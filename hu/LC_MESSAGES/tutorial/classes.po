# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2023
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-10 15:26+0000\n"
"PO-Revision-Date: 2023-05-24 02:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2023\n"
"Language-Team: Hungarian (https://app.transifex.com/python-doc/teams/5390/"
"hu/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: hu\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../tutorial/classes.rst:5
msgid "Classes"
msgstr "Osztályok"

#: ../../tutorial/classes.rst:7
msgid ""
"Classes provide a means of bundling data and functionality together.  "
"Creating a new class creates a new *type* of object, allowing new "
"*instances* of that type to be made.  Each class instance can have "
"attributes attached to it for maintaining its state.  Class instances can "
"also have methods (defined by its class) for modifying its state."
msgstr ""

#: ../../tutorial/classes.rst:13
msgid ""
"Compared with other programming languages, Python's class mechanism adds "
"classes with a minimum of new syntax and semantics.  It is a mixture of the "
"class mechanisms found in C++ and Modula-3.  Python classes provide all the "
"standard features of Object Oriented Programming: the class inheritance "
"mechanism allows multiple base classes, a derived class can override any "
"methods of its base class or classes, and a method can call the method of a "
"base class with the same name.  Objects can contain arbitrary amounts and "
"kinds of data.  As is true for modules, classes partake of the dynamic "
"nature of Python: they are created at runtime, and can be modified further "
"after creation."
msgstr ""
"Más nyelvekhez viszonyítva a Python osztálymechanizmusa a nyelvhez a lehető "
"legkevesebb új szintaxissal és szemantikával ad hozzá osztályokat. A Python "
"osztályok a C++--ban és a Modula-3--ban található osztálymechanizmusok "
"keveréke.  A Python osztályok rendelkeznek az objektumorientáltság minden "
"jellemzőjével: az öröklődési mechanizmus lehetővé teszi a több őstől való "
"származtatást;  a származtatott osztályok a szülők bármely metódusát felül "
"tudják írni; a metódusok ugyanazon a néven érhetik el a szülőosztály "
"metódusait.  Az objektumok tetszőleges számú és típusú adatot "
"tartalmazhatnak. Ahogy a modulok, úgy az osztályok is részt vesznek a Python "
"dinamikus természetében: futás közben létrehozhatóak, és tovább "
"módosíthatóak létrehozásuk után."

#: ../../tutorial/classes.rst:23
msgid ""
"In C++ terminology, normally class members (including the data members) are "
"*public* (except see below :ref:`tut-private`), and all member functions are "
"*virtual*.  As in Modula-3, there are no shorthands for referencing the "
"object's members from its methods: the method function is declared with an "
"explicit first argument representing the object, which is provided "
"implicitly by the call.  As in Smalltalk, classes themselves are objects.  "
"This provides semantics for importing and renaming.  Unlike C++ and "
"Modula-3, built-in types can be used as base classes for extension by the "
"user.  Also, like in C++, most built-in operators with special syntax "
"(arithmetic operators, subscripting etc.) can be redefined for class "
"instances."
msgstr ""
"C++ szóhasználattal élve az osztály minden eleme (beleértve az adattagokat "
"is) *publikus* (a kívételt lásd lejjebb :ref:`tut-private`), és minden "
"tagfüggvény *virtuális*.  A Modula-3--hoz hasonlóan nincsen rövidített "
"hivatkozás az objektum alkotóelemeire annak metódusaiból: az objektum "
"függvényeinek deklarálásakor első argumentumként az objektumot jelképező "
"változót adjuk meg, mely híváskor automatikusan átadásra kerül.  A Smalltalk-"
"hoz hasonlóan az osztályok önmaguk is objektumok. Ez teremt szemantikát az "
"importáláshoz és átnevezéshez.  A C++--tól és a Modula-3-tól eltérően a "
"beépített típusok  szülőosztályokként felhasználhatók. S végül a C++-hoz "
"hasonlóan legtöbb, egyéni szintaktikával bíró  beépített operátor "
"(aritmetikai műveletek, indexelés stb.) újradefiniálhatók az osztály "
"példányaiban."

#: ../../tutorial/classes.rst:34
msgid ""
"(Lacking universally accepted terminology to talk about classes, I will make "
"occasional use of Smalltalk and C++ terms.  I would use Modula-3 terms, "
"since its object-oriented semantics are closer to those of Python than C++, "
"but I expect that few readers have heard of it.)"
msgstr ""
"(Nem lévén általánosan elfogadott szóhasználat az osztályok témakörére, "
"alkalmanként Smalltalk és C++ kifejezéseket fogok használni. (Szerettem "
"volna Modula-3 kifejezéseket alkalmazni, mert annak jobban hasonlít az "
"objektum-orientáció-szemlélete a Pythonhoz, mint a C++-é,  de sejtésem "
"szerint kevés olvasó hallott erről a nyelvről.)"

#: ../../tutorial/classes.rst:43
msgid "A Word About Names and Objects"
msgstr "Pár szó a nevekről és objektumokról"

#: ../../tutorial/classes.rst:45
msgid ""
"Objects have individuality, and multiple names (in multiple scopes) can be "
"bound to the same object.  This is known as aliasing in other languages.  "
"This is usually not appreciated on a first glance at Python, and can be "
"safely ignored when dealing with immutable basic types (numbers, strings, "
"tuples).  However, aliasing has a possibly surprising effect on the "
"semantics of Python code involving mutable objects such as lists, "
"dictionaries, and most other types. This is usually used to the benefit of "
"the program, since aliases behave like pointers in some respects.  For "
"example, passing an object is cheap since only a pointer is passed by the "
"implementation; and if a function modifies an object passed as an argument, "
"the caller will see the change --- this eliminates the need for two "
"different argument passing mechanisms as in Pascal."
msgstr ""
"Az objektumoknak egyéni jellege van, és több nevet lehet kapcsolni "
"ugyanahhoz az objektumhoz (akár különböző névterekben). Ez a lehetőség "
"fedőnévhasználatként (aliasing) ismert más nyelvekben. Ezt a lehetőséget a "
"nyelvvel való első találkozáskor rendszerint nem becsülik meg, és nyugodtan "
"mellőzhető megváltoztathatatlan típusok használatakor (például számok, "
"karakterláncok, tuple-ok esetében).  Valójában a fedőnév használata "
"valószínűleg meglepő módon viselkedik megváltoztatható típusok esetében,  "
"mint például a listák, szótárak, és a legtöbb más típus esetén.  A fedőnevek "
"általában a program hasznára válnak, mivel a mutatókhoz hasonlítanak néhány "
"vonatkozásban. Például egy objektum átadása kevés erőforrásfelhasználással "
"jár, mivel ilyenkor csak egy mutató fog mutatni az objektumra. Ha a "
"meghívott függvény módosítja a neki átadott objektumot, a hívó látja a "
"változást -- ez szükségtelenné teszi két különböző argumentumátadási módszer "
"használatát, mint amilyen a Pascalnál van."

#: ../../tutorial/classes.rst:61
msgid "Python Scopes and Namespaces"
msgstr "Hatókörök és névterek a Pythonban"

#: ../../tutorial/classes.rst:63
msgid ""
"Before introducing classes, I first have to tell you something about "
"Python's scope rules.  Class definitions play some neat tricks with "
"namespaces, and you need to know how scopes and namespaces work to fully "
"understand what's going on. Incidentally, knowledge about this subject is "
"useful for any advanced Python programmer."
msgstr ""
"Mielőtt megismerkednénk az osztályokkal, beszélnünk kell a hatókörök "
"Pythonbeli szabályairól. Az osztálydefiníciók  néhány ügyesen trükköznek a "
"névterekkel, és ismerned kell a névterek és hatókörök működését ahhoz, hogy "
"teljesen átlásd, mi is történik. Egyébként ennek a témakörnek az ismerete "
"minden haladó Python programozónak a hasznára válik."

#: ../../tutorial/classes.rst:69
msgid "Let's begin with some definitions."
msgstr "Kezdetnek nézzünk meg néhány definíciót."

#: ../../tutorial/classes.rst:71
msgid ""
"A *namespace* is a mapping from names to objects.  Most namespaces are "
"currently implemented as Python dictionaries, but that's normally not "
"noticeable in any way (except for performance), and it may change in the "
"future.  Examples of namespaces are: the set of built-in names (containing "
"functions such as :func:`abs`, and built-in exception names); the global "
"names in a module; and the local names in a function invocation.  In a sense "
"the set of attributes of an object also form a namespace.  The important "
"thing to know about namespaces is that there is absolutely no relation "
"between names in different namespaces; for instance, two different modules "
"may both define a function ``maximize`` without confusion --- users of the "
"modules must prefix it with the module name."
msgstr ""
"A *névtér* a nevekhez objektumokat rendel. A legtöbb névtér jelenleg Python "
"szótárakként van megvalósítva, de ez (a teljesítmény kivételével) normális "
"esetben nem észlelhető, és ez a jövőben változhat. Példák a névterekre: a "
"beápített nevek listája (például az :func:`abs` függvény, vagy a beépített "
"kivételek nevei); a modulokban jelenlévő globális nevek; vagy a helyi nevek "
"függvényhívások során. Bizonyos értelemben egy objektum jellemzői is külön "
"névteret alkotnak. Fontos tudni, hogy különböző névterekben lévő két név "
"között semmilyen kapcsolat nem létezik.  Például ha két különböző modul "
"egyaránt definiálhat egy \"maximumalizal\" nevű függvényt bármilyen "
"keveredés nélkül, mert a modulok használóinak a függvénynév előtagjában a "
"modul nevével egyértelműen jelezniük kell, hogy pontosan melyik függvényt "
"fogják használni."

#: ../../tutorial/classes.rst:82
msgid ""
"By the way, I use the word *attribute* for any name following a dot --- for "
"example, in the expression ``z.real``, ``real`` is an attribute of the "
"object ``z``.  Strictly speaking, references to names in modules are "
"attribute references: in the expression ``modname.funcname``, ``modname`` is "
"a module object and ``funcname`` is an attribute of it.  In this case there "
"happens to be a straightforward mapping between the module's attributes and "
"the global names defined in the module: they share the same namespace!  [#]_"
msgstr ""
"Egyébként a *jellemző* szót használom bármilyen névre, ami pontot követ "
"jellemzője.  Szigorúan véve egy modulbeli névre való hivatkozás egy jellemző-"
"hivatkozás: a ``modulnev.fuggvenynev`` kifejezésben a ``modulnev`` egy modul "
"objektum és a ``fuggvenynev`` annak egy jellemzője.  Ebben az esetben "
"közvetlen hozzárendelés történik a modul jellemzői és a modulban definiált "
"globális nevek között: ezek ugyanazon a névtéren osztoznak. [#]_"

#: ../../tutorial/classes.rst:90
msgid ""
"Attributes may be read-only or writable.  In the latter case, assignment to "
"attributes is possible.  Module attributes are writable: you can write "
"``modname.the_answer = 42``.  Writable attributes may also be deleted with "
"the :keyword:`del` statement.  For example, ``del modname.the_answer`` will "
"remove the attribute :attr:`!the_answer` from the object named by "
"``modname``."
msgstr ""

#: ../../tutorial/classes.rst:96
msgid ""
"Namespaces are created at different moments and have different lifetimes.  "
"The namespace containing the built-in names is created when the Python "
"interpreter starts up, and is never deleted.  The global namespace for a "
"module is created when the module definition is read in; normally, module "
"namespaces also last until the interpreter quits.  The statements executed "
"by the top-level invocation of the interpreter, either read from a script "
"file or interactively, are considered part of a module called :mod:"
"`__main__`, so they have their own global namespace.  (The built-in names "
"actually also live in a module; this is called :mod:`builtins`.)"
msgstr ""
"A névterek különböző időpontokban születnek, és élettartamuk is változó. Az "
"a névtér, amely a Python értelmező beépített neveit tartalmazza, a Python-"
"értelmező indulásakor jön létre, és nem törölhető. A modulok globális "
"névtere a  moduldefiníció olvasásakor jön létre; általános esetben a  modul "
"névterek az értelmezőből való kilépésig megmaradnak. Az utasításokat, "
"amelyet az értelmező felső szintje futtat le, vagy egy szkriptfájlból "
"kiolvasva, vagy interaktív módon, azokat :mod:`__main__` modul részének "
"tekinti a Python, ezért saját névtérrel rendelkeznek. (A beépített nevek "
"szintén egy modulban léteznek, :mod:`builtins` név alatt.)"

#: ../../tutorial/classes.rst:106
msgid ""
"The local namespace for a function is created when the function is called, "
"and deleted when the function returns or raises an exception that is not "
"handled within the function.  (Actually, forgetting would be a better way to "
"describe what actually happens.)  Of course, recursive invocations each have "
"their own local namespace."
msgstr ""
"A függvények helyi névtere a függvény hívásakor keletkezik, és a függvény "
"lefutásakor, vagy a függvényben le nem kezelt kivételek létrejöttekor "
"szűnnek meg. (Talán a felejtés szó pontosabb kifejezés lenne arra, ami "
"történik.) Természetesen a rekurzív hívások mindegyike saját, helyi "
"névtérrel rendelkezik."

#: ../../tutorial/classes.rst:112
msgid ""
"A *scope* is a textual region of a Python program where a namespace is "
"directly accessible.  \"Directly accessible\" here means that an unqualified "
"reference to a name attempts to find the name in the namespace."
msgstr ""
"A *hatókör* (angolul scope) a Python kód azon szöveges része ahol a névtér "
"közvetlenül elérhető. A közvetlen elérhetőség itt azt  jelenti, hogy a név a "
"teljes elérési útjának kifejtése nélkül elérhető a névtérben. (például a ``z."
"real``-ben a . jelzi, hogy a  ``z`` objektumhoz tartozó jellemzőről van szó, "
"ez itt most teljesen kifejtett.)"

#: ../../tutorial/classes.rst:116
msgid ""
"Although scopes are determined statically, they are used dynamically. At any "
"time during execution, there are 3 or 4 nested scopes whose namespaces are "
"directly accessible:"
msgstr ""

#: ../../tutorial/classes.rst:120
msgid "the innermost scope, which is searched first, contains the local names"
msgstr ""
"a legbelső hatókör, amelyben először keresünk, a helyi neveket tartalmazza"

#: ../../tutorial/classes.rst:121
msgid ""
"the scopes of any enclosing functions, which are searched starting with the "
"nearest enclosing scope, contain non-local, but also non-global names"
msgstr ""

#: ../../tutorial/classes.rst:123
msgid "the next-to-last scope contains the current module's global names"
msgstr ""
"at utolsó előttiként vizsgált hatáskör az aktuális modul globális neveit "
"tartalmazza"

#: ../../tutorial/classes.rst:124
msgid ""
"the outermost scope (searched last) is the namespace containing built-in "
"names"
msgstr ""
"a legkülső (utolsónak vizsgált) hatókör a beépített neveket tartalmazó névtér"

#: ../../tutorial/classes.rst:126
msgid ""
"If a name is declared global, then all references and assignments go "
"directly to the next-to-last scope containing the module's global names.  To "
"rebind variables found outside of the innermost scope, the :keyword:"
"`nonlocal` statement can be used; if not declared nonlocal, those variables "
"are read-only (an attempt to write to such a variable will simply create a "
"*new* local variable in the innermost scope, leaving the identically named "
"outer variable unchanged)."
msgstr ""

#: ../../tutorial/classes.rst:133
msgid ""
"Usually, the local scope references the local names of the (textually) "
"current function.  Outside functions, the local scope references the same "
"namespace as the global scope: the module's namespace. Class definitions "
"place yet another namespace in the local scope."
msgstr ""
"Rendszerint a helyi hatókör a szövegkörnyezetben található helyi változókra "
"hivatkozik az aktuális függvényben. A függvényeken kívül a helyi hatókör "
"megegyezik a globális hatókörrel: a modul névtere. Az osztálydefiníciók "
"pedig még egy újabb névtereket helyeznek el a helyi hatókörben."

#: ../../tutorial/classes.rst:138
msgid ""
"It is important to realize that scopes are determined textually: the global "
"scope of a function defined in a module is that module's namespace, no "
"matter from where or by what alias the function is called.  On the other "
"hand, the actual search for names is done dynamically, at run time --- "
"however, the language definition is evolving towards static name resolution, "
"at \"compile\" time, so don't rely on dynamic name resolution!  (In fact, "
"local variables are already determined statically.)"
msgstr ""
"Fontos tudatosítani, hogy a hatókörök szövegkörnyezet által meghatározottak: "
"a modulban definiált függvény globális hatóköre a modul névtere, nem számít, "
"hogy hol és milyen fedőnévvel hívjuk meg a függvényt. Másrészről az aktuális "
"nevek keresése dinamikusan, futásidőben történik, -- a nyelvi definíció "
"akármennyire is törekszik a fordításkori, statikus névfeloldásra, szóval "
"hosszútávon ne számíts a dinamikus névfeloldásra! (Igazság szerint a helyi "
"változók mindig statikusan meghatározottak.)"

#: ../../tutorial/classes.rst:146
msgid ""
"A special quirk of Python is that -- if no :keyword:`global` or :keyword:"
"`nonlocal` statement is in effect -- assignments to names always go into the "
"innermost scope. Assignments do not copy data --- they just bind names to "
"objects.  The same is true for deletions: the statement ``del x`` removes "
"the binding of ``x`` from the namespace referenced by the local scope.  In "
"fact, all operations that introduce new names use the local scope: in "
"particular, :keyword:`import` statements and function definitions bind the "
"module or function name in the local scope."
msgstr ""

#: ../../tutorial/classes.rst:154
msgid ""
"The :keyword:`global` statement can be used to indicate that particular "
"variables live in the global scope and should be rebound there; the :keyword:"
"`nonlocal` statement indicates that particular variables live in an "
"enclosing scope and should be rebound there."
msgstr ""
"A :keyword:`global` kulcsszóval jelezheted hogy bizonyos változók a globális "
"névtérben léteznek és ott újra kell csatolni, a :keyword:`nonlocal` "
"kulcsszó  azt jelzi, hogy a szóban forgó változó a helyi hatókörhöz "
"tartozik, és ott kell újracsatolni."

#: ../../tutorial/classes.rst:162
msgid "Scopes and Namespaces Example"
msgstr "Hatókör és névtér példa"

#: ../../tutorial/classes.rst:164
msgid ""
"This is an example demonstrating how to reference the different scopes and "
"namespaces, and how :keyword:`global` and :keyword:`nonlocal` affect "
"variable binding::"
msgstr ""
"Itt van egy példa, amely bemutatja, hogyan lehet hivatkozni a különböző "
"hatókörökre és névterekre, és hogyan hat a :keyword:`global` és :keyword:"
"`nonlocal` a változócsatolásokra::"

#: ../../tutorial/classes.rst:191
msgid "The output of the example code is:"
msgstr "A példakód kimenete::"

#: ../../tutorial/classes.rst:200
msgid ""
"Note how the *local* assignment (which is default) didn't change "
"*scope_test*\\'s binding of *spam*.  The :keyword:`nonlocal` assignment "
"changed *scope_test*\\'s binding of *spam*, and the :keyword:`global` "
"assignment changed the module-level binding."
msgstr ""
"Jegyezd meg, hogy a *helyi* értékadás (amely az alapértelmezett) nem "
"változtatja meg a *scope_test* függvény  *spam* csatolását. A :keyword:"
"`nonlocal` értékadás a *scope_test* *spam* nevének csatolását változtatja "
"meg, a :keyword:`global`  értékadás pedig a modulszintű csatolást."

#: ../../tutorial/classes.rst:205
msgid ""
"You can also see that there was no previous binding for *spam* before the :"
"keyword:`global` assignment."
msgstr ""
"Azt is érdemes észrevenni, hogy nem csatoltunk értéket a *spam*-hez a  :"
"keyword:`global` értékadás előtt."

#: ../../tutorial/classes.rst:212
msgid "A First Look at Classes"
msgstr "Első találkozás az osztályokkal"

#: ../../tutorial/classes.rst:214
msgid ""
"Classes introduce a little bit of new syntax, three new object types, and "
"some new semantics."
msgstr ""
"Az osztályok használatához szükségünk van új szintaxisra: három új "
"objektumtípusra, és némi új szemantikára."

#: ../../tutorial/classes.rst:221
msgid "Class Definition Syntax"
msgstr "Az osztálydefiníció szinaxisa"

#: ../../tutorial/classes.rst:223
msgid "The simplest form of class definition looks like this::"
msgstr "A legegyszerűbb osztálydefiníció így néz ki::"

#: ../../tutorial/classes.rst:232
msgid ""
"Class definitions, like function definitions (:keyword:`def` statements) "
"must be executed before they have any effect.  (You could conceivably place "
"a class definition in a branch of an :keyword:`if` statement, or inside a "
"function.)"
msgstr ""
"Az osztálydefiníciók hasonlítanak a függvények definíciójára  (:keyword:"
"`def` statements) abból a szempontból, hogy az osztály  deklarációjának meg "
"kell előznie az első használatot. (Osztálydefiníciót elhelyzehetsz egy :"
"keyword:`if` utasítás valamely ágában is, vagy egy függvénybe beágyazva.)"

#: ../../tutorial/classes.rst:236
msgid ""
"In practice, the statements inside a class definition will usually be "
"function definitions, but other statements are allowed, and sometimes useful "
"--- we'll come back to this later.  The function definitions inside a class "
"normally have a peculiar form of argument list, dictated by the calling "
"conventions for methods --- again, this is explained later."
msgstr ""
"A gyakorlatban az osztályokon belüli utasítások többsége általában "
"függvénydefiníció, de bármilyen más utasítás is megengedett, és néha hasznos "
"is -- erre még később visszatérünk. Az osztályon belüli függvényeknek normál "
"esetben egyedi argumentumlistájuk (és  hívási módjuk) van az osztály "
"metódusainak hívására vontakozó megállapodás szerint --  ezt szintén később "
"fogjuk megvizsgálni."

#: ../../tutorial/classes.rst:242
msgid ""
"When a class definition is entered, a new namespace is created, and used as "
"the local scope --- thus, all assignments to local variables go into this "
"new namespace.  In particular, function definitions bind the name of the new "
"function here."
msgstr ""
"Egy osztálydefinícióba való belépéskor új névtér jön létre és válik a helyi "
"hatókörré -- ebből kifolyólag minden helyi változóra történő hivatkozás ebbe "
"az új névtérbe kerül. A gyakorlatban általában az új függvények csatolásai "
"kerülnek ide."

#: ../../tutorial/classes.rst:247
msgid ""
"When a class definition is left normally (via the end), a *class object* is "
"created.  This is basically a wrapper around the contents of the namespace "
"created by the class definition; we'll learn more about class objects in the "
"next section.  The original local scope (the one in effect just before the "
"class definition was entered) is reinstated, and the class object is bound "
"here to the class name given in the class definition header (:class:`!"
"ClassName` in the example)."
msgstr ""

#: ../../tutorial/classes.rst:259
msgid "Class Objects"
msgstr "Osztályobjektumok"

#: ../../tutorial/classes.rst:261
msgid ""
"Class objects support two kinds of operations: attribute references and "
"instantiation."
msgstr ""
"Az osztályobjektumok a műveletek kétféle típusát támogatják: a "
"jellemzőhivatkozást és a példányosítás."

#: ../../tutorial/classes.rst:264
msgid ""
"*Attribute references* use the standard syntax used for all attribute "
"references in Python: ``obj.name``.  Valid attribute names are all the names "
"that were in the class's namespace when the class object was created.  So, "
"if the class definition looked like this::"
msgstr ""
"A *jellemzőhivatkozások* az általánosan használt Python jelölésmódot "
"használják: ``objektum.jellemzőnév``. Az összes név érvényes jellemzőnév ami "
"az osztály névterében volt az osztályobjektum létrehozásakor. Ha egy osztály "
"definíció valahogy így néz ki::"

#: ../../tutorial/classes.rst:276
msgid ""
"then ``MyClass.i`` and ``MyClass.f`` are valid attribute references, "
"returning an integer and a function object, respectively. Class attributes "
"can also be assigned to, so you can change the value of ``MyClass.i`` by "
"assignment. :attr:`!__doc__` is also a valid attribute, returning the "
"docstring belonging to the class: ``\"A simple example class\"``."
msgstr ""

#: ../../tutorial/classes.rst:282
msgid ""
"Class *instantiation* uses function notation.  Just pretend that the class "
"object is a parameterless function that returns a new instance of the class. "
"For example (assuming the above class)::"
msgstr ""
"Egy osztály *példányosítása* a függvények jelölésmódját használja. "
"Egyszerűen úgy kell tenni, mintha az osztályobjektum egy argumentum nélküli "
"függvény lenne, amit meghívva az osztály egy új példányát kapjuk "
"visszatérési értékként. Például (a fenti osztályt alapul véve)::"

#: ../../tutorial/classes.rst:288
msgid ""
"creates a new *instance* of the class and assigns this object to the local "
"variable ``x``."
msgstr ""
"létrehoz egy új *példányt* az osztályból, és hozzárendeli a visszatérési "
"értékként kapott objektumot az ``x`` helyi változóhoz."

#: ../../tutorial/classes.rst:291
msgid ""
"The instantiation operation (\"calling\" a class object) creates an empty "
"object. Many classes like to create objects with instances customized to a "
"specific initial state. Therefore a class may define a special method named :"
"meth:`~object.__init__`, like this::"
msgstr ""

#: ../../tutorial/classes.rst:299
msgid ""
"When a class defines an :meth:`~object.__init__` method, class instantiation "
"automatically invokes :meth:`!__init__` for the newly created class "
"instance.  So in this example, a new, initialized instance can be obtained "
"by::"
msgstr ""

#: ../../tutorial/classes.rst:305
msgid ""
"Of course, the :meth:`~object.__init__` method may have arguments for "
"greater flexibility.  In that case, arguments given to the class "
"instantiation operator are passed on to :meth:`!__init__`.  For example, ::"
msgstr ""

#: ../../tutorial/classes.rst:322
msgid "Instance Objects"
msgstr "A létrehozott egyedek"

#: ../../tutorial/classes.rst:324
msgid ""
"Now what can we do with instance objects?  The only operations understood by "
"instance objects are attribute references.  There are two kinds of valid "
"attribute names: data attributes and methods."
msgstr ""

#: ../../tutorial/classes.rst:328
msgid ""
"*data attributes* correspond to \"instance variables\" in Smalltalk, and to "
"\"data members\" in C++.  Data attributes need not be declared; like local "
"variables, they spring into existence when they are first assigned to.  For "
"example, if ``x`` is the instance of :class:`!MyClass` created above, the "
"following piece of code will print the value ``16``, without leaving a "
"trace::"
msgstr ""

#: ../../tutorial/classes.rst:340
msgid ""
"The other kind of instance attribute reference is a *method*. A method is a "
"function that \"belongs to\" an object.  (In Python, the term method is not "
"unique to class instances: other object types can have methods as well.  For "
"example, list objects have methods called append, insert, remove, sort, and "
"so on. However, in the following discussion, we'll use the term method "
"exclusively to mean methods of class instance objects, unless explicitly "
"stated otherwise.)"
msgstr ""
"A másik fajta jellemző a metódus (más néven tagfüggvény). A metódus egy "
"objektumhoz ,,tartozó'' függvényt jelöl.  (A Pythonban a metódus kifejezés "
"nem kizárólag egy osztály példányának metódusát jelenti -- más objektum "
"típusok is rendelkezhetnek metódusokkal. Például a listaobjektumoknak vannak "
"saját metódusai: append, insert, remove, sort, és így tovább. Az alábbi "
"sorokban a metódus kifejezést kizárólag egy osztály metódusaira értjük, "
"hacsak nincs külön kihangsúlyozva, hogy most egy másik objektum metódusáról "
"van szó."

#: ../../tutorial/classes.rst:349
msgid ""
"Valid method names of an instance object depend on its class.  By "
"definition, all attributes of a class that are function  objects define "
"corresponding methods of its instances.  So in our example, ``x.f`` is a "
"valid method reference, since ``MyClass.f`` is a function, but ``x.i`` is "
"not, since ``MyClass.i`` is not.  But ``x.f`` is not the same thing as "
"``MyClass.f`` --- it is a *method object*, not a function object."
msgstr ""
"A létrehozott objektum metódusainak neve az osztályától függ. Meghatározás "
"szerint minden felhasználó által definiált metódust az adott (létező) "
"példány nevével kell hívni.  Például ``x.f`` egy érvényes "
"függvényhivatkozás, ha az ``Osztalyom.f`` függvény létezik (``x`` objektum "
"az ``Osztalyom`` példánya), de ``x.i`` nem érvényes ha ``Osztalyom.i`` "
"változót nem hoztuk létre az osztály definiálásakor. Fontos, hogy  ``x.f`` "
"nem ugyanaz, mint ``Osztalyom.f`` --- ez egy *metódusobjektum*, nem egy "
"függvényobjektum."

#: ../../tutorial/classes.rst:360
msgid "Method Objects"
msgstr "Az metódusobjektumok"

#: ../../tutorial/classes.rst:362
msgid "Usually, a method is called right after it is bound::"
msgstr "Többnyire a metódusokat rögtön meghívjuk::"

#: ../../tutorial/classes.rst:366
msgid ""
"In the :class:`!MyClass` example, this will return the string ``'hello "
"world'``. However, it is not necessary to call a method right away: ``x.f`` "
"is a method object, and can be stored away and called at a later time.  For "
"example::"
msgstr ""

#: ../../tutorial/classes.rst:374
msgid "will continue to print ``hello world`` until the end of time."
msgstr "Ez a kód az örökkévalóságig a ``hello világ`` üzenetet írja ki."

#: ../../tutorial/classes.rst:376
msgid ""
"What exactly happens when a method is called?  You may have noticed that ``x."
"f()`` was called without an argument above, even though the function "
"definition for :meth:`!f` specified an argument.  What happened to the "
"argument? Surely Python raises an exception when a function that requires an "
"argument is called without any --- even if the argument isn't actually "
"used..."
msgstr ""

#: ../../tutorial/classes.rst:382
msgid ""
"Actually, you may have guessed the answer: the special thing about methods "
"is that the instance object is passed as the first argument of the "
"function.  In our example, the call ``x.f()`` is exactly equivalent to "
"``MyClass.f(x)``.  In general, calling a method with a list of *n* arguments "
"is equivalent to calling the corresponding function with an argument list "
"that is created by inserting the method's instance object before the first "
"argument."
msgstr ""
"Lehet hogy már kitaláltad a választ: az a különleges a metódusokban, hogy "
"hívásukkor az őket tartalmazó osztálypéldányt megkapják az első változóban. "
"A példánkban ``x.f()`` hívása pontosan ugyanaz, mintha ``Osztalyom.f(x)`` "
"metódust hívnánk. Általában metódusok hívása *n* argumentummal ugyanaz, "
"mintha az osztálydefiníció függvényét hívnánk meg úgy, hogy a legelső "
"argumentum elé az aktuális példány nevét beillesztjük."

#: ../../tutorial/classes.rst:389
msgid ""
"In general, methods work as follows.  When a non-data attribute of an "
"instance is referenced, the instance's class is searched. If the name "
"denotes a valid class attribute that is a function object, references to "
"both the instance object and the function object are packed into a method "
"object.  When the method object is called with an argument list, a new "
"argument list is constructed from the instance object and the argument list, "
"and the function object is called with this new argument list."
msgstr ""

#: ../../tutorial/classes.rst:402
msgid "Class and Instance Variables"
msgstr ""

#: ../../tutorial/classes.rst:404
msgid ""
"Generally speaking, instance variables are for data unique to each instance "
"and class variables are for attributes and methods shared by all instances "
"of the class::"
msgstr ""

#: ../../tutorial/classes.rst:426
msgid ""
"As discussed in :ref:`tut-object`, shared data can have possibly surprising "
"effects with involving :term:`mutable` objects such as lists and "
"dictionaries. For example, the *tricks* list in the following code should "
"not be used as a class variable because just a single list would be shared "
"by all *Dog* instances::"
msgstr ""

#: ../../tutorial/classes.rst:449
msgid "Correct design of the class should use an instance variable instead::"
msgstr ""

#: ../../tutorial/classes.rst:473
msgid "Random Remarks"
msgstr "Pár megjegyzés"

#: ../../tutorial/classes.rst:477
msgid ""
"If the same attribute name occurs in both an instance and in a class, then "
"attribute lookup prioritizes the instance::"
msgstr ""

#: ../../tutorial/classes.rst:492
msgid ""
"Data attributes may be referenced by methods as well as by ordinary users "
"(\"clients\") of an object.  In other words, classes are not usable to "
"implement pure abstract data types.  In fact, nothing in Python makes it "
"possible to enforce data hiding --- it is all based upon convention.  (On "
"the other hand, the Python implementation, written in C, can completely hide "
"implementation details and control access to an object if necessary; this "
"can be used by extensions to Python written in C.)"
msgstr ""
"Az adatjellemzőkre a metódusok is hivatkozhatnak, éppúgy mint az  objektum "
"hagyományos felhasználói. Más szavakkal az osztályok nem használhatók "
"csupasz absztrakt adattípusok megvalósítására. Valójában a Pythonban "
"jelenleg semmi sincs, ami az adatrejtés elvét biztosítani tudná -- minden az "
"elnevezési konvenciókra épül. Másrészről az eredeti C alapú Python képes "
"teljesen elrejteni a megvalósítási  részleteket és ellenőrizni az objektum "
"elérését, ha szükséges; ehhez egy C nyelven írt kiegészítést kell használni."

#: ../../tutorial/classes.rst:500
msgid ""
"Clients should use data attributes with care --- clients may mess up "
"invariants maintained by the methods by stamping on their data attributes.  "
"Note that clients may add data attributes of their own to an instance object "
"without affecting the validity of the methods, as long as name conflicts are "
"avoided --- again, a naming convention can save a lot of headaches here."
msgstr ""
"A kliensek az adatjellemzőket csak óvatosan használhatják, mert elronthatják "
"azokat a variánsokat, amelyeket olyan eljárások tartanak karban, amelyek "
"időpontbélyeggel dolgoznak. Az objektum felhasználói saját adatjellemzőiket "
"bármiféle ellenőrzés nélkül hozzáadhatják az objektumokhoz amíg ezzel nem "
"okoznak névütközést -- az elnevezési konvenciók használatával elég sok "
"fejfájástól megszabadulhatunk!"

#: ../../tutorial/classes.rst:506
msgid ""
"There is no shorthand for referencing data attributes (or other methods!) "
"from within methods.  I find that this actually increases the readability of "
"methods: there is no chance of confusing local variables and instance "
"variables when glancing through a method."
msgstr ""
"A metódusokban nem használhatunk rövidítést az adatjellemzőkre (vagy más "
"metódusokra). Én úgy látom, hogy ez növeli a metódusok olvashatóságát, és "
"nem hagy esélyt a helyi és a példányosított változók összekeverésére, mikor "
"a metódus forráskódját olvassuk."

#: ../../tutorial/classes.rst:511
msgid ""
"Often, the first argument of a method is called ``self``.  This is nothing "
"more than a convention: the name ``self`` has absolutely no special meaning "
"to Python.  Note, however, that by not following the convention your code "
"may be less readable to other Python programmers, and it is also conceivable "
"that a *class browser* program might be written that relies upon such a "
"convention."
msgstr ""
"A hagyományokhoz hűen a metódusok első argumentumának neve rendszerint  "
"``self``. Ez valóban csak egy szokás: a ``self`` névnek semmilyen speciális "
"jelentése nincs a Pythonban. Azért vegyük figyelembe, hogy ha eltérünk a "
"hagyományoktól, akkor a program nehezebben olvashatóvá válik, és a "
"*osztályböngésző* is a tradicionális változónevet használja."

#: ../../tutorial/classes.rst:517
msgid ""
"Any function object that is a class attribute defines a method for instances "
"of that class.  It is not necessary that the function definition is "
"textually enclosed in the class definition: assigning a function object to a "
"local variable in the class is also ok.  For example::"
msgstr ""
"Az osztály definíciójában megadott függvények az osztály példányai  számára "
"hoznak létre metódusokat (a példányhoz tartozó függvényeket). Nem "
"szükségszerű azonban hogy egy függvénydefiníció kódja az osztálydefiníció "
"része legyen: egy definíción kívüli függvény helyi változóhoz való rendelése "
"is megfelel a célnak. Például::"

#: ../../tutorial/classes.rst:534
msgid ""
"Now ``f``, ``g`` and ``h`` are all attributes of class :class:`!C` that "
"refer to function objects, and consequently they are all methods of "
"instances of :class:`!C` --- ``h`` being exactly equivalent to ``g``.  Note "
"that this practice usually only serves to confuse the reader of a program."
msgstr ""

#: ../../tutorial/classes.rst:539
msgid ""
"Methods may call other methods by using method attributes of the ``self`` "
"argument::"
msgstr ""
"Az osztályon belüli metódusok egymást is hívhatják  a ``self`` argumentum "
"használatával::"

#: ../../tutorial/classes.rst:553
msgid ""
"Methods may reference global names in the same way as ordinary functions.  "
"The global scope associated with a method is the module containing its "
"definition.  (A class is never used as a global scope.)  While one rarely "
"encounters a good reason for using global data in a method, there are many "
"legitimate uses of the global scope: for one thing, functions and modules "
"imported into the global scope can be used by methods, as well as functions "
"and classes defined in it.  Usually, the class containing the method is "
"itself defined in this global scope, and in the next section we'll find some "
"good reasons why a method would want to reference its own class."
msgstr ""
"A metódusok a globális névtérben lévő függvényekre is hasonlóképp "
"hivatkozhatnak. (Maguk az osztálydefiníciók soha nem részei a globális "
"névtérnek!)  Míg egy kivételes esetben a globális névtér változóinak "
"használata jól jöhet, több esetben is jól jöhet a globális névtér elérése: a "
"globális névtérbe importált függvényeket és modulokat az adott "
"osztálymetódusból is használhatjuk, mintha az  adott függvényben vagy "
"osztályban definiálták volna azokat. Rendszerint az osztály az önmaga által "
"definiált metódust a globális névtérben tartja, és a következő részben "
"meglátjuk majd, miért jó ha a metódusok a saját osztályukra hivatkozhatnak!"

#: ../../tutorial/classes.rst:563
msgid ""
"Each value is an object, and therefore has a *class* (also called its "
"*type*). It is stored as ``object.__class__``."
msgstr ""

#: ../../tutorial/classes.rst:570
msgid "Inheritance"
msgstr "Öröklés"

#: ../../tutorial/classes.rst:572
msgid ""
"Of course, a language feature would not be worthy of the name \"class\" "
"without supporting inheritance.  The syntax for a derived class definition "
"looks like this::"
msgstr ""
"Természetesen az öröklés támogatása nélkül nem sok értelme lenne az "
"osztályok használatának. A származtatott osztályok definíciója a "
"következőképpen néz ki::"

#: ../../tutorial/classes.rst:583
msgid ""
"The name :class:`!BaseClassName` must be defined in a scope containing the "
"derived class definition.  In place of a base class name, other arbitrary "
"expressions are also allowed.  This can be useful, for example, when the "
"base class is defined in another module::"
msgstr ""

#: ../../tutorial/classes.rst:590
msgid ""
"Execution of a derived class definition proceeds the same as for a base "
"class. When the class object is constructed, the base class is remembered.  "
"This is used for resolving attribute references: if a requested attribute is "
"not found in the class, the search proceeds to look in the base class.  This "
"rule is applied recursively if the base class itself is derived from some "
"other class."
msgstr ""
"A származtatott osztály definíciójának feldolgozása hasonló a "
"szülőosztályokéhoz. Az osztályobjektum a létrehozásakor megjegyzi a "
"szülőosztályt. Ezt használjuk arra, hogy feloldjuk a jellemzőkre történő "
"hivatkozásokat: ha a keresett jellemző nincs jelen az osztályban, a keresés "
"a szülőosztályban folytatódik. Ez a szabályt alkalmazza a Python rekurzívan, "
"hogyha a szülőosztály maga is származtatott osztálya egy másik osztálynak."

#: ../../tutorial/classes.rst:596
msgid ""
"There's nothing special about instantiation of derived classes: "
"``DerivedClassName()`` creates a new instance of the class.  Method "
"references are resolved as follows: the corresponding class attribute is "
"searched, descending down the chain of base classes if necessary, and the "
"method reference is valid if this yields a function object."
msgstr ""
"A származtatott osztályok példányosításában nincs semmi különleges: "
"``SzarmaztatottOsztalyNeve()`` létrehozza az osztály új példányát. A metódus-"
"hivatkozások feloldása a következőképpen történik: a megfelelő osztály "
"jellemzőjét keresi meg, ha szükséges végigkutatva a szülőosztályok láncát, "
"és ha a talált jellemző egy függvény, akkor a metódus-hivatkozás érvényes."

#: ../../tutorial/classes.rst:602
msgid ""
"Derived classes may override methods of their base classes.  Because methods "
"have no special privileges when calling other methods of the same object, a "
"method of a base class that calls another method defined in the same base "
"class may end up calling a method of a derived class that overrides it.  "
"(For C++ programmers: all methods in Python are effectively ``virtual``.)"
msgstr ""
"A származtatott osztályok felülírhatják a szülőosztályok metódusait. Mivel a "
"metódusoknak nincsenek különleges előjogaik, amikor ugyanannak az "
"objektumnak más metódusát hívják, ezért a szülőosztályban definiált egyik "
"metódus, amely egy szintén a szülőosztályban definiált másik metódust hívná "
"eredetileg, lehet, hogy a származtatott osztály által felülírt metódust "
"fogja meghívni.  (C++ programozóknak: a Pythonban lényegében minden metódus "
"``virtual``.)"

#: ../../tutorial/classes.rst:608
msgid ""
"An overriding method in a derived class may in fact want to extend rather "
"than simply replace the base class method of the same name. There is a "
"simple way to call the base class method directly: just call ``BaseClassName."
"methodname(self, arguments)``.  This is occasionally useful to clients as "
"well.  (Note that this only works if the base class is accessible as "
"``BaseClassName`` in the global scope.)"
msgstr ""
"A származtatott osztály metódusa, amely felülírja a szülőosztály egy "
"metódusát, valójában inkább kiterjeszti az eredeti metódust, és nem "
"egyszerűen csak kicseréli. A szülőosztály metódusára így hivatkozhatunk: "
"``SzuloOsztalyNev.metodusnev(self, argumentumok)``. Ez néha jól jöhet.  "
"(Fontos, hogy ez csak akkor működik, ha a szülőosztály a globális névtérben "
"lett létrehozva, vagy közvetlenül beimportálva.)"

#: ../../tutorial/classes.rst:615
msgid "Python has two built-in functions that work with inheritance:"
msgstr ""

#: ../../tutorial/classes.rst:617
msgid ""
"Use :func:`isinstance` to check an instance's type: ``isinstance(obj, int)`` "
"will be ``True`` only if ``obj.__class__`` is :class:`int` or some class "
"derived from :class:`int`."
msgstr ""

#: ../../tutorial/classes.rst:621
msgid ""
"Use :func:`issubclass` to check class inheritance: ``issubclass(bool, int)`` "
"is ``True`` since :class:`bool` is a subclass of :class:`int`.  However, "
"``issubclass(float, int)`` is ``False`` since :class:`float` is not a "
"subclass of :class:`int`."
msgstr ""

#: ../../tutorial/classes.rst:631
msgid "Multiple Inheritance"
msgstr "Többszörös öröklés"

#: ../../tutorial/classes.rst:633
msgid ""
"Python supports a form of multiple inheritance as well.  A class definition "
"with multiple base classes looks like this::"
msgstr ""
"A Python támogatja a többszörös öröklést egy formáját is. Egy több "
"szülőosztályból származtatott osztály definíciója a következőképp néz ki::"

#: ../../tutorial/classes.rst:643
msgid ""
"For most purposes, in the simplest cases, you can think of the search for "
"attributes inherited from a parent class as depth-first, left-to-right, not "
"searching twice in the same class where there is an overlap in the "
"hierarchy. Thus, if an attribute is not found in :class:`!DerivedClassName`, "
"it is searched for in :class:`!Base1`, then (recursively) in the base "
"classes of :class:`!Base1`, and if it was not found there, it was searched "
"for in :class:`!Base2`, and so on."
msgstr ""

#: ../../tutorial/classes.rst:650
msgid ""
"In fact, it is slightly more complex than that; the method resolution order "
"changes dynamically to support cooperative calls to :func:`super`.  This "
"approach is known in some other multiple-inheritance languages as call-next-"
"method and is more powerful than the super call found in single-inheritance "
"languages."
msgstr ""
"Néhányan első pillanatban arra gondolnak, hogy a :class:`Szulo2`-ben és a :"
"class:`Szulo3`-ban kellene előbb keresni, a :class:`Szulo1` előtt --- "
"mondván hogy ez természetesebb lenne. Ez az elgondolás viszont igényli annak "
"ismeretét, hogy mely jellemzőt  definiáltak a :class:`Szulo1`-ben vagy annak "
"egyik szülőosztályában, és csak ezután tudod elkerülni a :class:`Szulo2`-ben "
"lévő névütközéseket. A mélyebb először szabály nem tesz különbséget a "
"helyben definiált és öröklött változók között."

#: ../../tutorial/classes.rst:656
msgid ""
"Dynamic ordering is necessary because all cases of multiple inheritance "
"exhibit one or more diamond relationships (where at least one of the parent "
"classes can be accessed through multiple paths from the bottommost class).  "
"For example, all classes inherit from :class:`object`, so any case of "
"multiple inheritance provides more than one path to reach :class:`object`.  "
"To keep the base classes from being accessed more than once, the dynamic "
"algorithm linearizes the search order in a way that preserves the left-to-"
"right ordering specified in each class, that calls each parent only once, "
"and that is monotonic (meaning that a class can be subclassed without "
"affecting the precedence order of its parents). Taken together, these "
"properties make it possible to design reliable and extensible classes with "
"multiple inheritance.  For more detail, see https://www.python.org/download/"
"releases/2.3/mro/."
msgstr ""
"Ezekből gondolom már látszik, hogy az átgondolatlanul használt többszörös "
"öröklődés a program karbantartását rémálommá teheti -- a névütközések "
"elkerülése végett pedig a Python csak a konvenciókra támaszkodhat.  A "
"többszörös öröklés egyik jól ismert problémája ha a gyermekosztály két "
"szülőosztályának egy közös nagyszülő osztálya van. Ugyan egyszerű kitalálni "
"hogy mi történik ebben az esetben (a nagyszülő adat jellemzőinek "
"egypéldányos változatát használja a gyermek) -- az még nem tisztázott, hogy "
"ez a nyelvi kifejezésmód minden esetben használható-e. További részletekért "
"lásd https://www.python.org/download/releases/2.3/mro/."

#: ../../tutorial/classes.rst:673
msgid "Private Variables"
msgstr "Privát változók"

#: ../../tutorial/classes.rst:675
msgid ""
"\"Private\" instance variables that cannot be accessed except from inside an "
"object don't exist in Python.  However, there is a convention that is "
"followed by most Python code: a name prefixed with an underscore (e.g. "
"``_spam``) should be treated as a non-public part of the API (whether it is "
"a function, a method or a data member).  It should be considered an "
"implementation detail and subject to change without notice."
msgstr ""
"Egyedi azonosítók létrehozását az osztályokhoz a Python korlátozottan "
"támogatja. Bármely azonosító, amely így néz ki: ``__spam``  (legalább két "
"bevezető alsóvonás, amit legfeljebb egy alsóvonás követhet) szövegesen "
"kicserélődik a ``_classname__spam`` formára, ahol a  ``classname`` az "
"aktuális osztály neve egy alsóvonással bevezetve. Ez a csere végrehajtódik "
"az azonosító pozíciójára való tekintet nélkül, úgyhogy használható osztály-"
"egyedi példányok, osztályváltozók, metódusok  definiálására ---  még akkor "
"is, ha más osztályok példányait saját privát változói közé veszi fel (???"
"Ford: ellenőrizni!)"

#: ../../tutorial/classes.rst:685
msgid ""
"Since there is a valid use-case for class-private members (namely to avoid "
"name clashes of names with names defined by subclasses), there is limited "
"support for such a mechanism, called :dfn:`name mangling`.  Any identifier "
"of the form ``__spam`` (at least two leading underscores, at most one "
"trailing underscore) is textually replaced with ``_classname__spam``, where "
"``classname`` is the current class name with leading underscore(s) "
"stripped.  This mangling is done without regard to the syntactic position of "
"the identifier, as long as it occurs within the definition of a class."
msgstr ""
"Ha a cserélt név hosszabb mint 255 karakter, az értelmező  csonkíthatja az "
"új nevet.  Külső osztályoknál, vagy ahol az osztálynév következetesen "
"alsóvonásokból áll??? nem történik csonkítás.   A névcsonkítás célja az, "
"hogy az osztályoknak egyszerű megoldást biztosítson a \"private\" változók "
"és metódusok definiálására --- anélkül, hogy aggódnunk kellene a "
"származtatott osztályokban megjelenő privát változók miatt, vagy esetleg a "
"származtatott osztályban már meglévő változó privát változóval való "
"felülírása miatt. Fontos tudni, hogy a névcsonkítási szabályok elsősorban a "
"problémák  elkerülését célozzák meg --- így még mindig leheséges annak, aki "
"nagyon akarja, hogy elérje vagy módosítsa a privátnak tartott változókat."

#: ../../tutorial/classes.rst:694
msgid ""
"Name mangling is helpful for letting subclasses override methods without "
"breaking intraclass method calls.  For example::"
msgstr ""

#: ../../tutorial/classes.rst:716
msgid ""
"The above example would work even if ``MappingSubclass`` were to introduce a "
"``__update`` identifier since it is replaced with ``_Mapping__update`` in "
"the ``Mapping`` class  and ``_MappingSubclass__update`` in the "
"``MappingSubclass`` class respectively."
msgstr ""

#: ../../tutorial/classes.rst:721
msgid ""
"Note that the mangling rules are designed mostly to avoid accidents; it "
"still is possible to access or modify a variable that is considered "
"private.  This can even be useful in special circumstances, such as in the "
"debugger."
msgstr ""

#: ../../tutorial/classes.rst:725
msgid ""
"Notice that code passed to ``exec()`` or ``eval()`` does not consider the "
"classname of the invoking class to be the current class; this is similar to "
"the effect of the ``global`` statement, the effect of which is likewise "
"restricted to code that is byte-compiled together.  The same restriction "
"applies to ``getattr()``, ``setattr()`` and ``delattr()``, as well as when "
"referencing ``__dict__`` directly."
msgstr ""
"Fontos, hogy a  ``exec``, ``eval()`` vagy ``evalfile()`` által végrehajtott "
"kód nem veszi figyelembe a hívó osztály nevét az aktuális osztály esetében "
"--- ez hasonló a ``global`` változók működéséhez, előre lefordított byte-kód "
"esetében. Hasonló korlátozások léteznek a ``getattr()``, ``setattr()`` és "
"``delattr()`` esetében, ha közvetlenül hívják meg a ``__dict__`` utasítást."

#: ../../tutorial/classes.rst:736
msgid "Odds and Ends"
msgstr "Egyebek..."

#: ../../tutorial/classes.rst:738
msgid ""
"Sometimes it is useful to have a data type similar to the Pascal \"record\" "
"or C \"struct\", bundling together a few named data items. The idiomatic "
"approach is to use :mod:`dataclasses` for this purpose::"
msgstr ""

#: ../../tutorial/classes.rst:758
msgid ""
"A piece of Python code that expects a particular abstract data type can "
"often be passed a class that emulates the methods of that data type "
"instead.  For instance, if you have a function that formats some data from a "
"file object, you can define a class with methods :meth:`~io.TextIOBase.read` "
"and :meth:`~io.TextIOBase.readline` that get the data from a string buffer "
"instead, and pass it as an argument."
msgstr ""

#: ../../tutorial/classes.rst:770
msgid ""
":ref:`Instance method objects <instance-methods>` have attributes, too: :"
"attr:`m.__self__ <method.__self__>` is the instance object with the method :"
"meth:`!m`, and :attr:`m.__func__ <method.__func__>` is the :ref:`function "
"object <user-defined-funcs>` corresponding to the method."
msgstr ""

#: ../../tutorial/classes.rst:780
msgid "Iterators"
msgstr "Iterátorok"

#: ../../tutorial/classes.rst:782
msgid ""
"By now you have probably noticed that most container objects can be looped "
"over using a :keyword:`for` statement::"
msgstr ""
"Valószínűleg már észrevetted, hogy a legtöbb tárolóobjektum bejárható a :"
"keyword:`for` ciklusutasítás használatával::"

#: ../../tutorial/classes.rst:796
msgid ""
"This style of access is clear, concise, and convenient.  The use of "
"iterators pervades and unifies Python.  Behind the scenes, the :keyword:"
"`for` statement calls :func:`iter` on the container object.  The function "
"returns an iterator object that defines the method :meth:`~iterator."
"__next__` which accesses elements in the container one at a time.  When "
"there are no more elements, :meth:`~iterator.__next__` raises a :exc:"
"`StopIteration` exception which tells the :keyword:`!for` loop to "
"terminate.  You can call the :meth:`~iterator.__next__` method using the :"
"func:`next` built-in function; this example shows how it all works::"
msgstr ""

#: ../../tutorial/classes.rst:821
msgid ""
"Having seen the mechanics behind the iterator protocol, it is easy to add "
"iterator behavior to your classes.  Define an :meth:`~container.__iter__` "
"method which returns an object with a :meth:`~iterator.__next__` method.  If "
"the class defines :meth:`!__next__`, then :meth:`!__iter__` can just return "
"``self``::"
msgstr ""

#: ../../tutorial/classes.rst:858
msgid "Generators"
msgstr "Generátorok"

#: ../../tutorial/classes.rst:860
msgid ""
":term:`Generators <generator>` are a simple and powerful tool for creating "
"iterators.  They are written like regular functions but use the :keyword:"
"`yield` statement whenever they want to return data.  Each time :func:`next` "
"is called on it, the generator resumes where it left off (it remembers all "
"the data values and which statement was last executed).  An example shows "
"that generators can be trivially easy to create::"
msgstr ""

#: ../../tutorial/classes.rst:881
msgid ""
"Anything that can be done with generators can also be done with class-based "
"iterators as described in the previous section.  What makes generators so "
"compact is that the :meth:`~iterator.__iter__` and :meth:`~generator."
"__next__` methods are created automatically."
msgstr ""

#: ../../tutorial/classes.rst:886
msgid ""
"Another key feature is that the local variables and execution state are "
"automatically saved between calls.  This made the function easier to write "
"and much more clear than an approach using instance variables like ``self."
"index`` and ``self.data``."
msgstr ""
"Egy másik fontos lehetőség hogy a helyi változók, és a végrehajtás állapota "
"automatikusan tárolódik a generátor két futása között."

#: ../../tutorial/classes.rst:891
msgid ""
"In addition to automatic method creation and saving program state, when "
"generators terminate, they automatically raise :exc:`StopIteration`. In "
"combination, these features make it easy to create iterators with no more "
"effort than writing a regular function."
msgstr ""
"Az automatikus metóduslétrehozáson és programállapot-mentésen felül, amikor "
"a generátor futása megszakad, ez az esemény automatikusan :exc:"
"`StopIteration` kivételt vált ki.  Egymással kombinálva ezek a nyelvi "
"szolgáltatások egyszerűvé teszik az iterátorok készítését néhány függvény "
"megírásának megfelelő -- viszonylag kis erőfeszítéssel."

#: ../../tutorial/classes.rst:900
msgid "Generator Expressions"
msgstr "Generátorkifejezések"

#: ../../tutorial/classes.rst:902
msgid ""
"Some simple generators can be coded succinctly as expressions using a syntax "
"similar to list comprehensions but with parentheses instead of square "
"brackets. These expressions are designed for situations where the generator "
"is used right away by an enclosing function.  Generator expressions are more "
"compact but less versatile than full generator definitions and tend to be "
"more memory friendly than equivalent list comprehensions."
msgstr ""

#: ../../tutorial/classes.rst:909
msgid "Examples::"
msgstr "Példák::"

#: ../../tutorial/classes.rst:930
msgid "Footnotes"
msgstr "Lábjegyzet"

#: ../../tutorial/classes.rst:931
msgid ""
"Except for one thing.  Module objects have a secret read-only attribute "
"called :attr:`~object.__dict__` which returns the dictionary used to "
"implement the module's namespace; the name :attr:`~object.__dict__` is an "
"attribute but not a global name. Obviously, using this violates the "
"abstraction of namespace implementation, and should be restricted to things "
"like post-mortem debuggers."
msgstr ""

#: ../../tutorial/classes.rst:347
msgid "object"
msgstr ""

#: ../../tutorial/classes.rst:347
msgid "method"
msgstr ""

#: ../../tutorial/classes.rst:682
msgid "name"
msgstr ""

#: ../../tutorial/classes.rst:682
msgid "mangling"
msgstr ""
