# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-23 14:56+0000\n"
"PO-Revision-Date: 2025-09-15 01:04+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: French (https://app.transifex.com/python-doc/teams/5390/fr/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: fr\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/queue.rst:2
msgid ":mod:`!queue` --- A synchronized queue class"
msgstr ""

#: ../../library/queue.rst:7
msgid "**Source code:** :source:`Lib/queue.py`"
msgstr "**Code source :** :source:`Lib/queue.py`"

#: ../../library/queue.rst:11
msgid ""
"The :mod:`queue` module implements multi-producer, multi-consumer queues. It "
"is especially useful in threaded programming when information must be "
"exchanged safely between multiple threads.  The :class:`Queue` class in this "
"module implements all the required locking semantics."
msgstr ""

#: ../../library/queue.rst:16
msgid ""
"The module implements three types of queue, which differ only in the order "
"in which the entries are retrieved.  In a :abbr:`FIFO (first-in, first-out)` "
"queue, the first tasks added are the first retrieved.  In a :abbr:`LIFO "
"(last-in, first-out)` queue, the most recently added entry is the first "
"retrieved (operating like a stack).  With a priority queue, the entries are "
"kept sorted (using the :mod:`heapq` module) and the lowest valued entry is "
"retrieved first."
msgstr ""

#: ../../library/queue.rst:24
msgid ""
"Internally, those three types of queues use locks to temporarily block "
"competing threads; however, they are not designed to handle reentrancy "
"within a thread."
msgstr ""
"En interne, ces trois types de files utilisent des verrous pour bloquer "
"temporairement des fils d'exécution concurrents. Cependant, ils n'ont pas "
"été conçus pour être réentrants au sein d'un fil d'exécution."

#: ../../library/queue.rst:28
msgid ""
"In addition, the module implements a \"simple\" :abbr:`FIFO (first-in, first-"
"out)` queue type, :class:`SimpleQueue`, whose specific implementation "
"provides additional guarantees in exchange for the smaller functionality."
msgstr ""
"Le module implémente aussi une :abbr:`FIFO (first-in, first-out)` basique, :"
"class:`SimpleQueue`, dont l’implémentation spécialisée fournit plus de "
"garanties au détriment des fonctionnalités."

#: ../../library/queue.rst:33
msgid "The :mod:`queue` module defines the following classes and exceptions:"
msgstr ""
"Le module :mod:`queue` définit les classes et les exceptions suivantes :"

#: ../../library/queue.rst:37
msgid ""
"Constructor for a :abbr:`FIFO (first-in, first-out)` queue.  *maxsize* is an "
"integer that sets the upperbound limit on the number of items that can be "
"placed in the queue.  Insertion will block once this size has been reached, "
"until queue items are consumed.  If *maxsize* is less than or equal to zero, "
"the queue size is infinite."
msgstr ""
"Constructeur pour une file :abbr:`FIFO (first-in, first-out)`. *maxsize* est "
"un entier définissant le nombre maximal d'éléments pouvant être mis dans la "
"file. L'insertion sera bloquée lorsque cette borne supérieure sera atteinte, "
"jusqu'à ce que des éléments de la file soient consommés. Si *maxsize* est "
"inférieur ou égal à 0, la taille de la file sera infinie."

#: ../../library/queue.rst:45
msgid ""
"Constructor for a :abbr:`LIFO (last-in, first-out)` queue.  *maxsize* is an "
"integer that sets the upperbound limit on the number of items that can be "
"placed in the queue.  Insertion will block once this size has been reached, "
"until queue items are consumed.  If *maxsize* is less than or equal to zero, "
"the queue size is infinite."
msgstr ""
"Constructeur pour une file :abbr:`LIFO (last-in, first-out)`. *maxsize* est "
"un entier définissant le nombre maximal d'éléments pouvant être mis dans la "
"file. L'insertion sera bloquée lorsque cette borne supérieure sera atteinte, "
"jusqu'à ce que des éléments de la file soient consommés. Si *maxsize* est "
"inférieur ou égal à 0, la taille de la file sera infinie."

#: ../../library/queue.rst:54
msgid ""
"Constructor for a priority queue.  *maxsize* is an integer that sets the "
"upperbound limit on the number of items that can be placed in the queue.  "
"Insertion will block once this size has been reached, until queue items are "
"consumed.  If *maxsize* is less than or equal to zero, the queue size is "
"infinite."
msgstr ""
"Constructeur pour une file de priorité. *maxsize* est un entier définissant "
"le nombre maximal d'éléments pouvant être mis dans la file. L'insertion sera "
"bloquée lorsque cette borne supérieure sera atteinte, jusqu'à ce que des "
"éléments soient consommés. Si *maxsize* est inférieur ou égal à 0, la taille "
"de la file sera infinie."

#: ../../library/queue.rst:59
msgid ""
"The lowest valued entries are retrieved first (the lowest valued entry is "
"the one that would be returned by ``min(entries)``).  A typical pattern for "
"entries is a tuple in the form: ``(priority_number, data)``."
msgstr ""

#: ../../library/queue.rst:63
msgid ""
"If the *data* elements are not comparable, the data can be wrapped in a "
"class that ignores the data item and only compares the priority number::"
msgstr ""
"Si les éléments de *data* ne sont pas comparables, les données peuvent être "
"enveloppées dans une classe qui ignore l'élément de données et ne compare "
"que l'ordre de priorité ::"

#: ../../library/queue.rst:66
msgid ""
"from dataclasses import dataclass, field\n"
"from typing import Any\n"
"\n"
"@dataclass(order=True)\n"
"class PrioritizedItem:\n"
"    priority: int\n"
"    item: Any=field(compare=False)"
msgstr ""

#: ../../library/queue.rst:76
msgid ""
"Constructor for an unbounded :abbr:`FIFO (first-in, first-out)` queue. "
"Simple queues lack advanced functionality such as task tracking."
msgstr ""
"Constructeur d'une file illimitée :abbr:`FIFO (first-in, first-out)`. Les "
"simples files d'attente ne possèdent pas de fonctionnalités avancées telles "
"que le suivi des tâches."

#: ../../library/queue.rst:84
msgid ""
"Exception raised when non-blocking :meth:`~Queue.get` (or :meth:`~Queue."
"get_nowait`) is called on a :class:`Queue` object which is empty."
msgstr ""
"Exception levée lorsque la méthode non bloquante :meth:`~Queue.get` (ou :"
"meth:`~Queue.get_nowait`) est appelée sur l'objet :class:`Queue` vide."

#: ../../library/queue.rst:91
msgid ""
"Exception raised when non-blocking :meth:`~Queue.put` (or :meth:`~Queue."
"put_nowait`) is called on a :class:`Queue` object which is full."
msgstr ""
"Exception levée lorsque la méthode non bloquante :meth:`~Queue.put` (ou :"
"meth:`~Queue.put_nowait`) est appelée sur un objet :class:`Queue` plein."

#: ../../library/queue.rst:98
msgid ""
"Exception raised when :meth:`~Queue.put` or :meth:`~Queue.get` is called on "
"a :class:`Queue` object which has been shut down."
msgstr ""

#: ../../library/queue.rst:107
msgid "Queue Objects"
msgstr "Objets ``Queue``"

#: ../../library/queue.rst:109
msgid ""
"Queue objects (:class:`Queue`, :class:`LifoQueue`, or :class:"
"`PriorityQueue`) provide the public methods described below."
msgstr ""
"Les objets *Queue* (:class:`Queue`, :class:`LifoQueue` ou :class:"
"`PriorityQueue`) fournissent les méthodes publiques décrites ci-dessous."

#: ../../library/queue.rst:115
msgid ""
"Return the approximate size of the queue.  Note, qsize() > 0 doesn't "
"guarantee that a subsequent get() will not block, nor will qsize() < maxsize "
"guarantee that put() will not block."
msgstr ""
"Renvoie la taille approximative de la file.  Notez que ``qsize() > 0`` ne "
"garantit pas qu'un ``get()`` ultérieur ne sera pas bloquant et que ``qsize() "
"< maxsize`` ne garantit pas non plus qu'un ``put()`` ne sera pas bloquant."

#: ../../library/queue.rst:122
msgid ""
"Return ``True`` if the queue is empty, ``False`` otherwise.  If empty() "
"returns ``True`` it doesn't guarantee that a subsequent call to put() will "
"not block.  Similarly, if empty() returns ``False`` it doesn't guarantee "
"that a subsequent call to get() will not block."
msgstr ""
"Renvoie ``True`` si la file est vide, ``False`` sinon.  Si ``empty()`` "
"renvoie ``True``, cela ne garantit pas qu'un appel ultérieur à ``put()`` ne "
"sera pas bloquant.  Similairement, si ``empty()`` renvoie ``False``, cela ne "
"garantit pas qu'un appel ultérieur à ``get()`` ne sera pas bloquant."

#: ../../library/queue.rst:130
msgid ""
"Return ``True`` if the queue is full, ``False`` otherwise.  If full() "
"returns ``True`` it doesn't guarantee that a subsequent call to get() will "
"not block.  Similarly, if full() returns ``False`` it doesn't guarantee that "
"a subsequent call to put() will not block."
msgstr ""
"Renvoie ``True`` si la file est pleine, ``False`` sinon.  Si ``full()`` "
"renvoie``True``, cela ne garantit pas qu'un appel ultérieur à ``get()`` ne "
"sera pas bloquant.  Similairement, si ``full()`` retourne ``False``, cela ne "
"garantit pas qu'un appel ultérieur à ``put()`` ne sera pas bloquant."

#: ../../library/queue.rst:138
msgid ""
"Put *item* into the queue.  If optional args *block* is true and *timeout* "
"is ``None`` (the default), block if necessary until a free slot is "
"available.  If *timeout* is a positive number, it blocks at most *timeout* "
"seconds and raises the :exc:`Full` exception if no free slot was available "
"within that time. Otherwise (*block* is false), put an item on the queue if "
"a free slot is immediately available, else raise the :exc:`Full` exception "
"(*timeout* is ignored in that case)."
msgstr ""

#: ../../library/queue.rst:146
msgid "Raises :exc:`ShutDown` if the queue has been shut down."
msgstr ""

#: ../../library/queue.rst:151
msgid "Equivalent to ``put(item, block=False)``."
msgstr ""

#: ../../library/queue.rst:156 ../../library/queue.rst:314
msgid ""
"Remove and return an item from the queue.  If optional args *block* is true "
"and *timeout* is ``None`` (the default), block if necessary until an item is "
"available. If *timeout* is a positive number, it blocks at most *timeout* "
"seconds and raises the :exc:`Empty` exception if no item was available "
"within that time. Otherwise (*block* is false), return an item if one is "
"immediately available, else raise the :exc:`Empty` exception (*timeout* is "
"ignored in that case)."
msgstr ""
"Retire et renvoie un élément de la file. Si les arguments optionnels *block* "
"et *timeout* valent respectivement ``True`` et ``None`` (les valeurs par "
"défaut), la méthode bloque si nécessaire jusqu'à ce qu'un élément soit "
"disponible. Si *timeout* est un entier positif, elle bloque au plus "
"*timeout* secondes et lève l'exception :exc:`Empty` s'il n'y avait pas "
"d'élément disponible pendant cette période de temps. Sinon (*block* vaut "
"``False``), elle renvoie un élément s'il y en a un immédiatement disponible. "
"Si ce n'est pas le cas, elle lève l'exception :exc:`Empty` (*timeout* est "
"ignoré dans ce cas)."

#: ../../library/queue.rst:163
msgid ""
"Prior to 3.0 on POSIX systems, and for all versions on Windows, if *block* "
"is true and *timeout* is ``None``, this operation goes into an "
"uninterruptible wait on an underlying lock.  This means that no exceptions "
"can occur, and in particular a SIGINT will not trigger a :exc:"
"`KeyboardInterrupt`."
msgstr ""

#: ../../library/queue.rst:168
msgid ""
"Raises :exc:`ShutDown` if the queue has been shut down and is empty, or if "
"the queue has been shut down immediately."
msgstr ""

#: ../../library/queue.rst:174 ../../library/queue.rst:324
msgid "Equivalent to ``get(False)``."
msgstr "Équivalent à ``get(False)``."

#: ../../library/queue.rst:176
msgid ""
"Two methods are offered to support tracking whether enqueued tasks have been "
"fully processed by daemon consumer threads."
msgstr ""
"Deux méthodes sont proposées afin de savoir si les tâches mises dans la file "
"ont été entièrement traitées par les fils d'exécution consommateurs du démon."

#: ../../library/queue.rst:182
msgid ""
"Indicate that a formerly enqueued task is complete.  Used by queue consumer "
"threads.  For each :meth:`get` used to fetch a task, a subsequent call to :"
"meth:`task_done` tells the queue that the processing on the task is complete."
msgstr ""
"Indique qu'une tâche précédemment mise dans la file est terminée. Utilisé "
"par les fils d'exécution consommateurs de la file. Pour chaque appel à :meth:"
"`get` effectué afin de récupérer une tâche, un appel ultérieur à :meth:"
"`task_done` informe la file que le traitement de la tâche est terminé."

#: ../../library/queue.rst:186
msgid ""
"If a :meth:`join` is currently blocking, it will resume when all items have "
"been processed (meaning that a :meth:`task_done` call was received for every "
"item that had been :meth:`put` into the queue)."
msgstr ""
"Si un :meth:`join` est actuellement bloquant, on reprendra lorsque tous les "
"éléments auront été traités (ce qui signifie qu'un appel à :meth:`task_done` "
"a été effectué pour chaque élément qui a été :meth:`put` dans la file)."

#: ../../library/queue.rst:190
msgid ""
"Raises a :exc:`ValueError` if called more times than there were items placed "
"in the queue."
msgstr ""
"Lève une exception :exc:`ValueError` si appelée plus de fois qu'il y avait "
"d'éléments dans la file."

#: ../../library/queue.rst:196
msgid "Blocks until all items in the queue have been gotten and processed."
msgstr ""
"Bloque jusqu'à ce que tous les éléments de la file aient été obtenus et "
"traités."

#: ../../library/queue.rst:198
msgid ""
"The count of unfinished tasks goes up whenever an item is added to the "
"queue. The count goes down whenever a consumer thread calls :meth:"
"`task_done` to indicate that the item was retrieved and all work on it is "
"complete.  When the count of unfinished tasks drops to zero, :meth:`join` "
"unblocks."
msgstr ""

#: ../../library/queue.rst:205
msgid "Waiting for task completion"
msgstr ""

#: ../../library/queue.rst:207
msgid "Example of how to wait for enqueued tasks to be completed::"
msgstr ""
"Exemple montrant comment attendre que les tâches mises dans la file soient "
"terminées ::"

#: ../../library/queue.rst:209
msgid ""
"import threading\n"
"import queue\n"
"\n"
"q = queue.Queue()\n"
"\n"
"def worker():\n"
"    while True:\n"
"        item = q.get()\n"
"        print(f'Working on {item}')\n"
"        print(f'Finished {item}')\n"
"        q.task_done()\n"
"\n"
"# Turn-on the worker thread.\n"
"threading.Thread(target=worker, daemon=True).start()\n"
"\n"
"# Send thirty task requests to the worker.\n"
"for item in range(30):\n"
"    q.put(item)\n"
"\n"
"# Block until all tasks are done.\n"
"q.join()\n"
"print('All work completed')"
msgstr ""

#: ../../library/queue.rst:234
msgid "Terminating queues"
msgstr ""

#: ../../library/queue.rst:236
msgid ""
"When no longer needed, :class:`Queue` objects can be wound down until empty "
"or terminated immediately with a hard shutdown."
msgstr ""

#: ../../library/queue.rst:241
msgid "Put a :class:`Queue` instance into a shutdown mode."
msgstr ""

#: ../../library/queue.rst:243
msgid ""
"The queue can no longer grow. Future calls to :meth:`~Queue.put` raise :exc:"
"`ShutDown`. Currently blocked callers of :meth:`~Queue.put` will be "
"unblocked and will raise :exc:`ShutDown` in the formerly blocked thread."
msgstr ""

#: ../../library/queue.rst:248
msgid ""
"If *immediate* is false (the default), the queue can be wound down normally "
"with :meth:`~Queue.get` calls to extract tasks that have already been loaded."
msgstr ""

#: ../../library/queue.rst:252
msgid ""
"And if :meth:`~Queue.task_done` is called for each remaining task, a "
"pending :meth:`~Queue.join` will be unblocked normally."
msgstr ""

#: ../../library/queue.rst:255
msgid ""
"Once the queue is empty, future calls to :meth:`~Queue.get` will raise :exc:"
"`ShutDown`."
msgstr ""

#: ../../library/queue.rst:258
msgid ""
"If *immediate* is true, the queue is terminated immediately. The queue is "
"drained to be completely empty and the count of unfinished tasks is reduced "
"by the number of tasks drained. If unfinished tasks is zero, callers of :"
"meth:`~Queue.join` are unblocked.  Also, blocked callers of :meth:`~Queue."
"get` are unblocked and will raise :exc:`ShutDown` because the queue is empty."
msgstr ""

#: ../../library/queue.rst:266
msgid ""
"Use caution when using :meth:`~Queue.join` with *immediate* set to true. "
"This unblocks the join even when no work has been done on the tasks, "
"violating the usual invariant for joining a queue."
msgstr ""

#: ../../library/queue.rst:274
msgid "SimpleQueue Objects"
msgstr "Objets ``SimpleQueue``"

#: ../../library/queue.rst:276
msgid ""
":class:`SimpleQueue` objects provide the public methods described below."
msgstr ""
"Les objets :class:`SimpleQueue` fournissent les méthodes publiques décrites "
"ci-dessous."

#: ../../library/queue.rst:280
msgid ""
"Return the approximate size of the queue.  Note, qsize() > 0 doesn't "
"guarantee that a subsequent get() will not block."
msgstr ""
"Renvoie la taille approximative de la file. Notez que ``qsize() > 0`` ne "
"garantit pas qu'un ``get()`` ultérieur ne soit pas bloquant."

#: ../../library/queue.rst:286
msgid ""
"Return ``True`` if the queue is empty, ``False`` otherwise.  If empty() "
"returns ``False`` it doesn't guarantee that a subsequent call to get() will "
"not block."
msgstr ""

#: ../../library/queue.rst:293
msgid ""
"Put *item* into the queue.  The method never blocks and always succeeds "
"(except for potential low-level errors such as failure to allocate memory). "
"The optional args *block* and *timeout* are ignored and only provided for "
"compatibility with :meth:`Queue.put`."
msgstr ""
"Met *item* dans la file. La méthode ne bloque jamais et aboutit toujours "
"(sauf en cas de potentielles erreurs de bas niveau, telles qu'un échec "
"d'allocation de mémoire). Les arguments optionnels *block* et *timeout* sont "
"ignorés et fournis uniquement pour la compatibilité avec :meth:`Queue.put`."

#: ../../library/queue.rst:299
msgid ""
"This method has a C implementation which is reentrant.  That is, a ``put()`` "
"or ``get()`` call can be interrupted by another ``put()`` call in the same "
"thread without deadlocking or corrupting internal state inside the queue.  "
"This makes it appropriate for use in destructors such as ``__del__`` methods "
"or :mod:`weakref` callbacks."
msgstr ""

#: ../../library/queue.rst:308
msgid ""
"Equivalent to ``put(item, block=False)``, provided for compatibility with :"
"meth:`Queue.put_nowait`."
msgstr ""

#: ../../library/queue.rst:329
msgid "Class :class:`multiprocessing.Queue`"
msgstr "Classe :class:`multiprocessing.Queue`"

#: ../../library/queue.rst:330
msgid ""
"A queue class for use in a multi-processing (rather than multi-threading) "
"context."
msgstr ""
"Une file à utiliser dans un contexte multi-processus (plutôt que *multi-"
"thread*)."

#: ../../library/queue.rst:333
msgid ""
":class:`collections.deque` is an alternative implementation of unbounded "
"queues with fast atomic :meth:`~collections.deque.append` and :meth:"
"`~collections.deque.popleft` operations that do not require locking and also "
"support indexing."
msgstr ""
