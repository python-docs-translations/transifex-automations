# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-23 14:56+0000\n"
"PO-Revision-Date: 2025-09-15 01:04+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: French (https://app.transifex.com/python-doc/teams/5390/fr/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: fr\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/numbers.rst:2
msgid ":mod:`!numbers` --- Numeric abstract base classes"
msgstr ""

#: ../../library/numbers.rst:7
msgid "**Source code:** :source:`Lib/numbers.py`"
msgstr "**Code source :** :source:`Lib/numbers.py`"

#: ../../library/numbers.rst:11
msgid ""
"The :mod:`!numbers` module (:pep:`3141`) defines a hierarchy of "
"numeric :term:`abstract base classes <abstract base class>` which "
"progressively define more operations.  None of the types defined in this "
"module are intended to be instantiated."
msgstr ""

#: ../../library/numbers.rst:18
msgid ""
"The root of the numeric hierarchy. If you just want to check if an argument "
"*x* is a number, without caring what kind, use ``isinstance(x, Number)``."
msgstr ""
"La base de la hiérarchie numérique. Si vous voulez juste vérifier qu'un "
"argument *x* est un nombre, peu importe le type, utilisez ``isinstance(x, "
"Number)``."

#: ../../library/numbers.rst:23
msgid "The numeric tower"
msgstr "La tour numérique"

#: ../../library/numbers.rst:27
msgid ""
"Subclasses of this type describe complex numbers and include the operations "
"that work on the built-in :class:`complex` type. These are: conversions "
"to :class:`complex` and :class:`bool`, :attr:`.real`, :attr:`.imag`, ``+``, "
"``-``, ``*``, ``/``, ``**``, :func:`abs`, :meth:`conjugate`, ``==``, and ``!"
"=``. All except ``-`` and ``!=`` are abstract."
msgstr ""

#: ../../library/numbers.rst:35
msgid "Abstract. Retrieves the real component of this number."
msgstr "Abstrait. Récupère la partie réelle de ce nombre."

#: ../../library/numbers.rst:39
msgid "Abstract. Retrieves the imaginary component of this number."
msgstr "Abstrait. Retrouve la partie imaginaire de ce nombre."

#: ../../library/numbers.rst:44
msgid ""
"Abstract. Returns the complex conjugate. For example, ``(1+3j).conjugate() "
"== (1-3j)``."
msgstr ""
"Abstrait. Renvoie le complexe conjugué. Par exemple, ``(1+3j).conjugate() == "
"(1-3j)``."

#: ../../library/numbers.rst:49
msgid ""
"To :class:`Complex`, :class:`!Real` adds the operations that work on real "
"numbers."
msgstr ""

#: ../../library/numbers.rst:52
msgid ""
"In short, those are: a conversion "
"to :class:`float`, :func:`math.trunc`, :func:`round`, :func:`math.floor`, :func:`math.ceil`, :func:`divmod`, "
"``//``, ``%``, ``<``, ``<=``, ``>``, and ``>=``."
msgstr ""
"En bref, celles-ci sont : une conversion "
"vers :class:`float`, :func:`math.trunc`, :func:`round`, :func:`math.floor`, :func:`math.ceil`, :func:`divmod`, "
"``//``, ``%``, ``<``, ``<=``, ``>`` et ``>=``."

#: ../../library/numbers.rst:56
msgid ""
"Real also provides defaults "
"for :func:`complex`, :attr:`~Complex.real`, :attr:`~Complex.imag`, "
"and :meth:`~Complex.conjugate`."
msgstr ""
"*Real* fournit également des valeurs par défaut "
"pour :func:`complex`, :attr:`~Complex.real`, :attr:`~Complex.imag` "
"et :meth:`~Complex.conjugate`."

#: ../../library/numbers.rst:62
msgid ""
"Subtypes :class:`Real` and adds :attr:`~Rational.numerator` "
"and :attr:`~Rational.denominator` properties. It also provides a default "
"for :func:`float`."
msgstr ""

#: ../../library/numbers.rst:66
msgid ""
"The :attr:`~Rational.numerator` and :attr:`~Rational.denominator` values "
"should be instances of :class:`Integral` and should be in lowest terms "
"with :attr:`~Rational.denominator` positive."
msgstr ""

#: ../../library/numbers.rst:72
msgid "Abstract.  The numerator of this rational number."
msgstr ""

#: ../../library/numbers.rst:76
msgid "Abstract.  The denominator of this rational number."
msgstr ""

#: ../../library/numbers.rst:81
msgid ""
"Subtypes :class:`Rational` and adds a conversion to :class:`int`.  Provides "
"defaults for :func:`float`, :attr:`~Rational.numerator`, "
"and :attr:`~Rational.denominator`.  Adds abstract methods for :func:`pow` "
"with modulus and bit-string operations: ``<<``, ``>>``, ``&``, ``^``, ``|``, "
"``~``."
msgstr ""

#: ../../library/numbers.rst:89
msgid "Notes for type implementers"
msgstr ""

#: ../../library/numbers.rst:91
msgid ""
"Implementers should be careful to make equal numbers equal and hash them to "
"the same values. This may be subtle if there are two different extensions of "
"the real numbers. For example, :class:`fractions.Fraction` "
"implements :func:`hash` as follows::"
msgstr ""

#: ../../library/numbers.rst:96
msgid ""
"def __hash__(self):\n"
"    if self.denominator == 1:\n"
"        # Get integers right.\n"
"        return hash(self.numerator)\n"
"    # Expensive check, but definitely correct.\n"
"    if self == float(self):\n"
"        return hash(float(self))\n"
"    else:\n"
"        # Use tuple's hash to avoid a high collision rate on\n"
"        # simple fractions.\n"
"        return hash((self.numerator, self.denominator))"
msgstr ""

#: ../../library/numbers.rst:110
msgid "Adding More Numeric ABCs"
msgstr "Ajouter plus d'ABC numériques"

#: ../../library/numbers.rst:112
msgid ""
"There are, of course, more possible ABCs for numbers, and this would be a "
"poor hierarchy if it precluded the possibility of adding those. You can add "
"``MyFoo`` between :class:`Complex` and :class:`Real` with::"
msgstr ""
"Il est bien entendu possible de créer davantage d’ABC pour les nombres et "
"cette hiérarchie serait médiocre si elle excluait la possibilité d'en "
"ajouter. Vous pouvez ajouter ``MyFoo`` entre :class:`Complex` "
"et :class:`Real` ainsi ::"

#: ../../library/numbers.rst:117
msgid ""
"class MyFoo(Complex): ...\n"
"MyFoo.register(Real)"
msgstr ""

#: ../../library/numbers.rst:124
msgid "Implementing the arithmetic operations"
msgstr "Implémentation des opérations arithmétiques"

#: ../../library/numbers.rst:126
msgid ""
"We want to implement the arithmetic operations so that mixed-mode operations "
"either call an implementation whose author knew about the types of both "
"arguments, or convert both to the nearest built in type and do the operation "
"there. For subtypes of :class:`Integral`, this means "
"that :meth:`~object.__add__` and :meth:`~object.__radd__` should be defined "
"as::"
msgstr ""

#: ../../library/numbers.rst:133
msgid ""
"class MyIntegral(Integral):\n"
"\n"
"    def __add__(self, other):\n"
"        if isinstance(other, MyIntegral):\n"
"            return do_my_adding_stuff(self, other)\n"
"        elif isinstance(other, OtherTypeIKnowAbout):\n"
"            return do_my_other_adding_stuff(self, other)\n"
"        else:\n"
"            return NotImplemented\n"
"\n"
"    def __radd__(self, other):\n"
"        if isinstance(other, MyIntegral):\n"
"            return do_my_adding_stuff(other, self)\n"
"        elif isinstance(other, OtherTypeIKnowAbout):\n"
"            return do_my_other_adding_stuff(other, self)\n"
"        elif isinstance(other, Integral):\n"
"            return int(other) + int(self)\n"
"        elif isinstance(other, Real):\n"
"            return float(other) + float(self)\n"
"        elif isinstance(other, Complex):\n"
"            return complex(other) + complex(self)\n"
"        else:\n"
"            return NotImplemented"
msgstr ""

#: ../../library/numbers.rst:158
msgid ""
"There are 5 different cases for a mixed-type operation on subclasses "
"of :class:`Complex`. I'll refer to all of the above code that doesn't refer "
"to ``MyIntegral`` and ``OtherTypeIKnowAbout`` as \"boilerplate\". ``a`` will "
"be an instance of ``A``, which is a subtype of :class:`Complex` (``a : A <: "
"Complex``), and ``b : B <: Complex``. I'll consider ``a + b``:"
msgstr ""
"Il existe 5 cas différents pour une opération de type mixte sur des sous-"
"classes de :class:`Complex`. Nous nous référerons à tout le code ci-dessus "
"qui ne se réfère pas à ``MyIntegral`` et ``OtherTypeIKnowAbout`` comme "
"\"expression générique\". ``a`` est une instance de ``A``, qui est un sous-"
"type de :class:`Complex` (``a : A <: Complex``) et ``b : B <: Complex``. "
"Considérons ``a + b``:"

#: ../../library/numbers.rst:165
msgid ""
"If ``A`` defines an :meth:`~object.__add__` which accepts ``b``, all is well."
msgstr ""

#: ../../library/numbers.rst:167
msgid ""
"If ``A`` falls back to the boilerplate code, and it were to return a value "
"from :meth:`~object.__add__`, we'd miss the possibility that ``B`` defines a "
"more intelligent :meth:`~object.__radd__`, so the boilerplate should "
"return :data:`NotImplemented` from :meth:`!__add__`. (Or ``A`` may not "
"implement :meth:`!__add__` at all.)"
msgstr ""

#: ../../library/numbers.rst:173
msgid ""
"Then ``B``'s :meth:`~object.__radd__` gets a chance. If it accepts ``a``, "
"all is well."
msgstr ""

#: ../../library/numbers.rst:175
msgid ""
"If it falls back to the boilerplate, there are no more possible methods to "
"try, so this is where the default implementation should live."
msgstr ""
"Si elle fait appel au code générique, il n'y a plus de méthode possible à "
"essayer, c'est donc ici que l'implémentation par défaut intervient."

#: ../../library/numbers.rst:178
msgid ""
"If ``B <: A``, Python tries ``B.__radd__`` before ``A.__add__``. This is ok, "
"because it was implemented with knowledge of ``A``, so it can handle those "
"instances before delegating to :class:`Complex`."
msgstr ""
"Si ``B < : A```, Python essaie ``B.__radd__`` avant ``A.__add__``. C'est "
"valable parce qu'elle est implémentée avec la connaissance de ``A``, donc "
"elle peut gérer ces instances avant de déléguer à :class:`Complex`."

#: ../../library/numbers.rst:183
msgid ""
"If ``A <: Complex`` and ``B <: Real`` without sharing any other knowledge, "
"then the appropriate shared operation is the one involving the built "
"in :class:`complex`, and both :meth:`~object.__radd__` s land there, so "
"``a+b == b+a``."
msgstr ""

#: ../../library/numbers.rst:188
msgid ""
"Because most of the operations on any given type will be very similar, it "
"can be useful to define a helper function which generates the forward and "
"reverse instances of any given operator. For "
"example, :class:`fractions.Fraction` uses::"
msgstr ""
"Comme la plupart des opérations sur un type donné seront très similaires, il "
"peut être utile de définir une fonction accessoire qui génère les instances "
"résultantes et inverses d'un opérateur donné. Par "
"exemple, :class:`fractions.Fraction` utilise ::"

#: ../../library/numbers.rst:193
msgid ""
"def _operator_fallbacks(monomorphic_operator, fallback_operator):\n"
"    def forward(a, b):\n"
"        if isinstance(b, (int, Fraction)):\n"
"            return monomorphic_operator(a, b)\n"
"        elif isinstance(b, float):\n"
"            return fallback_operator(float(a), b)\n"
"        elif isinstance(b, complex):\n"
"            return fallback_operator(complex(a), b)\n"
"        else:\n"
"            return NotImplemented\n"
"    forward.__name__ = '__' + fallback_operator.__name__ + '__'\n"
"    forward.__doc__ = monomorphic_operator.__doc__\n"
"\n"
"    def reverse(b, a):\n"
"        if isinstance(a, Rational):\n"
"            # Includes ints.\n"
"            return monomorphic_operator(a, b)\n"
"        elif isinstance(a, Real):\n"
"            return fallback_operator(float(a), float(b))\n"
"        elif isinstance(a, Complex):\n"
"            return fallback_operator(complex(a), complex(b))\n"
"        else:\n"
"            return NotImplemented\n"
"    reverse.__name__ = '__r' + fallback_operator.__name__ + '__'\n"
"    reverse.__doc__ = monomorphic_operator.__doc__\n"
"\n"
"    return forward, reverse\n"
"\n"
"def _add(a, b):\n"
"    \"\"\"a + b\"\"\"\n"
"    return Fraction(a.numerator * b.denominator +\n"
"                    b.numerator * a.denominator,\n"
"                    a.denominator * b.denominator)\n"
"\n"
"__add__, __radd__ = _operator_fallbacks(_add, operator.add)\n"
"\n"
"# ..."
msgstr ""
