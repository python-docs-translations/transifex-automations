# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-21 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../c-api/bytes.rst:6
msgid "Bytes Objects"
msgstr "Bytes-objekt"

#: ../../c-api/bytes.rst:8
msgid ""
"These functions raise :exc:`TypeError` when expecting a bytes parameter and "
"called with a non-bytes parameter."
msgstr ""
"Dessa funktioner ger upphov till :exc:`TypeError` när de förväntar sig en "
"bytesparameter och anropas med en parameter som inte är bytes."

#: ../../c-api/bytes.rst:16
msgid "This subtype of :c:type:`PyObject` represents a Python bytes object."
msgstr ""
"Denna subtyp av :c:type:`PyObject` representerar ett Python bytes-objekt."

#: ../../c-api/bytes.rst:21
msgid ""
"This instance of :c:type:`PyTypeObject` represents the Python bytes type; it "
"is the same object as :class:`bytes` in the Python layer."
msgstr ""
"Denna instans av :c:type:`PyTypeObject` representerar Python-bytes-typen; "
"det är samma objekt som :class:`bytes` i Python-lagret."

#: ../../c-api/bytes.rst:27
msgid ""
"Return true if the object *o* is a bytes object or an instance of a subtype "
"of the bytes type.  This function always succeeds."
msgstr ""
"Returnerar true om objektet *o* är ett bytesobjekt eller en instans av en "
"subtyp av bytes-typen.  Denna funktion lyckas alltid."

#: ../../c-api/bytes.rst:33
msgid ""
"Return true if the object *o* is a bytes object, but not an instance of a "
"subtype of the bytes type.  This function always succeeds."
msgstr ""
"Returnerar true om objektet *o* är ett bytesobjekt, men inte en instans av "
"en subtyp av bytes-typen.  Denna funktion lyckas alltid."

#: ../../c-api/bytes.rst:39
msgid ""
"Return a new bytes object with a copy of the string *v* as value on success, "
"and ``NULL`` on failure.  The parameter *v* must not be ``NULL``; it will "
"not be checked."
msgstr ""
"Returnerar ett nytt bytesobjekt med en kopia av strängen *v* som värde vid "
"framgång, och ``NULL`` vid misslyckande.  Parametern *v* får inte vara "
"``NULL``; den kommer inte att kontrolleras."

#: ../../c-api/bytes.rst:46
msgid ""
"Return a new bytes object with a copy of the string *v* as value and length "
"*len* on success, and ``NULL`` on failure.  If *v* is ``NULL``, the contents "
"of the bytes object are uninitialized."
msgstr ""
"Returnerar ett nytt bytes-objekt med en kopia av strängen *v* som värde och "
"längden *len* vid framgång, och ``NULL`` vid misslyckande.  Om *v* är "
"``NULL`` avinitialiseras innehållet i bytes-objektet."

#: ../../c-api/bytes.rst:53
msgid ""
"Take a C :c:func:`printf`\\ -style *format* string and a variable number of "
"arguments, calculate the size of the resulting Python bytes object and "
"return a bytes object with the values formatted into it.  The variable "
"arguments must be C types and must correspond exactly to the format "
"characters in the *format* string.  The following format characters are "
"allowed:"
msgstr ""
"Ta en C :c:func:`printf`-stil *format*-sträng och ett variabelt antal "
"argument, beräkna storleken på det resulterande Python bytes-objektet och "
"returnera ett bytes-objekt med de värden som formaterats i det.  De variabla "
"argumenten måste vara C-typer och måste exakt motsvara formattecknen i "
"*format*-strängen.  Följande formattecken är tillåtna:"

#: ../../c-api/bytes.rst:65
msgid "Format Characters"
msgstr "Format tecken"

#: ../../c-api/bytes.rst:65
msgid "Type"
msgstr "Typ"

#: ../../c-api/bytes.rst:65
msgid "Comment"
msgstr "Kommentar"

#: ../../c-api/bytes.rst:67
msgid "``%%``"
msgstr "``%%``"

#: ../../c-api/bytes.rst:67
msgid "*n/a*"
msgstr "*n/a*"

#: ../../c-api/bytes.rst:67
msgid "The literal % character."
msgstr "Det bokstavliga % ctecknet."

#: ../../c-api/bytes.rst:69
msgid "``%c``"
msgstr "``%c``"

#: ../../c-api/bytes.rst:69 ../../c-api/bytes.rst:72 ../../c-api/bytes.rst:90
#: ../../c-api/bytes.rst:93
msgid "int"
msgstr "int"

#: ../../c-api/bytes.rst:69
msgid "A single byte, represented as a C int."
msgstr "En enda byte, representerad som en C int."

#: ../../c-api/bytes.rst:72
msgid "``%d``"
msgstr "``%d``"

#: ../../c-api/bytes.rst:72
msgid "Equivalent to ``printf(\"%d\")``. [1]_"
msgstr "Motsvarar ``printf(\"%d\")``. [1]_"

#: ../../c-api/bytes.rst:75
msgid "``%u``"
msgstr "``%u``"

#: ../../c-api/bytes.rst:75
msgid "unsigned int"
msgstr "osignerad int"

#: ../../c-api/bytes.rst:75
msgid "Equivalent to ``printf(\"%u\")``. [1]_"
msgstr "Motsvarar ``printf(\"%u\")``. [1]_"

#: ../../c-api/bytes.rst:78
msgid "``%ld``"
msgstr "``%ld``"

#: ../../c-api/bytes.rst:78
msgid "long"
msgstr "long"

#: ../../c-api/bytes.rst:78
msgid "Equivalent to ``printf(\"%ld\")``. [1]_"
msgstr "Motsvarar ``printf(\"%ld\")``. [1]_"

#: ../../c-api/bytes.rst:81
msgid "``%lu``"
msgstr "``%lu``"

#: ../../c-api/bytes.rst:81
msgid "unsigned long"
msgstr "unsigned long"

#: ../../c-api/bytes.rst:81
msgid "Equivalent to ``printf(\"%lu\")``. [1]_"
msgstr "Motsvarar ``printf(\"%lu\")``. [1]_"

#: ../../c-api/bytes.rst:84
msgid "``%zd``"
msgstr "``%zd``"

#: ../../c-api/bytes.rst:84
msgid ":c:type:`\\ Py_ssize_t`"
msgstr ":c:type:`\\ Py_ssize_t`"

#: ../../c-api/bytes.rst:84
msgid "Equivalent to ``printf(\"%zd\")``. [1]_"
msgstr "Motsvarar ``printf(\"%zd\")``. [1]_"

#: ../../c-api/bytes.rst:87
msgid "``%zu``"
msgstr "``%zu``"

#: ../../c-api/bytes.rst:87
msgid "size_t"
msgstr "storlek_t"

#: ../../c-api/bytes.rst:87
msgid "Equivalent to ``printf(\"%zu\")``. [1]_"
msgstr "Motsvarar ``printf(\"%zu\")``. [1]_"

#: ../../c-api/bytes.rst:90
msgid "``%i``"
msgstr "``%i``"

#: ../../c-api/bytes.rst:90
msgid "Equivalent to ``printf(\"%i\")``. [1]_"
msgstr "Motsvarar ``printf(\"%i\")``. [1]_"

#: ../../c-api/bytes.rst:93
msgid "``%x``"
msgstr "``%x``"

#: ../../c-api/bytes.rst:93
msgid "Equivalent to ``printf(\"%x\")``. [1]_"
msgstr "Motsvarar ``printf(\"%x\")``. [1]_"

#: ../../c-api/bytes.rst:96
msgid "``%s``"
msgstr "``%s``"

#: ../../c-api/bytes.rst:96
msgid "const char\\*"
msgstr "konst char\\*"

#: ../../c-api/bytes.rst:96
msgid "A null-terminated C character array."
msgstr "En nollavslutad C-teckenmatris."

#: ../../c-api/bytes.rst:99
msgid "``%p``"
msgstr "``%p``"

#: ../../c-api/bytes.rst:99
msgid "const void\\*"
msgstr "konst void\\*"

#: ../../c-api/bytes.rst:99
msgid ""
"The hex representation of a C pointer. Mostly equivalent to "
"``printf(\"%p\")`` except that it is guaranteed to start with the literal "
"``0x`` regardless of what the platform's ``printf`` yields."
msgstr ""
"Hex-representationen av en C-pekare. I stort sett likvärdig med "
"``printf(\"%p\")`` förutom att den garanterat börjar med den bokstavliga "
"``0x`` oavsett vad plattformens ``printf`` ger."

#: ../../c-api/bytes.rst:108
msgid ""
"An unrecognized format character causes all the rest of the format string to "
"be copied as-is to the result object, and any extra arguments discarded."
msgstr ""
"Ett formattecken som inte känns igen gör att resten av formatsträngen "
"kopieras som den är till resultatobjektet och att eventuella extra argument "
"kasseras."

#: ../../c-api/bytes.rst:111
msgid ""
"For integer specifiers (d, u, ld, lu, zd, zu, i, x): the 0-conversion flag "
"has effect even when a precision is given."
msgstr ""
"För heltalsangivelser (d, u, ld, lu, zd, zu, i, x): 0-konverteringsflaggan "
"gäller även när en precision anges."

#: ../../c-api/bytes.rst:117
msgid ""
"Identical to :c:func:`PyBytes_FromFormat` except that it takes exactly two "
"arguments."
msgstr ""
"Identisk med :c:func:`PyBytes_FromFormat` förutom att den tar exakt två "
"argument."

#: ../../c-api/bytes.rst:123
msgid ""
"Return the bytes representation of object *o* that implements the buffer "
"protocol."
msgstr ""
"Returnera bytesrepresentationen av objektet *o* som implementerar "
"buffertprotokollet."

#: ../../c-api/bytes.rst:129
msgid "Return the length of the bytes in bytes object *o*."
msgstr "Returnera längden på byte i bytesobjektet *o*."

#: ../../c-api/bytes.rst:134
msgid "Similar to :c:func:`PyBytes_Size`, but without error checking."
msgstr "Liknar :c:func:`PyBytes_Size`, men utan felkontroll."

#: ../../c-api/bytes.rst:139
msgid ""
"Return a pointer to the contents of *o*.  The pointer refers to the internal "
"buffer of *o*, which consists of ``len(o) + 1`` bytes.  The last byte in the "
"buffer is always null, regardless of whether there are any other null "
"bytes.  The data must not be modified in any way, unless the object was just "
"created using ``PyBytes_FromStringAndSize(NULL, size)``. It must not be "
"deallocated.  If *o* is not a bytes object at all, :c:func:"
"`PyBytes_AsString` returns ``NULL`` and raises :exc:`TypeError`."
msgstr ""
"Returnerar en pekare till innehållet i *o*.  Pekaren refererar till den "
"interna bufferten i *o*, som består av ``len(o) + 1`` byte.  Den sista byten "
"i bufferten är alltid null, oavsett om det finns några andra null-bytes.  "
"Data får inte ändras på något sätt, såvida inte objektet just skapades med "
"``PyBytes_FromStringAndSize(NULL, size)``. Det får inte deallokeras.  Om *o* "
"inte alls är ett bytesobjekt, returnerar :c:func:`PyBytes_AsString` ``NULL`` "
"och ger upphov till :exc:`TypeError`."

#: ../../c-api/bytes.rst:151
msgid "Similar to :c:func:`PyBytes_AsString`, but without error checking."
msgstr "Liknar :c:func:`PyBytes_AsString`, men utan felkontroll."

#: ../../c-api/bytes.rst:156
msgid ""
"Return the null-terminated contents of the object *obj* through the output "
"variables *buffer* and *length*. Returns ``0`` on success."
msgstr ""
"Returnerar det nollavslutade innehållet i objektet *obj* genom "
"utdatavariablerna *buffer* och *length*. Returnerar ``0`` vid framgång."

#: ../../c-api/bytes.rst:160
msgid ""
"If *length* is ``NULL``, the bytes object may not contain embedded null "
"bytes; if it does, the function returns ``-1`` and a :exc:`ValueError` is "
"raised."
msgstr ""
"Om *length* är ``NULL`` får bytesobjektet inte innehålla inbäddade "
"nullbytes; om det gör det returnerar funktionen ``-1`` och ett :exc:"
"`ValueError`` uppstår."

#: ../../c-api/bytes.rst:164
msgid ""
"The buffer refers to an internal buffer of *obj*, which includes an "
"additional null byte at the end (not counted in *length*).  The data must "
"not be modified in any way, unless the object was just created using "
"``PyBytes_FromStringAndSize(NULL, size)``.  It must not be deallocated.  If "
"*obj* is not a bytes object at all, :c:func:`PyBytes_AsStringAndSize` "
"returns ``-1`` and raises :exc:`TypeError`."
msgstr ""
"Bufferten hänvisar till en intern buffert i *obj*, som innehåller en extra "
"null-byte i slutet (räknas inte in i *length*).  Data får inte ändras på "
"något sätt, såvida inte objektet precis skapades med "
"``PyBytes_FromStringAndSize(NULL, size)``.  Det får inte deallokeras.  Om "
"*obj* inte alls är ett bytesobjekt, returnerar :c:func:"
"`PyBytes_AsStringAndSize` ``-1`` och ger upphov till :exc:`TypeError`."

#: ../../c-api/bytes.rst:171
msgid ""
"Previously, :exc:`TypeError` was raised when embedded null bytes were "
"encountered in the bytes object."
msgstr ""
"Tidigare skapades :exc:`TypeError` när inbäddade null-bytes påträffades i "
"bytes-objektet."

#: ../../c-api/bytes.rst:178
msgid ""
"Create a new bytes object in *\\*bytes* containing the contents of *newpart* "
"appended to *bytes*; the caller will own the new reference.  The reference "
"to the old value of *bytes* will be stolen.  If the new object cannot be "
"created, the old reference to *bytes* will still be discarded and the value "
"of *\\*bytes* will be set to ``NULL``; the appropriate exception will be set."
msgstr ""
"Skapa ett nytt bytesobjekt i *\\*bytes* som innehåller innehållet i "
"*newpart* som lagts till *bytes*; den som anropar kommer att äga den nya "
"referensen.  Referensen till det gamla värdet av *bytes* kommer att "
"stjälas.  Om det nya objektet inte kan skapas, kommer den gamla referensen "
"till *bytes* ändå att kasseras och värdet på *\\*bytes* kommer att sättas "
"till ``NULL``; lämpligt undantag kommer att sättas."

#: ../../c-api/bytes.rst:187
msgid ""
"Create a new bytes object in *\\*bytes* containing the contents of *newpart* "
"appended to *bytes*.  This version releases the :term:`strong reference` to "
"*newpart* (i.e. decrements its reference count)."
msgstr ""
"Skapa ett nytt bytesobjekt i *\\*bytes* som innehåller innehållet i "
"*newpart* tillagt *bytes*.  Denna version släpper :term:`strong reference` "
"till *newpart* (dvs. minskar dess referensantal)."

#: ../../c-api/bytes.rst:194
msgid "Similar to ``sep.join(iterable)`` in Python."
msgstr "Liknar ``sep.join(iterable)`` i Python."

#: ../../c-api/bytes.rst:196
msgid ""
"*sep* must be Python :class:`bytes` object. (Note that :c:func:"
"`PyUnicode_Join` accepts ``NULL`` separator and treats it as a space, "
"whereas :c:func:`PyBytes_Join` doesn't accept ``NULL`` separator.)"
msgstr ""
"*sep* måste vara ett Python :class:`bytes`\\ -objekt. (Observera att :c:func:"
"`PyUnicode_Join` accepterar ``NULL`` separator och behandlar det som ett "
"mellanslag, medan :c:func:`PyBytes_Join` inte accepterar ``NULL`` separator)"

#: ../../c-api/bytes.rst:201
msgid ""
"*iterable* must be an iterable object yielding objects that implement the :"
"ref:`buffer protocol <bufferobjects>`."
msgstr ""
"*iterable* måste vara ett iterabelt objekt som ger objekt som implementerar :"
"ref:`buffer protocol <bufferobjects>`."

#: ../../c-api/bytes.rst:204
msgid ""
"On success, return a new :class:`bytes` object. On error, set an exception "
"and return ``NULL``."
msgstr ""
"Vid framgång returneras ett nytt :class:`bytes`\\ -objekt. Vid fel, ange ett "
"undantag och returnera ``NULL``."

#: ../../c-api/bytes.rst:212
msgid ""
"Resize a bytes object. *newsize* will be the new length of the bytes object. "
"You can think of it as creating a new bytes object and destroying the old "
"one, only more efficiently. Pass the address of an existing bytes object as "
"an lvalue (it may be written into), and the new size desired.  On success, "
"*\\*bytes* holds the resized bytes object and ``0`` is returned; the address "
"in *\\*bytes* may differ from its input value.  If the reallocation fails, "
"the original bytes object at *\\*bytes* is deallocated, *\\*bytes* is set to "
"``NULL``, :exc:`MemoryError` is set, and ``-1`` is returned."
msgstr ""
"Ändra storlek på ett bytes-objekt. *newsize* blir den nya längden på "
"bytesobjektet. Du kan tänka på det som att skapa ett nytt bytes-objekt och "
"förstöra det gamla, fast mer effektivt. Skicka adressen till ett befintligt "
"bytes-objekt som ett l-värde (det kan skrivas in i det) och den nya önskade "
"storleken.  Vid framgång innehåller *\\*bytes* det storleksförändrade "
"bytesobjektet och ``0`` returneras; adressen i *\\*bytes* kan skilja sig "
"från dess ingångsvärde.  Om omallokeringen misslyckas, avallokeras det "
"ursprungliga bytesobjektet i *\\*bytes*, *\\*bytes* sätts till ``NULL``, :"
"exc:`MemoryError` sätts och ``-1`` returneras."

#: ../../c-api/bytes.rst:11
msgid "object"
msgstr "objekt"

#: ../../c-api/bytes.rst:11
msgid "bytes"
msgstr "byte"
