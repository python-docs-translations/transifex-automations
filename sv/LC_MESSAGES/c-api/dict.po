# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-19 14:14+0000\n"
"PO-Revision-Date: 2025-09-16 00:00+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../c-api/dict.rst:6
msgid "Dictionary Objects"
msgstr "Ordboksobjekt"

#: ../../c-api/dict.rst:13
msgid ""
"This subtype of :c:type:`PyObject` represents a Python dictionary object."
msgstr ""
"Denna subtyp av :c:type:`PyObject` representerar ett Python-ordboksobjekt."

#: ../../c-api/dict.rst:18
msgid ""
"This instance of :c:type:`PyTypeObject` represents the Python dictionary "
"type.  This is the same object as :class:`dict` in the Python layer."
msgstr ""
"Denna instans av :c:type:`PyTypeObject` representerar Pythons ordbokstyp.  "
"Detta är samma objekt som :class:`dict` i Python-lagret."

#: ../../c-api/dict.rst:24
msgid ""
"Return true if *p* is a dict object or an instance of a subtype of the dict "
"type.  This function always succeeds."
msgstr ""
"Returnerar true om *p* är ett dict-objekt eller en instans av en subtyp av "
"dict-typen.  Denna funktion lyckas alltid."

#: ../../c-api/dict.rst:30
msgid ""
"Return true if *p* is a dict object, but not an instance of a subtype of the "
"dict type.  This function always succeeds."
msgstr ""
"Returnerar true om *p* är ett dict-objekt, men inte en instans av en subtyp "
"av dict-typen.  Denna funktion lyckas alltid."

#: ../../c-api/dict.rst:36
msgid "Return a new empty dictionary, or ``NULL`` on failure."
msgstr "Returnerar en ny tom ordbok, eller ``NULL`` om den misslyckas."

#: ../../c-api/dict.rst:41
msgid ""
"Return a :class:`types.MappingProxyType` object for a mapping which enforces "
"read-only behavior.  This is normally used to create a view to prevent "
"modification of the dictionary for non-dynamic class types."
msgstr ""
"Returnerar ett :class:`types.MappingProxyType`\\-objekt för en mappning som "
"kräver skrivskyddad läsning.  Detta används normalt för att skapa en vy som "
"förhindrar ändring av ordlistan för icke-dynamiska klasstyper."

#: ../../c-api/dict.rst:48
msgid "Empty an existing dictionary of all key-value pairs."
msgstr "Tömmer en befintlig ordbok på alla nyckel-värde-par."

#: ../../c-api/dict.rst:53
msgid ""
"Determine if dictionary *p* contains *key*.  If an item in *p* matches "
"*key*, return ``1``, otherwise return ``0``.  On error, return ``-1``. This "
"is equivalent to the Python expression ``key in p``."
msgstr ""

#: ../../c-api/dict.rst:60
msgid ""
"This is the same as :c:func:`PyDict_Contains`, but *key* is specified as a :"
"c:expr:`const char*` UTF-8 encoded bytes string, rather than a :c:expr:"
"`PyObject*`."
msgstr ""
"Detta är samma sak som :c:func:`PyDict_Contains`, men *key* anges som en :c:"
"expr:`const char*` UTF-8-kodad bytessträng, i stället för ett :c:expr:"
"`PyObject*`."

#: ../../c-api/dict.rst:69
msgid "Return a new dictionary that contains the same key-value pairs as *p*."
msgstr ""
"Returnerar en ny dictionary som innehåller samma nyckel-värde-par som *p*."

#: ../../c-api/dict.rst:74
msgid ""
"Insert *val* into the dictionary *p* with a key of *key*.  *key* must be :"
"term:`hashable`; if it isn't, :exc:`TypeError` will be raised. Return ``0`` "
"on success or ``-1`` on failure.  This function *does not* steal a reference "
"to *val*."
msgstr ""
"Infogar *val* i ordlistan *p* med nyckeln *key*.  *key* måste vara :term:"
"`hashable`; om den inte är det kommer :exc:`TypeError` att returneras. "
"Returnerar ``0`` vid framgång eller ``\\-1`` vid misslyckande.  Denna "
"funktion *stjäl* inte en referens till *val*."

#: ../../c-api/dict.rst:82
msgid ""
"This is the same as :c:func:`PyDict_SetItem`, but *key* is specified as a :c:"
"expr:`const char*` UTF-8 encoded bytes string, rather than a :c:expr:"
"`PyObject*`."
msgstr ""
"Detta är samma sak som :c:func:`PyDict_SetItem`, men *key* anges som en :c:"
"expr:`const char*` UTF-8-kodad bytessträng, i stället för en :c:expr:"
"`PyObject*`."

#: ../../c-api/dict.rst:89
msgid ""
"Remove the entry in dictionary *p* with key *key*. *key* must be :term:"
"`hashable`; if it isn't, :exc:`TypeError` is raised. If *key* is not in the "
"dictionary, :exc:`KeyError` is raised. Return ``0`` on success or ``-1`` on "
"failure."
msgstr ""
"Tar bort posten i ordlistan *p* med nyckeln *key*. *key* måste vara :term:"
"`hashable`; om den inte är det, :exc:`TypeError`. Om *key* inte finns i "
"ordlistan, :exc:`KeyError`. Returnerar ``0`` vid framgång eller ``\\-1`` vid "
"misslyckande."

#: ../../c-api/dict.rst:97
msgid ""
"This is the same as :c:func:`PyDict_DelItem`, but *key* is specified as a :c:"
"expr:`const char*` UTF-8 encoded bytes string, rather than a :c:expr:"
"`PyObject*`."
msgstr ""
"Detta är samma sak som :c:func:`PyDict_DelItem`, men *key* anges som en :c:"
"expr:`const char*` UTF-8-kodad bytessträng, istället för en :c:expr:"
"`PyObject*`."

#: ../../c-api/dict.rst:104
msgid ""
"Return a new :term:`strong reference` to the object from dictionary *p* "
"which has a key *key*:"
msgstr ""
"Returnerar en ny :term:`strong reference` till det objekt från ordlistan *p* "
"som har nyckeln *key*:"

#: ../../c-api/dict.rst:107
msgid ""
"If the key is present, set *\\*result* to a new :term:`strong reference` to "
"the value and return ``1``."
msgstr ""
"Om nyckeln finns, sätt *\\*result* till en ny :term:`strong reference` till "
"värdet och returnera ``1``."

#: ../../c-api/dict.rst:109
msgid "If the key is missing, set *\\*result* to ``NULL`` and return ``0``."
msgstr "Om nyckeln saknas, sätt *\\*result* till ``NULL`` och returnera ``0``."

#: ../../c-api/dict.rst:110 ../../c-api/dict.rst:207
msgid "On error, raise an exception and return ``-1``."
msgstr "Vid fel, skapa ett undantag och returnera ``\\-1``."

#: ../../c-api/dict.rst:114
msgid "See also the :c:func:`PyObject_GetItem` function."
msgstr "Se även funktionen :c:func:`PyObject_GetItem`."

#: ../../c-api/dict.rst:119
msgid ""
"Return a :term:`borrowed reference` to the object from dictionary *p* which "
"has a key *key*.  Return ``NULL`` if the key *key* is missing *without* "
"setting an exception."
msgstr ""
"Returnerar en :term:`lånad referens` till det objekt från ordlistan *p* som "
"har nyckeln *key*.  Returnerar ``NULL`` om nyckeln *key* saknas *utan* att "
"ett undantag anges."

#: ../../c-api/dict.rst:125
msgid ""
"Exceptions that occur while this calls :meth:`~object.__hash__` and :meth:"
"`~object.__eq__` methods are silently ignored. Prefer the :c:func:"
"`PyDict_GetItemWithError` function instead."
msgstr ""
"Undantag som inträffar när detta anropar metoderna :meth:`~object.__hash__` "
"och :meth:`~object.__eq__` ignoreras tyst. Föredra funktionen :c:func:"
"`PyDict_GetItemWithError` istället."

#: ../../c-api/dict.rst:129
msgid ""
"Calling this API without an :term:`attached thread state` had been allowed "
"for historical reason. It is no longer allowed."
msgstr ""
"Att anropa detta API utan en :term:`attached thread state` hade varit "
"tillåtet av historiska skäl. Det är inte längre tillåtet."

#: ../../c-api/dict.rst:136
msgid ""
"Variant of :c:func:`PyDict_GetItem` that does not suppress exceptions. "
"Return ``NULL`` **with** an exception set if an exception occurred.  Return "
"``NULL`` **without** an exception set if the key wasn't present."
msgstr ""
"Variant av :c:func:`PyDict_GetItem` som inte undertrycker undantag. "
"Returnerar ``NULL`` **med** en undantagsuppsättning om ett undantag "
"inträffade.  Returnerar ``NULL`` **utan** en undantagsuppsättning om nyckeln "
"inte fanns."

#: ../../c-api/dict.rst:144
msgid ""
"This is the same as :c:func:`PyDict_GetItem`, but *key* is specified as a :c:"
"expr:`const char*` UTF-8 encoded bytes string, rather than a :c:expr:"
"`PyObject*`."
msgstr ""
"Detta är samma sak som :c:func:`PyDict_GetItem`, men *key* anges som en :c:"
"expr:`const char*` UTF-8-kodad bytessträng, i stället för en :c:expr:"
"`PyObject*`."

#: ../../c-api/dict.rst:150
msgid ""
"Exceptions that occur while this calls :meth:`~object.__hash__` and :meth:"
"`~object.__eq__` methods or while creating the temporary :class:`str` object "
"are silently ignored. Prefer using the :c:func:`PyDict_GetItemWithError` "
"function with your own :c:func:`PyUnicode_FromString` *key* instead."
msgstr ""
"Undantag som inträffar när detta anropar metoderna :meth:`~object.__hash__` "
"och :meth:`~object.__eq__` eller när det tillfälliga :class:`str`\\-objektet "
"skapas ignoreras i tysthet. Använd hellre funktionen :c:func:"
"`PyDict_GetItemWithError` med din egen :c:func:`PyUnicode_FromString` *key* "
"istället."

#: ../../c-api/dict.rst:159
msgid ""
"Similar to :c:func:`PyDict_GetItemRef`, but *key* is specified as a :c:expr:"
"`const char*` UTF-8 encoded bytes string, rather than a :c:expr:`PyObject*`."
msgstr ""
"Liknar :c:func:`PyDict_GetItemRef`, men *key* anges som en :c:expr:`const "
"char*` UTF-8-kodad bytessträng, i stället för en :c:expr:`PyObject*`."

#: ../../c-api/dict.rst:168
msgid ""
"This is the same as the Python-level :meth:`dict.setdefault`.  If present, "
"it returns the value corresponding to *key* from the dictionary *p*.  If the "
"key is not in the dict, it is inserted with value *defaultobj* and "
"*defaultobj* is returned.  This function evaluates the hash function of "
"*key* only once, instead of evaluating it independently for the lookup and "
"the insertion."
msgstr ""
"Detta är samma sak som Python-nivå :meth:`dict.setdefault`.  Om den finns "
"returnerar den värdet som motsvarar *key* från ordlistan *p*.  Om nyckeln "
"inte finns i dict, infogas den med värdet *defaultobj* och *defaultobj* "
"returneras.  Denna funktion utvärderar hashfunktionen för *key* endast en "
"gång, i stället för att utvärdera den oberoende av varandra för uppslagning "
"och infogning."

#: ../../c-api/dict.rst:179
msgid ""
"Inserts *default_value* into the dictionary *p* with a key of *key* if the "
"key is not already present in the dictionary. If *result* is not ``NULL``, "
"then *\\*result* is set to a :term:`strong reference` to either "
"*default_value*, if the key was not present, or the existing value, if *key* "
"was already present in the dictionary. Returns ``1`` if the key was present "
"and *default_value* was not inserted, or ``0`` if the key was not present "
"and *default_value* was inserted. On failure, returns ``-1``, sets an "
"exception, and sets ``*result`` to ``NULL``."
msgstr ""
"Lägger till *default_value* i ordlistan *p* med nyckeln *key* om nyckeln "
"inte redan finns i ordlistan. Om *result* inte är ``NULL``, sätts "
"*\\*result* till en :term:`strong reference` till antingen *default_value*, "
"om nyckeln inte fanns, eller det befintliga värdet, om *key* redan fanns i "
"ordlistan. Returnerar ``1`` om nyckeln fanns och *default_value* inte "
"infogades, eller ``0`` om nyckeln inte fanns och *default_value* infogades. "
"Vid misslyckande returneras ``\\-1``, ett undantag skapas och ``*result`` "
"sätts till ``NULL``."

#: ../../c-api/dict.rst:189
msgid ""
"For clarity: if you have a strong reference to *default_value* before "
"calling this function, then after it returns, you hold a strong reference to "
"both *default_value* and *\\*result* (if it's not ``NULL``). These may refer "
"to the same object: in that case you hold two separate references to it."
msgstr ""
"För tydlighetens skull: om du har en stark referens till *default_value* "
"innan du anropar den här funktionen, så har du en stark referens till både "
"*default_value* och *\\*result* (om det inte är ``NULL``) efter att den har "
"returnerat. Dessa kan referera till samma objekt: i så fall har du två "
"separata referenser till det."

#: ../../c-api/dict.rst:200
msgid ""
"Remove *key* from dictionary *p* and optionally return the removed value. Do "
"not raise :exc:`KeyError` if the key is missing."
msgstr ""

#: ../../c-api/dict.rst:203
msgid ""
"If the key is present, set *\\*result* to a new reference to the removed "
"value if *result* is not ``NULL``, and return ``1``."
msgstr ""
"Om nyckeln finns, sätt *\\*result* till en ny referens till det borttagna "
"värdet om *result* inte är ``NULL``, och returnera ``1``."

#: ../../c-api/dict.rst:205
msgid ""
"If the key is missing, set *\\*result* to ``NULL`` if *result* is not "
"``NULL``, and return ``0``."
msgstr ""
"Om nyckeln saknas, sätt *\\*result* till ``NULL`` om *result* inte är "
"``NULL``, och returnera ``0``."

#: ../../c-api/dict.rst:209
msgid ""
"Similar to :meth:`dict.pop`, but without the default value and not raising :"
"exc:`KeyError` if the key is missing."
msgstr ""

#: ../../c-api/dict.rst:217
msgid ""
"Similar to :c:func:`PyDict_Pop`, but *key* is specified as a :c:expr:`const "
"char*` UTF-8 encoded bytes string, rather than a :c:expr:`PyObject*`."
msgstr ""
"Liknar :c:func:`PyDict_Pop`, men *key* anges som en :c:expr:`const char*` "
"UTF-8-kodad bytessträng, i stället för ett :c:expr:`PyObject*`."

#: ../../c-api/dict.rst:226
msgid ""
"Return a :c:type:`PyListObject` containing all the items from the dictionary."
msgstr ""
"Returnerar ett :c:type:`PyListObject` som innehåller alla objekt från "
"ordlistan."

#: ../../c-api/dict.rst:231
msgid ""
"Return a :c:type:`PyListObject` containing all the keys from the dictionary."
msgstr ""
"Returnerar ett :c:type:`PyListObject` som innehåller alla nycklar från "
"ordlistan."

#: ../../c-api/dict.rst:236
msgid ""
"Return a :c:type:`PyListObject` containing all the values from the "
"dictionary *p*."
msgstr ""
"Returnerar ett :c:type:`PyListObject` som innehåller alla värden från "
"ordlistan *p*."

#: ../../c-api/dict.rst:244
msgid ""
"Return the number of items in the dictionary.  This is equivalent to "
"``len(p)`` on a dictionary."
msgstr ""
"Returnerar antalet objekt i ordlistan.  Detta är likvärdigt med ``len(p)`` "
"för en ordbok."

#: ../../c-api/dict.rst:250
msgid "Similar to :c:func:`PyDict_Size`, but without error checking."
msgstr ""

#: ../../c-api/dict.rst:255
msgid ""
"Iterate over all key-value pairs in the dictionary *p*.  The :c:type:"
"`Py_ssize_t` referred to by *ppos* must be initialized to ``0`` prior to the "
"first call to this function to start the iteration; the function returns "
"true for each pair in the dictionary, and false once all pairs have been "
"reported.  The parameters *pkey* and *pvalue* should either point to :c:expr:"
"`PyObject*` variables that will be filled in with each key and value, "
"respectively, or may be ``NULL``.  Any references returned through them are "
"borrowed.  *ppos* should not be altered during iteration. Its value "
"represents offsets within the internal dictionary structure, and since the "
"structure is sparse, the offsets are not consecutive."
msgstr ""
"Iterera över alla nyckel-värde-par i ordlistan *p*.  Den :c:type:"
"`Py_ssize_t` som hänvisas till av *ppos* måste initialiseras till ``0`` före "
"det första anropet till denna funktion för att starta iterationen; "
"funktionen returnerar true för varje par i ordlistan och false när alla par "
"har rapporterats.  Parametrarna *pkey* och *pvalue* ska antingen peka på :c:"
"expr:`PyObject*`\\-variabler som kommer att fyllas i med varje nyckel "
"respektive värde, eller vara ``NULL``.  Alla referenser som returneras genom "
"dem lånas.  *ppos* bör inte ändras under iterationen. Dess värde "
"representerar offsets inom den interna ordboksstrukturen, och eftersom "
"strukturen är gles är offseten inte konsekutiva."

#: ../../c-api/dict.rst:266
msgid "For example::"
msgstr "Till exempel::"

#: ../../c-api/dict.rst:268
msgid ""
"PyObject *key, *value;\n"
"Py_ssize_t pos = 0;\n"
"\n"
"while (PyDict_Next(self->dict, &pos, &key, &value)) {\n"
"    /* do something interesting with the values... */\n"
"    ...\n"
"}"
msgstr ""
"PyObject *nyckel, *värde;\n"
"Py_ssize_t pos = 0;\n"
"\n"
"while (PyDict_Next(self->dict, &pos, &key, &value)) {\n"
"    /* gör något intressant med värdena... */\n"
"    ...\n"
"}"

#: ../../c-api/dict.rst:276
msgid ""
"The dictionary *p* should not be mutated during iteration.  It is safe to "
"modify the values of the keys as you iterate over the dictionary, but only "
"so long as the set of keys does not change.  For example::"
msgstr ""
"Ordboken *p* ska inte ändras under iterationen.  Det är säkert att ändra "
"värdena på nycklarna när du itererar över ordlistan, men bara så länge som "
"uppsättningen nycklar inte ändras.  Till exempel::"

#: ../../c-api/dict.rst:280
msgid ""
"PyObject *key, *value;\n"
"Py_ssize_t pos = 0;\n"
"\n"
"while (PyDict_Next(self->dict, &pos, &key, &value)) {\n"
"    long i = PyLong_AsLong(value);\n"
"    if (i == -1 && PyErr_Occurred()) {\n"
"        return -1;\n"
"    }\n"
"    PyObject *o = PyLong_FromLong(i + 1);\n"
"    if (o == NULL)\n"
"        return -1;\n"
"    if (PyDict_SetItem(self->dict, key, o) < 0) {\n"
"        Py_DECREF(o);\n"
"        return -1;\n"
"    }\n"
"    Py_DECREF(o);\n"
"}"
msgstr ""
"PyObject *key, *value;\n"
"Py_ssize_t pos = 0;\n"
"\n"
"while (PyDict_Next(self->dict, &pos, &key, &value)) {\n"
"    long i = PyLong_AsLong(value);\n"
"    if (i == -1 && PyErr_Occurred()) {\n"
"        return -1;\n"
"    }\n"
"    PyObject *o = PyLong_FromLong(i + 1);\n"
"    if (o == NULL)\n"
"        return -1;\n"
"    if (PyDict_SetItem(self->dict, key, o) < 0) {\n"
"        Py_DECREF(o);\n"
"        return -1;\n"
"    }\n"
"    Py_DECREF(o);\n"
"}"

#: ../../c-api/dict.rst:298
msgid ""
"The function is not thread-safe in the :term:`free-threaded <free "
"threading>` build without external synchronization.  You can use :c:macro:"
"`Py_BEGIN_CRITICAL_SECTION` to lock the dictionary while iterating over it::"
msgstr ""
"Funktionen är inte trådsäker i :term:`free-threaded <free threading>`\\-"
"byggnaden utan extern synkronisering.  Du kan använda :c:macro:"
"`Py_BEGIN_CRITICAL_SECTION` för att låsa ordlistan medan du itererar över "
"den::"

#: ../../c-api/dict.rst:303
msgid ""
"Py_BEGIN_CRITICAL_SECTION(self->dict);\n"
"while (PyDict_Next(self->dict, &pos, &key, &value)) {\n"
"    ...\n"
"}\n"
"Py_END_CRITICAL_SECTION();"
msgstr ""
"Py_BEGIN_CRITICAL_SECTION(själv>dict);\n"
"while (PyDict_Next(self->dict, &pos, &key, &value)) {\n"
"    ...\n"
"}\n"
"Py_END_CRITICAL_SECTION();"

#: ../../c-api/dict.rst:311
msgid ""
"On the free-threaded build, this function can be used safely inside a "
"critical section. However, the references returned for *pkey* and *pvalue* "
"are :term:`borrowed <borrowed reference>` and are only valid while the "
"critical section is held. If you need to use these objects outside the "
"critical section or when the critical section can be suspended, create a :"
"term:`strong reference <strong reference>` (for example, using :c:func:"
"`Py_NewRef`)."
msgstr ""
"I det fritt trådade bygget kan denna funktion användas säkert inom en "
"kritisk sektion. Referenserna som returneras för *pkey* och *pvalue* är "
"dock :term:`lånade <borrowed reference>` och är endast giltiga vid den "
"kritiska sektionen. Om du behöver använda dessa objekt utanför den kritiska "
"sektionen eller när den kritiska sektionen kan avbrytas, skapa en :term:"
"`strong reference <strong reference>` (till exempel med :c:func:`Py_NewRef`)."

#: ../../c-api/dict.rst:321
msgid ""
"Iterate over mapping object *b* adding key-value pairs to dictionary *a*. "
"*b* may be a dictionary, or any object supporting :c:func:`PyMapping_Keys` "
"and :c:func:`PyObject_GetItem`. If *override* is true, existing pairs in *a* "
"will be replaced if a matching key is found in *b*, otherwise pairs will "
"only be added if there is not a matching key in *a*. Return ``0`` on success "
"or ``-1`` if an exception was raised."
msgstr ""
"Iterera över mappningsobjektet *b* och lägg till nyckel-värdepar i ordboken "
"*a*. *b* kan vara en ordbok eller ett objekt som stöder :c:func:"
"`PyMapping_Keys` och :c:func:`PyObject_GetItem`. Om *override* är true "
"kommer befintliga par i *a* att ersättas om en matchande nyckel hittas i "
"*b*, annars kommer par endast att läggas till om det inte finns någon "
"matchande nyckel i *a*. Returnerar ``0`` vid framgång eller ``\\-1`` om ett "
"undantag har uppstått."

#: ../../c-api/dict.rst:331
msgid ""
"This is the same as ``PyDict_Merge(a, b, 1)`` in C, and is similar to ``a."
"update(b)`` in Python except that :c:func:`PyDict_Update` doesn't fall back "
"to the iterating over a sequence of key value pairs if the second argument "
"has no \"keys\" attribute.  Return ``0`` on success or ``-1`` if an "
"exception was raised."
msgstr ""
"Detta är samma sak som ``PyDict_Merge(a, b, 1)`` i C, och liknar ``a."
"update(b)`` i Python förutom att :c:func:`PyDict_Update` inte faller "
"tillbaka till att iterera över en sekvens av nyckel-värde-par om det andra "
"argumentet inte har något \"keys\"-attribut.  Returnerar ``0`` vid framgång "
"eller ``\\-1`` om ett undantag uppstod."

#: ../../c-api/dict.rst:340
msgid ""
"Update or merge into dictionary *a*, from the key-value pairs in *seq2*. "
"*seq2* must be an iterable object producing iterable objects of length 2, "
"viewed as key-value pairs.  In case of duplicate keys, the last wins if "
"*override* is true, else the first wins. Return ``0`` on success or ``-1`` "
"if an exception was raised. Equivalent Python (except for the return value)::"
msgstr ""
"Uppdatera eller sammanfoga till ordboken *a*, från nyckelvärdeparen i "
"*seq2*. *seq2* måste vara ett itererbart objekt som producerar itererbara "
"objekt med längden 2, betraktade som nyckel-värdepar.  Vid duplicerade "
"nycklar vinner den sista om *override* är sant, annars vinner den första. "
"Returnerar ``0`` vid framgång eller ``\\-1`` om ett undantag uppstod. "
"Motsvarande Python (förutom returvärdet)::"

#: ../../c-api/dict.rst:347
msgid ""
"def PyDict_MergeFromSeq2(a, seq2, override):\n"
"    for key, value in seq2:\n"
"        if override or key not in a:\n"
"            a[key] = value"
msgstr ""
"def PyDict_MergeFromSeq2(a, seq2, override):\n"
"    för nyckel, värde i seq2:\n"
"        om override eller key inte finns i a:\n"
"            a[nyckel] = värde"

#: ../../c-api/dict.rst:354
msgid ""
"Register *callback* as a dictionary watcher. Return a non-negative integer "
"id which must be passed to future calls to :c:func:`PyDict_Watch`. In case "
"of error (e.g. no more watcher IDs available), return ``-1`` and set an "
"exception."
msgstr ""
"Registrera *callback* som en dictionary watcher. Returnera ett icke-negativt "
"heltals-id som måste skickas till framtida anrop till :c:func:"
"`PyDict_Watch`. I händelse av fel (t.ex. inga fler bevaknings-IDs "
"tillgängliga), returnera ``\\-1`` och sätt ett undantag."

#: ../../c-api/dict.rst:363
msgid ""
"Clear watcher identified by *watcher_id* previously returned from :c:func:"
"`PyDict_AddWatcher`. Return ``0`` on success, ``-1`` on error (e.g. if the "
"given *watcher_id* was never registered.)"
msgstr ""
"Rensa bevakare identifierad av *watcher_id* som tidigare returnerats från :c:"
"func:`PyDict_AddWatcher`. Returnerar ``0`` vid framgång, ``\\-1`` vid fel (t."
"ex. om det givna *watcher_id* aldrig registrerades)"

#: ../../c-api/dict.rst:371
msgid ""
"Mark dictionary *dict* as watched. The callback granted *watcher_id* by :c:"
"func:`PyDict_AddWatcher` will be called when *dict* is modified or "
"deallocated. Return ``0`` on success or ``-1`` on error."
msgstr ""
"Markera ordboken *dict* som bevakad. Återkallelsen som tilldelats "
"*watcher_id* av :c:func:`PyDict_AddWatcher` kommer att anropas när *dict* "
"ändras eller avallokeras. Returnerar ``0`` vid framgång eller ``\\-1`` vid "
"fel."

#: ../../c-api/dict.rst:379
msgid ""
"Mark dictionary *dict* as no longer watched. The callback granted "
"*watcher_id* by :c:func:`PyDict_AddWatcher` will no longer be called when "
"*dict* is modified or deallocated. The dict must previously have been "
"watched by this watcher. Return ``0`` on success or ``-1`` on error."
msgstr ""
"Markera ordboken *dict* som inte längre bevakad. Återkallelsen som "
"tilldelades *watcher_id* av :c:func:`PyDict_AddWatcher` kommer inte längre "
"att anropas när *dict* ändras eller avallokeras. Dict måste tidigare ha "
"bevakats av denna bevakare. Returnerar ``0`` vid framgång eller ``\\-1`` vid "
"fel."

#: ../../c-api/dict.rst:388
msgid ""
"Enumeration of possible dictionary watcher events: ``PyDict_EVENT_ADDED``, "
"``PyDict_EVENT_MODIFIED``, ``PyDict_EVENT_DELETED``, "
"``PyDict_EVENT_CLONED``, ``PyDict_EVENT_CLEARED``, or "
"``PyDict_EVENT_DEALLOCATED``."
msgstr ""
"Uppräkning av möjliga händelser för ordboksövervakare: "
"``PyDict_EVENT_ADDED``, ``PyDict_EVENT_MODIFIED``, ``PyDict_EVENT_DELETED``, "
"``PyDict_EVENT_CLONED``, ``PyDict_EVENT_CLEARED`` eller "
"``PyDict_EVENT_DEALLOCATED``."

#: ../../c-api/dict.rst:396
msgid "Type of a dict watcher callback function."
msgstr "Typ av återuppringningsfunktion för en dict watcher."

#: ../../c-api/dict.rst:398
msgid ""
"If *event* is ``PyDict_EVENT_CLEARED`` or ``PyDict_EVENT_DEALLOCATED``, both "
"*key* and *new_value* will be ``NULL``. If *event* is ``PyDict_EVENT_ADDED`` "
"or ``PyDict_EVENT_MODIFIED``, *new_value* will be the new value for *key*. "
"If *event* is ``PyDict_EVENT_DELETED``, *key* is being deleted from the "
"dictionary and *new_value* will be ``NULL``."
msgstr ""
"Om *event* är ``PyDict_EVENT_CLEARED`` eller ``PyDict_EVENT_DEALLOCATED`` "
"kommer både *key* och *new_value* att vara ``NULL``. Om *event* är "
"``PyDict_EVENT_ADDED`` eller ``PyDict_EVENT_MODIFIED``, kommer *new_value* "
"att vara det nya värdet för *key*. Om *event* är ``PyDict_EVENT_DELETED`` "
"raderas *key* från ordlistan och *new_value* blir ``NULL``."

#: ../../c-api/dict.rst:404
msgid ""
"``PyDict_EVENT_CLONED`` occurs when *dict* was previously empty and another "
"dict is merged into it. To maintain efficiency of this operation, per-key "
"``PyDict_EVENT_ADDED`` events are not issued in this case; instead a single "
"``PyDict_EVENT_CLONED`` is issued, and *key* will be the source dictionary."
msgstr ""
"``PyDict_EVENT_CLONED`` inträffar när *dict* tidigare var tomt och en annan "
"dict har slagits samman med det. För att upprätthålla effektiviteten i denna "
"operation utfärdas inte händelser per nyckel ``PyDict_EVENT_ADDED`` i detta "
"fall. Istället utfärdas en enda ``PyDict_EVENT_CLONED``, och *key* blir "
"källordlistan."

#: ../../c-api/dict.rst:410
msgid ""
"The callback may inspect but must not modify *dict*; doing so could have "
"unpredictable effects, including infinite recursion. Do not trigger Python "
"code execution in the callback, as it could modify the dict as a side effect."
msgstr ""
"Callbacken kan inspektera men får inte modifiera *dict*; att göra det kan få "
"oförutsägbara effekter, inklusive oändlig rekursion. Utlös inte exekvering "
"av Python-kod i återuppringningen, eftersom det kan ändra dict som en "
"bieffekt."

#: ../../c-api/dict.rst:414
msgid ""
"If *event* is ``PyDict_EVENT_DEALLOCATED``, taking a new reference in the "
"callback to the about-to-be-destroyed dictionary will resurrect it and "
"prevent it from being freed at this time. When the resurrected object is "
"destroyed later, any watcher callbacks active at that time will be called "
"again."
msgstr ""
"Om *event* är ``PyDict_EVENT_DEALLOCATED`` kommer en ny referens i "
"återuppringningen till den ordbok som ska förstöras att återuppliva den och "
"förhindra att den frigörs vid den här tidpunkten. När det återupplivade "
"objektet förstörs senare, kommer alla watchers callbacks som är aktiva vid "
"den tidpunkten att anropas igen."

#: ../../c-api/dict.rst:420
msgid ""
"Callbacks occur before the notified modification to *dict* takes place, so "
"the prior state of *dict* can be inspected."
msgstr ""
"Återkallelser sker innan den aviserade modifieringen av *dict* äger rum, så "
"att *dict* tidigare tillstånd kan inspekteras."

#: ../../c-api/dict.rst:423
msgid ""
"If the callback sets an exception, it must return ``-1``; this exception "
"will be printed as an unraisable exception using :c:func:"
"`PyErr_WriteUnraisable`. Otherwise it should return ``0``."
msgstr ""
"Om callbacken anger ett undantag måste den returnera ``\\-1``; detta "
"undantag kommer att skrivas ut som ett undantag som inte kan bedömas med :c:"
"func:`PyErr_WriteUnraisable`. Annars bör det returnera ``0``."

#: ../../c-api/dict.rst:427
msgid ""
"There may already be a pending exception set on entry to the callback. In "
"this case, the callback should return ``0`` with the same exception still "
"set. This means the callback may not call any other API that can set an "
"exception unless it saves and clears the exception state first, and restores "
"it before returning."
msgstr ""
"Det kan redan finnas ett väntande undantag inställt vid ingången till "
"återuppringningen. I detta fall bör återuppringningen returnera ``0`` med "
"samma undantag fortfarande inställt. Detta innebär att återuppringningen "
"inte får anropa något annat API som kan ställa in ett undantag om det inte "
"sparar och rensar undantagstillståndet först och återställer det innan det "
"returneras."

#: ../../c-api/dict.rst:437
msgid "Dictionary View Objects"
msgstr ""

#: ../../c-api/dict.rst:441
msgid ""
"Return true if *op* is a view of a set inside a dictionary. This is "
"currently equivalent to :c:expr:`PyDictKeys_Check(op) || "
"PyDictItems_Check(op)`. This function always succeeds."
msgstr ""

#: ../../c-api/dict.rst:448
msgid ""
"Type object for a view of dictionary keys. In Python, this is the type of "
"the object returned by :meth:`dict.keys`."
msgstr ""

#: ../../c-api/dict.rst:454
msgid ""
"Return true if *op* is an instance of a dictionary keys view. This function "
"always succeeds."
msgstr ""

#: ../../c-api/dict.rst:460
msgid ""
"Type object for a view of dictionary values. In Python, this is the type of "
"the object returned by :meth:`dict.values`."
msgstr ""

#: ../../c-api/dict.rst:466
msgid ""
"Return true if *op* is an instance of a dictionary values view. This "
"function always succeeds."
msgstr ""

#: ../../c-api/dict.rst:472
msgid ""
"Type object for a view of dictionary items. In Python, this is the type of "
"the object returned by :meth:`dict.items`."
msgstr ""

#: ../../c-api/dict.rst:478
msgid ""
"Return true if *op* is an instance of a dictionary items view. This function "
"always succeeds."
msgstr ""

#: ../../c-api/dict.rst:483
msgid "Ordered Dictionaries"
msgstr ""

#: ../../c-api/dict.rst:485
msgid ""
"Python's C API provides interface for :class:`collections.OrderedDict` from "
"C. Since Python 3.7, dictionaries are ordered by default, so there is "
"usually little need for these functions; prefer ``PyDict*`` where possible."
msgstr ""

#: ../../c-api/dict.rst:492
msgid ""
"Type object for ordered dictionaries. This is the same object as :class:"
"`collections.OrderedDict` in the Python layer."
msgstr ""

#: ../../c-api/dict.rst:498
msgid ""
"Return true if *od* is an ordered dictionary object or an instance of a "
"subtype of the :class:`~collections.OrderedDict` type.  This function always "
"succeeds."
msgstr ""

#: ../../c-api/dict.rst:505
msgid ""
"Return true if *od* is an ordered dictionary object, but not an instance of "
"a subtype of the :class:`~collections.OrderedDict` type. This function "
"always succeeds."
msgstr ""

#: ../../c-api/dict.rst:512
msgid "Analogous to :c:type:`PyDictKeys_Type` for ordered dictionaries."
msgstr ""

#: ../../c-api/dict.rst:517
msgid "Analogous to :c:type:`PyDictValues_Type` for ordered dictionaries."
msgstr ""

#: ../../c-api/dict.rst:522
msgid "Analogous to :c:type:`PyDictItems_Type` for ordered dictionaries."
msgstr ""

#: ../../c-api/dict.rst:527
msgid "Return a new empty ordered dictionary, or ``NULL`` on failure."
msgstr ""

#: ../../c-api/dict.rst:529
msgid "This is analogous to :c:func:`PyDict_New`."
msgstr ""

#: ../../c-api/dict.rst:534
msgid ""
"Insert *value* into the ordered dictionary *od* with a key of *key*. Return "
"``0`` on success or ``-1`` with an exception set on failure."
msgstr ""

#: ../../c-api/dict.rst:537
msgid "This is analogous to :c:func:`PyDict_SetItem`."
msgstr ""

#: ../../c-api/dict.rst:542
msgid ""
"Remove the entry in the ordered dictionary *od* with key *key*. Return ``0`` "
"on success or ``-1`` with an exception set on failure."
msgstr ""

#: ../../c-api/dict.rst:545
msgid "This is analogous to :c:func:`PyDict_DelItem`."
msgstr ""

#: ../../c-api/dict.rst:548
msgid "These are :term:`soft deprecated` aliases to ``PyDict`` APIs:"
msgstr ""

#: ../../c-api/dict.rst:555
msgid "``PyODict``"
msgstr ""

#: ../../c-api/dict.rst:556
msgid "``PyDict``"
msgstr ""

#: ../../c-api/dict.rst:558
msgid ":c:func:`PyDict_GetItem`"
msgstr ":c:func:`PyDict_GetItem`"

#: ../../c-api/dict.rst:560
msgid ":c:func:`PyDict_GetItemWithError`"
msgstr ":c:func:`PyDict_GetItemWithError`"

#: ../../c-api/dict.rst:562
msgid ":c:func:`PyDict_GetItemString`"
msgstr ":c:func:`PyDict_GetItemString`"

#: ../../c-api/dict.rst:564
msgid ":c:func:`PyDict_Contains`"
msgstr ""

#: ../../c-api/dict.rst:566
msgid ":c:func:`PyDict_Size`"
msgstr ""

#: ../../c-api/dict.rst:568
msgid ":c:func:`PyDict_GET_SIZE`"
msgstr ""

#: ../../c-api/dict.rst:8
msgid "object"
msgstr "objekt"

#: ../../c-api/dict.rst:8
msgid "dictionary"
msgstr "ordbok"

#: ../../c-api/dict.rst:242
msgid "built-in function"
msgstr "inbyggd funktion"

#: ../../c-api/dict.rst:242
msgid "len"
msgstr "len"
