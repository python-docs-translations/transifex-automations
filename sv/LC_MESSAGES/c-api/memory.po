# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# python-doc bot, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-25 16:33+0000\n"
"PO-Revision-Date: 2025-09-22 16:49+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../c-api/memory.rst:8
msgid "Memory Management"
msgstr "Minneshantering"

#: ../../c-api/memory.rst:17
msgid "Overview"
msgstr "Översikt"

#: ../../c-api/memory.rst:19
msgid ""
"Memory management in Python involves a private heap containing all Python "
"objects and data structures. The management of this private heap is ensured "
"internally by the *Python memory manager*.  The Python memory manager has "
"different components which deal with various dynamic storage management "
"aspects, like sharing, segmentation, preallocation or caching."
msgstr ""
"Minneshantering i Python innebär en privat hög som innehåller alla Python-"
"objekt och datastrukturer. Hanteringen av denna privata hög sköts internt av"
" *Pythons minneshanterare*.  Pythons minneshanterare har olika komponenter "
"som hanterar olika aspekter av dynamisk lagringshantering, t.ex. delning, "
"segmentering, förallokering eller cachning."

#: ../../c-api/memory.rst:25
msgid ""
"At the lowest level, a raw memory allocator ensures that there is enough "
"room in the private heap for storing all Python-related data by interacting "
"with the memory manager of the operating system. On top of the raw memory "
"allocator, several object-specific allocators operate on the same heap and "
"implement distinct memory management policies adapted to the peculiarities "
"of every object type. For example, integer objects are managed differently "
"within the heap than strings, tuples or dictionaries because integers imply "
"different storage requirements and speed/space tradeoffs. The Python memory "
"manager thus delegates some of the work to the object-specific allocators, "
"but ensures that the latter operate within the bounds of the private heap."
msgstr ""
"På den lägsta nivån ser en råminnesallokerare till att det finns "
"tillräckligt med utrymme i den privata heapen för att lagra alla Python-"
"relaterade data genom att interagera med operativsystemets minneshanterare. "
"Utöver råminnesallokeringen arbetar flera objektspecifika allokeringar på "
"samma hög och implementerar olika minneshanteringspolicyer som är anpassade "
"till varje objekttyps särdrag. Exempelvis hanteras heltalsobjekt annorlunda "
"i heapen än strängar, tupler eller dictionaries eftersom heltal innebär "
"olika lagringskrav och avvägningar mellan hastighet och utrymme. Pythons "
"minneshanterare delegerar således en del av arbetet till de objektspecifika "
"allokeringarna, men ser till att de senare arbetar inom gränserna för den "
"privata heapen."

#: ../../c-api/memory.rst:36
msgid ""
"It is important to understand that the management of the Python heap is "
"performed by the interpreter itself and that the user has no control over "
"it, even if they regularly manipulate object pointers to memory blocks "
"inside that heap.  The allocation of heap space for Python objects and other"
" internal buffers is performed on demand by the Python memory manager "
"through the Python/C API functions listed in this document."
msgstr ""
"Det är viktigt att förstå att hanteringen av Pythons heap utförs av tolken "
"själv och att användaren inte har någon kontroll över den, även om de "
"regelbundet manipulerar objektpekare till minnesblock inuti heapen.  "
"Allokeringen av heaputrymme för Python-objekt och andra interna buffertar "
"utförs på begäran av Pythons minneshanterare genom de Python/C API-"
"funktioner som listas i detta dokument."

#: ../../c-api/memory.rst:49
msgid ""
"To avoid memory corruption, extension writers should never try to operate on"
" Python objects with the functions exported by the C library: "
":c:func:`malloc`, :c:func:`calloc`, :c:func:`realloc` and :c:func:`free`.  "
"This will result in  mixed calls between the C allocator and the Python "
"memory manager with fatal consequences, because they implement different "
"algorithms and operate on different heaps.  However, one may safely allocate"
" and release memory blocks with the C library allocator for individual "
"purposes, as shown in the following example::"
msgstr ""
"För att undvika minneskorruption bör författare av tillägg aldrig försöka "
"använda Python-objekt med de funktioner som exporteras av C-biblioteket: "
":c:func:`malloc`, :c:func:`calloc`, :c:func:`realloc` och :c:func:`free`.  "
"Detta kommer att resultera i blandade anrop mellan C-allokatorn och Pythons "
"minneshanterare med fatala konsekvenser, eftersom de implementerar olika "
"algoritmer och arbetar på olika heaps.  Man kan dock på ett säkert sätt "
"allokera och frigöra minnesblock med C-bibliotekets allokator för "
"individuella ändamål, som visas i följande exempel::"

#: ../../c-api/memory.rst:68
msgid ""
"In this example, the memory request for the I/O buffer is handled by the C "
"library allocator. The Python memory manager is involved only in the "
"allocation of the bytes object returned as a result."
msgstr ""
"I det här exemplet hanteras minnesbegäran för I/O-bufferten av "
"C-bibliotekets allokator. Pythons minneshanterare är endast involverad i "
"allokeringen av bytesobjektet som returneras som ett resultat."

#: ../../c-api/memory.rst:72
msgid ""
"In most situations, however, it is recommended to allocate memory from the "
"Python heap specifically because the latter is under control of the Python "
"memory manager. For example, this is required when the interpreter is "
"extended with new object types written in C. Another reason for using the "
"Python heap is the desire to *inform* the Python memory manager about the "
"memory needs of the extension module. Even when the requested memory is used"
" exclusively for internal, highly specific purposes, delegating all memory "
"requests to the Python memory manager causes the interpreter to have a more "
"accurate image of its memory footprint as a whole. Consequently, under "
"certain circumstances, the Python memory manager may or may not trigger "
"appropriate actions, like garbage collection, memory compaction or other "
"preventive procedures. Note that by using the C library allocator as shown "
"in the previous example, the allocated memory for the I/O buffer escapes "
"completely the Python memory manager."
msgstr ""
"I de flesta situationer är det dock rekommenderat att allokera minne från "
"Pythons heap, just för att den senare står under kontroll av Pythons "
"minneshanterare. Detta krävs till exempel när tolken utökas med nya "
"objekttyper skrivna i C. En annan anledning till att använda Python-heapen "
"är önskan att *informera* Pythons minneshanterare om minnesbehoven i "
"tilläggsmodulen. Även när det begärda minnet uteslutande används för "
"interna, mycket specifika ändamål, leder delegeringen av alla "
"minnesförfrågningar till Pythons minneshanterare till att tolken får en mer "
"exakt bild av sitt minnesavtryck som helhet. Följaktligen kan Pythons "
"minneshanterare under vissa omständigheter utlösa lämpliga åtgärder, t.ex. "
"sopsortering, minneskomprimering eller andra förebyggande åtgärder. "
"Observera att genom att använda C-bibliotekets allokator som visas i "
"föregående exempel, undgår det allokerade minnet för I/O-bufferten helt "
"Pythons minneshanterare."

#: ../../c-api/memory.rst:88
msgid ""
"The :envvar:`PYTHONMALLOC` environment variable can be used to configure the"
" memory allocators used by Python."
msgstr ""
"Miljövariabeln :envvar:`PYTHONMALLOC` kan användas för att konfigurera de "
"minnesallokatorer som används av Python."

#: ../../c-api/memory.rst:91
msgid ""
"The :envvar:`PYTHONMALLOCSTATS` environment variable can be used to print "
"statistics of the :ref:`pymalloc memory allocator <pymalloc>` every time a "
"new pymalloc object arena is created, and on shutdown."
msgstr ""
"Miljövariabeln :envvar:`PYTHONMALLOCSTATS` kan användas för att skriva ut "
"statistik för :ref:`pymalloc memory allocator <pymalloc>` varje gång en ny "
"pymalloc-objektarena skapas och vid avstängning."

#: ../../c-api/memory.rst:96
msgid "Allocator Domains"
msgstr "Domäner för allokering"

#: ../../c-api/memory.rst:100
msgid ""
"All allocating functions belong to one of three different \"domains\" (see "
"also :c:type:`PyMemAllocatorDomain`). These domains represent different "
"allocation strategies and are optimized for different purposes. The specific"
" details on how every domain allocates memory or what internal functions "
"each domain calls is considered an implementation detail, but for debugging "
"purposes a simplified table can be found at :ref:`here <default-memory-"
"allocators>`. There is no hard requirement to use the memory returned by the"
" allocation functions belonging to a given domain for only the purposes "
"hinted by that domain (although this is the recommended practice). For "
"example, one could use the memory returned by :c:func:`PyMem_RawMalloc` for "
"allocating Python objects or the memory returned by "
":c:func:`PyObject_Malloc` for allocating memory for buffers."
msgstr ""

#: ../../c-api/memory.rst:112
msgid "The three allocation domains are:"
msgstr "De tre tilldelningsdomänerna är:"

#: ../../c-api/memory.rst:114
msgid ""
"Raw domain: intended for allocating memory for general-purpose memory "
"buffers where the allocation *must* go to the system allocator or where the "
"allocator can operate without the :term:`GIL`. The memory is requested "
"directly to the system."
msgstr ""

#: ../../c-api/memory.rst:119
msgid ""
"\"Mem\" domain: intended for allocating memory for Python buffers and "
"general-purpose memory buffers where the allocation must be performed with "
"the :term:`GIL` held. The memory is taken from the Python private heap."
msgstr ""

#: ../../c-api/memory.rst:123
msgid ""
"Object domain: intended for allocating memory belonging to Python objects. "
"The memory is taken from the Python private heap."
msgstr ""

#: ../../c-api/memory.rst:126
msgid ""
"When freeing memory previously allocated by the allocating functions "
"belonging to a given domain,the matching specific deallocating functions "
"must be used. For example, :c:func:`PyMem_Free` must be used to free memory "
"allocated using :c:func:`PyMem_Malloc`."
msgstr ""

#: ../../c-api/memory.rst:131
msgid "Raw Memory Interface"
msgstr "Gränssnitt för råminne"

#: ../../c-api/memory.rst:133
msgid ""
"The following function sets are wrappers to the system allocator. These "
"functions are thread-safe, the :term:`GIL <global interpreter lock>` does "
"not need to be held."
msgstr ""

#: ../../c-api/memory.rst:137
msgid ""
"The :ref:`default raw memory allocator <default-memory-allocators>` uses the"
" following functions: :c:func:`malloc`, :c:func:`calloc`, :c:func:`realloc` "
"and :c:func:`!free`; call ``malloc(1)`` (or ``calloc(1, 1)``) when "
"requesting zero bytes."
msgstr ""
":ref:`standardminnesallokatorn <default-memory-allocators>` använder "
"följande funktioner: :c:func:`malloc`, :c:func:`calloc`, :c:func:`realloc` "
"och :c:func:`!free`; anropa ``malloc(1)`` (eller ``calloc(1, 1)``) när du "
"begär noll byte."

#: ../../c-api/memory.rst:146 ../../c-api/memory.rst:217
#: ../../c-api/memory.rst:325
msgid ""
"Allocates *n* bytes and returns a pointer of type :c:expr:`void*` to the "
"allocated memory, or ``NULL`` if the request fails."
msgstr ""
"Allokerar *n* byte och returnerar en pekare av typen :c:expr:`void*` till "
"det allokerade minnet, eller ``NULL`` om begäran misslyckas."

#: ../../c-api/memory.rst:149
msgid ""
"Requesting zero bytes returns a distinct non-``NULL`` pointer if possible, "
"as if ``PyMem_RawMalloc(1)`` had been called instead. The memory will not "
"have been initialized in any way."
msgstr ""
"En begäran om noll bytes returnerar en distinkt pekare som inte är ``NULL`` "
"om möjligt, som om ``PyMem_RawMalloc(1)`` hade anropats istället. Minnet "
"kommer inte att ha initialiserats på något sätt."

#: ../../c-api/memory.rst:156 ../../c-api/memory.rst:227
#: ../../c-api/memory.rst:335
msgid ""
"Allocates *nelem* elements each whose size in bytes is *elsize* and returns "
"a pointer of type :c:expr:`void*` to the allocated memory, or ``NULL`` if "
"the request fails. The memory is initialized to zeros."
msgstr ""
"Allokerar *nelem* element vars storlek i byte är *elsize* och returnerar en "
"pekare av typen :c:expr:`void*` till det allokerade minnet, eller ``NULL`` "
"om begäran misslyckas. Minnet initialiseras till nollor."

#: ../../c-api/memory.rst:160
msgid ""
"Requesting zero elements or elements of size zero bytes returns a distinct "
"non-``NULL`` pointer if possible, as if ``PyMem_RawCalloc(1, 1)`` had been "
"called instead."
msgstr ""
"Om man begär noll element eller element med storleken noll bytes returneras "
"en distinkt icke-``NULL`` pekare om möjligt, som om ``PyMem_RawCalloc(1, "
"1)`` hade anropats istället."

#: ../../c-api/memory.rst:169 ../../c-api/memory.rst:240
#: ../../c-api/memory.rst:348
msgid ""
"Resizes the memory block pointed to by *p* to *n* bytes. The contents will "
"be unchanged to the minimum of the old and the new sizes."
msgstr ""
"Ändrar storlek på minnesblocket som pekas ut av *p* till *n* byte. "
"Innehållet kommer att vara oförändrat till det minsta av den gamla och den "
"nya storleken."

#: ../../c-api/memory.rst:172
msgid ""
"If *p* is ``NULL``, the call is equivalent to ``PyMem_RawMalloc(n)``; else "
"if *n* is equal to zero, the memory block is resized but is not freed, and "
"the returned pointer is non-``NULL``."
msgstr ""
"Om *p* är ``NULL`` motsvarar anropet ``PyMem_RawMalloc(n)``; om *n* är lika "
"med noll ändras minnesblockets storlek men det frigörs inte och den "
"returnerade pekaren är inte ``NULL``."

#: ../../c-api/memory.rst:176
msgid ""
"Unless *p* is ``NULL``, it must have been returned by a previous call to "
":c:func:`PyMem_RawMalloc`, :c:func:`PyMem_RawRealloc` or "
":c:func:`PyMem_RawCalloc`."
msgstr ""
"Om inte *p* är ``NULL`` måste den ha returnerats av ett tidigare anrop till "
":c:func:`PyMem_RawMalloc`, :c:func:`PyMem_RawRealloc` eller "
":c:func:`PyMem_RawCalloc`."

#: ../../c-api/memory.rst:180
msgid ""
"If the request fails, :c:func:`PyMem_RawRealloc` returns ``NULL`` and *p* "
"remains a valid pointer to the previous memory area."
msgstr ""
"Om begäran misslyckas returnerar :c:func:`PyMem_RawRealloc` ``NULL`` och *p*"
" förblir en giltig pekare till det föregående minnesområdet."

#: ../../c-api/memory.rst:186
msgid ""
"Frees the memory block pointed to by *p*, which must have been returned by a"
" previous call to :c:func:`PyMem_RawMalloc`, :c:func:`PyMem_RawRealloc` or "
":c:func:`PyMem_RawCalloc`.  Otherwise, or if ``PyMem_RawFree(p)`` has been "
"called before, undefined behavior occurs."
msgstr ""
"Frigör minnesblocket som pekas ut av *p*, vilket måste ha returnerats av ett"
" tidigare anrop till :c:func:`PyMem_RawMalloc`, :c:func:`PyMem_RawRealloc` "
"eller :c:func:`PyMem_RawCalloc`.  Annars, eller om ``PyMem_RawFree(p)`` har "
"anropats tidigare, uppstår ett odefinierat beteende."

#: ../../c-api/memory.rst:191 ../../c-api/memory.rst:261
#: ../../c-api/memory.rst:369
msgid "If *p* is ``NULL``, no operation is performed."
msgstr "Om *p* är ``NULL`` utförs ingen åtgärd."

#: ../../c-api/memory.rst:197
msgid "Memory Interface"
msgstr "Minnesgränssnitt"

#: ../../c-api/memory.rst:199 ../../c-api/memory.rst:305
msgid ""
"The following function sets, modeled after the ANSI C standard, but "
"specifying behavior when requesting zero bytes, are available for allocating"
" and releasing memory from the Python heap."
msgstr ""
"Följande funktionsuppsättningar, som är modellerade efter ANSI C-standarden,"
" men som specificerar beteendet när noll byte begärs, är tillgängliga för "
"att allokera och frigöra minne från Pythons heap."

#: ../../c-api/memory.rst:203
msgid ""
"The :ref:`default memory allocator <default-memory-allocators>` uses the "
":ref:`pymalloc memory allocator <pymalloc>`."
msgstr ""
"I :ref:`default memory allocator <default-memory-allocators>` används "
":ref:`pymalloc memory allocator <pymalloc>`."

#: ../../c-api/memory.rst:208 ../../c-api/memory.rst:320
msgid ""
"The :term:`GIL <global interpreter lock>` must be held when using these "
"functions."
msgstr ""

#: ../../c-api/memory.rst:213
msgid ""
"The default allocator is now pymalloc instead of system :c:func:`malloc`."
msgstr ""
"Standardallokeraren är nu pymalloc istället för system :c:func:`malloc`."

#: ../../c-api/memory.rst:220
msgid ""
"Requesting zero bytes returns a distinct non-``NULL`` pointer if possible, "
"as if ``PyMem_Malloc(1)`` had been called instead. The memory will not have "
"been initialized in any way."
msgstr ""
"En begäran om noll bytes returnerar en distinkt pekare som inte är ``NULL`` "
"om möjligt, som om ``PyMem_Malloc(1)`` hade anropats istället. Minnet kommer"
" inte att ha initialiserats på något sätt."

#: ../../c-api/memory.rst:231
msgid ""
"Requesting zero elements or elements of size zero bytes returns a distinct "
"non-``NULL`` pointer if possible, as if ``PyMem_Calloc(1, 1)`` had been "
"called instead."
msgstr ""
"Om man begär noll element eller element med storleken noll bytes returneras "
"en distinkt icke-``NULL`` pekare om möjligt, som om ``PyMem_Calloc(1, 1)`` "
"hade anropats istället."

#: ../../c-api/memory.rst:243
msgid ""
"If *p* is ``NULL``, the call is equivalent to ``PyMem_Malloc(n)``; else if "
"*n* is equal to zero, the memory block is resized but is not freed, and the "
"returned pointer is non-``NULL``."
msgstr ""
"Om *p* är ``NULL`` motsvarar anropet ``PyMem_Malloc(n)``; om *n* är lika med"
" noll ändras minnesblockets storlek men det frigörs inte och den returnerade"
" pekaren är inte ``NULL``."

#: ../../c-api/memory.rst:247
msgid ""
"Unless *p* is ``NULL``, it must have been returned by a previous call to "
":c:func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` or :c:func:`PyMem_Calloc`."
msgstr ""
"Om inte *p* är ``NULL`` måste den ha returnerats av ett tidigare anrop till "
":c:func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` eller "
":c:func:`PyMem_Calloc`."

#: ../../c-api/memory.rst:250
msgid ""
"If the request fails, :c:func:`PyMem_Realloc` returns ``NULL`` and *p* "
"remains a valid pointer to the previous memory area."
msgstr ""
"Om begäran misslyckas returnerar :c:func:`PyMem_Realloc` ``NULL`` och *p* "
"förblir en giltig pekare till det föregående minnesområdet."

#: ../../c-api/memory.rst:256
msgid ""
"Frees the memory block pointed to by *p*, which must have been returned by a"
" previous call to :c:func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` or "
":c:func:`PyMem_Calloc`.  Otherwise, or if ``PyMem_Free(p)`` has been called "
"before, undefined behavior occurs."
msgstr ""
"Frigör minnesblocket som pekas ut av *p*, vilket måste ha returnerats av ett"
" tidigare anrop till :c:func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` eller "
":c:func:`PyMem_Calloc`.  Annars, eller om ``PyMem_Free(p)`` har anropats "
"tidigare, uppstår ett odefinierat beteende."

#: ../../c-api/memory.rst:263
msgid ""
"The following type-oriented macros are provided for convenience.  Note  that"
" *TYPE* refers to any C type."
msgstr ""
"Följande typorienterade makron tillhandahålls för enkelhetens skull.  "
"Observera att *TYPE* hänvisar till vilken C-typ som helst."

#: ../../c-api/memory.rst:269
msgid ""
"Same as :c:func:`PyMem_Malloc`, but allocates ``(n * sizeof(TYPE))`` bytes "
"of memory.  Returns a pointer cast to ``TYPE*``.  The memory will not have "
"been initialized in any way."
msgstr ""
"Samma som :c:func:`PyMem_Malloc`, men allokerar ``(n * sizeof(TYPE))`` bytes"
" minne.  Returnerar en pekare som kastas till ``TYPE*``.  Minnet kommer inte"
" att ha initialiserats på något sätt."

#: ../../c-api/memory.rst:276
msgid ""
"Same as :c:func:`PyMem_Realloc`, but the memory block is resized to ``(n * "
"sizeof(TYPE))`` bytes.  Returns a pointer cast to ``TYPE*``. On return, *p* "
"will be a pointer to the new memory area, or ``NULL`` in the event of "
"failure."
msgstr ""
"Samma som :c:func:`PyMem_Realloc`, men minnesblocket ändras till ``(n * "
"sizeof(TYPE))`` bytes.  Returnerar en pekare som kastats till ``TYPE*``. Vid"
" retur kommer *p* att vara en pekare till det nya minnesområdet, eller "
"``NULL`` i händelse av fel."

#: ../../c-api/memory.rst:281
msgid ""
"This is a C preprocessor macro; *p* is always reassigned.  Save the original"
" value of *p* to avoid losing memory when handling errors."
msgstr ""
"Detta är ett C preprocessormakro; *p* är alltid återtilldelad.  Spara "
"originalvärdet för *p* för att undvika minnesförlust vid felhantering."

#: ../../c-api/memory.rst:287
msgid "Same as :c:func:`PyMem_Free`."
msgstr "Samma som :c:func:`PyMem_Free`."

#: ../../c-api/memory.rst:289
msgid ""
"In addition, the following macro sets are provided for calling the Python "
"memory allocator directly, without involving the C API functions listed "
"above. However, note that their use does not preserve binary compatibility "
"across Python versions and is therefore deprecated in extension modules."
msgstr ""
"Dessutom finns följande makrouppsättningar för att anropa Pythons "
"minnesallokator direkt, utan att involvera C API-funktionerna som listas "
"ovan. Observera dock att användningen av dessa inte bevarar binär "
"kompatibilitet mellan olika Python-versioner och därför inte rekommenderas i"
" tilläggsmoduler."

#: ../../c-api/memory.rst:294
msgid "``PyMem_MALLOC(size)``"
msgstr "``PyMem_MALLOC(size)``"

#: ../../c-api/memory.rst:295
msgid "``PyMem_NEW(type, size)``"
msgstr "``PyMem_NEW(type, size)``"

#: ../../c-api/memory.rst:296
msgid "``PyMem_REALLOC(ptr, size)``"
msgstr "``PyMem_REALLOC(ptr, size)``"

#: ../../c-api/memory.rst:297
msgid "``PyMem_RESIZE(ptr, type, size)``"
msgstr "``PyMem_RESIZE(ptr, type, size)``"

#: ../../c-api/memory.rst:298
msgid "``PyMem_FREE(ptr)``"
msgstr "``PyMem_FREE(ptr)``"

#: ../../c-api/memory.rst:299
msgid "``PyMem_DEL(ptr)``"
msgstr "``PyMem_DEL(ptr)``"

#: ../../c-api/memory.rst:303
msgid "Object allocators"
msgstr "Objektallokatorer"

#: ../../c-api/memory.rst:310
msgid ""
"There is no guarantee that the memory returned by these allocators can be "
"successfully cast to a Python object when intercepting the allocating "
"functions in this domain by the methods described in the :ref:`Customize "
"Memory Allocators <customize-memory-allocators>` section."
msgstr ""
"Det finns ingen garanti för att det minne som returneras av dessa "
"allokeringsfunktioner framgångsrikt kan kastas till ett Python-objekt när "
"man avlyssnar allokeringsfunktionerna i den här domänen med de metoder som "
"beskrivs i avsnittet :ref:`Customize Memory Allocators <customize-memory-"
"allocators>`."

#: ../../c-api/memory.rst:315
msgid ""
"The :ref:`default object allocator <default-memory-allocators>` uses the "
":ref:`pymalloc memory allocator <pymalloc>`."
msgstr ""
"I :ref:`default object allocator <default-memory-allocators>` används "
":ref:`pymalloc memory allocator <pymalloc>`."

#: ../../c-api/memory.rst:328
msgid ""
"Requesting zero bytes returns a distinct non-``NULL`` pointer if possible, "
"as if ``PyObject_Malloc(1)`` had been called instead. The memory will not "
"have been initialized in any way."
msgstr ""
"Om noll bytes begärs returneras en distinkt icke-``NULL`` pekare om möjligt,"
" som om ``PyObject_Malloc(1)`` hade anropats istället. Minnet kommer inte "
"att ha initialiserats på något sätt."

#: ../../c-api/memory.rst:339
msgid ""
"Requesting zero elements or elements of size zero bytes returns a distinct "
"non-``NULL`` pointer if possible, as if ``PyObject_Calloc(1, 1)`` had been "
"called instead."
msgstr ""
"Om man begär noll element eller element med storleken noll bytes returneras "
"en distinkt icke-``NULL`` pekare om möjligt, som om ``PyObject_Calloc(1, "
"1)`` hade anropats istället."

#: ../../c-api/memory.rst:351
msgid ""
"If *p* is ``NULL``, the call is equivalent to ``PyObject_Malloc(n)``; else "
"if *n* is equal to zero, the memory block is resized but is not freed, and "
"the returned pointer is non-``NULL``."
msgstr ""
"Om *p* är ``NULL`` motsvarar anropet ``PyObject_Malloc(n)``; om *n* är lika "
"med noll ändras minnesblockets storlek men det frigörs inte och den "
"returnerade pekaren är inte ``NULL``."

#: ../../c-api/memory.rst:355
msgid ""
"Unless *p* is ``NULL``, it must have been returned by a previous call to "
":c:func:`PyObject_Malloc`, :c:func:`PyObject_Realloc` or "
":c:func:`PyObject_Calloc`."
msgstr ""
"Om inte *p* är ``NULL`` måste den ha returnerats av ett tidigare anrop till "
":c:func:`PyObject_Malloc`, :c:func:`PyObject_Realloc` eller "
":c:func:`PyObject_Calloc`."

#: ../../c-api/memory.rst:358
msgid ""
"If the request fails, :c:func:`PyObject_Realloc` returns ``NULL`` and *p* "
"remains a valid pointer to the previous memory area."
msgstr ""
"Om begäran misslyckas returnerar :c:func:`PyObject_Realloc` ``NULL`` och *p*"
" förblir en giltig pekare till det tidigare minnesområdet."

#: ../../c-api/memory.rst:364
msgid ""
"Frees the memory block pointed to by *p*, which must have been returned by a"
" previous call to :c:func:`PyObject_Malloc`, :c:func:`PyObject_Realloc` or "
":c:func:`PyObject_Calloc`.  Otherwise, or if ``PyObject_Free(p)`` has been "
"called before, undefined behavior occurs."
msgstr ""
"Frigör minnesblocket som pekas ut av *p*, vilket måste ha returnerats av ett"
" tidigare anrop till :c:func:`PyObject_Malloc`, :c:func:`PyObject_Realloc` "
"eller :c:func:`PyObject_Calloc`.  Annars, eller om ``PyObject_Free(p)`` har "
"anropats tidigare, uppstår ett odefinierat beteende."

#: ../../c-api/memory.rst:375
msgid "Default Memory Allocators"
msgstr "Standard minnesallokatorer"

#: ../../c-api/memory.rst:377
msgid "Default memory allocators:"
msgstr "Standardminnesallokatorer:"

#: ../../c-api/memory.rst:380
msgid "Configuration"
msgstr "Konfiguration"

#: ../../c-api/memory.rst:380
msgid "Name"
msgstr "Namn"

#: ../../c-api/memory.rst:380
msgid "PyMem_RawMalloc"
msgstr "PyMem_RawMalloc"

#: ../../c-api/memory.rst:380
msgid "PyMem_Malloc"
msgstr "PyMem_Malloc"

#: ../../c-api/memory.rst:380
msgid "PyObject_Malloc"
msgstr "PyObject_Malloc"

#: ../../c-api/memory.rst:382
msgid "Release build"
msgstr "Release-version"

#: ../../c-api/memory.rst:382
msgid "``\"pymalloc\"``"
msgstr "``\"pymalloc\"``"

#: ../../c-api/memory.rst:382 ../../c-api/memory.rst:384
msgid "``malloc``"
msgstr "``malloc``"

#: ../../c-api/memory.rst:382
msgid "``pymalloc``"
msgstr "``pymalloc``"

#: ../../c-api/memory.rst:383
msgid "Debug build"
msgstr "Felsök byggnaden"

#: ../../c-api/memory.rst:383
msgid "``\"pymalloc_debug\"``"
msgstr "``\"pymalloc_debug\"``"

#: ../../c-api/memory.rst:383 ../../c-api/memory.rst:385
msgid "``malloc`` + debug"
msgstr "``malloc`` + felsökning"

#: ../../c-api/memory.rst:383
msgid "``pymalloc`` + debug"
msgstr "``pymalloc`` + felsökning"

#: ../../c-api/memory.rst:384
msgid "Release build, without pymalloc"
msgstr "Release-version, utan pymalloc"

#: ../../c-api/memory.rst:384
msgid "``\"malloc\"``"
msgstr "``\"malloc\"``"

#: ../../c-api/memory.rst:385
msgid "Debug build, without pymalloc"
msgstr "Felsökning, utan pymalloc"

#: ../../c-api/memory.rst:385
msgid "``\"malloc_debug\"``"
msgstr "``\"malloc_debug\"``"

#: ../../c-api/memory.rst:388
msgid "Legend:"
msgstr "Legend:"

#: ../../c-api/memory.rst:390
msgid "Name: value for :envvar:`PYTHONMALLOC` environment variable."
msgstr "Namn: värde för miljövariabeln :envvar:`PYTHONMALLOC`."

#: ../../c-api/memory.rst:391
msgid ""
"``malloc``: system allocators from the standard C library, C functions: "
":c:func:`malloc`, :c:func:`calloc`, :c:func:`realloc` and :c:func:`free`."
msgstr ""
"``malloc``: systemallokatorer från standard C-biblioteket, C-funktioner: "
":c:func:`malloc`, :c:func:`calloc`, :c:func:`realloc` och :c:func:`free`."

#: ../../c-api/memory.rst:393
msgid "``pymalloc``: :ref:`pymalloc memory allocator <pymalloc>`."
msgstr "``pymalloc``: :ref:`pymalloc minnesallokering <pymalloc>`."

#: ../../c-api/memory.rst:394
msgid ""
"\"+ debug\": with :ref:`debug hooks on the Python memory allocators <pymem-"
"debug-hooks>`."
msgstr ""
"\"+ debug\": med :ref:`felsöknings-hooks på Pythons minnesallokatorer "
"<pymem-debug-hooks>`."

#: ../../c-api/memory.rst:396
msgid "\"Debug build\": :ref:`Python build in debug mode <debug-build>`."
msgstr "\"Debug build\": :ref:`Python byggs i felsökningsläge <debug-build>`."

#: ../../c-api/memory.rst:401
msgid "Customize Memory Allocators"
msgstr "Anpassa minnesfördelare"

#: ../../c-api/memory.rst:407
msgid ""
"Structure used to describe a memory block allocator. The structure has the "
"following fields:"
msgstr ""
"Struktur som används för att beskriva en minnesblocksallokering. Strukturen "
"har följande fält:"

#: ../../c-api/memory.rst:411 ../../c-api/memory.rst:652
msgid "Field"
msgstr "Fält"

#: ../../c-api/memory.rst:411 ../../c-api/memory.rst:652
msgid "Meaning"
msgstr "Betydelse"

#: ../../c-api/memory.rst:413 ../../c-api/memory.rst:654
msgid "``void *ctx``"
msgstr "``void *ctx``"

#: ../../c-api/memory.rst:413 ../../c-api/memory.rst:654
msgid "user context passed as first argument"
msgstr "användarkontext som skickas som första argument"

#: ../../c-api/memory.rst:415
msgid "``void* malloc(void *ctx, size_t size)``"
msgstr "``void* malloc(void *ctx, size_t size)``"

#: ../../c-api/memory.rst:415
msgid "allocate a memory block"
msgstr "allokera ett minnesblock"

#: ../../c-api/memory.rst:417
msgid "``void* calloc(void *ctx, size_t nelem, size_t elsize)``"
msgstr "``void* calloc(void *ctx, size_t nelem, size_t elsize)``"

#: ../../c-api/memory.rst:417
msgid "allocate a memory block initialized with zeros"
msgstr "allokera ett minnesblock som initieras med nollor"

#: ../../c-api/memory.rst:420
msgid "``void* realloc(void *ctx, void *ptr, size_t new_size)``"
msgstr "``void* realloc(void *ctx, void *ptr, size_t new_size)``"

#: ../../c-api/memory.rst:420
msgid "allocate or resize a memory block"
msgstr "allokera eller ändra storlek på ett minnesblock"

#: ../../c-api/memory.rst:422
msgid "``void free(void *ctx, void *ptr)``"
msgstr "``void free(void *ctx, void *ptr)``"

#: ../../c-api/memory.rst:422
msgid "free a memory block"
msgstr "frigöra ett minnesblock"

#: ../../c-api/memory.rst:425
msgid ""
"The :c:type:`!PyMemAllocator` structure was renamed to "
":c:type:`PyMemAllocatorEx` and a new ``calloc`` field was added."
msgstr ""
"Strukturen :c:type:`!PyMemAllocator` döptes om till "
":c:type:`PyMemAllocatorEx` och ett nytt fält ``calloc`` lades till."

#: ../../c-api/memory.rst:432
msgid "Enum used to identify an allocator domain. Domains:"
msgstr "Enum som används för att identifiera en allokeringsdomän. Domäner:"

#: ../../c-api/memory.rst:438 ../../c-api/memory.rst:447
#: ../../c-api/memory.rst:456
msgid "Functions:"
msgstr "Funktioner:"

#: ../../c-api/memory.rst:440
msgid ":c:func:`PyMem_RawMalloc`"
msgstr ":c:func:`PyMem_RawMalloc`"

#: ../../c-api/memory.rst:441
msgid ":c:func:`PyMem_RawRealloc`"
msgstr ":c:func:`PyMem_RawRealloc`"

#: ../../c-api/memory.rst:442
msgid ":c:func:`PyMem_RawCalloc`"
msgstr ":c:func:`PyMem_RawCalloc`"

#: ../../c-api/memory.rst:443
msgid ":c:func:`PyMem_RawFree`"
msgstr ":c:func:`PyMem_RawFree`"

#: ../../c-api/memory.rst:449
msgid ":c:func:`PyMem_Malloc`,"
msgstr ":c:func:`PyMem_Malloc`,"

#: ../../c-api/memory.rst:450
msgid ":c:func:`PyMem_Realloc`"
msgstr ":c:func:`PyMem_Realloc`"

#: ../../c-api/memory.rst:451
msgid ":c:func:`PyMem_Calloc`"
msgstr ":c:func:`PyMem_Calloc`"

#: ../../c-api/memory.rst:452
msgid ":c:func:`PyMem_Free`"
msgstr ":c:func:`PyMem_Free`"

#: ../../c-api/memory.rst:458
msgid ":c:func:`PyObject_Malloc`"
msgstr ":c:func:`PyObject_Malloc`"

#: ../../c-api/memory.rst:459
msgid ":c:func:`PyObject_Realloc`"
msgstr ":c:func:`PyObject_Realloc`"

#: ../../c-api/memory.rst:460
msgid ":c:func:`PyObject_Calloc`"
msgstr ":c:func:`PyObject_Calloc`"

#: ../../c-api/memory.rst:461
msgid ":c:func:`PyObject_Free`"
msgstr ":c:func:`PyObject_Free`"

#: ../../c-api/memory.rst:465
msgid "Get the memory block allocator of the specified domain."
msgstr "Hämta minnesblockstilldelaren för den angivna domänen."

#: ../../c-api/memory.rst:470
msgid "Set the memory block allocator of the specified domain."
msgstr "Ställ in minnesblocksallokeringen för den angivna domänen."

#: ../../c-api/memory.rst:472
msgid ""
"The new allocator must return a distinct non-``NULL`` pointer when "
"requesting zero bytes."
msgstr ""
"Den nya allokeraren måste returnera en distinkt pekare som inte är ``NULL`` "
"när den begär noll bytes."

#: ../../c-api/memory.rst:475
msgid ""
"For the :c:macro:`PYMEM_DOMAIN_RAW` domain, the allocator must be thread-"
"safe: the :term:`GIL <global interpreter lock>` is not held when the "
"allocator is called."
msgstr ""

#: ../../c-api/memory.rst:479
msgid ""
"If the new allocator is not a hook (does not call the previous allocator), "
"the :c:func:`PyMem_SetupDebugHooks` function must be called to reinstall the"
" debug hooks on top on the new allocator."
msgstr ""
"Om den nya allokeringsenheten inte är en hook (anropar inte den föregående "
"allokeringsenheten) måste funktionen :c:func:`PyMem_SetupDebugHooks` anropas"
" för att installera om debughooks ovanpå den nya allokeringsenheten."

#: ../../c-api/memory.rst:483
msgid ""
"See also :c:member:`PyPreConfig.allocator` and :ref:`Preinitialize Python "
"with PyPreConfig <c-preinit>`."
msgstr ""
"Se även :c:member:`PyPreConfig.allocator` och :ref:`Preinitialisera Python "
"med PyPreConfig <c-preinit>`."

#: ../../c-api/memory.rst:488
msgid ":c:func:`PyMem_SetAllocator` does have the following contract:"
msgstr ":c:func:`PyMem_SetAllocator` har följande kontrakt:"

#: ../../c-api/memory.rst:490
msgid ""
"It can be called after :c:func:`Py_PreInitialize` and before "
":c:func:`Py_InitializeFromConfig` to install a custom memory allocator. "
"There are no restrictions over the installed allocator other than the ones "
"imposed by the domain (for instance, the Raw Domain allows the allocator to "
"be called without the GIL held). See :ref:`the section on allocator domains "
"<allocator-domains>` for more information."
msgstr ""

#: ../../c-api/memory.rst:498
msgid ""
"If called after Python has finish initializing (after "
":c:func:`Py_InitializeFromConfig` has been called) the allocator **must** "
"wrap the existing allocator. Substituting the current allocator for some "
"other arbitrary one is **not supported**."
msgstr ""
"Om den anropas efter att Python har slutfört initialiseringen (efter att "
":c:func:`Py_InitializeFromConfig` har anropats) måste allokatorn **omhölja**"
" den befintliga allokatorn. Att ersätta den aktuella allokatorn med någon "
"annan godtycklig allokator stöds **inte**."

#: ../../c-api/memory.rst:507
msgid ""
"Setup :ref:`debug hooks in the Python memory allocators <pymem-debug-hooks>`"
" to detect memory errors."
msgstr ""
"Installera :ref:`debug-hooks i Pythons minnesallokatorer <pymem-debug-"
"hooks>` för att upptäcka minnesfel."

#: ../../c-api/memory.rst:514
msgid "Debug hooks on the Python memory allocators"
msgstr "Felsöknings-hooks på Pythons minnesallokatorer"

#: ../../c-api/memory.rst:516
msgid ""
"When :ref:`Python is built in debug mode <debug-build>`, the "
":c:func:`PyMem_SetupDebugHooks` function is called at the :ref:`Python "
"preinitialization <c-preinit>` to setup debug hooks on Python memory "
"allocators to detect memory errors."
msgstr ""
"När :ref:`Python byggs i felsökningsläge <debug-build>`, anropas funktionen "
":c:func:`PyMem_SetupDebugHooks` vid :ref:`Pythons förinitialisering "
"<c-preinit>` för att ställa in felsöknings-hooks på Pythons "
"minnesallokatorer för att upptäcka minnesfel."

#: ../../c-api/memory.rst:521
msgid ""
"The :envvar:`PYTHONMALLOC` environment variable can be used to install debug"
" hooks on a Python compiled in release mode (ex: ``PYTHONMALLOC=debug``)."
msgstr ""
"Miljövariabeln :envvar:`PYTHONMALLOC` kan användas för att installera debug-"
"hooks på ett Python som kompilerats i release-läge (ex: "
"``PYTHONMALLOC=debug``)."

#: ../../c-api/memory.rst:524
msgid ""
"The :c:func:`PyMem_SetupDebugHooks` function can be used to set debug hooks "
"after calling :c:func:`PyMem_SetAllocator`."
msgstr ""
"Funktionen :c:func:`PyMem_SetupDebugHooks` kan användas för att ställa in "
"debug-hooks efter anrop av :c:func:`PyMem_SetAllocator`."

#: ../../c-api/memory.rst:527
msgid ""
"These debug hooks fill dynamically allocated memory blocks with special, "
"recognizable bit patterns. Newly allocated memory is filled with the byte "
"``0xCD`` (``PYMEM_CLEANBYTE``), freed memory is filled with the byte "
"``0xDD`` (``PYMEM_DEADBYTE``). Memory blocks are surrounded by \"forbidden "
"bytes\" filled with the byte ``0xFD`` (``PYMEM_FORBIDDENBYTE``). Strings of "
"these bytes are unlikely to be valid addresses, floats, or ASCII strings."
msgstr ""
"Dessa debughooks fyller dynamiskt allokerade minnesblock med speciella, "
"igenkännbara bitmönster. Nytilldelat minne fylls med bytena ``0xCD`` "
"(``PYMEM_CLEANBYTE``), frigjort minne fylls med bytena ``0xDD`` "
"(``PYMEM_DEADBYTE``). Minnesblock omges av \"förbjudna byte\" som fylls med "
"byte ``0xFD`` (``PYMEM_FORBIDDENBYTE``). Strängar av dessa byte är sannolikt"
" inte giltiga adresser, flyttal eller ASCII-strängar."

#: ../../c-api/memory.rst:534
msgid "Runtime checks:"
msgstr "Kontroll av körtid:"

#: ../../c-api/memory.rst:536
msgid ""
"Detect API violations. For example, detect if :c:func:`PyObject_Free` is "
"called on a memory block allocated by :c:func:`PyMem_Malloc`."
msgstr ""
"Upptäck API-överträdelser. Detektera till exempel om :c:func:`PyObject_Free`"
" anropas på ett minnesblock som allokerats av :c:func:`PyMem_Malloc`."

#: ../../c-api/memory.rst:538
msgid "Detect write before the start of the buffer (buffer underflow)."
msgstr "Detekterar skrivning före buffertens början (bufferten underflödar)."

#: ../../c-api/memory.rst:539
msgid "Detect write after the end of the buffer (buffer overflow)."
msgstr "Detektera skrivning efter slutet av bufferten (buffer overflow)."

#: ../../c-api/memory.rst:540
msgid ""
"Check that the :term:`GIL <global interpreter lock>` is held when allocator "
"functions of :c:macro:`PYMEM_DOMAIN_OBJ` (ex: :c:func:`PyObject_Malloc`) and"
" :c:macro:`PYMEM_DOMAIN_MEM` (ex: :c:func:`PyMem_Malloc`) domains are "
"called."
msgstr ""
"Kontrollera att :term:`GIL <global interpreter lock>` hålls när "
"allokeringsfunktioner i domänerna :c:macro:`PYMEM_DOMAIN_OBJ` (ex: "
":c:func:`PyObject_Malloc`) och :c:macro:`PYMEM_DOMAIN_MEM` (ex: "
":c:func:`PyMem_Malloc`) anropas."

#: ../../c-api/memory.rst:545
msgid ""
"On error, the debug hooks use the :mod:`tracemalloc` module to get the "
"traceback where a memory block was allocated. The traceback is only "
"displayed if :mod:`tracemalloc` is tracing Python memory allocations and the"
" memory block was traced."
msgstr ""
"Vid fel använder debug-hooks modulen :mod:`tracemalloc` för att få en "
"spårning av var ett minnesblock allokerades. Spårningen visas bara om "
":mod:`tracemalloc` spårar Python-minnesallokeringar och minnesblocket "
"spårades."

#: ../../c-api/memory.rst:550
msgid ""
"Let *S* = ``sizeof(size_t)``. ``2*S`` bytes are added at each end of each "
"block of *N* bytes requested.  The memory layout is like so, where p "
"represents the address returned by a malloc-like or realloc-like function "
"(``p[i:j]`` means the slice of bytes from ``*(p+i)`` inclusive up to "
"``*(p+j)`` exclusive; note that the treatment of negative indices differs "
"from a Python slice):"
msgstr ""
"Låt *S* = ``sizeof(size_t)``. ``2*S`` bytes läggs till i vardera änden av "
"varje block om *N* bytes som begärs.  Minneslayouten ser ut så här, där p "
"representerar adressen som returneras av en malloc-liknande eller realloc-"
"liknande funktion (``p[i:j]`` betyder byteskivan från ``*(p+i)`` inklusive "
"upp till ``*(p+j)`` exklusive; observera att behandlingen av negativa index "
"skiljer sig från en Python-skiva):"

#: ../../c-api/memory.rst:557
msgid "``p[-2*S:-S]``"
msgstr "``p[-2*S:-S]``"

#: ../../c-api/memory.rst:557
msgid ""
"Number of bytes originally asked for.  This is a size_t, big-endian (easier "
"to read in a memory dump)."
msgstr ""
"Antal bytes som ursprungligen begärdes.  Detta är en size_t, big-endian "
"(lättare att läsa i en minnesdump)."

#: ../../c-api/memory.rst:564
msgid "``p[-S]``"
msgstr "``p[-S]``"

#: ../../c-api/memory.rst:560
msgid "API identifier (ASCII character):"
msgstr "API-identifierare (ASCII-tecken):"

#: ../../c-api/memory.rst:562
msgid "``'r'`` for :c:macro:`PYMEM_DOMAIN_RAW`."
msgstr "``'r'`` för :c:macro:`PYMEM_DOMAIN_RAW`."

#: ../../c-api/memory.rst:563
msgid "``'m'`` for :c:macro:`PYMEM_DOMAIN_MEM`."
msgstr "``'m'`` för :c:macro:`PYMEM_DOMAIN_MEM`."

#: ../../c-api/memory.rst:564
msgid "``'o'`` for :c:macro:`PYMEM_DOMAIN_OBJ`."
msgstr "``'o'`` för :c:macro:`PYMEM_DOMAIN_OBJ`."

#: ../../c-api/memory.rst:567
msgid "``p[-S+1:0]``"
msgstr "``p[-S+1:0]``"

#: ../../c-api/memory.rst:567
msgid "Copies of PYMEM_FORBIDDENBYTE.  Used to catch under- writes and reads."
msgstr ""
"Kopior av PYMEM_FORBIDDENBYTE.  Används för att fånga upp underskrivna och "
"underlästa filer."

#: ../../c-api/memory.rst:576
msgid "``p[0:N]``"
msgstr "``p[0:N]``"

#: ../../c-api/memory.rst:570
msgid ""
"The requested memory, filled with copies of PYMEM_CLEANBYTE, used to catch "
"reference to uninitialized memory.  When a realloc-like function is called "
"requesting a larger memory block, the new excess bytes are also filled with "
"PYMEM_CLEANBYTE.  When a free-like function is called, these are overwritten"
" with PYMEM_DEADBYTE, to catch reference to freed memory.  When a realloc- "
"like function is called requesting a smaller memory block, the excess old "
"bytes are also filled with PYMEM_DEADBYTE."
msgstr ""
"Det begärda minnet fylls med kopior av PYMEM_CLEANBYTE, som används för att "
"fånga upp referenser till oinitialiserat minne.  När en realloc-liknande "
"funktion anropas och begär ett större minnesblock fylls även de nya "
"överflödiga byte med PYMEM_CLEANBYTE.  När en free-liknande funktion anropas"
" skrivs dessa över med PYMEM_DEADBYTE, för att fånga referenser till "
"frigjort minne.  När en realloc-liknande funktion anropas och begär ett "
"mindre minnesblock, fylls även de överflödiga gamla bytena med "
"PYMEM_DEADBYTE."

#: ../../c-api/memory.rst:579
msgid "``p[N:N+S]``"
msgstr "``p[N:N+S]``"

#: ../../c-api/memory.rst:579
msgid "Copies of PYMEM_FORBIDDENBYTE.  Used to catch over- writes and reads."
msgstr ""
"Kopior av PYMEM_FORBIDDENBYTE.  Används för att fånga upp överskrivningar "
"och läsningar."

#: ../../c-api/memory.rst:590
msgid "``p[N+S:N+2*S]``"
msgstr "``p[N+S:N+2*S]``"

#: ../../c-api/memory.rst:582
msgid ""
"Only used if the ``PYMEM_DEBUG_SERIALNO`` macro is defined (not defined by "
"default)."
msgstr ""
"Används endast om makrot ``PYMEM_DEBUG_SERIALNO`` är definierat (inte "
"definierat som standard)."

#: ../../c-api/memory.rst:585
msgid ""
"A serial number, incremented by 1 on each call to a malloc-like or realloc-"
"like function.  Big-endian :c:type:`size_t`.  If \"bad memory\" is detected "
"later, the serial number gives an excellent way to set a breakpoint on the "
"next run, to capture the instant at which this block was passed out.  The "
"static function bumpserialno() in obmalloc.c is the only place the serial "
"number is incremented, and exists so you can set such a breakpoint easily."
msgstr ""
"Ett serienummer som ökas med 1 vid varje anrop till en malloc-liknande eller"
" realloc-liknande funktion.  Big-endian :c:type:`size_t`.  Om \"dåligt "
"minne\" upptäcks senare är serienumret ett utmärkt sätt att sätta en "
"brytpunkt vid nästa körning, för att fånga ögonblicket då detta block "
"skickades ut.  Den statiska funktionen bumpserialno() i obmalloc.c är det "
"enda stället där serienumret ökas, och den finns för att du enkelt ska kunna"
" sätta en sådan brytpunkt."

#: ../../c-api/memory.rst:592
msgid ""
"A realloc-like or free-like function first checks that the "
"PYMEM_FORBIDDENBYTE bytes at each end are intact.  If they've been altered, "
"diagnostic output is written to stderr, and the program is aborted via "
"Py_FatalError().  The other main failure mode is provoking a memory error "
"when a program reads up one of the special bit patterns and tries to use it "
"as an address.  If you get in a debugger then and look at the object, you're"
" likely to see that it's entirely filled with PYMEM_DEADBYTE (meaning freed "
"memory is getting used) or PYMEM_CLEANBYTE (meaning uninitialized memory is "
"getting used)."
msgstr ""
"En realloc-liknande eller free-liknande funktion kontrollerar först att "
"PYMEM_FORBIDDENBYTE-bytena i varje ände är intakta.  Om de har ändrats "
"skrivs en diagnostisk utdata till stderr och programmet avbryts via "
"Py_FatalError().  Det andra huvudsakliga felet är att provocera fram ett "
"minnesfel när ett program läser upp ett av de speciella bitmönstren och "
"försöker använda det som en adress.  Om du då går in i en debugger och "
"tittar på objektet kommer du sannolikt att se att det är helt fyllt med "
"PYMEM_DEADBYTE (vilket betyder att frigjort minne används) eller "
"PYMEM_CLEANBYTE (vilket betyder att oinitialiserat minne används)."

#: ../../c-api/memory.rst:601
msgid ""
"The :c:func:`PyMem_SetupDebugHooks` function now also works on Python "
"compiled in release mode.  On error, the debug hooks now use "
":mod:`tracemalloc` to get the traceback where a memory block was allocated. "
"The debug hooks now also check if the GIL is held when functions of "
":c:macro:`PYMEM_DOMAIN_OBJ` and :c:macro:`PYMEM_DOMAIN_MEM` domains are "
"called."
msgstr ""

#: ../../c-api/memory.rst:609
msgid ""
"Byte patterns ``0xCB`` (``PYMEM_CLEANBYTE``), ``0xDB`` (``PYMEM_DEADBYTE``) "
"and ``0xFB`` (``PYMEM_FORBIDDENBYTE``) have been replaced with ``0xCD``, "
"``0xDD`` and ``0xFD`` to use the same values than Windows CRT debug "
"``malloc()`` and ``free()``."
msgstr ""
"Bytemönstren ``0xCB`` (``PYMEM_CLEANBYTE``), ``0xDB`` (``PYMEM_DEADBYTE``) "
"och ``0xFB`` (``PYMEM_FORBIDDENBYTE``) har ersatts med ``0xCD``, ``0xDD`` "
"och ``0xFD`` för att använda samma värden som Windows CRT debug ``malloc()``"
" och ``free()``."

#: ../../c-api/memory.rst:619
msgid "The pymalloc allocator"
msgstr "Allokeringsverktyget pymalloc"

#: ../../c-api/memory.rst:621
msgid ""
"Python has a *pymalloc* allocator optimized for small objects (smaller or "
"equal to 512 bytes) with a short lifetime. It uses memory mappings called "
"\"arenas\" with a fixed size of either 256 KiB on 32-bit platforms or 1 MiB "
"on 64-bit platforms. It falls back to :c:func:`PyMem_RawMalloc` and "
":c:func:`PyMem_RawRealloc` for allocations larger than 512 bytes."
msgstr ""
"Python har en *pymalloc*-allokering som är optimerad för små objekt (mindre "
"eller lika med 512 byte) med kort livslängd. Den använder minnesmappningar "
"som kallas \"arenor\" med en fast storlek på antingen 256 KiB på 32-bitars "
"plattformar eller 1 MiB på 64-bitars plattformar. Den faller tillbaka till "
":c:func:`PyMem_RawMalloc` och :c:func:`PyMem_RawRealloc` för allokeringar "
"större än 512 byte."

#: ../../c-api/memory.rst:627
msgid ""
"*pymalloc* is the :ref:`default allocator <default-memory-allocators>` of "
"the :c:macro:`PYMEM_DOMAIN_MEM` (ex: :c:func:`PyMem_Malloc`) and "
":c:macro:`PYMEM_DOMAIN_OBJ` (ex: :c:func:`PyObject_Malloc`) domains."
msgstr ""
"*pymalloc* är :ref:`standardallokering <default-memory-allocators>` för "
"domänerna :c:macro:`PYMEM_DOMAIN_MEM` (ex: :c:func:`PyMem_Malloc`) och "
":c:macro:`PYMEM_DOMAIN_OBJ` (ex: :c:func:`PyObject_Malloc`)."

#: ../../c-api/memory.rst:631
msgid "The arena allocator uses the following functions:"
msgstr "Arenaallokeringen använder sig av följande funktioner:"

#: ../../c-api/memory.rst:633
msgid ":c:func:`!VirtualAlloc` and :c:func:`!VirtualFree` on Windows,"
msgstr ":c:func:`!VirtualAlloc` och :c:func:`!VirtualFree` i Windows,"

#: ../../c-api/memory.rst:634
msgid ":c:func:`!mmap` and :c:func:`!munmap` if available,"
msgstr ":c:func:`!mmap` och :c:func:`!munmap` om tillgängliga,"

#: ../../c-api/memory.rst:635
msgid ":c:func:`malloc` and :c:func:`free` otherwise."
msgstr ":c:func:`malloc` och :c:func:`free` annars."

#: ../../c-api/memory.rst:637
msgid ""
"This allocator is disabled if Python is configured with the "
":option:`--without-pymalloc` option. It can also be disabled at runtime "
"using the :envvar:`PYTHONMALLOC` environment variable (ex: "
"``PYTHONMALLOC=malloc``)."
msgstr ""
"Denna allokator inaktiveras om Python konfigureras med alternativet "
":option:`\\--without-pymalloc`. Den kan också inaktiveras under körning med "
"hjälp av miljövariabeln :envvar:`PYTHONMALLOC` (ex: "
"``PYTHONMALLOC=malloc``)."

#: ../../c-api/memory.rst:642
msgid "Customize pymalloc Arena Allocator"
msgstr "Anpassa pymalloc Arena Allocator"

#: ../../c-api/memory.rst:648
msgid ""
"Structure used to describe an arena allocator. The structure has three "
"fields:"
msgstr ""
"Struktur som används för att beskriva en arenaallokering. Strukturen har tre"
" fält:"

#: ../../c-api/memory.rst:656
msgid "``void* alloc(void *ctx, size_t size)``"
msgstr "``void* alloc(void *ctx, size_t size)``"

#: ../../c-api/memory.rst:656
msgid "allocate an arena of size bytes"
msgstr "allokera en arena av storleken bytes"

#: ../../c-api/memory.rst:658
msgid "``void free(void *ctx, void *ptr, size_t size)``"
msgstr "``void free(void *ctx, void *ptr, size_t size)``"

#: ../../c-api/memory.rst:658
msgid "free an arena"
msgstr "frigöra en arena"

#: ../../c-api/memory.rst:663
msgid "Get the arena allocator."
msgstr "Hämta arenans allokeringsenhet."

#: ../../c-api/memory.rst:667
msgid "Set the arena allocator."
msgstr "Ställ in arenaallokeringen."

#: ../../c-api/memory.rst:671
msgid "tracemalloc C API"
msgstr "tracemalloc C API"

#: ../../c-api/memory.rst:677
msgid "Track an allocated memory block in the :mod:`tracemalloc` module."
msgstr "Spåra ett allokerat minnesblock i modulen :mod:`tracemalloc`."

#: ../../c-api/memory.rst:679
msgid ""
"Return ``0`` on success, return ``-1`` on error (failed to allocate memory "
"to store the trace). Return ``-2`` if tracemalloc is disabled."
msgstr ""
"Returnera ``0`` vid framgång, returnera ``\\-1`` vid fel (misslyckades med "
"att allokera minne för att lagra spårningen). Returnerar ``\\-2`` om "
"tracemalloc är inaktiverat."

#: ../../c-api/memory.rst:682
msgid "If memory block is already tracked, update the existing trace."
msgstr ""
"Om minnesblocket redan är spårat, uppdatera den befintliga spårningen."

#: ../../c-api/memory.rst:686
msgid ""
"Untrack an allocated memory block in the :mod:`tracemalloc` module. Do "
"nothing if the block was not tracked."
msgstr ""
"Ta bort spårningen av ett allokerat minnesblock i modulen "
":mod:`tracemalloc`. Gör ingenting om blocket inte spårades."

#: ../../c-api/memory.rst:689
msgid "Return ``-2`` if tracemalloc is disabled, otherwise return ``0``."
msgstr ""
"Returnerar ``\\-2`` om tracemalloc är inaktiverat, annars returneras ``0``."

#: ../../c-api/memory.rst:695
msgid "Examples"
msgstr "Exempel"

#: ../../c-api/memory.rst:697
msgid ""
"Here is the example from section :ref:`memoryoverview`, rewritten so that "
"the I/O buffer is allocated from the Python heap by using the first function"
" set::"
msgstr ""
"Här är exemplet från avsnitt :ref:`memoryoverview`, omskrivet så att "
"I/O-bufferten allokeras från Pythons heap med hjälp av den första funktionen"
" set::"

#: ../../c-api/memory.rst:710
msgid "The same code using the type-oriented function set::"
msgstr "Samma kod med hjälp av den typorienterade funktionen set::"

#: ../../c-api/memory.rst:722
msgid ""
"Note that in the two examples above, the buffer is always manipulated via "
"functions belonging to the same set. Indeed, it is required to use the same "
"memory API family for a given memory block, so that the risk of mixing "
"different allocators is reduced to a minimum. The following code sequence "
"contains two errors, one of which is labeled as *fatal* because it mixes two"
" different allocators operating on different heaps. ::"
msgstr ""
"Observera att i de två exemplen ovan manipuleras bufferten alltid via "
"funktioner som tillhör samma uppsättning. Det är faktiskt nödvändigt att "
"använda samma minnes-API-familj för ett visst minnesblock, så att risken för"
" att blanda olika allokatorer reduceras till ett minimum. Följande "
"kodsekvens innehåller två fel, varav det ena är märkt som *dödligt* eftersom"
" det blandar två olika allokatorer som arbetar på olika heaps. ::"

#: ../../c-api/memory.rst:737
msgid ""
"In addition to the functions aimed at handling raw memory blocks from the "
"Python heap, objects in Python are allocated and released with "
":c:macro:`PyObject_New`, :c:macro:`PyObject_NewVar` and "
":c:func:`PyObject_Del`."
msgstr ""

#: ../../c-api/memory.rst:741
msgid ""
"These will be explained in the next chapter on defining and implementing new"
" object types in C."
msgstr ""
"Dessa kommer att förklaras i nästa kapitel om att definiera och implementera"
" nya objekttyper i C."

#: ../../c-api/memory.rst:43
msgid "malloc (C function)"
msgstr "malloc (C-funktion)"

#: ../../c-api/memory.rst:43
msgid "calloc (C function)"
msgstr "calloc (C-funktion)"

#: ../../c-api/memory.rst:43
msgid "realloc (C function)"
msgstr "realloc (C-funktion)"

#: ../../c-api/memory.rst:43
msgid "free (C function)"
msgstr "fri (C-funktion)"
