# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# python-doc bot, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-25 17:21+0000\n"
"PO-Revision-Date: 2025-09-22 15:56+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../c-api/buffer.rst:11
msgid "Buffer Protocol"
msgstr "Buffertprotokoll"

#: ../../c-api/buffer.rst:18
msgid ""
"Certain objects available in Python wrap access to an underlying memory "
"array or *buffer*.  Such objects include the built-in :class:`bytes` and "
":class:`bytearray`, and some extension types like :class:`array.array`. "
"Third-party libraries may define their own types for special purposes, such "
"as image processing or numeric analysis."
msgstr ""
"Vissa objekt som finns i Python ger tillgång till en underliggande "
"minnesarray eller *buffer*.  Sådana objekt inkluderar de inbyggda "
":class:`bytes` och :class:`bytearray`, och vissa tilläggstyper som "
":class:`array.array`. Tredjepartsbibliotek kan definiera sina egna typer för"
" speciella ändamål, t.ex. bildbehandling eller numerisk analys."

#: ../../c-api/buffer.rst:24
msgid ""
"While each of these types have their own semantics, they share the common "
"characteristic of being backed by a possibly large memory buffer.  It is "
"then desirable, in some situations, to access that buffer directly and "
"without intermediate copying."
msgstr ""
"Även om var och en av dessa typer har sin egen semantik, har de den "
"gemensamma egenskapen att de backas upp av en eventuellt stor minnesbuffert."
"  I vissa situationer är det då önskvärt att komma åt den bufferten direkt "
"och utan mellanliggande kopiering."

#: ../../c-api/buffer.rst:29
msgid ""
"Python provides such a facility at the C level in the form of the "
":ref:`buffer protocol <bufferobjects>`.  This protocol has two sides:"
msgstr ""

#: ../../c-api/buffer.rst:34
msgid ""
"on the producer side, a type can export a \"buffer interface\" which allows "
"objects of that type to expose information about their underlying buffer. "
"This interface is described in the section :ref:`buffer-structs`;"
msgstr ""

#: ../../c-api/buffer.rst:38
msgid ""
"on the consumer side, several means are available to obtain a pointer to the"
" raw underlying data of an object (for example a method parameter)."
msgstr ""

#: ../../c-api/buffer.rst:41
msgid ""
"Simple objects such as :class:`bytes` and :class:`bytearray` expose their "
"underlying buffer in byte-oriented form.  Other forms are possible; for "
"example, the elements exposed by an :class:`array.array` can be multi-byte "
"values."
msgstr ""
"Enkla objekt som :class:`bytes` och :class:`bytearray` exponerar sin "
"underliggande buffert i byteorienterad form.  Andra former är möjliga; till "
"exempel kan elementen som exponeras av en :class:`array.array` vara "
"multibyte-värden."

#: ../../c-api/buffer.rst:45
msgid ""
"An example consumer of the buffer interface is the "
":meth:`~io.BufferedIOBase.write` method of file objects: any object that can"
" export a series of bytes through the buffer interface can be written to a "
"file.  While :meth:`write` only needs read-only access to the internal "
"contents of the object passed to it, other methods such as "
":meth:`~io.BufferedIOBase.readinto` need write access to the contents of "
"their argument.  The buffer interface allows objects to selectively allow or"
" reject exporting of read-write and read-only buffers."
msgstr ""

#: ../../c-api/buffer.rst:53
msgid ""
"There are two ways for a consumer of the buffer interface to acquire a "
"buffer over a target object:"
msgstr ""
"Det finns två sätt för en användare av buffertgränssnittet att skaffa en "
"buffert över ett målobjekt:"

#: ../../c-api/buffer.rst:56
msgid "call :c:func:`PyObject_GetBuffer` with the right parameters;"
msgstr "anropa :c:func:`PyObject_GetBuffer` med rätt parametrar;"

#: ../../c-api/buffer.rst:58
msgid ""
"call :c:func:`PyArg_ParseTuple` (or one of its siblings) with one of the "
"``y*``, ``w*`` or ``s*`` :ref:`format codes <arg-parsing>`."
msgstr ""
"anropa :c:func:`PyArg_ParseTuple` (eller ett av dess syskon) med en av "
"``y*``, ``w*`` eller ``s*`` :ref:`formatkoder <arg-parsing>`."

#: ../../c-api/buffer.rst:61
msgid ""
"In both cases, :c:func:`PyBuffer_Release` must be called when the buffer "
"isn't needed anymore.  Failure to do so could lead to various issues such as"
" resource leaks."
msgstr ""
"I båda fallen måste :c:func:`PyBuffer_Release` anropas när bufferten inte "
"längre behövs.  Om detta inte görs kan det leda till olika problem, t.ex. "
"resursläckage."

#: ../../c-api/buffer.rst:69
msgid "Buffer structure"
msgstr "Buffertstruktur"

#: ../../c-api/buffer.rst:71
msgid ""
"Buffer structures (or simply \"buffers\") are useful as a way to expose the "
"binary data from another object to the Python programmer.  They can also be "
"used as a zero-copy slicing mechanism.  Using their ability to reference a "
"block of memory, it is possible to expose any data to the Python programmer "
"quite easily.  The memory could be a large, constant array in a C extension,"
" it could be a raw block of memory for manipulation before passing to an "
"operating system library, or it could be used to pass around structured data"
" in its native, in-memory format."
msgstr ""
"Buffertstrukturer (eller helt enkelt \"buffertar\") är användbara som ett "
"sätt att exponera binärdata från ett annat objekt till Python-"
"programmeraren.  De kan också användas som en nollkopieringsmekanism.  Genom"
" att använda deras förmåga att referera till ett minnesblock är det möjligt "
"att exponera vilken data som helst för Python-programmeraren ganska enkelt."
"  Minnet kan vara en stor, konstant array i ett C-tillägg, det kan vara ett "
"råminnesblock för manipulation innan det skickas till ett "
"operativsystembibliotek, eller det kan användas för att skicka runt "
"strukturerade data i sitt ursprungliga format i minnet."

#: ../../c-api/buffer.rst:80
msgid ""
"Contrary to most data types exposed by the Python interpreter, buffers are "
"not :c:type:`PyObject` pointers but rather simple C structures.  This allows"
" them to be created and copied very simply.  When a generic wrapper around a"
" buffer is needed, a :ref:`memoryview <memoryview-objects>` object can be "
"created."
msgstr ""
"Till skillnad från de flesta datatyper som exponeras av Python-tolken är "
"buffertar inte :c:type:`PyObject`-pekare utan snarare enkla C-strukturer.  "
"Detta gör att de kan skapas och kopieras mycket enkelt.  När ett generiskt "
"omslag runt en buffert behövs kan ett :ref:`memoryview <memoryview-"
"objects>`-objekt skapas."

#: ../../c-api/buffer.rst:86
msgid ""
"For short instructions how to write an exporting object, see :ref:`Buffer "
"Object Structures <buffer-structs>`. For obtaining a buffer, see "
":c:func:`PyObject_GetBuffer`."
msgstr ""
"För korta instruktioner om hur man skriver ett exporterande objekt, se "
":ref:`Buffer Object Structures <buffer-structs>`. För att hämta en buffert, "
"se :c:func:`PyObject_GetBuffer`."

#: ../../c-api/buffer.rst:94
msgid ""
"A pointer to the start of the logical structure described by the buffer "
"fields. This can be any location within the underlying physical memory block"
" of the exporter. For example, with negative :c:member:`~Py_buffer.strides` "
"the value may point to the end of the memory block."
msgstr ""
"En pekare till början av den logiska struktur som beskrivs av buffertfälten."
" Detta kan vara vilken plats som helst inom det underliggande fysiska "
"minnesblocket hos exportören. Till exempel, med negativ "
":c:member:`~Py_buffer.strides` kan värdet peka till slutet av minnesblocket."

#: ../../c-api/buffer.rst:99
msgid ""
"For :term:`contiguous` arrays, the value points to the beginning of the "
"memory block."
msgstr ""
"För :term:`contiguous` arrays pekar värdet på början av minnesblocket."

#: ../../c-api/buffer.rst:104
msgid ""
"A new reference to the exporting object. The reference is owned by the "
"consumer and automatically released (i.e. reference count decremented) and "
"set to ``NULL`` by :c:func:`PyBuffer_Release`. The field is the equivalent "
"of the return value of any standard C-API function."
msgstr ""
"En ny referens till det exporterande objektet. Referensen ägs av konsumenten"
" och frigörs automatiskt (d.v.s. referensantalet minskas) och sätts till "
"``NULL`` av :c:func:`PyBuffer_Release`. Fältet motsvarar returvärdet för "
"vilken standard C-API-funktion som helst."

#: ../../c-api/buffer.rst:111
msgid ""
"As a special case, for *temporary* buffers that are wrapped by "
":c:func:`PyMemoryView_FromBuffer` or :c:func:`PyBuffer_FillInfo` this field "
"is ``NULL``. In general, exporting objects MUST NOT use this scheme."
msgstr ""
"Som ett specialfall, för *temporära* buffertar som är omslutna av "
":c:func:`PyMemoryView_FromBuffer` eller :c:func:`PyBuffer_FillInfo` är detta"
" fält ``NULL``. Generellt gäller att exporterande objekt INTE får använda "
"detta schema."

#: ../../c-api/buffer.rst:118
msgid ""
"``product(shape) * itemsize``. For contiguous arrays, this is the length of "
"the underlying memory block. For non-contiguous arrays, it is the length "
"that the logical structure would have if it were copied to a contiguous "
"representation."
msgstr ""
"``produkt(form) * artikelstorlek``. För sammanhängande arrayer är detta "
"längden på det underliggande minnesblocket. För icke sammanhängande matriser"
" är det den längd som den logiska strukturen skulle ha om den kopierades "
"till en sammanhängande representation."

#: ../../c-api/buffer.rst:123
msgid ""
"Accessing ``((char *)buf)[0] up to ((char *)buf)[len-1]`` is only valid if "
"the buffer has been obtained by a request that guarantees contiguity. In "
"most cases such a request will be :c:macro:`PyBUF_SIMPLE` or "
":c:macro:`PyBUF_WRITABLE`."
msgstr ""
"Att komma åt ``((char *)buf)[0] upp till ((char *)buf)[len-1]`` är bara "
"giltigt om bufferten har erhållits genom en begäran som garanterar "
"sammanhängande. I de flesta fall kommer en sådan begäran att vara "
":c:macro:`PyBUF_SIMPLE` eller :c:macro:`PyBUF_WRITABLE`."

#: ../../c-api/buffer.rst:129
msgid ""
"An indicator of whether the buffer is read-only. This field is controlled by"
" the :c:macro:`PyBUF_WRITABLE` flag."
msgstr ""
"En indikator på om bufferten är skrivskyddad. Detta fält styrs av "
":c:macro:`PyBUF_WRITABLE` flaggan."

#: ../../c-api/buffer.rst:134
msgid ""
"Item size in bytes of a single element. Same as the value of "
":func:`struct.calcsize` called on non-``NULL`` :c:member:`~Py_buffer.format`"
" values."
msgstr ""
"Elementstorlek i bytes för ett enda element. Samma som värdet av "
":func:`struct.calcsize` som anropas på icke-``NULL`` "
":c:member:`~Py_buffer.format`-värden."

#: ../../c-api/buffer.rst:137
msgid ""
"Important exception: If a consumer requests a buffer without the "
":c:macro:`PyBUF_FORMAT` flag, :c:member:`~Py_buffer.format` will be set to  "
"``NULL``,  but :c:member:`~Py_buffer.itemsize` still has the value for the "
"original format."
msgstr ""
"Viktigt undantag: Om en konsument begär en buffert utan "
":c:macro:`PyBUF_FORMAT` flaggan, kommer :c:member:`~Py_buffer.format` att "
"sättas till ``NULL``, men :c:member:`~Py_buffer.itemsize` har fortfarande "
"värdet för det ursprungliga formatet."

#: ../../c-api/buffer.rst:142
msgid ""
"If :c:member:`~Py_buffer.shape` is present, the equality ``product(shape) * "
"itemsize == len`` still holds and the consumer can use "
":c:member:`~Py_buffer.itemsize` to navigate the buffer."
msgstr ""
"Om :c:member:`~Py_buffer.shape` är närvarande gäller fortfarande likheten "
"``product(shape) * itemsize == len`` och konsumenten kan använda "
":c:member:`~Py_buffer.itemsize` för att navigera i bufferten."

#: ../../c-api/buffer.rst:146
msgid ""
"If :c:member:`~Py_buffer.shape` is ``NULL`` as a result of a "
":c:macro:`PyBUF_SIMPLE` or a :c:macro:`PyBUF_WRITABLE` request, the consumer"
" must disregard :c:member:`~Py_buffer.itemsize` and assume ``itemsize == "
"1``."
msgstr ""
"Om :c:member:`~Py_buffer.shape` är ``NULL`` som ett resultat av en "
":c:macro:`PyBUF_SIMPLE` eller en :c:macro:`PyBUF_WRITABLE` begäran, måste "
"konsumenten bortse från :c:member:`~Py_buffer.itemsize` och anta ``itemsize "
"== 1``."

#: ../../c-api/buffer.rst:152
msgid ""
"A *NUL* terminated string in :mod:`struct` module style syntax describing "
"the contents of a single item. If this is ``NULL``, ``\"B\"`` (unsigned "
"bytes) is assumed."
msgstr ""

#: ../../c-api/buffer.rst:156
msgid "This field is controlled by the :c:macro:`PyBUF_FORMAT` flag."
msgstr "Detta fält styrs av flaggan :c:macro:`PyBUF_FORMAT`."

#: ../../c-api/buffer.rst:160
msgid ""
"The number of dimensions the memory represents as an n-dimensional array. If"
" it is ``0``, :c:member:`~Py_buffer.buf` points to a single item "
"representing a scalar. In this case, :c:member:`~Py_buffer.shape`, "
":c:member:`~Py_buffer.strides` and :c:member:`~Py_buffer.suboffsets` MUST be"
" ``NULL``."
msgstr ""

#: ../../c-api/buffer.rst:165
msgid ""
"The macro :c:macro:`PyBUF_MAX_NDIM` limits the maximum number of dimensions "
"to 64. Exporters MUST respect this limit, consumers of multi-dimensional "
"buffers SHOULD be able to handle up to :c:macro:`PyBUF_MAX_NDIM` dimensions."
msgstr ""

#: ../../c-api/buffer.rst:171
msgid ""
"An array of :c:type:`Py_ssize_t` of length :c:member:`~Py_buffer.ndim` "
"indicating the shape of the memory as an n-dimensional array. Note that "
"``shape[0] * ... * shape[ndim-1] * itemsize`` MUST be equal to "
":c:member:`~Py_buffer.len`."
msgstr ""
"En array av :c:type:`Py_ssize_t` med längden :c:member:`~Py_buffer.ndim` som"
" anger formen på minnet som en n-dimensionell array. Observera att "
"``shape[0] * ... * shape[ndim-1] * itemsize`` MÅSTE vara lika med "
":c:member:`~Py_buffer.len`."

#: ../../c-api/buffer.rst:176
msgid ""
"Shape values are restricted to ``shape[n] >= 0``. The case ``shape[n] == 0``"
" requires special attention. See `complex arrays`_ for further information."
msgstr ""
"Shape-värden är begränsade till ``shape[n] >= 0``. Fallet ``shape[n] == 0`` "
"kräver särskild uppmärksamhet. Se `komplexa matriser`_ för ytterligare "
"information."

#: ../../c-api/buffer.rst:180
msgid "The shape array is read-only for the consumer."
msgstr "Shape-arrayen är skrivskyddad för konsumenten."

#: ../../c-api/buffer.rst:184
msgid ""
"An array of :c:type:`Py_ssize_t` of length :c:member:`~Py_buffer.ndim` "
"giving the number of bytes to skip to get to a new element in each "
"dimension."
msgstr ""
"En array av :c:type:`Py_ssize_t` med längden :c:member:`~Py_buffer.ndim` som"
" anger antalet bytes som ska hoppas över för att komma till ett nytt element"
" i varje dimension."

#: ../../c-api/buffer.rst:188
msgid ""
"Stride values can be any integer. For regular arrays, strides are usually "
"positive, but a consumer MUST be able to handle the case ``strides[n] <= "
"0``. See `complex arrays`_ for further information."
msgstr ""
"Stride-värden kan vara valfritt heltal. För vanliga arrayer är strides "
"vanligtvis positiva, men en konsument MÅSTE kunna hantera fallet "
"``strides[n] <= 0``. Se `komplexa arrayer`_ för mer information."

#: ../../c-api/buffer.rst:192
msgid "The strides array is read-only for the consumer."
msgstr "Strides-arrayen är skrivskyddad för konsumenten."

#: ../../c-api/buffer.rst:196
msgid ""
"An array of :c:type:`Py_ssize_t` of length :c:member:`~Py_buffer.ndim`. If "
"``suboffsets[n] >= 0``, the values stored along the nth dimension are "
"pointers and the suboffset value dictates how many bytes to add to each "
"pointer after de-referencing. A suboffset value that is negative indicates "
"that no de-referencing should occur (striding in a contiguous memory block)."
msgstr ""
"En array av :c:type:`Py_ssize_t` med längden :c:member:`~Py_buffer.ndim`. Om"
" ``suboffsets[n] >= 0`` är värdena som lagras längs den n:te dimensionen "
"pekare och suboffset-värdet anger hur många byte som ska läggas till varje "
"pekare efter de-referering. Ett negativt suboffset-värde anger att ingen de-"
"referensering ska ske (striding i ett sammanhängande minnesblock)."

#: ../../c-api/buffer.rst:203
msgid ""
"If all suboffsets are negative (i.e. no de-referencing is needed), then this"
" field must be ``NULL`` (the default value)."
msgstr ""
"Om alla suboffsets är negativa (dvs. ingen de-referensering behövs), måste "
"detta fält vara ``NULL`` (standardvärdet)."

#: ../../c-api/buffer.rst:206
msgid ""
"This type of array representation is used by the Python Imaging Library "
"(PIL). See `complex arrays`_ for further information how to access elements "
"of such an array."
msgstr ""
"Denna typ av matrisrepresentation används av Python Imaging Library (PIL). "
"Se `komplexa arrayer`_ för mer information om hur du får tillgång till "
"element i en sådan array."

#: ../../c-api/buffer.rst:210
msgid "The suboffsets array is read-only for the consumer."
msgstr "Suboffsets-arrayen är skrivskyddad för konsumenten."

#: ../../c-api/buffer.rst:214
msgid ""
"This is for use internally by the exporting object. For example, this might "
"be re-cast as an integer by the exporter and used to store flags about "
"whether or not the shape, strides, and suboffsets arrays must be freed when "
"the buffer is released. The consumer MUST NOT alter this value."
msgstr ""
"Detta är för intern användning av det exporterande objektet. Det kan t.ex. "
"omformas till ett heltal av exportören och användas för att lagra flaggor om"
" huruvida arrayer med shape, strides och suboffsets måste frigöras när "
"bufferten släpps. Konsumenten MÅSTE INTE ändra detta värde."

#: ../../c-api/buffer.rst:223
msgid "Buffer request types"
msgstr "Typer av buffertförfrågningar"

#: ../../c-api/buffer.rst:225
msgid ""
"Buffers are usually obtained by sending a buffer request to an exporting "
"object via :c:func:`PyObject_GetBuffer`. Since the complexity of the logical"
" structure of the memory can vary drastically, the consumer uses the *flags*"
" argument to specify the exact buffer type it can handle."
msgstr ""
"Buffertar erhålls vanligtvis genom att skicka en buffertförfrågan till ett "
"exporterande objekt via :c:func:`PyObject_GetBuffer`. Eftersom komplexiteten"
" i minnets logiska struktur kan variera drastiskt använder konsumenten "
"argumentet *flags* för att ange den exakta bufferttyp som den kan hantera."

#: ../../c-api/buffer.rst:230
msgid ""
"All :c:data:`Py_buffer` fields are unambiguously defined by the request "
"type."
msgstr ""

#: ../../c-api/buffer.rst:234
msgid "request-independent fields"
msgstr "fält oberoende av begäran"

#: ../../c-api/buffer.rst:235
msgid ""
"The following fields are not influenced by *flags* and must always be filled"
" in with the correct values: :c:member:`~Py_buffer.obj`, "
":c:member:`~Py_buffer.buf`, :c:member:`~Py_buffer.len`, "
":c:member:`~Py_buffer.itemsize`, :c:member:`~Py_buffer.ndim`."
msgstr ""
"Följande fält påverkas inte av *flags* och måste alltid fyllas i med "
"korrekta värden: :c:member:`~Py_buffer.obj`, :c:member:`~Py_buffer.buf`, "
":c:member:`~Py_buffer.len`, :c:member:`~Py_buffer.itemsize`, "
":c:member:`~Py_buffer.ndim`."

#: ../../c-api/buffer.rst:241
msgid "readonly, format"
msgstr "skrivskyddad, format"

#: ../../c-api/buffer.rst:245
msgid ""
"Controls the :c:member:`~Py_buffer.readonly` field. If set, the exporter "
"MUST provide a writable buffer or else report failure. Otherwise, the "
"exporter MAY provide either a read-only or writable buffer, but the choice "
"MUST be consistent for all consumers."
msgstr ""

#: ../../c-api/buffer.rst:252
msgid ""
"Controls the :c:member:`~Py_buffer.format` field. If set, this field MUST be"
" filled in correctly. Otherwise, this field MUST be ``NULL``."
msgstr ""
"Kontrollerar fältet :c:member:`~Py_buffer.format`. Om det är inställt MÅSTE "
"fältet fyllas i korrekt. Annars MÅSTE detta fält vara ``NULL``."

#: ../../c-api/buffer.rst:256
msgid ""
":c:macro:`PyBUF_WRITABLE` can be \\|'d to any of the flags in the next "
"section. Since :c:macro:`PyBUF_SIMPLE` is defined as 0, "
":c:macro:`PyBUF_WRITABLE` can be used as a stand-alone flag to request a "
"simple writable buffer."
msgstr ""
":c:macro:`PyBUF_WRITABLE` kan kopplas till någon av flaggorna i nästa "
"avsnitt. Eftersom :c:macro:`PyBUF_SIMPLE` är definierad som 0, kan "
":c:macro:`PyBUF_WRITABLE` användas som en fristående flagga för att begära "
"en enkel skrivbar buffert."

#: ../../c-api/buffer.rst:260
msgid ""
":c:macro:`PyBUF_FORMAT` can be \\|'d to any of the flags except "
":c:macro:`PyBUF_SIMPLE`. The latter already implies format ``B`` (unsigned "
"bytes)."
msgstr ""

#: ../../c-api/buffer.rst:265
msgid "shape, strides, suboffsets"
msgstr "form, strides, suboffsets"

#: ../../c-api/buffer.rst:267
msgid ""
"The flags that control the logical structure of the memory are listed in "
"decreasing order of complexity. Note that each flag contains all bits of the"
" flags below it."
msgstr ""
"Flaggorna som styr minnets logiska struktur är listade i fallande ordning "
"efter komplexitet. Observera att varje flagga innehåller alla bitar i "
"flaggorna under den."

#: ../../c-api/buffer.rst:274 ../../c-api/buffer.rst:298
#: ../../c-api/buffer.rst:323
msgid "Request"
msgstr "Förfrågan"

#: ../../c-api/buffer.rst:274 ../../c-api/buffer.rst:298
#: ../../c-api/buffer.rst:323
msgid "shape"
msgstr "form"

#: ../../c-api/buffer.rst:274 ../../c-api/buffer.rst:298
#: ../../c-api/buffer.rst:323
msgid "strides"
msgstr "steg"

#: ../../c-api/buffer.rst:274 ../../c-api/buffer.rst:298
#: ../../c-api/buffer.rst:323
msgid "suboffsets"
msgstr "delmängder"

#: ../../c-api/buffer.rst:276 ../../c-api/buffer.rst:276
#: ../../c-api/buffer.rst:278 ../../c-api/buffer.rst:278
#: ../../c-api/buffer.rst:280 ../../c-api/buffer.rst:300
#: ../../c-api/buffer.rst:300 ../../c-api/buffer.rst:302
#: ../../c-api/buffer.rst:302 ../../c-api/buffer.rst:304
#: ../../c-api/buffer.rst:304 ../../c-api/buffer.rst:306
#: ../../c-api/buffer.rst:325 ../../c-api/buffer.rst:325
#: ../../c-api/buffer.rst:325 ../../c-api/buffer.rst:327
#: ../../c-api/buffer.rst:327 ../../c-api/buffer.rst:327
#: ../../c-api/buffer.rst:329 ../../c-api/buffer.rst:329
#: ../../c-api/buffer.rst:329 ../../c-api/buffer.rst:331
#: ../../c-api/buffer.rst:331 ../../c-api/buffer.rst:331
#: ../../c-api/buffer.rst:333 ../../c-api/buffer.rst:333
#: ../../c-api/buffer.rst:335 ../../c-api/buffer.rst:335
#: ../../c-api/buffer.rst:337 ../../c-api/buffer.rst:339
msgid "yes"
msgstr "ja"

#: ../../c-api/buffer.rst:276 ../../c-api/buffer.rst:325
#: ../../c-api/buffer.rst:327
msgid "if needed"
msgstr "om det behövs"

#: ../../c-api/buffer.rst:278 ../../c-api/buffer.rst:280
#: ../../c-api/buffer.rst:280 ../../c-api/buffer.rst:282
#: ../../c-api/buffer.rst:282 ../../c-api/buffer.rst:282
#: ../../c-api/buffer.rst:300 ../../c-api/buffer.rst:302
#: ../../c-api/buffer.rst:304 ../../c-api/buffer.rst:306
#: ../../c-api/buffer.rst:306 ../../c-api/buffer.rst:329
#: ../../c-api/buffer.rst:331 ../../c-api/buffer.rst:333
#: ../../c-api/buffer.rst:333 ../../c-api/buffer.rst:335
#: ../../c-api/buffer.rst:335 ../../c-api/buffer.rst:337
#: ../../c-api/buffer.rst:337 ../../c-api/buffer.rst:337
#: ../../c-api/buffer.rst:339 ../../c-api/buffer.rst:339
#: ../../c-api/buffer.rst:339
msgid "NULL"
msgstr "NULL"

#: ../../c-api/buffer.rst:289
msgid "contiguity requests"
msgstr "begäran om angränsning"

#: ../../c-api/buffer.rst:291
msgid ""
"C or Fortran :term:`contiguity <contiguous>` can be explicitly requested, "
"with and without stride information. Without stride information, the buffer "
"must be C-contiguous."
msgstr ""
"C eller Fortran :term:`contiguity <contiguous>` kan uttryckligen begäras, "
"med eller utan stride-information. Utan stride-information måste bufferten "
"vara C-kontigu."

#: ../../c-api/buffer.rst:298 ../../c-api/buffer.rst:323
msgid "contig"
msgstr "kontigent"

#: ../../c-api/buffer.rst:300 ../../c-api/buffer.rst:306
#: ../../c-api/buffer.rst:337 ../../c-api/buffer.rst:339
msgid "C"
msgstr "C"

#: ../../c-api/buffer.rst:302
msgid "F"
msgstr "F"

#: ../../c-api/buffer.rst:304
msgid "C or F"
msgstr "C eller F"

#: ../../c-api/buffer.rst:306
msgid ":c:macro:`PyBUF_ND`"
msgstr ":c:makro:`PyBUF_ND`"

#: ../../c-api/buffer.rst:311
msgid "compound requests"
msgstr "sammansatta förfrågningar"

#: ../../c-api/buffer.rst:313
msgid ""
"All possible requests are fully defined by some combination of the flags in "
"the previous section. For convenience, the buffer protocol provides "
"frequently used combinations as single flags."
msgstr ""
"Alla möjliga förfrågningar definieras fullt ut av någon kombination av "
"flaggorna i föregående avsnitt. För enkelhetens skull tillhandahåller "
"buffertprotokollet ofta använda kombinationer som enskilda flaggor."

#: ../../c-api/buffer.rst:317
msgid ""
"In the following table *U* stands for undefined contiguity. The consumer "
"would have to call :c:func:`PyBuffer_IsContiguous` to determine contiguity."
msgstr ""
"I följande tabell står *U* för undefined contiguity (odefinierad "
"sammanhängande). Konsumenten måste anropa :c:func:`PyBuffer_IsContiguous` "
"för att avgöra sammanhängande."

#: ../../c-api/buffer.rst:323
msgid "readonly"
msgstr "skrivskyddad"

#: ../../c-api/buffer.rst:323
msgid "format"
msgstr "format"

#: ../../c-api/buffer.rst:325 ../../c-api/buffer.rst:327
#: ../../c-api/buffer.rst:329 ../../c-api/buffer.rst:331
#: ../../c-api/buffer.rst:333 ../../c-api/buffer.rst:335
msgid "U"
msgstr "U"

#: ../../c-api/buffer.rst:325 ../../c-api/buffer.rst:329
#: ../../c-api/buffer.rst:333 ../../c-api/buffer.rst:337
msgid "0"
msgstr "0"

#: ../../c-api/buffer.rst:327 ../../c-api/buffer.rst:331
#: ../../c-api/buffer.rst:335 ../../c-api/buffer.rst:339
msgid "1 or 0"
msgstr "1 eller 0"

#: ../../c-api/buffer.rst:344
msgid "Complex arrays"
msgstr "Komplexa matriser"

#: ../../c-api/buffer.rst:347
msgid "NumPy-style: shape and strides"
msgstr "NumPy-stil: form och strides"

#: ../../c-api/buffer.rst:349
msgid ""
"The logical structure of NumPy-style arrays is defined by "
":c:member:`~Py_buffer.itemsize`, :c:member:`~Py_buffer.ndim`, "
":c:member:`~Py_buffer.shape` and :c:member:`~Py_buffer.strides`."
msgstr ""
"Den logiska strukturen för matriser i NumPy-stil definieras av "
":c:member:`~Py_buffer.itemsize`, :c:member:`~Py_buffer.ndim`, "
":c:member:`~Py_buffer.shape` och :c:member:`~Py_buffer.strides`."

#: ../../c-api/buffer.rst:352
msgid ""
"If ``ndim == 0``, the memory location pointed to by "
":c:member:`~Py_buffer.buf` is interpreted as a scalar of size "
":c:member:`~Py_buffer.itemsize`. In that case, both "
":c:member:`~Py_buffer.shape` and :c:member:`~Py_buffer.strides` are "
"``NULL``."
msgstr ""
"Om ``ndim == 0``, tolkas minnesplatsen som pekas ut av "
":c:member:`~Py_buffer.buf` som en skalär av storleken "
":c:member:`~Py_buffer.itemsize`. I det fallet är både "
":c:member:`~Py_buffer.shape` och :c:member:`~Py_buffer.strides` ``NULL``."

#: ../../c-api/buffer.rst:356
msgid ""
"If :c:member:`~Py_buffer.strides` is ``NULL``, the array is interpreted as a"
" standard n-dimensional C-array. Otherwise, the consumer must access an "
"n-dimensional array as follows:"
msgstr ""
"Om :c:member:`~Py_buffer.strides` är ``NULL`` tolkas matrisen som en "
"standard n-dimensionell C-array. Annars måste konsumenten komma åt en "
"n-dimensionell array på följande sätt:"

#: ../../c-api/buffer.rst:366
msgid ""
"As noted above, :c:member:`~Py_buffer.buf` can point to any location within "
"the actual memory block. An exporter can check the validity of a buffer with"
" this function:"
msgstr ""
"Som nämnts ovan kan :c:member:`~Py_buffer.buf` peka på vilken plats som "
"helst inom det faktiska minnesblocket. En exportör kan kontrollera "
"giltigheten av en buffert med denna funktion:"

#: ../../c-api/buffer.rst:400
msgid "PIL-style: shape, strides and suboffsets"
msgstr "PIL-stil: form, strides och suboffsets"

#: ../../c-api/buffer.rst:402
msgid ""
"In addition to the regular items, PIL-style arrays can contain pointers that"
" must be followed in order to get to the next element in a dimension. For "
"example, the regular three-dimensional C-array ``char v[2][2][3]`` can also "
"be viewed as an array of 2 pointers to 2 two-dimensional arrays: ``char "
"(*v[2])[2][3]``. In suboffsets representation, those two pointers can be "
"embedded at the start of :c:member:`~Py_buffer.buf`, pointing to two ``char "
"x[2][3]`` arrays that can be located anywhere in memory."
msgstr ""
"Förutom de vanliga elementen kan matriser i PIL-stil innehålla pekare som "
"måste följas för att komma till nästa element i en dimension. Till exempel "
"kan den vanliga tredimensionella C-arrayen ``char v[2][2][3]`` också ses som"
" en array med 2 pekare till 2 tvådimensionella arrayer: ``char "
"(*v[2])[2][3]``. I suboffsets-representationen kan dessa två pekare bäddas "
"in i början av :c:member:`~Py_buffer.buf` och peka på två ``char "
"x[2][3]``-arrayer som kan placeras var som helst i minnet."

#: ../../c-api/buffer.rst:411
msgid ""
"Here is a function that returns a pointer to the element in an N-D array "
"pointed to by an N-dimensional index when there are both non-``NULL`` "
"strides and suboffsets::"
msgstr ""
"Här är en funktion som returnerar en pekare till elementet i en N-D-array "
"som pekas ut av ett N-dimensionellt index när det finns både icke-``NULL`` "
"strides och suboffsets::"

#: ../../c-api/buffer.rst:430
msgid "Buffer-related functions"
msgstr "Buffertrelaterade funktioner"

#: ../../c-api/buffer.rst:434
msgid ""
"Return ``1`` if *obj* supports the buffer interface otherwise ``0``.  When "
"``1`` is returned, it doesn't guarantee that :c:func:`PyObject_GetBuffer` "
"will succeed.  This function always succeeds."
msgstr ""
"Returnerar ``1`` om *obj* stöder buffertgränssnittet annars ``0``.  När "
"``1`` returneras, garanterar det inte att :c:func:`PyObject_GetBuffer` "
"kommer att lyckas.  Denna funktion lyckas alltid."

#: ../../c-api/buffer.rst:441
msgid ""
"Send a request to *exporter* to fill in *view* as specified by  *flags*. If "
"the exporter cannot provide a buffer of the exact type, it MUST raise "
":c:data:`PyExc_BufferError`, set ``view->obj`` to ``NULL`` and return "
"``-1``."
msgstr ""

#: ../../c-api/buffer.rst:446
msgid ""
"On success, fill in *view*, set ``view->obj`` to a new reference to "
"*exporter* and return 0. In the case of chained buffer providers that "
"redirect requests to a single object, ``view->obj`` MAY refer to this object"
" instead of *exporter* (See :ref:`Buffer Object Structures <buffer-"
"structs>`)."
msgstr ""
"Vid framgång, fyll i *view*, sätt ``view-&gt;obj`` till en ny referens till "
"*exporter* och returnera 0. När det gäller kedjade buffertleverantörer som "
"omdirigerar förfrågningar till ett enda objekt, KAN ``view-&gt;obj`` "
"referera till detta objekt istället för *exporter* (Se "
":ref:``Buffertobjektstrukturer <buffer-structs>``)."

#: ../../c-api/buffer.rst:451
msgid ""
"Successful calls to :c:func:`PyObject_GetBuffer` must be paired with calls "
"to :c:func:`PyBuffer_Release`, similar to :c:func:`malloc` and "
":c:func:`free`. Thus, after the consumer is done with the buffer, "
":c:func:`PyBuffer_Release` must be called exactly once."
msgstr ""
"Lyckade anrop till :c:func:`PyObject_GetBuffer` måste paras ihop med anrop "
"till :c:func:`PyBuffer_Release`, på samma sätt som :c:func:`malloc` och "
":c:func:`free`. Efter att konsumenten är klar med bufferten måste alltså "
":c:func:`PyBuffer_Release` anropas exakt en gång."

#: ../../c-api/buffer.rst:459
msgid ""
"Release the buffer *view* and release the :term:`strong reference` (i.e. "
"decrement the reference count) to the view's supporting object, "
"``view->obj``. This function MUST be called when the buffer is no longer "
"being used, otherwise reference leaks may occur."
msgstr ""
"Frigör bufferten *view* och frigör :term:`strong-referensen` (dvs. decimera "
"referensantalet) till vyns stödobjekt, ``view->obj``. Denna funktion MÅSTE "
"anropas när bufferten inte längre används, annars kan referensläckor uppstå."

#: ../../c-api/buffer.rst:464
msgid ""
"It is an error to call this function on a buffer that was not obtained via "
":c:func:`PyObject_GetBuffer`."
msgstr ""
"Det är ett fel att anropa denna funktion på en buffert som inte erhölls via "
":c:func:`PyObject_GetBuffer`."

#: ../../c-api/buffer.rst:470
msgid ""
"Return the implied :c:data:`~Py_buffer.itemsize` from "
":c:data:`~Py_buffer.format`. On error, raise an exception and return -1."
msgstr ""

#: ../../c-api/buffer.rst:478
msgid ""
"Return ``1`` if the memory defined by the *view* is C-style (*order* is "
"``'C'``) or Fortran-style (*order* is ``'F'``) :term:`contiguous` or either "
"one (*order* is ``'A'``).  Return ``0`` otherwise.  This function always "
"succeeds."
msgstr ""
"Returnerar ``1`` om minnet som definieras av *vyn* är C-stil (*ordning* är "
"``'C'``) eller Fortran-stil (*ordning* är ``'F'``) :term:`contiguous` eller "
"endera (*ordning* är ``'A'``).  Returnerar ``0`` annars.  Denna funktion "
"lyckas alltid."

#: ../../c-api/buffer.rst:485
msgid ""
"Get the memory area pointed to by the *indices* inside the given *view*. "
"*indices* must point to an array of ``view->ndim`` indices."
msgstr ""
"Hämta minnesområdet som pekas ut av *indices* i den givna *view*. *indices* "
"måste peka på en array av ``view->ndim`` index."

#: ../../c-api/buffer.rst:491
msgid ""
"Copy contiguous *len* bytes from *buf* to *view*. *fort* can be ``'C'`` or "
"``'F'`` (for C-style or Fortran-style ordering). ``0`` is returned on "
"success, ``-1`` on error."
msgstr ""
"Kopiera sammanhängande *len* byte från *buf* till *view*. *fort* kan vara "
"``'C'`` eller ``'F'`` (för C-stil eller Fortran-stil ordning). ``0`` "
"returneras vid framgång, ``-1`` vid fel."

#: ../../c-api/buffer.rst:498
msgid ""
"Copy *len* bytes from *src* to its contiguous representation in *buf*. "
"*order* can be ``'C'`` or ``'F'`` or ``'A'`` (for C-style or Fortran-style "
"ordering or either one). ``0`` is returned on success, ``-1`` on error."
msgstr ""
"Kopiera *len* bytes från *src* till dess sammanhängande representation i "
"*buf*. *order* kan vara ``'C'`` eller ``'F'`` eller ``'A'`` (för C-stil "
"eller Fortran-stil eller endera). ``0`` returneras vid framgång, ``-1`` vid "
"fel."

#: ../../c-api/buffer.rst:502
msgid "This function fails if *len* != *src->len*."
msgstr "Denna funktion misslyckas om *len* != *src->len*."

#: ../../c-api/buffer.rst:507
msgid ""
"Fill the *strides* array with byte-strides of a :term:`contiguous` (C-style "
"if *order* is ``'C'`` or Fortran-style if *order* is ``'F'``) array of the "
"given shape with the given number of bytes per element."
msgstr ""
"Fyll *strides*-arrayen med byte-strides av en :term:`kontiguous` (C-style om"
" *order* är ``'C'`` eller Fortran-style om *order* är ``'F'``) array av den "
"givna formen med det givna antalet bytes per element."

#: ../../c-api/buffer.rst:514
msgid ""
"Handle buffer requests for an exporter that wants to expose *buf* of size "
"*len* with writability set according to *readonly*. *buf* is interpreted as "
"a sequence of unsigned bytes."
msgstr ""
"Hantera buffertförfrågningar för en exportör som vill exponera *buf* av "
"storlek *len* med skrivbarhet inställd enligt *readonly*. *buf* tolkas som "
"en sekvens av osignerade bytes."

#: ../../c-api/buffer.rst:518
msgid ""
"The *flags* argument indicates the request type. This function always fills "
"in *view* as specified by flags, unless *buf* has been designated as read-"
"only and :c:macro:`PyBUF_WRITABLE` is set in *flags*."
msgstr ""
"Argumentet *flags* anger typen av begäran. Den här funktionen fyller alltid "
"i *view* enligt flaggorna, såvida inte *buf* har angetts som skrivskyddad "
"och :c:macro:`PyBUF_WRITABLE` har angetts i *flags*."

#: ../../c-api/buffer.rst:522
msgid ""
"On success, set ``view->obj`` to a new reference to *exporter* and return 0."
" Otherwise, raise :c:data:`PyExc_BufferError`, set ``view->obj`` to ``NULL``"
" and return ``-1``;"
msgstr ""

#: ../../c-api/buffer.rst:526
msgid ""
"If this function is used as part of a :ref:`getbufferproc <buffer-structs>`,"
" *exporter* MUST be set to the exporting object and *flags* must be passed "
"unmodified. Otherwise, *exporter* MUST be ``NULL``."
msgstr ""
"Om denna funktion används som en del av en :ref:`getbufferproc <buffer-"
"structs>`, MÅSTE *exporter* sättas till det exporterande objektet och "
"*flags* måste skickas oförändrat. Annars MÅSTE *exporter* vara ``NULL``."
