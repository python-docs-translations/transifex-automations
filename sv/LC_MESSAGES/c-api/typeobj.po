# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2026, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Daniel Nylander <po@danielnylander.se>, 2025
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-15 15:06+0000\n"
"PO-Revision-Date: 2025-09-15 01:03+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../c-api/typeobj.rst:6
msgid "Type Object Structures"
msgstr "Typobjektstrukturer"

#: ../../c-api/typeobj.rst:8
msgid ""
"Perhaps one of the most important structures of the Python object system is "
"the structure that defines a new type: the :c:type:`PyTypeObject` "
"structure.  Type objects can be handled using any of the ``PyObject_*`` or "
"``PyType_*`` functions, but do not offer much that's interesting to most "
"Python applications. These objects are fundamental to how objects behave, so "
"they are very important to the interpreter itself and to any extension "
"module that implements new types."
msgstr ""
"En av de kanske viktigaste strukturerna i Pythons objektsystem är den "
"struktur som definierar en ny typ: :c:type:`PyTypeObject`-strukturen.  "
"Typobjekt kan hanteras med hjälp av någon av funktionerna ``PyObject_*`` "
"eller ``PyType_*``, men erbjuder inte mycket som är intressant för de flesta "
"Python-applikationer. Dessa objekt är grundläggande för hur objekt beter "
"sig, så de är mycket viktiga för själva tolken och för alla tilläggsmoduler "
"som implementerar nya typer."

#: ../../c-api/typeobj.rst:16
msgid ""
"Type objects are fairly large compared to most of the standard types. The "
"reason for the size is that each type object stores a large number of "
"values, mostly C function pointers, each of which implements a small part of "
"the type's functionality.  The fields of the type object are examined in "
"detail in this section.  The fields will be described in the order in which "
"they occur in the structure."
msgstr ""
"Typobjekt är ganska stora jämfört med de flesta standardtyperna. Anledningen "
"till storleken är att varje typobjekt lagrar ett stort antal värden, "
"mestadels C-funktionspekare, som var och en implementerar en liten del av "
"typens funktionalitet.  Fälten i typobjektet granskas i detalj i detta "
"avsnitt.  Fälten kommer att beskrivas i den ordning de förekommer i "
"strukturen."

#: ../../c-api/typeobj.rst:23
msgid ""
"In addition to the following quick reference, the :ref:`typedef-examples` "
"section provides at-a-glance insight into the meaning and use of :c:type:"
"`PyTypeObject`."
msgstr ""
"Förutom följande snabbreferens ger avsnittet :ref:`typedef-examples` en "
"snabb inblick i betydelsen och användningen av :c:type:`PyTypeObject`."

#: ../../c-api/typeobj.rst:29
msgid "Quick Reference"
msgstr "Snabbreferens"

#: ../../c-api/typeobj.rst:34
msgid "\"tp slots\""
msgstr "\"tp slots\""

#: ../../c-api/typeobj.rst:40
msgid "PyTypeObject Slot [#slots]_"
msgstr "PyTypeObject Slot [#slots]_"

#: ../../c-api/typeobj.rst:40 ../../c-api/typeobj.rst:201
msgid ":ref:`Type <slot-typedefs-table>`"
msgstr ":ref:`Typ <slot-typedefs-table>`"

#: ../../c-api/typeobj.rst:40
msgid "special methods/attrs"
msgstr "speciella metoder/attribut"

#: ../../c-api/typeobj.rst:40
msgid "Info [#cols]_"
msgstr "Info [#cols]_ _ Info"

#: ../../c-api/typeobj.rst:42
msgid "O"
msgstr "O"

#: ../../c-api/typeobj.rst:42
msgid "T"
msgstr "T"

#: ../../c-api/typeobj.rst:42
msgid "D"
msgstr "D"

#: ../../c-api/typeobj.rst:42
msgid "I"
msgstr "I"

#: ../../c-api/typeobj.rst:44
msgid "<R> :c:member:`~PyTypeObject.tp_name`"
msgstr "<R>:c:member:`~PyTypeObject.tp_name`"

#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:44
#: ../../c-api/typeobj.rst:86
msgid "const char *"
msgstr "konst char *"

#: ../../c-api/typeobj.rst:44
msgid "__name__"
msgstr "__name__"

#: ../../c-api/typeobj.rst:44 ../../c-api/typeobj.rst:46
#: ../../c-api/typeobj.rst:48 ../../c-api/typeobj.rst:50
#: ../../c-api/typeobj.rst:52 ../../c-api/typeobj.rst:62
#: ../../c-api/typeobj.rst:70 ../../c-api/typeobj.rst:72
#: ../../c-api/typeobj.rst:74 ../../c-api/typeobj.rst:76
#: ../../c-api/typeobj.rst:79 ../../c-api/typeobj.rst:84
#: ../../c-api/typeobj.rst:86 ../../c-api/typeobj.rst:88
#: ../../c-api/typeobj.rst:90 ../../c-api/typeobj.rst:92
#: ../../c-api/typeobj.rst:99 ../../c-api/typeobj.rst:101
#: ../../c-api/typeobj.rst:103 ../../c-api/typeobj.rst:105
#: ../../c-api/typeobj.rst:107 ../../c-api/typeobj.rst:109
#: ../../c-api/typeobj.rst:111 ../../c-api/typeobj.rst:115
#: ../../c-api/typeobj.rst:117 ../../c-api/typeobj.rst:120
#: ../../c-api/typeobj.rst:122 ../../c-api/typeobj.rst:124
#: ../../c-api/typeobj.rst:126 ../../c-api/typeobj.rst:128
#: ../../c-api/typeobj.rst:130 ../../c-api/typeobj.rst:146
msgid "X"
msgstr "X"

#: ../../c-api/typeobj.rst:46
msgid ":c:member:`~PyTypeObject.tp_basicsize`"
msgstr ":c:member:`~PyTypeObject.tp_basicsize`"

#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:46
#: ../../c-api/typeobj.rst:48 ../../c-api/typeobj.rst:52
#: ../../c-api/typeobj.rst:99 ../../c-api/typeobj.rst:120
#: ../../c-api/typeobj.rst:417
msgid ":c:type:`Py_ssize_t`"
msgstr ":c:type:`Py_ssize_t`"

#: ../../c-api/typeobj.rst:48
msgid ":c:member:`~PyTypeObject.tp_itemsize`"
msgstr ":c:member:`~PyTypeObject.tp_itemsize`"

#: ../../c-api/typeobj.rst:50
msgid ":c:member:`~PyTypeObject.tp_dealloc`"
msgstr ":c:member:`~PyTypeObject.tp_dealloc`"

#: ../../c-api/typeobj.rst:50 ../../c-api/typeobj.rst:142
#: ../../c-api/typeobj.rst:146 ../../c-api/typeobj.rst:347
msgid ":c:type:`destructor`"
msgstr ":c:type:`destruktor`"

#: ../../c-api/typeobj.rst:52
msgid ":c:member:`~PyTypeObject.tp_vectorcall_offset`"
msgstr ":c:member:`~PyTypeObject.tp_vectorcall_offset`"

#: ../../c-api/typeobj.rst:54
msgid "(:c:member:`~PyTypeObject.tp_getattr`)"
msgstr "(:c:member:`~PyTypeObject.tp_getattr`)"

#: ../../c-api/typeobj.rst:54 ../../c-api/typeobj.rst:371
msgid ":c:type:`getattrfunc`"
msgstr ":c:type:`getattrfunc`"

#: ../../c-api/typeobj.rst:54 ../../c-api/typeobj.rst:76
msgid "__getattribute__, __getattr__"
msgstr "__getattribut__, __getattr__"

#: ../../c-api/typeobj.rst:54 ../../c-api/typeobj.rst:57
#: ../../c-api/typeobj.rst:70 ../../c-api/typeobj.rst:76
#: ../../c-api/typeobj.rst:79 ../../c-api/typeobj.rst:88
#: ../../c-api/typeobj.rst:90 ../../c-api/typeobj.rst:92
msgid "G"
msgstr "G"

#: ../../c-api/typeobj.rst:57
msgid "(:c:member:`~PyTypeObject.tp_setattr`)"
msgstr "(:c:member:`~PyTypeObject.tp_setattr`)"

#: ../../c-api/typeobj.rst:57 ../../c-api/typeobj.rst:376
msgid ":c:type:`setattrfunc`"
msgstr ":c:type:`setattrfunc`"

#: ../../c-api/typeobj.rst:57 ../../c-api/typeobj.rst:79
msgid "__setattr__, __delattr__"
msgstr "__setattr__, __delattr__"

#: ../../c-api/typeobj.rst:60
msgid ":c:member:`~PyTypeObject.tp_as_async`"
msgstr ":c:member:`~PyTypeObject.tp_as_async`"

#: ../../c-api/typeobj.rst:60
msgid ":c:type:`PyAsyncMethods` *"
msgstr ":c:type:`PyAsyncMethods` *"

#: ../../c-api/typeobj.rst:60 ../../c-api/typeobj.rst:64
#: ../../c-api/typeobj.rst:66 ../../c-api/typeobj.rst:68
#: ../../c-api/typeobj.rst:82
msgid ":ref:`sub-slots`"
msgstr ":ref:`sub-slots`"

#: ../../c-api/typeobj.rst:60 ../../c-api/typeobj.rst:64
#: ../../c-api/typeobj.rst:66 ../../c-api/typeobj.rst:68
#: ../../c-api/typeobj.rst:82
msgid "%"
msgstr "%"

#: ../../c-api/typeobj.rst:62
msgid ":c:member:`~PyTypeObject.tp_repr`"
msgstr ":c:member:`~PyTypeObject.tp_repr`"

#: ../../c-api/typeobj.rst:62 ../../c-api/typeobj.rst:74
#: ../../c-api/typeobj.rst:369
msgid ":c:type:`reprfunc`"
msgstr ":c:type:`reprfunc`"

#: ../../c-api/typeobj.rst:62
msgid "__repr__"
msgstr "__repr__"

#: ../../c-api/typeobj.rst:64
msgid ":c:member:`~PyTypeObject.tp_as_number`"
msgstr ":c:member:`~PyTypeObject.tp_as_number`"

#: ../../c-api/typeobj.rst:64
msgid ":c:type:`PyNumberMethods` *"
msgstr ":c:type:`PyNumberMethods` *"

#: ../../c-api/typeobj.rst:66
msgid ":c:member:`~PyTypeObject.tp_as_sequence`"
msgstr ":c:member:`~PyTypeObject.tp_as_sequence`"

#: ../../c-api/typeobj.rst:66
msgid ":c:type:`PySequenceMethods` *"
msgstr ":c:type:`PySequenceMethods` *"

#: ../../c-api/typeobj.rst:68
msgid ":c:member:`~PyTypeObject.tp_as_mapping`"
msgstr ":c:member:`~PyTypeObject.tp_as_mapping`"

#: ../../c-api/typeobj.rst:68
msgid ":c:type:`PyMappingMethods` *"
msgstr ":c:type:`PyMappingMethods` *"

#: ../../c-api/typeobj.rst:70
msgid ":c:member:`~PyTypeObject.tp_hash`"
msgstr ":c:member:`~PyTypeObject.tp_hash`"

#: ../../c-api/typeobj.rst:70 ../../c-api/typeobj.rst:405
msgid ":c:type:`hashfunc`"
msgstr ":c:type:`hashfunc`"

#: ../../c-api/typeobj.rst:70
msgid "__hash__"
msgstr "__hash__"

#: ../../c-api/typeobj.rst:72
msgid ":c:member:`~PyTypeObject.tp_call`"
msgstr ":c:member:`~PyTypeObject.tp_call`"

#: ../../c-api/typeobj.rst:72 ../../c-api/typeobj.rst:237
#: ../../c-api/typeobj.rst:240 ../../c-api/typeobj.rst:441
msgid ":c:type:`ternaryfunc`"
msgstr ":c:type:`ternaryfunc`"

#: ../../c-api/typeobj.rst:72
msgid "__call__"
msgstr "__anropa__"

#: ../../c-api/typeobj.rst:74
msgid ":c:member:`~PyTypeObject.tp_str`"
msgstr ":c:member:`~PyTypeObject.tp_str`"

#: ../../c-api/typeobj.rst:74
msgid "__str__"
msgstr "__str__"

#: ../../c-api/typeobj.rst:76
msgid ":c:member:`~PyTypeObject.tp_getattro`"
msgstr ":c:member:`~PyTypeObject.tp_getattro`"

#: ../../c-api/typeobj.rst:76 ../../c-api/typeobj.rst:382
msgid ":c:type:`getattrofunc`"
msgstr ":c:type:`getattrofunc`"

#: ../../c-api/typeobj.rst:79
msgid ":c:member:`~PyTypeObject.tp_setattro`"
msgstr ":c:member:`~PyTypeObject.tp_setattro`"

#: ../../c-api/typeobj.rst:79 ../../c-api/typeobj.rst:387
msgid ":c:type:`setattrofunc`"
msgstr ":c:type:`setattrofunc`"

#: ../../c-api/typeobj.rst:82
msgid ":c:member:`~PyTypeObject.tp_as_buffer`"
msgstr ":c:member:`~PyTypeObject.tp_as_buffer`"

#: ../../c-api/typeobj.rst:82
msgid ":c:type:`PyBufferProcs` *"
msgstr ":c:type:`PyBufferProcs` *"

#: ../../c-api/typeobj.rst:84
msgid ":c:member:`~PyTypeObject.tp_flags`"
msgstr ":c:member:`~PyTypeObject.tp_flags`"

#: ../../c-api/typeobj.rst:84
msgid "unsigned long"
msgstr "unsigned long"

#: ../../c-api/typeobj.rst:84 ../../c-api/typeobj.rst:99
#: ../../c-api/typeobj.rst:113 ../../c-api/typeobj.rst:120
#: ../../c-api/typeobj.rst:124 ../../c-api/typeobj.rst:126
#: ../../c-api/typeobj.rst:128
msgid "?"
msgstr "?"

#: ../../c-api/typeobj.rst:86
msgid ":c:member:`~PyTypeObject.tp_doc`"
msgstr ":c:member:`~PyTypeObject.tp_doc`"

#: ../../c-api/typeobj.rst:86
msgid "__doc__"
msgstr "__doc__"

#: ../../c-api/typeobj.rst:88
msgid ":c:member:`~PyTypeObject.tp_traverse`"
msgstr ":c:member:`~PyTypeObject.tp_traverse`"

#: ../../c-api/typeobj.rst:88 ../../c-api/typeobj.rst:351
msgid ":c:type:`traverseproc`"
msgstr ":c:type:`traverseproc`"

#: ../../c-api/typeobj.rst:90
msgid ":c:member:`~PyTypeObject.tp_clear`"
msgstr ":c:member:`~PyTypeObject.tp_clear`"

#: ../../c-api/typeobj.rst:90 ../../c-api/typeobj.rst:130
#: ../../c-api/typeobj.rst:248 ../../c-api/typeobj.rst:430
msgid ":c:type:`inquiry`"
msgstr ":c:type:`förfrågan`"

#: ../../c-api/typeobj.rst:92
msgid ":c:member:`~PyTypeObject.tp_richcompare`"
msgstr ":c:member:`~PyTypeObject.tp_richcompare`"

#: ../../c-api/typeobj.rst:92 ../../c-api/typeobj.rst:407
msgid ":c:type:`richcmpfunc`"
msgstr ":c:type:`richcmpfunc`"

#: ../../c-api/typeobj.rst:92
msgid "__lt__, __le__, __eq__, __ne__, __gt__, __ge__"
msgstr "__lt__, __le__, __eq__, __ne__, __gt__, __ge__"

#: ../../c-api/typeobj.rst:99
msgid "(:c:member:`~PyTypeObject.tp_weaklistoffset`)"
msgstr "(:c:member:`~PyTypeObject.tp_weaklistoffset`)"

#: ../../c-api/typeobj.rst:101
msgid ":c:member:`~PyTypeObject.tp_iter`"
msgstr ":c:member:`~PyTypeObject.tp_iter`"

#: ../../c-api/typeobj.rst:101 ../../c-api/typeobj.rst:413
msgid ":c:type:`getiterfunc`"
msgstr ":c:type:`getiterfunc`"

#: ../../c-api/typeobj.rst:101
msgid "__iter__"
msgstr "__iter__"

#: ../../c-api/typeobj.rst:103
msgid ":c:member:`~PyTypeObject.tp_iternext`"
msgstr ":c:member:`~PyTypeObject.tp_iternext`"

#: ../../c-api/typeobj.rst:103 ../../c-api/typeobj.rst:415
msgid ":c:type:`iternextfunc`"
msgstr ":c:type:`iternextfunc`"

#: ../../c-api/typeobj.rst:103
msgid "__next__"
msgstr "nästa"

#: ../../c-api/typeobj.rst:105
msgid ":c:member:`~PyTypeObject.tp_methods`"
msgstr ":c:member:`~PyTypeObject.tp_methods`"

#: ../../c-api/typeobj.rst:105
msgid ":c:type:`PyMethodDef` []"
msgstr ":c:type:`PyMethodDef` []"

#: ../../c-api/typeobj.rst:107
msgid ":c:member:`~PyTypeObject.tp_members`"
msgstr ":c:member:`~PyTypeObject.tp_members`"

#: ../../c-api/typeobj.rst:107
msgid ":c:type:`PyMemberDef` []"
msgstr ":c:type:`PyMemberDef` []"

#: ../../c-api/typeobj.rst:109
msgid ":c:member:`~PyTypeObject.tp_getset`"
msgstr ":c:member:`~PyTypeObject.tp_getset`"

#: ../../c-api/typeobj.rst:109
msgid ":c:type:`PyGetSetDef` []"
msgstr ":c:type:`PyGetSetDef` []"

#: ../../c-api/typeobj.rst:111
msgid ":c:member:`~PyTypeObject.tp_base`"
msgstr ":c:member:`~PyTypeObject.tp_base`"

#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:111
msgid ":c:type:`PyTypeObject` *"
msgstr ":c:type:`PyTypeObject` *"

#: ../../c-api/typeobj.rst:111
msgid "__base__"
msgstr "__bas"

#: ../../c-api/typeobj.rst:113
msgid ":c:member:`~PyTypeObject.tp_dict`"
msgstr ":c:member:`~PyTypeObject.tp_dict`"

#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:113
#: ../../c-api/typeobj.rst:132 ../../c-api/typeobj.rst:134
#: ../../c-api/typeobj.rst:136 ../../c-api/typeobj.rst:140
#: ../../c-api/typeobj.rst:342 ../../c-api/typeobj.rst:347
#: ../../c-api/typeobj.rst:357 ../../c-api/typeobj.rst:369
#: ../../c-api/typeobj.rst:371 ../../c-api/typeobj.rst:382
#: ../../c-api/typeobj.rst:393 ../../c-api/typeobj.rst:405
#: ../../c-api/typeobj.rst:407 ../../c-api/typeobj.rst:413
#: ../../c-api/typeobj.rst:415 ../../c-api/typeobj.rst:417
#: ../../c-api/typeobj.rst:430 ../../c-api/typeobj.rst:432
#: ../../c-api/typeobj.rst:436 ../../c-api/typeobj.rst:441
#: ../../c-api/typeobj.rst:447
msgid ":c:type:`PyObject` *"
msgstr ":c:type:`PyObject` *"

#: ../../c-api/typeobj.rst:113
msgid "__dict__"
msgstr "__dict__"

#: ../../c-api/typeobj.rst:115
msgid ":c:member:`~PyTypeObject.tp_descr_get`"
msgstr ":c:member:`~PyTypeObject.tp_descr_get`"

#: ../../c-api/typeobj.rst:115 ../../c-api/typeobj.rst:393
msgid ":c:type:`descrgetfunc`"
msgstr ":c:type:`descrgetfunc`"

#: ../../c-api/typeobj.rst:115
msgid "__get__"
msgstr "__get__"

#: ../../c-api/typeobj.rst:117
msgid ":c:member:`~PyTypeObject.tp_descr_set`"
msgstr ":c:member:`~PyTypeObject.tp_descr_set`"

#: ../../c-api/typeobj.rst:117 ../../c-api/typeobj.rst:399
msgid ":c:type:`descrsetfunc`"
msgstr ":c:type:`descrsetfunc`"

#: ../../c-api/typeobj.rst:117
msgid "__set__, __delete__"
msgstr "__set__, __delete__"

#: ../../c-api/typeobj.rst:120
msgid "(:c:member:`~PyTypeObject.tp_dictoffset`)"
msgstr "(:c:member:`~PyTypeObject.tp_dictoffset`)"

#: ../../c-api/typeobj.rst:122
msgid ":c:member:`~PyTypeObject.tp_init`"
msgstr ":c:member:`~PyTypeObject.tp_init`"

#: ../../c-api/typeobj.rst:122 ../../c-api/typeobj.rst:363
msgid ":c:type:`initproc`"
msgstr ":c:type:`initproc`"

#: ../../c-api/typeobj.rst:122
msgid "__init__"
msgstr "__init__"

#: ../../c-api/typeobj.rst:124
msgid ":c:member:`~PyTypeObject.tp_alloc`"
msgstr ":c:member:`~PyTypeObject.tp_alloc`"

#: ../../c-api/typeobj.rst:124 ../../c-api/typeobj.rst:342
msgid ":c:type:`allocfunc`"
msgstr ":c:type:`allocfunc`"

#: ../../c-api/typeobj.rst:126
msgid ":c:member:`~PyTypeObject.tp_new`"
msgstr ":c:member:`~PyTypeObject.tp_new`"

#: ../../c-api/typeobj.rst:126 ../../c-api/typeobj.rst:357
msgid ":c:type:`newfunc`"
msgstr ":c:type:`newfunc`"

#: ../../c-api/typeobj.rst:126
msgid "__new__"
msgstr "__ny"

#: ../../c-api/typeobj.rst:128
msgid ":c:member:`~PyTypeObject.tp_free`"
msgstr ":c:member:`~PyTypeObject.tp_free`"

#: ../../c-api/typeobj.rst:128 ../../c-api/typeobj.rst:349
msgid ":c:type:`freefunc`"
msgstr ":c:type:`freefunc`"

#: ../../c-api/typeobj.rst:130
msgid ":c:member:`~PyTypeObject.tp_is_gc`"
msgstr ":c:member:`~PyTypeObject.tp_is_gc`"

#: ../../c-api/typeobj.rst:132
msgid "<:c:member:`~PyTypeObject.tp_bases`>"
msgstr "<:c:member:`~PyTypeObject.tp_bases`>"

#: ../../c-api/typeobj.rst:132
msgid "__bases__"
msgstr "baser"

#: ../../c-api/typeobj.rst:132 ../../c-api/typeobj.rst:134
msgid "~"
msgstr "~"

#: ../../c-api/typeobj.rst:134
msgid "<:c:member:`~PyTypeObject.tp_mro`>"
msgstr "<:c:member:`~PyTypeObject.tp_mro`>"

#: ../../c-api/typeobj.rst:134
msgid "__mro__"
msgstr "det är inte sant"

#: ../../c-api/typeobj.rst:136
msgid "[:c:member:`~PyTypeObject.tp_cache`]"
msgstr "[:c:member:`~PyTypeObject.tp_cache`]"

#: ../../c-api/typeobj.rst:138
msgid "[:c:member:`~PyTypeObject.tp_subclasses`]"
msgstr "[:c:member:`~PyTypeObject.tp_subclasses`]"

#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:138
#: ../../c-api/typeobj.rst:279 ../../c-api/typeobj.rst:349
msgid "void *"
msgstr "tomrum *"

#: ../../c-api/typeobj.rst:138
msgid "__subclasses__"
msgstr "__underklasser"

#: ../../c-api/typeobj.rst:140
msgid "[:c:member:`~PyTypeObject.tp_weaklist`]"
msgstr "[:c:member:`~PyTypeObject.tp_weaklist`]"

#: ../../c-api/typeobj.rst:142
msgid "(:c:member:`~PyTypeObject.tp_del`)"
msgstr "(:c:member:`~PyTypeObject.tp_del`)"

#: ../../c-api/typeobj.rst:144
msgid "[:c:member:`~PyTypeObject.tp_version_tag`]"
msgstr "[:c:member:`~PyTypeObject.tp_version_tag`]"

#: ../../c-api/typeobj.rst:144
msgid "unsigned int"
msgstr "unsigned int"

#: ../../c-api/typeobj.rst:146
msgid ":c:member:`~PyTypeObject.tp_finalize`"
msgstr ":c:member:`~PyTypeObject.tp_finalize`"

#: ../../c-api/typeobj.rst:146
msgid "__del__"
msgstr "__del__"

#: ../../c-api/typeobj.rst:148
msgid ":c:member:`~PyTypeObject.tp_vectorcall`"
msgstr ":c:member:`~PyTypeObject.tp_vectorcall`"

#: ../../c-api/typeobj.rst:148
msgid ":c:type:`vectorcallfunc`"
msgstr ":c:type:`vektorcallfunc`"

#: ../../c-api/typeobj.rst:150
msgid "[:c:member:`~PyTypeObject.tp_watched`]"
msgstr "[:c:member:`~PyTypeObject.tp_watched`]"

#: ../../c-api/typeobj.rst:150
msgid "unsigned char"
msgstr "unsigned char"

#: ../../c-api/typeobj.rst:155
msgid ""
"**()**: A slot name in parentheses indicates it is (effectively) deprecated."
msgstr ""
"**()**: Ett slotnamn inom parentes anger att det (i praktiken) är föråldrat."

#: ../../c-api/typeobj.rst:157
msgid ""
"**<>**: Names in angle brackets should be initially set to ``NULL`` and "
"treated as read-only."
msgstr ""
"**<>**: Namn inom hakparenteser bör initialt sättas till ``NULL`` och "
"behandlas som skrivskyddade."

#: ../../c-api/typeobj.rst:160
msgid "**[]**: Names in square brackets are for internal use only."
msgstr "**[]**: Namn inom hakparentes är endast för internt bruk."

#: ../../c-api/typeobj.rst:162
msgid ""
"**<R>** (as a prefix) means the field is required (must be non-``NULL``)."
msgstr ""
"**<R>** (som prefix) betyder att fältet är obligatoriskt (måste vara icke-"
"``NULL``)."

#: ../../c-api/typeobj.rst:164
msgid "Columns:"
msgstr "Kolumner:"

#: ../../c-api/typeobj.rst:166
msgid "**\"O\"**:  set on :c:data:`PyBaseObject_Type`"
msgstr "**\"O\"**: inställd på :c:data:`PyBaseObject_Type`"

#: ../../c-api/typeobj.rst:168
msgid "**\"T\"**:  set on :c:data:`PyType_Type`"
msgstr "**\"T\"**: inställd på :c:data:`PyType_Type`"

#: ../../c-api/typeobj.rst:170
msgid "**\"D\"**:  default (if slot is set to ``NULL``)"
msgstr "**\"D\"**: standard (om slot är inställd på ``NULL``)"

#: ../../c-api/typeobj.rst:172
msgid ""
"X - PyType_Ready sets this value if it is NULL\n"
"~ - PyType_Ready always sets this value (it should be NULL)\n"
"? - PyType_Ready may set this value depending on other slots\n"
"\n"
"Also see the inheritance column (\"I\")."
msgstr ""
"X - PyType_Ready ställer in detta värde om det är NULL\n"
"~ - PyType_Ready ställer alltid in detta värde (det ska vara NULL)\n"
"? - PyType_Ready kan ställa in detta värde beroende på andra slots\n"
"\n"
"Se även kolumnen för arv (\"I\")."

#: ../../c-api/typeobj.rst:180
msgid "**\"I\"**:  inheritance"
msgstr "**\"I\"**: arv"

#: ../../c-api/typeobj.rst:182
msgid ""
"X - type slot is inherited via *PyType_Ready* if defined with a *NULL* "
"value\n"
"% - the slots of the sub-struct are inherited individually\n"
"G - inherited, but only in combination with other slots; see the slot's "
"description\n"
"? - it's complicated; see the slot's description"
msgstr ""
"X - typplatsen ärvs via *PyType_Ready* om den definieras med ett *NULL*-"
"värde\n"
"% - understrukturens slots ärvs individuellt\n"
"G - ärvs, men endast i kombination med andra slots; se slotens beskrivning\n"
"? - det är komplicerat; se slotens beskrivning"

#: ../../c-api/typeobj.rst:189
msgid ""
"Note that some slots are effectively inherited through the normal attribute "
"lookup chain."
msgstr ""
"Observera att vissa slots faktiskt ärvs genom den normala "
"attributuppslagningskedjan."

#: ../../c-api/typeobj.rst:195
msgid "sub-slots"
msgstr "underluckor"

#: ../../c-api/typeobj.rst:201
msgid "Slot"
msgstr "Tidslucka"

#: ../../c-api/typeobj.rst:201
msgid "special methods"
msgstr "särskilda metoder"

#: ../../c-api/typeobj.rst:204
msgid ":c:member:`~PyAsyncMethods.am_await`"
msgstr ":c:member:`~PyAsyncMethods.am_await`"

#: ../../c-api/typeobj.rst:204 ../../c-api/typeobj.rst:206
#: ../../c-api/typeobj.rst:208 ../../c-api/typeobj.rst:242
#: ../../c-api/typeobj.rst:244 ../../c-api/typeobj.rst:246
#: ../../c-api/typeobj.rst:250 ../../c-api/typeobj.rst:277
#: ../../c-api/typeobj.rst:281 ../../c-api/typeobj.rst:291
#: ../../c-api/typeobj.rst:432
msgid ":c:type:`unaryfunc`"
msgstr ":c:type:`unaryfunc`"

#: ../../c-api/typeobj.rst:204
msgid "__await__"
msgstr "vänta.."

#: ../../c-api/typeobj.rst:206
msgid ":c:member:`~PyAsyncMethods.am_aiter`"
msgstr ":c:member:`~PyAsyncMethods.am_aiter`"

#: ../../c-api/typeobj.rst:206
msgid "__aiter__"
msgstr "__aiter__"

#: ../../c-api/typeobj.rst:208
msgid ":c:member:`~PyAsyncMethods.am_anext`"
msgstr ":c:member:`~PyAsyncMethods.am_anext`"

#: ../../c-api/typeobj.rst:208
msgid "__anext__"
msgstr "__anext__"

#: ../../c-api/typeobj.rst:210
msgid ":c:member:`~PyAsyncMethods.am_send`"
msgstr ":c:member:`~PyAsyncMethods.am_send`"

#: ../../c-api/typeobj.rst:210
msgid ":c:type:`sendfunc`"
msgstr ":c:type:`sendfunc`"

#: ../../c-api/typeobj.rst:214
msgid ":c:member:`~PyNumberMethods.nb_add`"
msgstr ":c:member:`~PyNumberMethods.nb_add`"

#: ../../c-api/typeobj.rst:214 ../../c-api/typeobj.rst:217
#: ../../c-api/typeobj.rst:219 ../../c-api/typeobj.rst:222
#: ../../c-api/typeobj.rst:224 ../../c-api/typeobj.rst:227
#: ../../c-api/typeobj.rst:229 ../../c-api/typeobj.rst:232
#: ../../c-api/typeobj.rst:234 ../../c-api/typeobj.rst:252
#: ../../c-api/typeobj.rst:255 ../../c-api/typeobj.rst:257
#: ../../c-api/typeobj.rst:260 ../../c-api/typeobj.rst:262
#: ../../c-api/typeobj.rst:265 ../../c-api/typeobj.rst:267
#: ../../c-api/typeobj.rst:270 ../../c-api/typeobj.rst:272
#: ../../c-api/typeobj.rst:275 ../../c-api/typeobj.rst:283
#: ../../c-api/typeobj.rst:285 ../../c-api/typeobj.rst:287
#: ../../c-api/typeobj.rst:289 ../../c-api/typeobj.rst:293
#: ../../c-api/typeobj.rst:296 ../../c-api/typeobj.rst:302
#: ../../c-api/typeobj.rst:311 ../../c-api/typeobj.rst:322
#: ../../c-api/typeobj.rst:436
msgid ":c:type:`binaryfunc`"
msgstr ":c:type:`binaryfunc`"

#: ../../c-api/typeobj.rst:214
msgid "__add__ __radd__"
msgstr "__add__ __radd__"

#: ../../c-api/typeobj.rst:217
msgid ":c:member:`~PyNumberMethods.nb_inplace_add`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_add`"

#: ../../c-api/typeobj.rst:217 ../../c-api/typeobj.rst:322
msgid "__iadd__"
msgstr "__iadd__"

#: ../../c-api/typeobj.rst:219
msgid ":c:member:`~PyNumberMethods.nb_subtract`"
msgstr ":c:member:`~PyNumberMethods.nb_subtract`"

#: ../../c-api/typeobj.rst:219
msgid "__sub__ __rsub__"
msgstr "__sub__ __rsub__"

#: ../../c-api/typeobj.rst:222
msgid ":c:member:`~PyNumberMethods.nb_inplace_subtract`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_subtract`"

#: ../../c-api/typeobj.rst:222
msgid "__isub__"
msgstr "__isub__"

#: ../../c-api/typeobj.rst:224
msgid ":c:member:`~PyNumberMethods.nb_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_multiply`"

#: ../../c-api/typeobj.rst:224
msgid "__mul__ __rmul__"
msgstr "__mul__ __rmul__"

#: ../../c-api/typeobj.rst:227
msgid ":c:member:`~PyNumberMethods.nb_inplace_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_multiply`"

#: ../../c-api/typeobj.rst:227 ../../c-api/typeobj.rst:324
msgid "__imul__"
msgstr "__imul__"

#: ../../c-api/typeobj.rst:229
msgid ":c:member:`~PyNumberMethods.nb_remainder`"
msgstr ":c:member:`~PyNumberMethods.nb_remainder`"

#: ../../c-api/typeobj.rst:229
msgid "__mod__ __rmod__"
msgstr "__mod__ __rmod__"

#: ../../c-api/typeobj.rst:232
msgid ":c:member:`~PyNumberMethods.nb_inplace_remainder`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_remainder`"

#: ../../c-api/typeobj.rst:232
msgid "__imod__"
msgstr "__imod__"

#: ../../c-api/typeobj.rst:234
msgid ":c:member:`~PyNumberMethods.nb_divmod`"
msgstr ":c:member:`~PyNumberMethods.nb_divmod`"

#: ../../c-api/typeobj.rst:234
msgid "__divmod__ __rdivmod__"
msgstr "__divmod__ __rdivmod__"

#: ../../c-api/typeobj.rst:237
msgid ":c:member:`~PyNumberMethods.nb_power`"
msgstr ":c:member:`~PyNumberMethods.nb_power`"

#: ../../c-api/typeobj.rst:237
msgid "__pow__ __rpow__"
msgstr "__pow__ __rpow__"

#: ../../c-api/typeobj.rst:240
msgid ":c:member:`~PyNumberMethods.nb_inplace_power`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_power`"

#: ../../c-api/typeobj.rst:240
msgid "__ipow__"
msgstr "__ipow__"

#: ../../c-api/typeobj.rst:242
msgid ":c:member:`~PyNumberMethods.nb_negative`"
msgstr ":c:member:`~PyNumberMethods.nb_negative`"

#: ../../c-api/typeobj.rst:242
msgid "__neg__"
msgstr "__neg__"

#: ../../c-api/typeobj.rst:244
msgid ":c:member:`~PyNumberMethods.nb_positive`"
msgstr ":c:member:`~PyNumberMethods.nb_positive`"

#: ../../c-api/typeobj.rst:244
msgid "__pos__"
msgstr "__pos__"

#: ../../c-api/typeobj.rst:246
msgid ":c:member:`~PyNumberMethods.nb_absolute`"
msgstr ":c:member:`~PyNumberMethods.nb_absolute`"

#: ../../c-api/typeobj.rst:246
msgid "__abs__"
msgstr "det är inte sant"

#: ../../c-api/typeobj.rst:248
msgid ":c:member:`~PyNumberMethods.nb_bool`"
msgstr ":c:member:`~PyNumberMethods.nb_bool`"

#: ../../c-api/typeobj.rst:248
msgid "__bool__"
msgstr "__bool"

#: ../../c-api/typeobj.rst:250
msgid ":c:member:`~PyNumberMethods.nb_invert`"
msgstr ":c:member:`~PyNumberMethods.nb_invert`"

#: ../../c-api/typeobj.rst:250
msgid "__invert__"
msgstr "__invertera__"

#: ../../c-api/typeobj.rst:252
msgid ":c:member:`~PyNumberMethods.nb_lshift`"
msgstr ":c:member:`~PyNumberMethods.nb_lshift`"

#: ../../c-api/typeobj.rst:252
msgid "__lshift__ __rlshift__"
msgstr "__lshift__ __rlshift__"

#: ../../c-api/typeobj.rst:255
msgid ":c:member:`~PyNumberMethods.nb_inplace_lshift`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_lshift`"

#: ../../c-api/typeobj.rst:255
msgid "__ilshift__"
msgstr "__ilshift__"

#: ../../c-api/typeobj.rst:257
msgid ":c:member:`~PyNumberMethods.nb_rshift`"
msgstr ":c:member:`~PyNumberMethods.nb_rshift`"

#: ../../c-api/typeobj.rst:257
msgid "__rshift__ __rrshift__"
msgstr "__rshift__ __rshift__ __rshift__"

#: ../../c-api/typeobj.rst:260
msgid ":c:member:`~PyNumberMethods.nb_inplace_rshift`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_rshift`"

#: ../../c-api/typeobj.rst:260
msgid "__irshift__"
msgstr "jag har inte tid"

#: ../../c-api/typeobj.rst:262
msgid ":c:member:`~PyNumberMethods.nb_and`"
msgstr ":c:member:`~PyNumberMethods.nb_and`"

#: ../../c-api/typeobj.rst:262
msgid "__and__ __rand__"
msgstr "__and__ __rand__"

#: ../../c-api/typeobj.rst:265
msgid ":c:member:`~PyNumberMethods.nb_inplace_and`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_and`"

#: ../../c-api/typeobj.rst:265
msgid "__iand__"
msgstr "__iand__"

#: ../../c-api/typeobj.rst:267
msgid ":c:member:`~PyNumberMethods.nb_xor`"
msgstr ":c:member:`~PyNumberMethods.nb_xor`"

#: ../../c-api/typeobj.rst:267
msgid "__xor__ __rxor__"
msgstr "__xor__ __rxor__"

#: ../../c-api/typeobj.rst:270
msgid ":c:member:`~PyNumberMethods.nb_inplace_xor`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_xor`"

#: ../../c-api/typeobj.rst:270
msgid "__ixor__"
msgstr "__ixor__"

#: ../../c-api/typeobj.rst:272
msgid ":c:member:`~PyNumberMethods.nb_or`"
msgstr ":c:member:`~PyNumberMethods.nb_or`"

#: ../../c-api/typeobj.rst:272
msgid "__or__ __ror__"
msgstr "__eller__ __ror__"

#: ../../c-api/typeobj.rst:275
msgid ":c:member:`~PyNumberMethods.nb_inplace_or`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_or`"

#: ../../c-api/typeobj.rst:275
msgid "__ior__"
msgstr "jag är inte här"

#: ../../c-api/typeobj.rst:277
msgid ":c:member:`~PyNumberMethods.nb_int`"
msgstr ":c:member:`~PyNumberMethods.nb_int`"

#: ../../c-api/typeobj.rst:277
msgid "__int__"
msgstr "__int__"

#: ../../c-api/typeobj.rst:279
msgid ":c:member:`~PyNumberMethods.nb_reserved`"
msgstr ":c:member:`~PyNumberMethods.nb_reserved`"

#: ../../c-api/typeobj.rst:281
msgid ":c:member:`~PyNumberMethods.nb_float`"
msgstr ":c:member:`~PyNumberMethods.nb_float`"

#: ../../c-api/typeobj.rst:281
msgid "__float__"
msgstr "__flödesvärde"

#: ../../c-api/typeobj.rst:283
msgid ":c:member:`~PyNumberMethods.nb_floor_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_floor_divide`"

#: ../../c-api/typeobj.rst:283
msgid "__floordiv__"
msgstr "__floordiv__"

#: ../../c-api/typeobj.rst:285
msgid ":c:member:`~PyNumberMethods.nb_inplace_floor_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_floor_divide`"

#: ../../c-api/typeobj.rst:285
msgid "__ifloordiv__"
msgstr "__ifloordiv__"

#: ../../c-api/typeobj.rst:287
msgid ":c:member:`~PyNumberMethods.nb_true_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_true_divide`"

#: ../../c-api/typeobj.rst:287
msgid "__truediv__"
msgstr "__truediv__"

#: ../../c-api/typeobj.rst:289
msgid ":c:member:`~PyNumberMethods.nb_inplace_true_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_true_divide`"

#: ../../c-api/typeobj.rst:289
msgid "__itruediv__"
msgstr "__itruediv__"

#: ../../c-api/typeobj.rst:291
msgid ":c:member:`~PyNumberMethods.nb_index`"
msgstr ":c:member:`~PyNumberMethods.nb_index`"

#: ../../c-api/typeobj.rst:291
msgid "__index__"
msgstr "__index__"

#: ../../c-api/typeobj.rst:293
msgid ":c:member:`~PyNumberMethods.nb_matrix_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_matrix_multiply`"

#: ../../c-api/typeobj.rst:293
msgid "__matmul__ __rmatmul__"
msgstr "__matmul__ __rmatmul__"

#: ../../c-api/typeobj.rst:296
msgid ":c:member:`~PyNumberMethods.nb_inplace_matrix_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_matrix_multiply`"

#: ../../c-api/typeobj.rst:296
msgid "__imatmul__"
msgstr "__imatmul__"

#: ../../c-api/typeobj.rst:300
msgid ":c:member:`~PyMappingMethods.mp_length`"
msgstr ":c:member:`~PyMappingMethods.mp_length`"

#: ../../c-api/typeobj.rst:300 ../../c-api/typeobj.rst:309
#: ../../c-api/typeobj.rst:417
msgid ":c:type:`lenfunc`"
msgstr ":c:type:`lenfunc`"

#: ../../c-api/typeobj.rst:300 ../../c-api/typeobj.rst:309
msgid "__len__"
msgstr "__len__"

#: ../../c-api/typeobj.rst:302
msgid ":c:member:`~PyMappingMethods.mp_subscript`"
msgstr ":c:member:`~PyMappingMethods.mp_subscript`"

#: ../../c-api/typeobj.rst:302 ../../c-api/typeobj.rst:315
msgid "__getitem__"
msgstr "__hämta objekt"

#: ../../c-api/typeobj.rst:304
msgid ":c:member:`~PyMappingMethods.mp_ass_subscript`"
msgstr ":c:member:`~PyMappingMethods.mp_ass_subscript`"

#: ../../c-api/typeobj.rst:304 ../../c-api/typeobj.rst:463
msgid ":c:type:`objobjargproc`"
msgstr ":c:type:`objobjargproc`"

#: ../../c-api/typeobj.rst:304
msgid "__setitem__, __delitem__"
msgstr "__sätt objekt__, __ta bort objekt"

#: ../../c-api/typeobj.rst:309
msgid ":c:member:`~PySequenceMethods.sq_length`"
msgstr ":c:member:`~PySequenceMethods.sq_length`"

#: ../../c-api/typeobj.rst:311
msgid ":c:member:`~PySequenceMethods.sq_concat`"
msgstr ":c:member:`~PySequenceMethods.sq_concat`"

#: ../../c-api/typeobj.rst:311
msgid "__add__"
msgstr "__tillägg__"

#: ../../c-api/typeobj.rst:313
msgid ":c:member:`~PySequenceMethods.sq_repeat`"
msgstr ":c:member:`~PySequenceMethods.sq_repeat`"

#: ../../c-api/typeobj.rst:313 ../../c-api/typeobj.rst:315
#: ../../c-api/typeobj.rst:324 ../../c-api/typeobj.rst:447
msgid ":c:type:`ssizeargfunc`"
msgstr ":c:type:`ssizeargfunc`"

#: ../../c-api/typeobj.rst:313
msgid "__mul__"
msgstr "__mul__"

#: ../../c-api/typeobj.rst:315
msgid ":c:member:`~PySequenceMethods.sq_item`"
msgstr ":c:member:`~PySequenceMethods.sq_item`"

#: ../../c-api/typeobj.rst:317
msgid ":c:member:`~PySequenceMethods.sq_ass_item`"
msgstr ":c:member:`~PySequenceMethods.sq_ass_item`"

#: ../../c-api/typeobj.rst:317 ../../c-api/typeobj.rst:452
msgid ":c:type:`ssizeobjargproc`"
msgstr ":c:type:`ssizeobjargproc`"

#: ../../c-api/typeobj.rst:317
msgid "__setitem__ __delitem__"
msgstr "__setitem__ __delitem__"

#: ../../c-api/typeobj.rst:320
msgid ":c:member:`~PySequenceMethods.sq_contains`"
msgstr ":c:member:`~PySequenceMethods.sq_contains`"

#: ../../c-api/typeobj.rst:320 ../../c-api/typeobj.rst:458
msgid ":c:type:`objobjproc`"
msgstr ":c:type:`objobjproc`"

#: ../../c-api/typeobj.rst:320
msgid "__contains__"
msgstr "innehåller"

#: ../../c-api/typeobj.rst:322
msgid ":c:member:`~PySequenceMethods.sq_inplace_concat`"
msgstr ":c:member:`~PySequenceMethods.sq_inplace_concat`"

#: ../../c-api/typeobj.rst:324
msgid ":c:member:`~PySequenceMethods.sq_inplace_repeat`"
msgstr ":c:member:`~PySequenceMethods.sq_inplace_repeat`"

#: ../../c-api/typeobj.rst:328
msgid ":c:member:`~PyBufferProcs.bf_getbuffer`"
msgstr ":c:member:`~PyBufferProcs.bf_getbuffer`"

#: ../../c-api/typeobj.rst:328
msgid ":c:func:`getbufferproc`"
msgstr ":c:func:`getbufferproc`"

#: ../../c-api/typeobj.rst:328
msgid "__buffer__"
msgstr "__buffer__"

#: ../../c-api/typeobj.rst:330
msgid ":c:member:`~PyBufferProcs.bf_releasebuffer`"
msgstr ":c:member:`~PyBufferProcs.bf_releasebuffer`"

#: ../../c-api/typeobj.rst:330
msgid ":c:func:`releasebufferproc`"
msgstr ":c:func:`releasebufferproc`"

#: ../../c-api/typeobj.rst:330
msgid "__release_\\ buffer\\__"
msgstr "buffert"

#: ../../c-api/typeobj.rst:337
msgid "slot typedefs"
msgstr "slot typdefinitioner"

#: ../../c-api/typeobj.rst:340
msgid "typedef"
msgstr "typdefinierad"

#: ../../c-api/typeobj.rst:340
msgid "Parameter Types"
msgstr "Parametertyper"

#: ../../c-api/typeobj.rst:340
msgid "Return Type"
msgstr "Typ av retur"

#: ../../c-api/typeobj.rst:347 ../../c-api/typeobj.rst:349
#: ../../c-api/typeobj.rst:425
msgid "void"
msgstr "void"

#: ../../c-api/typeobj.rst:0
msgid ":c:type:`visitproc`"
msgstr ":c:type:`visitproc`"

#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:351
#: ../../c-api/typeobj.rst:363 ../../c-api/typeobj.rst:376
#: ../../c-api/typeobj.rst:387 ../../c-api/typeobj.rst:399
#: ../../c-api/typeobj.rst:419 ../../c-api/typeobj.rst:430
#: ../../c-api/typeobj.rst:452 ../../c-api/typeobj.rst:458
#: ../../c-api/typeobj.rst:463
msgid "int"
msgstr "int"

#: ../../c-api/typeobj.rst:405
msgid "Py_hash_t"
msgstr "Py_hash_t"

#: ../../c-api/typeobj.rst:419
msgid ":c:type:`getbufferproc`"
msgstr ":c:type:`getbufferproc`"

#: ../../c-api/typeobj.rst:0
msgid ":c:type:`Py_buffer` *"
msgstr ":c:type:`Py_buffer` *"

#: ../../c-api/typeobj.rst:425
msgid ":c:type:`releasebufferproc`"
msgstr ":c:type:`releasebufferproc`"

#: ../../c-api/typeobj.rst:470
msgid "See :ref:`slot-typedefs` below for more detail."
msgstr "Se :ref:`slot-typedefs` nedan för mer information."

#: ../../c-api/typeobj.rst:474
msgid "PyTypeObject Definition"
msgstr "PyTypeObject Definition"

#: ../../c-api/typeobj.rst:476
msgid ""
"The structure definition for :c:type:`PyTypeObject` can be found in :file:"
"`Include/cpython/object.h`.  For convenience of reference, this repeats the "
"definition found there:"
msgstr ""
"Strukturdefinitionen för :c:type:`PyTypeObject` finns i :file:`Include/"
"cpython/object.h`.  För att underlätta referensen upprepar detta den "
"definition som finns där:"

#: ../../c-api/typeobj.rst:482
msgid ""
"typedef struct _typeobject {\n"
"    PyObject_VAR_HEAD\n"
"    const char *tp_name; /* For printing, in format \"<module>.<name>\" */\n"
"    Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */\n"
"\n"
"    /* Methods to implement standard operations */\n"
"\n"
"    destructor tp_dealloc;\n"
"    Py_ssize_t tp_vectorcall_offset;\n"
"    getattrfunc tp_getattr;\n"
"    setattrfunc tp_setattr;\n"
"    PyAsyncMethods *tp_as_async; /* formerly known as tp_compare (Python 2)\n"
"                                    or tp_reserved (Python 3) */\n"
"    reprfunc tp_repr;\n"
"\n"
"    /* Method suites for standard classes */\n"
"\n"
"    PyNumberMethods *tp_as_number;\n"
"    PySequenceMethods *tp_as_sequence;\n"
"    PyMappingMethods *tp_as_mapping;\n"
"\n"
"    /* More standard operations (here for binary compatibility) */\n"
"\n"
"    hashfunc tp_hash;\n"
"    ternaryfunc tp_call;\n"
"    reprfunc tp_str;\n"
"    getattrofunc tp_getattro;\n"
"    setattrofunc tp_setattro;\n"
"\n"
"    /* Functions to access object as input/output buffer */\n"
"    PyBufferProcs *tp_as_buffer;\n"
"\n"
"    /* Flags to define presence of optional/expanded features */\n"
"    unsigned long tp_flags;\n"
"\n"
"    const char *tp_doc; /* Documentation string */\n"
"\n"
"    /* Assigned meaning in release 2.0 */\n"
"    /* call function for all accessible objects */\n"
"    traverseproc tp_traverse;\n"
"\n"
"    /* delete references to contained objects */\n"
"    inquiry tp_clear;\n"
"\n"
"    /* Assigned meaning in release 2.1 */\n"
"    /* rich comparisons */\n"
"    richcmpfunc tp_richcompare;\n"
"\n"
"    /* weak reference enabler */\n"
"    Py_ssize_t tp_weaklistoffset;\n"
"\n"
"    /* Iterators */\n"
"    getiterfunc tp_iter;\n"
"    iternextfunc tp_iternext;\n"
"\n"
"    /* Attribute descriptor and subclassing stuff */\n"
"    struct PyMethodDef *tp_methods;\n"
"    struct PyMemberDef *tp_members;\n"
"    struct PyGetSetDef *tp_getset;\n"
"    // Strong reference on a heap type, borrowed reference on a static type\n"
"    struct _typeobject *tp_base;\n"
"    PyObject *tp_dict;\n"
"    descrgetfunc tp_descr_get;\n"
"    descrsetfunc tp_descr_set;\n"
"    Py_ssize_t tp_dictoffset;\n"
"    initproc tp_init;\n"
"    allocfunc tp_alloc;\n"
"    newfunc tp_new;\n"
"    freefunc tp_free; /* Low-level free-memory routine */\n"
"    inquiry tp_is_gc; /* For PyObject_IS_GC */\n"
"    PyObject *tp_bases;\n"
"    PyObject *tp_mro; /* method resolution order */\n"
"    PyObject *tp_cache;\n"
"    PyObject *tp_subclasses;\n"
"    PyObject *tp_weaklist;\n"
"    destructor tp_del;\n"
"\n"
"    /* Type attribute cache version tag. Added in version 2.6 */\n"
"    unsigned int tp_version_tag;\n"
"\n"
"    destructor tp_finalize;\n"
"    vectorcallfunc tp_vectorcall;\n"
"\n"
"    /* bitset of which type-watchers care about this type */\n"
"    unsigned char tp_watched;\n"
"} PyTypeObject;\n"
msgstr ""

#: ../../c-api/typeobj.rst:486
msgid "PyObject Slots"
msgstr "PyObject-spelautomater"

#: ../../c-api/typeobj.rst:488
msgid ""
"The type object structure extends the :c:type:`PyVarObject` structure. The :"
"c:member:`~PyVarObject.ob_size` field is used for dynamic types (created by :"
"c:func:`!type_new`, usually called from a class statement). Note that :c:"
"data:`PyType_Type` (the metatype) initializes :c:member:`~PyTypeObject."
"tp_itemsize`, which means that its instances (i.e. type objects) *must* have "
"the :c:member:`~PyVarObject.ob_size` field."
msgstr ""
"Typobjektstrukturen utökar :c:type:`PyVarObject`-strukturen. Fältet :c:"
"member:`~PyVarObject.ob_size` används för dynamiska typer (skapade av :c:"
"func:`!type_new`, som vanligtvis anropas från en class statement). Observera "
"att :c:data:`PyType_Type` (metatypen) initialiserar :c:member:`~PyTypeObject."
"tp_itemsize`, vilket innebär att dess instanser (dvs. typobjekt) *måste* ha "
"fältet :c:member:`~PyVarObject.ob_size`."

#: ../../c-api/typeobj.rst:497
msgid ""
"This is the type object's reference count, initialized to ``1`` by the "
"``PyObject_HEAD_INIT`` macro.  Note that for :ref:`statically allocated type "
"objects <static-types>`, the type's instances (objects whose :c:member:"
"`~PyObject.ob_type` points back to the type) do *not* count as references.  "
"But for :ref:`dynamically allocated type objects <heap-types>`, the "
"instances *do* count as references."
msgstr ""

#: ../../c-api/typeobj.rst:504 ../../c-api/typeobj.rst:527
#: ../../c-api/typeobj.rst:544 ../../c-api/typeobj.rst:588
#: ../../c-api/typeobj.rst:666 ../../c-api/typeobj.rst:744
#: ../../c-api/typeobj.rst:785 ../../c-api/typeobj.rst:804
#: ../../c-api/typeobj.rst:823 ../../c-api/typeobj.rst:841
#: ../../c-api/typeobj.rst:867 ../../c-api/typeobj.rst:884
#: ../../c-api/typeobj.rst:896 ../../c-api/typeobj.rst:908
#: ../../c-api/typeobj.rst:943 ../../c-api/typeobj.rst:967
#: ../../c-api/typeobj.rst:989 ../../c-api/typeobj.rst:1012
#: ../../c-api/typeobj.rst:1040 ../../c-api/typeobj.rst:1059
#: ../../c-api/typeobj.rst:1075 ../../c-api/typeobj.rst:1114
#: ../../c-api/typeobj.rst:1125 ../../c-api/typeobj.rst:1135
#: ../../c-api/typeobj.rst:1145 ../../c-api/typeobj.rst:1159
#: ../../c-api/typeobj.rst:1177 ../../c-api/typeobj.rst:1200
#: ../../c-api/typeobj.rst:1218 ../../c-api/typeobj.rst:1231
#: ../../c-api/typeobj.rst:1253 ../../c-api/typeobj.rst:1300
#: ../../c-api/typeobj.rst:1326 ../../c-api/typeobj.rst:1345
#: ../../c-api/typeobj.rst:1375 ../../c-api/typeobj.rst:1397
#: ../../c-api/typeobj.rst:1425 ../../c-api/typeobj.rst:1517
#: ../../c-api/typeobj.rst:1593 ../../c-api/typeobj.rst:1656
#: ../../c-api/typeobj.rst:1692 ../../c-api/typeobj.rst:1719
#: ../../c-api/typeobj.rst:1744 ../../c-api/typeobj.rst:1759
#: ../../c-api/typeobj.rst:1776 ../../c-api/typeobj.rst:1792
#: ../../c-api/typeobj.rst:1824 ../../c-api/typeobj.rst:1856
#: ../../c-api/typeobj.rst:1884 ../../c-api/typeobj.rst:1904
#: ../../c-api/typeobj.rst:1933 ../../c-api/typeobj.rst:1979
#: ../../c-api/typeobj.rst:1998 ../../c-api/typeobj.rst:2041
#: ../../c-api/typeobj.rst:2065 ../../c-api/typeobj.rst:2099
#: ../../c-api/typeobj.rst:2129 ../../c-api/typeobj.rst:2142
#: ../../c-api/typeobj.rst:2152 ../../c-api/typeobj.rst:2169
#: ../../c-api/typeobj.rst:2186 ../../c-api/typeobj.rst:2202
#: ../../c-api/typeobj.rst:2239 ../../c-api/typeobj.rst:2262
msgid "**Inheritance:**"
msgstr "**Arv:**"

#: ../../c-api/typeobj.rst:506 ../../c-api/typeobj.rst:546
#: ../../c-api/typeobj.rst:590
msgid "This field is not inherited by subtypes."
msgstr "Detta fält ärvs inte av subtyper."

#: ../../c-api/typeobj.rst:511
msgid ""
"This is the type's type, in other words its metatype.  It is initialized by "
"the argument to the ``PyObject_HEAD_INIT`` macro, and its value should "
"normally be ``&PyType_Type``.  However, for dynamically loadable extension "
"modules that must be usable on Windows (at least), the compiler complains "
"that this is not a valid initializer.  Therefore, the convention is to pass "
"``NULL`` to the ``PyObject_HEAD_INIT`` macro and to initialize this field "
"explicitly at the start of the module's initialization function, before "
"doing anything else.  This is typically done like this::"
msgstr ""
"Detta är typens typ, med andra ord dess metatyp.  Den initialiseras av "
"argumentet till makrot ``PyObject_HEAD_INIT``, och dess värde bör normalt "
"vara ``&PyType_Type``.  Men för dynamiskt laddningsbara tilläggsmoduler som "
"måste kunna användas på Windows (åtminstone), klagar kompilatorn på att "
"detta inte är en giltig initierare.  Därför är konventionen att skicka "
"``NULL`` till makrot ``PyObject_HEAD_INIT`` och att initiera detta fält "
"explicit i början av modulens initialiseringsfunktion, innan något annat "
"görs.  Detta görs typiskt så här::"

#: ../../c-api/typeobj.rst:520
msgid "Foo_Type.ob_type = &PyType_Type;"
msgstr "Foo_Type.ob_type = &PyType_Type;"

#: ../../c-api/typeobj.rst:522
msgid ""
"This should be done before any instances of the type are created. :c:func:"
"`PyType_Ready` checks if :c:member:`~PyObject.ob_type` is ``NULL``, and if "
"so, initializes it to the :c:member:`~PyObject.ob_type` field of the base "
"class. :c:func:`PyType_Ready` will not change this field if it is non-zero."
msgstr ""
"Detta bör göras innan några instanser av typen skapas. :c:func:"
"`PyType_Ready` kontrollerar om :c:member:`~PyObject.ob_type` är ``NULL``, "
"och initialiserar det i så fall till fältet :c:member:`~PyObject.ob_type` i "
"basklassen. :c:func:`PyType_Ready` ändrar inte detta fält om det är icke-"
"noll."

#: ../../c-api/typeobj.rst:529 ../../c-api/typeobj.rst:746
#: ../../c-api/typeobj.rst:869 ../../c-api/typeobj.rst:969
#: ../../c-api/typeobj.rst:991 ../../c-api/typeobj.rst:1721
#: ../../c-api/typeobj.rst:1746 ../../c-api/typeobj.rst:1886
#: ../../c-api/typeobj.rst:1906 ../../c-api/typeobj.rst:1981
#: ../../c-api/typeobj.rst:2101 ../../c-api/typeobj.rst:2241
msgid "This field is inherited by subtypes."
msgstr "Detta fält ärvs av subtyperna."

#: ../../c-api/typeobj.rst:533
msgid "PyVarObject Slots"
msgstr "PyVarObject platser"

#: ../../c-api/typeobj.rst:537
msgid ""
"For :ref:`statically allocated type objects <static-types>`, this should be "
"initialized to zero. For :ref:`dynamically allocated type objects <heap-"
"types>`, this field has a special internal meaning."
msgstr ""
"För :ref:``statiskt allokerade typobjekt <static-types>`, bör detta "
"initialiseras till noll. För :ref:``dynamiskt allokerade typobjekt <heap-"
"types>`, har detta fält en speciell intern betydelse."

#: ../../c-api/typeobj.rst:541
msgid ""
"This field should be accessed using the :c:func:`Py_SIZE()` and :c:func:"
"`Py_SET_SIZE()` macros."
msgstr ""

#: ../../c-api/typeobj.rst:550
msgid "PyTypeObject Slots"
msgstr "PyTypeObject platser"

#: ../../c-api/typeobj.rst:552
msgid ""
"Each slot has a section describing inheritance.  If :c:func:`PyType_Ready` "
"may set a value when the field is set to ``NULL`` then there will also be a "
"\"Default\" section.  (Note that many fields set on :c:data:"
"`PyBaseObject_Type` and :c:data:`PyType_Type` effectively act as defaults.)"
msgstr ""
"Varje slot har ett avsnitt som beskriver nedärvning.  Om :c:func:"
"`PyType_Ready` kan sätta ett värde när fältet är satt till ``NULL`` så "
"kommer det också att finnas en \"Default\" sektion.  (Observera att många "
"fält som anges i :c:data:`PyBaseObject_Type` och :c:data:`PyType_Type` "
"fungerar som standardvärden)"

#: ../../c-api/typeobj.rst:559
msgid ""
"Pointer to a NUL-terminated string containing the name of the type. For "
"types that are accessible as module globals, the string should be the full "
"module name, followed by a dot, followed by the type name; for built-in "
"types, it should be just the type name.  If the module is a submodule of a "
"package, the full package name is part of the full module name.  For "
"example, a type named :class:`!T` defined in module :mod:`!M` in subpackage :"
"mod:`!Q` in package :mod:`!P` should have the :c:member:`~PyTypeObject."
"tp_name` initializer ``\"P.Q.M.T\"``."
msgstr ""
"Pekare till en NUL-avslutad sträng som innehåller typens namn. För typer som "
"är tillgängliga som modulglobaler ska strängen vara det fullständiga "
"modulnamnet, följt av en punkt, följt av typnamnet; för inbyggda typer ska "
"det bara vara typnamnet.  Om modulen är en undermodul till ett paket ingår "
"det fullständiga paketnamnet i det fullständiga modulnamnet.  Till exempel, "
"en typ med namnet :class:`!T` definierad i modul :mod:`!M` i underpaket :mod:"
"`!Q` i paket :mod:`!P` bör ha :c:member:`~PyTypeObject.tp_name` "
"initialiseraren ``\"P.Q.M.T\"``."

#: ../../c-api/typeobj.rst:567
msgid ""
"For :ref:`dynamically allocated type objects <heap-types>`, this should just "
"be the type name, and the module name explicitly stored in the type dict as "
"the value for key ``'__module__'``."
msgstr ""
"För :ref:``dynamiskt allokerade typobjekt <heap-types>`` bör detta bara vara "
"typnamnet och modulnamnet som uttryckligen lagras i typdikten som värde för "
"nyckeln ``'__module__'``."

#: ../../c-api/typeobj.rst:572
msgid ""
"For :ref:`statically allocated type objects <static-types>`, the *tp_name* "
"field should contain a dot. Everything before the last dot is made "
"accessible as the :attr:`~type.__module__` attribute, and everything after "
"the last dot is made accessible as the :attr:`~type.__name__` attribute."
msgstr ""
"För :ref:``statiskt allokerade typobjekt <static-types>`` ska fältet "
"*tp_name* innehålla en punkt. Allt före den sista punkten görs tillgängligt "
"som attributet :attr:`~type.__module__`, och allt efter den sista punkten "
"görs tillgängligt som attributet :attr:`~type.__name__`."

#: ../../c-api/typeobj.rst:578
msgid ""
"If no dot is present, the entire :c:member:`~PyTypeObject.tp_name` field is "
"made accessible as the :attr:`~type.__name__` attribute, and the :attr:"
"`~type.__module__` attribute is undefined (unless explicitly set in the "
"dictionary, as explained above).  This means your type will be impossible to "
"pickle.  Additionally, it will not be listed in module documentations "
"created with pydoc."
msgstr ""
"Om ingen punkt finns, görs hela fältet :c:member:`~PyTypeObject.tp_name` "
"tillgängligt som attributet :attr:`~type.__name__`, och attributet :attr:"
"`~type.__module__` är odefinierat (om det inte uttryckligen har angetts i "
"ordlistan, enligt vad som förklaras ovan).  Detta innebär att din typ inte "
"kommer att kunna plockas.  Dessutom kommer den inte att listas i "
"moduldokumentationer som skapats med pydoc."

#: ../../c-api/typeobj.rst:584
msgid ""
"This field must not be ``NULL``.  It is the only required field in :c:func:"
"`PyTypeObject` (other than potentially :c:member:`~PyTypeObject."
"tp_itemsize`)."
msgstr ""
"Detta fält får inte vara ``NULL``.  Det är det enda obligatoriska fältet i :"
"c:func:`PyTypeObject` (förutom eventuellt :c:member:`~PyTypeObject."
"tp_itemsize`)."

#: ../../c-api/typeobj.rst:596
msgid ""
"These fields allow calculating the size in bytes of instances of the type."
msgstr ""
"Dessa fält gör det möjligt att beräkna storleken i bytes för instanser av "
"typen."

#: ../../c-api/typeobj.rst:598
msgid ""
"There are two kinds of types: types with fixed-length instances have a zero :"
"c:member:`!tp_itemsize` field, types with variable-length instances have a "
"non-zero :c:member:`!tp_itemsize` field.  For a type with fixed-length "
"instances, all instances have the same size, given in :c:member:`!"
"tp_basicsize`. (Exceptions to this rule can be made using :c:func:"
"`PyUnstable_Object_GC_NewWithExtraData`.)"
msgstr ""
"Det finns två typer av typer: typer med instanser med fast längd har fältet :"
"c:member:`!tp_itemsize` som är noll, medan typer med instanser med variabel "
"längd har fältet :c:member:`!tp_itemsize` som inte är noll.  För en typ med "
"instanser med fast längd har alla instanser samma storlek, angiven i :c:"
"member:`!tp_basicsize`. (Undantag från denna regel kan göras med hjälp av :c:"
"func:`PyUnstable_Object_GC_NewWithExtraData`)"

#: ../../c-api/typeobj.rst:605
msgid ""
"For a type with variable-length instances, the instances must have an :c:"
"member:`~PyVarObject.ob_size` field, and the instance size is :c:member:`!"
"tp_basicsize` plus N times :c:member:`!tp_itemsize`, where N is the "
"\"length\" of the object."
msgstr ""
"För en typ med instanser med variabel längd måste instanserna ha ett fält :c:"
"member:`~PyVarObject.ob_size`, och instansstorleken är :c:member:`!"
"tp_basicsize` plus N gånger :c:member:`!tp_itemsize`, där N är objektets "
"\"längd\"."

#: ../../c-api/typeobj.rst:610
msgid ""
"Functions like :c:func:`PyObject_NewVar` will take the value of N as an "
"argument, and store in the instance's :c:member:`~PyVarObject.ob_size` "
"field. Note that the :c:member:`~PyVarObject.ob_size` field may later be "
"used for other purposes. For example, :py:type:`int` instances use the bits "
"of :c:member:`~PyVarObject.ob_size` in an implementation-defined way; the "
"underlying storage and its size should be accessed using :c:func:"
"`PyLong_Export`."
msgstr ""
"Funktioner som :c:func:`PyObject_NewVar` tar värdet av N som ett argument "
"och lagrar det i instansens :c:member:`~PyVarObject.ob_size`-fält. Observera "
"att fältet :c:member:`~PyVarObject.ob_size` senare kan användas för andra "
"ändamål. Exempelvis använder instanser av :py:type:`int` bitarna i :c:member:"
"`~PyVarObject.ob_size` på ett implementationsdefinierat sätt; den "
"underliggande lagringen och dess storlek bör nås med hjälp av :c:func:"
"`PyLong_Export`."

#: ../../c-api/typeobj.rst:620
msgid ""
"The :c:member:`~PyVarObject.ob_size` field should be accessed using the :c:"
"func:`Py_SIZE()` and :c:func:`Py_SET_SIZE()` macros."
msgstr ""
"Fältet :c:member:`~PyVarObject.ob_size` bör nås med hjälp av makrona :c:func:"
"`Py_SIZE()` och :c:func:`Py_SET_SIZE()`."

#: ../../c-api/typeobj.rst:623
msgid ""
"Also, the presence of an :c:member:`~PyVarObject.ob_size` field in the "
"instance layout doesn't mean that the instance structure is variable-length. "
"For example, the :py:type:`list` type has fixed-length instances, yet those "
"instances have a :c:member:`~PyVarObject.ob_size` field. (As with :py:type:"
"`int`, avoid reading lists' :c:member:`!ob_size` directly. Call :c:func:"
"`PyList_Size` instead.)"
msgstr ""
"Att det finns ett fält :c:member:`~PyVarObject.ob_size` i instanslayouten "
"betyder inte heller att instansstrukturen har variabel längd. Till exempel "
"har typen :py:type:`list` instanser med fast längd, men dessa instanser har "
"ändå ett fält :c:member:`~PyVarObject.ob_size`. (Precis som med :py:type:"
"`int` bör du undvika att läsa listors :c:member:`!ob_size` direkt. Anropa :c:"
"func:`PyList_Size` istället)"

#: ../../c-api/typeobj.rst:630
msgid ""
"The :c:member:`!tp_basicsize` includes size needed for data of the type's :c:"
"member:`~PyTypeObject.tp_base`, plus any extra data needed by each instance."
msgstr ""
"I :c:member:`!tp_basicsize` ingår den storlek som behövs för data i typens :"
"c:member:`~PyTypeObject.tp_base`, plus eventuella extra data som behövs för "
"varje instans."

#: ../../c-api/typeobj.rst:634
msgid ""
"The  correct way to set :c:member:`!tp_basicsize` is to use the ``sizeof`` "
"operator on the struct used to declare the instance layout. This struct must "
"include the struct used to declare the base type. In other words, :c:member:"
"`!tp_basicsize` must be greater than or equal to the base's :c:member:`!"
"tp_basicsize`."
msgstr ""
"Det korrekta sättet att ange :c:member:`!tp_basicsize` är att använda "
"operatorn ``sizeof`` på den struct som används för att deklarera "
"instanslayouten. Denna struct måste inkludera den struct som används för att "
"deklarera bastypen. Med andra ord måste :c:member:`!tp_basicsize` vara "
"större än eller lika med basens :c:member:`!tp_basicsize`."

#: ../../c-api/typeobj.rst:640
msgid ""
"Since every type is a subtype of :py:type:`object`, this struct must "
"include :c:type:`PyObject` or :c:type:`PyVarObject` (depending on whether :c:"
"member:`~PyVarObject.ob_size` should be included). These are usually defined "
"by the macro :c:macro:`PyObject_HEAD` or :c:macro:`PyObject_VAR_HEAD`, "
"respectively."
msgstr ""
"Eftersom varje typ är en subtyp av :py:type:`object` måste denna struktur "
"innehålla :c:type:`PyObject` eller :c:type:`PyVarObject` (beroende på om :c:"
"member:`~PyVarObject.ob_size` ska ingå). Dessa definieras vanligtvis av "
"makrot :c:macro:`PyObject_HEAD` respektive :c:macro:`PyObject_VAR_HEAD`."

#: ../../c-api/typeobj.rst:646
msgid ""
"The basic size does not include the GC header size, as that header is not "
"part of :c:macro:`PyObject_HEAD`."
msgstr ""
"Grundstorleken inkluderar inte storleken på GC-huvudet, eftersom det huvudet "
"inte ingår i :c:macro:`PyObject_HEAD`."

#: ../../c-api/typeobj.rst:649
msgid ""
"For cases where struct used to declare the base type is unknown, see :c:"
"member:`PyType_Spec.basicsize` and :c:func:`PyType_FromMetaclass`."
msgstr ""
"För fall där struct som används för att deklarera bastypen är okänd, se :c:"
"member:`PyType_Spec.basicsize` och :c:func:`PyType_FromMetaclass`."

#: ../../c-api/typeobj.rst:652
msgid "Notes about alignment:"
msgstr "Anmärkningar om anpassning:"

#: ../../c-api/typeobj.rst:654
msgid ""
":c:member:`!tp_basicsize` must be a multiple of ``_Alignof(PyObject)``. When "
"using ``sizeof`` on a ``struct`` that includes :c:macro:`PyObject_HEAD`, as "
"recommended, the compiler ensures this. When not using a C ``struct``, or "
"when using compiler extensions like ``__attribute__((packed))``, it is up to "
"you."
msgstr ""
":c:member:`!tp_basicsize` måste vara en multipel av ``_Alignof(PyObject)``. "
"När du använder ``sizeof`` på en ``struct`` som innehåller :c:macro:"
"`PyObject_HEAD`, som rekommenderat, säkerställer kompilatorn detta. Om du "
"inte använder en C-struktur, eller om du använder kompilatortillägg som "
"``__attribute__((packed))``, är det upp till dig."

#: ../../c-api/typeobj.rst:659
msgid ""
"If the variable items require a particular alignment, :c:member:`!"
"tp_basicsize` and :c:member:`!tp_itemsize` must each be a multiple of that "
"alignment. For example, if a type's variable part stores a ``double``, it is "
"your responsibility that both fields are a multiple of ``_Alignof(double)``."
msgstr ""
"Om de variabla objekten kräver en viss inriktning måste :c:member:`!"
"tp_basicsize` och :c:member:`!tp_itemsize` var och en vara en multipel av "
"den inriktningen. Om t.ex. en variabeldel av en typ lagrar en ``double``, är "
"det ditt ansvar att båda fälten är en multipel av ``_Alignof(double)``."

#: ../../c-api/typeobj.rst:668
msgid ""
"These fields are inherited separately by subtypes. (That is, if the field is "
"set to zero, :c:func:`PyType_Ready` will copy the value from the base type, "
"indicating that the instances do not need additional storage.)"
msgstr ""
"Dessa fält ärvs separat av subtyperna. (Det vill säga, om fältet är satt "
"till noll kommer :c:func:`PyType_Ready` att kopiera värdet från bastypen, "
"vilket indikerar att instanserna inte behöver ytterligare lagring)"

#: ../../c-api/typeobj.rst:673
msgid ""
"If the base type has a non-zero :c:member:`~PyTypeObject.tp_itemsize`, it is "
"generally not safe to set :c:member:`~PyTypeObject.tp_itemsize` to a "
"different non-zero value in a subtype (though this depends on the "
"implementation of the base type)."
msgstr ""
"Om bastypen har ett icke-nollvärde för :c:member:`~PyTypeObject.tp_itemsize` "
"är det i allmänhet inte säkert att ange :c:member:`~PyTypeObject."
"tp_itemsize` till ett annat icke-nollvärde i en subtyp (detta beror dock på "
"implementeringen av bastypen)."

#: ../../c-api/typeobj.rst:682
msgid ""
"A pointer to the instance destructor function.  This function must be "
"defined unless the type guarantees that its instances will never be "
"deallocated (as is the case for the singletons ``None`` and ``Ellipsis``).  "
"The function signature is::"
msgstr ""

#: ../../c-api/typeobj.rst:686
msgid "void tp_dealloc(PyObject *self);"
msgstr "void tp_dealloc(PyObject *self);"

#: ../../c-api/typeobj.rst:688
msgid ""
"The destructor function is called by the :c:func:`Py_DECREF` and :c:func:"
"`Py_XDECREF` macros when the new reference count is zero.  At this point, "
"the instance is still in existence, but there are no references to it.  The "
"destructor function should free all references which the instance owns, free "
"all memory buffers owned by the instance (using the freeing function "
"corresponding to the allocation function used to allocate the buffer), and "
"call the type's :c:member:`~PyTypeObject.tp_free` function.  If the type is "
"not subtypable (doesn't have the :c:macro:`Py_TPFLAGS_BASETYPE` flag bit "
"set), it is permissible to call the object deallocator directly instead of "
"via :c:member:`~PyTypeObject.tp_free`.  The object deallocator should be the "
"one used to allocate the instance; this is normally :c:func:`PyObject_Del` "
"if the instance was allocated using :c:macro:`PyObject_New` or :c:macro:"
"`PyObject_NewVar`, or :c:func:`PyObject_GC_Del` if the instance was "
"allocated using :c:macro:`PyObject_GC_New` or :c:macro:`PyObject_GC_NewVar`."
msgstr ""

#: ../../c-api/typeobj.rst:703
msgid ""
"If the type supports garbage collection (has the :c:macro:"
"`Py_TPFLAGS_HAVE_GC` flag bit set), the destructor should call :c:func:"
"`PyObject_GC_UnTrack` before clearing any member fields."
msgstr ""

#: ../../c-api/typeobj.rst:707
msgid ""
"static void foo_dealloc(foo_object *self) {\n"
"    PyObject_GC_UnTrack(self);\n"
"    Py_CLEAR(self->ref);\n"
"    Py_TYPE(self)->tp_free((PyObject *)self);\n"
"}"
msgstr ""

#: ../../c-api/typeobj.rst:715
msgid ""
"Finally, if the type is heap allocated (:c:macro:`Py_TPFLAGS_HEAPTYPE`), the "
"deallocator should release the owned reference to its type object (via :c:"
"func:`Py_DECREF`)  after calling the type deallocator. In order to avoid "
"dangling pointers, the recommended way to achieve this is:"
msgstr ""

#: ../../c-api/typeobj.rst:721
msgid ""
"static void foo_dealloc(foo_object *self) {\n"
"    PyTypeObject *tp = Py_TYPE(self);\n"
"    // free references and buffers here\n"
"    tp->tp_free(self);\n"
"    Py_DECREF(tp);\n"
"}"
msgstr ""

#: ../../c-api/typeobj.rst:732
msgid ""
"In a garbage collected Python, :c:member:`!tp_dealloc` may be called from "
"any Python thread, not just the thread which created the object (if the "
"object becomes part of a refcount cycle, that cycle might be collected by a "
"garbage collection on any thread).  This is not a problem for Python API "
"calls, since the thread on which :c:member:`!tp_dealloc` is called will own "
"the Global Interpreter Lock (GIL).  However, if the object being destroyed "
"in turn destroys objects from some other C or C++ library, care should be "
"taken to ensure that destroying those objects on the thread which called :c:"
"member:`!tp_dealloc` will not violate any assumptions of the library."
msgstr ""

#: ../../c-api/typeobj.rst:751
msgid ""
"An optional offset to a per-instance function that implements calling the "
"object using the :ref:`vectorcall protocol <vectorcall>`, a more efficient "
"alternative of the simpler :c:member:`~PyTypeObject.tp_call`."
msgstr ""
"En valfri offset till en funktion per instans som implementerar anrop av "
"objektet med hjälp av :ref:`vectorcall-protokollet <vectorcall>`, ett "
"effektivare alternativ till den enklare :c:member:`~PyTypeObject.tp_call`."

#: ../../c-api/typeobj.rst:756
msgid ""
"This field is only used if the flag :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` is "
"set. If so, this must be a positive integer containing the offset in the "
"instance of a :c:type:`vectorcallfunc` pointer."
msgstr ""
"Detta fält används endast om flaggan :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` "
"är satt. Om så är fallet måste detta vara ett positivt heltal som innehåller "
"offset i instansen för en pekare av typen :c:type:`vectorcallfunc`."

#: ../../c-api/typeobj.rst:760
msgid ""
"The *vectorcallfunc* pointer may be ``NULL``, in which case the instance "
"behaves as if :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` was not set: calling the "
"instance falls back to :c:member:`~PyTypeObject.tp_call`."
msgstr ""
"Poängaren *vectorcallfunc* kan vara ``NULL``, i vilket fall instansen beter "
"sig som om :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` inte var inställd: anrop av "
"instansen faller tillbaka till :c:member:`~PyTypeObject.tp_call`."

#: ../../c-api/typeobj.rst:764
msgid ""
"Any class that sets ``Py_TPFLAGS_HAVE_VECTORCALL`` must also set :c:member:"
"`~PyTypeObject.tp_call` and make sure its behaviour is consistent with the "
"*vectorcallfunc* function. This can be done by setting *tp_call* to :c:func:"
"`PyVectorcall_Call`."
msgstr ""
"Alla klasser som ställer in ``Py_TPFLAGS_HAVE_VECTORCALL`` måste också "
"ställa in :c:member:`~PyTypeObject.tp_call` och se till att dess beteende är "
"förenligt med funktionen *vectorcallfunc*. Detta kan göras genom att ställa "
"in *tp_call* till :c:func:`PyVectorcall_Call`."

#: ../../c-api/typeobj.rst:771
msgid ""
"Before version 3.8, this slot was named ``tp_print``. In Python 2.x, it was "
"used for printing to a file. In Python 3.0 to 3.7, it was unused."
msgstr ""
"Före version 3.8 hette denna slot ``tp_print``. I Python 2.x användes den "
"för utskrift till en fil. I Python 3.0 till 3.7 var den oanvänd."

#: ../../c-api/typeobj.rst:777
msgid ""
"Before version 3.12, it was not recommended for :ref:`mutable heap types "
"<heap-types>` to implement the vectorcall protocol. When a user sets :attr:"
"`~object.__call__` in Python code, only *tp_call* is updated, likely making "
"it inconsistent with the vectorcall function. Since 3.12, setting "
"``__call__`` will disable vectorcall optimization by clearing the :c:macro:"
"`Py_TPFLAGS_HAVE_VECTORCALL` flag."
msgstr ""
"Före version 3.12 var det inte rekommenderat för :ref:`mutable heap types "
"<heap-types>` att implementera vectorcall-protokollet. När en användare "
"ställer in :attr:`~object.__call__` i Python-kod, uppdateras endast "
"*tp_call*, vilket sannolikt gör den inkonsekvent med vectorcall-funktionen. "
"Sedan 3.12 kommer inställningen ``__call__`` att inaktivera vectorcall-"
"optimering genom att rensa flaggan :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL`."

#: ../../c-api/typeobj.rst:787
msgid ""
"This field is always inherited. However, the :c:macro:"
"`Py_TPFLAGS_HAVE_VECTORCALL` flag is not always inherited. If it's not set, "
"then the subclass won't use :ref:`vectorcall <vectorcall>`, except when :c:"
"func:`PyVectorcall_Call` is explicitly called."
msgstr ""
"Detta fält är alltid ärftligt. Dock är :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` "
"flaggan inte alltid ärvd. Om den inte är satt, kommer subklassen inte att "
"använda :ref:`vectorcall <vectorcall>`, förutom när :c:func:"
"`PyVectorcall_Call` explicit anropas."

#: ../../c-api/typeobj.rst:798
msgid "An optional pointer to the get-attribute-string function."
msgstr "En valfri pekare till funktionen get-attribute-string."

#: ../../c-api/typeobj.rst:800
msgid ""
"This field is deprecated.  When it is defined, it should point to a function "
"that acts the same as the :c:member:`~PyTypeObject.tp_getattro` function, "
"but taking a C string instead of a Python string object to give the "
"attribute name."
msgstr ""
"Detta fält är föråldrat.  När det definieras bör det peka på en funktion som "
"fungerar på samma sätt som :c:member:`~PyTypeObject.tp_getattro`-funktionen, "
"men som tar en C-sträng istället för ett Python-strängobjekt för att ge "
"attributnamnet."

#: ../../c-api/typeobj.rst:806 ../../c-api/typeobj.rst:1014
msgid ""
"Group: :c:member:`~PyTypeObject.tp_getattr`, :c:member:`~PyTypeObject."
"tp_getattro`"
msgstr ""
"Grupp: :c:member:`~PyTypeObject.tp_getattr`, :c:member:`~PyTypeObject."
"tp_getattro`"

#: ../../c-api/typeobj.rst:808
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_getattro`: a subtype inherits both :c:member:`~PyTypeObject.tp_getattr` "
"and :c:member:`~PyTypeObject.tp_getattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_getattr` and :c:member:`~PyTypeObject."
"tp_getattro` are both ``NULL``."
msgstr ""
"Detta fält ärvs av subtyper tillsammans med :c:member:`~PyTypeObject."
"tp_getattro`: en subtyp ärver både :c:member:`~PyTypeObject.tp_getattr` och :"
"c:member:`~PyTypeObject.tp_getattro` från sin bastyp när subtypens :c:member:"
"`~PyTypeObject.tp_getattr` och :c:member:`~PyTypeObject.tp_getattro` båda är "
"``NULL``."

#: ../../c-api/typeobj.rst:817 ../../c-api/typeobj.rst:1029
msgid ""
"An optional pointer to the function for setting and deleting attributes."
msgstr ""
"En valfri pekare till funktionen för att ställa in och ta bort attribut."

#: ../../c-api/typeobj.rst:819
msgid ""
"This field is deprecated.  When it is defined, it should point to a function "
"that acts the same as the :c:member:`~PyTypeObject.tp_setattro` function, "
"but taking a C string instead of a Python string object to give the "
"attribute name."
msgstr ""
"Detta fält är föråldrat.  När det definieras bör det peka på en funktion som "
"fungerar på samma sätt som :c:member:`~PyTypeObject.tp_setattro`-funktionen, "
"men som tar en C-sträng istället för ett Python-strängobjekt för att ge "
"attributnamnet."

#: ../../c-api/typeobj.rst:825 ../../c-api/typeobj.rst:1042
msgid ""
"Group: :c:member:`~PyTypeObject.tp_setattr`, :c:member:`~PyTypeObject."
"tp_setattro`"
msgstr ""
"Grupp: :c:member:`~PyTypeObject.tp_setattr`, :c:member:`~PyTypeObject."
"tp_setattro`"

#: ../../c-api/typeobj.rst:827
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_setattro`: a subtype inherits both :c:member:`~PyTypeObject.tp_setattr` "
"and :c:member:`~PyTypeObject.tp_setattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_setattr` and :c:member:`~PyTypeObject."
"tp_setattro` are both ``NULL``."
msgstr ""
"Detta fält ärvs av subtyper tillsammans med :c:member:`~PyTypeObject."
"tp_setattro`: en subtyp ärver både :c:member:`~PyTypeObject.tp_setattr` och :"
"c:member:`~PyTypeObject.tp_setattro` från sin bastyp när subtypens :c:member:"
"`~PyTypeObject.tp_setattr` och :c:member:`~PyTypeObject.tp_setattro` båda är "
"``NULL``."

#: ../../c-api/typeobj.rst:834
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement :term:`awaitable` and :term:`asynchronous iterator` "
"protocols at the C-level.  See :ref:`async-structs` for details."
msgstr ""
"Pekare till en ytterligare struktur som innehåller fält som endast är "
"relevanta för objekt som implementerar protokollen :term:`awaitable` och :"
"term:`asynchronous iterator` på C-nivå.  Se :ref:`async-structs` för "
"detaljer."

#: ../../c-api/typeobj.rst:838
msgid "Formerly known as ``tp_compare`` and ``tp_reserved``."
msgstr "Tidigare känd som ``tp_compare`` och ``tp_reserved``."

#: ../../c-api/typeobj.rst:843
msgid ""
"The :c:member:`~PyTypeObject.tp_as_async` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"Fältet :c:member:`~PyTypeObject.tp_as_async` ärvs inte, men de ingående "
"fälten ärvs individuellt."

#: ../../c-api/typeobj.rst:853
msgid ""
"An optional pointer to a function that implements the built-in function :"
"func:`repr`."
msgstr ""
"En valfri pekare till en funktion som implementerar den inbyggda funktionen :"
"func:`repr`."

#: ../../c-api/typeobj.rst:856
msgid "The signature is the same as for :c:func:`PyObject_Repr`::"
msgstr "Signaturen är densamma som för :c:func:`PyObject_Repr`::"

#: ../../c-api/typeobj.rst:858
msgid "PyObject *tp_repr(PyObject *self);"
msgstr "PyObject *tp_repr(PyObject *self);"

#: ../../c-api/typeobj.rst:860
msgid ""
"The function must return a string or a Unicode object.  Ideally, this "
"function should return a string that, when passed to :func:`eval`, given a "
"suitable environment, returns an object with the same value.  If this is not "
"feasible, it should return a string starting with ``'<'`` and ending with "
"``'>'`` from which both the type and the value of the object can be deduced."
msgstr ""
"Funktionen måste returnera en sträng eller ett Unicode-objekt.  Helst ska "
"denna funktion returnera en sträng som, när den skickas till :func:`eval`, i "
"en lämplig miljö, returnerar ett objekt med samma värde.  Om detta inte är "
"möjligt, bör den returnera en sträng som börjar med ``'<'`` och slutar med "
"``'>'`` från vilken både typen och värdet på objektet kan härledas."

#: ../../c-api/typeobj.rst:871 ../../c-api/typeobj.rst:952
#: ../../c-api/typeobj.rst:993 ../../c-api/typeobj.rst:1020
#: ../../c-api/typeobj.rst:1048 ../../c-api/typeobj.rst:1089
#: ../../c-api/typeobj.rst:1665 ../../c-api/typeobj.rst:1699
#: ../../c-api/typeobj.rst:1828 ../../c-api/typeobj.rst:1861
#: ../../c-api/typeobj.rst:1940 ../../c-api/typeobj.rst:1983
#: ../../c-api/typeobj.rst:2003 ../../c-api/typeobj.rst:2047
#: ../../c-api/typeobj.rst:2070 ../../c-api/typeobj.rst:2103
msgid "**Default:**"
msgstr "**Förval:**"

#: ../../c-api/typeobj.rst:873
msgid ""
"When this field is not set, a string of the form ``<%s object at %p>`` is "
"returned, where ``%s`` is replaced by the type name, and ``%p`` by the "
"object's memory address."
msgstr ""
"Om detta fält inte är inställt returneras en sträng av formen ``<%s object "
"at %p>``, där ``%s`` ersätts av typnamnet och ``%p`` av objektets "
"minnesadress."

#: ../../c-api/typeobj.rst:880
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the number protocol.  These fields are documented "
"in :ref:`number-structs`."
msgstr ""
"Pekare till en ytterligare struktur som innehåller fält som endast är "
"relevanta för objekt som implementerar nummerprotokollet.  Dessa fält är "
"dokumenterade i :ref:`number-structs`."

#: ../../c-api/typeobj.rst:886
msgid ""
"The :c:member:`~PyTypeObject.tp_as_number` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"Fältet :c:member:`~PyTypeObject.tp_as_number` ärvs inte, men de ingående "
"fälten ärvs individuellt."

#: ../../c-api/typeobj.rst:892
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the sequence protocol.  These fields are documented "
"in :ref:`sequence-structs`."
msgstr ""
"Pekare till en ytterligare struktur som innehåller fält som endast är "
"relevanta för objekt som implementerar sekvensprotokollet.  Dessa fält är "
"dokumenterade i :ref:`sequence-structs`."

#: ../../c-api/typeobj.rst:898
msgid ""
"The :c:member:`~PyTypeObject.tp_as_sequence` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"Fältet :c:member:`~PyTypeObject.tp_as_sequence` ärvs inte, men de ingående "
"fälten ärvs individuellt."

#: ../../c-api/typeobj.rst:904
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the mapping protocol.  These fields are documented "
"in :ref:`mapping-structs`."
msgstr ""
"Pekare till en ytterligare struktur som innehåller fält som endast är "
"relevanta för objekt som implementerar mappningsprotokollet.  Dessa fält är "
"dokumenterade i :ref:`mapping-structs`."

#: ../../c-api/typeobj.rst:910
msgid ""
"The :c:member:`~PyTypeObject.tp_as_mapping` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"Fältet :c:member:`~PyTypeObject.tp_as_mapping` ärvs inte, men de ingående "
"fälten ärvs individuellt."

#: ../../c-api/typeobj.rst:920
msgid ""
"An optional pointer to a function that implements the built-in function :"
"func:`hash`."
msgstr ""
"En valfri pekare till en funktion som implementerar den inbyggda funktionen :"
"func:`hash`."

#: ../../c-api/typeobj.rst:923
msgid "The signature is the same as for :c:func:`PyObject_Hash`::"
msgstr "Signaturen är densamma som för :c:func:`PyObject_Hash`::"

#: ../../c-api/typeobj.rst:925
msgid "Py_hash_t tp_hash(PyObject *);"
msgstr "Py_hash_t tp_hash(PyObject *);"

#: ../../c-api/typeobj.rst:927
msgid ""
"The value ``-1`` should not be returned as a normal return value; when an "
"error occurs during the computation of the hash value, the function should "
"set an exception and return ``-1``."
msgstr ""
"Värdet ``-1`` ska inte returneras som ett normalt returvärde; när ett fel "
"inträffar under beräkningen av hashvärdet ska funktionen sätta ett undantag "
"och returnera ``-1``."

#: ../../c-api/typeobj.rst:931
msgid ""
"When this field is not set (*and* :c:member:`~PyTypeObject.tp_richcompare` "
"is not set), an attempt to take the hash of the object raises :exc:"
"`TypeError`. This is the same as setting it to :c:func:"
"`PyObject_HashNotImplemented`."
msgstr ""
"När detta fält inte är inställt (*och* :c:member:`~PyTypeObject."
"tp_richcompare` inte är inställt), kommer ett försök att ta objektets hash "
"att ge upphov till :exc:`TypeError`. Detta är samma sak som att sätta den "
"till :c:func:`PyObject_HashNotImplemented`."

#: ../../c-api/typeobj.rst:935
msgid ""
"This field can be set explicitly to :c:func:`PyObject_HashNotImplemented` to "
"block inheritance of the hash method from a parent type. This is interpreted "
"as the equivalent of ``__hash__ = None`` at the Python level, causing "
"``isinstance(o, collections.Hashable)`` to correctly return ``False``. Note "
"that the converse is also true - setting ``__hash__ = None`` on a class at "
"the Python level will result in the ``tp_hash`` slot being set to :c:func:"
"`PyObject_HashNotImplemented`."
msgstr ""
"Detta fält kan explicit sättas till :c:func:`PyObject_HashNotImplemented` "
"för att blockera arv av hash-metoden från en överordnad typ. Detta tolkas "
"som motsvarigheten till ``__hash__ = None`` på Python-nivå, vilket gör att "
"``isinstance(o, collections.Hashable)`` korrekt returnerar ``False``. "
"Observera att det omvända också är sant - att sätta ``__hash__ = None`` på "
"en klass på Python-nivå kommer att resultera i att ``tp_hash`` slot sätts "
"till :c:func:`PyObject_HashNotImplemented`."

#: ../../c-api/typeobj.rst:945 ../../c-api/typeobj.rst:1658
msgid ""
"Group: :c:member:`~PyTypeObject.tp_hash`, :c:member:`~PyTypeObject."
"tp_richcompare`"
msgstr ""
"Grupp: :c:member:`~PyTypeObject.tp_hash`, :c:member:`~PyTypeObject."
"tp_richcompare`"

#: ../../c-api/typeobj.rst:947
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_richcompare`: a subtype inherits both of :c:member:`~PyTypeObject."
"tp_richcompare` and :c:member:`~PyTypeObject.tp_hash`, when the subtype's :c:"
"member:`~PyTypeObject.tp_richcompare` and :c:member:`~PyTypeObject.tp_hash` "
"are both ``NULL``."
msgstr ""
"Detta fält ärvs av subtyper tillsammans med :c:member:`~PyTypeObject."
"tp_richcompare`: en subtyp ärver både :c:member:`~PyTypeObject."
"tp_richcompare` och :c:member:`~PyTypeObject.tp_hash`, när subtypens :c:"
"member:`~PyTypeObject.tp_richcompare` och :c:member:`~PyTypeObject.tp_hash` "
"båda är ``NULL``."

#: ../../c-api/typeobj.rst:954
msgid ":c:data:`PyBaseObject_Type` uses :c:func:`PyObject_GenericHash`."
msgstr ":c:data:`PyBaseObject_Type` använder :c:func:`PyObject_GenericHash`."

#: ../../c-api/typeobj.rst:961
msgid ""
"An optional pointer to a function that implements calling the object.  This "
"should be ``NULL`` if the object is not callable.  The signature is the same "
"as for :c:func:`PyObject_Call`::"
msgstr ""
"En valfri pekare till en funktion som implementerar anrop av objektet.  "
"Denna bör vara ``NULL`` om objektet inte är anropsbart.  Signaturen är "
"densamma som för :c:func:`PyObject_Call`::"

#: ../../c-api/typeobj.rst:965
msgid "PyObject *tp_call(PyObject *self, PyObject *args, PyObject *kwargs);"
msgstr "PyObject *tp_call(PyObject *self, PyObject *args, PyObject *kwargs);"

#: ../../c-api/typeobj.rst:976
msgid ""
"An optional pointer to a function that implements the built-in operation :"
"func:`str`.  (Note that :class:`str` is a type now, and :func:`str` calls "
"the constructor for that type.  This constructor calls :c:func:"
"`PyObject_Str` to do the actual work, and :c:func:`PyObject_Str` will call "
"this handler.)"
msgstr ""
"En valfri pekare till en funktion som implementerar den inbyggda "
"operationen :func:`str`.  (Observera att :class:`str` nu är en typ och att :"
"func:`str` anropar konstruktören för den typen.  Denna konstruktör anropar :"
"c:func:`PyObject_Str` för att göra det faktiska arbetet, och :c:func:"
"`PyObject_Str` kommer att anropa denna hanterare)"

#: ../../c-api/typeobj.rst:981
msgid "The signature is the same as for :c:func:`PyObject_Str`::"
msgstr "Signaturen är densamma som för :c:func:`PyObject_Str`::"

#: ../../c-api/typeobj.rst:983
msgid "PyObject *tp_str(PyObject *self);"
msgstr "PyObject *tp_str(PyObject *self);"

#: ../../c-api/typeobj.rst:985
msgid ""
"The function must return a string or a Unicode object.  It should be a "
"\"friendly\" string representation of the object, as this is the "
"representation that will be used, among other things, by the :func:`print` "
"function."
msgstr ""
"Funktionen måste returnera en sträng eller ett Unicode-objekt.  Det bör vara "
"en \"vänlig\" strängrepresentation av objektet, eftersom det är den "
"representation som kommer att användas, bland annat, av funktionen :func:"
"`print`."

#: ../../c-api/typeobj.rst:995
msgid ""
"When this field is not set, :c:func:`PyObject_Repr` is called to return a "
"string representation."
msgstr ""
"När detta fält inte är inställt anropas :c:func:`PyObject_Repr` för att "
"returnera en strängrepresentation."

#: ../../c-api/typeobj.rst:1003
msgid "An optional pointer to the get-attribute function."
msgstr "En valfri pekare till funktionen get-attribute."

#: ../../c-api/typeobj.rst:1005
msgid "The signature is the same as for :c:func:`PyObject_GetAttr`::"
msgstr "Signaturen är densamma som för :c:func:`PyObject_GetAttr`::"

#: ../../c-api/typeobj.rst:1007
msgid "PyObject *tp_getattro(PyObject *self, PyObject *attr);"
msgstr "PyObject *tp_getattro(PyObject *self, PyObject *attr);"

#: ../../c-api/typeobj.rst:1009
msgid ""
"It is usually convenient to set this field to :c:func:"
"`PyObject_GenericGetAttr`, which implements the normal way of looking for "
"object attributes."
msgstr ""
"Det är oftast lämpligt att ställa in detta fält till :c:func:"
"`PyObject_GenericGetAttr`, som implementerar det normala sättet att leta "
"efter objektattribut."

#: ../../c-api/typeobj.rst:1016
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_getattr`: a subtype inherits both :c:member:`~PyTypeObject.tp_getattr` "
"and :c:member:`~PyTypeObject.tp_getattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_getattr` and :c:member:`~PyTypeObject."
"tp_getattro` are both ``NULL``."
msgstr ""
"Detta fält ärvs av subtyper tillsammans med :c:member:`~PyTypeObject."
"tp_getattr`: en subtyp ärver både :c:member:`~PyTypeObject.tp_getattr` och :"
"c:member:`~PyTypeObject.tp_getattro` från sin bastyp när subtypens :c:member:"
"`~PyTypeObject.tp_getattr` och :c:member:`~PyTypeObject.tp_getattro` båda är "
"``NULL``."

#: ../../c-api/typeobj.rst:1022
msgid ":c:data:`PyBaseObject_Type` uses :c:func:`PyObject_GenericGetAttr`."
msgstr ""
":c:data:`PyBaseObject_Type` använder :c:func:`PyObject_GenericGetAttr`."

#: ../../c-api/typeobj.rst:1031
msgid "The signature is the same as for :c:func:`PyObject_SetAttr`::"
msgstr "Signaturen är densamma som för :c:func:`PyObject_SetAttr`::"

#: ../../c-api/typeobj.rst:1033
msgid "int tp_setattro(PyObject *self, PyObject *attr, PyObject *value);"
msgstr "int tp_setattro(PyObject *self, PyObject *attr, PyObject *value);"

#: ../../c-api/typeobj.rst:1035
msgid ""
"In addition, setting *value* to ``NULL`` to delete an attribute must be "
"supported.  It is usually convenient to set this field to :c:func:"
"`PyObject_GenericSetAttr`, which implements the normal way of setting object "
"attributes."
msgstr ""
"Dessutom måste det finnas stöd för att sätta *value* till ``NULL`` för att "
"ta bort ett attribut.  Det är vanligtvis bekvämt att ställa in detta fält "
"till :c:func:`PyObject_GenericSetAttr`, som implementerar det normala sättet "
"att ställa in objektattribut."

#: ../../c-api/typeobj.rst:1044
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_setattr`: a subtype inherits both :c:member:`~PyTypeObject.tp_setattr` "
"and :c:member:`~PyTypeObject.tp_setattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_setattr` and :c:member:`~PyTypeObject."
"tp_setattro` are both ``NULL``."
msgstr ""
"Detta fält ärvs av subtyper tillsammans med :c:member:`~PyTypeObject."
"tp_setattr`: en subtyp ärver både :c:member:`~PyTypeObject.tp_setattr` och :"
"c:member:`~PyTypeObject.tp_setattro` från sin bastyp när subtypens :c:member:"
"`~PyTypeObject.tp_setattr` och :c:member:`~PyTypeObject.tp_setattro` båda är "
"``NULL``."

#: ../../c-api/typeobj.rst:1050
msgid ":c:data:`PyBaseObject_Type` uses :c:func:`PyObject_GenericSetAttr`."
msgstr ""
":c:data:`PyBaseObject_Type` använder :c:func:`PyObject_GenericSetAttr`."

#: ../../c-api/typeobj.rst:1055
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the buffer interface.  These fields are documented "
"in :ref:`buffer-structs`."
msgstr ""
"Pekare till en ytterligare struktur som innehåller fält som endast är "
"relevanta för objekt som implementerar buffertgränssnittet.  Dessa fält är "
"dokumenterade i :ref:`buffer-structs`."

#: ../../c-api/typeobj.rst:1061
msgid ""
"The :c:member:`~PyTypeObject.tp_as_buffer` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"Fältet :c:member:`~PyTypeObject.tp_as_buffer` ärvs inte, men de ingående "
"fälten ärvs individuellt."

#: ../../c-api/typeobj.rst:1067
msgid ""
"This field is a bit mask of various flags.  Some flags indicate variant "
"semantics for certain situations; others are used to indicate that certain "
"fields in the type object (or in the extension structures referenced via :c:"
"member:`~PyTypeObject.tp_as_number`, :c:member:`~PyTypeObject."
"tp_as_sequence`, :c:member:`~PyTypeObject.tp_as_mapping`, and :c:member:"
"`~PyTypeObject.tp_as_buffer`) that were historically not always present are "
"valid; if such a flag bit is clear, the type fields it guards must not be "
"accessed and must be considered to have a zero or ``NULL`` value instead."
msgstr ""
"Detta fält är en bitmask med olika flaggor.  Vissa flaggor anger varierande "
"semantik för vissa situationer; andra används för att ange att vissa fält i "
"typobjektet (eller i de tilläggsstrukturer som refereras via :c:member:"
"`~PyTypeObject.tp_as_number`, :c:member:`~PyTypeObject.tp_as_sequence`, :c:"
"member:`~PyTypeObject.tp_as_mapping`, och :c:member:`~PyTypeObject."
"tp_as_buffer`) som historiskt sett inte alltid funnits är giltiga; om en "
"sådan flaggbit är klar får de typfält som den skyddar inte nås och måste "
"anses ha värdet noll eller ``NULL`` istället."

#: ../../c-api/typeobj.rst:1077
msgid ""
"Inheritance of this field is complicated.  Most flag bits are inherited "
"individually, i.e. if the base type has a flag bit set, the subtype inherits "
"this flag bit.  The flag bits that pertain to extension structures are "
"strictly inherited if the extension structure is inherited, i.e. the base "
"type's value of the flag bit is copied into the subtype together with a "
"pointer to the extension structure.  The :c:macro:`Py_TPFLAGS_HAVE_GC` flag "
"bit is inherited together with the :c:member:`~PyTypeObject.tp_traverse` "
"and :c:member:`~PyTypeObject.tp_clear` fields, i.e. if the :c:macro:"
"`Py_TPFLAGS_HAVE_GC` flag bit is clear in the subtype and the :c:member:"
"`~PyTypeObject.tp_traverse` and :c:member:`~PyTypeObject.tp_clear` fields in "
"the subtype exist and have ``NULL`` values. .. XXX are most flag bits "
"*really* inherited individually?"
msgstr ""

#: ../../c-api/typeobj.rst:1091
msgid ""
":c:data:`PyBaseObject_Type` uses ``Py_TPFLAGS_DEFAULT | "
"Py_TPFLAGS_BASETYPE``."
msgstr ""
":c:data:`PyBaseObject_Type` använder ``Py_TPFLAGS_DEFAULT | "
"Py_TPFLAGS_BASETYPE``."

#: ../../c-api/typeobj.rst:1094
msgid "**Bit Masks:**"
msgstr "**Bitmasker:**"

#: ../../c-api/typeobj.rst:1098
msgid ""
"The following bit masks are currently defined; these can be ORed together "
"using the ``|`` operator to form the value of the :c:member:`~PyTypeObject."
"tp_flags` field.  The macro :c:func:`PyType_HasFeature` takes a type and a "
"flags value, *tp* and *f*, and checks whether ``tp->tp_flags & f`` is non-"
"zero."
msgstr ""
"Följande bitmasker är för närvarande definierade; dessa kan kombineras med "
"operatorn ``|`` för att bilda värdet i fältet :c:member:`~PyTypeObject."
"tp_flags`.  Makrot :c:func:`PyType_HasFeature` tar en typ och ett "
"flaggvärde, *tp* och *f*, och kontrollerar om ``tp->tp_flags & f`` är icke-"
"noll."

#: ../../c-api/typeobj.rst:1105
msgid ""
"This bit is set when the type object itself is allocated on the heap, for "
"example, types created dynamically using :c:func:`PyType_FromSpec`.  In this "
"case, the :c:member:`~PyObject.ob_type` field of its instances is considered "
"a reference to the type, and the type object is INCREF'ed when a new "
"instance is created, and DECREF'ed when an instance is destroyed (this does "
"not apply to instances of subtypes; only the type referenced by the "
"instance's ob_type gets INCREF'ed or DECREF'ed). Heap types should also :ref:"
"`support garbage collection <supporting-cycle-detection>` as they can form a "
"reference cycle with their own module object."
msgstr ""
"Denna bit är inställd när själva typobjektet allokeras på heapen, t.ex. "
"typer som skapas dynamiskt med :c:func:`PyType_FromSpec`.  I detta fall "
"betraktas fältet :c:member:`~PyObject.ob_type` i dess instanser som en "
"referens till typen, och typobjektet INCREF'ed när en ny instans skapas, och "
"DECREF'ed när en instans förstörs (detta gäller inte instanser av subtyper; "
"endast den typ som instansens ob_type refererar till INCREF'ed eller "
"DECREF'ed). Heap-typer bör också :ref:`stödja garbage collection <supporting-"
"cycle-detection>` eftersom de kan bilda en referenscykel med sitt eget "
"modulobjekt."

#: ../../c-api/typeobj.rst:1116 ../../c-api/typeobj.rst:1127
#: ../../c-api/typeobj.rst:1137 ../../c-api/typeobj.rst:1147
#: ../../c-api/typeobj.rst:1179
msgid "???"
msgstr "???"

#: ../../c-api/typeobj.rst:1121
msgid ""
"This bit is set when the type can be used as the base type of another type.  "
"If this bit is clear, the type cannot be subtyped (similar to a \"final\" "
"class in Java)."
msgstr ""
"Denna bit är satt när typen kan användas som bastyp för en annan typ.  Om "
"denna bit är klar kan typen inte subtypas (på samma sätt som en \"final\"-"
"klass i Java)."

#: ../../c-api/typeobj.rst:1132
msgid ""
"This bit is set when the type object has been fully initialized by :c:func:"
"`PyType_Ready`."
msgstr ""
"Denna bit är inställd när typobjektet har initialiserats fullständigt av :c:"
"func:`PyType_Ready`."

#: ../../c-api/typeobj.rst:1142
msgid ""
"This bit is set while :c:func:`PyType_Ready` is in the process of "
"initializing the type object."
msgstr ""
"Denna bit är inställd när :c:func:`PyType_Ready` håller på att initiera "
"typobjektet."

#: ../../c-api/typeobj.rst:1152
msgid ""
"This bit is set when the object supports garbage collection.  If this bit is "
"set, instances must be created using :c:macro:`PyObject_GC_New` and "
"destroyed using :c:func:`PyObject_GC_Del`.  More information in section :ref:"
"`supporting-cycle-detection`.  This bit also implies that the GC-related "
"fields :c:member:`~PyTypeObject.tp_traverse` and :c:member:`~PyTypeObject."
"tp_clear` are present in the type object."
msgstr ""

#: ../../c-api/typeobj.rst:1161 ../../c-api/typeobj.rst:1519
#: ../../c-api/typeobj.rst:1595
msgid ""
"Group: :c:macro:`Py_TPFLAGS_HAVE_GC`, :c:member:`~PyTypeObject."
"tp_traverse`, :c:member:`~PyTypeObject.tp_clear`"
msgstr ""
"Grupp: :c:makro:`Py_TPFLAGS_HAVE_GC`, :c:member:`~PyTypeObject."
"tp_traverse`, :c:member:`~PyTypeObject.tp_clear`"

#: ../../c-api/typeobj.rst:1163
msgid ""
"The :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is inherited together with the :c:"
"member:`~PyTypeObject.tp_traverse` and :c:member:`~PyTypeObject.tp_clear` "
"fields, i.e.  if the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is clear in the "
"subtype and the :c:member:`~PyTypeObject.tp_traverse` and :c:member:"
"`~PyTypeObject.tp_clear` fields in the subtype exist and have ``NULL`` "
"values."
msgstr ""
"Flaggbiten :c:macro:`Py_TPFLAGS_HAVE_GC` ärvs tillsammans med fälten :c:"
"member:`~PyTypeObject.tp_traverse` och :c:member:`~PyTypeObject.tp_clear`, "
"dvs.  om flaggbiten :c:macro:`Py_TPFLAGS_HAVE_GC` är klar i subtypen och "
"fälten :c:member:`~PyTypeObject.tp_traverse` och :c:member:`~PyTypeObject."
"tp_clear` i subtypen finns och har värdena ``NULL``."

#: ../../c-api/typeobj.rst:1173
msgid ""
"This is a bitmask of all the bits that pertain to the existence of certain "
"fields in the type object and its extension structures. Currently, it "
"includes the following bits: :c:macro:`Py_TPFLAGS_HAVE_STACKLESS_EXTENSION`."
msgstr ""
"Detta är en bitmask med alla de bitar som rör förekomsten av vissa fält i "
"typobjektet och dess tilläggsstrukturer. För närvarande innehåller den "
"följande bitar: :c:macro:`Py_TPFLAGS_HAVE_STACKLESS_EXTENSION`."

#: ../../c-api/typeobj.rst:1184
msgid "This bit indicates that objects behave like unbound methods."
msgstr "Denna bit indikerar att objekt beter sig som obundna metoder."

#: ../../c-api/typeobj.rst:1186
msgid "If this flag is set for ``type(meth)``, then:"
msgstr "Om denna flagga är inställd för ``typ(meth)``, då:"

#: ../../c-api/typeobj.rst:1188
msgid ""
"``meth.__get__(obj, cls)(*args, **kwds)`` (with ``obj`` not None) must be "
"equivalent to ``meth(obj, *args, **kwds)``."
msgstr ""
"``meth.__get__(obj, cls)(*args, **kwds)`` (med ``obj`` inte None) måste vara "
"likvärdig med ``meth(obj, *args, **kwds)``."

#: ../../c-api/typeobj.rst:1191
msgid ""
"``meth.__get__(None, cls)(*args, **kwds)`` must be equivalent to "
"``meth(*args, **kwds)``."
msgstr ""
"``meth.__get__(None, cls)(*args, **kwds)`` måste vara likvärdig med "
"``meth(*args, **kwds)``."

#: ../../c-api/typeobj.rst:1194
msgid ""
"This flag enables an optimization for typical method calls like ``obj."
"meth()``: it avoids creating a temporary \"bound method\" object for ``obj."
"meth``."
msgstr ""
"Denna flagga möjliggör en optimering för typiska metodanrop som ``obj."
"meth()``: den undviker att skapa ett tillfälligt \"bound method\"-objekt för "
"``obj.meth``."

#: ../../c-api/typeobj.rst:1202
msgid ""
"This flag is never inherited by types without the :c:macro:"
"`Py_TPFLAGS_IMMUTABLETYPE` flag set.  For extension types, it is inherited "
"whenever :c:member:`~PyTypeObject.tp_descr_get` is inherited."
msgstr ""
"Denna flagga ärvs aldrig av typer som inte har flaggan :c:macro:"
"`Py_TPFLAGS_IMMUTABLETYPE` inställd.  För tilläggstyper ärvs den närhelst :c:"
"member:`~PyTypeObject.tp_descr_get` ärvs."

#: ../../c-api/typeobj.rst:1208
msgid ""
"This bit indicates that instances of the class have a :attr:`~object."
"__dict__` attribute, and that the space for the dictionary is managed by the "
"VM."
msgstr ""
"Denna bit anger att instanser av klassen har attributet :attr:`~object."
"__dict__` och att utrymmet för ordlistan hanteras av den virtuella datorn."

#: ../../c-api/typeobj.rst:1211
msgid "If this flag is set, :c:macro:`Py_TPFLAGS_HAVE_GC` should also be set."
msgstr ""
"Om denna flagga är satt, bör :c:macro:`Py_TPFLAGS_HAVE_GC` också vara satt."

#: ../../c-api/typeobj.rst:1213
msgid ""
"The type traverse function must call :c:func:`PyObject_VisitManagedDict` and "
"its clear function must call :c:func:`PyObject_ClearManagedDict`."
msgstr ""
"Typövergångsfunktionen måste anropa :c:func:`PyObject_VisitManagedDict` och "
"dess rensningsfunktion måste anropa :c:func:`PyObject_ClearManagedDict`."

#: ../../c-api/typeobj.rst:1220
msgid ""
"This flag is inherited unless the :c:member:`~PyTypeObject.tp_dictoffset` "
"field is set in a superclass."
msgstr ""
"Denna flagga ärvs om inte fältet :c:member:`~PyTypeObject.tp_dictoffset` är "
"inställt i en superklass."

#: ../../c-api/typeobj.rst:1226
msgid ""
"This bit indicates that instances of the class should be weakly "
"referenceable."
msgstr "Denna bit anger att instanser av klassen ska vara svagt refererbara."

#: ../../c-api/typeobj.rst:1233
msgid ""
"This flag is inherited unless the :c:member:`~PyTypeObject."
"tp_weaklistoffset` field is set in a superclass."
msgstr ""
"Denna flagga ärvs om inte fältet :c:member:`~PyTypeObject.tp_weaklistoffset` "
"är inställt i en superklass."

#: ../../c-api/typeobj.rst:1239
msgid ""
"Only usable with variable-size types, i.e. ones with non-zero :c:member:"
"`~PyTypeObject.tp_itemsize`."
msgstr ""
"Används endast med typer med variabel storlek, dvs. sådana som har :c:member:"
"`~PyTypeObject.tp_itemsize` som inte är noll."

#: ../../c-api/typeobj.rst:1242
msgid ""
"Indicates that the variable-sized portion of an instance of this type is at "
"the end of the instance's memory area, at an offset of ``Py_TYPE(obj)-"
">tp_basicsize`` (which may be different in each subclass)."
msgstr ""
"Indikerar att den variabelstora delen av en instans av denna typ är i slutet "
"av instansens minnesområde, vid en offset av ``Py_TYPE(obj)->tp_basicsize`` "
"(som kan vara annorlunda i varje underklass)."

#: ../../c-api/typeobj.rst:1247
msgid ""
"When setting this flag, be sure that all superclasses either use this memory "
"layout, or are not variable-sized. Python does not check this."
msgstr ""
"När du ställer in denna flagga måste du se till att alla superklasser "
"antingen använder denna minneslayout eller inte har variabel storlek. Python "
"kontrollerar inte detta."

#: ../../c-api/typeobj.rst:1255
msgid "This flag is inherited."
msgstr "Denna flagga ärvs."

#: ../../c-api/typeobj.rst:1269
msgid ""
"Functions such as :c:func:`PyLong_Check` will call :c:func:"
"`PyType_FastSubclass` with one of these flags to quickly determine if a type "
"is a subclass of a built-in type; such specific checks are faster than a "
"generic check, like :c:func:`PyObject_IsInstance`. Custom types that inherit "
"from built-ins should have their :c:member:`~PyTypeObject.tp_flags` set "
"appropriately, or the code that interacts with such types will behave "
"differently depending on what kind of check is used."
msgstr ""

#: ../../c-api/typeobj.rst:1280
msgid ""
"This bit is set when the :c:member:`~PyTypeObject.tp_finalize` slot is "
"present in the type structure."
msgstr ""
"Denna bit är inställd när :c:member:`~PyTypeObject.tp_finalize` finns i "
"typstrukturen."

#: ../../c-api/typeobj.rst:1285
msgid ""
"This flag isn't necessary anymore, as the interpreter assumes the :c:member:"
"`~PyTypeObject.tp_finalize` slot is always present in the type structure."
msgstr ""
"Denna flagga är inte längre nödvändig, eftersom tolken antar att :c:member:"
"`~PyTypeObject.tp_finalize` alltid finns i typstrukturen."

#: ../../c-api/typeobj.rst:1296
msgid ""
"This bit is set when the class implements the :ref:`vectorcall protocol "
"<vectorcall>`. See :c:member:`~PyTypeObject.tp_vectorcall_offset` for "
"details."
msgstr ""
"Denna bit är inställd när klassen implementerar :ref:`vectorcall-protokollet "
"<vectorcall>`. Se :c:member:`~PyTypeObject.tp_vectorcall_offset` för "
"detaljer."

#: ../../c-api/typeobj.rst:1302
msgid ""
"This bit is inherited if :c:member:`~PyTypeObject.tp_call` is also inherited."
msgstr "Denna bit ärvs om :c:member:`~PyTypeObject.tp_call` också ärvs."

#: ../../c-api/typeobj.rst:1305
msgid "as ``_Py_TPFLAGS_HAVE_VECTORCALL``"
msgstr ""

#: ../../c-api/typeobj.rst:1309
msgid ""
"Renamed to the current name, without the leading underscore. The old "
"provisional name is :term:`soft deprecated`."
msgstr ""

#: ../../c-api/typeobj.rst:1314
msgid ""
"This flag is now removed from a class when the class's :py:meth:`~object."
"__call__` method is reassigned."
msgstr ""
"Denna flagga tas nu bort från en klass när klassens :py:meth:`~object."
"__call__`-metod tilldelas på nytt."

#: ../../c-api/typeobj.rst:1317
msgid "This flag can now be inherited by mutable classes."
msgstr "Denna flagga kan nu ärvas av mutabla klasser."

#: ../../c-api/typeobj.rst:1321
msgid ""
"This bit is set for type objects that are immutable: type attributes cannot "
"be set nor deleted."
msgstr ""
"Denna bit är inställd för typobjekt som är oföränderliga: typattribut kan "
"inte ställas in eller tas bort."

#: ../../c-api/typeobj.rst:1323
msgid ""
":c:func:`PyType_Ready` automatically applies this flag to :ref:`static types "
"<static-types>`."
msgstr ""
":c:func:`PyType_Ready` tillämpar automatiskt denna flagga på :ref:`static "
"types <static-types>`."

#: ../../c-api/typeobj.rst:1328
msgid "This flag is not inherited."
msgstr "Denna flagga är inte ärftlig."

#: ../../c-api/typeobj.rst:1334
msgid ""
"Disallow creating instances of the type: set :c:member:`~PyTypeObject."
"tp_new` to NULL and don't create the ``__new__`` key in the type dictionary."
msgstr ""
"Tillåt inte att skapa instanser av typen: sätt :c:member:`~PyTypeObject."
"tp_new` till NULL och skapa inte nyckeln ``__new__`` i typordboken."

#: ../../c-api/typeobj.rst:1338
msgid ""
"The flag must be set before creating the type, not after. For example, it "
"must be set before :c:func:`PyType_Ready` is called on the type."
msgstr ""
"Flaggan måste anges innan typen skapas, inte efteråt. Den måste till exempel "
"ställas in innan :c:func:`PyType_Ready` anropas på typen."

#: ../../c-api/typeobj.rst:1341
msgid ""
"The flag is set automatically on :ref:`static types <static-types>` if :c:"
"member:`~PyTypeObject.tp_base` is NULL or ``&PyBaseObject_Type`` and :c:"
"member:`~PyTypeObject.tp_new` is NULL."
msgstr ""
"Flaggan sätts automatiskt på :ref:`static types <static-types>` om :c:member:"
"`~PyTypeObject.tp_base` är NULL eller ``&amp;PyBaseObject_Type`` och :c:"
"member:`~PyTypeObject.tp_new` är NULL."

#: ../../c-api/typeobj.rst:1347
msgid ""
"This flag is not inherited. However, subclasses will not be instantiable "
"unless they provide a non-NULL :c:member:`~PyTypeObject.tp_new` (which is "
"only possible via the C API)."
msgstr ""
"Denna flagga ärvs inte. Underklasser kommer dock inte att kunna instansieras "
"om de inte tillhandahåller en icke-NULL :c:member:`~PyTypeObject.tp_new` "
"(vilket endast är möjligt via C API)."

#: ../../c-api/typeobj.rst:1354
msgid ""
"To disallow instantiating a class directly but allow instantiating its "
"subclasses (e.g. for an :term:`abstract base class`), do not use this flag. "
"Instead, make :c:member:`~PyTypeObject.tp_new` only succeed for subclasses."
msgstr ""
"Använd inte denna flagga för att inte tillåta instansiering av en klass "
"direkt men tillåta instansiering av dess underklasser (t.ex. för en :term:"
"`abstrakt basklass`). Gör istället så att :c:member:`~PyTypeObject.tp_new` "
"bara lyckas för underklasser."

#: ../../c-api/typeobj.rst:1365
msgid ""
"This bit indicates that instances of the class may match mapping patterns "
"when used as the subject of a :keyword:`match` block. It is automatically "
"set when registering or subclassing :class:`collections.abc.Mapping`, and "
"unset when registering :class:`collections.abc.Sequence`."
msgstr ""
"Denna bit indikerar att instanser av klassen kan matcha mappningsmönster när "
"de används som ämne för ett :keyword:`match`-block. Den sätts automatiskt "
"vid registrering eller underklassning av :class:`collections.abc.Mapping`, "
"och avmarkeras vid registrering av :class:`collections.abc.Sequence`."

#: ../../c-api/typeobj.rst:1372 ../../c-api/typeobj.rst:1394
msgid ""
":c:macro:`Py_TPFLAGS_MAPPING` and :c:macro:`Py_TPFLAGS_SEQUENCE` are "
"mutually exclusive; it is an error to enable both flags simultaneously."
msgstr ""
":c:macro:`Py_TPFLAGS_MAPPING` och :c:macro:`Py_TPFLAGS_SEQUENCE` är "
"ömsesidigt uteslutande; det är ett fel att aktivera båda flaggorna samtidigt."

#: ../../c-api/typeobj.rst:1377
msgid ""
"This flag is inherited by types that do not already set :c:macro:"
"`Py_TPFLAGS_SEQUENCE`."
msgstr ""
"Denna flagga ärvs av typer som inte redan har satt :c:macro:"
"`Py_TPFLAGS_SEQUENCE`."

#: ../../c-api/typeobj.rst:1380 ../../c-api/typeobj.rst:1402
msgid ":pep:`634` -- Structural Pattern Matching: Specification"
msgstr ":pep:`634` -- Matchning av strukturella mönster: Specifikation"

#: ../../c-api/typeobj.rst:1387
msgid ""
"This bit indicates that instances of the class may match sequence patterns "
"when used as the subject of a :keyword:`match` block. It is automatically "
"set when registering or subclassing :class:`collections.abc.Sequence`, and "
"unset when registering :class:`collections.abc.Mapping`."
msgstr ""
"Denna bit indikerar att instanser av klassen kan matcha sekvensmönster när "
"de används som subjekt i ett :keyword:`match`-block. Den sätts automatiskt "
"vid registrering eller underklassning av :class:`collections.abc.Sequence`, "
"och avmarkeras vid registrering av :class:`collections.abc.Mapping`."

#: ../../c-api/typeobj.rst:1399
msgid ""
"This flag is inherited by types that do not already set :c:macro:"
"`Py_TPFLAGS_MAPPING`."
msgstr ""
"Denna flagga ärvs av typer som inte redan har satt :c:macro:"
"`Py_TPFLAGS_MAPPING`."

#: ../../c-api/typeobj.rst:1409
msgid ""
"Internal. Do not set or unset this flag. To indicate that a class has "
"changed call :c:func:`PyType_Modified`"
msgstr ""
"Internt. Denna flagga ska inte ställas in eller tas bort. För att indikera "
"att en klass har ändrats anropa :c:func:`PyType_Modified`"

#: ../../c-api/typeobj.rst:1413
msgid ""
"This flag is present in header files, but is not be used. It will be removed "
"in a future version of CPython"
msgstr ""
"Denna flagga finns i header-filer, men används inte. Den kommer att tas bort "
"i en framtida version av CPython"

#: ../../c-api/typeobj.rst:1421
msgid ""
"An optional pointer to a NUL-terminated C string giving the docstring for "
"this type object.  This is exposed as the :attr:`~type.__doc__` attribute on "
"the type and instances of the type."
msgstr ""
"En valfri pekare till en NUL-avslutad C-sträng som anger dokumentsträngen "
"för detta typobjekt.  Detta exponeras som attributet :attr:`~type.__doc__` "
"på typen och instanser av typen."

#: ../../c-api/typeobj.rst:1427
msgid "This field is *not* inherited by subtypes."
msgstr "Detta fält ärvs *inte* av subtyper."

#: ../../c-api/typeobj.rst:1434
msgid ""
"An optional pointer to a traversal function for the garbage collector.  This "
"is only used if the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is set.  The "
"signature is::"
msgstr ""
"En valfri pekare till en traversalfunktion för skräpsamlaren.  Denna används "
"endast om flaggbiten :c:macro:`Py_TPFLAGS_HAVE_GC` är satt.  Signaturen är::"

#: ../../c-api/typeobj.rst:1437
msgid "int tp_traverse(PyObject *self, visitproc visit, void *arg);"
msgstr "int tp_traverse(PyObject *self, visitproc visit, void *arg);"

#: ../../c-api/typeobj.rst:1439 ../../c-api/typeobj.rst:1590
msgid ""
"More information about Python's garbage collection scheme can be found in "
"section :ref:`supporting-cycle-detection`."
msgstr ""
"Mer information om Pythons skräpplockningssystem finns i avsnitt :ref:"
"`supporting-cycle-detection`."

#: ../../c-api/typeobj.rst:1442
msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` pointer is used by the garbage "
"collector to detect reference cycles. A typical implementation of a :c:"
"member:`~PyTypeObject.tp_traverse` function simply calls :c:func:`Py_VISIT` "
"on each of the instance's members that are Python objects that the instance "
"owns. For example, this is function :c:func:`!local_traverse` from the :mod:"
"`!_thread` extension module::"
msgstr ""
"Pekaren :c:member:`~PyTypeObject.tp_traverse` används av garbage collector "
"för att upptäcka referenscykler. En typisk implementering av en :c:member:"
"`~PyTypeObject.tp_traverse`-funktion anropar helt enkelt :c:func:`Py_VISIT` "
"på var och en av instansens medlemmar som är Python-objekt som instansen "
"äger. Detta är till exempel funktionen :c:func:`!local_traverse` från "
"tilläggsmodulen :mod:`!_thread`::"

#: ../../c-api/typeobj.rst:1448
msgid ""
"static int\n"
"local_traverse(localobject *self, visitproc visit, void *arg)\n"
"{\n"
"    Py_VISIT(self->args);\n"
"    Py_VISIT(self->kw);\n"
"    Py_VISIT(self->dict);\n"
"    return 0;\n"
"}"
msgstr ""

#: ../../c-api/typeobj.rst:1457
msgid ""
"Note that :c:func:`Py_VISIT` is called only on those members that can "
"participate in reference cycles.  Although there is also a ``self->key`` "
"member, it can only be ``NULL`` or a Python string and therefore cannot be "
"part of a reference cycle."
msgstr ""
"Observera att :c:func:`Py_VISIT` endast anropas på de medlemmar som kan "
"delta i referenscykler.  Även om det också finns en ``self->key``-medlem, "
"kan den bara vara ``NULL`` eller en Python-sträng och kan därför inte vara "
"en del av en referenscykel."

#: ../../c-api/typeobj.rst:1461
msgid ""
"On the other hand, even if you know a member can never be part of a cycle, "
"as a debugging aid you may want to visit it anyway just so the :mod:`gc` "
"module's :func:`~gc.get_referents` function will include it."
msgstr ""
"Å andra sidan, även om du vet att en medlem aldrig kan ingå i en cykel, kan "
"du som felsökningshjälp vilja besöka den ändå, bara för att :mod:`gc`-"
"modulens :func:`~gc.get_referents`-funktion ska inkludera den."

#: ../../c-api/typeobj.rst:1465
msgid ""
"Heap types (:c:macro:`Py_TPFLAGS_HEAPTYPE`) must visit their type with::"
msgstr "Heap-typer (:c:macro:`Py_TPFLAGS_HEAPTYPE`) måste besöka sin typ med::"

#: ../../c-api/typeobj.rst:1467
msgid "Py_VISIT(Py_TYPE(self));"
msgstr "Py_VISIT(Py_TYPE(self));"

#: ../../c-api/typeobj.rst:1469
msgid ""
"It is only needed since Python 3.9. To support Python 3.8 and older, this "
"line must be conditional::"
msgstr ""
"Den behövs bara sedan Python 3.9. För att stödja Python 3.8 och äldre måste "
"denna rad vara villkorlig::"

#: ../../c-api/typeobj.rst:1472
msgid ""
"#if PY_VERSION_HEX >= 0x03090000\n"
"    Py_VISIT(Py_TYPE(self));\n"
"#endif"
msgstr ""
"#if PY_VERSION_HEX >= 0x03090000\n"
"    Py_VISIT(Py_TYPE(self));\n"
"#endif"

#: ../../c-api/typeobj.rst:1476
msgid ""
"If the :c:macro:`Py_TPFLAGS_MANAGED_DICT` bit is set in the :c:member:"
"`~PyTypeObject.tp_flags` field, the traverse function must call :c:func:"
"`PyObject_VisitManagedDict` like this::"
msgstr ""
"Om bit :c:macro:`Py_TPFLAGS_MANAGED_DICT` är inställd i fältet :c:member:"
"`~PyTypeObject.tp_flags` måste traversefunktionen anropa :c:func:"
"`PyObject_VisitManagedDict` så här::"

#: ../../c-api/typeobj.rst:1480
msgid "PyObject_VisitManagedDict((PyObject*)self, visit, arg);"
msgstr "PyObject_VisitManagedDict((PyObject*)self, visit, arg);"

#: ../../c-api/typeobj.rst:1483
msgid ""
"When implementing :c:member:`~PyTypeObject.tp_traverse`, only the members "
"that the instance *owns* (by having :term:`strong references <strong "
"reference>` to them) must be visited. For instance, if an object supports "
"weak references via the :c:member:`~PyTypeObject.tp_weaklist` slot, the "
"pointer supporting the linked list (what *tp_weaklist* points to) must "
"**not** be visited as the instance does not directly own the weak references "
"to itself (the weakreference list is there to support the weak reference "
"machinery, but the instance has no strong reference to the elements inside "
"it, as they are allowed to be removed even if the instance is still alive)."
msgstr ""
"Vid implementering av :c:member:`~PyTypeObject.tp_traverse`, måste endast de "
"medlemmar som instansen *äger* (genom att ha :term:`strong references "
"<strong reference>` till dem) besökas. Om ett objekt t.ex. stöder svaga "
"referenser via :c:member:`~PyTypeObject.tp_weaklist` slot, får pekaren som "
"stöder den länkade listan (som *tp_weaklist* pekar på) **inte** besökas "
"eftersom instansen inte direkt äger de svaga referenserna till sig själv "
"(weakreference-listan finns där för att stödja maskineriet för svaga "
"referenser, men instansen har ingen stark referens till elementen inuti den, "
"eftersom de får tas bort även om instansen fortfarande lever)."

#: ../../c-api/typeobj.rst:1495
msgid ""
"The traversal function must not have any side effects.  It must not modify "
"the reference counts of any Python objects nor create or destroy any Python "
"objects."
msgstr ""

#: ../../c-api/typeobj.rst:1499
msgid ""
"Note that :c:func:`Py_VISIT` requires the *visit* and *arg* parameters to :c:"
"func:`!local_traverse` to have these specific names; don't name them just "
"anything."
msgstr ""
"Observera att :c:func:`Py_VISIT` kräver att parametrarna *visit* och *arg* "
"till :c:func:`!local_traverse` har dessa specifika namn; ge dem inte vilka "
"namn som helst."

#: ../../c-api/typeobj.rst:1503
msgid ""
"Instances of :ref:`heap-allocated types <heap-types>` hold a reference to "
"their type. Their traversal function must therefore either visit :c:func:"
"`Py_TYPE(self) <Py_TYPE>`, or delegate this responsibility by calling "
"``tp_traverse`` of another heap-allocated type (such as a heap-allocated "
"superclass). If they do not, the type object may not be garbage-collected."
msgstr ""
"Instanser av :ref:``heap-allocated types <heap-types>` håller en referens "
"till sin typ. Deras traversalfunktion måste därför antingen besöka :c:func:"
"`Py_TYPE(self) <Py_TYPE>`, eller delegera detta ansvar genom att anropa "
"``tp_traverse`` av en annan heap-allokerad typ (såsom en heap-allokerad "
"superklass). Om de inte gör det kan det hända att typobjektet inte är "
"garbage-collected."

#: ../../c-api/typeobj.rst:1512
msgid ""
"Heap-allocated types are expected to visit ``Py_TYPE(self)`` in "
"``tp_traverse``.  In earlier versions of Python, due to `bug 40217 <https://"
"bugs.python.org/issue40217>`_, doing this may lead to crashes in subclasses."
msgstr ""
"Heap-allokerade typer förväntas besöka ``Py_TYPE(self)`` i ``tp_traverse``.  "
"I tidigare versioner av Python, på grund av `bug 40217 <https://bugs.python."
"org/issue40217>`_, kan detta leda till krascher i underklasser."

#: ../../c-api/typeobj.rst:1521
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_clear` and the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit: the flag bit, :c:"
"member:`~PyTypeObject.tp_traverse`, and :c:member:`~PyTypeObject.tp_clear` "
"are all inherited from the base type if they are all zero in the subtype."
msgstr ""
"Detta fält ärvs av subtyper tillsammans med :c:member:`~PyTypeObject."
"tp_clear` och flaggbiten :c:macro:`Py_TPFLAGS_HAVE_GC`: flaggbiten, :c:"
"member:`~PyTypeObject.tp_traverse` och :c:member:`~PyTypeObject.tp_clear` "
"ärvs alla från bastypen om de alla är noll i subtypen."

#: ../../c-api/typeobj.rst:1531
msgid ""
"An optional pointer to a clear function for the garbage collector. This is "
"only used if the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is set.  The "
"signature is::"
msgstr ""

#: ../../c-api/typeobj.rst:1534
msgid "int tp_clear(PyObject *);"
msgstr "int tp_clear(PyObject *);"

#: ../../c-api/typeobj.rst:1536
msgid ""
"The :c:member:`~PyTypeObject.tp_clear` member function is used to break "
"reference cycles in cyclic garbage detected by the garbage collector.  Taken "
"together, all :c:member:`~PyTypeObject.tp_clear` functions in the system "
"must combine to break all reference cycles.  This is subtle, and if in any "
"doubt supply a :c:member:`~PyTypeObject.tp_clear` function.  For example, "
"the tuple type does not implement a :c:member:`~PyTypeObject.tp_clear` "
"function, because it's possible to prove that no reference cycle can be "
"composed entirely of tuples. Therefore the :c:member:`~PyTypeObject."
"tp_clear` functions of other types must be sufficient to break any cycle "
"containing a tuple.  This isn't immediately obvious, and there's rarely a "
"good reason to avoid implementing :c:member:`~PyTypeObject.tp_clear`."
msgstr ""

#: ../../c-api/typeobj.rst:1546
msgid ""
"Implementations of :c:member:`~PyTypeObject.tp_clear` should drop the "
"instance's references to those of its members that may be Python objects, "
"and set its pointers to those members to ``NULL``, as in the following "
"example::"
msgstr ""
"Implementeringar av :c:member:`~PyTypeObject.tp_clear` bör ta bort "
"instansens referenser till de av dess medlemmar som kan vara Python-objekt, "
"och sätta dess pekare till dessa medlemmar till ``NULL``, som i följande "
"exempel::"

#: ../../c-api/typeobj.rst:1550
msgid ""
"static int\n"
"local_clear(localobject *self)\n"
"{\n"
"    Py_CLEAR(self->key);\n"
"    Py_CLEAR(self->args);\n"
"    Py_CLEAR(self->kw);\n"
"    Py_CLEAR(self->dict);\n"
"    return 0;\n"
"}"
msgstr ""

#: ../../c-api/typeobj.rst:1560
msgid ""
"The :c:func:`Py_CLEAR` macro should be used, because clearing references is "
"delicate:  the reference to the contained object must not be released (via :"
"c:func:`Py_DECREF`) until after the pointer to the contained object is set "
"to ``NULL``.  This is because releasing the reference may cause the "
"contained object to become trash, triggering a chain of reclamation activity "
"that may include invoking arbitrary Python code (due to finalizers, or "
"weakref callbacks, associated with the contained object). If it's possible "
"for such code to reference *self* again, it's important that the pointer to "
"the contained object be ``NULL`` at that time, so that *self* knows the "
"contained object can no longer be used.  The :c:func:`Py_CLEAR` macro "
"performs the operations in a safe order."
msgstr ""
"Makrot :c:func:`Py_CLEAR` bör användas eftersom det är känsligt att rensa "
"referenser: referensen till det ingående objektet får inte släppas (via :c:"
"func:`Py_DECREF`) förrän efter att pekaren till det ingående objektet har "
"satts till ``NULL``.  Detta beror på att frigörandet av referensen kan leda "
"till att det inneslutna objektet blir skräp, vilket utlöser en kedja av "
"återvinningsaktiviteter som kan inkludera anrop av godtycklig Python-kod (på "
"grund av finalizers eller weakref callbacks som är associerade med det "
"inneslutna objektet). Om det är möjligt för sådan kod att referera till "
"*self* igen, är det viktigt att pekaren till det inneslutna objektet är "
"``NULL`` vid den tidpunkten, så att *self* vet att det inneslutna objektet "
"inte längre kan användas.  Makrot :c:func:`Py_CLEAR` utför dessa operationer "
"i en säker ordning."

#: ../../c-api/typeobj.rst:1572
msgid ""
"If the :c:macro:`Py_TPFLAGS_MANAGED_DICT` bit is set in the :c:member:"
"`~PyTypeObject.tp_flags` field, the clear function must call :c:func:"
"`PyObject_ClearManagedDict` like this::"
msgstr ""

#: ../../c-api/typeobj.rst:1576
msgid "PyObject_ClearManagedDict((PyObject*)self);"
msgstr "PyObject_ClearManagedDict((PyObject*)self);"

#: ../../c-api/typeobj.rst:1578
msgid ""
"Note that :c:member:`~PyTypeObject.tp_clear` is not *always* called before "
"an instance is deallocated. For example, when reference counting is enough "
"to determine that an object is no longer used, the cyclic garbage collector "
"is not involved and :c:member:`~PyTypeObject.tp_dealloc` is called directly."
msgstr ""

#: ../../c-api/typeobj.rst:1584
msgid ""
"Because the goal of :c:member:`~PyTypeObject.tp_clear` functions is to break "
"reference cycles, it's not necessary to clear contained objects like Python "
"strings or Python integers, which can't participate in reference cycles. On "
"the other hand, it may be convenient to clear all contained Python objects, "
"and write the type's :c:member:`~PyTypeObject.tp_dealloc` function to "
"invoke :c:member:`~PyTypeObject.tp_clear`."
msgstr ""

#: ../../c-api/typeobj.rst:1597
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_traverse` and the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit: the flag bit, :"
"c:member:`~PyTypeObject.tp_traverse`, and :c:member:`~PyTypeObject.tp_clear` "
"are all inherited from the base type if they are all zero in the subtype."
msgstr ""
"Detta fält ärvs av subtyper tillsammans med :c:member:`~PyTypeObject."
"tp_traverse` och flaggbiten :c:macro:`Py_TPFLAGS_HAVE_GC`: flaggbiten, :c:"
"member:`~PyTypeObject.tp_traverse` och :c:member:`~PyTypeObject.tp_clear` "
"ärvs alla från bastypen om de alla är noll i subtypen."

#: ../../c-api/typeobj.rst:1607
msgid ""
"An optional pointer to the rich comparison function, whose signature is::"
msgstr ""
"En valfri pekare till den rika jämförelsefunktionen, vars signatur är::"

#: ../../c-api/typeobj.rst:1609
msgid "PyObject *tp_richcompare(PyObject *self, PyObject *other, int op);"
msgstr "PyObject *tp_richcompare(PyObject *self, PyObject *other, int op);"

#: ../../c-api/typeobj.rst:1611
msgid ""
"The first parameter is guaranteed to be an instance of the type that is "
"defined by :c:type:`PyTypeObject`."
msgstr ""
"Den första parametern är garanterat en instans av den typ som definieras av :"
"c:type:`PyTypeObject`."

#: ../../c-api/typeobj.rst:1614
msgid ""
"The function should return the result of the comparison (usually ``Py_True`` "
"or ``Py_False``).  If the comparison is undefined, it must return "
"``Py_NotImplemented``, if another error occurred it must return ``NULL`` and "
"set an exception condition."
msgstr ""
"Funktionen ska returnera resultatet av jämförelsen (vanligtvis ``Py_True`` "
"eller ``Py_False``).  Om jämförelsen är odefinierad måste den returnera "
"``Py_NotImplemented``, om ett annat fel inträffade måste den returnera "
"``NULL`` och sätta ett undantagsvillkor."

#: ../../c-api/typeobj.rst:1619
msgid ""
"The following constants are defined to be used as the third argument for :c:"
"member:`~PyTypeObject.tp_richcompare` and for :c:func:`PyObject_RichCompare`:"
msgstr ""
"Följande konstanter är definierade för att användas som det tredje "
"argumentet för :c:member:`~PyTypeObject.tp_richcompare` och för :c:func:"
"`PyObject_RichCompare`:"

#: ../../c-api/typeobj.rst:1625
msgid "Constant"
msgstr "Konstant"

#: ../../c-api/typeobj.rst:1625
msgid "Comparison"
msgstr "Jämförelse"

#: ../../c-api/typeobj.rst:1627
msgid "``<``"
msgstr "``<``"

#: ../../c-api/typeobj.rst:1629
msgid "``<=``"
msgstr "``<=``"

#: ../../c-api/typeobj.rst:1631
msgid "``==``"
msgstr "``==``"

#: ../../c-api/typeobj.rst:1633
msgid "``!=``"
msgstr "``!=``"

#: ../../c-api/typeobj.rst:1635
msgid "``>``"
msgstr "``>``"

#: ../../c-api/typeobj.rst:1637
msgid "``>=``"
msgstr "``>=``"

#: ../../c-api/typeobj.rst:1640
msgid ""
"The following macro is defined to ease writing rich comparison functions:"
msgstr ""
"Följande makro är definierat för att underlätta skrivandet av rika "
"jämförelsefunktioner:"

#: ../../c-api/typeobj.rst:1644
msgid ""
"Return ``Py_True`` or ``Py_False`` from the function, depending on the "
"result of a comparison. VAL_A and VAL_B must be orderable by C comparison "
"operators (for example, they may be C ints or floats). The third argument "
"specifies the requested operation, as for :c:func:`PyObject_RichCompare`."
msgstr ""
"Returnerar ``Py_True`` eller ``Py_False`` från funktionen, beroende på "
"resultatet av en jämförelse. VAL_A och VAL_B måste kunna ordnas av C:s "
"jämförelseoperatorer (de kan t.ex. vara C:s ints eller floats). Det tredje "
"argumentet specificerar den begärda operationen, som för :c:func:"
"`PyObject_RichCompare`."

#: ../../c-api/typeobj.rst:1650
msgid "The returned value is a new :term:`strong reference`."
msgstr "Det returnerade värdet är en ny :term:`strong reference`."

#: ../../c-api/typeobj.rst:1652
msgid "On error, sets an exception and returns ``NULL`` from the function."
msgstr "Vid fel, anger ett undantag och returnerar ``NULL`` från funktionen."

#: ../../c-api/typeobj.rst:1660
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_hash`: a subtype inherits :c:member:`~PyTypeObject.tp_richcompare` and :c:"
"member:`~PyTypeObject.tp_hash` when the subtype's :c:member:`~PyTypeObject."
"tp_richcompare` and :c:member:`~PyTypeObject.tp_hash` are both ``NULL``."
msgstr ""
"Detta fält ärvs av subtyper tillsammans med :c:member:`~PyTypeObject."
"tp_hash`: en subtyp ärver :c:member:`~PyTypeObject.tp_richcompare` och :c:"
"member:`~PyTypeObject.tp_hash` när subtypens :c:member:`~PyTypeObject."
"tp_richcompare` och :c:member:`~PyTypeObject.tp_hash` båda är ``NULL``."

#: ../../c-api/typeobj.rst:1667
msgid ""
":c:data:`PyBaseObject_Type` provides a :c:member:`~PyTypeObject."
"tp_richcompare` implementation, which may be inherited.  However, if only :c:"
"member:`~PyTypeObject.tp_hash` is defined, not even the inherited function "
"is used and instances of the type will not be able to participate in any "
"comparisons."
msgstr ""
":c:data:`PyBaseObject_Type` tillhandahåller en :c:member:`~PyTypeObject."
"tp_richcompare`-implementation, som kan ärvas.  Men om endast :c:member:"
"`~PyTypeObject.tp_hash` definieras, används inte ens den ärvda funktionen "
"och instanser av typen kommer inte att kunna delta i några jämförelser."

#: ../../c-api/typeobj.rst:1676
msgid ""
"While this field is still supported, :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` "
"should be used instead, if at all possible."
msgstr ""
"Även om detta fält fortfarande stöds bör :c:macro:"
"`Py_TPFLAGS_MANAGED_WEAKREF` användas i stället, om det är möjligt."

#: ../../c-api/typeobj.rst:1679
msgid ""
"If the instances of this type are weakly referenceable, this field is "
"greater than zero and contains the offset in the instance structure of the "
"weak reference list head (ignoring the GC header, if present); this offset "
"is used by :c:func:`PyObject_ClearWeakRefs` and the ``PyWeakref_*`` "
"functions.  The instance structure needs to include a field of type :c:expr:"
"`PyObject*` which is initialized to ``NULL``."
msgstr ""
"Om instanserna av denna typ är svagt refererbara, är detta fält större än "
"noll och innehåller offset i instansstrukturen för huvudet på listan över "
"svaga referenser (ignorerar GC-headern, om sådan finns); denna offset "
"används av funktionerna :c:func:`PyObject_ClearWeakRefs` och "
"``PyWeakref_*``.  Instansstrukturen måste innehålla ett fält av typen :c:"
"expr:`PyObject*` som initialiseras till ``NULL``."

#: ../../c-api/typeobj.rst:1686
msgid ""
"Do not confuse this field with :c:member:`~PyTypeObject.tp_weaklist`; that "
"is the list head for weak references to the type object itself."
msgstr ""
"Förväxla inte detta fält med :c:member:`~PyTypeObject.tp_weaklist`; det är "
"listhuvudet för svaga referenser till typobjektet självt."

#: ../../c-api/typeobj.rst:1689
msgid ""
"It is an error to set both the :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` bit "
"and :c:member:`~PyTypeObject.tp_weaklistoffset`."
msgstr ""
"Det är ett fel att ange både :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` bit och :"
"c:member:`~PyTypeObject.tp_weaklistoffset`."

#: ../../c-api/typeobj.rst:1694
msgid ""
"This field is inherited by subtypes, but see the rules listed below. A "
"subtype may override this offset; this means that the subtype uses a "
"different weak reference list head than the base type.  Since the list head "
"is always found via :c:member:`~PyTypeObject.tp_weaklistoffset`, this should "
"not be a problem."
msgstr ""
"Detta fält ärvs av subtyper, men se de regler som anges nedan. En subtyp kan "
"åsidosätta denna offset; detta innebär att subtypen använder ett annat "
"listhuvud för svaga referenser än bastypen.  Eftersom listhuvudet alltid "
"hittas via :c:member:`~PyTypeObject.tp_weaklistoffset`, bör detta inte vara "
"något problem."

#: ../../c-api/typeobj.rst:1701
msgid ""
"If the :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` bit is set in the :c:member:"
"`~PyTypeObject.tp_flags` field, then :c:member:`~PyTypeObject."
"tp_weaklistoffset` will be set to a negative value, to indicate that it is "
"unsafe to use this field."
msgstr ""
"Om bitarna :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` är inställda i fältet :c:"
"member:`~PyTypeObject.tp_flags`, kommer :c:member:`~PyTypeObject."
"tp_weaklistoffset` att sättas till ett negativt värde, för att indikera att "
"det är osäkert att använda detta fält."

#: ../../c-api/typeobj.rst:1711
msgid ""
"An optional pointer to a function that returns an :term:`iterator` for the "
"object.  Its presence normally signals that the instances of this type are :"
"term:`iterable` (although sequences may be iterable without this function)."
msgstr ""
"En valfri pekare till en funktion som returnerar en :term:`iterator` för "
"objektet.  Dess närvaro signalerar normalt att instanser av denna typ är :"
"term:`iterabla` (även om sekvenser kan vara iterabla utan denna funktion)."

#: ../../c-api/typeobj.rst:1715
msgid "This function has the same signature as :c:func:`PyObject_GetIter`::"
msgstr "Denna funktion har samma signatur som :c:func:`PyObject_GetIter`::"

#: ../../c-api/typeobj.rst:1717
msgid "PyObject *tp_iter(PyObject *self);"
msgstr "PyObject *tp_iter(PyObject *self);"

#: ../../c-api/typeobj.rst:1728
msgid ""
"An optional pointer to a function that returns the next item in an :term:"
"`iterator`. The signature is::"
msgstr ""
"En valfri pekare till en funktion som returnerar nästa objekt i en :term:"
"`iterator`. Signaturen är::"

#: ../../c-api/typeobj.rst:1731
msgid "PyObject *tp_iternext(PyObject *self);"
msgstr "PyObject *tp_iternext(PyObject *self);"

#: ../../c-api/typeobj.rst:1733
msgid ""
"When the iterator is exhausted, it must return ``NULL``; a :exc:"
"`StopIteration` exception may or may not be set.  When another error occurs, "
"it must return ``NULL`` too.  Its presence signals that the instances of "
"this type are iterators."
msgstr ""
"När iteratorn är uttömd måste den returnera ``NULL``; ett :exc:"
"`StopIteration` undantag kan eller kan inte ställas in.  När ett annat fel "
"inträffar måste den också returnera ``NULL``.  Dess närvaro signalerar att "
"förekomsterna av denna typ är iteratorer."

#: ../../c-api/typeobj.rst:1738
msgid ""
"Iterator types should also define the :c:member:`~PyTypeObject.tp_iter` "
"function, and that function should return the iterator instance itself (not "
"a new iterator instance)."
msgstr ""
"Iteratortyper bör också definiera funktionen :c:member:`~PyTypeObject."
"tp_iter`, och den funktionen bör returnera själva iteratorinstansen (inte en "
"ny iteratorinstans)."

#: ../../c-api/typeobj.rst:1742
msgid "This function has the same signature as :c:func:`PyIter_Next`."
msgstr "Denna funktion har samma signatur som :c:func:`PyIter_Next`."

#: ../../c-api/typeobj.rst:1753
msgid ""
"An optional pointer to a static ``NULL``-terminated array of :c:type:"
"`PyMethodDef` structures, declaring regular methods of this type."
msgstr ""
"En valfri pekare till en statisk ``NULL``-terminerad array av :c:type:"
"`PyMethodDef`-strukturer, som deklarerar vanliga metoder av denna typ."

#: ../../c-api/typeobj.rst:1756
msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a method descriptor."
msgstr ""
"För varje post i matrisen läggs en post till i typens dictionary (se :c:"
"member:`~PyTypeObject.tp_dict` nedan) som innehåller en metoddeskriptor."

#: ../../c-api/typeobj.rst:1761
msgid ""
"This field is not inherited by subtypes (methods are inherited through a "
"different mechanism)."
msgstr ""
"Detta fält ärvs inte av subtyper (metoder ärvs genom en annan mekanism)."

#: ../../c-api/typeobj.rst:1769
msgid ""
"An optional pointer to a static ``NULL``-terminated array of :c:type:"
"`PyMemberDef` structures, declaring regular data members (fields or slots) "
"of instances of this type."
msgstr ""
"En valfri pekare till en statisk ``NULL``-terminerad array av :c:type:"
"`PyMemberDef`-strukturer, som deklarerar vanliga datamedlemmar (fält eller "
"slots) för instanser av denna typ."

#: ../../c-api/typeobj.rst:1773
msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a member descriptor."
msgstr ""
"För varje post i matrisen läggs en post till i typens dictionary (se :c:"
"member:`~PyTypeObject.tp_dict` nedan) som innehåller en medlemsdeskriptor."

#: ../../c-api/typeobj.rst:1778
msgid ""
"This field is not inherited by subtypes (members are inherited through a "
"different mechanism)."
msgstr ""
"Detta fält ärvs inte av subtyper (medlemmar ärvs genom en annan mekanism)."

#: ../../c-api/typeobj.rst:1786
msgid ""
"An optional pointer to a static ``NULL``-terminated array of :c:type:"
"`PyGetSetDef` structures, declaring computed attributes of instances of this "
"type."
msgstr ""
"En valfri pekare till en statisk ``NULL``-terminerad array av :c:type:"
"`PyGetSetDef`-strukturer, som deklarerar beräknade attribut för instanser av "
"denna typ."

#: ../../c-api/typeobj.rst:1789
msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a getset descriptor."
msgstr ""
"För varje post i matrisen läggs en post till i typens dictionary (se :c:"
"member:`~PyTypeObject.tp_dict` nedan) som innehåller en getset-descriptor."

#: ../../c-api/typeobj.rst:1794
msgid ""
"This field is not inherited by subtypes (computed attributes are inherited "
"through a different mechanism)."
msgstr ""
"Detta fält ärvs inte av subtyper (beräknade attribut ärvs genom en annan "
"mekanism)."

#: ../../c-api/typeobj.rst:1802
msgid ""
"An optional pointer to a base type from which type properties are "
"inherited.  At this level, only single inheritance is supported; multiple "
"inheritance require dynamically creating a type object by calling the "
"metatype."
msgstr ""
"En valfri pekare till en bastyp från vilken typegenskaper ärvs.  På denna "
"nivå stöds endast enkel nedärvning; multipel nedärvning kräver att ett "
"typobjekt skapas dynamiskt genom att anropa metatypen."

#: ../../c-api/typeobj.rst:1810
msgid ""
"Slot initialization is subject to the rules of initializing globals. C99 "
"requires the initializers to be \"address constants\".  Function designators "
"like :c:func:`PyType_GenericNew`, with implicit conversion to a pointer, are "
"valid C99 address constants."
msgstr ""
"Slotinitialisering är föremål för reglerna för initialisering av globaler. "
"C99 kräver att initialisatorerna är \"adresskonstanter\".  "
"Funktionsbeteckningar som :c:func:`PyType_GenericNew`, med implicit "
"konvertering till en pekare, är giltiga C99-adresskonstanter."

#: ../../c-api/typeobj.rst:1815
msgid ""
"However, the unary '&' operator applied to a non-static variable like :c:"
"data:`PyBaseObject_Type` is not required to produce an address constant.  "
"Compilers may support this (gcc does), MSVC does not. Both compilers are "
"strictly standard conforming in this particular behavior."
msgstr ""
"Den unära operatorn '&' som används på en icke-statisk variabel som :c:data:"
"`PyBaseObject_Type` är dock inte nödvändig för att producera en "
"adresskonstant.  Kompilatorer kan stödja detta (gcc gör det), MSVC gör det "
"inte. Båda kompilatorerna är strikt standardkonforma i detta speciella "
"beteende."

#: ../../c-api/typeobj.rst:1821
msgid ""
"Consequently, :c:member:`~PyTypeObject.tp_base` should be set in the "
"extension module's init function."
msgstr ""
"Följaktligen bör :c:member:`~PyTypeObject.tp_base` anges i tilläggsmodulens "
"init-funktion."

#: ../../c-api/typeobj.rst:1826
msgid "This field is not inherited by subtypes (obviously)."
msgstr "Detta fält ärvs inte av subtyper (naturligtvis)."

#: ../../c-api/typeobj.rst:1830
msgid ""
"This field defaults to ``&PyBaseObject_Type`` (which to Python programmers "
"is known as the type :class:`object`)."
msgstr ""
"Detta fält är som standard ``&PyBaseObject_Type`` (som för Python-"
"programmerare är känt som typen :class:`object`)."

#: ../../c-api/typeobj.rst:1836
msgid "The type's dictionary is stored here by :c:func:`PyType_Ready`."
msgstr "Typens ordbok lagras här av :c:func:`PyType_Ready`."

#: ../../c-api/typeobj.rst:1838
msgid ""
"This field should normally be initialized to ``NULL`` before PyType_Ready is "
"called; it may also be initialized to a dictionary containing initial "
"attributes for the type.  Once :c:func:`PyType_Ready` has initialized the "
"type, extra attributes for the type may be added to this dictionary only if "
"they don't correspond to overloaded operations (like :meth:`~object."
"__add__`).  Once initialization for the type has finished, this field should "
"be treated as read-only."
msgstr ""
"Detta fält bör normalt initialiseras till ``NULL`` innan PyType_Ready "
"anropas; det kan också initialiseras till en dictionary som innehåller "
"initiala attribut för typen.  När :c:func:`PyType_Ready` har initialiserat "
"typen kan extra attribut för typen läggas till i denna ordbok endast om de "
"inte motsvarar överbelastade operationer (som :meth:`~object.__add__`).  När "
"initialiseringen av typen har avslutats bör detta fält behandlas som "
"skrivskyddat."

#: ../../c-api/typeobj.rst:1846
msgid ""
"Some types may not store their dictionary in this slot. Use :c:func:"
"`PyType_GetDict` to retrieve the dictionary for an arbitrary type."
msgstr ""
"Vissa typer kanske inte lagrar sin ordbok i denna slot. Använd :c:func:"
"`PyType_GetDict` för att hämta ordlistan för en godtycklig typ."

#: ../../c-api/typeobj.rst:1852
msgid ""
"Internals detail: For static builtin types, this is always ``NULL``. "
"Instead, the dict for such types is stored on ``PyInterpreterState``. Use :c:"
"func:`PyType_GetDict` to get the dict for an arbitrary type."
msgstr ""
"Intern detalj: För statiska inbyggda typer är detta alltid ``NULL``. "
"Istället lagras dict för sådana typer på ``PyInterpreterState``. Använd :c:"
"func:`PyType_GetDict` för att få fram dict för en godtycklig typ."

#: ../../c-api/typeobj.rst:1858
msgid ""
"This field is not inherited by subtypes (though the attributes defined in "
"here are inherited through a different mechanism)."
msgstr ""
"Detta fält ärvs inte av subtyper (även om de attribut som definieras här "
"ärvs genom en annan mekanism)."

#: ../../c-api/typeobj.rst:1863
msgid ""
"If this field is ``NULL``, :c:func:`PyType_Ready` will assign a new "
"dictionary to it."
msgstr ""
"Om detta fält är ``NULL`` kommer :c:func:`PyType_Ready` att tilldela det en "
"ny ordbok."

#: ../../c-api/typeobj.rst:1868
msgid ""
"It is not safe to use :c:func:`PyDict_SetItem` on or otherwise modify :c:"
"member:`~PyTypeObject.tp_dict` with the dictionary C-API."
msgstr ""
"Det är inte säkert att använda :c:func:`PyDict_SetItem` på eller på annat "
"sätt modifiera :c:member:`~PyTypeObject.tp_dict` med dictionary C-API."

#: ../../c-api/typeobj.rst:1876
msgid "An optional pointer to a \"descriptor get\" function."
msgstr "En valfri pekare till en \"descriptor get\"-funktion."

#: ../../c-api/typeobj.rst:1878 ../../c-api/typeobj.rst:1896
#: ../../c-api/typeobj.rst:1962 ../../c-api/typeobj.rst:1994
#: ../../c-api/typeobj.rst:2020
msgid "The function signature is::"
msgstr "Funktionens signatur är::"

#: ../../c-api/typeobj.rst:1880
msgid "PyObject * tp_descr_get(PyObject *self, PyObject *obj, PyObject *type);"
msgstr ""
"PyObject * tp_descr_get(PyObject *self, PyObject *obj, PyObject *type);"

#: ../../c-api/typeobj.rst:1893
msgid ""
"An optional pointer to a function for setting and deleting a descriptor's "
"value."
msgstr ""
"En valfri pekare till en funktion för att ställa in och ta bort en "
"descriptors värde."

#: ../../c-api/typeobj.rst:1898
msgid "int tp_descr_set(PyObject *self, PyObject *obj, PyObject *value);"
msgstr "int tp_descr_set(PyObject *self, PyObject *obj, PyObject *value);"

#: ../../c-api/typeobj.rst:1900
msgid "The *value* argument is set to ``NULL`` to delete the value."
msgstr "Argumentet *värde* sätts till ``NULL`` för att ta bort värdet."

#: ../../c-api/typeobj.rst:1911
msgid ""
"While this field is still supported, :c:macro:`Py_TPFLAGS_MANAGED_DICT` "
"should be used instead, if at all possible."
msgstr ""
"Även om detta fält fortfarande stöds, bör :c:macro:`Py_TPFLAGS_MANAGED_DICT` "
"användas istället, om det är möjligt."

#: ../../c-api/typeobj.rst:1914
msgid ""
"If the instances of this type have a dictionary containing instance "
"variables, this field is non-zero and contains the offset in the instances "
"of the type of the instance variable dictionary; this offset is used by :c:"
"func:`PyObject_GenericGetAttr`."
msgstr ""
"Om instanserna av denna typ har en ordbok som innehåller instansvariabler, "
"är detta fält icke-noll och innehåller offset i instanserna av typen av "
"instansvariabelordboken; denna offset används av :c:func:"
"`PyObject_GenericGetAttr`."

#: ../../c-api/typeobj.rst:1919
msgid ""
"Do not confuse this field with :c:member:`~PyTypeObject.tp_dict`; that is "
"the dictionary for attributes of the type object itself."
msgstr ""
"Förväxla inte detta fält med :c:member:`~PyTypeObject.tp_dict`; det är "
"ordlistan för attribut för själva typobjektet."

#: ../../c-api/typeobj.rst:1922
msgid ""
"The value specifies the offset of the dictionary from the start of the "
"instance structure."
msgstr "Värdet anger ordbokens förskjutning från början av instansstrukturen."

#: ../../c-api/typeobj.rst:1924
msgid ""
"The :c:member:`~PyTypeObject.tp_dictoffset` should be regarded as write-"
"only. To get the pointer to the dictionary call :c:func:"
"`PyObject_GenericGetDict`. Calling :c:func:`PyObject_GenericGetDict` may "
"need to allocate memory for the dictionary, so it is may be more efficient "
"to call :c:func:`PyObject_GetAttr` when accessing an attribute on the object."
msgstr ""
":c:member:`~PyTypeObject.tp_dictoffset` bör betraktas som skrivskyddad. För "
"att få pekaren till ordlistan anropa :c:func:`PyObject_GenericGetDict`. "
"Anrop av :c:func:`PyObject_GenericGetDict` kan behöva allokera minne för "
"ordlistan, så det kan vara mer effektivt att anropa :c:func:"
"`PyObject_GetAttr` när man vill komma åt ett attribut på objektet."

#: ../../c-api/typeobj.rst:1930
msgid ""
"It is an error to set both the :c:macro:`Py_TPFLAGS_MANAGED_DICT` bit and :c:"
"member:`~PyTypeObject.tp_dictoffset`."
msgstr ""
"Det är ett fel att ange både :c:macro:`Py_TPFLAGS_MANAGED_DICT` bit och :c:"
"member:`~PyTypeObject.tp_dictoffset`."

#: ../../c-api/typeobj.rst:1935
msgid ""
"This field is inherited by subtypes. A subtype should not override this "
"offset; doing so could be unsafe, if C code tries to access the dictionary "
"at the previous offset. To properly support inheritance, use :c:macro:"
"`Py_TPFLAGS_MANAGED_DICT`."
msgstr ""
"Detta fält ärvs av subtyper. En subtyp bör inte åsidosätta denna offset; det "
"kan vara osäkert om C-kod försöker komma åt ordboken vid den tidigare "
"offset. För att korrekt stödja arv, använd :c:macro:"
"`Py_TPFLAGS_MANAGED_DICT`."

#: ../../c-api/typeobj.rst:1942
msgid ""
"This slot has no default.  For :ref:`static types <static-types>`, if the "
"field is ``NULL`` then no :attr:`~object.__dict__` gets created for "
"instances."
msgstr ""
"Denna slot har ingen standard.  För :ref:``static types <static-types>``, om "
"fältet är ``NULL`` så skapas ingen :attr:`~object.__dict__` för instanser."

#: ../../c-api/typeobj.rst:1945
msgid ""
"If the :c:macro:`Py_TPFLAGS_MANAGED_DICT` bit is set in the :c:member:"
"`~PyTypeObject.tp_flags` field, then :c:member:`~PyTypeObject.tp_dictoffset` "
"will be set to ``-1``, to indicate that it is unsafe to use this field."
msgstr ""
"Om bitarna :c:macro:`Py_TPFLAGS_MANAGED_DICT` är inställda i fältet :c:"
"member:`~PyTypeObject.tp_flags`, så kommer :c:member:`~PyTypeObject."
"tp_dictoffset` att sättas till ``-1``, för att indikera att det är osäkert "
"att använda detta fält."

#: ../../c-api/typeobj.rst:1955
msgid "An optional pointer to an instance initialization function."
msgstr "En valfri pekare till en instansinitialiseringsfunktion."

#: ../../c-api/typeobj.rst:1957
msgid ""
"This function corresponds to the :meth:`~object.__init__` method of "
"classes.  Like :meth:`!__init__`, it is possible to create an instance "
"without calling :meth:`!__init__`, and it is possible to reinitialize an "
"instance by calling its :meth:`!__init__` method again."
msgstr ""
"Denna funktion motsvarar metoden :meth:`~object.__init__` för klasser.  "
"Precis som :meth:`!__init__` är det möjligt att skapa en instans utan att "
"anropa :meth:`!__init__`, och det är möjligt att återinitialisera en instans "
"genom att anropa dess :meth:`!__init__`-metod igen."

#: ../../c-api/typeobj.rst:1964
msgid "int tp_init(PyObject *self, PyObject *args, PyObject *kwds);"
msgstr "int tp_init(PyObject *self, PyObject *args, PyObject *kwds);"

#: ../../c-api/typeobj.rst:1966
msgid ""
"The self argument is the instance to be initialized; the *args* and *kwds* "
"arguments represent positional and keyword arguments of the call to :meth:"
"`~object.__init__`."
msgstr ""
"Argumentet self är den instans som ska initialiseras; argumenten *args* och "
"*kwds* representerar positions- och nyckelordsargument för anropet till :"
"meth:`~object.__init__`."

#: ../../c-api/typeobj.rst:1970
msgid ""
"The :c:member:`~PyTypeObject.tp_init` function, if not ``NULL``, is called "
"when an instance is created normally by calling its type, after the type's :"
"c:member:`~PyTypeObject.tp_new` function has returned an instance of the "
"type.  If the :c:member:`~PyTypeObject.tp_new` function returns an instance "
"of some other type that is not a subtype of the original type, no :c:member:"
"`~PyTypeObject.tp_init` function is called; if :c:member:`~PyTypeObject."
"tp_new` returns an instance of a subtype of the original type, the "
"subtype's :c:member:`~PyTypeObject.tp_init` is called."
msgstr ""
"Funktionen :c:member:`~PyTypeObject.tp_init`, om den inte är ``NULL``, "
"anropas när en instans skapas normalt genom att anropa dess typ, efter att "
"typens funktion :c:member:`~PyTypeObject.tp_new` har returnerat en instans "
"av typen.  Om funktionen :c:member:`~PyTypeObject.tp_new` returnerar en "
"instans av någon annan typ som inte är en subtyp av den ursprungliga typen "
"anropas ingen funktion :c:member:`~PyTypeObject.tp_init`; om :c:member:"
"`~PyTypeObject.tp_new` returnerar en instans av en subtyp av den "
"ursprungliga typen anropas subtypens funktion :c:member:`~PyTypeObject."
"tp_init`."

#: ../../c-api/typeobj.rst:1977
msgid "Returns ``0`` on success, ``-1`` and sets an exception on error."
msgstr "Returnerar ``0`` vid framgång, ``-1`` och anger ett undantag vid fel."

#: ../../c-api/typeobj.rst:1985
msgid ""
"For :ref:`static types <static-types>` this field does not have a default."
msgstr "För :ref:`static types <static-types>` har detta fält ingen standard."

#: ../../c-api/typeobj.rst:1992
msgid "An optional pointer to an instance allocation function."
msgstr "En valfri pekare till en funktion för instansallokering."

#: ../../c-api/typeobj.rst:1996
msgid "PyObject *tp_alloc(PyTypeObject *self, Py_ssize_t nitems);"
msgstr "PyObject *tp_alloc(PyTypeObject *self, Py_ssize_t nitems);"

#: ../../c-api/typeobj.rst:2000
msgid ""
"This field is inherited by static subtypes, but not by dynamic subtypes "
"(subtypes created by a class statement)."
msgstr ""

#: ../../c-api/typeobj.rst:2005
msgid ""
"For dynamic subtypes, this field is always set to :c:func:"
"`PyType_GenericAlloc`, to force a standard heap allocation strategy."
msgstr ""

#: ../../c-api/typeobj.rst:2009
msgid ""
"For static subtypes, :c:data:`PyBaseObject_Type` uses :c:func:"
"`PyType_GenericAlloc`.  That is the recommended value for all statically "
"defined types."
msgstr ""

#: ../../c-api/typeobj.rst:2018
msgid "An optional pointer to an instance creation function."
msgstr "En valfri pekare till en funktion för att skapa en instans."

#: ../../c-api/typeobj.rst:2022
msgid ""
"PyObject *tp_new(PyTypeObject *subtype, PyObject *args, PyObject *kwds);"
msgstr ""
"PyObject *tp_new(PyTypeObject *subtype, PyObject *args, PyObject *kwds);"

#: ../../c-api/typeobj.rst:2024
msgid ""
"The *subtype* argument is the type of the object being created; the *args* "
"and *kwds* arguments represent positional and keyword arguments of the call "
"to the type.  Note that *subtype* doesn't have to equal the type whose :c:"
"member:`~PyTypeObject.tp_new` function is called; it may be a subtype of "
"that type (but not an unrelated type)."
msgstr ""
"Argumentet *subtype* är typen av det objekt som skapas; argumenten *args* "
"och *kwds* representerar positions- och nyckelordsargument i anropet till "
"typen.  Observera att *subtype* inte behöver vara lika med den typ vars :c:"
"member:`~PyTypeObject.tp_new`-funktion anropas; det kan vara en subtyp av "
"den typen (men inte en orelaterad typ)."

#: ../../c-api/typeobj.rst:2030
msgid ""
"The :c:member:`~PyTypeObject.tp_new` function should call ``subtype-"
">tp_alloc(subtype, nitems)`` to allocate space for the object, and then do "
"only as much further initialization as is absolutely necessary.  "
"Initialization that can safely be ignored or repeated should be placed in "
"the :c:member:`~PyTypeObject.tp_init` handler.  A good rule of thumb is that "
"for immutable types, all initialization should take place in :c:member:"
"`~PyTypeObject.tp_new`, while for mutable types, most initialization should "
"be deferred to :c:member:`~PyTypeObject.tp_init`."
msgstr ""
"Funktionen :c:member:`~PyTypeObject.tp_new` bör anropa ``subtype-"
">tp_alloc(subtype, nitems)`` för att allokera utrymme för objektet, och "
"sedan bara göra så mycket ytterligare initialisering som är absolut "
"nödvändigt.  Initialisering som säkert kan ignoreras eller upprepas bör "
"placeras i handlaren :c:member:`~PyTypeObject.tp_init`.  En bra tumregel är "
"att för oföränderliga typer bör all initialisering ske i :c:member:"
"`~PyTypeObject.tp_new`, medan för föränderliga typer bör de flesta "
"initialiseringar skjutas upp till :c:member:`~PyTypeObject.tp_init`."

#: ../../c-api/typeobj.rst:2038
msgid ""
"Set the :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION` flag to disallow "
"creating instances of the type in Python."
msgstr ""
"Ange flaggan :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION` för att inte "
"tillåta att instanser av typen skapas i Python."

#: ../../c-api/typeobj.rst:2043
msgid ""
"This field is inherited by subtypes, except it is not inherited by :ref:"
"`static types <static-types>` whose :c:member:`~PyTypeObject.tp_base` is "
"``NULL`` or ``&PyBaseObject_Type``."
msgstr ""
"Detta fält ärvs av subtyper, förutom att det inte ärvs av :ref:`static types "
"<static-types>` vars :c:member:`~PyTypeObject.tp_base` är ``NULL`` eller "
"``&amp;PyBaseObject_Type``."

#: ../../c-api/typeobj.rst:2049
msgid ""
"For :ref:`static types <static-types>` this field has no default. This means "
"if the slot is defined as ``NULL``, the type cannot be called to create new "
"instances; presumably there is some other way to create instances, like a "
"factory function."
msgstr ""
"För :ref:`static types <static-types>` har detta fält ingen standard. Detta "
"innebär att om slot definieras som ``NULL`` kan typen inte anropas för att "
"skapa nya instanser; förmodligen finns det något annat sätt att skapa "
"instanser, som en fabriksfunktion."

#: ../../c-api/typeobj.rst:2059
msgid ""
"An optional pointer to an instance deallocation function.  Its signature is::"
msgstr ""
"En valfri pekare till en funktion för avallokering av instanser.  Dess "
"signatur är::"

#: ../../c-api/typeobj.rst:2061
msgid "void tp_free(void *self);"
msgstr "void tp_free(void *self);"

#: ../../c-api/typeobj.rst:2063
msgid ""
"An initializer that is compatible with this signature is :c:func:"
"`PyObject_Free`."
msgstr ""

#: ../../c-api/typeobj.rst:2067
msgid ""
"This field is inherited by static subtypes, but not by dynamic subtypes "
"(subtypes created by a class statement)"
msgstr ""

#: ../../c-api/typeobj.rst:2072
msgid ""
"In dynamic subtypes, this field is set to a deallocator suitable to match :c:"
"func:`PyType_GenericAlloc` and the value of the :c:macro:"
"`Py_TPFLAGS_HAVE_GC` flag bit."
msgstr ""

#: ../../c-api/typeobj.rst:2076
msgid ""
"For static subtypes, :c:data:`PyBaseObject_Type` uses :c:func:`PyObject_Del`."
msgstr ""

#: ../../c-api/typeobj.rst:2083
msgid "An optional pointer to a function called by the garbage collector."
msgstr "En valfri pekare till en funktion som anropas av skräpsamlaren."

#: ../../c-api/typeobj.rst:2085
msgid ""
"The garbage collector needs to know whether a particular object is "
"collectible or not.  Normally, it is sufficient to look at the object's "
"type's :c:member:`~PyTypeObject.tp_flags` field, and check the :c:macro:"
"`Py_TPFLAGS_HAVE_GC` flag bit.  But some types have a mixture of statically "
"and dynamically allocated instances, and the statically allocated instances "
"are not collectible.  Such types should define this function; it should "
"return ``1`` for a collectible instance, and ``0`` for a non-collectible "
"instance. The signature is::"
msgstr ""
"Garbage collector behöver veta om ett visst objekt är insamlingsbart eller "
"inte.  Normalt räcker det att titta på objekttypens fält :c:member:"
"`~PyTypeObject.tp_flags` och kontrollera flaggbiten :c:macro:"
"`Py_TPFLAGS_HAVE_GC`.  Men vissa typer har en blandning av statiskt och "
"dynamiskt allokerade instanser, och de statiskt allokerade instanserna är "
"inte insamlingsbara.  Sådana typer bör definiera denna funktion; den bör "
"returnera ``1`` för en samlingsbar instans och ``0`` för en icke-samlingsbar "
"instans. Signaturen är::"

#: ../../c-api/typeobj.rst:2093
msgid "int tp_is_gc(PyObject *self);"
msgstr "int tp_is_gc(PyObject *self);"

#: ../../c-api/typeobj.rst:2095
msgid ""
"(The only example of this are types themselves.  The metatype, :c:data:"
"`PyType_Type`, defines this function to distinguish between statically and :"
"ref:`dynamically allocated types <heap-types>`.)"
msgstr ""
"(Det enda exemplet på detta är typerna själva.  Metatypen, :c:data:"
"`PyType_Type`, definierar den här funktionen för att skilja mellan statiskt "
"och :ref:`dynamiskt allokerade typer <heap-types>`.)"

#: ../../c-api/typeobj.rst:2105
msgid ""
"This slot has no default.  If this field is ``NULL``, :c:macro:"
"`Py_TPFLAGS_HAVE_GC` is used as the functional equivalent."
msgstr ""
"Denna slot har ingen standard.  Om detta fält är ``NULL``, används :c:macro:"
"`Py_TPFLAGS_HAVE_GC` som funktionell motsvarighet."

#: ../../c-api/typeobj.rst:2113
msgid "Tuple of base types."
msgstr "Tupel av bastyper."

#: ../../c-api/typeobj.rst:2115 ../../c-api/typeobj.rst:2139
msgid ""
"This field should be set to ``NULL`` and treated as read-only. Python will "
"fill it in when the type is :c:func:`initialized <PyType_Ready>`."
msgstr ""
"Detta fält bör sättas till ``NULL`` och behandlas som skrivskyddat. Python "
"kommer att fylla i det när typen är :c:func:`initialiserad <PyType_Ready>`."

#: ../../c-api/typeobj.rst:2118
msgid ""
"For dynamically created classes, the ``Py_tp_bases`` :c:type:`slot "
"<PyType_Slot>` can be used instead of the *bases* argument of :c:func:"
"`PyType_FromSpecWithBases`. The argument form is preferred."
msgstr ""
"För dynamiskt skapade klasser kan ``Py_tp_bases`` :c:type:`slot "
"<PyType_Slot>` användas istället för *bases*-argumentet i :c:func:"
"`PyType_FromSpecWithBases`. Argumentformen är att föredra."

#: ../../c-api/typeobj.rst:2125
msgid ""
"Multiple inheritance does not work well for statically defined types. If you "
"set ``tp_bases`` to a tuple, Python will not raise an error, but some slots "
"will only be inherited from the first base."
msgstr ""
"Multipel nedärvning fungerar inte bra för statiskt definierade typer. Om du "
"ställer in ``tp_bases`` till en tupel kommer Python inte att ge upphov till "
"ett fel, men vissa slots kommer endast att ärvas från den första basen."

#: ../../c-api/typeobj.rst:2131 ../../c-api/typeobj.rst:2154
#: ../../c-api/typeobj.rst:2171 ../../c-api/typeobj.rst:2188
#: ../../c-api/typeobj.rst:2204
msgid "This field is not inherited."
msgstr "Detta fält är inte ärftligt."

#: ../../c-api/typeobj.rst:2136
msgid ""
"Tuple containing the expanded set of base types, starting with the type "
"itself and ending with :class:`object`, in Method Resolution Order."
msgstr ""
"Tupel som innehåller den utökade uppsättningen bastyper, som börjar med "
"typen själv och slutar med :class:`object`, i Method Resolution Order."

#: ../../c-api/typeobj.rst:2144
msgid ""
"This field is not inherited; it is calculated fresh by :c:func:"
"`PyType_Ready`."
msgstr "Detta fält är inte ärftligt, utan beräknas av :c:func:`PyType_Ready`."

#: ../../c-api/typeobj.rst:2150
msgid "Unused.  Internal use only."
msgstr "Oanvänd.  Endast för internt bruk."

#: ../../c-api/typeobj.rst:2159
msgid ""
"A collection of subclasses.  Internal use only.  May be an invalid pointer."
msgstr ""
"En samling av underklasser.  Endast för internt bruk.  Kan vara en ogiltig "
"pekare."

#: ../../c-api/typeobj.rst:2161
msgid ""
"To get a list of subclasses, call the Python method :py:meth:`~type."
"__subclasses__`."
msgstr ""
"För att få en lista över underklasser anropar du Python-metoden :py:meth:"
"`~type.__subclasses__`."

#: ../../c-api/typeobj.rst:2166
msgid ""
"For some types, this field does not hold a valid :c:expr:`PyObject*`. The "
"type was changed to :c:expr:`void*` to indicate this."
msgstr ""
"För vissa typer innehåller detta fält inte ett giltigt :c:expr:`PyObject*`. "
"Typen ändrades till :c:expr:`void*` för att ange detta."

#: ../../c-api/typeobj.rst:2176
msgid ""
"Weak reference list head, for weak references to this type object.  Not "
"inherited.  Internal use only."
msgstr ""
"Svag referenslistans huvud, för svaga referenser till detta typobjekt.  Ärvs "
"inte.  Endast för internt bruk."

#: ../../c-api/typeobj.rst:2181
msgid ""
"Internals detail: For the static builtin types this is always ``NULL``, even "
"if weakrefs are added.  Instead, the weakrefs for each are stored on "
"``PyInterpreterState``.  Use the public C-API or the internal "
"``_PyObject_GET_WEAKREFS_LISTPTR()`` macro to avoid the distinction."
msgstr ""
"Intern detalj: För de statiska inbyggda typerna är detta alltid ``NULL``, "
"även om weakrefs läggs till.  Istället lagras weakrefs för var och en på "
"``PyInterpreterState``.  Använd det publika C-API:et eller det interna "
"makrot ``_PyObject_GET_WEAKREFS_LISTPTR()`` för att undvika skillnaden."

#: ../../c-api/typeobj.rst:2195
msgid ""
"This field is deprecated.  Use :c:member:`~PyTypeObject.tp_finalize` instead."
msgstr ""
"Detta fält är föråldrat.  Använd :c:member:`~PyTypeObject.tp_finalize` "
"istället."

#: ../../c-api/typeobj.rst:2200
msgid "Used to index into the method cache.  Internal use only."
msgstr "Används för att indexera till metodcachen.  Endast för internt bruk."

#: ../../c-api/typeobj.rst:2211
msgid ""
"An optional pointer to an instance finalization function.  This is the C "
"implementation of the :meth:`~object.__del__` special method.  Its signature "
"is::"
msgstr ""
"En valfri pekare till en funktion för att avsluta en instans.  Detta är C-"
"implementeringen av specialmetoden :meth:`~object.__del__`.  Dess signatur "
"är::"

#: ../../c-api/typeobj.rst:2215
msgid "void tp_finalize(PyObject *self);"
msgstr "void tp_finalize(PyObject *self);"

#: ../../c-api/typeobj.rst:2217
msgid ""
"If :c:member:`~PyTypeObject.tp_finalize` is set, the interpreter calls it "
"once when finalizing an instance.  It is called either from the garbage "
"collector (if the instance is part of an isolated reference cycle) or just "
"before the object is deallocated.  Either way, it is guaranteed to be called "
"before attempting to break reference cycles, ensuring that it finds the "
"object in a sane state."
msgstr ""

#: ../../c-api/typeobj.rst:2224
msgid ""
":c:member:`~PyTypeObject.tp_finalize` should not mutate the current "
"exception status; therefore, a recommended way to write a non-trivial "
"finalizer is::"
msgstr ""

#: ../../c-api/typeobj.rst:2227
msgid ""
"static void\n"
"local_finalize(PyObject *self)\n"
"{\n"
"    /* Save the current exception, if any. */\n"
"    PyObject *exc = PyErr_GetRaisedException();\n"
"\n"
"    /* ... */\n"
"\n"
"    /* Restore the saved exception. */\n"
"    PyErr_SetRaisedException(exc);\n"
"}"
msgstr ""

#: ../../c-api/typeobj.rst:2247
msgid ""
"Before version 3.8 it was necessary to set the :c:macro:"
"`Py_TPFLAGS_HAVE_FINALIZE` flags bit in order for this field to be used.  "
"This is no longer required."
msgstr ""
"Före version 3.8 var det nödvändigt att sätta flaggbiten :c:macro:"
"`Py_TPFLAGS_HAVE_FINALIZE` för att detta fält skulle kunna användas.  Detta "
"är inte längre nödvändigt."

#: ../../c-api/typeobj.rst:2251
msgid "\"Safe object finalization\" (:pep:`442`)"
msgstr ""

#: ../../c-api/typeobj.rst:2256
msgid ""
"Vectorcall function to use for calls of this type object. In other words, it "
"is used to implement :ref:`vectorcall <vectorcall>` for ``type.__call__``. "
"If ``tp_vectorcall`` is ``NULL``, the default call implementation using :"
"meth:`~object.__new__` and :meth:`~object.__init__` is used."
msgstr ""

#: ../../c-api/typeobj.rst:2264
msgid "This field is never inherited."
msgstr "Detta fält är aldrig ärftligt."

#: ../../c-api/typeobj.rst:2266
msgid "(the field exists since 3.8 but it's only used since 3.9)"
msgstr "(fältet har funnits sedan 3.8 men det används bara sedan 3.9)"

#: ../../c-api/typeobj.rst:2271
msgid "Internal. Do not use."
msgstr "Internt. Får inte användas."

#: ../../c-api/typeobj.rst:2279
msgid "Static Types"
msgstr "Statiska typer"

#: ../../c-api/typeobj.rst:2281
msgid ""
"Traditionally, types defined in C code are *static*, that is, a static :c:"
"type:`PyTypeObject` structure is defined directly in code and initialized "
"using :c:func:`PyType_Ready`."
msgstr ""
"Traditionellt är typer som definieras i C-kod *statiska*, det vill säga en "
"statisk :c:type:`PyTypeObject`-struktur definieras direkt i koden och "
"initieras med :c:func:`PyType_Ready`."

#: ../../c-api/typeobj.rst:2285
msgid ""
"This results in types that are limited relative to types defined in Python:"
msgstr ""
"Detta resulterar i typer som är begränsade i förhållande till de typer som "
"definieras i Python:"

#: ../../c-api/typeobj.rst:2287
msgid ""
"Static types are limited to one base, i.e. they cannot use multiple "
"inheritance."
msgstr ""
"Statiska typer är begränsade till en bas, dvs. de kan inte använda multipel "
"nedärvning."

#: ../../c-api/typeobj.rst:2289
msgid ""
"Static type objects (but not necessarily their instances) are immutable. It "
"is not possible to add or modify the type object's attributes from Python."
msgstr ""
"Statiska typobjekt (men inte nödvändigtvis deras instanser) är "
"oföränderliga. Det är inte möjligt att lägga till eller ändra typobjektets "
"attribut från Python."

#: ../../c-api/typeobj.rst:2291
msgid ""
"Static type objects are shared across :ref:`sub-interpreters <sub-"
"interpreter-support>`, so they should not include any subinterpreter-"
"specific state."
msgstr ""
"Statiska typobjekt delas mellan :ref:`undertolkare <sub-interpreter-"
"support>`, så de bör inte innehålla något undertolkarspecifikt tillstånd."

#: ../../c-api/typeobj.rst:2295
msgid ""
"Also, since :c:type:`PyTypeObject` is only part of the :ref:`Limited API "
"<limited-c-api>` as an opaque struct, any extension modules using static "
"types must be compiled for a specific Python minor version."
msgstr ""
"Eftersom :c:type:`PyTypeObject` endast är en del av :ref:`Limited API "
"<limited-c-api>` som en opak struktur, måste alla tilläggsmoduler som "
"använder statiska typer kompileras för en specifik mindre Python-version."

#: ../../c-api/typeobj.rst:2303
msgid "Heap Types"
msgstr "Typer av högar"

#: ../../c-api/typeobj.rst:2305
msgid ""
"An alternative to :ref:`static types <static-types>` is *heap-allocated "
"types*, or *heap types* for short, which correspond closely to classes "
"created by Python's ``class`` statement. Heap types have the :c:macro:"
"`Py_TPFLAGS_HEAPTYPE` flag set."
msgstr ""
"Ett alternativ till :ref:``static types <static-types>`` är *heap-allocated "
"types*, eller kort och gott *heap types*, som nära motsvarar klasser skapade "
"av Pythons ``class``-sats. Heap-typer har flaggan :c:macro:"
"`Py_TPFLAGS_HEAPTYPE` inställd."

#: ../../c-api/typeobj.rst:2310
msgid ""
"This is done by filling a :c:type:`PyType_Spec` structure and calling :c:"
"func:`PyType_FromSpec`, :c:func:`PyType_FromSpecWithBases`, :c:func:"
"`PyType_FromModuleAndSpec`, or :c:func:`PyType_FromMetaclass`."
msgstr ""
"Detta görs genom att fylla en :c:type:`PyType_Spec`-struktur och anropa :c:"
"func:`PyType_FromSpec`, :c:func:`PyType_FromSpecWithBases`, :c:func:"
"`PyType_FromModuleAndSpec`, eller :c:func:`PyType_FromMetaclass`."

#: ../../c-api/typeobj.rst:2318
msgid "Number Object Structures"
msgstr "Strukturer för nummerobjekt"

#: ../../c-api/typeobj.rst:2325
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the number protocol.  Each function is used by the function of "
"similar name documented in the :ref:`number` section."
msgstr ""
"Denna struktur innehåller pekare till de funktioner som ett objekt använder "
"för att implementera nummerprotokollet.  Varje funktion används av "
"funktionen med liknande namn som dokumenteras i avsnittet :ref:`number`."

#: ../../c-api/typeobj.rst:2331 ../../c-api/typeobj.rst:2787
msgid "Here is the structure definition::"
msgstr "Här är strukturdefinitionen::"

#: ../../c-api/typeobj.rst:2333
msgid ""
"typedef struct {\n"
"     binaryfunc nb_add;\n"
"     binaryfunc nb_subtract;\n"
"     binaryfunc nb_multiply;\n"
"     binaryfunc nb_remainder;\n"
"     binaryfunc nb_divmod;\n"
"     ternaryfunc nb_power;\n"
"     unaryfunc nb_negative;\n"
"     unaryfunc nb_positive;\n"
"     unaryfunc nb_absolute;\n"
"     inquiry nb_bool;\n"
"     unaryfunc nb_invert;\n"
"     binaryfunc nb_lshift;\n"
"     binaryfunc nb_rshift;\n"
"     binaryfunc nb_and;\n"
"     binaryfunc nb_xor;\n"
"     binaryfunc nb_or;\n"
"     unaryfunc nb_int;\n"
"     void *nb_reserved;\n"
"     unaryfunc nb_float;\n"
"\n"
"     binaryfunc nb_inplace_add;\n"
"     binaryfunc nb_inplace_subtract;\n"
"     binaryfunc nb_inplace_multiply;\n"
"     binaryfunc nb_inplace_remainder;\n"
"     ternaryfunc nb_inplace_power;\n"
"     binaryfunc nb_inplace_lshift;\n"
"     binaryfunc nb_inplace_rshift;\n"
"     binaryfunc nb_inplace_and;\n"
"     binaryfunc nb_inplace_xor;\n"
"     binaryfunc nb_inplace_or;\n"
"\n"
"     binaryfunc nb_floor_divide;\n"
"     binaryfunc nb_true_divide;\n"
"     binaryfunc nb_inplace_floor_divide;\n"
"     binaryfunc nb_inplace_true_divide;\n"
"\n"
"     unaryfunc nb_index;\n"
"\n"
"     binaryfunc nb_matrix_multiply;\n"
"     binaryfunc nb_inplace_matrix_multiply;\n"
"} PyNumberMethods;"
msgstr ""
"typedef struct {\n"
"     binärfunktion nb_add;\n"
"     binärfunktion nb_subtrahera;\n"
"     binärfunktion nb_multiplicera;\n"
"     binaryfunc nb_remainder;\n"
"     binärfunktion nb_divmod;\n"
"     ternaryfunc nb_power;\n"
"     unaryfunc nb_negative;\n"
"     unaryfunc nb_positive;\n"
"     unaryfunc nb_absolute;\n"
"     förfrågan nb_bool;\n"
"     unaryfunc nb_invert;\n"
"     binärfunktion nb_lshift;\n"
"     binaryfunc nb_rshift;\n"
"     binärfunktion nb_and;\n"
"     binärfunktion nb_xor;\n"
"     binärfunktion nb_or;\n"
"     unaryfunc nb_int;\n"
"     void *nb_reserved;\n"
"     unaryfunc nb_float;\n"
"\n"
"     binärfunktion nb_inplace_add;\n"
"     binaryfunc nb_inplace_subtract;\n"
"     binärfunktion nb_inplace_multiplicera;\n"
"     binärfunktion nb_inplace_remainder;\n"
"     ternaryfunc nb_inplace_power;\n"
"     binärfunktion nb_inplace_lshift;\n"
"     binärfunktion nb_inplace_rshift;\n"
"     binärfunktion nb_inplace_and;\n"
"     binärfunktion nb_inplace_xor;\n"
"     binärfunktion nb_inplace_or;\n"
"\n"
"     binärfunktion nb_floor_divide;\n"
"     binaryfunc nb_true_divide;\n"
"     binaryfunc nb_inplace_floor_divide;\n"
"     binaryfunc nb_inplace_true_divide;\n"
"\n"
"     unaryfunc nb_index;\n"
"\n"
"     binärfunktion nb_matris_multiplicera;\n"
"     binärfunktion nb_inplace_matrix_multiply;\n"
"} PyNumberMethods;"

#: ../../c-api/typeobj.rst:2378
msgid ""
"Binary and ternary functions must check the type of all their operands, and "
"implement the necessary conversions (at least one of the operands is an "
"instance of the defined type).  If the operation is not defined for the "
"given operands, binary and ternary functions must return "
"``Py_NotImplemented``, if another error occurred they must return ``NULL`` "
"and set an exception."
msgstr ""
"Binära och ternära funktioner måste kontrollera typen av alla sina operander "
"och implementera nödvändiga konverteringar (minst en av operanderna är en "
"instans av den definierade typen).  Om operationen inte är definierad för de "
"givna operanderna måste binära och ternära funktioner returnera "
"``Py_NotImplemented``, om ett annat fel inträffade måste de returnera "
"``NULL`` och ange ett undantag."

#: ../../c-api/typeobj.rst:2387
msgid ""
"The :c:member:`~PyNumberMethods.nb_reserved` field should always be "
"``NULL``.  It was previously called :c:member:`!nb_long`, and was renamed in "
"Python 3.0.1."
msgstr ""
"Fältet :c:member:`~PyNumberMethods.nb_reserved` bör alltid vara ``NULL``.  "
"Det kallades tidigare :c:member:`!nb_long`, och döptes om i Python 3.0.1."

#: ../../c-api/typeobj.rst:2538
msgid "Mapping Object Structures"
msgstr "Mappning av objektstrukturer"

#: ../../c-api/typeobj.rst:2545
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the mapping protocol.  It has three members:"
msgstr ""
"Denna struktur innehåller pekare till de funktioner som ett objekt använder "
"för att implementera mappningsprotokollet.  Den har tre medlemmar:"

#: ../../c-api/typeobj.rst:2552
msgid ""
"This function is used by :c:func:`PyMapping_Size` and :c:func:"
"`PyObject_Size`, and has the same signature.  This slot may be set to "
"``NULL`` if the object has no defined length."
msgstr ""
"Denna funktion används av :c:func:`PyMapping_Size` och :c:func:"
"`PyObject_Size`, och har samma signatur.  Denna slot kan sättas till "
"``NULL`` om objektet inte har någon definierad längd."

#: ../../c-api/typeobj.rst:2560
msgid ""
"This function is used by :c:func:`PyObject_GetItem` and :c:func:"
"`PySequence_GetSlice`, and has the same signature as :c:func:`!"
"PyObject_GetItem`.  This slot must be filled for the :c:func:"
"`PyMapping_Check` function to return ``1``, it can be ``NULL`` otherwise."
msgstr ""
"Denna funktion används av :c:func:`PyObject_GetItem` och :c:func:"
"`PySequence_GetSlice`, och har samma signatur som :c:func:`!"
"PyObject_GetItem`.  Denna slot måste vara fylld för att funktionen :c:func:"
"`PyMapping_Check` ska returnera ``1``, annars kan den vara ``NULL``."

#: ../../c-api/typeobj.rst:2570
msgid ""
"This function is used by :c:func:`PyObject_SetItem`, :c:func:"
"`PyObject_DelItem`, :c:func:`PySequence_SetSlice` and :c:func:"
"`PySequence_DelSlice`.  It has the same signature as :c:func:`!"
"PyObject_SetItem`, but *v* can also be set to ``NULL`` to delete an item.  "
"If this slot is ``NULL``, the object does not support item assignment and "
"deletion."
msgstr ""
"Denna funktion används av :c:func:`PyObject_SetItem`, :c:func:"
"`PyObject_DelItem`, :c:func:`PySequence_SetSlice` och :c:func:"
"`PySequence_DelSlice`.  Den har samma signatur som :c:func:`!"
"PyObject_SetItem`, men *v* kan också sättas till ``NULL`` för att radera ett "
"objekt.  Om denna slot är ``NULL`` har objektet inte stöd för tilldelning "
"och borttagning av objekt."

#: ../../c-api/typeobj.rst:2581
msgid "Sequence Object Structures"
msgstr "Strukturer för sekvensobjekt"

#: ../../c-api/typeobj.rst:2588
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the sequence protocol."
msgstr ""
"Denna struktur innehåller pekare till de funktioner som ett objekt använder "
"för att implementera sekvensprotokollet."

#: ../../c-api/typeobj.rst:2595
msgid ""
"This function is used by :c:func:`PySequence_Size` and :c:func:"
"`PyObject_Size`, and has the same signature.  It is also used for handling "
"negative indices via the :c:member:`~PySequenceMethods.sq_item` and the :c:"
"member:`~PySequenceMethods.sq_ass_item` slots."
msgstr ""
"Denna funktion används av :c:func:`PySequence_Size` och :c:func:"
"`PyObject_Size`, och har samma signatur.  Den används också för att hantera "
"negativa index via :c:member:`~PySequenceMethods.sq_item` och :c:member:"
"`~PySequenceMethods.sq_ass_item`."

#: ../../c-api/typeobj.rst:2604
msgid ""
"This function is used by :c:func:`PySequence_Concat` and has the same "
"signature.  It is also used by the ``+`` operator, after trying the numeric "
"addition via the :c:member:`~PyNumberMethods.nb_add` slot."
msgstr ""
"Denna funktion används av :c:func:`PySequence_Concat` och har samma "
"signatur.  Den används också av operatorn ``+``, efter att ha försökt "
"numerisk addition via :c:member:`~PyNumberMethods.nb_add` slot."

#: ../../c-api/typeobj.rst:2612
msgid ""
"This function is used by :c:func:`PySequence_Repeat` and has the same "
"signature.  It is also used by the ``*`` operator, after trying numeric "
"multiplication via the :c:member:`~PyNumberMethods.nb_multiply` slot."
msgstr ""
"Denna funktion används av :c:func:`PySequence_Repeat` och har samma "
"signatur.  Den används också av operatorn ``*``, efter att ha försökt "
"numerisk multiplikation via :c:member:`~PyNumberMethods.nb_multiply` slot."

#: ../../c-api/typeobj.rst:2620
msgid ""
"This function is used by :c:func:`PySequence_GetItem` and has the same "
"signature.  It is also used by :c:func:`PyObject_GetItem`, after trying the "
"subscription via the :c:member:`~PyMappingMethods.mp_subscript` slot. This "
"slot must be filled for the :c:func:`PySequence_Check` function to return "
"``1``, it can be ``NULL`` otherwise."
msgstr ""
"Denna funktion används av :c:func:`PySequence_GetItem` och har samma "
"signatur.  Den används också av :c:func:`PyObject_GetItem`, efter att ha "
"provat prenumerationen via :c:member:`~PyMappingMethods.mp_subscript` slot. "
"Denna slot måste vara fylld för att funktionen :c:func:`PySequence_Check` "
"skall returnera ``1``, annars kan den vara ``NULL``."

#: ../../c-api/typeobj.rst:2626
msgid ""
"Negative indexes are handled as follows: if the :c:member:"
"`~PySequenceMethods.sq_length` slot is filled, it is called and the sequence "
"length is used to compute a positive index which is passed to  :c:member:"
"`~PySequenceMethods.sq_item`.  If :c:member:`!sq_length` is ``NULL``, the "
"index is passed as is to the function."
msgstr ""
"Negativa index hanteras på följande sätt: om :c:member:`~PySequenceMethods."
"sq_length` är fylld, anropas den och sekvenslängden används för att beräkna "
"ett positivt index som skickas till :c:member:`~PySequenceMethods.sq_item`.  "
"Om :c:member:`!sq_length` är ``NULL``, skickas indexet som det är till "
"funktionen."

#: ../../c-api/typeobj.rst:2635
msgid ""
"This function is used by :c:func:`PySequence_SetItem` and has the same "
"signature.  It is also used by :c:func:`PyObject_SetItem` and :c:func:"
"`PyObject_DelItem`, after trying the item assignment and deletion via the :c:"
"member:`~PyMappingMethods.mp_ass_subscript` slot. This slot may be left to "
"``NULL`` if the object does not support item assignment and deletion."
msgstr ""
"Denna funktion används av :c:func:`PySequence_SetItem` och har samma "
"signatur.  Den används också av :c:func:`PyObject_SetItem` och :c:func:"
"`PyObject_DelItem`, efter att ha försökt tilldelning och borttagning av "
"objekt via :c:member:`~PyMappingMethods.mp_ass_subscript` slot. Denna slot "
"kan lämnas till ``NULL`` om objektet inte stöder tilldelning och borttagning "
"av objekt."

#: ../../c-api/typeobj.rst:2646
msgid ""
"This function may be used by :c:func:`PySequence_Contains` and has the same "
"signature.  This slot may be left to ``NULL``, in this case :c:func:`!"
"PySequence_Contains` simply traverses the sequence until it finds a match."
msgstr ""
"Denna funktion kan användas av :c:func:`PySequence_Contains` och har samma "
"signatur.  Denna plats kan lämnas till ``NULL``, i detta fall kommer :c:func:"
"`!PySequence_Contains` helt enkelt att korsa sekvensen tills den hittar en "
"matchning."

#: ../../c-api/typeobj.rst:2655
msgid ""
"This function is used by :c:func:`PySequence_InPlaceConcat` and has the same "
"signature.  It should modify its first operand, and return it.  This slot "
"may be left to ``NULL``, in this case :c:func:`!PySequence_InPlaceConcat` "
"will fall back to :c:func:`PySequence_Concat`.  It is also used by the "
"augmented assignment ``+=``, after trying numeric in-place addition via the :"
"c:member:`~PyNumberMethods.nb_inplace_add` slot."
msgstr ""
"Denna funktion används av :c:func:`PySequence_InPlaceConcat` och har samma "
"signatur.  Den bör modifiera sin första operand och returnera den.  Denna "
"plats kan lämnas till ``NULL``, i detta fall kommer :c:func:`!"
"PySequence_InPlaceConcat` att falla tillbaka till :c:func:"
"`PySequence_Concat`.  Den används också av den utökade tilldelningen ``+=``, "
"efter att ha försökt numerisk in-place addition via :c:member:"
"`~PyNumberMethods.nb_inplace_add` slot."

#: ../../c-api/typeobj.rst:2666
msgid ""
"This function is used by :c:func:`PySequence_InPlaceRepeat` and has the same "
"signature.  It should modify its first operand, and return it.  This slot "
"may be left to ``NULL``, in this case :c:func:`!PySequence_InPlaceRepeat` "
"will fall back to :c:func:`PySequence_Repeat`.  It is also used by the "
"augmented assignment ``*=``, after trying numeric in-place multiplication "
"via the :c:member:`~PyNumberMethods.nb_inplace_multiply` slot."
msgstr ""
"Denna funktion används av :c:func:`PySequence_InPlaceRepeat` och har samma "
"signatur.  Den bör modifiera sin första operand och returnera den.  Denna "
"plats kan lämnas till ``NULL``, i detta fall kommer :c:func:`!"
"PySequence_InPlaceRepeat` att falla tillbaka till :c:func:"
"`PySequence_Repeat`.  Den används också av den utökade tilldelningen ``*=``, "
"efter att ha försökt numerisk multiplikation på plats via :c:member:"
"`~PyNumberMethods.nb_inplace_multiply` slot."

#: ../../c-api/typeobj.rst:2677
msgid "Buffer Object Structures"
msgstr "Strukturer för buffertobjekt"

#: ../../c-api/typeobj.rst:2685
msgid ""
"This structure holds pointers to the functions required by the :ref:`Buffer "
"protocol <bufferobjects>`. The protocol defines how an exporter object can "
"expose its internal data to consumer objects."
msgstr ""
"Denna struktur innehåller pekare till de funktioner som krävs enligt :ref:"
"`Buffer protocol <bufferobjects>`. Protokollet definierar hur ett "
"exportobjekt kan exponera sina interna data till konsumentobjekt."

#: ../../c-api/typeobj.rst:2693 ../../c-api/typeobj.rst:2744
#: ../../c-api/typeobj.rst:2800 ../../c-api/typeobj.rst:2813
#: ../../c-api/typeobj.rst:2827 ../../c-api/typeobj.rst:2839
msgid "The signature of this function is::"
msgstr "Signaturen för denna funktion är::"

#: ../../c-api/typeobj.rst:2695
msgid "int (PyObject *exporter, Py_buffer *view, int flags);"
msgstr "int (PyObject *exporter, Py_buffer *view, int flags);"

#: ../../c-api/typeobj.rst:2697
msgid ""
"Handle a request to *exporter* to fill in *view* as specified by *flags*. "
"Except for point (3), an implementation of this function MUST take these "
"steps:"
msgstr ""
"Hantera en begäran till *exporter* om att fylla i *view* enligt "
"specifikationen i *flags*. Med undantag för punkt (3) MÅSTE en "
"implementering av denna funktion vidta följande steg:"

#: ../../c-api/typeobj.rst:2701
msgid ""
"Check if the request can be met. If not, raise :exc:`BufferError`, set :c:"
"expr:`view->obj` to ``NULL`` and return ``-1``."
msgstr ""
"Kontrollera om begäran kan uppfyllas. Om inte, skapa :exc:`BufferError`, "
"sätt :c:expr:`view->obj` till ``NULL`` och returnera ``-1``."

#: ../../c-api/typeobj.rst:2704
msgid "Fill in the requested fields."
msgstr "Fyll i de begärda fälten."

#: ../../c-api/typeobj.rst:2706
msgid "Increment an internal counter for the number of exports."
msgstr "Öka en intern räknare för antalet exporter."

#: ../../c-api/typeobj.rst:2708
msgid ""
"Set :c:expr:`view->obj` to *exporter* and increment :c:expr:`view->obj`."
msgstr ""
"Sätt :c:expr:`view->obj` till *exporter* och inkrementera :c:expr:`view-"
">obj`."

#: ../../c-api/typeobj.rst:2710
msgid "Return ``0``."
msgstr "Returnera ``0``."

#: ../../c-api/typeobj.rst:2712
msgid ""
"If *exporter* is part of a chain or tree of buffer providers, two main "
"schemes can be used:"
msgstr ""
"Om *exporter* är en del av en kedja eller ett träd av buffertleverantörer "
"kan två huvudsakliga system användas:"

#: ../../c-api/typeobj.rst:2715
msgid ""
"Re-export: Each member of the tree acts as the exporting object and sets :c:"
"expr:`view->obj` to a new reference to itself."
msgstr ""
"Återexportera: Varje medlem i trädet fungerar som det exporterande objektet "
"och sätter :c:expr:`view->obj` till en ny referens till sig själv."

#: ../../c-api/typeobj.rst:2718
msgid ""
"Redirect: The buffer request is redirected to the root object of the tree. "
"Here, :c:expr:`view->obj` will be a new reference to the root object."
msgstr ""
"Redirect: Buffertbegäran omdirigeras till trädets rotobjekt. Här kommer :c:"
"expr:`view->obj` att vara en ny referens till rotobjektet."

#: ../../c-api/typeobj.rst:2722
msgid ""
"The individual fields of *view* are described in section :ref:`Buffer "
"structure <buffer-structure>`, the rules how an exporter must react to "
"specific requests are in section :ref:`Buffer request types <buffer-request-"
"types>`."
msgstr ""
"De enskilda fälten i *view* beskrivs i avsnitt :ref:`Buffertstruktur <buffer-"
"structure>`, reglerna för hur en exportör måste reagera på specifika "
"förfrågningar finns i avsnitt :ref:`Buffertförfrågningstyper <buffer-request-"
"types>`."

#: ../../c-api/typeobj.rst:2727
msgid ""
"All memory pointed to in the :c:type:`Py_buffer` structure belongs to the "
"exporter and must remain valid until there are no consumers left. :c:member:"
"`~Py_buffer.format`, :c:member:`~Py_buffer.shape`, :c:member:`~Py_buffer."
"strides`, :c:member:`~Py_buffer.suboffsets` and :c:member:`~Py_buffer."
"internal` are read-only for the consumer."
msgstr ""
"Allt minne som pekas ut i :c:type:`Py_buffer`-strukturen tillhör exportören "
"och måste förbli giltigt tills det inte finns några konsumenter kvar. :c:"
"member:`~Py_buffer.format`, :c:member:`~Py_buffer.shape`, :c:member:"
"`~Py_buffer.strides`, :c:member:`~Py_buffer.suboffsets` och :c:member:"
"`~Py_buffer.internal` är skrivskyddade för konsumenten."

#: ../../c-api/typeobj.rst:2734
msgid ""
":c:func:`PyBuffer_FillInfo` provides an easy way of exposing a simple bytes "
"buffer while dealing correctly with all request types."
msgstr ""
":c:func:`PyBuffer_FillInfo` ger ett enkelt sätt att exponera en enkel "
"bytesbuffert samtidigt som alla typer av förfrågningar hanteras korrekt."

#: ../../c-api/typeobj.rst:2737
msgid ""
":c:func:`PyObject_GetBuffer` is the interface for the consumer that wraps "
"this function."
msgstr ""
":c:func:`PyObject_GetBuffer` är gränssnittet för den konsument som omsluter "
"denna funktion."

#: ../../c-api/typeobj.rst:2746
msgid "void (PyObject *exporter, Py_buffer *view);"
msgstr "void (PyObject *exporter, Py_buffer *view);"

#: ../../c-api/typeobj.rst:2748
msgid ""
"Handle a request to release the resources of the buffer. If no resources "
"need to be released, :c:member:`PyBufferProcs.bf_releasebuffer` may be "
"``NULL``. Otherwise, a standard implementation of this function will take "
"these optional steps:"
msgstr ""
"Hanterar en begäran om att frigöra buffertens resurser. Om inga resurser "
"behöver frigöras kan :c:member:`PyBufferProcs.bf_releasebuffer` vara "
"``NULL``. Annars kommer en standardimplementering av denna funktion att "
"vidta dessa valfria steg:"

#: ../../c-api/typeobj.rst:2753
msgid "Decrement an internal counter for the number of exports."
msgstr "Minskar en intern räknare för antalet exporter."

#: ../../c-api/typeobj.rst:2755
msgid "If the counter is ``0``, free all memory associated with *view*."
msgstr "Om räknaren är ``0``, frigör allt minne som är associerat med *view*."

#: ../../c-api/typeobj.rst:2757
msgid ""
"The exporter MUST use the :c:member:`~Py_buffer.internal` field to keep "
"track of buffer-specific resources. This field is guaranteed to remain "
"constant, while a consumer MAY pass a copy of the original buffer as the "
"*view* argument."
msgstr ""
"Exportören MÅSTE använda fältet :c:member:`~Py_buffer.internal` för att "
"hålla reda på buffertspecifika resurser. Detta fält är garanterat konstant, "
"medan en konsument KAN skicka en kopia av den ursprungliga bufferten som "
"*view*-argument."

#: ../../c-api/typeobj.rst:2763
msgid ""
"This function MUST NOT decrement :c:expr:`view->obj`, since that is done "
"automatically in :c:func:`PyBuffer_Release` (this scheme is useful for "
"breaking reference cycles)."
msgstr ""
"Denna funktion FÅR INTE decimera :c:expr:`view->obj`, eftersom det görs "
"automatiskt i :c:func:`PyBuffer_Release` (detta system är användbart för att "
"bryta referenscykler)."

#: ../../c-api/typeobj.rst:2768
msgid ""
":c:func:`PyBuffer_Release` is the interface for the consumer that wraps this "
"function."
msgstr ""
":c:func:`PyBuffer_Release` är gränssnittet för den konsument som omsluter "
"denna funktion."

#: ../../c-api/typeobj.rst:2776
msgid "Async Object Structures"
msgstr "Strukturer för asynkrona objekt"

#: ../../c-api/typeobj.rst:2784
msgid ""
"This structure holds pointers to the functions required to implement :term:"
"`awaitable` and :term:`asynchronous iterator` objects."
msgstr ""
"Denna struktur innehåller pekare till de funktioner som krävs för att "
"implementera objekten :term:`awaitable` och :term:`asynchronous iterator`."

#: ../../c-api/typeobj.rst:2789
msgid ""
"typedef struct {\n"
"    unaryfunc am_await;\n"
"    unaryfunc am_aiter;\n"
"    unaryfunc am_anext;\n"
"    sendfunc am_send;\n"
"} PyAsyncMethods;"
msgstr ""
"typedef struct {\n"
"    unaryfunc am_await;\n"
"    unaryfunc am_aiter;\n"
"    unaryfunc am_anext;\n"
"    sendfunc am_send;\n"
"} PyAsyncMethods;"

#: ../../c-api/typeobj.rst:2802
msgid "PyObject *am_await(PyObject *self);"
msgstr "PyObject *am_await(PyObject *self);"

#: ../../c-api/typeobj.rst:2804
msgid ""
"The returned object must be an :term:`iterator`, i.e. :c:func:`PyIter_Check` "
"must return ``1`` for it."
msgstr ""
"Det returnerade objektet måste vara en :term:`iterator`, d.v.s. :c:func:"
"`PyIter_Check` måste returnera ``1`` för det."

#: ../../c-api/typeobj.rst:2807
msgid ""
"This slot may be set to ``NULL`` if an object is not an :term:`awaitable`."
msgstr ""
"Denna slot kan sättas till ``NULL`` om ett objekt inte är en :term:"
"`awaitable`."

#: ../../c-api/typeobj.rst:2815
msgid "PyObject *am_aiter(PyObject *self);"
msgstr "PyObject *am_aiter(PyObject *self);"

#: ../../c-api/typeobj.rst:2817
msgid ""
"Must return an :term:`asynchronous iterator` object. See :meth:`~object."
"__anext__` for details."
msgstr ""
"Måste returnera ett :term:`asynkron iterator`-objekt. Se :meth:`~object."
"__anext__` för detaljer."

#: ../../c-api/typeobj.rst:2820
msgid ""
"This slot may be set to ``NULL`` if an object does not implement "
"asynchronous iteration protocol."
msgstr ""
"Denna slot kan sättas till ``NULL`` om ett objekt inte implementerar "
"asynkront iterationsprotokoll."

#: ../../c-api/typeobj.rst:2829
msgid "PyObject *am_anext(PyObject *self);"
msgstr "PyObject *am_anext(PyObject *self);"

#: ../../c-api/typeobj.rst:2831
msgid ""
"Must return an :term:`awaitable` object. See :meth:`~object.__anext__` for "
"details. This slot may be set to ``NULL``."
msgstr ""
"Måste returnera ett :term:`awaitable`-objekt. Se :meth:`~object.__anext__` "
"för detaljer. Denna slot kan sättas till ``NULL``."

#: ../../c-api/typeobj.rst:2841
msgid "PySendResult am_send(PyObject *self, PyObject *arg, PyObject **result);"
msgstr ""
"PySendResult am_send(PyObject *self, PyObject *arg, PyObject **result);"

#: ../../c-api/typeobj.rst:2843
msgid ""
"See :c:func:`PyIter_Send` for details. This slot may be set to ``NULL``."
msgstr ""
"Se :c:func:`PyIter_Send` för detaljer. Denna slot kan sättas till ``NULL``."

#: ../../c-api/typeobj.rst:2852
msgid "Slot Type typedefs"
msgstr "Slotstyp typedef"

#: ../../c-api/typeobj.rst:2856
msgid ""
"The purpose of this function is to separate memory allocation from memory "
"initialization.  It should return a pointer to a block of memory of adequate "
"length for the instance, suitably aligned, and initialized to zeros, but "
"with :c:member:`~PyObject.ob_refcnt` set to ``1`` and :c:member:`~PyObject."
"ob_type` set to the type argument.  If the type's :c:member:`~PyTypeObject."
"tp_itemsize` is non-zero, the object's :c:member:`~PyVarObject.ob_size` "
"field should be initialized to *nitems* and the length of the allocated "
"memory block should be ``tp_basicsize + nitems*tp_itemsize``, rounded up to "
"a multiple of ``sizeof(void*)``; otherwise, *nitems* is not used and the "
"length of the block should be :c:member:`~PyTypeObject.tp_basicsize`."
msgstr ""
"Syftet med denna funktion är att separera minnesallokering från "
"minnesinitialisering.  Den ska returnera en pekare till ett minnesblock som "
"är tillräckligt långt för instansen, lämpligt inriktat och initialiserat "
"till nollor, men med :c:member:`~PyObject.ob_refcnt` satt till ``1`` och :c:"
"member:`~PyObject.ob_type` satt till typargumentet.  Om typens :c:member:"
"`~PyTypeObject.tp_itemsize` inte är noll, ska objektets :c:member:"
"`~PyVarObject.ob_size` initialiseras till *nitems* och längden på det "
"allokerade minnesblocket blir ``tp_basicsize + nitems*tp_itemsize``, "
"avrundat uppåt till en multipel av ``sizeof(void*)``; annars används inte "
"*nitems* och längden på blocket blir :c:member:`~PyTypeObject.tp_basicsize``."

#: ../../c-api/typeobj.rst:2866
msgid ""
"This function should not do any other instance initialization, not even to "
"allocate additional memory; that should be done by :c:member:`~PyTypeObject."
"tp_new`."
msgstr ""
"Denna funktion bör inte göra någon annan instansinitialisering, inte ens för "
"att allokera ytterligare minne; det bör göras av :c:member:`~PyTypeObject."
"tp_new`."

#: ../../c-api/typeobj.rst:2873
msgid "See :c:member:`~PyTypeObject.tp_free`."
msgstr "Se :c:member:`~PyTypeObject.tp_free`."

#: ../../c-api/typeobj.rst:2877
msgid "See :c:member:`~PyTypeObject.tp_new`."
msgstr "Se :c:member:`~PyTypeObject.tp_new`."

#: ../../c-api/typeobj.rst:2881
msgid "See :c:member:`~PyTypeObject.tp_init`."
msgstr "Se :c:member:`~PyTypeObject.tp_init`."

#: ../../c-api/typeobj.rst:2885
msgid "See :c:member:`~PyTypeObject.tp_repr`."
msgstr "Se :c:member:`~PyTypeObject.tp_repr`."

#: ../../c-api/typeobj.rst:2889 ../../c-api/typeobj.rst:2898
msgid "Return the value of the named attribute for the object."
msgstr "Returnerar värdet på det namngivna attributet för objektet."

#: ../../c-api/typeobj.rst:2893 ../../c-api/typeobj.rst:2904
msgid ""
"Set the value of the named attribute for the object. The value argument is "
"set to ``NULL`` to delete the attribute."
msgstr ""
"Ställ in värdet på det namngivna attributet för objektet. Argumentet value "
"sätts till ``NULL`` för att ta bort attributet."

#: ../../c-api/typeobj.rst:2900
msgid "See :c:member:`~PyTypeObject.tp_getattro`."
msgstr "Se :c:member:`~PyTypeObject.tp_getattro`."

#: ../../c-api/typeobj.rst:2907
msgid "See :c:member:`~PyTypeObject.tp_setattro`."
msgstr "Se :c:member:`~PyTypeObject.tp_setattro`."

#: ../../c-api/typeobj.rst:2911
msgid "See :c:member:`~PyTypeObject.tp_descr_get`."
msgstr "Se :c:member:`~PyTypeObject.tp_descr_get`."

#: ../../c-api/typeobj.rst:2915
msgid "See :c:member:`~PyTypeObject.tp_descr_set`."
msgstr "Se :c:member:`~PyTypeObject.tp_descr_set`."

#: ../../c-api/typeobj.rst:2919
msgid "See :c:member:`~PyTypeObject.tp_hash`."
msgstr "Se :c:member:`~PyTypeObject.tp_hash`."

#: ../../c-api/typeobj.rst:2923
msgid "See :c:member:`~PyTypeObject.tp_richcompare`."
msgstr "Se :c:member:`~PyTypeObject.tp_richcompare`."

#: ../../c-api/typeobj.rst:2927
msgid "See :c:member:`~PyTypeObject.tp_iter`."
msgstr "Se :c:member:`~PyTypeObject.tp_iter`."

#: ../../c-api/typeobj.rst:2931
msgid "See :c:member:`~PyTypeObject.tp_iternext`."
msgstr "Se :c:member:`~PyTypeObject.tp_iternext`."

#: ../../c-api/typeobj.rst:2945
msgid "See :c:member:`~PyAsyncMethods.am_send`."
msgstr "Se :c:member:`~PyAsyncMethods.am_send`."

#: ../../c-api/typeobj.rst:2961
msgid "Examples"
msgstr "Exempel"

#: ../../c-api/typeobj.rst:2963
msgid ""
"The following are simple examples of Python type definitions.  They include "
"common usage you may encounter.  Some demonstrate tricky corner cases.  For "
"more examples, practical info, and a tutorial, see :ref:`defining-new-types` "
"and :ref:`new-types-topics`."
msgstr ""
"Följande är enkla exempel på Python-typdefinitioner.  De inkluderar vanlig "
"användning som du kan stöta på.  Några demonstrerar knepiga hörnfall.  För "
"fler exempel, praktisk information och en handledning, se :ref:`defining-new-"
"types` och :ref:`new-types-topics`."

#: ../../c-api/typeobj.rst:2968
msgid "A basic :ref:`static type <static-types>`::"
msgstr "En grundläggande :ref:`statisk typ <static-types>`::"

#: ../../c-api/typeobj.rst:2970
msgid ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"    const char *data;\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"    .tp_basicsize = sizeof(MyObject),\n"
"    .tp_doc = PyDoc_STR(\"My objects\"),\n"
"    .tp_new = myobj_new,\n"
"    .tp_dealloc = (destructor)myobj_dealloc,\n"
"    .tp_repr = (reprfunc)myobj_repr,\n"
"};"
msgstr ""
"typedef struct {\n"
"    PyObject_Huvud\n"
"    const char *data;\n"
"} MyObject;\n"
"\n"
"statisk PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"    .tp_basicsize = sizeof(MyObject),\n"
"    .tp_doc = PyDoc_STR(\"Mina objekt\"),\n"
"    .tp_new = myobj_new,\n"
"    .tp_dealloc = (destructor)myobj_dealloc,\n"
"    .tp_repr = (reprfunc)myobj_repr,\n"
"};"

#: ../../c-api/typeobj.rst:2985
msgid ""
"You may also find older code (especially in the CPython code base) with a "
"more verbose initializer::"
msgstr ""
"Du kan också hitta äldre kod (särskilt i CPython-kodbasen) med en mer "
"utförlig initialiserare::"

#: ../../c-api/typeobj.rst:2988
msgid ""
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    \"mymod.MyObject\",               /* tp_name */\n"
"    sizeof(MyObject),               /* tp_basicsize */\n"
"    0,                              /* tp_itemsize */\n"
"    (destructor)myobj_dealloc,      /* tp_dealloc */\n"
"    0,                              /* tp_vectorcall_offset */\n"
"    0,                              /* tp_getattr */\n"
"    0,                              /* tp_setattr */\n"
"    0,                              /* tp_as_async */\n"
"    (reprfunc)myobj_repr,           /* tp_repr */\n"
"    0,                              /* tp_as_number */\n"
"    0,                              /* tp_as_sequence */\n"
"    0,                              /* tp_as_mapping */\n"
"    0,                              /* tp_hash */\n"
"    0,                              /* tp_call */\n"
"    0,                              /* tp_str */\n"
"    0,                              /* tp_getattro */\n"
"    0,                              /* tp_setattro */\n"
"    0,                              /* tp_as_buffer */\n"
"    0,                              /* tp_flags */\n"
"    PyDoc_STR(\"My objects\"),        /* tp_doc */\n"
"    0,                              /* tp_traverse */\n"
"    0,                              /* tp_clear */\n"
"    0,                              /* tp_richcompare */\n"
"    0,                              /* tp_weaklistoffset */\n"
"    0,                              /* tp_iter */\n"
"    0,                              /* tp_iternext */\n"
"    0,                              /* tp_methods */\n"
"    0,                              /* tp_members */\n"
"    0,                              /* tp_getset */\n"
"    0,                              /* tp_base */\n"
"    0,                              /* tp_dict */\n"
"    0,                              /* tp_descr_get */\n"
"    0,                              /* tp_descr_set */\n"
"    0,                              /* tp_dictoffset */\n"
"    0,                              /* tp_init */\n"
"    0,                              /* tp_alloc */\n"
"    myobj_new,                      /* tp_new */\n"
"};"
msgstr ""
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    \"mymod.MyObject\", /* tp_name */\n"
"    sizeof(MyObject), /* tp_basicsize */\n"
"    0, /* tp_itemsize */\n"
"    (destructor)myobj_dealloc, /* tp_dealloc */\n"
"    0, /* tp_vectorcall_offset */\n"
"    0, /* tp_getattr */\n"
"    0, /* tp_setattr */\n"
"    0, /* tp_as_async */\n"
"    (reprfunc)myobj_repr, /* tp_repr */\n"
"    0, /* tp_as_number */\n"
"    0, /* tp_as_sequence */\n"
"    0, /* tp_as_mapping */\n"
"    0, /* tp_hash */\n"
"    0, /* tp_call */\n"
"    0, /* tp_str */\n"
"    0, /* tp_getattro */\n"
"    0, /* tp_setattro */\n"
"    0, /* tp_as_buffer */\n"
"    0, /* tp_flags */\n"
"    PyDoc_STR(\"Mina objekt\"), /* tp_doc */\n"
"    0, /* tp_traverse */\n"
"    0, /* tp_clear */\n"
"    0, /* tp_richcompare */\n"
"    0, /* tp_weaklistoffset */\n"
"    0, /* tp_iter */\n"
"    0, /* tp_iternext */\n"
"    0, /* tp_methods */\n"
"    0, /* tp_members */\n"
"    0, /* tp_getset */\n"
"    0, /* tp_base */\n"
"    0, /* tp_dict */\n"
"    0, /* tp_descr_get */\n"
"    0, /* tp_descr_set */\n"
"    0, /* tp_dictoffset */\n"
"    0, /* tp_init */\n"
"    0, /* tp_alloc */\n"
"    myobj_new, /* tp_new */\n"
"};"

#: ../../c-api/typeobj.rst:3029
msgid "A type that supports weakrefs, instance dicts, and hashing::"
msgstr "En typ som stöder weakrefs, instance dicts och hashing::"

#: ../../c-api/typeobj.rst:3031
msgid ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"    const char *data;\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"    .tp_basicsize = sizeof(MyObject),\n"
"    .tp_doc = PyDoc_STR(\"My objects\"),\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |\n"
"         Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_MANAGED_DICT |\n"
"         Py_TPFLAGS_MANAGED_WEAKREF,\n"
"    .tp_new = myobj_new,\n"
"    .tp_traverse = (traverseproc)myobj_traverse,\n"
"    .tp_clear = (inquiry)myobj_clear,\n"
"    .tp_alloc = PyType_GenericNew,\n"
"    .tp_dealloc = (destructor)myobj_dealloc,\n"
"    .tp_repr = (reprfunc)myobj_repr,\n"
"    .tp_hash = (hashfunc)myobj_hash,\n"
"    .tp_richcompare = PyBaseObject_Type.tp_richcompare,\n"
"};"
msgstr ""
"typedef struct {\n"
"    PyObjekt_Huvud\n"
"    const char *data;\n"
"} MyObject;\n"
"\n"
"statisk PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"    .tp_basicsize = sizeof(MyObject),\n"
"    .tp_doc = PyDoc_STR(\"Mina objekt\"),\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py\n"
"         Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_MANAGED_DICT | "
"Py_TPFLAGS_MANAGED_DICT | Py\n"
"         Py_TPFLAGS_MANAGED_WEAKREF,\n"
"    .tp_new = myobj_new,\n"
"    .tp_traverse = (traverseproc)myobj_traverse,\n"
"    .tp_clear = (förfrågan)myobj_clear,\n"
"    .tp_alloc = PyType_GenericNew,\n"
"    .tp_dealloc = (destructor)myobj_dealloc,\n"
"    .tp_repr = (reprfunc)myobj_repr,\n"
"    .tp_hash = (hashfunc)myobj_hash,\n"
"    .tp_richcompare = PyBaseObject_Type.tp_richcompare,\n"
"};"

#: ../../c-api/typeobj.rst:3054
msgid ""
"A str subclass that cannot be subclassed and cannot be called to create "
"instances (e.g. uses a separate factory func) using :c:macro:"
"`Py_TPFLAGS_DISALLOW_INSTANTIATION` flag::"
msgstr ""
"En str-underklass som inte kan underklassas och inte kan anropas för att "
"skapa instanser (t.ex. använder en separat fabriksfunktion) med :c:macro:"
"`Py_TPFLAGS_DISALLOW_INSTANTIATION` flagga::"

#: ../../c-api/typeobj.rst:3058
msgid ""
"typedef struct {\n"
"    PyUnicodeObject raw;\n"
"    char *extra;\n"
"} MyStr;\n"
"\n"
"static PyTypeObject MyStr_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyStr\",\n"
"    .tp_basicsize = sizeof(MyStr),\n"
"    .tp_base = NULL,  // set to &PyUnicode_Type in module init\n"
"    .tp_doc = PyDoc_STR(\"my custom str\"),\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_DISALLOW_INSTANTIATION,\n"
"    .tp_repr = (reprfunc)myobj_repr,\n"
"};"
msgstr ""
"typedef struct {\n"
"    PyUnicodeObject rå;\n"
"    char *extra;\n"
"} MyStr;\n"
"\n"
"statiskt PyTypeObject MyStr_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyStr\",\n"
"    .tp_basicsize = sizeof(MyStr),\n"
"    .tp_base = NULL, // satt till &PyUnicode_Type i modulinit\n"
"    .tp_doc = PyDoc_STR(\"min anpassade str\"),\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_DISALLOW_INSTANTIATION,\n"
"    .tp_repr = (reprfunc)myobj_repr,\n"
"};"

#: ../../c-api/typeobj.rst:3073
msgid ""
"The simplest :ref:`static type <static-types>` with fixed-length instances::"
msgstr ""
"Den enklaste :ref:` `statiska typen <static-types>` med instanser av fast "
"längd::"

#: ../../c-api/typeobj.rst:3075
msgid ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"};"
msgstr ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"} MyObject;\n"
"\n"
"statisk PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"};"

#: ../../c-api/typeobj.rst:3084
msgid ""
"The simplest :ref:`static type <static-types>` with variable-length "
"instances::"
msgstr ""
"Den enklaste :ref:`statiska typen <static-types>` med instanser av variabel "
"längd::"

#: ../../c-api/typeobj.rst:3086
msgid ""
"typedef struct {\n"
"    PyObject_VAR_HEAD\n"
"    const char *data[1];\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"    .tp_basicsize = sizeof(MyObject) - sizeof(char *),\n"
"    .tp_itemsize = sizeof(char *),\n"
"};"
msgstr ""
"typedef struct {\n"
"    PyObject_VAR_HEAD\n"
"    const char *data[1];\n"
"} MyObject;\n"
"\n"
"statisk PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"    .tp_basicsize = sizeof(MyObject) - sizeof(char *),\n"
"    .tp_itemsize = sizeof(char *),\n"
"};"

#: ../../c-api/typeobj.rst:851 ../../c-api/typeobj.rst:918
msgid "built-in function"
msgstr "inbyggd funktion"

#: ../../c-api/typeobj.rst:851
msgid "repr"
msgstr "repr"

#: ../../c-api/typeobj.rst:918
msgid "hash"
msgstr "hash"
