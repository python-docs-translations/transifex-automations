# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-27 15:00+0000\n"
"PO-Revision-Date: 2025-09-15 01:03+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../c-api/module.rst:6
msgid "Module Objects"
msgstr "Modulobjekt"

#: ../../c-api/module.rst:15
msgid ""
"This instance of :c:type:`PyTypeObject` represents the Python module type.  "
"This is exposed to Python programs as :py:class:`types.ModuleType`."
msgstr ""

#: ../../c-api/module.rst:21
msgid ""
"Return true if *p* is a module object, or a subtype of a module object. This "
"function always succeeds."
msgstr ""
"Returnerar true om *p* är ett modulobjekt eller en subtyp av ett "
"modulobjekt. Denna funktion lyckas alltid."

#: ../../c-api/module.rst:27
msgid ""
"Return true if *p* is a module object, but not a subtype of :c:data:"
"`PyModule_Type`.  This function always succeeds."
msgstr ""
"Returnerar true om *p* är ett modulobjekt, men inte en subtyp av :c:data:"
"`PyModule_Type`.  Denna funktion lyckas alltid."

#: ../../c-api/module.rst:40
msgid ""
"Return a new module object with :attr:`module.__name__` set to *name*. The "
"module's :attr:`!__name__`, :attr:`~module.__doc__`, :attr:`~module."
"__package__` and :attr:`~module.__loader__` attributes are filled in (all "
"but :attr:`!__name__` are set to ``None``). The caller is responsible for "
"setting a :attr:`~module.__file__` attribute."
msgstr ""
"Returnerar ett nytt modulobjekt med :attr:`module.__name__` satt till "
"*name*. Modulens attribut :attr:`!__name__`, :attr:`~module.__doc__`, :attr:"
"`~module.__package__` och :attr:`~module.__loader__` fylls i (alla utom :"
"attr:`!__name__` sätts till ``None``). Den som anropar är ansvarig för att "
"ange attributet :attr:`~module.__file__`."

#: ../../c-api/module.rst:46 ../../c-api/module.rst:286
#: ../../c-api/module.rst:510
msgid "Return ``NULL`` with an exception set on error."
msgstr "Returnerar ``NULL`` med ett undantag inställt på fel."

#: ../../c-api/module.rst:50
msgid ""
":attr:`~module.__package__` and :attr:`~module.__loader__` are now set to "
"``None``."
msgstr ""
":attr:`~module.__package__` och :attr:`~module.__loader__` är nu inställda "
"på ``None``."

#: ../../c-api/module.rst:57
msgid ""
"Similar to :c:func:`PyModule_NewObject`, but the name is a UTF-8 encoded "
"string instead of a Unicode object."
msgstr ""
"Liknar :c:func:`PyModule_NewObject`, men namnet är en UTF-8-kodad sträng i "
"stället för ett Unicode-objekt."

#: ../../c-api/module.rst:65
msgid ""
"Return the dictionary object that implements *module*'s namespace; this "
"object is the same as the :attr:`~object.__dict__` attribute of the module "
"object. If *module* is not a module object (or a subtype of a module "
"object), :exc:`SystemError` is raised and ``NULL`` is returned."
msgstr ""
"Returnerar det ordboksobjekt som implementerar *modul*:s namnrymd; detta "
"objekt är detsamma som :attr:`~object.__dict__`\\-attributet för "
"modulobjektet. Om *module* inte är ett modulobjekt (eller en subtyp av ett "
"modulobjekt), avges :exc:`SystemError` och ``NULL`` returneras."

#: ../../c-api/module.rst:70
msgid ""
"It is recommended extensions use other ``PyModule_*`` and ``PyObject_*`` "
"functions rather than directly manipulate a module's :attr:`~object."
"__dict__`."
msgstr ""
"Det rekommenderas att använda andra ``PyModule_*`` och ``PyObject_*`` "
"funktioner snarare än att direkt manipulera en moduls :attr:`~object."
"__dict__`."

#: ../../c-api/module.rst:74
msgid ""
"The returned reference is borrowed from the module; it is valid until the "
"module is destroyed."
msgstr ""

#: ../../c-api/module.rst:84
msgid ""
"Return *module*'s :attr:`~module.__name__` value.  If the module does not "
"provide one, or if it is not a string, :exc:`SystemError` is raised and "
"``NULL`` is returned."
msgstr ""
"Returnerar *modul*:s :attr:`~module.__name__`\\-värde.  Om modulen inte "
"tillhandahåller något värde eller om det inte är en sträng, :exc:"
"`SystemError` och ``NULL`` returneras."

#: ../../c-api/module.rst:93
msgid ""
"Similar to :c:func:`PyModule_GetNameObject` but return the name encoded to "
"``'utf-8'``."
msgstr ""
"Liknar :c:func:`PyModule_GetNameObject` men returnerar namnet kodat till "
"``'utf-8'``."

#: ../../c-api/module.rst:96
msgid ""
"The returned buffer is only valid until the module is renamed or destroyed. "
"Note that Python code may rename a module by setting its :py:attr:`~module."
"__name__` attribute."
msgstr ""

#: ../../c-api/module.rst:102
msgid ""
"Return the \"state\" of the module, that is, a pointer to the block of "
"memory allocated at module creation time, or ``NULL``.  See :c:member:"
"`PyModuleDef.m_size`."
msgstr ""
"Returnerar modulens \"tillstånd\", det vill säga en pekare till det "
"minnesblock som allokerades när modulen skapades, eller ``NULL``.  Se :c:"
"member:`PyModuleDef.m_size`."

#: ../../c-api/module.rst:109
msgid ""
"Return a pointer to the :c:type:`PyModuleDef` struct from which the module "
"was created, or ``NULL`` if the module wasn't created from a definition."
msgstr ""
"Returnerar en pekare till :c:type:`PyModuleDef`\\-strukturen från vilken "
"modulen skapades, eller ``NULL`` om modulen inte skapades från en definition."

#: ../../c-api/module.rst:112
msgid ""
"On error, return ``NULL`` with an exception set. Use :c:func:"
"`PyErr_Occurred` to tell this case apart from a missing :c:type:`!"
"PyModuleDef`."
msgstr ""

#: ../../c-api/module.rst:123
msgid ""
"Return the name of the file from which *module* was loaded using *module*'s :"
"attr:`~module.__file__` attribute.  If this is not defined, or if it is not "
"a string, raise :exc:`SystemError` and return ``NULL``; otherwise return a "
"reference to a Unicode object."
msgstr ""
"Returnerar namnet på den fil som *modul* laddades från med hjälp av *moduls* "
"attribut :attr:`~module.__file__`.  Om detta inte är definierat, eller om "
"det inte är en sträng, uppstår :exc:`SystemError` och ``NULL`` returneras; "
"annars returneras en referens till ett Unicode-objekt."

#: ../../c-api/module.rst:133
msgid ""
"Similar to :c:func:`PyModule_GetFilenameObject` but return the filename "
"encoded to 'utf-8'."
msgstr ""
"Liknar :c:func:`PyModule_GetFilenameObject` men returnerar filnamnet kodat "
"till 'utf-8'."

#: ../../c-api/module.rst:136
msgid ""
"The returned buffer is only valid until the module's :py:attr:`~module."
"__file__` attribute is reassigned or the module is destroyed."
msgstr ""

#: ../../c-api/module.rst:139
msgid ""
":c:func:`PyModule_GetFilename` raises :exc:`UnicodeEncodeError` on "
"unencodable filenames, use :c:func:`PyModule_GetFilenameObject` instead."
msgstr ""
":c:func:`PyModule_GetFilename` ger upphov till :exc:`UnicodeEncodeError` på "
"okodbara filnamn, använd :c:func:`PyModule_GetFilenameObject` istället."

#: ../../c-api/module.rst:147
msgid "Initializing C modules"
msgstr ""

#: ../../c-api/module.rst:149
msgid ""
"Modules objects are usually created from extension modules (shared libraries "
"which export an initialization function), or compiled-in modules (where the "
"initialization function is added using :c:func:`PyImport_AppendInittab`). "
"See :ref:`building` or :ref:`extending-with-embedding` for details."
msgstr ""

#: ../../c-api/module.rst:154
msgid ""
"The initialization function can either pass a module definition instance to :"
"c:func:`PyModule_Create`, and return the resulting module object, or request "
"\"multi-phase initialization\" by returning the definition struct itself."
msgstr ""

#: ../../c-api/module.rst:160
msgid ""
"The module definition struct, which holds all information needed to create a "
"module object. There is usually only one statically initialized variable of "
"this type for each module."
msgstr ""

#: ../../c-api/module.rst:166
msgid "Always initialize this member to :c:macro:`PyModuleDef_HEAD_INIT`."
msgstr ""
"Initialisera alltid denna medlem till :c:macro:`PyModuleDef_HEAD_INIT`."

#: ../../c-api/module.rst:170
msgid "Name for the new module."
msgstr "Namn för den nya modulen."

#: ../../c-api/module.rst:174
msgid ""
"Docstring for the module; usually a docstring variable created with :c:macro:"
"`PyDoc_STRVAR` is used."
msgstr ""
"Docstring för modulen; vanligtvis används en docstring-variabel som skapats "
"med :c:macro:`PyDoc_STRVAR`."

#: ../../c-api/module.rst:179
msgid ""
"Module state may be kept in a per-module memory area that can be retrieved "
"with :c:func:`PyModule_GetState`, rather than in static globals. This makes "
"modules safe for use in multiple sub-interpreters."
msgstr ""
"Modulstatus kan förvaras i ett minnesområde per modul som kan hämtas med :c:"
"func:`PyModule_GetState`, i stället för i statiska globaler. Detta gör "
"moduler säkra för användning i flera undertolkare."

#: ../../c-api/module.rst:183
msgid ""
"This memory area is allocated based on *m_size* on module creation, and "
"freed when the module object is deallocated, after the :c:member:"
"`~PyModuleDef.m_free` function has been called, if present."
msgstr ""
"Detta minnesområde allokeras baserat på *m_size* när modulen skapas och "
"frigörs när modulobjektet avallokeras, efter att funktionen :c:member:"
"`~PyModuleDef.m_free` har anropats, om den finns."

#: ../../c-api/module.rst:187
msgid ""
"Setting ``m_size`` to ``-1`` means that the module does not support sub-"
"interpreters, because it has global state."
msgstr ""

#: ../../c-api/module.rst:190
msgid ""
"Setting it to a non-negative value means that the module can be re-"
"initialized and specifies the additional amount of memory it requires for "
"its state. Non-negative ``m_size`` is required for multi-phase "
"initialization."
msgstr ""

#: ../../c-api/module.rst:195
msgid "See :PEP:`3121` for more details."
msgstr "Se :PEP:`3121` för mer information."

#: ../../c-api/module.rst:199
msgid ""
"A pointer to a table of module-level functions, described by :c:type:"
"`PyMethodDef` values.  Can be ``NULL`` if no functions are present."
msgstr ""
"En pekare till en tabell med funktioner på modulnivå, beskrivna av :c:type:"
"`PyMethodDef`\\-värden.  Kan vara ``NULL`` om inga funktioner finns."

#: ../../c-api/module.rst:204
msgid ""
"An array of slot definitions for multi-phase initialization, terminated by a "
"``{0, NULL}`` entry. When using single-phase initialization, *m_slots* must "
"be ``NULL``."
msgstr ""

#: ../../c-api/module.rst:210
msgid ""
"Prior to version 3.5, this member was always set to ``NULL``, and was "
"defined as:"
msgstr ""
"Före version 3.5 var denna medlem alltid inställd på ``NULL``, och "
"definierades som:"

#: ../../c-api/module.rst:217
msgid ""
"A traversal function to call during GC traversal of the module object, or "
"``NULL`` if not needed."
msgstr ""
"En traversalfunktion som ska anropas under GC-traversal av modulobjektet, "
"eller ``NULL`` om den inte behövs."

#: ../../c-api/module.rst:220 ../../c-api/module.rst:235
#: ../../c-api/module.rst:256
msgid ""
"This function is not called if the module state was requested but is not "
"allocated yet. This is the case immediately after the module is created and "
"before the module is executed (:c:data:`Py_mod_exec` function). More "
"precisely, this function is not called if :c:member:`~PyModuleDef.m_size` is "
"greater than 0 and the module state (as returned by :c:func:"
"`PyModule_GetState`) is ``NULL``."
msgstr ""
"Denna funktion anropas inte om modultillståndet begärdes men ännu inte har "
"allokerats. Detta är fallet omedelbart efter att modulen skapats och innan "
"modulen exekveras (:c:data:`Py_mod_exec` funktion). Mer exakt anropas inte "
"denna funktion om :c:member:`~PyModuleDef.m_size` är större än 0 och "
"modultillståndet (som returneras av :c:func:`PyModule_GetState`) är ``NULL``."

#: ../../c-api/module.rst:227 ../../c-api/module.rst:248
#: ../../c-api/module.rst:263
msgid "No longer called before the module state is allocated."
msgstr "Anropas inte längre innan modultillståndet har allokerats."

#: ../../c-api/module.rst:232
msgid ""
"A clear function to call during GC clearing of the module object, or "
"``NULL`` if not needed."
msgstr ""
"En clear-funktion som ska anropas vid GC-rensning av modulobjektet, eller "
"``NULL`` om den inte behövs."

#: ../../c-api/module.rst:242
msgid ""
"Like :c:member:`PyTypeObject.tp_clear`, this function is not *always* called "
"before a module is deallocated. For example, when reference counting is "
"enough to determine that an object is no longer used, the cyclic garbage "
"collector is not involved and :c:member:`~PyModuleDef.m_free` is called "
"directly."
msgstr ""
"Precis som :c:member:`PyTypeObject.tp_clear` anropas inte den här funktionen "
"*alltid* innan en modul avallokeras. Till exempel, när referensräkning är "
"tillräckligt för att avgöra att ett objekt inte längre används, är den "
"cykliska skräpsamlaren inte inblandad och :c:member:`~PyModuleDef.m_free` "
"anropas direkt."

#: ../../c-api/module.rst:253
msgid ""
"A function to call during deallocation of the module object, or ``NULL`` if "
"not needed."
msgstr ""
"En funktion som ska anropas vid avallokering av modulobjektet, eller "
"``NULL`` om den inte behövs."

#: ../../c-api/module.rst:267
msgid "Single-phase initialization"
msgstr ""

#: ../../c-api/module.rst:269
msgid ""
"The module initialization function may create and return the module object "
"directly. This is referred to as \"single-phase initialization\", and uses "
"one of the following two module creation functions:"
msgstr ""

#: ../../c-api/module.rst:275
msgid ""
"Create a new module object, given the definition in *def*.  This behaves "
"like :c:func:`PyModule_Create2` with *module_api_version* set to :c:macro:"
"`PYTHON_API_VERSION`."
msgstr ""

#: ../../c-api/module.rst:282
msgid ""
"Create a new module object, given the definition in *def*, assuming the API "
"version *module_api_version*.  If that version does not match the version of "
"the running interpreter, a :exc:`RuntimeWarning` is emitted."
msgstr ""
"Skapa ett nytt modulobjekt med definitionen i *def* och API-versionen "
"*module_api_version*.  Om den versionen inte stämmer överens med versionen i "
"den tolk som körs, skickas en :exc:`RuntimeWarning` ut."

#: ../../c-api/module.rst:290
msgid ""
"Most uses of this function should be using :c:func:`PyModule_Create` "
"instead; only use this if you are sure you need it."
msgstr ""
"De flesta användningar av denna funktion bör använda :c:func:"
"`PyModule_Create` istället; använd endast denna om du är säker på att du "
"behöver den."

#: ../../c-api/module.rst:293
msgid ""
"Before it is returned from in the initialization function, the resulting "
"module object is typically populated using functions like :c:func:"
"`PyModule_AddObjectRef`."
msgstr ""

#: ../../c-api/module.rst:299
msgid "Multi-phase initialization"
msgstr "Initialisering i flera faser"

#: ../../c-api/module.rst:301
msgid ""
"An alternate way to specify extensions is to request \"multi-phase "
"initialization\". Extension modules created this way behave more like Python "
"modules: the initialization is split between the *creation phase*, when the "
"module object is created, and the *execution phase*, when it is populated. "
"The distinction is similar to the :py:meth:`~object.__new__` and :py:meth:"
"`~object.__init__` methods of classes."
msgstr ""

#: ../../c-api/module.rst:308
msgid ""
"Unlike modules created using single-phase initialization, these modules are "
"not singletons. For example, if the :py:attr:`sys.modules` entry is removed "
"and the module is re-imported, a new module object is created, and typically "
"populated with fresh method and type objects. The old module is subject to "
"normal garbage collection. This mirrors the behavior of pure-Python modules."
msgstr ""

#: ../../c-api/module.rst:316
msgid ""
"Additional module instances may be created in :ref:`sub-interpreters <sub-"
"interpreter-support>` or after after Python runtime reinitialization (:c:"
"func:`Py_Finalize` and :c:func:`Py_Initialize`). In these cases, sharing "
"Python objects between module instances would likely cause crashes or "
"undefined behavior."
msgstr ""

#: ../../c-api/module.rst:323
msgid ""
"To avoid such issues, each instance of an extension module should be "
"*isolated*: changes to one instance should not implicitly affect the others, "
"and all state, including references to Python objects, should be specific to "
"a particular module instance. See :ref:`isolating-extensions-howto` for more "
"details and a practical guide."
msgstr ""

#: ../../c-api/module.rst:329
msgid ""
"A simpler way to avoid these issues is :ref:`raising an error on repeated "
"initialization <isolating-extensions-optout>`."
msgstr ""
"Ett enklare sätt att undvika dessa problem är :ref:`raising an error on "
"repeated initialization <isolating-extensions-optout>`."

#: ../../c-api/module.rst:332
msgid ""
"All modules created using multi-phase initialization are expected to "
"support :ref:`sub-interpreters <sub-interpreter-support>`, or otherwise "
"explicitly signal a lack of support. This is usually achieved by isolation "
"or blocking repeated initialization, as above. A module may also be limited "
"to the main interpreter using the :c:data:`Py_mod_multiple_interpreters` "
"slot."
msgstr ""

#: ../../c-api/module.rst:340
msgid ""
"To request multi-phase initialization, the initialization function "
"(PyInit_modulename) returns a :c:type:`PyModuleDef` instance with non-empty :"
"c:member:`~PyModuleDef.m_slots`. Before it is returned, the ``PyModuleDef`` "
"instance must be initialized with the following function:"
msgstr ""

#: ../../c-api/module.rst:347
msgid ""
"Ensures a module definition is a properly initialized Python object that "
"correctly reports its type and reference count."
msgstr ""

#: ../../c-api/module.rst:350
msgid "Returns *def* cast to ``PyObject*``, or ``NULL`` if an error occurred."
msgstr ""

#: ../../c-api/module.rst:354
msgid ""
"The *m_slots* member of the module definition must point to an array of "
"``PyModuleDef_Slot`` structures:"
msgstr ""

#: ../../c-api/module.rst:361
msgid "A slot ID, chosen from the available values explained below."
msgstr ""
"Ett slot-ID, som väljs bland de tillgängliga värden som beskrivs nedan."

#: ../../c-api/module.rst:365
msgid "Value of the slot, whose meaning depends on the slot ID."
msgstr "Värde för slot, vars betydelse beror på slot-ID."

#: ../../c-api/module.rst:369
msgid "The *m_slots* array must be terminated by a slot with id 0."
msgstr ""

#: ../../c-api/module.rst:371
msgid "The available slot types are:"
msgstr "De tillgängliga slot-typerna är:"

#: ../../c-api/module.rst:375
msgid ""
"Specifies a function that is called to create the module object itself. The "
"*value* pointer of this slot must point to a function of the signature:"
msgstr ""
"Anger en funktion som anropas för att skapa själva modulobjektet. Poängaren "
"*value* i denna slot måste peka på en funktion med samma signatur:"

#: ../../c-api/module.rst:382
msgid ""
"The function receives a :py:class:`~importlib.machinery.ModuleSpec` "
"instance, as defined in :PEP:`451`, and the module definition. It should "
"return a new module object, or set an error and return ``NULL``."
msgstr ""
"Funktionen tar emot en instans av :py:class:`~importlib.machinery."
"ModuleSpec`, enligt definitionen i :PEP:`451`, och moduldefinitionen. Den "
"bör returnera ett nytt modulobjekt, eller ange ett fel och returnera "
"``NULL``."

#: ../../c-api/module.rst:387
msgid ""
"This function should be kept minimal. In particular, it should not call "
"arbitrary Python code, as trying to import the same module again may result "
"in an infinite loop."
msgstr ""
"Denna funktion bör hållas minimal. I synnerhet bör den inte anropa "
"godtycklig Python-kod, eftersom försök att importera samma modul igen kan "
"resultera i en oändlig loop."

#: ../../c-api/module.rst:391
msgid ""
"Multiple ``Py_mod_create`` slots may not be specified in one module "
"definition."
msgstr "Flera ``Py_mod_create``\\-platser får inte anges i en moduldefinition."

#: ../../c-api/module.rst:394
msgid ""
"If ``Py_mod_create`` is not specified, the import machinery will create a "
"normal module object using :c:func:`PyModule_New`. The name is taken from "
"*spec*, not the definition, to allow extension modules to dynamically adjust "
"to their place in the module hierarchy and be imported under different names "
"through symlinks, all while sharing a single module definition."
msgstr ""
"Om ``Py_mod_create`` inte anges kommer importmaskineriet att skapa ett "
"normalt modulobjekt med hjälp av :c:func:`PyModule_New`. Namnet är taget "
"från *spec*, inte definitionen, för att göra det möjligt för tilläggsmoduler "
"att dynamiskt anpassa sig till sin plats i modulhierarkin och importeras "
"under olika namn genom symlinks, samtidigt som de delar en enda "
"moduldefinition."

#: ../../c-api/module.rst:400
msgid ""
"There is no requirement for the returned object to be an instance of :c:type:"
"`PyModule_Type`. Any type can be used, as long as it supports setting and "
"getting import-related attributes. However, only ``PyModule_Type`` instances "
"may be returned if the ``PyModuleDef`` has non-``NULL`` ``m_traverse``, "
"``m_clear``, ``m_free``; non-zero ``m_size``; or slots other than "
"``Py_mod_create``."
msgstr ""
"Det finns inget krav på att det returnerade objektet ska vara en instans av :"
"c:type:`PyModule_Type`. Vilken typ som helst kan användas, så länge den "
"stöder inställning och hämtning av importrelaterade attribut. Dock kan "
"endast ``PyModule_Type`` instanser returneras om ``PyModuleDef`` har icke-"
"``NULL`` ``m_traverse``, ``m_clear``, ``m_free``; icke- noll ``m_size``; "
"eller andra slots än ``Py_mod_create``."

#: ../../c-api/module.rst:411
msgid ""
"Specifies a function that is called to *execute* the module. This is "
"equivalent to executing the code of a Python module: typically, this "
"function adds classes and constants to the module. The signature of the "
"function is:"
msgstr ""
"Specificerar en funktion som anropas för att *exekvera* modulen. Detta "
"motsvarar att exekvera koden i en Python-modul: vanligtvis lägger denna "
"funktion till klasser och konstanter i modulen. Funktionens signatur är:"

#: ../../c-api/module.rst:420
msgid ""
"If multiple ``Py_mod_exec`` slots are specified, they are processed in the "
"order they appear in the *m_slots* array."
msgstr ""
"Om flera ``Py_mod_exec``\\-slots anges, behandlas de i den ordning de visas "
"i *m_slots*-arrayen."

#: ../../c-api/module.rst:427 ../../c-api/module.rst:460
msgid "Specifies one of the following values:"
msgstr "Anger ett av följande värden:"

#: ../../c-api/module.rst:433
msgid "The module does not support being imported in subinterpreters."
msgstr "Modulen stöder inte import i undertolkar."

#: ../../c-api/module.rst:437
msgid ""
"The module supports being imported in subinterpreters, but only when they "
"share the main interpreter's GIL. (See :ref:`isolating-extensions-howto`.)"
msgstr ""
"Modulen kan importeras i undertolkar, men endast om de delar huvudtolkens "
"GIL. (Se :ref:`isolating-extensions-howto`.)"

#: ../../c-api/module.rst:443
msgid ""
"The module supports being imported in subinterpreters, even when they have "
"their own GIL. (See :ref:`isolating-extensions-howto`.)"
msgstr ""
"Modulen stöder import i undertolkare, även när de har sin egen GIL. (Se :ref:"
"`isolating-extensions-howto`.)"

#: ../../c-api/module.rst:447
msgid ""
"This slot determines whether or not importing this module in a "
"subinterpreter will fail."
msgstr ""
"Denna plats avgör om import av denna modul i en subinterpreter kommer att "
"misslyckas eller inte."

#: ../../c-api/module.rst:450
msgid ""
"Multiple ``Py_mod_multiple_interpreters`` slots may not be specified in one "
"module definition."
msgstr ""
"Flera ``Py_mod_multiple_interpreters``\\-platser får inte anges i en "
"moduldefinition."

#: ../../c-api/module.rst:453
msgid ""
"If ``Py_mod_multiple_interpreters`` is not specified, the import machinery "
"defaults to ``Py_MOD_MULTIPLE_INTERPRETERS_SUPPORTED``."
msgstr ""
"Om ``Py_mod_multiple_interpreters`` inte anges, är standardvärdet för "
"importmaskineriet ``Py_MOD_MULTIPLE_INTERPRETERS_SUPPORTED``."

#: ../../c-api/module.rst:466
msgid ""
"The module depends on the presence of the global interpreter lock (GIL), and "
"may access global state without synchronization."
msgstr ""
"Modulen är beroende av att det globala tolklåset (GIL) finns och kan komma "
"åt globala tillstånd utan synkronisering."

#: ../../c-api/module.rst:471
msgid "The module is safe to run without an active GIL."
msgstr "Modulen är säker att köra utan en aktiv GIL."

#: ../../c-api/module.rst:473
msgid ""
"This slot is ignored by Python builds not configured with :option:`--disable-"
"gil`.  Otherwise, it determines whether or not importing this module will "
"cause the GIL to be automatically enabled. See :ref:`whatsnew313-free-"
"threaded-cpython` for more detail."
msgstr ""
"Denna slot ignoreras av Python-byggnader som inte konfigurerats med :option:"
"`\\--disable-gil`.  Annars avgör den om import av denna modul kommer att "
"orsaka att GIL aktiveras automatiskt. Se :ref:`whatsnew313-free-threaded-"
"cpython` för mer detaljer."

#: ../../c-api/module.rst:478
msgid ""
"Multiple ``Py_mod_gil`` slots may not be specified in one module definition."
msgstr "Flera ``Py_mod_gil``\\-platser får inte anges i en moduldefinition."

#: ../../c-api/module.rst:480
msgid ""
"If ``Py_mod_gil`` is not specified, the import machinery defaults to "
"``Py_MOD_GIL_USED``."
msgstr ""
"Om ``Py_mod_gil`` inte anges, är standardvärdet för importmaskineriet "
"``Py_MOD_GIL_USED``."

#: ../../c-api/module.rst:485
msgid "See :PEP:`489` for more details on multi-phase initialization."
msgstr ""

#: ../../c-api/module.rst:488
msgid "Low-level module creation functions"
msgstr ""

#: ../../c-api/module.rst:490
msgid ""
"The following functions are called under the hood when using multi-phase "
"initialization. They can be used directly, for example when creating module "
"objects dynamically. Note that both ``PyModule_FromDefAndSpec`` and "
"``PyModule_ExecDef`` must be called to fully initialize a module."
msgstr ""

#: ../../c-api/module.rst:497
msgid ""
"Create a new module object, given the definition in *def* and the ModuleSpec "
"*spec*.  This behaves like :c:func:`PyModule_FromDefAndSpec2` with "
"*module_api_version* set to :c:macro:`PYTHON_API_VERSION`."
msgstr ""

#: ../../c-api/module.rst:505
msgid ""
"Create a new module object, given the definition in *def* and the ModuleSpec "
"*spec*, assuming the API version *module_api_version*. If that version does "
"not match the version of the running interpreter, a :exc:`RuntimeWarning` is "
"emitted."
msgstr ""
"Skapar ett nytt modulobjekt, givet definitionen i *def* och ModuleSpec "
"*spec*, med API-versionen *module_api_version*. Om den versionen inte "
"stämmer överens med versionen i den tolk som körs, skickas en :exc:"
"`RuntimeWarning` ut."

#: ../../c-api/module.rst:514
msgid ""
"Most uses of this function should be using :c:func:`PyModule_FromDefAndSpec` "
"instead; only use this if you are sure you need it."
msgstr ""
"De flesta användningar av denna funktion bör använda :c:func:"
"`PyModule_FromDefAndSpec` istället; använd endast denna om du är säker på "
"att du behöver den."

#: ../../c-api/module.rst:521
msgid "Process any execution slots (:c:data:`Py_mod_exec`) given in *def*."
msgstr ""
"Behandla alla exekveringsplatser (:c:data:`Py_mod_exec`) som anges i *def*."

#: ../../c-api/module.rst:527
msgid ""
"Set the docstring for *module* to *docstring*. This function is called "
"automatically when creating a module from ``PyModuleDef``, using either "
"``PyModule_Create`` or ``PyModule_FromDefAndSpec``."
msgstr ""

#: ../../c-api/module.rst:536
msgid ""
"Add the functions from the ``NULL`` terminated *functions* array to "
"*module*. Refer to the :c:type:`PyMethodDef` documentation for details on "
"individual entries (due to the lack of a shared module namespace, module "
"level \"functions\" implemented in C typically receive the module as their "
"first parameter, making them similar to instance methods on Python classes). "
"This function is called automatically when creating a module from "
"``PyModuleDef``, using either ``PyModule_Create`` or "
"``PyModule_FromDefAndSpec``."
msgstr ""

#: ../../c-api/module.rst:545
msgid ""
"The *functions* array must be statically allocated (or otherwise guaranteed "
"to outlive the module object)."
msgstr ""

#: ../../c-api/module.rst:551
msgid "Support functions"
msgstr "Stödfunktioner"

#: ../../c-api/module.rst:553
msgid ""
"The module initialization function (if using single phase initialization) or "
"a function called from a module execution slot (if using multi-phase "
"initialization), can use the following functions to help initialize the "
"module state:"
msgstr ""

#: ../../c-api/module.rst:560
msgid ""
"Add an object to *module* as *name*.  This is a convenience function which "
"can be used from the module's initialization function."
msgstr ""
"Lägg till ett objekt till *modul* som *namn*.  Detta är en "
"bekvämlighetsfunktion som kan användas från modulens initialiseringsfunktion."

#: ../../c-api/module.rst:563
msgid ""
"On success, return ``0``. On error, raise an exception and return ``-1``."
msgstr ""
"Vid framgång, returnera ``0``. Vid fel, skapa ett undantag och returnera "
"``\\-1``."

#: ../../c-api/module.rst:565 ../../c-api/module.rst:616
#: ../../c-api/module.rst:643
msgid "Example usage::"
msgstr "Exempel på användning::"

#: ../../c-api/module.rst:567
msgid ""
"static int\n"
"add_spam(PyObject *module, int value)\n"
"{\n"
"    PyObject *obj = PyLong_FromLong(value);\n"
"    if (obj == NULL) {\n"
"        return -1;\n"
"    }\n"
"    int res = PyModule_AddObjectRef(module, \"spam\", obj);\n"
"    Py_DECREF(obj);\n"
"    return res;\n"
" }"
msgstr ""
"static int\n"
"add_spam(PyObject *module, int value)\n"
"{\n"
"    PyObject *obj = PyLong_FromLong(value);\n"
"    if (obj == NULL) {\n"
"        return -1;\n"
"    }\n"
"    int res = PyModule_AddObjectRef(module, \"spam\", obj);\n"
"    Py_DECREF(obj);\n"
"    return res;\n"
" }"

#: ../../c-api/module.rst:579
msgid ""
"To be convenient, the function accepts ``NULL`` *value* with an exception "
"set. In this case, return ``-1`` and just leave the raised exception "
"unchanged."
msgstr ""
"För att vara bekväm accepterar funktionen ``NULL`` *värde* med ett undantag. "
"I detta fall returneras ``\\-1`` och det undantag som skapats lämnas "
"oförändrat."

#: ../../c-api/module.rst:583
msgid ""
"The example can also be written without checking explicitly if *obj* is "
"``NULL``::"
msgstr ""
"Exemplet kan också skrivas utan att uttryckligen kontrollera om *obj* är "
"``NULL``::"

#: ../../c-api/module.rst:586
msgid ""
"static int\n"
"add_spam(PyObject *module, int value)\n"
"{\n"
"    PyObject *obj = PyLong_FromLong(value);\n"
"    int res = PyModule_AddObjectRef(module, \"spam\", obj);\n"
"    Py_XDECREF(obj);\n"
"    return res;\n"
" }"
msgstr ""
"static int\n"
"add_spam(PyObject *module, int value)\n"
"{\n"
"    PyObject *obj = PyLong_FromLong(value);\n"
"    int res = PyModule_AddObjectRef(module, \"spam\", obj);\n"
"    Py_XDECREF(obj);\n"
"    return res;\n"
" }"

#: ../../c-api/module.rst:595
msgid ""
"Note that ``Py_XDECREF()`` should be used instead of ``Py_DECREF()`` in this "
"case, since *obj* can be ``NULL``."
msgstr ""
"Observera att ``Py_XDECREF()`` bör användas i stället för ``Py_DECREF()`` i "
"detta fall, eftersom *obj* kan vara ``NULL``."

#: ../../c-api/module.rst:598
msgid ""
"The number of different *name* strings passed to this function should be "
"kept small, usually by only using statically allocated strings as *name*. "
"For names that aren't known at compile time, prefer calling :c:func:"
"`PyUnicode_FromString` and :c:func:`PyObject_SetAttr` directly. For more "
"details, see :c:func:`PyUnicode_InternFromString`, which may be used "
"internally to create a key object."
msgstr ""
"Antalet olika *name*-strängar som skickas till denna funktion bör hållas "
"litet, vanligtvis genom att endast använda statiskt allokerade strängar som "
"*name*. För namn som inte är kända vid kompileringstillfället är det bättre "
"att anropa :c:func:`PyUnicode_FromString` och :c:func:`PyObject_SetAttr` "
"direkt. För mer detaljer, se :c:func:`PyUnicode_InternFromString`, som kan "
"användas internt för att skapa ett nyckelobjekt."

#: ../../c-api/module.rst:611
msgid ""
"Similar to :c:func:`PyModule_AddObjectRef`, but \"steals\" a reference to "
"*value*. It can be called with a result of function that returns a new "
"reference without bothering to check its result or even saving it to a "
"variable."
msgstr ""
"Liknar :c:func:`PyModule_AddObjectRef`, men \"stjäl\" en referens till "
"*värde*. Den kan anropas med ett resultat av en funktion som returnerar en "
"ny referens utan att bry sig om att kontrollera resultatet eller ens spara "
"det i en variabel."

#: ../../c-api/module.rst:618
msgid ""
"if (PyModule_Add(module, \"spam\", PyBytes_FromString(value)) < 0) {\n"
"    goto error;\n"
"}"
msgstr ""
"if (PyModule_Add(module, \"spam\", PyBytes_FromString(value)) < 0) {\n"
"    gå till fel;\n"
"}"

#: ../../c-api/module.rst:627
msgid ""
"Similar to :c:func:`PyModule_AddObjectRef`, but steals a reference to "
"*value* on success (if it returns ``0``)."
msgstr ""
"Liknar :c:func:`PyModule_AddObjectRef`, men stjäl en referens till *värde* "
"vid framgång (om den returnerar ``0``)."

#: ../../c-api/module.rst:630
msgid ""
"The new :c:func:`PyModule_Add` or :c:func:`PyModule_AddObjectRef` functions "
"are recommended, since it is easy to introduce reference leaks by misusing "
"the :c:func:`PyModule_AddObject` function."
msgstr ""
"De nya funktionerna :c:func:`PyModule_Add` eller :c:func:"
"`PyModule_AddObjectRef` rekommenderas, eftersom det är lätt att införa "
"referensläckor genom att missbruka funktionen :c:func:`PyModule_AddObject`."

#: ../../c-api/module.rst:637
msgid ""
"Unlike other functions that steal references, ``PyModule_AddObject()`` only "
"releases the reference to *value* **on success**."
msgstr ""
"Till skillnad från andra funktioner som stjäl referenser, släpper "
"``PyModule_AddObject()`` bara referensen till *värde* **vid framgång**."

#: ../../c-api/module.rst:640
msgid ""
"This means that its return value must be checked, and calling code must :c:"
"func:`Py_XDECREF` *value* manually on error."
msgstr ""
"Detta innebär att dess returvärde måste kontrolleras, och anropande kod "
"måste :c:func:`Py_XDECREF` *värde* manuellt vid fel."

#: ../../c-api/module.rst:645
msgid ""
"PyObject *obj = PyBytes_FromString(value);\n"
"if (PyModule_AddObject(module, \"spam\", obj) < 0) {\n"
"    // If 'obj' is not NULL and PyModule_AddObject() failed,\n"
"    // 'obj' strong reference must be deleted with Py_XDECREF().\n"
"    // If 'obj' is NULL, Py_XDECREF() does nothing.\n"
"    Py_XDECREF(obj);\n"
"    goto error;\n"
"}\n"
"// PyModule_AddObject() stole a reference to obj:\n"
"// Py_XDECREF(obj) is not needed here."
msgstr ""
"PyObject *obj = PyBytes_FromString(value);\n"
"if (PyModule_AddObject(module, \"spam\", obj) < 0) {\n"
"    // If 'obj' is not NULL and PyModule_AddObject() failed,\n"
"    // 'obj' strong reference must be deleted with Py_XDECREF().\n"
"    // If 'obj' is NULL, Py_XDECREF() does nothing.\n"
"    Py_XDECREF(obj);\n"
"    goto error;\n"
"}\n"
"// PyModule_AddObject() stole a reference to obj:\n"
"// Py_XDECREF(obj) is not needed here."

#: ../../c-api/module.rst:658
msgid ":c:func:`PyModule_AddObject` is :term:`soft deprecated`."
msgstr ":c:func:`PyModule_AddObject` är :term:`soft deprecated`."

#: ../../c-api/module.rst:663
msgid ""
"Add an integer constant to *module* as *name*.  This convenience function "
"can be used from the module's initialization function. Return ``-1`` with an "
"exception set on error, ``0`` on success."
msgstr ""
"Lägg till en heltalskonstant till *modul* som *namn*.  Denna "
"bekvämlighetsfunktion kan användas från modulens initialiseringsfunktion. "
"Returnerar ``\\-1`` med ett undantag inställt vid fel, ``0`` vid framgång."

#: ../../c-api/module.rst:667
msgid ""
"This is a convenience function that calls :c:func:`PyLong_FromLong` and :c:"
"func:`PyModule_AddObjectRef`; see their documentation for details."
msgstr ""
"Detta är en bekvämlighetsfunktion som anropar :c:func:`PyLong_FromLong` och :"
"c:func:`PyModule_AddObjectRef`; se deras dokumentation för detaljer."

#: ../../c-api/module.rst:673
msgid ""
"Add a string constant to *module* as *name*.  This convenience function can "
"be used from the module's initialization function.  The string *value* must "
"be ``NULL``-terminated. Return ``-1`` with an exception set on error, ``0`` "
"on success."
msgstr ""
"Lägg till en strängkonstant till *modul* som *namn*.  Denna "
"bekvämlighetsfunktion kan användas från modulens initialiseringsfunktion.  "
"Strängen *värde* måste vara ``NULL``\\-terminerad. Returnerar ``\\-1`` med "
"en undantagsuppsättning vid fel, ``0`` vid framgång."

#: ../../c-api/module.rst:678
msgid ""
"This is a convenience function that calls :c:func:"
"`PyUnicode_InternFromString` and :c:func:`PyModule_AddObjectRef`; see their "
"documentation for details."
msgstr ""
"Detta är en bekvämlighetsfunktion som anropar :c:func:"
"`PyUnicode_InternFromString` och :c:func:`PyModule_AddObjectRef`; se deras "
"dokumentation för detaljer."

#: ../../c-api/module.rst:685
msgid ""
"Add an int constant to *module*. The name and the value are taken from "
"*macro*. For example ``PyModule_AddIntMacro(module, AF_INET)`` adds the int "
"constant *AF_INET* with the value of *AF_INET* to *module*. Return ``-1`` "
"with an exception set on error, ``0`` on success."
msgstr ""
"Lägg till en int-konstant i *modul*. Namnet och värdet hämtas från *macro*. "
"Till exempel ``PyModule_AddIntMacro(module, AF_INET)`` lägger till int-"
"konstanten *AF_INET* med värdet *AF_INET* till *modul*. Returnerar ``\\-1`` "
"med en undantagsuppsättning vid fel, ``0`` vid framgång."

#: ../../c-api/module.rst:693
msgid "Add a string constant to *module*."
msgstr "Lägg till en strängkonstant i *modul*."

#: ../../c-api/module.rst:697
msgid ""
"Add a type object to *module*. The type object is finalized by calling "
"internally :c:func:`PyType_Ready`. The name of the type object is taken from "
"the last component of :c:member:`~PyTypeObject.tp_name` after dot. Return "
"``-1`` with an exception set on error, ``0`` on success."
msgstr ""
"Lägg till ett typobjekt till *modul*. Typobjektet färdigställs genom att "
"internt anropa :c:func:`PyType_Ready`. Namnet på typobjektet hämtas från den "
"sista komponenten i :c:member:`~PyTypeObject.tp_name` efter punkt. "
"Returnerar ``\\-1`` med en exception set vid fel, ``0`` vid framgång."

#: ../../c-api/module.rst:707
msgid ""
"Indicate that *module* does or does not support running without the global "
"interpreter lock (GIL), using one of the values from :c:macro:`Py_mod_gil`. "
"It must be called during *module*'s initialization function. If this "
"function is not called during module initialization, the import machinery "
"assumes the module does not support running without the GIL. This function "
"is only available in Python builds configured with :option:`--disable-gil`. "
"Return ``-1`` with an exception set on error, ``0`` on success."
msgstr ""

#: ../../c-api/module.rst:720
msgid "Module lookup"
msgstr ""

#: ../../c-api/module.rst:722
msgid ""
"Single-phase initialization creates singleton modules that can be looked up "
"in the context of the current interpreter. This allows the module object to "
"be retrieved later with only a reference to the module definition."
msgstr ""

#: ../../c-api/module.rst:726
msgid ""
"These functions will not work on modules created using multi-phase "
"initialization, since multiple such modules can be created from a single "
"definition."
msgstr ""
"Dessa funktioner fungerar inte på moduler som skapats med hjälp av "
"flerfasinitialisering, eftersom flera sådana moduler kan skapas från en enda "
"definition."

#: ../../c-api/module.rst:731
msgid ""
"Returns the module object that was created from *def* for the current "
"interpreter. This method requires that the module object has been attached "
"to the interpreter state with :c:func:`PyState_AddModule` beforehand. In "
"case the corresponding module object is not found or has not been attached "
"to the interpreter state yet, it returns ``NULL``."
msgstr ""
"Returnerar det modulobjekt som skapades från *def* för den aktuella tolken. "
"Denna metod kräver att modulobjektet har kopplats till tolktillståndet med :"
"c:func:`PyState_AddModule` i förväg. Om motsvarande modulobjekt inte hittas "
"eller inte har kopplats till tolktillståndet ännu, returnerar den ``NULL``."

#: ../../c-api/module.rst:738
msgid ""
"Attaches the module object passed to the function to the interpreter state. "
"This allows the module object to be accessible via :c:func:"
"`PyState_FindModule`."
msgstr ""
"Kopplar modulobjektet som skickas till funktionen till tolkens tillstånd. "
"Detta gör att modulobjektet kan nås via :c:func:`PyState_FindModule`."

#: ../../c-api/module.rst:741
msgid "Only effective on modules created using single-phase initialization."
msgstr "Gäller endast för moduler som skapats med enfasinitialisering."

#: ../../c-api/module.rst:743
msgid ""
"Python calls ``PyState_AddModule`` automatically after importing a module, "
"so it is unnecessary (but harmless) to call it from module initialization "
"code. An explicit call is needed only if the module's own init code "
"subsequently calls ``PyState_FindModule``. The function is mainly intended "
"for implementing alternative import mechanisms (either by calling it "
"directly, or by referring to its implementation for details of the required "
"state updates)."
msgstr ""

#: ../../c-api/module.rst:751 ../../c-api/module.rst:762
msgid "The caller must hold the GIL."
msgstr ""

#: ../../c-api/module.rst:753
msgid "Return ``-1`` with an exception set on error, ``0`` on success."
msgstr "Returnerar ``\\-1`` med en exception set vid fel, ``0`` vid framgång."

#: ../../c-api/module.rst:759
msgid ""
"Removes the module object created from *def* from the interpreter state. "
"Return ``-1`` with an exception set on error, ``0`` on success."
msgstr ""
"Tar bort modulobjektet som skapats från *def* från tolkens tillstånd. "
"Returnerar ``\\-1`` med en undantagsuppsättning vid fel, ``0`` vid framgång."

#: ../../c-api/module.rst:8
msgid "object"
msgstr "object"

#: ../../c-api/module.rst:8
msgid "module"
msgstr "module"

#: ../../c-api/module.rst:13
msgid "ModuleType (in module types)"
msgstr "ModuleType (i modultyper)"

#: ../../c-api/module.rst:33 ../../c-api/module.rst:80
msgid "__name__ (module attribute)"
msgstr "__name__ (attribut för modul)"

#: ../../c-api/module.rst:33
msgid "__doc__ (module attribute)"
msgstr "__doc__ (modulattribut)"

#: ../../c-api/module.rst:33 ../../c-api/module.rst:119
msgid "__file__ (module attribute)"
msgstr "__file__ (modulattribut)"

#: ../../c-api/module.rst:33
msgid "__package__ (module attribute)"
msgstr "__package__ (modulattribut)"

#: ../../c-api/module.rst:33
msgid "__loader__ (module attribute)"
msgstr "__loader__ (modulattribut)"

#: ../../c-api/module.rst:63
msgid "__dict__ (module attribute)"
msgstr "__dict__ (modulattribut)"

#: ../../c-api/module.rst:80 ../../c-api/module.rst:119
msgid "SystemError (built-in exception)"
msgstr "SystemError (inbyggt undantag)"
