# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-09 14:15+0000\n"
"PO-Revision-Date: 2025-09-16 00:00+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../c-api/unicode.rst:6
msgid "Unicode Objects and Codecs"
msgstr "Unicode-objekt och codecs"

#: ../../c-api/unicode.rst:12
msgid "Unicode Objects"
msgstr "Unicode-objekt"

#: ../../c-api/unicode.rst:14
msgid ""
"Since the implementation of :pep:`393` in Python 3.3, Unicode objects "
"internally use a variety of representations, in order to allow handling the "
"complete range of Unicode characters while staying memory efficient.  There "
"are special cases for strings where all code points are below 128, 256, or "
"65536; otherwise, code points must be below 1114112 (which is the full "
"Unicode range)."
msgstr ""
"Sedan implementeringen av :pep:`393` i Python 3.3 använder Unicode-objekt "
"internt en mängd olika representationer, för att möjliggöra hantering av "
"hela utbudet av Unicode-tecken samtidigt som de är minneseffektiva.  Det "
"finns specialfall för strängar där alla kodpunkter är under 128, 256 eller "
"65536; annars måste kodpunkterna vara under 1114112 (vilket är hela Unicode-"
"intervallet)."

#: ../../c-api/unicode.rst:20
msgid ""
"UTF-8 representation is created on demand and cached in the Unicode object."
msgstr ""
"UTF-8-representationen skapas på begäran och cachelagras i Unicode-objektet."

#: ../../c-api/unicode.rst:23
msgid ""
"The :c:type:`Py_UNICODE` representation has been removed since Python 3.12 "
"with deprecated APIs. See :pep:`623` for more information."
msgstr ""
"Representationen :c:type:`Py_UNICODE` har tagits bort sedan Python 3.12 med "
"föråldrade API:er. Se :pep:`623` för mer information."

#: ../../c-api/unicode.rst:29
msgid "Unicode Type"
msgstr "Unicode-typ"

#: ../../c-api/unicode.rst:31
msgid ""
"These are the basic Unicode object types used for the Unicode implementation "
"in Python:"
msgstr ""
"Dessa är de grundläggande Unicode-objekttyperna som används för Unicode-"
"implementeringen i Python:"

#: ../../c-api/unicode.rst:36
msgid ""
"This instance of :c:type:`PyTypeObject` represents the Python Unicode type. "
"It is exposed to Python code as :py:class:`str`."
msgstr ""
"Denna instans av :c:type:`PyTypeObject` representerar Pythons Unicode-typ. "
"Den är exponerad för Python-kod som :py:class:`str`."

#: ../../c-api/unicode.rst:42
msgid ""
"This instance of :c:type:`PyTypeObject` represents the Python Unicode "
"iterator type. It is used to iterate over Unicode string objects."
msgstr ""
"Denna instans av :c:type:`PyTypeObject` representerar Pythons Unicode "
"iterator-typ. Den används för att iterera över Unicode-strängobjekt."

#: ../../c-api/unicode.rst:50
msgid ""
"These types are typedefs for unsigned integer types wide enough to contain "
"characters of 32 bits, 16 bits and 8 bits, respectively.  When dealing with "
"single Unicode characters, use :c:type:`Py_UCS4`."
msgstr ""
"Dessa typer är typdefinitioner för osignerade heltalstyper som är "
"tillräckligt breda för att innehålla tecken på 32 bitar, 16 bitar respektive "
"8 bitar.  När du hanterar enstaka Unicode-tecken, använd :c:type:`Py_UCS4`."

#: ../../c-api/unicode.rst:61
msgid ""
"These subtypes of :c:type:`PyObject` represent a Python Unicode object.  In "
"almost all cases, they shouldn't be used directly, since all API functions "
"that deal with Unicode objects take and return :c:type:`PyObject` pointers."
msgstr ""
"Dessa subtyper av :c:type:`PyObject` representerar ett Python Unicode-"
"objekt.  I nästan alla fall bör de inte användas direkt, eftersom alla API-"
"funktioner som hanterar Unicode-objekt tar och returnerar :c:type:`PyObject`-"
"pekare."

#: ../../c-api/unicode.rst:68
msgid ""
"The following APIs are C macros and static inlined functions for fast checks "
"and access to internal read-only data of Unicode objects:"
msgstr ""
"Följande API:er är C-makron och statiska inline-funktioner för snabba "
"kontroller och åtkomst till interna skrivskyddade data i Unicode-objekt:"

#: ../../c-api/unicode.rst:73
msgid ""
"Return true if the object *obj* is a Unicode object or an instance of a "
"Unicode subtype.  This function always succeeds."
msgstr ""
"Returnerar true om objektet *obj* är ett Unicode-objekt eller en instans av "
"en Unicode-subtyp.  Denna funktion lyckas alltid."

#: ../../c-api/unicode.rst:79
msgid ""
"Return true if the object *obj* is a Unicode object, but not an instance of "
"a subtype.  This function always succeeds."
msgstr ""
"Returnerar true om objektet *obj* är ett Unicode-objekt, men inte en instans "
"av en subtyp.  Denna funktion lyckas alltid."

#: ../../c-api/unicode.rst:85
msgid ""
"Return the length of the Unicode string, in code points.  *unicode* has to "
"be a Unicode object in the \"canonical\" representation (not checked)."
msgstr ""
"Returnerar längden på Unicode-strängen i kodpunkter.  *unicode* måste vara "
"ett Unicode-objekt i den \"kanoniska\" representationen (kontrolleras inte)."

#: ../../c-api/unicode.rst:95
msgid ""
"Return a pointer to the canonical representation cast to UCS1, UCS2 or UCS4 "
"integer types for direct character access.  No checks are performed if the "
"canonical representation has the correct character size; use :c:func:"
"`PyUnicode_KIND` to select the right function."
msgstr ""
"Returnerar en pekare till den kanoniska representationen omgjord till "
"heltalstyperna UCS1, UCS2 eller UCS4 för direkt teckenåtkomst.  Inga "
"kontroller utförs om den kanoniska representationen har rätt teckenstorlek; "
"använd :c:func:`PyUnicode_KIND` för att välja rätt funktion."

#: ../../c-api/unicode.rst:107
msgid "Return values of the :c:func:`PyUnicode_KIND` macro."
msgstr "Returvärden för makrot :c:func:`PyUnicode_KIND`."

#: ../../c-api/unicode.rst:111
msgid "``PyUnicode_WCHAR_KIND`` has been removed."
msgstr "``PyUnicode_WCHAR_KIND`` har tagits bort."

#: ../../c-api/unicode.rst:117
msgid ""
"Return one of the PyUnicode kind constants (see above) that indicate how "
"many bytes per character this Unicode object uses to store its data.  "
"*unicode* has to be a Unicode object in the \"canonical\" representation "
"(not checked)."
msgstr ""
"Returnerar en av PyUnicodes kindkonstanter (se ovan) som anger hur många "
"byte per tecken som detta Unicode-objekt använder för att lagra sina data.  "
"*unicode* måste vara ett Unicode-objekt i den \"kanoniska\" representationen "
"(ej kontrollerat)."

#: ../../c-api/unicode.rst:126
msgid ""
"Return a void pointer to the raw Unicode buffer.  *unicode* has to be a "
"Unicode object in the \"canonical\" representation (not checked)."
msgstr ""
"Returnerar en voidpekare till den råa Unicode-bufferten.  *unicode* måste "
"vara ett Unicode-objekt i den \"kanoniska\" representationen (kontrolleras "
"inte)."

#: ../../c-api/unicode.rst:135
msgid ""
"Write the code point *value* to the given zero-based *index* in a string."
msgstr ""
"Skriv kodpunktens *värde* till det givna nollbaserade *indexet* i en sträng."

#: ../../c-api/unicode.rst:137
msgid ""
"The *kind* value and *data* pointer must have been obtained from a string "
"using :c:func:`PyUnicode_KIND` and :c:func:`PyUnicode_DATA` respectively. "
"You must hold a reference to that string while calling :c:func:`!"
"PyUnicode_WRITE`. All requirements of :c:func:`PyUnicode_WriteChar` also "
"apply."
msgstr ""
"Värdet *kind* och pekaren *data* måste ha erhållits från en sträng med hjälp "
"av :c:func:`PyUnicode_KIND` respektive :c:func:`PyUnicode_DATA`. Du måste "
"hålla en referens till den strängen när du anropar :c:func:`!"
"PyUnicode_WRITE`. Alla krav för :c:func:`PyUnicode_WriteChar` gäller också."

#: ../../c-api/unicode.rst:143
msgid ""
"The function performs no checks for any of its requirements, and is intended "
"for usage in loops."
msgstr ""
"Funktionen utför inga kontroller för något av sina krav och är avsedd att "
"användas i loopar."

#: ../../c-api/unicode.rst:152
msgid ""
"Read a code point from a canonical representation *data* (as obtained with :"
"c:func:`PyUnicode_DATA`).  No checks or ready calls are performed."
msgstr ""
"Läser en kodpunkt från en kanonisk representation *data* (som erhålls med :c:"
"func:`PyUnicode_DATA`).  Inga kontroller eller ready-anrop utförs."

#: ../../c-api/unicode.rst:160
msgid ""
"Read a character from a Unicode object *unicode*, which must be in the "
"\"canonical\" representation.  This is less efficient than :c:func:"
"`PyUnicode_READ` if you do multiple consecutive reads."
msgstr ""
"Läser ett tecken från ett Unicode-objekt *unicode*, som måste vara i den "
"\"kanoniska\" representationen.  Detta är mindre effektivt än :c:func:"
"`PyUnicode_READ` om du gör flera på varandra följande läsningar."

#: ../../c-api/unicode.rst:169
msgid ""
"Return the maximum code point that is suitable for creating another string "
"based on *unicode*, which must be in the \"canonical\" representation.  This "
"is always an approximation but more efficient than iterating over the string."
msgstr ""
"Returnerar den maximala kodpunkt som är lämplig för att skapa en annan "
"sträng baserad på *unicode*, som måste vara i den \"kanoniska\" "
"representationen.  Detta är alltid en approximation men mer effektivt än att "
"iterera över strängen."

#: ../../c-api/unicode.rst:178
msgid ""
"Return ``1`` if the string is a valid identifier according to the language "
"definition, section :ref:`identifiers`. Return ``0`` otherwise."
msgstr ""
"Returnerar ``1`` om strängen är en giltig identifierare enligt "
"språkdefinitionen, avsnitt :ref:`identifiers`. Returnerar ``0`` annars."

#: ../../c-api/unicode.rst:181
msgid ""
"The function does not call :c:func:`Py_FatalError` anymore if the string is "
"not ready."
msgstr ""
"Funktionen anropar inte :c:func:`Py_FatalError` längre om strängen inte är "
"klar."

#: ../../c-api/unicode.rst:188
msgid ""
"Return true if the string only contains ASCII characters. Equivalent to :py:"
"meth:`str.isascii`."
msgstr ""
"Returnerar true om strängen bara innehåller ASCII-tecken. Motsvarar :py:meth:"
"`str.isascii`."

#: ../../c-api/unicode.rst:195
msgid "Unicode Character Properties"
msgstr "Egenskaper för Unicode-tecken"

#: ../../c-api/unicode.rst:197
msgid ""
"Unicode provides many different character properties. The most often needed "
"ones are available through these macros which are mapped to C functions "
"depending on the Python configuration."
msgstr ""
"Unicode tillhandahåller många olika teckenegenskaper. De som oftast behövs "
"är tillgängliga via dessa makron som mappas till C-funktioner beroende på "
"Python-konfigurationen."

#: ../../c-api/unicode.rst:204
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a whitespace character."
msgstr ""
"Returnerar ``1`` eller ``0`` beroende på om *ch* är ett blankstegstecken."

#: ../../c-api/unicode.rst:209
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a lowercase character."
msgstr ""
"Returnerar ``1`` eller ``0`` beroende på om *ch* är ett gemener-tecken."

#: ../../c-api/unicode.rst:214
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is an uppercase character."
msgstr ""
"Returnerar ``1`` eller ``0`` beroende på om *ch* är ett versalt tecken."

#: ../../c-api/unicode.rst:219
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a titlecase character."
msgstr "Returnerar ``1`` eller ``0`` beroende på om *ch* är en titelbokstav."

#: ../../c-api/unicode.rst:224
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a linebreak character."
msgstr ""
"Returnerar ``1`` eller ``0`` beroende på om *ch* är ett tecken för "
"radbrytning."

#: ../../c-api/unicode.rst:229
msgid "Return ``1`` or ``0`` depending on whether *ch* is a decimal character."
msgstr "Returnerar ``1`` eller ``0`` beroende på om *ch* är ett decimaltecken."

#: ../../c-api/unicode.rst:234
msgid "Return ``1`` or ``0`` depending on whether *ch* is a digit character."
msgstr "Returnerar ``1`` eller ``0`` beroende på om *ch* är ett siffertecken."

#: ../../c-api/unicode.rst:239
msgid "Return ``1`` or ``0`` depending on whether *ch* is a numeric character."
msgstr ""
"Returnerar ``1`` eller ``0`` beroende på om *ch* är ett numeriskt tecken."

#: ../../c-api/unicode.rst:244
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is an alphabetic character."
msgstr ""
"Returnerar ``1`` eller ``0`` beroende på om *ch* är ett alfabetiskt tecken."

#: ../../c-api/unicode.rst:249
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is an alphanumeric character."
msgstr ""
"Returnerar ``1`` eller ``0`` beroende på om *ch* är ett alfanumeriskt tecken."

#: ../../c-api/unicode.rst:254
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a printable character, in "
"the sense of :meth:`str.isprintable`."
msgstr ""
"Returnerar ``1`` eller ``0`` beroende på om *ch* är ett tryckbart tecken, i "
"betydelsen :meth:`str.isprintable`."

#: ../../c-api/unicode.rst:258
msgid "These APIs can be used for fast direct character conversions:"
msgstr "Dessa API:er kan användas för snabba direkta teckenkonverteringar:"

#: ../../c-api/unicode.rst:263
msgid "Return the character *ch* converted to lower case."
msgstr "Returnera tecknet *ch* konverterat till gemener."

#: ../../c-api/unicode.rst:268
msgid "Return the character *ch* converted to upper case."
msgstr "Returnera tecknet *ch* konverterat till versaler."

#: ../../c-api/unicode.rst:273
msgid "Return the character *ch* converted to title case."
msgstr "Returnera tecknet *ch* konverterat till titelfall."

#: ../../c-api/unicode.rst:278
msgid ""
"Return the character *ch* converted to a decimal positive integer.  Return "
"``-1`` if this is not possible.  This function does not raise exceptions."
msgstr ""
"Returnerar tecknet *ch* konverterat till ett positivt decimalt heltal.  "
"Returnera ``-1`` om detta inte är möjligt.  Denna funktion ger inte upphov "
"till undantag."

#: ../../c-api/unicode.rst:284
msgid ""
"Return the character *ch* converted to a single digit integer. Return ``-1`` "
"if this is not possible.  This function does not raise exceptions."
msgstr ""
"Returnerar tecknet *ch* omvandlat till ett ensiffrigt heltal. Returnera "
"``-1`` om detta inte är möjligt.  Denna funktion ger inte upphov till "
"undantag."

#: ../../c-api/unicode.rst:290
msgid ""
"Return the character *ch* converted to a double. Return ``-1.0`` if this is "
"not possible.  This function does not raise exceptions."
msgstr ""
"Returnerar tecknet *ch* omvandlat till en dubbel. Returnera ``-1.0`` om "
"detta inte är möjligt.  Denna funktion ger inte upphov till undantag."

#: ../../c-api/unicode.rst:294
msgid "These APIs can be used to work with surrogates:"
msgstr "Dessa API:er kan användas för att arbeta med surrogat:"

#: ../../c-api/unicode.rst:298
msgid "Check if *ch* is a surrogate (``0xD800 <= ch <= 0xDFFF``)."
msgstr "Kontrollera om *ch* är ett surrogat (``0xD800 <= ch <= 0xDFFF``)."

#: ../../c-api/unicode.rst:302
msgid "Check if *ch* is a high surrogate (``0xD800 <= ch <= 0xDBFF``)."
msgstr "Kontrollera om *ch* är ett högt surrogat (``0xD800 <= ch <= 0xDBFF``)."

#: ../../c-api/unicode.rst:306
msgid "Check if *ch* is a low surrogate (``0xDC00 <= ch <= 0xDFFF``)."
msgstr "Kontrollera om *ch* är ett lågt surrogat (``0xDC00 <= ch <= 0xDFFF``)."

#: ../../c-api/unicode.rst:310
msgid ""
"Join two surrogate code points and return a single :c:type:`Py_UCS4` value. "
"*high* and *low* are respectively the leading and trailing surrogates in a "
"surrogate pair. *high* must be in the range [0xD800; 0xDBFF] and *low* must "
"be in the range [0xDC00; 0xDFFF]."
msgstr ""
"Sammanfogar två surrogatkodpunkter och returnerar ett enda :c:type:`Py_UCS4`-"
"värde. *high* och *low* är det inledande respektive det avslutande "
"surrogatet i ett surrogatpar. *high* måste ligga inom intervallet [0xD800; "
"0xDBFF] och *low* måste ligga inom intervallet [0xDC00; 0xDFFF]."

#: ../../c-api/unicode.rst:317
msgid "Creating and accessing Unicode strings"
msgstr "Skapa och få tillgång till Unicode-strängar"

#: ../../c-api/unicode.rst:319
msgid ""
"To create Unicode objects and access their basic sequence properties, use "
"these APIs:"
msgstr ""
"Använd dessa API:er för att skapa Unicode-objekt och få tillgång till deras "
"grundläggande sekvensegenskaper:"

#: ../../c-api/unicode.rst:324
msgid ""
"Create a new Unicode object.  *maxchar* should be the true maximum code "
"point to be placed in the string.  As an approximation, it can be rounded up "
"to the nearest value in the sequence 127, 255, 65535, 1114111."
msgstr ""
"Skapa ett nytt Unicode-objekt.  *maxchar* bör vara den verkliga maximala "
"kodpunkten som ska placeras i strängen.  Som en approximation kan det "
"avrundas uppåt till närmaste värde i sekvensen 127, 255, 65535, 1114111."

#: ../../c-api/unicode.rst:328
msgid "On error, set an exception and return ``NULL``."
msgstr "Vid fel, sätt ett undantag och returnera ``NULL``."

#: ../../c-api/unicode.rst:330
msgid ""
"After creation, the string can be filled by :c:func:`PyUnicode_WriteChar`, :"
"c:func:`PyUnicode_CopyCharacters`, :c:func:`PyUnicode_Fill`, :c:func:"
"`PyUnicode_WRITE` or similar. Since strings are supposed to be immutable, "
"take care to not “use” the result while it is being modified. In particular, "
"before it's filled with its final contents, a string:"
msgstr ""
"Efter skapandet kan strängen fyllas med :c:func:`PyUnicode_WriteChar`, :c:"
"func:`PyUnicode_CopyCharacters`, :c:func:`PyUnicode_Fill`, :c:func:"
"`PyUnicode_WRITE` eller liknande. Eftersom strängar är tänkta att vara "
"oföränderliga, se till att inte \"använda\" resultatet medan det modifieras. "
"I synnerhet innan den fylls med sitt slutliga innehåll, en sträng:"

#: ../../c-api/unicode.rst:337
msgid "must not be hashed,"
msgstr "får inte vara hashad,"

#: ../../c-api/unicode.rst:338
msgid ""
"must not be :c:func:`converted to UTF-8 <PyUnicode_AsUTF8AndSize>`, or "
"another non-\"canonical\" representation,"
msgstr ""
"får inte vara :c:func:`konverterad till UTF-8 <PyUnicode_AsUTF8AndSize>`, "
"eller någon annan icke-\"kanonisk\" representation,"

#: ../../c-api/unicode.rst:340
msgid "must not have its reference count changed,"
msgstr "får inte få sitt referensantal ändrat,"

#: ../../c-api/unicode.rst:341
msgid "must not be shared with code that might do one of the above."
msgstr "får inte delas med kod som kan göra något av ovanstående."

#: ../../c-api/unicode.rst:343
msgid ""
"This list is not exhaustive. Avoiding these uses is your responsibility; "
"Python does not always check these requirements."
msgstr ""
"Denna lista är inte uttömmande. Att undvika dessa användningsområden är ditt "
"ansvar; Python kontrollerar inte alltid dessa krav."

#: ../../c-api/unicode.rst:346
msgid ""
"To avoid accidentally exposing a partially-written string object, prefer "
"using the :c:type:`PyUnicodeWriter` API, or one of the ``PyUnicode_From*`` "
"functions below."
msgstr ""
"För att undvika att oavsiktligt exponera ett delvis skrivet strängobjekt, "
"använd hellre API:et :c:type:`PyUnicodeWriter` eller någon av funktionerna "
"``PyUnicode_From*`` nedan."

#: ../../c-api/unicode.rst:357
msgid ""
"Create a new Unicode object with the given *kind* (possible values are :c:"
"macro:`PyUnicode_1BYTE_KIND` etc., as returned by :c:func:"
"`PyUnicode_KIND`).  The *buffer* must point to an array of *size* units of "
"1, 2 or 4 bytes per character, as given by the kind."
msgstr ""
"Skapa ett nytt Unicode-objekt med den angivna *typen* (möjliga värden är :c:"
"macro:`PyUnicode_1BYTE_KIND` etc., som returneras av :c:func:"
"`PyUnicode_KIND`).  *Buffer* måste peka på en array av *size*-enheter på 1, "
"2 eller 4 byte per tecken, enligt vad som anges av kind."

#: ../../c-api/unicode.rst:362
msgid ""
"If necessary, the input *buffer* is copied and transformed into the "
"canonical representation.  For example, if the *buffer* is a UCS4 string (:c:"
"macro:`PyUnicode_4BYTE_KIND`) and it consists only of codepoints in the UCS1 "
"range, it will be transformed into UCS1 (:c:macro:`PyUnicode_1BYTE_KIND`)."
msgstr ""
"Om det behövs kopieras och transformeras indata *buffer* till den kanoniska "
"representationen.  Om *bufferten* till exempel är en UCS4-sträng (:c:macro:"
"`PyUnicode_4BYTE_KIND`) och den endast består av kodpunkter i UCS1-"
"intervallet, kommer den att omvandlas till UCS1 (:c:macro:"
"`PyUnicode_1BYTE_KIND`)."

#: ../../c-api/unicode.rst:373
msgid ""
"Create a Unicode object from the char buffer *str*.  The bytes will be "
"interpreted as being UTF-8 encoded.  The buffer is copied into the new "
"object. The return value might be a shared object, i.e. modification of the "
"data is not allowed."
msgstr ""
"Skapa ett Unicode-objekt från char-bufferten *str*.  Bytesen kommer att "
"tolkas som UTF-8-kodade.  Bufferten kopieras in i det nya objektet. "
"Returvärdet kan vara ett delat objekt, d.v.s. det är inte tillåtet att ändra "
"data."

#: ../../c-api/unicode.rst:379
msgid "This function raises :exc:`SystemError` when:"
msgstr "Denna funktion ger upphov till :exc:`SystemError` när:"

#: ../../c-api/unicode.rst:381
msgid "*size* < 0,"
msgstr "*storlek* < 0,"

#: ../../c-api/unicode.rst:382
msgid "*str* is ``NULL`` and *size* > 0"
msgstr "*str* är ``NULL`` och *size* > 0"

#: ../../c-api/unicode.rst:384
msgid "*str* == ``NULL`` with *size* > 0 is not allowed anymore."
msgstr "*str* == ``NULL`` med *size* > 0 är inte tillåtet längre."

#: ../../c-api/unicode.rst:390
msgid ""
"Create a Unicode object from a UTF-8 encoded null-terminated char buffer "
"*str*."
msgstr ""
"Skapa ett Unicode-objekt från en UTF-8-kodad nollavslutad char-buffert *str*."

#: ../../c-api/unicode.rst:396
msgid ""
"Take a C :c:func:`printf`\\ -style *format* string and a variable number of "
"arguments, calculate the size of the resulting Python Unicode string and "
"return a string with the values formatted into it.  The variable arguments "
"must be C types and must correspond exactly to the format characters in the "
"*format* ASCII-encoded string."
msgstr ""
"Tar en C :c:func:`printf`-stil *format*-sträng och ett variabelt antal "
"argument, beräknar storleken på den resulterande Python Unicode-strängen och "
"returnerar en sträng med de värden som formaterats i den.  De variabla "
"argumenten måste vara C-typer och måste exakt motsvara formattecknen i den "
"ASCII-kodade strängen *format*."

#: ../../c-api/unicode.rst:402
msgid ""
"A conversion specifier contains two or more characters and has the following "
"components, which must occur in this order:"
msgstr ""
"En konverteringsspecifikator innehåller två eller flera tecken och har "
"följande komponenter, som måste förekomma i denna ordning:"

#: ../../c-api/unicode.rst:405
msgid "The ``'%'`` character, which marks the start of the specifier."
msgstr "Tecknet ``'%'``, som markerar början på specifikationen."

#: ../../c-api/unicode.rst:407
msgid ""
"Conversion flags (optional), which affect the result of some conversion "
"types."
msgstr ""
"Konverteringsflaggor (valfritt), som påverkar resultatet av vissa "
"konverteringstyper."

#: ../../c-api/unicode.rst:410
msgid ""
"Minimum field width (optional). If specified as an ``'*'`` (asterisk), the "
"actual width is given in the next argument, which must be of type :c:expr:"
"`int`, and the object to convert comes after the minimum field width and "
"optional precision."
msgstr ""
"Minsta fältbredd (valfritt). Om den anges som en ``'*'`` (asterisk) ges den "
"faktiska bredden i nästa argument, som måste vara av typen :c:expr:`int`, "
"och objektet som ska konverteras kommer efter den minsta fältbredden och den "
"valfria precisionen."

#: ../../c-api/unicode.rst:415
msgid ""
"Precision (optional), given as a ``'.'`` (dot) followed by the precision. If "
"specified as ``'*'`` (an asterisk), the actual precision is given in the "
"next argument, which must be of type :c:expr:`int`, and the value to convert "
"comes after the precision."
msgstr ""
"Precision (valfri), anges som en ``'.'`` (punkt) följt av precisionen. Om "
"den anges som ``'*'`` (en asterisk) anges den faktiska precisionen i nästa "
"argument, som måste vara av typen :c:expr:`int`, och värdet som ska "
"konverteras kommer efter precisionen."

#: ../../c-api/unicode.rst:420
msgid "Length modifier (optional)."
msgstr "Längdmodifierare (valfritt)."

#: ../../c-api/unicode.rst:422
msgid "Conversion type."
msgstr "Typ av konvertering."

#: ../../c-api/unicode.rst:424
msgid "The conversion flag characters are:"
msgstr "Konverteringens flaggtecken är:"

#: ../../c-api/unicode.rst:429
msgid "Flag"
msgstr "Flagga"

#: ../../c-api/unicode.rst:429
msgid "Meaning"
msgstr "Betydelse"

#: ../../c-api/unicode.rst:431
msgid "``0``"
msgstr "``0``"

#: ../../c-api/unicode.rst:431
msgid "The conversion will be zero padded for numeric values."
msgstr "Omvandlingen kommer att nollställas för numeriska värden."

#: ../../c-api/unicode.rst:433
msgid "``-``"
msgstr "``-``"

#: ../../c-api/unicode.rst:433
msgid ""
"The converted value is left adjusted (overrides the ``0`` flag if both are "
"given)."
msgstr ""
"Det konverterade värdet lämnas justerat (åsidosätter flaggan ``0`` om båda "
"är angivna)."

#: ../../c-api/unicode.rst:437
msgid ""
"The length modifiers for following integer conversions (``d``, ``i``, ``o``, "
"``u``, ``x``, or ``X``) specify the type of the argument (:c:expr:`int` by "
"default):"
msgstr ""
"Längdmodifierarna för följande heltalskonverteringar (``d``, ``i``, ``o``, "
"``u``, ``x`` eller ``X``) anger typen av argument (:c:expr:`int` som "
"standard):"

#: ../../c-api/unicode.rst:444
msgid "Modifier"
msgstr "Modifierare"

#: ../../c-api/unicode.rst:444
msgid "Types"
msgstr "Typer"

#: ../../c-api/unicode.rst:446
msgid "``l``"
msgstr "``l``"

#: ../../c-api/unicode.rst:446
msgid ":c:expr:`long` or :c:expr:`unsigned long`"
msgstr ":c:expr:`long` eller :c:expr:`unsigned long`"

#: ../../c-api/unicode.rst:448
msgid "``ll``"
msgstr "``ll``"

#: ../../c-api/unicode.rst:448
msgid ":c:expr:`long long` or :c:expr:`unsigned long long`"
msgstr ":c:expr:`long long` eller :c:expr:`unsigned long long`"

#: ../../c-api/unicode.rst:450
msgid "``j``"
msgstr "``j``"

#: ../../c-api/unicode.rst:450
msgid ":c:type:`intmax_t` or :c:type:`uintmax_t`"
msgstr ":c:type:`intmax_t` eller :c:type:`uintmax_t`"

#: ../../c-api/unicode.rst:452
msgid "``z``"
msgstr "``z``"

#: ../../c-api/unicode.rst:452
msgid ":c:type:`size_t` or :c:type:`ssize_t`"
msgstr ":c:type:`size_t` eller :c:type:`ssize_t`"

#: ../../c-api/unicode.rst:454
msgid "``t``"
msgstr "``t``"

#: ../../c-api/unicode.rst:454
msgid ":c:type:`ptrdiff_t`"
msgstr ":c:typ:`ptrdiff_t`"

#: ../../c-api/unicode.rst:457
msgid ""
"The length modifier ``l`` for following conversions ``s`` or ``V`` specify "
"that the type of the argument is :c:expr:`const wchar_t*`."
msgstr ""
"Längdmodifieraren ``l`` för följande konverteringar ``s`` eller ``V`` anger "
"att argumentets typ är :c:expr:`const wchar_t*`."

#: ../../c-api/unicode.rst:460
msgid "The conversion specifiers are:"
msgstr "Konverteringsspecifikationerna är:"

#: ../../c-api/unicode.rst:466
msgid "Conversion Specifier"
msgstr "Specifikator för konvertering"

#: ../../c-api/unicode.rst:467
msgid "Type"
msgstr "Typ"

#: ../../c-api/unicode.rst:468
msgid "Comment"
msgstr "Kommentar"

#: ../../c-api/unicode.rst:470
msgid "``%``"
msgstr "``%``"

#: ../../c-api/unicode.rst:471
msgid "*n/a*"
msgstr "*n/a*"

#: ../../c-api/unicode.rst:472
msgid "The literal ``%`` character."
msgstr "Det bokstavliga tecknet ``%``."

#: ../../c-api/unicode.rst:474
msgid "``d``, ``i``"
msgstr "``d``, ``i``"

#: ../../c-api/unicode.rst:475 ../../c-api/unicode.rst:479
#: ../../c-api/unicode.rst:483 ../../c-api/unicode.rst:487
#: ../../c-api/unicode.rst:491
msgid "Specified by the length modifier"
msgstr "Specificeras av längdmodifieraren"

#: ../../c-api/unicode.rst:476
msgid "The decimal representation of a signed C integer."
msgstr "Decimal representation av ett signerat C heltal."

#: ../../c-api/unicode.rst:478
msgid "``u``"
msgstr "``u``"

#: ../../c-api/unicode.rst:480
msgid "The decimal representation of an unsigned C integer."
msgstr "Decimal representation av ett osignerat C heltal."

#: ../../c-api/unicode.rst:482
msgid "``o``"
msgstr "``o``"

#: ../../c-api/unicode.rst:484
msgid "The octal representation of an unsigned C integer."
msgstr "Oktalrepresentation av ett osignerat C- heltal."

#: ../../c-api/unicode.rst:486
msgid "``x``"
msgstr "``x``"

#: ../../c-api/unicode.rst:488
msgid "The hexadecimal representation of an unsigned C integer (lowercase)."
msgstr ""
"Den hexadecimala representationen av ett osignerat C heltal (små bokstäver)."

#: ../../c-api/unicode.rst:490
msgid "``X``"
msgstr "``X``"

#: ../../c-api/unicode.rst:492
msgid "The hexadecimal representation of an unsigned C integer (uppercase)."
msgstr ""
"Den hexadecimala representationen av ett osignerat C heltal (versaler)."

#: ../../c-api/unicode.rst:494
msgid "``c``"
msgstr "``c``"

#: ../../c-api/unicode.rst:495
msgid ":c:expr:`int`"
msgstr ":c:expr:`int`"

#: ../../c-api/unicode.rst:496
msgid "A single character."
msgstr "Ett enda tecken."

#: ../../c-api/unicode.rst:498
msgid "``s``"
msgstr "``s``"

#: ../../c-api/unicode.rst:499
msgid ":c:expr:`const char*` or :c:expr:`const wchar_t*`"
msgstr ":c:expr:`const char*` eller :c:expr:`const wchar_t*`"

#: ../../c-api/unicode.rst:500
msgid "A null-terminated C character array."
msgstr "En nollavslutad C-teckenmatris."

#: ../../c-api/unicode.rst:502
msgid "``p``"
msgstr "``p``"

#: ../../c-api/unicode.rst:503
msgid ":c:expr:`const void*`"
msgstr ":c:expr:`const void*`"

#: ../../c-api/unicode.rst:504
msgid ""
"The hex representation of a C  pointer. Mostly equivalent to "
"``printf(\"%p\")`` except that it is guaranteed to start with the literal "
"``0x`` regardless of what the platform's ``printf`` yields."
msgstr ""
"Hex-representationen av en C-pekare. I stort sett likvärdig med "
"``printf(\"%p\")`` förutom att den garanterat börjar med den bokstavliga "
"``0x`` oavsett vad plattformens ``printf`` ger."

#: ../../c-api/unicode.rst:509
msgid "``A``"
msgstr "``A``"

#: ../../c-api/unicode.rst:510 ../../c-api/unicode.rst:514
#: ../../c-api/unicode.rst:524 ../../c-api/unicode.rst:528
#: ../../c-api/unicode.rst:532 ../../c-api/unicode.rst:537
msgid ":c:expr:`PyObject*`"
msgstr ":c:expr:`PyObject*`"

#: ../../c-api/unicode.rst:511
msgid "The result of calling :func:`ascii`."
msgstr "Resultatet av att anropa :func:`ascii`."

#: ../../c-api/unicode.rst:513
msgid "``U``"
msgstr "``U``"

#: ../../c-api/unicode.rst:515
msgid "A Unicode object."
msgstr "Ett Unicode-objekt."

#: ../../c-api/unicode.rst:517
msgid "``V``"
msgstr "``V``"

#: ../../c-api/unicode.rst:518
msgid ":c:expr:`PyObject*`, :c:expr:`const char*` or :c:expr:`const wchar_t*`"
msgstr ""
":c:expr:`PyObject*`, :c:expr:`const char*` eller :c:expr:`const wchar_t*`"

#: ../../c-api/unicode.rst:519
msgid ""
"A Unicode object (which may be ``NULL``) and a null-terminated C character "
"array as a second parameter (which will be used, if the first parameter is "
"``NULL``)."
msgstr ""
"Ett Unicode-objekt (som kan vara ``NULL``) och en nollterminerad C-"
"teckenarray som andra parameter (som kommer att användas om den första "
"parametern är ``NULL``)."

#: ../../c-api/unicode.rst:523
msgid "``S``"
msgstr "``S``"

#: ../../c-api/unicode.rst:525
msgid "The result of calling :c:func:`PyObject_Str`."
msgstr "Resultatet av anropet av :c:func:`PyObject_Str`."

#: ../../c-api/unicode.rst:527
msgid "``R``"
msgstr "``R``"

#: ../../c-api/unicode.rst:529
msgid "The result of calling :c:func:`PyObject_Repr`."
msgstr "Resultatet av anropet :c:func:`PyObject_Repr`."

#: ../../c-api/unicode.rst:531
msgid "``T``"
msgstr "``T``"

#: ../../c-api/unicode.rst:533
msgid ""
"Get the fully qualified name of an object type; call :c:func:"
"`PyType_GetFullyQualifiedName`."
msgstr ""
"Hämta det fullständigt kvalificerade namnet på en objekttyp; anropa :c:func:"
"`PyType_GetFullyQualifiedName`."

#: ../../c-api/unicode.rst:536
msgid "``#T``"
msgstr "``#T``"

#: ../../c-api/unicode.rst:538
msgid ""
"Similar to ``T`` format, but use a colon (``:``) as separator between the "
"module name and the qualified name."
msgstr ""
"Liknar formatet ``T``, men använder ett kolon (``:``) som avgränsare mellan "
"modulnamnet och det kvalificerade namnet."

#: ../../c-api/unicode.rst:541
msgid "``N``"
msgstr "``N``"

#: ../../c-api/unicode.rst:542 ../../c-api/unicode.rst:547
msgid ":c:expr:`PyTypeObject*`"
msgstr ":c:expr:`PyTypeObject*`"

#: ../../c-api/unicode.rst:543
msgid ""
"Get the fully qualified name of a type; call :c:func:"
"`PyType_GetFullyQualifiedName`."
msgstr ""
"Hämta det fullständigt kvalificerade namnet på en typ; anropa :c:func:"
"`PyType_GetFullyQualifiedName`."

#: ../../c-api/unicode.rst:546
msgid "``#N``"
msgstr "``#N``"

#: ../../c-api/unicode.rst:548
msgid ""
"Similar to ``N`` format, but use a colon (``:``) as separator between the "
"module name and the qualified name."
msgstr ""
"Liknar formatet ``N``, men använder ett kolon (``:``) som avgränsare mellan "
"modulnamnet och det kvalificerade namnet."

#: ../../c-api/unicode.rst:552
msgid ""
"The width formatter unit is number of characters rather than bytes. The "
"precision formatter unit is number of bytes or :c:type:`wchar_t` items (if "
"the length modifier ``l`` is used) for ``\"%s\"`` and ``\"%V\"`` (if the "
"``PyObject*`` argument is ``NULL``), and a number of characters for "
"``\"%A\"``, ``\"%U\"``, ``\"%S\"``, ``\"%R\"`` and ``\"%V\"`` (if the "
"``PyObject*`` argument is not ``NULL``)."
msgstr ""
"Formateringsenheten för bredd är antal tecken i stället för bytes. "
"Formateringsenheten för precision är antal byte eller :c:type:`wchar_t`-"
"objekt (om längdmodifieraren ``l`` används) för ``\"%s\"`` och ``\"%V\"`` "
"(om argumentet ``PyObject*`` är ``NULL``), och ett antal tecken för "
"``\"%A\"``, ``\"%U\"``, ``\"%S\"``, ``\"%R\"`` och ``\"%V\"`` (om argumentet "
"``PyObject*`` inte är ``NULL``)."

#: ../../c-api/unicode.rst:560
msgid ""
"Unlike to C :c:func:`printf` the ``0`` flag has effect even when a precision "
"is given for integer conversions (``d``, ``i``, ``u``, ``o``, ``x``, or "
"``X``)."
msgstr ""
"Till skillnad från C :c:func:`printf` har flaggan ``0`` effekt även när en "
"precision anges för heltalskonverteringar (``d``, ``i``, ``u``, ``o``, ``x`` "
"eller ``X``)."

#: ../../c-api/unicode.rst:564
msgid "Support for ``\"%lld\"`` and ``\"%llu\"`` added."
msgstr "Stöd för ``\"%lld\"`` och ``\"%llu\"`` tillagt."

#: ../../c-api/unicode.rst:567
msgid "Support for ``\"%li\"``, ``\"%lli\"`` and ``\"%zi\"`` added."
msgstr "Stöd för ``\"%li\"``, ``\"%lli\"`` och ``\"%zi\"`` tillagt."

#: ../../c-api/unicode.rst:570
msgid ""
"Support width and precision formatter for ``\"%s\"``, ``\"%A\"``, "
"``\"%U\"``, ``\"%V\"``, ``\"%S\"``, ``\"%R\"`` added."
msgstr ""
"Stöd för bredd- och precisionsformatering för ``\"%s\"``, ``\"%A\"``, "
"``\"%U\"``, ``\"%V\"``, ``\"%S\"``, ``\"%R\"`` tillagt."

#: ../../c-api/unicode.rst:574
msgid ""
"Support for conversion specifiers ``o`` and ``X``. Support for length "
"modifiers ``j`` and ``t``. Length modifiers are now applied to all integer "
"conversions. Length modifier ``l`` is now applied to conversion specifiers "
"``s`` and ``V``. Support for variable width and precision ``*``. Support for "
"flag ``-``."
msgstr ""
"Stöd för konverteringsspecifikatorerna ``o`` och ``X``. Stöd för "
"längdmodifierare ``j`` och ``t``. Längdmodifierare tillämpas nu på alla "
"heltalskonverteringar. Längdmodifieraren ``l`` används nu för "
"konverteringsspecifikationerna ```` och ``V``. Stöd för variabel bredd och "
"precision ``*``. Stöd för flaggan ``-``."

#: ../../c-api/unicode.rst:582
msgid ""
"An unrecognized format character now sets a :exc:`SystemError`. In previous "
"versions it caused all the rest of the format string to be copied as-is to "
"the result string, and any extra arguments discarded."
msgstr ""
"Ett formattecken som inte känns igen ger nu upphov till ett :exc:"
"`SystemError`. I tidigare versioner ledde det till att resten av "
"formatsträngen kopierades som den var till resultatsträngen och att "
"eventuella extra argument ignorerades."

#: ../../c-api/unicode.rst:586
msgid "Support for ``%T``, ``%#T``, ``%N`` and ``%#N`` formats added."
msgstr "Stöd för formaten ``%T``, ``%#T``, ``%N`` och ``%#N`` har lagts till."

#: ../../c-api/unicode.rst:592
msgid ""
"Identical to :c:func:`PyUnicode_FromFormat` except that it takes exactly two "
"arguments."
msgstr ""
"Identisk med :c:func:`PyUnicode_FromFormat` förutom att den tar exakt två "
"argument."

#: ../../c-api/unicode.rst:598
msgid ""
"Copy an instance of a Unicode subtype to a new true Unicode object if "
"necessary. If *obj* is already a true Unicode object (not a subtype), return "
"a new :term:`strong reference` to the object."
msgstr ""
"Kopiera en instans av en Unicode-subtyp till ett nytt äkta Unicode-objekt om "
"det behövs. Om *obj* redan är ett äkta Unicode-objekt (inte en subtyp), "
"returneras en ny :term:`strong-referens` till objektet."

#: ../../c-api/unicode.rst:602
msgid ""
"Objects other than Unicode or its subtypes will cause a :exc:`TypeError`."
msgstr ""
"Andra objekt än Unicode eller dess subtyper kommer att orsaka ett :exc:"
"`TypeError`."

#: ../../c-api/unicode.rst:607
msgid "Create a Unicode Object from the given Unicode code point *ordinal*."
msgstr ""
"Skapa ett Unicode-objekt från den angivna Unicode-kodpunkten *ordinal*."

#: ../../c-api/unicode.rst:609
msgid ""
"The ordinal must be in ``range(0x110000)``. A :exc:`ValueError` is raised in "
"the case it is not."
msgstr ""
"Ordinalen måste ligga inom ``range(0x110000)``. Om så inte är fallet uppstår "
"ett :exc:`ValueError`."

#: ../../c-api/unicode.rst:616
msgid "Decode an encoded object *obj* to a Unicode object."
msgstr "Avkodar ett kodat objekt *obj* till ett Unicode-objekt."

#: ../../c-api/unicode.rst:618
msgid ""
":class:`bytes`, :class:`bytearray` and other :term:`bytes-like objects "
"<bytes-like object>` are decoded according to the given *encoding* and using "
"the error handling defined by *errors*. Both can be ``NULL`` to have the "
"interface use the default values (see :ref:`builtincodecs` for details)."
msgstr ""
":class:`bytes`, :class:`bytearray` och andra :term:`bytesliknande objekt "
"<bytes-like object>` avkodas enligt den givna *kodningen* och med den "
"felhantering som definieras av *errors*. Båda kan vara ``NULL`` för att "
"gränssnittet ska använda standardvärdena (se :ref:`builtincodecs` för "
"detaljer)."

#: ../../c-api/unicode.rst:624
msgid ""
"All other objects, including Unicode objects, cause a :exc:`TypeError` to be "
"set."
msgstr ""
"Alla andra objekt, inklusive Unicode-objekt, orsakar att en :exc:`TypeError` "
"sätts."

#: ../../c-api/unicode.rst:627
msgid ""
"The API returns ``NULL`` if there was an error.  The caller is responsible "
"for decref'ing the returned objects."
msgstr ""
"API:et returnerar ``NULL`` om det uppstod ett fel.  Den som anropar är "
"ansvarig för att decref'a de returnerade objekten."

#: ../../c-api/unicode.rst:633
msgid ""
"Append the string *right* to the end of *p_left*. *p_left* must point to a :"
"term:`strong reference` to a Unicode object; :c:func:`!PyUnicode_Append` "
"releases (\"steals\") this reference."
msgstr ""
"Lägger till strängen *right* i slutet av *p_left*. *p_left* måste peka på "
"en :term:`strong referens` till ett Unicode-objekt; :c:func:`!"
"PyUnicode_Append` frigör (\"stjäl\") denna referens."

#: ../../c-api/unicode.rst:637
msgid "On error, set *\\*p_left* to ``NULL`` and set an exception."
msgstr "Vid fel, sätt *\\*p_left* till ``NULL`` och sätt ett undantag."

#: ../../c-api/unicode.rst:639
msgid "On success, set *\\*p_left* to a new strong reference to the result."
msgstr ""
"Vid framgång, sätt *\\*p_left* till en ny stark referens till resultatet."

#: ../../c-api/unicode.rst:644
msgid ""
"The function is similar to :c:func:`PyUnicode_Append`, with the only "
"difference being that it decrements the reference count of *right* by one."
msgstr ""
"Funktionen liknar :c:func:`PyUnicode_Append`, med den enda skillnaden att "
"den minskar referensantalet för *right* med ett."

#: ../../c-api/unicode.rst:650
msgid ""
"Return a mapping suitable for decoding a custom single-byte encoding. Given "
"a Unicode string *string* of up to 256 characters representing an encoding "
"table, returns either a compact internal mapping object or a dictionary "
"mapping character ordinals to byte values. Raises a :exc:`TypeError` and "
"return ``NULL`` on invalid input."
msgstr ""
"Returnerar en mappning som är lämplig för avkodning av en anpassad single-"
"byte-kodning. Givet en Unicode-sträng *sträng* med upp till 256 tecken som "
"representerar en kodningstabell, returnerar antingen ett kompakt internt "
"mappningsobjekt eller en ordbok som mappar teckenordinaler till bytevärden. "
"Utlöser ett :exc:`TypeError` och returnerar ``NULL`` vid ogiltig indata."

#: ../../c-api/unicode.rst:661
msgid ""
"Return the name of the default string encoding, ``\"utf-8\"``. See :func:"
"`sys.getdefaultencoding`."
msgstr ""
"Returnerar namnet på standardkodningen för strängar, ``\"utf-8\"``. Se :func:"
"`sys.getdefaultencoding`."

#: ../../c-api/unicode.rst:664
msgid ""
"The returned string does not need to be freed, and is valid until "
"interpreter shutdown."
msgstr ""
"Den returnerade strängen behöver inte frigöras och är giltig tills tolken "
"stängs av."

#: ../../c-api/unicode.rst:670
msgid "Return the length of the Unicode object, in code points."
msgstr "Returnerar längden på Unicode-objektet i kodpunkter."

#: ../../c-api/unicode.rst:672
msgid "On error, set an exception and return ``-1``."
msgstr "Vid fel, sätt ett undantag och returnera ``-1``."

#: ../../c-api/unicode.rst:683
msgid ""
"Copy characters from one Unicode object into another.  This function "
"performs character conversion when necessary and falls back to :c:func:`!"
"memcpy` if possible.  Returns ``-1`` and sets an exception on error, "
"otherwise returns the number of copied characters."
msgstr ""
"Kopierar tecken från ett Unicode-objekt till ett annat.  Denna funktion "
"utför teckenkonvertering när det är nödvändigt och faller tillbaka till :c:"
"func:`!memcpy` om möjligt.  Returnerar ``-1`` och sätter ett undantag vid "
"fel, annars returneras antalet kopierade tecken."

#: ../../c-api/unicode.rst:688 ../../c-api/unicode.rst:718
#: ../../c-api/unicode.rst:738
msgid ""
"The string must not have been “used” yet. See :c:func:`PyUnicode_New` for "
"details."
msgstr ""
"Strängen får inte ha \"använts\" ännu. Se :c:func:`PyUnicode_New` för "
"detaljer."

#: ../../c-api/unicode.rst:696
msgid ""
"Resize a Unicode object *\\*unicode* to the new *length* in code points."
msgstr ""
"Ändra storlek på ett Unicode-objekt *\\*unicode* till den nya *längden* i "
"kodpunkter."

#: ../../c-api/unicode.rst:698
msgid ""
"Try to resize the string in place (which is usually faster than allocating a "
"new string and copying characters), or create a new string."
msgstr ""
"Försök att ändra storlek på strängen på plats (vilket vanligtvis är snabbare "
"än att allokera en ny sträng och kopiera tecken), eller skapa en ny sträng."

#: ../../c-api/unicode.rst:701
msgid ""
"*\\*unicode* is modified to point to the new (resized) object and ``0`` is "
"returned on success. Otherwise, ``-1`` is returned and an exception is set, "
"and *\\*unicode* is left untouched."
msgstr ""
"*\\*unicode* modifieras så att det pekar på det nya (storleksändrade) "
"objektet och ``0`` returneras vid framgång. Annars returneras ``-1`` och ett "
"undantag sätts, och *\\*unicode* lämnas orörd."

#: ../../c-api/unicode.rst:705
msgid ""
"The function doesn't check string content, the result may not be a string in "
"canonical representation."
msgstr ""
"Funktionen kontrollerar inte stränginnehållet, så resultatet kanske inte är "
"en sträng i kanonisk representation."

#: ../../c-api/unicode.rst:712
msgid ""
"Fill a string with a character: write *fill_char* into ``unicode[start:"
"start+length]``."
msgstr ""
"Fyll en sträng med ett tecken: skriv *fill_char* till ``unicode[start:"
"start+längd]``."

#: ../../c-api/unicode.rst:715
msgid ""
"Fail if *fill_char* is bigger than the string maximum character, or if the "
"string has more than 1 reference."
msgstr ""
"Misslyckas om *fill_char* är större än strängens maximala tecken, eller om "
"strängen har mer än 1 referens."

#: ../../c-api/unicode.rst:721
msgid ""
"Return the number of written character, or return ``-1`` and raise an "
"exception on error."
msgstr ""
"Returnera antalet skrivna tecken, eller returnera ``-1`` och skapa ett "
"undantag vid fel."

#: ../../c-api/unicode.rst:730
msgid ""
"Write a *character* to the string *unicode* at the zero-based *index*. "
"Return ``0`` on success, ``-1`` on error with an exception set."
msgstr ""
"Skriv ett *tecken* till strängen *unicode* vid det nollbaserade *indexet*. "
"Returnerar ``0`` vid framgång, ``-1`` vid fel med en undantagsuppsättning."

#: ../../c-api/unicode.rst:733
msgid ""
"This function checks that *unicode* is a Unicode object, that the index is "
"not out of bounds, and that the object's reference count is one. See :c:func:"
"`PyUnicode_WRITE` for a version that skips these checks, making them your "
"responsibility."
msgstr ""

#: ../../c-api/unicode.rst:746
msgid ""
"Read a character from a string.  This function checks that *unicode* is a "
"Unicode object and the index is not out of bounds, in contrast to :c:func:"
"`PyUnicode_READ_CHAR`, which performs no error checking."
msgstr ""
"Läser ett tecken från en sträng.  Denna funktion kontrollerar att *unicode* "
"är ett Unicode-objekt och att index inte är utanför gränserna, till skillnad "
"från :c:func:`PyUnicode_READ_CHAR`, som inte utför någon felkontroll."

#: ../../c-api/unicode.rst:750
msgid "Return character on success, ``-1`` on error with an exception set."
msgstr ""
"Returnerar tecken vid framgång, ``-1`` vid fel med en undantagsuppsättning."

#: ../../c-api/unicode.rst:758
msgid ""
"Return a substring of *unicode*, from character index *start* (included) to "
"character index *end* (excluded).  Negative indices are not supported. On "
"error, set an exception and return ``NULL``."
msgstr ""
"Returnerar en delsträng av *unicode*, från teckenindex *start* (inkluderat) "
"till teckenindex *end* (exkluderat).  Negativa index stöds inte. Vid fel, "
"sätt ett undantag och returnera ``NULL``."

#: ../../c-api/unicode.rst:768
msgid ""
"Copy the string *unicode* into a UCS4 buffer, including a null character, if "
"*copy_null* is set.  Returns ``NULL`` and sets an exception on error (in "
"particular, a :exc:`SystemError` if *buflen* is smaller than the length of "
"*unicode*).  *buffer* is returned on success."
msgstr ""
"Kopierar strängen *unicode* till en UCS4-buffert, inklusive ett null-tecken, "
"om *copy_null* är inställt.  Returnerar ``NULL`` och anger ett undantag vid "
"fel (i synnerhet ett :exc:`SystemError` om *buflen* är mindre än längden på "
"*unicode*).  *buffer* returneras vid framgång."

#: ../../c-api/unicode.rst:778
msgid ""
"Copy the string *unicode* into a new UCS4 buffer that is allocated using :c:"
"func:`PyMem_Malloc`.  If this fails, ``NULL`` is returned with a :exc:"
"`MemoryError` set.  The returned buffer always has an extra null code point "
"appended."
msgstr ""
"Kopierar strängen *unicode* till en ny UCS4-buffert som allokeras med :c:"
"func:`PyMem_Malloc`.  Om detta misslyckas returneras ``NULL`` med :exc:"
"`MemoryError` inställt.  Den returnerade bufferten har alltid en extra null-"
"kodpunkt tillagd."

#: ../../c-api/unicode.rst:787
msgid "Locale Encoding"
msgstr "Kodning av lokala språk"

#: ../../c-api/unicode.rst:789
msgid ""
"The current locale encoding can be used to decode text from the operating "
"system."
msgstr ""
"Den aktuella locale-kodningen kan användas för att avkoda text från "
"operativsystemet."

#: ../../c-api/unicode.rst:796
msgid ""
"Decode a string from UTF-8 on Android and VxWorks, or from the current "
"locale encoding on other platforms. The supported error handlers are "
"``\"strict\"`` and ``\"surrogateescape\"`` (:pep:`383`). The decoder uses "
"``\"strict\"`` error handler if *errors* is ``NULL``.  *str* must end with a "
"null character but cannot contain embedded null characters."
msgstr ""
"Avkodar en sträng från UTF-8 på Android och VxWorks, eller från den aktuella "
"lokala kodningen på andra plattformar. De felhanterare som stöds är "
"``\"strict\"`` och ``\"surrogateescape\"`` (:pep:`383`). Avkodaren använder "
"felhanteraren ``\"strict\"`` om *errors* är ``NULL``.  *str* måste sluta med "
"ett nolltecken men kan inte innehålla inbäddade nolltecken."

#: ../../c-api/unicode.rst:803
msgid ""
"Use :c:func:`PyUnicode_DecodeFSDefaultAndSize` to decode a string from the :"
"term:`filesystem encoding and error handler`."
msgstr ""
"Använd :c:func:`PyUnicode_DecodeFSDefaultAndSize` för att avkoda en sträng "
"från :term:`filsystemets kodning och felhantering`."

#: ../../c-api/unicode.rst:806 ../../c-api/unicode.rst:841
msgid "This function ignores the :ref:`Python UTF-8 Mode <utf8-mode>`."
msgstr "Denna funktion ignorerar :ref:`Python UTF-8 Mode <utf8-mode>`."

#: ../../c-api/unicode.rst:810 ../../c-api/unicode.rst:926
msgid "The :c:func:`Py_DecodeLocale` function."
msgstr "Funktionen :c:func:`Py_DecodeLocale`."

#: ../../c-api/unicode.rst:814
msgid ""
"The function now also uses the current locale encoding for the "
"``surrogateescape`` error handler, except on Android. Previously, :c:func:"
"`Py_DecodeLocale` was used for the ``surrogateescape``, and the current "
"locale encoding was used for ``strict``."
msgstr ""
"Funktionen använder nu även den aktuella lokalkodningen för felhanteraren "
"``surrogateescape``, utom på Android. Tidigare användes :c:func:"
"`Py_DecodeLocale` för ``urrogateescape``, och den aktuella lokalkodningen "
"användes för ``strict``."

#: ../../c-api/unicode.rst:823
msgid ""
"Similar to :c:func:`PyUnicode_DecodeLocaleAndSize`, but compute the string "
"length using :c:func:`!strlen`."
msgstr ""
"Liknar :c:func:`PyUnicode_DecodeLocaleAndSize`, men beräknar stränglängden "
"med hjälp av :c:func:`!strlen`."

#: ../../c-api/unicode.rst:831
msgid ""
"Encode a Unicode object to UTF-8 on Android and VxWorks, or to the current "
"locale encoding on other platforms. The supported error handlers are "
"``\"strict\"`` and ``\"surrogateescape\"`` (:pep:`383`). The encoder uses "
"``\"strict\"`` error handler if *errors* is ``NULL``. Return a :class:"
"`bytes` object. *unicode* cannot contain embedded null characters."
msgstr ""
"Kodar ett Unicode-objekt till UTF-8 på Android och VxWorks, eller till den "
"aktuella lokala kodningen på andra plattformar. De felhanterare som stöds är "
"``\"strict\"`` och ``\"surrogateescape\"`` (:pep:`383`). Kodaren använder "
"felhanteraren ``\"strict\"`` om *errors* är ``NULL``. Returnerar ett :class:"
"`bytes`-objekt. *unicode* kan inte innehålla inbäddade null-tecken."

#: ../../c-api/unicode.rst:838
msgid ""
"Use :c:func:`PyUnicode_EncodeFSDefault` to encode a string to the :term:"
"`filesystem encoding and error handler`."
msgstr ""
"Använd :c:func:`PyUnicode_EncodeFSDefault` för att koda en sträng till :term:"
"`filsystemets kodning och felhantering`."

#: ../../c-api/unicode.rst:845 ../../c-api/unicode.rst:957
msgid "The :c:func:`Py_EncodeLocale` function."
msgstr "Funktionen :c:func:`Py_EncodeLocale`."

#: ../../c-api/unicode.rst:849
msgid ""
"The function now also uses the current locale encoding for the "
"``surrogateescape`` error handler, except on Android. Previously, :c:func:"
"`Py_EncodeLocale` was used for the ``surrogateescape``, and the current "
"locale encoding was used for ``strict``."
msgstr ""
"Funktionen använder nu även den aktuella lokalkodningen för felhanteraren "
"``surrogateescape``, utom på Android. Tidigare användes :c:func:"
"`Py_EncodeLocale` för ``urrogateescape``, och den aktuella lokalkodningen "
"användes för ``strict``."

#: ../../c-api/unicode.rst:858
msgid "File System Encoding"
msgstr "Kodning av filsystem"

#: ../../c-api/unicode.rst:860
msgid ""
"Functions encoding to and decoding from the :term:`filesystem encoding and "
"error handler` (:pep:`383` and :pep:`529`)."
msgstr ""
"Funktioner för kodning till och avkodning från :term:`filsystemets kodning "
"och felhantering` (:pep:`383` och :pep:`529`)."

#: ../../c-api/unicode.rst:863
msgid ""
"To encode file names to :class:`bytes` during argument parsing, the "
"``\"O&\"`` converter should be used, passing :c:func:`!"
"PyUnicode_FSConverter` as the conversion function:"
msgstr ""
"För att koda filnamn till :class:`bytes` under argumentparsning, bör "
"``\"O&\"``-omvandlaren användas, med :c:func:`!PyUnicode_FSConverter` som "
"omvandlingsfunktion:"

#: ../../c-api/unicode.rst:869
msgid ""
":ref:`PyArg_Parse\\* converter <arg-parsing>`: encode :class:`str` objects "
"-- obtained directly or through the :class:`os.PathLike` interface -- to :"
"class:`bytes` using :c:func:`PyUnicode_EncodeFSDefault`; :class:`bytes` "
"objects are output as-is. *result* must be an address of a C variable of "
"type :c:expr:`PyObject*` (or :c:expr:`PyBytesObject*`). On success, set the "
"variable to a new :term:`strong reference` to a :ref:`bytes object "
"<bytesobjects>` which must be released when it is no longer used and return "
"a non-zero value (:c:macro:`Py_CLEANUP_SUPPORTED`). Embedded null bytes are "
"not allowed in the result. On failure, return ``0`` with an exception set."
msgstr ""
":ref:`PyArg_Parse\\* converter <arg-parsing>`: koda :class:`str`-objekt -- "
"erhållna direkt eller genom :class:`os.PathLike`-gränssnittet -- till :class:"
"`bytes` med :c:func:`PyUnicode_EncodeFSDefault`; :class:`bytes`-objekt matas "
"ut som de är. *result* måste vara en adress till en C-variabel av typen :c:"
"expr:`PyObject*` (eller :c:expr:`PyBytesObject*`). Vid framgång, sätt "
"variabeln till en ny :term:`strong reference` till ett :ref:`bytesobjekt "
"<bytesobjects>` som måste släppas när det inte längre används och returnera "
"ett värde som inte är noll (:c:macro:`Py_CLEANUP_SUPPORTED`). Inbäddade "
"nollbytes är inte tillåtna i resultatet. Vid misslyckande returneras ``0`` "
"med en undantagsuppsättning."

#: ../../c-api/unicode.rst:881
msgid ""
"If *obj* is ``NULL``, the function releases a strong reference stored in the "
"variable referred by *result* and returns ``1``."
msgstr ""
"Om *obj* är ``NULL`` frigör funktionen en stark referens som lagrats i den "
"variabel som refereras av *result* och returnerar ``1``."

#: ../../c-api/unicode.rst:886 ../../c-api/unicode.rst:913
msgid "Accepts a :term:`path-like object`."
msgstr "Accepterar en :term:`path-liknande objekt`."

#: ../../c-api/unicode.rst:889
msgid ""
"To decode file names to :class:`str` during argument parsing, the ``\"O&\"`` "
"converter should be used, passing :c:func:`!PyUnicode_FSDecoder` as the "
"conversion function:"
msgstr ""
"För att avkoda filnamn till :class:`str` under argumentparsning, bör "
"``\"O&\"``-omvandlaren användas, med :c:func:`!PyUnicode_FSDecoder` som "
"omvandlingsfunktion:"

#: ../../c-api/unicode.rst:895
msgid ""
":ref:`PyArg_Parse\\* converter <arg-parsing>`: decode :class:`bytes` objects "
"-- obtained either directly or indirectly through the :class:`os.PathLike` "
"interface -- to :class:`str` using :c:func:"
"`PyUnicode_DecodeFSDefaultAndSize`; :class:`str` objects are output as-is. "
"*result* must be an address of a C variable of type :c:expr:`PyObject*` (or :"
"c:expr:`PyUnicodeObject*`). On success, set the variable to a new :term:"
"`strong reference` to a :ref:`Unicode object <unicodeobjects>` which must be "
"released when it is no longer used and return a non-zero value (:c:macro:"
"`Py_CLEANUP_SUPPORTED`). Embedded null characters are not allowed in the "
"result. On failure, return ``0`` with an exception set."
msgstr ""
":ref:`PyArg_Parse\\* converter <arg-parsing>`: avkodar :class:`bytes`-objekt "
"-- erhållna antingen direkt eller indirekt genom :class:`os.PathLike`-"
"gränssnittet -- till :class:`str` med :c:func:"
"`PyUnicode_DecodeFSDefaultAndSize`; :class:`str`-objekt matas ut som de är. "
"*result* måste vara en adress till en C-variabel av typen :c:expr:"
"`PyObject*` (eller :c:expr:`PyUnicodeObject*`). Vid framgång, sätt variabeln "
"till en ny :term:`strong reference` till en :ref:`Unicode object "
"<unicodeobjects>` som måste släppas när den inte längre används och "
"returnera ett icke-noll värde (:c:macro:`Py_CLEANUP_SUPPORTED`). Inbäddade "
"nolltecken är inte tillåtna i resultatet. Vid misslyckande returneras ``0`` "
"med en undantagsuppsättning."

#: ../../c-api/unicode.rst:908
msgid ""
"If *obj* is ``NULL``, release the strong reference to the object referred to "
"by *result* and return ``1``."
msgstr ""
"Om *obj* är ``NULL``, släpp den starka referensen till det objekt som "
"*result* hänvisar till och returnera ``1``."

#: ../../c-api/unicode.rst:919
msgid "Decode a string from the :term:`filesystem encoding and error handler`."
msgstr "Avkodar en sträng från :term:`filsystemets kodning och felhantering`."

#: ../../c-api/unicode.rst:921
msgid ""
"If you need to decode a string from the current locale encoding, use :c:func:"
"`PyUnicode_DecodeLocaleAndSize`."
msgstr ""
"Om du behöver avkoda en sträng från den aktuella lokala kodningen, använd :c:"
"func:`PyUnicode_DecodeLocaleAndSize`."

#: ../../c-api/unicode.rst:928 ../../c-api/unicode.rst:941
#: ../../c-api/unicode.rst:961
msgid ""
"The :term:`filesystem error handler <filesystem encoding and error handler>` "
"is now used."
msgstr ""
"Nu används :term:`filsystem error handler <filesystem encoding and error "
"handler>`."

#: ../../c-api/unicode.rst:935
msgid ""
"Decode a null-terminated string from the :term:`filesystem encoding and "
"error handler`."
msgstr ""
"Avkoda en nollavslutad sträng från :term:`filsystemets kodning och "
"felhantering`."

#: ../../c-api/unicode.rst:938
msgid ""
"If the string length is known, use :c:func:"
"`PyUnicode_DecodeFSDefaultAndSize`."
msgstr ""
"Om stränglängden är känd, använd :c:func:`PyUnicode_DecodeFSDefaultAndSize`."

#: ../../c-api/unicode.rst:948
msgid ""
"Encode a Unicode object to the :term:`filesystem encoding and error "
"handler`, and return :class:`bytes`. Note that the resulting :class:`bytes` "
"object can contain null bytes."
msgstr ""
"Kodar ett Unicode-objekt till :term:`filsystemets kodning och felhantering`, "
"och returnerar :class:`bytes`. Observera att det resulterande :class:`bytes`-"
"objektet kan innehålla nollbytes."

#: ../../c-api/unicode.rst:952
msgid ""
"If you need to encode a string to the current locale encoding, use :c:func:"
"`PyUnicode_EncodeLocale`."
msgstr ""
"Om du behöver koda en sträng till den aktuella locale-kodningen, använd :c:"
"func:`PyUnicode_EncodeLocale`."

#: ../../c-api/unicode.rst:966
msgid "wchar_t Support"
msgstr "wchar_t Stöd"

#: ../../c-api/unicode.rst:968
msgid ":c:type:`wchar_t` support for platforms which support it:"
msgstr ":c:type:`wchar_t` stöd för plattformar som stödjer det:"

#: ../../c-api/unicode.rst:972
msgid ""
"Create a Unicode object from the :c:type:`wchar_t` buffer *wstr* of the "
"given *size*. Passing ``-1`` as the *size* indicates that the function must "
"itself compute the length, using :c:func:`!wcslen`. Return ``NULL`` on "
"failure."
msgstr ""
"Skapar ett Unicode-objekt från :c:type:`wchar_t`-bufferten *wstr* med den "
"angivna *storleken*. Om du anger ``-1`` som *storlek* indikerar det att "
"funktionen själv måste beräkna längden med hjälp av :c:func:`!wcslen`. "
"Returnerar ``NULL`` om den misslyckas."

#: ../../c-api/unicode.rst:980
msgid ""
"Copy the Unicode object contents into the :c:type:`wchar_t` buffer *wstr*.  "
"At most *size* :c:type:`wchar_t` characters are copied (excluding a possibly "
"trailing null termination character).  Return the number of :c:type:"
"`wchar_t` characters copied or ``-1`` in case of an error."
msgstr ""
"Kopiera Unicode-objektets innehåll till :c:type:`wchar_t`-bufferten *wstr*.  "
"Högst *storlek* :c:type:`wchar_t`-tecken kopieras (exklusive ett eventuellt "
"avslutande null-tecken).  Returnerar antalet :c:type:`wchar_t`-tecken som "
"kopierats eller ``-1`` i händelse av ett fel."

#: ../../c-api/unicode.rst:985
msgid ""
"When *wstr* is ``NULL``, instead return the *size* that would be required to "
"store all of *unicode* including a terminating null."
msgstr ""
"När *wstr* är ``NULL``, returneras istället den *storlek* som skulle krävas "
"för att lagra hela *unicode* inklusive en avslutande null."

#: ../../c-api/unicode.rst:988
msgid ""
"Note that the resulting :c:expr:`wchar_t*` string may or may not be null-"
"terminated.  It is the responsibility of the caller to make sure that the :c:"
"expr:`wchar_t*` string is null-terminated in case this is required by the "
"application. Also, note that the :c:expr:`wchar_t*` string might contain "
"null characters, which would cause the string to be truncated when used with "
"most C functions."
msgstr ""
"Observera att den resulterande :c:expr:`wchar_t*`-strängen kan vara eller "
"inte vara nollterminerad.  Det är anroparens ansvar att se till att :c:expr:"
"`wchar_t*`-strängen är nollterminerad om detta krävs av programmet. "
"Observera också att strängen :c:expr:`wchar_t*` kan innehålla nolltecken, "
"vilket gör att strängen blir avkortad när den används med de flesta C-"
"funktioner."

#: ../../c-api/unicode.rst:998
msgid ""
"Convert the Unicode object to a wide character string. The output string "
"always ends with a null character. If *size* is not ``NULL``, write the "
"number of wide characters (excluding the trailing null termination "
"character) into *\\*size*. Note that the resulting :c:type:`wchar_t` string "
"might contain null characters, which would cause the string to be truncated "
"when used with most C functions. If *size* is ``NULL`` and the :c:expr:"
"`wchar_t*` string contains null characters a :exc:`ValueError` is raised."
msgstr ""
"Konverterar Unicode-objektet till en bred teckensträng. Utdatasträngen "
"slutar alltid med ett null-tecken. Om *size* inte är ``NULL``, skriv antalet "
"breda tecken (exklusive det avslutande nulltecknet) till *\\*size*. "
"Observera att den resulterande :c:type:`wchar_t`-strängen kan innehålla "
"nolltecken, vilket gör att strängen blir avkortad när den används med de "
"flesta C-funktioner. Om *size* är ``NULL`` och strängen :c:expr:`wchar_t*` "
"innehåller nolltecken, uppstår ett :exc:`ValueError`."

#: ../../c-api/unicode.rst:1006
msgid ""
"Returns a buffer allocated by :c:macro:`PyMem_New` (use :c:func:`PyMem_Free` "
"to free it) on success. On error, returns ``NULL`` and *\\*size* is "
"undefined. Raises a :exc:`MemoryError` if memory allocation is failed."
msgstr ""
"Returnerar en buffert som allokerats av :c:macro:`PyMem_New` (använd :c:func:"
"`PyMem_Free` för att frigöra den) vid framgång. Vid fel returneras ``NULL`` "
"och *\\*size* är odefinierad. Skapar ett :exc:`MemoryError` om "
"minnesallokeringen misslyckades."

#: ../../c-api/unicode.rst:1013
msgid ""
"Raises a :exc:`ValueError` if *size* is ``NULL`` and the :c:expr:`wchar_t*` "
"string contains null characters."
msgstr ""
"Utlöser ett :exc:`ValueError` om *size* är ``NULL`` och strängen :c:expr:"
"`wchar_t*` innehåller null-tecken."

#: ../../c-api/unicode.rst:1021
msgid "Built-in Codecs"
msgstr "Inbyggda codecs"

#: ../../c-api/unicode.rst:1023
msgid ""
"Python provides a set of built-in codecs which are written in C for speed. "
"All of these codecs are directly usable via the following functions."
msgstr ""
"Python tillhandahåller en uppsättning inbyggda codecs som är skrivna i C för "
"snabbhetens skull. Alla dessa codecs är direkt användbara via följande "
"funktioner."

#: ../../c-api/unicode.rst:1026
msgid ""
"Many of the following APIs take two arguments encoding and errors, and they "
"have the same semantics as the ones of the built-in :func:`str` string "
"object constructor."
msgstr ""
"Många av följande API:er tar två argument, encoding och errors, och de har "
"samma semantik som den inbyggda :func:`str`-konstruktören för strängobjekt."

#: ../../c-api/unicode.rst:1030
msgid ""
"Setting encoding to ``NULL`` causes the default encoding to be used which is "
"UTF-8.  The file system calls should use :c:func:`PyUnicode_FSConverter` for "
"encoding file names. This uses the :term:`filesystem encoding and error "
"handler` internally."
msgstr ""
"Om encoding sätts till ``NULL`` används standardkodningen UTF-8.  "
"Filsystemets anrop bör använda :c:func:`PyUnicode_FSConverter` för kodning "
"av filnamn. Detta använder :term:`filsystemets kodning och felhantering` "
"internt."

#: ../../c-api/unicode.rst:1035
msgid ""
"Error handling is set by errors which may also be set to ``NULL`` meaning to "
"use the default handling defined for the codec.  Default error handling for "
"all built-in codecs is \"strict\" (:exc:`ValueError` is raised)."
msgstr ""
"Felhantering anges av errors som också kan anges till ``NULL`` vilket "
"innebär att standardhanteringen som definierats för codec används.  "
"Standardfelhanteringen för alla inbyggda codecs är \"strict\" (:exc:"
"`ValueError` aktiveras)."

#: ../../c-api/unicode.rst:1039
msgid ""
"The codecs all use a similar interface.  Only deviations from the following "
"generic ones are documented for simplicity."
msgstr ""
"Codecs använder alla ett liknande gränssnitt.  För enkelhetens skull "
"dokumenteras endast avvikelser från följande generiska gränssnitt."

#: ../../c-api/unicode.rst:1044
msgid "Generic Codecs"
msgstr "Generiska codecs"

#: ../../c-api/unicode.rst:1046
msgid "The following macro is provided:"
msgstr "Följande makro tillhandahålls:"

#: ../../c-api/unicode.rst:1051
msgid "The Unicode code point ``U+FFFD`` (replacement character)."
msgstr "Unicode-kodpunkten ``U+FFFD`` (ersättningstecken)."

#: ../../c-api/unicode.rst:1053
msgid ""
"This Unicode character is used as the replacement character during decoding "
"if the *errors* argument is set to \"replace\"."
msgstr ""
"Detta Unicode-tecken används som ersättningstecken vid avkodning om *errors*-"
"argumentet är inställt på \"replace\"."

#: ../../c-api/unicode.rst:1057
msgid "These are the generic codec APIs:"
msgstr "Dessa är de generiska codec-API:erna:"

#: ../../c-api/unicode.rst:1063
msgid ""
"Create a Unicode object by decoding *size* bytes of the encoded string "
"*str*. *encoding* and *errors* have the same meaning as the parameters of "
"the same name in the :func:`str` built-in function.  The codec to be used is "
"looked up using the Python codec registry.  Return ``NULL`` if an exception "
"was raised by the codec."
msgstr ""
"Skapa ett Unicode-objekt genom att avkoda *size* bytes av den kodade "
"strängen *str*. *encoding* och *errors* har samma betydelse som parametrarna "
"med samma namn i den inbyggda funktionen :func:`str`.  Den codec som ska "
"användas söks upp med hjälp av Pythons codec-register.  Returnera ``NULL`` "
"om ett undantag uppstod av codec."

#: ../../c-api/unicode.rst:1073
msgid ""
"Encode a Unicode object and return the result as Python bytes object. "
"*encoding* and *errors* have the same meaning as the parameters of the same "
"name in the Unicode :meth:`~str.encode` method. The codec to be used is "
"looked up using the Python codec registry. Return ``NULL`` if an exception "
"was raised by the codec."
msgstr ""
"Kodar ett Unicode-objekt och returnerar resultatet som ett Python bytes-"
"objekt. *encoding* och *errors* har samma betydelse som parametrarna med "
"samma namn i Unicode :meth:`~str.encode`-metoden. Den codec som ska användas "
"söks upp med hjälp av Pythons codec-register. Returnera ``NULL`` om ett "
"undantag uppstod av codec."

#: ../../c-api/unicode.rst:1081
msgid "UTF-8 Codecs"
msgstr "UTF-8-codecs"

#: ../../c-api/unicode.rst:1083
msgid "These are the UTF-8 codec APIs:"
msgstr "Dessa är UTF-8 codec API:er:"

#: ../../c-api/unicode.rst:1088
msgid ""
"Create a Unicode object by decoding *size* bytes of the UTF-8 encoded string "
"*str*. Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"Skapa ett Unicode-objekt genom att avkoda *size* bytes av den UTF-8-kodade "
"strängen *str*. Returnerar ``NULL`` om ett undantag har uppstått i codec."

#: ../../c-api/unicode.rst:1095
msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeUTF8`. If "
"*consumed* is not ``NULL``, trailing incomplete UTF-8 byte sequences will "
"not be treated as an error. Those bytes will not be decoded and the number "
"of bytes that have been decoded will be stored in *consumed*."
msgstr ""
"Om *consumed* är ``NULL``, uppför sig som :c:func:`PyUnicode_DecodeUTF8`. Om "
"*consumed* inte är ``NULL``, kommer efterföljande ofullständiga UTF-8 byte-"
"sekvenser inte att behandlas som ett fel. Dessa byte kommer inte att avkodas "
"och antalet byte som har avkodats kommer att lagras i *consumed*."

#: ../../c-api/unicode.rst:1103
msgid ""
"Encode a Unicode object using UTF-8 and return the result as Python bytes "
"object.  Error handling is \"strict\".  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""
"Kodar ett Unicode-objekt med UTF-8 och returnerar resultatet som Python "
"bytes-objekt.  Felhanteringen är \"strikt\".  Returnera ``NULL`` om ett "
"undantag uppstod av codec."

#: ../../c-api/unicode.rst:1107 ../../c-api/unicode.rst:1122
msgid ""
"The function fails if the string contains surrogate code points (``U+D800`` "
"- ``U+DFFF``)."
msgstr ""
"Funktionen misslyckas om strängen innehåller surrogatkodpunkter (``U+D800`` "
"- ``U+DFFF``)."

#: ../../c-api/unicode.rst:1113
msgid ""
"Return a pointer to the UTF-8 encoding of the Unicode object, and store the "
"size of the encoded representation (in bytes) in *size*.  The *size* "
"argument can be ``NULL``; in this case no size will be stored.  The returned "
"buffer always has an extra null byte appended (not included in *size*), "
"regardless of whether there are any other null code points."
msgstr ""
"Returnerar en pekare till UTF-8-kodningen av Unicode-objektet och lagrar "
"storleken på den kodade representationen (i byte) i *size*.  Argumentet "
"*size* kan vara ``NULL``; i så fall lagras ingen storlek.  Den returnerade "
"bufferten har alltid en extra null-byte tillagd (ingår inte i *size*), "
"oavsett om det finns några andra null-kodpunkter."

#: ../../c-api/unicode.rst:1119
msgid ""
"On error, set an exception, set *size* to ``-1`` (if it's not NULL) and "
"return ``NULL``."
msgstr ""
"Vid fel, sätt ett undantag, sätt *size* till ``-1`` (om det inte är NULL) "
"och returnera ``NULL``."

#: ../../c-api/unicode.rst:1125
msgid ""
"This caches the UTF-8 representation of the string in the Unicode object, "
"and subsequent calls will return a pointer to the same buffer.  The caller "
"is not responsible for deallocating the buffer. The buffer is deallocated "
"and pointers to it become invalid when the Unicode object is garbage "
"collected."
msgstr ""
"Detta cachelagrar UTF-8-representationen av strängen i Unicode-objektet, och "
"efterföljande anrop returnerar en pekare till samma buffert.  Den som "
"anropar är inte ansvarig för att deallokera bufferten. Bufferten deallokeras "
"och pekare till den blir ogiltiga när Unicode-objektet garbage collectas."

#: ../../c-api/unicode.rst:1132 ../../c-api/unicode.rst:1154
msgid "The return type is now ``const char *`` rather of ``char *``."
msgstr "Returtypen är nu ``const char *`` i stället för ``char *``."

#: ../../c-api/unicode.rst:1135
msgid "This function is a part of the :ref:`limited API <limited-c-api>`."
msgstr "Denna funktion är en del av :ref:``limited API <limited-c-api>`."

#: ../../c-api/unicode.rst:1141
msgid "As :c:func:`PyUnicode_AsUTF8AndSize`, but does not store the size."
msgstr "Som :c:func:`PyUnicode_AsUTF8AndSize`, men lagrar inte storleken."

#: ../../c-api/unicode.rst:1145
msgid ""
"This function does not have any special behavior for `null characters "
"<https://en.wikipedia.org/wiki/Null_character>`_ embedded within *unicode*. "
"As a result, strings containing null characters will remain in the returned "
"string, which some C functions might interpret as the end of the string, "
"leading to truncation. If truncation is an issue, it is recommended to use :"
"c:func:`PyUnicode_AsUTF8AndSize` instead."
msgstr ""
"Denna funktion har inget speciellt beteende för `nulltecken <https://en."
"wikipedia.org/wiki/Null_character>`_ som är inbäddade i *unicode*. Därför "
"kommer strängar som innehåller nolltecken att finnas kvar i den returnerade "
"strängen, vilket vissa C-funktioner kan tolka som slutet på strängen, vilket "
"leder till trunkering. Om trunkering är ett problem rekommenderas det att "
"använda :c:func:`PyUnicode_AsUTF8AndSize` istället."

#: ../../c-api/unicode.rst:1159
msgid "UTF-32 Codecs"
msgstr "UTF-32 Codecs"

#: ../../c-api/unicode.rst:1161
msgid "These are the UTF-32 codec APIs:"
msgstr "Dessa är UTF-32 codec API:er:"

#: ../../c-api/unicode.rst:1167
msgid ""
"Decode *size* bytes from a UTF-32 encoded buffer string and return the "
"corresponding Unicode object.  *errors* (if non-``NULL``) defines the error "
"handling. It defaults to \"strict\"."
msgstr ""
"Avkodar *size* byte från en UTF-32-kodad buffertsträng och returnerar "
"motsvarande Unicode-objekt.  *errors* (om inte ``NULL``) definierar "
"felhanteringen. Standardvärdet är \"strict\"."

#: ../../c-api/unicode.rst:1171 ../../c-api/unicode.rst:1221
msgid ""
"If *byteorder* is non-``NULL``, the decoder starts decoding using the given "
"byte order::"
msgstr ""
"Om *byteorder* inte är ``NULL``, börjar avkodaren avkodningen med den "
"angivna byteordningen::"

#: ../../c-api/unicode.rst:1174 ../../c-api/unicode.rst:1224
msgid ""
"*byteorder == -1: little endian\n"
"*byteorder == 0:  native order\n"
"*byteorder == 1:  big endian"
msgstr ""
"*byteorder == -1: liten endian\n"
"*byteorder == 0: inbyggd ordning\n"
"*byteorder == 1: stor endian"

#: ../../c-api/unicode.rst:1178
msgid ""
"If ``*byteorder`` is zero, and the first four bytes of the input data are a "
"byte order mark (BOM), the decoder switches to this byte order and the BOM "
"is not copied into the resulting Unicode string.  If ``*byteorder`` is "
"``-1`` or ``1``, any byte order mark is copied to the output."
msgstr ""
"Om ``*byteorder`` är noll och de fyra första bytena i indata är en "
"byteordermarkering (BOM), växlar avkodaren till denna byteordning och BOM "
"kopieras inte till den resulterande Unicode-strängen.  Om ``*byteorder`` är "
"``-1`` eller ``1`` kopieras alla byteordermarkeringar till utdata."

#: ../../c-api/unicode.rst:1183
msgid ""
"After completion, *\\*byteorder* is set to the current byte order at the end "
"of input data."
msgstr ""
"Efter slutförandet ställs *\\*byteorder* in på den aktuella byteordningen i "
"slutet av indata."

#: ../../c-api/unicode.rst:1186 ../../c-api/unicode.rst:1237
msgid "If *byteorder* is ``NULL``, the codec starts in native order mode."
msgstr "Om *byteorder* är ``NULL`` startar codec i native order-läge."

#: ../../c-api/unicode.rst:1188 ../../c-api/unicode.rst:1239
msgid "Return ``NULL`` if an exception was raised by the codec."
msgstr "Returnerar ``NULL`` om ett undantag har uppstått i codec."

#: ../../c-api/unicode.rst:1194
msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeUTF32`. If "
"*consumed* is not ``NULL``, :c:func:`PyUnicode_DecodeUTF32Stateful` will not "
"treat trailing incomplete UTF-32 byte sequences (such as a number of bytes "
"not divisible by four) as an error. Those bytes will not be decoded and the "
"number of bytes that have been decoded will be stored in *consumed*."
msgstr ""
"Om *consumed* är ``NULL``, uppför sig som :c:func:`PyUnicode_DecodeUTF32`. "
"Om *consumed* inte är ``NULL`` kommer :c:func:"
"`PyUnicode_DecodeUTF32Stateful`` inte att behandla efterföljande "
"ofullständiga UTF-32 byte-sekvenser (t.ex. ett antal byte som inte är "
"delbart med fyra) som ett fel. Dessa byte kommer inte att avkodas och "
"antalet byte som har avkodats kommer att lagras i *consumed*."

#: ../../c-api/unicode.rst:1203
msgid ""
"Return a Python byte string using the UTF-32 encoding in native byte order. "
"The string always starts with a BOM mark.  Error handling is \"strict\". "
"Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"Returnerar en Python-bytesträng med UTF-32-kodning i inbyggd byteordning. "
"Strängen börjar alltid med en BOM-markering.  Felhanteringen är \"strikt\". "
"Returnera ``NULL`` om ett undantag har uppstått i codec."

#: ../../c-api/unicode.rst:1209
msgid "UTF-16 Codecs"
msgstr "UTF-16 Codecs"

#: ../../c-api/unicode.rst:1211
msgid "These are the UTF-16 codec APIs:"
msgstr "Dessa är UTF-16 codec API:er:"

#: ../../c-api/unicode.rst:1217
msgid ""
"Decode *size* bytes from a UTF-16 encoded buffer string and return the "
"corresponding Unicode object.  *errors* (if non-``NULL``) defines the error "
"handling. It defaults to \"strict\"."
msgstr ""
"Avkodar *size* byte från en UTF-16-kodad buffertsträng och returnerar "
"motsvarande Unicode-objekt.  *errors* (om inte ``NULL``) definierar "
"felhanteringen. Standardvärdet är \"strict\"."

#: ../../c-api/unicode.rst:1228
msgid ""
"If ``*byteorder`` is zero, and the first two bytes of the input data are a "
"byte order mark (BOM), the decoder switches to this byte order and the BOM "
"is not copied into the resulting Unicode string.  If ``*byteorder`` is "
"``-1`` or ``1``, any byte order mark is copied to the output (where it will "
"result in either a ``\\ufeff`` or a ``\\ufffe`` character)."
msgstr ""
"Om ``*byteorder`` är noll och de två första bytena i indata är en "
"byteordermarkering (BOM), växlar avkodaren till denna byteordning och BOM "
"kopieras inte till den resulterande Unicode-strängen.  Om ``*byteorder`` är "
"``-1`` eller ``1`` kopieras alla byteordermarkeringar till utdata (där de "
"resulterar i antingen en ``ufeff``- eller en ``ufffeff``-tecken)."

#: ../../c-api/unicode.rst:1234
msgid ""
"After completion, ``*byteorder`` is set to the current byte order at the end "
"of input data."
msgstr ""
"Efter slutförandet ställs ``*byteorder`` in på den aktuella byteordningen i "
"slutet av indata."

#: ../../c-api/unicode.rst:1245
msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeUTF16`. If "
"*consumed* is not ``NULL``, :c:func:`PyUnicode_DecodeUTF16Stateful` will not "
"treat trailing incomplete UTF-16 byte sequences (such as an odd number of "
"bytes or a split surrogate pair) as an error. Those bytes will not be "
"decoded and the number of bytes that have been decoded will be stored in "
"*consumed*."
msgstr ""
"Om *consumed* är ``NULL``, uppför sig som :c:func:`PyUnicode_DecodeUTF16`. "
"Om *consumed* inte är ``NULL`` kommer :c:func:"
"`PyUnicode_DecodeUTF16Stateful`` inte att behandla efterföljande "
"ofullständiga UTF-16 byte-sekvenser (t.ex. ett udda antal byte eller ett "
"delat surrogatpar) som ett fel. Dessa byte kommer inte att avkodas och "
"antalet byte som har avkodats kommer att lagras i *consumed*."

#: ../../c-api/unicode.rst:1254
msgid ""
"Return a Python byte string using the UTF-16 encoding in native byte order. "
"The string always starts with a BOM mark.  Error handling is \"strict\". "
"Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"Returnerar en Python-bytesträng med UTF-16-kodning i inbyggd byteordning. "
"Strängen börjar alltid med en BOM-markering.  Felhanteringen är \"strikt\". "
"Returnera ``NULL`` om ett undantag har uppstått i codec."

#: ../../c-api/unicode.rst:1260
msgid "UTF-7 Codecs"
msgstr "UTF-7-codecs"

#: ../../c-api/unicode.rst:1262
msgid "These are the UTF-7 codec APIs:"
msgstr "Detta är UTF-7-codec API:er:"

#: ../../c-api/unicode.rst:1267
msgid ""
"Create a Unicode object by decoding *size* bytes of the UTF-7 encoded string "
"*str*.  Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"Skapa ett Unicode-objekt genom att avkoda *size* bytes av den UTF-7-kodade "
"strängen *str*.  Returnera ``NULL`` om ett undantag har uppstått i codec."

#: ../../c-api/unicode.rst:1274
msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeUTF7`.  If "
"*consumed* is not ``NULL``, trailing incomplete UTF-7 base-64 sections will "
"not be treated as an error.  Those bytes will not be decoded and the number "
"of bytes that have been decoded will be stored in *consumed*."
msgstr ""
"Om *consumed* är ``NULL``, uppför sig som :c:func:`PyUnicode_DecodeUTF7`.  "
"Om *consumed* inte är ``NULL``, kommer efterföljande ofullständiga UTF-7 "
"base-64 sektioner inte att behandlas som ett fel.  Dessa byte kommer inte "
"att avkodas och antalet byte som har avkodats kommer att lagras i *consumed*."

#: ../../c-api/unicode.rst:1281
msgid "Unicode-Escape Codecs"
msgstr "Unicode-Escape-codecs"

#: ../../c-api/unicode.rst:1283
msgid "These are the \"Unicode Escape\" codec APIs:"
msgstr "Dessa är \"Unicode Escape\"-codec API:erna:"

#: ../../c-api/unicode.rst:1289
msgid ""
"Create a Unicode object by decoding *size* bytes of the Unicode-Escape "
"encoded string *str*.  Return ``NULL`` if an exception was raised by the "
"codec."
msgstr ""
"Skapa ett Unicode-objekt genom att avkoda *size* bytes av den Unicode-Escape-"
"kodade strängen *str*.  Returnerar ``NULL`` om ett undantag har uppstått i "
"codec."

#: ../../c-api/unicode.rst:1295
msgid ""
"Encode a Unicode object using Unicode-Escape and return the result as a "
"bytes object.  Error handling is \"strict\".  Return ``NULL`` if an "
"exception was raised by the codec."
msgstr ""
"Kodar ett Unicode-objekt med Unicode-Escape och returnerar resultatet som "
"ett bytes-objekt.  Felhanteringen är \"strikt\".  Returnera ``NULL`` om ett "
"undantag har uppstått i codec."

#: ../../c-api/unicode.rst:1301
msgid "Raw-Unicode-Escape Codecs"
msgstr "Rå-Unikod-Escape Codecs"

#: ../../c-api/unicode.rst:1303
msgid "These are the \"Raw Unicode Escape\" codec APIs:"
msgstr "Detta är API:erna för codec \"Raw Unicode Escape\":"

#: ../../c-api/unicode.rst:1309
msgid ""
"Create a Unicode object by decoding *size* bytes of the Raw-Unicode-Escape "
"encoded string *str*.  Return ``NULL`` if an exception was raised by the "
"codec."
msgstr ""
"Skapa ett Unicode-objekt genom att avkoda *size* bytes av den Raw-Unicode-"
"Escape-kodade strängen *str*.  Returnera ``NULL`` om ett undantag har "
"uppstått i codec."

#: ../../c-api/unicode.rst:1315
msgid ""
"Encode a Unicode object using Raw-Unicode-Escape and return the result as a "
"bytes object.  Error handling is \"strict\".  Return ``NULL`` if an "
"exception was raised by the codec."
msgstr ""
"Kodar ett Unicode-objekt med Raw-Unicode-Escape och returnerar resultatet "
"som ett bytes-objekt.  Felhanteringen är \"strikt\".  Returnera ``NULL`` om "
"ett undantag har uppstått i codec."

#: ../../c-api/unicode.rst:1321
msgid "Latin-1 Codecs"
msgstr "Latin-1 Codecs"

#: ../../c-api/unicode.rst:1323
msgid ""
"These are the Latin-1 codec APIs: Latin-1 corresponds to the first 256 "
"Unicode ordinals and only these are accepted by the codecs during encoding."
msgstr ""
"Detta är API:erna för Latin-1-codec: Latin-1 motsvarar de första 256 Unicode-"
"ordinalerna och endast dessa accepteras av codecs under kodningen."

#: ../../c-api/unicode.rst:1329
msgid ""
"Create a Unicode object by decoding *size* bytes of the Latin-1 encoded "
"string *str*.  Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"Skapa ett Unicode-objekt genom att avkoda *size* bytes av den Latin-1-kodade "
"strängen *str*.  Returnera ``NULL`` om ett undantag har uppstått i codec."

#: ../../c-api/unicode.rst:1335
msgid ""
"Encode a Unicode object using Latin-1 and return the result as Python bytes "
"object.  Error handling is \"strict\".  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""
"Kodar ett Unicode-objekt med Latin-1 och returnerar resultatet som ett "
"Python bytes-objekt.  Felhanteringen är \"strikt\".  Returnera ``NULL`` om "
"ett undantag uppstod av codec."

#: ../../c-api/unicode.rst:1341
msgid "ASCII Codecs"
msgstr "ASCII Codecs"

#: ../../c-api/unicode.rst:1343
msgid ""
"These are the ASCII codec APIs.  Only 7-bit ASCII data is accepted. All "
"other codes generate errors."
msgstr ""
"Detta är ASCII-codec-API:erna.  Endast 7-bitars ASCII-data accepteras. Alla "
"andra koder genererar fel."

#: ../../c-api/unicode.rst:1349
msgid ""
"Create a Unicode object by decoding *size* bytes of the ASCII encoded string "
"*str*.  Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"Skapa ett Unicode-objekt genom att avkoda *size* bytes av den ASCII-kodade "
"strängen *str*.  Returnera ``NULL`` om ett undantag har uppstått i codec."

#: ../../c-api/unicode.rst:1355
msgid ""
"Encode a Unicode object using ASCII and return the result as Python bytes "
"object.  Error handling is \"strict\".  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""
"Kodar ett Unicode-objekt med ASCII och returnerar resultatet som Python "
"bytes-objekt.  Felhanteringen är \"strikt\".  Returnera ``NULL`` om ett "
"undantag uppstod av codec."

#: ../../c-api/unicode.rst:1361
msgid "Character Map Codecs"
msgstr "Teckenkartan Codecs"

#: ../../c-api/unicode.rst:1363
msgid ""
"This codec is special in that it can be used to implement many different "
"codecs (and this is in fact what was done to obtain most of the standard "
"codecs included in the :mod:`!encodings` package). The codec uses mappings "
"to encode and decode characters.  The mapping objects provided must support "
"the :meth:`~object.__getitem__` mapping interface; dictionaries and "
"sequences work well."
msgstr ""
"Denna codec är speciell eftersom den kan användas för att implementera många "
"olika codecs (och det är faktiskt vad som gjordes för att få de flesta av de "
"standardcodecs som ingår i paketet :mod:`!encodings`). Codec använder "
"mappningar för att koda och avkoda tecken.  De mappningsobjekt som "
"tillhandahålls måste stödja :meth:`~object.__getitem__` "
"mappningsgränssnittet; ordböcker och sekvenser fungerar bra."

#: ../../c-api/unicode.rst:1369
msgid "These are the mapping codec APIs:"
msgstr "Detta är API:erna för mappningskodek:"

#: ../../c-api/unicode.rst:1374
msgid ""
"Create a Unicode object by decoding *size* bytes of the encoded string *str* "
"using the given *mapping* object.  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""
"Skapa ett Unicode-objekt genom att avkoda *size* bytes av den kodade "
"strängen *str* med hjälp av det angivna *mapping*-objektet.  Returnerar "
"``NULL`` om ett undantag har uppstått i codec."

#: ../../c-api/unicode.rst:1378
msgid ""
"If *mapping* is ``NULL``, Latin-1 decoding will be applied.  Else *mapping* "
"must map bytes ordinals (integers in the range from 0 to 255) to Unicode "
"strings, integers (which are then interpreted as Unicode ordinals) or "
"``None``.  Unmapped data bytes -- ones which cause a :exc:`LookupError`, as "
"well as ones which get mapped to ``None``, ``0xFFFE`` or ``'\\ufffe'``, are "
"treated as undefined mappings and cause an error."
msgstr ""
"Om *mapping* är ``NULL`` kommer Latin-1-avkodning att tillämpas.  Annars "
"måste *mapping* mappa bytes ordinaler (heltal i intervallet 0 till 255) till "
"Unicode-strängar, heltal (som sedan tolkas som Unicode-ordinaler) eller "
"``None``.  Databytes som inte mappas -- sådana som orsakar ett :exc:"
"`LookupError`, liksom sådana som mappas till ``None``, ``0xFFFE`` eller "
"``'\\ufffe'``, behandlas som odefinierade mappningar och orsakar ett fel."

#: ../../c-api/unicode.rst:1389
msgid ""
"Encode a Unicode object using the given *mapping* object and return the "
"result as a bytes object.  Error handling is \"strict\".  Return ``NULL`` if "
"an exception was raised by the codec."
msgstr ""
"Kodar ett Unicode-objekt med hjälp av det angivna *mapping*-objektet och "
"returnerar resultatet som ett bytes-objekt.  Felhanteringen är \"strikt\".  "
"Returnera ``NULL`` om ett undantag har uppstått i codec."

#: ../../c-api/unicode.rst:1393
msgid ""
"The *mapping* object must map Unicode ordinal integers to bytes objects, "
"integers in the range from 0 to 255 or ``None``.  Unmapped character "
"ordinals (ones which cause a :exc:`LookupError`) as well as mapped to "
"``None`` are treated as \"undefined mapping\" and cause an error."
msgstr ""
"Objektet *mapping* måste mappa Unicode ordinala heltal till bytesobjekt, "
"heltal i intervallet 0 till 255 eller ``None``.  Omappade teckenordinaler "
"(sådana som orsakar ett :exc:`LookupError`) samt mappade till ``None`` "
"behandlas som \"odefinierad mappning\" och orsakar ett fel."

#: ../../c-api/unicode.rst:1399
msgid "The following codec API is special in that maps Unicode to Unicode."
msgstr ""
"Följande codec API är speciellt genom att det mappar Unicode till Unicode."

#: ../../c-api/unicode.rst:1403
msgid ""
"Translate a string by applying a character mapping table to it and return "
"the resulting Unicode object. Return ``NULL`` if an exception was raised by "
"the codec."
msgstr ""
"Översätt en sträng genom att tillämpa en teckenmappningstabell på den och "
"returnera det resulterande Unicode-objektet. Returnera ``NULL`` om ett "
"undantag har uppstått i codec."

#: ../../c-api/unicode.rst:1407
msgid ""
"The mapping table must map Unicode ordinal integers to Unicode ordinal "
"integers or ``None`` (causing deletion of the character)."
msgstr ""
"Mappningstabellen måste mappa Unicodes ordinala heltal till Unicodes "
"ordinala heltal eller ``None`` (vilket leder till att tecknet raderas)."

#: ../../c-api/unicode.rst:1410
msgid ""
"Mapping tables need only provide the :meth:`~object.__getitem__` interface; "
"dictionaries and sequences work well.  Unmapped character ordinals (ones "
"which cause a :exc:`LookupError`) are left untouched and are copied as-is."
msgstr ""
"Mappningstabeller behöver bara tillhandahålla :meth:`~object.__getitem__`-"
"gränssnittet; ordböcker och sekvenser fungerar också bra.  Omappade "
"teckenordinaler (sådana som orsakar ett :exc:`LookupError`) lämnas orörda "
"och kopieras som de är."

#: ../../c-api/unicode.rst:1414
msgid ""
"*errors* has the usual meaning for codecs. It may be ``NULL`` which "
"indicates to use the default error handling."
msgstr ""
"*errors* har den vanliga betydelsen för codecs. Det kan vara ``NULL`` vilket "
"indikerar att standardfelhanteringen ska användas."

#: ../../c-api/unicode.rst:1419
msgid "MBCS codecs for Windows"
msgstr "MBCS codecs för Windows"

#: ../../c-api/unicode.rst:1421
msgid ""
"These are the MBCS codec APIs. They are currently only available on Windows "
"and use the Win32 MBCS converters to implement the conversions.  Note that "
"MBCS (or DBCS) is a class of encodings, not just one.  The target encoding "
"is defined by the user settings on the machine running the codec."
msgstr ""
"Detta är MBCS codec API:er. De är för närvarande endast tillgängliga i "
"Windows och använder Win32 MBCS-omvandlarna för att implementera "
"omvandlingarna.  Observera att MBCS (eller DBCS) är en klass av kodningar, "
"inte bara en.  Målkodningen definieras av användarinställningarna på den "
"maskin som kör codec:en."

#: ../../c-api/unicode.rst:1428
msgid ""
"Create a Unicode object by decoding *size* bytes of the MBCS encoded string "
"*str*. Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"Skapa ett Unicode-objekt genom att avkoda *size* bytes av den MBCS-kodade "
"strängen *str*. Returnera ``NULL`` om ett undantag har uppstått i codec."

#: ../../c-api/unicode.rst:1435
msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeMBCS`. If "
"*consumed* is not ``NULL``, :c:func:`PyUnicode_DecodeMBCSStateful` will not "
"decode trailing lead byte and the number of bytes that have been decoded "
"will be stored in *consumed*."
msgstr ""
"Om *consumed* är ``NULL``, uppför sig som :c:func:`PyUnicode_DecodeMBCS`. Om "
"*consumed* inte är ``NULL``, kommer :c:func:`PyUnicode_DecodeMBCSStateful`` "
"inte att avkoda trailing lead byte och antalet byte som har avkodats kommer "
"att lagras i *consumed*."

#: ../../c-api/unicode.rst:1444
msgid ""
"Similar to :c:func:`PyUnicode_DecodeMBCSStateful`, except uses the code page "
"specified by *code_page*."
msgstr ""
"Liknar :c:func:`PyUnicode_DecodeMBCSStateful`, men använder den kodsida som "
"anges av *code_page*."

#: ../../c-api/unicode.rst:1450
msgid ""
"Encode a Unicode object using MBCS and return the result as Python bytes "
"object.  Error handling is \"strict\".  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""
"Kodar ett Unicode-objekt med MBCS och returnerar resultatet som Python bytes-"
"objekt.  Felhanteringen är \"strikt\".  Returnera ``NULL`` om ett undantag "
"uppstod av codec."

#: ../../c-api/unicode.rst:1457
msgid ""
"Encode the Unicode object using the specified code page and return a Python "
"bytes object.  Return ``NULL`` if an exception was raised by the codec. Use :"
"c:macro:`!CP_ACP` code page to get the MBCS encoder."
msgstr ""
"Kodar Unicode-objektet med hjälp av den angivna kodsidan och returnerar ett "
"Python bytes-objekt.  Returnera ``NULL`` om ett undantag uppstod av codec. "
"Använd kodsidan :c:macro:`!CP_ACP` för att hämta MBCS-kodaren."

#: ../../c-api/unicode.rst:1467
msgid "Methods and Slot Functions"
msgstr "Metoder och slotfunktioner"

#: ../../c-api/unicode.rst:1469
msgid ""
"The following APIs are capable of handling Unicode objects and strings on "
"input (we refer to them as strings in the descriptions) and return Unicode "
"objects or integers as appropriate."
msgstr ""
"Följande API:er kan hantera Unicode-objekt och strängar som indata (vi "
"refererar till dem som strängar i beskrivningarna) och returnera Unicode-"
"objekt eller heltal på lämpligt sätt."

#: ../../c-api/unicode.rst:1473
msgid "They all return ``NULL`` or ``-1`` if an exception occurs."
msgstr "De returnerar alla ``NULL`` eller ``-1`` om ett undantag inträffar."

#: ../../c-api/unicode.rst:1478
msgid "Concat two strings giving a new Unicode string."
msgstr "Concat två strängar som ger en ny Unicode-sträng."

#: ../../c-api/unicode.rst:1483
msgid ""
"Split a string giving a list of Unicode strings.  If *sep* is ``NULL``, "
"splitting will be done at all whitespace substrings.  Otherwise, splits "
"occur at the given separator.  At most *maxsplit* splits will be done.  If "
"negative, no limit is set.  Separators are not included in the resulting "
"list."
msgstr ""
"Delar en sträng som ger en lista med Unicode-strängar.  Om *sep* är ``NULL`` "
"kommer uppdelning att göras vid alla substrängar med blanksteg.  Annars sker "
"uppdelningen vid den angivna separatorn.  Högst *maxsplit* uppdelningar "
"kommer att göras.  Om värdet är negativt sätts ingen gräns.  Separatorer "
"inkluderas inte i den resulterande listan."

#: ../../c-api/unicode.rst:1488 ../../c-api/unicode.rst:1498
#: ../../c-api/unicode.rst:1519 ../../c-api/unicode.rst:1532
msgid "On error, return ``NULL`` with an exception set."
msgstr "Vid fel returneras ``NULL`` med en undantagsuppsättning."

#: ../../c-api/unicode.rst:1490
msgid "Equivalent to :py:meth:`str.split`."
msgstr "Motsvarar :py:meth:`str.split`."

#: ../../c-api/unicode.rst:1495
msgid ""
"Similar to :c:func:`PyUnicode_Split`, but splitting will be done beginning "
"at the end of the string."
msgstr ""
"Liknar :c:func:`PyUnicode_Split`, men uppdelningen görs från slutet av "
"strängen."

#: ../../c-api/unicode.rst:1500
msgid "Equivalent to :py:meth:`str.rsplit`."
msgstr "Motsvarar :py:meth:`str.rsplit`."

#: ../../c-api/unicode.rst:1505
msgid ""
"Split a Unicode string at line breaks, returning a list of Unicode strings. "
"CRLF is considered to be one line break.  If *keepends* is ``0``, the Line "
"break characters are not included in the resulting strings."
msgstr ""
"Dela en Unicode-sträng vid radbrytningar och returnera en lista med Unicode-"
"strängar. CRLF anses vara en radbrytning.  Om *keepends* är ``0`` inkluderas "
"inte radbrytningstecken i de resulterande strängarna."

#: ../../c-api/unicode.rst:1512
msgid ""
"Split a Unicode string at the first occurrence of *sep*, and return a 3-"
"tuple containing the part before the separator, the separator itself, and "
"the part after the separator. If the separator is not found, return a 3-"
"tuple containing the string itself, followed by two empty strings."
msgstr ""
"Dela en Unicode-sträng vid den första förekomsten av *sep* och returnera en "
"3-tupel som innehåller delen före separatorn, själva separatorn och delen "
"efter separatorn. Om separatorn inte hittas returneras en 3-tupel som "
"innehåller själva strängen, följt av två tomma strängar."

#: ../../c-api/unicode.rst:1517 ../../c-api/unicode.rst:1530
msgid "*sep* must not be empty."
msgstr "*sep* får inte vara tomt."

#: ../../c-api/unicode.rst:1521
msgid "Equivalent to :py:meth:`str.partition`."
msgstr "Motsvarar :py:meth:`str.partition`."

#: ../../c-api/unicode.rst:1526
msgid ""
"Similar to :c:func:`PyUnicode_Partition`, but split a Unicode string at the "
"last occurrence of *sep*. If the separator is not found, return a 3-tuple "
"containing two empty strings, followed by the string itself."
msgstr ""
"Liknar :c:func:`PyUnicode_Partition`, men delar upp en Unicode-sträng vid "
"den sista förekomsten av *sep*. Om separatorn inte hittas returneras en 3-"
"tupel som innehåller två tomma strängar, följt av själva strängen."

#: ../../c-api/unicode.rst:1534
msgid "Equivalent to :py:meth:`str.rpartition`."
msgstr "Motsvarar :py:meth:`str.rpartition`."

#: ../../c-api/unicode.rst:1539
msgid ""
"Join a sequence of strings using the given *separator* and return the "
"resulting Unicode string."
msgstr ""
"Sammanfoga en sekvens av strängar med hjälp av den angivna *separatorn* och "
"returnera den resulterande Unicode-strängen."

#: ../../c-api/unicode.rst:1546
msgid ""
"Return ``1`` if *substr* matches ``unicode[start:end]`` at the given tail "
"end (*direction* == ``-1`` means to do a prefix match, *direction* == ``1`` "
"a suffix match), ``0`` otherwise. Return ``-1`` if an error occurred."
msgstr ""
"Returnerar ``1`` om *substr* matchar ``unicode[start:end]`` vid den angivna "
"svansänden (*direction* == ``-1`` betyder att man gör en prefixmatchning, "
"*direction* == ``1`` en suffixmatchning), ``0`` annars. Returnerar ``-1`` om "
"ett fel inträffade."

#: ../../c-api/unicode.rst:1554
msgid ""
"Return the first position of *substr* in ``unicode[start:end]`` using the "
"given *direction* (*direction* == ``1`` means to do a forward search, "
"*direction* == ``-1`` a backward search).  The return value is the index of "
"the first match; a value of ``-1`` indicates that no match was found, and "
"``-2`` indicates that an error occurred and an exception has been set."
msgstr ""
"Returnerar den första positionen för *substr* i ``unicode[start:end]`` med "
"hjälp av den angivna *direction* (*direction* == ``1`` betyder att man gör "
"en framåtriktad sökning, *direction* == ``-1`` en bakåtriktad sökning).  "
"Returvärdet är index för den första matchningen; ett värde på ``-1`` "
"indikerar att ingen matchning hittades och ``-2`` indikerar att ett fel "
"inträffade och att ett undantag har ställts in."

#: ../../c-api/unicode.rst:1564
msgid ""
"Return the first position of the character *ch* in ``unicode[start:end]`` "
"using the given *direction* (*direction* == ``1`` means to do a forward "
"search, *direction* == ``-1`` a backward search).  The return value is the "
"index of the first match; a value of ``-1`` indicates that no match was "
"found, and ``-2`` indicates that an error occurred and an exception has been "
"set."
msgstr ""
"Returnerar den första positionen för tecknet *ch* i ``unicode[start:end]`` "
"med hjälp av den angivna *direction* (*direction* == ``1`` betyder att man "
"gör en framåtriktad sökning, *direction* == ``-1`` en bakåtriktad sökning).  "
"Returvärdet är index för den första matchningen; ett värde på ``-1`` "
"indikerar att ingen matchning hittades och ``-2`` indikerar att ett fel "
"inträffade och att ett undantag har ställts in."

#: ../../c-api/unicode.rst:1572
msgid ""
"*start* and *end* are now adjusted to behave like ``unicode[start:end]``."
msgstr ""
"*start* och *end* är nu justerade för att bete sig som ``unicode[start:"
"end]``."

#: ../../c-api/unicode.rst:1579
msgid ""
"Return the number of non-overlapping occurrences of *substr* in "
"``unicode[start:end]``.  Return ``-1`` if an error occurred."
msgstr ""
"Returnerar antalet icke-överlappande förekomster av *substr* i "
"``unicode[start:end]``.  Returnera ``-1`` om ett fel inträffade."

#: ../../c-api/unicode.rst:1586
msgid ""
"Replace at most *maxcount* occurrences of *substr* in *unicode* with "
"*replstr* and return the resulting Unicode object. *maxcount* == ``-1`` "
"means replace all occurrences."
msgstr ""
"Ersätt högst *maxcount* förekomster av *substr* i *unicode* med *replstr* "
"och returnera det resulterande Unicode-objektet. *maxcount* == ``-1`` "
"innebär att alla förekomster ersätts."

#: ../../c-api/unicode.rst:1593
msgid ""
"Compare two strings and return ``-1``, ``0``, ``1`` for less than, equal, "
"and greater than, respectively."
msgstr ""
"Jämför två strängar och returnera ``-1``, ``0``, ``1`` för mindre än, lika "
"med respektive större än."

#: ../../c-api/unicode.rst:1596
msgid ""
"This function returns ``-1`` upon failure, so one should call :c:func:"
"`PyErr_Occurred` to check for errors."
msgstr ""
"Denna funktion returnerar ``-1`` om den misslyckas, så man bör anropa :c:"
"func:`PyErr_Occurred` för att kontrollera om det finns fel."

#: ../../c-api/unicode.rst:1601
msgid "The :c:func:`PyUnicode_Equal` function."
msgstr "Funktionen :c:func:`PyUnicode_Equal`."

#: ../../c-api/unicode.rst:1606
msgid "Test if two strings are equal:"
msgstr "Testar om två strängar är lika:"

#: ../../c-api/unicode.rst:1608
msgid "Return ``1`` if *a* is equal to *b*."
msgstr "Returnerar ``1`` om *a* är lika med *b*."

#: ../../c-api/unicode.rst:1609
msgid "Return ``0`` if *a* is not equal to *b*."
msgstr "Returnerar ``0`` om *a* inte är lika med *b*."

#: ../../c-api/unicode.rst:1610
msgid ""
"Set a :exc:`TypeError` exception and return ``-1`` if *a* or *b* is not a :"
"class:`str` object."
msgstr ""
"Ställ in ett :exc:`TypeError`-undantag och returnera ``-1`` om *a* eller *b* "
"inte är ett :class:`str`-objekt."

#: ../../c-api/unicode.rst:1613
msgid "The function always succeeds if *a* and *b* are :class:`str` objects."
msgstr "Funktionen lyckas alltid om *a* och *b* är :class:`str`-objekt."

#: ../../c-api/unicode.rst:1615
msgid ""
"The function works for :class:`str` subclasses, but does not honor custom "
"``__eq__()`` method."
msgstr ""
"Funktionen fungerar för underklasserna :class:`str`, men inte för den "
"anpassade metoden ``__eq__()``."

#: ../../c-api/unicode.rst:1620
msgid "The :c:func:`PyUnicode_Compare` function."
msgstr "Funktionen :c:func:`PyUnicode_Compare`."

#: ../../c-api/unicode.rst:1627
msgid ""
"Compare a Unicode object with a char buffer which is interpreted as being "
"UTF-8 or ASCII encoded and return true (``1``) if they are equal, or false "
"(``0``) otherwise. If the Unicode object contains surrogate code points "
"(``U+D800`` - ``U+DFFF``) or the C string is not valid UTF-8, false (``0``) "
"is returned."
msgstr ""
"Jämför ett Unicode-objekt med en char-buffert som tolkas som UTF-8- eller "
"ASCII-kodad och returnerar true (``1``) om de är lika, eller false (``0``) "
"annars. Om Unicode-objektet innehåller surrogatkodpunkter (``U+D800`` - "
"``U+DFFF``) eller om C-strängen inte är giltig UTF-8, returneras false "
"(``0``)."

#: ../../c-api/unicode.rst:1634 ../../c-api/unicode.rst:1655
msgid "This function does not raise exceptions."
msgstr "Denna funktion ger inte upphov till undantag."

#: ../../c-api/unicode.rst:1641
msgid ""
"Similar to :c:func:`PyUnicode_EqualToUTF8AndSize`, but compute *string* "
"length using :c:func:`!strlen`. If the Unicode object contains null "
"characters, false (``0``) is returned."
msgstr ""
"Liknar :c:func:`PyUnicode_EqualToUTF8AndSize`, men beräknar *strängens* "
"längd med hjälp av :c:func:`!strlen`. Om Unicode-objektet innehåller null-"
"tecken returneras false (``0``)."

#: ../../c-api/unicode.rst:1650
msgid ""
"Compare a Unicode object, *unicode*, with *string* and return ``-1``, ``0``, "
"``1`` for less than, equal, and greater than, respectively. It is best to "
"pass only ASCII-encoded strings, but the function interprets the input "
"string as ISO-8859-1 if it contains non-ASCII characters."
msgstr ""
"Jämför ett Unicode-objekt, *unicode*, med *sträng* och returnerar ``-1``, "
"``0``, ``1`` för mindre än, lika med respektive större än. Det är bäst att "
"bara skicka ASCII-kodade strängar, men funktionen tolkar indatasträngen som "
"ISO-8859-1 om den innehåller icke-ASCII-tecken."

#: ../../c-api/unicode.rst:1660
msgid "Rich compare two Unicode strings and return one of the following:"
msgstr "Rich jämför två Unicode-strängar och returnerar något av följande:"

#: ../../c-api/unicode.rst:1662
msgid "``NULL`` in case an exception was raised"
msgstr "``NULL`` i händelse av att ett undantag uppstod"

#: ../../c-api/unicode.rst:1663
msgid ":c:data:`Py_True` or :c:data:`Py_False` for successful comparisons"
msgstr ":c:data:`Py_True` eller :c:data:`Py_False` för lyckade jämförelser"

#: ../../c-api/unicode.rst:1664
msgid ":c:data:`Py_NotImplemented` in case the type combination is unknown"
msgstr ":c:data:`Py_NotImplemented` om typkombinationen är okänd"

#: ../../c-api/unicode.rst:1666
msgid ""
"Possible values for *op* are :c:macro:`Py_GT`, :c:macro:`Py_GE`, :c:macro:"
"`Py_EQ`, :c:macro:`Py_NE`, :c:macro:`Py_LT`, and :c:macro:`Py_LE`."
msgstr ""
"Möjliga värden för *op* är :c:macro:`Py_GT`, :c:macro:`Py_GE`, :c:macro:"
"`Py_EQ`, :c:macro:`Py_NE`, :c:macro:`Py_LT` och :c:macro:`Py_LE`."

#: ../../c-api/unicode.rst:1672
msgid ""
"Return a new string object from *format* and *args*; this is analogous to "
"``format % args``."
msgstr ""
"Returnerar ett nytt strängobjekt från *format* och *args*; detta är analogt "
"med ``format % args``."

#: ../../c-api/unicode.rst:1678
msgid ""
"Check whether *substr* is contained in *unicode* and return true or false "
"accordingly."
msgstr ""
"Kontrollera om *substr* ingår i *unicode* och returnera true eller false i "
"enlighet med detta."

#: ../../c-api/unicode.rst:1681
msgid ""
"*substr* has to coerce to a one element Unicode string. ``-1`` is returned "
"if there was an error."
msgstr ""
"*substr* måste sammanfogas till en Unicode-sträng med ett element. ``-1`` "
"returneras om det uppstod ett fel."

#: ../../c-api/unicode.rst:1687
msgid ""
"Intern the argument :c:expr:`*p_unicode` in place.  The argument must be the "
"address of a pointer variable pointing to a Python Unicode string object.  "
"If there is an existing interned string that is the same as :c:expr:"
"`*p_unicode`, it sets :c:expr:`*p_unicode` to it (releasing the reference to "
"the old string object and creating a new :term:`strong reference` to the "
"interned string object), otherwise it leaves :c:expr:`*p_unicode` alone and "
"interns it."
msgstr ""
"Internerar argumentet :c:expr:`*p_unicode` på plats.  Argumentet måste vara "
"adressen till en pekarvariabel som pekar på ett Python Unicode-"
"strängobjekt.  Om det finns en befintlig internerad sträng som är samma som :"
"c:expr:`*p_unicode`, sätter den :c:expr:`*p_unicode` till den (släpper "
"referensen till det gamla strängobjektet och skapar en ny :term:`strong "
"referens` till det internerade strängobjektet), annars lämnar den :c:expr:"
"`*p_unicode` ensam och internerar den."

#: ../../c-api/unicode.rst:1694
msgid ""
"(Clarification: even though there is a lot of talk about references, think "
"of this function as reference-neutral. You must own the object you pass in; "
"after the call you no longer own the passed-in reference, but you newly own "
"the result.)"
msgstr ""
"(Förtydligande: även om det talas mycket om referenser, tänk på denna "
"funktion som referensneutral. Du måste äga objektet du skickar in; efter "
"anropet äger du inte längre den skickade referensen, men du äger nyligen "
"resultatet)"

#: ../../c-api/unicode.rst:1699
msgid ""
"This function never raises an exception. On error, it leaves its argument "
"unchanged without interning it."
msgstr ""
"Denna funktion ger aldrig upphov till ett undantag. Vid fel lämnar den sitt "
"argument oförändrat utan att ingripa i det."

#: ../../c-api/unicode.rst:1702
msgid ""
"Instances of subclasses of :py:class:`str` may not be interned, that is, :c:"
"expr:`PyUnicode_CheckExact(*p_unicode)` must be true. If it is not, then -- "
"as with any other error -- the argument is left unchanged."
msgstr ""
"Instanser av underklasser till :py:class:`str` får inte internaliseras, det "
"vill säga :c:expr:`PyUnicode_CheckExact(*p_unicode)` måste vara sant. Om så "
"inte är fallet lämnas argumentet oförändrat, precis som med alla andra fel."

#: ../../c-api/unicode.rst:1706
msgid ""
"Note that interned strings are not “immortal”. You must keep a reference to "
"the result to benefit from interning."
msgstr ""
"Observera att internerade strängar inte är \"odödliga\". Du måste behålla en "
"referens till resultatet för att dra nytta av interning."

#: ../../c-api/unicode.rst:1712
msgid ""
"A combination of :c:func:`PyUnicode_FromString` and :c:func:"
"`PyUnicode_InternInPlace`, meant for statically allocated strings."
msgstr ""
"En kombination av :c:func:`PyUnicode_FromString` och :c:func:"
"`PyUnicode_InternInPlace`, avsedd för statiskt allokerade strängar."

#: ../../c-api/unicode.rst:1715
msgid ""
"Return a new (\"owned\") reference to either a new Unicode string object "
"that has been interned, or an earlier interned string object with the same "
"value."
msgstr ""
"Returnerar en ny (\"ägd\") referens till antingen ett nytt Unicode-"
"strängobjekt som har internaliserats eller ett tidigare internaliserat "
"strängobjekt med samma värde."

#: ../../c-api/unicode.rst:1719
msgid ""
"Python may keep a reference to the result, or make it :term:`immortal`, "
"preventing it from being garbage-collected promptly. For interning an "
"unbounded number of different strings, such as ones coming from user input, "
"prefer calling :c:func:`PyUnicode_FromString` and :c:func:"
"`PyUnicode_InternInPlace` directly."
msgstr ""
"Python kan behålla en referens till resultatet, eller göra det :term:"
"`immortal`, vilket förhindrar att det omedelbart samlas in i skräp. För "
"internering av ett obegränsat antal olika strängar, till exempel sådana som "
"kommer från användarinmatning, föredrar du att anropa :c:func:"
"`PyUnicode_FromString` och :c:func:`PyUnicode_InternInPlace` direkt."

#: ../../c-api/unicode.rst:1728
msgid ""
"Return a non-zero value if *str* is interned, zero if not. The *str* "
"argument must be a string; this is not checked. This function always "
"succeeds."
msgstr ""
"Returnerar ett värde som inte är noll om *str* är internerad, noll annars. "
"Argumentet *str* måste vara en sträng; detta kontrolleras inte. Denna "
"funktion lyckas alltid."

#: ../../c-api/unicode.rst:1734
msgid ""
"A non-zero return value may carry additional information about *how* the "
"string is interned. The meaning of such non-zero values, as well as each "
"specific string's intern-related details, may change between CPython "
"versions."
msgstr ""
"Ett returvärde som inte är noll kan innehålla ytterligare information om "
"*hur* strängen är internaliserad. Betydelsen av sådana icke-nollvärden, "
"liksom varje specifik strängs internrelaterade detaljer, kan ändras mellan "
"CPython-versioner."

#: ../../c-api/unicode.rst:1741
msgid "PyUnicodeWriter"
msgstr "PyUnicodeSkribent"

#: ../../c-api/unicode.rst:1743
msgid ""
"The :c:type:`PyUnicodeWriter` API can be used to create a Python :class:"
"`str` object."
msgstr ""
"API:et :c:type:`PyUnicodeWriter` kan användas för att skapa ett Python :"
"class:`str`-objekt."

#: ../../c-api/unicode.rst:1750
msgid "A Unicode writer instance."
msgstr "En instans för Unicode-skrivare."

#: ../../c-api/unicode.rst:1752
msgid ""
"The instance must be destroyed by :c:func:`PyUnicodeWriter_Finish` on "
"success, or :c:func:`PyUnicodeWriter_Discard` on error."
msgstr ""
"Instansen måste förstöras av :c:func:`PyUnicodeWriter_Finish` vid framgång, "
"eller :c:func:`PyUnicodeWriter_Discard` vid fel."

#: ../../c-api/unicode.rst:1757
msgid "Create a Unicode writer instance."
msgstr "Skapa en Unicode-skrivarinstans."

#: ../../c-api/unicode.rst:1759
msgid "*length* must be greater than or equal to ``0``."
msgstr "*length* måste vara större än eller lika med ``0``."

#: ../../c-api/unicode.rst:1761
msgid ""
"If *length* is greater than ``0``, preallocate an internal buffer of "
"*length* characters."
msgstr ""
"Om *length* är större än ``0``, allokeras en intern buffert med *length* "
"tecken."

#: ../../c-api/unicode.rst:1764 ../../c-api/unicode.rst:1770
msgid "Set an exception and return ``NULL`` on error."
msgstr "Ställ in ett undantag och returnera ``NULL`` vid fel."

#: ../../c-api/unicode.rst:1768
msgid ""
"Return the final Python :class:`str` object and destroy the writer instance."
msgstr ""
"Returnerar det slutliga Python :class:`str`-objektet och förstör "
"skrivarinstansen."

#: ../../c-api/unicode.rst:1772 ../../c-api/unicode.rst:1780
msgid "The writer instance is invalid after this call."
msgstr "Skrivarinstansen är ogiltig efter detta anrop."

#: ../../c-api/unicode.rst:1776
msgid "Discard the internal Unicode buffer and destroy the writer instance."
msgstr "Kassera den interna Unicode-bufferten och förstör skrivarinstansen."

#: ../../c-api/unicode.rst:1778
msgid "If *writer* is ``NULL``, no operation is performed."
msgstr "Om *writer* är ``NULL`` utförs ingen åtgärd."

#: ../../c-api/unicode.rst:1784
msgid "Write the single Unicode character *ch* into *writer*."
msgstr "Skriv det enskilda Unicode-tecknet *ch* till *writer*."

#: ../../c-api/unicode.rst:1786 ../../c-api/unicode.rst:1796
#: ../../c-api/unicode.rst:1811 ../../c-api/unicode.rst:1823
#: ../../c-api/unicode.rst:1832 ../../c-api/unicode.rst:1839
#: ../../c-api/unicode.rst:1846 ../../c-api/unicode.rst:1857
#: ../../c-api/unicode.rst:1864 ../../c-api/unicode.rst:1883
msgid ""
"On success, return ``0``. On error, set an exception, leave the writer "
"unchanged, and return ``-1``."
msgstr ""
"Vid framgång returneras ``0``. Vid fel, sätt ett undantag, lämna skrivaren "
"oförändrad och returnera ``-1``."

#: ../../c-api/unicode.rst:1791
msgid ""
"Decode the string *str* from UTF-8 in strict mode and write the output into "
"*writer*."
msgstr ""
"Avkoda strängen *str* från UTF-8 i strikt läge och skriv utdata till "
"*writer*."

#: ../../c-api/unicode.rst:1793 ../../c-api/unicode.rst:1805
#: ../../c-api/unicode.rst:1872
msgid ""
"*size* is the string length in bytes. If *size* is equal to ``-1``, call "
"``strlen(str)`` to get the string length."
msgstr ""
"*size* är strängens längd i byte. Om *size* är lika med ``-1``, anropa "
"``strlen(str)`` för att få fram strängens längd."

#: ../../c-api/unicode.rst:1799
msgid "See also :c:func:`PyUnicodeWriter_DecodeUTF8Stateful`."
msgstr "Se även :c:func:`PyUnicodeWriter_DecodeUTF8Stateful`."

#: ../../c-api/unicode.rst:1803
msgid "Write the ASCII string *str* into *writer*."
msgstr "Skriv ASCII-strängen *str* till *writer*."

#: ../../c-api/unicode.rst:1808
msgid ""
"*str* must only contain ASCII characters. The behavior is undefined if *str* "
"contains non-ASCII characters."
msgstr ""
"*str* får endast innehålla ASCII-tecken. Beteendet är odefinierat om *str* "
"innehåller icke-ASCII-tecken."

#: ../../c-api/unicode.rst:1818
msgid "Write the wide string *str* into *writer*."
msgstr "Skriv den breda strängen *str* till *writer*."

#: ../../c-api/unicode.rst:1820
msgid ""
"*size* is a number of wide characters. If *size* is equal to ``-1``, call "
"``wcslen(str)`` to get the string length."
msgstr ""
"*size* är ett antal breda tecken. Om *size* är lika med ``-1``, anropa "
"``wcslen(str)`` för att få fram strängens längd."

#: ../../c-api/unicode.rst:1828
msgid "Writer the UCS4 string *str* into *writer*."
msgstr "Skriv UCS4-strängen *str* till *writer*."

#: ../../c-api/unicode.rst:1830
msgid "*size* is a number of UCS4 characters."
msgstr "*size* är ett antal UCS4-tecken."

#: ../../c-api/unicode.rst:1837
msgid ""
"Call :c:func:`PyObject_Str` on *obj* and write the output into *writer*."
msgstr "Anropa :c:func:`PyObject_Str` på *obj* och skriv utdata till *writer*."

#: ../../c-api/unicode.rst:1844
msgid ""
"Call :c:func:`PyObject_Repr` on *obj* and write the output into *writer*."
msgstr ""
"Anropa :c:func:`PyObject_Repr` på *obj* och skriv utdata till *writer*."

#: ../../c-api/unicode.rst:1851
msgid "Write the substring ``str[start:end]`` into *writer*."
msgstr "Skriv in delsträngen ``str[start:slut]`` i *writer*."

#: ../../c-api/unicode.rst:1853
msgid ""
"*str* must be Python :class:`str` object. *start* must be greater than or "
"equal to 0, and less than or equal to *end*. *end* must be less than or "
"equal to *str* length."
msgstr ""
"*str* måste vara Python :class:`str`-objekt. *start* måste vara större än "
"eller lika med 0, och mindre än eller lika med *end*. *end* måste vara "
"mindre än eller lika med *str* längd."

#: ../../c-api/unicode.rst:1862
msgid ""
"Similar to :c:func:`PyUnicode_FromFormat`, but write the output directly "
"into *writer*."
msgstr ""
"Liknar :c:func:`PyUnicode_FromFormat`, men skriver utdata direkt till "
"*writer*."

#: ../../c-api/unicode.rst:1869
msgid ""
"Decode the string *str* from UTF-8 with *errors* error handler and write the "
"output into *writer*."
msgstr ""
"Avkoda strängen *str* från UTF-8 med felhanteraren *errors* och skriv utdata "
"till *writer*."

#: ../../c-api/unicode.rst:1875
msgid ""
"*errors* is an :ref:`error handler <error-handlers>` name, such as "
"``\"replace\"``. If *errors* is ``NULL``, use the strict error handler."
msgstr ""
"*errors* är ett :ref:`felhanterare <error-handlers>` namn, som till exempel "
"``\"replace\"``. Om *errors* är ``NULL`` används den strikta felhanteringen."

#: ../../c-api/unicode.rst:1878
msgid ""
"If *consumed* is not ``NULL``, set *\\*consumed* to the number of decoded "
"bytes on success. If *consumed* is ``NULL``, treat trailing incomplete UTF-8 "
"byte sequences as an error."
msgstr ""
"Om *consumed* inte är ``NULL``, sätt *\\*consumed* till antalet avkodade "
"byte vid framgång. Om *consumed* är ``NULL``, behandlas efterföljande "
"ofullständiga UTF-8 byte-sekvenser som ett fel."

#: ../../c-api/unicode.rst:1886
msgid "See also :c:func:`PyUnicodeWriter_WriteUTF8`."
msgstr "Se även :c:func:`PyUnicodeWriter_WriteUTF8`."

#: ../../c-api/unicode.rst:1889
msgid "Deprecated API"
msgstr "Föråldrad API"

#: ../../c-api/unicode.rst:1891
msgid "The following API is deprecated."
msgstr "Följande API är föråldrat."

#: ../../c-api/unicode.rst:1895
msgid ""
"This is a typedef of :c:type:`wchar_t`, which is a 16-bit type or 32-bit "
"type depending on the platform. Please use :c:type:`wchar_t` directly "
"instead."
msgstr ""
"Detta är en typdefinition av :c:type:`wchar_t`, som är en 16-bitars typ "
"eller 32-bitars typ beroende på plattform. Använd :c:type:`wchar_t` direkt "
"istället."

#: ../../c-api/unicode.rst:1899
msgid ""
"In previous versions, this was a 16-bit type or a 32-bit type depending on "
"whether you selected a \"narrow\" or \"wide\" Unicode version of Python at "
"build time."
msgstr ""
"I tidigare versioner var detta en 16-bitars typ eller en 32-bitars typ "
"beroende på om du valde en \"smal\" eller \"bred\" Unicode-version av Python "
"vid byggtiden."

#: ../../c-api/unicode.rst:1909
msgid ""
"Do nothing and return ``0``. This API is kept only for backward "
"compatibility, but there are no plans to remove it."
msgstr ""
"Gör ingenting och returnerar ``0``. Detta API behålls endast för "
"bakåtkompatibilitet, men det finns inga planer på att ta bort det."

#: ../../c-api/unicode.rst:1915
msgid ""
"This API does nothing since Python 3.12. Previously, this needed to be "
"called for each string created using the old API (:c:func:`!"
"PyUnicode_FromUnicode` or similar)."
msgstr ""
"Detta API gör ingenting sedan Python 3.12. Tidigare behövde detta anropas "
"för varje sträng som skapades med det gamla API:et (:c:func:`!"
"PyUnicode_FromUnicode` eller liknande)."

#: ../../c-api/unicode.rst:1923
msgid ""
"Do nothing and return ``1``. This API is kept only for backward "
"compatibility, but there are no plans to remove it."
msgstr ""
"Gör ingenting och returnera ``1``. Detta API behålls endast för "
"bakåtkompatibilitet, men det finns inga planer på att ta bort det."

#: ../../c-api/unicode.rst:1929
msgid ""
"This API does nothing since Python 3.12. Previously, this could be called to "
"check if :c:func:`PyUnicode_READY` is necessary."
msgstr ""
"Detta API gör ingenting sedan Python 3.12. Tidigare kunde detta anropas för "
"att kontrollera om :c:func:`PyUnicode_READY` är nödvändigt."
