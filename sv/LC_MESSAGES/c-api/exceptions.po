# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# python-doc bot, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-25 17:21+0000\n"
"PO-Revision-Date: 2025-09-22 15:57+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../c-api/exceptions.rst:8
msgid "Exception Handling"
msgstr "Hantering av undantag"

#: ../../c-api/exceptions.rst:10
msgid ""
"The functions described in this chapter will let you handle and raise Python"
" exceptions.  It is important to understand some of the basics of Python "
"exception handling.  It works somewhat like the POSIX :c:data:`errno` "
"variable: there is a global indicator (per thread) of the last error that "
"occurred.  Most C API functions don't clear this on success, but will set it"
" to indicate the cause of the error on failure.  Most C API functions also "
"return an error indicator, usually ``NULL`` if they are supposed to return a"
" pointer, or ``-1`` if they return an integer (exception: the ``PyArg_*`` "
"functions return ``1`` for success and ``0`` for failure)."
msgstr ""
"De funktioner som beskrivs i detta kapitel låter dig hantera och skapa "
"Python-undantag.  Det är viktigt att förstå några av grunderna i Pythons "
"undantagshantering.  Det fungerar ungefär som POSIX "
":c:data:`errno`-variabeln: det finns en global indikator (per tråd) för det "
"senaste felet som inträffade.  De flesta C API-funktioner rensar inte detta "
"vid framgång, men kommer att ställa in det för att ange orsaken till felet "
"vid misslyckande.  De flesta C API-funktioner returnerar också en "
"felindikator, vanligtvis ``NULL`` om de ska returnera en pekare, eller "
"``-1`` om de returnerar ett heltal (undantag: funktionerna ``PyArg_*`` "
"returnerar ``1`` vid framgång och ``0`` vid misslyckande)."

#: ../../c-api/exceptions.rst:20
msgid ""
"Concretely, the error indicator consists of three object pointers: the "
"exception's type, the exception's value, and the traceback object.  Any of "
"those pointers can be ``NULL`` if non-set (although some combinations are "
"forbidden, for example you can't have a non-``NULL`` traceback if the "
"exception type is ``NULL``)."
msgstr ""
"Konkret består felindikatorn av tre objektpekare: undantagets typ, "
"undantagets värde och traceback-objektet.  Vilken som helst av dessa pekare "
"kan vara ``NULL`` om den inte är inställd (även om vissa kombinationer är "
"förbjudna, till exempel kan du inte ha en traceback som inte är ``NULL`` om "
"undantagstypen är ``NULL``)."

#: ../../c-api/exceptions.rst:26
msgid ""
"When a function must fail because some function it called failed, it "
"generally doesn't set the error indicator; the function it called already "
"set it.  It is responsible for either handling the error and clearing the "
"exception or returning after cleaning up any resources it holds (such as "
"object references or memory allocations); it should *not* continue normally "
"if it is not prepared to handle the error.  If returning due to an error, it"
" is important to indicate to the caller that an error has been set.  If the "
"error is not handled or carefully propagated, additional calls into the "
"Python/C API may not behave as intended and may fail in mysterious ways."
msgstr ""
"När en funktion måste misslyckas på grund av att någon funktion som den "
"anropade misslyckades, sätter den i allmänhet inte felindikatorn; den "
"funktion som den anropade har redan satt den.  Den är ansvarig för att "
"antingen hantera felet och rensa undantaget eller återvända efter att ha "
"rensat upp alla resurser den har (t.ex. objektreferenser eller "
"minnesallokeringar); den ska *inte* fortsätta normalt om den inte är beredd "
"att hantera felet.  Om den återvänder på grund av ett fel är det viktigt att"
" ange för den som anropar att ett fel har uppstått.  Om felet inte hanteras "
"eller sprids på ett noggrant sätt kan det hända att ytterligare anrop till "
"Python/C API:et inte beter sig som avsett och misslyckas på mystiska sätt."

#: ../../c-api/exceptions.rst:37
msgid ""
"The error indicator is **not** the result of :func:`sys.exc_info()`. The "
"former corresponds to an exception that is not yet caught (and is therefore "
"still propagating), while the latter returns an exception after it is caught"
" (and has therefore stopped propagating)."
msgstr ""

#: ../../c-api/exceptions.rst:44
msgid "Printing and clearing"
msgstr "Tryckning och clearing"

#: ../../c-api/exceptions.rst:49
msgid ""
"Clear the error indicator.  If the error indicator is not set, there is no "
"effect."
msgstr ""
"Rensa felindikatorn.  Om felindikatorn inte är inställd har det ingen "
"effekt."

#: ../../c-api/exceptions.rst:55
msgid ""
"Print a standard traceback to ``sys.stderr`` and clear the error indicator. "
"**Unless** the error is a ``SystemExit``, in that case no traceback is "
"printed and the Python process will exit with the error code specified by "
"the ``SystemExit`` instance."
msgstr ""
"Skriver ut en standardspårning till ``sys.stderr`` och rensar felindikatorn."
" **Om** felet inte är ett ``SystemExit``, i så fall skrivs ingen spårning ut"
" och Python-processen avslutas med den felkod som anges av "
"``SystemExit``-instansen."

#: ../../c-api/exceptions.rst:60
msgid ""
"Call this function **only** when the error indicator is set.  Otherwise it "
"will cause a fatal error!"
msgstr ""
"Anropa denna funktion **endast** när felindikatorn är inställd.  Annars "
"kommer den att orsaka ett dödligt fel!"

#: ../../c-api/exceptions.rst:63
msgid ""
"If *set_sys_last_vars* is nonzero, the variables :data:`sys.last_type`, "
":data:`sys.last_value` and :data:`sys.last_traceback` will be set to the "
"type, value and traceback of the printed exception, respectively."
msgstr ""

#: ../../c-api/exceptions.rst:70
msgid "Alias for ``PyErr_PrintEx(1)``."
msgstr "Alias för ``PyErr_PrintEx(1)``."

#: ../../c-api/exceptions.rst:75
msgid ""
"Call :func:`sys.unraisablehook` using the current exception and *obj* "
"argument."
msgstr ""
"Anropa :func:`sys.unraisablehook` med aktuellt undantag och *obj*-argument."

#: ../../c-api/exceptions.rst:78
msgid ""
"This utility function prints a warning message to ``sys.stderr`` when an "
"exception has been set but it is impossible for the interpreter to actually "
"raise the exception.  It is used, for example, when an exception occurs in "
"an :meth:`__del__` method."
msgstr ""

#: ../../c-api/exceptions.rst:83
msgid ""
"The function is called with a single argument *obj* that identifies the "
"context in which the unraisable exception occurred. If possible, the repr of"
" *obj* will be printed in the warning message."
msgstr ""

#: ../../c-api/exceptions.rst:87
msgid "An exception must be set when calling this function."
msgstr "Ett undantag måste ställas in när denna funktion anropas."

#: ../../c-api/exceptions.rst:91
msgid "Raising exceptions"
msgstr "Upprättande av undantag"

#: ../../c-api/exceptions.rst:93
msgid ""
"These functions help you set the current thread's error indicator. For "
"convenience, some of these functions will always return a ``NULL`` pointer "
"for use in a ``return`` statement."
msgstr ""
"Dessa funktioner hjälper dig att ställa in den aktuella trådens "
"felindikator. För enkelhetens skull kommer vissa av dessa funktioner alltid "
"att returnera en ``NULL``-pekare för användning i en ``return``-sats."

#: ../../c-api/exceptions.rst:100
msgid ""
"This is the most common way to set the error indicator.  The first argument "
"specifies the exception type; it is normally one of the standard exceptions,"
" e.g. :c:data:`PyExc_RuntimeError`.  You need not create a new :term:`strong"
" reference` to it (e.g. with :c:func:`Py_INCREF`). The second argument is an"
" error message; it is decoded from ``'utf-8'``."
msgstr ""
"Detta är det vanligaste sättet att ställa in felindikatorn.  Det första "
"argumentet anger undantagstypen; det är normalt ett av standardundantagen, "
"t.ex. :c:data:`PyExc_RuntimeError`.  Du behöver inte skapa en ny "
":term:`strong reference` till den (t.ex. med :c:func:`Py_INCREF`). Det andra"
" argumentet är ett felmeddelande; det avkodas från ``'utf-8'``."

#: ../../c-api/exceptions.rst:109
msgid ""
"This function is similar to :c:func:`PyErr_SetString` but lets you specify "
"an arbitrary Python object for the \"value\" of the exception."
msgstr ""
"Den här funktionen liknar :c:func:`PyErr_SetString` men låter dig ange ett "
"godtyckligt Python-objekt som \"värde\" för undantaget."

#: ../../c-api/exceptions.rst:115
msgid ""
"This function sets the error indicator and returns ``NULL``.  *exception* "
"should be a Python exception class.  The *format* and subsequent parameters "
"help format the error message; they have the same meaning and values as in "
":c:func:`PyUnicode_FromFormat`. *format* is an ASCII-encoded string."
msgstr ""
"Denna funktion anger felindikatorn och returnerar ``NULL``.  *exception* bör"
" vara en Python exception-klass.  Parametrarna *format* och följande hjälper"
" till att formatera felmeddelandet; de har samma betydelse och värden som i "
":c:func:`PyUnicode_FromFormat`. *format* är en ASCII-kodad sträng."

#: ../../c-api/exceptions.rst:124
msgid ""
"Same as :c:func:`PyErr_Format`, but taking a :c:type:`va_list` argument "
"rather than a variable number of arguments."
msgstr ""
"Samma som :c:func:`PyErr_Format`, men tar ett :c:type:`va_list`-argument i "
"stället för ett variabelt antal argument."

#: ../../c-api/exceptions.rst:132
msgid "This is a shorthand for ``PyErr_SetObject(type, Py_None)``."
msgstr "Detta är en förkortning för ``PyErr_SetObject(type, Py_None)``."

#: ../../c-api/exceptions.rst:137
msgid ""
"This is a shorthand for ``PyErr_SetString(PyExc_TypeError, message)``, where"
" *message* indicates that a built-in operation was invoked with an illegal "
"argument.  It is mostly for internal use."
msgstr ""
"Detta är en förkortning för ``PyErr_SetString(PyExc_TypeError, message)``, "
"där *message* anger att en inbyggd operation anropades med ett olagligt "
"argument.  Den är mestadels för internt bruk."

#: ../../c-api/exceptions.rst:144
msgid ""
"This is a shorthand for ``PyErr_SetNone(PyExc_MemoryError)``; it returns "
"``NULL`` so an object allocation function can write ``return "
"PyErr_NoMemory();`` when it runs out of memory."
msgstr ""
"Detta är en förkortning för ``PyErr_SetNone(PyExc_MemoryError)``; den "
"returnerar ``NULL`` så att en objektallokeringsfunktion kan skriva ``return "
"PyErr_NoMemory();`` när den har slut på minne."

#: ../../c-api/exceptions.rst:153
msgid ""
"This is a convenience function to raise an exception when a C library "
"function has returned an error and set the C variable :c:data:`errno`.  It "
"constructs a tuple object whose first item is the integer :c:data:`errno` "
"value and whose second item is the corresponding error message (gotten from "
":c:func:`strerror`), and then calls ``PyErr_SetObject(type, object)``.  On "
"Unix, when the :c:data:`errno` value is :const:`EINTR`, indicating an "
"interrupted system call, this calls :c:func:`PyErr_CheckSignals`, and if "
"that set the error indicator, leaves it set to that.  The function always "
"returns ``NULL``, so a wrapper function around a system call can write "
"``return PyErr_SetFromErrno(type);`` when the system call returns an error."
msgstr ""

#: ../../c-api/exceptions.rst:167
msgid ""
"Similar to :c:func:`PyErr_SetFromErrno`, with the additional behavior that "
"if *filenameObject* is not ``NULL``, it is passed to the constructor of "
"*type* as a third parameter.  In the case of :exc:`OSError` exception, this "
"is used to define the :attr:`filename` attribute of the exception instance."
msgstr ""

#: ../../c-api/exceptions.rst:176
msgid ""
"Similar to :c:func:`PyErr_SetFromErrnoWithFilenameObject`, but takes a "
"second filename object, for raising errors when a function that takes two "
"filenames fails."
msgstr ""
"Liknar :c:func:`PyErr_SetFromErrnoWithFilenameObject`, men tar ett andra "
"filnamnsobjekt, för att skapa fel när en funktion som tar två filnamn "
"misslyckas."

#: ../../c-api/exceptions.rst:185
msgid ""
"Similar to :c:func:`PyErr_SetFromErrnoWithFilenameObject`, but the filename "
"is given as a C string.  *filename* is decoded from the :term:`filesystem "
"encoding and error handler`."
msgstr ""
"Liknar :c:func:`PyErr_SetFromErrnoWithFilenameObject`, men filnamnet anges "
"som en C-sträng.  *filename* är avkodad från :term:`filsystemets kodning och"
" felhantering`."

#: ../../c-api/exceptions.rst:192
msgid ""
"This is a convenience function to raise :exc:`WindowsError`. If called with "
"*ierr* of ``0``, the error code returned by a call to :c:func:`GetLastError`"
" is used instead.  It calls the Win32 function :c:func:`FormatMessage` to "
"retrieve the Windows description of error code given by *ierr* or "
":c:func:`GetLastError`, then it constructs a tuple object whose first item "
"is the *ierr* value and whose second item is the corresponding error message"
" (gotten from :c:func:`FormatMessage`), and then calls "
"``PyErr_SetObject(PyExc_WindowsError, object)``. This function always "
"returns ``NULL``."
msgstr ""

#: ../../c-api/exceptions.rst:201 ../../c-api/exceptions.rst:209
#: ../../c-api/exceptions.rst:218 ../../c-api/exceptions.rst:226
#: ../../c-api/exceptions.rst:235 ../../c-api/exceptions.rst:244
msgid ":ref:`Availability <availability>`: Windows."
msgstr ""

#: ../../c-api/exceptions.rst:206
msgid ""
"Similar to :c:func:`PyErr_SetFromWindowsErr`, with an additional parameter "
"specifying the exception type to be raised."
msgstr ""
"Liknar :c:func:`PyErr_SetFromWindowsErr`, med en ytterligare parameter som "
"anger vilken typ av undantag som ska tas upp."

#: ../../c-api/exceptions.rst:214
msgid ""
"Similar to :c:func:`PyErr_SetFromWindowsErrWithFilenameObject`, but the "
"filename is given as a C string.  *filename* is decoded from the filesystem "
"encoding (:func:`os.fsdecode`)."
msgstr ""

#: ../../c-api/exceptions.rst:223
msgid ""
"Similar to :c:func:`PyErr_SetFromWindowsErrWithFilenameObject`, with an "
"additional parameter specifying the exception type to be raised."
msgstr ""

#: ../../c-api/exceptions.rst:231
msgid ""
"Similar to :c:func:`PyErr_SetExcFromWindowsErrWithFilenameObject`, but "
"accepts a second filename object."
msgstr ""
"Liknar :c:func:`PyErr_SetExcFromWindowsErrWithFilenameObject`, men "
"accepterar ett andra filnamnsobjekt."

#: ../../c-api/exceptions.rst:241
msgid ""
"Similar to :c:func:`PyErr_SetFromWindowsErrWithFilename`, with an additional"
" parameter specifying the exception type to be raised."
msgstr ""
"Liknar :c:func:`PyErr_SetFromWindowsErrWithFilename`, med en ytterligare "
"parameter som anger vilken typ av undantag som ska tas upp."

#: ../../c-api/exceptions.rst:249
msgid ""
"This is a convenience function to raise :exc:`ImportError`. *msg* will be "
"set as the exception's message string. *name* and *path*, both of which can "
"be ``NULL``, will be set as the :exc:`ImportError`'s respective ``name`` and"
" ``path`` attributes."
msgstr ""
"Detta är en bekvämlighetsfunktion för att skapa :exc:`ImportError`. *msg* "
"kommer att sättas som undantagets meddelandesträng. *name* och *path*, som "
"båda kan vara ``NULL``, kommer att anges som :exc:`ImportError`'s respektive"
" attribut ``name`` och ``path``."

#: ../../c-api/exceptions.rst:259
msgid ""
"Much like :c:func:`PyErr_SetImportError` but this function allows for "
"specifying a subclass of :exc:`ImportError` to raise."
msgstr ""
"Ungefär som :c:func:`PyErr_SetImportError` men den här funktionen gör det "
"möjligt att ange en underklass av :exc:`ImportError` som ska uppstå."

#: ../../c-api/exceptions.rst:267
msgid ""
"Set file, line, and offset information for the current exception.  If the "
"current exception is not a :exc:`SyntaxError`, then it sets additional "
"attributes, which make the exception printing subsystem think the exception "
"is a :exc:`SyntaxError`."
msgstr ""
"Ställer in fil-, rad- och offsetinformation för det aktuella undantaget.  Om"
" det aktuella undantaget inte är ett :exc:`SyntaxError`, anges ytterligare "
"attribut som får subsystemet för utskrift av undantag att tro att undantaget"
" är ett :exc:`SyntaxError`."

#: ../../c-api/exceptions.rst:277
msgid ""
"Like :c:func:`PyErr_SyntaxLocationObject`, but *filename* is a byte string "
"decoded from the :term:`filesystem encoding and error handler`."
msgstr ""
"Som :c:func:`PyErr_SyntaxLocationObject`, men *filnamn* är en byte-sträng "
"avkodad från :term:`filsystemets kodning och felhantering`."

#: ../../c-api/exceptions.rst:285
msgid ""
"Like :c:func:`PyErr_SyntaxLocationEx`, but the *col_offset* parameter is "
"omitted."
msgstr ""
"Som :c:func:`PyErr_SyntaxLocationEx`, men parametern *col_offset* är "
"utelämnad."

#: ../../c-api/exceptions.rst:291
msgid ""
"This is a shorthand for ``PyErr_SetString(PyExc_SystemError, message)``, "
"where *message* indicates that an internal operation (e.g. a Python/C API "
"function) was invoked with an illegal argument.  It is mostly for internal "
"use."
msgstr ""
"Detta är en förkortning för ``PyErr_SetString(PyExc_SystemError, message)``,"
" där *message* indikerar att en intern operation (t.ex. en Python/C API-"
"funktion) anropades med ett olagligt argument.  Den är mestadels för internt"
" bruk."

#: ../../c-api/exceptions.rst:298
msgid "Issuing warnings"
msgstr "Utfärdande av varningar"

#: ../../c-api/exceptions.rst:300
msgid ""
"Use these functions to issue warnings from C code.  They mirror similar "
"functions exported by the Python :mod:`warnings` module.  They normally "
"print a warning message to *sys.stderr*; however, it is also possible that "
"the user has specified that warnings are to be turned into errors, and in "
"that case they will raise an exception.  It is also possible that the "
"functions raise an exception because of a problem with the warning "
"machinery. The return value is ``0`` if no exception is raised, or ``-1`` if"
" an exception is raised.  (It is not possible to determine whether a warning"
" message is actually printed, nor what the reason is for the exception; this"
" is intentional.)  If an exception is raised, the caller should do its "
"normal exception handling (for example, :c:func:`Py_DECREF` owned references"
" and return an error value)."
msgstr ""
"Använd dessa funktioner för att utfärda varningar från C-kod.  De speglar "
"liknande funktioner som exporteras av Python :mod:`warnings`-modulen.  De "
"skriver normalt ut ett varningsmeddelande till *sys.stderr*, men det är "
"också möjligt att användaren har angett att varningar ska omvandlas till "
"fel, och i så fall kommer de att ge upphov till ett undantag.  Det är också "
"möjligt att funktionerna ger upphov till ett undantag på grund av ett "
"problem med varningsmaskineriet. Returvärdet är ``0`` om inget undantag "
"uppstår, eller ``-1`` om ett undantag uppstår.  (Det är inte möjligt att "
"avgöra om ett varningsmeddelande faktiskt skrivs ut eller vad orsaken till "
"undantaget är; detta är avsiktligt)  Om ett undantag uppstår bör anroparen "
"göra sin normala undantagshantering (t.ex. :c:func:`Py_DECREF` äger "
"referenser och returnerar ett felvärde)."

#: ../../c-api/exceptions.rst:315
msgid ""
"Issue a warning message.  The *category* argument is a warning category (see"
" below) or ``NULL``; the *message* argument is a UTF-8 encoded string.  "
"*stack_level* is a positive number giving a number of stack frames; the "
"warning will be issued from the  currently executing line of code in that "
"stack frame.  A *stack_level* of 1 is the function calling "
":c:func:`PyErr_WarnEx`, 2 is  the function above that, and so forth."
msgstr ""
"Utfärdar ett varningsmeddelande.  Argumentet *category* är en "
"varningskategori (se nedan) eller ``NULL``; argumentet *message* är en "
"UTF-8-kodad sträng.  *stack_level* är ett positivt tal som anger ett antal "
"stackrutor; varningen kommer att utfärdas från den kodrad som för närvarande"
" körs i den stackrutan.  En *stack_level* på 1 är den funktion som anropar "
":c:func:`PyErr_WarnEx`, 2 är funktionen ovanför den, och så vidare."

#: ../../c-api/exceptions.rst:322
msgid ""
"Warning categories must be subclasses of :c:data:`PyExc_Warning`; "
":c:data:`PyExc_Warning` is a subclass of :c:data:`PyExc_Exception`; the "
"default warning category is :c:data:`PyExc_RuntimeWarning`. The standard "
"Python warning categories are available as global variables whose names are "
"enumerated at :ref:`standardwarningcategories`."
msgstr ""
"Varningskategorier måste vara subklasser av :c:data:`PyExc_Warning`; "
":c:data:`PyExc_Warning` är en subklass av :c:data:`PyExc_Exception`; "
"standardvarningskategorin är :c:data:`PyExc_RuntimeWarning`. Pythons "
"standardvarningskategorier finns tillgängliga som globala variabler vars "
"namn räknas upp på :ref:`standardwarningcategories`."

#: ../../c-api/exceptions.rst:328
msgid ""
"For information about warning control, see the documentation for the "
":mod:`warnings` module and the :option:`-W` option in the command line "
"documentation.  There is no C API for warning control."
msgstr ""
"Mer information om varningskontroll finns i dokumentationen för modulen "
":mod:`warnings` och alternativet :option:`-W` i kommandoradsdokumentationen."
"  Det finns inget C API för varningskontroll."

#: ../../c-api/exceptions.rst:335
msgid ""
"Issue a warning message with explicit control over all warning attributes.  "
"This is a straightforward wrapper around the Python function "
":func:`warnings.warn_explicit`; see there for more information.  The "
"*module* and *registry* arguments may be set to ``NULL`` to get the default "
"effect described there."
msgstr ""
"Utfärda ett varningsmeddelande med explicit kontroll över alla "
"varningsattribut.  Detta är en enkel omslutning av Python-funktionen "
":func:`warnings.warn_explicit`; se där för mer information.  Argumenten "
"*module* och *registry* kan sättas till ``NULL`` för att få den förvalda "
"effekten som beskrivs där."

#: ../../c-api/exceptions.rst:346
msgid ""
"Similar to :c:func:`PyErr_WarnExplicitObject` except that *message* and "
"*module* are UTF-8 encoded strings, and *filename* is decoded from the "
":term:`filesystem encoding and error handler`."
msgstr ""
"Liknar :c:func:`PyErr_WarnExplicitObject` förutom att *message* och *module*"
" är UTF-8-kodade strängar och *filename* är avkodad från :term:`filsystemets"
" kodning och felhantering`."

#: ../../c-api/exceptions.rst:353
msgid ""
"Function similar to :c:func:`PyErr_WarnEx`, but use "
":c:func:`PyUnicode_FromFormat` to format the warning message.  *format* is "
"an ASCII-encoded string."
msgstr ""
"Funktion liknande :c:func:`PyErr_WarnEx`, men använd "
":c:func:`PyUnicode_FromFormat` för att formatera varningsmeddelandet.  "
"*format* är en ASCII-kodad sträng."

#: ../../c-api/exceptions.rst:362
msgid ""
"Function similar to :c:func:`PyErr_WarnFormat`, but *category* is "
":exc:`ResourceWarning` and it passes *source* to "
":func:`warnings.WarningMessage`."
msgstr ""

#: ../../c-api/exceptions.rst:369
msgid "Querying the error indicator"
msgstr "Fråga efter felindikatorn"

#: ../../c-api/exceptions.rst:373
msgid ""
"Test whether the error indicator is set.  If set, return the exception "
"*type* (the first argument to the last call to one of the ``PyErr_Set*`` "
"functions or to :c:func:`PyErr_Restore`).  If not set, return ``NULL``.  You"
" do not own a reference to the return value, so you do not need to "
":c:func:`Py_DECREF` it."
msgstr ""
"Testar om felindikatorn är inställd.  Om den är inställd, returneras "
"undantagets *typ* (det första argumentet till det senaste anropet till en av"
" funktionerna ``PyErr_Set*`` eller till :c:func:`PyErr_Restore``).  Om den "
"inte är inställd returneras ``NULL``.  Du äger inte en referens till "
"returvärdet, så du behöver inte :c:func:`Py_DECREF` det."

#: ../../c-api/exceptions.rst:379
msgid "The caller must hold the GIL."
msgstr ""

#: ../../c-api/exceptions.rst:383
msgid ""
"Do not compare the return value to a specific exception; use "
":c:func:`PyErr_ExceptionMatches` instead, shown below.  (The comparison "
"could easily fail since the exception may be an instance instead of a class,"
" in the case of a class exception, or it may be a subclass of the expected "
"exception.)"
msgstr ""
"Jämför inte returvärdet med ett specifikt undantag; använd istället "
":c:func:`PyErr_ExceptionMatches`, som visas nedan.  (Jämförelsen kan lätt "
"misslyckas eftersom undantaget kan vara en instans i stället för en klass, i"
" fallet med ett klassundantag, eller det kan vara en underklass av det "
"förväntade undantaget)"

#: ../../c-api/exceptions.rst:391
msgid ""
"Equivalent to ``PyErr_GivenExceptionMatches(PyErr_Occurred(), exc)``.  This "
"should only be called when an exception is actually set; a memory access "
"violation will occur if no exception has been raised."
msgstr ""
"Motsvarar ``PyErr_GivenExceptionMatches(PyErr_Occurred(), exc)``.  Detta bör"
" endast anropas när ett undantag faktiskt har ställts in; en "
"minnesåtkomstöverträdelse kommer att inträffa om inget undantag har ställts "
"in."

#: ../../c-api/exceptions.rst:398
msgid ""
"Return true if the *given* exception matches the exception type in *exc*.  "
"If *exc* is a class object, this also returns true when *given* is an "
"instance of a subclass.  If *exc* is a tuple, all exception types in the "
"tuple (and recursively in subtuples) are searched for a match."
msgstr ""
"Returnerar true om det *givna* undantaget matchar undantagstypen i *exc*.  "
"Om *exc* är ett klassobjekt returneras även true när *given* är en instans "
"av en underklass.  Om *exc* är en tupel, söks alla undantagstyper i tupeln "
"(och rekursivt i subtuplar) efter en matchning."

#: ../../c-api/exceptions.rst:406
msgid ""
"Retrieve the error indicator into three variables whose addresses are "
"passed. If the error indicator is not set, set all three variables to "
"``NULL``.  If it is set, it will be cleared and you own a reference to each "
"object retrieved.  The value and traceback object may be ``NULL`` even when "
"the type object is not."
msgstr ""
"Hämta felindikatorn till tre variabler vars adresser skickas. Om "
"felindikatorn inte är inställd, ställ in alla tre variablerna till ``NULL``."
"  Om den är inställd kommer den att rensas och du äger en referens till "
"varje objekt som hämtas.  Värde- och spårningsobjektet kan vara ``NULL`` "
"även om typobjektet inte är det."

#: ../../c-api/exceptions.rst:413
msgid ""
"This function is normally only used by code that needs to catch exceptions "
"or by code that needs to save and restore the error indicator temporarily, "
"e.g.::"
msgstr ""

#: ../../c-api/exceptions.rst:428
msgid ""
"Set  the error indicator from the three objects.  If the error indicator is "
"already set, it is cleared first.  If the objects are ``NULL``, the error "
"indicator is cleared.  Do not pass a ``NULL`` type and non-``NULL`` value or"
" traceback.  The exception type should be a class.  Do not pass an invalid "
"exception type or value. (Violating these rules will cause subtle problems "
"later.)  This call takes away a reference to each object: you must own a "
"reference to each object before the call and after the call you no longer "
"own these references.  (If you don't understand this, don't use this "
"function.  I warned you.)"
msgstr ""

#: ../../c-api/exceptions.rst:440
msgid ""
"This function is normally only used by code that needs to save and restore "
"the error indicator temporarily.  Use :c:func:`PyErr_Fetch` to save the "
"current error indicator."
msgstr ""

#: ../../c-api/exceptions.rst:447
msgid ""
"Under certain circumstances, the values returned by :c:func:`PyErr_Fetch` "
"below can be \"unnormalized\", meaning that ``*exc`` is a class object but "
"``*val`` is not an instance of the  same class.  This function can be used "
"to instantiate the class in that case.  If the values are already "
"normalized, nothing happens. The delayed normalization is implemented to "
"improve performance."
msgstr ""
"Under vissa omständigheter kan värdena som returneras av "
":c:func:`PyErr_Fetch` nedan vara \"onormaliserade\", vilket innebär att "
"``*exc`` är ett klassobjekt men ``*val`` inte är en instans av samma klass."
"  Denna funktion kan användas för att instansiera klassen i det fallet.  Om "
"värdena redan är normaliserade händer ingenting. Den fördröjda "
"normaliseringen är implementerad för att förbättra prestandan."

#: ../../c-api/exceptions.rst:455
msgid ""
"This function *does not* implicitly set the ``__traceback__`` attribute on "
"the exception value. If setting the traceback appropriately is desired, the "
"following additional snippet is needed::"
msgstr ""

#: ../../c-api/exceptions.rst:466
msgid ""
"Retrieve the exception info, as known from ``sys.exc_info()``.  This refers "
"to an exception that was *already caught*, not to an exception that was "
"freshly raised.  Returns new references for the three objects, any of which "
"may be ``NULL``.  Does not modify the exception info state."
msgstr ""

#: ../../c-api/exceptions.rst:473
msgid ""
"This function is not normally used by code that wants to handle exceptions. "
"Rather, it can be used when code needs to save and restore the exception "
"state temporarily.  Use :c:func:`PyErr_SetExcInfo` to restore or clear the "
"exception state."
msgstr ""
"Denna funktion används normalt inte av kod som vill hantera undantag. "
"Istället kan den användas när koden behöver spara och återställa "
"undantagstillståndet tillfälligt.  Använd :c:func:`PyErr_SetExcInfo` för att"
" återställa eller rensa undantagstillståndet."

#: ../../c-api/exceptions.rst:483
msgid ""
"Set the exception info, as known from ``sys.exc_info()``.  This refers to an"
" exception that was *already caught*, not to an exception that was freshly "
"raised.  This function steals the references of the arguments. To clear the "
"exception state, pass ``NULL`` for all three arguments. For general rules "
"about the three arguments, see :c:func:`PyErr_Restore`."
msgstr ""

#: ../../c-api/exceptions.rst:491
msgid ""
"This function is not normally used by code that wants to handle exceptions. "
"Rather, it can be used when code needs to save and restore the exception "
"state temporarily.  Use :c:func:`PyErr_GetExcInfo` to read the exception "
"state."
msgstr ""
"Denna funktion används normalt inte av kod som vill hantera undantag. "
"Istället kan den användas när koden behöver spara och återställa "
"undantagstillståndet tillfälligt.  Använd :c:func:`PyErr_GetExcInfo` för att"
" läsa undantagstillståndet."

#: ../../c-api/exceptions.rst:500
msgid "Signal Handling"
msgstr "Signalhantering"

#: ../../c-api/exceptions.rst:510
msgid "This function interacts with Python's signal handling."
msgstr "Denna funktion interagerar med Pythons signalhantering."

#: ../../c-api/exceptions.rst:512
msgid ""
"If the function is called from the main thread and under the main Python "
"interpreter, it checks whether a signal has been sent to the processes and "
"if so, invokes the corresponding signal handler.  If the :mod:`signal` "
"module is supported, this can invoke a signal handler written in Python."
msgstr ""
"Om funktionen anropas från huvudtråden och under Pythons huvudtolk, "
"kontrollerar den om en signal har skickats till processerna och anropar i så"
" fall motsvarande signalhanterare.  Om modulen :mod:`signal` stöds kan den "
"anropa en signalhanterare som är skriven i Python."

#: ../../c-api/exceptions.rst:517
msgid ""
"The function attempts to handle all pending signals, and then returns ``0``."
" However, if a Python signal handler raises an exception, the error "
"indicator is set and the function returns ``-1`` immediately (such that "
"other pending signals may not have been handled yet: they will be on the "
"next :c:func:`PyErr_CheckSignals()` invocation)."
msgstr ""
"Funktionen försöker hantera alla väntande signaler och returnerar sedan "
"``0``. Men om en Python-signalhanterare ger upphov till ett undantag, sätts "
"felindikatorn och funktionen returnerar ``-1`` omedelbart (så att andra "
"väntande signaler kanske inte har hanterats ännu: de kommer att hanteras vid"
" nästa :c:func:`PyErr_CheckSignals()`-inkallning)."

#: ../../c-api/exceptions.rst:523
msgid ""
"If the function is called from a non-main thread, or under a non-main Python"
" interpreter, it does nothing and returns ``0``."
msgstr ""
"Om funktionen anropas från en tråd som inte är huvudtråd, eller under en "
"Python-tolk som inte är huvudtråd, gör den ingenting och returnerar ``0``."

#: ../../c-api/exceptions.rst:526
msgid ""
"This function can be called by long-running C code that wants to be "
"interruptible by user requests (such as by pressing Ctrl-C)."
msgstr ""
"Den här funktionen kan anropas av C-kod som körs under lång tid och som vill"
" kunna avbrytas av användaren (t.ex. genom att trycka på Ctrl-C)."

#: ../../c-api/exceptions.rst:530
msgid ""
"The default Python signal handler for :const:`SIGINT` raises the "
":exc:`KeyboardInterrupt` exception."
msgstr ""

#: ../../c-api/exceptions.rst:541
msgid ""
"Simulate the effect of a :const:`SIGINT` signal arriving. This is equivalent"
" to ``PyErr_SetInterruptEx(SIGINT)``."
msgstr ""

#: ../../c-api/exceptions.rst:545 ../../c-api/exceptions.rst:572
msgid ""
"This function is async-signal-safe.  It can be called without the "
":term:`GIL` and from a C signal handler."
msgstr ""

#: ../../c-api/exceptions.rst:555
msgid ""
"Simulate the effect of a signal arriving. The next time "
":c:func:`PyErr_CheckSignals` is called,  the Python signal handler for the "
"given signal number will be called."
msgstr ""
"Simulerar effekten av att en signal anländer. Nästa gång "
":c:func:`PyErr_CheckSignals` anropas, kommer Python-signalhanteraren för det"
" angivna signalnumret att anropas."

#: ../../c-api/exceptions.rst:559
msgid ""
"This function can be called by C code that sets up its own signal handling "
"and wants Python signal handlers to be invoked as expected when an "
"interruption is requested (for example when the user presses Ctrl-C to "
"interrupt an operation)."
msgstr ""
"Denna funktion kan anropas av C-kod som ställer in sin egen signalhantering "
"och vill att Pythons signalhanterare ska anropas som förväntat när ett "
"avbrott begärs (t.ex. när användaren trycker på Ctrl-C för att avbryta en "
"operation)."

#: ../../c-api/exceptions.rst:564
msgid ""
"If the given signal isn't handled by Python (it was set to "
":data:`signal.SIG_DFL` or :data:`signal.SIG_IGN`), it will be ignored."
msgstr ""

#: ../../c-api/exceptions.rst:567
msgid ""
"If *signum* is outside of the allowed range of signal numbers, ``-1`` is "
"returned.  Otherwise, ``0`` is returned.  The error indicator is never "
"changed by this function."
msgstr ""
"Om *signum* ligger utanför det tillåtna intervallet för signalnummer, "
"returneras ``-1``.  I annat fall returneras ``0``.  Felindikatorn ändras "
"aldrig av denna funktion."

#: ../../c-api/exceptions.rst:580
msgid ""
"This utility function specifies a file descriptor to which the signal number"
" is written as a single byte whenever a signal is received. *fd* must be "
"non-blocking. It returns the previous such file descriptor."
msgstr ""
"Denna utility-funktion specificerar en filbeskrivare till vilken "
"signalnumret skrivs som en enda byte när en signal tas emot. *fd* måste vara"
" icke-blockerande. Den returnerar den föregående sådana fildescriptorn."

#: ../../c-api/exceptions.rst:584
msgid ""
"The value ``-1`` disables the feature; this is the initial state. This is "
"equivalent to :func:`signal.set_wakeup_fd` in Python, but without any error "
"checking.  *fd* should be a valid file descriptor.  The function should only"
" be called from the main thread."
msgstr ""
"Värdet ``-1`` inaktiverar funktionen; detta är det initiala tillståndet. "
"Detta är likvärdigt med :func:`signal.set_wakeup_fd` i Python, men utan "
"någon felkontroll.  *fd* bör vara en giltig filbeskrivare.  Funktionen bör "
"endast anropas från huvudtråden."

#: ../../c-api/exceptions.rst:589
msgid "On Windows, the function now also supports socket handles."
msgstr "I Windows stöder funktionen nu även socket-handtag."

#: ../../c-api/exceptions.rst:594
msgid "Exception Classes"
msgstr "Undantagsklasser"

#: ../../c-api/exceptions.rst:598
msgid ""
"This utility function creates and returns a new exception class. The *name* "
"argument must be the name of the new exception, a C string of the form "
"``module.classname``.  The *base* and *dict* arguments are normally "
"``NULL``. This creates a class object derived from :exc:`Exception` "
"(accessible in C as :c:data:`PyExc_Exception`)."
msgstr ""
"Denna verktygsfunktion skapar och returnerar en ny undantagsklass. "
"Argumentet *name* måste vara namnet på det nya undantaget, en C-sträng av "
"formen ``module.classname``.  Argumenten *base* och *dict* är normalt "
"``NULL``. Detta skapar ett klassobjekt som härrör från :exc:`Exception` "
"(tillgängligt i C som :c:data:`PyExc_Exception`)."

#: ../../c-api/exceptions.rst:604
msgid ""
"The :attr:`__module__` attribute of the new class is set to the first part "
"(up to the last dot) of the *name* argument, and the class name is set to "
"the last part (after the last dot).  The *base* argument can be used to "
"specify alternate base classes; it can either be only one class or a tuple "
"of classes. The *dict* argument can be used to specify a dictionary of class"
" variables and methods."
msgstr ""

#: ../../c-api/exceptions.rst:613
msgid ""
"Same as :c:func:`PyErr_NewException`, except that the new exception class "
"can easily be given a docstring: If *doc* is non-``NULL``, it will be used "
"as the docstring for the exception class."
msgstr ""
"Samma som :c:func:`PyErr_NewException`, förutom att den nya undantagsklassen"
" enkelt kan ges en docstring: Om *doc* är icke-``NULL``, kommer den att "
"användas som dokumentsträng för undantagsklassen."

#: ../../c-api/exceptions.rst:621
msgid "Exception Objects"
msgstr "Objekt för undantag"

#: ../../c-api/exceptions.rst:625
msgid ""
"Return the traceback associated with the exception as a new reference, as "
"accessible from Python through :attr:`__traceback__`.  If there is no "
"traceback associated, this returns ``NULL``."
msgstr ""

#: ../../c-api/exceptions.rst:632
msgid ""
"Set the traceback associated with the exception to *tb*.  Use ``Py_None`` to"
" clear it."
msgstr ""
"Ställ in den traceback som är kopplad till undantaget till *tb*.  Använd "
"``Py_None`` för att rensa det."

#: ../../c-api/exceptions.rst:638
msgid ""
"Return the context (another exception instance during whose handling *ex* "
"was raised) associated with the exception as a new reference, as accessible "
"from Python through :attr:`__context__`.  If there is no context associated,"
" this returns ``NULL``."
msgstr ""

#: ../../c-api/exceptions.rst:646
msgid ""
"Set the context associated with the exception to *ctx*.  Use ``NULL`` to "
"clear it.  There is no type check to make sure that *ctx* is an exception "
"instance. This steals a reference to *ctx*."
msgstr ""
"Ställ in kontexten som är associerad med undantaget till *ctx*.  Använd "
"``NULL`` för att rensa den.  Det finns ingen typkontroll för att se till att"
" *ctx* är en undantagsinstans. Detta stjäl en referens till *ctx*."

#: ../../c-api/exceptions.rst:653
msgid ""
"Return the cause (either an exception instance, or :const:`None`, set by "
"``raise ... from ...``) associated with the exception as a new reference, as"
" accessible from Python through :attr:`__cause__`."
msgstr ""

#: ../../c-api/exceptions.rst:660
msgid ""
"Set the cause associated with the exception to *cause*.  Use ``NULL`` to "
"clear it.  There is no type check to make sure that *cause* is either an "
"exception instance or :const:`None`.  This steals a reference to *cause*."
msgstr ""

#: ../../c-api/exceptions.rst:664
msgid ""
":attr:`__suppress_context__` is implicitly set to ``True`` by this function."
msgstr ""

#: ../../c-api/exceptions.rst:670
msgid "Unicode Exception Objects"
msgstr "Objekt för Unicode-undantag"

#: ../../c-api/exceptions.rst:672
msgid ""
"The following functions are used to create and modify Unicode exceptions "
"from C."
msgstr ""
"Följande funktioner används för att skapa och modifiera Unicode-undantag "
"från C."

#: ../../c-api/exceptions.rst:676
msgid ""
"Create a :class:`UnicodeDecodeError` object with the attributes *encoding*, "
"*object*, *length*, *start*, *end* and *reason*. *encoding* and *reason* are"
" UTF-8 encoded strings."
msgstr ""
"Skapa ett :class:`UnicodeDecodeError`-objekt med attributen *encoding*, "
"*object*, *length*, *start*, *end* och *reason*. *encoding* och *reason* är "
"UTF-8-kodade strängar."

#: ../../c-api/exceptions.rst:682
msgid ""
"Create a :class:`UnicodeEncodeError` object with the attributes *encoding*, "
"*object*, *length*, *start*, *end* and *reason*. *encoding* and *reason* are"
" UTF-8 encoded strings."
msgstr ""

#: ../../c-api/exceptions.rst:686 ../../c-api/exceptions.rst:696
msgid "3.11"
msgstr "3.11"

#: ../../c-api/exceptions.rst:688
msgid ""
"``Py_UNICODE`` is deprecated since Python 3.3. Please migrate to "
"``PyObject_CallFunction(PyExc_UnicodeEncodeError, \"sOnns\", ...)``."
msgstr ""

#: ../../c-api/exceptions.rst:693
msgid ""
"Create a :class:`UnicodeTranslateError` object with the attributes *object*,"
" *length*, *start*, *end* and *reason*. *reason* is a UTF-8 encoded string."
msgstr ""

#: ../../c-api/exceptions.rst:698
msgid ""
"``Py_UNICODE`` is deprecated since Python 3.3. Please migrate to "
"``PyObject_CallFunction(PyExc_UnicodeTranslateError, \"Onns\", ...)``."
msgstr ""

#: ../../c-api/exceptions.rst:704
msgid "Return the *encoding* attribute of the given exception object."
msgstr "Returnerar *encoding*-attributet för det angivna undantagsobjektet."

#: ../../c-api/exceptions.rst:710
msgid "Return the *object* attribute of the given exception object."
msgstr "Returnerar *object*-attributet för det angivna undantagsobjektet."

#: ../../c-api/exceptions.rst:716
msgid ""
"Get the *start* attribute of the given exception object and place it into "
"*\\*start*.  *start* must not be ``NULL``.  Return ``0`` on success, ``-1`` "
"on failure."
msgstr ""
"Hämta *start*-attributet för det angivna undantagsobjektet och placera det i"
" *\\*start*.  *start* får inte vara ``NULL``.  Returnerar ``0`` vid "
"framgång, ``-1`` vid misslyckande."

#: ../../c-api/exceptions.rst:724
msgid ""
"Set the *start* attribute of the given exception object to *start*.  Return "
"``0`` on success, ``-1`` on failure."
msgstr ""

#: ../../c-api/exceptions.rst:731
msgid ""
"Get the *end* attribute of the given exception object and place it into "
"*\\*end*.  *end* must not be ``NULL``.  Return ``0`` on success, ``-1`` on "
"failure."
msgstr ""
"Hämta *end*-attributet för det angivna undantagsobjektet och placera det i "
"*\\*end*.  *end* får inte vara ``NULL``.  Returnerar ``0`` vid framgång, "
"``-1`` vid misslyckande."

#: ../../c-api/exceptions.rst:739
msgid ""
"Set the *end* attribute of the given exception object to *end*.  Return "
"``0`` on success, ``-1`` on failure."
msgstr ""
"Sätter attributet *end* för det angivna undantagsobjektet till *end*.  "
"Returnerar ``0`` vid framgång, ``-1`` vid misslyckande."

#: ../../c-api/exceptions.rst:746
msgid "Return the *reason* attribute of the given exception object."
msgstr "Returnerar attributet *reason* för det angivna undantagsobjektet."

#: ../../c-api/exceptions.rst:752
msgid ""
"Set the *reason* attribute of the given exception object to *reason*.  "
"Return ``0`` on success, ``-1`` on failure."
msgstr ""
"Sätter attributet *reason* för det angivna undantagsobjektet till *reason*."
"  Returnerar ``0`` vid framgång, ``-1`` vid misslyckande."

#: ../../c-api/exceptions.rst:759
msgid "Recursion Control"
msgstr "Kontroll av rekursion"

#: ../../c-api/exceptions.rst:761
msgid ""
"These two functions provide a way to perform safe recursive calls at the C "
"level, both in the core and in extension modules.  They are needed if the "
"recursive code does not necessarily invoke Python code (which tracks its "
"recursion depth automatically). They are also not needed for *tp_call* "
"implementations because the :ref:`call protocol <call>` takes care of "
"recursion handling."
msgstr ""
"Dessa två funktioner gör det möjligt att utföra säkra rekursiva anrop på "
"C-nivå, både i kärnan och i tilläggsmoduler.  De behövs om den rekursiva "
"koden inte nödvändigtvis anropar Python-kod (som spårar sitt rekursionsdjup "
"automatiskt). De behövs inte heller för *tp_call*-implementeringar eftersom "
":ref:`call protocol <call>` tar hand om rekursionshanteringen."

#: ../../c-api/exceptions.rst:770
msgid "Marks a point where a recursive C-level call is about to be performed."
msgstr ""
"Markerar en punkt där ett rekursivt anrop på C-nivå är på väg att utföras."

#: ../../c-api/exceptions.rst:772
msgid ""
"If :const:`USE_STACKCHECK` is defined, this function checks if the OS stack "
"overflowed using :c:func:`PyOS_CheckStack`.  In this is the case, it sets a "
":exc:`MemoryError` and returns a nonzero value."
msgstr ""

#: ../../c-api/exceptions.rst:776
msgid ""
"The function then checks if the recursion limit is reached.  If this is the "
"case, a :exc:`RecursionError` is set and a nonzero value is returned. "
"Otherwise, zero is returned."
msgstr ""

#: ../../c-api/exceptions.rst:780
msgid ""
"*where* should be a UTF-8 encoded string such as ``\" in instance check\"`` "
"to be concatenated to the :exc:`RecursionError` message caused by the "
"recursion depth limit."
msgstr ""
"*där* ska vara en UTF-8-kodad sträng som ``\" in instance check\"`` som ska "
"konkateneras till meddelandet :exc:`RecursionError` som orsakas av gränsen "
"för rekursionsdjup."

#: ../../c-api/exceptions.rst:784 ../../c-api/exceptions.rst:792
msgid "This function is now also available in the limited API."
msgstr ""

#: ../../c-api/exceptions.rst:789
msgid ""
"Ends a :c:func:`Py_EnterRecursiveCall`.  Must be called once for each "
"*successful* invocation of :c:func:`Py_EnterRecursiveCall`."
msgstr ""
"Avslutar en :c:func:`Py_EnterRecursiveCall`.  Måste anropas en gång för "
"varje *lyckad* anrop av :c:func:`Py_EnterRecursiveCall`."

#: ../../c-api/exceptions.rst:795
msgid ""
"Properly implementing :c:member:`~PyTypeObject.tp_repr` for container types "
"requires special recursion handling.  In addition to protecting the stack, "
":c:member:`~PyTypeObject.tp_repr` also needs to track objects to prevent "
"cycles.  The following two functions facilitate this functionality.  "
"Effectively, these are the C equivalent to :func:`reprlib.recursive_repr`."
msgstr ""
"Korrekt implementering av :c:member:`~PyTypeObject.tp_repr` för "
"containertyper kräver speciell rekursionshantering.  Förutom att skydda "
"stacken måste :c:member:`~PyTypeObject.tp_repr` också spåra objekt för att "
"förhindra cykler.  Följande två funktioner underlättar denna funktionalitet."
"  I praktiken är dessa C-motsvarigheten till :func:`reprlib.recursive_repr`."

#: ../../c-api/exceptions.rst:803
msgid ""
"Called at the beginning of the :c:member:`~PyTypeObject.tp_repr` "
"implementation to detect cycles."
msgstr ""
"Anropas i början av :c:member:`~PyTypeObject.tp_repr`-implementeringen för "
"att upptäcka cykler."

#: ../../c-api/exceptions.rst:806
msgid ""
"If the object has already been processed, the function returns a positive "
"integer.  In that case the :c:member:`~PyTypeObject.tp_repr` implementation "
"should return a string object indicating a cycle.  As examples, "
":class:`dict` objects return ``{...}`` and :class:`list` objects return "
"``[...]``."
msgstr ""
"Om objektet redan har bearbetats returnerar funktionen ett positivt heltal."
"  I så fall bör :c:member:`~PyTypeObject.tp_repr`-implementeringen returnera"
" ett strängobjekt som indikerar en cykel.  Som exempel kan nämnas att "
":class:`dict`-objekt returnerar ``{...}`` och :class:`list`-objekt "
"returnerar ``[...]``."

#: ../../c-api/exceptions.rst:812
msgid ""
"The function will return a negative integer if the recursion limit is "
"reached.  In that case the :c:member:`~PyTypeObject.tp_repr` implementation "
"should typically return ``NULL``."
msgstr ""
"Funktionen returnerar ett negativt heltal om rekursionsgränsen är nådd.  I "
"så fall bör implementeringen :c:member:`~PyTypeObject.tp_repr` typiskt "
"returnera ``NULL``."

#: ../../c-api/exceptions.rst:816
msgid ""
"Otherwise, the function returns zero and the "
":c:member:`~PyTypeObject.tp_repr` implementation can continue normally."
msgstr ""
"I annat fall returnerar funktionen noll och "
":c:member:`~PyTypeObject.tp_repr`-implementeringen kan fortsätta normalt."

#: ../../c-api/exceptions.rst:821
msgid ""
"Ends a :c:func:`Py_ReprEnter`.  Must be called once for each invocation of "
":c:func:`Py_ReprEnter` that returns zero."
msgstr ""
"Avslutar en :c:func:`Py_ReprEnter`.  Måste anropas en gång för varje anrop "
"av :c:func:`Py_ReprEnter` som returnerar noll."

#: ../../c-api/exceptions.rst:828
msgid "Standard Exceptions"
msgstr ""

#: ../../c-api/exceptions.rst:830
msgid ""
"All standard Python exceptions are available as global variables whose names"
" are ``PyExc_`` followed by the Python exception name.  These have the type "
":c:expr:`PyObject*`; they are all class objects.  For completeness, here are"
" all the variables:"
msgstr ""

#: ../../c-api/exceptions.rst:891 ../../c-api/exceptions.rst:1024
#: ../../c-api/exceptions.rst:1069
msgid "C Name"
msgstr ""

#: ../../c-api/exceptions.rst:891 ../../c-api/exceptions.rst:1069
msgid "Python Name"
msgstr ""

#: ../../c-api/exceptions.rst:891 ../../c-api/exceptions.rst:1024
#: ../../c-api/exceptions.rst:1069
msgid "Notes"
msgstr "Anteckningar"

#: ../../c-api/exceptions.rst:893
msgid ":c:data:`PyExc_BaseException`"
msgstr ""

#: ../../c-api/exceptions.rst:893
msgid ":exc:`BaseException`"
msgstr ":exc:`BaseException`"

#: ../../c-api/exceptions.rst:893 ../../c-api/exceptions.rst:895
#: ../../c-api/exceptions.rst:897 ../../c-api/exceptions.rst:943
#: ../../c-api/exceptions.rst:955
msgid "[1]_"
msgstr "[1]_"

#: ../../c-api/exceptions.rst:895
msgid ":c:data:`PyExc_Exception`"
msgstr ""

#: ../../c-api/exceptions.rst:895
msgid ":exc:`Exception`"
msgstr ":exc:`Untantagande`"

#: ../../c-api/exceptions.rst:897
msgid ":c:data:`PyExc_ArithmeticError`"
msgstr ""

#: ../../c-api/exceptions.rst:897
msgid ":exc:`ArithmeticError`"
msgstr ":exc:`Aritmetiskt fel`"

#: ../../c-api/exceptions.rst:899
msgid ":c:data:`PyExc_AssertionError`"
msgstr ""

#: ../../c-api/exceptions.rst:899
msgid ":exc:`AssertionError`"
msgstr ":exc:`AssertionError`"

#: ../../c-api/exceptions.rst:901
msgid ":c:data:`PyExc_AttributeError`"
msgstr ""

#: ../../c-api/exceptions.rst:901
msgid ":exc:`AttributeError`"
msgstr ":exc:`AttributeError`"

#: ../../c-api/exceptions.rst:903
msgid ":c:data:`PyExc_BlockingIOError`"
msgstr ""

#: ../../c-api/exceptions.rst:903
msgid ":exc:`BlockingIOError`"
msgstr ":exc:`BlockingIOError`"

#: ../../c-api/exceptions.rst:905
msgid ":c:data:`PyExc_BrokenPipeError`"
msgstr ""

#: ../../c-api/exceptions.rst:905
msgid ":exc:`BrokenPipeError`"
msgstr ":exc:`BrokenPipeError`"

#: ../../c-api/exceptions.rst:907
msgid ":c:data:`PyExc_BufferError`"
msgstr ""

#: ../../c-api/exceptions.rst:907
msgid ":exc:`BufferError`"
msgstr ":exc:`BufferError`"

#: ../../c-api/exceptions.rst:909
msgid ":c:data:`PyExc_ChildProcessError`"
msgstr ""

#: ../../c-api/exceptions.rst:909
msgid ":exc:`ChildProcessError`"
msgstr ":exc:`ChildProcessError`"

#: ../../c-api/exceptions.rst:911
msgid ":c:data:`PyExc_ConnectionAbortedError`"
msgstr ""

#: ../../c-api/exceptions.rst:911
msgid ":exc:`ConnectionAbortedError`"
msgstr ":exc:`Fel vid avbruten anslutning`"

#: ../../c-api/exceptions.rst:913
msgid ":c:data:`PyExc_ConnectionError`"
msgstr ""

#: ../../c-api/exceptions.rst:913
msgid ":exc:`ConnectionError`"
msgstr ":exc:`AnslutningFel`"

#: ../../c-api/exceptions.rst:915
msgid ":c:data:`PyExc_ConnectionRefusedError`"
msgstr ""

#: ../../c-api/exceptions.rst:915
msgid ":exc:`ConnectionRefusedError`"
msgstr ":exc:`AnslutningRefusedError`"

#: ../../c-api/exceptions.rst:917
msgid ":c:data:`PyExc_ConnectionResetError`"
msgstr ""

#: ../../c-api/exceptions.rst:917
msgid ":exc:`ConnectionResetError`"
msgstr ":exc:`Fel vid återställning av anslutning`"

#: ../../c-api/exceptions.rst:919
msgid ":c:data:`PyExc_EOFError`"
msgstr ""

#: ../../c-api/exceptions.rst:919
msgid ":exc:`EOFError`"
msgstr ":exc:`EOFError`"

#: ../../c-api/exceptions.rst:921
msgid ":c:data:`PyExc_FileExistsError`"
msgstr ""

#: ../../c-api/exceptions.rst:921
msgid ":exc:`FileExistsError`"
msgstr ":exc:`FileExistsError`"

#: ../../c-api/exceptions.rst:923
msgid ":c:data:`PyExc_FileNotFoundError`"
msgstr ""

#: ../../c-api/exceptions.rst:923
msgid ":exc:`FileNotFoundError`"
msgstr ":exc:`FileNotFoundError`"

#: ../../c-api/exceptions.rst:925
msgid ":c:data:`PyExc_FloatingPointError`"
msgstr ""

#: ../../c-api/exceptions.rst:925
msgid ":exc:`FloatingPointError`"
msgstr ":exc:`FloatingPointError`"

#: ../../c-api/exceptions.rst:927
msgid ":c:data:`PyExc_GeneratorExit`"
msgstr ""

#: ../../c-api/exceptions.rst:927
msgid ":exc:`GeneratorExit`"
msgstr ":exc:`GeneratorExit`"

#: ../../c-api/exceptions.rst:929
msgid ":c:data:`PyExc_ImportError`"
msgstr ""

#: ../../c-api/exceptions.rst:929
msgid ":exc:`ImportError`"
msgstr ":exc:`ImportError`"

#: ../../c-api/exceptions.rst:931
msgid ":c:data:`PyExc_IndentationError`"
msgstr ""

#: ../../c-api/exceptions.rst:931
msgid ":exc:`IndentationError`"
msgstr ":exc:`IndentationError`"

#: ../../c-api/exceptions.rst:933
msgid ":c:data:`PyExc_IndexError`"
msgstr ""

#: ../../c-api/exceptions.rst:933
msgid ":exc:`IndexError`"
msgstr ":exc:`IndexError`"

#: ../../c-api/exceptions.rst:935
msgid ":c:data:`PyExc_InterruptedError`"
msgstr ""

#: ../../c-api/exceptions.rst:935
msgid ":exc:`InterruptedError`"
msgstr ":exc:`AvbrutetFel`"

#: ../../c-api/exceptions.rst:937
msgid ":c:data:`PyExc_IsADirectoryError`"
msgstr ""

#: ../../c-api/exceptions.rst:937
msgid ":exc:`IsADirectoryError`"
msgstr ":exc:`IsADirectoryError`"

#: ../../c-api/exceptions.rst:939
msgid ":c:data:`PyExc_KeyError`"
msgstr ""

#: ../../c-api/exceptions.rst:939
msgid ":exc:`KeyError`"
msgstr ":exc:`KeyError`"

#: ../../c-api/exceptions.rst:941
msgid ":c:data:`PyExc_KeyboardInterrupt`"
msgstr ""

#: ../../c-api/exceptions.rst:941
msgid ":exc:`KeyboardInterrupt`"
msgstr ":exc:`KeyboardInterrupt`"

#: ../../c-api/exceptions.rst:943
msgid ":c:data:`PyExc_LookupError`"
msgstr ""

#: ../../c-api/exceptions.rst:943
msgid ":exc:`LookupError`"
msgstr ":exc:`LookupError`"

#: ../../c-api/exceptions.rst:945
msgid ":c:data:`PyExc_MemoryError`"
msgstr ""

#: ../../c-api/exceptions.rst:945
msgid ":exc:`MemoryError`"
msgstr ":exc:`MemoryError`"

#: ../../c-api/exceptions.rst:947
msgid ":c:data:`PyExc_ModuleNotFoundError`"
msgstr ""

#: ../../c-api/exceptions.rst:947
msgid ":exc:`ModuleNotFoundError`"
msgstr ":exc:`ModuleNotFoundError`"

#: ../../c-api/exceptions.rst:949
msgid ":c:data:`PyExc_NameError`"
msgstr ""

#: ../../c-api/exceptions.rst:949
msgid ":exc:`NameError`"
msgstr ":exc:`NamnFel`"

#: ../../c-api/exceptions.rst:951
msgid ":c:data:`PyExc_NotADirectoryError`"
msgstr ""

#: ../../c-api/exceptions.rst:951
msgid ":exc:`NotADirectoryError`"
msgstr ":exc:`NotADirectoryError`"

#: ../../c-api/exceptions.rst:953
msgid ":c:data:`PyExc_NotImplementedError`"
msgstr ""

#: ../../c-api/exceptions.rst:953
msgid ":exc:`NotImplementedError`"
msgstr ":exc:`NotImplementedError`"

#: ../../c-api/exceptions.rst:955
msgid ":c:data:`PyExc_OSError`"
msgstr ""

#: ../../c-api/exceptions.rst:955
msgid ":exc:`OSError`"
msgstr ":exc:`OSError`"

#: ../../c-api/exceptions.rst:957
msgid ":c:data:`PyExc_OverflowError`"
msgstr ""

#: ../../c-api/exceptions.rst:957
msgid ":exc:`OverflowError`"
msgstr ":exc:`OverflowError`"

#: ../../c-api/exceptions.rst:959
msgid ":c:data:`PyExc_PermissionError`"
msgstr ""

#: ../../c-api/exceptions.rst:959
msgid ":exc:`PermissionError`"
msgstr ":exc:`PermissionError`"

#: ../../c-api/exceptions.rst:961
msgid ":c:data:`PyExc_ProcessLookupError`"
msgstr ""

#: ../../c-api/exceptions.rst:961
msgid ":exc:`ProcessLookupError`"
msgstr ":exc:`ProcessLookupError`"

#: ../../c-api/exceptions.rst:963
msgid ":c:data:`PyExc_RecursionError`"
msgstr ""

#: ../../c-api/exceptions.rst:963
msgid ":exc:`RecursionError`"
msgstr ":exc:`RecursionError`"

#: ../../c-api/exceptions.rst:965
msgid ":c:data:`PyExc_ReferenceError`"
msgstr ""

#: ../../c-api/exceptions.rst:965
msgid ":exc:`ReferenceError`"
msgstr ":exc:`ReferenceError`"

#: ../../c-api/exceptions.rst:967
msgid ":c:data:`PyExc_RuntimeError`"
msgstr ""

#: ../../c-api/exceptions.rst:967
msgid ":exc:`RuntimeError`"
msgstr ":exc:`RuntimeError`"

#: ../../c-api/exceptions.rst:969
msgid ":c:data:`PyExc_StopAsyncIteration`"
msgstr ""

#: ../../c-api/exceptions.rst:969
msgid ":exc:`StopAsyncIteration`"
msgstr ":exc:`StopAsyncIteration`"

#: ../../c-api/exceptions.rst:971
msgid ":c:data:`PyExc_StopIteration`"
msgstr ""

#: ../../c-api/exceptions.rst:971
msgid ":exc:`StopIteration`"
msgstr ":exc:`StopIteration`"

#: ../../c-api/exceptions.rst:973
msgid ":c:data:`PyExc_SyntaxError`"
msgstr ""

#: ../../c-api/exceptions.rst:973
msgid ":exc:`SyntaxError`"
msgstr ":exc:`SyntaxError`"

#: ../../c-api/exceptions.rst:975
msgid ":c:data:`PyExc_SystemError`"
msgstr ""

#: ../../c-api/exceptions.rst:975
msgid ":exc:`SystemError`"
msgstr ":exc:`Systemfel`"

#: ../../c-api/exceptions.rst:977
msgid ":c:data:`PyExc_SystemExit`"
msgstr ""

#: ../../c-api/exceptions.rst:977
msgid ":exc:`SystemExit`"
msgstr ":exc:`SystemExit`"

#: ../../c-api/exceptions.rst:979
msgid ":c:data:`PyExc_TabError`"
msgstr ""

#: ../../c-api/exceptions.rst:979
msgid ":exc:`TabError`"
msgstr ":exc:`TabError`"

#: ../../c-api/exceptions.rst:981
msgid ":c:data:`PyExc_TimeoutError`"
msgstr ""

#: ../../c-api/exceptions.rst:981
msgid ":exc:`TimeoutError`"
msgstr ":exc:`TimeoutError`"

#: ../../c-api/exceptions.rst:983
msgid ":c:data:`PyExc_TypeError`"
msgstr ""

#: ../../c-api/exceptions.rst:983
msgid ":exc:`TypeError`"
msgstr ":exc:`TypeError`"

#: ../../c-api/exceptions.rst:985
msgid ":c:data:`PyExc_UnboundLocalError`"
msgstr ""

#: ../../c-api/exceptions.rst:985
msgid ":exc:`UnboundLocalError`"
msgstr ":exc:`UnboundLocalError`"

#: ../../c-api/exceptions.rst:987
msgid ":c:data:`PyExc_UnicodeDecodeError`"
msgstr ""

#: ../../c-api/exceptions.rst:987
msgid ":exc:`UnicodeDecodeError`"
msgstr ":exc:`UnicodeDecodeError`"

#: ../../c-api/exceptions.rst:989
msgid ":c:data:`PyExc_UnicodeEncodeError`"
msgstr ""

#: ../../c-api/exceptions.rst:989
msgid ":exc:`UnicodeEncodeError`"
msgstr ":exc:`UnicodeEncodeError`"

#: ../../c-api/exceptions.rst:991
msgid ":c:data:`PyExc_UnicodeError`"
msgstr ""

#: ../../c-api/exceptions.rst:991
msgid ":exc:`UnicodeError`"
msgstr ":exc:`UnicodeError`"

#: ../../c-api/exceptions.rst:993
msgid ":c:data:`PyExc_UnicodeTranslateError`"
msgstr ""

#: ../../c-api/exceptions.rst:993
msgid ":exc:`UnicodeTranslateError`"
msgstr ":exc:`UnicodeTranslateError`"

#: ../../c-api/exceptions.rst:995
msgid ":c:data:`PyExc_ValueError`"
msgstr ""

#: ../../c-api/exceptions.rst:995
msgid ":exc:`ValueError`"
msgstr ":exc:`ValueError`"

#: ../../c-api/exceptions.rst:997
msgid ":c:data:`PyExc_ZeroDivisionError`"
msgstr ""

#: ../../c-api/exceptions.rst:997
msgid ":exc:`ZeroDivisionError`"
msgstr ":exc:`ZeroDivisionError`"

#: ../../c-api/exceptions.rst:1000
msgid ""
":c:data:`PyExc_BlockingIOError`, :c:data:`PyExc_BrokenPipeError`, "
":c:data:`PyExc_ChildProcessError`, :c:data:`PyExc_ConnectionError`, "
":c:data:`PyExc_ConnectionAbortedError`, "
":c:data:`PyExc_ConnectionRefusedError`, "
":c:data:`PyExc_ConnectionResetError`, :c:data:`PyExc_FileExistsError`, "
":c:data:`PyExc_FileNotFoundError`, :c:data:`PyExc_InterruptedError`, "
":c:data:`PyExc_IsADirectoryError`, :c:data:`PyExc_NotADirectoryError`, "
":c:data:`PyExc_PermissionError`, :c:data:`PyExc_ProcessLookupError` and "
":c:data:`PyExc_TimeoutError` were introduced following :pep:`3151`."
msgstr ""
":c:data:`PyExc_BlockingIOError`, :c:data:`PyExc_BrokenPipeError`, "
":c:data:`PyExc_ChildProcessError`, :c:data:`PyExc_ConnectionError`, "
":c:data:`PyExc_ConnectionAbortedError`, "
":c:data:`PyExc_ConnectionRefusedError`, "
":c:data:`PyExc_ConnectionResetError`, :c:data:`PyExc_FileExistsError`, "
":c:data:`PyExc_FileNotFoundError`, :c:data:`PyExc_InterruptedError`, "
":c:data:`PyExc_IsADirectoryError`, :c:data:`PyExc_NotADirectoryError`, "
":c:data:`PyExc_PermissionError`, :c:data:`PyExc_ProcessLookupError` och "
":c:data:`PyExc_TimeoutError` infördes enligt :pep:`3151`."

#: ../../c-api/exceptions.rst:1010
msgid ":c:data:`PyExc_StopAsyncIteration` and :c:data:`PyExc_RecursionError`."
msgstr ""
":c:data:`PyExc_StopAsyncIteration` och :c:data:`PyExc_RecursionError`."

#: ../../c-api/exceptions.rst:1013
msgid ":c:data:`PyExc_ModuleNotFoundError`."
msgstr ":c:data:`PyExc_ModuleNotFoundError`."

#: ../../c-api/exceptions.rst:1016
msgid "These are compatibility aliases to :c:data:`PyExc_OSError`:"
msgstr ""

#: ../../c-api/exceptions.rst:1026
msgid ":c:data:`PyExc_EnvironmentError`"
msgstr ""

#: ../../c-api/exceptions.rst:1028
msgid ":c:data:`PyExc_IOError`"
msgstr ""

#: ../../c-api/exceptions.rst:1030
msgid ":c:data:`PyExc_WindowsError`"
msgstr ""

#: ../../c-api/exceptions.rst:1030
msgid "[2]_"
msgstr ""

#: ../../c-api/exceptions.rst:1033
msgid "These aliases used to be separate exception types."
msgstr "Dessa alias brukade tidigare vara separata undantagstyper."

#: ../../c-api/exceptions.rst:1036 ../../c-api/exceptions.rst:1097
msgid "Notes:"
msgstr "Anteckningar:"

#: ../../c-api/exceptions.rst:1039
msgid "This is a base class for other standard exceptions."
msgstr ""

#: ../../c-api/exceptions.rst:1042
msgid ""
"Only defined on Windows; protect code that uses this by testing that the "
"preprocessor macro ``MS_WINDOWS`` is defined."
msgstr ""

#: ../../c-api/exceptions.rst:1048
msgid "Standard Warning Categories"
msgstr ""

#: ../../c-api/exceptions.rst:1050
msgid ""
"All standard Python warning categories are available as global variables "
"whose names are ``PyExc_`` followed by the Python exception name. These have"
" the type :c:expr:`PyObject*`; they are all class objects. For completeness,"
" here are all the variables:"
msgstr ""

#: ../../c-api/exceptions.rst:1071
msgid ":c:data:`PyExc_Warning`"
msgstr ""

#: ../../c-api/exceptions.rst:1071
msgid ":exc:`Warning`"
msgstr ":exc:`Warning`"

#: ../../c-api/exceptions.rst:1071
msgid "[3]_"
msgstr ""

#: ../../c-api/exceptions.rst:1073
msgid ":c:data:`PyExc_BytesWarning`"
msgstr ""

#: ../../c-api/exceptions.rst:1073
msgid ":exc:`BytesWarning`"
msgstr ":exc:`BytesWarning`"

#: ../../c-api/exceptions.rst:1075
msgid ":c:data:`PyExc_DeprecationWarning`"
msgstr ""

#: ../../c-api/exceptions.rst:1075
msgid ":exc:`DeprecationWarning`"
msgstr ":exc:`DeprecationWarning`"

#: ../../c-api/exceptions.rst:1077
msgid ":c:data:`PyExc_FutureWarning`"
msgstr ""

#: ../../c-api/exceptions.rst:1077
msgid ":exc:`FutureWarning`"
msgstr ":exc:`FutureWarning`"

#: ../../c-api/exceptions.rst:1079
msgid ":c:data:`PyExc_ImportWarning`"
msgstr ""

#: ../../c-api/exceptions.rst:1079
msgid ":exc:`ImportWarning`"
msgstr ":exc:`ImportWarning`"

#: ../../c-api/exceptions.rst:1081
msgid ":c:data:`PyExc_PendingDeprecationWarning`"
msgstr ""

#: ../../c-api/exceptions.rst:1081
msgid ":exc:`PendingDeprecationWarning`"
msgstr ":exc:`PendingDeprecationWarning`"

#: ../../c-api/exceptions.rst:1083
msgid ":c:data:`PyExc_ResourceWarning`"
msgstr ""

#: ../../c-api/exceptions.rst:1083
msgid ":exc:`ResourceWarning`"
msgstr ":exc:`ResourceWarning`"

#: ../../c-api/exceptions.rst:1085
msgid ":c:data:`PyExc_RuntimeWarning`"
msgstr ""

#: ../../c-api/exceptions.rst:1085
msgid ":exc:`RuntimeWarning`"
msgstr ":exc:`RuntimeWarning`"

#: ../../c-api/exceptions.rst:1087
msgid ":c:data:`PyExc_SyntaxWarning`"
msgstr ""

#: ../../c-api/exceptions.rst:1087
msgid ":exc:`SyntaxWarning`"
msgstr ":exc:`SyntaxWarning`"

#: ../../c-api/exceptions.rst:1089
msgid ":c:data:`PyExc_UnicodeWarning`"
msgstr ""

#: ../../c-api/exceptions.rst:1089
msgid ":exc:`UnicodeWarning`"
msgstr ":exc:`UnicodeWarning`"

#: ../../c-api/exceptions.rst:1091
msgid ":c:data:`PyExc_UserWarning`"
msgstr ""

#: ../../c-api/exceptions.rst:1091
msgid ":exc:`UserWarning`"
msgstr ":exc:`UserWarning`"

#: ../../c-api/exceptions.rst:1094
msgid ":c:data:`PyExc_ResourceWarning`."
msgstr ":c:data:`PyExc_ResourceWarning`."

#: ../../c-api/exceptions.rst:1100
msgid "This is a base class for other standard warning categories."
msgstr ""
