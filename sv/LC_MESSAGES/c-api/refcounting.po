# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-16 17:23+0000\n"
"PO-Revision-Date: 2025-09-16 00:00+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../c-api/refcounting.rst:8
msgid "Reference Counting"
msgstr "Referensräkning"

#: ../../c-api/refcounting.rst:10
msgid ""
"The functions and macros in this section are used for managing reference "
"counts of Python objects."
msgstr ""
"Funktionerna och makron i det här avsnittet används för att hantera "
"referensantal för Python-objekt."

#: ../../c-api/refcounting.rst:16
msgid "Get the reference count of the Python object *o*."
msgstr "Hämta referensantalet för Python-objektet *o*."

#: ../../c-api/refcounting.rst:18
msgid ""
"Note that the returned value may not actually reflect how many references to "
"the object are actually held.  For example, some objects are :term:"
"`immortal` and have a very high refcount that does not reflect the actual "
"number of references.  Consequently, do not rely on the returned value to be "
"accurate, other than a value of 0 or 1."
msgstr ""
"Observera att det returnerade värdet kanske inte återspeglar hur många "
"referenser till objektet som faktiskt finns.  Vissa objekt är t.ex. :term:"
"`immortal` och har ett mycket högt refcount som inte återspeglar det "
"faktiska antalet referenser.  Förlita dig därför inte på att det returnerade "
"värdet är korrekt, annat än ett värde på 0 eller 1."

#: ../../c-api/refcounting.rst:24
msgid ""
"Use the :c:func:`Py_SET_REFCNT()` function to set an object reference count."
msgstr ""
"Använd funktionen :c:func:`Py_SET_REFCNT()` för att ställa in ett objekts "
"referensantal."

#: ../../c-api/refcounting.rst:28
msgid ""
"On :term:`free threaded <free threading>` builds of Python, returning 1 "
"isn't sufficient to determine if it's safe to treat *o* as having no access "
"by other threads. Use :c:func:`PyUnstable_Object_IsUniquelyReferenced` for "
"that instead."
msgstr ""
"I :term:`free threaded <free threading>` -versioner av Python räcker det "
"inte att returnera 1 för att avgöra om det är säkert att behandla *o* som om "
"det inte är tillgängligt för andra trådar. Använd istället :c:func:"
"`PyUnstable_Object_IsUniquelyReferenced` för detta."

#: ../../c-api/refcounting.rst:33
msgid ""
"See also the function :c:func:"
"`PyUnstable_Object_IsUniqueReferencedTemporary()`."
msgstr ""
"Se även funktionen :c:func:`PyUnstable_Object_IsUniqueReferencedTemporary()`."

#: ../../c-api/refcounting.rst:35
msgid ":c:func:`Py_REFCNT()` is changed to the inline static function."
msgstr ":c:func:`Py_REFCNT()` ändras till en inline statisk funktion."

#: ../../c-api/refcounting.rst:38
msgid "The parameter type is no longer :c:expr:`const PyObject*`."
msgstr "Parametertypen är inte längre :c:expr:`const PyObject*`."

#: ../../c-api/refcounting.rst:44
msgid "Set the object *o* reference counter to *refcnt*."
msgstr "Ställ in objektets *o* referensräknare till *refcnt*."

#: ../../c-api/refcounting.rst:46
msgid ""
"On :ref:`Python build with Free Threading <free-threading-build>`, if "
"*refcnt* is larger than ``UINT32_MAX``, the object is made :term:`immortal`."
msgstr ""
"På :ref:`Python build with Free Threading <free-threading-build>`, om "
"*refcnt* är större än ``UINT32_MAX``, görs objektet :term:`immortal`."

#: ../../c-api/refcounting.rst:49 ../../c-api/refcounting.rst:62
#: ../../c-api/refcounting.rst:128
msgid "This function has no effect on :term:`immortal` objects."
msgstr "Denna funktion har ingen effekt på :term:`immortal`\\-objekt."

#: ../../c-api/refcounting.rst:53 ../../c-api/refcounting.rst:77
#: ../../c-api/refcounting.rst:156
msgid "Immortal objects are not modified."
msgstr "Odödliga föremål ändras inte."

#: ../../c-api/refcounting.rst:59
msgid ""
"Indicate taking a new :term:`strong reference` to object *o*, indicating it "
"is in use and should not be destroyed."
msgstr ""
"Ange att du tar en ny :term:`strong reference` till objekt *o*, vilket "
"indikerar att det används och inte bör förstöras."

#: ../../c-api/refcounting.rst:64
msgid ""
"This function is usually used to convert a :term:`borrowed reference` to a :"
"term:`strong reference` in-place. The :c:func:`Py_NewRef` function can be "
"used to create a new :term:`strong reference`."
msgstr ""
"Denna funktion används vanligtvis för att konvertera en :term:`lånad "
"referens` till en :term:`strong reference` på plats. Funktionen :c:func:"
"`Py_NewRef` kan användas för att skapa en ny :term:`strong reference`."

#: ../../c-api/refcounting.rst:68
msgid "When done using the object, release is by calling :c:func:`Py_DECREF`."
msgstr ""
"När du är klar med att använda objektet, släpp det genom att anropa :c:func:"
"`Py_DECREF`."

#: ../../c-api/refcounting.rst:70
msgid ""
"The object must not be ``NULL``; if you aren't sure that it isn't ``NULL``, "
"use :c:func:`Py_XINCREF`."
msgstr ""
"Objektet får inte vara ``NULL``; om du inte är säker på att det inte är "
"``NULL``, använd :c:func:`Py_XINCREF`."

#: ../../c-api/refcounting.rst:73
msgid ""
"Do not expect this function to actually modify *o* in any way. For at least :"
"pep:`some objects <0683>`, this function has no effect."
msgstr ""
"Förvänta dig inte att den här funktionen faktiskt modifierar *o* på något "
"sätt. För åtminstone :pep:`vissa objekt <0683>` har den här funktionen ingen "
"effekt."

#: ../../c-api/refcounting.rst:83
msgid ""
"Similar to :c:func:`Py_INCREF`, but the object *o* can be ``NULL``, in which "
"case this has no effect."
msgstr ""
"Liknar :c:func:`Py_INCREF`, men objektet *o* kan vara ``NULL``, i vilket "
"fall detta inte har någon effekt."

#: ../../c-api/refcounting.rst:86
msgid "See also :c:func:`Py_XNewRef`."
msgstr "Se även :c:func:`Py_XNewRef`."

#: ../../c-api/refcounting.rst:91
msgid ""
"Create a new :term:`strong reference` to an object: call :c:func:`Py_INCREF` "
"on *o* and return the object *o*."
msgstr ""
"Skapa en ny :term:`strong reference` till ett objekt: anropa :c:func:"
"`Py_INCREF` på *o* och returnera objektet *o*."

#: ../../c-api/refcounting.rst:94
msgid ""
"When the :term:`strong reference` is no longer needed, :c:func:`Py_DECREF` "
"should be called on it to release the reference."
msgstr ""
"När :term:`strong reference` inte längre behövs, skall :c:func:`Py_DECREF` "
"anropas för att frigöra referensen."

#: ../../c-api/refcounting.rst:97
msgid ""
"The object *o* must not be ``NULL``; use :c:func:`Py_XNewRef` if *o* can be "
"``NULL``."
msgstr ""
"Objektet *o* får inte vara ``NULL``; använd :c:func:`Py_XNewRef` om *o* kan "
"vara ``NULL``."

#: ../../c-api/refcounting.rst:100
msgid "For example::"
msgstr "Till exempel::"

#: ../../c-api/refcounting.rst:102
msgid ""
"Py_INCREF(obj);\n"
"self->attr = obj;"
msgstr ""
"Py_INCREF(obj);\n"
"self->attr = obj;"

#: ../../c-api/refcounting.rst:105
msgid "can be written as::"
msgstr "kan skrivas som::"

#: ../../c-api/refcounting.rst:107
msgid "self->attr = Py_NewRef(obj);"
msgstr "self->attr = Py_NewRef(obj);"

#: ../../c-api/refcounting.rst:109
msgid "See also :c:func:`Py_INCREF`."
msgstr "Se även :c:func:`Py_INCREF`."

#: ../../c-api/refcounting.rst:116
msgid "Similar to :c:func:`Py_NewRef`, but the object *o* can be NULL."
msgstr "Liknar :c:func:`Py_NewRef`, men objektet *o* kan vara NULL."

#: ../../c-api/refcounting.rst:118
msgid "If the object *o* is ``NULL``, the function just returns ``NULL``."
msgstr "Om objektet *o* är ``NULL`` returnerar funktionen bara ``NULL``."

#: ../../c-api/refcounting.rst:125
msgid ""
"Release a :term:`strong reference` to object *o*, indicating the reference "
"is no longer used."
msgstr ""
"Frigör en :term:`strong reference` till objekt *o*, vilket indikerar att "
"referensen inte längre används."

#: ../../c-api/refcounting.rst:130
msgid ""
"Once the last :term:`strong reference` is released (i.e. the object's "
"reference count reaches 0), the object's type's deallocation function (which "
"must not be ``NULL``) is invoked."
msgstr ""
"När den sista :term:`strong reference` har släppts (d.v.s. objektets "
"referensantal når 0), anropas objekttypens deallokeringsfunktion (som inte "
"får vara ``NULL``)."

#: ../../c-api/refcounting.rst:135
msgid ""
"This function is usually used to delete a :term:`strong reference` before "
"exiting its scope."
msgstr ""
"Denna funktion används vanligtvis för att ta bort en :term:`strong "
"reference` innan den lämnar sitt scope."

#: ../../c-api/refcounting.rst:138
msgid ""
"The object must not be ``NULL``; if you aren't sure that it isn't ``NULL``, "
"use :c:func:`Py_XDECREF`."
msgstr ""
"Objektet får inte vara ``NULL``; om du inte är säker på att det inte är "
"``NULL``, använd :c:func:`Py_XDECREF`."

#: ../../c-api/refcounting.rst:141
msgid ""
"Do not expect this function to actually modify *o* in any way. For at least :"
"pep:`some objects <683>`, this function has no effect."
msgstr ""
"Förvänta dig inte att den här funktionen faktiskt modifierar *o* på något "
"sätt. För åtminstone :pep:`vissa objekt <683>` har den här funktionen ingen "
"effekt."

#: ../../c-api/refcounting.rst:147
msgid ""
"The deallocation function can cause arbitrary Python code to be invoked (e."
"g. when a class instance with a :meth:`~object.__del__` method is "
"deallocated).  While exceptions in such code are not propagated, the "
"executed code has free access to all Python global variables.  This means "
"that any object that is reachable from a global variable should be in a "
"consistent state before :c:func:`Py_DECREF` is invoked.  For example, code "
"to delete an object from a list should copy a reference to the deleted "
"object in a temporary variable, update the list data structure, and then "
"call :c:func:`Py_DECREF` for the temporary variable."
msgstr ""
"Funktionen deallocation kan orsaka att godtycklig Python-kod anropas (t.ex. "
"när en klassinstans med en :meth:`~object.__del__`\\-metod deallokeras).  "
"Undantag i sådan kod sprids inte, men den exekverade koden har fri tillgång "
"till alla Pythons globala variabler.  Detta innebär att alla objekt som kan "
"nås från en global variabel bör vara i ett konsekvent tillstånd innan :c:"
"func:`Py_DECREF` anropas.  Till exempel bör kod för att ta bort ett objekt "
"från en lista kopiera en referens till det borttagna objektet i en temporär "
"variabel, uppdatera listans datastruktur och sedan anropa :c:func:"
"`Py_DECREF` för den temporära variabeln."

#: ../../c-api/refcounting.rst:162
msgid ""
"Similar to :c:func:`Py_DECREF`, but the object *o* can be ``NULL``, in which "
"case this has no effect. The same warning from :c:func:`Py_DECREF` applies "
"here as well."
msgstr ""
"Liknar :c:func:`Py_DECREF`, men objektet *o* kan vara ``NULL``, i vilket "
"fall detta inte har någon effekt. Samma varning som för :c:func:`Py_DECREF` "
"gäller även här."

#: ../../c-api/refcounting.rst:169
msgid ""
"Release a :term:`strong reference` for object *o*. The object may be "
"``NULL``, in which case the macro has no effect; otherwise the effect is the "
"same as for :c:func:`Py_DECREF`, except that the argument is also set to "
"``NULL``.  The warning for :c:func:`Py_DECREF` does not apply with respect "
"to the object passed because the macro carefully uses a temporary variable "
"and sets the argument to ``NULL`` before releasing the reference."
msgstr ""
"Frigör en :term:`strong reference` för objektet *o*. Objektet kan vara "
"``NULL``, i vilket fall makrot inte har någon effekt; i annat fall är "
"effekten densamma som för :c:func:`Py_DECREF`, förutom att argumentet också "
"sätts till ``NULL``.  Varningen för :c:func:`Py_DECREF` gäller inte med "
"avseende på det objekt som skickas eftersom makrot försiktigt använder en "
"temporär variabel och sätter argumentet till ``NULL`` innan referensen "
"släpps."

#: ../../c-api/refcounting.rst:177
msgid ""
"It is a good idea to use this macro whenever releasing a reference to an "
"object that might be traversed during garbage collection."
msgstr ""
"Det är en god idé att använda detta makro när man släpper en referens till "
"ett objekt som kan komma att genomkorsas under garbage collection."

#: ../../c-api/refcounting.rst:180
msgid ""
"The macro argument is now only evaluated once. If the argument has side "
"effects, these are no longer duplicated."
msgstr ""
"Makroargumentet utvärderas nu bara en gång. Om argumentet har bieffekter "
"dupliceras dessa inte längre."

#: ../../c-api/refcounting.rst:187
msgid ""
"Indicate taking a new :term:`strong reference` to object *o*. A function "
"version of :c:func:`Py_XINCREF`. It can be used for runtime dynamic "
"embedding of Python."
msgstr ""
"Indikerar att en ny :term:`strong reference` tas till objekt *o*. En "
"funktionsversion av :c:func:`Py_XINCREF`. Den kan användas för dynamisk "
"inbäddning av Python under körtid."

#: ../../c-api/refcounting.rst:194
msgid ""
"Release a :term:`strong reference` to object *o*. A function version of :c:"
"func:`Py_XDECREF`. It can be used for runtime dynamic embedding of Python."
msgstr ""
"Frigör en :term:`strong reference` till objekt *o*. En funktionsversion av :"
"c:func:`Py_XDECREF`. Den kan användas för dynamisk inbäddning av Python "
"under körtid."

#: ../../c-api/refcounting.rst:201
msgid ""
"Macro safely releasing a :term:`strong reference` to object *dst* and "
"setting *dst* to *src*."
msgstr ""
"Makro som på ett säkert sätt släpper en :term:`strong reference` till "
"objektet *dst* och sätter *dst* till *src*."

#: ../../c-api/refcounting.rst:204
msgid "As in case of :c:func:`Py_CLEAR`, \"the obvious\" code can be deadly::"
msgstr ""
"Som i fallet med :c:func:`Py_CLEAR`, kan \"den uppenbara\" koden vara "
"dödlig::"

#: ../../c-api/refcounting.rst:206
msgid ""
"Py_DECREF(dst);\n"
"dst = src;"
msgstr ""
"Py_DECREF(dst);\n"
"dst = src;"

#: ../../c-api/refcounting.rst:209
msgid "The safe way is::"
msgstr "Det säkra sättet är::"

#: ../../c-api/refcounting.rst:211
msgid "Py_SETREF(dst, src);"
msgstr "Py_SETREF(dst, src);"

#: ../../c-api/refcounting.rst:213
msgid ""
"That arranges to set *dst* to *src* *before* releasing the reference to the "
"old value of *dst*, so that any code triggered as a side-effect of *dst* "
"getting torn down no longer believes *dst* points to a valid object."
msgstr ""
"Det gör att *dst* sätts till *src* *innan* referensen till det gamla värdet "
"på *dst* släpps, så att all kod som triggas som en bieffekt av att *dst* "
"rivs inte längre tror att *dst* pekar på ett giltigt objekt."

#: ../../c-api/refcounting.rst:220 ../../c-api/refcounting.rst:232
msgid ""
"The macro arguments are now only evaluated once. If an argument has side "
"effects, these are no longer duplicated."
msgstr ""
"Makroargumenten utvärderas nu bara en gång. Om ett argument har bieffekter "
"dupliceras dessa inte längre."

#: ../../c-api/refcounting.rst:227
msgid ""
"Variant of :c:macro:`Py_SETREF` macro that uses :c:func:`Py_XDECREF` instead "
"of :c:func:`Py_DECREF`."
msgstr ""
"Variant av makrot :c:macro:`Py_SETREF` som använder :c:func:`Py_XDECREF` "
"istället för :c:func:`Py_DECREF`."
