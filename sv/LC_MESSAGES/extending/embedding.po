# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# python-doc bot, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-25 18:05+0000\n"
"PO-Revision-Date: 2025-09-22 17:54+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../extending/embedding.rst:8
msgid "Embedding Python in Another Application"
msgstr "Bädda in Python i en annan applikation"

#: ../../extending/embedding.rst:10
msgid ""
"The previous chapters discussed how to extend Python, that is, how to extend"
" the functionality of Python by attaching a library of C functions to it.  "
"It is also possible to do it the other way around: enrich your C/C++ "
"application by embedding Python in it.  Embedding provides your application "
"with the ability to implement some of the functionality of your application "
"in Python rather than C or C++. This can be used for many purposes; one "
"example would be to allow users to tailor the application to their needs by "
"writing some scripts in Python.  You can also use it yourself if some of the"
" functionality can be written in Python more easily."
msgstr ""
"I de föregående kapitlen diskuterades hur man utökar Python, det vill säga "
"hur man utökar Pythons funktionalitet genom att koppla ett bibliotek med "
"C-funktioner till det.  Det är också möjligt att göra tvärtom: berika din "
"C/C++-applikation genom att bädda in Python i den.  Inbäddning ger din "
"applikation möjlighet att implementera en del av funktionaliteten i din "
"applikation i Python snarare än i C eller C++. Detta kan användas för många "
"ändamål; ett exempel skulle kunna vara att låta användarna skräddarsy "
"applikationen efter sina behov genom att skriva några skript i Python.  Du "
"kan också använda det själv om en del av funktionaliteten lättare kan "
"skrivas i Python."

#: ../../extending/embedding.rst:20
msgid ""
"Embedding Python is similar to extending it, but not quite.  The difference "
"is that when you extend Python, the main program of the application is still"
" the Python interpreter, while if you embed Python, the main program may "
"have nothing to do with Python --- instead, some parts of the application "
"occasionally call the Python interpreter to run some Python code."
msgstr ""
"Att bädda in Python liknar att utöka det, men inte riktigt.  Skillnaden är "
"att när du utökar Python är applikationens huvudprogram fortfarande Python-"
"tolken, medan om du bäddar in Python kanske huvudprogrammet inte har något "
"att göra med Python --- istället kallar vissa delar av applikationen ibland "
"Python-tolken för att köra lite Python-kod."

#: ../../extending/embedding.rst:26
msgid ""
"So if you are embedding Python, you are providing your own main program.  "
"One of the things this main program has to do is initialize the Python "
"interpreter.  At the very least, you have to call the function "
":c:func:`Py_Initialize`.  There are optional calls to pass command line "
"arguments to Python.  Then later you can call the interpreter from any part "
"of the application."
msgstr ""
"Så om du bäddar in Python tillhandahåller du ditt eget huvudprogram.  En av "
"de saker som detta huvudprogram måste göra är att initiera Python-tolken.  "
"Åtminstone måste du anropa funktionen :c:func:`Py_Initialize`.  Det finns "
"valfria anrop för att skicka kommandoradsargument till Python.  Senare kan "
"du anropa tolken från vilken del som helst av programmet."

#: ../../extending/embedding.rst:32
msgid ""
"There are several different ways to call the interpreter: you can pass a "
"string containing Python statements to :c:func:`PyRun_SimpleString`, or you "
"can pass a stdio file pointer and a file name (for identification in error "
"messages only) to :c:func:`PyRun_SimpleFile`.  You can also call the lower-"
"level operations described in the previous chapters to construct and use "
"Python objects."
msgstr ""
"Det finns flera olika sätt att anropa tolken: du kan skicka en sträng som "
"innehåller Python-satser till :c:func:`PyRun_SimpleString`, eller så kan du "
"skicka en stdio-filpekare och ett filnamn (endast för identifiering i "
"felmeddelanden) till :c:func:`PyRun_SimpleFile`.  Du kan också anropa de "
"operationer på lägre nivå som beskrivs i de föregående kapitlen för att "
"konstruera och använda Python-objekt."

#: ../../extending/embedding.rst:42
msgid ":ref:`c-api-index`"
msgstr ":ref:`c-api-index`"

#: ../../extending/embedding.rst:42
msgid ""
"The details of Python's C interface are given in this manual. A great deal "
"of necessary information can be found here."
msgstr ""
"Detaljerna i Pythons C-gränssnitt beskrivs i den här handboken. En stor del "
"av den nödvändiga informationen finns här."

#: ../../extending/embedding.rst:49
msgid "Very High Level Embedding"
msgstr "Inbäddning på mycket hög nivå"

#: ../../extending/embedding.rst:51
msgid ""
"The simplest form of embedding Python is the use of the very high level "
"interface. This interface is intended to execute a Python script without "
"needing to interact with the application directly. This can for example be "
"used to perform some operation on a file. ::"
msgstr ""
"Den enklaste formen av Python-inbäddning är att använda ett gränssnitt på "
"mycket hög nivå. Detta gränssnitt är avsett att exekvera ett Python-skript "
"utan att behöva interagera med applikationen direkt. Detta kan t.ex. "
"användas för att utföra någon operation på en fil:"

#: ../../extending/embedding.rst:78
msgid ""
"The :c:func:`Py_SetProgramName` function should be called before "
":c:func:`Py_Initialize` to inform the interpreter about paths to Python run-"
"time libraries.  Next, the Python interpreter is initialized with "
":c:func:`Py_Initialize`, followed by the execution of a hard-coded Python "
"script that prints the date and time.  Afterwards, the "
":c:func:`Py_FinalizeEx` call shuts the interpreter down, followed by the end"
" of the program.  In a real program, you may want to get the Python script "
"from another source, perhaps a text-editor routine, a file, or a database.  "
"Getting the Python code from a file can better be done by using the "
":c:func:`PyRun_SimpleFile` function, which saves you the trouble of "
"allocating memory space and loading the file contents."
msgstr ""

#: ../../extending/embedding.rst:93
msgid "Beyond Very High Level Embedding: An overview"
msgstr "Bortom inbäddning på mycket hög nivå: En översikt"

#: ../../extending/embedding.rst:95
msgid ""
"The high level interface gives you the ability to execute arbitrary pieces "
"of Python code from your application, but exchanging data values is quite "
"cumbersome to say the least. If you want that, you should use lower level "
"calls. At the cost of having to write more C code, you can achieve almost "
"anything."
msgstr ""
"Högnivågränssnittet ger dig möjlighet att exekvera godtyckliga bitar av "
"Python-kod från din applikation, men att utbyta datavärden är minst sagt "
"besvärligt. Om du vill ha det bör du använda anrop på lägre nivå. På "
"bekostnad av att behöva skriva mer C-kod kan du uppnå nästan vad som helst."

#: ../../extending/embedding.rst:100
msgid ""
"It should be noted that extending Python and embedding Python is quite the "
"same activity, despite the different intent. Most topics discussed in the "
"previous chapters are still valid. To show this, consider what the extension"
" code from Python to C really does:"
msgstr ""
"Det bör noteras att utöka Python och bädda in Python är ganska samma "
"aktivitet, trots den olika avsikten. De flesta ämnen som diskuterats i de "
"tidigare kapitlen är fortfarande giltiga. För att visa detta kan du fundera "
"på vad tilläggskoden från Python till C verkligen gör:"

#: ../../extending/embedding.rst:105
msgid "Convert data values from Python to C,"
msgstr "Konvertera datavärden från Python till C,"

#: ../../extending/embedding.rst:107
msgid "Perform a function call to a C routine using the converted values, and"
msgstr ""
"Utföra ett funktionsanrop till en C-rutin med hjälp av de konverterade "
"värdena, och"

#: ../../extending/embedding.rst:109
msgid "Convert the data values from the call from C to Python."
msgstr "Konvertera datavärdena från anropet från C till Python."

#: ../../extending/embedding.rst:111
msgid "When embedding Python, the interface code does:"
msgstr "Vid inbäddning av Python gör gränssnittskoden det:"

#: ../../extending/embedding.rst:113
msgid "Convert data values from C to Python,"
msgstr "Konvertera datavärden från C till Python,"

#: ../../extending/embedding.rst:115
msgid ""
"Perform a function call to a Python interface routine using the converted "
"values, and"
msgstr ""
"Utföra ett funktionsanrop till en Python-gränssnittsrutin med hjälp av de "
"konverterade värdena, och"

#: ../../extending/embedding.rst:118
msgid "Convert the data values from the call from Python to C."
msgstr "Konvertera datavärdena från anropet från Python till C."

#: ../../extending/embedding.rst:120
msgid ""
"As you can see, the data conversion steps are simply swapped to accommodate "
"the different direction of the cross-language transfer. The only difference "
"is the routine that you call between both data conversions. When extending, "
"you call a C routine, when embedding, you call a Python routine."
msgstr ""
"Som du kan se byts datakonverteringsstegen helt enkelt ut för att passa den "
"olika riktningen för överföringen mellan språken. Den enda skillnaden är den"
" rutin som du anropar mellan de båda datakonverteringarna. Vid utökning "
"anropar du en C-rutin, vid inbäddning anropar du en Python-rutin."

#: ../../extending/embedding.rst:125
msgid ""
"This chapter will not discuss how to convert data from Python to C and vice "
"versa.  Also, proper use of references and dealing with errors is assumed to"
" be understood.  Since these aspects do not differ from extending the "
"interpreter, you can refer to earlier chapters for the required information."
msgstr ""
"Detta kapitel kommer inte att diskutera hur man konverterar data från Python"
" till C och vice versa.  Även korrekt användning av referenser och hantering"
" av fel förutsätts vara förstått.  Eftersom dessa aspekter inte skiljer sig "
"från att utöka tolken, kan du hänvisa till tidigare kapitel för den "
"information som krävs."

#: ../../extending/embedding.rst:134
msgid "Pure Embedding"
msgstr "Ren inbäddning"

#: ../../extending/embedding.rst:136
msgid ""
"The first program aims to execute a function in a Python script. Like in the"
" section about the very high level interface, the Python interpreter does "
"not directly interact with the application (but that will change in the next"
" section)."
msgstr ""
"Det första programmet syftar till att exekvera en funktion i ett Python-"
"skript. Precis som i avsnittet om gränssnittet på mycket hög nivå "
"interagerar Python-tolken inte direkt med programmet (men det kommer att "
"ändras i nästa avsnitt)."

#: ../../extending/embedding.rst:141
msgid "The code to run a function defined in a Python script is:"
msgstr "Koden för att köra en funktion som definieras i ett Python-skript är:"

#: ../../extending/embedding.rst:146
msgid ""
"This code loads a Python script using ``argv[1]``, and calls the function "
"named in ``argv[2]``.  Its integer arguments are the other values of the "
"``argv`` array.  If you :ref:`compile and link <compiling>` this program "
"(let's call the finished executable :program:`call`), and use it to execute "
"a Python script, such as:"
msgstr ""
"Den här koden laddar ett Python-skript med hjälp av ``argv[1]`` och anropar "
"funktionen som namnges i ``argv[2]``.  Dess heltalsargument är de andra "
"värdena i ``argv``\\-arrayen.  Om du :ref:`kompilerar och länkar "
"<compiling>` detta program (låt oss kalla den färdiga körbara filen "
":program:`call`), och använder den för att köra ett Python-skript, t.ex:"

#: ../../extending/embedding.rst:161
msgid "then the result should be:"
msgstr "då borde resultatet bli:"

#: ../../extending/embedding.rst:169
msgid ""
"Although the program is quite large for its functionality, most of the code "
"is for data conversion between Python and C, and for error reporting.  The "
"interesting part with respect to embedding Python starts with ::"
msgstr ""
"Även om programmet är ganska stort för sin funktionalitet, är det mesta av "
"koden för datakonvertering mellan Python och C, och för felrapportering.  "
"Den intressanta delen när det gäller inbäddning av Python börjar med ::"

#: ../../extending/embedding.rst:178
msgid ""
"After initializing the interpreter, the script is loaded using "
":c:func:`PyImport_Import`.  This routine needs a Python string as its "
"argument, which is constructed using the :c:func:`PyUnicode_FromString` data"
" conversion routine. ::"
msgstr ""

#: ../../extending/embedding.rst:191
msgid ""
"Once the script is loaded, the name we're looking for is retrieved using "
":c:func:`PyObject_GetAttrString`.  If the name exists, and the object "
"returned is callable, you can safely assume that it is a function.  The "
"program then proceeds by constructing a tuple of arguments as normal.  The "
"call to the Python function is then made with::"
msgstr ""
"När skriptet har laddats hämtas det namn vi letar efter med hjälp av "
":c:func:`PyObject_GetAttrString`.  Om namnet finns och objektet som "
"returneras är anropsbart kan man lugnt anta att det är en funktion.  "
"Programmet fortsätter sedan med att konstruera en tupel av argument som "
"normalt.  Anropet till Python-funktionen görs sedan med::"

#: ../../extending/embedding.rst:199
msgid ""
"Upon return of the function, ``pValue`` is either ``NULL`` or it contains a "
"reference to the return value of the function.  Be sure to release the "
"reference after examining the value."
msgstr ""
"När funktionen returneras är ``pValue`` antingen ``NULL`` eller så "
"innehåller den en referens till funktionens returvärde.  Var noga med att "
"släppa referensen efter att ha undersökt värdet."

#: ../../extending/embedding.rst:207
msgid "Extending Embedded Python"
msgstr "Utökning av inbäddad Python"

#: ../../extending/embedding.rst:209
msgid ""
"Until now, the embedded Python interpreter had no access to functionality "
"from the application itself.  The Python API allows this by extending the "
"embedded interpreter.  That is, the embedded interpreter gets extended with "
"routines provided by the application. While it sounds complex, it is not so "
"bad.  Simply forget for a while that the application starts the Python "
"interpreter.  Instead, consider the application to be a set of subroutines, "
"and write some glue code that gives Python access to those routines, just "
"like you would write a normal Python extension.  For example::"
msgstr ""
"Fram till nu har den inbäddade Python-tolken inte haft tillgång till "
"funktionalitet från själva applikationen.  Python API tillåter detta genom "
"att utöka den inbäddade tolken.  Det vill säga, den inbäddade tolken utökas "
"med rutiner som tillhandahålls av applikationen. Även om det låter "
"komplicerat är det inte så illa.  Glöm bara för ett tag att applikationen "
"startar Python-tolken.  Betrakta istället applikationen som en uppsättning "
"underrutiner och skriv lite limkod som ger Python tillgång till dessa "
"rutiner, precis som du skulle skriva ett vanligt Python-tillägg.  Till "
"exempel::"

#: ../../extending/embedding.rst:246
msgid ""
"Insert the above code just above the :c:func:`main` function. Also, insert "
"the following two statements before the call to :c:func:`Py_Initialize`::"
msgstr ""
"Infoga ovanstående kod precis ovanför funktionen :c:func:`main`. Infoga "
"också följande två satser före anropet till :c:func:`Py_Initialize`::"

#: ../../extending/embedding.rst:252
msgid ""
"These two lines initialize the ``numargs`` variable, and make the "
":func:`emb.numargs` function accessible to the embedded Python interpreter. "
"With these extensions, the Python script can do things like"
msgstr ""

#: ../../extending/embedding.rst:261
msgid ""
"In a real application, the methods will expose an API of the application to "
"Python."
msgstr ""
"I en verklig applikation kommer metoderna att exponera ett API för "
"applikationen till Python."

#: ../../extending/embedding.rst:271
msgid "Embedding Python in C++"
msgstr "Inbäddning av Python i C++"

#: ../../extending/embedding.rst:273
msgid ""
"It is also possible to embed Python in a C++ program; precisely how this is "
"done will depend on the details of the C++ system used; in general you will "
"need to write the main program in C++, and use the C++ compiler to compile "
"and link your program.  There is no need to recompile Python itself using "
"C++."
msgstr ""
"Det är också möjligt att bädda in Python i ett C++-program; exakt hur detta "
"görs beror på detaljerna i det C++-system som används; i allmänhet måste du "
"skriva huvudprogrammet i C++ och använda C++-kompilatorn för att kompilera "
"och länka ditt program.  Det finns inget behov av att kompilera om Python "
"själv med hjälp av C++."

#: ../../extending/embedding.rst:282
msgid "Compiling and Linking under Unix-like systems"
msgstr "Kompilering och länkning under Unix-liknande system"

#: ../../extending/embedding.rst:284
msgid ""
"It is not necessarily trivial to find the right flags to pass to your "
"compiler (and linker) in order to embed the Python interpreter into your "
"application, particularly because Python needs to load library modules "
"implemented as C dynamic extensions (:file:`.so` files) linked against it."
msgstr ""
"Det är inte nödvändigtvis trivialt att hitta rätt flaggor att skicka till "
"din kompilator (och länkare) för att bädda in Python-tolken i din "
"applikation, särskilt eftersom Python måste ladda biblioteksmoduler som "
"implementeras som dynamiska C-tillägg (:file:`.so`\\-filer) länkade mot den."

#: ../../extending/embedding.rst:290
msgid ""
"To find out the required compiler and linker flags, you can execute the "
":file:`python{X.Y}-config` script which is generated as part of the "
"installation process (a :file:`python3-config` script may also be "
"available).  This script has several options, of which the following will be"
" directly useful to you:"
msgstr ""
"För att ta reda på vilka kompilator- och länkarflaggor som krävs kan du köra"
" skriptet :file:`python{X.Y}-config` som genereras som en del av "
"installationsprocessen (ett skript :file:`python3-config` kan också finnas "
"tillgängligt).  Detta skript har flera alternativ, av vilka följande kommer "
"att vara direkt användbara för dig:"

#: ../../extending/embedding.rst:296
msgid ""
"``pythonX.Y-config --cflags`` will give you the recommended flags when "
"compiling:"
msgstr ""
"``pythonX.Y-config --cflags`` kommer att ge dig de rekommenderade flaggorna "
"vid kompilering:"

#: ../../extending/embedding.rst:304
msgid ""
"``pythonX.Y-config --ldflags`` will give you the recommended flags when "
"linking:"
msgstr ""

#: ../../extending/embedding.rst:313
msgid ""
"To avoid confusion between several Python installations (and especially "
"between the system Python and your own compiled Python), it is recommended "
"that you use the absolute path to :file:`python{X.Y}-config`, as in the "
"above example."
msgstr ""
"För att undvika förväxling mellan olika Python-installationer (och särskilt "
"mellan systemets Python och ditt eget kompilerade Python) rekommenderas att "
"du använder den absoluta sökvägen till :file:`python{X.Y}-config`, som i "
"exemplet ovan."

#: ../../extending/embedding.rst:318
msgid ""
"If this procedure doesn't work for you (it is not guaranteed to work for all"
" Unix-like platforms; however, we welcome :ref:`bug reports <reporting-"
"bugs>`) you will have to read your system's documentation about dynamic "
"linking and/or examine Python's :file:`Makefile` (use "
":func:`sysconfig.get_makefile_filename` to find its location) and "
"compilation options.  In this case, the :mod:`sysconfig` module is a useful "
"tool to programmatically extract the configuration values that you will want"
" to combine together.  For example:"
msgstr ""
"Om den här proceduren inte fungerar för dig (det är inte garanterat att den "
"fungerar för alla Unix-liknande plattformar; vi välkomnar dock :ref:`bug "
"reports <reporting-bugs>`) måste du läsa ditt systems dokumentation om "
"dynamisk länkning och/eller undersöka Pythons :file:`Makefile` (använd "
":func:`sysconfig.get_makefile_filename` för att hitta dess plats) och "
"kompileringsalternativ.  I det här fallet är modulen :mod:`sysconfig` ett "
"användbart verktyg för att programmatiskt extrahera de konfigurationsvärden "
"som du vill kombinera tillsammans.  Till exempel"
