# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# python-doc bot, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-25 16:33+0000\n"
"PO-Revision-Date: 2025-09-22 16:49+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../howto/enum.rst:3
msgid "Enum HOWTO"
msgstr "Enum HOWTO"

#: ../../howto/enum.rst:9
msgid ""
"An :class:`Enum` is a set of symbolic names bound to unique values.  They "
"are similar to global variables, but they offer a more useful "
":func:`repr()`, grouping, type-safety, and a few other features."
msgstr ""

#: ../../howto/enum.rst:13
msgid ""
"They are most useful when you have a variable that can take one of a limited"
" selection of values.  For example, the days of the week::"
msgstr ""
"De är mest användbara när du har en variabel som kan ta ett av ett begränsat"
" urval av värden.  Till exempel veckodagarna::"

#: ../../howto/enum.rst:26
msgid "Or perhaps the RGB primary colors::"
msgstr "Eller kanske RGB-primärfärgerna::"

#: ../../howto/enum.rst:34
msgid ""
"As you can see, creating an :class:`Enum` is as simple as writing a class "
"that inherits from :class:`Enum` itself."
msgstr ""
"Som du kan se är det lika enkelt att skapa en :class:`Enum` som att skriva "
"en klass som ärver från :class:`Enum` själv."

#: ../../howto/enum.rst:37
msgid "Case of Enum Members"
msgstr "Fall med Enum-medlemmar"

#: ../../howto/enum.rst:39
msgid ""
"Because Enums are used to represent constants we recommend using UPPER_CASE "
"names for members, and will be using that style in our examples."
msgstr ""

#: ../../howto/enum.rst:42
msgid ""
"Depending on the nature of the enum a member's value may or may not be "
"important, but either way that value can be used to get the corresponding "
"member::"
msgstr ""
"Beroende på enumets karaktär kan en medlems värde vara viktigt eller inte, "
"men i vilket fall som helst kan det värdet användas för att få motsvarande "
"medlem::"

#: ../../howto/enum.rst:49
msgid ""
"As you can see, the ``repr()`` of a member shows the enum name, the member "
"name, and the value.  The ``str()`` of a member shows only the enum name and"
" member name::"
msgstr ""
"Som du kan se visar ``repr()`` för en medlem enumnamnet, medlemsnamnet och "
"värdet.  ``str()`` för en medlem visar bara enumnamnet och medlemsnamnet::"

#: ../../howto/enum.rst:56
msgid "The *type* of an enumeration member is the enum it belongs to::"
msgstr "*Typen* av en uppräkningsmedlem är den uppräkning som den tillhör::"

#: ../../howto/enum.rst:63
msgid "Enum members have an attribute that contains just their :attr:`name`::"
msgstr ""

#: ../../howto/enum.rst:68
msgid "Likewise, they have an attribute for their :attr:`value`::"
msgstr ""

#: ../../howto/enum.rst:74
msgid ""
"Unlike many languages that treat enumerations solely as name/value pairs, "
"Python Enums can have behavior added.  For example, :class:`datetime.date` "
"has two methods for returning the weekday: :meth:`weekday` and "
":meth:`isoweekday`. The difference is that one of them counts from 0-6 and "
"the other from 1-7. Rather than keep track of that ourselves we can add a "
"method to the :class:`Weekday` enum to extract the day from the "
":class:`date` instance and return the matching enum member::"
msgstr ""

#: ../../howto/enum.rst:86
msgid "The complete :class:`Weekday` enum now looks like this::"
msgstr ""

#: ../../howto/enum.rst:101
msgid "Now we can find out what today is!  Observe::"
msgstr "Nu kan vi ta reda på vad det är för dag!  Observera::"

#: ../../howto/enum.rst:107
msgid ""
"Of course, if you're reading this on some other day, you'll see that day "
"instead."
msgstr ""
"Om du läser det här någon annan dag får du naturligtvis se den dagen i "
"stället."

#: ../../howto/enum.rst:109
msgid ""
"This :class:`Weekday` enum is great if our variable only needs one day, but "
"what if we need several?  Maybe we're writing a function to plot chores "
"during a week, and don't want to use a :class:`list` -- we could use a "
"different type of :class:`Enum`::"
msgstr ""

#: ../../howto/enum.rst:124
msgid ""
"We've changed two things: we're inherited from :class:`Flag`, and the values"
" are all powers of 2."
msgstr ""
"Vi har ändrat två saker: vi ärver från :class:`Flag`, och värdena är alla "
"potenser av 2."

#: ../../howto/enum.rst:127
msgid ""
"Just like the original :class:`Weekday` enum above, we can have a single "
"selection::"
msgstr ""

#: ../../howto/enum.rst:133
msgid ""
"But :class:`Flag` also allows us to combine several members into a single "
"variable::"
msgstr ""
"Men :class:`Flag` tillåter oss också att kombinera flera medlemmar i en enda"
" variabel::"

#: ../../howto/enum.rst:140
msgid "You can even iterate over a :class:`Flag` variable::"
msgstr "Du kan till och med iterera över en :class:`Flag`\\-variabel::"

#: ../../howto/enum.rst:147
msgid "Okay, let's get some chores set up::"
msgstr "Okej, låt oss göra några sysslor::"

#: ../../howto/enum.rst:155
msgid "And a function to display the chores for a given day::"
msgstr "Och en funktion för att visa sysslorna för en viss dag::"

#: ../../howto/enum.rst:164
msgid ""
"In cases where the actual values of the members do not matter, you can save "
"yourself some work and use :func:`auto()` for the values::"
msgstr ""

#: ../../howto/enum.rst:183
msgid "Programmatic access to enumeration members and their attributes"
msgstr "Programmatisk åtkomst till uppräkningsmedlemmar och deras attribut"

#: ../../howto/enum.rst:185
msgid ""
"Sometimes it's useful to access members in enumerations programmatically "
"(i.e. situations where ``Color.RED`` won't do because the exact color is not"
" known at program-writing time).  ``Enum`` allows such access::"
msgstr ""
"Ibland är det användbart att komma åt medlemmar i uppräkningar "
"programmatiskt (t.ex. situationer där ``Color.RED`` inte fungerar eftersom "
"den exakta färgen inte är känd vid programskrivningstillfället).  ``Enum`` "
"tillåter sådan åtkomst::"

#: ../../howto/enum.rst:194
msgid "If you want to access enum members by *name*, use item access::"
msgstr ""
"Om du vill komma åt enum-medlemmar med *namn* använder du item access::"

#: ../../howto/enum.rst:201
msgid ""
"If you have an enum member and need its :attr:`name` or :attr:`value`::"
msgstr ""

#: ../../howto/enum.rst:211
msgid "Duplicating enum members and values"
msgstr "Duplicering av enum-medlemmar och -värden"

#: ../../howto/enum.rst:213
msgid "Having two enum members with the same name is invalid::"
msgstr "Att ha två enum-medlemmar med samma namn är ogiltigt:"

#: ../../howto/enum.rst:223
msgid ""
"However, an enum member can have other names associated with it.  Given two "
"entries ``A`` and ``B`` with the same value (and ``A`` defined first), ``B``"
" is an alias for the member ``A``.  By-value lookup of the value of ``A`` "
"will return the member ``A``.  By-name lookup of ``A`` will return the "
"member ``A``. By-name lookup of ``B`` will also return the member ``A``::"
msgstr ""
"En enum-medlem kan dock ha andra namn associerade med sig.  Givet två poster"
" ``A`` och ``B`` med samma värde (och ``A`` definierad först), är ``B`` ett "
"alias för medlemmen ``A``.  By-value lookup av värdet på ``A`` kommer att "
"returnera medlemmen ``A``.  By-name lookup av ``A`` kommer att returnera "
"medlemmen ``A``. By-name lookup av ``B`` kommer också att returnera "
"medlemmen ``A``::"

#: ../../howto/enum.rst:244
msgid ""
"Attempting to create a member with the same name as an already defined "
"attribute (another member, a method, etc.) or attempting to create an "
"attribute with the same name as a member is not allowed."
msgstr ""
"Det är inte tillåtet att försöka skapa en medlem med samma namn som ett "
"redan definierat attribut (en annan medlem, en metod etc.) eller att försöka"
" skapa ett attribut med samma namn som en medlem."

#: ../../howto/enum.rst:250
msgid "Ensuring unique enumeration values"
msgstr "Säkerställa unika uppräkningsvärden"

#: ../../howto/enum.rst:252
msgid ""
"By default, enumerations allow multiple names as aliases for the same value."
" When this behavior isn't desired, you can use the :func:`unique` "
"decorator::"
msgstr ""
"Som standard tillåter uppräkningar flera namn som alias för samma värde. När"
" detta beteende inte är önskvärt kan du använda :func:`unique` dekoratorn::"

#: ../../howto/enum.rst:269
msgid "Using automatic values"
msgstr "Använda automatiska värden"

#: ../../howto/enum.rst:271
msgid "If the exact value is unimportant you can use :class:`auto`::"
msgstr "Om det exakta värdet är oviktigt kan du använda :class:`auto`::"

#: ../../howto/enum.rst:282
msgid ""
"The values are chosen by :func:`_generate_next_value_`, which can be "
"overridden::"
msgstr ""

#: ../../howto/enum.rst:300
msgid ""
"The :meth:`_generate_next_value_` method must be defined before any members."
msgstr ""

#: ../../howto/enum.rst:303
msgid "Iteration"
msgstr "Iteration"

#: ../../howto/enum.rst:305
msgid "Iterating over the members of an enum does not provide the aliases::"
msgstr "Iterering över medlemmarna i ett enum ger inte alias::"

#: ../../howto/enum.rst:312
msgid ""
"Note that the aliases ``Shape.ALIAS_FOR_SQUARE`` and ``Weekday.WEEKEND`` "
"aren't shown."
msgstr ""
"Observera att aliasen ``Shape.ALIAS_FOR_SQUARE`` och ``Weekday.WEEKEND`` "
"inte visas."

#: ../../howto/enum.rst:314
msgid ""
"The special attribute ``__members__`` is a read-only ordered mapping of "
"names to members.  It includes all names defined in the enumeration, "
"including the aliases::"
msgstr ""
"Specialattributet ``__members__`` är en skrivskyddad ordnad mappning av namn"
" till medlemmar.  Den innehåller alla namn som definieras i uppräkningen, "
"inklusive alias::"

#: ../../howto/enum.rst:326
msgid ""
"The ``__members__`` attribute can be used for detailed programmatic access "
"to the enumeration members.  For example, finding all the aliases::"
msgstr ""
"Attributet ``__members__`` kan användas för detaljerad programmatisk åtkomst"
" till uppräkningens medlemmar.  Till exempel, hitta alla alias::"

#: ../../howto/enum.rst:334
msgid ""
"Aliases for flags include values with multiple flags set, such as ``3``, and"
" no flags set, i.e. ``0``."
msgstr ""
"Alias för flaggor inkluderar värden med flera flaggor inställda, t.ex. "
"``3``, och inga flaggor inställda, t.ex. ``0``."

#: ../../howto/enum.rst:339
msgid "Comparisons"
msgstr "Jämförelser"

#: ../../howto/enum.rst:341
msgid "Enumeration members are compared by identity::"
msgstr "Uppräkningens medlemmar jämförs med hjälp av identity::"

#: ../../howto/enum.rst:350
msgid ""
"Ordered comparisons between enumeration values are *not* supported.  Enum "
"members are not integers (but see `IntEnum`_ below)::"
msgstr ""
"Ordnade jämförelser mellan enumerationsvärden stöds *inte*.  Enum-medlemmar "
"är inte heltal (men se `IntEnum`_ nedan)::"

#: ../../howto/enum.rst:358
msgid "Equality comparisons are defined though::"
msgstr "Jämlikhetsjämförelser definieras genom::"

#: ../../howto/enum.rst:367
msgid ""
"Comparisons against non-enumeration values will always compare not equal "
"(again, :class:`IntEnum` was explicitly designed to behave differently, see "
"below)::"
msgstr ""
"Jämförelser mot värden som inte är uppräkningsvärden kommer alltid att "
"jämföra inte lika (återigen, :class:`IntEnum` var uttryckligen utformad för "
"att bete sig annorlunda, se nedan)::"

#: ../../howto/enum.rst:376
msgid ""
"It is possible to reload modules -- if a reloaded module contains enums, "
"they will be recreated, and the new members may not compare identical/equal "
"to the original members."
msgstr ""
"Det är möjligt att ladda om moduler - om en omladdad modul innehåller enumer"
" kommer de att återskapas, och de nya medlemmarna kanske inte är "
"identiska/likvärdiga med de ursprungliga medlemmarna."

#: ../../howto/enum.rst:381
msgid "Allowed members and attributes of enumerations"
msgstr "Tillåtna medlemmar och attribut för uppräkningar"

#: ../../howto/enum.rst:383
msgid ""
"Most of the examples above use integers for enumeration values.  Using "
"integers is short and handy (and provided by default by the `Functional "
"API`_), but not strictly enforced.  In the vast majority of use-cases, one "
"doesn't care what the actual value of an enumeration is.  But if the value "
"*is* important, enumerations can have arbitrary values."
msgstr ""
"I de flesta av exemplen ovan används heltal för uppräkningsvärden.  Att "
"använda heltal är kort och praktiskt (och tillhandahålls som standard av "
"`Functional API`_), men inte strikt påtvingat.  I de allra flesta "
"användningsfall bryr man sig inte om vad det faktiska värdet på en "
"uppräkning är.  Men om värdet *är* viktigt kan uppräkningar ha godtyckliga "
"värden."

#: ../../howto/enum.rst:389
msgid ""
"Enumerations are Python classes, and can have methods and special methods as"
" usual.  If we have this enumeration::"
msgstr ""
"Uppräkningar är Python-klasser, och kan ha metoder och specialmetoder som "
"vanligt.  Om vi har den här uppräkningen::"

#: ../../howto/enum.rst:409
msgid "Then::"
msgstr "Sedan::"

#: ../../howto/enum.rst:418
msgid ""
"The rules for what is allowed are as follows: names that start and end with "
"a single underscore are reserved by enum and cannot be used; all other "
"attributes defined within an enumeration will become members of this "
"enumeration, with the exception of special methods (:meth:`__str__`, "
":meth:`__add__`, etc.), descriptors (methods are also descriptors), and "
"variable names listed in :attr:`_ignore_`."
msgstr ""

#: ../../howto/enum.rst:425
msgid ""
"Note:  if your enumeration defines :meth:`__new__` and/or :meth:`__init__`, "
"any value(s) given to the enum member will be passed into those methods. See"
" `Planet`_ for an example."
msgstr ""

#: ../../howto/enum.rst:431
msgid ""
"The :meth:`__new__` method, if defined, is used during creation of the Enum "
"members; it is then replaced by Enum's :meth:`__new__` which is used after "
"class creation for lookup of existing members.  See :ref:`new-vs-init` for "
"more details."
msgstr ""

#: ../../howto/enum.rst:438
msgid "Restricted Enum subclassing"
msgstr "Begränsad subklassning av Enum"

#: ../../howto/enum.rst:440
msgid ""
"A new :class:`Enum` class must have one base enum class, up to one concrete "
"data type, and as many :class:`object`-based mixin classes as needed.  The "
"order of these base classes is::"
msgstr ""
"En ny :class:`Enum`\\-klass måste ha en bas-enumklass, upp till en konkret "
"datatyp och så många :class:`object`\\-baserade mixin-klasser som behövs.  "
"Ordningen på dessa basklasser är::"

#: ../../howto/enum.rst:447
msgid ""
"Also, subclassing an enumeration is allowed only if the enumeration does not"
" define any members.  So this is forbidden::"
msgstr ""
"Dessutom är subklassning av en uppräkning endast tillåten om uppräkningen "
"inte definierar några medlemmar.  Så detta är förbjudet::"

#: ../../howto/enum.rst:457
msgid "But this is allowed::"
msgstr "Men detta är tillåtet::"

#: ../../howto/enum.rst:468
msgid ""
"Allowing subclassing of enums that define members would lead to a violation "
"of some important invariants of types and instances.  On the other hand, it "
"makes sense to allow sharing some common behavior between a group of "
"enumerations. (See `OrderedEnum`_ for an example.)"
msgstr ""
"Att tillåta subklassning av enumerationer som definierar medlemmar skulle "
"leda till ett brott mot några viktiga invarianter av typer och instanser.  Å"
" andra sidan är det vettigt att tillåta att en grupp av uppräkningar delar "
"vissa gemensamma beteenden. (Se `OrderedEnum`_ för ett exempel.)"

#: ../../howto/enum.rst:475
msgid "Pickling"
msgstr "Inläggning"

#: ../../howto/enum.rst:477
msgid "Enumerations can be pickled and unpickled::"
msgstr "Uppräkningar kan vara inlagda och oinlagda::"

#: ../../howto/enum.rst:484
msgid ""
"The usual restrictions for pickling apply: picklable enums must be defined "
"in the top level of a module, since unpickling requires them to be "
"importable from that module."
msgstr ""
"De vanliga restriktionerna för pickling gäller: picklbara enumer måste "
"definieras på den översta nivån i en modul, eftersom unpickling kräver att "
"de kan importeras från den modulen."

#: ../../howto/enum.rst:490
msgid ""
"With pickle protocol version 4 it is possible to easily pickle enums nested "
"in other classes."
msgstr ""
"Med pickle protocol version 4 är det möjligt att enkelt plocka enumer som är"
" inbäddade i andra klasser."

#: ../../howto/enum.rst:493
msgid ""
"It is possible to modify how enum members are pickled/unpickled by defining "
":meth:`__reduce_ex__` in the enumeration class.  The default method is by-"
"value, but enums with complicated values may want to use by-name::"
msgstr ""

#: ../../howto/enum.rst:503
msgid ""
"Using by-name for flags is not recommended, as unnamed aliases will not "
"unpickle."
msgstr ""
"Att använda by-name för flaggor rekommenderas inte, eftersom icke namngivna "
"alias inte kommer att unpickle."

#: ../../howto/enum.rst:508
msgid "Functional API"
msgstr "Funktionellt API"

#: ../../howto/enum.rst:510
msgid ""
"The :class:`Enum` class is callable, providing the following functional "
"API::"
msgstr ""
"Klassen :class:`Enum` är anropsbar och tillhandahåller följande funktionella"
" API::"

#: ../../howto/enum.rst:520
msgid ""
"The semantics of this API resemble :class:`~collections.namedtuple`. The "
"first argument of the call to :class:`Enum` is the name of the enumeration."
msgstr ""
"Semantiken för detta API liknar :class:`~collections.namedtuple`. Det första"
" argumentet i anropet till :class:`Enum` är namnet på uppräkningen."

#: ../../howto/enum.rst:523
msgid ""
"The second argument is the *source* of enumeration member names.  It can be "
"a whitespace-separated string of names, a sequence of names, a sequence of "
"2-tuples with key/value pairs, or a mapping (e.g. dictionary) of names to "
"values.  The last two options enable assigning arbitrary values to "
"enumerations; the others auto-assign increasing integers starting with 1 "
"(use the ``start`` parameter to specify a different starting value).  A new "
"class derived from :class:`Enum` is returned.  In other words, the above "
"assignment to :class:`Animal` is equivalent to::"
msgstr ""

#: ../../howto/enum.rst:539
msgid ""
"The reason for defaulting to ``1`` as the starting number and not ``0`` is "
"that ``0`` is ``False`` in a boolean sense, but by default enum members all "
"evaluate to ``True``."
msgstr ""
"Anledningen till att startnumret som standard är ``1`` och inte ``0`` är att"
" ``0`` är ``False`` i boolesk mening, men som standard utvärderas alla enum-"
"medlemmar till ``True``."

#: ../../howto/enum.rst:543
msgid ""
"Pickling enums created with the functional API can be tricky as frame stack "
"implementation details are used to try and figure out which module the "
"enumeration is being created in (e.g. it will fail if you use a utility "
"function in a separate module, and also may not work on IronPython or "
"Jython). The solution is to specify the module name explicitly as follows::"
msgstr ""
"Pickling av uppräkningar som skapats med det funktionella API:et kan vara "
"knepigt eftersom implementeringsdetaljer för ramstacken används för att "
"försöka lista ut vilken modul uppräkningen skapas i (t.ex. kommer det att "
"misslyckas om du använder en verktygsfunktion i en separat modul, och kanske"
" inte heller fungerar på IronPython eller Jython). Lösningen är att ange "
"modulnamnet explicit enligt följande::"

#: ../../howto/enum.rst:553
msgid ""
"If ``module`` is not supplied, and Enum cannot determine what it is, the new"
" Enum members will not be unpicklable; to keep errors closer to the source, "
"pickling will be disabled."
msgstr ""
"Om ``module`` inte anges, och Enum inte kan avgöra vad det är, kommer de nya"
" Enum-medlemmarna inte att vara obearbetbara; för att hålla felen närmare "
"källan kommer bearbetningen att avaktiveras."

#: ../../howto/enum.rst:557
msgid ""
"The new pickle protocol 4 also, in some circumstances, relies on "
":attr:`~definition.__qualname__` being set to the location where pickle will"
" be able to find the class.  For example, if the class was made available in"
" class SomeData in the global scope::"
msgstr ""

#: ../../howto/enum.rst:564
msgid "The complete signature is::"
msgstr "Den fullständiga signaturen är::"

#: ../../howto/enum.rst:576
msgid "*value*: What the new enum class will record as its name."
msgstr ""
"*value*: Det som den nya enumklassen kommer att registrera som sitt namn."

#: ../../howto/enum.rst:578
msgid ""
"*names*: The enum members.  This can be a whitespace- or comma-separated "
"string (values will start at 1 unless otherwise specified)::"
msgstr ""
"*namn*: Enumets medlemmar.  Detta kan vara en sträng separerad med blanksteg"
" eller kommatecken (värdena börjar på 1 om inget annat anges)::"

#: ../../howto/enum.rst:583
msgid "or an iterator of names::"
msgstr "eller en iterator av namn::"

#: ../../howto/enum.rst:587
msgid "or an iterator of (name, value) pairs::"
msgstr "eller en iterator av (namn, värde)-par::"

#: ../../howto/enum.rst:591
msgid "or a mapping::"
msgstr "eller en mappning::"

#: ../../howto/enum.rst:595
msgid "*module*: name of module where new enum class can be found."
msgstr "*module*: namn på modul där ny enumklass kan hittas."

#: ../../howto/enum.rst:597
msgid "*qualname*: where in module new enum class can be found."
msgstr "*qualname*: var i modulen den nya enumklassen kan hittas."

#: ../../howto/enum.rst:599
msgid "*type*: type to mix in to new enum class."
msgstr "*type*: typ att blanda in i ny enumklass."

#: ../../howto/enum.rst:601
msgid "*start*: number to start counting at if only names are passed in."
msgstr "*start*: nummer att börja räkna med om endast namn skickas in."

#: ../../howto/enum.rst:603
msgid "The *start* parameter was added."
msgstr "Parametern *start* har lagts till."

#: ../../howto/enum.rst:608
msgid "Derived Enumerations"
msgstr "Härledda uppräkningar"

#: ../../howto/enum.rst:611
msgid "IntEnum"
msgstr "IntEnum"

#: ../../howto/enum.rst:613
msgid ""
"The first variation of :class:`Enum` that is provided is also a subclass of "
":class:`int`.  Members of an :class:`IntEnum` can be compared to integers; "
"by extension, integer enumerations of different types can also be compared "
"to each other::"
msgstr ""
"Den första varianten av :class:`Enum` som tillhandahålls är också en "
"subklass av :class:`int`.  Medlemmar i en :class:`IntEnum` kan jämföras med "
"heltal; efter utökning kan heltalsuppräkningar av olika typer också jämföras"
" med varandra::"

#: ../../howto/enum.rst:634
msgid ""
"However, they still can't be compared to standard :class:`Enum` "
"enumerations::"
msgstr ""
"De kan dock fortfarande inte jämföras med vanliga "
":class:`Enum`\\-uppräkningar::"

#: ../../howto/enum.rst:647
msgid ""
":class:`IntEnum` values behave like integers in other ways you'd expect::"
msgstr ""
":class:`IntEnum`\\-värden beter sig som heltal på andra sätt som du kan "
"förvänta dig::"

#: ../../howto/enum.rst:658
msgid "StrEnum"
msgstr "StrEnum"

#: ../../howto/enum.rst:660
msgid ""
"The second variation of :class:`Enum` that is provided is also a subclass of"
" :class:`str`.  Members of a :class:`StrEnum` can be compared to strings; by"
" extension, string enumerations of different types can also be compared to "
"each other."
msgstr ""
"Den andra varianten av :class:`Enum` som tillhandahålls är också en subklass"
" av :class:`str`.  Medlemmar i en :class:`StrEnum` kan jämföras med "
"strängar; i förlängningen kan stränguppräkningar av olika typer också "
"jämföras med varandra."

#: ../../howto/enum.rst:669
msgid "IntFlag"
msgstr "IntFlag"

#: ../../howto/enum.rst:671
msgid ""
"The next variation of :class:`Enum` provided, :class:`IntFlag`, is also "
"based on :class:`int`.  The difference being :class:`IntFlag` members can be"
" combined using the bitwise operators (&, \\|, ^, ~) and the result is still"
" an :class:`IntFlag` member, if possible.  Like :class:`IntEnum`, "
":class:`IntFlag` members are also integers and can be used wherever an "
":class:`int` is used."
msgstr ""
"Nästa variant av :class:`Enum` som tillhandahålls, :class:`IntFlag`, är "
"också baserad på :class:`int`.  Skillnaden är att "
":class:`IntFlag`\\-medlemmar kan kombineras med hjälp av bitvisa operatorer "
"(&, \\|, ^, ~) och resultatet är fortfarande en :class:`IntFlag`\\-medlem, "
"om möjligt.  Liksom :class:`IntEnum` är :class:`IntFlag`\\-medlemmar också "
"heltal och kan användas var som helst där en :class:`int` används."

#: ../../howto/enum.rst:679
msgid ""
"Any operation on an :class:`IntFlag` member besides the bit-wise operations "
"will lose the :class:`IntFlag` membership."
msgstr ""
"Alla operationer på en :class:`IntFlag`\\-medlem förutom de bitvisa "
"operationerna kommer att förlora :class:`IntFlag`\\-medlemskapet."

#: ../../howto/enum.rst:682
msgid ""
"Bit-wise operations that result in invalid :class:`IntFlag` values will lose"
" the :class:`IntFlag` membership.  See :class:`FlagBoundary` for details."
msgstr ""
"Bitvisa operationer som resulterar i ogiltiga :class:`IntFlag`\\-värden "
"kommer att förlora :class:`IntFlag`\\-medlemskapet.  Se "
":class:`FlagBoundary` för detaljer."

#: ../../howto/enum.rst:689
msgid "Sample :class:`IntFlag` class::"
msgstr "Exempel :class:`IntFlag` klass::"

#: ../../howto/enum.rst:705
msgid "It is also possible to name the combinations::"
msgstr "Det är också möjligt att namnge kombinationerna::"

#: ../../howto/enum.rst:721
msgid ""
"Named combinations are considered aliases.  Aliases do not show up during "
"iteration, but can be returned from by-value lookups."
msgstr ""
"Namngivna kombinationer betraktas som alias.  Alias visas inte under "
"iteration, men kan returneras från by-value-uppslagningar."

#: ../../howto/enum.rst:726
msgid ""
"Another important difference between :class:`IntFlag` and :class:`Enum` is "
"that if no flags are set (the value is 0), its boolean evaluation is "
":data:`False`::"
msgstr ""
"En annan viktig skillnad mellan :class:`IntFlag` och :class:`Enum` är att om"
" inga flaggor är inställda (värdet är 0), är dess booleska utvärdering "
":data:`False`::"

#: ../../howto/enum.rst:734
msgid ""
"Because :class:`IntFlag` members are also subclasses of :class:`int` they "
"can be combined with them (but may lose :class:`IntFlag` membership::"
msgstr ""
"Eftersom :class:`IntFlag`\\-medlemmar också är underklasser till "
":class:`int` kan de kombineras med dem (men kan förlora "
":class:`IntFlag`\\-medlemskap::"

#: ../../howto/enum.rst:745
msgid ""
"The negation operator, ``~``, always returns an :class:`IntFlag` member with"
" a positive value::"
msgstr ""
"Negationsoperatorn, ``~``, returnerar alltid en :class:`IntFlag`\\-medlem "
"med ett positivt värde::"

#: ../../howto/enum.rst:751
msgid ":class:`IntFlag` members can also be iterated over::"
msgstr ":class:`IntFlag`\\-medlemmar kan också itereras över::"

#: ../../howto/enum.rst:760
msgid "Flag"
msgstr "Flagga"

#: ../../howto/enum.rst:762
msgid ""
"The last variation is :class:`Flag`.  Like :class:`IntFlag`, :class:`Flag` "
"members can be combined using the bitwise operators (&, \\|, ^, ~).  Unlike "
":class:`IntFlag`, they cannot be combined with, nor compared against, any "
"other :class:`Flag` enumeration, nor :class:`int`.  While it is possible to "
"specify the values directly it is recommended to use :class:`auto` as the "
"value and let :class:`Flag` select an appropriate value."
msgstr ""
"Den sista variationen är :class:`Flag`.  Liksom :class:`IntFlag` kan "
":class:`Flag`\\-medlemmar kombineras med hjälp av bitvisa operatorer (&, "
"\\|, ^, ~).  Till skillnad från :class:`IntFlag` kan de inte kombineras med,"
" eller jämföras mot, någon annan :class:`Flag`\\-uppräkning, eller "
":class:`int`.  Det är möjligt att ange värdena direkt, men det rekommenderas"
" att använda :class:`auto` som värde och låta :class:`Flag` välja ett "
"lämpligt värde."

#: ../../howto/enum.rst:771
msgid ""
"Like :class:`IntFlag`, if a combination of :class:`Flag` members results in "
"no flags being set, the boolean evaluation is :data:`False`::"
msgstr ""
"Liksom :class:`IntFlag`, om en kombination av :class:`Flag`\\-medlemmar "
"resulterar i att inga flaggor sätts, är den booleska utvärderingen "
":data:`False`::"

#: ../../howto/enum.rst:785
msgid ""
"Individual flags should have values that are powers of two (1, 2, 4, 8, "
"...), while combinations of flags will not::"
msgstr ""
"Enskilda flaggor bör ha värden som är potenser av två (1, 2, 4, 8, ...), "
"medan kombinationer av flaggor inte kommer att ha det:"

#: ../../howto/enum.rst:797
msgid ""
"Giving a name to the \"no flags set\" condition does not change its boolean "
"value::"
msgstr ""
"Att ge ett namn till villkoret \"inga flaggor satta\" ändrar inte dess "
"booleska värde::"

#: ../../howto/enum.rst:811
msgid ":class:`Flag` members can also be iterated over::"
msgstr ":class:`Flag`\\-medlemmar kan också itereras över::"

#: ../../howto/enum.rst:821
msgid ""
"For the majority of new code, :class:`Enum` and :class:`Flag` are strongly "
"recommended, since :class:`IntEnum` and :class:`IntFlag` break some semantic"
" promises of an enumeration (by being comparable to integers, and thus by "
"transitivity to other unrelated enumerations).  :class:`IntEnum` and "
":class:`IntFlag` should be used only in cases where :class:`Enum` and "
":class:`Flag` will not do; for example, when integer constants are replaced "
"with enumerations, or for interoperability with other systems."
msgstr ""
"För majoriteten av ny kod rekommenderas :class:`Enum` och :class:`Flag` "
"starkt, eftersom :class:`IntEnum` och :class:`IntFlag` bryter några "
"semantiska löften om en uppräkning (genom att vara jämförbara med heltal, "
"och därmed genom transitivitet till andra orelaterade uppräkningar).  "
":class:`IntEnum` och :class:`IntFlag` bör endast användas i de fall där "
":class:`Enum` och :class:`Flag` inte räcker till; till exempel när "
"heltalskonstanter ersätts med uppräkningar, eller för interoperabilitet med "
"andra system."

#: ../../howto/enum.rst:831
msgid "Others"
msgstr "Andra"

#: ../../howto/enum.rst:833
msgid ""
"While :class:`IntEnum` is part of the :mod:`enum` module, it would be very "
"simple to implement independently::"
msgstr ""
"Medan :class:`IntEnum` är en del av :mod:`enum`\\-modulen, skulle det vara "
"mycket enkelt att implementera oberoende::"

#: ../../howto/enum.rst:839
msgid ""
"This demonstrates how similar derived enumerations can be defined; for "
"example a :class:`FloatEnum` that mixes in :class:`float` instead of "
":class:`int`."
msgstr ""

#: ../../howto/enum.rst:842
msgid "Some rules:"
msgstr "Vissa regler:"

#: ../../howto/enum.rst:844
msgid ""
"When subclassing :class:`Enum`, mix-in types must appear before "
":class:`Enum` itself in the sequence of bases, as in the :class:`IntEnum` "
"example above."
msgstr ""

#: ../../howto/enum.rst:847
msgid ""
"Mix-in types must be subclassable. For example, :class:`bool` and "
":class:`range` are not subclassable and will throw an error during Enum "
"creation if used as the mix-in type."
msgstr ""
"Mix-in-typer måste vara underklassbara. Till exempel är :class:`bool` och "
":class:`range` inte underklassbara och kommer att ge ett felmeddelande under"
" skapandet av Enum om de används som mix-in-typ."

#: ../../howto/enum.rst:850
msgid ""
"While :class:`Enum` can have members of any type, once you mix in an "
"additional type, all the members must have values of that type, e.g. "
":class:`int` above.  This restriction does not apply to mix-ins which only "
"add methods and don't specify another type."
msgstr ""
"Medan :class:`Enum` kan ha medlemmar av vilken typ som helst, måste alla "
"medlemmar ha värden av den typen när du blandar in en ytterligare typ, t.ex."
" :class:`int` ovan.  Denna begränsning gäller inte för mix-ins som bara "
"lägger till metoder och inte anger någon annan typ."

#: ../../howto/enum.rst:854
msgid ""
"When another data type is mixed in, the :attr:`value` attribute is *not the "
"same* as the enum member itself, although it is equivalent and will compare "
"equal."
msgstr ""

#: ../../howto/enum.rst:857
msgid "A ``data type`` is a mixin that defines :meth:`__new__`."
msgstr ""

#: ../../howto/enum.rst:858
msgid ""
"%-style formatting:  ``%s`` and ``%r`` call the :class:`Enum` class's "
":meth:`__str__` and :meth:`__repr__` respectively; other codes (such as "
"``%i`` or ``%h`` for IntEnum) treat the enum member as its mixed-in type."
msgstr ""

#: ../../howto/enum.rst:861
msgid ""
":ref:`Formatted string literals <f-strings>`, :meth:`str.format`, and "
":func:`format` will use the enum's :meth:`__str__` method."
msgstr ""

#: ../../howto/enum.rst:866
msgid ""
"Because :class:`IntEnum`, :class:`IntFlag`, and :class:`StrEnum` are "
"designed to be drop-in replacements for existing constants, their "
":meth:`__str__` method has been reset to their data types' :meth:`__str__` "
"method."
msgstr ""

#: ../../howto/enum.rst:874
msgid "When to use :meth:`__new__` vs. :meth:`__init__`"
msgstr ""

#: ../../howto/enum.rst:876
msgid ""
":meth:`__new__` must be used whenever you want to customize the actual value"
" of the :class:`Enum` member.  Any other modifications may go in either "
":meth:`__new__` or :meth:`__init__`, with :meth:`__init__` being preferred."
msgstr ""

#: ../../howto/enum.rst:880
msgid ""
"For example, if you want to pass several items to the constructor, but only "
"want one of them to be the value::"
msgstr ""
"Om du t.ex. vill skicka flera objekt till konstruktören, men bara vill att "
"ett av dem ska vara värdet::"

#: ../../howto/enum.rst:907
msgid ""
"*Do not* call ``super().__new__()``, as the lookup-only ``__new__`` is the "
"one that is found; instead, use the data type directly."
msgstr ""
"Anropa *inte* ``super().__new__()``, eftersom det är ``__new__`` som bara "
"hittas vid uppslagning; använd i stället datatypen direkt."

#: ../../howto/enum.rst:912
msgid "Finer Points"
msgstr "Finare punkter"

#: ../../howto/enum.rst:915
msgid "Supported ``__dunder__`` names"
msgstr "Namn som stöds för ``__dunder__``"

#: ../../howto/enum.rst:917
msgid ""
":attr:`__members__` is a read-only ordered mapping of "
"``member_name``:``member`` items.  It is only available on the class."
msgstr ""

#: ../../howto/enum.rst:920
msgid ""
":meth:`__new__`, if specified, must create and return the enum members; it "
"is also a very good idea to set the member's :attr:`_value_` appropriately."
"  Once all the members are created it is no longer used."
msgstr ""

#: ../../howto/enum.rst:926
msgid "Supported ``_sunder_`` names"
msgstr "Namn med stöd för ``_sunder_``"

#: ../../howto/enum.rst:928
msgid "``_name_`` -- name of the member"
msgstr ""

#: ../../howto/enum.rst:929
msgid ""
"``_value_`` -- value of the member; can be set / modified in ``__new__``"
msgstr ""

#: ../../howto/enum.rst:931
msgid ""
"``_missing_`` -- a lookup function used when a value is not found; may be "
"overridden"
msgstr ""

#: ../../howto/enum.rst:933
msgid ""
"``_ignore_`` -- a list of names, either as a :class:`list` or a "
":class:`str`, that will not be transformed into members, and will be removed"
" from the final class"
msgstr ""

#: ../../howto/enum.rst:936
msgid ""
"``_order_`` -- used in Python 2/3 code to ensure member order is consistent "
"(class attribute, removed during class creation)"
msgstr ""

#: ../../howto/enum.rst:938
msgid ""
"``_generate_next_value_`` -- used by the `Functional API`_ and by "
":class:`auto` to get an appropriate value for an enum member; may be "
"overridden"
msgstr ""

#: ../../howto/enum.rst:944
msgid ""
"For standard :class:`Enum` classes the next value chosen is the last value "
"seen incremented by one."
msgstr ""

#: ../../howto/enum.rst:947
msgid ""
"For :class:`Flag` classes the next value chosen will be the next highest "
"power-of-two, regardless of the last value seen."
msgstr ""

#: ../../howto/enum.rst:950
msgid "``_missing_``, ``_order_``, ``_generate_next_value_``"
msgstr "``_missing_``, ``_order_``, ``_generate_next_value_``"

#: ../../howto/enum.rst:951
msgid "``_ignore_``"
msgstr "``_ignore_``"

#: ../../howto/enum.rst:953
msgid ""
"To help keep Python 2 / Python 3 code in sync an :attr:`_order_` attribute "
"can be provided.  It will be checked against the actual order of the "
"enumeration and raise an error if the two do not match::"
msgstr ""

#: ../../howto/enum.rst:971
msgid ""
"In Python 2 code the :attr:`_order_` attribute is necessary as definition "
"order is lost before it can be recorded."
msgstr ""

#: ../../howto/enum.rst:976
msgid "_Private__names"
msgstr "_Private__names"

#: ../../howto/enum.rst:978
msgid ""
":ref:`Private names <private-name-mangling>` are not converted to enum "
"members, but remain normal attributes."
msgstr ""
":ref:`Privata namn <private-name-mangling>` konverteras inte till enum-"
"medlemmar, utan förblir normala attribut."

#: ../../howto/enum.rst:985
msgid "``Enum`` member type"
msgstr "``Enum`` medlemstyp"

#: ../../howto/enum.rst:987
msgid ""
"Enum members are instances of their enum class, and are normally accessed as"
" ``EnumClass.member``.  In certain situations, such as writing custom enum "
"behavior, being able to access one member directly from another is useful, "
"and is supported."
msgstr ""

#: ../../howto/enum.rst:996
msgid "Creating members that are mixed with other data types"
msgstr "Skapa medlemmar som blandas med andra datatyper"

#: ../../howto/enum.rst:998
msgid ""
"When subclassing other data types, such as :class:`int` or :class:`str`, "
"with an :class:`Enum`, all values after the ``=`` are passed to that data "
"type's constructor.  For example::"
msgstr ""
"När man subklassar andra datatyper, t.ex. :class:`int` eller :class:`str`, "
"med :class:`Enum`, skickas alla värden efter ``=`` till datatypens "
"konstruktör.  Till exempel::"

#: ../../howto/enum.rst:1010
msgid "Boolean value of ``Enum`` classes and members"
msgstr "Booleskt värde för klasser och medlemmar i ``Enum``"

#: ../../howto/enum.rst:1012
msgid ""
"Enum classes that are mixed with non-:class:`Enum` types (such as "
":class:`int`, :class:`str`, etc.) are evaluated according to the mixed-in "
"type's rules; otherwise, all members evaluate as :data:`True`.  To make your"
" own enum's boolean evaluation depend on the member's value add the "
"following to your class::"
msgstr ""
"Enumklasser som blandas med non-:class:`Enum` -typer (t.ex. :class:`int`, "
":class:`str`, etc.) utvärderas enligt den blandade typens regler; annars "
"utvärderas alla medlemmar som :data:`True`.  För att göra din egen enums "
"booleska utvärdering beroende av medlemmens värde, lägg till följande i din "
"klass::"

#: ../../howto/enum.rst:1021
msgid "Plain :class:`Enum` classes always evaluate as :data:`True`."
msgstr "Vanliga :class:`Enum`\\-klasser utvärderas alltid som :data:`True`."

#: ../../howto/enum.rst:1025
msgid "``Enum`` classes with methods"
msgstr "``Enum`` klasser med metoder"

#: ../../howto/enum.rst:1027
msgid ""
"If you give your enum subclass extra methods, like the `Planet`_ class "
"below, those methods will show up in a :func:`dir` of the member, but not of"
" the class::"
msgstr ""
"Om du ger din enum-underklass extra metoder, som klassen `Planet`_ nedan, "
"kommer dessa metoder att dyka upp i en :func:`dir` för medlemmen, men inte "
"för klassen::"

#: ../../howto/enum.rst:1038
msgid "Combining members of ``Flag``"
msgstr "Kombinerar medlemmar av ``Flag``"

#: ../../howto/enum.rst:1040
msgid ""
"Iterating over a combination of :class:`Flag` members will only return the "
"members that are comprised of a single bit::"
msgstr ""
"Iterering över en kombination av :class:`Flag`\\-medlemmar kommer endast att"
" returnera de medlemmar som består av en enda bit::"

#: ../../howto/enum.rst:1058
msgid "``Flag`` and ``IntFlag`` minutia"
msgstr "minutia för \"Flagg\" och \"IntFlagg"

#: ../../howto/enum.rst:1060
msgid "Using the following snippet for our examples::"
msgstr "Använd följande snutt för våra exempel::"

#: ../../howto/enum.rst:1071
msgid "the following are true:"
msgstr "följande är sant:"

#: ../../howto/enum.rst:1073
msgid "single-bit flags are canonical"
msgstr "enbitsflaggor är kanoniska"

#: ../../howto/enum.rst:1074
msgid "multi-bit and zero-bit flags are aliases"
msgstr "multibit- och nollbitflaggor är alias"

#: ../../howto/enum.rst:1075
msgid "only canonical flags are returned during iteration::"
msgstr "endast kanoniska flaggor returneras under iteration::"

#: ../../howto/enum.rst:1080
msgid ""
"negating a flag or flag set returns a new flag/flag set with the "
"corresponding positive integer value::"
msgstr ""
"negering av en flagga eller flagguppsättning ger en ny "
"flagga/flagguppsättning med motsvarande positiva heltalsvärde::"

#: ../../howto/enum.rst:1089
msgid "names of pseudo-flags are constructed from their members' names::"
msgstr "namn på pseudoflaggor konstrueras från deras medlemmars namn::"

#: ../../howto/enum.rst:1094
msgid "multi-bit flags, aka aliases, can be returned from operations::"
msgstr "multi-bit flaggor, aka alias, kan returneras från operationer::"

#: ../../howto/enum.rst:1105
msgid ""
"membership / containment checking: zero-valued flags are always considered "
"to be contained::"
msgstr ""
"kontroll av medlemskap / inneslutning: nollvärdesflaggor anses alltid vara "
"inneslutna::"

#: ../../howto/enum.rst:1111
msgid ""
"otherwise, only if all bits of one flag are in the other flag will True be "
"returned::"
msgstr ""
"annars, endast om alla bitar i en flagga är i den andra flaggan kommer True "
"att returneras::"

#: ../../howto/enum.rst:1120
msgid ""
"There is a new boundary mechanism that controls how out-of-range / invalid "
"bits are handled: ``STRICT``, ``CONFORM``, ``EJECT``, and ``KEEP``:"
msgstr ""
"Det finns en ny boundary-mekanism som styr hur out-of-range / ogiltiga bitar"
" hanteras: ``STRICT``, ``CONFORM``, ``EJECT`` och ``KEEP``:"

#: ../../howto/enum.rst:1123
msgid "STRICT --> raises an exception when presented with invalid values"
msgstr ""
"STRICT --> ger upphov till ett undantag när ogiltiga värden presenteras"

#: ../../howto/enum.rst:1124
msgid "CONFORM --> discards any invalid bits"
msgstr "CONFORM --> förkastar alla ogiltiga bitar"

#: ../../howto/enum.rst:1125
msgid ""
"EJECT --> lose Flag status and become a normal int with the given value"
msgstr ""
"EJECT --> förlorar Flag-status och blir en normal int med det angivna värdet"

#: ../../howto/enum.rst:1126
msgid "KEEP --> keep the extra bits"
msgstr "KEEP --> behåll de extra bitarna"

#: ../../howto/enum.rst:1128
msgid "keeps Flag status and extra bits"
msgstr "håller Flaggstatus och extra bitar"

#: ../../howto/enum.rst:1129
msgid "extra bits do not show up in iteration"
msgstr "extra bitar dyker inte upp i iterationen"

#: ../../howto/enum.rst:1130
msgid "extra bits do show up in repr() and str()"
msgstr "extra bitar dyker upp i repr() och str()"

#: ../../howto/enum.rst:1132
msgid ""
"The default for Flag is ``STRICT``, the default for ``IntFlag`` is "
"``EJECT``, and the default for ``_convert_`` is ``KEEP`` (see "
"``ssl.Options`` for an example of when ``KEEP`` is needed)."
msgstr ""
"Standardvärdet för Flag är ``STRICT``, standardvärdet för ``IntFlag`` är "
"``EJECT`` och standardvärdet för ``_convert_`` är ``KEEP`` (se "
"``ssl.Options`` för ett exempel på när ``KEEP`` behövs)."

#: ../../howto/enum.rst:1140
msgid "How are Enums and Flags different?"
msgstr "Hur skiljer sig Enums och Flags åt?"

#: ../../howto/enum.rst:1142
msgid ""
"Enums have a custom metaclass that affects many aspects of both derived "
":class:`Enum` classes and their instances (members)."
msgstr ""
"Enum har en egen metaklass som påverkar många aspekter av både härledda "
":class:`Enum`\\-klasser och deras instanser (medlemmar)."

#: ../../howto/enum.rst:1147
msgid "Enum Classes"
msgstr "Enumklasser"

#: ../../howto/enum.rst:1149
msgid ""
"The :class:`EnumType` metaclass is responsible for providing the "
":meth:`__contains__`, :meth:`__dir__`, :meth:`__iter__` and other methods "
"that allow one to do things with an :class:`Enum` class that fail on a "
"typical class, such as ``list(Color)`` or ``some_enum_var in Color``.  "
":class:`EnumType` is responsible for ensuring that various other methods on "
"the final :class:`Enum` class are correct (such as :meth:`__new__`, "
":meth:`__getnewargs__`, :meth:`__str__` and :meth:`__repr__`)."
msgstr ""

#: ../../howto/enum.rst:1158
msgid "Flag Classes"
msgstr "Flaggklasser"

#: ../../howto/enum.rst:1160
msgid ""
"Flags have an expanded view of aliasing: to be canonical, the value of a "
"flag needs to be a power-of-two value, and not a duplicate name.  So, in "
"addition to the :class:`Enum` definition of alias, a flag with no value "
"(a.k.a. ``0``) or with more than one power-of-two value (e.g. ``3``) is "
"considered an alias."
msgstr ""
"Flaggor har en utvidgad syn på alias: för att vara kanonisk måste värdet på "
"en flagga vara ett värde i tvåpotens och inte ett duplicerat namn.  Så, "
"utöver :class:`Enum` definitionen av alias, anses en flagga utan värde "
"(a.k.a. ``0``) eller med mer än ett tvåpotensvärde (t.ex. ``3``) vara ett "
"alias."

#: ../../howto/enum.rst:1166
msgid "Enum Members (aka instances)"
msgstr "Enum-medlemmar (även kallade instanser)"

#: ../../howto/enum.rst:1168
msgid ""
"The most interesting thing about enum members is that they are singletons. "
":class:`EnumType` creates them all while it is creating the enum class "
"itself, and then puts a custom :meth:`__new__` in place to ensure that no "
"new ones are ever instantiated by returning only the existing member "
"instances."
msgstr ""

#: ../../howto/enum.rst:1174
msgid "Flag Members"
msgstr "Flaggmedlemmar"

#: ../../howto/enum.rst:1176
msgid ""
"Flag members can be iterated over just like the :class:`Flag` class, and "
"only the canonical members will be returned.  For example::"
msgstr ""
"Flaggmedlemmar kan itereras över precis som i klassen :class:`Flag`, och "
"endast de kanoniska medlemmarna returneras.  Till exempel::"

#: ../../howto/enum.rst:1182
msgid "(Note that ``BLACK``, ``PURPLE``, and ``WHITE`` do not show up.)"
msgstr "(Observera att ``BLACK``, ``PURPLE`` och ``WHITE`` inte förekommer)"

#: ../../howto/enum.rst:1184
msgid ""
"Inverting a flag member returns the corresponding positive value, rather "
"than a negative value --- for example::"
msgstr ""
"Om du inverterar en flaggmedlem returneras motsvarande positiva värde, "
"snarare än ett negativt värde --- till exempel::"

#: ../../howto/enum.rst:1190
msgid ""
"Flag members have a length corresponding to the number of power-of-two "
"values they contain.  For example::"
msgstr ""
"Flaggmedlemmar har en längd som motsvarar antalet tvåpotensvärden de "
"innehåller.  Till exempel::"

#: ../../howto/enum.rst:1200
msgid "Enum Cookbook"
msgstr "Enum kokbok"

#: ../../howto/enum.rst:1203
msgid ""
"While :class:`Enum`, :class:`IntEnum`, :class:`StrEnum`, :class:`Flag`, and "
":class:`IntFlag` are expected to cover the majority of use-cases, they "
"cannot cover them all.  Here are recipes for some different types of "
"enumerations that can be used directly, or as examples for creating one's "
"own."
msgstr ""
"Även om :class:`Enum`, :class:`IntEnum`, :class:`StrEnum`, :class:`Flag` och"
" :class:`IntFlag` förväntas täcka de flesta användningsfall, kan de inte "
"täcka alla.  Här finns recept på några olika typer av uppräkningar som kan "
"användas direkt eller som exempel för att skapa egna."

#: ../../howto/enum.rst:1210
msgid "Omitting values"
msgstr "Utelämnande av värden"

#: ../../howto/enum.rst:1212
msgid ""
"In many use-cases, one doesn't care what the actual value of an enumeration "
"is. There are several ways to define this type of simple enumeration:"
msgstr ""
"I många användningsfall bryr man sig inte om vad det faktiska värdet på en "
"uppräkning är. Det finns flera sätt att definiera den här typen av enkla "
"uppräkningar:"

#: ../../howto/enum.rst:1215
msgid "use instances of :class:`auto` for the value"
msgstr "använda instanser av :class:`auto` för värdet"

#: ../../howto/enum.rst:1216
msgid "use instances of :class:`object` as the value"
msgstr "använda instanser av :class:`object` som värde"

#: ../../howto/enum.rst:1217
msgid "use a descriptive string as the value"
msgstr "använda en beskrivande sträng som värde"

#: ../../howto/enum.rst:1218
msgid ""
"use a tuple as the value and a custom :meth:`__new__` to replace the tuple "
"with an :class:`int` value"
msgstr ""

#: ../../howto/enum.rst:1221
msgid ""
"Using any of these methods signifies to the user that these values are not "
"important, and also enables one to add, remove, or reorder members without "
"having to renumber the remaining members."
msgstr ""
"Genom att använda någon av dessa metoder signalerar man till användaren att "
"dessa värden inte är viktiga och gör det också möjligt att lägga till, ta "
"bort eller ändra ordning på medlemmar utan att behöva numrera om de "
"återstående medlemmarna."

#: ../../howto/enum.rst:1227
msgid "Using :class:`auto`"
msgstr "Använda :class:`auto`"

#: ../../howto/enum.rst:1229
msgid "Using :class:`auto` would look like::"
msgstr "Att använda :class:`auto` skulle se ut så här::"

#: ../../howto/enum.rst:1241
msgid "Using :class:`object`"
msgstr "Använda :class:`object`"

#: ../../howto/enum.rst:1243
msgid "Using :class:`object` would look like::"
msgstr "Att använda :class:`object` skulle se ut så här::"

#: ../../howto/enum.rst:1253
msgid ""
"This is also a good example of why you might want to write your own "
":meth:`__repr__`::"
msgstr ""

#: ../../howto/enum.rst:1269
msgid "Using a descriptive string"
msgstr "Använda en beskrivande sträng"

#: ../../howto/enum.rst:1271
msgid "Using a string as the value would look like::"
msgstr "Om du använder en sträng som värde skulle det se ut så här::"

#: ../../howto/enum.rst:1283
msgid "Using a custom :meth:`__new__`"
msgstr ""

#: ../../howto/enum.rst:1285
msgid "Using an auto-numbering :meth:`__new__` would look like::"
msgstr ""

#: ../../howto/enum.rst:1302
msgid ""
"To make a more general purpose ``AutoNumber``, add ``*args`` to the "
"signature::"
msgstr ""
"För att skapa ett mer allmänt ``AutoNumber``, lägg till ``*args`` till "
"signaturen::"

#: ../../howto/enum.rst:1312
msgid ""
"Then when you inherit from ``AutoNumber`` you can write your own "
"``__init__`` to handle any extra arguments::"
msgstr ""
"När du sedan ärver från ``AutoNumber`` kan du skriva din egen ``__init__`` "
"för att hantera eventuella extra argument::"

#: ../../howto/enum.rst:1331
msgid ""
"The :meth:`__new__` method, if defined, is used during creation of the Enum "
"members; it is then replaced by Enum's :meth:`__new__` which is used after "
"class creation for lookup of existing members."
msgstr ""

#: ../../howto/enum.rst:1337
msgid ""
"*Do not* call ``super().__new__()``, as the lookup-only ``__new__`` is the "
"one that is found; instead, use the data type directly -- e.g.::"
msgstr ""
"Anropa *inte* ``super().__new__()``, eftersom det är ``__new__`` som bara "
"hittas vid uppslagning; använd i stället datatypen direkt -- t.ex.::"

#: ../../howto/enum.rst:1344
msgid "OrderedEnum"
msgstr "BeställdEnum"

#: ../../howto/enum.rst:1346
msgid ""
"An ordered enumeration that is not based on :class:`IntEnum` and so "
"maintains the normal :class:`Enum` invariants (such as not being comparable "
"to other enumerations)::"
msgstr ""
"En ordnad uppräkning som inte är baserad på :class:`IntEnum` och som därför "
"bibehåller de normala :class:`Enum`\\-invarianterna (t.ex. att den inte är "
"jämförbar med andra uppräkningar)::"

#: ../../howto/enum.rst:1380
msgid "DuplicateFreeEnum"
msgstr "DuplikatFriEnum"

#: ../../howto/enum.rst:1382
msgid ""
"Raises an error if a duplicate member value is found instead of creating an "
"alias::"
msgstr ""
"Utlöser ett fel om ett duplicerat medlemsvärde hittas istället för att skapa"
" ett alias::"

#: ../../howto/enum.rst:1407
msgid ""
"This is a useful example for subclassing Enum to add or change other "
"behaviors as well as disallowing aliases.  If the only desired change is "
"disallowing aliases, the :func:`unique` decorator can be used instead."
msgstr ""
"Detta är ett användbart exempel på subklassning av Enum för att lägga till "
"eller ändra andra beteenden samt för att inte tillåta alias.  Om den enda "
"önskade ändringen är att inte tillåta alias kan dekoratorn :func:`unique` "
"användas istället."

#: ../../howto/enum.rst:1413
msgid "Planet"
msgstr "Planet"

#: ../../howto/enum.rst:1415
msgid ""
"If :meth:`__new__` or :meth:`__init__` is defined, the value of the enum "
"member will be passed to those methods::"
msgstr ""

#: ../../howto/enum.rst:1444
msgid "TimePeriod"
msgstr "TidPeriod"

#: ../../howto/enum.rst:1446
msgid "An example to show the :attr:`_ignore_` attribute in use::"
msgstr ""

#: ../../howto/enum.rst:1465
msgid "Subclassing EnumType"
msgstr "Underklassificering av EnumType"

#: ../../howto/enum.rst:1467
msgid ""
"While most enum needs can be met by customizing :class:`Enum` subclasses, "
"either with class decorators or custom functions, :class:`EnumType` can be "
"subclassed to provide a different Enum experience."
msgstr ""
"Medan de flesta enum-behov kan tillgodoses genom att anpassa "
":class:`Enum`\\-subklasser, antingen med klassdekoratorer eller anpassade "
"funktioner, kan :class:`EnumType` subklassas för att ge en annan Enum-"
"upplevelse."
