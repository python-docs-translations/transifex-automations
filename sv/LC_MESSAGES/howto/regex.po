# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# python-doc bot, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-25 18:05+0000\n"
"PO-Revision-Date: 2025-09-22 17:54+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../howto/regex.rst:5
msgid "Regular Expression HOWTO"
msgstr "Reguljära uttryck HOWTO"

#: ../../howto/regex.rst:0
msgid "Author"
msgstr "Författare"

#: ../../howto/regex.rst:7
msgid "A.M. Kuchling <amk@amk.ca>"
msgstr "A.M. Kuchling <amk@amk.ca>"

#: ../../howto/regex.rstNone
msgid "Abstract"
msgstr "Abstrakt"

#: ../../howto/regex.rst:18
msgid ""
"This document is an introductory tutorial to using regular expressions in "
"Python with the :mod:`re` module.  It provides a gentler introduction than "
"the corresponding section in the Library Reference."
msgstr ""
"Detta dokument är en inledande handledning i hur man använder reguljära "
"uttryck i Python med modulen :mod:`re`.  Det ger en mildare introduktion än "
"motsvarande avsnitt i Library Reference."

#: ../../howto/regex.rst:24
msgid "Introduction"
msgstr "Introduktion"

#: ../../howto/regex.rst:26
msgid ""
"Regular expressions (called REs, or regexes, or regex patterns) are "
"essentially a tiny, highly specialized programming language embedded inside "
"Python and made available through the :mod:`re` module. Using this little "
"language, you specify the rules for the set of possible strings that you "
"want to match; this set might contain English sentences, or e-mail "
"addresses, or TeX commands, or anything you like.  You can then ask "
"questions such as \"Does this string match the pattern?\", or \"Is there a "
"match for the pattern anywhere in this string?\".  You can also use REs to "
"modify a string or to split it apart in various ways."
msgstr ""
"Reguljära uttryck (kallade RE, regex eller regexmönster) är i huvudsak ett "
"litet, mycket specialiserat programmeringsspråk som är inbäddat i Python och"
" görs tillgängligt via modulen :mod:`re`. Med hjälp av detta lilla språk "
"specificerar du reglerna för den uppsättning möjliga strängar som du vill "
"matcha; denna uppsättning kan innehålla engelska meningar, e-postadresser, "
"TeX-kommandon eller vad du vill.  Sedan kan man ställa frågor som \"Matchar "
"den här strängen mönstret?\" eller \"Finns det en matchning för mönstret "
"någonstans i den här strängen?\".  Du kan också använda RE:er för att "
"modifiera en sträng eller dela upp den på olika sätt."

#: ../../howto/regex.rst:35
msgid ""
"Regular expression patterns are compiled into a series of bytecodes which "
"are then executed by a matching engine written in C.  For advanced use, it "
"may be necessary to pay careful attention to how the engine will execute a "
"given RE, and write the RE in a certain way in order to produce bytecode "
"that runs faster. Optimization isn't covered in this document, because it "
"requires that you have a good understanding of the matching engine's "
"internals."
msgstr ""
"Reguljära uttrycksmönster kompileras till en serie bytekoder som sedan "
"exekveras av en matchningsmotor skriven i C. För avancerad användning kan "
"det vara nödvändigt att vara noga med hur motorn kommer att exekvera en viss"
" RE och skriva RE på ett visst sätt för att producera bytekoder som körs "
"snabbare. Optimering behandlas inte i det här dokumentet, eftersom det "
"kräver att du har en god förståelse för matchningsmotorns interna "
"funktioner."

#: ../../howto/regex.rst:42
msgid ""
"The regular expression language is relatively small and restricted, so not "
"all possible string processing tasks can be done using regular expressions."
"  There are also tasks that *can* be done with regular expressions, but the "
"expressions turn out to be very complicated.  In these cases, you may be "
"better off writing Python code to do the processing; while Python code will "
"be slower than an elaborate regular expression, it will also probably be "
"more understandable."
msgstr ""
"Språket för reguljära uttryck är relativt litet och begränsat, så alla "
"möjliga strängbehandlingsuppgifter kan inte utföras med reguljära uttryck.  "
"Det finns också uppgifter som *kan* utföras med reguljära uttryck, men "
"uttrycken visar sig vara mycket komplicerade.  I dessa fall kan det vara "
"bättre att skriva Python-kod för att göra bearbetningen; även om Python-kod "
"kommer att vara långsammare än ett utarbetat reguljärt uttryck, kommer den "
"förmodligen också att vara mer begriplig."

#: ../../howto/regex.rst:51
msgid "Simple Patterns"
msgstr "Enkla mönster"

#: ../../howto/regex.rst:53
msgid ""
"We'll start by learning about the simplest possible regular expressions.  "
"Since regular expressions are used to operate on strings, we'll begin with "
"the most common task: matching characters."
msgstr ""
"Vi börjar med att lära oss om de enklaste möjliga reguljära uttrycken.  "
"Eftersom reguljära uttryck används för att operera på strängar börjar vi med"
" den vanligaste uppgiften: att matcha tecken."

#: ../../howto/regex.rst:57
msgid ""
"For a detailed explanation of the computer science underlying regular "
"expressions (deterministic and non-deterministic finite automata), you can "
"refer to almost any textbook on writing compilers."
msgstr ""
"För en detaljerad förklaring av den datavetenskap som ligger bakom reguljära"
" uttryck (deterministiska och icke-deterministiska finita automater) kan du "
"hänvisa till nästan vilken lärobok som helst om att skriva kompilatorer."

#: ../../howto/regex.rst:63
msgid "Matching Characters"
msgstr "Matchande tecken"

#: ../../howto/regex.rst:65
msgid ""
"Most letters and characters will simply match themselves.  For example, the "
"regular expression ``test`` will match the string ``test`` exactly.  (You "
"can enable a case-insensitive mode that would let this RE match ``Test`` or "
"``TEST`` as well; more about this later.)"
msgstr ""
"De flesta bokstäver och tecken matchar helt enkelt sig själva.  Till exempel"
" kommer det reguljära uttrycket ``test`` att matcha strängen ``test`` exakt."
"  (Du kan aktivera ett skiftlägesokänsligt läge som låter RE matcha ``Test``"
" eller ``TEST`` också; mer om detta senare)"

#: ../../howto/regex.rst:70
msgid ""
"There are exceptions to this rule; some characters are special "
":dfn:`metacharacters`, and don't match themselves.  Instead, they signal "
"that some out-of-the-ordinary thing should be matched, or they affect other "
"portions of the RE by repeating them or changing their meaning.  Much of "
"this document is devoted to discussing various metacharacters and what they "
"do."
msgstr ""
"Det finns undantag från denna regel; vissa tecken är speciella "
":dfn:`metatecken`, och matchar inte sig själva.  Istället signalerar de att "
"något utöver det vanliga ska matchas, eller så påverkar de andra delar av RE"
" genom att upprepa dem eller ändra deras betydelse.  En stor del av det här "
"dokumentet ägnas åt att diskutera olika metatecken och vad de gör."

#: ../../howto/regex.rst:76
msgid ""
"Here's a complete list of the metacharacters; their meanings will be "
"discussed in the rest of this HOWTO."
msgstr ""
"Här är en fullständig lista över metatecken; deras betydelser kommer att "
"diskuteras i resten av denna HOWTO."

#: ../../howto/regex.rst:83
msgid ""
"The first metacharacters we'll look at are ``[`` and ``]``. They're used for"
" specifying a character class, which is a set of characters that you wish to"
" match.  Characters can be listed individually, or a range of characters can"
" be indicated by giving two characters and separating them by a ``'-'``.  "
"For example, ``[abc]`` will match any of the characters ``a``, ``b``, or "
"``c``; this is the same as ``[a-c]``, which uses a range to express the same"
" set of characters.  If you wanted to match only lowercase letters, your RE "
"would be ``[a-z]``."
msgstr ""
"De första metatecknen vi tittar på är ``[`` och ``]``. De används för att "
"ange en teckenklass, vilket är en uppsättning tecken som du vill matcha.  "
"Tecken kan listas individuellt, eller så kan ett intervall av tecken anges "
"genom att ange två tecken och separera dem med en ``'-'``.  Till exempel "
"kommer ``[abc]`` att matcha vilket som helst av tecknen ``a``, ``b`` eller "
"``c``; detta är samma sak som ``[a-c]``, som använder ett intervall för att "
"uttrycka samma uppsättning tecken.  Om du bara vill matcha gemena bokstäver "
"skulle RE vara ``[a-z]``."

#: ../../howto/regex.rst:92
msgid ""
"Metacharacters (except ``\\``) are not active inside classes.  For example, "
"``[akm$]`` will match any of the characters ``'a'``, ``'k'``, ``'m'``, or "
"``'$'``; ``'$'`` is usually a metacharacter, but inside a character class "
"it's stripped of its special nature."
msgstr ""
"Metatecken (utom ``\\``) är inte aktiva inom klasser. Till exempel kommer "
"``[akm$]`` att matcha något av tecknen ``'a'``, ``'k'``, ``'m'``, eller "
"``'$'``; ``'$'`` är vanligtvis ett metatecken, men inom en teckenklass "
"förlorar det sin speciella egenskap."

#: ../../howto/regex.rst:97
msgid ""
"You can match the characters not listed within the class by "
":dfn:`complementing` the set.  This is indicated by including a ``'^'`` as "
"the first character of the class. For example, ``[^5]`` will match any "
"character except ``'5'``.  If the caret appears elsewhere in a character "
"class, it does not have special meaning. For example: ``[5^]`` will match "
"either a ``'5'`` or a ``'^'``."
msgstr ""
"Du kan matcha de tecken som inte listas inom klassen genom att "
":dfn:`komplettera` uppsättningen.  Detta indikeras genom att inkludera en "
"``'^'`` som första tecken i klassen. Till exempel kommer ``[^5]`` att matcha"
" alla tecken utom ``'5'``.  Om caretten förekommer någon annanstans i en "
"teckenklass har den ingen speciell betydelse. Till exempel: ``[5^]`` kommer "
"att matcha antingen en ``'5'`` eller en ``'^'``."

#: ../../howto/regex.rst:103
msgid ""
"Perhaps the most important metacharacter is the backslash, ``\\``.   As in "
"Python string literals, the backslash can be followed by various characters "
"to signal various special sequences.  It's also used to escape all the "
"metacharacters so you can still match them in patterns; for example, if you "
"need to match a ``[`` or  ``\\``, you can precede them with a backslash to "
"remove their special meaning: ``\\[`` or ``\\\\``."
msgstr ""
"Den kanske viktigaste metatecknet är backsteget, ``\\``. Precis som i "
"Python-strängkonstanter kan backsteget följas av olika tecken för att ange "
"olika specialsekvenser. Den används också för att undvika alla metatecken så"
" att du fortfarande kan matcha dem i mönster. Om du till exempel behöver "
"matcha ``[`` eller ``\\`` kan du föregå dem med en backsteg för att ta bort "
"deras speciella betydelse: ``\\[`` eller ``\\\\``."

#: ../../howto/regex.rst:110
msgid ""
"Some of the special sequences beginning with ``'\\'`` represent predefined "
"sets of characters that are often useful, such as the set of digits, the set"
" of letters, or the set of anything that isn't whitespace."
msgstr ""
"Vissa av de specialsekvenser som börjar med ``'\\'`` representerar "
"fördefinierade uppsättningar av tecken som ofta är användbara, t.ex. "
"uppsättningen av siffror, uppsättningen av bokstäver eller uppsättningen av "
"allt som inte är blanksteg."

#: ../../howto/regex.rst:115
msgid ""
"Let's take an example: ``\\w`` matches any alphanumeric character.  If the "
"regex pattern is expressed in bytes, this is equivalent to the class "
"``[a-zA-Z0-9_]``.  If the regex pattern is a string, ``\\w`` will match all "
"the characters marked as letters in the Unicode database provided by the "
":mod:`unicodedata` module.  You can use the more restricted definition of "
"``\\w`` in a string pattern by supplying the :const:`re.ASCII` flag when "
"compiling the regular expression."
msgstr ""
"Låt oss ta ett exempel: ``\\w`` matchar alla alfanumeriska tecken.  Om "
"regex-mönstret uttrycks i byte motsvarar detta klassen ``[a-zA-Z0-9_]``.  Om"
" regex-mönstret är en sträng kommer ``w`` att matcha alla tecken som "
"markerats som bokstäver i Unicode-databasen som tillhandahålls av modulen "
":mod:`unicodedata`.  Du kan använda den mer begränsade definitionen av "
"``\\w`` i ett strängmönster genom att ange flaggan :const:`re.ASCII` när du "
"kompilerar det reguljära uttrycket."

#: ../../howto/regex.rst:123
msgid ""
"The following list of special sequences isn't complete. For a complete list "
"of sequences and expanded class definitions for Unicode string patterns, see"
" the last part of :ref:`Regular Expression Syntax <re-syntax>` in the "
"Standard Library reference.  In general, the Unicode versions match any "
"character that's in the appropriate category in the Unicode database."
msgstr ""
"Följande lista över specialsekvenser är inte fullständig. En fullständig "
"lista över sekvenser och utökade klassdefinitioner för Unicode-strängmönster"
" finns i den sista delen av :ref:`Regular Expression Syntax <re-syntax>` i "
"Standard Library-referensen.  I allmänhet matchar Unicode-versionerna alla "
"tecken som finns i lämplig kategori i Unicode-databasen."

#: ../../howto/regex.rst:131
msgid "``\\d``"
msgstr "``\\d``"

#: ../../howto/regex.rst:131
msgid "Matches any decimal digit; this is equivalent to the class ``[0-9]``."
msgstr "Matchar alla decimalsiffror; detta motsvarar klassen ``[0-9]``."

#: ../../howto/regex.rst:134
msgid "``\\D``"
msgstr "``\\D``"

#: ../../howto/regex.rst:134
msgid ""
"Matches any non-digit character; this is equivalent to the class ``[^0-9]``."
msgstr ""
"Motsvarar alla icke-siffriga tecken; detta motsvarar klassen ``[^0-9]``."

#: ../../howto/regex.rst:138
msgid "``\\s``"
msgstr "``\\s``"

#: ../../howto/regex.rst:137
msgid ""
"Matches any whitespace character; this is equivalent to the class ``[ "
"\\t\\n\\r\\f\\v]``."
msgstr ""
"Matchar alla tecken för blanksteg; detta motsvarar klassen ``[ "
"\\t\\n\\r\\f\\v]``."

#: ../../howto/regex.rst:142
msgid "``\\S``"
msgstr "``\\S``"

#: ../../howto/regex.rst:141
msgid ""
"Matches any non-whitespace character; this is equivalent to the class ``[^ "
"\\t\\n\\r\\f\\v]``."
msgstr ""
"Matchar alla tecken som inte är blanksteg; detta motsvarar klassen ``[^ "
"\\t\\n\\r\\f\\v]``."

#: ../../howto/regex.rst:146
msgid "``\\w``"
msgstr "``\\w``"

#: ../../howto/regex.rst:145
msgid ""
"Matches any alphanumeric character; this is equivalent to the class "
"``[a-zA-Z0-9_]``."
msgstr ""
"Matchar alla alfanumeriska tecken; detta är likvärdigt med klassen "
"``[a-zA-Z0-9_]``."

#: ../../howto/regex.rst:150
msgid "``\\W``"
msgstr "``\\W``"

#: ../../howto/regex.rst:149
msgid ""
"Matches any non-alphanumeric character; this is equivalent to the class "
"``[^a-zA-Z0-9_]``."
msgstr ""
"Matchar alla icke-alfanumeriska tecken; detta motsvarar klassen "
"``[^a-zA-Z0-9_]``."

#: ../../howto/regex.rst:152
msgid ""
"These sequences can be included inside a character class.  For example, "
"``[\\s,.]`` is a character class that will match any whitespace character, "
"or ``','`` or ``'.'``."
msgstr ""
"Dessa sekvenser kan inkluderas i en teckenklass.  Till exempel är "
"``[\\s,.]`` en teckenklass som matchar alla blankstegstecken, eller ``','`` "
"eller ``'.'``."

#: ../../howto/regex.rst:156
msgid ""
"The final metacharacter in this section is ``.``.  It matches anything "
"except a newline character, and there's an alternate mode "
"(:const:`re.DOTALL`) where it will match even a newline.  ``.`` is often "
"used where you want to match \"any character\"."
msgstr ""
"Det sista metatecknet i det här avsnittet är ``.``.  Det matchar allt utom "
"en ny rad, och det finns ett alternativt läge (:const:`re.DOTALL`) där det "
"matchar även en ny rad.  ``.`` används ofta där man vill matcha \"alla "
"tecken\"."

#: ../../howto/regex.rst:163
msgid "Repeating Things"
msgstr "Upprepning av saker"

#: ../../howto/regex.rst:165
msgid ""
"Being able to match varying sets of characters is the first thing regular "
"expressions can do that isn't already possible with the methods available on"
" strings.  However, if that was the only additional capability of regexes, "
"they wouldn't be much of an advance. Another capability is that you can "
"specify that portions of the RE must be repeated a certain number of times."
msgstr ""
"Att kunna matcha varierande uppsättningar av tecken är det första som "
"reguljära uttryck kan göra som inte redan är möjligt med de metoder som "
"finns tillgängliga för strängar.  Men om det var den enda ytterligare "
"förmågan hos regexes, skulle de inte vara mycket av ett framsteg. En annan "
"möjlighet är att du kan ange att delar av RE måste upprepas ett visst antal "
"gånger."

#: ../../howto/regex.rst:171
msgid ""
"The first metacharacter for repeating things that we'll look at is ``*``.  "
"``*`` doesn't match the literal character ``'*'``; instead, it specifies "
"that the previous character can be matched zero or more times, instead of "
"exactly once."
msgstr ""
"Det första metatecknet för upprepning av saker som vi ska titta på är ``*``."
"  ``*`` matchar inte det bokstavliga tecknet ``'*'``; istället anger det att"
" det föregående tecknet kan matchas noll eller flera gånger, istället för "
"exakt en gång."

#: ../../howto/regex.rst:175
msgid ""
"For example, ``ca*t`` will match ``'ct'`` (0 ``'a'`` characters), ``'cat'`` "
"(1 ``'a'``), ``'caaat'`` (3 ``'a'`` characters), and so forth."
msgstr ""
"Till exempel kommer ``ca*t`` att matcha ``'ct'`` (0 ``'a'`` tecken), "
"``'cat'`` (1 ``'a'``), ``'caaat'`` (3 ``'a'`` tecken), och så vidare."

#: ../../howto/regex.rst:178
msgid ""
"Repetitions such as ``*`` are :dfn:`greedy`; when repeating a RE, the "
"matching engine will try to repeat it as many times as possible. If later "
"portions of the pattern don't match, the matching engine will then back up "
"and try again with fewer repetitions."
msgstr ""
"Upprepningar som ``*`` är :dfn:`greedy`; när en RE upprepas försöker "
"matchningsmotorn upprepa den så många gånger som möjligt. Om senare delar av"
" mönstret inte matchar, backar matchningsmotorn och försöker igen med färre "
"upprepningar."

#: ../../howto/regex.rst:183
msgid ""
"A step-by-step example will make this more obvious.  Let's consider the "
"expression ``a[bcd]*b``.  This matches the letter ``'a'``, zero or more "
"letters from the class ``[bcd]``, and finally ends with a ``'b'``.  Now "
"imagine matching this RE against the string ``'abcbd'``."
msgstr ""
"Ett steg-för-steg exempel gör detta mer uppenbart.  Låt oss betrakta "
"uttrycket ``a[bcd]*b``.  Detta matchar bokstaven ``'a'``, noll eller fler "
"bokstäver från klassen ``[bcd]``, och slutar slutligen med ``'b'``.  Tänk "
"dig nu att du matchar denna RE mot strängen ``'abcbd``."

#: ../../howto/regex.rst:189
msgid "Step"
msgstr "Steg"

#: ../../howto/regex.rst:189
msgid "Matched"
msgstr "Matchad"

#: ../../howto/regex.rst:189
msgid "Explanation"
msgstr "Förklaring"

#: ../../howto/regex.rst:191
msgid "1"
msgstr "1"

#: ../../howto/regex.rst:191
msgid "``a``"
msgstr "``a``"

#: ../../howto/regex.rst:191
msgid "The ``a`` in the RE matches."
msgstr "\"A\" i \"RE\" stämmer överens."

#: ../../howto/regex.rst:193
msgid "2"
msgstr "2"

#: ../../howto/regex.rst:193
msgid "``abcbd``"
msgstr "``abcbd``"

#: ../../howto/regex.rst:193
msgid ""
"The engine matches ``[bcd]*``, going as far as it can, which is to the end "
"of the string."
msgstr ""
"Motorn matchar ``[bcd]*`` och går så långt den kan, vilket är till slutet av"
" strängen."

#: ../../howto/regex.rst:197
msgid "3"
msgstr "3"

#: ../../howto/regex.rst:197 ../../howto/regex.rst:205
msgid "*Failure*"
msgstr "*Fel*"

#: ../../howto/regex.rst:197
msgid ""
"The engine tries to match ``b``, but the current position is at the end of "
"the string, so it fails."
msgstr ""
"Motorn försöker matcha ``b``, men den aktuella positionen är i slutet av "
"strängen, så det misslyckas."

#: ../../howto/regex.rst:202
msgid "4"
msgstr "4"

#: ../../howto/regex.rst:202 ../../howto/regex.rst:213
msgid "``abcb``"
msgstr "``abcb``"

#: ../../howto/regex.rst:202
msgid "Back up, so that  ``[bcd]*`` matches one less character."
msgstr "Backa, så att ``[bcd]*`` matchar ett tecken mindre."

#: ../../howto/regex.rst:205
msgid "5"
msgstr "5"

#: ../../howto/regex.rst:205
msgid ""
"Try ``b`` again, but the current position is at the last character, which is"
" a ``'d'``."
msgstr ""
"Försök med ``b`` igen, men den aktuella positionen är vid det sista tecknet,"
" som är en ``'d'``."

#: ../../howto/regex.rst:209 ../../howto/regex.rst:213
msgid "6"
msgstr "6"

#: ../../howto/regex.rst:209
msgid "``abc``"
msgstr "``abc``"

#: ../../howto/regex.rst:209
msgid "Back up again, so that ``[bcd]*`` is only matching ``bc``."
msgstr "Tillbaka upp igen, så att ``[bcd]*`` bara matchar ``bc``."

#: ../../howto/regex.rst:213
msgid ""
"Try ``b`` again.  This time the character at the current position is "
"``'b'``, so it succeeds."
msgstr ""
"Försök med ``b`` igen.  Den här gången är tecknet vid den aktuella "
"positionen ``'b'``, så det lyckas."

#: ../../howto/regex.rst:219
msgid ""
"The end of the RE has now been reached, and it has matched ``'abcb'``.  This"
" demonstrates how the matching engine goes as far as it can at first, and if"
" no match is found it will then progressively back up and retry the rest of "
"the RE again and again.  It will back up until it has tried zero matches for"
" ``[bcd]*``, and if that subsequently fails, the engine will conclude that "
"the string doesn't match the RE at all."
msgstr ""
"Slutet av RE har nu nåtts, och den har matchat ``'abcb``.  Detta visar hur "
"matchningsmotorn först går så långt den kan, och om ingen matchning hittas "
"kommer den sedan successivt att backa tillbaka och försöka resten av RE om "
"och om igen.  Den kommer att backa tills den har försökt noll matchningar "
"för ``[bcd]*``, och om det därefter misslyckas kommer motorn att dra "
"slutsatsen att strängen inte alls matchar RE."

#: ../../howto/regex.rst:226
msgid ""
"Another repeating metacharacter is ``+``, which matches one or more times.  "
"Pay careful attention to the difference between ``*`` and ``+``; ``*`` "
"matches *zero* or more times, so whatever's being repeated may not be "
"present at all, while ``+`` requires at least *one* occurrence.  To use a "
"similar example, ``ca+t`` will match ``'cat'`` (1 ``'a'``), ``'caaat'`` (3 "
"``'a'``\\ s), but won't match ``'ct'``."
msgstr ""
"Ett annat upprepande metatecken är ``+``, som matchar en eller flera gånger."
"  Var noga med skillnaden mellan ``*`` och ``+``; ``*`` matchar *noll* eller"
" fler gånger, så det som upprepas kanske inte finns med alls, medan ``+`` "
"kräver minst *en* förekomst.  För att använda ett liknande exempel, ``ca+t``"
" kommer att matcha ``'cat'`` (1 ``'a'``), ``'caaat'`` (3 ``'a'``), men "
"kommer inte att matcha ``'ct'``."

#: ../../howto/regex.rst:233
msgid ""
"There are two more repeating qualifiers.  The question mark character, "
"``?``, matches either once or zero times; you can think of it as marking "
"something as being optional.  For example, ``home-?brew`` matches either "
"``'homebrew'`` or ``'home-brew'``."
msgstr ""

#: ../../howto/regex.rst:238
msgid ""
"The most complicated repeated qualifier is ``{m,n}``, where *m* and *n* are "
"decimal integers.  This qualifier means there must be at least *m* "
"repetitions, and at most *n*.  For example, ``a/{1,3}b`` will match "
"``'a/b'``, ``'a//b'``, and ``'a///b'``.  It won't match ``'ab'``, which has "
"no slashes, or ``'a////b'``, which has four."
msgstr ""

#: ../../howto/regex.rst:244
msgid ""
"You can omit either *m* or *n*; in that case, a reasonable value is assumed "
"for the missing value.  Omitting *m* is interpreted as a lower limit of 0, "
"while omitting *n* results in an upper bound of infinity."
msgstr ""
"Du kan utelämna antingen *m* eller *n*; i så fall antas ett rimligt värde "
"för det saknade värdet.  Att utelämna *m* tolkas som en nedre gräns på 0, "
"medan att utelämna *n* resulterar i en övre gräns på oändlighet."

#: ../../howto/regex.rst:248
msgid ""
"Readers of a reductionist bent may notice that the three other qualifiers "
"can all be expressed using this notation.  ``{0,}`` is the same as ``*``, "
"``{1,}`` is equivalent to ``+``, and ``{0,1}`` is the same as ``?``.  It's "
"better to use ``*``, ``+``, or ``?`` when you can, simply because they're "
"shorter and easier to read."
msgstr ""

#: ../../howto/regex.rst:256
msgid "Using Regular Expressions"
msgstr "Använda reguljära uttryck"

#: ../../howto/regex.rst:258
msgid ""
"Now that we've looked at some simple regular expressions, how do we actually"
" use them in Python?  The :mod:`re` module provides an interface to the "
"regular expression engine, allowing you to compile REs into objects and then"
" perform matches with them."
msgstr ""
"Nu när vi har tittat på några enkla reguljära uttryck, hur använder vi dem "
"egentligen i Python?  Modulen :mod:`re` tillhandahåller ett gränssnitt till "
"motorn för reguljära uttryck, så att du kan sammanställa RE:er till objekt "
"och sedan utföra matchningar med dem."

#: ../../howto/regex.rst:265
msgid "Compiling Regular Expressions"
msgstr "Kompilera reguljära uttryck"

#: ../../howto/regex.rst:267
msgid ""
"Regular expressions are compiled into pattern objects, which have methods "
"for various operations such as searching for pattern matches or performing "
"string substitutions. ::"
msgstr ""
"Reguljära uttryck sammanställs till mönsterobjekt, som har metoder för olika"
" operationer som att söka efter mönstermatchningar eller utföra "
"strängersättningar:"

#: ../../howto/regex.rst:276
msgid ""
":func:`re.compile` also accepts an optional *flags* argument, used to enable"
" various special features and syntax variations.  We'll go over the "
"available settings later, but for now a single example will do::"
msgstr ""
":func:`re.compile` accepterar också ett valfritt *flags*-argument, som "
"används för att aktivera olika specialfunktioner och syntaxvariationer.  Vi "
"kommer att gå igenom de tillgängliga inställningarna senare, men nu räcker "
"det med ett exempel::"

#: ../../howto/regex.rst:282
msgid ""
"The RE is passed to :func:`re.compile` as a string.  REs are handled as "
"strings because regular expressions aren't part of the core Python language,"
" and no special syntax was created for expressing them.  (There are "
"applications that don't need REs at all, so there's no need to bloat the "
"language specification by including them.) Instead, the :mod:`re` module is "
"simply a C extension module included with Python, just like the "
":mod:`socket` or :mod:`zlib` modules."
msgstr ""
"RE:n skickas till :func:`re.compile` som en sträng.  REs hanteras som "
"strängar eftersom reguljära uttryck inte är en del av Pythons kärnspråk och "
"ingen speciell syntax skapades för att uttrycka dem.  (Det finns "
"applikationer som inte behöver REs alls, så det finns ingen anledning att "
"uppblåsa språkspecifikationen genom att inkludera dem) Istället är modulen "
":mod:`re` helt enkelt en C-tilläggsmodul som ingår i Python, precis som "
"modulerna :mod:`socket` eller :mod:`zlib`."

#: ../../howto/regex.rst:289
msgid ""
"Putting REs in strings keeps the Python language simpler, but has one "
"disadvantage which is the topic of the next section."
msgstr ""
"Att lägga RE:er i strängar gör Python-språket enklare, men det har en "
"nackdel som behandlas i nästa avsnitt."

#: ../../howto/regex.rst:296
msgid "The Backslash Plague"
msgstr "Backslash-pesten"

#: ../../howto/regex.rst:298
msgid ""
"As stated earlier, regular expressions use the backslash character "
"(``'\\'``) to indicate special forms or to allow special characters to be "
"used without invoking their special meaning. This conflicts with Python's "
"usage of the same character for the same purpose in string literals."
msgstr ""
"Som tidigare nämnts använder reguljära uttryck tecknet backslash (``'\\'``) "
"för att ange speciella former eller för att tillåta att specialtecken "
"används utan att deras speciella betydelse åberopas. Detta står i konflikt "
"med Pythons användning av samma tecken för samma ändamål i stränglitteraler."

#: ../../howto/regex.rst:303
msgid ""
"Let's say you want to write a RE that matches the string ``\\section``, "
"which might be found in a LaTeX file.  To figure out what to write in the "
"program code, start with the desired string to be matched.  Next, you must "
"escape any backslashes and other metacharacters by preceding them with a "
"backslash, resulting in the string ``\\\\section``.  The resulting string "
"that must be passed to :func:`re.compile` must be ``\\\\section``.  However,"
" to express this as a Python string literal, both backslashes must be "
"escaped *again*."
msgstr ""
"Låt oss säga att du vill skriva en RE som matchar strängen ``\\section``, "
"som kan finnas i en LaTeX-fil.  För att räkna ut vad som ska skrivas i "
"programkoden börjar du med den önskade strängen som ska matchas.  Därefter "
"måste du undkomma eventuella backslash och andra metatecken genom att föregå"
" dem med ett backslash, vilket resulterar i strängen ``\\\\section``.  Den "
"resulterande strängen som måste skickas till :func:`re.compile` måste vara "
"``\\\\section``.  Men för att uttrycka detta som en Python-stränglitteral "
"måste båda backslasharna escapas *igen*."

#: ../../howto/regex.rst:312
msgid "Characters"
msgstr "Tecken"

#: ../../howto/regex.rst:312
msgid "Stage"
msgstr "Steg"

#: ../../howto/regex.rst:314
msgid "``\\section``"
msgstr "``\\section``"

#: ../../howto/regex.rst:314
msgid "Text string to be matched"
msgstr "Textsträng som ska matchas"

#: ../../howto/regex.rst:316
msgid "``\\\\section``"
msgstr "``\\\\section``"

#: ../../howto/regex.rst:316
msgid "Escaped backslash for :func:`re.compile`"
msgstr "Undangömd backslash för :func:`re.compile`"

#: ../../howto/regex.rst:318 ../../howto/regex.rst:345
msgid "``\"\\\\\\\\section\"``"
msgstr "``\"\\\\\\\\section\"``"

#: ../../howto/regex.rst:318
msgid "Escaped backslashes for a string literal"
msgstr "Escaped backslashes för en strängbördal"

#: ../../howto/regex.rst:321
msgid ""
"In short, to match a literal backslash, one has to write ``'\\\\\\\\'`` as "
"the RE string, because the regular expression must be ``\\\\``, and each "
"backslash must be expressed as ``\\\\`` inside a regular Python string "
"literal.  In REs that feature backslashes repeatedly, this leads to lots of "
"repeated backslashes and makes the resulting strings difficult to "
"understand."
msgstr ""
"Kort sagt, för att matcha ett literalt backslash måste man skriva "
"``'\\\\\\\\'`` som RE-sträng, eftersom det reguljära uttrycket måste vara "
"``\\\\`` och varje backslash måste uttryckas som ``\\\\`` inuti en reguljär "
"Python-strängliteral.  I RE:er som innehåller backslash upprepade gånger "
"leder detta till många upprepade backslash och gör de resulterande "
"strängarna svåra att förstå."

#: ../../howto/regex.rst:327
msgid ""
"The solution is to use Python's raw string notation for regular expressions;"
" backslashes are not handled in any special way in a string literal prefixed"
" with ``'r'``, so ``r\"\\n\"`` is a two-character string containing ``'\\'``"
" and ``'n'``, while ``\"\\n\"`` is a one-character string containing a "
"newline. Regular expressions will often be written in Python code using this"
" raw string notation."
msgstr ""
"Lösningen är att använda Pythons råa strängnotation för reguljära uttryck; "
"backslasher hanteras inte på något speciellt sätt i en stränglitual med "
"prefixet ``'r'``, så ``r\"\\n\"`` är en tvåteckenssträng som innehåller "
"``'\\'`` och ``'n'``, medan ``\"\\n\"`` är en enteckenssträng som innehåller"
" en ny rad. Reguljära uttryck skrivs ofta i Python-kod med hjälp av denna "
"råa strängnotation."

#: ../../howto/regex.rst:333
msgid ""
"In addition, special escape sequences that are valid in regular expressions,"
" but not valid as Python string literals, now result in a "
":exc:`DeprecationWarning` and will eventually become a :exc:`SyntaxError`, "
"which means the sequences will be invalid if raw string notation or escaping"
" the backslashes isn't used."
msgstr ""
"Dessutom resulterar nu speciella escape-sekvenser som är giltiga i reguljära"
" uttryck, men inte giltiga som Python-stränglitteraler, i en "
":exc:`DeprecationWarning` och kommer så småningom att bli en "
":exc:`SyntaxError`, vilket innebär att sekvenserna kommer att vara ogiltiga "
"om rå strängnotation eller escaping av backslashes inte används."

#: ../../howto/regex.rst:341
msgid "Regular String"
msgstr "Vanlig sträng"

#: ../../howto/regex.rst:341
msgid "Raw string"
msgstr "Rå sträng"

#: ../../howto/regex.rst:343
msgid "``\"ab*\"``"
msgstr "``\"ab*\"``"

#: ../../howto/regex.rst:343
msgid "``r\"ab*\"``"
msgstr "``r\"ab*\"``"

#: ../../howto/regex.rst:345
msgid "``r\"\\\\section\"``"
msgstr "``r\"\\\\section\"``"

#: ../../howto/regex.rst:347
msgid "``\"\\\\w+\\\\s+\\\\1\"``"
msgstr "``\"\\\\w+\\\\s+\\\\1\"``"

#: ../../howto/regex.rst:347
msgid "``r\"\\w+\\s+\\1\"``"
msgstr "``r\"\\w+\\s+\\1\"``"

#: ../../howto/regex.rst:352
msgid "Performing Matches"
msgstr "Utföra matchningar"

#: ../../howto/regex.rst:354
msgid ""
"Once you have an object representing a compiled regular expression, what do "
"you do with it?  Pattern objects have several methods and attributes. Only "
"the most significant ones will be covered here; consult the :mod:`re` docs "
"for a complete listing."
msgstr ""
"När du har ett objekt som representerar ett kompilerat reguljärt uttryck, "
"vad gör du med det?  Mönsterobjekt har flera metoder och attribut. Endast de"
" mest betydelsefulla kommer att tas upp här; se :mod:`re`\\-dokumenten för "
"en fullständig lista."

#: ../../howto/regex.rst:360 ../../howto/regex.rst:418
#: ../../howto/regex.rst:1064
msgid "Method/Attribute"
msgstr "Metod/Attribut"

#: ../../howto/regex.rst:360 ../../howto/regex.rst:418
#: ../../howto/regex.rst:1064
msgid "Purpose"
msgstr "Syfte"

#: ../../howto/regex.rst:362
msgid "``match()``"
msgstr "``match()``"

#: ../../howto/regex.rst:362
msgid "Determine if the RE matches at the beginning of the string."
msgstr "Avgör om RE matchar i början av strängen."

#: ../../howto/regex.rst:365
msgid "``search()``"
msgstr "``search()``"

#: ../../howto/regex.rst:365
msgid "Scan through a string, looking for any location where this RE matches."
msgstr ""
"Skanna igenom en sträng och leta efter alla platser där denna RE matchar."

#: ../../howto/regex.rst:368
msgid "``findall()``"
msgstr "``findall()``"

#: ../../howto/regex.rst:368
msgid "Find all substrings where the RE matches, and returns them as a list."
msgstr "Hitta alla delsträngar där RE matchar och returnera dem som en lista."

#: ../../howto/regex.rst:371
msgid "``finditer()``"
msgstr "``finditer()``"

#: ../../howto/regex.rst:371
msgid ""
"Find all substrings where the RE matches, and returns them as an "
":term:`iterator`."
msgstr ""
"Hitta alla substrängar där RE matchar och returnera dem som en "
":term:`iterator`."

#: ../../howto/regex.rst:375
msgid ""
":meth:`~re.Pattern.match` and :meth:`~re.Pattern.search` return ``None`` if "
"no match can be found.  If they're successful, a :ref:`match object <match-"
"objects>` instance is returned, containing information about the match: "
"where it starts and ends, the substring it matched, and more."
msgstr ""
":meth:`~re.Pattern.match` och :meth:`~re.Pattern.search` returnerar ``None``"
" om ingen matchning kan hittas.  Om de lyckas returneras en :ref:`match "
"object <match-objects>`\\-instans som innehåller information om matchningen:"
" var den börjar och slutar, den delsträng som matchades med mera."

#: ../../howto/regex.rst:380
msgid ""
"You can learn about this by interactively experimenting with the :mod:`re` "
"module.  If you have :mod:`tkinter` available, you may also want to look at "
":source:`Tools/demo/redemo.py`, a demonstration program included with the "
"Python distribution.  It allows you to enter REs and strings, and displays "
"whether the RE matches or fails. :file:`redemo.py` can be quite useful when "
"trying to debug a complicated RE."
msgstr ""

#: ../../howto/regex.rst:387
msgid ""
"This HOWTO uses the standard Python interpreter for its examples. First, run"
" the Python interpreter, import the :mod:`re` module, and compile a RE::"
msgstr ""
"Denna HOWTO använder standardtolken Python för sina exempel. Kör först "
"Python-tolken, importera modulen :mod:`re` och kompilera en RE::"

#: ../../howto/regex.rst:395
msgid ""
"Now, you can try matching various strings against the RE ``[a-z]+``.  An "
"empty string shouldn't match at all, since ``+`` means 'one or more "
"repetitions'. :meth:`~re.Pattern.match` should return ``None`` in this case,"
" which will cause the interpreter to print no output.  You can explicitly "
"print the result of :meth:`!match` to make this clear. ::"
msgstr ""
"Nu kan du försöka matcha olika strängar mot RE ``[a-z]+``.  En tom sträng "
"bör inte matchas alls, eftersom ``+`` betyder \"en eller flera "
"upprepningar\". :meth:`~re.Pattern.match` bör returnera ``None`` i det här "
"fallet, vilket gör att tolken inte skriver ut något.  Du kan uttryckligen "
"skriva ut resultatet av :meth:`!match` för att tydliggöra detta. ::"

#: ../../howto/regex.rst:405
msgid ""
"Now, let's try it on a string that it should match, such as ``tempo``.  In "
"this case, :meth:`~re.Pattern.match` will return a :ref:`match object "
"<match-objects>`, so you should store the result in a variable for later "
"use. ::"
msgstr ""
"Låt oss nu prova det på en sträng som det ska matcha, till exempel "
"``tempo``.  I det här fallet kommer :meth:`~re.Pattern.match` att returnera "
"en :ref:`match object <match-objects>`, så du bör lagra resultatet i en "
"variabel för senare användning. ::"

#: ../../howto/regex.rst:413
msgid ""
"Now you can query the :ref:`match object <match-objects>` for information "
"about the matching string.  Match object instances also have several methods"
" and attributes; the most important ones are:"
msgstr ""
"Nu kan du fråga :ref:`match object <match-objects>` efter information om den"
" matchande strängen.  Match-objektinstanser har också flera metoder och "
"attribut; de viktigaste är:"

#: ../../howto/regex.rst:420
msgid "``group()``"
msgstr "``group()``"

#: ../../howto/regex.rst:420
msgid "Return the string matched by the RE"
msgstr "Returnera den sträng som matchas av RE"

#: ../../howto/regex.rst:422
msgid "``start()``"
msgstr "``start()``"

#: ../../howto/regex.rst:422
msgid "Return the starting position of the match"
msgstr "Returnera startpositionen för matchen"

#: ../../howto/regex.rst:424
msgid "``end()``"
msgstr "``end()``"

#: ../../howto/regex.rst:424
msgid "Return the ending position of the match"
msgstr "Returnera slutpositionen för matchen"

#: ../../howto/regex.rst:426
msgid "``span()``"
msgstr "``span()``"

#: ../../howto/regex.rst:426
msgid "Return a tuple containing the (start, end) positions  of the match"
msgstr ""
"Returnera en tupel som innehåller matchningens (start, slut) positioner"

#: ../../howto/regex.rst:430
msgid "Trying these methods will soon clarify their meaning::"
msgstr "Att prova dessa metoder kommer snart att klargöra deras betydelse::"

#: ../../howto/regex.rst:439
msgid ""
":meth:`~re.Match.group` returns the substring that was matched by the RE.  "
":meth:`~re.Match.start` and :meth:`~re.Match.end` return the starting and "
"ending index of the match. :meth:`~re.Match.span` returns both start and end"
" indexes in a single tuple.  Since the :meth:`~re.Pattern.match` method only"
" checks if the RE matches at the start of a string, :meth:`!start` will "
"always be zero.  However, the :meth:`~re.Pattern.search` method of patterns "
"scans through the string, so  the match may not start at zero in that case. "
"::"
msgstr ""
":meth:`~re.Match.group` returnerar den delsträng som matchades av RE. "
":meth:`~re.Match.start` och :meth:`~re.Match.end` returnerar start- och "
"slutindex för matchningen. :meth:`~re.Match.span` returnerar både start- och"
" slutindex i en enda tupel.  Eftersom metoden :meth:`~re.Pattern.match` "
"endast kontrollerar om RE matchar i början av en sträng, kommer "
":meth:`!start` alltid att vara noll.  Men metoden :meth:`~re.Pattern.search`"
" i patterns skannar igenom strängen, så det är inte säkert att matchningen "
"börjar vid noll i det fallet. ::"

#: ../../howto/regex.rst:456
msgid ""
"In actual programs, the most common style is to store the :ref:`match object"
" <match-objects>` in a variable, and then check if it was ``None``.  This "
"usually looks like::"
msgstr ""
"I faktiska program är det vanligaste sättet att lagra :ref:`matchobjekt "
"<match-objects>` i en variabel och sedan kontrollera om det var ``None``.  "
"Detta ser vanligtvis ut som::"

#: ../../howto/regex.rst:467
msgid ""
"Two pattern methods return all of the matches for a pattern. "
":meth:`~re.Pattern.findall` returns a list of matching strings::"
msgstr ""
"Två mönstermetoder returnerar alla matchningar för ett mönster. "
":meth:`~re.Pattern.findall` returnerar en lista med matchande strängar::"

#: ../../howto/regex.rst:474
msgid ""
"The ``r`` prefix, making the literal a raw string literal, is needed in this"
" example because escape sequences in a normal \"cooked\" string literal that"
" are not recognized by Python, as opposed to regular expressions, now result"
" in a :exc:`DeprecationWarning` and will eventually become a "
":exc:`SyntaxError`.  See :ref:`the-backslash-plague`."
msgstr ""
"Prefixet ``r``, som gör literalen till en rå sträng-literal, behövs i detta "
"exempel eftersom escape-sekvenser i en normal \"tillagad\" sträng-literal "
"som inte känns igen av Python, till skillnad från reguljära uttryck, nu "
"resulterar i en :exc:`DeprecationWarning` och kommer så småningom att bli en"
" :exc:`SyntaxError`.  Se :ref:`the-backslash-plague`."

#: ../../howto/regex.rst:480
msgid ""
":meth:`~re.Pattern.findall` has to create the entire list before it can be "
"returned as the result.  The :meth:`~re.Pattern.finditer` method returns a "
"sequence of :ref:`match object <match-objects>` instances as an "
":term:`iterator`::"
msgstr ""
":meth:`~re.Pattern.findall` måste skapa hela listan innan den kan returneras"
" som resultat.  Metoden :meth:`~re.Pattern.finditer` returnerar en sekvens "
"av :ref:`match object <match-objects>` instanser som en :term:`iterator`::"

#: ../../howto/regex.rst:496
msgid "Module-Level Functions"
msgstr "Funktioner på modulnivå"

#: ../../howto/regex.rst:498
msgid ""
"You don't have to create a pattern object and call its methods; the "
":mod:`re` module also provides top-level functions called :func:`~re.match`,"
" :func:`~re.search`, :func:`~re.findall`, :func:`~re.sub`, and so forth.  "
"These functions take the same arguments as the corresponding pattern method "
"with the RE string added as the first argument, and still return either "
"``None`` or a :ref:`match object <match-objects>` instance. ::"
msgstr ""
"Du behöver inte skapa ett pattern-objekt och anropa dess metoder; modulen "
":mod:`re` tillhandahåller även funktioner på högsta nivå som heter "
":func:`~re.match`, :func:`~re.search`, :func:`~re.findall`, :func:`~re.sub` "
"och så vidare.  Dessa funktioner tar samma argument som motsvarande pattern-"
"metod med RE-strängen tillagd som första argument, och returnerar "
"fortfarande antingen ``None`` eller ett :ref:`match-objekt <match-objects>` "
"instance. ::"

#: ../../howto/regex.rst:510
msgid ""
"Under the hood, these functions simply create a pattern object for you and "
"call the appropriate method on it.  They also store the compiled object in a"
" cache, so future calls using the same RE won't need to parse the pattern "
"again and again."
msgstr ""
"Under huven skapar dessa funktioner helt enkelt ett mönsterobjekt åt dig och"
" anropar lämplig metod på det.  De lagrar också det kompilerade objektet i "
"en cache, så att framtida anrop med samma RE inte behöver analysera mönstret"
" om och om igen."

#: ../../howto/regex.rst:515
msgid ""
"Should you use these module-level functions, or should you get the pattern "
"and call its methods yourself?  If you're accessing a regex within a loop, "
"pre-compiling it will save a few function calls. Outside of loops, there's "
"not much difference thanks to the internal cache."
msgstr ""
"Ska du använda dessa funktioner på modulnivå, eller ska du hämta mönstret "
"och anropa dess metoder själv?  Om du kommer åt en regex i en loop sparar du"
" några funktionsanrop genom att förkompilera den. Utanför loopar är det inte"
" så stor skillnad tack vare den interna cachen."

#: ../../howto/regex.rst:523
msgid "Compilation Flags"
msgstr "Kompileringsflaggor"

#: ../../howto/regex.rst:525
msgid ""
"Compilation flags let you modify some aspects of how regular expressions "
"work. Flags are available in the :mod:`re` module under two names, a long "
"name such as :const:`IGNORECASE` and a short, one-letter form such as "
":const:`I`.  (If you're familiar with Perl's pattern modifiers, the one-"
"letter forms use the same letters; the short form of :const:`re.VERBOSE` is "
":const:`re.X`, for example.) Multiple flags can be specified by bitwise OR-"
"ing them; ``re.I | re.M`` sets both the :const:`I` and :const:`M` flags, for"
" example."
msgstr ""
"Med kompileringsflaggor kan du ändra vissa aspekter av hur reguljära uttryck"
" fungerar. Flaggor finns tillgängliga i modulen :mod:`re` under två namn, "
"ett långt namn som :const:`IGNORECASE` och en kort form med en bokstav som "
":const:`I`.  (Om du är bekant med Perls mönstermodifierare använder formerna"
" med en bokstav samma bokstäver; kortformen av :const:`re.VERBOSE` är till "
"exempel :const:`re.X`) Flera flaggor kan anges genom bitvis OR-ning av dem; "
"``re.I | re.M`` anger till exempel både flaggorna :const:`I` och :const:`M`."

#: ../../howto/regex.rst:533
msgid ""
"Here's a table of the available flags, followed by a more detailed "
"explanation of each one."
msgstr ""
"Här är en tabell över tillgängliga flaggor, följt av en mer detaljerad "
"förklaring av var och en."

#: ../../howto/regex.rst:537
msgid "Flag"
msgstr "Flagga"

#: ../../howto/regex.rst:537
msgid "Meaning"
msgstr "Betydelse"

#: ../../howto/regex.rst:539
msgid ":const:`ASCII`, :const:`A`"
msgstr ":const:`ASCII`, :const:`A`"

#: ../../howto/regex.rst:539
msgid ""
"Makes several escapes like ``\\w``, ``\\b``, ``\\s`` and ``\\d`` match only "
"on ASCII characters with the respective property."
msgstr ""
"Gör att flera escapes som ``\\w``, ``b``, ``s`` och ``d`` endast matchar "
"ASCII-tecken med respektive egenskap."

#: ../../howto/regex.rst:543
msgid ":const:`DOTALL`, :const:`S`"
msgstr ":const:`DOTALL`, :const:`S`"

#: ../../howto/regex.rst:543
msgid "Make ``.`` match any character, including newlines."
msgstr "Låt ``.`` matcha alla tecken, inklusive nya rader."

#: ../../howto/regex.rst:546
msgid ":const:`IGNORECASE`, :const:`I`"
msgstr ":const:`IGNORECASE`, :const:`I`"

#: ../../howto/regex.rst:546
msgid "Do case-insensitive matches."
msgstr "Gör matchningar utan hänsyn till skiftlägeskänslighet."

#: ../../howto/regex.rst:548
msgid ":const:`LOCALE`, :const:`L`"
msgstr ":const:`LOCALE`, :const:`L`"

#: ../../howto/regex.rst:548
msgid "Do a locale-aware match."
msgstr "Gör en lokalanpassad matchning."

#: ../../howto/regex.rst:550
msgid ":const:`MULTILINE`, :const:`M`"
msgstr ":const:`MULTILINE`, :const:`M`"

#: ../../howto/regex.rst:550
msgid "Multi-line matching, affecting ``^`` and ``$``."
msgstr "Matchning av flera rader, påverkar ``^`` och ``$``."

#: ../../howto/regex.rst:553
msgid ":const:`VERBOSE`, :const:`X` (for 'extended')"
msgstr ":const:`VERBOSE`, :const:`X` (för 'extended')"

#: ../../howto/regex.rst:553
msgid ""
"Enable verbose REs, which can be organized more cleanly and understandably."
msgstr ""
"Aktivera verbose RE:s, som kan organiseras på ett mer överskådligt och "
"begripligt sätt."

#: ../../howto/regex.rst:562
msgid ""
"Perform case-insensitive matching; character class and literal strings will "
"match letters by ignoring case.  For example, ``[A-Z]`` will match lowercase"
" letters, too. Full Unicode matching also works unless the :const:`ASCII` "
"flag is used to disable non-ASCII matches.  When the Unicode patterns "
"``[a-z]`` or ``[A-Z]`` are used in combination with the :const:`IGNORECASE` "
"flag, they will match the 52 ASCII letters and 4 additional non-ASCII "
"letters: 'İ' (U+0130, Latin capital letter I with dot above), 'ı' (U+0131, "
"Latin small letter dotless i), 'ſ' (U+017F, Latin small letter long s) and "
"'K' (U+212A, Kelvin sign).  ``Spam`` will match ``'Spam'``, ``'spam'``, "
"``'spAM'``, or ``'ſpam'`` (the latter is matched only in Unicode mode). This"
" lowercasing doesn't take the current locale into account; it will if you "
"also set the :const:`LOCALE` flag."
msgstr ""
"Utför matchning som inte är skiftlägeskänslig; teckenklasser och "
"bokstavssträngar matchar bokstäver genom att ignorera skiftlägeskänslighet. "
"Till exempel matchar ``[A-Z]`` även gemener. Fullständig Unicode-matchning "
"fungerar också om inte flaggan :const:`ASCII` används för att inaktivera "
"matchningar som inte är ASCII. När Unicode-mönstren ``[a-z]`` eller "
"``[A-Z]`` används i kombination med flaggan :const:`IGNORECASE` matchar de "
"de 52 ASCII-bokstäverna och 4 ytterligare icke-ASCII-bokstäver: 'İ' (U+0130,"
" latinsk versal I med punkt ovanför), ’ı’ (U+0131, latinsk gemen i utan "
"punkt), ’ſ’ (U+017F, latinsk gemen lång s) och ’K’ (U+212A, Kelvin-tecken). "
"``Spam`` matchar ``'Spam'``, ``'spam'``, ``'spAM'`` eller ``'ſpam'`` (det "
"senare matchas endast i Unicode-läge). Denna omvandling till gemener tar "
"inte hänsyn till den aktuella lokaliseringen; det gör den om du också anger "
"flaggan :const:`LOCALE`."

#: ../../howto/regex.rst:580
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B`` and case-insensitive matching "
"dependent on the current locale instead of the Unicode database."
msgstr ""
"Gör ``w``, ``W``, ``b``, ``B`` och skiftlägesokänslig matchning beroende av "
"aktuell locale istället för Unicode-databasen."

#: ../../howto/regex.rst:583
msgid ""
"Locales are a feature of the C library intended to help in writing programs "
"that take account of language differences.  For example, if you're "
"processing encoded French text, you'd want to be able to write ``\\w+`` to "
"match words, but ``\\w`` only matches the character class ``[A-Za-z]`` in "
"bytes patterns; it won't match bytes corresponding to ``é`` or ``ç``. If "
"your system is configured properly and a French locale is selected, certain "
"C functions will tell the program that the byte corresponding to ``é`` "
"should also be considered a letter. Setting the :const:`LOCALE` flag when "
"compiling a regular expression will cause the resulting compiled object to "
"use these C functions for ``\\w``; this is slower, but also enables ``\\w+``"
" to match French words as you'd expect. The use of this flag is discouraged "
"in Python 3 as the locale mechanism is very unreliable, it only handles one "
"\"culture\" at a time, and it only works with 8-bit locales.  Unicode "
"matching is already enabled by default in Python 3 for Unicode (str) "
"patterns, and it is able to handle different locales/languages."
msgstr ""
"Locales är en funktion i C-biblioteket som är avsedd att hjälpa till att "
"skriva program som tar hänsyn till språkskillnader.  Om du till exempel "
"bearbetar kodad fransk text skulle du vilja kunna skriva ``\\w+`` för att "
"matcha ord, men ``\\w`` matchar bara teckenklassen ``[A-Za-z]`` i "
"bytesmönster; den matchar inte bytes som motsvarar ``é`` eller ``ç``. Om "
"ditt system är korrekt konfigurerat och en fransk språkdräkt är vald, kommer"
" vissa C-funktioner att tala om för programmet att byten som motsvarar ``é``"
" också ska betraktas som en bokstav. Om du anger flaggan :const:`LOCALE` när"
" du kompilerar ett reguljärt uttryck kommer det resulterande kompilerade "
"objektet att använda dessa C-funktioner för ``w``; detta är långsammare, men"
" gör också att ``w+`` kan matcha franska ord som du förväntar dig. "
"Användningen av denna flagga är avrådd i Python 3 eftersom locale-mekanismen"
" är mycket opålitlig, den hanterar bara en \"kultur\" åt gången och den "
"fungerar bara med 8-bitars locales.  Unicode-matchning är redan aktiverad "
"som standard i Python 3 för Unicode (str)-mönster, och den kan hantera olika"
" lokala språk."

#: ../../howto/regex.rst:605
msgid ""
"(``^`` and ``$`` haven't been explained yet;  they'll be introduced in "
"section :ref:`more-metacharacters`.)"
msgstr ""
"(``^`` och ``$`` har inte förklarats ännu; de kommer att introduceras i "
"avsnittet :ref:`more-metacharacters`.)"

#: ../../howto/regex.rst:608
msgid ""
"Usually ``^`` matches only at the beginning of the string, and ``$`` matches"
" only at the end of the string and immediately before the newline (if any) "
"at the end of the string. When this flag is specified, ``^`` matches at the "
"beginning of the string and at the beginning of each line within the string,"
" immediately following each newline.  Similarly, the ``$`` metacharacter "
"matches either at the end of the string and at the end of each line "
"(immediately preceding each newline)."
msgstr ""
"Vanligtvis matchar ``^`` endast i början av strängen, och ``$`` matchar "
"endast i slutet av strängen och omedelbart före den nya raden (om någon) i "
"slutet av strängen. När denna flagga anges matchar ``^`` i början av "
"strängen och i början av varje rad i strängen, omedelbart efter varje ny "
"rad.  På samma sätt matchar metatecknet ``$`` antingen i slutet av strängen "
"eller i slutet av varje rad (omedelbart före varje ny rad)."

#: ../../howto/regex.rst:621
msgid ""
"Makes the ``'.'`` special character match any character at all, including a "
"newline; without this flag, ``'.'`` will match anything *except* a newline."
msgstr ""
"Gör att specialtecknet ``'.'`` matchar vilket tecken som helst, inklusive en"
" ny rad; utan denna flagga matchar ``'.'`` allt *utom* en ny rad."

#: ../../howto/regex.rst:629
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\s`` and ``\\S`` perform ASCII-"
"only matching instead of full Unicode matching. This is only meaningful for "
"Unicode patterns, and is ignored for byte patterns."
msgstr ""
"Få ``w``, ``W``, ``b``, ``B``, ``s`` och ``S`` att utföra matchning med "
"enbart ASCII istället för fullständig Unicode-matchning. Detta är endast "
"meningsfullt för Unicode-mönster och ignoreras för bytemönster."

#: ../../howto/regex.rst:638
msgid ""
"This flag allows you to write regular expressions that are more readable by "
"granting you more flexibility in how you can format them.  When this flag "
"has been specified, whitespace within the RE string is ignored, except when "
"the whitespace is in a character class or preceded by an unescaped "
"backslash; this lets you organize and indent the RE more clearly.  This flag"
" also lets you put comments within a RE that will be ignored by the engine; "
"comments are marked by a ``'#'`` that's neither in a character class or "
"preceded by an unescaped backslash."
msgstr ""
"Med den här flaggan kan du skriva reguljära uttryck som är mer läsbara genom"
" att du får mer flexibilitet i hur du kan formatera dem.  När den här "
"flaggan har angetts ignoreras blanksteg i RE-strängen, utom när blanksteget "
"är i en teckenklass eller föregås av en obegränsad backslash; detta gör att "
"du kan organisera och indentera RE mer tydligt.  Med den här flaggan kan du "
"också lägga in kommentarer i en RE som ignoreras av motorn; kommentarer "
"markeras med en ``'#'`` som varken är i en teckenklass eller föregås av ett "
"okapslat backslash."

#: ../../howto/regex.rst:647
msgid ""
"For example, here's a RE that uses :const:`re.VERBOSE`; see how much easier "
"it is to read? ::"
msgstr ""
"Här är till exempel en RE som använder :const:`re.VERBOSE`; ser du hur "
"mycket lättare den är att läsa? ::"

#: ../../howto/regex.rst:660
msgid "Without the verbose setting, the RE would look like this::"
msgstr "Utan verbose-inställningen skulle RE se ut så här::"

#: ../../howto/regex.rst:666
msgid ""
"In the above example, Python's automatic concatenation of string literals "
"has been used to break up the RE into smaller pieces, but it's still more "
"difficult to understand than the version using :const:`re.VERBOSE`."
msgstr ""
"I exemplet ovan har Pythons automatiska konkatenering av stränglitteraler "
"använts för att bryta upp RE i mindre bitar, men det är fortfarande svårare "
"att förstå än den version som använder :const:`re.VERBOSE`."

#: ../../howto/regex.rst:672
msgid "More Pattern Power"
msgstr "Mer mönsterkraft"

#: ../../howto/regex.rst:674
msgid ""
"So far we've only covered a part of the features of regular expressions.  In"
" this section, we'll cover some new metacharacters, and how to use groups to"
" retrieve portions of the text that was matched."
msgstr ""
"Hittills har vi bara gått igenom en del av funktionerna i reguljära uttryck."
"  I det här avsnittet går vi igenom några nya metatecken och hur man "
"använder grupper för att hämta delar av den text som matchades."

#: ../../howto/regex.rst:682
msgid "More Metacharacters"
msgstr "Fler metakaraktärer"

#: ../../howto/regex.rst:684
msgid ""
"There are some metacharacters that we haven't covered yet.  Most of them "
"will be covered in this section."
msgstr ""
"Det finns några metakaraktärer som vi inte har gått igenom ännu.  De flesta "
"av dem kommer att tas upp i detta avsnitt."

#: ../../howto/regex.rst:687
msgid ""
"Some of the remaining metacharacters to be discussed are :dfn:`zero-width "
"assertions`.  They don't cause the engine to advance through the string; "
"instead, they consume no characters at all, and simply succeed or fail.  For"
" example, ``\\b`` is an assertion that the current position is located at a "
"word boundary; the position isn't changed by the ``\\b`` at all.  This means"
" that zero-width assertions should never be repeated, because if they match "
"once at a given location, they can obviously be matched an infinite number "
"of times."
msgstr ""
"Några av de återstående metatecken som skall diskuteras är :dfn:`zero-width "
"assertions`.  De gör inte att motorn avancerar genom strängen, utan de "
"förbrukar inga tecken alls och lyckas eller misslyckas helt enkelt.  Till "
"exempel är ``b`` ett påstående om att den aktuella positionen ligger vid en "
"ordgräns; positionen ändras inte alls av ``b``.  Detta innebär att "
"påståenden med nollbredd aldrig bör upprepas, för om de matchar en gång på "
"en given plats kan de uppenbarligen matchas ett oändligt antal gånger."

#: ../../howto/regex.rst:703
msgid "``|``"
msgstr "``|``"

#: ../../howto/regex.rst:696
msgid ""
"Alternation, or the \"or\" operator.   If *A* and *B* are regular "
"expressions, ``A|B`` will match any string that matches either *A* or *B*. "
"``|`` has very low precedence in order to make it work reasonably when "
"you're alternating multi-character strings. ``Crow|Servo`` will match either"
" ``'Crow'`` or ``'Servo'``, not ``'Cro'``, a ``'w'`` or an ``'S'``, and "
"``'ervo'``."
msgstr ""
"Alternation, eller operatorn \"eller\".   Om *A* och *B* är reguljära "
"uttryck kommer ``A|B`` att matcha alla strängar som matchar antingen *A* "
"eller *B*. ``|`` har mycket låg prioritet för att det ska fungera på ett "
"rimligt sätt när du växlar strängar med flera tecken. ``Crow|Servo`` kommer "
"att matcha antingen ``'Crow'`` eller ``'Servo'``, inte ``'Cro'``, ett "
"``'w'`` eller ett ``'S'``, och ``'ervo'``."

#: ../../howto/regex.rst:702
msgid ""
"To match a literal ``'|'``, use ``\\|``, or enclose it inside a character "
"class, as in ``[|]``."
msgstr ""
"Om du vill matcha en literal ``'|'`` använder du ``\\|`` eller omsluter den "
"inne i en teckenklass, som i ``[|]``."

#: ../../howto/regex.rst:718
msgid "``^``"
msgstr "``^``"

#: ../../howto/regex.rst:706
msgid ""
"Matches at the beginning of lines.  Unless the :const:`MULTILINE` flag has "
"been set, this will only match at the beginning of the string.  In "
":const:`MULTILINE` mode, this also matches immediately after each newline "
"within the string."
msgstr ""
"Matchar i början av raderna.  Om inte flaggan :const:`MULTILINE` har "
"angetts, matchar detta endast i början av strängen.  I "
":const:`MULTILINE`\\-läget matchar detta även omedelbart efter varje ny rad "
"i strängen."

#: ../../howto/regex.rst:710
msgid ""
"For example, if you wish to match the word ``From`` only at the beginning of"
" a line, the RE to use is ``^From``. ::"
msgstr ""
"Om du till exempel vill matcha ordet ``From`` endast i början av en rad, är "
"RE att använda ``^From``. ::"

#: ../../howto/regex.rst:718
msgid "To match a literal ``'^'``, use ``\\^``."
msgstr "Om du vill matcha en bokstavlig ``'^'`` använder du ``^``."

#: ../../howto/regex.rst:732
msgid "``$``"
msgstr "``$``"

#: ../../howto/regex.rst:721
msgid ""
"Matches at the end of a line, which is defined as either the end of the "
"string, or any location followed by a newline character.     ::"
msgstr ""
"Matchar i slutet av en rad, vilket definieras som antingen slutet av "
"strängen eller en plats som följs av ett tecken för ny rad. ::"

#: ../../howto/regex.rst:731
msgid ""
"To match a literal ``'$'``, use ``\\$`` or enclose it inside a character "
"class, as in  ``[$]``."
msgstr ""
"Om du vill matcha en bokstavlig ``'$'`` använder du ``\\$`` eller omsluter "
"den med en teckenklass, som i ``[$]``."

#: ../../howto/regex.rst:738
msgid "``\\A``"
msgstr "``\\A``"

#: ../../howto/regex.rst:735
msgid ""
"Matches only at the start of the string.  When not in :const:`MULTILINE` "
"mode, ``\\A`` and ``^`` are effectively the same.  In :const:`MULTILINE` "
"mode, they're different: ``\\A`` still matches only at the beginning of the "
"string, but ``^`` may match at any location inside the string that follows a"
" newline character."
msgstr ""
"Matchar endast i början av strängen.  När det inte är i "
":const:`MULTILINE`\\-läge är ``A`` och ``^`` i praktiken samma sak.  I "
":const:`MULTILINE`\\-läget är de olika: ``A`` matchar fortfarande bara i "
"början av strängen, men ``^`` kan matcha på vilken plats som helst i "
"strängen som följer efter ett newline-tecken."

#: ../../howto/regex.rst:741
msgid "``\\Z``"
msgstr "``\\Z``"

#: ../../howto/regex.rst:741
msgid "Matches only at the end of the string."
msgstr "Matchar endast i slutet av strängen."

#: ../../howto/regex.rst:776
msgid "``\\b``"
msgstr "``\\b``"

#: ../../howto/regex.rst:744
msgid ""
"Word boundary.  This is a zero-width assertion that matches only at the "
"beginning or end of a word.  A word is defined as a sequence of alphanumeric"
" characters, so the end of a word is indicated by whitespace or a non-"
"alphanumeric character."
msgstr ""
"Ordgräns.  Detta är en assertion med noll bredd som endast matchar i början "
"eller slutet av ett ord.  Ett ord definieras som en sekvens av alfanumeriska"
" tecken, så slutet av ett ord indikeras av blanksteg eller ett icke-"
"alfanumeriskt tecken."

#: ../../howto/regex.rst:749
msgid ""
"The following example matches ``class`` only when it's a complete word; it "
"won't match when it's contained inside another word. ::"
msgstr ""
"Följande exempel matchar ``class`` endast när det är ett helt ord; det "
"kommer inte att matcha när det ingår i ett annat ord. ::"

#: ../../howto/regex.rst:760
msgid ""
"There are two subtleties you should remember when using this special "
"sequence. First, this is the worst collision between Python's string "
"literals and regular expression sequences.  In Python's string literals, "
"``\\b`` is the backspace character, ASCII value 8.  If you're not using raw "
"strings, then Python will convert the ``\\b`` to a backspace, and your RE "
"won't match as you expect it to. The following example looks the same as our"
" previous RE, but omits the ``'r'`` in front of the RE string. ::"
msgstr ""
"Det finns två saker du bör komma ihåg när du använder den här speciella "
"sekvensen. För det första är detta den värsta kollisionen mellan Pythons "
"stränglitteraler och sekvenser för reguljära uttryck.  I Pythons "
"stränglitteraler är ``b`` backspace-tecknet, ASCII-värde 8.  Om du inte "
"använder råa strängar kommer Python att konvertera ``b`` till ett backsteg, "
"och din RE kommer inte att matcha som du förväntar dig att den ska göra. "
"Följande exempel ser likadant ut som vår föregående RE, men utelämnar ``'r``"
" framför RE-strängen. ::"

#: ../../howto/regex.rst:774
msgid ""
"Second, inside a character class, where there's no use for this assertion, "
"``\\b`` represents the backspace character, for compatibility with Python's "
"string literals."
msgstr ""
"För det andra, i en teckenklass, där det inte finns någon användning för "
"detta påstående, representerar ``b`` backspace-tecknet, för kompatibilitet "
"med Pythons stränglitteraler."

#: ../../howto/regex.rst:781
msgid "``\\B``"
msgstr "``\\B``"

#: ../../howto/regex.rst:779
msgid ""
"Another zero-width assertion, this is the opposite of ``\\b``, only matching"
" when the current position is not at a word boundary."
msgstr ""
"Detta är motsatsen till ``b`` och matchar bara när den aktuella positionen "
"inte ligger vid en ordgräns."

#: ../../howto/regex.rst:784
msgid "Grouping"
msgstr "Gruppering"

#: ../../howto/regex.rst:786
msgid ""
"Frequently you need to obtain more information than just whether the RE "
"matched or not.  Regular expressions are often used to dissect strings by "
"writing a RE divided into several subgroups which match different components"
" of interest. For example, an RFC-822 header line is divided into a header "
"name and a value, separated by a ``':'``, like this:"
msgstr ""
"Ofta behöver man mer information än bara om RE:n matchar eller inte.  "
"Reguljära uttryck används ofta för att dissekera strängar genom att skriva "
"en RE som är uppdelad i flera undergrupper som matchar olika komponenter av "
"intresse. En rubrikrad i RFC-822 delas t.ex. upp i ett rubriknamn och ett "
"värde, åtskilda av ett ``':'``, så här:"

#: ../../howto/regex.rst:799
msgid ""
"This can be handled by writing a regular expression which matches an entire "
"header line, and has one group which matches the header name, and another "
"group which matches the header's value."
msgstr ""
"Detta kan hanteras genom att skriva ett reguljärt uttryck som matchar en hel"
" rubrikrad och har en grupp som matchar rubrikens namn och en annan grupp "
"som matchar rubrikens värde."

#: ../../howto/regex.rst:803
msgid ""
"Groups are marked by the ``'('``, ``')'`` metacharacters. ``'('`` and "
"``')'`` have much the same meaning as they do in mathematical expressions; "
"they group together the expressions contained inside them, and you can "
"repeat the contents of a group with a repeating qualifier, such as ``*``, "
"``+``, ``?``, or ``{m,n}``.  For example, ``(ab)*`` will match zero or more "
"repetitions of ``ab``. ::"
msgstr ""

#: ../../howto/regex.rst:814
msgid ""
"Groups indicated with ``'('``, ``')'`` also capture the starting and ending "
"index of the text that they match; this can be retrieved by passing an "
"argument to :meth:`~re.Match.group`, :meth:`~re.Match.start`, "
":meth:`~re.Match.end`, and :meth:`~re.Match.span`.  Groups are numbered "
"starting with 0.  Group 0 is always present; it's the whole RE, so "
":ref:`match object <match-objects>` methods all have group 0 as their "
"default argument.  Later we'll see how to express groups that don't capture "
"the span of text that they match. ::"
msgstr ""
"Grupper som indikeras med ``'('``, ``')'`` fångar också start- och slutindex"
" för texten som de matchar; detta kan hämtas genom att skicka ett argument "
"till :meth:`~re.Match.group`, :meth:`~re.Match.start`, "
":meth:`~re.Match.end`, och :meth:`~re.Match.span`.  Grupperna är numrerade "
"med början på 0. Grupp 0 finns alltid; det är hela RE, så :ref:`match object"
" <match-objects>` -metoderna har alla grupp 0 som standardargument.  Senare "
"ska vi se hur man uttrycker grupper som inte fångar det textavsnitt som de "
"matchar. ::"

#: ../../howto/regex.rst:830
msgid ""
"Subgroups are numbered from left to right, from 1 upward.  Groups can be "
"nested; to determine the number, just count the opening parenthesis "
"characters, going from left to right. ::"
msgstr ""
"Undergrupperna numreras från vänster till höger, från 1 och uppåt.  Grupper "
"kan vara kapslade; för att bestämma antalet räknar man bara de inledande "
"parentestecknen från vänster till höger. ::"

#: ../../howto/regex.rst:843
msgid ""
":meth:`~re.Match.group` can be passed multiple group numbers at a time, in "
"which case it will return a tuple containing the corresponding values for "
"those groups. ::"
msgstr ""
":meth:`~re.Match.group` kan ges flera gruppnummer åt gången, i vilket fall "
"den kommer att returnera en tupel som innehåller motsvarande värden för "
"dessa grupper. ::"

#: ../../howto/regex.rst:849
msgid ""
"The :meth:`~re.Match.groups` method returns a tuple containing the strings "
"for all the subgroups, from 1 up to however many there are. ::"
msgstr ""
"Metoden :meth:`~re.Match.groups` returnerar en tupel som innehåller "
"strängarna för alla undergrupper, från 1 upp till hur många som helst. ::"

#: ../../howto/regex.rst:855
msgid ""
"Backreferences in a pattern allow you to specify that the contents of an "
"earlier capturing group must also be found at the current location in the "
"string.  For example, ``\\1`` will succeed if the exact contents of group 1 "
"can be found at the current position, and fails otherwise.  Remember that "
"Python's string literals also use a backslash followed by numbers to allow "
"including arbitrary characters in a string, so be sure to use a raw string "
"when incorporating backreferences in a RE."
msgstr ""
"Med hjälp av bakåtreferenser i ett mönster kan du ange att innehållet i en "
"tidigare fångad grupp också måste finnas på den aktuella platsen i strängen."
"  Till exempel kommer ``1`` att lyckas om det exakta innehållet i grupp 1 "
"kan hittas på den aktuella positionen, och misslyckas annars.  Kom ihåg att "
"Pythons stränglitteraler också använder ett backslash följt av siffror för "
"att tillåta att godtyckliga tecken inkluderas i en sträng, så se till att "
"använda en rå sträng när du införlivar bakåtreferenser i en RE."

#: ../../howto/regex.rst:863
msgid "For example, the following RE detects doubled words in a string. ::"
msgstr "Följande RE upptäcker till exempel dubbla ord i en sträng: ::"

#: ../../howto/regex.rst:869
msgid ""
"Backreferences like this aren't often useful for just searching through a "
"string --- there are few text formats which repeat data in this way --- but "
"you'll soon find out that they're *very* useful when performing string "
"substitutions."
msgstr ""
"Sådana här backreferenser är inte ofta användbara för att bara söka igenom "
"en sträng --- det finns få textformat som upprepar data på det här sättet "
"--- men du kommer snart att upptäcka att de är *mycket* användbara när du "
"utför strängsubstitutioner."

#: ../../howto/regex.rst:875
msgid "Non-capturing and Named Groups"
msgstr "Icke-fångande och namngivna grupper"

#: ../../howto/regex.rst:877
msgid ""
"Elaborate REs may use many groups, both to capture substrings of interest, "
"and to group and structure the RE itself.  In complex REs, it becomes "
"difficult to keep track of the group numbers.  There are two features which "
"help with this problem.  Both of them use a common syntax for regular "
"expression extensions, so we'll look at that first."
msgstr ""
"I komplicerade RE:er kan många grupper användas, både för att fånga upp "
"intressanta delsträngar och för att gruppera och strukturera själva RE:n.  I"
" komplexa RE:er blir det svårt att hålla reda på gruppnumren.  Det finns två"
" funktioner som hjälper till att lösa detta problem.  Båda använder en "
"gemensam syntax för tillägg till reguljära uttryck, så vi tittar på det "
"först."

#: ../../howto/regex.rst:883
msgid ""
"Perl 5 is well known for its powerful additions to standard regular "
"expressions. For these new features the Perl developers couldn't choose new "
"single-keystroke metacharacters or new special sequences beginning with "
"``\\`` without making Perl's regular expressions confusingly different from "
"standard REs.  If they chose ``&`` as a new metacharacter, for example, old "
"expressions would be assuming that ``&`` was a regular character and "
"wouldn't have escaped it by writing ``\\&`` or ``[&]``."
msgstr ""
"Perl 5 är välkänt för sina kraftfulla tillägg till standardmässiga reguljära"
" uttryck. För dessa nya funktioner kunde Perl-utvecklarna inte välja nya "
"metatecken med ett enda tangenttryck eller nya specialsekvenser som börjar "
"med ``\\`` utan att göra Perls reguljära uttryck förvirrande olika från "
"standardmässiga reguljära uttryck. Om de till exempel hade valt ``&`` som "
"nytt metatecken skulle gamla uttryck anta att ``&`` var ett vanligt tecken "
"och inte skulle ha undvikit det genom att skriva ``\\&`` eller ``[&]``."

#: ../../howto/regex.rst:890
msgid ""
"The solution chosen by the Perl developers was to use ``(?...)`` as the "
"extension syntax.  ``?`` immediately after a parenthesis was a syntax error "
"because the ``?`` would have nothing to repeat, so this didn't introduce any"
" compatibility problems.  The characters immediately after the ``?``  "
"indicate what extension is being used, so ``(?=foo)`` is one thing (a "
"positive lookahead assertion) and ``(?:foo)`` is something else (a non-"
"capturing group containing the subexpression ``foo``)."
msgstr ""
"Den lösning som Perl-utvecklarna valde var att använda ``(?...)`` som "
"utvidgningssyntax.  ``?`` omedelbart efter en parentes var ett syntaxfel "
"eftersom ``?`` inte skulle ha något att upprepa, så detta medförde inga "
"kompatibilitetsproblem.  Tecknen omedelbart efter ``?`` anger vilket tillägg"
" som används, så ``(?=foo)`` är en sak (ett positivt lookahead-assertion) "
"och ``(?:foo)`` är något annat (en icke-fångande grupp som innehåller "
"underuttrycket ``foo``)."

#: ../../howto/regex.rst:898
msgid ""
"Python supports several of Perl's extensions and adds an extension syntax to"
" Perl's extension syntax.  If the first character after the question mark is"
" a ``P``, you know that it's an extension that's specific to Python."
msgstr ""
"Python stöder flera av Perls tillägg och lägger till en tilläggssyntax till "
"Perls tilläggssyntax.  Om det första tecknet efter frågetecknet är ett ``P``"
" vet du att det är ett tillägg som är specifikt för Python."

#: ../../howto/regex.rst:903
msgid ""
"Now that we've looked at the general extension syntax, we can return to the "
"features that simplify working with groups in complex REs."
msgstr ""
"Nu när vi har tittat på den allmänna syntaxen för tillägg kan vi återgå till"
" de funktioner som förenklar arbetet med grupper i komplexa RE:er."

#: ../../howto/regex.rst:906
msgid ""
"Sometimes you'll want to use a group to denote a part of a regular "
"expression, but aren't interested in retrieving the group's contents. You "
"can make this fact explicit by using a non-capturing group: ``(?:...)``, "
"where you can replace the ``...`` with any other regular expression. ::"
msgstr ""
"Ibland vill du använda en grupp för att beteckna en del av ett reguljärt "
"uttryck, men du är inte intresserad av att hämta gruppens innehåll. Du kan "
"göra detta faktum explicit genom att använda en icke-fångande grupp: "
"``(?:...)``, där du kan ersätta ``...`` med vilket annat reguljärt uttryck "
"som helst. ::"

#: ../../howto/regex.rst:918
msgid ""
"Except for the fact that you can't retrieve the contents of what the group "
"matched, a non-capturing group behaves exactly the same as a capturing "
"group; you can put anything inside it, repeat it with a repetition "
"metacharacter such as ``*``, and nest it within other groups (capturing or "
"non-capturing). ``(?:...)`` is particularly useful when modifying an "
"existing pattern, since you can add new groups without changing how all the "
"other groups are numbered.  It should be mentioned that there's no "
"performance difference in searching between capturing and non-capturing "
"groups; neither form is any faster than the other."
msgstr ""
"Förutom det faktum att du inte kan hämta innehållet i det som gruppen "
"matchade, beter sig en icke-fångande grupp exakt likadant som en fångande "
"grupp; du kan lägga in vad som helst i den, upprepa den med ett metatecken "
"för upprepning som ``*`` och nesta den i andra grupper (fångande eller icke-"
"fångande). ``(?:...)`` är särskilt användbart när du ändrar ett befintligt "
"mönster, eftersom du kan lägga till nya grupper utan att ändra hur alla "
"andra grupper är numrerade.  Det bör nämnas att det inte finns någon "
"prestandaskillnad i sökningen mellan fångande och icke-fångande grupper; "
"ingen av formerna är snabbare än den andra."

#: ../../howto/regex.rst:927
msgid ""
"A more significant feature is named groups: instead of referring to them by "
"numbers, groups can be referenced by a name."
msgstr ""
"En mer betydelsefull funktion är namngivna grupper: i stället för att "
"hänvisa till dem med nummer kan grupper hänvisas till med ett namn."

#: ../../howto/regex.rst:930
msgid ""
"The syntax for a named group is one of the Python-specific extensions: "
"``(?P<name>...)``.  *name* is, obviously, the name of the group.  Named "
"groups behave exactly like capturing groups, and additionally associate a "
"name with a group.  The :ref:`match object <match-objects>` methods that "
"deal with capturing groups all accept either integers that refer to the "
"group by number or strings that contain the desired group's name.  Named "
"groups are still given numbers, so you can retrieve information about a "
"group in two ways::"
msgstr ""
"Syntaxen för en namngiven grupp är ett av de Python-specifika tilläggen: "
"``(?P<name>...)``.  *name* är naturligtvis namnet på gruppen.  Namngivna "
"grupper beter sig precis som fångande grupper, och associerar dessutom ett "
"namn med en grupp.  Metoderna :ref:`match object <match-objects>` som "
"hanterar fångande grupper accepterar alla antingen heltal som hänvisar till "
"gruppen med nummer eller strängar som innehåller den önskade gruppens namn."
"  Namngivna grupper ges fortfarande nummer, så du kan hämta information om "
"en grupp på två sätt::"

#: ../../howto/regex.rst:945
msgid ""
"Additionally, you can retrieve named groups as a dictionary with "
":meth:`~re.Match.groupdict`::"
msgstr ""
"Dessutom kan du hämta namngivna grupper som en ordbok med "
":meth:`~re.Match.groupdict`::"

#: ../../howto/regex.rst:952
msgid ""
"Named groups are handy because they let you use easily-remembered names, "
"instead of having to remember numbers.  Here's an example RE from the "
":mod:`imaplib` module::"
msgstr ""

#: ../../howto/regex.rst:963
msgid ""
"It's obviously much easier to retrieve ``m.group('zonem')``, instead of "
"having to remember to retrieve group 9."
msgstr ""
"Det är uppenbarligen mycket enklare att hämta ``m.group('zonem')``, istället"
" för att behöva komma ihåg att hämta grupp 9."

#: ../../howto/regex.rst:966
msgid ""
"The syntax for backreferences in an expression such as ``(...)\\1`` refers "
"to the number of the group.  There's naturally a variant that uses the group"
" name instead of the number. This is another Python extension: ``(?P=name)``"
" indicates that the contents of the group called *name* should again be "
"matched at the current point.  The regular expression for finding doubled "
"words, ``\\b(\\w+)\\s+\\1\\b`` can also be written as "
"``\\b(?P<word>\\w+)\\s+(?P=word)\\b``::"
msgstr ""
"Syntaxen för backreferenser i ett uttryck som ``(...)\\1`` hänvisar till "
"gruppens nummer.  Det finns naturligtvis en variant som använder gruppnamnet"
" i stället för numret. Detta är ett annat Python-tillägg: ``(?P=namn)`` "
"indikerar att innehållet i gruppen som heter *namn* återigen ska matchas vid"
" den aktuella punkten.  Det reguljära uttrycket för att hitta dubblerade "
"ord, ``\\b(\\w+)\\s+\\1\\b`` kan också skrivas som "
"``\\b(?P<word>\\w+)\\s+(?P=ord)\\b``::"

#: ../../howto/regex.rst:979
msgid "Lookahead Assertions"
msgstr "Förutseende påståenden"

#: ../../howto/regex.rst:981
msgid ""
"Another zero-width assertion is the lookahead assertion.  Lookahead "
"assertions are available in both positive and negative form, and  look like "
"this:"
msgstr ""
"Ett annat nollbreddsassertion är lookahead-assertion.  Lookahead-assertions "
"finns i både positiv och negativ form och ser ut så här:"

#: ../../howto/regex.rst:989
msgid "``(?=...)``"
msgstr "``(?=...)``"

#: ../../howto/regex.rst:985
msgid ""
"Positive lookahead assertion.  This succeeds if the contained regular "
"expression, represented here by ``...``, successfully matches at the current"
" location, and fails otherwise. But, once the contained expression has been "
"tried, the matching engine doesn't advance at all; the rest of the pattern "
"is tried right where the assertion started."
msgstr ""
"Positivt påstående om lookahead.  Detta lyckas om det ingående reguljära "
"uttrycket, som här representeras av ``...``, framgångsrikt matchar på den "
"aktuella platsen, och misslyckas annars. Men när det inneslutna uttrycket "
"har prövats går matchningsmotorn inte vidare alls; resten av mönstret prövas"
" precis där påståendet började."

#: ../../howto/regex.rst:994
msgid "``(?!...)``"
msgstr "``(?!...)``"

#: ../../howto/regex.rst:992
msgid ""
"Negative lookahead assertion.  This is the opposite of the positive "
"assertion; it succeeds if the contained expression *doesn't* match at the "
"current position in the string."
msgstr ""
"Negativt framåtblickande påstående.  Detta är motsatsen till det positiva "
"påståendet; det lyckas om det ingående uttrycket *inte* matchar vid den "
"aktuella positionen i strängen."

#: ../../howto/regex.rst:996
msgid ""
"To make this concrete, let's look at a case where a lookahead is useful. "
"Consider a simple pattern to match a filename and split it apart into a base"
" name and an extension, separated by a ``.``.  For example, in ``news.rc``, "
"``news`` is the base name, and ``rc`` is the filename's extension."
msgstr ""
"För att konkretisera detta ska vi titta på ett fall där en lookahead är "
"användbar. Tänk på ett enkelt mönster för att matcha ett filnamn och dela "
"upp det i ett basnamn och ett tillägg, åtskilda av en ``.``.  I till exempel"
" ``news.rc`` är ``news`` basnamnet och ``rc`` är filnamnets tillägg."

#: ../../howto/regex.rst:1001
msgid "The pattern to match this is quite simple:"
msgstr "Mönstret för att matcha detta är ganska enkelt:"

#: ../../howto/regex.rst:1003
msgid "``.*[.].*$``"
msgstr "``.*[.].*$``"

#: ../../howto/regex.rst:1005
msgid ""
"Notice that the ``.`` needs to be treated specially because it's a "
"metacharacter, so it's inside a character class to only match that specific "
"character.  Also notice the trailing ``$``; this is added to ensure that all"
" the rest of the string must be included in the extension.  This regular "
"expression matches ``foo.bar`` and ``autoexec.bat`` and ``sendmail.cf`` and "
"``printers.conf``."
msgstr ""
"Lägg märke till att ``.`` måste behandlas speciellt eftersom det är ett "
"metatecken, så det är inuti en teckenklass som bara matchar det specifika "
"tecknet.  Lägg också märke till det efterföljande ``$``; detta läggs till "
"för att säkerställa att resten av strängen måste inkluderas i tillägget.  "
"Detta reguljära uttryck matchar ``foo.bar`` och ``autoexec.bat`` och "
"``endmail.cf`` och ``printers.conf``."

#: ../../howto/regex.rst:1012
msgid ""
"Now, consider complicating the problem a bit; what if you want to match "
"filenames where the extension is not ``bat``? Some incorrect attempts:"
msgstr ""
"Tänk nu på att komplicera problemet lite; vad händer om du vill matcha "
"filnamn där tillägget inte är ``bat``? Några felaktiga försök:"

#: ../../howto/regex.rst:1015
msgid ""
"``.*[.][^b].*$``  The first attempt above tries to exclude ``bat`` by "
"requiring that the first character of the extension is not a ``b``.  This is"
" wrong, because the pattern also doesn't match ``foo.bar``."
msgstr ""

#: ../../howto/regex.rst:1019
msgid "``.*[.]([^b]..|.[^a].|..[^t])$``"
msgstr "``.*[.]([^b]..|.[^a].|..[^t])$``"

#: ../../howto/regex.rst:1021
msgid ""
"The expression gets messier when you try to patch up the first solution by "
"requiring one of the following cases to match: the first character of the "
"extension isn't ``b``; the second character isn't ``a``; or the third "
"character isn't ``t``.  This accepts ``foo.bar`` and rejects "
"``autoexec.bat``, but it requires a three-letter extension and won't accept "
"a filename with a two-letter extension such as ``sendmail.cf``.  We'll "
"complicate the pattern again in an effort to fix it."
msgstr ""
"Uttrycket blir rörigare när du försöker lappa ihop den första lösningen "
"genom att kräva att något av följande fall ska matcha: det första tecknet i "
"tillägget är inte ``b``; det andra tecknet är inte ``a``; eller det tredje "
"tecknet är inte ``t``.  Detta accepterar ``foo.bar`` och avvisar "
"``autoexec.bat``, men det kräver ett tillägg på tre bokstäver och accepterar"
" inte ett filnamn med ett tillägg på två bokstäver som ``endmail.cf``.  Vi "
"ska komplicera mönstret igen i ett försök att lösa det."

#: ../../howto/regex.rst:1029
msgid "``.*[.]([^b].?.?|.[^a]?.?|..?[^t]?)$``"
msgstr "``.*[.]([^b].?.?|.[^a]?.?|..?[^t]?)$``"

#: ../../howto/regex.rst:1031
msgid ""
"In the third attempt, the second and third letters are all made optional in "
"order to allow matching extensions shorter than three characters, such as "
"``sendmail.cf``."
msgstr ""
"I det tredje försöket görs den andra och tredje bokstaven valfria för att "
"möjliggöra matchning av tillägg som är kortare än tre tecken, t.ex. "
"``sendmail.cf``."

#: ../../howto/regex.rst:1035
msgid ""
"The pattern's getting really complicated now, which makes it hard to read "
"and understand.  Worse, if the problem changes and you want to exclude both "
"``bat`` and ``exe`` as extensions, the pattern would get even more "
"complicated and confusing."
msgstr ""
"Mönstret börjar bli riktigt komplicerat nu, vilket gör det svårt att läsa "
"och förstå.  Än värre, om problemet ändras och du vill utesluta både ``bat``"
" och ``exe`` som tillägg, skulle mönstret bli ännu mer komplicerat och "
"förvirrande."

#: ../../howto/regex.rst:1040
msgid "A negative lookahead cuts through all this confusion:"
msgstr "En negativ framåtblickande prognos skär igenom all denna förvirring:"

#: ../../howto/regex.rst:1042
msgid ""
"``.*[.](?!bat$)[^.]*$``  The negative lookahead means: if the expression "
"``bat`` doesn't match at this point, try the rest of the pattern; if "
"``bat$`` does match, the whole pattern will fail.  The trailing ``$`` is "
"required to ensure that something like ``sample.batch``, where the extension"
" only starts with ``bat``, will be allowed.  The ``[^.]*`` makes sure that "
"the pattern works when there are multiple dots in the filename."
msgstr ""

#: ../../howto/regex.rst:1049
msgid ""
"Excluding another filename extension is now easy; simply add it as an "
"alternative inside the assertion.  The following pattern excludes filenames "
"that end in either ``bat`` or ``exe``:"
msgstr ""
"Det är nu enkelt att utesluta ett annat filnamnstillägg; lägg bara till det "
"som ett alternativ i påståendet.  Följande mönster utesluter filnamn som "
"slutar på antingen ``bat`` eller ``exe``:"

#: ../../howto/regex.rst:1053
msgid "``.*[.](?!bat$|exe$)[^.]*$``"
msgstr "``.*[.](?!bat$|exe$)[^.]*$``"

#: ../../howto/regex.rst:1057
msgid "Modifying Strings"
msgstr "Modifiera strängar"

#: ../../howto/regex.rst:1059
msgid ""
"Up to this point, we've simply performed searches against a static string. "
"Regular expressions are also commonly used to modify strings in various "
"ways, using the following pattern methods:"
msgstr ""
"Hittills har vi bara gjort sökningar mot en statisk sträng. Reguljära "
"uttryck används också ofta för att modifiera strängar på olika sätt, med "
"hjälp av följande mönstermetoder:"

#: ../../howto/regex.rst:1066
msgid "``split()``"
msgstr "``split()``"

#: ../../howto/regex.rst:1066
msgid "Split the string into a list, splitting it wherever the RE matches"
msgstr "Dela upp strängen i en lista och dela upp den där RE matchar"

#: ../../howto/regex.rst:1069
msgid "``sub()``"
msgstr "``sub()``"

#: ../../howto/regex.rst:1069
msgid ""
"Find all substrings where the RE matches, and replace them with a different "
"string"
msgstr ""
"Hitta alla delsträngar där RE matchar och ersätt dem med en annan sträng"

#: ../../howto/regex.rst:1072
msgid "``subn()``"
msgstr "``subn()``"

#: ../../howto/regex.rst:1072
msgid ""
"Does the same thing as :meth:`!sub`,  but returns the new string and the "
"number of replacements"
msgstr ""
"Gör samma sak som :meth:`!sub`, men returnerar den nya strängen och antalet "
"ersättningar"

#: ../../howto/regex.rst:1079
msgid "Splitting Strings"
msgstr "Delning av strängar"

#: ../../howto/regex.rst:1081
msgid ""
"The :meth:`~re.Pattern.split` method of a pattern splits a string apart "
"wherever the RE matches, returning a list of the pieces. It's similar to the"
" :meth:`~str.split` method of strings but provides much more generality in "
"the delimiters that you can split by; string :meth:`!split` only supports "
"splitting by whitespace or by a fixed string.  As you'd expect, there's a "
"module-level :func:`re.split` function, too."
msgstr ""
"Metoden :meth:`~re.Pattern.split` för ett mönster delar upp en sträng där RE"
" matchar och returnerar en lista över delarna. Den liknar metoden "
":meth:`~str.split` för strängar men är mycket mer generell när det gäller de"
" avgränsare som du kan dela upp med; sträng :meth:`!split` stöder bara "
"uppdelning med blanksteg eller med en fast sträng.  Som du kan förvänta dig "
"finns det också en funktion på modulnivå :func:`re.split`."

#: ../../howto/regex.rst:1092
msgid ""
"Split *string* by the matches of the regular expression.  If capturing "
"parentheses are used in the RE, then their contents will also be returned as"
" part of the resulting list.  If *maxsplit* is nonzero, at most *maxsplit* "
"splits are performed."
msgstr ""
"Dela upp *sträng* efter matchningarna i det reguljära uttrycket.  Om "
"fångande parenteser används i RE, kommer deras innehåll också att returneras"
" som en del av den resulterande listan.  Om *maxsplit* är ett annat värde än"
" noll utförs högst *maxsplit* uppdelningar."

#: ../../howto/regex.rst:1097
msgid ""
"You can limit the number of splits made, by passing a value for *maxsplit*. "
"When *maxsplit* is nonzero, at most *maxsplit* splits will be made, and the "
"remainder of the string is returned as the final element of the list.  In "
"the following example, the delimiter is any sequence of non-alphanumeric "
"characters. ::"
msgstr ""
"Du kan begränsa antalet uppdelningar som görs genom att ange ett värde för "
"*maxsplit*. När *maxsplit* inte är noll görs högst *maxsplit* uppdelningar "
"och resten av strängen returneras som det sista elementet i listan.  I "
"följande exempel är avgränsaren en valfri sekvens av icke-alfanumeriska "
"tecken. ::"

#: ../../howto/regex.rst:1109
msgid ""
"Sometimes you're not only interested in what the text between delimiters is,"
" but also need to know what the delimiter was.  If capturing parentheses are"
" used in the RE, then their values are also returned as part of the list.  "
"Compare the following calls::"
msgstr ""
"Ibland är man inte bara intresserad av vad texten mellan avgränsarna är, "
"utan behöver också veta vad avgränsaren var.  Om fångande parenteser används"
" i RE returneras även deras värden som en del av listan.  Jämför följande "
"anrop::"

#: ../../howto/regex.rst:1121
msgid ""
"The module-level function :func:`re.split` adds the RE to be used as the "
"first argument, but is otherwise the same.   ::"
msgstr ""
"Funktionen på modulnivå :func:`re.split` lägger till den RE som ska användas"
" som första argument, men är i övrigt densamma. ::"

#: ../../howto/regex.rst:1133
msgid "Search and Replace"
msgstr "Sök och ersätt"

#: ../../howto/regex.rst:1135
msgid ""
"Another common task is to find all the matches for a pattern, and replace "
"them with a different string.  The :meth:`~re.Pattern.sub` method takes a "
"replacement value, which can be either a string or a function, and the "
"string to be processed."
msgstr ""
"En annan vanlig uppgift är att hitta alla matchningar för ett mönster och "
"ersätta dem med en annan sträng.  Metoden :meth:`~re.Pattern.sub` tar ett "
"ersättningsvärde, som kan vara antingen en sträng eller en funktion, och den"
" sträng som ska bearbetas."

#: ../../howto/regex.rst:1142
msgid ""
"Returns the string obtained by replacing the leftmost non-overlapping "
"occurrences of the RE in *string* by the replacement *replacement*.  If the "
"pattern isn't found, *string* is returned unchanged."
msgstr ""
"Returnerar strängen som erhålls genom att ersätta de längst till vänster "
"liggande icke-överlappande förekomsterna av RE i *sträng* med ersättningen "
"*replacement*.  Om mönstret inte hittas returneras *sträng* oförändrad."

#: ../../howto/regex.rst:1146
msgid ""
"The optional argument *count* is the maximum number of pattern occurrences "
"to be replaced; *count* must be a non-negative integer.  The default value "
"of 0 means to replace all occurrences."
msgstr ""
"Det valfria argumentet *count* är det maximala antalet mönsterförekomster "
"som ska ersättas; *count* måste vara ett icke-negativt heltal.  "
"Standardvärdet 0 innebär att alla förekomster ersätts."

#: ../../howto/regex.rst:1150
msgid ""
"Here's a simple example of using the :meth:`~re.Pattern.sub` method.  It "
"replaces colour names with the word ``colour``::"
msgstr ""
"Här är ett enkelt exempel på användning av metoden :meth:`~re.Pattern.sub`."
"  Den ersätter färgnamn med ordet ``colour``::"

#: ../../howto/regex.rst:1159
msgid ""
"The :meth:`~re.Pattern.subn` method does the same work, but returns a "
"2-tuple containing the new string value and the number of replacements  that"
" were performed::"
msgstr ""
"Metoden :meth:`~re.Pattern.subn` gör samma sak, men returnerar en 2-tupel "
"som innehåller det nya strängvärdet och antalet ersättningar som utfördes::"

#: ../../howto/regex.rst:1168
msgid ""
"Empty matches are replaced only when they're not adjacent to a previous "
"empty match. ::"
msgstr ""
"Tomma tändstickor ersätts endast om de inte ligger intill en tidigare tom "
"tändsticka:"

#: ../../howto/regex.rst:1175
msgid ""
"If *replacement* is a string, any backslash escapes in it are processed.  "
"That is, ``\\n`` is converted to a single newline character, ``\\r`` is "
"converted to a carriage return, and so forth. Unknown escapes such as "
"``\\&`` are left alone. Backreferences, such as ``\\6``, are replaced with "
"the substring matched by the corresponding group in the RE.  This lets you "
"incorporate portions of the original text in the resulting replacement "
"string."
msgstr ""
"Om *replacement* är en sträng behandlas alla backslash-escapes i den.  Det "
"innebär att ``\\n`` konverteras till ett enda tecken för ny rad, ``\\r`` "
"konverteras till en vagnsretur och så vidare. Okända escape-tecken som ``&``"
" lämnas därhän. Bakreferenser, t.ex. ``6``, ersätts med den delsträng som "
"matchas av motsvarande grupp i RE.  Detta gör att du kan införliva delar av "
"originaltexten i den resulterande ersättningssträngen."

#: ../../howto/regex.rst:1182
msgid ""
"This example matches the word ``section`` followed by a string enclosed in "
"``{``, ``}``, and changes ``section`` to ``subsection``::"
msgstr ""
"Detta exempel matchar ordet ``section`` följt av en sträng innesluten i "
"``{``, ``}`` och ändrar ``section`` till ``subsection``::"

#: ../../howto/regex.rst:1189
msgid ""
"There's also a syntax for referring to named groups as defined by the "
"``(?P<name>...)`` syntax.  ``\\g<name>`` will use the substring matched by "
"the group named ``name``, and  ``\\g<number>``  uses the corresponding group"
" number. ``\\g<2>`` is therefore equivalent to ``\\2``,  but isn't ambiguous"
" in a replacement string such as ``\\g<2>0``.  (``\\20`` would be "
"interpreted as a reference to group 20, not a reference to group 2 followed "
"by the literal character ``'0'``.)  The following substitutions are all "
"equivalent, but use all three variations of the replacement string. ::"
msgstr ""
"Det finns också en syntax för att hänvisa till namngivna grupper som "
"definieras av syntaxen ``(?P<name>...)``.  ``\\g<name>`` kommer att använda "
"den delsträng som matchas av gruppen med namnet ``namn``, och ``g<number>`` "
"använder motsvarande gruppnummer. ``\\g<2>`` är därför likvärdigt med ``2``,"
" men är inte tvetydigt i en ersättningssträng som ``\\g<2>0``.  (``20`` "
"skulle tolkas som en referens till grupp 20, inte som en referens till grupp"
" 2 följt av det bokstavliga tecknet ``'0``)  Följande ersättningar är alla "
"likvärdiga, men använd alla tre varianterna av ersättningssträngen:"

#: ../../howto/regex.rst:1206
msgid ""
"*replacement* can also be a function, which gives you even more control.  If"
" *replacement* is a function, the function is called for every non-"
"overlapping occurrence of *pattern*.  On each call, the function is passed a"
" :ref:`match object <match-objects>` argument for the match and can use this"
" information to compute the desired replacement string and return it."
msgstr ""
"*replacement* kan också vara en funktion, vilket ger dig ännu mer kontroll."
"  Om *replacement* är en funktion anropas funktionen för varje icke-"
"överlappande förekomst av *pattern*.  Vid varje anrop får funktionen ett "
":ref:`match-objekt <match-objects>`\\-argument för matchningen och kan "
"använda denna information för att beräkna den önskade ersättningssträngen "
"och returnera den."

#: ../../howto/regex.rst:1212
msgid ""
"In the following example, the replacement function translates decimals into "
"hexadecimal::"
msgstr ""
"I följande exempel översätter ersättningsfunktionen decimaler till "
"hexadecimal::"

#: ../../howto/regex.rst:1224
msgid ""
"When using the module-level :func:`re.sub` function, the pattern is passed "
"as the first argument.  The pattern may be provided as an object or as a "
"string; if you need to specify regular expression flags, you must either use"
" a pattern object as the first parameter, or use embedded modifiers in the "
"pattern string, e.g. ``sub(\"(?i)b+\", \"x\", \"bbbb BBBB\")`` returns ``'x "
"x'``."
msgstr ""
"När funktionen :func:`re.sub` används på modulnivå skickas mönstret som det "
"första argumentet.  Mönstret kan anges som ett objekt eller som en sträng; "
"om du behöver ange flaggor för reguljära uttryck måste du antingen använda "
"ett mönsterobjekt som första parameter eller använda inbäddade modifierare i"
" mönstersträngen, t.ex. ``sub(\"(?i)b+\", \"x\", \"bbbb BBBB\")`` returnerar"
" ``'x x'``."

#: ../../howto/regex.rst:1232
msgid "Common Problems"
msgstr "Vanliga problem"

#: ../../howto/regex.rst:1234
msgid ""
"Regular expressions are a powerful tool for some applications, but in some "
"ways their behaviour isn't intuitive and at times they don't behave the way "
"you may expect them to.  This section will point out some of the most common"
" pitfalls."
msgstr ""
"Reguljära uttryck är ett kraftfullt verktyg för vissa tillämpningar, men på "
"vissa sätt är deras beteende inte intuitivt och ibland beter de sig inte på "
"det sätt som du kanske förväntar dig att de ska göra.  I det här avsnittet "
"pekar vi på några av de vanligaste fallgroparna."

#: ../../howto/regex.rst:1240
msgid "Use String Methods"
msgstr "Använda strängmetoder"

#: ../../howto/regex.rst:1242
msgid ""
"Sometimes using the :mod:`re` module is a mistake.  If you're matching a "
"fixed string, or a single character class, and you're not using any "
":mod:`re` features such as the :const:`~re.IGNORECASE` flag, then the full "
"power of regular expressions may not be required. Strings have several "
"methods for performing operations with fixed strings and they're usually "
"much faster, because the implementation is a single small C loop that's been"
" optimized for the purpose, instead of the large, more generalized regular "
"expression engine."
msgstr ""
"Ibland är det ett misstag att använda modulen :mod:`re`.  Om du matchar en "
"fast sträng, eller en klass med ett enda tecken, och inte använder några "
":mod:`re`\\-funktioner som t.ex. flaggan :const:`~re.IGNORECASE`, kanske du "
"inte behöver använda reguljära uttryck fullt ut. Strings har flera metoder "
"för att utföra operationer med fasta strängar och de är vanligtvis mycket "
"snabbare, eftersom implementeringen är en enda liten C-loop som har "
"optimerats för ändamålet, istället för den stora, mer generaliserade "
"reguljära uttrycksmotorn."

#: ../../howto/regex.rst:1250
msgid ""
"One example might be replacing a single fixed string with another one; for "
"example, you might replace ``word`` with ``deed``.  :func:`re.sub` seems "
"like the function to use for this, but consider the :meth:`~str.replace` "
"method.  Note that :meth:`!replace` will also replace ``word`` inside words,"
" turning ``swordfish`` into ``sdeedfish``, but the  naive RE ``word`` would "
"have done that, too.  (To avoid performing the substitution on parts of "
"words, the pattern would have to be ``\\bword\\b``, in order to require that"
" ``word`` have a word boundary on either side.  This takes the job beyond  "
":meth:`!replace`'s abilities.)"
msgstr ""
"Ett exempel kan vara att ersätta en enda fast sträng med en annan; till "
"exempel kan du ersätta ``word`` med ``deed``. :func:`re.sub` verkar vara den"
" funktion som ska användas för detta, men överväg "
":meth:`~str.replace`\\-metoden.  Observera att :meth:`!replace` också kommer"
" att ersätta ``word`` inuti ord, vilket gör ``wordfish`` till ``deedfish``, "
"men den naiva RE ``word`` skulle ha gjort det också.  (För att undvika att "
"utföra substitutionen på delar av ord, skulle mönstret behöva vara "
"``bword\\b``, för att kräva att ``word`` har en ordgräns på vardera sidan.  "
"Detta tar jobbet bortom :meth:`!replace` förmågor)"

#: ../../howto/regex.rst:1259
msgid ""
"Another common task is deleting every occurrence of a single character from "
"a string or replacing it with another single character.  You might do this "
"with something like ``re.sub('\\n', ' ', S)``, but :meth:`~str.translate` is"
" capable of doing both tasks and will be faster than any regular expression "
"operation can be."
msgstr ""
"En annan vanlig uppgift är att ta bort varje förekomst av ett enda tecken "
"från en sträng eller ersätta det med ett annat enda tecken.  Du kan göra "
"detta med något som ``re.sub('\\n', ' ', S)``, men :meth:`~str.translate` "
"kan göra båda uppgifterna och kommer att vara snabbare än någon operation "
"med reguljära uttryck kan vara."

#: ../../howto/regex.rst:1265
msgid ""
"In short, before turning to the :mod:`re` module, consider whether your "
"problem can be solved with a faster and simpler string method."
msgstr ""
"Kort sagt, innan du vänder dig till :mod:`re`\\-modulen bör du överväga om "
"ditt problem kan lösas med en snabbare och enklare strängmetod."

#: ../../howto/regex.rst:1270
msgid "match() versus search()"
msgstr "match() kontra search()"

#: ../../howto/regex.rst:1272
msgid ""
"The :func:`~re.match` function only checks if the RE matches at the "
"beginning of the string while :func:`~re.search` will scan forward through "
"the string for a match. It's important to keep this distinction in mind.  "
"Remember,  :func:`!match` will only report a successful match which will "
"start at 0; if the match wouldn't start at zero,  :func:`!match` will *not* "
"report it. ::"
msgstr ""
"Funktionen :func:`~re.match` kontrollerar bara om RE matchar i början av "
"strängen medan :func:`~re.search` söker framåt genom strängen efter en "
"matchning. Det är viktigt att hålla denna distinktion i minnet.  Kom ihåg "
"att :func:`!match` endast kommer att rapportera en lyckad matchning som "
"börjar på 0; om matchningen inte skulle börja på noll kommer :func:`!match` "
"*inte* att rapportera den. ::"

#: ../../howto/regex.rst:1283
msgid ""
"On the other hand, :func:`~re.search` will scan forward through the string, "
"reporting the first match it finds. ::"
msgstr ""
"Å andra sidan kommer :func:`~re.search` att skanna framåt genom strängen och"
" rapportera den första matchningen den hittar. ::"

#: ../../howto/regex.rst:1291
msgid ""
"Sometimes you'll be tempted to keep using :func:`re.match`, and just add "
"``.*`` to the front of your RE.  Resist this temptation and use "
":func:`re.search` instead.  The regular expression compiler does some "
"analysis of REs in order to speed up the process of looking for a match.  "
"One such analysis figures out what the first character of a match must be; "
"for example, a pattern starting with ``Crow`` must match starting with a "
"``'C'``.  The analysis lets the engine quickly scan through the string "
"looking for the starting character, only trying the full match if a ``'C'`` "
"is found."
msgstr ""
"Ibland frestas du att fortsätta använda :func:`re.match`, och bara lägga "
"till ``.*`` framför din RE.  Motstå denna frestelse och använd "
":func:`re.search` istället.  Kompilatorn för reguljära uttryck gör en del "
"analyser av RE:er för att snabba upp processen med att leta efter en "
"matchning.  En sådan analys räknar ut vad det första tecknet i en matchning "
"måste vara; till exempel måste ett mönster som börjar med ``Crow`` matcha "
"som börjar med en ``'C'``.  Analysen gör att sökmotorn snabbt kan skanna "
"igenom strängen och leta efter starttecknet, och bara försöka få en "
"fullständig matchning om ett ``'C`` hittas."

#: ../../howto/regex.rst:1300
msgid ""
"Adding ``.*`` defeats this optimization, requiring scanning to the end of "
"the string and then backtracking to find a match for the rest of the RE.  "
"Use :func:`re.search` instead."
msgstr ""
"Att lägga till ``.*`` motverkar denna optimering och kräver att man skannar "
"till slutet av strängen och sedan går tillbaka för att hitta en matchning "
"för resten av RE.  Använd :func:`re.search` istället."

#: ../../howto/regex.rst:1306
msgid "Greedy versus Non-Greedy"
msgstr "Girig kontra icke-girig"

#: ../../howto/regex.rst:1308
msgid ""
"When repeating a regular expression, as in ``a*``, the resulting action is "
"to consume as much of the pattern as possible.  This fact often bites you "
"when you're trying to match a pair of balanced delimiters, such as the angle"
" brackets surrounding an HTML tag.  The naive pattern for matching a single "
"HTML tag doesn't work because of the greedy nature of ``.*``. ::"
msgstr ""
"När man upprepar ett reguljärt uttryck, som i ``a*``, blir resultatet att så"
" mycket som möjligt av mönstret konsumeras.  Detta faktum slår ofta fel när "
"man försöker matcha ett par balanserade avgränsare, t.ex. de "
"vinkelparenteser som omger en HTML-tagg.  Det naiva mönstret för att matcha "
"en enda HTML-tagg fungerar inte på grund av den giriga karaktären hos "
"``.*``. ::"

#: ../../howto/regex.rst:1322
msgid ""
"The RE matches the ``'<'`` in ``'<html>'``, and the ``.*`` consumes the rest"
" of the string.  There's still more left in the RE, though, and the ``>`` "
"can't match at the end of the string, so the regular expression engine has "
"to backtrack character by character until it finds a match for the ``>``.   "
"The final match extends from the ``'<'`` in ``'<html>'`` to the ``'>'`` in "
"``'</title>'``, which isn't what you want."
msgstr ""
"RE matchar ``'<'`` i ``'<html>'``, och ``.*`` förbrukar resten av strängen."
"  Det finns dock fortfarande mer kvar i RE, och ``>`` kan inte matcha i "
"slutet av strängen, så motorn för reguljära uttryck måste backa tecken för "
"tecken tills den hittar en matchning för ``>``.   Den slutliga matchningen "
"sträcker sig från ``'<'`` i ``'<html>'`` till ``'>'`` i ``'</title>'``, "
"vilket inte är vad du vill."

#: ../../howto/regex.rst:1329
msgid ""
"In this case, the solution is to use the non-greedy qualifiers ``*?``, "
"``+?``, ``??``, or ``{m,n}?``, which match as *little* text as possible.  In"
" the above example, the ``'>'`` is tried immediately after the first ``'<'``"
" matches, and when it fails, the engine advances a character at a time, "
"retrying the ``'>'`` at every step.  This produces just the right result::"
msgstr ""

#: ../../howto/regex.rst:1338
msgid ""
"(Note that parsing HTML or XML with regular expressions is painful. Quick-"
"and-dirty patterns will handle common cases, but HTML and XML have special "
"cases that will break the obvious regular expression; by the time you've "
"written a regular expression that handles all of the possible cases, the "
"patterns will be *very* complicated.  Use an HTML or XML parser module for "
"such tasks.)"
msgstr ""
"(Observera att parsning av HTML eller XML med reguljära uttryck är "
"smärtsamt. Snabba och enkla mönster hanterar vanliga fall, men HTML och XML "
"har specialfall som bryter mot det uppenbara reguljära uttrycket; när du väl"
" har skrivit ett reguljärt uttryck som hanterar alla möjliga fall kommer "
"mönstren att vara *mycket* komplicerade.  Använd en HTML- eller XML-"
"parsermodul för sådana uppgifter)"

#: ../../howto/regex.rst:1346
msgid "Using re.VERBOSE"
msgstr "Använda re.VERBOSE"

#: ../../howto/regex.rst:1348
msgid ""
"By now you've probably noticed that regular expressions are a very compact "
"notation, but they're not terribly readable.  REs of moderate complexity can"
" become lengthy collections of backslashes, parentheses, and metacharacters,"
" making them difficult to read and understand."
msgstr ""
"Vid det här laget har du förmodligen märkt att reguljära uttryck är en "
"mycket kompakt notation, men de är inte särskilt läsbara.  RE med måttlig "
"komplexitet kan bli långa samlingar av bindestreck, parenteser och "
"metatecken, vilket gör dem svåra att läsa och förstå."

#: ../../howto/regex.rst:1353
msgid ""
"For such REs, specifying the :const:`re.VERBOSE` flag when compiling the "
"regular expression can be helpful, because it allows you to format the "
"regular expression more clearly."
msgstr ""
"För sådana RE:s kan det vara till hjälp att ange flaggan :const:`re.VERBOSE`"
" vid kompilering av det reguljära uttrycket, eftersom det gör att du kan "
"formatera det reguljära uttrycket tydligare."

#: ../../howto/regex.rst:1357
msgid ""
"The ``re.VERBOSE`` flag has several effects.  Whitespace in the regular "
"expression that *isn't* inside a character class is ignored.  This means "
"that an expression such as ``dog | cat`` is equivalent to the less readable "
"``dog|cat``, but ``[a b]`` will still match the characters ``'a'``, ``'b'``,"
" or a space.  In addition, you can also put comments inside a RE; comments "
"extend from a ``#`` character to the next newline.  When used with triple-"
"quoted strings, this enables REs to be formatted more neatly::"
msgstr ""
"Flaggan ``re.VERBOSE`` har flera effekter.  Whitespace i det reguljära "
"uttrycket som *inte* är inom en teckenklass ignoreras.  Detta innebär att "
"ett uttryck som ``dog | cat`` motsvarar det mindre läsbara ``dog|cat``, men "
"``[a b]`` kommer fortfarande att matcha tecknen ``'a'``, ``'b'`` eller ett "
"mellanslag.  Dessutom kan du lägga in kommentarer inuti en RE; kommentarer "
"sträcker sig från ett ``#``\\-tecken till nästa nya rad.  När detta används "
"med strängar med trippelcitat kan RE:er formateras på ett snyggare sätt::"

#: ../../howto/regex.rst:1374
msgid "This is far more readable than::"
msgstr "Detta är mycket mer läsbart än::"

#: ../../howto/regex.rst:1380
msgid "Feedback"
msgstr "Feedback"

#: ../../howto/regex.rst:1382
msgid ""
"Regular expressions are a complicated topic.  Did this document help you "
"understand them?  Were there parts that were unclear, or Problems you "
"encountered that weren't covered here?  If so, please send suggestions for "
"improvements to the author."
msgstr ""
"Reguljära uttryck är ett komplicerat ämne.  Hjälpte det här dokumentet dig "
"att förstå dem?  Fanns det delar som var oklara, eller problem som du stötte"
" på som inte täcktes här?  Om så är fallet, skicka gärna förslag på "
"förbättringar till författaren."

#: ../../howto/regex.rst:1387
msgid ""
"The most complete book on regular expressions is almost certainly Jeffrey "
"Friedl's Mastering Regular Expressions, published by O'Reilly.  "
"Unfortunately, it exclusively concentrates on Perl and Java's flavours of "
"regular expressions, and doesn't contain any Python material at all, so it "
"won't be useful as a reference for programming in Python.  (The first "
"edition covered Python's now-removed :mod:`!regex` module, which won't help "
"you much.)  Consider checking it out from your library."
msgstr ""
"Den mest kompletta boken om reguljära uttryck är nästan säkert Jeffrey "
"Friedls Mastering Regular Expressions, utgiven av O'Reilly.  Tyvärr "
"koncentrerar den sig uteslutande på Perl och Javas smaker av reguljära "
"uttryck och innehåller inte något Python-material alls, så det kommer inte "
"att vara användbart som referens för programmering i Python.  (Den första "
"utgåvan täckte Pythons nu borttagna :mod:`!regex`\\-modul, vilket inte "
"kommer att hjälpa dig mycket.)  Överväg att kolla in det från ditt "
"bibliotek."
