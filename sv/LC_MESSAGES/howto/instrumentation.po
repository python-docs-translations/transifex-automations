# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-15 16:36+0000\n"
"PO-Revision-Date: 2025-09-22 16:49+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../howto/instrumentation.rst:7
msgid "Instrumenting CPython with DTrace and SystemTap"
msgstr "Instrumentering av CPython med DTrace och SystemTap"

#: ../../howto/instrumentation.rst:0
msgid "author"
msgstr "författare"

#: ../../howto/instrumentation.rst:9
msgid "David Malcolm"
msgstr "David Malcolm"

#: ../../howto/instrumentation.rst:10
msgid "Łukasz Langa"
msgstr "Łukasz Langa"

#: ../../howto/instrumentation.rst:12
msgid ""
"DTrace and SystemTap are monitoring tools, each providing a way to inspect "
"what the processes on a computer system are doing.  They both use domain-"
"specific languages allowing a user to write scripts which:"
msgstr ""
"DTrace och SystemTap är övervakningsverktyg som var och en ger möjlighet att "
"inspektera vad processerna i ett datorsystem gör.  De använder båda "
"domänspecifika språk som gör det möjligt för en användare att skriva skript "
"som:"

#: ../../howto/instrumentation.rst:16
msgid "filter which processes are to be observed"
msgstr "filtrera vilka processer som ska följas"

#: ../../howto/instrumentation.rst:17
msgid "gather data from the processes of interest"
msgstr "samla in data från de processer som är av intresse"

#: ../../howto/instrumentation.rst:18
msgid "generate reports on the data"
msgstr "generera rapporter om data"

#: ../../howto/instrumentation.rst:20
msgid ""
"As of Python 3.6, CPython can be built with embedded \"markers\", also known "
"as \"probes\", that can be observed by a DTrace or SystemTap script, making "
"it easier to monitor what the CPython processes on a system are doing."
msgstr ""
"Från och med Python 3.6 kan CPython byggas med inbäddade \"markörer\", även "
"kända som \"prober\", som kan observeras av ett DTrace- eller SystemTap-"
"skript, vilket gör det lättare att övervaka vad CPython-processerna på ett "
"system gör."

#: ../../howto/instrumentation.rst:27
msgid ""
"DTrace markers are implementation details of the CPython interpreter. No "
"guarantees are made about probe compatibility between versions of CPython. "
"DTrace scripts can stop working or work incorrectly without warning when "
"changing CPython versions."
msgstr ""
"DTrace-markörer är implementeringsdetaljer i CPython-tolken. Inga garantier "
"ges om kompatibilitet mellan olika versioner av CPython. DTrace-skript kan "
"sluta fungera eller fungera felaktigt utan förvarning när CPython-versioner "
"ändras."

#: ../../howto/instrumentation.rst:34
msgid "Enabling the static markers"
msgstr "Aktivering av statiska markörer"

#: ../../howto/instrumentation.rst:36
msgid ""
"macOS comes with built-in support for DTrace.  On Linux, in order to build "
"CPython with the embedded markers for SystemTap, the SystemTap development "
"tools must be installed."
msgstr ""
"macOS kommer med inbyggt stöd för DTrace.  På Linux måste SystemTap-"
"utvecklingsverktygen installeras för att CPython ska kunna byggas med de "
"inbäddade markörerna för SystemTap."

#: ../../howto/instrumentation.rst:40
msgid "On a Linux machine, this can be done via::"
msgstr "På en Linux-maskin kan detta göras via::"

#: ../../howto/instrumentation.rst:44
msgid "or::"
msgstr "eller::"

#: ../../howto/instrumentation.rst:49
msgid ""
"CPython must then be :option:`configured with the --with-dtrace option <--"
"with-dtrace>`:"
msgstr ""
"CPython måste då :option:`konfigureras med alternativet --with-dtrace <--"
"with-dtrace>`:"

#: ../../howto/instrumentation.rst:56
msgid ""
"On macOS, you can list available DTrace probes by running a Python process "
"in the background and listing all probes made available by the Python "
"provider::"
msgstr ""
"På macOS kan du lista tillgängliga DTrace-prober genom att köra en Python-"
"process i bakgrunden och lista alla prober som görs tillgängliga av Python-"
"providern::"

#: ../../howto/instrumentation.rst:73
msgid ""
"On Linux, you can verify if the SystemTap static markers are present in the "
"built binary by seeing if it contains a \".note.stapsdt\" section."
msgstr ""
"På Linux kan du kontrollera om de statiska SystemTap-markörerna finns i den "
"inbyggda binärfilen genom att se om den innehåller ett avsnitt \".note."
"stapsdt\"."

#: ../../howto/instrumentation.rst:81
msgid ""
"If you've built Python as a shared library (with the :option:`--enable-"
"shared` configure option), you need to look instead within the shared "
"library.  For example::"
msgstr ""
"Om du har byggt Python som ett delat bibliotek (med "
"konfigurationsalternativet :option:`\\--enable-shared`) måste du istället "
"leta inom det delade biblioteket.  Till exempel::"

#: ../../howto/instrumentation.rst:88
msgid "Sufficiently modern readelf can print the metadata::"
msgstr "Tillräckligt modern readelf kan skriva ut metadata::"

#: ../../howto/instrumentation.rst:125
msgid ""
"The above metadata contains information for SystemTap describing how it can "
"patch strategically placed machine code instructions to enable the tracing "
"hooks used by a SystemTap script."
msgstr ""
"Ovanstående metadata innehåller information för SystemTap som beskriver hur "
"det kan patcha strategiskt placerade maskinkodinstruktioner för att aktivera "
"de spårningskrokar som används av ett SystemTap-skript."

#: ../../howto/instrumentation.rst:131
msgid "Static DTrace probes"
msgstr "Statiska DTrace-prober"

#: ../../howto/instrumentation.rst:133
msgid ""
"The following example DTrace script can be used to show the call/return "
"hierarchy of a Python script, only tracing within the invocation of a "
"function called \"start\". In other words, import-time function invocations "
"are not going to be listed:"
msgstr ""
"Följande exempel på DTrace-skript kan användas för att visa anrops-/"
"returhierarkin i ett Python-skript, med spårning endast inom anropet av en "
"funktion som heter \"start\". Med andra ord kommer inte anrop av "
"importfunktioner att listas:"

#: ../../howto/instrumentation.rst:172 ../../howto/instrumentation.rst:230
msgid "It can be invoked like this::"
msgstr "Den kan anropas på följande sätt::"

#: ../../howto/instrumentation.rst:176 ../../howto/instrumentation.rst:236
msgid "The output looks like this:"
msgstr "Utmatningen ser ut så här:"

#: ../../howto/instrumentation.rst:201
msgid "Static SystemTap markers"
msgstr "Statiskt systemTap-markörer"

#: ../../howto/instrumentation.rst:203
msgid ""
"The low-level way to use the SystemTap integration is to use the static "
"markers directly.  This requires you to explicitly state the binary file "
"containing them."
msgstr ""
"Lågnivåmetoden för att använda SystemTap-integrationen är att använda de "
"statiska markörerna direkt.  Detta kräver att du uttryckligen anger den "
"binära fil som innehåller dem."

#: ../../howto/instrumentation.rst:207
msgid ""
"For example, this SystemTap script can be used to show the call/return "
"hierarchy of a Python script:"
msgstr ""
"Detta SystemTap-skript kan t.ex. användas för att visa Call/Return-hierarkin "
"i ett Python-skript:"

#: ../../howto/instrumentation.rst:247
msgid "where the columns are:"
msgstr "där kolumnerna är:"

#: ../../howto/instrumentation.rst:249
msgid "time in microseconds since start of script"
msgstr "tid i mikrosekunder sedan skriptets start"

#: ../../howto/instrumentation.rst:250
msgid "name of executable"
msgstr "namn på körbar fil"

#: ../../howto/instrumentation.rst:251
msgid "PID of process"
msgstr "PID för process"

#: ../../howto/instrumentation.rst:253
msgid ""
"and the remainder indicates the call/return hierarchy as the script executes."
msgstr "och resten visar hierarkin för anrop/retur när skriptet körs."

#: ../../howto/instrumentation.rst:255
msgid ""
"For a :option:`--enable-shared` build of CPython, the markers are contained "
"within the libpython shared library, and the probe's dotted path needs to "
"reflect this. For example, this line from the above example:"
msgstr ""
"För en :option:`\\--enable-shared`\\-byggnad av CPython finns markörerna i "
"det delade biblioteket libpython, och probens prickade sökväg måste "
"återspegla detta. Till exempel den här raden från exemplet ovan:"

#: ../../howto/instrumentation.rst:263
msgid "should instead read:"
msgstr "bör istället lyda:"

#: ../../howto/instrumentation.rst:269
msgid "(assuming a :ref:`debug build <debug-build>` of CPython 3.6)"
msgstr "(antar en :ref:`debug build <debug-build>` av CPython 3.6)"

#: ../../howto/instrumentation.rst:273
msgid "Available static markers"
msgstr "Tillgängliga statiska markörer"

#: ../../howto/instrumentation.rst:277
msgid ""
"This marker indicates that execution of a Python function has begun. It is "
"only triggered for pure-Python (bytecode) functions."
msgstr ""
"Denna markör anger att exekveringen av en Python-funktion har påbörjats. Den "
"utlöses endast för rena Python-funktioner (bytecode)."

#: ../../howto/instrumentation.rst:280
msgid ""
"The filename, function name, and line number are provided back to the "
"tracing script as positional arguments, which must be accessed using "
"``$arg1``, ``$arg2``, ``$arg3``:"
msgstr ""
"Filnamnet, funktionsnamnet och radnumret skickas tillbaka till "
"spårningsskriptet som positionella argument, som måste nås med hjälp av "
"``$arg1``, ``$arg2``, ``$arg3``:"

#: ../../howto/instrumentation.rst:284
msgid ""
"``$arg1`` : ``(const char *)`` filename, accessible using "
"``user_string($arg1)``"
msgstr ""
"``$arg1`` : ``(const char *)`` filnamn, tillgängligt med "
"``user_string($arg1)``"

#: ../../howto/instrumentation.rst:286
msgid ""
"``$arg2`` : ``(const char *)`` function name, accessible using "
"``user_string($arg2)``"
msgstr ""
"``$arg2`` : ``(const char *)`` funktionsnamn, tillgängligt med "
"``user_string($arg2)``"

#: ../../howto/instrumentation.rst:289
msgid "``$arg3`` : ``int`` line number"
msgstr "``$arg3`` : ``int`` radnummer"

#: ../../howto/instrumentation.rst:293
msgid ""
"This marker is the converse of :c:func:`!function__entry`, and indicates "
"that execution of a Python function has ended (either via ``return``, or via "
"an exception).  It is only triggered for pure-Python (bytecode) functions."
msgstr ""
"Denna markör är motsatsen till :c:func:`!function__entry` och anger att "
"exekveringen av en Python-funktion har avslutats (antingen via ``return`` "
"eller via ett undantag).  Den utlöses endast för rena Python-funktioner "
"(bytecode)."

#: ../../howto/instrumentation.rst:297
msgid "The arguments are the same as for :c:func:`!function__entry`"
msgstr "Argumenten är desamma som för :c:func:`!function__entry`"

#: ../../howto/instrumentation.rst:301
msgid ""
"This marker indicates a Python line is about to be executed.  It is the "
"equivalent of line-by-line tracing with a Python profiler.  It is not "
"triggered within C functions."
msgstr ""
"Denna markör indikerar att en Python-rad är på väg att exekveras.  Det "
"motsvarar spårning rad för rad med en Python-profilerare.  Den utlöses inte "
"inom C-funktioner."

#: ../../howto/instrumentation.rst:305
msgid "The arguments are the same as for :c:func:`!function__entry`."
msgstr "Argumenten är desamma som för :c:func:`!function__entry`."

#: ../../howto/instrumentation.rst:309
msgid ""
"Fires when the Python interpreter starts a garbage collection cycle. "
"``arg0`` is the generation to scan, like :func:`gc.collect()`."
msgstr ""

#: ../../howto/instrumentation.rst:314
msgid ""
"Fires when the Python interpreter finishes a garbage collection cycle. "
"``arg0`` is the number of collected objects."
msgstr ""
"Utlöses när Python-tolken avslutar en garbage collection-cykel. ``arg0`` är "
"antalet insamlade objekt."

#: ../../howto/instrumentation.rst:319
msgid ""
"Fires before :mod:`importlib` attempts to find and load the module. ``arg0`` "
"is the module name."
msgstr ""
"Startas innan :mod:`importlib` försöker hitta och ladda modulen. ``arg0`` är "
"modulens namn."

#: ../../howto/instrumentation.rst:326
msgid ""
"Fires after :mod:`importlib`'s find_and_load function is called. ``arg0`` is "
"the module name, ``arg1`` indicates if module was successfully loaded."
msgstr ""
"Startas efter att :mod:`importlib`'s find_and_load-funktion har anropats. "
"``arg0`` är modulnamnet, ``arg1`` indikerar om modulen laddades "
"framgångsrikt."

#: ../../howto/instrumentation.rst:335
msgid ""
"Fires when :func:`sys.audit` or :c:func:`PySys_Audit` is called. ``arg0`` is "
"the event name as C string, ``arg1`` is a :c:type:`PyObject` pointer to a "
"tuple object."
msgstr ""
"Startar när :func:`sys.audit` eller :c:func:`PySys_Audit` anropas. ``arg0`` "
"är händelsens namn som C-sträng, ``arg1`` är en :c:type:`PyObject`\\-pekare "
"till ett tuple-objekt."

#: ../../howto/instrumentation.rst:343
msgid "SystemTap Tapsets"
msgstr "SystemTap Kranar"

#: ../../howto/instrumentation.rst:345
msgid ""
"The higher-level way to use the SystemTap integration is to use a "
"\"tapset\": SystemTap's equivalent of a library, which hides some of the "
"lower-level details of the static markers."
msgstr ""
"Det mer avancerade sättet att använda SystemTap-integrationen är att använda "
"ett \"tapset\": SystemTaps motsvarighet till ett bibliotek, som döljer några "
"av de statiska markörernas detaljer på lägre nivå."

#: ../../howto/instrumentation.rst:349
msgid "Here is a tapset file, based on a non-shared build of CPython:"
msgstr "Här är en tapset-fil, baserad på en icke-delad version av CPython:"

#: ../../howto/instrumentation.rst:372
msgid ""
"If this file is installed in SystemTap's tapset directory (e.g. ``/usr/share/"
"systemtap/tapset``), then these additional probepoints become available:"
msgstr ""
"Om den här filen installeras i SystemTaps tapset-katalog (t.ex. ``/usr/share/"
"systemtap/tapset``) blir dessa ytterligare probepoints tillgängliga:"

#: ../../howto/instrumentation.rst:378
msgid ""
"This probe point indicates that execution of a Python function has begun. It "
"is only triggered for pure-Python (bytecode) functions."
msgstr ""
"Denna probepunkt indikerar att exekveringen av en Python-funktion har "
"påbörjats. Den utlöses endast för rena Python-funktioner (bytecode)."

#: ../../howto/instrumentation.rst:383
msgid ""
"This probe point is the converse of ``python.function.return``, and "
"indicates that execution of a Python function has ended (either via "
"``return``, or via an exception).  It is only triggered for pure-Python "
"(bytecode) functions."
msgstr ""
"Denna probepunkt är motsatsen till ``python.function.return`` och anger att "
"exekveringen av en Python-funktion har avslutats (antingen via ``return`` "
"eller via ett undantag).  Den utlöses endast för rena Python-funktioner "
"(bytecode)."

#: ../../howto/instrumentation.rst:390
msgid "Examples"
msgstr "Exempel"

#: ../../howto/instrumentation.rst:391
msgid ""
"This SystemTap script uses the tapset above to more cleanly implement the "
"example given above of tracing the Python function-call hierarchy, without "
"needing to directly name the static markers:"
msgstr ""
"Detta SystemTap-skript använder tapset ovan för att på ett renare sätt "
"implementera exemplet ovan med spårning av Pythons funktionsanropshierarki, "
"utan att direkt behöva namnge de statiska markörerna:"

#: ../../howto/instrumentation.rst:410
msgid ""
"The following script uses the tapset above to provide a top-like view of all "
"running CPython code, showing the top 20 most frequently entered bytecode "
"frames, each second, across the whole system:"
msgstr ""
"Följande skript använder tapset ovan för att ge en toppliknande vy över all "
"CPython-kod som körs och visar de 20 mest frekvent inmatade bytekodsramarna "
"varje sekund i hela systemet:"
