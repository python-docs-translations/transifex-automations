# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-16 17:23+0000\n"
"PO-Revision-Date: 2025-09-16 00:01+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../library/statistics.rst:2
msgid ":mod:`!statistics` --- Mathematical statistics functions"
msgstr ":mod:`!statistics` --- Matematiska statistikfunktioner"

#: ../../library/statistics.rst:12
msgid "**Source code:** :source:`Lib/statistics.py`"
msgstr "**Källkod:** :source:`Lib/statistics.py`"

#: ../../library/statistics.rst:22
msgid ""
"This module provides functions for calculating mathematical statistics of "
"numeric (:class:`~numbers.Real`-valued) data."
msgstr ""
"Denna modul innehåller funktioner för att beräkna matematisk statistik för "
"numeriska (:class:`~numbers.Real`\\-värderade) data."

#: ../../library/statistics.rst:25
msgid ""
"The module is not intended to be a competitor to third-party libraries such "
"as `NumPy <https://numpy.org>`_, `SciPy <https://scipy.org/>`_, or "
"proprietary full-featured statistics packages aimed at professional "
"statisticians such as Minitab, SAS and Matlab. It is aimed at the level of "
"graphing and scientific calculators."
msgstr ""
"Modulen är inte avsedd att vara en konkurrent till tredjepartsbibliotek som "
"`NumPy <https://numpy.org>`_, `SciPy <https://scipy.org/>`_, eller "
"egenutvecklade statistikpaket med fullständiga funktioner som riktar sig "
"till professionella statistiker som Minitab, SAS och Matlab. Programmet är "
"anpassat för grafräknare och vetenskapliga räknare."

#: ../../library/statistics.rst:31
msgid ""
"Unless explicitly noted, these functions "
"support :class:`int`, :class:`float`, :class:`~decimal.Decimal` "
"and :class:`~fractions.Fraction`. Behaviour with other types (whether in the "
"numeric tower or not) is currently unsupported.  Collections with a mix of "
"types are also undefined and implementation-dependent.  If your input data "
"consists of mixed types, you may be able to use :func:`map` to ensure a "
"consistent result, for example: ``map(float, input_data)``."
msgstr ""
"Om inte annat uttryckligen anges, stöder dessa "
"funktioner :class:`int`, :class:`float`, :class:`~decimal.Decimal` "
"och :class:`~fractions.Fraction`. Beteende med andra typer (oavsett om de "
"finns i det numeriska tornet eller inte) stöds för närvarande inte.  "
"Samlingar med en blandning av typer är också odefinierade och beroende av "
"implementering.  Om dina indata består av blandade typer kan du kanske "
"använda :func:`map` för att säkerställa ett konsekvent resultat, till "
"exempel: ``map(float, input_data)``."

#: ../../library/statistics.rst:39
msgid ""
"Some datasets use ``NaN`` (not a number) values to represent missing data. "
"Since NaNs have unusual comparison semantics, they cause surprising or "
"undefined behaviors in the statistics functions that sort data or that count "
"occurrences.  The functions affected are ``median()``, ``median_low()``, "
"``median_high()``, ``median_grouped()``, ``mode()``, ``multimode()``, and "
"``quantiles()``.  The ``NaN`` values should be stripped before calling these "
"functions::"
msgstr ""
"I vissa dataset används NaN-värden (not a number) för att representera "
"saknade data. Eftersom NaN-värden har en ovanlig jämförelsesemantik orsakar "
"de överraskande eller odefinierade beteenden i statistikfunktioner som "
"sorterar data eller räknar förekomster.  De funktioner som påverkas är "
"``median()``, ``median_low()``, ``median_high()``, ``median_grouped()``, "
"``mode()``, ``multimode()`` och ``quantiles()``.  ``NaN``\\-värdena bör tas "
"bort innan du anropar dessa funktioner::"

#: ../../library/statistics.rst:47
msgid ""
">>> from statistics import median\n"
">>> from math import isnan\n"
">>> from itertools import filterfalse\n"
"\n"
">>> data = [20.7, float('NaN'),19.2, 18.3, float('NaN'), 14.4]\n"
">>> sorted(data)  # This has surprising behavior\n"
"[20.7, nan, 14.4, 18.3, 19.2, nan]\n"
">>> median(data)  # This result is unexpected\n"
"16.35\n"
"\n"
">>> sum(map(isnan, data))    # Number of missing values\n"
"2\n"
">>> clean = list(filterfalse(isnan, data))  # Strip NaN values\n"
">>> clean\n"
"[20.7, 19.2, 18.3, 14.4]\n"
">>> sorted(clean)  # Sorting now works as expected\n"
"[14.4, 18.3, 19.2, 20.7]\n"
">>> median(clean)       # This result is now well defined\n"
"18.75"
msgstr ""
">>> from statistics import median\n"
">>> from math import isnan\n"
">>> from itertools import filterfalse\n"
"\n"
">>> data = [20.7, float('NaN'),19.2, 18.3, float('NaN'), 14.4]\n"
">>> sorted(data)  # This has surprising behavior\n"
"[20.7, nan, 14.4, 18.3, 19.2, nan]\n"
">>> median(data)  # This result is unexpected\n"
"16.35\n"
"\n"
">>> sum(map(isnan, data))    # Number of missing values\n"
"2\n"
">>> clean = list(filterfalse(isnan, data))  # Strip NaN values\n"
">>> clean\n"
"[20.7, 19.2, 18.3, 14.4]\n"
">>> sorted(clean)  # Sorting now works as expected\n"
"[14.4, 18.3, 19.2, 20.7]\n"
">>> median(clean)       # This result is now well defined\n"
"18.75"

#: ../../library/statistics.rst:69
msgid "Averages and measures of central location"
msgstr "Medelvärden och mått på centralt läge"

#: ../../library/statistics.rst:71
msgid ""
"These functions calculate an average or typical value from a population or "
"sample."
msgstr ""
"Dessa funktioner beräknar ett genomsnittligt eller typiskt värde från en "
"population eller ett urval."

#: ../../library/statistics.rst:75
msgid ":func:`mean`"
msgstr ":func:`medelvärde`"

#: ../../library/statistics.rst:75
msgid "Arithmetic mean (\"average\") of data."
msgstr "Aritmetiskt medelvärde (\"average\") av data."

#: ../../library/statistics.rst:76
msgid ":func:`fmean`"
msgstr ":func:`fmean`"

#: ../../library/statistics.rst:76
msgid "Fast, floating-point arithmetic mean, with optional weighting."
msgstr "Snabbt aritmetiskt medelvärde med flyttal, med valfri viktning."

#: ../../library/statistics.rst:77
msgid ":func:`geometric_mean`"
msgstr ":func:`geometric_mean`"

#: ../../library/statistics.rst:77
msgid "Geometric mean of data."
msgstr "Geometriskt medelvärde av data."

#: ../../library/statistics.rst:78
msgid ":func:`harmonic_mean`"
msgstr ":func:`harmonic_mean`"

#: ../../library/statistics.rst:78
msgid "Harmonic mean of data."
msgstr "Harmoniskt medelvärde av data."

#: ../../library/statistics.rst:79
msgid ":func:`kde`"
msgstr ":func:`kde`"

#: ../../library/statistics.rst:79
msgid "Estimate the probability density distribution of the data."
msgstr "Uppskatta sannolikhetstäthetsfördelningen för data."

#: ../../library/statistics.rst:80
msgid ":func:`kde_random`"
msgstr ":func:`kde_random`"

#: ../../library/statistics.rst:80
msgid "Random sampling from the PDF generated by kde()."
msgstr "Slumpmässigt urval från den PDF som genereras av kde()."

#: ../../library/statistics.rst:81
msgid ":func:`median`"
msgstr ":func:`median`"

#: ../../library/statistics.rst:81
msgid "Median (middle value) of data."
msgstr "Median (medelvärde) av data."

#: ../../library/statistics.rst:82
msgid ":func:`median_low`"
msgstr ":func:`median_low`"

#: ../../library/statistics.rst:82
msgid "Low median of data."
msgstr "Låg median av data."

#: ../../library/statistics.rst:83
msgid ":func:`median_high`"
msgstr ":func:`median_high`"

#: ../../library/statistics.rst:83
msgid "High median of data."
msgstr "Hög median av data."

#: ../../library/statistics.rst:84
msgid ":func:`median_grouped`"
msgstr ":func:`median_grouped`"

#: ../../library/statistics.rst:84
msgid "Median (50th percentile) of grouped data."
msgstr "Median (50:e percentilen) för grupperade data."

#: ../../library/statistics.rst:85
msgid ":func:`mode`"
msgstr ":func:`mode`"

#: ../../library/statistics.rst:85
msgid "Single mode (most common value) of discrete or nominal data."
msgstr "Single mode (vanligaste värdet) av diskreta eller nominella data."

#: ../../library/statistics.rst:86
msgid ":func:`multimode`"
msgstr ":func:`multimode`"

#: ../../library/statistics.rst:86
msgid "List of modes (most common values) of discrete or nominal data."
msgstr ""
"Lista över lägen (de vanligaste värdena) för diskreta eller nominella data."

#: ../../library/statistics.rst:87
msgid ":func:`quantiles`"
msgstr ":func:`quantiles`"

#: ../../library/statistics.rst:87
msgid "Divide data into intervals with equal probability."
msgstr "Dela in data i intervall med lika stor sannolikhet."

#: ../../library/statistics.rst:91
msgid "Measures of spread"
msgstr "Mått på spridning"

#: ../../library/statistics.rst:93
msgid ""
"These functions calculate a measure of how much the population or sample "
"tends to deviate from the typical or average values."
msgstr ""
"Dessa funktioner beräknar ett mått på hur mycket populationen eller urvalet "
"tenderar att avvika från de typiska eller genomsnittliga värdena."

#: ../../library/statistics.rst:97
msgid ":func:`pstdev`"
msgstr ":func:`pstdev`"

#: ../../library/statistics.rst:97
msgid "Population standard deviation of data."
msgstr "Standardavvikelse för data i populationen."

#: ../../library/statistics.rst:98
msgid ":func:`pvariance`"
msgstr ":func:`pvariance`"

#: ../../library/statistics.rst:98
msgid "Population variance of data."
msgstr "Populationsvarians för data."

#: ../../library/statistics.rst:99
msgid ":func:`stdev`"
msgstr ":func:`stdev`"

#: ../../library/statistics.rst:99
msgid "Sample standard deviation of data."
msgstr "Standardavvikelse för data."

#: ../../library/statistics.rst:100
msgid ":func:`variance`"
msgstr ":func:`variance`"

#: ../../library/statistics.rst:100
msgid "Sample variance of data."
msgstr "Provvarians av data."

#: ../../library/statistics.rst:104
msgid "Statistics for relations between two inputs"
msgstr "Statistik för relationer mellan två inmatningar"

#: ../../library/statistics.rst:106
msgid ""
"These functions calculate statistics regarding relations between two inputs."
msgstr ""
"Dessa funktioner beräknar statistik avseende relationer mellan två indata."

#: ../../library/statistics.rst:109
msgid ":func:`covariance`"
msgstr ":func:`covariance`"

#: ../../library/statistics.rst:109
msgid "Sample covariance for two variables."
msgstr "Provkovarians för två variabler."

#: ../../library/statistics.rst:110
msgid ":func:`correlation`"
msgstr ":func:`correlation`"

#: ../../library/statistics.rst:110
msgid "Pearson and Spearman's correlation coefficients."
msgstr "Pearson och Spearmans korrelationskoefficienter."

#: ../../library/statistics.rst:111
msgid ":func:`linear_regression`"
msgstr ":func:`linear_regression`"

#: ../../library/statistics.rst:111
msgid "Slope and intercept for simple linear regression."
msgstr "Lutning och intercept för enkel linjär regression."

#: ../../library/statistics.rst:116
msgid "Function details"
msgstr "Funktionsdetaljer"

#: ../../library/statistics.rst:118
msgid ""
"Note: The functions do not require the data given to them to be sorted. "
"However, for reading convenience, most of the examples show sorted sequences."
msgstr ""
"Observera: Funktionerna kräver inte att de data som ges till dem är "
"sorterade. För att underlätta läsningen visas dock sorterade sekvenser i de "
"flesta exemplen."

#: ../../library/statistics.rst:123
msgid ""
"Return the sample arithmetic mean of *data* which can be a sequence or "
"iterable."
msgstr ""
"Returnerar det aritmetiska medelvärdet för *data* som kan vara en sekvens "
"eller iterabel."

#: ../../library/statistics.rst:125
msgid ""
"The arithmetic mean is the sum of the data divided by the number of data "
"points.  It is commonly called \"the average\", although it is only one of "
"many different mathematical averages.  It is a measure of the central "
"location of the data."
msgstr ""
"Det aritmetiska medelvärdet är summan av data dividerat med antalet "
"datapunkter.  Det kallas ofta för \"genomsnittet\", även om det bara är ett "
"av många olika matematiska genomsnitt.  Det är ett mått på den centrala "
"placeringen av data."

#: ../../library/statistics.rst:130
msgid "If *data* is empty, :exc:`StatisticsError` will be raised."
msgstr "Om *data* är tom, kommer :exc:`StatisticsError` att uppstå."

#: ../../library/statistics.rst:132
msgid "Some examples of use:"
msgstr "Några exempel på användning:"

#: ../../library/statistics.rst:134
msgid ""
">>> mean([1, 2, 3, 4, 4])\n"
"2.8\n"
">>> mean([-1.0, 2.5, 3.25, 5.75])\n"
"2.625\n"
"\n"
">>> from fractions import Fraction as F\n"
">>> mean([F(3, 7), F(1, 21), F(5, 3), F(1, 3)])\n"
"Fraction(13, 21)\n"
"\n"
">>> from decimal import Decimal as D\n"
">>> mean([D(\"0.5\"), D(\"0.75\"), D(\"0.625\"), D(\"0.375\")])\n"
"Decimal('0.5625')"
msgstr ""
">>> mean([1, 2, 3, 4, 4])\n"
"2.8\n"
">>> mean([-1.0, 2.5, 3.25, 5.75])\n"
"2.625\n"
"\n"
">>> from fractions import Fraction as F\n"
">>> mean([F(3, 7), F(1, 21), F(5, 3), F(1, 3)])\n"
"Fraction(13, 21)\n"
"\n"
">>> from decimal import Decimal as D\n"
">>> mean([D(\"0.5\"), D(\"0.75\"), D(\"0.625\"), D(\"0.375\")])\n"
"Decimal('0.5625')"

#: ../../library/statistics.rst:151
msgid ""
"The mean is strongly affected by `outliers <https://en.wikipedia.org/wiki/"
"Outlier>`_ and is not necessarily a typical example of the data points. For "
"a more robust, although less efficient, measure of `central tendency "
"<https://en.wikipedia.org/wiki/Central_tendency>`_, see :func:`median`."
msgstr ""
"Medelvärdet påverkas starkt av `extremvärden <https://en.wikipedia.org/wiki/"
"Outlier>`_ och är inte nödvändigtvis ett typiskt exempel på datapunkterna. "
"För ett mer robust, men mindre effektivt, mått på `central tendens <https://"
"en.wikipedia.org/wiki/Central_tendency>`_, se :func:`median`."

#: ../../library/statistics.rst:157
msgid ""
"The sample mean gives an unbiased estimate of the true population mean, so "
"that when taken on average over all the possible samples, ``mean(sample)`` "
"converges on the true mean of the entire population.  If *data* represents "
"the entire population rather than a sample, then ``mean(data)`` is "
"equivalent to calculating the true population mean μ."
msgstr ""
"Medelvärdet för urvalet ger en opartisk uppskattning av det sanna "
"populationsmedelvärdet, så att när det tas som ett genomsnitt över alla "
"möjliga urval, konvergerar ``mean(sample)`` mot det sanna medelvärdet för "
"hela populationen.  Om *data* representerar hela populationen snarare än ett "
"urval, är ``mean(data)`` likvärdigt med att beräkna det sanna "
"populationsmedelvärdet μ."

#: ../../library/statistics.rst:166
msgid "Convert *data* to floats and compute the arithmetic mean."
msgstr ""
"Konvertera *data* till flyttal och beräkna det aritmetiska medelvärdet."

#: ../../library/statistics.rst:168
msgid ""
"This runs faster than the :func:`mean` function and it always returns "
"a :class:`float`.  The *data* may be a sequence or iterable.  If the input "
"dataset is empty, raises a :exc:`StatisticsError`."
msgstr ""
"Detta går snabbare än funktionen :func:`mean` och returnerar alltid "
"en :class:`float`.  *Data* kan vara en sekvens eller iterabel.  Om "
"indatauppsättningen är tom, returneras ett :exc:`StatisticsError`."

#: ../../library/statistics.rst:172
msgid ""
">>> fmean([3.5, 4.0, 5.25])\n"
"4.25"
msgstr ""
">>> fmean([3.5, 4.0, 5.25])\n"
"4.25"

#: ../../library/statistics.rst:177
msgid ""
"Optional weighting is supported.  For example, a professor assigns a grade "
"for a course by weighting quizzes at 20%, homework at 20%, a midterm exam at "
"30%, and a final exam at 30%:"
msgstr ""
"Valfri viktning stöds.  En professor kan till exempel sätta betyg på en kurs "
"genom att vikta frågesporter med 20 %, hemuppgifter med 20 %, en "
"halvtidstentamen med 30 % och en sluttentamen med 30 %:"

#: ../../library/statistics.rst:181
msgid ""
">>> grades = [85, 92, 83, 91]\n"
">>> weights = [0.20, 0.20, 0.30, 0.30]\n"
">>> fmean(grades, weights)\n"
"87.6"
msgstr ""
">>> grades = [85, 92, 83, 91]\n"
">>> weights = [0.20, 0.20, 0.30, 0.30]\n"
">>> fmean(grades, weights)\n"
"87.6"

#: ../../library/statistics.rst:188
msgid ""
"If *weights* is supplied, it must be the same length as the *data* or "
"a :exc:`ValueError` will be raised."
msgstr ""
"Om *weights* anges måste den vara lika lång som *data*, annars uppstår "
"ett :exc:`ValueError`."

#: ../../library/statistics.rst:193 ../../library/statistics.rst:261
msgid "Added support for *weights*."
msgstr "Lagt till stöd för *vikter*."

#: ../../library/statistics.rst:199
msgid "Convert *data* to floats and compute the geometric mean."
msgstr ""
"Konvertera *data* till flyttal och beräkna det geometriska medelvärdet."

#: ../../library/statistics.rst:201
msgid ""
"The geometric mean indicates the central tendency or typical value of the "
"*data* using the product of the values (as opposed to the arithmetic mean "
"which uses their sum)."
msgstr ""
"Det geometriska medelvärdet anger den centrala tendensen eller det typiska "
"värdet för *data* genom att använda produkten av värdena (i motsats till det "
"aritmetiska medelvärdet som använder summan av värdena)."

#: ../../library/statistics.rst:205
msgid ""
"Raises a :exc:`StatisticsError` if the input dataset is empty, if it "
"contains a zero, or if it contains a negative value. The *data* may be a "
"sequence or iterable."
msgstr ""
"Utlöser ett :exc:`StatisticsError` om indatadatasetet är tomt, om det "
"innehåller en nolla eller om det innehåller ett negativt värde. *Data* kan "
"vara en sekvens eller iterabel."

#: ../../library/statistics.rst:209
msgid ""
"No special efforts are made to achieve exact results. (However, this may "
"change in the future.)"
msgstr ""
"Inga särskilda ansträngningar görs för att uppnå exakta resultat. (Detta kan "
"dock komma att ändras i framtiden.)"

#: ../../library/statistics.rst:212
msgid ""
">>> round(geometric_mean([54, 24, 36]), 1)\n"
"36.0"
msgstr ""
">>> round(geometric_mean([54, 24, 36]), 1)\n"
"36.0"

#: ../../library/statistics.rst:222
msgid ""
"Return the harmonic mean of *data*, a sequence or iterable of real-valued "
"numbers.  If *weights* is omitted or ``None``, then equal weighting is "
"assumed."
msgstr ""
"Returnerar det harmoniska medelvärdet av *data*, en sekvens eller iterabel "
"av realvärdesberäknade tal.  Om *weights* utelämnas eller ``None``, antas "
"lika viktning."

#: ../../library/statistics.rst:226
msgid ""
"The harmonic mean is the reciprocal of the arithmetic :func:`mean` of the "
"reciprocals of the data. For example, the harmonic mean of three values *a*, "
"*b* and *c* will be equivalent to ``3/(1/a + 1/b + 1/c)``.  If one of the "
"values is zero, the result will be zero."
msgstr ""
"Det harmoniska medelvärdet är reciprokvärdet av det aritmetiska :func:`mean` "
"av de reciproka värdena i data. Till exempel kommer det harmoniska "
"medelvärdet av tre värden *a*, *b* och *c* att motsvara ``3/(1/a + 1/b + 1/"
"c)``.  Om ett av värdena är noll blir resultatet noll."

#: ../../library/statistics.rst:231
msgid ""
"The harmonic mean is a type of average, a measure of the central location of "
"the data.  It is often appropriate when averaging ratios or rates, for "
"example speeds."
msgstr ""
"Det harmoniska medelvärdet är en typ av medelvärde, ett mått på den centrala "
"platsen för data.  Det är ofta lämpligt vid medelvärdesberäkning av "
"förhållanden eller hastigheter, t.ex. hastigheter."

#: ../../library/statistics.rst:235
msgid ""
"Suppose a car travels 10 km at 40 km/hr, then another 10 km at 60 km/hr. "
"What is the average speed?"
msgstr ""
"Antag att en bil färdas 10 km i 40 km/tim och sedan ytterligare 10 km i 60 "
"km/tim. Vad är medelhastigheten?"

#: ../../library/statistics.rst:238
msgid ""
">>> harmonic_mean([40, 60])\n"
"48.0"
msgstr ""
">>> harmonic_mean([40, 60])\n"
"48.0"

#: ../../library/statistics.rst:243
msgid ""
"Suppose a car travels 40 km/hr for 5 km, and when traffic clears, speeds-up "
"to 60 km/hr for the remaining 30 km of the journey. What is the average "
"speed?"
msgstr ""
"Antag att en bil kör 40 km/tim i 5 km och när trafiken släpper ökar "
"hastigheten till 60 km/tim under de återstående 30 km av färden. Vad är den "
"genomsnittliga hastigheten?"

#: ../../library/statistics.rst:247
msgid ""
">>> harmonic_mean([40, 60], weights=[5, 30])\n"
"56.0"
msgstr ""
">>> harmonic_mean([40, 60], weights=[5, 30])\n"
"56.0"

#: ../../library/statistics.rst:252
msgid ""
":exc:`StatisticsError` is raised if *data* is empty, any element is less "
"than zero, or if the weighted sum isn't positive."
msgstr ""
":exc:`StatisticsError` uppstår om *data* är tomt, om något element är mindre "
"än noll eller om den viktade summan inte är positiv."

#: ../../library/statistics.rst:255
msgid ""
"The current algorithm has an early-out when it encounters a zero in the "
"input.  This means that the subsequent inputs are not tested for validity.  "
"(This behavior may change in the future.)"
msgstr ""
"Den nuvarande algoritmen har en tidig utgång när den stöter på en nolla i "
"indata.  Detta innebär att de efterföljande inmatningarna inte testas för "
"giltighet.  (Detta beteende kan komma att ändras i framtiden)"

#: ../../library/statistics.rst:267
msgid ""
"`Kernel Density Estimation (KDE) <https://www.itm-conferences.org/articles/"
"itmconf/pdf/2018/08/itmconf_sam2018_00037.pdf>`_: Create a continuous "
"probability density function or cumulative distribution function from "
"discrete samples."
msgstr ""
"`Kernel Density Estimation (KDE) <https://www.itm-conferences.org/articles/"
"itmconf/pdf/2018/08/itmconf_sam2018_00037.pdf>`_: Skapa en kontinuerlig "
"sannolikhetstäthetsfunktion eller kumulativ fördelningsfunktion från "
"diskreta prov."

#: ../../library/statistics.rst:272
msgid ""
"The basic idea is to smooth the data using `a kernel function <https://"
"en.wikipedia.org/wiki/Kernel_(statistics)>`_. to help draw inferences about "
"a population from a sample."
msgstr ""
"Grundtanken är att jämna ut data med hjälp av `en kärnfunktion <https://"
"en.wikipedia.org/wiki/Kernel_(statistics)>`_. för att hjälpa till att dra "
"slutsatser om en population från ett urval."

#: ../../library/statistics.rst:276
msgid ""
"The degree of smoothing is controlled by the scaling parameter *h* which is "
"called the bandwidth.  Smaller values emphasize local features while larger "
"values give smoother results."
msgstr ""
"Graden av utjämning styrs av skalningsparametern *h*, som kallas bandbredd.  "
"Mindre värden framhäver lokala särdrag medan större värden ger ett jämnare "
"resultat."

#: ../../library/statistics.rst:280
msgid ""
"The *kernel* determines the relative weights of the sample data points.  "
"Generally, the choice of kernel shape does not matter as much as the more "
"influential bandwidth smoothing parameter."
msgstr ""
"*Kärnan* bestämmer de relativa vikterna för datapunkterna i urvalet.  I "
"allmänhet har valet av kärnform inte lika stor betydelse som den mer "
"inflytelserika parametern för utjämning av bandbredd."

#: ../../library/statistics.rst:284
msgid ""
"Kernels that give some weight to every sample point include *normal* "
"(*gauss*), *logistic*, and *sigmoid*."
msgstr ""
"Kärnor som ger viss vikt åt varje provpunkt inkluderar *normal* (*gauss*), "
"*logistisk* och *sigmoid*."

#: ../../library/statistics.rst:287
msgid ""
"Kernels that only give weight to sample points within the bandwidth include "
"*rectangular* (*uniform*), *triangular*, *parabolic* (*epanechnikov*), "
"*quartic* (*biweight*), *triweight*, and *cosine*."
msgstr ""
"Kärnor som bara ger vikt åt provpunkter inom bandbredden inkluderar "
"*rektangulär* (*uniform*), *triangulär*, *parabolisk* (*epanechnikov*), "
"*kvadratisk* (*bivikt*), *trivikt* och *cosinus*."

#: ../../library/statistics.rst:291
msgid ""
"If *cumulative* is true, will return a cumulative distribution function."
msgstr "Om *cumulative* är true, returneras en kumulativ fördelningsfunktion."

#: ../../library/statistics.rst:293 ../../library/statistics.rst:324
msgid ""
"A :exc:`StatisticsError` will be raised if the *data* sequence is empty."
msgstr ""
"Ett :exc:`StatisticsError` kommer att uppstå om *data*-sekvensen är tom."

#: ../../library/statistics.rst:295
msgid ""
"`Wikipedia has an example <https://en.wikipedia.org/wiki/"
"Kernel_density_estimation#Example>`_ where we can use :func:`kde` to "
"generate and plot a probability density function estimated from a small "
"sample:"
msgstr ""
"`Wikipedia har ett exempel <https://en.wikipedia.org/wiki/"
"Kernel_density_estimation#Example>`_ där vi kan använda :func:`kde` för att "
"generera och plotta en sannolikhetstäthetsfunktion som uppskattats från ett "
"litet urval:"

#: ../../library/statistics.rst:300
msgid ""
">>> sample = [-2.1, -1.3, -0.4, 1.9, 5.1, 6.2]\n"
">>> f_hat = kde(sample, h=1.5)\n"
">>> xarr = [i/100 for i in range(-750, 1100)]\n"
">>> yarr = [f_hat(x) for x in xarr]"
msgstr ""
">>> sample = [-2.1, -1.3, -0.4, 1.9, 5.1, 6.2]\n"
">>> f_hat = kde(sample, h=1.5)\n"
">>> xarr = [i/100 for i in range(-750, 1100)]\n"
">>> yarr = [f_hat(x) for x in xarr]"

#: ../../library/statistics.rst:307
msgid "The points in ``xarr`` and ``yarr`` can be used to make a PDF plot:"
msgstr ""
"Punkterna i ``xarr`` och ``yarr`` kan användas för att göra en PDF-plott:"

#: ../../library/statistics.rst:309
msgid "Scatter plot of the estimated probability density function."
msgstr "Spridningsdiagram över den uppskattade sannolikhetstäthetsfunktionen."

#: ../../library/statistics.rst:317
msgid ""
"Return a function that makes a random selection from the estimated "
"probability density function produced by ``kde(data, h, kernel)``."
msgstr ""
"Returnerar en funktion som gör ett slumpmässigt urval från den skattade "
"sannolikhetstäthetsfunktionen som produceras av ``kde(data, h, kernel)``."

#: ../../library/statistics.rst:320
msgid ""
"Providing a *seed* allows reproducible selections. In the future, the values "
"may change slightly as more accurate kernel inverse CDF estimates are "
"implemented.  The seed may be an integer, float, str, or bytes."
msgstr ""
"Genom att tillhandahålla ett *frö* möjliggörs reproducerbara urval. I "
"framtiden kan värdena ändras något i takt med att mer exakta inversa CDF-"
"estimat för kärnor implementeras.  Seed kan vara ett heltal, float, str "
"eller bytes."

#: ../../library/statistics.rst:326
msgid ""
"Continuing the example for :func:`kde`, we can use :func:`kde_random` to "
"generate new random selections from an estimated probability density "
"function:"
msgstr ""
"Om vi fortsätter med exemplet för :func:`kde` kan vi "
"använda :func:`kde_random` för att generera nya slumpmässiga val från en "
"uppskattad sannolikhetstäthetsfunktion:"

#: ../../library/statistics.rst:341
msgid ""
"Return the median (middle value) of numeric data, using the common \"mean of "
"middle two\" method.  If *data* is empty, :exc:`StatisticsError` is raised. "
"*data* can be a sequence or iterable."
msgstr ""
"Returnerar medianen (mittvärdet) för numeriska data med hjälp av den vanliga "
"metoden \"medelvärdet av de två mittersta\".  Om *data* är tomt "
"kommer :exc:`StatisticsError` att returneras. *data* kan vara en sekvens "
"eller en iterabel."

#: ../../library/statistics.rst:345
msgid ""
"The median is a robust measure of central location and is less affected by "
"the presence of outliers.  When the number of data points is odd, the middle "
"data point is returned:"
msgstr ""
"Medianen är ett robust mått på central placering och påverkas mindre av "
"förekomsten av avvikande värden.  När antalet datapunkter är udda returneras "
"den mittersta datapunkten:"

#: ../../library/statistics.rst:349
msgid ""
">>> median([1, 3, 5])\n"
"3"
msgstr ""
">>> median([1, 3, 5])\n"
"3"

#: ../../library/statistics.rst:354
msgid ""
"When the number of data points is even, the median is interpolated by taking "
"the average of the two middle values:"
msgstr ""
"När antalet datapunkter är jämnt interpoleras medianen genom att ta "
"medelvärdet av de två mellersta värdena:"

#: ../../library/statistics.rst:357
msgid ""
">>> median([1, 3, 5, 7])\n"
"4.0"
msgstr ""
">>> median([1, 3, 5, 7])\n"
"4.0"

#: ../../library/statistics.rst:362
msgid ""
"This is suited for when your data is discrete, and you don't mind that the "
"median may not be an actual data point."
msgstr ""
"Detta är lämpligt när dina data är diskreta och du inte bryr dig om att "
"medianen kanske inte är en faktisk datapunkt."

#: ../../library/statistics.rst:365
msgid ""
"If the data is ordinal (supports order operations) but not numeric (doesn't "
"support addition), consider using :func:`median_low` or :func:`median_high` "
"instead."
msgstr ""
"Om data är ordinala (stöder orderoperationer) men inte numeriska (stöder "
"inte addition) kan du överväga att använda :func:`median_low` "
"eller :func:`median_high` i stället."

#: ../../library/statistics.rst:371
msgid ""
"Return the low median of numeric data.  If *data* is "
"empty, :exc:`StatisticsError` is raised.  *data* can be a sequence or "
"iterable."
msgstr ""
"Returnerar den låga medianen för numeriska data.  Om *data* är tomt "
"kommer :exc:`StatisticsError` att returneras.  *data* kan vara en sekvens "
"eller en iterabel."

#: ../../library/statistics.rst:374
msgid ""
"The low median is always a member of the data set.  When the number of data "
"points is odd, the middle value is returned.  When it is even, the smaller "
"of the two middle values is returned."
msgstr ""
"Den låga medianen ingår alltid i datauppsättningen.  När antalet datapunkter "
"är udda returneras det mittersta värdet.  Om det är jämnt returneras det "
"minsta av de två mittvärdena."

#: ../../library/statistics.rst:378
msgid ""
">>> median_low([1, 3, 5])\n"
"3\n"
">>> median_low([1, 3, 5, 7])\n"
"3"
msgstr ""
">>> median_low([1, 3, 5])\n"
"3\n"
">>> median_low([1, 3, 5, 7])\n"
"3"

#: ../../library/statistics.rst:385
msgid ""
"Use the low median when your data are discrete and you prefer the median to "
"be an actual data point rather than interpolated."
msgstr ""
"Använd den låga medianen när dina data är diskreta och du föredrar att "
"medianen är en faktisk datapunkt snarare än interpolerad."

#: ../../library/statistics.rst:391
msgid ""
"Return the high median of data.  If *data* is empty, :exc:`StatisticsError` "
"is raised.  *data* can be a sequence or iterable."
msgstr ""
"Returnerar den höga medianen för data.  Om *data* är "
"tomt, :exc:`StatisticsError` tas upp.  *data* kan vara en sekvens eller en "
"iterabel."

#: ../../library/statistics.rst:394
msgid ""
"The high median is always a member of the data set.  When the number of data "
"points is odd, the middle value is returned.  When it is even, the larger of "
"the two middle values is returned."
msgstr ""
"Den höga medianen ingår alltid i datauppsättningen.  När antalet datapunkter "
"är udda returneras det mittersta värdet.  Om det är jämnt returneras det "
"största av de två mittvärdena."

#: ../../library/statistics.rst:398
msgid ""
">>> median_high([1, 3, 5])\n"
"3\n"
">>> median_high([1, 3, 5, 7])\n"
"5"
msgstr ""
">>> median_high([1, 3, 5])\n"
"3\n"
">>> median_high([1, 3, 5, 7])\n"
"5"

#: ../../library/statistics.rst:405
msgid ""
"Use the high median when your data are discrete and you prefer the median to "
"be an actual data point rather than interpolated."
msgstr ""
"Använd den höga medianen när dina data är diskreta och du föredrar att "
"medianen är en faktisk datapunkt snarare än interpolerad."

#: ../../library/statistics.rst:411
msgid ""
"Estimates the median for numeric data that has been `grouped or binned "
"<https://en.wikipedia.org/wiki/Data_binning>`_ around the midpoints of "
"consecutive, fixed-width intervals."
msgstr ""
"Beräknar medianen för numeriska data som har `grupperats eller binnats "
"<https://en.wikipedia.org/wiki/Data_binning>`_ runt mittpunkterna i på "
"varandra följande intervall med fast bredd."

#: ../../library/statistics.rst:415
msgid ""
"The *data* can be any iterable of numeric data with each value being exactly "
"the midpoint of a bin.  At least one value must be present."
msgstr ""
"*Data* kan vara vilken iterabel som helst av numeriska data där varje värde "
"är exakt mittpunkten i en bin.  Åtminstone ett värde måste finnas."

#: ../../library/statistics.rst:418
msgid "The *interval* is the width of each bin."
msgstr "*Intervall* är bredden på varje bin."

#: ../../library/statistics.rst:420
msgid ""
"For example, demographic information may have been summarized into "
"consecutive ten-year age groups with each group being represented by the 5-"
"year midpoints of the intervals:"
msgstr ""
"Demografisk information kan t.ex. ha sammanfattats i på varandra följande "
"tioåriga åldersgrupper där varje grupp representeras av intervallens 5-åriga "
"mittpunkter:"

#: ../../library/statistics.rst:424
msgid ""
">>> from collections import Counter\n"
">>> demographics = Counter({\n"
"...    25: 172,   # 20 to 30 years old\n"
"...    35: 484,   # 30 to 40 years old\n"
"...    45: 387,   # 40 to 50 years old\n"
"...    55:  22,   # 50 to 60 years old\n"
"...    65:   6,   # 60 to 70 years old\n"
"... })\n"
"..."
msgstr ""
">>> from collections import Counter\n"
">>> demographics = Counter({\n"
"...    25: 172,   # 20 to 30 years old\n"
"...    35: 484,   # 30 to 40 years old\n"
"...    45: 387,   # 40 to 50 years old\n"
"...    55:  22,   # 50 to 60 years old\n"
"...    65:   6,   # 60 to 70 years old\n"
"... })\n"
"..."

#: ../../library/statistics.rst:436
msgid ""
"The 50th percentile (median) is the 536th person out of the 1071 member "
"cohort.  That person is in the 30 to 40 year old age group."
msgstr ""
"Den 50:e percentilen (medianen) är den 536:e personen av de 1071 medlemmarna "
"i kohorten.  Den personen är i åldersgruppen 30 till 40 år."

#: ../../library/statistics.rst:439
msgid ""
"The regular :func:`median` function would assume that everyone in the "
"tricenarian age group was exactly 35 years old.  A more tenable assumption "
"is that the 484 members of that age group are evenly distributed between 30 "
"and 40.  For that, we use :func:`median_grouped`:"
msgstr ""
"Den vanliga funktionen :func:`median` skulle anta att alla i åldersgruppen "
"tricenarianer var exakt 35 år gamla.  Ett mer hållbart antagande är att de "
"484 medlemmarna i den åldersgruppen är jämnt fördelade mellan 30 och 40.  "
"För det använder vi :func:`median_grouped`:"

#: ../../library/statistics.rst:445
msgid ""
">>> data = list(demographics.elements())\n"
">>> median(data)\n"
"35\n"
">>> round(median_grouped(data, interval=10), 1)\n"
"37.5"
msgstr ""
">>> data = list(demographics.elements())\n"
">>> median(data)\n"
"35\n"
">>> round(median_grouped(data, interval=10), 1)\n"
"37.5"

#: ../../library/statistics.rst:453
msgid ""
"The caller is responsible for making sure the data points are separated by "
"exact multiples of *interval*.  This is essential for getting a correct "
"result.  The function does not check this precondition."
msgstr ""
"Anroparen ansvarar för att datapunkterna är åtskilda med exakta multiplar av "
"*intervall*.  Detta är viktigt för att få ett korrekt resultat.  Funktionen "
"kontrollerar inte detta förhandsvillkor."

#: ../../library/statistics.rst:457
msgid ""
"Inputs may be any numeric type that can be coerced to a float during the "
"interpolation step."
msgstr ""
"Ingångarna kan vara av vilken numerisk typ som helst som kan omvandlas till "
"en float under interpoleringssteget."

#: ../../library/statistics.rst:463
msgid ""
"Return the single most common data point from discrete or nominal *data*. "
"The mode (when it exists) is the most typical value and serves as a measure "
"of central location."
msgstr ""
"Returnerar den enskilt vanligaste datapunkten från diskreta eller nominella "
"*data*. Läget (när det finns) är det mest typiska värdet och fungerar som "
"ett mått på central placering."

#: ../../library/statistics.rst:467
msgid ""
"If there are multiple modes with the same frequency, returns the first one "
"encountered in the *data*.  If the smallest or largest of those is desired "
"instead, use ``min(multimode(data))`` or ``max(multimode(data))``. If the "
"input *data* is empty, :exc:`StatisticsError` is raised."
msgstr ""
"Om det finns flera lägen med samma frekvens returneras det första som "
"påträffas i *data*.  Om den minsta eller största av dessa önskas istället, "
"använd ``min(multimode(data))`` eller ``max(multimode(data))``. Om indata "
"*data* är tomt, kommer :exc:`StatisticsError` att visas."

#: ../../library/statistics.rst:472
msgid ""
"``mode`` assumes discrete data and returns a single value. This is the "
"standard treatment of the mode as commonly taught in schools:"
msgstr ""
"``mode`` förutsätter diskreta data och returnerar ett enda värde. Detta är "
"standardbehandlingen av mode som vanligtvis lärs ut i skolorna:"

#: ../../library/statistics.rst:475
msgid ""
">>> mode([1, 1, 2, 3, 3, 3, 3, 4])\n"
"3"
msgstr ""
">>> mode([1, 1, 2, 3, 3, 3, 3, 4])\n"
"3"

#: ../../library/statistics.rst:480
msgid ""
"The mode is unique in that it is the only statistic in this package that "
"also applies to nominal (non-numeric) data:"
msgstr ""
"Mode är unikt eftersom det är den enda statistiken i det här paketet som "
"även gäller för nominella (icke-numeriska) data:"

#: ../../library/statistics.rst:483
msgid ""
">>> mode([\"red\", \"blue\", \"blue\", \"red\", \"green\", \"red\", "
"\"red\"])\n"
"'red'"
msgstr ""
">>> mode([\"red\", \"blue\", \"blue\", \"red\", \"green\", \"red\", "
"\"red\"])\n"
"'red'"

#: ../../library/statistics.rst:488
msgid ""
"Only hashable inputs are supported.  To handle type :class:`set`, consider "
"casting to :class:`frozenset`.  To handle type :class:`list`, consider "
"casting to :class:`tuple`.  For mixed or nested inputs, consider using this "
"slower quadratic algorithm that only depends on equality tests: ``max(data, "
"key=data.count)``."
msgstr ""
"Endast hashbara indata stöds.  För att hantera typen :class:`set`, överväg "
"att casta till :class:`frozenset`.  För att hantera typen :class:`list`, "
"överväg att casta till :class:`tuple`.  För blandade eller nästlade indata "
"kan du överväga att använda den här långsammare kvadratiska algoritmen som "
"bara beror på likhetstester: ``max(data, key=data.count)``."

#: ../../library/statistics.rst:494
msgid ""
"Now handles multimodal datasets by returning the first mode encountered. "
"Formerly, it raised :exc:`StatisticsError` when more than one mode was found."
msgstr ""
"Hanterar nu multimodala dataset genom att returnera det första läget som "
"påträffas. Tidigare gav den :exc:`StatisticsError` när mer än ett läge "
"hittades."

#: ../../library/statistics.rst:502
msgid ""
"Return a list of the most frequently occurring values in the order they were "
"first encountered in the *data*.  Will return more than one result if there "
"are multiple modes or an empty list if the *data* is empty:"
msgstr ""
"Returnerar en lista med de mest frekvent förekommande värdena i den ordning "
"de först påträffades i *data*.  Returnerar mer än ett resultat om det finns "
"flera lägen eller en tom lista om *data* är tom:"

#: ../../library/statistics.rst:506
msgid ""
">>> multimode('aabbbbccddddeeffffgg')\n"
"['b', 'd', 'f']\n"
">>> multimode('')\n"
"[]"
msgstr ""
">>> multimode('aabbbbccddddeeffffgg')\n"
"['b', 'd', 'f']\n"
">>> multimode('')\n"
"[]"

#: ../../library/statistics.rst:518
msgid ""
"Return the population standard deviation (the square root of the population "
"variance).  See :func:`pvariance` for arguments and other details."
msgstr ""
"Returnerar populationens standardavvikelse (kvadratroten av populationens "
"varians).  Se :func:`pvariance` för argument och andra detaljer."

#: ../../library/statistics.rst:521
msgid ""
">>> pstdev([1.5, 2.5, 2.5, 2.75, 3.25, 4.75])\n"
"0.986893273527251"
msgstr ""
">>> pstdev([1.5, 2.5, 2.5, 2.75, 3.25, 4.75])\n"
"0.986893273527251"

#: ../../library/statistics.rst:529
msgid ""
"Return the population variance of *data*, a non-empty sequence or iterable "
"of real-valued numbers.  Variance, or second moment about the mean, is a "
"measure of the variability (spread or dispersion) of data.  A large variance "
"indicates that the data is spread out; a small variance indicates it is "
"clustered closely around the mean."
msgstr ""
"Returnerar populationsvariansen för *data*, en icke-tom sekvens eller "
"iterabel av realvärdesberäknade tal.  Varians, eller andra momentet kring "
"medelvärdet, är ett mått på variabiliteten (spridningen) i data.  En stor "
"varians indikerar att data är utspridda; en liten varians indikerar att de "
"är grupperade tätt runt medelvärdet."

#: ../../library/statistics.rst:535
msgid ""
"If the optional second argument *mu* is given, it should be the *population* "
"mean of the *data*.  It can also be used to compute the second moment around "
"a point that is not the mean.  If it is missing or ``None`` (the default), "
"the arithmetic mean is automatically calculated."
msgstr ""
"Om det valfria andra argumentet *mu* anges bör det vara *populationens* "
"medelvärde för *data*.  Det kan också användas för att beräkna det andra "
"momentet runt en punkt som inte är medelvärdet.  Om det saknas eller är "
"``None`` (standard) beräknas det aritmetiska medelvärdet automatiskt."

#: ../../library/statistics.rst:540
msgid ""
"Use this function to calculate the variance from the entire population.  To "
"estimate the variance from a sample, the :func:`variance` function is "
"usually a better choice."
msgstr ""
"Använd denna funktion för att beräkna variansen från hela populationen.  För "
"att uppskatta variansen från ett urval är funktionen :func:`variance` "
"vanligtvis ett bättre val."

#: ../../library/statistics.rst:544
msgid "Raises :exc:`StatisticsError` if *data* is empty."
msgstr "Utlöser :exc:`StatisticsError` om *data* är tomt."

#: ../../library/statistics.rst:546 ../../library/statistics.rst:616
#: ../../library/statistics.rst:725
msgid "Examples:"
msgstr "Exempel:"

#: ../../library/statistics.rst:548
msgid ""
">>> data = [0.0, 0.25, 0.25, 1.25, 1.5, 1.75, 2.75, 3.25]\n"
">>> pvariance(data)\n"
"1.25"
msgstr ""
">>> data = [0.0, 0.25, 0.25, 1.25, 1.5, 1.75, 2.75, 3.25]\n"
">>> pvariance(data)\n"
"1.25"

#: ../../library/statistics.rst:554
msgid ""
"If you have already calculated the mean of your data, you can pass it as the "
"optional second argument *mu* to avoid recalculation:"
msgstr ""
"Om du redan har beräknat medelvärdet för dina data kan du skicka det som det "
"valfria andra argumentet *mu* för att undvika omberäkning:"

#: ../../library/statistics.rst:557
msgid ""
">>> mu = mean(data)\n"
">>> pvariance(data, mu)\n"
"1.25"
msgstr ""
">>> mu = mean(data)\n"
">>> pvariance(data, mu)\n"
"1.25"

#: ../../library/statistics.rst:563
msgid "Decimals and Fractions are supported:"
msgstr "Decimaler och bråk stöds:"

#: ../../library/statistics.rst:565
msgid ""
">>> from decimal import Decimal as D\n"
">>> pvariance([D(\"27.5\"), D(\"30.25\"), D(\"30.25\"), D(\"34.5\"), "
"D(\"41.75\")])\n"
"Decimal('24.815')\n"
"\n"
">>> from fractions import Fraction as F\n"
">>> pvariance([F(1, 4), F(5, 4), F(1, 2)])\n"
"Fraction(13, 72)"
msgstr ""
">>> from decimal import Decimal as D\n"
">>> pvariance([D(\"27.5\"), D(\"30.25\"), D(\"30.25\"), D(\"34.5\"), "
"D(\"41.75\")])\n"
"Decimal('24.815')\n"
"\n"
">>> from fractions import Fraction as F\n"
">>> pvariance([F(1, 4), F(5, 4), F(1, 2)])\n"
"Fraction(13, 72)"

#: ../../library/statistics.rst:577
msgid ""
"When called with the entire population, this gives the population variance "
"σ².  When called on a sample instead, this is the biased sample variance s², "
"also known as variance with N degrees of freedom."
msgstr ""
"När detta kallas med hela populationen ger det populationsvariansen σ².  När "
"det i stället gäller ett urval är detta den partiska urvalsvariansen s², "
"även känd som varians med N frihetsgrader."

#: ../../library/statistics.rst:581
msgid ""
"If you somehow know the true population mean μ, you may use this function to "
"calculate the variance of a sample, giving the known population mean as the "
"second argument.  Provided the data points are a random sample of the "
"population, the result will be an unbiased estimate of the population "
"variance."
msgstr ""
"Om du på något sätt känner till det sanna populationsmedelvärdet μ, kan du "
"använda denna funktion för att beräkna variansen för ett urval, med det "
"kända populationsmedelvärdet som andra argument.  Förutsatt att "
"datapunkterna är ett slumpmässigt urval av populationen blir resultatet en "
"väntevärdesriktig skattning av populationsvariansen."

#: ../../library/statistics.rst:590
msgid ""
"Return the sample standard deviation (the square root of the sample "
"variance).  See :func:`variance` for arguments and other details."
msgstr ""
"Returnerar standardavvikelsen för urvalet (kvadratroten av variansen för "
"urvalet).  Se :func:`variance` för argument och andra detaljer."

#: ../../library/statistics.rst:593
msgid ""
">>> stdev([1.5, 2.5, 2.5, 2.75, 3.25, 4.75])\n"
"1.0810874155219827"
msgstr ""
">>> stdev([1.5, 2.5, 2.5, 2.75, 3.25, 4.75])\n"
"1.0810874155219827"

#: ../../library/statistics.rst:601
msgid ""
"Return the sample variance of *data*, an iterable of at least two real-"
"valued numbers.  Variance, or second moment about the mean, is a measure of "
"the variability (spread or dispersion) of data.  A large variance indicates "
"that the data is spread out; a small variance indicates it is clustered "
"closely around the mean."
msgstr ""
"Returnerar urvalsvariansen för *data*, en iterabel med minst två "
"realvärdestal.  Varians, eller andra momentet kring medelvärdet, är ett mått "
"på variabiliteten (spridningen) i data.  En stor varians indikerar att data "
"är utspridda, medan en liten varians indikerar att de är grupperade tätt "
"kring medelvärdet."

#: ../../library/statistics.rst:607
msgid ""
"If the optional second argument *xbar* is given, it should be the *sample* "
"mean of *data*.  If it is missing or ``None`` (the default), the mean is "
"automatically calculated."
msgstr ""
"Om det valfria andra argumentet *xbar* anges bör det vara medelvärdet för "
"*data* för *provet*.  Om det saknas eller är ``None`` (standard) beräknas "
"medelvärdet automatiskt."

#: ../../library/statistics.rst:611
msgid ""
"Use this function when your data is a sample from a population. To calculate "
"the variance from the entire population, see :func:`pvariance`."
msgstr ""
"Använd den här funktionen när dina data är ett urval från en population. För "
"att beräkna variansen från hela populationen, se :func:`pvariance`."

#: ../../library/statistics.rst:614
msgid "Raises :exc:`StatisticsError` if *data* has fewer than two values."
msgstr "Utlöser :exc:`StatisticsError` om *data* har färre än två värden."

#: ../../library/statistics.rst:618
msgid ""
">>> data = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5]\n"
">>> variance(data)\n"
"1.3720238095238095"
msgstr ""
">>> data = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5]\n"
">>> variance(data)\n"
"1.3720238095238095"

#: ../../library/statistics.rst:624
msgid ""
"If you have already calculated the sample mean of your data, you can pass it "
"as the optional second argument *xbar* to avoid recalculation:"
msgstr ""
"Om du redan har beräknat urvalsmedelvärdet för dina data kan du skicka det "
"som det valfria andra argumentet *xbar* för att undvika omräkning:"

#: ../../library/statistics.rst:627
msgid ""
">>> m = mean(data)\n"
">>> variance(data, m)\n"
"1.3720238095238095"
msgstr ""
">>> m = mean(data)\n"
">>> variance(data, m)\n"
"1.3720238095238095"

#: ../../library/statistics.rst:633
msgid ""
"This function does not attempt to verify that you have passed the actual "
"mean as *xbar*.  Using arbitrary values for *xbar* can lead to invalid or "
"impossible results."
msgstr ""
"Denna funktion försöker inte verifiera att du har angett det faktiska "
"medelvärdet som *xbar*.  Om du använder godtyckliga värden för *xbar* kan "
"det leda till ogiltiga eller omöjliga resultat."

#: ../../library/statistics.rst:637
msgid "Decimal and Fraction values are supported:"
msgstr "Decimal- och fraktionsvärden stöds:"

#: ../../library/statistics.rst:639
msgid ""
">>> from decimal import Decimal as D\n"
">>> variance([D(\"27.5\"), D(\"30.25\"), D(\"30.25\"), D(\"34.5\"), "
"D(\"41.75\")])\n"
"Decimal('31.01875')\n"
"\n"
">>> from fractions import Fraction as F\n"
">>> variance([F(1, 6), F(1, 2), F(5, 3)])\n"
"Fraction(67, 108)"
msgstr ""
">>> from decimal import Decimal as D\n"
">>> variance([D(\"27.5\"), D(\"30.25\"), D(\"30.25\"), D(\"34.5\"), "
"D(\"41.75\")])\n"
"Decimal('31.01875')\n"
"\n"
">>> from fractions import Fraction as F\n"
">>> variance([F(1, 6), F(1, 2), F(5, 3)])\n"
"Fraction(67, 108)"

#: ../../library/statistics.rst:651
msgid ""
"This is the sample variance s² with Bessel's correction, also known as "
"variance with N-1 degrees of freedom.  Provided that the data points are "
"representative (e.g. independent and identically distributed), the result "
"should be an unbiased estimate of the true population variance."
msgstr ""
"Detta är urvalsvariansen s² med Bessels korrigering, även känd som varians "
"med N-1 frihetsgrader.  Förutsatt att datapunkterna är representativa (t.ex. "
"oberoende och identiskt fördelade) bör resultatet vara en väntevärdesriktig "
"skattning av den verkliga populationsvariansen."

#: ../../library/statistics.rst:656
msgid ""
"If you somehow know the actual population mean μ you should pass it to "
"the :func:`pvariance` function as the *mu* parameter to get the variance of "
"a sample."
msgstr ""
"Om du på något sätt känner till det faktiska populationsmedelvärdet μ bör du "
"skicka det till funktionen :func:`pvariance` som parametern *mu* för att få "
"variansen för ett urval."

#: ../../library/statistics.rst:662
msgid ""
"Divide *data* into *n* continuous intervals with equal probability. Returns "
"a list of ``n - 1`` cut points separating the intervals."
msgstr ""
"Dela upp *data* i *n* kontinuerliga intervall med samma sannolikhet. "
"Returnerar en lista med ``n - 1`` skärningspunkter som separerar intervallen."

#: ../../library/statistics.rst:665
msgid ""
"Set *n* to 4 for quartiles (the default).  Set *n* to 10 for deciles.  Set "
"*n* to 100 for percentiles which gives the 99 cuts points that separate "
"*data* into 100 equal sized groups.  Raises :exc:`StatisticsError` if *n* is "
"not least 1."
msgstr ""
"Ställ in *n* på 4 för kvartiler (standard).  Ställ in *n* till 10 för "
"deciler.  Ställ in *n* på 100 för percentiler, vilket ger de 99 snittpunkter "
"som delar in *data* i 100 lika stora grupper.  "
"Utlöser :exc:`StatisticsError` om *n* inte är minst 1."

#: ../../library/statistics.rst:670
msgid ""
"The *data* can be any iterable containing sample data.  For meaningful "
"results, the number of data points in *data* should be larger than *n*. "
"Raises :exc:`StatisticsError` if there is not at least one data point."
msgstr ""
"*data* kan vara vilken iterabel som helst som innehåller exempeldata.  För "
"meningsfulla resultat bör antalet datapunkter i *data* vara större än *n*. "
"Utlöser :exc:`StatisticsError` om det inte finns minst en datapunkt."

#: ../../library/statistics.rst:674
msgid ""
"The cut points are linearly interpolated from the two nearest data points.  "
"For example, if a cut point falls one-third of the distance between two "
"sample values, ``100`` and ``112``, the cut-point will evaluate to ``104``."
msgstr ""
"Skärningspunkterna interpoleras linjärt från de två närmaste datapunkterna.  "
"Om en skärningspunkt t.ex. ligger en tredjedel av avståndet mellan två "
"provvärden, ``100`` och ``112``, kommer skärningspunkten att utvärderas till "
"``104``."

#: ../../library/statistics.rst:679
msgid ""
"The *method* for computing quantiles can be varied depending on whether the "
"*data* includes or excludes the lowest and highest possible values from the "
"population."
msgstr ""
"*Metoden* för att beräkna kvantiler kan varieras beroende på om *data* "
"inkluderar eller exkluderar de lägsta och högsta möjliga värdena från "
"populationen."

#: ../../library/statistics.rst:683
msgid ""
"The default *method* is \"exclusive\" and is used for data sampled from a "
"population that can have more extreme values than found in the samples.  The "
"portion of the population falling below the *i-th* of *m* sorted data points "
"is computed as ``i / (m + 1)``.  Given nine sample values, the method sorts "
"them and assigns the following percentiles: 10%, 20%, 30%, 40%, 50%, 60%, "
"70%, 80%, 90%."
msgstr ""
"Standardmetoden *method* är \"exclusive\" och används för data som samlats "
"in från en population som kan ha mer extrema värden än vad som finns i "
"urvalet.  Den del av populationen som faller under *i-th* av *m* sorterade "
"datapunkter beräknas som ``i / (m + 1)``.  Med nio urvalsvärden sorterar "
"metoden dem och tilldelar följande percentiler: 10%, 20%, 30%, 40%, 50%, "
"60%, 70%, 80%, 90%."

#: ../../library/statistics.rst:690
msgid ""
"Setting the *method* to \"inclusive\" is used for describing population data "
"or for samples that are known to include the most extreme values from the "
"population.  The minimum value in *data* is treated as the 0th percentile "
"and the maximum value is treated as the 100th percentile. The portion of the "
"population falling below the *i-th* of *m* sorted data points is computed as "
"``(i - 1) / (m - 1)``.  Given 11 sample values, the method sorts them and "
"assigns the following percentiles: 0%, 10%, 20%, 30%, 40%, 50%, 60%, 70%, "
"80%, 90%, 100%."
msgstr ""
"Om *method* är inställd på \"inclusive\" används den för att beskriva "
"populationsdata eller för stickprov som man vet innehåller de mest extrema "
"värdena från populationen.  Minimivärdet i *data* behandlas som den 0:e "
"percentilen och maximivärdet behandlas som den 100:e percentilen. Den del av "
"populationen som faller under *i-th* av *m* sorterade datapunkter beräknas "
"som ``(i - 1) / (m - 1)``.  Givet 11 provvärden sorterar metoden dem och "
"tilldelar följande percentiler: 0%, 10%, 20%, 30%, 40%, 50%, 60%, 70%, 80%, "
"90%, 100%."

#: ../../library/statistics.rst:699
msgid ""
"# Decile cut points for empirically sampled data\n"
">>> data = [105, 129, 87, 86, 111, 111, 89, 81, 108, 92, 110,\n"
"...         100, 75, 105, 103, 109, 76, 119, 99, 91, 103, 129,\n"
"...         106, 101, 84, 111, 74, 87, 86, 103, 103, 106, 86,\n"
"...         111, 75, 87, 102, 121, 111, 88, 89, 101, 106, 95,\n"
"...         103, 107, 101, 81, 109, 104]\n"
">>> [round(q, 1) for q in quantiles(data, n=10)]\n"
"[81.0, 86.2, 89.0, 99.4, 102.5, 103.6, 106.0, 109.8, 111.0]"
msgstr ""
"# Decile cut points for empirically sampled data\n"
">>> data = [105, 129, 87, 86, 111, 111, 89, 81, 108, 92, 110,\n"
"...         100, 75, 105, 103, 109, 76, 119, 99, 91, 103, 129,\n"
"...         106, 101, 84, 111, 74, 87, 86, 103, 103, 106, 86,\n"
"...         111, 75, 87, 102, 121, 111, 88, 89, 101, 106, 95,\n"
"...         103, 107, 101, 81, 109, 104]\n"
">>> [round(q, 1) for q in quantiles(data, n=10)]\n"
"[81.0, 86.2, 89.0, 99.4, 102.5, 103.6, 106.0, 109.8, 111.0]"

#: ../../library/statistics.rst:712
msgid ""
"No longer raises an exception for an input with only a single data point. "
"This allows quantile estimates to be built up one sample point at a time "
"becoming gradually more refined with each new data point."
msgstr ""
"Det uppstår inte längre något undantag för en indata med endast en enda "
"datapunkt. Detta gör att kvantilskattningar kan byggas upp med en provpunkt "
"i taget och gradvis bli mer förfinade med varje ny datapunkt."

#: ../../library/statistics.rst:719
msgid ""
"Return the sample covariance of two inputs *x* and *y*. Covariance is a "
"measure of the joint variability of two inputs."
msgstr ""
"Returnerar sampelkovariansen för två indata *x* och *y*. Kovarians är ett "
"mått på den gemensamma variabiliteten hos två indata."

#: ../../library/statistics.rst:722
msgid ""
"Both inputs must be of the same length (no less than two), "
"otherwise :exc:`StatisticsError` is raised."
msgstr ""
"Båda inmatningarna måste vara lika långa (inte mindre än två), "
"annars :exc:`StatisticsError` tas upp."

#: ../../library/statistics.rst:727
msgid ""
">>> x = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
">>> y = [1, 2, 3, 1, 2, 3, 1, 2, 3]\n"
">>> covariance(x, y)\n"
"0.75\n"
">>> z = [9, 8, 7, 6, 5, 4, 3, 2, 1]\n"
">>> covariance(x, z)\n"
"-7.5\n"
">>> covariance(z, x)\n"
"-7.5"
msgstr ""
">>> x = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
">>> y = [1, 2, 3, 1, 2, 3, 1, 2, 3]\n"
">>> covariance(x, y)\n"
"0.75\n"
">>> z = [9, 8, 7, 6, 5, 4, 3, 2, 1]\n"
">>> covariance(x, z)\n"
"-7.5\n"
">>> covariance(z, x)\n"
"-7.5"

#: ../../library/statistics.rst:743
msgid ""
"Return the `Pearson's correlation coefficient <https://en.wikipedia.org/wiki/"
"Pearson_correlation_coefficient>`_ for two inputs. Pearson's correlation "
"coefficient *r* takes values between -1 and +1. It measures the strength and "
"direction of a linear relationship."
msgstr ""
"Returnerar `Pearsons korrelationskoefficient <https://en.wikipedia.org/wiki/"
"Pearson_correlation_coefficient>`_ för två indata. Pearsons "
"korrelationskoefficient *r* tar värden mellan -1 och +1. Den mäter styrkan "
"och riktningen i ett linjärt förhållande."

#: ../../library/statistics.rst:749
msgid ""
"If *method* is \"ranked\", computes `Spearman's rank correlation coefficient "
"<https://en.wikipedia.org/wiki/Spearman%27s_rank_correlation_coefficient>`_ "
"for two inputs. The data is replaced by ranks.  Ties are averaged so that "
"equal values receive the same rank.  The resulting coefficient measures the "
"strength of a monotonic relationship."
msgstr ""
"Om *method* är \"ranked\", beräknas `Spearmans rangkorrelationskoefficient "
"<https://en.wikipedia.org/wiki/Spearman%27s_rank_correlation_coefficient>`_ "
"för två indata. Data ersätts av rangordningar.  Oavgjorda värden får ett "
"genomsnitt så att lika värden får samma rangordning.  Den resulterande "
"koefficienten mäter styrkan i ett monotont förhållande."

#: ../../library/statistics.rst:755
msgid ""
"Spearman's correlation coefficient is appropriate for ordinal data or for "
"continuous data that doesn't meet the linear proportion requirement for "
"Pearson's correlation coefficient."
msgstr ""
"Spearmans korrelationskoefficient är lämplig för ordinaldata eller för "
"kontinuerliga data som inte uppfyller kravet på linjär proportion för "
"Pearsons korrelationskoefficient."

#: ../../library/statistics.rst:759
msgid ""
"Both inputs must be of the same length (no less than two), and need not to "
"be constant, otherwise :exc:`StatisticsError` is raised."
msgstr ""
"Båda indata måste vara lika långa (minst två), och behöver inte vara "
"konstanta, annars :exc:`StatisticsError` tas upp."

#: ../../library/statistics.rst:762
msgid ""
"Example with `Kepler's laws of planetary motion <https://en.wikipedia.org/"
"wiki/Kepler's_laws_of_planetary_motion>`_:"
msgstr ""
"Exempel med `Kepler's lagar för planetrörelse <https://en.wikipedia.org/wiki/"
"Kepler's_laws_of_planetary_motion>`_:"

#: ../../library/statistics.rst:765
msgid ""
">>> # Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, and  Neptune\n"
">>> orbital_period = [88, 225, 365, 687, 4331, 10_756, 30_687, 60_190]    # "
"days\n"
">>> dist_from_sun = [58, 108, 150, 228, 778, 1_400, 2_900, 4_500] # million "
"km\n"
"\n"
">>> # Show that a perfect monotonic relationship exists\n"
">>> correlation(orbital_period, dist_from_sun, method='ranked')\n"
"1.0\n"
"\n"
">>> # Observe that a linear relationship is imperfect\n"
">>> round(correlation(orbital_period, dist_from_sun), 4)\n"
"0.9882\n"
"\n"
">>> # Demonstrate Kepler's third law: There is a linear correlation\n"
">>> # between the square of the orbital period and the cube of the\n"
">>> # distance from the sun.\n"
">>> period_squared = [p * p for p in orbital_period]\n"
">>> dist_cubed = [d * d * d for d in dist_from_sun]\n"
">>> round(correlation(period_squared, dist_cubed), 4)\n"
"1.0"
msgstr ""
">>> # Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, and  Neptune\n"
">>> orbital_period = [88, 225, 365, 687, 4331, 10_756, 30_687, 60_190]    # "
"days\n"
">>> dist_from_sun = [58, 108, 150, 228, 778, 1_400, 2_900, 4_500] # million "
"km\n"
"\n"
">>> # Show that a perfect monotonic relationship exists\n"
">>> correlation(orbital_period, dist_from_sun, method='ranked')\n"
"1.0\n"
"\n"
">>> # Observe that a linear relationship is imperfect\n"
">>> round(correlation(orbital_period, dist_from_sun), 4)\n"
"0.9882\n"
"\n"
">>> # Demonstrate Kepler's third law: There is a linear correlation\n"
">>> # between the square of the orbital period and the cube of the\n"
">>> # distance from the sun.\n"
">>> period_squared = [p * p for p in orbital_period]\n"
">>> dist_cubed = [d * d * d for d in dist_from_sun]\n"
">>> round(correlation(period_squared, dist_cubed), 4)\n"
"1.0"

#: ../../library/statistics.rst:789
msgid "Added support for Spearman's rank correlation coefficient."
msgstr "Stöd för Spearmans rangkorrelationskoefficient har lagts till."

#: ../../library/statistics.rst:794
msgid ""
"Return the slope and intercept of `simple linear regression <https://"
"en.wikipedia.org/wiki/Simple_linear_regression>`_ parameters estimated using "
"ordinary least squares. Simple linear regression describes the relationship "
"between an independent variable *x* and a dependent variable *y* in terms of "
"this linear function:"
msgstr ""
"Returnerar lutningen och interceptet för `parametrar för enkel linjär "
"regression <https://en.wikipedia.org/wiki/Simple_linear_regression>`_ som "
"uppskattats med hjälp av vanliga minsta kvadratmetoden. Enkel linjär "
"regression beskriver förhållandet mellan en oberoende variabel *x* och en "
"beroende variabel *y* i termer av denna linjära funktion:"

#: ../../library/statistics.rst:800
msgid "*y = slope \\* x + intercept + noise*"
msgstr "*y = lutning \\* x + intercept + brus*"

#: ../../library/statistics.rst:802
msgid ""
"where ``slope`` and ``intercept`` are the regression parameters that are "
"estimated, and ``noise`` represents the variability of the data that was not "
"explained by the linear regression (it is equal to the difference between "
"predicted and actual values of the dependent variable)."
msgstr ""
"där ``slope`` och ``intercept`` är de regressionsparametrar som uppskattas, "
"och ``noise`` representerar variationen i data som inte förklaras av den "
"linjära regressionen (det är lika med skillnaden mellan förutsagda och "
"faktiska värden för den beroende variabeln)."

#: ../../library/statistics.rst:808
msgid ""
"Both inputs must be of the same length (no less than two), and the "
"independent variable *x* cannot be constant; otherwise "
"a :exc:`StatisticsError` is raised."
msgstr ""
"Båda indata måste vara lika långa (minst två) och den oberoende variabeln "
"*x* får inte vara konstant, annars uppstår ett :exc:`StatisticsError`."

#: ../../library/statistics.rst:812
msgid ""
"For example, we can use the `release dates of the Monty Python films "
"<https://en.wikipedia.org/wiki/Monty_Python#Films>`_ to predict the "
"cumulative number of Monty Python films that would have been produced by "
"2019 assuming that they had kept the pace."
msgstr ""
"Vi kan till exempel använda `premiärdatum för Monty Python-filmerna <https://"
"en.wikipedia.org/wiki/Monty_Python#Films>`_\" för att förutsäga det "
"kumulativa antalet Monty Python-filmer som skulle ha producerats fram till "
"2019, förutsatt att de hade hållit samma takt."

#: ../../library/statistics.rst:818
msgid ""
">>> year = [1971, 1975, 1979, 1982, 1983]\n"
">>> films_total = [1, 2, 3, 4, 5]\n"
">>> slope, intercept = linear_regression(year, films_total)\n"
">>> round(slope * 2019 + intercept)\n"
"16"
msgstr ""
">>> year = [1971, 1975, 1979, 1982, 1983]\n"
">>> films_total = [1, 2, 3, 4, 5]\n"
">>> slope, intercept = linear_regression(year, films_total)\n"
">>> round(slope * 2019 + intercept)\n"
"16"

#: ../../library/statistics.rst:826
msgid ""
"If *proportional* is true, the independent variable *x* and the dependent "
"variable *y* are assumed to be directly proportional. The data is fit to a "
"line passing through the origin. Since the *intercept* will always be 0.0, "
"the underlying linear function simplifies to:"
msgstr ""
"Om *proportional* är sant antas den oberoende variabeln *x* och den beroende "
"variabeln *y* vara direkt proportionella. Data anpassas till en linje som "
"går genom origo. Eftersom *skärningspunkten* alltid kommer att vara 0,0 "
"förenklas den underliggande linjära funktionen till:"

#: ../../library/statistics.rst:832
msgid "*y = slope \\* x + noise*"
msgstr "*y = lutning \\* x + brus*"

#: ../../library/statistics.rst:834
msgid ""
"Continuing the example from :func:`correlation`, we look to see how well a "
"model based on major planets can predict the orbital distances for dwarf "
"planets:"
msgstr ""
"Vi fortsätter med exemplet från :func:`correlation` och undersöker hur väl "
"en modell som baseras på större planeter kan förutsäga omloppsavståndet för "
"dvärgplaneter:"

#: ../../library/statistics.rst:838
msgid ""
">>> model = linear_regression(period_squared, dist_cubed, "
"proportional=True)\n"
">>> slope = model.slope\n"
"\n"
">>> # Dwarf planets:   Pluto,  Eris,    Makemake, Haumea, Ceres\n"
">>> orbital_periods = [90_560, 204_199, 111_845, 103_410, 1_680]  # days\n"
">>> predicted_dist = [math.cbrt(slope * (p * p)) for p in orbital_periods]\n"
">>> list(map(round, predicted_dist))\n"
"[5912, 10166, 6806, 6459, 414]\n"
"\n"
">>> [5_906, 10_152, 6_796, 6_450, 414]  # actual distance in million km\n"
"[5906, 10152, 6796, 6450, 414]"
msgstr ""
">>> model = linear_regression(period_squared, dist_cubed, "
"proportional=True)\n"
">>> slope = model.slope\n"
"\n"
">>> # Dwarf planets:   Pluto,  Eris,    Makemake, Haumea, Ceres\n"
">>> orbital_periods = [90_560, 204_199, 111_845, 103_410, 1_680]  # days\n"
">>> predicted_dist = [math.cbrt(slope * (p * p)) for p in orbital_periods]\n"
">>> list(map(round, predicted_dist))\n"
"[5912, 10166, 6806, 6459, 414]\n"
"\n"
">>> [5_906, 10_152, 6_796, 6_450, 414]  # actual distance in million km\n"
"[5906, 10152, 6796, 6450, 414]"

#: ../../library/statistics.rst:854
msgid "Added support for *proportional*."
msgstr "Stöd för *proportionell* har lagts till."

#: ../../library/statistics.rst:858
msgid "Exceptions"
msgstr "Undantag"

#: ../../library/statistics.rst:860
msgid "A single exception is defined:"
msgstr "Ett enda undantag definieras:"

#: ../../library/statistics.rst:864
msgid "Subclass of :exc:`ValueError` for statistics-related exceptions."
msgstr "Underklass till :exc:`ValueError` för statistikrelaterade undantag."

#: ../../library/statistics.rst:868
msgid ":class:`NormalDist` objects"
msgstr ":class:`NormalDist` objekt"

#: ../../library/statistics.rst:870
msgid ""
":class:`NormalDist` is a tool for creating and manipulating normal "
"distributions of a `random variable <http://www.stat.yale.edu/Courses/"
"1997-98/101/ranvar.htm>`_.  It is a class that treats the mean and standard "
"deviation of data measurements as a single entity."
msgstr ""
":class:`NormalDist` är ett verktyg för att skapa och manipulera "
"normalfördelningar av en `slumpmässig variabel <http://www.stat.yale.edu/"
"Courses/1997-98/101/ranvar.htm>`_.  Det är en klass som behandlar "
"medelvärdet och standardavvikelsen för datamätningar som en enda enhet."

#: ../../library/statistics.rst:876
msgid ""
"Normal distributions arise from the `Central Limit Theorem <https://"
"en.wikipedia.org/wiki/Central_limit_theorem>`_ and have a wide range of "
"applications in statistics."
msgstr ""
"Normalfördelningar härrör från `Central Limit Theorem <https://"
"en.wikipedia.org/wiki/Central_limit_theorem>`_ och har ett brett spektrum av "
"tillämpningar inom statistik."

#: ../../library/statistics.rst:882
msgid ""
"Returns a new *NormalDist* object where *mu* represents the `arithmetic mean "
"<https://en.wikipedia.org/wiki/Arithmetic_mean>`_ and *sigma* represents the "
"`standard deviation <https://en.wikipedia.org/wiki/Standard_deviation>`_."
msgstr ""
"Returnerar ett nytt *NormalDist*-objekt där *mu* representerar det "
"`aritmetiska medelvärdet <https://en.wikipedia.org/wiki/Arithmetic_mean>`_ "
"och *sigma* representerar `standardavvikelsen <https://en.wikipedia.org/wiki/"
"Standard_deviation>`_."

#: ../../library/statistics.rst:887
msgid "If *sigma* is negative, raises :exc:`StatisticsError`."
msgstr "Om *sigma* är negativ, uppstår :exc:`StatisticsError`."

#: ../../library/statistics.rst:891
msgid ""
"A read-only property for the `arithmetic mean <https://en.wikipedia.org/wiki/"
"Arithmetic_mean>`_ of a normal distribution."
msgstr ""
"En skrivskyddad egenskap för det `aritmetiska medelvärdet <https://"
"en.wikipedia.org/wiki/Arithmetic_mean>`_ för en normalfördelning."

#: ../../library/statistics.rst:897
msgid ""
"A read-only property for the `median <https://en.wikipedia.org/wiki/"
"Median>`_ of a normal distribution."
msgstr ""
"En skrivskyddad egenskap för `median <https://en.wikipedia.org/wiki/"
"Median>`_ för en normalfördelning."

#: ../../library/statistics.rst:903
msgid ""
"A read-only property for the `mode <https://en.wikipedia.org/wiki/"
"Mode_(statistics)>`_ of a normal distribution."
msgstr ""
"En skrivskyddad egenskap för `mode <https://en.wikipedia.org/wiki/"
"Mode_(statistics)>`_ för en normalfördelning."

#: ../../library/statistics.rst:909
msgid ""
"A read-only property for the `standard deviation <https://en.wikipedia.org/"
"wiki/Standard_deviation>`_ of a normal distribution."
msgstr ""
"En skrivskyddad egenskap för `standardavvikelsen <https://en.wikipedia.org/"
"wiki/Standard_deviation>`_ för en normalfördelning."

#: ../../library/statistics.rst:915
msgid ""
"A read-only property for the `variance <https://en.wikipedia.org/wiki/"
"Variance>`_ of a normal distribution. Equal to the square of the standard "
"deviation."
msgstr ""
"En skrivskyddad egenskap för `variansen <https://en.wikipedia.org/wiki/"
"Variance>`_ i en normalfördelning. Lika med kvadraten på standardavvikelsen."

#: ../../library/statistics.rst:921
msgid ""
"Makes a normal distribution instance with *mu* and *sigma* parameters "
"estimated from the *data* using :func:`fmean` and :func:`stdev`."
msgstr ""
"Skapar en normalfördelningsinstans med parametrarna *mu* och *sigma* "
"uppskattade från *data* med hjälp av :func:`fmean` och :func:`stdev`."

#: ../../library/statistics.rst:924
msgid ""
"The *data* can be any :term:`iterable` and should consist of values that can "
"be converted to type :class:`float`.  If *data* does not contain at least "
"two elements, raises :exc:`StatisticsError` because it takes at least one "
"point to estimate a central value and at least two points to estimate "
"dispersion."
msgstr ""
"*data* kan vara valfri :term:`iterable` och bör bestå av värden som kan "
"konverteras till typen :class:`float`.  Om *data* inte innehåller minst två "
"element, uppstår :exc:`StatisticsError` eftersom det krävs minst en punkt "
"för att skatta ett centralt värde och minst två punkter för att skatta "
"spridningen."

#: ../../library/statistics.rst:932
msgid ""
"Generates *n* random samples for a given mean and standard deviation. "
"Returns a :class:`list` of :class:`float` values."
msgstr ""
"Genererar *n* slumpmässiga stickprov för ett givet medelvärde och "
"standardavvikelse. Returnerar en :class:`list` av :class:`float`\\-värden."

#: ../../library/statistics.rst:935
msgid ""
"If *seed* is given, creates a new instance of the underlying random number "
"generator.  This is useful for creating reproducible results, even in a "
"multi-threading context."
msgstr ""
"Om *seed* anges skapas en ny instans av den underliggande "
"slumptalsgeneratorn.  Detta är användbart för att skapa reproducerbara "
"resultat, även i ett sammanhang med flera trådar."

#: ../../library/statistics.rst:941
msgid ""
"Switched to a faster algorithm.  To reproduce samples from previous "
"versions, use :func:`random.seed` and :func:`random.gauss`."
msgstr ""
"Bytte till en snabbare algoritm.  För att återskapa exempel från tidigare "
"versioner, använd :func:`random.seed` och :func:`random.gauss`."

#: ../../library/statistics.rst:946
msgid ""
"Using a `probability density function (pdf) <https://en.wikipedia.org/wiki/"
"Probability_density_function>`_, compute the relative likelihood that a "
"random variable *X* will be near the given value *x*.  Mathematically, it is "
"the limit of the ratio ``P(x <= X < x+dx) / dx`` as *dx* approaches zero."
msgstr ""
"Med hjälp av en `sannolikhetstäthetsfunktion (pdf) <https://en.wikipedia.org/"
"wiki/Probability_density_function>`_, beräkna den relativa sannolikheten för "
"att en slumpmässig variabel *X* kommer att ligga nära det givna värdet *x*.  "
"Matematiskt sett är det gränsen för förhållandet ``P(x <= X < x+dx) / dx`` "
"när *dx* närmar sig noll."

#: ../../library/statistics.rst:952
msgid ""
"The relative likelihood is computed as the probability of a sample occurring "
"in a narrow range divided by the width of the range (hence the word "
"\"density\").  Since the likelihood is relative to other points, its value "
"can be greater than ``1.0``."
msgstr ""
"Den relativa sannolikheten beräknas som sannolikheten för att ett prov "
"förekommer inom ett smalt område dividerat med områdets bredd (därav ordet "
"\"densitet\").  Eftersom sannolikheten är relativ i förhållande till andra "
"punkter kan dess värde vara större än \"1,0\"."

#: ../../library/statistics.rst:959
msgid ""
"Using a `cumulative distribution function (cdf) <https://en.wikipedia.org/"
"wiki/Cumulative_distribution_function>`_, compute the probability that a "
"random variable *X* will be less than or equal to *x*.  Mathematically, it "
"is written ``P(X <= x)``."
msgstr ""
"Med hjälp av en `cumulative distribution function (cdf) <https://"
"en.wikipedia.org/wiki/Cumulative_distribution_function>`_, beräkna "
"sannolikheten för att en slumpmässig variabel *X* kommer att vara mindre än "
"eller lika med *x*.  Matematiskt skrivs det ``P(X <= x)``."

#: ../../library/statistics.rst:966
msgid ""
"Compute the inverse cumulative distribution function, also known as the "
"`quantile function <https://en.wikipedia.org/wiki/Quantile_function>`_ or "
"the `percent-point <https://web.archive.org/web/20190203145224/https://"
"www.statisticshowto.datasciencecentral.com/inverse-distribution-function/>`_ "
"function.  Mathematically, it is written ``x : P(X <= x) = p``."
msgstr ""
"Beräkna den inversa kumulativa fördelningsfunktionen, även känd som "
"`kvantielfunktionen <https://en.wikipedia.org/wiki/Quantile_function>`_ "
"eller `procentpunktsfunktionen <https://web.archive.org/web/20190203145224/"
"https://www.statisticshowto.datasciencecentral.com/inverse-distribution-"
"function/>`_.  Matematiskt skrivs den ``x : P(X <= x) = p``."

#: ../../library/statistics.rst:972
msgid ""
"Finds the value *x* of the random variable *X* such that the probability of "
"the variable being less than or equal to that value equals the given "
"probability *p*."
msgstr ""
"Tar reda på värdet *x* för den slumpmässiga variabeln *X* så att "
"sannolikheten för att variabeln är mindre än eller lika med detta värde är "
"lika med den givna sannolikheten *p*."

#: ../../library/statistics.rst:978
msgid ""
"Measures the agreement between two normal probability distributions. Returns "
"a value between 0.0 and 1.0 giving `the overlapping area for the two "
"probability density functions <https://www.rasch.org/rmt/rmt101r.htm>`_."
msgstr ""
"Mäter överensstämmelsen mellan två normala sannolikhetsfördelningar. "
"Returnerar ett värde mellan 0,0 och 1,0 som anger `överlappningsområdet för "
"de två sannolikhetstäthetsfunktionerna <https://www.rasch.org/rmt/"
"rmt101r.htm>`_."

#: ../../library/statistics.rst:985
msgid ""
"Divide the normal distribution into *n* continuous intervals with equal "
"probability.  Returns a list of (n - 1) cut points separating the intervals."
msgstr ""
"Dela upp normalfördelningen i *n* kontinuerliga intervall med samma "
"sannolikhet.  Returnerar en lista med (n - 1) skärningspunkter som separerar "
"intervallen."

#: ../../library/statistics.rst:989
msgid ""
"Set *n* to 4 for quartiles (the default).  Set *n* to 10 for deciles. Set "
"*n* to 100 for percentiles which gives the 99 cuts points that separate the "
"normal distribution into 100 equal sized groups."
msgstr ""
"Ställ in *n* på 4 för kvartiler (standard).  Ställ in *n* till 10 för "
"deciler. Ställ in *n* på 100 för percentiler, vilket ger de 99 "
"skärningspunkter som delar upp normalfördelningen i 100 lika stora grupper."

#: ../../library/statistics.rst:995
msgid ""
"Compute the `Standard Score <https://www.statisticshowto.com/probability-and-"
"statistics/z-score/>`_ describing *x* in terms of the number of standard "
"deviations above or below the mean of the normal distribution: ``(x - "
"mean) / stdev``."
msgstr ""
"Beräkna `Standardpoäng <https://www.statisticshowto.com/probability-and-"
"statistics/z-score/>`_ som beskriver *x* i termer av antalet "
"standardavvikelser över eller under normalfördelningens medelvärde: ``(x - "
"mean) / stdev``."

#: ../../library/statistics.rst:1003
msgid ""
"Instances of :class:`NormalDist` support addition, subtraction, "
"multiplication and division by a constant.  These operations are used for "
"translation and scaling.  For example:"
msgstr ""
"Instanser av :class:`NormalDist` stöder addition, subtraktion, "
"multiplikation och division med en konstant.  Dessa operationer används för "
"översättning och skalning.  Ett exempel:"

#: ../../library/statistics.rst:1007
msgid ""
">>> temperature_february = NormalDist(5, 2.5)             # Celsius\n"
">>> temperature_february * (9/5) + 32                     # Fahrenheit\n"
"NormalDist(mu=41.0, sigma=4.5)"
msgstr ""
">>> temperature_february = NormalDist(5, 2.5)             # Celsius\n"
">>> temperature_february * (9/5) + 32                     # Fahrenheit\n"
"NormalDist(mu=41.0, sigma=4.5)"

#: ../../library/statistics.rst:1013
msgid ""
"Dividing a constant by an instance of :class:`NormalDist` is not supported "
"because the result wouldn't be normally distributed."
msgstr ""
"Att dividera en konstant med en instans av :class:`NormalDist` stöds inte "
"eftersom resultatet inte skulle vara normalfördelat."

#: ../../library/statistics.rst:1016
msgid ""
"Since normal distributions arise from additive effects of independent "
"variables, it is possible to `add and subtract two independent normally "
"distributed random variables <https://en.wikipedia.org/wiki/"
"Sum_of_normally_distributed_random_variables>`_ represented as instances "
"of :class:`NormalDist`.  For example:"
msgstr ""
"Eftersom normalfördelningar uppstår genom additiva effekter av oberoende "
"variabler, är det möjligt att `addera och subtrahera två oberoende "
"normalfördelade slumpmässiga variabler <https://en.wikipedia.org/wiki/"
"Sum_of_normally_distributed_random_variables>`_ representerade som instanser "
"av :class:`NormalDist`.  Till exempel:"

#: ../../library/statistics.rst:1022
msgid ""
">>> birth_weights = NormalDist.from_samples([2.5, 3.1, 2.1, 2.4, 2.7, 3.5])\n"
">>> drug_effects = NormalDist(0.4, 0.15)\n"
">>> combined = birth_weights + drug_effects\n"
">>> round(combined.mean, 1)\n"
"3.1\n"
">>> round(combined.stdev, 1)\n"
"0.5"
msgstr ""
">>> birth_weights = NormalDist.from_samples([2.5, 3.1, 2.1, 2.4, 2.7, 3.5])\n"
">>> drug_effects = NormalDist(0.4, 0.15)\n"
">>> combined = birth_weights + drug_effects\n"
">>> round(combined.mean, 1)\n"
"3.1\n"
">>> round(combined.stdev, 1)\n"
"0.5"

#: ../../library/statistics.rst:1036
msgid "Examples and Recipes"
msgstr "Exempel och recept"

#: ../../library/statistics.rst:1040
msgid "Classic probability problems"
msgstr "Klassiska sannolikhetsproblem"

#: ../../library/statistics.rst:1042
msgid ":class:`NormalDist` readily solves classic probability problems."
msgstr ":class:`NormalDist` löser enkelt klassiska sannolikhetsproblem."

#: ../../library/statistics.rst:1044
msgid ""
"For example, given `historical data for SAT exams <https://nces.ed.gov/"
"programs/digest/d17/tables/dt17_226.40.asp>`_ showing that scores are "
"normally distributed with a mean of 1060 and a standard deviation of 195, "
"determine the percentage of students with test scores between 1100 and 1200, "
"after rounding to the nearest whole number:"
msgstr ""
"Om du till exempel har `historiska data för SAT-prov <https://nces.ed.gov/"
"programs/digest/d17/tables/dt17_226.40.asp>`_ som visar att resultaten är "
"normalfördelade med ett medelvärde på 1060 och en standardavvikelse på 195, "
"kan du bestämma andelen elever med provresultat mellan 1100 och 1200, efter "
"avrundning till närmaste heltal:"

#: ../../library/statistics.rst:1050
msgid ""
">>> sat = NormalDist(1060, 195)\n"
">>> fraction = sat.cdf(1200 + 0.5) - sat.cdf(1100 - 0.5)\n"
">>> round(fraction * 100.0, 1)\n"
"18.4"
msgstr ""
">>> sat = NormalDist(1060, 195)\n"
">>> fraction = sat.cdf(1200 + 0.5) - sat.cdf(1100 - 0.5)\n"
">>> round(fraction * 100.0, 1)\n"
"18.4"

#: ../../library/statistics.rst:1057
msgid ""
"Find the `quartiles <https://en.wikipedia.org/wiki/Quartile>`_ and `deciles "
"<https://en.wikipedia.org/wiki/Decile>`_ for the SAT scores:"
msgstr ""
"Hitta `kvartilerna <https://en.wikipedia.org/wiki/Quartile>`_ och `decilerna "
"<https://en.wikipedia.org/wiki/Decile>`_ för SAT-poängen:"

#: ../../library/statistics.rst:1060
msgid ""
">>> list(map(round, sat.quantiles()))\n"
"[928, 1060, 1192]\n"
">>> list(map(round, sat.quantiles(n=10)))\n"
"[810, 896, 958, 1011, 1060, 1109, 1162, 1224, 1310]"
msgstr ""
">>> list(map(round, sat.quantiles()))\n"
"[928, 1060, 1192]\n"
">>> list(map(round, sat.quantiles(n=10)))\n"
"[810, 896, 958, 1011, 1060, 1109, 1162, 1224, 1310]"

#: ../../library/statistics.rst:1069
msgid "Monte Carlo inputs for simulations"
msgstr "Monte Carlo-ingångar för simuleringar"

#: ../../library/statistics.rst:1071
msgid ""
"To estimate the distribution for a model that isn't easy to solve "
"analytically, :class:`NormalDist` can generate input samples for a `Monte "
"Carlo simulation <https://en.wikipedia.org/wiki/Monte_Carlo_method>`_:"
msgstr ""
"För att uppskatta fördelningen för en modell som inte är lätt att lösa "
"analytiskt kan :class:`NormalDist` generera indataprov för en `Monte Carlo-"
"simulering <https://en.wikipedia.org/wiki/Monte_Carlo_method>`_:"

#: ../../library/statistics.rst:1075
msgid ""
">>> def model(x, y, z):\n"
"...     return (3*x + 7*x*y - 5*y) / (11 * z)\n"
"...\n"
">>> n = 100_000\n"
">>> X = NormalDist(10, 2.5).samples(n, seed=3652260728)\n"
">>> Y = NormalDist(15, 1.75).samples(n, seed=4582495471)\n"
">>> Z = NormalDist(50, 1.25).samples(n, seed=6582483453)\n"
">>> quantiles(map(model, X, Y, Z))\n"
"[1.4591308524824727, 1.8035946855390597, 2.175091447274739]"
msgstr ""
">>> def model(x, y, z):\n"
"...     return (3*x + 7*x*y - 5*y) / (11 * z)\n"
"...\n"
">>> n = 100_000\n"
">>> X = NormalDist(10, 2.5).samples(n, seed=3652260728)\n"
">>> Y = NormalDist(15, 1.75).samples(n, seed=4582495471)\n"
">>> Z = NormalDist(50, 1.25).samples(n, seed=6582483453)\n"
">>> quantiles(map(model, X, Y, Z))\n"
"[1.4591308524824727, 1.8035946855390597, 2.175091447274739]"

#: ../../library/statistics.rst:1088
msgid "Approximating binomial distributions"
msgstr "Approximation av binomialfördelningar"

#: ../../library/statistics.rst:1090
msgid ""
"Normal distributions can be used to approximate `Binomial distributions "
"<https://mathworld.wolfram.com/BinomialDistribution.html>`_ when the sample "
"size is large and when the probability of a successful trial is near 50%."
msgstr ""
"Normalfördelningar kan användas för att approximera `binomialfördelningar "
"<https://mathworld.wolfram.com/BinomialDistribution.html>`_ när "
"urvalsstorleken är stor och när sannolikheten för ett lyckat försök är nära "
"50%."

#: ../../library/statistics.rst:1095
msgid ""
"For example, an open source conference has 750 attendees and two rooms with "
"a 500 person capacity.  There is a talk about Python and another about Ruby. "
"In previous conferences, 65% of the attendees preferred to listen to Python "
"talks.  Assuming the population preferences haven't changed, what is the "
"probability that the Python room will stay within its capacity limits?"
msgstr ""
"Till exempel har en konferens om öppen källkod 750 deltagare och två rum med "
"en kapacitet på 500 personer.  Det finns ett föredrag om Python och ett "
"annat om Ruby. Vid tidigare konferenser föredrog 65% of av deltagarna att "
"lyssna på Python-samtal.  Om vi antar att deltagarnas preferenser inte har "
"ändrats, hur stor är sannolikheten att Python-rummet håller sig inom "
"kapacitetsgränserna?"

#: ../../library/statistics.rst:1101
msgid ""
">>> n = 750             # Sample size\n"
">>> p = 0.65            # Preference for Python\n"
">>> q = 1.0 - p         # Preference for Ruby\n"
">>> k = 500             # Room capacity\n"
"\n"
">>> # Approximation using the cumulative normal distribution\n"
">>> from math import sqrt\n"
">>> round(NormalDist(mu=n*p, sigma=sqrt(n*p*q)).cdf(k + 0.5), 4)\n"
"0.8402\n"
"\n"
">>> # Exact solution using the cumulative binomial distribution\n"
">>> from math import comb, fsum\n"
">>> round(fsum(comb(n, r) * p**r * q**(n-r) for r in range(k+1)), 4)\n"
"0.8402\n"
"\n"
">>> # Approximation using a simulation\n"
">>> from random import seed, binomialvariate\n"
">>> seed(8675309)\n"
">>> mean(binomialvariate(n, p) <= k for i in range(10_000))\n"
"0.8406"
msgstr ""
">>> n = 750             # Sample size\n"
">>> p = 0.65            # Preference for Python\n"
">>> q = 1.0 - p         # Preference for Ruby\n"
">>> k = 500             # Room capacity\n"
"\n"
">>> # Approximation using the cumulative normal distribution\n"
">>> from math import sqrt\n"
">>> round(NormalDist(mu=n*p, sigma=sqrt(n*p*q)).cdf(k + 0.5), 4)\n"
"0.8402\n"
"\n"
">>> # Exact solution using the cumulative binomial distribution\n"
">>> from math import comb, fsum\n"
">>> round(fsum(comb(n, r) * p**r * q**(n-r) for r in range(k+1)), 4)\n"
"0.8402\n"
"\n"
">>> # Approximation using a simulation\n"
">>> from random import seed, binomialvariate\n"
">>> seed(8675309)\n"
">>> mean(binomialvariate(n, p) <= k for i in range(10_000))\n"
"0.8406"

#: ../../library/statistics.rst:1126
msgid "Naive bayesian classifier"
msgstr "Naiv bayesiansk klassificerare"

#: ../../library/statistics.rst:1128
msgid "Normal distributions commonly arise in machine learning problems."
msgstr "Normalfördelningar är vanligt förekommande i maskininlärningsproblem."

#: ../../library/statistics.rst:1130
msgid ""
"Wikipedia has a `nice example of a Naive Bayesian Classifier <https://"
"en.wikipedia.org/wiki/Naive_Bayes_classifier#Person_classification>`_. The "
"challenge is to predict a person's gender from measurements of normally "
"distributed features including height, weight, and foot size."
msgstr ""
"Wikipedia har ett `trevligt exempel på en Naive Bayesian Classifier <https://"
"en.wikipedia.org/wiki/Naive_Bayes_classifier#Person_classification>`_. "
"Utmaningen är att förutsäga en persons kön från mätningar av normalfördelade "
"egenskaper, inklusive längd, vikt och fotstorlek."

#: ../../library/statistics.rst:1135
msgid ""
"We're given a training dataset with measurements for eight people.  The "
"measurements are assumed to be normally distributed, so we summarize the "
"data with :class:`NormalDist`:"
msgstr ""
"Vi får en träningsdatauppsättning med mätningar för åtta personer.  Måtten "
"antas vara normalfördelade, så vi sammanfattar data med :class:`NormalDist`:"

#: ../../library/statistics.rst:1139
msgid ""
">>> height_male = NormalDist.from_samples([6, 5.92, 5.58, 5.92])\n"
">>> height_female = NormalDist.from_samples([5, 5.5, 5.42, 5.75])\n"
">>> weight_male = NormalDist.from_samples([180, 190, 170, 165])\n"
">>> weight_female = NormalDist.from_samples([100, 150, 130, 150])\n"
">>> foot_size_male = NormalDist.from_samples([12, 11, 12, 10])\n"
">>> foot_size_female = NormalDist.from_samples([6, 8, 7, 9])"
msgstr ""
">>> height_male = NormalDist.from_samples([6, 5.92, 5.58, 5.92])\n"
">>> height_female = NormalDist.from_samples([5, 5.5, 5.42, 5.75])\n"
">>> weight_male = NormalDist.from_samples([180, 190, 170, 165])\n"
">>> weight_female = NormalDist.from_samples([100, 150, 130, 150])\n"
">>> foot_size_male = NormalDist.from_samples([12, 11, 12, 10])\n"
">>> foot_size_female = NormalDist.from_samples([6, 8, 7, 9])"

#: ../../library/statistics.rst:1148
msgid ""
"Next, we encounter a new person whose feature measurements are known but "
"whose gender is unknown:"
msgstr ""
"Därefter möter vi en ny person vars funktionsmätningar är kända men vars kön "
"är okänt:"

#: ../../library/statistics.rst:1151
msgid ""
">>> ht = 6.0        # height\n"
">>> wt = 130        # weight\n"
">>> fs = 8          # foot size"
msgstr ""
">>> ht = 6.0        # height\n"
">>> wt = 130        # weight\n"
">>> fs = 8          # foot size"

#: ../../library/statistics.rst:1157
msgid ""
"Starting with a 50% `prior probability <https://en.wikipedia.org/wiki/"
"Prior_probability>`_ of being male or female, we compute the posterior as "
"the prior times the product of likelihoods for the feature measurements "
"given the gender:"
msgstr ""
"Med utgångspunkt från en 50% `prior sannolikhet <https://en.wikipedia.org/"
"wiki/Prior_probability>`_ för att vara man eller kvinna, beräknar vi "
"posterior som prior gånger produkten av sannolikheter för "
"funktionsmätningarna med tanke på kön:"

#: ../../library/statistics.rst:1162
msgid ""
">>> prior_male = 0.5\n"
">>> prior_female = 0.5\n"
">>> posterior_male = (prior_male * height_male.pdf(ht) *\n"
"...                   weight_male.pdf(wt) * foot_size_male.pdf(fs))\n"
"\n"
">>> posterior_female = (prior_female * height_female.pdf(ht) *\n"
"...                     weight_female.pdf(wt) * foot_size_female.pdf(fs))"
msgstr ""
">>> prior_male = 0.5\n"
">>> prior_female = 0.5\n"
">>> posterior_male = (prior_male * height_male.pdf(ht) *\n"
"...                   weight_male.pdf(wt) * foot_size_male.pdf(fs))\n"
"\n"
">>> posterior_female = (prior_female * height_female.pdf(ht) *\n"
"...                     weight_female.pdf(wt) * foot_size_female.pdf(fs))"

#: ../../library/statistics.rst:1172
msgid ""
"The final prediction goes to the largest posterior. This is known as the "
"`maximum a posteriori <https://en.wikipedia.org/wiki/"
"Maximum_a_posteriori_estimation>`_ or MAP:"
msgstr ""
"Den slutliga prediktionen går till den största posterior. Detta kallas för "
"`maximal a posteriori <https://en.wikipedia.org/wiki/"
"Maximum_a_posteriori_estimation>`_ eller MAP:"

#: ../../library/statistics.rst:1176
msgid ""
">>> 'male' if posterior_male > posterior_female else 'female'\n"
"'female'"
msgstr ""
">>> 'male' if posterior_male > posterior_female else 'female'\n"
"'female'"
