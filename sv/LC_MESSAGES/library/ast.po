# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-05 14:23+0000\n"
"PO-Revision-Date: 2025-07-18 18:48+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../library/ast.rst:2
msgid ":mod:`!ast` --- Abstract syntax trees"
msgstr ":mod:`!ast` --- Abstrakta syntaxträd"

#: ../../library/ast.rst:14
msgid "**Source code:** :source:`Lib/ast.py`"
msgstr "**Källkod:** :source:`Lib/ast.py`"

#: ../../library/ast.rst:18
msgid ""
"The :mod:`ast` module helps Python applications to process trees of the "
"Python abstract syntax grammar.  The abstract syntax itself might change "
"with each Python release; this module helps to find out programmatically "
"what the current grammar looks like."
msgstr ""
"Modulen :mod:`ast` hjälper Python-program att bearbeta träd av Pythons "
"abstrakta syntaxgrammatik.  Den abstrakta syntaxen i sig kan ändras med "
"varje Python-version; den här modulen hjälper till att programmatiskt ta "
"reda på hur den aktuella grammatiken ser ut."

#: ../../library/ast.rst:23
msgid ""
"An abstract syntax tree can be generated by passing :data:`ast."
"PyCF_ONLY_AST` as a flag to the :func:`compile` built-in function, or using "
"the :func:`parse` helper provided in this module.  The result will be a tree "
"of objects whose classes all inherit from :class:`ast.AST`.  An abstract "
"syntax tree can be compiled into a Python code object using the built-in :"
"func:`compile` function."
msgstr ""
"Ett abstrakt syntaxträd kan genereras genom att skicka :data:`ast."
"PyCF_ONLY_AST` som en flagga till den inbyggda funktionen :func:`compile`, "
"eller genom att använda hjälpen :func:`parse` som finns i den här modulen.  "
"Resultatet blir ett träd av objekt vars klasser alla ärver från :class:`ast."
"AST`.  Ett abstrakt syntaxträd kan kompileras till ett Python-kodobjekt med "
"hjälp av den inbyggda funktionen :func:`compile`."

#: ../../library/ast.rst:33
msgid "Abstract grammar"
msgstr "Abstrakt grammatik"

#: ../../library/ast.rst:35
msgid "The abstract grammar is currently defined as follows:"
msgstr "Den abstrakta grammatiken definieras för närvarande på följande sätt:"

#: ../../library/ast.rst:37
msgid ""
"-- ASDL's 4 builtin types are:\n"
"-- identifier, int, string, constant\n"
"\n"
"module Python\n"
"{\n"
"    mod = Module(stmt* body, type_ignore* type_ignores)\n"
"        | Interactive(stmt* body)\n"
"        | Expression(expr body)\n"
"        | FunctionType(expr* argtypes, expr returns)\n"
"\n"
"    stmt = FunctionDef(identifier name, arguments args,\n"
"                       stmt* body, expr* decorator_list, expr? returns,\n"
"                       string? type_comment, type_param* type_params)\n"
"          | AsyncFunctionDef(identifier name, arguments args,\n"
"                             stmt* body, expr* decorator_list, expr? "
"returns,\n"
"                             string? type_comment, type_param* type_params)\n"
"\n"
"          | ClassDef(identifier name,\n"
"             expr* bases,\n"
"             keyword* keywords,\n"
"             stmt* body,\n"
"             expr* decorator_list,\n"
"             type_param* type_params)\n"
"          | Return(expr? value)\n"
"\n"
"          | Delete(expr* targets)\n"
"          | Assign(expr* targets, expr value, string? type_comment)\n"
"          | TypeAlias(expr name, type_param* type_params, expr value)\n"
"          | AugAssign(expr target, operator op, expr value)\n"
"          -- 'simple' indicates that we annotate simple name without parens\n"
"          | AnnAssign(expr target, expr annotation, expr? value, int "
"simple)\n"
"\n"
"          -- use 'orelse' because else is a keyword in target languages\n"
"          | For(expr target, expr iter, stmt* body, stmt* orelse, string? "
"type_comment)\n"
"          | AsyncFor(expr target, expr iter, stmt* body, stmt* orelse, "
"string? type_comment)\n"
"          | While(expr test, stmt* body, stmt* orelse)\n"
"          | If(expr test, stmt* body, stmt* orelse)\n"
"          | With(withitem* items, stmt* body, string? type_comment)\n"
"          | AsyncWith(withitem* items, stmt* body, string? type_comment)\n"
"\n"
"          | Match(expr subject, match_case* cases)\n"
"\n"
"          | Raise(expr? exc, expr? cause)\n"
"          | Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* "
"finalbody)\n"
"          | TryStar(stmt* body, excepthandler* handlers, stmt* orelse, stmt* "
"finalbody)\n"
"          | Assert(expr test, expr? msg)\n"
"\n"
"          | Import(alias* names)\n"
"          | ImportFrom(identifier? module, alias* names, int? level)\n"
"\n"
"          | Global(identifier* names)\n"
"          | Nonlocal(identifier* names)\n"
"          | Expr(expr value)\n"
"          | Pass | Break | Continue\n"
"\n"
"          -- col_offset is the byte offset in the utf8 string the parser "
"uses\n"
"          attributes (int lineno, int col_offset, int? end_lineno, int? "
"end_col_offset)\n"
"\n"
"          -- BoolOp() can use left & right?\n"
"    expr = BoolOp(boolop op, expr* values)\n"
"         | NamedExpr(expr target, expr value)\n"
"         | BinOp(expr left, operator op, expr right)\n"
"         | UnaryOp(unaryop op, expr operand)\n"
"         | Lambda(arguments args, expr body)\n"
"         | IfExp(expr test, expr body, expr orelse)\n"
"         | Dict(expr?* keys, expr* values)\n"
"         | Set(expr* elts)\n"
"         | ListComp(expr elt, comprehension* generators)\n"
"         | SetComp(expr elt, comprehension* generators)\n"
"         | DictComp(expr key, expr value, comprehension* generators)\n"
"         | GeneratorExp(expr elt, comprehension* generators)\n"
"         -- the grammar constrains where yield expressions can occur\n"
"         | Await(expr value)\n"
"         | Yield(expr? value)\n"
"         | YieldFrom(expr value)\n"
"         -- need sequences for compare to distinguish between\n"
"         -- x < 4 < 3 and (x < 4) < 3\n"
"         | Compare(expr left, cmpop* ops, expr* comparators)\n"
"         | Call(expr func, expr* args, keyword* keywords)\n"
"         | FormattedValue(expr value, int conversion, expr? format_spec)\n"
"         | Interpolation(expr value, constant str, int conversion, expr? "
"format_spec)\n"
"         | JoinedStr(expr* values)\n"
"         | TemplateStr(expr* values)\n"
"         | Constant(constant value, string? kind)\n"
"\n"
"         -- the following expression can appear in assignment context\n"
"         | Attribute(expr value, identifier attr, expr_context ctx)\n"
"         | Subscript(expr value, expr slice, expr_context ctx)\n"
"         | Starred(expr value, expr_context ctx)\n"
"         | Name(identifier id, expr_context ctx)\n"
"         | List(expr* elts, expr_context ctx)\n"
"         | Tuple(expr* elts, expr_context ctx)\n"
"\n"
"         -- can appear only in Subscript\n"
"         | Slice(expr? lower, expr? upper, expr? step)\n"
"\n"
"          -- col_offset is the byte offset in the utf8 string the parser "
"uses\n"
"          attributes (int lineno, int col_offset, int? end_lineno, int? "
"end_col_offset)\n"
"\n"
"    expr_context = Load | Store | Del\n"
"\n"
"    boolop = And | Or\n"
"\n"
"    operator = Add | Sub | Mult | MatMult | Div | Mod | Pow | LShift\n"
"                 | RShift | BitOr | BitXor | BitAnd | FloorDiv\n"
"\n"
"    unaryop = Invert | Not | UAdd | USub\n"
"\n"
"    cmpop = Eq | NotEq | Lt | LtE | Gt | GtE | Is | IsNot | In | NotIn\n"
"\n"
"    comprehension = (expr target, expr iter, expr* ifs, int is_async)\n"
"\n"
"    excepthandler = ExceptHandler(expr? type, identifier? name, stmt* body)\n"
"                    attributes (int lineno, int col_offset, int? end_lineno, "
"int? end_col_offset)\n"
"\n"
"    arguments = (arg* posonlyargs, arg* args, arg? vararg, arg* kwonlyargs,\n"
"                 expr* kw_defaults, arg? kwarg, expr* defaults)\n"
"\n"
"    arg = (identifier arg, expr? annotation, string? type_comment)\n"
"           attributes (int lineno, int col_offset, int? end_lineno, int? "
"end_col_offset)\n"
"\n"
"    -- keyword arguments supplied to call (NULL identifier for **kwargs)\n"
"    keyword = (identifier? arg, expr value)\n"
"               attributes (int lineno, int col_offset, int? end_lineno, int? "
"end_col_offset)\n"
"\n"
"    -- import name with optional 'as' alias.\n"
"    alias = (identifier name, identifier? asname)\n"
"             attributes (int lineno, int col_offset, int? end_lineno, int? "
"end_col_offset)\n"
"\n"
"    withitem = (expr context_expr, expr? optional_vars)\n"
"\n"
"    match_case = (pattern pattern, expr? guard, stmt* body)\n"
"\n"
"    pattern = MatchValue(expr value)\n"
"            | MatchSingleton(constant value)\n"
"            | MatchSequence(pattern* patterns)\n"
"            | MatchMapping(expr* keys, pattern* patterns, identifier? rest)\n"
"            | MatchClass(expr cls, pattern* patterns, identifier* kwd_attrs, "
"pattern* kwd_patterns)\n"
"\n"
"            | MatchStar(identifier? name)\n"
"            -- The optional \"rest\" MatchMapping parameter handles "
"capturing extra mapping keys\n"
"\n"
"            | MatchAs(pattern? pattern, identifier? name)\n"
"            | MatchOr(pattern* patterns)\n"
"\n"
"             attributes (int lineno, int col_offset, int end_lineno, int "
"end_col_offset)\n"
"\n"
"    type_ignore = TypeIgnore(int lineno, string tag)\n"
"\n"
"    type_param = TypeVar(identifier name, expr? bound, expr? default_value)\n"
"               | ParamSpec(identifier name, expr? default_value)\n"
"               | TypeVarTuple(identifier name, expr? default_value)\n"
"               attributes (int lineno, int col_offset, int end_lineno, int "
"end_col_offset)\n"
"}\n"
msgstr ""
"-- ASDL:s 4 inbyggda typer är:\n"
"-- identifierare, int, sträng, konstant\n"
"\n"
"modul Python\n"
"{\n"
"    mod = Modul(stmt* kropp, typ_ignore* typ_ignores)\n"
"        | Interaktiv(stmt* kropp)\n"
"        | Uttryck(expr kropp)\n"
"        | FunctionType(expr* argtypes, expr returns)\n"
"\n"
"    stmt = FunctionDef(identifierarnamn, argument args,\n"
"                       stmt* body, expr* decorator_list, expr? returns,\n"
"                       sträng? typ_kommentar, typ_param* typ_param)\n"
"          | AsyncFunctionDef(identifierare namn, argument args,\n"
"                             stmt* body, expr* decorator_list, expr? "
"returns,\n"
"                             sträng? typ_kommentar, typ_param* typ_param)\n"
"\n"
"          | ClassDef(identifierare namn,\n"
"             expr* baser,\n"
"             nyckelord* nyckelord,\n"
"             stmt* kropp,\n"
"             expr* dekorator_lista,\n"
"             typ_param* typ_param)\n"
"          | Return(expr? värde)\n"
"\n"
"          | Ta bort(expr* mål)\n"
"          | Assign(expr* mål, expr värde, sträng? typ_kommentar)\n"
"          | TypeAlias(expr-namn, typ_param* typ_param, expr-värde)\n"
"          | AugAssign(expr-mål, operator op, expr-värde)\n"
"          -- 'simple' anger att vi annoterar enkla namn utan parenteser\n"
"          | AnnAssign(expr mål, expr annotation, expr? värde, int simple)\n"
"\n"
"          -- använd 'orelse' eftersom else är ett nyckelord i målspråken\n"
"          | For(expr mål, expr iter, stmt* kropp, stmt* orelse, sträng? "
"typ_kommentar)\n"
"          | AsyncFor(expr mål, expr iter, stmt* kropp, stmt* orelse, sträng? "
"typ_kommentar)\n"
"          | While(expr test, stmt* body, stmt* orelse)\n"
"          | If(expr test, stmt* kropp, stmt* orelse)\n"
"          | With(medobjekt*objekt, stmt*kropp, sträng? typ_kommentar)\n"
"          | AsyncWith(med objekt* objekt, stmt* kropp, sträng? "
"typ_kommentar)\n"
"\n"
"          | Match(expr ämne, match_case* fall)\n"
"\n"
"          | Raise(expr? exc, expr? cause)\n"
"          | Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* "
"finalbody)\n"
"          | TryStar(stmt* body, excepthandler* handlers, stmt* orelse, stmt* "
"finalbody)\n"
"          | Assert(expr test, expr? msg)\n"
"\n"
"          | Import(alias* namn)\n"
"          | ImportFrom(identifierare? modul, alias* namn, int? nivå)\n"
"\n"
"          | Global(identifier* namn)\n"
"          | Icke-lokal(identifier* namn)\n"
"          | Expr(expr-värde)\n"
"          | Pass | Break | Continue\n"
"\n"
"          -- col_offset är byte-offset i den utf8-sträng som parsern "
"använder\n"
"          attribut (int lineno, int col_offset, int? end_lineno, int? "
"end_col_offset)\n"
"\n"
"          -- BoolOp() kan använda vänster & höger?\n"
"    expr = BoolOp(boolop op, expr* värden)\n"
"         | NamedExpr(expr mål, expr värde)\n"
"         | BinOp(expr vänster, operator op, expr höger)\n"
"         | UnaryOp(unaryop op, expr operand)\n"
"         | Lambda(argument args, expr kropp)\n"
"         | IfExp(expr test, expr kropp, expr orelse)\n"
"         | Dict(expr?* nycklar, expr* värden)\n"
"         | Set(expr* elts)\n"
"         | ListComp(expr elt, förståelse* generatorer)\n"
"         | SetComp(expr elt, förståelse* generatorer)\n"
"         | DictComp(expr nyckel, expr värde, förståelse* generatorer)\n"
"         | GeneratorExp(expr elt, förståelse* generatorer)\n"
"         -- grammatiken begränsar var yield-uttryck kan förekomma\n"
"         | Await(expr värde)\n"
"         | Yield(expr? värde)\n"
"         | YieldFrom(expr värde)\n"
"         -- behöver sekvenser för compare för att skilja mellan\n"
"         -- x < 4 < 3 och (x < 4) < 3\n"
"         | Compare(expr vänster, cmpop* ops, expr* comparators)\n"
"         | Call(expr func, expr* args, nyckelord* nyckelord)\n"
"         | FormattedValue(expr värde, int konvertering, expr? format_spec)\n"
"         | Interpolation(expr-värde, konstant str, int-konvertering, expr? "
"format_spec)\n"
"         | JoinedStr(expr* värden)\n"
"         | TemplateStr(expr* värden)\n"
"         | Konstant(konstant värde, sträng? typ)\n"
"\n"
"         -- följande uttryck kan förekomma i tilldelningssammanhang\n"
"         | Attribute(expr-värde, identifierare attr, expr_context ctx)\n"
"         | Subscript(expr-värde, expr-slice, expr_kontext ctx)\n"
"         | Starred(expr-värde, expr_kontext ctx)\n"
"         | Namn(identifierare id, expr_kontext ctx)\n"
"         | Lista(expr* elts, expr_kontext ctx)\n"
"         | Tuple(expr* elts, expr_context ctx)\n"
"\n"
"         -- kan endast förekomma i Subscript\n"
"         | Slice(expr? lower, expr? upper, expr? step)\n"
"\n"
"          -- col_offset är byte-offset i den utf8-sträng som parsern "
"använder\n"
"          attributes (int lineno, int col_offset, int? end_lineno, int? "
"end_col_offset)\n"
"\n"
"    expr_context = Ladda | Förvara | Del\n"
"\n"
"    boolop = Och | Eller\n"
"\n"
"    operator = Add | Sub | Mult | MatMult | Div | Mod | Pow | LShift\n"
"                 | RShift | BitOr | BitXor | BitAnd | FloorDiv\n"
"\n"
"    unaryop = Invertera | Inte | UAdd | USub\n"
"\n"
"    cmpop = Eq | NotEq | Lt | LtE | Gt | GtE | Is | IsNot | In | NotIn\n"
"\n"
"    comprehension = (expr mål, expr iter, expr* ifs, int is_async)\n"
"\n"
"    excepthandler = ExceptHandler(expr? typ, identifier? namn, stmt* kropp)\n"
"                    attributes (int lineno, int col_offset, int? end_lineno, "
"int? end_col_offset)\n"
"\n"
"    arguments = (arg* posonlyargs, arg* args, arg? vararg, arg* kwonlyargs,\n"
"                 expr* kw_defaults, arg? kwarg, expr* defaults)\n"
"\n"
"    arg = (identifierare arg, expr? anteckning, sträng? typ_kommentar)\n"
"           attributes (int lineno, int col_offset, int? end_lineno, int? "
"end_col_offset)\n"
"\n"
"    -- nyckelord argument som anges till anropet (NULL-identifierare för "
"**kwargs)\n"
"    nyckelord = (identifierare? arg, expr-värde)\n"
"               attribut (int lineno, int col_offset, int? end_lineno, int? "
"end_col_offset)\n"
"\n"
"    -- importera namn med valfritt \"as\"-alias.\n"
"    alias = (identifierare namn, identifierare? asname)\n"
"             attributes (int lineno, int col_offset, int? end_lineno, int? "
"end_col_offset)\n"
"\n"
"    withitem = (expr context_expr, expr? optional_vars)\n"
"\n"
"    match_case = (pattern pattern, expr? guard, stmt* body)\n"
"\n"
"    pattern = MatchValue(expr värde)\n"
"            | MatchSingleton(konstant värde)\n"
"            | MatchSequence(mönster* mönster)\n"
"            | MatchMapping(expr* nycklar, mönster* mönster, identifierare? "
"rest)\n"
"            | MatchClass(expr cls, mönster* mönster, identifierare* "
"kwd_attrs, mönster* kwd_patterns)\n"
"\n"
"            | MatchStar(identifierare? namn)\n"
"            -- Den valfria MatchMapping-parametern \"rest\" hanterar extra "
"mappningsnycklar\n"
"\n"
"            | MatchAs(mönster? mönster, identifierare? namn)\n"
"            | MatchOr(mönster* mönster)\n"
"\n"
"             attributes (int lineno, int col_offset, int end_lineno, int "
"end_col_offset)\n"
"\n"
"    type_ignore = TypeIgnore(int lineno, string tag)\n"
"\n"
"    type_param = TypeVar(identifierarnamn, expr? bound, expr? "
"default_value)\n"
"               | ParamSpec(identifierarnamn, expr? default_value)\n"
"               | TypeVarTuple(identifierarnamn, expr? standardvärde)\n"
"               attributes (int lineno, int col_offset, int end_lineno, int "
"end_col_offset)\n"
"}\n"

#: ../../library/ast.rst:42
msgid "Node classes"
msgstr "Klasser för noder"

#: ../../library/ast.rst:46
msgid ""
"This is the base of all AST node classes.  The actual node classes are "
"derived from the :file:`Parser/Python.asdl` file, which is reproduced :ref:"
"`above <abstract-grammar>`.  They are defined in the :mod:`!_ast` C module "
"and re-exported in :mod:`ast`."
msgstr ""
"Detta är basen för alla AST-nodklasser.  De faktiska nodklasserna härleds "
"från filen :file:`Parser/Python.asdl`, som reproduceras :ref:``above "
"<abstract-grammar>`.  De definieras i C-modulen :mod:`!_ast` och exporteras "
"på nytt i :mod:`ast`."

#: ../../library/ast.rst:51
msgid ""
"There is one class defined for each left-hand side symbol in the abstract "
"grammar (for example, :class:`ast.stmt` or :class:`ast.expr`).  In addition, "
"there is one class defined for each constructor on the right-hand side; "
"these classes inherit from the classes for the left-hand side trees.  For "
"example, :class:`ast.BinOp` inherits from :class:`ast.expr`.  For production "
"rules with alternatives (aka \"sums\"), the left-hand side class is "
"abstract: only instances of specific constructor nodes are ever created."
msgstr ""
"Det finns en klass definierad för varje symbol på vänstersidan i den "
"abstrakta grammatiken (t.ex. :class:`ast.stmt` eller :class:`ast.expr`).  "
"Dessutom finns det en klass definierad för varje konstruktör på högersidan; "
"dessa klasser ärver från klasserna för vänstersidans träd.  Till exempel "
"ärver :class:`ast.BinOp` från :class:`ast.expr`.  För produktionsregler med "
"alternativ (även kallade \"summor\") är klassen på vänster sida abstrakt: "
"endast instanser av specifika konstruktörsnoder skapas någonsin."

#: ../../library/ast.rst:64
msgid ""
"Each concrete class has an attribute :attr:`!_fields` which gives the names "
"of all child nodes."
msgstr ""
"Varje konkret klass har ett attribut :attr:`!_fields` som anger namnen på "
"alla underordnade noder."

#: ../../library/ast.rst:67
msgid ""
"Each instance of a concrete class has one attribute for each child node, of "
"the type as defined in the grammar.  For example, :class:`ast.BinOp` "
"instances have an attribute :attr:`left` of type :class:`ast.expr`."
msgstr ""
"Varje instans av en konkret klass har ett attribut för varje underordnad "
"nod, av den typ som definieras i grammatiken.  Exempelvis har instanser av :"
"class:`ast.BinOp` ett attribut :attr:`left` av typen :class:`ast.expr`."

#: ../../library/ast.rst:71
msgid ""
"If these attributes are marked as optional in the grammar (using a question "
"mark), the value might be ``None``.  If the attributes can have zero-or-more "
"values (marked with an asterisk), the values are represented as Python "
"lists.  All possible attributes must be present and have valid values when "
"compiling an AST with :func:`compile`."
msgstr ""
"Om dessa attribut är markerade som valfria i grammatiken (med ett "
"frågetecken) kan värdet vara ``None``.  Om attributen kan ha noll eller fler "
"värden (markerade med en asterisk), representeras värdena som Python-"
"listor.  Alla möjliga attribut måste finnas och ha giltiga värden när man "
"kompilerar en AST med :func:`compile`."

#: ../../library/ast.rst:79
msgid ""
"The :attr:`!_field_types` attribute on each concrete class is a dictionary "
"mapping field names (as also listed in :attr:`_fields`) to their types."
msgstr ""
"Attributet :attr:`!_field_types` på varje konkret klass är en ordbok som "
"mappar fältnamn (som också listas i :attr:`_fields`) till deras typer."

#: ../../library/ast.rst:82
msgid ""
">>> ast.TypeVar._field_types\n"
"{'name': <class 'str'>, 'bound': ast.expr | None, 'default_value': ast.expr "
"| None}"
msgstr ""
">>> ast.TypeVar._field_types\n"
"{'namn': <class 'str'>, 'bound': ast.expr | None, 'default_value': ast.expr "
"| None}"

#: ../../library/ast.rst:94
msgid ""
"Instances of :class:`ast.expr` and :class:`ast.stmt` subclasses have :attr:"
"`lineno`, :attr:`col_offset`, :attr:`end_lineno`, and :attr:`end_col_offset` "
"attributes.  The :attr:`lineno` and :attr:`end_lineno` are the first and "
"last line numbers of source text span (1-indexed so the first line is line "
"1) and the :attr:`col_offset` and :attr:`end_col_offset` are the "
"corresponding UTF-8 byte offsets of the first and last tokens that generated "
"the node. The UTF-8 offset is recorded because the parser uses UTF-8 "
"internally."
msgstr ""
"Instanser av underklasserna :class:`ast.expr` och :class:`ast.stmt` har "
"attributen :attr:`lineno`, :attr:`col_offset`, :attr:`end_lineno` och :attr:"
"`end_col_offset`.  Attributen :attr:`lineno` och :attr:`end_lineno` är det "
"första och sista radnumret i källtexten (1-indexerat så att den första raden "
"är rad 1) och attributen :attr:`col_offset` och :attr:`end_col_offset` är "
"motsvarande UTF-8-byteoffset för den första och sista tokens som genererade "
"noden. UTF-8-offset registreras eftersom parsern använder UTF-8 internt."

#: ../../library/ast.rst:103
msgid ""
"Note that the end positions are not required by the compiler and are "
"therefore optional. The end offset is *after* the last symbol, for example "
"one can get the source segment of a one-line expression node using "
"``source_line[node.col_offset : node.end_col_offset]``."
msgstr ""
"Observera att slutpositionerna inte krävs av kompilatorn och därför är "
"valfria. Slutoffsetet är *efter* den sista symbolen, till exempel kan man få "
"källsegmentet för en nod med enradigt uttryck med hjälp av "
"``source_line[node.col_offset : node.end_col_offset]``."

#: ../../library/ast.rst:108
msgid ""
"The constructor of a class :class:`ast.T` parses its arguments as follows:"
msgstr ""
"Konstruktören för en klass :class:`ast.T` analyserar sina argument på "
"följande sätt:"

#: ../../library/ast.rst:110
msgid ""
"If there are positional arguments, there must be as many as there are items "
"in :attr:`T._fields`; they will be assigned as attributes of these names."
msgstr ""
"Om det finns positionella argument måste det finnas lika många som det finns "
"objekt i :attr:`T._fields`; de kommer att tilldelas som attribut till dessa "
"namn."

#: ../../library/ast.rst:112
msgid ""
"If there are keyword arguments, they will set the attributes of the same "
"names to the given values."
msgstr ""
"Om det finns nyckelordsargument kommer de att ställa in attributen med samma "
"namn till de angivna värdena."

#: ../../library/ast.rst:115
msgid ""
"For example, to create and populate an :class:`ast.UnaryOp` node, you could "
"use ::"
msgstr ""
"Om du till exempel vill skapa och fylla i en :class:`ast.UnaryOp`-nod kan du "
"använda ::"

#: ../../library/ast.rst:118
msgid ""
"node = ast.UnaryOp(ast.USub(), ast.Constant(5, lineno=0, col_offset=0),\n"
"                   lineno=0, col_offset=0)"
msgstr ""
"node = ast.UnaryOp(ast.USub(), ast.Constant(5, lineno=0, col_offset=0),\n"
"                   lineno=0, col_offset=0)"

#: ../../library/ast.rst:121
msgid ""
"If a field that is optional in the grammar is omitted from the constructor, "
"it defaults to ``None``. If a list field is omitted, it defaults to the "
"empty list. If a field of type :class:`!ast.expr_context` is omitted, it "
"defaults to :class:`Load() <ast.Load>`. If any other field is omitted, a :"
"exc:`DeprecationWarning` is raised and the AST node will not have this "
"field. In Python 3.15, this condition will raise an error."
msgstr ""
"Om ett fält som är valfritt i grammatiken utelämnas från konstruktorn, blir "
"standardvärdet ``None``. Om ett listfält utelämnas är standardvärdet den "
"tomma listan. Om ett fält av typen :class:`!ast.expr_context` utelämnas, "
"blir standardvärdet :class:`Load() <ast.Load>`. Om något annat fält "
"utelämnas, kommer en :exc:`DeprecationWarning` att visas och AST-noden "
"kommer inte att ha detta fält. I Python 3.15 kommer detta villkor att ge "
"upphov till ett fel."

#: ../../library/ast.rst:130
msgid "Class :class:`ast.Constant` is now used for all constants."
msgstr "Klassen :class:`ast.Constant` används nu för alla konstanter."

#: ../../library/ast.rst:134
msgid ""
"Simple indices are represented by their value, extended slices are "
"represented as tuples."
msgstr ""
"Enkla index representeras av sitt värde, extended slices representeras som "
"tupler."

#: ../../library/ast.rst:139
msgid ""
"The :meth:`~object.__repr__` output of :class:`~ast.AST` nodes includes the "
"values of the node fields."
msgstr ""
"Utmatningen :meth:`~object.__repr__` av :class:`~ast.AST`-noder innehåller "
"värdena för nodfälten."

#: ../../library/ast.rst:144
msgid ""
"Old classes :class:`!ast.Num`, :class:`!ast.Str`, :class:`!ast.Bytes`, :"
"class:`!ast.NameConstant` and :class:`!ast.Ellipsis` are still available, "
"but they will be removed in future Python releases.  In the meantime, "
"instantiating them will return an instance of a different class."
msgstr ""
"Gamla klasser :class:`!ast.Num`, :class:`!ast.Str`, :class:`!ast.Bytes`, :"
"class:`!ast.NameConstant` och :class:`!ast.Ellipsis` är fortfarande "
"tillgängliga, men de kommer att tas bort i framtida Python-versioner.  Under "
"tiden kommer instansiering av dem att returnera en instans av en annan klass."

#: ../../library/ast.rst:151
msgid ""
"Old classes :class:`!ast.Index` and :class:`!ast.ExtSlice` are still "
"available, but they will be removed in future Python releases. In the "
"meantime, instantiating them will return an instance of a different class."
msgstr ""
"Gamla klasser :class:`!ast.Index` och :class:`!ast.ExtSlice` är fortfarande "
"tillgängliga, men de kommer att tas bort i framtida Python-versioner. Under "
"tiden kommer instansiering av dem att returnera en instans av en annan klass."

#: ../../library/ast.rst:158
msgid ""
"Previous versions of Python allowed the creation of AST nodes that were "
"missing required fields. Similarly, AST node constructors allowed arbitrary "
"keyword arguments that were set as attributes of the AST node, even if they "
"did not match any of the fields of the AST node. This behavior is deprecated "
"and will be removed in Python 3.15."
msgstr ""
"Tidigare versioner av Python tillät skapandet av AST-noder som saknade "
"obligatoriska fält. På samma sätt tillät AST-nodkonstruktörer godtyckliga "
"nyckelordsargument som sattes som attribut för AST-noden, även om de inte "
"matchade något av fälten i AST-noden. Detta beteende är föråldrat och kommer "
"att tas bort i Python 3.15."

#: ../../library/ast.rst:165
msgid ""
"The descriptions of the specific node classes displayed here were initially "
"adapted from the fantastic `Green Tree Snakes <https://greentreesnakes."
"readthedocs.io/en/latest/>`__ project and all its contributors."
msgstr ""
"Beskrivningarna av de specifika nodklasserna som visas här anpassades "
"ursprungligen från det fantastiska projektet `Green Tree Snakes <https://"
"greentreesnakes.readthedocs.io/en/latest/>`__ och alla dess bidragsgivare."

#: ../../library/ast.rst:174
msgid "Root nodes"
msgstr "Rotnoder"

#: ../../library/ast.rst:178
msgid ""
"A Python module, as with :ref:`file input <file-input>`. Node type generated "
"by :func:`ast.parse` in the default ``\"exec\"`` *mode*."
msgstr ""
"En Python-modul, som med :ref:`file input <file-input>`. Nodtyp genererad "
"av :func:`ast.parse` i standard ``\"exec\"`` *mode*."

#: ../../library/ast.rst:181
msgid "``body`` is a :class:`list` of the module's :ref:`ast-statements`."
msgstr "``body`` är en :class:`lista` av modulens :ref:`ast-statements`."

#: ../../library/ast.rst:183
msgid ""
"``type_ignores`` is a :class:`list` of the module's type ignore comments; "
"see :func:`ast.parse` for more details."
msgstr ""
"``type_ignores`` är en :class:`lista` över modulens kommentarer för "
"ignorerade typer; se :func:`ast.parse` för mer information."

#: ../../library/ast.rst:186
msgid ""
">>> print(ast.dump(ast.parse('x = 1'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Name(id='x', ctx=Store())],\n"
"            value=Constant(value=1))])"
msgstr ""
">>> print(ast.dump(ast.parse('x = 1'), indent=4))\n"
"Modul(\n"
"    kropp=[\n"
"        Tilldela(\n"
"            mål=[\n"
"                Namn(id='x', ctx=Store())],\n"
"            värde=Konstant(värde=1))])"

#: ../../library/ast.rst:199
msgid ""
"A single Python :ref:`expression input <expression-input>`. Node type "
"generated by :func:`ast.parse` when *mode* is ``\"eval\"``."
msgstr ""
"En enda Python :ref:`uttrycksinmatning <expression-input>`. Nodtyp som "
"genereras av :func:`ast.parse` när *mode* är ``\"eval\"``."

#: ../../library/ast.rst:202
msgid ""
"``body`` is a single node, one of the :ref:`expression types <ast-"
"expressions>`."
msgstr ""
"``body`` är en enskild nod, en av :ref:`uttryckstyperna <ast-expressions>`."

#: ../../library/ast.rst:205 ../../library/ast.rst:275
msgid ""
">>> print(ast.dump(ast.parse('123', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Constant(value=123))"
msgstr ""
">>> print(ast.dump(ast.parse('123', mode='eval'), indent=4))\n"
"Uttryck(\n"
"    body=Konstant(värde=123))"

#: ../../library/ast.rst:214
msgid ""
"A single :ref:`interactive input <interactive>`, like in :ref:`tut-interac`. "
"Node type generated by :func:`ast.parse` when *mode* is ``\"single\"``."
msgstr ""
"En enda :ref:`interaktiv inmatning <interactive>`, som i :ref:`tut-interac`. "
"Nodtyp som genereras av :func:`ast.parse` när *mode* är ``\"single\"``."

#: ../../library/ast.rst:217
msgid "``body`` is a :class:`list` of :ref:`statement nodes <ast-statements>`."
msgstr ""
"``body`` är en :class:`list` av :ref:``statement nodes <ast-statements>`."

#: ../../library/ast.rst:219
msgid ""
">>> print(ast.dump(ast.parse('x = 1; y = 2', mode='single'), indent=4))\n"
"Interactive(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Name(id='x', ctx=Store())],\n"
"            value=Constant(value=1)),\n"
"        Assign(\n"
"            targets=[\n"
"                Name(id='y', ctx=Store())],\n"
"            value=Constant(value=2))])"
msgstr ""
">>> print(ast.dump(ast.parse('x = 1; y = 2', mode='single'), indent=4))\n"
"Interaktiv(\n"
"    kropp=[\n"
"        Tilldela(\n"
"            mål=[\n"
"                Namn(id='x', ctx=Store())],\n"
"            värde=Konstant(värde=1)),\n"
"        Tilldela(\n"
"            mål=[\n"
"                Namn(id='y', ctx=Store())],\n"
"            värde=Konstant(värde=2))])"

#: ../../library/ast.rst:236
msgid ""
"A representation of an old-style type comments for functions, as Python "
"versions prior to 3.5 didn't support :pep:`484` annotations. Node type "
"generated by :func:`ast.parse` when *mode* is ``\"func_type\"``."
msgstr ""
"En representation av en gammal typkommentar för funktioner, eftersom Python-"
"versioner före 3.5 inte hade stöd för :pep:`484`-annoteringar. Nodtyp som "
"genereras av :func:`ast.parse` när *mode* är ``\"func_type\"``."

#: ../../library/ast.rst:240
msgid "Such type comments would look like this::"
msgstr "En sådan typ av kommentarer skulle se ut så här::"

#: ../../library/ast.rst:242
msgid ""
"def sum_two_number(a, b):\n"
"    # type: (int, int) -> int\n"
"    return a + b"
msgstr ""
"def sum_two_number(a, b):\n"
"    # typ: (int, int) -> int\n"
"    returnerar a + b"

#: ../../library/ast.rst:246
msgid ""
"``argtypes`` is a :class:`list` of :ref:`expression nodes <ast-expressions>`."
msgstr ""
"``argtypes`` är en :class:`list` av :ref:`uttrycksnoder <ast-expressions>`."

#: ../../library/ast.rst:248
msgid "``returns`` is a single :ref:`expression node <ast-expressions>`."
msgstr "``returns`` är en enda :ref:`uttrycksnod <ast-expressions>`."

#: ../../library/ast.rst:250
msgid ""
">>> print(ast.dump(ast.parse('(int, str) -> List[int]', mode='func_type'), "
"indent=4))\n"
"FunctionType(\n"
"    argtypes=[\n"
"        Name(id='int', ctx=Load()),\n"
"        Name(id='str', ctx=Load())],\n"
"    returns=Subscript(\n"
"        value=Name(id='List', ctx=Load()),\n"
"        slice=Name(id='int', ctx=Load()),\n"
"        ctx=Load()))"
msgstr ""
">>> print(ast.dump(ast.parse('(int, str) -> List[int]', mode='func_type'), "
"indent=4))\n"
"Funktionstyp(\n"
"    argtypes=[\n"
"        Namn(id='int', ctx=Load()),\n"
"        Namn(id='str', ctx=Load())],\n"
"    returns=Subskript(\n"
"        value=Name(id='List', ctx=Load()),\n"
"        slice=Name(id='int', ctx=Load()),\n"
"        ctx=Load()))"

#: ../../library/ast.rst:266
msgid "Literals"
msgstr "Bokstäver"

#: ../../library/ast.rst:270
msgid ""
"A constant value. The ``value`` attribute of the ``Constant`` literal "
"contains the Python object it represents. The values represented can be "
"instances of :class:`str`, :class:`bytes`, :class:`int`, :class:`float`, :"
"class:`complex`, and :class:`bool`, and the constants :data:`None` and :data:"
"`Ellipsis`."
msgstr ""
"Ett konstant värde. Attributet ``value`` för ``Constant`` literalen "
"innehåller det Python-objekt som den representerar. De värden som "
"representeras kan vara instanser av :class:`str`, :class:`bytes`, :class:"
"`int`, :class:`float`, :class:`complex` och :class:`bool`, samt "
"konstanterna :data:`None` och :data:`Ellipsis`."

#: ../../library/ast.rst:284
msgid ""
"Node representing a single formatting field in an f-string. If the string "
"contains a single formatting field and nothing else the node can be isolated "
"otherwise it appears in :class:`JoinedStr`."
msgstr ""
"Nod som representerar ett enda formateringsfält i en f-sträng. Om strängen "
"innehåller ett enda formateringsfält och inget annat kan noden isoleras, "
"annars visas den i :class:`JoinedStr`."

#: ../../library/ast.rst:288 ../../library/ast.rst:360
msgid ""
"``value`` is any expression node (such as a literal, a variable, or a "
"function call)."
msgstr ""
"``värde`` är vilken uttrycksnod som helst (t.ex. en bokstav, en variabel "
"eller ett funktionsanrop)."

#: ../../library/ast.rst:290 ../../library/ast.rst:363
msgid "``conversion`` is an integer:"
msgstr "``konvertering`` är ett heltal:"

#: ../../library/ast.rst:292
msgid "-1: no formatting"
msgstr "-1: ingen formatering"

#: ../../library/ast.rst:293
msgid "115 (``ord('s')``): ``!s`` string formatting"
msgstr "115 (``ord('s')``): ``!s`` strängformatering"

#: ../../library/ast.rst:294
msgid "114 (``ord('r')``): ``!r`` repr formatting"
msgstr "114 (``ord('r')``): ``!r`` repr formatering"

#: ../../library/ast.rst:295
msgid "97 (``ord('a')``): ``!a`` ASCII formatting"
msgstr "97 (``ord('a')``): ``!a`` ASCII-formatering"

#: ../../library/ast.rst:297 ../../library/ast.rst:370
msgid ""
"``format_spec`` is a :class:`JoinedStr` node representing the formatting of "
"the value, or ``None`` if no format was specified. Both ``conversion`` and "
"``format_spec`` can be set at the same time."
msgstr ""
"``format_spec`` är en :class:`JoinedStr`-nod som representerar formateringen "
"av värdet, eller ``None`` om inget format har angetts. Både ``conversion`` "
"och ``format_spec`` kan anges samtidigt."

#: ../../library/ast.rst:304
msgid ""
"An f-string, comprising a series of :class:`FormattedValue` and :class:"
"`Constant` nodes."
msgstr ""
"En f-sträng som består av en serie :class:`FormattedValue`- och :class:"
"`Constant`-noder."

#: ../../library/ast.rst:307
msgid ""
">>> print(ast.dump(ast.parse('f\"sin({a}) is {sin(a):.3}\"', mode='eval'), "
"indent=4))\n"
"Expression(\n"
"    body=JoinedStr(\n"
"        values=[\n"
"            Constant(value='sin('),\n"
"            FormattedValue(\n"
"                value=Name(id='a', ctx=Load()),\n"
"                conversion=-1),\n"
"            Constant(value=') is '),\n"
"            FormattedValue(\n"
"                value=Call(\n"
"                    func=Name(id='sin', ctx=Load()),\n"
"                    args=[\n"
"                        Name(id='a', ctx=Load())]),\n"
"                conversion=-1,\n"
"                format_spec=JoinedStr(\n"
"                    values=[\n"
"                        Constant(value='.3')]))]))"
msgstr ""
">>> print(ast.dump(ast.parse('f\"sin({a}) är {sin(a):.3}\"', mode='eval'), "
"indent=4))\n"
"Uttryck(\n"
"    kropp=JoinedStr(\n"
"        värden=[\n"
"            Constant(värde='sin('),\n"
"            FormateratVärde(\n"
"                värde=Namn(id='a', ctx=Load()),\n"
"                konvertering=-1),\n"
"            Constant(värde=') är '),\n"
"            FormateratVärde(\n"
"                värde=Anrop(\n"
"                    func=Namn(id='sin', ctx=Load()),\n"
"                    args=[\n"
"                        Namn(id='a', ctx=Load())]),\n"
"                konvertering=-1,\n"
"                format_spec=JoinedStr(\n"
"                    värden=[\n"
"                        Constant(värde='.3')]))]))"

#: ../../library/ast.rst:331
msgid ""
"A t-string, comprising a series of :class:`Interpolation` and :class:"
"`Constant` nodes."
msgstr ""
"En t-sträng som består av en serie :class:`Interpolation`- och :class:"
"`Constant`-noder."

#: ../../library/ast.rst:334
msgid ""
">>> print(ast.dump(ast.parse('t\"{name} finished {place:ordinal}\"', "
"mode='eval'), indent=4))\n"
"Expression(\n"
"    body=TemplateStr(\n"
"        values=[\n"
"            Interpolation(\n"
"                value=Name(id='name', ctx=Load()),\n"
"                str='name',\n"
"                conversion=-1),\n"
"            Constant(value=' finished '),\n"
"            Interpolation(\n"
"                value=Name(id='place', ctx=Load()),\n"
"                str='place',\n"
"                conversion=-1,\n"
"                format_spec=JoinedStr(\n"
"                    values=[\n"
"                        Constant(value='ordinal')]))]))"
msgstr ""
">>> print(ast.dump(ast.parse('t\"{name} färdig {place:ordinal}\"', "
"mode='eval'), indent=4))\n"
"Uttryck(\n"
"    body=MallStr(\n"
"        värden=[\n"
"            Interpolering(\n"
"                värde=Namn(id='namn', ctx=Load()),\n"
"                str='namn',\n"
"                konvertering=-1),\n"
"            Konstant(värde=' färdig '),\n"
"            Interpolation(\n"
"                värde=Namn(id='plats', ctx=Load()),\n"
"                str='plats',\n"
"                konvertering=-1,\n"
"                format_spec=JoinedStr(\n"
"                    värden=[\n"
"                        Constant(value='ordinal')]))]))"

#: ../../library/ast.rst:358
msgid "Node representing a single interpolation field in a t-string."
msgstr "Nod som representerar ett enda interpoleringsfält i en t-sträng."

#: ../../library/ast.rst:362
msgid ""
"``str`` is a constant containing the text of the interpolation expression."
msgstr ""
"``str`` är en konstant som innehåller texten i interpoleringsuttrycket."

#: ../../library/ast.rst:365
msgid "-1: no conversion"
msgstr "-1: ingen konvertering"

#: ../../library/ast.rst:366
msgid "115: ``!s`` string conversion"
msgstr "115: ``!s`` strängomvandling"

#: ../../library/ast.rst:367
msgid "114: ``!r`` repr conversion"
msgstr "114: ``!r`` repr konvertering"

#: ../../library/ast.rst:368
msgid "97: ``!a`` ascii conversion"
msgstr "97: ``!a`` ascii-konvertering"

#: ../../library/ast.rst:380
msgid ""
"A list or tuple. ``elts`` holds a list of nodes representing the elements. "
"``ctx`` is :class:`Store` if the container is an assignment target (i.e. "
"``(x,y)=something``), and :class:`Load` otherwise."
msgstr ""
"En lista eller tupel. ``elts`` innehåller en lista med noder som "
"representerar elementen. ``ctx`` är :class:`Store`` om behållaren är ett mål "
"för en tilldelning (dvs. ``(x,y)=något``), och :class:`Load`` annars."

#: ../../library/ast.rst:384
msgid ""
">>> print(ast.dump(ast.parse('[1, 2, 3]', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=List(\n"
"        elts=[\n"
"            Constant(value=1),\n"
"            Constant(value=2),\n"
"            Constant(value=3)],\n"
"        ctx=Load()))\n"
">>> print(ast.dump(ast.parse('(1, 2, 3)', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Tuple(\n"
"        elts=[\n"
"            Constant(value=1),\n"
"            Constant(value=2),\n"
"            Constant(value=3)],\n"
"        ctx=Load()))"
msgstr ""
">>> print(ast.dump(ast.parse('[1, 2, 3]', mode='eval'), indent=4))\n"
"Uttryck(\n"
"    kropp=Lista(\n"
"        elts=[\n"
"            Konstant(värde=1),\n"
"            Konstant(värde=2),\n"
"            Konstant(värde=3)],\n"
"        ctx=Load()))\n"
">>> print(ast.dump(ast.parse('(1, 2, 3)', mode='eval'), indent=4))\n"
"Uttryck(\n"
"    body=Tupel(\n"
"        elts=[\n"
"            Konstant(värde=1),\n"
"            Konstant(värde=2),\n"
"            Konstant(värde=3)],\n"
"        ctx=Load()))"

#: ../../library/ast.rst:406
msgid "A set. ``elts`` holds a list of nodes representing the set's elements."
msgstr ""
"En uppsättning. ``elts`` innehåller en lista med noder som representerar "
"setets element."

#: ../../library/ast.rst:408
msgid ""
">>> print(ast.dump(ast.parse('{1, 2, 3}', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Set(\n"
"        elts=[\n"
"            Constant(value=1),\n"
"            Constant(value=2),\n"
"            Constant(value=3)]))"
msgstr ""
">>> print(ast.dump(ast.parse('{1, 2, 3}', mode='eval'), indent=4))\n"
"Uttryck(\n"
"    kropp=Set(\n"
"        elts=[\n"
"            Konstant(värde=1),\n"
"            Konstant(värde=2),\n"
"            Konstant(värde=3)]))"

#: ../../library/ast.rst:421
msgid ""
"A dictionary. ``keys`` and ``values`` hold lists of nodes representing the "
"keys and the values respectively, in matching order (what would be returned "
"when calling :code:`dictionary.keys()` and :code:`dictionary.values()`)."
msgstr ""
"En ordbok. ``keys`` och ``values`` innehåller listor med noder som "
"representerar nycklarna respektive värdena, i matchande ordning (vad som "
"skulle returneras vid anrop av :code:`dictionary.keys()` och :code:"
"`dictionary.values()`)."

#: ../../library/ast.rst:425
msgid ""
"When doing dictionary unpacking using dictionary literals the expression to "
"be expanded goes in the ``values`` list, with a ``None`` at the "
"corresponding position in ``keys``."
msgstr ""
"Vid uppackning av ordböcker med hjälp av ordbokslitteraler hamnar det "
"uttryck som ska expanderas i listan ``values``, med en ``None`` på "
"motsvarande position i ``keys``."

#: ../../library/ast.rst:429
msgid ""
">>> print(ast.dump(ast.parse('{\"a\":1, **d}', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Dict(\n"
"        keys=[\n"
"            Constant(value='a'),\n"
"            None],\n"
"        values=[\n"
"            Constant(value=1),\n"
"            Name(id='d', ctx=Load())]))"
msgstr ""
">>> print(ast.dump(ast.parse('{\"a\":1, **d}', mode='eval'), indent=4))\n"
"Uttryck(\n"
"    body=Dict(\n"
"        nycklar=[\n"
"            Konstant(värde='a'),\n"
"            Ingen],\n"
"        values=[\n"
"            Konstant(värde=1),\n"
"            Namn(id='d', ctx=Load())]))"

#: ../../library/ast.rst:443
msgid "Variables"
msgstr "Variabler"

#: ../../library/ast.rst:447
msgid ""
"A variable name. ``id`` holds the name as a string, and ``ctx`` is one of "
"the following types."
msgstr ""
"Ett variabelnamn. ``id`` innehåller namnet som en sträng, och ``ctx`` är en "
"av följande typer."

#: ../../library/ast.rst:455
msgid ""
"Variable references can be used to load the value of a variable, to assign a "
"new value to it, or to delete it. Variable references are given a context to "
"distinguish these cases."
msgstr ""
"Variabelreferenser kan användas för att ladda en variabels värde, tilldela "
"den ett nytt värde eller ta bort den. Variabelreferenser ges ett sammanhang "
"för att skilja dessa fall åt."

#: ../../library/ast.rst:459
msgid ""
">>> print(ast.dump(ast.parse('a'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Expr(\n"
"            value=Name(id='a', ctx=Load()))])\n"
"\n"
">>> print(ast.dump(ast.parse('a = 1'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Name(id='a', ctx=Store())],\n"
"            value=Constant(value=1))])\n"
"\n"
">>> print(ast.dump(ast.parse('del a'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Delete(\n"
"            targets=[\n"
"                Name(id='a', ctx=Del())])])"
msgstr ""
">>> print(ast.dump(ast.parse('a'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        Expr(\n"
"            värde=Namn(id='a', ctx=Load())))])\n"
"\n"
">>> print(ast.dump(ast.parse('a = 1'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        Tilldela(\n"
"            mål=[\n"
"                Namn(id='a', ctx=Store())],\n"
"            värde=Konstant(värde=1))])\n"
"\n"
">>> print(ast.dump(ast.parse('del a'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        Radera(\n"
"            mål=[\n"
"                Namn(id='a', ctx=Del())])])])"

#: ../../library/ast.rst:485
msgid ""
"A ``*var`` variable reference. ``value`` holds the variable, typically a :"
"class:`Name` node. This type must be used when building a :class:`Call` node "
"with ``*args``."
msgstr ""
"En ``*var`` variabelreferens. ``value`` innehåller variabeln, vanligtvis en :"
"class:`Name`-nod. Denna typ måste användas när man bygger en :class:`Call`-"
"nod med ``*args``."

#: ../../library/ast.rst:489
msgid ""
">>> print(ast.dump(ast.parse('a, *b = it'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Tuple(\n"
"                    elts=[\n"
"                        Name(id='a', ctx=Store()),\n"
"                        Starred(\n"
"                            value=Name(id='b', ctx=Store()),\n"
"                            ctx=Store())],\n"
"                    ctx=Store())],\n"
"            value=Name(id='it', ctx=Load()))])"
msgstr ""
">>> print(ast.dump(ast.parse('a, *b = it'), indent=4))\n"
"Modul(\n"
"    kropp=[\n"
"        Tilldela(\n"
"            mål=[\n"
"                Tupel(\n"
"                    elts=[\n"
"                        Namn(id='a', ctx=Store()),\n"
"                        Stjärnmärkt(\n"
"                            värde=Namn(id='b', ctx=Store()),\n"
"                            ctx=Store())],\n"
"                    ctx=Store())],\n"
"            value=Name(id='it', ctx=Load())))])"

#: ../../library/ast.rst:509
msgid "Expressions"
msgstr "Uttryck"

#: ../../library/ast.rst:513
msgid ""
"When an expression, such as a function call, appears as a statement by "
"itself with its return value not used or stored, it is wrapped in this "
"container. ``value`` holds one of the other nodes in this section, a :class:"
"`Constant`, a :class:`Name`, a :class:`Lambda`, a :class:`Yield` or :class:"
"`YieldFrom` node."
msgstr ""
"När ett uttryck, t.ex. ett funktionsanrop, visas som en egen sats utan att "
"dess returvärde används eller lagras, omsluts det av denna container. "
"``value`` innehåller en av de andra noderna i detta avsnitt, en :class:"
"`Constant`, en :class:`Name`, en :class:`Lambda`, en :class:`Yield` eller :"
"class:`YieldFrom` nod."

#: ../../library/ast.rst:518
msgid ""
">>> print(ast.dump(ast.parse('-a'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Expr(\n"
"            value=UnaryOp(\n"
"                op=USub(),\n"
"                operand=Name(id='a', ctx=Load())))])"
msgstr ""
">>> print(ast.dump(ast.parse('-a'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        Expr(\n"
"            värde=UnaryOp(\n"
"                op=USub(),\n"
"                operand=Namn(id='a', ctx=Load())))]))"

#: ../../library/ast.rst:531
msgid ""
"A unary operation. ``op`` is the operator, and ``operand`` any expression "
"node."
msgstr "En unär operation. ``op`` är operatorn och ``operand`` en uttrycksnod."

#: ../../library/ast.rst:540
msgid ""
"Unary operator tokens. :class:`Not` is the ``not`` keyword, :class:`Invert` "
"is the ``~`` operator."
msgstr ""
"Unära operatortokens. :class:`Not` är nyckelordet ``not``, :class:`Invert` "
"är operatorn ``~``."

#: ../../library/ast.rst:543
msgid ""
">>> print(ast.dump(ast.parse('not x', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=UnaryOp(\n"
"        op=Not(),\n"
"        operand=Name(id='x', ctx=Load())))"
msgstr ""
">>> print(ast.dump(ast.parse('not x', mode='eval'), indent=4))\n"
"Uttryck(\n"
"    body=UnaryOp(\n"
"        op=Inte(),\n"
"        operand=Namn(id='x', ctx=Load())))"

#: ../../library/ast.rst:554
msgid ""
"A binary operation (like addition or division). ``op`` is the operator, and "
"``left`` and ``right`` are any expression nodes."
msgstr ""
"En binär operation (som addition eller division). ``op`` är operatorn, och "
"``left`` och ``right`` är valfria uttrycksnoder."

#: ../../library/ast.rst:557
msgid ""
">>> print(ast.dump(ast.parse('x + y', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=BinOp(\n"
"        left=Name(id='x', ctx=Load()),\n"
"        op=Add(),\n"
"        right=Name(id='y', ctx=Load())))"
msgstr ""
">>> print(ast.dump(ast.parse('x + y', mode='eval'), indent=4))\n"
"Uttryck(\n"
"    body=BinOp(\n"
"        left=Namn(id='x', ctx=Load()),\n"
"        op=Add(),\n"
"        right=Name(id='y', ctx=Load())))"

#: ../../library/ast.rst:581
msgid "Binary operator tokens."
msgstr "Tokens för binära operatorer."

#: ../../library/ast.rst:586
msgid ""
"A boolean operation, 'or' or 'and'. ``op`` is :class:`Or` or :class:`And`. "
"``values`` are the values involved. Consecutive operations with the same "
"operator, such as ``a or b or c``, are collapsed into one node with several "
"values."
msgstr ""
"En boolesk operation, \"eller\" eller \"och\". ``op`` är :class:`Or` eller :"
"class:`And`. ``values`` är de involverade värdena. På varandra följande "
"operationer med samma operator, t.ex. ``a eller b eller c``, slås samman "
"till en nod med flera värden."

#: ../../library/ast.rst:591
msgid "This doesn't include ``not``, which is a :class:`UnaryOp`."
msgstr "Detta inkluderar inte ``not``, som är en :class:`UnaryOp`."

#: ../../library/ast.rst:593
msgid ""
">>> print(ast.dump(ast.parse('x or y', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=BoolOp(\n"
"        op=Or(),\n"
"        values=[\n"
"            Name(id='x', ctx=Load()),\n"
"            Name(id='y', ctx=Load())]))"
msgstr ""
">>> print(ast.dump(ast.parse('x eller y', mode='eval'), indent=4))\n"
"Uttryck(\n"
"    body=BoolOp(\n"
"        op=Or(),\n"
"        värden=[\n"
"            Namn(id='x', ctx=Load()),\n"
"            Namn(id='y', ctx=Load())]))"

#: ../../library/ast.rst:607
msgid "Boolean operator tokens."
msgstr "Tokens för booleska operatorer."

#: ../../library/ast.rst:612
msgid ""
"A comparison of two or more values. ``left`` is the first value in the "
"comparison, ``ops`` the list of operators, and ``comparators`` the list of "
"values after the first element in the comparison."
msgstr ""
"En jämförelse av två eller flera värden. ``left`` är det första värdet i "
"jämförelsen, ``ops`` listan med operatorer och ``comparators`` listan med "
"värden efter det första elementet i jämförelsen."

#: ../../library/ast.rst:616
msgid ""
">>> print(ast.dump(ast.parse('1 <= a < 10', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Compare(\n"
"        left=Constant(value=1),\n"
"        ops=[\n"
"            LtE(),\n"
"            Lt()],\n"
"        comparators=[\n"
"            Name(id='a', ctx=Load()),\n"
"            Constant(value=10)]))"
msgstr ""
">>> print(ast.dump(ast.parse('1 <= a < 10', mode='eval'), indent=4))\n"
"Uttryck(\n"
"    body=Jämför(\n"
"        vänster=Konstant(värde=1),\n"
"        ops=[\n"
"            LtE(),\n"
"            Lt()],\n"
"        comparators=[\n"
"            Namn(id='a', ctx=Load()),\n"
"            Konstant(värde=10)]))"

#: ../../library/ast.rst:641
msgid "Comparison operator tokens."
msgstr "Tokens för jämförelseoperatör."

#: ../../library/ast.rst:646
msgid ""
"A function call. ``func`` is the function, which will often be a :class:"
"`Name` or :class:`Attribute` object. Of the arguments:"
msgstr ""
"Ett anrop av en funktion. ``func`` är funktionen, som ofta kommer att vara "
"ett :class:`Name` eller :class:`Attribute` objekt. Av argumenten:"

#: ../../library/ast.rst:649
msgid "``args`` holds a list of the arguments passed by position."
msgstr ""
"``args`` innehåller en lista över de argument som skickas med position."

#: ../../library/ast.rst:650
msgid ""
"``keywords`` holds a list of :class:`.keyword` objects representing "
"arguments passed by keyword."
msgstr ""
"``keywords`` innehåller en lista med :class:`.keyword`-objekt som "
"representerar argument som skickas med keyword."

#: ../../library/ast.rst:653
msgid ""
"The ``args`` and ``keywords`` arguments are optional and default to empty "
"lists."
msgstr ""
"Argumenten ``args`` och ``keywords`` är valfria och är som standard tomma "
"listor."

#: ../../library/ast.rst:655
msgid ""
">>> print(ast.dump(ast.parse('func(a, b=c, *d, **e)', mode='eval'), "
"indent=4))\n"
"Expression(\n"
"    body=Call(\n"
"        func=Name(id='func', ctx=Load()),\n"
"        args=[\n"
"            Name(id='a', ctx=Load()),\n"
"            Starred(\n"
"                value=Name(id='d', ctx=Load()),\n"
"                ctx=Load())],\n"
"        keywords=[\n"
"            keyword(\n"
"                arg='b',\n"
"                value=Name(id='c', ctx=Load())),\n"
"            keyword(\n"
"                value=Name(id='e', ctx=Load()))]))"
msgstr ""
">>> print(ast.dump(ast.parse('func(a, b=c, *d, **e)', mode='eval'), "
"indent=4))\n"
"Uttryck(\n"
"    body=Anrop(\n"
"        func=Namn(id='func', ctx=Load()),\n"
"        args=[\n"
"            Namn(id='a', ctx=Load()),\n"
"            Stjärnmärkt(\n"
"                value=Name(id='d', ctx=Load()),\n"
"                ctx=Load())],\n"
"        nyckelord=[\n"
"            nyckelord(\n"
"                arg='b',\n"
"                value=Name(id='c', ctx=Load())),\n"
"            nyckelord(\n"
"                value=Name(id='e', ctx=Load())))]))"

#: ../../library/ast.rst:676
msgid ""
"A keyword argument to a function call or class definition. ``arg`` is a raw "
"string of the parameter name, ``value`` is a node to pass in."
msgstr ""
"Ett nyckelordsargument till ett funktionsanrop eller en klassdefinition. "
"``arg`` är en rå sträng med parameternamnet, ``value`` är en nod att skicka "
"in."

#: ../../library/ast.rst:682
msgid ""
"An expression such as ``a if b else c``. Each field holds a single node, so "
"in the following example, all three are :class:`Name` nodes."
msgstr ""
"Ett uttryck som ``a if b else c``. Varje fält innehåller en enda nod, så i "
"följande exempel är alla tre :class:`Name`-noder."

#: ../../library/ast.rst:685
msgid ""
">>> print(ast.dump(ast.parse('a if b else c', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=IfExp(\n"
"        test=Name(id='b', ctx=Load()),\n"
"        body=Name(id='a', ctx=Load()),\n"
"        orelse=Name(id='c', ctx=Load())))"
msgstr ""
">>> print(ast.dump(ast.parse('a if b else c', mode='eval'), indent=4))\n"
"Uttryck(\n"
"    body=IfExp(\n"
"        test=Namn(id='b', ctx=Load()),\n"
"        body=Namn(id='a', ctx=Load()),\n"
"        orelse=Namn(id='c', ctx=Load())))"

#: ../../library/ast.rst:697
msgid ""
"Attribute access, e.g. ``d.keys``. ``value`` is a node, typically a :class:"
"`Name`. ``attr`` is a bare string giving the name of the attribute, and "
"``ctx`` is :class:`Load`, :class:`Store` or :class:`Del` according to how "
"the attribute is acted on."
msgstr ""
"Attributåtkomst, t.ex. ``d.keys``. ``value`` är en nod, vanligtvis en :class:"
"`Name`. ``attr`` är en naken sträng som anger namnet på attributet, och "
"``ctx`` är :class:`Load`, :class:`Store` eller :class:`Del` beroende på hur "
"attributet används."

#: ../../library/ast.rst:702
msgid ""
">>> print(ast.dump(ast.parse('snake.colour', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Attribute(\n"
"        value=Name(id='snake', ctx=Load()),\n"
"        attr='colour',\n"
"        ctx=Load()))"
msgstr ""
">>> print(ast.dump(ast.parse('snake.color', mode='eval'), indent=4))\n"
"Uttryck(\n"
"    body=Attribut(\n"
"        value=Namn(id='snake', ctx=Load()),\n"
"        attr='färg',\n"
"        ctx=Load()))"

#: ../../library/ast.rst:714
msgid ""
"A named expression. This AST node is produced by the assignment expressions "
"operator (also known as the walrus operator). As opposed to the :class:"
"`Assign` node in which the first argument can be multiple nodes, in this "
"case both ``target`` and ``value`` must be single nodes."
msgstr ""
"Ett namngivet uttryck. Denna AST-nod produceras av operatorn för assignment-"
"uttryck (även känd som valrossoperatorn). I motsats till :class:`Assign`-"
"noden där det första argumentet kan vara flera noder, måste i detta fall "
"både ``target`` och ``value`` vara enstaka noder."

#: ../../library/ast.rst:719
msgid ""
">>> print(ast.dump(ast.parse('(x := 4)', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=NamedExpr(\n"
"        target=Name(id='x', ctx=Store()),\n"
"        value=Constant(value=4)))"
msgstr ""
">>> print(ast.dump(ast.parse('(x := 4)', mode='eval'), indent=4))\n"
"Uttryck(\n"
"    body=NamnExpr(\n"
"        target=Namn(id='x', ctx=Store()),\n"
"        värde=Konstant(värde=4)))"

#: ../../library/ast.rst:730
msgid "Subscripting"
msgstr "Subskription"

#: ../../library/ast.rst:734
msgid ""
"A subscript, such as ``l[1]``. ``value`` is the subscripted object (usually "
"sequence or mapping). ``slice`` is an index, slice or key. It can be a :"
"class:`Tuple` and contain a :class:`Slice`. ``ctx`` is :class:`Load`, :class:"
"`Store` or :class:`Del` according to the action performed with the subscript."
msgstr ""
"Ett index, t.ex. ``l[1]``. ``value`` är det subskriberade objektet "
"(vanligtvis sekvens eller mappning). ``lice`` är ett index, en skiva eller "
"en nyckel. Det kan vara en :class:`Tuple` och innehålla en :class:`Slice`. "
"``ctx`` är :class:`Load`, :class:`Store` eller :class:`Del` beroende på "
"vilken åtgärd som utförs med subskriptionen."

#: ../../library/ast.rst:740
msgid ""
">>> print(ast.dump(ast.parse('l[1:2, 3]', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Subscript(\n"
"        value=Name(id='l', ctx=Load()),\n"
"        slice=Tuple(\n"
"            elts=[\n"
"                Slice(\n"
"                    lower=Constant(value=1),\n"
"                    upper=Constant(value=2)),\n"
"                Constant(value=3)],\n"
"            ctx=Load()),\n"
"        ctx=Load()))"
msgstr ""
">>> print(ast.dump(ast.parse('l[1:2, 3]', mode='eval'), indent=4))\n"
"Uttryck(\n"
"    body=Subskript(\n"
"        value=Namn(id='l', ctx=Load()),\n"
"        slice=Tupel(\n"
"            elts=[\n"
"                Slice(\n"
"                    lägre=Konstant(värde=1),\n"
"                    övre=Konstant(värde=2)),\n"
"                Konstant(värde=3)],\n"
"            ctx=Load()),\n"
"        ctx=Load()))"

#: ../../library/ast.rst:758
msgid ""
"Regular slicing (on the form ``lower:upper`` or ``lower:upper:step``). Can "
"occur only inside the *slice* field of :class:`Subscript`, either directly "
"or as an element of :class:`Tuple`."
msgstr ""
"Vanlig skärning (på formen ``lower:upper`` eller ``lower:upper:step``). Kan "
"endast förekomma i fältet *slice* i :class:`Subscript`, antingen direkt "
"eller som ett element i :class:`Tuple`."

#: ../../library/ast.rst:762
msgid ""
">>> print(ast.dump(ast.parse('l[1:2]', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Subscript(\n"
"        value=Name(id='l', ctx=Load()),\n"
"        slice=Slice(\n"
"            lower=Constant(value=1),\n"
"            upper=Constant(value=2)),\n"
"        ctx=Load()))"
msgstr ""
">>> print(ast.dump(ast.parse('l[1:2]', mode='eval'), indent=4))\n"
"Uttryck(\n"
"    body=Subskript(\n"
"        value=Namn(id='l', ctx=Load()),\n"
"        slice=Slice(\n"
"            lower=Konstant(värde=1),\n"
"            övre=Konstant(värde=2)),\n"
"        ctx=Load()))"

#: ../../library/ast.rst:775
msgid "Comprehensions"
msgstr "Förståelse"

#: ../../library/ast.rst:782
msgid ""
"List and set comprehensions, generator expressions, and dictionary "
"comprehensions. ``elt`` (or ``key`` and ``value``) is a single node "
"representing the part that will be evaluated for each item."
msgstr ""
"List- och set-förståelser, generatoruttryck och ordboksförståelser. ``elt`` "
"(eller ``key`` och ``value``) är en enda nod som representerar den del som "
"kommer att utvärderas för varje objekt."

#: ../../library/ast.rst:786
msgid "``generators`` is a list of :class:`comprehension` nodes."
msgstr "``generators`` är en lista av :class:`comprehension` noder."

#: ../../library/ast.rst:788
msgid ""
">>> print(ast.dump(\n"
"...     ast.parse('[x for x in numbers]', mode='eval'),\n"
"...     indent=4,\n"
"... ))\n"
"Expression(\n"
"    body=ListComp(\n"
"        elt=Name(id='x', ctx=Load()),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='x', ctx=Store()),\n"
"                iter=Name(id='numbers', ctx=Load()),\n"
"                is_async=0)]))\n"
">>> print(ast.dump(\n"
"...     ast.parse('{x: x**2 for x in numbers}', mode='eval'),\n"
"...     indent=4,\n"
"... ))\n"
"Expression(\n"
"    body=DictComp(\n"
"        key=Name(id='x', ctx=Load()),\n"
"        value=BinOp(\n"
"            left=Name(id='x', ctx=Load()),\n"
"            op=Pow(),\n"
"            right=Constant(value=2)),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='x', ctx=Store()),\n"
"                iter=Name(id='numbers', ctx=Load()),\n"
"                is_async=0)]))\n"
">>> print(ast.dump(\n"
"...     ast.parse('{x for x in numbers}', mode='eval'),\n"
"...     indent=4,\n"
"... ))\n"
"Expression(\n"
"    body=SetComp(\n"
"        elt=Name(id='x', ctx=Load()),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='x', ctx=Store()),\n"
"                iter=Name(id='numbers', ctx=Load()),\n"
"                is_async=0)]))"
msgstr ""
">>> print(ast.dump(\n"
"... ast.parse('[x för x i tal]', mode='eval'),\n"
"... indrag=4,\n"
"... ))\n"
"Uttryck(\n"
"    body=ListComp(\n"
"        elt=Namn(id='x', ctx=Load()),\n"
"        generatorer=[\n"
"            förståelse(\n"
"                target=Namn(id='x', ctx=Store()),\n"
"                iter=Name(id='numbers', ctx=Load()),\n"
"                is_async=0)]))\n"
">>> print(ast.dump(\n"
"... ast.parse('{x: x**2 for x in numbers}', mode='eval'),\n"
"... indrag=4,\n"
"... ))\n"
"Uttryck(\n"
"    body=DictComp(\n"
"        nyckel=Namn(id='x', ctx=Load()),\n"
"        värde=BinOp(\n"
"            left=Namn(id='x', ctx=Load()),\n"
"            op=Pow(),\n"
"            right=Konstant(värde=2)),\n"
"        generatorer=[\n"
"            förståelse(\n"
"                target=Namn(id='x', ctx=Store()),\n"
"                iter=Name(id='numbers', ctx=Load()),\n"
"                is_async=0)]))\n"
">>> print(ast.dump(\n"
"... ast.parse('{x för x i tal}', mode='eval'),\n"
"... indrag=4,\n"
"... ))\n"
"Uttryck(\n"
"    body=SetComp(\n"
"        elt=Namn(id='x', ctx=Load()),\n"
"        generatorer=[\n"
"            förståelse(\n"
"                target=Namn(id='x', ctx=Store()),\n"
"                iter=Name(id='numbers', ctx=Load()),\n"
"                is_async=0)]))"

#: ../../library/ast.rst:834
msgid ""
"One ``for`` clause in a comprehension. ``target`` is the reference to use "
"for each element - typically a :class:`Name` or :class:`Tuple` node. "
"``iter`` is the object to iterate over. ``ifs`` is a list of test "
"expressions: each ``for`` clause can have multiple ``ifs``."
msgstr ""
"En ``for``-sats i en förståelse. ``target`` är referensen som ska användas "
"för varje element - typiskt en :class:`Name` eller :class:`Tuple` nod. "
"``iter`` är det objekt som ska itereras över. ``ifs`` är en lista med "
"testuttryck: varje ``for``-klausul kan ha flera ``ifs``."

#: ../../library/ast.rst:839
msgid ""
"``is_async`` indicates a comprehension is asynchronous (using an ``async "
"for`` instead of ``for``). The value is an integer (0 or 1)."
msgstr ""
"``is_async`` indikerar att en förståelse är asynkron (använder en ``async "
"for`` istället för ``for``). Värdet är ett heltal (0 eller 1)."

#: ../../library/ast.rst:842
msgid ""
">>> print(ast.dump(ast.parse('[ord(c) for line in file for c in line]', "
"mode='eval'),\n"
"...                indent=4)) # Multiple comprehensions in one.\n"
"Expression(\n"
"    body=ListComp(\n"
"        elt=Call(\n"
"            func=Name(id='ord', ctx=Load()),\n"
"            args=[\n"
"                Name(id='c', ctx=Load())]),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='line', ctx=Store()),\n"
"                iter=Name(id='file', ctx=Load()),\n"
"                is_async=0),\n"
"            comprehension(\n"
"                target=Name(id='c', ctx=Store()),\n"
"                iter=Name(id='line', ctx=Load()),\n"
"                is_async=0)]))\n"
"\n"
">>> print(ast.dump(ast.parse('(n**2 for n in it if n>5 if n<10)', "
"mode='eval'),\n"
"...                indent=4)) # generator comprehension\n"
"Expression(\n"
"    body=GeneratorExp(\n"
"        elt=BinOp(\n"
"            left=Name(id='n', ctx=Load()),\n"
"            op=Pow(),\n"
"            right=Constant(value=2)),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='n', ctx=Store()),\n"
"                iter=Name(id='it', ctx=Load()),\n"
"                ifs=[\n"
"                    Compare(\n"
"                        left=Name(id='n', ctx=Load()),\n"
"                        ops=[\n"
"                            Gt()],\n"
"                        comparators=[\n"
"                            Constant(value=5)]),\n"
"                    Compare(\n"
"                        left=Name(id='n', ctx=Load()),\n"
"                        ops=[\n"
"                            Lt()],\n"
"                        comparators=[\n"
"                            Constant(value=10)])],\n"
"                is_async=0)]))\n"
"\n"
">>> print(ast.dump(ast.parse('[i async for i in soc]', mode='eval'),\n"
"...                indent=4)) # Async comprehension\n"
"Expression(\n"
"    body=ListComp(\n"
"        elt=Name(id='i', ctx=Load()),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='i', ctx=Store()),\n"
"                iter=Name(id='soc', ctx=Load()),\n"
"                is_async=1)]))"
msgstr ""
">>> print(ast.dump(ast.parse('[ord(c) for line in file for c in line]', "
"mode='eval'),\n"
"... indent=4)) # Flera förståelser i en.\n"
"Uttryck(\n"
"    kropp=ListComp(\n"
"        elt=Anrop(\n"
"            func=Name(id='ord', ctx=Load()),\n"
"            args=[\n"
"                Name(id='c', ctx=Load())]),\n"
"        generatorer=[\n"
"            förståelse(\n"
"                target=Namn(id='line', ctx=Store()),\n"
"                iter=Name(id='file', ctx=Load()),\n"
"                is_async=0),\n"
"            förståelse(\n"
"                target=Namn(id='c', ctx=Store()),\n"
"                iter=Name(id='line', ctx=Load()),\n"
"                is_async=0)]))\n"
"\n"
">>> print(ast.dump(ast.parse('(n**2 for n in it if n>5 if n<10)', "
"mode='eval'),\n"
"... indent=4)) # generatorförståelse\n"
"Uttryck(\n"
"    body=GeneratorExp(\n"
"        elt=BinOp(\n"
"            left=Namn(id='n', ctx=Load()),\n"
"            op=Pow(),\n"
"            right=Konstant(värde=2)),\n"
"        generatorer=[\n"
"            förståelse(\n"
"                target=Namn(id='n', ctx=Store()),\n"
"                iter=Namn(id='det', ctx=Load()),\n"
"                ifs=[\n"
"                    Jämför(\n"
"                        left=Namn(id='n', ctx=Load()),\n"
"                        ops=[\n"
"                            Gt()],\n"
"                        comparators=[\n"
"                            Konstant(värde=5)]),\n"
"                    Jämför(\n"
"                        left=Namn(id='n', ctx=Load()),\n"
"                        ops=[\n"
"                            Lt()],\n"
"                        comparators=[\n"
"                            Constant(värde=10)])],\n"
"                is_async=0)]))\n"
"\n"
">>> print(ast.dump(ast.parse('[i async for i in soc]', mode='eval'),\n"
"... indent=4)) # Asynkron förståelse\n"
"Uttryck(\n"
"    body=ListComp(\n"
"        elt=Namn(id='i', ctx=Load()),\n"
"        generatorer=[\n"
"            förståelse(\n"
"                target=Namn(id='i', ctx=Store()),\n"
"                iter=Name(id='soc', ctx=Load()),\n"
"                is_async=1)]))"

#: ../../library/ast.rst:904
msgid "Statements"
msgstr "Specifikation"

#: ../../library/ast.rst:908
msgid ""
"An assignment. ``targets`` is a list of nodes, and ``value`` is a single "
"node."
msgstr ""
"En tilldelning. ``targets`` är en lista med noder och ``value`` är en "
"enskild nod."

#: ../../library/ast.rst:910
msgid ""
"Multiple nodes in ``targets`` represents assigning the same value to each. "
"Unpacking is represented by putting a :class:`Tuple` or :class:`List` within "
"``targets``."
msgstr ""
"Flera noder i ``targets`` representerar att tilldela samma värde till alla. "
"Uppackning representeras genom att sätta en :class:`Tuple` eller :class:"
"`List` inom ``targets``."

#: ../../library/ast.rst:916 ../../library/ast.rst:1211
#: ../../library/ast.rst:1405 ../../library/ast.rst:1971
msgid ""
"``type_comment`` is an optional string with the type annotation as a comment."
msgstr ""
"``type_comment`` är en valfri sträng med typannoteringen som en kommentar."

#: ../../library/ast.rst:918
msgid ""
">>> print(ast.dump(ast.parse('a = b = 1'), indent=4)) # Multiple assignment\n"
"Module(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Name(id='a', ctx=Store()),\n"
"                Name(id='b', ctx=Store())],\n"
"            value=Constant(value=1))])\n"
"\n"
">>> print(ast.dump(ast.parse('a,b = c'), indent=4)) # Unpacking\n"
"Module(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Tuple(\n"
"                    elts=[\n"
"                        Name(id='a', ctx=Store()),\n"
"                        Name(id='b', ctx=Store())],\n"
"                    ctx=Store())],\n"
"            value=Name(id='c', ctx=Load()))])"
msgstr ""
">>> print(ast.dump(ast.parse('a = b = 1'), indent=4)) # Multipel "
"tilldelning\n"
"Modul(\n"
"    body=[\n"
"        Tilldela(\n"
"            mål=[\n"
"                Namn(id='a', ctx=Store()),\n"
"                Namn(id='b', ctx=Store())],\n"
"            värde=Konstant(värde=1))])\n"
"\n"
">>> print(ast.dump(ast.parse('a,b = c'), indent=4)) # Uppackning\n"
"Modul(\n"
"    body=[\n"
"        Tilldela(\n"
"            mål=[\n"
"                Tuple(\n"
"                    elts=[\n"
"                        Namn(id='a', ctx=Store()),\n"
"                        Namn(id='b', ctx=Store())],\n"
"                    ctx=Store())],\n"
"            value=Name(id='c', ctx=Load()))])"

#: ../../library/ast.rst:944
msgid ""
"An assignment with a type annotation. ``target`` is a single node and can be "
"a :class:`Name`, an :class:`Attribute` or a :class:`Subscript`. "
"``annotation`` is the annotation, such as a :class:`Constant` or :class:"
"`Name` node. ``value`` is a single optional node."
msgstr ""
"Ett uppdrag med en typannotering. ``target`` är en enskild nod och kan vara "
"en :class:`Name`, en :class:`Attribute` eller en :class:`Subscript`. "
"``annotation`` är annoteringen, t.ex. en nod av typen :class:`Constant` "
"eller :class:`Name`. ``value`` är en enskild valfri nod."

#: ../../library/ast.rst:949
msgid ""
"``simple`` is always either 0 (indicating a \"complex\" target) or 1 "
"(indicating a \"simple\" target). A \"simple\" target consists solely of a :"
"class:`Name` node that does not appear between parentheses; all other "
"targets are considered complex. Only simple targets appear in the :attr:"
"`~object.__annotations__` dictionary of modules and classes."
msgstr ""
"``simple`` är alltid antingen 0 (indikerar ett \"komplext\" mål) eller 1 "
"(indikerar ett \"enkelt\" mål). Ett \"enkelt\" mål består enbart av en :"
"class:`Name`-nod som inte förekommer inom parentes; alla andra mål betraktas "
"som komplexa. Endast enkla mål visas i :attr:`~object.__annotations__`-"
"ordlistan över moduler och klasser."

#: ../../library/ast.rst:955
msgid ""
">>> print(ast.dump(ast.parse('c: int'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        AnnAssign(\n"
"            target=Name(id='c', ctx=Store()),\n"
"            annotation=Name(id='int', ctx=Load()),\n"
"            simple=1)])\n"
"\n"
">>> print(ast.dump(ast.parse('(a): int = 1'), indent=4)) # Annotation with "
"parenthesis\n"
"Module(\n"
"    body=[\n"
"        AnnAssign(\n"
"            target=Name(id='a', ctx=Store()),\n"
"            annotation=Name(id='int', ctx=Load()),\n"
"            value=Constant(value=1),\n"
"            simple=0)])\n"
"\n"
">>> print(ast.dump(ast.parse('a.b: int'), indent=4)) # Attribute annotation\n"
"Module(\n"
"    body=[\n"
"        AnnAssign(\n"
"            target=Attribute(\n"
"                value=Name(id='a', ctx=Load()),\n"
"                attr='b',\n"
"                ctx=Store()),\n"
"            annotation=Name(id='int', ctx=Load()),\n"
"            simple=0)])\n"
"\n"
">>> print(ast.dump(ast.parse('a[1]: int'), indent=4)) # Subscript "
"annotation\n"
"Module(\n"
"    body=[\n"
"        AnnAssign(\n"
"            target=Subscript(\n"
"                value=Name(id='a', ctx=Load()),\n"
"                slice=Constant(value=1),\n"
"                ctx=Store()),\n"
"            annotation=Name(id='int', ctx=Load()),\n"
"            simple=0)])"
msgstr ""
">>> print(ast.dump(ast.parse('c: int'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        AnnAssign(\n"
"            target=Namn(id='c', ctx=Store()),\n"
"            annotation=Name(id='int', ctx=Load()),\n"
"            simple=1)])\n"
"\n"
">>> print(ast.dump(ast.parse('(a): int = 1'), indent=4)) # Annotation med "
"parentes\n"
"Modul(\n"
"    body=[\n"
"        AnnAssign(\n"
"            target=Namn(id='a', ctx=Store()),\n"
"            annotation=Namn(id='int', ctx=Load()),\n"
"            värde=Konstant(värde=1),\n"
"            simple=0)])\n"
"\n"
">>> print(ast.dump(ast.parse('a.b: int'), indent=4)) # Attributanteckning\n"
"Modul(\n"
"    body=[\n"
"        AnnAssign(\n"
"            mål=Attribut(\n"
"                value=Namn(id='a', ctx=Load()),\n"
"                attr='b',\n"
"                ctx=Store()),\n"
"            annotation=Name(id='int', ctx=Load()),\n"
"            simple=0)])\n"
"\n"
">>> print(ast.dump(ast.parse('a[1]: int'), indent=4)) # Subscript-"
"annotering\n"
"Modul(\n"
"    body=[\n"
"        AnnAssign(\n"
"            mål=Subscript(\n"
"                value=Namn(id='a', ctx=Load()),\n"
"                slice=Konstant(värde=1),\n"
"                ctx=Store()),\n"
"            annotation=Name(id='int', ctx=Load()),\n"
"            simple=0)])"

#: ../../library/ast.rst:999
msgid ""
"Augmented assignment, such as ``a += 1``. In the following example, "
"``target`` is a :class:`Name` node for ``x`` (with the :class:`Store` "
"context), ``op`` is :class:`Add`, and ``value`` is a :class:`Constant` with "
"value for 1."
msgstr ""
"Förstärkt tilldelning, t.ex. ``a += 1``. I följande exempel är ``target`` "
"en :class:`Name`-nod för ``x`` (med :class:`Store`-kontexten), ``op`` är :"
"class:`Add`, och ``value`` är en :class:`Constant` med värdet 1."

#: ../../library/ast.rst:1004
msgid ""
"The ``target`` attribute cannot be of class :class:`Tuple` or :class:`List`, "
"unlike the targets of :class:`Assign`."
msgstr ""
"Attributet ``target`` kan inte vara av klass :class:`Tuple` eller :class:"
"`List`, till skillnad från målen i :class:`Assign`."

#: ../../library/ast.rst:1007
msgid ""
">>> print(ast.dump(ast.parse('x += 2'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        AugAssign(\n"
"            target=Name(id='x', ctx=Store()),\n"
"            op=Add(),\n"
"            value=Constant(value=2))])"
msgstr ""
">>> print(ast.dump(ast.parse('x += 2'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        AugAssign(\n"
"            target=Namn(id='x', ctx=Store()),\n"
"            op=Add(),\n"
"            värde=Konstant(värde=2))])"

#: ../../library/ast.rst:1020
msgid ""
"A ``raise`` statement. ``exc`` is the exception object to be raised, "
"normally a :class:`Call` or :class:`Name`, or ``None`` for a standalone "
"``raise``. ``cause`` is the optional part for ``y`` in ``raise x from y``."
msgstr ""
"En ``raise``-sats. ``exc`` är undantagsobjektet som ska tas upp, normalt en :"
"class:`Call` eller :class:`Name`, eller ``None`` för en fristående "
"``raise``. ``cause`` är den valfria delen för ``y`` i ``raise x from y``."

#: ../../library/ast.rst:1024
msgid ""
">>> print(ast.dump(ast.parse('raise x from y'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Raise(\n"
"            exc=Name(id='x', ctx=Load()),\n"
"            cause=Name(id='y', ctx=Load()))])"
msgstr ""
">>> print(ast.dump(ast.parse('raise x from y'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        Höjning(\n"
"            exc=Namn(id='x', ctx=Load()),\n"
"            cause=Name(id='y', ctx=Load())))])"

#: ../../library/ast.rst:1036
msgid ""
"An assertion. ``test`` holds the condition, such as a :class:`Compare` node. "
"``msg`` holds the failure message."
msgstr ""
"Ett påstående. ``test`` innehåller villkoret, t.ex. en :class:`Compare`-nod. "
"``msg`` innehåller felmeddelandet."

#: ../../library/ast.rst:1039
msgid ""
">>> print(ast.dump(ast.parse('assert x,y'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Assert(\n"
"            test=Name(id='x', ctx=Load()),\n"
"            msg=Name(id='y', ctx=Load()))])"
msgstr ""
">>> print(ast.dump(ast.parse('assert x,y'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        Assert(\n"
"            test=Namn(id='x', ctx=Load()),\n"
"            msg=Namn(id='y', ctx=Load())))])"

#: ../../library/ast.rst:1051
msgid ""
"Represents a ``del`` statement. ``targets`` is a list of nodes, such as :"
"class:`Name`, :class:`Attribute` or :class:`Subscript` nodes."
msgstr ""
"Representerar en ``del``-sats. ``targets`` är en lista med noder, t.ex. "
"noderna :class:`Name`, :class:`Attribute` eller :class:`Subscript`."

#: ../../library/ast.rst:1054
msgid ""
">>> print(ast.dump(ast.parse('del x,y,z'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Delete(\n"
"            targets=[\n"
"                Name(id='x', ctx=Del()),\n"
"                Name(id='y', ctx=Del()),\n"
"                Name(id='z', ctx=Del())])])"
msgstr ""
">>> print(ast.dump(ast.parse('del x,y,z'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        Radera(\n"
"            mål=[\n"
"                Namn(id='x', ctx=Del()),\n"
"                Namn(id='y', ctx=Del()),\n"
"                Name(id='z', ctx=Del()))])])"

#: ../../library/ast.rst:1068
msgid "A ``pass`` statement."
msgstr "Ett \"godkänt\" uttalande."

#: ../../library/ast.rst:1070
msgid ""
">>> print(ast.dump(ast.parse('pass'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Pass()])"
msgstr ""
">>> print(ast.dump(ast.parse('pass'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        Pass()])"

#: ../../library/ast.rst:1080
msgid ""
"A :ref:`type alias <type-aliases>` created through the :keyword:`type` "
"statement. ``name`` is the name of the alias, ``type_params`` is a list of :"
"ref:`type parameters <ast-type-params>`, and ``value`` is the value of the "
"type alias."
msgstr ""
"Ett :ref:`type-alias <type-aliases>` som skapas genom :keyword:`type`-"
"satsen. ``name`` är namnet på aliaset, ``type_params`` är en lista med :ref:"
"`type-parametrar <ast-type-params>`, och ``value`` är värdet på typaliaset."

#: ../../library/ast.rst:1085
msgid ""
">>> print(ast.dump(ast.parse('type Alias = int'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        TypeAlias(\n"
"            name=Name(id='Alias', ctx=Store()),\n"
"            value=Name(id='int', ctx=Load()))])"
msgstr ""
">>> print(ast.dump(ast.parse('typ Alias = int'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        TypAlias(\n"
"            name=Namn(id='Alias', ctx=Store()),\n"
"            value=Name(id='int', ctx=Load())))])"

#: ../../library/ast.rst:1096
msgid ""
"Other statements which are only applicable inside functions or loops are "
"described in other sections."
msgstr ""
"Andra uttalanden som endast är tillämpliga inom funktioner eller loopar "
"beskrivs i andra avsnitt."

#: ../../library/ast.rst:1100
msgid "Imports"
msgstr "Importera"

#: ../../library/ast.rst:1104
msgid "An import statement. ``names`` is a list of :class:`alias` nodes."
msgstr "En importförklaring. ``names`` är en lista med :class:`alias`-noder."

#: ../../library/ast.rst:1106
msgid ""
">>> print(ast.dump(ast.parse('import x,y,z'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Import(\n"
"            names=[\n"
"                alias(name='x'),\n"
"                alias(name='y'),\n"
"                alias(name='z')])])"
msgstr ""
">>> print(ast.dump(ast.parse('import x,y,z'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        Import(\n"
"            namn=[\n"
"                alias(name='x'),\n"
"                alias(name='y'),\n"
"                alias(name='z')])])"

#: ../../library/ast.rst:1120
msgid ""
"Represents ``from x import y``. ``module`` is a raw string of the 'from' "
"name, without any leading dots, or ``None`` for statements such as ``from . "
"import foo``. ``level`` is an integer holding the level of the relative "
"import (0 means absolute import)."
msgstr ""
"Representerar ``from x import y``. ``module`` är en rå sträng av 'from'-"
"namnet, utan några inledande punkter, eller ``None`` för uttalanden som "
"``from . import foo``. ``level`` är ett heltal som anger nivån på den "
"relativa importen (0 betyder absolut import)."

#: ../../library/ast.rst:1125
msgid ""
">>> print(ast.dump(ast.parse('from y import x,y,z'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        ImportFrom(\n"
"            module='y',\n"
"            names=[\n"
"                alias(name='x'),\n"
"                alias(name='y'),\n"
"                alias(name='z')],\n"
"            level=0)])"
msgstr ""
">>> print(ast.dump(ast.parse('from y import x,y,z'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        ImportFrom(\n"
"            modul='y',\n"
"            namn=[\n"
"                alias(name='x'),\n"
"                alias(name='y'),\n"
"                alias(name='z')],\n"
"            nivå=0)])"

#: ../../library/ast.rst:1141
msgid ""
"Both parameters are raw strings of the names. ``asname`` can be ``None`` if "
"the regular name is to be used."
msgstr ""
"Båda parametrarna är råa strängar av namnen. ``asname`` kan vara ``None`` om "
"det vanliga namnet ska användas."

#: ../../library/ast.rst:1144
msgid ""
">>> print(ast.dump(ast.parse('from ..foo.bar import a as b, c'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        ImportFrom(\n"
"            module='foo.bar',\n"
"            names=[\n"
"                alias(name='a', asname='b'),\n"
"                alias(name='c')],\n"
"            level=2)])"
msgstr ""
">>> print(ast.dump(ast.parse('from ..foo.bar import a as b, c'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        ImportFrom(\n"
"            modul='foo.bar',\n"
"            namn=[\n"
"                alias(name='a', asname='b'),\n"
"                alias(name='c')],\n"
"            nivå=2)])"

#: ../../library/ast.rst:1157
msgid "Control flow"
msgstr "Kontrollflöde"

#: ../../library/ast.rst:1160
msgid ""
"Optional clauses such as ``else`` are stored as an empty list if they're not "
"present."
msgstr ""
"Valfria klausuler som ``else`` lagras som en tom lista om de inte finns med."

#: ../../library/ast.rst:1165
msgid ""
"An ``if`` statement. ``test`` holds a single node, such as a :class:"
"`Compare` node. ``body`` and ``orelse`` each hold a list of nodes."
msgstr ""
"En ``if``-sats. ``test`` innehåller en enda nod, t.ex. en :class:`Compare`-"
"nod. ``body`` och ``orelse`` innehåller var och en en lista med noder."

#: ../../library/ast.rst:1168
msgid ""
"``elif`` clauses don't have a special representation in the AST, but rather "
"appear as extra :class:`If` nodes within the ``orelse`` section of the "
"previous one."
msgstr ""
"``elif``-klausuler har ingen speciell representation i AST, utan visas "
"snarare som extra :class:`If`-noder i ``orelse``-avsnittet i det föregående."

#: ../../library/ast.rst:1172
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... if x:\n"
"...    ...\n"
"... elif y:\n"
"...    ...\n"
"... else:\n"
"...    ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        If(\n"
"            test=Name(id='x', ctx=Load()),\n"
"            body=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            orelse=[\n"
"                If(\n"
"                    test=Name(id='y', ctx=Load()),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))],\n"
"                    orelse=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... om x:\n"
"... ...\n"
"... elif y:\n"
"... ...\n"
"... annat:\n"
"... ...\n"
"... \"\"\"), indrag=4))\n"
"Modul(\n"
"    body=[\n"
"        Om(\n"
"            test=Namn(id='x', ctx=Load()),\n"
"            body=[\n"
"                Expr(\n"
"                    värde=Konstant(värde=Ellipsis))],\n"
"            orelse=[\n"
"                Om(\n"
"                    test=Namn(id='y', ctx=Load()),\n"
"                    body=[\n"
"                        Expr(\n"
"                            värde=Konstant(värde=Ellipsis))],\n"
"                    orelse=[\n"
"                        Expr(\n"
"                            värde=Konstant(värde=Ellipsis))])])]])"

#: ../../library/ast.rst:1202
msgid ""
"A ``for`` loop. ``target`` holds the variable(s) the loop assigns to, as a "
"single :class:`Name`, :class:`Tuple`, :class:`List`, :class:`Attribute` or :"
"class:`Subscript` node. ``iter`` holds the item to be looped over, again as "
"a single node. ``body`` and ``orelse`` contain lists of nodes to execute. "
"Those in ``orelse`` are executed if the loop finishes normally, rather than "
"via a ``break`` statement."
msgstr ""
"En ``for``-slinga. ``target`` innehåller variabeln/variablerna som loopen "
"tilldelar, som en enskild :class:`Name`, :class:`Tuple`, :class:`List`, :"
"class:`Attribute` eller :class:`Subscript` nod. ``iter`` innehåller det "
"objekt som ska loopas över, återigen som en enda nod. ``body`` och "
"``orelse`` innehåller listor över noder som ska köras. De i ``orelse`` "
"exekveras om loopen avslutas på normalt sätt, snarare än via en ``break``-"
"sats."

#: ../../library/ast.rst:1213
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... for x in y:\n"
"...     ...\n"
"... else:\n"
"...     ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        For(\n"
"            target=Name(id='x', ctx=Store()),\n"
"            iter=Name(id='y', ctx=Load()),\n"
"            body=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            orelse=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... för x i y:\n"
"... ...\n"
"... annat:\n"
"... ...\n"
"... \"\"\"), indrag=4))\n"
"Modul(\n"
"    body=[\n"
"        För(\n"
"            target=Namn(id='x', ctx=Store()),\n"
"            iter=Name(id='y', ctx=Load()),\n"
"            body=[\n"
"                Expr(\n"
"                    värde=Konstant(värde=Ellipsis))],\n"
"            orelse=[\n"
"                Expr(\n"
"                    värde=Konstant(värde=Ellipsis))])])"

#: ../../library/ast.rst:1236
msgid ""
"A ``while`` loop. ``test`` holds the condition, such as a :class:`Compare` "
"node."
msgstr ""
"En ``while``-loop. ``test`` innehåller villkoret, t.ex. en :class:`Compare`-"
"nod."

#: ../../library/ast.rst:1239
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... while x:\n"
"...    ...\n"
"... else:\n"
"...    ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        While(\n"
"            test=Name(id='x', ctx=Load()),\n"
"            body=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            orelse=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... medan x:\n"
"... ...\n"
"... annat:\n"
"... ...\n"
"... \"\"\"), indrag=4))\n"
"Modul(\n"
"    body=[\n"
"        Medan(\n"
"            test=Namn(id='x', ctx=Load()),\n"
"            body=[\n"
"                Expr(\n"
"                    värde=Konstant(värde=Ellipsis))],\n"
"            orelse=[\n"
"                Expr(\n"
"                    värde=Konstant(värde=Ellipsis))])])"

#: ../../library/ast.rst:1262
msgid "The ``break`` and ``continue`` statements."
msgstr "Uttalandena ``bryt`` och ``fortsätt``."

#: ../../library/ast.rst:1264
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... for a in b:\n"
"...     if a > 5:\n"
"...         break\n"
"...     else:\n"
"...         continue\n"
"...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        For(\n"
"            target=Name(id='a', ctx=Store()),\n"
"            iter=Name(id='b', ctx=Load()),\n"
"            body=[\n"
"                If(\n"
"                    test=Compare(\n"
"                        left=Name(id='a', ctx=Load()),\n"
"                        ops=[\n"
"                            Gt()],\n"
"                        comparators=[\n"
"                            Constant(value=5)]),\n"
"                    body=[\n"
"                        Break()],\n"
"                    orelse=[\n"
"                        Continue()])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... för a i b:\n"
"... om a > 5:\n"
"... break\n"
"... annars:\n"
"... fortsätt\n"
"...\n"
"... \"\"\"), indrag=4))\n"
"Modul(\n"
"    body=[\n"
"        För(\n"
"            target=Namn(id='a', ctx=Store()),\n"
"            iter=Name(id='b', ctx=Load()),\n"
"            body=[\n"
"                Om(\n"
"                    test=Jämför(\n"
"                        left=Name(id='a', ctx=Load()),\n"
"                        ops=[\n"
"                            Gt()],\n"
"                        comparators=[\n"
"                            Constant(värde=5)]),\n"
"                    body=[\n"
"                        Break()],\n"
"                    orelse=[\n"
"                        Fortsätt()])])])"

#: ../../library/ast.rst:1295
msgid ""
"``try`` blocks. All attributes are list of nodes to execute, except for "
"``handlers``, which is a list of :class:`ExceptHandler` nodes."
msgstr ""
"``försök`` block. Alla attribut är listor över noder som ska köras, utom "
"``handlers``, som är en lista över :class:`ExceptHandler`-noder."

#: ../../library/ast.rst:1298
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... try:\n"
"...    ...\n"
"... except Exception:\n"
"...    ...\n"
"... except OtherException as e:\n"
"...    ...\n"
"... else:\n"
"...    ...\n"
"... finally:\n"
"...    ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Try(\n"
"            body=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            handlers=[\n"
"                ExceptHandler(\n"
"                    type=Name(id='Exception', ctx=Load()),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                ExceptHandler(\n"
"                    type=Name(id='OtherException', ctx=Load()),\n"
"                    name='e',\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])],\n"
"            orelse=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            finalbody=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... försök:\n"
"... ...\n"
"... utom Exception:\n"
"... ...\n"
"... förutom OtherException som e:\n"
"... ...\n"
"... else:\n"
"... ...\n"
"... slutligen:\n"
"... ...\n"
"... \"\"\"), indrag=4))\n"
"Modul(\n"
"    body=[\n"
"        Försök(\n"
"            kropp=[\n"
"                Expr(\n"
"                    värde=Konstant(värde=Ellipsis))],\n"
"            handlers=[\n"
"                UndantagHandler(\n"
"                    type=Name(id='Exception', ctx=Load()),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Konstant(value=Ellipsis))]),\n"
"                ExceptHandler(\n"
"                    type=Name(id='OtherException', ctx=Load()),\n"
"                    name='e',\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Konstant(value=Ellipsis)))])],\n"
"            orelse=[\n"
"                Expr(\n"
"                    värde=Konstant(värde=Ellipsis))],\n"
"            slutkropp=[\n"
"                Expr(\n"
"                    värde=Konstant(värde=Ellipsis))])]])"

#: ../../library/ast.rst:1340
msgid ""
"``try`` blocks which are followed by ``except*`` clauses. The attributes are "
"the same as for :class:`Try` but the :class:`ExceptHandler` nodes in "
"``handlers`` are interpreted as ``except*`` blocks rather then ``except``."
msgstr ""
"``try``-block som följs av ``except*``-klausuler. Attributen är desamma som "
"för :class:`Try` men :class:`ExceptHandler`-noderna i ``handlers`` tolkas "
"som ``except*`-block i stället för ``except``."

#: ../../library/ast.rst:1344
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... try:\n"
"...    ...\n"
"... except* Exception:\n"
"...    ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        TryStar(\n"
"            body=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            handlers=[\n"
"                ExceptHandler(\n"
"                    type=Name(id='Exception', ctx=Load()),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... försök:\n"
"... ...\n"
"... except* Undantag:\n"
"... ...\n"
"... \"\"\"), indrag=4))\n"
"Modul(\n"
"    body=[\n"
"        TryStar(\n"
"            kropp=[\n"
"                Expr(\n"
"                    värde=Konstant(värde=Ellipsis))],\n"
"            handlers=[\n"
"                UndantagHandler(\n"
"                    type=Name(id='Exception', ctx=Load()),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Konstant(value=Ellipsis))])])])])"

#: ../../library/ast.rst:1369
msgid ""
"A single ``except`` clause. ``type`` is the exception type it will match, "
"typically a :class:`Name` node (or ``None`` for a catch-all ``except:`` "
"clause). ``name`` is a raw string for the name to hold the exception, or "
"``None`` if the clause doesn't have ``as foo``. ``body`` is a list of nodes."
msgstr ""
"En enda ``except`` klausul. ``type`` är undantagstypen som den kommer att "
"matcha, vanligtvis en :class:`Name` nod (eller ``None`` för en catch-all "
"``except:`` klausul). ``name`` är en rå sträng för namnet på undantaget, "
"eller ``None`` om klausulen inte har ``as foo``. ``body`` är en lista med "
"noder."

#: ../../library/ast.rst:1374
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... try:\n"
"...     a + 1\n"
"... except TypeError:\n"
"...     pass\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Try(\n"
"            body=[\n"
"                Expr(\n"
"                    value=BinOp(\n"
"                        left=Name(id='a', ctx=Load()),\n"
"                        op=Add(),\n"
"                        right=Constant(value=1)))],\n"
"            handlers=[\n"
"                ExceptHandler(\n"
"                    type=Name(id='TypeError', ctx=Load()),\n"
"                    body=[\n"
"                        Pass()])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\\\"\")\n"
"... försök:\n"
"... a + 1\n"
"... förutom TypeError:\n"
"... pass\n"
"... \"\"\"), indrag=4))\n"
"Modul(\n"
"    body=[\n"
"        Försök(\n"
"            kropp=[\n"
"                Expr(\n"
"                    värde=BinOp(\n"
"                        left=Namn(id='a', ctx=Load()),\n"
"                        op=Add(),\n"
"                        right=Konstant(värde=1)))],\n"
"            handlers=[\n"
"                UndantagHandler(\n"
"                    type=Name(id='TypeError', ctx=Load()),\n"
"                    body=[\n"
"                        Pass()])])])"

#: ../../library/ast.rst:1400
msgid ""
"A ``with`` block. ``items`` is a list of :class:`withitem` nodes "
"representing the context managers, and ``body`` is the indented block inside "
"the context."
msgstr ""
"Ett ``with``-block. ``items`` är en lista med :class:`withitem`-noder som "
"representerar kontexthanterarna, och ``body`` är det indragna blocket inuti "
"kontexten."

#: ../../library/ast.rst:1410
msgid ""
"A single context manager in a ``with`` block. ``context_expr`` is the "
"context manager, often a :class:`Call` node. ``optional_vars`` is a :class:"
"`Name`, :class:`Tuple` or :class:`List` for the ``as foo`` part, or ``None`` "
"if that isn't used."
msgstr ""
"En enda kontexthanterare i ett ``with``-block. ``context_expr`` är "
"kontexthanteraren, ofta en :class:`Call` nod. ``optional_vars`` är en :class:"
"`Name`, :class:`Tuple` eller :class:`List` för ``as foo`` delen, eller "
"``None`` om det inte används."

#: ../../library/ast.rst:1415
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... with a as b, c as d:\n"
"...    something(b, d)\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        With(\n"
"            items=[\n"
"                withitem(\n"
"                    context_expr=Name(id='a', ctx=Load()),\n"
"                    optional_vars=Name(id='b', ctx=Store())),\n"
"                withitem(\n"
"                    context_expr=Name(id='c', ctx=Load()),\n"
"                    optional_vars=Name(id='d', ctx=Store()))],\n"
"            body=[\n"
"                Expr(\n"
"                    value=Call(\n"
"                        func=Name(id='something', ctx=Load()),\n"
"                        args=[\n"
"                            Name(id='b', ctx=Load()),\n"
"                            Name(id='d', ctx=Load())]))])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... med a som b, c som d:\n"
"... något(b, d)\n"
"... \"\"\"), indrag=4))\n"
"Modul(\n"
"    body=[\n"
"        Med(\n"
"            objekt=[\n"
"                medobjekt(\n"
"                    context_expr=Namn(id='a', ctx=Load()),\n"
"                    optional_vars=Name(id='b', ctx=Store())),\n"
"                medobjekt(\n"
"                    context_expr=Name(id='c', ctx=Load()), "
"optional_vars=Name(id='b', ctx=Store())\n"
"                    optional_vars=Name(id='d', ctx=Store()))],\n"
"            body=[\n"
"                Expr(\n"
"                    värde=Anrop(\n"
"                        func=Name(id='något', ctx=Load()),\n"
"                        args=[\n"
"                            Namn(id='b', ctx=Load()),\n"
"                            Name(id='d', ctx=Load())]))])])])"

#: ../../library/ast.rst:1441
msgid "Pattern matching"
msgstr "Mönstermatchning"

#: ../../library/ast.rst:1446
msgid ""
"A ``match`` statement. ``subject`` holds the subject of the match (the "
"object that is being matched against the cases) and ``cases`` contains an "
"iterable of :class:`match_case` nodes with the different cases."
msgstr ""
"En ``match``-sats. ``subject`` innehåller ämnet för matchningen (det objekt "
"som matchas mot fallen) och ``cases`` innehåller en iterabel av :class:"
"`match_case`-noder med de olika fallen."

#: ../../library/ast.rst:1454
msgid ""
"A single case pattern in a ``match`` statement. ``pattern`` contains the "
"match pattern that the subject will be matched against. Note that the :class:"
"`AST` nodes produced for patterns differ from those produced for "
"expressions, even when they share the same syntax."
msgstr ""
"Ett enskilt fallmönster i en ``match``-sats. ``pattern`` innehåller det "
"matchningsmönster som ämnet kommer att matchas mot. Observera att de :class:"
"`AST`-noder som produceras för mönster skiljer sig från dem som produceras "
"för uttryck, även om de har samma syntax."

#: ../../library/ast.rst:1459
msgid ""
"The ``guard`` attribute contains an expression that will be evaluated if the "
"pattern matches the subject."
msgstr ""
"Attributet ``guard`` innehåller ett uttryck som kommer att utvärderas om "
"mönstret matchar ämnet."

#: ../../library/ast.rst:1462
msgid ""
"``body`` contains a list of nodes to execute if the pattern matches and the "
"result of evaluating the guard expression is true."
msgstr ""
"``body`` innehåller en lista med noder som ska köras om mönstret matchar och "
"resultatet av utvärderingen av guard-uttrycket är sant."

#: ../../library/ast.rst:1465
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case [x] if x>0:\n"
"...         ...\n"
"...     case tuple():\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchSequence(\n"
"                        patterns=[\n"
"                            MatchAs(name='x')]),\n"
"                    guard=Compare(\n"
"                        left=Name(id='x', ctx=Load()),\n"
"                        ops=[\n"
"                            Gt()],\n"
"                        comparators=[\n"
"                            Constant(value=0)]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchClass(\n"
"                        cls=Name(id='tuple', ctx=Load())),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... matcha x:\n"
"... case [x] if x>0:\n"
"... ...\n"
"... fall tuple():\n"
"... ...\n"
"... \"\"\"), indrag=4))\n"
"Modul(\n"
"    kropp=[\n"
"        Matchning(\n"
"            subject=Namn(id='x', ctx=Load()),\n"
"            fall=[\n"
"                match_case(\n"
"                    pattern=Matcha sekvens(\n"
"                        mönster=[\n"
"                            MatchAs(name='x')]),\n"
"                    guard=Jämförelse(\n"
"                        left=Namn(id='x', ctx=Load()),\n"
"                        ops=[\n"
"                            Gt()],\n"
"                        comparators=[\n"
"                            Konstant(värde=0)]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            värde=Konstant(värde=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchClass(\n"
"                        cls=Name(id='tuple', ctx=Load())),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Konstant(value=Ellipsis))])])])])"

#: ../../library/ast.rst:1503
msgid ""
"A match literal or value pattern that compares by equality. ``value`` is an "
"expression node. Permitted value nodes are restricted as described in the "
"match statement documentation. This pattern succeeds if the match subject is "
"equal to the evaluated value."
msgstr ""
"Ett matchande bokstavs- eller värdemönster som jämförs genom likhet. "
"``value`` är en uttrycksnod. Tillåtna värdenoder är begränsade enligt "
"beskrivningen i dokumentationen för match-satsen. Det här mönstret lyckas om "
"matchningsobjektet är lika med det utvärderade värdet."

#: ../../library/ast.rst:1508
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case \"Relevant\":\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchValue(\n"
"                        value=Constant(value='Relevant')),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... matcha x:\n"
"... fall \"Relevant\":\n"
"... ...\n"
"... \"\"\"), indrag=4))\n"
"Modul(\n"
"    kropp=[\n"
"        Matchning(\n"
"            subject=Namn(id='x', ctx=Load()),\n"
"            fall=[\n"
"                match_case(\n"
"                    pattern=Matchvärde(\n"
"                        value=Konstant(value='Relevant')),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Konstant(value=Ellipsis))])])]])"

#: ../../library/ast.rst:1531
msgid ""
"A match literal pattern that compares by identity. ``value`` is the "
"singleton to be compared against: ``None``, ``True``, or ``False``. This "
"pattern succeeds if the match subject is the given constant."
msgstr ""
"Ett litterärt matchningsmönster som jämför med identitet. ``value`` är den "
"singleton som ska jämföras mot: ``None``, ``True``, eller ``False``. Detta "
"mönster lyckas om matchningsobjektet är den givna konstanten."

#: ../../library/ast.rst:1535
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case None:\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchSingleton(value=None),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"... fall Ingen:\n"
"... ...\n"
"... \"\"\"), indrag=4))\n"
"Modul(\n"
"    body=[\n"
"        Matchning(\n"
"            subject=Namn(id='x', ctx=Load()),\n"
"            fall=[\n"
"                match_case(\n"
"                    pattern=MatchSingleton(value=None),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Konstant(value=Ellipsis))])])]])"

#: ../../library/ast.rst:1557
msgid ""
"A match sequence pattern. ``patterns`` contains the patterns to be matched "
"against the subject elements if the subject is a sequence. Matches a "
"variable length sequence if one of the subpatterns is a ``MatchStar`` node, "
"otherwise matches a fixed length sequence."
msgstr ""
"Ett matchningsmönster för en sekvens. ``patterns`` innehåller de mönster som "
"ska matchas mot ämneselementen om ämnet är en sekvens. Matchar en sekvens "
"med variabel längd om ett av undermönstren är en ``MatchStar``-nod, annars "
"matchas en sekvens med fast längd."

#: ../../library/ast.rst:1562
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case [1, 2]:\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchSequence(\n"
"                        patterns=[\n"
"                            MatchValue(\n"
"                                value=Constant(value=1)),\n"
"                            MatchValue(\n"
"                                value=Constant(value=2))]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... matcha x:\n"
"... fall [1, 2]:\n"
"... ...\n"
"... \"\"\"), indrag=4))\n"
"Modul(\n"
"    kropp=[\n"
"        Matchning(\n"
"            subject=Namn(id='x', ctx=Load()),\n"
"            fall=[\n"
"                match_case(\n"
"                    pattern=Matcha sekvens(\n"
"                        mönster=[\n"
"                            MatchValue(\n"
"                                värde=Konstant(värde=1)),\n"
"                            MatchValue(\n"
"                                värde=Konstant(värde=2))]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Konstant(value=Ellipsis))])])]])"

#: ../../library/ast.rst:1589
msgid ""
"Matches the rest of the sequence in a variable length match sequence "
"pattern. If ``name`` is not ``None``, a list containing the remaining "
"sequence elements is bound to that name if the overall sequence pattern is "
"successful."
msgstr ""
"Matchar resten av sekvensen i ett matchsekvensmönster med variabel längd. Om "
"``name`` inte är ``None``, binds en lista som innehåller de återstående "
"sekvenselementen till det namnet om det övergripande sekvensmönstret är "
"framgångsrikt."

#: ../../library/ast.rst:1593
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case [1, 2, *rest]:\n"
"...         ...\n"
"...     case [*_]:\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchSequence(\n"
"                        patterns=[\n"
"                            MatchValue(\n"
"                                value=Constant(value=1)),\n"
"                            MatchValue(\n"
"                                value=Constant(value=2)),\n"
"                            MatchStar(name='rest')]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchSequence(\n"
"                        patterns=[\n"
"                            MatchStar()]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... matcha x:\n"
"... fall [1, 2, *rest]:\n"
"... ...\n"
"... fall [*_]:\n"
"... ...\n"
"... \"\"\"), indent=4))\n"
"Modul(\n"
"    kropp=[\n"
"        Matchning(\n"
"            subject=Namn(id='x', ctx=Load()),\n"
"            fall=[\n"
"                match_case(\n"
"                    pattern=Matcha sekvens(\n"
"                        mönster=[\n"
"                            MatchValue(\n"
"                                värde=Konstant(värde=1)),\n"
"                            MatchValue(\n"
"                                värde=Konstant(värde=2)),\n"
"                            MatchStar(name='rest')]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Konstant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=Matcha sekvens(\n"
"                        mönster=[\n"
"                            MatchStar()]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Konstant(value=Ellipsis))])])])])"

#: ../../library/ast.rst:1630
msgid ""
"A match mapping pattern. ``keys`` is a sequence of expression nodes. "
"``patterns`` is a corresponding sequence of pattern nodes. ``rest`` is an "
"optional name that can be specified to capture the remaining mapping "
"elements. Permitted key expressions are restricted as described in the match "
"statement documentation."
msgstr ""
"Ett matchande mappningsmönster. ``keys`` är en sekvens av uttrycksnoder. "
"``patterns`` är en motsvarande sekvens av mönsternoder. ``rest`` är ett "
"valfritt namn som kan anges för att fånga de återstående mappningselementen. "
"Tillåtna nyckeluttryck begränsas på det sätt som beskrivs i dokumentationen "
"för match statement."

#: ../../library/ast.rst:1636
msgid ""
"This pattern succeeds if the subject is a mapping, all evaluated key "
"expressions are present in the mapping, and the value corresponding to each "
"key matches the corresponding subpattern. If ``rest`` is not ``None``, a "
"dict containing the remaining mapping elements is bound to that name if the "
"overall mapping pattern is successful."
msgstr ""
"Detta mönster lyckas om ämnet är en mappning, alla utvärderade nyckeluttryck "
"finns i mappningen och värdet som motsvarar varje nyckel matchar motsvarande "
"undermönster. Om ``rest`` inte är ``None``, binds en dict som innehåller de "
"återstående mappningselementen till namnet om det övergripande "
"mappningsmönstret är framgångsrikt."

#: ../../library/ast.rst:1642
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case {1: _, 2: _}:\n"
"...         ...\n"
"...     case {**rest}:\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchMapping(\n"
"                        keys=[\n"
"                            Constant(value=1),\n"
"                            Constant(value=2)],\n"
"                        patterns=[\n"
"                            MatchAs(),\n"
"                            MatchAs()]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchMapping(rest='rest'),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... matcha x:\n"
"... fall {1: _, 2: _}:\n"
"... ...\n"
"... fall {**rest}:\n"
"... ...\n"
"... \"\"\"), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        Matchning(\n"
"            subject=Namn(id='x', ctx=Load()),\n"
"            fall=[\n"
"                match_case(\n"
"                    mönster=MatchMapping(\n"
"                        nycklar=[\n"
"                            Konstant(värde=1),\n"
"                            Konstant(värde=2)],\n"
"                        patterns=[\n"
"                            MatchAs(),\n"
"                            MatchAs()]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Konstant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchMapping(rest='rest'),\n"
"                    body=[\n"
"                        Expr(\n"
"                            värde=Konstant(värde=Ellipsis))])])]])"

#: ../../library/ast.rst:1677
msgid ""
"A match class pattern. ``cls`` is an expression giving the nominal class to "
"be matched. ``patterns`` is a sequence of pattern nodes to be matched "
"against the class defined sequence of pattern matching attributes. "
"``kwd_attrs`` is a sequence of additional attributes to be matched "
"(specified as keyword arguments in the class pattern), ``kwd_patterns`` are "
"the corresponding patterns (specified as keyword values in the class "
"pattern)."
msgstr ""
"Ett matchningsmönster för klass. ``cls`` är ett uttryck som anger den "
"nominella klass som skall matchas. ``patterns`` är en sekvens av "
"mönsternoder som skall matchas mot den klassdefinierade sekvensen av "
"attribut för mönstermatchning. ``kwd_attrs`` är en sekvens av ytterligare "
"attribut som skall matchas (specificerade som nyckelordsargument i "
"klassmönstret), ``kwd_patterns`` är motsvarande mönster (specificerade som "
"nyckelordsvärden i klassmönstret)."

#: ../../library/ast.rst:1684
msgid ""
"This pattern succeeds if the subject is an instance of the nominated class, "
"all positional patterns match the corresponding class-defined attributes, "
"and any specified keyword attributes match their corresponding pattern."
msgstr ""
"Detta mönster lyckas om ämnet är en instans av den nominerade klassen, alla "
"positionsmönster matchar motsvarande klassdefinierade attribut och alla "
"angivna nyckelordsattribut matchar motsvarande mönster."

#: ../../library/ast.rst:1688
msgid ""
"Note: classes may define a property that returns self in order to match a "
"pattern node against the instance being matched. Several builtin types are "
"also matched that way, as described in the match statement documentation."
msgstr ""
"Observera: Klasser kan definiera en egenskap som returnerar self för att "
"matcha en mönsternod mot den instans som ska matchas. Flera inbyggda typer "
"matchas också på detta sätt, vilket beskrivs i dokumentationen för match "
"statement."

#: ../../library/ast.rst:1692
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case Point2D(0, 0):\n"
"...         ...\n"
"...     case Point3D(x=0, y=0, z=0):\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchClass(\n"
"                        cls=Name(id='Point2D', ctx=Load()),\n"
"                        patterns=[\n"
"                            MatchValue(\n"
"                                value=Constant(value=0)),\n"
"                            MatchValue(\n"
"                                value=Constant(value=0))]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchClass(\n"
"                        cls=Name(id='Point3D', ctx=Load()),\n"
"                        kwd_attrs=[\n"
"                            'x',\n"
"                            'y',\n"
"                            'z'],\n"
"                        kwd_patterns=[\n"
"                            MatchValue(\n"
"                                value=Constant(value=0)),\n"
"                            MatchValue(\n"
"                                value=Constant(value=0)),\n"
"                            MatchValue(\n"
"                                value=Constant(value=0))]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... matcha x:\n"
"... fall Point2D(0, 0):\n"
"... ...\n"
"... case Point3D(x=0, y=0, z=0):\n"
"... ...\n"
"... \"\"\"), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        Matchning(\n"
"            subject=Namn(id='x', ctx=Load()),\n"
"            fall=[\n"
"                match_case(\n"
"                    mönster=MatchClass(\n"
"                        cls=Name(id='Point2D', ctx=Load()),\n"
"                        patterns=[\n"
"                            MatchValue(\n"
"                                värde=Konstant(värde=0)),\n"
"                            MatchValue(\n"
"                                värde=Konstant(värde=0))]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Konstant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchClass(\n"
"                        cls=Namn(id='Point3D', ctx=Load()),\n"
"                        kwd_attrs=[\n"
"                            'x',\n"
"                            'y',\n"
"                            'z'],\n"
"                        kwd_patterns=[\n"
"                            MatchValue(\n"
"                                värde=Konstant(värde=0)),\n"
"                            MatchValue(\n"
"                                värde=Konstant(värde=0)),\n"
"                            MatchValue(\n"
"                                värde=Konstant(värde=0))]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Konstant(value=Ellipsis))])])])])"

#: ../../library/ast.rst:1739
msgid ""
"A match \"as-pattern\", capture pattern or wildcard pattern. ``pattern`` "
"contains the match pattern that the subject will be matched against. If the "
"pattern is ``None``, the node represents a capture pattern (i.e a bare name) "
"and will always succeed."
msgstr ""
"En matchning \"som mönster\", fångstmönster eller jokerteckenmönster. "
"``pattern`` innehåller det matchningsmönster som ämnet kommer att matchas "
"mot. Om mönstret är ``None`` representerar noden ett fångstmönster (dvs. ett "
"tomt namn) och kommer alltid att lyckas."

#: ../../library/ast.rst:1744
msgid ""
"The ``name`` attribute contains the name that will be bound if the pattern "
"is successful. If ``name`` is ``None``, ``pattern`` must also be ``None`` "
"and the node represents the wildcard pattern."
msgstr ""
"Attributet ``name`` innehåller det namn som kommer att bindas om mönstret är "
"framgångsrikt. Om ``name`` är ``None`` måste ``pattern`` också vara ``None`` "
"och noden representerar wildcard-mönstret."

#: ../../library/ast.rst:1748
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case [x] as y:\n"
"...         ...\n"
"...     case _:\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchAs(\n"
"                        pattern=MatchSequence(\n"
"                            patterns=[\n"
"                                MatchAs(name='x')]),\n"
"                        name='y'),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchAs(),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... matcha x:\n"
"... fall [x] som y:\n"
"... ...\n"
"... fall _:\n"
"... ...\n"
"... \"\"\"), indrag=4))\n"
"Modul(\n"
"    kropp=[\n"
"        Matchning(\n"
"            subject=Namn(id='x', ctx=Load()),\n"
"            fall=[\n"
"                match_case(\n"
"                    mönster=MatchAs(\n"
"                        mönster=MatchSequence(\n"
"                            mönster=[\n"
"                                MatchAs(name='x')]),\n"
"                        name='y'),\n"
"                    body=[\n"
"                        Expr(\n"
"                            värde=Konstant(värde=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchAs(),\n"
"                    body=[\n"
"                        Expr(\n"
"                            värde=Konstant(värde=Ellipsis))])])]])"

#: ../../library/ast.rst:1781
msgid ""
"A match \"or-pattern\". An or-pattern matches each of its subpatterns in "
"turn to the subject, until one succeeds. The or-pattern is then deemed to "
"succeed. If none of the subpatterns succeed the or-pattern fails. The "
"``patterns`` attribute contains a list of match pattern nodes that will be "
"matched against the subject."
msgstr ""
"En matchning \"eller-mönster\". Ett eller-mönster matchar vart och ett av "
"sina undermönster i tur och ordning till ämnet, tills ett lyckas. Då anses "
"or-mönstret vara framgångsrikt. Om inget av undermönstren lyckas misslyckas "
"or-mönstret. Attributet ``patterns`` innehåller en lista över "
"matchningsmönsternoder som kommer att matchas mot subjektet."

#: ../../library/ast.rst:1787
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case [x] | (y):\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchOr(\n"
"                        patterns=[\n"
"                            MatchSequence(\n"
"                                patterns=[\n"
"                                    MatchAs(name='x')]),\n"
"                            MatchAs(name='y')]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... matcha x:\n"
"... fall [x] | (y):\n"
"... ...\n"
"... \"\"\"), indrag=4))\n"
"Modul(\n"
"    kropp=[\n"
"        Matchning(\n"
"            subject=Namn(id='x', ctx=Load()),\n"
"            fall=[\n"
"                match_case(\n"
"                    mönster=MatchOr(\n"
"                        mönster=[\n"
"                            MatchSequence(\n"
"                                mönster=[\n"
"                                    MatchAs(name='x')]),\n"
"                            MatchAs(name='y')]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Konstant(value=Ellipsis))])])])])"

#: ../../library/ast.rst:1814
msgid "Type annotations"
msgstr "Typ av anteckningar"

#: ../../library/ast.rst:1818
msgid ""
"A ``# type: ignore`` comment located at *lineno*. *tag* is the optional tag "
"specified by the form ``# type: ignore <tag>``."
msgstr ""
"En ``# type: ignore`` kommentar som finns på *lineno*. *tag* är den valfria "
"tagg som anges av formuläret ``# type: ignore <tag>``."

#: ../../library/ast.rst:1821
msgid ""
">>> print(ast.dump(ast.parse('x = 1 # type: ignore', type_comments=True), "
"indent=4))\n"
"Module(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Name(id='x', ctx=Store())],\n"
"            value=Constant(value=1))],\n"
"    type_ignores=[\n"
"        TypeIgnore(lineno=1, tag='')])\n"
">>> print(ast.dump(ast.parse('x: bool = 1 # type: ignore[assignment]', "
"type_comments=True), indent=4))\n"
"Module(\n"
"    body=[\n"
"        AnnAssign(\n"
"            target=Name(id='x', ctx=Store()),\n"
"            annotation=Name(id='bool', ctx=Load()),\n"
"            value=Constant(value=1),\n"
"            simple=1)],\n"
"    type_ignores=[\n"
"        TypeIgnore(lineno=1, tag='[assignment]')])"
msgstr ""
">>> print(ast.dump(ast.parse('x = 1 # typ: ignorera', type_comments=True), "
"indent=4))\n"
"Modul(\n"
"    body=[\n"
"        Tilldela(\n"
"            mål=[\n"
"                Namn(id='x', ctx=Store())],\n"
"            value=Konstant(värde=1))],\n"
"    type_ignores=[\n"
"        TypeIgnore(lineno=1, tag='')])\n"
">>> print(ast.dump(ast.parse('x: bool = 1 # type: ignore[assignment]', "
"type_comments=True), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        AnnAssign(\n"
"            target=Namn(id='x', ctx=Store()),\n"
"            annotation=Name(id='bool', ctx=Load()),\n"
"            value=Konstant(värde=1),\n"
"            simple=1)],\n"
"    type_ignores=[\n"
"        TypeIgnore(lineno=1, tag='[assignment]')])"

#: ../../library/ast.rst:1844
msgid ""
":class:`!TypeIgnore` nodes are not generated when the *type_comments* "
"parameter is set to ``False`` (default).  See :func:`ast.parse` for more "
"details."
msgstr ""
":class:`!TypeIgnore`-noder genereras inte när parametern *type_comments* är "
"inställd på ``False`` (standard).  Se :func:`ast.parse` för mer information."

#: ../../library/ast.rst:1852
msgid "Type parameters"
msgstr "Typ av parametrar"

#: ../../library/ast.rst:1854
msgid ""
":ref:`Type parameters <type-params>` can exist on classes, functions, and "
"type aliases."
msgstr ""
":ref:`Typ-parametrar <type-params>` kan finnas i klasser, funktioner och "
"typaliaser."

#: ../../library/ast.rst:1859
msgid ""
"A :class:`typing.TypeVar`. ``name`` is the name of the type variable. "
"``bound`` is the bound or constraints, if any. If ``bound`` is a :class:"
"`Tuple`, it represents constraints; otherwise it represents the bound. "
"``default_value`` is the default value; if the :class:`!TypeVar` has no "
"default, this attribute will be set to ``None``."
msgstr ""
"En :klass:`typing.TypeVar`. ``name`` är namnet på typvariabeln. ``bound`` är "
"bindningen eller begränsningarna, om sådana finns. Om ``bound`` är en :class:"
"`Tuple` representerar den begränsningar; annars representerar den "
"bindningen. ``default_value`` är standardvärdet; om :class:`!TypeVar` inte "
"har något standardvärde kommer detta attribut att sättas till ``None``."

#: ../../library/ast.rst:1865
msgid ""
">>> print(ast.dump(ast.parse(\"type Alias[T: int = bool] = list[T]\"), "
"indent=4))\n"
"Module(\n"
"    body=[\n"
"        TypeAlias(\n"
"            name=Name(id='Alias', ctx=Store()),\n"
"            type_params=[\n"
"                TypeVar(\n"
"                    name='T',\n"
"                    bound=Name(id='int', ctx=Load()),\n"
"                    default_value=Name(id='bool', ctx=Load()))],\n"
"            value=Subscript(\n"
"                value=Name(id='list', ctx=Load()),\n"
"                slice=Name(id='T', ctx=Load()),\n"
"                ctx=Load()))])"
msgstr ""
">>> print(ast.dump(ast.parse(\"typ Alias[T: int = bool] = list[T]\"), "
"indent=4))\n"
"Modul(\n"
"    body=[\n"
"        TypAlias(\n"
"            name=Namn(id='Alias', ctx=Store()),\n"
"            type_params=[\n"
"                TypeVar(\n"
"                    name='T',\n"
"                    bound=Name(id='int', ctx=Load()),\n"
"                    default_value=Name(id='bool', ctx=Load()))],\n"
"            värde=Subskript(\n"
"                value=Name(id='list', ctx=Load()),\n"
"                slice=Name(id='T', ctx=Load()),\n"
"                ctx=Load()))])"

#: ../../library/ast.rst:1884 ../../library/ast.rst:1919
#: ../../library/ast.rst:1951
msgid "Added the *default_value* parameter."
msgstr "Parametern *default_value* har lagts till."

#: ../../library/ast.rst:1889
msgid ""
"A :class:`typing.ParamSpec`. ``name`` is the name of the parameter "
"specification. ``default_value`` is the default value; if the :class:`!"
"ParamSpec` has no default, this attribute will be set to ``None``."
msgstr ""
"En :klass:`typing.ParamSpec`. ``name`` är namnet på "
"parameterspecifikationen. ``default_value`` är standardvärdet; om :class:`!"
"ParamSpec` inte har något standardvärde kommer detta attribut att sättas "
"till ``None``."

#: ../../library/ast.rst:1893
msgid ""
">>> print(ast.dump(ast.parse(\"type Alias[**P = [int, str]] = Callable[P, "
"int]\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        TypeAlias(\n"
"            name=Name(id='Alias', ctx=Store()),\n"
"            type_params=[\n"
"                ParamSpec(\n"
"                    name='P',\n"
"                    default_value=List(\n"
"                        elts=[\n"
"                            Name(id='int', ctx=Load()),\n"
"                            Name(id='str', ctx=Load())],\n"
"                        ctx=Load()))],\n"
"            value=Subscript(\n"
"                value=Name(id='Callable', ctx=Load()),\n"
"                slice=Tuple(\n"
"                    elts=[\n"
"                        Name(id='P', ctx=Load()),\n"
"                        Name(id='int', ctx=Load())],\n"
"                    ctx=Load()),\n"
"                ctx=Load()))])"
msgstr ""
">>> print(ast.dump(ast.parse(\"typ Alias[**P = [int, str]] = Callable[P, "
"int]\"), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        TypAlias(\n"
"            name=Namn(id='Alias', ctx=Store()),\n"
"            type_params=[\n"
"                ParamSpec(\n"
"                    name='P',\n"
"                    default_value=Lista(\n"
"                        elts=[\n"
"                            Namn(id='int', ctx=Load()),\n"
"                            Name(id='str', ctx=Load()))],\n"
"                        ctx=Load())))],\n"
"            värde=Subskript(\n"
"                value=Name(id='Callable', ctx=Load()),\n"
"                slice=Tupel(\n"
"                    elts=[\n"
"                        Namn(id='P', ctx=Load()),\n"
"                        Name(id='int', ctx=Load())],\n"
"                    ctx=Load()),\n"
"                ctx=Load()))])"

#: ../../library/ast.rst:1924
msgid ""
"A :class:`typing.TypeVarTuple`. ``name`` is the name of the type variable "
"tuple. ``default_value`` is the default value; if the :class:`!TypeVarTuple` "
"has no default, this attribute will be set to ``None``."
msgstr ""
"En :klass:`typing.TypeVarTuple`. ``name`` är namnet på typvariabeln tuple. "
"``default_value`` är standardvärdet; om :class:`!TypeVarTuple` inte har "
"något standardvärde kommer detta attribut att sättas till ``None``."

#: ../../library/ast.rst:1928
msgid ""
">>> print(ast.dump(ast.parse(\"type Alias[*Ts = ()] = tuple[*Ts]\"), "
"indent=4))\n"
"Module(\n"
"    body=[\n"
"        TypeAlias(\n"
"            name=Name(id='Alias', ctx=Store()),\n"
"            type_params=[\n"
"                TypeVarTuple(\n"
"                    name='Ts',\n"
"                    default_value=Tuple(ctx=Load()))],\n"
"            value=Subscript(\n"
"                value=Name(id='tuple', ctx=Load()),\n"
"                slice=Tuple(\n"
"                    elts=[\n"
"                        Starred(\n"
"                            value=Name(id='Ts', ctx=Load()),\n"
"                            ctx=Load())],\n"
"                    ctx=Load()),\n"
"                ctx=Load()))])"
msgstr ""
">>> print(ast.dump(ast.parse(\"typ Alias[*Ts = ()] = tuple[*Ts]\"), "
"indent=4))\n"
"Modul(\n"
"    body=[\n"
"        TypAlias(\n"
"            name=Namn(id='Alias', ctx=Store()),\n"
"            type_params=[\n"
"                TypeVarTuple(\n"
"                    name='Ts',\n"
"                    default_value=Tuple(ctx=Load()))],\n"
"            value=Subskript(\n"
"                value=Name(id='tuple', ctx=Load()),\n"
"                slice=Tupel(\n"
"                    elts=[\n"
"                        Stjärnmärkt(\n"
"                            value=Name(id='Ts', ctx=Load()),\n"
"                            ctx=Load())],\n"
"                    ctx=Load()),\n"
"                ctx=Load()))])"

#: ../../library/ast.rst:1955
msgid "Function and class definitions"
msgstr "Funktions- och klassdefinitioner"

#: ../../library/ast.rst:1959
msgid "A function definition."
msgstr "En funktionsdefinition."

#: ../../library/ast.rst:1961
msgid "``name`` is a raw string of the function name."
msgstr "``name`` är en rå sträng med funktionens namn."

#: ../../library/ast.rst:1962
msgid "``args`` is an :class:`arguments` node."
msgstr "``args`` är en nod i :class:`arguments`."

#: ../../library/ast.rst:1963
msgid "``body`` is the list of nodes inside the function."
msgstr "``body`` är listan över noder i funktionen."

#: ../../library/ast.rst:1964
msgid ""
"``decorator_list`` is the list of decorators to be applied, stored outermost "
"first (i.e. the first in the list will be applied last)."
msgstr ""
"``decorator_list`` är listan över dekoratorer som ska tillämpas, lagrade "
"längst ut först (dvs. den första i listan kommer att tillämpas sist)."

#: ../../library/ast.rst:1966
msgid "``returns`` is the return annotation."
msgstr "``returns`` är returannoteringen."

#: ../../library/ast.rst:1967 ../../library/ast.rst:2130
msgid "``type_params`` is a list of :ref:`type parameters <ast-type-params>`."
msgstr ""
"``type_params`` är en lista med :ref:`typ-parametrar <ast-type-params>`."

#: ../../library/ast.rst:1973 ../../library/ast.rst:2157
#: ../../library/ast.rst:2168
msgid "Added ``type_params``."
msgstr "Lagt till ``type_params``."

#: ../../library/ast.rst:1979
msgid ""
"``lambda`` is a minimal function definition that can be used inside an "
"expression. Unlike :class:`FunctionDef`, ``body`` holds a single node."
msgstr ""
"``lambda`` är en minimal funktionsdefinition som kan användas inuti ett "
"uttryck. Till skillnad från :class:`FunctionDef` innehåller ``body`` en enda "
"nod."

#: ../../library/ast.rst:1982
msgid ""
">>> print(ast.dump(ast.parse('lambda x,y: ...'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Expr(\n"
"            value=Lambda(\n"
"                args=arguments(\n"
"                    args=[\n"
"                        arg(arg='x'),\n"
"                        arg(arg='y')]),\n"
"                body=Constant(value=Ellipsis)))])"
msgstr ""
">>> print(ast.dump(ast.parse('lambda x,y: ...'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        Expr(\n"
"            värde=Lambda(\n"
"                args=argument(\n"
"                    args=[\n"
"                        arg(arg='x'),\n"
"                        arg(arg='y')]),\n"
"                body=Konstant(värde=Ellipsis)))])"

#: ../../library/ast.rst:1998
msgid "The arguments for a function."
msgstr "Argumenten för en funktion."

#: ../../library/ast.rst:2000
msgid ""
"``posonlyargs``, ``args`` and ``kwonlyargs`` are lists of :class:`arg` nodes."
msgstr ""
"``posonlyargs``, ``args`` och ``kwonlyargs`` är listor av :class:`arg`-noder."

#: ../../library/ast.rst:2001
msgid ""
"``vararg`` and ``kwarg`` are single :class:`arg` nodes, referring to the "
"``*args, **kwargs`` parameters."
msgstr ""
"``vararg`` och ``kwarg`` är enskilda :class:`arg`-noder som refererar till "
"parametrarna ``*args, **kwargs``."

#: ../../library/ast.rst:2003
msgid ""
"``kw_defaults`` is a list of default values for keyword-only arguments. If "
"one is ``None``, the corresponding argument is required."
msgstr ""
"``kw_defaults`` är en lista med standardvärden för argument som endast "
"innehåller nyckelord. Om ett är ``None`` krävs motsvarande argument."

#: ../../library/ast.rst:2005
msgid ""
"``defaults`` is a list of default values for arguments that can be passed "
"positionally. If there are fewer defaults, they correspond to the last n "
"arguments."
msgstr ""
"``defaults`` är en lista med standardvärden för argument som kan skickas "
"positionellt. Om det finns färre standardvärden motsvarar de de sista n "
"argumenten."

#: ../../library/ast.rst:2012
msgid ""
"A single argument in a list. ``arg`` is a raw string of the argument name; "
"``annotation`` is its annotation, such as a :class:`Name` node."
msgstr ""
"Ett enskilt argument i en lista. ``arg`` är en rå sträng med argumentets "
"namn; ``annotation`` är dess annotation, t.ex. en :class:`Name`-nod."

#: ../../library/ast.rst:2017
msgid ""
"``type_comment`` is an optional string with the type annotation as a comment"
msgstr ""
"``type_comment`` är en valfri sträng med typannoteringen som en kommentar"

#: ../../library/ast.rst:2019
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... @decorator1\n"
"... @decorator2\n"
"... def f(a: 'annotation', b=1, c=2, *d, e, f=3, **g) -> 'return "
"annotation':\n"
"...     pass\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        FunctionDef(\n"
"            name='f',\n"
"            args=arguments(\n"
"                args=[\n"
"                    arg(\n"
"                        arg='a',\n"
"                        annotation=Constant(value='annotation')),\n"
"                    arg(arg='b'),\n"
"                    arg(arg='c')],\n"
"                vararg=arg(arg='d'),\n"
"                kwonlyargs=[\n"
"                    arg(arg='e'),\n"
"                    arg(arg='f')],\n"
"                kw_defaults=[\n"
"                    None,\n"
"                    Constant(value=3)],\n"
"                kwarg=arg(arg='g'),\n"
"                defaults=[\n"
"                    Constant(value=1),\n"
"                    Constant(value=2)]),\n"
"            body=[\n"
"                Pass()],\n"
"            decorator_list=[\n"
"                Name(id='decorator1', ctx=Load()),\n"
"                Name(id='decorator2', ctx=Load())],\n"
"            returns=Constant(value='return annotation'))])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\\\"\")\n"
"... @dekoratör1\n"
"... @dekorerare2\n"
"... def f(a: 'annotation', b=1, c=2, *d, e, f=3, **g) -> 'returnera "
"annotation':\n"
"... pass\n"
"... \"\"\"), indrag=4))\n"
"Modul(\n"
"    body=[\n"
"        FunktionDef(\n"
"            name='f',\n"
"            args=argument(\n"
"                args=[\n"
"                    arg(\n"
"                        arg='a',\n"
"                        annotation=Konstant(värde='annotation')),\n"
"                    arg(arg='b'),\n"
"                    arg(arg='c')],\n"
"                vararg=arg(arg='d'),\n"
"                kwonlyargs=[\n"
"                    arg(arg='e'),\n"
"                    arg(arg='f')],\n"
"                kw_defaults=[\n"
"                    Ingen,\n"
"                    Constant(värde=3)],\n"
"                kwarg=arg(arg='g'),\n"
"                defaults=[\n"
"                    Konstant(värde=1),\n"
"                    Constant(värde=2)]),\n"
"            body=[\n"
"                Pass()],\n"
"            decorator_list=[\n"
"                Namn(id='decorator1', ctx=Load()),\n"
"                Name(id='dekorator2', ctx=Load())],\n"
"            returns=Constant(value='returnera anteckning'))])"

#: ../../library/ast.rst:2059
msgid "A ``return`` statement."
msgstr "Ett ``retur`` uttalande."

#: ../../library/ast.rst:2061
msgid ""
">>> print(ast.dump(ast.parse('return 4'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Return(\n"
"            value=Constant(value=4))])"
msgstr ""
">>> print(ast.dump(ast.parse('return 4'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        Retur(\n"
"            värde=Konstant(värde=4))])"

#: ../../library/ast.rst:2073
msgid ""
"A ``yield`` or ``yield from`` expression. Because these are expressions, "
"they must be wrapped in an :class:`Expr` node if the value sent back is not "
"used."
msgstr ""
"Ett ``yield`` eller ``yield from`` uttryck. Eftersom det här är uttryck "
"måste de omslutas av en :class:`Expr`-nod om värdet som skickas tillbaka "
"inte ska användas."

#: ../../library/ast.rst:2076
msgid ""
">>> print(ast.dump(ast.parse('yield x'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Expr(\n"
"            value=Yield(\n"
"                value=Name(id='x', ctx=Load())))])\n"
"\n"
">>> print(ast.dump(ast.parse('yield from x'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Expr(\n"
"            value=YieldFrom(\n"
"                value=Name(id='x', ctx=Load())))])"
msgstr ""
">>> print(ast.dump(ast.parse('yield x'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        Expr(\n"
"            värde=Yield(\n"
"                värde=Namn(id='x', ctx=Load())))])\n"
"\n"
">>> print(ast.dump(ast.parse('yield från x'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        Expr(\n"
"            värde=YieldFrom(\n"
"                värde=Namn(id='x', ctx=Load())))])"

#: ../../library/ast.rst:2096
msgid ""
"``global`` and ``nonlocal`` statements. ``names`` is a list of raw strings."
msgstr ""
"``global`` och ``nonlocal`` satser. ``names`` är en lista med råa strängar."

#: ../../library/ast.rst:2098
msgid ""
">>> print(ast.dump(ast.parse('global x,y,z'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Global(\n"
"            names=[\n"
"                'x',\n"
"                'y',\n"
"                'z'])])\n"
"\n"
">>> print(ast.dump(ast.parse('nonlocal x,y,z'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Nonlocal(\n"
"            names=[\n"
"                'x',\n"
"                'y',\n"
"                'z'])])"
msgstr ""
">>> print(ast.dump(ast.parse('global x,y,z'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        Global(\n"
"            namn=[\n"
"                'x',\n"
"                'y',\n"
"                'z'])])\n"
"\n"
">>> print(ast.dump(ast.parse('icke-lokala x,y,z'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        Icke-lokala(\n"
"            namn=[\n"
"                'x',\n"
"                'y',\n"
"                'z'])])"

#: ../../library/ast.rst:2121
msgid "A class definition."
msgstr "En klassdefinition."

#: ../../library/ast.rst:2123
msgid "``name`` is a raw string for the class name"
msgstr "``name`` är en rå sträng för klassnamnet"

#: ../../library/ast.rst:2124
msgid "``bases`` is a list of nodes for explicitly specified base classes."
msgstr "``bases`` är en lista med noder för explicit angivna basklasser."

#: ../../library/ast.rst:2125
msgid ""
"``keywords`` is a list of :class:`.keyword` nodes, principally for "
"'metaclass'. Other keywords will be passed to the metaclass, as per :pep:"
"`3115`."
msgstr ""
"``keywords`` är en lista med :class:`.keyword`-noder, huvudsakligen för "
"'metaclass'. Andra nyckelord kommer att skickas till metaklassen, enligt :"
"pep:`3115`."

#: ../../library/ast.rst:2127
msgid ""
"``body`` is a list of nodes representing the code within the class "
"definition."
msgstr ""
"``body`` är en lista med noder som representerar koden i klassdefinitionen."

#: ../../library/ast.rst:2129
msgid "``decorator_list`` is a list of nodes, as in :class:`FunctionDef`."
msgstr "``decorator_list`` är en lista med noder, som i :class:`FunctionDef`."

#: ../../library/ast.rst:2132
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... @decorator1\n"
"... @decorator2\n"
"... class Foo(base1, base2, metaclass=meta):\n"
"...     pass\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        ClassDef(\n"
"            name='Foo',\n"
"            bases=[\n"
"                Name(id='base1', ctx=Load()),\n"
"                Name(id='base2', ctx=Load())],\n"
"            keywords=[\n"
"                keyword(\n"
"                    arg='metaclass',\n"
"                    value=Name(id='meta', ctx=Load()))],\n"
"            body=[\n"
"                Pass()],\n"
"            decorator_list=[\n"
"                Name(id='decorator1', ctx=Load()),\n"
"                Name(id='decorator2', ctx=Load())])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\\\"\")\n"
"... @dekoratör1\n"
"... @dekorerare2\n"
"... klass Foo(bas1, bas2, metaklass=meta):\n"
"... pass\n"
"... \"\"\"), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        KlassDef(\n"
"            name='Foo',\n"
"            baser=[\n"
"                Name(id='base1', ctx=Load()),\n"
"                Name(id='base2', ctx=Load())],\n"
"            nyckelord=[\n"
"                nyckelord(\n"
"                    arg='metaklass',\n"
"                    value=Name(id='meta', ctx=Load()))],\n"
"            body=[\n"
"                Pass()],\n"
"            decorator_list=[\n"
"                Name(id='decorator1', ctx=Load()),\n"
"                Name(id='decorator2', ctx=Load())])])"

#: ../../library/ast.rst:2161
msgid "Async and await"
msgstr "Asynkron och await"

#: ../../library/ast.rst:2165
msgid ""
"An ``async def`` function definition. Has the same fields as :class:"
"`FunctionDef`."
msgstr ""
"En ``async def`` funktionsdefinition. Har samma fält som :class:"
"`FunctionDef`."

#: ../../library/ast.rst:2174
msgid ""
"An ``await`` expression. ``value`` is what it waits for. Only valid in the "
"body of an :class:`AsyncFunctionDef`."
msgstr ""
"Ett ``await``-uttryck. ``värde`` är vad den väntar på. Endast giltigt i "
"kroppen av en :class:`AsyncFunctionDef`."

#: ../../library/ast.rst:2177
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... async def f():\n"
"...     await other_func()\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        AsyncFunctionDef(\n"
"            name='f',\n"
"            args=arguments(),\n"
"            body=[\n"
"                Expr(\n"
"                    value=Await(\n"
"                        value=Call(\n"
"                            func=Name(id='other_func', ctx=Load()))))])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... asynkron def f():\n"
"... vänta på andra_func()\n"
"... \"\"\"), indent=4))\n"
"Modul(\n"
"    kropp=[\n"
"        AsyncFunctionDef(\n"
"            name='f',\n"
"            args=argument(),\n"
"            body=[\n"
"                Expr(\n"
"                    värde=Avvakta(\n"
"                        värde=Kalla(\n"
"                            func=Namn(id='other_func', ctx=Load()))))]))])"

#: ../../library/ast.rst:2198
msgid ""
"``async for`` loops and ``async with`` context managers. They have the same "
"fields as :class:`For` and :class:`With`, respectively. Only valid in the "
"body of an :class:`AsyncFunctionDef`."
msgstr ""
"``async for``-loopar och ``async with``-kontexthanterare. De har samma fält "
"som :class:`For` respektive :class:`With`. Endast giltig i kroppen av en :"
"class:`AsyncFunctionDef`."

#: ../../library/ast.rst:2203
msgid ""
"When a string is parsed by :func:`ast.parse`, operator nodes (subclasses of :"
"class:`ast.operator`, :class:`ast.unaryop`, :class:`ast.cmpop`, :class:`ast."
"boolop` and :class:`ast.expr_context`) on the returned tree will be "
"singletons. Changes to one will be reflected in all other occurrences of the "
"same value (for example, :class:`ast.Add`)."
msgstr ""
"När en sträng analyseras av :func:`ast.parse`, kommer operator-noder "
"(underklasser till :class:`ast.operator`, :class:`ast.unaryop`, :class:`ast."
"cmpop`, :class:`ast.boolop` och :class:`ast.expr_context`) på det "
"returnerade trädet att vara singletons. Ändringar i ett av dem kommer att "
"återspeglas i alla andra förekomster av samma värde (t.ex. :class:`ast.Add`)."

#: ../../library/ast.rst:2211
msgid ":mod:`ast` helpers"
msgstr ":mod:`ast` hjälpare"

#: ../../library/ast.rst:2213
msgid ""
"Apart from the node classes, the :mod:`ast` module defines these utility "
"functions and classes for traversing abstract syntax trees:"
msgstr ""
"Förutom nodklasserna definierar modulen :mod:`ast` dessa verktygsfunktioner "
"och klasser för genomgång av abstrakta syntaxträd:"

#: ../../library/ast.rst:2218
msgid ""
"Parse the source into an AST node.  Equivalent to ``compile(source, "
"filename, mode, flags=FLAGS_VALUE, optimize=optimize)``, where "
"``FLAGS_VALUE`` is ``ast.PyCF_ONLY_AST`` if ``optimize <= 0`` and ``ast."
"PyCF_OPTIMIZED_AST`` otherwise."
msgstr ""
"Parsar källan till en AST-nod.  Motsvarar ``compile(source, filename, mode, "
"flags=FLAGS_VALUE, optimize=optimize)``, där ``FLAGS_VALUE`` är ``ast."
"PyCF_ONLY_AST`` om ``optimize <= 0`` och ``ast.PyCF_OPTIMIZED_AST`` annars."

#: ../../library/ast.rst:2223
msgid ""
"If ``type_comments=True`` is given, the parser is modified to check and "
"return type comments as specified by :pep:`484` and :pep:`526`. This is "
"equivalent to adding :data:`ast.PyCF_TYPE_COMMENTS` to the flags passed to :"
"func:`compile`.  This will report syntax errors for misplaced type "
"comments.  Without this flag, type comments will be ignored, and the "
"``type_comment`` field on selected AST nodes will always be ``None``.  In "
"addition, the locations of ``# type: ignore`` comments will be returned as "
"the ``type_ignores`` attribute of :class:`Module` (otherwise it is always an "
"empty list)."
msgstr ""
"Om ``type_comments=True`` anges, modifieras parsern för att kontrollera och "
"returnera typkommentarer som specificeras av :pep:`484` och :pep:`526`. "
"Detta är likvärdigt med att lägga till :data:`ast.PyCF_TYPE_COMMENTS` till "
"flaggorna som skickas till :func:`compile`.  Detta kommer att rapportera "
"syntaxfel för felplacerade typkommentarer.  Utan denna flagga kommer "
"typkommentarer att ignoreras och fältet ``type_comment`` på valda AST-noder "
"kommer alltid att vara ``None``.  Dessutom kommer platserna för ``# type: "
"ignore`` kommentarer att returneras som ``type_ignores`` attributet för :"
"class:`Module` (annars är det alltid en tom lista)."

#: ../../library/ast.rst:2233
msgid ""
"In addition, if ``mode`` is ``'func_type'``, the input syntax is modified to "
"correspond to :pep:`484` \"signature type comments\", e.g. ``(str, int) -> "
"List[str]``."
msgstr ""
"Dessutom, om ``mode`` är ``'func_type'``, ändras inmatningssyntaxen för att "
"motsvara :pep:`484` \"signaturtypskommentarer\", t.ex. ``(str, int) -> "
"List[str]``."

#: ../../library/ast.rst:2237
msgid ""
"Setting ``feature_version`` to a tuple ``(major, minor)`` will result in a "
"\"best-effort\" attempt to parse using that Python version's grammar. For "
"example, setting ``feature_version=(3, 9)`` will attempt to disallow parsing "
"of :keyword:`match` statements. Currently ``major`` must equal to ``3``. The "
"lowest supported version is ``(3, 7)`` (and this may increase in future "
"Python versions); the highest is ``sys.version_info[0:2]``. \"Best-effort\" "
"attempt means there is no guarantee that the parse (or success of the parse) "
"is the same as when run on the Python version corresponding to "
"``feature_version``."
msgstr ""
"Om du anger ``feature_version`` till en tupel ``(major, minor)`` kommer det "
"att resultera i ett \"best-effort\" försök att analysera med hjälp av den "
"Python-versionens grammatik. Till exempel, att sätta ``feature_version=(3, "
"9)`` kommer att försöka att inte tillåta parsning av :keyword:`match`-"
"satser. För närvarande måste ``major`` vara lika med ``3``. Den lägsta "
"versionen som stöds är ``(3, 7)`` (och detta kan öka i framtida Python-"
"versioner); den högsta är ``sys.version_info[0:2]``. \"Best-effort\"-försök "
"innebär att det inte finns någon garanti för att parsen (eller att parsen "
"lyckas) är densamma som när den körs på den Python-version som motsvarar "
"``feature_version``."

#: ../../library/ast.rst:2247
msgid ""
"If source contains a null character (``\\0``), :exc:`ValueError` is raised."
msgstr "Om källan innehåller ett null-tecken (``\\0``), :exc:`ValueError`."

#: ../../library/ast.rst:2250
msgid ""
"Note that successfully parsing source code into an AST object doesn't "
"guarantee that the source code provided is valid Python code that can be "
"executed as the compilation step can raise further :exc:`SyntaxError` "
"exceptions. For instance, the source ``return 42`` generates a valid AST "
"node for a return statement, but it cannot be compiled alone (it needs to be "
"inside a function node)."
msgstr ""
"Observera att en lyckad parsning av källkod till ett AST-objekt inte "
"garanterar att den källkod som tillhandahålls är giltig Python-kod som kan "
"exekveras eftersom kompileringssteget kan ge upphov till ytterligare :exc:"
"`SyntaxError`-undantag. Till exempel genererar källan ``return 42`` en "
"giltig AST-nod för en return-sats, men den kan inte kompileras ensam (den "
"måste vara inuti en funktionsnod)."

#: ../../library/ast.rst:2257
msgid ""
"In particular, :func:`ast.parse` won't do any scoping checks, which the "
"compilation step does."
msgstr ""
"I synnerhet kommer :func:`ast.parse` inte att göra några scoping-kontroller, "
"vilket kompileringssteget gör."

#: ../../library/ast.rst:2261
msgid ""
"It is possible to crash the Python interpreter with a sufficiently large/"
"complex string due to stack depth limitations in Python's AST compiler."
msgstr ""
"Det är möjligt att krascha Python-tolken med en tillräckligt stor/komplex "
"sträng på grund av begränsningar i stackdjupet i Pythons AST-kompilator."

#: ../../library/ast.rst:2265
msgid "Added ``type_comments``, ``mode='func_type'`` and ``feature_version``."
msgstr ""
"Lagt till ``type_comments``, ``mode='func_type'`` och ``feature_version``."

#: ../../library/ast.rst:2268
msgid ""
"The minimum supported version for ``feature_version`` is now ``(3, 7)``. The "
"``optimize`` argument was added."
msgstr ""
"Den minsta versionen som stöds för ``feature_version`` är nu ``(3, 7)``. "
"Argumentet ``optimize`` har lagts till."

#: ../../library/ast.rst:2275
msgid ""
"Unparse an :class:`ast.AST` object and generate a string with code that "
"would produce an equivalent :class:`ast.AST` object if parsed back with :"
"func:`ast.parse`."
msgstr ""
"Unparse ett :class:`ast.AST`-objekt och generera en sträng med kod som "
"skulle producera ett motsvarande :class:`ast.AST`-objekt om det analyserades "
"tillbaka med :func:`ast.parse`."

#: ../../library/ast.rst:2280
msgid ""
"The produced code string will not necessarily be equal to the original code "
"that generated the :class:`ast.AST` object (without any compiler "
"optimizations, such as constant tuples/frozensets)."
msgstr ""
"Den kodsträng som produceras kommer inte nödvändigtvis att vara lika med den "
"ursprungliga koden som genererade :class:`ast.AST`-objektet (utan några "
"kompilatoroptimeringar, t.ex. konstanta tuples/frozensets)."

#: ../../library/ast.rst:2285
msgid ""
"Trying to unparse a highly complex expression would result with :exc:"
"`RecursionError`."
msgstr ""
"Försök att unparsa ett mycket komplext uttryck skulle resultera i :exc:"
"`RecursionError`."

#: ../../library/ast.rst:2293
msgid ""
"Evaluate an expression node or a string containing only a Python literal or "
"container display.  The string or node provided may only consist of the "
"following Python literal structures: strings, bytes, numbers, tuples, lists, "
"dicts, sets, booleans, ``None`` and ``Ellipsis``."
msgstr ""
"Utvärderar en uttrycksnod eller en sträng som endast innehåller en Python-"
"litteral eller containervisning.  Den angivna strängen eller noden får "
"endast bestå av följande Python-litteralstrukturer: strängar, bytes, tal, "
"tupler, listor, dicts, set, booleaner, ``None`` och ``Ellipsis``."

#: ../../library/ast.rst:2298
msgid ""
"This can be used for evaluating strings containing Python values without the "
"need to parse the values oneself.  It is not capable of evaluating "
"arbitrarily complex expressions, for example involving operators or indexing."
msgstr ""
"Detta kan användas för att utvärdera strängar som innehåller Python-värden "
"utan att man behöver analysera värdena själv.  Den kan inte utvärdera "
"godtyckligt komplexa uttryck, t.ex. med operatorer eller indexering."

#: ../../library/ast.rst:2303
msgid ""
"This function had been documented as \"safe\" in the past without defining "
"what that meant. That was misleading. This is specifically designed not to "
"execute Python code, unlike the more general :func:`eval`. There is no "
"namespace, no name lookups, or ability to call out. But it is not free from "
"attack: A relatively small input can lead to memory exhaustion or to C stack "
"exhaustion, crashing the process. There is also the possibility for "
"excessive CPU consumption denial of service on some inputs. Calling it on "
"untrusted data is thus not recommended."
msgstr ""
"Denna funktion har tidigare dokumenterats som \"säker\" utan att det har "
"definierats vad det innebär. Det var missvisande. Detta är specifikt "
"utformat för att inte exekvera Python-kod, till skillnad från den mer "
"allmänna :func:`eval`. Det finns ingen namnrymd, inga namnuppslagningar "
"eller möjlighet att ringa ut. Men det är inte fritt från angrepp: En "
"relativt liten inmatning kan leda till att minnet eller C-stacken tar slut "
"och att processen kraschar. Det finns också möjlighet till överdriven CPU-"
"konsumtion, denial of service, för vissa indata. Att anropa den på icke "
"betrodda data rekommenderas därför inte."

#: ../../library/ast.rst:2313
msgid ""
"It is possible to crash the Python interpreter due to stack depth "
"limitations in Python's AST compiler."
msgstr ""
"Det är möjligt att krascha Python-tolken på grund av begränsningar i "
"stackdjupet i Pythons AST-kompilator."

#: ../../library/ast.rst:2316
msgid ""
"It can raise :exc:`ValueError`, :exc:`TypeError`, :exc:`SyntaxError`, :exc:"
"`MemoryError` and :exc:`RecursionError` depending on the malformed input."
msgstr ""
"Det kan ge upphov till :exc:`ValueError`, :exc:`TypeError`, :exc:"
"`SyntaxError`, :exc:`MemoryError` och :exc:`RecursionError` beroende på den "
"felaktiga indata."

#: ../../library/ast.rst:2320
msgid "Now allows bytes and set literals."
msgstr "Tillåter nu bytes och set-litteraler."

#: ../../library/ast.rst:2323
msgid "Now supports creating empty sets with ``'set()'``."
msgstr "Stöder nu skapandet av tomma uppsättningar med ``'set()'``."

#: ../../library/ast.rst:2326
msgid "For string inputs, leading spaces and tabs are now stripped."
msgstr "För stränginmatningar tas nu inledande mellanslag och tabbar bort."

#: ../../library/ast.rst:2332
msgid ""
"Return the docstring of the given *node* (which must be a :class:"
"`FunctionDef`, :class:`AsyncFunctionDef`, :class:`ClassDef`, or :class:"
"`Module` node), or ``None`` if it has no docstring. If *clean* is true, "
"clean up the docstring's indentation with :func:`inspect.cleandoc`."
msgstr ""
"Returnerar dokumentsträngen för den givna *noden* (som måste vara en :class:"
"`FunctionDef`, :class:`AsyncFunctionDef`, :class:`ClassDef`, eller :class:"
"`Module` nod), eller ``None`` om den inte har någon dokumentsträng. Om "
"*clean* är true, rensa upp dokumentsträngens indrag med :func:`inspect."
"cleandoc`."

#: ../../library/ast.rst:2338
msgid ":class:`AsyncFunctionDef` is now supported."
msgstr ":class:`AsyncFunctionDef` stöds nu."

#: ../../library/ast.rst:2344
msgid ""
"Get source code segment of the *source* that generated *node*. If some "
"location information (:attr:`~ast.AST.lineno`, :attr:`~ast.AST.end_lineno`, :"
"attr:`~ast.AST.col_offset`, or :attr:`~ast.AST.end_col_offset`) is missing, "
"return ``None``."
msgstr ""
"Hämta källkodssegmentet för den *källa* som genererade *nod*. Om någon "
"platsinformation (:attr:`~ast.AST.lineno`, :attr:`~ast.AST.end_lineno`, :"
"attr:`~ast.AST.col_offset`, eller :attr:`~ast.AST.end_col_offset`) saknas, "
"returneras ``None``."

#: ../../library/ast.rst:2348
msgid ""
"If *padded* is ``True``, the first line of a multi-line statement will be "
"padded with spaces to match its original position."
msgstr ""
"Om *padded* är ``True``, kommer den första raden i ett flerradigt uttalande "
"att fyllas med mellanslag för att matcha dess ursprungliga position."

#: ../../library/ast.rst:2356
msgid ""
"When you compile a node tree with :func:`compile`, the compiler expects :"
"attr:`~ast.AST.lineno` and :attr:`~ast.AST.col_offset` attributes for every "
"node that supports them.  This is rather tedious to fill in for generated "
"nodes, so this helper adds these attributes recursively where not already "
"set, by setting them to the values of the parent node.  It works recursively "
"starting at *node*."
msgstr ""
"När du kompilerar ett nodträd med :func:`compile` förväntar sig kompilatorn "
"attributen :attr:`~ast.AST.lineno` och :attr:`~ast.AST.col_offset` för varje "
"nod som stöder dem.  Detta är ganska tråkigt att fylla i för genererade "
"noder, så den här hjälpen lägger till dessa attribut rekursivt där de inte "
"redan är inställda, genom att ställa in dem till värdena för den överordnade "
"noden.  Det fungerar rekursivt med början på *node*."

#: ../../library/ast.rst:2365
msgid ""
"Increment the line number and end line number of each node in the tree "
"starting at *node* by *n*. This is useful to \"move code\" to a different "
"location in a file."
msgstr ""
"Öka radnumret och slutradnumret för varje nod i trädet som börjar vid *nod* "
"med *n*. Detta är användbart för att \"flytta kod\" till en annan plats i en "
"fil."

#: ../../library/ast.rst:2372
msgid ""
"Copy source location (:attr:`~ast.AST.lineno`, :attr:`~ast.AST.col_offset`, :"
"attr:`~ast.AST.end_lineno`, and :attr:`~ast.AST.end_col_offset`) from "
"*old_node* to *new_node* if possible, and return *new_node*."
msgstr ""
"Kopiera källplatsen (:attr:`~ast.AST.lineno`, :attr:`~ast.AST.col_offset`, :"
"attr:`~ast.AST.end_lineno`, och :attr:`~ast.AST.end_col_offset`) från "
"*old_node* till *new_node* om möjligt, och returnera *new_node*."

#: ../../library/ast.rst:2379
msgid ""
"Yield a tuple of ``(fieldname, value)`` for each field in ``node._fields`` "
"that is present on *node*."
msgstr ""
"Ger en tupel av ``(fältnamn, värde)`` för varje fält i ``node._fields`` som "
"finns på *node*."

#: ../../library/ast.rst:2385
msgid ""
"Yield all direct child nodes of *node*, that is, all fields that are nodes "
"and all items of fields that are lists of nodes."
msgstr ""
"Ger alla direkta underordnade noder till *node*, dvs. alla fält som är noder "
"och alla fältobjekt som är listor över noder."

#: ../../library/ast.rst:2391
msgid ""
"Recursively yield all descendant nodes in the tree starting at *node* "
"(including *node* itself), in no specified order.  This is useful if you "
"only want to modify nodes in place and don't care about the context."
msgstr ""
"Ger rekursivt alla nedstigande noder i trädet som börjar på *node* "
"(inklusive *node* själv), utan specificerad ordning.  Detta är användbart om "
"du bara vill modifiera noder på plats och inte bryr dig om sammanhanget."

#: ../../library/ast.rst:2398
msgid ""
"A node visitor base class that walks the abstract syntax tree and calls a "
"visitor function for every node found.  This function may return a value "
"which is forwarded by the :meth:`visit` method."
msgstr ""
"En basklass för nodbesökare som går igenom det abstrakta syntaxträdet och "
"anropar en besökarfunktion för varje nod som hittas.  Denna funktion kan "
"returnera ett värde som vidarebefordras av :meth:`visit`-metoden."

#: ../../library/ast.rst:2402
msgid ""
"This class is meant to be subclassed, with the subclass adding visitor "
"methods."
msgstr ""
"Denna klass är avsedd att underklassificeras, varvid underklassen lägger "
"till besöksmetoder."

#: ../../library/ast.rst:2407
msgid ""
"Visit a node.  The default implementation calls the method called :samp:"
"`self.visit_{classname}` where *classname* is the name of the node class, "
"or :meth:`generic_visit` if that method doesn't exist."
msgstr ""
"Besöker en nod.  Standardimplementeringen anropar metoden som heter :samp:"
"`self.visit_{classname}` där *klassnamn* är namnet på nodklassen, eller :"
"meth:`generic_visit` om den metoden inte finns."

#: ../../library/ast.rst:2413
msgid "This visitor calls :meth:`visit` on all children of the node."
msgstr "Den här besökaren anropar :meth:`visit` på alla barn till noden."

#: ../../library/ast.rst:2415
msgid ""
"Note that child nodes of nodes that have a custom visitor method won't be "
"visited unless the visitor calls :meth:`generic_visit` or visits them itself."
msgstr ""
"Observera att barnnoder till noder som har en anpassad besöksmetod inte "
"kommer att besökas om inte besökaren anropar :meth:`generic_visit` eller "
"besöker dem själv."

#: ../../library/ast.rst:2421
msgid "Handles all constant nodes."
msgstr "Hanterar alla konstanta noder."

#: ../../library/ast.rst:2423
msgid ""
"Don't use the :class:`NodeVisitor` if you want to apply changes to nodes "
"during traversal.  For this a special visitor exists (:class:"
"`NodeTransformer`) that allows modifications."
msgstr ""
"Använd inte :class:`NodeVisitor` om du vill göra ändringar i noder under "
"traversal.  För detta finns en speciell besökare (:class:`NodeTransformer`) "
"som tillåter ändringar."

#: ../../library/ast.rst:2429
msgid ""
"Methods :meth:`!visit_Num`, :meth:`!visit_Str`, :meth:`!visit_Bytes`, :meth:"
"`!visit_NameConstant` and :meth:`!visit_Ellipsis` are deprecated now and "
"will not be called in future Python versions.  Add the :meth:"
"`visit_Constant` method to handle all constant nodes."
msgstr ""
"Metoderna :meth:`!visit_Num`, :meth:`!visit_Str`, :meth:`!visit_Bytes`, :"
"meth:`!visit_NameConstant` och :meth:`!visit_Ellipsis` är föråldrade nu och "
"kommer inte att anropas i framtida Python-versioner.  Lägg till metoden :"
"meth:`visit_Constant` för att hantera alla konstanta noder."

#: ../../library/ast.rst:2437
msgid ""
"A :class:`NodeVisitor` subclass that walks the abstract syntax tree and "
"allows modification of nodes."
msgstr ""
"En :class:`NodeVisitor`-underklass som går igenom det abstrakta syntaxträdet "
"och tillåter modifiering av noder."

#: ../../library/ast.rst:2440
msgid ""
"The :class:`NodeTransformer` will walk the AST and use the return value of "
"the visitor methods to replace or remove the old node.  If the return value "
"of the visitor method is ``None``, the node will be removed from its "
"location, otherwise it is replaced with the return value.  The return value "
"may be the original node in which case no replacement takes place."
msgstr ""
":class:`NodeTransformer` kommer att gå igenom AST och använda returvärdet "
"från besöksmetoderna för att ersätta eller ta bort den gamla noden.  Om "
"besöksmetodens returvärde är ``None`` kommer noden att tas bort från sin "
"plats, annars ersätts den med returvärdet.  Returvärdet kan vara den "
"ursprungliga noden och i så fall sker ingen ersättning."

#: ../../library/ast.rst:2446
msgid ""
"Here is an example transformer that rewrites all occurrences of name lookups "
"(``foo``) to ``data['foo']``::"
msgstr ""
"Här är ett exempel på en transformator som skriver om alla förekomster av "
"namnuppslagningar (``foo``) till ``data['foo']``::"

#: ../../library/ast.rst:2449
msgid ""
"class RewriteName(NodeTransformer):\n"
"\n"
"    def visit_Name(self, node):\n"
"        return Subscript(\n"
"            value=Name(id='data', ctx=Load()),\n"
"            slice=Constant(value=node.id),\n"
"            ctx=node.ctx\n"
"        )"
msgstr ""
"klass RewriteName(NodeTransformer):\n"
"\n"
"    def visit_Name(self, node):\n"
"        return Subscript(\n"
"            value=Namn(id='data', ctx=Load()),\n"
"            slice=Konstant(värde=node.id),\n"
"            ctx=nod.ctx\n"
"        )"

#: ../../library/ast.rst:2458
msgid ""
"Keep in mind that if the node you're operating on has child nodes you must "
"either transform the child nodes yourself or call the :meth:`~ast."
"NodeVisitor.generic_visit` method for the node first."
msgstr ""
"Tänk på att om den nod du använder har underordnade noder måste du antingen "
"transformera de underordnade noderna själv eller anropa metoden :meth:`~ast."
"NodeVisitor.generic_visit` för noden först."

#: ../../library/ast.rst:2462
msgid ""
"For nodes that were part of a collection of statements (that applies to all "
"statement nodes), the visitor may also return a list of nodes rather than "
"just a single node."
msgstr ""
"För noder som ingick i en samling uttalanden (det gäller alla "
"uttalandenoder) kan besökaren också returnera en lista med noder i stället "
"för bara en enda nod."

#: ../../library/ast.rst:2466
msgid ""
"If :class:`NodeTransformer` introduces new nodes (that weren't part of "
"original tree) without giving them location information (such as :attr:`~ast."
"AST.lineno`), :func:`fix_missing_locations` should be called with the new "
"sub-tree to recalculate the location information::"
msgstr ""
"Om :class:`NodeTransformer` introducerar nya noder (som inte var en del av "
"det ursprungliga trädet) utan att ge dem platsinformation (t.ex. :attr:`~ast."
"AST.lineno`), bör :func:`fix_missing_locations` anropas med det nya "
"delträdet för att räkna om platsinformationen::"

#: ../../library/ast.rst:2471
msgid ""
"tree = ast.parse('foo', mode='eval')\n"
"new_tree = fix_missing_locations(RewriteName().visit(tree))"
msgstr ""
"träd = ast.parse('foo', mode='eval')\n"
"new_tree = fix_missing_locations(RewriteName().visit(tree))"

#: ../../library/ast.rst:2474
msgid "Usually you use the transformer like this::"
msgstr "Vanligtvis använder du transformatorn på följande sätt::"

#: ../../library/ast.rst:2476
msgid "node = YourTransformer().visit(node)"
msgstr "nod = DinTransformator().visit(nod)"

#: ../../library/ast.rst:2481
msgid ""
"Return a formatted dump of the tree in *node*.  This is mainly useful for "
"debugging purposes.  If *annotate_fields* is true (by default), the returned "
"string will show the names and the values for fields. If *annotate_fields* "
"is false, the result string will be more compact by omitting unambiguous "
"field names.  Attributes such as line numbers and column offsets are not "
"dumped by default.  If this is wanted, *include_attributes* can be set to "
"true."
msgstr ""
"Returnerar en formaterad dumpning av trädet i *node*.  Detta är främst "
"användbart för felsökning.  Om *annotate_fields* är true (standard) kommer "
"den returnerade strängen att visa namn och värden för fälten. Om "
"*annotate_fields* är false blir resultatsträngen mer kompakt genom att "
"otvetydiga fältnamn utelämnas.  Attribut som radnummer och kolumnoffset "
"dumpas inte som standard.  Om detta önskas kan *include_attributes* sättas "
"till true."

#: ../../library/ast.rst:2489
msgid ""
"If *indent* is a non-negative integer or string, then the tree will be "
"pretty-printed with that indent level.  An indent level of 0, negative, or "
"``\"\"`` will only insert newlines.  ``None`` (the default) selects the "
"single line representation. Using a positive integer indent indents that "
"many spaces per level.  If *indent* is a string (such as ``\"\\t\"``), that "
"string is used to indent each level."
msgstr ""
"Om *indent* är ett icke-negativt heltal eller en sträng, kommer trädet att "
"skrivas ut med den indragsnivån.  En indragsnivå på 0, negativ eller "
"``\"\"`` kommer endast att infoga nya rader.  ``None`` (standard) väljer "
"representation med en rad. Om du använder ett positivt heltal indenteras så "
"många mellanslag per nivå.  Om *indent* är en sträng (t.ex. ``\"\\t\"``) "
"används den strängen för att dra in varje nivå."

#: ../../library/ast.rst:2496
msgid ""
"If *show_empty* is false (the default), optional empty lists will be omitted "
"from the output. Optional ``None`` values are always omitted."
msgstr ""
"Om *show_empty* är false (standard) kommer valfria tomma listor att "
"utelämnas från utdata. Valfria ``None``-värden utelämnas alltid."

#: ../../library/ast.rst:2500
msgid "Added the *indent* option."
msgstr "Lagt till alternativet *indent*."

#: ../../library/ast.rst:2503
msgid "Added the *show_empty* option."
msgstr "Lagt till alternativet *show_empty*."

#: ../../library/ast.rst:2506
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... async def f():\n"
"...     await other_func()\n"
"... \"\"\"), indent=4, show_empty=True))\n"
"Module(\n"
"    body=[\n"
"        AsyncFunctionDef(\n"
"            name='f',\n"
"            args=arguments(\n"
"                posonlyargs=[],\n"
"                args=[],\n"
"                kwonlyargs=[],\n"
"                kw_defaults=[],\n"
"                defaults=[]),\n"
"            body=[\n"
"                Expr(\n"
"                    value=Await(\n"
"                        value=Call(\n"
"                            func=Name(id='other_func', ctx=Load()),\n"
"                            args=[],\n"
"                            keywords=[])))],\n"
"            decorator_list=[],\n"
"            type_params=[])],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... asynkron def f():\n"
"... vänta på andra_func()\n"
"... \"\"\"), indent=4, show_empty=True))\n"
"Modul(\n"
"    body=[\n"
"        AsyncFunctionDef(\n"
"            name='f',\n"
"            args=argument(\n"
"                posonlyargs=[],\n"
"                args=[],\n"
"                kwonlyargs=[],\n"
"                kw_defaults=[],\n"
"                defaults=[]),\n"
"            body=[\n"
"                Expr(\n"
"                    värde=Vänta(\n"
"                        värde=Kalla(\n"
"                            func=Namn(id='other_func', ctx=Load()),\n"
"                            args=[],\n"
"                            nyckelord=[])))]],\n"
"            decorator_list=[],\n"
"            type_params=[])],\n"
"    typ_ignores=[])"

#: ../../library/ast.rst:2537
msgid "Compiler flags"
msgstr "Flaggor för kompilator"

#: ../../library/ast.rst:2539
msgid ""
"The following flags may be passed to :func:`compile` in order to change "
"effects on the compilation of a program:"
msgstr ""
"Följande flaggor kan skickas till :func:`compile` för att ändra effekterna "
"på kompileringen av ett program:"

#: ../../library/ast.rst:2544
msgid ""
"Enables support for top-level ``await``, ``async for``, ``async with`` and "
"async comprehensions."
msgstr ""
"Aktiverar stöd för toppnivå ``await``, ``async for``, ``async with`` och "
"async-förståelser."

#: ../../library/ast.rst:2551
msgid ""
"Generates and returns an abstract syntax tree instead of returning a "
"compiled code object."
msgstr ""
"Genererar och returnerar ett abstrakt syntaxträd i stället för att returnera "
"ett kompilerat kodobjekt."

#: ../../library/ast.rst:2556
msgid ""
"The returned AST is optimized according to the *optimize* argument in :func:"
"`compile` or :func:`ast.parse`."
msgstr ""
"Den returnerade AST:n optimeras enligt *optimize*-argumentet i :func:"
"`compile` eller :func:`ast.parse`."

#: ../../library/ast.rst:2563
msgid ""
"Enables support for :pep:`484` and :pep:`526` style type comments (``# type: "
"<type>``, ``# type: ignore <stuff>``)."
msgstr ""
"Aktiverar stöd för typkommentarer i stil med :pep:`484` och :pep:`526` (``# "
"type: <type>``, ``# type: ignore <stuff>``)."

#: ../../library/ast.rst:2571
msgid "Recursively compares two ASTs."
msgstr "Jämför rekursivt två AST:er."

#: ../../library/ast.rst:2573
msgid ""
"*compare_attributes* affects whether AST attributes are considered in the "
"comparison. If *compare_attributes* is ``False`` (default), then attributes "
"are ignored. Otherwise they must all be equal. This option is useful to "
"check whether the ASTs are structurally equal but differ in whitespace or "
"similar details. Attributes include line numbers and column offsets."
msgstr ""
"*compare_attributes* påverkar om AST-attribut ska beaktas i jämförelsen. Om "
"*compare_attributes* är ``False`` (standard) ignoreras attributen. Annars "
"måste de alla vara lika. Det här alternativet är användbart för att "
"kontrollera om AST:erna är strukturellt lika men skiljer sig åt i blanksteg "
"eller liknande detaljer. Attribut inkluderar radnummer och kolumnoffset."

#: ../../library/ast.rst:2586
msgid "Command-line usage"
msgstr "Användning av kommandoraden"

#: ../../library/ast.rst:2590
msgid ""
"The :mod:`ast` module can be executed as a script from the command line. It "
"is as simple as:"
msgstr ""
"Modulen :mod:`ast` kan köras som ett skript från kommandoraden. Det är så "
"enkelt som att:"

#: ../../library/ast.rst:2593
msgid "python -m ast [-m <mode>] [-a] [infile]"
msgstr "python -m ast [-m <mode>] [-a] [infile]"

#: ../../library/ast.rst:2597
msgid "The following options are accepted:"
msgstr "Följande alternativ accepteras:"

#: ../../library/ast.rst:2603
msgid "Show the help message and exit."
msgstr "Visa hjälpmeddelandet och avsluta."

#: ../../library/ast.rst:2608
msgid ""
"Specify what kind of code must be compiled, like the *mode* argument in :"
"func:`parse`."
msgstr ""
"Ange vilken typ av kod som ska kompileras, som *mode*-argumentet i :func:"
"`parse`."

#: ../../library/ast.rst:2613
msgid "Don't parse type comments."
msgstr "Analysera inte typkommentarer."

#: ../../library/ast.rst:2617
msgid "Include attributes such as line numbers and column offsets."
msgstr "Inkludera attribut som radnummer och kolumnförskjutningar."

#: ../../library/ast.rst:2622
msgid "Indentation of nodes in AST (number of spaces)."
msgstr "Indragning av noder i AST (antal mellanslag)."

#: ../../library/ast.rst:2626
msgid ""
"Python version in the format 3.x (for example, 3.10). Defaults to the "
"current version of the interpreter."
msgstr ""
"Python-version i formatet 3.x (t.ex. 3.10). Standardvärdet är den aktuella "
"versionen av tolken."

#: ../../library/ast.rst:2634
msgid "Optimization level for parser. Defaults to no optimization."
msgstr "Optimeringsnivå för parsern. Standardvärdet är ingen optimering."

#: ../../library/ast.rst:2640
msgid ""
"Show empty lists and fields that are ``None``. Defaults to not showing empty "
"objects."
msgstr ""
"Visa tomma listor och fält som är ``None``. Standardinställningen är att "
"inte visa tomma objekt."

#: ../../library/ast.rst:2646
msgid ""
"If :file:`infile` is specified its contents are parsed to AST and dumped to "
"stdout.  Otherwise, the content is read from stdin."
msgstr ""
"Om :file:`infile` anges analyseras dess innehåll till AST och dumpas till "
"stdout.  I annat fall läses innehållet från stdin."

#: ../../library/ast.rst:2652
msgid ""
"`Green Tree Snakes <https://greentreesnakes.readthedocs.io/>`_, an external "
"documentation resource, has good details on working with Python ASTs."
msgstr ""
"`Green Tree Snakes <https://greentreesnakes.readthedocs.io/>`_, en extern "
"dokumentationsresurs, har bra detaljer om hur man arbetar med Python ASTs."

#: ../../library/ast.rst:2655
msgid ""
"`ASTTokens <https://asttokens.readthedocs.io/en/latest/user-guide.html>`_ "
"annotates Python ASTs with the positions of tokens and text in the source "
"code that generated them. This is helpful for tools that make source code "
"transformations."
msgstr ""
"`ASTTokens <https://asttokens.readthedocs.io/en/latest/user-guide.html>`_ "
"annoterar Python ASTs med positionerna för tokens och text i källkoden som "
"genererade dem. Detta är användbart för verktyg som gör "
"källkodstransformationer."

#: ../../library/ast.rst:2660
msgid ""
"`leoAst.py <https://leo-editor.github.io/leo-editor/appendices.html#leoast-"
"py>`_ unifies the token-based and parse-tree-based views of python programs "
"by inserting two-way links between tokens and ast nodes."
msgstr ""
"`leoAst.py <https://leo-editor.github.io/leo-editor/appendices.html#leoast-"
"py>`_ förenar de tokenbaserade och parse-tree-baserade vyerna av "
"pythonprogram genom att infoga tvåvägslänkar mellan tokens och ast-noder."

#: ../../library/ast.rst:2665
msgid ""
"`LibCST <https://libcst.readthedocs.io/>`_ parses code as a Concrete Syntax "
"Tree that looks like an ast tree and keeps all formatting details. It's "
"useful for building automated refactoring (codemod) applications and linters."
msgstr ""
"`LibCST <https://libcst.readthedocs.io/>`_ analyserar kod som ett konkret "
"syntaxträd som ser ut som ett asträd och behåller alla formateringsdetaljer. "
"Det är användbart för att bygga automatiserade refaktoriseringsprogram "
"(codemod) och linters."

#: ../../library/ast.rst:2670
msgid ""
"`Parso <https://parso.readthedocs.io>`_ is a Python parser that supports "
"error recovery and round-trip parsing for different Python versions (in "
"multiple Python versions). Parso is also able to list multiple syntax errors "
"in your Python file."
msgstr ""
"`Parso <https://parso.readthedocs.io>`_ är en Python-parser som stöder "
"felåterställning och round-trip-parsing för olika Python-versioner (i flera "
"Python-versioner). Parso kan också lista flera syntaxfel i din Python-fil."

#: ../../library/ast.rst:59
msgid "? (question mark)"
msgstr "? (frågetecken)"

#: ../../library/ast.rst:59 ../../library/ast.rst:60
msgid "in AST grammar"
msgstr "i AST-grammatik"

#: ../../library/ast.rst:60
msgid "* (asterisk)"
msgstr "* (asterisk)"
