# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# python-doc bot, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-25 17:21+0000\n"
"PO-Revision-Date: 2025-09-22 15:57+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../library/ast.rst:2
msgid ":mod:`ast` --- Abstract Syntax Trees"
msgstr ""

#: ../../library/ast.rst:14
msgid "**Source code:** :source:`Lib/ast.py`"
msgstr "**Källkod:** :source:`Lib/ast.py`"

#: ../../library/ast.rst:18
msgid ""
"The :mod:`ast` module helps Python applications to process trees of the "
"Python abstract syntax grammar.  The abstract syntax itself might change "
"with each Python release; this module helps to find out programmatically "
"what the current grammar looks like."
msgstr ""
"Modulen :mod:`ast` hjälper Python-program att bearbeta träd av Pythons "
"abstrakta syntaxgrammatik.  Den abstrakta syntaxen i sig kan ändras med "
"varje Python-version; den här modulen hjälper till att programmatiskt ta "
"reda på hur den aktuella grammatiken ser ut."

#: ../../library/ast.rst:23
msgid ""
"An abstract syntax tree can be generated by passing "
":data:`ast.PyCF_ONLY_AST` as a flag to the :func:`compile` built-in "
"function, or using the :func:`parse` helper provided in this module.  The "
"result will be a tree of objects whose classes all inherit from "
":class:`ast.AST`.  An abstract syntax tree can be compiled into a Python "
"code object using the built-in :func:`compile` function."
msgstr ""
"Ett abstrakt syntaxträd kan genereras genom att skicka "
":data:`ast.PyCF_ONLY_AST` som en flagga till den inbyggda funktionen "
":func:`compile`, eller genom att använda hjälpen :func:`parse` som finns i "
"den här modulen.  Resultatet blir ett träd av objekt vars klasser alla ärver"
" från :class:`ast.AST`.  Ett abstrakt syntaxträd kan kompileras till ett "
"Python-kodobjekt med hjälp av den inbyggda funktionen :func:`compile`."

#: ../../library/ast.rst:33
msgid "Abstract Grammar"
msgstr ""

#: ../../library/ast.rst:35
msgid "The abstract grammar is currently defined as follows:"
msgstr "Den abstrakta grammatiken definieras för närvarande på följande sätt:"

#: ../../library/ast.rst:42
msgid "Node classes"
msgstr "Klasser för noder"

#: ../../library/ast.rst:46
msgid ""
"This is the base of all AST node classes.  The actual node classes are "
"derived from the :file:`Parser/Python.asdl` file, which is reproduced "
":ref:`above <abstract-grammar>`.  They are defined in the :mod:`_ast` C "
"module and re-exported in :mod:`ast`."
msgstr ""

#: ../../library/ast.rst:51
msgid ""
"There is one class defined for each left-hand side symbol in the abstract "
"grammar (for example, :class:`ast.stmt` or :class:`ast.expr`).  In addition,"
" there is one class defined for each constructor on the right-hand side; "
"these classes inherit from the classes for the left-hand side trees.  For "
"example, :class:`ast.BinOp` inherits from :class:`ast.expr`.  For production"
" rules with alternatives (aka \"sums\"), the left-hand side class is "
"abstract: only instances of specific constructor nodes are ever created."
msgstr ""
"Det finns en klass definierad för varje symbol på vänstersidan i den "
"abstrakta grammatiken (t.ex. :class:`ast.stmt` eller :class:`ast.expr`).  "
"Dessutom finns det en klass definierad för varje konstruktör på högersidan; "
"dessa klasser ärver från klasserna för vänstersidans träd.  Till exempel "
"ärver :class:`ast.BinOp` från :class:`ast.expr`.  För produktionsregler med "
"alternativ (även kallade \"summor\") är klassen på vänster sida abstrakt: "
"endast instanser av specifika konstruktörsnoder skapas någonsin."

#: ../../library/ast.rst:64
msgid ""
"Each concrete class has an attribute :attr:`_fields` which gives the names "
"of all child nodes."
msgstr ""

#: ../../library/ast.rst:67
msgid ""
"Each instance of a concrete class has one attribute for each child node, of "
"the type as defined in the grammar.  For example, :class:`ast.BinOp` "
"instances have an attribute :attr:`left` of type :class:`ast.expr`."
msgstr ""
"Varje instans av en konkret klass har ett attribut för varje underordnad "
"nod, av den typ som definieras i grammatiken.  Exempelvis har instanser av "
":class:`ast.BinOp` ett attribut :attr:`left` av typen :class:`ast.expr`."

#: ../../library/ast.rst:71
msgid ""
"If these attributes are marked as optional in the grammar (using a question "
"mark), the value might be ``None``.  If the attributes can have zero-or-more"
" values (marked with an asterisk), the values are represented as Python "
"lists.  All possible attributes must be present and have valid values when "
"compiling an AST with :func:`compile`."
msgstr ""
"Om dessa attribut är markerade som valfria i grammatiken (med ett "
"frågetecken) kan värdet vara ``None``.  Om attributen kan ha noll eller fler"
" värden (markerade med en asterisk), representeras värdena som Python-"
"listor.  Alla möjliga attribut måste finnas och ha giltiga värden när man "
"kompilerar en AST med :func:`compile`."

#: ../../library/ast.rst:82
msgid ""
"Instances of :class:`ast.expr` and :class:`ast.stmt` subclasses have "
":attr:`lineno`, :attr:`col_offset`, :attr:`end_lineno`, and "
":attr:`end_col_offset` attributes.  The :attr:`lineno` and "
":attr:`end_lineno` are the first and last line numbers of source text span "
"(1-indexed so the first line is line 1) and the :attr:`col_offset` and "
":attr:`end_col_offset` are the corresponding UTF-8 byte offsets of the first"
" and last tokens that generated the node. The UTF-8 offset is recorded "
"because the parser uses UTF-8 internally."
msgstr ""
"Instanser av underklasserna :class:`ast.expr` och :class:`ast.stmt` har "
"attributen :attr:`lineno`, :attr:`col_offset`, :attr:`end_lineno` och "
":attr:`end_col_offset`.  Attributen :attr:`lineno` och :attr:`end_lineno` är"
" det första och sista radnumret i källtexten (1-indexerat så att den första "
"raden är rad 1) och attributen :attr:`col_offset` och :attr:`end_col_offset`"
" är motsvarande UTF-8-byteoffset för den första och sista tokens som "
"genererade noden. UTF-8-offset registreras eftersom parsern använder UTF-8 "
"internt."

#: ../../library/ast.rst:91
msgid ""
"Note that the end positions are not required by the compiler and are "
"therefore optional. The end offset is *after* the last symbol, for example "
"one can get the source segment of a one-line expression node using "
"``source_line[node.col_offset : node.end_col_offset]``."
msgstr ""
"Observera att slutpositionerna inte krävs av kompilatorn och därför är "
"valfria. Slutoffsetet är *efter* den sista symbolen, till exempel kan man få"
" källsegmentet för en nod med enradigt uttryck med hjälp av "
"``source_line[node.col_offset : node.end_col_offset]``."

#: ../../library/ast.rst:96
msgid ""
"The constructor of a class :class:`ast.T` parses its arguments as follows:"
msgstr ""
"Konstruktören för en klass :class:`ast.T` analyserar sina argument på "
"följande sätt:"

#: ../../library/ast.rst:98
msgid ""
"If there are positional arguments, there must be as many as there are items "
"in :attr:`T._fields`; they will be assigned as attributes of these names."
msgstr ""
"Om det finns positionella argument måste det finnas lika många som det finns"
" objekt i :attr:`T._fields`; de kommer att tilldelas som attribut till dessa"
" namn."

#: ../../library/ast.rst:100
msgid ""
"If there are keyword arguments, they will set the attributes of the same "
"names to the given values."
msgstr ""
"Om det finns nyckelordsargument kommer de att ställa in attributen med samma"
" namn till de angivna värdena."

#: ../../library/ast.rst:103
msgid ""
"For example, to create and populate an :class:`ast.UnaryOp` node, you could "
"use ::"
msgstr ""
"Om du till exempel vill skapa och fylla i en :class:`ast.UnaryOp`\\-nod kan "
"du använda ::"

#: ../../library/ast.rst:115
msgid "or the more compact ::"
msgstr ""

#: ../../library/ast.rst:122
msgid "Class :class:`ast.Constant` is now used for all constants."
msgstr "Klassen :class:`ast.Constant` används nu för alla konstanter."

#: ../../library/ast.rst:126
msgid ""
"Simple indices are represented by their value, extended slices are "
"represented as tuples."
msgstr ""
"Enkla index representeras av sitt värde, extended slices representeras som "
"tupler."

#: ../../library/ast.rst:131
msgid ""
"Old classes :class:`ast.Num`, :class:`ast.Str`, :class:`ast.Bytes`, "
":class:`ast.NameConstant` and :class:`ast.Ellipsis` are still available, but"
" they will be removed in future Python releases.  In the meantime, "
"instantiating them will return an instance of a different class."
msgstr ""

#: ../../library/ast.rst:138
msgid ""
"Old classes :class:`ast.Index` and :class:`ast.ExtSlice` are still "
"available, but they will be removed in future Python releases. In the "
"meantime, instantiating them will return an instance of a different class."
msgstr ""

#: ../../library/ast.rst:144
msgid ""
"The descriptions of the specific node classes displayed here were initially "
"adapted from the fantastic `Green Tree Snakes "
"<https://greentreesnakes.readthedocs.io/en/latest/>`__ project and all its "
"contributors."
msgstr ""
"Beskrivningarna av de specifika nodklasserna som visas här anpassades "
"ursprungligen från det fantastiska projektet `Green Tree Snakes "
"<https://greentreesnakes.readthedocs.io/en/latest/>`__ och alla dess "
"bidragsgivare."

#: ../../library/ast.rst:150
msgid "Literals"
msgstr "Bokstäver"

#: ../../library/ast.rst:154
msgid ""
"A constant value. The ``value`` attribute of the ``Constant`` literal "
"contains the Python object it represents. The values represented can be "
"simple types such as a number, string or ``None``, but also immutable "
"container types (tuples and frozensets) if all of their elements are "
"constant."
msgstr ""

#: ../../library/ast.rst:168
msgid ""
"Node representing a single formatting field in an f-string. If the string "
"contains a single formatting field and nothing else the node can be isolated"
" otherwise it appears in :class:`JoinedStr`."
msgstr ""
"Nod som representerar ett enda formateringsfält i en f-sträng. Om strängen "
"innehåller ett enda formateringsfält och inget annat kan noden isoleras, "
"annars visas den i :class:`JoinedStr`."

#: ../../library/ast.rst:172
msgid ""
"``value`` is any expression node (such as a literal, a variable, or a "
"function call)."
msgstr ""
"``värde`` är vilken uttrycksnod som helst (t.ex. en bokstav, en variabel "
"eller ett funktionsanrop)."

#: ../../library/ast.rst:174
msgid "``conversion`` is an integer:"
msgstr "``konvertering`` är ett heltal:"

#: ../../library/ast.rst:176
msgid "-1: no formatting"
msgstr "-1: ingen formatering"

#: ../../library/ast.rst:177
msgid "115: ``!s`` string formatting"
msgstr ""

#: ../../library/ast.rst:178
msgid "114: ``!r`` repr formatting"
msgstr ""

#: ../../library/ast.rst:179
msgid "97: ``!a`` ascii formatting"
msgstr ""

#: ../../library/ast.rst:181
msgid ""
"``format_spec`` is a :class:`JoinedStr` node representing the formatting of "
"the value, or ``None`` if no format was specified. Both ``conversion`` and "
"``format_spec`` can be set at the same time."
msgstr ""
"``format_spec`` är en :class:`JoinedStr`\\-nod som representerar "
"formateringen av värdet, eller ``None`` om inget format har angetts. Både "
"``conversion`` och ``format_spec`` kan anges samtidigt."

#: ../../library/ast.rst:188
msgid ""
"An f-string, comprising a series of :class:`FormattedValue` and "
":class:`Constant` nodes."
msgstr ""
"En f-sträng som består av en serie :class:`FormattedValue`\\- och "
":class:`Constant`\\-noder."

#: ../../library/ast.rst:217
msgid ""
"A list or tuple. ``elts`` holds a list of nodes representing the elements. "
"``ctx`` is :class:`Store` if the container is an assignment target (i.e. "
"``(x,y)=something``), and :class:`Load` otherwise."
msgstr ""
"En lista eller tupel. ``elts`` innehåller en lista med noder som "
"representerar elementen. ``ctx`` är :class:`Store`` om behållaren är ett mål"
" för en tilldelning (dvs. ``(x,y)=något``), och :class:`Load`` annars."

#: ../../library/ast.rst:243
msgid "A set. ``elts`` holds a list of nodes representing the set's elements."
msgstr ""
"En uppsättning. ``elts`` innehåller en lista med noder som representerar "
"setets element."

#: ../../library/ast.rst:258
msgid ""
"A dictionary. ``keys`` and ``values`` hold lists of nodes representing the "
"keys and the values respectively, in matching order (what would be returned "
"when calling :code:`dictionary.keys()` and :code:`dictionary.values()`)."
msgstr ""
"En ordbok. ``keys`` och ``values`` innehåller listor med noder som "
"representerar nycklarna respektive värdena, i matchande ordning (vad som "
"skulle returneras vid anrop av :code:`dictionary.keys()` och "
":code:`dictionary.values()`)."

#: ../../library/ast.rst:262
msgid ""
"When doing dictionary unpacking using dictionary literals the expression to "
"be expanded goes in the ``values`` list, with a ``None`` at the "
"corresponding position in ``keys``."
msgstr ""
"Vid uppackning av ordböcker med hjälp av ordbokslitteraler hamnar det "
"uttryck som ska expanderas i listan ``values``, med en ``None`` på "
"motsvarande position i ``keys``."

#: ../../library/ast.rst:280
msgid "Variables"
msgstr "Variabler"

#: ../../library/ast.rst:284
msgid ""
"A variable name. ``id`` holds the name as a string, and ``ctx`` is one of "
"the following types."
msgstr ""
"Ett variabelnamn. ``id`` innehåller namnet som en sträng, och ``ctx`` är en "
"av följande typer."

#: ../../library/ast.rst:292
msgid ""
"Variable references can be used to load the value of a variable, to assign a"
" new value to it, or to delete it. Variable references are given a context "
"to distinguish these cases."
msgstr ""
"Variabelreferenser kan användas för att ladda en variabels värde, tilldela "
"den ett nytt värde eller ta bort den. Variabelreferenser ges ett sammanhang "
"för att skilja dessa fall åt."

#: ../../library/ast.rst:325
msgid ""
"A ``*var`` variable reference. ``value`` holds the variable, typically a "
":class:`Name` node. This type must be used when building a :class:`Call` "
"node with ``*args``."
msgstr ""
"En ``*var`` variabelreferens. ``value`` innehåller variabeln, vanligtvis en "
":class:`Name`\\-nod. Denna typ måste användas när man bygger en "
":class:`Call`\\-nod med ``*args``."

#: ../../library/ast.rst:348
msgid "Expressions"
msgstr "Uttryck"

#: ../../library/ast.rst:352
msgid ""
"When an expression, such as a function call, appears as a statement by "
"itself with its return value not used or stored, it is wrapped in this "
"container. ``value`` holds one of the other nodes in this section, a "
":class:`Constant`, a :class:`Name`, a :class:`Lambda`, a :class:`Yield` or "
":class:`YieldFrom` node."
msgstr ""
"När ett uttryck, t.ex. ett funktionsanrop, visas som en egen sats utan att "
"dess returvärde används eller lagras, omsluts det av denna container. "
"``value`` innehåller en av de andra noderna i detta avsnitt, en "
":class:`Constant`, en :class:`Name`, en :class:`Lambda`, en :class:`Yield` "
"eller :class:`YieldFrom` nod."

#: ../../library/ast.rst:371
msgid ""
"A unary operation. ``op`` is the operator, and ``operand`` any expression "
"node."
msgstr ""
"En unär operation. ``op`` är operatorn och ``operand`` en uttrycksnod."

#: ../../library/ast.rst:380
msgid ""
"Unary operator tokens. :class:`Not` is the ``not`` keyword, :class:`Invert` "
"is the ``~`` operator."
msgstr ""
"Unära operatortokens. :class:`Not` är nyckelordet ``not``, :class:`Invert` "
"är operatorn ``~``."

#: ../../library/ast.rst:394
msgid ""
"A binary operation (like addition or division). ``op`` is the operator, and "
"``left`` and ``right`` are any expression nodes."
msgstr ""
"En binär operation (som addition eller division). ``op`` är operatorn, och "
"``left`` och ``right`` är valfria uttrycksnoder."

#: ../../library/ast.rst:421
msgid "Binary operator tokens."
msgstr "Tokens för binära operatorer."

#: ../../library/ast.rst:426
msgid ""
"A boolean operation, 'or' or 'and'. ``op`` is :class:`Or` or :class:`And`. "
"``values`` are the values involved. Consecutive operations with the same "
"operator, such as ``a or b or c``, are collapsed into one node with several "
"values."
msgstr ""
"En boolesk operation, \"eller\" eller \"och\". ``op`` är :class:`Or` eller "
":class:`And`. ``values`` är de involverade värdena. På varandra följande "
"operationer med samma operator, t.ex. ``a eller b eller c``, slås samman "
"till en nod med flera värden."

#: ../../library/ast.rst:431
msgid "This doesn't include ``not``, which is a :class:`UnaryOp`."
msgstr "Detta inkluderar inte ``not``, som är en :class:`UnaryOp`."

#: ../../library/ast.rst:447
msgid "Boolean operator tokens."
msgstr "Tokens för booleska operatorer."

#: ../../library/ast.rst:452
msgid ""
"A comparison of two or more values. ``left`` is the first value in the "
"comparison, ``ops`` the list of operators, and ``comparators`` the list of "
"values after the first element in the comparison."
msgstr ""
"En jämförelse av två eller flera värden. ``left`` är det första värdet i "
"jämförelsen, ``ops`` listan med operatorer och ``comparators`` listan med "
"värden efter det första elementet i jämförelsen."

#: ../../library/ast.rst:481
msgid "Comparison operator tokens."
msgstr "Tokens för jämförelseoperator."

#: ../../library/ast.rst:486
msgid ""
"A function call. ``func`` is the function, which will often be a "
":class:`Name` or :class:`Attribute` object. Of the arguments:"
msgstr ""
"Ett anrop av en funktion. ``func`` är funktionen, som ofta kommer att vara "
"ett :class:`Name` eller :class:`Attribute` objekt. Av argumenten:"

#: ../../library/ast.rst:489
msgid "``args`` holds a list of the arguments passed by position."
msgstr ""
"``args`` innehåller en lista över de argument som skickas med position."

#: ../../library/ast.rst:490
msgid ""
"``keywords`` holds a list of :class:`keyword` objects representing arguments"
" passed by keyword."
msgstr ""

#: ../../library/ast.rst:493
msgid ""
"When creating a ``Call`` node, ``args`` and ``keywords`` are required, but "
"they can be empty lists. ``starargs`` and ``kwargs`` are optional."
msgstr ""

#: ../../library/ast.rst:517
msgid ""
"A keyword argument to a function call or class definition. ``arg`` is a raw "
"string of the parameter name, ``value`` is a node to pass in."
msgstr ""
"Ett nyckelordsargument till ett funktionsanrop eller en klassdefinition. "
"``arg`` är en rå sträng med parameternamnet, ``value`` är en nod att skicka "
"in."

#: ../../library/ast.rst:523
msgid ""
"An expression such as ``a if b else c``. Each field holds a single node, so "
"in the following example, all three are :class:`Name` nodes."
msgstr ""
"Ett uttryck som ``a if b else c``. Varje fält innehåller en enda nod, så i "
"följande exempel är alla tre :class:`Name`\\-noder."

#: ../../library/ast.rst:538
msgid ""
"Attribute access, e.g. ``d.keys``. ``value`` is a node, typically a "
":class:`Name`. ``attr`` is a bare string giving the name of the attribute, "
"and ``ctx`` is :class:`Load`, :class:`Store` or :class:`Del` according to "
"how the attribute is acted on."
msgstr ""
"Attributåtkomst, t.ex. ``d.keys``. ``value`` är en nod, vanligtvis en "
":class:`Name`. ``attr`` är en naken sträng som anger namnet på attributet, "
"och ``ctx`` är :class:`Load`, :class:`Store` eller :class:`Del` beroende på "
"hur attributet används."

#: ../../library/ast.rst:555
msgid ""
"A named expression. This AST node is produced by the assignment expressions "
"operator (also known as the walrus operator). As opposed to the "
":class:`Assign` node in which the first argument can be multiple nodes, in "
"this case both ``target`` and ``value`` must be single nodes."
msgstr ""
"Ett namngivet uttryck. Denna AST-nod produceras av operatorn för assignment-"
"uttryck (även känd som valrossoperatorn). I motsats till "
":class:`Assign`\\-noden där det första argumentet kan vara flera noder, "
"måste i detta fall både ``target`` och ``value`` vara enstaka noder."

#: ../../library/ast.rst:570
msgid "Subscripting"
msgstr "Subskription"

#: ../../library/ast.rst:574
msgid ""
"A subscript, such as ``l[1]``. ``value`` is the subscripted object (usually "
"sequence or mapping). ``slice`` is an index, slice or key. It can be a "
":class:`Tuple` and contain a :class:`Slice`. ``ctx`` is :class:`Load`, "
":class:`Store` or :class:`Del` according to the action performed with the "
"subscript."
msgstr ""
"Ett index, t.ex. ``l[1]``. ``value`` är det subskriberade objektet "
"(vanligtvis sekvens eller mappning). ``lice`` är ett index, en skiva eller "
"en nyckel. Det kan vara en :class:`Tuple` och innehålla en :class:`Slice`. "
"``ctx`` är :class:`Load`, :class:`Store` eller :class:`Del` beroende på "
"vilken åtgärd som utförs med subskriptionen."

#: ../../library/ast.rst:598
msgid ""
"Regular slicing (on the form ``lower:upper`` or ``lower:upper:step``). Can "
"occur only inside the *slice* field of :class:`Subscript`, either directly "
"or as an element of :class:`Tuple`."
msgstr ""
"Vanlig skärning (på formen ``lower:upper`` eller ``lower:upper:step``). Kan "
"endast förekomma i fältet *slice* i :class:`Subscript`, antingen direkt "
"eller som ett element i :class:`Tuple`."

#: ../../library/ast.rst:615
msgid "Comprehensions"
msgstr "Förståelse"

#: ../../library/ast.rst:622
msgid ""
"List and set comprehensions, generator expressions, and dictionary "
"comprehensions. ``elt`` (or ``key`` and ``value``) is a single node "
"representing the part that will be evaluated for each item."
msgstr ""
"List- och set-förståelser, generatoruttryck och ordboksförståelser. ``elt`` "
"(eller ``key`` och ``value``) är en enda nod som representerar den del som "
"kommer att utvärderas för varje objekt."

#: ../../library/ast.rst:626
msgid "``generators`` is a list of :class:`comprehension` nodes."
msgstr "``generators`` är en lista av :class:`comprehension` noder."

#: ../../library/ast.rst:668
msgid ""
"One ``for`` clause in a comprehension. ``target`` is the reference to use "
"for each element - typically a :class:`Name` or :class:`Tuple` node. "
"``iter`` is the object to iterate over. ``ifs`` is a list of test "
"expressions: each ``for`` clause can have multiple ``ifs``."
msgstr ""
"En ``for`` -sats i en förståelse. ``target`` är referensen som ska användas "
"för varje element - vanligtvis en :class:`Name` eller :class:`Tuple` -nod. "
"``iter`` är objektet som ska itereras över. ``ifs`` är en lista med "
"testuttryck: varje ``for`` -sats kan ha flera ``ifs``."

#: ../../library/ast.rst:673
msgid ""
"``is_async`` indicates a comprehension is asynchronous (using an ``async "
"for`` instead of ``for``). The value is an integer (0 or 1)."
msgstr ""
"``is_async`` indikerar att en förståelse är asynkron (använder en ``async "
"for`` istället för ``for``). Värdet är ett heltal (0 eller 1)."

#: ../../library/ast.rst:739
msgid "Statements"
msgstr "Specifikation"

#: ../../library/ast.rst:743
msgid ""
"An assignment. ``targets`` is a list of nodes, and ``value`` is a single "
"node."
msgstr ""
"En tilldelning. ``targets`` är en lista med noder och ``value`` är en "
"enskild nod."

#: ../../library/ast.rst:745
msgid ""
"Multiple nodes in ``targets`` represents assigning the same value to each. "
"Unpacking is represented by putting a :class:`Tuple` or :class:`List` within"
" ``targets``."
msgstr ""
"Flera noder i ``targets`` representerar att tilldela samma värde till alla. "
"Uppackning representeras genom att sätta en :class:`Tuple` eller "
":class:`List` inom ``targets``."

#: ../../library/ast.rst:751 ../../library/ast.rst:1038
#: ../../library/ast.rst:1211 ../../library/ast.rst:1632
msgid ""
"``type_comment`` is an optional string with the type annotation as a "
"comment."
msgstr ""
"``type_comment`` är en valfri sträng med typannoteringen som en kommentar."

#: ../../library/ast.rst:781
msgid ""
"An assignment with a type annotation. ``target`` is a single node and can be"
" a :class:`Name`, a :class:`Attribute` or a :class:`Subscript`. "
"``annotation`` is the annotation, such as a :class:`Constant` or "
":class:`Name` node. ``value`` is a single optional node. ``simple`` is a "
"boolean integer set to True for a :class:`Name` node in ``target`` that do "
"not appear in between parenthesis and are hence pure names and not "
"expressions."
msgstr ""

#: ../../library/ast.rst:836
msgid ""
"Augmented assignment, such as ``a += 1``. In the following example, "
"``target`` is a :class:`Name` node for ``x`` (with the :class:`Store` "
"context), ``op`` is :class:`Add`, and ``value`` is a :class:`Constant` with "
"value for 1."
msgstr ""
"Förstärkt tilldelning, t.ex. ``a += 1``. I följande exempel är ``target`` en"
" :class:`Name`\\-nod för ``x`` (med :class:`Store`\\-kontexten), ``op`` är "
":class:`Add`, och ``value`` är en :class:`Constant` med värdet 1."

#: ../../library/ast.rst:841
msgid ""
"The ``target`` attribute cannot be of class :class:`Tuple` or :class:`List`,"
" unlike the targets of :class:`Assign`."
msgstr ""
"Attributet ``target`` kan inte vara av klass :class:`Tuple` eller "
":class:`List`, till skillnad från målen i :class:`Assign`."

#: ../../library/ast.rst:858
msgid ""
"A ``raise`` statement. ``exc`` is the exception object to be raised, "
"normally a :class:`Call` or :class:`Name`, or ``None`` for a standalone "
"``raise``. ``cause`` is the optional part for ``y`` in ``raise x from y``."
msgstr ""
"Ett ``raise``\\ -uttryck. ``exc`` är det undantagsobjekt som ska genereras, "
"normalt ett :class:`Call` eller :class:`Name`, eller ``None`` för ett "
"fristående ``raise``. ``cause`` är den valfria delen för ``y`` i ``raise x "
"from y``."

#: ../../library/ast.rst:875
msgid ""
"An assertion. ``test`` holds the condition, such as a :class:`Compare` node."
" ``msg`` holds the failure message."
msgstr ""
"Ett påstående. ``test`` innehåller villkoret, t.ex. en "
":class:`Compare`\\-nod. ``msg`` innehåller felmeddelandet."

#: ../../library/ast.rst:891
msgid ""
"Represents a ``del`` statement. ``targets`` is a list of nodes, such as "
":class:`Name`, :class:`Attribute` or :class:`Subscript` nodes."
msgstr ""
"Representerar ett ``del``\\ -uttryck. ``targets`` är en lista med noder, "
"till exempel :class:`Name`, :class:`Attribute` eller :class:`Subscript` "
"-noder."

#: ../../library/ast.rst:909
msgid "A ``pass`` statement."
msgstr "Ett \"godkänt\" uttalande."

#: ../../library/ast.rst:920
msgid ""
"Other statements which are only applicable inside functions or loops are "
"described in other sections."
msgstr ""
"Andra uttalanden som endast är tillämpliga inom funktioner eller loopar "
"beskrivs i andra avsnitt."

#: ../../library/ast.rst:924
msgid "Imports"
msgstr "Importer"

#: ../../library/ast.rst:928
msgid "An import statement. ``names`` is a list of :class:`alias` nodes."
msgstr "En importförklaring. ``names`` är en lista med :class:`alias`\\-noder."

#: ../../library/ast.rst:945
msgid ""
"Represents ``from x import y``. ``module`` is a raw string of the 'from' "
"name, without any leading dots, or ``None`` for statements such as ``from . "
"import foo``. ``level`` is an integer holding the level of the relative "
"import (0 means absolute import)."
msgstr ""
"Representerar ``from x import y``. ``module`` är en rå sträng av "
"'from'-namnet, utan några inledande punkter, eller ``None`` för uttalanden "
"som ``from . import foo``. ``level`` är ett heltal som anger nivån på den "
"relativa importen (0 betyder absolut import)."

#: ../../library/ast.rst:967
msgid ""
"Both parameters are raw strings of the names. ``asname`` can be ``None`` if "
"the regular name is to be used."
msgstr ""
"Båda parametrarna är råa strängar av namnen. ``asname`` kan vara ``None`` om"
" det vanliga namnet ska användas."

#: ../../library/ast.rst:984
msgid "Control flow"
msgstr "Kontrollflöde"

#: ../../library/ast.rst:987
msgid ""
"Optional clauses such as ``else`` are stored as an empty list if they're not"
" present."
msgstr ""
"Valfria klausuler som ``else`` lagras som en tom lista om de inte finns med."

#: ../../library/ast.rst:992
msgid ""
"An ``if`` statement. ``test`` holds a single node, such as a "
":class:`Compare` node. ``body`` and ``orelse`` each hold a list of nodes."
msgstr ""
"En ``if``\\-sats. ``test`` innehåller en enda nod, t.ex. en "
":class:`Compare`\\-nod. ``body`` och ``orelse`` innehåller var och en en "
"lista med noder."

#: ../../library/ast.rst:995
msgid ""
"``elif`` clauses don't have a special representation in the AST, but rather "
"appear as extra :class:`If` nodes within the ``orelse`` section of the "
"previous one."
msgstr ""
"``elif`` -klausuler har ingen särskild representation i AST, utan visas "
"istället som extra :class:`If` -noder inom ``orelse`` -sektionen i den "
"föregående."

#: ../../library/ast.rst:1030
msgid ""
"A ``for`` loop. ``target`` holds the variable(s) the loop assigns to, as a "
"single :class:`Name`, :class:`Tuple` or :class:`List` node. ``iter`` holds "
"the item to be looped over, again as a single node. ``body`` and ``orelse`` "
"contain lists of nodes to execute. Those in ``orelse`` are executed if the "
"loop finishes normally, rather than via a ``break`` statement."
msgstr ""

#: ../../library/ast.rst:1064
msgid ""
"A ``while`` loop. ``test`` holds the condition, such as a :class:`Compare` "
"node."
msgstr ""
"En ``while`` -slinga. ``test`` innehåller villkoret, till exempel en "
":class:`Compare` -nod."

#: ../../library/ast.rst:1091
msgid "The ``break`` and ``continue`` statements."
msgstr "Uttalandena ``bryt`` och ``fortsätt``."

#: ../../library/ast.rst:1126
msgid ""
"``try`` blocks. All attributes are list of nodes to execute, except for "
"``handlers``, which is a list of :class:`ExceptHandler` nodes."
msgstr ""
"``försök`` block. Alla attribut är listor över noder som ska köras, utom "
"``handlers``, som är en lista över :class:`ExceptHandler`\\-noder."

#: ../../library/ast.rst:1172
msgid ""
"A single ``except`` clause. ``type`` is the exception type it will match, "
"typically a :class:`Name` node (or ``None`` for a catch-all ``except:`` "
"clause). ``name`` is a raw string for the name to hold the exception, or "
"``None`` if the clause doesn't have ``as foo``. ``body`` is a list of nodes."
msgstr ""
"En enda ``except`` klausul. ``type`` är undantagstypen som den kommer att "
"matcha, vanligtvis en :class:`Name` nod (eller ``None`` för en catch-all "
"``except:`` klausul). ``name`` är en rå sträng för namnet på undantaget, "
"eller ``None`` om klausulen inte har ``as foo``. ``body`` är en lista med "
"noder."

#: ../../library/ast.rst:1206
msgid ""
"A ``with`` block. ``items`` is a list of :class:`withitem` nodes "
"representing the context managers, and ``body`` is the indented block inside"
" the context."
msgstr ""
"Ett ``with`` -block. ``items`` är en lista med :class:`withitem` -noder som "
"representerar kontext hanterarna, och ``body`` är det indragna blocket inuti"
" kontexten."

#: ../../library/ast.rst:1216
msgid ""
"A single context manager in a ``with`` block. ``context_expr`` is the "
"context manager, often a :class:`Call` node. ``optional_vars`` is a "
":class:`Name`, :class:`Tuple` or :class:`List` for the ``as foo`` part, or "
"``None`` if that isn't used."
msgstr ""
"En enda kontextmanager i ett ``with`` -block. ``context_expr`` är "
"kontextmanagern, ofta en :class:`Call` -nod. ``optional_vars`` är en "
":class:`Name`, :class:`Tuple` eller :class:`List` för delen ``as foo``, "
"eller ``None`` om den inte används."

#: ../../library/ast.rst:1249
msgid "Pattern matching"
msgstr "Mönstermatchning"

#: ../../library/ast.rst:1254
msgid ""
"A ``match`` statement. ``subject`` holds the subject of the match (the "
"object that is being matched against the cases) and ``cases`` contains an "
"iterable of :class:`match_case` nodes with the different cases."
msgstr ""
"Ett ``match``\\ -uttryck. ``subject`` innehåller ämnet för matchningen "
"(objektet som matchas mot fallen) och ``cases`` innehåller en iterabel av "
":class:`match_case` -noder med olika fall."

#: ../../library/ast.rst:1260
msgid ""
"A single case pattern in a ``match`` statement. ``pattern`` contains the "
"match pattern that the subject will be matched against. Note that the "
":class:`AST` nodes produced for patterns differ from those produced for "
"expressions, even when they share the same syntax."
msgstr ""
"Ett enda fallmönster i ett ``match``\\ -uttryck. ``pattern`` innehåller det "
"mönster som objektet ska matchas mot. Observera att :class:`AST` -noder som "
"skapas för mönster skiljer sig från de som skapas för uttryck, även om de "
"har samma syntax."

#: ../../library/ast.rst:1265
msgid ""
"The ``guard`` attribute contains an expression that will be evaluated if the"
" pattern matches the subject."
msgstr ""
"Attributet ``guard`` innehåller ett uttryck som kommer att utvärderas om "
"mönstret matchar ämnet."

#: ../../library/ast.rst:1268
msgid ""
"``body`` contains a list of nodes to execute if the pattern matches and the "
"result of evaluating the guard expression is true."
msgstr ""
"``body`` innehåller en lista med noder som ska köras om mönstret matchar och"
" resultatet av utvärderingen av guard-uttrycket är sant."

#: ../../library/ast.rst:1311
msgid ""
"A match literal or value pattern that compares by equality. ``value`` is an "
"expression node. Permitted value nodes are restricted as described in the "
"match statement documentation. This pattern succeeds if the match subject is"
" equal to the evaluated value."
msgstr ""
"Ett matchande bokstavs- eller värdemönster som jämförs genom likhet. "
"``value`` är en uttrycksnod. Tillåtna värdenoder är begränsade enligt "
"beskrivningen i dokumentationen för match-satsen. Det här mönstret lyckas om"
" matchningsobjektet är lika med det utvärderade värdet."

#: ../../library/ast.rst:1338
msgid ""
"A match literal pattern that compares by identity. ``value`` is the "
"singleton to be compared against: ``None``, ``True``, or ``False``. This "
"pattern succeeds if the match subject is the given constant."
msgstr ""
"Ett litterärt matchningsmönster som jämför med identitet. ``value`` är den "
"singleton som ska jämföras mot: ``None``, ``True``, eller ``False``. Detta "
"mönster lyckas om matchningsobjektet är den givna konstanten."

#: ../../library/ast.rst:1363
msgid ""
"A match sequence pattern. ``patterns`` contains the patterns to be matched "
"against the subject elements if the subject is a sequence. Matches a "
"variable length sequence if one of the subpatterns is a ``MatchStar`` node, "
"otherwise matches a fixed length sequence."
msgstr ""
"Ett matchningsmönster för en sekvens. ``patterns`` innehåller de mönster som"
" ska matchas mot ämneselementen om ämnet är en sekvens. Matchar en sekvens "
"med variabel längd om ett av undermönstren är en ``MatchStar``\\-nod, annars"
" matchas en sekvens med fast längd."

#: ../../library/ast.rst:1394
msgid ""
"Matches the rest of the sequence in a variable length match sequence "
"pattern. If ``name`` is not ``None``, a list containing the remaining "
"sequence elements is bound to that name if the overall sequence pattern is "
"successful."
msgstr ""
"Matchar resten av sekvensen i ett matchsekvensmönster med variabel längd. Om"
" ``name`` inte är ``None``, binds en lista som innehåller de återstående "
"sekvenselementen till det namnet om det övergripande sekvensmönstret är "
"framgångsrikt."

#: ../../library/ast.rst:1434
msgid ""
"A match mapping pattern. ``keys`` is a sequence of expression nodes. "
"``patterns`` is a corresponding sequence of pattern nodes. ``rest`` is an "
"optional name that can be specified to capture the remaining mapping "
"elements. Permitted key expressions are restricted as described in the match"
" statement documentation."
msgstr ""
"Ett matchande mappningsmönster. ``keys`` är en sekvens av uttrycksnoder. "
"``patterns`` är en motsvarande sekvens av mönsternoder. ``rest`` är ett "
"valfritt namn som kan anges för att fånga de återstående mappningselementen."
" Tillåtna nyckeluttryck begränsas på det sätt som beskrivs i dokumentationen"
" för match statement."

#: ../../library/ast.rst:1440
msgid ""
"This pattern succeeds if the subject is a mapping, all evaluated key "
"expressions are present in the mapping, and the value corresponding to each "
"key matches the corresponding subpattern. If ``rest`` is not ``None``, a "
"dict containing the remaining mapping elements is bound to that name if the "
"overall mapping pattern is successful."
msgstr ""
"Detta mönster lyckas om ämnet är en mappning, alla utvärderade nyckeluttryck"
" finns i mappningen och värdet som motsvarar varje nyckel matchar "
"motsvarande undermönster. Om ``rest`` inte är ``None``, binds en dict som "
"innehåller de återstående mappningselementen till namnet om det övergripande"
" mappningsmönstret är framgångsrikt."

#: ../../library/ast.rst:1480
msgid ""
"A match class pattern. ``cls`` is an expression giving the nominal class to "
"be matched. ``patterns`` is a sequence of pattern nodes to be matched "
"against the class defined sequence of pattern matching attributes. "
"``kwd_attrs`` is a sequence of additional attributes to be matched "
"(specified as keyword arguments in the class pattern), ``kwd_patterns`` are "
"the corresponding patterns (specified as keyword values in the class "
"pattern)."
msgstr ""
"Ett matchningsmönster för klass. ``cls`` är ett uttryck som anger den "
"nominella klass som skall matchas. ``patterns`` är en sekvens av "
"mönsternoder som skall matchas mot den klassdefinierade sekvensen av "
"attribut för mönstermatchning. ``kwd_attrs`` är en sekvens av ytterligare "
"attribut som skall matchas (specificerade som nyckelordsargument i "
"klassmönstret), ``kwd_patterns`` är motsvarande mönster (specificerade som "
"nyckelordsvärden i klassmönstret)."

#: ../../library/ast.rst:1487
msgid ""
"This pattern succeeds if the subject is an instance of the nominated class, "
"all positional patterns match the corresponding class-defined attributes, "
"and any specified keyword attributes match their corresponding pattern."
msgstr ""
"Detta mönster lyckas om ämnet är en instans av den nominerade klassen, alla "
"positionsmönster matchar motsvarande klassdefinierade attribut och alla "
"angivna nyckelordsattribut matchar motsvarande mönster."

#: ../../library/ast.rst:1491
msgid ""
"Note: classes may define a property that returns self in order to match a "
"pattern node against the instance being matched. Several builtin types are "
"also matched that way, as described in the match statement documentation."
msgstr ""
"Observera: Klasser kan definiera en egenskap som returnerar self för att "
"matcha en mönsternod mot den instans som ska matchas. Flera inbyggda typer "
"matchas också på detta sätt, vilket beskrivs i dokumentationen för match "
"statement."

#: ../../library/ast.rst:1544
msgid ""
"A match \"as-pattern\", capture pattern or wildcard pattern. ``pattern`` "
"contains the match pattern that the subject will be matched against. If the "
"pattern is ``None``, the node represents a capture pattern (i.e a bare name)"
" and will always succeed."
msgstr ""
"En matchning \"som mönster\", fångstmönster eller jokerteckenmönster. "
"``pattern`` innehåller det matchningsmönster som ämnet kommer att matchas "
"mot. Om mönstret är ``None`` representerar noden ett fångstmönster (dvs. ett"
" tomt namn) och kommer alltid att lyckas."

#: ../../library/ast.rst:1549
msgid ""
"The ``name`` attribute contains the name that will be bound if the pattern "
"is successful. If ``name`` is ``None``, ``pattern`` must also be ``None`` "
"and the node represents the wildcard pattern."
msgstr ""
"Attributet ``name`` innehåller det namn som kommer att bindas om mönstret är"
" framgångsrikt. Om ``name`` är ``None`` måste ``pattern`` också vara "
"``None`` och noden representerar wildcard-mönstret."

#: ../../library/ast.rst:1585
msgid ""
"A match \"or-pattern\". An or-pattern matches each of its subpatterns in "
"turn to the subject, until one succeeds. The or-pattern is then deemed to "
"succeed. If none of the subpatterns succeed the or-pattern fails. The "
"``patterns`` attribute contains a list of match pattern nodes that will be "
"matched against the subject."
msgstr ""
"En matchning \"eller-mönster\". Ett eller-mönster matchar vart och ett av "
"sina undermönster i tur och ordning till ämnet, tills ett lyckas. Då anses "
"or-mönstret vara framgångsrikt. Om inget av undermönstren lyckas misslyckas "
"or-mönstret. Attributet ``patterns`` innehåller en lista över "
"matchningsmönsternoder som kommer att matchas mot subjektet."

#: ../../library/ast.rst:1617
msgid "Function and class definitions"
msgstr "Funktions- och klassdefinitioner"

#: ../../library/ast.rst:1621
msgid "A function definition."
msgstr "En funktionsdefinition."

#: ../../library/ast.rst:1623
msgid "``name`` is a raw string of the function name."
msgstr "``name`` är en rå sträng med funktionens namn."

#: ../../library/ast.rst:1624
msgid "``args`` is an :class:`arguments` node."
msgstr "``args`` är en nod i :class:`arguments`."

#: ../../library/ast.rst:1625
msgid "``body`` is the list of nodes inside the function."
msgstr "``body`` är listan över noder i funktionen."

#: ../../library/ast.rst:1626
msgid ""
"``decorator_list`` is the list of decorators to be applied, stored outermost"
" first (i.e. the first in the list will be applied last)."
msgstr ""
"``decorator_list`` är listan över dekoratorer som ska tillämpas, lagrade "
"längst ut först (dvs. den första i listan kommer att tillämpas sist)."

#: ../../library/ast.rst:1628
msgid "``returns`` is the return annotation."
msgstr "``returns`` är returannoteringen."

#: ../../library/ast.rst:1637
msgid ""
"``lambda`` is a minimal function definition that can be used inside an "
"expression. Unlike :class:`FunctionDef`, ``body`` holds a single node."
msgstr ""
"``lambda`` är en minimal funktionsdefinition som kan användas inuti ett "
"uttryck. Till skillnad från :class:`FunctionDef` innehåller ``body`` en enda"
" nod."

#: ../../library/ast.rst:1661
msgid "The arguments for a function."
msgstr "Argumenten för en funktion."

#: ../../library/ast.rst:1663
msgid ""
"``posonlyargs``, ``args`` and ``kwonlyargs`` are lists of :class:`arg` "
"nodes."
msgstr ""
"``posonlyargs``, ``args`` och ``kwonlyargs`` är listor av "
":class:`arg`\\-noder."

#: ../../library/ast.rst:1664
msgid ""
"``vararg`` and ``kwarg`` are single :class:`arg` nodes, referring to the "
"``*args, **kwargs`` parameters."
msgstr ""
"``vararg`` och ``kwarg`` är enskilda :class:`arg`\\-noder som refererar till"
" parametrarna ``*args, **kwargs``."

#: ../../library/ast.rst:1666
msgid ""
"``kw_defaults`` is a list of default values for keyword-only arguments. If "
"one is ``None``, the corresponding argument is required."
msgstr ""
"``kw_defaults`` är en lista med standardvärden för argument som endast "
"innehåller nyckelord. Om ett är ``None`` krävs motsvarande argument."

#: ../../library/ast.rst:1668
msgid ""
"``defaults`` is a list of default values for arguments that can be passed "
"positionally. If there are fewer defaults, they correspond to the last n "
"arguments."
msgstr ""
"``defaults`` är en lista med standardvärden för argument som kan skickas "
"positionellt. Om det finns färre standardvärden motsvarar de de sista n "
"argumenten."

#: ../../library/ast.rst:1675
msgid ""
"A single argument in a list. ``arg`` is a raw string of the argument name, "
"``annotation`` is its annotation, such as a :class:`Str` or :class:`Name` "
"node."
msgstr ""

#: ../../library/ast.rst:1681
msgid ""
"``type_comment`` is an optional string with the type annotation as a comment"
msgstr ""
"``type_comment`` är en valfri sträng med typannoteringen som en kommentar"

#: ../../library/ast.rst:1725
msgid "A ``return`` statement."
msgstr "Ett ``retur`` uttalande."

#: ../../library/ast.rst:1740
msgid ""
"A ``yield`` or ``yield from`` expression. Because these are expressions, "
"they must be wrapped in a :class:`Expr` node if the value sent back is not "
"used."
msgstr ""

#: ../../library/ast.rst:1765
msgid ""
"``global`` and ``nonlocal`` statements. ``names`` is a list of raw strings."
msgstr ""
"``global`` och ``nonlocal`` satser. ``names`` är en lista med råa strängar."

#: ../../library/ast.rst:1792
msgid "A class definition."
msgstr "En klassdefinition."

#: ../../library/ast.rst:1794
msgid "``name`` is a raw string for the class name"
msgstr "``name`` är en rå sträng för klassnamnet"

#: ../../library/ast.rst:1795
msgid "``bases`` is a list of nodes for explicitly specified base classes."
msgstr "``bases`` är en lista med noder för explicit angivna basklasser."

#: ../../library/ast.rst:1796
msgid ""
"``keywords`` is a list of :class:`keyword` nodes, principally for "
"'metaclass'. Other keywords will be passed to the metaclass, as per "
"`PEP-3115 <https://www.python.org/dev/peps/pep-3115/>`_."
msgstr ""

#: ../../library/ast.rst:1799
msgid ""
"``starargs`` and ``kwargs`` are each a single node, as in a function call. "
"starargs will be expanded to join the list of base classes, and kwargs will "
"be passed to the metaclass."
msgstr ""

#: ../../library/ast.rst:1802
msgid ""
"``body`` is a list of nodes representing the code within the class "
"definition."
msgstr ""
"``body`` är en lista med noder som representerar koden i klassdefinitionen."

#: ../../library/ast.rst:1804
msgid "``decorator_list`` is a list of nodes, as in :class:`FunctionDef`."
msgstr "``decorator_list`` är en lista med noder, som i :class:`FunctionDef`."

#: ../../library/ast.rst:1833
msgid "Async and await"
msgstr "Asynkron och await"

#: ../../library/ast.rst:1837
msgid ""
"An ``async def`` function definition. Has the same fields as "
":class:`FunctionDef`."
msgstr ""
"En ``async def`` funktionsdefinition. Har samma fält som "
":class:`FunctionDef`."

#: ../../library/ast.rst:1843
msgid ""
"An ``await`` expression. ``value`` is what it waits for. Only valid in the "
"body of an :class:`AsyncFunctionDef`."
msgstr ""
"Ett ``await``\\ -uttryck. ``value`` är det som väntas på. Endast giltigt i "
"kroppen av en :class:`AsyncFunctionDef`."

#: ../../library/ast.rst:1876
msgid ""
"``async for`` loops and ``async with`` context managers. They have the same "
"fields as :class:`For` and :class:`With`, respectively. Only valid in the "
"body of an :class:`AsyncFunctionDef`."
msgstr ""
"``async for`` -slingor och ``async with``\\ -kontexthanterare. De har samma "
"fält som :class:`For` respektive :class:`With`. Endast giltigt i kroppen av "
"en :class:`AsyncFunctionDef`."

#: ../../library/ast.rst:1881
msgid ""
"When a string is parsed by :func:`ast.parse`, operator nodes (subclasses of "
":class:`ast.operator`, :class:`ast.unaryop`, :class:`ast.cmpop`, "
":class:`ast.boolop` and :class:`ast.expr_context`) on the returned tree will"
" be singletons. Changes to one will be reflected in all other occurrences of"
" the same value (e.g. :class:`ast.Add`)."
msgstr ""

#: ../../library/ast.rst:1889
msgid ":mod:`ast` Helpers"
msgstr ""

#: ../../library/ast.rst:1891
msgid ""
"Apart from the node classes, the :mod:`ast` module defines these utility "
"functions and classes for traversing abstract syntax trees:"
msgstr ""
"Förutom nodklasserna definierar modulen :mod:`ast` dessa verktygsfunktioner "
"och klasser för genomgång av abstrakta syntaxträd:"

#: ../../library/ast.rst:1896
msgid ""
"Parse the source into an AST node.  Equivalent to ``compile(source, "
"filename, mode, ast.PyCF_ONLY_AST)``."
msgstr ""

#: ../../library/ast.rst:1899
msgid ""
"If ``type_comments=True`` is given, the parser is modified to check and "
"return type comments as specified by :pep:`484` and :pep:`526`. This is "
"equivalent to adding :data:`ast.PyCF_TYPE_COMMENTS` to the flags passed to "
":func:`compile()`.  This will report syntax errors for misplaced type "
"comments.  Without this flag, type comments will be ignored, and the "
"``type_comment`` field on selected AST nodes will always be ``None``.  In "
"addition, the locations of ``# type: ignore`` comments will be returned as "
"the ``type_ignores`` attribute of :class:`Module` (otherwise it is always an"
" empty list)."
msgstr ""

#: ../../library/ast.rst:1909
msgid ""
"In addition, if ``mode`` is ``'func_type'``, the input syntax is modified to"
" correspond to :pep:`484` \"signature type comments\", e.g. ``(str, int) -> "
"List[str]``."
msgstr ""
"Dessutom, om ``mode`` är ``'func_type'``, ändras inmatningssyntaxen för att "
"motsvara :pep:`484` \"signaturtypskommentarer\", t.ex. ``(str, int) -> "
"List[str]``."

#: ../../library/ast.rst:1913
msgid ""
"Also, setting ``feature_version`` to a tuple ``(major, minor)`` will attempt"
" to parse using that Python version's grammar. Currently ``major`` must "
"equal to ``3``.  For example, setting ``feature_version=(3, 4)`` will allow "
"the use of ``async`` and ``await`` as variable names.  The lowest supported "
"version is ``(3, 4)``; the highest is ``sys.version_info[0:2]``."
msgstr ""

#: ../../library/ast.rst:1920
msgid ""
"If source contains a null character ('\\0'), :exc:`ValueError` is raised."
msgstr ""

#: ../../library/ast.rst:1923
msgid ""
"Note that successfully parsing source code into an AST object doesn't "
"guarantee that the source code provided is valid Python code that can be "
"executed as the compilation step can raise further :exc:`SyntaxError` "
"exceptions. For instance, the source ``return 42`` generates a valid AST "
"node for a return statement, but it cannot be compiled alone (it needs to be"
" inside a function node)."
msgstr ""
"Observera att en lyckad parsning av källkod till ett AST-objekt inte "
"garanterar att den källkod som tillhandahålls är giltig Python-kod som kan "
"exekveras eftersom kompileringssteget kan ge upphov till ytterligare "
":exc:`SyntaxError`\\-undantag. Till exempel genererar källan ``return 42`` "
"en giltig AST-nod för en return-sats, men den kan inte kompileras ensam (den"
" måste vara inuti en funktionsnod)."

#: ../../library/ast.rst:1930
msgid ""
"In particular, :func:`ast.parse` won't do any scoping checks, which the "
"compilation step does."
msgstr ""
"I synnerhet kommer :func:`ast.parse` inte att göra några scoping-kontroller,"
" vilket kompileringssteget gör."

#: ../../library/ast.rst:1934
msgid ""
"It is possible to crash the Python interpreter with a sufficiently "
"large/complex string due to stack depth limitations in Python's AST "
"compiler."
msgstr ""
"Det är möjligt att krascha Python-tolken med en tillräckligt stor/komplex "
"sträng på grund av begränsningar i stackdjupet i Pythons AST-kompilator."

#: ../../library/ast.rst:1938
msgid "Added ``type_comments``, ``mode='func_type'`` and ``feature_version``."
msgstr ""
"Lagt till ``type_comments``, ``mode='func_type'`` och ``feature_version``."

#: ../../library/ast.rst:1944
msgid ""
"Unparse an :class:`ast.AST` object and generate a string with code that "
"would produce an equivalent :class:`ast.AST` object if parsed back with "
":func:`ast.parse`."
msgstr ""
"Unparse ett :class:`ast.AST`\\-objekt och generera en sträng med kod som "
"skulle producera ett motsvarande :class:`ast.AST`\\-objekt om det "
"analyserades tillbaka med :func:`ast.parse`."

#: ../../library/ast.rst:1949
msgid ""
"The produced code string will not necessarily be equal to the original code "
"that generated the :class:`ast.AST` object (without any compiler "
"optimizations, such as constant tuples/frozensets)."
msgstr ""
"Den kodsträng som produceras kommer inte nödvändigtvis att vara lika med den"
" ursprungliga koden som genererade :class:`ast.AST`\\-objektet (utan några "
"kompilatoroptimeringar, t.ex. konstanta tuples/frozensets)."

#: ../../library/ast.rst:1954
msgid ""
"Trying to unparse a highly complex expression would result with "
":exc:`RecursionError`."
msgstr ""
"Försök att unparsa ett mycket komplext uttryck skulle resultera i "
":exc:`RecursionError`."

#: ../../library/ast.rst:1962
msgid ""
"Evaluate an expression node or a string containing only a Python literal or "
"container display.  The string or node provided may only consist of the "
"following Python literal structures: strings, bytes, numbers, tuples, lists,"
" dicts, sets, booleans, ``None`` and ``Ellipsis``."
msgstr ""
"Utvärderar en uttrycksnod eller en sträng som endast innehåller en Python-"
"litteral eller containervisning.  Den angivna strängen eller noden får "
"endast bestå av följande Python-litteralstrukturer: strängar, bytes, tal, "
"tupler, listor, dicts, set, booleaner, ``None`` och ``Ellipsis``."

#: ../../library/ast.rst:1967
msgid ""
"This can be used for evaluating strings containing Python values without the"
" need to parse the values oneself.  It is not capable of evaluating "
"arbitrarily complex expressions, for example involving operators or "
"indexing."
msgstr ""
"Detta kan användas för att utvärdera strängar som innehåller Python-värden "
"utan att man behöver analysera värdena själv.  Den kan inte utvärdera "
"godtyckligt komplexa uttryck, t.ex. med operatorer eller indexering."

#: ../../library/ast.rst:1972
msgid ""
"This function had been documented as \"safe\" in the past without defining "
"what that meant. That was misleading. This is specifically designed not to "
"execute Python code, unlike the more general :func:`eval`. There is no "
"namespace, no name lookups, or ability to call out. But it is not free from "
"attack: A relatively small input can lead to memory exhaustion or to C stack"
" exhaustion, crashing the process. There is also the possibility for "
"excessive CPU consumption denial of service on some inputs. Calling it on "
"untrusted data is thus not recommended."
msgstr ""
"Denna funktion har tidigare dokumenterats som \"säker\" utan att det har "
"definierats vad det innebär. Det var missvisande. Detta är specifikt "
"utformat för att inte exekvera Python-kod, till skillnad från den mer "
"allmänna :func:`eval`. Det finns ingen namnrymd, inga namnuppslagningar "
"eller möjlighet att ringa ut. Men det är inte fritt från angrepp: En "
"relativt liten inmatning kan leda till att minnet eller C-stacken tar slut "
"och att processen kraschar. Det finns också möjlighet till överdriven CPU-"
"konsumtion, denial of service, för vissa indata. Att anropa den på icke "
"betrodda data rekommenderas därför inte."

#: ../../library/ast.rst:1982
msgid ""
"It is possible to crash the Python interpreter due to stack depth "
"limitations in Python's AST compiler."
msgstr ""
"Det är möjligt att krascha Python-tolken på grund av begränsningar i "
"stackdjupet i Pythons AST-kompilator."

#: ../../library/ast.rst:1985
msgid ""
"It can raise :exc:`ValueError`, :exc:`TypeError`, :exc:`SyntaxError`, "
":exc:`MemoryError` and :exc:`RecursionError` depending on the malformed "
"input."
msgstr ""
"Det kan ge upphov till :exc:`ValueError`, :exc:`TypeError`, "
":exc:`SyntaxError`, :exc:`MemoryError` och :exc:`RecursionError` beroende på"
" den felaktiga indata."

#: ../../library/ast.rst:1989
msgid "Now allows bytes and set literals."
msgstr "Tillåter nu bytes och set-litteraler."

#: ../../library/ast.rst:1992
msgid "Now supports creating empty sets with ``'set()'``."
msgstr "Stöder nu skapandet av tomma uppsättningar med ``'set()'``."

#: ../../library/ast.rst:1995
msgid "For string inputs, leading spaces and tabs are now stripped."
msgstr "För stränginmatningar tas nu inledande mellanslag och tabbar bort."

#: ../../library/ast.rst:2001
msgid ""
"Return the docstring of the given *node* (which must be a "
":class:`FunctionDef`, :class:`AsyncFunctionDef`, :class:`ClassDef`, or "
":class:`Module` node), or ``None`` if it has no docstring. If *clean* is "
"true, clean up the docstring's indentation with :func:`inspect.cleandoc`."
msgstr ""
"Returnerar dokumentsträngen för den givna *noden* (som måste vara en "
":class:`FunctionDef`, :class:`AsyncFunctionDef`, :class:`ClassDef`, eller "
":class:`Module` nod), eller ``None`` om den inte har någon dokumentsträng. "
"Om *clean* är true, rensa upp dokumentsträngens indrag med "
":func:`inspect.cleandoc`."

#: ../../library/ast.rst:2007
msgid ":class:`AsyncFunctionDef` is now supported."
msgstr ":class:`AsyncFunctionDef` stöds nu."

#: ../../library/ast.rst:2013
msgid ""
"Get source code segment of the *source* that generated *node*. If some "
"location information (:attr:`lineno`, :attr:`end_lineno`, "
":attr:`col_offset`, or :attr:`end_col_offset`) is missing, return ``None``."
msgstr ""

#: ../../library/ast.rst:2017
msgid ""
"If *padded* is ``True``, the first line of a multi-line statement will be "
"padded with spaces to match its original position."
msgstr ""
"Om *padded* är ``True``, kommer den första raden i ett flerradigt uttalande "
"att fyllas med mellanslag för att matcha dess ursprungliga position."

#: ../../library/ast.rst:2025
msgid ""
"When you compile a node tree with :func:`compile`, the compiler expects "
":attr:`lineno` and :attr:`col_offset` attributes for every node that "
"supports them.  This is rather tedious to fill in for generated nodes, so "
"this helper adds these attributes recursively where not already set, by "
"setting them to the values of the parent node.  It works recursively "
"starting at *node*."
msgstr ""

#: ../../library/ast.rst:2034
msgid ""
"Increment the line number and end line number of each node in the tree "
"starting at *node* by *n*. This is useful to \"move code\" to a different "
"location in a file."
msgstr ""
"Öka radnumret och slutradnumret för varje nod i trädet som börjar vid *nod* "
"med *n*. Detta är användbart för att \"flytta kod\" till en annan plats i en"
" fil."

#: ../../library/ast.rst:2041
msgid ""
"Copy source location (:attr:`lineno`, :attr:`col_offset`, "
":attr:`end_lineno`, and :attr:`end_col_offset`) from *old_node* to "
"*new_node* if possible, and return *new_node*."
msgstr ""

#: ../../library/ast.rst:2048
msgid ""
"Yield a tuple of ``(fieldname, value)`` for each field in ``node._fields`` "
"that is present on *node*."
msgstr ""
"Ger en tupel av ``(fältnamn, värde)`` för varje fält i ``node._fields`` som "
"finns på *node*."

#: ../../library/ast.rst:2054
msgid ""
"Yield all direct child nodes of *node*, that is, all fields that are nodes "
"and all items of fields that are lists of nodes."
msgstr ""
"Ger alla direkta underordnade noder till *node*, dvs. alla fält som är noder"
" och alla fältobjekt som är listor över noder."

#: ../../library/ast.rst:2060
msgid ""
"Recursively yield all descendant nodes in the tree starting at *node* "
"(including *node* itself), in no specified order.  This is useful if you "
"only want to modify nodes in place and don't care about the context."
msgstr ""
"Ger rekursivt alla nedstigande noder i trädet som börjar på *node* "
"(inklusive *node* själv), utan specificerad ordning.  Detta är användbart om"
" du bara vill modifiera noder på plats och inte bryr dig om sammanhanget."

#: ../../library/ast.rst:2067
msgid ""
"A node visitor base class that walks the abstract syntax tree and calls a "
"visitor function for every node found.  This function may return a value "
"which is forwarded by the :meth:`visit` method."
msgstr ""
"En basklass för nodbesökare som går igenom det abstrakta syntaxträdet och "
"anropar en besökarfunktion för varje nod som hittas.  Denna funktion kan "
"returnera ett värde som vidarebefordras av :meth:`visit`\\-metoden."

#: ../../library/ast.rst:2071
msgid ""
"This class is meant to be subclassed, with the subclass adding visitor "
"methods."
msgstr ""
"Denna klass är avsedd att underklassificeras, varvid underklassen lägger "
"till besöksmetoder."

#: ../../library/ast.rst:2076
msgid ""
"Visit a node.  The default implementation calls the method called "
":samp:`self.visit_{classname}` where *classname* is the name of the node "
"class, or :meth:`generic_visit` if that method doesn't exist."
msgstr ""
"Besöker en nod.  Standardimplementeringen anropar metoden som heter "
":samp:`self.visit_{classname}` där *klassnamn* är namnet på nodklassen, "
"eller :meth:`generic_visit` om den metoden inte finns."

#: ../../library/ast.rst:2082
msgid "This visitor calls :meth:`visit` on all children of the node."
msgstr "Den här besökaren anropar :meth:`visit` på alla barn till noden."

#: ../../library/ast.rst:2084
msgid ""
"Note that child nodes of nodes that have a custom visitor method won't be "
"visited unless the visitor calls :meth:`generic_visit` or visits them "
"itself."
msgstr ""
"Observera att barnnoder till noder som har en anpassad besöksmetod inte "
"kommer att besökas om inte besökaren anropar :meth:`generic_visit` eller "
"besöker dem själv."

#: ../../library/ast.rst:2088
msgid ""
"Don't use the :class:`NodeVisitor` if you want to apply changes to nodes "
"during traversal.  For this a special visitor exists "
"(:class:`NodeTransformer`) that allows modifications."
msgstr ""
"Använd inte :class:`NodeVisitor` om du vill göra ändringar i noder under "
"traversal.  För detta finns en speciell besökare (:class:`NodeTransformer`) "
"som tillåter ändringar."

#: ../../library/ast.rst:2094
msgid ""
"Methods :meth:`visit_Num`, :meth:`visit_Str`, :meth:`visit_Bytes`, "
":meth:`visit_NameConstant` and :meth:`visit_Ellipsis` are deprecated now and"
" will not be called in future Python versions.  Add the "
":meth:`visit_Constant` method to handle all constant nodes."
msgstr ""

#: ../../library/ast.rst:2102
msgid ""
"A :class:`NodeVisitor` subclass that walks the abstract syntax tree and "
"allows modification of nodes."
msgstr ""
"En :class:`NodeVisitor`\\-underklass som går igenom det abstrakta "
"syntaxträdet och tillåter modifiering av noder."

#: ../../library/ast.rst:2105
msgid ""
"The :class:`NodeTransformer` will walk the AST and use the return value of "
"the visitor methods to replace or remove the old node.  If the return value "
"of the visitor method is ``None``, the node will be removed from its "
"location, otherwise it is replaced with the return value.  The return value "
"may be the original node in which case no replacement takes place."
msgstr ""
":class:`NodeTransformer` kommer att gå igenom AST och använda returvärdet "
"från besöksmetoderna för att ersätta eller ta bort den gamla noden.  Om "
"besöksmetodens returvärde är ``None`` kommer noden att tas bort från sin "
"plats, annars ersätts den med returvärdet.  Returvärdet kan vara den "
"ursprungliga noden och i så fall sker ingen ersättning."

#: ../../library/ast.rst:2111
msgid ""
"Here is an example transformer that rewrites all occurrences of name lookups"
" (``foo``) to ``data['foo']``::"
msgstr ""
"Här är ett exempel på en transformator som skriver om alla förekomster av "
"namnuppslagningar (``foo``) till ``data['foo']``::"

#: ../../library/ast.rst:2123
msgid ""
"Keep in mind that if the node you're operating on has child nodes you must "
"either transform the child nodes yourself or call the :meth:`generic_visit` "
"method for the node first."
msgstr ""

#: ../../library/ast.rst:2127
msgid ""
"For nodes that were part of a collection of statements (that applies to all "
"statement nodes), the visitor may also return a list of nodes rather than "
"just a single node."
msgstr ""
"För noder som ingick i en samling uttalanden (det gäller alla "
"uttalandenoder) kan besökaren också returnera en lista med noder i stället "
"för bara en enda nod."

#: ../../library/ast.rst:2131
msgid ""
"If :class:`NodeTransformer` introduces new nodes (that weren't part of "
"original tree) without giving them location information (such as "
":attr:`lineno`), :func:`fix_missing_locations` should be called with the new"
" sub-tree to recalculate the location information::"
msgstr ""

#: ../../library/ast.rst:2139
msgid "Usually you use the transformer like this::"
msgstr "Vanligtvis använder du transformatorn på följande sätt::"

#: ../../library/ast.rst:2146
msgid ""
"Return a formatted dump of the tree in *node*.  This is mainly useful for "
"debugging purposes.  If *annotate_fields* is true (by default), the returned"
" string will show the names and the values for fields. If *annotate_fields* "
"is false, the result string will be more compact by omitting unambiguous "
"field names.  Attributes such as line numbers and column offsets are not "
"dumped by default.  If this is wanted, *include_attributes* can be set to "
"true."
msgstr ""
"Returnerar en formaterad dumpning av trädet i *node*.  Detta är främst "
"användbart för felsökning.  Om *annotate_fields* är true (standard) kommer "
"den returnerade strängen att visa namn och värden för fälten. Om "
"*annotate_fields* är false blir resultatsträngen mer kompakt genom att "
"otvetydiga fältnamn utelämnas.  Attribut som radnummer och kolumnoffset "
"dumpas inte som standard.  Om detta önskas kan *include_attributes* sättas "
"till true."

#: ../../library/ast.rst:2154
msgid ""
"If *indent* is a non-negative integer or string, then the tree will be "
"pretty-printed with that indent level.  An indent level of 0, negative, or "
"``\"\"`` will only insert newlines.  ``None`` (the default) selects the "
"single line representation. Using a positive integer indent indents that "
"many spaces per level.  If *indent* is a string (such as ``\"\\t\"``), that "
"string is used to indent each level."
msgstr ""
"Om *indent* är ett icke-negativt heltal eller en sträng, kommer trädet att "
"skrivas ut med den indragsnivån.  En indragsnivå på 0, negativ eller "
"``\"\"`` kommer endast att infoga nya rader.  ``None`` (standard) väljer "
"representation med en rad. Om du använder ett positivt heltal indenteras så "
"många mellanslag per nivå.  Om *indent* är en sträng (t.ex. ``\"\\t\"``) "
"används den strängen för att dra in varje nivå."

#: ../../library/ast.rst:2161
msgid "Added the *indent* option."
msgstr "Lagt till alternativet *indent*."

#: ../../library/ast.rst:2168
msgid "Compiler Flags"
msgstr ""

#: ../../library/ast.rst:2170
msgid ""
"The following flags may be passed to :func:`compile` in order to change "
"effects on the compilation of a program:"
msgstr ""
"Följande flaggor kan skickas till :func:`compile` för att ändra effekterna "
"på kompileringen av ett program:"

#: ../../library/ast.rst:2175
msgid ""
"Enables support for top-level ``await``, ``async for``, ``async with`` and "
"async comprehensions."
msgstr ""
"Aktiverar stöd för toppnivå ``await``, ``async for``, ``async with`` och "
"async-förståelser."

#: ../../library/ast.rst:2182
msgid ""
"Generates and returns an abstract syntax tree instead of returning a "
"compiled code object."
msgstr ""
"Genererar och returnerar ett abstrakt syntaxträd i stället för att returnera"
" ett kompilerat kodobjekt."

#: ../../library/ast.rst:2187
msgid ""
"Enables support for :pep:`484` and :pep:`526` style type comments (``# type:"
" <type>``, ``# type: ignore <stuff>``)."
msgstr ""
"Aktiverar stöd för typkommentarer i stil med :pep:`484` och :pep:`526` (``# "
"type: <type>``, ``# type: ignore <stuff>``)."

#: ../../library/ast.rst:2196
msgid "Command-Line Usage"
msgstr "Användning av kommandoraden"

#: ../../library/ast.rst:2200
msgid ""
"The :mod:`ast` module can be executed as a script from the command line. It "
"is as simple as:"
msgstr ""
"Modulen :mod:`ast` kan köras som ett skript från kommandoraden. Det är så "
"enkelt som att:"

#: ../../library/ast.rst:2207
msgid "The following options are accepted:"
msgstr "Följande alternativ accepteras:"

#: ../../library/ast.rst:2213
msgid "Show the help message and exit."
msgstr "Visa hjälpmeddelandet och avsluta."

#: ../../library/ast.rst:2218
msgid ""
"Specify what kind of code must be compiled, like the *mode* argument in "
":func:`parse`."
msgstr ""
"Ange vilken typ av kod som ska kompileras, som *mode*-argumentet i "
":func:`parse`."

#: ../../library/ast.rst:2223
msgid "Don't parse type comments."
msgstr "Analysera inte typkommentarer."

#: ../../library/ast.rst:2227
msgid "Include attributes such as line numbers and column offsets."
msgstr "Inkludera attribut som radnummer och kolumnförskjutningar."

#: ../../library/ast.rst:2232
msgid "Indentation of nodes in AST (number of spaces)."
msgstr "Indragning av noder i AST (antal mellanslag)."

#: ../../library/ast.rst:2234
msgid ""
"If :file:`infile` is specified its contents are parsed to AST and dumped to "
"stdout.  Otherwise, the content is read from stdin."
msgstr ""
"Om :file:`infile` anges analyseras dess innehåll till AST och dumpas till "
"stdout.  I annat fall läses innehållet från stdin."

#: ../../library/ast.rst:2240
msgid ""
"`Green Tree Snakes <https://greentreesnakes.readthedocs.io/>`_, an external "
"documentation resource, has good details on working with Python ASTs."
msgstr ""
"`Green Tree Snakes <https://greentreesnakes.readthedocs.io/>`_, en extern "
"dokumentationsresurs, har bra detaljer om hur man arbetar med Python ASTs."

#: ../../library/ast.rst:2243
msgid ""
"`ASTTokens <https://asttokens.readthedocs.io/en/latest/user-guide.html>`_ "
"annotates Python ASTs with the positions of tokens and text in the source "
"code that generated them. This is helpful for tools that make source code "
"transformations."
msgstr ""
"`ASTTokens <https://asttokens.readthedocs.io/en/latest/user-guide.html>`_ "
"annoterar Python ASTs med positionerna för tokens och text i källkoden som "
"genererade dem. Detta är användbart för verktyg som gör "
"källkodstransformationer."

#: ../../library/ast.rst:2248
msgid ""
"`leoAst.py <https://leoeditor.com/appendices.html#leoast-py>`_ unifies the "
"token-based and parse-tree-based views of python programs by inserting two-"
"way links between tokens and ast nodes."
msgstr ""

#: ../../library/ast.rst:2252
msgid ""
"`LibCST <https://libcst.readthedocs.io/>`_ parses code as a Concrete Syntax "
"Tree that looks like an ast tree and keeps all formatting details. It's "
"useful for building automated refactoring (codemod) applications and "
"linters."
msgstr ""
"`LibCST <https://libcst.readthedocs.io/>`_ analyserar kod som ett konkret "
"syntaxträd som ser ut som ett asträd och behåller alla formateringsdetaljer."
" Det är användbart för att bygga automatiserade refaktoriseringsprogram "
"(codemod) och linters."

#: ../../library/ast.rst:2257
msgid ""
"`Parso <https://parso.readthedocs.io>`_ is a Python parser that supports "
"error recovery and round-trip parsing for different Python versions (in "
"multiple Python versions). Parso is also able to list multiple syntax errors"
" in your python file."
msgstr ""
