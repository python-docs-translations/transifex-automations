# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-17 14:16+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../library/unittest.rst:2
msgid ":mod:`!unittest` --- Unit testing framework"
msgstr ":mod:`!unittest` --- Ramverk för enhetstestning"

#: ../../library/unittest.rst:12
msgid "**Source code:** :source:`Lib/unittest/__init__.py`"
msgstr "**Källkod:** :source:`Lib/unittest/__init__.py`"

#: ../../library/unittest.rst:16
msgid ""
"(If you are already familiar with the basic concepts of testing, you might "
"want to skip to :ref:`the list of assert methods <assert-methods>`.)"
msgstr ""
"(Om du redan är bekant med de grundläggande testkoncepten kanske du vill "
"hoppa över till :ref:`listan över assert-metoder <assert-methods>`.)"

#: ../../library/unittest.rst:19
msgid ""
"The :mod:`unittest` unit testing framework was originally inspired by JUnit "
"and has a similar flavor as major unit testing frameworks in other "
"languages.  It supports test automation, sharing of setup and shutdown code "
"for tests, aggregation of tests into collections, and independence of the "
"tests from the reporting framework."
msgstr ""
"Ramverket för enhetstestning :mod:`unittest` inspirerades ursprungligen av "
"JUnit och har en liknande smak som de stora ramverken för enhetstestning i "
"andra språk.  Det stöder testautomatisering, delning av installations- och "
"avstängningskod för tester, aggregering av tester i samlingar och oberoende "
"av testerna från rapporteringsramverket."

#: ../../library/unittest.rst:25
msgid ""
"To achieve this, :mod:`unittest` supports some important concepts in an "
"object-oriented way:"
msgstr ""
"För att uppnå detta stöder :mod:`unittest` några viktiga koncept på ett "
"objektorienterat sätt:"

#: ../../library/unittest.rst:28
msgid "test fixture"
msgstr "test fixture"

#: ../../library/unittest.rst:29
msgid ""
"A :dfn:`test fixture` represents the preparation needed to perform one or "
"more tests, and any associated cleanup actions.  This may involve, for "
"example, creating temporary or proxy databases, directories, or starting a "
"server process."
msgstr ""
"En :dfn:`test fixture` representerar de förberedelser som krävs för att "
"utföra ett eller flera tester, och alla tillhörande rensningsåtgärder.  Det "
"kan t.ex. handla om att skapa tillfälliga databaser eller proxydatabaser, "
"kataloger eller att starta en serverprocess."

#: ../../library/unittest.rst:34
msgid "test case"
msgstr "test case"

#: ../../library/unittest.rst:35
msgid ""
"A :dfn:`test case` is the individual unit of testing.  It checks for a "
"specific response to a particular set of inputs.  :mod:`unittest` provides a "
"base class, :class:`TestCase`, which may be used to create new test cases."
msgstr ""
"Ett :dfn:`testfall` är en individuell enhet för testning.  Det kontrollerar "
"ett specifikt svar på en viss uppsättning indata. :mod:`unittest` "
"tillhandahåller en basklass, :class:`TestCase`, som kan användas för att "
"skapa nya testfall."

#: ../../library/unittest.rst:39
msgid "test suite"
msgstr "test suite"

#: ../../library/unittest.rst:40
msgid ""
"A :dfn:`test suite` is a collection of test cases, test suites, or both.  It "
"is used to aggregate tests that should be executed together."
msgstr ""
"En :dfn:`testsvit` är en samling av testfall, testsviter eller båda.  Den "
"används för att samla ihop tester som ska utföras tillsammans."

#: ../../library/unittest.rst:43
msgid "test runner"
msgstr "test runner"

#: ../../library/unittest.rst:44
msgid ""
"A :dfn:`test runner` is a component which orchestrates the execution of "
"tests and provides the outcome to the user.  The runner may use a graphical "
"interface, a textual interface, or return a special value to indicate the "
"results of executing the tests."
msgstr ""
"En :dfn:`test runner` är en komponent som orkestrerar utförandet av tester "
"och ger resultatet till användaren.  Runnern kan använda ett grafiskt "
"gränssnitt, ett textgränssnitt eller returnera ett speciellt värde för att "
"ange resultatet av testkörningen."

#: ../../library/unittest.rst:51
msgid "Module :mod:`doctest`"
msgstr "Modul :mod:`doctest`"

#: ../../library/unittest.rst:52
msgid "Another test-support module with a very different flavor."
msgstr "En annan teststödsmodul med en helt annan smak."

#: ../../library/unittest.rst:54
msgid ""
"`Simple Smalltalk Testing: With Patterns <https://web.archive.org/"
"web/20150315073817/http://www.xprogramming.com/testfram.htm>`_"
msgstr ""
"`Enkel testning av Smalltalk: Med mönster <https://web.archive.org/"
"web/20150315073817/http://www.xprogramming.com/testfram.htm>`_"

#: ../../library/unittest.rst:55
msgid ""
"Kent Beck's original paper on testing frameworks using the pattern shared "
"by :mod:`unittest`."
msgstr ""
"Kent Becks originalartikel om testning av ramverk med hjälp av det mönster "
"som delas av :mod:`unittest`."

#: ../../library/unittest.rst:58
msgid "`pytest <https://docs.pytest.org/>`_"
msgstr "`pytest <https://docs.pytest.org/>`_"

#: ../../library/unittest.rst:59
msgid ""
"Third-party unittest framework with a lighter-weight syntax for writing "
"tests.  For example, ``assert func(10) == 42``."
msgstr ""
"Tredjeparts unittest-ramverk med en lättare syntax för att skriva tester.  "
"Till exempel, ``assert func(10) == 42``."

#: ../../library/unittest.rst:62
msgid ""
"`The Python Testing Tools Taxonomy <https://wiki.python.org/moin/"
"PythonTestingToolsTaxonomy>`_"
msgstr ""
"`Taxonomin för testverktyg för Python <https://wiki.python.org/moin/"
"PythonTestingToolsTaxonomy>`_"

#: ../../library/unittest.rst:63
msgid ""
"An extensive list of Python testing tools including functional testing "
"frameworks and mock object libraries."
msgstr ""
"En omfattande lista över testverktyg för Python, inklusive ramverk för "
"funktionstestning och bibliotek med låtsasobjekt."

#: ../../library/unittest.rst:66
msgid ""
"`Testing in Python Mailing List <http://lists.idyll.org/listinfo/testing-in-"
"python>`_"
msgstr ""
"`Sändlista för testning i Python <http://lists.idyll.org/listinfo/testing-in-"
"python>`_"

#: ../../library/unittest.rst:67
msgid ""
"A special-interest-group for discussion of testing, and testing tools, in "
"Python."
msgstr ""
"En specialintressegrupp för diskussion om testning och testverktyg i Python."

#: ../../library/unittest.rst:70
msgid ""
"The script :file:`Tools/unittestgui/unittestgui.py` in the Python source "
"distribution is a GUI tool for test discovery and execution.  This is "
"intended largely for ease of use for those new to unit testing.  For "
"production environments it is recommended that tests be driven by a "
"continuous integration system such as `Buildbot <https://buildbot.net/>`_, "
"`Jenkins <https://www.jenkins.io/>`_, `GitHub Actions <https://github.com/"
"features/actions>`_, or `AppVeyor <https://www.appveyor.com/>`_."
msgstr ""
"Skriptet :file:`Tools/unittestgui/unittestgui.py` i Python-"
"källdistributionen är ett GUI-verktyg för att upptäcka och utföra tester.  "
"Detta är främst avsett för att underlätta användningen för dem som är nya "
"inom enhetstestning.  För produktionsmiljöer rekommenderas att tester drivs "
"av ett kontinuerligt integrationssystem som `Buildbot <https://buildbot.net/"
">`_, `Jenkins <https://www.jenkins.io/>`_, `GitHub Actions <https://github."
"com/features/actions>`_ eller `AppVeyor <https://www.appveyor.com/>`_."

#: ../../library/unittest.rst:82
msgid "Basic example"
msgstr "Grundläggande exempel"

#: ../../library/unittest.rst:84
msgid ""
"The :mod:`unittest` module provides a rich set of tools for constructing and "
"running tests.  This section demonstrates that a small subset of the tools "
"suffice to meet the needs of most users."
msgstr ""
"Modulen :mod:`unittest` innehåller en stor uppsättning verktyg för att "
"konstruera och köra tester.  Detta avsnitt visar att en liten delmängd av "
"verktygen räcker för att uppfylla de flesta användares behov."

#: ../../library/unittest.rst:88
msgid "Here is a short script to test three string methods::"
msgstr "Här är ett kort skript för att testa tre strängmetoder::"

#: ../../library/unittest.rst:90
msgid ""
"import unittest\n"
"\n"
"class TestStringMethods(unittest.TestCase):\n"
"\n"
"    def test_upper(self):\n"
"        self.assertEqual('foo'.upper(), 'FOO')\n"
"\n"
"    def test_isupper(self):\n"
"        self.assertTrue('FOO'.isupper())\n"
"        self.assertFalse('Foo'.isupper())\n"
"\n"
"    def test_split(self):\n"
"        s = 'hello world'\n"
"        self.assertEqual(s.split(), ['hello', 'world'])\n"
"        # check that s.split fails when the separator is not a string\n"
"        with self.assertRaises(TypeError):\n"
"            s.split(2)\n"
"\n"
"if __name__ == '__main__':\n"
"    unittest.main()"
msgstr ""
"import unittest\n"
"\n"
"class TestStringMethods(unittest.TestCase):\n"
"\n"
"    def test_upper(self):\n"
"        self.assertEqual('foo'.upper(), 'FOO')\n"
"\n"
"    def test_isupper(self):\n"
"        self.assertTrue('FOO'.isupper())\n"
"        self.assertFalse('Foo'.isupper())\n"
"\n"
"    def test_split(self):\n"
"        s = 'hello world'\n"
"        self.assertEqual(s.split(), ['hello', 'world'])\n"
"        # check that s.split fails when the separator is not a string\n"
"        with self.assertRaises(TypeError):\n"
"            s.split(2)\n"
"\n"
"if __name__ == '__main__':\n"
"    unittest.main()"

#: ../../library/unittest.rst:112
msgid ""
"A test case is created by subclassing :class:`unittest.TestCase`.  The three "
"individual tests are defined with methods whose names start with the letters "
"``test``.  This naming convention informs the test runner about which "
"methods represent tests."
msgstr ""
"Ett testfall skapas genom subklassning av :class:`unittest.TestCase`.  De "
"tre enskilda testerna definieras med metoder vars namn börjar med "
"bokstäverna ``test``.  Denna namngivningskonvention informerar testlöparen "
"om vilka metoder som representerar tester."

#: ../../library/unittest.rst:117
msgid ""
"The crux of each test is a call to :meth:`~TestCase.assertEqual` to check "
"for an expected result; :meth:`~TestCase.assertTrue` or :meth:`~TestCase."
"assertFalse` to verify a condition; or :meth:`~TestCase.assertRaises` to "
"verify that a specific exception gets raised.  These methods are used "
"instead of the :keyword:`assert` statement so the test runner can accumulate "
"all test results and produce a report."
msgstr ""
"Kärnan i varje test är ett anrop till :meth:`~TestCase.assertEqual` för att "
"kontrollera ett förväntat resultat; :meth:`~TestCase.assertTrue` eller :meth:"
"`~TestCase.assertFalse` för att verifiera ett villkor; eller :meth:"
"`~TestCase.assertRaises` för att verifiera att ett specifikt undantag tas "
"upp.  Dessa metoder används istället för :keyword:`assert`-satsen så att "
"testlöparen kan samla alla testresultat och producera en rapport."

#: ../../library/unittest.rst:124
msgid ""
"The :meth:`~TestCase.setUp` and :meth:`~TestCase.tearDown` methods allow you "
"to define instructions that will be executed before and after each test "
"method. They are covered in more detail in the section :ref:`organizing-"
"tests`."
msgstr ""
"Med metoderna :meth:`~TestCase.setUp` och :meth:`~TestCase.tearDown` kan du "
"definiera instruktioner som ska utföras före och efter varje testmetod. De "
"beskrivs mer i detalj i avsnittet :ref:``organizing-tests``."

#: ../../library/unittest.rst:128
msgid ""
"The final block shows a simple way to run the tests. :func:`unittest.main` "
"provides a command-line interface to the test script.  When run from the "
"command line, the above script produces an output that looks like this::"
msgstr ""
"Det sista blocket visar ett enkelt sätt att köra testerna. :func:`unittest."
"main` ger ett kommandoradsgränssnitt till testskriptet.  När ovanstående "
"skript körs från kommandoraden ger det en utdata som ser ut så här::"

#: ../../library/unittest.rst:132
msgid ""
"...\n"
"----------------------------------------------------------------------\n"
"Ran 3 tests in 0.000s\n"
"\n"
"OK"
msgstr ""
"...\n"
"----------------------------------------------------------------------\n"
"Ran 3 tests in 0.000s\n"
"\n"
"OK"

#: ../../library/unittest.rst:138
msgid ""
"Passing the ``-v`` option to your test script will instruct :func:`unittest."
"main` to enable a higher level of verbosity, and produce the following "
"output::"
msgstr ""
"Om du anger alternativet ``-v`` i ditt testskript kommer :func:`unittest."
"main` att aktivera en högre nivå av ordrikedom och producera följande "
"utdata::"

#: ../../library/unittest.rst:141
msgid ""
"test_isupper (__main__.TestStringMethods.test_isupper) ... ok\n"
"test_split (__main__.TestStringMethods.test_split) ... ok\n"
"test_upper (__main__.TestStringMethods.test_upper) ... ok\n"
"\n"
"----------------------------------------------------------------------\n"
"Ran 3 tests in 0.001s\n"
"\n"
"OK"
msgstr ""
"test_isupper (__main__.TestStringMethods.test_isupper) ... ok\n"
"test_split (__main__.TestStringMethods.test_split) ... ok\n"
"test_upper (__main__.TestStringMethods.test_upper) ... ok\n"
"\n"
"----------------------------------------------------------------------\n"
"Ran 3 tests in 0.001s\n"
"\n"
"OK"

#: ../../library/unittest.rst:150
msgid ""
"The above examples show the most commonly used :mod:`unittest` features "
"which are sufficient to meet many everyday testing needs.  The remainder of "
"the documentation explores the full feature set from first principles."
msgstr ""
"Exemplen ovan visar de vanligaste :mod:`unittest`-funktionerna som är "
"tillräckliga för att uppfylla många vardagliga testbehov.  I resten av "
"dokumentationen utforskas hela funktionsuppsättningen från första början."

#: ../../library/unittest.rst:154
msgid ""
"The behavior of returning a value from a test method (other than the default "
"``None`` value), is now deprecated."
msgstr ""
"Beteendet att returnera ett värde från en testmetod (annat än standardvärdet "
"``None``) är nu föråldrat."

#: ../../library/unittest.rst:162
msgid "Command-Line Interface"
msgstr "Kommandoradsgränssnitt"

#: ../../library/unittest.rst:164
msgid ""
"The unittest module can be used from the command line to run tests from "
"modules, classes or even individual test methods::"
msgstr ""
"Modulen unittest kan användas från kommandoraden för att köra tester från "
"moduler, klasser eller till och med enskilda testmetoder::"

#: ../../library/unittest.rst:167
msgid ""
"python -m unittest test_module1 test_module2\n"
"python -m unittest test_module.TestClass\n"
"python -m unittest test_module.TestClass.test_method"
msgstr ""
"python -m unittest test_modul1 test_modul2\n"
"python -m unittest test_modul.TestClass\n"
"python -m unittest test_modul.TestClass.test_method"

#: ../../library/unittest.rst:171
msgid ""
"You can pass in a list with any combination of module names, and fully "
"qualified class or method names."
msgstr ""
"Du kan skicka in en lista med valfri kombination av modulnamn och "
"fullständigt kvalificerade klass- eller metodnamn."

#: ../../library/unittest.rst:174
msgid "Test modules can be specified by file path as well::"
msgstr "Testmoduler kan också anges med filväg::"

#: ../../library/unittest.rst:176
msgid "python -m unittest tests/test_something.py"
msgstr "python -m unittest tester/test_något.py"

#: ../../library/unittest.rst:178
msgid ""
"This allows you to use the shell filename completion to specify the test "
"module. The file specified must still be importable as a module. The path is "
"converted to a module name by removing the '.py' and converting path "
"separators into '.'. If you want to execute a test file that isn't "
"importable as a module you should execute the file directly instead."
msgstr ""
"Detta gör att du kan använda skalets filnamnskomplettering för att ange "
"testmodulen. Den angivna filen måste fortfarande vara importerbar som en "
"modul. Sökvägen konverteras till ett modulnamn genom att \".py\" tas bort "
"och sökvägsavgränsare konverteras till \".\". Om du vill köra en testfil som "
"inte kan importeras som en modul bör du istället köra filen direkt."

#: ../../library/unittest.rst:184
msgid ""
"You can run tests with more detail (higher verbosity) by passing in the -v "
"flag::"
msgstr ""
"Du kan köra tester med fler detaljer (högre verbosity) genom att skicka in "
"flaggan -v::"

#: ../../library/unittest.rst:186
msgid "python -m unittest -v test_module"
msgstr "python -m unittest -v test_modul"

#: ../../library/unittest.rst:188
msgid ""
"When executed without arguments :ref:`unittest-test-discovery` is started::"
msgstr "När den körs utan argument startas :ref:`unittest-test-discovery`::"

#: ../../library/unittest.rst:190
msgid "python -m unittest"
msgstr "python -m unittest"

#: ../../library/unittest.rst:192
msgid "For a list of all the command-line options::"
msgstr "För en lista över alla kommandoradsalternativ::"

#: ../../library/unittest.rst:194
msgid "python -m unittest -h"
msgstr "python -m unittest -h"

#: ../../library/unittest.rst:196
msgid ""
"In earlier versions it was only possible to run individual test methods and "
"not modules or classes."
msgstr ""
"I tidigare versioner var det bara möjligt att köra enskilda testmetoder och "
"inte moduler eller klasser."

#: ../../library/unittest.rst:200
msgid ""
"Output is colorized by default and can be :ref:`controlled using environment "
"variables <using-on-controlling-color>`."
msgstr ""
"Utdata är färgade som standard och kan :ref:`kontrolleras med hjälp av "
"miljövariabler <using-on-controlling-color>`."

#: ../../library/unittest.rst:205
msgid "Command-line options"
msgstr "Alternativ för kommandoraden"

#: ../../library/unittest.rst:207
msgid ":program:`unittest` supports these command-line options:"
msgstr ":program:`unittest` stöder dessa kommandoradsalternativ:"

#: ../../library/unittest.rst:213
msgid ""
"The standard output and standard error streams are buffered during the test "
"run. Output during a passing test is discarded. Output is echoed normally on "
"test fail or error and is added to the failure messages."
msgstr ""
"Standardutdata- och standardfelströmmarna buffras under testkörningen. "
"Utdata under ett godkänt test kasseras. Utdata ekas normalt vid misslyckat "
"eller felaktigt test och läggs till i felmeddelandena."

#: ../../library/unittest.rst:219
msgid ""
":kbd:`Control-C` during the test run waits for the current test to end and "
"then reports all the results so far. A second :kbd:`Control-C` raises the "
"normal :exc:`KeyboardInterrupt` exception."
msgstr ""
":kbd:`Control-C` under testkörningen väntar på att det aktuella testet skall "
"avslutas och rapporterar sedan alla resultat så här långt. En andra :kbd:"
"`Control-C` ger upphov till det normala :exc:`KeyboardInterrupt` undantaget."

#: ../../library/unittest.rst:223
msgid ""
"See `Signal Handling`_ for the functions that provide this functionality."
msgstr ""
"Se `Signalhantering`_ för de funktioner som tillhandahåller denna "
"funktionalitet."

#: ../../library/unittest.rst:227
msgid "Stop the test run on the first error or failure."
msgstr "Avbryt testkörningen vid första felet eller misslyckandet."

#: ../../library/unittest.rst:231
msgid ""
"Only run test methods and classes that match the pattern or substring. This "
"option may be used multiple times, in which case all test cases that match "
"any of the given patterns are included."
msgstr ""
"Kör endast testmetoder och klasser som matchar mönstret eller delsträngen. "
"Det här alternativet kan användas flera gånger, och då inkluderas alla "
"testfall som matchar något av de angivna mönstren."

#: ../../library/unittest.rst:235
msgid ""
"Patterns that contain a wildcard character (``*``) are matched against the "
"test name using :meth:`fnmatch.fnmatchcase`; otherwise simple case-sensitive "
"substring matching is used."
msgstr ""
"Mönster som innehåller ett jokertecken (``*``) matchas mot testnamnet med "
"hjälp av :meth:`fnmatch.fnmatchcase`; annars används enkel skiftlägeskänslig "
"delsträngsmatchning."

#: ../../library/unittest.rst:239
msgid ""
"Patterns are matched against the fully qualified test method name as "
"imported by the test loader."
msgstr ""
"Mönster matchas mot det fullständigt kvalificerade testmetodnamnet som "
"importeras av testladdaren."

#: ../../library/unittest.rst:242
msgid ""
"For example, ``-k foo`` matches ``foo_tests.SomeTest.test_something``, "
"``bar_tests.SomeTest.test_foo``, but not ``bar_tests.FooTest."
"test_something``."
msgstr ""
"Till exempel matchar ``-k foo`` ``foo_tests.SomeTest.test_something``, "
"``bar_tests.SomeTest.test_foo``, men inte ``bar_tests.FooTest."
"test_something``."

#: ../../library/unittest.rst:247
msgid "Show local variables in tracebacks."
msgstr "Visa lokala variabler i spårningar."

#: ../../library/unittest.rst:251
msgid "Show the N slowest test cases (N=0 for all)."
msgstr "Visa de N långsammaste testfallen (N=0 för alla)."

#: ../../library/unittest.rst:253
msgid "The command-line options ``-b``, ``-c`` and ``-f`` were added."
msgstr "Kommandoradsalternativen ``-b``, ``-c`` och ``-f`` har lagts till."

#: ../../library/unittest.rst:256
msgid "The command-line option ``--locals``."
msgstr "Kommandoradsalternativet ``--locals``."

#: ../../library/unittest.rst:259
msgid "The command-line option ``-k``."
msgstr "Kommandoradsalternativet ``-k``."

#: ../../library/unittest.rst:262
msgid "The command-line option ``--durations``."
msgstr "Kommandoradsalternativet ``--durations``."

#: ../../library/unittest.rst:265
msgid ""
"The command line can also be used for test discovery, for running all of the "
"tests in a project or just a subset."
msgstr ""
"Kommandoraden kan också användas för att upptäcka tester, för att köra alla "
"tester i ett projekt eller bara en delmängd."

#: ../../library/unittest.rst:271
msgid "Test Discovery"
msgstr "Testupptäckt"

#: ../../library/unittest.rst:275
msgid ""
"Unittest supports simple test discovery. In order to be compatible with test "
"discovery, all of the test files must be :ref:`modules <tut-modules>` or :"
"ref:`packages <tut-packages>` importable from the top-level directory of the "
"project (this means that their filenames must be valid :ref:`identifiers "
"<identifiers>`)."
msgstr ""
"Unittest stöder enkel testupptäckt. För att vara kompatibla med testupptäckt "
"måste alla testfiler vara :ref:`modules <tut-modules>` eller :ref:`packages "
"<tut-packages>` som kan importeras från projektets toppkatalog (detta "
"innebär att deras filnamn måste vara giltiga :ref:`identifiers "
"<identifiers>`)."

#: ../../library/unittest.rst:281
msgid ""
"Test discovery is implemented in :meth:`TestLoader.discover`, but can also "
"be used from the command line. The basic command-line usage is::"
msgstr ""
"Testupptäckt implementeras i :meth:`TestLoader.discover`, men kan också "
"användas från kommandoraden. Den grundläggande kommandoradsanvändningen är::"

#: ../../library/unittest.rst:284
msgid ""
"cd project_directory\n"
"python -m unittest discover"
msgstr ""
"cd projekt_katalog\n"
"python -m unittest discover"

#: ../../library/unittest.rst:289
msgid ""
"As a shortcut, ``python -m unittest`` is the equivalent of ``python -m "
"unittest discover``. If you want to pass arguments to test discovery the "
"``discover`` sub-command must be used explicitly."
msgstr ""
"Som en genväg är ``python -m unittest`` ekvivalent med ``python -m unittest "
"discover``. Om du vill skicka argument till testdiscovery måste "
"underkommandot ``discover`` användas explicit."

#: ../../library/unittest.rst:293
msgid "The ``discover`` sub-command has the following options:"
msgstr "Underkommandot ``discover`` har följande alternativ:"

#: ../../library/unittest.rst:299
msgid "Verbose output"
msgstr "Utförlig utdata"

#: ../../library/unittest.rst:303
msgid "Directory to start discovery (``.`` default)"
msgstr "Katalog för att starta upptäckten (``.`` standard)"

#: ../../library/unittest.rst:307
msgid "Pattern to match test files (``test*.py`` default)"
msgstr "Mönster för att matcha testfiler (``test*.py`` standard)"

#: ../../library/unittest.rst:311
msgid "Top level directory of project (defaults to start directory)"
msgstr "Projektets katalog på högsta nivån (standard är startkatalogen)"

#: ../../library/unittest.rst:313
msgid ""
"The :option:`-s`, :option:`-p`, and :option:`-t` options can be passed in as "
"positional arguments in that order. The following two command lines are "
"equivalent::"
msgstr ""
"Alternativen :option:`-s`, :option:`-p` och :option:`-t` kan anges som "
"positionella argument i den ordningen. Följande två kommandorader är "
"likvärdiga::"

#: ../../library/unittest.rst:317
msgid ""
"python -m unittest discover -s project_directory -p \"*_test.py\"\n"
"python -m unittest discover project_directory \"*_test.py\""
msgstr ""
"python -m unittest discover -s project_directory -p \"*_test.py\"\n"
"python -m unittest discover project_directory \"*_test.py\""

#: ../../library/unittest.rst:320
msgid ""
"As well as being a path it is possible to pass a package name, for example "
"``myproject.subpackage.test``, as the start directory. The package name you "
"supply will then be imported and its location on the filesystem will be used "
"as the start directory."
msgstr ""
"Förutom att ange en sökväg är det möjligt att ange ett paketnamn, t.ex. "
"``myproject.subpackage.test``, som startkatalog. Det paketnamn som du anger "
"importeras då och dess plats i filsystemet används som startkatalog."

#: ../../library/unittest.rst:327
msgid ""
"Test discovery loads tests by importing them. Once test discovery has found "
"all the test files from the start directory you specify it turns the paths "
"into package names to import. For example :file:`foo/bar/baz.py` will be "
"imported as ``foo.bar.baz``."
msgstr ""
"Test discovery laddar tester genom att importera dem. När testdiscovery har "
"hittat alla testfiler från den startkatalog du anger omvandlar den "
"sökvägarna till paketnamn som ska importeras. Till exempel :file:`foo/bar/"
"baz.py` importeras som ``foo.bar.baz``."

#: ../../library/unittest.rst:332
msgid ""
"If you have a package installed globally and attempt test discovery on a "
"different copy of the package then the import *could* happen from the wrong "
"place. If this happens test discovery will warn you and exit."
msgstr ""
"Om du har ett paket installerat globalt och försöker utföra testdiscovery på "
"en annan kopia av paketet, kan importen ske från fel ställe. Om detta händer "
"kommer test discovery att varna dig och avsluta."

#: ../../library/unittest.rst:336
msgid ""
"If you supply the start directory as a package name rather than a path to a "
"directory then discover assumes that whichever location it imports from is "
"the location you intended, so you will not get the warning."
msgstr ""
"Om du anger startkatalogen som ett paketnamn i stället för en sökväg till en "
"katalog antar discover att den plats som den importerar från är den plats "
"som du avsåg, så att du inte får varningen."

#: ../../library/unittest.rst:341
msgid ""
"Test modules and packages can customize test loading and discovery by "
"through the `load_tests protocol`_."
msgstr ""
"Testmoduler och testpaket kan anpassa laddning och upptäckt av tester genom "
"protokollet `load_tests`_."

#: ../../library/unittest.rst:344
msgid "Test discovery supports :term:`namespace packages <namespace package>`."
msgstr "Test discovery stöder :term:`namespace packages <namespace package>`."

#: ../../library/unittest.rst:347
msgid ""
"Test discovery dropped the :term:`namespace packages <namespace package>` "
"support. It has been broken since Python 3.7. Start directory and its "
"subdirectories containing tests must be regular package that have ``__init__."
"py`` file."
msgstr ""
"Test discovery släppte :term:`namespace packages <namespace package>`-"
"stödet. Det har varit trasigt sedan Python 3.7. Startkatalog och dess "
"underkataloger som innehåller tester måste vara vanliga paket som har filen "
"``__init__.py``."

#: ../../library/unittest.rst:353
msgid ""
"If the start directory is the dotted name of the package, the ancestor "
"packages can be namespace packages."
msgstr ""
"Om startkatalogen är paketets prickade namn kan förfäderspaketen vara "
"namnrymdspaket."

#: ../../library/unittest.rst:356
msgid ""
"Test discovery supports :term:`namespace package` as start directory again. "
"To avoid scanning directories unrelated to Python, tests are not searched in "
"subdirectories that do not contain ``__init__.py``."
msgstr ""
"Testupptäckt stöder :term:`namespace package` som startkatalog igen. För att "
"undvika att skanna kataloger som inte är relaterade till Python, söks inte "
"tester i underkataloger som inte innehåller ``__init__.py``."

#: ../../library/unittest.rst:365
msgid "Organizing test code"
msgstr "Organisering av testkod"

#: ../../library/unittest.rst:367
msgid ""
"The basic building blocks of unit testing are :dfn:`test cases` --- single "
"scenarios that must be set up and checked for correctness.  In :mod:"
"`unittest`, test cases are represented by :class:`unittest.TestCase` "
"instances. To make your own test cases you must write subclasses of :class:"
"`TestCase` or use :class:`FunctionTestCase`."
msgstr ""
"De grundläggande byggstenarna i enhetstestning är :dfn:`testfall` --- "
"enskilda scenarier som måste ställas upp och kontrolleras för korrekthet.  "
"I :mod:`unittest` representeras testfall av :class:`unittest.TestCase`-"
"instanser. För att skapa egna testfall måste du skriva subklasser av :class:"
"`TestCase` eller använda :class:`FunctionTestCase`."

#: ../../library/unittest.rst:373
msgid ""
"The testing code of a :class:`TestCase` instance should be entirely self "
"contained, such that it can be run either in isolation or in arbitrary "
"combination with any number of other test cases."
msgstr ""
"Testkoden för en :class:`TestCase`-instans bör vara helt fristående, så att "
"den kan köras antingen isolerat eller i godtycklig kombination med valfritt "
"antal andra testfall."

#: ../../library/unittest.rst:377
msgid ""
"The simplest :class:`TestCase` subclass will simply implement a test method "
"(i.e. a method whose name starts with ``test``) in order to perform specific "
"testing code::"
msgstr ""
"Den enklaste :class:`TestCase`-underklassen kommer helt enkelt att "
"implementera en testmetod (dvs. en metod vars namn börjar med ``test``) för "
"att utföra specifik testkod::"

#: ../../library/unittest.rst:381
msgid ""
"import unittest\n"
"\n"
"class DefaultWidgetSizeTestCase(unittest.TestCase):\n"
"    def test_default_widget_size(self):\n"
"        widget = Widget('The widget')\n"
"        self.assertEqual(widget.size(), (50, 50))"
msgstr ""
"import unittest\n"
"\n"
"class DefaultWidgetSizeTestCase(unittest.TestCase):\n"
"    def test_default_widget_size(self):\n"
"        widget = Widget('The widget')\n"
"        self.assertEqual(widget.size(), (50, 50))"

#: ../../library/unittest.rst:388
msgid ""
"Note that in order to test something, we use one of the :ref:`assert\\* "
"methods <assert-methods>` provided by the :class:`TestCase` base class.  If "
"the test fails, an exception will be raised with an explanatory message, "
"and :mod:`unittest` will identify the test case as a :dfn:`failure`.  Any "
"other exceptions will be treated as :dfn:`errors`."
msgstr ""
"Observera att för att testa något använder vi en av metoderna :ref:"
"`assert\\* <assert-methods>` som tillhandahålls av basklassen :class:"
"`TestCase`.  Om testet misslyckas kommer ett undantag att uppstå med ett "
"förklarande meddelande, och :mod:`unittest` kommer att identifiera "
"testfallet som ett :dfn:`failure`.  Alla andra undantag kommer att behandlas "
"som :dfn:`errors`."

#: ../../library/unittest.rst:394
msgid ""
"Tests can be numerous, and their set-up can be repetitive.  Luckily, we can "
"factor out set-up code by implementing a method called :meth:`~TestCase."
"setUp`, which the testing framework will automatically call for every single "
"test we run::"
msgstr ""
"Testerna kan vara många och deras uppbyggnad kan vara repetitiv.  "
"Lyckligtvis kan vi eliminera uppstartskoden genom att implementera en metod "
"som heter :meth:`~TestCase.setUp`, som testramverket automatiskt anropar för "
"varje enskilt test vi kör::"

#: ../../library/unittest.rst:399
msgid ""
"import unittest\n"
"\n"
"class WidgetTestCase(unittest.TestCase):\n"
"    def setUp(self):\n"
"        self.widget = Widget('The widget')\n"
"\n"
"    def test_default_widget_size(self):\n"
"        self.assertEqual(self.widget.size(), (50,50),\n"
"                         'incorrect default size')\n"
"\n"
"    def test_widget_resize(self):\n"
"        self.widget.resize(100,150)\n"
"        self.assertEqual(self.widget.size(), (100,150),\n"
"                         'wrong size after resize')"
msgstr ""
"import unittest\n"
"\n"
"class WidgetTestCase(unittest.TestCase):\n"
"    def setUp(self):\n"
"        self.widget = Widget('The widget')\n"
"\n"
"    def test_default_widget_size(self):\n"
"        self.assertEqual(self.widget.size(), (50,50),\n"
"                         'incorrect default size')\n"
"\n"
"    def test_widget_resize(self):\n"
"        self.widget.resize(100,150)\n"
"        self.assertEqual(self.widget.size(), (100,150),\n"
"                         'wrong size after resize')"

#: ../../library/unittest.rst:415
msgid ""
"The order in which the various tests will be run is determined by sorting "
"the test method names with respect to the built-in ordering for strings."
msgstr ""
"Den ordning i vilken de olika testerna kommer att köras bestäms genom att "
"sortera testmetodernas namn med hänsyn till den inbyggda ordningen för "
"strängar."

#: ../../library/unittest.rst:419
msgid ""
"If the :meth:`~TestCase.setUp` method raises an exception while the test is "
"running, the framework will consider the test to have suffered an error, and "
"the test method will not be executed."
msgstr ""
"Om metoden :meth:`~TestCase.setUp` ger upphov till ett undantag medan testet "
"körs, kommer ramverket att anse att testet har drabbats av ett fel och "
"testmetoden kommer inte att utföras."

#: ../../library/unittest.rst:423
msgid ""
"Similarly, we can provide a :meth:`~TestCase.tearDown` method that tidies up "
"after the test method has been run::"
msgstr ""
"På samma sätt kan vi tillhandahålla en :meth:`~TestCase.tearDown`-metod som "
"städar upp efter att testmetoden har körts::"

#: ../../library/unittest.rst:426
msgid ""
"import unittest\n"
"\n"
"class WidgetTestCase(unittest.TestCase):\n"
"    def setUp(self):\n"
"        self.widget = Widget('The widget')\n"
"\n"
"    def tearDown(self):\n"
"        self.widget.dispose()"
msgstr ""
"import unittest\n"
"\n"
"class WidgetTestCase(unittest.TestCase):\n"
"    def setUp(self):\n"
"        self.widget = Widget('The widget')\n"
"\n"
"    def tearDown(self):\n"
"        self.widget.dispose()"

#: ../../library/unittest.rst:435
msgid ""
"If :meth:`~TestCase.setUp` succeeded, :meth:`~TestCase.tearDown` will be run "
"whether the test method succeeded or not."
msgstr ""
"Om :meth:`~TestCase.setUp` lyckades kommer :meth:`~TestCase.tearDown` att "
"köras oavsett om testmetoden lyckades eller inte."

#: ../../library/unittest.rst:438
msgid ""
"Such a working environment for the testing code is called a :dfn:`test "
"fixture`.  A new TestCase instance is created as a unique test fixture used "
"to execute each individual test method.  Thus :meth:`~TestCase.setUp`, :meth:"
"`~TestCase.tearDown`, and :meth:`~TestCase.__init__` will be called once per "
"test."
msgstr ""
"En sådan arbetsmiljö för testkoden kallas för en :dfn:`testfixtur`.  En ny "
"TestCase-instans skapas som en unik testfixtur som används för att utföra "
"varje enskild testmetod.  Således kommer :meth:`~TestCase.setUp`, :meth:"
"`~TestCase.tearDown` och :meth:`~TestCase.__init__` att anropas en gång per "
"test."

#: ../../library/unittest.rst:444
msgid ""
"It is recommended that you use TestCase implementations to group tests "
"together according to the features they test.  :mod:`unittest` provides a "
"mechanism for this: the :dfn:`test suite`, represented by :mod:`unittest`'s :"
"class:`TestSuite` class.  In most cases, calling :func:`unittest.main` will "
"do the right thing and collect all the module's test cases for you and "
"execute them."
msgstr ""
"Det rekommenderas att du använder TestCase-implementationer för att gruppera "
"tester tillsammans enligt de funktioner de testar. :mod:`unittest` "
"tillhandahåller en mekanism för detta: :dfn:`test suite`, representerad av :"
"mod:`unittest`:s :class:`TestSuite`-klass.  I de flesta fall kommer ett "
"anrop till :func:`unittest.main` att göra det rätta och samla in alla "
"modulens testfall åt dig och köra dem."

#: ../../library/unittest.rst:451
msgid ""
"However, should you want to customize the building of your test suite, you "
"can do it yourself::"
msgstr ""
"Men om du vill anpassa uppbyggnaden av din testsvit kan du göra det själv::"

#: ../../library/unittest.rst:454
msgid ""
"def suite():\n"
"    suite = unittest.TestSuite()\n"
"    suite.addTest(WidgetTestCase('test_default_widget_size'))\n"
"    suite.addTest(WidgetTestCase('test_widget_resize'))\n"
"    return suite\n"
"\n"
"if __name__ == '__main__':\n"
"    runner = unittest.TextTestRunner()\n"
"    runner.run(suite())"
msgstr ""
"def suite():\n"
"    suite = unittest.TestSuite()\n"
"    suite.addTest(WidgetTestCase('test_default_widget_size'))\n"
"    suite.addTest(WidgetTestCase('test_widget_resize'))\n"
"    return suite\n"
"\n"
"if __name__ == '__main__':\n"
"    runner = unittest.TextTestRunner()\n"
"    runner.run(suite())"

#: ../../library/unittest.rst:464
msgid ""
"You can place the definitions of test cases and test suites in the same "
"modules as the code they are to test (such as :file:`widget.py`), but there "
"are several advantages to placing the test code in a separate module, such "
"as :file:`test_widget.py`:"
msgstr ""
"Du kan placera definitionerna av testfall och testsviter i samma moduler som "
"den kod de ska testa (t.ex. :file:`widget.py`), men det finns flera fördelar "
"med att placera testkoden i en separat modul, t.ex. :file:`test_widget.py`:"

#: ../../library/unittest.rst:469
msgid "The test module can be run standalone from the command line."
msgstr "Testmodulen kan köras fristående från kommandoraden."

#: ../../library/unittest.rst:471
msgid "The test code can more easily be separated from shipped code."
msgstr "Testkoden kan lättare separeras från den levererade koden."

#: ../../library/unittest.rst:473
msgid ""
"There is less temptation to change test code to fit the code it tests "
"without a good reason."
msgstr ""
"Det är mindre frestande att utan goda skäl ändra testkoden så att den passar "
"den kod som testas."

#: ../../library/unittest.rst:476
msgid ""
"Test code should be modified much less frequently than the code it tests."
msgstr "Testkod bör modifieras mycket mer sällan än den kod som den testar."

#: ../../library/unittest.rst:478
msgid "Tested code can be refactored more easily."
msgstr "Testad kod kan lättare omarbetas."

#: ../../library/unittest.rst:480
msgid ""
"Tests for modules written in C must be in separate modules anyway, so why "
"not be consistent?"
msgstr ""
"Tester för moduler som är skrivna i C måste ändå vara i separata moduler, så "
"varför inte vara konsekvent?"

#: ../../library/unittest.rst:483
msgid ""
"If the testing strategy changes, there is no need to change the source code."
msgstr "Om teststrategin ändras behöver källkoden inte ändras."

#: ../../library/unittest.rst:489
msgid "Re-using old test code"
msgstr "Återanvändning av gammal testkod"

#: ../../library/unittest.rst:491
msgid ""
"Some users will find that they have existing test code that they would like "
"to run from :mod:`unittest`, without converting every old test function to "
"a :class:`TestCase` subclass."
msgstr ""
"Vissa användare kommer att upptäcka att de har befintlig testkod som de vill "
"köra från :mod:`unittest`, utan att konvertera varje gammal testfunktion "
"till en :class:`TestCase`-underklass."

#: ../../library/unittest.rst:495
msgid ""
"For this reason, :mod:`unittest` provides a :class:`FunctionTestCase` class. "
"This subclass of :class:`TestCase` can be used to wrap an existing test "
"function.  Set-up and tear-down functions can also be provided."
msgstr ""
"Av denna anledning tillhandahåller :mod:`unittest` en :class:"
"`FunctionTestCase`-klass. Denna subklass av :class:`TestCase` kan användas "
"för att paketera en befintlig testfunktion.  Funktioner för uppbyggnad och "
"nedmontering kan också tillhandahållas."

#: ../../library/unittest.rst:499
msgid "Given the following test function::"
msgstr "Givet följande testfunktion::"

#: ../../library/unittest.rst:501
msgid ""
"def testSomething():\n"
"    something = makeSomething()\n"
"    assert something.name is not None\n"
"    # ..."
msgstr ""
"def testSomething():\n"
"    something = makeSomething()\n"
"    assert something.name is not None\n"
"    # ..."

#: ../../library/unittest.rst:506
msgid ""
"one can create an equivalent test case instance as follows, with optional "
"set-up and tear-down methods::"
msgstr ""
"kan man skapa en motsvarande testfallsinstans på följande sätt, med valfria "
"metoder för uppbyggnad och nedmontering::"

#: ../../library/unittest.rst:509
msgid ""
"testcase = unittest.FunctionTestCase(testSomething,\n"
"                                     setUp=makeSomethingDB,\n"
"                                     tearDown=deleteSomethingDB)"
msgstr ""
"testcase = unittest.FunctionTestCase(testSomething,\n"
"                                     setUp=makeSomethingDB,\n"
"                                     tearDown=deleteSomethingDB)"

#: ../../library/unittest.rst:515
msgid ""
"Even though :class:`FunctionTestCase` can be used to quickly convert an "
"existing test base over to a :mod:`unittest`\\ -based system, this approach "
"is not recommended.  Taking the time to set up proper :class:`TestCase` "
"subclasses will make future test refactorings infinitely easier."
msgstr ""
"Även om :class:`FunctionTestCase` kan användas för att snabbt konvertera en "
"befintlig testbas till ett :mod:`unittest` -baserat system, rekommenderas "
"inte detta tillvägagångssätt.  Att ta sig tid att skapa korrekta :class:"
"`TestCase`-subklasser kommer att göra framtida refaktoriseringar av tester "
"oändligt mycket enklare."

#: ../../library/unittest.rst:520
msgid ""
"In some cases, the existing tests may have been written using the :mod:"
"`doctest` module.  If so, :mod:`doctest` provides a :class:`DocTestSuite` "
"class that can automatically build :class:`unittest.TestSuite` instances "
"from the existing :mod:`doctest`\\ -based tests."
msgstr ""
"I vissa fall kan de befintliga testerna ha skrivits med modulen :mod:"
"`doctest`.  Om så är fallet tillhandahåller :mod:`doctest` en :class:"
"`DocTestSuite`-klass som automatiskt kan bygga :class:`unittest.TestSuite`-"
"instanser från de befintliga :mod:`doctest`-baserade testerna."

#: ../../library/unittest.rst:529
msgid "Skipping tests and expected failures"
msgstr "Skippa tester och förväntade misslyckanden"

#: ../../library/unittest.rst:533
msgid ""
"Unittest supports skipping individual test methods and even whole classes of "
"tests.  In addition, it supports marking a test as an \"expected failure,\" "
"a test that is broken and will fail, but shouldn't be counted as a failure "
"on a :class:`TestResult`."
msgstr ""
"Unittest har stöd för att hoppa över enskilda testmetoder och till och med "
"hela klasser av tester.  Dessutom finns det stöd för att markera ett test "
"som ett \"förväntat misslyckande\", ett test som är trasigt och kommer att "
"misslyckas, men som inte bör räknas som ett misslyckande i :class:"
"`TestResult`."

#: ../../library/unittest.rst:538
msgid ""
"Skipping a test is simply a matter of using the :func:`skip` :term:"
"`decorator` or one of its conditional variants, calling :meth:`TestCase."
"skipTest` within a :meth:`~TestCase.setUp` or test method, or raising :exc:"
"`SkipTest` directly."
msgstr ""
"Att hoppa över ett test är helt enkelt en fråga om att använda :func:`skip` :"
"term:`decorator` eller en av dess villkorliga varianter, anropa :meth:"
"`TestCase.skipTest` inom en :meth:`~TestCase.setUp` eller testmetod, eller "
"att direkt ställa in :exc:`SkipTest`."

#: ../../library/unittest.rst:542
msgid "Basic skipping looks like this::"
msgstr "Grundläggande hoppning ser ut så här::"

#: ../../library/unittest.rst:544
msgid ""
"class MyTestCase(unittest.TestCase):\n"
"\n"
"    @unittest.skip(\"demonstrating skipping\")\n"
"    def test_nothing(self):\n"
"        self.fail(\"shouldn't happen\")\n"
"\n"
"    @unittest.skipIf(mylib.__version__ < (1, 3),\n"
"                     \"not supported in this library version\")\n"
"    def test_format(self):\n"
"        # Tests that work for only a certain version of the library.\n"
"        pass\n"
"\n"
"    @unittest.skipUnless(sys.platform.startswith(\"win\"), \"requires "
"Windows\")\n"
"    def test_windows_support(self):\n"
"        # windows specific testing code\n"
"        pass\n"
"\n"
"    def test_maybe_skipped(self):\n"
"        if not external_resource_available():\n"
"            self.skipTest(\"external resource not available\")\n"
"        # test code that depends on the external resource\n"
"        pass"
msgstr ""
"class MyTestCase(unittest.TestCase):\n"
"\n"
"    @unittest.skip(\"demonstrating skipping\")\n"
"    def test_nothing(self):\n"
"        self.fail(\"shouldn't happen\")\n"
"\n"
"    @unittest.skipIf(mylib.__version__ < (1, 3),\n"
"                     \"not supported in this library version\")\n"
"    def test_format(self):\n"
"        # Tests that work for only a certain version of the library.\n"
"        pass\n"
"\n"
"    @unittest.skipUnless(sys.platform.startswith(\"win\"), \"requires "
"Windows\")\n"
"    def test_windows_support(self):\n"
"        # windows specific testing code\n"
"        pass\n"
"\n"
"    def test_maybe_skipped(self):\n"
"        if not external_resource_available():\n"
"            self.skipTest(\"external resource not available\")\n"
"        # test code that depends on the external resource\n"
"        pass"

#: ../../library/unittest.rst:567
msgid "This is the output of running the example above in verbose mode::"
msgstr "Så här ser resultatet ut när du kör exemplet ovan i verbose-läge::"

#: ../../library/unittest.rst:569
msgid ""
"test_format (__main__.MyTestCase.test_format) ... skipped 'not supported in "
"this library version'\n"
"test_nothing (__main__.MyTestCase.test_nothing) ... skipped 'demonstrating "
"skipping'\n"
"test_maybe_skipped (__main__.MyTestCase.test_maybe_skipped) ... skipped "
"'external resource not available'\n"
"test_windows_support (__main__.MyTestCase.test_windows_support) ... skipped "
"'requires Windows'\n"
"\n"
"----------------------------------------------------------------------\n"
"Ran 4 tests in 0.005s\n"
"\n"
"OK (skipped=4)"
msgstr ""
"test_format (__main__.MyTestCase.test_format) ... skipped 'not supported in "
"this library version'\n"
"test_nothing (__main__.MyTestCase.test_nothing) ... skipped 'demonstrating "
"skipping'\n"
"test_maybe_skipped (__main__.MyTestCase.test_maybe_skipped) ... skipped "
"'external resource not available'\n"
"test_windows_support (__main__.MyTestCase.test_windows_support) ... skipped "
"'requires Windows'\n"
"\n"
"----------------------------------------------------------------------\n"
"Ran 4 tests in 0.005s\n"
"\n"
"OK (skipped=4)"

#: ../../library/unittest.rst:579
msgid "Classes can be skipped just like methods::"
msgstr "Klasser kan hoppas över precis som metoder:"

#: ../../library/unittest.rst:581
msgid ""
"@unittest.skip(\"showing class skipping\")\n"
"class MySkippedTestCase(unittest.TestCase):\n"
"    def test_not_run(self):\n"
"        pass"
msgstr ""
"@unittest.skip(\"visar klasshoppning\")\n"
"klass MySkippedTestCase(unittest.TestCase):\n"
"    def test_not_run(self):\n"
"        passera"

#: ../../library/unittest.rst:586
msgid ""
":meth:`TestCase.setUp` can also skip the test.  This is useful when a "
"resource that needs to be set up is not available."
msgstr ""
":meth:`TestCase.setUp` kan också hoppa över testet.  Detta är användbart när "
"en resurs som behöver konfigureras inte är tillgänglig."

#: ../../library/unittest.rst:589
msgid "Expected failures use the :func:`expectedFailure` decorator. ::"
msgstr "Förväntade fel använder dekoratorn :func:`expectedFailure`. ::"

#: ../../library/unittest.rst:591
msgid ""
"class ExpectedFailureTestCase(unittest.TestCase):\n"
"    @unittest.expectedFailure\n"
"    def test_fail(self):\n"
"        self.assertEqual(1, 0, \"broken\")"
msgstr ""
"class ExpectedFailureTestCase(unittest.TestCase):\n"
"    @unittest.expectedFailure\n"
"    def test_fail(self):\n"
"        self.assertEqual(1, 0, \"broken\")"

#: ../../library/unittest.rst:596
msgid ""
"It's easy to roll your own skipping decorators by making a decorator that "
"calls :func:`skip` on the test when it wants it to be skipped.  This "
"decorator skips the test unless the passed object has a certain attribute::"
msgstr ""
"Det är enkelt att skapa egna dekoratorer för att hoppa över tester genom att "
"skapa en dekorator som anropar :func:`skip` på testet när den vill att det "
"ska hoppas över.  Denna dekorator hoppar över testet om inte det passerade "
"objektet har ett visst attribut::"

#: ../../library/unittest.rst:600
msgid ""
"def skipUnlessHasattr(obj, attr):\n"
"    if hasattr(obj, attr):\n"
"        return lambda func: func\n"
"    return unittest.skip(\"{!r} doesn't have {!r}\".format(obj, attr))"
msgstr ""
"def skipUnlessHasattr(obj, attr):\n"
"    if hasattr(obj, attr):\n"
"        return lambda func: func\n"
"    return unittest.skip(\"{!r} har inte {!r}\".format(obj, attr))"

#: ../../library/unittest.rst:605
msgid ""
"The following decorators and exception implement test skipping and expected "
"failures:"
msgstr ""
"Följande dekoratorer och undantag implementerar testöverhoppning och "
"förväntade fel:"

#: ../../library/unittest.rst:609
msgid ""
"Unconditionally skip the decorated test.  *reason* should describe why the "
"test is being skipped."
msgstr ""
"Hoppa ovillkorligen över det dekorerade testet.  *reason* bör beskriva "
"varför testet hoppas över."

#: ../../library/unittest.rst:614
msgid "Skip the decorated test if *condition* is true."
msgstr "Hoppa över det dekorerade testet om *villkoret* är sant."

#: ../../library/unittest.rst:618
msgid "Skip the decorated test unless *condition* is true."
msgstr "Hoppa över det dekorerade testet om inte *villkoret* är sant."

#: ../../library/unittest.rst:622
msgid ""
"Mark the test as an expected failure or error.  If the test fails or errors "
"in the test function itself (rather than in one of the :dfn:`test fixture` "
"methods) then it will be considered a success.  If the test passes, it will "
"be considered a failure."
msgstr ""
"Markera testet som ett förväntat misslyckande eller fel.  Om testet "
"misslyckas eller fel uppstår i själva testfunktionen (snarare än i någon av "
"metoderna i :dfn:`test fixture`) kommer det att betraktas som en framgång.  "
"Om testet godkänns kommer det att betraktas som ett misslyckande."

#: ../../library/unittest.rst:629
msgid "This exception is raised to skip a test."
msgstr "Detta undantag görs för att hoppa över ett test."

#: ../../library/unittest.rst:631
msgid ""
"Usually you can use :meth:`TestCase.skipTest` or one of the skipping "
"decorators instead of raising this directly."
msgstr ""
"Vanligtvis kan du använda :meth:`TestCase.skipTest` eller någon av "
"dekoratorerna för att hoppa över istället för att ta upp detta direkt."

#: ../../library/unittest.rst:634
msgid ""
"Skipped tests will not have :meth:`~TestCase.setUp` or :meth:`~TestCase."
"tearDown` run around them. Skipped classes will not have :meth:`~TestCase."
"setUpClass` or :meth:`~TestCase.tearDownClass` run. Skipped modules will not "
"have :func:`setUpModule` or :func:`tearDownModule` run."
msgstr ""
"Överhoppade tester kommer inte att ha :meth:`~TestCase.setUp` eller :meth:"
"`~TestCase.tearDown` körda runt dem. Överhoppade klasser kommer inte att ha :"
"meth:`~TestCase.setUpClass` eller :meth:`~TestCase.tearDownClass` körda. "
"Överhoppade moduler kommer inte att få :func:`setUpModule` eller :func:"
"`tearDownModule` körda."

#: ../../library/unittest.rst:642
msgid "Distinguishing test iterations using subtests"
msgstr "Särskiljande av testiterationer med hjälp av deltest"

#: ../../library/unittest.rst:646
msgid ""
"When there are very small differences among your tests, for instance some "
"parameters, unittest allows you to distinguish them inside the body of a "
"test method using the :meth:`~TestCase.subTest` context manager."
msgstr ""
"När det finns mycket små skillnader mellan dina tester, t.ex. några "
"parametrar, kan du med unittest skilja dem åt inuti en testmetod med hjälp "
"av kontexthanteraren :meth:`~TestCase.subTest`."

#: ../../library/unittest.rst:650
msgid "For example, the following test::"
msgstr "Till exempel följande test::"

#: ../../library/unittest.rst:652
msgid ""
"class NumbersTest(unittest.TestCase):\n"
"\n"
"    def test_even(self):\n"
"        \"\"\"\n"
"        Test that numbers between 0 and 5 are all even.\n"
"        \"\"\"\n"
"        for i in range(0, 6):\n"
"            with self.subTest(i=i):\n"
"                self.assertEqual(i % 2, 0)"
msgstr ""
"class NumbersTest(unittest.TestCase):\n"
"\n"
"    def test_even(self):\n"
"        \"\"\"\n"
"        Test that numbers between 0 and 5 are all even.\n"
"        \"\"\"\n"
"        for i in range(0, 6):\n"
"            with self.subTest(i=i):\n"
"                self.assertEqual(i % 2, 0)"

#: ../../library/unittest.rst:662
msgid "will produce the following output::"
msgstr "kommer att ge följande utdata::"

#: ../../library/unittest.rst:664
msgid ""
"======================================================================\n"
"FAIL: test_even (__main__.NumbersTest.test_even) (i=1)\n"
"Test that numbers between 0 and 5 are all even.\n"
"----------------------------------------------------------------------\n"
"Traceback (most recent call last):\n"
"  File \"subtests.py\", line 11, in test_even\n"
"    self.assertEqual(i % 2, 0)\n"
"    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"AssertionError: 1 != 0\n"
"\n"
"======================================================================\n"
"FAIL: test_even (__main__.NumbersTest.test_even) (i=3)\n"
"Test that numbers between 0 and 5 are all even.\n"
"----------------------------------------------------------------------\n"
"Traceback (most recent call last):\n"
"  File \"subtests.py\", line 11, in test_even\n"
"    self.assertEqual(i % 2, 0)\n"
"    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"AssertionError: 1 != 0\n"
"\n"
"======================================================================\n"
"FAIL: test_even (__main__.NumbersTest.test_even) (i=5)\n"
"Test that numbers between 0 and 5 are all even.\n"
"----------------------------------------------------------------------\n"
"Traceback (most recent call last):\n"
"  File \"subtests.py\", line 11, in test_even\n"
"    self.assertEqual(i % 2, 0)\n"
"    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"AssertionError: 1 != 0"
msgstr ""
"======================================================================\n"
"FAIL: test_even (__main__.NumbersTest.test_even) (i=1)\n"
"Testar att alla tal mellan 0 och 5 är jämna.\n"
"----------------------------------------------------------------------\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"subtests.py\", rad 11, i test_even\n"
"    self.assertEqual(i % 2, 0)\n"
"    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"AssertionError: 1 != 0\n"
"\n"
"======================================================================\n"
"FAIL: test_even (__main__.NumbersTest.test_even) (i=3)\n"
"Testar att alla tal mellan 0 och 5 är jämna.\n"
"----------------------------------------------------------------------\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"subtests.py\", rad 11, i test_even\n"
"    self.assertEqual(i % 2, 0)\n"
"    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"AssertionError: 1 != 0\n"
"\n"
"======================================================================\n"
"FAIL: test_even (__main__.NumbersTest.test_even) (i=5)\n"
"Testar att alla tal mellan 0 och 5 är jämna.\n"
"----------------------------------------------------------------------\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"subtests.py\", rad 11, i test_even\n"
"    self.assertEqual(i % 2, 0)\n"
"    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"AssertionError: 1 != 0"

#: ../../library/unittest.rst:694
msgid ""
"Without using a subtest, execution would stop after the first failure, and "
"the error would be less easy to diagnose because the value of ``i`` wouldn't "
"be displayed::"
msgstr ""
"Utan att använda ett deltest skulle exekveringen avbrytas efter det första "
"felet, och felet skulle vara svårare att diagnostisera eftersom värdet på "
"``i`` inte skulle visas::"

#: ../../library/unittest.rst:698
msgid ""
"======================================================================\n"
"FAIL: test_even (__main__.NumbersTest.test_even)\n"
"----------------------------------------------------------------------\n"
"Traceback (most recent call last):\n"
"  File \"subtests.py\", line 32, in test_even\n"
"    self.assertEqual(i % 2, 0)\n"
"AssertionError: 1 != 0"
msgstr ""
"======================================================================\n"
"FAIL: test_even (__main__.NumbersTest.test_even)\n"
"----------------------------------------------------------------------\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"subtests.py\", rad 32, i test_even\n"
"    self.assertEqual(i % 2, 0)\n"
"AssertionError (påståendefel): 1 != 0"

#: ../../library/unittest.rst:710
msgid "Classes and functions"
msgstr "Klasser och funktioner"

#: ../../library/unittest.rst:712
msgid "This section describes in depth the API of :mod:`unittest`."
msgstr ""
"I det här avsnittet beskrivs API:et för :mod:`unittest` på ett djupgående "
"sätt."

#: ../../library/unittest.rst:718
msgid "Test cases"
msgstr "Testfall"

#: ../../library/unittest.rst:722
msgid ""
"Instances of the :class:`TestCase` class represent the logical test units in "
"the :mod:`unittest` universe.  This class is intended to be used as a base "
"class, with specific tests being implemented by concrete subclasses.  This "
"class implements the interface needed by the test runner to allow it to "
"drive the tests, and methods that the test code can use to check for and "
"report various kinds of failure."
msgstr ""
"Instanser av klassen :class:`TestCase` representerar de logiska "
"testenheterna i :mod:`unittest`-universumet.  Den här klassen är avsedd att "
"användas som basklass, där specifika tester implementeras av konkreta "
"underklasser.  Den här klassen implementerar det gränssnitt som testköraren "
"behöver för att kunna köra testerna, och metoder som testkoden kan använda "
"för att kontrollera och rapportera olika typer av fel."

#: ../../library/unittest.rst:729
msgid ""
"Each instance of :class:`TestCase` will run a single base method: the method "
"named *methodName*. In most uses of :class:`TestCase`, you will neither "
"change the *methodName* nor reimplement the default ``runTest()`` method."
msgstr ""
"Varje instans av :class:`TestCase` kommer att köra en enda basmetod: metoden "
"med namnet *methodName*. I de flesta användningar av :class:`TestCase` "
"kommer du varken att ändra *methodName* eller återimplementera "
"standardmetoden ``runTest()``."

#: ../../library/unittest.rst:734
msgid ""
":class:`TestCase` can be instantiated successfully without providing a "
"*methodName*. This makes it easier to experiment with :class:`TestCase` from "
"the interactive interpreter."
msgstr ""
":class:`TestCase` kan instansieras framgångsrikt utan att ange ett "
"*methodName*. Detta gör det lättare att experimentera med :class:`TestCase` "
"från den interaktiva tolken."

#: ../../library/unittest.rst:739
msgid ""
":class:`TestCase` instances provide three groups of methods: one group used "
"to run the test, another used by the test implementation to check conditions "
"and report failures, and some inquiry methods allowing information about the "
"test itself to be gathered."
msgstr ""
":class:`TestCase`-instanser tillhandahåller tre grupper av metoder: en grupp "
"som används för att köra testet, en annan som används av "
"testimplementeringen för att kontrollera villkor och rapportera fel, och "
"några undersökningsmetoder som gör det möjligt att samla in information om "
"själva testet."

#: ../../library/unittest.rst:744
msgid "Methods in the first group (running the test) are:"
msgstr "Metoder i den första gruppen (som kör testet) är:"

#: ../../library/unittest.rst:748
msgid ""
"Method called to prepare the test fixture.  This is called immediately "
"before calling the test method; other than :exc:`AssertionError` or :exc:"
"`SkipTest`, any exception raised by this method will be considered an error "
"rather than a test failure. The default implementation does nothing."
msgstr ""
"Metod som anropas för att förbereda testfixturen.  Den anropas omedelbart "
"innan testmetoden anropas; förutom :exc:`AssertionError` eller :exc:"
"`SkipTest` kommer alla undantag som denna metod ger upphov till att "
"betraktas som fel snarare än som ett misslyckat test. "
"Standardimplementationen gör ingenting."

#: ../../library/unittest.rst:756
msgid ""
"Method called immediately after the test method has been called and the "
"result recorded.  This is called even if the test method raised an "
"exception, so the implementation in subclasses may need to be particularly "
"careful about checking internal state.  Any exception, other than :exc:"
"`AssertionError` or :exc:`SkipTest`, raised by this method will be "
"considered an additional error rather than a test failure (thus increasing "
"the total number of reported errors). This method will only be called if "
"the :meth:`setUp` succeeds, regardless of the outcome of the test method. "
"The default implementation does nothing."
msgstr ""
"Metod som anropas omedelbart efter att testmetoden har anropats och "
"resultatet registrerats.  Denna metod anropas även om testmetoden gav upphov "
"till ett undantag, så implementeringen i underklasser kan behöva vara "
"särskilt noggrann med att kontrollera det interna tillståndet.  Varje "
"undantag, annat än :exc:`AssertionError` eller :exc:`SkipTest`, som anropas "
"av denna metod kommer att betraktas som ett ytterligare fel snarare än ett "
"misslyckat test (vilket ökar det totala antalet rapporterade fel). Denna "
"metod kommer endast att anropas om :meth:`setUp` lyckas, oavsett resultatet "
"av testmetoden. Standardimplementeringen gör ingenting."

#: ../../library/unittest.rst:769
msgid ""
"A class method called before tests in an individual class are run. "
"``setUpClass`` is called with the class as the only argument and must be "
"decorated as a :func:`classmethod`::"
msgstr ""
"En klassmetod som anropas innan tester i en enskild klass körs. "
"``setUpClass`` anropas med klassen som enda argument och måste vara "
"dekorerad som en :func:`classmethod`::"

#: ../../library/unittest.rst:773
msgid ""
"@classmethod\n"
"def setUpClass(cls):\n"
"    ..."
msgstr ""
"@classmethod\n"
"def setUpClass(cls):\n"
"    ..."

#: ../../library/unittest.rst:777 ../../library/unittest.rst:792
msgid "See `Class and Module Fixtures`_ for more details."
msgstr "Se `Klass- och modulfixturer`_ för mer information."

#: ../../library/unittest.rst:784
msgid ""
"A class method called after tests in an individual class have run. "
"``tearDownClass`` is called with the class as the only argument and must be "
"decorated as a :meth:`classmethod`::"
msgstr ""
"En klassmetod som anropas efter att testerna i en enskild klass har körts. "
"``tearDownClass`` anropas med klassen som enda argument och måste vara "
"dekorerad som en :meth:`classmethod`::"

#: ../../library/unittest.rst:788
msgid ""
"@classmethod\n"
"def tearDownClass(cls):\n"
"    ..."
msgstr ""
"@classmethod\n"
"def tearDownClass(cls):\n"
"    ..."

#: ../../library/unittest.rst:799
msgid ""
"Run the test, collecting the result into the :class:`TestResult` object "
"passed as *result*.  If *result* is omitted or ``None``, a temporary result "
"object is created (by calling the :meth:`defaultTestResult` method) and "
"used. The result object is returned to :meth:`run`'s caller."
msgstr ""
"Kör testet och samla in resultatet i :class:`TestResult`-objektet som "
"skickas som *result*.  Om *result* utelämnas eller är ``None`` skapas ett "
"temporärt resultatobjekt (genom att anropa metoden :meth:"
"`defaultTestResult`) och används. Resultatobjektet returneras till :meth:"
"`run`:s anropare."

#: ../../library/unittest.rst:805
msgid ""
"The same effect may be had by simply calling the :class:`TestCase` instance."
msgstr ""
"Samma effekt kan uppnås genom att helt enkelt anropa :class:`TestCase`-"
"instansen."

#: ../../library/unittest.rst:808
msgid ""
"Previous versions of ``run`` did not return the result. Neither did calling "
"an instance."
msgstr ""
"Tidigare versioner av ``run`` returnerade inte resultatet. Inte heller att "
"anropa en instans."

#: ../../library/unittest.rst:814
msgid ""
"Calling this during a test method or :meth:`setUp` skips the current test.  "
"See :ref:`unittest-skipping` for more information."
msgstr ""
"Om du anropar detta under en testmetod eller :meth:`setUp` hoppar du över "
"det aktuella testet.  Se :ref:`unittest-skipping` för mer information."

#: ../../library/unittest.rst:822
msgid ""
"Return a context manager which executes the enclosed code block as a "
"subtest.  *msg* and *params* are optional, arbitrary values which are "
"displayed whenever a subtest fails, allowing you to identify them clearly."
msgstr ""
"Returnerar en kontexthanterare som exekverar det bifogade kodblocket som ett "
"subtest.  *msg* och *params* är valfria, godtyckliga värden som visas när "
"ett deltest misslyckas, vilket gör att du kan identifiera dem tydligt."

#: ../../library/unittest.rst:827
msgid ""
"A test case can contain any number of subtest declarations, and they can be "
"arbitrarily nested."
msgstr ""
"Ett testfall kan innehålla ett obegränsat antal subtestdeklarationer, och de "
"kan vara godtyckligt nästlade."

#: ../../library/unittest.rst:830
msgid "See :ref:`subtests` for more information."
msgstr "Se :ref:`subtests` för mer information."

#: ../../library/unittest.rst:837
msgid ""
"Run the test without collecting the result.  This allows exceptions raised "
"by the test to be propagated to the caller, and can be used to support "
"running tests under a debugger."
msgstr ""
"Kör testet utan att samla in resultatet.  Detta gör att undantag som uppstår "
"i testet kan vidarebefordras till den som anropar och kan användas för att "
"köra tester under en debugger."

#: ../../library/unittest.rst:843
msgid ""
"The :class:`TestCase` class provides several assert methods to check for and "
"report failures.  The following table lists the most commonly used methods "
"(see the tables below for more assert methods):"
msgstr ""
"Klassen :class:`TestCase` innehåller flera assert-metoder för att "
"kontrollera och rapportera fel.  I följande tabell listas de vanligaste "
"metoderna (se tabellerna nedan för fler assert-metoder):"

#: ../../library/unittest.rst:848 ../../library/unittest.rst:984
#: ../../library/unittest.rst:1198 ../../library/unittest.rst:1368
msgid "Method"
msgstr "Metod"

#: ../../library/unittest.rst:848 ../../library/unittest.rst:984
#: ../../library/unittest.rst:1198
msgid "Checks that"
msgstr "Kontrollerar att"

#: ../../library/unittest.rst:848 ../../library/unittest.rst:984
#: ../../library/unittest.rst:1198 ../../library/unittest.rst:1368
msgid "New in"
msgstr "Ny i"

#: ../../library/unittest.rst:850
msgid ":meth:`assertEqual(a, b) <TestCase.assertEqual>`"
msgstr ":meth:`assertEqual(a, b) <TestCase.assertEqual>`"

#: ../../library/unittest.rst:850
msgid "``a == b``"
msgstr "``a == b```"

#: ../../library/unittest.rst:853
msgid ":meth:`assertNotEqual(a, b) <TestCase.assertNotEqual>`"
msgstr ":meth:`assertNotEqual(a, b) <TestCase.assertNotEqual>`"

#: ../../library/unittest.rst:853
msgid "``a != b``"
msgstr "``a != b``"

#: ../../library/unittest.rst:856
msgid ":meth:`assertTrue(x) <TestCase.assertTrue>`"
msgstr ":meth:`assertTrue(x) <TestCase.assertTrue>`"

#: ../../library/unittest.rst:856
msgid "``bool(x) is True``"
msgstr "``bool(x) is True``"

#: ../../library/unittest.rst:859
msgid ":meth:`assertFalse(x) <TestCase.assertFalse>`"
msgstr ":meth:`assertFalse(x) <TestCase.assertFalse>`"

#: ../../library/unittest.rst:859
msgid "``bool(x) is False``"
msgstr "``bool(x) is False``"

#: ../../library/unittest.rst:862
msgid ":meth:`assertIs(a, b) <TestCase.assertIs>`"
msgstr ":meth:`assertIs(a, b) <TestCase.assertIs>`"

#: ../../library/unittest.rst:862
msgid "``a is b``"
msgstr "``a is b``"

#: ../../library/unittest.rst:862 ../../library/unittest.rst:865
#: ../../library/unittest.rst:868 ../../library/unittest.rst:871
#: ../../library/unittest.rst:874 ../../library/unittest.rst:877
#: ../../library/unittest.rst:989 ../../library/unittest.rst:1206
#: ../../library/unittest.rst:1209 ../../library/unittest.rst:1212
#: ../../library/unittest.rst:1215 ../../library/unittest.rst:1218
#: ../../library/unittest.rst:1370 ../../library/unittest.rst:1373
#: ../../library/unittest.rst:1376 ../../library/unittest.rst:1379
#: ../../library/unittest.rst:1382 ../../library/unittest.rst:1385
msgid "3.1"
msgstr "3.1"

#: ../../library/unittest.rst:865
msgid ":meth:`assertIsNot(a, b) <TestCase.assertIsNot>`"
msgstr ":meth:`assertIsNot(a, b) <TestCase.assertIsNot>`"

#: ../../library/unittest.rst:865
msgid "``a is not b``"
msgstr "``a is not b``"

#: ../../library/unittest.rst:868
msgid ":meth:`assertIsNone(x) <TestCase.assertIsNone>`"
msgstr ":meth:`assertIsNone(x) <TestCase.assertIsNone>`"

#: ../../library/unittest.rst:868
msgid "``x is None``"
msgstr "``x is None``"

#: ../../library/unittest.rst:871
msgid ":meth:`assertIsNotNone(x) <TestCase.assertIsNotNone>`"
msgstr ":meth:`assertIsNotNone(x) <TestCase.assertIsNotNone>`"

#: ../../library/unittest.rst:871
msgid "``x is not None``"
msgstr "``x is not None``"

#: ../../library/unittest.rst:874
msgid ":meth:`assertIn(a, b) <TestCase.assertIn>`"
msgstr ":meth:`assertIn(a, b) <TestCase.assertIn>`"

#: ../../library/unittest.rst:874
msgid "``a in b``"
msgstr "``a in b``"

#: ../../library/unittest.rst:877
msgid ":meth:`assertNotIn(a, b) <TestCase.assertNotIn>`"
msgstr ":meth:`assertNotIn(a, b) <TestCase.assertNotIn>`"

#: ../../library/unittest.rst:877
msgid "``a not in b``"
msgstr "``a not in b``"

#: ../../library/unittest.rst:880
msgid ":meth:`assertIsInstance(a, b) <TestCase.assertIsInstance>`"
msgstr ":meth:`assertIsInstance(a, b) <TestCase.assertIsInstance>`"

#: ../../library/unittest.rst:880
msgid "``isinstance(a, b)``"
msgstr "``isinstance(a, b)``"

#: ../../library/unittest.rst:880 ../../library/unittest.rst:883
#: ../../library/unittest.rst:992 ../../library/unittest.rst:995
#: ../../library/unittest.rst:1221 ../../library/unittest.rst:1224
msgid "3.2"
msgstr "3.2"

#: ../../library/unittest.rst:883
msgid ":meth:`assertNotIsInstance(a, b) <TestCase.assertNotIsInstance>`"
msgstr ":meth:`assertNotIsInstance(a, b) <TestCase.assertNotIsInstance>`"

#: ../../library/unittest.rst:883
msgid "``not isinstance(a, b)``"
msgstr "``not isinstance(a, b)``"

#: ../../library/unittest.rst:886
msgid ":meth:`assertIsSubclass(a, b) <TestCase.assertIsSubclass>`"
msgstr ":meth:`assertIsSubclass(a, b) <TestCase.assertIsSubclass>`"

#: ../../library/unittest.rst:886
msgid "``issubclass(a, b)``"
msgstr "``issubclass(a, b)``"

#: ../../library/unittest.rst:886 ../../library/unittest.rst:889
#: ../../library/unittest.rst:1228 ../../library/unittest.rst:1231
#: ../../library/unittest.rst:1234 ../../library/unittest.rst:1237
#: ../../library/unittest.rst:1240 ../../library/unittest.rst:1243
msgid "3.14"
msgstr "3.14"

#: ../../library/unittest.rst:889
msgid ":meth:`assertNotIsSubclass(a, b) <TestCase.assertNotIsSubclass>`"
msgstr ":meth:`assertNotIsSubclass(a, b) <TestCase.assertNotIsSubclass>`"

#: ../../library/unittest.rst:889
msgid "``not issubclass(a, b)``"
msgstr "``not issubclass(a, b)``"

#: ../../library/unittest.rst:893
msgid ""
"All the assert methods accept a *msg* argument that, if specified, is used "
"as the error message on failure (see also :data:`longMessage`). Note that "
"the *msg* keyword argument can be passed to :meth:`assertRaises`, :meth:"
"`assertRaisesRegex`, :meth:`assertWarns`, :meth:`assertWarnsRegex` only when "
"they are used as a context manager."
msgstr ""
"Alla assert-metoder accepterar ett *msg*-argument som, om det anges, används "
"som felmeddelande vid misslyckande (se även :data:`longMessage`). Observera "
"att nyckelordsargumentet *msg* endast kan skickas till :meth:"
"`assertRaises`, :meth:`assertRaisesRegex`, :meth:`assertWarns`, :meth:"
"`assertWarnsRegex` när de används som kontexthanterare."

#: ../../library/unittest.rst:901
msgid ""
"Test that *first* and *second* are equal.  If the values do not compare "
"equal, the test will fail."
msgstr ""
"Testa att *first* och *second* är lika stora.  Om värdena inte jämförs lika "
"kommer testet att misslyckas."

#: ../../library/unittest.rst:904
msgid ""
"In addition, if *first* and *second* are the exact same type and one of "
"list, tuple, dict, set, frozenset or str or any type that a subclass "
"registers with :meth:`addTypeEqualityFunc` the type-specific equality "
"function will be called in order to generate a more useful default error "
"message (see also the :ref:`list of type-specific methods <type-specific-"
"methods>`)."
msgstr ""
"Dessutom, om *first* och *second* är exakt samma typ och en av list, tuple, "
"dict, set, frozenset eller str eller någon typ som en underklass registrerar "
"med :meth:`addTypeEqualityFunc` kommer den typspecifika likhetsfunktionen "
"att anropas för att generera ett mer användbart standardfelmeddelande (se "
"även :ref:`list of type-specific methods <type-specific-methods>`)."

#: ../../library/unittest.rst:911
msgid "Added the automatic calling of type-specific equality function."
msgstr "Lagt till automatisk anrop av typspecifik likhetsfunktion."

#: ../../library/unittest.rst:914
msgid ""
":meth:`assertMultiLineEqual` added as the default type equality function for "
"comparing strings."
msgstr ""
":meth:`assertMultiLineEqual` tillagd som standardfunktion för typjämförelse "
"för jämförelse av strängar."

#: ../../library/unittest.rst:921
msgid ""
"Test that *first* and *second* are not equal.  If the values do compare "
"equal, the test will fail."
msgstr ""
"Testa att *first* och *second* inte är lika.  Om värdena är lika med "
"varandra kommer testet att misslyckas."

#: ../../library/unittest.rst:927
msgid "Test that *expr* is true (or false)."
msgstr "Testa att *expr* är sant (eller falskt)."

#: ../../library/unittest.rst:929
msgid ""
"Note that this is equivalent to ``bool(expr) is True`` and not to ``expr is "
"True`` (use ``assertIs(expr, True)`` for the latter).  This method should "
"also be avoided when more specific methods are available (e.g. "
"``assertEqual(a, b)`` instead of ``assertTrue(a == b)``), because they "
"provide a better error message in case of failure."
msgstr ""
"Observera att detta är likvärdigt med ``bool(expr) is True`` och inte med "
"``expr is True`` (använd ``assertIs(expr, True)`` för det senare).  Denna "
"metod bör också undvikas när mer specifika metoder finns tillgängliga (t.ex. "
"``assertEqual(a, b)`` istället för ``assertTrue(a == b)``), eftersom de ger "
"ett bättre felmeddelande vid fel."

#: ../../library/unittest.rst:939
msgid "Test that *first* and *second* are (or are not) the same object."
msgstr "Testa att *first* och *second* är (eller inte är) samma objekt."

#: ../../library/unittest.rst:947
msgid "Test that *expr* is (or is not) ``None``."
msgstr "Testa att *expr* är (eller inte är) ``None``."

#: ../../library/unittest.rst:955
msgid "Test that *member* is (or is not) in *container*."
msgstr "Testa att *member* är (eller inte är) i *container*."

#: ../../library/unittest.rst:963
msgid ""
"Test that *obj* is (or is not) an instance of *cls* (which can be a class or "
"a tuple of classes, as supported by :func:`isinstance`). To check for the "
"exact type, use :func:`assertIs(type(obj), cls) <assertIs>`."
msgstr ""
"Testa att *obj* är (eller inte är) en instans av *cls* (som kan vara en "
"klass eller en tupel av klasser, vilket stöds av :func:`isinstance`). För "
"att kontrollera den exakta typen, använd :func:`assertIs(type(obj), cls) "
"<assertIs>`."

#: ../../library/unittest.rst:973
msgid ""
"Test that *cls* is (or is not) a subclass of *superclass* (which can be a "
"class or a tuple of classes, as supported by :func:`issubclass`). To check "
"for the exact type, use :func:`assertIs(cls, superclass) <assertIs>`."
msgstr ""
"Testa att *cls* är (eller inte är) en underklass till *superclass* (som kan "
"vara en klass eller en tupel av klasser, vilket stöds av :func:"
"`issubclass`). För att kontrollera den exakta typen, använd :func:"
"`assertIs(cls, superclass) <assertIs>`."

#: ../../library/unittest.rst:980
msgid ""
"It is also possible to check the production of exceptions, warnings, and log "
"messages using the following methods:"
msgstr ""
"Det är också möjligt att kontrollera produktionen av undantag, varningar och "
"loggmeddelanden med hjälp av följande metoder:"

#: ../../library/unittest.rst:986
msgid ":meth:`assertRaises(exc, fun, *args, **kwds) <TestCase.assertRaises>`"
msgstr ":meth:`assertRaises(exc, fun, *args, **kwds) <TestCase.assertRaises>`"

#: ../../library/unittest.rst:986
msgid "``fun(*args, **kwds)`` raises *exc*"
msgstr "``fun(*args, **kwds)`` ger upphov till *exc*"

#: ../../library/unittest.rst:989
msgid ""
":meth:`assertRaisesRegex(exc, r, fun, *args, **kwds) <TestCase."
"assertRaisesRegex>`"
msgstr ""
":meth:`assertRaisesRegex(exc, r, fun, *args, **kwds) <TestCase."
"assertRaisesRegex>`"

#: ../../library/unittest.rst:989
msgid "``fun(*args, **kwds)`` raises *exc* and the message matches regex *r*"
msgstr ""
"``fun(*args, **kwds)``` ger upphov till *exc* och meddelandet matchar regex "
"*r*"

#: ../../library/unittest.rst:992
msgid ":meth:`assertWarns(warn, fun, *args, **kwds) <TestCase.assertWarns>`"
msgstr ":meth:`assertWarns(warn, fun, *args, **kwds) <TestCase.assertWarns>`"

#: ../../library/unittest.rst:992
msgid "``fun(*args, **kwds)`` raises *warn*"
msgstr "``fun(*args, **kwds)`` ger upphov till *varning*"

#: ../../library/unittest.rst:995
msgid ""
":meth:`assertWarnsRegex(warn, r, fun, *args, **kwds) <TestCase."
"assertWarnsRegex>`"
msgstr ""
":meth:`assertWarnsRegex(warn, r, fun, *args, **kwds) <TestCase."
"assertWarnsRegex>`"

#: ../../library/unittest.rst:995
msgid "``fun(*args, **kwds)`` raises *warn* and the message matches regex *r*"
msgstr ""
"``fun(*args, **kwds)`` ger upphov till *warn* och meddelandet matchar regex "
"*r*"

#: ../../library/unittest.rst:998
msgid ":meth:`assertLogs(logger, level) <TestCase.assertLogs>`"
msgstr ":meth:`assertLogs(logger, level) <TestCase.assertLogs>`"

#: ../../library/unittest.rst:998
msgid "The ``with`` block logs on *logger* with minimum *level*"
msgstr "Blocket ``with`` loggar på *logger* med lägsta *nivå*"

#: ../../library/unittest.rst:998
msgid "3.4"
msgstr "3.4"

#: ../../library/unittest.rst:1001
msgid ":meth:`assertNoLogs(logger, level) <TestCase.assertNoLogs>`"
msgstr ":meth:`assertNoLogs(logger, level) <TestCase.assertNoLogs>`"

#: ../../library/unittest.rst:1001
msgid "The ``with`` block does not log on"
msgstr "Blocket ``with`` loggar inte in"

#: ../../library/unittest.rst:1002
msgid "*logger* with minimum *level*"
msgstr "*logger* med lägsta *nivå*"

#: ../../library/unittest.rst:1001
msgid "3.10"
msgstr "3.10"

#: ../../library/unittest.rst:1008
msgid ""
"Test that an exception is raised when *callable* is called with any "
"positional or keyword arguments that are also passed to :meth:"
"`assertRaises`.  The test passes if *exception* is raised, is an error if "
"another exception is raised, or fails if no exception is raised. To catch "
"any of a group of exceptions, a tuple containing the exception classes may "
"be passed as *exception*."
msgstr ""
"Testar att ett undantag utlöses när *callable* anropas med eventuella "
"positionella eller nyckelordsargument som också skickas till :meth:"
"`assertRaises`.  Testet godkänns om *exception* utlöses, är ett fel om ett "
"annat undantag utlöses eller misslyckas om inget undantag utlöses. För att "
"fånga upp något av en grupp undantag kan en tupel som innehåller "
"undantagsklasserna skickas som *exception*."

#: ../../library/unittest.rst:1015
msgid ""
"If only the *exception* and possibly the *msg* arguments are given, return a "
"context manager so that the code under test can be written inline rather "
"than as a function::"
msgstr ""
"Om endast argumenten *exception* och eventuellt *msg* anges, returneras en "
"kontexthanterare så att koden som testas kan skrivas inline i stället för "
"som en funktion::"

#: ../../library/unittest.rst:1019
msgid ""
"with self.assertRaises(SomeException):\n"
"    do_something()"
msgstr ""
"with self.assertRaises(SomeException):\n"
"    do_something()"

#: ../../library/unittest.rst:1022
msgid ""
"When used as a context manager, :meth:`assertRaises` accepts the additional "
"keyword argument *msg*."
msgstr ""
"När den används som kontexthanterare accepterar :meth:`assertRaises` det "
"extra nyckelordsargumentet *msg*."

#: ../../library/unittest.rst:1025
msgid ""
"The context manager will store the caught exception object in its :attr:"
"`exception` attribute.  This can be useful if the intention is to perform "
"additional checks on the exception raised::"
msgstr ""
"Kontexthanteraren lagrar det fångade undantagsobjektet i dess :attr:"
"`exception`-attribut.  Detta kan vara användbart om avsikten är att utföra "
"ytterligare kontroller på det undantag som uppstått:"

#: ../../library/unittest.rst:1029
msgid ""
"with self.assertRaises(SomeException) as cm:\n"
"    do_something()\n"
"\n"
"the_exception = cm.exception\n"
"self.assertEqual(the_exception.error_code, 3)"
msgstr ""
"med self.assertRaises(SomeException) som cm:\n"
"    gör_något()\n"
"\n"
"the_exception = cm.undantag\n"
"self.assertEqual(the_exception.error_code, 3)"

#: ../../library/unittest.rst:1035
msgid "Added the ability to use :meth:`assertRaises` as a context manager."
msgstr ""
"Lagt till möjligheten att använda :meth:`assertRaises` som en "
"kontexthanterare."

#: ../../library/unittest.rst:1038
msgid "Added the :attr:`exception` attribute."
msgstr "Lagt till attributet :attr:`exception`."

#: ../../library/unittest.rst:1041 ../../library/unittest.rst:1067
#: ../../library/unittest.rst:1108 ../../library/unittest.rst:1131
msgid "Added the *msg* keyword argument when used as a context manager."
msgstr ""
"Lagt till nyckelordsargumentet *msg* när det används som en kontexthanterare."

#: ../../library/unittest.rst:1048
msgid ""
"Like :meth:`assertRaises` but also tests that *regex* matches on the string "
"representation of the raised exception.  *regex* may be a regular expression "
"object or a string containing a regular expression suitable for use by :func:"
"`re.search`.  Examples::"
msgstr ""
"Som :meth:`assertRaises` men testar också att *regex* matchar "
"strängrepresentationen av det undantag som uppstod.  *regex* kan vara ett "
"objekt för reguljära uttryck eller en sträng som innehåller ett reguljärt "
"uttryck som är lämpligt för användning av :func:`re.search`.  Exempel::"

#: ../../library/unittest.rst:1053
msgid ""
"self.assertRaisesRegex(ValueError, \"invalid literal for.*XYZ'$\",\n"
"                       int, 'XYZ')"
msgstr ""
"self.assertRaisesRegex(ValueError,\"ogiltig bokstav för.*XYZ'$\",\n"
"                       int, 'XYZ')"

#: ../../library/unittest.rst:1056 ../../library/unittest.rst:1124
msgid "or::"
msgstr "eller::"

#: ../../library/unittest.rst:1058
msgid ""
"with self.assertRaisesRegex(ValueError, 'literal'):\n"
"   int('XYZ')"
msgstr ""
"med self.assertRaisesRegex(ValueError, 'literal'):\n"
"   int('XYZ')"

#: ../../library/unittest.rst:1061
msgid "Added under the name ``assertRaisesRegexp``."
msgstr "Tillagd under namnet ``assertRaisesRegexp``."

#: ../../library/unittest.rst:1064
msgid "Renamed to :meth:`assertRaisesRegex`."
msgstr "Omdöpta till :meth:`assertRaisesRegex`."

#: ../../library/unittest.rst:1074
msgid ""
"Test that a warning is triggered when *callable* is called with any "
"positional or keyword arguments that are also passed to :meth:"
"`assertWarns`.  The test passes if *warning* is triggered and fails if it "
"isn't.  Any exception is an error. To catch any of a group of warnings, a "
"tuple containing the warning classes may be passed as *warnings*."
msgstr ""
"Testar att en varning utlöses när *callable* anropas med positionella eller "
"nyckelordsargument som också skickas till :meth:`assertWarns`.  Testet "
"godkänns om *warning* utlöses och misslyckas om så inte är fallet.  Varje "
"undantag är ett fel. För att fånga någon av en grupp varningar kan en tupel "
"som innehåller varningsklasserna skickas som *warnings*."

#: ../../library/unittest.rst:1081
msgid ""
"If only the *warning* and possibly the *msg* arguments are given, return a "
"context manager so that the code under test can be written inline rather "
"than as a function::"
msgstr ""
"Om endast argumenten *warning* och eventuellt *msg* anges, returneras en "
"kontexthanterare så att koden som testas kan skrivas inline i stället för "
"som en funktion::"

#: ../../library/unittest.rst:1085
msgid ""
"with self.assertWarns(SomeWarning):\n"
"    do_something()"
msgstr ""
"with self.assertWarns(SomeWarning):\n"
"    do_something()"

#: ../../library/unittest.rst:1088
msgid ""
"When used as a context manager, :meth:`assertWarns` accepts the additional "
"keyword argument *msg*."
msgstr ""
"När :meth:`assertWarns` används som en kontexthanterare accepteras det extra "
"nyckelordsargumentet *msg*."

#: ../../library/unittest.rst:1091
msgid ""
"The context manager will store the caught warning object in its :attr:"
"`warning` attribute, and the source line which triggered the warnings in "
"the :attr:`filename` and :attr:`lineno` attributes. This can be useful if "
"the intention is to perform additional checks on the warning caught::"
msgstr ""
"Kontexthanteraren lagrar det fångade varningsobjektet i attributet :attr:"
"`warning` och källraden som utlöste varningarna i attributen :attr:"
"`filename` och :attr:`lineno`. Detta kan vara användbart om avsikten är att "
"utföra ytterligare kontroller på den fångade varningen:"

#: ../../library/unittest.rst:1097
msgid ""
"with self.assertWarns(SomeWarning) as cm:\n"
"    do_something()\n"
"\n"
"self.assertIn('myfile.py', cm.filename)\n"
"self.assertEqual(320, cm.lineno)"
msgstr ""
"with self.assertWarns(SomeWarning) as cm:\n"
"    do_something()\n"
"\n"
"self.assertIn('myfile.py', cm.filename)\n"
"self.assertEqual(320, cm.lineno)"

#: ../../library/unittest.rst:1103
msgid ""
"This method works regardless of the warning filters in place when it is "
"called."
msgstr ""
"Denna metod fungerar oavsett vilka varningsfilter som finns på plats när den "
"anropas."

#: ../../library/unittest.rst:1115
msgid ""
"Like :meth:`assertWarns` but also tests that *regex* matches on the message "
"of the triggered warning.  *regex* may be a regular expression object or a "
"string containing a regular expression suitable for use by :func:`re."
"search`.  Example::"
msgstr ""
"Som :meth:`assertWarns` men testar också att *regex* matchar meddelandet i "
"den utlösta varningen.  *regex* kan vara ett objekt för reguljära uttryck "
"eller en sträng som innehåller ett reguljärt uttryck som är lämpligt för "
"användning av :func:`re.search`.  Exempel::"

#: ../../library/unittest.rst:1120
msgid ""
"self.assertWarnsRegex(DeprecationWarning,\n"
"                      r'legacy_function\\(\\) is deprecated',\n"
"                      legacy_function, 'XYZ')"
msgstr ""
"self.assertWarnsRegex(DeprecationWarning,\n"
"                      r'legacy_function\\(\\) is deprecated',\n"
"                      legacy_function, 'XYZ')"

#: ../../library/unittest.rst:1126
msgid ""
"with self.assertWarnsRegex(RuntimeWarning, 'unsafe frobnicating'):\n"
"    frobnicate('/etc/passwd')"
msgstr ""
"with self.assertWarnsRegex(RuntimeWarning, 'unsafe frobnicating'):\n"
"    frobnicate('/etc/passwd')"

#: ../../library/unittest.rst:1136
msgid ""
"A context manager to test that at least one message is logged on the "
"*logger* or one of its children, with at least the given *level*."
msgstr ""
"En kontexthanterare som testar att minst ett meddelande loggas på *logger* "
"eller ett av dess barn, med minst den angivna *level*."

#: ../../library/unittest.rst:1140
msgid ""
"If given, *logger* should be a :class:`logging.Logger` object or a :class:"
"`str` giving the name of a logger.  The default is the root logger, which "
"will catch all messages that were not blocked by a non-propagating "
"descendent logger."
msgstr ""
"Om *logger* anges ska det vara ett :class:`logging.Logger'-objekt eller ett :"
"class:`str` som anger namnet på en logger.  Standard är rotloggern, som "
"fångar upp alla meddelanden som inte blockerats av en icke-spridande logger "
"i nedstigande led."

#: ../../library/unittest.rst:1145 ../../library/unittest.rst:1186
msgid ""
"If given, *level* should be either a numeric logging level or its string "
"equivalent (for example either ``\"ERROR\"`` or :const:`logging.ERROR`).  "
"The default is :const:`logging.INFO`."
msgstr ""
"Om *level* anges ska det vara antingen en numerisk loggningsnivå eller dess "
"strängmotsvarighet (t.ex. antingen ``\"ERROR\"`` eller :const:`logging."
"ERROR`).  Standardvärdet är :const:`logging.INFO`."

#: ../../library/unittest.rst:1149
msgid ""
"The test passes if at least one message emitted inside the ``with`` block "
"matches the *logger* and *level* conditions, otherwise it fails."
msgstr ""
"Testet godkänns om minst ett meddelande som sänds ut i ``with``-blocket "
"uppfyller villkoren *logger* och *level*, annars misslyckas det."

#: ../../library/unittest.rst:1152
msgid ""
"The object returned by the context manager is a recording helper which keeps "
"tracks of the matching log messages.  It has two attributes:"
msgstr ""
"Objektet som returneras av kontexthanteraren är en inspelningshjälp som "
"håller reda på de matchande loggmeddelandena.  Det har två attribut:"

#: ../../library/unittest.rst:1158
msgid ""
"A list of :class:`logging.LogRecord` objects of the matching log messages."
msgstr ""
"En lista med :class:`logging.LogRecord`-objekt för de matchande "
"loggmeddelandena."

#: ../../library/unittest.rst:1163
msgid ""
"A list of :class:`str` objects with the formatted output of matching "
"messages."
msgstr ""
"En lista med :class:`str`-objekt med formaterade utdata från matchande "
"meddelanden."

#: ../../library/unittest.rst:1166
msgid "Example::"
msgstr "Exempel::"

#: ../../library/unittest.rst:1168
msgid ""
"with self.assertLogs('foo', level='INFO') as cm:\n"
"    logging.getLogger('foo').info('first message')\n"
"    logging.getLogger('foo.bar').error('second message')\n"
"self.assertEqual(cm.output, ['INFO:foo:first message',\n"
"                             'ERROR:foo.bar:second message'])"
msgstr ""
"med self.assertLogs('foo', level='INFO') som cm:\n"
"    logging.getLogger('foo').info('första meddelandet')\n"
"    logging.getLogger('foo.bar').error('andra meddelandet')\n"
"self.assertEqual(cm.output, ['INFO:foo:första meddelandet',\n"
"                             'ERROR:foo.bar:andra meddelandet'])"

#: ../../library/unittest.rst:1178
msgid ""
"A context manager to test that no messages are logged on the *logger* or one "
"of its children, with at least the given *level*."
msgstr ""
"En kontexthanterare som testar att inga meddelanden loggas på *logger* eller "
"ett av dess underordnade objekt, med minst den angivna *level*."

#: ../../library/unittest.rst:1182
msgid ""
"If given, *logger* should be a :class:`logging.Logger` object or a :class:"
"`str` giving the name of a logger.  The default is the root logger, which "
"will catch all messages."
msgstr ""
"Om *logger* anges ska det vara ett :class:`logging.Logger'-objekt eller ett :"
"class:`str` som anger namnet på en logger.  Standard är rotloggaren, som "
"fångar upp alla meddelanden."

#: ../../library/unittest.rst:1190
msgid ""
"Unlike :meth:`assertLogs`, nothing will be returned by the context manager."
msgstr ""
"Till skillnad från :meth:`assertLogs` kommer inget att returneras av "
"kontexthanteraren."

#: ../../library/unittest.rst:1195
msgid ""
"There are also other methods used to perform more specific checks, such as:"
msgstr ""
"Det finns också andra metoder som används för att utföra mer specifika "
"kontroller, t.ex:"

#: ../../library/unittest.rst:1200
msgid ":meth:`assertAlmostEqual(a, b) <TestCase.assertAlmostEqual>`"
msgstr ":meth:`assertAlmostEqual(a, b) <TestCase.assertAlmostEqual>`"

#: ../../library/unittest.rst:1200
msgid "``round(a-b, 7) == 0``"
msgstr "``round(a-b, 7) == 0``"

#: ../../library/unittest.rst:1203
msgid ":meth:`assertNotAlmostEqual(a, b) <TestCase.assertNotAlmostEqual>`"
msgstr ":meth:`assertNotAlmostEqual(a, b) <TestCase.assertNotAlmostEqual>`"

#: ../../library/unittest.rst:1203
msgid "``round(a-b, 7) != 0``"
msgstr "``round(a-b, 7) != 0``"

#: ../../library/unittest.rst:1206
msgid ":meth:`assertGreater(a, b) <TestCase.assertGreater>`"
msgstr ":meth:`assertGreater(a, b) <TestCase.assertGreater>`"

#: ../../library/unittest.rst:1206
msgid "``a > b``"
msgstr "``a > b``"

#: ../../library/unittest.rst:1209
msgid ":meth:`assertGreaterEqual(a, b) <TestCase.assertGreaterEqual>`"
msgstr ":meth:`assertGreaterEqual(a, b) <TestCase.assertGreaterEqual>`"

#: ../../library/unittest.rst:1209
msgid "``a >= b``"
msgstr "``a >= b```"

#: ../../library/unittest.rst:1212
msgid ":meth:`assertLess(a, b) <TestCase.assertLess>`"
msgstr ":meth:`assertLess(a, b) <TestCase.assertLess>`"

#: ../../library/unittest.rst:1212
msgid "``a < b``"
msgstr "``a < b```"

#: ../../library/unittest.rst:1215
msgid ":meth:`assertLessEqual(a, b) <TestCase.assertLessEqual>`"
msgstr ":meth:`assertLessEqual(a, b) <TestCase.assertLessEqual>`"

#: ../../library/unittest.rst:1215
msgid "``a <= b``"
msgstr "``a <= b```"

#: ../../library/unittest.rst:1218
msgid ":meth:`assertRegex(s, r) <TestCase.assertRegex>`"
msgstr ":meth:`assertRegex(s, r) <TestCase.assertRegex>`"

#: ../../library/unittest.rst:1218
msgid "``r.search(s)``"
msgstr "``r.sök(s)```"

#: ../../library/unittest.rst:1221
msgid ":meth:`assertNotRegex(s, r) <TestCase.assertNotRegex>`"
msgstr ":meth:`assertNotRegex(s, r) <TestCase.assertNotRegex>`"

#: ../../library/unittest.rst:1221
msgid "``not r.search(s)``"
msgstr "``inte r.sök(s)``"

#: ../../library/unittest.rst:1224
msgid ":meth:`assertCountEqual(a, b) <TestCase.assertCountEqual>`"
msgstr ":meth:`assertCountEqual(a, b) <TestCase.assertCountEqual>`"

#: ../../library/unittest.rst:1224
msgid ""
"*a* and *b* have the same elements in the same number, regardless of their "
"order."
msgstr ""
"*a* och *b* har samma element i samma antal, oberoende av deras ordning."

#: ../../library/unittest.rst:1228
msgid ":meth:`assertStartsWith(a, b) <TestCase.assertStartsWith>`"
msgstr ":meth:`assertStartsWith(a, b) <TestCase.assertStartsWith>`"

#: ../../library/unittest.rst:1228
msgid "``a.startswith(b)``"
msgstr "``a.startswith(b)``"

#: ../../library/unittest.rst:1231
msgid ":meth:`assertNotStartsWith(a, b) <TestCase.assertNotStartsWith>`"
msgstr ":meth:`assertNotStartsWith(a, b) <TestCase.assertNotStartsWith>`"

#: ../../library/unittest.rst:1231
msgid "``not a.startswith(b)``"
msgstr "``not a.startswith(b)``"

#: ../../library/unittest.rst:1234
msgid ":meth:`assertEndsWith(a, b) <TestCase.assertEndsWith>`"
msgstr ":meth:`assertEndsWith(a, b) <TestCase.assertEndsWith>`"

#: ../../library/unittest.rst:1234
msgid "``a.endswith(b)``"
msgstr "``a.endswith(b)``"

#: ../../library/unittest.rst:1237
msgid ":meth:`assertNotEndsWith(a, b) <TestCase.assertNotEndsWith>`"
msgstr ":meth:`assertNotEndsWith(a, b) <TestCase.assertNotEndsWith>`"

#: ../../library/unittest.rst:1237
msgid "``not a.endswith(b)``"
msgstr "``not a.endswith(b)``"

#: ../../library/unittest.rst:1240
msgid ":meth:`assertHasAttr(a, b) <TestCase.assertHasAttr>`"
msgstr ":meth:`assertHasAttr(a, b) <TestCase.assertHasAttr>`"

#: ../../library/unittest.rst:1240
msgid "``hastattr(a, b)``"
msgstr "``hastattr(a, b)``"

#: ../../library/unittest.rst:1243
msgid ":meth:`assertNotHasAttr(a, b) <TestCase.assertNotHasAttr>`"
msgstr ":meth:`assertNotHasAttr(a, b) <TestCase.assertNotHasAttr>`"

#: ../../library/unittest.rst:1243
msgid "``not hastattr(a, b)``"
msgstr "``not hastattr(a, b)``"

#: ../../library/unittest.rst:1251
msgid ""
"Test that *first* and *second* are approximately (or not approximately) "
"equal by computing the difference, rounding to the given number of decimal "
"*places* (default 7), and comparing to zero.  Note that these methods round "
"the values to the given number of *decimal places* (i.e. like the :func:"
"`round` function) and not *significant digits*."
msgstr ""
"Testa att *first* och *second* är ungefär (eller inte ungefär) lika genom "
"att beräkna skillnaden, avrunda till det angivna antalet decimaler (standard "
"7) och jämföra med noll.  Observera att dessa metoder avrundar värdena till "
"det angivna antalet *decimaler* (dvs. som funktionen :func:`round`) och inte "
"till *signifikanta siffror*."

#: ../../library/unittest.rst:1257
msgid ""
"If *delta* is supplied instead of *places* then the difference between "
"*first* and *second* must be less or equal to (or greater than) *delta*."
msgstr ""
"Om *delta* anges i stället för *places* måste skillnaden mellan *first* och "
"*second* vara mindre eller lika med (eller större än) *delta*."

#: ../../library/unittest.rst:1260
msgid "Supplying both *delta* and *places* raises a :exc:`TypeError`."
msgstr ""
"Att ange både *delta* och *places* ger upphov till ett :exc:`TypeError`."

#: ../../library/unittest.rst:1262
msgid ""
":meth:`assertAlmostEqual` automatically considers almost equal objects that "
"compare equal.  :meth:`assertNotAlmostEqual` automatically fails if the "
"objects compare equal.  Added the *delta* keyword argument."
msgstr ""
":meth:`assertAlmostEqual` betraktar automatiskt nästan lika objekt som "
"jämför lika. :meth:`assertNotAlmostEqual` misslyckas automatiskt om objekten "
"jämför lika.  Lade till nyckelordsargumentet *delta*."

#: ../../library/unittest.rst:1273
msgid ""
"Test that *first* is respectively >, >=, < or <= than *second* depending on "
"the method name.  If not, the test will fail::"
msgstr ""
"Testar att *first* är >, >=, < eller <= än *second* beroende på "
"metodnamnet.  Om inte, kommer testet att misslyckas::"

#: ../../library/unittest.rst:1276
msgid ""
">>> self.assertGreaterEqual(3, 4)\n"
"AssertionError: \"3\" unexpectedly not greater than or equal to \"4\""
msgstr ""
">>> self.assertGreaterEqual(3, 4)\n"
"AssertionError: \"3\" unexpectedly not greater than or equal to \"4\""

#: ../../library/unittest.rst:1285
msgid ""
"Test that a *regex* search matches (or does not match) *text*.  In case of "
"failure, the error message will include the pattern and the *text* (or the "
"pattern and the part of *text* that unexpectedly matched).  *regex* may be a "
"regular expression object or a string containing a regular expression "
"suitable for use by :func:`re.search`."
msgstr ""
"Testar att en *regex*-sökning matchar (eller inte matchar) *text*.  Om "
"sökningen misslyckas kommer felmeddelandet att innehålla mönstret och *text* "
"(eller mönstret och den del av *text* som oväntat matchade).  *regex* kan "
"vara ett objekt för reguljära uttryck eller en sträng som innehåller ett "
"reguljärt uttryck som är lämpligt för användning av :func:`re.search`."

#: ../../library/unittest.rst:1291
msgid "Added under the name ``assertRegexpMatches``."
msgstr "Tillagd under namnet ``assertRegexpMatches``."

#: ../../library/unittest.rst:1293
msgid ""
"The method ``assertRegexpMatches()`` has been renamed to :meth:`."
"assertRegex`."
msgstr ""
"Metoden ``assertRegexpMatches()`` har bytt namn till :meth:`.assertRegex`."

#: ../../library/unittest.rst:1296
msgid ":meth:`.assertNotRegex`."
msgstr ":meth:`.assertNotRegex`."

#: ../../library/unittest.rst:1302
msgid ""
"Test that sequence *first* contains the same elements as *second*, "
"regardless of their order. When they don't, an error message listing the "
"differences between the sequences will be generated."
msgstr ""
"Testa att sekvensen *först* innehåller samma element som *andra*, oavsett "
"deras ordning. Om de inte gör det genereras ett felmeddelande som listar "
"skillnaderna mellan sekvenserna."

#: ../../library/unittest.rst:1306
msgid ""
"Duplicate elements are *not* ignored when comparing *first* and *second*. It "
"verifies whether each element has the same count in both sequences. "
"Equivalent to: ``assertEqual(Counter(list(first)), Counter(list(second)))`` "
"but works with sequences of unhashable objects as well."
msgstr ""
"Duplicerade element ignoreras *inte* vid jämförelse av *första* och *andra*. "
"Det kontrolleras om varje element har samma antal i båda sekvenserna. "
"Likvärdig med: ``assertEqual(Counter(list(first)), Counter(list(second)))`` "
"men fungerar även med sekvenser av icke-hashbara objekt."

#: ../../library/unittest.rst:1318
msgid ""
"Test that the Unicode or byte string *s* starts (or does not start) with a "
"*prefix*. *prefix* can also be a tuple of strings to try."
msgstr ""
"Testar att Unicode- eller byte-strängen *s* börjar (eller inte börjar) med "
"ett *prefix*. *prefix* kan också vara en tupel av strängar som ska testas."

#: ../../library/unittest.rst:1328
msgid ""
"Test that the Unicode or byte string *s* ends (or does not end) with a "
"*suffix*. *suffix* can also be a tuple of strings to try."
msgstr ""
"Testar att Unicode- eller byte-strängen *s* slutar (eller inte slutar) med "
"ett *suffix*. *suffix* kan också vara en tupel av strängar som ska testas."

#: ../../library/unittest.rst:1338
msgid "Test that the object *obj* has (or has not) an attribute *name*."
msgstr "Testar att objektet *obj* har (eller inte har) ett attribut *name*."

#: ../../library/unittest.rst:1345
msgid ""
"The :meth:`assertEqual` method dispatches the equality check for objects of "
"the same type to different type-specific methods.  These methods are already "
"implemented for most of the built-in types, but it's also possible to "
"register new methods using :meth:`addTypeEqualityFunc`:"
msgstr ""
"Metoden :meth:`assertEqual` skickar jämlikhetskontrollen för objekt av samma "
"typ till olika typspecifika metoder.  Dessa metoder är redan implementerade "
"för de flesta av de inbyggda typerna, men det är också möjligt att "
"registrera nya metoder med :meth:`addTypeEqualityFunc`:"

#: ../../library/unittest.rst:1352
msgid ""
"Registers a type-specific method called by :meth:`assertEqual` to check if "
"two objects of exactly the same *typeobj* (not subclasses) compare equal.  "
"*function* must take two positional arguments and a third msg=None keyword "
"argument just as :meth:`assertEqual` does.  It must raise :data:`self."
"failureException(msg) <failureException>` when inequality between the first "
"two parameters is detected -- possibly providing useful information and "
"explaining the inequalities in details in the error message."
msgstr ""
"Registrerar en typspecifik metod som anropas av :meth:`assertEqual` för att "
"kontrollera om två objekt av exakt samma *typobj* (inte underklasser) är "
"lika.  *function* måste ta två positionella argument och ett tredje msg=None "
"nyckelordsargument precis som :meth:`assertEqual` gör.  Den måste ge upphov "
"till :data:`self.failureException(msg) <failureException>` när ojämlikhet "
"mellan de två första parametrarna upptäcks -- eventuellt ge användbar "
"information och förklara ojämlikheterna i detalj i felmeddelandet."

#: ../../library/unittest.rst:1363
msgid ""
"The list of type-specific methods automatically used by :meth:`~TestCase."
"assertEqual` are summarized in the following table.  Note that it's usually "
"not necessary to invoke these methods directly."
msgstr ""
"Listan över typspecifika metoder som automatiskt används av :meth:`~TestCase."
"assertEqual` sammanfattas i följande tabell.  Observera att det vanligtvis "
"inte är nödvändigt att anropa dessa metoder direkt."

#: ../../library/unittest.rst:1368
msgid "Used to compare"
msgstr "Används för att jämföra"

#: ../../library/unittest.rst:1370
msgid ":meth:`assertMultiLineEqual(a, b) <TestCase.assertMultiLineEqual>`"
msgstr ":meth:`assertMultiLineEqual(a, b) <TestCase.assertMultiLineEqual>`"

#: ../../library/unittest.rst:1370
msgid "strings"
msgstr "strängar"

#: ../../library/unittest.rst:1373
msgid ":meth:`assertSequenceEqual(a, b) <TestCase.assertSequenceEqual>`"
msgstr ":meth:`assertSequenceEqual(a, b) <TestCase.assertSequenceEqual>`"

#: ../../library/unittest.rst:1373
msgid "sequences"
msgstr "sekvenser"

#: ../../library/unittest.rst:1376
msgid ":meth:`assertListEqual(a, b) <TestCase.assertListEqual>`"
msgstr ":meth:`assertListEqual(a, b) <TestCase.assertListEqual>`"

#: ../../library/unittest.rst:1376
msgid "lists"
msgstr "listor"

#: ../../library/unittest.rst:1379
msgid ":meth:`assertTupleEqual(a, b) <TestCase.assertTupleEqual>`"
msgstr ":meth:`assertTupleEqual(a, b) <TestCase.assertTupleEqual>`"

#: ../../library/unittest.rst:1379
msgid "tuples"
msgstr "tupler"

#: ../../library/unittest.rst:1382
msgid ":meth:`assertSetEqual(a, b) <TestCase.assertSetEqual>`"
msgstr ":meth:`assertSetEqual(a, b) <TestCase.assertSetEqual>`"

#: ../../library/unittest.rst:1382
msgid "sets or frozensets"
msgstr "uppsättningar eller frozensets"

#: ../../library/unittest.rst:1385
msgid ":meth:`assertDictEqual(a, b) <TestCase.assertDictEqual>`"
msgstr ":meth:`assertDictEqual(a, b) <TestCase.assertDictEqual>`"

#: ../../library/unittest.rst:1385
msgid "dicts"
msgstr "dikter"

#: ../../library/unittest.rst:1393
msgid ""
"Test that the multiline string *first* is equal to the string *second*. When "
"not equal a diff of the two strings highlighting the differences will be "
"included in the error message. This method is used by default when comparing "
"strings with :meth:`assertEqual`."
msgstr ""
"Testa att den flerradiga strängen *first* är lika med strängen *second*. Om "
"strängarna inte är lika kommer en diff av de två strängarna som belyser "
"skillnaderna att inkluderas i felmeddelandet. Den här metoden används som "
"standard när strängar jämförs med :meth:`assertEqual`."

#: ../../library/unittest.rst:1403
msgid ""
"Tests that two sequences are equal.  If a *seq_type* is supplied, both "
"*first* and *second* must be instances of *seq_type* or a failure will be "
"raised.  If the sequences are different an error message is constructed that "
"shows the difference between the two."
msgstr ""
"Testar att två sekvenser är lika.  Om en *seq_type* anges måste både *first* "
"och *second* vara instanser av *seq_type*, annars uppstår ett fel.  Om "
"sekvenserna är olika konstrueras ett felmeddelande som visar skillnaden "
"mellan de två."

#: ../../library/unittest.rst:1408
msgid ""
"This method is not called directly by :meth:`assertEqual`, but it's used to "
"implement :meth:`assertListEqual` and :meth:`assertTupleEqual`."
msgstr ""
"Denna metod anropas inte direkt av :meth:`assertEqual`, men den används för "
"att implementera :meth:`assertListEqual` och :meth:`assertTupleEqual`."

#: ../../library/unittest.rst:1418
msgid ""
"Tests that two lists or tuples are equal.  If not, an error message is "
"constructed that shows only the differences between the two.  An error is "
"also raised if either of the parameters are of the wrong type. These methods "
"are used by default when comparing lists or tuples with :meth:`assertEqual`."
msgstr ""
"Testar att två listor eller tupler är lika.  Om så inte är fallet "
"konstrueras ett felmeddelande som endast visar skillnaderna mellan de två.  "
"Ett felmeddelande visas också om någon av parametrarna är av fel typ. Dessa "
"metoder används som standard när listor eller tupler jämförs med :meth:"
"`assertEqual`."

#: ../../library/unittest.rst:1429
msgid ""
"Tests that two sets are equal.  If not, an error message is constructed that "
"lists the differences between the sets.  This method is used by default when "
"comparing sets or frozensets with :meth:`assertEqual`."
msgstr ""
"Testar att två uppsättningar är lika.  Om inte, konstrueras ett "
"felmeddelande som listar skillnaderna mellan uppsättningarna.  Den här "
"metoden används som standard när man jämför uppsättningar eller frozensets "
"med :meth:`assertEqual`."

#: ../../library/unittest.rst:1433
msgid ""
"Fails if either of *first* or *second* does not have a :meth:`set."
"difference` method."
msgstr ""
"Misslyckas om *first* eller *second* inte har någon :meth:`set.difference`-"
"metod."

#: ../../library/unittest.rst:1441
msgid ""
"Test that two dictionaries are equal.  If not, an error message is "
"constructed that shows the differences in the dictionaries. This method will "
"be used by default to compare dictionaries in calls to :meth:`assertEqual`."
msgstr ""
"Testa att två ordböcker är likvärdiga.  Om inte, konstrueras ett "
"felmeddelande som visar skillnaderna i ordböckerna. Denna metod kommer att "
"användas som standard för att jämföra ordböcker i anrop till :meth:"
"`assertEqual`."

#: ../../library/unittest.rst:1452
msgid ""
"Finally the :class:`TestCase` provides the following methods and attributes:"
msgstr ""
"Slutligen tillhandahåller :class:`TestCase` följande metoder och attribut:"

#: ../../library/unittest.rst:1457
msgid ""
"Signals a test failure unconditionally, with *msg* or ``None`` for the error "
"message."
msgstr ""
"Signalerar ovillkorligt att testet misslyckats, med *msg* eller ``None`` som "
"felmeddelande."

#: ../../library/unittest.rst:1463
msgid ""
"This class attribute gives the exception raised by the test method.  If a "
"test framework needs to use a specialized exception, possibly to carry "
"additional information, it must subclass this exception in order to \"play "
"fair\" with the framework.  The initial value of this attribute is :exc:"
"`AssertionError`."
msgstr ""
"Detta klassattribut anger det undantag som testmetoden ger upphov till.  Om "
"ett testramverk behöver använda ett specialiserat undantag, eventuellt för "
"att bära ytterligare information, måste det underklassa detta undantag för "
"att \"spela rättvist\" med ramverket.  Det initiala värdet för detta "
"attribut är :exc:`AssertionError`."

#: ../../library/unittest.rst:1472
msgid ""
"This class attribute determines what happens when a custom failure message "
"is passed as the msg argument to an assertXYY call that fails. ``True`` is "
"the default value. In this case, the custom message is appended to the end "
"of the standard failure message. When set to ``False``, the custom message "
"replaces the standard message."
msgstr ""
"Detta klassattribut avgör vad som händer när ett anpassat felmeddelande "
"skickas som msg-argument till ett assertXYY-anrop som misslyckas. ``True`` "
"är standardvärdet. I det här fallet läggs det anpassade meddelandet till i "
"slutet av standardmeddelandet om misslyckande. När värdet är satt till "
"``False`` ersätter det anpassade meddelandet standardmeddelandet."

#: ../../library/unittest.rst:1478
msgid ""
"The class setting can be overridden in individual test methods by assigning "
"an instance attribute, self.longMessage, to ``True`` or ``False`` before "
"calling the assert methods."
msgstr ""
"Klassinställningen kan åsidosättas i enskilda testmetoder genom att tilldela "
"ett instansattribut, self.longMessage, till ``True`` eller ``False`` innan "
"assert-metoderna anropas."

#: ../../library/unittest.rst:1482
msgid "The class setting gets reset before each test call."
msgstr "Klassinställningen återställs före varje testanrop."

#: ../../library/unittest.rst:1489
msgid ""
"This attribute controls the maximum length of diffs output by assert methods "
"that report diffs on failure. It defaults to 80*8 characters. Assert methods "
"affected by this attribute are :meth:`assertSequenceEqual` (including all "
"the sequence comparison methods that delegate to it), :meth:"
"`assertDictEqual` and :meth:`assertMultiLineEqual`."
msgstr ""
"Detta attribut styr den maximala längden på differenser som skrivs ut av "
"assert-metoder som rapporterar differenser vid fel. Standardvärdet är 80*8 "
"tecken. Assert-metoder som påverkas av detta attribut är :meth:"
"`assertSequenceEqual` (inklusive alla sekvensjämförelsemetoder som delegeras "
"till den), :meth:`assertDictEqual` och :meth:`assertMultiLineEqual`."

#: ../../library/unittest.rst:1496
msgid ""
"Setting ``maxDiff`` to ``None`` means that there is no maximum length of "
"diffs."
msgstr ""
"Om du anger ``maxDiff`` till ``None`` innebär det att det inte finns någon "
"maximal längd på diffar."

#: ../../library/unittest.rst:1502
msgid ""
"Testing frameworks can use the following methods to collect information on "
"the test:"
msgstr ""
"Testramverk kan använda följande metoder för att samla in information om "
"testet:"

#: ../../library/unittest.rst:1508
msgid ""
"Return the number of tests represented by this test object.  For :class:"
"`TestCase` instances, this will always be ``1``."
msgstr ""
"Returnerar antalet tester som representeras av detta testobjekt.  För :class:"
"`TestCase`-instanser kommer detta alltid att vara ``1``."

#: ../../library/unittest.rst:1514
msgid ""
"Return an instance of the test result class that should be used for this "
"test case class (if no other result instance is provided to the :meth:`run` "
"method)."
msgstr ""
"Returnerar en instans av den testresultatklass som ska användas för denna "
"testfallsklass (om ingen annan resultatinstans har angetts för :meth:`run`-"
"metoden)."

#: ../../library/unittest.rst:1518
msgid ""
"For :class:`TestCase` instances, this will always be an instance of :class:"
"`TestResult`; subclasses of :class:`TestCase` should override this as "
"necessary."
msgstr ""
"För :class:`TestCase`-instanser kommer detta alltid att vara en instans av :"
"class:`TestResult`; underklasser till :class:`TestCase` bör åsidosätta detta "
"vid behov."

#: ../../library/unittest.rst:1525
msgid ""
"Return a string identifying the specific test case.  This is usually the "
"full name of the test method, including the module and class name."
msgstr ""
"Returnerar en sträng som identifierar det specifika testfallet.  Detta är "
"vanligtvis det fullständiga namnet på testmetoden, inklusive modul- och "
"klassnamnet."

#: ../../library/unittest.rst:1531
msgid ""
"Returns a description of the test, or ``None`` if no description has been "
"provided.  The default implementation of this method returns the first line "
"of the test method's docstring, if available, or ``None``."
msgstr ""
"Returnerar en beskrivning av testet, eller ``None`` om ingen beskrivning har "
"angetts.  Standardimplementeringen av denna metod returnerar den första "
"raden i testmetodens dokumentsträng, om den finns tillgänglig, eller "
"``None``."

#: ../../library/unittest.rst:1536
msgid ""
"In 3.1 this was changed to add the test name to the short description even "
"in the presence of a docstring.  This caused compatibility issues with "
"unittest extensions and adding the test name was moved to the :class:"
"`TextTestResult` in Python 3.2."
msgstr ""
"I 3.1 ändrades detta så att testnamnet lades till i den korta beskrivningen "
"även om det fanns en docstring.  Detta orsakade kompatibilitetsproblem med "
"unittest-tillägg och tillägget av testnamnet flyttades till :class:"
"`TextTestResult` i Python 3.2."

#: ../../library/unittest.rst:1545
msgid ""
"Add a function to be called after :meth:`tearDown` to cleanup resources used "
"during the test. Functions will be called in reverse order to the order they "
"are added (:abbr:`LIFO (last-in, first-out)`).  They are called with any "
"arguments and keyword arguments passed into :meth:`addCleanup` when they are "
"added."
msgstr ""
"Lägg till en funktion som ska anropas efter :meth:`tearDown` för att rensa "
"resurser som använts under testet. Funktioner kommer att anropas i omvänd "
"ordning mot den ordning de läggs till (:abbr:`LIFO (sist in, först ut)`).  "
"De anropas med alla argument och nyckelordsargument som skickas in i :meth:"
"`addCleanup` när de läggs till."

#: ../../library/unittest.rst:1551
msgid ""
"If :meth:`setUp` fails, meaning that :meth:`tearDown` is not called, then "
"any cleanup functions added will still be called."
msgstr ""
"Om :meth:`setUp` misslyckas, vilket innebär att :meth:`tearDown` inte "
"anropas, anropas ändå eventuella cleanup-funktioner som lagts till."

#: ../../library/unittest.rst:1559
msgid ""
"Enter the supplied :term:`context manager`.  If successful, also add its :"
"meth:`~object.__exit__` method as a cleanup function by :meth:`addCleanup` "
"and return the result of the :meth:`~object.__enter__` method."
msgstr ""
"Ange den medföljande :term:`context manager`.  Om det lyckas, lägg också "
"till dess :meth:`~object.__exit__`-metod som en uppstädningsfunktion med :"
"meth:`addCleanup` och returnera resultatet av :meth:`~object.__enter__`-"
"metoden."

#: ../../library/unittest.rst:1569
msgid ""
"This method is called unconditionally after :meth:`tearDown`, or after :meth:"
"`setUp` if :meth:`setUp` raises an exception."
msgstr ""
"Denna metod anropas ovillkorligen efter :meth:`tearDown`, eller efter :meth:"
"`setUp` om :meth:`setUp` ger upphov till ett undantag."

#: ../../library/unittest.rst:1572
msgid ""
"It is responsible for calling all the cleanup functions added by :meth:"
"`addCleanup`. If you need cleanup functions to be called *prior* to :meth:"
"`tearDown` then you can call :meth:`doCleanups` yourself."
msgstr ""
"Den är ansvarig för att anropa alla upprensningsfunktioner som lagts till "
"av :meth:`addCleanup`. Om du vill att rensningsfunktionerna ska anropas "
"*före* :meth:`tearDown` kan du anropa :meth:`doCleanups` själv."

#: ../../library/unittest.rst:1577
msgid ""
":meth:`doCleanups` pops methods off the stack of cleanup functions one at a "
"time, so it can be called at any time."
msgstr ""
":meth:`doCleanups` plockar metoder från stacken med rensningsfunktioner en i "
"taget, så att den kan anropas när som helst."

#: ../../library/unittest.rst:1585
msgid ""
"Add a function to be called after :meth:`tearDownClass` to cleanup resources "
"used during the test class. Functions will be called in reverse order to the "
"order they are added (:abbr:`LIFO (last-in, first-out)`). They are called "
"with any arguments and keyword arguments passed into :meth:`addClassCleanup` "
"when they are added."
msgstr ""
"Lägg till en funktion som ska anropas efter :meth:`tearDownClass` för att "
"städa upp resurser som använts under testklassen. Funktioner kommer att "
"anropas i omvänd ordning mot den ordning de läggs till (:abbr:`LIFO (sist "
"in, först ut)`). De anropas med alla argument och nyckelordsargument som "
"skickas in i :meth:`addClassCleanup` när de läggs till."

#: ../../library/unittest.rst:1591
msgid ""
"If :meth:`setUpClass` fails, meaning that :meth:`tearDownClass` is not "
"called, then any cleanup functions added will still be called."
msgstr ""
"Om :meth:`setUpClass` misslyckas, vilket innebär att :meth:`tearDownClass` "
"inte anropas, så kommer eventuella cleanup-funktioner som lagts till ändå "
"att anropas."

#: ../../library/unittest.rst:1599
msgid ""
"Enter the supplied :term:`context manager`.  If successful, also add its :"
"meth:`~object.__exit__` method as a cleanup function by :meth:"
"`addClassCleanup` and return the result of the :meth:`~object.__enter__` "
"method."
msgstr ""
"Ange den medföljande :term:`context manager`.  Om det lyckas, lägg också "
"till dess :meth:`~object.__exit__`-metod som en uppstädningsfunktion med :"
"meth:`addClassCleanup` och returnera resultatet av :meth:`~object.__enter__`-"
"metoden."

#: ../../library/unittest.rst:1609
msgid ""
"This method is called unconditionally after :meth:`tearDownClass`, or after :"
"meth:`setUpClass` if :meth:`setUpClass` raises an exception."
msgstr ""
"Denna metod anropas ovillkorligen efter :meth:`tearDownClass`, eller efter :"
"meth:`setUpClass` om :meth:`setUpClass` ger upphov till ett undantag."

#: ../../library/unittest.rst:1612
msgid ""
"It is responsible for calling all the cleanup functions added by :meth:"
"`addClassCleanup`. If you need cleanup functions to be called *prior* to :"
"meth:`tearDownClass` then you can call :meth:`doClassCleanups` yourself."
msgstr ""
"Den är ansvarig för att anropa alla uppstädningsfunktioner som lagts till "
"av :meth:`addClassCleanup`. Om du vill att rensningsfunktionerna ska anropas "
"*före* :meth:`tearDownClass` kan du själv anropa :meth:`doClassCleanups`."

#: ../../library/unittest.rst:1617
msgid ""
":meth:`doClassCleanups` pops methods off the stack of cleanup functions one "
"at a time, so it can be called at any time."
msgstr ""
":meth:`doClassCleanups` plockar bort metoder från stacken med "
"rensningsfunktioner en i taget, så att den kan anropas när som helst."

#: ../../library/unittest.rst:1625
msgid ""
"This class provides an API similar to :class:`TestCase` and also accepts "
"coroutines as test functions."
msgstr ""
"Denna klass tillhandahåller ett API som liknar :class:`TestCase` och "
"accepterar även coroutines som testfunktioner."

#: ../../library/unittest.rst:1632
msgid ""
"The *loop_factory* passed to :class:`asyncio.Runner`. Override in subclasses "
"with :class:`asyncio.EventLoop` to avoid using the asyncio policy system."
msgstr ""
"Den *loop_factory* som skickas till :class:`asyncio.Runner`. Åsidosätt i "
"underklasser med :class:`asyncio.EventLoop` för att undvika att använda "
"asyncios policysystem."

#: ../../library/unittest.rst:1641
msgid ""
"Method called to prepare the test fixture. This is called after :meth:"
"`setUp`. This is called immediately before calling the test method; other "
"than :exc:`AssertionError` or :exc:`SkipTest`, any exception raised by this "
"method will be considered an error rather than a test failure. The default "
"implementation does nothing."
msgstr ""
"Metod som anropas för att förbereda testfixturen. Detta anropas efter :meth:"
"`setUp`. Detta anropas omedelbart innan testmetoden anropas; förutom :exc:"
"`AssertionError` eller :exc:`SkipTest`, kommer alla undantag som denna metod "
"ger upphov till att betraktas som ett fel snarare än ett misslyckat test. "
"Standardimplementationen gör ingenting."

#: ../../library/unittest.rst:1650
msgid ""
"Method called immediately after the test method has been called and the "
"result recorded.  This is called before :meth:`tearDown`. This is called "
"even if the test method raised an exception, so the implementation in "
"subclasses may need to be particularly careful about checking internal "
"state.  Any exception, other than :exc:`AssertionError` or :exc:`SkipTest`, "
"raised by this method will be considered an additional error rather than a "
"test failure (thus increasing the total number of reported errors). This "
"method will only be called if the :meth:`asyncSetUp` succeeds, regardless of "
"the outcome of the test method. The default implementation does nothing."
msgstr ""
"Metod som anropas omedelbart efter att testmetoden har anropats och "
"resultatet registrerats.  Detta anropas före :meth:`tearDown`. Den anropas "
"även om testmetoden gav upphov till ett undantag, så implementeringen i "
"underklasser kan behöva vara särskilt noggrann med att kontrollera det "
"interna tillståndet.  Varje undantag, annat än :exc:`AssertionError` eller :"
"exc:`SkipTest`, som anropas av denna metod kommer att betraktas som ett "
"ytterligare fel snarare än ett testfel (vilket ökar det totala antalet "
"rapporterade fel). Denna metod kommer endast att anropas om :meth:"
"`asyncSetUp` lyckas, oavsett resultatet av testmetoden. "
"Standardimplementeringen gör ingenting."

#: ../../library/unittest.rst:1662
msgid "This method accepts a coroutine that can be used as a cleanup function."
msgstr ""
"Den här metoden accepterar en coroutine som kan användas som en "
"rensningsfunktion."

#: ../../library/unittest.rst:1667
msgid ""
"Enter the supplied :term:`asynchronous context manager`.  If successful, "
"also add its :meth:`~object.__aexit__` method as a cleanup function by :meth:"
"`addAsyncCleanup` and return the result of the :meth:`~object.__aenter__` "
"method."
msgstr ""
"Ange den medföljande :term:`asynkron kontexthanterare`.  Om det lyckas, lägg "
"också till dess :meth:`~object.__aexit__`-metod som en uppstädningsfunktion "
"med :meth:`addAsyncCleanup` och returnera resultatet av :meth:`~object."
"__aenter__`-metoden."

#: ../../library/unittest.rst:1677
msgid ""
"Sets up a new event loop to run the test, collecting the result into the :"
"class:`TestResult` object passed as *result*.  If *result* is omitted or "
"``None``, a temporary result object is created (by calling the :meth:"
"`defaultTestResult` method) and used. The result object is returned to :meth:"
"`run`'s caller. At the end of the test all the tasks in the event loop are "
"cancelled."
msgstr ""
"Skapar en ny händelseslinga för att köra testet och samlar in resultatet i :"
"class:`TestResult`-objektet som skickas som *result*.  Om *result* utelämnas "
"eller är ``None`` skapas ett temporärt resultatobjekt (genom att anropa "
"metoden :meth:`defaultTestResult`) och används. Resultatobjektet returneras "
"till :meth:`run`:s anropare. I slutet av testet avbryts alla uppgifter i "
"händelseslingan."

#: ../../library/unittest.rst:1685
msgid "An example illustrating the order::"
msgstr "Ett exempel som illustrerar ordningen::"

#: ../../library/unittest.rst:1687
msgid ""
"from unittest import IsolatedAsyncioTestCase\n"
"\n"
"events = []\n"
"\n"
"\n"
"class Test(IsolatedAsyncioTestCase):\n"
"\n"
"\n"
"    def setUp(self):\n"
"        events.append(\"setUp\")\n"
"\n"
"    async def asyncSetUp(self):\n"
"        self._async_connection = await AsyncConnection()\n"
"        events.append(\"asyncSetUp\")\n"
"\n"
"    async def test_response(self):\n"
"        events.append(\"test_response\")\n"
"        response = await self._async_connection.get(\"https://example."
"com\")\n"
"        self.assertEqual(response.status_code, 200)\n"
"        self.addAsyncCleanup(self.on_cleanup)\n"
"\n"
"    def tearDown(self):\n"
"        events.append(\"tearDown\")\n"
"\n"
"    async def asyncTearDown(self):\n"
"        await self._async_connection.close()\n"
"        events.append(\"asyncTearDown\")\n"
"\n"
"    async def on_cleanup(self):\n"
"        events.append(\"cleanup\")\n"
"\n"
"if __name__ == \"__main__\":\n"
"    unittest.main()"
msgstr ""
"from unittest import IsolatedAsyncioTestCase\n"
"\n"
"händelser = []\n"
"\n"
"\n"
"klass Test(IsolatedAsyncioTestCase):\n"
"\n"
"\n"
"    def setUp(self):\n"
"        events.append(\"setUp\")\n"
"\n"
"    async def asyncSetUp(self):\n"
"        self._async_connection = await AsyncConnection()\n"
"        events.append(\"asyncSetUp\")\n"
"\n"
"    async def test_response(self):\n"
"        events.append(\"test_response\")\n"
"        response = await self._async_connection.get(\"https://example."
"com\")\n"
"        self.assertEqual(svar.status_kod, 200)\n"
"        self.addAsyncCleanup(self.on_cleanup)\n"
"\n"
"    def tearDown(self):\n"
"        events.append(\"tearDown\")\n"
"\n"
"    async def asyncTearDown(self):\n"
"        await self._async_connection.close()\n"
"        events.append(\"asyncTearDown\")\n"
"\n"
"    async def on_cleanup(self):\n"
"        events.append(\"cleanup\")\n"
"\n"
"om __name__ == \"__main__\":\n"
"    unittest.main()"

#: ../../library/unittest.rst:1721
msgid ""
"After running the test, ``events`` would contain ``[\"setUp\", "
"\"asyncSetUp\", \"test_response\", \"asyncTearDown\", \"tearDown\", "
"\"cleanup\"]``."
msgstr ""
"Efter att testet körts skulle ``events`` innehålla ``[\"setUp\", "
"\"asyncSetUp\", \"test_response\", \"asyncTearDown\", \"tearDown\", "
"\"cleanup\"]``."

#: ../../library/unittest.rst:1726
msgid ""
"This class implements the portion of the :class:`TestCase` interface which "
"allows the test runner to drive the test, but does not provide the methods "
"which test code can use to check and report errors.  This is used to create "
"test cases using legacy test code, allowing it to be integrated into a :mod:"
"`unittest`-based test framework."
msgstr ""
"Denna klass implementerar den del av :class:`TestCase`-gränssnittet som gör "
"det möjligt för testköraren att köra testet, men tillhandahåller inte de "
"metoder som testkoden kan använda för att kontrollera och rapportera fel.  "
"Detta används för att skapa testfall med hjälp av äldre testkod, vilket gör "
"att den kan integreras i ett :mod:`unittest`-baserat testramverk."

#: ../../library/unittest.rst:1736
msgid "Grouping tests"
msgstr "Gruppering av tester"

#: ../../library/unittest.rst:1740
msgid ""
"This class represents an aggregation of individual test cases and test "
"suites. The class presents the interface needed by the test runner to allow "
"it to be run as any other test case.  Running a :class:`TestSuite` instance "
"is the same as iterating over the suite, running each test individually."
msgstr ""
"Denna klass representerar en sammanställning av enskilda testfall och "
"testsviter. Klassen presenterar det gränssnitt som testlöparen behöver för "
"att kunna köra den som vilket annat testfall som helst.  Att köra en :class:"
"`TestSuite`-instans är samma sak som att iterera över sviten och köra varje "
"test individuellt."

#: ../../library/unittest.rst:1745
msgid ""
"If *tests* is given, it must be an iterable of individual test cases or "
"other test suites that will be used to build the suite initially. Additional "
"methods are provided to add test cases and suites to the collection later on."
msgstr ""
"Om *tests* anges måste det vara en iterabel av enskilda testfall eller andra "
"testsviter som kommer att användas för att bygga upp sviten initialt. "
"Ytterligare metoder tillhandahålls för att lägga till testfall och sviter "
"till samlingen senare."

#: ../../library/unittest.rst:1749
msgid ""
":class:`TestSuite` objects behave much like :class:`TestCase` objects, "
"except they do not actually implement a test.  Instead, they are used to "
"aggregate tests into groups of tests that should be run together. Some "
"additional methods are available to add tests to :class:`TestSuite` "
"instances:"
msgstr ""
":class:`TestSuite`-objekt beter sig ungefär som :class:`TestCase`-objekt, "
"förutom att de inte implementerar ett test.  Istället används de för att "
"samla ihop tester till grupper av tester som ska köras tillsammans. Det "
"finns några ytterligare metoder för att lägga till tester i :class:"
"`TestSuite`-instanser:"

#: ../../library/unittest.rst:1757
msgid "Add a :class:`TestCase` or :class:`TestSuite` to the suite."
msgstr "Lägg till ett :class:`TestCase` eller :class:`TestSuite` till sviten."

#: ../../library/unittest.rst:1762
msgid ""
"Add all the tests from an iterable of :class:`TestCase` and :class:"
"`TestSuite` instances to this test suite."
msgstr ""
"Lägg till alla tester från en iterabel med instanser av :class:`TestCase` "
"och :class:`TestSuite` till denna testsvit."

#: ../../library/unittest.rst:1765
msgid ""
"This is equivalent to iterating over *tests*, calling :meth:`addTest` for "
"each element."
msgstr ""
"Detta är likvärdigt med att iterera över *tester* och anropa :meth:`addTest` "
"för varje element."

#: ../../library/unittest.rst:1768
msgid ":class:`TestSuite` shares the following methods with :class:`TestCase`:"
msgstr ":class:`TestSuite` delar följande metoder med :class:`TestCase`:"

#: ../../library/unittest.rst:1773
msgid ""
"Run the tests associated with this suite, collecting the result into the "
"test result object passed as *result*.  Note that unlike :meth:`TestCase."
"run`, :meth:`TestSuite.run` requires the result object to be passed in."
msgstr ""
"Kör de tester som är associerade med denna svit och samla in resultatet i "
"testresultatobjektet som skickas som *result*.  Observera att till skillnad "
"från :meth:`TestCase.run` kräver :meth:`TestSuite.run` att resultatobjektet "
"skickas in."

#: ../../library/unittest.rst:1781
msgid ""
"Run the tests associated with this suite without collecting the result. This "
"allows exceptions raised by the test to be propagated to the caller and can "
"be used to support running tests under a debugger."
msgstr ""
"Kör de tester som är kopplade till denna svit utan att samla in resultatet. "
"Detta gör att undantag som uppstår i testet kan vidarebefordras till den som "
"anropar och kan användas för att köra tester under en debugger."

#: ../../library/unittest.rst:1788
msgid ""
"Return the number of tests represented by this test object, including all "
"individual tests and sub-suites."
msgstr ""
"Returnerar antalet tester som representeras av detta testobjekt, inklusive "
"alla enskilda tester och undergrupper."

#: ../../library/unittest.rst:1794
msgid ""
"Tests grouped by a :class:`TestSuite` are always accessed by iteration. "
"Subclasses can lazily provide tests by overriding :meth:`!__iter__`. Note "
"that this method may be called several times on a single suite (for example "
"when counting tests or comparing for equality) so the tests returned by "
"repeated iterations before :meth:`TestSuite.run` must be the same for each "
"call iteration. After :meth:`TestSuite.run`, callers should not rely on the "
"tests returned by this method unless the caller uses a subclass that "
"overrides :meth:`TestSuite._removeTestAtIndex` to preserve test references."
msgstr ""
"Tester som grupperas av en :class:`TestSuite` nås alltid genom iteration. "
"Underklasser kan lata tillhandahålla tester genom att åsidosätta :meth:`!"
"__iter__`. Observera att den här metoden kan anropas flera gånger på en enda "
"svit (t.ex. när man räknar tester eller jämför för likhet) så de tester som "
"returneras av upprepade iterationer före :meth:`TestSuite.run` måste vara "
"desamma för varje anropsiteration. Efter :meth:`TestSuite.run` bör anropare "
"inte förlita sig på de tester som returneras av denna metod om inte "
"anroparen använder en subklass som åsidosätter :meth:`TestSuite."
"_removeTestAtIndex` för att bevara testreferenser."

#: ../../library/unittest.rst:1804
msgid ""
"In earlier versions the :class:`TestSuite` accessed tests directly rather "
"than through iteration, so overriding :meth:`!__iter__` wasn't sufficient "
"for providing tests."
msgstr ""
"I tidigare versioner hade :class:`TestSuite` tillgång till tester direkt "
"snarare än genom iteration, så att åsidosätta :meth:`!__iter__` var inte "
"tillräckligt för att tillhandahålla tester."

#: ../../library/unittest.rst:1809
msgid ""
"In earlier versions the :class:`TestSuite` held references to each :class:"
"`TestCase` after :meth:`TestSuite.run`. Subclasses can restore that behavior "
"by overriding :meth:`TestSuite._removeTestAtIndex`."
msgstr ""
"I tidigare versioner behöll :class:`TestSuite` referenser till varje :class:"
"`TestCase` efter :meth:`TestSuite.run`. Underklasser kan återställa detta "
"beteende genom att åsidosätta :meth:`TestSuite._removeTestAtIndex`."

#: ../../library/unittest.rst:1814
msgid ""
"In the typical usage of a :class:`TestSuite` object, the :meth:`run` method "
"is invoked by a :class:`TestRunner` rather than by the end-user test harness."
msgstr ""
"I den typiska användningen av ett :class:`TestSuite`-objekt anropas :meth:"
"`run`-metoden av en :class:`TestRunner` snarare än av slutanvändarens "
"testprogram."

#: ../../library/unittest.rst:1819
msgid "Loading and running tests"
msgstr "Ladda och köra tester"

#: ../../library/unittest.rst:1823
msgid ""
"The :class:`TestLoader` class is used to create test suites from classes and "
"modules.  Normally, there is no need to create an instance of this class; "
"the :mod:`unittest` module provides an instance that can be shared as :data:"
"`unittest.defaultTestLoader`.  Using a subclass or instance, however, allows "
"customization of some configurable properties."
msgstr ""
"Klassen :class:`TestLoader` används för att skapa testsviter från klasser "
"och moduler.  Normalt finns det inget behov av att skapa en instans av den "
"här klassen; modulen :mod:`unittest` tillhandahåller en instans som kan "
"delas som :data:`unittest.defaultTestLoader`.  Om du använder en underklass "
"eller instans kan du dock anpassa vissa konfigurerbara egenskaper."

#: ../../library/unittest.rst:1829
msgid ":class:`TestLoader` objects have the following attributes:"
msgstr ":class:`TestLoader`-objekt har följande attribut:"

#: ../../library/unittest.rst:1834
msgid ""
"A list of the non-fatal errors encountered while loading tests. Not reset by "
"the loader at any point. Fatal errors are signalled by the relevant method "
"raising an exception to the caller. Non-fatal errors are also indicated by a "
"synthetic test that will raise the original error when run."
msgstr ""
"En lista över de icke-fatala fel som uppstår vid laddning av tester. "
"Återställs inte av laddaren vid någon tidpunkt. Fatala fel signaleras genom "
"att den relevanta metoden ger upphov till ett undantag för den som anropar. "
"Icke-fatala fel indikeras också av ett syntetiskt test som kommer att ge "
"upphov till det ursprungliga felet när det körs."

#: ../../library/unittest.rst:1843
msgid ":class:`TestLoader` objects have the following methods:"
msgstr ":class:`TestLoader`-objekt har följande metoder:"

#: ../../library/unittest.rst:1848
msgid ""
"Return a suite of all test cases contained in the :class:`TestCase`\\ -"
"derived :class:`testCaseClass`."
msgstr ""
"Returnerar en svit av alla testfall som ingår i den :class:`TestCase`-"
"deriverade :class:`testCaseClass`."

#: ../../library/unittest.rst:1851
msgid ""
"A test case instance is created for each method named by :meth:"
"`getTestCaseNames`. By default these are the method names beginning with "
"``test``. If :meth:`getTestCaseNames` returns no methods, but the :meth:"
"`runTest` method is implemented, a single test case is created for that "
"method instead."
msgstr ""
"En testfallsinstans skapas för varje metod som namnges av :meth:"
"`getTestCaseNames`. Som standard är detta de metodnamn som börjar med "
"``test``. Om :meth:`getTestCaseNames` inte returnerar några metoder, men "
"metoden :meth:`runTest` är implementerad, skapas ett enda testfall för den "
"metoden istället."

#: ../../library/unittest.rst:1860
msgid ""
"Return a suite of all test cases contained in the given module. This method "
"searches *module* for classes derived from :class:`TestCase` and creates an "
"instance of the class for each test method defined for the class."
msgstr ""
"Returnerar en svit av alla testfall som ingår i den givna modulen. Den här "
"metoden söker i *module* efter klasser som härrör från :class:`TestCase` och "
"skapar en instans av klassen för varje testmetod som definieras för klassen."

#: ../../library/unittest.rst:1867
msgid ""
"While using a hierarchy of :class:`TestCase`\\ -derived classes can be "
"convenient in sharing fixtures and helper functions, defining test methods "
"on base classes that are not intended to be instantiated directly does not "
"play well with this method.  Doing so, however, can be useful when the "
"fixtures are different and defined in subclasses."
msgstr ""
"Även om det kan vara praktiskt att använda en hierarki av :class:`TestCase`-"
"avledda klasser för att dela fixturer och hjälpfunktioner, är det inte så "
"bra att definiera testmetoder på basklasser som inte är avsedda att "
"instansieras direkt med den här metoden.  Det kan dock vara användbart när "
"fixturerna är olika och definieras i underklasser."

#: ../../library/unittest.rst:1873
msgid ""
"If a module provides a ``load_tests`` function it will be called to load the "
"tests. This allows modules to customize test loading. This is the "
"`load_tests protocol`_.  The *pattern* argument is passed as the third "
"argument to ``load_tests``."
msgstr ""
"Om en modul tillhandahåller en ``load_tests``-funktion kommer den att "
"anropas för att ladda testerna. Detta gör det möjligt för moduler att "
"anpassa testladdningen. Detta är `load_tests-protokollet`_.  Argumentet "
"*pattern* skickas som det tredje argumentet till ``load_tests``."

#: ../../library/unittest.rst:1878
msgid "Support for ``load_tests`` added."
msgstr "Stöd för ``load_tests`` har lagts till."

#: ../../library/unittest.rst:1881
msgid "Support for a keyword-only argument *pattern* has been added."
msgstr ""
"Stöd för ett argument *pattern* som endast innehåller nyckelord har lagts "
"till."

#: ../../library/unittest.rst:1884
msgid ""
"The undocumented and unofficial *use_load_tests* parameter has been removed."
msgstr ""
"Den odokumenterade och inofficiella parametern *use_load_tests* har tagits "
"bort."

#: ../../library/unittest.rst:1891
msgid "Return a suite of all test cases given a string specifier."
msgstr ""
"Returnerar en svit med alla testfall som anges med en strängspecifikator."

#: ../../library/unittest.rst:1893
msgid ""
"The specifier *name* is a \"dotted name\" that may resolve either to a "
"module, a test case class, a test method within a test case class, a :class:"
"`TestSuite` instance, or a callable object which returns a :class:`TestCase` "
"or :class:`TestSuite` instance.  These checks are applied in the order "
"listed here; that is, a method on a possible test case class will be picked "
"up as \"a test method within a test case class\", rather than \"a callable "
"object\"."
msgstr ""
"Specificeraren *name* är ett \"prickat namn\" som kan leda till antingen en "
"modul, en testfallsklass, en testmetod i en testfallsklass, en instans av :"
"class:`TestSuite` eller ett anropsbart objekt som returnerar en instans av :"
"class:`TestCase` eller :class:`TestSuite`.  Dessa kontroller tillämpas i den "
"ordning som anges här, dvs. en metod i en möjlig testfallsklass kommer att "
"uppfattas som \"en testmetod i en testfallsklass\", snarare än \"ett "
"anropbart objekt\"."

#: ../../library/unittest.rst:1901
msgid ""
"For example, if you have a module :mod:`SampleTests` containing a :class:"
"`TestCase`\\ -derived class :class:`SampleTestCase` with three test methods "
"(:meth:`test_one`, :meth:`test_two`, and :meth:`test_three`), the specifier "
"``'SampleTests.SampleTestCase'`` would cause this method to return a suite "
"which will run all three test methods. Using the specifier ``'SampleTests."
"SampleTestCase.test_two'`` would cause it to return a test suite which will "
"run only the :meth:`test_two` test method. The specifier can refer to "
"modules and packages which have not been imported; they will be imported as "
"a side-effect."
msgstr ""
"Om du till exempel har en modul :mod:`SampleTests` som innehåller en :class:"
"`TestCase`-avledd klass :class:`SampleTestCase` med tre testmetoder (:meth:"
"`test_one`, :meth:`test_two` och :meth:`test_three`), skulle specifikatorn "
"``'SampleTests.SampleTestCase'`` göra att den här metoden returnerar en svit "
"som kör alla tre testmetoderna. Om specifikatorn ``'SampleTests."
"SampleTestCase.test_two'`` används kommer metoden att returnera en testsvit "
"som endast kör testmetoden :meth:`test_two`. Specificeraren kan hänvisa till "
"moduler och paket som inte har importerats; de kommer att importeras som en "
"bieffekt."

#: ../../library/unittest.rst:1911
msgid "The method optionally resolves *name* relative to the given *module*."
msgstr ""
"Metoden löser valfritt upp *namn* i förhållande till den angivna *modulen*."

#: ../../library/unittest.rst:1913
msgid ""
"If an :exc:`ImportError` or :exc:`AttributeError` occurs while traversing "
"*name* then a synthetic test that raises that error when run will be "
"returned. These errors are included in the errors accumulated by self.errors."
msgstr ""
"Om ett :exc:`ImportError` eller :exc:`AttributeError` inträffar när *name* "
"genomkorsas kommer ett syntetiskt test som ger upphov till felet att "
"returneras. Dessa fel ingår i de fel som ackumuleras av self.errors."

#: ../../library/unittest.rst:1922
msgid ""
"Similar to :meth:`loadTestsFromName`, but takes a sequence of names rather "
"than a single name.  The return value is a test suite which supports all the "
"tests defined for each name."
msgstr ""
"Liknar :meth:`loadTestsFromName`, men tar en sekvens av namn i stället för "
"ett enda namn.  Returvärdet är en testsvit som stöder alla tester som "
"definierats för varje namn."

#: ../../library/unittest.rst:1929
msgid ""
"Return a sorted sequence of method names found within *testCaseClass*; this "
"should be a subclass of :class:`TestCase`."
msgstr ""
"Returnerar en sorterad sekvens av metodnamn som finns inom *testCaseClass*; "
"detta bör vara en subklass av :class:`TestCase`."

#: ../../library/unittest.rst:1935
msgid ""
"Find all the test modules by recursing into subdirectories from the "
"specified start directory, and return a TestSuite object containing them. "
"Only test files that match *pattern* will be loaded. (Using shell style "
"pattern matching.) Only module names that are importable (i.e. are valid "
"Python identifiers) will be loaded."
msgstr ""
"Hitta alla testmoduler genom att söka i underkataloger från den angivna "
"startkatalogen och returnera ett TestSuite-objekt som innehåller dem. Endast "
"testfiler som matchar *mönster* kommer att laddas. (Med hjälp av "
"mönstermatchning i shell-stil.) Endast modulnamn som är importerbara (dvs. "
"giltiga Python-identifierare) laddas."

#: ../../library/unittest.rst:1941
msgid ""
"All test modules must be importable from the top level of the project. If "
"the start directory is not the top level directory then *top_level_dir* must "
"be specified separately."
msgstr ""
"Alla testmoduler måste kunna importeras från den översta nivån i projektet. "
"Om startkatalogen inte är den översta katalogen måste *top_level_dir* anges "
"separat."

#: ../../library/unittest.rst:1945
msgid ""
"If importing a module fails, for example due to a syntax error, then this "
"will be recorded as a single error and discovery will continue.  If the "
"import failure is due to :exc:`SkipTest` being raised, it will be recorded "
"as a skip instead of an error."
msgstr ""
"Om importen av en modul misslyckas, t.ex. på grund av ett syntaxfel, "
"registreras detta som ett enda fel och upptäckten fortsätter.  Om importen "
"misslyckas på grund av att :exc:`SkipTest` aktiveras, registreras det som en "
"skip istället för ett fel."

#: ../../library/unittest.rst:1950
msgid ""
"If a package (a directory containing a file named :file:`__init__.py`) is "
"found, the package will be checked for a ``load_tests`` function. If this "
"exists then it will be called ``package.load_tests(loader, tests, "
"pattern)``. Test discovery takes care to ensure that a package is only "
"checked for tests once during an invocation, even if the load_tests function "
"itself calls ``loader.discover``."
msgstr ""
"Om ett paket (en katalog som innehåller en fil med namnet :file:`__init__."
"py`) hittas, kommer paketet att kontrolleras för en ``load_tests``-funktion. "
"Om en sådan finns kommer den att kallas ``package.load_tests(loader, tests, "
"pattern)``. Testdiscovery ser till att ett paket bara kontrolleras för "
"tester en gång under en anrop, även om load_tests-funktionen själv anropar "
"``loader.discover``."

#: ../../library/unittest.rst:1958
msgid ""
"If ``load_tests`` exists then discovery does *not* recurse into the package, "
"``load_tests`` is responsible for loading all tests in the package."
msgstr ""
"Om ``load_tests`` existerar så rekurserar discovery *inte* in i paketet, "
"``load_tests`` ansvarar för att ladda alla tester i paketet."

#: ../../library/unittest.rst:1962
msgid ""
"The pattern is deliberately not stored as a loader attribute so that "
"packages can continue discovery themselves."
msgstr ""
"Mönstret lagras avsiktligt inte som ett attribut för laddaren, så att "
"paketen kan fortsätta att upptäcka sig själva."

#: ../../library/unittest.rst:1965
msgid ""
"*top_level_dir* is stored internally, and used as a default to any nested "
"calls to ``discover()``. That is, if a package's ``load_tests`` calls "
"``loader.discover()``, it does not need to pass this argument."
msgstr ""
"*top_level_dir* lagras internt och används som standard för alla nästlade "
"anrop till ``discover()``. Det vill säga, om ett pakets ``load_tests`` "
"anropar ``loader.discover()``, behöver det inte skicka detta argument."

#: ../../library/unittest.rst:1969
msgid "*start_dir* can be a dotted module name as well as a directory."
msgstr "*start_dir* kan vara både ett punktat modulnamn och en katalog."

#: ../../library/unittest.rst:1973
msgid ""
"Modules that raise :exc:`SkipTest` on import are recorded as skips, not "
"errors."
msgstr ""
"Moduler som ger upphov till :exc:`SkipTest` vid import registreras som "
"överhoppningar, inte fel."

#: ../../library/unittest.rst:1977
msgid "*start_dir* can be a :term:`namespace packages <namespace package>`."
msgstr ""
"*start_dir* kan vara en :term:`namespace packages <namespace package>`."

#: ../../library/unittest.rst:1979
msgid ""
"Paths are sorted before being imported so that execution order is the same "
"even if the underlying file system's ordering is not dependent on file name."
msgstr ""
"Sökvägarna sorteras innan de importeras så att exekveringsordningen blir "
"densamma även om det underliggande filsystemets ordning inte är beroende av "
"filnamnet."

#: ../../library/unittest.rst:1983
msgid ""
"Found packages are now checked for ``load_tests`` regardless of whether "
"their path matches *pattern*, because it is impossible for a package name to "
"match the default pattern."
msgstr ""
"Hittade paket kontrolleras nu för ``load_tests`` oavsett om deras sökväg "
"matchar *pattern*, eftersom det är omöjligt för ett paketnamn att matcha "
"standardmönstret."

#: ../../library/unittest.rst:1988
msgid ""
"*start_dir* can not be a :term:`namespace packages <namespace package>`. It "
"has been broken since Python 3.7, and Python 3.11 officially removes it."
msgstr ""
"*start_dir* kan inte vara en :term:`namespace packages <namespace package>`. "
"Det har varit trasigt sedan Python 3.7, och Python 3.11 tar officiellt bort "
"det."

#: ../../library/unittest.rst:1992
msgid "*top_level_dir* is only stored for the duration of *discover* call."
msgstr ""
"*top_level_dir* lagras endast under den tid som *discover*-anropet pågår."

#: ../../library/unittest.rst:1995
msgid "*start_dir* can once again be a :term:`namespace package`."
msgstr "*start_dir* kan återigen vara en :term:`namespace package`."

#: ../../library/unittest.rst:1998
msgid ""
"The following attributes of a :class:`TestLoader` can be configured either "
"by subclassing or assignment on an instance:"
msgstr ""
"Följande attribut för en :class:`TestLoader` kan konfigureras antingen genom "
"subklassning eller genom tilldelning på en instans:"

#: ../../library/unittest.rst:2004
msgid ""
"String giving the prefix of method names which will be interpreted as test "
"methods.  The default value is ``'test'``."
msgstr ""
"Sträng som anger prefixet för metodnamn som ska tolkas som testmetoder.  "
"Standardvärdet är ``'test'``."

#: ../../library/unittest.rst:2007
msgid ""
"This affects :meth:`getTestCaseNames` and all the ``loadTestsFrom*`` methods."
msgstr ""
"Detta påverkar :meth:`getTestCaseNames` och alla ``loadTestsFrom*``-metoder."

#: ../../library/unittest.rst:2013
msgid ""
"Function to be used to compare method names when sorting them in :meth:"
"`getTestCaseNames` and all the ``loadTestsFrom*`` methods."
msgstr ""
"Funktion som ska användas för att jämföra metodnamn när de sorteras i :meth:"
"`getTestCaseNames` och alla ``loadTestsFrom*``-metoder."

#: ../../library/unittest.rst:2019
msgid ""
"Callable object that constructs a test suite from a list of tests. No "
"methods on the resulting object are needed.  The default value is the :class:"
"`TestSuite` class."
msgstr ""
"Anropsbart objekt som konstruerar en testsvit från en lista med tester. Inga "
"metoder på det resulterande objektet behövs.  Standardvärdet är klassen :"
"class:`TestSuite`."

#: ../../library/unittest.rst:2023 ../../library/unittest.rst:2036
msgid "This affects all the ``loadTestsFrom*`` methods."
msgstr "Detta påverkar alla ``loadTestsFrom*``-metoder."

#: ../../library/unittest.rst:2027
msgid ""
"List of Unix shell-style wildcard test name patterns that test methods have "
"to match to be included in test suites (see ``-k`` option)."
msgstr ""
"Lista över testnamnsmönster med jokertecken i Unix-shell-stil som "
"testmetoder måste matcha för att inkluderas i testsviter (se alternativet ``-"
"k``)."

#: ../../library/unittest.rst:2030
msgid ""
"If this attribute is not ``None`` (the default), all test methods to be "
"included in test suites must match one of the patterns in this list. Note "
"that matches are always performed using :meth:`fnmatch.fnmatchcase`, so "
"unlike patterns passed to the ``-k`` option, simple substring patterns will "
"have to be converted using ``*`` wildcards."
msgstr ""
"Om detta attribut inte är ``None`` (standard) måste alla testmetoder som ska "
"ingå i testsviter matcha ett av mönstren i listan. Observera att matchningar "
"alltid utförs med :meth:`fnmatch.fnmatchcase`, så till skillnad från mönster "
"som skickas till alternativet ``-k`` måste enkla delsträngsmönster "
"konverteras med hjälp av jokertecken ``*``."

#: ../../library/unittest.rst:2043
msgid ""
"This class is used to compile information about which tests have succeeded "
"and which have failed."
msgstr ""
"Denna klass används för att sammanställa information om vilka tester som har "
"lyckats och vilka som har misslyckats."

#: ../../library/unittest.rst:2046
msgid ""
"A :class:`TestResult` object stores the results of a set of tests.  The :"
"class:`TestCase` and :class:`TestSuite` classes ensure that results are "
"properly recorded; test authors do not need to worry about recording the "
"outcome of tests."
msgstr ""
"Ett :class:`TestResult`-objekt lagrar resultaten av en uppsättning tester.  "
"Klasserna :class:`TestCase` och :class:`TestSuite` säkerställer att "
"resultaten registreras på rätt sätt; testförfattare behöver inte oroa sig "
"för att registrera resultatet av testerna."

#: ../../library/unittest.rst:2051
msgid ""
"Testing frameworks built on top of :mod:`unittest` may want access to the :"
"class:`TestResult` object generated by running a set of tests for reporting "
"purposes; a :class:`TestResult` instance is returned by the :meth:"
"`TestRunner.run` method for this purpose."
msgstr ""
"Testramverk som bygger på :mod:`unittest` kan vilja ha tillgång till :class:"
"`TestResult`-objektet som genereras genom att köra en uppsättning tester för "
"rapporteringsändamål; en :class:`TestResult`-instans returneras av :meth:"
"`TestRunner.run`-metoden för detta ändamål."

#: ../../library/unittest.rst:2056
msgid ""
":class:`TestResult` instances have the following attributes that will be of "
"interest when inspecting the results of running a set of tests:"
msgstr ""
":class:`TestResult`-instanser har följande attribut som är av intresse när "
"man granskar resultatet av en uppsättning tester:"

#: ../../library/unittest.rst:2062
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks. Each tuple represents a test which raised an "
"unexpected exception."
msgstr ""
"En lista som innehåller 2-tupler av :class:`TestCase`-instanser och strängar "
"som innehåller formaterade spårningar. Varje tupel representerar ett test "
"som gav upphov till ett oväntat undantag."

#: ../../library/unittest.rst:2068
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks. Each tuple represents a test where a failure "
"was explicitly signalled using the :ref:`assert\\* methods <assert-methods>`."
msgstr ""
"En lista som innehåller 2-tupler av :class:`TestCase`-instanser och strängar "
"som innehåller formaterade spårningar. Varje tupel representerar ett test "
"där ett fel uttryckligen signalerades med hjälp av :ref:`assert\\*-metoderna "
"<assert-methods>`."

#: ../../library/unittest.rst:2074
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding the reason for skipping the test."
msgstr ""
"En lista som innehåller 2-tupel av :class:`TestCase`-instanser och strängar "
"som anger orsaken till att testet hoppar över."

#: ../../library/unittest.rst:2081
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks.  Each tuple represents an expected failure or "
"error of the test case."
msgstr ""
"En lista som innehåller 2-tupler av :class:`TestCase`-instanser och strängar "
"som innehåller formaterade spårningar.  Varje tupel representerar ett "
"förväntat misslyckande eller fel i testfallet."

#: ../../library/unittest.rst:2087
msgid ""
"A list containing :class:`TestCase` instances that were marked as expected "
"failures, but succeeded."
msgstr ""
"En lista som innehåller :class:`TestCase`-instanser som var markerade som "
"förväntade misslyckanden, men som lyckades."

#: ../../library/unittest.rst:2092
msgid ""
"A list containing 2-tuples of test case names and floats representing the "
"elapsed time of each test which was run."
msgstr ""
"En lista som innehåller 2-tuples av testfallsnamn och floats som "
"representerar den förflutna tiden för varje test som kördes."

#: ../../library/unittest.rst:2099
msgid ""
"Set to ``True`` when the execution of tests should stop by :meth:`stop`."
msgstr "Sätts till ``True`` när testkörningen ska stoppas med :meth:`stop`."

#: ../../library/unittest.rst:2103
msgid "The total number of tests run so far."
msgstr "Det totala antalet tester som körts hittills."

#: ../../library/unittest.rst:2107
msgid ""
"If set to true, ``sys.stdout`` and ``sys.stderr`` will be buffered in "
"between :meth:`startTest` and :meth:`stopTest` being called. Collected "
"output will only be echoed onto the real ``sys.stdout`` and ``sys.stderr`` "
"if the test fails or errors. Any output is also attached to the failure / "
"error message."
msgstr ""
"Om inställningen är true kommer ``sys.stdout`` och ``sys.stderr`` att "
"buffras mellan anropen av :meth:`startTest` och :meth:`stopTest`. Insamlad "
"utdata kommer endast att ekas till de riktiga ``sys.stdout`` och ``sys."
"stderr`` om testet misslyckas eller felar. Alla utdata bifogas också till "
"felmeddelandet."

#: ../../library/unittest.rst:2116
msgid ""
"If set to true :meth:`stop` will be called on the first failure or error, "
"halting the test run."
msgstr ""
"Om inställningen är true kommer :meth:`stop` att anropas vid det första "
"misslyckandet eller felet, vilket stoppar testkörningen."

#: ../../library/unittest.rst:2123
msgid "If set to true then local variables will be shown in tracebacks."
msgstr "Om värdet är true kommer lokala variabler att visas i spårningar."

#: ../../library/unittest.rst:2129
msgid ""
"Return ``True`` if all tests run so far have passed, otherwise returns "
"``False``."
msgstr ""
"Returnerar ``True`` om alla tester som körts hittills har godkänts, annars "
"returneras ``False``."

#: ../../library/unittest.rst:2132
msgid ""
"Returns ``False`` if there were any :attr:`unexpectedSuccesses` from tests "
"marked with the :func:`expectedFailure` decorator."
msgstr ""
"Returnerar ``False`` om det fanns några :attr:`unexpectedSuccesses` från "
"tester markerade med :func:`expectedFailure` dekoratorn."

#: ../../library/unittest.rst:2138
msgid ""
"This method can be called to signal that the set of tests being run should "
"be aborted by setting the :attr:`shouldStop` attribute to ``True``. :class:"
"`TestRunner` objects should respect this flag and return without running any "
"additional tests."
msgstr ""
"Denna metod kan anropas för att signalera att den uppsättning tester som "
"körs bör avbrytas genom att sätta attributet :attr:`shouldStop` till "
"``True``. :class:`TestRunner`-objekt bör respektera denna flagga och "
"återvända utan att köra några ytterligare tester."

#: ../../library/unittest.rst:2143
msgid ""
"For example, this feature is used by the :class:`TextTestRunner` class to "
"stop the test framework when the user signals an interrupt from the "
"keyboard.  Interactive tools which provide :class:`TestRunner` "
"implementations can use this in a similar manner."
msgstr ""
"Den här funktionen används t.ex. av klassen :class:`TextTestRunner` för att "
"stoppa testramverket när användaren signalerar ett avbrott från "
"tangentbordet.  Interaktiva verktyg som tillhandahåller :class:`TestRunner`-"
"implementationer kan använda detta på liknande sätt."

#: ../../library/unittest.rst:2148
msgid ""
"The following methods of the :class:`TestResult` class are used to maintain "
"the internal data structures, and may be extended in subclasses to support "
"additional reporting requirements.  This is particularly useful in building "
"tools which support interactive reporting while tests are being run."
msgstr ""
"Följande metoder i klassen :class:`TestResult` används för att underhålla de "
"interna datastrukturerna och kan utökas i underklasser för att stödja "
"ytterligare rapporteringskrav.  Detta är särskilt användbart för att bygga "
"verktyg som stöder interaktiv rapportering medan tester körs."

#: ../../library/unittest.rst:2156
msgid "Called when the test case *test* is about to be run."
msgstr "Anropas när testfallet *test* ska köras."

#: ../../library/unittest.rst:2160
msgid ""
"Called after the test case *test* has been executed, regardless of the "
"outcome."
msgstr "Anropas efter att testfallet *test* har utförts, oavsett resultat."

#: ../../library/unittest.rst:2165
msgid "Called once before any tests are executed."
msgstr "Anropas en gång innan några tester utförs."

#: ../../library/unittest.rst:2172
msgid "Called once after all tests are executed."
msgstr "Anropas en gång efter att alla tester har utförts."

#: ../../library/unittest.rst:2179
msgid ""
"Called when the test case *test* raises an unexpected exception. *err* is a "
"tuple of the form returned by :func:`sys.exc_info`: ``(type, value, "
"traceback)``."
msgstr ""
"Anropas när testfallet *test* ger upphov till ett oväntat undantag. *err* är "
"en tupel av den form som returneras av :func:`sys.exc_info`: ``(type, value, "
"traceback)``."

#: ../../library/unittest.rst:2183
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`errors` attribute, where *formatted_err* is a formatted "
"traceback derived from *err*."
msgstr ""
"Standardimplementeringen lägger till en tupel ``(test, formatted_err)`` till "
"instansens attribut :attr:`errors`, där *formatted_err* är en formaterad "
"återgång som härrör från *err*."

#: ../../library/unittest.rst:2190
msgid ""
"Called when the test case *test* signals a failure. *err* is a tuple of the "
"form returned by :func:`sys.exc_info`: ``(type, value, traceback)``."
msgstr ""
"Anropas när testfallet *test* signalerar ett misslyckande. *err* är en tupel "
"av den form som returneras av :func:`sys.exc_info`: ``(type, value, "
"traceback)``."

#: ../../library/unittest.rst:2193
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`failures` attribute, where *formatted_err* is a formatted "
"traceback derived from *err*."
msgstr ""
"Standardimplementeringen lägger till en tupel ``(test, formatted_err)`` till "
"instansens attribut :attr:`failures`, där *formatted_err* är en formaterad "
"återgång som härrör från *err*."

#: ../../library/unittest.rst:2200
msgid "Called when the test case *test* succeeds."
msgstr "Anropas när testfallet *test* lyckas."

#: ../../library/unittest.rst:2202
msgid "The default implementation does nothing."
msgstr "Standardimplementeringen gör ingenting."

#: ../../library/unittest.rst:2207
msgid ""
"Called when the test case *test* is skipped.  *reason* is the reason the "
"test gave for skipping."
msgstr ""
"Anropas när testfallet *test* hoppar över.  *reason* är den anledning som "
"testet angav för att hoppa över."

#: ../../library/unittest.rst:2210
msgid ""
"The default implementation appends a tuple ``(test, reason)`` to the "
"instance's :attr:`skipped` attribute."
msgstr ""
"Standardimplementeringen lägger till en tupel ``(test, reason)`` till "
"instansens attribut :attr:`skipped`."

#: ../../library/unittest.rst:2216
msgid ""
"Called when the test case *test* fails or errors, but was marked with the :"
"func:`expectedFailure` decorator."
msgstr ""
"Anropas när testfallet *test* misslyckas eller felar, men var markerat med :"
"func:`expectedFailure`-dekoratorn."

#: ../../library/unittest.rst:2219
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`expectedFailures` attribute, where *formatted_err* is a "
"formatted traceback derived from *err*."
msgstr ""
"Standardimplementeringen lägger till en tupel ``(test, formatted_err)`` till "
"instansens attribut :attr:`expectedFailures`, där *formatted_err* är en "
"formaterad återgång som härrör från *err*."

#: ../../library/unittest.rst:2226
msgid ""
"Called when the test case *test* was marked with the :func:`expectedFailure` "
"decorator, but succeeded."
msgstr ""
"Anropas när testfallet *test* markerades med dekoratorn :func:"
"`expectedFailure`, men lyckades."

#: ../../library/unittest.rst:2229
msgid ""
"The default implementation appends the test to the instance's :attr:"
"`unexpectedSuccesses` attribute."
msgstr ""
"Standardimplementeringen lägger till testet till instansens attribut :attr:"
"`unexpectedSuccesses`."

#: ../../library/unittest.rst:2235
msgid ""
"Called when a subtest finishes.  *test* is the test case corresponding to "
"the test method.  *subtest* is a custom :class:`TestCase` instance "
"describing the subtest."
msgstr ""
"Anropas när ett deltest är avslutat.  *test* är det testfall som motsvarar "
"testmetoden.  *subtest* är en anpassad :class:`TestCase`-instans som "
"beskriver subtestet."

#: ../../library/unittest.rst:2239
msgid ""
"If *outcome* is :const:`None`, the subtest succeeded.  Otherwise, it failed "
"with an exception where *outcome* is a tuple of the form returned by :func:"
"`sys.exc_info`: ``(type, value, traceback)``."
msgstr ""
"Om *outcome* är :const:`None`, lyckades deltestet.  Annars misslyckades det "
"med ett undantag där *outcome* är en tupel av den form som returneras av :"
"func:`sys.exc_info`: ``(type, value, traceback)``."

#: ../../library/unittest.rst:2243
msgid ""
"The default implementation does nothing when the outcome is a success, and "
"records subtest failures as normal failures."
msgstr ""
"Standardimplementeringen gör ingenting när resultatet är en framgång, och "
"registrerar misslyckade deltest som normala misslyckanden."

#: ../../library/unittest.rst:2250
msgid ""
"Called when the test case finishes.  *elapsed* is the time represented in "
"seconds, and it includes the execution of cleanup functions."
msgstr ""
"Anropas när testfallet är avslutat.  *elapsed* är tiden i sekunder och "
"inkluderar exekvering av rensningsfunktioner."

#: ../../library/unittest.rst:2257
msgid ""
"A concrete implementation of :class:`TestResult` used by the :class:"
"`TextTestRunner`. Subclasses should accept ``**kwargs`` to ensure "
"compatibility as the interface changes."
msgstr ""
"En konkret implementation av :class:`TestResult` som används av :class:"
"`TextTestRunner`. Underklasser bör acceptera ``**kwargs`` för att "
"säkerställa kompatibilitet när gränssnittet ändras."

#: ../../library/unittest.rst:2263
msgid "Added the *durations* keyword parameter."
msgstr "Nyckelordsparametern *durations* har lagts till."

#: ../../library/unittest.rst:2268
msgid ""
"Instance of the :class:`TestLoader` class intended to be shared.  If no "
"customization of the :class:`TestLoader` is needed, this instance can be "
"used instead of repeatedly creating new instances."
msgstr ""
"Instans av klassen :class:`TestLoader` som är avsedd att delas.  Om ingen "
"anpassning av :class:`TestLoader` behövs, kan denna instans användas "
"istället för att upprepade gånger skapa nya instanser."

#: ../../library/unittest.rst:2277
msgid ""
"A basic test runner implementation that outputs results to a stream. If "
"*stream* is ``None``, the default, :data:`sys.stderr` is used as the output "
"stream. This class has a few configurable parameters, but is essentially "
"very simple.  Graphical applications which run test suites should provide "
"alternate implementations. Such implementations should accept ``**kwargs`` "
"as the interface to construct runners changes when features are added to "
"unittest."
msgstr ""
"En grundläggande implementering av en testlöpare som matar ut resultat till "
"en ström. Om *stream* är ``None`` används standardvärdet :data:`sys.stderr` "
"som utdataflöde. Den här klassen har några konfigurerbara parametrar, men är "
"i grunden mycket enkel.  Grafiska applikationer som kör testsviter bör "
"tillhandahålla alternativa implementationer. Sådana implementationer bör "
"acceptera ``**kwargs`` eftersom gränssnittet för att konstruera löpare "
"ändras när funktioner läggs till i unittest."

#: ../../library/unittest.rst:2284
msgid ""
"By default this runner shows :exc:`DeprecationWarning`, :exc:"
"`PendingDeprecationWarning`, :exc:`ResourceWarning` and :exc:`ImportWarning` "
"even if they are :ref:`ignored by default <warning-ignored>`.  This behavior "
"can be overridden using Python's :option:`!-Wd` or :option:`!-Wa` options "
"(see :ref:`Warning control <using-on-warnings>`) and leaving *warnings* to "
"``None``."
msgstr ""
"Som standard visar den här löparen :exc:`DeprecationWarning`, :exc:"
"`PendingDeprecationWarning`, :exc:`ResourceWarning` och :exc:`ImportWarning` "
"även om de är :ref:`ignorerade som standard <warning-ignored>`.  Detta "
"beteende kan åsidosättas genom att använda Pythons :option:`!-Wd` eller :"
"option:`!-Wa` (se :ref:`Warning control <using-on-warnings>`) och lämna "
"*warnings* till ``None``."

#: ../../library/unittest.rst:2292
msgid "Added the *warnings* parameter."
msgstr "Parametern *warnings* har lagts till."

#: ../../library/unittest.rst:2295
msgid ""
"The default stream is set to :data:`sys.stderr` at instantiation time rather "
"than import time."
msgstr ""
"Standardströmmen är inställd på :data:`sys.stderr` vid instantiering "
"istället för vid import."

#: ../../library/unittest.rst:2299
msgid "Added the *tb_locals* parameter."
msgstr "Parametern *tb_locals* har lagts till."

#: ../../library/unittest.rst:2302
msgid "Added the *durations* parameter."
msgstr "Parametern *durations* har lagts till."

#: ../../library/unittest.rst:2307
msgid ""
"This method returns the instance of ``TestResult`` used by :meth:`run`. It "
"is not intended to be called directly, but can be overridden in subclasses "
"to provide a custom ``TestResult``."
msgstr ""
"Denna metod returnerar den instans av ``TestResult`` som används av :meth:"
"`run`. Den är inte avsedd att anropas direkt, men kan åsidosättas i "
"subklasser för att tillhandahålla ett eget ``TestResult``."

#: ../../library/unittest.rst:2311
msgid ""
"``_makeResult()`` instantiates the class or callable passed in the "
"``TextTestRunner`` constructor as the ``resultclass`` argument. It defaults "
"to :class:`TextTestResult` if no ``resultclass`` is provided. The result "
"class is instantiated with the following arguments::"
msgstr ""
"``_makeResult()`` instansierar klassen eller anropsbarheten som skickas i "
"``TextTestRunner`` konstruktören som ``resultclass`` argument. "
"Standardvärdet är :class:`TextTestResult` om ingen ``resultclass`` anges. "
"Resultatklassen instansieras med följande argument::"

#: ../../library/unittest.rst:2316
msgid "stream, descriptions, verbosity"
msgstr "stream, descriptions, verbosity"

#: ../../library/unittest.rst:2320
msgid ""
"This method is the main public interface to the ``TextTestRunner``. This "
"method takes a :class:`TestSuite` or :class:`TestCase` instance. A :class:"
"`TestResult` is created by calling :func:`_makeResult` and the test(s) are "
"run and the results printed to stdout."
msgstr ""
"Denna metod är det huvudsakliga publika gränssnittet till "
"``TextTestRunner``. Denna metod tar en :class:`TestSuite` eller :class:"
"`TestCase` instans. Ett :class:`TestResult` skapas genom att anropa :func:"
"`_makeResult` och testet(en) körs och resultaten skrivs ut till stdout."

#: ../../library/unittest.rst:2331
msgid ""
"A command-line program that loads a set of tests from *module* and runs "
"them; this is primarily for making test modules conveniently executable. The "
"simplest use for this function is to include the following line at the end "
"of a test script::"
msgstr ""
"Ett kommandoradsprogram som laddar en uppsättning tester från *modul* och "
"kör dem; detta är främst till för att göra testmoduler praktiskt körbara. "
"Den enklaste användningen av denna funktion är att inkludera följande rad i "
"slutet av ett testskript::"

#: ../../library/unittest.rst:2336
msgid ""
"if __name__ == '__main__':\n"
"    unittest.main()"
msgstr ""
"if __name__ == '__main__':\n"
"    unittest.main()"

#: ../../library/unittest.rst:2339
msgid ""
"You can run tests with more detailed information by passing in the verbosity "
"argument::"
msgstr ""
"Du kan köra tester med mer detaljerad information genom att ange argumentet "
"verbosity::"

#: ../../library/unittest.rst:2342
msgid ""
"if __name__ == '__main__':\n"
"    unittest.main(verbosity=2)"
msgstr ""
"if __name__ == '__main__':\n"
"    unittest.main(ordrikhet=2)"

#: ../../library/unittest.rst:2345
msgid ""
"The *defaultTest* argument is either the name of a single test or an "
"iterable of test names to run if no test names are specified via *argv*.  If "
"not specified or ``None`` and no test names are provided via *argv*, all "
"tests found in *module* are run."
msgstr ""
"Argumentet *defaultTest* är antingen namnet på ett enskilt test eller en "
"iterabel med testnamn som ska köras om inga testnamn anges via *argv*.  Om "
"det inte specificeras eller ``None`` och inga testnamn anges via *argv*, "
"körs alla tester som finns i *module*."

#: ../../library/unittest.rst:2350
msgid ""
"The *argv* argument can be a list of options passed to the program, with the "
"first element being the program name.  If not specified or ``None``, the "
"values of :data:`sys.argv` are used."
msgstr ""
"Argumentet *argv* kan vara en lista med alternativ som skickas till "
"programmet, där det första elementet är programnamnet.  Om inget anges eller "
"``None``, används värdena i :data:`sys.argv`."

#: ../../library/unittest.rst:2354
msgid ""
"The *testRunner* argument can either be a test runner class or an already "
"created instance of it. By default ``main`` calls :func:`sys.exit` with an "
"exit code indicating success (0) or failure (1) of the tests run. An exit "
"code of 5 indicates that no tests were run or skipped."
msgstr ""
"Argumentet *testRunner* kan antingen vara en testlöparklass eller en redan "
"skapad instans av den. Som standard anropar ``main`` :func:`sys.exit` med en "
"utgångskod som anger om testerna som körts lyckades (0) eller misslyckades "
"(1). En exit-kod på 5 anger att inga tester kördes eller att de hoppades "
"över."

#: ../../library/unittest.rst:2359
msgid ""
"The *testLoader* argument has to be a :class:`TestLoader` instance, and "
"defaults to :data:`defaultTestLoader`."
msgstr ""
"Argumentet *testLoader* måste vara en instans av :class:`TestLoader`, och "
"standardvärdet är :data:`defaultTestLoader`."

#: ../../library/unittest.rst:2362
msgid ""
"``main`` supports being used from the interactive interpreter by passing in "
"the argument ``exit=False``. This displays the result on standard output "
"without calling :func:`sys.exit`::"
msgstr ""
"``main`` kan användas från den interaktiva tolken genom att skicka in "
"argumentet ``exit=False``. Detta visar resultatet på standardutmatningen "
"utan att anropa :func:`sys.exit`::"

#: ../../library/unittest.rst:2366
msgid ""
">>> from unittest import main\n"
">>> main(module='test_module', exit=False)"
msgstr ""
">>> from unittest import main\n"
">>> main(module='test_module', exit=False)"

#: ../../library/unittest.rst:2369
msgid ""
"The *failfast*, *catchbreak* and *buffer* parameters have the same effect as "
"the same-name `command-line options`_."
msgstr ""
"Parametrarna *failfast*, *catchbreak* och *buffer* har samma effekt som "
"`kommandoradsalternativen`_ med samma namn."

#: ../../library/unittest.rst:2372
msgid ""
"The *warnings* argument specifies the :ref:`warning filter <warning-filter>` "
"that should be used while running the tests.  If it's not specified, it will "
"remain ``None`` if a :option:`!-W` option is passed to :program:`python` "
"(see :ref:`Warning control <using-on-warnings>`), otherwise it will be set "
"to ``'default'``."
msgstr ""
"Argumentet *warnings* anger det :ref:`varningsfilter <warning-filter>` som "
"ska användas när testerna körs.  Om det inte anges kommer det att förbli "
"``None`` om ett :option:`!-W`-alternativ skickas till :program:`python` (se :"
"ref:`Warning control <using-on-warnings>`), annars kommer det att sättas "
"till ``'default'``."

#: ../../library/unittest.rst:2378
msgid ""
"Calling ``main`` returns an object with the ``result`` attribute that "
"contains the result of the tests run as a :class:`unittest.TestResult`."
msgstr ""
"Anrop av ``main`` returnerar ett objekt med attributet ``result`` som "
"innehåller resultatet av de tester som körts som en :class:`unittest."
"TestResult`."

#: ../../library/unittest.rst:2381
msgid "The *exit* parameter was added."
msgstr "Parametern *exit* har lagts till."

#: ../../library/unittest.rst:2384
msgid ""
"The *verbosity*, *failfast*, *catchbreak*, *buffer* and *warnings* "
"parameters were added."
msgstr ""
"Parametrarna *verbosity*, *failfast*, *catchbreak*, *buffer* och *warnings* "
"har lagts till."

#: ../../library/unittest.rst:2388
msgid ""
"The *defaultTest* parameter was changed to also accept an iterable of test "
"names."
msgstr ""
"Parametern *defaultTest* har ändrats så att den även accepterar en iterabel "
"med testnamn."

#: ../../library/unittest.rst:2396
msgid "load_tests Protocol"
msgstr "load_tests Protokoll"

#: ../../library/unittest.rst:2400
msgid ""
"Modules or packages can customize how tests are loaded from them during "
"normal test runs or test discovery by implementing a function called "
"``load_tests``."
msgstr ""
"Moduler eller paket kan anpassa hur tester laddas från dem under normala "
"testkörningar eller testupptäckt genom att implementera en funktion som "
"heter ``load_tests``."

#: ../../library/unittest.rst:2403
msgid ""
"If a test module defines ``load_tests`` it will be called by :meth:"
"`TestLoader.loadTestsFromModule` with the following arguments::"
msgstr ""
"Om en testmodul definierar ``load_tests`` kommer den att anropas av :meth:"
"`TestLoader.loadTestsFromModule` med följande argument::"

#: ../../library/unittest.rst:2406 ../../library/unittest.rst:2438
msgid "load_tests(loader, standard_tests, pattern)"
msgstr "load_tests(loader, standard_tests, pattern)"

#: ../../library/unittest.rst:2408
msgid ""
"where *pattern* is passed straight through from ``loadTestsFromModule``.  It "
"defaults to ``None``."
msgstr ""
"där *mönster* skickas rakt igenom från ``loadTestsFromModule``.  "
"Standardvärdet är ``None``."

#: ../../library/unittest.rst:2411
msgid "It should return a :class:`TestSuite`."
msgstr "Den bör returnera en :class:`TestSuite`."

#: ../../library/unittest.rst:2413
msgid ""
"*loader* is the instance of :class:`TestLoader` doing the loading. "
"*standard_tests* are the tests that would be loaded by default from the "
"module. It is common for test modules to only want to add or remove tests "
"from the standard set of tests. The third argument is used when loading "
"packages as part of test discovery."
msgstr ""
"*loader* är den instans av :class:`TestLoader` som gör inläsningen. "
"*standard_tests* är de tester som laddas som standard från modulen. Det är "
"vanligt att testmoduler bara vill lägga till eller ta bort tester från "
"standarduppsättningen av tester. Det tredje argumentet används när paket "
"laddas som en del av testupptäckten."

#: ../../library/unittest.rst:2419
msgid ""
"A typical ``load_tests`` function that loads tests from a specific set of :"
"class:`TestCase` classes may look like::"
msgstr ""
"En typisk ``load_tests``-funktion som laddar tester från en specifik "
"uppsättning :class:`TestCase`-klasser kan se ut på följande sätt::"

#: ../../library/unittest.rst:2422
msgid ""
"test_cases = (TestCase1, TestCase2, TestCase3)\n"
"\n"
"def load_tests(loader, tests, pattern):\n"
"    suite = TestSuite()\n"
"    for test_class in test_cases:\n"
"        tests = loader.loadTestsFromTestCase(test_class)\n"
"        suite.addTests(tests)\n"
"    return suite"
msgstr ""
"test_cases = (TestCase1, TestCase2, TestCase3)\n"
"\n"
"def load_tests(loader, tests, pattern):\n"
"    suite = TestSuite()\n"
"    for test_class in test_cases:\n"
"        tests = loader.loadTestsFromTestCase(test_class)\n"
"        suite.addTests(tests)\n"
"    return suite"

#: ../../library/unittest.rst:2431
msgid ""
"If discovery is started in a directory containing a package, either from the "
"command line or by calling :meth:`TestLoader.discover`, then the package :"
"file:`__init__.py` will be checked for ``load_tests``.  If that function "
"does not exist, discovery will recurse into the package as though it were "
"just another directory.  Otherwise, discovery of the package's tests will be "
"left up to ``load_tests`` which is called with the following arguments::"
msgstr ""
"Om discovery startas i en katalog som innehåller ett paket, antingen från "
"kommandoraden eller genom att anropa :meth:`TestLoader.discover`, kommer "
"paketet :file:`__init__.py` att kontrolleras med avseende på "
"``load_tests``.  Om den funktionen inte finns kommer discovery att rekursera "
"i paketet som om det vore en katalog.  Annars kommer upptäckten av paketets "
"tester att överlåtas till ``load_tests`` som anropas med följande argument::"

#: ../../library/unittest.rst:2440
msgid ""
"This should return a :class:`TestSuite` representing all the tests from the "
"package. (``standard_tests`` will only contain tests collected from :file:"
"`__init__.py`.)"
msgstr ""
"Detta bör returnera en :class:`TestSuite` som representerar alla tester från "
"paketet. (``standard_tests`` kommer endast att innehålla tester som hämtats "
"från :file:`__init__.py`.)"

#: ../../library/unittest.rst:2444
msgid ""
"Because the pattern is passed into ``load_tests`` the package is free to "
"continue (and potentially modify) test discovery. A 'do nothing' "
"``load_tests`` function for a test package would look like::"
msgstr ""
"Eftersom mönstret skickas in i ``load_tests`` är paketet fritt att fortsätta "
"(och eventuellt modifiera) testupptäckten. En \"gör ingenting\" "
"``load_tests`` funktion för ett testpaket skulle se ut som::"

#: ../../library/unittest.rst:2448
msgid ""
"def load_tests(loader, standard_tests, pattern):\n"
"    # top level directory cached on loader instance\n"
"    this_dir = os.path.dirname(__file__)\n"
"    package_tests = loader.discover(start_dir=this_dir, pattern=pattern)\n"
"    standard_tests.addTests(package_tests)\n"
"    return standard_tests"
msgstr ""
"def load_tests(loader, standard_tests, pattern):\n"
"    # top level directory cached on loader instance\n"
"    this_dir = os.path.dirname(__file__)\n"
"    package_tests = loader.discover(start_dir=this_dir, pattern=pattern)\n"
"    standard_tests.addTests(package_tests)\n"
"    return standard_tests"

#: ../../library/unittest.rst:2455
msgid ""
"Discovery no longer checks package names for matching *pattern* due to the "
"impossibility of package names matching the default pattern."
msgstr ""
"Discovery kontrollerar inte längre om paketnamn matchar *pattern* eftersom "
"det är omöjligt att paketnamn matchar standardmönstret."

#: ../../library/unittest.rst:2462
msgid "Class and Module Fixtures"
msgstr "Klass- och modulfixturer"

#: ../../library/unittest.rst:2464
msgid ""
"Class and module level fixtures are implemented in :class:`TestSuite`. When "
"the test suite encounters a test from a new class then :meth:`tearDownClass` "
"from the previous class (if there is one) is called, followed by :meth:"
"`setUpClass` from the new class."
msgstr ""
"Fixturer på klass- och modulnivå är implementerade i :class:`TestSuite`. När "
"testsviten stöter på ett test från en ny klass anropas :meth:`tearDownClass` "
"från den tidigare klassen (om det finns en sådan), följt av :meth:"
"`setUpClass` från den nya klassen."

#: ../../library/unittest.rst:2469
msgid ""
"Similarly if a test is from a different module from the previous test then "
"``tearDownModule`` from the previous module is run, followed by "
"``setUpModule`` from the new module."
msgstr ""
"På samma sätt om ett test är från en annan modul än det föregående testet så "
"körs ``tearDownModule`` från den föregående modulen, följt av "
"``setUpModule`` från den nya modulen."

#: ../../library/unittest.rst:2473
msgid ""
"After all the tests have run the final ``tearDownClass`` and "
"``tearDownModule`` are run."
msgstr ""
"Efter att alla tester har körts körs de slutliga ``tearDownClass`` och "
"``tearDownModule``."

#: ../../library/unittest.rst:2476
msgid ""
"Note that shared fixtures do not play well with [potential] features like "
"test parallelization and they break test isolation. They should be used with "
"care."
msgstr ""
"Observera att delade fixturer inte fungerar bra med [potentiella] funktioner "
"som testparallellisering och att de bryter testisolering. De bör användas "
"med försiktighet."

#: ../../library/unittest.rst:2479
msgid ""
"The default ordering of tests created by the unittest test loaders is to "
"group all tests from the same modules and classes together. This will lead "
"to ``setUpClass`` / ``setUpModule`` (etc) being called exactly once per "
"class and module. If you randomize the order, so that tests from different "
"modules and classes are adjacent to each other, then these shared fixture "
"functions may be called multiple times in a single test run."
msgstr ""
"Standardordningen för tester som skapas av unittests testladdare är att "
"gruppera alla tester från samma moduler och klasser tillsammans. Detta "
"kommer att leda till att ``setUpClass`` / ``setUpModule`` (etc) anropas "
"exakt en gång per klass och modul. Om du slumpar ordningen, så att tester "
"från olika moduler och klasser ligger intill varandra, kan dessa delade "
"fixture-funktioner anropas flera gånger under en enda testkörning."

#: ../../library/unittest.rst:2486
msgid ""
"Shared fixtures are not intended to work with suites with non-standard "
"ordering. A ``BaseTestSuite`` still exists for frameworks that don't want to "
"support shared fixtures."
msgstr ""
"Delade fixturer är inte avsedda att fungera med sviter med icke-"
"standardiserad ordningsföljd. En ``BaseTestSuite`` finns fortfarande för "
"ramverk som inte vill stödja delade fixturer."

#: ../../library/unittest.rst:2490
msgid ""
"If there are any exceptions raised during one of the shared fixture "
"functions the test is reported as an error. Because there is no "
"corresponding test instance an ``_ErrorHolder`` object (that has the same "
"interface as a :class:`TestCase`) is created to represent the error. If you "
"are just using the standard unittest test runner then this detail doesn't "
"matter, but if you are a framework author it may be relevant."
msgstr ""
"Om det uppstår några undantag under någon av de delade fixturfunktionerna "
"rapporteras testet som ett fel. Eftersom det inte finns någon motsvarande "
"testinstans skapas ett ``_ErrorHolder``-objekt (som har samma gränssnitt som "
"ett :class:`TestCase`) för att representera felet. Om du bara använder "
"standardtestköraren unittest spelar den här detaljen ingen roll, men om du "
"är ramverksförfattare kan det vara relevant."

#: ../../library/unittest.rst:2499
msgid "setUpClass and tearDownClass"
msgstr "setUpClass och tearDownClass"

#: ../../library/unittest.rst:2501
msgid "These must be implemented as class methods::"
msgstr "Dessa måste implementeras som klassmetoder::"

#: ../../library/unittest.rst:2503
msgid ""
"import unittest\n"
"\n"
"class Test(unittest.TestCase):\n"
"    @classmethod\n"
"    def setUpClass(cls):\n"
"        cls._connection = createExpensiveConnectionObject()\n"
"\n"
"    @classmethod\n"
"    def tearDownClass(cls):\n"
"        cls._connection.destroy()"
msgstr ""
"import unittest\n"
"\n"
"class Test(unittest.TestCase):\n"
"    @classmethod\n"
"    def setUpClass(cls):\n"
"        cls._connection = createExpensiveConnectionObject()\n"
"\n"
"    @classmethod\n"
"    def tearDownClass(cls):\n"
"        cls._connection.destroy()"

#: ../../library/unittest.rst:2514
msgid ""
"If you want the ``setUpClass`` and ``tearDownClass`` on base classes called "
"then you must call up to them yourself. The implementations in :class:"
"`TestCase` are empty."
msgstr ""
"Om du vill att ``setUpClass`` och ``tearDownClass`` på basklasser skall "
"anropas måste du själv anropa dem. Implementationerna i :class:`TestCase` är "
"tomma."

#: ../../library/unittest.rst:2518
msgid ""
"If an exception is raised during a ``setUpClass`` then the tests in the "
"class are not run and the ``tearDownClass`` is not run. Skipped classes will "
"not have ``setUpClass`` or ``tearDownClass`` run. If the exception is a :exc:"
"`SkipTest` exception then the class will be reported as having been skipped "
"instead of as an error."
msgstr ""
"Om ett undantag uppstår under en ``setUpClass`` så körs inte testerna i "
"klassen och ``tearDownClass`` körs inte. Klasser som hoppats över kommer "
"inte att få ``setUpClass`` eller ``tearDownClass`` körda. Om undantaget är "
"ett :exc:`SkipTest`-undantag kommer klassen att rapporteras som att den har "
"hoppats över istället för som ett fel."

#: ../../library/unittest.rst:2526
msgid "setUpModule and tearDownModule"
msgstr "setUpModule och tearDownModule"

#: ../../library/unittest.rst:2528
msgid "These should be implemented as functions::"
msgstr "Dessa bör implementeras som funktioner::"

#: ../../library/unittest.rst:2530
msgid ""
"def setUpModule():\n"
"    createConnection()\n"
"\n"
"def tearDownModule():\n"
"    closeConnection()"
msgstr ""
"def setUpModule():\n"
"    createConnection()\n"
"\n"
"def tearDownModule():\n"
"    closeConnection()"

#: ../../library/unittest.rst:2536
msgid ""
"If an exception is raised in a ``setUpModule`` then none of the tests in the "
"module will be run and the ``tearDownModule`` will not be run. If the "
"exception is a :exc:`SkipTest` exception then the module will be reported as "
"having been skipped instead of as an error."
msgstr ""
"Om ett undantag uppstår i en ``setUpModule`` kommer inget av testerna i "
"modulen att köras och ``tearDownModule`` kommer inte att köras. Om "
"undantaget är ett :exc:`SkipTest`-undantag kommer modulen att rapporteras "
"som att den har hoppats över istället för som ett fel."

#: ../../library/unittest.rst:2541
msgid ""
"To add cleanup code that must be run even in the case of an exception, use "
"``addModuleCleanup``:"
msgstr ""
"Om du vill lägga till uppstädningskod som måste köras även vid undantag "
"använder du ``addModuleCleanup``:"

#: ../../library/unittest.rst:2547
msgid ""
"Add a function to be called after :func:`tearDownModule` to cleanup "
"resources used during the test class. Functions will be called in reverse "
"order to the order they are added (:abbr:`LIFO (last-in, first-out)`). They "
"are called with any arguments and keyword arguments passed into :meth:"
"`addModuleCleanup` when they are added."
msgstr ""
"Lägg till en funktion som ska anropas efter :func:`tearDownModule` för att "
"städa upp resurser som använts under testklassen. Funktioner kommer att "
"anropas i omvänd ordning mot den ordning de läggs till (:abbr:`LIFO (sist "
"in, först ut)`). De anropas med alla argument och nyckelordsargument som "
"skickas in i :meth:`addModuleCleanup` när de läggs till."

#: ../../library/unittest.rst:2553
msgid ""
"If :meth:`setUpModule` fails, meaning that :func:`tearDownModule` is not "
"called, then any cleanup functions added will still be called."
msgstr ""
"Om :meth:`setUpModule` misslyckas, vilket innebär att :func:`tearDownModule` "
"inte anropas, så kommer eventuella cleanup-funktioner som lagts till ändå "
"att anropas."

#: ../../library/unittest.rst:2561
msgid ""
"Enter the supplied :term:`context manager`.  If successful, also add its :"
"meth:`~object.__exit__` method as a cleanup function by :func:"
"`addModuleCleanup` and return the result of the :meth:`~object.__enter__` "
"method."
msgstr ""
"Ange den medföljande :term:`context manager`.  Om det lyckas, lägg även till "
"dess :meth:`~object.__exit__`-metod som en uppstädningsfunktion med :func:"
"`addModuleCleanup` och returnera resultatet av :meth:`~object.__enter__`-"
"metoden."

#: ../../library/unittest.rst:2571
msgid ""
"This function is called unconditionally after :func:`tearDownModule`, or "
"after :func:`setUpModule` if :func:`setUpModule` raises an exception."
msgstr ""
"Denna funktion anropas ovillkorligen efter :func:`tearDownModule`, eller "
"efter :func:`setUpModule` om :func:`setUpModule` ger upphov till ett "
"undantag."

#: ../../library/unittest.rst:2574
msgid ""
"It is responsible for calling all the cleanup functions added by :func:"
"`addModuleCleanup`. If you need cleanup functions to be called *prior* to :"
"func:`tearDownModule` then you can call :func:`doModuleCleanups` yourself."
msgstr ""
"Den är ansvarig för att anropa alla upprensningsfunktioner som lagts till "
"av :func:`addModuleCleanup`. Om du vill att rensningsfunktionerna ska "
"anropas *före* :func:`tearDownModule` kan du anropa :func:`doModuleCleanups` "
"själv."

#: ../../library/unittest.rst:2579
msgid ""
":func:`doModuleCleanups` pops methods off the stack of cleanup functions one "
"at a time, so it can be called at any time."
msgstr ""
":func:`doModuleCleanups` plockar bort metoder från stacken med "
"rensningsfunktioner en i taget, så att den kan anropas när som helst."

#: ../../library/unittest.rst:2586
msgid "Signal Handling"
msgstr "Signalhantering"

#: ../../library/unittest.rst:2590
msgid ""
"The :option:`-c/--catch <unittest -c>` command-line option to unittest, "
"along with the ``catchbreak`` parameter to :func:`unittest.main`, provide "
"more friendly handling of control-C during a test run. With catch break "
"behavior enabled control-C will allow the currently running test to "
"complete, and the test run will then end and report all the results so far. "
"A second control-c will raise a :exc:`KeyboardInterrupt` in the usual way."
msgstr ""
"Kommandoradsalternativet :option:`-c/--catch <unittest -c>` till unittest, "
"tillsammans med parametern ``catchbreak`` till :func:`unittest.main`, ger en "
"mer vänlig hantering av kontroll-C under en testkörning. Med catch break-"
"beteendet aktiverat kommer control-C att låta det pågående testet slutföras, "
"och testkörningen kommer sedan att avslutas och rapportera alla resultat så "
"här långt. En andra kontroll-c kommer att ge upphov till en :exc:"
"`KeyboardInterrupt` på vanligt sätt."

#: ../../library/unittest.rst:2597
msgid ""
"The control-c handling signal handler attempts to remain compatible with "
"code or tests that install their own :const:`signal.SIGINT` handler. If the "
"``unittest`` handler is called but *isn't* the installed :const:`signal."
"SIGINT` handler, i.e. it has been replaced by the system under test and "
"delegated to, then it calls the default handler. This will normally be the "
"expected behavior by code that replaces an installed handler and delegates "
"to it. For individual tests that need ``unittest`` control-c handling "
"disabled the :func:`removeHandler` decorator can be used."
msgstr ""
"Signalhanteraren för kontroll-c försöker vara kompatibel med kod eller "
"tester som installerar sin egen :const:`signal.SIGINT`-hanterare. Om "
"``unittest``-hanteraren anropas men *inte* är den installerade :const:"
"`signal.SIGINT`-hanteraren, d.v.s. den har ersatts av systemet som testas "
"och delegerats till, anropas standardhanteraren. Detta är normalt det "
"förväntade beteendet hos kod som ersätter en installerad hanterare och "
"delegerar till den. För enskilda tester som behöver ``unittest`` kontroll-c "
"hantering inaktiverad kan :func:`removeHandler` dekoratorn användas."

#: ../../library/unittest.rst:2606
msgid ""
"There are a few utility functions for framework authors to enable control-c "
"handling functionality within test frameworks."
msgstr ""
"Det finns ett fåtal funktioner för ramverksförfattare som gör det möjligt "
"att hantera kontroll-c-funktioner i testramverk."

#: ../../library/unittest.rst:2611
msgid ""
"Install the control-c handler. When a :const:`signal.SIGINT` is received "
"(usually in response to the user pressing control-c) all registered results "
"have :meth:`~TestResult.stop` called."
msgstr ""
"Installera control-c hanteraren. När en :const:`signal.SIGINT` tas emot "
"(vanligtvis som svar på att användaren trycker på control-c) kommer alla "
"registrerade resultat att anropas :meth:`~TestResult.stop`."

#: ../../library/unittest.rst:2618
msgid ""
"Register a :class:`TestResult` object for control-c handling. Registering a "
"result stores a weak reference to it, so it doesn't prevent the result from "
"being garbage collected."
msgstr ""
"Registrera ett :class:`TestResult`-objekt för kontrollhantering. Genom att "
"registrera ett resultat lagras en svag referens till det, så det hindrar "
"inte att resultatet samlas in i en soptunna."

#: ../../library/unittest.rst:2622
msgid ""
"Registering a :class:`TestResult` object has no side-effects if control-c "
"handling is not enabled, so test frameworks can unconditionally register all "
"results they create independently of whether or not handling is enabled."
msgstr ""
"Registrering av ett :class:`TestResult`-objekt har inga bieffekter om "
"kontroll-c-hantering inte är aktiverad, så testramverk kan ovillkorligen "
"registrera alla resultat de skapar oberoende av om hantering är aktiverad "
"eller inte."

#: ../../library/unittest.rst:2629
msgid ""
"Remove a registered result. Once a result has been removed then :meth:"
"`~TestResult.stop` will no longer be called on that result object in "
"response to a control-c."
msgstr ""
"Ta bort ett registrerat resultat. När ett resultat har tagits bort kommer :"
"meth:`~TestResult.stop` inte längre att anropas på det resultatobjektet som "
"svar på ett kontroll-c."

#: ../../library/unittest.rst:2636
msgid ""
"When called without arguments this function removes the control-c handler if "
"it has been installed. This function can also be used as a test decorator to "
"temporarily remove the handler while the test is being executed::"
msgstr ""
"När den anropas utan argument tar denna funktion bort kontroll-c-hanteraren "
"om den har installerats. Denna funktion kan också användas som en "
"testdekorator för att tillfälligt ta bort hanteraren medan testet körs::"

#: ../../library/unittest.rst:2640
msgid ""
"@unittest.removeHandler\n"
"def test_signal_handling(self):\n"
"    ..."
msgstr ""
"@unittest.removeHandler\n"
"def test_signal_handling(self):\n"
"    ..."
