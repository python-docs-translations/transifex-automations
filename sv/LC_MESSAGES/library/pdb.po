# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-23 14:15+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../library/pdb.rst:4
msgid ":mod:`pdb` --- The Python Debugger"
msgstr ":mod:`pdb` --- Pythons felsökare"

#: ../../library/pdb.rst:9
msgid "**Source code:** :source:`Lib/pdb.py`"
msgstr "**Källkod:** :source:`Lib/pdb.py`"

#: ../../library/pdb.rst:15
msgid ""
"The module :mod:`pdb` defines an interactive source code debugger for Python "
"programs.  It supports setting (conditional) breakpoints and single stepping "
"at the source line level, inspection of stack frames, source code listing, "
"and evaluation of arbitrary Python code in the context of any stack frame.  "
"It also supports post-mortem debugging and can be called under program "
"control."
msgstr ""
"Modulen :mod:`pdb` definierar en interaktiv källkodsdebugger för Python-"
"program.  Den stöder inställning av (villkorliga) brytpunkter och single "
"stepping på källkodsnivå, inspektion av stapelramar, källkodslistning och "
"utvärdering av godtycklig Python-kod i samband med valfri stapelram.  Den "
"stöder också felsökning efter avslutad användning och kan anropas under "
"programkontroll."

#: ../../library/pdb.rst:26
msgid ""
"The debugger is extensible -- it is actually defined as the class :class:"
"`Pdb`. This is currently undocumented but easily understood by reading the "
"source.  The extension interface uses the modules :mod:`bdb` and :mod:`cmd`."
msgstr ""
"Felsökaren är utbyggbar -- den är faktiskt definierad som klassen :class:"
"`Pdb`. Detta är för närvarande odokumenterat men lätt att förstå genom att "
"läsa källan.  Gränssnittet för utökning använder modulerna :mod:`bdb` och :"
"mod:`cmd`."

#: ../../library/pdb.rst:32
msgid "Module :mod:`faulthandler`"
msgstr "Modul :mod:`faulthandler`"

#: ../../library/pdb.rst:33
msgid ""
"Used to dump Python tracebacks explicitly, on a fault, after a timeout, or "
"on a user signal."
msgstr ""
"Används för att dumpa Python-spårningar explicit, vid ett fel, efter en "
"timeout eller vid en användarsignal."

#: ../../library/pdb.rst:36
msgid "Module :mod:`traceback`"
msgstr "Modul :mod:`traceback`"

#: ../../library/pdb.rst:37
msgid ""
"Standard interface to extract, format and print stack traces of Python "
"programs."
msgstr ""
"Standardgränssnitt för att extrahera, formatera och skriva ut stackspår från "
"Python-program."

#: ../../library/pdb.rst:39
msgid "The typical usage to break into the debugger is to insert::"
msgstr ""
"Den typiska användningen för att bryta sig in i felsökaren är att infoga::"

#: ../../library/pdb.rst:41
msgid "import pdb; pdb.set_trace()"
msgstr "import pdb; pdb.set_trace()"

#: ../../library/pdb.rst:43
msgid "Or::"
msgstr "Eller::"

#: ../../library/pdb.rst:45
msgid "breakpoint()"
msgstr "breakpoint()"

#: ../../library/pdb.rst:47
msgid ""
"at the location you want to break into the debugger, and then run the "
"program. You can then step through the code following this statement, and "
"continue running without the debugger using the :pdbcmd:`continue` command."
msgstr ""
"på den plats där du vill bryta dig in i debuggern och kör sedan programmet. "
"Du kan sedan gå igenom koden efter detta uttalande och fortsätta att köra "
"utan debuggern med kommandot :pdbcmd:`continue`."

#: ../../library/pdb.rst:51
msgid ""
"The built-in :func:`breakpoint`, when called with defaults, can be used "
"instead of ``import pdb; pdb.set_trace()``."
msgstr ""
"Den inbyggda :func:`breakpoint` kan, när den anropas med standardvärden, "
"användas istället för ``import pdb; pdb.set_trace()``."

#: ../../library/pdb.rst:57
msgid ""
"def double(x):\n"
"   breakpoint()\n"
"   return x * 2\n"
"val = 3\n"
"print(f\"{val} * 2 is {double(val)}\")"
msgstr ""
"def double(x):\n"
"   breakpoint()\n"
"   return x * 2\n"
"val = 3\n"
"print(f\"{val} * 2 is {double(val)}\")"

#: ../../library/pdb.rst:63
msgid ""
"The debugger's prompt is ``(Pdb)``, which is the indicator that you are in "
"debug mode::"
msgstr ""
"Felsökarens prompt är ``(Pdb)``, vilket är en indikator på att du befinner "
"dig i felsökningsläge::"

#: ../../library/pdb.rst:65
msgid ""
"> ...(2)double()\n"
"-> breakpoint()\n"
"(Pdb) p x\n"
"3\n"
"(Pdb) continue\n"
"3 * 2 is 6"
msgstr ""
"> ...(2)double()\n"
"-> breakpoint()\n"
"(Pdb) p x\n"
"3\n"
"(Pdb) continue\n"
"3 * 2 is 6"

#: ../../library/pdb.rst:72
msgid ""
"Tab-completion via the :mod:`readline` module is available for commands and "
"command arguments, e.g. the current global and local names are offered as "
"arguments of the ``p`` command."
msgstr ""
"Tabbkomplettering via modulen :mod:`readline` är tillgänglig för kommandon "
"och kommandonas argument, t.ex. erbjuds de aktuella globala och lokala "
"namnen som argument för kommandot ``p``."

#: ../../library/pdb.rst:81
msgid ""
"You can also invoke :mod:`pdb` from the command line to debug other "
"scripts.  For example::"
msgstr ""
"Du kan också anropa :mod:`pdb` från kommandoraden för att felsöka andra "
"skript.  Till exempel::"

#: ../../library/pdb.rst:84
msgid "python -m pdb [-c command] (-m module | -p pid | pyfile) [args ...]"
msgstr "python -m pdb [-c command] (-m module | -p pid | pyfile) [args ...]"

#: ../../library/pdb.rst:86
msgid ""
"When invoked as a module, pdb will automatically enter post-mortem debugging "
"if the program being debugged exits abnormally.  After post-mortem debugging "
"(or after normal exit of the program), pdb will restart the program.  "
"Automatic restarting preserves pdb's state (such as breakpoints) and in most "
"cases is more useful than quitting the debugger upon program's exit."
msgstr ""
"När pdb anropas som en modul kommer den automatiskt att gå in i post-mortem-"
"felsökning om det program som felsöks avslutas på ett onormalt sätt.  Efter "
"post-mortem-felsökning (eller efter normal avslutning av programmet) kommer "
"pdb att starta om programmet.  Automatisk omstart bevarar pdb:s status (t."
"ex. brytpunkter) och är i de flesta fall mer användbart än att avsluta "
"felsökaren när programmet avslutas."

#: ../../library/pdb.rst:94
msgid ""
"To execute commands as if given in a :file:`.pdbrc` file; see :ref:`debugger-"
"commands`."
msgstr ""
"För att utföra kommandon som om de vore angivna i en :file:`.pdbrc`-fil; se :"
"ref:`debugger-commands`."

#: ../../library/pdb.rst:97
msgid "Added the ``-c`` option."
msgstr "Alternativet ``-c`` har lagts till."

#: ../../library/pdb.rst:102
msgid ""
"To execute modules similar to the way ``python -m`` does. As with a script, "
"the debugger will pause execution just before the first line of the module."
msgstr ""
"För att exekvera moduler på samma sätt som ``python -m`` gör. Precis som med "
"ett skript kommer felsökaren att pausa exekveringen precis före modulens "
"första rad."

#: ../../library/pdb.rst:105
msgid "Added the ``-m`` option."
msgstr "Lagt till alternativet ``-m``."

#: ../../library/pdb.rst:110
msgid "Attach to the process with the specified PID."
msgstr "Anslut till processen med angiven PID."

#: ../../library/pdb.rst:115
msgid ""
"To attach to a running Python process for remote debugging, use the ``-p`` "
"or ``--pid`` option with the target process's PID::"
msgstr ""
"Om du vill koppla till en Python-process som körs för fjärrfelsökning "
"använder du alternativet ``-p`` eller ``--pid`` med målprocessens PID::"

#: ../../library/pdb.rst:118
msgid "python -m pdb -p 1234"
msgstr "python -m pdb -p 1234"

#: ../../library/pdb.rst:122
msgid ""
"Attaching to a process that is blocked in a system call or waiting for I/O "
"will only work once the next bytecode instruction is executed or when the "
"process receives a signal."
msgstr ""
"Att ansluta till en process som är blockerad i ett systemanrop eller väntar "
"på I/O fungerar först när nästa bytecode-instruktion utförs eller när "
"processen får en signal."

#: ../../library/pdb.rst:126
msgid "Typical usage to execute a statement under control of the debugger is::"
msgstr ""
"Typisk användning för att exekvera en sats under kontroll av debuggern är::"

#: ../../library/pdb.rst:128
msgid ""
">>> import pdb\n"
">>> def f(x):\n"
"...     print(1 / x)\n"
">>> pdb.run(\"f(2)\")\n"
"> <string>(1)<module>()\n"
"(Pdb) continue\n"
"0.5\n"
">>>"
msgstr ""
">>> import pdb\n"
">>> def f(x):\n"
"...     print(1 / x)\n"
">>> pdb.run(\"f(2)\")\n"
"> <string>(1)<module>()\n"
"(Pdb) continue\n"
"0.5\n"
">>>"

#: ../../library/pdb.rst:137
msgid "The typical usage to inspect a crashed program is::"
msgstr "Den typiska användningen för att inspektera ett kraschat program är::"

#: ../../library/pdb.rst:139
msgid ""
">>> import pdb\n"
">>> def f(x):\n"
"...     print(1 / x)\n"
"...\n"
">>> f(0)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"<stdin>\", line 2, in f\n"
"ZeroDivisionError: division by zero\n"
">>> pdb.pm()\n"
"> <stdin>(2)f()\n"
"(Pdb) p x\n"
"0\n"
"(Pdb)"
msgstr ""
">>> import pdb\n"
">>> def f(x):\n"
"...     print(1 / x)\n"
"...\n"
">>> f(0)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"<stdin>\", line 2, in f\n"
"ZeroDivisionError: division by zero\n"
">>> pdb.pm()\n"
"> <stdin>(2)f()\n"
"(Pdb) p x\n"
"0\n"
"(Pdb)"

#: ../../library/pdb.rst:154
msgid ""
"The implementation of :pep:`667` means that name assignments made via "
"``pdb`` will immediately affect the active scope, even when running inside "
"an :term:`optimized scope`."
msgstr ""
"Implementeringen av :pep:`667` innebär att namntilldelningar som görs via "
"``pdb`` omedelbart kommer att påverka det aktiva scopet, även när det körs i "
"ett :term:`optimized scope`."

#: ../../library/pdb.rst:160
msgid ""
"The module defines the following functions; each enters the debugger in a "
"slightly different way:"
msgstr ""
"Modulen definierar följande funktioner, som alla går in i felsökaren på lite "
"olika sätt:"

#: ../../library/pdb.rst:165
msgid ""
"Execute the *statement* (given as a string or a code object) under debugger "
"control.  The debugger prompt appears before any code is executed; you can "
"set breakpoints and type :pdbcmd:`continue`, or you can step through the "
"statement using :pdbcmd:`step` or :pdbcmd:`next` (all these commands are "
"explained below).  The optional *globals* and *locals* arguments specify the "
"environment in which the code is executed; by default the dictionary of the "
"module :mod:`__main__` is used.  (See the explanation of the built-in :func:"
"`exec` or :func:`eval` functions.)"
msgstr ""
"Exekverar *satsen* (angiven som en sträng eller ett kodobjekt) under "
"debuggerkontroll.  Du kan sätta brytpunkter och skriva :pdbcmd:`continue`, "
"eller så kan du stega genom satsen med :pdbcmd:`step` eller :pdbcmd:`next` "
"(alla dessa kommandon förklaras nedan).  De valfria argumenten *globals* och "
"*locals* anger den miljö i vilken koden exekveras; som standard används "
"ordlistan för modulen :mod:`__main__`.  (Se förklaringen av de inbyggda "
"funktionerna :func:`exec` eller :func:`eval`)"

#: ../../library/pdb.rst:177
msgid ""
"Evaluate the *expression* (given as a string or a code object) under "
"debugger control.  When :func:`runeval` returns, it returns the value of the "
"*expression*.  Otherwise this function is similar to :func:`run`."
msgstr ""
"Utvärdera *uttrycket* (givet som en sträng eller ett kodobjekt) under "
"debuggerkontroll.  När :func:`runeval` returnerar, returnerar den värdet av "
"*uttrycket*.  I övrigt är denna funktion lik :func:`run`."

#: ../../library/pdb.rst:184
msgid ""
"Call the *function* (a function or method object, not a string) with the "
"given arguments.  When :func:`runcall` returns, it returns whatever the "
"function call returned.  The debugger prompt appears as soon as the function "
"is entered."
msgstr ""
"Anropar *funktionen* (ett funktions- eller metodobjekt, inte en sträng) med "
"de angivna argumenten.  När :func:`runcall` returneras, returneras det som "
"funktionsanropet returnerade.  Felsökarprompten visas så snart funktionen "
"har angetts."

#: ../../library/pdb.rst:192
msgid ""
"Enter the debugger at the calling stack frame.  This is useful to hard-code "
"a breakpoint at a given point in a program, even if the code is not "
"otherwise being debugged (e.g. when an assertion fails).  If given, *header* "
"is printed to the console just before debugging begins. The *commands* "
"argument, if given, is a list of commands to execute when the debugger "
"starts."
msgstr ""
"Gå in i debuggern vid den anropande stackramen.  Detta är användbart för att "
"hårdkoda en brytpunkt vid en viss punkt i ett program, även om koden inte "
"felsöks på något annat sätt (t.ex. när ett påstående misslyckas).  Om "
"*header* anges skrivs den ut i konsolen precis innan felsökningen påbörjas. "
"Argumentet *commands*, om det anges, är en lista med kommandon som ska "
"utföras när felsökaren startar."

#: ../../library/pdb.rst:200
msgid "The keyword-only argument *header*."
msgstr "Argumentet *header* är endast nyckelord."

#: ../../library/pdb.rst:203
msgid ""
":func:`set_trace` will enter the debugger immediately, rather than on the "
"next line of code to be executed."
msgstr ""
":func:`set_trace` kommer att gå in i felsökaren omedelbart, snarare än på "
"nästa kodrad som ska exekveras."

#: ../../library/pdb.rst:207
msgid "The *commands* argument."
msgstr "Argumentet *kommandon*."

#: ../../library/pdb.rst:213
msgid ""
"async version of :func:`set_trace`. This function should be used inside an "
"async function with :keyword:`await`."
msgstr ""
"asynkron version av :func:`set_trace`. Denna funktion bör användas inuti en "
"asynkron funktion med :keyword:`await`."

#: ../../library/pdb.rst:216
msgid ""
"async def f():\n"
"    await pdb.set_trace_async()"
msgstr ""
"async def f():\n"
"    await pdb.set_trace_async()"

#: ../../library/pdb.rst:221
msgid ""
":keyword:`await` statements are supported if the debugger is invoked by this "
"function."
msgstr ""
":keyword:`await` statements stöds om debuggern anropas av denna funktion."

#: ../../library/pdb.rst:227
msgid ""
"Enter post-mortem debugging of the given exception or :ref:`traceback object "
"<traceback-objects>`. If no value is given, it uses the exception that is "
"currently being handled, or raises ``ValueError`` if there isn’t one."
msgstr ""
"Startar felsökning av det angivna undantaget eller :ref:`traceback-objektet "
"<traceback-objects>`. Om inget värde anges används det undantag som för "
"närvarande hanteras, eller ``ValueError`` om det inte finns något."

#: ../../library/pdb.rst:232
msgid "Support for exception objects was added."
msgstr "Stöd för undantagsobjekt har lagts till."

#: ../../library/pdb.rst:237
msgid ""
"Enter post-mortem debugging of the exception found in :data:`sys.last_exc`."
msgstr ""
"Starta felsökning efteråt av undantaget som hittades i :data:`sys.last_exc`."

#: ../../library/pdb.rst:242
msgid ""
"There are two supported backends for pdb: ``'settrace'`` and "
"``'monitoring'``. See :class:`bdb.Bdb` for details. The user can set the "
"default backend to use if none is specified when instantiating :class:`Pdb`. "
"If no backend is specified, the default is ``'settrace'``."
msgstr ""
"Det finns två backends som stöds för pdb: ``'settrace'`` och "
"``'monitoring'``. Se :class:`bdb.Bdb` för mer information. Användaren kan "
"ange vilken standardbackend som ska användas om ingen anges vid "
"instansiering av :class:`Pdb`. Om ingen backend specificeras är standard "
"``'settrace'``."

#: ../../library/pdb.rst:249
msgid ""
":func:`breakpoint` and :func:`set_trace` will not be affected by this "
"function. They always use ``'monitoring'`` backend."
msgstr ""
":func:`breakpoint` och :func:`set_trace` kommer inte att påverkas av denna "
"funktion. De använder alltid ``'monitoring'`` backend."

#: ../../library/pdb.rst:256
msgid "Returns the default backend for pdb."
msgstr "Returnerar standardbackend för pdb."

#: ../../library/pdb.rst:260
msgid ""
"The ``run*`` functions and :func:`set_trace` are aliases for instantiating "
"the :class:`Pdb` class and calling the method of the same name.  If you want "
"to access further features, you have to do this yourself:"
msgstr ""
"Funktionerna ``run*`` och :func:`set_trace`` är alias för att instansiera "
"klassen :class:`Pdb` och anropa metoden med samma namn.  Om du vill ha "
"tillgång till ytterligare funktioner måste du göra detta själv:"

#: ../../library/pdb.rst:267
msgid ":class:`Pdb` is the debugger class."
msgstr ":class:`Pdb` är klassen för felsökare."

#: ../../library/pdb.rst:269
msgid ""
"The *completekey*, *stdin* and *stdout* arguments are passed to the "
"underlying :class:`cmd.Cmd` class; see the description there."
msgstr ""
"Argumenten *completekey*, *stdin* och *stdout* skickas till den "
"underliggande :class:`cmd.Cmd`-klassen; se beskrivningen där."

#: ../../library/pdb.rst:272
msgid ""
"The *skip* argument, if given, must be an iterable of glob-style module name "
"patterns.  The debugger will not step into frames that originate in a module "
"that matches one of these patterns. [1]_"
msgstr ""
"Argumentet *skip*, om det anges, måste vara en iterabel av modulnamnsmönster "
"i glob-stil.  Felsökaren kommer inte att gå in i ramar som har sitt ursprung "
"i en modul som matchar något av dessa mönster. [1]_"

#: ../../library/pdb.rst:276
msgid ""
"By default, Pdb sets a handler for the SIGINT signal (which is sent when the "
"user presses :kbd:`Ctrl-C` on the console) when you give a :pdbcmd:"
"`continue` command. This allows you to break into the debugger again by "
"pressing :kbd:`Ctrl-C`.  If you want Pdb not to touch the SIGINT handler, "
"set *nosigint* to true."
msgstr ""
"Som standard ställer Pdb in en hanterare för SIGINT-signalen (som skickas "
"när användaren trycker på :kbd:`Ctrl-C` på konsolen) när du ger ett :pdbcmd:"
"`continue`-kommando. Detta gör att du kan bryta dig in i felsökaren igen "
"genom att trycka på :kbd:`Ctrl-C`.  Om du vill att Pdb inte ska röra SIGINT-"
"hanteraren ska du sätta *nosigint* till true."

#: ../../library/pdb.rst:281
msgid ""
"The *readrc* argument defaults to true and controls whether Pdb will load ."
"pdbrc files from the filesystem."
msgstr ""
"Argumentet *readrc* är som standard true och styr om Pdb ska läsa in .pdbrc-"
"filer från filsystemet."

#: ../../library/pdb.rst:284
msgid ""
"The *mode* argument specifies how the debugger was invoked. It impacts the "
"workings of some debugger commands. Valid values are ``'inline'`` (used by "
"the breakpoint() builtin), ``'cli'`` (used by the command line invocation) "
"or ``None`` (for backwards compatible behaviour, as before the *mode* "
"argument was added)."
msgstr ""
"Argumentet *mode* anger hur felsökaren startades. Det påverkar hur vissa "
"kommandon i felsökaren fungerar. Giltiga värden är ``'inline'`` (används av "
"breakpoint() builtin), ``'cli'`` (används av kommandoradsinställningen) "
"eller ``None`` (för bakåtkompatibelt beteende, som innan *mode*-argumentet "
"lades till)."

#: ../../library/pdb.rst:291
msgid ""
"The *backend* argument specifies the backend to use for the debugger. If "
"``None`` is passed, the default backend will be used. See :func:"
"`set_default_backend`. Otherwise the supported backends are ``'settrace'`` "
"and ``'monitoring'``."
msgstr ""
"Argumentet *backend* anger vilken backend som ska användas för felsökaren. "
"Om ``None`` skickas, kommer standardbackend att användas. Se :func:"
"`set_default_backend`. Annars är de backends som stöds ``'settrace'`` och "
"``'monitoring'``."

#: ../../library/pdb.rst:295
msgid ""
"The *colorize* argument, if set to ``True``, will enable colorized output in "
"the debugger, if color is supported. This will highlight source code "
"displayed in pdb."
msgstr ""
"Argumentet *colorize*, om det sätts till ``True``, aktiverar färgade utdata "
"i felsökaren, om färg stöds. Detta kommer att markera källkod som visas i "
"pdb."

#: ../../library/pdb.rst:298
msgid "Example call to enable tracing with *skip*::"
msgstr "Exempel på anrop för att aktivera spårning med *skip*::"

#: ../../library/pdb.rst:300
msgid "import pdb; pdb.Pdb(skip=['django.*']).set_trace()"
msgstr "import pdb; pdb.Pdb(skip=['django.*']).set_trace()"

#: ../../library/pdb.rst:302
msgid ""
"Raises an :ref:`auditing event <auditing>` ``pdb.Pdb`` with no arguments."
msgstr "Utlöser en :ref:`auditing event <auditing>` ``pdb.Pdb`` utan argument."

#: ../../library/pdb.rst:304
msgid "Added the *skip* parameter."
msgstr "Lagt till parametern *skip*."

#: ../../library/pdb.rst:307
msgid ""
"Added the *nosigint* parameter. Previously, a SIGINT handler was never set "
"by Pdb."
msgstr ""
"Parametern *nosigint* har lagts till. Tidigare ställdes aldrig en SIGINT-"
"hanterare in av Pdb."

#: ../../library/pdb.rst:311
msgid "The *readrc* argument."
msgstr "Argumentet *readrc*."

#: ../../library/pdb.rst:314
msgid "Added the *mode* argument."
msgstr "Lagt till argumentet *mode*."

#: ../../library/pdb.rst:317
msgid "Added the *backend* argument."
msgstr "Lagt till argumentet *backend*."

#: ../../library/pdb.rst:320
msgid "Added the *colorize* argument."
msgstr "Lagt till argumentet *colorize*."

#: ../../library/pdb.rst:323
msgid ""
"Inline breakpoints like :func:`breakpoint` or :func:`pdb.set_trace` will "
"always stop the program at calling frame, ignoring the *skip* pattern (if "
"any)."
msgstr ""
"Inline breakpoints som :func:`breakpoint` eller :func:`pdb.set_trace` "
"stoppar alltid programmet vid anropande frame och ignorerar *skip*-mönstret "
"(om sådant finns)."

#: ../../library/pdb.rst:332
msgid "See the documentation for the functions explained above."
msgstr "Se dokumentationen för de funktioner som beskrivs ovan."

#: ../../library/pdb.rst:338
msgid "Debugger Commands"
msgstr "Kommandon för felsökare"

#: ../../library/pdb.rst:340
msgid ""
"The commands recognized by the debugger are listed below.  Most commands can "
"be abbreviated to one or two letters as indicated; e.g. ``h(elp)`` means "
"that either ``h`` or ``help`` can be used to enter the help command (but not "
"``he`` or ``hel``, nor ``H`` or ``Help`` or ``HELP``).  Arguments to "
"commands must be separated by whitespace (spaces or tabs).  Optional "
"arguments are enclosed in square brackets (``[]``) in the command syntax; "
"the square brackets must not be typed.  Alternatives in the command syntax "
"are separated by a vertical bar (``|``)."
msgstr ""
"De kommandon som debuggern känner igen listas nedan.  De flesta kommandon "
"kan förkortas till en eller två bokstäver enligt vad som anges; t.ex. "
"betyder ``h(elp)`` att antingen ``h`` eller ``help`` kan användas för att "
"ange hjälpkommandot (men inte ``he`` eller ``hel``, inte heller ``H`` eller "
"``Help`` eller ``HELP``).  Argument till kommandon måste separeras med "
"blanksteg (mellanslag eller tabbar).  Valfria argument omsluts av "
"hakparenteser (``[]``) i kommandosyntaxen; hakparenteserna får inte "
"skrivas.  Alternativ i kommandosyntaxen separeras med en vertikal stapel (``|"
"``)."

#: ../../library/pdb.rst:349
msgid ""
"Entering a blank line repeats the last command entered.  Exception: if the "
"last command was a :pdbcmd:`list` command, the next 11 lines are listed."
msgstr ""
"Om du skriver in en tom rad upprepas det senast inskrivna kommandot.  "
"Undantag: om det senaste kommandot var ett :pdbcmd:`list`-kommando, listas "
"de kommande 11 raderna."

#: ../../library/pdb.rst:352
msgid ""
"Commands that the debugger doesn't recognize are assumed to be Python "
"statements and are executed in the context of the program being debugged.  "
"Python statements can also be prefixed with an exclamation point (``!``).  "
"This is a powerful way to inspect the program being debugged; it is even "
"possible to change a variable or call a function.  When an exception occurs "
"in such a statement, the exception name is printed but the debugger's state "
"is not changed."
msgstr ""
"Kommandon som debuggern inte känner igen antas vara Python-satser och körs i "
"kontexten för det program som debuggas.  Python-satser kan också inledas med "
"ett utropstecken (``!``).  Detta är ett kraftfullt sätt att inspektera det "
"program som debuggas; det är till och med möjligt att ändra en variabel "
"eller anropa en funktion.  När ett undantag inträffar i ett sådant uttalande "
"skrivs undantagsnamnet ut, men debuggarens tillstånd ändras inte."

#: ../../library/pdb.rst:360
msgid ""
"Expressions/Statements whose prefix is a pdb command are now correctly "
"identified and executed."
msgstr ""
"Uttryck/satser vars prefix är ett pdb-kommando identifieras och exekveras nu "
"korrekt."

#: ../../library/pdb.rst:364
msgid ""
"The debugger supports :ref:`aliases <debugger-aliases>`.  Aliases can have "
"parameters which allows one a certain level of adaptability to the context "
"under examination."
msgstr ""
"Felsökaren stöder :ref:`aliaser <debugger-aliases>`.  Aliaser kan ha "
"parametrar som ger en viss anpassningsförmåga till det sammanhang som "
"undersöks."

#: ../../library/pdb.rst:368
msgid ""
"Multiple commands may be entered on a single line, separated by ``;;``.  (A "
"single ``;`` is not used as it is the separator for multiple commands in a "
"line that is passed to the Python parser.)  No intelligence is applied to "
"separating the commands; the input is split at the first ``;;`` pair, even "
"if it is in the middle of a quoted string. A workaround for strings with "
"double semicolons is to use implicit string concatenation ``';'';'`` or ``\";"
"\"\";\"``."
msgstr ""
"Flera kommandon kan anges på en rad, åtskilda av ``;;``.  (En enda ``;`` "
"används inte eftersom det är separatorn för flera kommandon på en rad som "
"skickas till Python-parsern)  Ingen intelligens används för att separera "
"kommandona; indata delas upp vid det första ``;;``-paret, även om det är "
"mitt i en citerad sträng. En lösning för strängar med dubbla semikolon är "
"att använda implicit strängkonkatenering ``';'';'`` eller ``\";\"\";\"``."

#: ../../library/pdb.rst:375
msgid ""
"To set a temporary global variable, use a *convenience variable*. A "
"*convenience variable* is a variable whose name starts with ``$``.  For "
"example, ``$foo = 1`` sets a global variable ``$foo`` which you can use in "
"the debugger session.  The *convenience variables* are cleared when the "
"program resumes execution so it's less likely to interfere with your program "
"compared to using normal variables like ``foo = 1``."
msgstr ""
"Om du vill ställa in en tillfällig global variabel använder du en "
"*konveniensvariabel*. En *konvenansvariabel* är en variabel vars namn börjar "
"med ``$``.  Till exempel, ``$foo = 1`` ställer in en global variabel "
"``$foo`` som du kan använda i felsökarsessionen.  *Vänlighetsvariablerna* "
"rensas när programmet återupptas, så det är mindre troligt att de stör "
"programmet jämfört med om du använder normala variabler som ``foo = 1``."

#: ../../library/pdb.rst:382
msgid "There are four preset *convenience variables*:"
msgstr "Det finns fyra förinställda *bekvämlighetsvariabler*:"

#: ../../library/pdb.rst:384
msgid "``$_frame``: the current frame you are debugging"
msgstr "``$_frame``: den aktuella bildrutan som du felsöker"

#: ../../library/pdb.rst:385
msgid "``$_retval``: the return value if the frame is returning"
msgstr "``$_retval``: returvärdet om ramen returnerar"

#: ../../library/pdb.rst:386
msgid "``$_exception``: the exception if the frame is raising an exception"
msgstr "``$_exception``: undantaget om ramen ger upphov till ett undantag"

#: ../../library/pdb.rst:387
msgid "``$_asynctask``: the asyncio task if pdb stops in an async function"
msgstr ""
"``$_asynctask``: asyncio-uppgiften om pdb stannar i en asynkron funktion"

#: ../../library/pdb.rst:391
msgid "Added the *convenience variable* feature."
msgstr "Lagt till funktionen *convenience variable*."

#: ../../library/pdb.rst:393
msgid "Added the ``$_asynctask`` convenience variable."
msgstr "Lagt till bekvämlighetsvariabeln ``$_asynctask``."

#: ../../library/pdb.rst:400
msgid ""
"If a file :file:`.pdbrc` exists in the user's home directory or in the "
"current directory, it is read with ``'utf-8'`` encoding and executed as if "
"it had been typed at the debugger prompt, with the exception that empty "
"lines and lines starting with ``#`` are ignored.  This is particularly "
"useful for aliases.  If both files exist, the one in the home directory is "
"read first and aliases defined there can be overridden by the local file."
msgstr ""
"Om filen :file:`.pdbrc` finns i användarens hemkatalog eller i den aktuella "
"katalogen, läses den med kodningen ``'utf-8'`` och exekveras som om den hade "
"skrivits i debuggerprompten, med undantaget att tomma rader och rader som "
"börjar med ``#`` ignoreras.  Detta är särskilt användbart för alias.  Om "
"båda filerna finns läses den som finns i hemkatalogen först och alias som "
"definieras där kan åsidosättas av den lokala filen."

#: ../../library/pdb.rst:407
msgid ""
":file:`.pdbrc` can now contain commands that continue debugging, such as :"
"pdbcmd:`continue` or :pdbcmd:`next`.  Previously, these commands had no "
"effect."
msgstr ""
":file:`.pdbrc` kan nu innehålla kommandon som fortsätter felsökningen, t."
"ex. :pdbcmd:`continue` eller :pdbcmd:`next`.  Tidigare hade dessa kommandon "
"ingen effekt."

#: ../../library/pdb.rst:412
msgid ""
":file:`.pdbrc` is now read with ``'utf-8'`` encoding. Previously, it was "
"read with the system locale encoding."
msgstr ""
":file:`.pdbrc` läses nu med kodningen ``'utf-8'``. Tidigare lästes den med "
"systemets lokala kodning."

#: ../../library/pdb.rst:419
msgid ""
"Without argument, print the list of available commands.  With a *command* as "
"argument, print help about that command.  ``help pdb`` displays the full "
"documentation (the docstring of the :mod:`pdb` module).  Since the *command* "
"argument must be an identifier, ``help exec`` must be entered to get help on "
"the ``!`` command."
msgstr ""
"Utan argument skrivs en lista över tillgängliga kommandon ut.  Med ett "
"*kommando* som argument, skriv ut hjälp om det kommandot.  ``help pdb`` "
"visar den fullständiga dokumentationen (dokumentsträngen för modulen :mod:"
"`pdb`).  Eftersom argumentet *command* måste vara en identifierare måste "
"``help exec`` anges för att få hjälp med kommandot ``!``."

#: ../../library/pdb.rst:427
msgid ""
"Print a stack trace, with the most recent frame at the bottom.  if *count* "
"is 0, print the current frame entry. If *count* is negative, print the least "
"recent - *count* frames. If *count* is positive, print the most recent "
"*count* frames.  An arrow (``>``) indicates the current frame, which "
"determines the context of most commands."
msgstr ""
"Skriv ut en stackspårning, med den senaste ramen längst ned. om *count* är "
"0, skriv ut den aktuella ramposten. Om *count* är negativt, skriv ut de "
"senaste - *count* ramarna. Om *count* är positiv, skriv ut de senaste "
"*count* ramarna.  En pil (``>``) anger aktuell bildruta, som bestämmer "
"sammanhanget för de flesta kommandon."

#: ../../library/pdb.rst:433
msgid "*count* argument is added."
msgstr "*count*-argumentet läggs till."

#: ../../library/pdb.rst:438
msgid ""
"Move the current frame *count* (default one) levels down in the stack trace "
"(to a newer frame)."
msgstr ""
"Flytta den aktuella ramen *antal* (standard ett) nivåer nedåt i "
"stackspårningen (till en nyare ram)."

#: ../../library/pdb.rst:443
msgid ""
"Move the current frame *count* (default one) levels up in the stack trace "
"(to an older frame)."
msgstr ""
"Flytta den aktuella ramen *antal* (standard ett) nivåer uppåt i "
"stackspårningen (till en äldre ram)."

#: ../../library/pdb.rst:448
msgid ""
"With a *lineno* argument, set a break at line *lineno* in the current file. "
"The line number may be prefixed with a *filename* and a colon, to specify a "
"breakpoint in another file (possibly one that hasn't been loaded yet).  The "
"file is searched on :data:`sys.path`.  Acceptable forms of *filename* are ``/"
"abspath/to/file.py``, ``relpath/file.py``, ``module`` and ``package.module``."
msgstr ""
"Med ett *lineno*-argument, sätt en brytpunkt på rad *lineno* i den aktuella "
"filen. Radnumret kan föregås av ett *filnamn* och ett kolon, för att ange en "
"brytpunkt i en annan fil (eventuellt en som inte har laddats in ännu).  "
"Filen söks på :data:`sys.path`.  Godtagbara former av *filnamn* är ``/"
"abspath/to/file.py``, ``relpath/file.py``, ``module`` och ``package.module``."

#: ../../library/pdb.rst:455
msgid ""
"With a *function* argument, set a break at the first executable statement "
"within that function. *function* can be any expression that evaluates to a "
"function in the current namespace."
msgstr ""
"Med ett *function*-argument, sätt en paus vid den första körbara satsen i "
"den funktionen. *function* kan vara vilket uttryck som helst som utvärderas "
"till en funktion i den aktuella namnrymden."

#: ../../library/pdb.rst:459
msgid ""
"If a second argument is present, it is an expression which must evaluate to "
"true before the breakpoint is honored."
msgstr ""
"Om det finns ett andra argument är det ett uttryck som måste utvärderas till "
"sant innan brytpunkten respekteras."

#: ../../library/pdb.rst:462
msgid ""
"Without argument, list all breaks, including for each breakpoint, the number "
"of times that breakpoint has been hit, the current ignore count, and the "
"associated condition if any."
msgstr ""
"Utan argument listas alla brytpunkter, inklusive för varje brytpunkt, "
"antalet gånger brytpunkten har träffats, aktuellt ignoreringsantal och "
"eventuellt associerat villkor."

#: ../../library/pdb.rst:466
msgid ""
"Each breakpoint is assigned a number to which all the other breakpoint "
"commands refer."
msgstr ""
"Varje brytpunkt tilldelas ett nummer som alla andra brytpunktskommandon "
"hänvisar till."

#: ../../library/pdb.rst:471
msgid ""
"Temporary breakpoint, which is removed automatically when it is first hit. "
"The arguments are the same as for :pdbcmd:`break`."
msgstr ""
"Tillfällig brytpunkt, som tas bort automatiskt när den träffas första "
"gången. Argumenten är desamma som för :pdbcmd:`break`."

#: ../../library/pdb.rst:476
msgid ""
"With a *filename:lineno* argument, clear all the breakpoints at this line. "
"With a space separated list of breakpoint numbers, clear those breakpoints. "
"Without argument, clear all breaks (but first ask confirmation)."
msgstr ""
"Med ett *filnamn:lineno*-argument rensar du alla brytpunkter på denna rad. "
"Med en mellanslagsseparerad lista med brytpunktsnummer rensas dessa "
"brytpunkter. Utan argument, rensa alla brytpunkter (men be först om "
"bekräftelse)."

#: ../../library/pdb.rst:482
msgid ""
"Disable the breakpoints given as a space separated list of breakpoint "
"numbers.  Disabling a breakpoint means it cannot cause the program to stop "
"execution, but unlike clearing a breakpoint, it remains in the list of "
"breakpoints and can be (re-)enabled."
msgstr ""
"Inaktivera brytpunkterna som anges som en blankstegssorterad lista med "
"brytpunktsnummer.  Att inaktivera en brytpunkt innebär att den inte kan "
"orsaka att programmet stoppas, men till skillnad från att rensa en brytpunkt "
"finns den kvar i listan över brytpunkter och kan (åter)aktiveras."

#: ../../library/pdb.rst:489
msgid "Enable the breakpoints specified."
msgstr "Aktivera de angivna brytpunkterna."

#: ../../library/pdb.rst:493
msgid ""
"Set the ignore count for the given breakpoint number.  If *count* is "
"omitted, the ignore count is set to 0.  A breakpoint becomes active when the "
"ignore count is zero.  When non-zero, the *count* is decremented each time "
"the breakpoint is reached and the breakpoint is not disabled and any "
"associated condition evaluates to true."
msgstr ""
"Ställ in ignoreringsantalet för det angivna brytpunktsnumret.  Om *count* "
"utelämnas sätts ignoreringsantalet till 0. En brytpunkt blir aktiv när "
"ignoreringsantalet är noll.  Om *count* inte är noll minskas det varje gång "
"brytpunkten nås och brytpunkten inte är inaktiverad och något associerat "
"villkor utvärderas till sant."

#: ../../library/pdb.rst:501
msgid ""
"Set a new *condition* for the breakpoint, an expression which must evaluate "
"to true before the breakpoint is honored.  If *condition* is absent, any "
"existing condition is removed; i.e., the breakpoint is made unconditional."
msgstr ""
"Ange ett nytt *villkor* för brytpunkten, ett uttryck som måste utvärderas "
"till sant innan brytpunkten respekteras.  Om *condition* saknas tas alla "
"befintliga villkor bort, dvs. brytpunkten görs ovillkorlig."

#: ../../library/pdb.rst:507
msgid ""
"Specify a list of commands for breakpoint number *bpnumber*.  The commands "
"themselves appear on the following lines.  Type a line containing just "
"``end`` to terminate the commands. An example::"
msgstr ""
"Ange en lista med kommandon för brytpunktsnummer *bpnumber*.  Själva "
"kommandona visas på följande rader.  Skriv en rad som bara innehåller "
"``end`` för att avsluta kommandona. Ett exempel::"

#: ../../library/pdb.rst:511
msgid ""
"(Pdb) commands 1\n"
"(com) p some_variable\n"
"(com) end\n"
"(Pdb)"
msgstr ""
"(Pdb) kommandon 1\n"
"(com) p någon_variabel\n"
"(com) slut\n"
"(Pdb)"

#: ../../library/pdb.rst:516
msgid ""
"To remove all commands from a breakpoint, type ``commands`` and follow it "
"immediately with ``end``; that is, give no commands."
msgstr ""
"För att ta bort alla kommandon från en brytpunkt, skriv ``kommandon`` och "
"följ omedelbart efter med ``slut``, dvs. ge inga kommandon."

#: ../../library/pdb.rst:519
msgid ""
"With no *bpnumber* argument, ``commands`` refers to the last breakpoint set."
msgstr ""
"Utan argumentet *bpnumber* hänvisar ``commands`` till den senast inställda "
"brytpunkten."

#: ../../library/pdb.rst:521
msgid ""
"You can use breakpoint commands to start your program up again.  Simply use "
"the :pdbcmd:`continue` command, or :pdbcmd:`step`, or any other command that "
"resumes execution."
msgstr ""
"Du kan använda brytpunktskommandon för att starta upp programmet igen.  "
"Använd helt enkelt kommandot :pdbcmd:`continue`, eller :pdbcmd:`step`, eller "
"något annat kommando som återupptar exekveringen."

#: ../../library/pdb.rst:525
msgid ""
"Specifying any command resuming execution (currently :pdbcmd:`continue`, :"
"pdbcmd:`step`, :pdbcmd:`next`, :pdbcmd:`return`, :pdbcmd:`until`, :pdbcmd:"
"`jump`, :pdbcmd:`quit` and their abbreviations) terminates the command list "
"(as if that command was immediately followed by end). This is because any "
"time you resume execution (even with a simple next or step), you may "
"encounter another breakpoint—which could have its own command list, leading "
"to ambiguities about which list to execute."
msgstr ""
"Om du anger ett kommando som återupptar körningen (för närvarande :pdbcmd:"
"`continue`, :pdbcmd:`step`, :pdbcmd:`next`, :pdbcmd:`return`, :pdbcmd:"
"`until`, :pdbcmd:`jump`, :pdbcmd:`quit` och deras förkortningar) avslutas "
"kommandolistan (som om kommandot omedelbart följdes av end). Detta beror på "
"att varje gång du återupptar körningen (även med ett enkelt next eller step) "
"kan du stöta på en annan brytpunkt - som kan ha sin egen kommandolista, "
"vilket leder till tvetydigheter om vilken lista som ska köras."

#: ../../library/pdb.rst:534
msgid ""
"If the list of commands contains the ``silent`` command, or a command that "
"resumes execution, then the breakpoint message containing information about "
"the frame is not displayed."
msgstr ""
"Om listan med kommandon innehåller kommandot ``silent``, eller ett kommando "
"som återupptar körningen, visas inte brytpunktsmeddelandet med information "
"om ramen."

#: ../../library/pdb.rst:538
msgid ""
"Frame information will not be displayed if a command that resumes execution "
"is present in the command list."
msgstr ""
"Raminformation visas inte om ett kommando som återupptar körningen finns i "
"kommandolistan."

#: ../../library/pdb.rst:544
msgid ""
"Execute the current line, stop at the first possible occasion (either in a "
"function that is called or on the next line in the current function)."
msgstr ""
"Exekvera den aktuella raden, stoppa vid första möjliga tillfälle (antingen i "
"en funktion som anropas eller på nästa rad i den aktuella funktionen)."

#: ../../library/pdb.rst:549
msgid ""
"Continue execution until the next line in the current function is reached or "
"it returns.  (The difference between :pdbcmd:`next` and :pdbcmd:`step` is "
"that :pdbcmd:`step` stops inside a called function, while :pdbcmd:`next` "
"executes called functions at (nearly) full speed, only stopping at the next "
"line in the current function.)"
msgstr ""
"Fortsätter exekveringen tills nästa rad i den aktuella funktionen nås eller "
"tills den returneras.  (Skillnaden mellan :pdbcmd:`next` och :pdbcmd:`step` "
"är att :pdbcmd:`step` stannar inuti en anropad funktion, medan :pdbcmd:"
"`next` kör anropade funktioner i (nästan) full hastighet och bara stannar "
"vid nästa rad i den aktuella funktionen)"

#: ../../library/pdb.rst:557
msgid ""
"Without argument, continue execution until the line with a number greater "
"than the current one is reached."
msgstr ""
"Utan argument fortsätter exekveringen tills raden med ett nummer som är "
"större än det aktuella nås."

#: ../../library/pdb.rst:560
msgid ""
"With *lineno*, continue execution until a line with a number greater or "
"equal to *lineno* is reached.  In both cases, also stop when the current "
"frame returns."
msgstr ""
"Med *lineno* fortsätter exekveringen tills en rad med ett nummer som är "
"större än eller lika med *lineno* nås.  I båda fallen stoppas också när den "
"aktuella ramen återkommer."

#: ../../library/pdb.rst:564
msgid "Allow giving an explicit line number."
msgstr "Tillåt att ange ett explicit linjenummer."

#: ../../library/pdb.rst:569
msgid "Continue execution until the current function returns."
msgstr "Fortsätt körningen tills den aktuella funktionen återkommer."

#: ../../library/pdb.rst:573
msgid "Continue execution, only stop when a breakpoint is encountered."
msgstr "Fortsätt exekveringen, stoppa först när en brytpunkt påträffas."

#: ../../library/pdb.rst:577
msgid ""
"Set the next line that will be executed.  Only available in the bottom-most "
"frame.  This lets you jump back and execute code again, or jump forward to "
"skip code that you don't want to run."
msgstr ""
"Ange nästa rad som ska köras.  Endast tillgängligt i den nedersta ramen.  "
"Detta gör att du kan hoppa tillbaka och exekvera kod igen, eller hoppa "
"framåt för att hoppa över kod som du inte vill köra."

#: ../../library/pdb.rst:581
msgid ""
"It should be noted that not all jumps are allowed -- for instance it is not "
"possible to jump into the middle of a :keyword:`for` loop or out of a :"
"keyword:`finally` clause."
msgstr ""
"Det bör noteras att inte alla hopp är tillåtna -- det är t.ex. inte möjligt "
"att hoppa in i mitten av en :keyword:`for`-loop eller ut ur en :keyword:"
"`finally`-klausul."

#: ../../library/pdb.rst:587
msgid ""
"List source code for the current file.  Without arguments, list 11 lines "
"around the current line or continue the previous listing.  With ``.`` as "
"argument, list 11 lines around the current line.  With one argument, list 11 "
"lines around at that line.  With two arguments, list the given range; if the "
"second argument is less than the first, it is interpreted as a count."
msgstr ""
"Listar källkoden för den aktuella filen.  Utan argument, lista 11 rader runt "
"den aktuella raden eller fortsätt med föregående lista.  Med ``.`` som "
"argument listas 11 rader runt den aktuella raden.  Med ett argument listas "
"11 rader runt den raden.  Med två argument listas det angivna intervallet; "
"om det andra argumentet är mindre än det första tolkas det som en räkning."

#: ../../library/pdb.rst:593
msgid ""
"The current line in the current frame is indicated by ``->``.  If an "
"exception is being debugged, the line where the exception was originally "
"raised or propagated is indicated by ``>>``, if it differs from the current "
"line."
msgstr ""
"Den aktuella raden i den aktuella bildrutan anges med ``->``.  Om ett "
"undantag felsöks, anges raden där undantaget ursprungligen uppstod eller "
"spreds med ``>>``, om den skiljer sig från den aktuella raden."

#: ../../library/pdb.rst:598
msgid "Added the ``>>`` marker."
msgstr "Lade till markören ``>>``."

#: ../../library/pdb.rst:603
msgid ""
"List all source code for the current function or frame.  Interesting lines "
"are marked as for :pdbcmd:`list`."
msgstr ""
"Lista all källkod för den aktuella funktionen eller ramen.  Intressanta "
"rader markeras som för :pdbcmd:`list`."

#: ../../library/pdb.rst:610
msgid "Print the arguments of the current function and their current values."
msgstr ""
"Skriv ut argumenten för den aktuella funktionen och deras aktuella värden."

#: ../../library/pdb.rst:614
msgid "Evaluate *expression* in the current context and print its value."
msgstr ""
"Utvärdera *uttryck* i det aktuella sammanhanget och skriv ut dess värde."

#: ../../library/pdb.rst:618
msgid ""
"``print()`` can also be used, but is not a debugger command --- this "
"executes the Python :func:`print` function."
msgstr ""
"``print()`` kan också användas, men är inte ett debugger-kommando --- detta "
"exekverar Python :func:`print`-funktionen."

#: ../../library/pdb.rst:624
msgid ""
"Like the :pdbcmd:`p` command, except the value of *expression* is pretty-"
"printed using the :mod:`pprint` module."
msgstr ""
"Som kommandot :pdbcmd:`p`, förutom att värdet av *uttryck* skrivs ut med "
"modulen :mod:`pprint`."

#: ../../library/pdb.rst:629
msgid "Print the type of *expression*."
msgstr "Skriv ut typen av *uttryck*."

#: ../../library/pdb.rst:633
msgid "Try to get source code of *expression* and display it."
msgstr "Försök att få fram källkoden för *uttryck* och visa den."

#: ../../library/pdb.rst:639
msgid ""
"Display the value of *expression* if it changed, each time execution stops "
"in the current frame."
msgstr ""
"Visa värdet på *uttryck* om det har ändrats, varje gång exekveringen stoppas "
"i den aktuella bildrutan."

#: ../../library/pdb.rst:642
msgid ""
"Without *expression*, list all display expressions for the current frame."
msgstr "Utan *uttryck* listas alla displayuttryck för den aktuella bildrutan."

#: ../../library/pdb.rst:646
msgid ""
"Display evaluates *expression* and compares to the result of the previous "
"evaluation of *expression*, so when the result is mutable, display may not "
"be able to pick up the changes."
msgstr ""
"Display utvärderar *uttryck* och jämför med resultatet av den föregående "
"utvärderingen av *uttryck*, så när resultatet är föränderligt är det inte "
"säkert att displayen kan fånga upp ändringarna."

#: ../../library/pdb.rst:650 ../../library/pdb.rst:815
msgid "Example::"
msgstr "Exempel::"

#: ../../library/pdb.rst:652
msgid ""
"lst = []\n"
"breakpoint()\n"
"pass\n"
"lst.append(1)\n"
"print(lst)"
msgstr ""
"lst = []\n"
"breakpoint()\n"
"pass\n"
"lst.append(1)\n"
"print(lst)"

#: ../../library/pdb.rst:658
msgid ""
"Display won't realize ``lst`` has been changed because the result of "
"evaluation is modified in place by ``lst.append(1)`` before being compared::"
msgstr ""
"Displayen kommer inte att inse att ``lst`` har ändrats eftersom resultatet "
"av utvärderingen modifieras på plats av ``lst.append(1)`` innan det jämförs::"

#: ../../library/pdb.rst:661
msgid ""
"> example.py(3)<module>()\n"
"-> pass\n"
"(Pdb) display lst\n"
"display lst: []\n"
"(Pdb) n\n"
"> example.py(4)<module>()\n"
"-> lst.append(1)\n"
"(Pdb) n\n"
"> example.py(5)<module>()\n"
"-> print(lst)\n"
"(Pdb)"
msgstr ""
"> example.py(3)<module>()\n"
"-> pass\n"
"(Pdb) display lst\n"
"display lst: []\n"
"(Pdb) n\n"
"> example.py(4)<module>()\n"
"-> lst.append(1)\n"
"(Pdb) n\n"
"> example.py(5)<module>()\n"
"-> print(lst)\n"
"(Pdb)"

#: ../../library/pdb.rst:673
msgid "You can do some tricks with copy mechanism to make it work::"
msgstr ""
"Du kan göra några trick med kopieringsmekanismen för att få den att fungera::"

#: ../../library/pdb.rst:675
msgid ""
"> example.py(3)<module>()\n"
"-> pass\n"
"(Pdb) display lst[:]\n"
"display lst[:]: []\n"
"(Pdb) n\n"
"> example.py(4)<module>()\n"
"-> lst.append(1)\n"
"(Pdb) n\n"
"> example.py(5)<module>()\n"
"-> print(lst)\n"
"display lst[:]: [1]  [old: []]\n"
"(Pdb)"
msgstr ""
"> example.py(3)<module>()\n"
"-> pass\n"
"(Pdb) display lst[:]\n"
"display lst[:]: []\n"
"(Pdb) n\n"
"> example.py(4)<module>()\n"
"-> lst.append(1)\n"
"(Pdb) n\n"
"> example.py(5)<module>()\n"
"-> print(lst)\n"
"display lst[:]: [1]  [old: []]\n"
"(Pdb)"

#: ../../library/pdb.rst:692
msgid ""
"Do not display *expression* anymore in the current frame.  Without "
"*expression*, clear all display expressions for the current frame."
msgstr ""
"Visa inte *uttryck* längre i den aktuella bildrutan.  Utan *uttryck* rensas "
"alla visningsuttryck för den aktuella ramen."

#: ../../library/pdb.rst:699
msgid ""
"Start an interactive interpreter (using the :mod:`code` module) in a new "
"global namespace initialised from the local and global namespaces for the "
"current scope. Use ``exit()`` or ``quit()`` to exit the interpreter and "
"return to the debugger."
msgstr ""
"Starta en interaktiv tolk (med modulen :mod:`code`) i en ny global namnrymd "
"som initieras från de lokala och globala namnrymderna för det aktuella "
"området. Använd ``exit()`` eller ``quit()`` för att avsluta tolken och "
"återgå till felsökaren."

#: ../../library/pdb.rst:706
msgid ""
"As ``interact`` creates a new dedicated namespace for code execution, "
"assignments to variables will not affect the original namespaces. However, "
"modifications to any referenced mutable objects will be reflected in the "
"original namespaces as usual."
msgstr ""
"Eftersom ``interact`` skapar ett nytt dedikerat namnrymd för exekvering av "
"kod, kommer tilldelningar till variabler inte att påverka de ursprungliga "
"namnrymderna. Modifieringar av alla refererade mutabla objekt kommer dock "
"att återspeglas i de ursprungliga namnrymderna som vanligt."

#: ../../library/pdb.rst:713
msgid ""
"``exit()`` and ``quit()`` can be used to exit the :pdbcmd:`interact` command."
msgstr ""
"``exit()`` och ``quit()`` kan användas för att avsluta kommandot :pdbcmd:"
"`interact`."

#: ../../library/pdb.rst:717
msgid ""
":pdbcmd:`interact` directs its output to the debugger's output channel "
"rather than :data:`sys.stderr`."
msgstr ""
":pdbcmd:`interact` styr utdata till debuggarens utdatakanal i stället för "
"till :data:`sys.stderr`."

#: ../../library/pdb.rst:725
msgid ""
"Create an alias called *name* that executes *command*.  The *command* must "
"*not* be enclosed in quotes.  Replaceable parameters can be indicated by "
"``%1``, ``%2``, ... and ``%9``, while ``%*`` is replaced by all the "
"parameters. If *command* is omitted, the current alias for *name* is shown. "
"If no arguments are given, all aliases are listed."
msgstr ""
"Skapa ett alias som heter *namn* och som utför *kommando*.  *kommandot* får "
"*inte* vara omslutet av citationstecken.  Ersättningsbara parametrar kan "
"anges med ``%1``, ``%2``, ... och ``%9``, medan ``%*`` ersätts av alla "
"parametrar. Om *kommando* utelämnas visas det aktuella aliaset för *namn*. "
"Om inga argument anges listas alla alias."

#: ../../library/pdb.rst:731
msgid ""
"Aliases may be nested and can contain anything that can be legally typed at "
"the pdb prompt.  Note that internal pdb commands *can* be overridden by "
"aliases.  Such a command is then hidden until the alias is removed.  "
"Aliasing is recursively applied to the first word of the command line; all "
"other words in the line are left alone."
msgstr ""
"Alias kan vara nästlade och kan innehålla vad som helst som lagligen kan "
"skrivas vid pdb-prompten.  Observera att interna pdb-kommandon *kan* "
"åsidosättas av alias.  Ett sådant kommando är då dolt tills aliaset tas "
"bort.  Alias tillämpas rekursivt på det första ordet i kommandoraden; alla "
"andra ord i raden lämnas obehandlade."

#: ../../library/pdb.rst:737
msgid ""
"As an example, here are two useful aliases (especially when placed in the :"
"file:`.pdbrc` file)::"
msgstr ""
"Som exempel kan nämnas två användbara alias (särskilt när de placeras i "
"filen :file:`.pdbrc`)::"

#: ../../library/pdb.rst:740
msgid ""
"# Print instance variables (usage \"pi classInst\")\n"
"alias pi for k in %1.__dict__.keys(): print(f\"%1.{k} = {%1.__dict__[k]}\")\n"
"# Print instance variables in self\n"
"alias ps pi self"
msgstr ""
"# Skriv ut instansvariabler (användning \"pi classInst\")\n"
"alias pi for k in %1.__dict__.keys(): print(f\"%1.{k} = {%1.__dict__[k]}\")\n"
"# Skriv ut instansvariabler i self\n"
"alias ps pi själv"

#: ../../library/pdb.rst:747
msgid "Delete the specified alias *name*."
msgstr "Ta bort det angivna aliaset *namn*."

#: ../../library/pdb.rst:751
msgid ""
"Execute the (one-line) *statement* in the context of the current stack "
"frame. The exclamation point can be omitted unless the first word of the "
"statement resembles a debugger command, e.g.:"
msgstr ""
"Exekvera (enradigt) *uttalandet* i kontexten för den aktuella stackramen. "
"Utropstecknet kan utelämnas om inte det första ordet i satsen liknar ett "
"debugger-kommando, t.ex:"

#: ../../library/pdb.rst:755
msgid ""
"(Pdb) ! n=42\n"
"(Pdb)"
msgstr ""
"(Pdb) ! n=42\n"
"(Pdb)"

#: ../../library/pdb.rst:760
msgid ""
"To set a global variable, you can prefix the assignment command with a :"
"keyword:`global` statement on the same line, e.g.:"
msgstr ""
"För att ställa in en global variabel kan du prefixera assignment-kommandot "
"med en :keyword:`global`-sats på samma rad, t.ex:"

#: ../../library/pdb.rst:763
msgid ""
"(Pdb) global list_options; list_options = ['-l']\n"
"(Pdb)"
msgstr ""
"(Pdb) global list_options; list_options = ['-l']\n"
"(Pdb)"

#: ../../library/pdb.rst:771
msgid ""
"Restart the debugged Python program.  If *args* is supplied, it is split "
"with :mod:`shlex` and the result is used as the new :data:`sys.argv`. "
"History, breakpoints, actions and debugger options are preserved. :pdbcmd:"
"`restart` is an alias for :pdbcmd:`run`."
msgstr ""
"Startar om det felsökta Python-programmet.  Om *args* anges delas den upp "
"med :mod:`shlex` och resultatet används som ny :data:`sys.argv`. Historik, "
"brytpunkter, åtgärder och debuggaralternativ bevaras. :pdbcmd:`restart` är "
"ett alias för :pdbcmd:`run`."

#: ../../library/pdb.rst:776
msgid ""
":pdbcmd:`run` and :pdbcmd:`restart` commands are disabled when the debugger "
"is invoked in ``'inline'`` mode."
msgstr ""
"kommandona :pdbcmd:`run` och :pdbcmd:`restart` inaktiveras när debuggern "
"anropas i ``'inline'``-läge."

#: ../../library/pdb.rst:782
msgid ""
"Quit from the debugger.  The program being executed is aborted. An end-of-"
"file input is equivalent to :pdbcmd:`quit`."
msgstr ""
"Avsluta från felsökaren.  Det program som körs avbryts. En inmatning vid "
"slutet av filen motsvarar :pdbcmd:`quit`."

#: ../../library/pdb.rst:785
msgid ""
"A confirmation prompt will be shown if the debugger is invoked in "
"``'inline'`` mode. Either ``y``, ``Y``, ``<Enter>`` or ``EOF`` will confirm "
"the quit."
msgstr ""
"En bekräftelseprompt visas om felsökaren anropas i ``'inline'``-läge. "
"Antingen ``y``, ``Y``, ``<Enter>`` eller ``EOF`` kommer att bekräfta "
"avslutningen."

#: ../../library/pdb.rst:789
msgid ""
"A confirmation prompt will be shown if the debugger is invoked in "
"``'inline'`` mode. After the confirmation, the debugger will call :func:`sys."
"exit` immediately, instead of raising :exc:`bdb.BdbQuit` in the next trace "
"event."
msgstr ""
"En bekräftelseprompt visas om felsökaren anropas i ``'inline'``-läge. Efter "
"bekräftelsen anropar felsökaren :func:`sys.exit` omedelbart, i stället för :"
"exc:`bdb.BdbQuit` i nästa spårningshändelse."

#: ../../library/pdb.rst:797
msgid ""
"Enter a recursive debugger that steps through *code* (which is an arbitrary "
"expression or statement to be executed in the current environment)."
msgstr ""
"Ange en rekursiv felsökare som går igenom *kod* (vilket är ett godtyckligt "
"uttryck eller en sats som ska utföras i den aktuella miljön)."

#: ../../library/pdb.rst:803
msgid "Print the return value for the last return of the current function."
msgstr "Skriv ut returvärdet för den sista returen i den aktuella funktionen."

#: ../../library/pdb.rst:807
msgid "List or jump between chained exceptions."
msgstr "Lista eller hoppa mellan kedjade undantag."

#: ../../library/pdb.rst:809
msgid ""
"When using ``pdb.pm()``  or ``Pdb.post_mortem(...)`` with a chained "
"exception instead of a traceback, it allows the user to move between the "
"chained exceptions using ``exceptions`` command to list exceptions, and "
"``exceptions <number>`` to switch to that exception."
msgstr ""
"När du använder ``pdb.pm()`` eller ``Pdb.post_mortem(...)`` med ett kedjat "
"undantag istället för en spårning, tillåter det användaren att flytta mellan "
"de kedjade undantagen med kommandot ``exceptions`` för att lista undantag "
"och ``exceptions <number>`` för att byta till det undantaget."

#: ../../library/pdb.rst:817
msgid ""
"def out():\n"
"    try:\n"
"        middle()\n"
"    except Exception as e:\n"
"        raise ValueError(\"reraise middle() error\") from e\n"
"\n"
"def middle():\n"
"    try:\n"
"        return inner(0)\n"
"    except Exception as e:\n"
"        raise ValueError(\"Middle fail\")\n"
"\n"
"def inner(x):\n"
"    1 / x\n"
"\n"
" out()"
msgstr ""
"def out():\n"
"    try:\n"
"        middle()\n"
"    except Exception as e:\n"
"        raise ValueError(\"reraise middle() error\") from e\n"
"\n"
"def middle():\n"
"    try:\n"
"        return inner(0)\n"
"    except Exception as e:\n"
"        raise ValueError(\"Middle fail\")\n"
"\n"
"def inner(x):\n"
"    1 / x\n"
"\n"
" out()"

#: ../../library/pdb.rst:834
msgid "calling ``pdb.pm()`` will allow to move between exceptions::"
msgstr ""
"att anropa ``pdb.pm()`` kommer att göra det möjligt att flytta mellan "
"undantag::"

#: ../../library/pdb.rst:836
msgid ""
"> example.py(5)out()\n"
"-> raise ValueError(\"reraise middle() error\") from e\n"
"\n"
"(Pdb) exceptions\n"
"  0 ZeroDivisionError('division by zero')\n"
"  1 ValueError('Middle fail')\n"
"> 2 ValueError('reraise middle() error')\n"
"\n"
"(Pdb) exceptions 0\n"
"> example.py(16)inner()\n"
"-> 1 / x\n"
"\n"
"(Pdb) up\n"
"> example.py(10)middle()\n"
"-> return inner(0)"
msgstr ""
"> example.py(5)out()\n"
"-> raise ValueError(\"reraise middle() error\") from e\n"
"\n"
"(Pdb) exceptions\n"
"  0 ZeroDivisionError('division by zero')\n"
"  1 ValueError('Middle fail')\n"
"> 2 ValueError('reraise middle() error')\n"
"\n"
"(Pdb) exceptions 0\n"
"> example.py(16)inner()\n"
"-> 1 / x\n"
"\n"
"(Pdb) up\n"
"> example.py(10)middle()\n"
"-> return inner(0)"

#: ../../library/pdb.rst:855
msgid "Footnotes"
msgstr "Fotnoter"

#: ../../library/pdb.rst:856
msgid ""
"Whether a frame is considered to originate in a certain module is determined "
"by the ``__name__`` in the frame globals."
msgstr ""
"Om en frame anses ha sitt ursprung i en viss modul avgörs av ``__name__`` i "
"frame-globalerna."

#: ../../library/pdb.rst:11
msgid "debugging"
msgstr "felsökning"

#: ../../library/pdb.rst:21
msgid "Pdb (class in pdb)"
msgstr "Pdb (klass i pdb)"

#: ../../library/pdb.rst:21
msgid "module"
msgstr "modul"

#: ../../library/pdb.rst:21
msgid "bdb"
msgstr "bdb"

#: ../../library/pdb.rst:21
msgid "cmd"
msgstr "cmd"

#: ../../library/pdb.rst:396
msgid ".pdbrc"
msgstr ".pdbrc"

#: ../../library/pdb.rst:396
msgid "file"
msgstr "fil"

#: ../../library/pdb.rst:396
msgid "debugger"
msgstr "felsökare"

#: ../../library/pdb.rst:396
msgid "configuration"
msgstr "konfiguration"
