# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Daniel Nylander <po@danielnylander.se>, 2025
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-15 15:08+0000\n"
"PO-Revision-Date: 2025-09-15 01:04+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../library/shutil.rst:2
msgid ":mod:`!shutil` --- High-level file operations"
msgstr ":mod:`!shutil` --- Filoperationer på hög nivå"

#: ../../library/shutil.rst:10
msgid "**Source code:** :source:`Lib/shutil.py`"
msgstr "**Källkod:** :source:`Lib/shutil.py`"

#: ../../library/shutil.rst:18
msgid ""
"The :mod:`shutil` module offers a number of high-level operations on files "
"and collections of files.  In particular, functions are provided  which "
"support file copying and removal. For operations on individual files, see "
"also the :mod:`os` module."
msgstr ""
"Modulen :mod:`shutil` erbjuder ett antal funktioner på hög nivå för filer "
"och samlingar av filer.  I synnerhet finns funktioner som stöder kopiering "
"och borttagning av filer. För operationer på enskilda filer, se även "
"modulen :mod:`os`."

#: ../../library/shutil.rst:25
msgid ""
"Even the higher-level file copying functions (:func:`shutil.copy`, :func:"
"`shutil.copy2`) cannot copy all file metadata."
msgstr ""
"Inte ens filkopieringsfunktionerna på högre nivå (:func:`shutil.copy`, :func:"
"`shutil.copy2`) kan kopiera alla filmetadata."

#: ../../library/shutil.rst:28
msgid ""
"On POSIX platforms, this means that file owner and group are lost as well as "
"ACLs.  On Mac OS, the resource fork and other metadata are not used. This "
"means that resources will be lost and file type and creator codes will not "
"be correct. On Windows, file owners, ACLs and alternate data streams are not "
"copied."
msgstr ""
"På POSIX-plattformar innebär detta att filägare och grupp försvinner, liksom "
"ACL:er.  På Mac OS används inte resursgaffeln och andra metadata. Det "
"innebär att resurser går förlorade och att filtyp och skaparkod inte blir "
"korrekta. På Windows kopieras inte filägare, ACL:er och alternativa "
"dataströmmar."

#: ../../library/shutil.rst:38
msgid "Directory and files operations"
msgstr "Katalog- och filoperationer"

#: ../../library/shutil.rst:42
msgid ""
"Copy the contents of the :term:`file-like object <file object>` *fsrc* to "
"the file-like object *fdst*. The integer *length*, if given, is the buffer "
"size. In particular, a negative *length* value means to copy the data "
"without looping over the source data in chunks; by default the data is read "
"in chunks to avoid uncontrolled memory consumption. Note that if the current "
"file position of the *fsrc* object is not 0, only the contents from the "
"current file position to the end of the file will be copied."
msgstr ""
"Kopierar innehållet i :term:`filliknande objekt <file object>` *fsrc* till "
"det filliknande objektet *fdst*. Heltalet *length*, om det anges, är "
"buffertstorleken. Ett negativt *length*-värde innebär att data kopieras utan "
"att källdata loopas i bitar; som standard läses data i bitar för att undvika "
"okontrollerad minnesförbrukning. Observera att om den aktuella filpositionen "
"för *fsrc*-objektet inte är 0, kommer endast innehållet från den aktuella "
"filpositionen till slutet av filen att kopieras."

#: ../../library/shutil.rst:53
msgid ""
"Copy the contents (no metadata) of the file named *src* to a file named "
"*dst* and return *dst* in the most efficient way possible. *src* and *dst* "
"are :term:`path-like objects <path-like object>` or path names given as "
"strings."
msgstr ""
"Kopiera innehållet (inga metadata) i filen med namnet *src* till en fil med "
"namnet *dst* och returnera *dst* på effektivast möjliga sätt. *src* och "
"*dst* är :term:`sökvägsliknande objekt <path-like object>` eller sökvägsnamn "
"angivna som strängar."

#: ../../library/shutil.rst:57
msgid ""
"*dst* must be the complete target file name; look at :func:`~shutil.copy` "
"for a copy that accepts a target directory path.  If *src* and *dst* specify "
"the same file, :exc:`SameFileError` is raised."
msgstr ""
"*dst* måste vara det fullständiga målfilsnamnet; se :func:`~shutil.copy` för "
"en kopiering som accepterar en målkatalogsökväg.  Om *src* och *dst* anger "
"samma fil, uppstår :exc:`SameFileError`."

#: ../../library/shutil.rst:61
msgid ""
"The destination location must be writable; otherwise, an :exc:`OSError` "
"exception will be raised. If *dst* already exists, it will be replaced. "
"Special files such as character or block devices and pipes cannot be copied "
"with this function."
msgstr ""
"Destinationsplatsen måste vara skrivbar, annars kommer ett :exc:`OSError` "
"undantag att uppstå. Om *dst* redan finns kommer den att ersättas. "
"Specialfiler som tecken- eller blockenheter och pipes kan inte kopieras med "
"den här funktionen."

#: ../../library/shutil.rst:66
msgid ""
"If *follow_symlinks* is false and *src* is a symbolic link, a new symbolic "
"link will be created instead of copying the file *src* points to."
msgstr ""
"Om *follow_symlinks* är false och *src* är en symbolisk länk, skapas en ny "
"symbolisk länk i stället för att kopiera filen som *src* pekar på."

#: ../../library/shutil.rst:70 ../../library/shutil.rst:184
#: ../../library/shutil.rst:215
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.copyfile`` with "
"arguments ``src``, ``dst``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``shutil.copyfile`` med "
"argumenten ``src``, ``dst``."

#: ../../library/shutil.rst:72
msgid ""
":exc:`IOError` used to be raised instead of :exc:`OSError`. Added "
"*follow_symlinks* argument. Now returns *dst*."
msgstr ""
":exc:`IOError` brukade visas istället för :exc:`OSError`. Argumentet "
"*follow_symlinks* lades till. Returnerar nu *dst*."

#: ../../library/shutil.rst:77
msgid ""
"Raise :exc:`SameFileError` instead of :exc:`Error`.  Since the former is a "
"subclass of the latter, this change is backward compatible."
msgstr ""
"Utlös :exc:`SameFileError` istället för :exc:`Error`.  Eftersom den förra är "
"en subklass av den senare är denna ändring bakåtkompatibel."

#: ../../library/shutil.rst:81 ../../library/shutil.rst:192
#: ../../library/shutil.rst:224 ../../library/shutil.rst:294
#: ../../library/shutil.rst:407
msgid ""
"Platform-specific fast-copy syscalls may be used internally in order to copy "
"the file more efficiently. See :ref:`shutil-platform-dependent-efficient-"
"copy-operations` section."
msgstr ""
"Plattformsspecifika syscalls för snabbkopiering kan användas internt för att "
"kopiera filen mer effektivt. Se avsnittet :ref:`shutil-platform-dependent-"
"efficient-copy-operations`."

#: ../../library/shutil.rst:88
msgid ""
"This exception is raised when :func:`copyfile` or :func:`copytree` attempt "
"to copy a named pipe."
msgstr ""

#: ../../library/shutil.rst:95
msgid ""
"This exception is raised if source and destination in :func:`copyfile` are "
"the same file."
msgstr ""
"Detta undantag uppstår om källan och destinationen i :func:`copyfile` är "
"samma fil."

#: ../../library/shutil.rst:103
msgid ""
"Copy the permission bits from *src* to *dst*.  The file contents, owner, and "
"group are unaffected.  *src* and *dst* are :term:`path-like objects <path-"
"like object>` or path names given as strings. If *follow_symlinks* is false, "
"and both *src* and *dst* are symbolic links, :func:`copymode` will attempt "
"to modify the mode of *dst* itself (rather than the file it points to).  "
"This functionality is not available on every platform; please see :func:"
"`copystat` for more information.  If :func:`copymode` cannot modify symbolic "
"links on the local platform, and it is asked to do so, it will do nothing "
"and return."
msgstr ""
"Kopiera behörighetsbitarna från *src* till *dst*.  Filens innehåll, ägare "
"och grupp påverkas inte.  *src* och *dst* är :term:`sökvägsliknande objekt "
"<path-like object>` eller sökvägsnamn angivna som strängar. Om "
"*follow_symlinks* är false och både *src* och *dst* är symboliska länkar, "
"kommer :func:`copymode` att försöka ändra läget för *dst* själv (snarare än "
"filen den pekar på).  Denna funktion är inte tillgänglig på alla "
"plattformar; se :func:`copystat` för mer information.  Om :func:`copymode` "
"inte kan modifiera symboliska länkar på den lokala plattformen, och den "
"ombeds att göra det, kommer den inte att göra någonting och returnera."

#: ../../library/shutil.rst:113 ../../library/shutil.rst:186
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.copymode`` with "
"arguments ``src``, ``dst``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``shutil.copymode`` med "
"argumenten ``src``, ``dst``."

#: ../../library/shutil.rst:115
msgid "Added *follow_symlinks* argument."
msgstr "Lagt till argumentet *follow_symlinks*."

#: ../../library/shutil.rst:120
msgid ""
"Copy the permission bits, last access time, last modification time, and "
"flags from *src* to *dst*.  On Linux, :func:`copystat` also copies the "
"\"extended attributes\" where possible.  The file contents, owner, and group "
"are unaffected.  *src* and *dst* are :term:`path-like objects <path-like "
"object>` or path names given as strings."
msgstr ""
"Kopierar behörighetsbitar, senaste åtkomsttid, senaste ändringstid och "
"flaggor från *src* till *dst*.  På Linux kopierar :func:`copystat` även de "
"\"utökade attributen\" där så är möjligt.  Filinnehåll, ägare och grupp "
"påverkas inte.  *src* och *dst* är :term:`sökvägsliknande objekt <path-like "
"object>` eller sökvägsnamn angivna som strängar."

#: ../../library/shutil.rst:126
msgid ""
"If *follow_symlinks* is false, and *src* and *dst* both refer to symbolic "
"links, :func:`copystat` will operate on the symbolic links themselves rather "
"than the files the symbolic links refer to—reading the information from the "
"*src* symbolic link, and writing the information to the *dst* symbolic link."
msgstr ""
"Om *follow_symlinks* är false, och *src* och *dst* båda hänvisar till "
"symboliska länkar, kommer :func:`copystat` att arbeta med de symboliska "
"länkarna själva snarare än med de filer som de symboliska länkarna hänvisar "
"till - läsa informationen från den symboliska länken *src* och skriva "
"informationen till den symboliska länken *dst*."

#: ../../library/shutil.rst:135
msgid ""
"Not all platforms provide the ability to examine and modify symbolic links.  "
"Python itself can tell you what functionality is locally available."
msgstr ""
"Det är inte alla plattformar som ger möjlighet att undersöka och ändra "
"symboliska länkar.  Python själv kan berätta vilken funktionalitet som är "
"lokalt tillgänglig."

#: ../../library/shutil.rst:139
msgid ""
"If ``os.chmod in os.supports_follow_symlinks`` is ``True``, :func:`copystat` "
"can modify the permission bits of a symbolic link."
msgstr ""
"Om ``os.chmod in os.supports_follow_symlinks`` är ``True``, kan :func:"
"`copystat` ändra behörighetsbitarna för en symbolisk länk."

#: ../../library/shutil.rst:143
msgid ""
"If ``os.utime in os.supports_follow_symlinks`` is ``True``, :func:`copystat` "
"can modify the last access and modification times of a symbolic link."
msgstr ""
"Om ``os.utime in os.supports_follow_symlinks`` är ``True``, kan :func:"
"`copystat` ändra den senaste åtkomst- och ändringstiden för en symbolisk "
"länk."

#: ../../library/shutil.rst:147
msgid ""
"If ``os.chflags in os.supports_follow_symlinks`` is ``True``, :func:"
"`copystat` can modify the flags of a symbolic link.  (``os.chflags`` is not "
"available on all platforms.)"
msgstr ""
"Om ``os.chflags in os.supports_follow_symlinks`` är ``True`` kan :func:"
"`copystat` ändra flaggorna för en symbolisk länk.  (``os.chflags`` är inte "
"tillgänglig på alla plattformar)"

#: ../../library/shutil.rst:152
msgid ""
"On platforms where some or all of this functionality is unavailable, when "
"asked to modify a symbolic link, :func:`copystat` will copy everything it "
"can. :func:`copystat` never returns failure."
msgstr ""
"På plattformar där en del av eller all denna funktionalitet inte är "
"tillgänglig, kommer :func:`copystat` att kopiera allt den kan när den ombeds "
"att ändra en symbolisk länk. :func:`copystat` returnerar aldrig fel."

#: ../../library/shutil.rst:157
msgid "Please see :data:`os.supports_follow_symlinks` for more information."
msgstr "Se :data:`os.supports_follow_symlinks` för mer information."

#: ../../library/shutil.rst:160 ../../library/shutil.rst:217
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.copystat`` with "
"arguments ``src``, ``dst``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``shutil.copystat`` med "
"argumenten ``src``, ``dst``."

#: ../../library/shutil.rst:162
msgid ""
"Added *follow_symlinks* argument and support for Linux extended attributes."
msgstr ""
"Argumentet *follow_symlinks* och stöd för Linux utökade attribut har lagts "
"till."

#: ../../library/shutil.rst:167
msgid ""
"Copies the file *src* to the file or directory *dst*.  *src* and *dst* "
"should be :term:`path-like objects <path-like object>` or strings.  If *dst* "
"specifies a directory, the file will be copied into *dst* using the base "
"filename from *src*. If *dst* specifies a file that already exists, it will "
"be replaced. Returns the path to the newly created file."
msgstr ""
"Kopierar filen *src* till filen eller katalogen *dst*.  *src* och *dst* bör "
"vara :term:`path-liknande objekt <path-like object>` eller strängar.  Om "
"*dst* anger en katalog kommer filen att kopieras till *dst* med hjälp av "
"basfilnamnet från *src*. Om *dst* anger en fil som redan finns kommer den "
"att ersättas. Returnerar sökvägen till den nyskapade filen."

#: ../../library/shutil.rst:173
msgid ""
"If *follow_symlinks* is false, and *src* is a symbolic link, *dst* will be "
"created as a symbolic link.  If *follow_symlinks* is true and *src* is a "
"symbolic link, *dst* will be a copy of the file *src* refers to."
msgstr ""
"Om *follow_symlinks* är false och *src* är en symbolisk länk kommer *dst* "
"att skapas som en symbolisk länk.  Om *follow_symlinks* är true och *src* är "
"en symbolisk länk, blir *dst* en kopia av den fil som *src* hänvisar till."

#: ../../library/shutil.rst:178
msgid ""
":func:`~shutil.copy` copies the file data and the file's permission mode "
"(see :func:`os.chmod`).  Other metadata, like the file's creation and "
"modification times, is not preserved. To preserve all file metadata from the "
"original, use :func:`~shutil.copy2` instead."
msgstr ""
":func:`~shutil.copy` kopierar filinformationen och filens behörighetsläge "
"(se :func:`os.chmod`).  Andra metadata, t.ex. filens skapelse- och "
"ändringstid, bevaras inte. Om du vill bevara alla filmetadata från "
"originalet använder du istället :func:`~shutil.copy2`."

#: ../../library/shutil.rst:188
msgid ""
"Added *follow_symlinks* argument. Now returns path to the newly created file."
msgstr ""
"Lagt till argumentet *follow_symlinks*. Returnerar nu sökvägen till den "
"nyskapade filen."

#: ../../library/shutil.rst:199
msgid ""
"Identical to :func:`~shutil.copy` except that :func:`copy2` also attempts to "
"preserve file metadata."
msgstr ""
"Identisk med :func:`~shutil.copy` förutom att :func:`copy2` också försöker "
"bevara metadata för filer."

#: ../../library/shutil.rst:202
msgid ""
"When *follow_symlinks* is false, and *src* is a symbolic link, :func:`copy2` "
"attempts to copy all metadata from the *src* symbolic link to the newly "
"created *dst* symbolic link. However, this functionality is not available on "
"all platforms. On platforms where some or all of this functionality is "
"unavailable, :func:`copy2` will preserve all the metadata it can; :func:"
"`copy2` never raises an exception because it cannot preserve file metadata."
msgstr ""
"När *follow_symlinks* är false och *src* är en symbolisk länk försöker :func:"
"`copy2` att kopiera alla metadata från den symboliska länken *src* till den "
"nyskapade symboliska länken *dst*. Denna funktion är dock inte tillgänglig "
"på alla plattformar. På plattformar där hela eller delar av denna "
"funktionalitet inte är tillgänglig kommer :func:`copy2` att bevara alla "
"metadata den kan; :func:`copy2` ger aldrig upphov till ett undantag för att "
"den inte kan bevara filmetadata."

#: ../../library/shutil.rst:211
msgid ""
":func:`copy2` uses :func:`copystat` to copy the file metadata. Please see :"
"func:`copystat` for more information about platform support for modifying "
"symbolic link metadata."
msgstr ""
":func:`copy2` använder :func:`copystat` för att kopiera filens metadata. Se :"
"func:`copystat` för mer information om plattformsstöd för modifiering av "
"metadata för symboliska länkar."

#: ../../library/shutil.rst:219
msgid ""
"Added *follow_symlinks* argument, try to copy extended file system "
"attributes too (currently Linux only). Now returns path to the newly created "
"file."
msgstr ""
"Lagt till *follow_symlinks*-argument, försök att kopiera utökade "
"filsystemattribut också (för närvarande endast Linux). Returnerar nu "
"sökvägen till den nyskapade filen."

#: ../../library/shutil.rst:231
msgid ""
"This factory function creates a function that can be used as a callable for :"
"func:`copytree`\\'s *ignore* argument, ignoring files and directories that "
"match one of the glob-style *patterns* provided.  See the example below."
msgstr ""
"Denna fabriksfunktion skapar en funktion som kan användas som en anropbar "
"funktion för :func:`copytree`'s *ignore*-argument, och ignorerar filer och "
"kataloger som matchar ett av de *mönster* i glob-stil som anges.  Se "
"exemplet nedan."

#: ../../library/shutil.rst:240
msgid ""
"Recursively copy an entire directory tree rooted at *src* to a directory "
"named *dst* and return the destination directory.  All intermediate "
"directories needed to contain *dst* will also be created by default."
msgstr ""
"Kopiera rekursivt ett helt katalogträd med rot i *src* till en katalog med "
"namnet *dst* och returnera destinationskatalogen.  Alla mellanliggande "
"kataloger som behövs för att innehålla *dst* kommer också att skapas som "
"standard."

#: ../../library/shutil.rst:244
msgid ""
"Permissions and times of directories are copied with :func:`copystat`, "
"individual files are copied using :func:`~shutil.copy2`."
msgstr ""
"Behörigheter och tider för kataloger kopieras med :func:`copystat`, enskilda "
"filer kopieras med :func:`~shutil.copy2`."

#: ../../library/shutil.rst:247
msgid ""
"If *symlinks* is true, symbolic links in the source tree are represented as "
"symbolic links in the new tree and the metadata of the original links will "
"be copied as far as the platform allows; if false or omitted, the contents "
"and metadata of the linked files are copied to the new tree."
msgstr ""
"Om *symlinks* är true representeras symboliska länkar i källträdet som "
"symboliska länkar i det nya trädet och metadata för de ursprungliga länkarna "
"kopieras så långt som plattformen tillåter; om false eller utelämnas "
"kopieras innehållet och metadata för de länkade filerna till det nya trädet."

#: ../../library/shutil.rst:252
msgid ""
"When *symlinks* is false, if the file pointed to by the symlink doesn't "
"exist, an exception will be added in the list of errors raised in an :exc:"
"`Error` exception at the end of the copy process. You can set the optional "
"*ignore_dangling_symlinks* flag to true if you want to silence this "
"exception. Notice that this option has no effect on platforms that don't "
"support :func:`os.symlink`."
msgstr ""
"När *symlinks* är false, om filen som symlänken pekar på inte finns, kommer "
"ett undantag att läggas till i listan över fel som tas upp i ett :exc:"
"`Error`\\-undantag i slutet av kopieringsprocessen. Du kan sätta den valfria "
"flaggan *ignore_dangling_symlinks* till true om du vill tysta detta "
"undantag. Observera att det här alternativet inte har någon effekt på "
"plattformar som inte stöder :func:`os.symlink`."

#: ../../library/shutil.rst:259
msgid ""
"If *ignore* is given, it must be a callable that will receive as its "
"arguments the directory being visited by :func:`copytree`, and a list of its "
"contents, as returned by :func:`os.listdir`.  Since :func:`copytree` is "
"called recursively, the *ignore* callable will be called once for each "
"directory that is copied.  The callable must return a sequence of directory "
"and file names relative to the current directory (i.e. a subset of the items "
"in its second argument); these names will then be ignored in the copy "
"process.  :func:`ignore_patterns` can be used to create such a callable that "
"ignores names based on glob-style patterns."
msgstr ""
"Om *ignore* anges, måste det vara en anropbar funktion som får som argument "
"den katalog som besöks av :func:`copytree`, och en lista över dess innehåll, "
"som returneras av :func:`os.listdir`.  Eftersom :func:`copytree` anropas "
"rekursivt, kommer anropet *ignore* att anropas en gång för varje katalog som "
"kopieras.  Anropet måste returnera en sekvens av katalog- och filnamn i "
"förhållande till den aktuella katalogen (dvs. en delmängd av objekten i dess "
"andra argument); dessa namn kommer sedan att ignoreras i "
"kopieringsprocessen. :func:`ignore_patterns` kan användas för att skapa ett "
"sådant anrop som ignorerar namn baserade på glob-liknande mönster."

#: ../../library/shutil.rst:269
msgid ""
"If exception(s) occur, an :exc:`Error` is raised with a list of reasons."
msgstr ""
"Om ett eller flera undantag inträffar genereras ett :exc:`Error` med en "
"lista över orsaker."

#: ../../library/shutil.rst:271
msgid ""
"If *copy_function* is given, it must be a callable that will be used to copy "
"each file. It will be called with the source path and the destination path "
"as arguments. By default, :func:`~shutil.copy2` is used, but any function "
"that supports the same signature (like :func:`~shutil.copy`) can be used."
msgstr ""
"Om *copy_function* anges måste det vara en anropsbar funktion som används "
"för att kopiera varje fil. Den kommer att anropas med källsökvägen och "
"destinationssökvägen som argument. Som standard används :func:`~shutil."
"copy2`, men alla funktioner som stöder samma signatur (som :func:`~shutil."
"copy`) kan användas."

#: ../../library/shutil.rst:276
msgid ""
"If *dirs_exist_ok* is false (the default) and *dst* already exists, a :exc:"
"`FileExistsError` is raised. If *dirs_exist_ok* is true, the copying "
"operation will continue if it encounters existing directories, and files "
"within the *dst* tree will be overwritten by corresponding files from the "
"*src* tree."
msgstr ""
"Om *dirs_exist_ok* är false (standard) och *dst* redan existerar, uppstår "
"ett :exc:`FileExistsError`. Om *dirs_exist_ok* är true fortsätter "
"kopieringen om den stöter på befintliga kataloger, och filer i *dst*-trädet "
"skrivs över av motsvarande filer från *src*-trädet."

#: ../../library/shutil.rst:282
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.copytree`` with "
"arguments ``src``, ``dst``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``shutil.copytree`` med "
"argumenten ``src``, ``dst``."

#: ../../library/shutil.rst:284
msgid ""
"Added the *copy_function* argument to be able to provide a custom copy "
"function. Added the *ignore_dangling_symlinks* argument to silence dangling "
"symlinks errors when *symlinks* is false."
msgstr ""
"Lagt till argumentet *copy_function* för att kunna tillhandahålla en "
"anpassad kopieringsfunktion. Lagt till argumentet *ignore_dangling_symlinks* "
"för att dämpa fel med dinglande symlänkar när *symlinks* är false."

#: ../../library/shutil.rst:290
msgid "Copy metadata when *symlinks* is false. Now returns *dst*."
msgstr "Kopiera metadata när *symlinks* är false. Returnerar nu *dst*."

#: ../../library/shutil.rst:299
msgid "Added the *dirs_exist_ok* parameter."
msgstr "Parametern *dirs_exist_ok* har lagts till."

#: ../../library/shutil.rst:306
msgid ""
"Delete an entire directory tree; *path* must point to a directory (but not a "
"symbolic link to a directory).  If *ignore_errors* is true, errors resulting "
"from failed removals will be ignored; if false or omitted, such errors are "
"handled by calling a handler specified by *onexc* or *onerror* or, if both "
"are omitted, exceptions are propagated to the caller."
msgstr ""
"Ta bort ett helt katalogträd; *path* måste peka på en katalog (men inte på "
"en symbolisk länk till en katalog).  Om *ignore_errors* är true ignoreras "
"fel som uppstår vid misslyckade borttagningar; om false eller utelämnas "
"hanteras sådana fel genom att anropa en hanterare som specificeras av "
"*onexc* eller *onerror* eller, om båda utelämnas, sprids undantag till den "
"som anropar."

#: ../../library/shutil.rst:312
msgid ""
"This function can support :ref:`paths relative to directory descriptors "
"<dir_fd>`."
msgstr ""
"Den här funktionen kan stödja :ref:`sökvägar som är relativa till "
"katalogbeskrivare <dir_fd>`."

#: ../../library/shutil.rst:317
msgid ""
"On platforms that support the necessary fd-based functions a symlink attack "
"resistant version of :func:`rmtree` is used by default.  On other platforms, "
"the :func:`rmtree` implementation is susceptible to a symlink attack: given "
"proper timing and circumstances, attackers can manipulate symlinks on the "
"filesystem to delete files they wouldn't be able to access otherwise.  "
"Applications can use the :data:`rmtree.avoids_symlink_attacks` function "
"attribute to determine which case applies."
msgstr ""
"På plattformar som stöder de nödvändiga fd-baserade funktionerna används som "
"standard en version av :func:`rmtree` som är motståndskraftig mot "
"symlänkattacker.  På andra plattformar är implementeringen av :func:`rmtree` "
"känslig för en symlänk-attack: med rätt timing och omständigheter kan "
"angripare manipulera symlinks i filsystemet för att radera filer som de "
"annars inte skulle ha tillgång till.  Program kan använda "
"funktionsattributet :data:`rmtree.avoids_symlink_attacks` för att avgöra "
"vilket fall som gäller."

#: ../../library/shutil.rst:325
msgid ""
"If *onexc* is provided, it must be a callable that accepts three parameters: "
"*function*, *path*, and *excinfo*."
msgstr ""
"Om *onexc* anges måste det vara en callable som accepterar tre parametrar: "
"*funktion*, *sökväg* och *excinfo*."

#: ../../library/shutil.rst:328
msgid ""
"The first parameter, *function*, is the function which raised the exception; "
"it depends on the platform and implementation.  The second parameter, "
"*path*, will be the path name passed to *function*.  The third parameter, "
"*excinfo*, is the exception that was raised. Exceptions raised by *onexc* "
"will not be caught."
msgstr ""
"Den första parametern, *function*, är den funktion som orsakade undantaget; "
"den beror på plattform och implementering.  Den andra parametern, *path*, är "
"det sökvägsnamn som skickas till *function*.  Den tredje parametern, "
"*excinfo*, är det undantag som uppstod. Undantag som orsakas av *onexc* "
"kommer inte att fångas upp."

#: ../../library/shutil.rst:334
msgid ""
"The deprecated *onerror* is similar to *onexc*, except that the third "
"parameter it receives is the tuple returned from :func:`sys.exc_info`."
msgstr ""
"Den föråldrade *onerror* liknar *onexc*, förutom att den tredje parametern "
"den tar emot är den tupel som returneras från :func:`sys.exc_info`."

#: ../../library/shutil.rst:338
msgid ""
":ref:`shutil-rmtree-example` for an example of handling the removal of a "
"directory tree that contains read-only files."
msgstr ""
":ref:`shutil-rmtree-example` för ett exempel på hur man hanterar "
"borttagningen av ett katalogträd som innehåller skrivskyddade filer."

#: ../../library/shutil.rst:341
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.rmtree`` with arguments "
"``path``, ``dir_fd``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``shutil.rmtree`` med argumenten "
"``path``, ``dir_fd``."

#: ../../library/shutil.rst:343
msgid ""
"Added a symlink attack resistant version that is used automatically if "
"platform supports fd-based functions."
msgstr ""
"Lagt till en version som är motståndskraftig mot symlink-attacker och som "
"används automatiskt om plattformen stöder fd-baserade funktioner."

#: ../../library/shutil.rst:347
msgid ""
"On Windows, will no longer delete the contents of a directory junction "
"before removing the junction."
msgstr ""
"I Windows tas inte längre innehållet i en katalogövergång bort innan "
"övergången tas bort."

#: ../../library/shutil.rst:351
msgid "Added the *dir_fd* parameter."
msgstr "Parametern *dir_fd* har lagts till."

#: ../../library/shutil.rst:354
msgid "Added the *onexc* parameter, deprecated *onerror*."
msgstr "Parametern *onexc* tillagd, *onerror* borttagen."

#: ../../library/shutil.rst:357
msgid ""
":func:`!rmtree` now ignores :exc:`FileNotFoundError` exceptions for all but "
"the top-level path. Exceptions other than :exc:`OSError` and subclasses of :"
"exc:`!OSError` are now always propagated to the caller."
msgstr ""
":func:`!rmtree` ignorerar nu :exc:`FileNotFoundError`\\-undantag för alla "
"utom sökvägen på högsta nivån. Andra undantag än :exc:`OSError` och "
"underklasser till :exc:`!OSError` sprids nu alltid till den som anropar."

#: ../../library/shutil.rst:365
msgid ""
"Indicates whether the current platform and implementation provides a symlink "
"attack resistant version of :func:`rmtree`.  Currently this is only true for "
"platforms supporting fd-based directory access functions."
msgstr ""
"Anger om den aktuella plattformen och implementationen tillhandahåller en "
"version av :func:`rmtree` som är motståndskraftig mot symlink-attacker.  För "
"närvarande gäller detta endast för plattformar som stöder fd-baserade "
"funktioner för katalogåtkomst."

#: ../../library/shutil.rst:374
msgid ""
"Recursively move a file or directory (*src*) to another location and return "
"the destination."
msgstr ""
"Flytta rekursivt en fil eller katalog (*src*) till en annan plats och "
"returnera destinationen."

#: ../../library/shutil.rst:377
msgid ""
"If *dst* is an existing directory or a symlink to a directory, then *src* is "
"moved inside that directory. The destination path in that directory must not "
"already exist."
msgstr ""
"Om *dst* är en befintlig katalog eller en symlänk till en katalog, flyttas "
"*src* till den katalogen. Målsökvägen i den katalogen får inte redan "
"existera."

#: ../../library/shutil.rst:381
msgid ""
"If *dst* already exists but is not a directory, it may be overwritten "
"depending on :func:`os.rename` semantics."
msgstr ""
"Om *dst* redan finns men inte är en katalog kan den komma att skrivas över "
"beroende på :func:`os.rename` semantik."

#: ../../library/shutil.rst:384
msgid ""
"If the destination is on the current filesystem, then :func:`os.rename` is "
"used. Otherwise, *src* is copied to the destination using *copy_function* "
"and then removed.  In case of symlinks, a new symlink pointing to the target "
"of *src* will be created as the destination and *src* will be removed."
msgstr ""
"Om destinationen finns i det aktuella filsystemet används :func:`os.rename`. "
"Annars kopieras *src* till destinationen med hjälp av *copy_function* och "
"tas sedan bort.  Om det gäller symlinks skapas en ny symlink som pekar på "
"målet för *src* som destination och *src* tas bort."

#: ../../library/shutil.rst:389
msgid ""
"If *copy_function* is given, it must be a callable that takes two arguments, "
"*src* and the destination, and will be used to copy *src* to the destination "
"if :func:`os.rename` cannot be used.  If the source is a directory, :func:"
"`copytree` is called, passing it the *copy_function*. The default "
"*copy_function* is :func:`copy2`.  Using :func:`~shutil.copy` as the "
"*copy_function* allows the move to succeed when it is not possible to also "
"copy the metadata, at the expense of not copying any of the metadata."
msgstr ""
"Om *copy_function* anges måste det vara en anropsbar funktion som tar två "
"argument, *src* och destinationen, och som kommer att användas för att "
"kopiera *src* till destinationen om :func:`os.rename` inte kan användas.  Om "
"källan är en katalog anropas :func:`copytree` som får *copy_function*. "
"Standard *copy_function* är :func:`copy2`.  Genom att använda :func:`~shutil."
"copy` som *copy_function* kan flytten lyckas när det inte är möjligt att "
"även kopiera metadata, på bekostnad av att inga metadata kopieras."

#: ../../library/shutil.rst:397
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.move`` with arguments "
"``src``, ``dst``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``shutil.move`` med argumenten "
"``src``, ``dst``."

#: ../../library/shutil.rst:399
msgid ""
"Added explicit symlink handling for foreign filesystems, thus adapting it to "
"the behavior of GNU's :program:`mv`. Now returns *dst*."
msgstr ""
"Lade till explicit symlänkhantering för utländska filsystem och anpassade "
"den därmed till beteendet i GNU:s :program:`mv`. Returnerar nu *dst*."

#: ../../library/shutil.rst:404
msgid "Added the *copy_function* keyword argument."
msgstr "Lagt till nyckelordsargumentet *copy_function*."

#: ../../library/shutil.rst:412
msgid "Accepts a :term:`path-like object` for both *src* and *dst*."
msgstr "Accepterar en :term:`path-like object` för både *src* och *dst*."

#: ../../library/shutil.rst:417
msgid ""
"Return disk usage statistics about the given path as a :term:`named tuple` "
"with the attributes *total*, *used* and *free*, which are the amount of "
"total, used and free space, in bytes. *path* may be a file or a directory."
msgstr ""
"Returnerar diskanvändningsstatistik för den angivna sökvägen som en :term:"
"`named tuple` med attributen *total*, *used* och *free*, som är mängden "
"totalt, använt och ledigt utrymme i byte. *path* kan vara en fil eller en "
"katalog."

#: ../../library/shutil.rst:424
msgid ""
"On Unix filesystems, *path* must point to a path within a **mounted** "
"filesystem partition. On those platforms, CPython doesn't attempt to "
"retrieve disk usage information from non-mounted filesystems."
msgstr ""
"På Unix-filsystem måste *path* peka på en sökväg inom en **monterad** "
"filsystemspartition. På dessa plattformar försöker CPython inte att hämta "
"information om diskanvändning från icke monterade filsystem."

#: ../../library/shutil.rst:430
msgid "On Windows, *path* can now be a file or directory."
msgstr "I Windows kan *path* nu vara en fil eller katalog."

#: ../../library/shutil.rst:433 ../../library/shutil.rst:447
msgid "Availability"
msgstr "Tillgänglighet"

#: ../../library/shutil.rst:438
msgid "Change owner *user* and/or *group* of the given *path*."
msgstr "Ändra ägare *user* och/eller *group* för den angivna *path*."

#: ../../library/shutil.rst:440
msgid ""
"*user* can be a system user name or a uid; the same applies to *group*. At "
"least one argument is required."
msgstr ""
"*user* kan vara ett systemanvändarnamn eller ett uid; samma sak gäller för "
"*group*. Minst ett argument krävs."

#: ../../library/shutil.rst:443
msgid "See also :func:`os.chown`, the underlying function."
msgstr "Se även :func:`os.chown`, den underliggande funktionen."

#: ../../library/shutil.rst:445
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.chown`` with arguments "
"``path``, ``user``, ``group``."
msgstr ""
"Utlöser en :ref:`auditing-händelse <auditing>` ``shutil.chown`` med "
"argumenten ``path``, ``user``, ``group``."

#: ../../library/shutil.rst:451
msgid "Added *dir_fd* and *follow_symlinks* parameters."
msgstr "Parametrarna *dir_fd* och *follow_symlinks* har lagts till."

#: ../../library/shutil.rst:457
msgid ""
"Return the path to an executable which would be run if the given *cmd* was "
"called.  If no *cmd* would be called, return ``None``."
msgstr ""
"Returnerar sökvägen till en körbar fil som skulle köras om den angivna *cmd* "
"anropades.  Om ingen *cmd* skulle anropas returneras ``None``."

#: ../../library/shutil.rst:460
msgid ""
"*mode* is a permission mask passed to :func:`os.access`, by default "
"determining if the file exists and is executable."
msgstr ""
"*mode* är en behörighetsmask som skickas till :func:`os.access`, som "
"standard avgör den om filen finns och är körbar."

#: ../../library/shutil.rst:463
msgid ""
"*path* is a \"``PATH`` string\" specifying the directories to look in, "
"delimited by :data:`os.pathsep`. When no *path* is specified, the :envvar:"
"`PATH` environment variable is read from :data:`os.environ`, falling back "
"to :data:`os.defpath` if it is not set."
msgstr ""
"*path* är en \"``PATH``\\-sträng\" som anger de kataloger som ska sökas i, "
"avgränsad av :data:`os.pathsep`. Om ingen *path* anges, läses "
"miljövariabeln :envvar:`PATH` från :data:`os.environ`, och faller tillbaka "
"till :data:`os.defpath` om den inte är inställd."

#: ../../library/shutil.rst:468
msgid ""
"If *cmd* contains a directory component, :func:`!which` only checks the "
"specified path directly and does not search the directories listed in *path* "
"or in the system's :envvar:`PATH` environment variable."
msgstr ""
"Om *cmd* innehåller en katalogkomponent kontrollerar :func:`!which` endast "
"den angivna sökvägen direkt och söker inte i de kataloger som anges i *path* "
"eller i systemets miljövariabel :envvar:`PATH`."

#: ../../library/shutil.rst:472
msgid ""
"On Windows, the current directory is prepended to the *path* if *mode* does "
"not include ``os.X_OK``. When the *mode* does include ``os.X_OK``, the "
"Windows API ``NeedCurrentDirectoryForExePathW`` will be consulted to "
"determine if the current directory should be prepended to *path*. To avoid "
"consulting the current working directory for executables: set the "
"environment variable ``NoDefaultCurrentDirectoryInExePath``."
msgstr ""
"I Windows prependlas den aktuella katalogen till *path* om *mode* inte "
"innehåller ``os.X_OK``. När *mode* innehåller ``os.X_OK``, kommer Windows "
"API ``NeedCurrentDirectoryForExePathW`` att konsulteras för att avgöra om "
"den aktuella katalogen ska läggas till *path*. För att undvika att den "
"aktuella arbetskatalogen konsulteras för körbara filer: ställ in "
"miljövariabeln ``NoDefaultCurrentDirectoryInExePath``."

#: ../../library/shutil.rst:479
msgid ""
"Also on Windows, the :envvar:`PATHEXT` environment variable is used to "
"resolve commands that may not already include an extension. For example, if "
"you call ``shutil.which(\"python\")``, :func:`which` will search ``PATHEXT`` "
"to know that it should look for ``python.exe`` within the *path* "
"directories. For example, on Windows::"
msgstr ""
"I Windows används även miljövariabeln :envvar:`PATHEXT` för att lösa "
"kommandon som kanske inte redan innehåller ett tillägg. Om du till exempel "
"anropar ``shutil.which(\"python\")``, kommer :func:`which` att söka i "
"``PATHEXT`` för att veta att den ska leta efter ``python.exe`` i katalogerna "
"*path*. Till exempel på Windows::"

#: ../../library/shutil.rst:485
msgid ""
">>> shutil.which(\"python\")\n"
"'C:\\\\Python33\\\\python.EXE'"
msgstr ""
">>> shutil.which(\"python\")\n"
"'C:\\\\Python33\\\\python.EXE'"

#: ../../library/shutil.rst:488
msgid ""
"This is also applied when *cmd* is a path that contains a directory "
"component::"
msgstr ""
"Detta gäller även när *cmd* är en sökväg som innehåller en katalogkomponent::"

#: ../../library/shutil.rst:491
msgid ""
">>> shutil.which(\"C:\\\\Python33\\\\python\")\n"
"'C:\\\\Python33\\\\python.EXE'"
msgstr ""
">>> shutil.which(\"C:\\\\Python33\\\\python\")\n"
"'C:\\\\Python33\\\\python.EXE'"

#: ../../library/shutil.rst:496
msgid ""
"The :class:`bytes` type is now accepted.  If *cmd* type is :class:`bytes`, "
"the result type is also :class:`bytes`."
msgstr ""
"Typen :class:`bytes` accepteras nu.  Om *cmd*-typen är :class:`bytes`, är "
"resultattypen också :class:`bytes`."

#: ../../library/shutil.rst:500
msgid ""
"On Windows, the current directory is no longer prepended to the search path "
"if *mode* includes ``os.X_OK`` and WinAPI "
"``NeedCurrentDirectoryForExePathW(cmd)`` is false, else the current "
"directory is prepended even if it is already in the search path; ``PATHEXT`` "
"is used now even when *cmd* includes a directory component or ends with an "
"extension that is in ``PATHEXT``; and filenames that have no extension can "
"now be found."
msgstr ""
"I Windows läggs inte längre den aktuella katalogen till i sökvägen om *mode* "
"innehåller ``os.X_OK`` och WinAPI ``NeedCurrentDirectoryForExePathW(cmd)`` "
"är false, annars läggs den aktuella katalogen till även om den redan finns i "
"sökvägen; ``PATHEXT`` används nu även när *cmd* innehåller en "
"katalogkomponent eller slutar med ett tillägg som finns i ``PATHEXT``; och "
"filnamn som inte har något tillägg kan nu hittas."

#: ../../library/shutil.rst:511
msgid ""
"This exception collects exceptions that are raised during a multi-file "
"operation. For :func:`copytree`, the exception argument is a list of 3-"
"tuples (*srcname*, *dstname*, *exception*)."
msgstr ""
"Detta undantag samlar in undantag som uppstår under en operation med flera "
"filer. För :func:`copytree` är undantagsargumentet en lista med 3-tuples "
"(*srcname*, *dstname*, *exception*)."

#: ../../library/shutil.rst:518
msgid "Platform-dependent efficient copy operations"
msgstr "Plattformsberoende effektiva kopieringsoperationer"

#: ../../library/shutil.rst:520
msgid ""
"Starting from Python 3.8, all functions involving a file copy (:func:"
"`copyfile`, :func:`~shutil.copy`, :func:`copy2`, :func:`copytree`, and :func:"
"`move`) may use platform-specific \"fast-copy\" syscalls in order to copy "
"the file more efficiently (see :issue:`33671`). \"fast-copy\" means that the "
"copying operation occurs within the kernel, avoiding the use of userspace "
"buffers in Python as in \"``outfd.write(infd.read())``\"."
msgstr ""
"Från och med Python 3.8 kan alla funktioner som involverar en filkopiering (:"
"func:`copyfile`, :func:`~shutil.copy`, :func:`copy2`, :func:`copytree`, och :"
"func:`move`) använda plattformsspecifika \"fast-copy\" syscalls för att "
"kopiera filen mer effektivt (se :issue:`33671`). \"Fast-copy\" innebär att "
"kopieringsoperationen sker i kärnan, vilket undviker användning av userspace-"
"buffertar i Python som i \"``outfd.write(infd.read())``\"."

#: ../../library/shutil.rst:528
msgid "On macOS `fcopyfile`_ is used to copy the file content (not metadata)."
msgstr ""
"På macOS används `fcopyfile`_ för att kopiera filinnehållet (inte metadata)."

#: ../../library/shutil.rst:530
msgid "On Linux :func:`os.sendfile` is used."
msgstr ""

#: ../../library/shutil.rst:532
msgid ""
"On Windows :func:`shutil.copyfile` uses a bigger default buffer size (1 MiB "
"instead of 64 KiB) and a :func:`memoryview`-based variant of :func:`shutil."
"copyfileobj` is used."
msgstr ""
"I Windows använder :func:`shutil.copyfile` en större standardbuffertstorlek "
"(1 MiB istället för 64 KiB) och en :func:`memoryview`\\-baserad variant av :"
"func:`shutil.copyfileobj` används."

#: ../../library/shutil.rst:536
msgid ""
"If the fast-copy operation fails and no data was written in the destination "
"file then shutil will silently fallback on using less efficient :func:"
"`copyfileobj` function internally."
msgstr ""
"Om snabbkopieringen misslyckas och inga data skrevs i målfilen kommer shutil "
"att tyst fallbacka till att använda den mindre effektiva :func:"
"`copyfileobj`\\-funktionen internt."

#: ../../library/shutil.rst:545
msgid "copytree example"
msgstr "exempel på copytree"

#: ../../library/shutil.rst:547
msgid "An example that uses the :func:`ignore_patterns` helper::"
msgstr "Ett exempel som använder hjälpen :func:`ignore_patterns`::"

#: ../../library/shutil.rst:549
msgid ""
"from shutil import copytree, ignore_patterns\n"
"\n"
"copytree(source, destination, ignore=ignore_patterns('*.pyc', 'tmp*'))"
msgstr ""
"from shutil import copytree, ignore_patterns\n"
"\n"
"copytree(source, destination, ignore=ignore_patterns('*.pyc', 'tmp*'))"

#: ../../library/shutil.rst:553
msgid ""
"This will copy everything except ``.pyc`` files and files or directories "
"whose name starts with ``tmp``."
msgstr ""
"Detta kopierar allt utom ``.pyc``\\-filer och filer eller kataloger vars "
"namn börjar med ``tmp``."

#: ../../library/shutil.rst:556
msgid "Another example that uses the *ignore* argument to add a logging call::"
msgstr ""
"Ett annat exempel som använder *ignore*-argumentet för att lägga till ett "
"loggningsanrop::"

#: ../../library/shutil.rst:558
msgid ""
"from shutil import copytree\n"
"import logging\n"
"\n"
"def _logpath(path, names):\n"
"    logging.info('Working in %s', path)\n"
"    return []   # nothing will be ignored\n"
"\n"
"copytree(source, destination, ignore=_logpath)"
msgstr ""
"from shutil import copytree\n"
"import logging\n"
"\n"
"def _logpath(path, names):\n"
"    logging.info('Working in %s', path)\n"
"    return []   # nothing will be ignored\n"
"\n"
"copytree(source, destination, ignore=_logpath)"

#: ../../library/shutil.rst:571
msgid "rmtree example"
msgstr "exempel på rmtree"

#: ../../library/shutil.rst:573
msgid ""
"This example shows how to remove a directory tree on Windows where some of "
"the files have their read-only bit set. It uses the onexc callback to clear "
"the readonly bit and reattempt the remove. Any subsequent failure will "
"propagate. ::"
msgstr ""
"Det här exemplet visar hur man tar bort ett katalogträd i Windows där vissa "
"av filerna har skrivskyddad bit inställd. Det använder onexc callback för "
"att rensa den skrivskyddade biten och göra ett nytt försök att ta bort. "
"Eventuella efterföljande fel kommer att sprida sig. ::"

#: ../../library/shutil.rst:578
msgid ""
"import os, stat\n"
"import shutil\n"
"\n"
"def remove_readonly(func, path, _):\n"
"    \"Clear the readonly bit and reattempt the removal\"\n"
"    os.chmod(path, stat.S_IWRITE)\n"
"    func(path)\n"
"\n"
"shutil.rmtree(directory, onexc=remove_readonly)"
msgstr ""
"import os, stat\n"
"import shutil\n"
"\n"
"def remove_readonly(func, path, _):\n"
"    \"Clear the readonly bit and reattempt the removal\"\n"
"    os.chmod(path, stat.S_IWRITE)\n"
"    func(path)\n"
"\n"
"shutil.rmtree(directory, onexc=remove_readonly)"

#: ../../library/shutil.rst:591
msgid "Archiving operations"
msgstr "Arkiveringsverksamhet"

#: ../../library/shutil.rst:595
msgid "Added support for the *xztar* format."
msgstr "Stöd för formatet *xztar* har lagts till."

#: ../../library/shutil.rst:599
msgid ""
"High-level utilities to create and read compressed and archived files are "
"also provided.  They rely on the :mod:`zipfile` and :mod:`tarfile` modules."
msgstr ""
"Verktyg på hög nivå för att skapa och läsa komprimerade och arkiverade filer "
"tillhandahålls också.  De förlitar sig på modulerna :mod:`zipfile` och :mod:"
"`tarfile`."

#: ../../library/shutil.rst:604
msgid "Create an archive file (such as zip or tar) and return its name."
msgstr "Skapa en arkivfil (t.ex. zip eller tar) och ange dess namn."

#: ../../library/shutil.rst:606
msgid ""
"*base_name* is the name of the file to create, including the path, minus any "
"format-specific extension."
msgstr ""
"*base_name* är namnet på den fil som ska skapas, inklusive sökvägen, minus "
"eventuella formatspecifika tillägg."

#: ../../library/shutil.rst:609
msgid ""
"*format* is the archive format: one of \"zip\" (if the :mod:`zlib` module is "
"available), \"tar\", \"gztar\" (if the :mod:`zlib` module is available), "
"\"bztar\" (if the :mod:`bz2` module is available), or \"xztar\" (if the :mod:"
"`lzma` module is available)."
msgstr ""

#: ../../library/shutil.rst:614
msgid ""
"*root_dir* is a directory that will be the root directory of the archive, "
"all paths in the archive will be relative to it; for example, we typically "
"chdir into *root_dir* before creating the archive."
msgstr ""
"*root_dir* är en katalog som kommer att vara arkivets rotkatalog, alla "
"sökvägar i arkivet kommer att vara relativa till den; vi brukar t.ex. chdir:"
"a till *root_dir* innan vi skapar arkivet."

#: ../../library/shutil.rst:618
msgid ""
"*base_dir* is the directory where we start archiving from; i.e. *base_dir* "
"will be the common prefix of all files and directories in the archive.  "
"*base_dir* must be given relative to *root_dir*.  See :ref:`shutil-archiving-"
"example-with-basedir` for how to use *base_dir* and *root_dir* together."
msgstr ""
"*base_dir* är den katalog där vi börjar arkivera från, dvs. *base_dir* "
"kommer att vara det gemensamma prefixet för alla filer och kataloger i "
"arkivet.  *base_dir* måste anges i förhållande till *root_dir*.  Se :ref:"
"`shutil-archiving-example-with-basedir` för hur man använder *base_dir* och "
"*root_dir* tillsammans."

#: ../../library/shutil.rst:624
msgid "*root_dir* and *base_dir* both default to the current directory."
msgstr ""
"*root_dir* och *base_dir* är båda förvalda till den aktuella katalogen."

#: ../../library/shutil.rst:626
msgid ""
"If *dry_run* is true, no archive is created, but the operations that would "
"be executed are logged to *logger*."
msgstr ""
"Om *dry_run* är true skapas inget arkiv, men de operationer som skulle ha "
"utförts loggas i *logger*."

#: ../../library/shutil.rst:629
msgid ""
"*owner* and *group* are used when creating a tar archive. By default, uses "
"the current owner and group."
msgstr ""
"*owner* och *group* används när ett tar-arkiv skapas. Som standard används "
"den aktuella ägaren och gruppen."

#: ../../library/shutil.rst:632
msgid ""
"*logger* must be an object compatible with :pep:`282`, usually an instance "
"of :class:`logging.Logger`."
msgstr ""
"*logger* måste vara ett objekt som är kompatibelt med :pep:`282`, vanligtvis "
"en instans av :class:`logging.Logger`."

#: ../../library/shutil.rst:635
msgid "The *verbose* argument is unused and deprecated."
msgstr "Argumentet *verbose* är oanvänt och föråldrat."

#: ../../library/shutil.rst:637
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.make_archive`` with "
"arguments ``base_name``, ``format``, ``root_dir``, ``base_dir``."
msgstr ""
"Utlöser en :ref:`auditing-händelse <auditing>` ``shutil.make_archive`` med "
"argumenten ``base_name``, ``format``, ``root_dir``, ``base_dir``."

#: ../../library/shutil.rst:641
msgid ""
"This function is not thread-safe when custom archivers registered with :func:"
"`register_archive_format` do not support the *root_dir* argument.  In this "
"case it temporarily changes the current working directory of the process to "
"*root_dir* to perform archiving."
msgstr ""
"Den här funktionen är inte trådsäker när anpassade arkiverare som "
"registrerats med :func:`register_archive_format` inte stöder argumentet "
"*root_dir*.  I så fall ändras processens aktuella arbetskatalog tillfälligt "
"till *root_dir* för att utföra arkivering."

#: ../../library/shutil.rst:647
msgid ""
"The modern pax (POSIX.1-2001) format is now used instead of the legacy GNU "
"format for archives created with ``format=\"tar\"``."
msgstr ""
"Det moderna pax-formatet (POSIX.1-2001) används nu i stället för det äldre "
"GNU-formatet för arkiv som skapats med ``format=\"tar\"``."

#: ../../library/shutil.rst:651
msgid ""
"This function is now made thread-safe during creation of standard ``.zip`` "
"and tar archives."
msgstr ""
"Denna funktion är nu trådsäker under skapandet av standardarkiv av typen ``."
"zip`` och tar."

#: ../../library/shutil.rst:657
msgid ""
"Return a list of supported formats for archiving. Each element of the "
"returned sequence is a tuple ``(name, description)``."
msgstr ""
"Returnerar en lista över format som stöds för arkivering. Varje element i "
"den returnerade sekvensen är en tupel ``(namn, beskrivning)``."

#: ../../library/shutil.rst:660 ../../library/shutil.rst:771
msgid "By default :mod:`shutil` provides these formats:"
msgstr "Som standard tillhandahåller :mod:`shutil` dessa format:"

#: ../../library/shutil.rst:662
msgid "*zip*: ZIP file (if the :mod:`zlib` module is available)."
msgstr "*zip*: ZIP-fil (om modulen :mod:`zlib` är tillgänglig)."

#: ../../library/shutil.rst:663
msgid ""
"*tar*: Uncompressed tar file. Uses POSIX.1-2001 pax format for new archives."
msgstr ""
"*tar*: Okomprimerad tar-fil. Använder POSIX.1-2001 pax-format för nya arkiv."

#: ../../library/shutil.rst:664 ../../library/shutil.rst:776
msgid "*gztar*: gzip'ed tar-file (if the :mod:`zlib` module is available)."
msgstr "*gztar*: gzip'ed tar-fil (om modulen :mod:`zlib` är tillgänglig)."

#: ../../library/shutil.rst:665 ../../library/shutil.rst:777
msgid "*bztar*: bzip2'ed tar-file (if the :mod:`bz2` module is available)."
msgstr ""
"*bztar*: bzip2-behandlad tar-fil (om modulen :mod:`bz2` är tillgänglig)."

#: ../../library/shutil.rst:666 ../../library/shutil.rst:778
msgid "*xztar*: xz'ed tar-file (if the :mod:`lzma` module is available)."
msgstr "*xztar*: xz'ed tar-fil (om modulen :mod:`lzma` är tillgänglig)."

#: ../../library/shutil.rst:668
msgid ""
"You can register new formats or provide your own archiver for any existing "
"formats, by using :func:`register_archive_format`."
msgstr ""
"Du kan registrera nya format eller tillhandahålla din egen arkiverare för "
"befintliga format genom att använda :func:`register_archive_format`."

#: ../../library/shutil.rst:674
msgid "Register an archiver for the format *name*."
msgstr "Registrera en arkiverare för formatet *namn*."

#: ../../library/shutil.rst:676
msgid ""
"*function* is the callable that will be used to unpack archives. The "
"callable will receive the *base_name* of the file to create, followed by the "
"*base_dir* (which defaults to :data:`os.curdir`) to start archiving from. "
"Further arguments are passed as keyword arguments: *owner*, *group*, "
"*dry_run* and *logger* (as passed in :func:`make_archive`)."
msgstr ""
"*function* är den anropbara funktion som kommer att användas för att packa "
"upp arkiv. Anropsfunktionen tar emot *base_name* för filen som ska skapas, "
"följt av *base_dir* (som standard är :data:`os.curdir`) för att starta "
"arkiveringen från. Ytterligare argument skickas som nyckelordsargument: "
"*owner*, *group*, *dry_run* och *logger* (som skickas i :func:"
"`make_archive`)."

#: ../../library/shutil.rst:682
msgid ""
"If *function* has the custom attribute ``function.supports_root_dir`` set to "
"``True``, the *root_dir* argument is passed as a keyword argument. Otherwise "
"the current working directory of the process is temporarily changed to "
"*root_dir* before calling *function*. In this case :func:`make_archive` is "
"not thread-safe."
msgstr ""
"Om *function* har det anpassade attributet ``function.supports_root_dir`` "
"inställt på ``True``, skickas *root_dir*-argumentet som ett "
"nyckelordsargument. Annars ändras processens aktuella arbetskatalog "
"tillfälligt till *root_dir* innan *function* anropas. I det här fallet är :"
"func:`make_archive` inte trådsäker."

#: ../../library/shutil.rst:688
msgid ""
"If given, *extra_args* is a sequence of ``(name, value)`` pairs that will be "
"used as extra keywords arguments when the archiver callable is used."
msgstr ""
"Om *extra_args* anges är det en sekvens av par av ``(namn, värde)`` som "
"kommer att användas som extra nyckelordsargument när arkiverarens "
"anropsbarhet används."

#: ../../library/shutil.rst:691
msgid ""
"*description* is used by :func:`get_archive_formats` which returns the list "
"of archivers.  Defaults to an empty string."
msgstr ""
"*description* används av :func:`get_archive_formats` som returnerar en lista "
"över arkivbildare.  Standardvärdet är en tom sträng."

#: ../../library/shutil.rst:694
msgid "Added support for functions supporting the *root_dir* argument."
msgstr "Lagt till stöd för funktioner som stöder argumentet *root_dir*."

#: ../../library/shutil.rst:700
msgid "Remove the archive format *name* from the list of supported formats."
msgstr "Ta bort arkivformatet *name* från listan över format som stöds."

#: ../../library/shutil.rst:705
msgid "Unpack an archive. *filename* is the full path of the archive."
msgstr ""
"Packa upp ett arkiv. *filnamn* är den fullständiga sökvägen till arkivet."

#: ../../library/shutil.rst:707
msgid ""
"*extract_dir* is the name of the target directory where the archive is "
"unpacked. If not provided, the current working directory is used."
msgstr ""
"*extract_dir* är namnet på den målkatalog där arkivet ska packas upp. Om det "
"inte anges används den aktuella arbetskatalogen."

#: ../../library/shutil.rst:710
msgid ""
"*format* is the archive format: one of \"zip\", \"tar\", \"gztar\", "
"\"bztar\", or \"xztar\".  Or any other format registered with :func:"
"`register_unpack_format`.  If not provided, :func:`unpack_archive` will use "
"the archive file name extension and see if an unpacker was registered for "
"that extension.  In case none is found, a :exc:`ValueError` is raised."
msgstr ""

#: ../../library/shutil.rst:717
msgid ""
"The keyword-only *filter* argument is passed to the underlying unpacking "
"function. For zip files, *filter* is not accepted. For tar files, it is "
"recommended to set it to ``'data'``, unless using features specific to tar "
"and UNIX-like filesystems. (See :ref:`tarfile-extraction-filter` for "
"details.) The ``'data'`` filter will become the default for tar files in "
"Python 3.14."
msgstr ""

#: ../../library/shutil.rst:725
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.unpack_archive`` with "
"arguments ``filename``, ``extract_dir``, ``format``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``shutil.unpack_archive`` med "
"argumenten ``filename``, ``extract_dir``, ``format``."

#: ../../library/shutil.rst:729
msgid ""
"Never extract archives from untrusted sources without prior inspection. It "
"is possible that files are created outside of the path specified in the "
"*extract_dir* argument, e.g. members that have absolute filenames starting "
"with \"/\" or filenames with two dots \"..\"."
msgstr ""
"Extrahera aldrig arkiv från otillförlitliga källor utan föregående "
"inspektion. Det är möjligt att filer skapas utanför den sökväg som anges i "
"argumentet *extract_dir*, t.ex. medlemmar som har absoluta filnamn som "
"börjar med \"/\" eller filnamn med två punkter \"...\"."

#: ../../library/shutil.rst:734
msgid "Accepts a :term:`path-like object` for *filename* and *extract_dir*."
msgstr ""
"Accepterar en :term:`path-like object` för *filename* och *extract_dir*."

#: ../../library/shutil.rst:737
msgid "Added the *filter* argument."
msgstr "Lagt till argumentet *filter*."

#: ../../library/shutil.rst:742
msgid ""
"Registers an unpack format. *name* is the name of the format and "
"*extensions* is a list of extensions corresponding to the format, like ``."
"zip`` for Zip files."
msgstr ""
"Registrerar ett uppackningsformat. *name* är namnet på formatet och "
"*extensions* är en lista med tillägg som motsvarar formatet, t.ex. ``.zip`` "
"för Zip-filer."

#: ../../library/shutil.rst:746
msgid ""
"*function* is the callable that will be used to unpack archives. The "
"callable will receive:"
msgstr ""
"*function* är den anropbara funktion som kommer att användas för att packa "
"upp arkiv. Den anropsbara funktionen kommer att ta emot:"

#: ../../library/shutil.rst:749
msgid "the path of the archive, as a positional argument;"
msgstr "sökvägen till arkivet, som ett positionellt argument;"

#: ../../library/shutil.rst:750
msgid ""
"the directory the archive must be extracted to, as a positional argument;"
msgstr ""
"den katalog som arkivet måste extraheras till, som ett positionellt argument;"

#: ../../library/shutil.rst:751
msgid ""
"possibly a *filter* keyword argument, if it was given to :func:"
"`unpack_archive`;"
msgstr ""
"eventuellt ett *filter* nyckelordsargument, om det gavs till :func:"
"`unpack_archive`;"

#: ../../library/shutil.rst:753
msgid ""
"additional keyword arguments, specified by *extra_args* as a sequence of "
"``(name, value)`` tuples."
msgstr ""
"ytterligare nyckelordsargument, specificerade av *extra_args* som en sekvens "
"av ``(namn, värde)``\\-tupler."

#: ../../library/shutil.rst:756
msgid ""
"*description* can be provided to describe the format, and will be returned "
"by the :func:`get_unpack_formats` function."
msgstr ""
"*description* kan anges för att beskriva formatet och kommer att returneras "
"av funktionen :func:`get_unpack_formats`."

#: ../../library/shutil.rst:762
msgid "Unregister an unpack format. *name* is the name of the format."
msgstr "Avregistrera ett uppackningsformat. *name* är namnet på formatet."

#: ../../library/shutil.rst:767
msgid ""
"Return a list of all registered formats for unpacking. Each element of the "
"returned sequence is a tuple ``(name, extensions, description)``."
msgstr ""
"Returnerar en lista över alla registrerade format för uppackning. Varje "
"element i den returnerade sekvensen är en tupel ``(name, extensions, "
"description)``."

#: ../../library/shutil.rst:773
msgid ""
"*zip*: ZIP file (unpacking compressed files works only if the corresponding "
"module is available)."
msgstr ""
"*zip*: ZIP-fil (uppackning av komprimerade filer fungerar endast om "
"motsvarande modul finns tillgänglig)."

#: ../../library/shutil.rst:775
msgid "*tar*: uncompressed tar file."
msgstr "*tar*: okomprimerad tar-fil."

#: ../../library/shutil.rst:780
msgid ""
"You can register new formats or provide your own unpacker for any existing "
"formats, by using :func:`register_unpack_format`."
msgstr ""
"Du kan registrera nya format eller tillhandahålla din egen uppackare för "
"befintliga format genom att använda :func:`register_unpack_format`."

#: ../../library/shutil.rst:787
msgid "Archiving example"
msgstr "Exempel på arkivering"

#: ../../library/shutil.rst:789
msgid ""
"In this example, we create a gzip'ed tar-file archive containing all files "
"found in the :file:`.ssh` directory of the user::"
msgstr ""
"I det här exemplet skapar vi ett gzip-komprimerat tar-filarkiv som "
"innehåller alla filer som finns i :file:`.ssh`\\-katalogen för användaren::"

#: ../../library/shutil.rst:792
msgid ""
">>> from shutil import make_archive\n"
">>> import os\n"
">>> archive_name = os.path.expanduser(os.path.join('~', 'myarchive'))\n"
">>> root_dir = os.path.expanduser(os.path.join('~', '.ssh'))\n"
">>> make_archive(archive_name, 'gztar', root_dir)\n"
"'/Users/tarek/myarchive.tar.gz'"
msgstr ""
">>> from shutil import make_archive\n"
">>> import os\n"
">>> archive_name = os.path.expanduser(os.path.join('~', 'myarchive'))\n"
">>> root_dir = os.path.expanduser(os.path.join('~', '.ssh'))\n"
">>> make_archive(archive_name, 'gztar', root_dir)\n"
"'/Users/tarek/myarchive.tar.gz'"

#: ../../library/shutil.rst:799
msgid "The resulting archive contains:"
msgstr "Det resulterande arkivet innehåller:"

#: ../../library/shutil.rst:801
msgid ""
"$ tar -tzvf /Users/tarek/myarchive.tar.gz\n"
"drwx------ tarek/staff       0 2010-02-01 16:23:40 ./\n"
"-rw-r--r-- tarek/staff     609 2008-06-09 13:26:54 ./authorized_keys\n"
"-rwxr-xr-x tarek/staff      65 2008-06-09 13:26:54 ./config\n"
"-rwx------ tarek/staff     668 2008-06-09 13:26:54 ./id_dsa\n"
"-rwxr-xr-x tarek/staff     609 2008-06-09 13:26:54 ./id_dsa.pub\n"
"-rw------- tarek/staff    1675 2008-06-09 13:26:54 ./id_rsa\n"
"-rw-r--r-- tarek/staff     397 2008-06-09 13:26:54 ./id_rsa.pub\n"
"-rw-r--r-- tarek/staff   37192 2010-02-06 18:23:10 ./known_hosts"
msgstr ""
"$ tar -tzvf /Users/tarek/myarchive.tar.gz\n"
"drwx------ tarek/staff       0 2010-02-01 16:23:40 ./\n"
"-rw-r--r-- tarek/staff     609 2008-06-09 13:26:54 ./authorized_keys\n"
"-rwxr-xr-x tarek/staff      65 2008-06-09 13:26:54 ./config\n"
"-rwx------ tarek/staff     668 2008-06-09 13:26:54 ./id_dsa\n"
"-rwxr-xr-x tarek/staff     609 2008-06-09 13:26:54 ./id_dsa.pub\n"
"-rw------- tarek/staff    1675 2008-06-09 13:26:54 ./id_rsa\n"
"-rw-r--r-- tarek/staff     397 2008-06-09 13:26:54 ./id_rsa.pub\n"
"-rw-r--r-- tarek/staff   37192 2010-02-06 18:23:10 ./known_hosts"

#: ../../library/shutil.rst:817
msgid "Archiving example with *base_dir*"
msgstr "Exempel på arkivering med *base_dir*"

#: ../../library/shutil.rst:819
msgid ""
"In this example, similar to the `one above <shutil-archiving-example_>`_, we "
"show how to use :func:`make_archive`, but this time with the usage of "
"*base_dir*.  We now have the following directory structure:"
msgstr ""
"I det här exemplet, som liknar `exemplet ovan <shutil-archiving-example_>`_, "
"visar vi hur man använder :func:`make_archive`, men den här gången med "
"*base_dir*.  Vi har nu följande katalogstruktur:"

#: ../../library/shutil.rst:823
msgid ""
"$ tree tmp\n"
"tmp\n"
"└── root\n"
"    └── structure\n"
"        ├── content\n"
"            └── please_add.txt\n"
"        └── do_not_add.txt"
msgstr ""
"$ tree tmp\n"
"tmp\n"
"└── root\n"
"    └── structure\n"
"        ├── content\n"
"            └── please_add.txt\n"
"        └── do_not_add.txt"

#: ../../library/shutil.rst:833
msgid ""
"In the final archive, :file:`please_add.txt` should be included, but :file:"
"`do_not_add.txt` should not.  Therefore we use the following::"
msgstr ""
"I det slutliga arkivet ska :file:`please_add.txt` ingå, men :file:"
"`do_not_add.txt` ska inte ingå.  Därför använder vi följande::"

#: ../../library/shutil.rst:836
msgid ""
">>> from shutil import make_archive\n"
">>> import os\n"
">>> archive_name = os.path.expanduser(os.path.join('~', 'myarchive'))\n"
">>> make_archive(\n"
"...     archive_name,\n"
"...     'tar',\n"
"...     root_dir='tmp/root',\n"
"...     base_dir='structure/content',\n"
"... )\n"
"'/Users/tarek/myarchive.tar'"
msgstr ""
">>> from shutil import make_archive\n"
">>> import os\n"
">>> archive_name = os.path.expanduser(os.path.join('~', 'myarchive'))\n"
">>> make_archive(\n"
"...     archive_name,\n"
"...     'tar',\n"
"...     root_dir='tmp/root',\n"
"...     base_dir='structure/content',\n"
"... )\n"
"'/Users/tarek/myarchive.tar'"

#: ../../library/shutil.rst:847
msgid "Listing the files in the resulting archive gives us:"
msgstr "En lista över filerna i det resulterande arkivet ger oss:"

#: ../../library/shutil.rst:849
msgid ""
"$ python -m tarfile -l /Users/tarek/myarchive.tar\n"
"structure/content/\n"
"structure/content/please_add.txt"
msgstr ""
"$ python -m tarfile -l /Users/tarek/myarchive.tar\n"
"structure/content/\n"
"structure/content/please_add.txt"

#: ../../library/shutil.rst:857
msgid "Querying the size of the output terminal"
msgstr "Fråga om storleken på utdataterminalen"

#: ../../library/shutil.rst:861
msgid "Get the size of the terminal window."
msgstr "Hämta storleken på terminalfönstret."

#: ../../library/shutil.rst:863
msgid ""
"For each of the two dimensions, the environment variable, ``COLUMNS`` and "
"``LINES`` respectively, is checked. If the variable is defined and the value "
"is a positive integer, it is used."
msgstr ""
"För var och en av de två dimensionerna kontrolleras miljövariabeln "
"``COLUMNS`` respektive ``LINES``. Om variabeln är definierad och värdet är "
"ett positivt heltal används den."

#: ../../library/shutil.rst:867
msgid ""
"When ``COLUMNS`` or ``LINES`` is not defined, which is the common case, the "
"terminal connected to :data:`sys.__stdout__` is queried by invoking :func:"
"`os.get_terminal_size`."
msgstr ""
"När ``COLUMNS`` eller ``LINES`` inte är definierade, vilket är det vanliga "
"fallet, frågas terminalen som är ansluten till :data:`sys.__stdout__` genom "
"att anropa :func:`os.get_terminal_size`."

#: ../../library/shutil.rst:871
msgid ""
"If the terminal size cannot be successfully queried, either because the "
"system doesn't support querying, or because we are not connected to a "
"terminal, the value given in ``fallback`` parameter is used. ``fallback`` "
"defaults to ``(80, 24)`` which is the default size used by many terminal "
"emulators."
msgstr ""
"Om det inte går att fråga efter terminalstorleken, antingen för att systemet "
"inte stöder en sådan fråga eller för att vi inte är anslutna till en "
"terminal, används det värde som anges i parametern ``fallback``. "
"standardvärdet för ``fallback`` är ``(80, 24)``, vilket är den "
"standardstorlek som används av många terminalemulatorer."

#: ../../library/shutil.rst:877
msgid "The value returned is a named tuple of type :class:`os.terminal_size`."
msgstr ""
"Det värde som returneras är en namngiven tupel av typen :class:`os."
"terminal_size`."

#: ../../library/shutil.rst:879
msgid ""
"See also: The Single UNIX Specification, Version 2, `Other Environment "
"Variables`_."
msgstr ""
"Se även: The Single UNIX Specification, Version 2, `Other Environment "
"Variables`_."

#: ../../library/shutil.rst:884
msgid ""
"The ``fallback`` values are also used if :func:`os.get_terminal_size` "
"returns zeroes."
msgstr ""
"``fallback``\\-värdena används också om :func:`os.get_terminal_size` "
"returnerar noll."

#: ../../library/shutil.rst:12
msgid "file"
msgstr "fil"

#: ../../library/shutil.rst:12
msgid "copying"
msgstr "kopiering"

#: ../../library/shutil.rst:12
msgid "copying files"
msgstr "kopiering av filer"

#: ../../library/shutil.rst:304
msgid "directory"
msgstr "directory"

#: ../../library/shutil.rst:304
msgid "deleting"
msgstr "radering"
