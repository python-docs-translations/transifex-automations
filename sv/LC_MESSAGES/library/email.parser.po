# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-16 17:23+0000\n"
"PO-Revision-Date: 2025-09-16 00:01+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../library/email.parser.rst:2
msgid ":mod:`!email.parser`: Parsing email messages"
msgstr ":mod:`!email.parser`: Parsning av e-postmeddelanden"

#: ../../library/email.parser.rst:7
msgid "**Source code:** :source:`Lib/email/parser.py`"
msgstr "**Källkod:** :source:`Lib/email/parser.py`"

#: ../../library/email.parser.rst:11
msgid ""
"Message object structures can be created in one of two ways: they can be "
"created from whole cloth by creating an :class:`~email.message.EmailMessage` "
"object, adding headers using the dictionary interface, and adding payload(s) "
"using :meth:`~email.message.EmailMessage.set_content` and related methods, "
"or they can be created by parsing a serialized representation of the email "
"message."
msgstr ""
"Objektstrukturer för meddelanden kan skapas på två sätt: de kan skapas helt "
"från början genom att skapa ett :class:`~email.message.EmailMessage`-objekt, "
"lägga till rubriker med hjälp av dictionary-gränssnittet och lägga till "
"nyttolast(er) med hjälp av :meth:`~email.message.EmailMessage.set_content` "
"och relaterade metoder, eller så kan de skapas genom att parsa en "
"serialiserad representation av e-postmeddelandet."

#: ../../library/email.parser.rst:18
msgid ""
"The :mod:`email` package provides a standard parser that understands most "
"email document structures, including MIME documents.  You can pass the "
"parser a bytes, string or file object, and the parser will return to you the "
"root :class:`~email.message.EmailMessage` instance of the object structure.  "
"For simple, non-MIME messages the payload of this root object will likely be "
"a string containing the text of the message.  For MIME messages, the root "
"object will return ``True`` from "
"its :meth:`~email.message.EmailMessage.is_multipart` method, and the "
"subparts can be accessed via the payload manipulation methods, such "
"as :meth:`~email.message.EmailMessage.get_body`, :meth:`~email.message.EmailMessage.iter_parts`, "
"and :meth:`~email.message.EmailMessage.walk`."
msgstr ""
"Paketet :mod:`email` tillhandahåller en standardparser som förstår de flesta "
"e-postdokumentstrukturer, inklusive MIME-dokument.  Du kan skicka ett "
"bytes-, sträng- eller filobjekt till parsern, som returnerar "
"rotobjektet :class:`~email.message.EmailMessage` i objektstrukturen.  För "
"enkla icke-MIME-meddelanden kommer nyttolasten för detta rotobjekt sannolikt "
"att vara en sträng som innehåller texten i meddelandet.  För MIME-"
"meddelanden returnerar rotobjektet ``True`` från sin "
"metod :meth:`~email.message.EmailMessage.is_multipart`, och underdelarna kan "
"nås via metoderna för manipulering av nyttolasten, "
"t.ex. :meth:`~email.message.EmailMessage.get_body`, :meth:`~email.message.EmailMessage.iter_parts` "
"och :meth:`~email.message.EmailMessage.walk`."

#: ../../library/email.parser.rst:30
msgid ""
"There are actually two parser interfaces available for use, "
"the :class:`Parser` API and the incremental :class:`FeedParser` API.  "
"The :class:`Parser` API is most useful if you have the entire text of the "
"message in memory, or if the entire message lives in a file on the file "
"system.  :class:`FeedParser` is more appropriate when you are reading the "
"message from a stream which might block waiting for more input (such as "
"reading an email message from a socket).  The :class:`FeedParser` can "
"consume and parse the message incrementally, and only returns the root "
"object when you close the parser."
msgstr ""
"Det finns faktiskt två parsergränssnitt tillgängliga för "
"användning, :class:`Parser` API och det inkrementella :class:`FeedParser` "
"API.  API:et :class:`Parser` är mest användbart om du har hela texten i "
"meddelandet i minnet, eller om hela meddelandet finns i en fil i "
"filsystemet. API:et :class:`FeedParser` är mer lämpligt när du läser "
"meddelandet från en ström som kan blockeras i väntan på mer indata (t.ex. "
"när du läser ett e-postmeddelande från en socket).  :class:`FeedParser` kan "
"konsumera och analysera meddelandet stegvis och returnerar rotobjektet först "
"när du stänger parsern."

#: ../../library/email.parser.rst:39
msgid ""
"Note that the parser can be extended in limited ways, and of course you can "
"implement your own parser completely from scratch.  All of the logic that "
"connects the :mod:`email` package's bundled parser and "
"the :class:`~email.message.EmailMessage` class is embodied in "
"the :class:`~email.policy.Policy` class, so a custom parser can create "
"message object trees any way it finds necessary by implementing custom "
"versions of the appropriate :class:`!Policy` methods."
msgstr ""
"Observera att parsern kan utökas på begränsade sätt, och naturligtvis kan du "
"implementera din egen parser helt från grunden.  All logik som kopplar "
"samman :mod:`email`-paketets medföljande parser "
"och :class:`~email.message.EmailMessage`-klassen finns "
"i :class:`~email.policy.Policy`-klassen, så en anpassad parser kan skapa "
"träd av meddelandeobjekt på det sätt som den finner nödvändigt genom att "
"implementera anpassade versioner av lämpliga :class:`!Policy`-metoder."

#: ../../library/email.parser.rst:49
msgid "FeedParser API"
msgstr "FeedParser API"

#: ../../library/email.parser.rst:51
msgid ""
"The :class:`BytesFeedParser`, imported from the :mod:`email.feedparser` "
"module, provides an API that is conducive to incremental parsing of email "
"messages, such as would be necessary when reading the text of an email "
"message from a source that can block (such as a socket).  "
"The :class:`BytesFeedParser` can of course be used to parse an email message "
"fully contained in a :term:`bytes-like object`, string, or file, but "
"the :class:`BytesParser` API may be more convenient for such use cases.  The "
"semantics and results of the two parser APIs are identical."
msgstr ""
":class:`BytesFeedParser`, som importeras från "
"modulen :mod:`email.feedparser`, tillhandahåller ett API som är lämpligt för "
"stegvis analys av e-postmeddelanden, t.ex. när man läser texten i ett e-"
"postmeddelande från en källa som kan blockeras (t.ex. en socket).  "
"API:t :class:`BytesFeedParser` kan naturligtvis användas för att analysera "
"ett e-postmeddelande som helt och hållet finns i ett :term:`bytesliknande "
"objekt`, en sträng eller en fil, men API:t :class:`BytesParser` kan vara mer "
"praktiskt för sådana användningsfall.  Semantiken och resultaten för de två "
"parser-API:erna är identiska."

#: ../../library/email.parser.rst:60
msgid ""
"The :class:`BytesFeedParser`'s API is simple; you create an instance, feed "
"it a bunch of bytes until there's no more to feed it, then close the parser "
"to retrieve the root message object.  The :class:`BytesFeedParser` is "
"extremely accurate when parsing standards-compliant messages, and it does a "
"very good job of parsing non-compliant messages, providing information about "
"how a message was deemed broken.  It will populate a message "
"object's :attr:`~email.message.EmailMessage.defects` attribute with a list "
"of any problems it found in a message.  See the :mod:`email.errors` module "
"for the list of defects that it can find."
msgstr ""
"API:et för :class:`BytesFeedParser` är enkelt; du skapar en instans, matar "
"den med en massa bytes tills det inte finns mer att mata den med och stänger "
"sedan parsern för att hämta rotmeddelandeobjektet.  :class:`BytesFeedParser` "
"är extremt exakt när den analyserar meddelanden som följer standarder, och "
"den gör ett mycket bra jobb med att analysera meddelanden som inte följer "
"standarder, och ger information om hur ett meddelande ansågs vara trasigt.  "
"Den kommer att fylla ett "
"meddelandeobjekts :attr:`~email.message.EmailMessage.defects`-attribut med "
"en lista över alla problem som den hittade i ett meddelande.  Se "
"modulen :mod:`email.errors` för en lista över defekter som den kan hitta."

#: ../../library/email.parser.rst:70
msgid "Here is the API for the :class:`BytesFeedParser`:"
msgstr "Här är API:et för :class:`BytesFeedParser`:"

#: ../../library/email.parser.rst:75
msgid ""
"Create a :class:`BytesFeedParser` instance.  Optional *_factory* is a no-"
"argument callable; if not specified use "
"the :attr:`~email.policy.Policy.message_factory` from the *policy*.  Call "
"*_factory* whenever a new message object is needed."
msgstr ""
"Skapa en instans av :class:`BytesFeedParser`.  Valfri *_factory* är en "
"anropsbar utan argument; om den inte anges "
"används :attr:`~email.policy.Policy.message_factory` från *policy*.  Anropa "
"*_factory* när ett nytt meddelandeobjekt behövs."

#: ../../library/email.parser.rst:80
msgid ""
"If *policy* is specified use the rules it specifies to update the "
"representation of the message.  If *policy* is not set, use "
"the :class:`compat32 <email.policy.Compat32>` policy, which maintains "
"backward compatibility with the Python 3.2 version of the email package and "
"provides :class:`~email.message.Message` as the default factory.  All other "
"policies provide :class:`~email.message.EmailMessage` as the default "
"*_factory*. For more information on what else *policy* controls, see "
"the :mod:`~email.policy` documentation."
msgstr ""
"Om *policy* anges används de regler som anges för att uppdatera "
"representationen av meddelandet.  Om *policy* inte anges, använd "
"policyn :class:`compat32 <email.policy.Compat32>`, som upprätthåller "
"bakåtkompatibilitet med Python 3.2-versionen av e-postpaketet och "
"tillhandahåller :class:`~email.message.Message` som standardfabrik.  Alla "
"andra policyer tillhandahåller :class:`~email.message.EmailMessage` som "
"standard *_factory*. Mer information om vad mer *policy* kontrollerar finns "
"i dokumentationen för :mod:`~email.policy`."

#: ../../library/email.parser.rst:89 ../../library/email.parser.rst:145
msgid ""
"Note: **The policy keyword should always be specified**; The default will "
"change to :data:`email.policy.default` in a future version of Python."
msgstr ""
"Obs: ** Nyckelordet policy ska alltid anges**; Standardvärdet kommer att "
"ändras till :data:`email.policy.default` i en framtida version av Python."

#: ../../library/email.parser.rst:94 ../../library/email.parser.rst:122
msgid "Added the *policy* keyword."
msgstr "Nyckelordet *policy* har lagts till."

#: ../../library/email.parser.rst:95
msgid "*_factory* defaults to the policy ``message_factory``."
msgstr "*_factory* Standardvärdet är policyn ``message_factory``."

#: ../../library/email.parser.rst:100
msgid ""
"Feed the parser some more data.  *data* should be a :term:`bytes-like "
"object` containing one or more lines.  The lines can be partial and the "
"parser will stitch such partial lines together properly.  The lines can have "
"any of the three common line endings: carriage return, newline, or carriage "
"return and newline (they can even be mixed)."
msgstr ""
"Mata parsern med mer data.  *data* bör vara ett :term:`bytesliknande objekt` "
"som innehåller en eller flera rader.  Raderna kan vara partiella och parsern "
"kommer att sy ihop sådana partiella rader på rätt sätt.  Raderna kan ha "
"någon av de tre vanliga radavslutningarna: vagnsretur, ny rad eller "
"vagnsretur och ny rad (de kan även blandas)."

#: ../../library/email.parser.rst:109
msgid ""
"Complete the parsing of all previously fed data and return the root message "
"object.  It is undefined what happens if :meth:`~feed` is called after this "
"method has been called."
msgstr ""
"Slutför parsningen av all tidigare matad data och returnerar "
"rotmeddelandeobjektet.  Det är odefinierat vad som händer om :meth:`~feed` "
"anropas efter att denna metod har anropats."

#: ../../library/email.parser.rst:116
msgid ""
"Works like :class:`BytesFeedParser` except that the input to "
"the :meth:`~BytesFeedParser.feed` method must be a string.  This is of "
"limited utility, since the only way for such a message to be valid is for it "
"to contain only ASCII text or, if :attr:`~email.policy.EmailPolicy.utf8` is "
"``True``, no binary attachments."
msgstr ""
"Fungerar som :class:`BytesFeedParser` förutom att indata "
"till :meth:`~BytesFeedParser.feed`-metoden måste vara en sträng.  Detta är "
"av begränsad nytta, eftersom det enda sättet för ett sådant meddelande att "
"vara giltigt är att det endast innehåller ASCII-text eller, "
"om :attr:`~email.policy.EmailPolicy.utf8` är ``True``, inga binära bilagor."

#: ../../library/email.parser.rst:126
msgid "Parser API"
msgstr "Parser API"

#: ../../library/email.parser.rst:128
msgid ""
"The :class:`BytesParser` class, imported from the :mod:`email.parser` "
"module, provides an API that can be used to parse a message when the "
"complete contents of the message are available in a :term:`bytes-like "
"object` or file.  The :mod:`email.parser` module also "
"provides :class:`Parser` for parsing strings, and header-only "
"parsers, :class:`BytesHeaderParser` and :class:`HeaderParser`, which can be "
"used if you're only interested in the headers of the "
"message.  :class:`BytesHeaderParser` and :class:`HeaderParser` can be much "
"faster in these situations, since they do not attempt to parse the message "
"body, instead setting the payload to the raw body."
msgstr ""
"Klassen :class:`BytesParser`, importerad från modulen :mod:`email.parser`, "
"tillhandahåller ett API som kan användas för att analysera ett meddelande "
"när det fullständiga innehållet i meddelandet finns tillgängligt i "
"ett :term:`bytesliknande objekt` eller en fil.  Modulen :mod:`email.parser` "
"tillhandahåller även :class:`Parser` för att analysera strängar och "
"analysatorer för enbart rubriker, :class:`BytesHeaderParser` "
"och :class:`HeaderParser`, som kan användas om du bara är intresserad av "
"meddelandets rubriker.  :class:`BytesHeaderParser` och :class:`HeaderParser` "
"kan vara mycket snabbare i dessa situationer, eftersom de inte försöker "
"analysera meddelandetexten, utan istället sätter nyttolasten till den råa "
"texten."

#: ../../library/email.parser.rst:141
msgid ""
"Create a :class:`BytesParser` instance.  The *_class* and *policy* arguments "
"have the same meaning and semantics as the *_factory* and *policy* arguments "
"of :class:`BytesFeedParser`."
msgstr ""
"Skapa en instans av :class:`BytesParser`.  Argumenten *_class* och *policy* "
"har samma betydelse och semantik som argumenten *_factory* och *policy* "
"i :class:`BytesFeedParser`."

#: ../../library/email.parser.rst:148
msgid ""
"Removed the *strict* argument that was deprecated in 2.4.  Added the "
"*policy* keyword."
msgstr ""
"Tog bort argumentet *strict* som inte längre användes i 2.4.  Nyckelordet "
"*policy* har lagts till."

#: ../../library/email.parser.rst:151 ../../library/email.parser.rst:200
#: ../../library/email.parser.rst:280
msgid "*_class* defaults to the policy ``message_factory``."
msgstr "*_class* Standardvärdet är policyn ``message_factory``."

#: ../../library/email.parser.rst:156
msgid ""
"Read all the data from the binary file-like object *fp*, parse the resulting "
"bytes, and return the message object.  *fp* must support both "
"the :meth:`~io.IOBase.readline` and the :meth:`~io.IOBase.read` methods."
msgstr ""
"Läser alla data från det binära filliknande objektet *fp*, analyserar de "
"resulterande byte och returnerar meddelandeobjektet.  *fp* måste stödja både "
"metoderna :meth:`~io.IOBase.readline` och :meth:`~io.IOBase.read`."

#: ../../library/email.parser.rst:161
msgid ""
"The bytes contained in *fp* must be formatted as a block of :rfc:`5322` (or, "
"if :attr:`~email.policy.EmailPolicy.utf8` is ``True``, :rfc:`6532`) style "
"headers and header continuation lines, optionally preceded by an envelope "
"header.  The header block is terminated either by the end of the data or by "
"a blank line.  Following the header block is the body of the message (which "
"may contain MIME-encoded subparts, including subparts with "
"a :mailheader:`Content-Transfer-Encoding` of ``8bit``)."
msgstr ""
"Bytesen i *fp* måste formateras som ett block med rubriker och "
"fortsättningsrader av typen :rfc:`5322` (eller, "
"om :attr:`~email.policy.EmailPolicy.utf8` är ``True``, :rfc:`6532`), "
"eventuellt föregånget av ett kuverthuvud.  Huvudblocket avslutas antingen "
"med slutet av datan eller med en blank rad.  Efter huvudblocket följer "
"meddelandetexten (som kan innehålla MIME-kodade underdelar, inklusive "
"underdelar med en :mailheader:`Content-Transfer-Encoding` på ``8bit``)."

#: ../../library/email.parser.rst:169
msgid ""
"Optional *headersonly* is a flag specifying whether to stop parsing after "
"reading the headers or not.  The default is ``False``, meaning it parses the "
"entire contents of the file."
msgstr ""
"Valfritt *headersonly* är en flagga som anger om parsningen ska avbrytas "
"efter att rubrikerna har lästs eller inte.  Standardvärdet är ``False``, "
"vilket innebär att hela filens innehåll analyseras."

#: ../../library/email.parser.rst:176
msgid ""
"Similar to the :meth:`parse` method, except it takes a :term:`bytes-like "
"object` instead of a file-like object.  Calling this method on "
"a :term:`bytes-like object` is equivalent to wrapping *bytes* in "
"a :class:`~io.BytesIO` instance first and calling :meth:`parse`."
msgstr ""
"Liknar metoden :meth:`parse`, förutom att den tar ett :term:`bytesliknande "
"objekt` istället för ett filliknande objekt.  Att anropa denna metod på "
"ett :term:`bytesliknande objekt` är likvärdigt med att först packa in "
"*bytes* i en :class:`~io.BytesIO`-instans och sedan anropa :meth:`parse`."

#: ../../library/email.parser.rst:181 ../../library/email.parser.rst:221
msgid "Optional *headersonly* is as with the :meth:`parse` method."
msgstr "Valfritt *headersonly* är som med metoden :meth:`parse`."

#: ../../library/email.parser.rst:188
msgid ""
"Exactly like :class:`BytesParser`, except that *headersonly* defaults to "
"``True``."
msgstr ""
"Exakt som :class:`BytesParser`, förutom att *headersonly* som standard är "
"``True``."

#: ../../library/email.parser.rst:196
msgid ""
"This class is parallel to :class:`BytesParser`, but handles string input."
msgstr ""
"Denna klass är parallell med :class:`BytesParser`, men hanterar "
"stränginmatning."

#: ../../library/email.parser.rst:198 ../../library/email.parser.rst:245
#: ../../library/email.parser.rst:258 ../../library/email.parser.rst:268
#: ../../library/email.parser.rst:278
msgid "Removed the *strict* argument.  Added the *policy* keyword."
msgstr ""
"Argumentet *strict* har tagits bort.  Nyckelordet *policy* har lagts till."

#: ../../library/email.parser.rst:205
msgid ""
"Read all the data from the text-mode file-like object *fp*, parse the "
"resulting text, and return the root message object.  *fp* must support both "
"the :meth:`~io.TextIOBase.readline` and the :meth:`~io.TextIOBase.read` "
"methods on file-like objects."
msgstr ""
"Läser alla data från det filliknande objektet *fp* i textläge, tolkar den "
"resulterande texten och returnerar rotmeddelandeobjektet.  *fp* måste stödja "
"både metoderna :meth:`~io.TextIOBase.readline` "
"och :meth:`~io.TextIOBase.read` för filliknande objekt."

#: ../../library/email.parser.rst:210
msgid ""
"Other than the text mode requirement, this method operates "
"like :meth:`BytesParser.parse`."
msgstr ""
"Bortsett från kravet på textläge fungerar den här metoden "
"som :meth:`BytesParser.parse`."

#: ../../library/email.parser.rst:216
msgid ""
"Similar to the :meth:`parse` method, except it takes a string object instead "
"of a file-like object.  Calling this method on a string is equivalent to "
"wrapping *text* in a :class:`~io.StringIO` instance first and "
"calling :meth:`parse`."
msgstr ""
"Liknar metoden :meth:`parse`, förutom att den tar ett strängobjekt istället "
"för ett filliknande objekt.  Att anropa denna metod på en sträng motsvarar "
"att först packa in *text* i en :class:`~io.StringIO`-instans och sedan "
"anropa :meth:`parse`."

#: ../../library/email.parser.rst:226
msgid ""
"Exactly like :class:`Parser`, except that *headersonly* defaults to ``True``."
msgstr ""
"Exakt som :class:`Parser`, förutom att *headersonly* har standardvärdet "
"``True``."

#: ../../library/email.parser.rst:230
msgid ""
"Since creating a message object structure from a string or a file object is "
"such a common task, four functions are provided as a convenience.  They are "
"available in the top-level :mod:`email` package namespace."
msgstr ""
"Eftersom det är en vanlig uppgift att skapa en meddelandeobjektstruktur från "
"en sträng eller ett filobjekt, finns det fyra funktioner som en "
"bekvämlighet.  De är tillgängliga i toppnivån :mod:`email` package namespace."

#: ../../library/email.parser.rst:239
msgid ""
"Return a message object structure from a :term:`bytes-like object`.  This is "
"equivalent to ``BytesParser().parsebytes(s)``.  Optional *_class* and "
"*policy* are interpreted as with the :class:`~email.parser.BytesParser` "
"class constructor."
msgstr ""
"Returnerar en meddelandeobjektstruktur från ett :term:`bytesliknande "
"objekt`.  Detta är likvärdigt med ``BytesParser().parsebytes(s)``.  Valfria "
"*_class* och *policy* tolkas som med :class:`~email.parser.BytesParser` "
"klasskonstruktören."

#: ../../library/email.parser.rst:252
msgid ""
"Return a message object structure tree from an open binary :term:`file "
"object`.  This is equivalent to ``BytesParser().parse(fp)``.  *_class* and "
"*policy* are interpreted as with the :class:`~email.parser.BytesParser` "
"class constructor."
msgstr ""
"Returnerar ett strukturträd för meddelandeobjekt från ett öppet "
"binärt :term:`filobjekt`.  Detta är likvärdigt med "
"``BytesParser().parse(fp)``.  *_class* och *policy* tolkas som "
"med :class:`~email.parser.BytesParser` klasskonstruktören."

#: ../../library/email.parser.rst:264
msgid ""
"Return a message object structure from a string.  This is equivalent to "
"``Parser().parsestr(s)``.  *_class* and *policy* are interpreted as with "
"the :class:`~email.parser.Parser` class constructor."
msgstr ""
"Returnerar en meddelandeobjektstruktur från en sträng.  Detta är likvärdigt "
"med ``Parser().parsestr(s)``.  *_class* och *policy* tolkas som "
"med :class:`~email.parser.Parser`-klassens konstruktör."

#: ../../library/email.parser.rst:274
msgid ""
"Return a message object structure tree from an open :term:`file object`. "
"This is equivalent to ``Parser().parse(fp)``.  *_class* and *policy* are "
"interpreted as with the :class:`~email.parser.Parser` class constructor."
msgstr ""
"Returnerar ett strukturträd för meddelandeobjekt från ett "
"öppet :term:`filobjekt`. Detta är likvärdigt med ``Parser().parse(fp)``.  "
"*_class* och *policy* tolkas som med :class:`~email.parser.Parser` "
"klasskonstruktören."

#: ../../library/email.parser.rst:283
msgid ""
"Here's an example of how you might use :func:`message_from_bytes` at an "
"interactive Python prompt::"
msgstr ""
"Här är ett exempel på hur du kan använda :func:`message_from_bytes` i en "
"interaktiv Python-prompt::"

#: ../../library/email.parser.rst:286
msgid ""
">>> import email\n"
">>> msg = email.message_from_bytes(myBytes)"
msgstr ""
">>> import e-post\n"
">>> msg = email.message_from_bytes(myBytes)"

#: ../../library/email.parser.rst:291
msgid "Additional notes"
msgstr "Ytterligare anmärkningar"

#: ../../library/email.parser.rst:293
msgid "Here are some notes on the parsing semantics:"
msgstr "Här följer några kommentarer om semantiken i parsningen:"

#: ../../library/email.parser.rst:295
msgid ""
"Most non-\\ :mimetype:`multipart` type messages are parsed as a single "
"message object with a string payload.  These objects will return ``False`` "
"for :meth:`~email.message.EmailMessage.is_multipart`, "
"and :meth:`~email.message.EmailMessage.iter_parts` will yield an empty list."
msgstr ""
"De flesta meddelanden av typen :mimetype:`multipart` som inte är av "
"typen :mimetype:`multipart` analyseras som ett enda meddelandeobjekt med en "
"sträng som nyttolast.  Dessa objekt kommer att returnera ``False`` "
"för :meth:`~email.message.EmailMessage.is_multipart`, "
"och :meth:`~email.message.EmailMessage.iter_parts` kommer att ge en tom "
"lista."

#: ../../library/email.parser.rst:300
msgid ""
"All :mimetype:`multipart` type messages will be parsed as a container "
"message object with a list of sub-message objects for their payload.  The "
"outer container message will return ``True`` "
"for :meth:`~email.message.EmailMessage.is_multipart`, "
"and :meth:`~email.message.EmailMessage.iter_parts` will yield a list of "
"subparts."
msgstr ""
"Alla meddelanden av typen :mimetype:`multipart` tolkas som ett "
"containermeddelandeobjekt med en lista över undermeddelandeobjekt för "
"nyttolasten.  Det yttre containermeddelandet returnerar ``True`` "
"för :meth:`~email.message.EmailMessage.is_multipart`, "
"och :meth:`~email.message.EmailMessage.iter_parts` ger en lista med "
"underdelar."

#: ../../library/email.parser.rst:306
msgid ""
"Most messages with a content type of :mimetype:`message/\\*` (such "
"as :mimetype:`message/delivery-status` and :mimetype:`message/rfc822`) will "
"also be parsed as container object containing a list payload of length 1.  "
"Their :meth:`~email.message.EmailMessage.is_multipart` method will return "
"``True``. The single element yielded "
"by :meth:`~email.message.EmailMessage.iter_parts` will be a sub-message "
"object."
msgstr ""
"De flesta meddelanden med innehållstypen :mimetype:`message/\\*` "
"(t.ex. :mimetype:`message/delivery-status` och :mimetype:`message/rfc822`) "
"kommer också att analyseras som containerobjekt som innehåller en list "
"payload av längd 1. Deras "
"metod :meth:`~email.message.EmailMessage.is_multipart` kommer att returnera "
"``True``. Det enskilda element som erhålls "
"genom :meth:`~email.message.EmailMessage.iter_parts` kommer att vara ett "
"undermeddelandeobjekt."

#: ../../library/email.parser.rst:313
msgid ""
"Some non-standards-compliant messages may not be internally consistent about "
"their :mimetype:`multipart`\\ -edness.  Such messages may have "
"a :mailheader:`Content-Type` header of type :mimetype:`multipart`, but "
"their :meth:`~email.message.EmailMessage.is_multipart` method may return "
"``False``. If such messages were parsed with "
"the :class:`~email.parser.FeedParser`, they will have an instance of "
"the :class:`~email.errors.MultipartInvariantViolationDefect` class in their "
"*defects* attribute list.  See :mod:`email.errors` for details."
msgstr ""
"Vissa meddelanden som inte följer standarderna kanske inte är internt "
"konsekventa när det gäller deras :mimetype:`multipart`-edness.  Sådana "
"meddelanden kan ha en :mailheader:`Content-Type` header av "
"typen :mimetype:`multipart`, men "
"deras :meth:`~email.message.EmailMessage.is_multipart` metod kan returnera "
"``False``. Om sådana meddelanden analyserades "
"med :class:`~email.parser.FeedParser`, kommer de att ha en instans "
"av :class:`~email.errors.MultipartInvariantViolationDefect`-klassen i sin "
"*defects*-attributlista.  Se :mod:`email.errors` för detaljer."
