# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# python-doc bot, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-25 17:21+0000\n"
"PO-Revision-Date: 2025-09-22 15:58+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../library/threading.rst:2
msgid ":mod:`threading` --- Thread-based parallelism"
msgstr ""

#: ../../library/threading.rst:7
msgid "**Source code:** :source:`Lib/threading.py`"
msgstr "**Källkod:** :source:`Lib/threading.py`"

#: ../../library/threading.rst:11
msgid ""
"This module constructs higher-level threading interfaces on top of the lower"
" level :mod:`_thread` module."
msgstr ""
"Denna modul konstruerar trådningsgränssnitt på högre nivå ovanpå modulen "
":mod:`_thread` på lägre nivå."

#: ../../library/threading.rst:14
msgid "This module used to be optional, it is now always available."
msgstr "Denna modul var tidigare valfri, men är nu alltid tillgänglig."

#: ../../library/threading.rst:19
msgid ""
":class:`concurrent.futures.ThreadPoolExecutor` offers a higher level "
"interface to push tasks to a background thread without blocking execution of"
" the calling thread, while still being able to retrieve their results when "
"needed."
msgstr ""
":class:`concurrent.futures.ThreadPoolExecutor` erbjuder ett gränssnitt på "
"högre nivå för att flytta uppgifter till en bakgrundstråd utan att blockera "
"exekveringen av den anropande tråden, samtidigt som man kan hämta resultaten"
" när det behövs."

#: ../../library/threading.rst:23
msgid ""
":mod:`queue` provides a thread-safe interface for exchanging data between "
"running threads."
msgstr ""
":mod:`queue` tillhandahåller ett trådsäkert gränssnitt för utbyte av data "
"mellan pågående trådar."

#: ../../library/threading.rst:26
msgid ""
":mod:`asyncio` offers an alternative approach to achieving task level "
"concurrency without requiring the use of multiple operating system threads."
msgstr ""
":mod:`asyncio` erbjuder en alternativ metod för att uppnå samtidighet på "
"uppgiftsnivå utan att behöva använda flera operativsystemtrådar."

#: ../../library/threading.rst:31
msgid ""
"In the Python 2.x series, this module contained ``camelCase`` names for some"
" methods and functions. These are deprecated as of Python 3.10, but they are"
" still supported for compatibility with Python 2.5 and lower."
msgstr ""
"I Python 2.x-serien innehöll denna modul ``camelCase``-namn för vissa "
"metoder och funktioner. Dessa är föråldrade från och med Python 3.10, men de"
" stöds fortfarande för kompatibilitet med Python 2.5 och lägre."

#: ../../library/threading.rst:38
msgid ""
"In CPython, due to the :term:`Global Interpreter Lock <global interpreter "
"lock>`, only one thread can execute Python code at once (even though certain"
" performance-oriented libraries might overcome this limitation). If you want"
" your application to make better use of the computational resources of "
"multi-core machines, you are advised to use :mod:`multiprocessing` or "
":class:`concurrent.futures.ProcessPoolExecutor`. However, threading is still"
" an appropriate model if you want to run multiple I/O-bound tasks "
"simultaneously."
msgstr ""
"I CPython, på grund av :term:`Global Interpreter Lock <global interpreter "
"lock>`, kan endast en tråd exekvera Python-kod samtidigt (även om vissa "
"prestandaorienterade bibliotek kan övervinna denna begränsning). Om du vill "
"att din applikation ska utnyttja beräkningsresurserna i flerkärniga maskiner"
" bättre rekommenderas du att använda :mod:`multiprocessing` eller "
":class:`concurrent.futures.ProcessPoolExecutor`. Trådning är dock "
"fortfarande en lämplig modell om du vill köra flera I/O-bundna uppgifter "
"samtidigt."

#: ../../library/threading.rst:49
msgid "This module defines the following functions:"
msgstr "Denna modul definierar följande funktioner:"

#: ../../library/threading.rst:54
msgid ""
"Return the number of :class:`Thread` objects currently alive.  The returned "
"count is equal to the length of the list returned by :func:`.enumerate`."
msgstr ""
"Returnerar antalet :class:`Thread`-objekt som för närvarande lever.  Antalet"
" som returneras är lika med längden på listan som returneras av "
":func:`.enumerate`."

#: ../../library/threading.rst:57
msgid "The function ``activeCount`` is a deprecated alias for this function."
msgstr "Funktionen ``activeCount`` är ett föråldrat alias för denna funktion."

#: ../../library/threading.rst:62
msgid ""
"Return the current :class:`Thread` object, corresponding to the caller's "
"thread of control.  If the caller's thread of control was not created "
"through the :mod:`threading` module, a dummy thread object with limited "
"functionality is returned."
msgstr ""

#: ../../library/threading.rst:67
msgid ""
"The function ``currentThread`` is a deprecated alias for this function."
msgstr ""
"Funktionen ``currentThread`` är ett föråldrat alias för denna funktion."

#: ../../library/threading.rst:72
msgid "Handle uncaught exception raised by :func:`Thread.run`."
msgstr "Hantera undantag som uppkommit genom :func:`Thread.run`."

#: ../../library/threading.rst:74
msgid "The *args* argument has the following attributes:"
msgstr "Argumentet *args* har följande attribut:"

#: ../../library/threading.rst:76
msgid "*exc_type*: Exception type."
msgstr "*exc_type*: Typ av undantag."

#: ../../library/threading.rst:77
msgid "*exc_value*: Exception value, can be ``None``."
msgstr "*exc_värde*: Undantagsvärde, kan vara ``None``."

#: ../../library/threading.rst:78
msgid "*exc_traceback*: Exception traceback, can be ``None``."
msgstr "*exc_traceback*: Exception traceback, kan vara ``None``."

#: ../../library/threading.rst:79
msgid "*thread*: Thread which raised the exception, can be ``None``."
msgstr "*tråd*: Tråd som orsakade undantaget, kan vara ``None``."

#: ../../library/threading.rst:81
msgid ""
"If *exc_type* is :exc:`SystemExit`, the exception is silently ignored. "
"Otherwise, the exception is printed out on :data:`sys.stderr`."
msgstr ""
"Om *exc_type* är :exc:`SystemExit`, ignoreras undantaget i tysthet. Annars "
"skrivs undantaget ut på :data:`sys.stderr`."

#: ../../library/threading.rst:84
msgid ""
"If  this function raises an exception, :func:`sys.excepthook` is called to "
"handle it."
msgstr ""
"Om denna funktion ger upphov till ett undantag anropas "
":func:`sys.excepthook` för att hantera det."

#: ../../library/threading.rst:87
msgid ""
":func:`threading.excepthook` can be overridden to control how uncaught "
"exceptions raised by :func:`Thread.run` are handled."
msgstr ""
":func:`threading.excepthook` kan åsidosättas för att styra hur obehandlade "
"undantag som tas upp av :func:`Thread.run` hanteras."

#: ../../library/threading.rst:90
msgid ""
"Storing *exc_value* using a custom hook can create a reference cycle. It "
"should be cleared explicitly to break the reference cycle when the exception"
" is no longer needed."
msgstr ""
"Att lagra *exc_value* med en anpassad krok kan skapa en referenscykel. Den "
"bör rensas explicit för att bryta referenscykeln när undantaget inte längre "
"behövs."

#: ../../library/threading.rst:94
msgid ""
"Storing *thread* using a custom hook can resurrect it if it is set to an "
"object which is being finalized. Avoid storing *thread* after the custom "
"hook completes to avoid resurrecting objects."
msgstr ""
"Om du lagrar *thread* med en anpassad krok kan den återuppstå om den är "
"inställd på ett objekt som håller på att slutföras. Undvik att lagra "
"*thread* efter att den anpassade kroken har slutförts för att undvika att "
"objekt återuppstår."

#: ../../library/threading.rst:99
msgid ":func:`sys.excepthook` handles uncaught exceptions."
msgstr ":func:`sys.excepthook` hanterar undantag som inte fångats upp."

#: ../../library/threading.rst:105
msgid ""
"Holds the original value of :func:`threading.excepthook`. It is saved so "
"that the original value can be restored in case they happen to get replaced "
"with broken or alternative objects."
msgstr ""
"Innehåller det ursprungliga värdet av :func:`threading.excepthook`. Det "
"sparas så att det ursprungliga värdet kan återställas om de skulle råka "
"ersättas med trasiga eller alternativa objekt."

#: ../../library/threading.rst:113
msgid ""
"Return the 'thread identifier' of the current thread.  This is a nonzero "
"integer.  Its value has no direct meaning; it is intended as a magic cookie "
"to be used e.g. to index a dictionary of thread-specific data.  Thread "
"identifiers may be recycled when a thread exits and another thread is "
"created."
msgstr ""
"Returnerar \"trådidentifieraren\" för den aktuella tråden.  Detta är ett "
"heltal som inte är noll.  Dess värde har ingen direkt betydelse; det är "
"avsett som en magisk cookie som kan användas t.ex. för att indexera en "
"ordbok med trådspecifika data.  Trådidentifierare kan återanvändas när en "
"tråd avslutas och en ny tråd skapas."

#: ../../library/threading.rst:124
msgid ""
"Return the native integral Thread ID of the current thread assigned by the "
"kernel. This is a non-negative integer. Its value may be used to uniquely "
"identify this particular thread system-wide (until the thread terminates, "
"after which the value may be recycled by the OS)."
msgstr ""
"Returnerar det inbyggda integrerade tråd-ID:t för den aktuella tråden som "
"tilldelats av kärnan. Detta är ett icke-negativt heltal. Dess värde kan "
"användas för att unikt identifiera just denna tråd i hela systemet (tills "
"tråden avslutas, varefter värdet kan återanvändas av operativsystemet)."

#: ../../library/threading.rst:130
msgid ""
":ref:`Availability <availability>`: Windows, FreeBSD, Linux, macOS, OpenBSD,"
" NetBSD, AIX."
msgstr ""

#: ../../library/threading.rst:136
msgid ""
"Return a list of all :class:`Thread` objects currently active.  The list "
"includes daemonic threads and dummy thread objects created by "
":func:`current_thread`.  It excludes terminated threads and threads that "
"have not yet been started.  However, the main thread is always part of the "
"result, even when terminated."
msgstr ""
"Returnerar en lista över alla :class:`Thread`-objekt som för närvarande är "
"aktiva.  Listan inkluderar daemoniska trådar och dummy-trådobjekt som "
"skapats av :func:`current_thread`.  Den utesluter avslutade trådar och "
"trådar som ännu inte har startats.  Huvudtråden är dock alltid en del av "
"resultatet, även när den har avslutats."

#: ../../library/threading.rst:145
msgid ""
"Return the main :class:`Thread` object.  In normal conditions, the main "
"thread is the thread from which the Python interpreter was started."
msgstr ""
"Returnerar huvudobjektet :class:`Thread`.  Under normala förhållanden är "
"huvudtråden den tråd från vilken Python-tolken startades."

#: ../../library/threading.rst:156
msgid ""
"Set a trace function for all threads started from the :mod:`threading` "
"module. The *func* will be passed to  :func:`sys.settrace` for each thread, "
"before its :meth:`~Thread.run` method is called."
msgstr ""

#: ../../library/threading.rst:167
msgid "Get the trace function as set by :func:`settrace`."
msgstr "Hämta spårningsfunktionen som den ställts in av :func:`settrace`."

#: ../../library/threading.rst:176
msgid ""
"Set a profile function for all threads started from the :mod:`threading` "
"module. The *func* will be passed to  :func:`sys.setprofile` for each "
"thread, before its :meth:`~Thread.run` method is called."
msgstr ""

#: ../../library/threading.rst:185
msgid "Get the profiler function as set by :func:`setprofile`."
msgstr "Hämta den profileringsfunktion som ställts in av :func:`setprofile`."

#: ../../library/threading.rst:192
msgid ""
"Return the thread stack size used when creating new threads.  The optional "
"*size* argument specifies the stack size to be used for subsequently created"
" threads, and must be 0 (use platform or configured default) or a positive "
"integer value of at least 32,768 (32 KiB). If *size* is not specified, 0 is "
"used.  If changing the thread stack size is unsupported, a "
":exc:`RuntimeError` is raised.  If the specified stack size is invalid, a "
":exc:`ValueError` is raised and the stack size is unmodified.  32 KiB is "
"currently the minimum supported stack size value to guarantee sufficient "
"stack space for the interpreter itself.  Note that some platforms may have "
"particular restrictions on values for the stack size, such as requiring a "
"minimum stack size > 32 KiB or requiring allocation in multiples of the "
"system memory page size - platform documentation should be referred to for "
"more information (4 KiB pages are common; using multiples of 4096 for the "
"stack size is the suggested approach in the absence of more specific "
"information)."
msgstr ""
"Returnerar den trådstackstorlek som används när nya trådar skapas.  Det "
"valfria argumentet *size* anger den stackstorlek som ska användas för senare"
" skapade trådar och måste vara 0 (använd plattformens eller konfigurerade "
"standard) eller ett positivt heltalsvärde på minst 32 768 (32 KiB). Om "
"*size* inte anges används 0.  Om ändring av trådstackens storlek inte stöds,"
" uppstår ett :exc:`RuntimeError`.  Om den angivna stackstorleken är ogiltig,"
" uppstår ett :exc:`ValueError` och stackstorleken ändras inte.  32 KiB är "
"för närvarande det minsta stödda stackstorleksvärdet för att garantera "
"tillräckligt med stackutrymme för själva tolken.  Observera att vissa "
"plattformar kan ha särskilda restriktioner för värden på stackstorleken, "
"t.ex. att den minsta stackstorleken måste vara > 32 KiB eller att allokering"
" måste ske i multiplar av sidstorleken i systemminnet - "
"plattformsdokumentationen bör läsas för mer information (4 KiB-sidor är "
"vanliga; att använda multiplar av 4096 för stackstorleken är det föreslagna "
"tillvägagångssättet i avsaknad av mer specifik information)."

#: ../../library/threading.rst:207
msgid ""
":ref:`Availability <availability>`: Windows, systems with POSIX threads."
msgstr ""

#: ../../library/threading.rst:210
msgid "This module also defines the following constant:"
msgstr "Denna modul definierar också följande konstant:"

#: ../../library/threading.rst:214
msgid ""
"The maximum value allowed for the *timeout* parameter of blocking functions "
"(:meth:`Lock.acquire`, :meth:`RLock.acquire`, :meth:`Condition.wait`, etc.)."
" Specifying a timeout greater than this value will raise an "
":exc:`OverflowError`."
msgstr ""
"Det högsta tillåtna värdet för parametern *timeout* i blockeringsfunktioner "
"(:meth:`Lock.acquire`, :meth:`RLock.acquire`, :meth:`Condition.wait`, etc.)."
" Om du anger en timeout som är större än detta värde kommer ett "
":exc:`OverflowError` att uppstå."

#: ../../library/threading.rst:222
msgid ""
"This module defines a number of classes, which are detailed in the sections "
"below."
msgstr ""
"Denna modul definierar ett antal klasser som beskrivs närmare i avsnitten "
"nedan."

#: ../../library/threading.rst:225
msgid ""
"The design of this module is loosely based on Java's threading model. "
"However, where Java makes locks and condition variables basic behavior of "
"every object, they are separate objects in Python.  Python's :class:`Thread`"
" class supports a subset of the behavior of Java's Thread class; currently, "
"there are no priorities, no thread groups, and threads cannot be destroyed, "
"stopped, suspended, resumed, or interrupted.  The static methods of Java's "
"Thread class, when implemented, are mapped to module-level functions."
msgstr ""
"Utformningen av denna modul är löst baserad på Javas trådningsmodell. Men "
"där Java gör lås och villkorliga variabler till grundläggande beteende för "
"varje objekt, är de separata objekt i Python.  Pythons :class:`Thread`-klass"
" stöder en delmängd av beteendet hos Javas Thread-klass; för närvarande "
"finns det inga prioriteringar, inga trådgrupper och trådar kan inte "
"förstöras, stoppas, avbrytas, återupptas eller avbrytas.  De statiska "
"metoderna i Javas Thread-klass mappas, när de implementeras, till funktioner"
" på modulnivå."

#: ../../library/threading.rst:233
msgid "All of the methods described below are executed atomically."
msgstr "Alla metoder som beskrivs nedan utförs atomiskt."

#: ../../library/threading.rst:237
msgid "Thread-Local Data"
msgstr ""

#: ../../library/threading.rst:239
msgid ""
"Thread-local data is data whose values are thread specific.  To manage "
"thread-local data, just create an instance of :class:`local` (or a subclass)"
" and store attributes on it::"
msgstr ""

#: ../../library/threading.rst:246
msgid "The instance's values will be different for separate threads."
msgstr ""

#: ../../library/threading.rst:251
msgid "A class that represents thread-local data."
msgstr "En klass som representerar trådlokala data."

#: ../../library/threading.rst:253
msgid ""
"For more details and extensive examples, see the documentation string of the"
" :mod:`_threading_local` module."
msgstr ""

#: ../../library/threading.rst:260
msgid "Thread Objects"
msgstr ""

#: ../../library/threading.rst:262
msgid ""
"The :class:`Thread` class represents an activity that is run in a separate "
"thread of control.  There are two ways to specify the activity: by passing a"
" callable object to the constructor, or by overriding the "
":meth:`~Thread.run` method in a subclass.  No other methods (except for the "
"constructor) should be overridden in a subclass.  In other words, *only*  "
"override the :meth:`~Thread.__init__` and :meth:`~Thread.run` methods of "
"this class."
msgstr ""

#: ../../library/threading.rst:269
msgid ""
"Once a thread object is created, its activity must be started by calling the"
" thread's :meth:`~Thread.start` method.  This invokes the "
":meth:`~Thread.run` method in a separate thread of control."
msgstr ""
"När ett trådobjekt har skapats måste dess aktivitet startas genom att anropa"
" trådens metod :meth:`~Thread.start`.  Detta anropar metoden "
":meth:`~Thread.run` i en separat kontrolltråd."

#: ../../library/threading.rst:273
msgid ""
"Once the thread's activity is started, the thread is considered 'alive'. It "
"stops being alive when its :meth:`~Thread.run` method terminates -- either "
"normally, or by raising an unhandled exception.  The "
":meth:`~Thread.is_alive` method tests whether the thread is alive."
msgstr ""
"När trådens aktivitet har startat anses tråden vara \"levande\". Den slutar "
"att vara levande när dess :meth:`~Thread.run`-metod avslutas -- antingen "
"normalt eller genom att ett ohanterat undantag uppstår.  Metoden "
":meth:`~Thread.is_alive` testar om tråden är vid liv."

#: ../../library/threading.rst:278
msgid ""
"Other threads can call a thread's :meth:`~Thread.join` method.  This blocks "
"the calling thread until the thread whose :meth:`~Thread.join` method is "
"called is terminated."
msgstr ""
"Andra trådar kan anropa en tråds :meth:`~Thread.join`-metod.  Detta "
"blockerar den anropande tråden tills den tråd vars "
":meth:`~Thread.join`-metod anropas har avslutats."

#: ../../library/threading.rst:282
msgid ""
"A thread has a name.  The name can be passed to the constructor, and read or"
" changed through the :attr:`~Thread.name` attribute."
msgstr ""
"En tråd har ett namn.  Namnet kan skickas till konstruktören och läsas eller"
" ändras genom attributet :attr:`~Thread.name`."

#: ../../library/threading.rst:285
msgid ""
"If the :meth:`~Thread.run` method raises an exception, "
":func:`threading.excepthook` is called to handle it. By default, "
":func:`threading.excepthook` ignores silently :exc:`SystemExit`."
msgstr ""
"Om metoden :meth:`~Thread.run` ger upphov till ett undantag anropas "
":func:`threading.excepthook` för att hantera det. Som standard ignorerar "
":func:`threading.excepthook` tyst :exc:`SystemExit`."

#: ../../library/threading.rst:289
msgid ""
"A thread can be flagged as a \"daemon thread\".  The significance of this "
"flag is that the entire Python program exits when only daemon threads are "
"left.  The initial value is inherited from the creating thread.  The flag "
"can be set through the :attr:`~Thread.daemon` property or the *daemon* "
"constructor argument."
msgstr ""
"En tråd kan flaggas som en \"daemon-tråd\".  Betydelsen av denna flagga är "
"att hela Python-programmet avslutas när det bara finns daemon-trådar kvar.  "
"Det initiala värdet ärvs från den skapande tråden.  Flaggan kan sättas genom"
" egenskapen :attr:`~Thread.daemon` eller konstruktörsargumentet *daemon*."

#: ../../library/threading.rst:296
msgid ""
"Daemon threads are abruptly stopped at shutdown.  Their resources (such as "
"open files, database transactions, etc.) may not be released properly. If "
"you want your threads to stop gracefully, make them non-daemonic and use a "
"suitable signalling mechanism such as an :class:`Event`."
msgstr ""
"Daemon-trådar stoppas plötsligt vid nedstängning.  Deras resurser (t.ex. "
"öppna filer, databastransaktioner etc.) kanske inte frigörs på rätt sätt. Om"
" du vill att dina trådar ska sluta på ett elegant sätt, gör dem inte till "
"daemoner och använd en lämplig signalmekanism, t.ex. en :class:`Event`."

#: ../../library/threading.rst:301
msgid ""
"There is a \"main thread\" object; this corresponds to the initial thread of"
" control in the Python program.  It is not a daemon thread."
msgstr ""
"Det finns ett \"main thread\"-objekt; detta motsvarar den första "
"kontrolltråden i Python-programmet.  Det är inte en daemon-tråd."

#: ../../library/threading.rst:304
msgid ""
"There is the possibility that \"dummy thread objects\" are created. These "
"are thread objects corresponding to \"alien threads\", which are threads of "
"control started outside the threading module, such as directly from C code."
"  Dummy thread objects have limited functionality; they are always "
"considered alive and daemonic, and cannot be :meth:`~Thread.join`\\ ed.  "
"They are never deleted, since it is impossible to detect the termination of "
"alien threads."
msgstr ""

#: ../../library/threading.rst:315
msgid ""
"This constructor should always be called with keyword arguments.  Arguments "
"are:"
msgstr ""
"Denna konstruktor ska alltid anropas med nyckelordsargument.  Argumenten är:"

#: ../../library/threading.rst:318
msgid ""
"*group* should be ``None``; reserved for future extension when a "
":class:`ThreadGroup` class is implemented."
msgstr ""

#: ../../library/threading.rst:321
msgid ""
"*target* is the callable object to be invoked by the :meth:`run` method. "
"Defaults to ``None``, meaning nothing is called."
msgstr ""
"*target* är det anropsbara objekt som ska anropas av metoden :meth:`run`. "
"Standardvärdet är ``None``, vilket innebär att ingenting anropas."

#: ../../library/threading.rst:324
msgid ""
"*name* is the thread name. By default, a unique name is constructed of the "
"form \"Thread-*N*\" where *N* is a small decimal number, or \"Thread-*N* "
"(target)\" where \"target\" is ``target.__name__`` if the *target* argument "
"is specified."
msgstr ""
"*name* är trådens namn. Som standard konstrueras ett unikt namn av formen "
"\"Thread-*N*\" där *N* är ett litet decimaltal, eller \"Thread-*N* "
"(target)\" där \"target\" är ``target.__name__`` om argumentet *target* "
"anges."

#: ../../library/threading.rst:329
msgid ""
"*args* is the argument tuple for the target invocation.  Defaults to ``()``."
msgstr ""

#: ../../library/threading.rst:331
msgid ""
"*kwargs* is a dictionary of keyword arguments for the target invocation. "
"Defaults to ``{}``."
msgstr ""
"*kwargs* är en ordbok med nyckelordsargument för målanropet. Standardvärdet "
"är ``{}``."

#: ../../library/threading.rst:334
msgid ""
"If not ``None``, *daemon* explicitly sets whether the thread is daemonic. If"
" ``None`` (the default), the daemonic property is inherited from the current"
" thread."
msgstr ""
"Om inte ``None``, anger *daemon* explicit om tråden är daemonisk. Om "
"``None`` (standard) ärvs daemonic-egenskapen från den aktuella tråden."

#: ../../library/threading.rst:338
msgid ""
"If the subclass overrides the constructor, it must make sure to invoke the "
"base class constructor (``Thread.__init__()``) before doing anything else to"
" the thread."
msgstr ""
"Om subklassen åsidosätter konstruktorn måste den se till att anropa "
"basklassens konstruktor (``Thread.__init__()``) innan den gör något annat "
"med tråden."

#: ../../library/threading.rst:342
msgid "Use the *target* name if *name* argument is omitted."
msgstr "Använd *target*-namnet om *name*-argumentet utelämnas."

#: ../../library/threading.rst:345
msgid "Added the *daemon* argument."
msgstr ""

#: ../../library/threading.rst:350
msgid "Start the thread's activity."
msgstr "Starta trådens aktivitet."

#: ../../library/threading.rst:352
msgid ""
"It must be called at most once per thread object.  It arranges for the "
"object's :meth:`~Thread.run` method to be invoked in a separate thread of "
"control."
msgstr ""
"Den får anropas högst en gång per trådobjekt.  Den ordnar så att objektets "
":meth:`~Thread.run`-metod anropas i en separat kontrolltråd."

#: ../../library/threading.rst:356
msgid ""
"This method will raise a :exc:`RuntimeError` if called more than once on the"
" same thread object."
msgstr ""
"Denna metod kommer att ge upphov till ett :exc:`RuntimeError` om den anropas"
" mer än en gång på samma trådobjekt."

#: ../../library/threading.rst:361
msgid "Method representing the thread's activity."
msgstr "Metod som representerar trådens aktivitet."

#: ../../library/threading.rst:363
msgid ""
"You may override this method in a subclass.  The standard :meth:`run` method"
" invokes the callable object passed to the object's constructor as the "
"*target* argument, if any, with positional and keyword arguments taken from "
"the *args* and *kwargs* arguments, respectively."
msgstr ""
"Du kan åsidosätta denna metod i en subklass.  Standardmetoden :meth:`run` "
"anropar det anropsbara objekt som skickats till objektets konstruktör som "
"*target*-argument, om något, med positions- och nyckelordsargument som "
"hämtas från *args*- respektive *kwargs*-argumenten."

#: ../../library/threading.rst:370
msgid ""
"Wait until the thread terminates. This blocks the calling thread until the "
"thread whose :meth:`~Thread.join` method is called terminates -- either "
"normally or through an unhandled exception -- or until the optional timeout "
"occurs."
msgstr ""
"Vänta tills tråden avslutas. Detta blockerar den anropande tråden tills den "
"tråd vars :meth:`~Thread.join`-metod anropas avslutas -- antingen normalt "
"eller genom ett ohanterat undantag -- eller tills den valfria timeouten "
"inträffar."

#: ../../library/threading.rst:375
msgid ""
"When the *timeout* argument is present and not ``None``, it should be a "
"floating point number specifying a timeout for the operation in seconds (or "
"fractions thereof). As :meth:`~Thread.join` always returns ``None``, you "
"must call :meth:`~Thread.is_alive` after :meth:`~Thread.join` to decide "
"whether a timeout happened -- if the thread is still alive, the "
":meth:`~Thread.join` call timed out."
msgstr ""

#: ../../library/threading.rst:382
msgid ""
"When the *timeout* argument is not present or ``None``, the operation will "
"block until the thread terminates."
msgstr ""
"Om argumentet *timeout* inte finns med eller om det är ``None``, blockeras "
"åtgärden tills tråden avslutas."

#: ../../library/threading.rst:385
msgid "A thread can be :meth:`~Thread.join`\\ ed many times."
msgstr ""

#: ../../library/threading.rst:387
msgid ""
":meth:`~Thread.join` raises a :exc:`RuntimeError` if an attempt is made to "
"join the current thread as that would cause a deadlock. It is also an error "
"to :meth:`~Thread.join` a thread before it has been started and attempts to "
"do so raise the same exception."
msgstr ""
":meth:`~Thread.join` ger upphov till ett :exc:`RuntimeError` om ett försök "
"görs att ansluta till den aktuella tråden eftersom det skulle orsaka ett "
"dödläge. Det är också ett fel att :meth:`~Thread.join` en tråd innan den har"
" startats och försök att göra det ger upphov till samma undantag."

#: ../../library/threading.rst:394
msgid ""
"A string used for identification purposes only. It has no semantics. "
"Multiple threads may be given the same name.  The initial name is set by the"
" constructor."
msgstr ""
"En sträng som endast används för identifieringsändamål. Den har ingen "
"semantik. Flera trådar kan ges samma namn.  Det initiala namnet sätts av "
"konstruktören."

#: ../../library/threading.rst:401
msgid ""
"Deprecated getter/setter API for :attr:`~Thread.name`; use it directly as a "
"property instead."
msgstr ""
"Föråldrat getter/setter API för :attr:`~Thread.name`; använd det direkt som "
"en egenskap istället."

#: ../../library/threading.rst:408
msgid ""
"The 'thread identifier' of this thread or ``None`` if the thread has not "
"been started.  This is a nonzero integer.  See the :func:`get_ident` "
"function.  Thread identifiers may be recycled when a thread exits and "
"another thread is created.  The identifier is available even after the "
"thread has exited."
msgstr ""
"Trådidentifieraren för denna tråd eller ``None`` om tråden inte har "
"startats.  Detta är ett heltal som inte är noll.  Se funktionen "
":func:`get_ident`.  Trådidentifierare kan återanvändas när en tråd avslutas "
"och en ny tråd skapas.  Identifieraren är tillgänglig även efter att tråden "
"har avslutats."

#: ../../library/threading.rst:416
msgid ""
"The Thread ID (``TID``) of this thread, as assigned by the OS (kernel). This"
" is a non-negative integer, or ``None`` if the thread has not been started. "
"See the :func:`get_native_id` function. This value may be used to uniquely "
"identify this particular thread system-wide (until the thread terminates, "
"after which the value may be recycled by the OS)."
msgstr ""
"Tråd-ID (``TID``) för denna tråd, som tilldelats av operativsystemet "
"(kärnan). Detta är ett icke-negativt heltal, eller ``None`` om tråden inte "
"har startats. Se funktionen :func:`get_native_id`. Detta värde kan användas "
"för att unikt identifiera just denna tråd i hela systemet (tills tråden "
"avslutas, varefter värdet kan återanvändas av operativsystemet)."

#: ../../library/threading.rst:425
msgid ""
"Similar to Process IDs, Thread IDs are only valid (guaranteed unique system-"
"wide) from the time the thread is created until the thread has been "
"terminated."
msgstr ""
"I likhet med process-ID:n är tråd-ID:n endast giltiga (garanterat unika i "
"hela systemet) från det att tråden skapas till dess att tråden har "
"avslutats."

#: ../../library/threading.rst:430
msgid ""
":ref:`Availability <availability>`: Requires :func:`get_native_id` function."
msgstr ""

#: ../../library/threading.rst:435
msgid "Return whether the thread is alive."
msgstr "Returnerar om tråden är vid liv."

#: ../../library/threading.rst:437
msgid ""
"This method returns ``True`` just before the :meth:`~Thread.run` method "
"starts until just after the :meth:`~Thread.run` method terminates.  The "
"module function :func:`.enumerate` returns a list of all alive threads."
msgstr ""
"Denna metod returnerar ``True`` precis innan metoden :meth:`~Thread.run` "
"startar till precis efter att metoden :meth:`~Thread.run` avslutas.  "
"Modulfunktionen :func:`.enumerate` returnerar en lista över alla levande "
"trådar."

#: ../../library/threading.rst:443
msgid ""
"A boolean value indicating whether this thread is a daemon thread (``True``)"
" or not (``False``).  This must be set before :meth:`~Thread.start` is "
"called, otherwise :exc:`RuntimeError` is raised.  Its initial value is "
"inherited from the creating thread; the main thread is not a daemon thread "
"and therefore all threads created in the main thread default to "
":attr:`~Thread.daemon` = ``False``."
msgstr ""
"Ett booleskt värde som anger om denna tråd är en daemon-tråd (``True``) "
"eller inte (``False``).  Detta måste anges innan :meth:`~Thread.start` "
"anropas, annars kommer :exc:`RuntimeError` att aktiveras.  Dess initiala "
"värde ärvs från den tråd som skapar den; huvudtråden är inte en daemon-tråd "
"och därför har alla trådar som skapas i huvudtråden som standard "
":attr:`~Thread.daemon` = ``False``."

#: ../../library/threading.rst:450
msgid ""
"The entire Python program exits when no alive non-daemon threads are left."
msgstr ""
"Hela Python-programmet avslutas när inga levande icke-daemon-trådar finns "
"kvar."

#: ../../library/threading.rst:455
msgid ""
"Deprecated getter/setter API for :attr:`~Thread.daemon`; use it directly as "
"a property instead."
msgstr ""
"Föråldrad getter/setter API för :attr:`~Thread.daemon`; använd den direkt "
"som en egenskap istället."

#: ../../library/threading.rst:464
msgid "Lock Objects"
msgstr ""

#: ../../library/threading.rst:466
msgid ""
"A primitive lock is a synchronization primitive that is not owned by a "
"particular thread when locked.  In Python, it is currently the lowest level "
"synchronization primitive available, implemented directly by the "
":mod:`_thread` extension module."
msgstr ""
"Ett primitivt lås är en synkroniseringsprimitiv som inte ägs av en viss tråd"
" när den är låst.  I Python är det för närvarande den lägsta tillgängliga "
"synkroniseringsprimitiven, som implementeras direkt av tilläggsmodulen "
":mod:`_thread`."

#: ../../library/threading.rst:471
msgid ""
"A primitive lock is in one of two states, \"locked\" or \"unlocked\". It is "
"created in the unlocked state.  It has two basic methods, "
":meth:`~Lock.acquire` and :meth:`~Lock.release`.  When the state is "
"unlocked, :meth:`~Lock.acquire` changes the state to locked and returns "
"immediately.  When the state is locked, :meth:`~Lock.acquire` blocks until a"
" call to :meth:`~Lock.release` in another thread changes it to unlocked, "
"then the :meth:`~Lock.acquire` call resets it to locked and returns.  The "
":meth:`~Lock.release` method should only be called in the locked state; it "
"changes the state to unlocked and returns immediately. If an attempt is made"
" to release an unlocked lock, a :exc:`RuntimeError` will be raised."
msgstr ""
"Ett primitivt lås är i ett av två tillstånd, \"låst\" eller \"olåst\". Det "
"skapas i det olåsta tillståndet.  Det har två grundläggande metoder, "
":meth:`~Lock.acquire` och :meth:`~Lock.release`.  När tillståndet är upplåst"
" ändrar :meth:`~Lock.acquire` tillståndet till locked och återgår "
"omedelbart.  När tillståndet är locked blockerar :meth:`~Lock.acquire` tills"
" ett anrop till :meth:`~Lock.release` i en annan tråd ändrar det till "
"unlocked, då återställer anropet till :meth:`~Lock.acquire` det till locked "
"och returnerar.  Metoden :meth:`~Lock.release` bör endast anropas i låst "
"tillstånd; den ändrar tillståndet till olåst och returnerar omedelbart. Om "
"ett försök görs att frigöra ett olåst lås, kommer ett :exc:`RuntimeError` "
"att uppstå."

#: ../../library/threading.rst:482
msgid ""
"Locks also support the :ref:`context management protocol <with-locks>`."
msgstr "Lås stöder också :ref:``context management protocol <with-locks>``."

#: ../../library/threading.rst:484
msgid ""
"When more than one thread is blocked in :meth:`~Lock.acquire` waiting for "
"the state to turn to unlocked, only one thread proceeds when a "
":meth:`~Lock.release` call resets the state to unlocked; which one of the "
"waiting threads proceeds is not defined, and may vary across "
"implementations."
msgstr ""
"När mer än en tråd är blockerad i :meth:`~Lock.acquire` i väntan på att "
"tillståndet ska övergå till olåst, fortsätter endast en tråd när ett anrop "
"av :meth:`~Lock.release` återställer tillståndet till olåst; vilken av de "
"väntande trådarna som fortsätter är inte definierat och kan variera mellan "
"olika implementationer."

#: ../../library/threading.rst:489
msgid "All methods are executed atomically."
msgstr "Alla metoder utförs atomiskt."

#: ../../library/threading.rst:494
msgid ""
"The class implementing primitive lock objects.  Once a thread has acquired a"
" lock, subsequent attempts to acquire it block, until it is released; any "
"thread may release it."
msgstr ""
"Klassen som implementerar primitiva låsobjekt.  När en tråd har förvärvat "
"ett lås blockeras efterföljande försök att förvärva det tills det släpps; "
"vilken tråd som helst kan släppa det."

#: ../../library/threading.rst:498
msgid ""
"Note that ``Lock`` is actually a factory function which returns an instance "
"of the most efficient version of the concrete Lock class that is supported "
"by the platform."
msgstr ""

#: ../../library/threading.rst:505 ../../library/threading.rst:585
msgid "Acquire a lock, blocking or non-blocking."
msgstr "Förvärva ett lås, blockerande eller icke-blockerande."

#: ../../library/threading.rst:507
msgid ""
"When invoked with the *blocking* argument set to ``True`` (the default), "
"block until the lock is unlocked, then set it to locked and return ``True``."
msgstr ""
"När den anropas med argumentet *blocking* satt till ``True`` (standard), "
"blockeras den tills låset låses upp, sedan sätts den till locked och "
"returnerar ``True``."

#: ../../library/threading.rst:510
msgid ""
"When invoked with the *blocking* argument set to ``False``, do not block. If"
" a call with *blocking* set to ``True`` would block, return ``False`` "
"immediately; otherwise, set the lock to locked and return ``True``."
msgstr ""
"Blockera inte när anropet görs med argumentet *blocking* satt till "
"``False``. Om ett anrop med *blocking* satt till ``True`` skulle blockera, "
"returnera ``False`` omedelbart; i annat fall, sätt låset till locked och "
"returnera ``True``."

#: ../../library/threading.rst:514
msgid ""
"When invoked with the floating-point *timeout* argument set to a positive "
"value, block for at most the number of seconds specified by *timeout* and as"
" long as the lock cannot be acquired.  A *timeout* argument of ``-1`` "
"specifies an unbounded wait.  It is forbidden to specify a *timeout* when "
"*blocking* is ``False``."
msgstr ""
"När *timeout* anropas med ett positivt värde för argumentet med flyttal, "
"blockeras blockeringen i högst det antal sekunder som anges av *timeout* och"
" så länge som låset inte kan förvärvas.  Ett *timeout*-argument på ``-1`` "
"anger en obegränsad väntan.  Det är förbjudet att ange en *timeout* när "
"*blocking* är ``False``."

#: ../../library/threading.rst:520
msgid ""
"The return value is ``True`` if the lock is acquired successfully, ``False``"
" if not (for example if the *timeout* expired)."
msgstr ""
"Returvärdet är ``True`` om låset har förvärvats framgångsrikt, ``False`` om "
"inte (t.ex. om *timeout* har löpt ut)."

#: ../../library/threading.rst:523 ../../library/threading.rst:607
#: ../../library/threading.rst:854
msgid "The *timeout* parameter is new."
msgstr "Parametern *timeout* är ny."

#: ../../library/threading.rst:526
msgid ""
"Lock acquisition can now be interrupted by signals on POSIX if the "
"underlying threading implementation supports it."
msgstr ""
"Låsinhämtning kan nu avbrytas av signaler på POSIX om den underliggande "
"trådningsimplementationen stöder det."

#: ../../library/threading.rst:533
msgid ""
"Release a lock.  This can be called from any thread, not only the thread "
"which has acquired the lock."
msgstr ""
"Frigör ett lås.  Detta kan anropas från vilken tråd som helst, inte bara "
"från den tråd som har förvärvat låset."

#: ../../library/threading.rst:536
msgid ""
"When the lock is locked, reset it to unlocked, and return.  If any other "
"threads are blocked waiting for the lock to become unlocked, allow exactly "
"one of them to proceed."
msgstr ""
"När låset är låst återställer du det till olåst och återvänder.  Om några "
"andra trådar är blockerade i väntan på att låset ska låsas upp, tillåter du "
"att exakt en av dem fortsätter."

#: ../../library/threading.rst:540
msgid "When invoked on an unlocked lock, a :exc:`RuntimeError` is raised."
msgstr "När den anropas på ett olåst lås uppstår ett :exc:`RuntimeError`."

#: ../../library/threading.rst:542 ../../library/threading.rst:623
msgid "There is no return value."
msgstr "Det finns inget returvärde."

#: ../../library/threading.rst:546
msgid "Return ``True`` if the lock is acquired."
msgstr "Returnerar ``True`` om låset är förvärvat."

#: ../../library/threading.rst:553
msgid "RLock Objects"
msgstr ""

#: ../../library/threading.rst:555
msgid ""
"A reentrant lock is a synchronization primitive that may be acquired "
"multiple times by the same thread.  Internally, it uses the concepts of "
"\"owning thread\" and \"recursion level\" in addition to the locked/unlocked"
" state used by primitive locks.  In the locked state, some thread owns the "
"lock; in the unlocked state, no thread owns it."
msgstr ""
"Ett reentrant lås är en synkroniseringsprimitiv som kan förvärvas flera "
"gånger av samma tråd.  Internt använder det koncepten \"ägande tråd\" och "
"\"rekursionsnivå\" utöver det låsta/olåsta tillstånd som används av "
"primitiva lås.  I låst tillstånd äger någon tråd låset; i olåst tillstånd "
"äger ingen tråd det."

#: ../../library/threading.rst:561
msgid ""
"To lock the lock, a thread calls its :meth:`~RLock.acquire` method; this "
"returns once the thread owns the lock.  To unlock the lock, a thread calls "
"its :meth:`~Lock.release` method. "
":meth:`~Lock.acquire`/:meth:`~Lock.release` call pairs may be nested; only "
"the final :meth:`~Lock.release` (the :meth:`~Lock.release` of the outermost "
"pair) resets the lock to unlocked and allows another thread blocked in "
":meth:`~Lock.acquire` to proceed."
msgstr ""

#: ../../library/threading.rst:568
msgid ""
"Reentrant locks also support the :ref:`context management protocol <with-"
"locks>`."
msgstr ""

#: ../../library/threading.rst:573
msgid ""
"This class implements reentrant lock objects.  A reentrant lock must be "
"released by the thread that acquired it.  Once a thread has acquired a "
"reentrant lock, the same thread may acquire it again without blocking; the "
"thread must release it once for each time it has acquired it."
msgstr ""
"Denna klass implementerar objekt med återkommande lås.  Ett reentrant lås "
"måste släppas av den tråd som förvärvade det.  När en tråd har förvärvat ett"
" reentrant lås kan samma tråd förvärva det igen utan att blockera; tråden "
"måste släppa det en gång för varje gång den har förvärvat det."

#: ../../library/threading.rst:578
msgid ""
"Note that ``RLock`` is actually a factory function which returns an instance"
" of the most efficient version of the concrete RLock class that is supported"
" by the platform."
msgstr ""
"Observera att ``RLock`` faktiskt är en fabriksfunktion som returnerar en "
"instans av den mest effektiva versionen av den konkreta RLock-klassen som "
"stöds av plattformen."

#: ../../library/threading.rst:587
msgid ""
"When invoked without arguments: if this thread already owns the lock, "
"increment the recursion level by one, and return immediately.  Otherwise, if"
" another thread owns the lock, block until the lock is unlocked.  Once the "
"lock is unlocked (not owned by any thread), then grab ownership, set the "
"recursion level to one, and return.  If more than one thread is blocked "
"waiting until the lock is unlocked, only one at a time will be able to grab "
"ownership of the lock. There is no return value in this case."
msgstr ""

#: ../../library/threading.rst:595
msgid ""
"When invoked with the *blocking* argument set to ``True``, do the same thing"
" as when called without arguments, and return ``True``."
msgstr ""

#: ../../library/threading.rst:598
msgid ""
"When invoked with the *blocking* argument set to ``False``, do not block.  "
"If a call without an argument would block, return ``False`` immediately; "
"otherwise, do the same thing as when called without arguments, and return "
"``True``."
msgstr ""

#: ../../library/threading.rst:602
msgid ""
"When invoked with the floating-point *timeout* argument set to a positive "
"value, block for at most the number of seconds specified by *timeout* and as"
" long as the lock cannot be acquired.  Return ``True`` if the lock has been "
"acquired, ``False`` if the timeout has elapsed."
msgstr ""

#: ../../library/threading.rst:613
msgid ""
"Release a lock, decrementing the recursion level.  If after the decrement it"
" is zero, reset the lock to unlocked (not owned by any thread), and if any "
"other threads are blocked waiting for the lock to become unlocked, allow "
"exactly one of them to proceed.  If after the decrement the recursion level "
"is still nonzero, the lock remains locked and owned by the calling thread."
msgstr ""
"Frigör ett lås och dekrementera rekursionsnivån.  Om den efter "
"dekrementeringen är noll, återställ låset till olåst (ägs inte av någon "
"tråd), och om några andra trådar är blockerade i väntan på att låset ska bli"
" olåst, låt exakt en av dem fortsätta.  Om rekursionsnivån fortfarande inte "
"är noll efter dekrementeringen förblir låset låst och ägs av den anropande "
"tråden."

#: ../../library/threading.rst:619
msgid ""
"Only call this method when the calling thread owns the lock. A "
":exc:`RuntimeError` is raised if this method is called when the lock is "
"unlocked."
msgstr ""

#: ../../library/threading.rst:629
msgid "Condition Objects"
msgstr ""

#: ../../library/threading.rst:631
msgid ""
"A condition variable is always associated with some kind of lock; this can "
"be passed in or one will be created by default.  Passing one in is useful "
"when several condition variables must share the same lock.  The lock is part"
" of the condition object: you don't have to track it separately."
msgstr ""
"En villkorsvariabel är alltid associerad med någon form av lås; detta kan "
"anges eller så skapas ett som standard.  Att skicka in ett lås är användbart"
" när flera villkorsvariabler måste dela på samma lås.  Låset är en del av "
"villkorsobjektet: du behöver inte spåra det separat."

#: ../../library/threading.rst:636
msgid ""
"A condition variable obeys the :ref:`context management protocol <with-"
"locks>`: using the ``with`` statement acquires the associated lock for the "
"duration of the enclosed block.  The :meth:`~Condition.acquire` and "
":meth:`~Condition.release` methods also call the corresponding methods of "
"the associated lock."
msgstr ""
"En villkorsvariabel följer :ref:`context management protocol <with-locks>`: "
"genom att använda ``with``-satsen förvärvas det associerade låset under hela"
" det inneslutna blocket.  Metoderna :meth:`~Condition.acquire` och "
":meth:`~Condition.release` anropar också motsvarande metoder för det "
"associerade låset."

#: ../../library/threading.rst:642
msgid ""
"Other methods must be called with the associated lock held.  The "
":meth:`~Condition.wait` method releases the lock, and then blocks until "
"another thread awakens it by calling :meth:`~Condition.notify` or "
":meth:`~Condition.notify_all`.  Once awakened, :meth:`~Condition.wait` re-"
"acquires the lock and returns.  It is also possible to specify a timeout."
msgstr ""
"Andra metoder måste anropas med det associerade låset kvar.  Metoden "
":meth:`~Condition.wait` frigör låset och blockerar sedan tills en annan tråd"
" väcker det genom att anropa :meth:`~Condition.notify` eller "
":meth:`~Condition.notify_all`.  När den har väckts återtar "
":meth:`~Condition.wait` låset och återgår.  Det är också möjligt att ange en"
" timeout."

#: ../../library/threading.rst:648
msgid ""
"The :meth:`~Condition.notify` method wakes up one of the threads waiting for"
" the condition variable, if any are waiting.  The "
":meth:`~Condition.notify_all` method wakes up all threads waiting for the "
"condition variable."
msgstr ""
"Metoden :meth:`~Condition.notify` väcker en av de trådar som väntar på "
"villkorsvariabeln, om det finns några som väntar.  Metoden "
":meth:`~Condition.notify_all` väcker alla trådar som väntar på "
"villkorsvariabeln."

#: ../../library/threading.rst:652
msgid ""
"Note: the :meth:`~Condition.notify` and :meth:`~Condition.notify_all` "
"methods don't release the lock; this means that the thread or threads "
"awakened will not return from their :meth:`~Condition.wait` call "
"immediately, but only when the thread that called :meth:`~Condition.notify` "
"or :meth:`~Condition.notify_all` finally relinquishes ownership of the lock."
msgstr ""
"Observera: metoderna :meth:`~Condition.notify` och "
":meth:`~Condition.notify_all` frigör inte låset; detta innebär att den tråd "
"eller de trådar som väcks inte kommer att återvända från sitt anrop av "
":meth:`~Condition.wait` omedelbart, utan först när den tråd som anropade "
":meth:`~Condition.notify` eller :meth:`~Condition.notify_all` slutligen "
"släpper äganderätten till låset."

#: ../../library/threading.rst:658
msgid ""
"The typical programming style using condition variables uses the lock to "
"synchronize access to some shared state; threads that are interested in a "
"particular change of state call :meth:`~Condition.wait` repeatedly until "
"they see the desired state, while threads that modify the state call "
":meth:`~Condition.notify` or :meth:`~Condition.notify_all` when they change "
"the state in such a way that it could possibly be a desired state for one of"
" the waiters.  For example, the following code is a generic producer-"
"consumer situation with unlimited buffer capacity::"
msgstr ""
"Den typiska programmeringsstilen som använder villkorsvariabler använder "
"låset för att synkronisera åtkomst till ett delat tillstånd; trådar som är "
"intresserade av en viss förändring av tillståndet anropar "
":meth:`~Condition.wait` upprepade gånger tills de ser det önskade "
"tillståndet, medan trådar som ändrar tillståndet anropar "
":meth:`~Condition.notify` eller :meth:`~Condition.notify_all` när de ändrar "
"tillståndet på ett sådant sätt att det möjligen kan vara ett önskat "
"tillstånd för en av de väntande.  Följande kod är till exempel en generisk "
"producent-konsument-situation med obegränsad buffertkapacitet::"

#: ../../library/threading.rst:678
msgid ""
"The ``while`` loop checking for the application's condition is necessary "
"because :meth:`~Condition.wait` can return after an arbitrary long time, and"
" the condition which prompted the :meth:`~Condition.notify` call may no "
"longer hold true.  This is inherent to multi-threaded programming.  The "
":meth:`~Condition.wait_for` method can be used to automate the condition "
"checking, and eases the computation of timeouts::"
msgstr ""
"``while``-loopen som kontrollerar applikationens villkor är nödvändig "
"eftersom :meth:`~Condition.wait` kan returneras efter godtyckligt lång tid "
"och det villkor som föranledde :meth:`~Condition.notify`-anropet kanske inte"
" längre är sant.  Detta är inbyggt i programmering med flera trådar.  "
"Metoden :meth:`~Condition.wait_for` kan användas för att automatisera "
"villkorskontrollen och underlättar beräkningen av timeouts::"

#: ../../library/threading.rst:690
msgid ""
"To choose between :meth:`~Condition.notify` and "
":meth:`~Condition.notify_all`, consider whether one state change can be "
"interesting for only one or several waiting threads.  E.g. in a typical "
"producer-consumer situation, adding one item to the buffer only needs to "
"wake up one consumer thread."
msgstr ""
"För att välja mellan :meth:`~Condition.notify` och "
":meth:`~Condition.notify_all` bör du överväga om en tillståndsändring kan "
"vara intressant för endast en eller flera väntande trådar.  I en typisk "
"producent-konsument-situation behöver t.ex. en konsumenttråd bara väckas om "
"ett objekt läggs till i bufferten."

#: ../../library/threading.rst:698
msgid ""
"This class implements condition variable objects.  A condition variable "
"allows one or more threads to wait until they are notified by another "
"thread."
msgstr ""
"Denna klass implementerar objekt för villkorsvariabler.  En villkorsvariabel"
" tillåter en eller flera trådar att vänta tills de får ett meddelande från "
"en annan tråd."

#: ../../library/threading.rst:701
msgid ""
"If the *lock* argument is given and not ``None``, it must be a :class:`Lock`"
" or :class:`RLock` object, and it is used as the underlying lock.  "
"Otherwise, a new :class:`RLock` object is created and used as the underlying"
" lock."
msgstr ""
"Om argumentet *lock* anges och inte ``None``, måste det vara ett "
":class:`Lock`- eller :class:`RLock`-objekt, och det används som "
"underliggande lås.  Annars skapas ett nytt :class:`RLock`-objekt som används"
" som det underliggande låset."

#: ../../library/threading.rst:705 ../../library/threading.rst:829
#: ../../library/threading.rst:875 ../../library/threading.rst:927
#: ../../library/threading.rst:998
msgid "changed from a factory function to a class."
msgstr "ändrades från en fabriksfunktion till en klass."

#: ../../library/threading.rst:710
msgid ""
"Acquire the underlying lock. This method calls the corresponding method on "
"the underlying lock; the return value is whatever that method returns."
msgstr ""
"Förvärva det underliggande låset. Denna metod anropar motsvarande metod på "
"det underliggande låset; returvärdet är vad den metoden returnerar."

#: ../../library/threading.rst:715
msgid ""
"Release the underlying lock. This method calls the corresponding method on "
"the underlying lock; there is no return value."
msgstr ""
"Frigör det underliggande låset. Denna metod anropar motsvarande metod på det"
" underliggande låset; det finns inget returvärde."

#: ../../library/threading.rst:720
msgid ""
"Wait until notified or until a timeout occurs. If the calling thread has not"
" acquired the lock when this method is called, a :exc:`RuntimeError` is "
"raised."
msgstr ""
"Vänta tills du blir meddelad eller tills en timeout inträffar. Om den "
"anropande tråden inte har förvärvat låset när denna metod anropas, kommer "
"ett :exc:`RuntimeError` att uppstå."

#: ../../library/threading.rst:724
msgid ""
"This method releases the underlying lock, and then blocks until it is "
"awakened by a :meth:`notify` or :meth:`notify_all` call for the same "
"condition variable in another thread, or until the optional timeout occurs."
"  Once awakened or timed out, it re-acquires the lock and returns."
msgstr ""
"Denna metod frigör det underliggande låset och blockerar sedan tills den "
"väcks av ett :meth:`notify`- eller :meth:`notify_all`-anrop för samma "
"tillståndsvariabel i en annan tråd, eller tills den valfria timeouten "
"inträffar.  När den har väckts eller fått timeout återtar den låset och "
"återvänder."

#: ../../library/threading.rst:729
msgid ""
"When the *timeout* argument is present and not ``None``, it should be a "
"floating point number specifying a timeout for the operation in seconds (or "
"fractions thereof)."
msgstr ""

#: ../../library/threading.rst:733
msgid ""
"When the underlying lock is an :class:`RLock`, it is not released using its "
":meth:`release` method, since this may not actually unlock the lock when it "
"was acquired multiple times recursively.  Instead, an internal interface of "
"the :class:`RLock` class is used, which really unlocks it even when it has "
"been recursively acquired several times. Another internal interface is then "
"used to restore the recursion level when the lock is reacquired."
msgstr ""
"När det underliggande låset är ett :class:`RLock` frigörs det inte med hjälp"
" av dess :meth:`release`-metod, eftersom detta kanske inte låser upp låset "
"när det har förvärvats flera gånger rekursivt.  Istället används ett internt"
" gränssnitt för klassen :class:`RLock`, som verkligen låser upp det även om "
"det har förvärvats rekursivt flera gånger. Ett annat internt gränssnitt "
"används sedan för att återställa rekursionsnivån när låset förvärvas på "
"nytt."

#: ../../library/threading.rst:741
msgid ""
"The return value is ``True`` unless a given *timeout* expired, in which case"
" it is ``False``."
msgstr ""
"Returvärdet är ``True`` om inte en given *timeout* har löpt ut, i vilket "
"fall det är ``False``."

#: ../../library/threading.rst:744 ../../library/threading.rst:963
msgid "Previously, the method always returned ``None``."
msgstr "Tidigare returnerade metoden alltid ``None``."

#: ../../library/threading.rst:749
msgid ""
"Wait until a condition evaluates to true.  *predicate* should be a callable "
"which result will be interpreted as a boolean value. A *timeout* may be "
"provided giving the maximum time to wait."
msgstr ""
"Vänta tills ett villkor utvärderas till sant.  *predicate* ska vara en "
"callable vars resultat kommer att tolkas som ett booleskt värde. En "
"*timeout* kan anges som ger den maximala tiden att vänta."

#: ../../library/threading.rst:753
msgid ""
"This utility method may call :meth:`wait` repeatedly until the predicate is "
"satisfied, or until a timeout occurs. The return value is the last return "
"value of the predicate and will evaluate to ``False`` if the method timed "
"out."
msgstr ""
"Denna verktygsmetod kan anropa :meth:`wait` upprepade gånger tills "
"predikatet är uppfyllt eller tills en timeout inträffar. Returvärdet är det "
"sista returvärdet för predikatet och kommer att utvärderas till ``False`` om"
" metoden tidsavbröts."

#: ../../library/threading.rst:758
msgid ""
"Ignoring the timeout feature, calling this method is roughly equivalent to "
"writing::"
msgstr ""
"Om man bortser från timeout-funktionen motsvarar anrop av denna metod "
"ungefär att skriva::"

#: ../../library/threading.rst:764
msgid ""
"Therefore, the same rules apply as with :meth:`wait`: The lock must be held "
"when called and is re-acquired on return.  The predicate is evaluated with "
"the lock held."
msgstr ""
"Därför gäller samma regler som för :meth:`wait`: Låset måste hållas när det "
"anropas och återfås när det returneras.  Predikatet utvärderas med låset "
"kvar."

#: ../../library/threading.rst:772
msgid ""
"By default, wake up one thread waiting on this condition, if any.  If the "
"calling thread has not acquired the lock when this method is called, a "
":exc:`RuntimeError` is raised."
msgstr ""
"Som standard väcks en tråd som väntar på detta villkor, om det finns någon."
"  Om den anropande tråden inte har förvärvat låset när denna metod anropas, "
"kommer ett :exc:`RuntimeError` att uppstå."

#: ../../library/threading.rst:776
msgid ""
"This method wakes up at most *n* of the threads waiting for the condition "
"variable; it is a no-op if no threads are waiting."
msgstr ""
"Den här metoden väcker högst *n* av de trådar som väntar på "
"villkorvariabeln; den är ingen operation om inga trådar väntar."

#: ../../library/threading.rst:779
msgid ""
"The current implementation wakes up exactly *n* threads, if at least *n* "
"threads are waiting.  However, it's not safe to rely on this behavior. A "
"future, optimized implementation may occasionally wake up more than *n* "
"threads."
msgstr ""
"Den nuvarande implementationen väcker exakt *n* trådar om minst *n* trådar "
"väntar.  Det är dock inte säkert att förlita sig på detta beteende. En "
"framtida, optimerad implementering kan ibland väcka fler än *n* trådar."

#: ../../library/threading.rst:784
msgid ""
"Note: an awakened thread does not actually return from its :meth:`wait` call"
" until it can reacquire the lock.  Since :meth:`notify` does not release the"
" lock, its caller should."
msgstr ""
"Notera: en väckt tråd återvänder inte från sitt :meth:`wait`-anrop förrän "
"den kan återta låset.  Eftersom :meth:`notify` inte släpper låset, bör dess "
"anropare göra det."

#: ../../library/threading.rst:790
msgid ""
"Wake up all threads waiting on this condition.  This method acts like "
":meth:`notify`, but wakes up all waiting threads instead of one. If the "
"calling thread has not acquired the lock when this method is called, a "
":exc:`RuntimeError` is raised."
msgstr ""
"Väck alla trådar som väntar på detta villkor.  Denna metod fungerar som "
":meth:`notify`, men väcker alla väntande trådar istället för en. Om den "
"anropande tråden inte har förvärvat låset när denna metod anropas, kommer "
"ett :exc:`RuntimeError` att uppstå."

#: ../../library/threading.rst:795
msgid "The method ``notifyAll`` is a deprecated alias for this method."
msgstr "Metoden ``notifyAll`` är ett föråldrat alias för denna metod."

#: ../../library/threading.rst:801
msgid "Semaphore Objects"
msgstr ""

#: ../../library/threading.rst:803
msgid ""
"This is one of the oldest synchronization primitives in the history of "
"computer science, invented by the early Dutch computer scientist Edsger W. "
"Dijkstra (he used the names ``P()`` and ``V()`` instead of "
":meth:`~Semaphore.acquire` and :meth:`~Semaphore.release`)."
msgstr ""
"Detta är en av de äldsta synkroniseringsprimitiverna i datavetenskapens "
"historia, uppfunnen av den tidiga holländska datavetaren Edsger W. Dijkstra "
"(han använde namnen ``P()`` och ``V()`` istället för "
":meth:`~Semaphore.acquire` och :meth:`~Semaphore.release`)."

#: ../../library/threading.rst:808
msgid ""
"A semaphore manages an internal counter which is decremented by each "
":meth:`~Semaphore.acquire` call and incremented by each "
":meth:`~Semaphore.release` call.  The counter can never go below zero; when "
":meth:`~Semaphore.acquire` finds that it is zero, it blocks, waiting until "
"some other thread calls :meth:`~Semaphore.release`."
msgstr ""
"En semafor hanterar en intern räknare som decimeras vid varje anrop av "
":meth:`~Semaphore.acquire` och ökas vid varje anrop av "
":meth:`~Semaphore.release`.  Räknaren kan aldrig gå under noll; när "
":meth:`~Semaphore.acquire` upptäcker att den är noll blockerar den och "
"väntar tills någon annan tråd anropar :meth:`~Semaphore.release`."

#: ../../library/threading.rst:814
msgid ""
"Semaphores also support the :ref:`context management protocol <with-locks>`."
msgstr ""
"Semaforer stöder också :ref:``context management protocol <with-locks>``."

#: ../../library/threading.rst:819
msgid ""
"This class implements semaphore objects.  A semaphore manages an atomic "
"counter representing the number of :meth:`release` calls minus the number of"
" :meth:`acquire` calls, plus an initial value.  The :meth:`acquire` method "
"blocks if necessary until it can return without making the counter negative."
" If not given, *value* defaults to 1."
msgstr ""
"Denna klass implementerar semaforobjekt.  En semafor hanterar en atomisk "
"räknare som representerar antalet :meth:`release`-anrop minus antalet "
":meth:`acquire`-anrop, plus ett initialt värde.  Metoden :meth:`acquire` "
"blockerar om det behövs tills den kan återvända utan att räknaren blir "
"negativ. Om *value* inte anges är standardvärdet 1."

#: ../../library/threading.rst:825
msgid ""
"The optional argument gives the initial *value* for the internal counter; it"
" defaults to ``1``. If the *value* given is less than 0, :exc:`ValueError` "
"is raised."
msgstr ""
"Det valfria argumentet anger det initiala *värdet* för den interna räknaren;"
" standardvärdet är ``1``. Om det angivna *värdet* är mindre än 0, uppstår "
":exc:`ValueError`."

#: ../../library/threading.rst:834
msgid "Acquire a semaphore."
msgstr "Förvärva en semafor."

#: ../../library/threading.rst:836
msgid "When invoked without arguments:"
msgstr "När den anropas utan argument:"

#: ../../library/threading.rst:838
msgid ""
"If the internal counter is larger than zero on entry, decrement it by one "
"and return ``True`` immediately."
msgstr ""
"Om den interna räknaren är större än noll vid inmatningen, dekrementera den "
"med ett och returnera ``True`` omedelbart."

#: ../../library/threading.rst:840
msgid ""
"If the internal counter is zero on entry, block until awoken by a call to "
":meth:`~Semaphore.release`.  Once awoken (and the counter is greater than "
"0), decrement the counter by 1 and return ``True``.  Exactly one thread will"
" be awoken by each call to :meth:`~Semaphore.release`.  The order in which "
"threads are awoken should not be relied on."
msgstr ""
"Om den interna räknaren är noll vid inmatningen, blockera tills den väcks "
"genom ett anrop till :meth:`~Semaphore.release`.  När du har väckts (och "
"räknaren är större än 0), dekrementera räknaren med 1 och returnera "
"``True``.  Exakt en tråd kommer att väckas vid varje anrop till "
":meth:`~Semaphore.release`.  Ordningen i vilken trådarna väcks bör inte "
"förlitas på."

#: ../../library/threading.rst:846
msgid ""
"When invoked with *blocking* set to ``False``, do not block.  If a call "
"without an argument would block, return ``False`` immediately; otherwise, do"
" the same thing as when called without arguments, and return ``True``."
msgstr ""
"Blockera inte när den anropas med *blocking* satt till ``False``.  Om ett "
"anrop utan argument skulle blockera, returnera ``False`` omedelbart; i annat"
" fall, gör samma sak som vid anrop utan argument och returnera ``True``."

#: ../../library/threading.rst:850
msgid ""
"When invoked with a *timeout* other than ``None``, it will block for at most"
" *timeout* seconds.  If acquire does not complete successfully in that "
"interval, return ``False``.  Return ``True`` otherwise."
msgstr ""
"När den anropas med en *timeout* annan än ``None``, kommer den att blockera "
"i högst *timeout* sekunder.  Om förvärvet inte slutförs framgångsrikt inom "
"detta intervall returneras ``False``.  Returnera annars ``True``."

#: ../../library/threading.rst:859
msgid ""
"Release a semaphore, incrementing the internal counter by *n*.  When it was "
"zero on entry and other threads are waiting for it to become larger than "
"zero again, wake up *n* of those threads."
msgstr ""
"Släpp en semafor och öka den interna räknaren med *n*.  När den var noll vid"
" inmatningen och andra trådar väntar på att den ska bli större än noll igen,"
" väcker du *n* av dessa trådar."

#: ../../library/threading.rst:863
msgid "Added the *n* parameter to release multiple waiting threads at once."
msgstr ""
"Lagt till parametern *n* för att släppa flera väntande trådar samtidigt."

#: ../../library/threading.rst:869
msgid ""
"Class implementing bounded semaphore objects.  A bounded semaphore checks to"
" make sure its current value doesn't exceed its initial value.  If it does, "
":exc:`ValueError` is raised. In most situations semaphores are used to guard"
" resources with limited capacity.  If the semaphore is released too many "
"times it's a sign of a bug.  If not given, *value* defaults to 1."
msgstr ""
"Klass som implementerar begränsade semaforobjekt.  En bounded semaphore "
"kontrollerar att dess aktuella värde inte överstiger dess initiala värde.  "
"Om så är fallet, genereras :exc:`ValueError`. I de flesta situationer "
"används semaforer för att bevaka resurser med begränsad kapacitet.  Om "
"semaforen släpps för många gånger är det ett tecken på en bugg.  Om *värde* "
"inte anges är standardvärdet 1."

#: ../../library/threading.rst:882
msgid ":class:`Semaphore` Example"
msgstr ""

#: ../../library/threading.rst:884
msgid ""
"Semaphores are often used to guard resources with limited capacity, for "
"example, a database server.  In any situation where the size of the resource"
" is fixed, you should use a bounded semaphore.  Before spawning any worker "
"threads, your main thread would initialize the semaphore::"
msgstr ""
"Semaforer används ofta för att bevaka resurser med begränsad kapacitet, "
"t.ex. en databasserver.  I alla situationer där resursens storlek är fast "
"bör du använda en begränsad semafor.  Innan du skapar några arbetstrådar "
"skulle din huvudtråd initiera semaforen::"

#: ../../library/threading.rst:893
msgid ""
"Once spawned, worker threads call the semaphore's acquire and release "
"methods when they need to connect to the server::"
msgstr ""
"När de har skapats anropar arbetstrådarna semaforens metoder för att "
"förvärva och frigöra när de behöver ansluta till servern::"

#: ../../library/threading.rst:903
msgid ""
"The use of a bounded semaphore reduces the chance that a programming error "
"which causes the semaphore to be released more than it's acquired will go "
"undetected."
msgstr ""
"Användningen av en begränsad semafor minskar risken för att ett "
"programmeringsfel som gör att semaforen släpps mer än den förvärvas inte "
"upptäcks."

#: ../../library/threading.rst:910
msgid "Event Objects"
msgstr ""

#: ../../library/threading.rst:912
msgid ""
"This is one of the simplest mechanisms for communication between threads: "
"one thread signals an event and other threads wait for it."
msgstr ""
"Detta är en av de enklaste mekanismerna för kommunikation mellan trådar: en "
"tråd signalerar en händelse och andra trådar väntar på den."

#: ../../library/threading.rst:915
msgid ""
"An event object manages an internal flag that can be set to true with the "
":meth:`~Event.set` method and reset to false with the :meth:`~Event.clear` "
"method.  The :meth:`~Event.wait` method blocks until the flag is true."
msgstr ""
"Ett eventobjekt hanterar en intern flagga som kan sättas till true med "
"metoden :meth:`~Event.set` och återställas till false med metoden "
":meth:`~Event.clear`.  Metoden :meth:`~Event.wait` blockerar tills flaggan "
"är sann."

#: ../../library/threading.rst:922
msgid ""
"Class implementing event objects.  An event manages a flag that can be set "
"to true with the :meth:`~Event.set` method and reset to false with the "
":meth:`clear` method.  The :meth:`wait` method blocks until the flag is "
"true. The flag is initially false."
msgstr ""
"Klass som implementerar händelseobjekt.  En händelse hanterar en flagga som "
"kan sättas till true med metoden :meth:`~Event.set` och återställas till "
"false med metoden :meth:`clear`.  Metoden :meth:`wait` blockerar tills "
"flaggan är sann. Flaggan är initialt falsk."

#: ../../library/threading.rst:932
msgid "Return ``True`` if and only if the internal flag is true."
msgstr "Returnerar ``True`` om och endast om den interna flaggan är sann."

#: ../../library/threading.rst:934
msgid "The method ``isSet`` is a deprecated alias for this method."
msgstr "Metoden ``isSet`` är ett föråldrat alias för denna metod."

#: ../../library/threading.rst:938
msgid ""
"Set the internal flag to true. All threads waiting for it to become true are"
" awakened. Threads that call :meth:`wait` once the flag is true will not "
"block at all."
msgstr ""
"Sätt den interna flaggan till true. Alla trådar som väntar på att den ska "
"bli sann väcks. Trådar som anropar :meth:`wait` när flaggan är true kommer "
"inte att blockera alls."

#: ../../library/threading.rst:944
msgid ""
"Reset the internal flag to false. Subsequently, threads calling :meth:`wait`"
" will block until :meth:`.set` is called to set the internal flag to true "
"again."
msgstr ""
"Återställer den interna flaggan till false. Därefter kommer trådar som "
"anropar :meth:`wait` att blockeras tills :meth:`.set` anropas för att sätta "
"den interna flaggan till true igen."

#: ../../library/threading.rst:950
msgid ""
"Block until the internal flag is true.  If the internal flag is true on "
"entry, return immediately.  Otherwise, block until another thread calls "
":meth:`.set` to set the flag to true, or until the optional timeout occurs."
msgstr ""

#: ../../library/threading.rst:954
msgid ""
"When the timeout argument is present and not ``None``, it should be a "
"floating point number specifying a timeout for the operation in seconds (or "
"fractions thereof)."
msgstr ""

#: ../../library/threading.rst:958
msgid ""
"This method returns ``True`` if and only if the internal flag has been set "
"to true, either before the wait call or after the wait starts, so it will "
"always return ``True`` except if a timeout is given and the operation times "
"out."
msgstr ""

#: ../../library/threading.rst:970
msgid "Timer Objects"
msgstr ""

#: ../../library/threading.rst:972
msgid ""
"This class represents an action that should be run only after a certain "
"amount of time has passed --- a timer.  :class:`Timer` is a subclass of "
":class:`Thread` and as such also functions as an example of creating custom "
"threads."
msgstr ""
"Den här klassen representerar en åtgärd som ska utföras först efter att en "
"viss tid har gått --- en timer. :class:`Timer` är en underklass till "
":class:`Thread` och fungerar som sådan också som ett exempel på hur man "
"skapar egna trådar."

#: ../../library/threading.rst:976
msgid ""
"Timers are started, as with threads, by calling their :meth:`~Timer.start` "
"method.  The timer can be stopped (before its action has begun) by calling "
"the :meth:`~Timer.cancel` method.  The interval the timer will wait before "
"executing its action may not be exactly the same as the interval specified "
"by the user."
msgstr ""

#: ../../library/threading.rst:982
msgid "For example::"
msgstr "Till exempel::"

#: ../../library/threading.rst:993
msgid ""
"Create a timer that will run *function* with arguments *args* and  keyword "
"arguments *kwargs*, after *interval* seconds have passed. If *args* is "
"``None`` (the default) then an empty list will be used. If *kwargs* is "
"``None`` (the default) then an empty dict will be used."
msgstr ""
"Skapa en timer som kör *function* med argumenten *args* och "
"nyckelordsargumenten *kwargs*, efter att *interval* sekunder har passerat. "
"Om *args* är ``None`` (standard) kommer en tom lista att användas. Om "
"*kwargs* är ``None`` (standard) kommer en tom dict att användas."

#: ../../library/threading.rst:1003
msgid ""
"Stop the timer, and cancel the execution of the timer's action.  This will "
"only work if the timer is still in its waiting stage."
msgstr ""
"Stoppa timern och avbryt utförandet av timerns åtgärd.  Detta fungerar bara "
"om timern fortfarande befinner sig i vänteläge."

#: ../../library/threading.rst:1008
msgid "Barrier Objects"
msgstr ""

#: ../../library/threading.rst:1012
msgid ""
"This class provides a simple synchronization primitive for use by a fixed "
"number of threads that need to wait for each other.  Each of the threads "
"tries to pass the barrier by calling the :meth:`~Barrier.wait` method and "
"will block until all of the threads have made their :meth:`~Barrier.wait` "
"calls. At this point, the threads are released simultaneously."
msgstr ""
"Denna klass tillhandahåller en enkel synkroniseringsprimitiv för användning "
"av ett fast antal trådar som behöver vänta på varandra.  Var och en av "
"trådarna försöker passera barriären genom att anropa metoden "
":meth:`~Barrier.wait` och blockerar tills alla trådar har gjort sina anrop "
"till :meth:`~Barrier.wait`. Vid denna punkt släpps trådarna samtidigt."

#: ../../library/threading.rst:1018
msgid ""
"The barrier can be reused any number of times for the same number of "
"threads."
msgstr ""
"Barriären kan återanvändas ett obegränsat antal gånger för samma antal "
"trådar."

#: ../../library/threading.rst:1020
msgid ""
"As an example, here is a simple way to synchronize a client and server "
"thread::"
msgstr ""
"Som ett exempel följer här ett enkelt sätt att synkronisera en klient- och "
"servertråd::"

#: ../../library/threading.rst:1040
msgid ""
"Create a barrier object for *parties* number of threads.  An *action*, when "
"provided, is a callable to be called by one of the threads when they are "
"released.  *timeout* is the default timeout value if none is specified for "
"the :meth:`wait` method."
msgstr ""
"Skapa ett barriärobjekt för *parties* antal trådar.  En *action*, när den "
"tillhandahålls, är en callable som ska anropas av en av trådarna när de "
"släpps.  *timeout* är standardvärdet för timeout om inget anges för metoden "
":meth:`wait`."

#: ../../library/threading.rst:1047
msgid ""
"Pass the barrier.  When all the threads party to the barrier have called "
"this function, they are all released simultaneously.  If a *timeout* is "
"provided, it is used in preference to any that was supplied to the class "
"constructor."
msgstr ""
"Passera barriären.  När alla trådar som är parter i barriären har anropat "
"denna funktion släpps de samtidigt.  Om en *timeout* anges används den i "
"stället för den som angavs i klassens konstruktor."

#: ../../library/threading.rst:1052
msgid ""
"The return value is an integer in the range 0 to *parties* -- 1, different "
"for each thread.  This can be used to select a thread to do some special "
"housekeeping, e.g.::"
msgstr ""
"Returvärdet är ett heltal i intervallet 0 till *parties* -- 1, olika för "
"varje tråd.  Detta kan användas för att välja en tråd för att göra några "
"speciella hushållsarbeten, t.ex.::"

#: ../../library/threading.rst:1061
msgid ""
"If an *action* was provided to the constructor, one of the threads will have"
" called it prior to being released.  Should this call raise an error, the "
"barrier is put into the broken state."
msgstr ""
"Om en *action* tillhandahölls till konstruktören kommer en av trådarna att "
"ha anropat den innan den släpps.  Om detta anrop ger upphov till ett fel, "
"försätts barriären i det brutna tillståndet."

#: ../../library/threading.rst:1065
msgid "If the call times out, the barrier is put into the broken state."
msgstr "Om anropet tidsbegränsas försätts barriären i ett trasigt tillstånd."

#: ../../library/threading.rst:1067
msgid ""
"This method may raise a :class:`BrokenBarrierError` exception if the barrier"
" is broken or reset while a thread is waiting."
msgstr ""
"Denna metod kan ge upphov till ett :class:`BrokenBarrierError` undantag om "
"barriären bryts eller återställs medan en tråd väntar."

#: ../../library/threading.rst:1072
msgid ""
"Return the barrier to the default, empty state.  Any threads waiting on it "
"will receive the :class:`BrokenBarrierError` exception."
msgstr ""
"Återställer barriären till det tomma standardtillståndet.  Alla trådar som "
"väntar på den kommer att få undantaget :class:`BrokenBarrierError`."

#: ../../library/threading.rst:1075
msgid ""
"Note that using this function may require some external synchronization if "
"there are other threads whose state is unknown.  If a barrier is broken it "
"may be better to just leave it and create a new one."
msgstr ""
"Observera att denna funktion kan kräva viss extern synkronisering om det "
"finns andra trådar vars tillstånd är okänt.  Om en barriär bryts kan det "
"vara bättre att bara lämna den och skapa en ny."

#: ../../library/threading.rst:1081
msgid ""
"Put the barrier into a broken state.  This causes any active or future calls"
" to :meth:`wait` to fail with the :class:`BrokenBarrierError`.  Use this for"
" example if one of the threads needs to abort, to avoid deadlocking the "
"application."
msgstr ""
"Sätter barriären i ett trasigt tillstånd.  Detta gör att alla aktiva eller "
"framtida anrop till :meth:`wait` misslyckas med :class:`BrokenBarrierError`."
"  Använd detta till exempel om en av trådarna behöver avbrytas för att "
"undvika att applikationen låser sig."

#: ../../library/threading.rst:1086
msgid ""
"It may be preferable to simply create the barrier with a sensible *timeout* "
"value to automatically guard against one of the threads going awry."
msgstr ""
"Det kan vara att föredra att helt enkelt skapa barriären med ett vettigt "
"*timeout*-värde för att automatiskt skydda sig mot att en av trådarna går "
"fel."

#: ../../library/threading.rst:1092
msgid "The number of threads required to pass the barrier."
msgstr "Det antal trådar som krävs för att passera barriären."

#: ../../library/threading.rst:1096
msgid "The number of threads currently waiting in the barrier."
msgstr "Antalet trådar som för närvarande väntar i barriären."

#: ../../library/threading.rst:1100
msgid "A boolean that is ``True`` if the barrier is in the broken state."
msgstr "En boolean som är ``True`` om barriären är i ett trasigt tillstånd."

#: ../../library/threading.rst:1105
msgid ""
"This exception, a subclass of :exc:`RuntimeError`, is raised when the "
":class:`Barrier` object is reset or broken."
msgstr ""
"Detta undantag, en underklass till :exc:`RuntimeError`, uppstår när objektet"
" :class:`Barrier` återställs eller bryts."

#: ../../library/threading.rst:1112
msgid ""
"Using locks, conditions, and semaphores in the :keyword:`!with` statement"
msgstr "Använda lås, villkor och semaforer i :keyword:`!with`-satsen"

#: ../../library/threading.rst:1114
msgid ""
"All of the objects provided by this module that have :meth:`acquire` and "
":meth:`release` methods can be used as context managers for a "
":keyword:`with` statement.  The :meth:`acquire` method will be called when "
"the block is entered, and :meth:`release` will be called when the block is "
"exited.  Hence, the following snippet::"
msgstr ""

#: ../../library/threading.rst:1123
msgid "is equivalent to::"
msgstr "är likvärdig med::"

#: ../../library/threading.rst:1131
msgid ""
"Currently, :class:`Lock`, :class:`RLock`, :class:`Condition`, "
":class:`Semaphore`, and :class:`BoundedSemaphore` objects may be used as "
":keyword:`with` statement context managers."
msgstr ""
"För närvarande kan objekten :class:`Lock`, :class:`RLock`, "
":class:`Condition`, :class:`Semaphore` och :class:`BoundedSemaphore` "
"användas som :keyword:`with` statement context managers."
