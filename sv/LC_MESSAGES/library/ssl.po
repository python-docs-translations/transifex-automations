# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# python-doc bot, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-25 16:33+0000\n"
"PO-Revision-Date: 2025-09-22 16:50+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../library/ssl.rst:2
msgid ":mod:`ssl` --- TLS/SSL wrapper for socket objects"
msgstr ""

#: ../../library/ssl.rst:10
msgid "**Source code:** :source:`Lib/ssl.py`"
msgstr "**Källkod:** :source:`Lib/ssl.py`"

#: ../../library/ssl.rst:18
msgid ""
"This module provides access to Transport Layer Security (often known as "
"\"Secure Sockets Layer\") encryption and peer authentication facilities for "
"network sockets, both client-side and server-side.  This module uses the "
"OpenSSL library. It is available on all modern Unix systems, Windows, macOS,"
" and probably additional platforms, as long as OpenSSL is installed on that "
"platform."
msgstr ""
"Den här modulen ger tillgång till Transport Layer Security (ofta kallat "
"\"Secure Sockets Layer\") kryptering och peer authentication för "
"nätverksuttag, både på klient- och serversidan.  Den här modulen använder "
"OpenSSL-biblioteket. Det är tillgängligt på alla moderna Unix-system, "
"Windows, macOS och förmodligen ytterligare plattformar, så länge OpenSSL är "
"installerat på den plattformen."

#: ../../library/ssl.rst:26
msgid ""
"Some behavior may be platform dependent, since calls are made to the "
"operating system socket APIs.  The installed version of OpenSSL may also "
"cause variations in behavior. For example, TLSv1.3 comes with OpenSSL "
"version 1.1.1."
msgstr ""
"Vissa beteenden kan vara plattformsberoende, eftersom anrop görs till "
"operativsystemets socket-API:er.  Den installerade versionen av OpenSSL kan "
"också orsaka variationer i beteendet. TLSv1.3 levereras till exempel med "
"OpenSSL version 1.1.1."

#: ../../library/ssl.rst:32
msgid ""
"Don't use this module without reading the :ref:`ssl-security`.  Doing so may"
" lead to a false sense of security, as the default settings of the ssl "
"module are not necessarily appropriate for your application."
msgstr ""
"Använd inte den här modulen utan att läsa :ref:`ssl-security`.  Detta kan "
"leda till en falsk känsla av säkerhet, eftersom standardinställningarna för "
"ssl-modulen inte nödvändigtvis är lämpliga för din applikation."

#: ../../includes/wasm-notavail.rst:3
msgid ":ref:`Availability <availability>`: not Emscripten, not WASI."
msgstr ""

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly platforms "
"``wasm32-emscripten`` and ``wasm32-wasi``. See :ref:`wasm-availability` for "
"more information."
msgstr ""

#: ../../library/ssl.rst:38
msgid ""
"This section documents the objects and functions in the ``ssl`` module; for "
"more general information about TLS, SSL, and certificates, the reader is "
"referred to the documents in the \"See Also\" section at the bottom."
msgstr ""
"Detta avsnitt dokumenterar objekten och funktionerna i modulen ``ssl``; för "
"mer allmän information om TLS, SSL och certifikat hänvisas läsaren till "
"dokumenten i avsnittet \"Se även\" längst ned."

#: ../../library/ssl.rst:42
msgid ""
"This module provides a class, :class:`ssl.SSLSocket`, which is derived from "
"the :class:`socket.socket` type, and provides a socket-like wrapper that "
"also encrypts and decrypts the data going over the socket with SSL.  It "
"supports additional methods such as :meth:`getpeercert`, which retrieves the"
" certificate of the other side of the connection, and :meth:`cipher`, which "
"retrieves the cipher being used for the secure connection."
msgstr ""

#: ../../library/ssl.rst:49
msgid ""
"For more sophisticated applications, the :class:`ssl.SSLContext` class helps"
" manage settings and certificates, which can then be inherited by SSL "
"sockets created through the :meth:`SSLContext.wrap_socket` method."
msgstr ""
"För mer sofistikerade applikationer hjälper klassen :class:`ssl.SSLContext` "
"till att hantera inställningar och certifikat, som sedan kan ärvas av SSL-"
"uttag som skapas genom metoden :meth:`SSLContext.wrap_socket`."

#: ../../library/ssl.rst:53
msgid "Updated to support linking with OpenSSL 1.1.0"
msgstr "Uppdaterad för att stödja länkning med OpenSSL 1.1.0"

#: ../../library/ssl.rst:58
msgid ""
"OpenSSL 0.9.8, 1.0.0 and 1.0.1 are deprecated and no longer supported. In "
"the future the ssl module will require at least OpenSSL 1.0.2 or 1.1.0."
msgstr ""
"OpenSSL 0.9.8, 1.0.0 och 1.0.1 är föråldrade och stöds inte längre. I "
"framtiden kommer ssl-modulen att kräva minst OpenSSL 1.0.2 eller 1.1.0."

#: ../../library/ssl.rst:64
msgid ""
":pep:`644` has been implemented. The ssl module requires OpenSSL 1.1.1 or "
"newer."
msgstr ""
":pep:`644` har implementerats. Modulen ssl kräver OpenSSL 1.1.1 eller nyare."

#: ../../library/ssl.rst:67
msgid ""
"Use of deprecated constants and functions result in deprecation warnings."
msgstr ""
"Användning av föråldrade konstanter och funktioner resulterar i varningar om"
" föråldring."

#: ../../library/ssl.rst:71
msgid "Functions, Constants, and Exceptions"
msgstr "Funktioner, konstanter och undantag"

#: ../../library/ssl.rst:75
msgid "Socket creation"
msgstr "Skapande av uttag"

#: ../../library/ssl.rst:77
msgid ""
"Since Python 3.2 and 2.7.9, it is recommended to use the "
":meth:`SSLContext.wrap_socket` of an :class:`SSLContext` instance to wrap "
"sockets as :class:`SSLSocket` objects. The helper functions "
":func:`create_default_context` returns a new context with secure default "
"settings. The old :func:`wrap_socket` function is deprecated since it is "
"both inefficient and has no support for server name indication (SNI) and "
"hostname matching."
msgstr ""

#: ../../library/ssl.rst:85
msgid "Client socket example with default context and IPv4/IPv6 dual stack::"
msgstr "Exempel på klientuttag med standardkontext och IPv4/IPv6 dual stack::"

#: ../../library/ssl.rst:98
msgid "Client socket example with custom context and IPv4::"
msgstr "Exempel på klientuttag med anpassad kontext och IPv4::"

#: ../../library/ssl.rst:110
msgid "Server socket example listening on localhost IPv4::"
msgstr "Serveruttag exempel lyssnar på localhost IPv4::"

#: ../../library/ssl.rst:124
msgid "Context creation"
msgstr "Skapande av kontext"

#: ../../library/ssl.rst:126
msgid ""
"A convenience function helps create :class:`SSLContext` objects for common "
"purposes."
msgstr ""
"En bekvämlighetsfunktion som hjälper till att skapa "
":class:`SSLContext`\\-objekt för vanliga ändamål."

#: ../../library/ssl.rst:131
msgid ""
"Return a new :class:`SSLContext` object with default settings for the given "
"*purpose*.  The settings are chosen by the :mod:`ssl` module, and usually "
"represent a higher security level than when calling the :class:`SSLContext` "
"constructor directly."
msgstr ""
"Returnerar ett nytt :class:`SSLContext`\\-objekt med standardinställningar "
"för det angivna *syftet*.  Inställningarna väljs av modulen :mod:`ssl` och "
"representerar vanligtvis en högre säkerhetsnivå än när man anropar "
"konstruktören :class:`SSLContext` direkt."

#: ../../library/ssl.rst:136
msgid ""
"*cafile*, *capath*, *cadata* represent optional CA certificates to trust for"
" certificate verification, as in :meth:`SSLContext.load_verify_locations`.  "
"If all three are :const:`None`, this function can choose to trust the "
"system's default CA certificates instead."
msgstr ""
"*cafile*, *capath*, *cadata* representerar valfria CA-certifikat att lita på"
" för certifikatverifiering, som i :meth:`SSLContext.load_verify_locations`."
"  Om alla tre är :const:`None` kan den här funktionen välja att lita på "
"systemets standardcertifikat från CA i stället."

#: ../../library/ssl.rst:142
msgid ""
"The settings are: :data:`PROTOCOL_TLS_CLIENT` or "
":data:`PROTOCOL_TLS_SERVER`, :data:`OP_NO_SSLv2`, and :data:`OP_NO_SSLv3` "
"with high encryption cipher suites without RC4 and without unauthenticated "
"cipher suites. Passing :const:`~Purpose.SERVER_AUTH` as *purpose* sets "
":data:`~SSLContext.verify_mode` to :data:`CERT_REQUIRED` and either loads CA"
" certificates (when at least one of *cafile*, *capath* or *cadata* is given)"
" or uses :meth:`SSLContext.load_default_certs` to load default CA "
"certificates."
msgstr ""
"Inställningarna är: :data:`PROTOCOL_TLS_CLIENT` eller "
":data:`PROTOCOL_TLS_SERVER`, :data:`OP_NO_SSLv2` och :data:`OP_NO_SSLv3` med"
" chiffersviter med hög kryptering utan RC4 och utan oautentiserade "
"chiffersviter. Genom att ange :const:`~Purpose.SERVER_AUTH` som *purpose* "
"sätts :data:`~SSLContext.verify_mode` till :data:`CERT_REQUIRED` och "
"antingen laddas CA-certifikat (när minst en av *cafile*, *capath* eller "
"*cadata* anges) eller så används :meth:`SSLContext.load_default_certs` för "
"att ladda standard CA-certifikat."

#: ../../library/ssl.rst:151
msgid ""
"When :attr:`~SSLContext.keylog_filename` is supported and the environment "
"variable :envvar:`SSLKEYLOGFILE` is set, :func:`create_default_context` "
"enables key logging."
msgstr ""
"När :attr:`~SSLContext.keylog_filename` stöds och miljövariabeln "
":envvar:`SSLKEYLOGFILE` är inställd, aktiverar "
":func:`create_default_context` nyckelloggning."

#: ../../library/ssl.rst:156
msgid ""
"The protocol, options, cipher and other settings may change to more "
"restrictive values anytime without prior deprecation.  The values represent "
"a fair balance between compatibility and security."
msgstr ""
"Protokoll, alternativ, chiffer och andra inställningar kan ändras till mer "
"restriktiva värden när som helst utan föregående avskrivning.  Värdena "
"representerar en rättvis balans mellan kompatibilitet och säkerhet."

#: ../../library/ssl.rst:160
msgid ""
"If your application needs specific settings, you should create a "
":class:`SSLContext` and apply the settings yourself."
msgstr ""
"Om din applikation behöver specifika inställningar bör du skapa en "
":class:`SSLContext` och tillämpa inställningarna själv."

#: ../../library/ssl.rst:164
msgid ""
"If you find that when certain older clients or servers attempt to connect "
"with a :class:`SSLContext` created by this function that they get an error "
"stating \"Protocol or cipher suite mismatch\", it may be that they only "
"support SSL3.0 which this function excludes using the :data:`OP_NO_SSLv3`. "
"SSL3.0 is widely considered to be `completely broken "
"<https://en.wikipedia.org/wiki/POODLE>`_. If you still wish to continue to "
"use this function but still allow SSL 3.0 connections you can re-enable them"
" using::"
msgstr ""
"Om du upptäcker att när vissa äldre klienter eller servrar försöker ansluta "
"med en :class:`SSLContext` som skapats av den här funktionen får de "
"felmeddelandet \"Protocol or cipher suite mismatch\", kan det bero på att de"
" endast stöder SSL3.0 som den här funktionen utesluter med "
":data:`OP_NO_SSLv3`. SSL3.0 anses allmänt vara `helt trasigt "
"<https://en.wikipedia.org/wiki/POODLE>`_. Om du fortfarande vill fortsätta "
"att använda den här funktionen men ändå tillåta SSL 3.0-anslutningar kan du "
"återaktivera dem med hjälp av::"

#: ../../library/ssl.rst:180
msgid "RC4 was dropped from the default cipher string."
msgstr "RC4 togs bort från standardchiffersträngen."

#: ../../library/ssl.rst:184
msgid "ChaCha20/Poly1305 was added to the default cipher string."
msgstr "ChaCha20/Poly1305 har lagts till i standardchiffersträngen."

#: ../../library/ssl.rst:186
msgid "3DES was dropped from the default cipher string."
msgstr "3DES togs bort från standardchiffersträngen."

#: ../../library/ssl.rst:190
msgid "Support for key logging to :envvar:`SSLKEYLOGFILE` was added."
msgstr "Stöd för nyckelloggning till :envvar:`SSLKEYLOGFILE` har lagts till."

#: ../../library/ssl.rst:194
msgid ""
"The context now uses :data:`PROTOCOL_TLS_CLIENT` or "
":data:`PROTOCOL_TLS_SERVER` protocol instead of generic "
":data:`PROTOCOL_TLS`."
msgstr ""
"Kontexten använder nu protokollet :data:`PROTOCOL_TLS_CLIENT` eller "
":data:`PROTOCOL_TLS_SERVER` i stället för det generiska protokollet "
":data:`PROTOCOL_TLS`."

#: ../../library/ssl.rst:200
msgid "Exceptions"
msgstr "Undantag"

#: ../../library/ssl.rst:204
msgid ""
"Raised to signal an error from the underlying SSL implementation (currently "
"provided by the OpenSSL library).  This signifies some problem in the "
"higher-level encryption and authentication layer that's superimposed on the "
"underlying network connection.  This error is a subtype of :exc:`OSError`.  "
"The error code and message of :exc:`SSLError` instances are provided by the "
"OpenSSL library."
msgstr ""
"Utlöses för att signalera ett fel från den underliggande SSL-"
"implementeringen (som för närvarande tillhandahålls av OpenSSL-biblioteket)."
"  Detta innebär något problem i krypterings- och autentiseringslagret på "
"högre nivå som läggs ovanpå den underliggande nätverksanslutningen.  Det här"
" felet är en subtyp av :exc:`OSError`.  Felkoden och meddelandet för "
":exc:`SSLError`\\-instanser tillhandahålls av OpenSSL-biblioteket."

#: ../../library/ssl.rst:211
msgid ":exc:`SSLError` used to be a subtype of :exc:`socket.error`."
msgstr ":exc:`SSLError` brukade vara en subtyp av :exc:`socket.error`."

#: ../../library/ssl.rst:216
msgid ""
"A string mnemonic designating the OpenSSL submodule in which the error "
"occurred, such as ``SSL``, ``PEM`` or ``X509``.  The range of possible "
"values depends on the OpenSSL version."
msgstr ""
"En sträng som betecknar den OpenSSL-submodul där felet inträffade, t.ex. "
"``SSL``, ``PEM`` eller ``X509``.  Mängden möjliga värden beror på OpenSSL-"
"versionen."

#: ../../library/ssl.rst:224
msgid ""
"A string mnemonic designating the reason this error occurred, for example "
"``CERTIFICATE_VERIFY_FAILED``.  The range of possible values depends on the "
"OpenSSL version."
msgstr ""
"En sträng som anger orsaken till att felet uppstod, till exempel "
"``CERTIFICATE_VERIFY_FAILED``.  Mängden möjliga värden beror på OpenSSL-"
"versionen."

#: ../../library/ssl.rst:232
msgid ""
"A subclass of :exc:`SSLError` raised when trying to read or write and the "
"SSL connection has been closed cleanly.  Note that this doesn't mean that "
"the underlying transport (read TCP) has been closed."
msgstr ""
"En underklass av :exc:`SSLError` som uppstår när man försöker läsa eller "
"skriva och SSL-anslutningen har stängts på ett korrekt sätt.  Observera att "
"detta inte betyder att den underliggande transporten (läs TCP) har stängts."

#: ../../library/ssl.rst:240
msgid ""
"A subclass of :exc:`SSLError` raised by a :ref:`non-blocking SSL socket "
"<ssl-nonblocking>` when trying to read or write data, but more data needs to"
" be received on the underlying TCP transport before the request can be "
"fulfilled."
msgstr ""
"En underklass till :exc:`SSLError` som orsakas av en :ref:`icke-blockerande "
"SSL-socket <ssl-nonblocking>` när den försöker läsa eller skriva data, men "
"mer data måste tas emot på den underliggande TCP-transporten innan begäran "
"kan uppfyllas."

#: ../../library/ssl.rst:249
msgid ""
"A subclass of :exc:`SSLError` raised by a :ref:`non-blocking SSL socket "
"<ssl-nonblocking>` when trying to read or write data, but more data needs to"
" be sent on the underlying TCP transport before the request can be "
"fulfilled."
msgstr ""
"En underklass till :exc:`SSLError` som uppstår när ett :ref:`icke-"
"blockerande SSL-uttag <ssl-nonblocking>` försöker läsa eller skriva data, "
"men mer data måste skickas på den underliggande TCP-transporten innan "
"begäran kan uppfyllas."

#: ../../library/ssl.rst:258
msgid ""
"A subclass of :exc:`SSLError` raised when a system error was encountered "
"while trying to fulfill an operation on a SSL socket.  Unfortunately, there "
"is no easy way to inspect the original errno number."
msgstr ""
"En underklass till :exc:`SSLError` som uppstår när ett systemfel uppstår när"
" man försöker utföra en åtgärd på ett SSL-uttag.  Tyvärr finns det inget "
"enkelt sätt att inspektera det ursprungliga errno-numret."

#: ../../library/ssl.rst:266
msgid ""
"A subclass of :exc:`SSLError` raised when the SSL connection has been "
"terminated abruptly.  Generally, you shouldn't try to reuse the underlying "
"transport when this error is encountered."
msgstr ""
"En underklass till :exc:`SSLError` som uppstår när SSL-anslutningen har "
"avslutats abrupt.  Generellt sett bör du inte försöka återanvända den "
"underliggande transporten när detta fel uppstår."

#: ../../library/ssl.rst:274
msgid ""
"A subclass of :exc:`SSLError` raised when certificate validation has failed."
msgstr ""
"En underklass av :exc:`SSLError` som uppstår när certifikatvalideringen "
"misslyckats."

#: ../../library/ssl.rst:281
msgid "A numeric error number that denotes the verification error."
msgstr "Ett numeriskt felnummer som anger verifieringsfelet."

#: ../../library/ssl.rst:285
msgid "A human readable string of the verification error."
msgstr "En mänskligt läsbar sträng av verifieringsfelet."

#: ../../library/ssl.rst:289
msgid "An alias for :exc:`SSLCertVerificationError`."
msgstr "Ett alias för :exc:`SSLCertVerificationError`."

#: ../../library/ssl.rst:291
msgid "The exception is now an alias for :exc:`SSLCertVerificationError`."
msgstr "Undantaget är nu ett alias för :exc:`SSLCertVerificationError`."

#: ../../library/ssl.rst:296
msgid "Random generation"
msgstr "Slumpmässig generering"

#: ../../library/ssl.rst:300
msgid ""
"Return *num* cryptographically strong pseudo-random bytes. Raises an "
":class:`SSLError` if the PRNG has not been seeded with enough data or if the"
" operation is not supported by the current RAND method. :func:`RAND_status` "
"can be used to check the status of the PRNG and :func:`RAND_add` can be used"
" to seed the PRNG."
msgstr ""
"Returnerar *num* kryptografiskt starka pseudoslumpmässiga bytes. Utlöser ett"
" :class:`SSLError` om PRNG inte har laddats med tillräckligt med data eller "
"om operationen inte stöds av den aktuella RAND-metoden. :func:`RAND_status` "
"kan användas för att kontrollera statusen för PRNG och :func:`RAND_add` kan "
"användas för att ladda PRNG."

#: ../../library/ssl.rst:306 ../../library/ssl.rst:327
msgid "For almost all applications :func:`os.urandom` is preferable."
msgstr "För nästan alla tillämpningar är :func:`os.urandom` att föredra."

#: ../../library/ssl.rst:308
msgid ""
"Read the Wikipedia article, `Cryptographically secure pseudorandom number "
"generator (CSPRNG) "
"<https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator>`_,"
" to get the requirements of a cryptographically strong generator."
msgstr ""
"Läs Wikipedia-artikeln `Cryptographically secure pseudorandom number "
"generator (CSPRNG) "
"<https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator>`_"
" för att få information om kraven på en kryptografiskt stark generator."

#: ../../library/ssl.rst:317
msgid ""
"Return (bytes, is_cryptographic): bytes are *num* pseudo-random bytes, "
"is_cryptographic is ``True`` if the bytes generated are cryptographically "
"strong. Raises an :class:`SSLError` if the operation is not supported by the"
" current RAND method."
msgstr ""

#: ../../library/ssl.rst:322
msgid ""
"Generated pseudo-random byte sequences will be unique if they are of "
"sufficient length, but are not necessarily unpredictable. They can be used "
"for non-cryptographic purposes and for certain purposes in cryptographic "
"protocols, but usually not for key generation etc."
msgstr ""

#: ../../library/ssl.rst:333
msgid ""
"OpenSSL has deprecated :func:`ssl.RAND_pseudo_bytes`, use "
":func:`ssl.RAND_bytes` instead."
msgstr ""

#: ../../library/ssl.rst:338
msgid ""
"Return ``True`` if the SSL pseudo-random number generator has been seeded "
"with 'enough' randomness, and ``False`` otherwise.  You can use "
":func:`ssl.RAND_egd` and :func:`ssl.RAND_add` to increase the randomness of "
"the pseudo-random number generator."
msgstr ""
"Returnerar ``True`` om SSL:s pseudoslumptalsgenerator har försetts med "
"\"tillräckligt\" med slumpmässighet, och ``False`` annars.  Du kan använda "
":func:`ssl.RAND_egd` och :func:`ssl.RAND_add` för att öka slumpmässigheten i"
" pseudoslumptalsgeneratorn."

#: ../../library/ssl.rst:345
msgid ""
"Mix the given *bytes* into the SSL pseudo-random number generator.  The "
"parameter *entropy* (a float) is a lower bound on the entropy contained in "
"string (so you can always use ``0.0``).  See :rfc:`1750` for more "
"information on sources of entropy."
msgstr ""
"Blanda de angivna *bytes* i SSL:s pseudoslumpmässiga nummergenerator.  "
"Parametern *entropy* (en float) är en nedre gräns för entropin i strängen "
"(så du kan alltid använda ``0.0``).  Se :rfc:`1750` för mer information om "
"källor till entropi."

#: ../../library/ssl.rst:350
msgid "Writable :term:`bytes-like object` is now accepted."
msgstr "Skrivbar :term:`bytesliknande objekt` är nu accepterad."

#: ../../library/ssl.rst:354
msgid "Certificate handling"
msgstr "Hantering av certifikat"

#: ../../library/ssl.rst:362
msgid ""
"Verify that *cert* (in decoded format as returned by "
":meth:`SSLSocket.getpeercert`) matches the given *hostname*.  The rules "
"applied are those for checking the identity of HTTPS servers as outlined in "
":rfc:`2818`, :rfc:`5280` and :rfc:`6125`.  In addition to HTTPS, this "
"function should be suitable for checking the identity of servers in various "
"SSL-based protocols such as FTPS, IMAPS, POPS and others."
msgstr ""

#: ../../library/ssl.rst:369
msgid ""
":exc:`CertificateError` is raised on failure. On success, the function "
"returns nothing::"
msgstr ""

#: ../../library/ssl.rst:382
msgid ""
"The function now follows :rfc:`6125`, section 6.4.3 and does neither match "
"multiple wildcards (e.g. ``*.*.com`` or ``*a*.example.org``) nor a wildcard "
"inside an internationalized domain names (IDN) fragment. IDN A-labels such "
"as ``www*.xn--pthon-kva.org`` are still supported, but ``x*.python.org`` no "
"longer matches ``xn--tda.python.org``."
msgstr ""

#: ../../library/ssl.rst:389
msgid ""
"Matching of IP addresses, when present in the subjectAltName field of the "
"certificate, is now supported."
msgstr ""

#: ../../library/ssl.rst:393
msgid ""
"The function is no longer used to TLS connections. Hostname matching is now "
"performed by OpenSSL."
msgstr ""

#: ../../library/ssl.rst:397
msgid ""
"Allow wildcard when it is the leftmost and the only character in that "
"segment. Partial wildcards like ``www*.example.com`` are no longer "
"supported."
msgstr ""

#: ../../library/ssl.rst:405
msgid ""
"Return the time in seconds since the Epoch, given the ``cert_time`` string "
"representing the \"notBefore\" or \"notAfter\" date from a certificate in "
"``\"%b %d %H:%M:%S %Y %Z\"`` strptime format (C locale)."
msgstr ""
"Returnerar tiden i sekunder sedan epoken, givet strängen ``cert_time`` som "
"representerar \"notBefore\"- eller \"notAfter\"-datumet från ett certifikat "
"i ``\"%b %d %H:%M:%S %Y %Z\"`` strptime-format (C-läge)."

#: ../../library/ssl.rst:410
msgid "Here's an example:"
msgstr "Här är ett exempel:"

#: ../../library/ssl.rst:422
msgid "\"notBefore\" or \"notAfter\" dates must use GMT (:rfc:`5280`)."
msgstr "\"notBefore\"- eller \"notAfter\"-datum måste använda GMT (:rfc:`5280`)."

#: ../../library/ssl.rst:424
msgid ""
"Interpret the input time as a time in UTC as specified by 'GMT' timezone in "
"the input string. Local timezone was used previously. Return an integer (no "
"fractions of a second in the input format)"
msgstr ""
"Tolkar inmatningstiden som en tid i UTC enligt tidszonen \"GMT\" i "
"inmatningssträngen. Lokal tidszon användes tidigare. Returnera ett heltal "
"(inga bråkdelar av en sekund i inmatningsformatet)"

#: ../../library/ssl.rst:433
msgid ""
"Given the address ``addr`` of an SSL-protected server, as a (*hostname*, "
"*port-number*) pair, fetches the server's certificate, and returns it as a "
"PEM-encoded string.  If ``ssl_version`` is specified, uses that version of "
"the SSL protocol to attempt to connect to the server.  If ``ca_certs`` is "
"specified, it should be a file containing a list of root certificates, the "
"same format as used for the same parameter in "
":meth:`SSLContext.wrap_socket`.  The call will attempt to validate the "
"server certificate against that set of root certificates, and will fail if "
"the validation attempt fails.  A timeout can be specified with the "
"``timeout`` parameter."
msgstr ""

#: ../../library/ssl.rst:444
msgid "This function is now IPv6-compatible."
msgstr "Denna funktion är nu IPv6-kompatibel."

#: ../../library/ssl.rst:447
msgid ""
"The default *ssl_version* is changed from :data:`PROTOCOL_SSLv3` to "
":data:`PROTOCOL_TLS` for maximum compatibility with modern servers."
msgstr ""
"Standard *ssl_version* ändras från :data:`PROTOCOL_SSLv3` till "
":data:`PROTOCOL_TLS` för maximal kompatibilitet med moderna servrar."

#: ../../library/ssl.rst:451
msgid "The *timeout* parameter was added."
msgstr "Parametern *timeout* har lagts till."

#: ../../library/ssl.rst:456
msgid ""
"Given a certificate as a DER-encoded blob of bytes, returns a PEM-encoded "
"string version of the same certificate."
msgstr ""
"Om ett certifikat ges som en DER-kodad blob med bytes, returneras en PEM-"
"kodad strängversion av samma certifikat."

#: ../../library/ssl.rst:461
msgid ""
"Given a certificate as an ASCII PEM string, returns a DER-encoded sequence "
"of bytes for that same certificate."
msgstr ""
"Om ett certifikat anges som en ASCII PEM-sträng returneras en DER-kodad "
"sekvens av bytes för samma certifikat."

#: ../../library/ssl.rst:466
msgid ""
"Returns a named tuple with paths to OpenSSL's default cafile and capath. The"
" paths are the same as used by :meth:`SSLContext.set_default_verify_paths`. "
"The return value is a :term:`named tuple` ``DefaultVerifyPaths``:"
msgstr ""
"Returnerar en namngiven tupel med sökvägar till OpenSSL:s standardcafile och"
" -capath. Sökvägarna är samma som används av "
":meth:`SSLContext.set_default_verify_paths`. Returvärdet är en :term:`named "
"tuple` ``DefaultVerifyPaths``:"

#: ../../library/ssl.rst:471
msgid ""
":attr:`cafile` - resolved path to cafile or ``None`` if the file doesn't "
"exist,"
msgstr ""
":attr:`cafile` - upplöst sökväg till cafile eller ``None`` om filen inte "
"finns,"

#: ../../library/ssl.rst:472
msgid ""
":attr:`capath` - resolved path to capath or ``None`` if the directory "
"doesn't exist,"
msgstr ""
":attr:`capath` - upplöst sökväg till capath eller ``None`` om katalogen inte"
" finns,"

#: ../../library/ssl.rst:473
msgid ""
":attr:`openssl_cafile_env` - OpenSSL's environment key that points to a "
"cafile,"
msgstr ""
":attr:`openssl_cafile_env` - OpenSSL:s miljönyckel som pekar på en cafile,"

#: ../../library/ssl.rst:474
msgid ":attr:`openssl_cafile` - hard coded path to a cafile,"
msgstr ":attr:`openssl_cafile` - hårdkodad sökväg till en cafile,"

#: ../../library/ssl.rst:475
msgid ""
":attr:`openssl_capath_env` - OpenSSL's environment key that points to a "
"capath,"
msgstr ""
":attr:`openssl_capath_env` - OpenSSL:s miljönyckel som pekar på en capath,"

#: ../../library/ssl.rst:476
msgid ":attr:`openssl_capath` - hard coded path to a capath directory"
msgstr ":attr:`openssl_capath` - hårdkodad sökväg till en capath-katalog"

#: ../../library/ssl.rst:482
msgid ""
"Retrieve certificates from Windows' system cert store. *store_name* may be "
"one of ``CA``, ``ROOT`` or ``MY``. Windows may provide additional cert "
"stores, too."
msgstr ""
"Hämtar certifikat från Windows system cert store. *store_name* kan vara en "
"av ``CA``, ``ROOT`` eller ``MY``. Windows kan också tillhandahålla "
"ytterligare certifikatlager."

#: ../../library/ssl.rst:486
msgid ""
"The function returns a list of (cert_bytes, encoding_type, trust) tuples. "
"The encoding_type specifies the encoding of cert_bytes. It is either "
":const:`x509_asn` for X.509 ASN.1 data or :const:`pkcs_7_asn` for PKCS#7 "
"ASN.1 data. Trust specifies the purpose of the certificate as a set of OIDS "
"or exactly ``True`` if the certificate is trustworthy for all purposes."
msgstr ""
"Funktionen returnerar en lista med (cert_bytes, encoding_type, "
"trust)-tupler. Encoding_type anger kodningen av cert_bytes. Den är antingen "
":const:`x509_asn` för X.509 ASN.1-data eller :const:`pkcs_7_asn` för PKCS#7 "
"ASN.1-data. Trust anger syftet med certifikatet som en uppsättning OIDS "
"eller exakt ``True`` om certifikatet är pålitligt för alla ändamål."

#: ../../library/ssl.rst:493 ../../library/ssl.rst:1637
#: ../../library/ssl.rst:1935
msgid "Example::"
msgstr "Exempel::"

#: ../../library/ssl.rst:499 ../../library/ssl.rst:514
msgid ":ref:`Availability <availability>`: Windows."
msgstr ""

#: ../../library/ssl.rst:505
msgid ""
"Retrieve CRLs from Windows' system cert store. *store_name* may be one of "
"``CA``, ``ROOT`` or ``MY``. Windows may provide additional cert stores, too."
msgstr ""
"Hämtar CRL:er från Windows systemets cert-arkiv. *store_name* kan vara en av"
" ``CA``, ``ROOT`` eller ``MY``. Windows kan också tillhandahålla ytterligare"
" cert-arkiv."

#: ../../library/ssl.rst:509
msgid ""
"The function returns a list of (cert_bytes, encoding_type, trust) tuples. "
"The encoding_type specifies the encoding of cert_bytes. It is either "
":const:`x509_asn` for X.509 ASN.1 data or :const:`pkcs_7_asn` for PKCS#7 "
"ASN.1 data."
msgstr ""
"Funktionen returnerar en lista med (cert_bytes, encoding_type, "
"trust)-tupler. Encoding_type anger kodningen av cert_bytes. Den är antingen "
":const:`x509_asn` för X.509 ASN.1-data eller :const:`pkcs_7_asn` för PKCS#7 "
"ASN.1-data."

#: ../../library/ssl.rst:523
msgid ""
"Takes an instance ``sock`` of :class:`socket.socket`, and returns an "
"instance of :class:`ssl.SSLSocket`, a subtype of :class:`socket.socket`, "
"which wraps the underlying socket in an SSL context.  ``sock`` must be a "
":data:`~socket.SOCK_STREAM` socket; other socket types are unsupported."
msgstr ""

#: ../../library/ssl.rst:528
msgid ""
"Internally, function creates a :class:`SSLContext` with protocol "
"*ssl_version* and :attr:`SSLContext.options` set to *cert_reqs*. If "
"parameters *keyfile*, *certfile*, *ca_certs* or *ciphers* are set, then the "
"values are passed to :meth:`SSLContext.load_cert_chain`, "
":meth:`SSLContext.load_verify_locations`, and "
":meth:`SSLContext.set_ciphers`."
msgstr ""

#: ../../library/ssl.rst:535
msgid ""
"The arguments *server_side*, *do_handshake_on_connect*, and "
"*suppress_ragged_eofs* have the same meaning as "
":meth:`SSLContext.wrap_socket`."
msgstr ""

#: ../../library/ssl.rst:541
msgid ""
"Since Python 3.2 and 2.7.9, it is recommended to use the "
":meth:`SSLContext.wrap_socket` instead of :func:`wrap_socket`. The top-level"
" function is limited and creates an insecure client socket without server "
"name indication or hostname matching."
msgstr ""

#: ../../library/ssl.rst:547
msgid "Constants"
msgstr "Konstanter"

#: ../../library/ssl.rst:549
msgid ""
"All constants are now :class:`enum.IntEnum` or :class:`enum.IntFlag` "
"collections."
msgstr ""
"Alla konstanter är nu :class:`enum.IntEnum` eller :class:`enum.IntFlag` "
"samlingar."

#: ../../library/ssl.rst:555
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`, or the ``cert_reqs`` "
"parameter to :func:`wrap_socket`.  Except for :const:`PROTOCOL_TLS_CLIENT`, "
"it is the default mode.  With client-side sockets, just about any cert is "
"accepted.  Validation errors, such as untrusted or expired cert, are ignored"
" and do not abort the TLS/SSL handshake."
msgstr ""

#: ../../library/ssl.rst:561
msgid ""
"In server mode, no certificate is requested from the client, so the client "
"does not send any for client cert authentication."
msgstr ""
"I serverläge begärs inget certifikat från klienten, så klienten skickar inte"
" något för autentisering med klientcertifikat."

#: ../../library/ssl.rst:564 ../../library/ssl.rst:2343
msgid "See the discussion of :ref:`ssl-security` below."
msgstr "Se diskussionen om :ref:`ssl-security` nedan."

#: ../../library/ssl.rst:568
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`, or the ``cert_reqs`` "
"parameter to :func:`wrap_socket`.  In client mode, :const:`CERT_OPTIONAL` "
"has the same meaning as :const:`CERT_REQUIRED`. It is recommended to use "
":const:`CERT_REQUIRED` for client-side sockets instead."
msgstr ""

#: ../../library/ssl.rst:573
msgid ""
"In server mode, a client certificate request is sent to the client.  The "
"client may either ignore the request or send a certificate in order perform "
"TLS client cert authentication.  If the client chooses to send a "
"certificate, it is verified.  Any verification error immediately aborts the "
"TLS handshake."
msgstr ""
"I serverläge skickas en begäran om klientcertifikat till klienten.  Klienten"
" kan antingen ignorera begäran eller skicka ett certifikat för att utföra "
"TLS-klientcertifikatsautentisering.  Om klienten väljer att skicka ett "
"certifikat verifieras det.  Om ett verifieringsfel uppstår avbryts TLS-"
"handskakningen omedelbart."

#: ../../library/ssl.rst:579 ../../library/ssl.rst:599
msgid ""
"Use of this setting requires a valid set of CA certificates to be passed, "
"either to :meth:`SSLContext.load_verify_locations` or as a value of the "
"``ca_certs`` parameter to :func:`wrap_socket`."
msgstr ""

#: ../../library/ssl.rst:585
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`, or the ``cert_reqs`` "
"parameter to :func:`wrap_socket`.  In this mode, certificates are required "
"from the other side of the socket connection; an :class:`SSLError` will be "
"raised if no certificate is provided, or if its validation fails. This mode "
"is **not** sufficient to verify a certificate in client mode as it does not "
"match hostnames.  :attr:`~SSLContext.check_hostname` must be enabled as well"
" to verify the authenticity of a cert. :const:`PROTOCOL_TLS_CLIENT` uses "
":const:`CERT_REQUIRED` and enables :attr:`~SSLContext.check_hostname` by "
"default."
msgstr ""

#: ../../library/ssl.rst:595
msgid ""
"With server socket, this mode provides mandatory TLS client cert "
"authentication.  A client certificate request is sent to the client and the "
"client must provide a valid and trusted certificate."
msgstr ""
"Med serveruttag ger detta läge obligatorisk TLS-"
"klientcertifikatsautentisering.  En begäran om klientcertifikat skickas till"
" klienten och klienten måste tillhandahålla ett giltigt och betrott "
"certifikat."

#: ../../library/ssl.rst:605
msgid ":class:`enum.IntEnum` collection of CERT_* constants."
msgstr ":class:`enum.IntEnum` samling av CERT_*-konstanter."

#: ../../library/ssl.rst:611
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, "
"certificate revocation lists (CRLs) are not checked. By default OpenSSL does"
" neither require nor verify CRLs."
msgstr ""
"Möjligt värde för :attr:`SSLContext.verify_flags`. I det här läget "
"kontrolleras inte CRL:er (Certificate Revocation List). Som standard varken "
"kräver eller verifierar OpenSSL CRL:er."

#: ../../library/ssl.rst:619
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, only the "
"peer cert is checked but none of the intermediate CA certificates. The mode "
"requires a valid CRL that is signed by the peer cert's issuer (its direct "
"ancestor CA). If no proper CRL has been loaded with "
":attr:`SSLContext.load_verify_locations`, validation will fail."
msgstr ""
"Möjligt värde för :attr:`SSLContext.verify_flags`. I det här läget "
"kontrolleras endast peer-certifikatet, men inga mellanliggande CA-"
"certifikat. Läget kräver en giltig CRL som är signerad av peer-certifikatets"
" utfärdare (dess direkta förfader CA). Om ingen korrekt CRL har laddats med "
":attr:`SSLContext.load_verify_locations`, kommer valideringen att "
"misslyckas."

#: ../../library/ssl.rst:629
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, CRLs of "
"all certificates in the peer cert chain are checked."
msgstr ""
"Möjligt värde för :attr:`SSLContext.verify_flags`. I det här läget "
"kontrolleras CRL för alla certifikat i peer-certifikatkedjan."

#: ../../library/ssl.rst:636
msgid ""
"Possible value for :attr:`SSLContext.verify_flags` to disable workarounds "
"for broken X.509 certificates."
msgstr ""
"Möjligt värde för :attr:`SSLContext.verify_flags` för att inaktivera "
"lösningar för trasiga X.509-certifikat."

#: ../../library/ssl.rst:643
msgid ""
"Possible value for :attr:`SSLContext.verify_flags` to enables proxy "
"certificate verification."
msgstr ""
"Möjligt värde för :attr:`SSLContext.verify_flags` för att aktivera "
"verifiering av proxycertifikat."

#: ../../library/ssl.rst:650
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. It instructs OpenSSL to "
"prefer trusted certificates when building the trust chain to validate a "
"certificate. This flag is enabled by default."
msgstr ""
"Möjligt värde för :attr:`SSLContext.verify_flags`. Instruerar OpenSSL att "
"föredra betrodda certifikat när förtroendekedjan byggs upp för att validera "
"ett certifikat. Denna flagga är aktiverad som standard."

#: ../../library/ssl.rst:658
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. It instructs OpenSSL to "
"accept intermediate CAs in the trust store to be treated as trust-anchors, "
"in the same way as the self-signed root CA certificates. This makes it "
"possible to trust certificates issued by an intermediate CA without having "
"to trust its ancestor root CA."
msgstr ""
"Möjligt värde för :attr:`SSLContext.verify_flags`. Instruerar OpenSSL att "
"acceptera att mellanliggande CA:er i trust store behandlas som trust-"
"anchors, på samma sätt som självsignerade root CA-certifikat. Detta gör det "
"möjligt att lita på certifikat som utfärdats av en mellanliggande CA utan "
"att behöva lita på dess förfader rot-CA."

#: ../../library/ssl.rst:669
msgid ":class:`enum.IntFlag` collection of VERIFY_* constants."
msgstr ":class:`enum.IntFlag` samling av VERIFY_*-konstanter."

#: ../../library/ssl.rst:675
msgid ""
"Selects the highest protocol version that both the client and server "
"support. Despite the name, this option can select both \"SSL\" and \"TLS\" "
"protocols."
msgstr ""
"Väljer den högsta protokollversionen som både klienten och servern stöder. "
"Trots namnet kan det här alternativet välja både \"SSL\"- och "
"\"TLS\"-protokoll."

#: ../../library/ssl.rst:682
msgid ""
"TLS clients and servers require different default settings for secure "
"communication. The generic TLS protocol constant is deprecated in favor of "
":data:`PROTOCOL_TLS_CLIENT` and :data:`PROTOCOL_TLS_SERVER`."
msgstr ""
"TLS-klienter och -servrar kräver olika standardinställningar för säker "
"kommunikation. Den generiska TLS-protokollkonstanten är föråldrad till "
"förmån för :data:`PROTOCOL_TLS_CLIENT` och :data:`PROTOCOL_TLS_SERVER`."

#: ../../library/ssl.rst:688
msgid ""
"Auto-negotiate the highest protocol version that both the client and server "
"support, and configure the context client-side connections. The protocol "
"enables :data:`CERT_REQUIRED` and :attr:`~SSLContext.check_hostname` by "
"default."
msgstr ""
"Förhandla automatiskt om den högsta protokollversionen som både klienten och"
" servern stöder och konfigurera kontextanslutningarna på klientsidan. "
"Protokollet aktiverar :data:`CERT_REQUIRED` och "
":attr:`~SSLContext.check_hostname` som standard."

#: ../../library/ssl.rst:697
msgid ""
"Auto-negotiate the highest protocol version that both the client and server "
"support, and configure the context server-side connections."
msgstr ""
"Autoförhandla den högsta protokollversionen som både klienten och servern "
"stöder och konfigurera kontexten för anslutningar på serversidan."

#: ../../library/ssl.rst:704
msgid "Alias for :data:`PROTOCOL_TLS`."
msgstr "Alias för :data:`PROTOCOL_TLS`."

#: ../../library/ssl.rst:708
msgid "Use :data:`PROTOCOL_TLS` instead."
msgstr "Använd :data:`PROTOCOL_TLS` istället."

#: ../../library/ssl.rst:712
msgid "Selects SSL version 2 as the channel encryption protocol."
msgstr ""

#: ../../library/ssl.rst:714
msgid ""
"This protocol is not available if OpenSSL is compiled with the ``no-ssl2`` "
"option."
msgstr ""

#: ../../library/ssl.rst:719
msgid "SSL version 2 is insecure.  Its use is highly discouraged."
msgstr ""

#: ../../library/ssl.rst:723
msgid "OpenSSL has removed support for SSLv2."
msgstr ""

#: ../../library/ssl.rst:727
msgid "Selects SSL version 3 as the channel encryption protocol."
msgstr "Väljer SSL version 3 som protokoll för kryptering av kanalen."

#: ../../library/ssl.rst:729
msgid ""
"This protocol is not available if OpenSSL is compiled with the ``no-ssl3`` "
"option."
msgstr ""
"Detta protokoll är inte tillgängligt om OpenSSL kompileras med alternativet "
"``no-ssl3``."

#: ../../library/ssl.rst:734
msgid "SSL version 3 is insecure.  Its use is highly discouraged."
msgstr "SSL version 3 är osäkert.  Dess användning är starkt avrådd."

#: ../../library/ssl.rst:738
msgid ""
"OpenSSL has deprecated all version specific protocols. Use the default "
"protocol :data:`PROTOCOL_TLS_SERVER` or :data:`PROTOCOL_TLS_CLIENT` with "
":attr:`SSLContext.minimum_version` and :attr:`SSLContext.maximum_version` "
"instead."
msgstr ""
"OpenSSL har utgått från alla versionsspecifika protokoll. Använd "
"standardprotokollet :data:`PROTOCOL_TLS_SERVER` eller "
":data:`PROTOCOL_TLS_CLIENT` med :attr:`SSLContext.minimum_version` och "
":attr:`SSLContext.maximum_version` istället."

#: ../../library/ssl.rst:746
msgid "Selects TLS version 1.0 as the channel encryption protocol."
msgstr "Väljer TLS version 1.0 som krypteringsprotokoll för kanalen."

#: ../../library/ssl.rst:750 ../../library/ssl.rst:761
#: ../../library/ssl.rst:772
msgid "OpenSSL has deprecated all version specific protocols."
msgstr "OpenSSL har avskaffat alla versionsspecifika protokoll."

#: ../../library/ssl.rst:754
msgid ""
"Selects TLS version 1.1 as the channel encryption protocol. Available only "
"with openssl version 1.0.1+."
msgstr ""
"Väljer TLS version 1.1 som krypteringsprotokoll för kanalen. Endast "
"tillgängligt med openssl version 1.0.1+."

#: ../../library/ssl.rst:765
msgid ""
"Selects TLS version 1.2 as the channel encryption protocol. Available only "
"with openssl version 1.0.1+."
msgstr ""
"Väljer TLS version 1.2 som krypteringsprotokoll för kanalen. Endast "
"tillgängligt med openssl version 1.0.1+."

#: ../../library/ssl.rst:776
msgid ""
"Enables workarounds for various bugs present in other SSL implementations. "
"This option is set by default.  It does not necessarily set the same flags "
"as OpenSSL's ``SSL_OP_ALL`` constant."
msgstr ""
"Möjliggör lösningar för olika buggar som finns i andra SSL-implementeringar."
" Detta alternativ är inställt som standard.  Det sätter inte nödvändigtvis "
"samma flaggor som OpenSSL:s konstant ``SSL_OP_ALL``."

#: ../../library/ssl.rst:784
msgid ""
"Prevents an SSLv2 connection.  This option is only applicable in conjunction"
" with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing SSLv2 as "
"the protocol version."
msgstr ""
"Förhindrar en SSLv2-anslutning.  Detta alternativ är endast tillämpligt i "
"kombination med :const:`PROTOCOL_TLS`.  Det hindrar motparterna från att "
"välja SSLv2 som protokollversion."

#: ../../library/ssl.rst:792
msgid "SSLv2 is deprecated"
msgstr "SSLv2 är föråldrat"

#: ../../library/ssl.rst:796
msgid ""
"Prevents an SSLv3 connection.  This option is only applicable in conjunction"
" with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing SSLv3 as "
"the protocol version."
msgstr ""
"Förhindrar en SSLv3-anslutning.  Detta alternativ är endast tillämpligt i "
"kombination med :const:`PROTOCOL_TLS`.  Det hindrar motparterna från att "
"välja SSLv3 som protokollversion."

#: ../../library/ssl.rst:804
msgid "SSLv3 is deprecated"
msgstr "SSLv3 är föråldrad"

#: ../../library/ssl.rst:808
msgid ""
"Prevents a TLSv1 connection.  This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing TLSv1 as "
"the protocol version."
msgstr ""
"Förhindrar en TLSv1-anslutning.  Detta alternativ är endast tillämpligt i "
"kombination med :const:`PROTOCOL_TLS`.  Det hindrar peers från att välja "
"TLSv1 som protokollversion."

#: ../../library/ssl.rst:814
msgid ""
"The option is deprecated since OpenSSL 1.1.0, use the new "
":attr:`SSLContext.minimum_version` and :attr:`SSLContext.maximum_version` "
"instead."
msgstr ""
"Alternativet är föråldrat sedan OpenSSL 1.1.0, använd de nya "
":attr:`SSLContext.minimum_version` och :attr:`SSLContext.maximum_version` "
"istället."

#: ../../library/ssl.rst:821
msgid ""
"Prevents a TLSv1.1 connection. This option is only applicable in conjunction"
" with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.1 as "
"the protocol version. Available only with openssl version 1.0.1+."
msgstr ""
"Förhindrar en TLSv1.1-anslutning. Detta alternativ är endast tillämpligt i "
"kombination med :const:`PROTOCOL_TLS`. Det hindrar motparterna från att "
"välja TLSv1.1 som protokollversion. Endast tillgängligt med openssl version "
"1.0.1+."

#: ../../library/ssl.rst:827 ../../library/ssl.rst:838
msgid "The option is deprecated since OpenSSL 1.1.0."
msgstr "Alternativet är föråldrat sedan OpenSSL 1.1.0."

#: ../../library/ssl.rst:832
msgid ""
"Prevents a TLSv1.2 connection. This option is only applicable in conjunction"
" with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.2 as "
"the protocol version. Available only with openssl version 1.0.1+."
msgstr ""
"Förhindrar en TLSv1.2-anslutning. Detta alternativ är endast tillämpligt i "
"kombination med :const:`PROTOCOL_TLS`. Det hindrar motparterna från att "
"välja TLSv1.2 som protokollversion. Endast tillgängligt med openssl version "
"1.0.1+."

#: ../../library/ssl.rst:843
msgid ""
"Prevents a TLSv1.3 connection. This option is only applicable in conjunction"
" with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.3 as "
"the protocol version. TLS 1.3 is available with OpenSSL 1.1.1 or later. When"
" Python has been compiled against an older version of OpenSSL, the flag "
"defaults to *0*."
msgstr ""
"Förhindrar en TLSv1.3-anslutning. Detta alternativ är endast tillämpligt i "
"kombination med :const:`PROTOCOL_TLS`. Det hindrar motparterna från att "
"välja TLSv1.3 som protokollversion. TLS 1.3 är tillgängligt med OpenSSL "
"1.1.1 eller senare. När Python har kompilerats mot en äldre version av "
"OpenSSL, är flaggan som standard *0*."

#: ../../library/ssl.rst:851
msgid ""
"The option is deprecated since OpenSSL 1.1.0. It was added to 2.7.15 and "
"3.6.3 for backwards compatibility with OpenSSL 1.0.2."
msgstr ""
"Alternativet är föråldrat sedan OpenSSL 1.1.0. Det lades till i 2.7.15 och "
"3.6.3 för bakåtkompatibilitet med OpenSSL 1.0.2."

#: ../../library/ssl.rst:857
msgid ""
"Disable all renegotiation in TLSv1.2 and earlier. Do not send HelloRequest "
"messages, and ignore renegotiation requests via ClientHello."
msgstr ""
"Inaktivera all omförhandling i TLSv1.2 och tidigare. Skicka inte "
"HelloRequest-meddelanden och ignorera begäran om omförhandling via "
"ClientHello."

#: ../../library/ssl.rst:860
msgid "This option is only available with OpenSSL 1.1.0h and later."
msgstr ""
"Detta alternativ är endast tillgängligt med OpenSSL 1.1.0h och senare."

#: ../../library/ssl.rst:866
msgid ""
"Use the server's cipher ordering preference, rather than the client's. This "
"option has no effect on client sockets and SSLv2 server sockets."
msgstr ""
"Använd serverns preferens för chifferordning i stället för klientens. Det "
"här alternativet har ingen effekt på klientsocklar och SSLv2-serversocklar."

#: ../../library/ssl.rst:873
msgid ""
"Prevents re-use of the same DH key for distinct SSL sessions.  This improves"
" forward secrecy but requires more computational resources. This option only"
" applies to server sockets."
msgstr ""

#: ../../library/ssl.rst:881
msgid ""
"Prevents re-use of the same ECDH key for distinct SSL sessions.  This "
"improves forward secrecy but requires more computational resources. This "
"option only applies to server sockets."
msgstr ""

#: ../../library/ssl.rst:889
msgid ""
"Send dummy Change Cipher Spec (CCS) messages in TLS 1.3 handshake to make a "
"TLS 1.3 connection look more like a TLS 1.2 connection."
msgstr ""
"Skicka falska CCS-meddelanden (Change Cipher Spec) i TLS 1.3-handskakningen "
"för att få en TLS 1.3-anslutning att mer likna en TLS 1.2-anslutning."

#: ../../library/ssl.rst:892
msgid "This option is only available with OpenSSL 1.1.1 and later."
msgstr "Detta alternativ är endast tillgängligt med OpenSSL 1.1.1 och senare."

#: ../../library/ssl.rst:898
msgid ""
"Disable compression on the SSL channel.  This is useful if the application "
"protocol supports its own compression scheme."
msgstr ""
"Inaktivera komprimering på SSL-kanalen.  Detta är användbart om "
"applikationsprotokollet stöder sitt eget komprimeringsschema."

#: ../../library/ssl.rst:905
msgid ":class:`enum.IntFlag` collection of OP_* constants."
msgstr ":class:`enum.IntFlag` samling av OP_*-konstanter."

#: ../../library/ssl.rst:909
msgid "Prevent client side from requesting a session ticket."
msgstr "Förhindra klientsidan från att begära en sessionsbiljett."

#: ../../library/ssl.rst:915
msgid "Ignore unexpected shutdown of TLS connections."
msgstr "Ignorera oväntad avstängning av TLS-anslutningar."

#: ../../library/ssl.rst:917
msgid "This option is only available with OpenSSL 3.0.0 and later."
msgstr "Detta alternativ är endast tillgängligt med OpenSSL 3.0.0 och senare."

#: ../../library/ssl.rst:923
msgid ""
"Whether the OpenSSL library has built-in support for the *Application-Layer "
"Protocol Negotiation* TLS extension as described in :rfc:`7301`."
msgstr ""
"Om OpenSSL-biblioteket har inbyggt stöd för TLS-tillägget *Application-Layer"
" Protocol Negotiation* enligt beskrivningen i :rfc:`7301`."

#: ../../library/ssl.rst:930
msgid ""
"Whether the OpenSSL library has built-in support not checking subject common"
" name and :attr:`SSLContext.hostname_checks_common_name` is writeable."
msgstr ""
"Om OpenSSL-biblioteket har inbyggt stöd för att inte kontrollera ämnets "
"gemensamma namn och :attr:`SSLContext.hostname_checks_common_name` är "
"skrivbart."

#: ../../library/ssl.rst:938
msgid ""
"Whether the OpenSSL library has built-in support for the Elliptic Curve-"
"based Diffie-Hellman key exchange.  This should be true unless the feature "
"was explicitly disabled by the distributor."
msgstr ""
"Om OpenSSL-biblioteket har inbyggt stöd för Diffie-Hellman-nyckelutbyte "
"baserat på elliptiska kurvor.  Detta bör vara sant om inte funktionen "
"uttryckligen har inaktiverats av distributören."

#: ../../library/ssl.rst:946
msgid ""
"Whether the OpenSSL library has built-in support for the *Server Name "
"Indication* extension (as defined in :rfc:`6066`)."
msgstr ""
"Om OpenSSL-biblioteket har inbyggt stöd för tillägget *Server Name "
"Indication* (enligt definitionen i :rfc:`6066`)."

#: ../../library/ssl.rst:953
msgid ""
"Whether the OpenSSL library has built-in support for the *Next Protocol "
"Negotiation* as described in the `Application Layer Protocol Negotiation "
"<https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation>`_. "
"When true, you can use the :meth:`SSLContext.set_npn_protocols` method to "
"advertise which protocols you want to support."
msgstr ""
"Om OpenSSL-biblioteket har inbyggt stöd för *Next Protocol Negotiation* "
"enligt beskrivningen i `Application Layer Protocol Negotiation "
"<https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation>`_. "
"När det är sant kan du använda metoden :meth:`SSLContext.set_npn_protocols` "
"för att annonsera vilka protokoll du vill stödja."

#: ../../library/ssl.rst:963
msgid ""
"Whether the OpenSSL library has built-in support for the SSL 2.0 protocol."
msgstr "Om OpenSSL-biblioteket har inbyggt stöd för SSL 2.0-protokollet."

#: ../../library/ssl.rst:969
msgid ""
"Whether the OpenSSL library has built-in support for the SSL 3.0 protocol."
msgstr "Om OpenSSL-biblioteket har inbyggt stöd för SSL 3.0-protokollet."

#: ../../library/ssl.rst:975
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.0 protocol."
msgstr "Om OpenSSL-biblioteket har inbyggt stöd för TLS 1.0-protokollet."

#: ../../library/ssl.rst:981
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.1 protocol."
msgstr "Om OpenSSL-biblioteket har inbyggt stöd för TLS 1.1-protokollet."

#: ../../library/ssl.rst:987
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.2 protocol."
msgstr "Om OpenSSL-biblioteket har inbyggt stöd för TLS 1.2-protokollet."

#: ../../library/ssl.rst:993
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.3 protocol."
msgstr "Om OpenSSL-biblioteket har inbyggt stöd för TLS 1.3-protokollet."

#: ../../library/ssl.rst:999
msgid ""
"List of supported TLS channel binding types.  Strings in this list can be "
"used as arguments to :meth:`SSLSocket.get_channel_binding`."
msgstr ""
"Lista över TLS-kanalbindningstyper som stöds.  Strängar i den här listan kan"
" användas som argument för :meth:`SSLSocket.get_channel_binding`."

#: ../../library/ssl.rst:1006
msgid "The version string of the OpenSSL library loaded by the interpreter::"
msgstr "Versionssträngen för OpenSSL-biblioteket som läses in av tolken::"

#: ../../library/ssl.rst:1015
msgid ""
"A tuple of five integers representing version information about the OpenSSL "
"library::"
msgstr ""
"En tupel med fem heltal som representerar versionsinformation om OpenSSL-"
"biblioteket::"

#: ../../library/ssl.rst:1025
msgid "The raw version number of the OpenSSL library, as a single integer::"
msgstr "Det råa versionsnumret för OpenSSL-biblioteket, som ett enda heltal::"

#: ../../library/ssl.rst:1038
msgid ""
"Alert Descriptions from :rfc:`5246` and others. The `IANA TLS Alert Registry"
" <https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-"
"parameters-6>`_ contains this list and references to the RFCs where their "
"meaning is defined."
msgstr ""
"Varningsbeskrivningar från :rfc:`5246` och andra. Registret `IANA TLS Alert "
"Registry <https://www.iana.org/assignments/tls-parameters/tls-"
"parameters.xml#tls-parameters-6>`_ innehåller denna lista och referenser "
"till de RFC:er där deras betydelse definieras."

#: ../../library/ssl.rst:1042
msgid ""
"Used as the return value of the callback function in "
":meth:`SSLContext.set_servername_callback`."
msgstr ""
"Används som returvärde för callback-funktionen i "
":meth:`SSLContext.set_servername_callback`."

#: ../../library/ssl.rst:1049
msgid ":class:`enum.IntEnum` collection of ALERT_DESCRIPTION_* constants."
msgstr ":class:`enum.IntEnum` samling av ALERT_DESCRIPTION_*-konstanter."

#: ../../library/ssl.rst:1055
msgid ""
"Option for :func:`create_default_context` and "
":meth:`SSLContext.load_default_certs`.  This value indicates that the "
"context may be used to authenticate web servers (therefore, it will be used "
"to create client-side sockets)."
msgstr ""
"Alternativ för :func:`create_default_context` och "
":meth:`SSLContext.load_default_certs`.  Detta värde anger att kontexten kan "
"användas för att autentisera webbservrar (därför kommer den att användas för"
" att skapa sockets på klientsidan)."

#: ../../library/ssl.rst:1064
msgid ""
"Option for :func:`create_default_context` and "
":meth:`SSLContext.load_default_certs`.  This value indicates that the "
"context may be used to authenticate web clients (therefore, it will be used "
"to create server-side sockets)."
msgstr ""
"Alternativ för :func:`create_default_context` och "
":meth:`SSLContext.load_default_certs`.  Detta värde indikerar att kontexten "
"kan användas för att autentisera webbklienter (därför kommer den att "
"användas för att skapa sockets på serversidan)."

#: ../../library/ssl.rst:1073
msgid ":class:`enum.IntEnum` collection of SSL_ERROR_* constants."
msgstr ":class:`enum.IntEnum` samling av SSL_ERROR_*-konstanter."

#: ../../library/ssl.rst:1079
msgid ""
":class:`enum.IntEnum` collection of SSL and TLS versions for "
":attr:`SSLContext.maximum_version` and :attr:`SSLContext.minimum_version`."
msgstr ""
":class:`enum.IntEnum` samling av SSL- och TLS-versioner för "
":attr:`SSLContext.maximum_version` och :attr:`SSLContext.minimum_version`."

#: ../../library/ssl.rst:1087
msgid ""
"The minimum or maximum supported SSL or TLS version. These are magic "
"constants. Their values don't reflect the lowest and highest available "
"TLS/SSL versions."
msgstr ""
"Den lägsta eller högsta SSL- eller TLS-versionen som stöds. Dessa är magiska"
" konstanter. Deras värden återspeglar inte de lägsta och högsta tillgängliga"
" TLS/SSL-versionerna."

#: ../../library/ssl.rst:1097
msgid "SSL 3.0 to TLS 1.3."
msgstr "SSL 3.0 till TLS 1.3."

#: ../../library/ssl.rst:1101
msgid ""
"All :class:`TLSVersion` members except :attr:`TLSVersion.TLSv1_2` and "
":attr:`TLSVersion.TLSv1_3` are deprecated."
msgstr ""
"Alla :class:`TLSVersion`\\-medlemmar utom :attr:`TLSVersion.TLSv1_2` och "
":attr:`TLSVersion.TLSv1_3` är föråldrade."

#: ../../library/ssl.rst:1106
msgid "SSL Sockets"
msgstr "SSL-uttag"

#: ../../library/ssl.rst:1110
msgid "SSL sockets provide the following methods of :ref:`socket-objects`:"
msgstr "SSL-uttag tillhandahåller följande metoder för :ref:`socket-objects`:"

#: ../../library/ssl.rst:1112
msgid ":meth:`~socket.socket.accept()`"
msgstr ""

#: ../../library/ssl.rst:1113
msgid ":meth:`~socket.socket.bind()`"
msgstr ""

#: ../../library/ssl.rst:1114
msgid ":meth:`~socket.socket.close()`"
msgstr ""

#: ../../library/ssl.rst:1115
msgid ":meth:`~socket.socket.connect()`"
msgstr ""

#: ../../library/ssl.rst:1116
msgid ":meth:`~socket.socket.detach()`"
msgstr ""

#: ../../library/ssl.rst:1117
msgid ":meth:`~socket.socket.fileno()`"
msgstr ""

#: ../../library/ssl.rst:1118
msgid ""
":meth:`~socket.socket.getpeername()`, :meth:`~socket.socket.getsockname()`"
msgstr ""

#: ../../library/ssl.rst:1119
msgid ""
":meth:`~socket.socket.getsockopt()`, :meth:`~socket.socket.setsockopt()`"
msgstr ""

#: ../../library/ssl.rst:1120
msgid ""
":meth:`~socket.socket.gettimeout()`, :meth:`~socket.socket.settimeout()`, "
":meth:`~socket.socket.setblocking()`"
msgstr ""

#: ../../library/ssl.rst:1122
msgid ":meth:`~socket.socket.listen()`"
msgstr ""

#: ../../library/ssl.rst:1123
msgid ":meth:`~socket.socket.makefile()`"
msgstr ""

#: ../../library/ssl.rst:1124
msgid ""
":meth:`~socket.socket.recv()`, :meth:`~socket.socket.recv_into()` (but "
"passing a non-zero ``flags`` argument is not allowed)"
msgstr ""

#: ../../library/ssl.rst:1126
msgid ""
":meth:`~socket.socket.send()`, :meth:`~socket.socket.sendall()` (with the "
"same limitation)"
msgstr ""

#: ../../library/ssl.rst:1128
msgid ""
":meth:`~socket.socket.sendfile()` (but :mod:`os.sendfile` will be used for "
"plain-text sockets only, else :meth:`~socket.socket.send()` will be used)"
msgstr ""

#: ../../library/ssl.rst:1130
msgid ":meth:`~socket.socket.shutdown()`"
msgstr ""

#: ../../library/ssl.rst:1132
msgid ""
"However, since the SSL (and TLS) protocol has its own framing atop of TCP, "
"the SSL sockets abstraction can, in certain respects, diverge from the "
"specification of normal, OS-level sockets.  See especially the :ref:`notes "
"on non-blocking sockets <ssl-nonblocking>`."
msgstr ""
"Men eftersom SSL- (och TLS-) protokollet har sin egen inramning ovanpå TCP, "
"kan abstraktionen för SSL-uttag i vissa avseenden avvika från "
"specifikationen för normala uttag på OS-nivå.  Se särskilt "
":ref:`anmärkningar om icke-blockerande uttag <ssl-nonblocking>`."

#: ../../library/ssl.rst:1137
msgid ""
"Instances of :class:`SSLSocket` must be created using the "
":meth:`SSLContext.wrap_socket` method."
msgstr ""
"Instanser av :class:`SSLSocket` måste skapas med hjälp av "
":meth:`SSLContext.wrap_socket`\\-metoden."

#: ../../library/ssl.rst:1140
msgid "The :meth:`sendfile` method was added."
msgstr "Metoden :meth:`sendfile` lades till."

#: ../../library/ssl.rst:1143
msgid ""
"The :meth:`shutdown` does not reset the socket timeout each time bytes are "
"received or sent. The socket timeout is now the maximum total duration of "
"the shutdown."
msgstr ""
":meth:`shutdown` nollställer inte socket timeout varje gång bytes tas emot "
"eller skickas. Socket timeout är nu den maximala totala varaktigheten för "
"avstängningen."

#: ../../library/ssl.rst:1148
msgid ""
"It is deprecated to create a :class:`SSLSocket` instance directly, use "
":meth:`SSLContext.wrap_socket` to wrap a socket."
msgstr ""
"Det är inte längre aktuellt att skapa en :class:`SSLSocket`\\-instans "
"direkt, använd :meth:`SSLContext.wrap_socket` för att omsluta en socket."

#: ../../library/ssl.rst:1152
msgid ""
":class:`SSLSocket` instances must to created with "
":meth:`~SSLContext.wrap_socket`. In earlier versions, it was possible to "
"create instances directly. This was never documented or officially "
"supported."
msgstr ""
":class:`SSLSocket`\\-instanser måste skapas med "
":meth:`~SSLContext.wrap_socket`. I tidigare versioner var det möjligt att "
"skapa instanser direkt. Detta var aldrig dokumenterat eller officiellt "
"stöttat."

#: ../../library/ssl.rst:1158
msgid ""
"Python now uses ``SSL_read_ex`` and ``SSL_write_ex`` internally. The "
"functions support reading and writing of data larger than 2 GB. Writing "
"zero-length data no longer fails with a protocol violation error."
msgstr ""
"Python använder nu ``SSL_read_ex`` och ``SSL_write_ex`` internt. "
"Funktionerna stöder läsning och skrivning av data som är större än 2 GB. "
"Skrivning av noll-längdsdata misslyckas inte längre med ett "
"protokollöverträdelsefel."

#: ../../library/ssl.rst:1163
msgid "SSL sockets also have the following additional methods and attributes:"
msgstr "SSL-uttag har också följande ytterligare metoder och attribut:"

#: ../../library/ssl.rst:1167
msgid ""
"Read up to *len* bytes of data from the SSL socket and return the result as "
"a ``bytes`` instance. If *buffer* is specified, then read into the buffer "
"instead, and return the number of bytes read."
msgstr ""
"Läser upp till *len* byte data från SSL-socket och returnerar resultatet som"
" en ``bytes``\\-instans. Om *buffer* anges läses data in i bufferten i "
"stället och antalet lästa byte returneras."

#: ../../library/ssl.rst:1171
msgid ""
"Raise :exc:`SSLWantReadError` or :exc:`SSLWantWriteError` if the socket is "
":ref:`non-blocking <ssl-nonblocking>` and the read would block."
msgstr ""
"Utlös :exc:`SSLWantReadError` eller :exc:`SSLWantWriteError` om uttaget är "
":ref:`icke-blockerande <ssl-nonblocking>` och läsningen skulle blockera."

#: ../../library/ssl.rst:1174
msgid ""
"As at any time a re-negotiation is possible, a call to :meth:`read` can also"
" cause write operations."
msgstr ""
"Eftersom en omförhandling kan ske när som helst kan ett anrop till "
":meth:`read` också orsaka skrivoperationer."

#: ../../library/ssl.rst:1177
msgid ""
"The socket timeout is no longer reset each time bytes are received or sent. "
"The socket timeout is now the maximum total duration to read up to *len* "
"bytes."
msgstr ""
"Timeouten för uttaget återställs inte längre varje gång byte tas emot eller "
"skickas. Socket timeout är nu den maximala totala tiden det tar att läsa upp"
" till *len* bytes."

#: ../../library/ssl.rst:1182
msgid "Use :meth:`~SSLSocket.recv` instead of :meth:`~SSLSocket.read`."
msgstr "Använd :meth:`~SSLSocket.recv` istället för :meth:`~SSLSocket.read`."

#: ../../library/ssl.rst:1187
msgid ""
"Write *buf* to the SSL socket and return the number of bytes written. The "
"*buf* argument must be an object supporting the buffer interface."
msgstr ""
"Skriv *buf* till SSL-socket och returnera antalet byte som skrivits. "
"Argumentet *buf* måste vara ett objekt som stöder buffertgränssnittet."

#: ../../library/ssl.rst:1190
msgid ""
"Raise :exc:`SSLWantReadError` or :exc:`SSLWantWriteError` if the socket is "
":ref:`non-blocking <ssl-nonblocking>` and the write would block."
msgstr ""
"Utlös :exc:`SSLWantReadError` eller :exc:`SSLWantWriteError` om uttaget är "
":ref:`non-blocking <ssl-nonblocking>` och skrivningen skulle blockera."

#: ../../library/ssl.rst:1193
msgid ""
"As at any time a re-negotiation is possible, a call to :meth:`write` can "
"also cause read operations."
msgstr ""
"Eftersom en omförhandling kan ske när som helst kan ett anrop till "
":meth:`write` också orsaka läsoperationer."

#: ../../library/ssl.rst:1196
msgid ""
"The socket timeout is no longer reset each time bytes are received or sent. "
"The socket timeout is now the maximum total duration to write *buf*."
msgstr ""
"Timeout för socket nollställs inte längre varje gång byte tas emot eller "
"skickas. Timeouten för uttaget är nu den maximala totala tiden det tar att "
"skriva *buf*."

#: ../../library/ssl.rst:1200
msgid "Use :meth:`~SSLSocket.send` instead of :meth:`~SSLSocket.write`."
msgstr "Använd :meth:`~SSLSocket.send` istället för :meth:`~SSLSocket.write`."

#: ../../library/ssl.rst:1205
msgid ""
"The :meth:`~SSLSocket.read` and :meth:`~SSLSocket.write` methods are the "
"low-level methods that read and write unencrypted, application-level data "
"and decrypt/encrypt it to encrypted, wire-level data. These methods require "
"an active SSL connection, i.e. the handshake was completed and "
":meth:`SSLSocket.unwrap` was not called."
msgstr ""
"Metoderna :meth:`~SSLSocket.read` och :meth:`~SSLSocket.write` är "
"lågnivåmetoder som läser och skriver okrypterade data på applikationsnivå "
"och dekrypterar/krypterar dem till krypterade data på trådnivå. Dessa "
"metoder kräver en aktiv SSL-anslutning, dvs. handskakningen har slutförts "
"och :meth:`SSLSocket.unwrap` har inte anropats."

#: ../../library/ssl.rst:1211
msgid ""
"Normally you should use the socket API methods like "
":meth:`~socket.socket.recv` and :meth:`~socket.socket.send` instead of these"
" methods."
msgstr ""
"Normalt bör du använda Socket API-metoder som :meth:`~socket.socket.recv` "
"och :meth:`~socket.socket.send` istället för dessa metoder."

#: ../../library/ssl.rst:1217
msgid "Perform the SSL setup handshake."
msgstr "Utför handskakningen för SSL-installationen."

#: ../../library/ssl.rst:1219
msgid ""
"The handshake method also performs :func:`match_hostname` when the "
":attr:`~SSLContext.check_hostname` attribute of the socket's "
":attr:`~SSLSocket.context` is true."
msgstr ""
"Handskakningsmetoden utför också :func:`match_hostname` när attributet "
":attr:`~SSLContext.check_hostname` i socketens :attr:`~SSLSocket.context` är"
" true."

#: ../../library/ssl.rst:1224
msgid ""
"The socket timeout is no longer reset each time bytes are received or sent. "
"The socket timeout is now the maximum total duration of the handshake."
msgstr ""
"Timeout för socket återställs inte längre varje gång byte tas emot eller "
"skickas. Timeouten för uttaget är nu den maximala totala varaktigheten för "
"handskakningen."

#: ../../library/ssl.rst:1228
msgid ""
"Hostname or IP address is matched by OpenSSL during handshake. The function "
":func:`match_hostname` is no longer used. In case OpenSSL refuses a hostname"
" or IP address, the handshake is aborted early and a TLS alert message is "
"sent to the peer."
msgstr ""
"Värdnamn eller IP-adress matchas av OpenSSL under handskakning. Funktionen "
":func:`match_hostname` används inte längre. Om OpenSSL vägrar ett värdnamn "
"eller en IP-adress avbryts handskakningen i förtid och ett TLS-"
"varningsmeddelande skickas till motparten."

#: ../../library/ssl.rst:1236
msgid ""
"If there is no certificate for the peer on the other end of the connection, "
"return ``None``.  If the SSL handshake hasn't been done yet, raise "
":exc:`ValueError`."
msgstr ""
"Om det inte finns något certifikat för motparten i den andra änden av "
"anslutningen returneras ``None``.  Om SSL-handskakningen inte har gjorts "
"ännu, returneras :exc:`ValueError`."

#: ../../library/ssl.rst:1240
msgid ""
"If the ``binary_form`` parameter is :const:`False`, and a certificate was "
"received from the peer, this method returns a :class:`dict` instance.  If "
"the certificate was not validated, the dict is empty.  If the certificate "
"was validated, it returns a dict with several keys, amongst them ``subject``"
" (the principal for which the certificate was issued) and ``issuer`` (the "
"principal issuing the certificate).  If a certificate contains an instance "
"of the *Subject Alternative Name* extension (see :rfc:`3280`), there will "
"also be a ``subjectAltName`` key in the dictionary."
msgstr ""
"Om parametern ``binary_form`` är :const:`False`, och ett certifikat har "
"mottagits från motparten, returnerar denna metod en :class:`dict`\\-instans."
"  Om certifikatet inte validerades är dict tomt.  Om certifikatet "
"validerades returneras en dict med flera nycklar, bland annat ``subject`` "
"(den huvudman för vilken certifikatet utfärdades) och ``issuer`` (den "
"huvudman som utfärdar certifikatet).  Om ett certifikat innehåller en "
"instans av tillägget *Subject Alternative Name* (se :rfc:`3280`), kommer det"
" också att finnas en nyckel ``subjectAltName`` i ordlistan."

#: ../../library/ssl.rst:1249
msgid ""
"The ``subject`` and ``issuer`` fields are tuples containing the sequence of "
"relative distinguished names (RDNs) given in the certificate's data "
"structure for the respective fields, and each RDN is a sequence of name-"
"value pairs.  Here is a real-world example::"
msgstr ""
"Fälten ``subject`` och ``issuer`` är tupler som innehåller den sekvens av "
"RDN (relative distinguished names) som anges i certifikatets datastruktur "
"för respektive fält, och varje RDN är en sekvens av namn-värdepar.  Här är "
"ett exempel från den verkliga världen::"

#: ../../library/ssl.rst:1275
msgid ""
"To validate a certificate for a particular service, you can use the "
":func:`match_hostname` function."
msgstr ""

#: ../../library/ssl.rst:1278
msgid ""
"If the ``binary_form`` parameter is :const:`True`, and a certificate was "
"provided, this method returns the DER-encoded form of the entire certificate"
" as a sequence of bytes, or :const:`None` if the peer did not provide a "
"certificate.  Whether the peer provides a certificate depends on the SSL "
"socket's role:"
msgstr ""
"Om parametern ``binary_form`` är :const:`True`` och ett certifikat har "
"tillhandahållits, returnerar denna metod den DER-kodade formen av hela "
"certifikatet som en sekvens av bytes, eller :const:`None` om motparten inte "
"har tillhandahållit något certifikat.  Om motparten tillhandahåller ett "
"certifikat beror på SSL-uttagets roll:"

#: ../../library/ssl.rst:1284
msgid ""
"for a client SSL socket, the server will always provide a certificate, "
"regardless of whether validation was required;"
msgstr ""
"för ett SSL-uttag från en klient kommer servern alltid att tillhandahålla "
"ett certifikat, oavsett om validering krävdes eller inte;"

#: ../../library/ssl.rst:1287
msgid ""
"for a server SSL socket, the client will only provide a certificate when "
"requested by the server; therefore :meth:`getpeercert` will return "
":const:`None` if you used :const:`CERT_NONE` (rather than "
":const:`CERT_OPTIONAL` or :const:`CERT_REQUIRED`)."
msgstr ""
"för ett SSL-uttag på en server kommer klienten endast att tillhandahålla ett"
" certifikat när servern begär det; därför kommer :meth:`getpeercert` att "
"returnera :const:`None` om du använde :const:`CERT_NONE` (i stället för "
":const:`CERT_OPTIONAL` eller :const:`CERT_REQUIRED`)."

#: ../../library/ssl.rst:1292
msgid ""
"The returned dictionary includes additional items such as ``issuer`` and "
"``notBefore``."
msgstr ""
"Den returnerade ordlistan innehåller ytterligare objekt som ``issuer`` och "
"``notBefore``."

#: ../../library/ssl.rst:1296
msgid ""
":exc:`ValueError` is raised when the handshake isn't done. The returned "
"dictionary includes additional X509v3 extension items   such as "
"``crlDistributionPoints``, ``caIssuers`` and ``OCSP`` URIs."
msgstr ""
":exc:`ValueError` utlöses när handskakningen inte är klar. Den returnerade "
"ordlistan innehåller ytterligare X509v3-tilläggsobjekt såsom "
"``crlDistributionPoints``, ``caIssuers`` och ``OCSP`` URI:er."

#: ../../library/ssl.rst:1301
msgid "IPv6 address strings no longer have a trailing new line."
msgstr "IPv6-adresssträngar har inte längre någon efterföljande ny rad."

#: ../../library/ssl.rst:1306
msgid ""
"Returns a three-value tuple containing the name of the cipher being used, "
"the version of the SSL protocol that defines its use, and the number of "
"secret bits being used.  If no connection has been established, returns "
"``None``."
msgstr ""
"Returnerar en tupel med tre värden som innehåller namnet på det chiffer som "
"används, den version av SSL-protokollet som definierar dess användning och "
"antalet hemliga bitar som används.  Om ingen anslutning har upprättats, "
"returneras ``None``."

#: ../../library/ssl.rst:1312
msgid ""
"Return the list of ciphers available in both the client and server.  Each "
"entry of the returned list is a three-value tuple containing the name of the"
" cipher, the version of the SSL protocol that defines its use, and the "
"number of secret bits the cipher uses.  :meth:`~SSLSocket.shared_ciphers` "
"returns ``None`` if no connection has been established or the socket is a "
"client socket."
msgstr ""
"Returnerar listan över chiffer som är tillgängliga i både klienten och "
"servern.  Varje post i den returnerade listan är en tupel med tre värden som"
" innehåller namnet på chiffret, den version av SSL-protokollet som "
"definierar dess användning och antalet hemliga bitar som chiffret använder. "
":meth:`~SSLSocket.shared_ciphers` returnerar ``None`` om ingen anslutning "
"har upprättats eller om uttaget är ett klientuttag."

#: ../../library/ssl.rst:1323
msgid ""
"Return the compression algorithm being used as a string, or ``None`` if the "
"connection isn't compressed."
msgstr ""
"Returnerar den komprimeringsalgoritm som används som en sträng, eller "
"``None`` om anslutningen inte komprimeras."

#: ../../library/ssl.rst:1326
msgid ""
"If the higher-level protocol supports its own compression mechanism, you can"
" use :data:`OP_NO_COMPRESSION` to disable SSL-level compression."
msgstr ""
"Om protokollet på högre nivå stöder sin egen komprimeringsmekanism kan du "
"använda :data:`OP_NO_COMPRESSION` för att inaktivera komprimering på SSL-"
"nivå."

#: ../../library/ssl.rst:1333
msgid ""
"Get channel binding data for current connection, as a bytes object.  Returns"
" ``None`` if not connected or the handshake has not been completed."
msgstr ""
"Hämta kanalbindningsdata för aktuell anslutning, som ett bytesobjekt.  "
"Returnerar ``None`` om ingen anslutning finns eller om handskakningen inte "
"har slutförts."

#: ../../library/ssl.rst:1336
msgid ""
"The *cb_type* parameter allow selection of the desired channel binding type."
" Valid channel binding types are listed in the :data:`CHANNEL_BINDING_TYPES`"
" list.  Currently only the 'tls-unique' channel binding, defined by "
":rfc:`5929`, is supported.  :exc:`ValueError` will be raised if an "
"unsupported channel binding type is requested."
msgstr ""
"Parametern *cb_type* gör det möjligt att välja önskad kanalbindningstyp. "
"Giltiga kanalbindningstyper listas i listan :data:`CHANNEL_BINDING_TYPES`.  "
"För närvarande stöds endast kanalbindningen 'tls-unique', definierad av "
":rfc:`5929`. :exc:`ValueError` kommer att uppstå om en kanalbindningstyp som"
" inte stöds begärs."

#: ../../library/ssl.rst:1346
msgid ""
"Return the protocol that was selected during the TLS handshake.  If "
":meth:`SSLContext.set_alpn_protocols` was not called, if the other party "
"does not support ALPN, if this socket does not support any of the client's "
"proposed protocols, or if the handshake has not happened yet, ``None`` is "
"returned."
msgstr ""
"Returnerar det protokoll som valdes under TLS-handskakningen.  Om "
":meth:`SSLContext.set_alpn_protocols` inte anropades, om den andra parten "
"inte stöder ALPN, om detta uttag inte stöder något av klientens föreslagna "
"protokoll, eller om handskakningen inte har skett ännu, returneras ``None``."

#: ../../library/ssl.rst:1356
msgid ""
"Return the higher-level protocol that was selected during the TLS/SSL "
"handshake. If :meth:`SSLContext.set_npn_protocols` was not called, or if the"
" other party does not support NPN, or if the handshake has not yet happened,"
" this will return ``None``."
msgstr ""
"Returnerar det protokoll på högre nivå som valdes under TLS/SSL-"
"handskakningen. Om :meth:`SSLContext.set_npn_protocols` inte anropades, "
"eller om den andra parten inte stöder NPN, eller om handskakningen ännu inte"
" har skett, kommer detta att returnera ``None``."

#: ../../library/ssl.rst:1365 ../../library/ssl.rst:1725
msgid "NPN has been superseded by ALPN"
msgstr "NPN har ersatts av ALPN"

#: ../../library/ssl.rst:1369
msgid ""
"Performs the SSL shutdown handshake, which removes the TLS layer from the "
"underlying socket, and returns the underlying socket object.  This can be "
"used to go from encrypted operation over a connection to unencrypted.  The "
"returned socket should always be used for further communication with the "
"other side of the connection, rather than the original socket."
msgstr ""
"Utför SSL-avstängningshandskakningen, som tar bort TLS-lagret från det "
"underliggande uttaget, och returnerar det underliggande uttagsobjektet.  "
"Detta kan användas för att gå från krypterad drift över en anslutning till "
"okrypterad.  Det returnerade uttaget bör alltid användas för vidare "
"kommunikation med den andra sidan av anslutningen, snarare än det "
"ursprungliga uttaget."

#: ../../library/ssl.rst:1377
msgid ""
"Requests post-handshake authentication (PHA) from a TLS 1.3 client. PHA can "
"only be initiated for a TLS 1.3 connection from a server-side socket, after "
"the initial TLS handshake and with PHA enabled on both sides, see "
":attr:`SSLContext.post_handshake_auth`."
msgstr ""
"Begär PHA (post-handshake authentication) från en TLS 1.3-klient. PHA kan "
"endast initieras för en TLS 1.3-anslutning från ett server-sidesockel, efter"
" den inledande TLS-handskakningen och med PHA aktiverat på båda sidor, se "
":attr:`SSLContext.post_handshake_auth`."

#: ../../library/ssl.rst:1382
msgid ""
"The method does not perform a cert exchange immediately. The server-side "
"sends a CertificateRequest during the next write event and expects the "
"client to respond with a certificate on the next read event."
msgstr ""
"Metoden utför inte ett cert-utbyte omedelbart. Serversidan skickar en "
"CertificateRequest vid nästa skrivhändelse och förväntar sig att klienten "
"svarar med ett certifikat vid nästa läshändelse."

#: ../../library/ssl.rst:1386
msgid ""
"If any precondition isn't met (e.g. not TLS 1.3, PHA not enabled), an "
":exc:`SSLError` is raised."
msgstr ""
"Om något förhandsvillkor inte uppfylls (t.ex. inte TLS 1.3, PHA inte "
"aktiverat), utlöses ett :exc:`SSLError`."

#: ../../library/ssl.rst:1390
msgid ""
"Only available with OpenSSL 1.1.1 and TLS 1.3 enabled. Without TLS 1.3 "
"support, the method raises :exc:`NotImplementedError`."
msgstr ""
"Endast tillgänglig med OpenSSL 1.1.1 och TLS 1.3 aktiverat. Utan stöd för "
"TLS 1.3 ger metoden upphov till :exc:`NotImplementedError`."

#: ../../library/ssl.rst:1397
msgid ""
"Return the actual SSL protocol version negotiated by the connection as a "
"string, or ``None`` if no secure connection is established. As of this "
"writing, possible return values include ``\"SSLv2\"``, ``\"SSLv3\"``, "
"``\"TLSv1\"``, ``\"TLSv1.1\"`` and ``\"TLSv1.2\"``. Recent OpenSSL versions "
"may define more return values."
msgstr ""
"Returnerar den faktiska SSL-protokollversionen som förhandlats fram av "
"anslutningen som en sträng, eller ``None`` om ingen säker anslutning "
"upprättas. I skrivande stund inkluderar möjliga returvärden ``\"SSLv2\"``, "
"``\"SSLv3\"``, ``\"TLSv1\"``, ``\"TLSv1.1\"`` och ``\"TLSv1.2\"``. Nyare "
"OpenSSL-versioner kan definiera fler returvärden."

#: ../../library/ssl.rst:1407
msgid ""
"Returns the number of already decrypted bytes available for read, pending on"
" the connection."
msgstr ""
"Returnerar antalet redan dekrypterade bytes som är tillgängliga för läsning,"
" i väntan på anslutningen."

#: ../../library/ssl.rst:1412
msgid ""
"The :class:`SSLContext` object this SSL socket is tied to.  If the SSL "
"socket was created using the deprecated :func:`wrap_socket` function (rather"
" than :meth:`SSLContext.wrap_socket`), this is a custom context object "
"created for this SSL socket."
msgstr ""

#: ../../library/ssl.rst:1421
msgid ""
"A boolean which is ``True`` for server-side sockets and ``False`` for "
"client-side sockets."
msgstr ""
"En boolean som är ``True`` för server-sidans uttag och ``False`` för klient-"
"sidans uttag."

#: ../../library/ssl.rst:1428
msgid ""
"Hostname of the server: :class:`str` type, or ``None`` for server-side "
"socket or if the hostname was not specified in the constructor."
msgstr ""
"Värdnamn för servern: :class:`str`\\-typ, eller ``None`` för server-side "
"socket eller om värdnamnet inte angavs i konstruktören."

#: ../../library/ssl.rst:1433
msgid ""
"The attribute is now always ASCII text. When ``server_hostname`` is an "
"internationalized domain name (IDN), this attribute now stores the A-label "
"form (``\"xn--pythn-mua.org\"``), rather than the U-label form "
"(``\"pythön.org\"``)."
msgstr ""
"Attributet är nu alltid ASCII-text. När ``server_hostname`` är ett "
"internationaliserat domännamn (IDN) lagrar detta attribut nu "
"A-märkningsformen (``\"xn--pythn-mua.org\"``) i stället för "
"U-märkningsformen (``\"pythön.org\"``)."

#: ../../library/ssl.rst:1441
msgid ""
"The :class:`SSLSession` for this SSL connection. The session is available "
"for client and server side sockets after the TLS handshake has been "
"performed. For client sockets the session can be set before "
":meth:`~SSLSocket.do_handshake` has been called to reuse a session."
msgstr ""
":class:`SSLSession` för denna SSL-anslutning. Sessionen är tillgänglig för "
"uttag på klient- och serversidan efter att TLS-handskakningen har utförts. "
"För klientuttag kan sessionen ställas in innan "
":meth:`~SSLSocket.do_handshake` har anropats för att återanvända en session."

#: ../../library/ssl.rst:1454
msgid "SSL Contexts"
msgstr "SSL-kontexter"

#: ../../library/ssl.rst:1458
msgid ""
"An SSL context holds various data longer-lived than single SSL connections, "
"such as SSL configuration options, certificate(s) and private key(s). It "
"also manages a cache of SSL sessions for server-side sockets, in order to "
"speed up repeated connections from the same clients."
msgstr ""
"En SSL-kontext innehåller olika data som är mer långlivade än enskilda SSL-"
"anslutningar, t.ex. SSL-konfigurationsalternativ, certifikat och privata "
"nycklar. Den hanterar också en cache för SSL-sessioner för uttag på "
"serversidan, för att snabba upp upprepade anslutningar från samma klienter."

#: ../../library/ssl.rst:1465
msgid ""
"Create a new SSL context.  You may pass *protocol* which must be one of the "
"``PROTOCOL_*`` constants defined in this module.  The parameter specifies "
"which version of the SSL protocol to use.  Typically, the server chooses a "
"particular protocol version, and the client must adapt to the server's "
"choice.  Most of the versions are not interoperable with the other versions."
"  If not specified, the default is :data:`PROTOCOL_TLS`; it provides the "
"most compatibility with other versions."
msgstr ""
"Skapa en ny SSL-kontext.  Du kan skicka *protocol* som måste vara en av "
"``PROTOCOL_*``\\-konstanterna som definieras i den här modulen.  Parametern "
"anger vilken version av SSL-protokollet som ska användas.  Vanligtvis väljer"
" servern en viss protokollversion och klienten måste anpassa sig till "
"serverns val.  De flesta av versionerna är inte kompatibla med andra "
"versioner.  Om inget anges är standardvärdet :data:`PROTOCOL_TLS`; det ger "
"störst kompatibilitet med andra versioner."

#: ../../library/ssl.rst:1474
msgid ""
"Here's a table showing which versions in a client (down the side) can "
"connect to which versions in a server (along the top):"
msgstr ""
"Här är en tabell som visar vilka versioner i en klient (längst ned på sidan)"
" som kan ansluta till vilka versioner i en server (längst upp):"

#: ../../library/ssl.rst:1480
msgid "*client* / **server**"
msgstr "*klient* / **server**"

#: ../../library/ssl.rst:1480
msgid "**SSLv2**"
msgstr "**SSLv2**"

#: ../../library/ssl.rst:1480
msgid "**SSLv3**"
msgstr "**SSLv3**"

#: ../../library/ssl.rst:1480
msgid "**TLS** [3]_"
msgstr "**TLS** [3]_ _TLS"

#: ../../library/ssl.rst:1480
msgid "**TLSv1**"
msgstr "**TLSv1**"

#: ../../library/ssl.rst:1480
msgid "**TLSv1.1**"
msgstr "**TLSv1.1**"

#: ../../library/ssl.rst:1480
msgid "**TLSv1.2**"
msgstr "**TLSv1.2**"

#: ../../library/ssl.rst:1482
msgid "*SSLv2*"
msgstr "*SSLv2*"

#: ../../library/ssl.rst:1482 ../../library/ssl.rst:1483
#: ../../library/ssl.rst:1484 ../../library/ssl.rst:1485
#: ../../library/ssl.rst:1486 ../../library/ssl.rst:1487
msgid "yes"
msgstr "ja"

#: ../../library/ssl.rst:1482 ../../library/ssl.rst:1483
#: ../../library/ssl.rst:1485 ../../library/ssl.rst:1486
#: ../../library/ssl.rst:1487
msgid "no"
msgstr "nej"

#: ../../library/ssl.rst:1482 ../../library/ssl.rst:1484
msgid "no [1]_"
msgstr "no [1]_"

#: ../../library/ssl.rst:1483
msgid "*SSLv3*"
msgstr "*SSLv3*"

#: ../../library/ssl.rst:1483 ../../library/ssl.rst:1484
msgid "no [2]_"
msgstr "no [2]_"

#: ../../library/ssl.rst:1484
msgid "*TLS* (*SSLv23*) [3]_"
msgstr "*TLS* (*SSLv23*) [3]_"

#: ../../library/ssl.rst:1485
msgid "*TLSv1*"
msgstr "*TLSv1*"

#: ../../library/ssl.rst:1486
msgid "*TLSv1.1*"
msgstr "*TLSv1.1*"

#: ../../library/ssl.rst:1487
msgid "*TLSv1.2*"
msgstr "*TLSv1.2*"

#: ../../library/ssl.rst:1490
msgid "Footnotes"
msgstr "Fotnoter"

#: ../../library/ssl.rst:1491
msgid ""
":class:`SSLContext` disables SSLv2 with :data:`OP_NO_SSLv2` by default."
msgstr ""
":class:`SSLContext` inaktiverar SSLv2 med :data:`OP_NO_SSLv2` som standard."

#: ../../library/ssl.rst:1492
msgid ""
":class:`SSLContext` disables SSLv3 with :data:`OP_NO_SSLv3` by default."
msgstr ""
":class:`SSLContext` inaktiverar SSLv3 med :data:`OP_NO_SSLv3` som standard."

#: ../../library/ssl.rst:1493
msgid ""
"TLS 1.3 protocol will be available with :data:`PROTOCOL_TLS` in OpenSSL >= "
"1.1.1. There is no dedicated PROTOCOL constant for just TLS 1.3."
msgstr ""
"TLS 1.3-protokollet kommer att vara tillgängligt med :data:`PROTOCOL_TLS` i "
"OpenSSL >= 1.1.1. Det finns ingen dedikerad PROTOCOL-konstant för just TLS "
"1.3."

#: ../../library/ssl.rst:1498
msgid ""
":func:`create_default_context` lets the :mod:`ssl` module choose security "
"settings for a given purpose."
msgstr ""
":func:`create_default_context` låter :mod:`ssl`\\-modulen välja "
"säkerhetsinställningar för ett visst syfte."

#: ../../library/ssl.rst:1503
msgid ""
"The context is created with secure default values. The options "
":data:`OP_NO_COMPRESSION`, :data:`OP_CIPHER_SERVER_PREFERENCE`, "
":data:`OP_SINGLE_DH_USE`, :data:`OP_SINGLE_ECDH_USE`, :data:`OP_NO_SSLv2` "
"(except for :data:`PROTOCOL_SSLv2`), and :data:`OP_NO_SSLv3` (except for "
":data:`PROTOCOL_SSLv3`) are set by default. The initial cipher suite list "
"contains only ``HIGH`` ciphers, no ``NULL`` ciphers and no ``MD5`` ciphers "
"(except for :data:`PROTOCOL_SSLv2`)."
msgstr ""

#: ../../library/ssl.rst:1514
msgid ""
":class:`SSLContext` without protocol argument is deprecated. The context "
"class will either require :data:`PROTOCOL_TLS_CLIENT` or "
":data:`PROTOCOL_TLS_SERVER` protocol in the future."
msgstr ""
":class:`SSLContext` utan protokollargument är föråldrad. Kontextklassen "
"kommer antingen att kräva :data:`PROTOCOL_TLS_CLIENT` eller "
":data:`PROTOCOL_TLS_SERVER` protokoll i framtiden."

#: ../../library/ssl.rst:1520
msgid ""
"The default cipher suites now include only secure AES and ChaCha20 ciphers "
"with forward secrecy and security level 2. RSA and DH keys with less than "
"2048 bits and ECC keys with less than 224 bits are prohibited. "
":data:`PROTOCOL_TLS`, :data:`PROTOCOL_TLS_CLIENT`, and "
":data:`PROTOCOL_TLS_SERVER` use TLS 1.2 as minimum TLS version."
msgstr ""
"Standardchiffersviterna innehåller nu endast säkra AES- och ChaCha20-chiffer"
" med forward secrecy och säkerhetsnivå 2. RSA- och DH-nycklar med mindre än "
"2048 bitar och ECC-nycklar med mindre än 224 bitar är förbjudna. "
":data:`PROTOCOL_TLS`, :data:`PROTOCOL_TLS_CLIENT`, och "
":data:`PROTOCOL_TLS_SERVER` använder TLS 1.2 som minsta TLS-version."

#: ../../library/ssl.rst:1527
msgid ":class:`SSLContext` objects have the following methods and attributes:"
msgstr ":class:`SSLContext`\\-objekt har följande metoder och attribut:"

#: ../../library/ssl.rst:1531
msgid ""
"Get statistics about quantities of loaded X.509 certificates, count of X.509"
" certificates flagged as CA certificates and certificate revocation lists as"
" dictionary."
msgstr ""
"Hämta statistik över antal laddade X.509-certifikat, antal X.509-certifikat "
"som markerats som CA-certifikat och spärrlistor som ordlista."

#: ../../library/ssl.rst:1535
msgid "Example for a context with one CA cert and one other cert::"
msgstr "Exempel för en kontext med ett CA-cert och ett annat cert::"

#: ../../library/ssl.rst:1545
msgid ""
"Load a private key and the corresponding certificate.  The *certfile* string"
" must be the path to a single file in PEM format containing the certificate "
"as well as any number of CA certificates needed to establish the "
"certificate's authenticity.  The *keyfile* string, if present, must point to"
" a file containing the private key.  Otherwise the private key will be taken"
" from *certfile* as well.  See the discussion of :ref:`ssl-certificates` for"
" more information on how the certificate is stored in the *certfile*."
msgstr ""
"Läser in en privat nyckel och motsvarande certifikat.  Strängen *certfile* "
"måste vara sökvägen till en enda fil i PEM-format som innehåller "
"certifikatet samt valfritt antal CA-certifikat som behövs för att fastställa"
" certifikatets äkthet.  Strängen *keyfile* måste, om den finns, peka på en "
"fil som innehåller den privata nyckeln.  I annat fall hämtas den privata "
"nyckeln även från *certfile*.  Se diskussionen i :ref:`ssl-certificates` för"
" mer information om hur certifikatet lagras i *certfile*."

#: ../../library/ssl.rst:1554
msgid ""
"The *password* argument may be a function to call to get the password for "
"decrypting the private key.  It will only be called if the private key is "
"encrypted and a password is necessary.  It will be called with no arguments,"
" and it should return a string, bytes, or bytearray.  If the return value is"
" a string it will be encoded as UTF-8 before using it to decrypt the key. "
"Alternatively a string, bytes, or bytearray value may be supplied directly "
"as the *password* argument.  It will be ignored if the private key is not "
"encrypted and no password is needed."
msgstr ""
"Argumentet *password* kan vara en funktion som ska anropas för att få "
"lösenordet för dekryptering av den privata nyckeln.  Funktionen anropas "
"endast om den privata nyckeln är krypterad och ett lösenord är nödvändigt.  "
"Den anropas utan argument och ska returnera en sträng, bytes eller "
"bytearray.  Om returvärdet är en sträng kommer den att kodas som UTF-8 innan"
" den används för att dekryptera nyckeln. Alternativt kan ett värde i form av"
" en sträng, bytes eller bytearray anges direkt som argument för *password*."
"  Det ignoreras om den privata nyckeln inte är krypterad och inget lösenord "
"behövs."

#: ../../library/ssl.rst:1563
msgid ""
"If the *password* argument is not specified and a password is required, "
"OpenSSL's built-in password prompting mechanism will be used to "
"interactively prompt the user for a password."
msgstr ""
"Om argumentet *password* inte anges och ett lösenord krävs, kommer OpenSSL:s"
" inbyggda mekanism för lösenordsuppmaning att användas för att interaktivt "
"uppmana användaren att ange ett lösenord."

#: ../../library/ssl.rst:1567
msgid ""
"An :class:`SSLError` is raised if the private key doesn't match with the "
"certificate."
msgstr ""
"Ett :class:`SSLError` uppstår om den privata nyckeln inte stämmer överens "
"med certifikatet."

#: ../../library/ssl.rst:1570
msgid "New optional argument *password*."
msgstr "Nytt valfritt argument *password*."

#: ../../library/ssl.rst:1575
msgid ""
"Load a set of default \"certification authority\" (CA) certificates from "
"default locations. On Windows it loads CA certs from the ``CA`` and ``ROOT``"
" system stores. On all systems it calls "
":meth:`SSLContext.set_default_verify_paths`. In the future the method may "
"load CA certificates from other locations, too."
msgstr ""
"Ladda en uppsättning standardcertifikat för \"certifikatutfärdare\" (CA) "
"från standardplatser. I Windows laddas CA-certifikat från systemlagren "
"``CA`` och ``ROOT``. På alla system anropar den "
":meth:`SSLContext.set_default_verify_paths`. I framtiden kan metoden komma "
"att ladda CA-certifikat från andra platser också."

#: ../../library/ssl.rst:1581
msgid ""
"The *purpose* flag specifies what kind of CA certificates are loaded. The "
"default settings :const:`Purpose.SERVER_AUTH` loads certificates, that are "
"flagged and trusted for TLS web server authentication (client side sockets)."
" :const:`Purpose.CLIENT_AUTH` loads CA certificates for client certificate "
"verification on the server side."
msgstr ""
"Flaggan *purpose* anger vilken typ av CA-certifikat som läses in. "
"Standardinställningarna :const:`Purpose.SERVER_AUTH` laddar certifikat som "
"är flaggade och betrodda för TLS-autentisering av webbservern (sockets på "
"klientsidan). :const:`Purpose.CLIENT_AUTH` laddar CA-certifikat för "
"verifiering av klientcertifikat på serversidan."

#: ../../library/ssl.rst:1591
msgid ""
"Load a set of \"certification authority\" (CA) certificates used to validate"
" other peers' certificates when :data:`verify_mode` is other than "
":data:`CERT_NONE`.  At least one of *cafile* or *capath* must be specified."
msgstr ""
"Läser in en uppsättning certifikat från \"Certification Authority\" (CA) som"
" används för att validera andra peers certifikat när :data:`verify_mode` är "
"något annat än :data:`CERT_NONE`.  Åtminstone en av *cafile* eller *capath* "
"måste anges."

#: ../../library/ssl.rst:1595
msgid ""
"This method can also load certification revocation lists (CRLs) in PEM or "
"DER format. In order to make use of CRLs, :attr:`SSLContext.verify_flags` "
"must be configured properly."
msgstr ""
"Den här metoden kan också läsa in CRL:er (Certification Revocation List) i "
"PEM- eller DER-format. För att kunna använda CRL:er måste "
":attr:`SSLContext.verify_flags` vara korrekt konfigurerad."

#: ../../library/ssl.rst:1599
msgid ""
"The *cafile* string, if present, is the path to a file of concatenated CA "
"certificates in PEM format. See the discussion of :ref:`ssl-certificates` "
"for more information about how to arrange the certificates in this file."
msgstr ""
"Strängen *cafile*, om den finns, är sökvägen till en fil med sammanlänkade "
"certifikat från certifikatutfärdare i PEM-format. Se diskussionen om "
":ref:`ssl-certificates` för mer information om hur du ordnar certifikaten i "
"den här filen."

#: ../../library/ssl.rst:1604
msgid ""
"The *capath* string, if present, is the path to a directory containing "
"several CA certificates in PEM format, following an `OpenSSL specific layout"
" "
"<https://www.openssl.org/docs/manmaster/man3/SSL_CTX_load_verify_locations.html>`_."
msgstr ""

#: ../../library/ssl.rst:1609
msgid ""
"The *cadata* object, if present, is either an ASCII string of one or more "
"PEM-encoded certificates or a :term:`bytes-like object` of DER-encoded "
"certificates. Like with *capath* extra lines around PEM-encoded certificates"
" are ignored but at least one certificate must be present."
msgstr ""
"Objektet *cadata*, om det finns, är antingen en ASCII-sträng med ett eller "
"flera PEM-kodade certifikat eller ett :term:`bytesliknande objekt` med DER-"
"kodade certifikat. Precis som med *capath* ignoreras extra rader runt PEM-"
"kodade certifikat, men minst ett certifikat måste finnas med."

#: ../../library/ssl.rst:1614
msgid "New optional argument *cadata*"
msgstr "Nytt valfritt argument *cadata*"

#: ../../library/ssl.rst:1619
msgid ""
"Get a list of loaded \"certification authority\" (CA) certificates. If the "
"``binary_form`` parameter is :const:`False` each list entry is a dict like "
"the output of :meth:`SSLSocket.getpeercert`. Otherwise the method returns a "
"list of DER-encoded certificates. The returned list does not contain "
"certificates from *capath* unless a certificate was requested and loaded by "
"a SSL connection."
msgstr ""
"Hämta en lista med laddade certifikat från certifikatutfärdare (CA). Om "
"parametern ``binary_form`` är :const:`False`` är varje post i listan en dikt"
" som utdata från :meth:`SSLSocket.getpeercert`. Annars returnerar metoden en"
" lista med DER-kodade certifikat. Den returnerade listan innehåller inte "
"certifikat från *capath* om inte ett certifikat begärdes och laddades av en "
"SSL-anslutning."

#: ../../library/ssl.rst:1627
msgid ""
"Certificates in a capath directory aren't loaded unless they have been used "
"at least once."
msgstr ""
"Certifikat i en capath-katalog läses inte in om de inte har använts minst en"
" gång."

#: ../../library/ssl.rst:1634
msgid ""
"Get a list of enabled ciphers. The list is in order of cipher priority. See "
":meth:`SSLContext.set_ciphers`."
msgstr ""
"Hämta en lista över aktiverade chiffer. Listan är i ordning efter "
"chifferprioritet. Se :meth:`SSLContext.set_ciphers`."

#: ../../library/ssl.rst:1671
msgid ""
"Load a set of default \"certification authority\" (CA) certificates from a "
"filesystem path defined when building the OpenSSL library.  Unfortunately, "
"there's no easy way to know whether this method succeeds: no error is "
"returned if no certificates are to be found.  When the OpenSSL library is "
"provided as part of the operating system, though, it is likely to be "
"configured properly."
msgstr ""
"Ladda en uppsättning standardcertifikat från en certifikatutfärdare (CA) "
"från en filsystemssökväg som definieras när OpenSSL-biblioteket byggs.  "
"Tyvärr finns det inget enkelt sätt att veta om den här metoden lyckas: inget"
" fel returneras om inga certifikat hittas.  När OpenSSL-biblioteket "
"tillhandahålls som en del av operativsystemet är det dock troligt att det är"
" korrekt konfigurerat."

#: ../../library/ssl.rst:1680
msgid ""
"Set the available ciphers for sockets created with this context. It should "
"be a string in the `OpenSSL cipher list format "
"<https://www.openssl.org/docs/manmaster/man1/ciphers.html>`_. If no cipher "
"can be selected (because compile-time options or other configuration forbids"
" use of all the specified ciphers), an :class:`SSLError` will be raised."
msgstr ""

#: ../../library/ssl.rst:1688
msgid ""
"when connected, the :meth:`SSLSocket.cipher` method of SSL sockets will give"
" the currently selected cipher."
msgstr ""
"när du är ansluten kommer :meth:`SSLSocket.cipher`\\-metoden för SSL-uttag "
"att ge det aktuella valda chiffret."

#: ../../library/ssl.rst:1691
msgid ""
"TLS 1.3 cipher suites cannot be disabled with "
":meth:`~SSLContext.set_ciphers`."
msgstr ""
"TLS 1.3-chiffersviter kan inte inaktiveras med "
":meth:`~SSLContext.set_ciphers`."

#: ../../library/ssl.rst:1696
msgid ""
"Specify which protocols the socket should advertise during the SSL/TLS "
"handshake. It should be a list of ASCII strings, like ``['http/1.1', "
"'spdy/2']``, ordered by preference. The selection of a protocol will happen "
"during the handshake, and will play out according to :rfc:`7301`. After a "
"successful handshake, the :meth:`SSLSocket.selected_alpn_protocol` method "
"will return the agreed-upon protocol."
msgstr ""
"Ange vilka protokoll som uttaget ska annonsera under SSL/TLS-handskakningen."
" Det bör vara en lista med ASCII-strängar, som ``['http/1.1', 'spdy/2']``, "
"ordnade efter preferens. Valet av protokoll kommer att ske under "
"handskakningen, och kommer att ske enligt :rfc:`7301`. Efter en lyckad "
"handskakning kommer metoden :meth:`SSLSocket.selected_alpn_protocol` att "
"returnera det överenskomna protokollet."

#: ../../library/ssl.rst:1703
msgid ""
"This method will raise :exc:`NotImplementedError` if :data:`HAS_ALPN` is "
"``False``."
msgstr ""
"Denna metod ger upphov till :exc:`NotImplementedError` om :data:`HAS_ALPN` "
"är ``False``."

#: ../../library/ssl.rst:1710
msgid ""
"Specify which protocols the socket should advertise during the SSL/TLS "
"handshake. It should be a list of strings, like ``['http/1.1', 'spdy/2']``, "
"ordered by preference. The selection of a protocol will happen during the "
"handshake, and will play out according to the `Application Layer Protocol "
"Negotiation <https://en.wikipedia.org/wiki/Application-"
"Layer_Protocol_Negotiation>`_. After a successful handshake, the "
":meth:`SSLSocket.selected_npn_protocol` method will return the agreed-upon "
"protocol."
msgstr ""
"Ange vilka protokoll som uttaget ska annonsera under SSL/TLS-handskakningen."
" Det bör vara en lista med strängar, till exempel ``['http/1.1', "
"'spdy/2']``, ordnade efter preferens. Valet av protokoll kommer att ske "
"under handskakningen och kommer att ske i enlighet med `Application Layer "
"Protocol Negotiation <https://en.wikipedia.org/wiki/Application-"
"Layer_Protocol_Negotiation>`_. Efter en lyckad handskakning kommer metoden "
":meth:`SSLSocket.selected_npn_protocol` att returnera det överenskomna "
"protokollet."

#: ../../library/ssl.rst:1718
msgid ""
"This method will raise :exc:`NotImplementedError` if :data:`HAS_NPN` is "
"``False``."
msgstr ""
"Denna metod ger upphov till :exc:`NotImplementedError` om :data:`HAS_NPN` är"
" ``False``."

#: ../../library/ssl.rst:1729
msgid ""
"Register a callback function that will be called after the TLS Client Hello "
"handshake message has been received by the SSL/TLS server when the TLS "
"client specifies a server name indication. The server name indication "
"mechanism is specified in :rfc:`6066` section 3 - Server Name Indication."
msgstr ""
"Registrera en återuppringningsfunktion som kommer att anropas efter att "
"handskakningsmeddelandet TLS Client Hello har mottagits av SSL/TLS-servern "
"när TLS-klienten anger en servernamnindikation. Mekanismen för indikering av"
" servernamn specificeras i :rfc:`6066` avsnitt 3 - Server Name Indication."

#: ../../library/ssl.rst:1734
msgid ""
"Only one callback can be set per ``SSLContext``.  If *sni_callback* is set "
"to ``None`` then the callback is disabled. Calling this function a "
"subsequent time will disable the previously registered callback."
msgstr ""
"Endast en återuppringning kan ställas in per ``SSLContext``.  Om "
"*sni_callback* är inställd på ``None`` inaktiveras återuppringningen. Anrop "
"av denna funktion en senare gång inaktiverar den tidigare registrerade "
"återuppringningen."

#: ../../library/ssl.rst:1738
msgid ""
"The callback function will be called with three arguments; the first being "
"the :class:`ssl.SSLSocket`, the second is a string that represents the "
"server name that the client is intending to communicate (or :const:`None` if"
" the TLS Client Hello does not contain a server name) and the third argument"
" is the original :class:`SSLContext`. The server name argument is text. For "
"internationalized domain name, the server name is an IDN A-label (``\"xn--"
"pythn-mua.org\"``)."
msgstr ""
"Callback-funktionen anropas med tre argument; det första är "
":class:`ssl.SSLSocket`, det andra är en sträng som representerar det "
"servernamn som klienten avser att kommunicera med (eller :const:`None` om "
"TLS Client Hello inte innehåller något servernamn) och det tredje argumentet"
" är det ursprungliga :class:`SSLContext`. Argumentet för servernamnet är "
"text. För internationaliserade domännamn är servernamnet en IDN A-label "
"(``\"xn--pythn-mua.org\"``)."

#: ../../library/ssl.rst:1746
msgid ""
"A typical use of this callback is to change the :class:`ssl.SSLSocket`'s "
":attr:`SSLSocket.context` attribute to a new object of type "
":class:`SSLContext` representing a certificate chain that matches the server"
" name."
msgstr ""
"En typisk användning av denna callback är att ändra "
":class:`ssl.SSLSocket`:attr:`SSLSocket.context`\\-attributet till ett nytt "
"objekt av typen :class:`SSLContext` som representerar en certifikatkedja som"
" matchar servernamnet."

#: ../../library/ssl.rst:1751
msgid ""
"Due to the early negotiation phase of the TLS connection, only limited "
"methods and attributes are usable like "
":meth:`SSLSocket.selected_alpn_protocol` and :attr:`SSLSocket.context`. The "
":meth:`SSLSocket.getpeercert`, :meth:`SSLSocket.cipher` and "
":meth:`SSLSocket.compression` methods require that the TLS connection has "
"progressed beyond the TLS Client Hello and therefore will not return "
"meaningful values nor can they be called safely."
msgstr ""

#: ../../library/ssl.rst:1759
msgid ""
"The *sni_callback* function must return ``None`` to allow the TLS "
"negotiation to continue.  If a TLS failure is required, a constant "
":const:`ALERT_DESCRIPTION_* <ALERT_DESCRIPTION_INTERNAL_ERROR>` can be "
"returned.  Other return values will result in a TLS fatal error with "
":const:`ALERT_DESCRIPTION_INTERNAL_ERROR`."
msgstr ""
"Funktionen *sni_callback* måste returnera ``None`` för att TLS-förhandlingen"
" ska kunna fortsätta.  Om ett TLS-fel krävs kan en konstant "
":const:`ALERT_DESCRIPTION_* <ALERT_DESCRIPTION_INTERNAL_ERROR>` returneras."
"  Andra returvärden kommer att resultera i ett TLS-fatal error med "
":const:`ALERT_DESCRIPTION_INTERNAL_ERROR`."

#: ../../library/ssl.rst:1765
msgid ""
"If an exception is raised from the *sni_callback* function the TLS "
"connection will terminate with a fatal TLS alert message "
":const:`ALERT_DESCRIPTION_HANDSHAKE_FAILURE`."
msgstr ""
"Om ett undantag uppstår från funktionen *sni_callback* kommer TLS-"
"anslutningen att avslutas med ett TLS-varningsmeddelande "
":const:`ALERT_DESCRIPTION_HANDSHAKE_FAILURE`."

#: ../../library/ssl.rst:1769
msgid ""
"This method will raise :exc:`NotImplementedError` if the OpenSSL library had"
" OPENSSL_NO_TLSEXT defined when it was built."
msgstr ""
"Denna metod kommer att ge upphov till :exc:`NotImplementedError` om OpenSSL-"
"biblioteket hade OPENSSL_NO_TLSEXT definierat när det byggdes."

#: ../../library/ssl.rst:1776
msgid ""
"This is a legacy API retained for backwards compatibility. When possible, "
"you should use :attr:`sni_callback` instead. The given "
"*server_name_callback* is similar to *sni_callback*, except that when the "
"server hostname is an IDN-encoded internationalized domain name, the "
"*server_name_callback* receives a decoded U-label (``\"pythön.org\"``)."
msgstr ""
"Detta är ett äldre API som behålls för bakåtkompatibilitet. När det är "
"möjligt bör du använda :attr:`sni_callback` istället. Den givna "
"*server_name_callback* liknar *sni_callback*, förutom att när serverns "
"värdnamn är ett IDN-kodat internationaliserat domännamn, får "
"*server_name_callback* en avkodad U-etikett (``\"pythön.org\"``)."

#: ../../library/ssl.rst:1782
msgid ""
"If there is an decoding error on the server name, the TLS connection will "
"terminate with an :const:`ALERT_DESCRIPTION_INTERNAL_ERROR` fatal TLS alert "
"message to the client."
msgstr ""

#: ../../library/ssl.rst:1790
msgid ""
"Load the key generation parameters for Diffie-Hellman (DH) key exchange. "
"Using DH key exchange improves forward secrecy at the expense of "
"computational resources (both on the server and on the client). The *dhfile*"
" parameter should be the path to a file containing DH parameters in PEM "
"format."
msgstr ""
"Ladda parametrarna för nyckelgenerering för Diffie-Hellman "
"(DH)-nyckelutbyte. Genom att använda DH-nyckelutbyte förbättras forward "
"secrecy på bekostnad av beräkningsresurser (både på servern och på "
"klienten). Parametern *dhfile* ska vara sökvägen till en fil som innehåller "
"DH-parametrar i PEM-format."

#: ../../library/ssl.rst:1796
msgid ""
"This setting doesn't apply to client sockets.  You can also use the "
":data:`OP_SINGLE_DH_USE` option to further improve security."
msgstr ""
"Den här inställningen gäller inte för klientsocklar.  Du kan också använda "
"alternativet :data:`OP_SINGLE_DH_USE` för att ytterligare förbättra "
"säkerheten."

#: ../../library/ssl.rst:1803
msgid ""
"Set the curve name for Elliptic Curve-based Diffie-Hellman (ECDH) key "
"exchange.  ECDH is significantly faster than regular DH while arguably as "
"secure.  The *curve_name* parameter should be a string describing a well-"
"known elliptic curve, for example ``prime256v1`` for a widely supported "
"curve."
msgstr ""
"Ange kurvans namn för ECDH-nyckelutbyte (Elliptic Curve-based Diffie-"
"Hellman).  ECDH är betydligt snabbare än vanlig DH, men förmodligen lika "
"säkert.  Parametern *curve_name* ska vara en sträng som beskriver en välkänd"
" elliptisk kurva, t.ex. ``prime256v1`` för en kurva med brett stöd."

#: ../../library/ssl.rst:1809
msgid ""
"This setting doesn't apply to client sockets.  You can also use the "
":data:`OP_SINGLE_ECDH_USE` option to further improve security."
msgstr ""
"Den här inställningen gäller inte för klientsocklar.  Du kan också använda "
"alternativet :data:`OP_SINGLE_ECDH_USE` för att ytterligare förbättra "
"säkerheten."

#: ../../library/ssl.rst:1812
msgid "This method is not available if :data:`HAS_ECDH` is ``False``."
msgstr "Denna metod är inte tillgänglig om :data:`HAS_ECDH` är ``False``."

#: ../../library/ssl.rst:1817
msgid ""
"`SSL/TLS & Perfect Forward Secrecy "
"<https://vincent.bernat.ch/en/blog/2011-ssl-perfect-forward-secrecy>`_"
msgstr ""
"`SSL/TLS & Perfect Forward Secrecy "
"<https://vincent.bernat.ch/en/blog/2011-ssl-perfect-forward-secrecy>`_"

#: ../../library/ssl.rst:1818
msgid "Vincent Bernat."
msgstr "Vincent Bernat."

#: ../../library/ssl.rst:1824
msgid ""
"Wrap an existing Python socket *sock* and return an instance of "
":attr:`SSLContext.sslsocket_class` (default :class:`SSLSocket`). The "
"returned SSL socket is tied to the context, its settings and certificates. "
"*sock* must be a :const:`~socket.SOCK_STREAM` socket; other socket types are"
" unsupported."
msgstr ""
"Omfattar en befintlig Python-socket *sock* och returnerar en instans av "
":attr:`SSLContext.sslsocket_class` (standard :class:`SSLSocket`). Det "
"returnerade SSL-uttaget är knutet till kontexten, dess inställningar och "
"certifikat. *sock* måste vara ett :const:`~socket.SOCK_STREAM`\\-uttag; "
"andra uttagstyper stöds inte."

#: ../../library/ssl.rst:1830
msgid ""
"The parameter ``server_side`` is a boolean which identifies whether server-"
"side or client-side behavior is desired from this socket."
msgstr ""
"Parametern ``server_side`` är en boolean som anger om det är server- eller "
"klientsidans beteende som önskas från detta uttag."

#: ../../library/ssl.rst:1833
msgid ""
"For client-side sockets, the context construction is lazy; if the underlying"
" socket isn't connected yet, the context construction will be performed "
"after :meth:`connect` is called on the socket.  For server-side sockets, if "
"the socket has no remote peer, it is assumed to be a listening socket, and "
"the server-side SSL wrapping is automatically performed on client "
"connections accepted via the :meth:`accept` method. The method may raise "
":exc:`SSLError`."
msgstr ""
"För uttag på klientsidan är kontextkonstruktionen lat; om det underliggande "
"uttaget inte är anslutet ännu kommer kontextkonstruktionen att utföras efter"
" att :meth:`connect` anropas på uttaget.  För uttag på serversidan, om "
"uttaget inte har någon fjärrpeer, antas det vara ett lyssnande uttag, och "
"SSL-omslaget på serversidan utförs automatiskt på klientanslutningar som "
"accepteras via metoden :meth:`accept`. Metoden kan ge upphov till "
":exc:`SSLError`."

#: ../../library/ssl.rst:1841
msgid ""
"On client connections, the optional parameter *server_hostname* specifies "
"the hostname of the service which we are connecting to.  This allows a "
"single server to host multiple SSL-based services with distinct "
"certificates, quite similarly to HTTP virtual hosts. Specifying "
"*server_hostname* will raise a :exc:`ValueError` if *server_side* is true."
msgstr ""
"Vid klientanslutningar anger den valfria parametern *server_hostname* "
"värdnamnet på den tjänst som vi ansluter till.  Detta gör att en enda server"
" kan vara värd för flera SSL-baserade tjänster med olika certifikat, på "
"liknande sätt som virtuella HTTP-värdar. Om *server_hostname* anges kommer "
"ett :exc:`ValueError` att uppstå om *server_side* är true."

#: ../../library/ssl.rst:1847
msgid ""
"The parameter ``do_handshake_on_connect`` specifies whether to do the SSL "
"handshake automatically after doing a :meth:`socket.connect`, or whether the"
" application program will call it explicitly, by invoking the "
":meth:`SSLSocket.do_handshake` method.  Calling "
":meth:`SSLSocket.do_handshake` explicitly gives the program control over the"
" blocking behavior of the socket I/O involved in the handshake."
msgstr ""
"Parametern ``do_handshake_on_connect`` anger om SSL-handskakningen ska göras"
" automatiskt efter en :meth:`socket.connect`, eller om "
"applikationsprogrammet ska göra det explicit genom att anropa metoden "
":meth:`SSLSocket.do_handshake`.  Genom att anropa "
":meth:`SSLSocket.do_handshake` explicit får programmet kontroll över "
"blockeringsbeteendet för socket I/O som är involverat i handskakningen."

#: ../../library/ssl.rst:1854
msgid ""
"The parameter ``suppress_ragged_eofs`` specifies how the "
":meth:`SSLSocket.recv` method should signal unexpected EOF from the other "
"end of the connection.  If specified as :const:`True` (the default), it "
"returns a normal EOF (an empty bytes object) in response to unexpected EOF "
"errors raised from the underlying socket; if :const:`False`, it will raise "
"the exceptions back to the caller."
msgstr ""
"Parametern ``suppress_ragged_eofs`` anger hur metoden :meth:`SSLSocket.recv`"
" ska signalera oväntade EOF från den andra änden av anslutningen.  Om den "
"anges som :const:`True` (standard) returnerar den en normal EOF (ett tomt "
"bytesobjekt) som svar på oväntade EOF-fel från den underliggande sockeln; om"
" den anges som :const:`False` returneras undantagen tillbaka till anroparen."

#: ../../library/ssl.rst:1861
msgid "*session*, see :attr:`~SSLSocket.session`."
msgstr "*session*, se :attr:`~SSLSocket.session`."

#: ../../library/ssl.rst:1863
msgid ""
"To wrap an :class:`SSLSocket` in another :class:`SSLSocket`, use "
":meth:`SSLContext.wrap_bio`."
msgstr ""
"För att linda in en :class:`SSLSocket` i en annan :class:`SSLSocket`, använd"
" :meth:`SSLContext.wrap_bio`."

#: ../../library/ssl.rst:1866
msgid ""
"Always allow a server_hostname to be passed, even if OpenSSL does not have "
"SNI."
msgstr ""
"Tillåt alltid att ett server_hostname skickas med, även om OpenSSL inte har "
"SNI."

#: ../../library/ssl.rst:1870 ../../library/ssl.rst:1896
msgid "*session* argument was added."
msgstr "*session*-argumentet har lagts till."

#: ../../library/ssl.rst:1873
msgid ""
"The method returns an instance of :attr:`SSLContext.sslsocket_class` instead"
" of hard-coded :class:`SSLSocket`."
msgstr ""
"Metoden returnerar en instans av :attr:`SSLContext.sslsocket_class` istället"
" för hårdkodad :class:`SSLSocket`."

#: ../../library/ssl.rst:1879
msgid ""
"The return type of :meth:`SSLContext.wrap_socket`, defaults to "
":class:`SSLSocket`. The attribute can be overridden on instance of class in "
"order to return a custom subclass of :class:`SSLSocket`."
msgstr ""

#: ../../library/ssl.rst:1888
msgid ""
"Wrap the BIO objects *incoming* and *outgoing* and return an instance of "
":attr:`SSLContext.sslobject_class` (default :class:`SSLObject`). The SSL "
"routines will read input data from the incoming BIO and write data to the "
"outgoing BIO."
msgstr ""
"Packa in BIO-objekten *incoming* och *outgoing* och returnera en instans av "
":attr:`SSLContext.sslobject_class` (standard :class:`SSLObject`). SSL-"
"rutinerna läser inmatningsdata från det inkommande BIO-objektet och skriver "
"data till det utgående BIO-objektet."

#: ../../library/ssl.rst:1893
msgid ""
"The *server_side*, *server_hostname* and *session* parameters have the same "
"meaning as in :meth:`SSLContext.wrap_socket`."
msgstr ""
"Parametrarna *server_side*, *server_hostname* och *session* har samma "
"betydelse som i :meth:`SSLContext.wrap_socket`."

#: ../../library/ssl.rst:1899
msgid ""
"The method returns an instance of :attr:`SSLContext.sslobject_class` instead"
" of hard-coded :class:`SSLObject`."
msgstr ""
"Metoden returnerar en instans av :attr:`SSLContext.sslobject_class` istället"
" för hårdkodad :class:`SSLObject`."

#: ../../library/ssl.rst:1905
msgid ""
"The return type of :meth:`SSLContext.wrap_bio`, defaults to "
":class:`SSLObject`. The attribute can be overridden on instance of class in "
"order to return a custom subclass of :class:`SSLObject`."
msgstr ""
"Returtyp för :meth:`SSLContext.wrap_bio`, standard är :class:`SSLObject`. "
"Attributet kan åsidosättas på en instans av class för att returnera en "
"anpassad underklass av :class:`SSLObject`."

#: ../../library/ssl.rst:1913
msgid ""
"Get statistics about the SSL sessions created or managed by this context. A "
"dictionary is returned which maps the names of each `piece of information "
"<https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_sess_number.html>`_ to "
"their numeric values.  For example, here is the total number of hits and "
"misses in the session cache since the context was created::"
msgstr ""

#: ../../library/ssl.rst:1924
msgid ""
"Whether to match the peer cert's hostname in :meth:`SSLSocket.do_handshake`."
" The context's :attr:`~SSLContext.verify_mode` must be set to "
":data:`CERT_OPTIONAL` or :data:`CERT_REQUIRED`, and you must pass "
"*server_hostname* to :meth:`~SSLContext.wrap_socket` in order to match the "
"hostname.  Enabling hostname checking automatically sets "
":attr:`~SSLContext.verify_mode` from :data:`CERT_NONE` to "
":data:`CERT_REQUIRED`.  It cannot be set back to :data:`CERT_NONE` as long "
"as hostname checking is enabled. The :data:`PROTOCOL_TLS_CLIENT` protocol "
"enables hostname checking by default. With other protocols, hostname "
"checking must be enabled explicitly."
msgstr ""
"Huruvida peer-certifikatets värdnamn ska matchas i "
":meth:`SSLSocket.do_handshake`. Kontextens :attr:`~SSLContext.verify_mode` "
"måste vara inställd på :data:`CERT_OPTIONAL` eller :data:`CERT_REQUIRED`, "
"och du måste skicka *server_hostname* till :meth:`~SSLContext.wrap_socket` "
"för att matcha värdnamnet.  Om du aktiverar kontroll av värdnamn ställs "
":attr:`~SSLContext.verify_mode` automatiskt in från :data:`CERT_NONE` till "
":data:`CERT_REQUIRED`.  Det kan inte sättas tillbaka till :data:`CERT_NONE` "
"så länge värdnamnskontrollen är aktiverad. Protokollet "
":data:`PROTOCOL_TLS_CLIENT` aktiverar värdnamnskontroll som standard. Med "
"andra protokoll måste värdnamnskontroll aktiveras uttryckligen."

#: ../../library/ssl.rst:1952
msgid ""
":attr:`~SSLContext.verify_mode` is now automatically changed to "
":data:`CERT_REQUIRED`  when hostname checking is enabled and "
":attr:`~SSLContext.verify_mode` is :data:`CERT_NONE`. Previously the same "
"operation would have failed with a :exc:`ValueError`."
msgstr ""
":attr:`~SSLContext.verify_mode` ändras nu automatiskt till "
":data:`CERT_REQUIRED` när kontroll av värdnamn är aktiverat och "
":attr:`~SSLContext.verify_mode` är :data:`CERT_NONE`. Tidigare skulle samma "
"operation ha misslyckats med ett :exc:`ValueError`."

#: ../../library/ssl.rst:1959
msgid ""
"Write TLS keys to a keylog file, whenever key material is generated or "
"received. The keylog file is designed for debugging purposes only. The file "
"format is specified by NSS and used by many traffic analyzers such as "
"Wireshark. The log file is opened in append-only mode. Writes are "
"synchronized between threads, but not between processes."
msgstr ""
"Skriv TLS-nycklar till en keylog-fil när nyckelmaterial genereras eller tas "
"emot. Keylog-filen är endast avsedd för felsökningsändamål. Filformatet "
"specificeras av NSS och används av många trafikanalysatorer, t.ex. "
"Wireshark. Loggfilen öppnas i append-only-läge. Skrivningar synkroniseras "
"mellan trådar, men inte mellan processer."

#: ../../library/ssl.rst:1969
msgid ""
"A :class:`TLSVersion` enum member representing the highest supported TLS "
"version. The value defaults to :attr:`TLSVersion.MAXIMUM_SUPPORTED`. The "
"attribute is read-only for protocols other than :attr:`PROTOCOL_TLS`, "
":attr:`PROTOCOL_TLS_CLIENT`, and :attr:`PROTOCOL_TLS_SERVER`."
msgstr ""

#: ../../library/ssl.rst:1974
msgid ""
"The attributes :attr:`~SSLContext.maximum_version`, "
":attr:`~SSLContext.minimum_version` and :attr:`SSLContext.options` all "
"affect the supported SSL and TLS versions of the context. The implementation"
" does not prevent invalid combination. For example a context with "
":attr:`OP_NO_TLSv1_2` in :attr:`~SSLContext.options` and "
":attr:`~SSLContext.maximum_version` set to :attr:`TLSVersion.TLSv1_2` will "
"not be able to establish a TLS 1.2 connection."
msgstr ""
"Attributen :attr:`~SSLContext.maximum_version`, "
":attr:`~SSLContext.minimum_version` och :attr:`SSLContext.options` påverkar "
"alla de SSL- och TLS-versioner som stöds av kontexten. Implementationen "
"förhindrar inte ogiltiga kombinationer. Till exempel kommer en kontext med "
":attr:`OP_NO_TLSv1_2` i :attr:`~SSLContext.options` och "
":attr:`~SSLContext.maximum_version` satt till :attr:`TLSVersion.TLSv1_2` "
"inte att kunna upprätta en TLS 1.2-anslutning."

#: ../../library/ssl.rst:1987
msgid ""
"Like :attr:`SSLContext.maximum_version` except it is the lowest supported "
"version or :attr:`TLSVersion.MINIMUM_SUPPORTED`."
msgstr ""
"Som :attr:`SSLContext.maximum_version` förutom att det är den lägsta "
"versionen som stöds eller :attr:`TLSVersion.MINIMUM_SUPPORTED`."

#: ../../library/ssl.rst:1994
msgid ""
"Control the number of TLS 1.3 session tickets of a "
":attr:`PROTOCOL_TLS_SERVER` context. The setting has no impact on TLS 1.0 to"
" 1.2 connections."
msgstr ""

#: ../../library/ssl.rst:2002
msgid ""
"An integer representing the set of SSL options enabled on this context. The "
"default value is :data:`OP_ALL`, but you can specify other options such as "
":data:`OP_NO_SSLv2` by ORing them together."
msgstr ""
"Ett heltal som representerar den uppsättning SSL-alternativ som är "
"aktiverade i detta sammanhang. Standardvärdet är :data:`OP_ALL`, men du kan "
"ange andra alternativ som t.ex. :data:`OP_NO_SSLv2` genom att sätta ihop dem"
" med OR."

#: ../../library/ssl.rst:2006
msgid ":attr:`SSLContext.options` returns :class:`Options` flags:"
msgstr ":attr:`SSLContext.options` returnerar :class:`Options` flaggor:"

#: ../../library/ssl.rst:2014
msgid ""
"All ``OP_NO_SSL*`` and ``OP_NO_TLS*`` options have been deprecated since "
"Python 3.7. Use :attr:`SSLContext.minimum_version` and "
":attr:`SSLContext.maximum_version` instead."
msgstr ""
"Alla ``OP_NO_SSL*`` och ``OP_NO_TLS*`` alternativ har blivit föråldrade "
"sedan Python 3.7. Använd :attr:`SSLContext.minimum_version` och "
":attr:`SSLContext.maximum_version` istället."

#: ../../library/ssl.rst:2020
msgid ""
"Enable TLS 1.3 post-handshake client authentication. Post-handshake auth is "
"disabled by default and a server can only request a TLS client certificate "
"during the initial handshake. When enabled, a server may request a TLS "
"client certificate at any time after the handshake."
msgstr ""
"Aktivera TLS 1.3-klientautentisering efter handskakning. Autentisering efter"
" handskakning är inaktiverad som standard och en server kan bara begära ett "
"TLS-klientcertifikat under den inledande handskakningen. När den är "
"aktiverad kan en server begära ett TLS-klientcertifikat när som helst efter "
"handskakningen."

#: ../../library/ssl.rst:2025
msgid ""
"When enabled on client-side sockets, the client signals the server that it "
"supports post-handshake authentication."
msgstr ""
"När den är aktiverad på sockets på klientsidan signalerar klienten till "
"servern att den stöder autentisering efter handskakning."

#: ../../library/ssl.rst:2028
msgid ""
"When enabled on server-side sockets, :attr:`SSLContext.verify_mode` must be "
"set to :data:`CERT_OPTIONAL` or :data:`CERT_REQUIRED`, too. The actual "
"client cert exchange is delayed until "
":meth:`SSLSocket.verify_client_post_handshake` is called and some I/O is "
"performed."
msgstr ""
"När det är aktiverat på server-sidans socklar måste "
":attr:`SSLContext.verify_mode` också vara inställt på :data:`CERT_OPTIONAL` "
"eller :data:`CERT_REQUIRED`. Det faktiska utbytet av klientcertifikat "
"fördröjs tills :meth:`SSLSocket.verify_client_post_handshake` anropas och "
"vissa I/O utförs."

#: ../../library/ssl.rst:2038
msgid ""
"The protocol version chosen when constructing the context.  This attribute "
"is read-only."
msgstr ""
"Den protokollversion som valdes när kontexten konstruerades.  Detta attribut"
" är skrivskyddat."

#: ../../library/ssl.rst:2043
msgid ""
"Whether :attr:`~SSLContext.check_hostname` falls back to verify the cert's "
"subject common name in the absence of a subject alternative name extension "
"(default: true)."
msgstr ""
"Om :attr:`~SSLContext.check_hostname` faller tillbaka för att verifiera "
"certets gemensamma ämnesnamn i avsaknad av ett alternativt ämnesnamnstillägg"
" (standard: true)."

#: ../../library/ssl.rst:2051
msgid ""
"The flag had no effect with OpenSSL before version 1.1.1l. Python 3.8.9, "
"3.9.3, and 3.10 include workarounds for previous versions."
msgstr ""
"Flaggan hade ingen effekt med OpenSSL före version 1.1.1l. Python 3.8.9, "
"3.9.3 och 3.10 innehåller lösningar för tidigare versioner."

#: ../../library/ssl.rst:2056
msgid ""
"An integer representing the `security level "
"<https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get_security_level.html>`_"
" for the context. This attribute is read-only."
msgstr ""

#: ../../library/ssl.rst:2064
msgid ""
"The flags for certificate verification operations. You can set flags like "
":data:`VERIFY_CRL_CHECK_LEAF` by ORing them together. By default OpenSSL "
"does neither require nor verify certificate revocation lists (CRLs)."
msgstr ""
"Flaggorna för verifiering av certifikat. Du kan ange flaggor som "
":data:`VERIFY_CRL_CHECK_LEAF` genom att sätta ihop dem med OR. Som standard "
"varken kräver eller verifierar OpenSSL återkallningslistor för certifikat "
"(CRL)."

#: ../../library/ssl.rst:2070
msgid ":attr:`SSLContext.verify_flags` returns :class:`VerifyFlags` flags:"
msgstr ""
":attr:`SSLContext.verify_flags` returnerar :class:`VerifyFlags` flaggor:"

#: ../../library/ssl.rst:2078
msgid ""
"Whether to try to verify other peers' certificates and how to behave if "
"verification fails.  This attribute must be one of :data:`CERT_NONE`, "
":data:`CERT_OPTIONAL` or :data:`CERT_REQUIRED`."
msgstr ""
"Om man ska försöka verifiera andra peers certifikat och hur man ska agera om"
" verifieringen misslyckas.  Detta attribut måste vara ett av "
":data:`CERT_NONE`, :data:`CERT_OPTIONAL` eller :data:`CERT_REQUIRED`."

#: ../../library/ssl.rst:2082
msgid ":attr:`SSLContext.verify_mode` returns :class:`VerifyMode` enum:"
msgstr ":attr:`SSLContext.verify_mode` returnerar :class:`VerifyMode` enum:"

#: ../../library/ssl.rst:2095
msgid "Certificates"
msgstr "Diplom"

#: ../../library/ssl.rst:2097
msgid ""
"Certificates in general are part of a public-key / private-key system.  In "
"this system, each *principal*, (which may be a machine, or a person, or an "
"organization) is assigned a unique two-part encryption key.  One part of the"
" key is public, and is called the *public key*; the other part is kept "
"secret, and is called the *private key*.  The two parts are related, in that"
" if you encrypt a message with one of the parts, you can decrypt it with the"
" other part, and **only** with the other part."
msgstr ""
"Certifikat är i allmänhet en del av ett system med offentliga nycklar och "
"privata nycklar.  I detta system tilldelas varje *principal* (som kan vara "
"en maskin, en person eller en organisation) en unik krypteringsnyckel i två "
"delar.  Den ena delen av nyckeln är offentlig och kallas *public key*; den "
"andra delen hålls hemlig och kallas *private key*.  De två delarna är "
"relaterade på så sätt att om man krypterar ett meddelande med den ena delen "
"kan man dekryptera det med den andra delen, och **endast** med den andra "
"delen."

#: ../../library/ssl.rst:2105
msgid ""
"A certificate contains information about two principals.  It contains the "
"name of a *subject*, and the subject's public key.  It also contains a "
"statement by a second principal, the *issuer*, that the subject is who they "
"claim to be, and that this is indeed the subject's public key.  The issuer's"
" statement is signed with the issuer's private key, which only the issuer "
"knows.  However, anyone can verify the issuer's statement by finding the "
"issuer's public key, decrypting the statement with it, and comparing it to "
"the other information in the certificate. The certificate also contains "
"information about the time period over which it is valid.  This is expressed"
" as two fields, called \"notBefore\" and \"notAfter\"."
msgstr ""
"Ett certifikat innehåller information om två huvudmän.  Det innehåller "
"namnet på en *subjekt* och subjektets publika nyckel.  Det innehåller också "
"ett uttalande från en andra huvudman, *utfärdaren*, om att subjektet är den "
"hen utger sig för att vara och att detta verkligen är subjektets publika "
"nyckel.  Utfärdarens uttalande är signerat med utfärdarens privata nyckel, "
"som endast utfärdaren känner till.  Vem som helst kan dock verifiera "
"utfärdarens uttalande genom att hitta utfärdarens publika nyckel, dekryptera"
" uttalandet med den och jämföra det med den övriga informationen i "
"certifikatet. Certifikatet innehåller också information om den tidsperiod "
"under vilken det är giltigt.  Detta uttrycks som två fält, kallade "
"\"notBefore\" och \"notAfter\"."

#: ../../library/ssl.rst:2115
msgid ""
"In the Python use of certificates, a client or server can use a certificate "
"to prove who they are.  The other side of a network connection can also be "
"required to produce a certificate, and that certificate can be validated to "
"the satisfaction of the client or server that requires such validation.  The"
" connection attempt can be set to raise an exception if the validation "
"fails. Validation is done automatically, by the underlying OpenSSL "
"framework; the application need not concern itself with its mechanics.  But "
"the application does usually need to provide sets of certificates to allow "
"this process to take place."
msgstr ""
"I Python-användningen av certifikat kan en klient eller server använda ett "
"certifikat för att bevisa vem de är.  Den andra sidan av en "
"nätverksanslutning kan också krävas på ett certifikat, och det certifikatet "
"kan valideras på ett sätt som tillfredsställer den klient eller server som "
"kräver sådan validering.  Anslutningsförsöket kan ställas in så att ett "
"undantag utlöses om valideringen misslyckas. Valideringen görs automatiskt "
"av det underliggande OpenSSL-ramverket och applikationen behöver inte "
"bekymra sig om hur det fungerar.  Men applikationen behöver vanligtvis "
"tillhandahålla uppsättningar av certifikat för att denna process ska kunna "
"äga rum."

#: ../../library/ssl.rst:2125
msgid ""
"Python uses files to contain certificates.  They should be formatted as "
"\"PEM\" (see :rfc:`1422`), which is a base-64 encoded form wrapped with a "
"header line and a footer line::"
msgstr ""
"Python använder filer för att innehålla certifikat.  De bör formateras som "
"\"PEM\" (se :rfc:`1422`), vilket är en bas-64-kodad form omsluten av en "
"rubrikrad och en sidfot:"

#: ../../library/ssl.rst:2134
msgid "Certificate chains"
msgstr "Certifikatkedjor"

#: ../../library/ssl.rst:2136
msgid ""
"The Python files which contain certificates can contain a sequence of "
"certificates, sometimes called a *certificate chain*.  This chain should "
"start with the specific certificate for the principal who \"is\" the client "
"or server, and then the certificate for the issuer of that certificate, and "
"then the certificate for the issuer of *that* certificate, and so on up the "
"chain till you get to a certificate which is *self-signed*, that is, a "
"certificate which has the same subject and issuer, sometimes called a *root "
"certificate*.  The certificates should just be concatenated together in the "
"certificate file.  For example, suppose we had a three certificate chain, "
"from our server certificate to the certificate of the certification "
"authority that signed our server certificate, to the root certificate of the"
" agency which issued the certification authority's certificate::"
msgstr ""
"De Python-filer som innehåller certifikat kan innehålla en sekvens av "
"certifikat, ibland kallad en *certifikatkedja*.  Denna kedja bör börja med "
"det specifika certifikatet för den principal som \"är\" klienten eller "
"servern, och sedan certifikatet för utfärdaren av det certifikatet, och "
"sedan certifikatet för utfärdaren av *det* certifikatet, och så vidare upp i"
" kedjan tills man kommer till ett certifikat som är *självsignerat*, det "
"vill säga ett certifikat som har samma subject och utfärdare, ibland kallat "
"ett *rotcertifikat*.  Certifikaten ska bara sammankopplas i certifikatfilen."
"  Anta till exempel att vi har en kedja med tre certifikat, från vårt "
"servercertifikat till certifikatet för den certifikatutfärdare som signerade"
" vårt servercertifikat, till rotcertifikatet för den myndighet som utfärdade"
" certifikatutfärdarens certifikat::"

#: ../../library/ssl.rst:2160
msgid "CA certificates"
msgstr "CA-certifikat"

#: ../../library/ssl.rst:2162
msgid ""
"If you are going to require validation of the other side of the connection's"
" certificate, you need to provide a \"CA certs\" file, filled with the "
"certificate chains for each issuer you are willing to trust.  Again, this "
"file just contains these chains concatenated together.  For validation, "
"Python will use the first chain it finds in the file which matches.  The "
"platform's certificates file can be used by calling "
":meth:`SSLContext.load_default_certs`, this is done automatically with "
":func:`.create_default_context`."
msgstr ""
"Om du ska kräva validering av den andra sidan av anslutningens certifikat "
"måste du tillhandahålla en \"CA certs\"-fil, fylld med certifikatkedjorna "
"för varje utfärdare som du är villig att lita på.  Återigen innehåller den "
"här filen bara dessa kedjor sammankopplade tillsammans.  För validering "
"kommer Python att använda den första kedjan som den hittar i filen som "
"matchar.  Plattformens certifikatfil kan användas genom att anropa "
":meth:`SSLContext.load_default_certs`, detta görs automatiskt med "
":func:`.create_default_context`."

#: ../../library/ssl.rst:2171
msgid "Combined key and certificate"
msgstr "Kombinerad nyckel och certifikat"

#: ../../library/ssl.rst:2173
msgid ""
"Often the private key is stored in the same file as the certificate; in this"
" case, only the ``certfile`` parameter to :meth:`SSLContext.load_cert_chain`"
" and :func:`wrap_socket` needs to be passed.  If the private key is stored "
"with the certificate, it should come before the first certificate in the "
"certificate chain::"
msgstr ""

#: ../../library/ssl.rst:2187
msgid "Self-signed certificates"
msgstr "Självsignerade certifikat"

#: ../../library/ssl.rst:2189
msgid ""
"If you are going to create a server that provides SSL-encrypted connection "
"services, you will need to acquire a certificate for that service.  There "
"are many ways of acquiring appropriate certificates, such as buying one from"
" a certification authority.  Another common practice is to generate a self-"
"signed certificate.  The simplest way to do this is with the OpenSSL "
"package, using something like the following::"
msgstr ""
"Om du ska skapa en server som tillhandahåller SSL-krypterade "
"anslutningstjänster måste du skaffa ett certifikat för den tjänsten.  Det "
"finns många sätt att skaffa lämpliga certifikat, t.ex. genom att köpa ett "
"från en certifikatutfärdare.  Ett annat vanligt sätt är att skapa ett "
"självsignerat certifikat.  Det enklaste sättet att göra detta är med "
"OpenSSL-paketet, genom att använda något i stil med följande::"

#: ../../library/ssl.rst:2218
msgid ""
"The disadvantage of a self-signed certificate is that it is its own root "
"certificate, and no one else will have it in their cache of known (and "
"trusted) root certificates."
msgstr ""
"Nackdelen med ett självsignerat certifikat är att det är ett eget "
"rotcertifikat, och ingen annan kommer att ha det i sin cache av kända (och "
"betrodda) rotcertifikat."

#: ../../library/ssl.rst:2224
msgid "Examples"
msgstr "Exempel"

#: ../../library/ssl.rst:2227
msgid "Testing for SSL support"
msgstr "Testning för SSL-stöd"

#: ../../library/ssl.rst:2229
msgid ""
"To test for the presence of SSL support in a Python installation, user code "
"should use the following idiom::"
msgstr ""
"För att testa om det finns SSL-stöd i en Python-installation bör "
"användarkoden använda följande idiom::"

#: ../../library/ssl.rst:2240
msgid "Client-side operation"
msgstr "Operation på klientsidan"

#: ../../library/ssl.rst:2242
msgid ""
"This example creates a SSL context with the recommended security settings "
"for client sockets, including automatic certificate verification::"
msgstr ""
"I detta exempel skapas en SSL-kontext med rekommenderade "
"säkerhetsinställningar för klientsocklar, inklusive automatisk "
"certifikatverifiering::"

#: ../../library/ssl.rst:2247
msgid ""
"If you prefer to tune security settings yourself, you might create a context"
" from scratch (but beware that you might not get the settings right)::"
msgstr ""
"Om du föredrar att göra säkerhetsinställningarna själv kan du skapa ett "
"sammanhang från början (men tänk på att du kanske inte får rätt "
"inställningar)::"

#: ../../library/ssl.rst:2254
msgid ""
"(this snippet assumes your operating system places a bundle of all CA "
"certificates in ``/etc/ssl/certs/ca-bundle.crt``; if not, you'll get an "
"error and have to adjust the location)"
msgstr ""
"(detta utdrag förutsätter att ditt operativsystem placerar ett paket med "
"alla CA-certifikat i ``/etc/ssl/certs/ca-bundle.crt``; om inte, får du ett "
"fel och måste justera platsen)"

#: ../../library/ssl.rst:2258
msgid ""
"The :data:`PROTOCOL_TLS_CLIENT` protocol configures the context for cert "
"validation and hostname verification. :attr:`~SSLContext.verify_mode` is set"
" to :data:`CERT_REQUIRED` and :attr:`~SSLContext.check_hostname` is set to "
"``True``. All other protocols create SSL contexts with insecure defaults."
msgstr ""
"Protokollet :data:`PROTOCOL_TLS_CLIENT` konfigurerar kontexten för "
"validering av certifikat och verifiering av värdnamn. "
":attr:`~SSLContext.verify_mode` är inställd på :data:`CERT_REQUIRED` och "
":attr:`~SSLContext.check_hostname` är inställd på ``True``. Alla andra "
"protokoll skapar SSL-kontexter med osäkra standardvärden."

#: ../../library/ssl.rst:2263
msgid ""
"When you use the context to connect to a server, :const:`CERT_REQUIRED` and "
":attr:`~SSLContext.check_hostname` validate the server certificate: it "
"ensures that the server certificate was signed with one of the CA "
"certificates, checks the signature for correctness, and verifies other "
"properties like validity and identity of the hostname::"
msgstr ""
"När du använder kontexten för att ansluta till en server validerar "
":const:`CERT_REQUIRED` och :attr:`~SSLContext.check_hostname` "
"servercertifikatet: det säkerställer att servercertifikatet har signerats "
"med ett av CA-certifikaten, kontrollerar att signaturen är korrekt och "
"verifierar andra egenskaper som giltighet och identitet för värdnamnet::"

#: ../../library/ssl.rst:2273
msgid "You may then fetch the certificate::"
msgstr "Du kan då hämta ut certifikatet::"

#: ../../library/ssl.rst:2277
msgid ""
"Visual inspection shows that the certificate does identify the desired "
"service (that is, the HTTPS host ``www.python.org``)::"
msgstr ""
"En visuell kontroll visar att certifikatet identifierar den önskade tjänsten"
" (dvs. HTTPS-värden ``www.python.org``)::"

#: ../../library/ssl.rst:2320
msgid ""
"Now the SSL channel is established and the certificate verified, you can "
"proceed to talk with the server::"
msgstr ""
"Nu när SSL-kanalen har upprättats och certifikatet har verifierats kan du "
"fortsätta att prata med servern::"

#: ../../library/ssl.rst:2347
msgid "Server-side operation"
msgstr "Drift på serversidan"

#: ../../library/ssl.rst:2349
msgid ""
"For server operation, typically you'll need to have a server certificate, "
"and private key, each in a file.  You'll first create a context holding the "
"key and the certificate, so that clients can check your authenticity.  Then "
"you'll open a socket, bind it to a port, call :meth:`listen` on it, and "
"start waiting for clients to connect::"
msgstr ""
"För serverdrift behöver du vanligtvis ha ett servercertifikat och en privat "
"nyckel i varsin fil.  Du skapar först en kontext som innehåller nyckeln och "
"certifikatet, så att klienterna kan kontrollera din äkthet.  Sedan öppnar du"
" en socket, binder den till en port, anropar :meth:`listen` på den och "
"börjar vänta på att klienter ska ansluta::"

#: ../../library/ssl.rst:2364
msgid ""
"When a client connects, you'll call :meth:`accept` on the socket to get the "
"new socket from the other end, and use the context's "
":meth:`SSLContext.wrap_socket` method to create a server-side SSL socket for"
" the connection::"
msgstr ""
"När en klient ansluter anropar du :meth:`accept` på sockeln för att hämta "
"den nya sockeln från andra änden och använder kontextens "
":meth:`SSLContext.wrap_socket`\\-metod för att skapa en SSL-socket på "
"serversidan för anslutningen:"

#: ../../library/ssl.rst:2377
msgid ""
"Then you'll read data from the ``connstream`` and do something with it till "
"you are finished with the client (or the client is finished with you)::"
msgstr ""
"Sedan läser du data från ``connstream`` och gör något med den tills du är "
"klar med klienten (eller klienten är klar med dig)::"

#: ../../library/ssl.rst:2391
msgid ""
"And go back to listening for new client connections (of course, a real "
"server would probably handle each client connection in a separate thread, or"
" put the sockets in :ref:`non-blocking mode <ssl-nonblocking>` and use an "
"event loop)."
msgstr ""
"Och gå tillbaka till att lyssna efter nya klientanslutningar (naturligtvis "
"skulle en riktig server förmodligen hantera varje klientanslutning i en "
"separat tråd, eller sätta socklarna i :ref:`icke-blockerande läge <ssl-"
"nonblocking>` och använda en händelseslinga)."

#: ../../library/ssl.rst:2399
msgid "Notes on non-blocking sockets"
msgstr "Anteckningar om icke-blockerande sockets"

#: ../../library/ssl.rst:2401
msgid ""
"SSL sockets behave slightly different than regular sockets in non-blocking "
"mode. When working with non-blocking sockets, there are thus several things "
"you need to be aware of:"
msgstr ""
"SSL-uttag beter sig något annorlunda än vanliga uttag i icke-blockerande "
"läge. När du arbetar med icke-blockerande sockets finns det därför flera "
"saker du måste vara medveten om:"

#: ../../library/ssl.rst:2405
msgid ""
"Most :class:`SSLSocket` methods will raise either :exc:`SSLWantWriteError` "
"or :exc:`SSLWantReadError` instead of :exc:`BlockingIOError` if an I/O "
"operation would block. :exc:`SSLWantReadError` will be raised if a read "
"operation on the underlying socket is necessary, and "
":exc:`SSLWantWriteError` for a write operation on the underlying socket. "
"Note that attempts to *write* to an SSL socket may require *reading* from "
"the underlying socket first, and attempts to *read* from the SSL socket may "
"require a prior *write* to the underlying socket."
msgstr ""
"De flesta :class:`SSLSocket`\\-metoder kommer att ge upphov till antingen "
":exc:`SSLWantWriteError` eller :exc:`SSLWantReadError` istället för "
":exc:`BlockingIOError` om en I/O-operation skulle blockeras. "
":exc:`SSLWantReadError` kommer att ges upphov till om en läsoperation på den"
" underliggande sockeln är nödvändig, och :exc:`SSLWantWriteError` för en "
"skrivoperation på den underliggande sockeln. Observera att försök att "
"*skriva* till ett SSL-uttag kan kräva att man först *läser* från det "
"underliggande uttaget, och försök att *läsa* från SSL-uttaget kan kräva att "
"man först *skriver* till det underliggande uttaget."

#: ../../library/ssl.rst:2417
msgid ""
"In earlier Python versions, the :meth:`!SSLSocket.send` method returned zero"
" instead of raising :exc:`SSLWantWriteError` or :exc:`SSLWantReadError`."
msgstr ""
"I tidigare Python-versioner returnerade metoden :meth:`!SSLSocket.send` noll"
" istället för att ge upphov till :exc:`SSLWantWriteError` eller "
":exc:`SSLWantReadError`."

#: ../../library/ssl.rst:2421
msgid ""
"Calling :func:`~select.select` tells you that the OS-level socket can be "
"read from (or written to), but it does not imply that there is sufficient "
"data at the upper SSL layer.  For example, only part of an SSL frame might "
"have arrived.  Therefore, you must be ready to handle :meth:`SSLSocket.recv`"
" and :meth:`SSLSocket.send` failures, and retry after another call to "
":func:`~select.select`."
msgstr ""
"Om du anropar :func:`~select.select` får du veta att det går att läsa från "
"(eller skriva till) sockeln på OS-nivå, men det innebär inte att det finns "
"tillräckligt med data i det övre SSL-lagret.  Det kan t.ex. hända att bara "
"en del av en SSL-ram har kommit fram.  Därför måste du vara redo att hantera"
" misslyckanden med :meth:`SSLSocket.recv` och :meth:`SSLSocket.send`, och "
"försöka igen efter ett nytt anrop till :func:`~select.select`."

#: ../../library/ssl.rst:2428
msgid ""
"Conversely, since the SSL layer has its own framing, a SSL socket may still "
"have data available for reading without :func:`~select.select` being aware "
"of it.  Therefore, you should first call :meth:`SSLSocket.recv` to drain any"
" potentially available data, and then only block on a :func:`~select.select`"
" call if still necessary."
msgstr ""
"Omvänt, eftersom SSL-lagret har sin egen inramning, kan ett SSL-uttag "
"fortfarande ha data tillgängliga för läsning utan att :func:`~select.select`"
" är medveten om det.  Därför bör du först anropa :meth:`SSLSocket.recv` för "
"att tömma alla potentiellt tillgängliga data, och sedan bara blockera på ett"
" :func:`~select.select`\\-anrop om det fortfarande är nödvändigt."

#: ../../library/ssl.rst:2434
msgid ""
"(of course, similar provisions apply when using other primitives such as "
":func:`~select.poll`, or those in the :mod:`selectors` module)"
msgstr ""
"(Naturligtvis gäller liknande bestämmelser när du använder andra primitiver "
"som :func:`~select.poll`, eller de i :mod:`selectors`\\-modulen)"

#: ../../library/ssl.rst:2437
msgid ""
"The SSL handshake itself will be non-blocking: the "
":meth:`SSLSocket.do_handshake` method has to be retried until it returns "
"successfully.  Here is a synopsis using :func:`~select.select` to wait for "
"the socket's readiness::"
msgstr ""
"Själva SSL-handskakningen kommer att vara icke-blockerande: metoden "
":meth:`SSLSocket.do_handshake` måste prövas igen tills den returneras "
"framgångsrikt.  Här är en sammanfattning som använder :func:`~select.select`"
" för att vänta på att uttaget är redo::"

#: ../../library/ssl.rst:2453
msgid ""
"The :mod:`asyncio` module supports :ref:`non-blocking SSL sockets <ssl-"
"nonblocking>` and provides a higher level API. It polls for events using the"
" :mod:`selectors` module and handles :exc:`SSLWantWriteError`, "
":exc:`SSLWantReadError` and :exc:`BlockingIOError` exceptions. It runs the "
"SSL handshake asynchronously as well."
msgstr ""

#: ../../library/ssl.rst:2462
msgid "Memory BIO Support"
msgstr "Stöd för BIO-minne"

#: ../../library/ssl.rst:2466
msgid ""
"Ever since the SSL module was introduced in Python 2.6, the "
":class:`SSLSocket` class has provided two related but distinct areas of "
"functionality:"
msgstr ""
"Ända sedan SSL-modulen introducerades i Python 2.6 har "
":class:`SSLSocket`\\-klassen tillhandahållit två relaterade men distinkta "
"områden av funktionalitet:"

#: ../../library/ssl.rst:2469
msgid "SSL protocol handling"
msgstr "Hantering av SSL-protokoll"

#: ../../library/ssl.rst:2470
msgid "Network IO"
msgstr "Nätverk IO"

#: ../../library/ssl.rst:2472
msgid ""
"The network IO API is identical to that provided by :class:`socket.socket`, "
"from which :class:`SSLSocket` also inherits. This allows an SSL socket to be"
" used as a drop-in replacement for a regular socket, making it very easy to "
"add SSL support to an existing application."
msgstr ""
"API:et för nätverks-IO är identiskt med det som tillhandahålls av "
":class:`socket.socket`, som :class:`SSLSocket` också ärver från. Detta gör "
"att en SSL-socket kan användas som en drop-in-ersättning för en vanlig "
"socket, vilket gör det mycket enkelt att lägga till SSL-stöd i en befintlig "
"applikation."

#: ../../library/ssl.rst:2477
msgid ""
"Combining SSL protocol handling and network IO usually works well, but there"
" are some cases where it doesn't. An example is async IO frameworks that "
"want to use a different IO multiplexing model than the \"select/poll on a "
"file descriptor\" (readiness based) model that is assumed by "
":class:`socket.socket` and by the internal OpenSSL socket IO routines. This "
"is mostly relevant for platforms like Windows where this model is not "
"efficient. For this purpose, a reduced scope variant of :class:`SSLSocket` "
"called :class:`SSLObject` is provided."
msgstr ""
"Att kombinera SSL-protokollhantering och nätverks-IO fungerar vanligtvis "
"bra, men det finns vissa fall där det inte gör det. Ett exempel är asynkrona"
" IO-ramverk som vill använda en annan IO-multiplexeringsmodell än "
"\"select/poll on a file descriptor\"-modellen (beredskapsbaserad) som antas "
"av :class:`socket.socket` och av de interna OpenSSL-socket IO-rutinerna. "
"Detta är mest relevant för plattformar som Windows där denna modell inte är "
"effektiv. För detta ändamål tillhandahålls en variant med reducerat scope av"
" :class:`SSLSocket` som kallas :class:`SSLObject`."

#: ../../library/ssl.rst:2488
msgid ""
"A reduced-scope variant of :class:`SSLSocket` representing an SSL protocol "
"instance that does not contain any network IO methods. This class is "
"typically used by framework authors that want to implement asynchronous IO "
"for SSL through memory buffers."
msgstr ""
"En reducerad variant av :class:`SSLSocket` som representerar en SSL-"
"protokollinstans som inte innehåller några IO-metoder för nätverk. Den här "
"klassen används vanligtvis av ramverksförfattare som vill implementera "
"asynkron IO för SSL via minnesbuffertar."

#: ../../library/ssl.rst:2493
msgid ""
"This class implements an interface on top of a low-level SSL object as "
"implemented by OpenSSL. This object captures the state of an SSL connection "
"but does not provide any network IO itself. IO needs to be performed through"
" separate \"BIO\" objects which are OpenSSL's IO abstraction layer."
msgstr ""
"Den här klassen implementerar ett gränssnitt ovanpå ett SSL-objekt på låg "
"nivå som implementeras av OpenSSL. Detta objekt fångar upp tillståndet för "
"en SSL-anslutning men tillhandahåller inte någon egen nätverks-IO. IO måste "
"utföras genom separata \"BIO\"-objekt som är OpenSSL:s abstraktionslager för"
" IO."

#: ../../library/ssl.rst:2498
msgid ""
"This class has no public constructor.  An :class:`SSLObject` instance must "
"be created using the :meth:`~SSLContext.wrap_bio` method. This method will "
"create the :class:`SSLObject` instance and bind it to a pair of BIOs. The "
"*incoming* BIO is used to pass data from Python to the SSL protocol "
"instance, while the *outgoing* BIO is used to pass data the other way "
"around."
msgstr ""
"Denna klass har ingen offentlig konstruktör.  En instans av "
":class:`SSLObject` måste skapas med hjälp av metoden "
":meth:`~SSLContext.wrap_bio`. Denna metod skapar "
":class:`SSLObject`\\-instansen och binder den till ett par BIO:er. Den "
"*inkommande* BIO används för att skicka data från Python till SSL-"
"protokollinstansen, medan den *utgående* BIO används för att skicka data åt "
"andra hållet."

#: ../../library/ssl.rst:2505
msgid "The following methods are available:"
msgstr "Följande metoder finns tillgängliga:"

#: ../../library/ssl.rst:2507
msgid ":attr:`~SSLSocket.context`"
msgstr ":attr:`~SSLSocket.context`"

#: ../../library/ssl.rst:2508
msgid ":attr:`~SSLSocket.server_side`"
msgstr ":attr:`~SSLSocket.server_side`"

#: ../../library/ssl.rst:2509
msgid ":attr:`~SSLSocket.server_hostname`"
msgstr ":attr:`~SSLSocket.server_hostname`"

#: ../../library/ssl.rst:2510
msgid ":attr:`~SSLSocket.session`"
msgstr ":attr:`~SSLSocket.session`"

#: ../../library/ssl.rst:2511
msgid ":attr:`~SSLSocket.session_reused`"
msgstr ":attr:`~SSLSocket.session_reused`"

#: ../../library/ssl.rst:2512
msgid ":meth:`~SSLSocket.read`"
msgstr ":meth:`~SSLSocket.read`"

#: ../../library/ssl.rst:2513
msgid ":meth:`~SSLSocket.write`"
msgstr ":meth:`~SSLSocket.write`"

#: ../../library/ssl.rst:2514
msgid ":meth:`~SSLSocket.getpeercert`"
msgstr ":meth:`~SSLSocket.getpeercert`"

#: ../../library/ssl.rst:2515
msgid ":meth:`~SSLSocket.selected_alpn_protocol`"
msgstr ":meth:`~SSLSocket.selected_alpn_protocol`"

#: ../../library/ssl.rst:2516
msgid ":meth:`~SSLSocket.selected_npn_protocol`"
msgstr ":meth:`~SSLSocket.selected_npn_protocol`"

#: ../../library/ssl.rst:2517
msgid ":meth:`~SSLSocket.cipher`"
msgstr ":meth:`~SSLSocket.cipher`"

#: ../../library/ssl.rst:2518
msgid ":meth:`~SSLSocket.shared_ciphers`"
msgstr ":meth:`~SSLSocket.shared_ciphers`"

#: ../../library/ssl.rst:2519
msgid ":meth:`~SSLSocket.compression`"
msgstr ":meth:`~SSLSocket.compression`"

#: ../../library/ssl.rst:2520
msgid ":meth:`~SSLSocket.pending`"
msgstr ":meth:`~SSLSocket.pending`"

#: ../../library/ssl.rst:2521
msgid ":meth:`~SSLSocket.do_handshake`"
msgstr ":meth:`~SSLSocket.do_handshake`"

#: ../../library/ssl.rst:2522
msgid ":meth:`~SSLSocket.verify_client_post_handshake`"
msgstr ":meth:`~SSLSocket.verify_client_post_handshake`"

#: ../../library/ssl.rst:2523
msgid ":meth:`~SSLSocket.unwrap`"
msgstr ":meth:`~SSLSocket.unwrap`"

#: ../../library/ssl.rst:2524
msgid ":meth:`~SSLSocket.get_channel_binding`"
msgstr ":meth:`~SSLSocket.get_channel_binding`"

#: ../../library/ssl.rst:2525
msgid ":meth:`~SSLSocket.version`"
msgstr ":meth:`~SSLSocket.version`"

#: ../../library/ssl.rst:2527
msgid ""
"When compared to :class:`SSLSocket`, this object lacks the following "
"features:"
msgstr ""
"Jämfört med :class:`SSLSocket` saknar detta objekt följande egenskaper:"

#: ../../library/ssl.rst:2530
msgid ""
"Any form of network IO; ``recv()`` and ``send()`` read and write only to the"
" underlying :class:`MemoryBIO` buffers."
msgstr ""
"Alla former av nätverks-IO; ``recv()`` och ``send()`` läser och skriver "
"endast till de underliggande :class:`MemoryBIO`\\-buffertarna."

#: ../../library/ssl.rst:2533
msgid ""
"There is no *do_handshake_on_connect* machinery. You must always manually "
"call :meth:`~SSLSocket.do_handshake` to start the handshake."
msgstr ""
"Det finns ingen *do_handshake_on_connect*-mekanism. Du måste alltid manuellt"
" anropa :meth:`~SSLSocket.do_handshake` för att starta handskakningen."

#: ../../library/ssl.rst:2536
msgid ""
"There is no handling of *suppress_ragged_eofs*. All end-of-file conditions "
"that are in violation of the protocol are reported via the "
":exc:`SSLEOFError` exception."
msgstr ""
"Det finns ingen hantering av *suppress_ragged_eofs*. Alla villkor för "
"filändar som bryter mot protokollet rapporteras via undantaget "
":exc:`SSLEOFError`."

#: ../../library/ssl.rst:2540
msgid ""
"The method :meth:`~SSLSocket.unwrap` call does not return anything, unlike "
"for an SSL socket where it returns the underlying socket."
msgstr ""
"Anropet till metoden :meth:`~SSLSocket.unwrap` returnerar ingenting, till "
"skillnad från en SSL-socket där den underliggande sockeln returneras."

#: ../../library/ssl.rst:2543
msgid ""
"The *server_name_callback* callback passed to "
":meth:`SSLContext.set_servername_callback` will get an :class:`SSLObject` "
"instance instead of a :class:`SSLSocket` instance as its first parameter."
msgstr ""
"Den *server_name_callback* callback som skickas till "
":meth:`SSLContext.set_servername_callback` kommer att få en "
":class:`SSLObject`\\-instans istället för en :class:`SSLSocket`\\-instans "
"som sin första parameter."

#: ../../library/ssl.rst:2547
msgid "Some notes related to the use of :class:`SSLObject`:"
msgstr ""
"Några anteckningar relaterade till användningen av :class:`SSLObject`:"

#: ../../library/ssl.rst:2549
msgid ""
"All IO on an :class:`SSLObject` is :ref:`non-blocking <ssl-nonblocking>`. "
"This means that for example :meth:`~SSLSocket.read` will raise an "
":exc:`SSLWantReadError` if it needs more data than the incoming BIO has "
"available."
msgstr ""
"All IO på ett :class:`SSLObject` är :ref:`icke-blockerande <ssl-"
"nonblocking>`. Detta innebär att till exempel :meth:`~SSLSocket.read` kommer"
" att ge upphov till ett :exc:`SSLWantReadError` om det behöver mer data än "
"vad det inkommande IO:t har tillgängligt."

#: ../../library/ssl.rst:2554
msgid ""
"There is no module-level ``wrap_bio()`` call like there is for "
":meth:`~SSLContext.wrap_socket`. An :class:`SSLObject` is always created via"
" an :class:`SSLContext`."
msgstr ""

#: ../../library/ssl.rst:2558
msgid ""
":class:`SSLObject` instances must to created with "
":meth:`~SSLContext.wrap_bio`. In earlier versions, it was possible to create"
" instances directly. This was never documented or officially supported."
msgstr ""

#: ../../library/ssl.rst:2564
msgid ""
"An SSLObject communicates with the outside world using memory buffers. The "
"class :class:`MemoryBIO` provides a memory buffer that can be used for this "
"purpose.  It wraps an OpenSSL memory BIO (Basic IO) object:"
msgstr ""
"Ett SSLObject kommunicerar med omvärlden med hjälp av minnesbuffertar. "
"Klassen :class:`MemoryBIO` tillhandahåller en minnesbuffert som kan användas"
" för detta ändamål.  Den omsluter ett OpenSSL-minne BIO-objekt (Basic IO):"

#: ../../library/ssl.rst:2570
msgid ""
"A memory buffer that can be used to pass data between Python and an SSL "
"protocol instance."
msgstr ""
"En minnesbuffert som kan användas för att skicka data mellan Python och en "
"SSL-protokollinstans."

#: ../../library/ssl.rst:2575
msgid "Return the number of bytes currently in the memory buffer."
msgstr "Returnerar antalet bytes som för närvarande finns i minnesbufferten."

#: ../../library/ssl.rst:2579
msgid ""
"A boolean indicating whether the memory BIO is current at the end-of-file "
"position."
msgstr ""
"En boolean som anger om minnet BIO är aktuellt vid filens slutposition."

#: ../../library/ssl.rst:2584
msgid ""
"Read up to *n* bytes from the memory buffer. If *n* is not specified or "
"negative, all bytes are returned."
msgstr ""
"Läser upp till *n* bytes från minnesbufferten. Om *n* inte anges eller är "
"negativ returneras alla byte."

#: ../../library/ssl.rst:2589
msgid ""
"Write the bytes from *buf* to the memory BIO. The *buf* argument must be an "
"object supporting the buffer protocol."
msgstr ""
"Skriv bytena från *buf* till minnet BIO. Argumentet *buf* måste vara ett "
"objekt som stöder buffertprotokollet."

#: ../../library/ssl.rst:2592
msgid ""
"The return value is the number of bytes written, which is always equal to "
"the length of *buf*."
msgstr ""
"Returvärdet är antalet byte som skrivits, vilket alltid är lika med längden "
"på *buf*."

#: ../../library/ssl.rst:2597
msgid ""
"Write an EOF marker to the memory BIO. After this method has been called, it"
" is illegal to call :meth:`~MemoryBIO.write`. The attribute :attr:`eof` will"
" become true after all data currently in the buffer has been read."
msgstr ""
"Skriver en EOF-markör till minnet BIO. Efter att denna metod har anropats är"
" det olagligt att anropa :meth:`~MemoryBIO.write`. Attributet :attr:`eof` "
"kommer att bli sant efter att all data som för närvarande finns i bufferten "
"har lästs."

#: ../../library/ssl.rst:2603
msgid "SSL session"
msgstr "SSL-session"

#: ../../library/ssl.rst:2609
msgid "Session object used by :attr:`~SSLSocket.session`."
msgstr "Sessionsobjekt som används av :attr:`~SSLSocket.session`."

#: ../../library/ssl.rst:2621
msgid "Security considerations"
msgstr "Överväganden om säkerhet"

#: ../../library/ssl.rst:2624
msgid "Best defaults"
msgstr "Bästa standardvärden"

#: ../../library/ssl.rst:2626
msgid ""
"For **client use**, if you don't have any special requirements for your "
"security policy, it is highly recommended that you use the "
":func:`create_default_context` function to create your SSL context. It will "
"load the system's trusted CA certificates, enable certificate validation and"
" hostname checking, and try to choose reasonably secure protocol and cipher "
"settings."
msgstr ""
"För **klientanvändning**, om du inte har några särskilda krav på din "
"säkerhetspolicy, rekommenderas starkt att du använder funktionen "
":func:`create_default_context` för att skapa din SSL-kontext. Den kommer att"
" ladda systemets betrodda CA-certifikat, aktivera certifikatvalidering och "
"värdnamnskontroll och försöka välja rimligt säkra protokoll- och "
"chifferinställningar."

#: ../../library/ssl.rst:2633
msgid ""
"For example, here is how you would use the :class:`smtplib.SMTP` class to "
"create a trusted, secure connection to a SMTP server::"
msgstr ""
"Så här kan du till exempel använda klassen :class:`smtplib.SMTP` för att "
"skapa en betrodd, säker anslutning till en SMTP-server::"

#: ../../library/ssl.rst:2642
msgid ""
"If a client certificate is needed for the connection, it can be added with "
":meth:`SSLContext.load_cert_chain`."
msgstr ""
"Om det behövs ett klientcertifikat för anslutningen kan det läggas till med "
":meth:`SSLContext.load_cert_chain`."

#: ../../library/ssl.rst:2645
msgid ""
"By contrast, if you create the SSL context by calling the "
":class:`SSLContext` constructor yourself, it will not have certificate "
"validation nor hostname checking enabled by default.  If you do so, please "
"read the paragraphs below to achieve a good security level."
msgstr ""
"Om du däremot skapar SSL-kontexten genom att anropa "
":class:`SSLContext`\\-konstruktören själv, kommer den inte att ha "
"certifikatvalidering eller kontroll av värdnamn aktiverat som standard.  Om "
"du gör det bör du läsa nedanstående stycken för att uppnå en bra "
"säkerhetsnivå."

#: ../../library/ssl.rst:2651
msgid "Manual settings"
msgstr "Manuella inställningar"

#: ../../library/ssl.rst:2654
msgid "Verifying certificates"
msgstr "Verifiering av certifikat"

#: ../../library/ssl.rst:2656
msgid ""
"When calling the :class:`SSLContext` constructor directly, "
":const:`CERT_NONE` is the default.  Since it does not authenticate the other"
" peer, it can be insecure, especially in client mode where most of time you "
"would like to ensure the authenticity of the server you're talking to. "
"Therefore, when in client mode, it is highly recommended to use "
":const:`CERT_REQUIRED`.  However, it is in itself not sufficient; you also "
"have to check that the server certificate, which can be obtained by calling "
":meth:`SSLSocket.getpeercert`, matches the desired service.  For many "
"protocols and applications, the service can be identified by the hostname; "
"in this case, the :func:`match_hostname` function can be used.  This common "
"check is automatically performed when :attr:`SSLContext.check_hostname` is "
"enabled."
msgstr ""

#: ../../library/ssl.rst:2669
msgid ""
"Hostname matchings is now performed by OpenSSL. Python no longer uses "
":func:`match_hostname`."
msgstr ""
"Matchning av värdnamn utförs nu av OpenSSL. Python använder inte längre "
":func:`match_hostname`."

#: ../../library/ssl.rst:2673
msgid ""
"In server mode, if you want to authenticate your clients using the SSL layer"
" (rather than using a higher-level authentication mechanism), you'll also "
"have to specify :const:`CERT_REQUIRED` and similarly check the client "
"certificate."
msgstr ""
"Om du i serverläget vill autentisera dina klienter med hjälp av SSL-lagret "
"(i stället för att använda en autentiseringsmekanism på högre nivå) måste du"
" också ange :const:`CERT_REQUIRED` och kontrollera klientcertifikatet på "
"samma sätt."

#: ../../library/ssl.rst:2679
msgid "Protocol versions"
msgstr "Protokollversioner"

#: ../../library/ssl.rst:2681
msgid ""
"SSL versions 2 and 3 are considered insecure and are therefore dangerous to "
"use.  If you want maximum compatibility between clients and servers, it is "
"recommended to use :const:`PROTOCOL_TLS_CLIENT` or "
":const:`PROTOCOL_TLS_SERVER` as the protocol version. SSLv2 and SSLv3 are "
"disabled by default."
msgstr ""
"SSL version 2 och 3 anses vara osäkra och är därför farliga att använda.  Om"
" du vill ha maximal kompatibilitet mellan klienter och servrar rekommenderas"
" det att du använder :const:`PROTOCOL_TLS_CLIENT` eller "
":const:`PROTOCOL_TLS_SERVER` som protokollversion. SSLv2 och SSLv3 är "
"inaktiverade som standard."

#: ../../library/ssl.rst:2694
msgid ""
"The SSL context created above will only allow TLSv1.3 and later (if "
"supported by your system) connections to a server. "
":const:`PROTOCOL_TLS_CLIENT` implies certificate validation and hostname "
"checks by default. You have to load certificates into the context."
msgstr ""
"SSL-kontexten som skapades ovan tillåter endast TLSv1.3 och senare (om det "
"stöds av ditt system) anslutningar till en server. "
":const:`PROTOCOL_TLS_CLIENT` innebär certifikatvalidering och "
"värdnamnskontroller som standard. Du måste ladda certifikat i kontexten."

#: ../../library/ssl.rst:2701
msgid "Cipher selection"
msgstr "Val av chiffer"

#: ../../library/ssl.rst:2703
msgid ""
"If you have advanced security requirements, fine-tuning of the ciphers "
"enabled when negotiating a SSL session is possible through the "
":meth:`SSLContext.set_ciphers` method.  Starting from Python 3.2.3, the ssl "
"module disables certain weak ciphers by default, but you may want to further"
" restrict the cipher choice. Be sure to read OpenSSL's documentation about "
"the `cipher list format "
"<https://www.openssl.org/docs/man1.1.1/man1/ciphers.html#CIPHER-LIST-"
"FORMAT>`_. If you want to check which ciphers are enabled by a given cipher "
"list, use :meth:`SSLContext.get_ciphers` or the ``openssl ciphers`` command "
"on your system."
msgstr ""

#: ../../library/ssl.rst:2714
msgid "Multi-processing"
msgstr "Multiprocessing"

#: ../../library/ssl.rst:2716
msgid ""
"If using this module as part of a multi-processed application (using, for "
"example the :mod:`multiprocessing` or :mod:`concurrent.futures` modules), be"
" aware that OpenSSL's internal random number generator does not properly "
"handle forked processes.  Applications must change the PRNG state of the "
"parent process if they use any SSL feature with :func:`os.fork`.  Any "
"successful call of :func:`~ssl.RAND_add`, :func:`~ssl.RAND_bytes` or "
":func:`~ssl.RAND_pseudo_bytes` is sufficient."
msgstr ""

#: ../../library/ssl.rst:2728
msgid "TLS 1.3"
msgstr "TLS 1.3"

#: ../../library/ssl.rst:2732
msgid ""
"The TLS 1.3 protocol behaves slightly differently than previous version of "
"TLS/SSL. Some new TLS 1.3 features are not yet available."
msgstr ""
"Protokollet TLS 1.3 beter sig något annorlunda än tidigare versioner av "
"TLS/SSL. Vissa nya funktioner i TLS 1.3 är ännu inte tillgängliga."

#: ../../library/ssl.rst:2735
msgid ""
"TLS 1.3 uses a disjunct set of cipher suites. All AES-GCM and ChaCha20 "
"cipher suites are enabled by default.  The method "
":meth:`SSLContext.set_ciphers` cannot enable or disable any TLS 1.3 ciphers "
"yet, but :meth:`SSLContext.get_ciphers` returns them."
msgstr ""
"TLS 1.3 använder en disjunkt uppsättning chiffersviter. Alla AES-GCM- och "
"ChaCha20-chiffersviter är aktiverade som standard.  Metoden "
":meth:`SSLContext.set_ciphers` kan inte aktivera eller inaktivera några TLS "
"1.3-chiffer ännu, men :meth:`SSLContext.get_ciphers` returnerar dem."

#: ../../library/ssl.rst:2739
msgid ""
"Session tickets are no longer sent as part of the initial handshake and are "
"handled differently.  :attr:`SSLSocket.session` and :class:`SSLSession` are "
"not compatible with TLS 1.3."
msgstr ""
"Sessionsbiljetter skickas inte längre som en del av den inledande "
"handskakningen och hanteras annorlunda. :attr:`SSLSocket.session` och "
":class:`SSLSession` är inte kompatibla med TLS 1.3."

#: ../../library/ssl.rst:2742
msgid ""
"Client-side certificates are also no longer verified during the initial "
"handshake.  A server can request a certificate at any time.  Clients process"
" certificate requests while they send or receive application data from the "
"server."
msgstr ""
"Certifikat på klientsidan verifieras inte heller längre under den första "
"handskakningen.  En server kan begära ett certifikat när som helst.  "
"Klienter behandlar certifikatbegäran medan de skickar eller tar emot "
"programdata från servern."

#: ../../library/ssl.rst:2746
msgid ""
"TLS 1.3 features like early data, deferred TLS client cert request, "
"signature algorithm configuration, and rekeying are not supported yet."
msgstr ""
"TLS 1.3-funktioner som tidig data, uppskjuten begäran om TLS-"
"klientcertifikat, konfiguration av signaturalgoritm och omkodning stöds inte"
" ännu."

#: ../../library/ssl.rst:2753
msgid "Class :class:`socket.socket`"
msgstr "Klassen :class:`socket.socket`"

#: ../../library/ssl.rst:2753
msgid "Documentation of underlying :mod:`socket` class"
msgstr "Dokumentation av den underliggande :mod:`socket`\\-klassen"

#: ../../library/ssl.rst:2756
msgid ""
"`SSL/TLS Strong Encryption: An Introduction "
"<https://httpd.apache.org/docs/trunk/en/ssl/ssl_intro.html>`_"
msgstr ""
"`SSL/TLS Stark Kryptering: En introduktion "
"<https://httpd.apache.org/docs/trunk/en/ssl/ssl_intro.html>`_"

#: ../../library/ssl.rst:2756
msgid "Intro from the Apache HTTP Server documentation"
msgstr "Intro från dokumentationen för Apache HTTP Server"

#: ../../library/ssl.rst:2759
msgid ""
":rfc:`RFC 1422: Privacy Enhancement for Internet Electronic Mail: Part II: "
"Certificate-Based Key Management <1422>`"
msgstr ""
":rfc:`RFC 1422: Förbättrad sekretess för elektronisk post på Internet: Part "
"II: Certificate-Based Key Management <1422>`"

#: ../../library/ssl.rst:2759
msgid "Steve Kent"
msgstr "Steve Kent"

#: ../../library/ssl.rst:2762
msgid ":rfc:`RFC 4086: Randomness Requirements for Security <4086>`"
msgstr ":rfc:`RFC 4086: Slumpmässighetskrav för säkerhet <4086>`"

#: ../../library/ssl.rst:2762
msgid "Donald E., Jeffrey I. Schiller"
msgstr "Donald E., Jeffrey I. Schiller"

#: ../../library/ssl.rst:2765
msgid ""
":rfc:`RFC 5280: Internet X.509 Public Key Infrastructure Certificate and "
"Certificate Revocation List (CRL) Profile <5280>`"
msgstr ""
":rfc:`RFC 5280: Profil för Internet X.509 Public Key Infrastructure-"
"certifikat och lista över återkallade certifikat (CRL) <5280>`"

#: ../../library/ssl.rst:2765
msgid "D. Cooper"
msgstr "D. Cooper"

#: ../../library/ssl.rst:2768
msgid ""
":rfc:`RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2 "
"<5246>`"
msgstr ""
":rfc:`RFC 5246: TLS-protokollet (Transport Layer Security) version 1.2 "
"<5246>`"

#: ../../library/ssl.rst:2768
msgid "T. Dierks et. al."
msgstr "T. Dierks et. al."

#: ../../library/ssl.rst:2771
msgid ":rfc:`RFC 6066: Transport Layer Security (TLS) Extensions <6066>`"
msgstr ":rfc:`RFC 6066: TLS-tillägg (Transport Layer Security) <6066>`"

#: ../../library/ssl.rst:2771
msgid "D. Eastlake"
msgstr "D. Eastlake"

#: ../../library/ssl.rst:2774
msgid ""
"`IANA TLS: Transport Layer Security (TLS) Parameters "
"<https://www.iana.org/assignments/tls-parameters/tls-parameters.xml>`_"
msgstr ""
"`IANA TLS: Parametrar för TLS (Transport Layer Security) "
"<https://www.iana.org/assignments/tls-parameters/tls-parameters.xml>`_"

#: ../../library/ssl.rst:2774
msgid "IANA"
msgstr "IANA"

#: ../../library/ssl.rst:2777
msgid ""
":rfc:`RFC 7525: Recommendations for Secure Use of Transport Layer Security "
"(TLS) and Datagram Transport Layer Security (DTLS) <7525>`"
msgstr ""
":rfc:`RFC 7525: Rekommendationer för säker användning av TLS (Transport "
"Layer Security) och DTLS (Datagram Transport Layer Security) <7525>`"

#: ../../library/ssl.rst:2777
msgid "IETF"
msgstr "IETF"

#: ../../library/ssl.rst:2779
msgid ""
"`Mozilla's Server Side TLS recommendations "
"<https://wiki.mozilla.org/Security/Server_Side_TLS>`_"
msgstr ""
"`Mozillas TLS-rekommendationer för serversidan "
"<https://wiki.mozilla.org/Security/Server_Side_TLS>`_"

#: ../../library/ssl.rst:2780
msgid "Mozilla"
msgstr "Mozilla"

#: ../../library/ssl.rst:12
msgid "OpenSSL"
msgstr "OpenSSL"

#: ../../library/ssl.rst:12
msgid "(use in module ssl)"
msgstr "(används i modul ssl)"

#: ../../library/ssl.rst:14
msgid "TLS"
msgstr "TLS"

#: ../../library/ssl.rst:14
msgid "SSL"
msgstr "SSL"

#: ../../library/ssl.rst:14
msgid "Transport Layer Security"
msgstr "Transport Layer Security"

#: ../../library/ssl.rst:14
msgid "Secure Sockets Layer"
msgstr "Secure Sockets Layer"

#: ../../library/ssl.rst:2088
msgid "certificates"
msgstr "certifikat"

#: ../../library/ssl.rst:2090
msgid "X509 certificate"
msgstr "X509-certifikat"
