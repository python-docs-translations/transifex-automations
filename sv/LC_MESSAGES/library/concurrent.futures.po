# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# python-doc bot, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-25 18:05+0000\n"
"PO-Revision-Date: 2025-09-22 17:54+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../library/concurrent.futures.rst:2
msgid ":mod:`concurrent.futures` --- Launching parallel tasks"
msgstr ""

#: ../../library/concurrent.futures.rst:9
msgid ""
"**Source code:** :source:`Lib/concurrent/futures/thread.py` and "
":source:`Lib/concurrent/futures/process.py`"
msgstr ""

#: ../../library/concurrent.futures.rst:14
msgid ""
"The :mod:`concurrent.futures` module provides a high-level interface for "
"asynchronously executing callables."
msgstr ""
"Modulen :mod:`concurrent.futures` tillhandahåller ett gränssnitt på hög nivå"
" för asynkron exekvering av anropbara filer."

#: ../../library/concurrent.futures.rst:17
msgid ""
"The asynchronous execution can be performed with threads, using "
":class:`ThreadPoolExecutor`, or separate processes, using "
":class:`ProcessPoolExecutor`.  Both implement the same interface, which is "
"defined by the abstract :class:`Executor` class."
msgstr ""

#: ../../library/concurrent.futures.rst:24
msgid "Executor Objects"
msgstr "Exekverande objekt"

#: ../../library/concurrent.futures.rst:28
msgid ""
"An abstract class that provides methods to execute calls asynchronously.  It"
" should not be used directly, but through its concrete subclasses."
msgstr ""
"En abstrakt klass som tillhandahåller metoder för att exekvera anrop "
"asynkront.  Den bör inte användas direkt, utan genom sina konkreta "
"underklasser."

#: ../../library/concurrent.futures.rst:33
msgid ""
"Schedules the callable, *fn*, to be executed as ``fn(*args, **kwargs)`` and "
"returns a :class:`Future` object representing the execution of the callable."
" ::"
msgstr ""
"Schemalägger anropbarheten *fn* så att den exekveras som ``fn(*args, "
"**kwargs)`` och returnerar ett :class:`Future`\\-objekt som representerar "
"exekveringen av anropbarheten. ::"

#: ../../library/concurrent.futures.rst:43
msgid "Similar to :func:`map(func, *iterables) <map>` except:"
msgstr ""

#: ../../library/concurrent.futures.rst:45
msgid "the *iterables* are collected immediately rather than lazily;"
msgstr ""

#: ../../library/concurrent.futures.rst:47
msgid ""
"*func* is executed asynchronously and several calls to *func* may be made "
"concurrently."
msgstr ""

#: ../../library/concurrent.futures.rst:50
msgid ""
"The returned iterator raises a :exc:`concurrent.futures.TimeoutError` if "
":meth:`~iterator.__next__` is called and the result isn't available after "
"*timeout* seconds from the original call to :meth:`Executor.map`. *timeout* "
"can be an int or a float.  If *timeout* is not specified or ``None``, there "
"is no limit to the wait time."
msgstr ""

#: ../../library/concurrent.futures.rst:56
msgid ""
"If a *func* call raises an exception, then that exception will be raised "
"when its value is retrieved from the iterator."
msgstr ""

#: ../../library/concurrent.futures.rst:59
msgid ""
"When using :class:`ProcessPoolExecutor`, this method chops *iterables* into "
"a number of chunks which it submits to the pool as separate tasks.  The "
"(approximate) size of these chunks can be specified by setting *chunksize* "
"to a positive integer.  For very long iterables, using a large value for "
"*chunksize* can significantly improve performance compared to the default "
"size of 1.  With :class:`ThreadPoolExecutor`, *chunksize* has no effect."
msgstr ""

#: ../../library/concurrent.futures.rst:67
msgid "Added the *chunksize* argument."
msgstr ""

#: ../../library/concurrent.futures.rst:72
msgid ""
"Signal the executor that it should free any resources that it is using when "
"the currently pending futures are done executing.  Calls to "
":meth:`Executor.submit` and :meth:`Executor.map` made after shutdown will "
"raise :exc:`RuntimeError`."
msgstr ""
"Signalerar till exekutorn att den ska frigöra alla resurser som den använder"
" när de aktuella väntande futures är klara med exekveringen.  Anrop till "
":meth:`Executor.submit` och :meth:`Executor.map` som görs efter nedstängning"
" kommer att ge upphov till :exc:`RuntimeError`."

#: ../../library/concurrent.futures.rst:77
msgid ""
"If *wait* is ``True`` then this method will not return until all the pending"
" futures are done executing and the resources associated with the executor "
"have been freed.  If *wait* is ``False`` then this method will return "
"immediately and the resources associated with the executor will be freed "
"when all pending futures are done executing.  Regardless of the value of "
"*wait*, the entire Python program will not exit until all pending futures "
"are done executing."
msgstr ""
"Om *wait* är ``True`` kommer denna metod inte att returneras förrän alla "
"väntande futures har exekverats och de resurser som är associerade med "
"exekveraren har frigjorts.  Om *wait* är ``False`` kommer denna metod att "
"returneras omedelbart och resurserna som är associerade med exekveraren "
"kommer att frigöras när alla väntande futures har exekverats.  Oavsett "
"värdet på *wait* kommer hela Python-programmet inte att avslutas förrän alla"
" väntande futures har exekverats."

#: ../../library/concurrent.futures.rst:85
msgid ""
"If *cancel_futures* is ``True``, this method will cancel all pending futures"
" that the executor has not started running. Any futures that are completed "
"or running won't be cancelled, regardless of the value of *cancel_futures*."
msgstr ""
"Om *cancel_futures* är ``True``, kommer denna metod att avbryta alla "
"väntande futures som exekutören inte har börjat köra. Eventuella terminer "
"som är avslutade eller körs kommer inte att annulleras, oavsett värdet på "
"*cancel_futures*."

#: ../../library/concurrent.futures.rst:90
msgid ""
"If both *cancel_futures* and *wait* are ``True``, all futures that the "
"executor has started running will be completed prior to this method "
"returning. The remaining futures are cancelled."
msgstr ""
"Om både *cancel_futures* och *wait* är ``True``, kommer alla futures som "
"exekutorn har börjat köra att slutföras innan denna metod återkommer. De "
"återstående futures avbryts."

#: ../../library/concurrent.futures.rst:94
msgid ""
"You can avoid having to call this method explicitly if you use the "
":keyword:`with` statement, which will shutdown the :class:`Executor` "
"(waiting as if :meth:`Executor.shutdown` were called with *wait* set to "
"``True``)::"
msgstr ""

#: ../../library/concurrent.futures.rst:106
msgid "Added *cancel_futures*."
msgstr "Lagt till *cancel_futures*."

#: ../../library/concurrent.futures.rst:111
msgid "ThreadPoolExecutor"
msgstr "ThreadPool-utförare"

#: ../../library/concurrent.futures.rst:113
msgid ""
":class:`ThreadPoolExecutor` is an :class:`Executor` subclass that uses a "
"pool of threads to execute calls asynchronously."
msgstr ""
":class:`ThreadPoolExecutor` är en :class:`Executor`\\-underklass som "
"använder en pool av trådar för att utföra anrop asynkront."

#: ../../library/concurrent.futures.rst:116
msgid ""
"Deadlocks can occur when the callable associated with a :class:`Future` "
"waits on the results of another :class:`Future`.  For example::"
msgstr ""
"Dödlägen kan uppstå när den anropbara funktionen som är associerad med en "
":class:`Future` väntar på resultatet av en annan :class:`Future`.  Till "
"exempel::"

#: ../../library/concurrent.futures.rst:135
msgid "And::"
msgstr "Och::"

#: ../../library/concurrent.futures.rst:149
msgid ""
"An :class:`Executor` subclass that uses a pool of at most *max_workers* "
"threads to execute calls asynchronously."
msgstr ""
"En :class:`Executor`\\-underklass som använder en pool med högst "
"*max_workers* trådar för att utföra anrop asynkront."

#: ../../library/concurrent.futures.rst:152
msgid ""
"*initializer* is an optional callable that is called at the start of each "
"worker thread; *initargs* is a tuple of arguments passed to the initializer."
"  Should *initializer* raise an exception, all currently pending jobs will "
"raise a :exc:`~concurrent.futures.thread.BrokenThreadPool`, as well as any "
"attempt to submit more jobs to the pool."
msgstr ""
"*initializer* är en valfri callable som anropas i början av varje "
"arbetstråd; *initargs* är en tupel av argument som skickas till "
"initializern.  Om *initializer* ger upphov till ett undantag kommer alla "
"pågående jobb att ge upphov till en "
":exc:`~concurrent.futures.thread.BrokenThreadPool`, liksom alla försök att "
"skicka fler jobb till poolen."

#: ../../library/concurrent.futures.rst:158
msgid ""
"If *max_workers* is ``None`` or not given, it will default to the number of "
"processors on the machine, multiplied by ``5``, assuming that "
":class:`ThreadPoolExecutor` is often used to overlap I/O instead of CPU work"
" and the number of workers should be higher than the number of workers for "
":class:`ProcessPoolExecutor`."
msgstr ""
"Om *max_workers* är ``None`` eller inte anges, kommer det som standard att "
"vara antalet processorer på maskinen, multiplicerat med ``5``, förutsatt att"
" :class:`ThreadPoolExecutor` ofta används för att överlappa I/O istället för"
" CPU-arbete och antalet workers bör vara högre än antalet workers för "
":class:`ProcessPoolExecutor`."

#: ../../library/concurrent.futures.rst:166
msgid ""
"The *thread_name_prefix* argument was added to allow users to control the "
":class:`threading.Thread` names for worker threads created by the pool for "
"easier debugging."
msgstr ""

#: ../../library/concurrent.futures.rst:171
#: ../../library/concurrent.futures.rst:265
msgid "Added the *initializer* and *initargs* arguments."
msgstr "Lagt till argumenten *initializer* och *initargs*."

#: ../../library/concurrent.futures.rst:174
msgid ""
"Default value of *max_workers* is changed to ``min(32, os.cpu_count() + "
"4)``. This default value preserves at least 5 workers for I/O bound tasks. "
"It utilizes at most 32 CPU cores for CPU bound tasks which release the GIL. "
"And it avoids using very large resources implicitly on many-core machines."
msgstr ""
"Standardvärdet för *max_workers* ändras till ``min(32, os.cpu_count() + "
"4)``. Detta standardvärde bevarar minst 5 arbetare för I/O-bundna uppgifter."
" Det använder högst 32 CPU-kärnor för CPU-bundna uppgifter som frigör GIL. "
"Och det undviker att använda mycket stora resurser implicit på flerkärniga "
"maskiner."

#: ../../library/concurrent.futures.rst:180
msgid ""
"ThreadPoolExecutor now reuses idle worker threads before starting "
"*max_workers* worker threads too."
msgstr ""
"ThreadPoolExecutor återanvänder nu inaktiva arbetstrådar innan *max_workers*"
" arbetstrådar också startas."

#: ../../library/concurrent.futures.rst:187
msgid "ThreadPoolExecutor Example"
msgstr "ThreadPoolExecutor Exempel"

#: ../../library/concurrent.futures.rst:219
msgid "ProcessPoolExecutor"
msgstr "ProcessPoolExekutör"

#: ../../library/concurrent.futures.rst:221
msgid ""
"The :class:`ProcessPoolExecutor` class is an :class:`Executor` subclass that"
" uses a pool of processes to execute calls asynchronously. "
":class:`ProcessPoolExecutor` uses the :mod:`multiprocessing` module, which "
"allows it to side-step the :term:`Global Interpreter Lock <global "
"interpreter lock>` but also means that only picklable objects can be "
"executed and returned."
msgstr ""
"Klassen :class:`ProcessPoolExecutor` är en underklass till :class:`Executor`"
" som använder en pool av processer för att exekvera anrop asynkront. "
":class:`ProcessPoolExecutor` använder modulen :mod:`multiprocessing`, vilket"
" gör att den kan kringgå :term:`Global Interpreter Lock <global interpreter "
"lock>`, men innebär också att endast picklbara objekt kan exekveras och "
"returneras."

#: ../../library/concurrent.futures.rst:228
msgid ""
"The ``__main__`` module must be importable by worker subprocesses. This "
"means that :class:`ProcessPoolExecutor` will not work in the interactive "
"interpreter."
msgstr ""
"Modulen ``__main__`` måste kunna importeras av underprocesser som arbetar. "
"Detta innebär att :class:`ProcessPoolExecutor` inte kommer att fungera i den"
" interaktiva tolken."

#: ../../library/concurrent.futures.rst:231
msgid ""
"Calling :class:`Executor` or :class:`Future` methods from a callable "
"submitted to a :class:`ProcessPoolExecutor` will result in deadlock."
msgstr ""
"Anrop av :class:`Executor` eller :class:`Future` metoder från en callable "
"som skickats till en :class:`ProcessPoolExecutor` kommer att resultera i "
"deadlock."

#: ../../library/concurrent.futures.rst:236
msgid ""
"An :class:`Executor` subclass that executes calls asynchronously using a "
"pool of at most *max_workers* processes.  If *max_workers* is ``None`` or "
"not given, it will default to the number of processors on the machine. If "
"*max_workers* is less than or equal to ``0``, then a :exc:`ValueError` will "
"be raised. On Windows, *max_workers* must be less than or equal to ``61``. "
"If it is not then :exc:`ValueError` will be raised. If *max_workers* is "
"``None``, then the default chosen will be at most ``61``, even if more "
"processors are available. *mp_context* can be a multiprocessing context or "
"None. It will be used to launch the workers. If *mp_context* is ``None`` or "
"not given, the default multiprocessing context is used."
msgstr ""

#: ../../library/concurrent.futures.rst:249
msgid ""
"*initializer* is an optional callable that is called at the start of each "
"worker process; *initargs* is a tuple of arguments passed to the "
"initializer.  Should *initializer* raise an exception, all currently pending"
" jobs will raise a :exc:`~concurrent.futures.process.BrokenProcessPool`, as "
"well as any attempt to submit more jobs to the pool."
msgstr ""
"*initializer* är en valfri callable som anropas i början av varje "
"arbetsprocess; *initargs* är en tupel av argument som skickas till "
"initializern.  Om *initializer* ger upphov till ett undantag kommer alla "
"pågående jobb att ge upphov till en "
":exc:`~concurrent.futures.process.BrokenProcessPool`, liksom alla försök att"
" skicka fler jobb till poolen."

#: ../../library/concurrent.futures.rst:255
msgid ""
"When one of the worker processes terminates abruptly, a "
":exc:`BrokenProcessPool` error is now raised.  Previously, behaviour was "
"undefined but operations on the executor or its futures would often freeze "
"or deadlock."
msgstr ""

#: ../../library/concurrent.futures.rst:261
msgid ""
"The *mp_context* argument was added to allow users to control the "
"start_method for worker processes created by the pool."
msgstr ""
"Argumentet *mp_context* lades till för att användare ska kunna styra "
"startmetoden för arbetsprocesser som skapas av poolen."

#: ../../library/concurrent.futures.rst:271
msgid "ProcessPoolExecutor Example"
msgstr "Exempel på ProcessPoolExecutor"

#: ../../library/concurrent.futures.rst:309
msgid "Future Objects"
msgstr "Framtida objekt"

#: ../../library/concurrent.futures.rst:311
msgid ""
"The :class:`Future` class encapsulates the asynchronous execution of a "
"callable. :class:`Future` instances are created by :meth:`Executor.submit`."
msgstr ""
"Klassen :class:`Future` kapslar in den asynkrona exekveringen av en "
"anropsbar. Instanser av :class:`Future` skapas av :meth:`Executor.submit`."

#: ../../library/concurrent.futures.rst:316
msgid ""
"Encapsulates the asynchronous execution of a callable.  :class:`Future` "
"instances are created by :meth:`Executor.submit` and should not be created "
"directly except for testing."
msgstr ""
"Kapslar in den asynkrona exekveringen av en callable. "
":class:`Future`\\-instanser skapas av :meth:`Executor.submit` och bör inte "
"skapas direkt utom för testning."

#: ../../library/concurrent.futures.rst:322
msgid ""
"Attempt to cancel the call.  If the call is currently being executed or "
"finished running and cannot be cancelled then the method will return "
"``False``, otherwise the call will be cancelled and the method will return "
"``True``."
msgstr ""
"Försök att avbryta anropet.  Om anropet håller på att utföras eller har "
"avslutats och inte kan avbrytas kommer metoden att returnera ``False``, "
"annars kommer anropet att avbrytas och metoden kommer att returnera "
"``True``."

#: ../../library/concurrent.futures.rst:329
msgid "Return ``True`` if the call was successfully cancelled."
msgstr "Returnerar ``True`` om samtalet framgångsrikt har avbrutits."

#: ../../library/concurrent.futures.rst:333
msgid ""
"Return ``True`` if the call is currently being executed and cannot be "
"cancelled."
msgstr ""
"Returnerar ``True`` om anropet håller på att utföras och inte kan avbrytas."

#: ../../library/concurrent.futures.rst:338
msgid ""
"Return ``True`` if the call was successfully cancelled or finished running."
msgstr ""
"Returnerar ``True`` om anropet framgångsrikt avbröts eller avslutades."

#: ../../library/concurrent.futures.rst:343
msgid ""
"Return the value returned by the call. If the call hasn't yet completed then"
" this method will wait up to *timeout* seconds.  If the call hasn't "
"completed in *timeout* seconds, then a "
":exc:`concurrent.futures.TimeoutError` will be raised. *timeout* can be an "
"int or float.  If *timeout* is not specified or ``None``, there is no limit "
"to the wait time."
msgstr ""

#: ../../library/concurrent.futures.rst:350
#: ../../library/concurrent.futures.rst:364
msgid ""
"If the future is cancelled before completing then :exc:`.CancelledError` "
"will be raised."
msgstr ""
"Om framtiden avbryts innan den har slutförts kommer :exc:`.CancelledError` "
"att tas upp."

#: ../../library/concurrent.futures.rst:353
msgid ""
"If the call raised an exception, this method will raise the same exception."
msgstr ""
"Om anropet gav upphov till ett undantag kommer denna metod att ge upphov "
"till samma undantag."

#: ../../library/concurrent.futures.rst:357
msgid ""
"Return the exception raised by the call.  If the call hasn't yet completed "
"then this method will wait up to *timeout* seconds.  If the call hasn't "
"completed in *timeout* seconds, then a "
":exc:`concurrent.futures.TimeoutError` will be raised.  *timeout* can be an "
"int or float.  If *timeout* is not specified or ``None``, there is no limit "
"to the wait time."
msgstr ""

#: ../../library/concurrent.futures.rst:367
msgid "If the call completed without raising, ``None`` is returned."
msgstr ""
"Om anropet slutfördes utan att någon fråga ställdes återsänds ``None``."

#: ../../library/concurrent.futures.rst:371
msgid ""
"Attaches the callable *fn* to the future.  *fn* will be called, with the "
"future as its only argument, when the future is cancelled or finishes "
"running."
msgstr ""
"Kopplar den anropsbara *fn* till framtiden.  *fn* kommer att anropas, med "
"framtiden som enda argument, när framtiden avbryts eller slutar att köras."

#: ../../library/concurrent.futures.rst:375
msgid ""
"Added callables are called in the order that they were added and are always "
"called in a thread belonging to the process that added them.  If the "
"callable raises an :exc:`Exception` subclass, it will be logged and ignored."
"  If the callable raises a :exc:`BaseException` subclass, the behavior is "
"undefined."
msgstr ""
"Tillagda anropsbara filer anropas i den ordning de lades till och anropas "
"alltid i en tråd som tillhör den process som lade till dem.  Om "
"anropsbarheten ger upphov till en :exc:`Exception`\\-subklass loggas den och"
" ignoreras.  Om anropet ger upphov till en subklass av :exc:`BaseException` "
"är beteendet odefinierat."

#: ../../library/concurrent.futures.rst:381
msgid ""
"If the future has already completed or been cancelled, *fn* will be called "
"immediately."
msgstr ""
"Om framtiden redan har avslutats eller avbrutits, kommer *fn* att anropas "
"omedelbart."

#: ../../library/concurrent.futures.rst:384
msgid ""
"The following :class:`Future` methods are meant for use in unit tests and "
":class:`Executor` implementations."
msgstr ""
"Följande :class:`Future`\\-metoder är avsedda att användas i enhetstester "
"och :class:`Executor`\\-implementationer."

#: ../../library/concurrent.futures.rst:389
msgid ""
"This method should only be called by :class:`Executor` implementations "
"before executing the work associated with the :class:`Future` and by unit "
"tests."
msgstr ""
"Denna metod bör endast anropas av :class:`Executor`\\-implementationer innan"
" de utför det arbete som är associerat med :class:`Future` och av "
"enhetstester."

#: ../../library/concurrent.futures.rst:393
msgid ""
"If the method returns ``False`` then the :class:`Future` was cancelled, i.e."
" :meth:`Future.cancel` was called and returned `True`.  Any threads waiting "
"on the :class:`Future` completing (i.e. through :func:`as_completed` or "
":func:`wait`) will be woken up."
msgstr ""

#: ../../library/concurrent.futures.rst:398
msgid ""
"If the method returns ``True`` then the :class:`Future` was not cancelled "
"and has been put in the running state, i.e. calls to :meth:`Future.running` "
"will return `True`."
msgstr ""

#: ../../library/concurrent.futures.rst:402
msgid ""
"This method can only be called once and cannot be called after "
":meth:`Future.set_result` or :meth:`Future.set_exception` have been called."
msgstr ""
"Denna metod kan bara anropas en gång och kan inte anropas efter att "
":meth:`Future.set_result` eller :meth:`Future.set_exception` har anropats."

#: ../../library/concurrent.futures.rst:408
msgid ""
"Sets the result of the work associated with the :class:`Future` to *result*."
msgstr ""
"Ställer in resultatet av det arbete som är associerat med :class:`Future` "
"till *result*."

#: ../../library/concurrent.futures.rst:411
#: ../../library/concurrent.futures.rst:424
msgid ""
"This method should only be used by :class:`Executor` implementations and "
"unit tests."
msgstr ""
"Denna metod bör endast användas av :class:`Executor`\\-implementationer och "
"enhetstester."

#: ../../library/concurrent.futures.rst:414
#: ../../library/concurrent.futures.rst:427
msgid ""
"This method raises :exc:`concurrent.futures.InvalidStateError` if the "
":class:`Future` is already done."
msgstr ""
"Denna metod ger upphov till :exc:`concurrent.futures.InvalidStateError` om "
":class:`Future` redan är klar."

#: ../../library/concurrent.futures.rst:421
msgid ""
"Sets the result of the work associated with the :class:`Future` to the "
":class:`Exception` *exception*."
msgstr ""
"Ställer in resultatet av det arbete som associeras med :class:`Future` till "
":class:`Exception` *exception*."

#: ../../library/concurrent.futures.rst:433
msgid "Module Functions"
msgstr "Modulens funktioner"

#: ../../library/concurrent.futures.rst:437
msgid ""
"Wait for the :class:`Future` instances (possibly created by different "
":class:`Executor` instances) given by *fs* to complete. Duplicate futures "
"given to *fs* are removed and will be returned only once. Returns a named "
"2-tuple of sets.  The first set, named ``done``, contains the futures that "
"completed (finished or cancelled futures) before the wait completed.  The "
"second set, named ``not_done``, contains the futures that did not complete "
"(pending or running futures)."
msgstr ""
"Vänta på att :class:`Future`\\-instanser (eventuellt skapade av olika "
":class:`Executor`\\-instanser) som ges av *fs* ska slutföras. Duplicerade "
"futures som ges till *fs* tas bort och returneras endast en gång. Returnerar"
" en namngiven 2-tupel av uppsättningar.  Den första uppsättningen, med "
"namnet ``done``, innehåller de futures som slutfördes (finished eller "
"cancelled futures) innan väntan slutfördes.  Den andra uppsättningen, med "
"namnet ``not_done``, innehåller de terminer som inte slutfördes (väntande "
"eller pågående terminer)."

#: ../../library/concurrent.futures.rst:445
msgid ""
"*timeout* can be used to control the maximum number of seconds to wait "
"before returning.  *timeout* can be an int or float.  If *timeout* is not "
"specified or ``None``, there is no limit to the wait time."
msgstr ""
"*timeout* kan användas för att styra det maximala antalet sekunder som ska "
"väntas innan returnering.  *timeout* kan vara en int eller float.  Om "
"*timeout* inte anges eller om ``None``, finns det ingen gräns för "
"väntetiden."

#: ../../library/concurrent.futures.rst:449
msgid ""
"*return_when* indicates when this function should return.  It must be one of"
" the following constants:"
msgstr ""
"*return_when* anger när denna funktion ska returnera.  Den måste vara en av "
"följande konstanter:"

#: ../../library/concurrent.futures.rst:455
msgid "Constant"
msgstr "Konstant"

#: ../../library/concurrent.futures.rst:455
msgid "Description"
msgstr "Beskrivning"

#: ../../library/concurrent.futures.rst:457
msgid ":const:`FIRST_COMPLETED`"
msgstr ""

#: ../../library/concurrent.futures.rst:457
msgid "The function will return when any future finishes or is cancelled."
msgstr ""
"Funktionen kommer att återkomma när någon framtid avslutas eller avbryts."

#: ../../library/concurrent.futures.rst:460
msgid ":const:`FIRST_EXCEPTION`"
msgstr ""

#: ../../library/concurrent.futures.rst:460
msgid ""
"The function will return when any future finishes by raising an exception.  "
"If no future raises an exception then it is equivalent to "
":const:`ALL_COMPLETED`."
msgstr ""

#: ../../library/concurrent.futures.rst:466
msgid ":const:`ALL_COMPLETED`"
msgstr ""

#: ../../library/concurrent.futures.rst:466
msgid "The function will return when all futures finish or are cancelled."
msgstr "Funktionen återkommer när alla terminer är avslutade eller avbrutna."

#: ../../library/concurrent.futures.rst:472
msgid ""
"Returns an iterator over the :class:`Future` instances (possibly created by "
"different :class:`Executor` instances) given by *fs* that yields futures as "
"they complete (finished or cancelled futures). Any futures given by *fs* "
"that are duplicated will be returned once. Any futures that completed before"
" :func:`as_completed` is called will be yielded first.  The returned "
"iterator raises a :exc:`concurrent.futures.TimeoutError` if "
":meth:`~iterator.__next__` is called and the result isn't available after "
"*timeout* seconds from the original call to :func:`as_completed`.  *timeout*"
" can be an int or float. If *timeout* is not specified or ``None``, there is"
" no limit to the wait time."
msgstr ""

#: ../../library/concurrent.futures.rst:486
msgid ":pep:`3148` -- futures - execute computations asynchronously"
msgstr ":pep:`3148` -- futures - utföra beräkningar asynkront"

#: ../../library/concurrent.futures.rst:486
msgid ""
"The proposal which described this feature for inclusion in the Python "
"standard library."
msgstr ""
"Förslaget som beskrev denna funktion för inkludering i Pythons "
"standardbibliotek."

#: ../../library/concurrent.futures.rst:491
msgid "Exception classes"
msgstr "Undantagsklasser"

#: ../../library/concurrent.futures.rst:497
msgid "Raised when a future is cancelled."
msgstr "Utlöses när en framtid avbryts."

#: ../../library/concurrent.futures.rst:501
msgid "Raised when a future operation exceeds the given timeout."
msgstr ""

#: ../../library/concurrent.futures.rst:505
msgid ""
"Derived from :exc:`RuntimeError`, this exception class is raised when an "
"executor is broken for some reason, and cannot be used to submit or execute "
"new tasks."
msgstr ""
"Denna undantagsklass härstammar från :exc:`RuntimeError` och uppstår när en "
"exekverare av någon anledning inte fungerar och inte kan användas för att "
"skicka in eller utföra nya uppgifter."

#: ../../library/concurrent.futures.rst:513
msgid ""
"Raised when an operation is performed on a future that is not allowed in the"
" current state."
msgstr ""
"Utlöses när en operation utförs på en future som inte är tillåten i det "
"aktuella tillståndet."

#: ../../library/concurrent.futures.rst:522
msgid ""
"Derived from :exc:`~concurrent.futures.BrokenExecutor`, this exception class"
" is raised when one of the workers of a :class:`ThreadPoolExecutor` has "
"failed initializing."
msgstr ""

#: ../../library/concurrent.futures.rst:532
msgid ""
"Derived from :exc:`~concurrent.futures.BrokenExecutor` (formerly "
":exc:`RuntimeError`), this exception class is raised when one of the workers"
" of a :class:`ProcessPoolExecutor` has terminated in a non-clean fashion "
"(for example, if it was killed from the outside)."
msgstr ""
