# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# python-doc bot, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-25 18:05+0000\n"
"PO-Revision-Date: 2025-09-22 17:54+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../library/codecs.rst:2
msgid ":mod:`codecs` --- Codec registry and base classes"
msgstr ""

#: ../../library/codecs.rst:11
msgid "**Source code:** :source:`Lib/codecs.py`"
msgstr "**Källkod:** :source:`Lib/kodekar.py`"

#: ../../library/codecs.rst:23
msgid ""
"This module defines base classes for standard Python codecs (encoders and "
"decoders) and provides access to the internal Python codec registry, which "
"manages the codec and error handling lookup process. Most standard codecs "
"are :term:`text encodings <text encoding>`, which encode text to bytes (and "
"decode bytes to text), but there are also codecs provided that encode text "
"to text, and bytes to bytes. Custom codecs may encode and decode between "
"arbitrary types, but some module features are restricted to be used "
"specifically with :term:`text encodings <text encoding>` or with codecs that"
" encode to :class:`bytes`."
msgstr ""
"Denna modul definierar basklasser för standard Python-kodekar (kodare och "
"avkodare) och ger tillgång till det interna Python-kodek-registret, som "
"hanterar uppslagningsprocessen för kodek och felhantering. De flesta "
"standardkodeker är :term:`textkodningar <text encoding>`, som kodar text "
"till byte (och avkodar byte till text), men det finns också kodeker som "
"kodar text till text och byte till byte. Anpassade kodekar kan koda och "
"avkoda mellan godtyckliga typer, men vissa modulfunktioner är begränsade "
"till att användas specifikt med :term:`text encodings <text encoding>` eller"
" med kodekar som kodar till :class:`bytes`."

#: ../../library/codecs.rst:33
msgid ""
"The module defines the following functions for encoding and decoding with "
"any codec:"
msgstr ""
"Modulen definierar följande funktioner för kodning och avkodning med valfri "
"kodek:"

#: ../../library/codecs.rst:38
msgid "Encodes *obj* using the codec registered for *encoding*."
msgstr "Kodar *obj* med hjälp av den kodek som registrerats för *kodning*."

#: ../../library/codecs.rst:40
msgid ""
"*Errors* may be given to set the desired error handling scheme. The default "
"error handler is ``'strict'`` meaning that encoding errors raise "
":exc:`ValueError` (or a more codec specific subclass, such as "
":exc:`UnicodeEncodeError`). Refer to :ref:`codec-base-classes` for more "
"information on codec error handling."
msgstr ""
"*Errors* kan anges för att ställa in önskat felhanteringssystem. "
"Standardfelhanteringen är ``'strict'`` vilket innebär att kodningsfel ger "
"upphov till :exc:`ValueError` (eller en mer kodek-specifik underklass, t.ex."
" :exc:`UnicodeEncodeError`). Se :ref:`kodek-base-classes` för mer "
"information om felhantering för kodek."

#: ../../library/codecs.rst:48
msgid "Decodes *obj* using the codec registered for *encoding*."
msgstr "Avkodar *obj* med hjälp av den kodek som registrerats för *encoding*."

#: ../../library/codecs.rst:50
msgid ""
"*Errors* may be given to set the desired error handling scheme. The default "
"error handler is ``'strict'`` meaning that decoding errors raise "
":exc:`ValueError` (or a more codec specific subclass, such as "
":exc:`UnicodeDecodeError`). Refer to :ref:`codec-base-classes` for more "
"information on codec error handling."
msgstr ""
"*Errors* kan anges för att ställa in önskat felhanteringssystem. "
"Standardfelhanteringen är ``'strict'`` vilket innebär att avkodningsfel ger "
"upphov till :exc:`ValueError` (eller en mer kodek-specifik underklass, t.ex."
" :exc:`UnicodeDecodeError`). Se :ref:`kodek-base-classes` för mer "
"information om felhantering för kodek."

#: ../../library/codecs.rst:56
msgid "The full details for each codec can also be looked up directly:"
msgstr "Fullständig information om varje kodek kan också hämtas direkt:"

#: ../../library/codecs.rst:60
msgid ""
"Looks up the codec info in the Python codec registry and returns a "
":class:`CodecInfo` object as defined below."
msgstr ""
"Letar upp kodek-info i Pythons kodek-register och returnerar ett "
":class:`KodekInfo`-objekt enligt definitionen nedan."

#: ../../library/codecs.rst:63
msgid ""
"Encodings are first looked up in the registry's cache. If not found, the "
"list of registered search functions is scanned. If no :class:`CodecInfo` "
"object is found, a :exc:`LookupError` is raised. Otherwise, the "
":class:`CodecInfo` object is stored in the cache and returned to the caller."
msgstr ""
"Kodningar söks först upp i registrets cacheminne. Om de inte hittas "
"genomsöks listan över registrerade sökfunktioner. Om inget "
":class:`KodekInfo`-objekt hittas genereras ett :exc:`LookupError`. I annat "
"fall lagras :class:`KodekInfo`-objektet i cacheminnet och returneras till "
"anroparen."

#: ../../library/codecs.rst:70
msgid ""
"Codec details when looking up the codec registry. The constructor arguments "
"are stored in attributes of the same name:"
msgstr ""
"Kodek-detaljer vid sökning i kodek-registret. Konstruktörens argument lagras"
" i attribut med samma namn:"

#: ../../library/codecs.rst:76
msgid "The name of the encoding."
msgstr "Namnet på kodningen."

#: ../../library/codecs.rst:82
msgid ""
"The stateless encoding and decoding functions. These must be functions or "
"methods which have the same interface as the :meth:`~Codec.encode` and "
":meth:`~Codec.decode` methods of Codec instances (see :ref:`Codec Interface "
"<codec-objects>`). The functions or methods are expected to work in a "
"stateless mode."
msgstr ""
"De statslösa kodnings- och avkodningsfunktionerna. Dessa måste vara "
"funktioner eller metoder som har samma gränssnitt som metoderna "
":meth:`~Kodek.encode` och :meth:`~Kodek.decode` för Kodek-instanser (se "
":ref:`Kodek Interface <kodek-objects>`). Funktionerna eller metoderna "
"förväntas fungera i ett statslöst läge."

#: ../../library/codecs.rst:92
msgid ""
"Incremental encoder and decoder classes or factory functions. These have to "
"provide the interface defined by the base classes "
":class:`IncrementalEncoder` and :class:`IncrementalDecoder`, respectively. "
"Incremental codecs can maintain state."
msgstr ""
"Klasser eller fabriksfunktioner för inkrementella kodare och avkodare. Dessa"
" måste tillhandahålla det gränssnitt som definieras av basklasserna "
":class:`IncrementalEncoder` respektive :class:`IncrementalDecoder`. "
"Inkrementella kodekar kan bibehålla tillstånd."

#: ../../library/codecs.rst:101
msgid ""
"Stream writer and reader classes or factory functions. These have to provide"
" the interface defined by the base classes :class:`StreamWriter` and "
":class:`StreamReader`, respectively. Stream codecs can maintain state."
msgstr ""
"Klasser eller fabriksfunktioner för stream writer och reader. Dessa måste "
"tillhandahålla det gränssnitt som definieras av basklasserna "
":class:`StreamWriter` respektive :class:`StreamReader`. Stream kodekar kan "
"upprätthålla tillstånd."

#: ../../library/codecs.rst:106
msgid ""
"To simplify access to the various codec components, the module provides "
"these additional functions which use :func:`lookup` for the codec lookup:"
msgstr ""
"För att förenkla åtkomsten till de olika kodek-komponenterna tillhandahåller"
" modulen dessa ytterligare funktioner som använder :func:`lookup` för kodek-"
"uppslagningen:"

#: ../../library/codecs.rst:111
msgid ""
"Look up the codec for the given encoding and return its encoder function."
msgstr ""
"Leta upp kodek för den givna kodningen och returnera dess kodningsfunktion."

#: ../../library/codecs.rst:113 ../../library/codecs.rst:120
#: ../../library/codecs.rst:146 ../../library/codecs.rst:154
msgid "Raises a :exc:`LookupError` in case the encoding cannot be found."
msgstr "Utlöser ett :exc:`LookupError` om kodningen inte kan hittas."

#: ../../library/codecs.rst:118
msgid ""
"Look up the codec for the given encoding and return its decoder function."
msgstr ""
"Leta upp kodek för den givna kodningen och returnera dess "
"avkodningsfunktion."

#: ../../library/codecs.rst:125
msgid ""
"Look up the codec for the given encoding and return its incremental encoder "
"class or factory function."
msgstr ""
"Leta upp kodek för den angivna kodningen och returnera dess inkrementella "
"kodningsklass eller fabriksfunktion."

#: ../../library/codecs.rst:128
msgid ""
"Raises a :exc:`LookupError` in case the encoding cannot be found or the "
"codec doesn't support an incremental encoder."
msgstr ""
"Utlöser ett :exc:`LookupError` om kodningen inte kan hittas eller om kodek "
"inte stöder en inkrementell kodare."

#: ../../library/codecs.rst:134
msgid ""
"Look up the codec for the given encoding and return its incremental decoder "
"class or factory function."
msgstr ""
"Leta upp kodek för den givna kodningen och returnera dess inkrementella "
"avkodarklass eller fabriksfunktion."

#: ../../library/codecs.rst:137
msgid ""
"Raises a :exc:`LookupError` in case the encoding cannot be found or the "
"codec doesn't support an incremental decoder."
msgstr ""
"Utlöser ett :exc:`LookupError` om kodningen inte kan hittas eller om kodek "
"inte stöder en inkrementell avkodare."

#: ../../library/codecs.rst:143
msgid ""
"Look up the codec for the given encoding and return its "
":class:`StreamReader` class or factory function."
msgstr ""
"Leta upp kodek för den angivna kodningen och returnera dess "
":class:`StreamReader` klass eller fabriksfunktion."

#: ../../library/codecs.rst:151
msgid ""
"Look up the codec for the given encoding and return its "
":class:`StreamWriter` class or factory function."
msgstr ""
"Leta upp kodek för den angivna kodningen och returnera dess "
":class:`StreamWriter` klass eller fabriksfunktion."

#: ../../library/codecs.rst:156
msgid ""
"Custom codecs are made available by registering a suitable codec search "
"function:"
msgstr ""
"Anpassade kodekar görs tillgängliga genom att registrera en lämplig "
"kodekarökfunktion:"

#: ../../library/codecs.rst:161
msgid ""
"Register a codec search function. Search functions are expected to take one "
"argument, being the encoding name in all lower case letters with hyphens and"
" spaces converted to underscores, and return a :class:`CodecInfo` object. In"
" case a search function cannot find a given encoding, it should return "
"``None``."
msgstr ""
"Registrera en kodek-sökfunktion. Sökfunktioner förväntas ta ett argument, "
"vilket är kodningsnamnet i gemener med bindestreck och mellanslag "
"konverterade till understreck, och returnera ett :class:`KodekInfo`-objekt. "
"Om en sökfunktion inte kan hitta en given kodning bör den returnera "
"``None``."

#: ../../library/codecs.rst:167
msgid "Hyphens and spaces are converted to underscore."
msgstr "Bindestreck och mellanslag omvandlas till understreck."

#: ../../library/codecs.rst:172
msgid ""
"Search function registration is not currently reversible, which may cause "
"problems in some cases, such as unit testing or module reloading."
msgstr ""

#: ../../library/codecs.rst:176
msgid ""
"While the builtin :func:`open` and the associated :mod:`io` module are the "
"recommended approach for working with encoded text files, this module "
"provides additional utility functions and classes that allow the use of a "
"wider range of codecs when working with binary files:"
msgstr ""
"Den inbyggda modulen :func:`open` och den tillhörande modulen :mod:`io` "
"rekommenderas för arbete med kodade textfiler, men den här modulen "
"innehåller ytterligare funktioner och klasser som gör det möjligt att "
"använda ett större antal kodekar vid arbete med binära filer:"

#: ../../library/codecs.rst:183
msgid ""
"Open an encoded file using the given *mode* and return an instance of "
":class:`StreamReaderWriter`, providing transparent encoding/decoding. The "
"default file mode is ``'r'``, meaning to open the file in read mode."
msgstr ""
"Öppna en kodad fil med det angivna *läget* och returnera en instans av "
":class:`StreamReaderWriter`, vilket ger transparent kodning/avkodning. "
"Standardläget för filen är ``'r'``, vilket innebär att filen öppnas i "
"läsläge."

#: ../../library/codecs.rst:189
msgid ""
"Underlying encoded files are always opened in binary mode. No automatic "
"conversion of ``'\\n'`` is done on reading and writing. The *mode* argument "
"may be any binary mode acceptable to the built-in :func:`open` function; the"
" ``'b'`` is automatically added."
msgstr ""

#: ../../library/codecs.rst:194
msgid ""
"*encoding* specifies the encoding which is to be used for the file. Any "
"encoding that encodes to and decodes from bytes is allowed, and the data "
"types supported by the file methods depend on the codec used."
msgstr ""
"*encoding* anger den kodning som ska användas för filen. Alla kodningar som "
"kodar till och avkodar från bytes är tillåtna, och de datatyper som stöds av"
" filmetoderna beror på vilken kodek som används."

#: ../../library/codecs.rst:198
msgid ""
"*errors* may be given to define the error handling. It defaults to "
"``'strict'`` which causes a :exc:`ValueError` to be raised in case an "
"encoding error occurs."
msgstr ""
"*errors* kan anges för att definiera felhanteringen. Standardinställningen "
"är ``'strict'`` vilket gör att ett :exc:`ValueError` skapas om ett "
"kodningsfel uppstår."

#: ../../library/codecs.rst:201
msgid ""
"*buffering* has the same meaning as for the built-in :func:`open` function. "
"It defaults to -1 which means that the default buffer size will be used."
msgstr ""
"*buffring* har samma betydelse som för den inbyggda funktionen :func:`open`."
" Standardvärdet är -1, vilket innebär att standardbuffertstorleken kommer "
"att användas."

#: ../../library/codecs.rst:207
msgid ""
"Return a :class:`StreamRecoder` instance, a wrapped version of *file* which "
"provides transparent transcoding. The original file is closed when the "
"wrapped version is closed."
msgstr ""
"Returnerar en :class:`StreamRecoder`-instans, en omsluten version av *file* "
"som ger transparent omkodning. Originalfilen stängs när den omslutna "
"versionen stängs."

#: ../../library/codecs.rst:211
msgid ""
"Data written to the wrapped file is decoded according to the given "
"*data_encoding* and then written to the original file as bytes using "
"*file_encoding*. Bytes read from the original file are decoded according to "
"*file_encoding*, and the result is encoded using *data_encoding*."
msgstr ""
"Data som skrivs till den omslutna filen avkodas enligt den angivna "
"*data_encoding* och skrivs sedan till originalfilen som byte med "
"*file_encoding*. Bytes som läses från originalfilen avkodas enligt "
"*file_encoding* och resultatet kodas med hjälp av *data_encoding*."

#: ../../library/codecs.rst:217
msgid "If *file_encoding* is not given, it defaults to *data_encoding*."
msgstr "Om *file_encoding* inte anges, används *data_encoding* som standard."

#: ../../library/codecs.rst:219
msgid ""
"*errors* may be given to define the error handling. It defaults to "
"``'strict'``, which causes :exc:`ValueError` to be raised in case an "
"encoding error occurs."
msgstr ""
"*errors* kan anges för att definiera felhanteringen. Standardvärdet är "
"``'strict'``, vilket gör att :exc:`ValueError` aktiveras om ett kodningsfel "
"inträffar."

#: ../../library/codecs.rst:226
msgid ""
"Uses an incremental encoder to iteratively encode the input provided by "
"*iterator*. This function is a :term:`generator`. The *errors* argument (as "
"well as any other keyword argument) is passed through to the incremental "
"encoder."
msgstr ""

#: ../../library/codecs.rst:231
msgid ""
"This function requires that the codec accept text :class:`str` objects to "
"encode. Therefore it does not support bytes-to-bytes encoders such as "
"``base64_codec``."
msgstr ""
"Denna funktion kräver att kodek accepterar text :class:`str`-objekt att "
"koda. Därför stöder den inte bytes-till-bytes-kodare som ``base64_codec``."

#: ../../library/codecs.rst:238
msgid ""
"Uses an incremental decoder to iteratively decode the input provided by "
"*iterator*. This function is a :term:`generator`. The *errors* argument (as "
"well as any other keyword argument) is passed through to the incremental "
"decoder."
msgstr ""

#: ../../library/codecs.rst:243
msgid ""
"This function requires that the codec accept :class:`bytes` objects to "
"decode. Therefore it does not support text-to-text encoders such as "
"``rot_13``, although ``rot_13`` may be used equivalently with "
":func:`iterencode`."
msgstr ""
"Denna funktion kräver att kodek accepterar :class:`bytes`-objekt för "
"avkodning. Därför stöder den inte text-till-text-kodare som ``rot_13``, även"
" om ``rot_13`` kan användas på motsvarande sätt med :func:`iterencode`."

#: ../../library/codecs.rst:249
msgid ""
"The module also provides the following constants which are useful for "
"reading and writing to platform dependent files:"
msgstr ""
"Modulen innehåller också följande konstanter som är användbara för att läsa "
"och skriva till plattformsberoende filer:"

#: ../../library/codecs.rst:264
msgid ""
"These constants define various byte sequences, being Unicode byte order "
"marks (BOMs) for several encodings. They are used in UTF-16 and UTF-32 data "
"streams to indicate the byte order used, and in UTF-8 as a Unicode "
"signature. :const:`BOM_UTF16` is either :const:`BOM_UTF16_BE` or "
":const:`BOM_UTF16_LE` depending on the platform's native byte order, "
":const:`BOM` is an alias for :const:`BOM_UTF16`, :const:`BOM_LE` for "
":const:`BOM_UTF16_LE` and :const:`BOM_BE` for :const:`BOM_UTF16_BE`. The "
"others represent the BOM in UTF-8 and UTF-32 encodings."
msgstr ""
"Dessa konstanter definierar olika byte-sekvenser och är Unicode byte order "
"marks (BOMs) för flera kodningar. De används i UTF-16- och "
"UTF-32-dataströmmar för att ange den byteordning som används, och i UTF-8 "
"som en Unicode-signatur. :const:`BOM_UTF16` är antingen "
":const:`BOM_UTF16_BE` eller :const:`BOM_UTF16_LE` beroende på plattformens "
"inbyggda byteordning, :const:`BOM` är ett alias för :const:`BOM_UTF16`, "
":const:`BOM_LE` för :const:`BOM_UTF16_LE` och :const:`BOM_BE` för "
":const:`BOM_UTF16_BE`. De andra representerar BOM i UTF-8- och "
"UTF-32-kodningar."

#: ../../library/codecs.rst:278
msgid "Codec Base Classes"
msgstr "Kodek-basklasser"

#: ../../library/codecs.rst:280
msgid ""
"The :mod:`codecs` module defines a set of base classes which define the "
"interfaces for working with codec objects, and can also be used as the basis"
" for custom codec implementations."
msgstr ""
"Modulen :mod:`kodekar` definierar en uppsättning basklasser som definierar "
"gränssnitten för att arbeta med kodek-objekt och kan också användas som "
"grund för anpassade kodek-implementeringar."

#: ../../library/codecs.rst:284
msgid ""
"Each codec has to define four interfaces to make it usable as codec in "
"Python: stateless encoder, stateless decoder, stream reader and stream "
"writer. The stream reader and writers typically reuse the stateless "
"encoder/decoder to implement the file protocols. Codec authors also need to "
"define how the codec will handle encoding and decoding errors."
msgstr ""
"Varje kodek måste definiera fyra gränssnitt för att kunna användas som kodek"
" i Python: stateless encoder, stateless decoder, stream reader och stream "
"writer. Strömläsaren och strömskrivaren återanvänder vanligtvis den "
"statslösa kodaren/avkodaren för att implementera filprotokollen. Kodek-"
"författare måste också definiera hur kodek ska hantera kodnings- och "
"avkodningsfel."

#: ../../library/codecs.rst:295
msgid "Error Handlers"
msgstr "Felhanterare"

#: ../../library/codecs.rst:297
msgid ""
"To simplify and standardize error handling, codecs may implement different "
"error handling schemes by accepting the *errors* string argument:"
msgstr ""
"För att förenkla och standardisera felhanteringen kan kodekar implementera "
"olika felhanteringsscheman genom att acceptera strängargumentet *errors*:"

#: ../../library/codecs.rst:317
msgid ""
"The following error handlers can be used with all Python :ref:`standard-"
"encodings` codecs:"
msgstr ""
"Följande felhanterare kan användas med alla Python :ref:`standard-"
"encodings`-kodekar:"

#: ../../library/codecs.rst:323 ../../library/codecs.rst:365
#: ../../library/codecs.rst:384
msgid "Value"
msgstr "Värde"

#: ../../library/codecs.rst:323 ../../library/codecs.rst:365
#: ../../library/codecs.rst:384 ../../library/codecs.rst:1317
#: ../../library/codecs.rst:1384 ../../library/codecs.rst:1439
msgid "Meaning"
msgstr "Betydelse"

#: ../../library/codecs.rst:325
msgid "``'strict'``"
msgstr "``'strikt```"

#: ../../library/codecs.rst:325
msgid ""
"Raise :exc:`UnicodeError` (or a subclass), this is the default. Implemented "
"in :func:`strict_errors`."
msgstr ""
"Utlöser :exc:`UnicodeError` (eller en underklass), detta är standard. "
"Implementerad i :func:`strict_errors`."

#: ../../library/codecs.rst:329
msgid "``'ignore'``"
msgstr "```ignore```"

#: ../../library/codecs.rst:329
msgid ""
"Ignore the malformed data and continue without further notice. Implemented "
"in :func:`ignore_errors`."
msgstr ""
"Ignorera de felaktiga uppgifterna och fortsätt utan ytterligare meddelande. "
"Implementerad i :func:`ignore_errors`."

#: ../../library/codecs.rst:333
msgid "``'replace'``"
msgstr "``'replace'``"

#: ../../library/codecs.rst:333
msgid ""
"Replace with a replacement marker. On encoding, use ``?`` (ASCII character)."
" On decoding, use ``�`` (U+FFFD, the official REPLACEMENT CHARACTER). "
"Implemented in :func:`replace_errors`."
msgstr ""
"Ersätt med en ersättningsmarkör. Vid kodning, använd ``?`` (ASCII-tecken). "
"Vid avkodning, använd ``�`` (U+FFFD, det officiella ERSÄTTNINGSKARAKTERET). "
"Implementerad i :func:`replace_errors`."

#: ../../library/codecs.rst:339
msgid "``'backslashreplace'``"
msgstr "``'backslashreplace'``"

#: ../../library/codecs.rst:339
msgid ""
"Replace with backslashed escape sequences. On encoding, use hexadecimal form"
" of Unicode code point with formats ``\\xhh`` ``\\uxxxx`` ``\\Uxxxxxxxx``. "
"On decoding, use hexadecimal form of byte value with format ``\\xhh``. "
"Implemented in :func:`backslashreplace_errors`."
msgstr ""

#: ../../library/codecs.rst:347
msgid "``'surrogateescape'``"
msgstr "``'surrogatlandskap'``"

#: ../../library/codecs.rst:347
msgid ""
"On decoding, replace byte with individual surrogate code ranging from "
"``U+DC80`` to ``U+DCFF``. This code will then be turned back into the same "
"byte when the ``'surrogateescape'`` error handler is used when encoding the "
"data. (See :pep:`383` for more.)"
msgstr ""
"Vid avkodning ersätts byte med individuell surrogatkod från ``U+DC80`` till "
"``U+DCFF``. Denna kod kommer sedan att omvandlas tillbaka till samma byte "
"när felhanteraren ``'surrogateescape'`` används vid kodning av data. (Se "
":pep:`383` för mer information.)"

#: ../../library/codecs.rst:361
msgid ""
"The following error handlers are only applicable to encoding (within "
":term:`text encodings <text encoding>`):"
msgstr ""
"Följande felhanterare är endast tillämpliga på kodning (inom "
":term:`textkodning <text encoding>`):"

#: ../../library/codecs.rst:367
msgid "``'xmlcharrefreplace'``"
msgstr "``'xmlcharrefreplace'`` ``"

#: ../../library/codecs.rst:367
msgid ""
"Replace with XML/HTML numeric character reference, which is a decimal form "
"of Unicode code point with format ``&#num;`` Implemented in "
":func:`xmlcharrefreplace_errors`."
msgstr ""

#: ../../library/codecs.rst:372
msgid "``'namereplace'``"
msgstr "``'namnbytare'```"

#: ../../library/codecs.rst:372
msgid ""
"Replace with ``\\N{...}`` escape sequences, what appears in the braces is "
"the Name property from Unicode Character Database. Implemented in "
":func:`namereplace_errors`."
msgstr ""
"Ersätt med ``\\N{...}`` escape-sekvenser, det som visas inom hakparenteserna"
" är egenskapen Name från Unicode Character Database. Implementerad i "
":func:`namereplace_errors`."

#: ../../library/codecs.rst:381
msgid ""
"In addition, the following error handler is specific to the given codecs:"
msgstr "Dessutom är följande felhanterare specifik för de angivna kodekar:"

#: ../../library/codecs.rst:384
msgid "Codecs"
msgstr "Codecs"

#: ../../library/codecs.rst:386
msgid "``'surrogatepass'``"
msgstr "``'surrogatpass``"

#: ../../library/codecs.rst:386
msgid "utf-8, utf-16, utf-32, utf-16-be, utf-16-le, utf-32-be, utf-32-le"
msgstr "utf-8, utf-16, utf-32, utf-16-be, utf-16-le, utf-32-be, utf-32-le"

#: ../../library/codecs.rst:386
msgid ""
"Allow encoding and decoding surrogate code point (``U+D800`` - ``U+DFFF``) "
"as normal code point. Otherwise these codecs treat the presence of surrogate"
" code point in :class:`str` as an error."
msgstr ""
"Tillåt kodning och avkodning av surrogatkodpunkt (``U+D800`` - ``U+DFFF``) "
"som normal kodpunkt. Annars behandlar dessa kodekar förekomsten av "
"surrogatkodpunkt i :class:`str` som ett fel."

#: ../../library/codecs.rst:393
msgid "The ``'surrogateescape'`` and ``'surrogatepass'`` error handlers."
msgstr "Felhanterarna ``'surrogateescape'`` och ``'surrogatepass'``."

#: ../../library/codecs.rst:396
msgid ""
"The ``'surrogatepass'`` error handler now works with utf-16\\* and utf-32\\*"
" codecs."
msgstr ""
"Felhanteraren ``'surrogatepass'`` fungerar nu med utf-16\\* och utf-32\\* "
"kodekar."

#: ../../library/codecs.rst:400
msgid "The ``'namereplace'`` error handler."
msgstr "Felhanteraren för ``'namereplace'``."

#: ../../library/codecs.rst:403
msgid ""
"The ``'backslashreplace'`` error handler now works with decoding and "
"translating."
msgstr ""
"Felhanteraren ``'backslashreplace'`` fungerar nu med avkodning och "
"översättning."

#: ../../library/codecs.rst:407
msgid ""
"The set of allowed values can be extended by registering a new named error "
"handler:"
msgstr ""
"Uppsättningen av tillåtna värden kan utökas genom att registrera en ny "
"namngiven felhanterare:"

#: ../../library/codecs.rst:412
msgid ""
"Register the error handling function *error_handler* under the name *name*. "
"The *error_handler* argument will be called during encoding and decoding in "
"case of an error, when *name* is specified as the errors parameter."
msgstr ""
"Registrera felhanteringsfunktionen *error_handler* under namnet *name*. "
"Argumentet *error_handler* kommer att anropas under kodning och avkodning i "
"händelse av ett fel, när *name* anges som felparameter."

#: ../../library/codecs.rst:416
msgid ""
"For encoding, *error_handler* will be called with a "
":exc:`UnicodeEncodeError` instance, which contains information about the "
"location of the error. The error handler must either raise this or a "
"different exception, or return a tuple with a replacement for the "
"unencodable part of the input and a position where encoding should continue."
" The replacement may be either :class:`str` or :class:`bytes`. If the "
"replacement is bytes, the encoder will simply copy them into the output "
"buffer. If the replacement is a string, the encoder will encode the "
"replacement. Encoding continues on original input at the specified position."
" Negative position values will be treated as being relative to the end of "
"the input string. If the resulting position is out of bound an "
":exc:`IndexError` will be raised."
msgstr ""
"För kodning kommer *error_handler* att anropas med en "
":exc:`UnicodeEncodeError`-instans, som innehåller information om var felet "
"finns. Felhanteraren måste antingen lyfta detta eller ett annat undantag, "
"eller returnera en tupel med en ersättning för den okodbara delen av indata "
"och en position där kodningen ska fortsätta. Ersättningen kan vara antingen "
":class:`str` eller :class:`bytes`. Om ersättningen är bytes kommer kodaren "
"helt enkelt att kopiera dem till utmatningsbufferten. Om ersättningen är en "
"sträng kommer kodaren att koda ersättningen. Kodningen fortsätter på den "
"ursprungliga inmatningen vid den angivna positionen. Negativa "
"positionsvärden behandlas som om de är i förhållande till slutet av den "
"inmatade strängen. Om den resulterande positionen är utanför gränsen kommer "
"ett :exc:`IndexError` att visas."

#: ../../library/codecs.rst:428
msgid ""
"Decoding and translating works similarly, except :exc:`UnicodeDecodeError` "
"or :exc:`UnicodeTranslateError` will be passed to the handler and that the "
"replacement from the error handler will be put into the output directly."
msgstr ""
"Avkodning och översättning fungerar på samma sätt, förutom att "
":exc:`UnicodeDecodeError` eller :exc:`UnicodeTranslateError` kommer att "
"skickas till felhanteraren och att ersättningen från felhanteraren kommer "
"att läggas in i utdata direkt."

#: ../../library/codecs.rst:433
msgid ""
"Previously registered error handlers (including the standard error handlers)"
" can be looked up by name:"
msgstr ""
"Tidigare registrerade felhanterare (inklusive standardfelhanterare) kan "
"sökas upp med namn:"

#: ../../library/codecs.rst:438
msgid "Return the error handler previously registered under the name *name*."
msgstr ""
"Returnerar den felhanterare som tidigare registrerats under namnet *name*."

#: ../../library/codecs.rst:440
msgid "Raises a :exc:`LookupError` in case the handler cannot be found."
msgstr "Utlöser ett :exc:`LookupError` om handläggaren inte kan hittas."

#: ../../library/codecs.rst:442
msgid ""
"The following standard error handlers are also made available as module "
"level functions:"
msgstr ""
"Följande standardfelhanterare är också tillgängliga som funktioner på "
"modulnivå:"

#: ../../library/codecs.rst:447
msgid "Implements the ``'strict'`` error handling."
msgstr "Implementerar felhanteringen ``'strict``."

#: ../../library/codecs.rst:449
msgid "Each encoding or decoding error raises a :exc:`UnicodeError`."
msgstr ""
"Varje kodnings- eller avkodningsfel ger upphov till ett :exc:`UnicodeError`."

#: ../../library/codecs.rst:454
msgid "Implements the ``'ignore'`` error handling."
msgstr "Implementerar felhanteringen ``'ignorera'``."

#: ../../library/codecs.rst:456
msgid ""
"Malformed data is ignored; encoding or decoding is continued without further"
" notice."
msgstr ""
"Missbildade data ignoreras; kodning eller avkodning fortsätter utan "
"ytterligare meddelande."

#: ../../library/codecs.rst:462
msgid "Implements the ``'replace'`` error handling."
msgstr "Implementerar felhanteringen ``'replace'``."

#: ../../library/codecs.rst:464
msgid ""
"Substitutes ``?`` (ASCII character) for encoding errors or ``�`` (U+FFFD, "
"the official REPLACEMENT CHARACTER) for decoding errors."
msgstr ""
"Ersätter ``?`` (ASCII-tecken) för kodningsfel eller ``�`` (U+FFFD, det "
"officiella ERSÄTTNINGSKARAKTERET) för avkodningsfel."

#: ../../library/codecs.rst:470
msgid "Implements the ``'backslashreplace'`` error handling."
msgstr "Implementerar felhanteringen ``'backslashreplace'``."

#: ../../library/codecs.rst:472
msgid ""
"Malformed data is replaced by a backslashed escape sequence. On encoding, "
"use the hexadecimal form of Unicode code point with formats ``\\xhh`` "
"``\\uxxxx`` ``\\Uxxxxxxxx``. On decoding, use the hexadecimal form of byte "
"value with format ``\\xhh``."
msgstr ""

#: ../../library/codecs.rst:477
msgid "Works with decoding and translating."
msgstr "Arbetar med avkodning och översättning."

#: ../../library/codecs.rst:483
msgid ""
"Implements the ``'xmlcharrefreplace'`` error handling (for encoding within "
":term:`text encoding` only)."
msgstr ""
"Implementerar felhanteringen ``'xmlcharrefreplace'`` (endast för kodning "
"inom :term:`textkodning`)."

#: ../../library/codecs.rst:486
msgid ""
"The unencodable character is replaced by an appropriate XML/HTML numeric "
"character reference, which is a decimal form of Unicode code point with "
"format ``&#num;`` ."
msgstr ""

#: ../../library/codecs.rst:493
msgid ""
"Implements the ``'namereplace'`` error handling (for encoding within "
":term:`text encoding` only)."
msgstr ""
"Implementerar felhanteringen ``'namereplace'`` (endast för kodning inom "
":term:`textkodning`)."

#: ../../library/codecs.rst:496
msgid ""
"The unencodable character is replaced by a ``\\N{...}`` escape sequence. The"
" set of characters that appear in the braces is the Name property from "
"Unicode Character Database. For example, the German lowercase letter ``'ß'``"
" will be converted to byte sequence ``\\N{LATIN SMALL LETTER SHARP S}`` ."
msgstr ""
"Det icke-kodbara tecknet ersätts av en ``N{...}`` escape-sekvens. "
"Uppsättningen av tecken som visas inom hakparenteserna är egenskapen Name "
"från Unicode Character Database. Till exempel kommer den tyska gemena "
"bokstaven ``'ß'`` att konverteras till byte-sekvensen ``\\N{LATIN SMALL "
"LETTER SHARP S}`` ."

#: ../../library/codecs.rst:507
msgid "Stateless Encoding and Decoding"
msgstr "Statlös kodning och avkodning"

#: ../../library/codecs.rst:509
msgid ""
"The base :class:`Codec` class defines these methods which also define the "
"function interfaces of the stateless encoder and decoder:"
msgstr ""
"Basklassen :class:`Kodek` definierar dessa metoder som också definierar "
"funktionsgränssnitten för den statslösa kodaren och avkodaren:"

#: ../../library/codecs.rst:515
msgid ""
"Encodes the object *input* and returns a tuple (output object, length "
"consumed). For instance, :term:`text encoding` converts a string object to a"
" bytes object using a particular character set encoding (e.g., ``cp1252`` or"
" ``iso-8859-1``)."
msgstr ""
"Kodar objektet *input* och returnerar en tupel (utgångsobjekt, förbrukad "
"längd). Till exempel :term:`text encoding` konverterar ett strängobjekt till"
" ett bytesobjekt med hjälp av en viss teckenuppsättningskodning (t.ex. "
"``cp1252`` eller ``iso-8859-1``)."

#: ../../library/codecs.rst:520 ../../library/codecs.rst:542
msgid ""
"The *errors* argument defines the error handling to apply. It defaults to "
"``'strict'`` handling."
msgstr ""
"Argumentet *errors* definierar vilken felhantering som ska tillämpas. "
"Standardinställningen är ``'strict'`` hantering."

#: ../../library/codecs.rst:523
msgid ""
"The method may not store state in the :class:`Codec` instance. Use "
":class:`StreamWriter` for codecs which have to keep state in order to make "
"encoding efficient."
msgstr ""
"Metoden får inte lagra tillstånd i :class:`Kodek`-instansen. Använd "
":class:`StreamWriter` för kodekar som måste behålla tillstånd för att göra "
"kodningen effektiv."

#: ../../library/codecs.rst:527
msgid ""
"The encoder must be able to handle zero length input and return an empty "
"object of the output object type in this situation."
msgstr ""
"Kodaren måste kunna hantera inmatning med noll längd och returnera ett tomt "
"objekt av typen output-objekt i denna situation."

#: ../../library/codecs.rst:533
msgid ""
"Decodes the object *input* and returns a tuple (output object, length "
"consumed). For instance, for a :term:`text encoding`, decoding converts a "
"bytes object encoded using a particular character set encoding to a string "
"object."
msgstr ""
"Avkodar objektet *input* och returnerar en tupel (utgångsobjekt, förbrukad "
"längd). Till exempel, för en :term:`text encoding`, omvandlar decoding ett "
"bytes-objekt som kodats med en viss teckenuppsättningskodning till ett "
"strängobjekt."

#: ../../library/codecs.rst:538
msgid ""
"For text encodings and bytes-to-bytes codecs, *input* must be a bytes object"
" or one which provides the read-only buffer interface -- for example, buffer"
" objects and memory mapped files."
msgstr ""
"För textkodningar och bytes-till-bytes-kodekar måste *input* vara ett bytes-"
"objekt eller ett objekt som tillhandahåller gränssnittet för skrivskyddade "
"buffertar - t.ex. buffertobjekt och minnesmappade filer."

#: ../../library/codecs.rst:545
msgid ""
"The method may not store state in the :class:`Codec` instance. Use "
":class:`StreamReader` for codecs which have to keep state in order to make "
"decoding efficient."
msgstr ""
"Metoden får inte lagra tillstånd i :class:`Kodek`-instansen. Använd "
":class:`StreamReader` för kodekar som måste behålla tillstånd för att göra "
"avkodningen effektiv."

#: ../../library/codecs.rst:549
msgid ""
"The decoder must be able to handle zero length input and return an empty "
"object of the output object type in this situation."
msgstr ""
"Avkodaren måste kunna hantera inmatning med noll längd och returnera ett "
"tomt objekt av typen output-objekt i denna situation."

#: ../../library/codecs.rst:554
msgid "Incremental Encoding and Decoding"
msgstr "Inkrementell kodning och avkodning"

#: ../../library/codecs.rst:556
msgid ""
"The :class:`IncrementalEncoder` and :class:`IncrementalDecoder` classes "
"provide the basic interface for incremental encoding and decoding. "
"Encoding/decoding the input isn't done with one call to the stateless "
"encoder/decoder function, but with multiple calls to the "
":meth:`~IncrementalEncoder.encode`/:meth:`~IncrementalDecoder.decode` method"
" of the incremental encoder/decoder. The incremental encoder/decoder keeps "
"track of the encoding/decoding process during method calls."
msgstr ""
"Klasserna :class:`IncrementalEncoder` och :class:`IncrementalDecoder` "
"tillhandahåller det grundläggande gränssnittet för inkrementell kodning och "
"avkodning. Kodning/avkodning av indata görs inte med ett anrop till den "
"statslösa kodar/avkodarfunktionen, utan med flera anrop till "
":meth:`~IncrementalEncoder.encode`/:meth:`~IncrementalDecoder.decode`-metoden"
" för den inkrementella kodaren/avkodaren. Den inkrementella "
"kodaren/avkodaren håller reda på kodnings-/avkodningsprocessen under "
"metodanropen."

#: ../../library/codecs.rst:564
msgid ""
"The joined output of calls to the "
":meth:`~IncrementalEncoder.encode`/:meth:`~IncrementalDecoder.decode` method"
" is the same as if all the single inputs were joined into one, and this "
"input was encoded/decoded with the stateless encoder/decoder."
msgstr ""
"Det sammanfogade resultatet av anrop till metoden "
":meth:`~IncrementalEncoder.encode`/:meth:`~IncrementalDecoder.decode` är "
"detsamma som om alla enskilda indata hade sammanfogats till ett, och detta "
"indata hade kodats/avkodats med den statslösa kodaren/avkodaren."

#: ../../library/codecs.rst:573
msgid "IncrementalEncoder Objects"
msgstr "Objekt för inkrementell kodare"

#: ../../library/codecs.rst:575
msgid ""
"The :class:`IncrementalEncoder` class is used for encoding an input in "
"multiple steps. It defines the following methods which every incremental "
"encoder must define in order to be compatible with the Python codec "
"registry."
msgstr ""
"Klassen :class:`IncrementalEncoder` används för att koda en inmatning i "
"flera steg. Den definierar följande metoder som varje inkrementell kodare "
"måste definiera för att vara kompatibel med Pythons kodek-register."

#: ../../library/codecs.rst:582
msgid "Constructor for an :class:`IncrementalEncoder` instance."
msgstr "Konstruktör för en instans av :class:`IncrementalEncoder`."

#: ../../library/codecs.rst:584
msgid ""
"All incremental encoders must provide this constructor interface. They are "
"free to add additional keyword arguments, but only the ones defined here are"
" used by the Python codec registry."
msgstr ""
"Alla inkrementella kodare måste tillhandahålla detta konstruktörsgränssnitt."
" De är fria att lägga till ytterligare nyckelordsargument, men endast de som"
" definieras här används av Pythons kodek-register."

#: ../../library/codecs.rst:588
msgid ""
"The :class:`IncrementalEncoder` may implement different error handling "
"schemes by providing the *errors* keyword argument. See :ref:`error-"
"handlers` for possible values."
msgstr ""
":class:`IncrementalEncoder` kan implementera olika felhanteringssystem genom"
" att tillhandahålla nyckelordsargumentet *errors*. Se :ref:`error-handlers` "
"för möjliga värden."

#: ../../library/codecs.rst:592
msgid ""
"The *errors* argument will be assigned to an attribute of the same name. "
"Assigning to this attribute makes it possible to switch between different "
"error handling strategies during the lifetime of the "
":class:`IncrementalEncoder` object."
msgstr ""
"Argumentet *errors* kommer att tilldelas ett attribut med samma namn. Genom "
"att tilldela detta attribut blir det möjligt att växla mellan olika "
"felhanteringsstrategier under :class:`IncrementalEncoder`-objektets livstid."

#: ../../library/codecs.rst:600
msgid ""
"Encodes *object* (taking the current state of the encoder into account) and "
"returns the resulting encoded object. If this is the last call to "
":meth:`encode` *final* must be true (the default is false)."
msgstr ""
"Kodar *objekt* (med hänsyn tagen till kodarens aktuella tillstånd) och "
"returnerar det resulterande kodade objektet. Om detta är det sista anropet "
"till :meth:`encode` måste *final* vara true (standard är false)."

#: ../../library/codecs.rst:607
msgid ""
"Reset the encoder to the initial state. The output is discarded: call "
"``.encode(object, final=True)``, passing an empty byte or text string if "
"necessary, to reset the encoder and to get the output."
msgstr ""
"Återställ kodaren till det ursprungliga tillståndet. Utdata kastas: anropa "
"``.encode(object, final=True)``, och skicka en tom byte- eller textsträng om"
" det behövs, för att återställa kodaren och få utdata."

#: ../../library/codecs.rst:614
msgid ""
"Return the current state of the encoder which must be an integer. The "
"implementation should make sure that ``0`` is the most common state. (States"
" that are more complicated than integers can be converted into an integer by"
" marshaling/pickling the state and encoding the bytes of the resulting "
"string into an integer.)"
msgstr ""
"Returnerar det aktuella tillståndet för kodaren som måste vara ett heltal. "
"Implementationen bör se till att ```0`` är det vanligaste tillståndet. "
"(Tillstånd som är mer komplicerade än heltal kan konverteras till ett heltal"
" genom att marshala/pickla tillståndet och koda bytena i den resulterande "
"strängen till ett heltal)"

#: ../../library/codecs.rst:623
msgid ""
"Set the state of the encoder to *state*. *state* must be an encoder state "
"returned by :meth:`getstate`."
msgstr ""
"Ställ in kodarens tillstånd till *state*. *state* måste vara ett "
"kodartillstånd som returneras av :meth:`getstate`."

#: ../../library/codecs.rst:630
msgid "IncrementalDecoder Objects"
msgstr "IncrementalDecoder Objekt"

#: ../../library/codecs.rst:632
msgid ""
"The :class:`IncrementalDecoder` class is used for decoding an input in "
"multiple steps. It defines the following methods which every incremental "
"decoder must define in order to be compatible with the Python codec "
"registry."
msgstr ""
"Klassen :class:`IncrementalDecoder` används för att avkoda en indata i flera"
" steg. Den definierar följande metoder som varje inkrementell avkodare måste"
" definiera för att vara kompatibel med Pythons kodek-register."

#: ../../library/codecs.rst:639
msgid "Constructor for an :class:`IncrementalDecoder` instance."
msgstr "Konstruktör för en instans av :class:`IncrementalDecoder`."

#: ../../library/codecs.rst:641
msgid ""
"All incremental decoders must provide this constructor interface. They are "
"free to add additional keyword arguments, but only the ones defined here are"
" used by the Python codec registry."
msgstr ""
"Alla inkrementella avkodare måste tillhandahålla detta "
"konstruktörsgränssnitt. Det står dem fritt att lägga till ytterligare "
"nyckelordsargument, men endast de som definieras här används av Pythons "
"kodek-register."

#: ../../library/codecs.rst:645
msgid ""
"The :class:`IncrementalDecoder` may implement different error handling "
"schemes by providing the *errors* keyword argument. See :ref:`error-"
"handlers` for possible values."
msgstr ""
":class:`IncrementalDecoder` kan implementera olika felhanteringssystem genom"
" att tillhandahålla nyckelordsargumentet *errors*. Se :ref:`error-handlers` "
"för möjliga värden."

#: ../../library/codecs.rst:649
msgid ""
"The *errors* argument will be assigned to an attribute of the same name. "
"Assigning to this attribute makes it possible to switch between different "
"error handling strategies during the lifetime of the "
":class:`IncrementalDecoder` object."
msgstr ""
"Argumentet *errors* kommer att tilldelas ett attribut med samma namn. Genom "
"att tilldela detta attribut blir det möjligt att växla mellan olika "
"felhanteringsstrategier under :class:`IncrementalDecoder`-objektets livstid."

#: ../../library/codecs.rst:657
msgid ""
"Decodes *object* (taking the current state of the decoder into account) and "
"returns the resulting decoded object. If this is the last call to "
":meth:`decode` *final* must be true (the default is false). If *final* is "
"true the decoder must decode the input completely and must flush all "
"buffers. If this isn't possible (e.g. because of incomplete byte sequences "
"at the end of the input) it must initiate error handling just like in the "
"stateless case (which might raise an exception)."
msgstr ""
"Avkodar *objekt* (med hänsyn tagen till avkodarens aktuella tillstånd) och "
"returnerar det avkodade objektet. Om detta är det sista anropet till "
":meth:`decode` måste *final* vara true (standardvärdet är false). Om *final*"
" är true måste avkodaren avkoda indata helt och hållet och tömma alla "
"buffertar. Om detta inte är möjligt (t.ex. på grund av ofullständiga byte-"
"sekvenser i slutet av indata) måste den initiera felhantering precis som i "
"det statslösa fallet (vilket kan leda till ett undantag)."

#: ../../library/codecs.rst:668
msgid "Reset the decoder to the initial state."
msgstr "Återställer dekodern till utgångsläget."

#: ../../library/codecs.rst:673
msgid ""
"Return the current state of the decoder. This must be a tuple with two "
"items, the first must be the buffer containing the still undecoded input. "
"The second must be an integer and can be additional state info. (The "
"implementation should make sure that ``0`` is the most common additional "
"state info.) If this additional state info is ``0`` it must be possible to "
"set the decoder to the state which has no input buffered and ``0`` as the "
"additional state info, so that feeding the previously buffered input to the "
"decoder returns it to the previous state without producing any output. "
"(Additional state info that is more complicated than integers can be "
"converted into an integer by marshaling/pickling the info and encoding the "
"bytes of the resulting string into an integer.)"
msgstr ""
"Returnerar avkodarens aktuella tillstånd. Detta måste vara en tupel med två "
"poster, den första måste vara bufferten som innehåller den fortfarande "
"oavkodade inmatningen. Den andra måste vara ett heltal och kan vara "
"ytterligare tillståndsinformation. (Implementationen bör se till att ``0`` "
"är den vanligaste ytterligare tillståndsinformationen) Om denna ytterligare "
"tillståndsinformation är ``0`` måste det vara möjligt att ställa in "
"avkodaren till det tillstånd som inte har någon buffrad indata och ``0`` som"
" ytterligare tillståndsinformation, så att matning av den tidigare buffrade "
"indata till avkodaren återför den till föregående tillstånd utan att "
"producera någon utdata. (Ytterligare tillståndsinformation som är mer "
"komplicerad än heltal kan konverteras till ett heltal genom att "
"marshala/pickla informationen och koda bytena i den resulterande strängen "
"till ett heltal)"

#: ../../library/codecs.rst:688
msgid ""
"Set the state of the decoder to *state*. *state* must be a decoder state "
"returned by :meth:`getstate`."
msgstr ""
"Ställ in avkodarens tillstånd till *state*. *state* måste vara ett "
"avkodartillstånd som returneras av :meth:`getstate`."

#: ../../library/codecs.rst:693
msgid "Stream Encoding and Decoding"
msgstr "Kodning och avkodning av strömmar"

#: ../../library/codecs.rst:696
msgid ""
"The :class:`StreamWriter` and :class:`StreamReader` classes provide generic "
"working interfaces which can be used to implement new encoding submodules "
"very easily. See :mod:`encodings.utf_8` for an example of how this is done."
msgstr ""

#: ../../library/codecs.rst:704
msgid "StreamWriter Objects"
msgstr "StreamWriter-objekt"

#: ../../library/codecs.rst:706
msgid ""
"The :class:`StreamWriter` class is a subclass of :class:`Codec` and defines "
"the following methods which every stream writer must define in order to be "
"compatible with the Python codec registry."
msgstr ""
"Klassen :class:`StreamWriter` är en underklass till :class:`Kodek` och "
"definierar följande metoder som alla streamwriters måste definiera för att "
"vara kompatibla med Pythons kodek-register."

#: ../../library/codecs.rst:713
msgid "Constructor for a :class:`StreamWriter` instance."
msgstr "Konstruktör för en :class:`StreamWriter`-instans."

#: ../../library/codecs.rst:715
msgid ""
"All stream writers must provide this constructor interface. They are free to"
" add additional keyword arguments, but only the ones defined here are used "
"by the Python codec registry."
msgstr ""
"Alla strömskrivare måste tillhandahålla detta konstruktörsgränssnitt. De är "
"fria att lägga till ytterligare nyckelordsargument, men endast de som "
"definieras här används av Pythons kodek-register."

#: ../../library/codecs.rst:719
msgid ""
"The *stream* argument must be a file-like object open for writing text or "
"binary data, as appropriate for the specific codec."
msgstr ""
"Argumentet *stream* måste vara ett filliknande objekt som är öppet för att "
"skriva text eller binära data, beroende på vad som är lämpligt för den "
"specifika kodeken."

#: ../../library/codecs.rst:722
msgid ""
"The :class:`StreamWriter` may implement different error handling schemes by "
"providing the *errors* keyword argument. See :ref:`error-handlers` for the "
"standard error handlers the underlying stream codec may support."
msgstr ""
"Klassen :class:`StreamWriter` kan implementera olika felhanteringssystem "
"genom att tillhandahålla nyckelordsargumentet *errors*. Se :ref:`error-"
"handlers` för de standardfelhanterare som den underliggande stream-kodek kan"
" stödja."

#: ../../library/codecs.rst:726
msgid ""
"The *errors* argument will be assigned to an attribute of the same name. "
"Assigning to this attribute makes it possible to switch between different "
"error handling strategies during the lifetime of the :class:`StreamWriter` "
"object."
msgstr ""
"Argumentet *errors* kommer att tilldelas ett attribut med samma namn. Genom "
"att tilldela detta attribut blir det möjligt att växla mellan olika "
"felhanteringsstrategier under :class:`StreamWriter`-objektets livstid."

#: ../../library/codecs.rst:732
msgid "Writes the object's contents encoded to the stream."
msgstr "Skriver objektets innehåll kodat till strömmen."

#: ../../library/codecs.rst:737
msgid ""
"Writes the concatenated iterable of strings to the stream (possibly by "
"reusing the :meth:`write` method). Infinite or very large iterables are not "
"supported. The standard bytes-to-bytes codecs do not support this method."
msgstr ""
"Skriver den konkatenerade iterationen av strängar till strömmen (eventuellt "
"genom att återanvända metoden :meth:`write`). Oändliga eller mycket stora "
"iterabler stöds inte. De vanliga bytes-till-bytes-kodekerna stöder inte "
"denna metod."

#: ../../library/codecs.rst:745 ../../library/codecs.rst:840
msgid "Resets the codec buffers used for keeping internal state."
msgstr ""
"Återställer kodek-buffertarna som används för att hålla internt tillstånd."

#: ../../library/codecs.rst:747
msgid ""
"Calling this method should ensure that the data on the output is put into a "
"clean state that allows appending of new fresh data without having to rescan"
" the whole stream to recover state."
msgstr ""
"Genom att anropa den här metoden kan man säkerställa att data på utdatasidan"
" försätts i ett rent tillstånd som gör det möjligt att lägga till nya data "
"utan att behöva skanna om hela flödet till ett återställt tillstånd."

#: ../../library/codecs.rst:752
msgid ""
"In addition to the above methods, the :class:`StreamWriter` must also "
"inherit all other methods and attributes from the underlying stream."
msgstr ""
"Förutom ovanstående metoder måste :class:`StreamWriter` också ärva alla "
"andra metoder och attribut från den underliggande strömmen."

#: ../../library/codecs.rst:759
msgid "StreamReader Objects"
msgstr "StreamReader-objekt"

#: ../../library/codecs.rst:761
msgid ""
"The :class:`StreamReader` class is a subclass of :class:`Codec` and defines "
"the following methods which every stream reader must define in order to be "
"compatible with the Python codec registry."
msgstr ""
"Klassen :class:`StreamReader` är en underklass till :class:`Kodek` och "
"definierar följande metoder som varje strömläsare måste definiera för att "
"vara kompatibel med Pythons kodek-register."

#: ../../library/codecs.rst:768
msgid "Constructor for a :class:`StreamReader` instance."
msgstr "Konstruktor för en :class:`StreamReader`-instans."

#: ../../library/codecs.rst:770
msgid ""
"All stream readers must provide this constructor interface. They are free to"
" add additional keyword arguments, but only the ones defined here are used "
"by the Python codec registry."
msgstr ""
"Alla strömläsare måste tillhandahålla detta konstruktörsgränssnitt. De är "
"fria att lägga till ytterligare nyckelordsargument, men endast de som "
"definieras här används av Pythons kodek-register."

#: ../../library/codecs.rst:774
msgid ""
"The *stream* argument must be a file-like object open for reading text or "
"binary data, as appropriate for the specific codec."
msgstr ""
"Argumentet *stream* måste vara ett filliknande objekt som är öppet för "
"läsning av text eller binära data, beroende på vad som är lämpligt för den "
"specifika kodeken."

#: ../../library/codecs.rst:777
msgid ""
"The :class:`StreamReader` may implement different error handling schemes by "
"providing the *errors* keyword argument. See :ref:`error-handlers` for the "
"standard error handlers the underlying stream codec may support."
msgstr ""
"Klassen :class:`StreamReader` kan implementera olika felhanteringssystem "
"genom att tillhandahålla nyckelordsargumentet *errors*. Se :ref:`error-"
"handlers` för de standardfelhanterare som den underliggande stream-kodek kan"
" stödja."

#: ../../library/codecs.rst:781
msgid ""
"The *errors* argument will be assigned to an attribute of the same name. "
"Assigning to this attribute makes it possible to switch between different "
"error handling strategies during the lifetime of the :class:`StreamReader` "
"object."
msgstr ""
"Argumentet *errors* kommer att tilldelas ett attribut med samma namn. Genom "
"att tilldela detta attribut blir det möjligt att växla mellan olika "
"felhanteringsstrategier under :class:`StreamReader`-objektets livstid."

#: ../../library/codecs.rst:785
msgid ""
"The set of allowed values for the *errors* argument can be extended with "
":func:`register_error`."
msgstr ""
"Uppsättningen av tillåtna värden för argumentet *errors* kan utökas med "
":func:`register_error`."

#: ../../library/codecs.rst:791
msgid "Decodes data from the stream and returns the resulting object."
msgstr "Avkodar data från strömmen och returnerar det resulterande objektet."

#: ../../library/codecs.rst:793
msgid ""
"The *chars* argument indicates the number of decoded code points or bytes to"
" return. The :func:`read` method will never return more data than requested,"
" but it might return less, if there is not enough available."
msgstr ""
"Argumentet *chars* anger antalet avkodade kodpunkter eller byte som ska "
"returneras. Metoden :func:`read` kommer aldrig att returnera mer data än vad"
" som begärts, men den kan returnera mindre om det inte finns tillräckligt "
"med data tillgängligt."

#: ../../library/codecs.rst:798
msgid ""
"The *size* argument indicates the approximate maximum number of encoded "
"bytes or code points to read for decoding. The decoder can modify this "
"setting as appropriate. The default value -1 indicates to read and decode as"
" much as possible. This parameter is intended to prevent having to decode "
"huge files in one step."
msgstr ""
"Argumentet *size* anger det ungefärliga maximala antalet kodade bytes eller "
"kodpunkter som ska läsas för avkodning. Avkodaren kan ändra denna "
"inställning på lämpligt sätt. Standardvärdet -1 anger att så mycket som "
"möjligt ska läsas och avkodas. Denna parameter är avsedd att förhindra att "
"stora filer måste avkodas i ett steg."

#: ../../library/codecs.rst:805
msgid ""
"The *firstline* flag indicates that it would be sufficient to only return "
"the first line, if there are decoding errors on later lines."
msgstr ""
"Flaggan *firstline* anger att det skulle räcka att bara returnera den första"
" raden om det finns avkodningsfel på senare rader."

#: ../../library/codecs.rst:809
msgid ""
"The method should use a greedy read strategy meaning that it should read as "
"much data as is allowed within the definition of the encoding and the given "
"size, e.g.  if optional encoding endings or state markers are available on "
"the stream, these should be read too."
msgstr ""
"Metoden bör använda en girig lässtrategi, vilket innebär att den bör läsa så"
" mycket data som tillåts inom definitionen av kodningen och den givna "
"storleken, t.ex. om valfria kodningsändelser eller tillståndsmarkörer finns "
"tillgängliga i strömmen, bör dessa också läsas."

#: ../../library/codecs.rst:817
msgid "Read one line from the input stream and return the decoded data."
msgstr "Läs en rad från inmatningsflödet och returnera de avkodade data."

#: ../../library/codecs.rst:819
msgid ""
"*size*, if given, is passed as size argument to the stream's :meth:`read` "
"method."
msgstr ""
"*size*, om den anges, skickas som size-argument till strömningens "
":meth:`read`-metod."

#: ../../library/codecs.rst:822
msgid ""
"If *keepends* is false line-endings will be stripped from the lines "
"returned."
msgstr ""
"Om *keepends* är false kommer radavslut att tas bort från de returnerade "
"raderna."

#: ../../library/codecs.rst:828
msgid ""
"Read all lines available on the input stream and return them as a list of "
"lines."
msgstr ""
"Läs alla tillgängliga rader i inmatningsströmmen och returnera dem som en "
"lista med rader."

#: ../../library/codecs.rst:831
msgid ""
"Line-endings are implemented using the codec's :meth:`decode` method and are"
" included in the list entries if *keepends* is true."
msgstr ""
"Radavslut implementeras med hjälp av kodek:ens metod :meth:`decode` och "
"inkluderas i listans poster om *keepends* är true."

#: ../../library/codecs.rst:834
msgid ""
"*sizehint*, if given, is passed as the *size* argument to the stream's "
":meth:`read` method."
msgstr ""
"*sizehint*, om den anges, skickas som argumentet *size* till strömningens "
"metod :meth:`read`."

#: ../../library/codecs.rst:842
msgid ""
"Note that no stream repositioning should take place. This method is "
"primarily intended to be able to recover from decoding errors."
msgstr ""
"Observera att ingen ompositionering av strömmen ska ske. Denna metod är "
"främst avsedd för att kunna återhämta sig efter avkodningsfel."

#: ../../library/codecs.rst:846
msgid ""
"In addition to the above methods, the :class:`StreamReader` must also "
"inherit all other methods and attributes from the underlying stream."
msgstr ""
"Förutom ovanstående metoder måste :class:`StreamReader` också ärva alla "
"andra metoder och attribut från den underliggande strömmen."

#: ../../library/codecs.rst:852
msgid "StreamReaderWriter Objects"
msgstr "StreamReaderWriter-objekt"

#: ../../library/codecs.rst:854
msgid ""
"The :class:`StreamReaderWriter` is a convenience class that allows wrapping "
"streams which work in both read and write modes."
msgstr ""
":class:`StreamReaderWriter` är en bekvämlighetsklass som gör det möjligt att"
" paketera strömmar som fungerar i både läs- och skrivläge."

#: ../../library/codecs.rst:857 ../../library/codecs.rst:881
msgid ""
"The design is such that one can use the factory functions returned by the "
":func:`lookup` function to construct the instance."
msgstr ""
"Designen är sådan att man kan använda de fabriksfunktioner som returneras av"
" :func:`lookup`-funktionen för att konstruera instansen."

#: ../../library/codecs.rst:863
msgid ""
"Creates a :class:`StreamReaderWriter` instance. *stream* must be a file-like"
" object. *Reader* and *Writer* must be factory functions or classes "
"providing the :class:`StreamReader` and :class:`StreamWriter` interface "
"resp. Error handling is done in the same way as defined for the stream "
"readers and writers."
msgstr ""
"Skapar en instans av :class:`StreamReaderWriter`. *stream* måste vara ett "
"filliknande objekt. *Reader* och *Writer* måste vara fabriksfunktioner eller"
" klasser som tillhandahåller gränssnittet :class:`StreamReader` respektive "
":class:`StreamWriter`. Felhantering sker på samma sätt som definierats för "
"stream-läsare och -skrivare."

#: ../../library/codecs.rst:868
msgid ""
":class:`StreamReaderWriter` instances define the combined interfaces of "
":class:`StreamReader` and :class:`StreamWriter` classes. They inherit all "
"other methods and attributes from the underlying stream."
msgstr ""
":class:`StreamReaderWriter`-instanser definierar de kombinerade gränssnitten"
" för klasserna :class:`StreamReader` och :class:`StreamWriter`. De ärver "
"alla andra metoder och attribut från den underliggande strömmen."

#: ../../library/codecs.rst:876
msgid "StreamRecoder Objects"
msgstr "StreamRecoder-objekt"

#: ../../library/codecs.rst:878
msgid ""
"The :class:`StreamRecoder` translates data from one encoding to another, "
"which is sometimes useful when dealing with different encoding environments."
msgstr ""
":class:`StreamRecoder` översätter data från en kodning till en annan, vilket"
" ibland är användbart när man har att göra med olika kodningsmiljöer."

#: ../../library/codecs.rst:887
msgid ""
"Creates a :class:`StreamRecoder` instance which implements a two-way "
"conversion: *encode* and *decode* work on the frontend — the data visible to"
" code calling :meth:`read` and :meth:`write`, while *Reader* and *Writer* "
"work on the backend — the data in *stream*."
msgstr ""

#: ../../library/codecs.rst:892
msgid ""
"You can use these objects to do transparent transcodings, e.g., from Latin-1"
" to UTF-8 and back."
msgstr ""
"Du kan använda dessa objekt för att göra transparenta omkodningar, t.ex. "
"från Latin-1 till UTF-8 och tillbaka."

#: ../../library/codecs.rst:895
msgid "The *stream* argument must be a file-like object."
msgstr "Argumentet *stream* måste vara ett filliknande objekt."

#: ../../library/codecs.rst:897
msgid ""
"The *encode* and *decode* arguments must adhere to the :class:`Codec` "
"interface. *Reader* and *Writer* must be factory functions or classes "
"providing objects of the :class:`StreamReader` and :class:`StreamWriter` "
"interface respectively."
msgstr ""
"Argumenten *encode* och *decode* måste följa gränssnittet :class:`Kodek`. "
"*Reader* och *Writer* måste vara fabriksfunktioner eller klasser som "
"tillhandahåller objekt av gränssnittet :class:`StreamReader` respektive "
":class:`StreamWriter`."

#: ../../library/codecs.rst:902
msgid ""
"Error handling is done in the same way as defined for the stream readers and"
" writers."
msgstr ""
"Felhanteringen sker på samma sätt som definierats för strömläsare och "
"strömskrivare."

#: ../../library/codecs.rst:906
msgid ""
":class:`StreamRecoder` instances define the combined interfaces of "
":class:`StreamReader` and :class:`StreamWriter` classes. They inherit all "
"other methods and attributes from the underlying stream."
msgstr ""
":class:`StreamRecoder`-instanser definierar de kombinerade gränssnitten för "
"klasserna :class:`StreamReader` och :class:`StreamWriter`. De ärver alla "
"andra metoder och attribut från den underliggande strömmen."

#: ../../library/codecs.rst:914
msgid "Encodings and Unicode"
msgstr "Kodningar och Unicode"

#: ../../library/codecs.rst:916
msgid ""
"Strings are stored internally as sequences of code points in range "
"``U+0000``--``U+10FFFF``. (See :pep:`393` for more details about the "
"implementation.) Once a string object is used outside of CPU and memory, "
"endianness and how these arrays are stored as bytes become an issue. As with"
" other codecs, serialising a string into a sequence of bytes is known as "
"*encoding*, and recreating the string from the sequence of bytes is known as"
" *decoding*. There are a variety of different text serialisation codecs, "
"which are collectivity referred to as :term:`text encodings <text "
"encoding>`."
msgstr ""
"Strängar lagras internt som sekvenser av kodpunkter i intervallet "
"``U+0000``--``U+10FFFF``. (Se :pep:`393` för mer information om "
"implementeringen.) När ett strängobjekt används utanför CPU och minne blir "
"endianness och hur dessa arrayer lagras som byte ett problem. Precis som med"
" andra kodekar kallas serialisering av en sträng till en sekvens av byte för"
" *encoding* och återskapande av strängen från sekvensen av byte för "
"*decoding*. Det finns en mängd olika kodekar för textserialisering, som "
"kollektivt kallas :term:`text encodings <text encoding>`."

#: ../../library/codecs.rst:926
msgid ""
"The simplest text encoding (called ``'latin-1'`` or ``'iso-8859-1'``) maps "
"the code points 0--255 to the bytes ``0x0``--``0xff``, which means that a "
"string object that contains code points above ``U+00FF`` can't be encoded "
"with this codec. Doing so will raise a :exc:`UnicodeEncodeError` that looks "
"like the following (although the details of the error message may differ): "
"``UnicodeEncodeError: 'latin-1' codec can't encode character '\\u1234' in "
"position 3: ordinal not in range(256)``."
msgstr ""
"Den enklaste textkodningen (kallad ``'latin-1'`` eller ``'iso-8859-1'``) "
"mappar kodpunkterna 0--255 till bytena ``0x0``--``0xff``, vilket innebär att"
" ett strängobjekt som innehåller kodpunkter över ``U+00FF`` inte kan kodas "
"med denna kodek. Om du gör det kommer ett :exc:`UnicodeEncodeError` att "
"uppstå som ser ut som följande (även om detaljerna i felmeddelandet kan "
"skilja sig åt): ``UnicodeEncodeError: 'latin-1' kodek kan inte koda tecknet "
"'\\u1234' i position 3: ordinal not in range(256)```."

#: ../../library/codecs.rst:934
msgid ""
"There's another group of encodings (the so called charmap encodings) that "
"choose a different subset of all Unicode code points and how these code "
"points are mapped to the bytes ``0x0``--``0xff``. To see how this is done "
"simply open e.g. :file:`encodings/cp1252.py` (which is an encoding that is "
"used primarily on Windows). There's a string constant with 256 characters "
"that shows you which character is mapped to which byte value."
msgstr ""
"Det finns en annan grupp av kodningar (de s.k. charmap-kodningarna) som "
"väljer en annan delmängd av alla Unicode-kodpunkter och hur dessa kodpunkter"
" mappas till bytena ``0x0``--``0xff``. För att se hur detta görs är det bara"
" att öppna t.ex. :file:`encodings/cp1252.py` (som är en kodning som används "
"främst på Windows). Där finns en strängkonstant med 256 tecken som visar "
"vilket tecken som är mappat till vilket bytevärde."

#: ../../library/codecs.rst:941
msgid ""
"All of these encodings can only encode 256 of the 1114112 code points "
"defined in Unicode. A simple and straightforward way that can store each "
"Unicode code point, is to store each code point as four consecutive bytes. "
"There are two possibilities: store the bytes in big endian or in little "
"endian order. These two encodings are called ``UTF-32-BE`` and ``UTF-32-LE``"
" respectively. Their disadvantage is that if e.g. you use ``UTF-32-BE`` on a"
" little endian machine you will always have to swap bytes on encoding and "
"decoding. ``UTF-32`` avoids this problem: bytes will always be in natural "
"endianness. When these bytes are read by a CPU with a different endianness, "
"then bytes have to be swapped though. To be able to detect the endianness of"
" a ``UTF-16`` or ``UTF-32`` byte sequence, there's the so called BOM (\"Byte"
" Order Mark\"). This is the Unicode character ``U+FEFF``. This character can"
" be prepended to every ``UTF-16`` or ``UTF-32`` byte sequence. The byte "
"swapped version of this character (``0xFFFE``) is an illegal character that "
"may not appear in a Unicode text. So when the first character in a "
"``UTF-16`` or ``UTF-32`` byte sequence appears to be a ``U+FFFE`` the bytes "
"have to be swapped on decoding. Unfortunately the character ``U+FEFF`` had a"
" second purpose as a ``ZERO WIDTH NO-BREAK SPACE``: a character that has no "
"width and doesn't allow a word to be split. It can e.g. be used to give "
"hints to a ligature algorithm. With Unicode 4.0 using ``U+FEFF`` as a ``ZERO"
" WIDTH NO-BREAK SPACE`` has been deprecated (with ``U+2060`` (``WORD "
"JOINER``) assuming this role). Nevertheless Unicode software still must be "
"able to handle ``U+FEFF`` in both roles: as a BOM it's a device to determine"
" the storage layout of the encoded bytes, and vanishes once the byte "
"sequence has been decoded into a string; as a ``ZERO WIDTH NO-BREAK SPACE`` "
"it's a normal character that will be decoded like any other."
msgstr ""
"Alla dessa kodningar kan bara koda 256 av de 1114112 kodpunkter som "
"definieras i Unicode. Ett enkelt och okomplicerat sätt att lagra varje "
"Unicode-kodpunkt är att lagra varje kodpunkt som fyra på varandra följande "
"byte. Det finns två möjligheter: lagra bytena i big endian- eller little "
"endian-ordning. Dessa två kodningar kallas ``UTF-32-BE`` respektive "
"``UTF-32-LE``. Nackdelen med dem är att om man t.ex. använder ``UTF-32-BE`` "
"på en little endian-maskin måste man alltid byta byte vid kodning och "
"avkodning. ``UTF-32`` undviker detta problem: byte kommer alltid att vara i "
"naturlig endian. När dessa byte läses av en CPU med en annan endianness, "
"måste byte dock bytas ut. För att kunna upptäcka endianness för en "
"``UTF-16`` eller ``UTF-32`` byte-sekvens, finns det så kallade BOM (\"Byte "
"Order Mark\"). Detta är Unicode-tecknet ``U+FEFF``. Detta tecken kan "
"prependlas till varje ``UTF-16`` eller ``UTF-32`` byte-sekvens. Den "
"byteväxlade versionen av detta tecken (``0xFFFE``) är ett olagligt tecken "
"som inte får förekomma i en Unicode-text. Så när det första tecknet i en "
"``UTF-16`` eller ``UTF-32`` byte-sekvens ser ut att vara en ``U+FFFE`` måste"
" bytena bytas vid avkodningen. Tyvärr hade tecknet ``U+FEFF`` ett andra "
"syfte som ett ``ZERO WIDTH NO-BREAK SPACE``: ett tecken som inte har någon "
"bredd och inte tillåter att ett ord delas upp. Det kan t.ex. användas för "
"att ge ledtrådar till en ligaturalgoritm. Med Unicode 4.0 har användningen "
"av ``U+FEFF`` som ett ``ZERO WIDTH NO-BREAK SPACE`` utgått (med ``U+2060`` "
"(``WORD JOINER``) som tar över denna roll). Unicode-programvara måste dock "
"fortfarande kunna hantera ``U+FEFF`` i båda rollerna: som BOM är det en "
"enhet för att bestämma lagringslayouten för de kodade byte, och försvinner "
"när byte-sekvensen har avkodats till en sträng; som ``ZERO WIDTH NO-BREAK "
"SPACE`` är det ett normalt tecken som kommer att avkodas som alla andra."

#: ../../library/codecs.rst:967
msgid ""
"There's another encoding that is able to encode the full range of Unicode "
"characters: UTF-8. UTF-8 is an 8-bit encoding, which means there are no "
"issues with byte order in UTF-8. Each byte in a UTF-8 byte sequence consists"
" of two parts: marker bits (the most significant bits) and payload bits. The"
" marker bits are a sequence of zero to four ``1`` bits followed by a ``0`` "
"bit. Unicode characters are encoded like this (with x being payload bits, "
"which when concatenated give the Unicode character):"
msgstr ""
"Det finns en annan kodning som kan koda hela utbudet av Unicode-tecken: "
"UTF-8. UTF-8 är en 8-bitars kodning, vilket innebär att det inte finns några"
" problem med byteordningen i UTF-8. Varje byte i en UTF-8-bytessekvens "
"består av två delar: markörbitar (de mest signifikanta bitarna) och "
"nyttolastbitar. Markörbitarna är en sekvens av noll till fyra ``1``-bitar "
"följt av en ``0``-bit. Unicode-tecken kodas så här (x är payload-bitar, som "
"när de sammankopplas ger Unicode-tecknet):"

#: ../../library/codecs.rst:976
msgid "Range"
msgstr "Intervall"

#: ../../library/codecs.rst:976
msgid "Encoding"
msgstr "Avkodning"

#: ../../library/codecs.rst:978
msgid "``U-00000000`` ... ``U-0000007F``"
msgstr "``U-00000000`` ... ``U-0000007F``"

#: ../../library/codecs.rst:978
msgid "0xxxxxxx"
msgstr "0xxxxxxx"

#: ../../library/codecs.rst:980
msgid "``U-00000080`` ... ``U-000007FF``"
msgstr "``U-00000080`` ... ``U-000007FF``"

#: ../../library/codecs.rst:980
msgid "110xxxxx 10xxxxxx"
msgstr "110xxxxx 10xxxxxx"

#: ../../library/codecs.rst:982
msgid "``U-00000800`` ... ``U-0000FFFF``"
msgstr "``U-00000800`` ... ``U-0000FFFF``"

#: ../../library/codecs.rst:982
msgid "1110xxxx 10xxxxxx 10xxxxxx"
msgstr "1110xxxx 10xxxxxx 10xxxxxx"

#: ../../library/codecs.rst:984
msgid "``U-00010000`` ... ``U-0010FFFF``"
msgstr "``U-00010000`` ... ``U-0010FFFF``"

#: ../../library/codecs.rst:984
msgid "11110xxx 10xxxxxx 10xxxxxx 10xxxxxx"
msgstr "11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx"

#: ../../library/codecs.rst:987
msgid ""
"The least significant bit of the Unicode character is the rightmost x bit."
msgstr ""
"Den minst signifikanta biten i Unicode-tecknet är den längst till höger "
"liggande x-biten."

#: ../../library/codecs.rst:989
msgid ""
"As UTF-8 is an 8-bit encoding no BOM is required and any ``U+FEFF`` "
"character in the decoded string (even if it's the first character) is "
"treated as a ``ZERO WIDTH NO-BREAK SPACE``."
msgstr ""
"Eftersom UTF-8 är en 8-bitars kodning krävs ingen BOM och varje "
"``U+FEFF``-tecken i den avkodade strängen (även om det är det första "
"tecknet) behandlas som ett ``ZERO WIDTH NO-BREAK SPACE``."

#: ../../library/codecs.rst:993
msgid ""
"Without external information it's impossible to reliably determine which "
"encoding was used for encoding a string. Each charmap encoding can decode "
"any random byte sequence. However that's not possible with UTF-8, as UTF-8 "
"byte sequences have a structure that doesn't allow arbitrary byte sequences."
" To increase the reliability with which a UTF-8 encoding can be detected, "
"Microsoft invented a variant of UTF-8 (that Python calls ``\"utf-8-sig\"``) "
"for its Notepad program: Before any of the Unicode characters is written to "
"the file, a UTF-8 encoded BOM (which looks like this as a byte sequence: "
"``0xef``, ``0xbb``, ``0xbf``) is written. As it's rather improbable that any"
" charmap encoded file starts with these byte values (which would e.g. map to"
msgstr ""
"Utan extern information är det omöjligt att på ett tillförlitligt sätt "
"avgöra vilken kodning som användes för att koda en sträng. Varje charmap-"
"kodning kan avkoda vilken slumpmässig byte-sekvens som helst. Det är dock "
"inte möjligt med UTF-8, eftersom UTF-8-bytessekvenser har en struktur som "
"inte tillåter godtyckliga bytessekvenser. För att öka tillförlitligheten med"
" vilken en UTF-8-kodning kan upptäckas uppfann Microsoft en variant av UTF-8"
" (som Python kallar ``\"utf-8-sig\"``) för sitt Notepad-program: Innan något"
" av Unicode-tecknen skrivs till filen, skrivs en UTF-8-kodad BOM (som ser ut"
" så här som en byte-sekvens: ``0xef``, ``0xbb``, ``0xbf``). Eftersom det är "
"ganska osannolikt att någon charmap-kodad fil börjar med dessa bytevärden "
"(som t.ex. skulle motsvara"

#: ../../library/codecs.rst:0
msgid "LATIN SMALL LETTER I WITH DIAERESIS"
msgstr "LATINSKA LILLA BOKSTAVEN I MED DIACERESE"

#: ../../library/codecs.rst:0
msgid "RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK"
msgstr "HÖGERPEKANDE DUBBELVINKELCITATIONSTECKEN"

#: ../../library/codecs.rst:0
msgid "INVERTED QUESTION MARK"
msgstr "INVERTERAT FRÅGETECKEN"

#: ../../library/codecs.rst:1009
msgid ""
"in iso-8859-1), this increases the probability that a ``utf-8-sig`` encoding"
" can be correctly guessed from the byte sequence. So here the BOM is not "
"used to be able to determine the byte order used for generating the byte "
"sequence, but as a signature that helps in guessing the encoding. On "
"encoding the utf-8-sig codec will write ``0xef``, ``0xbb``, ``0xbf`` as the "
"first three bytes to the file. On decoding ``utf-8-sig`` will skip those "
"three bytes if they appear as the first three bytes in the file. In UTF-8, "
"the use of the BOM is discouraged and should generally be avoided."
msgstr ""
"i iso-8859-1), ökar detta sannolikheten för att en ``utf-8-sig``-kodning kan"
" gissas korrekt från byte-sekvensen. Här används alltså inte BOM för att "
"avgöra vilken byteordning som använts för att generera byte-sekvensen, utan "
"som en signatur som hjälper till att gissa kodningen. Vid kodning skriver "
"utf-8-sig-kodek ``0xef``, ``0xbb``, ``0xbf`` som de tre första bytena till "
"filen. Vid avkodning kommer ``utf-8-sig`` att hoppa över dessa tre byte om "
"de förekommer som de tre första byte i filen. I UTF-8 är användningen av BOM"
" avrådd och bör i allmänhet undvikas."

#: ../../library/codecs.rst:1022
msgid "Standard Encodings"
msgstr "Standardkodningar"

#: ../../library/codecs.rst:1024
msgid ""
"Python comes with a number of codecs built-in, either implemented as C "
"functions or with dictionaries as mapping tables. The following table lists "
"the codecs by name, together with a few common aliases, and the languages "
"for which the encoding is likely used. Neither the list of aliases nor the "
"list of languages is meant to be exhaustive. Notice that spelling "
"alternatives that only differ in case or use a hyphen instead of an "
"underscore are also valid aliases; therefore, e.g. ``'utf-8'`` is a valid "
"alias for the ``'utf_8'`` codec."
msgstr ""

#: ../../library/codecs.rst:1034
msgid ""
"Some common encodings can bypass the codecs lookup machinery to improve "
"performance. These optimization opportunities are only recognized by CPython"
" for a limited set of (case insensitive) aliases: utf-8, utf8, latin-1, "
"latin1, iso-8859-1, iso8859-1, mbcs (Windows only), ascii, us-ascii, utf-16,"
" utf16, utf-32, utf32, and the same using underscores instead of dashes. "
"Using alternative aliases for these encodings may result in slower "
"execution."
msgstr ""
"Vissa vanliga kodningar kan kringgå kodekar-uppslagningsmaskineriet för att "
"förbättra prestandan. Dessa optimeringsmöjligheter känns bara igen av "
"CPython för en begränsad uppsättning (skiftlägesokänsliga) alias: utf-8, "
"utf8, latin-1, latin1, iso-8859-1, iso8859-1, mbcs (endast Windows), ascii, "
"us-ascii, utf-16, utf16, utf-32, utf32, och samma sak med understreck "
"istället för bindestreck. Om du använder alternativa alias för dessa "
"kodningar kan det leda till långsammare körning."

#: ../../library/codecs.rst:1042
msgid "Optimization opportunity recognized for us-ascii."
msgstr "Optimeringsmöjlighet erkänd för us-ascii."

#: ../../library/codecs.rst:1045
msgid ""
"Many of the character sets support the same languages. They vary in "
"individual characters (e.g. whether the EURO SIGN is supported or not), and "
"in the assignment of characters to code positions. For the European "
"languages in particular, the following variants typically exist:"
msgstr ""
"Många av teckenuppsättningarna stöder samma språk. De varierar i fråga om "
"enskilda tecken (t.ex. om EURO-tecknet stöds eller inte) och i fråga om "
"tilldelningen av tecken till kodpositioner. I synnerhet för de europeiska "
"språken finns normalt följande varianter:"

#: ../../library/codecs.rst:1050
msgid "an ISO 8859 codeset"
msgstr "en ISO 8859-kodset"

#: ../../library/codecs.rst:1052
msgid ""
"a Microsoft Windows code page, which is typically derived from an 8859 "
"codeset, but replaces control characters with additional graphic characters"
msgstr ""
"en Microsoft Windows-kodsida som vanligtvis härrör från en 8859-kod, men som"
" ersätter kontrolltecken med ytterligare grafiska tecken"

#: ../../library/codecs.rst:1055
msgid "an IBM EBCDIC code page"
msgstr "en IBM EBCDIC-kodsida"

#: ../../library/codecs.rst:1057
msgid "an IBM PC code page, which is ASCII compatible"
msgstr "en IBM PC-kodsida, som är ASCII-kompatibel"

#: ../../library/codecs.rst:1062 ../../library/codecs.rst:1317
#: ../../library/codecs.rst:1384 ../../library/codecs.rst:1439
msgid "Codec"
msgstr "Kodek"

#: ../../library/codecs.rst:1062 ../../library/codecs.rst:1317
#: ../../library/codecs.rst:1384 ../../library/codecs.rst:1439
msgid "Aliases"
msgstr "Alias"

#: ../../library/codecs.rst:1062
msgid "Languages"
msgstr "Språk"

#: ../../library/codecs.rst:1064
msgid "ascii"
msgstr "ascii"

#: ../../library/codecs.rst:1064
msgid "646, us-ascii"
msgstr "646, us-ascii"

#: ../../library/codecs.rst:1064 ../../library/codecs.rst:1070
#: ../../library/codecs.rst:1078
msgid "English"
msgstr "Engelska"

#: ../../library/codecs.rst:1066
msgid "big5"
msgstr "big5"

#: ../../library/codecs.rst:1066
msgid "big5-tw, csbig5"
msgstr "big5-tw, csbig5"

#: ../../library/codecs.rst:1066 ../../library/codecs.rst:1068
#: ../../library/codecs.rst:1126
msgid "Traditional Chinese"
msgstr "Traditionell kinesiska"

#: ../../library/codecs.rst:1068
msgid "big5hkscs"
msgstr "big5hkscs"

#: ../../library/codecs.rst:1068
msgid "big5-hkscs, hkscs"
msgstr "big5-hkscs, hkscs"

#: ../../library/codecs.rst:1070
msgid "cp037"
msgstr "cp037"

#: ../../library/codecs.rst:1070
msgid "IBM037, IBM039"
msgstr "IBM037, IBM039"

#: ../../library/codecs.rst:1072
msgid "cp273"
msgstr "cp273"

#: ../../library/codecs.rst:1072
msgid "273, IBM273, csIBM273"
msgstr "273, IBM273, csIBM273"

#: ../../library/codecs.rst:1072
msgid "German"
msgstr "Tyska"

#: ../../library/codecs.rst:1076
msgid "cp424"
msgstr "cp424"

#: ../../library/codecs.rst:1076
msgid "EBCDIC-CP-HE, IBM424"
msgstr "EBCDIC-CP-HE, IBM424"

#: ../../library/codecs.rst:1076 ../../library/codecs.rst:1096
#: ../../library/codecs.rst:1106 ../../library/codecs.rst:1149
#: ../../library/codecs.rst:1212
msgid "Hebrew"
msgstr "Hebreiska"

#: ../../library/codecs.rst:1078
msgid "cp437"
msgstr "cp437"

#: ../../library/codecs.rst:1078
msgid "437, IBM437"
msgstr "437, IBM437"

#: ../../library/codecs.rst:1080
msgid "cp500"
msgstr "cp500"

#: ../../library/codecs.rst:1080
msgid "EBCDIC-CP-BE, EBCDIC-CP-CH, IBM500"
msgstr "EBCDIC-CP-BE, EBCDIC-CP-CH, IBM500"

#: ../../library/codecs.rst:1080 ../../library/codecs.rst:1089
#: ../../library/codecs.rst:1100 ../../library/codecs.rst:1136
#: ../../library/codecs.rst:1143 ../../library/codecs.rst:1196
#: ../../library/codecs.rst:1224 ../../library/codecs.rst:1252
msgid "Western Europe"
msgstr "Västeuropa"

#: ../../library/codecs.rst:1083
msgid "cp720"
msgstr "cp720"

#: ../../library/codecs.rst:1083 ../../library/codecs.rst:1110
#: ../../library/codecs.rst:1151 ../../library/codecs.rst:1208
msgid "Arabic"
msgstr "Arabiska"

#: ../../library/codecs.rst:1085
msgid "cp737"
msgstr "cp737"

#: ../../library/codecs.rst:1085 ../../library/codecs.rst:1116
#: ../../library/codecs.rst:1120 ../../library/codecs.rst:1145
#: ../../library/codecs.rst:1210 ../../library/codecs.rst:1245
msgid "Greek"
msgstr "Grekiska"

#: ../../library/codecs.rst:1087
msgid "cp775"
msgstr "cp775"

#: ../../library/codecs.rst:1087
msgid "IBM775"
msgstr "IBM775"

#: ../../library/codecs.rst:1087 ../../library/codecs.rst:1153
#: ../../library/codecs.rst:1203 ../../library/codecs.rst:1220
msgid "Baltic languages"
msgstr "Baltiska språk"

#: ../../library/codecs.rst:1089
msgid "cp850"
msgstr "cp850"

#: ../../library/codecs.rst:1089
msgid "850, IBM850"
msgstr "850, IBM850"

#: ../../library/codecs.rst:1091
msgid "cp852"
msgstr "cp852"

#: ../../library/codecs.rst:1091
msgid "852, IBM852"
msgstr "852, IBM852"

#: ../../library/codecs.rst:1091 ../../library/codecs.rst:1138
#: ../../library/codecs.rst:1199 ../../library/codecs.rst:1249
msgid "Central and Eastern Europe"
msgstr "Central- och Östeuropa"

#: ../../library/codecs.rst:1093
msgid "cp855"
msgstr "cp855"

#: ../../library/codecs.rst:1093
msgid "855, IBM855"
msgstr "855, IBM855"

#: ../../library/codecs.rst:1093 ../../library/codecs.rst:1140
#: ../../library/codecs.rst:1205 ../../library/codecs.rst:1242
msgid "Bulgarian, Byelorussian, Macedonian, Russian, Serbian"
msgstr ""

#: ../../library/codecs.rst:1096
msgid "cp856"
msgstr "cp856"

#: ../../library/codecs.rst:1098
msgid "cp857"
msgstr "cp857"

#: ../../library/codecs.rst:1098
msgid "857, IBM857"
msgstr "857, IBM857"

#: ../../library/codecs.rst:1098 ../../library/codecs.rst:1130
#: ../../library/codecs.rst:1147 ../../library/codecs.rst:1214
#: ../../library/codecs.rst:1254
msgid "Turkish"
msgstr "Turkiska"

#: ../../library/codecs.rst:1100
msgid "cp858"
msgstr "cp858"

#: ../../library/codecs.rst:1100
msgid "858, IBM858"
msgstr "858, IBM858"

#: ../../library/codecs.rst:1102
msgid "cp860"
msgstr "cp860"

#: ../../library/codecs.rst:1102
msgid "860, IBM860"
msgstr "860, IBM860"

#: ../../library/codecs.rst:1102
msgid "Portuguese"
msgstr "Portugisiska"

#: ../../library/codecs.rst:1104
msgid "cp861"
msgstr "cp861"

#: ../../library/codecs.rst:1104
msgid "861, CP-IS, IBM861"
msgstr "861, CP-IS, IBM861"

#: ../../library/codecs.rst:1104 ../../library/codecs.rst:1247
msgid "Icelandic"
msgstr "Icelandic"

#: ../../library/codecs.rst:1106
msgid "cp862"
msgstr "cp862"

#: ../../library/codecs.rst:1106
msgid "862, IBM862"
msgstr "862, IBM862"

#: ../../library/codecs.rst:1108
msgid "cp863"
msgstr "cp863"

#: ../../library/codecs.rst:1108
msgid "863, IBM863"
msgstr "863, IBM863"

#: ../../library/codecs.rst:1108
msgid "Canadian"
msgstr "Canadian"

#: ../../library/codecs.rst:1110
msgid "cp864"
msgstr "cp864"

#: ../../library/codecs.rst:1110
msgid "IBM864"
msgstr "IBM864"

#: ../../library/codecs.rst:1112
msgid "cp865"
msgstr "cp865"

#: ../../library/codecs.rst:1112
msgid "865, IBM865"
msgstr "865, IBM865"

#: ../../library/codecs.rst:1112
msgid "Danish, Norwegian"
msgstr "Danska, Norska"

#: ../../library/codecs.rst:1114
msgid "cp866"
msgstr "cp866"

#: ../../library/codecs.rst:1114
msgid "866, IBM866"
msgstr "866, IBM866"

#: ../../library/codecs.rst:1114 ../../library/codecs.rst:1230
msgid "Russian"
msgstr "Russian"

#: ../../library/codecs.rst:1116
msgid "cp869"
msgstr "cp869"

#: ../../library/codecs.rst:1116
msgid "869, CP-GR, IBM869"
msgstr "869, CP-GR, IBM869"

#: ../../library/codecs.rst:1118
msgid "cp874"
msgstr "cp874"

#: ../../library/codecs.rst:1118
msgid "Thai"
msgstr "Thai"

#: ../../library/codecs.rst:1120
msgid "cp875"
msgstr "cp875"

#: ../../library/codecs.rst:1122
msgid "cp932"
msgstr "cp932"

#: ../../library/codecs.rst:1122
msgid "932, ms932, mskanji, ms-kanji"
msgstr ""

#: ../../library/codecs.rst:1122 ../../library/codecs.rst:1157
#: ../../library/codecs.rst:1159 ../../library/codecs.rst:1161
#: ../../library/codecs.rst:1178 ../../library/codecs.rst:1181
#: ../../library/codecs.rst:1186 ../../library/codecs.rst:1189
#: ../../library/codecs.rst:1191 ../../library/codecs.rst:1259
#: ../../library/codecs.rst:1262 ../../library/codecs.rst:1265
msgid "Japanese"
msgstr "Japanska"

#: ../../library/codecs.rst:1124
msgid "cp949"
msgstr "cp949"

#: ../../library/codecs.rst:1124
msgid "949, ms949, uhc"
msgstr "949, ms949, uhc"

#: ../../library/codecs.rst:1124 ../../library/codecs.rst:1163
#: ../../library/codecs.rst:1193 ../../library/codecs.rst:1228
msgid "Korean"
msgstr "Koreanska"

#: ../../library/codecs.rst:1126
msgid "cp950"
msgstr "cp950"

#: ../../library/codecs.rst:1126
msgid "950, ms950"
msgstr "950, ms950"

#: ../../library/codecs.rst:1128
msgid "cp1006"
msgstr "cp1006"

#: ../../library/codecs.rst:1128
msgid "Urdu"
msgstr "Urdu"

#: ../../library/codecs.rst:1130
msgid "cp1026"
msgstr "cp1026"

#: ../../library/codecs.rst:1130
msgid "ibm1026"
msgstr "ibm1026"

#: ../../library/codecs.rst:1132
msgid "cp1125"
msgstr "cp1125"

#: ../../library/codecs.rst:1132
msgid "1125, ibm1125, cp866u, ruscii"
msgstr "1125, ibm1125, cp866u, ruscii"

#: ../../library/codecs.rst:1132 ../../library/codecs.rst:1236
msgid "Ukrainian"
msgstr "Ukrainian"

#: ../../library/codecs.rst:1136
msgid "cp1140"
msgstr "cp1140"

#: ../../library/codecs.rst:1136
msgid "ibm1140"
msgstr "ibm1140"

#: ../../library/codecs.rst:1138
msgid "cp1250"
msgstr "cp1250"

#: ../../library/codecs.rst:1138
msgid "windows-1250"
msgstr "windows-1250"

#: ../../library/codecs.rst:1140
msgid "cp1251"
msgstr "cp1251"

#: ../../library/codecs.rst:1140
msgid "windows-1251"
msgstr "windows-1251"

#: ../../library/codecs.rst:1143
msgid "cp1252"
msgstr "cp1252"

#: ../../library/codecs.rst:1143
msgid "windows-1252"
msgstr "windows-1252"

#: ../../library/codecs.rst:1145
msgid "cp1253"
msgstr "cp1253"

#: ../../library/codecs.rst:1145
msgid "windows-1253"
msgstr "windows-1253"

#: ../../library/codecs.rst:1147
msgid "cp1254"
msgstr "cp1254"

#: ../../library/codecs.rst:1147
msgid "windows-1254"
msgstr "windows-1254"

#: ../../library/codecs.rst:1149
msgid "cp1255"
msgstr "cp1255"

#: ../../library/codecs.rst:1149
msgid "windows-1255"
msgstr "windows-1255"

#: ../../library/codecs.rst:1151
msgid "cp1256"
msgstr "cp1256"

#: ../../library/codecs.rst:1151
msgid "windows-1256"
msgstr "windows-1256"

#: ../../library/codecs.rst:1153
msgid "cp1257"
msgstr "cp1257"

#: ../../library/codecs.rst:1153
msgid "windows-1257"
msgstr "windows-1257"

#: ../../library/codecs.rst:1155
msgid "cp1258"
msgstr "cp1258"

#: ../../library/codecs.rst:1155
msgid "windows-1258"
msgstr "windows-1258"

#: ../../library/codecs.rst:1155
msgid "Vietnamese"
msgstr "Vietnamesisk"

#: ../../library/codecs.rst:1157
msgid "euc_jp"
msgstr "euc_jp"

#: ../../library/codecs.rst:1157
msgid "eucjp, ujis, u-jis"
msgstr "eucjp, ujis, u-jis"

#: ../../library/codecs.rst:1159
msgid "euc_jis_2004"
msgstr "euc_jis_2004"

#: ../../library/codecs.rst:1159
msgid "jisx0213, eucjis2004"
msgstr "jisx0213, eucjis2004"

#: ../../library/codecs.rst:1161
msgid "euc_jisx0213"
msgstr "euc_jisx0213"

#: ../../library/codecs.rst:1161
msgid "eucjisx0213"
msgstr "eucjisx0213"

#: ../../library/codecs.rst:1163
msgid "euc_kr"
msgstr "euc_kr"

#: ../../library/codecs.rst:1163
msgid "euckr, korean, ksc5601, ks_c-5601, ks_c-5601-1987, ksx1001, ks_x-1001"
msgstr ""
"euckr, koreanska, ksc5601, ks_c-5601, ks_c-5601-1987, ksx1001, ks_x-1001"

#: ../../library/codecs.rst:1167
msgid "gb2312"
msgstr "gb2312"

#: ../../library/codecs.rst:1167
msgid ""
"chinese, csiso58gb231280, euc-cn, euccn, eucgb2312-cn, gb2312-1980, "
"gb2312-80, iso-ir-58"
msgstr ""
"kinesiska, csiso58gb231280, euc-cn, euccn, eucgb2312-cn, gb2312-1980, "
"gb2312-80, iso-ir-58"

#: ../../library/codecs.rst:1167 ../../library/codecs.rst:1176
msgid "Simplified Chinese"
msgstr "Förenklad kinesiska"

#: ../../library/codecs.rst:1172
msgid "gbk"
msgstr "gbk"

#: ../../library/codecs.rst:1172
msgid "936, cp936, ms936"
msgstr "936, cp936, ms936"

#: ../../library/codecs.rst:1172 ../../library/codecs.rst:1174
msgid "Unified Chinese"
msgstr "Unifierad kinesiska"

#: ../../library/codecs.rst:1174
msgid "gb18030"
msgstr "gb18030"

#: ../../library/codecs.rst:1174
msgid "gb18030-2000"
msgstr "gb18030-2000"

#: ../../library/codecs.rst:1176
msgid "hz"
msgstr "hz"

#: ../../library/codecs.rst:1176
msgid "hzgb, hz-gb, hz-gb-2312"
msgstr "hzgb, hz-gb, hz-gb-2312"

#: ../../library/codecs.rst:1178
msgid "iso2022_jp"
msgstr "iso2022_jp"

#: ../../library/codecs.rst:1178
msgid "csiso2022jp, iso2022jp, iso-2022-jp"
msgstr "csiso2022jp, iso2022jp, iso-2022-jp"

#: ../../library/codecs.rst:1181
msgid "iso2022_jp_1"
msgstr "iso2022_jp_1"

#: ../../library/codecs.rst:1181
msgid "iso2022jp-1, iso-2022-jp-1"
msgstr "iso2022jp-1, iso-2022-jp-1"

#: ../../library/codecs.rst:1183
msgid "iso2022_jp_2"
msgstr "iso2022_jp_2"

#: ../../library/codecs.rst:1183
msgid "iso2022jp-2, iso-2022-jp-2"
msgstr "iso2022jp-2, iso-2022-jp-2"

#: ../../library/codecs.rst:1183
msgid "Japanese, Korean, Simplified Chinese, Western Europe, Greek"
msgstr "Japanska, koreanska, förenklad kinesiska, Västeuropa, grekiska"

#: ../../library/codecs.rst:1186
msgid "iso2022_jp_2004"
msgstr "iso2022_jp_2004"

#: ../../library/codecs.rst:1186
msgid "iso2022jp-2004, iso-2022-jp-2004"
msgstr "iso2022jp-2004, iso-2022-jp-2004"

#: ../../library/codecs.rst:1189
msgid "iso2022_jp_3"
msgstr "iso2022_jp_3"

#: ../../library/codecs.rst:1189
msgid "iso2022jp-3, iso-2022-jp-3"
msgstr "iso2022jp-3, iso-2022-jp-3"

#: ../../library/codecs.rst:1191
msgid "iso2022_jp_ext"
msgstr "iso2022_jp_ext"

#: ../../library/codecs.rst:1191
msgid "iso2022jp-ext, iso-2022-jp-ext"
msgstr "iso2022jp-ext, iso-2022-jp-ext"

#: ../../library/codecs.rst:1193
msgid "iso2022_kr"
msgstr "iso2022_kr"

#: ../../library/codecs.rst:1193
msgid "csiso2022kr, iso2022kr, iso-2022-kr"
msgstr "csiso2022kr, iso2022kr, iso-2022-kr"

#: ../../library/codecs.rst:1196
msgid "latin_1"
msgstr "latin_1"

#: ../../library/codecs.rst:1196
msgid "iso-8859-1, iso8859-1, 8859, cp819, latin, latin1, L1"
msgstr "iso-8859-1, iso8859-1, 8859, cp819, latin, latin1, L1"

#: ../../library/codecs.rst:1199
msgid "iso8859_2"
msgstr "iso8859_2"

#: ../../library/codecs.rst:1199
msgid "iso-8859-2, latin2, L2"
msgstr "iso-8859-2, latin2, L2"

#: ../../library/codecs.rst:1201
msgid "iso8859_3"
msgstr "iso8859_3"

#: ../../library/codecs.rst:1201
msgid "iso-8859-3, latin3, L3"
msgstr "iso-8859-3, latin3, L3"

#: ../../library/codecs.rst:1201
msgid "Esperanto, Maltese"
msgstr "Esperanto, Maltese"

#: ../../library/codecs.rst:1203
msgid "iso8859_4"
msgstr "iso8859_4"

#: ../../library/codecs.rst:1203
msgid "iso-8859-4, latin4, L4"
msgstr "iso-8859-4, latin4, L4"

#: ../../library/codecs.rst:1205
msgid "iso8859_5"
msgstr "iso8859_5"

#: ../../library/codecs.rst:1205
msgid "iso-8859-5, cyrillic"
msgstr "iso-8859-5, cyrillic"

#: ../../library/codecs.rst:1208
msgid "iso8859_6"
msgstr "iso8859_6"

#: ../../library/codecs.rst:1208
msgid "iso-8859-6, arabic"
msgstr "iso-8859-6, arabic"

#: ../../library/codecs.rst:1210
msgid "iso8859_7"
msgstr "iso8859_7"

#: ../../library/codecs.rst:1210
msgid "iso-8859-7, greek, greek8"
msgstr "iso-8859-7, greek, greek8"

#: ../../library/codecs.rst:1212
msgid "iso8859_8"
msgstr "iso8859_8"

#: ../../library/codecs.rst:1212
msgid "iso-8859-8, hebrew"
msgstr "iso-8859-8, hebrew"

#: ../../library/codecs.rst:1214
msgid "iso8859_9"
msgstr "iso8859_9"

#: ../../library/codecs.rst:1214
msgid "iso-8859-9, latin5, L5"
msgstr "iso-8859-9, latin5, L5"

#: ../../library/codecs.rst:1216
msgid "iso8859_10"
msgstr "iso8859_10"

#: ../../library/codecs.rst:1216
msgid "iso-8859-10, latin6, L6"
msgstr "iso-8859-10, latin6, L6"

#: ../../library/codecs.rst:1216
msgid "Nordic languages"
msgstr "Nordiska språk"

#: ../../library/codecs.rst:1218
msgid "iso8859_11"
msgstr "iso8859_11"

#: ../../library/codecs.rst:1218
msgid "iso-8859-11, thai"
msgstr "iso-8859-11, thai"

#: ../../library/codecs.rst:1218
msgid "Thai languages"
msgstr "Thailändska språk"

#: ../../library/codecs.rst:1220
msgid "iso8859_13"
msgstr "iso8859_13"

#: ../../library/codecs.rst:1220
msgid "iso-8859-13, latin7, L7"
msgstr "iso-8859-13, latin7, L7"

#: ../../library/codecs.rst:1222
msgid "iso8859_14"
msgstr "iso8859_14"

#: ../../library/codecs.rst:1222
msgid "iso-8859-14, latin8, L8"
msgstr "iso-8859-14, latin8, L8"

#: ../../library/codecs.rst:1222
msgid "Celtic languages"
msgstr "Keltiska språk"

#: ../../library/codecs.rst:1224
msgid "iso8859_15"
msgstr "iso8859_15"

#: ../../library/codecs.rst:1224
msgid "iso-8859-15, latin9, L9"
msgstr "iso-8859-15, latin9, L9"

#: ../../library/codecs.rst:1226
msgid "iso8859_16"
msgstr "iso8859_16"

#: ../../library/codecs.rst:1226
msgid "iso-8859-16, latin10, L10"
msgstr "iso-8859-16, latin10, L10"

#: ../../library/codecs.rst:1226
msgid "South-Eastern Europe"
msgstr "Sydöstra Europa"

#: ../../library/codecs.rst:1228
msgid "johab"
msgstr "johab"

#: ../../library/codecs.rst:1228
msgid "cp1361, ms1361"
msgstr "cp1361, ms1361"

#: ../../library/codecs.rst:1230
msgid "koi8_r"
msgstr "koi8_r"

#: ../../library/codecs.rst:1232
msgid "koi8_t"
msgstr "koi8_t"

#: ../../library/codecs.rst:1232
msgid "Tajik"
msgstr "Tadzjikiska"

#: ../../library/codecs.rst:1236
msgid "koi8_u"
msgstr "koi8_u"

#: ../../library/codecs.rst:1238
msgid "kz1048"
msgstr "kz1048"

#: ../../library/codecs.rst:1238
msgid "kz_1048, strk1048_2002, rk1048"
msgstr "kz_1048, strk1048_2002, rk1048"

#: ../../library/codecs.rst:1238 ../../library/codecs.rst:1256
msgid "Kazakh"
msgstr "Kazakiskt"

#: ../../library/codecs.rst:1242
msgid "mac_cyrillic"
msgstr "mac_cyrillic"

#: ../../library/codecs.rst:1242
msgid "maccyrillic"
msgstr "maccyrillic"

#: ../../library/codecs.rst:1245
msgid "mac_greek"
msgstr "mac_greek"

#: ../../library/codecs.rst:1245
msgid "macgreek"
msgstr "macgreek"

#: ../../library/codecs.rst:1247
msgid "mac_iceland"
msgstr "mac_iceland"

#: ../../library/codecs.rst:1247
msgid "maciceland"
msgstr "maciceland"

#: ../../library/codecs.rst:1249
msgid "mac_latin2"
msgstr "mac_latin2"

#: ../../library/codecs.rst:1249
msgid "maclatin2, maccentraleurope, mac_centeuro"
msgstr "maclatin2, maccentraleurope, mac_centeuro"

#: ../../library/codecs.rst:1252
msgid "mac_roman"
msgstr "mac_roman"

#: ../../library/codecs.rst:1252
msgid "macroman, macintosh"
msgstr "macroman, macintosh"

#: ../../library/codecs.rst:1254
msgid "mac_turkish"
msgstr "mac_turkish"

#: ../../library/codecs.rst:1254
msgid "macturkish"
msgstr "macturkish"

#: ../../library/codecs.rst:1256
msgid "ptcp154"
msgstr "ptcp154"

#: ../../library/codecs.rst:1256
msgid "csptcp154, pt154, cp154, cyrillic-asian"
msgstr "csptcp154, pt154, cp154, cyrillic-asian"

#: ../../library/codecs.rst:1259
msgid "shift_jis"
msgstr "shift_jis"

#: ../../library/codecs.rst:1259
msgid "csshiftjis, shiftjis, sjis, s_jis"
msgstr "csshiftjis, shiftjis, sjis, s_jis"

#: ../../library/codecs.rst:1262
msgid "shift_jis_2004"
msgstr "shift_jis_2004"

#: ../../library/codecs.rst:1262
msgid "shiftjis2004, sjis_2004, sjis2004"
msgstr "shiftjis2004, sjis_2004, sjis2004"

#: ../../library/codecs.rst:1265
msgid "shift_jisx0213"
msgstr "shift_jisx0213"

#: ../../library/codecs.rst:1265
msgid "shiftjisx0213, sjisx0213, s_jisx0213"
msgstr "shiftjisx0213, sjisx0213, s_jisx0213"

#: ../../library/codecs.rst:1268
msgid "utf_32"
msgstr "utf_32"

#: ../../library/codecs.rst:1268
msgid "U32, utf32"
msgstr "U32, utf32"

#: ../../library/codecs.rst:1268 ../../library/codecs.rst:1270
#: ../../library/codecs.rst:1272 ../../library/codecs.rst:1274
#: ../../library/codecs.rst:1276 ../../library/codecs.rst:1278
#: ../../library/codecs.rst:1280 ../../library/codecs.rst:1282
#: ../../library/codecs.rst:1284
msgid "all languages"
msgstr "alla språk"

#: ../../library/codecs.rst:1270
msgid "utf_32_be"
msgstr "utf_32_be"

#: ../../library/codecs.rst:1270
msgid "UTF-32BE"
msgstr "UTF-32BE"

#: ../../library/codecs.rst:1272
msgid "utf_32_le"
msgstr "utf_32_le"

#: ../../library/codecs.rst:1272
msgid "UTF-32LE"
msgstr "UTF-32LE"

#: ../../library/codecs.rst:1274
msgid "utf_16"
msgstr "utf_16"

#: ../../library/codecs.rst:1274
msgid "U16, utf16"
msgstr "U16, utf16"

#: ../../library/codecs.rst:1276
msgid "utf_16_be"
msgstr "utf_16_be"

#: ../../library/codecs.rst:1276
msgid "UTF-16BE"
msgstr "UTF-16BE"

#: ../../library/codecs.rst:1278
msgid "utf_16_le"
msgstr "utf_16_le"

#: ../../library/codecs.rst:1278
msgid "UTF-16LE"
msgstr "UTF-16LE"

#: ../../library/codecs.rst:1280
msgid "utf_7"
msgstr "utf_7"

#: ../../library/codecs.rst:1280
msgid "U7, unicode-1-1-utf-7"
msgstr "U7, unicode-1-1-utf-7"

#: ../../library/codecs.rst:1282
msgid "utf_8"
msgstr "utf_8"

#: ../../library/codecs.rst:1282
msgid "U8, UTF, utf8, cp65001"
msgstr "U8, UTF, utf8, cp65001"

#: ../../library/codecs.rst:1284
msgid "utf_8_sig"
msgstr "utf_8_sig"

#: ../../library/codecs.rst:1287
msgid ""
"The utf-16\\* and utf-32\\* encoders no longer allow surrogate code points "
"(``U+D800``--``U+DFFF``) to be encoded. The utf-32\\* decoders no longer "
"decode byte sequences that correspond to surrogate code points."
msgstr ""
"Kodarna utf-16\\* och utf-32\\* tillåter inte längre att surrogatkodpunkter "
"(``U+D800``--``U+DFFF``) kodas. Avkodarna utf-32\\* avkodar inte längre "
"byte-sekvenser som motsvarar surrogatkodpunkter."

#: ../../library/codecs.rst:1293
msgid "``cp65001`` is now an alias to ``utf_8``."
msgstr "``cp65001`` är nu ett alias till ``utf_8``."

#: ../../library/codecs.rst:1298
msgid "Python Specific Encodings"
msgstr "Python-specifika kodningar"

#: ../../library/codecs.rst:1300
msgid ""
"A number of predefined codecs are specific to Python, so their codec names "
"have no meaning outside Python. These are listed in the tables below based "
"on the expected input and output types (note that while text encodings are "
"the most common use case for codecs, the underlying codec infrastructure "
"supports arbitrary data transforms rather than just text encodings). For "
"asymmetric codecs, the stated meaning describes the encoding direction."
msgstr ""
"Ett antal fördefinierade kodekar är specifika för Python, så deras kodek-"
"namn har ingen betydelse utanför Python. Dessa listas i tabellerna nedan "
"baserat på de förväntade in- och utdatatyperna (notera att även om "
"textkodningar är det vanligaste användningsområdet för kodekar, stöder den "
"underliggande kodek-infrastrukturen godtyckliga datatransformationer snarare"
" än bara textkodningar). För asymmetriska kodekar beskriver den angivna "
"betydelsen kodningsriktningen."

#: ../../library/codecs.rst:1308
msgid "Text Encodings"
msgstr "Kodning av text"

#: ../../library/codecs.rst:1310
msgid ""
"The following codecs provide :class:`str` to :class:`bytes` encoding and "
":term:`bytes-like object` to :class:`str` decoding, similar to the Unicode "
"text encodings."
msgstr ""
"Följande kodekar ger :class:`str` till :class:`bytes`-kodning och "
":term:`bytes-like object` till :class:`str`-avkodning, på samma sätt som "
"Unicodes textkodning."

#: ../../library/codecs.rst:1319
msgid "idna"
msgstr "idna"

#: ../../library/codecs.rst:1319
msgid ""
"Implement :rfc:`3490`, see also :mod:`encodings.idna`. Only "
"``errors='strict'`` is supported."
msgstr ""
"Implementera :rfc:`3490`, se även :mod:`encodings.idna`. Endast "
"``errors='strict'`` stöds."

#: ../../library/codecs.rst:1325
msgid "mbcs"
msgstr "mbcs"

#: ../../library/codecs.rst:1325
msgid "ansi, dbcs"
msgstr "ansi, dbcs"

#: ../../library/codecs.rst:1325
msgid ""
"Windows only: Encode the operand according to the ANSI codepage (CP_ACP)."
msgstr "Endast för Windows: Koda operanden enligt ANSI-kodsidan (CP_ACP)."

#: ../../library/codecs.rst:1329
msgid "oem"
msgstr "original"

#: ../../library/codecs.rst:1329
msgid ""
"Windows only: Encode the operand according to the OEM codepage (CP_OEMCP)."
msgstr "Endast för Windows: Koda operanden enligt OEM-kodsidan (CP_OEMCP)."

#: ../../library/codecs.rst:1335
msgid "palmos"
msgstr "palmos"

#: ../../library/codecs.rst:1335
msgid "Encoding of PalmOS 3.5."
msgstr "Kodning av PalmOS 3.5."

#: ../../library/codecs.rst:1337
msgid "punycode"
msgstr "punycode"

#: ../../library/codecs.rst:1337
msgid "Implement :rfc:`3492`. Stateful codecs are not supported."
msgstr "Implementera :rfc:`3492`. Stateful kodekar stöds inte."

#: ../../library/codecs.rst:1341
msgid "raw_unicode_escape"
msgstr "raw_unicode_escape"

#: ../../library/codecs.rst:1341
msgid ""
"Latin-1 encoding with ``\\uXXXX`` and ``\\UXXXXXXXX`` for other code points."
" Existing backslashes are not escaped in any way. It is used in the Python "
"pickle protocol."
msgstr ""

#: ../../library/codecs.rst:1350
msgid "undefined"
msgstr "odefinerad"

#: ../../library/codecs.rst:1350
msgid ""
"Raise an exception for all conversions, even empty strings. The error "
"handler is ignored."
msgstr ""
"Utlös ett undantag för alla konverteringar, även tomma strängar. "
"Felhanteraren ignoreras."

#: ../../library/codecs.rst:1355
msgid "unicode_escape"
msgstr "unicode_escape"

#: ../../library/codecs.rst:1355
msgid ""
"Encoding suitable as the contents of a Unicode literal in ASCII-encoded "
"Python source code, except that quotes are not escaped. Decode from Latin-1 "
"source code. Beware that Python source code actually uses UTF-8 by default."
msgstr ""
"Kodning lämplig som innehållet i en Unicode-litteral i ASCII-kodad Python-"
"källkod, förutom att citattecken inte escapas. Avkodning från "
"Latin-1-källkod. Tänk på att Python-källkod faktiskt använder UTF-8 som "
"standard."

#: ../../library/codecs.rst:1367
msgid "\"unicode_internal\" codec is removed."
msgstr "kodek \"unicode_internal\" har tagits bort."

#: ../../library/codecs.rst:1374
msgid "Binary Transforms"
msgstr "Binära transformationer"

#: ../../library/codecs.rst:1376
msgid ""
"The following codecs provide binary transforms: :term:`bytes-like object` to"
" :class:`bytes` mappings. They are not supported by :meth:`bytes.decode` "
"(which only produces :class:`str` output)."
msgstr ""
"Följande kodekar tillhandahåller binära transformationer: :term:`bytes-like "
"object` till :class:`bytes` mappningar. De stöds inte av "
":meth:`bytes.decode` (som endast producerar :class:`str` utdata)."

#: ../../library/codecs.rst:1384
msgid "Encoder / decoder"
msgstr "Kodare / avkodare"

#: ../../library/codecs.rst:1386
msgid "base64_codec [#b64]_"
msgstr "base64_codec [#b64]_"

#: ../../library/codecs.rst:1386
msgid "base64, base_64"
msgstr "base64, base_64"

#: ../../library/codecs.rst:1386
msgid ""
"Convert the operand to multiline MIME base64 (the result always includes a "
"trailing ``'\\n'``)."
msgstr ""
"Konverterar operanden till multiline MIME base64 (resultatet innehåller "
"alltid en efterföljande ``'\\n'``)."

#: ../../library/codecs.rst:1391
msgid ""
"accepts any :term:`bytes-like object` as input for encoding and decoding"
msgstr ""
"accepterar alla :term:`bytes-like object` som indata för kodning och "
"avkodning"

#: ../../library/codecs.rst:1386
msgid ":meth:`base64.encodebytes` / :meth:`base64.decodebytes`"
msgstr ":meth:`base64.encodebytes` / :meth:`base64.decodebytes`"

#: ../../library/codecs.rst:1397
msgid "bz2_codec"
msgstr "bz2_codec"

#: ../../library/codecs.rst:1397
msgid "bz2"
msgstr "bz2"

#: ../../library/codecs.rst:1397
msgid "Compress the operand using bz2."
msgstr "Komprimera operanden med hjälp av bz2."

#: ../../library/codecs.rst:1397
msgid ":meth:`bz2.compress` / :meth:`bz2.decompress`"
msgstr ":meth:`bz2.compress` / :meth:`bz2.decompress`"

#: ../../library/codecs.rst:1400
msgid "hex_codec"
msgstr "hex_codec"

#: ../../library/codecs.rst:1400
msgid "hex"
msgstr "hex"

#: ../../library/codecs.rst:1400
msgid ""
"Convert the operand to hexadecimal representation, with two digits per byte."
msgstr ""
"Konvertera operanden till hexadecimal representation, med två siffror per "
"byte."

#: ../../library/codecs.rst:1400
msgid ":meth:`binascii.b2a_hex` / :meth:`binascii.a2b_hex`"
msgstr ":meth:`binascii.b2a_hex` / :meth:`binascii.a2b_hex`"

#: ../../library/codecs.rst:1405
msgid "quopri_codec"
msgstr "quopri_codec"

#: ../../library/codecs.rst:1405
msgid "quopri, quotedprintable, quoted_printable"
msgstr "quopri, citerat tryckbart, citerat_tryckbart"

#: ../../library/codecs.rst:1405
msgid "Convert the operand to MIME quoted printable."
msgstr "Konvertera operanden till MIME quoted printable."

#: ../../library/codecs.rst:1405
msgid ":meth:`quopri.encode` with ``quotetabs=True`` / :meth:`quopri.decode`"
msgstr ":meth:`quopri.encode` med ``quotetabs=True`` / :meth:`quopri.decode`"

#: ../../library/codecs.rst:1409
msgid "uu_codec"
msgstr "uu_codec"

#: ../../library/codecs.rst:1409
msgid "uu"
msgstr "uu"

#: ../../library/codecs.rst:1409
msgid "Convert the operand using uuencode."
msgstr "Konvertera operanden med hjälp av uuencode."

#: ../../library/codecs.rst:1409
msgid ":meth:`uu.encode` / :meth:`uu.decode`"
msgstr ""

#: ../../library/codecs.rst:1412
msgid "zlib_codec"
msgstr "zlib_codec"

#: ../../library/codecs.rst:1412
msgid "zip, zlib"
msgstr "zip, zlib"

#: ../../library/codecs.rst:1412
msgid "Compress the operand using gzip."
msgstr "Komprimera operanden med hjälp av gzip."

#: ../../library/codecs.rst:1412
msgid ":meth:`zlib.compress` / :meth:`zlib.decompress`"
msgstr ":meth:`zlib.compress` / :meth:`zlib.decompress`"

#: ../../library/codecs.rst:1416
msgid ""
"In addition to :term:`bytes-like objects <bytes-like object>`, "
"``'base64_codec'`` also accepts ASCII-only instances of :class:`str` for "
"decoding"
msgstr ""
"Förutom :term:`bytesliknande objekt <bytes-like object>` accepterar "
"``'base64_codec'`` även ASCII-instanser av :class:`str` för avkodning"

#: ../../library/codecs.rst:1420
msgid "Restoration of the binary transforms."
msgstr "Återställning av de binära transformationerna."

#: ../../library/codecs.rst:1423
msgid "Restoration of the aliases for the binary transforms."
msgstr "Återställande av alias för de binära transformationerna."

#: ../../library/codecs.rst:1430
msgid "Text Transforms"
msgstr "Text omvandlas"

#: ../../library/codecs.rst:1432
msgid ""
"The following codec provides a text transform: a :class:`str` to "
":class:`str` mapping. It is not supported by :meth:`str.encode` (which only "
"produces :class:`bytes` output)."
msgstr ""
"Följande kodek tillhandahåller en texttransformation: en mappning från "
":class:`str` till :class:`str`. Den stöds inte av :meth:`str.encode` (som "
"bara producerar :class:`bytes`)."

#: ../../library/codecs.rst:1441
msgid "rot_13"
msgstr "rot_13"

#: ../../library/codecs.rst:1441
msgid "rot13"
msgstr "rot13"

#: ../../library/codecs.rst:1441
msgid "Return the Caesar-cypher encryption of the operand."
msgstr "Returnerar Caesar-cypherkrypteringen av operanden."

#: ../../library/codecs.rst:1446
msgid "Restoration of the ``rot_13`` text transform."
msgstr "Återställande av textomvandlingen ``rot_13``."

#: ../../library/codecs.rst:1449
msgid "Restoration of the ``rot13`` alias."
msgstr "Återskapande av aliaset ``rot13``."

#: ../../library/codecs.rst:1454
msgid ""
":mod:`encodings.idna` --- Internationalized Domain Names in Applications"
msgstr ""
":mod:`encodings.idna` --- Internationaliserade domännamn i applikationer"

#: ../../library/codecs.rst:1460
msgid ""
"This module implements :rfc:`3490` (Internationalized Domain Names in "
"Applications) and :rfc:`3492` (Nameprep: A Stringprep Profile for "
"Internationalized Domain Names (IDN)). It builds upon the ``punycode`` "
"encoding and :mod:`stringprep`."
msgstr ""
"Denna modul implementerar :rfc:`3490` (Internationalized Domain Names in "
"Applications) och :rfc:`3492` (Nameprep: En strängprep-profil för "
"internationaliserade domännamn (IDN)). Den bygger på kodningen ``punycode`` "
"och :mod:`stringprep`."

#: ../../library/codecs.rst:1465
msgid ""
"If you need the IDNA 2008 standard from :rfc:`5891` and :rfc:`5895`, use the"
" third-party `idna module <https://pypi.org/project/idna/>`_."
msgstr ""

#: ../../library/codecs.rst:1468
msgid ""
"These RFCs together define a protocol to support non-ASCII characters in "
"domain names. A domain name containing non-ASCII characters (such as "
"``www.Alliancefrançaise.nu``) is converted into an ASCII-compatible encoding"
" (ACE, such as ``www.xn--alliancefranaise-npb.nu``). The ACE form of the "
"domain name is then used in all places where arbitrary characters are not "
"allowed by the protocol, such as DNS queries, HTTP :mailheader:`Host` "
"fields, and so on. This conversion is carried out in the application; if "
"possible invisible to the user: The application should transparently convert"
" Unicode domain labels to IDNA on the wire, and convert back ACE labels to "
"Unicode before presenting them to the user."
msgstr ""
"Dessa RFC:er definierar tillsammans ett protokoll för att stödja icke-ASCII-"
"tecken i domännamn. Ett domännamn som innehåller icke-ASCII-tecken (t.ex. "
"``www.Alliancefrançaise.nu``) konverteras till en ASCII-kompatibel kodning "
"(ACE, t.ex. ``www.xn--alliancefranaise-npb.nu``). ACE-formen av domännamnet "
"används sedan på alla ställen där godtyckliga tecken inte tillåts av "
"protokollet, t.ex. DNS-frågor, HTTP :mailheader:`Host`-fält och så vidare. "
"Denna konvertering utförs i applikationen och är om möjligt osynlig för "
"användaren: Programmet bör på ett transparent sätt konvertera Unicode-"
"domänetiketter till IDNA på kabeln och konvertera tillbaka ACE-etiketter "
"till Unicode innan de presenteras för användaren."

#: ../../library/codecs.rst:1479
msgid ""
"Python supports this conversion in several ways:  the ``idna`` codec "
"performs conversion between Unicode and ACE, separating an input string into"
" labels based on the separator characters defined in :rfc:`section 3.1 of "
"RFC 3490 <3490#section-3.1>` and converting each label to ACE as required, "
"and conversely separating an input byte string into labels based on the "
"``.`` separator and converting any ACE labels found into unicode. "
"Furthermore, the :mod:`socket` module transparently converts Unicode host "
"names to ACE, so that applications need not be concerned about converting "
"host names themselves when they pass them to the socket module. On top of "
"that, modules that have host names as function parameters, such as "
":mod:`http.client` and :mod:`ftplib`, accept Unicode host names "
"(:mod:`http.client` then also transparently sends an IDNA hostname in the "
":mailheader:`Host` field if it sends that field at all)."
msgstr ""
"Python stöder denna konvertering på flera sätt: kodeken ``idna`` utför "
"konvertering mellan Unicode och ACE, separerar en inmatningssträng i "
"etiketter baserat på de separatortecken som definieras i :rfc:`section 3.1 "
"of RFC 3490 <3490#section-3.1>` och konverterar varje etikett till ACE efter"
" behov, och omvänt separerar en inmatad bytesträng i etiketter baserat på "
"separatorn ``.`` och konverterar alla ACE-etiketter som hittas till Unicode."
" Modulen :mod:`socket` konverterar dessutom Unicode-värdnamn till ACE på ett"
" transparent sätt, så att program inte behöver bekymra sig om att konvertera"
" värdnamn själva när de skickar dem till socket-modulen. Dessutom accepterar"
" moduler som har värdnamn som funktionsparametrar, t.ex. :mod:`http.client` "
"och :mod:`ftplib`, Unicode-värdnamn (:mod:`http.client` skickar då också på "
"ett transparent sätt ett IDNA-värdnamn i fältet :mailheader:`Host` om den "
"alls skickar det fältet)."

#: ../../library/codecs.rst:1492
msgid ""
"When receiving host names from the wire (such as in reverse name lookup), no"
" automatic conversion to Unicode is performed: applications wishing to "
"present such host names to the user should decode them to Unicode."
msgstr ""
"När värdnamn tas emot från kabeln (t.ex. vid omvänd namnuppslagning) sker "
"ingen automatisk konvertering till Unicode: program som vill presentera "
"sådana värdnamn för användaren måste avkoda dem till Unicode."

#: ../../library/codecs.rst:1496
msgid ""
"The module :mod:`encodings.idna` also implements the nameprep procedure, "
"which performs certain normalizations on host names, to achieve case-"
"insensitivity of international domain names, and to unify similar "
"characters. The nameprep functions can be used directly if desired."
msgstr ""
"Modulen :mod:`encodings.idna` implementerar också nameprep-proceduren, som "
"utför vissa normaliseringar på värdnamn, för att uppnå skiftlägesokänslighet"
" för internationella domännamn och för att förena liknande tecken. Nameprep-"
"funktionerna kan användas direkt om så önskas."

#: ../../library/codecs.rst:1504
msgid ""
"Return the nameprepped version of *label*. The implementation currently "
"assumes query strings, so ``AllowUnassigned`` is true."
msgstr ""
"Returnerar den namnpreppade versionen av *label*. Implementationen "
"förutsätter för närvarande frågesträngar, så ``AllowUnassigned`` är sant."

#: ../../library/codecs.rst:1510
msgid ""
"Convert a label to ASCII, as specified in :rfc:`3490`. ``UseSTD3ASCIIRules``"
" is assumed to be false."
msgstr ""
"Konverterar en etikett till ASCII, enligt specifikationen i :rfc:`3490`. "
"``UseSTD3ASCIIRules`` antas vara false."

#: ../../library/codecs.rst:1516
msgid "Convert a label to Unicode, as specified in :rfc:`3490`."
msgstr ""
"Konverterar en etikett till Unicode, enligt specifikationen i :rfc:`3490`."

#: ../../library/codecs.rst:1520
msgid ":mod:`encodings.mbcs` --- Windows ANSI codepage"
msgstr ":mod:`encodings.mbcs` --- Windows ANSI-kodning"

#: ../../library/codecs.rst:1525
msgid "This module implements the ANSI codepage (CP_ACP)."
msgstr "Denna modul implementerar ANSI-kodsidan (CP_ACP)."

#: ../../library/codecs.rst:1528
msgid ":ref:`Availability <availability>`: Windows only."
msgstr ""

#: ../../library/codecs.rst:1529
msgid "Support any error handler."
msgstr "Stödjer alla felhanterare."

#: ../../library/codecs.rst:1532
msgid ""
"Before 3.2, the *errors* argument was ignored; ``'replace'`` was always used"
" to encode, and ``'ignore'`` to decode."
msgstr ""
"Före 3.2 ignorerades argumentet *errors*; ``'replace'`` användes alltid för "
"kodning och ``'ignore'`` för avkodning."

#: ../../library/codecs.rst:1538
msgid ":mod:`encodings.utf_8_sig` --- UTF-8 codec with BOM signature"
msgstr ":mod:`encodings.utf_8_sig` --- UTF-8-kodek med BOM-signatur"

#: ../../library/codecs.rst:1544
msgid ""
"This module implements a variant of the UTF-8 codec. On encoding, a UTF-8 "
"encoded BOM will be prepended to the UTF-8 encoded bytes. For the stateful "
"encoder this is only done once (on the first write to the byte stream). On "
"decoding, an optional UTF-8 encoded BOM at the start of the data will be "
"skipped."
msgstr ""
"Denna modul implementerar en variant av UTF-8-kodek. Vid kodning kommer en "
"UTF-8-kodad BOM att prependlas till de UTF-8-kodade bytena. För den "
"stateful-kodaren görs detta endast en gång (vid den första skrivningen till "
"byteflödet). Vid avkodning kommer en valfri UTF-8-kodad BOM i början av "
"datan att hoppas över."
