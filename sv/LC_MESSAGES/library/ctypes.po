# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-17 15:05+0000\n"
"PO-Revision-Date: 2025-09-15 01:04+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../library/ctypes.rst:2
msgid ":mod:`!ctypes` --- A foreign function library for Python"
msgstr ":mod:`!ctypes` --- Ett bibliotek med främmande funktioner för Python"

#: ../../library/ctypes.rst:9
msgid "**Source code:** :source:`Lib/ctypes`"
msgstr "**Källkod:** :source:`Lib/ctypes`"

#: ../../library/ctypes.rst:13
msgid ""
":mod:`ctypes` is a foreign function library for Python.  It provides C "
"compatible data types, and allows calling functions in DLLs or shared "
"libraries.  It can be used to wrap these libraries in pure Python."
msgstr ""
":mod:`ctypes` är ett bibliotek med främmande funktioner för Python.  Det "
"tillhandahåller C-kompatibla datatyper och gör det möjligt att anropa "
"funktioner i DLL:er eller delade bibliotek.  Det kan användas för att "
"paketera dessa bibliotek i ren Python."

#: ../../library/ctypes.rst:21
msgid "ctypes tutorial"
msgstr "ctypes handledning"

#: ../../library/ctypes.rst:23
msgid ""
"Note: The code samples in this tutorial use :mod:`doctest` to make sure that "
"they actually work.  Since some code samples behave differently under Linux, "
"Windows, or macOS, they contain doctest directives in comments."
msgstr ""
"Observera: I kodproverna i den här handledningen används :mod:`doctest` för "
"att säkerställa att de faktiskt fungerar.  Eftersom vissa kodprover beter "
"sig olika under Linux, Windows eller macOS innehåller de doctest-direktiv i "
"kommentarerna."

#: ../../library/ctypes.rst:27
msgid ""
"Note: Some code samples reference the ctypes :class:`c_int` type.  On "
"platforms where ``sizeof(long) == sizeof(int)`` it is an alias to :class:"
"`c_long`. So, you should not be confused if :class:`c_long` is printed if "
"you would expect :class:`c_int` --- they are actually the same type."
msgstr ""
"Observera: I vissa kodexempel hänvisas till typen ctypes :class:`c_int`.  På "
"plattformar där ``sizeof(long) == sizeof(int)`` är det ett alias till :class:"
"`c_long`. Så du bör inte bli förvirrad om :class:`c_long` skrivs ut när du "
"förväntar dig :class:`c_int` --- de är faktiskt samma typ."

#: ../../library/ctypes.rst:35
msgid "Loading dynamic link libraries"
msgstr "Ladda dynamiska länkbibliotek"

#: ../../library/ctypes.rst:37
msgid ""
":mod:`ctypes` exports the *cdll*, and on Windows *windll* and *oledll* "
"objects, for loading dynamic link libraries."
msgstr ""
":mod:`ctypes` exporterar objekten *cdll*, och i Windows *windll* och "
"*oledll*, för laddning av dynamiska länkbibliotek."

#: ../../library/ctypes.rst:40
msgid ""
"You load libraries by accessing them as attributes of these objects. *cdll* "
"loads libraries which export functions using the standard ``cdecl`` calling "
"convention, while *windll* libraries call functions using the ``stdcall`` "
"calling convention. *oledll* also uses the ``stdcall`` calling convention, "
"and assumes the functions return a Windows :c:type:`!HRESULT` error code. "
"The error code is used to automatically raise an :class:`OSError` exception "
"when the function call fails."
msgstr ""
"Du laddar bibliotek genom att komma åt dem som attribut till dessa objekt. "
"*cdll* laddar bibliotek som exporterar funktioner med hjälp av "
"standardkonventionen ``cdecl``, medan *windll*-bibliotek anropar funktioner "
"med hjälp av konventionen ``stdcall``. *oledll* använder också "
"anropskonventionen ``stdcall`` och antar att funktionerna returnerar en "
"Windows :c:type:`!HRESULT`-felkod. Felkoden används för att automatiskt "
"skapa ett :class:`OSError`-undantag när funktionsanropet misslyckas."

#: ../../library/ctypes.rst:48
msgid ""
"Windows errors used to raise :exc:`WindowsError`, which is now an alias of :"
"exc:`OSError`."
msgstr ""
"Windows-fel gav tidigare upphov till :exc:`WindowsError`, som nu är ett "
"alias för :exc:`OSError`."

#: ../../library/ctypes.rst:53
msgid ""
"Here are some examples for Windows. Note that ``msvcrt`` is the MS standard "
"C library containing most standard C functions, and uses the ``cdecl`` "
"calling convention::"
msgstr ""
"Här är några exempel för Windows. Observera att ``msvcrt`` är MS standard C-"
"bibliotek som innehåller de flesta standard C-funktioner och använder "
"``cdecl`` anropskonventionen::"

#: ../../library/ctypes.rst:57
msgid ""
">>> from ctypes import *\n"
">>> print(windll.kernel32)\n"
"<WinDLL 'kernel32', handle ... at ...>\n"
">>> print(cdll.msvcrt)\n"
"<CDLL 'msvcrt', handle ... at ...>\n"
">>> libc = cdll.msvcrt\n"
">>>"
msgstr ""
">>> från ctypes import *\n"
">>> print(windll.kernel32)\n"
"<WinDLL 'kernel32', handtag ... vid ...> >>> print(windll msvcrt)\n"
">>> print(cdll.msvcrt)\n"
"<CDLL 'msvcrt', handtag ... vid ...>\n"
">>> libc = cdll.msvcrt\n"
">>>"

#: ../../library/ctypes.rst:65
msgid "Windows appends the usual ``.dll`` file suffix automatically."
msgstr "Windows lägger till det vanliga filsuffixet ``.dll`` automatiskt."

#: ../../library/ctypes.rst:68
msgid ""
"Accessing the standard C library through ``cdll.msvcrt`` will use an "
"outdated version of the library that may be incompatible with the one being "
"used by Python. Where possible, use native Python functionality, or else "
"import and use the ``msvcrt`` module."
msgstr ""
"Om du använder standard C-biblioteket via ``cdll.msvcrt`` kommer du att "
"använda en föråldrad version av biblioteket som kan vara inkompatibel med "
"den som används av Python. Där det är möjligt, använd Pythons inbyggda "
"funktionalitet, eller importera och använd modulen ``msvcrt``."

#: ../../library/ctypes.rst:73
msgid ""
"On Linux, it is required to specify the filename *including* the extension "
"to load a library, so attribute access can not be used to load libraries. "
"Either the :meth:`~LibraryLoader.LoadLibrary` method of the dll loaders "
"should be used, or you should load the library by creating an instance of "
"CDLL by calling the constructor::"
msgstr ""
"Under Linux måste filnamnet *inklusive* tillägget anges för att ladda ett "
"bibliotek, så attributåtkomst kan inte användas för att ladda bibliotek. "
"Antingen bör metoden :meth:`~LibraryLoader.LoadLibrary` i dll-laddarna "
"användas, eller så bör du ladda biblioteket genom att skapa en instans av "
"CDLL genom att anropa konstruktören::"

#: ../../library/ctypes.rst:79
msgid ""
">>> cdll.LoadLibrary(\"libc.so.6\")\n"
"<CDLL 'libc.so.6', handle ... at ...>\n"
">>> libc = CDLL(\"libc.so.6\")\n"
">>> libc\n"
"<CDLL 'libc.so.6', handle ... at ...>\n"
">>>"
msgstr ""
">>> cdll.LoadLibrary(\"libc.so.6\")\n"
"<CDLL 'libc.so.6', handtag ... vid ...> >>> libc = CDLL(\"libc.so.6\")\n"
">>> libc = CDLL(\"libc.so.6\")\n"
">>> libc\n"
"<CDLL 'libc.so.6', handtag ... vid ...>\n"
">>>"

#: ../../library/ctypes.rst:92
msgid "Accessing functions from loaded dlls"
msgstr "Åtkomst till funktioner från inlästa dll-filer"

#: ../../library/ctypes.rst:94
msgid "Functions are accessed as attributes of dll objects::"
msgstr "Funktioner är åtkomliga som attribut till dll-objekt::"

#: ../../library/ctypes.rst:96
msgid ""
">>> libc.printf\n"
"<_FuncPtr object at 0x...>\n"
">>> print(windll.kernel32.GetModuleHandleA)\n"
"<_FuncPtr object at 0x...>\n"
">>> print(windll.kernel32.MyOwnFunction)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"ctypes.py\", line 239, in __getattr__\n"
"    func = _StdcallFuncPtr(name, self)\n"
"AttributeError: function 'MyOwnFunction' not found\n"
">>>"
msgstr ""
"&gt;&gt;&gt; libc.printf\n"
"<_FuncPtr object at 0x...>\n"
"&gt;&gt;&gt; print(windll.kernel32.GetModuleHandleA)\n"
"<_FuncPtr object at 0x...>\n"
"&gt;&gt;&gt; Skriv ut(windll.kernel32.MyOwnFunction)\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"  Fil \"ctypes.py\", rad 239, i __getattr__\n"
"    func = _StdcallFuncPtr(namn, self)\n"
"AttributeError: funktionen 'MyOwnFunction' hittades inte\n"
"&gt;&gt;&gt"

#: ../../library/ctypes.rst:108
msgid ""
"Note that win32 system dlls like ``kernel32`` and ``user32`` often export "
"ANSI as well as UNICODE versions of a function. The UNICODE version is "
"exported with a ``W`` appended to the name, while the ANSI version is "
"exported with an ``A`` appended to the name. The win32 ``GetModuleHandle`` "
"function, which returns a *module handle* for a given module name, has the "
"following C prototype, and a macro is used to expose one of them as "
"``GetModuleHandle`` depending on whether UNICODE is defined or not::"
msgstr ""
"Observera att Win32-systemdLL:er som ``kernel32`` och ``user32`` ofta "
"exporterar både ANSI- och UNICODE-versioner av en funktion. UNICODE-"
"versionen exporteras med ``W`` som tillägg till namnet, medan ANSI-versionen "
"exporteras med ``A`` som tillägg till namnet. Win32-funktionen "
"``GetModuleHandle``, som returnerar ett *modulhandtag* för ett givet "
"modulnamn, har följande C-prototyp, och ett makro används för att exponera "
"en av dem som ``GetModuleHandle`` beroende på om UNICODE är definierat eller "
"inte::"

#: ../../library/ctypes.rst:116
msgid ""
"/* ANSI version */\n"
"HMODULE GetModuleHandleA(LPCSTR lpModuleName);\n"
"/* UNICODE version */\n"
"HMODULE GetModuleHandleW(LPCWSTR lpModuleName);"
msgstr ""
"/* ANSI-version */\n"
"HMODULE GetModuleHandleA(LPCSTR lpModuleName);\n"
"/* UNICODE-version */\n"
"HMODULE GetModuleHandleW(LPCWSTR lpModuleName);"

#: ../../library/ctypes.rst:121
msgid ""
"*windll* does not try to select one of them by magic, you must access the "
"version you need by specifying ``GetModuleHandleA`` or ``GetModuleHandleW`` "
"explicitly, and then call it with bytes or string objects respectively."
msgstr ""
"*windll* försöker inte välja en av dem med magi, du måste komma åt den "
"version du behöver genom att ange ``GetModuleHandleA`` eller "
"``GetModuleHandleW`` uttryckligen, och sedan anropa den med bytes- "
"respektive strängobjekt."

#: ../../library/ctypes.rst:125
msgid ""
"Sometimes, dlls export functions with names which aren't valid Python "
"identifiers, like ``\"??2@YAPAXI@Z\"``. In this case you have to use :func:"
"`getattr` to retrieve the function::"
msgstr ""
"Ibland exporterar dll-filer funktioner med namn som inte är giltiga Python-"
"identifierare, som ``\"??2@YAPAXI@Z\"``. I det här fallet måste du använda :"
"func:`getattr` för att hämta funktionen::"

#: ../../library/ctypes.rst:129
msgid ""
">>> getattr(cdll.msvcrt, \"??2@YAPAXI@Z\")\n"
"<_FuncPtr object at 0x...>\n"
">>>"
msgstr ""
">>> getattr(cdll.msvcrt, \"??2@YAPAXI@Z\")\n"
"<_FuncPtr-objekt på 0x ...>\n"
">>>"

#: ../../library/ctypes.rst:133
msgid ""
"On Windows, some dlls export functions not by name but by ordinal. These "
"functions can be accessed by indexing the dll object with the ordinal "
"number::"
msgstr ""
"I Windows exporterar vissa dll-filer funktioner inte efter namn utan efter "
"ordinal. Dessa funktioner kan nås genom att indexera dll-objektet med "
"ordinalnumret::"

#: ../../library/ctypes.rst:136
msgid ""
">>> cdll.kernel32[1]\n"
"<_FuncPtr object at 0x...>\n"
">>> cdll.kernel32[0]\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"ctypes.py\", line 310, in __getitem__\n"
"    func = _StdcallFuncPtr(name, self)\n"
"AttributeError: function ordinal 0 not found\n"
">>>"
msgstr ""
"&gt;&gt;&gt; cdll.kernel32[1]\n"
"<_FuncPtr object at 0x...>\n"
"&gt;&gt;&gt; cdll.kernel32[0]\n"
"Återkoppling (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"  Fil \"ctypes.py\", rad 310, i __getitem__\n"
"    func = _StdcallFuncPtr(namn, self)\n"
"AttributeError: funktionen ordinal 0 hittades inte\n"
"&gt;&gt;&gt"

#: ../../library/ctypes.rst:150
msgid "Calling functions"
msgstr "Anropsfunktioner"

#: ../../library/ctypes.rst:152
msgid ""
"You can call these functions like any other Python callable. This example "
"uses the ``rand()`` function, which takes no arguments and returns a pseudo-"
"random integer::"
msgstr ""
"Du kan anropa dessa funktioner som alla andra Python-anropbara funktioner. I "
"det här exemplet används funktionen ``rand()``, som inte tar några argument "
"och returnerar ett pseudoslumpmässigt heltal::"

#: ../../library/ctypes.rst:155
msgid ""
">>> print(libc.rand())\n"
"1804289383"
msgstr ""
">>> print(libc.rand())\n"
"1804289383"

#: ../../library/ctypes.rst:158
msgid ""
"On Windows, you can call the ``GetModuleHandleA()`` function, which returns "
"a win32 module handle (passing ``None`` as single argument to call it with a "
"``NULL`` pointer)::"
msgstr ""
"I Windows kan du anropa funktionen ``GetModuleHandleA()``, som returnerar "
"ett win32-modulhandtag (genom att ange ``None`` som enda argument kan du "
"anropa den med en ``NULL``-pekare)::"

#: ../../library/ctypes.rst:161
msgid ""
">>> print(hex(windll.kernel32.GetModuleHandleA(None)))\n"
"0x1d000000\n"
">>>"
msgstr ""
">>> print(hex(windll.kernel32.GetModuleHandleA(None)))\n"
"0x1d000000\n"
">>>"

#: ../../library/ctypes.rst:165
msgid ""
":exc:`ValueError` is raised when you call an ``stdcall`` function with the "
"``cdecl`` calling convention, or vice versa::"
msgstr ""
":exc:`ValueError` uppstår när du anropar en ``stdcall``-funktion med "
"anropskonventionen ``cdecl``, eller vice versa::"

#: ../../library/ctypes.rst:168
msgid ""
">>> cdll.kernel32.GetModuleHandleA(None)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: Procedure probably called with not enough arguments (4 bytes "
"missing)\n"
">>>\n"
"\n"
">>> windll.msvcrt.printf(b\"spam\")\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: Procedure probably called with too many arguments (4 bytes in "
"excess)\n"
">>>"
msgstr ""
"&gt;&gt;&gt; cdll.kernel32.HämtaModulHandleA(Ingen)\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"ValueError (värdefel): Proceduren anropades troligen med för få argument (4 "
"byte saknas)\n"
"&gt;&gt;&gt\n"
"\n"
"&gt;&gt;&gt; windll.msvcrt.printf(b\"spam\")\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"ValueError (värdefel): Proceduren anropades förmodligen med för många "
"argument (4 byte i överskott)\n"
"&gt;&gt;&gt"

#: ../../library/ctypes.rst:180
msgid ""
"To find out the correct calling convention you have to look into the C "
"header file or the documentation for the function you want to call."
msgstr ""
"För att ta reda på den korrekta anropskonventionen måste du titta i C-"
"headerfilen eller dokumentationen för den funktion du vill anropa."

#: ../../library/ctypes.rst:183
msgid ""
"On Windows, :mod:`ctypes` uses win32 structured exception handling to "
"prevent crashes from general protection faults when functions are called "
"with invalid argument values::"
msgstr ""
"I Windows använder :mod:`ctypes` win32-strukturerad undantagshantering för "
"att förhindra krascher på grund av generella skyddsfel när funktioner "
"anropas med ogiltiga argumentvärden::"

#: ../../library/ctypes.rst:187
msgid ""
">>> windll.kernel32.GetModuleHandleA(32)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"OSError: exception: access violation reading 0x00000020\n"
">>>"
msgstr ""
"&gt;&gt;&gt; windll.kernel32.HämtaModuleHandleA(32)\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"OSError: undantag: åtkomstöverträdelse vid läsning av 0x00000020\n"
"&gt;&gt;&gt"

#: ../../library/ctypes.rst:193
msgid ""
"There are, however, enough ways to crash Python with :mod:`ctypes`, so you "
"should be careful anyway.  The :mod:`faulthandler` module can be helpful in "
"debugging crashes (e.g. from segmentation faults produced by erroneous C "
"library calls)."
msgstr ""
"Det finns dock tillräckligt många sätt att krascha Python med :mod:`ctypes`, "
"så du bör vara försiktig ändå.  Modulen :mod:`faulthandler` kan vara till "
"hjälp vid felsökning av krascher (t.ex. från segmenteringsfel som orsakas av "
"felaktiga anrop till C-biblioteket)."

#: ../../library/ctypes.rst:198
msgid ""
"``None``, integers, bytes objects and (unicode) strings are the only native "
"Python objects that can directly be used as parameters in these function "
"calls. ``None`` is passed as a C ``NULL`` pointer, bytes objects and strings "
"are passed as pointer to the memory block that contains their data (:c:expr:"
"`char *` or :c:expr:`wchar_t *`).  Python integers are passed as the "
"platform's default C :c:expr:`int` type, their value is masked to fit into "
"the C type."
msgstr ""
"``None``, heltal, bytesobjekt och (unicode) strängar är de enda Python-"
"objekt som direkt kan användas som parametrar i dessa funktionsanrop. "
"``None`` skickas som en C ``NULL`` pekare, bytesobjekt och strängar skickas "
"som pekare till minnesblocket som innehåller deras data (:c:expr:`char *` "
"eller :c:expr:`wchar_t *`).  Python heltal skickas som plattformens standard "
"C :c:expr:`int`-typ, deras värde maskeras för att passa in i C-typen."

#: ../../library/ctypes.rst:205
msgid ""
"Before we move on calling functions with other parameter types, we have to "
"learn more about :mod:`ctypes` data types."
msgstr ""
"Innan vi går vidare med att anropa funktioner med andra parametertyper måste "
"vi lära oss mer om datatyperna :mod:`ctypes`."

#: ../../library/ctypes.rst:212 ../../library/ctypes.rst:2283
msgid "Fundamental data types"
msgstr "Grundläggande datatyper"

#: ../../library/ctypes.rst:214
msgid ":mod:`ctypes` defines a number of primitive C compatible data types:"
msgstr ":mod:`ctypes` definierar ett antal primitiva C-kompatibla datatyper:"

#: ../../library/ctypes.rst:217
msgid "ctypes type"
msgstr "ctypes typ"

#: ../../library/ctypes.rst:217
msgid "C type"
msgstr "C-typ"

#: ../../library/ctypes.rst:217
msgid "Python type"
msgstr "Python-typ"

#: ../../library/ctypes.rst:219
msgid ":class:`c_bool`"
msgstr ":klass:`c_bool`"

#: ../../library/ctypes.rst:219
msgid ":c:expr:`_Bool`"
msgstr ":c:expr:`_Bool`"

#: ../../library/ctypes.rst:219
msgid "bool (1)"
msgstr "bool (1)"

#: ../../library/ctypes.rst:221
msgid ":class:`c_char`"
msgstr ":klass:`c_char`"

#: ../../library/ctypes.rst:221 ../../library/ctypes.rst:225
msgid ":c:expr:`char`"
msgstr ":c:expr:`char`"

#: ../../library/ctypes.rst:221
msgid "1-character bytes object"
msgstr "1-teckens bytes objekt"

#: ../../library/ctypes.rst:223
msgid ":class:`c_wchar`"
msgstr ":klass:`c_wchar`"

#: ../../library/ctypes.rst:223
msgid ":c:type:`wchar_t`"
msgstr ":c:typ:`wchar_t`"

#: ../../library/ctypes.rst:223
msgid "1-character string"
msgstr "1-teckens sträng"

#: ../../library/ctypes.rst:225
msgid ":class:`c_byte`"
msgstr ":klass:`c_byte`"

#: ../../library/ctypes.rst:225 ../../library/ctypes.rst:227
#: ../../library/ctypes.rst:229 ../../library/ctypes.rst:231
#: ../../library/ctypes.rst:233 ../../library/ctypes.rst:235
#: ../../library/ctypes.rst:237 ../../library/ctypes.rst:239
#: ../../library/ctypes.rst:241 ../../library/ctypes.rst:243
#: ../../library/ctypes.rst:245 ../../library/ctypes.rst:247
#: ../../library/ctypes.rst:249 ../../library/ctypes.rst:251
#: ../../library/ctypes.rst:253 ../../library/ctypes.rst:255
#: ../../library/ctypes.rst:257 ../../library/ctypes.rst:259
#: ../../library/ctypes.rst:262 ../../library/ctypes.rst:264
#: ../../library/ctypes.rst:267
msgid "int"
msgstr "int"

#: ../../library/ctypes.rst:227
msgid ":class:`c_ubyte`"
msgstr ":klass:`c_ubyte`"

#: ../../library/ctypes.rst:227
msgid ":c:expr:`unsigned char`"
msgstr ":c:expr:`unsigned char`"

#: ../../library/ctypes.rst:229
msgid ":class:`c_short`"
msgstr ":klass:`c_short`"

#: ../../library/ctypes.rst:229
msgid ":c:expr:`short`"
msgstr ":c:expr:`short`"

#: ../../library/ctypes.rst:231
msgid ":class:`c_ushort`"
msgstr ":klass:`c_ushort`"

#: ../../library/ctypes.rst:231
msgid ":c:expr:`unsigned short`"
msgstr ":c:expr:`unsigned short`"

#: ../../library/ctypes.rst:233
msgid ":class:`c_int`"
msgstr ":klass:`c_int`"

#: ../../library/ctypes.rst:233
msgid ":c:expr:`int`"
msgstr ":c:expr:`int`"

#: ../../library/ctypes.rst:235
msgid ":class:`c_int8`"
msgstr ":klass:`c_int8`"

#: ../../library/ctypes.rst:235
msgid ":c:type:`int8_t`"
msgstr ":c:typ:`int8_t`"

#: ../../library/ctypes.rst:237
msgid ":class:`c_int16`"
msgstr ":klass:`c_int16`"

#: ../../library/ctypes.rst:237
msgid ":c:type:`int16_t`"
msgstr ":c:typ:`int16_t`"

#: ../../library/ctypes.rst:239
msgid ":class:`c_int32`"
msgstr ":klass:`c_int32`"

#: ../../library/ctypes.rst:239
msgid ":c:type:`int32_t`"
msgstr ":c:typ:`int32_t`"

#: ../../library/ctypes.rst:241
msgid ":class:`c_int64`"
msgstr ":klass:`c_int64`"

#: ../../library/ctypes.rst:241
msgid ":c:type:`int64_t`"
msgstr ":c:typ:`int64_t`"

#: ../../library/ctypes.rst:243
msgid ":class:`c_uint`"
msgstr ":klass:`c_uint`"

#: ../../library/ctypes.rst:243
msgid ":c:expr:`unsigned int`"
msgstr ":c:expr:`unsigned int`"

#: ../../library/ctypes.rst:245
msgid ":class:`c_uint8`"
msgstr ":klass:`c_uint8`"

#: ../../library/ctypes.rst:245
msgid ":c:type:`uint8_t`"
msgstr ":c:typ:`uint8_t`"

#: ../../library/ctypes.rst:247
msgid ":class:`c_uint16`"
msgstr ":klass:`c_uint16`"

#: ../../library/ctypes.rst:247
msgid ":c:type:`uint16_t`"
msgstr ":c:typ:`uint16_t`"

#: ../../library/ctypes.rst:249
msgid ":class:`c_uint32`"
msgstr ":klass:`c_uint32`"

#: ../../library/ctypes.rst:249
msgid ":c:type:`uint32_t`"
msgstr ":c:typ:`uint32_t`"

#: ../../library/ctypes.rst:251
msgid ":class:`c_uint64`"
msgstr ":klass:`c_uint64`"

#: ../../library/ctypes.rst:251
msgid ":c:type:`uint64_t`"
msgstr ":c:typ:`uint64_t`"

#: ../../library/ctypes.rst:253
msgid ":class:`c_long`"
msgstr ":klass:`c_long`"

#: ../../library/ctypes.rst:253
msgid ":c:expr:`long`"
msgstr ":c:expr:`long`"

#: ../../library/ctypes.rst:255
msgid ":class:`c_ulong`"
msgstr ":klass:`c_ulong`"

#: ../../library/ctypes.rst:255
msgid ":c:expr:`unsigned long`"
msgstr ":c:expr:`unsigned long`"

#: ../../library/ctypes.rst:257
msgid ":class:`c_longlong`"
msgstr ":klass:`c_longlong`"

#: ../../library/ctypes.rst:257
msgid ":c:expr:`__int64` or :c:expr:`long long`"
msgstr ":c:expr:`__int64` eller :c:expr:`long long`"

#: ../../library/ctypes.rst:259
msgid ":class:`c_ulonglong`"
msgstr ":klass:`c_ulonglong`"

#: ../../library/ctypes.rst:259
msgid ":c:expr:`unsigned __int64` or :c:expr:`unsigned long long`"
msgstr ":c:expr:`unsigned __int64` eller :c:expr:`unsigned long long`"

#: ../../library/ctypes.rst:262
msgid ":class:`c_size_t`"
msgstr ":klass:`c_size_t`"

#: ../../library/ctypes.rst:262
msgid ":c:type:`size_t`"
msgstr ":c:type:`size_t`"

#: ../../library/ctypes.rst:264
msgid ":class:`c_ssize_t`"
msgstr ":klass:`c_ssize_t`"

#: ../../library/ctypes.rst:264
msgid ":c:type:`ssize_t` or :c:expr:`Py_ssize_t`"
msgstr ":c:type:`ssize_t` eller :c:expr:`Py_ssize_t`"

#: ../../library/ctypes.rst:267
msgid ":class:`c_time_t`"
msgstr ":klass:`c_time_t`"

#: ../../library/ctypes.rst:267
msgid ":c:type:`time_t`"
msgstr ":c:typ:`time_t`"

#: ../../library/ctypes.rst:269
msgid ":class:`c_float`"
msgstr ":klass:`c_float`"

#: ../../library/ctypes.rst:269
msgid ":c:expr:`float`"
msgstr ":c:expr:`float`"

#: ../../library/ctypes.rst:269 ../../library/ctypes.rst:271
#: ../../library/ctypes.rst:273
msgid "float"
msgstr "float"

#: ../../library/ctypes.rst:271
msgid ":class:`c_double`"
msgstr ":klass:`c_double`"

#: ../../library/ctypes.rst:271
msgid ":c:expr:`double`"
msgstr ":c:expr:`double`"

#: ../../library/ctypes.rst:273
msgid ":class:`c_longdouble`"
msgstr ":klass:`c_longdouble`"

#: ../../library/ctypes.rst:273
msgid ":c:expr:`long double`"
msgstr ":c:expr:`lång dubbel`"

#: ../../library/ctypes.rst:275
msgid ":class:`c_char_p`"
msgstr ":klass:`c_char_p`"

#: ../../library/ctypes.rst:275
msgid ":c:expr:`char *` (NUL terminated)"
msgstr ":c:expr:`char *` (NUL-terminerad)"

#: ../../library/ctypes.rst:275
msgid "bytes object or ``None``"
msgstr "bytes objekt eller ``None``"

#: ../../library/ctypes.rst:277
msgid ":class:`c_wchar_p`"
msgstr ":klass:`c_wchar_p`"

#: ../../library/ctypes.rst:277
msgid ":c:expr:`wchar_t *` (NUL terminated)"
msgstr ":c:expr:`wchar_t *` (NUL-terminerad)"

#: ../../library/ctypes.rst:277
msgid "string or ``None``"
msgstr "sträng eller ``None``"

#: ../../library/ctypes.rst:279
msgid ":class:`c_void_p`"
msgstr ":klass:`c_void_p`"

#: ../../library/ctypes.rst:279
msgid ":c:expr:`void *`"
msgstr ":c:expr:`void *`"

#: ../../library/ctypes.rst:279
msgid "int or ``None``"
msgstr "int eller ``None``"

#: ../../library/ctypes.rst:283
msgid "The constructor accepts any object with a truth value."
msgstr "Konstruktören accepterar alla objekt med ett sanningsvärde."

#: ../../library/ctypes.rst:285
msgid ""
"All these types can be created by calling them with an optional initializer "
"of the correct type and value::"
msgstr ""
"Alla dessa typer kan skapas genom att anropa dem med en valfri "
"initialiserare av rätt typ och värde::"

#: ../../library/ctypes.rst:288
msgid ""
">>> c_int()\n"
"c_long(0)\n"
">>> c_wchar_p(\"Hello, World\")\n"
"c_wchar_p(140018365411392)\n"
">>> c_ushort(-3)\n"
"c_ushort(65533)\n"
">>>"
msgstr ""
">>> c_int()\n"
"c_long(0)\n"
">>> c_wchar_p(\"Hej, världen\")\n"
"c_wchar_p(140018365411392)\n"
">>> c_ushort(-3)\n"
"c_ushort(65533)\n"
">>>"

#: ../../library/ctypes.rst:296
msgid ""
"Since these types are mutable, their value can also be changed afterwards::"
msgstr ""
"Eftersom dessa typer är mutabla kan deras värde också ändras i efterhand::"

#: ../../library/ctypes.rst:298
msgid ""
">>> i = c_int(42)\n"
">>> print(i)\n"
"c_long(42)\n"
">>> print(i.value)\n"
"42\n"
">>> i.value = -99\n"
">>> print(i.value)\n"
"-99\n"
">>>"
msgstr ""
">>> i = c_int(42)\n"
">>> skriv ut(i)\n"
"c_long(42)\n"
">>> print(i.värde)\n"
"42\n"
">>> i.värde = -99\n"
">>> skriv ut(i.värde)\n"
"-99\n"
">>>"

#: ../../library/ctypes.rst:308
msgid ""
"Assigning a new value to instances of the pointer types :class:`c_char_p`, :"
"class:`c_wchar_p`, and :class:`c_void_p` changes the *memory location* they "
"point to, *not the contents* of the memory block (of course not, because "
"Python string objects are immutable)::"
msgstr ""
"Genom att tilldela ett nytt värde till instanser av pekartyperna :class:"
"`c_char_p`, :class:`c_wchar_p` och :class:`c_void_p` ändras den "
"*minnesplats* de pekar på, *inte innehållet* i minnesblocket (naturligtvis "
"inte, eftersom Pythons strängobjekt är oföränderliga)::"

#: ../../library/ctypes.rst:313
msgid ""
">>> s = \"Hello, World\"\n"
">>> c_s = c_wchar_p(s)\n"
">>> print(c_s)\n"
"c_wchar_p(139966785747344)\n"
">>> print(c_s.value)\n"
"Hello World\n"
">>> c_s.value = \"Hi, there\"\n"
">>> print(c_s)              # the memory location has changed\n"
"c_wchar_p(139966783348904)\n"
">>> print(c_s.value)\n"
"Hi, there\n"
">>> print(s)                # first object is unchanged\n"
"Hello, World\n"
">>>"
msgstr ""
">>> s = \"Hej, världen\"\n"
">>> c_s = c_wchar_p(s)\n"
">>> skriv ut(c_s)\n"
"c_wchar_p(139966785747344)\n"
">>> print(c_s.värde)\n"
"Hej världen\n"
">>> c_s.value = \"Hej, där\"\n"
">>> print(c_s) # minnesplatsen har ändrats\n"
"c_wchar_p(139966783348904)\n"
">>> skriv ut(c_s.värde)\n"
"Hej, där\n"
">>> print(s) # första objektet är oförändrat\n"
"Hallå, världen\n"
">>>"

#: ../../library/ctypes.rst:328
msgid ""
"You should be careful, however, not to pass them to functions expecting "
"pointers to mutable memory. If you need mutable memory blocks, ctypes has a :"
"func:`create_string_buffer` function which creates these in various ways.  "
"The current memory block contents can be accessed (or changed) with the "
"``raw`` property; if you want to access it as NUL terminated string, use the "
"``value`` property::"
msgstr ""
"Du bör dock vara försiktig så att du inte skickar dem till funktioner som "
"förväntar sig pekare till föränderligt minne. Om du behöver föränderliga "
"minnesblock har ctypes en :func:`create_string_buffer`-funktion som skapar "
"dessa på olika sätt.  Det aktuella innehållet i minnesblocket kan nås (eller "
"ändras) med egenskapen ``raw``; om du vill komma åt det som en NUL-avslutad "
"sträng, använd egenskapen ``value``::"

#: ../../library/ctypes.rst:335
msgid ""
">>> from ctypes import *\n"
">>> p = create_string_buffer(3)            # create a 3 byte buffer, "
"initialized to NUL bytes\n"
">>> print(sizeof(p), repr(p.raw))\n"
"3 b'\\x00\\x00\\x00'\n"
">>> p = create_string_buffer(b\"Hello\")     # create a buffer containing a "
"NUL terminated string\n"
">>> print(sizeof(p), repr(p.raw))\n"
"6 b'Hello\\x00'\n"
">>> print(repr(p.value))\n"
"b'Hello'\n"
">>> p = create_string_buffer(b\"Hello\", 10) # create a 10 byte buffer\n"
">>> print(sizeof(p), repr(p.raw))\n"
"10 b'Hello\\x00\\x00\\x00\\x00\\x00'\n"
">>> p.value = b\"Hi\"\n"
">>> print(sizeof(p), repr(p.raw))\n"
"10 b'Hi\\x00lo\\x00\\x00\\x00\\x00\\x00'\n"
">>>"
msgstr ""
">>> från ctypes import *\n"
">>> p = create_string_buffer(3) # skapa en buffert på 3 byte, initialiserad "
"till NUL-byte\n"
">>> print(sizeof(p), repr(p.raw))\n"
"3 b'\\x00\\x00\\x00'\n"
">>> p = create_string_buffer(b\"Hello\") # skapa en buffert som innehåller "
"en NUL-avslutad sträng\n"
">>> print(sizeof(p), repr(p.raw))\n"
"6 b'Hej\\x00'\n"
">>> skriv ut(repr(p.värde))\n"
"b'Hej'\n"
">>> p = create_string_buffer(b\"Hello\", 10) # skapa en buffert på 10 byte\n"
">>> print(sizeof(p), repr(p.raw))\n"
"10 b'Hello\\x00\\x00\\x00\\x00\\x00'\n"
">>> p.värde = b\"Hej\"\n"
">>> print(sizeof(p), repr(p.raw))\n"
"10 b'Hi\\x00lo\\x00\\x00\\x00\\x00\\x00'\n"
">>>"

#: ../../library/ctypes.rst:352
msgid ""
"The :func:`create_string_buffer` function replaces the old :func:`!c_buffer` "
"function (which is still available as an alias).  To create a mutable memory "
"block containing unicode characters of the C type :c:type:`wchar_t`, use "
"the :func:`create_unicode_buffer` function."
msgstr ""
"Funktionen :func:`create_string_buffer` ersätter den gamla funktionen :func:"
"`!c_buffer` (som fortfarande är tillgänglig som alias).  För att skapa ett "
"föränderligt minnesblock som innehåller unicode-tecken av C-typen :c:type:"
"`wchar_t`, använd funktionen :func:`create_unicode_buffer`."

#: ../../library/ctypes.rst:361
msgid "Calling functions, continued"
msgstr "Anropsfunktioner, fortsättning"

#: ../../library/ctypes.rst:363
msgid ""
"Note that printf prints to the real standard output channel, *not* to :data:"
"`sys.stdout`, so these examples will only work at the console prompt, not "
"from within *IDLE* or *PythonWin*::"
msgstr ""
"Observera att printf skriver ut till den riktiga standardutdatakanalen, "
"*inte* till :data:`sys.stdout`, så dessa exempel fungerar bara vid "
"konsolprompten, inte från *IDLE* eller *PythonWin*::"

#: ../../library/ctypes.rst:367
msgid ""
">>> printf = libc.printf\n"
">>> printf(b\"Hello, %s\\n\", b\"World!\")\n"
"Hello, World!\n"
"14\n"
">>> printf(b\"Hello, %S\\n\", \"World!\")\n"
"Hello, World!\n"
"14\n"
">>> printf(b\"%d bottles of beer\\n\", 42)\n"
"42 bottles of beer\n"
"19\n"
">>> printf(b\"%f bottles of beer\\n\", 42.5)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ctypes.ArgumentError: argument 2: TypeError: Don't know how to convert "
"parameter 2\n"
">>>"
msgstr ""
"&gt;&gt;&gt; printf = libc.printf\n"
"&gt;&gt;&gt; printf(b\"Hej, %s\\n\", b\"Världen!\")\n"
"Hej, världen!\n"
"14\n"
"&gt;&gt;&gt; printf(b\"Hej, %S\\n\", \"Världen!\")\n"
"Hej, världen!\n"
"14\n"
"&gt;&gt;&gt; printf(b\"%d flaskor öl\\n\", 42)\n"
"42 flaskor öl\n"
"19\n"
"&gt;&gt;&gt; printf(b\"%f flaskor öl\\n\", 42.5)\n"
"Traceback (senaste anropet sist):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"ctypes.ArgumentError: argument 2: TypeError: Vet inte hur man konverterar "
"parameter 2\n"
"&gt;&gt;&gt"

#: ../../library/ctypes.rst:383
msgid ""
"As has been mentioned before, all Python types except integers, strings, and "
"bytes objects have to be wrapped in their corresponding :mod:`ctypes` type, "
"so that they can be converted to the required C data type::"
msgstr ""
"Som tidigare nämnts måste alla Python-typer utom heltal, strängar och "
"bytesobjekt förpackas i sin motsvarande :mod:`ctypes`-typ, så att de kan "
"konverteras till den nödvändiga C-datatypen::"

#: ../../library/ctypes.rst:387
msgid ""
">>> printf(b\"An int %d, a double %f\\n\", 1234, c_double(3.14))\n"
"An int 1234, a double 3.140000\n"
"31\n"
">>>"
msgstr ""
">>> printf(b\"Ett int %d, en dubbel %f\\n\", 1234, c_double(3.14))\n"
"Ett int 1234, en dubbel 3,140000\n"
"31\n"
">>>"

#: ../../library/ctypes.rst:395
msgid "Calling variadic functions"
msgstr "Anrop av variadiska funktioner"

#: ../../library/ctypes.rst:397
msgid ""
"On a lot of platforms calling variadic functions through ctypes is exactly "
"the same as calling functions with a fixed number of parameters. On some "
"platforms, and in particular ARM64 for Apple Platforms, the calling "
"convention for variadic functions is different than that for regular "
"functions."
msgstr ""
"På många plattformar är det exakt samma sak att anropa variadiska funktioner "
"via ctypes som att anropa funktioner med ett fast antal parametrar. På vissa "
"plattformar, och i synnerhet ARM64 för Apple-plattformar, är "
"anropskonventionen för variadiska funktioner annorlunda än för vanliga "
"funktioner."

#: ../../library/ctypes.rst:402
msgid ""
"On those platforms it is required to specify the :attr:`~_CFuncPtr.argtypes` "
"attribute for the regular, non-variadic, function arguments:"
msgstr ""
"På dessa plattformar är det nödvändigt att ange attributet :attr:`~_CFuncPtr."
"argtypes` för de vanliga, icke-variadiska, funktionsargumenten:"

#: ../../library/ctypes.rst:405
msgid "libc.printf.argtypes = [ctypes.c_char_p]"
msgstr "libc.printf.argtypes = [ctypes.c_char_p]"

#: ../../library/ctypes.rst:409
msgid ""
"Because specifying the attribute does not inhibit portability it is advised "
"to always specify :attr:`~_CFuncPtr.argtypes` for all variadic functions."
msgstr ""
"Eftersom angivandet av attributet inte hindrar portabilitet rekommenderas "
"att alltid ange :attr:`~_CFuncPtr.argtypes` för alla variadiska funktioner."

#: ../../library/ctypes.rst:416
msgid "Calling functions with your own custom data types"
msgstr "Anropa funktioner med dina egna anpassade datatyper"

#: ../../library/ctypes.rst:418
msgid ""
"You can also customize :mod:`ctypes` argument conversion to allow instances "
"of your own classes be used as function arguments. :mod:`ctypes` looks for "
"an :attr:`!_as_parameter_` attribute and uses this as the function argument. "
"The attribute must be an integer, string, bytes, a :mod:`ctypes` instance, "
"or an object with an :attr:`!_as_parameter_` attribute::"
msgstr ""
"Du kan också anpassa :mod:`ctypes` argumentkonvertering så att instanser av "
"dina egna klasser kan användas som funktionsargument. :mod:`ctypes` letar "
"efter ett :attr:`!_as_parameter_`-attribut och använder detta som "
"funktionsargument. Attributet måste vara ett heltal, en sträng, bytes, en :"
"mod:`ctypes`-instans eller ett objekt med ett :attr:`!_as_parameter_`-"
"attribut:"

#: ../../library/ctypes.rst:424
msgid ""
">>> class Bottles:\n"
"...     def __init__(self, number):\n"
"...         self._as_parameter_ = number\n"
"...\n"
">>> bottles = Bottles(42)\n"
">>> printf(b\"%d bottles of beer\\n\", bottles)\n"
"42 bottles of beer\n"
"19\n"
">>>"
msgstr ""
">>> klass Flaskor:\n"
"... def __init__(self, number):\n"
"... self._as_parameter_ = antal\n"
"...\n"
">>> flaskor = Flaskor(42)\n"
">>> printf(b\"%d flaskor öl\\n\", flaskor)\n"
"42 flaskor öl\n"
"19\n"
">>>"

#: ../../library/ctypes.rst:434
msgid ""
"If you don't want to store the instance's data in the :attr:`!"
"_as_parameter_` instance variable, you could define a :class:`property` "
"which makes the attribute available on request."
msgstr ""
"Om du inte vill lagra instansens data i instansvariabeln :attr:`!"
"_as_parameter_` kan du definiera en :class:`property` som gör attributet "
"tillgängligt på begäran."

#: ../../library/ctypes.rst:442
msgid "Specifying the required argument types (function prototypes)"
msgstr "Ange de nödvändiga argumenttyperna (funktionsprototyper)"

#: ../../library/ctypes.rst:444
msgid ""
"It is possible to specify the required argument types of functions exported "
"from DLLs by setting the :attr:`~_CFuncPtr.argtypes` attribute."
msgstr ""
"Det är möjligt att ange vilka argumenttyper som krävs för funktioner som "
"exporteras från DLL:er genom att ange attributet :attr:`~_CFuncPtr.argtypes`."

#: ../../library/ctypes.rst:447
msgid ""
":attr:`~_CFuncPtr.argtypes` must be a sequence of C data types (the :func:`!"
"printf` function is probably not a good example here, because it takes a "
"variable number and different types of parameters depending on the format "
"string, on the other hand this is quite handy to experiment with this "
"feature)::"
msgstr ""
":attr:`~_CFuncPtr.argtypes` måste vara en sekvens av C-datatyper "
"(funktionen :func:`!printf` är förmodligen inte ett bra exempel här, "
"eftersom den tar ett variabelt antal och olika typer av parametrar beroende "
"på formatsträngen, å andra sidan är det ganska praktiskt att experimentera "
"med den här funktionen)::"

#: ../../library/ctypes.rst:452
msgid ""
">>> printf.argtypes = [c_char_p, c_char_p, c_int, c_double]\n"
">>> printf(b\"String '%s', Int %d, Double %f\\n\", b\"Hi\", 10, 2.2)\n"
"String 'Hi', Int 10, Double 2.200000\n"
"37\n"
">>>"
msgstr ""
">>> printf.argtypes = [c_char_p, c_char_p, c_int, c_double]\n"
">>> printf(b\"Sträng '%s', Int %d, Dubbel %f\\n\", b\"Hej\", 10, 2,2)\n"
"Sträng \"Hi\", Int 10, Dubbel 2,200000\n"
"37\n"
">>>"

#: ../../library/ctypes.rst:458
msgid ""
"Specifying a format protects against incompatible argument types (just as a "
"prototype for a C function), and tries to convert the arguments to valid "
"types::"
msgstr ""
"Genom att ange ett format skyddar man sig mot inkompatibla argumenttyper "
"(precis som en prototyp för en C-funktion) och försöker konvertera "
"argumenten till giltiga typer::"

#: ../../library/ctypes.rst:461
msgid ""
">>> printf(b\"%d %d %d\", 1, 2, 3)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ctypes.ArgumentError: argument 2: TypeError: 'int' object cannot be "
"interpreted as ctypes.c_char_p\n"
">>> printf(b\"%s %d %f\\n\", b\"X\", 2, 3)\n"
"X 2 3.000000\n"
"13\n"
">>>"
msgstr ""
"&gt;&gt;&gt; printf(b\"%d %d %d\", 1, 2, 3)\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"ctypes.ArgumentError: argument 2: TypeError: objektet 'int' kan inte tolkas "
"som ctypes.c_char_p\n"
"&gt;&gt;&gt; printf(b\"%s %d %f\\n\", b\"X\", 2, 3)\n"
"X 2 3.000000\n"
"13\n"
"&gt;&gt;&gt"

#: ../../library/ctypes.rst:470
msgid ""
"If you have defined your own classes which you pass to function calls, you "
"have to implement a :meth:`~_CData.from_param` class method for them to be "
"able to use them in the :attr:`~_CFuncPtr.argtypes` sequence. The :meth:"
"`~_CData.from_param` class method receives the Python object passed to the "
"function call, it should do a typecheck or whatever is needed to make sure "
"this object is acceptable, and then return the object itself, its :attr:`!"
"_as_parameter_` attribute, or whatever you want to pass as the C function "
"argument in this case. Again, the result should be an integer, string, "
"bytes, a :mod:`ctypes` instance, or an object with an :attr:`!"
"_as_parameter_` attribute."
msgstr ""
"Om du har definierat dina egna klasser som du skickar till funktionsanrop, "
"måste du implementera en :meth:`~_CData.from_param` klassmetod för att de "
"ska kunna använda dem i :attr:`~_CFuncPtr.argtypes` sekvensen. Klassmetoden :"
"meth:`~_CData.from_param` tar emot Python-objektet som skickas till "
"funktionsanropet, den bör göra en typkontroll eller vad som behövs för att "
"se till att detta objekt är acceptabelt och sedan returnera själva objektet, "
"dess :attr:`!_as_parameter_`-attribut eller vad du vill skicka som C-"
"funktionsargument i det här fallet. Återigen bör resultatet vara ett heltal, "
"en sträng, bytes, en :mod:`ctypes`-instans eller ett objekt med ett :attr:`!"
"_as_parameter_`-attribut."

#: ../../library/ctypes.rst:484
msgid "Return types"
msgstr "Typer av avkastning"

#: ../../library/ctypes.rst:494
msgid ""
"By default functions are assumed to return the C :c:expr:`int` type.  Other "
"return types can be specified by setting the :attr:`~_CFuncPtr.restype` "
"attribute of the function object."
msgstr ""
"Som standard antas funktioner returnera C :c:expr:`int`-typen.  Andra "
"returtyper kan anges genom att ställa in attributet :attr:`~_CFuncPtr."
"restype` för funktionsobjektet."

#: ../../library/ctypes.rst:498
msgid ""
"The C prototype of :c:func:`time` is ``time_t time(time_t *)``. Because :c:"
"type:`time_t` might be of a different type than the default return type :c:"
"expr:`int`, you should specify the :attr:`!restype` attribute::"
msgstr ""
"C-prototypen för :c:func:`time` är ``time_t time(time_t *)``. Eftersom :c:"
"type:`time_t` kan vara av en annan typ än standardreturtypen :c:expr:`int`, "
"bör du ange attributet :attr:`!restype`::"

#: ../../library/ctypes.rst:502
msgid ">>> libc.time.restype = c_time_t"
msgstr ">>> libc.time.restype = c_time_t"

#: ../../library/ctypes.rst:504
msgid "The argument types can be specified using :attr:`~_CFuncPtr.argtypes`::"
msgstr "Argumenttyperna kan anges med hjälp av :attr:`~_CFuncPtr.argtypes`::"

#: ../../library/ctypes.rst:506
msgid ">>> libc.time.argtypes = (POINTER(c_time_t),)"
msgstr ">>> libc.time.argtypes = (POINTER(c_time_t),)"

#: ../../library/ctypes.rst:508
msgid ""
"To call the function with a ``NULL`` pointer as first argument, use "
"``None``::"
msgstr ""
"Om du vill anropa funktionen med en ``NULL``-pekare som första argument "
"använder du ``None``::"

#: ../../library/ctypes.rst:510
msgid ""
">>> print(libc.time(None))\n"
"1150640792"
msgstr ""
">>> print(libc.time(None))\n"
"1150640792"

#: ../../library/ctypes.rst:513
msgid ""
"Here is a more advanced example, it uses the :func:`!strchr` function, which "
"expects a string pointer and a char, and returns a pointer to a string::"
msgstr ""
"Här är ett mer avancerat exempel, det använder funktionen :func:`!strchr`, "
"som förväntar sig en strängpekare och en char, och returnerar en pekare till "
"en sträng::"

#: ../../library/ctypes.rst:516
msgid ""
">>> strchr = libc.strchr\n"
">>> strchr(b\"abcdef\", ord(\"d\"))\n"
"8059983\n"
">>> strchr.restype = c_char_p    # c_char_p is a pointer to a string\n"
">>> strchr(b\"abcdef\", ord(\"d\"))\n"
"b'def'\n"
">>> print(strchr(b\"abcdef\", ord(\"x\")))\n"
"None\n"
">>>"
msgstr ""
">>> strchr = libc.strchr\n"
">>> strchr(b\"abcdef\", ord(\"d\"))\n"
"8059983\n"
">>> strchr.restype = c_char_p # c_char_p är en pekare till en sträng\n"
">>> strchr(b\"abcdef\", ord(\"d\"))\n"
"b'def'\n"
">>> print(strchr(b\"abcdef\", ord(\"x\")))\n"
"Ingen\n"
">>>"

#: ../../library/ctypes.rst:526
msgid ""
"If you want to avoid the :func:`ord(\"x\") <ord>` calls above, you can set "
"the :attr:`~_CFuncPtr.argtypes` attribute, and the second argument will be "
"converted from a single character Python bytes object into a C char:"
msgstr ""
"Om du vill undvika :func:`ord(\"x\") <ord>`-anropen ovan kan du ställa in "
"attributet :attr:`~_CFuncPtr.argtypes`, och det andra argumentet konverteras "
"från ett Python bytes-objekt med ett tecken till ett C char:"

#: ../../library/ctypes.rst:530
msgid ""
">>> strchr.restype = c_char_p\n"
">>> strchr.argtypes = [c_char_p, c_char]\n"
">>> strchr(b\"abcdef\", b\"d\")\n"
"b'def'\n"
">>> strchr(b\"abcdef\", b\"def\")\n"
"Traceback (most recent call last):\n"
"ctypes.ArgumentError: argument 2: TypeError: one character bytes, bytearray "
"or integer expected\n"
">>> print(strchr(b\"abcdef\", b\"x\"))\n"
"None\n"
">>> strchr(b\"abcdef\", b\"d\")\n"
"b'def'\n"
">>>"
msgstr ""
">>> strchr.restype = c_char_p\n"
">>> strchr.argtypes = [c_char_p, c_char]\n"
">>> strchr(b\"abcdef\", b\"d\")\n"
"b\"def\n"
">>> strchr(b\"abcdef\", b\"def\")\n"
"Traceback (senaste anropet senast):\n"
"ctypes.ArgumentError: argument 2: TypeError: ett tecken bytes, bytearray "
"eller heltal förväntas\n"
">>> print(strchr(b\"abcdef\", b\"x\"))\n"
"Ingen\n"
">>> strchr(b\"abcdef\", b\"d\")\n"
"b'def'\n"
">>>"

#: ../../library/ctypes.rst:545
msgid ""
"You can also use a callable Python object (a function or a class for "
"example) as the :attr:`~_CFuncPtr.restype` attribute, if the foreign "
"function returns an integer.  The callable will be called with the *integer* "
"the C function returns, and the result of this call will be used as the "
"result of your function call. This is useful to check for error return "
"values and automatically raise an exception::"
msgstr ""
"Du kan också använda ett anropbart Python-objekt (t.ex. en funktion eller en "
"klass) som attributet :attr:`~_CFuncPtr.restype`, om den utländska "
"funktionen returnerar ett heltal.  Det anropbara objektet kommer att anropas "
"med det *integer* som C-funktionen returnerar, och resultatet av detta anrop "
"kommer att användas som resultatet av ditt funktionsanrop. Detta är "
"användbart för att kontrollera felaktiga returvärden och automatiskt skapa "
"ett undantag::"

#: ../../library/ctypes.rst:551
msgid ""
">>> GetModuleHandle = windll.kernel32.GetModuleHandleA\n"
">>> def ValidHandle(value):\n"
"...     if value == 0:\n"
"...         raise WinError()\n"
"...     return value\n"
"...\n"
">>>\n"
">>> GetModuleHandle.restype = ValidHandle\n"
">>> GetModuleHandle(None)\n"
"486539264\n"
">>> GetModuleHandle(\"something silly\")\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"<stdin>\", line 3, in ValidHandle\n"
"OSError: [Errno 126] The specified module could not be found.\n"
">>>"
msgstr ""
"&gt;&gt;&gt; GetModuleHandle = windll.kernel32.GetModuleHandleA\n"
"&gt;&gt;&gt; def ValidHandle(värde):\n"
"... om värde == 0:\n"
"... raise WinError()\n"
"... returnera värde\n"
"...\n"
"&gt;&gt;&gt\n"
"&gt;&gt;&gt; GetModuleHandle.restype = GiltigHandle\n"
"&gt;&gt;&gt; HämtaModulHandle(Ingen)\n"
"486539264\n"
"&gt;&gt;&gt; GetModuleHandle(\"något fånigt\")\n"
"Traceback (senaste anropet sist):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"  Fil \"<stdin>\", rad 3, i ValidHandle\n"
"OSError: [Errno 126] Den angivna modulen kunde inte hittas.\n"
"&gt;&gt;&gt"

#: ../../library/ctypes.rst:568
msgid ""
"``WinError`` is a function which will call Windows ``FormatMessage()`` api "
"to get the string representation of an error code, and *returns* an "
"exception. ``WinError`` takes an optional error code parameter, if no one is "
"used, it calls :func:`GetLastError` to retrieve it."
msgstr ""
"``WinError`` är en funktion som anropar Windows ``FormatMessage()`` api för "
"att få strängrepresentationen av en felkod, och *returnerar* ett undantag. "
"``WinError`` tar en valfri felkodsparameter, om ingen används anropar den :"
"func:`GetLastError` för att hämta den."

#: ../../library/ctypes.rst:573
msgid ""
"Please note that a much more powerful error checking mechanism is available "
"through the :attr:`~_CFuncPtr.errcheck` attribute; see the reference manual "
"for details."
msgstr ""
"Observera att en mycket kraftfullare felkontrollmekanism är tillgänglig via "
"attributet :attr:`~_CFuncPtr.errcheck`; se referenshandboken för mer "
"information."

#: ../../library/ctypes.rst:581
msgid "Passing pointers (or: passing parameters by reference)"
msgstr "Passera pekare (eller: passera parametrar genom referens)"

#: ../../library/ctypes.rst:583
msgid ""
"Sometimes a C api function expects a *pointer* to a data type as parameter, "
"probably to write into the corresponding location, or if the data is too "
"large to be passed by value. This is also known as *passing parameters by "
"reference*."
msgstr ""
"Ibland förväntar sig en C api-funktion en *pekare* till en datatyp som "
"parameter, förmodligen för att skriva till motsvarande plats, eller om data "
"är för stora för att skickas med värde. Detta kallas också att *överföra "
"parametrar genom referens*."

#: ../../library/ctypes.rst:587
msgid ""
":mod:`ctypes` exports the :func:`byref` function which is used to pass "
"parameters by reference.  The same effect can be achieved with the :func:"
"`pointer` function, although :func:`pointer` does a lot more work since it "
"constructs a real pointer object, so it is faster to use :func:`byref` if "
"you don't need the pointer object in Python itself::"
msgstr ""
":mod:`ctypes` exporterar funktionen :func:`byref` som används för att skicka "
"parametrar som referenser.  Samma effekt kan uppnås med funktionen :func:"
"`pointer`, även om :func:`pointer` gör mycket mer arbete eftersom den "
"konstruerar ett riktigt pekarobjekt, så det är snabbare att använda :func:"
"`byref` om du inte behöver pekarobjektet i Python själv::"

#: ../../library/ctypes.rst:593
msgid ""
">>> i = c_int()\n"
">>> f = c_float()\n"
">>> s = create_string_buffer(b'\\000' * 32)\n"
">>> print(i.value, f.value, repr(s.value))\n"
"0 0.0 b''\n"
">>> libc.sscanf(b\"1 3.14 Hello\", b\"%d %f %s\",\n"
"...             byref(i), byref(f), s)\n"
"3\n"
">>> print(i.value, f.value, repr(s.value))\n"
"1 3.1400001049 b'Hello'\n"
">>>"
msgstr ""
">>> i = c_int()\n"
">>> f = c_float()\n"
">>> s = skapa_sträng_buffer(b'\\000' * 32)\n"
">>> print(i.värde, f.värde, repr(s.värde))\n"
"0 0.0 b''\n"
">>> libc.sscanf(b\"1 3.14 Hello\", b\"%d %f %s\",\n"
"... byref(i), byref(f), s)\n"
"3\n"
">>> print(i.värde, f.värde, repr(s.värde))\n"
"1 3.1400001049 b'Hello'\n"
">>>"

#: ../../library/ctypes.rst:609
msgid "Structures and unions"
msgstr "Strukturer och fackföreningar"

#: ../../library/ctypes.rst:611
msgid ""
"Structures and unions must derive from the :class:`Structure` and :class:"
"`Union` base classes which are defined in the :mod:`ctypes` module. Each "
"subclass must define a :attr:`~Structure._fields_` attribute.  :attr:`!"
"_fields_` must be a list of *2-tuples*, containing a *field name* and a "
"*field type*."
msgstr ""
"Strukturer och unioner måste härledas från basklasserna :class:`Structure` "
"och :class:`Union` som definieras i modulen :mod:`ctypes`. Varje underklass "
"måste definiera ett attribut :attr:`~Structure._fields_`. :attr:`!_fields_` "
"måste vara en lista med *2-tuples*, innehållande ett *fältsnamn* och en "
"*fältstyp*."

#: ../../library/ctypes.rst:616
msgid ""
"The field type must be a :mod:`ctypes` type like :class:`c_int`, or any "
"other derived :mod:`ctypes` type: structure, union, array, pointer."
msgstr ""
"Fälttypen måste vara en :mod:`ctypes`-typ som :class:`c_int`, eller någon "
"annan härledd :mod:`ctypes`-typ: struktur, union, array, pekare."

#: ../../library/ctypes.rst:619
msgid ""
"Here is a simple example of a POINT structure, which contains two integers "
"named *x* and *y*, and also shows how to initialize a structure in the "
"constructor::"
msgstr ""
"Här följer ett enkelt exempel på en POINT-struktur, som innehåller två "
"heltal med namnen *x* och *y*, och som också visar hur man initialiserar en "
"struktur i konstruktorn::"

#: ../../library/ctypes.rst:622
msgid ""
">>> from ctypes import *\n"
">>> class POINT(Structure):\n"
"...     _fields_ = [(\"x\", c_int),\n"
"...                 (\"y\", c_int)]\n"
"...\n"
">>> point = POINT(10, 20)\n"
">>> print(point.x, point.y)\n"
"10 20\n"
">>> point = POINT(y=5)\n"
">>> print(point.x, point.y)\n"
"0 5\n"
">>> POINT(1, 2, 3)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: too many initializers\n"
">>>"
msgstr ""
"&gt;&gt;&gt; från ctypes importera *\n"
"&gt;&gt;&gt; klass POINT(Struktur):\n"
"...     _fields_ = [(\"x\", c_int),\n"
"... (\"y\", c_int)]\n"
"...\n"
"&gt;&gt;&gt; punkt = POINT(10, 20)\n"
"&gt;&gt;&gt; print(punkt.x, punkt.y)\n"
"10 20\n"
"&gt;&gt;&gt; punkt = PUNKT(y=5)\n"
"&gt;&gt;&gt; skriv ut(punkt.x, punkt.y)\n"
"0 5\n"
"&gt;&gt;&gt; PUNKT(1, 2, 3)\n"
"Traceback (senaste anropet sist):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"TypeError: för många initialiserare\n"
"&gt;&gt;&gt"

#: ../../library/ctypes.rst:639
msgid ""
"You can, however, build much more complicated structures.  A structure can "
"itself contain other structures by using a structure as a field type."
msgstr ""
"Det går dock att bygga mycket mer komplicerade strukturer.  En struktur kan "
"i sig innehålla andra strukturer genom att använda en struktur som fälttyp."

#: ../../library/ctypes.rst:642
msgid ""
"Here is a RECT structure which contains two POINTs named *upperleft* and "
"*lowerright*::"
msgstr ""
"Här är en RECT-struktur som innehåller två POINTs med namnen *upperleft* och "
"*lowerright*::"

#: ../../library/ctypes.rst:645
msgid ""
">>> class RECT(Structure):\n"
"...     _fields_ = [(\"upperleft\", POINT),\n"
"...                 (\"lowerright\", POINT)]\n"
"...\n"
">>> rc = RECT(point)\n"
">>> print(rc.upperleft.x, rc.upperleft.y)\n"
"0 5\n"
">>> print(rc.lowerright.x, rc.lowerright.y)\n"
"0 0\n"
">>>"
msgstr ""
">>> klass RECT(Struktur):\n"
"...     _fields_ = [(\"upperleft\", POINT),\n"
"... (\"lowerright\", POINT)]\n"
"...\n"
">>> rc = RECT(punkt)\n"
">>> print(rc.upperleft.x, rc.upperleft.y)\n"
"0 5\n"
">>> print(rc.lowerright.x, rc.lowerright.y)\n"
"0 0\n"
">>>"

#: ../../library/ctypes.rst:656
msgid ""
"Nested structures can also be initialized in the constructor in several "
"ways::"
msgstr ""
"Nästlade strukturer kan också initialiseras i konstruktorn på flera sätt::"

#: ../../library/ctypes.rst:658
msgid ""
">>> r = RECT(POINT(1, 2), POINT(3, 4))\n"
">>> r = RECT((1, 2), (3, 4))"
msgstr ""
">>> r = RECT(PUNKT(1, 2), PUNKT(3, 4))\n"
">>> r = RECT((1, 2), (3, 4))"

#: ../../library/ctypes.rst:661
msgid ""
"Field :term:`descriptor`\\s can be retrieved from the *class*, they are "
"useful for debugging because they can provide useful information::"
msgstr ""

#: ../../library/ctypes.rst:664
msgid ""
">>> print(POINT.x)\n"
"<Field type=c_long, ofs=0, size=4>\n"
">>> print(POINT.y)\n"
"<Field type=c_long, ofs=4, size=4>\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:675
msgid ""
":mod:`ctypes` does not support passing unions or structures with bit-fields "
"to functions by value.  While this may work on 32-bit x86, it's not "
"guaranteed by the library to work in the general case.  Unions and "
"structures with bit-fields should always be passed to functions by pointer."
msgstr ""
":mod:`ctypes` har inte stöd för att skicka unioner eller strukturer med "
"bitfält till funktioner med värde.  Även om detta kan fungera på 32-bitars "
"x86, garanteras det inte av biblioteket att det fungerar i det allmänna "
"fallet.  Unioner och strukturer med bitfält bör alltid skickas till "
"funktioner med pekare."

#: ../../library/ctypes.rst:681
msgid "Structure/union alignment and byte order"
msgstr ""

#: ../../library/ctypes.rst:683
msgid ""
"By default, Structure and Union fields are aligned in the same way the C "
"compiler does it. It is possible to override this behavior by specifying a :"
"attr:`~Structure._pack_` class attribute in the subclass definition. This "
"must be set to a positive integer and specifies the maximum alignment for "
"the fields. This is what ``#pragma pack(n)`` also does in MSVC. It is also "
"possible to set a minimum alignment for how the subclass itself is packed in "
"the same way ``#pragma align(n)`` works in MSVC. This can be achieved by "
"specifying a :attr:`~Structure._align_` class attribute in the subclass "
"definition."
msgstr ""

#: ../../library/ctypes.rst:693
msgid ""
":mod:`ctypes` uses the native byte order for Structures and Unions.  To "
"build structures with non-native byte order, you can use one of the :class:"
"`BigEndianStructure`, :class:`LittleEndianStructure`, :class:"
"`BigEndianUnion`, and :class:`LittleEndianUnion` base classes.  These "
"classes cannot contain pointer fields."
msgstr ""
":mod:`ctypes` använder den ursprungliga byteordningen för strukturer och "
"unioner.  Om du vill bygga strukturer med en annan byteordning kan du "
"använda någon av basklasserna :class:`BigEndianStructure`, :class:"
"`LittleEndianStructure`, :class:`BigEndianUnion` och :class:"
"`LittleEndianUnion`.  Dessa klasser kan inte innehålla pekarfält."

#: ../../library/ctypes.rst:703
msgid "Bit fields in structures and unions"
msgstr "Bitfält i strukturer och fackföreningar"

#: ../../library/ctypes.rst:705
msgid ""
"It is possible to create structures and unions containing bit fields. Bit "
"fields are only possible for integer fields, the bit width is specified as "
"the third item in the :attr:`~Structure._fields_` tuples::"
msgstr ""
"Det är möjligt att skapa strukturer och unioner som innehåller bitfält. "
"Bitfält är endast möjliga för heltalsfält, bitbredden anges som det tredje "
"objektet i :attr:`~Structure._fields_`-tuplerna::"

#: ../../library/ctypes.rst:709
msgid ""
">>> class Int(Structure):\n"
"...     _fields_ = [(\"first_16\", c_int, 16),\n"
"...                 (\"second_16\", c_int, 16)]\n"
"...\n"
">>> print(Int.first_16)\n"
"<Field type=c_long, ofs=0:0, bits=16>\n"
">>> print(Int.second_16)\n"
"<Field type=c_long, ofs=0:16, bits=16>\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:723
msgid "Arrays"
msgstr "Arrayer"

#: ../../library/ctypes.rst:725
msgid ""
"Arrays are sequences, containing a fixed number of instances of the same "
"type."
msgstr ""
"Arrayer är sekvenser som innehåller ett fast antal instanser av samma typ."

#: ../../library/ctypes.rst:727
msgid ""
"The recommended way to create array types is by multiplying a data type with "
"a positive integer::"
msgstr ""
"Det rekommenderade sättet att skapa array-typer är genom att multiplicera en "
"datatyp med ett positivt heltal::"

#: ../../library/ctypes.rst:730
msgid "TenPointsArrayType = POINT * 10"
msgstr "TenPointsArrayType = PUNKT * 10"

#: ../../library/ctypes.rst:732
msgid ""
"Here is an example of a somewhat artificial data type, a structure "
"containing 4 POINTs among other stuff::"
msgstr ""
"Här är ett exempel på en något artificiell datatyp, en struktur som bland "
"annat innehåller 4 POINTs::"

#: ../../library/ctypes.rst:735
msgid ""
">>> from ctypes import *\n"
">>> class POINT(Structure):\n"
"...     _fields_ = (\"x\", c_int), (\"y\", c_int)\n"
"...\n"
">>> class MyStruct(Structure):\n"
"...     _fields_ = [(\"a\", c_int),\n"
"...                 (\"b\", c_float),\n"
"...                 (\"point_array\", POINT * 4)]\n"
">>>\n"
">>> print(len(MyStruct().point_array))\n"
"4\n"
">>>"
msgstr ""
">>> från ctypes importera *\n"
">>> klass POINT(Struktur):\n"
"...     _fields_ = (\"x\", c_int), (\"y\", c_int)\n"
"...\n"
">>> klass MyStruct(Struktur):\n"
"...     _fields_ = [(\"a\", c_int),\n"
"... (\"b\", c_float),\n"
"... (\"point_array\", POINT * 4)]\n"
">>>\n"
">>> print(len(MyStruct().point_array))\n"
"4\n"
">>>"

#: ../../library/ctypes.rst:748
msgid "Instances are created in the usual way, by calling the class::"
msgstr "Instanser skapas på vanligt sätt, genom att anropa class::"

#: ../../library/ctypes.rst:750
msgid ""
"arr = TenPointsArrayType()\n"
"for pt in arr:\n"
"    print(pt.x, pt.y)"
msgstr ""
"arr = TenPointsArrayType()\n"
"för pt i arr:\n"
"    print(pt.x, pt.y)"

#: ../../library/ctypes.rst:754
msgid ""
"The above code print a series of ``0 0`` lines, because the array contents "
"is initialized to zeros."
msgstr ""
"Ovanstående kod skriver ut en serie ``0 0`` rader, eftersom matrisens "
"innehåll är initialiserat till nollor."

#: ../../library/ctypes.rst:757
msgid "Initializers of the correct type can also be specified::"
msgstr "Initialiserare av rätt typ kan också anges::"

#: ../../library/ctypes.rst:759
msgid ""
">>> from ctypes import *\n"
">>> TenIntegers = c_int * 10\n"
">>> ii = TenIntegers(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n"
">>> print(ii)\n"
"<c_long_Array_10 object at 0x...>\n"
">>> for i in ii: print(i, end=\" \")\n"
"...\n"
"1 2 3 4 5 6 7 8 9 10\n"
">>>"
msgstr ""
">>> från ctypes import *\n"
">>> TenIntegers = c_int * 10\n"
">>> ii = TenIntegers(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n"
">>> print(ii)\n"
"<c_long_Array_10-objekt vid 0x...> >>> för i i ii\n"
">>> for i in ii: print(i, end=\" \")\n"
"...\n"
"1 2 3 4 5 6 7 8 9 10\n"
">>>"

#: ../../library/ctypes.rst:773
msgid "Pointers"
msgstr "Pekare"

#: ../../library/ctypes.rst:775
msgid ""
"Pointer instances are created by calling the :func:`pointer` function on a :"
"mod:`ctypes` type::"
msgstr ""
"Pekarinstanser skapas genom att anropa funktionen :func:`pointer` på en :mod:"
"`ctypes`-typ::"

#: ../../library/ctypes.rst:778
msgid ""
">>> from ctypes import *\n"
">>> i = c_int(42)\n"
">>> pi = pointer(i)\n"
">>>"
msgstr ""
">>> från ctypes import *\n"
">>> i = c_int(42)\n"
">>> pi = pekare(i)\n"
">>>"

#: ../../library/ctypes.rst:783
msgid ""
"Pointer instances have a :attr:`~_Pointer.contents` attribute which returns "
"the object to which the pointer points, the ``i`` object above::"
msgstr ""
"Pekarinstanser har ett :attr:`~_Pointer.contents`-attribut som returnerar "
"det objekt som pekaren pekar på, ``i``-objektet ovan::"

#: ../../library/ctypes.rst:786
msgid ""
">>> pi.contents\n"
"c_long(42)\n"
">>>"
msgstr ""
">>> pi.innehåll\n"
"c_long(42)\n"
">>>"

#: ../../library/ctypes.rst:790
msgid ""
"Note that :mod:`ctypes` does not have OOR (original object return), it "
"constructs a new, equivalent object each time you retrieve an attribute::"
msgstr ""
"Observera att :mod:`ctypes` inte har OOR (original object return), utan "
"konstruerar ett nytt, likvärdigt objekt varje gång du hämtar ett attribut::"

#: ../../library/ctypes.rst:793
msgid ""
">>> pi.contents is i\n"
"False\n"
">>> pi.contents is pi.contents\n"
"False\n"
">>>"
msgstr ""
">>> pi.innehåll är i\n"
"Falskt\n"
">>> pi.innehåll är pi.innehåll\n"
"Falskt\n"
">>>"

#: ../../library/ctypes.rst:799
msgid ""
"Assigning another :class:`c_int` instance to the pointer's contents "
"attribute would cause the pointer to point to the memory location where this "
"is stored::"
msgstr ""
"Om du tilldelar en annan :class:`c_int`-instans till pekarens "
"innehållsattribut skulle pekaren peka på den minnesplats där detta är "
"lagrat::"

#: ../../library/ctypes.rst:802
msgid ""
">>> i = c_int(99)\n"
">>> pi.contents = i\n"
">>> pi.contents\n"
"c_long(99)\n"
">>>"
msgstr ""
">>> i = c_int(99)\n"
">>> pi.innehåll = i\n"
">>> pi.innehåll\n"
"c_long(99)\n"
">>>"

#: ../../library/ctypes.rst:811
msgid "Pointer instances can also be indexed with integers::"
msgstr "Pekarinstanser kan också indexeras med heltal::"

#: ../../library/ctypes.rst:813
msgid ""
">>> pi[0]\n"
"99\n"
">>>"
msgstr ""
">>> pi[0]\n"
"99\n"
">>>"

#: ../../library/ctypes.rst:817
msgid "Assigning to an integer index changes the pointed to value::"
msgstr "Genom att tilldela ett heltalsindex ändras det pekade till värdet::"

#: ../../library/ctypes.rst:819
msgid ""
">>> print(i)\n"
"c_long(99)\n"
">>> pi[0] = 22\n"
">>> print(i)\n"
"c_long(22)\n"
">>>"
msgstr ""
">>> skriv ut(i)\n"
"c_long(99)\n"
">>> pi[0] = 22\n"
">>> skriv ut(i)\n"
"c_long(22)\n"
">>>"

#: ../../library/ctypes.rst:826
msgid ""
"It is also possible to use indexes different from 0, but you must know what "
"you're doing, just as in C: You can access or change arbitrary memory "
"locations. Generally you only use this feature if you receive a pointer from "
"a C function, and you *know* that the pointer actually points to an array "
"instead of a single item."
msgstr ""
"Det är också möjligt att använda index som skiljer sig från 0, men du måste "
"veta vad du gör, precis som i C: Du kan komma åt eller ändra godtyckliga "
"minnesplatser. I allmänhet använder du bara den här funktionen om du får en "
"pekare från en C-funktion och du *vet* att pekaren faktiskt pekar på en "
"array i stället för på ett enda objekt."

#: ../../library/ctypes.rst:832
msgid ""
"Behind the scenes, the :func:`pointer` function does more than simply create "
"pointer instances, it has to create pointer *types* first. This is done with "
"the :func:`POINTER` function, which accepts any :mod:`ctypes` type, and "
"returns a new type::"
msgstr ""
"Bakom kulisserna gör funktionen :func:`pointer` mer än att bara skapa "
"pekarinstanser, den måste först skapa pekar*typer*. Detta görs med "
"funktionen :func:`POINTER`, som accepterar vilken typ som helst av :mod:"
"`ctypes` och returnerar en ny typ::"

#: ../../library/ctypes.rst:837
msgid ""
">>> PI = POINTER(c_int)\n"
">>> PI\n"
"<class 'ctypes.LP_c_long'>\n"
">>> PI(42)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: expected c_long instead of int\n"
">>> PI(c_int(42))\n"
"<ctypes.LP_c_long object at 0x...>\n"
">>>"
msgstr ""
"&gt;&gt;&gt; PI = POINTER(c_int)\n"
"&gt;&gt;&gt; PI\n"
"<class 'ctypes.LP_c_long'>\n"
"&gt;&gt;&gt; PI(42)\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"TypeError: förväntade c_long istället för int\n"
"&gt;&gt;&gt; PI(c_int(42))\n"
"<ctypes.LP_c_long object at 0x...>\n"
"&gt;&gt;&gt"

#: ../../library/ctypes.rst:848
msgid ""
"Calling the pointer type without an argument creates a ``NULL`` pointer. "
"``NULL`` pointers have a ``False`` boolean value::"
msgstr ""
"Anrop av pekartypen utan ett argument skapar en ``NULL``-pekare. ``NULL`` "
"pekare har ett ``False`` boolean värde::"

#: ../../library/ctypes.rst:851
msgid ""
">>> null_ptr = POINTER(c_int)()\n"
">>> print(bool(null_ptr))\n"
"False\n"
">>>"
msgstr ""
">>> null_ptr = POINTER(c_int)()\n"
">>> print(bool(null_ptr))\n"
"Falsk\n"
">>>"

#: ../../library/ctypes.rst:856
msgid ""
":mod:`ctypes` checks for ``NULL`` when dereferencing pointers (but "
"dereferencing invalid non-\\ ``NULL`` pointers would crash Python)::"
msgstr ""
":mod:`ctypes` kontrollerar för ``NULL`` vid dereferencing av pekare (men "
"dereferencing av ogiltiga icke ``NULL`` pekare skulle krascha Python)::"

#: ../../library/ctypes.rst:859
msgid ""
">>> null_ptr[0]\n"
"Traceback (most recent call last):\n"
"    ....\n"
"ValueError: NULL pointer access\n"
">>>\n"
"\n"
">>> null_ptr[0] = 1234\n"
"Traceback (most recent call last):\n"
"    ....\n"
"ValueError: NULL pointer access\n"
">>>"
msgstr ""
">>> null_ptr[0]\n"
"Traceback (senaste anropet senast):\n"
"    ....\n"
"Värdefel: Tillgång till NULL-pekare\n"
">>>\n"
"\n"
">>> null_ptr[0] = 1234\n"
"Traceback (senaste anropet senast):\n"
"    ....\n"
"Värdefel (ValueError): Tillgång till NULL-pekare\n"
">>>"

#: ../../library/ctypes.rst:875
msgid "Type conversions"
msgstr "Typkonverteringar"

#: ../../library/ctypes.rst:877
msgid ""
"Usually, ctypes does strict type checking.  This means, if you have "
"``POINTER(c_int)`` in the :attr:`~_CFuncPtr.argtypes` list of a function or "
"as the type of a member field in a structure definition, only instances of "
"exactly the same type are accepted.  There are some exceptions to this rule, "
"where ctypes accepts other objects.  For example, you can pass compatible "
"array instances instead of pointer types.  So, for ``POINTER(c_int)``, "
"ctypes accepts an array of c_int::"
msgstr ""
"Vanligtvis gör ctypes en strikt typkontroll.  Detta innebär att om du har "
"``POINTER(c_int)`` i :attr:`~_CFuncPtr.argtypes`-listan för en funktion "
"eller som typ för ett medlemsfält i en strukturdefinition, accepteras endast "
"instanser av exakt samma typ.  Det finns några undantag från denna regel, "
"där ctypes accepterar andra objekt.  Du kan t.ex. skicka kompatibla array-"
"instanser i stället för pekartyper.  Så för ``POINTER(c_int)`` accepterar "
"ctypes en array av c_int::"

#: ../../library/ctypes.rst:884
msgid ""
">>> class Bar(Structure):\n"
"...     _fields_ = [(\"count\", c_int), (\"values\", POINTER(c_int))]\n"
"...\n"
">>> bar = Bar()\n"
">>> bar.values = (c_int * 3)(1, 2, 3)\n"
">>> bar.count = 3\n"
">>> for i in range(bar.count):\n"
"...     print(bar.values[i])\n"
"...\n"
"1\n"
"2\n"
"3\n"
">>>"
msgstr ""
">>> klass Bar(Struktur):\n"
"...     _fields_ = [(\"count\", c_int), (\"values\", POINTER(c_int))]\n"
"...\n"
">>> bar = Bar()\n"
">>> bar.värden = (c_int * 3)(1, 2, 3)\n"
">>> bar.count = 3\n"
">>> for i in range(bar.count):\n"
"... print(bar.värden[i])\n"
"...\n"
"1\n"
"2\n"
"3\n"
">>>"

#: ../../library/ctypes.rst:898
msgid ""
"In addition, if a function argument is explicitly declared to be a pointer "
"type (such as ``POINTER(c_int)``) in :attr:`~_CFuncPtr.argtypes`, an object "
"of the pointed type (``c_int`` in this case) can be passed to the function.  "
"ctypes will apply the required :func:`byref` conversion in this case "
"automatically."
msgstr ""
"Dessutom, om ett funktionsargument uttryckligen deklareras vara en pekartyp "
"(t.ex. ``POINTER(c_int)``) i :attr:`~_CFuncPtr.argtypes`, kan ett objekt av "
"pekartypen (``c_int`` i detta fall) skickas till funktionen. ctypes kommer "
"att tillämpa den nödvändiga :func:`byref`-konverteringen i detta fall "
"automatiskt."

#: ../../library/ctypes.rst:903
msgid "To set a POINTER type field to ``NULL``, you can assign ``None``::"
msgstr ""
"För att ställa in ett fält av typen POINTER till ``NULL`` kan du tilldela "
"``None``::"

#: ../../library/ctypes.rst:905
msgid ""
">>> bar.values = None\n"
">>>"
msgstr ""
">>> bar.värden = Ingen\n"
">>>"

#: ../../library/ctypes.rst:910
msgid ""
"Sometimes you have instances of incompatible types.  In C, you can cast one "
"type into another type.  :mod:`ctypes` provides a :func:`cast` function "
"which can be used in the same way.  The ``Bar`` structure defined above "
"accepts ``POINTER(c_int)`` pointers or :class:`c_int` arrays for its "
"``values`` field, but not instances of other types::"
msgstr ""
"Ibland har man instanser av inkompatibla typer.  I C kan du casta en typ "
"till en annan typ. :mod:`ctypes` tillhandahåller en :func:`cast`-funktion "
"som kan användas på samma sätt.  Strukturen ``Bar`` som definieras ovan "
"accepterar ``POINTER(c_int)`` pekare eller :class:`c_int` matriser för sitt "
"``values`` fält, men inte instanser av andra typer::"

#: ../../library/ctypes.rst:916
msgid ""
">>> bar.values = (c_byte * 4)()\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: incompatible types, c_byte_Array_4 instance instead of LP_c_long "
"instance\n"
">>>"
msgstr ""
"&gt;&gt;&gt; bar.värden = (c_byte * 4)()\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"TypeError: inkompatibla typer, c_byte_Array_4-instans istället för LP_c_long-"
"instans\n"
"&gt;&gt;&gt"

#: ../../library/ctypes.rst:922
msgid "For these cases, the :func:`cast` function is handy."
msgstr "I dessa fall är funktionen :func:`cast` praktisk."

#: ../../library/ctypes.rst:924
msgid ""
"The :func:`cast` function can be used to cast a ctypes instance into a "
"pointer to a different ctypes data type.  :func:`cast` takes two parameters, "
"a ctypes object that is or can be converted to a pointer of some kind, and a "
"ctypes pointer type.  It returns an instance of the second argument, which "
"references the same memory block as the first argument::"
msgstr ""
"Funktionen :func:`cast` kan användas för att casta en ctypes-instans till en "
"pekare på en annan ctypes-datatyp. :func:`cast` tar två parametrar, ett "
"ctypes-objekt som är eller kan konverteras till en pekare av något slag och "
"en ctypes-pekartyp.  Den returnerar en instans av det andra argumentet, som "
"refererar till samma minnesblock som det första argumentet::"

#: ../../library/ctypes.rst:930
msgid ""
">>> a = (c_byte * 4)()\n"
">>> cast(a, POINTER(c_int))\n"
"<ctypes.LP_c_long object at ...>\n"
">>>"
msgstr ""
">>> a = (c_byte * 4)()\n"
">>> cast(a, POINTER(c_int))\n"
"<ctypes.LP_c_long-objekt vid ...>\n"
">>>"

#: ../../library/ctypes.rst:935
msgid ""
"So, :func:`cast` can be used to assign to the ``values`` field of ``Bar`` "
"the structure::"
msgstr ""
"Så :func:`cast` kan användas för att tilldela fältet ``values`` i ``Bar`` "
"strukturen::"

#: ../../library/ctypes.rst:938
msgid ""
">>> bar = Bar()\n"
">>> bar.values = cast((c_byte * 4)(), POINTER(c_int))\n"
">>> print(bar.values[0])\n"
"0\n"
">>>"
msgstr ""
">>> bar = Bar()\n"
">>> bar.values = cast((c_byte * 4)(), POINTER(c_int))\n"
">>> print(bar.värden[0])\n"
"0\n"
">>>"

#: ../../library/ctypes.rst:948
msgid "Incomplete Types"
msgstr "Ofullständiga typer"

#: ../../library/ctypes.rst:950
msgid ""
"*Incomplete Types* are structures, unions or arrays whose members are not "
"yet specified. In C, they are specified by forward declarations, which are "
"defined later::"
msgstr ""
"*Ofullständiga typer* är strukturer, unioner eller matriser vars medlemmar "
"ännu inte har specificerats. I C specificeras de genom forward-"
"deklarationer, som definieras senare::"

#: ../../library/ctypes.rst:954
msgid ""
"struct cell; /* forward declaration */\n"
"\n"
"struct cell {\n"
"    char *name;\n"
"    struct cell *next;\n"
"};"
msgstr ""
"struct cell; /* framåtdeklaration */\n"
"\n"
"struct cell {\n"
"    char *namn;\n"
"    strukturcell *nästa;\n"
"};"

#: ../../library/ctypes.rst:961
msgid ""
"The straightforward translation into ctypes code would be this, but it does "
"not work::"
msgstr ""
"Den raka översättningen till ctypes-kod skulle vara denna, men det fungerar "
"inte::"

#: ../../library/ctypes.rst:964
msgid ""
">>> class cell(Structure):\n"
"...     _fields_ = [(\"name\", c_char_p),\n"
"...                 (\"next\", POINTER(cell))]\n"
"...\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"<stdin>\", line 2, in cell\n"
"NameError: name 'cell' is not defined\n"
">>>"
msgstr ""
"&gt;&gt;&gt; klass cell(Struktur):\n"
"...     _fields_ = [(\"name\", c_char_p),\n"
"... (\"next\", POINTER(cell))]\n"
"...\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"  Fil \"<stdin>\", rad 2, i cell\n"
"NameError: namnet 'cell' är inte definierat\n"
"&gt;&gt;&gt"

#: ../../library/ctypes.rst:974
msgid ""
"because the new ``class cell`` is not available in the class statement "
"itself. In :mod:`ctypes`, we can define the ``cell`` class and set the :attr:"
"`~Structure._fields_` attribute later, after the class statement::"
msgstr ""
"eftersom den nya ``class cell`` inte är tillgänglig i själva "
"klassuttalandet. I :mod:`ctypes` kan vi definiera klassen ``cell`` och "
"ställa in attributet :attr:`~Structure._fields_` senare, efter "
"klassuttalandet::"

#: ../../library/ctypes.rst:978
msgid ""
">>> from ctypes import *\n"
">>> class cell(Structure):\n"
"...     pass\n"
"...\n"
">>> cell._fields_ = [(\"name\", c_char_p),\n"
"...                  (\"next\", POINTER(cell))]\n"
">>>"
msgstr ""
">>> från ctypes importera *\n"
">>> klass cell(Struktur):\n"
"... pass\n"
"...\n"
">>> cell._fields_ = [(\"name\", c_char_p),\n"
"... (\"next\", POINTER(cell))]\n"
">>>"

#: ../../library/ctypes.rst:986
msgid ""
"Let's try it. We create two instances of ``cell``, and let them point to "
"each other, and finally follow the pointer chain a few times::"
msgstr ""
"Låt oss prova det. Vi skapar två instanser av ``cell``, och låter dem peka "
"på varandra, och följer slutligen pekarkedjan några gånger::"

#: ../../library/ctypes.rst:989
msgid ""
">>> c1 = cell()\n"
">>> c1.name = b\"foo\"\n"
">>> c2 = cell()\n"
">>> c2.name = b\"bar\"\n"
">>> c1.next = pointer(c2)\n"
">>> c2.next = pointer(c1)\n"
">>> p = c1\n"
">>> for i in range(8):\n"
"...     print(p.name, end=\" \")\n"
"...     p = p.next[0]\n"
"...\n"
"foo bar foo bar foo bar foo bar\n"
">>>"
msgstr ""
">>> c1 = cell()\n"
">>> c1.namn = b\"foo\"\n"
">>> c2 = cell()\n"
">>> c2.namn = b\"bar\"\n"
">>> c1.nästa = pekare(c2)\n"
">>> c2.nästa = pekare(c1)\n"
">>> p = c1\n"
">>> för i i intervall(8):\n"
"... print(p.namn, end=\" \")\n"
"... p = p.nästa[0]\n"
"...\n"
"foo bar foo bar foo bar foo bar foo bar\n"
">>>"

#: ../../library/ctypes.rst:1007
msgid "Callback functions"
msgstr "Återkallelsefunktioner"

#: ../../library/ctypes.rst:1009
msgid ""
":mod:`ctypes` allows creating C callable function pointers from Python "
"callables. These are sometimes called *callback functions*."
msgstr ""
":mod:`ctypes` gör det möjligt att skapa C-kallbara funktionspoängare från "
"Python-kallbara funktioner. Dessa kallas ibland för *callback-funktioner*."

#: ../../library/ctypes.rst:1012
msgid ""
"First, you must create a class for the callback function. The class knows "
"the calling convention, the return type, and the number and types of "
"arguments this function will receive."
msgstr ""
"Först måste du skapa en klass för återuppringningsfunktionen. Klassen känner "
"till anropskonventionen, returtypen och antalet och typerna av argument som "
"denna funktion kommer att ta emot."

#: ../../library/ctypes.rst:1016
msgid ""
"The :func:`CFUNCTYPE` factory function creates types for callback functions "
"using the ``cdecl`` calling convention. On Windows, the :func:`WINFUNCTYPE` "
"factory function creates types for callback functions using the ``stdcall`` "
"calling convention."
msgstr ""
"Fabriksfunktionen :func:`CFUNCTYPE` skapar typer för "
"återuppringningsfunktioner med hjälp av anropskonventionen ``cdecl``. I "
"Windows skapar fabriksfunktionen :func:`WINFUNCTYPE` typer för "
"återkallningsfunktioner med hjälp av anropskonventionen ``stdcall``."

#: ../../library/ctypes.rst:1021
msgid ""
"Both of these factory functions are called with the result type as first "
"argument, and the callback functions expected argument types as the "
"remaining arguments."
msgstr ""
"Båda dessa fabriksfunktioner anropas med resultattypen som första argument, "
"och callback-funktionernas förväntade argumenttyper som resterande argument."

#: ../../library/ctypes.rst:1025
msgid ""
"I will present an example here which uses the standard C library's :c:func:`!"
"qsort` function, that is used to sort items with the help of a callback "
"function.  :c:func:`!qsort` will be used to sort an array of integers::"
msgstr ""
"Jag kommer här att presentera ett exempel som använder standard C-"
"bibliotekets :c:func:`!qsort`-funktion, som används för att sortera objekt "
"med hjälp av en callback-funktion. :c:func:`!qsort` kommer att användas för "
"att sortera en array av heltal::"

#: ../../library/ctypes.rst:1029
msgid ""
">>> IntArray5 = c_int * 5\n"
">>> ia = IntArray5(5, 1, 7, 33, 99)\n"
">>> qsort = libc.qsort\n"
">>> qsort.restype = None\n"
">>>"
msgstr ""
">>> IntArray5 = c_int * 5\n"
">>> ia = IntArray5(5, 1, 7, 33, 99)\n"
">>> qsort = libc.qsort\n"
">>> qsort.restype = Ingen\n"
">>>"

#: ../../library/ctypes.rst:1035
msgid ""
":func:`!qsort` must be called with a pointer to the data to sort, the number "
"of items in the data array, the size of one item, and a pointer to the "
"comparison function, the callback. The callback will then be called with two "
"pointers to items, and it must return a negative integer if the first item "
"is smaller than the second, a zero if they are equal, and a positive integer "
"otherwise."
msgstr ""
":func:`!qsort` måste anropas med en pekare till de data som skall sorteras, "
"antalet objekt i dataarrayen, storleken på ett objekt och en pekare till "
"jämförelsefunktionen, callback. Callbacken anropas sedan med två pekare till "
"objekt och måste returnera ett negativt heltal om det första objektet är "
"mindre än det andra, en nolla om de är lika stora och ett positivt heltal "
"annars."

#: ../../library/ctypes.rst:1041
msgid ""
"So our callback function receives pointers to integers, and must return an "
"integer. First we create the ``type`` for the callback function::"
msgstr ""
"Så vår callback-funktion tar emot pekare till heltal och måste returnera ett "
"heltal. Först skapar vi ``typ`` för callback-funktionen::"

#: ../../library/ctypes.rst:1044
msgid ""
">>> CMPFUNC = CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))\n"
">>>"
msgstr ""
">>> CMPFUNC = CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))\n"
">>>"

#: ../../library/ctypes.rst:1047
msgid ""
"To get started, here is a simple callback that shows the values it gets "
"passed::"
msgstr ""
"För att komma igång, här är en enkel callback som visar de värden den får "
"skickade till sig::"

#: ../../library/ctypes.rst:1050
msgid ""
">>> def py_cmp_func(a, b):\n"
"...     print(\"py_cmp_func\", a[0], b[0])\n"
"...     return 0\n"
"...\n"
">>> cmp_func = CMPFUNC(py_cmp_func)\n"
">>>"
msgstr ""
">>> def py_cmp_func(a, b):\n"
"... print(\"py_cmp_func\", a[0], b[0])\n"
"... return 0\n"
"...\n"
">>> cmp_func = CMPFUNC(py_cmp_func)\n"
">>>"

#: ../../library/ctypes.rst:1057
msgid "The result::"
msgstr "Resultatet::"

#: ../../library/ctypes.rst:1059
msgid ""
">>> qsort(ia, len(ia), sizeof(c_int), cmp_func)\n"
"py_cmp_func 5 1\n"
"py_cmp_func 33 99\n"
"py_cmp_func 7 33\n"
"py_cmp_func 5 7\n"
"py_cmp_func 1 7\n"
">>>"
msgstr ""
">>> qsort(ia, len(ia), sizeof(c_int), cmp_func)\n"
"py_cmp_func 5 1\n"
"py_cmp_func 33 99\n"
"py_cmp_func 7 33\n"
"py_cmp_func 5 7\n"
"py_cmp_func 1 7\n"
">>>"

#: ../../library/ctypes.rst:1067
msgid "Now we can actually compare the two items and return a useful result::"
msgstr ""
"Nu kan vi faktiskt jämföra de två objekten och returnera ett användbart "
"resultat::"

#: ../../library/ctypes.rst:1069
msgid ""
">>> def py_cmp_func(a, b):\n"
"...     print(\"py_cmp_func\", a[0], b[0])\n"
"...     return a[0] - b[0]\n"
"...\n"
">>>\n"
">>> qsort(ia, len(ia), sizeof(c_int), CMPFUNC(py_cmp_func))\n"
"py_cmp_func 5 1\n"
"py_cmp_func 33 99\n"
"py_cmp_func 7 33\n"
"py_cmp_func 1 7\n"
"py_cmp_func 5 7\n"
">>>"
msgstr ""
">>> def py_cmp_func(a, b):\n"
"... print(\"py_cmp_func\", a[0], b[0])\n"
"... return a[0] - b[0]\n"
"...\n"
">>>\n"
">>> qsort(ia, len(ia), sizeof(c_int), CMPFUNC(py_cmp_func))\n"
"py_cmp_func 5 1\n"
"py_cmp_func 33 99\n"
"py_cmp_func 7 33\n"
"py_cmp_func 1 7\n"
"py_cmp_func 5 7\n"
">>>"

#: ../../library/ctypes.rst:1082
msgid "As we can easily check, our array is sorted now::"
msgstr "Som vi lätt kan kontrollera är vår matris nu sorterad::"

#: ../../library/ctypes.rst:1084
msgid ""
">>> for i in ia: print(i, end=\" \")\n"
"...\n"
"1 5 7 33 99\n"
">>>"
msgstr ""
">>> for i in ia: print(i, end=\" \")\n"
"...\n"
"1 5 7 33 99\n"
">>>"

#: ../../library/ctypes.rst:1089
msgid ""
"The function factories can be used as decorator factories, so we may as well "
"write::"
msgstr ""
"Funktionsfabrikerna kan användas som dekoratorfabriker, så vi kan lika gärna "
"skriva::"

#: ../../library/ctypes.rst:1092
msgid ""
">>> @CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))\n"
"... def py_cmp_func(a, b):\n"
"...     print(\"py_cmp_func\", a[0], b[0])\n"
"...     return a[0] - b[0]\n"
"...\n"
">>> qsort(ia, len(ia), sizeof(c_int), py_cmp_func)\n"
"py_cmp_func 5 1\n"
"py_cmp_func 33 99\n"
"py_cmp_func 7 33\n"
"py_cmp_func 1 7\n"
"py_cmp_func 5 7\n"
">>>"
msgstr ""
">>> @CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))\n"
"... def py_cmp_func(a, b):\n"
"... print(\"py_cmp_func\", a[0], b[0])\n"
"... return a[0] - b[0]\n"
"...\n"
">>> qsort(ia, len(ia), sizeof(c_int), py_cmp_func)\n"
"py_cmp_func 5 1\n"
"py_cmp_func 33 99\n"
"py_cmp_func 7 33\n"
"py_cmp_func 1 7\n"
"py_cmp_func 5 7\n"
">>>"

#: ../../library/ctypes.rst:1107
msgid ""
"Make sure you keep references to :func:`CFUNCTYPE` objects as long as they "
"are used from C code. :mod:`ctypes` doesn't, and if you don't, they may be "
"garbage collected, crashing your program when a callback is made."
msgstr ""
"Se till att du behåller referenser till :func:`CFUNCTYPE`-objekt så länge "
"som de används från C-kod. :mod:`ctypes` gör inte det, och om du inte gör "
"det kan de bli garbage collected, vilket kraschar ditt program när en "
"callback görs."

#: ../../library/ctypes.rst:1111
msgid ""
"Also, note that if the callback function is called in a thread created "
"outside of Python's control (e.g. by the foreign code that calls the "
"callback), ctypes creates a new dummy Python thread on every invocation. "
"This behavior is correct for most purposes, but it means that values stored "
"with :class:`threading.local` will *not* survive across different callbacks, "
"even when those calls are made from the same C thread."
msgstr ""
"Observera också att om återuppringningsfunktionen anropas i en tråd som "
"skapats utanför Pythons kontroll (t.ex. av den utländska kod som anropar "
"återuppringningen), skapar ctypes en ny dummy Python-tråd vid varje anrop. "
"Detta beteende är korrekt för de flesta ändamål, men det innebär att värden "
"som lagras med :class:`threading.local` *inte* kommer att överleva mellan "
"olika anrop, även när dessa anrop görs från samma C-tråd."

#: ../../library/ctypes.rst:1121
msgid "Accessing values exported from dlls"
msgstr "Tillgång till värden exporterade från dll-filer"

#: ../../library/ctypes.rst:1123
msgid ""
"Some shared libraries not only export functions, they also export variables. "
"An example in the Python library itself is the :c:data:`Py_Version`, Python "
"runtime version number encoded in a single constant integer."
msgstr ""
"Vissa delade bibliotek exporterar inte bara funktioner, utan även variabler. "
"Ett exempel i själva Python-biblioteket är :c:data:`Py_Version`, Pythons "
"versionsnummer för runtime kodat i ett enda konstant heltal."

#: ../../library/ctypes.rst:1127
msgid ""
":mod:`ctypes` can access values like this with the :meth:`~_CData.in_dll` "
"class methods of the type.  *pythonapi* is a predefined symbol giving access "
"to the Python C api::"
msgstr ""
":mod:`ctypes` kan komma åt värden som detta med :meth:`~_CData.in_dll` "
"klassmetoderna för typen.  *pythonapi* är en fördefinierad symbol som ger "
"tillgång till Python C api::"

#: ../../library/ctypes.rst:1131
msgid ""
">>> version = ctypes.c_int.in_dll(ctypes.pythonapi, \"Py_Version\")\n"
">>> print(hex(version.value))\n"
"0x30c00a0"
msgstr ""
">>> version = ctypes.c_int.in_dll(ctypes.pythonapi, \"Py_Version\")\n"
">>> print(hex(version.värde))\n"
"0x30c00a0"

#: ../../library/ctypes.rst:1135
msgid ""
"An extended example which also demonstrates the use of pointers accesses "
"the :c:data:`PyImport_FrozenModules` pointer exported by Python."
msgstr ""
"Ett utökat exempel som också demonstrerar användningen av pekare kommer åt :"
"c:data:`PyImport_FrozenModules`-pekaren som exporteras av Python."

#: ../../library/ctypes.rst:1138
msgid "Quoting the docs for that value:"
msgstr "Citerar dokumenten för det värdet:"

#: ../../library/ctypes.rst:1140
msgid ""
"This pointer is initialized to point to an array of :c:struct:`_frozen` "
"records, terminated by one whose members are all ``NULL`` or zero.  When a "
"frozen module is imported, it is searched in this table.  Third-party code "
"could play tricks with this to provide a dynamically created collection of "
"frozen modules."
msgstr ""
"Denna pekare initialiseras så att den pekar på en array av :c:struct:"
"`_frozen`\\-poster, som avslutas med en post vars alla medlemmar är ``NULL`` "
"eller noll.  När en fryst modul importeras söks den i den här tabellen.  "
"Tredjepartskod kan använda detta för att skapa en dynamiskt skapad samling "
"av frysta moduler."

#: ../../library/ctypes.rst:1145
msgid ""
"So manipulating this pointer could even prove useful. To restrict the "
"example size, we show only how this table can be read with :mod:`ctypes`::"
msgstr ""
"Så att manipulera denna pekare kan till och med visa sig vara användbart. "
"För att begränsa exemplets storlek visar vi bara hur denna tabell kan läsas "
"med :mod:`ctypes`::"

#: ../../library/ctypes.rst:1148
msgid ""
">>> from ctypes import *\n"
">>>\n"
">>> class struct_frozen(Structure):\n"
"...     _fields_ = [(\"name\", c_char_p),\n"
"...                 (\"code\", POINTER(c_ubyte)),\n"
"...                 (\"size\", c_int),\n"
"...                 (\"get_code\", POINTER(c_ubyte)),  # Function pointer\n"
"...                ]\n"
"...\n"
">>>"
msgstr ""
">>> från ctypes import *\n"
">>>\n"
">>> klass struct_frozen(Struktur):\n"
"...     _fields_ = [(\"name\", c_char_p),\n"
"... (\"code\", POINTER(c_ubyte)),\n"
"... (\"size\", c_int),\n"
"... (\"get_code\", POINTER(c_ubyte)), # Funktionspekare\n"
"...                ]\n"
"...\n"
">>>"

#: ../../library/ctypes.rst:1159
msgid ""
"We have defined the :c:struct:`_frozen` data type, so we can get the pointer "
"to the table::"
msgstr ""
"Vi har definierat datatypen :c:struct:`_frozen`, så vi kan hämta pekaren "
"till tabellen::"

#: ../../library/ctypes.rst:1162
msgid ""
">>> FrozenTable = POINTER(struct_frozen)\n"
">>> table = FrozenTable.in_dll(pythonapi, \"_PyImport_FrozenBootstrap\")\n"
">>>"
msgstr ""
">>> FrozenTable = POINTER(struct_frozen)\n"
">>> tabell = FrozenTable.in_dll(pythonapi, \"_PyImport_FrozenBootstrap\")\n"
">>>"

#: ../../library/ctypes.rst:1166
msgid ""
"Since ``table`` is a ``pointer`` to the array of ``struct_frozen`` records, "
"we can iterate over it, but we just have to make sure that our loop "
"terminates, because pointers have no size. Sooner or later it would probably "
"crash with an access violation or whatever, so it's better to break out of "
"the loop when we hit the ``NULL`` entry::"
msgstr ""
"Eftersom ``table`` är en ``pekare`` till arrayen av ``struct_frozen``-poster "
"kan vi iterera över den, men vi måste bara se till att vår slinga avslutas, "
"eftersom pekare inte har någon storlek. Förr eller senare skulle det "
"förmodligen krascha med en access violation eller vad som helst, så det är "
"bättre att bryta sig ur slingan när vi träffar ``NULL``-ingången::"

#: ../../library/ctypes.rst:1172
msgid ""
">>> for item in table:\n"
"...     if item.name is None:\n"
"...         break\n"
"...     print(item.name.decode(\"ascii\"), item.size)\n"
"...\n"
"_frozen_importlib 31764\n"
"_frozen_importlib_external 41499\n"
"zipimport 12345\n"
">>>"
msgstr ""
">>> för objekt i tabellen:\n"
"... om item.name är None:\n"
"... break\n"
"... print(objekt.namn.decode(\"ascii\")), objekt.storlek)\n"
"...\n"
"_frozen_importlib 31764\n"
"_frozen_importlib_external 41499\n"
"zipimport 12345\n"
">>>"

#: ../../library/ctypes.rst:1182
msgid ""
"The fact that standard Python has a frozen module and a frozen package "
"(indicated by the negative ``size`` member) is not well known, it is only "
"used for testing. Try it out with ``import __hello__`` for example."
msgstr ""
"Det faktum att standard Python har en frusen modul och ett fruset paket "
"(indikeras av den negativa ``size``-medlemmen) är inte välkänt, det används "
"bara för testning. Prova det till exempel med ``import __hello__``."

#: ../../library/ctypes.rst:1190
msgid "Surprises"
msgstr "Överraskningar"

#: ../../library/ctypes.rst:1192
msgid ""
"There are some edges in :mod:`ctypes` where you might expect something other "
"than what actually happens."
msgstr ""
"Det finns vissa kanter i :mod:`ctypes` där man kan förvänta sig något annat "
"än vad som faktiskt händer."

#: ../../library/ctypes.rst:1195
msgid "Consider the following example::"
msgstr "Tänk på följande exempel::"

#: ../../library/ctypes.rst:1197
msgid ""
">>> from ctypes import *\n"
">>> class POINT(Structure):\n"
"...     _fields_ = (\"x\", c_int), (\"y\", c_int)\n"
"...\n"
">>> class RECT(Structure):\n"
"...     _fields_ = (\"a\", POINT), (\"b\", POINT)\n"
"...\n"
">>> p1 = POINT(1, 2)\n"
">>> p2 = POINT(3, 4)\n"
">>> rc = RECT(p1, p2)\n"
">>> print(rc.a.x, rc.a.y, rc.b.x, rc.b.y)\n"
"1 2 3 4\n"
">>> # now swap the two points\n"
">>> rc.a, rc.b = rc.b, rc.a\n"
">>> print(rc.a.x, rc.a.y, rc.b.x, rc.b.y)\n"
"3 4 3 4\n"
">>>"
msgstr ""
">>> från ctypes importera *\n"
">>> klass POINT(Struktur):\n"
"...     _fields_ = (\"x\", c_int), (\"y\", c_int)\n"
"...\n"
">>> klass RECT(Struktur):\n"
"...     _fields_ = (\"a\", POINT), (\"b\", POINT)\n"
"...\n"
">>> p1 = POINT(1, 2)\n"
">>> p2 = POINT(3, 4)\n"
">>> rc = RECT(p1, p2)\n"
">>> print(rc.a.x, rc.a.y, rc.b.x, rc.b.y)\n"
"1 2 3 4\n"
">>> # byt nu ut de två punkterna\n"
">>> rc.a, rc.b = rc.b, rc.a\n"
">>> print(rc.a.x, rc.a.y, rc.b.x, rc.b.y)\n"
"3 4 3 4\n"
">>>"

#: ../../library/ctypes.rst:1215
msgid ""
"Hm. We certainly expected the last statement to print ``3 4 1 2``. What "
"happened? Here are the steps of the ``rc.a, rc.b = rc.b, rc.a`` line above::"
msgstr ""
"Hm. Vi förväntade oss verkligen att det sista uttalandet skulle skriva ut "
"``3 4 1 2``. Vad var det som hände? Här är stegen i raden ``rc.a, rc.b = rc."
"b, rc.a`` ovan::"

#: ../../library/ctypes.rst:1218
msgid ""
">>> temp0, temp1 = rc.b, rc.a\n"
">>> rc.a = temp0\n"
">>> rc.b = temp1\n"
">>>"
msgstr ""
">>> temp0, temp1 = rc.b, rc.a\n"
">>> rc.a = temp0\n"
">>> rc.b = temp1\n"
">>>"

#: ../../library/ctypes.rst:1223
msgid ""
"Note that ``temp0`` and ``temp1`` are objects still using the internal "
"buffer of the ``rc`` object above. So executing ``rc.a = temp0`` copies the "
"buffer contents of ``temp0`` into ``rc`` 's buffer.  This, in turn, changes "
"the contents of ``temp1``. So, the last assignment ``rc.b = temp1``, doesn't "
"have the expected effect."
msgstr ""
"Observera att ``temp0`` och ``temp1`` är objekt som fortfarande använder den "
"interna bufferten i ``rc``-objektet ovan. Så när du kör ``rc.a = temp0`` "
"kopieras buffertinnehållet i ``temp0`` till ``rc`` buffert.  Detta ändrar i "
"sin tur innehållet i ``temp1``. Så den sista uppgiften ``rc.b = temp1`` har "
"inte den förväntade effekten."

#: ../../library/ctypes.rst:1229
msgid ""
"Keep in mind that retrieving sub-objects from Structure, Unions, and Arrays "
"doesn't *copy* the sub-object, instead it retrieves a wrapper object "
"accessing the root-object's underlying buffer."
msgstr ""
"Tänk på att när du hämtar underobjekt från Structure, Unions och Arrays "
"*kopieras* inte underobjektet, utan istället hämtas ett omslagsobjekt som "
"har åtkomst till rotobjektets underliggande buffert."

#: ../../library/ctypes.rst:1233
msgid ""
"Another example that may behave differently from what one would expect is "
"this::"
msgstr ""
"Ett annat exempel som kan bete sig annorlunda än vad man förväntar sig är "
"detta::"

#: ../../library/ctypes.rst:1235
msgid ""
">>> s = c_char_p()\n"
">>> s.value = b\"abc def ghi\"\n"
">>> s.value\n"
"b'abc def ghi'\n"
">>> s.value is s.value\n"
"False\n"
">>>"
msgstr ""
">>> s = c_char_p()\n"
">>> s.värde = b\"abc def ghi\"\n"
">>> s.värde\n"
"b'abc def ghi'\n"
">>> s.value är s.value\n"
"Falskt\n"
">>>"

#: ../../library/ctypes.rst:1245
msgid ""
"Objects instantiated from :class:`c_char_p` can only have their value set to "
"bytes or integers."
msgstr ""
"Objekt som instansieras från :class:`c_char_p` kan bara ha sitt värde "
"inställt på bytes eller heltal."

#: ../../library/ctypes.rst:1248
msgid ""
"Why is it printing ``False``?  ctypes instances are objects containing a "
"memory block plus some :term:`descriptor`\\s accessing the contents of the "
"memory. Storing a Python object in the memory block does not store the "
"object itself, instead the ``contents`` of the object is stored.  Accessing "
"the contents again constructs a new Python object each time!"
msgstr ""
"Varför skriver den ut ``False``? ctypes-instanser är objekt som innehåller "
"ett minnesblock plus några :term:`descriptor`` som har åtkomst till "
"innehållet i minnet. När ett Python-objekt lagras i minnesblocket lagras "
"inte själva objektet, utan istället lagras objektets ``innehåll``.  Om du "
"öppnar innehållet igen konstrueras ett nytt Python-objekt varje gång!"

#: ../../library/ctypes.rst:1258
msgid "Variable-sized data types"
msgstr "Datatyper med variabel storlek"

#: ../../library/ctypes.rst:1260
msgid ""
":mod:`ctypes` provides some support for variable-sized arrays and structures."
msgstr ""
":mod:`ctypes` ger visst stöd för arrayer och strukturer med variabel storlek."

#: ../../library/ctypes.rst:1262
msgid ""
"The :func:`resize` function can be used to resize the memory buffer of an "
"existing ctypes object.  The function takes the object as first argument, "
"and the requested size in bytes as the second argument.  The memory block "
"cannot be made smaller than the natural memory block specified by the "
"objects type, a :exc:`ValueError` is raised if this is tried::"
msgstr ""
"Funktionen :func:`resize` kan användas för att ändra storlek på "
"minnesbufferten för ett befintligt ctypes-objekt.  Funktionen tar objektet "
"som första argument och den begärda storleken i byte som andra argument.  "
"Minnesblocket kan inte göras mindre än det naturliga minnesblock som anges "
"av objektets typ, ett :exc:`ValueError` uppstår om detta försöker:"

#: ../../library/ctypes.rst:1268
msgid ""
">>> short_array = (c_short * 4)()\n"
">>> print(sizeof(short_array))\n"
"8\n"
">>> resize(short_array, 4)\n"
"Traceback (most recent call last):\n"
"    ...\n"
"ValueError: minimum size is 8\n"
">>> resize(short_array, 32)\n"
">>> sizeof(short_array)\n"
"32\n"
">>> sizeof(type(short_array))\n"
"8\n"
">>>"
msgstr ""
">>> short_array = (c_short * 4)()\n"
">>> print(sizeof(short_array))\n"
"8\n"
">>> ändra storlek(short_array, 4)\n"
"Traceback (senaste anropet senast):\n"
"    ...\n"
"ValueError: minsta storlek är 8\n"
">>> storleksändring(kort_matris, 32)\n"
">>> sizeof(short_array)\n"
"32\n"
">>> sizeof(type(short_array))\n"
"8\n"
">>>"

#: ../../library/ctypes.rst:1282
msgid ""
"This is nice and fine, but how would one access the additional elements "
"contained in this array?  Since the type still only knows about 4 elements, "
"we get errors accessing other elements::"
msgstr ""
"Detta är bra, men hur skulle man komma åt de ytterligare element som finns i "
"denna array?  Eftersom typen fortfarande bara känner till 4 element, får vi "
"fel vid åtkomst till andra element::"

#: ../../library/ctypes.rst:1286
msgid ""
">>> short_array[:]\n"
"[0, 0, 0, 0]\n"
">>> short_array[7]\n"
"Traceback (most recent call last):\n"
"    ...\n"
"IndexError: invalid index\n"
">>>"
msgstr ""
">>> kort_array[:]\n"
"[0, 0, 0, 0]\n"
">>> short_array[7]\n"
"Traceback (senaste anropet senast):\n"
"    ...\n"
"IndexError: ogiltigt index\n"
">>>"

#: ../../library/ctypes.rst:1294
msgid ""
"Another way to use variable-sized data types with :mod:`ctypes` is to use "
"the dynamic nature of Python, and (re-)define the data type after the "
"required size is already known, on a case by case basis."
msgstr ""
"Ett annat sätt att använda datatyper med variabel storlek med :mod:`ctypes` "
"är att använda Pythons dynamiska natur och (om)definiera datatypen efter att "
"den önskade storleken redan är känd, från fall till fall."

#: ../../library/ctypes.rst:1302
msgid "ctypes reference"
msgstr "ctypes referens"

#: ../../library/ctypes.rst:1308
msgid "Finding shared libraries"
msgstr "Hitta delade bibliotek"

#: ../../library/ctypes.rst:1310
msgid ""
"When programming in a compiled language, shared libraries are accessed when "
"compiling/linking a program, and when the program is run."
msgstr ""
"När du programmerar i ett kompilerat språk används delade bibliotek när du "
"kompilerar/länkar ett program och när programmet körs."

#: ../../library/ctypes.rst:1313
msgid ""
"The purpose of the :func:`~ctypes.util.find_library` function is to locate a "
"library in a way similar to what the compiler or runtime loader does (on "
"platforms with several versions of a shared library the most recent should "
"be loaded), while the ctypes library loaders act like when a program is run, "
"and call the runtime loader directly."
msgstr ""
"Syftet med funktionen :func:`~ctypes.util.find_library` är att hitta ett "
"bibliotek på ett sätt som liknar det som kompilatorn eller runtime-laddaren "
"gör (på plattformar med flera versioner av ett delat bibliotek bör den "
"senaste laddas), medan ctypes-biblioteksladdarna fungerar som när ett "
"program körs och anropar runtime-laddaren direkt."

#: ../../library/ctypes.rst:1319
msgid ""
"The :mod:`!ctypes.util` module provides a function which can help to "
"determine the library to load."
msgstr ""
"Modulen :mod:`!ctypes.util` innehåller en funktion som kan hjälpa till att "
"bestämma vilket bibliotek som ska laddas."

#: ../../library/ctypes.rst:1327
msgid ""
"Try to find a library and return a pathname.  *name* is the library name "
"without any prefix like *lib*, suffix like ``.so``, ``.dylib`` or version "
"number (this is the form used for the posix linker option :option:`!-l`).  "
"If no library can be found, returns ``None``."
msgstr ""
"Försöker hitta ett bibliotek och returnerar ett sökvägsnamn.  *name* är "
"biblioteksnamnet utan något prefix som *lib*, suffix som ``.so``, ``.dylib`` "
"eller versionsnummer (detta är den form som används för posix-"
"länkalternativet :option:`!-l`).  Om inget bibliotek kan hittas returneras "
"``None``."

#: ../../library/ctypes.rst:1332 ../../library/ctypes.rst:2041
msgid "The exact functionality is system dependent."
msgstr "Den exakta funktionaliteten är systemberoende."

#: ../../library/ctypes.rst:1334
msgid ""
"On Linux, :func:`~ctypes.util.find_library` tries to run external programs "
"(``/sbin/ldconfig``, ``gcc``, ``objdump`` and ``ld``) to find the library "
"file. It returns the filename of the library file."
msgstr ""
"På Linux försöker :func:`~ctypes.util.find_library` köra externa program (``/"
"sbin/ldconfig``, ``gcc``, ``objdump`` och ``ld``) för att hitta "
"biblioteksfilen. Den returnerar filnamnet på biblioteksfilen."

#: ../../library/ctypes.rst:1338
msgid ""
"Note that if the output of these programs does not correspond to the dynamic "
"linker used by Python, the result of this function may be misleading."
msgstr ""

#: ../../library/ctypes.rst:1341
msgid ""
"On Linux, the value of the environment variable ``LD_LIBRARY_PATH`` is used "
"when searching for libraries, if a library cannot be found by any other "
"means."
msgstr ""
"Under Linux används värdet för miljövariabeln ``LD_LIBRARY_PATH`` vid "
"sökning efter bibliotek, om ett bibliotek inte kan hittas på något annat "
"sätt."

#: ../../library/ctypes.rst:1345
msgid "Here are some examples::"
msgstr "Här är några exempel::"

#: ../../library/ctypes.rst:1347
msgid ""
">>> from ctypes.util import find_library\n"
">>> find_library(\"m\")\n"
"'libm.so.6'\n"
">>> find_library(\"c\")\n"
"'libc.so.6'\n"
">>> find_library(\"bz2\")\n"
"'libbz2.so.1.0'\n"
">>>"
msgstr ""
">>> från ctypes.util import find_library\n"
">>> find_library(\"m\")\n"
"'libm.so.6'\n"
">>> find_library(\"c\")\n"
"'libc.so.6'\n"
">>> find_library(\"bz2\")\n"
"'libbz2.so.1.0'\n"
">>>"

#: ../../library/ctypes.rst:1356
msgid ""
"On macOS and Android, :func:`~ctypes.util.find_library` uses the system's "
"standard naming schemes and paths to locate the library, and returns a full "
"pathname if successful::"
msgstr ""
"På macOS och Android använder :func:`~ctypes.util.find_library` systemets "
"standardnamngivningsscheman och sökvägar för att hitta biblioteket och "
"returnerar ett fullständigt söknamn om det lyckas::"

#: ../../library/ctypes.rst:1360
msgid ""
">>> from ctypes.util import find_library\n"
">>> find_library(\"c\")\n"
"'/usr/lib/libc.dylib'\n"
">>> find_library(\"m\")\n"
"'/usr/lib/libm.dylib'\n"
">>> find_library(\"bz2\")\n"
"'/usr/lib/libbz2.dylib'\n"
">>> find_library(\"AGL\")\n"
"'/System/Library/Frameworks/AGL.framework/AGL'\n"
">>>"
msgstr ""
">>> från ctypes.util importera find_library\n"
">>> find_library(\"c\")\n"
"'/usr/lib/libc.dylib'\n"
">>> find_library(\"m\")\n"
"'/usr/lib/libm.dylib'\n"
">>> hitta_bibliotek(\"bz2\")\n"
"'/usr/lib/libbz2.dylib'\n"
">>> hitta_bibliotek(\"AGL\")\n"
"'/System/Bibliotek/Framverk/AGL.ramverk/AGL'\n"
">>>"

#: ../../library/ctypes.rst:1371
msgid ""
"On Windows, :func:`~ctypes.util.find_library` searches along the system "
"search path, and returns the full pathname, but since there is no predefined "
"naming scheme a call like ``find_library(\"c\")`` will fail and return "
"``None``."
msgstr ""
"På Windows söker :func:`~ctypes.util.find_library` längs systemets sökväg "
"och returnerar det fullständiga sökvägsnamnet, men eftersom det inte finns "
"något fördefinierat namngivningsschema kommer ett anrop som "
"``find_library(\"c\")`` att misslyckas och returnera ``None``."

#: ../../library/ctypes.rst:1375
msgid ""
"If wrapping a shared library with :mod:`ctypes`, it *may* be better to "
"determine the shared library name at development time, and hardcode that "
"into the wrapper module instead of using :func:`~ctypes.util.find_library` "
"to locate the library at runtime."
msgstr ""
"Om du omsluter ett delat bibliotek med :mod:`ctypes`, kan det *vara* bättre "
"att bestämma det delade bibliotekets namn under utvecklingstiden och "
"hårdkoda det i omslutningsmodulen istället för att använda :func:`~ctypes."
"util.find_library` för att hitta biblioteket vid körning."

#: ../../library/ctypes.rst:1383
msgid "Loading shared libraries"
msgstr "Ladda delade bibliotek"

#: ../../library/ctypes.rst:1385
msgid ""
"There are several ways to load shared libraries into the Python process.  "
"One way is to instantiate one of the following classes:"
msgstr ""
"Det finns flera sätt att ladda in delade bibliotek i Python-processen.  Ett "
"sätt är att instansiera en av följande klasser:"

#: ../../library/ctypes.rst:1391
msgid ""
"Instances of this class represent loaded shared libraries. Functions in "
"these libraries use the standard C calling convention, and are assumed to "
"return :c:expr:`int`."
msgstr ""
"Instanser av denna klass representerar laddade delade bibliotek. Funktioner "
"i dessa bibliotek använder standard C-anropskonventionen och antas "
"returnera :c:expr:`int`."

#: ../../library/ctypes.rst:1395
msgid ""
"On Windows creating a :class:`CDLL` instance may fail even if the DLL name "
"exists. When a dependent DLL of the loaded DLL is not found, a :exc:"
"`OSError` error is raised with the message *\"[WinError 126] The specified "
"module could not be found\".* This error message does not contain the name "
"of the missing DLL because the Windows API does not return this information "
"making this error hard to diagnose. To resolve this error and determine "
"which DLL is not found, you need to find the list of dependent DLLs and "
"determine which one is not found using Windows debugging and tracing tools."
msgstr ""
"I Windows kan det misslyckas att skapa en :class:`CDLL`-instans även om DLL-"
"namnet finns. När en DLL som är beroende av den inlästa DLL:en inte hittas, "
"uppstår ett :exc:`OSError`-fel med meddelandet *\"[WinError 126] Den angivna "
"modulen kunde inte hittas\".* Detta felmeddelande innehåller inte namnet på "
"den DLL som saknas eftersom Windows API inte returnerar denna information, "
"vilket gör det svårt att diagnostisera detta fel. För att lösa det här felet "
"och avgöra vilken DLL som inte hittas måste du hitta listan över beroende "
"DLL:er och avgöra vilken som inte hittas med hjälp av Windows felsöknings- "
"och spårningsverktyg."

#: ../../library/ctypes.rst:1407 ../../library/ctypes.rst:1432
#: ../../library/ctypes.rst:1445 ../../library/ctypes.rst:1463
msgid "The *name* parameter can now be a :term:`path-like object`."
msgstr "Parametern *namn* kan nu vara en :term:`path-liknande objekt`."

#: ../../library/ctypes.rst:1411
msgid ""
"`Microsoft DUMPBIN tool <https://docs.microsoft.com/cpp/build/reference/"
"dependents>`_ -- A tool to find DLL dependents."
msgstr ""
"microsofts DUMPBIN-verktyg <https://docs.microsoft.com/cpp/build/reference/"
"dependents>`_ -- Ett verktyg för att hitta DLL-beroenden."

#: ../../library/ctypes.rst:1417
msgid ""
"Instances of this class represent loaded shared libraries, functions in "
"these libraries use the ``stdcall`` calling convention, and are assumed to "
"return the windows specific :class:`HRESULT` code.  :class:`HRESULT` values "
"contain information specifying whether the function call failed or "
"succeeded, together with additional error code.  If the return value signals "
"a failure, an :class:`OSError` is automatically raised."
msgstr ""
"Instanser av denna klass representerar inlästa delade bibliotek, funktioner "
"i dessa bibliotek använder anropskonventionen ``stdcall`` och antas "
"returnera den Windows-specifika :class:`HRESULT`-koden. :class:`HRESULT`-"
"värden innehåller information som anger om funktionsanropet misslyckades "
"eller lyckades, tillsammans med ytterligare felkod.  Om returvärdet "
"signalerar ett misslyckande, skapas automatiskt ett :class:`OSError`."

#: ../../library/ctypes.rst:1424 ../../library/ctypes.rst:1441
#: ../../library/ctypes.rst:1585 ../../library/ctypes.rst:1593
#: ../../library/ctypes.rst:1770 ../../library/ctypes.rst:2021
#: ../../library/ctypes.rst:2030 ../../library/ctypes.rst:2057
#: ../../library/ctypes.rst:2066 ../../library/ctypes.rst:2075
#: ../../library/ctypes.rst:2090 ../../library/ctypes.rst:2147
#: ../../library/ctypes.rst:2175 ../../library/ctypes.rst:2519
msgid "Availability"
msgstr "Tillgänglighet"

#: ../../library/ctypes.rst:1426
msgid ""
":exc:`WindowsError` used to be raised, which is now an alias of :exc:"
"`OSError`."
msgstr ""
"tidigare användes :exc:`WindowsError`, som nu är ett alias för :exc:"
"`OSError`."

#: ../../library/ctypes.rst:1437
msgid ""
"Instances of this class represent loaded shared libraries, functions in "
"these libraries use the ``stdcall`` calling convention, and are assumed to "
"return :c:expr:`int` by default."
msgstr ""
"Instanser av den här klassen representerar laddade delade bibliotek, "
"funktioner i dessa bibliotek använder anropskonventionen ``stdcall`` och "
"antas returnera :c:expr:`int` som standard."

#: ../../library/ctypes.rst:1448
msgid ""
"The Python :term:`global interpreter lock` is released before calling any "
"function exported by these libraries, and reacquired afterwards."
msgstr ""
"Python :term:`global interpreter lock` släpps innan anrop av någon funktion "
"som exporteras av dessa bibliotek, och återfås efteråt."

#: ../../library/ctypes.rst:1454
msgid ""
"Instances of this class behave like :class:`CDLL` instances, except that the "
"Python GIL is *not* released during the function call, and after the "
"function execution the Python error flag is checked. If the error flag is "
"set, a Python exception is raised."
msgstr ""
"Instanser av denna klass beter sig som :class:`CDLL`-instanser, förutom att "
"Python GIL *inte* släpps under funktionsanropet, och efter att funktionen "
"har exekverats kontrolleras Pythons felflagga. Om fel-flaggan är satt, "
"uppstår ett Python-undantag."

#: ../../library/ctypes.rst:1459
msgid "Thus, this is only useful to call Python C api functions directly."
msgstr ""
"Därför är detta endast användbart för att anropa Python C api-funktioner "
"direkt."

#: ../../library/ctypes.rst:1465
msgid ""
"All these classes can be instantiated by calling them with at least one "
"argument, the pathname of the shared library.  If you have an existing "
"handle to an already loaded shared library, it can be passed as the "
"``handle`` named parameter, otherwise the underlying platform's :c:func:`!"
"dlopen` or :c:func:`!LoadLibrary` function is used to load the library into "
"the process, and to get a handle to it."
msgstr ""
"Alla dessa klasser kan instansieras genom att anropa dem med minst ett "
"argument, sökvägen till det delade biblioteket.  Om du har ett befintligt "
"handtag till ett redan laddat delat bibliotek kan det skickas som den "
"namngivna parametern ``handle``, annars används den underliggande "
"plattformens funktion :c:func:`!dlopen` eller :c:func:`!LoadLibrary` för att "
"ladda biblioteket i processen och för att få ett handtag till det."

#: ../../library/ctypes.rst:1472
msgid ""
"The *mode* parameter can be used to specify how the library is loaded.  For "
"details, consult the :manpage:`dlopen(3)` manpage.  On Windows, *mode* is "
"ignored.  On posix systems, RTLD_NOW is always added, and is not "
"configurable."
msgstr ""
"Parametern *mode* kan användas för att ange hur biblioteket laddas.  För mer "
"information, se :manpage:`dlopen(3)` manpage.  I Windows ignoreras *mode*.  "
"På posix-system läggs RTLD_NOW alltid till och är inte konfigurerbart."

#: ../../library/ctypes.rst:1477
msgid ""
"The *use_errno* parameter, when set to true, enables a ctypes mechanism that "
"allows accessing the system :data:`errno` error number in a safe way. :mod:"
"`ctypes` maintains a thread-local copy of the system's :data:`errno` "
"variable; if you call foreign functions created with ``use_errno=True`` then "
"the :data:`errno` value before the function call is swapped with the ctypes "
"private copy, the same happens immediately after the function call."
msgstr ""
"Parametern *use_errno*, när den är satt till true, aktiverar en ctypes-"
"mekanism som gör det möjligt att komma åt systemets :data:`errno`-felnummer "
"på ett säkert sätt. :mod:`ctypes` upprätthåller en trådlokal kopia av "
"systemets :data:`errno`-variabel; om du anropar utländska funktioner som "
"skapats med ``use_errno=True`` byts :data:`errno`-värdet före "
"funktionsanropet ut mot ctypes privata kopia, och samma sak händer "
"omedelbart efter funktionsanropet."

#: ../../library/ctypes.rst:1484
msgid ""
"The function :func:`ctypes.get_errno` returns the value of the ctypes "
"private copy, and the function :func:`ctypes.set_errno` changes the ctypes "
"private copy to a new value and returns the former value."
msgstr ""
"Funktionen :func:`ctypes.get_errno` returnerar värdet på den privata kopian "
"av ctypes, och funktionen :func:`ctypes.set_errno` ändrar den privata kopian "
"av ctypes till ett nytt värde och returnerar det tidigare värdet."

#: ../../library/ctypes.rst:1488
msgid ""
"The *use_last_error* parameter, when set to true, enables the same mechanism "
"for the Windows error code which is managed by the :func:`GetLastError` and :"
"func:`!SetLastError` Windows API functions; :func:`ctypes.get_last_error` "
"and :func:`ctypes.set_last_error` are used to request and change the ctypes "
"private copy of the windows error code."
msgstr ""
"Parametern *use_last_error*, när den är satt till true, aktiverar samma "
"mekanism för Windows-felkoden som hanteras av Windows API-funktionerna :func:"
"`GetLastError` och :func:`!SetLastError`; :func:`ctypes.get_last_error` och :"
"func:`ctypes.set_last_error` används för att begära och ändra ctypes privata "
"kopia av Windows-felkoden."

#: ../../library/ctypes.rst:1494
msgid ""
"The *winmode* parameter is used on Windows to specify how the library is "
"loaded (since *mode* is ignored). It takes any value that is valid for the "
"Win32 API ``LoadLibraryEx`` flags parameter. When omitted, the default is to "
"use the flags that result in the most secure DLL load, which avoids issues "
"such as DLL hijacking. Passing the full path to the DLL is the safest way to "
"ensure the correct library and dependencies are loaded."
msgstr ""
"Parametern *winmode* används i Windows för att ange hur biblioteket laddas "
"(eftersom *mode* ignoreras). Den tar alla värden som är giltiga för Win32 "
"API:s flaggparameter ``LoadLibraryEx``. När den utelämnas är "
"standardinställningen att använda de flaggor som ger den säkraste DLL-"
"laddningen, vilket undviker problem som DLL-kapning. Att ange den "
"fullständiga sökvägen till DLL:en är det säkraste sättet att se till att "
"rätt bibliotek och beroenden laddas."

#: ../../library/ctypes.rst:1501
msgid "Added *winmode* parameter."
msgstr "Lagt till parametern *winmode*."

#: ../../library/ctypes.rst:1508
msgid ""
"Flag to use as *mode* parameter.  On platforms where this flag is not "
"available, it is defined as the integer zero."
msgstr ""
"Flagga som ska användas som *mode*-parameter.  På plattformar där denna "
"flagga inte är tillgänglig definieras den som heltalet noll."

#: ../../library/ctypes.rst:1515
msgid ""
"Flag to use as *mode* parameter.  On platforms where this is not available, "
"it is the same as *RTLD_GLOBAL*."
msgstr ""
"Flagga att använda som *mode*-parameter.  På plattformar där detta inte är "
"tillgängligt är det samma sak som *RTLD_GLOBAL*."

#: ../../library/ctypes.rst:1522
msgid ""
"The default mode which is used to load shared libraries.  On OSX 10.3, this "
"is *RTLD_GLOBAL*, otherwise it is the same as *RTLD_LOCAL*."
msgstr ""
"Det standardläge som används för att ladda delade bibliotek.  I OSX 10.3 är "
"detta *RTLD_GLOBAL*, annars är det samma som *RTLD_LOCAL*."

#: ../../library/ctypes.rst:1525
msgid ""
"Instances of these classes have no public methods.  Functions exported by "
"the shared library can be accessed as attributes or by index.  Please note "
"that accessing the function through an attribute caches the result and "
"therefore accessing it repeatedly returns the same object each time.  On the "
"other hand, accessing it through an index returns a new object each time::"
msgstr ""
"Instanser av dessa klasser har inga publika metoder.  Funktioner som "
"exporteras av det delade biblioteket kan nås som attribut eller via index.  "
"Observera att om du använder funktionen via ett attribut cachas resultatet "
"och därför returneras samma objekt varje gång om du använder den upprepade "
"gånger.  Å andra sidan returnerar åtkomst via ett index ett nytt objekt "
"varje gång::"

#: ../../library/ctypes.rst:1531
msgid ""
">>> from ctypes import CDLL\n"
">>> libc = CDLL(\"libc.so.6\")  # On Linux\n"
">>> libc.time == libc.time\n"
"True\n"
">>> libc['time'] == libc['time']\n"
"False"
msgstr ""
">>> från ctypes import CDLL\n"
">>> libc = CDLL(\"libc.so.6\") # På Linux\n"
">>> libc.time == libc.time\n"
"Sann\n"
">>> libc['time'] == libc['time']\n"
"False"

#: ../../library/ctypes.rst:1538
msgid ""
"The following public attributes are available, their name starts with an "
"underscore to not clash with exported function names:"
msgstr ""
"Följande publika attribut finns tillgängliga, deras namn börjar med ett "
"understreck för att inte krocka med exporterade funktionsnamn:"

#: ../../library/ctypes.rst:1544
msgid "The system handle used to access the library."
msgstr "Det systemhandtag som används för att komma åt biblioteket."

#: ../../library/ctypes.rst:1549
msgid "The name of the library passed in the constructor."
msgstr "Namnet på det bibliotek som skickas i konstruktören."

#: ../../library/ctypes.rst:1551
msgid ""
"Shared libraries can also be loaded by using one of the prefabricated "
"objects, which are instances of the :class:`LibraryLoader` class, either by "
"calling the :meth:`~LibraryLoader.LoadLibrary` method, or by retrieving the "
"library as attribute of the loader instance."
msgstr ""
"Delade bibliotek kan också laddas med hjälp av ett av de prefabricerade "
"objekten, som är instanser av klassen :class:`LibraryLoader`, antingen genom "
"att anropa metoden :meth:`~LibraryLoader.LoadLibrary` eller genom att hämta "
"biblioteket som attribut för laddningsinstansen."

#: ../../library/ctypes.rst:1559
msgid ""
"Class which loads shared libraries.  *dlltype* should be one of the :class:"
"`CDLL`, :class:`PyDLL`, :class:`WinDLL`, or :class:`OleDLL` types."
msgstr ""
"Klass som laddar delade bibliotek.  *dlltype* bör vara en av typerna :class:"
"`CDLL`, :class:`PyDLL`, :class:`WinDLL` eller :class:`OleDLL`."

#: ../../library/ctypes.rst:1562
msgid ""
":meth:`!__getattr__` has special behavior: It allows loading a shared "
"library by accessing it as attribute of a library loader instance.  The "
"result is cached, so repeated attribute accesses return the same library "
"each time."
msgstr ""
":meth:`!__getattr__` har ett speciellt beteende: Det gör det möjligt att "
"ladda ett delat bibliotek genom att komma åt det som attribut för en "
"biblioteksladdningsinstans.  Resultatet cachas, så upprepade "
"attributåtkomster returnerar samma bibliotek varje gång."

#: ../../library/ctypes.rst:1568
msgid ""
"Load a shared library into the process and return it.  This method always "
"returns a new instance of the library."
msgstr ""
"Ladda in ett delat bibliotek i processen och returnera det.  Denna metod "
"returnerar alltid en ny instans av biblioteket."

#: ../../library/ctypes.rst:1572
msgid "These prefabricated library loaders are available:"
msgstr "Dessa prefabricerade bibliotekslastare finns tillgängliga:"

#: ../../library/ctypes.rst:1577
msgid "Creates :class:`CDLL` instances."
msgstr "Skapar :class:`CDLL`-instanser."

#: ../../library/ctypes.rst:1583
msgid "Creates :class:`WinDLL` instances."
msgstr "Skapar :class:`WinDLL`-instanser."

#: ../../library/ctypes.rst:1591
msgid "Creates :class:`OleDLL` instances."
msgstr "Skapar :class:`OleDLL`-instanser."

#: ../../library/ctypes.rst:1599
msgid "Creates :class:`PyDLL` instances."
msgstr "Skapar :class:`PyDLL`-instanser."

#: ../../library/ctypes.rst:1602
msgid ""
"For accessing the C Python api directly, a ready-to-use Python shared "
"library object is available:"
msgstr ""
"För direkt åtkomst till C Python Api finns ett färdigt Python shared library-"
"objekt tillgängligt:"

#: ../../library/ctypes.rst:1608
msgid ""
"An instance of :class:`PyDLL` that exposes Python C API functions as "
"attributes.  Note that all these functions are assumed to return C :c:expr:"
"`int`, which is of course not always the truth, so you have to assign the "
"correct :attr:`!restype` attribute to use these functions."
msgstr ""
"En instans av :class:`PyDLL` som exponerar Python C API-funktioner som "
"attribut.  Observera att alla dessa funktioner antas returnera C :c:expr:"
"`int`, vilket naturligtvis inte alltid är sant, så du måste tilldela rätt :"
"attr:`!restype`-attribut för att använda dessa funktioner."

#: ../../library/ctypes.rst:1613 ../../library/ctypes.rst:1615
msgid ""
"Loading a library through any of these objects raises an :ref:`auditing "
"event <auditing>` ``ctypes.dlopen`` with string argument ``name``, the name "
"used to load the library."
msgstr ""
"Att ladda ett bibliotek via något av dessa objekt ger upphov till en :ref:"
"`auditing event <auditing>` ``ctypes.dlopen`` med strängargumentet ``name``, "
"namnet som används för att ladda biblioteket."

#: ../../library/ctypes.rst:1619 ../../library/ctypes.rst:1621
msgid ""
"Accessing a function on a loaded library raises an auditing event ``ctypes."
"dlsym`` with arguments ``library`` (the library object) and ``name`` (the "
"symbol's name as a string or integer)."
msgstr ""
"Åtkomst till en funktion i ett laddat bibliotek ger upphov till en "
"granskningshändelse ``ctypes.dlsym`` med argumenten ``library`` "
"(biblioteksobjektet) och ``name`` (symbolens namn som en sträng eller ett "
"heltal)."

#: ../../library/ctypes.rst:1625 ../../library/ctypes.rst:1627
msgid ""
"In cases when only the library handle is available rather than the object, "
"accessing a function raises an auditing event ``ctypes.dlsym/handle`` with "
"arguments ``handle`` (the raw library handle) and ``name``."
msgstr ""
"I de fall då endast bibliotekshandtaget är tillgängligt i stället för "
"objektet, ger åtkomst till en funktion upphov till en granskningshändelse "
"``ctypes.dlsym/handle`` med argumenten ``handle`` (det råa "
"bibliotekshandtaget) och ``name``."

#: ../../library/ctypes.rst:1634
msgid "Foreign functions"
msgstr "Utländska funktioner"

#: ../../library/ctypes.rst:1636
msgid ""
"As explained in the previous section, foreign functions can be accessed as "
"attributes of loaded shared libraries.  The function objects created in this "
"way by default accept any number of arguments, accept any ctypes data "
"instances as arguments, and return the default result type specified by the "
"library loader."
msgstr ""
"Som förklarades i föregående avsnitt kan utländska funktioner nås som "
"attribut till inlästa delade bibliotek.  De funktionsobjekt som skapas på "
"detta sätt accepterar som standard valfritt antal argument, accepterar "
"valfria ctypes-datainstanser som argument och returnerar den "
"standardresultattyp som anges av biblioteksladdaren."

#: ../../library/ctypes.rst:1641
msgid ""
"They are instances of a private local class :class:`!_FuncPtr` (not exposed "
"in :mod:`!ctypes`) which inherits from the private :class:`_CFuncPtr` class:"
msgstr ""
"De är instanser av en privat lokal klass :class:`!_FuncPtr` (inte exponerad "
"i :mod:`!ctypes`) som ärver från den privata klassen :class:`_CFuncPtr`:"

#: ../../library/ctypes.rst:1644
msgid ""
">>> import ctypes\n"
">>> lib = ctypes.CDLL(None)\n"
">>> issubclass(lib._FuncPtr, ctypes._CFuncPtr)\n"
"True\n"
">>> lib._FuncPtr is ctypes._CFuncPtr\n"
"False"
msgstr ""
">>> import ctypes\n"
">>> lib = ctypes.CDLL(None)\n"
">>> issubclass(lib._FuncPtr, ctypes._CFuncPtr)\n"
"Sant\n"
">>> lib._FuncPtr är ctypes._CFuncPtr\n"
"Falsk"

#: ../../library/ctypes.rst:1655
msgid "Base class for C callable foreign functions."
msgstr "Basklass för C-anropsbara utländska funktioner."

#: ../../library/ctypes.rst:1657
msgid ""
"Instances of foreign functions are also C compatible data types; they "
"represent C function pointers."
msgstr ""
"Instanser av utländska funktioner är också C-kompatibla datatyper; de "
"representerar C-funktionspoängare."

#: ../../library/ctypes.rst:1660
msgid ""
"This behavior can be customized by assigning to special attributes of the "
"foreign function object."
msgstr ""
"Detta beteende kan anpassas genom att tilldela speciella attribut till det "
"utländska funktionsobjektet."

#: ../../library/ctypes.rst:1665
msgid ""
"Assign a ctypes type to specify the result type of the foreign function. Use "
"``None`` for :c:expr:`void`, a function not returning anything."
msgstr ""
"Tilldela en ctypes-typ för att ange resultattypen för den främmande "
"funktionen. Använd ``None`` för :c:expr:`void`, en funktion som inte "
"returnerar någonting."

#: ../../library/ctypes.rst:1668
msgid ""
"It is possible to assign a callable Python object that is not a ctypes type, "
"in this case the function is assumed to return a C :c:expr:`int`, and the "
"callable will be called with this integer, allowing further processing or "
"error checking.  Using this is deprecated, for more flexible post processing "
"or error checking use a ctypes data type as :attr:`!restype` and assign a "
"callable to the :attr:`errcheck` attribute."
msgstr ""
"Det är möjligt att tilldela ett anropbart Python-objekt som inte är en "
"ctypes-typ, i det här fallet antas funktionen returnera en C :c:expr:`int`, "
"och den anropbara kommer att anropas med detta heltal, vilket möjliggör "
"ytterligare bearbetning eller felkontroll.  Att använda detta är föråldrat, "
"för mer flexibel efterbehandling eller felkontroll, använd en ctypes-datatyp "
"som :attr:`!restype` och tilldela en anropbar till attributet :attr:"
"`errcheck`."

#: ../../library/ctypes.rst:1677
msgid ""
"Assign a tuple of ctypes types to specify the argument types that the "
"function accepts.  Functions using the ``stdcall`` calling convention can "
"only be called with the same number of arguments as the length of this "
"tuple; functions using the C calling convention accept additional, "
"unspecified arguments as well."
msgstr ""
"Tilldela en tupel av ctypes-typer för att ange de argumenttyper som "
"funktionen accepterar.  Funktioner som använder anropskonventionen "
"``stdcall`` kan bara anropas med samma antal argument som längden på denna "
"tupel; funktioner som använder anropskonventionen C accepterar även "
"ytterligare, ospecificerade argument."

#: ../../library/ctypes.rst:1683
msgid ""
"When a foreign function is called, each actual argument is passed to the :"
"meth:`~_CData.from_param` class method of the items in the :attr:`argtypes` "
"tuple, this method allows adapting the actual argument to an object that the "
"foreign function accepts.  For example, a :class:`c_char_p` item in the :"
"attr:`argtypes` tuple will convert a string passed as argument into a bytes "
"object using ctypes conversion rules."
msgstr ""
"När en utländsk funktion anropas skickas varje faktiskt argument till "
"klassmetoden :meth:`~_CData.from_param` för objekten i tupeln :attr:"
"`argtypes`, denna metod gör det möjligt att anpassa det faktiska argumentet "
"till ett objekt som den utländska funktionen accepterar.  Exempelvis kommer "
"ett :class:`c_char_p`-objekt i :attr:`argtypes`-tupeln att konvertera en "
"sträng som skickas som argument till ett bytes-objekt med hjälp av ctypes "
"konverteringsregler."

#: ../../library/ctypes.rst:1690
msgid ""
"New: It is now possible to put items in argtypes which are not ctypes types, "
"but each item must have a :meth:`~_CData.from_param` method which returns a "
"value usable as argument (integer, string, ctypes instance).  This allows "
"defining adapters that can adapt custom objects as function parameters."
msgstr ""
"Nytt: Det är nu möjligt att lägga in objekt i argtypes som inte är ctypes-"
"typer, men varje objekt måste ha en :meth:`~_CData.from_param`-metod som "
"returnerar ett värde som kan användas som argument (heltal, sträng, ctypes-"
"instans).  Detta gör det möjligt att definiera adaptrar som kan anpassa "
"anpassade objekt som funktionsparametrar."

#: ../../library/ctypes.rst:1697
msgid ""
"Assign a Python function or another callable to this attribute. The callable "
"will be called with three or more arguments:"
msgstr ""
"Tilldela en Python-funktion eller en annan anropbar funktion till detta "
"attribut. Den anropsbara funktionen kommer att anropas med tre eller fler "
"argument:"

#: ../../library/ctypes.rst:1704
msgid ""
"*result* is what the foreign function returns, as specified by the :attr:`!"
"restype` attribute."
msgstr ""
"*result* är vad den främmande funktionen returnerar, enligt vad som anges av "
"attributet :attr:`!restype`."

#: ../../library/ctypes.rst:1707
msgid ""
"*func* is the foreign function object itself, this allows reusing the same "
"callable object to check or post process the results of several functions."
msgstr ""
"*func* är själva det främmande funktionsobjektet, vilket gör det möjligt att "
"återanvända samma anropsbara objekt för att kontrollera eller efterbehandla "
"resultaten av flera funktioner."

#: ../../library/ctypes.rst:1711
msgid ""
"*arguments* is a tuple containing the parameters originally passed to the "
"function call, this allows specializing the behavior on the arguments used."
msgstr ""
"*arguments* är en tupel som innehåller de parametrar som ursprungligen "
"skickades till funktionsanropet, vilket gör det möjligt att specialisera "
"beteendet på de argument som används."

#: ../../library/ctypes.rst:1715
msgid ""
"The object that this function returns will be returned from the foreign "
"function call, but it can also check the result value and raise an exception "
"if the foreign function call failed."
msgstr ""
"Det objekt som den här funktionen returnerar kommer att returneras från det "
"utländska funktionsanropet, men den kan också kontrollera resultatvärdet och "
"skapa ett undantag om det utländska funktionsanropet misslyckades."

#: ../../library/ctypes.rst:1722
msgid ""
"This exception is raised when a foreign function call cannot convert one of "
"the passed arguments."
msgstr ""
"Detta undantag uppstår när ett anrop av en utländsk funktion inte kan "
"konvertera ett av de passerade argumenten."

#: ../../library/ctypes.rst:1726 ../../library/ctypes.rst:1728
msgid ""
"On Windows, when a foreign function call raises a system exception (for "
"example, due to an access violation), it will be captured and replaced with "
"a suitable Python exception. Further, an auditing event ``ctypes."
"set_exception`` with argument ``code`` will be raised, allowing an audit "
"hook to replace the exception with its own."
msgstr ""
"I Windows, när ett främmande funktionsanrop ger upphov till ett "
"systemundantag (t.ex. på grund av en åtkomstöverträdelse), kommer det att "
"fångas upp och ersättas med ett lämpligt Python-undantag. Dessutom kommer en "
"granskningshändelse ``ctypes.set_exception`` med argumentet ``code`` att "
"uppstå, vilket gör det möjligt för en granskningskrok att ersätta undantaget "
"med sitt eget."

#: ../../library/ctypes.rst:1734 ../../library/ctypes.rst:1736
msgid ""
"Some ways to invoke foreign function calls may raise an auditing event "
"``ctypes.call_function`` with arguments ``function pointer`` and "
"``arguments``."
msgstr ""

#: ../../library/ctypes.rst:1742
msgid "Function prototypes"
msgstr "Prototyper av funktioner"

#: ../../library/ctypes.rst:1744
msgid ""
"Foreign functions can also be created by instantiating function prototypes. "
"Function prototypes are similar to function prototypes in C; they describe a "
"function (return type, argument types, calling convention) without defining "
"an implementation.  The factory functions must be called with the desired "
"result type and the argument types of the function, and can be used as "
"decorator factories, and as such, be applied to functions through the "
"``@wrapper`` syntax. See :ref:`ctypes-callback-functions` for examples."
msgstr ""
"Utländska funktioner kan också skapas genom instansiering av "
"funktionsprototyper. Funktionsprototyper liknar funktionsprototyper i C; de "
"beskriver en funktion (returtyp, argumenttyper, anropskonvention) utan att "
"definiera en implementation.  Fabriksfunktionerna måste anropas med önskad "
"resultattyp och funktionens argumenttyper och kan användas som "
"dekoratorfabriker och som sådana tillämpas på funktioner genom syntaxen "
"``@wrapper``. Se :ref:`ctypes-callback-functions` för exempel."

#: ../../library/ctypes.rst:1755
msgid ""
"The returned function prototype creates functions that use the standard C "
"calling convention.  The function will release the GIL during the call.  If "
"*use_errno* is set to true, the ctypes private copy of the system :data:"
"`errno` variable is exchanged with the real :data:`errno` value before and "
"after the call; *use_last_error* does the same for the Windows error code."
msgstr ""
"Den returnerade funktionsprototypen skapar funktioner som använder C:s "
"standardkonvention för anrop.  Funktionen kommer att frigöra GIL under "
"anropet.  Om *use_errno* är satt till true, kommer ctypes privata kopia av "
"systemvariabeln :data:`errno` att bytas ut mot det verkliga värdet för :data:"
"`errno` före och efter anropet; *use_last_error* gör samma sak för Windows "
"felkod."

#: ../../library/ctypes.rst:1765
msgid ""
"The returned function prototype creates functions that use the ``stdcall`` "
"calling convention.  The function will release the GIL during the call.  "
"*use_errno* and *use_last_error* have the same meaning as above."
msgstr ""
"Den returnerade funktionsprototypen skapar funktioner som använder "
"anropskonventionen ``stdcall``.  Funktionen kommer att frigöra GIL under "
"anropet.  *use_errno* och *use_last_error* har samma betydelse som ovan."

#: ../../library/ctypes.rst:1775
msgid ""
"The returned function prototype creates functions that use the Python "
"calling convention.  The function will *not* release the GIL during the call."
msgstr ""
"Den returnerade funktionsprototypen skapar funktioner som använder Pythons "
"anropskonvention.  Funktionen kommer *inte* att frigöra GIL under anropet."

#: ../../library/ctypes.rst:1778
msgid ""
"Function prototypes created by these factory functions can be instantiated "
"in different ways, depending on the type and number of the parameters in the "
"call:"
msgstr ""
"Funktionsprototyper som skapas av dessa fabriksfunktioner kan instansieras "
"på olika sätt, beroende på typen och antalet parametrar i anropet:"

#: ../../library/ctypes.rst:1785
msgid ""
"Returns a foreign function at the specified address which must be an integer."
msgstr ""
"Returnerar en utländsk funktion på den angivna adressen som måste vara ett "
"heltal."

#: ../../library/ctypes.rst:1792
msgid ""
"Create a C callable function (a callback function) from a Python *callable*."
msgstr ""
"Skapa en anropsbar C-funktion (en callback-funktion) från en Python "
"*callable*."

#: ../../library/ctypes.rst:1799
msgid ""
"Returns a foreign function exported by a shared library. *func_spec* must be "
"a 2-tuple ``(name_or_ordinal, library)``. The first item is the name of the "
"exported function as string, or the ordinal of the exported function as "
"small integer.  The second item is the shared library instance."
msgstr ""
"Returnerar en utländsk funktion som exporteras av ett delat bibliotek. "
"*func_spec* måste vara en 2-tupel ``(name_or_ordinal, library)``. Det första "
"elementet är namnet på den exporterade funktionen som en sträng, eller den "
"exporterade funktionens ordinal som ett litet heltal.  Det andra elementet "
"är den delade biblioteksinstansen."

#: ../../library/ctypes.rst:1809
msgid ""
"Returns a foreign function that will call a COM method. *vtbl_index* is the "
"index into the virtual function table, a small non-negative integer. *name* "
"is name of the COM method. *iid* is an optional pointer to the interface "
"identifier which is used in extended error reporting."
msgstr ""
"Returnerar en utländsk funktion som anropar en COM-metod. *vtbl_index* är "
"index i den virtuella funktionstabellen, ett litet icke-negativt heltal. "
"*name* är namnet på COM-metoden. *iid* är en valfri pekare till "
"gränssnittsidentifieraren som används vid utökad felrapportering."

#: ../../library/ctypes.rst:1814
msgid ""
"COM methods use a special calling convention: They require a pointer to the "
"COM interface as first argument, in addition to those parameters that are "
"specified in the :attr:`!argtypes` tuple."
msgstr ""
"COM-metoder använder en speciell anropskonvention: De kräver en pekare till "
"COM-gränssnittet som första argument, utöver de parametrar som anges i :attr:"
"`!argtypes`-tupeln."

#: ../../library/ctypes.rst:1818
msgid ""
"The optional *paramflags* parameter creates foreign function wrappers with "
"much more functionality than the features described above."
msgstr ""
"Den valfria parametern *paramflags* skapar omslag för utländska funktioner "
"med mycket mer funktionalitet än de funktioner som beskrivs ovan."

#: ../../library/ctypes.rst:1821
msgid ""
"*paramflags* must be a tuple of the same length as :attr:`~_CFuncPtr."
"argtypes`."
msgstr ""
"*paramflags* måste vara en tupel av samma längd som :attr:`~_CFuncPtr."
"argtypes`."

#: ../../library/ctypes.rst:1823
msgid ""
"Each item in this tuple contains further information about a parameter, it "
"must be a tuple containing one, two, or three items."
msgstr ""
"Varje objekt i denna tupel innehåller ytterligare information om en "
"parameter, det måste vara en tupel som innehåller ett, två eller tre objekt."

#: ../../library/ctypes.rst:1826
msgid ""
"The first item is an integer containing a combination of direction flags for "
"the parameter:"
msgstr ""
"Den första posten är ett heltal som innehåller en kombination av "
"riktningsflaggor för parametern:"

#: ../../library/ctypes.rst:1829
msgid "1"
msgstr "1"

#: ../../library/ctypes.rst:1830
msgid "Specifies an input parameter to the function."
msgstr "Anger en inparameter till funktionen."

#: ../../library/ctypes.rst:1832
msgid "2"
msgstr "2"

#: ../../library/ctypes.rst:1833
msgid "Output parameter.  The foreign function fills in a value."
msgstr "Parameter för utdata.  Den utländska funktionen fyller i ett värde."

#: ../../library/ctypes.rst:1835
msgid "4"
msgstr "4"

#: ../../library/ctypes.rst:1836
msgid "Input parameter which defaults to the integer zero."
msgstr "Inmatningsparameter som som standard är heltalet noll."

#: ../../library/ctypes.rst:1838
msgid ""
"The optional second item is the parameter name as string.  If this is "
"specified, the foreign function can be called with named parameters."
msgstr ""
"Den andra valfria posten är parameternamnet som en sträng.  Om detta anges "
"kan den utländska funktionen anropas med namngivna parametrar."

#: ../../library/ctypes.rst:1841
msgid "The optional third item is the default value for this parameter."
msgstr "Den valfria tredje posten är standardvärdet för denna parameter."

#: ../../library/ctypes.rst:1844
msgid ""
"The following example demonstrates how to wrap the Windows ``MessageBoxW`` "
"function so that it supports default parameters and named arguments. The C "
"declaration from the windows header file is this::"
msgstr ""
"Följande exempel visar hur man slår in Windows ``MessageBoxW``-funktionen så "
"att den stöder standardparametrar och namngivna argument. C-deklarationen "
"från Windows header-fil är denna::"

#: ../../library/ctypes.rst:1848
msgid ""
"WINUSERAPI int WINAPI\n"
"MessageBoxW(\n"
"    HWND hWnd,\n"
"    LPCWSTR lpText,\n"
"    LPCWSTR lpCaption,\n"
"    UINT uType);"
msgstr ""
"WINUSERAPI int WINAPI\n"
"MessageBoxW(\n"
"    HWND hWnd,\n"
"    LPCWSTR lpText,\n"
"    LPCWSTR lpCaption,\n"
"    UINT uType);"

#: ../../library/ctypes.rst:1855 ../../library/ctypes.rst:1878
msgid "Here is the wrapping with :mod:`ctypes`::"
msgstr "Här är förpackningen med :mod:`ctypes`::"

#: ../../library/ctypes.rst:1857
msgid ""
">>> from ctypes import c_int, WINFUNCTYPE, windll\n"
">>> from ctypes.wintypes import HWND, LPCWSTR, UINT\n"
">>> prototype = WINFUNCTYPE(c_int, HWND, LPCWSTR, LPCWSTR, UINT)\n"
">>> paramflags = (1, \"hwnd\", 0), (1, \"text\", \"Hi\"), (1, \"caption\", "
"\"Hello from ctypes\"), (1, \"flags\", 0)\n"
">>> MessageBox = prototype((\"MessageBoxW\", windll.user32), paramflags)"
msgstr ""
">>> från ctypes importera c_int, WINFUNCTYPE, windll\n"
">>> från ctypes.wintypes importera HWND, LPCWSTR, UINT\n"
">>> prototype = WINFUNCTYPE(c_int, HWND, LPCWSTR, LPCWSTR, UINT)\n"
">>> paramflags = (1, \"hwnd\", 0), (1, \"text\", \"Hi\"), (1, \"caption\", "
"\"Hello from ctypes\"), (1, \"flags\", 0)\n"
">>> MessageBox = prototyp((\"MessageBoxW\", windll.user32), paramflags)"

#: ../../library/ctypes.rst:1863
msgid "The ``MessageBox`` foreign function can now be called in these ways::"
msgstr ""
"Den utländska funktionen ``MessageBox`` kan nu anropas på följande sätt::"

#: ../../library/ctypes.rst:1865
msgid ""
">>> MessageBox()\n"
">>> MessageBox(text=\"Spam, spam, spam\")\n"
">>> MessageBox(flags=2, text=\"foo bar\")"
msgstr ""
">>> MessageBox()\n"
">>> MessageBox(text=\"Skräppost, skräppost, skräppost\")\n"
">>> MessageBox(flaggor=2, text=\"foo bar\")"

#: ../../library/ctypes.rst:1869
msgid ""
"A second example demonstrates output parameters.  The win32 "
"``GetWindowRect`` function retrieves the dimensions of a specified window by "
"copying them into ``RECT`` structure that the caller has to supply.  Here is "
"the C declaration::"
msgstr ""
"Ett andra exempel demonstrerar utdataparametrar.  Win32-funktionen "
"``GetWindowRect`` hämtar dimensionerna för ett angivet fönster genom att "
"kopiera dem till ``RECT``-strukturen som anroparen måste tillhandahålla.  "
"Här är C-deklarationen::"

#: ../../library/ctypes.rst:1873
msgid ""
"WINUSERAPI BOOL WINAPI\n"
"GetWindowRect(\n"
"     HWND hWnd,\n"
"     LPRECT lpRect);"
msgstr ""
"WINUSERAPI BOOL WINAPI\n"
"GetWindowRect(\n"
"     HWND hWnd,\n"
"     LPRECT lpRect);"

#: ../../library/ctypes.rst:1880
msgid ""
">>> from ctypes import POINTER, WINFUNCTYPE, windll, WinError\n"
">>> from ctypes.wintypes import BOOL, HWND, RECT\n"
">>> prototype = WINFUNCTYPE(BOOL, HWND, POINTER(RECT))\n"
">>> paramflags = (1, \"hwnd\"), (2, \"lprect\")\n"
">>> GetWindowRect = prototype((\"GetWindowRect\", windll.user32), "
"paramflags)\n"
">>>"
msgstr ""
">>> från ctypes importera POINTER, WINFUNCTYPE, windll, WinError\n"
">>> från ctypes.wintypes importera BOOL, HWND, RECT\n"
">>> prototype = WINFUNCTYPE(BOOL, HWND, POINTER(RECT))\n"
">>> paramflags = (1, \"hwnd\"), (2, \"lprect\")\n"
">>> GetWindowRect = prototyp((\"GetWindowRect\", windll.user32), "
"paramflags)\n"
">>>"

#: ../../library/ctypes.rst:1887
msgid ""
"Functions with output parameters will automatically return the output "
"parameter value if there is a single one, or a tuple containing the output "
"parameter values when there are more than one, so the GetWindowRect function "
"now returns a RECT instance, when called."
msgstr ""
"Funktioner med utparametrar returnerar automatiskt utparametervärdet om det "
"finns ett enda, eller en tupel som innehåller utparametervärdena om det "
"finns fler än ett, så funktionen GetWindowRect returnerar nu en RECT-instans "
"när den anropas."

#: ../../library/ctypes.rst:1892
msgid ""
"Output parameters can be combined with the :attr:`~_CFuncPtr.errcheck` "
"protocol to do further output processing and error checking.  The win32 "
"``GetWindowRect`` api function returns a ``BOOL`` to signal success or "
"failure, so this function could do the error checking, and raises an "
"exception when the api call failed::"
msgstr ""
"Utdataparametrar kan kombineras med :attr:`~_CFuncPtr.errcheck`-protokollet "
"för att göra ytterligare utdatabehandling och felkontroll.  Win32 "
"``GetWindowRect`` api-funktionen returnerar en ``BOOL`` för att signalera "
"framgång eller misslyckande, så den här funktionen kan göra felkontrollen "
"och ger upphov till ett undantag när api-anropet misslyckades::"

#: ../../library/ctypes.rst:1897
msgid ""
">>> def errcheck(result, func, args):\n"
"...     if not result:\n"
"...         raise WinError()\n"
"...     return args\n"
"...\n"
">>> GetWindowRect.errcheck = errcheck\n"
">>>"
msgstr ""
">>> def errcheck(resultat, func, args):\n"
"... om inte resultat:\n"
"... raise WinError()\n"
"... returnerar args\n"
"...\n"
">>> GetWindowRect.errcheck = errcheck\n"
">>>"

#: ../../library/ctypes.rst:1905
msgid ""
"If the :attr:`~_CFuncPtr.errcheck` function returns the argument tuple it "
"receives unchanged, :mod:`ctypes` continues the normal processing it does on "
"the output parameters.  If you want to return a tuple of window coordinates "
"instead of a ``RECT`` instance, you can retrieve the fields in the function "
"and return them instead, the normal processing will no longer take place::"
msgstr ""
"Om funktionen :attr:`~_CFuncPtr.errcheck` returnerar den argumenttupel som "
"den tar emot oförändrad, fortsätter :mod:`ctypes` med den normala "
"bearbetning som den gör på utdataparametrarna.  Om du vill returnera en "
"tupel av fönsterkoordinater istället för en ``RECT``-instans, kan du hämta "
"fälten i funktionen och returnera dem istället, den normala bearbetningen "
"kommer inte längre att äga rum::"

#: ../../library/ctypes.rst:1911
msgid ""
">>> def errcheck(result, func, args):\n"
"...     if not result:\n"
"...         raise WinError()\n"
"...     rc = args[1]\n"
"...     return rc.left, rc.top, rc.bottom, rc.right\n"
"...\n"
">>> GetWindowRect.errcheck = errcheck\n"
">>>"
msgstr ""
">>> def errcheck(resultat, func, args):\n"
"... om inte resultat:\n"
"... raise WinError()\n"
"... rc = args[1]\n"
"... return rc.vänster, rc.topp, rc.botten, rc.höger\n"
"...\n"
">>> GetWindowRect.errcheck = errcheck\n"
">>>"

#: ../../library/ctypes.rst:1924
msgid "Utility functions"
msgstr "Verktygsfunktioner"

#: ../../library/ctypes.rst:1928
msgid ""
"Returns the address of the memory buffer as integer.  *obj* must be an "
"instance of a ctypes type."
msgstr ""
"Returnerar minnesbuffertens adress som heltal.  *obj* måste vara en instans "
"av en ctypes-typ."

#: ../../library/ctypes.rst:1931
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.addressof`` with "
"argument ``obj``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``ctypes.addressof`` med "
"argumentet ``obj``."

#: ../../library/ctypes.rst:1936
msgid ""
"Returns the alignment requirements of a ctypes type. *obj_or_type* must be a "
"ctypes type or instance."
msgstr ""
"Returnerar anpassningskraven för en ctypes-typ. *obj_or_type* måste vara en "
"ctypes-typ eller -instans."

#: ../../library/ctypes.rst:1942
msgid ""
"Returns a light-weight pointer to *obj*, which must be an instance of a "
"ctypes type.  *offset* defaults to zero, and must be an integer that will be "
"added to the internal pointer value."
msgstr ""
"Returnerar en lättviktspekare till *obj*, som måste vara en instans av en "
"ctypes-typ.  *offset* är som standard noll och måste vara ett heltal som "
"läggs till det interna pekarvärdet."

#: ../../library/ctypes.rst:1946
msgid "``byref(obj, offset)`` corresponds to this C code::"
msgstr "``byref(obj, offset)`` motsvarar denna C-kod::"

#: ../../library/ctypes.rst:1948
msgid "(((char *)&obj) + offset)"
msgstr "(((char *)&obj) + offset)"

#: ../../library/ctypes.rst:1950
msgid ""
"The returned object can only be used as a foreign function call parameter. "
"It behaves similar to ``pointer(obj)``, but the construction is a lot faster."
msgstr ""
"Det returnerade objektet kan endast användas som en parameter i ett "
"främmande funktionsanrop. Det fungerar på samma sätt som ``pointer(obj)``, "
"men konstruktionen är mycket snabbare."

#: ../../library/ctypes.rst:1956
msgid ""
"This function is similar to the cast operator in C. It returns a new "
"instance of *type* which points to the same memory block as *obj*.  *type* "
"must be a pointer type, and *obj* must be an object that can be interpreted "
"as a pointer."
msgstr ""
"Denna funktion liknar cast-operatorn i C. Den returnerar en ny instans av "
"*type* som pekar på samma minnesblock som *obj*.  *typ* måste vara en "
"pekartyp och *obj* måste vara ett objekt som kan tolkas som en pekare."

#: ../../library/ctypes.rst:1965
msgid ""
"This function creates a mutable character buffer. The returned object is a "
"ctypes array of :class:`c_char`."
msgstr ""
"Denna funktion skapar en föränderlig teckenbuffert. Det returnerade objektet "
"är en ctypes-array av :class:`c_char`."

#: ../../library/ctypes.rst:1968
msgid ""
"If *size* is given (and not ``None``), it must be an :class:`int`. It "
"specifies the size of the returned array."
msgstr ""
"Om *size* anges (och inte ``None``) måste det vara en :class:`int`. Den "
"anger storleken på den returnerade arrayen."

#: ../../library/ctypes.rst:1971
msgid ""
"If the *init* argument is given, it must be :class:`bytes`. It is used to "
"initialize the array items. Bytes not initialized this way are set to zero "
"(NUL)."
msgstr ""
"Om *init*-argumentet anges måste det vara :class:`bytes`. Det används för "
"att initialisera arrayobjekten. Bytes som inte initieras på detta sätt sätts "
"till noll (NUL)."

#: ../../library/ctypes.rst:1975
msgid ""
"If *size* is not given (or if it is ``None``), the buffer is made one "
"element larger than *init*, effectively adding a NUL terminator."
msgstr ""
"Om *size* inte anges (eller om den är ``None``) görs bufferten ett element "
"större än *init*, vilket innebär att en NUL-terminator läggs till."

#: ../../library/ctypes.rst:1978
msgid ""
"If both arguments are given, *size* must not be less than ``len(init)``."
msgstr "Om båda argumenten anges får *size* inte vara mindre än ``len(init)``."

#: ../../library/ctypes.rst:1982
msgid ""
"If *size* is equal to ``len(init)``, a NUL terminator is not added. Do not "
"treat such a buffer as a C string."
msgstr ""
"Om *size* är lika med ``len(init)``, läggs ingen NUL-terminator till. "
"Behandla inte en sådan buffert som en C-sträng."

#: ../../library/ctypes.rst:1985
msgid "For example::"
msgstr "Till exempel::"

#: ../../library/ctypes.rst:1987
msgid ""
">>> bytes(create_string_buffer(2))\n"
"b'\\x00\\x00'\n"
">>> bytes(create_string_buffer(b'ab'))\n"
"b'ab\\x00'\n"
">>> bytes(create_string_buffer(b'ab', 2))\n"
"b'ab'\n"
">>> bytes(create_string_buffer(b'ab', 4))\n"
"b'ab\\x00\\x00'\n"
">>> bytes(create_string_buffer(b'abcdef', 2))\n"
"Traceback (most recent call last):\n"
"   ...\n"
"ValueError: byte string too long"
msgstr ""
">>> bytes(skapa_sträng_buffer(2))\n"
"b'\\x00\\x00'\n"
">>> byte(skapa_sträng_buffer(b'ab'))\n"
"b'ab\\x00'\n"
">>> byte(skapa_sträng_buffer(b'ab', 2))\n"
"b'ab'\n"
">>> byte(skapa_sträng_buffer(b'ab', 4))\n"
"b'ab\\x00\\x00'\n"
">>> byte(skapa_sträng_buffert(b'abcdef', 2))\n"
"Traceback (senaste anropet senast):\n"
"   ...\n"
"ValueError: byte-strängen är för lång"

#: ../../library/ctypes.rst:2000
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.create_string_buffer`` "
"with arguments ``init``, ``size``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``ctypes.create_string_buffer`` "
"med argumenten ``init``, ``size``."

#: ../../library/ctypes.rst:2006
msgid ""
"This function creates a mutable unicode character buffer. The returned "
"object is a ctypes array of :class:`c_wchar`."
msgstr ""
"Denna funktion skapar en mutabel unicode-teckenbuffert. Det returnerade "
"objektet är en ctypes-array av :class:`c_wchar`."

#: ../../library/ctypes.rst:2009
msgid ""
"The function takes the same arguments as :func:`~create_string_buffer` "
"except *init* must be a string and *size* counts :class:`c_wchar`."
msgstr ""
"Funktionen tar samma argument som :func:`~create_string_buffer` förutom att "
"*init* måste vara en sträng och *size* räknar :class:`c_wchar`."

#: ../../library/ctypes.rst:2012
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.create_unicode_buffer`` "
"with arguments ``init``, ``size``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``ctypes.create_unicode_buffer`` "
"med argumenten ``init``, ``size``."

#: ../../library/ctypes.rst:2017
msgid ""
"This function is a hook which allows implementing in-process COM servers "
"with ctypes.  It is called from the DllCanUnloadNow function that the "
"_ctypes extension dll exports."
msgstr ""
"Denna funktion är en krok som gör det möjligt att implementera COM-servrar i "
"processen med ctypes.  Den anropas från funktionen DllCanUnloadNow som "
"exporteras av tilläggsdivisionen _ctypes."

#: ../../library/ctypes.rst:2026
msgid ""
"This function is a hook which allows implementing in-process COM servers "
"with ctypes.  It is called from the DllGetClassObject function that the "
"``_ctypes`` extension dll exports."
msgstr ""
"Denna funktion är en krok som gör det möjligt att implementera COM-servrar i "
"processen med ctypes.  Den anropas från funktionen DllGetClassObject som "
"exporteras av dll-tillägget ``_ctypes``."

#: ../../library/ctypes.rst:2036
msgid ""
"Try to find a library and return a pathname.  *name* is the library name "
"without any prefix like ``lib``, suffix like ``.so``, ``.dylib`` or version "
"number (this is the form used for the posix linker option :option:`!-l`).  "
"If no library can be found, returns ``None``."
msgstr ""
"Försöker hitta ett bibliotek och returnerar ett sökvägsnamn.  *name* är "
"biblioteksnamnet utan något prefix som ``lib``, suffix som ``.so``, ``."
"dylib`` eller versionsnummer (detta är den form som används för posix-"
"länkaralternativet :option:`!-l`).  Om inget bibliotek kan hittas returneras "
"``None``."

#: ../../library/ctypes.rst:2043
msgid "See :ref:`ctypes-finding-shared-libraries` for complete documentation."
msgstr ""

#: ../../library/ctypes.rst:2049
msgid ""
"Returns the filename of the VC runtime library used by Python, and by the "
"extension modules.  If the name of the library cannot be determined, "
"``None`` is returned."
msgstr ""
"Returnerar filnamnet på det VC runtime-bibliotek som används av Python och "
"av tilläggsmodulerna.  Om namnet på biblioteket inte kan fastställas "
"returneras ``None``."

#: ../../library/ctypes.rst:2053
msgid ""
"If you need to free memory, for example, allocated by an extension module "
"with a call to the ``free(void *)``, it is important that you use the "
"function in the same library that allocated the memory."
msgstr ""
"Om du behöver frigöra minne, t.ex. minne som har allokerats av en "
"tilläggsmodul med ett anrop till funktionen ``free(void *)``, är det viktigt "
"att du använder funktionen i samma bibliotek som allokerade minnet."

#: ../../library/ctypes.rst:2062
msgid ""
"Returns a textual description of the error code *code*.  If no error code is "
"specified, the last error code is used by calling the Windows api function "
"GetLastError."
msgstr ""

#: ../../library/ctypes.rst:2071
msgid ""
"Returns the last error code set by Windows in the calling thread. This "
"function calls the Windows ``GetLastError()`` function directly, it does not "
"return the ctypes-private copy of the error code."
msgstr ""
"Returnerar den senaste felkoden som ställts in av Windows i den anropande "
"tråden. Denna funktion anropar Windows-funktionen ``GetLastError()`` direkt, "
"den returnerar inte den ctypes-privata kopian av felkoden."

#: ../../library/ctypes.rst:2080
msgid ""
"Returns the current value of the ctypes-private copy of the system :data:"
"`errno` variable in the calling thread."
msgstr ""
"Returnerar det aktuella värdet av den ctypes-privata kopian av "
"systemvariabeln :data:`errno` i den anropande tråden."

#: ../../library/ctypes.rst:2083
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.get_errno`` with no "
"arguments."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``ctypes.get_errno`` utan "
"argument."

#: ../../library/ctypes.rst:2087
msgid ""
"Returns the current value of the ctypes-private copy of the system :data:`!"
"LastError` variable in the calling thread."
msgstr ""
"Returnerar det aktuella värdet av den ctypes-privata kopian av "
"systemvariabeln :data:`!LastError` i den anropande tråden."

#: ../../library/ctypes.rst:2092
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.get_last_error`` with no "
"arguments."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``ctypes.get_last_error`` utan "
"argument."

#: ../../library/ctypes.rst:2097
msgid ""
"Same as the standard C memmove library function: copies *count* bytes from "
"*src* to *dst*. *dst* and *src* must be integers or ctypes instances that "
"can be converted to pointers."
msgstr ""
"Samma som standard C memmove biblioteksfunktionen: kopierar *count* bytes "
"från *src* till *dst*. *dst* och *src* måste vara heltal eller ctypes-"
"instanser som kan konverteras till pekare."

#: ../../library/ctypes.rst:2104
msgid ""
"Same as the standard C memset library function: fills the memory block at "
"address *dst* with *count* bytes of value *c*. *dst* must be an integer "
"specifying an address, or a ctypes instance."
msgstr ""
"Samma som standardfunktionen memset i C-biblioteket: fyller minnesblocket på "
"adress *dst* med *count* byte av värdet *c*. *dst* måste vara ett heltal som "
"anger en adress, eller en ctypes-instans."

#: ../../library/ctypes.rst:2111
msgid ""
"Create and return a new ctypes pointer type. Pointer types are cached and "
"reused internally, so calling this function repeatedly is cheap. *type* must "
"be a ctypes type."
msgstr ""

#: ../../library/ctypes.rst:2118
msgid ""
"Create a new pointer instance, pointing to *obj*. The returned object is of "
"the type ``POINTER(type(obj))``."
msgstr ""
"Skapa en ny pekarinstans som pekar på *obj*. Det returnerade objektet är av "
"typen ``POINTER(type(obj))``."

#: ../../library/ctypes.rst:2121
msgid ""
"Note: If you just want to pass a pointer to an object to a foreign function "
"call, you should use ``byref(obj)`` which is much faster."
msgstr ""
"Observera: Om du bara vill skicka en pekare till ett objekt till ett "
"främmande funktionsanrop bör du använda ``byref(obj)`` som är mycket "
"snabbare."

#: ../../library/ctypes.rst:2127
msgid ""
"This function resizes the internal memory buffer of *obj*, which must be an "
"instance of a ctypes type.  It is not possible to make the buffer smaller "
"than the native size of the objects type, as given by ``sizeof(type(obj))``, "
"but it is possible to enlarge the buffer."
msgstr ""
"Den här funktionen ändrar storleken på internminnesbufferten för *obj*, som "
"måste vara en instans av en ctypes-typ.  Det är inte möjligt att göra "
"bufferten mindre än den ursprungliga storleken för objekttypen, som anges av "
"``sizeof(type(obj))``, men det är möjligt att förstora bufferten."

#: ../../library/ctypes.rst:2135
msgid ""
"Set the current value of the ctypes-private copy of the system :data:`errno` "
"variable in the calling thread to *value* and return the previous value."
msgstr ""
"Ställ in det aktuella värdet för den ctypes-privata kopian av "
"systemvariabeln :data:`errno` i den anropande tråden till *värde* och "
"returnera det tidigare värdet."

#: ../../library/ctypes.rst:2138
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.set_errno`` with "
"argument ``errno``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``ctypes.set_errno`` med "
"argumentet ``errno``."

#: ../../library/ctypes.rst:2143
msgid ""
"Sets the current value of the ctypes-private copy of the system :data:`!"
"LastError` variable in the calling thread to *value* and return the previous "
"value."
msgstr ""
"Ställer in det aktuella värdet för den ctypes-privata kopian av "
"systemvariabeln :data:`!LastError` i den anropande tråden till *värde* och "
"returnerar det tidigare värdet."

#: ../../library/ctypes.rst:2149
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.set_last_error`` with "
"argument ``error``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``ctypes.set_last_error`` med "
"argumentet ``error``."

#: ../../library/ctypes.rst:2154
msgid ""
"Returns the size in bytes of a ctypes type or instance memory buffer. Does "
"the same as the C ``sizeof`` operator."
msgstr ""
"Returnerar storleken i byte på en minnesbuffert för en ctypes-typ eller "
"instans. Gör samma sak som C-operatorn ``sizeof``."

#: ../../library/ctypes.rst:2160
msgid ""
"Return the byte string at *void \\*ptr*. If *size* is specified, it is used "
"as size, otherwise the string is assumed to be zero-terminated."
msgstr ""
"Returnerar byte-strängen på *void \\*ptr*. Om *size* anges används den som "
"storlek, annars antas strängen vara nollavslutad."

#: ../../library/ctypes.rst:2164
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.string_at`` with "
"arguments ``ptr``, ``size``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``ctypes.string_at`` med "
"argumenten ``ptr``, ``size``."

#: ../../library/ctypes.rst:2169
msgid ""
"This function is probably the worst-named thing in ctypes. It creates an "
"instance of :exc:`OSError`.  If *code* is not specified, ``GetLastError`` is "
"called to determine the error code. If *descr* is not specified, :func:"
"`FormatError` is called to get a textual description of the error."
msgstr ""

#: ../../library/ctypes.rst:2177
msgid ""
"An instance of :exc:`WindowsError` used to be created, which is now an alias "
"of :exc:`OSError`."
msgstr ""
"Tidigare skapades en instans av :exc:`WindowsError`, som nu är ett alias av :"
"exc:`OSError`."

#: ../../library/ctypes.rst:2184
msgid ""
"Return the wide-character string at *void \\*ptr*. If *size* is specified, "
"it is used as the number of characters of the string, otherwise the string "
"is assumed to be zero-terminated."
msgstr ""
"Returnerar den breda teckensträngen på *void \\*ptr*. Om *size* anges "
"används det som antal tecken i strängen, annars antas strängen vara "
"nollavslutad."

#: ../../library/ctypes.rst:2189
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.wstring_at`` with "
"arguments ``ptr``, ``size``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``ctypes.wstring_at`` med "
"argumenten ``ptr``, ``size``."

#: ../../library/ctypes.rst:2195
msgid "Data types"
msgstr "Datatyper"

#: ../../library/ctypes.rst:2200
msgid ""
"This non-public class is the common base class of all ctypes data types. "
"Among other things, all ctypes type instances contain a memory block that "
"hold C compatible data; the address of the memory block is returned by the :"
"func:`addressof` helper function. Another instance variable is exposed as :"
"attr:`_objects`; this contains other Python objects that need to be kept "
"alive in case the memory block contains pointers."
msgstr ""
"Denna icke-offentliga klass är den gemensamma basklassen för alla ctypes-"
"datatyper. Bland annat innehåller alla instanser av ctypes-typen ett "
"minnesblock som innehåller C-kompatibla data; adressen till minnesblocket "
"returneras av hjälpfunktionen :func:`addressof`. En annan instansvariabel "
"exponeras som :attr:`_objects`; denna innehåller andra Python-objekt som "
"måste hållas vid liv ifall minnesblocket innehåller pekare."

#: ../../library/ctypes.rst:2207
msgid ""
"Common methods of ctypes data types, these are all class methods (to be "
"exact, they are methods of the :term:`metaclass`):"
msgstr ""
"Vanliga metoder för ctypes-datatyper, dessa är alla klassmetoder (för att "
"vara exakt är de metoder för :term:`metaclass`):"

#: ../../library/ctypes.rst:2212
msgid ""
"This method returns a ctypes instance that shares the buffer of the *source* "
"object.  The *source* object must support the writeable buffer interface.  "
"The optional *offset* parameter specifies an offset into the source buffer "
"in bytes; the default is zero.  If the source buffer is not large enough a :"
"exc:`ValueError` is raised."
msgstr ""
"Denna metod returnerar en ctypes-instans som delar buffert med *käll*-"
"objektet.  Objektet *källa* måste stödja gränssnittet för skrivbar buffert.  "
"Den valfria parametern *offset* anger en förskjutning i källbufferten i "
"byte; standardvärdet är noll.  Om källbufferten inte är tillräckligt stor "
"uppstår ett :exc:`ValueError`."

#: ../../library/ctypes.rst:2218 ../../library/ctypes.rst:2228
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.cdata/buffer`` with "
"arguments ``pointer``, ``size``, ``offset``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``ctypes.cdata/buffer`` med "
"argumenten ``pointer``, ``size``, ``offset``."

#: ../../library/ctypes.rst:2222
msgid ""
"This method creates a ctypes instance, copying the buffer from the *source* "
"object buffer which must be readable.  The optional *offset* parameter "
"specifies an offset into the source buffer in bytes; the default is zero.  "
"If the source buffer is not large enough a :exc:`ValueError` is raised."
msgstr ""
"Denna metod skapar en ctypes-instans genom att kopiera bufferten från "
"*källans* objektbuffert som måste vara läsbar.  Den valfria parametern "
"*offset* anger en förskjutning i källbufferten i byte; standardvärdet är "
"noll.  Om källbufferten inte är tillräckligt stor uppstår ett :exc:"
"`ValueError`."

#: ../../library/ctypes.rst:2232
msgid ""
"This method returns a ctypes type instance using the memory specified by "
"*address* which must be an integer."
msgstr ""
"Den här metoden returnerar en ctypes-typinstans som använder det minne som "
"anges av *address*, som måste vara ett heltal."

#: ../../library/ctypes.rst:2235 ../../library/ctypes.rst:2237
msgid ""
"This method, and others that indirectly call this method, raises an :ref:"
"`auditing event <auditing>` ``ctypes.cdata`` with argument ``address``."
msgstr ""
"Denna metod, och andra som indirekt anropar denna metod, ger upphov till en :"
"ref:``auditing event <auditing>``ctypes.cdata`` med argumentet ``address``."

#: ../../library/ctypes.rst:2243
msgid ""
"This method adapts *obj* to a ctypes type.  It is called with the actual "
"object used in a foreign function call when the type is present in the "
"foreign function's :attr:`~_CFuncPtr.argtypes` tuple; it must return an "
"object that can be used as a function call parameter."
msgstr ""
"Denna metod anpassar *obj* till en ctypes-typ.  Den anropas med det faktiska "
"objekt som används i ett utländskt funktionsanrop när typen finns i den "
"utländska funktionens :attr:`~_CFuncPtr.argtypes`-tupel; den måste returnera "
"ett objekt som kan användas som parameter för funktionsanropet."

#: ../../library/ctypes.rst:2248
msgid ""
"All ctypes data types have a default implementation of this classmethod that "
"normally returns *obj* if that is an instance of the type.  Some types "
"accept other objects as well."
msgstr ""
"Alla ctypes-datatyper har en standardimplementering av denna classmethod som "
"normalt returnerar *obj* om det är en instans av typen.  Vissa typer "
"accepterar även andra objekt."

#: ../../library/ctypes.rst:2254
msgid ""
"This method returns a ctypes type instance exported by a shared library. "
"*name* is the name of the symbol that exports the data, *library* is the "
"loaded shared library."
msgstr ""
"Denna metod returnerar en ctypes-typinstans som exporteras av ett delat "
"bibliotek. *name* är namnet på den symbol som exporterar data, *library* är "
"det laddade delade biblioteket."

#: ../../library/ctypes.rst:2258
msgid "Common instance variables of ctypes data types:"
msgstr "Vanliga instansvariabler för ctypes datatyper:"

#: ../../library/ctypes.rst:2262
msgid ""
"Sometimes ctypes data instances do not own the memory block they contain, "
"instead they share part of the memory block of a base object.  The :attr:"
"`_b_base_` read-only member is the root ctypes object that owns the memory "
"block."
msgstr ""
"Ibland äger inte ctypes-datainstanser det minnesblock de innehåller, utan de "
"delar istället en del av minnesblocket för ett basobjekt.  Den skrivskyddade "
"medlemmen :attr:`_b_base_` är det rot-ctypes-objekt som äger minnesblocket."

#: ../../library/ctypes.rst:2269
msgid ""
"This read-only variable is true when the ctypes data instance has allocated "
"the memory block itself, false otherwise."
msgstr ""
"Denna skrivskyddade variabel är sann när ctypes-datainstansen har allokerat "
"minnesblocket själv, annars falsk."

#: ../../library/ctypes.rst:2274
msgid ""
"This member is either ``None`` or a dictionary containing Python objects "
"that need to be kept alive so that the memory block contents is kept valid.  "
"This object is only exposed for debugging; never modify the contents of this "
"dictionary."
msgstr ""
"Denna medlem är antingen ``None`` eller en ordbok som innehåller Python-"
"objekt som måste hållas vid liv så att minnesblockets innehåll hålls "
"giltigt.  Detta objekt är endast exponerat för felsökning; ändra aldrig "
"innehållet i denna ordbok."

#: ../../library/ctypes.rst:2287
msgid ""
"This non-public class is the base class of all fundamental ctypes data "
"types. It is mentioned here because it contains the common attributes of the "
"fundamental ctypes data types.  :class:`_SimpleCData` is a subclass of :"
"class:`_CData`, so it inherits their methods and attributes. ctypes data "
"types that are not and do not contain pointers can now be pickled."
msgstr ""
"Denna icke-offentliga klass är basklass för alla grundläggande ctypes-"
"datatyper. Den nämns här eftersom den innehåller de gemensamma attributen "
"för de grundläggande ctypes-datatyperna. :class:`_SimpleCData` är en "
"underklass till :class:`_CData`, så den ärver deras metoder och attribut. "
"ctypes-datatyper som inte är och inte innehåller pekare kan nu picklas."

#: ../../library/ctypes.rst:2293
msgid "Instances have a single attribute:"
msgstr "Instanser har ett enda attribut:"

#: ../../library/ctypes.rst:2297
msgid ""
"This attribute contains the actual value of the instance. For integer and "
"pointer types, it is an integer, for character types, it is a single "
"character bytes object or string, for character pointer types it is a Python "
"bytes object or string."
msgstr ""
"Detta attribut innehåller det faktiska värdet för instansen. För heltals- "
"och pekartyper är det ett heltal, för teckentyper är det ett objekt eller en "
"sträng med enstaka teckenbytes, för teckenspekartyper är det ett objekt "
"eller en sträng med Python-bytes."

#: ../../library/ctypes.rst:2302
msgid ""
"When the ``value`` attribute is retrieved from a ctypes instance, usually a "
"new object is returned each time.  :mod:`ctypes` does *not* implement "
"original object return, always a new object is constructed.  The same is "
"true for all other ctypes object instances."
msgstr ""
"När attributet ``value`` hämtas från en ctypes-instans returneras vanligtvis "
"ett nytt objekt varje gång. :mod:`ctypes` implementerar *inte* "
"originalobjektretur, alltid konstrueras ett nytt objekt.  Detsamma gäller "
"för alla andra ctypes-objektinstanser."

#: ../../library/ctypes.rst:2308
msgid ""
"Fundamental data types, when returned as foreign function call results, or, "
"for example, by retrieving structure field members or array items, are "
"transparently converted to native Python types.  In other words, if a "
"foreign function has a :attr:`~_CFuncPtr.restype` of :class:`c_char_p`, you "
"will always receive a Python bytes object, *not* a :class:`c_char_p` "
"instance."
msgstr ""
"Grundläggande datatyper, när de returneras som resultat av anrop från "
"främmande funktioner, eller till exempel genom att hämta "
"strukturfältmedlemmar eller arrayobjekt, konverteras transparent till "
"ursprungliga Python-typer.  Med andra ord, om en utländsk funktion har en :"
"attr:`~_CFuncPtr.restype` av :class:`c_char_p`, kommer du alltid att få ett "
"Python bytes-objekt, *inte* en :class:`c_char_p`-instans."

#: ../../library/ctypes.rst:2316
msgid ""
"Subclasses of fundamental data types do *not* inherit this behavior. So, if "
"a foreign functions :attr:`!restype` is a subclass of :class:`c_void_p`, you "
"will receive an instance of this subclass from the function call. Of course, "
"you can get the value of the pointer by accessing the ``value`` attribute."
msgstr ""
"Underklasser av grundläggande datatyper ärver *inte* detta beteende. Så om "
"en utländsk funktion :attr:`!restype` är en subklass av :class:`c_void_p`, "
"kommer du att få en instans av denna subklass från funktionsanropet. "
"Naturligtvis kan du få pekarens värde genom att komma åt attributet "
"``value``."

#: ../../library/ctypes.rst:2321
msgid "These are the fundamental ctypes data types:"
msgstr "Dessa är de grundläggande ctypes-datatyperna:"

#: ../../library/ctypes.rst:2325
msgid ""
"Represents the C :c:expr:`signed char` datatype, and interprets the value as "
"small integer.  The constructor accepts an optional integer initializer; no "
"overflow checking is done."
msgstr ""
"Representerar C:s datatyp :c:expr:`signed char` och tolkar värdet som ett "
"litet heltal.  Konstruktören accepterar en valfri heltalsinitialiserare; "
"ingen kontroll av överflöd görs."

#: ../../library/ctypes.rst:2332
msgid ""
"Represents the C :c:expr:`char` datatype, and interprets the value as a "
"single character.  The constructor accepts an optional string initializer, "
"the length of the string must be exactly one character."
msgstr ""
"Representerar C :c:expr:`char`-datatypen och tolkar värdet som ett enda "
"tecken.  Konstruktören accepterar en valfri stränginitialiserare, strängens "
"längd måste vara exakt ett tecken."

#: ../../library/ctypes.rst:2339
msgid ""
"Represents the C :c:expr:`char *` datatype when it points to a zero-"
"terminated string.  For a general character pointer that may also point to "
"binary data, ``POINTER(c_char)`` must be used.  The constructor accepts an "
"integer address, or a bytes object."
msgstr ""
"Representerar datatypen C :c:expr:`char *` när den pekar på en nollavslutad "
"sträng.  För en allmän teckenpekare som också kan peka på binära data måste "
"``POINTER(c_char)`` användas.  Konstruktören accepterar en heltalsadress "
"eller ett bytes-objekt."

#: ../../library/ctypes.rst:2347
msgid ""
"Represents the C :c:expr:`double` datatype.  The constructor accepts an "
"optional float initializer."
msgstr ""
"Representerar datatypen C :c:expr:`double`.  Konstruktören accepterar en "
"valfri float-initialiserare."

#: ../../library/ctypes.rst:2353
msgid ""
"Represents the C :c:expr:`long double` datatype.  The constructor accepts an "
"optional float initializer.  On platforms where ``sizeof(long double) == "
"sizeof(double)`` it is an alias to :class:`c_double`."
msgstr ""
"Representerar datatypen C :c:expr:`long double`.  Konstruktorn accepterar en "
"valfri float-initialiserare.  På plattformar där ``sizeof(long double) == "
"sizeof(double)`` är det ett alias till :class:`c_double`."

#: ../../library/ctypes.rst:2359
msgid ""
"Represents the C :c:expr:`float` datatype.  The constructor accepts an "
"optional float initializer."
msgstr ""
"Representerar datatypen C :c:expr:`float`.  Konstruktören accepterar en "
"valfri float-initialiserare."

#: ../../library/ctypes.rst:2365
msgid ""
"Represents the C :c:expr:`signed int` datatype.  The constructor accepts an "
"optional integer initializer; no overflow checking is done.  On platforms "
"where ``sizeof(int) == sizeof(long)`` it is an alias to :class:`c_long`."
msgstr ""
"Representerar datatypen C :c:expr:`signed int`.  Konstruktorn accepterar en "
"valfri heltalsinitialiserare; ingen kontroll av överflöd görs.  På "
"plattformar där ``sizeof(int) == sizeof(long)`` är det ett alias till :class:"
"`c_long`."

#: ../../library/ctypes.rst:2372
msgid ""
"Represents the C 8-bit :c:expr:`signed int` datatype.  It is an alias for :"
"class:`c_byte`."
msgstr ""
"Representerar C 8-bitars :c:expr:`signed int`-datatypen.  Det är ett alias "
"för :class:`c_byte`."

#: ../../library/ctypes.rst:2378
msgid ""
"Represents the C 16-bit :c:expr:`signed int` datatype.  Usually an alias "
"for :class:`c_short`."
msgstr ""
"Representerar C 16-bitars :c:expr:`signed int`-datatypen.  Vanligtvis ett "
"alias för :class:`c_short`."

#: ../../library/ctypes.rst:2384
msgid ""
"Represents the C 32-bit :c:expr:`signed int` datatype.  Usually an alias "
"for :class:`c_int`."
msgstr ""
"Representerar C 32-bitars :c:expr:`signed int`-datatypen.  Vanligtvis ett "
"alias för :class:`c_int`."

#: ../../library/ctypes.rst:2390
msgid ""
"Represents the C 64-bit :c:expr:`signed int` datatype.  Usually an alias "
"for :class:`c_longlong`."
msgstr ""
"Representerar C 64-bitars :c:expr:`signed int`-datatypen.  Vanligtvis ett "
"alias för :class:`c_longlong`."

#: ../../library/ctypes.rst:2396
msgid ""
"Represents the C :c:expr:`signed long` datatype.  The constructor accepts an "
"optional integer initializer; no overflow checking is done."
msgstr ""
"Representerar datatypen C :c:expr:`signed long`.  Konstruktören accepterar "
"en valfri heltalsinitialiserare; ingen kontroll av överflöd görs."

#: ../../library/ctypes.rst:2402
msgid ""
"Represents the C :c:expr:`signed long long` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done."
msgstr ""
"Representerar datatypen C :c:expr:`signed long long`.  Konstruktören "
"accepterar en valfri heltalsinitialiserare; ingen kontroll av överflöd görs."

#: ../../library/ctypes.rst:2408
msgid ""
"Represents the C :c:expr:`signed short` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done."
msgstr ""
"Representerar datatypen C :c:expr:`signed short`.  Konstruktören accepterar "
"en valfri heltalsinitialiserare; ingen kontroll av överflöd görs."

#: ../../library/ctypes.rst:2414
msgid "Represents the C :c:type:`size_t` datatype."
msgstr "Representerar datatypen C :c:type:`size_t`."

#: ../../library/ctypes.rst:2419
msgid "Represents the C :c:type:`ssize_t` datatype."
msgstr "Representerar datatypen C :c:type:`ssize_t`."

#: ../../library/ctypes.rst:2426
msgid "Represents the C :c:type:`time_t` datatype."
msgstr "Representerar datatypen C :c:type:`time_t`."

#: ../../library/ctypes.rst:2433
msgid ""
"Represents the C :c:expr:`unsigned char` datatype, it interprets the value "
"as small integer.  The constructor accepts an optional integer initializer; "
"no overflow checking is done."
msgstr ""
"Representerar C :c:expr:`unsigned char`-datatypen, tolkar värdet som ett "
"litet heltal.  Konstruktören accepterar en valfri heltalsinitialiserare; "
"ingen kontroll av överflöd görs."

#: ../../library/ctypes.rst:2440
msgid ""
"Represents the C :c:expr:`unsigned int` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done.  On platforms "
"where ``sizeof(int) == sizeof(long)`` it is an alias for :class:`c_ulong`."
msgstr ""
"Representerar datatypen C :c:expr:`unsigned int`.  Konstruktorn accepterar "
"en valfri heltalsinitialiserare; ingen kontroll av överflöd görs.  På "
"plattformar där ``sizeof(int) == sizeof(long)`` är det ett alias för :class:"
"`c_ulong`."

#: ../../library/ctypes.rst:2447
msgid ""
"Represents the C 8-bit :c:expr:`unsigned int` datatype.  It is an alias for :"
"class:`c_ubyte`."
msgstr ""
"Representerar C 8-bitars datatypen :c:expr:`unsigned int`.  Det är ett alias "
"för :class:`c_ubyte`."

#: ../../library/ctypes.rst:2453
msgid ""
"Represents the C 16-bit :c:expr:`unsigned int` datatype.  Usually an alias "
"for :class:`c_ushort`."
msgstr ""
"Representerar C 16-bitars :c:expr:`unsigned int`-datatypen.  Vanligtvis ett "
"alias för :class:`c_ushort`."

#: ../../library/ctypes.rst:2459
msgid ""
"Represents the C 32-bit :c:expr:`unsigned int` datatype.  Usually an alias "
"for :class:`c_uint`."
msgstr ""
"Representerar C 32-bitars :c:expr:`unsigned int`-datatypen.  Vanligtvis ett "
"alias för :class:`c_uint`."

#: ../../library/ctypes.rst:2465
msgid ""
"Represents the C 64-bit :c:expr:`unsigned int` datatype.  Usually an alias "
"for :class:`c_ulonglong`."
msgstr ""
"Representerar C 64-bitars :c:expr:`unsigned int`-datatypen.  Vanligtvis ett "
"alias för :class:`c_ulonglong`."

#: ../../library/ctypes.rst:2471
msgid ""
"Represents the C :c:expr:`unsigned long` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done."
msgstr ""
"Representerar datatypen C :c:expr:`unsigned long`.  Konstruktören accepterar "
"en valfri heltalsinitialiserare; ingen kontroll av överflöd görs."

#: ../../library/ctypes.rst:2477
msgid ""
"Represents the C :c:expr:`unsigned long long` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done."
msgstr ""
"Representerar datatypen C :c:expr:`unsigned long long`.  Konstruktören "
"accepterar en valfri heltalsinitialiserare; ingen kontroll av överflöd görs."

#: ../../library/ctypes.rst:2483
msgid ""
"Represents the C :c:expr:`unsigned short` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done."
msgstr ""
"Representerar datatypen C :c:expr:`unsigned short`.  Konstruktören "
"accepterar en valfri heltalsinitialiserare; ingen kontroll av överflöd görs."

#: ../../library/ctypes.rst:2489
msgid ""
"Represents the C :c:expr:`void *` type.  The value is represented as "
"integer. The constructor accepts an optional integer initializer."
msgstr ""
"Representerar C :c:expr:`void *`-typen.  Värdet representeras som ett "
"heltal. Konstruktören accepterar en valfri heltalsinitialiserare."

#: ../../library/ctypes.rst:2495
msgid ""
"Represents the C :c:type:`wchar_t` datatype, and interprets the value as a "
"single character unicode string.  The constructor accepts an optional string "
"initializer, the length of the string must be exactly one character."
msgstr ""
"Representerar datatypen C :c:type:`wchar_t` och tolkar värdet som en unicode-"
"sträng med ett tecken.  Konstruktören accepterar en valfri "
"stränginitialiserare, strängens längd måste vara exakt ett tecken."

#: ../../library/ctypes.rst:2502
msgid ""
"Represents the C :c:expr:`wchar_t *` datatype, which must be a pointer to a "
"zero-terminated wide character string.  The constructor accepts an integer "
"address, or a string."
msgstr ""
"Representerar datatypen C :c:expr:`wchar_t *`, som måste vara en pekare till "
"en nollavslutad bred teckensträng.  Konstruktören accepterar en "
"heltalsadress eller en sträng."

#: ../../library/ctypes.rst:2509
msgid ""
"Represent the C :c:expr:`bool` datatype (more accurately, :c:expr:`_Bool` "
"from C99).  Its value can be ``True`` or ``False``, and the constructor "
"accepts any object that has a truth value."
msgstr ""
"Representerar C:s datatyp :c:expr:`bool` (mer exakt :c:expr:`_Bool` från "
"C99).  Dess värde kan vara ``True`` eller ``False``, och konstruktören "
"accepterar alla objekt som har ett sanningsvärde."

#: ../../library/ctypes.rst:2516
msgid ""
"Represents a :c:type:`!HRESULT` value, which contains success or error "
"information for a function or method call."
msgstr ""
"Representerar ett värde av :c:type:`!HRESULT`, som innehåller information om "
"framgång eller fel för ett funktions- eller metodanrop."

#: ../../library/ctypes.rst:2524
msgid ""
"Represents the C :c:expr:`PyObject *` datatype.  Calling this without an "
"argument creates a ``NULL`` :c:expr:`PyObject *` pointer."
msgstr ""
"Representerar datatypen C :c:expr:`PyObject *`.  Anrop av detta utan "
"argument skapar en ``NULL`` :c:expr:`PyObject *`-pekare."

#: ../../library/ctypes.rst:2527
msgid ""
"The :mod:`!ctypes.wintypes` module provides quite some other Windows "
"specific data types, for example :c:type:`!HWND`, :c:type:`!WPARAM`, or :c:"
"type:`!DWORD`. Some useful structures like :c:type:`!MSG` or :c:type:`!RECT` "
"are also defined."
msgstr ""
"Modulen :mod:`!ctypes.wintypes` tillhandahåller en hel del andra Windows-"
"specifika datatyper, till exempel :c:type:`!HWND`, :c:type:`!WPARAM` eller :"
"c:type:`!DWORD`. Några användbara strukturer som :c:type:`!MSG` eller :c:"
"type:`!RECT` är också definierade."

#: ../../library/ctypes.rst:2535
msgid "Structured data types"
msgstr "Strukturerade datatyper"

#: ../../library/ctypes.rst:2540
msgid "Abstract base class for unions in native byte order."
msgstr "Abstrakt basklass för unioner i inbyggd byte-ordning."

#: ../../library/ctypes.rst:2545
msgid "Abstract base class for unions in *big endian* byte order."
msgstr "Abstrakt basklass för unioner i *big endian* byteordning."

#: ../../library/ctypes.rst:2551
msgid "Abstract base class for unions in *little endian* byte order."
msgstr "Abstrakt basklass för unioner i byteordning *little endian*."

#: ../../library/ctypes.rst:2557
msgid "Abstract base class for structures in *big endian* byte order."
msgstr "Abstrakt basklass för strukturer i *big endian* byteordning."

#: ../../library/ctypes.rst:2562
msgid "Abstract base class for structures in *little endian* byte order."
msgstr "Abstrakt basklass för strukturer i byteordning *little endian*."

#: ../../library/ctypes.rst:2564
msgid ""
"Structures and unions with non-native byte order cannot contain pointer type "
"fields, or any other data types containing pointer type fields."
msgstr ""
"Strukturer och unioner med icke inhemsk byteordning kan inte innehålla fält "
"av pekartyp eller andra datatyper som innehåller fält av pekartyp."

#: ../../library/ctypes.rst:2570
msgid "Abstract base class for structures in *native* byte order."
msgstr "Abstrakt basklass för strukturer i *nativ* byte-ordning."

#: ../../library/ctypes.rst:2572
msgid ""
"Concrete structure and union types must be created by subclassing one of "
"these types, and at least define a :attr:`_fields_` class variable. :mod:"
"`ctypes` will create :term:`descriptor`\\s which allow reading and writing "
"the fields by direct attribute accesses.  These are the"
msgstr ""
"Konkreta struktur- och unionstyper måste skapas genom att underklassa en av "
"dessa typer och åtminstone definiera en klassvariabel :attr:`_fields_`. :mod:"
"`ctypes` skapar :term:`descriptor` som gör det möjligt att läsa och skriva "
"fälten genom direkt attributåtkomst.  Dessa är"

#: ../../library/ctypes.rst:2580
msgid ""
"A sequence defining the structure fields.  The items must be 2-tuples or 3-"
"tuples.  The first item is the name of the field, the second item specifies "
"the type of the field; it can be any ctypes data type."
msgstr ""
"En sekvens som definierar strukturfälten.  Elementen måste vara 2-tupler "
"eller 3-tupler.  Det första objektet är fältets namn, det andra objektet "
"anger fältets typ; det kan vara vilken ctypes-datatyp som helst."

#: ../../library/ctypes.rst:2584
msgid ""
"For integer type fields like :class:`c_int`, a third optional item can be "
"given.  It must be a small positive integer defining the bit width of the "
"field."
msgstr ""
"För fält av heltalstyp som :class:`c_int` kan ett tredje valfritt element "
"anges.  Det måste vara ett litet positivt heltal som definierar fältets "
"bitbredd."

#: ../../library/ctypes.rst:2588
msgid ""
"Field names must be unique within one structure or union.  This is not "
"checked, only one field can be accessed when names are repeated."
msgstr ""
"Fältnamn måste vara unika inom en struktur eller union.  Detta kontrolleras "
"inte, endast ett fält kan nås när namnen upprepas."

#: ../../library/ctypes.rst:2591
msgid ""
"It is possible to define the :attr:`_fields_` class variable *after* the "
"class statement that defines the Structure subclass, this allows creating "
"data types that directly or indirectly reference themselves::"
msgstr ""
"Det är möjligt att definiera klassvariabeln :attr:`_fields_` *efter* den "
"class-sats som definierar underklassen Structure, vilket gör det möjligt att "
"skapa datatyper som direkt eller indirekt refererar till sig själva::"

#: ../../library/ctypes.rst:2595
msgid ""
"class List(Structure):\n"
"    pass\n"
"List._fields_ = [(\"pnext\", POINTER(List)),\n"
"                 ...\n"
"                ]"
msgstr ""
"klass Lista(Struktur):\n"
"    pass\n"
"List._fields_ = [(\"pnext\", POINTER(List)),\n"
"                 ...\n"
"                ]"

#: ../../library/ctypes.rst:2601
msgid ""
"The :attr:`_fields_` class variable must, however, be defined before the "
"type is first used (an instance is created, :func:`sizeof` is called on it, "
"and so on).  Later assignments to the :attr:`_fields_` class variable will "
"raise an AttributeError."
msgstr ""

#: ../../library/ctypes.rst:2606
msgid ""
"It is possible to define sub-subclasses of structure types, they inherit the "
"fields of the base class plus the :attr:`_fields_` defined in the sub-"
"subclass, if any."
msgstr ""

#: ../../library/ctypes.rst:2613
msgid ""
"An optional small integer that allows overriding the alignment of structure "
"fields in the instance.  :attr:`_pack_` must already be defined when :attr:"
"`_fields_` is assigned, otherwise it will have no effect. Setting this "
"attribute to 0 is the same as not setting it at all."
msgstr ""
"Ett valfritt litet heltal som gör det möjligt att åsidosätta inriktningen av "
"strukturfälten i instansen. :attr:`_pack_` måste redan vara definierat när :"
"attr:`_fields_` tilldelas, annars har det ingen effekt. Att sätta detta "
"attribut till 0 är samma sak som att inte sätta det alls."

#: ../../library/ctypes.rst:2621
msgid ""
"An optional small integer that allows overriding the alignment of the "
"structure when being packed or unpacked to/from memory. Setting this "
"attribute to 0 is the same as not setting it at all."
msgstr ""
"Ett valfritt litet heltal som gör det möjligt att åsidosätta strukturens "
"inriktning när den packas eller packas upp till/från minnet. Att sätta detta "
"attribut till 0 är samma sak som att inte sätta det alls."

#: ../../library/ctypes.rst:2629
msgid ""
"An optional sequence that lists the names of unnamed (anonymous) fields. :"
"attr:`_anonymous_` must be already defined when :attr:`_fields_` is "
"assigned, otherwise it will have no effect."
msgstr ""
"En valfri sekvens som listar namnen på namnlösa (anonyma) fält. :attr:"
"`_anonymous_` måste redan vara definierat när :attr:`_fields_` tilldelas, "
"annars har det ingen effekt."

#: ../../library/ctypes.rst:2633
msgid ""
"The fields listed in this variable must be structure or union type fields. :"
"mod:`ctypes` will create descriptors in the structure type that allows "
"accessing the nested fields directly, without the need to create the "
"structure or union field."
msgstr ""
"De fält som anges i denna variabel måste vara av strukturtyp eller "
"unionstyp. :mod:`ctypes` skapar deskriptorer i strukturtypen som gör det "
"möjligt att komma åt de nästlade fälten direkt, utan att behöva skapa "
"struktur- eller unionsfältet."

#: ../../library/ctypes.rst:2638
msgid "Here is an example type (Windows)::"
msgstr "Här är ett exempel på en typ (Windows)::"

#: ../../library/ctypes.rst:2640
msgid ""
"class _U(Union):\n"
"    _fields_ = [(\"lptdesc\", POINTER(TYPEDESC)),\n"
"                (\"lpadesc\", POINTER(ARRAYDESC)),\n"
"                (\"hreftype\", HREFTYPE)]\n"
"\n"
"class TYPEDESC(Structure):\n"
"    _anonymous_ = (\"u\",)\n"
"    _fields_ = [(\"u\", _U),\n"
"                (\"vt\", VARTYPE)]"
msgstr ""
"klass _U(Union):\n"
"    _fields_ = [(\"lptdesc\", POINTER(TYPEDESC)),\n"
"                (\"lpadesc\", POINTER(ARRAYDESC)),\n"
"                (\"hreftype\", HREFTYPE)]\n"
"\n"
"klass TYPEDESC(Struktur):\n"
"    _anonymous_ = (\"u\",)\n"
"    _fields_ = [(\"u\", _U),\n"
"                (\"vt\", VARTYPE)]"

#: ../../library/ctypes.rst:2651
msgid ""
"The ``TYPEDESC`` structure describes a COM data type, the ``vt`` field "
"specifies which one of the union fields is valid.  Since the ``u`` field is "
"defined as anonymous field, it is now possible to access the members "
"directly off the TYPEDESC instance. ``td.lptdesc`` and ``td.u.lptdesc`` are "
"equivalent, but the former is faster since it does not need to create a "
"temporary union instance::"
msgstr ""
"Strukturen ``TYPEDESC`` beskriver en COM-datatyp, fältet ``vt`` anger vilket "
"av unionsfälten som är giltigt.  Eftersom fältet ``u`` är definierat som ett "
"anonymt fält är det nu möjligt att komma åt medlemmarna direkt från TYPEDESC-"
"instansen. ``td.lptdesc`` och ``td.u.lptdesc`` är likvärdiga, men den förra "
"är snabbare eftersom den inte behöver skapa en tillfällig unionsinstans::"

#: ../../library/ctypes.rst:2658
msgid ""
"td = TYPEDESC()\n"
"td.vt = VT_PTR\n"
"td.lptdesc = POINTER(some_type)\n"
"td.u.lptdesc = POINTER(some_type)"
msgstr ""
"td = TYPEDESC()\n"
"td.vt = VT_PTR\n"
"td.lptdesc = POINTER(some_type)\n"
"td.u.lptdesc = POINTER(some_type)"

#: ../../library/ctypes.rst:2663
msgid ""
"It is possible to define sub-subclasses of structures, they inherit the "
"fields of the base class.  If the subclass definition has a separate :attr:"
"`_fields_` variable, the fields specified in this are appended to the fields "
"of the base class."
msgstr ""
"Det är möjligt att definiera sub-subklasser av strukturer, de ärver fälten i "
"basklassen.  Om subklassdefinitionen har en separat variabel :attr:"
"`_fields_`, läggs de fält som anges i denna till basklassens fält."

#: ../../library/ctypes.rst:2668
msgid ""
"Structure and union constructors accept both positional and keyword "
"arguments.  Positional arguments are used to initialize member fields in the "
"same order as they are appear in :attr:`_fields_`.  Keyword arguments in the "
"constructor are interpreted as attribute assignments, so they will "
"initialize :attr:`_fields_` with the same name, or create new attributes for "
"names not present in :attr:`_fields_`."
msgstr ""
"Struktur- och unionskonstruktörer accepterar både positionella argument och "
"nyckelordsargument.  Positionella argument används för att initiera "
"medlemsfält i samma ordning som de visas i :attr:`_fields_`.  Nyckelord i "
"konstruktorn tolkas som attributtilldelningar, vilket innebär att de "
"initierar :attr:`_fields_` med samma namn eller skapar nya attribut för namn "
"som inte finns i :attr:`_fields_`."

#: ../../library/ctypes.rst:2679
msgid "Arrays and pointers"
msgstr "Arrayer och pekare"

#: ../../library/ctypes.rst:2683
msgid "Abstract base class for arrays."
msgstr "Abstrakt basklass för arrayer."

#: ../../library/ctypes.rst:2685
msgid ""
"The recommended way to create concrete array types is by multiplying any :"
"mod:`ctypes` data type with a non-negative integer.  Alternatively, you can "
"subclass this type and define :attr:`_length_` and :attr:`_type_` class "
"variables. Array elements can be read and written using standard subscript "
"and slice accesses; for slice reads, the resulting object is *not* itself "
"an :class:`Array`."
msgstr ""
"Det rekommenderade sättet att skapa konkreta array-typer är att multiplicera "
"valfri :mod:`ctypes`-datatyp med ett icke-negativt heltal.  Alternativt kan "
"du underklassa den här typen och definiera klassvariablerna :attr:`_length_` "
"och :attr:`_type_`. Array-element kan läsas och skrivas med hjälp av "
"standardåtkomst för subscript och slice; för slice-läsning är det "
"resulterande objektet *inte* i sig självt en :class:`Array`."

#: ../../library/ctypes.rst:2695
msgid ""
"A positive integer specifying the number of elements in the array. Out-of-"
"range subscripts result in an :exc:`IndexError`. Will be returned by :func:"
"`len`."
msgstr ""
"Ett positivt heltal som anger antalet element i matrisen. Subskriptioner "
"utanför intervallet resulterar i ett :exc:`IndexError`. Kommer att "
"returneras av :func:`len`."

#: ../../library/ctypes.rst:2702
msgid "Specifies the type of each element in the array."
msgstr "Anger typen för varje element i matrisen."

#: ../../library/ctypes.rst:2705
msgid ""
"Array subclass constructors accept positional arguments, used to initialize "
"the elements in order."
msgstr ""
"Array-underklassens konstruktörer accepterar positionella argument som "
"används för att initiera elementen i ordning."

#: ../../library/ctypes.rst:2710
msgid ""
"Create an array. Equivalent to ``type * length``, where *type* is a :mod:"
"`ctypes` data type and *length* an integer."
msgstr ""
"Skapar en array. Motsvarar ``type * length``, där *type* är en :mod:`ctypes`-"
"datatyp och *length* ett heltal."

#: ../../library/ctypes.rst:2714
msgid ""
"This function is :term:`soft deprecated` in favor of multiplication. There "
"are no plans to remove it."
msgstr ""
"Denna funktion är :term:`soft deprecated` till förmån för multiplikation. "
"Det finns inga planer på att ta bort den."

#: ../../library/ctypes.rst:2720
msgid "Private, abstract base class for pointers."
msgstr "Privat, abstrakt basklass för pekare."

#: ../../library/ctypes.rst:2722
msgid ""
"Concrete pointer types are created by calling :func:`POINTER` with the type "
"that will be pointed to; this is done automatically by :func:`pointer`."
msgstr ""
"Konkreta pekartyper skapas genom att anropa :func:`POINTER` med den typ som "
"ska pekas på; detta görs automatiskt av :func:`pointer`."

#: ../../library/ctypes.rst:2726
msgid ""
"If a pointer points to an array, its elements can be read and written using "
"standard subscript and slice accesses.  Pointer objects have no size, so :"
"func:`len` will raise :exc:`TypeError`.  Negative subscripts will read from "
"the memory *before* the pointer (as in C), and out-of-range subscripts will "
"probably crash with an access violation (if you're lucky)."
msgstr ""
"Om en pekare pekar på en array kan dess element läsas och skrivas med hjälp "
"av standardåtkomst för subscript och slice.  Pekarobjekt har ingen storlek, "
"så :func:`len` kommer att ge upphov till :exc:`TypeError`.  Negativa "
"subscripts läser från minnet *före* pekaren (som i C), och out-of-range "
"subscripts kraschar förmodligen med en access violation (om du har tur)."

#: ../../library/ctypes.rst:2736
msgid "Specifies the type pointed to."
msgstr "Anger vilken typ som pekas ut."

#: ../../library/ctypes.rst:2740
msgid ""
"Returns the object to which to pointer points.  Assigning to this attribute "
"changes the pointer to point to the assigned object."
msgstr ""
"Returnerar det objekt som pekaren till pekar på.  Om du tilldelar detta "
"attribut ändras pekaren till att peka på det tilldelade objektet."
