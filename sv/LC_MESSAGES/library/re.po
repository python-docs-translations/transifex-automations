# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-17 18:07+0000\n"
"PO-Revision-Date: 2025-09-22 17:55+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../library/re.rst:2
msgid ":mod:`re` --- Regular expression operations"
msgstr ""

#: ../../library/re.rst:10
msgid "**Source code:** :source:`Lib/re.py`"
msgstr ""

#: ../../library/re.rst:14
msgid ""
"This module provides regular expression matching operations similar to those "
"found in Perl."
msgstr ""
"Den här modulen innehåller funktioner för matchning med reguljära uttryck "
"som liknar dem som finns i Perl."

#: ../../library/re.rst:17
msgid ""
"Both patterns and strings to be searched can be Unicode strings (:class:"
"`str`) as well as 8-bit strings (:class:`bytes`). However, Unicode strings "
"and 8-bit strings cannot be mixed: that is, you cannot match a Unicode "
"string with a byte pattern or vice-versa; similarly, when asking for a "
"substitution, the replacement string must be of the same type as both the "
"pattern and the search string."
msgstr ""

#: ../../library/re.rst:24
msgid ""
"Regular expressions use the backslash character (``'\\'``) to indicate "
"special forms or to allow special characters to be used without invoking "
"their special meaning.  This collides with Python's usage of the same "
"character for the same purpose in string literals; for example, to match a "
"literal backslash, one might have to write ``'\\\\\\\\'`` as the pattern "
"string, because the regular expression must be ``\\\\``, and each backslash "
"must be expressed as ``\\\\`` inside a regular Python string literal. Also, "
"please note that any invalid escape sequences in Python's usage of the "
"backslash in string literals now generate a :exc:`DeprecationWarning` and in "
"the future this will become a :exc:`SyntaxError`. This behaviour will happen "
"even if it is a valid escape sequence for a regular expression."
msgstr ""

#: ../../library/re.rst:36
msgid ""
"The solution is to use Python's raw string notation for regular expression "
"patterns; backslashes are not handled in any special way in a string literal "
"prefixed with ``'r'``.  So ``r\"\\n\"`` is a two-character string containing "
"``'\\'`` and ``'n'``, while ``\"\\n\"`` is a one-character string containing "
"a newline.  Usually patterns will be expressed in Python code using this raw "
"string notation."
msgstr ""
"Lösningen är att använda Pythons råa strängnotation för reguljära "
"uttrycksmönster; backslash hanteras inte på något speciellt sätt i en "
"stränglitual med prefixet ``'r'``.  Så ``r\"\\n\"`` är en tvåteckenssträng "
"som innehåller ``'\\'`` och ``'n'``, medan ``\"\\n\"`` är en enteckenssträng "
"som innehåller en ny rad.  Vanligtvis kommer mönster att uttryckas i Python-"
"kod med hjälp av denna råa strängnotation."

#: ../../library/re.rst:43
msgid ""
"It is important to note that most regular expression operations are "
"available as module-level functions and methods on :ref:`compiled regular "
"expressions <re-objects>`.  The functions are shortcuts that don't require "
"you to compile a regex object first, but miss some fine-tuning parameters."
msgstr ""
"Det är viktigt att notera att de flesta operationer med reguljära uttryck "
"finns tillgängliga som funktioner och metoder på modulnivå på :ref:`compiled "
"regular expressions <re-objects>`.  Funktionerna är genvägar som inte kräver "
"att du först kompilerar ett regex-objekt, men saknar vissa "
"finjusteringsparametrar."

#: ../../library/re.rst:51
msgid ""
"The third-party `regex <https://pypi.org/project/regex/>`_ module, which has "
"an API compatible with the standard library :mod:`re` module, but offers "
"additional functionality and a more thorough Unicode support."
msgstr ""

#: ../../library/re.rst:59
msgid "Regular Expression Syntax"
msgstr "Syntax för reguljära uttryck"

#: ../../library/re.rst:61
msgid ""
"A regular expression (or RE) specifies a set of strings that matches it; the "
"functions in this module let you check if a particular string matches a "
"given regular expression (or if a given regular expression matches a "
"particular string, which comes down to the same thing)."
msgstr ""
"Ett reguljärt uttryck (eller RE) anger en uppsättning strängar som matchar "
"det; med funktionerna i den här modulen kan du kontrollera om en viss sträng "
"matchar ett visst reguljärt uttryck (eller om ett visst reguljärt uttryck "
"matchar en viss sträng, vilket är samma sak)."

#: ../../library/re.rst:66
msgid ""
"Regular expressions can be concatenated to form new regular expressions; if "
"*A* and *B* are both regular expressions, then *AB* is also a regular "
"expression. In general, if a string *p* matches *A* and another string *q* "
"matches *B*, the string *pq* will match AB.  This holds unless *A* or *B* "
"contain low precedence operations; boundary conditions between *A* and *B*; "
"or have numbered group references.  Thus, complex expressions can easily be "
"constructed from simpler primitive expressions like the ones described "
"here.  For details of the theory and implementation of regular expressions, "
"consult the Friedl book [Frie09]_, or almost any textbook about compiler "
"construction."
msgstr ""
"Reguljära uttryck kan sammankopplas för att bilda nya reguljära uttryck; om "
"*A* och *B* båda är reguljära uttryck, är *AB* också ett reguljärt uttryck. "
"I allmänhet gäller att om en sträng *p* matchar *A* och en annan sträng *q* "
"matchar *B*, kommer strängen *pq* att matcha AB.  Detta gäller om inte *A* "
"eller *B* innehåller operationer med låg prioritet, gränsvillkor mellan *A* "
"och *B* eller har numrerade gruppreferenser.  Komplexa uttryck kan alltså "
"lätt konstrueras från enklare primitiva uttryck som de som beskrivs här.  "
"För detaljer om teorin och implementeringen av reguljära uttryck, se Friedls "
"bok [Frie09]_, eller nästan vilken lärobok som helst om "
"kompilatorkonstruktion."

#: ../../library/re.rst:76
msgid ""
"A brief explanation of the format of regular expressions follows.  For "
"further information and a gentler presentation, consult the :ref:`regex-"
"howto`."
msgstr ""
"Här följer en kort förklaring av formatet för reguljära uttryck.  För "
"ytterligare information och en mildare presentation, se :ref:`regex-howto`."

#: ../../library/re.rst:79
msgid ""
"Regular expressions can contain both special and ordinary characters. Most "
"ordinary characters, like ``'A'``, ``'a'``, or ``'0'``, are the simplest "
"regular expressions; they simply match themselves.  You can concatenate "
"ordinary characters, so ``last`` matches the string ``'last'``.  (In the "
"rest of this section, we'll write RE's in ``this special style``, usually "
"without quotes, and strings to be matched ``'in single quotes'``.)"
msgstr ""
"Reguljära uttryck kan innehålla både specialtecken och vanliga tecken. De "
"flesta vanliga tecken, som ``'A'``, ``'a'`` eller ``'0'``, är de enklaste "
"reguljära uttrycken; de matchar helt enkelt sig själva.  Du kan konkatenera "
"vanliga tecken, så att ``last`` matchar strängen ``'last'``.  (I resten av "
"det här avsnittet skriver vi RE:s med ``den här speciella stilen``, "
"vanligtvis utan citationstecken, och strängar som ska matchas ``'med enkla "
"citationstecken``)"

#: ../../library/re.rst:86
msgid ""
"Some characters, like ``'|'`` or ``'('``, are special. Special characters "
"either stand for classes of ordinary characters, or affect how the regular "
"expressions around them are interpreted."
msgstr ""
"Vissa tecken, som ``'|'`` eller ``'('``, är specialtecken. Specialtecken "
"står antingen för klasser av vanliga tecken eller påverkar hur de reguljära "
"uttryck som omger dem tolkas."

#: ../../library/re.rst:90
msgid ""
"Repetition qualifiers (``*``, ``+``, ``?``, ``{m,n}``, etc) cannot be "
"directly nested. This avoids ambiguity with the non-greedy modifier suffix "
"``?``, and with other modifiers in other implementations. To apply a second "
"repetition to an inner repetition, parentheses may be used. For example, the "
"expression ``(?:a{6})*`` matches any multiple of six ``'a'`` characters."
msgstr ""

#: ../../library/re.rst:97
msgid "The special characters are:"
msgstr "Specialtecknen är följande:"

#: ../../library/re.rst:104 ../../library/re.rst:1419
msgid "``.``"
msgstr "``.``"

#: ../../library/re.rst:102
msgid ""
"(Dot.)  In the default mode, this matches any character except a newline.  "
"If the :const:`DOTALL` flag has been specified, this matches any character "
"including a newline."
msgstr ""

#: ../../library/re.rst:110
msgid "``^``"
msgstr "``^``"

#: ../../library/re.rst:109
msgid ""
"(Caret.)  Matches the start of the string, and in :const:`MULTILINE` mode "
"also matches immediately after each newline."
msgstr ""
"(Caret.) Matchar början av strängen, och i :const:`MULTILINE`\\-läget även "
"omedelbart efter varje ny rad."

#: ../../library/re.rst:121
msgid "``$``"
msgstr "``$``"

#: ../../library/re.rst:115
msgid ""
"Matches the end of the string or just before the newline at the end of the "
"string, and in :const:`MULTILINE` mode also matches before a newline.  "
"``foo`` matches both 'foo' and 'foobar', while the regular expression "
"``foo$`` matches only 'foo'.  More interestingly, searching for ``foo.$`` in "
"``'foo1\\nfoo2\\n'`` matches 'foo2' normally, but 'foo1' in :const:"
"`MULTILINE` mode; searching for a single ``$`` in ``'foo\\n'`` will find two "
"(empty) matches: one just before the newline, and one at the end of the "
"string."
msgstr ""
"Matchar slutet av strängen eller precis före den nya raden i slutet av "
"strängen, och i :const:`MULTILINE`\\-läget även före en ny rad.  ``foo`` "
"matchar både 'foo' och 'foobar', medan det reguljära uttrycket ``foo$`` "
"endast matchar 'foo'.  Mer intressant är att en sökning efter ``foo.$`` i "
"``'foo1\\nfoo2\\n'`` normalt matchar 'foo2', men 'foo1' i :const:"
"`MULTILINE`\\-läget; en sökning efter en enda ``$`` i ``'foo\\n'`` kommer "
"att hitta två (tomma) träffar: en precis före det nya strecket och en i "
"slutet av strängen."

#: ../../library/re.rst:128
msgid "``*``"
msgstr "``*``"

#: ../../library/re.rst:126
msgid ""
"Causes the resulting RE to match 0 or more repetitions of the preceding RE, "
"as many repetitions as are possible.  ``ab*`` will match 'a', 'ab', or 'a' "
"followed by any number of 'b's."
msgstr ""
"Gör att den resulterande RE:n matchar 0 eller flera upprepningar av den "
"föregående RE:n, så många upprepningar som möjligt.  ``ab*`` matchar 'a', "
"'ab' eller 'a' följt av ett valfritt antal 'b'."

#: ../../library/re.rst:135
msgid "``+``"
msgstr "``+``"

#: ../../library/re.rst:133
msgid ""
"Causes the resulting RE to match 1 or more repetitions of the preceding RE. "
"``ab+`` will match 'a' followed by any non-zero number of 'b's; it will not "
"match just 'a'."
msgstr ""
"Gör att den resulterande RE:n matchar 1 eller flera upprepningar av den "
"föregående RE:n. ``ab+`` kommer att matcha 'a' följt av ett valfritt antal "
"'b' som inte är noll; det kommer inte att matcha bara 'a'."

#: ../../library/re.rst:141
msgid "``?``"
msgstr "``?``"

#: ../../library/re.rst:140
msgid ""
"Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. "
"``ab?`` will match either 'a' or 'ab'."
msgstr ""
"Gör att den resulterande RE:n matchar 0 eller 1 upprepningar av den "
"föregående RE:n. ``ab?`` kommer att matcha antingen 'a' eller 'ab'."

#: ../../library/re.rst:155
msgid "``*?``, ``+?``, ``??``"
msgstr "``*?``, ``+?``, ``??``"

#: ../../library/re.rst:149
msgid ""
"The ``'*'``, ``'+'``, and ``'?'`` qualifiers are all :dfn:`greedy`; they "
"match as much text as possible.  Sometimes this behaviour isn't desired; if "
"the RE ``<.*>`` is matched against ``'<a> b <c>'``, it will match the entire "
"string, and not just ``'<a>'``.  Adding ``?`` after the qualifier makes it "
"perform the match in :dfn:`non-greedy` or :dfn:`minimal` fashion; as *few* "
"characters as possible will be matched.  Using the RE ``<.*?>`` will match "
"only ``'<a>'``."
msgstr ""

#: ../../library/re.rst:163
msgid "``{m}``"
msgstr "``{m}``"

#: ../../library/re.rst:161
msgid ""
"Specifies that exactly *m* copies of the previous RE should be matched; "
"fewer matches cause the entire RE not to match.  For example, ``a{6}`` will "
"match exactly six ``'a'`` characters, but not five."
msgstr ""
"Anger att exakt *m* kopior av föregående RE ska matchas; färre matchningar "
"gör att hela RE inte matchas.  Till exempel kommer ``a{6}`` att matcha exakt "
"sex ``'a'``\\-tecken, men inte fem."

#: ../../library/re.rst:172
msgid "``{m,n}``"
msgstr "``{m,n}``"

#: ../../library/re.rst:166
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as many repetitions as possible.  For "
"example, ``a{3,5}`` will match from 3 to 5 ``'a'`` characters.  Omitting *m* "
"specifies a lower bound of zero,  and omitting *n* specifies an infinite "
"upper bound.  As an example, ``a{4,}b`` will match ``'aaaab'`` or a thousand "
"``'a'`` characters followed by a ``'b'``, but not ``'aaab'``. The comma may "
"not be omitted or the modifier would be confused with the previously "
"described form."
msgstr ""
"Gör att den resulterande RE:n matchar från *m* till *n* upprepningar av den "
"föregående RE:n, med försök att matcha så många upprepningar som möjligt.  "
"Exempelvis kommer ``a{3,5}`` att matcha mellan 3 och 5 ``'a'``\\-tecken.  Om "
"*m* utelämnas anges en nedre gräns på noll, och om *n* utelämnas anges en "
"oändlig övre gräns.  Som ett exempel kommer ``a{4,}b`` att matcha "
"``'aaaab'`` eller tusen ``'a'``\\-tecken följt av ett ``'b'``, men inte "
"``'aaab'``. Kommatecknet får inte utelämnas, eftersom modifieraren då skulle "
"förväxlas med den tidigare beskrivna formen."

#: ../../library/re.rst:179
msgid "``{m,n}?``"
msgstr "``{m,n}?``"

#: ../../library/re.rst:175
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as *few* repetitions as possible.  This is "
"the non-greedy version of the previous qualifier.  For example, on the 6-"
"character string ``'aaaaaa'``, ``a{3,5}`` will match 5 ``'a'`` characters, "
"while ``a{3,5}?`` will only match 3 characters."
msgstr ""

#: ../../library/re.rst:194
msgid "``\\``"
msgstr "``\\``"

#: ../../library/re.rst:184
msgid ""
"Either escapes special characters (permitting you to match characters like "
"``'*'``, ``'?'``, and so forth), or signals a special sequence; special "
"sequences are discussed below."
msgstr ""
"Antingen undviker du specialtecken (så att du kan matcha tecken som ``'*'``, "
"``'?'`` osv.) eller så signalerar du en specialsekvens; specialsekvenser "
"diskuteras nedan."

#: ../../library/re.rst:188
msgid ""
"If you're not using a raw string to express the pattern, remember that "
"Python also uses the backslash as an escape sequence in string literals; if "
"the escape sequence isn't recognized by Python's parser, the backslash and "
"subsequent character are included in the resulting string.  However, if "
"Python would recognize the resulting sequence, the backslash should be "
"repeated twice.  This is complicated and hard to understand, so it's highly "
"recommended that you use raw strings for all but the simplest expressions."
msgstr ""
"Om du inte använder en rå sträng för att uttrycka mönstret, kom ihåg att "
"Python också använder backslash som en escape-sekvens i stränglitteraler; om "
"escape-sekvensen inte känns igen av Pythons parser, inkluderas backslash och "
"efterföljande tecken i den resulterande strängen.  Men om Python skulle "
"känna igen den resulterande sekvensen, bör backslash upprepas två gånger.  "
"Det här är komplicerat och svårt att förstå, så det rekommenderas starkt att "
"du använder råa strängar för alla utom de enklaste uttrycken."

#: ../../library/re.rst:254
msgid "``[]``"
msgstr "``[]``"

#: ../../library/re.rst:200
msgid "Used to indicate a set of characters.  In a set:"
msgstr "Används för att ange en uppsättning tecken.  I en uppsättning:"

#: ../../library/re.rst:202
msgid ""
"Characters can be listed individually, e.g. ``[amk]`` will match ``'a'``, "
"``'m'``, or ``'k'``."
msgstr ""
"Tecken kan listas individuellt, t.ex. kommer ``[amk]`` att matcha ``'a'``, "
"``'m'`` eller ``'k'``."

#: ../../library/re.rst:207
msgid ""
"Ranges of characters can be indicated by giving two characters and "
"separating them by a ``'-'``, for example ``[a-z]`` will match any lowercase "
"ASCII letter, ``[0-5][0-9]`` will match all the two-digits numbers from "
"``00`` to ``59``, and ``[0-9A-Fa-f]`` will match any hexadecimal digit.  If "
"``-`` is escaped (e.g. ``[a\\-z]``) or if it's placed as the first or last "
"character (e.g. ``[-a]`` or ``[a-]``), it will match a literal ``'-'``."
msgstr ""
"Teckenintervall kan anges genom att ange två tecken och separera dem med "
"``'-'``, t.ex. ``[a-z]`` matchar alla gemena ASCII-bokstäver, ``[0-5][0-9]`` "
"matchar alla tvåsiffriga tal från ``00`` till ``59`` och ``[0-9A-Fa-f]`` "
"matchar alla hexadecimala siffror.  Om ``\\-`` är escapat (t.ex. ``[a\\ -"
"z]``) eller om det placeras som första eller sista tecken (t.ex. ``[-a]`` "
"eller ``[a-]``), kommer det att matcha ett bokstavligt ``'-'``."

#: ../../library/re.rst:214
msgid ""
"Special characters lose their special meaning inside sets.  For example, "
"``[(+*)]`` will match any of the literal characters ``'('``, ``'+'``, "
"``'*'``, or ``')'``."
msgstr ""

#: ../../library/re.rst:220
msgid ""
"Character classes such as ``\\w`` or ``\\S`` (defined below) are also "
"accepted inside a set, although the characters they match depends on "
"whether :const:`ASCII` or :const:`LOCALE` mode is in force."
msgstr ""

#: ../../library/re.rst:226
msgid ""
"Characters that are not within a range can be matched by :dfn:"
"`complementing` the set.  If the first character of the set is ``'^'``, all "
"the characters that are *not* in the set will be matched.  For example, "
"``[^5]`` will match any character except ``'5'``, and ``[^^]`` will match "
"any character except ``'^'``.  ``^`` has no special meaning if it's not the "
"first character in the set."
msgstr ""
"Tecken som inte finns inom ett intervall kan matchas genom att :dfn:"
"`komplettera` uppsättningen.  Om det första tecknet i uppsättningen är "
"``'^'`` kommer alla tecken som *inte* finns i uppsättningen att matchas.  "
"Till exempel kommer ``[^5]`` att matcha alla tecken utom ``'5'``, och "
"``[^^]`` kommer att matcha alla tecken utom ``'^'``.  ``^`` har ingen "
"speciell betydelse om det inte är det första tecknet i uppsättningen."

#: ../../library/re.rst:233
msgid ""
"To match a literal ``']'`` inside a set, precede it with a backslash, or "
"place it at the beginning of the set.  For example, both ``[()[\\]{}]`` and "
"``[]()[{}]`` will both match a parenthesis."
msgstr ""

#: ../../library/re.rst:242
msgid ""
"Support of nested sets and set operations as in `Unicode Technical Standard "
"#18`_ might be added in the future.  This would change the syntax, so to "
"facilitate this change a :exc:`FutureWarning` will be raised in ambiguous "
"cases for the time being. That includes sets starting with a literal ``'['`` "
"or containing literal character sequences ``'--'``, ``'&&'``, ``'~~'``, and "
"``'||'``.  To avoid a warning escape them with a backslash."
msgstr ""
"Stöd för nästlade mängder och mängdoperationer som i `Unicode Technical "
"Standard #18`_ kan komma att läggas till i framtiden.  Detta skulle ändra "
"syntaxen, så för att underlätta denna förändring kommer en :exc:"
"`FutureWarning` att visas i tvetydiga fall för tillfället. Detta inkluderar "
"uppsättningar som börjar med en bokstavlig ``'['`` eller innehåller "
"bokstavliga teckensekvenser ``'--'``, ``'&&'``, ``'~~'`` och ``'||'``.  För "
"att undvika en varning, undvik dem med ett backslash."

#: ../../library/re.rst:252
msgid ""
":exc:`FutureWarning` is raised if a character set contains constructs that "
"will change semantically in the future."
msgstr ""
":exc:`FutureWarning` utlöses om en teckenuppsättning innehåller "
"konstruktioner som kommer att förändras semantiskt i framtiden."

#: ../../library/re.rst:267
msgid "``|``"
msgstr "``|``"

#: ../../library/re.rst:259
msgid ""
"``A|B``, where *A* and *B* can be arbitrary REs, creates a regular "
"expression that will match either *A* or *B*.  An arbitrary number of REs "
"can be separated by the ``'|'`` in this way.  This can be used inside groups "
"(see below) as well.  As the target string is scanned, REs separated by "
"``'|'`` are tried from left to right. When one pattern completely matches, "
"that branch is accepted. This means that once *A* matches, *B* will not be "
"tested further, even if it would produce a longer overall match.  In other "
"words, the ``'|'`` operator is never greedy.  To match a literal ``'|'``, "
"use ``\\|``, or enclose it inside a character class, as in ``[|]``."
msgstr ""
"``A|B``, där *A* och *B* kan vara godtyckliga RE:s, skapar ett reguljärt "
"uttryck som matchar antingen *A* eller *B*.  Ett godtyckligt antal RE:s kan "
"separeras med ``'|'`` på detta sätt.  Detta kan även användas inom grupper "
"(se nedan).  När målsträngen skannas testas RE:s som separerats med ``'|'`` "
"från vänster till höger. När ett mönster matchar fullständigt accepteras den "
"grenen. Detta innebär att när *A* matchar kommer *B* inte att testas "
"ytterligare, även om det skulle ge en längre total matchning.  Med andra ord "
"är operatorn ``'|'`` aldrig girig.  Om du vill matcha en bokstavlig ``'|'`` "
"använder du ``\\|` eller omsluter den i en teckenklass, som i ``[|]``."

#: ../../library/re.rst:277
msgid "``(...)``"
msgstr "``(...)``"

#: ../../library/re.rst:273
msgid ""
"Matches whatever regular expression is inside the parentheses, and indicates "
"the start and end of a group; the contents of a group can be retrieved after "
"a match has been performed, and can be matched later in the string with the "
"``\\number`` special sequence, described below.  To match the literals "
"``'('`` or ``')'``, use ``\\(`` or ``\\)``, or enclose them inside a "
"character class: ``[(]``, ``[)]``."
msgstr ""
"Matchar det reguljära uttryck som finns inom parentesen och anger början och "
"slutet på en grupp; innehållet i en grupp kan hämtas efter att en matchning "
"har utförts och kan matchas senare i strängen med specialsekvensen "
"``\\number``, som beskrivs nedan.  För att matcha bokstavstecken ``'('`` "
"eller ``')'``, använd ``(`` eller ``\\)``, eller omslut dem i en "
"teckenklass: ``[(]``, ``[)]``."

#: ../../library/re.rst:286
msgid "``(?...)``"
msgstr "``(?...)``"

#: ../../library/re.rst:282
msgid ""
"This is an extension notation (a ``'?'`` following a ``'('`` is not "
"meaningful otherwise).  The first character after the ``'?'`` determines "
"what the meaning and further syntax of the construct is. Extensions usually "
"do not create a new group; ``(?P<name>...)`` is the only exception to this "
"rule. Following are the currently supported extensions."
msgstr ""
"Detta är en utvidgad notation (en ``'?'`` efter en ``'('`` är inte "
"meningsfull i övrigt).  Det första tecknet efter ``'?'`` avgör vad "
"konstruktionen har för betydelse och vidare syntax. Tillägg skapar "
"vanligtvis inte en ny grupp; ``(?P<name>...)`` är det enda undantaget från "
"denna regel. Följande är de tillägg som för närvarande stöds."

#: ../../library/re.rst:300
msgid "``(?aiLmsux)``"
msgstr "``(?aiLmsux)``"

#: ../../library/re.rst:289
msgid ""
"(One or more letters from the set ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``'s'``, ``'u'``, ``'x'``.)  The group matches the empty string; the letters "
"set the corresponding flags: :const:`re.A` (ASCII-only matching), :const:`re."
"I` (ignore case), :const:`re.L` (locale dependent), :const:`re.M` (multi-"
"line), :const:`re.S` (dot matches all), :const:`re.U` (Unicode matching), "
"and :const:`re.X` (verbose), for the entire regular expression. (The flags "
"are described in :ref:`contents-of-module-re`.) This is useful if you wish "
"to include the flags as part of the regular expression, instead of passing a "
"*flag* argument to the :func:`re.compile` function.  Flags should be used "
"first in the expression string."
msgstr ""

#: ../../library/re.rst:308
msgid "``(?:...)``"
msgstr "``(?:...)``"

#: ../../library/re.rst:305
msgid ""
"A non-capturing version of regular parentheses.  Matches whatever regular "
"expression is inside the parentheses, but the substring matched by the group "
"*cannot* be retrieved after performing a match or referenced later in the "
"pattern."
msgstr ""
"En icke-fångande version av reguljära parenteser.  Matchar det reguljära "
"uttryck som finns inom parentesen, men den delsträng som matchas av gruppen "
"*kan* inte hämtas efter en matchning eller refereras till senare i mönstret."

#: ../../library/re.rst:334
msgid "``(?aiLmsux-imsx:...)``"
msgstr "``(?aiLmsux-imsx:...)``"

#: ../../library/re.rst:311
msgid ""
"(Zero or more letters from the set ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``'s'``, ``'u'``, ``'x'``, optionally followed by ``'-'`` followed by one or "
"more letters from the ``'i'``, ``'m'``, ``'s'``, ``'x'``.) The letters set "
"or remove the corresponding flags: :const:`re.A` (ASCII-only matching), :"
"const:`re.I` (ignore case), :const:`re.L` (locale dependent), :const:`re.M` "
"(multi-line), :const:`re.S` (dot matches all), :const:`re.U` (Unicode "
"matching), and :const:`re.X` (verbose), for the part of the expression. (The "
"flags are described in :ref:`contents-of-module-re`.)"
msgstr ""

#: ../../library/re.rst:321
msgid ""
"The letters ``'a'``, ``'L'`` and ``'u'`` are mutually exclusive when used as "
"inline flags, so they can't be combined or follow ``'-'``.  Instead, when "
"one of them appears in an inline group, it overrides the matching mode in "
"the enclosing group.  In Unicode patterns ``(?a:...)`` switches to ASCII-"
"only matching, and ``(?u:...)`` switches to Unicode matching (default).  In "
"byte pattern ``(?L:...)`` switches to locale depending matching, and ``(?"
"a:...)`` switches to ASCII-only matching (default). This override is only in "
"effect for the narrow inline group, and the original matching mode is "
"restored outside of the group."
msgstr ""

#: ../../library/re.rst:333
msgid "The letters ``'a'``, ``'L'`` and ``'u'`` also can be used in a group."
msgstr ""
"Bokstäverna ``'a'``, ``'L'`` och ``'u'`` kan också användas i en grupp."

#: ../../library/re.rst:361
msgid "``(?P<name>...)``"
msgstr "``(?P<name>...)``"

#: ../../library/re.rst:339
msgid ""
"Similar to regular parentheses, but the substring matched by the group is "
"accessible via the symbolic group name *name*.  Group names must be valid "
"Python identifiers, and each group name must be defined only once within a "
"regular expression.  A symbolic group is also a numbered group, just as if "
"the group were not named."
msgstr ""

#: ../../library/re.rst:345
msgid ""
"Named groups can be referenced in three contexts.  If the pattern is ``(?"
"P<quote>['\"]).*?(?P=quote)`` (i.e. matching a string quoted with either "
"single or double quotes):"
msgstr ""
"Namngivna grupper kan refereras till i tre sammanhang.  Om mönstret är ``(?"
"P<quote>['\"]).*?(?P=quote)`` (d.v.s. matchning av en sträng som citeras med "
"antingen enkla eller dubbla citattecken):"

#: ../../library/re.rst:350
msgid "Context of reference to group \"quote\""
msgstr "Sammanhang med hänvisning till gruppen \"offert\""

#: ../../library/re.rst:350
msgid "Ways to reference it"
msgstr "Sätt att hänvisa till den"

#: ../../library/re.rst:352
msgid "in the same pattern itself"
msgstr "i samma mönster själv"

#: ../../library/re.rst:352
msgid "``(?P=quote)`` (as shown)"
msgstr "``(?P=quote)`` (som visas)"

#: ../../library/re.rst:353 ../../library/re.rst:360
msgid "``\\1``"
msgstr "``\\1``"

#: ../../library/re.rst:355
msgid "when processing match object *m*"
msgstr "vid bearbetning av matchningsobjekt *m*"

#: ../../library/re.rst:355
msgid "``m.group('quote')``"
msgstr "``m.group('quote')``"

#: ../../library/re.rst:356
msgid "``m.end('quote')`` (etc.)"
msgstr "``m.end('quote')`` (etc.)"

#: ../../library/re.rst:358
msgid "in a string passed to the *repl* argument of ``re.sub()``"
msgstr "i en sträng som skickas till *repl*-argumentet i ``re.sub()``"

#: ../../library/re.rst:358
msgid "``\\g<quote>``"
msgstr "<quote>"

#: ../../library/re.rst:359
msgid "``\\g<1>``"
msgstr "<1>"

#: ../../library/re.rst:367
msgid "``(?P=name)``"
msgstr "``(?P=namn)``"

#: ../../library/re.rst:366
msgid ""
"A backreference to a named group; it matches whatever text was matched by "
"the earlier group named *name*."
msgstr ""
"En återreferens till en namngiven grupp; den matchar den text som matchades "
"av den tidigare gruppen med namnet *namn*."

#: ../../library/re.rst:372
msgid "``(?#...)``"
msgstr "``(?#...)``"

#: ../../library/re.rst:372
msgid "A comment; the contents of the parentheses are simply ignored."
msgstr "En kommentar; innehållet i parentesen ignoreras helt enkelt."

#: ../../library/re.rst:379
msgid "``(?=...)``"
msgstr "``(?=...)``"

#: ../../library/re.rst:377
msgid ""
"Matches if ``...`` matches next, but doesn't consume any of the string.  "
"This is called a :dfn:`lookahead assertion`.  For example, ``Isaac (?"
"=Asimov)`` will match ``'Isaac '`` only if it's followed by ``'Asimov'``."
msgstr ""
"Matchar om ``...`` matchar nästa, men inte förbrukar någon del av strängen.  "
"Detta kallas för ett :dfn:`lookahead-assertion`.  Till exempel kommer "
"``Isaac (?=Asimov)`` att matcha ``'Isaac'`` endast om det följs av "
"``'Asimov'``."

#: ../../library/re.rst:386
msgid "``(?!...)``"
msgstr "``(?!...)``"

#: ../../library/re.rst:384
msgid ""
"Matches if ``...`` doesn't match next.  This is a :dfn:`negative lookahead "
"assertion`. For example, ``Isaac (?!Asimov)`` will match ``'Isaac '`` only "
"if it's *not* followed by ``'Asimov'``."
msgstr ""
"Matchar om ``...`` inte matchar nästa.  Detta är ett :dfn:`negativt "
"lookahead-antagande`. Till exempel kommer ``Isaac (?!Asimov)`` att matcha "
"``'Isaac'`` endast om det *inte* följs av ``'Asimov'``."

#: ../../library/re.rst:413
msgid "``(?<=...)``"
msgstr "``(?<=...)``"

#: ../../library/re.rst:391
msgid ""
"Matches if the current position in the string is preceded by a match for "
"``...`` that ends at the current position.  This is called a :dfn:`positive "
"lookbehind assertion`. ``(?<=abc)def`` will find a match in ``'abcdef'``, "
"since the lookbehind will back up 3 characters and check if the contained "
"pattern matches. The contained pattern must only match strings of some fixed "
"length, meaning that ``abc`` or ``a|b`` are allowed, but ``a*`` and ``a{3,4}"
"`` are not.  Note that patterns which start with positive lookbehind "
"assertions will not match at the beginning of the string being searched; you "
"will most likely want to use the :func:`search` function rather than the :"
"func:`match` function:"
msgstr ""
"Matchar om den aktuella positionen i strängen föregås av en matchning för "
"``...`` som slutar vid den aktuella positionen.  Detta kallas ett :dfn:"
"`positivt lookbehind-antagande`. ``(?<=abc)def`` kommer att hitta en "
"matchning i ``'abcdef'``, eftersom lookbehind kommer att backa 3 tecken och "
"kontrollera om det ingående mönstret matchar. Det ingående mönstret får bara "
"matcha strängar av en viss bestämd längd, vilket innebär att ``abc`` eller "
"``a|b`` är tillåtna, men inte ``a*`` och ``a{3,4}``.  Observera att mönster "
"som börjar med positiva lookbehind-assertions inte kommer att matcha i "
"början av den sträng som söks; du kommer troligen att vilja använda "
"funktionen :func:`search` snarare än funktionen :func:`match`:"

#: ../../library/re.rst:406
msgid "This example looks for a word following a hyphen:"
msgstr "I det här exemplet söker du efter ett ord efter ett bindestreck:"

#: ../../library/re.rst:412
msgid "Added support for group references of fixed length."
msgstr "Stöd för gruppreferenser med fast längd har lagts till."

#: ../../library/re.rst:422
msgid "``(?<!...)``"
msgstr "``(?<!...)``"

#: ../../library/re.rst:418
msgid ""
"Matches if the current position in the string is not preceded by a match for "
"``...``.  This is called a :dfn:`negative lookbehind assertion`.  Similar to "
"positive lookbehind assertions, the contained pattern must only match "
"strings of some fixed length.  Patterns which start with negative lookbehind "
"assertions may match at the beginning of the string being searched."
msgstr ""
"Träffar om den aktuella positionen i strängen inte föregås av en träff för "
"``...``.  Detta kallas ett :dfn:`negativt lookbehind-antagande`.  I likhet "
"med positiva lookbehind-assertions måste det ingående mönstret endast matcha "
"strängar av en viss bestämd längd.  Mönster som börjar med negativa "
"lookbehind-assertions kan matcha i början av den sträng som söks."

#: ../../library/re.rst:431
msgid "``(?(id/name)yes-pattern|no-pattern)``"
msgstr "``(?(id/name)yes-pattern|no-pattern)``"

#: ../../library/re.rst:425
msgid ""
"Will try to match with ``yes-pattern`` if the group with given *id* or "
"*name* exists, and with ``no-pattern`` if it doesn't. ``no-pattern`` is "
"optional and can be omitted. For example, ``(<)?(\\w+@\\w+(?:\\.\\w+)+)(?"
"(1)>|$)`` is a poor email matching pattern, which will match with "
"``'<user@host.com>'`` as well as ``'user@host.com'``, but not with "
"``'<user@host.com'`` nor ``'user@host.com>'``."
msgstr ""
"Försöker matcha med ``yes-pattern`` om gruppen med angivet *id* eller *namn* "
"finns, och med ``no-pattern`` om den inte gör det. ``no-pattern`` är "
"valfritt och kan utelämnas. Till exempel är ``(<)?(\\w+@\\w+(?:\\.\\w+)+)(?"
"(1)>|$)`` ett dåligt mönster för e-postmatchning, som kommer att matcha med "
"``'<user@host.com>'`` såväl som ``'user@host.com'``, men inte med "
"``'<user@host.com'`` eller ``'user@host.com>'``."

#: ../../library/re.rst:433
msgid ""
"The special sequences consist of ``'\\'`` and a character from the list "
"below. If the ordinary character is not an ASCII digit or an ASCII letter, "
"then the resulting RE will match the second character.  For example, ``\\$`` "
"matches the character ``'$'``."
msgstr ""
"De speciella sekvenserna består av ``'\\'`` och ett tecken från listan "
"nedan. Om det vanliga tecknet inte är en ASCII-siffra eller en ASCII-"
"bokstav, kommer den resulterande RE att matcha det andra tecknet.  Till "
"exempel matchar ``\\$`` tecknet ``'$'``."

#: ../../library/re.rst:448
msgid "``\\number``"
msgstr "\"Nummer"

#: ../../library/re.rst:441
msgid ""
"Matches the contents of the group of the same number.  Groups are numbered "
"starting from 1.  For example, ``(.+) \\1`` matches ``'the the'`` or ``'55 "
"55'``, but not ``'thethe'`` (note the space after the group).  This special "
"sequence can only be used to match one of the first 99 groups.  If the first "
"digit of *number* is 0, or *number* is 3 octal digits long, it will not be "
"interpreted as a group match, but as the character with octal value "
"*number*. Inside the ``'['`` and ``']'`` of a character class, all numeric "
"escapes are treated as characters."
msgstr ""
"Matchar innehållet i gruppen med samma nummer.  Grupperna är numrerade från "
"1. Till exempel matchar ``(.+) \\1`` ``'the the'`` eller ``'55 55'``, men "
"inte ``'thethe'`` (notera mellanslaget efter gruppen).  Denna speciella "
"sekvens kan endast användas för att matcha en av de första 99 grupperna.  Om "
"den första siffran i *number* är 0, eller *number* är 3 oktalsiffror långt, "
"tolkas det inte som en gruppmatchning, utan som tecknet med oktalvärdet "
"*number*. Inom ``'['`` och ``']'`` i en teckenklass behandlas alla numeriska "
"eskapader som tecken."

#: ../../library/re.rst:453
msgid "``\\A``"
msgstr "``\\A``"

#: ../../library/re.rst:453
msgid "Matches only at the start of the string."
msgstr "Matchar endast i början av strängen."

#: ../../library/re.rst:469
msgid "``\\b``"
msgstr "``\\b``"

#: ../../library/re.rst:458
msgid ""
"Matches the empty string, but only at the beginning or end of a word. A word "
"is defined as a sequence of word characters.  Note that formally, ``\\b`` is "
"defined as the boundary between a ``\\w`` and a ``\\W`` character (or vice "
"versa), or between ``\\w`` and the beginning/end of the string. This means "
"that ``r'\\bfoo\\b'`` matches ``'foo'``, ``'foo.'``, ``'(foo)'``, ``'bar foo "
"baz'`` but not ``'foobar'`` or ``'foo3'``."
msgstr ""

#: ../../library/re.rst:465
msgid ""
"By default Unicode alphanumerics are the ones used in Unicode patterns, but "
"this can be changed by using the :const:`ASCII` flag.  Word boundaries are "
"determined by the current locale if the :const:`LOCALE` flag is used. Inside "
"a character range, ``\\b`` represents the backspace character, for "
"compatibility with Python's string literals."
msgstr ""

#: ../../library/re.rst:480
msgid "``\\B``"
msgstr "``\\B``"

#: ../../library/re.rst:474
msgid ""
"Matches the empty string, but only when it is *not* at the beginning or end "
"of a word.  This means that ``r'py\\B'`` matches ``'python'``, ``'py3'``, "
"``'py2'``, but not ``'py'``, ``'py.'``, or ``'py!'``. ``\\B`` is just the "
"opposite of ``\\b``, so word characters in Unicode patterns are Unicode "
"alphanumerics or the underscore, although this can be changed by using the :"
"const:`ASCII` flag.  Word boundaries are determined by the current locale if "
"the :const:`LOCALE` flag is used."
msgstr ""

#: ../../library/re.rst:492
msgid "``\\d``"
msgstr "``\\d``"

#: ../../library/re.rst:489 ../../library/re.rst:509 ../../library/re.rst:529
msgid "For Unicode (str) patterns:"
msgstr "För Unicode (str)-mönster:"

#: ../../library/re.rst:486
msgid ""
"Matches any Unicode decimal digit (that is, any character in Unicode "
"character category [Nd]).  This includes ``[0-9]``, and also many other "
"digit characters.  If the :const:`ASCII` flag is used only ``[0-9]`` is "
"matched."
msgstr ""

#: ../../library/re.rst:492 ../../library/re.rst:513 ../../library/re.rst:535
msgid "For 8-bit (bytes) patterns:"
msgstr "För 8-bitars (bytes) mönster:"

#: ../../library/re.rst:492
msgid "Matches any decimal digit; this is equivalent to ``[0-9]``."
msgstr ""

#: ../../library/re.rst:499
msgid "``\\D``"
msgstr "``\\D``"

#: ../../library/re.rst:497
msgid ""
"Matches any character which is not a decimal digit. This is the opposite of "
"``\\d``. If the :const:`ASCII` flag is used this becomes the equivalent of "
"``[^0-9]``."
msgstr ""

#: ../../library/re.rst:513
msgid "``\\s``"
msgstr "``\\s``"

#: ../../library/re.rst:505
msgid ""
"Matches Unicode whitespace characters (which includes "
"``[ \\t\\n\\r\\f\\v]``, and also many other characters, for example the non-"
"breaking spaces mandated by typography rules in many languages). If the :"
"const:`ASCII` flag is used, only ``[ \\t\\n\\r\\f\\v]`` is matched."
msgstr ""

#: ../../library/re.rst:512
msgid ""
"Matches characters considered whitespace in the ASCII character set; this is "
"equivalent to ``[ \\t\\n\\r\\f\\v]``."
msgstr ""
"Matchar tecken som betraktas som blanksteg i ASCII-teckensatsen; detta "
"motsvarar ``[ \\t\\n\\r\\f\\v]``."

#: ../../library/re.rst:520
msgid "``\\S``"
msgstr "``\\S``"

#: ../../library/re.rst:518
msgid ""
"Matches any character which is not a whitespace character. This is the "
"opposite of ``\\s``. If the :const:`ASCII` flag is used this becomes the "
"equivalent of ``[^ \\t\\n\\r\\f\\v]``."
msgstr ""

#: ../../library/re.rst:535
msgid "``\\w``"
msgstr "``\\w``"

#: ../../library/re.rst:526
msgid ""
"Matches Unicode word characters; this includes most characters that can be "
"part of a word in any language, as well as numbers and the underscore. If "
"the :const:`ASCII` flag is used, only ``[a-zA-Z0-9_]`` is matched."
msgstr ""

#: ../../library/re.rst:532
msgid ""
"Matches characters considered alphanumeric in the ASCII character set; this "
"is equivalent to ``[a-zA-Z0-9_]``.  If the :const:`LOCALE` flag is used, "
"matches characters considered alphanumeric in the current locale and the "
"underscore."
msgstr ""

#: ../../library/re.rst:544
msgid "``\\W``"
msgstr "``\\W``"

#: ../../library/re.rst:540
msgid ""
"Matches any character which is not a word character. This is the opposite of "
"``\\w``. If the :const:`ASCII` flag is used this becomes the equivalent of "
"``[^a-zA-Z0-9_]``.  If the :const:`LOCALE` flag is used, matches characters "
"which are neither alphanumeric in the current locale nor the underscore."
msgstr ""

#: ../../library/re.rst:549
msgid "``\\Z``"
msgstr "``\\Z``"

#: ../../library/re.rst:549
msgid "Matches only at the end of the string."
msgstr "Matchar endast i slutet av strängen."

#: ../../library/re.rst:565
msgid ""
"Most of the standard escapes supported by Python string literals are also "
"accepted by the regular expression parser::"
msgstr ""

#: ../../library/re.rst:572
msgid ""
"(Note that ``\\b`` is used to represent word boundaries, and means "
"\"backspace\" only inside character classes.)"
msgstr ""
"(Observera att ``b`` används för att representera ordgränser och betyder "
"\"backspace\" endast inom teckenklasser)"

#: ../../library/re.rst:575
msgid ""
"``'\\u'``, ``'\\U'``, and ``'\\N'`` escape sequences are only recognized in "
"Unicode patterns.  In bytes patterns they are errors.  Unknown escapes of "
"ASCII letters are reserved for future use and treated as errors."
msgstr ""

#: ../../library/re.rst:579
msgid ""
"Octal escapes are included in a limited form.  If the first digit is a 0, or "
"if there are three octal digits, it is considered an octal escape. "
"Otherwise, it is a group reference.  As for string literals, octal escapes "
"are always at most three digits in length."
msgstr ""
"Oktala escapes ingår i en begränsad form.  Om den första siffran är en 0, "
"eller om det finns tre oktalsiffror, betraktas det som en oktal escape. "
"Annars är det en gruppreferens.  När det gäller stränglitteraler är oktala "
"escapes alltid högst tre siffror långa."

#: ../../library/re.rst:584
msgid "The ``'\\u'`` and ``'\\U'`` escape sequences have been added."
msgstr "Escape-sekvenserna ``'\\u'`` och ``'\\U'`` har lagts till."

#: ../../library/re.rst:587
msgid ""
"Unknown escapes consisting of ``'\\'`` and an ASCII letter now are errors."
msgstr "Okända escapes som består av ``'\\'`` och en ASCII-bokstav är nu fel."

#: ../../library/re.rst:590
msgid ""
"The ``'\\N{name}'`` escape sequence has been added. As in string literals, "
"it expands to the named Unicode character (e.g. ``'\\N{EM DASH}'``)."
msgstr ""

#: ../../library/re.rst:598
msgid "Module Contents"
msgstr "Modulens innehåll"

#: ../../library/re.rst:600
msgid ""
"The module defines several functions, constants, and an exception. Some of "
"the functions are simplified versions of the full featured methods for "
"compiled regular expressions.  Most non-trivial applications always use the "
"compiled form."
msgstr ""
"Modulen definierar flera funktioner, konstanter och ett undantag. Vissa av "
"funktionerna är förenklade versioner av de fullständiga metoderna för "
"kompilerade reguljära uttryck.  De flesta icke-triviala applikationer "
"använder alltid den kompilerade formen."

#: ../../library/re.rst:605
msgid ""
"Flag constants are now instances of :class:`RegexFlag`, which is a subclass "
"of :class:`enum.IntFlag`."
msgstr ""
"Flaggkonstanter är nu instanser av :class:`RegexFlag`, som är en underklass "
"av :class:`enum.IntFlag`."

#: ../../library/re.rst:611
msgid ""
"Compile a regular expression pattern into a :ref:`regular expression object "
"<re-objects>`, which can be used for matching using its :func:`~Pattern."
"match`, :func:`~Pattern.search` and other methods, described below."
msgstr ""
"Kompilera ett mönster för reguljära uttryck till ett :ref:`regular "
"expression object <re-objects>`, som kan användas för matchning med hjälp av "
"dess :func:`~Pattern.match`, :func:`~Pattern.search` och andra metoder, som "
"beskrivs nedan."

#: ../../library/re.rst:616
msgid ""
"The expression's behaviour can be modified by specifying a *flags* value. "
"Values can be any of the following variables, combined using bitwise OR (the "
"``|`` operator)."
msgstr ""

#: ../../library/re.rst:620
msgid "The sequence ::"
msgstr "Sekvensen ::"

#: ../../library/re.rst:625
msgid "is equivalent to ::"
msgstr "är likvärdig med ::"

#: ../../library/re.rst:629
msgid ""
"but using :func:`re.compile` and saving the resulting regular expression "
"object for reuse is more efficient when the expression will be used several "
"times in a single program."
msgstr ""
"men att använda :func:`re.compile` och spara det resulterande objektet för "
"reguljära uttryck för återanvändning är effektivare när uttrycket kommer att "
"användas flera gånger i ett och samma program."

#: ../../library/re.rst:635
msgid ""
"The compiled versions of the most recent patterns passed to :func:`re."
"compile` and the module-level matching functions are cached, so programs "
"that use only a few regular expressions at a time needn't worry about "
"compiling regular expressions."
msgstr ""
"De kompilerade versionerna av de senaste mönstren som skickas till :func:`re."
"compile` och matchningsfunktionerna på modulnivå cachas, så program som bara "
"använder ett fåtal reguljära uttryck åt gången behöver inte oroa sig för att "
"kompilera reguljära uttryck."

#: ../../library/re.rst:644
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\d``, ``\\D``, ``\\s`` and "
"``\\S`` perform ASCII-only matching instead of full Unicode matching.  This "
"is only meaningful for Unicode patterns, and is ignored for byte patterns. "
"Corresponds to the inline flag ``(?a)``."
msgstr ""

#: ../../library/re.rst:649
msgid ""
"Note that for backward compatibility, the :const:`re.U` flag still exists "
"(as well as its synonym :const:`re.UNICODE` and its embedded counterpart ``(?"
"u)``), but these are redundant in Python 3 since matches are Unicode by "
"default for strings (and Unicode matching isn't allowed for bytes)."
msgstr ""

#: ../../library/re.rst:658
msgid ""
"Display debug information about compiled expression. No corresponding inline "
"flag."
msgstr ""

#: ../../library/re.rst:665
msgid ""
"Perform case-insensitive matching; expressions like ``[A-Z]`` will also "
"match lowercase letters.  Full Unicode matching (such as ``Ü`` matching "
"``ü``) also works unless the :const:`re.ASCII` flag is used to disable non-"
"ASCII matches.  The current locale does not change the effect of this flag "
"unless the :const:`re.LOCALE` flag is also used. Corresponds to the inline "
"flag ``(?i)``."
msgstr ""

#: ../../library/re.rst:672
msgid ""
"Note that when the Unicode patterns ``[a-z]`` or ``[A-Z]`` are used in "
"combination with the :const:`IGNORECASE` flag, they will match the 52 ASCII "
"letters and 4 additional non-ASCII letters: 'İ' (U+0130, Latin capital "
"letter I with dot above), 'ı' (U+0131, Latin small letter dotless i), "
"'ſ' (U+017F, Latin small letter long s) and 'K' (U+212A, Kelvin sign). If "
"the :const:`ASCII` flag is used, only letters 'a' to 'z' and 'A' to 'Z' are "
"matched."
msgstr ""

#: ../../library/re.rst:683
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B`` and case-insensitive matching "
"dependent on the current locale.  This flag can be used only with bytes "
"patterns.  The use of this flag is discouraged as the locale mechanism is "
"very unreliable, it only handles one \"culture\" at a time, and it only "
"works with 8-bit locales.  Unicode matching is already enabled by default in "
"Python 3 for Unicode (str) patterns, and it is able to handle different "
"locales/languages. Corresponds to the inline flag ``(?L)``."
msgstr ""

#: ../../library/re.rst:692
msgid ""
":const:`re.LOCALE` can be used only with bytes patterns and is not "
"compatible with :const:`re.ASCII`."
msgstr ""

#: ../../library/re.rst:696
msgid ""
"Compiled regular expression objects with the :const:`re.LOCALE` flag no "
"longer depend on the locale at compile time.  Only the locale at matching "
"time affects the result of matching."
msgstr ""

#: ../../library/re.rst:705
msgid ""
"When specified, the pattern character ``'^'`` matches at the beginning of "
"the string and at the beginning of each line (immediately following each "
"newline); and the pattern character ``'$'`` matches at the end of the string "
"and at the end of each line (immediately preceding each newline).  By "
"default, ``'^'`` matches only at the beginning of the string, and ``'$'`` "
"only at the end of the string and immediately before the newline (if any) at "
"the end of the string. Corresponds to the inline flag ``(?m)``."
msgstr ""

#: ../../library/re.rst:717
msgid ""
"Make the ``'.'`` special character match any character at all, including a "
"newline; without this flag, ``'.'`` will match anything *except* a newline. "
"Corresponds to the inline flag ``(?s)``."
msgstr ""

#: ../../library/re.rst:727
msgid ""
"This flag allows you to write regular expressions that look nicer and are "
"more readable by allowing you to visually separate logical sections of the "
"pattern and add comments. Whitespace within the pattern is ignored, except "
"when in a character class, or when preceded by an unescaped backslash, or "
"within tokens like ``*?``, ``(?:`` or ``(?P<...>``. When a line contains a "
"``#`` that is not in a character class and is not preceded by an unescaped "
"backslash, all characters from the leftmost such ``#`` through the end of "
"the line are ignored."
msgstr ""

#: ../../library/re.rst:736
msgid ""
"This means that the two following regular expression objects that match a "
"decimal number are functionally equal::"
msgstr ""
"Detta innebär att de två följande objekten för reguljära uttryck som matchar "
"ett decimaltal är funktionellt lika::"

#: ../../library/re.rst:744
msgid "Corresponds to the inline flag ``(?x)``."
msgstr "Motsvarar inline-flaggan ``(?x)``."

#: ../../library/re.rst:749
msgid ""
"Scan through *string* looking for the first location where the regular "
"expression *pattern* produces a match, and return a corresponding :ref:"
"`match object <match-objects>`.  Return ``None`` if no position in the "
"string matches the pattern; note that this is different from finding a zero-"
"length match at some point in the string."
msgstr ""

#: ../../library/re.rst:758
msgid ""
"If zero or more characters at the beginning of *string* match the regular "
"expression *pattern*, return a corresponding :ref:`match object <match-"
"objects>`.  Return ``None`` if the string does not match the pattern; note "
"that this is different from a zero-length match."
msgstr ""

#: ../../library/re.rst:763
msgid ""
"Note that even in :const:`MULTILINE` mode, :func:`re.match` will only match "
"at the beginning of the string and not at the beginning of each line."
msgstr ""
"Observera att även i :const:`MULTILINE`\\-läget kommer :func:`re.match` bara "
"att matcha i början av strängen och inte i början av varje rad."

#: ../../library/re.rst:766
msgid ""
"If you want to locate a match anywhere in *string*, use :func:`search` "
"instead (see also :ref:`search-vs-match`)."
msgstr ""
"Om du vill hitta en träff var som helst i *sträng*, använd :func:`search` "
"istället (se även :ref:`search-vs-match`)."

#: ../../library/re.rst:772
msgid ""
"If the whole *string* matches the regular expression *pattern*, return a "
"corresponding :ref:`match object <match-objects>`.  Return ``None`` if the "
"string does not match the pattern; note that this is different from a zero-"
"length match."
msgstr ""

#: ../../library/re.rst:782
msgid ""
"Split *string* by the occurrences of *pattern*.  If capturing parentheses "
"are used in *pattern*, then the text of all groups in the pattern are also "
"returned as part of the resulting list. If *maxsplit* is nonzero, at most "
"*maxsplit* splits occur, and the remainder of the string is returned as the "
"final element of the list. ::"
msgstr ""
"Dela upp *sträng* efter förekomsterna av *mönster*.  Om fångande parenteser "
"används i *mönster* returneras även texten för alla grupper i mönstret som "
"en del av den resulterande listan. Om *maxsplit* inte är noll, sker högst "
"*maxsplit* uppdelningar och resten av strängen returneras som det sista "
"elementet i listan. ::"

#: ../../library/re.rst:797
msgid ""
"If there are capturing groups in the separator and it matches at the start "
"of the string, the result will start with an empty string.  The same holds "
"for the end of the string::"
msgstr ""
"Om det finns fångstgrupper i separatorn och den matchar i början av "
"strängen, kommer resultatet att börja med en tom sträng.  Detsamma gäller "
"för slutet av strängen::"

#: ../../library/re.rst:804
msgid ""
"That way, separator components are always found at the same relative indices "
"within the result list."
msgstr ""
"På så sätt hittas separatorkomponenterna alltid på samma relativa index i "
"resultatlistan."

#: ../../library/re.rst:807
msgid ""
"Empty matches for the pattern split the string only when not adjacent to a "
"previous empty match."
msgstr ""

#: ../../library/re.rst:817 ../../library/re.rst:907 ../../library/re.rst:931
msgid "Added the optional flags argument."
msgstr "Lagt till det valfria flaggargumentet."

#: ../../library/re.rst:820
msgid ""
"Added support of splitting on a pattern that could match an empty string."
msgstr ""
"Stöd för uppdelning av ett mönster som kan matcha en tom sträng har lagts "
"till."

#: ../../library/re.rst:826
msgid ""
"Return all non-overlapping matches of *pattern* in *string*, as a list of "
"strings or tuples.  The *string* is scanned left-to-right, and matches are "
"returned in the order found.  Empty matches are included in the result."
msgstr ""
"Returnerar alla icke-överlappande matchningar av *mönster* i *sträng*, som "
"en lista med strängar eller tupler.  *sträng* skannas från vänster till "
"höger och matchningarna returneras i den ordning de hittas.  Tomma "
"matchningar inkluderas i resultatet."

#: ../../library/re.rst:830
msgid ""
"The result depends on the number of capturing groups in the pattern. If "
"there are no groups, return a list of strings matching the whole pattern.  "
"If there is exactly one group, return a list of strings matching that "
"group.  If multiple groups are present, return a list of tuples of strings "
"matching the groups.  Non-capturing groups do not affect the form of the "
"result."
msgstr ""
"Resultatet beror på antalet fångstgrupper i mönstret. Om det inte finns "
"några grupper returneras en lista med strängar som matchar hela mönstret.  "
"Om det finns exakt en grupp returneras en lista med strängar som matchar den "
"gruppen.  Om det finns flera grupper returneras en lista med tupler av "
"strängar som matchar grupperna.  Grupper som inte fångas upp påverkar inte "
"resultatets form."

#: ../../library/re.rst:842 ../../library/re.rst:853
msgid "Non-empty matches can now start just after a previous empty match."
msgstr ""
"Matcher som inte är tomma kan nu starta precis efter en tidigare tom match."

#: ../../library/re.rst:848
msgid ""
"Return an :term:`iterator` yielding :ref:`match objects <match-objects>` "
"over all non-overlapping matches for the RE *pattern* in *string*.  The "
"*string* is scanned left-to-right, and matches are returned in the order "
"found.  Empty matches are included in the result."
msgstr ""

#: ../../library/re.rst:859
msgid ""
"Return the string obtained by replacing the leftmost non-overlapping "
"occurrences of *pattern* in *string* by the replacement *repl*.  If the "
"pattern isn't found, *string* is returned unchanged.  *repl* can be a string "
"or a function; if it is a string, any backslash escapes in it are "
"processed.  That is, ``\\n`` is converted to a single newline character, "
"``\\r`` is converted to a carriage return, and so forth.  Unknown escapes of "
"ASCII letters are reserved for future use and treated as errors.  Other "
"unknown escapes such as ``\\&`` are left alone. Backreferences, such as "
"``\\6``, are replaced with the substring matched by group 6 in the pattern. "
"For example::"
msgstr ""
"Returnerar strängen som erhålls genom att ersätta de längst till vänster "
"liggande icke överlappande förekomsterna av *mönster* i *sträng* med "
"ersättningen *repl*.  Om mönstret inte hittas returneras *sträng* "
"oförändrad.  *repl* kan vara en sträng eller en funktion; om det är en "
"sträng behandlas alla backslash-escapes i den.  Det innebär att ``\\n`` "
"konverteras till ett enda ny rad-tecken, ``r`` konverteras till en "
"vagnsretur och så vidare.  Okända escapes av ASCII-bokstäver reserveras för "
"framtida användning och behandlas som fel.  Andra okända escapetecken som "
"``&`` lämnas därhän. Bakreferenser, t.ex. ``\\6``, ersätts med den delsträng "
"som matchas av grupp 6 i mönstret. Till exempel::"

#: ../../library/re.rst:875
msgid ""
"If *repl* is a function, it is called for every non-overlapping occurrence "
"of *pattern*.  The function takes a single :ref:`match object <match-"
"objects>` argument, and returns the replacement string.  For example::"
msgstr ""

#: ../../library/re.rst:887
msgid "The pattern may be a string or a :ref:`pattern object <re-objects>`."
msgstr ""

#: ../../library/re.rst:889
msgid ""
"The optional argument *count* is the maximum number of pattern occurrences "
"to be replaced; *count* must be a non-negative integer.  If omitted or zero, "
"all occurrences will be replaced. Empty matches for the pattern are replaced "
"only when not adjacent to a previous empty match, so ``sub('x*', '-', "
"'abxd')`` returns ``'-a-b--d-'``."
msgstr ""

#: ../../library/re.rst:897
msgid ""
"In string-type *repl* arguments, in addition to the character escapes and "
"backreferences described above, ``\\g<name>`` will use the substring matched "
"by the group named ``name``, as defined by the ``(?P<name>...)`` syntax. "
"``\\g<number>`` uses the corresponding group number; ``\\g<2>`` is therefore "
"equivalent to ``\\2``, but isn't ambiguous in a replacement such as "
"``\\g<2>0``.  ``\\20`` would be interpreted as a reference to group 20, not "
"a reference to group 2 followed by the literal character ``'0'``.  The "
"backreference ``\\g<0>`` substitutes in the entire substring matched by the "
"RE."
msgstr ""
"I *repl*-argument av strängtyp, utöver de teckenundantag och bakåtreferenser "
"som beskrivs ovan, kommer ``g<name>`` att använda den delsträng som matchas "
"av gruppen med namnet ``namn``, enligt definitionen i syntaxen ``(?"
"P<name>...)``. ``\\g<number>`` använder motsvarande gruppnummer; ``g<2>`` är "
"därför likvärdigt med ``2``, men är inte tvetydigt i en ersättning som "
"``g<2>0``.  ``20`` skulle tolkas som en referens till grupp 20, inte en "
"referens till grupp 2 följt av det bokstavliga tecknet ``'0'``.  "
"Bakreferensen ``\\g<0>`` ersätter hela den delsträng som matchas av RE."

#: ../../library/re.rst:910 ../../library/re.rst:934 ../../library/re.rst:1165
msgid "Unmatched groups are replaced with an empty string."
msgstr "Omatchade grupper ersätts med en tom sträng."

#: ../../library/re.rst:913
msgid ""
"Unknown escapes in *pattern* consisting of ``'\\'`` and an ASCII letter now "
"are errors."
msgstr ""
"Okända escapes i *mönster* som består av ``'\\'`` och en ASCII-bokstav är nu "
"fel."

#: ../../library/re.rst:917
msgid ""
"Unknown escapes in *repl* consisting of ``'\\'`` and an ASCII letter now are "
"errors."
msgstr ""

#: ../../library/re.rst:921
msgid ""
"Empty matches for the pattern are replaced when adjacent to a previous non-"
"empty match."
msgstr ""

#: ../../library/re.rst:928
msgid ""
"Perform the same operation as :func:`sub`, but return a tuple ``(new_string, "
"number_of_subs_made)``."
msgstr ""
"Utför samma operation som :func:`sub`, men returnerar en tupel "
"``(new_string, number_of_subs_made)``."

#: ../../library/re.rst:940
msgid ""
"Escape special characters in *pattern*. This is useful if you want to match "
"an arbitrary literal string that may have regular expression metacharacters "
"in it.  For example::"
msgstr ""
"Undvik specialtecken i *mönster*. Detta är användbart om du vill matcha en "
"godtycklig bokstavlig sträng som kan innehålla metatecken för reguljära "
"uttryck.  Till exempel::"

#: ../../library/re.rst:955
msgid ""
"This function must not be used for the replacement string in :func:`sub` "
"and :func:`subn`, only backslashes should be escaped.  For example::"
msgstr ""
"Denna funktion får inte användas för ersättningssträngen i :func:`sub` och :"
"func:`subn`, endast backslashes ska escapas.  Till exempel::"

#: ../../library/re.rst:963
msgid "The ``'_'`` character is no longer escaped."
msgstr "Tecknet ``'_'`` är inte längre escapat."

#: ../../library/re.rst:966
msgid ""
"Only characters that can have special meaning in a regular expression are "
"escaped. As a result, ``'!'``, ``'\"'``, ``'%'``, ``\"'\"``, ``','``, "
"``'/'``, ``':'``, ``';'``, ``'<'``, ``'='``, ``'>'``, ``'@'``, and ``\"`\"`` "
"are no longer escaped."
msgstr ""
"Endast tecken som kan ha en speciell betydelse i ett reguljärt uttryck "
"escapas. Därför undviks inte längre ``'!'``, ``'\"'``, ``'%'``, ``\"''``, "
"``','``, ``'/'``, ``':'``, ``';'``, ``'<'``, ``'='``, ``'>'``, ``'@'`` och "
"``\"`\"``."

#: ../../library/re.rst:975
msgid "Clear the regular expression cache."
msgstr "Rensa cacheminnet för reguljära uttryck."

#: ../../library/re.rst:980
msgid ""
"Exception raised when a string passed to one of the functions here is not a "
"valid regular expression (for example, it might contain unmatched "
"parentheses) or when some other error occurs during compilation or "
"matching.  It is never an error if a string contains no match for a "
"pattern.  The error instance has the following additional attributes:"
msgstr ""

#: ../../library/re.rst:988
msgid "The unformatted error message."
msgstr "Det oformaterade felmeddelandet."

#: ../../library/re.rst:992
msgid "The regular expression pattern."
msgstr "Det reguljära uttrycksmönstret."

#: ../../library/re.rst:996
msgid "The index in *pattern* where compilation failed (may be ``None``)."
msgstr ""
"Indexet i *mönster* där kompileringen misslyckades (kan vara ``None``)."

#: ../../library/re.rst:1000
msgid "The line corresponding to *pos* (may be ``None``)."
msgstr "Den rad som motsvarar *pos* (kan vara ``None``)."

#: ../../library/re.rst:1004
msgid "The column corresponding to *pos* (may be ``None``)."
msgstr "Den kolumn som motsvarar *pos* (kan vara ``None``)."

#: ../../library/re.rst:1006
msgid "Added additional attributes."
msgstr "Lagt till ytterligare attribut."

#: ../../library/re.rst:1012
msgid "Regular Expression Objects"
msgstr "Objekt för reguljära uttryck"

#: ../../library/re.rst:1014
msgid ""
"Compiled regular expression objects support the following methods and "
"attributes:"
msgstr ""

#: ../../library/re.rst:1019
msgid ""
"Scan through *string* looking for the first location where this regular "
"expression produces a match, and return a corresponding :ref:`match object "
"<match-objects>`.  Return ``None`` if no position in the string matches the "
"pattern; note that this is different from finding a zero-length match at "
"some point in the string."
msgstr ""

#: ../../library/re.rst:1025
msgid ""
"The optional second parameter *pos* gives an index in the string where the "
"search is to start; it defaults to ``0``.  This is not completely equivalent "
"to slicing the string; the ``'^'`` pattern character matches at the real "
"beginning of the string and at positions just after a newline, but not "
"necessarily at the index where the search is to start."
msgstr ""
"Den valfria andra parametern *pos* anger ett index i strängen där sökningen "
"ska börja; standardvärdet är ``0``.  Detta är inte helt likvärdigt med att "
"skära upp strängen; mönsterstecknet ``'^'`` matchar i strängens verkliga "
"början och vid positioner strax efter en ny rad, men inte nödvändigtvis vid "
"det index där sökningen ska börja."

#: ../../library/re.rst:1031
msgid ""
"The optional parameter *endpos* limits how far the string will be searched; "
"it will be as if the string is *endpos* characters long, so only the "
"characters from *pos* to ``endpos - 1`` will be searched for a match.  If "
"*endpos* is less than *pos*, no match will be found; otherwise, if *rx* is a "
"compiled regular expression object, ``rx.search(string, 0, 50)`` is "
"equivalent to ``rx.search(string[:50], 0)``. ::"
msgstr ""
"Den valfria parametern *endpos* begränsar hur långt strängen kommer att "
"sökas; det kommer att vara som om strängen är *endpos* tecken lång, så "
"endast tecknen från *pos* till ``endpos - 1`` kommer att sökas efter en "
"matchning.  Om *endpos* är mindre än *pos* kommer ingen matchning att "
"hittas; annars, om *rx* är ett kompilerat objekt för reguljära uttryck, är "
"``rx.search(string, 0, 50)`` likvärdigt med ``rx.search(string[:50], 0)``. ::"

#: ../../library/re.rst:1046
msgid ""
"If zero or more characters at the *beginning* of *string* match this regular "
"expression, return a corresponding :ref:`match object <match-objects>`. "
"Return ``None`` if the string does not match the pattern; note that this is "
"different from a zero-length match."
msgstr ""

#: ../../library/re.rst:1051 ../../library/re.rst:1069
msgid ""
"The optional *pos* and *endpos* parameters have the same meaning as for the :"
"meth:`~Pattern.search` method. ::"
msgstr ""
"De valfria parametrarna *pos* och *endpos* har samma betydelse som för "
"metoden :meth:`~Pattern.search`. ::"

#: ../../library/re.rst:1059
msgid ""
"If you want to locate a match anywhere in *string*, use :meth:`~Pattern."
"search` instead (see also :ref:`search-vs-match`)."
msgstr ""
"Om du vill hitta en matchning var som helst i *sträng*, använd :meth:"
"`~Pattern.search` istället (se även :ref:`search-vs-match`)."

#: ../../library/re.rst:1065
msgid ""
"If the whole *string* matches this regular expression, return a "
"corresponding :ref:`match object <match-objects>`.  Return ``None`` if the "
"string does not match the pattern; note that this is different from a zero-"
"length match."
msgstr ""

#: ../../library/re.rst:1083
msgid "Identical to the :func:`split` function, using the compiled pattern."
msgstr ""
"Identisk med funktionen :func:`split`, men med det kompilerade mönstret."

#: ../../library/re.rst:1088
msgid ""
"Similar to the :func:`findall` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search "
"region like for :meth:`search`."
msgstr ""
"Liknar funktionen :func:`findall`, använder det kompilerade mönstret, men "
"accepterar också valfria parametrar *pos* och *endpos* som begränsar "
"sökregionen som för :meth:`search`."

#: ../../library/re.rst:1095
msgid ""
"Similar to the :func:`finditer` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search "
"region like for :meth:`search`."
msgstr ""
"Liknar funktionen :func:`finditer`, använder det kompilerade mönstret, men "
"accepterar också valfria parametrar *pos* och *endpos* som begränsar "
"sökregionen som för :meth:`search`."

#: ../../library/re.rst:1102
msgid "Identical to the :func:`sub` function, using the compiled pattern."
msgstr ""
"Identisk med funktionen :func:`sub`, men använder det kompilerade mönstret."

#: ../../library/re.rst:1107
msgid "Identical to the :func:`subn` function, using the compiled pattern."
msgstr ""
"Identisk med funktionen :func:`subn`, men med det kompilerade mönstret."

#: ../../library/re.rst:1112
msgid ""
"The regex matching flags.  This is a combination of the flags given to :func:"
"`.compile`, any ``(?...)`` inline flags in the pattern, and implicit flags "
"such as :data:`UNICODE` if the pattern is a Unicode string."
msgstr ""

#: ../../library/re.rst:1119
msgid "The number of capturing groups in the pattern."
msgstr "Antalet fångstgrupper i mönstret."

#: ../../library/re.rst:1124
msgid ""
"A dictionary mapping any symbolic group names defined by ``(?P<id>)`` to "
"group numbers.  The dictionary is empty if no symbolic groups were used in "
"the pattern."
msgstr ""
"En ordbok som mappar alla symboliska gruppnamn som definieras av ``(?"
"P<id>)`` till gruppnummer.  Ordlistan är tom om inga symboliska grupper har "
"använts i mönstret."

#: ../../library/re.rst:1131
msgid "The pattern string from which the pattern object was compiled."
msgstr "Den mönstersträng från vilken mönsterobjektet sammanställdes."

#: ../../library/re.rst:1134
msgid ""
"Added support of :func:`copy.copy` and :func:`copy.deepcopy`.  Compiled "
"regular expression objects are considered atomic."
msgstr ""
"Lagt till stöd för :func:`copy.copy` och :func:`copy.deepcopy`.  Kompilerade "
"objekt för reguljära uttryck betraktas som atomära."

#: ../../library/re.rst:1142
msgid "Match Objects"
msgstr "Matchningsobjekt"

#: ../../library/re.rst:1144
msgid ""
"Match objects always have a boolean value of ``True``. Since :meth:`~Pattern."
"match` and :meth:`~Pattern.search` return ``None`` when there is no match, "
"you can test whether there was a match with a simple ``if`` statement::"
msgstr ""
"Match-objekt har alltid det booleska värdet ``True``. Eftersom :meth:"
"`~Pattern.match` och :meth:`~Pattern.search` returnerar ``None`` när det "
"inte finns någon matchning, kan du testa om det fanns en matchning med en "
"enkel ``if``\\-sats::"

#: ../../library/re.rst:1153
msgid "Match objects support the following methods and attributes:"
msgstr ""

#: ../../library/re.rst:1158
msgid ""
"Return the string obtained by doing backslash substitution on the template "
"string *template*, as done by the :meth:`~Pattern.sub` method. Escapes such "
"as ``\\n`` are converted to the appropriate characters, and numeric "
"backreferences (``\\1``, ``\\2``) and named backreferences (``\\g<1>``, "
"``\\g<name>``) are replaced by the contents of the corresponding group."
msgstr ""

#: ../../library/re.rst:1170
msgid ""
"Returns one or more subgroups of the match.  If there is a single argument, "
"the result is a single string; if there are multiple arguments, the result "
"is a tuple with one item per argument. Without arguments, *group1* defaults "
"to zero (the whole match is returned). If a *groupN* argument is zero, the "
"corresponding return value is the entire matching string; if it is in the "
"inclusive range [1..99], it is the string matching the corresponding "
"parenthesized group.  If a group number is negative or larger than the "
"number of groups defined in the pattern, an :exc:`IndexError` exception is "
"raised. If a group is contained in a part of the pattern that did not match, "
"the corresponding result is ``None``. If a group is contained in a part of "
"the pattern that matched multiple times, the last match is returned. ::"
msgstr ""
"Returnerar en eller flera undergrupper av matchningen.  Om det finns ett "
"enda argument är resultatet en enda sträng; om det finns flera argument är "
"resultatet en tupel med ett objekt per argument. Utan argument är *group1* "
"standardvärdet noll (hela matchningen returneras). Om ett *groupN*-argument "
"är noll är motsvarande returvärde hela den matchande strängen; om det är i "
"det inkluderande intervallet [1..99] är det den sträng som matchar "
"motsvarande grupp inom parentes.  Om ett gruppnummer är negativt eller "
"större än det antal grupper som definieras i mönstret, uppstår ett :exc:"
"`IndexError` undantag. Om en grupp ingår i en del av mönstret som inte "
"matchade, är motsvarande resultat ``None``. Om en grupp ingår i en del av "
"mönstret som matchade flera gånger, returneras den sista matchningen. ::"

#: ../../library/re.rst:1192
msgid ""
"If the regular expression uses the ``(?P<name>...)`` syntax, the *groupN* "
"arguments may also be strings identifying groups by their group name.  If a "
"string argument is not used as a group name in the pattern, an :exc:"
"`IndexError` exception is raised."
msgstr ""
"Om det reguljära uttrycket använder syntaxen ``(?P<name>...)`` kan *groupN*-"
"argumenten också vara strängar som identifierar grupper med deras "
"gruppnamn.  Om ett strängargument inte används som ett gruppnamn i mönstret, "
"uppstår ett :exc:`IndexError` undantag."

#: ../../library/re.rst:1197
msgid "A moderately complicated example::"
msgstr "Ett måttligt komplicerat exempel::"

#: ../../library/re.rst:1205
msgid "Named groups can also be referred to by their index::"
msgstr "Namngivna grupper kan också hänvisas till genom sitt index::"

#: ../../library/re.rst:1212
msgid "If a group matches multiple times, only the last match is accessible::"
msgstr ""
"Om en grupp matchar flera gånger är det bara den sista matchningen som är "
"tillgänglig::"

#: ../../library/re.rst:1221
msgid ""
"This is identical to ``m.group(g)``.  This allows easier access to an "
"individual group from a match::"
msgstr ""
"Detta är identiskt med ``m.group(g)``.  Detta gör det lättare att få "
"tillgång till en enskild grupp från en matchning:"

#: ../../library/re.rst:1237
msgid ""
"Return a tuple containing all the subgroups of the match, from 1 up to "
"however many groups are in the pattern.  The *default* argument is used for "
"groups that did not participate in the match; it defaults to ``None``."
msgstr ""
"Returnerar en tupel som innehåller alla undergrupper i matchningen, från 1 "
"upp till hur många grupper som helst i mönstret.  Argumentet *default* "
"används för grupper som inte deltog i matchningen; standardvärdet är "
"``None``."

#: ../../library/re.rst:1241 ../../library/re.rst:1463
msgid "For example::"
msgstr "Till exempel::"

#: ../../library/re.rst:1247
msgid ""
"If we make the decimal place and everything after it optional, not all "
"groups might participate in the match.  These groups will default to "
"``None`` unless the *default* argument is given::"
msgstr ""
"Om vi gör decimaltecknet och allt efter det valfritt kan det hända att inte "
"alla grupper deltar i matchningen.  Dessa grupper kommer som standard att "
"vara ``None`` om inte *default*-argumentet anges::"

#: ../../library/re.rst:1260
msgid ""
"Return a dictionary containing all the *named* subgroups of the match, keyed "
"by the subgroup name.  The *default* argument is used for groups that did "
"not participate in the match; it defaults to ``None``.  For example::"
msgstr ""
"Returnerar en ordbok som innehåller alla *namngivna* undergrupper i "
"matchningen, med undergruppsnamnet som nyckel.  Argumentet *default* används "
"för grupper som inte deltog i matchningen; standardvärdet är ``None``.  Till "
"exempel::"

#: ../../library/re.rst:1272
msgid ""
"Return the indices of the start and end of the substring matched by *group*; "
"*group* defaults to zero (meaning the whole matched substring). Return "
"``-1`` if *group* exists but did not contribute to the match.  For a match "
"object *m*, and a group *g* that did contribute to the match, the substring "
"matched by group *g* (equivalent to ``m.group(g)``) is ::"
msgstr ""
"Returnerar indexen för början och slutet av den delsträng som matchas av "
"*group*; *group* är som standard noll (vilket betyder hela den matchade "
"delsträngen). Returnerar ``\\-1`` om *group* finns men inte bidrog till "
"matchningen.  För ett matchningsobjekt *m* och en grupp *g* som bidrog till "
"matchningen är den delsträng som matchas av gruppen *g* (motsvarande ``m."
"group(g)``) ::"

#: ../../library/re.rst:1280
msgid ""
"Note that ``m.start(group)`` will equal ``m.end(group)`` if *group* matched "
"a null string.  For example, after ``m = re.search('b(c?)', 'cba')``, ``m."
"start(0)`` is 1, ``m.end(0)`` is 2, ``m.start(1)`` and ``m.end(1)`` are both "
"2, and ``m.start(2)`` raises an :exc:`IndexError` exception."
msgstr ""
"Observera att ``m.start(group)`` kommer att vara lika med ``m.end(group)`` "
"om *group* matchade en nollsträng.  Till exempel, efter ``m = re."
"search('b(c?)', 'cba')``, är ``m.start(0)`` 1, ``m.end(0)`` är 2, ``m."
"start(1)`` och ``m.end(1)`` är båda 2, och ``m.start(2)`` ger upphov till "
"ett :exc:`IndexError` undantag."

#: ../../library/re.rst:1285
msgid "An example that will remove *remove_this* from email addresses::"
msgstr "Ett exempel som tar bort *remove_this* från e-postadresser::"

#: ../../library/re.rst:1295
msgid ""
"For a match *m*, return the 2-tuple ``(m.start(group), m.end(group))``. Note "
"that if *group* did not contribute to the match, this is ``(-1, -1)``. "
"*group* defaults to zero, the entire match."
msgstr ""
"För en matchning *m* returneras 2-tupeln ``(m.start(group), m.end(group))``. "
"Observera att om *grupp* inte bidrog till matchen är detta ``(-1, -1)``. "
"*group* är standardvärdet noll, hela matchningen."

#: ../../library/re.rst:1302
msgid ""
"The value of *pos* which was passed to the :meth:`~Pattern.search` or :meth:"
"`~Pattern.match` method of a :ref:`regex object <re-objects>`.  This is the "
"index into the string at which the RE engine started looking for a match."
msgstr ""
"Värdet på *pos* som skickades till metoden :meth:`~Pattern.search` eller :"
"meth:`~Pattern.match` i ett :ref:`regexobjekt <re-objects>`.  Detta är det "
"index i strängen där RE-motorn började leta efter en matchning."

#: ../../library/re.rst:1309
msgid ""
"The value of *endpos* which was passed to the :meth:`~Pattern.search` or :"
"meth:`~Pattern.match` method of a :ref:`regex object <re-objects>`.  This is "
"the index into the string beyond which the RE engine will not go."
msgstr ""
"Värdet på *endpos* som skickades till metoden :meth:`~Pattern.search` eller :"
"meth:`~Pattern.match` i en :ref:`regexobjekt <re-objects>`.  Detta är det "
"index i strängen som RE-motorn inte kommer längre än så."

#: ../../library/re.rst:1316
msgid ""
"The integer index of the last matched capturing group, or ``None`` if no "
"group was matched at all. For example, the expressions ``(a)b``, ``((a)"
"(b))``, and ``((ab))`` will have ``lastindex == 1`` if applied to the string "
"``'ab'``, while the expression ``(a)(b)`` will have ``lastindex == 2``, if "
"applied to the same string."
msgstr ""
"Heltalsindexet för den senast matchade fångstgruppen, eller ``None`` om "
"ingen grupp matchades alls. Till exempel kommer uttrycken ``(a)b``, ``((a)"
"(b))`` och ``((ab))`` att ha ``lastindex == 1`` om de tillämpas på strängen "
"``'ab'``, medan uttrycket ``(a)(b)`` kommer att ha ``lastindex == 2`` om det "
"tillämpas på samma sträng."

#: ../../library/re.rst:1325
msgid ""
"The name of the last matched capturing group, or ``None`` if the group "
"didn't have a name, or if no group was matched at all."
msgstr ""
"Namnet på den senast matchade fångstgruppen, eller ``None`` om gruppen inte "
"hade något namn, eller om ingen grupp matchades alls."

#: ../../library/re.rst:1331
msgid ""
"The :ref:`regular expression object <re-objects>` whose :meth:`~Pattern."
"match` or :meth:`~Pattern.search` method produced this match instance."
msgstr ""
"Den :ref:`objekt för reguljära uttryck <re-objects>` vars :meth:`~Pattern."
"match` eller :meth:`~Pattern.search` metod producerade denna "
"matchningsinstans."

#: ../../library/re.rst:1337
msgid "The string passed to :meth:`~Pattern.match` or :meth:`~Pattern.search`."
msgstr ""
"Den sträng som skickas till :meth:`~Pattern.match` eller :meth:`~Pattern."
"search`."

#: ../../library/re.rst:1340
msgid ""
"Added support of :func:`copy.copy` and :func:`copy.deepcopy`.  Match objects "
"are considered atomic."
msgstr ""
"Lagt till stöd för :func:`copy.copy` och :func:`copy.deepcopy`.  "
"Matchningsobjekt betraktas som atomära."

#: ../../library/re.rst:1348
msgid "Regular Expression Examples"
msgstr "Exempel på reguljära uttryck"

#: ../../library/re.rst:1352
msgid "Checking for a Pair"
msgstr "Kontrollerar för ett par"

#: ../../library/re.rst:1354
msgid ""
"In this example, we'll use the following helper function to display match "
"objects a little more gracefully::"
msgstr ""
"I det här exemplet använder vi följande hjälpfunktion för att visa "
"matchningsobjekt på ett lite mer elegant sätt::"

#: ../../library/re.rst:1362
msgid ""
"Suppose you are writing a poker program where a player's hand is represented "
"as a 5-character string with each character representing a card, \"a\" for "
"ace, \"k\" for king, \"q\" for queen, \"j\" for jack, \"t\" for 10, and "
"\"2\" through \"9\" representing the card with that value."
msgstr ""
"Anta att du skriver ett pokerprogram där en spelares hand representeras av "
"en sträng med 5 tecken där varje tecken representerar ett kort, \"a\" för "
"ess, \"k\" för kung, \"q\" för dam, \"j\" för knekt, \"t\" för 10 och \"2\" "
"till \"9\" representerar kortet med det värdet."

#: ../../library/re.rst:1367
msgid "To see if a given string is a valid hand, one could do the following::"
msgstr ""
"För att se om en given sträng är en giltig hand kan man göra följande::"

#: ../../library/re.rst:1377
msgid ""
"That last hand, ``\"727ak\"``, contained a pair, or two of the same valued "
"cards. To match this with a regular expression, one could use backreferences "
"as such::"
msgstr ""
"Den sista handen, ``\"727ak\"``, innehöll ett par eller två kort med samma "
"värde. För att matcha detta med ett reguljärt uttryck kan man använda "
"backreferenser som t.ex:"

#: ../../library/re.rst:1387
msgid ""
"To find out what card the pair consists of, one could use the :meth:`~Match."
"group` method of the match object in the following manner::"
msgstr ""
"För att ta reda på vilket kort paret består av kan man använda :meth:`~Match."
"group`\\-metoden för match-objektet på följande sätt::"

#: ../../library/re.rst:1406
msgid "Simulating scanf()"
msgstr "Simulering av scanf()"

#: ../../library/re.rst:1410
msgid ""
"Python does not currently have an equivalent to :c:func:`scanf`.  Regular "
"expressions are generally more powerful, though also more verbose, than :c:"
"func:`scanf` format strings.  The table below offers some more-or-less "
"equivalent mappings between :c:func:`scanf` format tokens and regular "
"expressions."
msgstr ""

#: ../../library/re.rst:1417
msgid ":c:func:`scanf` Token"
msgstr ""

#: ../../library/re.rst:1417
msgid "Regular Expression"
msgstr "Reguljärt uttryck"

#: ../../library/re.rst:1419
msgid "``%c``"
msgstr "``%c``"

#: ../../library/re.rst:1421
msgid "``%5c``"
msgstr "``%5c``"

#: ../../library/re.rst:1421
msgid "``.{5}``"
msgstr "``.{5}``"

#: ../../library/re.rst:1423
msgid "``%d``"
msgstr "``%d``"

#: ../../library/re.rst:1423
msgid "``[-+]?\\d+``"
msgstr "``[-+]?\\d+``"

#: ../../library/re.rst:1425
msgid "``%e``, ``%E``, ``%f``, ``%g``"
msgstr "``%e``, ``%E``, ``%f``, ``%g``"

#: ../../library/re.rst:1425
msgid "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"
msgstr "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"

#: ../../library/re.rst:1427
msgid "``%i``"
msgstr "``%i``"

#: ../../library/re.rst:1427
msgid "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"
msgstr "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"

#: ../../library/re.rst:1429
msgid "``%o``"
msgstr "``%o``"

#: ../../library/re.rst:1429
msgid "``[-+]?[0-7]+``"
msgstr "``[-+]?[0-7]+``"

#: ../../library/re.rst:1431
msgid "``%s``"
msgstr "``%s``"

#: ../../library/re.rst:1431
msgid "``\\S+``"
msgstr "``\\S+``"

#: ../../library/re.rst:1433
msgid "``%u``"
msgstr "``%u``"

#: ../../library/re.rst:1433
msgid "``\\d+``"
msgstr "``\\d+``"

#: ../../library/re.rst:1435
msgid "``%x``, ``%X``"
msgstr "``%x``, ``%X``"

#: ../../library/re.rst:1435
msgid "``[-+]?(0[xX])?[\\dA-Fa-f]+``"
msgstr "``[-+]?(0[xX])?[\\dA-Fa-f]+``"

#: ../../library/re.rst:1438
msgid "To extract the filename and numbers from a string like ::"
msgstr "Så här extraherar du filnamn och siffror från en sträng som ::"

#: ../../library/re.rst:1442
msgid "you would use a :c:func:`scanf` format like ::"
msgstr ""

#: ../../library/re.rst:1446
msgid "The equivalent regular expression would be ::"
msgstr "Motsvarande reguljära uttryck skulle vara ::"

#: ../../library/re.rst:1454
msgid "search() vs. match()"
msgstr "sök() vs. match()"

#: ../../library/re.rst:1458
msgid ""
"Python offers two different primitive operations based on regular "
"expressions: :func:`re.match` checks for a match only at the beginning of "
"the string, while :func:`re.search` checks for a match anywhere in the "
"string (this is what Perl does by default)."
msgstr ""

#: ../../library/re.rst:1469
msgid ""
"Regular expressions beginning with ``'^'`` can be used with :func:`search` "
"to restrict the match at the beginning of the string::"
msgstr ""
"Reguljära uttryck som börjar med ``'^'`` kan användas med :func:`search` för "
"att begränsa matchningen till början av strängen::"

#: ../../library/re.rst:1477
msgid ""
"Note however that in :const:`MULTILINE` mode :func:`match` only matches at "
"the beginning of the string, whereas using :func:`search` with a regular "
"expression beginning with ``'^'`` will match at the beginning of each "
"line. ::"
msgstr ""
"Observera dock att i :const:`MULTILINE`\\-läget matchar :func:`match` bara i "
"början av strängen, medan :func:`search` med ett reguljärt uttryck som "
"börjar med ``'^'`` matchar i början av varje rad:"

#: ../../library/re.rst:1487
msgid "Making a Phonebook"
msgstr "Skapa en telefonbok"

#: ../../library/re.rst:1489
msgid ""
":func:`split` splits a string into a list delimited by the passed pattern.  "
"The method is invaluable for converting textual data into data structures "
"that can be easily read and modified by Python as demonstrated in the "
"following example that creates a phonebook."
msgstr ""
":func:`split` delar upp en sträng i en lista som avgränsas av det passerade "
"mönstret.  Metoden är ovärderlig för att konvertera textdata till "
"datastrukturer som lätt kan läsas och modifieras av Python, vilket visas i "
"följande exempel som skapar en telefonbok."

#: ../../library/re.rst:1494
msgid ""
"First, here is the input.  Normally it may come from a file, here we are "
"using triple-quoted string syntax"
msgstr ""
"Först, här är indata.  Normalt kan den komma från en fil, här använder vi "
"trippelciterad strängsyntax"

#: ../../library/re.rst:1507
msgid ""
"The entries are separated by one or more newlines. Now we convert the string "
"into a list with each nonempty line having its own entry:"
msgstr ""
"Posterna är åtskilda av en eller flera nya linjer. Nu omvandlar vi strängen "
"till en lista där varje icke-tom rad har en egen post:"

#: ../../library/re.rst:1520
msgid ""
"Finally, split each entry into a list with first name, last name, telephone "
"number, and address.  We use the ``maxsplit`` parameter of :func:`split` "
"because the address has spaces, our splitting pattern, in it:"
msgstr ""
"Slutligen delar vi upp varje post i en lista med förnamn, efternamn, "
"telefonnummer och adress.  Vi använder parametern ``maxsplit`` i :func:"
"`split` eftersom adressen innehåller mellanslag, vårt uppdelningsmönster:"

#: ../../library/re.rst:1533
msgid ""
"The ``:?`` pattern matches the colon after the last name, so that it does "
"not occur in the result list.  With a ``maxsplit`` of ``4``, we could "
"separate the house number from the street name:"
msgstr ""
"Mönstret ``:?`` matchar kolon efter efternamnet, så att det inte förekommer "
"i resultatlistan.  Med en ``maxsplit`` på ``4`` kan vi separera husnumret "
"från gatunamnet:"

#: ../../library/re.rst:1548
msgid "Text Munging"
msgstr "Text Munging"

#: ../../library/re.rst:1550
msgid ""
":func:`sub` replaces every occurrence of a pattern with a string or the "
"result of a function.  This example demonstrates using :func:`sub` with a "
"function to \"munge\" text, or randomize the order of all the characters in "
"each word of a sentence except for the first and last characters::"
msgstr ""
":func:`sub` ersätter varje förekomst av ett mönster med en sträng eller "
"resultatet av en funktion.  I det här exemplet används :func:`sub` "
"tillsammans med en funktion för att \"mjuka upp\" text, dvs. slumpa fram "
"ordningen på alla tecken i varje ord i en mening utom det första och sista "
"tecknet::"

#: ../../library/re.rst:1567
msgid "Finding all Adverbs"
msgstr "Hitta alla adverb"

#: ../../library/re.rst:1569
msgid ""
":func:`findall` matches *all* occurrences of a pattern, not just the first "
"one as :func:`search` does.  For example, if a writer wanted to find all of "
"the adverbs in some text, they might use :func:`findall` in the following "
"manner::"
msgstr ""
":func:`findall` matchar *alla* förekomster av ett mönster, inte bara den "
"första som :func:`search` gör.  Om en skribent till exempel vill hitta alla "
"adverb i en text, kan han använda :func:`findall` på följande sätt::"

#: ../../library/re.rst:1580
msgid "Finding all Adverbs and their Positions"
msgstr "Hitta alla adverb och deras positioner"

#: ../../library/re.rst:1582
msgid ""
"If one wants more information about all matches of a pattern than the "
"matched text, :func:`finditer` is useful as it provides :ref:`match objects "
"<match-objects>` instead of strings.  Continuing with the previous example, "
"if a writer wanted to find all of the adverbs *and their positions* in some "
"text, they would use :func:`finditer` in the following manner::"
msgstr ""

#: ../../library/re.rst:1596
msgid "Raw String Notation"
msgstr "Notation av råa strängar"

#: ../../library/re.rst:1598
msgid ""
"Raw string notation (``r\"text\"``) keeps regular expressions sane.  Without "
"it, every backslash (``'\\'``) in a regular expression would have to be "
"prefixed with another one to escape it.  For example, the two following "
"lines of code are functionally identical::"
msgstr ""
"Rå strängnotation (``r\"text\"``) håller reguljära uttryck sunda.  Utan den "
"skulle varje backslash (``'\\'``) i ett reguljärt uttryck behöva föregås av "
"en annan för att undkomma den.  Till exempel är de två följande raderna med "
"kod funktionellt identiska::"

#: ../../library/re.rst:1608
msgid ""
"When one wants to match a literal backslash, it must be escaped in the "
"regular expression.  With raw string notation, this means ``r\"\\\\\"``.  "
"Without raw string notation, one must use ``\"\\\\\\\\\"``, making the "
"following lines of code functionally identical::"
msgstr ""
"När man vill matcha en bokstavlig backslash måste den escapas i det "
"reguljära uttrycket.  Med rå strängnotation betyder detta ``r\"\\\\\"``.  "
"Utan rå strängnotation måste man använda ``\"\\\\\\\\\"``, vilket gör "
"följande kodrader funktionellt identiska::"

#: ../../library/re.rst:1620
msgid "Writing a Tokenizer"
msgstr "Skriva en Tokenizer"

#: ../../library/re.rst:1622
msgid ""
"A `tokenizer or scanner <https://en.wikipedia.org/wiki/Lexical_analysis>`_ "
"analyzes a string to categorize groups of characters.  This is a useful "
"first step in writing a compiler or interpreter."
msgstr ""
"En `tokenizer eller scanner <https://en.wikipedia.org/wiki/"
"Lexical_analysis>`_ analyserar en sträng för att kategorisera grupper av "
"tecken.  Detta är ett användbart första steg i att skriva en kompilator "
"eller tolk."

#: ../../library/re.rst:1626
msgid ""
"The text categories are specified with regular expressions.  The technique "
"is to combine those into a single master regular expression and to loop over "
"successive matches::"
msgstr ""
"Textkategorierna specificeras med reguljära uttryck.  Tekniken är att "
"kombinera dessa till ett enda övergripande reguljärt uttryck och att loopa "
"över successiva matchningar::"

#: ../../library/re.rst:1682
msgid "The tokenizer produces the following output::"
msgstr "Tokenizer producerar följande utdata::"

#: ../../library/re.rst:1705
msgid ""
"Friedl, Jeffrey. Mastering Regular Expressions. 3rd ed., O'Reilly Media, "
"2009. The third edition of the book no longer covers Python at all, but the "
"first edition covered writing good regular expression patterns in great "
"detail."
msgstr ""
"Friedl, Jeffrey. Mastering Regular Expressions. 3:e upplagan, O'Reilly "
"Media, 2009. Den tredje upplagan av boken täcker inte längre Python alls, "
"men den första upplagan täckte att skriva bra reguljära uttrycksmönster i "
"stor detalj."
