# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# python-doc bot, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-25 16:33+0000\n"
"PO-Revision-Date: 2025-09-22 16:50+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../library/importlib.rst:2
msgid ":mod:`!importlib` --- The implementation of :keyword:`!import`"
msgstr ":mod:`!importlib` --- Implementeringen av :keyword:`!import`"

#: ../../library/importlib.rst:12
msgid "**Source code:** :source:`Lib/importlib/__init__.py`"
msgstr "**Källkod:** :source:`Lib/importlib/__init__.py`"

#: ../../library/importlib.rst:18
msgid "Introduction"
msgstr "Introduktion"

#: ../../library/importlib.rst:20
msgid "The purpose of the :mod:`importlib` package is three-fold."
msgstr "Syftet med :mod:`importlib`\\-paketet är trefaldigt."

#: ../../library/importlib.rst:22
msgid ""
"One is to provide the implementation of the :keyword:`import` statement (and"
" thus, by extension, the :func:`__import__` function) in Python source code."
" This provides an implementation of :keyword:`!import` which is portable to "
"any Python interpreter. This also provides an implementation which is easier"
" to comprehend than one implemented in a programming language other than "
"Python."
msgstr ""
"En är att tillhandahålla implementeringen av :keyword:`import`\\-satsen (och"
" därmed, i förlängningen, :func:`__import__`\\-funktionen) i Python-källkod."
" Detta ger en implementering av :keyword:`!import` som är portabel till alla"
" Python-tolkar. Detta ger också en implementering som är lättare att förstå "
"än en implementering i ett annat programmeringsspråk än Python."

#: ../../library/importlib.rst:29
msgid ""
"Two, the components to implement :keyword:`import` are exposed in this "
"package, making it easier for users to create their own custom objects "
"(known generically as an :term:`importer`) to participate in the import "
"process."
msgstr ""
"För det andra exponeras komponenterna för att implementera :keyword:`import`"
" i detta paket, vilket gör det lättare för användare att skapa sina egna "
"anpassade objekt (allmänt kända som en :term:`importer`) för att delta i "
"importprocessen."

#: ../../library/importlib.rst:33
msgid ""
"Three, the package contains modules exposing additional functionality for "
"managing aspects of Python packages:"
msgstr ""
"Tre, paketet innehåller moduler som exponerar ytterligare funktionalitet för"
" att hantera aspekter av Python-paket:"

#: ../../library/importlib.rst:36
msgid ""
":mod:`importlib.metadata` presents access to metadata from third-party "
"distributions."
msgstr ""
":mod:`importlib.metadata` ger tillgång till metadata från "
"tredjepartsdistributioner."

#: ../../library/importlib.rst:38
msgid ""
":mod:`importlib.resources` provides routines for accessing non-code "
"\"resources\" from Python packages."
msgstr ""
":mod:`importlib.resources` tillhandahåller rutiner för att komma åt icke-"
"kodade \"resurser\" från Python-paket."

#: ../../library/importlib.rst:44
msgid ":ref:`import`"
msgstr ":ref:`import`"

#: ../../library/importlib.rst:44
msgid "The language reference for the :keyword:`import` statement."
msgstr "Språkreferensen för :keyword:`import`\\-satsen."

#: ../../library/importlib.rst:49
msgid ""
"`Packages specification <https://www.python.org/doc/essays/packages/>`__"
msgstr "`Paketspecifikation <https://www.python.org/doc/essays/packages/>`__"

#: ../../library/importlib.rst:47
msgid ""
"Original specification of packages. Some semantics have changed since the "
"writing of this document (e.g. redirecting based on ``None`` in "
":data:`sys.modules`)."
msgstr ""
"Ursprunglig specifikation av paket. Viss semantik har ändrats sedan detta "
"dokument skrevs (t.ex. omdirigering baserad på ``None`` i "
":data:`sys.modules`)."

#: ../../library/importlib.rst:52
msgid "The :func:`.__import__` function"
msgstr "Funktionen :func:`.__import__`"

#: ../../library/importlib.rst:52
msgid "The :keyword:`import` statement is syntactic sugar for this function."
msgstr ""
"Satsen :keyword:`import` är ett syntaktiskt socker för denna funktion."

#: ../../library/importlib.rst:55
msgid ":ref:`sys-path-init`"
msgstr ":ref:`sys-path-init`"

#: ../../library/importlib.rst:55
msgid "The initialization of :data:`sys.path`."
msgstr "Initialisering av :data:`sys.path`."

#: ../../library/importlib.rst:58
msgid ":pep:`235`"
msgstr ":pep:`235`"

#: ../../library/importlib.rst:58
msgid "Import on Case-Insensitive Platforms"
msgstr "Import på plattformar som är okänsliga för skiftlägeslägeskoder"

#: ../../library/importlib.rst:61
msgid ":pep:`263`"
msgstr ":pep:`263`"

#: ../../library/importlib.rst:61
msgid "Defining Python Source Code Encodings"
msgstr "Definiera kodning av Python-källkod"

#: ../../library/importlib.rst:64
msgid ":pep:`302`"
msgstr ":pep:`302`"

#: ../../library/importlib.rst:64
msgid "New Import Hooks"
msgstr "Hooks för ny import"

#: ../../library/importlib.rst:67
msgid ":pep:`328`"
msgstr ":pep:`328`"

#: ../../library/importlib.rst:67
msgid "Imports: Multi-Line and Absolute/Relative"
msgstr "Import: Multi-Line och Absolut/Relativ"

#: ../../library/importlib.rst:70
msgid ":pep:`366`"
msgstr ":pep:`366`"

#: ../../library/importlib.rst:70
msgid "Main module explicit relative imports"
msgstr "Huvudmodulens explicita relativa import"

#: ../../library/importlib.rst:73
msgid ":pep:`420`"
msgstr ":pep:`420`"

#: ../../library/importlib.rst:73
msgid "Implicit namespace packages"
msgstr "Implicita namnrymdspaket"

#: ../../library/importlib.rst:76
msgid ":pep:`451`"
msgstr ":pep:`451`"

#: ../../library/importlib.rst:76
msgid "A ModuleSpec Type for the Import System"
msgstr "En ModuleSpec-typ för importsystemet"

#: ../../library/importlib.rst:79
msgid ":pep:`488`"
msgstr ":pep:`488`"

#: ../../library/importlib.rst:79
msgid "Elimination of PYO files"
msgstr "Eliminering av PYO-filer"

#: ../../library/importlib.rst:82
msgid ":pep:`489`"
msgstr ":pep:`489`"

#: ../../library/importlib.rst:82
msgid "Multi-phase extension module initialization"
msgstr "Initialisering av utökningsmodul i flera faser"

#: ../../library/importlib.rst:85
msgid ":pep:`552`"
msgstr ":pep:`552`"

#: ../../library/importlib.rst:85
msgid "Deterministic pycs"
msgstr "Deterministisk pycs"

#: ../../library/importlib.rst:88
msgid ":pep:`3120`"
msgstr ":pep:`3120`"

#: ../../library/importlib.rst:88
msgid "Using UTF-8 as the Default Source Encoding"
msgstr "Använda UTF-8 som standardkodning för källkod"

#: ../../library/importlib.rst:90
msgid ":pep:`3147`"
msgstr ":pep:`3147`"

#: ../../library/importlib.rst:91
msgid "PYC Repository Directories"
msgstr "Kataloger för PYC-förvar"

#: ../../library/importlib.rst:95
msgid "Functions"
msgstr "Funktioner"

#: ../../library/importlib.rst:99
msgid "An implementation of the built-in :func:`__import__` function."
msgstr "En implementation av den inbyggda funktionen :func:`__import__`."

#: ../../library/importlib.rst:102
msgid ""
"Programmatic importing of modules should use :func:`import_module` instead "
"of this function."
msgstr ""
"Programmatisk import av moduler bör använda :func:`import_module` istället "
"för denna funktion."

#: ../../library/importlib.rst:107
msgid ""
"Import a module. The *name* argument specifies what module to import in "
"absolute or relative terms (e.g. either ``pkg.mod`` or ``..mod``). If the "
"name is specified in relative terms, then the *package* argument must be set"
" to the name of the package which is to act as the anchor for resolving the "
"package name (e.g. ``import_module('..mod', 'pkg.subpkg')`` will import "
"``pkg.mod``)."
msgstr ""
"Importera en modul. Argumentet *name* anger vilken modul som ska importeras "
"i absoluta eller relativa termer (t.ex. antingen ``pkg.mod`` eller "
"``..mod``). Om namnet anges i relativa termer måste argumentet *package* "
"sättas till namnet på det paket som ska fungera som ankare för att lösa upp "
"paketnamnet (t.ex. ``import_module('..mod', 'pkg.subpkg')`` importerar "
"``pkg.mod``)."

#: ../../library/importlib.rst:115
msgid ""
"The :func:`import_module` function acts as a simplifying wrapper around "
":func:`importlib.__import__`. This means all semantics of the function are "
"derived from :func:`importlib.__import__`. The most important difference "
"between these two functions is that :func:`import_module` returns the "
"specified package or module (e.g. ``pkg.mod``), while :func:`__import__` "
"returns the top-level package or module (e.g. ``pkg``)."
msgstr ""
"Funktionen :func:`import_module` fungerar som ett förenklande hölje runt "
":func:`importlib.__import__`. Detta innebär att all semantik i funktionen "
"härleds från :func:`importlib.__import__`. Den viktigaste skillnaden mellan "
"dessa två funktioner är att :func:`import_module` returnerar det angivna "
"paketet eller modulen (t.ex. ``pkg.mod``), medan :func:`__import__` "
"returnerar paketet eller modulen på högsta nivån (t.ex. ``pkg``)."

#: ../../library/importlib.rst:122
msgid ""
"If you are dynamically importing a module that was created since the "
"interpreter began execution (e.g., created a Python source file), you may "
"need to call :func:`invalidate_caches` in order for the new module to be "
"noticed by the import system."
msgstr ""
"Om du dynamiskt importerar en modul som skapats sedan tolken började "
"exekvera (t.ex. skapade en Python-källfil), kan du behöva anropa "
":func:`invalidate_caches` för att den nya modulen ska uppmärksammas av "
"importsystemet."

#: ../../library/importlib.rst:127
msgid "Parent packages are automatically imported."
msgstr "Föräldrapaket importeras automatiskt."

#: ../../library/importlib.rst:132
msgid ""
"Find the loader for a module, optionally within the specified *path*. If the"
" module is in :attr:`sys.modules`, then ``sys.modules[name].__loader__`` is "
"returned (unless the loader would be ``None`` or is not set, in which case "
":exc:`ValueError` is raised). Otherwise a search using :attr:`sys.meta_path`"
" is done. ``None`` is returned if no loader is found."
msgstr ""

#: ../../library/importlib.rst:138
msgid ""
"A dotted name does not have its parents implicitly imported as that requires"
" loading them and that may not be desired. To properly import a submodule "
"you will need to import all parent packages of the submodule and use the "
"correct argument to *path*."
msgstr ""

#: ../../library/importlib.rst:145
msgid ""
"If ``__loader__`` is not set, raise :exc:`ValueError`, just like when the "
"attribute is set to ``None``."
msgstr ""

#: ../../library/importlib.rst:149
msgid "Use :func:`importlib.util.find_spec` instead."
msgstr ""

#: ../../library/importlib.rst:154
msgid ""
"Invalidate the internal caches of finders stored at :data:`sys.meta_path`. "
"If a finder implements ``invalidate_caches()`` then it will be called to "
"perform the invalidation.  This function should be called if any modules are"
" created/installed while your program is running to guarantee all finders "
"will notice the new module's existence."
msgstr ""
"Invalidera de interna cacherna för sökare som lagras på "
":data:`sys.meta_path`. Om en sökare implementerar ``invalidate_caches()`` "
"kommer den att anropas för att utföra invalideringen.  Den här funktionen "
"bör anropas om moduler skapas/installeras medan ditt program körs för att "
"garantera att alla sökare märker att den nya modulen finns."

#: ../../library/importlib.rst:162
msgid ""
"Namespace packages created/installed in a different :data:`sys.path` "
"location after the same namespace was already imported are noticed."
msgstr ""
"Namnrymdspaket som skapats/installerats på en annan :data:`sys.path`\\-plats"
" efter att samma namnrymd redan importerats uppmärksammas."

#: ../../library/importlib.rst:168
msgid ""
"Reload a previously imported *module*.  The argument must be a module "
"object, so it must have been successfully imported before.  This is useful "
"if you have edited the module source file using an external editor and want "
"to try out the new version without leaving the Python interpreter.  The "
"return value is the module object (which can be different if re-importing "
"causes a different object to be placed in :data:`sys.modules`)."
msgstr ""
"Laddar om en tidigare importerad *modul*.  Argumentet måste vara ett "
"modulobjekt, så det måste ha importerats tidigare.  Detta är användbart om "
"du har redigerat modulens källfil med en extern editor och vill prova den "
"nya versionen utan att lämna Python-tolken.  Returvärdet är modulobjektet "
"(som kan vara annorlunda om en ny import gör att ett annat objekt placeras i"
" :data:`sys.modules`)."

#: ../../library/importlib.rst:175
msgid "When :func:`reload` is executed:"
msgstr "När :func:`reload` utförs:"

#: ../../library/importlib.rst:177
msgid ""
"Python module's code is recompiled and the module-level code re-executed, "
"defining a new set of objects which are bound to names in the module's "
"dictionary by reusing the :term:`loader` which originally loaded the module."
"  The ``init`` function of extension modules is not called a second time."
msgstr ""
"Python-modulens kod kompileras om och koden på modulnivå exekveras på nytt, "
"vilket definierar en ny uppsättning objekt som är bundna till namn i "
"modulens ordbok genom att återanvända :term:`loader` som ursprungligen "
"laddade modulen.  Funktionen ``init`` för tilläggsmoduler anropas inte en "
"andra gång."

#: ../../library/importlib.rst:183
msgid ""
"As with all other objects in Python the old objects are only reclaimed after"
" their reference counts drop to zero."
msgstr ""
"Som med alla andra objekt i Python återkrävs de gamla objekten först när "
"deras referensantal sjunkit till noll."

#: ../../library/importlib.rst:186
msgid ""
"The names in the module namespace are updated to point to any new or changed"
" objects."
msgstr ""
"Namnen i modulens namnrymd uppdateras för att peka på alla nya eller ändrade"
" objekt."

#: ../../library/importlib.rst:189
msgid ""
"Other references to the old objects (such as names external to the module) "
"are not rebound to refer to the new objects and must be updated in each "
"namespace where they occur if that is desired."
msgstr ""
"Andra referenser till de gamla objekten (t.ex. namn utanför modulen) är inte"
" rebound för att referera till de nya objekten och måste uppdateras i varje "
"namnrymd där de förekommer om så önskas."

#: ../../library/importlib.rst:193
msgid "There are a number of other caveats:"
msgstr "Det finns ett antal andra förbehåll:"

#: ../../library/importlib.rst:195
msgid ""
"When a module is reloaded, its dictionary (containing the module's global "
"variables) is retained.  Redefinitions of names will override the old "
"definitions, so this is generally not a problem.  If the new version of a "
"module does not define a name that was defined by the old version, the old "
"definition remains.  This feature can be used to the module's advantage if "
"it maintains a global table or cache of objects --- with a :keyword:`try` "
"statement it can test for the table's presence and skip its initialization "
"if desired::"
msgstr ""
"När en modul laddas om behålls dess dictionary (som innehåller modulens "
"globala variabler).  Omdefinitioner av namn kommer att åsidosätta de gamla "
"definitionerna, så detta är i allmänhet inget problem.  Om den nya versionen"
" av en modul inte definierar ett namn som definierades i den gamla "
"versionen, kvarstår den gamla definitionen.  Denna funktion kan användas "
"till modulens fördel om den upprätthåller en global tabell eller cache av "
"objekt --- med en :keyword:`try`\\-sats kan den testa om tabellen finns och "
"hoppa över dess initialisering om så önskas::"

#: ../../library/importlib.rst:209
msgid ""
"It is generally not very useful to reload built-in or dynamically loaded "
"modules.  Reloading :mod:`sys`, :mod:`__main__`, :mod:`builtins` and other "
"key modules is not recommended.  In many cases extension modules are not "
"designed to be initialized more than once, and may fail in arbitrary ways "
"when reloaded."
msgstr ""
"Det är i allmänhet inte särskilt användbart att ladda om inbyggda eller "
"dynamiskt laddade moduler.  Att ladda om :mod:`sys`, :mod:`__main__`, "
":mod:`builtins` och andra nyckelmoduler rekommenderas inte.  I många fall är"
" tilläggsmoduler inte utformade för att initieras mer än en gång, och kan "
"misslyckas på godtyckliga sätt när de laddas om."

#: ../../library/importlib.rst:215
msgid ""
"If a module imports objects from another module using :keyword:`from` ... "
":keyword:`import` ..., calling :func:`reload` for the other module does not "
"redefine the objects imported from it --- one way around this is to re-"
"execute the :keyword:`!from` statement, another is to use :keyword:`!import`"
" and qualified names (*module.name*) instead."
msgstr ""
"Om en modul importerar objekt från en annan modul med hjälp av "
":keyword:`from` ... :keyword:`import` ..., omdefinieras inte de objekt som "
"importerats från den andra modulen genom att anropa :func:`reload` för den "
"andra modulen --- ett sätt att komma runt detta är att utföra "
":keyword:`!from`\\-satsen igen, ett annat är att använda :keyword:`!import` "
"och kvalificerade namn (*module.name*) istället."

#: ../../library/importlib.rst:221
msgid ""
"If a module instantiates instances of a class, reloading the module that "
"defines the class does not affect the method definitions of the instances "
"--- they continue to use the old class definition.  The same is true for "
"derived classes."
msgstr ""
"Om en modul instansierar instanser av en klass påverkas inte "
"metoddefinitionerna för instanserna av att modulen som definierar klassen "
"laddas om - de fortsätter att använda den gamla klassdefinitionen.  Samma "
"sak gäller för härledda klasser."

#: ../../library/importlib.rst:227
msgid ""
":exc:`ModuleNotFoundError` is raised when the module being reloaded lacks a "
":class:`~importlib.machinery.ModuleSpec`."
msgstr ""
":exc:`ModuleNotFoundError` uppstår när den modul som laddas om saknar en "
":class:`~importlib.machinery.ModuleSpec`."

#: ../../library/importlib.rst:233
msgid ":mod:`importlib.abc` -- Abstract base classes related to import"
msgstr ":mod:`importlib.abc` -- Abstrakta basklasser relaterade till import"

#: ../../library/importlib.rst:238
msgid "**Source code:** :source:`Lib/importlib/abc.py`"
msgstr "**Källkod:** :source:`Lib/importlib/abc.py`"

#: ../../library/importlib.rst:243
msgid ""
"The :mod:`importlib.abc` module contains all of the core abstract base "
"classes used by :keyword:`import`. Some subclasses of the core abstract base"
" classes are also provided to help in implementing the core ABCs."
msgstr ""
"Modulen :mod:`importlib.abc` innehåller alla de centrala abstrakta "
"basklasser som används av :keyword:`import`. Vissa subklasser av de centrala"
" abstrakta basklasserna tillhandahålls också för att hjälpa till att "
"implementera de centrala ABC."

#: ../../library/importlib.rst:247
msgid "ABC hierarchy::"
msgstr "ABC-hierarkin::"

#: ../../library/importlib.rst:263
msgid "An abstract base class representing a :term:`finder`."
msgstr ""

#: ../../library/importlib.rst:265
msgid "Use :class:`MetaPathFinder` or :class:`PathEntryFinder` instead."
msgstr ""

#: ../../library/importlib.rst:270
msgid ""
"An abstract method for finding a :term:`loader` for the specified module.  "
"Originally specified in :pep:`302`, this method was meant for use in "
":data:`sys.meta_path` and in the path-based import subsystem."
msgstr ""

#: ../../library/importlib.rst:274
msgid ""
"Returns ``None`` when called instead of raising :exc:`NotImplementedError`."
msgstr ""

#: ../../library/importlib.rst:278
msgid ""
"Implement :meth:`MetaPathFinder.find_spec` or "
":meth:`PathEntryFinder.find_spec` instead."
msgstr ""

#: ../../library/importlib.rst:285
msgid "An abstract base class representing a :term:`meta path finder`."
msgstr "En abstrakt basklass som representerar en :term:`meta path finder`."

#: ../../library/importlib.rst:289 ../../library/importlib.rst:344
msgid "No longer a subclass of :class:`Finder`."
msgstr ""

#: ../../library/importlib.rst:294
msgid ""
"An abstract method for finding a :term:`spec <module spec>` for the "
"specified module.  If this is a top-level import, *path* will be ``None``.  "
"Otherwise, this is a search for a subpackage or module and *path* will be "
"the value of :attr:`__path__` from the parent package. If a spec cannot be "
"found, ``None`` is returned. When passed in, ``target`` is a module object "
"that the finder may use to make a more educated guess about what spec to "
"return. :func:`importlib.util.spec_from_loader` may be useful for "
"implementing concrete ``MetaPathFinders``."
msgstr ""

#: ../../library/importlib.rst:308
msgid ""
"A legacy method for finding a :term:`loader` for the specified module.  If "
"this is a top-level import, *path* will be ``None``. Otherwise, this is a "
"search for a subpackage or module and *path* will be the value of "
":attr:`__path__` from the parent package. If a loader cannot be found, "
"``None`` is returned."
msgstr ""

#: ../../library/importlib.rst:314
msgid ""
"If :meth:`find_spec` is defined, backwards-compatible functionality is "
"provided."
msgstr ""

#: ../../library/importlib.rst:317
msgid ""
"Returns ``None`` when called instead of raising :exc:`NotImplementedError`. "
"Can use :meth:`find_spec` to provide functionality."
msgstr ""

#: ../../library/importlib.rst:322 ../../library/importlib.rst:378
#: ../../library/importlib.rst:386 ../../library/importlib.rst:902
#: ../../library/importlib.rst:959
msgid "Use :meth:`find_spec` instead."
msgstr ""

#: ../../library/importlib.rst:327
msgid ""
"An optional method which, when called, should invalidate any internal cache "
"used by the finder. Used by :func:`importlib.invalidate_caches` when "
"invalidating the caches of all finders on :data:`sys.meta_path`."
msgstr ""
"En valfri metod som, när den anropas, ska ogiltigförklara alla interna "
"cacheminnen som används av sökaren. Används av "
":func:`importlib.invalidate_caches` när cachen för alla sökare på "
":data:`sys.meta_path` ogiltigförklaras."

#: ../../library/importlib.rst:331
msgid "Returns ``None`` when called instead of :data:`NotImplemented`."
msgstr ""
"Returnerar ``None`` när den anropas istället för :data:`NotImplemented`."

#: ../../library/importlib.rst:337
msgid ""
"An abstract base class representing a :term:`path entry finder`.  Though it "
"bears some similarities to :class:`MetaPathFinder`, ``PathEntryFinder`` is "
"meant for use only within the path-based import subsystem provided by "
":class:`importlib.machinery.PathFinder`."
msgstr ""
"En abstrakt basklass som representerar en :term:`path entry finder`.  Även "
"om den har vissa likheter med :class:`MetaPathFinder`, är "
"``PathEntryFinder`` endast avsedd att användas inom det sökvägsbaserade "
"importundersystem som tillhandahålls av "
":class:`importlib.machinery.PathFinder`."

#: ../../library/importlib.rst:349
msgid ""
"An abstract method for finding a :term:`spec <module spec>` for the "
"specified module.  The finder will search for the module only within the "
":term:`path entry` to which it is assigned.  If a spec cannot be found, "
"``None`` is returned.  When passed in, ``target`` is a module object that "
"the finder may use to make a more educated guess about what spec to return. "
":func:`importlib.util.spec_from_loader` may be useful for implementing "
"concrete ``PathEntryFinders``."
msgstr ""
"En abstrakt metod för att hitta en :term:`spec <module spec>` för den "
"angivna modulen.  Sökaren kommer att söka efter modulen endast inom "
":term:`path entry` som den är tilldelad.  Om en specifikation inte kan "
"hittas returneras ``None``.  När ``target`` skickas in är det ett "
"modulobjekt som sökaren kan använda för att göra en mer kvalificerad "
"gissning om vilken spec som ska returneras. "
":func:`importlib.util.spec_from_loader` kan vara användbar för att "
"implementera konkreta ``PathEntryFinders``."

#: ../../library/importlib.rst:361
msgid ""
"A legacy method for finding a :term:`loader` for the specified module.  "
"Returns a 2-tuple of ``(loader, portion)`` where ``portion`` is a sequence "
"of file system locations contributing to part of a namespace package. The "
"loader may be ``None`` while specifying ``portion`` to signify the "
"contribution of the file system locations to a namespace package. An empty "
"list can be used for ``portion`` to signify the loader is not part of a "
"namespace package. If ``loader`` is ``None`` and ``portion`` is the empty "
"list then no loader or location for a namespace package were found (i.e. "
"failure to find anything for the module)."
msgstr ""

#: ../../library/importlib.rst:371
msgid ""
"If :meth:`find_spec` is defined then backwards-compatible functionality is "
"provided."
msgstr ""

#: ../../library/importlib.rst:374
msgid ""
"Returns ``(None, [])`` instead of raising :exc:`NotImplementedError`. Uses "
":meth:`find_spec` when available to provide functionality."
msgstr ""

#: ../../library/importlib.rst:383
msgid ""
"A concrete implementation of :meth:`Finder.find_module` which is equivalent "
"to ``self.find_loader(fullname)[0]``."
msgstr ""

#: ../../library/importlib.rst:391
msgid ""
"An optional method which, when called, should invalidate any internal cache "
"used by the finder. Used by "
":meth:`importlib.machinery.PathFinder.invalidate_caches` when invalidating "
"the caches of all cached finders."
msgstr ""
"En valfri metod som, när den anropas, ska ogiltigförklara alla interna "
"cacheminnen som används av sökaren. Används av "
":meth:`importlib.machinery.PathFinder.invalidate_caches` när cacheminnet för"
" alla cachade sökare ogiltigförklaras."

#: ../../library/importlib.rst:399
msgid ""
"An abstract base class for a :term:`loader`. See :pep:`302` for the exact "
"definition for a loader."
msgstr ""
"En abstrakt basklass för en :term:`loader`. Se :pep:`302` för den exakta "
"definitionen av en laddare."

#: ../../library/importlib.rst:402
msgid ""
"Loaders that wish to support resource reading should implement a "
":meth:`get_resource_reader` method as specified by "
":class:`importlib.resources.abc.ResourceReader`."
msgstr ""
"Laddare som vill stödja resursläsning bör implementera en "
":meth:`get_resource_reader`\\-metod som specificeras av "
":class:`importlib.resources.abc.ResourceReader`."

#: ../../library/importlib.rst:406
msgid "Introduced the optional :meth:`get_resource_reader` method."
msgstr "Införde den valfria metoden :meth:`get_resource_reader`."

#: ../../library/importlib.rst:411
msgid ""
"A method that returns the module object to use when importing a module.  "
"This method may return ``None``, indicating that default module creation "
"semantics should take place."
msgstr ""
"En metod som returnerar det modulobjekt som ska användas vid import av en "
"modul.  Denna metod kan returnera ``None``, vilket indikerar att standard "
"semantik för modulskapande ska användas."

#: ../../library/importlib.rst:417
msgid "This method is no longer optional when :meth:`exec_module` is defined."
msgstr ""
"Denna metod är inte längre valfri när :meth:`exec_module` är definierad."

#: ../../library/importlib.rst:423
msgid ""
"An abstract method that executes the module in its own namespace when a "
"module is imported or reloaded.  The module should already be initialized "
"when :meth:`exec_module` is called.  When this method exists, "
":meth:`create_module` must be defined."
msgstr ""
"En abstrakt metod som exekverar modulen i dess eget namnrymd när en modul "
"importeras eller laddas om.  Modulen bör redan vara initialiserad när "
":meth:`exec_module` anropas.  När den här metoden finns måste "
":meth:`create_module` definieras."

#: ../../library/importlib.rst:430
msgid ":meth:`create_module` must also be defined."
msgstr ":meth:`create_module` måste också definieras."

#: ../../library/importlib.rst:435
msgid ""
"A legacy method for loading a module.  If the module cannot be loaded, "
":exc:`ImportError` is raised, otherwise the loaded module is returned."
msgstr ""
"En äldre metod för att ladda en modul.  Om modulen inte kan läsas in visas "
":exc:`ImportError`, annars returneras den inlästa modulen."

#: ../../library/importlib.rst:439
msgid ""
"If the requested module already exists in :data:`sys.modules`, that module "
"should be used and reloaded. Otherwise the loader should create a new module"
" and insert it into :data:`sys.modules` before any loading begins, to "
"prevent recursion from the import.  If the loader inserted a module and the "
"load fails, it must be removed by the loader from :data:`sys.modules`; "
"modules already in :data:`sys.modules` before the loader began execution "
"should be left alone (see :func:`importlib.util.module_for_loader`)."
msgstr ""

#: ../../library/importlib.rst:448
msgid ""
"The loader should set several attributes on the module (note that some of "
"these attributes can change when a module is reloaded):"
msgstr ""
"Laddaren ska ange flera attribut för modulen (observera att vissa av dessa "
"attribut kan ändras när en modul laddas om):"

#: ../../library/importlib.rst:454
msgid ":attr:`__name__`"
msgstr ""

#: ../../library/importlib.rst:453
msgid ""
"The module's fully qualified name. It is ``'__main__'`` for an executed "
"module."
msgstr ""

#: ../../library/importlib.rst:459
msgid ":attr:`__file__`"
msgstr ""

#: ../../library/importlib.rst:457
msgid ""
"The location the :term:`loader` used to load the module. For example, for "
"modules loaded from a .py file this is the filename. It is not set on all "
"modules (e.g. built-in modules)."
msgstr ""

#: ../../library/importlib.rst:463
msgid ":attr:`__cached__`"
msgstr ""

#: ../../library/importlib.rst:462
msgid ""
"The filename of a compiled version of the module's code. It is not set on "
"all modules (e.g. built-in modules)."
msgstr ""

#: ../../library/importlib.rst:471
msgid ":attr:`__path__`"
msgstr ""

#: ../../library/importlib.rst:466
msgid ""
"The list of locations where the package's submodules will be found. Most of "
"the time this is a single directory. The import system passes this attribute"
" to ``__import__()`` and to finders in the same way as :data:`sys.path` but "
"just for the package. It is not set on non-package modules so it can be used"
" as an indicator that the module is a package."
msgstr ""

#: ../../library/importlib.rst:476
msgid ":attr:`__package__`"
msgstr ""

#: ../../library/importlib.rst:474
msgid ""
"The fully qualified name of the package the module is in (or the empty "
"string for a top-level module). If the module is a package then this is the "
"same as :attr:`__name__`."
msgstr ""

#: ../../library/importlib.rst:479
msgid ":attr:`__loader__`"
msgstr ""

#: ../../library/importlib.rst:479
msgid "The :term:`loader` used to load the module."
msgstr ""

#: ../../library/importlib.rst:481
msgid ""
"When :meth:`exec_module` is available then backwards-compatible "
"functionality is provided."
msgstr ""
"När :meth:`exec_module` är tillgänglig tillhandahålls bakåtkompatibel "
"funktionalitet."

#: ../../library/importlib.rst:484
msgid ""
"Raise :exc:`ImportError` when called instead of :exc:`NotImplementedError`."
"  Functionality provided when :meth:`exec_module` is available."
msgstr ""
"Utlöser :exc:`ImportError` när den anropas istället för "
":exc:`NotImplementedError`.  Funktionalitet som tillhandahålls när "
":meth:`exec_module` är tillgänglig."

#: ../../library/importlib.rst:489
msgid ""
"The recommended API for loading a module is :meth:`exec_module` (and "
":meth:`create_module`).  Loaders should implement it instead of "
":meth:`load_module`.  The import machinery takes care of all the other "
"responsibilities of :meth:`load_module` when :meth:`exec_module` is "
"implemented."
msgstr ""
"Det rekommenderade API:et för att ladda en modul är :meth:`exec_module` (och"
" :meth:`create_module`).  Laddare bör implementera det istället för "
":meth:`load_module`.  Importmaskineriet tar hand om alla andra "
"ansvarsområden för :meth:`load_module` när :meth:`exec_module` är "
"implementerat."

#: ../../library/importlib.rst:498
msgid ""
"A legacy method which when implemented calculates and returns the given "
"module's representation, as a string.  The module type's default "
":meth:`__repr__` will use the result of this method as appropriate."
msgstr ""

#: ../../library/importlib.rst:504
msgid "Made optional instead of an abstractmethod."
msgstr ""

#: ../../library/importlib.rst:507
msgid "The import machinery now takes care of this automatically."
msgstr ""

#: ../../library/importlib.rst:513
msgid ""
"An abstract base class for a :term:`loader` which implements the optional "
":pep:`302` protocol for loading arbitrary resources from the storage back-"
"end."
msgstr ""
"En abstrakt basklass för en :term:`loader` som implementerar det valfria "
":pep:`302`\\-protokollet för laddning av godtyckliga resurser från "
"lagringsbackenden."

#: ../../library/importlib.rst:517
msgid ""
"This ABC is deprecated in favour of supporting resource loading through "
":class:`importlib.resources.abc.ResourceReader`."
msgstr ""

#: ../../library/importlib.rst:523
msgid ""
"An abstract method to return the bytes for the data located at *path*. "
"Loaders that have a file-like storage back-end that allows storing arbitrary"
" data can implement this abstract method to give direct access to the data "
"stored. :exc:`OSError` is to be raised if the *path* cannot be found. The "
"*path* is expected to be constructed using a module's :attr:`__file__` "
"attribute or an item from a package's :attr:`__path__`."
msgstr ""

#: ../../library/importlib.rst:531
msgid "Raises :exc:`OSError` instead of :exc:`NotImplementedError`."
msgstr "Utlöser :exc:`OSError` istället för :exc:`NotImplementedError`."

#: ../../library/importlib.rst:537
msgid ""
"An abstract base class for a :term:`loader` which implements the optional "
":pep:`302` protocol for loaders that inspect modules."
msgstr ""
"En abstrakt basklass för en :term:`loader` som implementerar det valfria "
":pep:`302`\\-protokollet för laddare som inspekterar moduler."

#: ../../library/importlib.rst:542
msgid ""
"Return the code object for a module, or ``None`` if the module does not have"
" a code object (as would be the case, for example, for a built-in module).  "
"Raise an :exc:`ImportError` if loader cannot find the requested module."
msgstr ""
"Returnerar kodobjektet för en modul, eller ``None`` om modulen inte har "
"något kodobjekt (vilket t.ex. skulle vara fallet för en inbyggd modul).  Ger"
" ett :exc:`ImportError` om laddaren inte kan hitta den begärda modulen."

#: ../../library/importlib.rst:548
msgid ""
"While the method has a default implementation, it is suggested that it be "
"overridden if possible for performance."
msgstr ""
"Metoden har en standardimplementering, men det rekommenderas att den "
"åsidosätts om det är möjligt av prestandaskäl."

#: ../../library/importlib.rst:554
msgid "No longer abstract and a concrete implementation is provided."
msgstr "Inte längre abstrakt och en konkret implementering tillhandahålls."

#: ../../library/importlib.rst:559
msgid ""
"An abstract method to return the source of a module. It is returned as a "
"text string using :term:`universal newlines`, translating all recognized "
"line separators into ``'\\n'`` characters.  Returns ``None`` if no source is"
" available (e.g. a built-in module). Raises :exc:`ImportError` if the loader"
" cannot find the module specified."
msgstr ""
"En abstrakt metod för att returnera källan till en modul. Den returneras som"
" en textsträng med :term:`universal newlines`, som översätter alla erkända "
"radavgränsare till ``'\\n'``\\-tecken.  Returnerar ``None`` om ingen källa "
"är tillgänglig (t.ex. en inbyggd modul). Utlöser :exc:`ImportError` om "
"laddaren inte kan hitta den angivna modulen."

#: ../../library/importlib.rst:565 ../../library/importlib.rst:574
#: ../../library/importlib.rst:624
msgid "Raises :exc:`ImportError` instead of :exc:`NotImplementedError`."
msgstr "Utlöser :exc:`ImportError` istället för :exc:`NotImplementedError`."

#: ../../library/importlib.rst:570
msgid ""
"An optional method to return a true value if the module is a package, a "
"false value otherwise. :exc:`ImportError` is raised if the :term:`loader` "
"cannot find the module."
msgstr ""
"En valfri metod som returnerar ett sant värde om modulen är ett paket, "
"annars ett falskt värde. :exc:`ImportError` uppstår om :term:`loader` inte "
"kan hitta modulen."

#: ../../library/importlib.rst:579
msgid "Create a code object from Python source."
msgstr "Skapa ett kodobjekt från Python-källan."

#: ../../library/importlib.rst:581
msgid ""
"The *data* argument can be whatever the :func:`compile` function supports "
"(i.e. string or bytes). The *path* argument should be the \"path\" to where "
"the source code originated from, which can be an abstract concept (e.g. "
"location in a zip file)."
msgstr ""
"Argumentet *data* kan vara vad som helst som :func:`compile`\\-funktionen "
"stöder (t.ex. sträng eller byte). Argumentet *path* bör vara \"sökvägen\" "
"till den plats där källkoden kommer ifrån, vilket kan vara ett abstrakt "
"koncept (t.ex. plats i en zip-fil)."

#: ../../library/importlib.rst:586
msgid ""
"With the subsequent code object one can execute it in a module by running "
"``exec(code, module.__dict__)``."
msgstr ""
"Med det efterföljande kodobjektet kan man exekvera det i en modul genom att "
"köra ``exec(code, module.__dict__)``."

#: ../../library/importlib.rst:591
msgid "Made the method static."
msgstr "Gjorde metoden statisk."

#: ../../library/importlib.rst:596
msgid "Implementation of :meth:`Loader.exec_module`."
msgstr "Implementering av :meth:`Loader.exec_module`."

#: ../../library/importlib.rst:602
msgid "Implementation of :meth:`Loader.load_module`."
msgstr "Implementering av :meth:`Loader.load_module`."

#: ../../library/importlib.rst:604
msgid "use :meth:`exec_module` instead."
msgstr "använd :meth:`exec_module` istället."

#: ../../library/importlib.rst:610
msgid ""
"An abstract base class which inherits from :class:`InspectLoader` that, when"
" implemented, helps a module to be executed as a script. The ABC represents "
"an optional :pep:`302` protocol."
msgstr ""
"En abstrakt basklass som ärver från :class:`InspectLoader` som, när den "
"implementeras, hjälper en modul att exekveras som ett skript. ABC "
"representerar ett valfritt :pep:`302` protokoll."

#: ../../library/importlib.rst:616
msgid ""
"An abstract method that is to return the value of :attr:`__file__` for the "
"specified module. If no path is available, :exc:`ImportError` is raised."
msgstr ""

#: ../../library/importlib.rst:620
msgid ""
"If source code is available, then the method should return the path to the "
"source file, regardless of whether a bytecode was used to load the module."
msgstr ""
"Om källkod finns tillgänglig ska metoden returnera sökvägen till källfilen, "
"oavsett om en bytecode användes för att ladda modulen."

#: ../../library/importlib.rst:630
msgid ""
"An abstract base class which inherits from :class:`ResourceLoader` and "
":class:`ExecutionLoader`, providing concrete implementations of "
":meth:`ResourceLoader.get_data` and :meth:`ExecutionLoader.get_filename`."
msgstr ""
"En abstrakt basklass som ärver från :class:`ResourceLoader` och "
":class:`ExecutionLoader` och ger konkreta implementationer av "
":meth:`ResourceLoader.get_data` och :meth:`ExecutionLoader.get_filename`."

#: ../../library/importlib.rst:634
msgid ""
"The *fullname* argument is a fully resolved name of the module the loader is"
" to handle. The *path* argument is the path to the file for the module."
msgstr ""
"Argumentet *fullname* är ett fullständigt upplöst namn på den modul som "
"laddaren ska hantera. Argumentet *path* är sökvägen till filen för modulen."

#: ../../library/importlib.rst:641
msgid "The name of the module the loader can handle."
msgstr "Namnet på den modul som laddaren kan hantera."

#: ../../library/importlib.rst:645
msgid "Path to the file of the module."
msgstr "Sökväg till filen för modulen."

#: ../../library/importlib.rst:649
msgid "Calls super's ``load_module()``."
msgstr "Anropar super's ``load_module()``."

#: ../../library/importlib.rst:651
msgid "Use :meth:`Loader.exec_module` instead."
msgstr "Använd :meth:`Loader.exec_module` istället."

#: ../../library/importlib.rst:656 ../../library/importlib.rst:1104
msgid "Returns :attr:`path`."
msgstr "Returnerar :attr:`path`."

#: ../../library/importlib.rst:660
msgid "Reads *path* as a binary file and returns the bytes from it."
msgstr "Läser *sökväg* som en binär fil och returnerar byte från den."

#: ../../library/importlib.rst:665
msgid ""
"An abstract base class for implementing source (and optionally bytecode) "
"file loading. The class inherits from both :class:`ResourceLoader` and "
":class:`ExecutionLoader`, requiring the implementation of:"
msgstr ""
"En abstrakt basklass för att implementera laddning av källfiler (och "
"eventuellt bytekoder). Klassen ärver från både :class:`ResourceLoader` och "
":class:`ExecutionLoader`, och kräver implementering av:"

#: ../../library/importlib.rst:669
msgid ":meth:`ResourceLoader.get_data`"
msgstr ":meth:`ResourceLoader.get_data`"

#: ../../library/importlib.rst:672
msgid ":meth:`ExecutionLoader.get_filename`"
msgstr ":meth:`ExecutionLoader.get_filename`"

#: ../../library/importlib.rst:671
msgid ""
"Should only return the path to the source file; sourceless loading is not "
"supported."
msgstr ""
"Ska endast returnera sökvägen till källfilen; laddning utan källa stöds "
"inte."

#: ../../library/importlib.rst:674
msgid ""
"The abstract methods defined by this class are to add optional bytecode file"
" support. Not implementing these optional methods (or causing them to raise "
":exc:`NotImplementedError`) causes the loader to only work with source code."
" Implementing the methods allows the loader to work with source *and* "
"bytecode files; it does not allow for *sourceless* loading where only "
"bytecode is provided.  Bytecode files are an optimization to speed up "
"loading by removing the parsing step of Python's compiler, and so no "
"bytecode-specific API is exposed."
msgstr ""
"De abstrakta metoder som definieras av denna klass är till för att lägga "
"till valfritt stöd för bytecode-filer. Om dessa valfria metoder inte "
"implementeras (eller om de ger upphov till :exc:`NotImplementedError`) "
"fungerar laddaren endast med källkod. Genom att implementera metoderna kan "
"laddaren arbeta med källkods- *och* bytecode-filer; det tillåter inte "
"*källkodslös* laddning där endast bytecode tillhandahålls.  Bytecode-filer "
"är en optimering för att påskynda laddningen genom att ta bort "
"parsningssteget i Pythons kompilator, och därför exponeras inget bytecode-"
"specifikt API."

#: ../../library/importlib.rst:685
msgid ""
"Optional abstract method which returns a :class:`dict` containing metadata "
"about the specified path.  Supported dictionary keys are:"
msgstr ""
"Valfri abstrakt metod som returnerar en :class:`dict` som innehåller "
"metadata om den angivna sökvägen.  Nycklar i ordlistan som stöds är:"

#: ../../library/importlib.rst:688
msgid ""
"``'mtime'`` (mandatory): an integer or floating-point number representing "
"the modification time of the source code;"
msgstr ""
"``'mtime'`` (mandatory): ett heltal eller flyttal som anger "
"modifieringstiden för källkoden;"

#: ../../library/importlib.rst:690
msgid "``'size'`` (optional): the size in bytes of the source code."
msgstr "``'size'`` (valfritt): storleken i bytes på källkoden."

#: ../../library/importlib.rst:692
msgid ""
"Any other keys in the dictionary are ignored, to allow for future "
"extensions. If the path cannot be handled, :exc:`OSError` is raised."
msgstr ""
"Alla andra nycklar i ordlistan ignoreras för att möjliggöra framtida "
"tillägg. Om sökvägen inte kan hanteras genereras :exc:`OSError`."

#: ../../library/importlib.rst:697 ../../library/importlib.rst:710
msgid "Raise :exc:`OSError` instead of :exc:`NotImplementedError`."
msgstr "Utlös :exc:`OSError` istället för :exc:`NotImplementedError`."

#: ../../library/importlib.rst:702
msgid ""
"Optional abstract method which returns the modification time for the "
"specified path."
msgstr ""
"Valfri abstrakt metod som returnerar modifieringstiden för den angivna "
"sökvägen."

#: ../../library/importlib.rst:705
msgid ""
"This method is deprecated in favour of :meth:`path_stats`.  You don't have "
"to implement it, but it is still available for compatibility purposes. Raise"
" :exc:`OSError` if the path cannot be handled."
msgstr ""
"Den här metoden är utfasad till förmån för :meth:`path_stats`.  Du behöver "
"inte implementera den, men den är fortfarande tillgänglig för "
"kompatibilitetsändamål. Utlöser :exc:`OSError` om sökvägen inte kan "
"hanteras."

#: ../../library/importlib.rst:715
msgid ""
"Optional abstract method which writes the specified bytes to a file path. "
"Any intermediate directories which do not exist are to be created "
"automatically."
msgstr ""
"Valfri abstrakt metod som skriver de angivna bytena till en filsökväg. "
"Eventuella mellanliggande kataloger som inte finns ska skapas automatiskt."

#: ../../library/importlib.rst:719
msgid ""
"When writing to the path fails because the path is read-only "
"(:const:`errno.EACCES`/:exc:`PermissionError`), do not propagate the "
"exception."
msgstr ""
"Om det inte går att skriva till sökvägen eftersom sökvägen är skrivskyddad "
"(:const:`errno.EACCES`/:exc:`PermissionError`), ska undantaget inte spridas."

#: ../../library/importlib.rst:723
msgid "No longer raises :exc:`NotImplementedError` when called."
msgstr ""
"Ger inte längre upphov till :exc:`NotImplementedError` när den anropas."

#: ../../library/importlib.rst:728
msgid "Concrete implementation of :meth:`InspectLoader.get_code`."
msgstr "Konkret implementation av :meth:`InspectLoader.get_code`."

#: ../../library/importlib.rst:732
msgid "Concrete implementation of :meth:`Loader.exec_module`."
msgstr "Konkret implementering av :meth:`Loader.exec_module`."

#: ../../library/importlib.rst:738
msgid "Concrete implementation of :meth:`Loader.load_module`."
msgstr "Konkret implementation av :meth:`Loader.load_module`."

#: ../../library/importlib.rst:740
msgid "Use :meth:`exec_module` instead."
msgstr "Använd :meth:`exec_module` istället."

#: ../../library/importlib.rst:745
msgid "Concrete implementation of :meth:`InspectLoader.get_source`."
msgstr "Konkret implementation av :meth:`InspectLoader.get_source`."

#: ../../library/importlib.rst:749
msgid ""
"Concrete implementation of :meth:`InspectLoader.is_package`. A module is "
"determined to be a package if its file path (as provided by "
":meth:`ExecutionLoader.get_filename`) is a file named ``__init__`` when the "
"file extension is removed **and** the module name itself does not end in "
"``__init__``."
msgstr ""
"Konkret implementation av :meth:`InspectLoader.is_package`. En modul anses "
"vara ett paket om dess filsökväg (som tillhandahålls av "
":meth:`ExecutionLoader.get_filename`) är en fil med namnet ``__init__`` när "
"filtillägget är borttaget **och** modulnamnet i sig inte slutar på "
"``__init__``."

#: ../../library/importlib.rst:758
msgid ":mod:`importlib.machinery` -- Importers and path hooks"
msgstr ":mod:`importlib.machinery` -- Importörer och sökvägs-hooks"

#: ../../library/importlib.rst:763
msgid "**Source code:** :source:`Lib/importlib/machinery.py`"
msgstr "**Källkod:** :source:`Lib/importlib/machinery.py`"

#: ../../library/importlib.rst:767
msgid ""
"This module contains the various objects that help :keyword:`import` find "
"and load modules."
msgstr ""
"Denna modul innehåller de olika objekt som hjälper :keyword:`import` att "
"hitta och ladda moduler."

#: ../../library/importlib.rst:772
msgid ""
"A list of strings representing the recognized file suffixes for source "
"modules."
msgstr ""
"En lista med strängar som representerar de identifierade filsuffixen för "
"källmoduler."

#: ../../library/importlib.rst:779
msgid ""
"A list of strings representing the file suffixes for non-optimized bytecode "
"modules."
msgstr ""
"En lista med strängar som representerar filsuffixen för icke-optimerade "
"bytekodsmoduler."

#: ../../library/importlib.rst:784 ../../library/importlib.rst:794
msgid "Use :attr:`BYTECODE_SUFFIXES` instead."
msgstr ""

#: ../../library/importlib.rst:789
msgid ""
"A list of strings representing the file suffixes for optimized bytecode "
"modules."
msgstr ""
"En lista med strängar som representerar filsuffixen för optimerade bytecode-"
"moduler."

#: ../../library/importlib.rst:799
msgid ""
"A list of strings representing the recognized file suffixes for bytecode "
"modules (including the leading dot)."
msgstr ""
"En lista med strängar som representerar de erkända filsuffixen för bytecode-"
"moduler (inklusive den inledande punkten)."

#: ../../library/importlib.rst:804
msgid "The value is no longer dependent on ``__debug__``."
msgstr "Värdet är inte längre beroende av ``__debug__``."

#: ../../library/importlib.rst:809
msgid ""
"A list of strings representing the recognized file suffixes for extension "
"modules."
msgstr ""
"En lista med strängar som representerar de identifierade filsuffixen för "
"tilläggsmoduler."

#: ../../library/importlib.rst:816
msgid ""
"Returns a combined list of strings representing all file suffixes for "
"modules recognized by the standard import machinery. This is a helper for "
"code which simply needs to know if a filesystem path potentially refers to a"
" module without needing any details on the kind of module (for example, "
":func:`inspect.getmodulename`)."
msgstr ""
"Returnerar en kombinerad lista med strängar som representerar alla filsuffix"
" för moduler som känns igen av standardimportmaskineriet. Detta är ett "
"hjälpmedel för kod som helt enkelt behöver veta om en filsystemssökväg "
"potentiellt hänvisar till en modul utan att behöva några detaljer om typen "
"av modul (till exempel :func:`inspect.getmodulename`)."

#: ../../library/importlib.rst:827
msgid ""
"An :term:`importer` for built-in modules. All known built-in modules are "
"listed in :data:`sys.builtin_module_names`. This class implements the "
":class:`importlib.abc.MetaPathFinder` and "
":class:`importlib.abc.InspectLoader` ABCs."
msgstr ""
"En :term:`importer` för inbyggda moduler. Alla kända inbyggda moduler finns "
"listade i :data:`sys.builtin_module_names`. Den här klassen implementerar "
"ABC:erna :class:`importlib.abc.MetaPathFinder` och "
":class:`importlib.abc.InspectLoader`."

#: ../../library/importlib.rst:832 ../../library/importlib.rst:846
#: ../../library/importlib.rst:859 ../../library/importlib.rst:874
msgid ""
"Only class methods are defined by this class to alleviate the need for "
"instantiation."
msgstr ""
"Endast klassens metoder definieras av denna klass för att minska behovet av "
"instansiering."

#: ../../library/importlib.rst:835
msgid ""
"As part of :pep:`489`, the builtin importer now implements "
":meth:`Loader.create_module` and :meth:`Loader.exec_module`"
msgstr ""
"Som en del av :pep:`489` implementerar den inbyggda importören nu "
":meth:`Loader.create_module` och :meth:`Loader.exec_module`"

#: ../../library/importlib.rst:842
msgid ""
"An :term:`importer` for frozen modules. This class implements the "
":class:`importlib.abc.MetaPathFinder` and "
":class:`importlib.abc.InspectLoader` ABCs."
msgstr ""
"En :term:`importer` för frysta moduler. Denna klass implementerar ABC:erna "
":class:`importlib.abc.MetaPathFinder` och "
":class:`importlib.abc.InspectLoader`."

#: ../../library/importlib.rst:849
msgid ""
"Gained :meth:`~Loader.create_module` and :meth:`~Loader.exec_module` "
"methods."
msgstr ""
"Fått metoderna :meth:`~Loader.create_module` och "
":meth:`~Loader.exec_module`."

#: ../../library/importlib.rst:856
msgid ""
":term:`Finder <finder>` for modules declared in the Windows registry.  This "
"class implements the :class:`importlib.abc.MetaPathFinder` ABC."
msgstr ""
":term:`Finder <finder>` för moduler som deklareras i Windows-registret.  Den"
" här klassen implementerar :class:`importlib.abc.MetaPathFinder` ABC."

#: ../../library/importlib.rst:864
msgid ""
"Use :mod:`site` configuration instead. Future versions of Python may not "
"enable this finder by default."
msgstr ""
"Använd :mod:`site`\\-konfigurationen istället. Framtida versioner av Python "
"kanske inte aktiverar den här sökaren som standard."

#: ../../library/importlib.rst:871
msgid ""
"A :term:`Finder <finder>` for :data:`sys.path` and package ``__path__`` "
"attributes. This class implements the :class:`importlib.abc.MetaPathFinder` "
"ABC."
msgstr ""
"En :term:`Finder <finder>` för :data:`sys.path` och paketets ``__path__`` "
"attribut. Den här klassen implementerar "
":class:`importlib.abc.MetaPathFinder` ABC."

#: ../../library/importlib.rst:879
msgid ""
"Class method that attempts to find a :term:`spec <module spec>` for the "
"module specified by *fullname* on :data:`sys.path` or, if defined, on "
"*path*. For each path entry that is searched, "
":data:`sys.path_importer_cache` is checked. If a non-false object is found "
"then it is used as the :term:`path entry finder` to look for the module "
"being searched for. If no entry is found in :data:`sys.path_importer_cache`,"
" then :data:`sys.path_hooks` is searched for a finder for the path entry "
"and, if found, is stored in :data:`sys.path_importer_cache` along with being"
" queried about the module. If no finder is ever found then ``None`` is both "
"stored in the cache and returned."
msgstr ""
"Klassmetod som försöker hitta en :term:`spec <module spec>` för den modul "
"som anges av *fullname* på :data:`sys.path` eller, om definierad, på *path*."
" För varje sökvägspost som genomsöks kontrolleras "
":data:`sys.path_importer_cache`. Om ett icke-falskt objekt hittas används "
"det som :term:`path entry finder` för att leta efter den modul som söks. Om "
"ingen post hittas i :data:`sys.path_importer_cache`, söks i "
":data:`sys.path_hooks` efter en sökare för sökvägsposten och, om den hittas,"
" lagras den i :data:`sys.path_importer_cache` tillsammans med en fråga om "
"modulen. Om ingen sökare någonsin hittas lagras ``None`` i cachen och "
"returneras."

#: ../../library/importlib.rst:893
msgid ""
"If the current working directory -- represented by an empty string -- is no "
"longer valid then ``None`` is returned but no value is cached in "
":data:`sys.path_importer_cache`."
msgstr ""
"Om den aktuella arbetskatalogen - representerad av en tom sträng - inte "
"längre är giltig returneras ``None`` men inget värde cachas i "
":data:`sys.path_importer_cache`."

#: ../../library/importlib.rst:900
msgid "A legacy wrapper around :meth:`find_spec`."
msgstr ""

#: ../../library/importlib.rst:907
msgid ""
"Calls :meth:`importlib.abc.PathEntryFinder.invalidate_caches` on all finders"
" stored in :data:`sys.path_importer_cache` that define the method. Otherwise"
" entries in :data:`sys.path_importer_cache` set to ``None`` are deleted."
msgstr ""
"Anropar :meth:`importlib.abc.PathEntryFinder.invalidate_caches` på alla "
"sökare som lagras i :data:`sys.path_importer_cache` som definierar metoden. "
"Annars raderas poster i :data:`sys.path_importer_cache` som är inställda på "
"``None``."

#: ../../library/importlib.rst:912
msgid "Entries of ``None`` in :data:`sys.path_importer_cache` are deleted."
msgstr "Poster med ``None`` i :data:`sys.path_importer_cache` tas bort."

#: ../../library/importlib.rst:915
msgid ""
"Calls objects in :data:`sys.path_hooks` with the current working directory "
"for ``''`` (i.e. the empty string)."
msgstr ""
"Anropar objekt i :data:`sys.path_hooks` med den aktuella arbetskatalogen för"
" ``''`` (d.v.s. den tomma strängen)."

#: ../../library/importlib.rst:922
msgid ""
"A concrete implementation of :class:`importlib.abc.PathEntryFinder` which "
"caches results from the file system."
msgstr ""
"En konkret implementation av :class:`importlib.abc.PathEntryFinder` som "
"cachar resultat från filsystemet."

#: ../../library/importlib.rst:925
msgid ""
"The *path* argument is the directory for which the finder is in charge of "
"searching."
msgstr "Argumentet *path* är den katalog som sökaren ska söka i."

#: ../../library/importlib.rst:928
msgid ""
"The *loader_details* argument is a variable number of 2-item tuples each "
"containing a loader and a sequence of file suffixes the loader recognizes. "
"The loaders are expected to be callables which accept two arguments of the "
"module's name and the path to the file found."
msgstr ""
"Argumentet *loader_details* är ett variabelt antal tuples med två objekt som"
" var och en innehåller en laddare och en sekvens av filsuffix som laddaren "
"känner igen. Laddarna förväntas vara callables som accepterar två argument, "
"modulens namn och sökvägen till den fil som hittas."

#: ../../library/importlib.rst:933
msgid ""
"The finder will cache the directory contents as necessary, making stat calls"
" for each module search to verify the cache is not outdated. Because cache "
"staleness relies upon the granularity of the operating system's state "
"information of the file system, there is a potential race condition of "
"searching for a module, creating a new file, and then searching for the "
"module the new file represents. If the operations happen fast enough to fit "
"within the granularity of stat calls, then the module search will fail. To "
"prevent this from happening, when you create a module dynamically, make sure"
" to call :func:`importlib.invalidate_caches`."
msgstr ""
"Sökaren cachelagrar kataloginnehållet efter behov och gör stat-anrop för "
"varje modulsökning för att kontrollera att cacheminnet inte är föråldrat. "
"Eftersom cache-stalkeness är beroende av granulariteten i operativsystemets "
"statusinformation om filsystemet, finns det ett potentiellt "
"tävlingsförhållande där man söker efter en modul, skapar en ny fil och sedan"
" söker efter den modul som den nya filen representerar. Om operationerna "
"sker tillräckligt snabbt för att rymmas inom granulariteten för stat-anrop, "
"kommer modulsökningen att misslyckas. För att förhindra att detta händer, "
"när du skapar en modul dynamiskt, se till att anropa "
":func:`importlib.invalidate_caches`."

#: ../../library/importlib.rst:947
msgid "The path the finder will search in."
msgstr "Den väg som sökaren kommer att söka i."

#: ../../library/importlib.rst:951
msgid "Attempt to find the spec to handle *fullname* within :attr:`path`."
msgstr ""
"Försök att hitta specifikationen för att hantera *fullname* inom "
":attr:`path`."

#: ../../library/importlib.rst:957
msgid "Attempt to find the loader to handle *fullname* within :attr:`path`."
msgstr ""

#: ../../library/importlib.rst:964
msgid "Clear out the internal cache."
msgstr "Rensa ut den interna cachen."

#: ../../library/importlib.rst:968
msgid ""
"A class method which returns a closure for use on :data:`sys.path_hooks`. An"
" instance of :class:`FileFinder` is returned by the closure using the path "
"argument given to the closure directly and *loader_details* indirectly."
msgstr ""
"En klassmetod som returnerar en closure för användning på "
":data:`sys.path_hooks`. En instans av :class:`FileFinder` returneras av "
"stängningen med hjälp av sökvägsargumentet som ges till stängningen direkt "
"och *loader_details* indirekt."

#: ../../library/importlib.rst:973
msgid ""
"If the argument to the closure is not an existing directory, "
":exc:`ImportError` is raised."
msgstr ""
"Om argumentet till stängningen inte är en befintlig katalog kommer "
":exc:`ImportError` att tas upp."

#: ../../library/importlib.rst:979
msgid ""
"A concrete implementation of :class:`importlib.abc.SourceLoader` by "
"subclassing :class:`importlib.abc.FileLoader` and providing some concrete "
"implementations of other methods."
msgstr ""
"En konkret implementation av :class:`importlib.abc.SourceLoader` genom att "
"underklassa :class:`importlib.abc.FileLoader` och tillhandahålla några "
"konkreta implementationer av andra metoder."

#: ../../library/importlib.rst:987
msgid "The name of the module that this loader will handle."
msgstr "Namnet på den modul som den här laddaren ska hantera."

#: ../../library/importlib.rst:991
msgid "The path to the source file."
msgstr "Sökvägen till källfilen."

#: ../../library/importlib.rst:995
msgid "Return ``True`` if :attr:`path` appears to be for a package."
msgstr "Returnerar ``True`` om :attr:`path` verkar vara för ett paket."

#: ../../library/importlib.rst:999
msgid ""
"Concrete implementation of :meth:`importlib.abc.SourceLoader.path_stats`."
msgstr ""
"Konkret implementering av :meth:`importlib.abc.SourceLoader.path_stats`."

#: ../../library/importlib.rst:1003
msgid ""
"Concrete implementation of :meth:`importlib.abc.SourceLoader.set_data`."
msgstr ""
"Konkret implementation av :meth:`importlib.abc.SourceLoader.set_data`."

#: ../../library/importlib.rst:1007 ../../library/importlib.rst:1050
msgid ""
"Concrete implementation of :meth:`importlib.abc.Loader.load_module` where "
"specifying the name of the module to load is optional."
msgstr ""
"Konkret implementation av :meth:`importlib.abc.Loader.load_module` där det "
"är valfritt att ange namnet på den modul som ska laddas."

#: ../../library/importlib.rst:1012 ../../library/importlib.rst:1055
msgid "Use :meth:`importlib.abc.Loader.exec_module` instead."
msgstr "Använd :meth:`importlib.abc.Loader.exec_module` istället."

#: ../../library/importlib.rst:1017
msgid ""
"A concrete implementation of :class:`importlib.abc.FileLoader` which can "
"import bytecode files (i.e. no source code files exist)."
msgstr ""
"En konkret implementation av :class:`importlib.abc.FileLoader` som kan "
"importera bytecode-filer (dvs. inga källkodsfiler existerar)."

#: ../../library/importlib.rst:1020
msgid ""
"Please note that direct use of bytecode files (and thus not source code "
"files) inhibits your modules from being usable by all Python implementations"
" or new versions of Python which change the bytecode format."
msgstr ""
"Observera att direkt användning av bytecode-filer (och därmed inte "
"källkodsfiler) hindrar dina moduler från att kunna användas av alla Python-"
"implementationer eller nya versioner av Python som ändrar bytecode-formatet."

#: ../../library/importlib.rst:1029
msgid "The name of the module the loader will handle."
msgstr "Namnet på den modul som laddaren ska hantera."

#: ../../library/importlib.rst:1033
msgid "The path to the bytecode file."
msgstr "Sökvägen till bytekodfilen."

#: ../../library/importlib.rst:1037
msgid "Determines if the module is a package based on :attr:`path`."
msgstr "Avgör om modulen är ett paket baserat på :attr:`path`."

#: ../../library/importlib.rst:1041
msgid "Returns the code object for :attr:`name` created from :attr:`path`."
msgstr ""
"Returnerar kodobjektet för :attr:`name` som skapats från :attr:`path`."

#: ../../library/importlib.rst:1045
msgid ""
"Returns ``None`` as bytecode files have no source when this loader is used."
msgstr ""
"Returnerar ``None`` eftersom bytecode-filer inte har någon källa när denna "
"laddare används."

#: ../../library/importlib.rst:1060
msgid ""
"A concrete implementation of :class:`importlib.abc.ExecutionLoader` for "
"extension modules."
msgstr ""
"En konkret implementation av :class:`importlib.abc.ExecutionLoader` för "
"tilläggsmoduler."

#: ../../library/importlib.rst:1063
msgid ""
"The *fullname* argument specifies the name of the module the loader is to "
"support. The *path* argument is the path to the extension module's file."
msgstr ""
"Argumentet *fullname* anger namnet på den modul som laddaren ska stödja. "
"Argumentet *path* är sökvägen till filen för tilläggsmodulen."

#: ../../library/importlib.rst:1070
msgid "Name of the module the loader supports."
msgstr "Namnet på den modul som laddaren stöder."

#: ../../library/importlib.rst:1074
msgid "Path to the extension module."
msgstr "Sökväg till tilläggsmodulen."

#: ../../library/importlib.rst:1078
msgid ""
"Creates the module object from the given specification in accordance with "
":pep:`489`."
msgstr ""
"Skapar modulobjektet från den givna specifikationen i enlighet med "
":pep:`489`."

#: ../../library/importlib.rst:1085
msgid "Initializes the given module object in accordance with :pep:`489`."
msgstr "Initialiserar det givna modulobjektet i enlighet med :pep:`489`."

#: ../../library/importlib.rst:1091
msgid ""
"Returns ``True`` if the file path points to a package's ``__init__`` module "
"based on :attr:`EXTENSION_SUFFIXES`."
msgstr ""

#: ../../library/importlib.rst:1096
msgid "Returns ``None`` as extension modules lack a code object."
msgstr "Returnerar ``None`` eftersom tilläggsmoduler saknar ett kodobjekt."

#: ../../library/importlib.rst:1100
msgid "Returns ``None`` as extension modules do not have source code."
msgstr "Returnerar ``None`` eftersom tilläggsmoduler inte har någon källkod."

#: ../../library/importlib.rst:1111
msgid ""
"A concrete implementation of :class:`importlib.abc.InspectLoader` for "
"namespace packages.  This is an alias for a private class and is only made "
"public for introspecting the ``__loader__`` attribute on namespace "
"packages::"
msgstr ""
"En konkret implementation av :class:`importlib.abc.InspectLoader` för "
"namespace-paket.  Detta är ett alias för en privat klass och görs endast "
"offentlig för introspektion av ``__loader__``\\-attributet på namespace-"
"paket::"

#: ../../library/importlib.rst:1129
msgid ""
"A specification for a module's import-system-related state.  This is "
"typically exposed as the module's :attr:`__spec__` attribute.  In the "
"descriptions below, the names in parentheses give the corresponding "
"attribute available directly on the module object, e.g. "
"``module.__spec__.origin == module.__file__``.  Note, however, that while "
"the *values* are usually equivalent, they can differ since there is no "
"synchronization between the two objects.  For example, it is possible to "
"update the module's :attr:`__file__` at runtime and this will not be "
"automatically reflected in the module's :attr:`__spec__.origin`, and vice "
"versa."
msgstr ""

#: ../../library/importlib.rst:1143
msgid "(:attr:`__name__`)"
msgstr ""

#: ../../library/importlib.rst:1145
msgid ""
"The module's fully qualified name. The :term:`finder` should always set this"
" attribute to a non-empty string."
msgstr ""

#: ../../library/importlib.rst:1150
msgid "(:attr:`__loader__`)"
msgstr ""

#: ../../library/importlib.rst:1152
msgid ""
"The :term:`loader` used to load the module. The :term:`finder` should always"
" set this attribute."
msgstr ""

#: ../../library/importlib.rst:1157
msgid "(:attr:`__file__`)"
msgstr ""

#: ../../library/importlib.rst:1159
msgid ""
"The location the :term:`loader` should use to load the module. For example, "
"for modules loaded from a .py file this is the filename. The :term:`finder` "
"should always set this attribute to a meaningful value for the "
":term:`loader` to use.  In the uncommon case that there is not one (like for"
" namespace packages), it should be set to ``None``."
msgstr ""

#: ../../library/importlib.rst:1167
msgid "(:attr:`__path__`)"
msgstr ""

#: ../../library/importlib.rst:1169
msgid ""
"The list of locations where the package's submodules will be found. Most of "
"the time this is a single directory. The :term:`finder` should set this "
"attribute to a list, even an empty one, to indicate to the import system "
"that the module is a package.  It should be set to ``None`` for non-package "
"modules.  It is set automatically later to a special object for namespace "
"packages."
msgstr ""

#: ../../library/importlib.rst:1178
msgid ""
"The :term:`finder` may set this attribute to an object containing "
"additional, module-specific data to use when loading the module.  Otherwise "
"it should be set to ``None``."
msgstr ""
":term:`finder` kan sätta detta attribut till ett objekt som innehåller "
"ytterligare modulspecifika data att använda vid laddning av modulen.  Annars"
" bör det sättas till ``None``."

#: ../../library/importlib.rst:1184
msgid "(:attr:`__cached__`)"
msgstr ""

#: ../../library/importlib.rst:1186
msgid ""
"The filename of a compiled version of the module's code. The :term:`finder` "
"should always set this attribute but it may be ``None`` for modules that do "
"not need compiled code stored."
msgstr ""

#: ../../library/importlib.rst:1192
msgid "(:attr:`__package__`)"
msgstr ""

#: ../../library/importlib.rst:1194
msgid ""
"(Read-only) The fully qualified name of the package the module is in (or the"
" empty string for a top-level module). If the module is a package then this "
"is the same as :attr:`name`."
msgstr ""

#: ../../library/importlib.rst:1201
msgid "``True`` if the spec's :attr:`origin` refers to a loadable location,"
msgstr ""

#: ../../library/importlib.rst:1201
msgid ""
"``False`` otherwise.  This value impacts how :attr:`origin` is interpreted "
"and how the module's :attr:`__file__` is populated."
msgstr ""

#: ../../library/importlib.rst:1206
msgid ":mod:`importlib.util` -- Utility code for importers"
msgstr ":mod:`importlib.util` -- Verktygskod för importörer"

#: ../../library/importlib.rst:1212
msgid "**Source code:** :source:`Lib/importlib/util.py`"
msgstr "**Källkod:** :source:`Lib/importlib/util.py`"

#: ../../library/importlib.rst:1216
msgid ""
"This module contains the various objects that help in the construction of an"
" :term:`importer`."
msgstr ""
"Denna modul innehåller de olika objekt som hjälper till vid konstruktionen "
"av en :term:`importer`."

#: ../../library/importlib.rst:1221
msgid ""
"The bytes which represent the bytecode version number. If you need help with"
" loading/writing bytecode then consider :class:`importlib.abc.SourceLoader`."
msgstr ""
"Byte som representerar bytekodens versionsnummer. Om du behöver hjälp med "
"att ladda/skriva bytecode kan du överväga "
":class:`importlib.abc.SourceLoader`."

#: ../../library/importlib.rst:1228
msgid ""
"Return the :pep:`3147`/:pep:`488` path to the byte-compiled file associated "
"with the source *path*.  For example, if *path* is ``/foo/bar/baz.py`` the "
"return value would be ``/foo/bar/__pycache__/baz.cpython-32.pyc`` for Python"
" 3.2. The ``cpython-32`` string comes from the current magic tag (see "
":func:`get_tag`; if :attr:`sys.implementation.cache_tag` is not defined then"
" :exc:`NotImplementedError` will be raised)."
msgstr ""
"Returnerar :pep:`3147`/:pep:`488` sökvägen till den bytekompilerade filen "
"som är associerad med källan *path*.  Till exempel, om *väg* är "
"``/foo/bar/baz.py`` skulle returvärdet vara "
"``/foo/bar/__pycache__/baz.cpython-32.pyc`` för Python 3.2. Strängen "
"``cpython-32`` kommer från den aktuella magiska taggen (se :func:`get_tag`; "
"om :attr:`sys.implementation.cache_tag` inte är definierad kommer "
":exc:`NotImplementedError`` att anges)."

#: ../../library/importlib.rst:1235
msgid ""
"The *optimization* parameter is used to specify the optimization level of "
"the bytecode file. An empty string represents no optimization, so "
"``/foo/bar/baz.py`` with an *optimization* of ``''`` will result in a "
"bytecode path of ``/foo/bar/__pycache__/baz.cpython-32.pyc``. ``None`` "
"causes the interpreter's optimization level to be used. Any other value's "
"string representation is used, so ``/foo/bar/baz.py`` with an *optimization*"
" of ``2`` will lead to the bytecode path of "
"``/foo/bar/__pycache__/baz.cpython-32.opt-2.pyc``. The string representation"
" of *optimization* can only be alphanumeric, else :exc:`ValueError` is "
"raised."
msgstr ""
"Parametern *optimization* används för att ange optimeringsnivån för "
"bytecode-filen. En tom sträng representerar ingen optimering, så "
"``/foo/bar/baz.py`` med en *optimering* på ``''`` kommer att resultera i en "
"bytekodssökväg på ``/foo/bar/__pycache__/baz.cpython-32.pyc``. ``None`` gör "
"att tolkens optimeringsnivå används. Alla andra värdens strängrepresentation"
" används, så ``/foo/bar/baz.py`` med en *optimering* på ``2`` kommer att "
"leda till bytekodssökvägen "
"``/foo/bar/__pycache__/baz.cpython-32.opt-2.pyc``. Strängrepresentationen av"
" *optimering* kan endast vara alfanumerisk, annars uppstår "
":exc:`ValueError`."

#: ../../library/importlib.rst:1245
msgid ""
"The *debug_override* parameter is deprecated and can be used to override the"
" system's value for ``__debug__``. A ``True`` value is the equivalent of "
"setting *optimization* to the empty string. A ``False`` value is the same as"
" setting *optimization* to ``1``. If both *debug_override* an *optimization*"
" are not ``None`` then :exc:`TypeError` is raised."
msgstr ""
"Parametern *debug_override* är föråldrad och kan användas för att åsidosätta"
" systemets värde för ``__debug__``. Värdet ``True`` motsvarar inställningen "
"av *optimization* till den tomma strängen. Ett värde på ``False`` är "
"detsamma som att sätta *optimization* till ``1``. Om både *debug_override* "
"och *optimization* inte är ``None`` så genereras :exc:`TypeError`."

#: ../../library/importlib.rst:1253
msgid ""
"The *optimization* parameter was added and the *debug_override* parameter "
"was deprecated."
msgstr ""
"Parametern *optimization* har lagts till och parametern *debug_override* har"
" tagits bort."

#: ../../library/importlib.rst:1257 ../../library/importlib.rst:1273
#: ../../library/importlib.rst:1423
msgid "Accepts a :term:`path-like object`."
msgstr "Accepterar en :term:`path-like object`."

#: ../../library/importlib.rst:1263
msgid ""
"Given the *path* to a :pep:`3147` file name, return the associated source "
"code file path.  For example, if *path* is "
"``/foo/bar/__pycache__/baz.cpython-32.pyc`` the returned path would be "
"``/foo/bar/baz.py``.  *path* need not exist, however if it does not conform "
"to :pep:`3147` or :pep:`488` format, a :exc:`ValueError` is raised. If "
":attr:`sys.implementation.cache_tag` is not defined, "
":exc:`NotImplementedError` is raised."
msgstr ""
"Givet *sökvägen* till ett :pep:`3147`\\-filnamn, returnera den associerade "
"källkodsfilsökvägen.  Till exempel, om *sökväg* är "
"``/foo/bar/__pycache__/baz.cpython-32.pyc`` skulle den returnerade sökvägen "
"vara ``/foo/bar/baz.py``.  *path* behöver inte existera, men om den inte "
"överensstämmer med :pep:`3147` eller :pep:`488` format, kommer ett "
":exc:`ValueError` att uppstå. Om :attr:`sys.implementation.cache_tag` inte "
"är definierad, genereras :exc:`NotImplementedError`."

#: ../../library/importlib.rst:1278
msgid ""
"Decode the given bytes representing source code and return it as a string "
"with universal newlines (as required by "
":meth:`importlib.abc.InspectLoader.get_source`)."
msgstr ""
"Avkodar de angivna byte som representerar källkod och returnerar den som en "
"sträng med universella nya linjer (enligt "
":meth:`importlib.abc.InspectLoader.get_source`)."

#: ../../library/importlib.rst:1286
msgid "Resolve a relative module name to an absolute one."
msgstr "Omvandlar ett relativt modulnamn till ett absolut."

#: ../../library/importlib.rst:1288
msgid ""
"If  **name** has no leading dots, then **name** is simply returned. This "
"allows for usage such as ``importlib.util.resolve_name('sys', "
"__spec__.parent)`` without doing a check to see if the **package** argument "
"is needed."
msgstr ""
"Om **name** inte har några inledande punkter returneras helt enkelt "
"**name**. Detta gör det möjligt att använda "
"``importlib.util.resolve_name('sys', __spec__.parent)`` utan att kontrollera"
" om argumentet **package** behövs."

#: ../../library/importlib.rst:1293
msgid ""
":exc:`ImportError` is raised if **name** is a relative module name but "
"**package** is a false value (e.g. ``None`` or the empty string). "
":exc:`ImportError` is also raised if a relative name would escape its "
"containing package (e.g. requesting ``..bacon`` from within the ``spam`` "
"package)."
msgstr ""
":exc:`ImportError` tas upp om **name** är ett relativt modulnamn men "
"**package** är ett falskt värde (t.ex. ``None`` eller den tomma strängen). "
":exc:`ImportError` tas också upp om ett relativt namn skulle undkomma det "
"innehållande paketet (t.ex. begära ``..bacon`` inom paketet ``spam``)."

#: ../../library/importlib.rst:1301
msgid ""
"To improve consistency with import statements, raise :exc:`ImportError` "
"instead of :exc:`ValueError` for invalid relative import attempts."
msgstr ""
"För att förbättra konsistensen med importdeklarationer, skicka "
":exc:`ImportError` istället för :exc:`ValueError` för ogiltiga relativa "
"importförsök."

#: ../../library/importlib.rst:1308
msgid ""
"Find the :term:`spec <module spec>` for a module, optionally relative to the"
" specified **package** name. If the module is in :data:`sys.modules`, then "
"``sys.modules[name].__spec__`` is returned (unless the spec would be "
"``None`` or is not set, in which case :exc:`ValueError` is raised). "
"Otherwise a search using :data:`sys.meta_path` is done. ``None`` is returned"
" if no spec is found."
msgstr ""
"Hitta :term:`spec <module spec>` för en modul, eventuellt i förhållande till"
" det angivna **package**-namnet. Om modulen finns i :data:`sys.modules`, "
"returneras ``sys.modules[name].__spec__`` (såvida inte specifikationen "
"skulle vara ``None`` eller inte är inställd, i vilket fall "
":exc:`ValueError`` tas upp). Annars görs en sökning med hjälp av "
":data:`sys.meta_path`. ``None`` returneras om ingen specifikation hittas."

#: ../../library/importlib.rst:1315
msgid ""
"If **name** is for a submodule (contains a dot), the parent module is "
"automatically imported."
msgstr ""
"Om **namn** är för en undermodul (innehåller en punkt) importeras den "
"överordnade modulen automatiskt."

#: ../../library/importlib.rst:1318
msgid "**name** and **package** work the same as for :func:`import_module`."
msgstr ""
"**name** och **package** fungerar på samma sätt som för "
":func:`import_module`."

#: ../../library/importlib.rst:1322
msgid ""
"Raises :exc:`ModuleNotFoundError` instead of :exc:`AttributeError` if "
"**package** is in fact not a package (i.e. lacks a :attr:`__path__` "
"attribute)."
msgstr ""

#: ../../library/importlib.rst:1329
msgid ""
"Create a new module based on **spec** and :meth:`spec.loader.create_module "
"<importlib.abc.Loader.create_module>`."
msgstr ""
"Skapa en ny modul baserad på **spec** och :meth:`spec.loader.create_module "
"<importlib.abc.Loader.create_module>`."

#: ../../library/importlib.rst:1332
msgid ""
"If :meth:`spec.loader.create_module <importlib.abc.Loader.create_module>` "
"does not return ``None``, then any pre-existing attributes will not be "
"reset. Also, no :exc:`AttributeError` will be raised if triggered while "
"accessing **spec** or setting an attribute on the module."
msgstr ""
"Om :meth:`spec.loader.create_module <importlib.abc.Loader.create_module>` "
"inte returnerar ``None``, kommer inga befintliga attribut att återställas. "
"Inte heller kommer något :exc:`AttributeError` att uppstå om det utlöses "
"under åtkomst till **spec** eller inställning av ett attribut på modulen."

#: ../../library/importlib.rst:1337
msgid ""
"This function is preferred over using :class:`types.ModuleType` to create a "
"new module as **spec** is used to set as many import-controlled attributes "
"on the module as possible."
msgstr ""
"Denna funktion är att föredra framför att använda :class:`types.ModuleType` "
"för att skapa en ny modul eftersom **spec** används för att ange så många "
"importkontrollerade attribut för modulen som möjligt."

#: ../../library/importlib.rst:1345
msgid ""
"A :term:`decorator` for :meth:`importlib.abc.Loader.load_module` to handle "
"selecting the proper module object to load with. The decorated method is "
"expected to have a call signature taking two positional arguments (e.g. "
"``load_module(self, module)``) for which the second argument will be the "
"module **object** to be used by the loader. Note that the decorator will not"
" work on static methods because of the assumption of two arguments."
msgstr ""

#: ../../library/importlib.rst:1354
msgid ""
"The decorated method will take in the **name** of the module to be loaded as"
" expected for a :term:`loader`. If the module is not found in "
":data:`sys.modules` then a new one is constructed. Regardless of where the "
"module came from, :attr:`__loader__` set to **self** and :attr:`__package__`"
" is set based on what :meth:`importlib.abc.InspectLoader.is_package` returns"
" (if available). These attributes are set unconditionally to support "
"reloading."
msgstr ""

#: ../../library/importlib.rst:1362
msgid ""
"If an exception is raised by the decorated method and a module was added to "
":data:`sys.modules`, then the module will be removed to prevent a partially "
"initialized module from being in left in :data:`sys.modules`. If the module "
"was already in :data:`sys.modules` then it is left alone."
msgstr ""

#: ../../library/importlib.rst:1367
msgid ""
":attr:`__loader__` and :attr:`__package__` are automatically set (when "
"possible)."
msgstr ""

#: ../../library/importlib.rst:1371
msgid ""
"Set :attr:`__name__`, :attr:`__loader__` :attr:`__package__` unconditionally"
" to support reloading."
msgstr ""

#: ../../library/importlib.rst:1375
msgid ""
"The import machinery now directly performs all the functionality provided by"
" this function."
msgstr ""

#: ../../library/importlib.rst:1381
msgid ""
"A :term:`decorator` for :meth:`importlib.abc.Loader.load_module` to set the "
":attr:`__loader__` attribute on the returned module. If the attribute is "
"already set the decorator does nothing. It is assumed that the first "
"positional argument to the wrapped method (i.e. ``self``) is what "
":attr:`__loader__` should be set to."
msgstr ""

#: ../../library/importlib.rst:1388
msgid ""
"Set ``__loader__`` if set to ``None``, as if the attribute does not exist."
msgstr ""

#: ../../library/importlib.rst:1392 ../../library/importlib.rst:1401
msgid "The import machinery takes care of this automatically."
msgstr ""

#: ../../library/importlib.rst:1397
msgid ""
"A :term:`decorator` for :meth:`importlib.abc.Loader.load_module` to set the "
":attr:`__package__` attribute on the returned module. If :attr:`__package__`"
" is set and has a value other than ``None`` it will not be changed."
msgstr ""

#: ../../library/importlib.rst:1406
msgid ""
"A factory function for creating a :class:`~importlib.machinery.ModuleSpec` "
"instance based on a loader.  The parameters have the same meaning as they do"
" for ModuleSpec.  The function uses available :term:`loader` APIs, such as "
":meth:`InspectLoader.is_package`, to fill in any missing information on the "
"spec."
msgstr ""
"En fabriksfunktion för att skapa en "
":class:`~importlib.machinery.ModuleSpec`\\-instans baserad på en laddare.  "
"Parametrarna har samma betydelse som de har för ModuleSpec.  Funktionen "
"använder tillgängliga :term:`loader` API:er, såsom "
":meth:`InspectLoader.is_package`, för att fylla i eventuell saknad "
"information om specifikationen."

#: ../../library/importlib.rst:1416
msgid ""
"A factory function for creating a :class:`~importlib.machinery.ModuleSpec` "
"instance based on the path to a file.  Missing information will be filled in"
" on the spec by making use of loader APIs and by the implication that the "
"module will be file-based."
msgstr ""
"En fabriksfunktion för att skapa en "
":class:`~importlib.machinery.ModuleSpec`\\-instans baserat på sökvägen till "
"en fil.  Saknad information kommer att fyllas i i specifikationen genom att "
"använda API:er för laddare och genom att antyda att modulen kommer att vara "
"filbaserad."

#: ../../library/importlib.rst:1428
msgid ""
"Return the hash of *source_bytes* as bytes. A hash-based ``.pyc`` file "
"embeds the :func:`source_hash` of the corresponding source file's contents "
"in its header."
msgstr ""
"Returnerar hashen av *source_bytes* som bytes. En hashbaserad ``.pyc``\\-fil"
" bäddar in :func:`source_hash` av motsvarande källfils innehåll i sitt "
"huvud."

#: ../../library/importlib.rst:1436
msgid ""
"A class which postpones the execution of the loader of a module until the "
"module has an attribute accessed."
msgstr ""
"En klass som skjuter upp exekveringen av laddaren för en modul tills dess "
"att modulen har ett attribut åtkomligt."

#: ../../library/importlib.rst:1439
msgid ""
"This class **only** works with loaders that define "
":meth:`~importlib.abc.Loader.exec_module` as control over what module type "
"is used for the module is required. For those same reasons, the loader's "
":meth:`~importlib.abc.Loader.create_module` method must return ``None`` or a"
" type for which its ``__class__`` attribute can be mutated along with not "
"using :term:`slots <__slots__>`. Finally, modules which substitute the "
"object placed into :data:`sys.modules` will not work as there is no way to "
"properly replace the module references throughout the interpreter safely; "
":exc:`ValueError` is raised if such a substitution is detected."
msgstr ""
"Denna klass fungerar **endast** med laddare som definierar "
":meth:`~importlib.abc.Loader.exec_module` eftersom kontroll över vilken "
"modultyp som används för modulen krävs. Av samma skäl måste laddarens metod "
":meth:`~importlib.abc.Loader.create_module` returnera ``None`` eller en typ "
"för vilken attributet ``__class__`` kan ändras, och inte heller använda "
":term:`slots <__slots__>`. Slutligen kommer moduler som ersätter objektet "
"som placerats i :data:`sys.modules` inte att fungera eftersom det inte finns"
" något sätt att på ett säkert sätt ersätta modulreferenserna i hela tolken; "
":exc:`ValueError` tas upp om en sådan ersättning upptäcks."

#: ../../library/importlib.rst:1450
msgid ""
"For projects where startup time is critical, this class allows for "
"potentially minimizing the cost of loading a module if it is never used. For"
" projects where startup time is not essential then use of this class is "
"**heavily** discouraged due to error messages created during loading being "
"postponed and thus occurring out of context."
msgstr ""
"För projekt där uppstartstiden är kritisk gör den här klassen det möjligt "
"att potentiellt minimera kostnaden för att ladda en modul om den aldrig "
"används. För projekt där starttiden inte är avgörande är det **starkt** "
"avrått från att använda denna klass eftersom felmeddelanden som skapas under"
" laddningen skjuts upp och därmed uppträder utanför sitt sammanhang."

#: ../../library/importlib.rst:1458
msgid ""
"Began calling :meth:`~importlib.abc.Loader.create_module`, removing the "
"compatibility warning for :class:`importlib.machinery.BuiltinImporter` and "
":class:`importlib.machinery.ExtensionFileLoader`."
msgstr ""
"Började anropa :meth:`~importlib.abc.Loader.create_module`, vilket tog bort "
"kompatibilitetsvarningen för :class:`importlib.machinery.BuiltinImporter` "
"och :class:`importlib.machinery.ExtensionFileLoader`."

#: ../../library/importlib.rst:1465
msgid ""
"A class method which returns a callable that creates a lazy loader. This is "
"meant to be used in situations where the loader is passed by class instead "
"of by instance. ::"
msgstr ""
"En klassmetod som returnerar en callable som skapar en lazy loader. Detta är"
" tänkt att användas i situationer där laddaren skickas av klassen istället "
"för av instansen:"

#: ../../library/importlib.rst:1478
msgid "Examples"
msgstr "Exempel"

#: ../../library/importlib.rst:1481
msgid "Importing programmatically"
msgstr "Importera programmatiskt"

#: ../../library/importlib.rst:1483
msgid ""
"To programmatically import a module, use :func:`importlib.import_module`. ::"
msgstr ""
"För att programmatiskt importera en modul, använd "
":func:`importlib.import_module`. ::"

#: ../../library/importlib.rst:1492
msgid "Checking if a module can be imported"
msgstr "Kontroll av om en modul kan importeras"

#: ../../library/importlib.rst:1494
msgid ""
"If you need to find out if a module can be imported without actually doing "
"the import, then you should use :func:`importlib.util.find_spec`."
msgstr ""
"Om du behöver ta reda på om en modul kan importeras utan att faktiskt göra "
"importen, bör du använda :func:`importlib.util.find_spec`."

#: ../../library/importlib.rst:1497
msgid ""
"Note that if ``name`` is a submodule (contains a dot), "
":func:`importlib.util.find_spec` will import the parent module. ::"
msgstr ""
"Observera att om ``name`` är en undermodul (innehåller en punkt) kommer "
":func:`importlib.util.find_spec` att importera föräldramodulen. ::"

#: ../../library/importlib.rst:1520
msgid "Importing a source file directly"
msgstr "Importera en källfil direkt"

#: ../../library/importlib.rst:1522
msgid "To import a Python source file directly, use the following recipe::"
msgstr ""

#: ../../library/importlib.rst:1539
msgid "Implementing lazy imports"
msgstr "Implementering av lat import"

#: ../../library/importlib.rst:1541
msgid "The example below shows how to implement lazy imports::"
msgstr "Exemplet nedan visar hur man implementerar lazy imports::"

#: ../../library/importlib.rst:1563
msgid "Setting up an importer"
msgstr "Konfigurera en importer"

#: ../../library/importlib.rst:1565
msgid ""
"For deep customizations of import, you typically want to implement an "
":term:`importer`. This means managing both the :term:`finder` and "
":term:`loader` side of things. For finders there are two flavours to choose "
"from depending on your needs: a :term:`meta path finder` or a :term:`path "
"entry finder`. The former is what you would put on :data:`sys.meta_path` "
"while the latter is what you create using a :term:`path entry hook` on "
":data:`sys.path_hooks` which works with :data:`sys.path` entries to "
"potentially create a finder. This example will show you how to register your"
" own importers so that import will use them (for creating an importer for "
"yourself, read the documentation for the appropriate classes defined within "
"this package)::"
msgstr ""
"För djupa anpassningar av import vill du vanligtvis implementera en "
":term:`importer`. Detta innebär att hantera både :term:`finder` och "
":term:`loader` sidan av saker och ting. För sökare finns det två varianter "
"att välja mellan beroende på dina behov: en :term:`meta path finder` eller "
"en :term:`path entry finder`. Den förra är vad du skulle sätta på "
":data:`sys.meta_path` medan den senare är vad du skapar med hjälp av en "
":term:`path entry hook` på :data:`sys.path_hooks` som fungerar med "
":data:`sys.path`\\-poster för att potentiellt skapa en sökare. Det här "
"exemplet visar hur du registrerar dina egna importörer så att import "
"använder dem (för att skapa en egen importör, läs dokumentationen för "
"lämpliga klasser som definieras i det här paketet)::"

#: ../../library/importlib.rst:1597
msgid "Approximating :func:`importlib.import_module`"
msgstr "Närmar sig :func:`importlib.import_module`"

#: ../../library/importlib.rst:1599
msgid ""
"Import itself is implemented in Python code, making it possible to expose "
"most of the import machinery through importlib. The following helps "
"illustrate the various APIs that importlib exposes by providing an "
"approximate implementation of :func:`importlib.import_module`::"
msgstr ""
"Import i sig är implementerat i Python-kod, vilket gör det möjligt att "
"exponera det mesta av importmaskineriet genom importlib. Följande hjälper "
"till att illustrera de olika API:erna som importlib exponerar genom att "
"tillhandahålla en ungefärlig implementering av "
":func:`importlib.import_module`::"

#: ../../library/importlib.rst:551
msgid "universal newlines"
msgstr "universella nya rader"

#: ../../library/importlib.rst:551
msgid "importlib.abc.InspectLoader.get_source method"
msgstr "importlib.abc.InspectLoader.get_source-metoden"
