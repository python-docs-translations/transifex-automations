# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-17 18:07+0000\n"
"PO-Revision-Date: 2025-09-22 17:55+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../library/heapq.rst:2
msgid ":mod:`heapq` --- Heap queue algorithm"
msgstr ""

#: ../../library/heapq.rst:12
msgid "**Source code:** :source:`Lib/heapq.py`"
msgstr "**Källkod:** :source:`Lib/heapq.py`"

#: ../../library/heapq.rst:16
msgid ""
"This module provides an implementation of the heap queue algorithm, also "
"known as the priority queue algorithm."
msgstr ""
"Denna modul ger en implementation av heap-köalgoritmen, även känd som "
"prioritetsköalgoritmen."

#: ../../library/heapq.rst:19
msgid ""
"Heaps are binary trees for which every parent node has a value less than or "
"equal to any of its children.  This implementation uses arrays for which "
"``heap[k] <= heap[2*k+1]`` and ``heap[k] <= heap[2*k+2]`` for all *k*, "
"counting elements from zero.  For the sake of comparison, non-existing "
"elements are considered to be infinite.  The interesting property of a heap "
"is that its smallest element is always the root, ``heap[0]``."
msgstr ""

#: ../../library/heapq.rst:26
msgid ""
"The API below differs from textbook heap algorithms in two aspects: (a) We "
"use zero-based indexing.  This makes the relationship between the index for "
"a node and the indexes for its children slightly less obvious, but is more "
"suitable since Python uses zero-based indexing. (b) Our pop method returns "
"the smallest item, not the largest (called a \"min heap\" in textbooks; a "
"\"max heap\" is more common in texts because of its suitability for in-place "
"sorting)."
msgstr ""

#: ../../library/heapq.rst:33
msgid ""
"These two make it possible to view the heap as a regular Python list without "
"surprises: ``heap[0]`` is the smallest item, and ``heap.sort()`` maintains "
"the heap invariant!"
msgstr ""

#: ../../library/heapq.rst:37
msgid ""
"To create a heap, use a list initialized to ``[]``, or you can transform a "
"populated list into a heap via function :func:`heapify`."
msgstr ""

#: ../../library/heapq.rst:40
msgid "The following functions are provided:"
msgstr "Följande funktioner finns tillgängliga:"

#: ../../library/heapq.rst:45
msgid "Push the value *item* onto the *heap*, maintaining the heap invariant."
msgstr ""

#: ../../library/heapq.rst:50
msgid ""
"Pop and return the smallest item from the *heap*, maintaining the heap "
"invariant.  If the heap is empty, :exc:`IndexError` is raised.  To access "
"the smallest item without popping it, use ``heap[0]``."
msgstr ""

#: ../../library/heapq.rst:57
msgid ""
"Push *item* on the heap, then pop and return the smallest item from the "
"*heap*.  The combined action runs more efficiently than :func:`heappush` "
"followed by a separate call to :func:`heappop`."
msgstr ""
"Skjut *objekt* på högen, sedan popa upp och returnera det minsta objektet "
"från *högen*.  Den kombinerade åtgärden körs mer effektivt än :func:"
"`heappush` följt av ett separat anrop till :func:`heappop`."

#: ../../library/heapq.rst:64
msgid "Transform list *x* into a heap, in-place, in linear time."
msgstr ""

#: ../../library/heapq.rst:69
msgid ""
"Pop and return the smallest item from the *heap*, and also push the new "
"*item*. The heap size doesn't change. If the heap is empty, :exc:"
"`IndexError` is raised."
msgstr ""
"Popa och returnera det minsta objektet från *heapen*, och även pusha det nya "
"*objektet*. Stapelns storlek ändras inte. Om högen är tom, uppstår :exc:"
"`IndexError`."

#: ../../library/heapq.rst:72
msgid ""
"This one step operation is more efficient than a :func:`heappop` followed "
"by :func:`heappush` and can be more appropriate when using a fixed-size "
"heap. The pop/push combination always returns an element from the heap and "
"replaces it with *item*."
msgstr ""
"Denna operation i ett steg är mer effektiv än :func:`heappop` följt av :func:"
"`heappush` och kan vara mer lämplig när man använder en heap med fast "
"storlek. Kombinationen pop/push returnerar alltid ett element från högen och "
"ersätter det med *item*."

#: ../../library/heapq.rst:77
msgid ""
"The value returned may be larger than the *item* added.  If that isn't "
"desired, consider using :func:`heappushpop` instead.  Its push/pop "
"combination returns the smaller of the two values, leaving the larger value "
"on the heap."
msgstr ""
"Det returnerade värdet kan vara större än det tillagda *objektet*.  Om detta "
"inte är önskvärt kan du överväga att använda :func:`heappushpop` istället.  "
"Dess push/pop-kombination returnerar det mindre av de två värdena och lämnar "
"det större värdet på högen."

#: ../../library/heapq.rst:83
msgid "The module also offers three general purpose functions based on heaps."
msgstr "Modulen erbjuder också tre allmänna funktioner baserade på heaps."

#: ../../library/heapq.rst:88
msgid ""
"Merge multiple sorted inputs into a single sorted output (for example, merge "
"timestamped entries from multiple log files).  Returns an :term:`iterator` "
"over the sorted values."
msgstr ""
"Sammanfogar flera sorterade indata till en enda sorterad utdata (t.ex. "
"sammanfogar tidsstämplade poster från flera loggfiler).  Returnerar en :term:"
"`iterator` över de sorterade värdena."

#: ../../library/heapq.rst:92
msgid ""
"Similar to ``sorted(itertools.chain(*iterables))`` but returns an iterable, "
"does not pull the data into memory all at once, and assumes that each of the "
"input streams is already sorted (smallest to largest)."
msgstr ""
"Liknar ``sorted(itertools.chain(*iterables))`` men returnerar en iterabel, "
"drar inte in data i minnet på en gång och förutsätter att var och en av "
"inmatningsströmmarna redan är sorterade (minsta till största)."

#: ../../library/heapq.rst:96
msgid ""
"Has two optional arguments which must be specified as keyword arguments."
msgstr "Har två valfria argument som måste anges som nyckelordsargument."

#: ../../library/heapq.rst:98
msgid ""
"*key* specifies a :term:`key function` of one argument that is used to "
"extract a comparison key from each input element.  The default value is "
"``None`` (compare the elements directly)."
msgstr ""
"*key* anger en :term:`key function` med ett argument som används för att "
"extrahera en jämförelsenyckel från varje inmatat element.  Standardvärdet är "
"``None`` (jämför elementen direkt)."

#: ../../library/heapq.rst:102
msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the input elements "
"are merged as if each comparison were reversed. To achieve behavior similar "
"to ``sorted(itertools.chain(*iterables), reverse=True)``, all iterables must "
"be sorted from largest to smallest."
msgstr ""
"*reverse* är ett booleanskt värde.  Om värdet är satt till ``True`` slås "
"inmatningselementen samman som om varje jämförelse var omvänd. För att uppnå "
"ett beteende som liknar ``sorted(itertools.chain(*iterables), "
"reverse=True)`` måste alla iterables sorteras från största till minsta."

#: ../../library/heapq.rst:107
msgid "Added the optional *key* and *reverse* parameters."
msgstr "Lagt till de valfria parametrarna *key* och *reverse*."

#: ../../library/heapq.rst:113
msgid ""
"Return a list with the *n* largest elements from the dataset defined by "
"*iterable*.  *key*, if provided, specifies a function of one argument that "
"is used to extract a comparison key from each element in *iterable* (for "
"example, ``key=str.lower``).  Equivalent to:  ``sorted(iterable, key=key, "
"reverse=True)[:n]``."
msgstr ""
"Returnerar en lista med de *n* största elementen från datasetet som "
"definieras av *iterable*.  *key*, om den anges, specificerar en funktion med "
"ett argument som används för att extrahera en jämförelsenyckel från varje "
"element i *iterable* (t.ex. ``key=str.lower``).  Likvärdig med:  "
"``sorted(iterable, key=key, reverse=True)[:n]``."

#: ../../library/heapq.rst:122
msgid ""
"Return a list with the *n* smallest elements from the dataset defined by "
"*iterable*.  *key*, if provided, specifies a function of one argument that "
"is used to extract a comparison key from each element in *iterable* (for "
"example, ``key=str.lower``).  Equivalent to:  ``sorted(iterable, key=key)[:"
"n]``."
msgstr ""
"Returnerar en lista med de *n* minsta elementen från datasetet som "
"definieras av *iterable*.  *key*, om det anges, specificerar en funktion med "
"ett argument som används för att extrahera en jämförelsenyckel från varje "
"element i *iterable* (till exempel ``key=str.lower``).  Likvärdig med:  "
"``sorted(iterable, key=key)[:n]``."

#: ../../library/heapq.rst:128
msgid ""
"The latter two functions perform best for smaller values of *n*.  For larger "
"values, it is more efficient to use the :func:`sorted` function.  Also, when "
"``n==1``, it is more efficient to use the built-in :func:`min` and :func:"
"`max` functions.  If repeated usage of these functions is required, consider "
"turning the iterable into an actual heap."
msgstr ""
"De två sistnämnda funktionerna fungerar bäst för mindre värden på *n*.  För "
"större värden är det mer effektivt att använda funktionen :func:`sorted`.  "
"När ``n==1`` är det också mer effektivt att använda de inbyggda "
"funktionerna :func:`min` och :func:`max`.  Om det krävs upprepad användning "
"av dessa funktioner bör du överväga att göra om iterabeln till en faktisk "
"hög."

#: ../../library/heapq.rst:136
msgid "Basic Examples"
msgstr "Grundläggande exempel"

#: ../../library/heapq.rst:138
msgid ""
"A `heapsort <https://en.wikipedia.org/wiki/Heapsort>`_ can be implemented by "
"pushing all values onto a heap and then popping off the smallest values one "
"at a time::"
msgstr ""
"En `heapsort <https://en.wikipedia.org/wiki/Heapsort>`_ kan implementeras "
"genom att lägga alla värden på en hög och sedan plocka bort de minsta "
"värdena ett i taget::"

#: ../../library/heapq.rst:151
msgid ""
"This is similar to ``sorted(iterable)``, but unlike :func:`sorted`, this "
"implementation is not stable."
msgstr ""
"Detta liknar ``sorted(iterable)``, men till skillnad från :func:`sorted` är "
"denna implementation inte stabil."

#: ../../library/heapq.rst:154
msgid ""
"Heap elements can be tuples.  This is useful for assigning comparison values "
"(such as task priorities) alongside the main record being tracked::"
msgstr ""
"Heap-element kan vara tupler.  Detta är användbart för att tilldela "
"jämförelsevärden (t.ex. uppgiftsprioriteringar) vid sidan av den "
"huvudsakliga post som spåras::"

#: ../../library/heapq.rst:167
msgid "Priority Queue Implementation Notes"
msgstr "Anvisningar för implementering av prioriterad kö"

#: ../../library/heapq.rst:169
msgid ""
"A `priority queue <https://en.wikipedia.org/wiki/Priority_queue>`_ is common "
"use for a heap, and it presents several implementation challenges:"
msgstr ""
"En `prioritetskö <https://en.wikipedia.org/wiki/Priority_queue>`_ är en "
"vanlig användning för en hög, och den innebär flera "
"implementeringsutmaningar:"

#: ../../library/heapq.rst:172
msgid ""
"Sort stability:  how do you get two tasks with equal priorities to be "
"returned in the order they were originally added?"
msgstr ""
"Sorteringsstabilitet: Hur får man två uppgifter med samma prioritet att "
"returneras i den ordning de ursprungligen lades till?"

#: ../../library/heapq.rst:175
msgid ""
"Tuple comparison breaks for (priority, task) pairs if the priorities are "
"equal and the tasks do not have a default comparison order."
msgstr ""
"Tupeljämförelsen bryts för (prioritet, uppgift)-par om prioriteringarna är "
"lika och uppgifterna inte har en standardjämförelseordning."

#: ../../library/heapq.rst:178
msgid ""
"If the priority of a task changes, how do you move it to a new position in "
"the heap?"
msgstr ""
"Om prioriteten för en uppgift ändras, hur flyttar du den till en ny position "
"i högen?"

#: ../../library/heapq.rst:181
msgid ""
"Or if a pending task needs to be deleted, how do you find it and remove it "
"from the queue?"
msgstr ""
"Eller om en väntande uppgift behöver raderas, hur hittar du den och tar bort "
"den från kön?"

#: ../../library/heapq.rst:184
msgid ""
"A solution to the first two challenges is to store entries as 3-element list "
"including the priority, an entry count, and the task.  The entry count "
"serves as a tie-breaker so that two tasks with the same priority are "
"returned in the order they were added. And since no two entry counts are the "
"same, the tuple comparison will never attempt to directly compare two tasks."
msgstr ""
"En lösning på de två första utmaningarna är att lagra poster som en lista "
"med tre element, inklusive prioriteten, ett antal poster och uppgiften.  "
"Entry count fungerar som en tie-breaker så att två uppgifter med samma "
"prioritet returneras i den ordning de lades till. Och eftersom ingen "
"posträkning är den andra lik kommer tuple-jämförelsen aldrig att försöka "
"jämföra två uppgifter direkt."

#: ../../library/heapq.rst:190
msgid ""
"Another solution to the problem of non-comparable tasks is to create a "
"wrapper class that ignores the task item and only compares the priority "
"field::"
msgstr ""
"En annan lösning på problemet med icke jämförbara uppgifter är att skapa en "
"omslutande klass som ignorerar uppgiftsobjektet och endast jämför "
"prioritetsfältet::"

#: ../../library/heapq.rst:201
msgid ""
"The remaining challenges revolve around finding a pending task and making "
"changes to its priority or removing it entirely.  Finding a task can be done "
"with a dictionary pointing to an entry in the queue."
msgstr ""
"De återstående utmaningarna handlar om att hitta en väntande uppgift och "
"ändra dess prioritet eller ta bort den helt och hållet.  Att hitta en "
"uppgift kan göras med en ordbok som pekar på en post i kön."

#: ../../library/heapq.rst:205
msgid ""
"Removing the entry or changing its priority is more difficult because it "
"would break the heap structure invariants.  So, a possible solution is to "
"mark the entry as removed and add a new entry with the revised priority::"
msgstr ""
"Att ta bort posten eller ändra dess prioritet är svårare eftersom det skulle "
"bryta mot invarianterna för heapstrukturen.  En möjlig lösning är därför att "
"markera posten som borttagen och lägga till en ny post med den reviderade "
"prioriteten::"

#: ../../library/heapq.rst:239
msgid "Theory"
msgstr "Teori"

#: ../../library/heapq.rst:241
msgid ""
"Heaps are arrays for which ``a[k] <= a[2*k+1]`` and ``a[k] <= a[2*k+2]`` for "
"all *k*, counting elements from 0.  For the sake of comparison, non-existing "
"elements are considered to be infinite.  The interesting property of a heap "
"is that ``a[0]`` is always its smallest element."
msgstr ""
"Heaps är matriser för vilka ``a[k] <= a[2*k+1]`` och ``a[k] <= a[2*k+2]`` "
"för alla *k*, räknat med element från 0. För jämförelsens skull anses icke-"
"existerande element vara oändliga.  Den intressanta egenskapen hos en hög är "
"att ``a[0]`` alltid är dess minsta element."

#: ../../library/heapq.rst:246
msgid ""
"The strange invariant above is meant to be an efficient memory "
"representation for a tournament.  The numbers below are *k*, not ``a[k]``::"
msgstr ""
"Den märkliga invarianten ovan är tänkt att vara en effektiv "
"minnesrepresentation för en turnering.  Siffrorna nedan är *k*, inte "
"``a[k]``::"

#: ../../library/heapq.rst:259
msgid ""
"In the tree above, each cell *k* is topping ``2*k+1`` and ``2*k+2``. In a "
"usual binary tournament we see in sports, each cell is the winner over the "
"two cells it tops, and we can trace the winner down the tree to see all "
"opponents s/he had.  However, in many computer applications of such "
"tournaments, we do not need to trace the history of a winner. To be more "
"memory efficient, when a winner is promoted, we try to replace it by "
"something else at a lower level, and the rule becomes that a cell and the "
"two cells it tops contain three different items, but the top cell \"wins\" "
"over the two topped cells."
msgstr ""
"I trädet ovan toppar varje cell *k* ``2*k+1`` och ``2*k+2``. I en vanlig "
"binär turnering som vi ser i sport är varje cell vinnare över de två celler "
"den toppar, och vi kan spåra vinnaren nedåt i trädet för att se alla "
"motståndare han/hon hade.  I många datortillämpningar av sådana turneringar "
"behöver vi dock inte spåra en vinnares historia. För att vara mer "
"minneseffektiva försöker vi ersätta en vinnare med något annat på en lägre "
"nivå, och regeln blir att en cell och de två celler som den toppar "
"innehåller tre olika saker, men att den översta cellen \"vinner\" över de "
"två toppade cellerna."

#: ../../library/heapq.rst:268
msgid ""
"If this heap invariant is protected at all time, index 0 is clearly the "
"overall winner.  The simplest algorithmic way to remove it and find the "
"\"next\" winner is to move some loser (let's say cell 30 in the diagram "
"above) into the 0 position, and then percolate this new 0 down the tree, "
"exchanging values, until the invariant is re-established. This is clearly "
"logarithmic on the total number of items in the tree. By iterating over all "
"items, you get an O(n log n) sort."
msgstr ""

#: ../../library/heapq.rst:275
msgid ""
"A nice feature of this sort is that you can efficiently insert new items "
"while the sort is going on, provided that the inserted items are not "
"\"better\" than the last 0'th element you extracted.  This is especially "
"useful in simulation contexts, where the tree holds all incoming events, and "
"the \"win\" condition means the smallest scheduled time.  When an event "
"schedules other events for execution, they are scheduled into the future, so "
"they can easily go into the heap.  So, a heap is a good structure for "
"implementing schedulers (this is what I used for my MIDI sequencer :-)."
msgstr ""
"En trevlig egenskap hos denna sortering är att du effektivt kan infoga nya "
"element medan sorteringen pågår, förutsatt att de infogade elementen inte är "
"\"bättre\" än det sista 0:e elementet du extraherade.  Detta är särskilt "
"användbart i simuleringssammanhang, där trädet innehåller alla inkommande "
"händelser och \"win\"-villkoret innebär den minsta schemalagda tiden.  När "
"en händelse schemalägger andra händelser för utförande schemaläggs de in i "
"framtiden, så att de lätt kan hamna i högen.  Så en hög är en bra struktur "
"för att implementera schemaläggare (det är vad jag använde för min MIDI-"
"sequencer :-)."

#: ../../library/heapq.rst:284
msgid ""
"Various structures for implementing schedulers have been extensively "
"studied, and heaps are good for this, as they are reasonably speedy, the "
"speed is almost constant, and the worst case is not much different than the "
"average case. However, there are other representations which are more "
"efficient overall, yet the worst cases might be terrible."
msgstr ""
"Olika strukturer för att implementera schemaläggare har studerats ingående, "
"och heaps är bra för detta, eftersom de är rimligt snabba, hastigheten är "
"nästan konstant och det värsta fallet inte skiljer sig mycket från det "
"genomsnittliga fallet. Det finns dock andra representationer som är mer "
"effektiva överlag, men de värsta fallen kan vara fruktansvärda."

#: ../../library/heapq.rst:290
msgid ""
"Heaps are also very useful in big disk sorts.  You most probably all know "
"that a big sort implies producing \"runs\" (which are pre-sorted sequences, "
"whose size is usually related to the amount of CPU memory), followed by a "
"merging passes for these runs, which merging is often very cleverly "
"organised [#]_. It is very important that the initial sort produces the "
"longest runs possible.  Tournaments are a good way to achieve that.  If, "
"using all the memory available to hold a tournament, you replace and "
"percolate items that happen to fit the current run, you'll produce runs "
"which are twice the size of the memory for random input, and much better for "
"input fuzzily ordered."
msgstr ""
"Heaps är också mycket användbara i stora disksorteringar.  Du vet säkert "
"alla att en stor sortering innebär att man producerar \"körningar\" (som är "
"försorterade sekvenser, vars storlek vanligtvis är relaterad till mängden "
"CPU-minne), följt av ett sammanslagningspass för dessa körningar, vilken "
"sammanslagning ofta är mycket smart organiserad [#]_. Det är mycket viktigt "
"att den inledande sorteringen ger så långa körningar som möjligt.  "
"Turneringar är ett bra sätt att uppnå detta.  Om du använder allt minne som "
"finns tillgängligt för att hålla en turnering, ersätter och perkolerar "
"objekt som råkar passa den aktuella körningen, kommer du att producera "
"körningar som är dubbelt så stora som minnet för slumpmässig inmatning, och "
"mycket bättre för inmatning som är luddigt ordnad."

#: ../../library/heapq.rst:300
msgid ""
"Moreover, if you output the 0'th item on disk and get an input which may not "
"fit in the current tournament (because the value \"wins\" over the last "
"output value), it cannot fit in the heap, so the size of the heap "
"decreases.  The freed memory could be cleverly reused immediately for "
"progressively building a second heap, which grows at exactly the same rate "
"the first heap is melting.  When the first heap completely vanishes, you "
"switch heaps and start a new run.  Clever and quite effective!"
msgstr ""
"Dessutom, om du matar ut det 0:e objektet på disken och får en inmatning som "
"inte får plats i den aktuella turneringen (eftersom värdet \"vinner\" över "
"det senaste utmatningsvärdet), kan det inte få plats i högen, så storleken "
"på högen minskar.  Det frigjorda minnet kan på ett smart sätt omedelbart "
"återanvändas för att successivt bygga upp en andra hög, som växer i exakt "
"samma takt som den första högen smälter.  När den första högen helt "
"försvinner byter man hög och startar en ny körning.  Smart och ganska "
"effektivt!"

#: ../../library/heapq.rst:308
msgid ""
"In a word, heaps are useful memory structures to know.  I use them in a few "
"applications, and I think it is good to keep a 'heap' module around. :-)"
msgstr ""
"Kort sagt, heaps är användbara minnesstrukturer att känna till.  Jag "
"använder dem i några program, och jag tror att det är bra att ha en \"heap\"-"
"modul :-)"

#: ../../library/heapq.rst:312
msgid "Footnotes"
msgstr "Fotnoter"

#: ../../library/heapq.rst:313
msgid ""
"The disk balancing algorithms which are current, nowadays, are more annoying "
"than clever, and this is a consequence of the seeking capabilities of the "
"disks. On devices which cannot seek, like big tape drives, the story was "
"quite different, and one had to be very clever to ensure (far in advance) "
"that each tape movement will be the most effective possible (that is, will "
"best participate at \"progressing\" the merge).  Some tapes were even able "
"to read backwards, and this was also used to avoid the rewinding time. "
"Believe me, real good tape sorts were quite spectacular to watch! From all "
"times, sorting has always been a Great Art! :-)"
msgstr ""
"De algoritmer för diskbalansering som används nuförtiden är mer irriterande "
"än smarta, och detta är en följd av diskarnas sökfunktioner. På enheter som "
"inte kan söka, som stora bandstationer, var historien en helt annan, och man "
"var tvungen att vara mycket smart för att säkerställa (långt i förväg) att "
"varje bandrörelse skulle vara så effektiv som möjligt (det vill säga bäst "
"bidra till att \"föra fram\" sammanfogningen).  Vissa band kunde till och "
"med läsas baklänges, och detta användes också för att undvika "
"omspolningstiden. Tro mig, riktigt bra bandsorteringar var ganska "
"spektakulära att se! Från alla tider har sortering alltid varit en stor "
"konst! :-)"
