# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-05 14:23+0000\n"
"PO-Revision-Date: 2025-07-18 18:49+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../library/stdtypes.rst:8
msgid "Built-in Types"
msgstr "Inbyggda typer"

#: ../../library/stdtypes.rst:10
msgid ""
"The following sections describe the standard types that are built into the "
"interpreter."
msgstr ""
"I följande avsnitt beskrivs de standardtyper som finns inbyggda i tolken."

#: ../../library/stdtypes.rst:15
msgid ""
"The principal built-in types are numerics, sequences, mappings, classes, "
"instances and exceptions."
msgstr ""
"De viktigaste inbyggda typerna är numeriska, sekvenser, mappningar, klasser, "
"instanser och undantag."

#: ../../library/stdtypes.rst:18
msgid ""
"Some collection classes are mutable.  The methods that add, subtract, or "
"rearrange their members in place, and don't return a specific item, never "
"return the collection instance itself but ``None``."
msgstr ""
"Vissa samlingsklasser är mutabla.  De metoder som lägger till, subtraherar "
"eller omorganiserar sina medlemmar på plats, och inte returnerar ett "
"specifikt objekt, returnerar aldrig själva samlingsinstansen utan ``None``."

#: ../../library/stdtypes.rst:22
msgid ""
"Some operations are supported by several object types; in particular, "
"practically all objects can be compared for equality, tested for truth "
"value, and converted to a string (with the :func:`repr` function or the "
"slightly different :func:`str` function).  The latter function is implicitly "
"used when an object is written by the :func:`print` function."
msgstr ""
"Vissa operationer stöds av flera objekttyper; i synnerhet kan praktiskt "
"taget alla objekt jämföras med avseende på likhet, testas för sanningsvärde "
"och konverteras till en sträng (med funktionen :func:`repr` eller den något "
"annorlunda funktionen :func:`str`).  Den senare funktionen används implicit "
"när ett objekt skrivs ut med funktionen :func:`print`."

#: ../../library/stdtypes.rst:32
msgid "Truth Value Testing"
msgstr "Test av sanning och värde"

#: ../../library/stdtypes.rst:41
msgid ""
"Any object can be tested for truth value, for use in an :keyword:`if` or :"
"keyword:`while` condition or as operand of the Boolean operations below."
msgstr ""
"Alla objekt kan testas för sanningsvärde, för användning i ett :keyword:`if` "
"eller :keyword:`while` villkor eller som operand i de booleska operationerna "
"nedan."

#: ../../library/stdtypes.rst:46
msgid ""
"By default, an object is considered true unless its class defines either a :"
"meth:`~object.__bool__` method that returns ``False`` or a :meth:`~object."
"__len__` method that returns zero, when called with the object. [1]_  Here "
"are most of the built-in objects considered false:"
msgstr ""
"Som standard anses ett objekt vara sant om inte dess klass definierar "
"antingen en :meth:`~object.__bool__`-metod som returnerar ``False`` eller "
"en :meth:`~object.__len__`-metod som returnerar noll, när den anropas med "
"objektet. [1]_ Här är de flesta av de inbyggda objekt som anses vara falska:"

#: ../../library/stdtypes.rst:56
msgid "constants defined to be false: ``None`` and ``False``"
msgstr "konstanter som definieras som falska: ``None`` och ``False``"

#: ../../library/stdtypes.rst:58
msgid ""
"zero of any numeric type: ``0``, ``0.0``, ``0j``, ``Decimal(0)``, "
"``Fraction(0, 1)``"
msgstr ""
"noll av valfri numerisk typ: ``0``, ``0.0``, ``0j``, ``Decimal(0)``, "
"``Fraktion(0, 1)``"

#: ../../library/stdtypes.rst:61
msgid ""
"empty sequences and collections: ``''``, ``()``, ``[]``, ``{}``, ``set()``, "
"``range(0)``"
msgstr ""
"tomma sekvenser och samlingar: ``''``, ``()``, ``[]``, ``{}``, ``set()``, "
"``range(0)``"

#: ../../library/stdtypes.rst:70
msgid ""
"Operations and built-in functions that have a Boolean result always return "
"``0`` or ``False`` for false and ``1`` or ``True`` for true, unless "
"otherwise stated. (Important exception: the Boolean operations ``or`` and "
"``and`` always return one of their operands.)"
msgstr ""
"Operationer och inbyggda funktioner som har ett booleskt resultat returnerar "
"alltid ``0`` eller ``False`` för false och ``1`` eller ``True`` för true, om "
"inget annat anges. (Viktigt undantag: de booleska operationerna ``eller`` "
"och ``och`` returnerar alltid en av sina operander)"

#: ../../library/stdtypes.rst:79
msgid "Boolean Operations --- :keyword:`!and`, :keyword:`!or`, :keyword:`!not`"
msgstr ""
"Booleska operationer --- :keyword:`!and`, :keyword:`!or`, :keyword:`!not`"

#: ../../library/stdtypes.rst:83
msgid "These are the Boolean operations, ordered by ascending priority:"
msgstr "Dessa är de booleska operationerna, ordnade efter stigande prioritet:"

#: ../../library/stdtypes.rst:86 ../../library/stdtypes.rst:144
#: ../../library/stdtypes.rst:282 ../../library/stdtypes.rst:372
#: ../../library/stdtypes.rst:422 ../../library/stdtypes.rst:1007
#: ../../library/stdtypes.rst:1215
msgid "Operation"
msgstr "Operation"

#: ../../library/stdtypes.rst:86 ../../library/stdtypes.rst:282
#: ../../library/stdtypes.rst:372 ../../library/stdtypes.rst:422
#: ../../library/stdtypes.rst:1007 ../../library/stdtypes.rst:1215
msgid "Result"
msgstr "Resultat"

#: ../../library/stdtypes.rst:86 ../../library/stdtypes.rst:282
#: ../../library/stdtypes.rst:422 ../../library/stdtypes.rst:1007
#: ../../library/stdtypes.rst:1215 ../../library/stdtypes.rst:2772
#: ../../library/stdtypes.rst:4031
msgid "Notes"
msgstr "Anteckningar"

#: ../../library/stdtypes.rst:88
msgid "``x or y``"
msgstr "``x eller y``"

#: ../../library/stdtypes.rst:88
msgid "if *x* is true, then *x*, else *y*"
msgstr "om *x* är sant, då *x*, annars *y*"

#: ../../library/stdtypes.rst:88 ../../library/stdtypes.rst:1009
#: ../../library/stdtypes.rst:1012 ../../library/stdtypes.rst:1230
#: ../../library/stdtypes.rst:2778 ../../library/stdtypes.rst:4037
msgid "\\(1)"
msgstr "\\(1)"

#: ../../library/stdtypes.rst:91
msgid "``x and y``"
msgstr "``x och y``"

#: ../../library/stdtypes.rst:91
msgid "if *x* is false, then *x*, else *y*"
msgstr "om *x* är falskt, då *x*, annars *y*"

#: ../../library/stdtypes.rst:91 ../../library/stdtypes.rst:295
#: ../../library/stdtypes.rst:315 ../../library/stdtypes.rst:1258
#: ../../library/stdtypes.rst:2782 ../../library/stdtypes.rst:2784
#: ../../library/stdtypes.rst:4041 ../../library/stdtypes.rst:4043
msgid "\\(2)"
msgstr "\\(2)"

#: ../../library/stdtypes.rst:94
msgid "``not x``"
msgstr "``inte x``"

#: ../../library/stdtypes.rst:94
msgid "if *x* is false, then ``True``, else ``False``"
msgstr "om *x* är falskt, då ``True``, annars ``False``"

#: ../../library/stdtypes.rst:94 ../../library/stdtypes.rst:1261
#: ../../library/stdtypes.rst:2786 ../../library/stdtypes.rst:2788
#: ../../library/stdtypes.rst:2790 ../../library/stdtypes.rst:2792
#: ../../library/stdtypes.rst:4045 ../../library/stdtypes.rst:4047
#: ../../library/stdtypes.rst:4049 ../../library/stdtypes.rst:4051
msgid "\\(3)"
msgstr "\\(3)"

#: ../../library/stdtypes.rst:103 ../../library/stdtypes.rst:326
#: ../../library/stdtypes.rst:440 ../../library/stdtypes.rst:1058
#: ../../library/stdtypes.rst:1270 ../../library/stdtypes.rst:2818
#: ../../library/stdtypes.rst:4081
msgid "Notes:"
msgstr "Anteckningar:"

#: ../../library/stdtypes.rst:106
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is false."
msgstr ""
"Detta är en kortslutningsoperator, vilket innebär att den bara utvärderar "
"det andra argumentet om det första är falskt."

#: ../../library/stdtypes.rst:110
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is true."
msgstr ""
"Detta är en kortslutningsoperator, vilket innebär att den bara utvärderar "
"det andra argumentet om det första är sant."

#: ../../library/stdtypes.rst:114
msgid ""
"``not`` has a lower priority than non-Boolean operators, so ``not a == b`` "
"is interpreted as ``not (a == b)``, and ``a == not b`` is a syntax error."
msgstr ""
"``not`` har lägre prioritet än icke booleska operatorer, så ``not a == b`` "
"tolkas som ``not (a == b)``, och ``a == not b`` är ett syntaxfel."

#: ../../library/stdtypes.rst:121
msgid "Comparisons"
msgstr "Jämförelser"

#: ../../library/stdtypes.rst:135
msgid ""
"There are eight comparison operations in Python.  They all have the same "
"priority (which is higher than that of the Boolean operations).  Comparisons "
"can be chained arbitrarily; for example, ``x < y <= z`` is equivalent to ``x "
"< y and y <= z``, except that *y* is evaluated only once (but in both cases "
"*z* is not evaluated at all when ``x < y`` is found to be false)."
msgstr ""
"Det finns åtta jämförelseoperationer i Python.  De har alla samma prioritet "
"(som är högre än den för de booleska operationerna).  Jämförelser kan kedjas "
"godtyckligt; till exempel är ``x < y <= z`` ekvivalent med ``x < y och y <= "
"z``, förutom att *y* bara utvärderas en gång (men i båda fallen utvärderas "
"*z* inte alls när ``x < y`` visar sig vara falskt)."

#: ../../library/stdtypes.rst:141
msgid "This table summarizes the comparison operations:"
msgstr "I denna tabell sammanfattas jämförelseoperationerna:"

#: ../../library/stdtypes.rst:144 ../../library/stdtypes.rst:2604
#: ../../library/stdtypes.rst:2749 ../../library/stdtypes.rst:2772
#: ../../library/stdtypes.rst:4008 ../../library/stdtypes.rst:4031
msgid "Meaning"
msgstr "Betydelse"

#: ../../library/stdtypes.rst:146
msgid "``<``"
msgstr "``<``"

#: ../../library/stdtypes.rst:146
msgid "strictly less than"
msgstr "strikt mindre än"

#: ../../library/stdtypes.rst:148
msgid "``<=``"
msgstr "``<=``"

#: ../../library/stdtypes.rst:148
msgid "less than or equal"
msgstr "mindre än eller lika med"

#: ../../library/stdtypes.rst:150
msgid "``>``"
msgstr "``>``"

#: ../../library/stdtypes.rst:150
msgid "strictly greater than"
msgstr "strikt större än"

#: ../../library/stdtypes.rst:152
msgid "``>=``"
msgstr "``>=``"

#: ../../library/stdtypes.rst:152
msgid "greater than or equal"
msgstr "större än eller lika med"

#: ../../library/stdtypes.rst:154
msgid "``==``"
msgstr "``==``"

#: ../../library/stdtypes.rst:154
msgid "equal"
msgstr "lika"

#: ../../library/stdtypes.rst:156
msgid "``!=``"
msgstr "``!=``"

#: ../../library/stdtypes.rst:156
msgid "not equal"
msgstr "är inte lika med"

#: ../../library/stdtypes.rst:158
msgid "``is``"
msgstr "``är``"

#: ../../library/stdtypes.rst:158
msgid "object identity"
msgstr "objektets identitet"

#: ../../library/stdtypes.rst:160
msgid "``is not``"
msgstr "``är inte``"

#: ../../library/stdtypes.rst:160
msgid "negated object identity"
msgstr "förnekad objektsidentitet"

#: ../../library/stdtypes.rst:167
msgid ""
"Objects of different types, except different numeric types, never compare "
"equal. The ``==`` operator is always defined but for some object types (for "
"example, class objects) is equivalent to :keyword:`is`. The ``<``, ``<=``, "
"``>`` and ``>=`` operators are only defined where they make sense; for "
"example, they raise a :exc:`TypeError` exception when one of the arguments "
"is a complex number."
msgstr ""
"Objekt av olika typer, utom olika numeriska typer, jämför aldrig lika. "
"Operatorn ``==`` är alltid definierad men för vissa objekttyper (t.ex. "
"klassobjekt) är den ekvivalent med :keyword:`is`. Operatorerna ``<``, "
"``<=``, ``>`` och ``>=`` definieras endast där de är meningsfulla; till "
"exempel ger de upphov till ett :exc:`TypeError`-undantag när ett av "
"argumenten är ett komplext tal."

#: ../../library/stdtypes.rst:181
msgid ""
"Non-identical instances of a class normally compare as non-equal unless the "
"class defines the :meth:`~object.__eq__` method."
msgstr ""
"Icke-identiska instanser av en klass jämförs normalt som icke-jämlika om "
"inte klassen definierar metoden :meth:`~object.__eq__`."

#: ../../library/stdtypes.rst:184
msgid ""
"Instances of a class cannot be ordered with respect to other instances of "
"the same class, or other types of object, unless the class defines enough of "
"the methods :meth:`~object.__lt__`, :meth:`~object.__le__`, :meth:`~object."
"__gt__`, and :meth:`~object.__ge__` (in general, :meth:`~object.__lt__` and :"
"meth:`~object.__eq__` are sufficient, if you want the conventional meanings "
"of the comparison operators)."
msgstr ""
"Instanser av en klass kan inte ordnas med avseende på andra instanser av "
"samma klass eller andra typer av objekt, såvida inte klassen definierar "
"tillräckligt många av metoderna :meth:`~object.__lt__`, :meth:`~object."
"__le__`, :meth:`~object.__gt__`, och :meth:`~object.__ge__` (i allmänhet "
"räcker det med :meth:`~object.__lt__` och :meth:`~object.__eq__`, om man "
"vill ha de konventionella betydelserna av jämförelseoperatorerna)."

#: ../../library/stdtypes.rst:191
msgid ""
"The behavior of the :keyword:`is` and :keyword:`is not` operators cannot be "
"customized; also they can be applied to any two objects and never raise an "
"exception."
msgstr ""
"Beteendet hos operatörerna :keyword:`is` och :keyword:`is not` kan inte "
"anpassas; de kan också tillämpas på två valfria objekt och aldrig ge upphov "
"till ett undantag."

#: ../../library/stdtypes.rst:199
msgid ""
"Two more operations with the same syntactic priority, :keyword:`in` and :"
"keyword:`not in`, are supported by types that are :term:`iterable` or "
"implement the :meth:`~object.__contains__` method."
msgstr ""
"Ytterligare två operationer med samma syntaktiska prioritet, :keyword:`in` "
"och :keyword:`not in`, stöds av typer som är :term:`iterable` eller "
"implementerar metoden :meth:`~object.__contains__`."

#: ../../library/stdtypes.rst:206
msgid "Numeric Types --- :class:`int`, :class:`float`, :class:`complex`"
msgstr "Numeriska typer --- :class:`int`, :class:`float`, :class:`complex`"

#: ../../library/stdtypes.rst:216
msgid ""
"There are three distinct numeric types: :dfn:`integers`, :dfn:`floating-"
"point numbers`, and :dfn:`complex numbers`.  In addition, Booleans are a "
"subtype of integers.  Integers have unlimited precision.  Floating-point "
"numbers are usually implemented using :c:expr:`double` in C; information "
"about the precision and internal representation of floating-point numbers "
"for the machine on which your program is running is available in :data:`sys."
"float_info`.  Complex numbers have a real and imaginary part, which are each "
"a floating-point number.  To extract these parts from a complex number *z*, "
"use ``z.real`` and ``z.imag``. (The standard library includes the additional "
"numeric types :mod:`fractions.Fraction`, for rationals, and :mod:`decimal."
"Decimal`, for floating-point numbers with user-definable precision.)"
msgstr ""
"Det finns tre olika numeriska typer: :dfn:`integrer`, :dfn:`flytande tal` "
"och :dfn:`komplexa tal`.  Dessutom är booleaner en subtyp av heltal.  Heltal "
"har obegränsad precision.  Flyttal implementeras vanligtvis med :c:expr:"
"`double` i C; information om precisionen och den interna representationen av "
"flyttal för den maskin som ditt program körs på finns i :data:`sys."
"float_info`.  Komplexa tal har en reell del och en imaginär del, som var och "
"en är ett flyttal.  För att extrahera dessa delar från ett komplext tal *z*, "
"använd ``z.real`` och ``z.imag``. (Standardbiblioteket innehåller de "
"ytterligare numeriska typerna :mod:`fractions.Fraction`, för rationella tal, "
"och :mod:`decimal.Decimal`, för flyttal med precision som kan definieras av "
"användaren)"

#: ../../library/stdtypes.rst:238
msgid ""
"Numbers are created by numeric literals or as the result of built-in "
"functions and operators.  Unadorned integer literals (including hex, octal "
"and binary numbers) yield integers.  Numeric literals containing a decimal "
"point or an exponent sign yield floating-point numbers.  Appending ``'j'`` "
"or ``'J'`` to a numeric literal yields an imaginary number (a complex number "
"with a zero real part) which you can add to an integer or float to get a "
"complex number with real and imaginary parts."
msgstr ""
"Tal skapas av numeriska literaler eller som resultat av inbyggda funktioner "
"och operatorer.  Heltalslitteraler utan utsmyckning (inklusive hex-, oktal- "
"och binära tal) ger heltal.  Numeriska literaler som innehåller en "
"decimalpunkt eller ett exponenttecken ger flyttal.  Om du lägger till "
"``'j'`` eller ``'J'`` till en numerisk literal får du ett imaginärt tal (ett "
"komplext tal med en reell del på noll) som du kan lägga till ett heltal "
"eller en float för att få ett komplext tal med en reell och en imaginär del."

#: ../../library/stdtypes.rst:246
msgid ""
"The constructors :func:`int`, :func:`float`, and :func:`complex` can be used "
"to produce numbers of a specific type."
msgstr ""
"Konstruktörerna :func:`int`, :func:`float` och :func:`complex` kan användas "
"för att producera tal av en viss typ."

#: ../../library/stdtypes.rst:266
msgid ""
"Python fully supports mixed arithmetic: when a binary arithmetic operator "
"has operands of different numeric types, the operand with the \"narrower\" "
"type is widened to that of the other, where integer is narrower than "
"floating point. Arithmetic with complex and real operands is defined by the "
"usual mathematical formula, for example::"
msgstr ""
"Python har fullt stöd för blandad aritmetik: när en binär aritmetisk "
"operator har operander av olika numeriska typer, breddas operanden med den "
"\"smalare\" typen till den andra, där heltal är smalare än flyttal. "
"Aritmetik med komplexa och reella operander definieras av den vanliga "
"matematiska formeln, till exempel::"

#: ../../library/stdtypes.rst:272
msgid ""
"x + complex(u, v) = complex(x + u, v)\n"
"x * complex(u, v) = complex(x * u, x * v)"
msgstr ""
"x + komplex(u, v) = komplex(x + u, v)\n"
"x * komplex(u, v) = komplex(x * u, x * v)"

#: ../../library/stdtypes.rst:275
msgid ""
"A comparison between numbers of different types behaves as though the exact "
"values of those numbers were being compared. [2]_"
msgstr ""
"En jämförelse mellan tal av olika typer beter sig som om det var de exakta "
"värdena för dessa tal som jämfördes. [2]_"

#: ../../library/stdtypes.rst:278
msgid ""
"All numeric types (except complex) support the following operations (for "
"priorities of the operations, see :ref:`operator-summary`):"
msgstr ""
"Alla numeriska typer (utom komplexa) stöder följande operationer (för "
"prioriteringar av operationerna, se :ref:`operator-summary`):"

#: ../../library/stdtypes.rst:282
msgid "Full documentation"
msgstr "Fullständig dokumentation"

#: ../../library/stdtypes.rst:284
msgid "``x + y``"
msgstr "``x + y``"

#: ../../library/stdtypes.rst:284
msgid "sum of *x* and *y*"
msgstr "summan av *x* och *y*"

#: ../../library/stdtypes.rst:286
msgid "``x - y``"
msgstr "``x - y``"

#: ../../library/stdtypes.rst:286
msgid "difference of *x* and *y*"
msgstr "skillnaden mellan *x* och *y*"

#: ../../library/stdtypes.rst:288
msgid "``x * y``"
msgstr "``x * y``"

#: ../../library/stdtypes.rst:288
msgid "product of *x* and *y*"
msgstr "produkten av *x* och *y*"

#: ../../library/stdtypes.rst:290
msgid "``x / y``"
msgstr "``x / y``"

#: ../../library/stdtypes.rst:290
msgid "quotient of *x* and *y*"
msgstr "kvot av *x* och *y*"

#: ../../library/stdtypes.rst:292
msgid "``x // y``"
msgstr "``x // y```"

#: ../../library/stdtypes.rst:292
msgid "floored quotient of *x* and *y*"
msgstr "golvad kvot av *x* och *y*"

#: ../../library/stdtypes.rst:292
msgid "\\(1)\\(2)"
msgstr "\\(1)\\(2)"

#: ../../library/stdtypes.rst:295
msgid "``x % y``"
msgstr "``x % y``"

#: ../../library/stdtypes.rst:295
msgid "remainder of ``x / y``"
msgstr "återstoden av ``x / y``"

#: ../../library/stdtypes.rst:297
msgid "``-x``"
msgstr "``-x``"

#: ../../library/stdtypes.rst:297
msgid "*x* negated"
msgstr "*x* negerad"

#: ../../library/stdtypes.rst:299
msgid "``+x``"
msgstr "``+x``"

#: ../../library/stdtypes.rst:299
msgid "*x* unchanged"
msgstr "*x* oförändrad"

#: ../../library/stdtypes.rst:301
msgid "``abs(x)``"
msgstr "``abs(x)```"

#: ../../library/stdtypes.rst:301
msgid "absolute value or magnitude of *x*"
msgstr "absolut värde eller magnitud av *x*"

#: ../../library/stdtypes.rst:301
msgid ":func:`abs`"
msgstr ":func:`abs`"

#: ../../library/stdtypes.rst:304
msgid "``int(x)``"
msgstr "``int(x)```"

#: ../../library/stdtypes.rst:304
msgid "*x* converted to integer"
msgstr "*x* omvandlad till heltal"

#: ../../library/stdtypes.rst:304
msgid "\\(3)\\(6)"
msgstr "\\(3)\\(6)"

#: ../../library/stdtypes.rst:304
msgid ":func:`int`"
msgstr ":func:`int`"

#: ../../library/stdtypes.rst:306
msgid "``float(x)``"
msgstr "``flata(x)``"

#: ../../library/stdtypes.rst:306
msgid "*x* converted to floating point"
msgstr "*x* omvandlad till flyttal"

#: ../../library/stdtypes.rst:306
msgid "\\(4)\\(6)"
msgstr "\\(4)\\(6)"

#: ../../library/stdtypes.rst:306
msgid ":func:`float`"
msgstr ":func:`flöde`"

#: ../../library/stdtypes.rst:308
msgid "``complex(re, im)``"
msgstr "``komplex(re, im)``"

#: ../../library/stdtypes.rst:308
msgid ""
"a complex number with real part *re*, imaginary part *im*. *im* defaults to "
"zero."
msgstr ""
"ett komplext tal med realdel *re*, imaginärdel *im*. *im* är som standard "
"noll."

#: ../../library/stdtypes.rst:308 ../../library/stdtypes.rst:1251
#: ../../library/stdtypes.rst:2780 ../../library/stdtypes.rst:4068
msgid "\\(6)"
msgstr "\\(6)"

#: ../../library/stdtypes.rst:308
msgid ":func:`complex`"
msgstr ":func:`komplex`"

#: ../../library/stdtypes.rst:312
msgid "``c.conjugate()``"
msgstr "``c.konjugat()```"

#: ../../library/stdtypes.rst:312
msgid "conjugate of the complex number *c*"
msgstr "konjugat av det komplexa talet *c*"

#: ../../library/stdtypes.rst:315
msgid "``divmod(x, y)``"
msgstr "``divmod(x, y)``"

#: ../../library/stdtypes.rst:315
msgid "the pair ``(x // y, x % y)``"
msgstr "paret ``(x // y, x % y)```"

#: ../../library/stdtypes.rst:315
msgid ":func:`divmod`"
msgstr ":func:`divmod`"

#: ../../library/stdtypes.rst:317
msgid "``pow(x, y)``"
msgstr "``pow(x, y)``"

#: ../../library/stdtypes.rst:317 ../../library/stdtypes.rst:319
msgid "*x* to the power *y*"
msgstr "*x* till potensen *y*"

#: ../../library/stdtypes.rst:317 ../../library/stdtypes.rst:319
#: ../../library/stdtypes.rst:1240 ../../library/stdtypes.rst:1243
#: ../../library/stdtypes.rst:2805 ../../library/stdtypes.rst:2808
#: ../../library/stdtypes.rst:2811 ../../library/stdtypes.rst:4064
#: ../../library/stdtypes.rst:4071
msgid "\\(5)"
msgstr "\\(5)"

#: ../../library/stdtypes.rst:317
msgid ":func:`pow`"
msgstr ":func:`pow`"

#: ../../library/stdtypes.rst:319
msgid "``x ** y``"
msgstr "``x ** y``"

#: ../../library/stdtypes.rst:329
msgid ""
"Also referred to as integer division.  For operands of type :class:`int`, "
"the result has type :class:`int`.  For operands of type :class:`float`, the "
"result has type :class:`float`.  In general, the result is a whole integer, "
"though the result's type is not necessarily :class:`int`.  The result is "
"always rounded towards minus infinity: ``1//2`` is ``0``, ``(-1)//2`` is "
"``-1``, ``1//(-2)`` is ``-1``, and ``(-1)//(-2)`` is ``0``."
msgstr ""
"Kallas även heltalsdivision.  För operander av typen :class:`int` har "
"resultatet typen :class:`int`.  För operander av typen :class:`float` har "
"resultatet typen :class:`float`.  I allmänhet är resultatet ett helt heltal, "
"även om resultatets typ inte nödvändigtvis är :class:`int`.  Resultatet är "
"alltid avrundat mot minus oändligheten: ``1//2`` är ``0``, ``(-1)//2`` är "
"``-1``, ``1//(-2)`` är ``-1`` och ``(-1)//(-2)`` är ``0``."

#: ../../library/stdtypes.rst:337
msgid ""
"Not for complex numbers.  Instead convert to floats using :func:`abs` if "
"appropriate."
msgstr ""
"Inte för komplexa tal.  Konvertera istället till flyttal med :func:`abs` om "
"det är lämpligt."

#: ../../library/stdtypes.rst:348
msgid ""
"Conversion from :class:`float` to :class:`int` truncates, discarding the "
"fractional part. See functions :func:`math.floor` and :func:`math.ceil` for "
"alternative conversions."
msgstr ""
"Konvertering från :class:`float` till :class:`int` trunkerar och kastar bort "
"bråkdelen. Se funktionerna :func:`math.floor` och :func:`math.ceil` för "
"alternativa omvandlingar."

#: ../../library/stdtypes.rst:353
msgid ""
"float also accepts the strings \"nan\" and \"inf\" with an optional prefix "
"\"+\" or \"-\" for Not a Number (NaN) and positive or negative infinity."
msgstr ""
"float accepterar också strängarna \"nan\" och \"inf\" med ett valfritt "
"prefix \"+\" eller \"-\" för Not a Number (NaN) och positiv eller negativ "
"oändlighet."

#: ../../library/stdtypes.rst:357
msgid ""
"Python defines ``pow(0, 0)`` and ``0 ** 0`` to be ``1``, as is common for "
"programming languages."
msgstr ""
"Python definierar ``pow(0, 0)`` och ``0 ** 0`` som ``1``, vilket är vanligt "
"för programmeringsspråk."

#: ../../library/stdtypes.rst:361
msgid ""
"The numeric literals accepted include the digits ``0`` to ``9`` or any "
"Unicode equivalent (code points with the ``Nd`` property)."
msgstr ""
"De numeriska literaler som accepteras inkluderar siffrorna ``0`` till ``9`` "
"eller någon Unicode-ekvivalent (kodpunkter med egenskapen ``Nd``)."

#: ../../library/stdtypes.rst:364
msgid ""
"See `the Unicode Standard <https://unicode.org/Public/UNIDATA/extracted/"
"DerivedNumericType.txt>`_ for a complete list of code points with the ``Nd`` "
"property."
msgstr ""
"Se `the Unicode Standard <https://unicode.org/Public/UNIDATA/extracted/"
"DerivedNumericType.txt>`_ för en fullständig lista över kodpunkter med "
"egenskapen ``Nd``."

#: ../../library/stdtypes.rst:368
msgid ""
"All :class:`numbers.Real` types (:class:`int` and :class:`float`) also "
"include the following operations:"
msgstr ""
"Alla :class:`numbers.Real`-typer (:class:`int` och :class:`float`) "
"innehåller också följande operationer:"

#: ../../library/stdtypes.rst:374
msgid ":func:`math.trunc(\\ x) <math.trunc>`"
msgstr ":func:`math.trunc(\\ x) <math.trunc>`"

#: ../../library/stdtypes.rst:374
msgid "*x* truncated to :class:`~numbers.Integral`"
msgstr "*x* trunkerad till :class:`~numbers.Integral`"

#: ../../library/stdtypes.rst:377
msgid ":func:`round(x[, n]) <round>`"
msgstr ":func:`round(x[, n]) <round>`"

#: ../../library/stdtypes.rst:377
msgid ""
"*x* rounded to *n* digits, rounding half to even. If *n* is omitted, it "
"defaults to 0."
msgstr ""
"*x* avrundat till *n* siffror, avrundning hälften till jämnt. Om *n* "
"utelämnas är standardvärdet 0."

#: ../../library/stdtypes.rst:381
msgid ":func:`math.floor(\\ x) <math.floor>`"
msgstr ":func:`math.floor(\\ x) <math.floor>`"

#: ../../library/stdtypes.rst:381
msgid "the greatest :class:`~numbers.Integral` <= *x*"
msgstr "den största :class:`~numbers.Integral` <= *x*"

#: ../../library/stdtypes.rst:384
msgid ":func:`math.ceil(x) <math.ceil>`"
msgstr ":func:`math.ceil(x) <math.ceil>`"

#: ../../library/stdtypes.rst:384
msgid "the least :class:`~numbers.Integral` >= *x*"
msgstr "den minsta :class:`~numbers.Integral` >= *x*"

#: ../../library/stdtypes.rst:388
msgid ""
"For additional numeric operations see the :mod:`math` and :mod:`cmath` "
"modules."
msgstr ""
"För ytterligare numeriska operationer, se modulerna :mod:`math` och :mod:"
"`cmath`."

#: ../../library/stdtypes.rst:397
msgid "Bitwise Operations on Integer Types"
msgstr "Bitvisa operationer på heltalstyper"

#: ../../library/stdtypes.rst:411
msgid ""
"Bitwise operations only make sense for integers. The result of bitwise "
"operations is calculated as though carried out in two's complement with an "
"infinite number of sign bits."
msgstr ""
"Bitvisa operationer är bara meningsfulla för heltal. Resultatet av bitvisa "
"operationer beräknas som om de utförts i tvåkomplement med ett oändligt "
"antal teckenbitar."

#: ../../library/stdtypes.rst:415
msgid ""
"The priorities of the binary bitwise operations are all lower than the "
"numeric operations and higher than the comparisons; the unary operation "
"``~`` has the same priority as the other unary numeric operations (``+`` and "
"``-``)."
msgstr ""
"Prioriteringarna för de binära bitvisa operationerna är alla lägre än de "
"numeriska operationerna och högre än jämförelserna; den unära operationen "
"``~`` har samma prioritet som de andra unära numeriska operationerna (``+`` "
"och ``-``)."

#: ../../library/stdtypes.rst:419
msgid "This table lists the bitwise operations sorted in ascending priority:"
msgstr ""
"I denna tabell listas de bitvisa operationerna sorterade i stigande "
"prioritetsordning:"

#: ../../library/stdtypes.rst:424
msgid "``x | y``"
msgstr "``x | y``"

#: ../../library/stdtypes.rst:424
msgid "bitwise :dfn:`or` of *x* and *y*"
msgstr "bitvis :dfn:`or` av *x* och *y*"

#: ../../library/stdtypes.rst:424 ../../library/stdtypes.rst:427
#: ../../library/stdtypes.rst:430 ../../library/stdtypes.rst:1265
#: ../../library/stdtypes.rst:2794 ../../library/stdtypes.rst:2798
#: ../../library/stdtypes.rst:4053 ../../library/stdtypes.rst:4057
msgid "\\(4)"
msgstr "\\(4)"

#: ../../library/stdtypes.rst:427
msgid "``x ^ y``"
msgstr "``x ^ y``"

#: ../../library/stdtypes.rst:427
msgid "bitwise :dfn:`exclusive or` of *x* and *y*"
msgstr "bitvis :dfn:`exklusivt eller` av *x* och *y*"

#: ../../library/stdtypes.rst:430
msgid "``x & y``"
msgstr "``x & y``"

#: ../../library/stdtypes.rst:430
msgid "bitwise :dfn:`and` of *x* and *y*"
msgstr "bitvis :dfn:`och` av *x* och *y*"

#: ../../library/stdtypes.rst:433
msgid "``x << n``"
msgstr "``x << n```"

#: ../../library/stdtypes.rst:433
msgid "*x* shifted left by *n* bits"
msgstr "*x* vänsterförskjutet med *n* bitar"

#: ../../library/stdtypes.rst:433
msgid "(1)(2)"
msgstr "(1)(2)"

#: ../../library/stdtypes.rst:435
msgid "``x >> n``"
msgstr "``x >> n```"

#: ../../library/stdtypes.rst:435
msgid "*x* shifted right by *n* bits"
msgstr "*x* högerförskjutet med *n* bitar"

#: ../../library/stdtypes.rst:435
msgid "(1)(3)"
msgstr "(1)(3)"

#: ../../library/stdtypes.rst:437
msgid "``~x``"
msgstr "``~x``"

#: ../../library/stdtypes.rst:437
msgid "the bits of *x* inverted"
msgstr "bitarna i *x* inverterade"

#: ../../library/stdtypes.rst:443
msgid ""
"Negative shift counts are illegal and cause a :exc:`ValueError` to be raised."
msgstr "Negativa skifträkningar är olagliga och orsakar ett :exc:`ValueError`."

#: ../../library/stdtypes.rst:446
msgid ""
"A left shift by *n* bits is equivalent to multiplication by ``pow(2, n)``."
msgstr ""
"En vänsterförskjutning med *n* bitar är likvärdig med multiplikation med "
"``pow(2, n)``."

#: ../../library/stdtypes.rst:449
msgid ""
"A right shift by *n* bits is equivalent to floor division by ``pow(2, n)``."
msgstr ""
"En högerförskjutning med *n* bitar motsvarar en vågdivision med ``pow(2, "
"n)``."

#: ../../library/stdtypes.rst:452
msgid ""
"Performing these calculations with at least one extra sign extension bit in "
"a finite two's complement representation (a working bit-width of ``1 + max(x."
"bit_length(), y.bit_length())`` or more) is sufficient to get the same "
"result as if there were an infinite number of sign bits."
msgstr ""
"Att utföra dessa beräkningar med minst en extra teckenförlängningsbit i en "
"ändlig tvåkomplementrepresentation (en fungerande bitbredd på ``1 + max(x."
"bit_length(), y.bit_length())`` eller mer) är tillräckligt för att få samma "
"resultat som om det fanns ett oändligt antal teckenbitar."

#: ../../library/stdtypes.rst:459
msgid "Additional Methods on Integer Types"
msgstr "Ytterligare metoder för heltalstyper"

#: ../../library/stdtypes.rst:461
msgid ""
"The int type implements the :class:`numbers.Integral` :term:`abstract base "
"class`. In addition, it provides a few more methods:"
msgstr ""
"Typen int implementerar :class:`numbers.Integral` :term:`abstrakt basklass`. "
"Dessutom tillhandahåller den några fler metoder:"

#: ../../library/stdtypes.rst:466
msgid ""
"Return the number of bits necessary to represent an integer in binary, "
"excluding the sign and leading zeros::"
msgstr ""
"Returnerar det antal bitar som krävs för att representera ett heltal i binär "
"form, exklusive tecken och inledande nollor::"

#: ../../library/stdtypes.rst:469
msgid ""
">>> n = -37\n"
">>> bin(n)\n"
"'-0b100101'\n"
">>> n.bit_length()\n"
"6"
msgstr ""
">>> n = -37\n"
">>> bin(n)\n"
"'-0b100101'\n"
">>> n.bit_längd()\n"
"6"

#: ../../library/stdtypes.rst:475
msgid ""
"More precisely, if ``x`` is nonzero, then ``x.bit_length()`` is the unique "
"positive integer ``k`` such that ``2**(k-1) <= abs(x) < 2**k``. "
"Equivalently, when ``abs(x)`` is small enough to have a correctly rounded "
"logarithm, then ``k = 1 + int(log(abs(x), 2))``. If ``x`` is zero, then ``x."
"bit_length()`` returns ``0``."
msgstr ""
"Närmare bestämt, om ``x`` inte är noll, så är ``x.bit_length()`` det unika "
"positiva heltalet ``k`` så att ``2**(k-1) <= abs(x) < 2**k``. På motsvarande "
"sätt gäller att när ``abs(x)`` är tillräckligt litet för att ha en korrekt "
"avrundad logaritm, så är ``k = 1 + int(log(abs(x), 2))``. Om ``x`` är noll, "
"så returnerar ``x.bit_length()`` ``0``."

#: ../../library/stdtypes.rst:481 ../../library/stdtypes.rst:504
#: ../../library/stdtypes.rst:549 ../../library/stdtypes.rst:593
msgid "Equivalent to::"
msgstr "Motsvarar::"

#: ../../library/stdtypes.rst:483
msgid ""
"def bit_length(self):\n"
"    s = bin(self)       # binary representation:  bin(-37) --> '-0b100101'\n"
"    s = s.lstrip('-0b') # remove leading zeros and minus sign\n"
"    return len(s)       # len('100101') --> 6"
msgstr ""
"def bit_längd(self):\n"
"    s = bin(self) # binär representation: bin(-37) --> '-0b100101'\n"
"    s = s.lstrip('-0b') # ta bort ledande nollor och minustecken\n"
"    return len(s) # len('100101') --> 6"

#: ../../library/stdtypes.rst:492
msgid ""
"Return the number of ones in the binary representation of the absolute value "
"of the integer. This is also known as the population count. Example::"
msgstr ""
"Returnerar antalet ettor i den binära representationen av heltalets absoluta "
"värde. Detta är också känt som populationsantalet. Exempel::"

#: ../../library/stdtypes.rst:496
msgid ""
">>> n = 19\n"
">>> bin(n)\n"
"'0b10011'\n"
">>> n.bit_count()\n"
"3\n"
">>> (-n).bit_count()\n"
"3"
msgstr ""
">>> n = 19\n"
">>> bin(n)\n"
"'0b10011'\n"
">>> n.bit_räkning()\n"
"3\n"
">>> (-n).bit_count()\n"
"3"

#: ../../library/stdtypes.rst:506
msgid ""
"def bit_count(self):\n"
"    return bin(self).count(\"1\")"
msgstr ""
"def bit_count(self):\n"
"    return bin(self).count(\"1\")"

#: ../../library/stdtypes.rst:513
msgid "Return an array of bytes representing an integer."
msgstr "Returnerar en array av bytes som representerar ett heltal."

#: ../../library/stdtypes.rst:525
msgid ""
"The integer is represented using *length* bytes, and defaults to 1.  An :exc:"
"`OverflowError` is raised if the integer is not representable with the given "
"number of bytes."
msgstr ""
"Heltalet representeras med *längd* byte och standardvärdet är 1.  Ett :exc:"
"`OverflowError` uppstår om heltalet inte kan representeras med det givna "
"antalet byte."

#: ../../library/stdtypes.rst:529
msgid ""
"The *byteorder* argument determines the byte order used to represent the "
"integer, and defaults to ``\"big\"``.  If *byteorder* is ``\"big\"``, the "
"most significant byte is at the beginning of the byte array.  If *byteorder* "
"is ``\"little\"``, the most significant byte is at the end of the byte array."
msgstr ""
"Argumentet *byteorder* bestämmer den byteordning som används för att "
"representera heltalet, och standardvärdet är ``\"big\"``.  Om *byteorder* är "
"``\"big\"`` ligger den mest signifikanta byten i början av bytearrayen.  Om "
"*byteorder* är ``\"little\"`` ligger den mest signifikanta byten i slutet av "
"bytearrayen."

#: ../../library/stdtypes.rst:535
msgid ""
"The *signed* argument determines whether two's complement is used to "
"represent the integer.  If *signed* is ``False`` and a negative integer is "
"given, an :exc:`OverflowError` is raised. The default value for *signed* is "
"``False``."
msgstr ""
"Argumentet *signed* avgör om tvåkomplement används för att representera "
"heltalet.  Om *signed* är ``False`` och ett negativt heltal anges, uppstår "
"ett :exc:`OverflowError`. Standardvärdet för *signed* är ``False``."

#: ../../library/stdtypes.rst:540
msgid ""
"The default values can be used to conveniently turn an integer into a single "
"byte object::"
msgstr ""
"Standardvärdena kan användas för att enkelt omvandla ett heltal till ett "
"objekt med en byte::"

#: ../../library/stdtypes.rst:543
msgid ""
">>> (65).to_bytes()\n"
"b'A'"
msgstr ""
">>> (65).to_bytes()\n"
"b'A'"

#: ../../library/stdtypes.rst:546
msgid ""
"However, when using the default arguments, don't try to convert a value "
"greater than 255 or you'll get an :exc:`OverflowError`."
msgstr ""
"När du använder standardargumenten ska du dock inte försöka konvertera ett "
"värde som är större än 255, för då får du ett :exc:`OverflowError`."

#: ../../library/stdtypes.rst:551
msgid ""
"def to_bytes(n, length=1, byteorder='big', signed=False):\n"
"    if byteorder == 'little':\n"
"        order = range(length)\n"
"    elif byteorder == 'big':\n"
"        order = reversed(range(length))\n"
"    else:\n"
"        raise ValueError(\"byteorder must be either 'little' or 'big'\")\n"
"\n"
"    return bytes((n >> i*8) & 0xff for i in order)"
msgstr ""
"def to_bytes(n, length=1, byteorder='big', signed=False):\n"
"    om byteorder == 'liten':\n"
"        order = intervall(längd)\n"
"    elif byteorder == 'stor':\n"
"        ordning = omvänd(intervall(längd))\n"
"    else:\n"
"        raise ValueError(\"byteorder måste vara antingen 'liten' eller "
"'stor'\")\n"
"\n"
"    return bytes((n >> i*8) & 0xff for i in order)"

#: ../../library/stdtypes.rst:562
msgid "Added default argument values for ``length`` and ``byteorder``."
msgstr "Lagt till standardargumentvärden för ``length`` och ``byteorder``."

#: ../../library/stdtypes.rst:567
msgid "Return the integer represented by the given array of bytes."
msgstr "Returnerar det heltal som representeras av den givna arrayen av bytes."

#: ../../library/stdtypes.rst:580
msgid ""
"The argument *bytes* must either be a :term:`bytes-like object` or an "
"iterable producing bytes."
msgstr ""
"Argumentet *bytes* måste antingen vara ett :term:`bytesliknande objekt` "
"eller en iterabel som producerar bytes."

#: ../../library/stdtypes.rst:583
msgid ""
"The *byteorder* argument determines the byte order used to represent the "
"integer, and defaults to ``\"big\"``.  If *byteorder* is ``\"big\"``, the "
"most significant byte is at the beginning of the byte array.  If *byteorder* "
"is ``\"little\"``, the most significant byte is at the end of the byte "
"array.  To request the native byte order of the host system, use :data:`sys."
"byteorder` as the byte order value."
msgstr ""
"Argumentet *byteorder* bestämmer den byteordning som används för att "
"representera heltalet, och standardvärdet är ``\"big\"``.  Om *byteorder* är "
"``\"big\"`` ligger den mest signifikanta byten i början av bytearrayen.  Om "
"*byteorder* är ``\"little\"`` ligger den mest betydelsefulla byten i slutet "
"av bytearrayen.  Om du vill begära värdsystemets inbyggda byteordning "
"använder du :data:`sys.byteorder` som värde för byteordningen."

#: ../../library/stdtypes.rst:590
msgid ""
"The *signed* argument indicates whether two's complement is used to "
"represent the integer."
msgstr ""
"Argumentet *signed* anger om tvåkomplement ska användas för att representera "
"heltalet."

#: ../../library/stdtypes.rst:595
msgid ""
"def from_bytes(bytes, byteorder='big', signed=False):\n"
"    if byteorder == 'little':\n"
"        little_ordered = list(bytes)\n"
"    elif byteorder == 'big':\n"
"        little_ordered = list(reversed(bytes))\n"
"    else:\n"
"        raise ValueError(\"byteorder must be either 'little' or 'big'\")\n"
"\n"
"    n = sum(b << i*8 for i, b in enumerate(little_ordered))\n"
"    if signed and little_ordered and (little_ordered[-1] & 0x80):\n"
"        n -= 1 << 8*len(little_ordered)\n"
"\n"
"    return n"
msgstr ""
"def from_bytes(bytes, byteorder='big', signed=False):\n"
"    if byteorder == 'little':\n"
"        little_ordered = list(byte)\n"
"    elif byteorder == 'big':\n"
"        little_ordered = list(reversed(bytes))\n"
"    else:\n"
"        raise ValueError(\"byteorder måste vara antingen 'liten' eller "
"'stor'\")\n"
"\n"
"    n = sum(b << i*8 for i, b in enumerate(little_ordered))\n"
"    om signerad och little_ordered och (little_ordered[-1] & 0x80):\n"
"        n -= 1 << 8*len(little_ordered)\n"
"\n"
"    returnera n"

#: ../../library/stdtypes.rst:610
msgid "Added default argument value for ``byteorder``."
msgstr "Lagt till standardargumentvärde för ``byteorder``."

#: ../../library/stdtypes.rst:615
msgid ""
"Return a pair of integers whose ratio is equal to the original integer and "
"has a positive denominator.  The integer ratio of integers (whole numbers) "
"is always the integer as the numerator and ``1`` as the denominator."
msgstr ""
"Returnerar ett par heltal vars kvot är lika med det ursprungliga heltalet "
"och har en positiv nämnare.  Heltalsförhållandet mellan heltal (hela tal) är "
"alltid heltalet i täljaren och ``1`` i nämnaren."

#: ../../library/stdtypes.rst:624
msgid ""
"Returns ``True``. Exists for duck type compatibility with :meth:`float."
"is_integer`."
msgstr ""
"Returnerar ``True``. Existerar för kompatibilitet med :meth:`float."
"is_integer`."

#: ../../library/stdtypes.rst:629
msgid "Additional Methods on Float"
msgstr "Ytterligare metoder på Float"

#: ../../library/stdtypes.rst:631
msgid ""
"The float type implements the :class:`numbers.Real` :term:`abstract base "
"class`. float also has the following additional methods."
msgstr ""
"Typen float implementerar :class:`numbers.Real` :term:`abstrakt basklass`. "
"float har också följande ytterligare metoder."

#: ../../library/stdtypes.rst:636
msgid ""
"Class method to return a floating-point number constructed from a number *x*."
msgstr "Klassmetod för att returnera ett flyttal konstruerat från ett tal *x*."

#: ../../library/stdtypes.rst:638
msgid ""
"If the argument is an integer or a floating-point number, a floating-point "
"number with the same value (within Python's floating-point precision) is "
"returned.  If the argument is outside the range of a Python float, an :exc:"
"`OverflowError` will be raised."
msgstr ""
"Om argumentet är ett heltal eller ett flyttal, returneras ett flyttal med "
"samma värde (inom Pythons flyttalsprecision).  Om argumentet ligger utanför "
"intervallet för en Python-flottör, kommer ett :exc:`OverflowError` att "
"uppstå."

#: ../../library/stdtypes.rst:643
msgid ""
"For a general Python object ``x``, ``float.from_number(x)`` delegates to ``x."
"__float__()``. If :meth:`~object.__float__` is not defined then it falls "
"back to :meth:`~object.__index__`."
msgstr ""
"För ett allmänt Python-objekt ``x`` delegerar ``float.from_number(x)`` till "
"``x.__float__()``. Om :meth:`~object.__float__` inte är definierad faller "
"den tillbaka till :meth:`~object.__index__`."

#: ../../library/stdtypes.rst:653
msgid ""
"Return a pair of integers whose ratio is exactly equal to the original "
"float. The ratio is in lowest terms and has a positive denominator.  Raises :"
"exc:`OverflowError` on infinities and a :exc:`ValueError` on NaNs."
msgstr ""
"Returnerar ett par heltal vars kvot är exakt lika med den ursprungliga "
"floaten. Kvoten är i lägsta termer och har en positiv nämnare.  Utlöser :exc:"
"`OverflowError` på oändligheter och ett :exc:`ValueError` på NaNs."

#: ../../library/stdtypes.rst:660
msgid ""
"Return ``True`` if the float instance is finite with integral value, and "
"``False`` otherwise::"
msgstr ""
"Returnerar ``True`` om float-instansen är finit med integrerat värde, och "
"``False`` annars::"

#: ../../library/stdtypes.rst:663
msgid ""
">>> (-2.0).is_integer()\n"
"True\n"
">>> (3.2).is_integer()\n"
"False"
msgstr ""
">>> (-2.0).is_integer()\n"
"Sant\n"
">>> (3,2).is_integer()\n"
"Falskt"

#: ../../library/stdtypes.rst:668
msgid ""
"Two methods support conversion to and from hexadecimal strings.  Since "
"Python's floats are stored internally as binary numbers, converting a float "
"to or from a *decimal* string usually involves a small rounding error.  In "
"contrast, hexadecimal strings allow exact representation and specification "
"of floating-point numbers.  This can be useful when debugging, and in "
"numerical work."
msgstr ""
"Två metoder stöder konvertering till och från hexadecimala strängar.  "
"Eftersom Pythons flyttal lagras internt som binära tal innebär konvertering "
"av ett flyttal till eller från en *decimal* sträng vanligtvis ett litet "
"avrundningsfel.  Däremot tillåter hexadecimala strängar exakt representation "
"och specifikation av flyttal.  Detta kan vara användbart vid felsökning och "
"i numeriskt arbete."

#: ../../library/stdtypes.rst:679
msgid ""
"Return a representation of a floating-point number as a hexadecimal string.  "
"For finite floating-point numbers, this representation will always include a "
"leading ``0x`` and a trailing ``p`` and exponent."
msgstr ""
"Returnerar en representation av ett flyttal som en hexadecimal sträng.  För "
"finita flyttal kommer denna representation alltid att innehålla en inledande "
"``0x`` och en efterföljande ``p`` och exponent."

#: ../../library/stdtypes.rst:687
msgid ""
"Class method to return the float represented by a hexadecimal string *s*.  "
"The string *s* may have leading and trailing whitespace."
msgstr ""
"Klassmetod för att returnera den flottör som representeras av en hexadecimal "
"sträng *s*.  Strängen *s* kan ha inledande och avslutande blanksteg."

#: ../../library/stdtypes.rst:692
msgid ""
"Note that :meth:`float.hex` is an instance method, while :meth:`float."
"fromhex` is a class method."
msgstr ""
"Observera att :meth:`float.hex` är en instansmetod, medan :meth:`float."
"fromhex` är en klassmetod."

#: ../../library/stdtypes.rst:695
msgid "A hexadecimal string takes the form::"
msgstr "En hexadecimal sträng har formen::"

#: ../../library/stdtypes.rst:697
msgid "[sign] ['0x'] integer ['.' fraction] ['p' exponent]"
msgstr "[tecken] ['0x'] heltal ['.' bråk] ['p' exponent]"

#: ../../library/stdtypes.rst:699
msgid ""
"where the optional ``sign`` may by either ``+`` or ``-``, ``integer`` and "
"``fraction`` are strings of hexadecimal digits, and ``exponent`` is a "
"decimal integer with an optional leading sign.  Case is not significant, and "
"there must be at least one hexadecimal digit in either the integer or the "
"fraction.  This syntax is similar to the syntax specified in section 6.4.4.2 "
"of the C99 standard, and also to the syntax used in Java 1.5 onwards.  In "
"particular, the output of :meth:`float.hex` is usable as a hexadecimal "
"floating-point literal in C or Java code, and hexadecimal strings produced "
"by C's ``%a`` format character or Java's ``Double.toHexString`` are accepted "
"by :meth:`float.fromhex`."
msgstr ""
"där det valfria ``tecknet`` kan vara antingen ``+`` eller ``-``, ``integer`` "
"och ``fraction`` är strängar av hexadecimala siffror, och ``exponent`` är "
"ett decimalt heltal med ett valfritt inledande tecken.  Versaler är oviktiga "
"och det måste finnas minst en hexadecimal siffra i antingen heltalet eller "
"bråket.  Denna syntax liknar den syntax som anges i avsnitt 6.4.4.2 i C99-"
"standarden, och även den syntax som används i Java 1.5 och framåt.  I "
"synnerhet kan resultatet från :meth:`float.hex` användas som en hexadecimal "
"flyttalslitteral i C- eller Java-kod, och hexadecimala strängar som "
"produceras av C:s ``%a`` formattecken eller Javas ``Double.toHexString`` "
"accepteras av :meth:`float.fromhex`."

#: ../../library/stdtypes.rst:712
msgid ""
"Note that the exponent is written in decimal rather than hexadecimal, and "
"that it gives the power of 2 by which to multiply the coefficient. For "
"example, the hexadecimal string ``0x3.a7p10`` represents the floating-point "
"number ``(3 + 10./16 + 7./16**2) * 2.0**10``, or ``3740.0``::"
msgstr ""
"Observera att exponenten skrivs i decimalform i stället för hexadecimalform "
"och att den anger med vilken potens 2 koefficienten ska multipliceras. Till "
"exempel representerar den hexadecimala strängen ``0x3.a7p10`` flyttalstalet "
"``(3 + 10./16 + 7./16**2) * 2,0**10``, eller ``3740,0``::"

#: ../../library/stdtypes.rst:718
msgid ""
">>> float.fromhex('0x3.a7p10')\n"
"3740.0"
msgstr ""
">>> float.fromhex('0x3.a7p10')\n"
"3740.0"

#: ../../library/stdtypes.rst:722
msgid ""
"Applying the reverse conversion to ``3740.0`` gives a different hexadecimal "
"string representing the same number::"
msgstr ""
"Genom att tillämpa den omvända konverteringen på ``3740.0`` får man en annan "
"hexadecimal sträng som representerar samma nummer::"

#: ../../library/stdtypes.rst:725
msgid ""
">>> float.hex(3740.0)\n"
"'0x1.d380000000000p+11'"
msgstr ""
">>> float.hex(3740.0)\n"
"'0x1.d380000000000p+11'"

#: ../../library/stdtypes.rst:730
msgid "Additional Methods on Complex"
msgstr "Ytterligare metoder för komplexa"

#: ../../library/stdtypes.rst:732
msgid ""
"The :class:`!complex` type implements the :class:`numbers.Complex` :term:"
"`abstract base class`. :class:`!complex` also has the following additional "
"methods."
msgstr ""
"Typen :class:`!complex` implementerar :class:`numbers.Complex` :term:"
"`abstrakt basklass`. :class:`!complex` har även följande ytterligare metoder."

#: ../../library/stdtypes.rst:738
msgid "Class method to convert a number to a complex number."
msgstr "Klassmetod för att konvertera ett tal till ett komplext tal."

#: ../../library/stdtypes.rst:740
msgid ""
"For a general Python object ``x``, ``complex.from_number(x)`` delegates to "
"``x.__complex__()``.  If :meth:`~object.__complex__` is not defined then it "
"falls back to :meth:`~object.__float__`.  If :meth:`!__float__` is not "
"defined then it falls back to :meth:`~object.__index__`."
msgstr ""
"För ett allmänt Python-objekt ``x`` delegerar ``complex.from_number(x)`` "
"till ``x.__complex__()``.  Om :meth:`~object.__complex__` inte är definierad "
"så faller den tillbaka till :meth:`~object.__float__`.  Om :meth:`!"
"__float__` inte är definierat faller det tillbaka till :meth:`~object."
"__index__`."

#: ../../library/stdtypes.rst:751
msgid "Hashing of numeric types"
msgstr "Hashning av numeriska typer"

#: ../../library/stdtypes.rst:753
msgid ""
"For numbers ``x`` and ``y``, possibly of different types, it's a requirement "
"that ``hash(x) == hash(y)`` whenever ``x == y`` (see the :meth:`~object."
"__hash__` method documentation for more details).  For ease of "
"implementation and efficiency across a variety of numeric types (including :"
"class:`int`, :class:`float`, :class:`decimal.Decimal` and :class:`fractions."
"Fraction`) Python's hash for numeric types is based on a single mathematical "
"function that's defined for any rational number, and hence applies to all "
"instances of :class:`int` and :class:`fractions.Fraction`, and all finite "
"instances of :class:`float` and :class:`decimal.Decimal`.  Essentially, this "
"function is given by reduction modulo ``P`` for a fixed prime ``P``.  The "
"value of ``P`` is made available to Python as the :attr:`~sys.hash_info."
"modulus` attribute of :data:`sys.hash_info`."
msgstr ""
"För talen ``x`` och ``y``, eventuellt av olika typer, är det ett krav att "
"``hash(x) == hash(y)`` när ``x == y`` (se :meth:`~object.__hash__` "
"metoddokumentation för mer information).  För att underlätta implementering "
"och effektivitet över en mängd olika numeriska typer (inklusive :class:"
"`int`, :class:`float`, :class:`decimal.Decimal` och :class:`fractions."
"Fraction`) Pythons hash för numeriska typer baseras på en enda matematisk "
"funktion som är definierad för alla rationella tal, och gäller därför för "
"alla instanser av :class:`int` och :class:`fractions.Fraction`, och alla "
"ändliga instanser av :class:`float` och :class:`decimal.Decimal`.  I "
"huvudsak ges denna funktion genom reduktion modulo ``P`` för ett fast "
"primtal ``P``.  Värdet av ``P`` görs tillgängligt för Python som attributet :"
"attr:`~sys.hash_info.modulus` av :data:`sys.hash_info`."

#: ../../library/stdtypes.rst:768
msgid ""
"Currently, the prime used is ``P = 2**31 - 1`` on machines with 32-bit C "
"longs and ``P = 2**61 - 1`` on machines with 64-bit C longs."
msgstr ""
"För närvarande används primtalet ``P = 2**31 - 1`` på maskiner med 32-bitars "
"C-längder och ``P = 2**61 - 1`` på maskiner med 64-bitars C-längder."

#: ../../library/stdtypes.rst:771
msgid "Here are the rules in detail:"
msgstr "Här är reglerna i detalj:"

#: ../../library/stdtypes.rst:773
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is not divisible "
"by ``P``, define ``hash(x)`` as ``m * invmod(n, P) % P``, where ``invmod(n, "
"P)`` gives the inverse of ``n`` modulo ``P``."
msgstr ""
"Om ``x = m / n`` är ett nonnegativt rationellt tal och ``n`` inte är delbart "
"med ``P``, definiera ``hash(x)`` som ``m * invmod(n, P) % P``, där "
"``invmod(n, P)`` anger inversen av ``n`` modulo ``P``."

#: ../../library/stdtypes.rst:777
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is divisible by "
"``P`` (but ``m`` is not) then ``n`` has no inverse modulo ``P`` and the rule "
"above doesn't apply; in this case define ``hash(x)`` to be the constant "
"value ``sys.hash_info.inf``."
msgstr ""
"Om ``x = m / n`` är ett nonnegativt rationellt tal och ``n`` är delbart med "
"``P`` (men ``m`` inte är det) så har ``n`` ingen invers modulo ``P`` och "
"regeln ovan gäller inte; i detta fall definieras ``hash(x)`` som det "
"konstanta värdet ``sys.hash_info.inf``."

#: ../../library/stdtypes.rst:782
msgid ""
"If ``x = m / n`` is a negative rational number define ``hash(x)`` as ``-"
"hash(-x)``.  If the resulting hash is ``-1``, replace it with ``-2``."
msgstr ""
"Om ``x = m / n`` är ett negativt rationellt tal, definiera ``hash(x)`` som "
"``-hash(-x)``.  Om den resulterande hashen är ``-1``, ersätt den med ``-2``."

#: ../../library/stdtypes.rst:786
msgid ""
"The particular values ``sys.hash_info.inf`` and ``-sys.hash_info.inf`` are "
"used as hash values for positive infinity or negative infinity "
"(respectively)."
msgstr ""
"De särskilda värdena ``sys.hash_info.inf`` och ``-sys.hash_info.inf`` "
"används som hashvärden för positiv oändlighet respektive negativ oändlighet."

#: ../../library/stdtypes.rst:790
msgid ""
"For a :class:`complex` number ``z``, the hash values of the real and "
"imaginary parts are combined by computing ``hash(z.real) + sys.hash_info."
"imag * hash(z.imag)``, reduced modulo ``2**sys.hash_info.width`` so that it "
"lies in ``range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - "
"1))``.  Again, if the result is ``-1``, it's replaced with ``-2``."
msgstr ""
"För ett :class:`complex`-tal ``z`` kombineras hashvärdena för de reella och "
"imaginära delarna genom att beräkna ``hash(z.real) + sys.hash_info.imag * "
"hash(z.imag)``, reducerat modulo ``2**sys.hash_info.width`` så att det "
"ligger i ``range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - "
"1))``.  Återigen, om resultatet är ``-1`` ersätts det med ``-2``."

#: ../../library/stdtypes.rst:798
msgid ""
"To clarify the above rules, here's some example Python code, equivalent to "
"the built-in hash, for computing the hash of a rational number, :class:"
"`float`, or :class:`complex`::"
msgstr ""
"För att klargöra ovanstående regler följer här ett exempel på Python-kod, "
"motsvarande den inbyggda hashen, för att beräkna hashen för ett rationellt "
"tal, :class:`float`, eller :class:`complex`::"

#: ../../library/stdtypes.rst:803
msgid ""
"import sys, math\n"
"\n"
"def hash_fraction(m, n):\n"
"    \"\"\"Compute the hash of a rational number m / n.\n"
"\n"
"    Assumes m and n are integers, with n positive.\n"
"    Equivalent to hash(fractions.Fraction(m, n)).\n"
"\n"
"    \"\"\"\n"
"    P = sys.hash_info.modulus\n"
"    # Remove common factors of P.  (Unnecessary if m and n already "
"coprime.)\n"
"    while m % P == n % P == 0:\n"
"        m, n = m // P, n // P\n"
"\n"
"    if n % P == 0:\n"
"        hash_value = sys.hash_info.inf\n"
"    else:\n"
"        # Fermat's Little Theorem: pow(n, P-1, P) is 1, so\n"
"        # pow(n, P-2, P) gives the inverse of n modulo P.\n"
"        hash_value = (abs(m) % P) * pow(n, P - 2, P) % P\n"
"    if m < 0:\n"
"        hash_value = -hash_value\n"
"    if hash_value == -1:\n"
"        hash_value = -2\n"
"    return hash_value\n"
"\n"
"def hash_float(x):\n"
"    \"\"\"Compute the hash of a float x.\"\"\"\n"
"\n"
"    if math.isnan(x):\n"
"        return object.__hash__(x)\n"
"    elif math.isinf(x):\n"
"        return sys.hash_info.inf if x > 0 else -sys.hash_info.inf\n"
"    else:\n"
"        return hash_fraction(*x.as_integer_ratio())\n"
"\n"
"def hash_complex(z):\n"
"    \"\"\"Compute the hash of a complex number z.\"\"\"\n"
"\n"
"    hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z."
"imag)\n"
"    # do a signed reduction modulo 2**sys.hash_info.width\n"
"    M = 2**(sys.hash_info.width - 1)\n"
"    hash_value = (hash_value & (M - 1)) - (hash_value & M)\n"
"    if hash_value == -1:\n"
"        hash_value = -2\n"
"    return hash_value"
msgstr ""
"import sys, matematik\n"
"\n"
"def hash_fraktion(m, n):\n"
"    \"\"\"Beräkna hashvärdet av ett rationellt tal m / n.\n"
"\n"
"    Antar att m och n är heltal, med n positivt.\n"
"    Likvärdig med hash(fractions.Fraction(m, n)).\n"
"\n"
"    \"\"\"\n"
"    P = sys.hash_info.modulus\n"
"    # Ta bort gemensamma faktorer i P. (Onödigt om m och n redan är "
"coprime.)\n"
"    while m % P == n % P == 0:\n"
"        m, n = m // P, n // P\n"
"\n"
"    om n % P == 0:\n"
"        hash_värde = sys.hash_info.inf\n"
"    else:\n"
"        # Fermats lilla sats: pow(n, P-1, P) är 1, så\n"
"        # pow(n, P-2, P) ger inversen av n modulo P.\n"
"        hash_value = (abs(m) % P) * pow(n, P - 2, P) % P\n"
"    om m < 0:\n"
"        hash_värde = -hash_värde\n"
"    om hash_value == -1:\n"
"        hash_värde = -2\n"
"    returnera hash_värde\n"
"\n"
"def hash_float(x):\n"
"    \"\"\"Beräkna hashvärdet för en float x.\"\"\"\n"
"\n"
"    om math.isnan(x):\n"
"        returnera objekt.__hash__(x)\n"
"    elif math.isinf(x):\n"
"        return sys.hash_info.inf if x > 0 else -sys.hash_info.inf\n"
"    annat:\n"
"        return hash_fraction(*x.as_integer_ratio())\n"
"\n"
"def hash_komplex(z):\n"
"    \"\"\"Beräkna hashvärdet för ett komplext tal z.\"\"\"\n"
"\n"
"    hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z."
"imag)\n"
"    # gör en signerad reduktion modulo 2**sys.hash_info.width\n"
"    M = 2**(sys.hash_info.width - 1)\n"
"    hash_värde = (hash_värde & (M - 1)) - (hash_värde & M)\n"
"    om hash_value == -1:\n"
"        hash_värde = -2\n"
"    returnera hash_värde"

#: ../../library/stdtypes.rst:854
msgid "Boolean Type - :class:`bool`"
msgstr "Booleansk typ - :class:`bool`"

#: ../../library/stdtypes.rst:856
msgid ""
"Booleans represent truth values. The :class:`bool` type has exactly two "
"constant instances: ``True`` and ``False``."
msgstr ""
"Booleaner representerar sanningsvärden. Typen :class:`bool` har exakt två "
"konstanta instanser: ``True`` och ``False``."

#: ../../library/stdtypes.rst:864
msgid ""
"The built-in function :func:`bool`  converts any value to a boolean, if the "
"value can be interpreted as a truth value (see section :ref:`truth` above)."
msgstr ""
"Den inbyggda funktionen :func:`bool` konverterar ett värde till en boolean, "
"om värdet kan tolkas som ett sanningsvärde (se avsnitt :ref:`truth` ovan)."

#: ../../library/stdtypes.rst:867
msgid ""
"For logical operations, use the :ref:`boolean operators <boolean>` ``and``, "
"``or`` and ``not``. When applying the bitwise operators ``&``, ``|``, ``^`` "
"to two booleans, they return a bool equivalent to the logical operations "
"\"and\", \"or\", \"xor\". However, the logical operators ``and``, ``or`` and "
"``!=`` should be preferred over ``&``, ``|`` and ``^``."
msgstr ""
"För logiska operationer, använd :ref:`booleska operatorer <boolean>` "
"``and``, ``or`` och ``not``. När man använder de bitvisa operatorerna ``&amp;"
"``, ``|``, ``^`` på två booleaner returnerar de en bool som motsvarar de "
"logiska operationerna \"and\", \"or\", \"xor\". De logiska operatorerna "
"``och``, ``eller`` och ``!=`` bör dock föredras framför ``&amp;``, ``|`` och "
"``^``."

#: ../../library/stdtypes.rst:876
msgid ""
"The use of the bitwise inversion operator ``~`` is deprecated and will raise "
"an error in Python 3.16."
msgstr ""
"Användningen av den bitvisa inversionsoperatorn ``~`` är föråldrad och "
"kommer att ge upphov till ett fel i Python 3.16."

#: ../../library/stdtypes.rst:879
msgid ""
":class:`bool` is a subclass of :class:`int` (see :ref:`typesnumeric`). In "
"many numeric contexts, ``False`` and ``True`` behave like the integers 0 and "
"1, respectively. However, relying on this is discouraged; explicitly convert "
"using :func:`int` instead."
msgstr ""
":class:`bool` är en underklass till :class:`int` (se :ref:`typesnumeric`). I "
"många numeriska sammanhang beter sig ``False`` och ``True`` som heltalen 0 "
"respektive 1. Det är dock inte rekommenderat att förlita sig på detta; "
"konvertera explicit med :func:`int` istället."

#: ../../library/stdtypes.rst:887
msgid "Iterator Types"
msgstr "Iterator-typer"

#: ../../library/stdtypes.rst:895
msgid ""
"Python supports a concept of iteration over containers.  This is implemented "
"using two distinct methods; these are used to allow user-defined classes to "
"support iteration.  Sequences, described below in more detail, always "
"support the iteration methods."
msgstr ""
"Python stöder ett koncept för iteration över behållare.  Detta implementeras "
"med hjälp av två olika metoder; dessa används för att låta "
"användardefinierade klasser stödja iteration.  Sekvenser, som beskrivs mer i "
"detalj nedan, stöder alltid iterationsmetoderna."

#: ../../library/stdtypes.rst:900
msgid ""
"One method needs to be defined for container objects to provide :term:"
"`iterable` support:"
msgstr ""
"En metod måste definieras för containerobjekt för att ge stöd för :term:"
"`iterable`:"

#: ../../library/stdtypes.rst:907
msgid ""
"Return an :term:`iterator` object.  The object is required to support the "
"iterator protocol described below.  If a container supports different types "
"of iteration, additional methods can be provided to specifically request "
"iterators for those iteration types.  (An example of an object supporting "
"multiple forms of iteration would be a tree structure which supports both "
"breadth-first and depth-first traversal.)  This method corresponds to the :c:"
"member:`~PyTypeObject.tp_iter` slot of the type structure for Python objects "
"in the Python/C API."
msgstr ""
"Returnerar ett :term:`iterator`-objekt.  Objektet måste ha stöd för "
"iteratorprotokollet som beskrivs nedan.  Om en container stöder olika typer "
"av iteration kan ytterligare metoder tillhandahållas för att specifikt "
"begära iteratorer för dessa iterationstyper.  (Ett exempel på ett objekt som "
"stöder flera former av iteration är en trädstruktur som stöder både bredd-"
"först- och djup-först-traversering)  Denna metod motsvarar :c:member:"
"`~PyTypeObject.tp_iter` slot i typstrukturen för Python-objekt i Python/C "
"API."

#: ../../library/stdtypes.rst:916
msgid ""
"The iterator objects themselves are required to support the following two "
"methods, which together form the :dfn:`iterator protocol`:"
msgstr ""
"Själva iteratorobjekten måste stödja följande två metoder, som tillsammans "
"utgör :dfn:`iteratorprotokollet`:"

#: ../../library/stdtypes.rst:922
msgid ""
"Return the :term:`iterator` object itself.  This is required to allow both "
"containers and iterators to be used with the :keyword:`for` and :keyword:"
"`in` statements.  This method corresponds to the :c:member:`~PyTypeObject."
"tp_iter` slot of the type structure for Python objects in the Python/C API."
msgstr ""
"Returnerar själva :term:`iterator`-objektet.  Detta krävs för att både "
"containers och iteratorer ska kunna användas med :keyword:`for` och :keyword:"
"`in` satserna.  Denna metod motsvarar :c:member:`~PyTypeObject.tp_iter`-"
"platsen i typstrukturen för Python-objekt i Python/C API."

#: ../../library/stdtypes.rst:931
msgid ""
"Return the next item from the :term:`iterator`.  If there are no further "
"items, raise the :exc:`StopIteration` exception.  This method corresponds to "
"the :c:member:`~PyTypeObject.tp_iternext` slot of the type structure for "
"Python objects in the Python/C API."
msgstr ""
"Returnerar nästa objekt från :term:`iterator`.  Om det inte finns några fler "
"objekt, utlöses undantaget :exc:`StopIteration`.  Denna metod motsvarar :c:"
"member:`~PyTypeObject.tp_iternext`-platsen i typstrukturen för Python-objekt "
"i Python/C API."

#: ../../library/stdtypes.rst:936
msgid ""
"Python defines several iterator objects to support iteration over general "
"and specific sequence types, dictionaries, and other more specialized "
"forms.  The specific types are not important beyond their implementation of "
"the iterator protocol."
msgstr ""
"Python definierar flera iteratorobjekt för att stödja iteration över "
"allmänna och specifika sekvenstyper, ordböcker och andra mer specialiserade "
"former.  De specifika typerna är inte viktiga utöver deras implementering av "
"iteratorprotokollet."

#: ../../library/stdtypes.rst:941
msgid ""
"Once an iterator's :meth:`~iterator.__next__` method raises :exc:"
"`StopIteration`, it must continue to do so on subsequent calls. "
"Implementations that do not obey this property are deemed broken."
msgstr ""
"När en iterators :meth:`~iterator.__next__`-metod ger upphov till :exc:"
"`StopIteration`, måste den fortsätta att göra det vid efterföljande anrop. "
"Implementationer som inte följer denna egenskap anses vara trasiga."

#: ../../library/stdtypes.rst:949
msgid "Generator Types"
msgstr "Typer av generatorer"

#: ../../library/stdtypes.rst:951
msgid ""
"Python's :term:`generator`\\s provide a convenient way to implement the "
"iterator protocol.  If a container object's :meth:`~object.__iter__` method "
"is implemented as a generator, it will automatically return an iterator "
"object (technically, a generator object) supplying the :meth:`~iterator."
"__iter__` and :meth:`~generator.__next__` methods. More information about "
"generators can be found in :ref:`the documentation for the yield expression "
"<yieldexpr>`."
msgstr ""
"Pythons :term:`generator` ger ett bekvämt sätt att implementera "
"iteratorprotokollet.  Om ett containerobjekts metod :meth:`~object.__iter__` "
"implementeras som en generator, kommer den automatiskt att returnera ett "
"iteratorobjekt (tekniskt sett ett generatorobjekt) som tillhandahåller "
"metoderna :meth:`~iterator.__iter__` och :meth:`~generator.__next__`. Mer "
"information om generatorer finns i :ref:``dokumentationen för yield-"
"uttrycket <yieldexpr>`."

#: ../../library/stdtypes.rst:963
msgid "Sequence Types --- :class:`list`, :class:`tuple`, :class:`range`"
msgstr "Sekvenstyper --- :class:`list`, :class:`tuple`, :class:`range`"

#: ../../library/stdtypes.rst:965
msgid ""
"There are three basic sequence types: lists, tuples, and range objects. "
"Additional sequence types tailored for processing of :ref:`binary data "
"<binaryseq>` and :ref:`text strings <textseq>` are described in dedicated "
"sections."
msgstr ""
"Det finns tre grundläggande sekvenstyper: listor, tupler och "
"intervallobjekt. Ytterligare sekvenstyper som är skräddarsydda för "
"bearbetning av :ref:``binärdata <binaryseq>`` och :ref:``textsträngar "
"<textseq>`` beskrivs i särskilda avsnitt."

#: ../../library/stdtypes.rst:974
msgid "Common Sequence Operations"
msgstr "Vanliga sekvensoperationer"

#: ../../library/stdtypes.rst:978
msgid ""
"The operations in the following table are supported by most sequence types, "
"both mutable and immutable. The :class:`collections.abc.Sequence` ABC is "
"provided to make it easier to correctly implement these operations on custom "
"sequence types."
msgstr ""
"Operationerna i följande tabell stöds av de flesta sekvenstyper, både "
"föränderliga och oföränderliga. ABC :class:`collections.abc.Sequence` "
"tillhandahålls för att göra det enklare att korrekt implementera dessa "
"operationer på anpassade sekvenstyper."

#: ../../library/stdtypes.rst:983
msgid ""
"This table lists the sequence operations sorted in ascending priority.  In "
"the table, *s* and *t* are sequences of the same type, *n*, *i*, *j* and *k* "
"are integers and *x* is an arbitrary object that meets any type and value "
"restrictions imposed by *s*."
msgstr ""
"I denna tabell listas sekvensoperationerna sorterade i stigande prioritet.  "
"I tabellen är *s* och *t* sekvenser av samma typ, *n*, *i*, *j* och *k* är "
"heltal och *x* är ett godtyckligt objekt som uppfyller alla typ- och "
"värdebegränsningar som *s* ställer upp."

#: ../../library/stdtypes.rst:988
msgid ""
"The ``in`` and ``not in`` operations have the same priorities as the "
"comparison operations. The ``+`` (concatenation) and ``*`` (repetition) "
"operations have the same priority as the corresponding numeric operations. "
"[3]_"
msgstr ""
"Operationerna ``in`` och ``not in`` har samma prioritet som "
"jämförelseoperationerna. Operationerna ``+`` (konkatenering) och ``*`` "
"(repetition) har samma prioritet som motsvarande numeriska operationer. [3]_"

#: ../../library/stdtypes.rst:1009
msgid "``x in s``"
msgstr "``x i s```"

#: ../../library/stdtypes.rst:1009
msgid "``True`` if an item of *s* is equal to *x*, else ``False``"
msgstr "``True`` om ett objekt i *s* är lika med *x*, annars ``False``"

#: ../../library/stdtypes.rst:1012
msgid "``x not in s``"
msgstr "``x inte i s```"

#: ../../library/stdtypes.rst:1012
msgid "``False`` if an item of *s* is equal to *x*, else ``True``"
msgstr "``False`` om ett objekt i *s* är lika med *x*, annars ``True``"

#: ../../library/stdtypes.rst:1015
msgid "``s + t``"
msgstr "``s + t``"

#: ../../library/stdtypes.rst:1015
msgid "the concatenation of *s* and *t*"
msgstr "sammankopplingen av *s* och *t*"

#: ../../library/stdtypes.rst:1015
msgid "(6)(7)"
msgstr "(6)(7)"

#: ../../library/stdtypes.rst:1018
msgid "``s * n`` or ``n * s``"
msgstr "``s * n`` eller ``n * s``"

#: ../../library/stdtypes.rst:1018
msgid "equivalent to adding *s* to itself *n* times"
msgstr "motsvarar att addera *s* till sig själv *n* gånger"

#: ../../library/stdtypes.rst:1018
msgid "(2)(7)"
msgstr "(2)(7)"

#: ../../library/stdtypes.rst:1021
msgid "``s[i]``"
msgstr "``s[i]``"

#: ../../library/stdtypes.rst:1021
msgid "*i*\\ th item of *s*, origin 0"
msgstr "*i*\\ det tredje objektet i *s*, ursprung 0"

#: ../../library/stdtypes.rst:1021
msgid "(3)(9)"
msgstr "(3)(9)"

#: ../../library/stdtypes.rst:1023
msgid "``s[i:j]``"
msgstr "``s[i:j]``"

#: ../../library/stdtypes.rst:1023
msgid "slice of *s* from *i* to *j*"
msgstr "skiva av *s* från *i* till *j*"

#: ../../library/stdtypes.rst:1023
msgid "(3)(4)"
msgstr "(3)(4)"

#: ../../library/stdtypes.rst:1025
msgid "``s[i:j:k]``"
msgstr "``[i:j:k]``"

#: ../../library/stdtypes.rst:1025
msgid "slice of *s* from *i* to *j* with step *k*"
msgstr "skiva av *s* från *i* till *j* med steg *k*"

#: ../../library/stdtypes.rst:1025
msgid "(3)(5)"
msgstr "(3)(5)"

#: ../../library/stdtypes.rst:1028
msgid "``len(s)``"
msgstr "``len(s)```"

#: ../../library/stdtypes.rst:1028
msgid "length of *s*"
msgstr "längd på *s*"

#: ../../library/stdtypes.rst:1030
msgid "``min(s)``"
msgstr "``min(s)```"

#: ../../library/stdtypes.rst:1030
msgid "smallest item of *s*"
msgstr "minsta delen av *s*"

#: ../../library/stdtypes.rst:1032
msgid "``max(s)``"
msgstr "``max(s)```"

#: ../../library/stdtypes.rst:1032
msgid "largest item of *s*"
msgstr "största posten av *s*"

#: ../../library/stdtypes.rst:1034
msgid "``s.index(x[, i[, j]])``"
msgstr "``s.index(x[, i[, j]])``"

#: ../../library/stdtypes.rst:1034
msgid ""
"index of the first occurrence of *x* in *s* (at or after index *i* and "
"before index *j*)"
msgstr ""
"index för den första förekomsten av *x* i *s* (vid eller efter index *i* och "
"före index *j*)"

#: ../../library/stdtypes.rst:1034 ../../library/stdtypes.rst:4039
msgid "\\(8)"
msgstr "\\(8)"

#: ../../library/stdtypes.rst:1038
msgid "``s.count(x)``"
msgstr "``s.count(x)``"

#: ../../library/stdtypes.rst:1038
msgid "total number of occurrences of *x* in *s*"
msgstr "totalt antal förekomster av *x* i *s*"

#: ../../library/stdtypes.rst:1042
msgid ""
"Sequences of the same type also support comparisons.  In particular, tuples "
"and lists are compared lexicographically by comparing corresponding "
"elements. This means that to compare equal, every element must compare equal "
"and the two sequences must be of the same type and have the same length.  "
"(For full details see :ref:`comparisons` in the language reference.)"
msgstr ""
"Sekvenser av samma typ stöder också jämförelser.  Framför allt jämförs "
"tupler och listor lexikografiskt genom att jämföra motsvarande element. "
"Detta innebär att för att jämföra lika måste varje element jämföra lika och "
"de två sekvenserna måste vara av samma typ och ha samma längd.  (För "
"fullständig information se :ref:`comparisons` i språkreferensen)"

#: ../../library/stdtypes.rst:1052
msgid ""
"Forward and reversed iterators over mutable sequences access values using an "
"index.  That index will continue to march forward (or backward) even if the "
"underlying sequence is mutated.  The iterator terminates only when an :exc:"
"`IndexError` or a :exc:`StopIteration` is encountered (or when the index "
"drops below zero)."
msgstr ""
"Framåtriktade och bakåtriktade iteratorer över muterbara sekvenser får "
"tillgång till värden med hjälp av ett index.  Detta index kommer att "
"fortsätta att marschera framåt (eller bakåt) även om den underliggande "
"sekvensen muteras.  Iteratorn avslutas först när ett :exc:`IndexError` eller "
"ett :exc:`StopIteration` inträffar (eller när indexet sjunker under noll)."

#: ../../library/stdtypes.rst:1061
msgid ""
"While the ``in`` and ``not in`` operations are used only for simple "
"containment testing in the general case, some specialised sequences (such "
"as :class:`str`, :class:`bytes` and :class:`bytearray`) also use them for "
"subsequence testing::"
msgstr ""
"Medan operationerna ``in`` och ``not in`` endast används för enkel testning "
"av inneslutning i det allmänna fallet, använder vissa specialiserade "
"sekvenser (t.ex. :class:`str`, :class:`bytes` och :class:`bytearray`) dem "
"också för testning av undersekvenser::"

#: ../../library/stdtypes.rst:1066
msgid ""
">>> \"gg\" in \"eggs\"\n"
"True"
msgstr ""
">>> \"gg\" i \"ägg\"\n"
"Sant"

#: ../../library/stdtypes.rst:1070
msgid ""
"Values of *n* less than ``0`` are treated as ``0`` (which yields an empty "
"sequence of the same type as *s*).  Note that items in the sequence *s* are "
"not copied; they are referenced multiple times.  This often haunts new "
"Python programmers; consider::"
msgstr ""
"Värden av *n* mindre än ``0`` behandlas som ``0`` (vilket ger en tom sekvens "
"av samma typ som *s*).  Observera att objekt i sekvensen *s* inte kopieras; "
"de refereras flera gånger.  Detta spökar ofta för nya Python-programmerare; "
"tänk på::"

#: ../../library/stdtypes.rst:1075
msgid ""
">>> lists = [[]] * 3\n"
">>> lists\n"
"[[], [], []]\n"
">>> lists[0].append(3)\n"
">>> lists\n"
"[[3], [3], [3]]"
msgstr ""
">>> listor = [[]] * 3\n"
">>> listor\n"
"[[], [], []]\n"
">>> listor[0].append(3)\n"
">>> listor\n"
"[[3], [3], [3]]"

#: ../../library/stdtypes.rst:1082
msgid ""
"What has happened is that ``[[]]`` is a one-element list containing an empty "
"list, so all three elements of ``[[]] * 3`` are references to this single "
"empty list.  Modifying any of the elements of ``lists`` modifies this single "
"list. You can create a list of different lists this way::"
msgstr ""
"Vad som har hänt är att ``[]]`` är en lista med ett element som innehåller "
"en tom lista, så alla tre elementen i ``[]] * 3`` är referenser till denna "
"enda tomma lista.  Om du ändrar något av elementen i ``lists`` ändras denna "
"enda lista. Du kan skapa en lista med olika listor på följande sätt::"

#: ../../library/stdtypes.rst:1087
msgid ""
">>> lists = [[] for i in range(3)]\n"
">>> lists[0].append(3)\n"
">>> lists[1].append(5)\n"
">>> lists[2].append(7)\n"
">>> lists\n"
"[[3], [5], [7]]"
msgstr ""
">>> lists = [[] for i in range(3)] >>> lists[0].append(3)\n"
">>> listor[0].lägg till(3)\n"
">>> listor[1].append(5)\n"
">>> listor[2].append(7)\n"
">>> listor\n"
"[[3], [5], [7]]"

#: ../../library/stdtypes.rst:1094
msgid ""
"Further explanation is available in the FAQ entry :ref:`faq-multidimensional-"
"list`."
msgstr ""
"Ytterligare förklaringar finns i FAQ-artikeln :ref:`faq-multidimensional-"
"list`."

#: ../../library/stdtypes.rst:1098
msgid ""
"If *i* or *j* is negative, the index is relative to the end of sequence *s*: "
"``len(s) + i`` or ``len(s) + j`` is substituted.  But note that ``-0`` is "
"still ``0``."
msgstr ""
"Om *i* eller *j* är negativ, är indexet relativt slutet av sekvensen *s*: "
"``len(s) + i`` eller ``len(s) + j`` ersätts.  Men observera att ``-0`` "
"fortfarande är ``0``."

#: ../../library/stdtypes.rst:1103
msgid ""
"The slice of *s* from *i* to *j* is defined as the sequence of items with "
"index *k* such that ``i <= k < j``.  If *i* or *j* is greater than "
"``len(s)``, use ``len(s)``.  If *i* is omitted or ``None``, use ``0``.  If "
"*j* is omitted or ``None``, use ``len(s)``.  If *i* is greater than or equal "
"to *j*, the slice is empty."
msgstr ""
"Slice av *s* från *i* till *j* definieras som den sekvens av objekt med "
"index *k* som är sådan att ``i <= k < j``.  Om *i* eller *j* är större än "
"``len(s)``, använd ``len(s)``.  Om *i* är utelämnad eller ``None``, använd "
"``0``.  Om *j* utelämnas eller ``None``, använd ``len(s)``.  Om *i* är "
"större än eller lika med *j* är skivan tom."

#: ../../library/stdtypes.rst:1110
msgid ""
"The slice of *s* from *i* to *j* with step *k* is defined as the sequence of "
"items with index  ``x = i + n*k`` such that ``0 <= n < (j-i)/k``.  In other "
"words, the indices are ``i``, ``i+k``, ``i+2*k``, ``i+3*k`` and so on, "
"stopping when *j* is reached (but never including *j*).  When *k* is "
"positive, *i* and *j* are reduced to ``len(s)`` if they are greater. When "
"*k* is negative, *i* and *j* are reduced to ``len(s) - 1`` if they are "
"greater.  If *i* or *j* are omitted or ``None``, they become \"end\" values "
"(which end depends on the sign of *k*).  Note, *k* cannot be zero. If *k* is "
"``None``, it is treated like ``1``."
msgstr ""
"Slice av *s* från *i* till *j* med steg *k* definieras som sekvensen av "
"objekt med index ``x = i + n*k`` så att ``0 <= n < (j-i)/k``.  Med andra ord "
"är indexen ``i``, ``i+k``, ``i+2*k``, ``i+3*k`` och så vidare, med stopp när "
"*j* nås (men aldrig inklusive *j*).  När *k* är positiv reduceras *i* och "
"*j* till ``len(s)`` om de är större. När *k* är negativ reduceras *i* och "
"*j* till ``len(s) - 1`` om de är större.  Om *i* eller *j* utelämnas eller "
"är ``None``, blir de \"slut\"-värden (vilket slut beror på tecknet för "
"*k*).  Observera att *k* inte kan vara noll. Om *k* är ``None`` behandlas "
"det som ``1``."

#: ../../library/stdtypes.rst:1121
msgid ""
"Concatenating immutable sequences always results in a new object.  This "
"means that building up a sequence by repeated concatenation will have a "
"quadratic runtime cost in the total sequence length.  To get a linear "
"runtime cost, you must switch to one of the alternatives below:"
msgstr ""
"Sammankoppling av oföränderliga sekvenser resulterar alltid i ett nytt "
"objekt.  Detta innebär att uppbyggnaden av en sekvens genom upprepad "
"konkatenering får en kvadratisk körtidskostnad i den totala sekvenslängden.  "
"För att få en linjär körtidskostnad måste du byta till något av alternativen "
"nedan:"

#: ../../library/stdtypes.rst:1126
msgid ""
"if concatenating :class:`str` objects, you can build a list and use :meth:"
"`str.join` at the end or else write to an :class:`io.StringIO` instance and "
"retrieve its value when complete"
msgstr ""
"om du sammanfogar :class:`str`-objekt kan du bygga en lista och använda :"
"meth:`str.join` i slutet eller skriva till en :class:`io.StringIO`-instans "
"och hämta dess värde när du är klar"

#: ../../library/stdtypes.rst:1130
msgid ""
"if concatenating :class:`bytes` objects, you can similarly use :meth:`bytes."
"join` or :class:`io.BytesIO`, or you can do in-place concatenation with a :"
"class:`bytearray` object.  :class:`bytearray` objects are mutable and have "
"an efficient overallocation mechanism"
msgstr ""
"om du konkatenerar :class:`bytes`-objekt kan du på samma sätt använda :meth:"
"`bytes.join` eller :class:`io.BytesIO`, eller så kan du göra konkatenering "
"på plats med ett :class:`bytearray`-objekt. :class:`bytearray`-objekt är "
"muterbara och har en effektiv mekanism för overallokering"

#: ../../library/stdtypes.rst:1135
msgid "if concatenating :class:`tuple` objects, extend a :class:`list` instead"
msgstr ""
"om du konkatenerar :class:`tuple`-objekt, förläng en :class:`list` istället"

#: ../../library/stdtypes.rst:1137
msgid "for other types, investigate the relevant class documentation"
msgstr "för andra typer, undersök den relevanta klassdokumentationen"

#: ../../library/stdtypes.rst:1141
msgid ""
"Some sequence types (such as :class:`range`) only support item sequences "
"that follow specific patterns, and hence don't support sequence "
"concatenation or repetition."
msgstr ""
"Vissa sekvenstyper (t.ex. :class:`range`) stöder endast sekvenser av objekt "
"som följer specifika mönster och stöder därför inte sammankoppling eller "
"upprepning av sekvenser."

#: ../../library/stdtypes.rst:1146
msgid ""
"``index`` raises :exc:`ValueError` when *x* is not found in *s*. Not all "
"implementations support passing the additional arguments *i* and *j*. These "
"arguments allow efficient searching of subsections of the sequence. Passing "
"the extra arguments is roughly equivalent to using ``s[i:j].index(x)``, only "
"without copying any data and with the returned index being relative to the "
"start of the sequence rather than the start of the slice."
msgstr ""
"``index`` ger upphov till :exc:`ValueError` när *x* inte finns i *s*. Det är "
"inte alla implementationer som stöder de ytterligare argumenten *i* och *j*. "
"Dessa argument möjliggör effektiv sökning av underavsnitt av sekvensen. Att "
"skicka de extra argumenten motsvarar i stort sett att använda ``s[i:j]."
"index(x)``, men utan att kopiera några data och med det returnerade indexet "
"i förhållande till början av sekvensen snarare än början av skivan."

#: ../../library/stdtypes.rst:1154
msgid "An :exc:`IndexError` is raised if *i* is outside the sequence range."
msgstr ""
"Ett :exc:`IndexError` uppstår om *i* ligger utanför sekvensintervallet."

#: ../../library/stdtypes.rst:1160
msgid "Immutable Sequence Types"
msgstr "Oföränderliga sekvenstyper"

#: ../../library/stdtypes.rst:1167
msgid ""
"The only operation that immutable sequence types generally implement that is "
"not also implemented by mutable sequence types is support for the :func:"
"`hash` built-in."
msgstr ""
"Den enda operation som oföränderliga sekvenstyper i allmänhet implementerar "
"och som inte också implementeras av föränderliga sekvenstyper är stöd för "
"den inbyggda :func:`hash`."

#: ../../library/stdtypes.rst:1171
msgid ""
"This support allows immutable sequences, such as :class:`tuple` instances, "
"to be used as :class:`dict` keys and stored in :class:`set` and :class:"
"`frozenset` instances."
msgstr ""
"Detta stöd gör att oföränderliga sekvenser, t.ex. :class:`tuple`-instanser, "
"kan användas som :class:`dict`-nycklar och lagras i :class:`set`- och :class:"
"`frozenset`-instanser."

#: ../../library/stdtypes.rst:1175
msgid ""
"Attempting to hash an immutable sequence that contains unhashable values "
"will result in :exc:`TypeError`."
msgstr ""
"Försök att hasha en oföränderlig sekvens som innehåller värden som inte kan "
"hashas kommer att resultera i :exc:`TypeError`."

#: ../../library/stdtypes.rst:1182
msgid "Mutable Sequence Types"
msgstr "Mutabla sekvenstyper"

#: ../../library/stdtypes.rst:1189
msgid ""
"The operations in the following table are defined on mutable sequence types. "
"The :class:`collections.abc.MutableSequence` ABC is provided to make it "
"easier to correctly implement these operations on custom sequence types."
msgstr ""
"Operationerna i följande tabell är definierade för mutabla sekvenstyper. "
"Klassen :`collections.abc.MutableSequence` ABC tillhandahålls för att göra "
"det enklare att korrekt implementera dessa operationer på anpassade "
"sekvenstyper."

#: ../../library/stdtypes.rst:1193
msgid ""
"In the table *s* is an instance of a mutable sequence type, *t* is any "
"iterable object and *x* is an arbitrary object that meets any type and value "
"restrictions imposed by *s* (for example, :class:`bytearray` only accepts "
"integers that meet the value restriction ``0 <= x <= 255``)."
msgstr ""
"I tabellen är *s* en instans av en föränderlig sekvenstyp, *t* är ett "
"itererbart objekt och *x* är ett godtyckligt objekt som uppfyller alla typ- "
"och värdebegränsningar som *s* ställer (till exempel accepterar :class:"
"`bytearray` endast heltal som uppfyller värdebegränsningen ``0 <= x <= "
"255``)."

#: ../../library/stdtypes.rst:1217
msgid "``s[i] = x``"
msgstr "``s[i] = x``"

#: ../../library/stdtypes.rst:1217
msgid "item *i* of *s* is replaced by *x*"
msgstr "post *i* i *s* ska ersättas med *x*"

#: ../../library/stdtypes.rst:1220
msgid "``del s[i]``"
msgstr "``del s[i]```"

#: ../../library/stdtypes.rst:1220
msgid "removes item *i* of *s*"
msgstr "tar bort objekt *i* av *s*"

#: ../../library/stdtypes.rst:1222
msgid "``s[i:j] = t``"
msgstr "``s[i:j] = t``"

#: ../../library/stdtypes.rst:1222
msgid ""
"slice of *s* from *i* to *j* is replaced by the contents of the iterable *t*"
msgstr "slice av *s* från *i* till *j* ersätts av innehållet i iterabeln *t*"

#: ../../library/stdtypes.rst:1226
msgid "``del s[i:j]``"
msgstr "``del s[i:j]``"

#: ../../library/stdtypes.rst:1226
msgid ""
"removes the elements of ``s[i:j]`` from the list (same as ``s[i:j] = []``)"
msgstr ""
"tar bort elementen i ``s[i:j]`` från listan (samma som ``s[i:j] = []``)"

#: ../../library/stdtypes.rst:1230
msgid "``s[i:j:k] = t``"
msgstr "``s[i:j:k] = t``"

#: ../../library/stdtypes.rst:1230
msgid "the elements of ``s[i:j:k]`` are replaced by those of *t*"
msgstr "elementen i ``s[i:j:k]`` ersätts med elementen i *t*"

#: ../../library/stdtypes.rst:1233
msgid "``del s[i:j:k]``"
msgstr "``del s[i:j:k]``"

#: ../../library/stdtypes.rst:1233
msgid "removes the elements of ``s[i:j:k]`` from the list"
msgstr "tar bort elementen i ``s[i:j:k]`` från listan"

#: ../../library/stdtypes.rst:1236
msgid "``s.append(x)``"
msgstr "``s.append(x)``"

#: ../../library/stdtypes.rst:1236
msgid ""
"appends *x* to the end of the sequence (same as ``s[len(s):len(s)] = [x]``)"
msgstr ""
"lägger till *x* i slutet av sekvensen (samma som ``s[len(s):len(s)] = [x]``)"

#: ../../library/stdtypes.rst:1240
msgid "``s.clear()``"
msgstr "``s.clear()``"

#: ../../library/stdtypes.rst:1240
msgid "removes all items from *s* (same as ``del s[:]``)"
msgstr "tar bort alla objekt från *s* (samma som ``del s[:]``)"

#: ../../library/stdtypes.rst:1243
msgid "``s.copy()``"
msgstr "``s.copy()``"

#: ../../library/stdtypes.rst:1243
msgid "creates a shallow copy of *s* (same as ``s[:]``)"
msgstr "skapar en ytlig kopia av *s* (samma som ``s[:]``)"

#: ../../library/stdtypes.rst:1246
msgid "``s.extend(t)`` or ``s += t``"
msgstr "``s.extend(t)`` eller ``s += t``"

#: ../../library/stdtypes.rst:1246
msgid ""
"extends *s* with the contents of *t* (for the most part the same as "
"``s[len(s):len(s)] = t``)"
msgstr ""
"utökar *s* med innehållet i *t* (till största delen samma sak som ``s[len(s):"
"len(s)] = t``)"

#: ../../library/stdtypes.rst:1251
msgid "``s *= n``"
msgstr "``s *= n```"

#: ../../library/stdtypes.rst:1251
msgid "updates *s* with its contents repeated *n* times"
msgstr "uppdaterar *s* med dess innehåll upprepade *n* gånger"

#: ../../library/stdtypes.rst:1254
msgid "``s.insert(i, x)``"
msgstr "``s.insert(i, x)``"

#: ../../library/stdtypes.rst:1254
msgid ""
"inserts *x* into *s* at the index given by *i* (same as ``s[i:i] = [x]``)"
msgstr ""
"infogar *x* i *s* vid det index som anges av *i* (samma som ``s[i:i] = [x]``)"

#: ../../library/stdtypes.rst:1258
msgid "``s.pop()`` or ``s.pop(i)``"
msgstr "``s.pop()`` eller ``s.pop(i)``"

#: ../../library/stdtypes.rst:1258
msgid "retrieves the item at *i* and also removes it from *s*"
msgstr "hämtar objektet på *i* och tar även bort det från *s*"

#: ../../library/stdtypes.rst:1261
msgid "``s.remove(x)``"
msgstr "``s.remove(x)``"

#: ../../library/stdtypes.rst:1261
msgid "removes the first item from *s* where ``s[i]`` is equal to *x*"
msgstr "tar bort det första objektet från *s* där ``s[i]`` är lika med *x*"

#: ../../library/stdtypes.rst:1265
msgid "``s.reverse()``"
msgstr "``s.reverse()``"

#: ../../library/stdtypes.rst:1265
msgid "reverses the items of *s* in place"
msgstr "vänder posterna av *s* på plats"

#: ../../library/stdtypes.rst:1273
msgid ""
"If *k* is not equal to ``1``, *t* must have the same length as the slice it "
"is replacing."
msgstr ""
"Om *k* inte är lika med ``1``, måste *t* ha samma längd som den skiva den "
"ersätter."

#: ../../library/stdtypes.rst:1276
msgid ""
"The optional argument *i* defaults to ``-1``, so that by default the last "
"item is removed and returned."
msgstr ""
"Det valfria argumentet *i* är som standard ``-1``, så att det sista objektet "
"som standard tas bort och returneras."

#: ../../library/stdtypes.rst:1280
msgid ":meth:`remove` raises :exc:`ValueError` when *x* is not found in *s*."
msgstr ""
":meth:`remove` ger upphov till :exc:`ValueError` när *x* inte finns i *s*."

#: ../../library/stdtypes.rst:1283
msgid ""
"The :meth:`reverse` method modifies the sequence in place for economy of "
"space when reversing a large sequence.  To remind users that it operates by "
"side effect, it does not return the reversed sequence."
msgstr ""
"Metoden :meth:`reverse` modifierar sekvensen på plats för att spara utrymme "
"vid omkastning av en stor sekvens.  För att påminna användarna om att den "
"fungerar som en bieffekt returnerar den inte den omvända sekvensen."

#: ../../library/stdtypes.rst:1288
msgid ""
":meth:`clear` and :meth:`!copy` are included for consistency with the "
"interfaces of mutable containers that don't support slicing operations (such "
"as :class:`dict` and :class:`set`). :meth:`!copy` is not part of the :class:"
"`collections.abc.MutableSequence` ABC, but most concrete mutable sequence "
"classes provide it."
msgstr ""
":meth:`clear` och :meth:`!copy` ingår för att vara konsekventa med "
"gränssnitten för mutabla behållare som inte stöder skivningsoperationer (t."
"ex. :class:`dict` och :class:`set`). :meth:`!copy` är inte en del av :class:"
"``collections.abc.MutableSequence` ABC, men de flesta konkreta klasser för "
"mutabla sekvenser har det."

#: ../../library/stdtypes.rst:1294
msgid ":meth:`clear` and :meth:`!copy` methods."
msgstr "metoderna :meth:`clear` och :meth:`!copy`."

#: ../../library/stdtypes.rst:1298
msgid ""
"The value *n* is an integer, or an object implementing :meth:`~object."
"__index__`.  Zero and negative values of *n* clear the sequence.  Items in "
"the sequence are not copied; they are referenced multiple times, as "
"explained for ``s * n`` under :ref:`typesseq-common`."
msgstr ""
"Värdet *n* är ett heltal eller ett objekt som implementerar :meth:`~object."
"__index__`.  Noll och negativa värden på *n* rensar sekvensen.  Objekten i "
"sekvensen kopieras inte; de refereras flera gånger, vilket förklaras för ``s "
"* n`` under :ref:`typesseq-common`."

#: ../../library/stdtypes.rst:1307
msgid "Lists"
msgstr "Listor"

#: ../../library/stdtypes.rst:1311
msgid ""
"Lists are mutable sequences, typically used to store collections of "
"homogeneous items (where the precise degree of similarity will vary by "
"application)."
msgstr ""
"Listor är föränderliga sekvenser som vanligtvis används för att lagra "
"samlingar av homogena objekt (där den exakta graden av likhet varierar "
"beroende på tillämpning)."

#: ../../library/stdtypes.rst:1317
msgid "Lists may be constructed in several ways:"
msgstr "Listor kan byggas upp på flera olika sätt:"

#: ../../library/stdtypes.rst:1319
msgid "Using a pair of square brackets to denote the empty list: ``[]``"
msgstr "Använd ett par hakparenteser för att beteckna den tomma listan: ``[]``"

#: ../../library/stdtypes.rst:1320
msgid ""
"Using square brackets, separating items with commas: ``[a]``, ``[a, b, c]``"
msgstr ""
"Använd hakparenteser och separera objekt med kommatecken: ``[a]``, ``[a, b, "
"c]``"

#: ../../library/stdtypes.rst:1321
msgid "Using a list comprehension: ``[x for x in iterable]``"
msgstr "Använda en listförståelse: ``[x for x in iterable]``"

#: ../../library/stdtypes.rst:1322
msgid "Using the type constructor: ``list()`` or ``list(iterable)``"
msgstr "Använda typkonstruktören: ``list()`` eller ``list(iterable)``"

#: ../../library/stdtypes.rst:1324
msgid ""
"The constructor builds a list whose items are the same and in the same order "
"as *iterable*'s items.  *iterable* may be either a sequence, a container "
"that supports iteration, or an iterator object.  If *iterable* is already a "
"list, a copy is made and returned, similar to ``iterable[:]``. For example, "
"``list('abc')`` returns ``['a', 'b', 'c']`` and ``list( (1, 2, 3) )`` "
"returns ``[1, 2, 3]``. If no argument is given, the constructor creates a "
"new empty list, ``[]``."
msgstr ""
"Konstruktorn bygger en lista vars objekt är desamma och i samma ordning som "
"*iterable*:s objekt.  *iterable* kan vara antingen en sekvens, en behållare "
"som stöder iteration eller ett iteratorobjekt.  Om *iterable* redan är en "
"lista görs en kopia och returneras, på samma sätt som ``iterable[:]``. Till "
"exempel returnerar ``list('abc')`` ``['a', 'b', 'c']`` och ``list( (1, 2, "
"3) )`` returnerar ``[1, 2, 3]``. Om inget argument anges skapar "
"konstruktören en ny tom lista, ``[]``."

#: ../../library/stdtypes.rst:1333
msgid ""
"Many other operations also produce lists, including the :func:`sorted` built-"
"in."
msgstr ""
"Många andra operationer producerar också listor, inklusive den inbyggda :"
"func:`sorted`."

#: ../../library/stdtypes.rst:1336
msgid ""
"Lists implement all of the :ref:`common <typesseq-common>` and :ref:`mutable "
"<typesseq-mutable>` sequence operations. Lists also provide the following "
"additional method:"
msgstr ""
"Listor implementerar alla :ref:`common <typesseq-common>` och :ref:`mutable "
"<typesseq-mutable>` sekvensoperationer. Listor tillhandahåller också "
"följande ytterligare metod:"

#: ../../library/stdtypes.rst:1342
msgid ""
"This method sorts the list in place, using only ``<`` comparisons between "
"items. Exceptions are not suppressed - if any comparison operations fail, "
"the entire sort operation will fail (and the list will likely be left in a "
"partially modified state)."
msgstr ""
"Den här metoden sorterar listan på plats och använder endast ``<``-"
"jämförelser mellan objekten. Undantag undertrycks inte - om någon "
"jämförelseoperation misslyckas, kommer hela sorteringsoperationen att "
"misslyckas (och listan kommer sannolikt att lämnas i ett delvis modifierat "
"tillstånd)."

#: ../../library/stdtypes.rst:1347
msgid ""
":meth:`sort` accepts two arguments that can only be passed by keyword (:ref:"
"`keyword-only arguments <keyword-only_parameter>`):"
msgstr ""
":meth:`sort` accepterar två argument som endast kan skickas med nyckelord (:"
"ref:`keyword-only arguments <keyword-only_parameter>`):"

#: ../../library/stdtypes.rst:1350
msgid ""
"*key* specifies a function of one argument that is used to extract a "
"comparison key from each list element (for example, ``key=str.lower``). The "
"key corresponding to each item in the list is calculated once and then used "
"for the entire sorting process. The default value of ``None`` means that "
"list items are sorted directly without calculating a separate key value."
msgstr ""
"*key* anger en funktion med ett argument som används för att extrahera en "
"jämförelsenyckel från varje listelement (t.ex. ``key=str.lower``). Den "
"nyckel som motsvarar varje objekt i listan beräknas en gång och används "
"sedan för hela sorteringsprocessen. Standardvärdet ``None`` innebär att "
"listobjekten sorteras direkt utan att ett separat nyckelvärde beräknas."

#: ../../library/stdtypes.rst:1357
msgid ""
"The :func:`functools.cmp_to_key` utility is available to convert a 2.x style "
"*cmp* function to a *key* function."
msgstr ""
"Verktyget :func:`functools.cmp_to_key` är tillgängligt för att konvertera en "
"*cmp*-funktion i 2.x-stil till en *key*-funktion."

#: ../../library/stdtypes.rst:1360
msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the list elements "
"are sorted as if each comparison were reversed."
msgstr ""
"*reverse* är ett booleanskt värde.  Om värdet är satt till ``True`` sorteras "
"listelementen som om varje jämförelse vore omvänd."

#: ../../library/stdtypes.rst:1363
msgid ""
"This method modifies the sequence in place for economy of space when sorting "
"a large sequence.  To remind users that it operates by side effect, it does "
"not return the sorted sequence (use :func:`sorted` to explicitly request a "
"new sorted list instance)."
msgstr ""
"Denna metod modifierar sekvensen på plats för att spara utrymme vid "
"sortering av en stor sekvens.  För att påminna användarna om att den "
"fungerar som en bieffekt returneras inte den sorterade sekvensen (använd :"
"func:`sorted` för att uttryckligen begära en ny instans av en sorterad "
"lista)."

#: ../../library/stdtypes.rst:1368
msgid ""
"The :meth:`sort` method is guaranteed to be stable.  A sort is stable if it "
"guarantees not to change the relative order of elements that compare equal "
"--- this is helpful for sorting in multiple passes (for example, sort by "
"department, then by salary grade)."
msgstr ""
"Metoden :meth:`sort` är garanterat stabil.  En sortering är stabil om den "
"garanterar att den inte ändrar den relativa ordningen på element som jämförs "
"lika --- detta är användbart för sortering i flera omgångar (t.ex. sortera "
"efter avdelning, sedan efter lönegrad)."

#: ../../library/stdtypes.rst:1373
msgid ""
"For sorting examples and a brief sorting tutorial, see :ref:`sortinghowto`."
msgstr ""
"För sorteringsexempel och en kort sorteringshandledning, se :ref:"
"`sortinghowto`."

#: ../../library/stdtypes.rst:1377
msgid ""
"While a list is being sorted, the effect of attempting to mutate, or even "
"inspect, the list is undefined.  The C implementation of Python makes the "
"list appear empty for the duration, and raises :exc:`ValueError` if it can "
"detect that the list has been mutated during a sort."
msgstr ""
"När en lista sorteras är effekten av att försöka mutera, eller till och med "
"inspektera, listan odefinierad.  C-implementeringen av Python gör att listan "
"ser tom ut under tiden och ger :exc:`ValueError` om den kan upptäcka att "
"listan har muterats under en sortering."

#: ../../library/stdtypes.rst:1386
msgid "Tuples"
msgstr "Tupler"

#: ../../library/stdtypes.rst:1390
msgid ""
"Tuples are immutable sequences, typically used to store collections of "
"heterogeneous data (such as the 2-tuples produced by the :func:`enumerate` "
"built-in). Tuples are also used for cases where an immutable sequence of "
"homogeneous data is needed (such as allowing storage in a :class:`set` or :"
"class:`dict` instance)."
msgstr ""
"Tupler är oföränderliga sekvenser som vanligtvis används för att lagra "
"samlingar av heterogena data (t.ex. de 2-tupler som produceras av den "
"inbyggda :func:`enumerate`). Tuples används också i fall där en oföränderlig "
"sekvens av homogena data behövs (t.ex. för att tillåta lagring i en :class:"
"`set`- eller :class:`dict`-instans)."

#: ../../library/stdtypes.rst:1398
msgid "Tuples may be constructed in a number of ways:"
msgstr "Tupler kan konstrueras på ett antal olika sätt:"

#: ../../library/stdtypes.rst:1400
msgid "Using a pair of parentheses to denote the empty tuple: ``()``"
msgstr "Använda ett par parenteser för att beteckna den tomma tupeln: ``()``"

#: ../../library/stdtypes.rst:1401
msgid "Using a trailing comma for a singleton tuple: ``a,`` or ``(a,)``"
msgstr ""
"Använda ett efterföljande kommatecken för en singleton-tupel: ``a,`` eller "
"``(a,)``"

#: ../../library/stdtypes.rst:1402
msgid "Separating items with commas: ``a, b, c`` or ``(a, b, c)``"
msgstr "Separera objekt med kommatecken: ``a, b, c`` eller ``(a, b, c)``"

#: ../../library/stdtypes.rst:1403
msgid "Using the :func:`tuple` built-in: ``tuple()`` or ``tuple(iterable)``"
msgstr ""
"Använda den inbyggda :func:`tuple`: ``tuple()`` eller ``tuple(iterable)``"

#: ../../library/stdtypes.rst:1405
msgid ""
"The constructor builds a tuple whose items are the same and in the same "
"order as *iterable*'s items.  *iterable* may be either a sequence, a "
"container that supports iteration, or an iterator object.  If *iterable* is "
"already a tuple, it is returned unchanged. For example, ``tuple('abc')`` "
"returns ``('a', 'b', 'c')`` and ``tuple( [1, 2, 3] )`` returns ``(1, 2, "
"3)``. If no argument is given, the constructor creates a new empty tuple, "
"``()``."
msgstr ""
"Konstruktorn bygger en tupel vars poster är desamma och i samma ordning som "
"*iterable*s poster.  *iterable* kan vara antingen en sekvens, en behållare "
"som stöder iteration eller ett iteratorobjekt.  Om *iterable* redan är en "
"tupel returneras den oförändrad. Till exempel returnerar ``tuple('abc')`` "
"``('a', 'b', 'c')`` och ``tuple( [1, 2, 3] )`` returnerar ``(1, 2, 3)``. Om "
"inget argument anges skapar konstruktören en ny tom tupel, ``()``."

#: ../../library/stdtypes.rst:1413
msgid ""
"Note that it is actually the comma which makes a tuple, not the parentheses. "
"The parentheses are optional, except in the empty tuple case, or when they "
"are needed to avoid syntactic ambiguity. For example, ``f(a, b, c)`` is a "
"function call with three arguments, while ``f((a, b, c))`` is a function "
"call with a 3-tuple as the sole argument."
msgstr ""
"Observera att det faktiskt är kommatecknet som skapar en tupel, inte "
"parentesen. Parenteserna är valfria, utom i fallet med en tom tupel, eller "
"när de behövs för att undvika syntaktisk tvetydighet. Till exempel är ``f(a, "
"b, c)`` ett funktionsanrop med tre argument, medan ``f((a, b, c))`` är ett "
"funktionsanrop med en 3-tupel som enda argument."

#: ../../library/stdtypes.rst:1419
msgid ""
"Tuples implement all of the :ref:`common <typesseq-common>` sequence "
"operations."
msgstr ""
"Tupler implementerar alla :ref:`common <typesseq-common>` sekvensoperationer."

#: ../../library/stdtypes.rst:1422
msgid ""
"For heterogeneous collections of data where access by name is clearer than "
"access by index, :func:`collections.namedtuple` may be a more appropriate "
"choice than a simple tuple object."
msgstr ""
"För heterogena samlingar av data där åtkomst via namn är tydligare än "
"åtkomst via index kan :func:`collections.namedtuple` vara ett lämpligare val "
"än ett enkelt tuple-objekt."

#: ../../library/stdtypes.rst:1430
msgid "Ranges"
msgstr "Intervaller"

#: ../../library/stdtypes.rst:1434
msgid ""
"The :class:`range` type represents an immutable sequence of numbers and is "
"commonly used for looping a specific number of times in :keyword:`for` loops."
msgstr ""
"Typen :class:`range` representerar en oföränderlig sekvens av tal och "
"används ofta för att loopa ett visst antal gånger i :keyword:`for`-loopar."

#: ../../library/stdtypes.rst:1441
msgid ""
"The arguments to the range constructor must be integers (either built-in :"
"class:`int` or any object that implements the :meth:`~object.__index__` "
"special method).  If the *step* argument is omitted, it defaults to ``1``. "
"If the *start* argument is omitted, it defaults to ``0``. If *step* is "
"zero, :exc:`ValueError` is raised."
msgstr ""
"Argumenten till intervallkonstruktören måste vara heltal (antingen inbyggd :"
"class:`int` eller något objekt som implementerar specialmetoden :meth:"
"`~object.__index__`).  Om argumentet *step* utelämnas är standardvärdet "
"``1``. Om argumentet *start* utelämnas är standardvärdet ``0``. Om *step* är "
"noll genereras :exc:`ValueError`."

#: ../../library/stdtypes.rst:1447
msgid ""
"For a positive *step*, the contents of a range ``r`` are determined by the "
"formula ``r[i] = start + step*i`` where ``i >= 0`` and ``r[i] < stop``."
msgstr ""
"För ett positivt *steg* bestäms innehållet i ett intervall ``r`` av formeln "
"``r[i] = start + steg*i`` där ``i >= 0`` och ``r[i] < stopp``."

#: ../../library/stdtypes.rst:1451
msgid ""
"For a negative *step*, the contents of the range are still determined by the "
"formula ``r[i] = start + step*i``, but the constraints are ``i >= 0`` and "
"``r[i] > stop``."
msgstr ""
"För ett negativt *steg* bestäms innehållet i intervallet fortfarande av "
"formeln ``r[i] = start + steg*i``, men begränsningarna är ``i >= 0`` och "
"``r[i] > stopp``."

#: ../../library/stdtypes.rst:1455
msgid ""
"A range object will be empty if ``r[0]`` does not meet the value constraint. "
"Ranges do support negative indices, but these are interpreted as indexing "
"from the end of the sequence determined by the positive indices."
msgstr ""
"Ett intervallobjekt är tomt om ``r[0]`` inte uppfyller värdebegränsningen. "
"Ranges har stöd för negativa index, men dessa tolkas som indexering från "
"slutet av den sekvens som bestäms av de positiva indexen."

#: ../../library/stdtypes.rst:1460
msgid ""
"Ranges containing absolute values larger than :data:`sys.maxsize` are "
"permitted but some features (such as :func:`len`) may raise :exc:"
"`OverflowError`."
msgstr ""
"Intervall som innehåller absoluta värden som är större än :data:`sys."
"maxsize` är tillåtna men vissa funktioner (t.ex. :func:`len`) kan ge upphov "
"till :exc:`OverflowError`."

#: ../../library/stdtypes.rst:1464
msgid "Range examples::"
msgstr "Exempel på intervall::"

#: ../../library/stdtypes.rst:1466
msgid ""
">>> list(range(10))\n"
"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
">>> list(range(1, 11))\n"
"[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n"
">>> list(range(0, 30, 5))\n"
"[0, 5, 10, 15, 20, 25]\n"
">>> list(range(0, 10, 3))\n"
"[0, 3, 6, 9]\n"
">>> list(range(0, -10, -1))\n"
"[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]\n"
">>> list(range(0))\n"
"[]\n"
">>> list(range(1, 0))\n"
"[]"
msgstr ""
">>> lista(intervall(10))\n"
"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
">>> lista(intervall(1, 11))\n"
"[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n"
">>> lista(intervall(0, 30, 5))\n"
"[0, 5, 10, 15, 20, 25]\n"
">>> lista(intervall(0, 10, 3))\n"
"[0, 3, 6, 9]\n"
">>> lista(intervall(0, -10, -1))\n"
"[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]\n"
">>> lista(intervall(0))\n"
"[]\n"
">>> list(intervall(1, 0))\n"
"[]"

#: ../../library/stdtypes.rst:1481
msgid ""
"Ranges implement all of the :ref:`common <typesseq-common>` sequence "
"operations except concatenation and repetition (due to the fact that range "
"objects can only represent sequences that follow a strict pattern and "
"repetition and concatenation will usually violate that pattern)."
msgstr ""
"Ranges implementerar alla :ref:``common <typesseq-common>` "
"sekvensoperationer utom konkatenering och repetition (på grund av att range-"
"objekt endast kan representera sekvenser som följer ett strikt mönster och "
"repetition och konkatenering bryter vanligtvis mot detta mönster)."

#: ../../library/stdtypes.rst:1488
msgid ""
"The value of the *start* parameter (or ``0`` if the parameter was not "
"supplied)"
msgstr ""
"Värdet på parametern *start* (eller ``0`` om parametern inte har angetts)"

#: ../../library/stdtypes.rst:1493
msgid "The value of the *stop* parameter"
msgstr "Värdet på parametern *stop*"

#: ../../library/stdtypes.rst:1497
msgid ""
"The value of the *step* parameter (or ``1`` if the parameter was not "
"supplied)"
msgstr ""
"Värdet på parametern *step* (eller ``1`` om parametern inte har angetts)"

#: ../../library/stdtypes.rst:1500
msgid ""
"The advantage of the :class:`range` type over a regular :class:`list` or :"
"class:`tuple` is that a :class:`range` object will always take the same "
"(small) amount of memory, no matter the size of the range it represents (as "
"it only stores the ``start``, ``stop`` and ``step`` values, calculating "
"individual items and subranges as needed)."
msgstr ""
"Fördelen med typen :class:`range` jämfört med en vanlig :class:`list` eller :"
"class:`tuple` är att ett :class:`range`-objekt alltid tar samma (lilla) "
"mängd minne i anspråk, oavsett storleken på det intervall det representerar "
"(eftersom det bara lagrar värdena ``start``, ``stop`` och ``step`` och "
"beräknar enskilda objekt och delintervall efter behov)."

#: ../../library/stdtypes.rst:1506
msgid ""
"Range objects implement the :class:`collections.abc.Sequence` ABC, and "
"provide features such as containment tests, element index lookup, slicing "
"and support for negative indices (see :ref:`typesseq`):"
msgstr ""
"Range-objekt implementerar :class:`collections.abc.Sequence` ABC, och "
"tillhandahåller funktioner som inneslutningstest, elementindexuppslagning, "
"skivning och stöd för negativa index (se :ref:`typesseq`):"

#: ../../library/stdtypes.rst:1526
msgid ""
"Testing range objects for equality with ``==`` and ``!=`` compares them as "
"sequences.  That is, two range objects are considered equal if they "
"represent the same sequence of values.  (Note that two range objects that "
"compare equal might have different :attr:`~range.start`, :attr:`~range.stop` "
"and :attr:`~range.step` attributes, for example ``range(0) == range(2, 1, "
"3)`` or ``range(0, 3, 2) == range(0, 4, 2)``.)"
msgstr ""
"När intervallobjekt testas för likhet med ``==`` och ``!=`` jämförs de som "
"sekvenser.  Det innebär att två intervallobjekt anses vara lika om de "
"representerar samma sekvens av värden.  (Observera att två intervallobjekt "
"som jämförs lika kan ha olika attribut :attr:`~range.start`, :attr:`~range."
"stop` och :attr:`~range.step`, till exempel ``range(0) == range(2, 1, 3)`` "
"eller ``range(0, 3, 2) == range(0, 4, 2)``.)"

#: ../../library/stdtypes.rst:1533
msgid ""
"Implement the Sequence ABC. Support slicing and negative indices. Test :"
"class:`int` objects for membership in constant time instead of iterating "
"through all items."
msgstr ""
"Implementera sekvensen ABC. Stödjer skivning och negativa index. Testa :"
"class:`int`-objekt för medlemskap i konstant tid istället för att iterera "
"genom alla objekt."

#: ../../library/stdtypes.rst:1539
msgid ""
"Define '==' and '!=' to compare range objects based on the sequence of "
"values they define (instead of comparing based on object identity)."
msgstr ""
"Definiera '==' och '!=' för att jämföra intervallobjekt baserat på den "
"sekvens av värden som de definierar (istället för att jämföra baserat på "
"objektets identitet)."

#: ../../library/stdtypes.rst:1544
msgid ""
"Added the :attr:`~range.start`, :attr:`~range.stop` and :attr:`~range.step` "
"attributes."
msgstr ""
"Lagt till attributen :attr:`~range.start`, :attr:`~range.stop` och :attr:"
"`~range.step`."

#: ../../library/stdtypes.rst:1549
msgid ""
"The `linspace recipe <https://code.activestate.com/recipes/579000-equally-"
"spaced-numbers-linspace/>`_ shows how to implement a lazy version of range "
"suitable for floating-point applications."
msgstr ""
"I `linspace-receptet <https://code.activestate.com/recipes/579000-equally-"
"spaced-numbers-linspace/>`_ visas hur man implementerar en lat version av "
"range som är lämplig för flyttalsapplikationer."

#: ../../library/stdtypes.rst:1561
msgid "Text and Binary Sequence Type Methods Summary"
msgstr "Metoder för text- och binära sekvenstyper Sammanfattning"

#: ../../library/stdtypes.rst:1562
msgid ""
"The following table summarizes the text and binary sequence types methods by "
"category."
msgstr ""
"I följande tabell sammanfattas metoderna för text- och binära sekvenstyper "
"per kategori."

#: ../../library/stdtypes.rst:1567
msgid "Category"
msgstr "Kategori"

#: ../../library/stdtypes.rst:1567
msgid ":class:`str` methods"
msgstr ":klass:`str` metoder"

#: ../../library/stdtypes.rst:1567
msgid ":class:`bytes` and :class:`bytearray` methods"
msgstr "metoderna :class:`bytes` och :class:`bytearray"

#: ../../library/stdtypes.rst:1569
msgid "Formatting"
msgstr "Formaterar"

#: ../../library/stdtypes.rst:1569
msgid ":meth:`str.format`"
msgstr ":meth:`str.format`"

#: ../../library/stdtypes.rst:1571
msgid ":meth:`str.format_map`"
msgstr ":meth:`str.format_map`"

#: ../../library/stdtypes.rst:1573
msgid ":ref:`f-strings`"
msgstr ":ref:`f-strängar`"

#: ../../library/stdtypes.rst:1575
msgid ":ref:`old-string-formatting`"
msgstr ":ref:`gammal strängformatering`"

#: ../../library/stdtypes.rst:1575
msgid ":ref:`bytes-formatting`"
msgstr ":ref:`bytesformatering`"

#: ../../library/stdtypes.rst:1577
msgid "Searching and Replacing"
msgstr "Sökning och byte"

#: ../../library/stdtypes.rst:1577
msgid ":meth:`str.find`"
msgstr ":meth:`str.find`"

#: ../../library/stdtypes.rst:1577
msgid ":meth:`str.rfind`"
msgstr ":meth:`str.rfind`"

#: ../../library/stdtypes.rst:1577
msgid ":meth:`bytes.find`"
msgstr ":meth:`bytes.find`"

#: ../../library/stdtypes.rst:1577
msgid ":meth:`bytes.rfind`"
msgstr ":meth:`bytes.rfind`"

#: ../../library/stdtypes.rst:1579
msgid ":meth:`str.index`"
msgstr ":meth:`str.index`"

#: ../../library/stdtypes.rst:1579
msgid ":meth:`str.rindex`"
msgstr ":meth:`str.rindex`"

#: ../../library/stdtypes.rst:1579
msgid ":meth:`bytes.index`"
msgstr ":meth:`bytes.index`"

#: ../../library/stdtypes.rst:1579
msgid ":meth:`bytes.rindex`"
msgstr ":meth:`bytes.rindex`"

#: ../../library/stdtypes.rst:1581
msgid ":meth:`str.startswith`"
msgstr ":meth:`str.startswith`"

#: ../../library/stdtypes.rst:1581
msgid ":meth:`bytes.startswith`"
msgstr ":meth:`bytes.startswith`"

#: ../../library/stdtypes.rst:1583
msgid ":meth:`str.endswith`"
msgstr ":meth:`str.endswith`"

#: ../../library/stdtypes.rst:1583
msgid ":meth:`bytes.endswith`"
msgstr ":meth:`bytes.endswith`"

#: ../../library/stdtypes.rst:1585
msgid ":meth:`str.count`"
msgstr ":meth:`str.count`"

#: ../../library/stdtypes.rst:1585
msgid ":meth:`bytes.count`"
msgstr ":meth:`bytes.count`"

#: ../../library/stdtypes.rst:1587
msgid ":meth:`str.replace`"
msgstr ":meth:`str.replace`"

#: ../../library/stdtypes.rst:1587
msgid ":meth:`bytes.replace`"
msgstr ":meth:`bytes.replace`"

#: ../../library/stdtypes.rst:1589
msgid "Splitting and Joining"
msgstr "Delning och sammanfogning"

#: ../../library/stdtypes.rst:1589
msgid ":meth:`str.split`"
msgstr ":meth:`str.split`"

#: ../../library/stdtypes.rst:1589
msgid ":meth:`str.rsplit`"
msgstr ":meth:`str.rsplit`"

#: ../../library/stdtypes.rst:1589
msgid ":meth:`bytes.split`"
msgstr ":meth:`bytes.split`"

#: ../../library/stdtypes.rst:1589
msgid ":meth:`bytes.rsplit`"
msgstr ":meth:`bytes.rsplit`"

#: ../../library/stdtypes.rst:1591
msgid ":meth:`str.splitlines`"
msgstr ":meth:`str.splitlines`"

#: ../../library/stdtypes.rst:1591
msgid ":meth:`bytes.splitlines`"
msgstr ":meth:`bytes.splitlines`"

#: ../../library/stdtypes.rst:1593
msgid ":meth:`str.partition`"
msgstr ":meth:`str.partition`"

#: ../../library/stdtypes.rst:1593
msgid ":meth:`bytes.partition`"
msgstr ":meth:`bytes.partition`"

#: ../../library/stdtypes.rst:1595
msgid ":meth:`str.rpartition`"
msgstr ":meth:`str.rpartition`"

#: ../../library/stdtypes.rst:1595
msgid ":meth:`bytes.rpartition`"
msgstr ":meth:`bytes.rpartition`"

#: ../../library/stdtypes.rst:1597
msgid ":meth:`str.join`"
msgstr ":meth:`str.join`"

#: ../../library/stdtypes.rst:1597
msgid ":meth:`bytes.join`"
msgstr ":meth:`bytes.join`"

#: ../../library/stdtypes.rst:1599
msgid "String Classification"
msgstr "Klassificering av strängar"

#: ../../library/stdtypes.rst:1599
msgid ":meth:`str.isalpha`"
msgstr ":meth:`str.isalpha`"

#: ../../library/stdtypes.rst:1599
msgid ":meth:`bytes.isalpha`"
msgstr ":meth:`bytes.isalpha`"

#: ../../library/stdtypes.rst:1601
msgid ":meth:`str.isdecimal`"
msgstr ":meth:`str.isdecimal`"

#: ../../library/stdtypes.rst:1603
msgid ":meth:`str.isdigit`"
msgstr ":meth:`str.isdigit`"

#: ../../library/stdtypes.rst:1603
msgid ":meth:`bytes.isdigit`"
msgstr ":meth:`bytes.isdigit`"

#: ../../library/stdtypes.rst:1605
msgid ":meth:`str.isnumeric`"
msgstr ":meth:`str.isnumeric`"

#: ../../library/stdtypes.rst:1607
msgid ":meth:`str.isalnum`"
msgstr ":meth:`str.isalnum`"

#: ../../library/stdtypes.rst:1607
msgid ":meth:`bytes.isalnum`"
msgstr ":meth:`bytes.isalnum`"

#: ../../library/stdtypes.rst:1609
msgid ":meth:`str.isidentifier`"
msgstr ":meth:`str.isidentifier`"

#: ../../library/stdtypes.rst:1611
msgid ":meth:`str.islower`"
msgstr ":meth:`str.islower`"

#: ../../library/stdtypes.rst:1611
msgid ":meth:`bytes.islower`"
msgstr ":meth:`bytes.islower`"

#: ../../library/stdtypes.rst:1613
msgid ":meth:`str.isupper`"
msgstr ":meth:`str.isupper`"

#: ../../library/stdtypes.rst:1613
msgid ":meth:`bytes.isupper`"
msgstr ":meth:`bytes.isupper`"

#: ../../library/stdtypes.rst:1615
msgid ":meth:`str.istitle`"
msgstr ":meth:`str.istitle`"

#: ../../library/stdtypes.rst:1615
msgid ":meth:`bytes.istitle`"
msgstr ":meth:`bytes.istitle`"

#: ../../library/stdtypes.rst:1617
msgid ":meth:`str.isspace`"
msgstr ":meth:`str.isspace`"

#: ../../library/stdtypes.rst:1617
msgid ":meth:`bytes.isspace`"
msgstr ":meth:`bytes.isspace`"

#: ../../library/stdtypes.rst:1619
msgid ":meth:`str.isprintable`"
msgstr ":meth:`str.isprintable`"

#: ../../library/stdtypes.rst:1621
msgid "Case Manipulation"
msgstr "Manipulation av ärenden"

#: ../../library/stdtypes.rst:1621
msgid ":meth:`str.lower`"
msgstr ":meth:`str.lower`"

#: ../../library/stdtypes.rst:1621
msgid ":meth:`bytes.lower`"
msgstr ":meth:`bytes.lägre`"

#: ../../library/stdtypes.rst:1623
msgid ":meth:`str.upper`"
msgstr ":meth:`str.övre`"

#: ../../library/stdtypes.rst:1623
msgid ":meth:`bytes.upper`"
msgstr ":meth:`bytes.övre`"

#: ../../library/stdtypes.rst:1625
msgid ":meth:`str.casefold`"
msgstr ":meth:`str.casefold`"

#: ../../library/stdtypes.rst:1627
msgid ":meth:`str.capitalize`"
msgstr ":meth:`str.capitalize`"

#: ../../library/stdtypes.rst:1627
msgid ":meth:`bytes.capitalize`"
msgstr ":meth:`bytes.capitalize`"

#: ../../library/stdtypes.rst:1629
msgid ":meth:`str.title`"
msgstr ":meth:`str.title`"

#: ../../library/stdtypes.rst:1629
msgid ":meth:`bytes.title`"
msgstr ":meth:`bytes.titel`"

#: ../../library/stdtypes.rst:1631
msgid ":meth:`str.swapcase`"
msgstr ":meth:`str.swapcase`"

#: ../../library/stdtypes.rst:1631
msgid ":meth:`bytes.swapcase`"
msgstr ":meth:`bytes.swapcase`"

#: ../../library/stdtypes.rst:1633
msgid "Padding and Stripping"
msgstr "Stoppning och strippning"

#: ../../library/stdtypes.rst:1633
msgid ":meth:`str.ljust`"
msgstr ":meth:`str.ljust`"

#: ../../library/stdtypes.rst:1633
msgid ":meth:`str.rjust`"
msgstr ":meth:`str.rjust`"

#: ../../library/stdtypes.rst:1633
msgid ":meth:`bytes.ljust`"
msgstr ":meth:`bytes.ljust`"

#: ../../library/stdtypes.rst:1633
msgid ":meth:`bytes.rjust`"
msgstr ":meth:`bytes.rjust`"

#: ../../library/stdtypes.rst:1635
msgid ":meth:`str.center`"
msgstr ":meth:`str.center`"

#: ../../library/stdtypes.rst:1635
msgid ":meth:`bytes.center`"
msgstr ":meth:`bytes.center`"

#: ../../library/stdtypes.rst:1637
msgid ":meth:`str.expandtabs`"
msgstr ":meth:`str.expandtabs`"

#: ../../library/stdtypes.rst:1637
msgid ":meth:`bytes.expandtabs`"
msgstr ":meth:`bytes.expandtabs`"

#: ../../library/stdtypes.rst:1639
msgid ":meth:`str.strip`"
msgstr ":meth:`str.strip`"

#: ../../library/stdtypes.rst:1639
msgid ":meth:`bytes.strip`"
msgstr ":meth:`bytes.strip`"

#: ../../library/stdtypes.rst:1641
msgid ":meth:`str.lstrip`"
msgstr ":meth:`str.lstrip`"

#: ../../library/stdtypes.rst:1641
msgid ":meth:`str.rstrip`"
msgstr ":meth:`str.rstrip`"

#: ../../library/stdtypes.rst:1641
msgid ":meth:`bytes.lstrip`"
msgstr ":meth:`bytes.lstrip`"

#: ../../library/stdtypes.rst:1641
msgid ":meth:`bytes.rstrip`"
msgstr ":meth:`bytes.rstrip`"

#: ../../library/stdtypes.rst:1643
msgid "Translation and Encoding"
msgstr "Översättning och kodning"

#: ../../library/stdtypes.rst:1643
msgid ":meth:`str.translate`"
msgstr ":meth:`str.translate`"

#: ../../library/stdtypes.rst:1643
msgid ":meth:`bytes.translate`"
msgstr ":meth:`bytes.translate`"

#: ../../library/stdtypes.rst:1645
msgid ":meth:`str.maketrans`"
msgstr ":meth:`str.maketrans`"

#: ../../library/stdtypes.rst:1645
msgid ":meth:`bytes.maketrans`"
msgstr ":meth:`bytes.maketrans`"

#: ../../library/stdtypes.rst:1647
msgid ":meth:`str.encode`"
msgstr ":meth:`str.encode`"

#: ../../library/stdtypes.rst:1649
msgid ":meth:`bytes.decode`"
msgstr ":meth:`bytes.avkodning`"

#: ../../library/stdtypes.rst:1655
msgid "Text Sequence Type --- :class:`str`"
msgstr "Textsekvenstyp --- :class:`str`"

#: ../../library/stdtypes.rst:1657
msgid ""
"Textual data in Python is handled with :class:`str` objects, or :dfn:"
"`strings`. Strings are immutable :ref:`sequences <typesseq>` of Unicode code "
"points.  String literals are written in a variety of ways:"
msgstr ""
"Textdata i Python hanteras med :class:`str`-objekt, eller :dfn:`strings`. "
"Strängar är oföränderliga :ref:`sekvenser <typesseq>` av Unicode-"
"kodpunkter.  Stränglitteraler skrivs på en mängd olika sätt:"

#: ../../library/stdtypes.rst:1662
msgid "Single quotes: ``'allows embedded \"double\" quotes'``"
msgstr ""
"Enkla citattecken: ``'tillåter inbäddade \"dubbla\" citationstecken'```"

#: ../../library/stdtypes.rst:1663
msgid "Double quotes: ``\"allows embedded 'single' quotes\"``"
msgstr "Dubbla citattecken: ``\"tillåter inbäddade 'enkla' citationstecken\"``"

#: ../../library/stdtypes.rst:1664
msgid ""
"Triple quoted: ``'''Three single quotes'''``, ``\"\"\"Three double "
"quotes\"\"\"``"
msgstr ""
"Trippelcitat: ``\"\"\"Tre enkla citattecken\"\"\"``, ``\"\"\"Tre dubbla "
"citattecken\"\"\"``"

#: ../../library/stdtypes.rst:1666
msgid ""
"Triple quoted strings may span multiple lines - all associated whitespace "
"will be included in the string literal."
msgstr ""
"Strängar med trippelcitat kan sträcka sig över flera rader - alla "
"tillhörande blanksteg kommer att inkluderas i strängens bokstav."

#: ../../library/stdtypes.rst:1669
msgid ""
"String literals that are part of a single expression and have only "
"whitespace between them will be implicitly converted to a single string "
"literal. That is, ``(\"spam \" \"eggs\") == \"spam eggs\"``."
msgstr ""
"Stränglitteraler som är en del av ett enda uttryck och som bara har "
"blanksteg mellan sig konverteras implicit till en enda stränglitteral. Det "
"vill säga ``(\"spam \" \"ägg\") == \"spam ägg\"``."

#: ../../library/stdtypes.rst:1673
msgid ""
"See :ref:`strings` for more about the various forms of string literal, "
"including supported :ref:`escape sequences <escape-sequences>`, and the "
"``r`` (\"raw\") prefix that disables most escape sequence processing."
msgstr ""
"Se :ref:`strings` för mer information om de olika formerna av "
"strängbokstäver, inklusive stöd för :ref:`escape-sekvenser <escape-"
"sequences>`, och prefixet ``r`` (\"raw\") som inaktiverar den mesta "
"bearbetningen av escape-sekvenser."

#: ../../library/stdtypes.rst:1677
msgid ""
"Strings may also be created from other objects using the :class:`str` "
"constructor."
msgstr ""
"Strängar kan också skapas från andra objekt med hjälp av :class:`str`-"
"konstruktören."

#: ../../library/stdtypes.rst:1680
msgid ""
"Since there is no separate \"character\" type, indexing a string produces "
"strings of length 1. That is, for a non-empty string *s*, ``s[0] == s[0:1]``."
msgstr ""
"Eftersom det inte finns någon separat \"tecken\"-typ, ger indexering av en "
"sträng strängar med längden 1. Det vill säga, för en icke-tom sträng *s*, "
"``s[0] == s[0:1]``."

#: ../../library/stdtypes.rst:1686
msgid ""
"There is also no mutable string type, but :meth:`str.join` or :class:`io."
"StringIO` can be used to efficiently construct strings from multiple "
"fragments."
msgstr ""
"Det finns inte heller någon mutabel strängtyp, men :meth:`str.join` eller :"
"class:`io.StringIO` kan användas för att effektivt konstruera strängar från "
"flera fragment."

#: ../../library/stdtypes.rst:1690
msgid ""
"For backwards compatibility with the Python 2 series, the ``u`` prefix is "
"once again permitted on string literals. It has no effect on the meaning of "
"string literals and cannot be combined with the ``r`` prefix."
msgstr ""
"För bakåtkompatibilitet med Python 2-serien är prefixet ``u`` återigen "
"tillåtet för stränglitteraler. Det har ingen effekt på betydelsen av "
"stränglitteraler och kan inte kombineras med prefixet ``r``."

#: ../../library/stdtypes.rst:1702
msgid ""
"Return a :ref:`string <textseq>` version of *object*.  If *object* is not "
"provided, returns the empty string.  Otherwise, the behavior of ``str()`` "
"depends on whether *encoding* or *errors* is given, as follows."
msgstr ""
"Returnerar en :ref:`sträng <textseq>`-version av *objekt*.  Om *object* inte "
"anges, returneras den tomma strängen.  Annars beror beteendet hos ``str()`` "
"på om *encoding* eller *errors* anges, enligt följande."

#: ../../library/stdtypes.rst:1706
msgid ""
"If neither *encoding* nor *errors* is given, ``str(object)`` returns :meth:"
"`type(object).__str__(object) <object.__str__>`, which is the \"informal\" "
"or nicely printable string representation of *object*.  For string objects, "
"this is the string itself.  If *object* does not have a :meth:`~object."
"__str__` method, then :func:`str` falls back to returning :func:"
"`repr(object) <repr>`."
msgstr ""
"Om varken *encoding* eller *errors* anges returnerar ``str(object)`` :meth:"
"`type(object).__str__(object) <object.__str__>`, vilket är den "
"\"informella\" eller snyggt utskrivbara strängrepresentationen av *object*.  "
"För strängobjekt är detta själva strängen.  Om *object* inte har en :meth:"
"`~object.__str__`-metod, faller :func:`str` tillbaka till att returnera :"
"func:`repr(object) <repr>`."

#: ../../library/stdtypes.rst:1718
msgid ""
"If at least one of *encoding* or *errors* is given, *object* should be a :"
"term:`bytes-like object` (e.g. :class:`bytes` or :class:`bytearray`).  In "
"this case, if *object* is a :class:`bytes` (or :class:`bytearray`) object, "
"then ``str(bytes, encoding, errors)`` is equivalent to :meth:`bytes."
"decode(encoding, errors) <bytes.decode>`.  Otherwise, the bytes object "
"underlying the buffer object is obtained before calling :meth:`bytes."
"decode`.  See :ref:`binaryseq` and :ref:`bufferobjects` for information on "
"buffer objects."
msgstr ""
"Om minst en av *encoding* eller *errors* anges, bör *object* vara ett :term:"
"`bytes-liknande objekt` (t.ex. :class:`bytes` eller :class:`bytearray`).  I "
"det här fallet, om *objekt* är ett :class:`bytes` (eller :class:`bytearray`) "
"objekt, så är ``str(bytes, encoding, errors)`` ekvivalent med :meth:`bytes."
"decode(encoding, errors) <bytes.decode>`.  I annat fall erhålls "
"bytesobjektet som ligger under buffertobjektet innan :meth:`bytes.decode` "
"anropas.  Se :ref:`binaryseq` och :ref:`bufferobjects` för information om "
"buffertobjekt."

#: ../../library/stdtypes.rst:1727
msgid ""
"Passing a :class:`bytes` object to :func:`str` without the *encoding* or "
"*errors* arguments falls under the first case of returning the informal "
"string representation (see also the :option:`-b` command-line option to "
"Python).  For example::"
msgstr ""
"Att skicka ett :class:`bytes`-objekt till :func:`str` utan argumenten "
"*encoding* eller *errors* faller under det första fallet av att returnera "
"den informella strängrepresentationen (se även kommandoradsalternativet :"
"option:`-b` till Python).  Till exempel::"

#: ../../library/stdtypes.rst:1732
msgid ""
">>> str(b'Zoot!')\n"
"\"b'Zoot!'\""
msgstr ""
">>> str(b'Zoot!')\n"
"\"b'Zoot!'\""

#: ../../library/stdtypes.rst:1735
msgid ""
"For more information on the ``str`` class and its methods, see :ref:"
"`textseq` and the :ref:`string-methods` section below.  To output formatted "
"strings, see the :ref:`f-strings` and :ref:`formatstrings` sections.  In "
"addition, see the :ref:`stringservices` section."
msgstr ""
"Mer information om klassen ``str`` och dess metoder finns i avsnitten :ref:"
"`textseq` och :ref:`string-methods` nedan.  För att skriva ut formaterade "
"strängar, se avsnitten :ref:`f-strings` och :ref:`formatstrings`.  Dessutom, "
"se avsnittet :ref:`stringservices`."

#: ../../library/stdtypes.rst:1747
msgid "String Methods"
msgstr "Strängmetoder"

#: ../../library/stdtypes.rst:1752
msgid ""
"Strings implement all of the :ref:`common <typesseq-common>` sequence "
"operations, along with the additional methods described below."
msgstr ""
"Strängar implementerar alla :ref:`common <typesseq-common>` "
"sekvensoperationer, tillsammans med de ytterligare metoder som beskrivs "
"nedan."

#: ../../library/stdtypes.rst:1755
msgid ""
"Strings also support two styles of string formatting, one providing a large "
"degree of flexibility and customization (see :meth:`str.format`, :ref:"
"`formatstrings` and :ref:`string-formatting`) and the other based on C "
"``printf`` style formatting that handles a narrower range of types and is "
"slightly harder to use correctly, but is often faster for the cases it can "
"handle (:ref:`old-string-formatting`)."
msgstr ""
"Strängar har också stöd för två typer av strängformatering, en som ger stor "
"flexibilitet och möjlighet till anpassning (se :meth:`str.format`, :ref:"
"`formatstrings` och :ref:`string-formatting`) och en som baseras på C "
"``printf``-stilformatering som hanterar ett smalare urval av typer och är "
"något svårare att använda korrekt, men som ofta är snabbare i de fall den "
"kan hantera (:ref:`old-string-formatting`)."

#: ../../library/stdtypes.rst:1762
msgid ""
"The :ref:`textservices` section of the standard library covers a number of "
"other modules that provide various text related utilities (including regular "
"expression support in the :mod:`re` module)."
msgstr ""
"Avsnittet :ref:`textservices` i standardbiblioteket omfattar ett antal andra "
"moduler som tillhandahåller olika textrelaterade verktyg (inklusive stöd för "
"reguljära uttryck i modulen :mod:`re`)."

#: ../../library/stdtypes.rst:1768
msgid ""
"Return a copy of the string with its first character capitalized and the "
"rest lowercased."
msgstr ""
"Returnerar en kopia av strängen med första tecknet i versaler och resten i "
"gemener."

#: ../../library/stdtypes.rst:1771
msgid ""
"The first character is now put into titlecase rather than uppercase. This "
"means that characters like digraphs will only have their first letter "
"capitalized, instead of the full character."
msgstr ""
"Det första tecknet sätts nu i titelbokstäver i stället för versaler. Detta "
"innebär att tecken som digrafer endast får sin första bokstav versaliserad, "
"istället för hela tecknet."

#: ../../library/stdtypes.rst:1778
msgid ""
"Return a casefolded copy of the string. Casefolded strings may be used for "
"caseless matching."
msgstr ""
"Returnerar en casefoldad kopia av strängen. Casefoldade strängar kan "
"användas för caseless matchning."

#: ../../library/stdtypes.rst:1781
msgid ""
"Casefolding is similar to lowercasing but more aggressive because it is "
"intended to remove all case distinctions in a string. For example, the "
"German lowercase letter ``'ß'`` is equivalent to ``\"ss\"``. Since it is "
"already lowercase, :meth:`lower` would do nothing to ``'ß'``; :meth:"
"`casefold` converts it to ``\"ss\"``."
msgstr ""
"Casefolding liknar lowercasing men är mer aggressivt eftersom det är avsett "
"att ta bort alla skillnader i versaler i en sträng. Till exempel är den "
"tyska gemena bokstaven ``'ß'`` likvärdig med ``\"ss\"``. Eftersom den redan "
"är gemen skulle :meth:`lower` inte göra något med ``'ß'``; :meth:`casefold` "
"konverterar den till ``\"ss\"``."

#: ../../library/stdtypes.rst:1787
msgid ""
"The casefolding algorithm is `described in section 3.13 'Default Case "
"Folding' of the Unicode Standard <https://www.unicode.org/versions/"
"Unicode16.0.0/core-spec/chapter-3/#G33992>`__."
msgstr ""
"Algoritmen för casefolding beskrivs i avsnitt 3.13 \"Default Case Folding\" "
"i Unicode-standarden <https://www.unicode.org/versions/Unicode16.0.0/core-"
"spec/chapter-3/#G33992>`__."

#: ../../library/stdtypes.rst:1796
msgid ""
"Return centered in a string of length *width*. Padding is done using the "
"specified *fillchar* (default is an ASCII space). The original string is "
"returned if *width* is less than or equal to ``len(s)``.  For example::"
msgstr ""
"Returnerar centrerad i en sträng av längden *bredd*. Utfyllnad görs med "
"hjälp av det angivna *fillchar* (standard är ett ASCII-rymd). Den "
"ursprungliga strängen returneras om *width* är mindre än eller lika med "
"``len(s)``.  Till exempel::"

#: ../../library/stdtypes.rst:1800
msgid ""
">>> 'Python'.center(10)\n"
"'  Python  '\n"
">>> 'Python'.center(10, '-')\n"
"'--Python--'\n"
">>> 'Python'.center(4)\n"
"'Python'"
msgstr ""
">>> 'Python'.center(10)\n"
"' Python '\n"
">>> 'Python'.center(10, '-')\n"
"'--Python--'\n"
">>> 'Python'.centrum(4)\n"
"\"Python"

#: ../../library/stdtypes.rst:1810
msgid ""
"Return the number of non-overlapping occurrences of substring *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""
"Returnerar antalet icke-överlappande förekomster av substring *sub* i "
"intervallet [*start*, *slut*].  De valfria argumenten *start* och *slut* "
"tolkas som i slice-notation."

#: ../../library/stdtypes.rst:1814
msgid ""
"If *sub* is empty, returns the number of empty strings between characters "
"which is the length of the string plus one. For example::"
msgstr ""
"Om *sub* är tom, returneras antalet tomma strängar mellan tecknen, vilket är "
"strängens längd plus ett. Till exempel::"

#: ../../library/stdtypes.rst:1817
msgid ""
">>> 'spam, spam, spam'.count('spam')\n"
"3\n"
">>> 'spam, spam, spam'.count('spam', 5)\n"
"2\n"
">>> 'spam, spam, spam'.count('spam', 5, 10)\n"
"1\n"
">>> 'spam, spam, spam'.count('eggs')\n"
"0\n"
">>> 'spam, spam, spam'.count('')\n"
"17"
msgstr ""
">>> 'spam, spam, spam'.count('spam')\n"
"3\n"
">>> 'skräppost, skräppost, skräppost'.count('skräppost', 5)\n"
"2\n"
">>> 'spam, spam, spam'.count('spam', 5, 10)\n"
"1\n"
">>> 'spam, spam, spam'.count('ägg')\n"
"0\n"
">>> 'spam, spam, spam'.count('')\n"
"17"

#: ../../library/stdtypes.rst:1830
msgid "Return the string encoded to :class:`bytes`."
msgstr "Returnerar strängen kodad till :class:`bytes`."

#: ../../library/stdtypes.rst:1832 ../../library/stdtypes.rst:3204
msgid ""
"*encoding* defaults to ``'utf-8'``; see :ref:`standard-encodings` for "
"possible values."
msgstr ""
"*encoding* är som standard ``'utf-8'``; se :ref:`standard-encodings` för "
"möjliga värden."

#: ../../library/stdtypes.rst:1835
msgid ""
"*errors* controls how encoding errors are handled. If ``'strict'`` (the "
"default), a :exc:`UnicodeError` exception is raised. Other possible values "
"are ``'ignore'``, ``'replace'``, ``'xmlcharrefreplace'``, "
"``'backslashreplace'`` and any other name registered via :func:`codecs."
"register_error`. See :ref:`error-handlers` for details."
msgstr ""
"*errors* styr hur kodningsfel ska hanteras. Om ``'strict'`` (standard), "
"kommer ett :exc:`UnicodeError` undantag att uppstå. Andra möjliga värden är "
"``'ignore'``, ``'replace'``, ``'xmlcharrefreplace'``, ``'backslashreplace'`` "
"och alla andra namn som registreras via :func:`codecs.register_error`. Se :"
"ref:`error-handlers` för detaljer."

#: ../../library/stdtypes.rst:1842
msgid ""
"For performance reasons, the value of *errors* is not checked for validity "
"unless an encoding error actually occurs, :ref:`devmode` is enabled or a :"
"ref:`debug build <debug-build>` is used. For example::"
msgstr ""
"Av prestandaskäl kontrolleras inte värdet på *errors* om inte ett "
"kodningsfel faktiskt inträffar, :ref:`devmode` är aktiverat eller en :ref:"
"`debug build <debug-build>` används. Till exempel::"

#: ../../library/stdtypes.rst:1848
msgid ""
">>> encoded_str_to_bytes = 'Python'.encode()\n"
">>> type(encoded_str_to_bytes)\n"
"<class 'bytes'>\n"
">>> encoded_str_to_bytes\n"
"b'Python'"
msgstr ""
">>> kodad_str_to_bytes = 'Python'.encode()\n"
">>> typ(kodad_str_to_bytes)\n"
"<klass 'bytes'> >>> kodad_str_till_bytes\n"
">>> kodad_str_till_bytes\n"
"b'Python'"

#: ../../library/stdtypes.rst:1855 ../../library/stdtypes.rst:3223
msgid "Added support for keyword arguments."
msgstr "Stöd för nyckelordsargument har lagts till."

#: ../../library/stdtypes.rst:1858 ../../library/stdtypes.rst:3226
msgid ""
"The value of the *errors* argument is now checked in :ref:`devmode` and in :"
"ref:`debug mode <debug-build>`."
msgstr ""
"Värdet på *errors*-argumentet kontrolleras nu i :ref:`devmode` och i :ref:"
"`debug mode <debug-build>`."

#: ../../library/stdtypes.rst:1865
msgid ""
"Return ``True`` if the string ends with the specified *suffix*, otherwise "
"return ``False``.  *suffix* can also be a tuple of suffixes to look for.  "
"With optional *start*, test beginning at that position.  With optional "
"*end*, stop comparing at that position. Using *start* and *end* is "
"equivalent to ``str[start:end].endswith(suffix)``. For example::"
msgstr ""
"Returnerar ``True`` om strängen slutar med det angivna *suffixet*, annars "
"returneras ``False``.  *suffix* kan också vara en tupel av suffix att leta "
"efter.  Med valfri *start* börjar testet vid den positionen.  Med valfri "
"*end*, sluta jämföra vid den positionen. Att använda *start* och *end* är "
"likvärdigt med ``str[start:end].endswith(suffix)``. Till exempel::"

#: ../../library/stdtypes.rst:1871
msgid ""
">>> 'Python'.endswith('on')\n"
"True\n"
">>> 'a tuple of suffixes'.endswith(('at', 'in'))\n"
"False\n"
">>> 'a tuple of suffixes'.endswith(('at', 'es'))\n"
"True\n"
">>> 'Python is amazing'.endswith('is', 0, 9)\n"
"True"
msgstr ""
">>> 'Python'.endswith('on')\n"
"Sant\n"
">>> 'en tupel av suffix'.endswith(('at', 'in'))\n"
"Falsk\n"
">>> 'en tupel av suffix'.endswith(('at', 'es'))\n"
"Sant\n"
">>> 'Python är fantastiskt'.endswith('is', 0, 9)\n"
"Sant"

#: ../../library/stdtypes.rst:1880
msgid "See also :meth:`startswith` and :meth:`removesuffix`."
msgstr "Se även :meth:`startswith` och :meth:`removesuffix`."

#: ../../library/stdtypes.rst:1885
msgid ""
"Return a copy of the string where all tab characters are replaced by one or "
"more spaces, depending on the current column and the given tab size.  Tab "
"positions occur every *tabsize* characters (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the string, the current "
"column is set to zero and the string is examined character by character.  If "
"the character is a tab (``\\t``), one or more space characters are inserted "
"in the result until the current column is equal to the next tab position. "
"(The tab character itself is not copied.)  If the character is a newline "
"(``\\n``) or return (``\\r``), it is copied and the current column is reset "
"to zero.  Any other character is copied unchanged and the current column is "
"incremented by one regardless of how the character is represented when "
"printed. For example::"
msgstr ""
"Returnerar en kopia av strängen där alla tabbtecken ersatts av ett eller "
"flera mellanslag, beroende på aktuell kolumn och angiven tabbstorlek.  "
"Tabbpositioner uppstår varje *tabsize* tecken (standard är 8, vilket ger "
"tabbpositioner i kolumnerna 0, 8, 16 och så vidare).  För att expandera "
"strängen sätts den aktuella kolumnen till noll och strängen granskas tecken "
"för tecken.  Om tecknet är en tabb (``t``) infogas ett eller flera "
"mellanslagstecken i resultatet tills den aktuella kolumnen är lika med nästa "
"tabbposition. (Tabbtecknet i sig kopieras inte.) Om tecknet är en ny rad "
"(``\\n``) eller en retur (``\\r``) kopieras det och den aktuella kolumnen "
"nollställs.  Alla andra tecken kopieras oförändrade och den aktuella "
"kolumnen ökas med ett oavsett hur tecknet representeras när det skrivs ut. "
"Till exempel::"

#: ../../library/stdtypes.rst:1898
msgid ""
">>> '01\\t012\\t0123\\t01234'.expandtabs()\n"
"'01      012     0123    01234'\n"
">>> '01\\t012\\t0123\\t01234'.expandtabs(4)\n"
"'01  012 0123    01234'\n"
">>> print('01\\t012\\n0123\\t01234'.expandtabs(4))\n"
"01  012\n"
"0123    01234"
msgstr ""
">>> '01\\t012\\t0123\\t01234'.expandtabs()\n"
"'01 012 0123 01234'\n"
">>> '01\\t012\\t0123\\t01234'.expandtabs(4)\n"
"'01 012 0123 01234'\n"
">>> print('01\\t012\\n0123\\t01234'.expandtabs(4))\n"
"01 012\n"
"0123 01234"

#: ../../library/stdtypes.rst:1909
msgid ""
"Return the lowest index in the string where substring *sub* is found within "
"the slice ``s[start:end]``.  Optional arguments *start* and *end* are "
"interpreted as in slice notation.  Return ``-1`` if *sub* is not found."
msgstr ""
"Returnerar det lägsta indexet i strängen där delsträngen *sub* finns inom "
"skivan ``s[start:end]``.  De valfria argumenten *start* och *end* tolkas som "
"i slice-notation.  Returnerar ``-1`` om *sub* inte hittas."

#: ../../library/stdtypes.rst:1915
msgid ""
"The :meth:`~str.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the :"
"keyword:`in` operator::"
msgstr ""
"Metoden :meth:`~str.find` bör endast användas om du behöver veta positionen "
"för *sub*.  Om du vill kontrollera om *sub* är en delsträng eller inte "
"använder du operatorn :keyword:`in`::"

#: ../../library/stdtypes.rst:1919
msgid ""
">>> 'Py' in 'Python'\n"
"True"
msgstr ""
">>> 'Py' i 'Python'\n"
"Sant"

#: ../../library/stdtypes.rst:1925
msgid ""
"Perform a string formatting operation.  The string on which this method is "
"called can contain literal text or replacement fields delimited by braces "
"``{}``.  Each replacement field contains either the numeric index of a "
"positional argument, or the name of a keyword argument.  Returns a copy of "
"the string where each replacement field is replaced with the string value of "
"the corresponding argument."
msgstr ""
"Utför en strängformateringsoperation.  Strängen som den här metoden anropas "
"på kan innehålla bokstavlig text eller ersättningsfält som avgränsas av "
"hakparenteser ``{}``.  Varje ersättningsfält innehåller antingen det "
"numeriska indexet för ett positionsargument eller namnet på ett "
"nyckelordsargument.  Returnerar en kopia av strängen där varje "
"ersättningsfält ersätts med strängvärdet för motsvarande argument."

#: ../../library/stdtypes.rst:1935
msgid ""
"See :ref:`formatstrings` for a description of the various formatting options "
"that can be specified in format strings."
msgstr ""
"Se :ref:`formatsträngar` för en beskrivning av de olika "
"formateringsalternativ som kan anges i formatsträngar."

#: ../../library/stdtypes.rst:1939
msgid ""
"When formatting a number (:class:`int`, :class:`float`, :class:`complex`, :"
"class:`decimal.Decimal` and subclasses) with the ``n`` type (ex: ``'{:n}'."
"format(1234)``), the function temporarily sets the ``LC_CTYPE`` locale to "
"the ``LC_NUMERIC`` locale to decode ``decimal_point`` and ``thousands_sep`` "
"fields of :c:func:`localeconv` if they are non-ASCII or longer than 1 byte, "
"and the ``LC_NUMERIC`` locale is different than the ``LC_CTYPE`` locale.  "
"This temporary change affects other threads."
msgstr ""
"Vid formatering av ett tal (:class:`int`, :class:`float`, :class:`complex`, :"
"class:`decimal.Decimal` och underklasser) med typen ``n`` (ex: ``'{:n}'."
"format(1234)``), ställer funktionen temporärt in ``LC_CTYPE`` locale till "
"``LC_NUMERIC`` locale för att avkoda ``decimal_point`` och ``thousands_sep`` "
"fälten i :c:func:`localeconv` om de är icke-ASCII eller längre än 1 byte, "
"och ``LC_NUMERIC`` locale är annorlunda än ``LC_CTYPE`` locale.  Denna "
"tillfälliga ändring påverkar andra trådar."

#: ../../library/stdtypes.rst:1948
msgid ""
"When formatting a number with the ``n`` type, the function sets temporarily "
"the ``LC_CTYPE`` locale to the ``LC_NUMERIC`` locale in some cases."
msgstr ""
"Vid formatering av ett tal med typen ``n`` ställer funktionen i vissa fall "
"tillfälligt in ``LC_CTYPE`` locale till ``LC_NUMERIC`` locale."

#: ../../library/stdtypes.rst:1956
msgid ""
"Similar to ``str.format(**mapping)``, except that ``mapping`` is used "
"directly and not copied to a :class:`dict`.  This is useful if for example "
"``mapping`` is a dict subclass:"
msgstr ""
"Liknar ``str.format(**mapping)``, förutom att ``mapping`` används direkt och "
"inte kopieras till en :class:`dict`.  Detta är användbart om till exempel "
"``mapping`` är en dict-underklass:"

#: ../../library/stdtypes.rst:1972
msgid ""
"Like :meth:`~str.find`, but raise :exc:`ValueError` when the substring is "
"not found."
msgstr ""
"Som :meth:`~str.find`, men ger upphov till :exc:`ValueError` när delsträngen "
"inte hittas."

#: ../../library/stdtypes.rst:1978
msgid ""
"Return ``True`` if all characters in the string are alphanumeric and there "
"is at least one character, ``False`` otherwise.  A character ``c`` is "
"alphanumeric if one of the following returns ``True``: ``c.isalpha()``, ``c."
"isdecimal()``, ``c.isdigit()``, or ``c.isnumeric()``."
msgstr ""
"Returnerar ``True`` om alla tecken i strängen är alfanumeriska och det finns "
"minst ett tecken, annars ``False``.  Ett tecken ``c`` är alfanumeriskt om "
"något av följande returnerar ``True``: ``c.isalpha()``, ``c.isdecimal()``, "
"``c.isdigit()``, eller ``c.isnumeric()``."

#: ../../library/stdtypes.rst:1986
msgid ""
"Return ``True`` if all characters in the string are alphabetic and there is "
"at least one character, ``False`` otherwise.  Alphabetic characters are "
"those characters defined in the Unicode character database as \"Letter\", i."
"e., those with general category property being one of \"Lm\", \"Lt\", "
"\"Lu\", \"Ll\", or \"Lo\".  Note that this is different from the `Alphabetic "
"property defined in the section 4.10 'Letters, Alphabetic, and Ideographic' "
"of the Unicode Standard <https://www.unicode.org/versions/Unicode16.0.0/core-"
"spec/chapter-4/#G91002>`_."
msgstr ""
"Returnerar ``True`` om alla tecken i strängen är alfabetiska och det finns "
"minst ett tecken, ``False`` annars.  Alfabetiska tecken är de tecken som i "
"Unicodes teckendatabas definieras som \"Letter\", dvs. de som har en allmän "
"kategoriegenskap som är en av \"Lm\", \"Lt\", \"Lu\", \"Ll\" eller \"Lo\".  "
"Observera att detta skiljer sig från egenskapen `Alphabetic som definieras i "
"avsnitt 4.10 'Letters, Alphabetic, and Ideographic' i Unicode-standarden "
"<https://www.unicode.org/versions/Unicode16.0.0/core-spec/chapter-4/"
"#G91002>`_."

#: ../../library/stdtypes.rst:1997
msgid ""
"Return ``True`` if the string is empty or all characters in the string are "
"ASCII, ``False`` otherwise. ASCII characters have code points in the range "
"U+0000-U+007F."
msgstr ""
"Returnerar ``True`` om strängen är tom eller om alla tecken i strängen är "
"ASCII, annars ``False``. ASCII-tecken har kodpunkter i intervallet U+0000-"
"U+007F."

#: ../../library/stdtypes.rst:2006
msgid ""
"Return ``True`` if all characters in the string are decimal characters and "
"there is at least one character, ``False`` otherwise. Decimal characters are "
"those that can be used to form numbers in base 10, e.g. U+0660, ARABIC-INDIC "
"DIGIT ZERO.  Formally a decimal character is a character in the Unicode "
"General Category \"Nd\"."
msgstr ""
"Returnerar ``True`` om alla tecken i strängen är decimala tecken och det "
"finns minst ett tecken, annars ``False``. Decimala tecken är sådana som kan "
"användas för att bilda tal i bas 10, t.ex. U+0660, ARABIC-INDIC DIGIT ZERO.  "
"Formellt är ett decimaltal ett tecken i Unicodes allmänna kategori \"Nd\"."

#: ../../library/stdtypes.rst:2016
msgid ""
"Return ``True`` if all characters in the string are digits and there is at "
"least one character, ``False`` otherwise.  Digits include decimal characters "
"and digits that need special handling, such as the compatibility superscript "
"digits. This covers digits which cannot be used to form numbers in base 10, "
"like the Kharosthi numbers.  Formally, a digit is a character that has the "
"property value Numeric_Type=Digit or Numeric_Type=Decimal."
msgstr ""
"Returnerar ``True`` om alla tecken i strängen är siffror och det finns minst "
"ett tecken, annars ``False``.  Siffror omfattar decimala tecken och siffror "
"som kräver särskild hantering, t.ex. upphöjda siffror för kompatibilitet. "
"Detta omfattar siffror som inte kan användas för att bilda tal i bas 10, t."
"ex. Kharosthi-talen.  Formellt sett är en siffra ett tecken som har "
"egenskapsvärdet Numeric_Type=Digit eller Numeric_Type=Decimal."

#: ../../library/stdtypes.rst:2026
msgid ""
"Return ``True`` if the string is a valid identifier according to the "
"language definition, section :ref:`identifiers`."
msgstr ""
"Returnerar ``True`` om strängen är en giltig identifierare enligt "
"språkdefinitionen, avsnitt :ref:`identifiers`."

#: ../../library/stdtypes.rst:2029
msgid ""
":func:`keyword.iskeyword` can be used to test whether string ``s`` is a "
"reserved identifier, such as :keyword:`def` and :keyword:`class`."
msgstr ""
":func:`keyword.iskeyword` kan användas för att testa om strängen ``s`` är en "
"reserverad identifierare, t.ex. :keyword:`def` och :keyword:`class`."

#: ../../library/stdtypes.rst:2032
msgid "Example: ::"
msgstr "Exempel: ::"

#: ../../library/stdtypes.rst:2035
msgid ""
">>> from keyword import iskeyword\n"
"\n"
">>> 'hello'.isidentifier(), iskeyword('hello')\n"
"(True, False)\n"
">>> 'def'.isidentifier(), iskeyword('def')\n"
"(True, True)"
msgstr ""
">>> från nyckelord import iskeyword\n"
"\n"
">>> 'hello'.isidentifier(), iskeyword('hello')\n"
"(sant, falskt)\n"
">>> 'def'.isidentifier(), iskeyword('def')\n"
"(sant, sant)"

#: ../../library/stdtypes.rst:2045
msgid ""
"Return ``True`` if all cased characters [4]_ in the string are lowercase and "
"there is at least one cased character, ``False`` otherwise."
msgstr ""
"Returnerar ``True`` om alla tecken med versaler [4]_ i strängen är gemener "
"och det finns minst ett tecken med versaler, ``False`` annars."

#: ../../library/stdtypes.rst:2051
msgid ""
"Return ``True`` if all characters in the string are numeric characters, and "
"there is at least one character, ``False`` otherwise. Numeric characters "
"include digit characters, and all characters that have the Unicode numeric "
"value property, e.g. U+2155, VULGAR FRACTION ONE FIFTH.  Formally, numeric "
"characters are those with the property value Numeric_Type=Digit, "
"Numeric_Type=Decimal or Numeric_Type=Numeric."
msgstr ""
"Returnerar ``True`` om alla tecken i strängen är numeriska tecken och det "
"finns minst ett tecken, annars ``False``. Numeriska tecken inkluderar "
"siffertecken och alla tecken som har egenskapen Unicode numeriskt värde, t."
"ex. U+2155, VULGAR FRACTION ONE FIFTH.  Formellt är numeriska tecken de som "
"har egenskapsvärdet Numeric_Type=Digit, Numeric_Type=Decimal eller "
"Numeric_Type=Numeric."

#: ../../library/stdtypes.rst:2061
msgid ""
"Return ``True`` if all characters in the string are printable, ``False`` if "
"it contains at least one non-printable character."
msgstr ""
"Returnerar ``True`` om alla tecken i strängen är utskrivbara, ``False`` om "
"den innehåller minst ett icke-utskrivbart tecken."

#: ../../library/stdtypes.rst:2064
msgid ""
"Here \"printable\" means the character is suitable for :func:`repr` to use "
"in its output; \"non-printable\" means that :func:`repr` on built-in types "
"will hex-escape the character.  It has no bearing on the handling of strings "
"written to :data:`sys.stdout` or :data:`sys.stderr`."
msgstr ""
"Här betyder \"printable\" att tecknet är lämpligt för :func:`repr` att "
"använda i sin utdata; \"non-printable\" betyder att :func:`repr` på inbyggda "
"typer kommer att hex-escape tecknet.  Det har ingen betydelse för "
"hanteringen av strängar som skrivs till :data:`sys.stdout` eller :data:`sys."
"stderr`."

#: ../../library/stdtypes.rst:2069
msgid ""
"The printable characters are those which in the Unicode character database "
"(see :mod:`unicodedata`) have a general category in group Letter, Mark, "
"Number, Punctuation, or Symbol (L, M, N, P, or S); plus the ASCII space "
"0x20. Nonprintable characters are those in group Separator or Other (Z or "
"C), except the ASCII space."
msgstr ""
"De tryckbara tecknen är de som i Unicodes teckendatabas (se :mod:"
"`unicodedata`) har en allmän kategori i gruppen Letter, Mark, Number, "
"Punctuation, or Symbol (L, M, N, P, or S); plus ASCII-rymden 0x20. Icke-"
"tryckbara tecken är de som finns i gruppen Separator eller Annat (Z eller "
"C), förutom ASCII-utrymmet."

#: ../../library/stdtypes.rst:2078
msgid ""
"Return ``True`` if there are only whitespace characters in the string and "
"there is at least one character, ``False`` otherwise."
msgstr ""
"Returnerar ``True`` om det bara finns blankstegstecken i strängen och det "
"finns minst ett tecken, ``False`` annars."

#: ../../library/stdtypes.rst:2081
msgid ""
"A character is *whitespace* if in the Unicode character database (see :mod:"
"`unicodedata`), either its general category is ``Zs`` (\"Separator, "
"space\"), or its bidirectional class is one of ``WS``, ``B``, or ``S``."
msgstr ""
"Ett tecken är *whitespace* om det i Unicodes teckendatabas (se :mod:"
"`unicodedata`) antingen har den allmänna kategorin ``Zs`` (\"Separator, "
"mellanslag\"), eller om dess dubbelriktade klass är en av ``WS``, ``B`` "
"eller ``S``."

#: ../../library/stdtypes.rst:2089
msgid ""
"Return ``True`` if the string is a titlecased string and there is at least "
"one character, for example uppercase characters may only follow uncased "
"characters and lowercase characters only cased ones.  Return ``False`` "
"otherwise."
msgstr ""
"Returnerar ``True`` om strängen är en titlecased-sträng och det finns minst "
"ett tecken, till exempel kan versaler bara följa obokstaverade tecken och "
"gemena tecken bara bokstaverade.  Returnerar ``False`` annars."

#: ../../library/stdtypes.rst:2096
msgid ""
"Return ``True`` if all cased characters [4]_ in the string are uppercase and "
"there is at least one cased character, ``False`` otherwise."
msgstr ""
"Returnerar ``True`` om alla tecken med versaler [4]_ i strängen är versaler "
"och det finns minst ett tecken med versaler, ``False`` annars."

#: ../../library/stdtypes.rst:2114
msgid ""
"Return a string which is the concatenation of the strings in *iterable*. A :"
"exc:`TypeError` will be raised if there are any non-string values in "
"*iterable*, including :class:`bytes` objects.  The separator between "
"elements is the string providing this method."
msgstr ""
"Returnerar en sträng som är en konkatenering av strängarna i *iterable*. "
"Ett :exc:`TypeError` kommer att uppstå om det finns några värden som inte är "
"strängar i *iterable*, inklusive :class:`bytes`-objekt.  Separatorn mellan "
"elementen är den sträng som tillhandahåller denna metod."

#: ../../library/stdtypes.rst:2122
msgid ""
"Return the string left justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is an ASCII space). The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Returnerar strängen vänsterställd i en sträng med längden *width*. Utfyllnad "
"görs med det angivna *fillchar* (standard är ett ASCII-rymd). Den "
"ursprungliga strängen returneras om *width* är mindre än eller lika med "
"``len(s)``."

#: ../../library/stdtypes.rst:2129
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"lowercase."
msgstr ""
"Returnerar en kopia av strängen med alla tecken med versaler [4]_ "
"konverterade till gemener."

#: ../../library/stdtypes.rst:2132
msgid ""
"The lowercasing algorithm used is `described in section 3.13 'Default Case "
"Folding' of the Unicode Standard <https://www.unicode.org/versions/"
"Unicode16.0.0/core-spec/chapter-3/#G33992>`__."
msgstr ""
"Den algoritm för gemener som används beskrivs i avsnitt 3.13 \"Default Case "
"Folding\" i Unicode-standarden <https://www.unicode.org/versions/"
"Unicode16.0.0/core-spec/chapter-3/#G33992>`__."

#: ../../library/stdtypes.rst:2139
msgid ""
"Return a copy of the string with leading characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a prefix; rather, all combinations of its values "
"are stripped::"
msgstr ""
"Returnerar en kopia av strängen med inledande tecken borttagna.  Argumentet "
"*chars* är en sträng som anger den uppsättning tecken som ska tas bort.  Om "
"*chars* utelämnas eller är ``None`` är standardinställningen att ta bort "
"blanksteg.  Argumentet *chars* är inte ett prefix, utan alla kombinationer "
"av dess värden tas bort::"

#: ../../library/stdtypes.rst:2144
msgid ""
">>> '   spacious   '.lstrip()\n"
"'spacious   '\n"
">>> 'www.example.com'.lstrip('cmowz.')\n"
"'example.com'"
msgstr ""
">>> ' rymlig '.lstrip()\n"
"'rymlig '\n"
">>> 'www.example.com'.lstrip('cmowz.')\n"
"'exempel.com'"

#: ../../library/stdtypes.rst:2149
msgid ""
"See :meth:`str.removeprefix` for a method that will remove a single prefix "
"string rather than all of a set of characters.  For example::"
msgstr ""
"Se :meth:`str.removeprefix` för en metod som tar bort en enda prefixsträng i "
"stället för alla tecken i en uppsättning.  Till exempel::"

#: ../../library/stdtypes.rst:2152
msgid ""
">>> 'Arthur: three!'.lstrip('Arthur: ')\n"
"'ee!'\n"
">>> 'Arthur: three!'.removeprefix('Arthur: ')\n"
"'three!'"
msgstr ""
">>> \"Arthur: tre!\".lstrip(\"Arthur: ')\n"
"'ee!'\n"
">>> 'Arthur: tre!'.removeprefix('Arthur: ')\n"
"'tre!'"

#: ../../library/stdtypes.rst:2160
msgid ""
"This static method returns a translation table usable for :meth:`str."
"translate`."
msgstr ""
"Denna statiska metod returnerar en översättningstabell som kan användas för :"
"meth:`str.translate`."

#: ../../library/stdtypes.rst:2162
msgid ""
"If there is only one argument, it must be a dictionary mapping Unicode "
"ordinals (integers) or characters (strings of length 1) to Unicode ordinals, "
"strings (of arbitrary lengths) or ``None``.  Character keys will then be "
"converted to ordinals."
msgstr ""
"Om det bara finns ett argument måste det vara en ordbok som mappar Unicode-"
"ordinaler (heltal) eller tecken (strängar av längd 1) till Unicode-"
"ordinaler, strängar (av godtycklig längd) eller ``None``.  Teckennycklar "
"kommer då att konverteras till ordinaler."

#: ../../library/stdtypes.rst:2167
msgid ""
"If there are two arguments, they must be strings of equal length, and in the "
"resulting dictionary, each character in x will be mapped to the character at "
"the same position in y.  If there is a third argument, it must be a string, "
"whose characters will be mapped to ``None`` in the result."
msgstr ""
"Om det finns två argument måste de vara strängar av samma längd, och i den "
"resulterande ordlistan kommer varje tecken i x att mappas till tecknet på "
"samma position i y. Om det finns ett tredje argument måste det vara en "
"sträng, vars tecken kommer att mappas till ``None`` i resultatet."

#: ../../library/stdtypes.rst:2175
msgid ""
"Split the string at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part "
"after the separator.  If the separator is not found, return a 3-tuple "
"containing the string itself, followed by two empty strings."
msgstr ""
"Dela strängen vid den första förekomsten av *sep* och returnera en 3-tupel "
"som innehåller delen före separatorn, själva separatorn och delen efter "
"separatorn.  Om separatorn inte hittas returneras en 3-tupel som innehåller "
"själva strängen, följt av två tomma strängar."

#: ../../library/stdtypes.rst:2183
msgid ""
"If the string starts with the *prefix* string, return "
"``string[len(prefix):]``. Otherwise, return a copy of the original string::"
msgstr ""
"Om strängen börjar med *prefix*-strängen returneras "
"``sträng[len(prefix):]``. Annars returneras en kopia av den ursprungliga "
"strängen::"

#: ../../library/stdtypes.rst:2187
msgid ""
">>> 'TestHook'.removeprefix('Test')\n"
"'Hook'\n"
">>> 'BaseTestCase'.removeprefix('Test')\n"
"'BaseTestCase'"
msgstr ""
">>> 'TestHook'.removeprefix('Test')\n"
"'Hook'\n"
">>> 'BaseTestCase'.removeprefix('Test')\n"
"'BaseTestCase'"

#: ../../library/stdtypes.rst:2197
msgid ""
"If the string ends with the *suffix* string and that *suffix* is not empty, "
"return ``string[:-len(suffix)]``. Otherwise, return a copy of the original "
"string::"
msgstr ""
"Om strängen slutar med strängen *suffix* och *suffix* inte är tomt, "
"returneras ``sträng[:-len(suffix)]``. Annars returneras en kopia av den "
"ursprungliga strängen::"

#: ../../library/stdtypes.rst:2201
msgid ""
">>> 'MiscTests'.removesuffix('Tests')\n"
"'Misc'\n"
">>> 'TmpDirMixin'.removesuffix('Tests')\n"
"'TmpDirMixin'"
msgstr ""
">>> 'MiscTests'.removesuffix('Tester')\n"
"'Misc'\n"
">>> 'TmpDirMixin'.removesuffix('Tester')\n"
"'TmpDirMixin'"

#: ../../library/stdtypes.rst:2211
msgid ""
"Return a copy of the string with all occurrences of substring *old* replaced "
"by *new*.  If *count* is given, only the first *count* occurrences are "
"replaced. If *count* is not specified or ``-1``, then all occurrences are "
"replaced."
msgstr ""
"Returnerar en kopia av strängen med alla förekomster av delsträngen *old* "
"ersatt av *new*.  Om *count* anges ersätts endast de första *count* "
"förekomsterna. Om *count* inte anges eller om ``-1``, ersätts alla "
"förekomster."

#: ../../library/stdtypes.rst:2215
msgid "*count* is now supported as a keyword argument."
msgstr "*count* stöds nu som ett nyckelordsargument."

#: ../../library/stdtypes.rst:2221
msgid ""
"Return the highest index in the string where substring *sub* is found, such "
"that *sub* is contained within ``s[start:end]``.  Optional arguments *start* "
"and *end* are interpreted as in slice notation.  Return ``-1`` on failure."
msgstr ""
"Returnerar det högsta indexet i strängen där delsträngen *sub* finns, så att "
"*sub* ingår i ``s[start:end]``.  De valfria argumenten *start* och *end* "
"tolkas som i slice-notation.  Returnerar ``-1`` om den misslyckas."

#: ../../library/stdtypes.rst:2228
msgid ""
"Like :meth:`rfind` but raises :exc:`ValueError` when the substring *sub* is "
"not found."
msgstr ""
"Som :meth:`rfind` men ger upphov till :exc:`ValueError` när delsträngen "
"*sub* inte hittas."

#: ../../library/stdtypes.rst:2234
msgid ""
"Return the string right justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is an ASCII space). The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Returnerar strängen högerställd i en sträng med längden *width*. Utfyllnad "
"görs med det angivna *fillchar* (standard är ett ASCII-rymd). Den "
"ursprungliga strängen returneras om *width* är mindre än eller lika med "
"``len(s)``."

#: ../../library/stdtypes.rst:2241
msgid ""
"Split the string at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part "
"after the separator.  If the separator is not found, return a 3-tuple "
"containing two empty strings, followed by the string itself."
msgstr ""
"Dela strängen vid den sista förekomsten av *sep* och returnera en 3-tupel "
"som innehåller delen före separatorn, själva separatorn och delen efter "
"separatorn.  Om separatorn inte hittas, returneras en 3-tupel som innehåller "
"två tomma strängar, följt av själva strängen."

#: ../../library/stdtypes.rst:2249
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string. If *maxsplit* is given, at most *maxsplit* splits are done, the "
"*rightmost* ones.  If *sep* is not specified or ``None``, any whitespace "
"string is a separator.  Except for splitting from the right, :meth:`rsplit` "
"behaves like :meth:`split` which is described in detail below."
msgstr ""
"Returnerar en lista med orden i strängen, med *sep* som avgränsningssträng. "
"Om *maxsplit* anges görs högst *maxsplit* uppdelningar, de *högst till "
"höger*.  Om *sep* inte anges eller om ``None``, är alla strängar med "
"blanksteg en separator.  Förutom att dela upp från höger, beter sig :meth:"
"`rsplit` som :meth:`split` som beskrivs i detalj nedan."

#: ../../library/stdtypes.rst:2258
msgid ""
"Return a copy of the string with trailing characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a suffix; rather, all combinations of its values "
"are stripped::"
msgstr ""
"Returnerar en kopia av strängen med borttagna efterföljande tecken.  "
"Argumentet *chars* är en sträng som anger den uppsättning tecken som ska tas "
"bort.  Om det utelämnas eller ``None``, är *chars*-argumentet standard för "
"att ta bort blanksteg.  Argumentet *chars* är inte ett suffix, utan alla "
"kombinationer av dess värden tas bort::"

#: ../../library/stdtypes.rst:2263
msgid ""
">>> '   spacious   '.rstrip()\n"
"'   spacious'\n"
">>> 'mississippi'.rstrip('ipz')\n"
"'mississ'"
msgstr ""
">>> ' rymlig '.rstrip()\n"
"' rymlig'\n"
">>> 'mississippi'.rstrip('ipz')\n"
"'mississ'"

#: ../../library/stdtypes.rst:2268
msgid ""
"See :meth:`str.removesuffix` for a method that will remove a single suffix "
"string rather than all of a set of characters.  For example::"
msgstr ""
"Se :meth:`str.removesuffix` för en metod som tar bort en enda suffixsträng "
"istället för alla tecken i en uppsättning.  Till exempel::"

#: ../../library/stdtypes.rst:2271
msgid ""
">>> 'Monty Python'.rstrip(' Python')\n"
"'M'\n"
">>> 'Monty Python'.removesuffix(' Python')\n"
"'Monty'"
msgstr ""
">>> 'Monty Python'.rstrip(' Python')\n"
"'M'\n"
">>> 'Monty Python'.removesuffix(' Python')\n"
"'Monty'"

#: ../../library/stdtypes.rst:2278
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string.  If *maxsplit* is given, at most *maxsplit* splits are done (thus, "
"the list will have at most ``maxsplit+1`` elements).  If *maxsplit* is not "
"specified or ``-1``, then there is no limit on the number of splits (all "
"possible splits are made)."
msgstr ""
"Returnerar en lista med orden i strängen, med *sep* som avgränsningssträng.  "
"Om *maxsplit* anges görs högst *maxsplit* uppdelningar (listan kommer alltså "
"att ha högst ``maxsplit+1`` element).  Om *maxsplit* inte anges eller "
"``-1``, finns det ingen begränsning av antalet uppdelningar (alla möjliga "
"uppdelningar görs)."

#: ../../library/stdtypes.rst:2284
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty strings (for example, ``'1,,2'.split(',')`` returns "
"``['1', '', '2']``).  The *sep* argument may consist of multiple characters "
"as a single delimiter (to split with multiple delimiters, use :func:`re."
"split`). Splitting an empty string with a specified separator returns "
"``['']``."
msgstr ""
"Om *sep* anges grupperas inte på varandra följande avgränsare och de anses "
"avgränsa tomma strängar (till exempel ger ``'1,,2'.split(',') ``['1', '', "
"'2']``).  Argumentet *sep* kan bestå av flera tecken som en enda avgränsare "
"(för att dela upp med flera avgränsare, använd :func:`re.split`). Om en tom "
"sträng delas upp med en angiven avgränsare returneras ``['']``."

#: ../../library/stdtypes.rst:2291 ../../library/stdtypes.rst:2309
#: ../../library/stdtypes.rst:2321 ../../library/stdtypes.rst:2373
#: ../../library/stdtypes.rst:2441 ../../library/stdtypes.rst:2509
#: ../../library/stdtypes.rst:3541 ../../library/stdtypes.rst:3559
#: ../../library/stdtypes.rst:3650 ../../library/stdtypes.rst:3666
#: ../../library/stdtypes.rst:3691 ../../library/stdtypes.rst:3705
#: ../../library/stdtypes.rst:3733 ../../library/stdtypes.rst:3747
#: ../../library/stdtypes.rst:3765 ../../library/stdtypes.rst:3792
#: ../../library/stdtypes.rst:3815 ../../library/stdtypes.rst:3842
#: ../../library/stdtypes.rst:3884 ../../library/stdtypes.rst:3908
msgid "For example::"
msgstr "Till exempel::"

#: ../../library/stdtypes.rst:2293
msgid ""
">>> '1,2,3'.split(',')\n"
"['1', '2', '3']\n"
">>> '1,2,3'.split(',', maxsplit=1)\n"
"['1', '2,3']\n"
">>> '1,2,,3,'.split(',')\n"
"['1', '2', '', '3', '']\n"
">>> '1<>2<>3<4'.split('<>')\n"
"['1', '2', '3<4']"
msgstr ""
">>> '1,2,3'.split(',')\n"
"['1', '2', '3']\n"
">>> '1,2,3'.split(',', maxsplit=1)\n"
"['1', '2,3']\n"
">>> '1,2,,3,'.split(',')\n"
"['1', '2', '', '3', '']\n"
">>> '1<>2<>3<4'.split('<>')\n"
"['1', '2', '3<4']"

#: ../../library/stdtypes.rst:2302
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is "
"applied: runs of consecutive whitespace are regarded as a single separator, "
"and the result will contain no empty strings at the start or end if the "
"string has leading or trailing whitespace.  Consequently, splitting an empty "
"string or a string consisting of just whitespace with a ``None`` separator "
"returns ``[]``."
msgstr ""
"Om *sep* inte anges eller är ``None`` används en annan delningsalgoritm: "
"flera på varandra följande blanksteg betraktas som en enda separator, och "
"resultatet innehåller inga tomma strängar i början eller slutet om strängen "
"har inledande eller avslutande blanksteg.  Om en tom sträng eller en sträng "
"som bara består av blanksteg delas upp med en ``None``-separator blir "
"följaktligen resultatet ``[]``."

#: ../../library/stdtypes.rst:2311
msgid ""
">>> '1 2 3'.split()\n"
"['1', '2', '3']\n"
">>> '1 2 3'.split(maxsplit=1)\n"
"['1', '2 3']\n"
">>> '   1   2   3   '.split()\n"
"['1', '2', '3']"
msgstr ""
">>> '1 2 3'.split()\n"
"['1', '2', '3']\n"
">>> '1 2 3'.split(maxsplit=1)\n"
"['1', '2 3']\n"
">>> ' 1 2 3 '.split()\n"
"['1', '2', '3']"

#: ../../library/stdtypes.rst:2318
msgid ""
"If *sep* is not specified or is ``None`` and  *maxsplit* is ``0``, only "
"leading runs of consecutive whitespace are considered."
msgstr ""
"Om *sep* inte anges eller är ``None`` och *maxsplit* är ``0``, beaktas "
"endast ledande serier av på varandra följande blanksteg."

#: ../../library/stdtypes.rst:2323
msgid ""
">>> \"\".split(None, 0)\n"
"[]\n"
">>> \"   \".split(None, 0)\n"
"[]\n"
">>> \"   foo   \".split(maxsplit=0)\n"
"['foo   ']"
msgstr ""
">>> \"\".split(None, 0)\n"
"[]\n"
">>> \" \".split(Ingen, 0)\n"
"[]\n"
">>> \" foo \".split(maxsplit=0)\n"
"['foo ']"

#: ../../library/stdtypes.rst:2336
msgid ""
"Return a list of the lines in the string, breaking at line boundaries.  Line "
"breaks are not included in the resulting list unless *keepends* is given and "
"true."
msgstr ""
"Returnerar en lista över raderna i strängen, med radbrytning vid "
"radgränser.  Radbrytningar inkluderas inte i den resulterande listan om inte "
"*keepends* anges och är true."

#: ../../library/stdtypes.rst:2340
msgid ""
"This method splits on the following line boundaries.  In particular, the "
"boundaries are a superset of :term:`universal newlines`."
msgstr ""
"Denna metod delar på följande linjegränser.  I synnerhet är gränserna en "
"övermängd av :term:`universal newlines`."

#: ../../library/stdtypes.rst:2344
msgid "Representation"
msgstr "Representation"

#: ../../library/stdtypes.rst:2344
msgid "Description"
msgstr "Beskrivning"

#: ../../library/stdtypes.rst:2346
msgid "``\\n``"
msgstr "``\\n``"

#: ../../library/stdtypes.rst:2346
msgid "Line Feed"
msgstr "Linje matning"

#: ../../library/stdtypes.rst:2348
msgid "``\\r``"
msgstr "``\\r``"

#: ../../library/stdtypes.rst:2348
msgid "Carriage Return"
msgstr "Vagnretur"

#: ../../library/stdtypes.rst:2350
msgid "``\\r\\n``"
msgstr "``R\\n``"

#: ../../library/stdtypes.rst:2350
msgid "Carriage Return + Line Feed"
msgstr "Vagnretur + radmatning"

#: ../../library/stdtypes.rst:2352
msgid "``\\v`` or ``\\x0b``"
msgstr "\"v\" eller \"x0b"

#: ../../library/stdtypes.rst:2352
msgid "Line Tabulation"
msgstr "Linjetabellering"

#: ../../library/stdtypes.rst:2354
msgid "``\\f`` or ``\\x0c``"
msgstr "\"f\" eller \"x0c"

#: ../../library/stdtypes.rst:2354
msgid "Form Feed"
msgstr "Formulärmatning"

#: ../../library/stdtypes.rst:2356
msgid "``\\x1c``"
msgstr "``x1c``"

#: ../../library/stdtypes.rst:2356
msgid "File Separator"
msgstr "Filavskiljare"

#: ../../library/stdtypes.rst:2358
msgid "``\\x1d``"
msgstr "``x1d``"

#: ../../library/stdtypes.rst:2358
msgid "Group Separator"
msgstr "Gruppseparator"

#: ../../library/stdtypes.rst:2360
msgid "``\\x1e``"
msgstr "``x1e``"

#: ../../library/stdtypes.rst:2360
msgid "Record Separator"
msgstr "Skivseparator"

#: ../../library/stdtypes.rst:2362
msgid "``\\x85``"
msgstr "``\\x85``"

#: ../../library/stdtypes.rst:2362
msgid "Next Line (C1 Control Code)"
msgstr "Nästa rad (C1-kontrollkod)"

#: ../../library/stdtypes.rst:2364
msgid "``\\u2028``"
msgstr "``\\u2028``"

#: ../../library/stdtypes.rst:2364
msgid "Line Separator"
msgstr "Separatorlinje"

#: ../../library/stdtypes.rst:2366
msgid "``\\u2029``"
msgstr "``\\u2029``"

#: ../../library/stdtypes.rst:2366
msgid "Paragraph Separator"
msgstr "Paragrafavskiljare"

#: ../../library/stdtypes.rst:2371
msgid "``\\v`` and ``\\f`` added to list of line boundaries."
msgstr "\"v\" och \"f\" läggs till i listan över linjegränser."

#: ../../library/stdtypes.rst:2375
msgid ""
">>> 'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines()\n"
"['ab c', '', 'de fg', 'kl']\n"
">>> 'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines(keepends=True)\n"
"['ab c\\n', '\\n', 'de fg\\r', 'kl\\r\\n']"
msgstr ""
">>> 'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines()\n"
"['ab c', '', 'de fg', 'kl']\n"
">>> 'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines(keepends=True)\n"
"['ab c\\n', '\\n', 'de fg\\r', 'kl\\r\\n']"

#: ../../library/stdtypes.rst:2380
msgid ""
"Unlike :meth:`~str.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break "
"does not result in an extra line::"
msgstr ""
"Till skillnad från :meth:`~str.split` när en avgränsningssträng *sep* anges, "
"returnerar den här metoden en tom lista för den tomma strängen, och en "
"terminal radbrytning resulterar inte i en extra rad::"

#: ../../library/stdtypes.rst:2384
msgid ""
">>> \"\".splitlines()\n"
"[]\n"
">>> \"One line\\n\".splitlines()\n"
"['One line']"
msgstr ""
">>> \"\".splitlines()\n"
"[]\n"
">>> \"En rad\\n\".splitlines()\n"
"['En rad']"

#: ../../library/stdtypes.rst:2389
msgid "For comparison, ``split('\\n')`` gives::"
msgstr "Som jämförelse ger ``split('\\n')``::"

#: ../../library/stdtypes.rst:2391
msgid ""
">>> ''.split('\\n')\n"
"['']\n"
">>> 'Two lines\\n'.split('\\n')\n"
"['Two lines', '']"
msgstr ""
">>> ''.split('\\n')\n"
"['']\n"
">>> 'Två linjer\\n'.split('\\n')\n"
"['Två rader', '']"

#: ../../library/stdtypes.rst:2399
msgid ""
"Return ``True`` if string starts with the *prefix*, otherwise return "
"``False``. *prefix* can also be a tuple of prefixes to look for.  With "
"optional *start*, test string beginning at that position.  With optional "
"*end*, stop comparing string at that position."
msgstr ""
"Returnerar ``True`` om strängen börjar med *prefixet*, annars returneras "
"``False``. *prefix* kan också vara en tupel av prefix att leta efter.  Med "
"valfri *start*, testa strängen som börjar vid den positionen.  Med valfri "
"*end*, sluta jämföra strängen vid den positionen."

#: ../../library/stdtypes.rst:2407
msgid ""
"Return a copy of the string with the leading and trailing characters "
"removed. The *chars* argument is a string specifying the set of characters "
"to be removed. If omitted or ``None``, the *chars* argument defaults to "
"removing whitespace. The *chars* argument is not a prefix or suffix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"Returnerar en kopia av strängen med de inledande och avslutande tecknen "
"borttagna. Argumentet *chars* är en sträng som anger den uppsättning tecken "
"som ska tas bort. Om det utelämnas eller ``None``, är *chars*-argumentet "
"standard för att ta bort blanksteg. Argumentet *chars* är inte ett prefix "
"eller suffix, utan alla kombinationer av dess värden tas bort::"

#: ../../library/stdtypes.rst:2413
msgid ""
">>> '   spacious   '.strip()\n"
"'spacious'\n"
">>> 'www.example.com'.strip('cmowz.')\n"
"'example'"
msgstr ""
">>> ' rymlig '.strip()\n"
"'rymlig'\n"
">>> 'www.example.com'.strip('cmowz.')\n"
"'exempel'"

#: ../../library/stdtypes.rst:2418
msgid ""
"The outermost leading and trailing *chars* argument values are stripped from "
"the string. Characters are removed from the leading end until reaching a "
"string character that is not contained in the set of characters in *chars*. "
"A similar action takes place on the trailing end. For example::"
msgstr ""
"De yttersta inledande och avslutande *chars*-argumentvärdena tas bort från "
"strängen. Tecken tas bort från den främre änden tills man når ett "
"strängtecken som inte ingår i teckenuppsättningen i *chars*. En liknande "
"åtgärd sker i den bakre änden. Till exempel::"

#: ../../library/stdtypes.rst:2424
msgid ""
">>> comment_string = '#....... Section 3.2.1 Issue #32 .......'\n"
">>> comment_string.strip('.#! ')\n"
"'Section 3.2.1 Issue #32'"
msgstr ""
">>> kommentar_sträng = '#....... Avsnitt 3.2.1 Utgåva #32 .......'\n"
">>> kommentar_sträng.strip('.#! ')\n"
"'Avsnitt 3.2.1 Utgåva #32'"

#: ../../library/stdtypes.rst:2431
msgid ""
"Return a copy of the string with uppercase characters converted to lowercase "
"and vice versa. Note that it is not necessarily true that ``s.swapcase()."
"swapcase() == s``."
msgstr ""
"Returnerar en kopia av strängen med versaler omvandlade till gemener och "
"vice versa. Observera att det inte nödvändigtvis är sant att ``s.swapcase()."
"swapcase() == s``."

#: ../../library/stdtypes.rst:2438
msgid ""
"Return a titlecased version of the string where words start with an "
"uppercase character and the remaining characters are lowercase."
msgstr ""
"Returnerar en titelanpassad version av strängen där orden börjar med en "
"versal och övriga tecken är gemener."

#: ../../library/stdtypes.rst:2443
msgid ""
">>> 'Hello world'.title()\n"
"'Hello World'"
msgstr ""
">>> 'Hej världen'.title()\n"
"'Hej världen'"

#: ../../library/stdtypes.rst:2446 ../../library/stdtypes.rst:3852
msgid ""
"The algorithm uses a simple language-independent definition of a word as "
"groups of consecutive letters.  The definition works in many contexts but it "
"means that apostrophes in contractions and possessives form word boundaries, "
"which may not be the desired result::"
msgstr ""
"Algoritmen använder en enkel språkoberoende definition av ett ord som "
"grupper av på varandra följande bokstäver.  Definitionen fungerar i många "
"sammanhang men innebär att apostrofer i sammandragningar och possessiver "
"bildar ordgränser, vilket kanske inte är det önskade resultatet::"

#: ../../library/stdtypes.rst:2451
msgid ""
">>> \"they're bill's friends from the UK\".title()\n"
"\"They'Re Bill'S Friends From The Uk\""
msgstr ""
">>> \"de är Bills vänner från Storbritannien\".title()\n"
"\"De är Bills vänner från Storbritannien\""

#: ../../library/stdtypes.rst:2454
msgid ""
"The :func:`string.capwords` function does not have this problem, as it "
"splits words on spaces only."
msgstr ""
"Funktionen :func:`string.capwords` har inte detta problem, eftersom den "
"endast delar upp ord efter mellanslag."

#: ../../library/stdtypes.rst:2457
msgid ""
"Alternatively, a workaround for apostrophes can be constructed using regular "
"expressions::"
msgstr ""
"Alternativt kan en lösning för apostrofer konstrueras med hjälp av reguljära "
"uttryck::"

#: ../../library/stdtypes.rst:2460
msgid ""
">>> import re\n"
">>> def titlecase(s):\n"
"...     return re.sub(r\"[A-Za-z]+('[A-Za-z]+)?\",\n"
"...                   lambda mo: mo.group(0).capitalize(),\n"
"...                   s)\n"
"...\n"
">>> titlecase(\"they're bill's friends.\")\n"
"\"They're Bill's Friends.\""
msgstr ""
">>> import re\n"
">>> def titlecase(s):\n"
"... return re.sub(r\"[A-Za-z]+('[A-Za-z]+)?\",\n"
"... lambda mo: mo.group(0).capitalize(),\n"
"... s)\n"
"...\n"
">>> titlecase(\"de är Bills vänner.\")\n"
"\"De är Bills vänner.\""

#: ../../library/stdtypes.rst:2472
msgid ""
"Return a copy of the string in which each character has been mapped through "
"the given translation table.  The table must be an object that implements "
"indexing via :meth:`~object.__getitem__`, typically a :term:`mapping` or :"
"term:`sequence`.  When indexed by a Unicode ordinal (an integer), the table "
"object can do any of the following: return a Unicode ordinal or a string, to "
"map the character to one or more other characters; return ``None``, to "
"delete the character from the return string; or raise a :exc:`LookupError` "
"exception, to map the character to itself."
msgstr ""
"Returnerar en kopia av strängen där varje tecken har mappats genom den "
"angivna översättningstabellen.  Tabellen måste vara ett objekt som "
"implementerar indexering via :meth:`~object.__getitem__`, vanligtvis en :"
"term:`mapping` eller :term:`sequence`.  När tabellen indexeras med en "
"Unicode-ordinal (ett heltal) kan tabellobjektet göra något av följande: "
"returnera en Unicode-ordinal eller en sträng, för att mappa tecknet till ett "
"eller flera andra tecken; returnera ``None``, för att ta bort tecknet från "
"retursträngen; eller skapa ett :exc:`LookupError`-undantag, för att mappa "
"tecknet till sig själv."

#: ../../library/stdtypes.rst:2481
msgid ""
"You can use :meth:`str.maketrans` to create a translation map from character-"
"to-character mappings in different formats."
msgstr ""
"Du kan använda :meth:`str.maketrans` för att skapa en översättningsmappning "
"från tecken-till-tecken-mappningar i olika format."

#: ../../library/stdtypes.rst:2484
msgid ""
"See also the :mod:`codecs` module for a more flexible approach to custom "
"character mappings."
msgstr ""
"Se även modulen :mod:`codecs` för en mer flexibel metod för anpassade "
"teckenmappningar."

#: ../../library/stdtypes.rst:2490
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"uppercase.  Note that ``s.upper().isupper()`` might be ``False`` if ``s`` "
"contains uncased characters or if the Unicode category of the resulting "
"character(s) is not \"Lu\" (Letter, uppercase), but e.g. \"Lt\" (Letter, "
"titlecase)."
msgstr ""
"Returnerar en kopia av strängen med alla tecken med versaler [4]_ "
"konverterade till versaler.  Observera att ``s.upper().isupper()`` kan vara "
"``False`` om ``s`` innehåller obehandlade tecken eller om Unicode-kategorin "
"för de resulterande tecknen inte är \"Lu\" (Letter, uppercase), utan t.ex. "
"\"Lt\" (Letter, titlecase)."

#: ../../library/stdtypes.rst:2496
msgid ""
"The uppercasing algorithm used is `described in section 3.13 'Default Case "
"Folding' of the Unicode Standard <https://www.unicode.org/versions/"
"Unicode16.0.0/core-spec/chapter-3/#G33992>`__."
msgstr ""
"Den uppercasing-algoritm som används beskrivs i avsnitt 3.13 \"Default Case "
"Folding\" i Unicode-standarden <https://www.unicode.org/versions/"
"Unicode16.0.0/core-spec/chapter-3/#G33992>`__."

#: ../../library/stdtypes.rst:2503
msgid ""
"Return a copy of the string left filled with ASCII ``'0'`` digits to make a "
"string of length *width*. A leading sign prefix (``'+'``/``'-'``) is handled "
"by inserting the padding *after* the sign character rather than before. The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Returnerar en kopia av strängen som fyllts med ASCII ``'0'`` siffror för att "
"skapa en sträng med längden *bredd*. Ett ledande teckenprefix (``'+'``/"
"``'-'``) hanteras genom att utfyllnaden infogas *efter* tecknet i stället "
"för före. Den ursprungliga strängen returneras om *width* är mindre än eller "
"lika med ``len(s)``."

#: ../../library/stdtypes.rst:2511
msgid ""
">>> \"42\".zfill(5)\n"
"'00042'\n"
">>> \"-42\".zfill(5)\n"
"'-0042'"
msgstr ""
">>> \"42\".zfill(5)\n"
"'00042'\n"
">>> \"-42\".zfill(5)\n"
"'-0042'"

#: ../../library/stdtypes.rst:2532
msgid "Formatted String Literals (f-strings)"
msgstr "Formaterade strängbokstäver (f-strängar)"

#: ../../library/stdtypes.rst:2535
msgid ""
"The :keyword:`await` and :keyword:`async for` can be used in expressions "
"within f-strings."
msgstr ""
"Nyckelorden :`await` och :keyword:`async for` kan användas i uttryck inom f-"
"strängar."

#: ../../library/stdtypes.rst:2538
msgid "Added the debugging operator (``=``)"
msgstr "Lagt till felsökningsoperatorn (``=``)"

#: ../../library/stdtypes.rst:2540
msgid ""
"Many restrictions on expressions within f-strings have been removed. "
"Notably, nested strings, comments, and backslashes are now permitted."
msgstr ""
"Många restriktioner för uttryck inom f-strängar har tagits bort. Bland annat "
"är nästlade strängar, kommentarer och backslash nu tillåtna."

#: ../../library/stdtypes.rst:2544
msgid ""
"An :dfn:`f-string` (formally a :dfn:`formatted string literal`) is a string "
"literal that is prefixed with ``f`` or ``F``. This type of string literal "
"allows embedding arbitrary Python expressions within *replacement fields*, "
"which are delimited by curly brackets (``{}``). These expressions are "
"evaluated at runtime, similarly to :meth:`str.format`, and are converted "
"into regular :class:`str` objects. For example:"
msgstr ""
"En :dfn:`f-string` (formellt en :dfn:`formatted string literal`) är en "
"stränglitual som har prefixet ``f`` eller ``F``. Den här typen av "
"stränglital möjliggör inbäddning av godtyckliga Python-uttryck i "
"*ersättningsfält*, som avgränsas av hakparenteser (``{}``). Dessa uttryck "
"utvärderas vid körning, på liknande sätt som :meth:`str.format`, och "
"konverteras till vanliga :class:`str`-objekt. Ett exempel:"

#: ../../library/stdtypes.rst:2552
msgid ""
">>> who = 'nobody'\n"
">>> nationality = 'Spanish'\n"
">>> f'{who.title()} expects the {nationality} Inquisition!'\n"
"'Nobody expects the Spanish Inquisition!'"
msgstr ""
">>> vem = 'ingen'\n"
">>> nationalitet = 'spansk'\n"
">>> f'{who.title()} förväntar sig {nationality} inkvisitionen!'\n"
"\"Ingen förväntar sig den spanska inkvisitionen!"

#: ../../library/stdtypes.rst:2559
msgid "It is also possible to use a multi line f-string:"
msgstr "Det är också möjligt att använda en f-sträng med flera linjer:"

#: ../../library/stdtypes.rst:2561
msgid ""
">>> f'''This is a string\n"
"... on two lines'''\n"
"'This is a string\\non two lines'"
msgstr ""
">>> f'''Detta är en sträng\n"
"... på två rader'''\n"
"\"Det här är en sträng på två rader"

#: ../../library/stdtypes.rst:2567
msgid ""
"A single opening curly bracket, ``'{'``, marks a *replacement field* that "
"can contain any Python expression:"
msgstr ""
"En enda öppnande hakparentes, ``'{'``, markerar ett *ersättningsfält* som "
"kan innehålla vilket Python-uttryck som helst:"

#: ../../library/stdtypes.rst:2570
msgid ""
">>> nationality = 'Spanish'\n"
">>> f'The {nationality} Inquisition!'\n"
"'The Spanish Inquisition!'"
msgstr ""
">>> nationalitet = 'spansk'\n"
">>> f'Inkvisitionen {nationality}!'\n"
"\"Den spanska inkvisitionen!"

#: ../../library/stdtypes.rst:2576
msgid "To include a literal ``{`` or ``}``, use a double bracket:"
msgstr ""
"För att inkludera en bokstavlig ``{`` eller ``}``, använd en dubbelparentes:"

#: ../../library/stdtypes.rst:2578
msgid ""
">>> x = 42\n"
">>> f'{{x}} is {x}'\n"
"'{x} is 42'"
msgstr ""
">>> x = 42\n"
">>> f'{{x}} är {x}'\n"
"'{x} är 42'"

#: ../../library/stdtypes.rst:2584
msgid ""
"Functions can also be used, and :ref:`format specifiers <formatstrings>`:"
msgstr ""
"Funktioner kan också användas och :ref:`formatangivelser <formatstrings>`:"

#: ../../library/stdtypes.rst:2586
msgid ""
">>> from math import sqrt\n"
">>> f'√2 \\N{ALMOST EQUAL TO} {sqrt(2):.5f}'\n"
"'√2 ≈ 1.41421'"
msgstr ""
">>> från math importera sqrt\n"
">>> f'√2 \\N{Nästan lika med} {sqrt(2):.5f}'\n"
"'√2 ≈ 1.41421'"

#: ../../library/stdtypes.rst:2592
msgid "Any non-string expression is converted using :func:`str`, by default:"
msgstr ""
"Alla uttryck som inte är strängar konverteras som standard med :func:`str`:"

#: ../../library/stdtypes.rst:2594
msgid ""
">>> from fractions import Fraction\n"
">>> f'{Fraction(1, 3)}'\n"
"'1/3'"
msgstr ""
">>> from fractions import Fraktion\n"
">>> f'{Fraktion(1, 3)}'\n"
"'1/3'"

#: ../../library/stdtypes.rst:2600
msgid ""
"To use an explicit conversion, use the ``!`` (exclamation mark) operator, "
"followed by any of the valid formats, which are:"
msgstr ""
"För att använda en explicit konvertering, använd operatorn ``!`` "
"(utropstecken), följt av något av de giltiga formaten, vilka är:"

#: ../../library/stdtypes.rst:2604 ../../library/stdtypes.rst:2772
#: ../../library/stdtypes.rst:4031
msgid "Conversion"
msgstr "Konvertering"

#: ../../library/stdtypes.rst:2606
msgid "``!a``"
msgstr "``!a``"

#: ../../library/stdtypes.rst:2606
msgid ":func:`ascii`"
msgstr ":func:`ascii`"

#: ../../library/stdtypes.rst:2607
msgid "``!r``"
msgstr "``!r``"

#: ../../library/stdtypes.rst:2607
msgid ":func:`repr`"
msgstr ":func:`repr`"

#: ../../library/stdtypes.rst:2608
msgid "``!s``"
msgstr "``!s``"

#: ../../library/stdtypes.rst:2608
msgid ":func:`str`"
msgstr ":func:`str`"

#: ../../library/stdtypes.rst:2611
msgid "For example:"
msgstr "Till exempel:"

#: ../../library/stdtypes.rst:2613
msgid ""
">>> from fractions import Fraction\n"
">>> f'{Fraction(1, 3)!s}'\n"
"'1/3'\n"
">>> f'{Fraction(1, 3)!r}'\n"
"'Fraction(1, 3)'\n"
">>> question = '¿Dónde está el Presidente?'\n"
">>> print(f'{question!a}')\n"
"'\\xbfD\\xf3nde est\\xe1 el Presidente?'"
msgstr ""
">>> from fractions import Fraktion\n"
">>> f'{Fraktion(1, 3)!s}'\n"
"'1/3'\n"
">>> f'{Fraktion(1, 3)!r}'\n"
"'Fraktion(1, 3)'\n"
">>> fråga = '¿Dónde está el Presidente?'\n"
">>> print(f'{question!a}')\n"
"'\\xbfD\\xf3nde est\\xe1 el Presidente?'"

#: ../../library/stdtypes.rst:2624
msgid ""
"While debugging it may be helpful to see both the expression and its value, "
"by using the equals sign (``=``) after the expression. This preserves spaces "
"within the brackets, and can be used with a converter. By default, the "
"debugging operator uses the :func:`repr` (``!r``) conversion. For example:"
msgstr ""
"Vid felsökning kan det vara till hjälp att se både uttrycket och dess värde "
"genom att använda likhetstecknet (``=``) efter uttrycket. Detta bevarar "
"mellanslag inom parenteserna och kan användas med en konverterare. Som "
"standard använder debugging-operatorn konverteringen :func:`repr` (``!r``). "
"Till exempel"

#: ../../library/stdtypes.rst:2630
msgid ""
">>> from fractions import Fraction\n"
">>> calculation = Fraction(1, 3)\n"
">>> f'{calculation=}'\n"
"'calculation=Fraction(1, 3)'\n"
">>> f'{calculation = }'\n"
"'calculation = Fraction(1, 3)'\n"
">>> f'{calculation = !s}'\n"
"'calculation = 1/3'"
msgstr ""
">>> from fractions import Fraktion\n"
">>> beräkning = Fraktion(1, 3)\n"
">>> f'{calculation=}'\n"
"'beräkning=Fraktion(1, 3)'\n"
">>> f'{beräkning = }'\n"
"'beräkning = Fraktion(1, 3)'\n"
">>> f'{beräkning = !s}'\n"
"'beräkning = 1/3'"

#: ../../library/stdtypes.rst:2641
msgid ""
"Once the output has been evaluated, it can be formatted using a :ref:`format "
"specifier <formatstrings>` following a colon (``':'``). After the expression "
"has been evaluated, and possibly converted to a string, the :meth:`!"
"__format__` method of the result is called with the format specifier, or the "
"empty string if no format specifier is given. The formatted result is then "
"used as the final value for the replacement field. For example:"
msgstr ""
"När utdata har utvärderats kan de formateras med hjälp av :ref:"
"`formatspecificerare <formatstrings>` efter ett kolon (``':'``). När "
"uttrycket har utvärderats och eventuellt konverterats till en sträng anropas "
"resultatets :meth:`!__format__`-metod med formatangivaren, eller den tomma "
"strängen om ingen formatangivelse anges. Det formaterade resultatet används "
"sedan som det slutliga värdet för ersättningsfältet. Till exempel"

#: ../../library/stdtypes.rst:2649
msgid ""
">>> from fractions import Fraction\n"
">>> f'{Fraction(1, 7):.6f}'\n"
"'0.142857'\n"
">>> f'{Fraction(1, 7):_^+10}'\n"
"'___+1/7___'"
msgstr ""
">>> from fractions import Fraktion\n"
">>> f'{Fraktion(1, 7):.6f}'\n"
"'0.142857'\n"
">>> f'{Fraktion(1, 7):_^+10}'\n"
"'___+1/7___'"

#: ../../library/stdtypes.rst:2661
msgid "``printf``-style String Formatting"
msgstr "strängformatering i stil med ``printf``"

#: ../../library/stdtypes.rst:2674
msgid ""
"The formatting operations described here exhibit a variety of quirks that "
"lead to a number of common errors (such as failing to display tuples and "
"dictionaries correctly).  Using the newer :ref:`formatted string literals <f-"
"strings>`, the :meth:`str.format` interface, or :ref:`template strings ($-"
"strings) <template-strings-pep292>` may help avoid these errors. Each of "
"these alternatives provides their own trade-offs and benefits of simplicity, "
"flexibility, and/or extensibility."
msgstr ""
"De formateringsoperationer som beskrivs här uppvisar en rad olika egenheter "
"som leder till ett antal vanliga fel (t.ex. att tuples och ordböcker inte "
"visas korrekt).  Genom att använda den nyare :ref:`formatted string literals "
"<f-strings>`, gränssnittet :meth:`str.format` eller :ref:`template strings "
"($-strings) <template-strings-pep292>` kan dessa fel undvikas. Vart och ett "
"av dessa alternativ ger sina egna kompromisser och fördelar i form av "
"enkelhet, flexibilitet och/eller utbyggbarhet."

#: ../../library/stdtypes.rst:2682
msgid ""
"String objects have one unique built-in operation: the ``%`` operator "
"(modulo). This is also known as the string *formatting* or *interpolation* "
"operator. Given ``format % values`` (where *format* is a string), ``%`` "
"conversion specifications in *format* are replaced with zero or more "
"elements of *values*. The effect is similar to using the :c:func:`sprintf` "
"function in the C language. For example:"
msgstr ""
"Strängobjekt har en unik inbyggd operation: operatorn ``%`` (modulo). Den är "
"också känd som strängens *formatering* eller *interpolering*-operator. Givet "
"``format % värden`` (där *format* är en sträng), ersätts ``%`` "
"konverteringsspecifikationer i *format* med noll eller flera element i "
"*värden*. Effekten liknar användningen av funktionen :c:func:`sprintf` i C-"
"språket. Ett exempel:"

#: ../../library/stdtypes.rst:2689
msgid ""
">>> print('%s has %d quote types.' % ('Python', 2))\n"
"Python has 2 quote types."
msgstr ""
">>> print('%s har %d citattyper.' % ('Python', 2))\n"
"Python har 2 citattyper."

#: ../../library/stdtypes.rst:2694
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of "
"items specified by the format string, or a single mapping object (for "
"example, a dictionary)."
msgstr ""
"Om *format* kräver ett enda argument kan *values* vara ett enda objekt som "
"inte är en tupel. [5]_ Annars måste *values* vara en tupel med exakt det "
"antal objekt som anges i formatsträngen, eller ett enda mappningsobjekt (t."
"ex. en ordbok)."

#: ../../library/stdtypes.rst:2704 ../../library/stdtypes.rst:3963
msgid ""
"A conversion specifier contains two or more characters and has the following "
"components, which must occur in this order:"
msgstr ""
"En konverteringsspecifikator innehåller två eller flera tecken och har "
"följande komponenter, som måste förekomma i denna ordning:"

#: ../../library/stdtypes.rst:2707 ../../library/stdtypes.rst:3966
msgid "The ``'%'`` character, which marks the start of the specifier."
msgstr "Tecknet ``'%'``, som markerar början på specifikationen."

#: ../../library/stdtypes.rst:2709 ../../library/stdtypes.rst:3968
msgid ""
"Mapping key (optional), consisting of a parenthesised sequence of characters "
"(for example, ``(somename)``)."
msgstr ""
"Mappningsnyckel (valfri) som består av en sekvens av tecken inom parentes (t."
"ex. ``(somename)``)."

#: ../../library/stdtypes.rst:2712 ../../library/stdtypes.rst:3971
msgid ""
"Conversion flags (optional), which affect the result of some conversion "
"types."
msgstr ""
"Konverteringsflaggor (valfritt), som påverkar resultatet av vissa "
"konverteringstyper."

#: ../../library/stdtypes.rst:2715 ../../library/stdtypes.rst:3974
msgid ""
"Minimum field width (optional).  If specified as an ``'*'`` (asterisk), the "
"actual width is read from the next element of the tuple in *values*, and the "
"object to convert comes after the minimum field width and optional precision."
msgstr ""
"Minsta fältbredd (valfritt).  Om den anges som en ``'*'`` (asterisk) läses "
"den faktiska bredden från nästa element i tupeln i *values*, och objektet "
"som ska konverteras kommer efter den minsta fältbredden och den valfria "
"precisionen."

#: ../../library/stdtypes.rst:2719 ../../library/stdtypes.rst:3978
msgid ""
"Precision (optional), given as a ``'.'`` (dot) followed by the precision.  "
"If specified as ``'*'`` (an asterisk), the actual precision is read from the "
"next element of the tuple in *values*, and the value to convert comes after "
"the precision."
msgstr ""
"Precision (valfri), anges som en ``'.'`` (punkt) följt av precisionen.  Om "
"den anges som ``'*'`` (en asterisk) läses den faktiska precisionen från "
"nästa element i tupeln i *values*, och värdet som ska konverteras kommer "
"efter precisionen."

#: ../../library/stdtypes.rst:2724 ../../library/stdtypes.rst:3983
msgid "Length modifier (optional)."
msgstr "Längdmodifierare (valfritt)."

#: ../../library/stdtypes.rst:2726 ../../library/stdtypes.rst:3985
msgid "Conversion type."
msgstr "Typ av konvertering."

#: ../../library/stdtypes.rst:2728
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the string *must* include a parenthesised mapping key into that "
"dictionary inserted immediately after the ``'%'`` character. The mapping key "
"selects the value to be formatted from the mapping.  For example:"
msgstr ""
"När det högra argumentet är en ordbok (eller annan mappningstyp), måste "
"formaten i strängen *inkludera* en parentetisk mappningsnyckel till ordboken "
"som infogas omedelbart efter tecknet ``'%'``. Mappningsnyckeln väljer det "
"värde som ska formateras från mappningen.  Till exempel"

#: ../../library/stdtypes.rst:2737 ../../library/stdtypes.rst:3996
msgid ""
"In this case no ``*`` specifiers may occur in a format (since they require a "
"sequential parameter list)."
msgstr ""
"I detta fall får inga ``*``-specifikatorer förekomma i ett format (eftersom "
"de kräver en sekventiell parameterlista)."

#: ../../library/stdtypes.rst:2740 ../../library/stdtypes.rst:3999
msgid "The conversion flag characters are:"
msgstr "Konverteringens flaggtecken är:"

#: ../../library/stdtypes.rst:2749 ../../library/stdtypes.rst:4008
msgid "Flag"
msgstr "Flagga"

#: ../../library/stdtypes.rst:2751 ../../library/stdtypes.rst:4010
msgid "``'#'``"
msgstr "``'#'``"

#: ../../library/stdtypes.rst:2751 ../../library/stdtypes.rst:4010
msgid ""
"The value conversion will use the \"alternate form\" (where defined below)."
msgstr ""
"Värdeomvandlingen kommer att använda den \"alternativa formen\" (enligt "
"definitionen nedan)."

#: ../../library/stdtypes.rst:2754 ../../library/stdtypes.rst:4013
msgid "``'0'``"
msgstr "``'0'``"

#: ../../library/stdtypes.rst:2754 ../../library/stdtypes.rst:4013
msgid "The conversion will be zero padded for numeric values."
msgstr "Omvandlingen kommer att nollställas för numeriska värden."

#: ../../library/stdtypes.rst:2756 ../../library/stdtypes.rst:4015
msgid "``'-'``"
msgstr "``'-'``"

#: ../../library/stdtypes.rst:2756 ../../library/stdtypes.rst:4015
msgid ""
"The converted value is left adjusted (overrides the ``'0'`` conversion if "
"both are given)."
msgstr ""
"Det konverterade värdet lämnas justerat (åsidosätter konverteringen ``'0'`` "
"om båda anges)."

#: ../../library/stdtypes.rst:2759 ../../library/stdtypes.rst:4018
msgid "``' '``"
msgstr "``' '``"

#: ../../library/stdtypes.rst:2759 ../../library/stdtypes.rst:4018
msgid ""
"(a space) A blank should be left before a positive number (or empty string) "
"produced by a signed conversion."
msgstr ""
"(ett mellanslag) Ett mellanslag ska lämnas före ett positivt tal (eller en "
"tom sträng) som produceras genom en signerad konvertering."

#: ../../library/stdtypes.rst:2762 ../../library/stdtypes.rst:4021
msgid "``'+'``"
msgstr "``'+'``"

#: ../../library/stdtypes.rst:2762 ../../library/stdtypes.rst:4021
msgid ""
"A sign character (``'+'`` or ``'-'``) will precede the conversion (overrides "
"a \"space\" flag)."
msgstr ""
"Ett tecken (``'+'`` eller ``'-'``) kommer att föregå konverteringen "
"(åsidosätter en \"mellanslagsflagga\")."

#: ../../library/stdtypes.rst:2766 ../../library/stdtypes.rst:4025
msgid ""
"A length modifier (``h``, ``l``, or ``L``) may be present, but is ignored as "
"it is not necessary for Python -- so e.g. ``%ld`` is identical to ``%d``."
msgstr ""
"En längdmodifierare (``h``, ``l`` eller ``L``) kan förekomma, men ignoreras "
"eftersom den inte är nödvändig för Python - så t.ex. ``%ld`` är identisk med "
"``%d``."

#: ../../library/stdtypes.rst:2769 ../../library/stdtypes.rst:4028
msgid "The conversion types are:"
msgstr "Konverteringstyperna är:"

#: ../../library/stdtypes.rst:2774 ../../library/stdtypes.rst:4033
msgid "``'d'``"
msgstr "``'d'``"

#: ../../library/stdtypes.rst:2774 ../../library/stdtypes.rst:2776
#: ../../library/stdtypes.rst:4033 ../../library/stdtypes.rst:4035
msgid "Signed integer decimal."
msgstr "Decimalt heltal med tecken."

#: ../../library/stdtypes.rst:2776 ../../library/stdtypes.rst:4035
msgid "``'i'``"
msgstr "``'i'``"

#: ../../library/stdtypes.rst:2778 ../../library/stdtypes.rst:4037
msgid "``'o'``"
msgstr "``'o'``"

#: ../../library/stdtypes.rst:2778 ../../library/stdtypes.rst:4037
msgid "Signed octal value."
msgstr "Sekvenserat oktalt värde."

#: ../../library/stdtypes.rst:2780 ../../library/stdtypes.rst:4039
msgid "``'u'``"
msgstr "``'u'``"

#: ../../library/stdtypes.rst:2780 ../../library/stdtypes.rst:4039
msgid "Obsolete type -- it is identical to ``'d'``."
msgstr "Föråldrad typ - identisk med ``'d'``."

#: ../../library/stdtypes.rst:2782 ../../library/stdtypes.rst:4041
msgid "``'x'``"
msgstr "``'x'``"

#: ../../library/stdtypes.rst:2782 ../../library/stdtypes.rst:4041
msgid "Signed hexadecimal (lowercase)."
msgstr "Signerad hexadecimal (gemener)."

#: ../../library/stdtypes.rst:2784 ../../library/stdtypes.rst:4043
msgid "``'X'``"
msgstr "``'X'``"

#: ../../library/stdtypes.rst:2784 ../../library/stdtypes.rst:4043
msgid "Signed hexadecimal (uppercase)."
msgstr "Signerad hexadecimal (versaler)."

#: ../../library/stdtypes.rst:2786 ../../library/stdtypes.rst:4045
msgid "``'e'``"
msgstr "``'e'``"

#: ../../library/stdtypes.rst:2786 ../../library/stdtypes.rst:4045
msgid "Floating-point exponential format (lowercase)."
msgstr "Exponentiellt format för flyttal (små bokstäver)."

#: ../../library/stdtypes.rst:2788 ../../library/stdtypes.rst:4047
msgid "``'E'``"
msgstr "``'E'``"

#: ../../library/stdtypes.rst:2788 ../../library/stdtypes.rst:4047
msgid "Floating-point exponential format (uppercase)."
msgstr "Exponentiellt format för flyttal (versaler)."

#: ../../library/stdtypes.rst:2790 ../../library/stdtypes.rst:4049
msgid "``'f'``"
msgstr "``'f'``"

#: ../../library/stdtypes.rst:2790 ../../library/stdtypes.rst:2792
#: ../../library/stdtypes.rst:4049 ../../library/stdtypes.rst:4051
msgid "Floating-point decimal format."
msgstr "Decimalformat för flyttal."

#: ../../library/stdtypes.rst:2792 ../../library/stdtypes.rst:4051
msgid "``'F'``"
msgstr "``'F'``"

#: ../../library/stdtypes.rst:2794 ../../library/stdtypes.rst:4053
msgid "``'g'``"
msgstr "``'g'``"

#: ../../library/stdtypes.rst:2794 ../../library/stdtypes.rst:4053
msgid ""
"Floating-point format. Uses lowercase exponential format if exponent is less "
"than -4 or not less than precision, decimal format otherwise."
msgstr ""
"Flyttalsformat. Använder exponentiellt format med gemener om exponenten är "
"mindre än -4 eller inte mindre än precision, annars decimalformat."

#: ../../library/stdtypes.rst:2798 ../../library/stdtypes.rst:4057
msgid "``'G'``"
msgstr "``'G'``"

#: ../../library/stdtypes.rst:2798 ../../library/stdtypes.rst:4057
msgid ""
"Floating-point format. Uses uppercase exponential format if exponent is less "
"than -4 or not less than precision, decimal format otherwise."
msgstr ""
"Flyttalsformat. Använder exponentiellt format med versaler om exponenten är "
"mindre än -4 eller inte mindre än precision, annars decimalformat."

#: ../../library/stdtypes.rst:2802 ../../library/stdtypes.rst:4061
msgid "``'c'``"
msgstr "``'c'``"

#: ../../library/stdtypes.rst:2802
msgid "Single character (accepts integer or single character string)."
msgstr "Enstaka tecken (accepterar heltal eller sträng med enstaka tecken)."

#: ../../library/stdtypes.rst:2805 ../../library/stdtypes.rst:4074
msgid "``'r'``"
msgstr "``'r'``"

#: ../../library/stdtypes.rst:2805
msgid "String (converts any Python object using :func:`repr`)."
msgstr "String (konverterar valfritt Python-objekt med :func:`repr`)."

#: ../../library/stdtypes.rst:2808 ../../library/stdtypes.rst:4068
msgid "``'s'``"
msgstr "``'s'``"

#: ../../library/stdtypes.rst:2808
msgid "String (converts any Python object using :func:`str`)."
msgstr "String (konverterar valfritt Python-objekt med :func:`str`)."

#: ../../library/stdtypes.rst:2811 ../../library/stdtypes.rst:4071
msgid "``'a'``"
msgstr "``'a'``"

#: ../../library/stdtypes.rst:2811
msgid "String (converts any Python object using :func:`ascii`)."
msgstr "String (konverterar valfritt Python-objekt med :func:`ascii`)."

#: ../../library/stdtypes.rst:2814 ../../library/stdtypes.rst:4077
msgid "``'%'``"
msgstr "``'%'``"

#: ../../library/stdtypes.rst:2814 ../../library/stdtypes.rst:4077
msgid "No argument is converted, results in a ``'%'`` character in the result."
msgstr ""
"Inget argument konverteras, vilket resulterar i ett ``'%'``-tecken i "
"resultatet."

#: ../../library/stdtypes.rst:2821 ../../library/stdtypes.rst:4084
msgid ""
"The alternate form causes a leading octal specifier (``'0o'``) to be "
"inserted before the first digit."
msgstr ""
"Den alternativa formen innebär att en ledande oktalspecifikator (``'0o'``) "
"infogas före den första siffran."

#: ../../library/stdtypes.rst:2825 ../../library/stdtypes.rst:4088
msgid ""
"The alternate form causes a leading ``'0x'`` or ``'0X'`` (depending on "
"whether the ``'x'`` or ``'X'`` format was used) to be inserted before the "
"first digit."
msgstr ""
"Den alternativa formen gör att en inledande ``'0x'`` eller ``'0X'`` "
"(beroende på om formatet ``'x'`` eller ``'X'`` användes) infogas före den "
"första siffran."

#: ../../library/stdtypes.rst:2829 ../../library/stdtypes.rst:4092
msgid ""
"The alternate form causes the result to always contain a decimal point, even "
"if no digits follow it."
msgstr ""
"Den alternativa formen gör att resultatet alltid innehåller en decimalpunkt, "
"även om inga siffror följer efter den."

#: ../../library/stdtypes.rst:2832 ../../library/stdtypes.rst:4095
msgid ""
"The precision determines the number of digits after the decimal point and "
"defaults to 6."
msgstr ""
"Precisionen bestämmer antalet siffror efter decimaltecknet och är som "
"standard 6."

#: ../../library/stdtypes.rst:2836 ../../library/stdtypes.rst:4099
msgid ""
"The alternate form causes the result to always contain a decimal point, and "
"trailing zeroes are not removed as they would otherwise be."
msgstr ""
"Den alternativa formen gör att resultatet alltid innehåller en decimalpunkt "
"och att efterföljande nollor inte tas bort som de annars skulle ha gjort."

#: ../../library/stdtypes.rst:2839 ../../library/stdtypes.rst:4102
msgid ""
"The precision determines the number of significant digits before and after "
"the decimal point and defaults to 6."
msgstr ""
"Precisionen bestämmer antalet signifikanta siffror före och efter "
"decimaltecknet och är som standard 6."

#: ../../library/stdtypes.rst:2843 ../../library/stdtypes.rst:4106
msgid "If precision is ``N``, the output is truncated to ``N`` characters."
msgstr "Om precision är ``N`` trunkeras utdata till ``N`` tecken."

#: ../../library/stdtypes.rst:2846 ../../library/stdtypes.rst:4115
msgid "See :pep:`237`."
msgstr "Se :pep:`237`."

#: ../../library/stdtypes.rst:2848
msgid ""
"Since Python strings have an explicit length, ``%s`` conversions do not "
"assume that ``'\\0'`` is the end of the string."
msgstr ""
"Eftersom Python-strängar har en explicit längd, antar inte ``%s``-"
"konverteringar att ``'\\0'`` är slutet på strängen."

#: ../../library/stdtypes.rst:2853
msgid ""
"``%f`` conversions for numbers whose absolute value is over 1e50 are no "
"longer replaced by ``%g`` conversions."
msgstr ""
"``%f``-konverteringar för tal vars absoluta värde är över 1e50 ersätts inte "
"längre av ``%g``-konverteringar."

#: ../../library/stdtypes.rst:2864
msgid ""
"Binary Sequence Types --- :class:`bytes`, :class:`bytearray`, :class:"
"`memoryview`"
msgstr ""
"Binära sekvenstyper --- :class:`bytes`, :class:`bytearray`, :class:"
"`memoryview`"

#: ../../library/stdtypes.rst:2872
msgid ""
"The core built-in types for manipulating binary data are :class:`bytes` and :"
"class:`bytearray`. They are supported by :class:`memoryview` which uses the :"
"ref:`buffer protocol <bufferobjects>` to access the memory of other binary "
"objects without needing to make a copy."
msgstr ""
"De viktigaste inbyggda typerna för att manipulera binära data är :class:"
"`bytes` och :class:`bytearray`. De stöds av :class:`memoryview` som "
"använder :ref:`buffer protocol <bufferobjects>` för att komma åt minnet hos "
"andra binära objekt utan att behöva göra en kopia."

#: ../../library/stdtypes.rst:2877
msgid ""
"The :mod:`array` module supports efficient storage of basic data types like "
"32-bit integers and IEEE754 double-precision floating values."
msgstr ""
"Modulen :mod:`array` stöder effektiv lagring av grundläggande datatyper som "
"32-bitars heltal och flytande värden med dubbel precision enligt IEEE754."

#: ../../library/stdtypes.rst:2883
msgid "Bytes Objects"
msgstr "Bytes-objekt"

#: ../../library/stdtypes.rst:2887
msgid ""
"Bytes objects are immutable sequences of single bytes. Since many major "
"binary protocols are based on the ASCII text encoding, bytes objects offer "
"several methods that are only valid when working with ASCII compatible data "
"and are closely related to string objects in a variety of other ways."
msgstr ""
"Bytesobjekt är oföränderliga sekvenser av enstaka bytes. Eftersom många "
"större binära protokoll baseras på ASCII-textkodningen erbjuder bytesobjekt "
"flera metoder som endast är giltiga när man arbetar med ASCII-kompatibla "
"data och är nära besläktade med strängobjekt på en mängd andra sätt."

#: ../../library/stdtypes.rst:2894
msgid ""
"Firstly, the syntax for bytes literals is largely the same as that for "
"string literals, except that a ``b`` prefix is added:"
msgstr ""
"För det första är syntaxen för bytes-litteraler i stort sett densamma som "
"för sträng-litteraler, förutom att prefixet ``b`` läggs till:"

#: ../../library/stdtypes.rst:2897
msgid "Single quotes: ``b'still allows embedded \"double\" quotes'``"
msgstr ""
"Enkla citattecken: ``b'tillåter fortfarande inbäddade \"dubbla\" "
"citationstecken'```"

#: ../../library/stdtypes.rst:2898
msgid "Double quotes: ``b\"still allows embedded 'single' quotes\"``"
msgstr ""
"Dubbla citattecken: ``b\"tillåter fortfarande inbäddade 'enkla' "
"citattecken\"```"

#: ../../library/stdtypes.rst:2899
msgid ""
"Triple quoted: ``b'''3 single quotes'''``, ``b\"\"\"3 double quotes\"\"\"``"
msgstr ""
"Tredubbla citat: ``b\"''3 enkla citattecken'''``, ``b\"\"'3 dubbla "
"citattecken'\"\"``"

#: ../../library/stdtypes.rst:2901
msgid ""
"Only ASCII characters are permitted in bytes literals (regardless of the "
"declared source code encoding). Any binary values over 127 must be entered "
"into bytes literals using the appropriate escape sequence."
msgstr ""
"Endast ASCII-tecken är tillåtna i byteslitteraler (oavsett den deklarerade "
"källkodskodningen). Alla binära värden över 127 måste anges i "
"byteslitteraler med hjälp av lämplig escape-sekvens."

#: ../../library/stdtypes.rst:2905
msgid ""
"As with string literals, bytes literals may also use a ``r`` prefix to "
"disable processing of escape sequences. See :ref:`strings` for more about "
"the various forms of bytes literal, including supported escape sequences."
msgstr ""
"Precis som med stränglitteraler kan byteslitteraler också använda prefixet "
"``r`` för att inaktivera bearbetning av escape-sekvenser. Se :ref:`strings` "
"för mer information om de olika formerna av bytes-litteraler, inklusive "
"escape-sekvenser som stöds."

#: ../../library/stdtypes.rst:2909
msgid ""
"While bytes literals and representations are based on ASCII text, bytes "
"objects actually behave like immutable sequences of integers, with each "
"value in the sequence restricted such that ``0 <= x < 256`` (attempts to "
"violate this restriction will trigger :exc:`ValueError`). This is done "
"deliberately to emphasise that while many binary formats include ASCII based "
"elements and can be usefully manipulated with some text-oriented algorithms, "
"this is not generally the case for arbitrary binary data (blindly applying "
"text processing algorithms to binary data formats that are not ASCII "
"compatible will usually lead to data corruption)."
msgstr ""
"Medan bytes literaler och representationer är baserade på ASCII-text, beter "
"sig bytes objekt faktiskt som oföränderliga sekvenser av heltal, med varje "
"värde i sekvensen begränsat så att ``0 <= x < 256`` (försök att bryta mot "
"denna begränsning kommer att utlösa :exc:`ValueError`). Detta görs "
"avsiktligt för att betona att även om många binära format innehåller ASCII-"
"baserade element och kan manipuleras med vissa textorienterade algoritmer, "
"så är detta inte generellt fallet för godtyckliga binära data (att blint "
"tillämpa textbehandlingsalgoritmer på binära dataformat som inte är ASCII-"
"kompatibla leder vanligtvis till att data korrumperas)."

#: ../../library/stdtypes.rst:2919
msgid ""
"In addition to the literal forms, bytes objects can be created in a number "
"of other ways:"
msgstr ""
"Förutom de bokstavliga formerna kan bytesobjekt skapas på ett antal andra "
"sätt:"

#: ../../library/stdtypes.rst:2922
msgid "A zero-filled bytes object of a specified length: ``bytes(10)``"
msgstr "Ett nollfyllt bytesobjekt med en angiven längd: ``bytes(10)``"

#: ../../library/stdtypes.rst:2923
msgid "From an iterable of integers: ``bytes(range(20))``"
msgstr "Från en iterabel av heltal: ``bytes(range(20))``"

#: ../../library/stdtypes.rst:2924
msgid "Copying existing binary data via the buffer protocol:  ``bytes(obj)``"
msgstr ""
"Kopiering av befintliga binära data via buffertprotokollet:  ``bytes(obj)```"

#: ../../library/stdtypes.rst:2926
msgid "Also see the :ref:`bytes <func-bytes>` built-in."
msgstr "Se även den inbyggda :ref:`bytes <func-bytes>`."

#: ../../library/stdtypes.rst:2928
msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, "
"hexadecimal numbers are a commonly used format for describing binary data. "
"Accordingly, the bytes type has an additional class method to read data in "
"that format:"
msgstr ""
"Eftersom 2 hexadecimala siffror exakt motsvarar en enda byte är hexadecimala "
"tal ett vanligt format för att beskriva binära data. Bytes-typen har därför "
"en extra klassmetod för att läsa data i det formatet:"

#: ../../library/stdtypes.rst:2934
msgid ""
"This :class:`bytes` class method returns a bytes object, decoding the given "
"string object.  The string must contain two hexadecimal digits per byte, "
"with ASCII whitespace being ignored."
msgstr ""
"Denna klassmetod :class:`bytes` returnerar ett bytes-objekt som avkodar det "
"givna strängobjektet.  Strängen måste innehålla två hexadecimala siffror per "
"byte, med ASCII-teckensnitt som ignoreras."

#: ../../library/stdtypes.rst:2941
msgid ""
":meth:`bytes.fromhex` now skips all ASCII whitespace in the string, not just "
"spaces."
msgstr ""
":meth:`bytes.fromhex` hoppar nu över alla ASCII-teckensnitt i strängen, inte "
"bara mellanslag."

#: ../../library/stdtypes.rst:2945
msgid ""
":meth:`bytes.fromhex` now accepts ASCII :class:`bytes` and :term:`bytes-like "
"objects <bytes-like object>` as input."
msgstr ""
":meth:`bytes.fromhex` accepterar nu ASCII :class:`bytes` och :term:"
"`bytesliknande objekt <bytes-like object>` som indata."

#: ../../library/stdtypes.rst:2949
msgid ""
"A reverse conversion function exists to transform a bytes object into its "
"hexadecimal representation."
msgstr ""
"En omvänd konverteringsfunktion finns för att omvandla ett bytesobjekt till "
"dess hexadecimala representation."

#: ../../library/stdtypes.rst:2954 ../../library/stdtypes.rst:3043
msgid ""
"Return a string object containing two hexadecimal digits for each byte in "
"the instance."
msgstr ""
"Returnerar ett strängobjekt som innehåller två hexadecimala siffror för "
"varje byte i instansen."

#: ../../library/stdtypes.rst:2960
msgid ""
"If you want to make the hex string easier to read, you can specify a single "
"character separator *sep* parameter to include in the output. By default, "
"this separator will be included between each byte. A second optional "
"*bytes_per_sep* parameter controls the spacing. Positive values calculate "
"the separator position from the right, negative values from the left."
msgstr ""
"Om du vill göra hexsträngen mer lättläst kan du ange en parameter för en "
"teckenseparator *sep* som ska inkluderas i utdata. Som standard kommer denna "
"separator att inkluderas mellan varje byte. En andra valfri parameter "
"*bytes_per_sep* styr avståndet. Positiva värden beräknar separatorns "
"position från höger, negativa värden från vänster."

#: ../../library/stdtypes.rst:2977
msgid ""
":meth:`bytes.hex` now supports optional *sep* and *bytes_per_sep* parameters "
"to insert separators between bytes in the hex output."
msgstr ""
":meth:`bytes.hex` har nu stöd för de valfria parametrarna *sep* och "
"*bytes_per_sep* för att infoga separatorer mellan byte i hex-utdata."

#: ../../library/stdtypes.rst:2981
msgid ""
"Since bytes objects are sequences of integers (akin to a tuple), for a bytes "
"object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be a bytes "
"object of length 1.  (This contrasts with text strings, where both indexing "
"and slicing will produce a string of length 1)"
msgstr ""
"Eftersom bytesobjekt är sekvenser av heltal (liknande en tupel), för ett "
"bytesobjekt *b*, kommer ``b[0]`` att vara ett heltal, medan ``b[0:1]`` "
"kommer att vara ett bytesobjekt av längd 1. (Detta står i kontrast till "
"textsträngar, där både indexering och skivning kommer att producera en "
"sträng av längd 1)"

#: ../../library/stdtypes.rst:2986
msgid ""
"The representation of bytes objects uses the literal format (``b'...'``) "
"since it is often more useful than e.g. ``bytes([46, 46, 46])``.  You can "
"always convert a bytes object into a list of integers using ``list(b)``."
msgstr ""
"Representationen av bytes-objekt använder det bokstavliga formatet "
"(``b'...'``) eftersom det ofta är mer användbart än t.ex. ``bytes([46, 46, "
"46])``.  Du kan alltid konvertera ett bytesobjekt till en lista med heltal "
"med hjälp av ``list(b)``."

#: ../../library/stdtypes.rst:2994
msgid "Bytearray Objects"
msgstr "Bytearray-objekt"

#: ../../library/stdtypes.rst:2998
msgid ""
":class:`bytearray` objects are a mutable counterpart to :class:`bytes` "
"objects."
msgstr ""
":class:`bytearray`-objekt är en föränderlig motsvarighet till :class:`bytes`-"
"objekt."

#: ../../library/stdtypes.rst:3003
msgid ""
"There is no dedicated literal syntax for bytearray objects, instead they are "
"always created by calling the constructor:"
msgstr ""
"Det finns ingen särskild litteral syntax för bytearray-objekt, utan de "
"skapas alltid genom att anropa konstruktören:"

#: ../../library/stdtypes.rst:3006
msgid "Creating an empty instance: ``bytearray()``"
msgstr "Skapa en tom instans: ``bytearray()``"

#: ../../library/stdtypes.rst:3007
msgid "Creating a zero-filled instance with a given length: ``bytearray(10)``"
msgstr "Skapa en nollfylld instans med en given längd: ``bytearray(10)``"

#: ../../library/stdtypes.rst:3008
msgid "From an iterable of integers: ``bytearray(range(20))``"
msgstr "Från en iterabel av heltal: ``bytearray(range(20))``"

#: ../../library/stdtypes.rst:3009
msgid ""
"Copying existing binary data via the buffer protocol:  ``bytearray(b'Hi!')``"
msgstr ""
"Kopiering av befintliga binära data via buffertprotokollet:  "
"``bytearray(b'Hej!')``"

#: ../../library/stdtypes.rst:3011
msgid ""
"As bytearray objects are mutable, they support the :ref:`mutable <typesseq-"
"mutable>` sequence operations in addition to the common bytes and bytearray "
"operations described in :ref:`bytes-methods`."
msgstr ""
"Eftersom bytearray-objekt är mutabla stöder de :ref:`mutable <typesseq-"
"mutable>` sekvensoperationer utöver de vanliga bytes- och bytearray-"
"operationer som beskrivs i :ref:`bytes-methods`."

#: ../../library/stdtypes.rst:3015
msgid "Also see the :ref:`bytearray <func-bytearray>` built-in."
msgstr "Se även den inbyggda :ref:`bytearray <func-bytearray>`."

#: ../../library/stdtypes.rst:3017
msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, "
"hexadecimal numbers are a commonly used format for describing binary data. "
"Accordingly, the bytearray type has an additional class method to read data "
"in that format:"
msgstr ""
"Eftersom 2 hexadecimala siffror exakt motsvarar en enda byte är hexadecimala "
"tal ett vanligt format för att beskriva binära data. Följaktligen har "
"bytearray-typen en extra klassmetod för att läsa data i det formatet:"

#: ../../library/stdtypes.rst:3023
msgid ""
"This :class:`bytearray` class method returns bytearray object, decoding the "
"given string object.  The string must contain two hexadecimal digits per "
"byte, with ASCII whitespace being ignored."
msgstr ""
"Denna :class:`bytearray`-klassmetod returnerar bytearray-objekt, som avkodar "
"det givna strängobjektet.  Strängen måste innehålla två hexadecimala siffror "
"per byte, med ASCII-teckensnitt som ignoreras."

#: ../../library/stdtypes.rst:3030
msgid ""
":meth:`bytearray.fromhex` now skips all ASCII whitespace in the string, not "
"just spaces."
msgstr ""
":meth:`bytearray.fromhex` hoppar nu över alla ASCII-teckensnitt i strängen, "
"inte bara mellanslag."

#: ../../library/stdtypes.rst:3034
msgid ""
":meth:`bytearray.fromhex` now accepts ASCII :class:`bytes` and :term:`bytes-"
"like objects <bytes-like object>` as input."
msgstr ""
":meth:`bytearray.fromhex` accepterar nu ASCII :class:`bytes` och :term:"
"`bytesliknande objekt <bytes-like object>` som indata."

#: ../../library/stdtypes.rst:3038
msgid ""
"A reverse conversion function exists to transform a bytearray object into "
"its hexadecimal representation."
msgstr ""
"En omvänd konverteringsfunktion finns för att omvandla ett bytearray-objekt "
"till dess hexadecimala representation."

#: ../../library/stdtypes.rst:3051
msgid ""
"Similar to :meth:`bytes.hex`, :meth:`bytearray.hex` now supports optional "
"*sep* and *bytes_per_sep* parameters to insert separators between bytes in "
"the hex output."
msgstr ""
"I likhet med :meth:`bytes.hex` har :meth:`bytearray.hex` nu stöd för de "
"valfria parametrarna *sep* och *bytes_per_sep* för att infoga separatorer "
"mellan byte i hex-utdata."

#: ../../library/stdtypes.rst:3058
msgid ""
"Resize the :class:`bytearray` to contain *size* bytes. *size* must be "
"greater than or equal to 0."
msgstr ""
"Ändra storlek på :class:`bytearray` så att den innehåller *size* bytes. "
"*size* måste vara större än eller lika med 0."

#: ../../library/stdtypes.rst:3061
msgid ""
"If the :class:`bytearray` needs to shrink, bytes beyond *size* are truncated."
msgstr ""
"Om :class:`bytearray` behöver krympas, trunkeras byte som är större än "
"*size*."

#: ../../library/stdtypes.rst:3063
msgid ""
"If the :class:`bytearray` needs to grow, all new bytes, those beyond *size*, "
"will be set to null bytes."
msgstr ""
"Om :class:`bytearray` behöver växa kommer alla nya bytes, de som överstiger "
"*size*, att sättas till null bytes."

#: ../../library/stdtypes.rst:3067
msgid "This is equivalent to:"
msgstr "Detta är likvärdigt med:"

#: ../../library/stdtypes.rst:3075
msgid "Examples:"
msgstr "Exempel:"

#: ../../library/stdtypes.rst:3088
msgid ""
"Since bytearray objects are sequences of integers (akin to a list), for a "
"bytearray object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be "
"a bytearray object of length 1.  (This contrasts with text strings, where "
"both indexing and slicing will produce a string of length 1)"
msgstr ""
"Eftersom bytearray-objekt är sekvenser av heltal (i likhet med en lista), "
"kommer ``b[0]`` för ett bytearray-objekt *b* att vara ett heltal, medan "
"``b[0:1]`` kommer att vara ett bytearray-objekt med längden 1. (Detta står i "
"kontrast till textsträngar, där både indexering och skivning kommer att "
"producera en sträng med längden 1)"

#: ../../library/stdtypes.rst:3093
msgid ""
"The representation of bytearray objects uses the bytes literal format "
"(``bytearray(b'...')``) since it is often more useful than e.g. "
"``bytearray([46, 46, 46])``.  You can always convert a bytearray object into "
"a list of integers using ``list(b)``."
msgstr ""
"Representationen av bytearray-objekt använder bytes literal-formatet "
"(``bytearray(b'...')``) eftersom det ofta är mer användbart än t.ex. "
"``bytearray([46, 46, 46])``.  Du kan alltid konvertera ett bytearray-objekt "
"till en lista med heltal med hjälp av ``list(b)``."

#: ../../library/stdtypes.rst:3102
msgid "Bytes and Bytearray Operations"
msgstr "Bytes- och bytearrayoperationer"

#: ../../library/stdtypes.rst:3107
msgid ""
"Both bytes and bytearray objects support the :ref:`common <typesseq-common>` "
"sequence operations. They interoperate not just with operands of the same "
"type, but with any :term:`bytes-like object`. Due to this flexibility, they "
"can be freely mixed in operations without causing errors. However, the "
"return type of the result may depend on the order of operands."
msgstr ""
"Både bytes och bytearray-objekt stöder :ref:``common <typesseq-common>` "
"sekvensoperationer. De fungerar inte bara med operander av samma typ, utan "
"med alla :term:`bytesliknande objekt`. På grund av denna flexibilitet kan de "
"blandas fritt i operationer utan att orsaka fel. Returtypen för resultatet "
"kan dock bero på ordningen på operanderna."

#: ../../library/stdtypes.rst:3115
msgid ""
"The methods on bytes and bytearray objects don't accept strings as their "
"arguments, just as the methods on strings don't accept bytes as their "
"arguments.  For example, you have to write::"
msgstr ""
"Metoderna för bytes och bytearray-objekt accepterar inte strängar som "
"argument, precis som metoderna för strängar inte accepterar bytes som "
"argument.  Till exempel måste du skriva::"

#: ../../library/stdtypes.rst:3119
msgid ""
"a = \"abc\"\n"
"b = a.replace(\"a\", \"f\")"
msgstr ""
"a = \"abc\"\n"
"b = a.replace(\"a\", \"f\")"

#: ../../library/stdtypes.rst:3122
msgid "and::"
msgstr "och::"

#: ../../library/stdtypes.rst:3124
msgid ""
"a = b\"abc\"\n"
"b = a.replace(b\"a\", b\"f\")"
msgstr ""
"a = b\"abc\"\n"
"b = a.replace(b\"a\", b\"f\")"

#: ../../library/stdtypes.rst:3127
msgid ""
"Some bytes and bytearray operations assume the use of ASCII compatible "
"binary formats, and hence should be avoided when working with arbitrary "
"binary data. These restrictions are covered below."
msgstr ""
"Vissa bytes- och bytearrayoperationer förutsätter användning av ASCII-"
"kompatibla binära format och bör därför undvikas när man arbetar med "
"godtyckliga binära data. Dessa begränsningar beskrivs nedan."

#: ../../library/stdtypes.rst:3132
msgid ""
"Using these ASCII based operations to manipulate binary data that is not "
"stored in an ASCII based format may lead to data corruption."
msgstr ""
"Om dessa ASCII-baserade operationer används för att manipulera binära data "
"som inte lagras i ett ASCII-baserat format kan det leda till att data "
"korrumperas."

#: ../../library/stdtypes.rst:3135
msgid ""
"The following methods on bytes and bytearray objects can be used with "
"arbitrary binary data."
msgstr ""
"Följande metoder för bytes och bytearray-objekt kan användas med godtyckliga "
"binära data."

#: ../../library/stdtypes.rst:3141
msgid ""
"Return the number of non-overlapping occurrences of subsequence *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""
"Returnerar antalet icke-överlappande förekomster av undersekvensen *sub* i "
"intervallet [*start*, *slut*].  De valfria argumenten *start* och *slut* "
"tolkas som i slice-notation."

#: ../../library/stdtypes.rst:3145 ../../library/stdtypes.rst:3250
#: ../../library/stdtypes.rst:3272 ../../library/stdtypes.rst:3338
#: ../../library/stdtypes.rst:3351
msgid ""
"The subsequence to search for may be any :term:`bytes-like object` or an "
"integer in the range 0 to 255."
msgstr ""
"Den undersekvens som ska sökas kan vara valfri :term:`bytesliknande objekt` "
"eller ett heltal i intervallet 0 till 255."

#: ../../library/stdtypes.rst:3148
msgid ""
"If *sub* is empty, returns the number of empty slices between characters "
"which is the length of the bytes object plus one."
msgstr ""
"Om *sub* är tomt, returneras antalet tomma delar mellan tecken, vilket är "
"bytesobjektets längd plus ett."

#: ../../library/stdtypes.rst:3151 ../../library/stdtypes.rst:3262
#: ../../library/stdtypes.rst:3275 ../../library/stdtypes.rst:3341
#: ../../library/stdtypes.rst:3354
msgid "Also accept an integer in the range 0 to 255 as the subsequence."
msgstr "Acceptera också ett heltal i intervallet 0 till 255 som undersekvens."

#: ../../library/stdtypes.rst:3158
msgid ""
"If the binary data starts with the *prefix* string, return "
"``bytes[len(prefix):]``. Otherwise, return a copy of the original binary "
"data::"
msgstr ""
"Om de binära data börjar med strängen *prefix*, returneras "
"``bytes[len(prefix):]``. I annat fall returneras en kopia av den "
"ursprungliga binära datan::"

#: ../../library/stdtypes.rst:3162
msgid ""
">>> b'TestHook'.removeprefix(b'Test')\n"
"b'Hook'\n"
">>> b'BaseTestCase'.removeprefix(b'Test')\n"
"b'BaseTestCase'"
msgstr ""
">>> b'TestHook'.removeprefix(b'Test')\n"
"b'Hook'\n"
">>> b'BaseTestCase'.removeprefix(b'Test')\n"
"b'BaseTestCase'"

#: ../../library/stdtypes.rst:3167
msgid "The *prefix* may be any :term:`bytes-like object`."
msgstr "*prefixet* kan vara valfri :term:`bytesliknande objekt`."

#: ../../library/stdtypes.rst:3171 ../../library/stdtypes.rst:3193
#: ../../library/stdtypes.rst:3326 ../../library/stdtypes.rst:3419
#: ../../library/stdtypes.rst:3433 ../../library/stdtypes.rst:3464
#: ../../library/stdtypes.rst:3478 ../../library/stdtypes.rst:3520
#: ../../library/stdtypes.rst:3591 ../../library/stdtypes.rst:3609
#: ../../library/stdtypes.rst:3637 ../../library/stdtypes.rst:3776
#: ../../library/stdtypes.rst:3831 ../../library/stdtypes.rst:3874
#: ../../library/stdtypes.rst:3895 ../../library/stdtypes.rst:3917
#: ../../library/stdtypes.rst:4119
msgid ""
"The bytearray version of this method does *not* operate in place - it always "
"produces a new object, even if no changes were made."
msgstr ""
"Bytearray-versionen av den här metoden fungerar *inte* på plats - den "
"producerar alltid ett nytt objekt, även om inga ändringar har gjorts."

#: ../../library/stdtypes.rst:3180
msgid ""
"If the binary data ends with the *suffix* string and that *suffix* is not "
"empty, return ``bytes[:-len(suffix)]``.  Otherwise, return a copy of the "
"original binary data::"
msgstr ""
"Om de binära data slutar med strängen *suffix* och *suffix* inte är tomt, "
"returneras ``bytes[:-len(suffix)]``.  I annat fall returneras en kopia av de "
"ursprungliga binära data::"

#: ../../library/stdtypes.rst:3184
msgid ""
">>> b'MiscTests'.removesuffix(b'Tests')\n"
"b'Misc'\n"
">>> b'TmpDirMixin'.removesuffix(b'Tests')\n"
"b'TmpDirMixin'"
msgstr ""
">>> b'MiscTests'.removesuffix(b'Tests')\n"
"b'Misc'\n"
">>> b'TmpDirMixin'.removesuffix(b'Tests')\n"
"b'TmpDirMixin'"

#: ../../library/stdtypes.rst:3189
msgid "The *suffix* may be any :term:`bytes-like object`."
msgstr "*Suffix* kan vara valfri :term:`bytesliknande objekt`."

#: ../../library/stdtypes.rst:3202
msgid "Return the bytes decoded to a :class:`str`."
msgstr "Returnera byte som avkodats till en :class:`str`."

#: ../../library/stdtypes.rst:3207
msgid ""
"*errors* controls how decoding errors are handled. If ``'strict'`` (the "
"default), a :exc:`UnicodeError` exception is raised. Other possible values "
"are ``'ignore'``, ``'replace'``, and any other name registered via :func:"
"`codecs.register_error`. See :ref:`error-handlers` for details."
msgstr ""
"*errors* styr hur avkodningsfel ska hanteras. Om ``'strict'`` (standard), "
"kommer ett :exc:`UnicodeError` undantag att skapas. Andra möjliga värden är "
"``'ignore'``, ``'replace'``, och alla andra namn som registreras via :func:"
"`codecs.register_error`. Se :ref:`error-handlers` för detaljer."

#: ../../library/stdtypes.rst:3213
msgid ""
"For performance reasons, the value of *errors* is not checked for validity "
"unless a decoding error actually occurs, :ref:`devmode` is enabled or a :ref:"
"`debug build <debug-build>` is used."
msgstr ""
"Av prestandaskäl kontrolleras inte värdet på *errors* om inte ett "
"avkodningsfel faktiskt inträffar, :ref:`devmode` är aktiverat eller en :ref:"
"`debug build <debug-build>` används."

#: ../../library/stdtypes.rst:3219
msgid ""
"Passing the *encoding* argument to :class:`str` allows decoding any :term:"
"`bytes-like object` directly, without needing to make a temporary :class:`!"
"bytes` or :class:`!bytearray` object."
msgstr ""
"Genom att skicka argumentet *encoding* till :class:`str` kan man avkoda "
"alla :term:`bytes-liknande objekt` direkt, utan att behöva skapa ett "
"tillfälligt :class:`!bytes`- eller :class:`!bytearray`-objekt."

#: ../../library/stdtypes.rst:3234
msgid ""
"Return ``True`` if the binary data ends with the specified *suffix*, "
"otherwise return ``False``.  *suffix* can also be a tuple of suffixes to "
"look for.  With optional *start*, test beginning at that position.  With "
"optional *end*, stop comparing at that position."
msgstr ""
"Returnerar ``True`` om binärdata slutar med det angivna *suffixet*, annars "
"returneras ``False``.  *suffix* kan också vara en tupel av suffix att leta "
"efter.  Med valfri *start* börjar testet vid den positionen.  Med valfri "
"*end*, sluta jämföra vid den positionen."

#: ../../library/stdtypes.rst:3239
msgid "The suffix(es) to search for may be any :term:`bytes-like object`."
msgstr ""
"Suffixet (suffixen) som skall sökas efter kan vara valfri :term:"
"`bytesliknande objekt`."

#: ../../library/stdtypes.rst:3245
msgid ""
"Return the lowest index in the data where the subsequence *sub* is found, "
"such that *sub* is contained in the slice ``s[start:end]``.  Optional "
"arguments *start* and *end* are interpreted as in slice notation.  Return "
"``-1`` if *sub* is not found."
msgstr ""
"Returnerar det lägsta indexet i data där undersekvensen *sub* finns, så att "
"*sub* finns i skivan ``s[start:end]``.  De valfria argumenten *start* och "
"*end* tolkas som i slice-notation.  Returnerar ``-1`` om *sub* inte hittas."

#: ../../library/stdtypes.rst:3255
msgid ""
"The :meth:`~bytes.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the :"
"keyword:`in` operator::"
msgstr ""
"Metoden :meth:`~bytes.find` bör endast användas om du behöver veta "
"positionen för *sub*.  Om du vill kontrollera om *sub* är en delsträng eller "
"inte använder du operatorn :keyword:`in`::"

#: ../../library/stdtypes.rst:3259
msgid ""
">>> b'Py' in b'Python'\n"
"True"
msgstr ""
">>> b'Py' i b'Python'\n"
"Sant"

#: ../../library/stdtypes.rst:3269
msgid ""
"Like :meth:`~bytes.find`, but raise :exc:`ValueError` when the subsequence "
"is not found."
msgstr ""
"Som :meth:`~bytes.find`, men ger upphov till :exc:`ValueError` när "
"undersekvensen inte hittas."

#: ../../library/stdtypes.rst:3282
msgid ""
"Return a bytes or bytearray object which is the concatenation of the binary "
"data sequences in *iterable*.  A :exc:`TypeError` will be raised if there "
"are any values in *iterable* that are not :term:`bytes-like objects <bytes-"
"like object>`, including :class:`str` objects.  The separator between "
"elements is the contents of the bytes or bytearray object providing this "
"method."
msgstr ""
"Returnerar ett bytes- eller bytearray-objekt som är sammankopplingen av de "
"binära datasekvenserna i *iterable*.  Ett :exc:`TypeError` kommer att tas "
"upp om det finns några värden i *iterable* som inte är :term:`bytesliknande "
"objekt <bytes-like object>`, inklusive :class:`str`-objekt.  Separatorn "
"mellan elementen är innehållet i bytes- eller bytearray-objektet som "
"tillhandahåller denna metod."

#: ../../library/stdtypes.rst:3293
msgid ""
"This static method returns a translation table usable for :meth:`bytes."
"translate` that will map each character in *from* into the character at the "
"same position in *to*; *from* and *to* must both be :term:`bytes-like "
"objects <bytes-like object>` and have the same length."
msgstr ""
"Denna statiska metod returnerar en översättningstabell användbar för :meth:"
"`bytes.translate` som mappar varje tecken i *from* till tecknet på samma "
"position i *to*; *from* och *to* måste båda vara :term:`bytes-like objects "
"<bytes-like object>` och ha samma längd."

#: ../../library/stdtypes.rst:3304
msgid ""
"Split the sequence at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself or its "
"bytearray copy, and the part after the separator. If the separator is not "
"found, return a 3-tuple containing a copy of the original sequence, followed "
"by two empty bytes or bytearray objects."
msgstr ""
"Dela sekvensen vid den första förekomsten av *sep* och returnera en 3-tupel "
"som innehåller delen före separatorn, själva separatorn eller dess bytearray-"
"kopia och delen efter separatorn. Om separatorn inte hittas returneras en 3-"
"tupel som innehåller en kopia av den ursprungliga sekvensen, följt av två "
"tomma bytes eller bytearray-objekt."

#: ../../library/stdtypes.rst:3311 ../../library/stdtypes.rst:3368
msgid "The separator to search for may be any :term:`bytes-like object`."
msgstr ""
"Separatorn att söka efter kan vara valfri :term:`bytesliknande objekt`."

#: ../../library/stdtypes.rst:3317
msgid ""
"Return a copy of the sequence with all occurrences of subsequence *old* "
"replaced by *new*.  If the optional argument *count* is given, only the "
"first *count* occurrences are replaced."
msgstr ""
"Returnerar en kopia av sekvensen med alla förekomster av undersekvensen "
"*old* ersatta av *new*.  Om det valfria argumentet *count* anges, ersätts "
"endast de första *count* förekomsterna."

#: ../../library/stdtypes.rst:3321
msgid ""
"The subsequence to search for and its replacement may be any :term:`bytes-"
"like object`."
msgstr ""
"Den undersekvens som ska sökas och dess ersättning kan vara valfri :term:"
"`bytesliknande objekt`."

#: ../../library/stdtypes.rst:3333
msgid ""
"Return the highest index in the sequence where the subsequence *sub* is "
"found, such that *sub* is contained within ``s[start:end]``.  Optional "
"arguments *start* and *end* are interpreted as in slice notation. Return "
"``-1`` on failure."
msgstr ""
"Returnerar det högsta indexet i sekvensen där undersekvensen *sub* finns, så "
"att *sub* ingår i ``s[start:end]``.  De valfria argumenten *start* och *end* "
"tolkas som i slice-notation. Returnerar ``-1`` om den misslyckas."

#: ../../library/stdtypes.rst:3348
msgid ""
"Like :meth:`~bytes.rfind` but raises :exc:`ValueError` when the subsequence "
"*sub* is not found."
msgstr ""
"Som :meth:`~bytes.rfind` men ger upphov till :exc:`ValueError` när "
"undersekvensen *sub* inte hittas."

#: ../../library/stdtypes.rst:3361
msgid ""
"Split the sequence at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself or its "
"bytearray copy, and the part after the separator. If the separator is not "
"found, return a 3-tuple containing two empty bytes or bytearray objects, "
"followed by a copy of the original sequence."
msgstr ""
"Dela sekvensen vid den sista förekomsten av *sep*, och returnera en 3-tupel "
"som innehåller delen före separatorn, själva separatorn eller dess bytearray-"
"kopia, och delen efter separatorn. Om separatorn inte hittas returneras en 3-"
"tupel som innehåller två tomma bytes eller bytearray-objekt, följt av en "
"kopia av den ursprungliga sekvensen."

#: ../../library/stdtypes.rst:3374
msgid ""
"Return ``True`` if the binary data starts with the specified *prefix*, "
"otherwise return ``False``.  *prefix* can also be a tuple of prefixes to "
"look for.  With optional *start*, test beginning at that position.  With "
"optional *end*, stop comparing at that position."
msgstr ""
"Returnerar ``True`` om de binära data börjar med det angivna *prefixet*, "
"annars returneras ``False``.  *prefix* kan också vara en tupel av prefix att "
"leta efter.  Med valfri *start* börjar testet vid den positionen.  Med "
"valfri *end*, sluta jämföra vid den positionen."

#: ../../library/stdtypes.rst:3379
msgid "The prefix(es) to search for may be any :term:`bytes-like object`."
msgstr ""
"Prefixet/prefixen att söka efter kan vara valfri :term:`bytesliknande "
"objekt`."

#: ../../library/stdtypes.rst:3385
msgid ""
"Return a copy of the bytes or bytearray object where all bytes occurring in "
"the optional argument *delete* are removed, and the remaining bytes have "
"been mapped through the given translation table, which must be a bytes "
"object of length 256."
msgstr ""
"Returnerar en kopia av bytes- eller bytearray-objektet där alla bytes som "
"förekommer i det valfria argumentet *delete* har tagits bort, och de "
"återstående bytesen har mappats genom den angivna översättningstabellen, som "
"måste vara ett bytes-objekt med längden 256."

#: ../../library/stdtypes.rst:3390
msgid ""
"You can use the :func:`bytes.maketrans` method to create a translation table."
msgstr ""
"Du kan använda metoden :func:`bytes.maketrans` för att skapa en "
"översättningstabell."

#: ../../library/stdtypes.rst:3393
msgid ""
"Set the *table* argument to ``None`` for translations that only delete "
"characters::"
msgstr ""
"Sätt argumentet *table* till ``None`` för översättningar som bara tar bort "
"tecken::"

#: ../../library/stdtypes.rst:3396
msgid ""
">>> b'read this short text'.translate(None, b'aeiou')\n"
"b'rd ths shrt txt'"
msgstr ""
">>> b'läs denna korta text'.translate(None, b'aeiou')\n"
"b'rd ths shrt txt'"

#: ../../library/stdtypes.rst:3399
msgid "*delete* is now supported as a keyword argument."
msgstr "*delete* stöds nu som ett nyckelordsargument."

#: ../../library/stdtypes.rst:3403
msgid ""
"The following methods on bytes and bytearray objects have default behaviours "
"that assume the use of ASCII compatible binary formats, but can still be "
"used with arbitrary binary data by passing appropriate arguments. Note that "
"all of the bytearray methods in this section do *not* operate in place, and "
"instead produce new objects."
msgstr ""
"Följande metoder för bytes och bytearray-objekt har standardbeteenden som "
"förutsätter användning av ASCII-kompatibla binära format, men kan ändå "
"användas med godtyckliga binära data genom att lämpliga argument anges. "
"Observera att alla bytearray-metoder i det här avsnittet *inte* fungerar på "
"plats, utan istället producerar nya objekt."

#: ../../library/stdtypes.rst:3412
msgid ""
"Return a copy of the object centered in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"Returnerar en kopia av objektet centrerat i en sekvens med längden *width*. "
"Utfyllnad görs med hjälp av den angivna *fillbyte* (standard är ett ASCII-"
"utrymme). För :class:`bytes`-objekt returneras originalsekvensen om *width* "
"är mindre än eller lika med ``len(s)``."

#: ../../library/stdtypes.rst:3426
msgid ""
"Return a copy of the object left justified in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"Returnerar en kopia av objektet vänsterjusterat i en sekvens med längden "
"*bredd*. Utfyllnad görs med hjälp av den angivna *fillbyte* (standard är ett "
"ASCII-utrymme). För :class:`bytes`-objekt returneras originalsekvensen om "
"*width* är mindre än eller lika med ``len(s)``."

#: ../../library/stdtypes.rst:3440
msgid ""
"Return a copy of the sequence with specified leading bytes removed.  The "
"*chars* argument is a binary sequence specifying the set of byte values to "
"be removed - the name refers to the fact this method is usually used with "
"ASCII characters.  If omitted or ``None``, the *chars* argument defaults to "
"removing ASCII whitespace.  The *chars* argument is not a prefix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"Returnerar en kopia av sekvensen med angivna inledande byte borttagna.  "
"Argumentet *chars* är en binär sekvens som anger den uppsättning bytevärden "
"som ska tas bort - namnet hänvisar till att denna metod vanligtvis används "
"med ASCII-tecken.  Om *chars*-argumentet utelämnas eller ``None``, tas ASCII-"
"teckenspråk bort som standard.  Argumentet *chars* är inte ett prefix, utan "
"alla kombinationer av dess värden tas bort::"

#: ../../library/stdtypes.rst:3447
msgid ""
">>> b'   spacious   '.lstrip()\n"
"b'spacious   '\n"
">>> b'www.example.com'.lstrip(b'cmowz.')\n"
"b'example.com'"
msgstr ""
">>> b' rymlig '.lstrip()\n"
"b'rymlig '\n"
">>> b'www.example.com'.lstrip(b'cmowz.')\n"
"b'exempel.com'"

#: ../../library/stdtypes.rst:3452
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`. See :meth:`~bytes.removeprefix` for a method that will remove a "
"single prefix string rather than all of a set of characters.  For example::"
msgstr ""
"Den binära sekvensen av bytevärden som ska tas bort kan vara valfri :term:"
"`bytesliknande objekt`. Se :meth:`~bytes.removeprefix` för en metod som tar "
"bort en enda prefixsträng i stället för alla tecken i en uppsättning.  Till "
"exempel::"

#: ../../library/stdtypes.rst:3457
msgid ""
">>> b'Arthur: three!'.lstrip(b'Arthur: ')\n"
"b'ee!'\n"
">>> b'Arthur: three!'.removeprefix(b'Arthur: ')\n"
"b'three!'"
msgstr ""
">>> b'Arthur: tre!'.lstrip(b'Arthur: ')\n"
"b'ee!'\n"
">>> b'Arthur: tre!'.removeprefix(b'Arthur: ')\n"
"b'tre!'"

#: ../../library/stdtypes.rst:3471
msgid ""
"Return a copy of the object right justified in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"Returnerar en kopia av objektet högerställd i en sekvens med längd *bredd*. "
"Utfyllnad görs med hjälp av den angivna *fillbyte* (standard är ett ASCII-"
"utrymme). För :class:`bytes`-objekt returneras originalsekvensen om *width* "
"är mindre än eller lika med ``len(s)``."

#: ../../library/stdtypes.rst:3485
msgid ""
"Split the binary sequence into subsequences of the same type, using *sep* as "
"the delimiter string. If *maxsplit* is given, at most *maxsplit* splits are "
"done, the *rightmost* ones.  If *sep* is not specified or ``None``, any "
"subsequence consisting solely of ASCII whitespace is a separator. Except for "
"splitting from the right, :meth:`rsplit` behaves like :meth:`split` which is "
"described in detail below."
msgstr ""
"Dela upp den binära sekvensen i undersekvenser av samma typ, med *sep* som "
"avgränsningssträng. Om *maxsplit* anges görs högst *maxsplit* uppdelningar, "
"de *högst till höger*.  Om *sep* inte specificeras eller om ``None``, är "
"varje delsekvens som enbart består av ASCII-teckensnitt en separator. "
"Förutom att dela upp från höger, beter sig :meth:`rsplit` som :meth:`split` "
"som beskrivs i detalj nedan."

#: ../../library/stdtypes.rst:3496
msgid ""
"Return a copy of the sequence with specified trailing bytes removed.  The "
"*chars* argument is a binary sequence specifying the set of byte values to "
"be removed - the name refers to the fact this method is usually used with "
"ASCII characters.  If omitted or ``None``, the *chars* argument defaults to "
"removing ASCII whitespace.  The *chars* argument is not a suffix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"Returnerar en kopia av sekvensen med angivna efterföljande byte borttagna.  "
"Argumentet *chars* är en binär sekvens som anger den uppsättning bytevärden "
"som ska tas bort - namnet hänvisar till att denna metod vanligtvis används "
"med ASCII-tecken.  Om argumentet *chars* utelämnas eller ``None``, tas ASCII-"
"teckensnitt bort som standard.  Argumentet *chars* är inte ett suffix, utan "
"alla kombinationer av dess värden tas bort::"

#: ../../library/stdtypes.rst:3503
msgid ""
">>> b'   spacious   '.rstrip()\n"
"b'   spacious'\n"
">>> b'mississippi'.rstrip(b'ipz')\n"
"b'mississ'"
msgstr ""
">>> b' rymlig '.rstrip()\n"
"b' rymlig'\n"
">>> b'mississippi'.rstrip(b'ipz')\n"
"b'mississ'"

#: ../../library/stdtypes.rst:3508
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`. See :meth:`~bytes.removesuffix` for a method that will remove a "
"single suffix string rather than all of a set of characters.  For example::"
msgstr ""
"Den binära sekvensen av bytevärden som ska tas bort kan vara valfritt :term:"
"`bytesliknande objekt`. Se :meth:`~bytes.removesuffix` för en metod som tar "
"bort en enda suffixsträng i stället för alla tecken i en uppsättning.  Till "
"exempel::"

#: ../../library/stdtypes.rst:3513
msgid ""
">>> b'Monty Python'.rstrip(b' Python')\n"
"b'M'\n"
">>> b'Monty Python'.removesuffix(b' Python')\n"
"b'Monty'"
msgstr ""
">>> b'Monty Python'.rstrip(b' Python')\n"
"b'M'\n"
">>> b'Monty Python'.removesuffix(b' Python')\n"
"b'Monty'"

#: ../../library/stdtypes.rst:3527
msgid ""
"Split the binary sequence into subsequences of the same type, using *sep* as "
"the delimiter string. If *maxsplit* is given and non-negative, at most "
"*maxsplit* splits are done (thus, the list will have at most ``maxsplit+1`` "
"elements).  If *maxsplit* is not specified or is ``-1``, then there is no "
"limit on the number of splits (all possible splits are made)."
msgstr ""
"Dela upp den binära sekvensen i undersekvenser av samma typ, med *sep* som "
"avgränsningssträng. Om *maxsplit* anges och är icke-negativ görs högst "
"*maxsplit* uppdelningar (listan kommer alltså att ha högst ``maxsplit+1`` "
"element).  Om *maxsplit* inte anges eller är ``-1`` finns det ingen "
"begränsning av antalet uppdelningar (alla möjliga uppdelningar görs)."

#: ../../library/stdtypes.rst:3533
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty subsequences (for example, ``b'1,,2'.split(b',')`` "
"returns ``[b'1', b'', b'2']``).  The *sep* argument may consist of a "
"multibyte sequence as a single delimiter. Splitting an empty sequence with a "
"specified separator returns ``[b'']`` or ``[bytearray(b'')]`` depending on "
"the type of object being split.  The *sep* argument may be any :term:`bytes-"
"like object`."
msgstr ""
"Om *sep* anges grupperas inte på varandra följande avgränsare och de anses "
"avgränsa tomma undersekvenser (t.ex. ``b'1,,2'.split(b','')`` ger ``[b'1', "
"b'', b'2']``).  Argumentet *sep* kan bestå av en multibyte-sekvens som en "
"enda avgränsare. Om en tom sekvens delas med en angiven separator returneras "
"``[b'']`` eller ``[bytearray(b'')]`` beroende på vilken typ av objekt som "
"delas.  Argumentet *sep* kan vara valfri :term:`bytesliknande objekt`."

#: ../../library/stdtypes.rst:3543
msgid ""
">>> b'1,2,3'.split(b',')\n"
"[b'1', b'2', b'3']\n"
">>> b'1,2,3'.split(b',', maxsplit=1)\n"
"[b'1', b'2,3']\n"
">>> b'1,2,,3,'.split(b',')\n"
"[b'1', b'2', b'', b'3', b'']\n"
">>> b'1<>2<>3<4'.split(b'<>')\n"
"[b'1', b'2', b'3<4']"
msgstr ""
">>> b'1,2,3'.split(b',')\n"
"[b'1', b'2', b'3']\n"
">>> b'1,2,3'.split(b',', maxsplit=1)\n"
"[b'1', b'2,3']\n"
">>> b'1,2,,3,'.split(b',')\n"
"[b'1', b'2', b'', b'3', b'']\n"
">>> b'1<>2<>3<4'.split(b'<>')\n"
"[b'1', b'2', b'3<4']"

#: ../../library/stdtypes.rst:3552
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is "
"applied: runs of consecutive ASCII whitespace are regarded as a single "
"separator, and the result will contain no empty strings at the start or end "
"if the sequence has leading or trailing whitespace.  Consequently, splitting "
"an empty sequence or a sequence consisting solely of ASCII whitespace "
"without a specified separator returns ``[]``."
msgstr ""
"Om *sep* inte anges eller är ``None``, används en annan delningsalgoritm: "
"sekvenser av på varandra följande ASCII-teckensnitt betraktas som en enda "
"separator, och resultatet innehåller inga tomma strängar i början eller "
"slutet om sekvensen har inledande eller avslutande teckensnitt.  "
"Följaktligen returneras ``[]`` när en tom sekvens eller en sekvens som "
"endast består av ASCII-teckensnitt utan en angiven separator delas."

#: ../../library/stdtypes.rst:3562
msgid ""
">>> b'1 2 3'.split()\n"
"[b'1', b'2', b'3']\n"
">>> b'1 2 3'.split(maxsplit=1)\n"
"[b'1', b'2 3']\n"
">>> b'   1   2   3   '.split()\n"
"[b'1', b'2', b'3']"
msgstr ""
">>> b'1 2 3'.split()\n"
"[b'1', b'2', b'3']\n"
">>> b'1 2 3'.split(maxsplit=1)\n"
"[b'1', b'2 3']\n"
">>> b' 1 2 3 '.split()\n"
"[b'1', b'2', b'3'] >>> b' 1 2 3 '.split()"

#: ../../library/stdtypes.rst:3573
msgid ""
"Return a copy of the sequence with specified leading and trailing bytes "
"removed. The *chars* argument is a binary sequence specifying the set of "
"byte values to be removed - the name refers to the fact this method is "
"usually used with ASCII characters.  If omitted or ``None``, the *chars* "
"argument defaults to removing ASCII whitespace. The *chars* argument is not "
"a prefix or suffix; rather, all combinations of its values are stripped::"
msgstr ""
"Returnerar en kopia av sekvensen med angivna inledande och avslutande byte "
"borttagna. Argumentet *chars* är en binär sekvens som anger den uppsättning "
"bytevärden som ska tas bort - namnet hänvisar till att denna metod "
"vanligtvis används med ASCII-tecken.  Om argumentet *chars* utelämnas eller "
"``None``, tas ASCII-teckensnitt bort som standard. Argumentet *chars* är "
"inte ett prefix eller suffix, utan alla kombinationer av dess värden tas "
"bort::"

#: ../../library/stdtypes.rst:3581
msgid ""
">>> b'   spacious   '.strip()\n"
"b'spacious'\n"
">>> b'www.example.com'.strip(b'cmowz.')\n"
"b'example'"
msgstr ""
">>> b' rymlig '.strip()\n"
"b'rymlig'\n"
">>> b'www.example.com'.strip(b'cmowz.')\n"
"b'exempel'"

#: ../../library/stdtypes.rst:3586
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`."
msgstr ""
"Den binära sekvensen av bytevärden som skall tas bort kan vara valfri :term:"
"`bytesliknande objekt`."

#: ../../library/stdtypes.rst:3595
msgid ""
"The following methods on bytes and bytearray objects assume the use of ASCII "
"compatible binary formats and should not be applied to arbitrary binary "
"data. Note that all of the bytearray methods in this section do *not* "
"operate in place, and instead produce new objects."
msgstr ""
"Följande metoder för bytes och bytearray-objekt förutsätter användning av "
"ASCII-kompatibla binära format och bör inte tillämpas på godtyckliga binära "
"data. Observera att alla bytearray-metoder i detta avsnitt *inte* arbetar på "
"plats, utan istället producerar nya objekt."

#: ../../library/stdtypes.rst:3603
msgid ""
"Return a copy of the sequence with each byte interpreted as an ASCII "
"character, and the first byte capitalized and the rest lowercased. Non-ASCII "
"byte values are passed through unchanged."
msgstr ""
"Returnerar en kopia av sekvensen där varje byte tolkas som ett ASCII-tecken "
"och den första byten skrivs med stor bokstav och resten med liten bokstav. "
"Bytevärden som inte är ASCII-värden skickas oförändrade."

#: ../../library/stdtypes.rst:3616
msgid ""
"Return a copy of the sequence where all ASCII tab characters are replaced by "
"one or more ASCII spaces, depending on the current column and the given tab "
"size.  Tab positions occur every *tabsize* bytes (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the sequence, the "
"current column is set to zero and the sequence is examined byte by byte.  If "
"the byte is an ASCII tab character (``b'\\t'``), one or more space "
"characters are inserted in the result until the current column is equal to "
"the next tab position. (The tab character itself is not copied.)  If the "
"current byte is an ASCII newline (``b'\\n'``) or carriage return "
"(``b'\\r'``), it is copied and the current column is reset to zero.  Any "
"other byte value is copied unchanged and the current column is incremented "
"by one regardless of how the byte value is represented when printed::"
msgstr ""
"Returnerar en kopia av sekvensen där alla ASCII tabbtecken ersätts av ett "
"eller flera ASCII-rymder, beroende på aktuell kolumn och angiven "
"tabbstorlek.  Tabbpositioner förekommer varje *tabsize* byte (standard är 8, "
"vilket ger tabbpositioner i kolumnerna 0, 8, 16 och så vidare).  För att "
"expandera sekvensen sätts den aktuella kolumnen till noll och sekvensen "
"undersöks byte för byte.  Om byten är ett ASCII-tab-tecken (``b'\\t'``) "
"infogas ett eller flera mellanslagstecken i resultatet tills den aktuella "
"kolumnen är lika med nästa tab-position. (Tabbtecknet i sig kopieras inte.) "
"Om den aktuella byten är en ASCII newline (``b'\\n'``) eller carriage return "
"(``b'\\r'``) kopieras den och den aktuella kolumnen nollställs.  Alla andra "
"bytevärden kopieras oförändrade och den aktuella kolumnen ökas med ett "
"oavsett hur bytevärdet representeras när det skrivs ut::"

#: ../../library/stdtypes.rst:3630
msgid ""
">>> b'01\\t012\\t0123\\t01234'.expandtabs()\n"
"b'01      012     0123    01234'\n"
">>> b'01\\t012\\t0123\\t01234'.expandtabs(4)\n"
"b'01  012 0123    01234'"
msgstr ""
">>> b'01\\t012\\t0123\\t01234'.expandtabs()\n"
"b'01 012 0123 01234'\n"
">>> b'01\\t012\\t0123\\t01234'.expandtabs(4)\n"
"b'01 012 0123 01234'"

#: ../../library/stdtypes.rst:3644
msgid ""
"Return ``True`` if all bytes in the sequence are alphabetical ASCII "
"characters or ASCII decimal digits and the sequence is not empty, ``False`` "
"otherwise. Alphabetic ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``. ASCII decimal "
"digits are those byte values in the sequence ``b'0123456789'``."
msgstr ""
"Returnerar ``True`` om alla bytes i sekvensen är alfabetiska ASCII-tecken "
"eller ASCIIdecimalsiffror och sekvensen inte är tom, annars ``False``. "
"Alfabetiska ASCII-tecken är de bytevärden som finns i sekvensen "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``. ASCII "
"decimalsiffror är de bytevärden i sekvensen ``b'0123456789'``."

#: ../../library/stdtypes.rst:3652
msgid ""
">>> b'ABCabc1'.isalnum()\n"
"True\n"
">>> b'ABC abc1'.isalnum()\n"
"False"
msgstr ""
">>> b'ABCabc1'.isalnum()\n"
"Sant\n"
">>> b'ABC abc1'.isalnum()\n"
"Falsk"

#: ../../library/stdtypes.rst:3661
msgid ""
"Return ``True`` if all bytes in the sequence are alphabetic ASCII characters "
"and the sequence is not empty, ``False`` otherwise.  Alphabetic ASCII "
"characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""
"Returnerar ``True`` om alla bytes i sekvensen är alfabetiska ASCII-tecken "
"och sekvensen inte är tom, annars ``False``.  Alfabetiska ASCII-tecken är de "
"bytevärden som finns i sekvensen "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``."

#: ../../library/stdtypes.rst:3668
msgid ""
">>> b'ABCabc'.isalpha()\n"
"True\n"
">>> b'ABCabc1'.isalpha()\n"
"False"
msgstr ""
">>> b'ABCabc'.isalpha()\n"
"Sant\n"
">>> b'ABCabc1'.isalpha()\n"
"Falskt"

#: ../../library/stdtypes.rst:3677
msgid ""
"Return ``True`` if the sequence is empty or all bytes in the sequence are "
"ASCII, ``False`` otherwise. ASCII bytes are in the range 0-0x7F."
msgstr ""
"Returnerar ``True`` om sekvensen är tom eller om alla byte i sekvensen är "
"ASCII, annars ``False``. ASCII-bytes ligger i intervallet 0-0x7F."

#: ../../library/stdtypes.rst:3687
msgid ""
"Return ``True`` if all bytes in the sequence are ASCII decimal digits and "
"the sequence is not empty, ``False`` otherwise. ASCII decimal digits are "
"those byte values in the sequence ``b'0123456789'``."
msgstr ""
"Returnerar ``True`` om alla bytes i sekvensen är ASCII decimala siffror och "
"sekvensen inte är tom, annars ``False``. ASCII decimalsiffror är de "
"bytevärden som finns i sekvensen ``b'0123456789'``."

#: ../../library/stdtypes.rst:3693
msgid ""
">>> b'1234'.isdigit()\n"
"True\n"
">>> b'1.23'.isdigit()\n"
"False"
msgstr ""
">>> b'1234'.isdigit()\n"
"Sant\n"
">>> b'1.23'.isdigit()\n"
"Falsk"

#: ../../library/stdtypes.rst:3702
msgid ""
"Return ``True`` if there is at least one lowercase ASCII character in the "
"sequence and no uppercase ASCII characters, ``False`` otherwise."
msgstr ""
"Returnerar ``True`` om det finns minst ett ASCII-tecken med små bokstäver i "
"sekvensen och inga ASCII-tecken med stora bokstäver, annars ``False``."

#: ../../library/stdtypes.rst:3707
msgid ""
">>> b'hello world'.islower()\n"
"True\n"
">>> b'Hello world'.islower()\n"
"False"
msgstr ""
">>> b'hello world'.islower()\n"
"Sant\n"
">>> b'Hello world'.islower()\n"
"Falsk"

#: ../../library/stdtypes.rst:3712 ../../library/stdtypes.rst:3754
#: ../../library/stdtypes.rst:3770 ../../library/stdtypes.rst:3820
#: ../../library/stdtypes.rst:3889
msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those byte "
"values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""
"ASCII-tecken med gemener är de bytevärden som ingår i sekvensen "
"``b'abcdefghijklmnopqrstuvwxyz'``. Versala ASCII-tecken är de bytevärden som "
"ingår i sekvensen ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``."

#: ../../library/stdtypes.rst:3720
msgid ""
"Return ``True`` if all bytes in the sequence are ASCII whitespace and the "
"sequence is not empty, ``False`` otherwise.  ASCII whitespace characters are "
"those byte values in the sequence ``b' \\t\\n\\r\\x0b\\f'`` (space, tab, "
"newline, carriage return, vertical tab, form feed)."
msgstr ""
"Returnerar ``True`` om alla byte i sekvensen är ASCII blanksteg och "
"sekvensen inte är tom, annars ``False``.  ASCII-tecknen för blanksteg är de "
"bytevärden i sekvensen ``b' \\t\\n\\r\\x0b\\f'`` (mellanslag, tabb, ny rad, "
"vagnsretur, vertikal tabb, form feed)."

#: ../../library/stdtypes.rst:3729
msgid ""
"Return ``True`` if the sequence is ASCII titlecase and the sequence is not "
"empty, ``False`` otherwise. See :meth:`bytes.title` for more details on the "
"definition of \"titlecase\"."
msgstr ""
"Returnerar ``True`` om sekvensen är ASCII titlecase och sekvensen inte är "
"tom, ``False`` annars. Se :meth:`bytes.title` för mer information om "
"definitionen av \"titlecase\"."

#: ../../library/stdtypes.rst:3735
msgid ""
">>> b'Hello World'.istitle()\n"
"True\n"
">>> b'Hello world'.istitle()\n"
"False"
msgstr ""
">>> b'Hello World'.istitle()\n"
"Sant\n"
">>> b'Hello world'.istitle()\n"
"Falsk"

#: ../../library/stdtypes.rst:3744
msgid ""
"Return ``True`` if there is at least one uppercase alphabetic ASCII "
"character in the sequence and no lowercase ASCII characters, ``False`` "
"otherwise."
msgstr ""
"Returnerar ``True`` om det finns minst ett versalt alfabetiskt ASCII-tecken "
"i sekvensen och inga gemena ASCII-tecken, annars ``False``."

#: ../../library/stdtypes.rst:3749
msgid ""
">>> b'HELLO WORLD'.isupper()\n"
"True\n"
">>> b'Hello world'.isupper()\n"
"False"
msgstr ""
">>> b'HELLO WORLD'.isupper()\n"
"Sant\n"
">>> b'Hello world'.isupper()\n"
"False"

#: ../../library/stdtypes.rst:3762
msgid ""
"Return a copy of the sequence with all the uppercase ASCII characters "
"converted to their corresponding lowercase counterpart."
msgstr ""
"Returnerar en kopia av sekvensen med alla ASCII-tecken med versaler "
"konverterade till motsvarande tecken med gemener."

#: ../../library/stdtypes.rst:3767
msgid ""
">>> b'Hello World'.lower()\n"
"b'hello world'"
msgstr ""
">>> b'Hello World'.lower()\n"
"b'hej världen'"

#: ../../library/stdtypes.rst:3787
msgid ""
"Return a list of the lines in the binary sequence, breaking at ASCII line "
"boundaries. This method uses the :term:`universal newlines` approach to "
"splitting lines. Line breaks are not included in the resulting list unless "
"*keepends* is given and true."
msgstr ""
"Returnerar en lista med raderna i den binära sekvensen, med brytning vid "
"ASCII-radgränser. Den här metoden använder :term:`universal newlines` för "
"att dela upp rader. Radbrytningar inkluderas inte i den resulterande listan "
"om inte *keepends* anges och är true."

#: ../../library/stdtypes.rst:3794
msgid ""
">>> b'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines()\n"
"[b'ab c', b'', b'de fg', b'kl']\n"
">>> b'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines(keepends=True)\n"
"[b'ab c\\n', b'\\n', b'de fg\\r', b'kl\\r\\n']"
msgstr ""
">>> b'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines()\n"
"[b'ab c', b'', b'de fg', b'kl']\n"
">>> b'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines(keepends=True)\n"
"[b'ab c\\n', b'\\n', b'de fg\\r', b'kl\\r\\n']"

#: ../../library/stdtypes.rst:3799
msgid ""
"Unlike :meth:`~bytes.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break "
"does not result in an extra line::"
msgstr ""
"Till skillnad från :meth:`~bytes.split` när en avgränsningssträng *sep* "
"anges, returnerar den här metoden en tom lista för den tomma strängen, och "
"en terminal radbrytning resulterar inte i en extra rad::"

#: ../../library/stdtypes.rst:3803
msgid ""
">>> b\"\".split(b'\\n'), b\"Two lines\\n\".split(b'\\n')\n"
"([b''], [b'Two lines', b''])\n"
">>> b\"\".splitlines(), b\"One line\\n\".splitlines()\n"
"([], [b'One line'])"
msgstr ""
">>> b\"\".split(b'\\n'), b\"Två linjer\\n\".split(b'\\n')\n"
"([b''], [b'Två rader', b''])\n"
">>> b\"\".splitlines(), b\"En rad\\n\".splitlines()\n"
"([], [b'En rad'])"

#: ../../library/stdtypes.rst:3812
msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters "
"converted to their corresponding uppercase counterpart and vice-versa."
msgstr ""
"Returnerar en kopia av sekvensen med alla ASCII-tecken med gemener "
"konverterade till motsvarande tecken med versaler och vice versa."

#: ../../library/stdtypes.rst:3817
msgid ""
">>> b'Hello World'.swapcase()\n"
"b'hELLO wORLD'"
msgstr ""
">>> b'Hello World'.swapcase()\n"
"b'hELLO VÄRLDEN'"

#: ../../library/stdtypes.rst:3824
msgid ""
"Unlike :func:`str.swapcase`, it is always the case that ``bin.swapcase()."
"swapcase() == bin`` for the binary versions. Case conversions are "
"symmetrical in ASCII, even though that is not generally true for arbitrary "
"Unicode code points."
msgstr ""
"Till skillnad från :func:`str.swapcase` är det alltid så att ``bin."
"swapcase().swapcase() == bin`` för de binära versionerna. Omvandling av "
"versaler är symmetrisk i ASCII, även om det i allmänhet inte är sant för "
"godtyckliga Unicode-kodpunkter."

#: ../../library/stdtypes.rst:3838
msgid ""
"Return a titlecased version of the binary sequence where words start with an "
"uppercase ASCII character and the remaining characters are lowercase. "
"Uncased byte values are left unmodified."
msgstr ""
"Returnerar en version med versaler av den binära sekvensen där orden börjar "
"med ett ASCII-tecken med versaler och de återstående tecknen är gemener. "
"Bytevärden som inte är versaler lämnas oförändrade."

#: ../../library/stdtypes.rst:3844
msgid ""
">>> b'Hello world'.title()\n"
"b'Hello World'"
msgstr ""
">>> b'Hello world'.title()\n"
"b'Hello World'"

#: ../../library/stdtypes.rst:3847
msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those byte "
"values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``. All other byte "
"values are uncased."
msgstr ""
"ASCII-tecken med gemener är de bytevärden som ingår i sekvensen "
"``b'abcdefghijklmnopqrstuvwxyz'``. Versala ASCII-tecken är de bytevärden i "
"sekvensen ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``. Alla andra bytevärden är "
"okommaterade."

#: ../../library/stdtypes.rst:3857
msgid ""
">>> b\"they're bill's friends from the UK\".title()\n"
"b\"They'Re Bill'S Friends From The Uk\""
msgstr ""
">>> b\"de är Bills vänner från Storbritannien\".title()\n"
"b\"De är Bills vänner från Storbritannien\""

#: ../../library/stdtypes.rst:3860
msgid ""
"A workaround for apostrophes can be constructed using regular expressions::"
msgstr ""
"En lösning för apostrofer kan konstrueras med hjälp av reguljära uttryck::"

#: ../../library/stdtypes.rst:3862
msgid ""
">>> import re\n"
">>> def titlecase(s):\n"
"...     return re.sub(rb\"[A-Za-z]+('[A-Za-z]+)?\",\n"
"...                   lambda mo: mo.group(0)[0:1].upper() +\n"
"...                              mo.group(0)[1:].lower(),\n"
"...                   s)\n"
"...\n"
">>> titlecase(b\"they're bill's friends.\")\n"
"b\"They're Bill's Friends.\""
msgstr ""
">>> import re\n"
">>> def titlecase(s):\n"
"... return re.sub(rb\"[A-Za-z]+('[A-Za-z]+)?\",\n"
"... lambda mo: mo.group(0)[0:1].upper() +\n"
"... mo.group(0)[1:].lower(),\n"
"... s)\n"
"...\n"
">>> titlecase(b\"de är Bills vänner.\")\n"
"b\"De är Bills vänner.\""

#: ../../library/stdtypes.rst:3881
msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters "
"converted to their corresponding uppercase counterpart."
msgstr ""
"Returnerar en kopia av sekvensen med alla ASCII-tecken med gemener "
"konverterade till motsvarande tecken med versaler."

#: ../../library/stdtypes.rst:3886
msgid ""
">>> b'Hello World'.upper()\n"
"b'HELLO WORLD'"
msgstr ""
">>> b'Hello World'.upper()\n"
"b'HELLO WORLD'"

#: ../../library/stdtypes.rst:3902
msgid ""
"Return a copy of the sequence left filled with ASCII ``b'0'`` digits to make "
"a sequence of length *width*. A leading sign prefix (``b'+'``/ ``b'-'``) is "
"handled by inserting the padding *after* the sign character rather than "
"before. For :class:`bytes` objects, the original sequence is returned if "
"*width* is less than or equal to ``len(seq)``."
msgstr ""
"Returnerar en kopia av den sekvens som lämnats fylld med ASCII ``b'0'`` "
"siffror för att skapa en sekvens med längden *bredd*. Ett ledande "
"teckenprefix (``b'+'``/ ``b'-'``) hanteras genom att utfyllnaden infogas "
"*efter* tecknet istället för före. För :class:`bytes`-objekt returneras den "
"ursprungliga sekvensen om *width* är mindre än eller lika med ``len(seq)``."

#: ../../library/stdtypes.rst:3910
msgid ""
">>> b\"42\".zfill(5)\n"
"b'00042'\n"
">>> b\"-42\".zfill(5)\n"
"b'-0042'"
msgstr ""
">>> b\"42\".zfill(5)\n"
"b'00042'\n"
">>> b\"-42\".zfill(5)\n"
"b'-0042'"

#: ../../library/stdtypes.rst:3924
msgid "``printf``-style Bytes Formatting"
msgstr "byteformatering i stil med ``printf``"

#: ../../library/stdtypes.rst:3941
msgid ""
"The formatting operations described here exhibit a variety of quirks that "
"lead to a number of common errors (such as failing to display tuples and "
"dictionaries correctly).  If the value being printed may be a tuple or "
"dictionary, wrap it in a tuple."
msgstr ""
"De formateringsoperationer som beskrivs här uppvisar en rad olika egenheter "
"som leder till ett antal vanliga fel (t.ex. att tuplar och ordböcker inte "
"visas korrekt).  Om det värde som skrivs ut kan vara en tupel eller en "
"ordbok ska det paketeras i en tupel."

#: ../../library/stdtypes.rst:3946
msgid ""
"Bytes objects (``bytes``/``bytearray``) have one unique built-in operation: "
"the ``%`` operator (modulo). This is also known as the bytes *formatting* or "
"*interpolation* operator. Given ``format % values`` (where *format* is a "
"bytes object), ``%`` conversion specifications in *format* are replaced with "
"zero or more elements of *values*. The effect is similar to using the :c:"
"func:`sprintf` in the C language."
msgstr ""
"Bytesobjekt (``bytes``/`bytearray``) har en unik inbyggd operation: "
"operatorn ``%`` (modulo). Detta är också känt som bytes *formatering* eller "
"*interpolation*-operator. Givet ``format % values`` (där *format* är ett "
"bytesobjekt), ersätts ``%`` konverteringsspecifikationer i *format* med noll "
"eller flera element i *values*. Effekten liknar användningen av :c:func:"
"`sprintf` i C-språket."

#: ../../library/stdtypes.rst:3953
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of "
"items specified by the format bytes object, or a single mapping object (for "
"example, a dictionary)."
msgstr ""
"Om *format* kräver ett enda argument kan *values* vara ett enda objekt som "
"inte är en tupel. [5]_ Annars måste *values* vara en tupel med exakt det "
"antal objekt som anges av formatbytesobjektet, eller ett enda "
"mappningsobjekt (t.ex. en ordbok)."

#: ../../library/stdtypes.rst:3987
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the bytes object *must* include a parenthesised mapping key into "
"that dictionary inserted immediately after the ``'%'`` character. The "
"mapping key selects the value to be formatted from the mapping.  For example:"
msgstr ""
"När det högra argumentet är en ordbok (eller annan mappningstyp), måste "
"formaten i bytesobjektet *inkludera* en parentetisk mappningsnyckel till "
"ordboken som infogas omedelbart efter tecknet ``'%'``. Mappningsnyckeln "
"väljer det värde som ska formateras från mappningen.  Exempelvis"

#: ../../library/stdtypes.rst:4061
msgid "Single byte (accepts integer or single byte objects)."
msgstr "Single byte (accepterar objekt med heltal eller single byte)."

#: ../../library/stdtypes.rst:4064
msgid "``'b'``"
msgstr "``'b'``"

#: ../../library/stdtypes.rst:4064
msgid ""
"Bytes (any object that follows the :ref:`buffer protocol <bufferobjects>` or "
"has :meth:`~object.__bytes__`)."
msgstr ""
"Bytes (alla objekt som följer :ref:`buffer protocol <bufferobjects>` eller "
"har :meth:`~object.__bytes__`)."

#: ../../library/stdtypes.rst:4068
msgid ""
"``'s'`` is an alias for ``'b'`` and should only be used for Python2/3 code "
"bases."
msgstr ""
"``'s'`` är ett alias för ``'b'`` och bör endast användas för Python2/3-"
"kodbaser."

#: ../../library/stdtypes.rst:4071
msgid ""
"Bytes (converts any Python object using ``repr(obj).encode('ascii', "
"'backslashreplace')``)."
msgstr ""
"Bytes (konverterar valfritt Python-objekt med ``repr(obj).encode('ascii', "
"'backslashreplace')``)."

#: ../../library/stdtypes.rst:4074
msgid ""
"``'r'`` is an alias for ``'a'`` and should only be used for Python2/3 code "
"bases."
msgstr ""
"``'r'`` är ett alias för ``'a'`` och bör endast användas för Python2/3-"
"kodbaser."

#: ../../library/stdtypes.rst:4074
msgid "\\(7)"
msgstr "\\(7)"

#: ../../library/stdtypes.rst:4109
msgid "``b'%s'`` is deprecated, but will not be removed during the 3.x series."
msgstr "``b'%s'`` är föråldrad, men kommer inte att tas bort under 3.x-serien."

#: ../../library/stdtypes.rst:4112
msgid "``b'%r'`` is deprecated, but will not be removed during the 3.x series."
msgstr "``b'%r'`` är föråldrad, men kommer inte att tas bort under 3.x-serien."

#: ../../library/stdtypes.rst:4124
msgid ":pep:`461` - Adding % formatting to bytes and bytearray"
msgstr ":pep:`461` - Lägga till % formatering till bytes och bytearray"

#: ../../library/stdtypes.rst:4131
msgid "Memory Views"
msgstr "Minnesvy"

#: ../../library/stdtypes.rst:4133
msgid ""
":class:`memoryview` objects allow Python code to access the internal data of "
"an object that supports the :ref:`buffer protocol <bufferobjects>` without "
"copying."
msgstr ""
":class:`memoryview`-objekt gör det möjligt för Python-kod att komma åt "
"interna data i ett objekt som stöder :ref:`buffer protocol <bufferobjects>` "
"utan kopiering."

#: ../../library/stdtypes.rst:4139
msgid ""
"Create a :class:`memoryview` that references *object*.  *object* must "
"support the buffer protocol.  Built-in objects that support the buffer "
"protocol include :class:`bytes` and :class:`bytearray`."
msgstr ""
"Skapa en :class:`memoryview` som refererar till *object*.  *object* måste "
"stödja buffertprotokollet.  Inbyggda objekt som stöder buffertprotokollet "
"inkluderar :class:`bytes` och :class:`bytearray`."

#: ../../library/stdtypes.rst:4143
msgid ""
"A :class:`memoryview` has the notion of an *element*, which is the atomic "
"memory unit handled by the originating *object*.  For many simple types such "
"as :class:`bytes` and :class:`bytearray`, an element is a single byte, but "
"other types such as :class:`array.array` may have bigger elements."
msgstr ""
"En :class:`memoryview` har begreppet *element*, som är den atomära "
"minnesenhet som hanteras av det ursprungliga *objektet*.  För många enkla "
"typer som :class:`bytes` och :class:`bytearray` är ett element en enda byte, "
"men andra typer som :class:`array.array` kan ha större element."

#: ../../library/stdtypes.rst:4148
msgid ""
"``len(view)`` is equal to the length of :class:`~memoryview.tolist`, which "
"is the nested list representation of the view. If ``view.ndim = 1``, this is "
"equal to the number of elements in the view."
msgstr ""
"``len(view)`` är lika med längden på :class:`~memoryview.tolist`, som är den "
"nästlade listrepresentationen av vyn. Om ``view.ndim = 1`` är detta lika med "
"antalet element i vyn."

#: ../../library/stdtypes.rst:4152
msgid ""
"If ``view.ndim == 0``, ``len(view)`` now raises :exc:`TypeError` instead of "
"returning 1."
msgstr ""
"Om ``view.ndim == 0``, ``len(view)`` ger nu :exc:`TypeError` istället för "
"att returnera 1."

#: ../../library/stdtypes.rst:4155
msgid ""
"The :class:`~memoryview.itemsize` attribute will give you the number of "
"bytes in a single element."
msgstr ""
"Attributet :class:`~memoryview.itemsize` ger dig antalet byte i ett enda "
"element."

#: ../../library/stdtypes.rst:4158
msgid ""
"A :class:`memoryview` supports slicing and indexing to expose its data. One-"
"dimensional slicing will result in a subview::"
msgstr ""
"En :class:`memoryview` stöder skivning och indexering för att exponera sina "
"data. Endimensionell skivning kommer att resultera i en undervy::"

#: ../../library/stdtypes.rst:4161
msgid ""
">>> v = memoryview(b'abcefg')\n"
">>> v[1]\n"
"98\n"
">>> v[-1]\n"
"103\n"
">>> v[1:4]\n"
"<memory at 0x7f3ddc9f4350>\n"
">>> bytes(v[1:4])\n"
"b'bce'"
msgstr ""
"&gt;&gt;&gt; v = minnesvy(b'abcefg')\n"
"&gt;&gt;&gt; v[1]\n"
"98\n"
"&gt;&gt;&gt; v[-1]\n"
"103\n"
"&gt;&gt;&gt; v[1:4]\n"
"<memory at 0x7f3ddc9f4350>\n"
"&gt;&gt;&gt; bytes(v[1:4])\n"
"b'bce'"

#: ../../library/stdtypes.rst:4171
msgid ""
"If :class:`~memoryview.format` is one of the native format specifiers from "
"the :mod:`struct` module, indexing with an integer or a tuple of integers is "
"also supported and returns a single *element* with the correct type.  One-"
"dimensional memoryviews can be indexed with an integer or a one-integer "
"tuple.  Multi-dimensional memoryviews can be indexed with tuples of exactly "
"*ndim* integers where *ndim* is the number of dimensions.  Zero-dimensional "
"memoryviews can be indexed with the empty tuple."
msgstr ""
"Om :class:`~memoryview.format` är en av de ursprungliga "
"formatspecifikationerna från modulen :mod:`struct` stöds även indexering med "
"ett heltal eller en tupel av heltal och returnerar ett enda *element* med "
"rätt typ.  Endimensionella minnesvyer kan indexeras med ett heltal eller en "
"tupel med ett heltal.  Flerdimensionella minnesvyer kan indexeras med tupler "
"av exakt *ndim* heltal där *ndim* är antalet dimensioner.  Nolldimensionella "
"minnesvyer kan indexeras med den tomma tupeln."

#: ../../library/stdtypes.rst:4180
msgid "Here is an example with a non-byte format::"
msgstr "Här är ett exempel med ett format som inte är byte::"

#: ../../library/stdtypes.rst:4182
msgid ""
">>> import array\n"
">>> a = array.array('l', [-11111111, 22222222, -33333333, 44444444])\n"
">>> m = memoryview(a)\n"
">>> m[0]\n"
"-11111111\n"
">>> m[-1]\n"
"44444444\n"
">>> m[::2].tolist()\n"
"[-11111111, -33333333]"
msgstr ""
">>> importera array\n"
">>> a = array.array('l', [-11111111, 22222222, -33333333, 44444444])\n"
">>> m = minnesvy(a)\n"
">>> m[0]\n"
"-11111111\n"
">>> m[-1]\n"
"44444444\n"
">>> m[::2].tolist()\n"
"[-11111111, -33333333]"

#: ../../library/stdtypes.rst:4192
msgid ""
"If the underlying object is writable, the memoryview supports one-"
"dimensional slice assignment. Resizing is not allowed::"
msgstr ""
"Om det underliggande objektet är skrivbart stöder minnesvyn endimensionell "
"tilldelning av skivor. Storleksändring är inte tillåtet::"

#: ../../library/stdtypes.rst:4195
msgid ""
">>> data = bytearray(b'abcefg')\n"
">>> v = memoryview(data)\n"
">>> v.readonly\n"
"False\n"
">>> v[0] = ord(b'z')\n"
">>> data\n"
"bytearray(b'zbcefg')\n"
">>> v[1:4] = b'123'\n"
">>> data\n"
"bytearray(b'z123fg')\n"
">>> v[2:3] = b'spam'\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: memoryview assignment: lvalue and rvalue have different "
"structures\n"
">>> v[2:6] = b'spam'\n"
">>> data\n"
"bytearray(b'z1spam')"
msgstr ""
"&gt;&gt;&gt; data = bytearray(b'abcefg')\n"
"&gt;&gt;&gt; v = minnesvy(data)\n"
"&gt;&gt;&gt; v.readonly\n"
"Falsk\n"
"&gt;&gt;&gt; v[0] = ord(b'z')\n"
"&gt;&gt;&gt; data\n"
"bytearray(b'zbcefg')\n"
"&gt;&gt;&gt; v[1:4] = b'123'\n"
"&gt;&gt;&gt; data\n"
"bytearray(b'z123fg')\n"
"&gt;&gt;&gt; v[2:3] = b'spam'\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"ValueError: minnesvytilldelning: lvärde och rvärde har olika strukturer\n"
"&gt;&gt;&gt; v[2:6] = b'spam'\n"
"&gt;&gt;&gt; data\n"
"bytearray(b'z1spam')"

#: ../../library/stdtypes.rst:4213
msgid ""
"One-dimensional memoryviews of :term:`hashable` (read-only) types with "
"formats 'B', 'b' or 'c' are also hashable. The hash is defined as ``hash(m) "
"== hash(m.tobytes())``::"
msgstr ""
"Endimensionella minnesvyer av :term:`hashable` (skrivskyddade) typer med "
"formaten 'B', 'b' eller 'c' är också hashbara. Hash definieras som ``hash(m) "
"== hash(m.tobytes())``::"

#: ../../library/stdtypes.rst:4217
msgid ""
">>> v = memoryview(b'abcefg')\n"
">>> hash(v) == hash(b'abcefg')\n"
"True\n"
">>> hash(v[2:4]) == hash(b'ce')\n"
"True\n"
">>> hash(v[::-2]) == hash(b'abcefg'[::-2])\n"
"True"
msgstr ""
">>> v = minnesvy(b'abcefg')\n"
">>> hash(v) == hash(b'abcefg')\n"
"Sant\n"
">>> hash(v[2:4]) == hash(b'ce')\n"
"Sant\n"
">>> hash(v[::-2]) == hash(b'abcefg'[::-2])\n"
"Sant"

#: ../../library/stdtypes.rst:4225
msgid ""
"One-dimensional memoryviews can now be sliced. One-dimensional memoryviews "
"with formats 'B', 'b' or 'c' are now :term:`hashable`."
msgstr ""
"Endimensionella minnesvyer kan nu skivas. Endimensionella minnesvyer med "
"formaten 'B', 'b' eller 'c' är nu :term:`hashable`."

#: ../../library/stdtypes.rst:4229
msgid ""
"memoryview is now registered automatically with :class:`collections.abc."
"Sequence`"
msgstr ""
"memoryview registreras nu automatiskt med :class:`collections.abc.Sequence`"

#: ../../library/stdtypes.rst:4233
msgid "memoryviews can now be indexed with tuple of integers."
msgstr "minnesvyer kan nu indexeras med tupel av heltal."

#: ../../library/stdtypes.rst:4236
msgid "memoryview is now a :term:`generic type`."
msgstr "memoryview är nu en :term:`generisk typ`."

#: ../../library/stdtypes.rst:4239
msgid ":class:`memoryview` has several methods:"
msgstr ":class:`memoryview` har flera metoder:"

#: ../../library/stdtypes.rst:4243
msgid ""
"A memoryview and a :pep:`3118` exporter are equal if their shapes are "
"equivalent and if all corresponding values are equal when the operands' "
"respective format codes are interpreted using :mod:`struct` syntax."
msgstr ""
"En minnesvy och en :pep:`3118` exportör är lika om deras former är "
"likvärdiga och om alla motsvarande värden är lika när operandernas "
"respektive formatkoder tolkas med :mod:`struct` syntax."

#: ../../library/stdtypes.rst:4247
msgid ""
"For the subset of :mod:`struct` format strings currently supported by :meth:"
"`tolist`, ``v`` and ``w`` are equal if ``v.tolist() == w.tolist()``::"
msgstr ""
"För den delmängd av :mod:`struct` formatsträngar som för närvarande stöds "
"av :meth:`tolist`, är ``v`` och ``w`` lika om ``v.tolist() == w.tolist()``::"

#: ../../library/stdtypes.rst:4250
msgid ""
">>> import array\n"
">>> a = array.array('I', [1, 2, 3, 4, 5])\n"
">>> b = array.array('d', [1.0, 2.0, 3.0, 4.0, 5.0])\n"
">>> c = array.array('b', [5, 3, 1])\n"
">>> x = memoryview(a)\n"
">>> y = memoryview(b)\n"
">>> x == a == y == b\n"
"True\n"
">>> x.tolist() == a.tolist() == y.tolist() == b.tolist()\n"
"True\n"
">>> z = y[::-2]\n"
">>> z == c\n"
"True\n"
">>> z.tolist() == c.tolist()\n"
"True"
msgstr ""
">>> importera array\n"
">>> a = array.array('I', [1, 2, 3, 4, 5])\n"
">>> b = array.array('d', [1,0, 2,0, 3,0, 4,0, 5,0])\n"
">>> c = matris.matris('b', [5, 3, 1])\n"
">>> x = minnesvy(a)\n"
">>> y = minnesvy(b)\n"
">>> x == a == y == b\n"
"Sant\n"
">>> x.tolist() == a.tolist() == y.tolist() == b.tolist()\n"
"Sant\n"
">>> z = y[::-2]\n"
">>> z == c\n"
"Sant\n"
">>> z.tolist() == c.tolist()\n"
"Sant"

#: ../../library/stdtypes.rst:4266
msgid ""
"If either format string is not supported by the :mod:`struct` module, then "
"the objects will always compare as unequal (even if the format strings and "
"buffer contents are identical)::"
msgstr ""
"Om någon av formatsträngarna inte stöds av modulen :mod:`struct`, kommer "
"objekten alltid att jämföras som olika (även om formatsträngarna och "
"buffertinnehållet är identiska)::"

#: ../../library/stdtypes.rst:4270
msgid ""
">>> from ctypes import BigEndianStructure, c_long\n"
">>> class BEPoint(BigEndianStructure):\n"
"...     _fields_ = [(\"x\", c_long), (\"y\", c_long)]\n"
"...\n"
">>> point = BEPoint(100, 200)\n"
">>> a = memoryview(point)\n"
">>> b = memoryview(point)\n"
">>> a == point\n"
"False\n"
">>> a == b\n"
"False"
msgstr ""
">>> från ctypes importera BigEndianStructure, c_long\n"
">>> class BEPoint(BigEndianStructure):\n"
"...     _fields_ = [(\"x\", c_long), (\"y\", c_long)]\n"
"...\n"
">>> punkt = BEPoint(100, 200)\n"
">>> a = minnesvy(punkt)\n"
">>> b = minnesvy(punkt)\n"
">>> a == punkt\n"
"Falsk\n"
">>> a == b\n"
"Falsk"

#: ../../library/stdtypes.rst:4282
msgid ""
"Note that, as with floating-point numbers, ``v is w`` does *not* imply ``v "
"== w`` for memoryview objects."
msgstr ""
"Observera att, precis som med flyttal, ``v är w`` inte *innebär* ``v == w`` "
"för memoryview-objekt."

#: ../../library/stdtypes.rst:4285
msgid ""
"Previous versions compared the raw memory disregarding the item format and "
"the logical array structure."
msgstr ""
"Tidigare versioner jämförde råminnet utan att ta hänsyn till objektformatet "
"och den logiska arraystrukturen."

#: ../../library/stdtypes.rst:4291
msgid ""
"Return the data in the buffer as a bytestring.  This is equivalent to "
"calling the :class:`bytes` constructor on the memoryview. ::"
msgstr ""
"Returnerar data i bufferten som en bytestring.  Detta är likvärdigt med att "
"anropa :class:`bytes`-konstruktören på minnesvyn. ::"

#: ../../library/stdtypes.rst:4294
msgid ""
">>> m = memoryview(b\"abc\")\n"
">>> m.tobytes()\n"
"b'abc'\n"
">>> bytes(m)\n"
"b'abc'"
msgstr ""
">>> m = minnesvy(b\"abc\")\n"
">>> m.tobytes()\n"
"b'abc'\n"
">>> bytes(m)\n"
"b'abc'"

#: ../../library/stdtypes.rst:4300
msgid ""
"For non-contiguous arrays the result is equal to the flattened list "
"representation with all elements converted to bytes. :meth:`tobytes` "
"supports all format strings, including those that are not in :mod:`struct` "
"module syntax."
msgstr ""
"För icke sammanhängande matriser är resultatet lika med den tillplattade "
"listrepresentationen med alla element konverterade till bytes. :meth:"
"`tobytes` stöder alla formatsträngar, inklusive de som inte är i :mod:"
"`struct`-modulsyntax."

#: ../../library/stdtypes.rst:4305
msgid ""
"*order* can be {'C', 'F', 'A'}.  When *order* is 'C' or 'F', the data of the "
"original array is converted to C or Fortran order. For contiguous views, 'A' "
"returns an exact copy of the physical memory. In particular, in-memory "
"Fortran order is preserved. For non-contiguous views, the data is converted "
"to C first. *order=None* is the same as *order='C'*."
msgstr ""
"*order* kan vara {'C', 'F', 'A'}.  När *order* är 'C' eller 'F' konverteras "
"data från den ursprungliga matrisen till C- eller Fortran-ordning. För "
"sammanhängande vyer returnerar 'A' en exakt kopia av det fysiska minnet. I "
"synnerhet bevaras Fortran-ordningen i minnet. För icke-slutna vyer "
"konverteras data först till C. *order=None* är samma sak som *order='C'*."

#: ../../library/stdtypes.rst:4314
msgid ""
"Return a string object containing two hexadecimal digits for each byte in "
"the buffer. ::"
msgstr ""
"Returnerar ett strängobjekt som innehåller två hexadecimala siffror för "
"varje byte i bufferten. ::"

#: ../../library/stdtypes.rst:4317
msgid ""
">>> m = memoryview(b\"abc\")\n"
">>> m.hex()\n"
"'616263'"
msgstr ""
">>> m = minnesvy(b\"abc\")\n"
">>> m.hex()\n"
"'616263'"

#: ../../library/stdtypes.rst:4323
msgid ""
"Similar to :meth:`bytes.hex`, :meth:`memoryview.hex` now supports optional "
"*sep* and *bytes_per_sep* parameters to insert separators between bytes in "
"the hex output."
msgstr ""
"I likhet med :meth:`bytes.hex` har :meth:`memoryview.hex` nu stöd för de "
"valfria parametrarna *sep* och *bytes_per_sep* för att infoga separatorer "
"mellan byte i hex-utdata."

#: ../../library/stdtypes.rst:4330
msgid "Return the data in the buffer as a list of elements. ::"
msgstr "Returnera data i bufferten som en lista med element. ::"

#: ../../library/stdtypes.rst:4332
msgid ""
">>> memoryview(b'abc').tolist()\n"
"[97, 98, 99]\n"
">>> import array\n"
">>> a = array.array('d', [1.1, 2.2, 3.3])\n"
">>> m = memoryview(a)\n"
">>> m.tolist()\n"
"[1.1, 2.2, 3.3]"
msgstr ""
">>> memoryview(b'abc').tolist()\n"
"[97, 98, 99]\n"
">>> importera array\n"
">>> a = array.array('d', [1,1, 2,2, 3,3])\n"
">>> m = minnesvy(a)\n"
">>> m.tolist()\n"
"[1.1, 2.2, 3.3]"

#: ../../library/stdtypes.rst:4340
msgid ""
":meth:`tolist` now supports all single character native formats in :mod:"
"`struct` module syntax as well as multi-dimensional representations."
msgstr ""
":meth:`tolist` stöder nu alla ursprungliga format för enstaka tecken i "
"modulsyntaxen :mod:`struct` samt flerdimensionella representationer."

#: ../../library/stdtypes.rst:4347
msgid ""
"Return a readonly version of the memoryview object.  The original memoryview "
"object is unchanged. ::"
msgstr ""
"Returnerar en skrivskyddad version av memoryview-objektet.  Det ursprungliga "
"memoryview-objektet är oförändrat. ::"

#: ../../library/stdtypes.rst:4350
msgid ""
">>> m = memoryview(bytearray(b'abc'))\n"
">>> mm = m.toreadonly()\n"
">>> mm.tolist()\n"
"[97, 98, 99]\n"
">>> mm[0] = 42\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: cannot modify read-only memory\n"
">>> m[0] = 43\n"
">>> mm.tolist()\n"
"[43, 98, 99]"
msgstr ""
"&gt;&gt;&gt; m = memoryview(bytearray(b'abc'))\n"
"&gt;&gt;&gt; mm = m.toreadonly()\n"
"&gt;&gt;&gt; mm.tolist()\n"
"[97, 98, 99]\n"
"&gt;&gt;&gt; mm[0] = 42\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"TypeError: kan inte modifiera skrivskyddat minne\n"
"&gt;&gt;&gt; m[0] = 43\n"
"&gt;&gt;&gt; mm.tolist()\n"
"[43, 98, 99]"

#: ../../library/stdtypes.rst:4366
msgid ""
"Release the underlying buffer exposed by the memoryview object.  Many "
"objects take special actions when a view is held on them (for example, a :"
"class:`bytearray` would temporarily forbid resizing); therefore, calling "
"release() is handy to remove these restrictions (and free any dangling "
"resources) as soon as possible."
msgstr ""
"Frigör den underliggande bufferten som exponeras av memoryview-objektet.  "
"Många objekt vidtar speciella åtgärder när en vy hålls på dem (t.ex. skulle "
"en :class:`bytearray` tillfälligt förbjuda storleksändring); därför är det "
"praktiskt att anropa release() för att ta bort dessa begränsningar (och "
"frigöra eventuella hängande resurser) så snart som möjligt."

#: ../../library/stdtypes.rst:4372
msgid ""
"After this method has been called, any further operation on the view raises "
"a :class:`ValueError` (except :meth:`release` itself which can be called "
"multiple times)::"
msgstr ""
"Efter att denna metod har anropats ger alla ytterligare åtgärder på vyn "
"upphov till ett :class:`ValueError` (utom :meth:`release` själv som kan "
"anropas flera gånger)::"

#: ../../library/stdtypes.rst:4376
msgid ""
">>> m = memoryview(b'abc')\n"
">>> m.release()\n"
">>> m[0]\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: operation forbidden on released memoryview object"
msgstr ""
"&gt;&gt;&gt; m = minnesvy(b'abc')\n"
"&gt;&gt;&gt; m.release()\n"
"&gt;&gt;&gt; m[0]\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"ValueError: operation förbjuden på frigjort memoryview-objekt"

#: ../../library/stdtypes.rst:4383
msgid ""
"The context management protocol can be used for a similar effect, using the "
"``with`` statement::"
msgstr ""
"Protokollet för kontexthantering kan användas för en liknande effekt med "
"hjälp av ``with``-satsen::"

#: ../../library/stdtypes.rst:4386
msgid ""
">>> with memoryview(b'abc') as m:\n"
"...     m[0]\n"
"...\n"
"97\n"
">>> m[0]\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: operation forbidden on released memoryview object"
msgstr ""
"&gt;&gt;&gt; med memoryview(b'abc') som m:\n"
"... m[0]\n"
"...\n"
"97\n"
"&gt;&gt;&gt; m[0]\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"ValueError: operation förbjuden på frigjort memoryview-objekt"

#: ../../library/stdtypes.rst:4399
msgid ""
"Cast a memoryview to a new format or shape. *shape* defaults to "
"``[byte_length//new_itemsize]``, which means that the result view will be "
"one-dimensional. The return value is a new memoryview, but the buffer itself "
"is not copied. Supported casts are 1D -> C-:term:`contiguous` and C-"
"contiguous -> 1D."
msgstr ""
"Castar en minnesvy till ett nytt format eller en ny form. *shape* är som "
"standard ``[byte_length//new_itemsize]``, vilket innebär att resultatvyn "
"kommer att vara endimensionell. Returvärdet är en ny minnesvy, men själva "
"bufferten kopieras inte. Stödda casts är 1D -> C-:term:`contiguous` och C-"
"contiguous -> 1D."

#: ../../library/stdtypes.rst:4405
msgid ""
"The destination format is restricted to a single element native format in :"
"mod:`struct` syntax. One of the formats must be a byte format ('B', 'b' or "
"'c'). The byte length of the result must be the same as the original length. "
"Note that all byte lengths may depend on the operating system."
msgstr ""
"Målformatet är begränsat till ett inbyggt format med ett enda element i :mod:"
"`struct`-syntax. Ett av formaten måste vara ett byteformat ('B', 'b' eller "
"'c'). Byte-längden på resultatet måste vara samma som den ursprungliga "
"längden. Observera att alla byte-längder kan bero på operativsystemet."

#: ../../library/stdtypes.rst:4411
msgid "Cast 1D/long to 1D/unsigned bytes::"
msgstr "Cast 1D/lång till 1D/unsigned bytes::"

#: ../../library/stdtypes.rst:4413
msgid ""
">>> import array\n"
">>> a = array.array('l', [1,2,3])\n"
">>> x = memoryview(a)\n"
">>> x.format\n"
"'l'\n"
">>> x.itemsize\n"
"8\n"
">>> len(x)\n"
"3\n"
">>> x.nbytes\n"
"24\n"
">>> y = x.cast('B')\n"
">>> y.format\n"
"'B'\n"
">>> y.itemsize\n"
"1\n"
">>> len(y)\n"
"24\n"
">>> y.nbytes\n"
"24"
msgstr ""
">>> importera array\n"
">>> a = array.array('l', [1,2,3])\n"
">>> x = minnesvy(a)\n"
">>> x.format\n"
"'l'\n"
">>> x.objektstorlek\n"
"8\n"
">>> len(x)\n"
"3\n"
">>> x.nbytes\n"
"24\n"
">>> y = x.cast('B')\n"
">>> y.format\n"
"'B'\n"
">>> y.itemsize\n"
"1\n"
">>> len(y)\n"
"24\n"
">>> y.nbytes\n"
"24"

#: ../../library/stdtypes.rst:4434
msgid "Cast 1D/unsigned bytes to 1D/char::"
msgstr "Casta 1D/unsigned bytes till 1D/char::"

#: ../../library/stdtypes.rst:4436
msgid ""
">>> b = bytearray(b'zyz')\n"
">>> x = memoryview(b)\n"
">>> x[0] = b'a'\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: memoryview: invalid type for format 'B'\n"
">>> y = x.cast('c')\n"
">>> y[0] = b'a'\n"
">>> b\n"
"bytearray(b'ayz')"
msgstr ""
">>> b = bytearray(b'zyz')\n"
">>> x = minnesvy(b)\n"
">>> x[0] = b'a'\n"
"Traceback (senaste anropet senast):\n"
"  ...\n"
"TypeError: memoryview: ogiltig typ för formatet 'B'\n"
">>> y = x.cast('c')\n"
">>> y[0] = b'a'\n"
">>> b\n"
"bytearray(b'ayz')"

#: ../../library/stdtypes.rst:4447
msgid "Cast 1D/bytes to 3D/ints to 1D/signed char::"
msgstr "Cast 1D/bytes till 3D/ints till 1D/signed char::"

#: ../../library/stdtypes.rst:4449
msgid ""
">>> import struct\n"
">>> buf = struct.pack(\"i\"*12, *list(range(12)))\n"
">>> x = memoryview(buf)\n"
">>> y = x.cast('i', shape=[2,2,3])\n"
">>> y.tolist()\n"
"[[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]\n"
">>> y.format\n"
"'i'\n"
">>> y.itemsize\n"
"4\n"
">>> len(y)\n"
"2\n"
">>> y.nbytes\n"
"48\n"
">>> z = y.cast('b')\n"
">>> z.format\n"
"'b'\n"
">>> z.itemsize\n"
"1\n"
">>> len(z)\n"
"48\n"
">>> z.nbytes\n"
"48"
msgstr ""
">>> import struct\n"
">>> buf = struct.pack(\"i\"*12, *list(intervall(12)))\n"
">>> x = minnesvy(buf)\n"
">>> y = x.cast('i', shape=[2,2,3])\n"
">>> y.tolist()\n"
"[[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]\n"
">>> y.format\n"
"'i'\n"
">>> y.objektstorlek\n"
"4\n"
">>> len(y)\n"
"2\n"
">>> y.nbytes\n"
"48\n"
">>> z = y.cast('b')\n"
">>> z.format\n"
"'b'\n"
">>> z.objektstorlek\n"
"1\n"
">>> len(z)\n"
"48\n"
">>> z.nbytes\n"
"48"

#: ../../library/stdtypes.rst:4473
msgid "Cast 1D/unsigned long to 2D/unsigned long::"
msgstr "Cast 1D/unsigned long till 2D/unsigned long::"

#: ../../library/stdtypes.rst:4475
msgid ""
">>> buf = struct.pack(\"L\"*6, *list(range(6)))\n"
">>> x = memoryview(buf)\n"
">>> y = x.cast('L', shape=[2,3])\n"
">>> len(y)\n"
"2\n"
">>> y.nbytes\n"
"48\n"
">>> y.tolist()\n"
"[[0, 1, 2], [3, 4, 5]]"
msgstr ""
">>> buf = struct.pack(\"L\"*6, *list(intervall(6)))\n"
">>> x = minnesvy(buf)\n"
">>> y = x.cast('L', shape=[2,3])\n"
">>> len(y)\n"
"2\n"
">>> y.nbytes\n"
"48\n"
">>> y.tolist()\n"
"[[0, 1, 2], [3, 4, 5]]"

#: ../../library/stdtypes.rst:4487
msgid "The source format is no longer restricted when casting to a byte view."
msgstr "Källformatet är inte längre begränsat vid casting till en bytevy."

#: ../../library/stdtypes.rst:4492
msgid "Count the number of occurrences of *value*."
msgstr "Räkna antalet förekomster av *värde*."

#: ../../library/stdtypes.rst:4498
msgid ""
"Return the index of the first occurrence of *value* (at or after index "
"*start* and before index *stop*)."
msgstr ""
"Returnerar index för den första förekomsten av *värde* (vid eller efter "
"index *start* och före index *stop*)."

#: ../../library/stdtypes.rst:4501
msgid "Raises a :exc:`ValueError` if *value* cannot be found."
msgstr "Utlöser ett :exc:`ValueError` om *värde* inte kan hittas."

#: ../../library/stdtypes.rst:4505
msgid "There are also several readonly attributes available:"
msgstr "Det finns också flera skrivskyddade attribut tillgängliga:"

#: ../../library/stdtypes.rst:4509
msgid "The underlying object of the memoryview::"
msgstr "Det underliggande objektet för minnesvyn::"

#: ../../library/stdtypes.rst:4511
msgid ""
">>> b  = bytearray(b'xyz')\n"
">>> m = memoryview(b)\n"
">>> m.obj is b\n"
"True"
msgstr ""
">>> b = bytearray(b'xyz')\n"
">>> m = minnesvy(b)\n"
">>> m.obj är b\n"
"Sant"

#: ../../library/stdtypes.rst:4520
msgid ""
"``nbytes == product(shape) * itemsize == len(m.tobytes())``. This is the "
"amount of space in bytes that the array would use in a contiguous "
"representation. It is not necessarily equal to ``len(m)``::"
msgstr ""
"``nbytes == product(shape) * itemsize == len(m.tobytes())``. Detta är den "
"mängd utrymme i bytes som matrisen skulle använda i en sammanhängande "
"representation. Det är inte nödvändigtvis lika med ``len(m)``::"

#: ../../library/stdtypes.rst:4524
msgid ""
">>> import array\n"
">>> a = array.array('i', [1,2,3,4,5])\n"
">>> m = memoryview(a)\n"
">>> len(m)\n"
"5\n"
">>> m.nbytes\n"
"20\n"
">>> y = m[::2]\n"
">>> len(y)\n"
"3\n"
">>> y.nbytes\n"
"12\n"
">>> len(y.tobytes())\n"
"12"
msgstr ""
">>> importera array\n"
">>> a = array.array('i', [1,2,3,4,5])\n"
">>> m = minnesvy(a)\n"
">>> len(m)\n"
"5\n"
">>> m.nbytes\n"
"20\n"
">>> y = m[::2]\n"
">>> len(y)\n"
"3\n"
">>> y.nbytes\n"
"12\n"
">>> len(y.tobytes())\n"
"12"

#: ../../library/stdtypes.rst:4539
msgid "Multi-dimensional arrays::"
msgstr "Flerdimensionella matriser::"

#: ../../library/stdtypes.rst:4541
msgid ""
">>> import struct\n"
">>> buf = struct.pack(\"d\"*12, *[1.5*x for x in range(12)])\n"
">>> x = memoryview(buf)\n"
">>> y = x.cast('d', shape=[3,4])\n"
">>> y.tolist()\n"
"[[0.0, 1.5, 3.0, 4.5], [6.0, 7.5, 9.0, 10.5], [12.0, 13.5, 15.0, 16.5]]\n"
">>> len(y)\n"
"3\n"
">>> y.nbytes\n"
"96"
msgstr ""
">>> import struct\n"
">>> buf = struct.pack(\"d\"*12, *[1,5*x för x i intervall(12)])\n"
">>> x = minnesvy(buf)\n"
">>> y = x.cast('d', shape=[3,4])\n"
">>> y.tolist()\n"
"[[0.0, 1.5, 3.0, 4.5], [6.0, 7.5, 9.0, 10.5], [12.0, 13.5, 15.0, 16.5]]\n"
">>> len(y)\n"
"3\n"
">>> y.nbytes\n"
"96"

#: ../../library/stdtypes.rst:4556
msgid "A bool indicating whether the memory is read only."
msgstr "En bool som anger om minnet är skrivskyddat."

#: ../../library/stdtypes.rst:4560
msgid ""
"A string containing the format (in :mod:`struct` module style) for each "
"element in the view. A memoryview can be created from exporters with "
"arbitrary format strings, but some methods (e.g. :meth:`tolist`) are "
"restricted to native single element formats."
msgstr ""
"En sträng som innehåller formatet (i :mod:`struct`-modulstil) för varje "
"element i vyn. En minnesvy kan skapas från exportörer med godtyckliga "
"formatsträngar, men vissa metoder (t.ex. :meth:`tolist`) är begränsade till "
"ursprungliga format för enstaka element."

#: ../../library/stdtypes.rst:4565
msgid ""
"format ``'B'`` is now handled according to the struct module syntax. This "
"means that ``memoryview(b'abc')[0] == b'abc'[0] == 97``."
msgstr ""
"formatet ``'B'`` hanteras nu enligt struct-modulens syntax. Detta innebär "
"att ``memoryview(b'abc')[0] == b'abc'[0] == 97``."

#: ../../library/stdtypes.rst:4571
msgid "The size in bytes of each element of the memoryview::"
msgstr "Storleken i bytes för varje element i minnesvyn::"

#: ../../library/stdtypes.rst:4573
msgid ""
">>> import array, struct\n"
">>> m = memoryview(array.array('H', [32000, 32001, 32002]))\n"
">>> m.itemsize\n"
"2\n"
">>> m[0]\n"
"32000\n"
">>> struct.calcsize('H') == m.itemsize\n"
"True"
msgstr ""
">>> import matris, struktur\n"
">>> m = memoryview(array.array('H', [32000, 32001, 32002]))\n"
">>> m.itemsize\n"
"2\n"
">>> m[0]\n"
"32000\n"
">>> struct.calcsize('H') == m.itemsize\n"
"Sant"

#: ../../library/stdtypes.rst:4584
msgid ""
"An integer indicating how many dimensions of a multi-dimensional array the "
"memory represents."
msgstr ""
"Ett heltal som anger hur många dimensioner av en flerdimensionell array som "
"minnet representerar."

#: ../../library/stdtypes.rst:4589
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the shape of the "
"memory as an N-dimensional array."
msgstr ""
"En tupel av heltal med längden :attr:`ndim` som ger formen på minnet som en "
"N-dimensionell array."

#: ../../library/stdtypes.rst:4592 ../../library/stdtypes.rst:4600
msgid "An empty tuple instead of ``None`` when ndim = 0."
msgstr "En tom tupel i stället för ``None`` när ndim = 0."

#: ../../library/stdtypes.rst:4597
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the size in bytes to "
"access each element for each dimension of the array."
msgstr ""
"En tupel av heltal med längden :attr:`ndim` som anger storleken i bytes för "
"att komma åt varje element för varje dimension i matrisen."

#: ../../library/stdtypes.rst:4605
msgid "Used internally for PIL-style arrays. The value is informational only."
msgstr "Används internt för matriser av PIL-typ. Värdet är endast informativt."

#: ../../library/stdtypes.rst:4609
msgid "A bool indicating whether the memory is C-:term:`contiguous`."
msgstr "En bool som anger om minnet är C-:term:`contiguous`."

#: ../../library/stdtypes.rst:4615
msgid "A bool indicating whether the memory is Fortran :term:`contiguous`."
msgstr "En bool som anger om minnet är Fortran :term:`contiguous`."

#: ../../library/stdtypes.rst:4621
msgid "A bool indicating whether the memory is :term:`contiguous`."
msgstr "En bool som anger om minnet är :term:`sammenhängande`."

#: ../../library/stdtypes.rst:4629
msgid "Set Types --- :class:`set`, :class:`frozenset`"
msgstr "Set-typer --- :class:`set`, :class:`frozenset`"

#: ../../library/stdtypes.rst:4633
msgid ""
"A :dfn:`set` object is an unordered collection of distinct :term:`hashable` "
"objects. Common uses include membership testing, removing duplicates from a "
"sequence, and computing mathematical operations such as intersection, union, "
"difference, and symmetric difference. (For other containers see the built-"
"in :class:`dict`, :class:`list`, and :class:`tuple` classes, and the :mod:"
"`collections` module.)"
msgstr ""
"Ett :dfn:`set`-objekt är en oordnad samling av distinkta :term:`hashable`-"
"objekt. Vanliga användningsområden är medlemskapstestning, borttagning av "
"dubbletter från en sekvens och beräkning av matematiska operationer som "
"intersektion, union, differens och symmetrisk differens. (För andra "
"behållare se de inbyggda klasserna :class:`dict`, :class:`list` och :class:"
"`tuple` samt modulen :mod:`collections`)"

#: ../../library/stdtypes.rst:4640
msgid ""
"Like other collections, sets support ``x in set``, ``len(set)``, and ``for x "
"in set``.  Being an unordered collection, sets do not record element "
"position or order of insertion.  Accordingly, sets do not support indexing, "
"slicing, or other sequence-like behavior."
msgstr ""
"Liksom andra samlingar stöder set ``x in set``, ``len(set)`` och ``for x in "
"set``.  Eftersom set är en oordnad samling registreras inte elementens "
"position eller inmatningsordning.  Följaktligen stöder inte set indexering, "
"skivning eller annat sekvensliknande beteende."

#: ../../library/stdtypes.rst:4645
msgid ""
"There are currently two built-in set types, :class:`set` and :class:"
"`frozenset`. The :class:`set` type is mutable --- the contents can be "
"changed using methods like :meth:`~set.add` and :meth:`~set.remove`.  Since "
"it is mutable, it has no hash value and cannot be used as either a "
"dictionary key or as an element of another set.  The :class:`frozenset` type "
"is immutable and :term:`hashable` --- its contents cannot be altered after "
"it is created; it can therefore be used as a dictionary key or as an element "
"of another set."
msgstr ""
"Det finns för närvarande två inbyggda set-typer, :class:`set` och :class:"
"`frozenset`. Typen :class:`set` är mutabel --- innehållet kan ändras med "
"hjälp av metoder som :meth:`~set.add` och :meth:`~set.remove`.  Eftersom den "
"är föränderlig har den inget hashvärde och kan inte användas som vare sig "
"nyckel i en ordbok eller som element i en annan uppsättning.  Typen :class:"
"`frozenset` är oföränderlig och :term:`hashable` --- dess innehåll kan inte "
"ändras efter att den skapats; den kan därför användas som en ordboksnyckel "
"eller som ett element i en annan uppsättning."

#: ../../library/stdtypes.rst:4653
msgid ""
"Non-empty sets (not frozensets) can be created by placing a comma-separated "
"list of elements within braces, for example: ``{'jack', 'sjoerd'}``, in "
"addition to the :class:`set` constructor."
msgstr ""
"Icke-tomma mängder (inte frozensets) kan skapas genom att placera en "
"kommaseparerad lista med element inom hakparenteser, till exempel: "
"``{'jack', 'sjoerd'}``, utöver konstruktören :class:`set`."

#: ../../library/stdtypes.rst:4657
msgid "The constructors for both classes work the same:"
msgstr "Konstruktörerna för båda klasserna fungerar på samma sätt:"

#: ../../library/stdtypes.rst:4662
msgid ""
"Return a new set or frozenset object whose elements are taken from "
"*iterable*.  The elements of a set must be :term:`hashable`.  To represent "
"sets of sets, the inner sets must be :class:`frozenset` objects.  If "
"*iterable* is not specified, a new empty set is returned."
msgstr ""
"Returnerar ett nytt set eller frozenset-objekt vars element är hämtade från "
"*iterable*.  Elementen i en uppsättning måste vara :term:`hashable`.  För "
"att representera mängder av mängder måste de inre mängderna vara :class:"
"`frozenset`-objekt.  Om *iterable* inte anges returneras en ny tom "
"uppsättning."

#: ../../library/stdtypes.rst:4668
msgid "Sets can be created by several means:"
msgstr "Uppsättningar kan skapas på flera sätt:"

#: ../../library/stdtypes.rst:4670
msgid ""
"Use a comma-separated list of elements within braces: ``{'jack', 'sjoerd'}``"
msgstr ""
"Använd en kommaseparerad lista med element inom hakparenteser: ``{'jack', "
"'sjoerd'}``"

#: ../../library/stdtypes.rst:4671
msgid ""
"Use a set comprehension: ``{c for c in 'abracadabra' if c not in 'abc'}``"
msgstr ""
"Använd en set-förståelse: ``{c för c i 'abracadabra' om c inte finns i 'abc'}"
"``"

#: ../../library/stdtypes.rst:4672
msgid ""
"Use the type constructor: ``set()``, ``set('foobar')``, ``set(['a', 'b', "
"'foo'])``"
msgstr ""
"Använd typkonstruktören: ``set()``, ``set('foobar')``, ``set(['a', 'b', "
"'foo'])``"

#: ../../library/stdtypes.rst:4674
msgid ""
"Instances of :class:`set` and :class:`frozenset` provide the following "
"operations:"
msgstr ""
"Instanser av :class:`set` och :class:`frozenset` tillhandahåller följande "
"operationer:"

#: ../../library/stdtypes.rst:4679
msgid "Return the number of elements in set *s* (cardinality of *s*)."
msgstr "Returnera antalet element i uppsättningen *s* (kardinalitet för *s*)."

#: ../../library/stdtypes.rst:4683
msgid "Test *x* for membership in *s*."
msgstr "Testa *x* för medlemskap i *s*."

#: ../../library/stdtypes.rst:4687
msgid "Test *x* for non-membership in *s*."
msgstr "Testa *x* för icke-medlemskap i *s*."

#: ../../library/stdtypes.rst:4691
msgid ""
"Return ``True`` if the set has no elements in common with *other*.  Sets are "
"disjoint if and only if their intersection is the empty set."
msgstr ""
"Returnerar ``True`` om mängden inte har några element gemensamma med "
"*andra*.  Mängder är disjunkta om och endast om deras intersektion är den "
"tomma mängden."

#: ../../library/stdtypes.rst:4697
msgid "Test whether every element in the set is in *other*."
msgstr "Testa om varje element i uppsättningen finns i *other*."

#: ../../library/stdtypes.rst:4701
msgid ""
"Test whether the set is a proper subset of *other*, that is, ``set <= other "
"and set != other``."
msgstr ""
"Testa om mängden är en korrekt delmängd av *annan*, dvs. ``mängd <= annan "
"och mängd != annan``."

#: ../../library/stdtypes.rst:4707
msgid "Test whether every element in *other* is in the set."
msgstr "Testa om alla element i *other* finns med i uppsättningen."

#: ../../library/stdtypes.rst:4711
msgid ""
"Test whether the set is a proper superset of *other*, that is, ``set >= "
"other and set != other``."
msgstr ""
"Testa om mängden är en korrekt övermängd av *annan*, det vill säga ``mängd "
">= annan och mängd != annan``."

#: ../../library/stdtypes.rst:4717
msgid "Return a new set with elements from the set and all others."
msgstr ""
"Returnera en ny uppsättning med element från uppsättningen och alla andra."

#: ../../library/stdtypes.rst:4722
msgid "Return a new set with elements common to the set and all others."
msgstr ""
"Returnerar en ny uppsättning med element som är gemensamma för uppsättningen "
"och alla andra."

#: ../../library/stdtypes.rst:4727
msgid "Return a new set with elements in the set that are not in the others."
msgstr ""
"Returnera en ny uppsättning med element i uppsättningen som inte finns i de "
"andra."

#: ../../library/stdtypes.rst:4732
msgid ""
"Return a new set with elements in either the set or *other* but not both."
msgstr ""
"Returnerar en ny uppsättning med element i antingen uppsättningen eller "
"*annan* men inte båda."

#: ../../library/stdtypes.rst:4736
msgid "Return a shallow copy of the set."
msgstr "Returnerar en ytlig kopia av uppsättningen."

#: ../../library/stdtypes.rst:4739
msgid ""
"Note, the non-operator versions of :meth:`union`, :meth:`intersection`, :"
"meth:`difference`, :meth:`symmetric_difference`, :meth:`issubset`, and :meth:"
"`issuperset` methods will accept any iterable as an argument.  In contrast, "
"their operator based counterparts require their arguments to be sets.  This "
"precludes error-prone constructions like ``set('abc') & 'cbs'`` in favor of "
"the more readable ``set('abc').intersection('cbs')``."
msgstr ""
"Observera att icke-operatorversionerna av metoderna :meth:`union`, :meth:"
"`intersection`, :meth:`difference`, :meth:`symmetric_difference`, :meth:"
"`issubset` och :meth:`issuperset` accepterar vilken iterabel som helst som "
"argument.  Däremot kräver deras operatorbaserade motsvarigheter att deras "
"argument är mängder.  Detta utesluter felbenägna konstruktioner som "
"``set('abc') & 'cbs'`` till förmån för det mer läsbara ``set('abc')."
"intersection('cbs')``."

#: ../../library/stdtypes.rst:4746
msgid ""
"Both :class:`set` and :class:`frozenset` support set to set comparisons. Two "
"sets are equal if and only if every element of each set is contained in the "
"other (each is a subset of the other). A set is less than another set if and "
"only if the first set is a proper subset of the second set (is a subset, but "
"is not equal). A set is greater than another set if and only if the first "
"set is a proper superset of the second set (is a superset, but is not equal)."
msgstr ""
"Både :class:`set` och :class:`frozenset` stöder jämförelser mellan mängder. "
"Två mängder är lika om och endast om varje element i varje mängd ingår i den "
"andra (varje mängd är en delmängd av den andra). En mängd är mindre än en "
"annan mängd om och endast om den första mängden är en riktig delmängd av den "
"andra mängden (är en delmängd, men inte lika). En mängd är större än en "
"annan mängd om och endast om den första mängden är en korrekt övermängd av "
"den andra mängden (är en övermängd, men inte lika)."

#: ../../library/stdtypes.rst:4753
msgid ""
"Instances of :class:`set` are compared to instances of :class:`frozenset` "
"based on their members.  For example, ``set('abc') == frozenset('abc')`` "
"returns ``True`` and so does ``set('abc') in set([frozenset('abc')])``."
msgstr ""
"Instanser av :class:`set` jämförs med instanser av :class:`frozenset` "
"baserat på deras medlemmar.  Till exempel returnerar ``set('abc') == "
"frozenset('abc')`` ``True`` och det gör även ``set('abc') in "
"set([frozenset('abc')])``."

#: ../../library/stdtypes.rst:4757
msgid ""
"The subset and equality comparisons do not generalize to a total ordering "
"function.  For example, any two nonempty disjoint sets are not equal and are "
"not subsets of each other, so *all* of the following return ``False``: "
"``a<b``, ``a==b``, or ``a>b``."
msgstr ""
"Jämförelserna mellan delmängder och likheter kan inte generaliseras till en "
"total ordningsfunktion.  Till exempel, två icke-tomma disjunkta mängder är "
"inte lika och är inte delmängder av varandra, så *alla* av följande "
"returnerar ``False``: ``a<b``, ``a==b``, eller ``a>b``."

#: ../../library/stdtypes.rst:4762
msgid ""
"Since sets only define partial ordering (subset relationships), the output "
"of the :meth:`list.sort` method is undefined for lists of sets."
msgstr ""
"Eftersom mängder endast definierar partiell ordning (relationer mellan "
"delmängder) är resultatet av metoden :meth:`list.sort` odefinierat för "
"listor med mängder."

#: ../../library/stdtypes.rst:4765
msgid "Set elements, like dictionary keys, must be :term:`hashable`."
msgstr ""
"Set-element måste, precis som nycklar i ordböcker, vara :term:`hashable`."

#: ../../library/stdtypes.rst:4767
msgid ""
"Binary operations that mix :class:`set` instances with :class:`frozenset` "
"return the type of the first operand.  For example: ``frozenset('ab') | "
"set('bc')`` returns an instance of :class:`frozenset`."
msgstr ""
"Binära operationer som blandar :class:`set`-instanser med :class:`frozenset` "
"returnerar typen av den första operanden.  Till exempel: ```frozenset('ab') "
"| set('bc')`` returnerar en instans av :class:`frozenset`."

#: ../../library/stdtypes.rst:4771
msgid ""
"The following table lists operations available for :class:`set` that do not "
"apply to immutable instances of :class:`frozenset`:"
msgstr ""
"Följande tabell listar operationer som är tillgängliga för :class:`set` och "
"som inte gäller för oföränderliga instanser av :class:`frozenset`:"

#: ../../library/stdtypes.rst:4777
msgid "Update the set, adding elements from all others."
msgstr "Uppdatera uppsättningen genom att lägga till element från alla andra."

#: ../../library/stdtypes.rst:4782
msgid "Update the set, keeping only elements found in it and all others."
msgstr ""
"Uppdatera uppsättningen och behåll endast de element som finns i den och "
"alla andra."

#: ../../library/stdtypes.rst:4787
msgid "Update the set, removing elements found in others."
msgstr "Uppdatera uppsättningen och ta bort element som finns i andra."

#: ../../library/stdtypes.rst:4792
msgid ""
"Update the set, keeping only elements found in either set, but not in both."
msgstr ""
"Uppdatera uppsättningen och behåll endast element som finns i endera "
"uppsättningen, men inte i båda."

#: ../../library/stdtypes.rst:4796
msgid "Add element *elem* to the set."
msgstr "Lägg till element *elem* i uppsättningen."

#: ../../library/stdtypes.rst:4800
msgid ""
"Remove element *elem* from the set.  Raises :exc:`KeyError` if *elem* is not "
"contained in the set."
msgstr ""
"Tar bort elementet *elem* från uppsättningen.  Utlöser :exc:`KeyError` om "
"*elem* inte finns med i uppsättningen."

#: ../../library/stdtypes.rst:4805
msgid "Remove element *elem* from the set if it is present."
msgstr "Ta bort elementet *elem* från uppsättningen om det finns där."

#: ../../library/stdtypes.rst:4809
msgid ""
"Remove and return an arbitrary element from the set.  Raises :exc:`KeyError` "
"if the set is empty."
msgstr ""
"Tar bort och returnerar ett godtyckligt element från uppsättningen.  "
"Utlöser :exc:`KeyError` om uppsättningen är tom."

#: ../../library/stdtypes.rst:4814
msgid "Remove all elements from the set."
msgstr "Ta bort alla element från uppsättningen."

#: ../../library/stdtypes.rst:4817
msgid ""
"Note, the non-operator versions of the :meth:`update`, :meth:"
"`intersection_update`, :meth:`difference_update`, and :meth:"
"`symmetric_difference_update` methods will accept any iterable as an "
"argument."
msgstr ""
"Observera att de icke-operatoriska versionerna av metoderna :meth:`update`, :"
"meth:`intersection_update`, :meth:`difference_update` och :meth:"
"`symmetric_difference_update` accepterar vilken iterabel som helst som "
"argument."

#: ../../library/stdtypes.rst:4822
msgid ""
"Note, the *elem* argument to the :meth:`~object.__contains__`, :meth:"
"`remove`, and :meth:`discard` methods may be a set.  To support searching "
"for an equivalent frozenset, a temporary one is created from *elem*."
msgstr ""
"Observera att argumentet *elem* till metoderna :meth:`~object."
"__contains__`, :meth:`remove` och :meth:`discard` kan vara en uppsättning.  "
"För att underlätta sökningen efter en motsvarande frozenset skapas en "
"tillfällig sådan från *elem*."

#: ../../library/stdtypes.rst:4831
msgid "Mapping Types --- :class:`dict`"
msgstr "Mappningstyper --- :class:`dict`"

#: ../../library/stdtypes.rst:4841
msgid ""
"A :term:`mapping` object maps :term:`hashable` values to arbitrary objects. "
"Mappings are mutable objects.  There is currently only one standard mapping "
"type, the :dfn:`dictionary`.  (For other containers see the built-in :class:"
"`list`, :class:`set`, and :class:`tuple` classes, and the :mod:`collections` "
"module.)"
msgstr ""
"Ett :term:`mapping`-objekt mappar :term:`hashable`-värden till godtyckliga "
"objekt. Mappningar är muterbara objekt.  Det finns för närvarande bara en "
"standardmappningstyp, :dfn:`dictionary`.  (För andra behållare se de "
"inbyggda klasserna :class:`list`, :class:`set` och :class:`tuple` samt "
"modulen :mod:`collections`)"

#: ../../library/stdtypes.rst:4847
msgid ""
"A dictionary's keys are *almost* arbitrary values.  Values that are not :"
"term:`hashable`, that is, values containing lists, dictionaries or other "
"mutable types (that are compared by value rather than by object identity) "
"may not be used as keys. Values that compare equal (such as ``1``, ``1.0``, "
"and ``True``) can be used interchangeably to index the same dictionary entry."
msgstr ""
"En dictionaries nycklar är *nästan* godtyckliga värden.  Värden som inte är :"
"term:`hashable`, det vill säga värden som innehåller listor, dictionaries "
"eller andra föränderliga typer (som jämförs med värde snarare än med "
"objektidentitet) får inte användas som nycklar. Värden som jämför lika (t."
"ex. ``1``, ``1.0`` och ``True``) kan användas omväxlande för att indexera "
"samma ordbokspost."

#: ../../library/stdtypes.rst:4858
msgid ""
"Return a new dictionary initialized from an optional positional argument and "
"a possibly empty set of keyword arguments."
msgstr ""
"Returnerar en ny ordbok som initierats från ett valfritt positionsargument "
"och en eventuellt tom uppsättning nyckelordsargument."

#: ../../library/stdtypes.rst:4861
msgid "Dictionaries can be created by several means:"
msgstr "Ordböcker kan skapas på flera olika sätt:"

#: ../../library/stdtypes.rst:4863
msgid ""
"Use a comma-separated list of ``key: value`` pairs within braces: ``{'jack': "
"4098, 'sjoerd': 4127}`` or ``{4098: 'jack', 4127: 'sjoerd'}``"
msgstr ""
"Använd en kommaseparerad lista med ``nyckel: värde``-par inom hakparenteser: "
"``{'jack': 4098, 'sjoerd': 4127}`` eller ``{4098: 'jack', 4127: 'sjoerd'}``"

#: ../../library/stdtypes.rst:4865
msgid "Use a dict comprehension: ``{}``, ``{x: x ** 2 for x in range(10)}``"
msgstr "Använd en dict-förståelse: ``{}``, ``{x: x ** 2 for x in range(10)}``"

#: ../../library/stdtypes.rst:4866
msgid ""
"Use the type constructor: ``dict()``, ``dict([('foo', 100), ('bar', "
"200)])``, ``dict(foo=100, bar=200)``"
msgstr ""
"Använd typkonstruktören: ``dict()``, ``dict([('foo', 100), ('bar', 200)])``, "
"``dict(foo=100, bar=200)``"

#: ../../library/stdtypes.rst:4869
msgid ""
"If no positional argument is given, an empty dictionary is created. If a "
"positional argument is given and it defines a ``keys()`` method, a "
"dictionary is created by calling :meth:`~object.__getitem__` on the argument "
"with each returned key from the method.  Otherwise, the positional argument "
"must be an :term:`iterable` object.  Each item in the iterable must itself "
"be an iterable with exactly two elements.  The first element of each item "
"becomes a key in the new dictionary, and the second element the "
"corresponding value.  If a key occurs more than once, the last value for "
"that key becomes the corresponding value in the new dictionary."
msgstr ""
"Om inget positionsargument anges skapas en tom ordbok. Om ett "
"positionsargument anges och det definierar en ``keys()``-metod, skapas en "
"ordbok genom att anropa :meth:`~object.__getitem__` på argumentet med varje "
"nyckel som returneras från metoden.  Annars måste det positionella "
"argumentet vara ett :term:`iterable`-objekt.  Varje objekt i iterabeln måste "
"själv vara en iterabel med exakt två element.  Det första elementet i varje "
"objekt blir en nyckel i den nya ordboken och det andra elementet blir "
"motsvarande värde.  Om en nyckel förekommer mer än en gång blir det sista "
"värdet för den nyckeln motsvarande värde i den nya ordboken."

#: ../../library/stdtypes.rst:4879
msgid ""
"If keyword arguments are given, the keyword arguments and their values are "
"added to the dictionary created from the positional argument.  If a key "
"being added is already present, the value from the keyword argument replaces "
"the value from the positional argument."
msgstr ""
"Om nyckelordsargument anges läggs nyckelordsargumenten och deras värden till "
"i den ordbok som skapats utifrån positionsargumentet.  Om en nyckel som "
"läggs till redan finns, ersätter värdet från nyckelordsargumentet värdet "
"från positionsargumentet."

#: ../../library/stdtypes.rst:4884 ../../library/stdtypes.rst:4902
msgid ""
"Providing keyword arguments as in the first example only works for keys that "
"are valid Python identifiers.  Otherwise, any valid keys can be used."
msgstr ""
"Att ange nyckelordsargument som i det första exemplet fungerar bara för "
"nycklar som är giltiga Python-identifierare.  Annars kan alla giltiga "
"nycklar användas."

#: ../../library/stdtypes.rst:4887
msgid ""
"Dictionaries compare equal if and only if they have the same ``(key, "
"value)`` pairs (regardless of ordering). Order comparisons ('<', '<=', '>=', "
"'>') raise :exc:`TypeError`.  To illustrate dictionary creation and "
"equality, the following examples all return a dictionary equal to "
"``{\"one\": 1, \"two\": 2, \"three\": 3}``::"
msgstr ""
"Dictionaries jämförs lika om och endast om de har samma ``(nyckel, värde)``-"
"par (oavsett ordning). Orderjämförelser ('<', '<=', '>=', '>') ger upphov "
"till :exc:`TypeError`.  För att illustrera skapande av ordlistor och likhet "
"returnerar följande exempel alla en ordlista som är lika med ``{\"one\": 1, "
"\"two\": 2, \"three\": 3}``::"

#: ../../library/stdtypes.rst:4893
msgid ""
">>> a = dict(one=1, two=2, three=3)\n"
">>> b = {'one': 1, 'two': 2, 'three': 3}\n"
">>> c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))\n"
">>> d = dict([('two', 2), ('one', 1), ('three', 3)])\n"
">>> e = dict({'three': 3, 'one': 1, 'two': 2})\n"
">>> f = dict({'one': 1, 'three': 3}, two=2)\n"
">>> a == b == c == d == e == f\n"
"True"
msgstr ""
">>> a = dict(ett=1, två=2, tre=3)\n"
">>> b = {'ett': 1, 'två': 2, 'tre': 3}\n"
">>> c = dict(zip(['ett', 'två', 'tre'], [1, 2, 3]))\n"
">>> d = dict([('two', 2), ('one', 1), ('three', 3)])\n"
">>> e = dict({'tre': 3, 'ett': 1, 'två': 2})\n"
">>> f = dict({'ett': 1, 'tre': 3}, två=2)\n"
">>> a == b == c == d == e == f\n"
"Sant"

#: ../../library/stdtypes.rst:4905
msgid ""
"Dictionaries preserve insertion order.  Note that updating a key does not "
"affect the order.  Keys added after deletion are inserted at the end. ::"
msgstr ""
"Ordböcker bevarar inmatningsordningen.  Observera att uppdatering av en "
"nyckel inte påverkar ordningen.  Nycklar som läggs till efter radering "
"infogas i slutet. ::"

#: ../../library/stdtypes.rst:4908
msgid ""
">>> d = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4}\n"
">>> d\n"
"{'one': 1, 'two': 2, 'three': 3, 'four': 4}\n"
">>> list(d)\n"
"['one', 'two', 'three', 'four']\n"
">>> list(d.values())\n"
"[1, 2, 3, 4]\n"
">>> d[\"one\"] = 42\n"
">>> d\n"
"{'one': 42, 'two': 2, 'three': 3, 'four': 4}\n"
">>> del d[\"two\"]\n"
">>> d[\"two\"] = None\n"
">>> d\n"
"{'one': 42, 'three': 3, 'four': 4, 'two': None}"
msgstr ""
">>> d = {\"ett\": 1, \"två\": 2, \"tre\": 3, \"fyra\": 4}\n"
">>> d\n"
"{\"ett\": 1, \"två\": 2, \"tre\": 3, 'four': 4}\n"
">>> list(d)\n"
"['ett', 'två', 'tre', 'fyra']\n"
">>> list(d.värden())\n"
"[1, 2, 3, 4]\n"
">>> d[\"ett\"] = 42\n"
">>> d\n"
"{\"ett\": 42, \"två\": 2, \"tre\": 3, 'fyra': 4}\n"
">>> del d[\"två\"]\n"
">>> d[\"två\"] = Ingen\n"
">>> d\n"
"{\"ett\": 42, \"tre\": 3, 'fyra': 4, 'two': None}"

#: ../../library/stdtypes.rst:4923
msgid ""
"Dictionary order is guaranteed to be insertion order.  This behavior was an "
"implementation detail of CPython from 3.6."
msgstr ""
"Ordningsföljden i ordboken är garanterad att vara insättningsordning.  Detta "
"beteende var en implementationsdetalj i CPython från 3.6."

#: ../../library/stdtypes.rst:4927
msgid ""
"These are the operations that dictionaries support (and therefore, custom "
"mapping types should support too):"
msgstr ""
"Det här är de operationer som ordböcker stöder (och därför bör anpassade "
"mappningstyper också stödja):"

#: ../../library/stdtypes.rst:4932
msgid "Return a list of all the keys used in the dictionary *d*."
msgstr "Returnerar en lista med alla nycklar som används i ordlistan *d*."

#: ../../library/stdtypes.rst:4936
msgid "Return the number of items in the dictionary *d*."
msgstr "Returnerar antalet objekt i ordlistan *d*."

#: ../../library/stdtypes.rst:4940
msgid ""
"Return the item of *d* with key *key*.  Raises a :exc:`KeyError` if *key* is "
"not in the map."
msgstr ""
"Returnerar objektet i *d* med nyckel *key*.  Utlöser ett :exc:`KeyError` om "
"*nyckel* inte finns i kartan."

#: ../../library/stdtypes.rst:4945
msgid ""
"If a subclass of dict defines a method :meth:`__missing__` and *key* is not "
"present, the ``d[key]`` operation calls that method with the key *key* as "
"argument.  The ``d[key]`` operation then returns or raises whatever is "
"returned or raised by the ``__missing__(key)`` call. No other operations or "
"methods invoke :meth:`__missing__`. If :meth:`__missing__` is not defined, :"
"exc:`KeyError` is raised. :meth:`__missing__` must be a method; it cannot be "
"an instance variable::"
msgstr ""
"Om en subklass av dict definierar en metod :meth:`__missing__` och *key* "
"inte finns, anropar operationen ``d[key]`` den metoden med nyckeln *key* som "
"argument.  Operationen ``d[key]`` returnerar eller väcker sedan det som "
"returneras eller väcks av anropet ``__missing__(key)``. Inga andra "
"operationer eller metoder anropar :meth:`__missing__`. Om :meth:"
"`__missing__` inte är definierad, uppstår :exc:`KeyError`. :meth:"
"`__missing__` måste vara en metod; den kan inte vara en instansvariabel::"

#: ../../library/stdtypes.rst:4953
msgid ""
">>> class Counter(dict):\n"
"...     def __missing__(self, key):\n"
"...         return 0\n"
"...\n"
">>> c = Counter()\n"
">>> c['red']\n"
"0\n"
">>> c['red'] += 1\n"
">>> c['red']\n"
"1"
msgstr ""
">>> klass Counter(dict):\n"
"... def __missing__(self, key):\n"
"... return 0\n"
"...\n"
">>> c = Räknare()\n"
">>> c['röd']\n"
"0\n"
">>> c['röd'] += 1\n"
">>> c['röd']\n"
"1"

#: ../../library/stdtypes.rst:4964
msgid ""
"The example above shows part of the implementation of :class:`collections."
"Counter`.  A different ``__missing__`` method is used by :class:`collections."
"defaultdict`."
msgstr ""
"Exemplet ovan visar en del av implementationen av :class:`collections."
"Counter`.  En annan ``__missing__`` metod används av :class:`collections."
"defaultdict`."

#: ../../library/stdtypes.rst:4970
msgid "Set ``d[key]`` to *value*."
msgstr "Sätt ``d[key]`` till *värde*."

#: ../../library/stdtypes.rst:4974
msgid ""
"Remove ``d[key]`` from *d*.  Raises a :exc:`KeyError` if *key* is not in the "
"map."
msgstr ""
"Tar bort ``d[nyckel]`` från *d*.  Utlöser ett :exc:`KeyError` om *key* inte "
"finns i kartan."

#: ../../library/stdtypes.rst:4979
msgid "Return ``True`` if *d* has a key *key*, else ``False``."
msgstr "Returnerar ``True`` om *d* har en nyckel *key*, annars ``False``."

#: ../../library/stdtypes.rst:4983
msgid "Equivalent to ``not key in d``."
msgstr "Motsvarar ``inte nyckel i d``."

#: ../../library/stdtypes.rst:4987
msgid ""
"Return an iterator over the keys of the dictionary.  This is a shortcut for "
"``iter(d.keys())``."
msgstr ""
"Returnerar en iterator över nycklarna i ordlistan.  Detta är en genväg till "
"``iter(d.keys())``."

#: ../../library/stdtypes.rst:4992
msgid "Remove all items from the dictionary."
msgstr "Ta bort alla objekt från ordlistan."

#: ../../library/stdtypes.rst:4996
msgid "Return a shallow copy of the dictionary."
msgstr "Returnerar en ytlig kopia av ordlistan."

#: ../../library/stdtypes.rst:5000
msgid ""
"Create a new dictionary with keys from *iterable* and values set to *value*."
msgstr ""
"Skapa en ny ordbok med nycklar från *iterable* och värden satta till *value*."

#: ../../library/stdtypes.rst:5002
msgid ""
":meth:`fromkeys` is a class method that returns a new dictionary. *value* "
"defaults to ``None``.  All of the values refer to just a single instance, so "
"it generally doesn't make sense for *value* to be a mutable object such as "
"an empty list.  To get distinct values, use a :ref:`dict comprehension "
"<dict>` instead."
msgstr ""
":meth:`fromkeys` är en klassmetod som returnerar en ny ordbok. *value* är "
"som standard ``None``.  Alla värden hänvisar bara till en enda instans, så "
"det är i allmänhet inte meningsfullt att *värde* är ett föränderligt objekt, "
"t.ex. en tom lista.  För att få distinkta värden, använd en :ref:`dict "
"comprehension <dict>` istället."

#: ../../library/stdtypes.rst:5010
msgid ""
"Return the value for *key* if *key* is in the dictionary, else *default*. If "
"*default* is not given, it defaults to ``None``, so that this method never "
"raises a :exc:`KeyError`."
msgstr ""
"Returnerar värdet för *key* om *key* finns i ordlistan, annars *default*. Om "
"*default* inte anges är standardvärdet ``None``, så att den här metoden "
"aldrig ger upphov till ett :exc:`KeyError`."

#: ../../library/stdtypes.rst:5016
msgid ""
"Return a new view of the dictionary's items (``(key, value)`` pairs). See "
"the :ref:`documentation of view objects <dict-views>`."
msgstr ""
"Returnerar en ny vy av ordbokens objekt (``(nyckel, värde)``-par). Se :ref:"
"`dokumentation av view-objekt <dict-views>`."

#: ../../library/stdtypes.rst:5021
msgid ""
"Return a new view of the dictionary's keys.  See the :ref:`documentation of "
"view objects <dict-views>`."
msgstr ""
"Returnerar en ny vy av nycklarna i ordlistan.  Se :ref:`dokumentation av "
"view-objekt <dict-views>`."

#: ../../library/stdtypes.rst:5026
msgid ""
"If *key* is in the dictionary, remove it and return its value, else return "
"*default*.  If *default* is not given and *key* is not in the dictionary, a :"
"exc:`KeyError` is raised."
msgstr ""
"Om *key* finns i ordlistan, ta bort den och returnera dess värde, annars "
"returneras *default*.  Om *default* inte anges och *key* inte finns i "
"ordlistan, uppstår ett :exc:`KeyError`."

#: ../../library/stdtypes.rst:5032
msgid ""
"Remove and return a ``(key, value)`` pair from the dictionary. Pairs are "
"returned in :abbr:`LIFO (last-in, first-out)` order."
msgstr ""
"Tar bort och returnerar ett ``(nyckel, värde)``-par från ordlistan. Paren "
"returneras i :abbr:`LIFO (sist in, först ut)`-ordning."

#: ../../library/stdtypes.rst:5035
msgid ""
":meth:`popitem` is useful to destructively iterate over a dictionary, as "
"often used in set algorithms.  If the dictionary is empty, calling :meth:"
"`popitem` raises a :exc:`KeyError`."
msgstr ""
":meth:`popitem` är användbart för att destruktivt iterera över en ordbok, "
"vilket ofta används i set-algoritmer.  Om ordlistan är tom ger anrop av :"
"meth:`popitem` upphov till ett :exc:`KeyError`."

#: ../../library/stdtypes.rst:5039
msgid ""
"LIFO order is now guaranteed. In prior versions, :meth:`popitem` would "
"return an arbitrary key/value pair."
msgstr ""
"LIFO-ordning är nu garanterad. I tidigare versioner kunde :meth:`popitem` "
"returnera ett godtyckligt nyckel/värde-par."

#: ../../library/stdtypes.rst:5045
msgid ""
"Return a reverse iterator over the keys of the dictionary. This is a "
"shortcut for ``reversed(d.keys())``."
msgstr ""
"Returnerar en omvänd iterator över nycklarna i ordlistan. Detta är en genväg "
"till ``reversed(d.keys())``."

#: ../../library/stdtypes.rst:5052
msgid ""
"If *key* is in the dictionary, return its value.  If not, insert *key* with "
"a value of *default* and return *default*.  *default* defaults to ``None``."
msgstr ""
"Om *key* finns i ordlistan returneras dess värde.  Om inte, infoga *key* med "
"ett värde av *default* och returnera *default*.  *default* är som standard "
"``None``."

#: ../../library/stdtypes.rst:5058
msgid ""
"Update the dictionary with the key/value pairs from *other*, overwriting "
"existing keys.  Return ``None``."
msgstr ""
"Uppdaterar ordlistan med nyckel/värde-paren från *other* och skriver över "
"befintliga nycklar.  Returnerar ``None``."

#: ../../library/stdtypes.rst:5061
msgid ""
":meth:`update` accepts either another object with a ``keys()`` method (in "
"which case :meth:`~object.__getitem__` is called with every key returned "
"from the method) or an iterable of key/value pairs (as tuples or other "
"iterables of length two). If keyword arguments are specified, the dictionary "
"is then updated with those key/value pairs: ``d.update(red=1, blue=2)``."
msgstr ""
":meth:`update` accepterar antingen ett annat objekt med en ``keys()``-metod "
"(i vilket fall :meth:`~object.__getitem__` anropas med varje nyckel som "
"returneras från metoden) eller en iterabel med nyckel/värde-par (som tupler "
"eller andra iterabler av längd två). Om nyckelordsargument anges uppdateras "
"sedan ordlistan med dessa nyckel/värde-par: ``d.update(red=1, blue=2)``."

#: ../../library/stdtypes.rst:5069
msgid ""
"Return a new view of the dictionary's values.  See the :ref:`documentation "
"of view objects <dict-views>`."
msgstr ""
"Returnerar en ny vy av ordbokens värden.  Se :ref:`dokumentation av view-"
"objekt <dict-views>`."

#: ../../library/stdtypes.rst:5072
msgid ""
"An equality comparison between one ``dict.values()`` view and another will "
"always return ``False``. This also applies when comparing ``dict.values()`` "
"to itself::"
msgstr ""
"En jämlikhetsjämförelse mellan en ``dict.values()`` vy och en annan kommer "
"alltid att returnera ``False``. Detta gäller även när man jämför ``dict."
"values()`` med sig själv::"

#: ../../library/stdtypes.rst:5076
msgid ""
">>> d = {'a': 1}\n"
">>> d.values() == d.values()\n"
"False"
msgstr ""
">>> d = {'a': 1}\n"
">>> d.värden() == d.värden()\n"
"Falskt"

#: ../../library/stdtypes.rst:5082
msgid ""
"Create a new dictionary with the merged keys and values of *d* and *other*, "
"which must both be dictionaries. The values of *other* take priority when "
"*d* and *other* share keys."
msgstr ""
"Skapa en ny ordbok med de sammanslagna nycklarna och värdena i *d* och "
"*other*, som båda måste vara ordböcker. Värdena i *other* prioriteras när "
"*d* och *other* delar nycklar."

#: ../../library/stdtypes.rst:5090
msgid ""
"Update the dictionary *d* with keys and values from *other*, which may be "
"either a :term:`mapping` or an :term:`iterable` of key/value pairs. The "
"values of *other* take priority when *d* and *other* share keys."
msgstr ""
"Uppdaterar ordlistan *d* med nycklar och värden från *other*, som kan vara "
"antingen en :term:`mappning` eller en :term:`iterabel` av nyckel/värde-par. "
"Värdena i *other* prioriteras när *d* och *other* delar nycklar."

#: ../../library/stdtypes.rst:5096
msgid "Dictionaries and dictionary views are reversible. ::"
msgstr "Ordböcker och ordboksvyer är reversibla ::"

#: ../../library/stdtypes.rst:5098
msgid ""
">>> d = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4}\n"
">>> d\n"
"{'one': 1, 'two': 2, 'three': 3, 'four': 4}\n"
">>> list(reversed(d))\n"
"['four', 'three', 'two', 'one']\n"
">>> list(reversed(d.values()))\n"
"[4, 3, 2, 1]\n"
">>> list(reversed(d.items()))\n"
"[('four', 4), ('three', 3), ('two', 2), ('one', 1)]"
msgstr ""
">>> d = {\"ett\": 1, \"två\": 2, \"tre\": 3, \"fyra\": 4}\n"
">>> d\n"
"{\"ett\": 1, \"två\": 2, \"tre\": 3, 'four': 4}\n"
">>> list(reversed(d))\n"
"['fyra', 'tre', 'två', 'ett']\n"
">>> list(reversed(d.values())))\n"
"[4, 3, 2, 1]\n"
">>> list(reversed(d.items()))\n"
"[('fyra', 4), ('tre', 3), ('två', 2), ('ett', 1)]"

#: ../../library/stdtypes.rst:5108
msgid "Dictionaries are now reversible."
msgstr "Ordböcker är nu reversibla."

#: ../../library/stdtypes.rst:5113
msgid ""
":class:`types.MappingProxyType` can be used to create a read-only view of a :"
"class:`dict`."
msgstr ""
":class:`types.MappingProxyType` kan användas för att skapa en skrivskyddad "
"vy av en :class:`dict`."

#: ../../library/stdtypes.rst:5120
msgid "Dictionary view objects"
msgstr "Objekt för ordboksvisning"

#: ../../library/stdtypes.rst:5122
msgid ""
"The objects returned by :meth:`dict.keys`, :meth:`dict.values` and :meth:"
"`dict.items` are *view objects*.  They provide a dynamic view on the "
"dictionary's entries, which means that when the dictionary changes, the view "
"reflects these changes."
msgstr ""
"De objekt som returneras av :meth:`dict.keys`, :meth:`dict.values` och :meth:"
"`dict.items` är *vyobjekt*.  De ger en dynamisk vy över ordbokens poster, "
"vilket innebär att när ordboken ändras återspeglas dessa ändringar i vyn."

#: ../../library/stdtypes.rst:5127
msgid ""
"Dictionary views can be iterated over to yield their respective data, and "
"support membership tests:"
msgstr ""
"Dictionary-vyer kan itereras för att få fram sina respektive data och stödja "
"medlemskapstester:"

#: ../../library/stdtypes.rst:5132
msgid "Return the number of entries in the dictionary."
msgstr "Returnerar antalet poster i ordlistan."

#: ../../library/stdtypes.rst:5136
msgid ""
"Return an iterator over the keys, values or items (represented as tuples of "
"``(key, value)``) in the dictionary."
msgstr ""
"Returnerar en iterator över nycklar, värden eller objekt (representerade som "
"tupler av ``(nyckel, värde)``) i ordlistan."

#: ../../library/stdtypes.rst:5139
msgid ""
"Keys and values are iterated over in insertion order. This allows the "
"creation of ``(value, key)`` pairs using :func:`zip`: ``pairs = zip(d."
"values(), d.keys())``.  Another way to create the same list is ``pairs = "
"[(v, k) for (k, v) in d.items()]``."
msgstr ""
"Nycklar och värden itereras över i insättningsordning. Detta gör det möjligt "
"att skapa ``(värde, nyckel)``-par med hjälp av :func:`zip`: ``par = zip(d."
"values(), d.keys())``.  Ett annat sätt att skapa samma lista är ``par = [(v, "
"k) for (k, v) in d.items()]``."

#: ../../library/stdtypes.rst:5144
msgid ""
"Iterating views while adding or deleting entries in the dictionary may raise "
"a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr ""
"Om du itererar vyer medan du lägger till eller tar bort poster i ordlistan "
"kan det leda till ett :exc:`RuntimeError` eller att du inte kan iterera över "
"alla poster."

#: ../../library/stdtypes.rst:5147
msgid "Dictionary order is guaranteed to be insertion order."
msgstr "Ordboksordning är garanterad att vara insättningsordning."

#: ../../library/stdtypes.rst:5152
msgid ""
"Return ``True`` if *x* is in the underlying dictionary's keys, values or "
"items (in the latter case, *x* should be a ``(key, value)`` tuple)."
msgstr ""
"Returnerar ``True`` om *x* finns i den underliggande ordbokens nycklar, "
"värden eller objekt (i det senare fallet bör *x* vara en ``(nyckel, värde)``-"
"tupel)."

#: ../../library/stdtypes.rst:5157
msgid ""
"Return a reverse iterator over the keys, values or items of the dictionary. "
"The view will be iterated in reverse order of the insertion."
msgstr ""
"Returnerar en omvänd iterator över nycklar, värden eller objekt i ordlistan. "
"Vyn kommer att itereras i omvänd ordning efter införandet."

#: ../../library/stdtypes.rst:5160
msgid "Dictionary views are now reversible."
msgstr "Ordboksvyerna är nu reversibla."

#: ../../library/stdtypes.rst:5165
msgid ""
"Return a :class:`types.MappingProxyType` that wraps the original dictionary "
"to which the view refers."
msgstr ""
"Returnerar en :class:`types.MappingProxyType` som omsluter den ursprungliga "
"ordlistan som vyn refererar till."

#: ../../library/stdtypes.rst:5170
msgid ""
"Keys views are set-like since their entries are unique and :term:`hashable`. "
"Items views also have set-like operations since the (key, value) pairs are "
"unique and the keys are hashable. If all values in an items view are "
"hashable as well, then the items view can interoperate with other sets. "
"(Values views are not treated as set-like since the entries are generally "
"not unique.)  For set-like views, all of the operations defined for the "
"abstract base class :class:`collections.abc.Set` are available (for example, "
"``==``, ``<``, or ``^``).  While using set operators, set-like views accept "
"any iterable as the other operand, unlike sets which only accept sets as the "
"input."
msgstr ""
"Keys-vyer är set-liknande eftersom deras poster är unika och :term:"
"`hashable`. Objektvyer har också set-liknande operationer eftersom (nyckel, "
"värde)-paren är unika och nycklarna är hashbara. Om alla värden i en items-"
"vy också är hashbara kan items-vyn samverka med andra set. (Värdevyer "
"behandlas inte som set-liknande eftersom posterna i allmänhet inte är "
"unika)  För set-liknande vyer är alla operationer som definieras för den "
"abstrakta basklassen :class:`collections.abc.Set` tillgängliga (t.ex. "
"``==``, ``<`` eller ``^``).  Vid användning av set-operatorer accepterar set-"
"liknande vyer alla iterabla som den andra operanden, till skillnad från sets "
"som endast accepterar sets som indata."

#: ../../library/stdtypes.rst:5182
msgid "An example of dictionary view usage::"
msgstr "Ett exempel på användning av ordboksvy::"

#: ../../library/stdtypes.rst:5184
msgid ""
">>> dishes = {'eggs': 2, 'sausage': 1, 'bacon': 1, 'spam': 500}\n"
">>> keys = dishes.keys()\n"
">>> values = dishes.values()\n"
"\n"
">>> # iteration\n"
">>> n = 0\n"
">>> for val in values:\n"
"...     n += val\n"
"...\n"
">>> print(n)\n"
"504\n"
"\n"
">>> # keys and values are iterated over in the same order (insertion order)\n"
">>> list(keys)\n"
"['eggs', 'sausage', 'bacon', 'spam']\n"
">>> list(values)\n"
"[2, 1, 1, 500]\n"
"\n"
">>> # view objects are dynamic and reflect dict changes\n"
">>> del dishes['eggs']\n"
">>> del dishes['sausage']\n"
">>> list(keys)\n"
"['bacon', 'spam']\n"
"\n"
">>> # set operations\n"
">>> keys & {'eggs', 'bacon', 'salad'}\n"
"{'bacon'}\n"
">>> keys ^ {'sausage', 'juice'} == {'juice', 'sausage', 'bacon', 'spam'}\n"
"True\n"
">>> keys | ['juice', 'juice', 'juice'] == {'bacon', 'spam', 'juice'}\n"
"True\n"
"\n"
">>> # get back a read-only proxy for the original dictionary\n"
">>> values.mapping\n"
"mappingproxy({'bacon': 1, 'spam': 500})\n"
">>> values.mapping['spam']\n"
"500"
msgstr ""
">>> rätter = {'ägg': 2, 'korv': 1, 'bacon': 1, 'spam': 500}\n"
">>> nycklar = rätter.nycklar()\n"
">>> värden = rätter.värden()\n"
"\n"
">>> # iteration\n"
">>> n = 0\n"
">>> för val i värden:\n"
"... n += val\n"
"...\n"
">>> print(n)\n"
"504\n"
"\n"
">>> # nycklar och värden itereras över i samma ordning (insättningsordning)\n"
">>> list(nycklar)\n"
"['ägg', 'korv', 'bacon', 'spam']\n"
">>> list(värden)\n"
"[2, 1, 1, 500]\n"
"\n"
">>> # visningsobjekt är dynamiska och återspeglar diktatändringar\n"
">>> del rätter['ägg']\n"
">>> del rätter['korv']\n"
">>> list(nycklar)\n"
"['bacon', 'spam']\n"
"\n"
">>> # ställa in operationer\n"
">>> nycklar & {'ägg', 'bacon', 'sallad'}\n"
"{'bacon'}\n"
">>> nycklar ^ {'korv', 'juice'} == {'juice', 'korv', 'bacon', 'spam'}\n"
"Sant\n"
">>> nycklar | ['juice', 'juice', 'juice'] == {'bacon', 'spam', 'juice'}\n"
"Sant\n"
"\n"
">>> # få tillbaka en skrivskyddad proxy för den ursprungliga ordlistan\n"
">>> värden.mappning\n"
"mappningsproxy({'bacon': 1, 'spam': 500})\n"
">>> värden.mappning['spam']\n"
"500"

#: ../../library/stdtypes.rst:5226
msgid "Context Manager Types"
msgstr "Typer av kontexthanterare"

#: ../../library/stdtypes.rst:5233
msgid ""
"Python's :keyword:`with` statement supports the concept of a runtime context "
"defined by a context manager.  This is implemented using a pair of methods "
"that allow user-defined classes to define a runtime context that is entered "
"before the statement body is executed and exited when the statement ends:"
msgstr ""
"Pythons :keyword:`with`-sats stöder konceptet med en körtidskontext som "
"definieras av en kontexthanterare.  Detta implementeras med hjälp av ett par "
"metoder som gör det möjligt för användardefinierade klasser att definiera en "
"körtidskontext som anges innan satsens kropp exekveras och avslutas när "
"satsen avslutas:"

#: ../../library/stdtypes.rst:5241
msgid ""
"Enter the runtime context and return either this object or another object "
"related to the runtime context. The value returned by this method is bound "
"to the identifier in the :keyword:`!as` clause of :keyword:`with` statements "
"using this context manager."
msgstr ""
"Anger körtidskontexten och returnerar antingen detta objekt eller ett annat "
"objekt som är relaterat till körtidskontexten. Det värde som returneras av "
"denna metod är bundet till identifieraren i :keyword:`!as`-klausulen i :"
"keyword:`with`-satser med hjälp av denna kontexthanterare."

#: ../../library/stdtypes.rst:5246
msgid ""
"An example of a context manager that returns itself is a :term:`file "
"object`. File objects return themselves from __enter__() to allow :func:"
"`open` to be used as the context expression in a :keyword:`with` statement."
msgstr ""
"Ett exempel på en kontexthanterare som returnerar sig själv är ett :term:"
"`file-objekt`. Filobjekt returnerar sig själva från __enter__() så att :func:"
"`open` kan användas som kontextuttryck i en :keyword:`with`-sats."

#: ../../library/stdtypes.rst:5250
msgid ""
"An example of a context manager that returns a related object is the one "
"returned by :func:`decimal.localcontext`. These managers set the active "
"decimal context to a copy of the original decimal context and then return "
"the copy. This allows changes to be made to the current decimal context in "
"the body of the :keyword:`with` statement without affecting code outside "
"the :keyword:`!with` statement."
msgstr ""
"Ett exempel på en kontexthanterare som returnerar ett relaterat objekt är "
"den som returneras av :func:`decimal.localcontext`. Dessa hanterare sätter "
"den aktiva decimalkontexten till en kopia av den ursprungliga "
"decimalkontexten och returnerar sedan kopian. Detta gör att ändringar kan "
"göras i den aktuella decimalkontexten i :keyword:`with`-satsen utan att "
"påverka koden utanför :keyword:`!with`-satsen."

#: ../../library/stdtypes.rst:5260
msgid ""
"Exit the runtime context and return a Boolean flag indicating if any "
"exception that occurred should be suppressed. If an exception occurred while "
"executing the body of the :keyword:`with` statement, the arguments contain "
"the exception type, value and traceback information. Otherwise, all three "
"arguments are ``None``."
msgstr ""
"Avslutar körtidskontexten och returnerar en boolesk flagga som anger om ett "
"eventuellt undantag som inträffat ska undertryckas. Om ett undantag "
"inträffade under exekveringen av :keyword:`with`-satsen, innehåller "
"argumenten undantagstyp, värde och spårningsinformation. Annars är alla tre "
"argumenten ``None``."

#: ../../library/stdtypes.rst:5265
msgid ""
"Returning a true value from this method will cause the :keyword:`with` "
"statement to suppress the exception and continue execution with the "
"statement immediately following the :keyword:`!with` statement. Otherwise "
"the exception continues propagating after this method has finished "
"executing. Exceptions that occur during execution of this method will "
"replace any exception that occurred in the body of the :keyword:`!with` "
"statement."
msgstr ""
"Om ett sant värde returneras från den här metoden kommer :keyword:`with`-"
"satsen att undertrycka undantaget och fortsätta exekveringen med den sats "
"som följer omedelbart efter :keyword:`!with`-satsen. Annars fortsätter "
"undantaget att spridas efter att den här metoden har avslutats. Undantag som "
"inträffar under exekveringen av denna metod kommer att ersätta alla undantag "
"som inträffade i :keyword:`!with`-satsens kropp."

#: ../../library/stdtypes.rst:5272
msgid ""
"The exception passed in should never be reraised explicitly - instead, this "
"method should return a false value to indicate that the method completed "
"successfully and does not want to suppress the raised exception. This allows "
"context management code to easily detect whether or not an :meth:`~object."
"__exit__` method has actually failed."
msgstr ""
"Det undantag som skickas in bör aldrig återställas explicit - i stället bör "
"denna metod returnera ett falskt värde för att ange att metoden slutfördes "
"framgångsrikt och inte vill undertrycka det undantag som återställts. Detta "
"gör det möjligt för kontexthanteringskod att enkelt upptäcka om en :meth:"
"`~object.__exit__`-metod faktiskt har misslyckats eller inte."

#: ../../library/stdtypes.rst:5278
msgid ""
"Python defines several context managers to support easy thread "
"synchronisation, prompt closure of files or other objects, and simpler "
"manipulation of the active decimal arithmetic context. The specific types "
"are not treated specially beyond their implementation of the context "
"management protocol. See the :mod:`contextlib` module for some examples."
msgstr ""
"Python definierar flera kontexthanterare för att stödja enkel "
"trådsynkronisering, snabb stängning av filer eller andra objekt och enklare "
"hantering av den aktiva decimala aritmetiska kontexten. De specifika typerna "
"behandlas inte speciellt utöver deras implementering av "
"kontexthanteringsprotokollet. Se modulen :mod:`contextlib` för några exempel."

#: ../../library/stdtypes.rst:5284
msgid ""
"Python's :term:`generator`\\s and the :class:`contextlib.contextmanager` "
"decorator provide a convenient way to implement these protocols.  If a "
"generator function is decorated with the :class:`contextlib.contextmanager` "
"decorator, it will return a context manager implementing the necessary :meth:"
"`~contextmanager.__enter__` and :meth:`~contextmanager.__exit__` methods, "
"rather than the iterator produced by an undecorated generator function."
msgstr ""
"Pythons :term:`generator` och :class:`contextlib.contextmanager`-dekoratorn "
"ger ett bekvämt sätt att implementera dessa protokoll.  Om en "
"generatorfunktion dekoreras med dekoratorn :class:`contextlib."
"contextmanager` kommer den att returnera en kontexthanterare som "
"implementerar de nödvändiga metoderna :meth:`~contextmanager.__enter__` och :"
"meth:`~contextmanager.__exit__`, snarare än den iterator som produceras av "
"en odekorerad generatorfunktion."

#: ../../library/stdtypes.rst:5291
msgid ""
"Note that there is no specific slot for any of these methods in the type "
"structure for Python objects in the Python/C API. Extension types wanting to "
"define these methods must provide them as a normal Python accessible method. "
"Compared to the overhead of setting up the runtime context, the overhead of "
"a single class dictionary lookup is negligible."
msgstr ""
"Observera att det inte finns någon specifik plats för någon av dessa metoder "
"i typstrukturen för Python-objekt i Python/C API. Tilläggstyper som vill "
"definiera dessa metoder måste tillhandahålla dem som en normal Python-"
"åtkomlig metod. Jämfört med omkostnaderna för att konfigurera "
"körtidskontexten är omkostnaderna för en enda klassordboksuppslagning "
"försumbara."

#: ../../library/stdtypes.rst:5299
msgid ""
"Type Annotation Types --- :ref:`Generic Alias <types-genericalias>`, :ref:"
"`Union <types-union>`"
msgstr ""
"Typ Annotation Types --- :ref:`Generic Alias <types-genericalias>`, :ref:"
"`Union <types-union>`"

#: ../../library/stdtypes.rst:5304
msgid ""
"The core built-in types for :term:`type annotations <annotation>` are :ref:"
"`Generic Alias <types-genericalias>` and :ref:`Union <types-union>`."
msgstr ""
"De inbyggda kärntyperna för :term:`type annotations <annotation>` är :ref:"
"`Generic Alias <types-genericalias>` och :ref:`Union <types-union>`."

#: ../../library/stdtypes.rst:5311
msgid "Generic Alias Type"
msgstr "Generiskt alias Typ"

#: ../../library/stdtypes.rst:5317
msgid ""
"``GenericAlias`` objects are generally created by :ref:`subscripting "
"<subscriptions>` a class. They are most often used with :ref:`container "
"classes <sequence-types>`, such as :class:`list` or :class:`dict`. For "
"example, ``list[int]`` is a ``GenericAlias`` object created by subscripting "
"the ``list`` class with the argument :class:`int`. ``GenericAlias`` objects "
"are intended primarily for use with :term:`type annotations <annotation>`."
msgstr ""
"objekt av typen ``GenericAlias`` skapas i allmänhet genom :ref:`subscripting "
"<subscriptions>` av en klass. De används oftast med :ref:``container classes "
"<sequence-types>`, såsom :class:`list` eller :class:`dict`. Till exempel är "
"``list[int]`` ett ``GenericAlias``-objekt som skapas genom att subskribera "
"klassen ``list`` med argumentet :class:`int`. ``GenericAlias``-objekt är "
"främst avsedda att användas med :term:`type annotations <annotation>`."

#: ../../library/stdtypes.rst:5327
msgid ""
"It is generally only possible to subscript a class if the class implements "
"the special method :meth:`~object.__class_getitem__`."
msgstr ""
"Det är i allmänhet bara möjligt att subskribera en klass om klassen "
"implementerar den speciella metoden :meth:`~object.__class_getitem__`."

#: ../../library/stdtypes.rst:5330
msgid ""
"A ``GenericAlias`` object acts as a proxy for a :term:`generic type`, "
"implementing *parameterized generics*."
msgstr ""
"Ett ``GenericAlias``-objekt fungerar som en proxy för en :term:`generisk "
"typ` och implementerar *parameteriserade generiska typer*."

#: ../../library/stdtypes.rst:5333
msgid ""
"For a container class, the argument(s) supplied to a :ref:`subscription "
"<subscriptions>` of the class may indicate the type(s) of the elements an "
"object contains. For example, ``set[bytes]`` can be used in type annotations "
"to signify a :class:`set` in which all the elements are of type :class:"
"`bytes`."
msgstr ""
"För en containerklass kan det eller de argument som anges i en :ref:"
"`subscription <subscriptions>` av klassen ange typen eller typerna av de "
"element som ett objekt innehåller. Till exempel kan ``set[bytes]`` användas "
"i typannoteringar för att beteckna en :class:`set` där alla element är av "
"typen :class:`bytes`."

#: ../../library/stdtypes.rst:5339
msgid ""
"For a class which defines :meth:`~object.__class_getitem__` but is not a "
"container, the argument(s) supplied to a subscription of the class will "
"often indicate the return type(s) of one or more methods defined on an "
"object. For example, :mod:`regular expressions <re>` can be used on both "
"the :class:`str` data type and the :class:`bytes` data type:"
msgstr ""
"För en klass som definierar :meth:`~object.__class_getitem__` men som inte "
"är en container, kommer argumentet/argumenten till en prenumeration av "
"klassen ofta att ange returtypen/returtyperna för en eller flera metoder som "
"definieras på ett objekt. Exempelvis kan :mod:``regular expressions <re>`` "
"användas på både datatypen :class:`str` och datatypen :class:`bytes`:"

#: ../../library/stdtypes.rst:5345
msgid ""
"If ``x = re.search('foo', 'foo')``, ``x`` will be a :ref:`re.Match <match-"
"objects>` object where the return values of ``x.group(0)`` and ``x[0]`` will "
"both be of type :class:`str`. We can represent this kind of object in type "
"annotations with the ``GenericAlias`` ``re.Match[str]``."
msgstr ""
"Om ``x = re.search('foo', 'foo')``, kommer ``x`` att vara ett :ref:`re.Match "
"<match-objects>`-objekt där returvärdena för ``x.group(0)`` och ``x[0]`` "
"båda kommer att vara av typen :class:`str`. Vi kan representera den här "
"typen av objekt i typannoteringar med ``GenericAlias`` ``re.Match[str]``."

#: ../../library/stdtypes.rst:5351
msgid ""
"If ``y = re.search(b'bar', b'bar')``, (note the ``b`` for :class:`bytes`), "
"``y`` will also be an instance of ``re.Match``, but the return values of ``y."
"group(0)`` and ``y[0]`` will both be of type :class:`bytes`. In type "
"annotations, we would represent this variety of :ref:`re.Match <match-"
"objects>` objects with ``re.Match[bytes]``."
msgstr ""
"Om ``y = re.search(b'bar', b'bar')``, (notera ``b`` för :class:`bytes`), "
"kommer ``y`` också att vara en instans av ``re.Match``, men returvärdena för "
"``y.group(0)`` och ``y[0]`` kommer båda att vara av typen :class:`bytes`. I "
"typannoteringar skulle vi representera denna variation av :ref:`re.Match "
"<match-objects>` objekt med ``re.Match[bytes]``."

#: ../../library/stdtypes.rst:5357
msgid ""
"``GenericAlias`` objects are instances of the class :class:`types."
"GenericAlias`, which can also be used to create ``GenericAlias`` objects "
"directly."
msgstr ""
"``GenericAlias``-objekt är instanser av klassen :class:`types.GenericAlias`, "
"som också kan användas för att skapa ``GenericAlias``-objekt direkt."

#: ../../library/stdtypes.rst:5363
msgid ""
"Creates a ``GenericAlias`` representing a type ``T`` parameterized by types "
"*X*, *Y*, and more depending on the ``T`` used. For example, a function "
"expecting a :class:`list` containing :class:`float` elements::"
msgstr ""
"Skapar en ``GenericAlias`` som representerar en typ ``T`` parametriserad av "
"typerna *X*, *Y*, och mer beroende på vilken ``T`` som används. Till exempel "
"en funktion som förväntar sig en :class:`list` som innehåller :class:`float`-"
"element::"

#: ../../library/stdtypes.rst:5368
msgid ""
"def average(values: list[float]) -> float:\n"
"    return sum(values) / len(values)"
msgstr ""
"def average(värden: lista[float]) -> float:\n"
"    return sum(värden) / len(värden)"

#: ../../library/stdtypes.rst:5371
msgid ""
"Another example for :term:`mapping` objects, using a :class:`dict`, which is "
"a generic type expecting two type parameters representing the key type and "
"the value type.  In this example, the function expects a ``dict`` with keys "
"of type :class:`str` and values of type :class:`int`::"
msgstr ""
"Ett annat exempel för :term:`mapping`-objekt, med :class:`dict`, som är en "
"generisk typ som förväntar sig två typparametrar som representerar "
"nyckeltypen och värdetypen.  I detta exempel förväntar sig funktionen en "
"``dict`` med nycklar av typen :class:`str` och värden av typen :class:`int`::"

#: ../../library/stdtypes.rst:5376
msgid ""
"def send_post_request(url: str, body: dict[str, int]) -> None:\n"
"    ..."
msgstr ""
"def send_post_request(url: str, body: dict[str, int]) -> None:\n"
"    ..."

#: ../../library/stdtypes.rst:5379
msgid ""
"The builtin functions :func:`isinstance` and :func:`issubclass` do not "
"accept ``GenericAlias`` types for their second argument::"
msgstr ""
"De inbyggda funktionerna :func:`isinstance` och :func:`issubclass` "
"accepterar inte ``GenericAlias``-typer för sitt andra argument::"

#: ../../library/stdtypes.rst:5382
msgid ""
">>> isinstance([1, 2], list[str])\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: isinstance() argument 2 cannot be a parameterized generic"
msgstr ""
"&gt;&gt;&gt; isinstance([1, 2], lista[str])\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"TypeError: isinstance() argument 2 kan inte vara en parameteriserad generisk"

#: ../../library/stdtypes.rst:5387
msgid ""
"The Python runtime does not enforce :term:`type annotations <annotation>`. "
"This extends to generic types and their type parameters. When creating a "
"container object from a ``GenericAlias``, the elements in the container are "
"not checked against their type. For example, the following code is "
"discouraged, but will run without errors::"
msgstr ""
"Pythons runtime upprätthåller inte :term:`typannoteringar <annotation>`. "
"Detta gäller även generiska typer och deras typparametrar. När du skapar ett "
"containerobjekt från en ``GenericAlias`` kontrolleras inte elementen i "
"containern mot deras typ. Till exempel, följande kod är inte rekommenderad, "
"men kommer att köras utan fel::"

#: ../../library/stdtypes.rst:5393
msgid ""
">>> t = list[str]\n"
">>> t([1, 2, 3])\n"
"[1, 2, 3]"
msgstr ""
">>> t = lista[str]\n"
">>> t([1, 2, 3])\n"
"[1, 2, 3]"

#: ../../library/stdtypes.rst:5397
msgid ""
"Furthermore, parameterized generics erase type parameters during object "
"creation::"
msgstr ""
"Dessutom raderar parametriserade generika typparametrar när objektet skapas::"

#: ../../library/stdtypes.rst:5400
msgid ""
">>> t = list[str]\n"
">>> type(t)\n"
"<class 'types.GenericAlias'>\n"
"\n"
">>> l = t()\n"
">>> type(l)\n"
"<class 'list'>"
msgstr ""
">>> t = lista[str]\n"
">>> typ(t)\n"
"<class 'typer.generiska alias'>\n"
"\n"
">>> l = t()\n"
">>> typ(l)\n"
"<klass 'lista'>"

#: ../../library/stdtypes.rst:5408
msgid ""
"Calling :func:`repr` or :func:`str` on a generic shows the parameterized "
"type::"
msgstr ""
"Anrop av :func:`repr` eller :func:`str` på en generisk visar den "
"parametriserade typen::"

#: ../../library/stdtypes.rst:5410
msgid ""
">>> repr(list[int])\n"
"'list[int]'\n"
"\n"
">>> str(list[int])\n"
"'list[int]'"
msgstr ""
">>> repr(list[int])\n"
"'lista[int]'\n"
"\n"
">>> str(lista[int])\n"
"\"lista[int]"

#: ../../library/stdtypes.rst:5416
msgid ""
"The :meth:`~object.__getitem__` method of generic containers will raise an "
"exception to disallow mistakes like ``dict[str][str]``::"
msgstr ""
"Metoden :meth:`~object.__getitem__` för generiska behållare kommer att ge "
"upphov till ett undantag för att förhindra misstag som ``dict[str][str]``::"

#: ../../library/stdtypes.rst:5419
msgid ""
">>> dict[str][str]\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: dict[str] is not a generic class"
msgstr ""
">>> dict[str][str]\n"
"Traceback (senaste anropet senast):\n"
"  ...\n"
"TypeError: dict[str] är inte en generisk klass"

#: ../../library/stdtypes.rst:5424
msgid ""
"However, such expressions are valid when :ref:`type variables <generics>` "
"are used.  The index must have as many elements as there are type variable "
"items in the ``GenericAlias`` object's :attr:`~genericalias.__args__`. ::"
msgstr ""
"Sådana uttryck är dock giltiga när :ref:``typvariabler <generics>`` "
"används.  Indexet måste ha lika många element som det finns typvariabler i "
"``GenericAlias``-objektets :attr:`~genericalias.__args__`. ::"

#: ../../library/stdtypes.rst:5428
msgid ""
">>> from typing import TypeVar\n"
">>> Y = TypeVar('Y')\n"
">>> dict[str, Y][int]\n"
"dict[str, int]"
msgstr ""
">>> från typing import TypeVar\n"
">>> Y = TypeVar('Y')\n"
">>> dict[str, Y][int]\n"
"dict[str, int]"

#: ../../library/stdtypes.rst:5435
msgid "Standard Generic Classes"
msgstr "Generiska standardklasser"

#: ../../library/stdtypes.rst:5437
msgid ""
"The following standard library classes support parameterized generics. This "
"list is non-exhaustive."
msgstr ""
"Följande klasser i standardbiblioteket stöder parametriserade generiker. "
"Denna lista är inte uttömmande."

#: ../../library/stdtypes.rst:5440
msgid ":class:`tuple`"
msgstr ":klass:`tuple`"

#: ../../library/stdtypes.rst:5441
msgid ":class:`list`"
msgstr ":klass:`lista`"

#: ../../library/stdtypes.rst:5442
msgid ":class:`dict`"
msgstr ":klass:`dict`"

#: ../../library/stdtypes.rst:5443
msgid ":class:`set`"
msgstr ":klass:`set`"

#: ../../library/stdtypes.rst:5444
msgid ":class:`frozenset`"
msgstr ":klass:`frozenset`"

#: ../../library/stdtypes.rst:5445
msgid ":class:`type`"
msgstr ":klass:`typ`"

#: ../../library/stdtypes.rst:5446
msgid ":class:`asyncio.Future`"
msgstr ":klass:`asyncio.Future`"

#: ../../library/stdtypes.rst:5447
msgid ":class:`asyncio.Task`"
msgstr ":klass:`asyncio.Task`"

#: ../../library/stdtypes.rst:5448
msgid ":class:`collections.deque`"
msgstr ":klass:`samlingar.deque`"

#: ../../library/stdtypes.rst:5449
msgid ":class:`collections.defaultdict`"
msgstr ":klass:`samlingar.defaultdict`"

#: ../../library/stdtypes.rst:5450
msgid ":class:`collections.OrderedDict`"
msgstr ":klass:`samlingar.OrderedDict`"

#: ../../library/stdtypes.rst:5451
msgid ":class:`collections.Counter`"
msgstr ":klass:`samlingar.Räknare`"

#: ../../library/stdtypes.rst:5452
msgid ":class:`collections.ChainMap`"
msgstr ":klass:`samlingar.ChainMap`"

#: ../../library/stdtypes.rst:5453
msgid ":class:`collections.abc.Awaitable`"
msgstr ":klass:`samlingar.abc.Awaitable`"

#: ../../library/stdtypes.rst:5454
msgid ":class:`collections.abc.Coroutine`"
msgstr ":klass:`samlingar.abc.Coroutine`"

#: ../../library/stdtypes.rst:5455
msgid ":class:`collections.abc.AsyncIterable`"
msgstr ":class:`samlingar.abc.AsyncIterable`"

#: ../../library/stdtypes.rst:5456
msgid ":class:`collections.abc.AsyncIterator`"
msgstr ":klass:`samlingar.abc.AsyncIterator`"

#: ../../library/stdtypes.rst:5457
msgid ":class:`collections.abc.AsyncGenerator`"
msgstr ":klass:``kollektioner.abc.AsyncGenerator``"

#: ../../library/stdtypes.rst:5458
msgid ":class:`collections.abc.Iterable`"
msgstr ":klass:`samlingar.abc.Iterable`"

#: ../../library/stdtypes.rst:5459
msgid ":class:`collections.abc.Iterator`"
msgstr ":klass:`samlingar.abc.Iterator`"

#: ../../library/stdtypes.rst:5460
msgid ":class:`collections.abc.Generator`"
msgstr ":klass:`samlingar.abc.Generator`"

#: ../../library/stdtypes.rst:5461
msgid ":class:`collections.abc.Reversible`"
msgstr ":klass:``samlingar.abc.Reversibel``"

#: ../../library/stdtypes.rst:5462
msgid ":class:`collections.abc.Container`"
msgstr ":klass:``samlingar.abc.container``"

#: ../../library/stdtypes.rst:5463
msgid ":class:`collections.abc.Collection`"
msgstr ":klass:`collections.abc.Collection`"

#: ../../library/stdtypes.rst:5464
msgid ":class:`collections.abc.Callable`"
msgstr ":klass:`samlingar.abc.Callable`"

#: ../../library/stdtypes.rst:5465
msgid ":class:`collections.abc.Set`"
msgstr ":klass:``samlingar.abc.Set``"

#: ../../library/stdtypes.rst:5466
msgid ":class:`collections.abc.MutableSet`"
msgstr ":klass:``samlingar.abc.MutableSet``"

#: ../../library/stdtypes.rst:5467
msgid ":class:`collections.abc.Mapping`"
msgstr ":klass:``samlingar.abc.Mapping``"

#: ../../library/stdtypes.rst:5468
msgid ":class:`collections.abc.MutableMapping`"
msgstr ":klass:`samlingar.abc.MutableMapping`"

#: ../../library/stdtypes.rst:5469
msgid ":class:`collections.abc.Sequence`"
msgstr ":klass:``samlingar.abc.sekvens``"

#: ../../library/stdtypes.rst:5470
msgid ":class:`collections.abc.MutableSequence`"
msgstr ":class:`samlingar.abc.MutableSequence`"

#: ../../library/stdtypes.rst:5471
msgid ":class:`collections.abc.MappingView`"
msgstr ":class:`samlingar.abc.MappingView`"

#: ../../library/stdtypes.rst:5472
msgid ":class:`collections.abc.KeysView`"
msgstr ":klass:`samlingar.abc.KeysView`"

#: ../../library/stdtypes.rst:5473
msgid ":class:`collections.abc.ItemsView`"
msgstr ":klass:`collections.abc.ItemsView`"

#: ../../library/stdtypes.rst:5474
msgid ":class:`collections.abc.ValuesView`"
msgstr ":class:`kollektioner.abc.ValuesView`"

#: ../../library/stdtypes.rst:5475
msgid ":class:`contextlib.AbstractContextManager`"
msgstr ":klass:`contextlib.AbstractContextManager`"

#: ../../library/stdtypes.rst:5476
msgid ":class:`contextlib.AbstractAsyncContextManager`"
msgstr ":klass:`contextlib.AbstractAsyncContextManager`"

#: ../../library/stdtypes.rst:5477
msgid ":class:`dataclasses.Field`"
msgstr ":klass:`dataklasser.fält`"

#: ../../library/stdtypes.rst:5478
msgid ":class:`functools.cached_property`"
msgstr ":klass:`functools.cached_property`"

#: ../../library/stdtypes.rst:5479
msgid ":class:`functools.partialmethod`"
msgstr ":klass:`functools.partialmethod`"

#: ../../library/stdtypes.rst:5480
msgid ":class:`os.PathLike`"
msgstr ":klass:`os.PathLike`"

#: ../../library/stdtypes.rst:5481
msgid ":class:`queue.LifoQueue`"
msgstr ":klass:`queue.LifoQueue`"

#: ../../library/stdtypes.rst:5482
msgid ":class:`queue.Queue`"
msgstr ":klass:`queue.Queue`"

#: ../../library/stdtypes.rst:5483
msgid ":class:`queue.PriorityQueue`"
msgstr ":klass:`queue.PriorityQueue`"

#: ../../library/stdtypes.rst:5484
msgid ":class:`queue.SimpleQueue`"
msgstr ":klass:`queue.SimpleQueue`"

#: ../../library/stdtypes.rst:5485
msgid ":ref:`re.Pattern <re-objects>`"
msgstr ":ref:`re.mönster <re-objects>`"

#: ../../library/stdtypes.rst:5486
msgid ":ref:`re.Match <match-objects>`"
msgstr ":ref:`re.Match <match-objects>`"

#: ../../library/stdtypes.rst:5487
msgid ":class:`shelve.BsdDbShelf`"
msgstr ":klass:`shelve.BsdDbShelf`"

#: ../../library/stdtypes.rst:5488
msgid ":class:`shelve.DbfilenameShelf`"
msgstr ":klass:`shelve.DbfilenameShelf`"

#: ../../library/stdtypes.rst:5489
msgid ":class:`shelve.Shelf`"
msgstr ":klass:`shelve.Shelf`"

#: ../../library/stdtypes.rst:5490
msgid ":class:`types.MappingProxyType`"
msgstr ":klass:`types.MappingProxyType`"

#: ../../library/stdtypes.rst:5491
msgid ":class:`weakref.WeakKeyDictionary`"
msgstr ":klass:`weakref.WeakKeyDictionary`"

#: ../../library/stdtypes.rst:5492
msgid ":class:`weakref.WeakMethod`"
msgstr ":klass:`weakref.WeakMethod`"

#: ../../library/stdtypes.rst:5493
msgid ":class:`weakref.WeakSet`"
msgstr ":klass:`weakref.WeakSet`"

#: ../../library/stdtypes.rst:5494
msgid ":class:`weakref.WeakValueDictionary`"
msgstr ":klass:`weakref.WeakValueDictionary`"

#: ../../library/stdtypes.rst:5499
msgid "Special Attributes of ``GenericAlias`` objects"
msgstr "Särskilda egenskaper för objekt av typen ``GenericAlias"

#: ../../library/stdtypes.rst:5501
msgid "All parameterized generics implement special read-only attributes."
msgstr ""
"Alla parametriserade generics implementerar speciella skrivskyddade attribut."

#: ../../library/stdtypes.rst:5505
msgid "This attribute points at the non-parameterized generic class::"
msgstr "Detta attribut pekar på den icke-parameteriserade generiska klassen::"

#: ../../library/stdtypes.rst:5507
msgid ""
">>> list[int].__origin__\n"
"<class 'list'>"
msgstr ""
">>> list[int].__origin__\n"
"<klass 'lista'>"

#: ../../library/stdtypes.rst:5513
msgid ""
"This attribute is a :class:`tuple` (possibly of length 1) of generic types "
"passed to the original :meth:`~object.__class_getitem__` of the generic "
"class::"
msgstr ""
"Detta attribut är en :class:`tuple` (eventuellt av längd 1) av generiska "
"typer som skickas till den ursprungliga :meth:`~object.__class_getitem__` av "
"den generiska klassen::"

#: ../../library/stdtypes.rst:5517
msgid ""
">>> dict[str, list[int]].__args__\n"
"(<class 'str'>, list[int])"
msgstr ""
">>> dict[str, list[int]].__args__\n"
"(<klass 'str'>, lista[int])"

#: ../../library/stdtypes.rst:5523
msgid ""
"This attribute is a lazily computed tuple (possibly empty) of unique type "
"variables found in ``__args__``::"
msgstr ""
"Detta attribut är en latent beräknad tupel (eventuellt tom) av unika "
"typvariabler som finns i ``__args__``::"

#: ../../library/stdtypes.rst:5526
msgid ""
">>> from typing import TypeVar\n"
"\n"
">>> T = TypeVar('T')\n"
">>> list[T].__parameters__\n"
"(~T,)"
msgstr ""
">>> från typing import TypeVar\n"
"\n"
">>> T = TypeVar('T')\n"
">>> lista[T].__parametrar__\n"
"(~T,)"

#: ../../library/stdtypes.rst:5534
msgid ""
"A ``GenericAlias`` object with :class:`typing.ParamSpec` parameters may not "
"have correct ``__parameters__`` after substitution because :class:`typing."
"ParamSpec` is intended primarily for static type checking."
msgstr ""
"Ett ``GenericAlias``-objekt med :class:`typing.ParamSpec`-parametrar kanske "
"inte har korrekta ``__parameters__`` efter substitution eftersom :class:"
"`typing.ParamSpec` främst är avsedd för statisk typkontroll."

#: ../../library/stdtypes.rst:5541
msgid ""
"A boolean that is true if the alias has been unpacked using the ``*`` "
"operator (see :data:`~typing.TypeVarTuple`)."
msgstr ""
"En boolean som är sann om aliaset har packats upp med operatorn ``*`` (se :"
"data:`~typing.TypeVarTuple`)."

#: ../../library/stdtypes.rst:5549
msgid ":pep:`484` - Type Hints"
msgstr ":pep:`484` - Tips om typ"

#: ../../library/stdtypes.rst:5550
msgid "Introducing Python's framework for type annotations."
msgstr "Introduktion till Pythons ramverk för typannoteringar."

#: ../../library/stdtypes.rst:5552
msgid ":pep:`585` - Type Hinting Generics In Standard Collections"
msgstr ":pep:`585` - Typhintning av generiska gener i standardsamlingar"

#: ../../library/stdtypes.rst:5553
msgid ""
"Introducing the ability to natively parameterize standard-library classes, "
"provided they implement the special class method :meth:`~object."
"__class_getitem__`."
msgstr ""
"Introducerar möjligheten att naturligt parametrisera "
"standardbiblioteksklasser, förutsatt att de implementerar den speciella "
"klassmetoden :meth:`~object.__class_getitem__`."

#: ../../library/stdtypes.rst:5557
msgid ""
":ref:`Generics`, :ref:`user-defined generics <user-defined-generics>` and :"
"class:`typing.Generic`"
msgstr ""
":ref:`Generics`, :ref:`användardefinierad generik <user-defined-generics>` "
"och :class:`typing.Generic`"

#: ../../library/stdtypes.rst:5558
msgid ""
"Documentation on how to implement generic classes that can be parameterized "
"at runtime and understood by static type-checkers."
msgstr ""
"Dokumentation om hur man implementerar generiska klasser som kan "
"parametriseras vid körning och förstås av statiska typkontrollanter."

#: ../../library/stdtypes.rst:5567
msgid "Union Type"
msgstr "Typ av fackförening"

#: ../../library/stdtypes.rst:5573
msgid ""
"A union object holds the value of the ``|`` (bitwise or) operation on "
"multiple :ref:`type objects <bltin-type-objects>`.  These types are intended "
"primarily for :term:`type annotations <annotation>`. The union type "
"expression enables cleaner type hinting syntax compared to subscripting :"
"class:`typing.Union`."
msgstr ""
"Ett union-objekt innehåller värdet av ``|``-operationen (bitvis eller) på "
"flera :ref:`type-objekt <bltin-type-objects>`.  Dessa typer är främst "
"avsedda för :term:`type annotations <annotation>`. Uttrycket unionstyp "
"möjliggör en renare syntax för typhinting jämfört med subskription av :class:"
"`typing.Union`."

#: ../../library/stdtypes.rst:5580
msgid ""
"Defines a union object which holds types *X*, *Y*, and so forth. ``X | Y`` "
"means either X or Y.  It is equivalent to ``typing.Union[X, Y]``. For "
"example, the following function expects an argument of type :class:`int` or :"
"class:`float`::"
msgstr ""
"Definierar ett union-objekt som innehåller typerna *X*, *Y*, och så vidare. "
"``X | Y`` betyder antingen X eller Y. Det är ekvivalent med ``typing."
"Union[X, Y]``. Till exempel förväntar sig följande funktion ett argument av "
"typen :class:`int` eller :class:`float`::"

#: ../../library/stdtypes.rst:5585
msgid ""
"def square(number: int | float) -> int | float:\n"
"    return number ** 2"
msgstr ""
"def square(number: int | float) -> int | float:\n"
"    returnerar nummer ** 2"

#: ../../library/stdtypes.rst:5590
msgid ""
"The ``|`` operand cannot be used at runtime to define unions where one or "
"more members is a forward reference. For example, ``int | \"Foo\"``, where "
"``\"Foo\"`` is a reference to a class not yet defined, will fail at runtime. "
"For unions which include forward references, present the whole expression as "
"a string, e.g. ``\"int | Foo\"``."
msgstr ""
"Operanden ``|`` kan inte användas vid körning för att definiera unioner där "
"en eller flera medlemmar är en framåtriktad referens. Till exempel kommer "
"``int | \"Foo\"``, där ``\"Foo\"`` är en referens till en klass som ännu "
"inte definierats, att misslyckas vid körning. För unioner som innehåller "
"framåtriktade referenser ska hela uttrycket presenteras som en sträng, t.ex. "
"``\"int | Foo\"``."

#: ../../library/stdtypes.rst:5598
msgid ""
"Union objects can be tested for equality with other union objects.  Details:"
msgstr ""
"Unionsobjekt kan testas för jämlikhet med andra unionsobjekt.  Detaljerad "
"information:"

#: ../../library/stdtypes.rst:5600
msgid "Unions of unions are flattened::"
msgstr "Unioner av unioner är tillplattade::"

#: ../../library/stdtypes.rst:5602
msgid "(int | str) | float == int | str | float"
msgstr "(int | str) | float == int | str | float"

#: ../../library/stdtypes.rst:5604
msgid "Redundant types are removed::"
msgstr "Överflödiga typer tas bort::"

#: ../../library/stdtypes.rst:5606
msgid "int | str | int == int | str"
msgstr "int | str | int == int | str"

#: ../../library/stdtypes.rst:5608
msgid "When comparing unions, the order is ignored::"
msgstr "Vid jämförelse av fackföreningar ignoreras ordningen::"

#: ../../library/stdtypes.rst:5610
msgid "int | str == str | int"
msgstr "int | str == str | int"

#: ../../library/stdtypes.rst:5612
msgid "It creates instances of :class:`typing.Union`::"
msgstr "Den skapar instanser av :class:`typing.Union`::"

#: ../../library/stdtypes.rst:5614
msgid ""
"int | str == typing.Union[int, str]\n"
"type(int | str) is typing.Union"
msgstr ""
"int | str == typing.Union[int, str]\n"
"typ(int | str) är typing.union"

#: ../../library/stdtypes.rst:5617
msgid "Optional types can be spelled as a union with ``None``::"
msgstr "Valfria typer kan stavas som en union med ``None``::"

#: ../../library/stdtypes.rst:5619
msgid "str | None == typing.Optional[str]"
msgstr "str | None == typing.Optional[str]"

#: ../../library/stdtypes.rst:5624
msgid ""
"Calls to :func:`isinstance` and :func:`issubclass` are also supported with a "
"union object::"
msgstr ""
"Anrop till :func:`isinstance` och :func:`issubclass` stöds också med ett "
"unionsobjekt::"

#: ../../library/stdtypes.rst:5627
msgid ""
">>> isinstance(\"\", int | str)\n"
"True"
msgstr ""
">>> isinstance(\"\", int | str)\n"
"Sant"

#: ../../library/stdtypes.rst:5630
msgid ""
"However, :ref:`parameterized generics <types-genericalias>` in union objects "
"cannot be checked::"
msgstr ""
"Däremot kan :ref:`parameterized generics <types-genericalias>` i "
"unionsobjekt inte kontrolleras::"

#: ../../library/stdtypes.rst:5633
msgid ""
">>> isinstance(1, int | list[int])  # short-circuit evaluation\n"
"True\n"
">>> isinstance([1], int | list[int])\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: isinstance() argument 2 cannot be a parameterized generic"
msgstr ""
">>> isinstance(1, int | list[int]) # kortslutningsutvärdering\n"
"Sant\n"
">>> isinstans([1], int | lista[int])\n"
"Traceback (senaste anropet senast):\n"
"  ...\n"
"TypeError: isinstance() argument 2 kan inte vara en parameteriserad generisk"

#: ../../library/stdtypes.rst:5640
msgid ""
"The user-exposed type for the union object can be accessed from :class:"
"`typing.Union` and used for :func:`isinstance` checks::"
msgstr ""
"Den användardefinierade typen för union-objektet kan hämtas från :class:"
"`typing.Union` och användas för :func:`isinstance`-kontroller::"

#: ../../library/stdtypes.rst:5643
msgid ""
">>> import typing\n"
">>> isinstance(int | str, typing.Union)\n"
"True\n"
">>> typing.Union()\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: cannot create 'typing.Union' instances"
msgstr ""
"&gt;&gt;&gt; import typning\n"
"&gt;&gt;&gt; isinstance(int | str, typing.Union)\n"
"Sant\n"
"&gt;&gt;&gt; typing.union()\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"TypeError: kan inte skapa 'typing.Union'-instanser"

#: ../../library/stdtypes.rst:5652
msgid ""
"The :meth:`!__or__` method for type objects was added to support the syntax "
"``X | Y``.  If a metaclass implements :meth:`!__or__`, the Union may "
"override it:"
msgstr ""
"Metoden :meth:`!__or__` för typobjekt har lagts till för att stödja syntaxen "
"``X | Y``.  Om en metaklass implementerar :meth:`!__or__` kan unionen "
"åsidosätta den:"

#: ../../library/stdtypes.rst:5656
msgid ""
">>> class M(type):\n"
"...     def __or__(self, other):\n"
"...         return \"Hello\"\n"
"...\n"
">>> class C(metaclass=M):\n"
"...     pass\n"
"...\n"
">>> C | int\n"
"'Hello'\n"
">>> int | C\n"
"int | C"
msgstr ""
">>> klass M(typ):\n"
"... def __or__(self, other):\n"
"... return \"Hej\"\n"
"...\n"
">>> klass C(metaklass=M):\n"
"... pass\n"
"...\n"
">>> C | int\n"
"'Hej'\n"
">>> int | C\n"
"int | C"

#: ../../library/stdtypes.rst:5672
msgid ":pep:`604` -- PEP proposing the ``X | Y`` syntax and the Union type."
msgstr ":pep:`604` -- PEP föreslår syntaxen ``X | Y`` och Union-typen."

#: ../../library/stdtypes.rst:5678
msgid ""
"Union objects are now instances of :class:`typing.Union`. Previously, they "
"were instances of :class:`types.UnionType`, which remains an alias for :"
"class:`typing.Union`."
msgstr ""
"Union-objekt är nu instanser av :class:`typing.Union`. Tidigare var de "
"instanser av :class:`types.UnionType`, som fortfarande är ett alias för :"
"class:`typing.Union`."

#: ../../library/stdtypes.rst:5685
msgid "Other Built-in Types"
msgstr "Andra inbyggda typer"

#: ../../library/stdtypes.rst:5687
msgid ""
"The interpreter supports several other kinds of objects. Most of these "
"support only one or two operations."
msgstr ""
"Tolken har stöd för flera andra typer av objekt. De flesta av dessa stöder "
"endast en eller två operationer."

#: ../../library/stdtypes.rst:5694
msgid "Modules"
msgstr "Moduler"

#: ../../library/stdtypes.rst:5696
msgid ""
"The only special operation on a module is attribute access: ``m.name``, "
"where *m* is a module and *name* accesses a name defined in *m*'s symbol "
"table. Module attributes can be assigned to.  (Note that the :keyword:"
"`import` statement is not, strictly speaking, an operation on a module "
"object; ``import foo`` does not require a module object named *foo* to "
"exist, rather it requires an (external) *definition* for a module named "
"*foo* somewhere.)"
msgstr ""
"Den enda speciella operationen på en modul är attributåtkomst: ``m.name``, "
"där *m* är en modul och *name* ger åtkomst till ett namn som definieras i "
"*m*:s symboltabell. Modulattribut kan tilldelas till.  (Observera att :"
"keyword:`import` inte i strikt mening är en operation på ett modulobjekt; "
"``import foo`` kräver inte att ett modulobjekt med namnet *foo* existerar, "
"utan snarare att det finns en (extern) *definition* för en modul med namnet "
"*foo* någonstans)"

#: ../../library/stdtypes.rst:5703
msgid ""
"A special attribute of every module is :attr:`~object.__dict__`. This is the "
"dictionary containing the module's symbol table. Modifying this dictionary "
"will actually change the module's symbol table, but direct assignment to "
"the :attr:`~object.__dict__` attribute is not possible (you can write ``m."
"__dict__['a'] = 1``, which defines ``m.a`` to be ``1``, but you can't write "
"``m.__dict__ = {}``).  Modifying :attr:`~object.__dict__` directly is not "
"recommended."
msgstr ""
"Ett speciellt attribut för varje modul är :attr:`~object.__dict__`. Detta är "
"den ordbok som innehåller modulens symboltabell. Modifiering av denna "
"dictionary kommer faktiskt att ändra modulens symboltabell, men direkt "
"tilldelning till attributet :attr:`~object.__dict__` är inte möjligt (du kan "
"skriva ``m.__dict__['a'] = 1``, vilket definierar ``m.a`` till att vara "
"``1``, men du kan inte skriva ``m.__dict__ = {}``).  Att ändra :attr:"
"`~object.__dict__` direkt är inte rekommenderat."

#: ../../library/stdtypes.rst:5711
msgid ""
"Modules built into the interpreter are written like this: ``<module "
"'sys' (built-in)>``.  If loaded from a file, they are written as ``<module "
"'os' from '/usr/local/lib/pythonX.Y/os.pyc'>``."
msgstr ""
"Moduler som är inbyggda i tolken skrivs på följande sätt: ``<modulen "
"'sys' (inbyggd)>``.  Om de laddas från en fil skrivs de som ``<modulen 'os' "
"från '/usr/local/lib/pythonX.Y/os.pyc'>``."

#: ../../library/stdtypes.rst:5719
msgid "Classes and Class Instances"
msgstr "Klasser och klassinstanser"

#: ../../library/stdtypes.rst:5721
msgid "See :ref:`objects` and :ref:`class` for these."
msgstr "Se :ref:`objects` och :ref:`class` för dessa."

#: ../../library/stdtypes.rst:5727
msgid "Functions"
msgstr "Funktioner"

#: ../../library/stdtypes.rst:5729
msgid ""
"Function objects are created by function definitions.  The only operation on "
"a function object is to call it: ``func(argument-list)``."
msgstr ""
"Funktionsobjekt skapas av funktionsdefinitioner.  Den enda operationen på "
"ett funktionsobjekt är att anropa det: ``func(argument-list)``."

#: ../../library/stdtypes.rst:5732
msgid ""
"There are really two flavors of function objects: built-in functions and "
"user-defined functions.  Both support the same operation (to call the "
"function), but the implementation is different, hence the different object "
"types."
msgstr ""
"Det finns egentligen två olika typer av funktionsobjekt: inbyggda funktioner "
"och användardefinierade funktioner.  Båda stöder samma operation (att anropa "
"funktionen), men implementeringen är olika, därav de olika objekttyperna."

#: ../../library/stdtypes.rst:5736
msgid "See :ref:`function` for more information."
msgstr "Se :ref:`function` för mer information."

#: ../../library/stdtypes.rst:5742
msgid "Methods"
msgstr "Metoder"

#: ../../library/stdtypes.rst:5746
msgid ""
"Methods are functions that are called using the attribute notation. There "
"are two flavors: :ref:`built-in methods <builtin-methods>` (such as :meth:"
"`append` on lists) and :ref:`class instance method <instance-methods>`. "
"Built-in methods are described with the types that support them."
msgstr ""
"Metoder är funktioner som anropas med hjälp av attributnotationen. Det finns "
"två varianter: :ref:`inbyggda metoder <builtin-methods>` (t.ex. :meth:"
"`append` på listor) och :ref:`klassinstansmetod <instance-methods>`. "
"Inbyggda metoder beskrivs med de typer som stöder dem."

#: ../../library/stdtypes.rst:5751
msgid ""
"If you access a method (a function defined in a class namespace) through an "
"instance, you get a special object: a :dfn:`bound method` (also called :ref:"
"`instance method <instance-methods>`) object. When called, it will add the "
"``self`` argument to the argument list.  Bound methods have two special read-"
"only attributes: :attr:`m.__self__ <method.__self__>` is the object on which "
"the method operates, and :attr:`m.__func__ <method.__func__>` is the "
"function implementing the method.  Calling ``m(arg-1, arg-2, ..., arg-n)`` "
"is completely equivalent to calling ``m.__func__(m.__self__, arg-1, "
"arg-2, ..., arg-n)``."
msgstr ""
"Om du anropar en metod (en funktion som definieras i en klassnamnrymd) via "
"en instans får du ett speciellt objekt: ett :dfn:`bound method`-objekt (även "
"kallat :ref:`instance method <instance-methods>`). När den anropas kommer "
"den att lägga till argumentet ``self`` i argumentlistan.  Bound methods har "
"två speciella skrivskyddade attribut: :attr:`m.__self__ <method.__self__>` "
"är det objekt som metoden verkar på, och :attr:`m.__func__ <method."
"__func__>` är den funktion som implementerar metoden.  Anrop av ``m(arg-1, "
"arg-2, ..., arg-n)`` är helt likvärdigt med anrop av ``m.__func__(m."
"__self__, arg-1, arg-2, ..., arg-n)``."

#: ../../library/stdtypes.rst:5762
msgid ""
"Like :ref:`function objects <user-defined-funcs>`, bound method objects "
"support getting arbitrary attributes.  However, since method attributes are "
"actually stored on the underlying function object (:attr:`method.__func__`), "
"setting method attributes on bound methods is disallowed.  Attempting to set "
"an attribute on a method results in an :exc:`AttributeError` being raised.  "
"In order to set a method attribute, you need to explicitly set it on the "
"underlying function object:"
msgstr ""
"Liksom :ref:`funktionsobjekt <user-defined-funcs>`, stöder bundna "
"metodobjekt att få godtyckliga attribut.  Men eftersom metodattribut "
"faktiskt lagras på det underliggande funktionsobjektet (:attr:`method."
"__func__`) är det inte tillåtet att ställa in metodattribut på bundna "
"metoder.  Försök att sätta ett attribut på en metod resulterar i ett :exc:"
"`AttributeError`.  För att kunna ställa in ett metodattribut måste du "
"uttryckligen ställa in det på det underliggande funktionsobjektet:"

#: ../../library/stdtypes.rst:5770
msgid ""
">>> class C:\n"
"...     def method(self):\n"
"...         pass\n"
"...\n"
">>> c = C()\n"
">>> c.method.whoami = 'my name is method'  # can't set on the method\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"AttributeError: 'method' object has no attribute 'whoami'\n"
">>> c.method.__func__.whoami = 'my name is method'\n"
">>> c.method.whoami\n"
"'my name is method'"
msgstr ""
"&gt;&gt;&gt; klass C:\n"
"... def method(self):\n"
"... pass\n"
"...\n"
"&gt;&gt;&gt; c = C()\n"
"&gt;&gt;&gt; c.method.whoami = 'mitt namn är method' # kan inte ställas in "
"på metoden\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"AttributeError: Objektet 'method' har inget attribut 'whoami'\n"
"&gt;&gt;&gt; c.method.__func__.whoami = 'mitt namn är metod'\n"
"&gt;&gt;&gt; c.method.whoami\n"
"\"mitt namn är metod"

#: ../../library/stdtypes.rst:5785
msgid "See :ref:`instance-methods` for more information."
msgstr "Se :ref:`instance-methods` för mer information."

#: ../../library/stdtypes.rst:5793
msgid "Code Objects"
msgstr "Kodobjekt"

#: ../../library/stdtypes.rst:5799
msgid ""
"Code objects are used by the implementation to represent \"pseudo-compiled\" "
"executable Python code such as a function body. They differ from function "
"objects because they don't contain a reference to their global execution "
"environment.  Code objects are returned by the built-in :func:`compile` "
"function and can be extracted from function objects through their :attr:"
"`~function.__code__` attribute. See also the :mod:`code` module."
msgstr ""
"Kodobjekt används av implementationen för att representera "
"\"pseudokompilerad\" körbar Python-kod, t.ex. en funktionskropp. De skiljer "
"sig från funktionsobjekt eftersom de inte innehåller någon referens till sin "
"globala exekveringsmiljö.  Kodobjekt returneras av den inbyggda :func:"
"`compile`-funktionen och kan extraheras från funktionsobjekt genom deras :"
"attr:`~function.__code__`-attribut. Se även modulen :mod:`code`."

#: ../../library/stdtypes.rst:5806
msgid ""
"Accessing :attr:`~function.__code__` raises an :ref:`auditing event "
"<auditing>` ``object.__getattr__`` with arguments ``obj`` and "
"``\"__code__\"``."
msgstr ""
"Accessing :attr:`~function.__code__` raises an :ref:`auditing event "
"<auditing>``object.__getattr__`` with arguments ``obj`` and ``\"__code__\"``."

#: ../../library/stdtypes.rst:5813
msgid ""
"A code object can be executed or evaluated by passing it (instead of a "
"source string) to the :func:`exec` or :func:`eval`  built-in functions."
msgstr ""
"Ett kodobjekt kan exekveras eller utvärderas genom att skicka det (i stället "
"för en källsträng) till de inbyggda funktionerna :func:`exec` eller :func:"
"`eval`."

#: ../../library/stdtypes.rst:5816
msgid "See :ref:`types` for more information."
msgstr "Se :ref:`types` för mer information."

#: ../../library/stdtypes.rst:5822
msgid "Type Objects"
msgstr "Typ av objekt"

#: ../../library/stdtypes.rst:5828
msgid ""
"Type objects represent the various object types.  An object's type is "
"accessed by the built-in function :func:`type`.  There are no special "
"operations on types.  The standard module :mod:`types` defines names for all "
"standard built-in types."
msgstr ""
"Typobjekt representerar de olika objekttyperna.  Ett objekts typ nås med den "
"inbyggda funktionen :func:`type`.  Det finns inga speciella operationer på "
"typer.  Standardmodulen :mod:`types` definierar namn för alla inbyggda "
"standardtyper."

#: ../../library/stdtypes.rst:5833
msgid "Types are written like this: ``<class 'int'>``."
msgstr "Typer skrivs på detta sätt: ``<klass 'int'>``."

#: ../../library/stdtypes.rst:5839
msgid "The Null Object"
msgstr "Null-objektet"

#: ../../library/stdtypes.rst:5841
msgid ""
"This object is returned by functions that don't explicitly return a value.  "
"It supports no special operations.  There is exactly one null object, named "
"``None`` (a built-in name).  ``type(None)()`` produces the same singleton."
msgstr ""
"Detta objekt returneras av funktioner som inte uttryckligen returnerar ett "
"värde.  Det stöder inga speciella operationer.  Det finns exakt ett null-"
"objekt, med namnet ``None`` (ett inbyggt namn).  ``type(None)()`` producerar "
"samma singleton."

#: ../../library/stdtypes.rst:5845
msgid "It is written as ``None``."
msgstr "Det är skrivet som ``None``."

#: ../../library/stdtypes.rst:5852
msgid "The Ellipsis Object"
msgstr "Ellipsis-objektet"

#: ../../library/stdtypes.rst:5854
msgid ""
"This object is commonly used by slicing (see :ref:`slicings`).  It supports "
"no special operations.  There is exactly one ellipsis object, named :const:"
"`Ellipsis` (a built-in name).  ``type(Ellipsis)()`` produces the :const:"
"`Ellipsis` singleton."
msgstr ""
"Detta objekt används vanligen vid skivning (se :ref:`slicings`).  Det stöder "
"inga speciella operationer.  Det finns exakt ett ellipsis-objekt, med "
"namnet :const:`Ellipsis` (ett inbyggt namn).  ``type(Ellipsis)()`` "
"producerar :const:`Ellipsis` singleton."

#: ../../library/stdtypes.rst:5859
msgid "It is written as ``Ellipsis`` or ``...``."
msgstr "Det skrivs som ``Ellipsis`` eller ``...``."

#: ../../library/stdtypes.rst:5865
msgid "The NotImplemented Object"
msgstr "Det icke implementerade objektet"

#: ../../library/stdtypes.rst:5867
msgid ""
"This object is returned from comparisons and binary operations when they are "
"asked to operate on types they don't support. See :ref:`comparisons` for "
"more information.  There is exactly one :data:`NotImplemented` object. :code:"
"`type(NotImplemented)()` produces the singleton instance."
msgstr ""
"Detta objekt returneras från jämförelser och binära operationer när de "
"ombeds att använda typer som de inte stöder. Se :ref:`comparisons` för mer "
"information.  Det finns exakt ett :data:`NotImplemented`-objekt. :code:"
"`type(NotImplemented)()` producerar singleton-instansen."

#: ../../library/stdtypes.rst:5872
msgid "It is written as :code:`NotImplemented`."
msgstr "Den är skriven som :code:`NotImplemented`."

#: ../../library/stdtypes.rst:5878
msgid "Internal Objects"
msgstr "Interna objekt"

#: ../../library/stdtypes.rst:5880
msgid ""
"See :ref:`types` for this information.  It describes :ref:`stack frame "
"objects <frame-objects>`, :ref:`traceback objects <traceback-objects>`, and "
"slice objects."
msgstr ""
"Se :ref:`types` för denna information.  Den beskriver :ref:``stack frame "
"objects <frame-objects>`, :ref:``traceback objects <traceback-objects>`, och "
"slice objects."

#: ../../library/stdtypes.rst:5888
msgid "Special Attributes"
msgstr "Särskilda egenskaper"

#: ../../library/stdtypes.rst:5890
msgid ""
"The implementation adds a few special read-only attributes to several object "
"types, where they are relevant.  Some of these are not reported by the :func:"
"`dir` built-in function."
msgstr ""
"Implementationen lägger till några speciella skrivskyddade attribut till "
"flera objekttyper, där de är relevanta.  Vissa av dessa rapporteras inte av "
"den inbyggda funktionen :func:`dir`."

#: ../../library/stdtypes.rst:5897
msgid ""
"The name of the class, function, method, descriptor, or generator instance."
msgstr ""
"Namnet på klassen, funktionen, metoden, deskriptorn eller generatorinstansen."

#: ../../library/stdtypes.rst:5903
msgid ""
"The :term:`qualified name` of the class, function, method, descriptor, or "
"generator instance."
msgstr ""
"Klassens, funktionens, metodens, deskriptorns eller generatorinstansens :"
"term:`kvalificerade namn`."

#: ../../library/stdtypes.rst:5911
msgid "The name of the module in which a class or function was defined."
msgstr "Namnet på den modul i vilken en klass eller funktion definierades."

#: ../../library/stdtypes.rst:5916
msgid ""
"The documentation string of a class or function, or ``None`` if undefined."
msgstr ""
"Dokumentationssträngen för en klass eller funktion, eller ``None`` om den är "
"odefinierad."

#: ../../library/stdtypes.rst:5921
msgid ""
"The :ref:`type parameters <type-params>` of generic classes, functions, and :"
"ref:`type aliases <type-aliases>`. For classes and functions that are not "
"generic, this will be an empty tuple."
msgstr ""
":ref:`typ-parametrarna <type-params>` för generiska klasser, funktioner och :"
"ref:`typ-alias <type-aliases>`. För klasser och funktioner som inte är "
"generiska kommer detta att vara en tom tupel."

#: ../../library/stdtypes.rst:5931
msgid "Integer string conversion length limitation"
msgstr "Längdbegränsning för konvertering av heltalssträngar"

#: ../../library/stdtypes.rst:5933
msgid ""
"CPython has a global limit for converting between :class:`int` and :class:"
"`str` to mitigate denial of service attacks. This limit *only* applies to "
"decimal or other non-power-of-two number bases. Hexadecimal, octal, and "
"binary conversions are unlimited. The limit can be configured."
msgstr ""
"CPython har en global gräns för konvertering mellan :class:`int` och :class:"
"`str` för att motverka överbelastningsattacker. Denna gräns gäller *endast* "
"för decimaltal eller andra talbaser som inte har två potenser. Hexadecimala, "
"oktala och binära konverteringar är obegränsade. Gränsen kan konfigureras."

#: ../../library/stdtypes.rst:5938
msgid ""
"The :class:`int` type in CPython is an arbitrary length number stored in "
"binary form (commonly known as a \"bignum\"). There exists no algorithm that "
"can convert a string to a binary integer or a binary integer to a string in "
"linear time, *unless* the base is a power of 2. Even the best known "
"algorithms for base 10 have sub-quadratic complexity. Converting a large "
"value such as ``int('1' * 500_000)`` can take over a second on a fast CPU."
msgstr ""
"Typen :class:`int` i CPython är ett tal av godtycklig längd som lagras i "
"binär form (allmänt känt som ett \"bignum\"). Det finns ingen algoritm som "
"kan konvertera en sträng till ett binärt heltal eller ett binärt heltal till "
"en sträng i linjär tid, *om inte* basen är en potens av 2. Även de mest "
"kända algoritmerna för bas 10 har subkvadratisk komplexitet. Att konvertera "
"ett stort värde som ``int('1' * 500_000)`` kan ta över en sekund på en snabb "
"CPU."

#: ../../library/stdtypes.rst:5945
msgid ""
"Limiting conversion size offers a practical way to avoid :cve:`2020-10735`."
msgstr ""
"Att begränsa konverteringsstorleken är ett praktiskt sätt att undvika :cve:"
"`2020-10735`."

#: ../../library/stdtypes.rst:5947
msgid ""
"The limit is applied to the number of digit characters in the input or "
"output string when a non-linear conversion algorithm would be involved.  "
"Underscores and the sign are not counted towards the limit."
msgstr ""
"Gränsen tillämpas på antalet siffertecken i in- eller utdatasträngen när en "
"icke-linjär konverteringsalgoritm skulle vara inblandad.  Underscorer och "
"tecknet räknas inte med i begränsningen."

#: ../../library/stdtypes.rst:5951
msgid ""
"When an operation would exceed the limit, a :exc:`ValueError` is raised:"
msgstr ""
"När en operation skulle överskrida gränsen genereras ett :exc:`ValueError`:"

#: ../../library/stdtypes.rst:5953
msgid ""
">>> import sys\n"
">>> sys.set_int_max_str_digits(4300)  # Illustrative, this is the default.\n"
">>> _ = int('2' * 5432)\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: Exceeds the limit (4300 digits) for integer string conversion: "
"value has 5432 digits; use sys.set_int_max_str_digits() to increase the "
"limit\n"
">>> i = int('2' * 4300)\n"
">>> len(str(i))\n"
"4300\n"
">>> i_squared = i*i\n"
">>> len(str(i_squared))\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: Exceeds the limit (4300 digits) for integer string conversion; "
"use sys.set_int_max_str_digits() to increase the limit\n"
">>> len(hex(i_squared))\n"
"7144\n"
">>> assert int(hex(i_squared), base=16) == i*i  # Hexadecimal is unlimited."
msgstr ""
">>> import sys\n"
">>> sys.set_int_max_str_digits(4300) # Illustrativt, detta är standard.\n"
">>> _ = int('2' * 5432)\n"
"Traceback (senaste anropet senast):\n"
"...\n"
"ValueError (värdefel): Överskrider gränsen (4300 siffror) för omvandling av "
"heltalssträngar: värdet har 5432 siffror; använd sys."
"set_int_max_str_digits() för att öka gränsen\n"
">>> i = int('2' * 4300)\n"
">>> len(str(i))\n"
"4300\n"
">>> i_squared = i*i\n"
">>> len(str(i_squared))\n"
"Traceback (senaste anropet senast):\n"
"...\n"
"ValueError (värdefel): Överskrider gränsen (4300 siffror) för omvandling av "
"heltalssträngar; använd sys.set_int_max_str_digits() för att öka gränsen\n"
">>> len(hex(i_squared))\n"
"7144\n"
">>> assert int(hex(i_squared), base=16) == i*i # Hexadecimal är obegränsad."

#: ../../library/stdtypes.rst:5973
msgid ""
"The default limit is 4300 digits as provided in :data:`sys.int_info."
"default_max_str_digits <sys.int_info>`. The lowest limit that can be "
"configured is 640 digits as provided in :data:`sys.int_info."
"str_digits_check_threshold <sys.int_info>`."
msgstr ""
"Standardgränsen är 4300 siffror enligt :data:`sys.int_info."
"default_max_str_digits <sys.int_info>`. Den lägsta gräns som kan "
"konfigureras är 640 siffror enligt :data:`sys.int_info."
"str_digits_check_threshold <sys.int_info>`."

#: ../../library/stdtypes.rst:5978
msgid "Verification:"
msgstr "Verifiering:"

#: ../../library/stdtypes.rst:5980
msgid ""
">>> import sys\n"
">>> assert sys.int_info.default_max_str_digits == 4300, sys.int_info\n"
">>> assert sys.int_info.str_digits_check_threshold == 640, sys.int_info\n"
">>> msg = int('578966293710682886880994035146873798396722250538762761564'\n"
"...           '9252925514383915483333812743580549779436104706260696366600'\n"
"...           '571186405732').to_bytes(53, 'big')\n"
"..."
msgstr ""
">>> importera sys\n"
">>> assert sys.int_info.default_max_str_digits == 4300, sys.int_info\n"
">>> assert sys.int_info.str_digits_check_threshold == 640, sys.int_info\n"
">>> msg = int('578966293710682886880994035146873798396722250538762761564'\n"
"...           '9252925514383915483333812743580549779436104706260696366600'\n"
"...           '571186405732').to_bytes(53, 'big')\n"
"..."

#: ../../library/stdtypes.rst:5993
msgid "Affected APIs"
msgstr "Berörda API:er"

#: ../../library/stdtypes.rst:5995
msgid ""
"The limitation only applies to potentially slow conversions between :class:"
"`int` and :class:`str` or :class:`bytes`:"
msgstr ""
"Begränsningen gäller endast potentiellt långsamma konverteringar mellan :"
"class:`int` och :class:`str` eller :class:`bytes`:"

#: ../../library/stdtypes.rst:5998
msgid "``int(string)`` with default base 10."
msgstr "``int(sträng)`` med standardbas 10."

#: ../../library/stdtypes.rst:5999
msgid "``int(string, base)`` for all bases that are not a power of 2."
msgstr "``int(string, base)`` för alla baser som inte är en potens av 2."

#: ../../library/stdtypes.rst:6000
msgid "``str(integer)``."
msgstr "``str(heltal)``."

#: ../../library/stdtypes.rst:6001
msgid "``repr(integer)``."
msgstr "``repr(heltal)``."

#: ../../library/stdtypes.rst:6002
msgid ""
"any other string conversion to base 10, for example ``f\"{integer}\"``, "
"``\"{}\".format(integer)``, or ``b\"%d\" % integer``."
msgstr ""
"någon annan strängkonvertering till bas 10, till exempel ``f\"{integer}\"``, "
"``\"{}\".format(integer)``, eller ``b\"%d\" % integer``."

#: ../../library/stdtypes.rst:6005
msgid "The limitations do not apply to functions with a linear algorithm:"
msgstr "Begränsningarna gäller inte för funktioner med en linjär algoritm:"

#: ../../library/stdtypes.rst:6007
msgid "``int(string, base)`` with base 2, 4, 8, 16, or 32."
msgstr "``int(sträng, bas)`` med bas 2, 4, 8, 16 eller 32."

#: ../../library/stdtypes.rst:6008
msgid ":func:`int.from_bytes` and :func:`int.to_bytes`."
msgstr ":func:`int.from_bytes` och :func:`int.to_bytes`."

#: ../../library/stdtypes.rst:6009
msgid ":func:`hex`, :func:`oct`, :func:`bin`."
msgstr ":func:`hex`, :func:`oct`, :func:`bin`."

#: ../../library/stdtypes.rst:6010
msgid ":ref:`formatspec` for hex, octal, and binary numbers."
msgstr ":ref:`formatspec` för hex-, oktal- och binära tal."

#: ../../library/stdtypes.rst:6011
msgid ":class:`str` to :class:`float`."
msgstr ":class:`str` till :class:`float`."

#: ../../library/stdtypes.rst:6012
msgid ":class:`str` to :class:`decimal.Decimal`."
msgstr ":class:`str` till :class:`decimal.Decimal`."

#: ../../library/stdtypes.rst:6015
msgid "Configuring the limit"
msgstr "Konfigurera gränsvärdet"

#: ../../library/stdtypes.rst:6017
msgid ""
"Before Python starts up you can use an environment variable or an "
"interpreter command line flag to configure the limit:"
msgstr ""
"Innan Python startar kan du använda en miljövariabel eller en "
"kommandoradsflagga för tolken för att konfigurera gränsen:"

#: ../../library/stdtypes.rst:6020
msgid ""
":envvar:`PYTHONINTMAXSTRDIGITS`, e.g. ``PYTHONINTMAXSTRDIGITS=640 python3`` "
"to set the limit to 640 or ``PYTHONINTMAXSTRDIGITS=0 python3`` to disable "
"the limitation."
msgstr ""
":envvar:`PYTHONINTMAXSTRDIGITS`, t.ex. ``PYTHONINTMAXSTRDIGITS=640 python3`` "
"för att sätta gränsen till 640 eller ``PYTHONINTMAXSTRDIGITS=0 python3`` för "
"att inaktivera begränsningen."

#: ../../library/stdtypes.rst:6023
msgid ""
":option:`-X int_max_str_digits <-X>`, e.g. ``python3 -X "
"int_max_str_digits=640``"
msgstr ""
":option:`-X int_max_str_digits <-X>`, t.ex. ``python3 -X "
"int_max_str_digits=640```"

#: ../../library/stdtypes.rst:6025
msgid ""
":data:`sys.flags.int_max_str_digits` contains the value of :envvar:"
"`PYTHONINTMAXSTRDIGITS` or :option:`-X int_max_str_digits <-X>`. If both the "
"env var and the ``-X`` option are set, the ``-X`` option takes precedence. A "
"value of *-1* indicates that both were unset, thus a value of :data:`sys."
"int_info.default_max_str_digits` was used during initialization."
msgstr ""
":data:`sys.flags.int_max_str_digits` innehåller värdet av :envvar:"
"`PYTHONINTMAXSTRDIGITS` eller :option:`-X int_max_str_digits <-X>`. Om både "
"env var och alternativet ``-X`` är inställda, har alternativet ``-X`` "
"företräde. Ett värde på *-1* indikerar att båda var oinställda, vilket "
"innebär att ett värde på :data:`sys.int_info.default_max_str_digits` "
"användes under initialiseringen."

#: ../../library/stdtypes.rst:6031
msgid ""
"From code, you can inspect the current limit and set a new one using these :"
"mod:`sys` APIs:"
msgstr ""
"Från kod kan du inspektera den aktuella gränsen och sätta en ny med hjälp av "
"dessa :mod:`sys` API:er:"

#: ../../library/stdtypes.rst:6034
msgid ""
":func:`sys.get_int_max_str_digits` and :func:`sys.set_int_max_str_digits` "
"are a getter and setter for the interpreter-wide limit. Subinterpreters have "
"their own limit."
msgstr ""
":func:`sys.get_int_max_str_digits` och :func:`sys.set_int_max_str_digits` är "
"en getter och setter för den tolkningsomfattande gränsen. Undertolkare har "
"sin egen gräns."

#: ../../library/stdtypes.rst:6038
msgid ""
"Information about the default and minimum can be found in :data:`sys."
"int_info`:"
msgstr ""
"Information om standard- och minimivärden finns i :data:`sys.int_info`:"

#: ../../library/stdtypes.rst:6040
msgid ""
":data:`sys.int_info.default_max_str_digits <sys.int_info>` is the compiled-"
"in default limit."
msgstr ""
":data:`sys.int_info.default_max_str_digits <sys.int_info>` är den "
"kompilerade standardgränsen."

#: ../../library/stdtypes.rst:6042
msgid ""
":data:`sys.int_info.str_digits_check_threshold <sys.int_info>` is the lowest "
"accepted value for the limit (other than 0 which disables it)."
msgstr ""
":data:`sys.int_info.str_digits_check_threshold <sys.int_info>` är det lägsta "
"accepterade värdet för gränsen (annat än 0 som inaktiverar den)."

#: ../../library/stdtypes.rst:6049
msgid ""
"Setting a low limit *can* lead to problems. While rare, code exists that "
"contains integer constants in decimal in their source that exceed the "
"minimum threshold. A consequence of setting the limit is that Python source "
"code containing decimal integer literals longer than the limit will "
"encounter an error during parsing, usually at startup time or import time or "
"even at installation time - anytime an up to date ``.pyc`` does not already "
"exist for the code. A workaround for source that contains such large "
"constants is to convert them to ``0x`` hexadecimal form as it has no limit."
msgstr ""
"Att sätta en låg gräns *kan* leda till problem. Även om det är sällsynt "
"finns det kod som innehåller heltalskonstanter i decimal i sin källa som "
"överskrider minimigränsen. En konsekvens av att sätta gränsen är att Python-"
"källkod som innehåller decimala heltalslitteraler som är längre än gränsen "
"kommer att stöta på ett fel under parsning, vanligtvis vid starttid eller "
"importtid eller till och med vid installationstid - när som helst en "
"uppdaterad ``.pyc`` inte redan finns för koden. En lösning för källkod som "
"innehåller så stora konstanter är att konvertera dem till hexadecimal form "
"``0x`` eftersom den inte har någon gräns."

#: ../../library/stdtypes.rst:6058
msgid ""
"Test your application thoroughly if you use a low limit. Ensure your tests "
"run with the limit set early via the environment or flag so that it applies "
"during startup and even during any installation step that may invoke Python "
"to precompile ``.py`` sources to ``.pyc`` files."
msgstr ""
"Testa din applikation noggrant om du använder en låg gräns. Se till att dina "
"tester körs med gränsen inställd tidigt via miljön eller flaggan så att den "
"gäller under uppstart och även under alla installationssteg som kan anropa "
"Python för att förkompilera ``.py``-källor till ``.pyc``-filer."

#: ../../library/stdtypes.rst:6064
msgid "Recommended configuration"
msgstr "Rekommenderad konfiguration"

#: ../../library/stdtypes.rst:6066
msgid ""
"The default :data:`sys.int_info.default_max_str_digits` is expected to be "
"reasonable for most applications. If your application requires a different "
"limit, set it from your main entry point using Python version agnostic code "
"as these APIs were added in security patch releases in versions before 3.12."
msgstr ""
"Standardvärdet :data:`sys.int_info.default_max_str_digits` förväntas vara "
"rimligt för de flesta applikationer. Om ditt program kräver en annan gräns, "
"ställ in den från din huvudingångspunkt med Python-version agnostisk kod "
"eftersom dessa API:er lades till i säkerhetsuppdateringar i versioner före "
"3.12."

#: ../../library/stdtypes.rst:6071
msgid "Example::"
msgstr "Exempel::"

#: ../../library/stdtypes.rst:6073
msgid ""
">>> import sys\n"
">>> if hasattr(sys, \"set_int_max_str_digits\"):\n"
"...     upper_bound = 68000\n"
"...     lower_bound = 4004\n"
"...     current_limit = sys.get_int_max_str_digits()\n"
"...     if current_limit == 0 or current_limit > upper_bound:\n"
"...         sys.set_int_max_str_digits(upper_bound)\n"
"...     elif current_limit < lower_bound:\n"
"...         sys.set_int_max_str_digits(lower_bound)"
msgstr ""
">>> import sys\n"
">>> if hasattr(sys, \"set_int_max_str_digits\"):\n"
"... övre_gräns = 68000\n"
"... lägre_gräns = 4004\n"
"... current_limit = sys.get_int_max_str_digits()\n"
"... om current_limit == 0 eller current_limit > upper_bound:\n"
"... sys.set_int_max_str_digits(övre_gräns)\n"
"... elif current_limit < lower_bound:\n"
"... sys.set_int_max_str_digits(lower_bound)"

#: ../../library/stdtypes.rst:6083
msgid "If you need to disable it entirely, set it to ``0``."
msgstr "Om du behöver inaktivera det helt, ställ in det på ``0``."

#: ../../library/stdtypes.rst:6087
msgid "Footnotes"
msgstr "Fotnoter"

#: ../../library/stdtypes.rst:6088
msgid ""
"Additional information on these special methods may be found in the Python "
"Reference Manual (:ref:`customization`)."
msgstr ""
"Ytterligare information om dessa specialmetoder finns i Pythons "
"referensmanual (:ref:`customization`)."

#: ../../library/stdtypes.rst:6091
msgid ""
"As a consequence, the list ``[1, 2]`` is considered equal to ``[1.0, 2.0]``, "
"and similarly for tuples."
msgstr ""
"Som en följd av detta betraktas listan ``[1, 2]`` som lika med ``[1.0, "
"2.0]``, och på samma sätt för tupler."

#: ../../library/stdtypes.rst:6094
msgid "They must have since the parser can't tell the type of the operands."
msgstr ""
"Det måste de ha gjort eftersom parsern inte kan avgöra typen av operander."

#: ../../library/stdtypes.rst:6096
msgid ""
"Cased characters are those with general category property being one of "
"\"Lu\" (Letter, uppercase), \"Ll\" (Letter, lowercase), or \"Lt\" (Letter, "
"titlecase)."
msgstr ""
"Bokstäver med versaler är tecken som har en allmän kategoriegenskap som är "
"en av \"Lu\" (bokstav, versal), \"Ll\" (bokstav, gemen) eller "
"\"Lt\" (bokstav, titelbokstav)."

#: ../../library/stdtypes.rst:6099
msgid ""
"To format only a tuple you should therefore provide a singleton tuple whose "
"only element is the tuple to be formatted."
msgstr ""
"För att formatera endast en tupel bör du därför tillhandahålla en singleton-"
"tupel vars enda element är den tupel som ska formateras."

#: ../../library/stdtypes.rst:13
msgid "built-in"
msgstr "inbyggd"

#: ../../library/stdtypes.rst:13 ../../library/stdtypes.rst:322
#: ../../library/stdtypes.rst:399 ../../library/stdtypes.rst:992
#: ../../library/stdtypes.rst:1162 ../../library/stdtypes.rst:1184
#: ../../library/stdtypes.rst:1199 ../../library/stdtypes.rst:4833
#: ../../library/stdtypes.rst:5824
msgid "types"
msgstr "typer"

#: ../../library/stdtypes.rst:34 ../../library/stdtypes.rst:1199
#: ../../library/stdtypes.rst:4833
msgid "statement"
msgstr "uttalande"

#: ../../library/stdtypes.rst:34
msgid "if"
msgstr "om"

#: ../../library/stdtypes.rst:34
msgid "while"
msgstr "medan"

#: ../../library/stdtypes.rst:34
msgid "truth"
msgstr "sanning"

#: ../../library/stdtypes.rst:34
msgid "value"
msgstr "värde"

#: ../../library/stdtypes.rst:34 ../../library/stdtypes.rst:81
#: ../../library/stdtypes.rst:208 ../../library/stdtypes.rst:859
msgid "Boolean"
msgstr "Boolean"

#: ../../library/stdtypes.rst:34 ../../library/stdtypes.rst:81
#: ../../library/stdtypes.rst:399
msgid "operations"
msgstr "verksamhet"

#: ../../library/stdtypes.rst:34
msgid "false"
msgstr "falskt"

#: ../../library/stdtypes.rst:44
msgid "true"
msgstr "sant"

#: ../../library/stdtypes.rst:52
msgid "None (Built-in object)"
msgstr "Ingen (inbyggt objekt)"

#: ../../library/stdtypes.rst:52
msgid "False (Built-in object)"
msgstr "False (Inbyggt objekt)"

#: ../../library/stdtypes.rst:64 ../../library/stdtypes.rst:98
#: ../../library/stdtypes.rst:123 ../../library/stdtypes.rst:195
#: ../../library/stdtypes.rst:249 ../../library/stdtypes.rst:399
#: ../../library/stdtypes.rst:992
msgid "operator"
msgstr "operatör"

#: ../../library/stdtypes.rst:64 ../../library/stdtypes.rst:98
msgid "or"
msgstr "eller"

#: ../../library/stdtypes.rst:64 ../../library/stdtypes.rst:98
msgid "and"
msgstr "och"

#: ../../library/stdtypes.rst:64 ../../library/stdtypes.rst:859
msgid "False"
msgstr "Falskt"

#: ../../library/stdtypes.rst:64 ../../library/stdtypes.rst:859
msgid "True"
msgstr "Sant"

#: ../../library/stdtypes.rst:98
msgid "not"
msgstr "inte"

#: ../../library/stdtypes.rst:123
msgid "chaining"
msgstr "kedja"

#: ../../library/stdtypes.rst:123
msgid "comparisons"
msgstr "jämförelser"

#: ../../library/stdtypes.rst:123
msgid "comparison"
msgstr "jämförelse"

#: ../../library/stdtypes.rst:123
msgid "=="
msgstr "=="

#: ../../library/stdtypes.rst:123
msgid "< (less)"
msgstr "< (mindre)"

#: ../../library/stdtypes.rst:123
msgid "<="
msgstr "<="

#: ../../library/stdtypes.rst:123
msgid "> (greater)"
msgstr "> (större)"

#: ../../library/stdtypes.rst:123
msgid ">="
msgstr ">="

#: ../../library/stdtypes.rst:123
msgid "!="
msgstr "!="

#: ../../library/stdtypes.rst:123
msgid "is"
msgstr "är"

#: ../../library/stdtypes.rst:123
msgid "is not"
msgstr "är inte"

#: ../../library/stdtypes.rst:163 ../../library/stdtypes.rst:208
#: ../../library/stdtypes.rst:976 ../../library/stdtypes.rst:1162
#: ../../library/stdtypes.rst:1184 ../../library/stdtypes.rst:1309
#: ../../library/stdtypes.rst:1388 ../../library/stdtypes.rst:1432
#: ../../library/stdtypes.rst:1553 ../../library/stdtypes.rst:1683
#: ../../library/stdtypes.rst:2866 ../../library/stdtypes.rst:2885
#: ../../library/stdtypes.rst:2996 ../../library/stdtypes.rst:4631
#: ../../library/stdtypes.rst:4833 ../../library/stdtypes.rst:5313
#: ../../library/stdtypes.rst:5569 ../../library/stdtypes.rst:5744
#: ../../library/stdtypes.rst:5788
msgid "object"
msgstr "objekt"

#: ../../library/stdtypes.rst:163 ../../library/stdtypes.rst:208
#: ../../library/stdtypes.rst:229 ../../library/stdtypes.rst:322
#: ../../library/stdtypes.rst:341
msgid "numeric"
msgstr "numeriska"

#: ../../library/stdtypes.rst:163
msgid "objects"
msgstr "objekt"

#: ../../library/stdtypes.rst:163
msgid "comparing"
msgstr "jämförelse"

#: ../../library/stdtypes.rst:173
msgid "__eq__() (instance method)"
msgstr "__eq__() (instansmetod)"

#: ../../library/stdtypes.rst:173
msgid "__ne__() (instance method)"
msgstr "__ne__() (instansmetod)"

#: ../../library/stdtypes.rst:173
msgid "__lt__() (instance method)"
msgstr "__lt__() (instansmetod)"

#: ../../library/stdtypes.rst:173
msgid "__le__() (instance method)"
msgstr "__le__() (instansmetod)"

#: ../../library/stdtypes.rst:173
msgid "__gt__() (instance method)"
msgstr "__gt__() (instansmetod)"

#: ../../library/stdtypes.rst:173
msgid "__ge__() (instance method)"
msgstr "__ge__() (instansmetod)"

#: ../../library/stdtypes.rst:195 ../../library/stdtypes.rst:992
msgid "in"
msgstr "i"

#: ../../library/stdtypes.rst:195 ../../library/stdtypes.rst:992
msgid "not in"
msgstr "inte i"

#: ../../library/stdtypes.rst:208 ../../library/stdtypes.rst:229
#: ../../library/stdtypes.rst:399
msgid "integer"
msgstr "heltal"

#: ../../library/stdtypes.rst:208 ../../library/stdtypes.rst:229
msgid "floating-point"
msgstr "flyttal"

#: ../../library/stdtypes.rst:208 ../../library/stdtypes.rst:229
msgid "complex number"
msgstr "komplext tal"

#: ../../library/stdtypes.rst:208
msgid "C"
msgstr "C"

#: ../../library/stdtypes.rst:208
msgid "language"
msgstr "språk"

#: ../../library/stdtypes.rst:229
msgid "literals"
msgstr "bokstäver"

#: ../../library/stdtypes.rst:229
msgid "hexadecimal"
msgstr "hexadecimal"

#: ../../library/stdtypes.rst:229
msgid "octal"
msgstr "oktal"

#: ../../library/stdtypes.rst:229
msgid "binary"
msgstr "binär"

#: ../../library/stdtypes.rst:249
msgid "arithmetic"
msgstr "aritmetisk"

#: ../../library/stdtypes.rst:249 ../../library/stdtypes.rst:992
#: ../../library/stdtypes.rst:1162 ../../library/stdtypes.rst:4833
#: ../../library/stdtypes.rst:5795 ../../library/stdtypes.rst:5809
#: ../../library/stdtypes.rst:5824
msgid "built-in function"
msgstr "inbyggd funktion"

#: ../../library/stdtypes.rst:249
msgid "int"
msgstr "int"

#: ../../library/stdtypes.rst:249
msgid "float"
msgstr "flyt"

#: ../../library/stdtypes.rst:249
msgid "complex"
msgstr "komplex"

#: ../../library/stdtypes.rst:249 ../../library/stdtypes.rst:2742
#: ../../library/stdtypes.rst:4001
msgid "+ (plus)"
msgstr "+ (plus)"

#: ../../library/stdtypes.rst:249
msgid "unary operator"
msgstr "unär operator"

#: ../../library/stdtypes.rst:249
msgid "binary operator"
msgstr "binär operatör"

#: ../../library/stdtypes.rst:249 ../../library/stdtypes.rst:2742
#: ../../library/stdtypes.rst:4001
msgid "- (minus)"
msgstr "- (minus)"

#: ../../library/stdtypes.rst:249 ../../library/stdtypes.rst:2699
#: ../../library/stdtypes.rst:3958
msgid "* (asterisk)"
msgstr "* (asterisk)"

#: ../../library/stdtypes.rst:249
msgid "/ (slash)"
msgstr "/ (snedstreck)"

#: ../../library/stdtypes.rst:249
msgid "//"
msgstr "//"

#: ../../library/stdtypes.rst:249 ../../library/stdtypes.rst:2663
#: ../../library/stdtypes.rst:3926
msgid "% (percent)"
msgstr "% (procent)"

#: ../../library/stdtypes.rst:249
msgid "**"
msgstr "**"

#: ../../library/stdtypes.rst:322 ../../library/stdtypes.rst:399
#: ../../library/stdtypes.rst:992 ../../library/stdtypes.rst:1199
#: ../../library/stdtypes.rst:4833
msgid "operations on"
msgstr "operationer på"

#: ../../library/stdtypes.rst:322
msgid "conjugate() (complex number method)"
msgstr "conjugate() (metod för komplexa tal)"

#: ../../library/stdtypes.rst:341 ../../library/stdtypes.rst:1749
#: ../../library/stdtypes.rst:2866 ../../library/stdtypes.rst:5824
msgid "module"
msgstr "modul"

#: ../../library/stdtypes.rst:341
msgid "math"
msgstr "matematik"

#: ../../library/stdtypes.rst:341
msgid "floor() (in module math)"
msgstr "floor() (i modul math)"

#: ../../library/stdtypes.rst:341
msgid "ceil() (in module math)"
msgstr "ceil() (i modul math)"

#: ../../library/stdtypes.rst:341
msgid "trunc() (in module math)"
msgstr "trunc() (i modul matematik)"

#: ../../library/stdtypes.rst:341
msgid "conversions"
msgstr "konverteringar"

#: ../../library/stdtypes.rst:399
msgid "bitwise"
msgstr "bitvis"

#: ../../library/stdtypes.rst:399
msgid "shifting"
msgstr "förskjutning"

#: ../../library/stdtypes.rst:399
msgid "masking"
msgstr "maskering"

#: ../../library/stdtypes.rst:399
msgid "| (vertical bar)"
msgstr "| (vertikal stapel)"

#: ../../library/stdtypes.rst:399
msgid "^ (caret)"
msgstr "^ (caret)"

#: ../../library/stdtypes.rst:399
msgid "& (ampersand)"
msgstr "& (ampersand)"

#: ../../library/stdtypes.rst:399
msgid "<<"
msgstr "<<"

#: ../../library/stdtypes.rst:399
msgid ">>"
msgstr ">>"

#: ../../library/stdtypes.rst:399
msgid "~ (tilde)"
msgstr "~ (tilde)"

#: ../../library/stdtypes.rst:859
msgid "values"
msgstr "värden"

#: ../../library/stdtypes.rst:889
msgid "iterator protocol"
msgstr "iteratorprotokoll"

#: ../../library/stdtypes.rst:889 ../../library/stdtypes.rst:5228
msgid "protocol"
msgstr "protokoll"

#: ../../library/stdtypes.rst:889
msgid "iterator"
msgstr "iterator"

#: ../../library/stdtypes.rst:889 ../../library/stdtypes.rst:976
#: ../../library/stdtypes.rst:992 ../../library/stdtypes.rst:1162
#: ../../library/stdtypes.rst:1184 ../../library/stdtypes.rst:1199
msgid "sequence"
msgstr "sekvens"

#: ../../library/stdtypes.rst:889
msgid "iteration"
msgstr "iteration"

#: ../../library/stdtypes.rst:889
msgid "container"
msgstr "behållare"

#: ../../library/stdtypes.rst:889
msgid "iteration over"
msgstr "iteration över"

#: ../../library/stdtypes.rst:992 ../../library/stdtypes.rst:4833
msgid "len"
msgstr "len"

#: ../../library/stdtypes.rst:992
msgid "min"
msgstr "min"

#: ../../library/stdtypes.rst:992
msgid "max"
msgstr "max"

#: ../../library/stdtypes.rst:992
msgid "concatenation"
msgstr "sammanfogning"

#: ../../library/stdtypes.rst:992
msgid "operation"
msgstr "drift"

#: ../../library/stdtypes.rst:992
msgid "repetition"
msgstr "upprepning"

#: ../../library/stdtypes.rst:992 ../../library/stdtypes.rst:1199
msgid "subscript"
msgstr "index"

#: ../../library/stdtypes.rst:992 ../../library/stdtypes.rst:1199
msgid "slice"
msgstr "skiva"

#: ../../library/stdtypes.rst:992
msgid "count() (sequence method)"
msgstr "count() (sekvensmetod)"

#: ../../library/stdtypes.rst:992
msgid "index() (sequence method)"
msgstr "index() (sekvensmetod)"

#: ../../library/stdtypes.rst:1048
msgid "loop"
msgstr "loop"

#: ../../library/stdtypes.rst:1048
msgid "over mutable sequence"
msgstr "över muterbar sekvens"

#: ../../library/stdtypes.rst:1048
msgid "mutable sequence"
msgstr "muterbar sekvens"

#: ../../library/stdtypes.rst:1048
msgid "loop over"
msgstr "loopa över"

#: ../../library/stdtypes.rst:1162
msgid "immutable"
msgstr "oföränderlig"

#: ../../library/stdtypes.rst:1162 ../../library/stdtypes.rst:1388
msgid "tuple"
msgstr "tupel"

#: ../../library/stdtypes.rst:1162
msgid "hash"
msgstr "hash"

#: ../../library/stdtypes.rst:1184
msgid "mutable"
msgstr "föränderlig"

#: ../../library/stdtypes.rst:1184 ../../library/stdtypes.rst:1199
#: ../../library/stdtypes.rst:1309
msgid "list"
msgstr "lista"

#: ../../library/stdtypes.rst:1184 ../../library/stdtypes.rst:2866
#: ../../library/stdtypes.rst:2996 ../../library/stdtypes.rst:3104
#: ../../library/stdtypes.rst:3926
msgid "bytearray"
msgstr "bytearray"

#: ../../library/stdtypes.rst:1199 ../../library/stdtypes.rst:4833
#: ../../library/stdtypes.rst:5569 ../../library/stdtypes.rst:5824
msgid "type"
msgstr "typ"

#: ../../library/stdtypes.rst:1199
msgid "assignment"
msgstr "uppgift"

#: ../../library/stdtypes.rst:1199 ../../library/stdtypes.rst:4833
msgid "del"
msgstr "rad"

#: ../../library/stdtypes.rst:1199
msgid "append() (sequence method)"
msgstr "append() (sekvensmetod)"

#: ../../library/stdtypes.rst:1199
msgid "clear() (sequence method)"
msgstr "clear() (sekvensmetod)"

#: ../../library/stdtypes.rst:1199
msgid "copy() (sequence method)"
msgstr "copy() (sekvensmetod)"

#: ../../library/stdtypes.rst:1199
msgid "extend() (sequence method)"
msgstr "extend() (sekvensmetod)"

#: ../../library/stdtypes.rst:1199
msgid "insert() (sequence method)"
msgstr "insert() (sekvensmetod)"

#: ../../library/stdtypes.rst:1199
msgid "pop() (sequence method)"
msgstr "pop() (sekvensmetod)"

#: ../../library/stdtypes.rst:1199
msgid "remove() (sequence method)"
msgstr "remove() (sekvensmetod)"

#: ../../library/stdtypes.rst:1199
msgid "reverse() (sequence method)"
msgstr "reverse() (sekvensmetod)"

#: ../../library/stdtypes.rst:1432
msgid "range"
msgstr "intervall"

#: ../../library/stdtypes.rst:1553 ../../library/stdtypes.rst:1696
#: ../../library/stdtypes.rst:1741 ../../library/stdtypes.rst:2517
#: ../../library/stdtypes.rst:2663
msgid "string"
msgstr "sträng"

#: ../../library/stdtypes.rst:1553
msgid "text sequence type"
msgstr "text sekvens typ"

#: ../../library/stdtypes.rst:1553 ../../library/stdtypes.rst:1696
#: ../../library/stdtypes.rst:1714
msgid "str (built-in class)"
msgstr "str (inbyggd klass)"

#: ../../library/stdtypes.rst:1553
msgid "(see also string)"
msgstr "(se även sträng)"

#: ../../library/stdtypes.rst:1683
msgid "io.StringIO"
msgstr "io.StringIO"

#: ../../library/stdtypes.rst:1714 ../../library/stdtypes.rst:2858
msgid "buffer protocol"
msgstr "buffertprotokoll"

#: ../../library/stdtypes.rst:1714 ../../library/stdtypes.rst:2866
#: ../../library/stdtypes.rst:2885 ../../library/stdtypes.rst:3104
#: ../../library/stdtypes.rst:3926
msgid "bytes"
msgstr "byte"

#: ../../library/stdtypes.rst:1741 ../../library/stdtypes.rst:3104
msgid "methods"
msgstr "metoder"

#: ../../library/stdtypes.rst:1749
msgid "re"
msgstr "re"

#: ../../library/stdtypes.rst:2331 ../../library/stdtypes.rst:3780
msgid "universal newlines"
msgstr "universella nya rader"

#: ../../library/stdtypes.rst:2331
msgid "str.splitlines method"
msgstr "str.splitlines-metoden"

#: ../../library/stdtypes.rst:2517
msgid "! formatted string literal"
msgstr "! formaterad sträng bokstavlig"

#: ../../library/stdtypes.rst:2517
msgid "formatted string literals"
msgstr "formaterade stränglitteraler"

#: ../../library/stdtypes.rst:2517
msgid "! f-string"
msgstr "! f-sträng"

#: ../../library/stdtypes.rst:2517
msgid "f-strings"
msgstr "f-strängar"

#: ../../library/stdtypes.rst:2517
msgid "fstring"
msgstr "fsträng"

#: ../../library/stdtypes.rst:2517
msgid "interpolated string literal"
msgstr "interpolerad sträng bokstavlig"

#: ../../library/stdtypes.rst:2517
msgid "formatted literal"
msgstr "formaterad bokstav"

#: ../../library/stdtypes.rst:2517
msgid "interpolated literal"
msgstr "interpolerad bokstavlig"

#: ../../library/stdtypes.rst:2517
msgid "{} (curly brackets)"
msgstr "{} (inom hakparentes)"

#: ../../library/stdtypes.rst:2517
msgid "in formatted string literal"
msgstr "i formaterad sträng bokstavlig"

#: ../../library/stdtypes.rst:2517
msgid "! (exclamation mark)"
msgstr "! (utropstecken)"

#: ../../library/stdtypes.rst:2517
msgid ": (colon)"
msgstr ": (kolon)"

#: ../../library/stdtypes.rst:2517
msgid "= (equals)"
msgstr "= (lika med)"

#: ../../library/stdtypes.rst:2517
msgid "for help in debugging using string literals"
msgstr "för hjälp med felsökning med hjälp av stränglitteraler"

#: ../../library/stdtypes.rst:2663
msgid "formatting, string (%)"
msgstr "formatering, sträng (%)"

#: ../../library/stdtypes.rst:2663
msgid "interpolation, string (%)"
msgstr "interpolation, sträng (%)"

#: ../../library/stdtypes.rst:2663
msgid "formatting, printf"
msgstr "formatering, printf"

#: ../../library/stdtypes.rst:2663
msgid "interpolation, printf"
msgstr "interpolation, printf"

#: ../../library/stdtypes.rst:2663 ../../library/stdtypes.rst:3926
msgid "printf-style formatting"
msgstr "formatering i printf-stil"

#: ../../library/stdtypes.rst:2663 ../../library/stdtypes.rst:3926
msgid "sprintf-style formatting"
msgstr "formatering i sprintf-stil"

#: ../../library/stdtypes.rst:2699 ../../library/stdtypes.rst:3958
msgid "() (parentheses)"
msgstr "() (inom parentes)"

#: ../../library/stdtypes.rst:2699 ../../library/stdtypes.rst:2742
#: ../../library/stdtypes.rst:3958 ../../library/stdtypes.rst:4001
msgid "in printf-style formatting"
msgstr "i formatering i printf-stil"

#: ../../library/stdtypes.rst:2699 ../../library/stdtypes.rst:3958
msgid ". (dot)"
msgstr ". (punkt)"

#: ../../library/stdtypes.rst:2742 ../../library/stdtypes.rst:4001
msgid "# (hash)"
msgstr "# (hash)"

#: ../../library/stdtypes.rst:2742 ../../library/stdtypes.rst:4001
msgid "space"
msgstr "tid"

#: ../../library/stdtypes.rst:2858
msgid "binary sequence types"
msgstr "binära sekvenstyper"

#: ../../library/stdtypes.rst:2866
msgid "memoryview"
msgstr "minnesvy"

#: ../../library/stdtypes.rst:2866
msgid "array"
msgstr "array"

#: ../../library/stdtypes.rst:3780
msgid "bytes.splitlines method"
msgstr "bytes.splitlines-metoden"

#: ../../library/stdtypes.rst:3780
msgid "bytearray.splitlines method"
msgstr "bytearray.splitlines-metoden"

#: ../../library/stdtypes.rst:3926
msgid "formatting"
msgstr "formatering"

#: ../../library/stdtypes.rst:3926
msgid "bytes (%)"
msgstr "byte (%)"

#: ../../library/stdtypes.rst:3926
msgid "bytearray (%)"
msgstr "bytearray (%)"

#: ../../library/stdtypes.rst:3926
msgid "interpolation"
msgstr "interpolering"

#: ../../library/stdtypes.rst:4631
msgid "set"
msgstr "set"

#: ../../library/stdtypes.rst:4833
msgid "mapping"
msgstr "kartläggning"

#: ../../library/stdtypes.rst:4833
msgid "dictionary"
msgstr "ordbok"

#: ../../library/stdtypes.rst:4943
msgid "__missing__()"
msgstr "__missing__()"

#: ../../library/stdtypes.rst:5228
msgid "context manager"
msgstr "kontexthanterare"

#: ../../library/stdtypes.rst:5228
msgid "context management protocol"
msgstr "protokoll för kontexthantering"

#: ../../library/stdtypes.rst:5228
msgid "context management"
msgstr "hantering av sammanhang"

#: ../../library/stdtypes.rst:5301
msgid "annotation"
msgstr "anteckning"

#: ../../library/stdtypes.rst:5301
msgid "type annotation; type hint"
msgstr "typ anteckning; typ ledtråd"

#: ../../library/stdtypes.rst:5313
msgid "GenericAlias"
msgstr "GeneriskAlias"

#: ../../library/stdtypes.rst:5313
msgid "Generic"
msgstr "Allmän"

#: ../../library/stdtypes.rst:5313
msgid "Alias"
msgstr "Alias"

#: ../../library/stdtypes.rst:5569
msgid "Union"
msgstr "Förening"

#: ../../library/stdtypes.rst:5569
msgid "union"
msgstr "forbund"

#: ../../library/stdtypes.rst:5744
msgid "method"
msgstr "metod"

#: ../../library/stdtypes.rst:5788
msgid "code"
msgstr "kod"

#: ../../library/stdtypes.rst:5788
msgid "code object"
msgstr "kodobjekt"

#: ../../library/stdtypes.rst:5795
msgid "compile"
msgstr "sammanställa"

#: ../../library/stdtypes.rst:5795
msgid "__code__ (function object attribute)"
msgstr "__code__ (funktion objektattribut)"

#: ../../library/stdtypes.rst:5809
msgid "exec"
msgstr "avrättning"

#: ../../library/stdtypes.rst:5809
msgid "eval"
msgstr "eval"

#: ../../library/stdtypes.rst:5848
msgid "..."
msgstr "..."

#: ../../library/stdtypes.rst:5848
msgid "ellipsis literal"
msgstr "ellips bokstavlig"
