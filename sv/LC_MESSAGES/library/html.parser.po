# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-01 14:13+0000\n"
"PO-Revision-Date: 2025-09-16 00:01+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../library/html.parser.rst:2
msgid ":mod:`!html.parser` --- Simple HTML and XHTML parser"
msgstr ":mod:`!html.parser` --- Enkel HTML- och XHTML-parser"

#: ../../library/html.parser.rst:7
msgid "**Source code:** :source:`Lib/html/parser.py`"
msgstr "**Källkod:** :source:`Lib/html/parser.py`"

#: ../../library/html.parser.rst:15
msgid ""
"This module defines a class :class:`HTMLParser` which serves as the basis "
"for parsing text files formatted in HTML (HyperText Mark-up Language) and "
"XHTML."
msgstr ""
"Den här modulen definierar en klass :class:`HTMLParser` som fungerar som bas "
"för parsning av textfiler formaterade i HTML (HyperText Mark-up Language) "
"och XHTML."

#: ../../library/html.parser.rst:20
msgid "Create a parser instance able to parse invalid markup."
msgstr "Skapa en parserinstans som kan parsa ogiltig markup."

#: ../../library/html.parser.rst:22
msgid ""
"If *convert_charrefs* is true (the default), all character references "
"(except the ones in elements like ``script`` and ``style``) are "
"automatically converted to the corresponding Unicode characters."
msgstr ""

#: ../../library/html.parser.rst:26
msgid ""
"If *scripting* is false (the default), the content of the ``noscript`` "
"element is parsed normally; if it's true, it's returned as is without being "
"parsed."
msgstr ""

#: ../../library/html.parser.rst:30
msgid ""
"An :class:`.HTMLParser` instance is fed HTML data and calls handler methods "
"when start tags, end tags, text, comments, and other markup elements are "
"encountered.  The user should subclass :class:`.HTMLParser` and override its "
"methods to implement the desired behavior."
msgstr ""
"En instans av :class:`.HTMLParser` matas med HTML-data och anropar "
"hanteringsmetoder när starttaggar, sluttaggar, text, kommentarer och andra "
"markeringselement påträffas.  Användaren bör subklassa :class:`.HTMLParser` "
"och åsidosätta dess metoder för att implementera önskat beteende."

#: ../../library/html.parser.rst:35
msgid ""
"This parser does not check that end tags match start tags or call the end-"
"tag handler for elements which are closed implicitly by closing an outer "
"element."
msgstr ""
"Denna parser kontrollerar inte att sluttaggar matchar starttaggar eller "
"anropar sluttagghanteraren för element som stängs implicit genom att stänga "
"ett yttre element."

#: ../../library/html.parser.rst:38
msgid "*convert_charrefs* keyword argument added."
msgstr "*convert_charrefs* nyckelordsargument tillagt."

#: ../../library/html.parser.rst:41
msgid "The default value for argument *convert_charrefs* is now ``True``."
msgstr "Standardvärdet för argumentet *convert_charrefs* är nu ``True``."

#: ../../library/html.parser.rst:44
msgid "Added the *scripting* parameter."
msgstr ""

#: ../../library/html.parser.rst:49
msgid "Example HTML Parser Application"
msgstr "Exempel på HTML Parser-applikation"

#: ../../library/html.parser.rst:51
msgid ""
"As a basic example, below is a simple HTML parser that uses the :class:"
"`HTMLParser` class to print out start tags, end tags, and data as they are "
"encountered:"
msgstr ""
"Som ett grundläggande exempel visas nedan en enkel HTML-parser som använder "
"klassen :class:`HTMLParser` för att skriva ut starttaggar, sluttaggar och "
"data när de påträffas:"

#: ../../library/html.parser.rst:55
msgid ""
"from html.parser import HTMLParser\n"
"\n"
"class MyHTMLParser(HTMLParser):\n"
"    def handle_starttag(self, tag, attrs):\n"
"        print(\"Encountered a start tag:\", tag)\n"
"\n"
"    def handle_endtag(self, tag):\n"
"        print(\"Encountered an end tag :\", tag)\n"
"\n"
"    def handle_data(self, data):\n"
"        print(\"Encountered some data  :\", data)\n"
"\n"
"parser = MyHTMLParser()\n"
"parser.feed('<html><head><title>Test</title></head>'\n"
"            '<body><h1>Parse me!</h1></body></html>')"
msgstr ""
"from html.parser import HTMLParser\n"
"\n"
"class MyHTMLParser(HTMLParser):\n"
"    def handle_starttag(self, tag, attrs):\n"
"        print(\"Encountered a start tag:\", tag)\n"
"\n"
"    def handle_endtag(self, tag):\n"
"        print(\"Encountered an end tag :\", tag)\n"
"\n"
"    def handle_data(self, data):\n"
"        print(\"Encountered some data  :\", data)\n"
"\n"
"parser = MyHTMLParser()\n"
"parser.feed('<html><head><title>Test</title></head>'\n"
"            '<body><h1>Parse me!</h1></body></html>')"

#: ../../library/html.parser.rst:73
msgid "The output will then be:"
msgstr "Utgången kommer då att vara:"

#: ../../library/html.parser.rst:75
msgid ""
"Encountered a start tag: html\n"
"Encountered a start tag: head\n"
"Encountered a start tag: title\n"
"Encountered some data  : Test\n"
"Encountered an end tag : title\n"
"Encountered an end tag : head\n"
"Encountered a start tag: body\n"
"Encountered a start tag: h1\n"
"Encountered some data  : Parse me!\n"
"Encountered an end tag : h1\n"
"Encountered an end tag : body\n"
"Encountered an end tag : html"
msgstr ""
"Encountered a start tag: html\n"
"Encountered a start tag: head\n"
"Encountered a start tag: title\n"
"Encountered some data  : Test\n"
"Encountered an end tag : title\n"
"Encountered an end tag : head\n"
"Encountered a start tag: body\n"
"Encountered a start tag: h1\n"
"Encountered some data  : Parse me!\n"
"Encountered an end tag : h1\n"
"Encountered an end tag : body\n"
"Encountered an end tag : html"

#: ../../library/html.parser.rst:92
msgid ":class:`.HTMLParser` Methods"
msgstr ":class:`.HTMLParser` Metoder"

#: ../../library/html.parser.rst:94
msgid ":class:`HTMLParser` instances have the following methods:"
msgstr ":class:`HTMLParser`\\-instanser har följande metoder:"

#: ../../library/html.parser.rst:99
msgid ""
"Feed some text to the parser.  It is processed insofar as it consists of "
"complete elements; incomplete data is buffered until more data is fed or :"
"meth:`close` is called.  *data* must be :class:`str`."
msgstr ""
"Mata in text till parsern.  Den bearbetas i den mån den består av "
"fullständiga element; ofullständiga data buffras tills mer data matas in "
"eller :meth:`close` anropas.  *data* måste vara :class:`str`."

#: ../../library/html.parser.rst:106
msgid ""
"Force processing of all buffered data as if it were followed by an end-of-"
"file mark.  This method may be redefined by a derived class to define "
"additional processing at the end of the input, but the redefined version "
"should always call the :class:`HTMLParser` base class method :meth:`close`."
msgstr ""
"Tvingar fram bearbetning av alla buffrade data som om de följdes av en "
"markering för slutet av filen.  Denna metod kan omdefinieras av en härledd "
"klass för att definiera ytterligare bearbetning i slutet av inmatningen, men "
"den omdefinierade versionen bör alltid anropa basklassmetoden :meth:`close` "
"i :class:`HTMLParser`."

#: ../../library/html.parser.rst:114
msgid ""
"Reset the instance.  Loses all unprocessed data.  This is called implicitly "
"at instantiation time."
msgstr ""
"Återställer instansen.  Förlorar alla obearbetade data.  Detta anropas "
"implicit vid instantieringstillfället."

#: ../../library/html.parser.rst:120
msgid "Return current line number and offset."
msgstr "Returnerar aktuellt radnummer och offset."

#: ../../library/html.parser.rst:125
msgid ""
"Return the text of the most recently opened start tag.  This should not "
"normally be needed for structured processing, but may be useful in dealing "
"with HTML \"as deployed\" or for re-generating input with minimal changes "
"(whitespace between attributes can be preserved, etc.)."
msgstr ""
"Returnerar texten i den senast öppnade starttaggen.  Detta bör normalt inte "
"behövas för strukturerad bearbetning, men kan vara användbart för att "
"hantera HTML \"som den är distribuerad\" eller för att återskapa indata med "
"minimala ändringar (blanksteg mellan attribut kan bevaras etc.)."

#: ../../library/html.parser.rst:131
msgid ""
"The following methods are called when data or markup elements are "
"encountered and they are meant to be overridden in a subclass.  The base "
"class implementations do nothing (except for :meth:`~HTMLParser."
"handle_startendtag`):"
msgstr ""
"Följande metoder anropas när data- eller markeringselement påträffas och de "
"är avsedda att åsidosättas i en underklass.  Basklassens implementationer "
"gör ingenting (förutom :meth:`~HTMLParser.handle_startendtag`):"

#: ../../library/html.parser.rst:138
msgid ""
"This method is called to handle the start tag of an element (e.g. ``<div "
"id=\"main\">``)."
msgstr ""
"Denna metod anropas för att hantera starttaggen för ett element (t.ex. "
"``<div id=\"main\">``)."

#: ../../library/html.parser.rst:140
msgid ""
"The *tag* argument is the name of the tag converted to lower case. The "
"*attrs* argument is a list of ``(name, value)`` pairs containing the "
"attributes found inside the tag's ``<>`` brackets.  The *name* will be "
"translated to lower case, and quotes in the *value* have been removed, and "
"character and entity references have been replaced."
msgstr ""
"Argumentet *tag* är namnet på taggen konverterat till gemener. Argumentet "
"*attrs* är en lista med paren ``(namn, värde)`` som innehåller de attribut "
"som finns inom taggens ``<>``\\-parenteser.  *name* översätts till gemener "
"och citattecken i *value* har tagits bort, och tecken- och "
"entitetsreferenser har ersatts."

#: ../../library/html.parser.rst:146
msgid ""
"For instance, for the tag ``<A HREF=\"https://www.cwi.nl/\">``, this method "
"would be called as ``handle_starttag('a', [('href', 'https://www.cwi."
"nl/')])``."
msgstr ""
"För taggen ``<A HREF=\"https://www.cwi.nl/\">`` skulle den här metoden till "
"exempel anropas som ``handle_starttag('a', [('href', 'https://www.cwi."
"nl/')])``."

#: ../../library/html.parser.rst:149
msgid ""
"All entity references from :mod:`html.entities` are replaced in the "
"attribute values."
msgstr ""
"Alla entitetsreferenser från :mod:`html.entities` ersätts i attributvärdena."

#: ../../library/html.parser.rst:155
msgid ""
"This method is called to handle the end tag of an element (e.g. ``</div>``)."
msgstr ""
"Denna metod anropas för att hantera sluttaggen för ett element (t.ex. ``</"
"div>``)."

#: ../../library/html.parser.rst:157
msgid "The *tag* argument is the name of the tag converted to lower case."
msgstr "Argumentet *tag* är namnet på taggen konverterat till gemener."

#: ../../library/html.parser.rst:162
msgid ""
"Similar to :meth:`handle_starttag`, but called when the parser encounters an "
"XHTML-style empty tag (``<img ... />``).  This method may be overridden by "
"subclasses which require this particular lexical information; the default "
"implementation simply calls :meth:`handle_starttag` and :meth:"
"`handle_endtag`."
msgstr ""
"Liknar :meth:`handle_starttag`, men anropas när parsern stöter på en tom "
"tagg i XHTML-stil (``<img ... />``).  Denna metod kan åsidosättas av "
"underklasser som kräver denna speciella lexikala information; "
"standardimplementationen anropar helt enkelt :meth:`handle_starttag` och :"
"meth:`handle_endtag`."

#: ../../library/html.parser.rst:170
msgid ""
"This method is called to process arbitrary data (e.g. text nodes and the "
"content of elements like ``script`` and ``style``)."
msgstr ""

#: ../../library/html.parser.rst:176
msgid ""
"This method is called to process a named character reference of the form "
"``&name;`` (e.g. ``&gt;``), where *name* is a general entity reference (e.g. "
"``'gt'``). This method is only called if *convert_charrefs* is false."
msgstr ""

#: ../../library/html.parser.rst:184
msgid ""
"This method is called to process decimal and hexadecimal numeric character "
"references of the form :samp:`&#{NNN};` and :samp:`&#x{NNN};`.  For example, "
"the decimal equivalent for ``&gt;`` is ``&#62;``, whereas the hexadecimal is "
"``&#x3E;``; in this case the method will receive ``'62'`` or ``'x3E'``. This "
"method is only called if *convert_charrefs* is false."
msgstr ""

#: ../../library/html.parser.rst:193
msgid ""
"This method is called when a comment is encountered (e.g. ``<!--comment--"
">``)."
msgstr ""
"Denna metod anropas när en kommentar påträffas (t.ex. ``<!--comment-->``)."

#: ../../library/html.parser.rst:195
msgid ""
"For example, the comment ``<!-- comment -->`` will cause this method to be "
"called with the argument ``' comment '``."
msgstr ""
"Exempelvis kommer kommentaren ``<!-- comment -->`` att leda till att denna "
"metod anropas med argumentet ``' comment '``."

#: ../../library/html.parser.rst:198
msgid ""
"The content of Internet Explorer conditional comments (condcoms) will also "
"be sent to this method, so, for ``<!--[if IE 9]>IE9-specific content<!"
"[endif]-->``, this method will receive ``'[if IE 9]>IE9-specific content<!"
"[endif]'``."
msgstr ""
"Innehållet i Internet Explorer villkorliga kommentarer (condcoms) kommer "
"också att skickas till denna metod, så för ``<!--[om IE 9]>IE9-specifikt "
"innehåll<![endif]-->`` kommer denna metod att få ``'[om IE 9]>IE9-specifikt "
"innehåll<![endif]'``."

#: ../../library/html.parser.rst:205
msgid ""
"This method is called to handle an HTML doctype declaration (e.g. ``<!"
"DOCTYPE html>``)."
msgstr ""
"Denna metod anropas för att hantera en HTML-doktypdeklaration (t.ex. ``<!"
"DOCTYPE html>``)."

#: ../../library/html.parser.rst:208
msgid ""
"The *decl* parameter will be the entire contents of the declaration inside "
"the ``<!...>`` markup (e.g. ``'DOCTYPE html'``)."
msgstr ""
"Parametern *decl* kommer att vara hela innehållet i deklarationen inuti "
"``<!...>``\\-markeringen (t.ex. ``'DOCTYPE html'``)."

#: ../../library/html.parser.rst:214
msgid ""
"Method called when a processing instruction is encountered.  The *data* "
"parameter will contain the entire processing instruction. For example, for "
"the processing instruction ``<?proc color='red'>``, this method would be "
"called as ``handle_pi(\"proc color='red'\")``.  It is intended to be "
"overridden by a derived class; the base class implementation does nothing."
msgstr ""
"Metod som anropas när en bearbetningsinstruktion påträffas.  Parametern "
"*data* kommer att innehålla hela bearbetningsinstruktionen. Till exempel, "
"för bearbetningsinstruktionen ``<?proc color='red'>``, skulle denna metod "
"anropas som ``handle_pi(\"proc color='red'\")``.  Den är avsedd att "
"åsidosättas av en härledd klass; basklassens implementering gör ingenting."

#: ../../library/html.parser.rst:222
msgid ""
"The :class:`HTMLParser` class uses the SGML syntactic rules for processing "
"instructions.  An XHTML processing instruction using the trailing ``'?'`` "
"will cause the ``'?'`` to be included in *data*."
msgstr ""
"Klassen :class:`HTMLParser` använder SGML:s syntaktiska regler för "
"bearbetningsinstruktioner.  En XHTML-bearbetningsinstruktion som använder "
"den efterföljande ``'?'`` kommer att leda till att ``'?'`` inkluderas i "
"*data*."

#: ../../library/html.parser.rst:229
msgid ""
"This method is called when an unrecognized declaration is read by the parser."
msgstr "Denna metod anropas när en oigenkänd deklaration läses av parsern."

#: ../../library/html.parser.rst:231
msgid ""
"The *data* parameter will be the entire contents of the declaration inside "
"the ``<![...]>`` markup.  It is sometimes useful to be overridden by a "
"derived class.  The base class implementation does nothing."
msgstr ""
"Parametern *data* kommer att vara hela innehållet i deklarationen inuti ``<!"
"[...]>``\\-markeringen.  Det är ibland användbart att åsidosättas av en "
"härledd klass.  Basklassens implementation gör ingenting."

#: ../../library/html.parser.rst:239
msgid "Examples"
msgstr "Exempel"

#: ../../library/html.parser.rst:241
msgid ""
"The following class implements a parser that will be used to illustrate more "
"examples:"
msgstr ""
"Följande klass implementerar en parser som kommer att användas för att "
"illustrera fler exempel:"

#: ../../library/html.parser.rst:244
msgid ""
"from html.parser import HTMLParser\n"
"from html.entities import name2codepoint\n"
"\n"
"class MyHTMLParser(HTMLParser):\n"
"    def handle_starttag(self, tag, attrs):\n"
"        print(\"Start tag:\", tag)\n"
"        for attr in attrs:\n"
"            print(\"     attr:\", attr)\n"
"\n"
"    def handle_endtag(self, tag):\n"
"        print(\"End tag  :\", tag)\n"
"\n"
"    def handle_data(self, data):\n"
"        print(\"Data     :\", data)\n"
"\n"
"    def handle_comment(self, data):\n"
"        print(\"Comment  :\", data)\n"
"\n"
"    def handle_entityref(self, name):\n"
"        c = chr(name2codepoint[name])\n"
"        print(\"Named ent:\", c)\n"
"\n"
"    def handle_charref(self, name):\n"
"        if name.startswith('x'):\n"
"            c = chr(int(name[1:], 16))\n"
"        else:\n"
"            c = chr(int(name))\n"
"        print(\"Num ent  :\", c)\n"
"\n"
"    def handle_decl(self, data):\n"
"        print(\"Decl     :\", data)\n"
"\n"
"parser = MyHTMLParser()"
msgstr ""
"from html.parser import HTMLParser\n"
"from html.entities import name2codepoint\n"
"\n"
"class MyHTMLParser(HTMLParser):\n"
"    def handle_starttag(self, tag, attrs):\n"
"        print(\"Start tag:\", tag)\n"
"        for attr in attrs:\n"
"            print(\"     attr:\", attr)\n"
"\n"
"    def handle_endtag(self, tag):\n"
"        print(\"End tag  :\", tag)\n"
"\n"
"    def handle_data(self, data):\n"
"        print(\"Data     :\", data)\n"
"\n"
"    def handle_comment(self, data):\n"
"        print(\"Comment  :\", data)\n"
"\n"
"    def handle_entityref(self, name):\n"
"        c = chr(name2codepoint[name])\n"
"        print(\"Named ent:\", c)\n"
"\n"
"    def handle_charref(self, name):\n"
"        if name.startswith('x'):\n"
"            c = chr(int(name[1:], 16))\n"
"        else:\n"
"            c = chr(int(name))\n"
"        print(\"Num ent  :\", c)\n"
"\n"
"    def handle_decl(self, data):\n"
"        print(\"Decl     :\", data)\n"
"\n"
"parser = MyHTMLParser()"

#: ../../library/html.parser.rst:280
msgid "Parsing a doctype:"
msgstr "Parsning av en doctype:"

#: ../../library/html.parser.rst:282
msgid ""
">>> parser.feed('<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" '\n"
"...             '\"http://www.w3.org/TR/html4/strict.dtd\">')\n"
"Decl     : DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3."
"org/TR/html4/strict.dtd\""
msgstr ""
">>> parser.feed('<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" '\n"
"...             '\"http://www.w3.org/TR/html4/strict.dtd\">')\n"
"Decl     : DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3."
"org/TR/html4/strict.dtd\""

#: ../../library/html.parser.rst:288
msgid "Parsing an element with a few attributes and a title:"
msgstr "Parsning av ett element med några attribut och en titel:"

#: ../../library/html.parser.rst:290
msgid ""
">>> parser.feed('<img src=\"python-logo.png\" alt=\"The Python logo\">')\n"
"Start tag: img\n"
"     attr: ('src', 'python-logo.png')\n"
"     attr: ('alt', 'The Python logo')\n"
">>>\n"
">>> parser.feed('<h1>Python</h1>')\n"
"Start tag: h1\n"
"Data     : Python\n"
"End tag  : h1"
msgstr ""
">>> parser.feed('<img src=\"python-logo.png\" alt=\"The Python logo\">')\n"
"Start tag: img\n"
"     attr: ('src', 'python-logo.png')\n"
"     attr: ('alt', 'The Python logo')\n"
">>>\n"
">>> parser.feed('<h1>Python</h1>')\n"
"Start tag: h1\n"
"Data     : Python\n"
"End tag  : h1"

#: ../../library/html.parser.rst:302
msgid ""
"The content of elements like ``script`` and ``style`` is returned as is, "
"without further parsing:"
msgstr ""

#: ../../library/html.parser.rst:305
msgid ""
">>> parser.feed('<style type=\"text/css\">#python { color: green }</"
"style>')\n"
"Start tag: style\n"
"     attr: ('type', 'text/css')\n"
"Data     : #python { color: green }\n"
"End tag  : style\n"
"\n"
">>> parser.feed('<script type=\"text/javascript\">'\n"
"...             'alert(\"<strong>hello! &#9786;</strong>\");</script>')\n"
"Start tag: script\n"
"     attr: ('type', 'text/javascript')\n"
"Data     : alert(\"<strong>hello! &#9786;</strong>\");\n"
"End tag  : script"
msgstr ""

#: ../../library/html.parser.rst:320
msgid "Parsing comments:"
msgstr "Analyserar kommentarer:"

#: ../../library/html.parser.rst:322
msgid ""
">>> parser.feed('<!--a comment-->'\n"
"...             '<!--[if IE 9]>IE-specific content<![endif]-->')\n"
"Comment  : a comment\n"
"Comment  : [if IE 9]>IE-specific content<![endif]"
msgstr ""
">>> parser.feed('<!--a comment-->'\n"
"...             '<!--[if IE 9]>IE-specific content<![endif]-->')\n"
"Comment  : a comment\n"
"Comment  : [if IE 9]>IE-specific content<![endif]"

#: ../../library/html.parser.rst:329
msgid ""
"Parsing named and numeric character references and converting them to the "
"correct char (note: these 3 references are all equivalent to ``'>'``):"
msgstr ""
"Parsning av namngivna och numeriska teckenreferenser och konvertering av dem "
"till rätt tecken (notera: dessa 3 referenser är alla likvärdiga med ``'>'``):"

#: ../../library/html.parser.rst:332
msgid ""
">>> parser = MyHTMLParser()\n"
">>> parser.feed('&gt;&#62;&#x3E;')\n"
"Data     : >>>\n"
"\n"
">>> parser = MyHTMLParser(convert_charrefs=False)\n"
">>> parser.feed('&gt;&#62;&#x3E;')\n"
"Named ent: >\n"
"Num ent  : >\n"
"Num ent  : >"
msgstr ""
">>> parser = MyHTMLParser()\n"
">>> parser.feed('&gt;&#62;&#x3E;')\n"
"Data     : >>>\n"
"\n"
">>> parser = MyHTMLParser(convert_charrefs=False)\n"
">>> parser.feed('&gt;&#62;&#x3E;')\n"
"Named ent: >\n"
"Num ent  : >\n"
"Num ent  : >"

#: ../../library/html.parser.rst:344
msgid ""
"Feeding incomplete chunks to :meth:`~HTMLParser.feed` works, but :meth:"
"`~HTMLParser.handle_data` might be called more than once if "
"*convert_charrefs* is false:"
msgstr ""

#: ../../library/html.parser.rst:348
msgid ""
">>> for chunk in ['<sp', 'an>buff', 'ered', ' text</s', 'pan>']:\n"
"...     parser.feed(chunk)\n"
"...\n"
"Start tag: span\n"
"Data     : buff\n"
"Data     : ered\n"
"Data     :  text\n"
"End tag  : span"
msgstr ""
">>> for chunk in ['<sp', 'an>buff', 'ered', ' text</s', 'pan>']:\n"
"...     parser.feed(chunk)\n"
"...\n"
"Start tag: span\n"
"Data     : buff\n"
"Data     : ered\n"
"Data     :  text\n"
"End tag  : span"

#: ../../library/html.parser.rst:359
msgid "Parsing invalid HTML (e.g. unquoted attributes) also works:"
msgstr ""
"Parsning av ogiltig HTML (t.ex. attribut som inte citeras) fungerar också:"

#: ../../library/html.parser.rst:361
msgid ""
">>> parser.feed('<p><a class=link href=#main>tag soup</p ></a>')\n"
"Start tag: p\n"
"Start tag: a\n"
"     attr: ('class', 'link')\n"
"     attr: ('href', '#main')\n"
"Data     : tag soup\n"
"End tag  : p\n"
"End tag  : a"
msgstr ""
">>> parser.feed('<p><a class=link href=#main>tag soup</p ></a>')\n"
"Start tag: p\n"
"Start tag: a\n"
"     attr: ('class', 'link')\n"
"     attr: ('href', '#main')\n"
"Data     : tag soup\n"
"End tag  : p\n"
"End tag  : a"

#: ../../library/html.parser.rst:9
msgid "HTML"
msgstr "HTML"

#: ../../library/html.parser.rst:9
msgid "XHTML"
msgstr "XHTML"
