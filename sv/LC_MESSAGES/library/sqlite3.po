# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2026, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-09 17:38+0000\n"
"PO-Revision-Date: 2025-09-22 15:58+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../library/sqlite3.rst:2
msgid ":mod:`sqlite3` --- DB-API 2.0 interface for SQLite databases"
msgstr ""

#: ../../library/sqlite3.rst:9
msgid "**Source code:** :source:`Lib/sqlite3/`"
msgstr "**Källkod:** :source:`Lib/sqlite3/`"

#: ../../library/sqlite3.rst:23
msgid ""
"SQLite is a C library that provides a lightweight disk-based database that "
"doesn't require a separate server process and allows accessing the database "
"using a nonstandard variant of the SQL query language. Some applications can "
"use SQLite for internal data storage.  It's also possible to prototype an "
"application using SQLite and then port the code to a larger database such as "
"PostgreSQL or Oracle."
msgstr ""
"SQLite är ett C-bibliotek som tillhandahåller en lättviktig diskbaserad "
"databas som inte kräver en separat serverprocess och som gör det möjligt att "
"komma åt databasen med en icke-standardvariant av frågespråket SQL. Vissa "
"applikationer kan använda SQLite för intern datalagring.  Det är också "
"möjligt att prototypa en applikation med SQLite och sedan porta koden till "
"en större databas som PostgreSQL eller Oracle."

#: ../../library/sqlite3.rst:30
msgid ""
"The :mod:`!sqlite3` module was written by Gerhard Häring.  It provides an "
"SQL interface compliant with the DB-API 2.0 specification described by :pep:"
"`249`, and requires SQLite 3.7.15 or newer."
msgstr ""

#: ../../library/sqlite3.rst:34
msgid "This document includes four main sections:"
msgstr "Detta dokument innehåller fyra huvudavsnitt:"

#: ../../library/sqlite3.rst:36
msgid ":ref:`sqlite3-tutorial` teaches how to use the :mod:`!sqlite3` module."
msgstr ""
":ref:`sqlite3-tutorial` lär ut hur man använder modulen :mod:`!sqlite3`."

#: ../../library/sqlite3.rst:37
msgid ""
":ref:`sqlite3-reference` describes the classes and functions this module "
"defines."
msgstr ""
":ref:`sqlite3-reference` beskriver de klasser och funktioner som denna modul "
"definierar."

#: ../../library/sqlite3.rst:39
msgid ":ref:`sqlite3-howtos` details how to handle specific tasks."
msgstr ":ref:`sqlite3-howtos` beskriver hur man hanterar specifika uppgifter."

#: ../../library/sqlite3.rst:40
msgid ""
":ref:`sqlite3-explanation` provides in-depth background on transaction "
"control."
msgstr ""
":ref:`sqlite3-explanation` ger en djupgående bakgrund till "
"transaktionskontroll."

#: ../../library/sqlite3.rst:47
msgid "https://www.sqlite.org"
msgstr "https://www.sqlite.org"

#: ../../library/sqlite3.rst:46
msgid ""
"The SQLite web page; the documentation describes the syntax and the "
"available data types for the supported SQL dialect."
msgstr ""
"SQLite-webbsidan; dokumentationen beskriver syntaxen och de tillgängliga "
"datatyperna för den SQL-dialekt som stöds."

#: ../../library/sqlite3.rst:50
msgid "https://www.w3schools.com/sql/"
msgstr "https://www.w3schools.com/sql/"

#: ../../library/sqlite3.rst:50
msgid "Tutorial, reference and examples for learning SQL syntax."
msgstr "Handledning, referens och exempel för att lära sig SQL-syntax."

#: ../../library/sqlite3.rst:52
msgid ":pep:`249` - Database API Specification 2.0"
msgstr ":pep:`249` - API-specifikation för databaser 2.0"

#: ../../library/sqlite3.rst:53
msgid "PEP written by Marc-André Lemburg."
msgstr "PEP skriven av Marc-André Lemburg."

#: ../../library/sqlite3.rst:66
msgid "Tutorial"
msgstr "Handledning"

#: ../../library/sqlite3.rst:68
msgid ""
"In this tutorial, you will create a database of Monty Python movies using "
"basic :mod:`!sqlite3` functionality. It assumes a fundamental understanding "
"of database concepts, including `cursors`_ and `transactions`_."
msgstr ""
"I den här handledningen skapar du en databas med Monty Python-filmer med "
"hjälp av grundläggande :mod:`!sqlite3`\\-funktionalitet. Den förutsätter en "
"grundläggande förståelse för databaskoncept, inklusive `cursors`_ och "
"`transactions`_."

#: ../../library/sqlite3.rst:73
msgid ""
"First, we need to create a new database and open a database connection to "
"allow :mod:`!sqlite3` to work with it. Call :func:`sqlite3.connect` to "
"create a connection to the database :file:`tutorial.db` in the current "
"working directory, implicitly creating it if it does not exist:"
msgstr ""
"Först måste vi skapa en ny databas och öppna en databasanslutning så att :"
"mod:`!sqlite3` kan arbeta med den. Anropa :func:`sqlite3.connect` för att "
"skapa en anslutning till databasen :file:`tutorial.db` i den aktuella "
"arbetskatalogen, och skapa den implicit om den inte finns:"

#: ../../library/sqlite3.rst:84
msgid ""
"The returned :class:`Connection` object ``con`` represents the connection to "
"the on-disk database."
msgstr ""
"Det returnerade :class:`Connection`\\-objektet ``con`` representerar "
"anslutningen till databasen på disken."

#: ../../library/sqlite3.rst:87
msgid ""
"In order to execute SQL statements and fetch results from SQL queries, we "
"will need to use a database cursor. Call :meth:`con.cursor() <Connection."
"cursor>` to create the :class:`Cursor`:"
msgstr ""
"För att kunna utföra SQL-satser och hämta resultat från SQL-frågor måste vi "
"använda en databascursor. Anropa :meth:`con.cursor() <Connection.cursor>` "
"för att skapa :class:`Cursor`:"

#: ../../library/sqlite3.rst:95
msgid ""
"Now that we've got a database connection and a cursor, we can create a "
"database table ``movie`` with columns for title, release year, and review "
"score. For simplicity, we can just use column names in the table declaration "
"-- thanks to the `flexible typing`_ feature of SQLite, specifying the data "
"types is optional. Execute the ``CREATE TABLE`` statement by calling :meth:"
"`cur.execute(...) <Cursor.execute>`:"
msgstr ""
"Nu när vi har en databasanslutning och en markör kan vi skapa en "
"databastabell ``movie`` med kolumner för titel, utgivningsår och "
"recensionspoäng. För enkelhetens skull kan vi bara använda kolumnnamn i "
"tabelldeklarationen - tack vare SQLites `flexible typing`_-funktion är det "
"valfritt att ange datatyperna. Kör ``CREATE TABLE``\\-satsen genom att "
"anropa :meth:`cur.execute(...) <Cursor.execute>`:"

#: ../../library/sqlite3.rst:111
msgid ""
"We can verify that the new table has been created by querying the "
"``sqlite_master`` table built-in to SQLite, which should now contain an "
"entry for the ``movie`` table definition (see `The Schema Table`_ for "
"details). Execute that query by calling :meth:`cur.execute(...) <Cursor."
"execute>`, assign the result to ``res``, and call :meth:`res.fetchone() "
"<Cursor.fetchone>` to fetch the resulting row:"
msgstr ""
"Vi kan verifiera att den nya tabellen har skapats genom att fråga tabellen "
"``qlite_master`` som är inbyggd i SQLite, som nu bör innehålla en post för "
"tabelldefinitionen ``movie`` (se `The Schema Table`_ för detaljer). Exekvera "
"frågan genom att anropa :meth:`cur.execute(...) <Cursor.execute>`, tilldela "
"resultatet till ``res`` och anropa :meth:`res.fetchone() <Cursor.fetchone>` "
"för att hämta den resulterande raden:"

#: ../../library/sqlite3.rst:125
msgid ""
"We can see that the table has been created, as the query returns a :class:"
"`tuple` containing the table's name. If we query ``sqlite_master`` for a non-"
"existent table ``spam``, :meth:`!res.fetchone()` will return ``None``:"
msgstr ""

#: ../../library/sqlite3.rst:136
msgid ""
"Now, add two rows of data supplied as SQL literals by executing an "
"``INSERT`` statement, once again by calling :meth:`cur.execute(...) <Cursor."
"execute>`:"
msgstr ""
"Lägg nu till två rader med data som tillhandahålls som SQL-litteraler genom "
"att köra en ``INSERT``\\-sats, återigen genom att anropa :meth:`cur."
"execute(...) <Cursor.execute>`:"

#: ../../library/sqlite3.rst:148
msgid ""
"The ``INSERT`` statement implicitly opens a transaction, which needs to be "
"committed before changes are saved in the database (see :ref:`sqlite3-"
"controlling-transactions` for details). Call :meth:`con.commit() <Connection."
"commit>` on the connection object to commit the transaction:"
msgstr ""
"Satsen ``INSERT`` öppnar implicit en transaktion, som måste bekräftas innan "
"ändringarna sparas i databasen (se :ref:`sqlite3-controlling-transactions` "
"för mer information). Anropa :meth:`con.commit() <Connection.commit>` på "
"anslutningsobjektet för att bekräfta transaktionen:"

#: ../../library/sqlite3.rst:158
msgid ""
"We can verify that the data was inserted correctly by executing a ``SELECT`` "
"query. Use the now-familiar :meth:`cur.execute(...) <Cursor.execute>` to "
"assign the result to ``res``, and call :meth:`res.fetchall() <Cursor."
"fetchall>` to return all resulting rows:"
msgstr ""
"Vi kan verifiera att data infogades korrekt genom att köra en ``SELECT``\\-"
"fråga. Använd den numera välkända :meth:`cur.execute(...) <Cursor.execute>` "
"för att tilldela resultatet till ``res``, och anropa :meth:`res.fetchall() "
"<Cursor.fetchall>` för att returnera alla resulterande rader:"

#: ../../library/sqlite3.rst:170
msgid ""
"The result is a :class:`list` of two :class:`!tuple`\\s, one per row, each "
"containing that row's ``score`` value."
msgstr ""
"Resultatet är en :class:`list` med två :class:`!tuple`, en per rad, som var "
"och en innehåller den radens ``score``\\-värde."

#: ../../library/sqlite3.rst:173
msgid ""
"Now, insert three more rows by calling :meth:`cur.executemany(...) <Cursor."
"executemany>`:"
msgstr ""
"Nu ska du infoga ytterligare tre rader genom att anropa :meth:`cur."
"executemany(...) <Cursor.executemany>`:"

#: ../../library/sqlite3.rst:186
msgid ""
"Notice that ``?`` placeholders are used to bind ``data`` to the query. "
"Always use placeholders instead of :ref:`string formatting <tut-formatting>` "
"to bind Python values to SQL statements, to avoid `SQL injection attacks`_ "
"(see :ref:`sqlite3-placeholders` for more details)."
msgstr ""
"Observera att ``?``\\ -platshållare används för att binda ``data`` till "
"frågan. Använd alltid platshållare istället för :ref:`string formatting <tut-"
"formatting>` för att binda Python-värden till SQL-satser, för att undvika "
"`SQL injection attacks`_ (se :ref:`sqlite3-placeholders` för mer "
"information)."

#: ../../library/sqlite3.rst:192
msgid ""
"We can verify that the new rows were inserted by executing a ``SELECT`` "
"query, this time iterating over the results of the query:"
msgstr ""
"Vi kan verifiera att de nya raderna infogades genom att köra en ``SELECT``\\-"
"fråga och den här gången iterera över resultaten av frågan:"

#: ../../library/sqlite3.rst:206
msgid ""
"Each row is a two-item :class:`tuple` of ``(year, title)``, matching the "
"columns selected in the query."
msgstr ""
"Varje rad är en :class:`tuple` av ``(year, title)`` med två objekt som "
"matchar de kolumner som valts i frågan."

#: ../../library/sqlite3.rst:209
msgid ""
"Finally, verify that the database has been written to disk by calling :meth:"
"`con.close() <Connection.close>` to close the existing connection, opening a "
"new one, creating a new cursor, then querying the database:"
msgstr ""
"Slutligen kontrollerar du att databasen har skrivits till disken genom att "
"anropa :meth:`con.close() <Connection.close>` för att stänga den befintliga "
"anslutningen, öppna en ny, skapa en ny markör och sedan fråga databasen:"

#: ../../library/sqlite3.rst:224
msgid ""
"You've now created an SQLite database using the :mod:`!sqlite3` module, "
"inserted data and retrieved values from it in multiple ways."
msgstr ""
"Du har nu skapat en SQLite-databas med modulen :mod:`!sqlite3`, lagt in data "
"och hämtat värden från den på flera olika sätt."

#: ../../library/sqlite3.rst:236
msgid ":ref:`sqlite3-howtos` for further reading:"
msgstr ":ref:`sqlite3-howtos` för ytterligare läsning:"

#: ../../library/sqlite3.rst:238
msgid ":ref:`sqlite3-placeholders`"
msgstr ":ref:`sqlite3-placeholders`"

#: ../../library/sqlite3.rst:239
msgid ":ref:`sqlite3-adapters`"
msgstr ":ref:`sqlite3-adapters`"

#: ../../library/sqlite3.rst:240
msgid ":ref:`sqlite3-converters`"
msgstr ":ref:`sqlite3-converters`"

#: ../../library/sqlite3.rst:241 ../../library/sqlite3.rst:515
msgid ":ref:`sqlite3-connection-context-manager`"
msgstr ":ref:`sqlite3-connection-context-manager`"

#: ../../library/sqlite3.rst:242
msgid ":ref:`sqlite3-howto-row-factory`"
msgstr ":ref:`sqlite3-howto-row-factory`"

#: ../../library/sqlite3.rst:244
msgid ""
":ref:`sqlite3-explanation` for in-depth background on transaction control."
msgstr ""
":ref:`sqlite3-explanation` för djupgående bakgrund om transaktionskontroll."

#: ../../library/sqlite3.rst:249
msgid "Reference"
msgstr "Referens"

#: ../../library/sqlite3.rst:257
msgid "Module functions"
msgstr "Modulens funktioner"

#: ../../library/sqlite3.rst:264
msgid "Open a connection to an SQLite database."
msgstr "Öppna en anslutning till en SQLite-databas."

#: ../../library/sqlite3.rst:0
msgid "Parameters"
msgstr "Parametrar"

#: ../../library/sqlite3.rst:266
msgid ""
"The path to the database file to be opened. Pass ``\":memory:\"`` to open a "
"connection to a database that is in RAM instead of on disk."
msgstr ""

#: ../../library/sqlite3.rst:272
msgid ""
"How many seconds the connection should wait before raising an :exc:"
"`OperationalError` when a table is locked. If another connection opens a "
"transaction to modify a table, that table will be locked until the "
"transaction is committed. Default five seconds."
msgstr ""
"Hur många sekunder anslutningen ska vänta innan den skickar ett :exc:"
"`OperationalError` när en tabell är låst. Om en annan anslutning öppnar en "
"transaktion för att ändra en tabell, kommer tabellen att vara låst tills "
"transaktionen är genomförd. Standard fem sekunder."

#: ../../library/sqlite3.rst:279
msgid ""
"Control whether and how data types not :ref:`natively supported by SQLite "
"<sqlite3-types>` are looked up to be converted to Python types, using the "
"converters registered with :func:`register_converter`. Set it to any "
"combination (using ``|``, bitwise or) of :const:`PARSE_DECLTYPES` and :const:"
"`PARSE_COLNAMES` to enable this. Column names takes precedence over declared "
"types if both flags are set. Types cannot be detected for generated fields "
"(for example ``max(data)``), even when the *detect_types* parameter is set; :"
"class:`str` will be returned instead. By default (``0``), type detection is "
"disabled."
msgstr ""

#: ../../library/sqlite3.rst:293
msgid ""
"The :attr:`~Connection.isolation_level` of the connection, controlling "
"whether and how transactions are implicitly opened. Can be ``\"DEFERRED\"`` "
"(default), ``\"EXCLUSIVE\"`` or ``\"IMMEDIATE\"``; or ``None`` to disable "
"opening transactions implicitly. See :ref:`sqlite3-controlling-transactions` "
"for more."
msgstr ""

#: ../../library/sqlite3.rst:301
msgid ""
"If ``True`` (default), :exc:`ProgrammingError` will be raised if the "
"database connection is used by a thread other than the one that created it. "
"If ``False``, the connection may be accessed in multiple threads; write "
"operations may need to be serialized by the user to avoid data corruption. "
"See :attr:`threadsafety` for more information."
msgstr ""
"Om ``True`` (standard), kommer :exc:`ProgrammingError` att uppstå om "
"databasanslutningen används av en annan tråd än den som skapade den. Om "
"``False``, kan anslutningen användas av flera trådar; skrivoperationer kan "
"behöva serialiseras av användaren för att undvika datakorruption. Se :attr:"
"`threadsafety` för mer information."

#: ../../library/sqlite3.rst:310
msgid ""
"A custom subclass of :class:`Connection` to create the connection with, if "
"not the default :class:`Connection` class."
msgstr ""
"En anpassad underklass av :class:`Connection` för att skapa anslutningen "
"med, om inte standardklassen :class:`Connection` används."

#: ../../library/sqlite3.rst:314
msgid ""
"The number of statements that :mod:`!sqlite3` should internally cache for "
"this connection, to avoid parsing overhead. By default, 100 statements."
msgstr ""

#: ../../library/sqlite3.rst:319
msgid ""
"If set to ``True``, *database* is interpreted as a :abbr:`URI (Uniform "
"Resource Identifier)` with a file path and an optional query string. The "
"scheme part *must* be ``\"file:\"``, and the path can be relative or "
"absolute. The query string allows passing parameters to SQLite, enabling "
"various :ref:`sqlite3-uri-tricks`."
msgstr ""
"Om värdet är ``True`` tolkas *database* som en :abbr:`URI (Uniform Resource "
"Identifier)` med en filsökväg och en valfri frågesträng. Schemadelen *måste* "
"vara ``\"file:\"``, och sökvägen kan vara relativ eller absolut. "
"Frågesträngen gör det möjligt att skicka parametrar till SQLite, vilket "
"möjliggör olika :ref:`sqlite3-uri-tricks`."

#: ../../library/sqlite3.rst:0
msgid "Return type"
msgstr "Typ av retur"

#: ../../library/sqlite3.rst:330
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.connect`` with argument "
"``database``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``sqlite3.connect`` med "
"argumentet ``database``."

#: ../../library/sqlite3.rst:331
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.connect/handle`` with "
"argument ``connection_handle``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``sqlite3.connect/handle`` med "
"argumentet ``connection_handle``."

#: ../../library/sqlite3.rst:333
msgid "The *uri* parameter."
msgstr ""

#: ../../library/sqlite3.rst:336
msgid ""
"*database* can now also be a :term:`path-like object`, not only a string."
msgstr ""
"*databas* kan nu också vara en :term:`path-like object`, inte bara en sträng."

#: ../../library/sqlite3.rst:339
msgid "The ``sqlite3.connect/handle`` auditing event."
msgstr ""

#: ../../library/sqlite3.rst:344
msgid ""
"Return ``True`` if the string *statement* appears to contain one or more "
"complete SQL statements. No syntactic verification or parsing of any kind is "
"performed, other than checking that there are no unclosed string literals "
"and the statement is terminated by a semicolon."
msgstr ""
"Returnerar ``True`` om strängen *statement* verkar innehålla en eller flera "
"kompletta SQL-satser. Ingen syntaktisk verifiering eller parsning av något "
"slag utförs, annat än att kontrollera att det inte finns några oavslutade "
"stränglitteraler och att satsen avslutas med ett semikolon."

#: ../../library/sqlite3.rst:350
msgid "For example:"
msgstr "Till exempel:"

#: ../../library/sqlite3.rst:359
msgid ""
"This function may be useful during command-line input to determine if the "
"entered text seems to form a complete SQL statement, or if additional input "
"is needed before calling :meth:`~Cursor.execute`."
msgstr ""
"Denna funktion kan vara användbar vid kommandoradsinmatning för att avgöra "
"om den inmatade texten verkar utgöra en komplett SQL-sats, eller om "
"ytterligare inmatning behövs innan :meth:`~Cursor.execute` anropas."

#: ../../library/sqlite3.rst:365
msgid ""
"Enable or disable callback tracebacks. By default you will not get any "
"tracebacks in user-defined functions, aggregates, converters, authorizer "
"callbacks etc. If you want to debug them, you can call this function with "
"*flag* set to ``True``. Afterwards, you will get tracebacks from callbacks "
"on ``sys.stderr``. Use ``False`` to disable the feature again."
msgstr ""

#: ../../library/sqlite3.rst:374
msgid ""
"Register an *adapter* callable to adapt the Python type *type* into an "
"SQLite type. The adapter is called with a Python object of type *type* as "
"its sole argument, and must return a value of a :ref:`type that SQLite "
"natively understands <sqlite3-types>`."
msgstr ""

#: ../../library/sqlite3.rst:382
msgid ""
"Register the *converter* callable to convert SQLite objects of type "
"*typename* into a Python object of a specific type. The converter is invoked "
"for all SQLite values of type *typename*; it is passed a :class:`bytes` "
"object and should return an object of the desired Python type. Consult the "
"parameter *detect_types* of :func:`connect` for information regarding how "
"type detection works."
msgstr ""

#: ../../library/sqlite3.rst:390
msgid ""
"Note: *typename* and the name of the type in your query are matched case-"
"insensitively."
msgstr ""
"Obs: *typename* och namnet på typen i din fråga matchas case-insensitivt."

#: ../../library/sqlite3.rst:397
msgid "Module constants"
msgstr "Modul konstanter"

#: ../../library/sqlite3.rst:401
msgid ""
"Pass this flag value to the *detect_types* parameter of :func:`connect` to "
"look up a converter function by using the type name, parsed from the query "
"column name, as the converter dictionary key. The type name must be wrapped "
"in square brackets (``[]``)."
msgstr ""

#: ../../library/sqlite3.rst:411
msgid ""
"This flag may be combined with :const:`PARSE_DECLTYPES` using the ``|`` "
"(bitwise or) operator."
msgstr ""
"Denna flagga kan kombineras med :const:`PARSE_DECLTYPES` med hjälp av "
"operatorn ``|`` (bitvis eller)."

#: ../../library/sqlite3.rst:416
msgid ""
"Pass this flag value to the *detect_types* parameter of :func:`connect` to "
"look up a converter function using the declared types for each column. The "
"types are declared when the database table is created. :mod:`!sqlite3` will "
"look up a converter function using the first word of the declared type as "
"the converter dictionary key. For example:"
msgstr ""
"Skicka detta flaggvärde till parametern *detect_types* i :func:`connect` för "
"att söka upp en konverteringsfunktion med hjälp av de deklarerade typerna "
"för varje kolumn. Typerna deklareras när databastabellen skapas. :mod:`!"
"sqlite3` söker upp en konverteringsfunktion med det första ordet i den "
"deklarerade typen som nyckel i konverteringsordlistan. Till exempel"

#: ../../library/sqlite3.rst:432
msgid ""
"This flag may be combined with :const:`PARSE_COLNAMES` using the ``|`` "
"(bitwise or) operator."
msgstr ""
"Denna flagga kan kombineras med :const:`PARSE_COLNAMES` med hjälp av "
"operatorn ``|`` (bitvis eller)."

#: ../../library/sqlite3.rst:439
msgid ""
"Flags that should be returned by the *authorizer_callback* callable passed "
"to :meth:`Connection.set_authorizer`, to indicate whether:"
msgstr ""

#: ../../library/sqlite3.rst:442
msgid "Access is allowed (:const:`!SQLITE_OK`),"
msgstr "Åtkomst är tillåten (:const:`!SQLITE_OK`),"

#: ../../library/sqlite3.rst:443
msgid ""
"The SQL statement should be aborted with an error (:const:`!SQLITE_DENY`)"
msgstr "SQL-satsen bör avbrytas med ett fel (:const:`!SQLITE_DENY`)"

#: ../../library/sqlite3.rst:444
msgid ""
"The column should be treated as a ``NULL`` value (:const:`!SQLITE_IGNORE`)"
msgstr ""
"Kolumnen ska behandlas som ett ``NULL``\\-värde (:const:`!SQLITE_IGNORE`)"

#: ../../library/sqlite3.rst:448
msgid ""
"String constant stating the supported DB-API level. Required by the DB-API. "
"Hard-coded to ``\"2.0\"``."
msgstr ""
"Strängkonstant som anger den DB-API-nivå som stöds. Krävs av DB-API. "
"Hårdkodad till ``\"2.0\"``."

#: ../../library/sqlite3.rst:453
msgid ""
"String constant stating the type of parameter marker formatting expected by "
"the :mod:`!sqlite3` module. Required by the DB-API. Hard-coded to "
"``\"qmark\"``."
msgstr ""
"Strängkonstant som anger vilken typ av parametermarkörsformatering som "
"förväntas av modulen :mod:`!sqlite3`. Krävs av DB-API. Hårdkodad till "
"``\"qmark\"``."

#: ../../library/sqlite3.rst:459
msgid "The ``named`` DB-API parameter style is also supported."
msgstr "DB-API-parameterstilen ``named`` stöds också."

#: ../../library/sqlite3.rst:463
msgid ""
"Version number of the runtime SQLite library as a :class:`string <str>`."
msgstr ""
"Versionsnummer för SQLite-biblioteket för körning som en :class:`string "
"<str>`."

#: ../../library/sqlite3.rst:467
msgid ""
"Version number of the runtime SQLite library as a :class:`tuple` of :class:"
"`integers <int>`."
msgstr ""
"Versionsnummer för SQLite-biblioteket under körning som en :class:`tuple` "
"av :class:`integers <int>`."

#: ../../library/sqlite3.rst:472
msgid ""
"Integer constant required by the DB-API, stating the level of thread safety "
"the :mod:`!sqlite3` module supports. Currently hard-coded to ``1``, meaning "
"*\"Threads may share the module, but not connections.\"* However, this may "
"not always be true. You can check the underlying SQLite library's compile-"
"time threaded mode using the following query::"
msgstr ""

#: ../../library/sqlite3.rst:485
msgid ""
"Note that the `SQLITE_THREADSAFE levels <https://sqlite.org/compile."
"html#threadsafe>`_ do not match the DB-API 2.0 ``threadsafety`` levels."
msgstr ""

#: ../../library/sqlite3.rst:491
msgid ""
"Version number of this module as a :class:`string <str>`. This is not the "
"version of the SQLite library."
msgstr ""

#: ../../library/sqlite3.rst:496
msgid ""
"Version number of this module as a :class:`tuple` of :class:`integers "
"<int>`. This is not the version of the SQLite library."
msgstr ""

#: ../../library/sqlite3.rst:503
msgid "Connection objects"
msgstr "Anslutningsobjekt"

#: ../../library/sqlite3.rst:507
msgid ""
"Each open SQLite database is represented by a ``Connection`` object, which "
"is created using :func:`sqlite3.connect`. Their main purpose is creating :"
"class:`Cursor` objects, and :ref:`sqlite3-controlling-transactions`."
msgstr ""
"Varje öppen SQLite-databas representeras av ett ``Connection``\\ -objekt, "
"som skapas med :func:`sqlite3.connect`. Deras huvudsakliga syfte är att "
"skapa :class:`Cursor`\\-objekt och :ref:`sqlite3-controlling-transactions`."

#: ../../library/sqlite3.rst:514
msgid ":ref:`sqlite3-connection-shortcuts`"
msgstr ":ref:`sqlite3-connection-shortcuts`"

#: ../../library/sqlite3.rst:517
msgid "An SQLite database connection has the following attributes and methods:"
msgstr "En SQLite-databasanslutning har följande attribut och metoder:"

#: ../../library/sqlite3.rst:521
msgid ""
"Create and return a :class:`Cursor` object. The cursor method accepts a "
"single optional parameter *factory*. If supplied, this must be a callable "
"returning an instance of :class:`Cursor` or its subclasses."
msgstr ""

#: ../../library/sqlite3.rst:528
msgid ""
"Commit any pending transaction to the database. If there is no open "
"transaction, this method is a no-op."
msgstr ""

#: ../../library/sqlite3.rst:533
msgid ""
"Roll back to the start of any pending transaction. If there is no open "
"transaction, this method is a no-op."
msgstr ""

#: ../../library/sqlite3.rst:538
msgid ""
"Close the database connection. Any pending transaction is not committed "
"implicitly; make sure to :meth:`commit` before closing to avoid losing "
"pending changes."
msgstr ""

#: ../../library/sqlite3.rst:545
msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.execute` on it "
"with the given *sql* and *parameters*. Return the new cursor object."
msgstr ""
"Skapa ett nytt :class:`Cursor`\\-objekt och anropa :meth:`~Cursor.execute` "
"på det med de angivna *sql* och *parametrarna*. Returnera det nya cursor-"
"objektet."

#: ../../library/sqlite3.rst:551
msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.executemany` on "
"it with the given *sql* and *parameters*. Return the new cursor object."
msgstr ""
"Skapa ett nytt :class:`Cursor`\\-objekt och anropa :meth:`~Cursor."
"executemany` på det med de angivna *sql* och *parametrarna*. Returnera det "
"nya cursor-objektet."

#: ../../library/sqlite3.rst:557
msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.executescript` "
"on it with the given *sql_script*. Return the new cursor object."
msgstr ""
"Skapa ett nytt :class:`Cursor`\\-objekt och anropa :meth:`~Cursor."
"executescript` på det med det angivna *sql_script*. Returnera det nya cursor-"
"objektet."

#: ../../library/sqlite3.rst:563
msgid "Create or remove a user-defined SQL function."
msgstr "Skapa eller ta bort en användardefinierad SQL-funktion."

#: ../../library/sqlite3.rst:565
msgid "The name of the SQL function."
msgstr "Namnet på SQL-funktionen."

#: ../../library/sqlite3.rst:568
msgid ""
"The number of arguments the SQL function can accept. If ``-1``, it may take "
"any number of arguments."
msgstr ""
"Antalet argument som SQL-funktionen kan acceptera. Om ``\\-1``, kan den ta "
"emot valfritt antal argument."

#: ../../library/sqlite3.rst:572
msgid ""
"A callable that is called when the SQL function is invoked. The callable "
"must return :ref:`a type natively supported by SQLite <sqlite3-types>`. Set "
"to ``None`` to remove an existing SQL function."
msgstr ""

#: ../../library/sqlite3.rst:579
msgid ""
"If ``True``, the created SQL function is marked as `deterministic <https://"
"sqlite.org/deterministic.html>`_, which allows SQLite to perform additional "
"optimizations."
msgstr ""
"Om ``True``, markeras den skapade SQL-funktionen som `deterministisk "
"<https://sqlite.org/deterministic.html>`_, vilket gör att SQLite kan utföra "
"ytterligare optimeringar."

#: ../../library/sqlite3.rst:0
msgid "Raises"
msgstr "Höjer"

#: ../../library/sqlite3.rst:584
msgid "If *deterministic* is used with SQLite versions older than 3.8.3."
msgstr ""

#: ../../library/sqlite3.rst:587
msgid "The *deterministic* parameter."
msgstr ""

#: ../../library/sqlite3.rst:590 ../../library/sqlite3.rst:628
#: ../../library/sqlite3.rst:847 ../../library/sqlite3.rst:966
#: ../../library/sqlite3.rst:1094 ../../library/sqlite3.rst:1115
msgid "Example:"
msgstr "Exempel:"

#: ../../library/sqlite3.rst:606
msgid "Create or remove a user-defined SQL aggregate function."
msgstr "Skapa eller ta bort en användardefinierad SQL-aggregatfunktion."

#: ../../library/sqlite3.rst:608
msgid "The name of the SQL aggregate function."
msgstr "Namnet på SQL-aggregatfunktionen."

#: ../../library/sqlite3.rst:611
msgid ""
"The number of arguments the SQL aggregate function can accept. If ``-1``, it "
"may take any number of arguments."
msgstr ""
"Det antal argument som SQL-aggregatfunktionen kan acceptera. Om ``\\-1``, "
"kan den ta emot valfritt antal argument."

#: ../../library/sqlite3.rst:615
msgid ""
"A class must implement the following methods:  * ``step()``: Add a row to "
"the aggregate. * ``finalize()``: Return the final result of the aggregate "
"as   :ref:`a type natively supported by SQLite <sqlite3-types>`.  The number "
"of arguments that the ``step()`` method must accept is controlled by "
"*n_arg*.  Set to ``None`` to remove an existing SQL aggregate function."
msgstr ""
"En klass måste implementera följande metoder:  * ``step()``: Lägger till en "
"rad i aggregatet. * ``finalize()``: Returnerar aggregatets slutresultat som :"
"ref:`a type natively supported by SQLite <sqlite3-types>`.  Antalet argument "
"som metoden ``step()`` måste acceptera styrs av *n_arg*.  Ställ in till "
"``None`` för att ta bort en befintlig SQL-aggregatfunktion."

#: ../../library/sqlite3.rst:616
msgid "A class must implement the following methods:"
msgstr "En klass måste implementera följande metoder:"

#: ../../library/sqlite3.rst:618
msgid "``step()``: Add a row to the aggregate."
msgstr "``step()``: Lägg till en rad i aggregatet."

#: ../../library/sqlite3.rst:619
msgid ""
"``finalize()``: Return the final result of the aggregate as :ref:`a type "
"natively supported by SQLite <sqlite3-types>`."
msgstr ""
"``finalize()``: Returnerar det slutliga resultatet av sammanställningen som :"
"ref:`en typ som stöds av SQLite <sqlite3-types>`."

#: ../../library/sqlite3.rst:622
msgid ""
"The number of arguments that the ``step()`` method must accept is controlled "
"by *n_arg*."
msgstr ""
"Antalet argument som metoden ``step()`` måste acceptera styrs av *n_arg*."

#: ../../library/sqlite3.rst:625
msgid "Set to ``None`` to remove an existing SQL aggregate function."
msgstr "Sätt till ``None`` för att ta bort en befintlig SQL-aggregatfunktion."

#: ../../library/sqlite3.rst:660
msgid ""
"Create a collation named *name* using the collating function *callable*. "
"*callable* is passed two :class:`string <str>` arguments, and it should "
"return an :class:`integer <int>`:"
msgstr ""
"Skapa en kollationering med namnet *namn* med hjälp av kollationsfunktionen "
"*callable*. *callable* får två :class:`sträng <str>`\\-argument, och den ska "
"returnera en :class:`integer <int>`:"

#: ../../library/sqlite3.rst:664
msgid "``1`` if the first is ordered higher than the second"
msgstr "``1`` om den första är högre beställd än den andra"

#: ../../library/sqlite3.rst:665
msgid "``-1`` if the first is ordered lower than the second"
msgstr "``\\-1`` om den första är lägre ordnad än den andra"

#: ../../library/sqlite3.rst:666
msgid "``0`` if they are ordered equal"
msgstr "``0`` om de är ordnade lika"

#: ../../library/sqlite3.rst:668
msgid "The following example shows a reverse sorting collation:"
msgstr "Följande exempel visar en omvänd sorteringskollation:"

#: ../../library/sqlite3.rst:696
msgid "Remove a collation function by setting *callable* to ``None``."
msgstr ""
"Ta bort en sorteringsfunktion genom att sätta *callable* till ``None``."

#: ../../library/sqlite3.rst:701
msgid ""
"Call this method from a different thread to abort any queries that might be "
"executing on the connection. Aborted queries will raise an :exc:"
"`OperationalError`."
msgstr ""
"Anropa den här metoden från en annan tråd för att avbryta eventuella frågor "
"som körs på anslutningen. Avbrutna förfrågningar kommer att ge upphov till "
"ett :exc:`OperationalError`."

#: ../../library/sqlite3.rst:708
msgid ""
"Register callable *authorizer_callback* to be invoked for each attempt to "
"access a column of a table in the database. The callback should return one "
"of :const:`SQLITE_OK`, :const:`SQLITE_DENY`, or :const:`SQLITE_IGNORE` to "
"signal how access to the column should be handled by the underlying SQLite "
"library."
msgstr ""

#: ../../library/sqlite3.rst:714
msgid ""
"The first argument to the callback signifies what kind of operation is to be "
"authorized. The second and third argument will be arguments or ``None`` "
"depending on the first argument. The 4th argument is the name of the "
"database (\"main\", \"temp\", etc.) if applicable. The 5th argument is the "
"name of the inner-most trigger or view that is responsible for the access "
"attempt or ``None`` if this access attempt is directly from input SQL code."
msgstr ""
"Det första argumentet till callbacken anger vilken typ av operation som ska "
"auktoriseras. Det andra och tredje argumentet kommer att vara argument eller "
"``None`` beroende på det första argumentet. Det fjärde argumentet är namnet "
"på databasen (\"main\", \"temp\", etc.) om tillämpligt. Det femte argumentet "
"är namnet på den innersta trigger eller vy som är ansvarig för "
"åtkomstförsöket eller ``None`` om åtkomstförsöket kommer direkt från SQL-kod."

#: ../../library/sqlite3.rst:721
msgid ""
"Please consult the SQLite documentation about the possible values for the "
"first argument and the meaning of the second and third argument depending on "
"the first one. All necessary constants are available in the :mod:`!sqlite3` "
"module."
msgstr ""
"Se SQLite-dokumentationen för information om möjliga värden för det första "
"argumentet och betydelsen av det andra och tredje argumentet beroende på det "
"första. Alla nödvändiga konstanter finns tillgängliga i modulen :mod:`!"
"sqlite3`."

#: ../../library/sqlite3.rst:728
msgid ""
"Register callable *progress_handler* to be invoked for every *n* "
"instructions of the SQLite virtual machine. This is useful if you want to "
"get called from SQLite during long-running operations, for example to update "
"a GUI."
msgstr ""

#: ../../library/sqlite3.rst:733
msgid ""
"If you want to clear any previously installed progress handler, call the "
"method with ``None`` for *progress_handler*."
msgstr ""
"Om du vill ta bort alla tidigare installerade progress-handläggare anropar "
"du metoden med ``None`` för *progress_handler*."

#: ../../library/sqlite3.rst:736
msgid ""
"Returning a non-zero value from the handler function will terminate the "
"currently executing query and cause it to raise an :exc:`OperationalError` "
"exception."
msgstr ""

#: ../../library/sqlite3.rst:743
msgid ""
"Register callable *trace_callback* to be invoked for each SQL statement that "
"is actually executed by the SQLite backend."
msgstr ""

#: ../../library/sqlite3.rst:746
msgid ""
"The only argument passed to the callback is the statement (as :class:`str`) "
"that is being executed. The return value of the callback is ignored. Note "
"that the backend does not only run statements passed to the :meth:`Cursor."
"execute` methods.  Other sources include the :ref:`transaction management "
"<sqlite3-controlling-transactions>` of the :mod:`!sqlite3` module and the "
"execution of triggers defined in the current database."
msgstr ""
"Det enda argument som skickas till callbacken är det uttalande (som :class:"
"`str`) som körs. Returvärdet för återuppringningen ignoreras. Observera att "
"backend inte bara kör satser som skickas till :meth:`Cursor.execute`\\-"
"metoderna.  Andra källor inkluderar :ref:`transaction management <sqlite3-"
"controlling-transactions>` i :mod:`!sqlite3`\\-modulen och exekveringen av "
"triggers som definieras i den aktuella databasen."

#: ../../library/sqlite3.rst:754
msgid "Passing ``None`` as *trace_callback* will disable the trace callback."
msgstr ""
"Om du anger ``None`` som *trace_callback* inaktiveras spårningsuppringningen."

#: ../../library/sqlite3.rst:757
msgid ""
"Exceptions raised in the trace callback are not propagated. As a development "
"and debugging aid, use :meth:`~sqlite3.enable_callback_tracebacks` to enable "
"printing tracebacks from exceptions raised in the trace callback."
msgstr ""
"Undantag som uppstår i trace callback sprids inte. Som ett hjälpmedel för "
"utveckling och felsökning kan du använda :meth:`~sqlite3."
"enable_callback_tracebacks` för att aktivera utskrift av spårningar från "
"undantag som tas upp i trace callback."

#: ../../library/sqlite3.rst:767
msgid ""
"Enable the SQLite engine to load SQLite extensions from shared libraries if "
"*enabled* is ``True``; else, disallow loading SQLite extensions. SQLite "
"extensions can define new functions, aggregates or whole new virtual table "
"implementations.  One well-known extension is the fulltext-search extension "
"distributed with SQLite."
msgstr ""
"Aktivera SQLite-motorn att ladda SQLite-tillägg från delade bibliotek om "
"*enabled* är ``True``; annars, avaktivera laddning av SQLite-tillägg. SQLite-"
"tillägg kan definiera nya funktioner, aggregat eller helt nya "
"implementeringar av virtuella tabeller.  Ett välkänt tillägg är fulltext-"
"söktillägget som distribueras med SQLite."

#: ../../library/sqlite3.rst:776
msgid ""
"The :mod:`!sqlite3` module is not built with loadable extension support by "
"default, because some platforms (notably macOS) have SQLite libraries which "
"are compiled without this feature. To get loadable extension support, you "
"must pass the :option:`--enable-loadable-sqlite-extensions` option to :"
"program:`configure`."
msgstr ""
"Modulen :mod:`!sqlite3` är inte byggd med stöd för laddningsbara tillägg som "
"standard, eftersom vissa plattformar (särskilt macOS) har SQLite-bibliotek "
"som är kompilerade utan denna funktion. För att få stöd för laddningsbara "
"tillägg måste du skicka alternativet :option:`\\--enable-loadable-sqlite-"
"extensions` till :program:`configure`."

#: ../../library/sqlite3.rst:783
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.enable_load_extension`` "
"with arguments ``connection``, ``enabled``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``sqlite3."
"enable_load_extension`` med argumenten ``connection``, ``enabled``."

#: ../../library/sqlite3.rst:787
msgid "Added the ``sqlite3.enable_load_extension`` auditing event."
msgstr "Lagt till granskningshändelsen ``sqlite3.enable_load_extension``."

#: ../../library/sqlite3.rst:830
msgid ""
"Load an SQLite extension from a shared library located at *path*. Enable "
"extension loading with :meth:`enable_load_extension` before calling this "
"method."
msgstr ""

#: ../../library/sqlite3.rst:834
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.load_extension`` with "
"arguments ``connection``, ``path``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``sqlite3.load_extension`` med "
"argumenten ``connection``, ``path``."

#: ../../library/sqlite3.rst:838
msgid "Added the ``sqlite3.load_extension`` auditing event."
msgstr "Lagt till granskningshändelsen ``sqlite3.load_extension``."

#: ../../library/sqlite3.rst:843
msgid ""
"Return an :term:`iterator` to dump the database as SQL source code. Useful "
"when saving an in-memory database for later restoration. Similar to the ``."
"dump`` command in the :program:`sqlite3` shell."
msgstr ""
"Returnerar en :term:`iterator` för att dumpa databasen som SQL-källkod. "
"Användbart när du sparar en databas i minnet för senare återställning. "
"Liknar kommandot ``.dump`` i skalet :program:`sqlite3`."

#: ../../library/sqlite3.rst:861
msgid "Create a backup of an SQLite database."
msgstr "Skapa en säkerhetskopia av en SQLite-databas."

#: ../../library/sqlite3.rst:863
msgid ""
"Works even if the database is being accessed by other clients or "
"concurrently by the same connection."
msgstr ""
"Fungerar även om databasen nås av andra klienter eller samtidigt med samma "
"anslutning."

#: ../../library/sqlite3.rst:866
msgid "The database connection to save the backup to."
msgstr "Den databasanslutning som säkerhetskopian ska sparas i."

#: ../../library/sqlite3.rst:869
msgid ""
"The number of pages to copy at a time. If equal to or less than ``0``, the "
"entire database is copied in a single step. Defaults to ``-1``."
msgstr ""
"Antalet sidor som ska kopieras åt gången. Om det är lika med eller mindre än "
"``0`` kopieras hela databasen i ett enda steg. Standardvärdet är ``\\-1``."

#: ../../library/sqlite3.rst:875
msgid ""
"If set to a callable, it is invoked with three integer arguments for every "
"backup iteration: the *status* of the last iteration, the *remaining* number "
"of pages still to be copied, and the *total* number of pages. Defaults to "
"``None``."
msgstr ""

#: ../../library/sqlite3.rst:884
msgid ""
"The name of the database to back up. Either ``\"main\"`` (the default) for "
"the main database, ``\"temp\"`` for the temporary database, or the name of a "
"custom database as attached using the ``ATTACH DATABASE`` SQL statement."
msgstr ""
"Namnet på den databas som ska säkerhetskopieras. Antingen ``\"main\"`` "
"(standard) för huvuddatabasen, ``\"temp\"`` för den tillfälliga databasen "
"eller namnet på en anpassad databas som bifogats med SQL-satsen ``ATTACH "
"DATABASE``."

#: ../../library/sqlite3.rst:891
msgid ""
"The number of seconds to sleep between successive attempts to back up "
"remaining pages."
msgstr ""
"Antalet sekunder som ska gå mellan två på varandra följande försök att "
"säkerhetskopiera återstående sidor."

#: ../../library/sqlite3.rst:895
msgid "Example 1, copy an existing database into another:"
msgstr "Exempel 1, kopiera en befintlig databas till en annan:"

#: ../../library/sqlite3.rst:914
msgid "Example 2, copy an existing database into a transient copy:"
msgstr "Exempel 2, kopiera en befintlig databas till en tillfällig kopia:"

#: ../../library/sqlite3.rst:926
msgid ""
"This read-only attribute corresponds to the low-level SQLite `autocommit "
"mode`_."
msgstr ""
"Detta skrivskyddade attribut motsvarar SQLites `autocommit mode`_ på låg "
"nivå."

#: ../../library/sqlite3.rst:929
msgid ""
"``True`` if a transaction is active (there are uncommitted changes), "
"``False`` otherwise."
msgstr ""
"``True`` om en transaktion är aktiv (det finns ändringar som inte är "
"bekräftade), ``False`` annars."

#: ../../library/sqlite3.rst:936
msgid ""
"This attribute controls the :ref:`transaction handling <sqlite3-controlling-"
"transactions>` performed by :mod:`!sqlite3`. If set to ``None``, "
"transactions are never implicitly opened. If set to one of ``\"DEFERRED\"``, "
"``\"IMMEDIATE\"``, or ``\"EXCLUSIVE\"``, corresponding to the underlying "
"`SQLite transaction behaviour`_, implicit :ref:`transaction management "
"<sqlite3-controlling-transactions>` is performed."
msgstr ""

#: ../../library/sqlite3.rst:944
msgid ""
"If not overridden by the *isolation_level* parameter of :func:`connect`, the "
"default is ``\"\"``, which is an alias for ``\"DEFERRED\"``."
msgstr ""
"Om den inte åsidosätts av parametern *isolation_level* i :func:`connect`, är "
"standardvärdet ``\"\"``, som är ett alias för ``\"DEFERRED\"``."

#: ../../library/sqlite3.rst:949
msgid ""
"The initial :attr:`~Cursor.row_factory` for :class:`Cursor` objects created "
"from this connection. Assigning to this attribute does not affect the :attr:"
"`!row_factory` of existing cursors belonging to this connection, only new "
"ones. Is ``None`` by default, meaning each row is returned as a :class:"
"`tuple`."
msgstr ""
"Det ursprungliga :attr:`~Cursor.row_factory` för :class:`Cursor`\\-objekt "
"som skapas från den här anslutningen. Tilldelning av detta attribut påverkar "
"inte :attr:`!row_factory` för befintliga markörer som tillhör denna "
"anslutning, endast nya. Är ``None`` som standard, vilket innebär att varje "
"rad returneras som en :class:`tuple`."

#: ../../library/sqlite3.rst:956 ../../library/sqlite3.rst:1239
#: ../../library/sqlite3.rst:1262
msgid "See :ref:`sqlite3-howto-row-factory` for more details."
msgstr "Se :ref:`sqlite3-howto-row-factory` för mer information."

#: ../../library/sqlite3.rst:960
msgid ""
"A callable that accepts a :class:`bytes` parameter and returns a text "
"representation of it. The callable is invoked for SQLite values with the "
"``TEXT`` data type. By default, this attribute is set to :class:`str`. If "
"you want to return ``bytes`` instead, set *text_factory* to ``bytes``."
msgstr ""

#: ../../library/sqlite3.rst:1000
msgid ""
"Return the total number of database rows that have been modified, inserted, "
"or deleted since the database connection was opened."
msgstr ""
"Returnerar det totala antalet databasrader som har ändrats, infogats eller "
"tagits bort sedan databasanslutningen öppnades."

#: ../../library/sqlite3.rst:1006
msgid "Cursor objects"
msgstr "Cursor-objekt"

#: ../../library/sqlite3.rst:1008
msgid ""
"A ``Cursor`` object represents a `database cursor`_ which is used to execute "
"SQL statements, and manage the context of a fetch operation. Cursors are "
"created using :meth:`Connection.cursor`, or by using any of the :ref:"
"`connection shortcut methods <sqlite3-connection-shortcuts>`."
msgstr ""
"Ett ``Cursor``\\ -objekt representerar en `database cursor`_ som används för "
"att exekvera SQL-satser och hantera kontexten för en hämtningsoperation. "
"Cursors skapas med :meth:`Connection.cursor`, eller genom att använda någon "
"av :ref:`connection shortcut methods <sqlite3-connection-shortcuts>`."

#: ../../library/sqlite3.rst:1015
msgid ""
"Cursor objects are :term:`iterators <iterator>`, meaning that if you :meth:"
"`~Cursor.execute` a ``SELECT`` query, you can simply iterate over the cursor "
"to fetch the resulting rows:"
msgstr ""
"Markörobjekt är :term:`iteratorer <iterator>`, vilket innebär att om du :"
"meth:`~Cursor.execute` en ``SELECT``\\-fråga kan du helt enkelt iterera över "
"markören för att hämta de resulterande raderna:"

#: ../../library/sqlite3.rst:1040
msgid "A :class:`Cursor` instance has the following attributes and methods."
msgstr "En :class:`Cursor`\\-instans har följande attribut och metoder."

#: ../../library/sqlite3.rst:1047
msgid ""
"Execute SQL a single SQL statement, optionally binding Python values using :"
"ref:`placeholders <sqlite3-placeholders>`."
msgstr ""

#: ../../library/sqlite3.rst:1051
msgid "A single SQL statement."
msgstr "En enda SQL-sats."

#: ../../library/sqlite3.rst:1054
msgid ""
"Python values to bind to placeholders in *sql*. A :class:`!dict` if named "
"placeholders are used. A :term:`!sequence` if unnamed placeholders are used. "
"See :ref:`sqlite3-placeholders`."
msgstr ""
"Python-värden att binda till platshållare i *sql*. En :class:`!dict` om "
"namngivna platshållare används. En :term:`!sequence` om icke namngivna "
"platshållare används. Se :ref:`sqlite3-placeholders`."

#: ../../library/sqlite3.rst:1061 ../../library/sqlite3.rst:1091
msgid "If *sql* contains more than one SQL statement."
msgstr ""

#: ../../library/sqlite3.rst:1064
msgid ""
"If :attr:`~Connection.isolation_level` is not ``None``, *sql* is an "
"``INSERT``, ``UPDATE``, ``DELETE``, or ``REPLACE`` statement, and there is "
"no open transaction, a transaction is implicitly opened before executing "
"*sql*."
msgstr ""

#: ../../library/sqlite3.rst:1069
msgid "Use :meth:`executescript` to execute multiple SQL statements."
msgstr "Använd :meth:`executescript` för att köra flera SQL-satser."

#: ../../library/sqlite3.rst:1073
msgid ""
"For every item in *parameters*, repeatedly execute the :ref:`parameterized "
"<sqlite3-placeholders>` SQL statement *sql*."
msgstr ""

#: ../../library/sqlite3.rst:1077
msgid "Uses the same implicit transaction handling as :meth:`~Cursor.execute`."
msgstr ""
"Använder samma implicita transaktionshantering som :meth:`~Cursor.execute`."

#: ../../library/sqlite3.rst:1079
msgid "A single SQL :abbr:`DML (Data Manipulation Language)` statement."
msgstr ""

#: ../../library/sqlite3.rst:1082
msgid ""
"An :term:`!iterable` of parameters to bind with the placeholders in *sql*. "
"See :ref:`sqlite3-placeholders`."
msgstr ""
"En :term:`!iterable` av parametrar att binda med platshållarna i *sql*. Se :"
"ref:`sqlite3-placeholders`."

#: ../../library/sqlite3.rst:1088
msgid "If *sql* is not a DML statment."
msgstr ""

#: ../../library/sqlite3.rst:1107
msgid ""
"Execute the SQL statements in *sql_script*. If there is a pending "
"transaction, an implicit ``COMMIT`` statement is executed first. No other "
"implicit transaction control is performed; any transaction control must be "
"added to *sql_script*."
msgstr ""

#: ../../library/sqlite3.rst:1113
msgid "*sql_script* must be a :class:`string <str>`."
msgstr "*sql_script* måste vara en :class:`sträng <str>`."

#: ../../library/sqlite3.rst:1131
msgid ""
"If :attr:`~Cursor.row_factory` is ``None``, return the next row query result "
"set as a :class:`tuple`. Else, pass it to the row factory and return its "
"result. Return ``None`` if no more data is available."
msgstr ""
"Om :attr:`~Cursor.row_factory` är ``None``, returneras nästa "
"resultatuppsättning för radfrågor som en :class:`tuple`. Annars skickas den "
"till radfabriken och dess resultat returneras. Returnera ``None`` om inga "
"fler data finns tillgängliga."

#: ../../library/sqlite3.rst:1139
msgid ""
"Return the next set of rows of a query result as a :class:`list`. Return an "
"empty list if no more rows are available."
msgstr ""
"Returnerar nästa uppsättning rader i ett frågeresultat som en :class:`list`. "
"Returnerar en tom lista om inga fler rader är tillgängliga."

#: ../../library/sqlite3.rst:1142
msgid ""
"The number of rows to fetch per call is specified by the *size* parameter. "
"If *size* is not given, :attr:`arraysize` determines the number of rows to "
"be fetched. If fewer than *size* rows are available, as many rows as are "
"available are returned."
msgstr ""
"Antalet rader som ska hämtas per anrop specificeras av parametern *size*. Om "
"*size* inte anges bestämmer :attr:`arraysize` antalet rader som ska hämtas. "
"Om färre än *size* rader är tillgängliga returneras så många rader som är "
"tillgängliga."

#: ../../library/sqlite3.rst:1148
msgid ""
"Note there are performance considerations involved with the *size* "
"parameter. For optimal performance, it is usually best to use the arraysize "
"attribute. If the *size* parameter is used, then it is best for it to retain "
"the same value from one :meth:`fetchmany` call to the next."
msgstr ""
"Observera att parametern *size* är förknippad med prestandafrågor. För "
"optimal prestanda är det oftast bäst att använda arraysize-attributet. Om "
"parametern *size* används är det bäst att den behåller samma värde från ett :"
"meth:`fetchmany`\\-anrop till nästa."

#: ../../library/sqlite3.rst:1155
msgid ""
"Return all (remaining) rows of a query result as a :class:`list`. Return an "
"empty list if no rows are available. Note that the :attr:`arraysize` "
"attribute can affect the performance of this operation."
msgstr ""
"Returnerar alla (återstående) rader i ett sökresultat som en :class:`list`. "
"Returnerar en tom lista om inga rader är tillgängliga. Observera att "
"attributet :attr:`arraysize` kan påverka prestandan för denna operation."

#: ../../library/sqlite3.rst:1162
msgid "Close the cursor now (rather than whenever ``__del__`` is called)."
msgstr "Stäng markören nu (i stället för när ``__del__`` anropas)."

#: ../../library/sqlite3.rst:1164
msgid ""
"The cursor will be unusable from this point forward; a :exc:"
"`ProgrammingError` exception will be raised if any operation is attempted "
"with the cursor."
msgstr ""
"Markören kommer att vara oanvändbar från och med nu; ett :exc:"
"`ProgrammingError` undantag kommer att uppstå om någon operation försöker "
"utföras med markören."

#: ../../library/sqlite3.rst:1169 ../../library/sqlite3.rst:1173
msgid "Required by the DB-API. Does nothing in :mod:`!sqlite3`."
msgstr "Krävs av DB-API. Gör ingenting i :mod:`!sqlite3`."

#: ../../library/sqlite3.rst:1177
msgid ""
"Read/write attribute that controls the number of rows returned by :meth:"
"`fetchmany`. The default value is 1 which means a single row would be "
"fetched per call."
msgstr ""
"Läs-/skrivattribut som styr antalet rader som returneras av :meth:"
"`fetchmany`. Standardvärdet är 1, vilket innebär att en enda rad hämtas per "
"anrop."

#: ../../library/sqlite3.rst:1182
msgid ""
"Read-only attribute that provides the SQLite database :class:`Connection` "
"belonging to the cursor.  A :class:`Cursor` object created by calling :meth:"
"`con.cursor() <Connection.cursor>` will have a :attr:`connection` attribute "
"that refers to *con*:"
msgstr ""
"Skrivskyddat attribut som anger SQLite-databasen :class:`Connection` som hör "
"till markören.  Ett :class:`Cursor`\\-objekt som skapas genom anrop av :meth:"
"`con.cursor() <Connection.cursor>` kommer att ha ett :attr:`connection`\\-"
"attribut som hänvisar till *con*:"

#: ../../library/sqlite3.rst:1196
msgid ""
"Read-only attribute that provides the column names of the last query. To "
"remain compatible with the Python DB API, it returns a 7-tuple for each "
"column where the last six items of each tuple are ``None``."
msgstr ""
"Skrivskyddat attribut som tillhandahåller kolumnnamnen för den senaste "
"frågan. För att vara kompatibel med Python DB API returneras en 7-tupel för "
"varje kolumn där de sex sista posterna i varje tupel är ``None``."

#: ../../library/sqlite3.rst:1200
msgid "It is set for ``SELECT`` statements without any matching rows as well."
msgstr ""
"Den är också inställd för ``SELECT``\\-satser utan några matchande rader."

#: ../../library/sqlite3.rst:1204
msgid ""
"Read-only attribute that provides the row id of the last inserted row. It is "
"only updated after successful ``INSERT`` or ``REPLACE`` statements using "
"the :meth:`execute` method.  For other statements, after :meth:`executemany` "
"or :meth:`executescript`, or if the insertion failed, the value of "
"``lastrowid`` is left unchanged.  The initial value of ``lastrowid`` is "
"``None``."
msgstr ""
"Skrivskyddat attribut som anger rad-id för den senast infogade raden. Det "
"uppdateras endast efter lyckade ``INSERT`` eller ``REPLACE``\\-satser som "
"använder metoden :meth:`execute`.  För andra satser, efter :meth:"
"`executemany` eller :meth:`executescript`, eller om infogningen "
"misslyckades, lämnas värdet på ``lastrowid`` oförändrat.  Det initiala "
"värdet för ``lastrowid`` är ``None``."

#: ../../library/sqlite3.rst:1212
msgid "Inserts into ``WITHOUT ROWID`` tables are not recorded."
msgstr "Insättningar i tabellerna ``WITHOUT ROWID`` registreras inte."

#: ../../library/sqlite3.rst:1214
msgid "Added support for the ``REPLACE`` statement."
msgstr "Lagt till stöd för ``REPLACE``\\-satsen."

#: ../../library/sqlite3.rst:1219
msgid ""
"Read-only attribute that provides the number of modified rows for "
"``INSERT``, ``UPDATE``, ``DELETE``, and ``REPLACE`` statements; is ``-1`` "
"for other statements, including :abbr:`CTE (Common Table Expression)` "
"queries. It is only updated by the :meth:`execute` and :meth:`executemany` "
"methods."
msgstr ""

#: ../../library/sqlite3.rst:1227
msgid ""
"Control how a row fetched from this :class:`!Cursor` is represented. If "
"``None``, a row is represented as a :class:`tuple`. Can be set to the "
"included :class:`sqlite3.Row`; or a :term:`callable` that accepts two "
"arguments, a :class:`Cursor` object and the :class:`!tuple` of row values, "
"and returns a custom object representing an SQLite row."
msgstr ""
"Styr hur en rad som hämtas från denna :class:`!Cursor` representeras. Om "
"``None`` representeras en rad som en :class:`tuple`. Kan sättas till den "
"inkluderade :class:`sqlite3.Row`; eller en :term:`callable` som accepterar "
"två argument, ett :class:`Cursor`\\-objekt och :class:`!tuple` av radvärden, "
"och returnerar ett anpassat objekt som representerar en SQLite-rad."

#: ../../library/sqlite3.rst:1234
msgid ""
"Defaults to what :attr:`Connection.row_factory` was set to when the :class:`!"
"Cursor` was created. Assigning to this attribute does not affect :attr:"
"`Connection.row_factory` of the parent connection."
msgstr ""
"Standardvärdet är det värde som :attr:`Connection.row_factory` angavs till "
"när :class:`!Cursor` skapades. Tilldelning av detta attribut påverkar inte :"
"attr:`Connection.row_factory` för den överordnade anslutningen."

#: ../../library/sqlite3.rst:1250
msgid "Row objects"
msgstr "Radobjekt"

#: ../../library/sqlite3.rst:1254
msgid ""
"A :class:`!Row` instance serves as a highly optimized :attr:`~Connection."
"row_factory` for :class:`Connection` objects. It supports iteration, "
"equality testing, :func:`len`, and :term:`mapping` access by column name and "
"index."
msgstr ""
"En :class:`!Row`\\-instans fungerar som en mycket optimerad :attr:"
"`~Connection.row_factory` för :class:`Connection`\\-objekt. Den stöder "
"iteration, jämlikhetstestning, :func:`len` och :term:`mapping`\\-åtkomst via "
"kolumnnamn och index."

#: ../../library/sqlite3.rst:1259
msgid ""
"Two :class:`!Row` objects compare equal if they have identical column names "
"and values."
msgstr ""
"Två :class:`!Row`\\-objekt jämförs lika om de har identiska kolumnnamn och "
"värden."

#: ../../library/sqlite3.rst:1266
msgid ""
"Return a :class:`list` of column names as :class:`strings <str>`. "
"Immediately after a query, it is the first member of each tuple in :attr:"
"`Cursor.description`."
msgstr ""
"Returnerar en :class:`lista` med kolumnnamn som :class:`strängar <str>`. "
"Omedelbart efter en fråga är det den första medlemmen i varje tupel i :attr:"
"`Cursor.description`."

#: ../../library/sqlite3.rst:1270
msgid "Added support of slicing."
msgstr "Lagt till stöd för skivning."

#: ../../library/sqlite3.rst:1275
msgid "PrepareProtocol objects"
msgstr "PrepareProtocol-objekt"

#: ../../library/sqlite3.rst:1279
msgid ""
"The PrepareProtocol type's single purpose is to act as a :pep:`246` style "
"adaption protocol for objects that can :ref:`adapt themselves <sqlite3-"
"conform>` to :ref:`native SQLite types <sqlite3-types>`."
msgstr ""
"PrepareProtocol-typens enda syfte är att fungera som ett :pep:`246`\\-"
"stilanpassningsprotokoll för objekt som kan :ref:`anpassa sig <sqlite3-"
"conform>` till :ref:`nativa SQLite-typer <sqlite3-types>`."

#: ../../library/sqlite3.rst:1287
msgid "Exceptions"
msgstr "Undantag"

#: ../../library/sqlite3.rst:1289
msgid "The exception hierarchy is defined by the DB-API 2.0 (:pep:`249`)."
msgstr "Undantagshierarkin definieras av DB-API 2.0 (:pep:`249`)."

#: ../../library/sqlite3.rst:1293
msgid ""
"This exception is raised by :mod:`!sqlite3` if an SQL query is not a :class:"
"`string <str>`, or if multiple statements are passed to :meth:`~Cursor."
"execute` or :meth:`~Cursor.executemany`. ``Warning`` is a subclass of :exc:"
"`Exception`."
msgstr ""

#: ../../library/sqlite3.rst:1300
msgid ""
"The base class of the other exceptions in this module. Use this to catch all "
"errors with one single :keyword:`except` statement. ``Error`` is a subclass "
"of :exc:`Exception`."
msgstr ""
"Basklassen för de andra undantagen i den här modulen. Använd denna för att "
"fånga upp alla fel med en enda :keyword:`except`\\-sats. ``Error`` är en "
"underklass till :exc:`Exception`."

#: ../../library/sqlite3.rst:1306
msgid ""
"This exception is raised by :mod:`!sqlite3` for fetch across rollback, or "
"if :mod:`!sqlite3` is unable to bind parameters. ``InterfaceError`` is a "
"subclass of :exc:`Error`."
msgstr ""

#: ../../library/sqlite3.rst:1312
msgid ""
"Exception raised for errors that are related to the database. This serves as "
"the base exception for several types of database errors. It is only raised "
"implicitly through the specialised subclasses. ``DatabaseError`` is a "
"subclass of :exc:`Error`."
msgstr ""
"Undantag för fel som är relaterade till databasen. Detta fungerar som "
"basundantag för flera typer av databasfel. Det kan bara skapas implicit "
"genom de specialiserade underklasserna. ``DatabaseError`` är en underklass "
"till :exc:`Error`."

#: ../../library/sqlite3.rst:1319
msgid ""
"Exception raised for errors caused by problems with the processed data, like "
"numeric values out of range, and strings which are too long. ``DataError`` "
"is a subclass of :exc:`DatabaseError`."
msgstr ""
"Undantag för fel som orsakas av problem med bearbetade data, t.ex. numeriska "
"värden utanför intervallet och för långa strängar. ``DataError`` är en "
"underklass till :exc:`DatabaseError`."

#: ../../library/sqlite3.rst:1325
msgid ""
"Exception raised for errors that are related to the database's operation, "
"and not necessarily under the control of the programmer. For example, the "
"database path is not found, or a transaction could not be processed. "
"``OperationalError`` is a subclass of :exc:`DatabaseError`."
msgstr ""
"Undantag för fel som är relaterade till databasens funktion och inte "
"nödvändigtvis under programmerarens kontroll. Till exempel, databassökvägen "
"hittades inte, eller en transaktion kunde inte behandlas. "
"``OperationalError`` är en underklass till :exc:`DatabaseError`."

#: ../../library/sqlite3.rst:1333
msgid ""
"Exception raised when the relational integrity of the database is affected, "
"e.g. a foreign key check fails.  It is a subclass of :exc:`DatabaseError`."
msgstr ""
"Undantag som uppstår när databasens relationsintegritet påverkas, t.ex. när "
"en kontroll av en främmande nyckel misslyckas.  Det är en underklass till :"
"exc:`DatabaseError`."

#: ../../library/sqlite3.rst:1338
msgid ""
"Exception raised when SQLite encounters an internal error. If this is "
"raised, it may indicate that there is a problem with the runtime SQLite "
"library. ``InternalError`` is a subclass of :exc:`DatabaseError`."
msgstr ""
"Undantag som uppstår när SQLite stöter på ett internt fel. Om det uppstår "
"kan det tyda på att det finns ett problem med SQLite-biblioteket under "
"körning. ``InternalError`` är en underklass till :exc:`DatabaseError`."

#: ../../library/sqlite3.rst:1345
msgid ""
"Exception raised for :mod:`!sqlite3` API programming errors, for example "
"trying to operate on a closed :class:`Connection`, or trying to execute non-"
"DML statements with :meth:`~Cursor.executemany`. ``ProgrammingError`` is a "
"subclass of :exc:`DatabaseError`."
msgstr ""

#: ../../library/sqlite3.rst:1352
msgid ""
"Exception raised in case a method or database API is not supported by the "
"underlying SQLite library. For example, setting *deterministic* to ``True`` "
"in :meth:`~Connection.create_function`, if the underlying SQLite library "
"does not support deterministic functions. ``NotSupportedError`` is a "
"subclass of :exc:`DatabaseError`."
msgstr ""
"Undantag som uppstår om en metod eller databas-API inte stöds av det "
"underliggande SQLite-biblioteket. Till exempel kan *deterministic* sättas "
"till ``True`` i :meth:`~Connection.create_function`, om det underliggande "
"SQLite-biblioteket inte stöder deterministiska funktioner. "
"``NotSupportedError`` är en underklass till :exc:`DatabaseError`."

#: ../../library/sqlite3.rst:1362
msgid "SQLite and Python types"
msgstr "SQLite- och Python-typer"

#: ../../library/sqlite3.rst:1364
msgid ""
"SQLite natively supports the following types: ``NULL``, ``INTEGER``, "
"``REAL``, ``TEXT``, ``BLOB``."
msgstr ""
"SQLite har inbyggt stöd för följande typer: ``NULL``, ``INTEGER``, ``REAL``, "
"``TEXT``, ``BLOB``."

#: ../../library/sqlite3.rst:1367
msgid ""
"The following Python types can thus be sent to SQLite without any problem:"
msgstr "Följande Python-typer kan alltså skickas till SQLite utan problem:"

#: ../../library/sqlite3.rst:1370 ../../library/sqlite3.rst:1387
msgid "Python type"
msgstr "Python-typ"

#: ../../library/sqlite3.rst:1370 ../../library/sqlite3.rst:1387
msgid "SQLite type"
msgstr "SQLite-typ"

#: ../../library/sqlite3.rst:1372 ../../library/sqlite3.rst:1389
msgid "``None``"
msgstr "``Ingen``"

#: ../../library/sqlite3.rst:1372 ../../library/sqlite3.rst:1389
msgid "``NULL``"
msgstr "``NULL``"

#: ../../library/sqlite3.rst:1374 ../../library/sqlite3.rst:1391
msgid ":class:`int`"
msgstr ":class:`int`"

#: ../../library/sqlite3.rst:1374 ../../library/sqlite3.rst:1391
msgid "``INTEGER``"
msgstr "``INTEGER``"

#: ../../library/sqlite3.rst:1376 ../../library/sqlite3.rst:1393
msgid ":class:`float`"
msgstr ":class:`float`"

#: ../../library/sqlite3.rst:1376 ../../library/sqlite3.rst:1393
msgid "``REAL``"
msgstr "``REAL``"

#: ../../library/sqlite3.rst:1378
msgid ":class:`str`"
msgstr ":class:`str`"

#: ../../library/sqlite3.rst:1378 ../../library/sqlite3.rst:1395
msgid "``TEXT``"
msgstr "``TEXT``"

#: ../../library/sqlite3.rst:1380 ../../library/sqlite3.rst:1398
msgid ":class:`bytes`"
msgstr ":class:`bytes`"

#: ../../library/sqlite3.rst:1380 ../../library/sqlite3.rst:1398
msgid "``BLOB``"
msgstr "``BLOB``"

#: ../../library/sqlite3.rst:1384
msgid "This is how SQLite types are converted to Python types by default:"
msgstr "Detta är hur SQLite-typer konverteras till Python-typer som standard:"

#: ../../library/sqlite3.rst:1395
msgid "depends on :attr:`~Connection.text_factory`, :class:`str` by default"
msgstr "beror på :attr:`~Connection.text_factory`, :class:`str` som standard"

#: ../../library/sqlite3.rst:1401
msgid ""
"The type system of the :mod:`!sqlite3` module is extensible in two ways: you "
"can store additional Python types in an SQLite database via :ref:`object "
"adapters <sqlite3-adapters>`, and you can let the :mod:`!sqlite3` module "
"convert SQLite types to Python types via :ref:`converters <sqlite3-"
"converters>`."
msgstr ""
"Typsystemet i modulen :mod:`!sqlite3` är utbyggbart på två sätt: du kan "
"lagra ytterligare Python-typer i en SQLite-databas via :ref:`object adapters "
"<sqlite3-adapters>`, och du kan låta modulen :mod:`!sqlite3` konvertera "
"SQLite-typer till Python-typer via :ref:`converters <sqlite3-converters>`."

#: ../../library/sqlite3.rst:1411
msgid "Default adapters and converters"
msgstr ""

#: ../../library/sqlite3.rst:1413
msgid ""
"There are default adapters for the date and datetime types in the datetime "
"module. They will be sent as ISO dates/ISO timestamps to SQLite."
msgstr ""

#: ../../library/sqlite3.rst:1416
msgid ""
"The default converters are registered under the name \"date\" for :class:"
"`datetime.date` and under the name \"timestamp\" for :class:`datetime."
"datetime`."
msgstr ""

#: ../../library/sqlite3.rst:1420
msgid ""
"This way, you can use date/timestamps from Python without any additional "
"fiddling in most cases. The format of the adapters is also compatible with "
"the experimental SQLite date/time functions."
msgstr ""

#: ../../library/sqlite3.rst:1424
msgid "The following example demonstrates this."
msgstr ""

#: ../../library/sqlite3.rst:1428
msgid ""
"If a timestamp stored in SQLite has a fractional part longer than 6 numbers, "
"its value will be truncated to microsecond precision by the timestamp "
"converter."
msgstr ""

#: ../../library/sqlite3.rst:1434
msgid ""
"The default \"timestamp\" converter ignores UTC offsets in the database and "
"always returns a naive :class:`datetime.datetime` object. To preserve UTC "
"offsets in timestamps, either leave converters disabled, or register an "
"offset-aware converter with :func:`register_converter`."
msgstr ""
"Standardomvandlaren \"timestamp\" ignorerar UTC-offset i databasen och "
"returnerar alltid ett naivt :class:`datetime.datetime`\\-objekt. Om du vill "
"bevara UTC-offset i tidsstämplar ska du antingen låta omvandlare vara "
"inaktiverade eller registrera en offsetmedveten omvandlare med :func:"
"`register_converter`."

#: ../../library/sqlite3.rst:1443
msgid "How-to guides"
msgstr "Hur man gör-guider"

#: ../../library/sqlite3.rst:1448
msgid "How to use placeholders to bind values in SQL queries"
msgstr "Så här använder du platshållare för att binda värden i SQL-frågor"

#: ../../library/sqlite3.rst:1450
msgid ""
"SQL operations usually need to use values from Python variables. However, "
"beware of using Python's string operations to assemble queries, as they are "
"vulnerable to `SQL injection attacks`_. For example, an attacker can simply "
"close the single quote and inject ``OR TRUE`` to select all rows::"
msgstr ""
"SQL-operationer behöver vanligtvis använda värden från Python-variabler. Var "
"dock försiktig med att använda Pythons strängoperationer för att sätta ihop "
"frågor, eftersom de är sårbara för `SQL-injektionsattacker`_. Till exempel "
"kan en angripare helt enkelt stänga det enkla citatet och injicera ``OR "
"TRUE`` för att välja alla rader::"

#: ../../library/sqlite3.rst:1463
msgid ""
"Instead, use the DB-API's parameter substitution. To insert a variable into "
"a query string, use a placeholder in the string, and substitute the actual "
"values into the query by providing them as a :class:`tuple` of values to the "
"second argument of the cursor's :meth:`~Cursor.execute` method."
msgstr ""
"Använd istället DB-API:s parametersubstitution. Om du vill infoga en "
"variabel i en frågesträng använder du en platshållare i strängen och "
"ersätter de faktiska värdena i frågan genom att tillhandahålla dem som en :"
"class:`tuple` av värden till det andra argumentet i markörens :meth:`~Cursor."
"execute`\\-metod."

#: ../../library/sqlite3.rst:1468
msgid ""
"An SQL statement may use one of two kinds of placeholders: question marks "
"(qmark style) or named placeholders (named style). For the qmark style, "
"*parameters* must be a :term:`sequence` whose length must match the number "
"of placeholders, or a :exc:`ProgrammingError` is raised. For the named "
"style, *parameters* should be an instance of a :class:`dict` (or a "
"subclass), which must contain keys for all named parameters; any extra items "
"are ignored. Here's an example of both styles:"
msgstr ""

#: ../../library/sqlite3.rst:1505
msgid ""
":pep:`249` numeric placeholders are *not* supported. If used, they will be "
"interpreted as named placeholders."
msgstr ""
":pep:`249` numeriska platshållare stöds *inte*. Om de används kommer de att "
"tolkas som namngivna platshållare."

#: ../../library/sqlite3.rst:1512
msgid "How to adapt custom Python types to SQLite values"
msgstr "Så här anpassar du anpassade Python-typer till SQLite-värden"

#: ../../library/sqlite3.rst:1514
msgid ""
"SQLite supports only a limited set of data types natively. To store custom "
"Python types in SQLite databases, *adapt* them to one of the :ref:`Python "
"types SQLite natively understands <sqlite3-types>`."
msgstr ""
"SQLite stöder endast en begränsad uppsättning datatyper. För att lagra "
"anpassade Python-typer i SQLite-databaser, *anpassa* dem till en av :ref:"
"`Python-typer som SQLite förstår inbyggt <sqlite3-types>`."

#: ../../library/sqlite3.rst:1518
msgid ""
"There are two ways to adapt Python objects to SQLite types: letting your "
"object adapt itself, or using an *adapter callable*. The latter will take "
"precedence above the former. For a library that exports a custom type, it "
"may make sense to enable that type to adapt itself. As an application "
"developer, it may make more sense to take direct control by registering "
"custom adapter functions."
msgstr ""
"Det finns två sätt att anpassa Python-objekt till SQLite-typer: att låta "
"ditt objekt anpassa sig självt eller att använda en *adapter callable*. Det "
"senare kommer att ha företräde framför det förra. För ett bibliotek som "
"exporterar en anpassad typ kan det vara vettigt att låta den typen anpassa "
"sig själv. Som applikationsutvecklare kan det vara mer meningsfullt att ta "
"direkt kontroll genom att registrera anpassade adapterfunktioner."

#: ../../library/sqlite3.rst:1530
msgid "How to write adaptable objects"
msgstr "Hur man skriver anpassningsbara objekt"

#: ../../library/sqlite3.rst:1532
msgid ""
"Suppose we have a :class:`!Point` class that represents a pair of "
"coordinates, ``x`` and ``y``, in a Cartesian coordinate system. The "
"coordinate pair will be stored as a text string in the database, using a "
"semicolon to separate the coordinates. This can be implemented by adding a "
"``__conform__(self, protocol)`` method which returns the adapted value. The "
"object passed to *protocol* will be of type :class:`PrepareProtocol`."
msgstr ""
"Antag att vi har en :class:`!Point`\\-klass som representerar ett par "
"koordinater, ``x`` och ``y``, i ett kartesiskt koordinatsystem. "
"Koordinatparet kommer att lagras som en textsträng i databasen, med ett "
"semikolon för att separera koordinaterna. Detta kan implementeras genom att "
"lägga till en metod ``__conform__(self, protocol)`` som returnerar det "
"anpassade värdet. Objektet som skickas till *protocol* kommer att vara av "
"typen :class:`PrepareProtocol`."

#: ../../library/sqlite3.rst:1563
msgid "How to register adapter callables"
msgstr "Så här registrerar du adapterkallelser"

#: ../../library/sqlite3.rst:1565
msgid ""
"The other possibility is to create a function that converts the Python "
"object to an SQLite-compatible type. This function can then be registered "
"using :func:`register_adapter`."
msgstr ""
"Den andra möjligheten är att skapa en funktion som konverterar Python-"
"objektet till en SQLite-kompatibel typ. Denna funktion kan sedan registreras "
"med hjälp av :func:`register_adapter`."

#: ../../library/sqlite3.rst:1595
msgid "How to convert SQLite values to custom Python types"
msgstr "Så här konverterar du SQLite-värden till anpassade Python-typer"

#: ../../library/sqlite3.rst:1597
msgid ""
"Writing an adapter lets you convert *from* custom Python types *to* SQLite "
"values. To be able to convert *from* SQLite values *to* custom Python types, "
"we use *converters*."
msgstr ""
"Genom att skriva en adapter kan du konvertera *från* anpassade Python-typer "
"*till* SQLite-värden. För att kunna konvertera *från* SQLite-värden *till* "
"anpassade Python-typer använder vi *konverterare*."

#: ../../library/sqlite3.rst:1602
msgid ""
"Let's go back to the :class:`!Point` class. We stored the x and y "
"coordinates separated via semicolons as strings in SQLite."
msgstr ""
"Låt oss gå tillbaka till :class:`!Point`\\-klassen. Vi lagrade x- och y-"
"koordinaterna åtskilda med semikolon som strängar i SQLite."

#: ../../library/sqlite3.rst:1605
msgid ""
"First, we'll define a converter function that accepts the string as a "
"parameter and constructs a :class:`!Point` object from it."
msgstr ""
"Först definierar vi en konverteringsfunktion som tar emot en sträng som "
"parameter och konstruerar ett :class:`!Point`\\-objekt från den."

#: ../../library/sqlite3.rst:1610
msgid ""
"Converter functions are **always** passed a :class:`bytes` object, no matter "
"the underlying SQLite data type."
msgstr ""
"Konverteringsfunktioner får **alltid** ett :class:`bytes`\\-objekt, oavsett "
"den underliggande SQLite-datatypen."

#: ../../library/sqlite3.rst:1619
msgid ""
"We now need to tell :mod:`!sqlite3` when it should convert a given SQLite "
"value. This is done when connecting to a database, using the *detect_types* "
"parameter of :func:`connect`. There are three options:"
msgstr ""
"Vi måste nu tala om för :mod:`!sqlite3` när den ska konvertera ett givet "
"SQLite-värde. Detta görs när du ansluter till en databas, med hjälp av "
"parametern *detect_types* i :func:`connect`. Det finns tre alternativ:"

#: ../../library/sqlite3.rst:1623
msgid "Implicit: set *detect_types* to :const:`PARSE_DECLTYPES`"
msgstr "Implicit: sätt *detect_types* till :const:`PARSE_DECLTYPES`"

#: ../../library/sqlite3.rst:1624
msgid "Explicit: set *detect_types* to :const:`PARSE_COLNAMES`"
msgstr "Explicit: sätt *detect_types* till :const:`PARSE_COLNAMES`"

#: ../../library/sqlite3.rst:1625
msgid ""
"Both: set *detect_types* to ``sqlite3.PARSE_DECLTYPES | sqlite3."
"PARSE_COLNAMES``. Column names take precedence over declared types."
msgstr ""
"Båda: sätt *detect_types* till ``sqlite3.PARSE_DECLTYPES | sqlite3."
"PARSE_COLNAMES``. Kolumnnamn har företräde framför deklarerade typer."

#: ../../library/sqlite3.rst:1629
msgid "The following example illustrates the implicit and explicit approaches:"
msgstr ""
"Följande exempel illustrerar de implicita och explicita tillvägagångssätten:"

#: ../../library/sqlite3.rst:1680
msgid "Adapter and converter recipes"
msgstr "Adapter- och konverterrecept"

#: ../../library/sqlite3.rst:1682
msgid "This section shows recipes for common adapters and converters."
msgstr "I detta avsnitt visas recept för vanliga adaptrar och konvertrar."

#: ../../library/sqlite3.rst:1744
msgid "How to use connection shortcut methods"
msgstr "Så här använder du genvägsmetoder för anslutning"

#: ../../library/sqlite3.rst:1746
msgid ""
"Using the :meth:`~Connection.execute`, :meth:`~Connection.executemany`, and :"
"meth:`~Connection.executescript` methods of the :class:`Connection` class, "
"your code can be written more concisely because you don't have to create the "
"(often superfluous) :class:`Cursor` objects explicitly. Instead, the :class:"
"`Cursor` objects are created implicitly and these shortcut methods return "
"the cursor objects. This way, you can execute a ``SELECT`` statement and "
"iterate over it directly using only a single call on the :class:`Connection` "
"object."
msgstr ""
"Med hjälp av metoderna :meth:`~Connection.execute`, :meth:`~Connection."
"executemany` och :meth:`~Connection.executescript` i klassen :class:"
"`Connection` kan din kod skrivas mer koncist eftersom du inte behöver skapa "
"de (ofta överflödiga) :class:`Cursor`\\-objekten explicit. Istället skapas :"
"class:`Cursor`\\-objekten implicit och dessa genvägsmetoder returnerar "
"cursor-objekten. På så sätt kan du köra en ``SELECT``\\-sats och iterera "
"över den direkt med bara ett enda anrop på :class:`Connection`\\-objektet."

#: ../../library/sqlite3.rst:1787
msgid "How to use the connection context manager"
msgstr "Så här använder du kontexthanteraren för anslutningar"

#: ../../library/sqlite3.rst:1789
msgid ""
"A :class:`Connection` object can be used as a context manager that "
"automatically commits or rolls back open transactions when leaving the body "
"of the context manager. If the body of the :keyword:`with` statement "
"finishes without exceptions, the transaction is committed. If this commit "
"fails, or if the body of the ``with`` statement raises an uncaught "
"exception, the transaction is rolled back."
msgstr ""

#: ../../library/sqlite3.rst:1798
msgid ""
"If there is no open transaction upon leaving the body of the ``with`` "
"statement, the context manager is a no-op."
msgstr ""

#: ../../library/sqlite3.rst:1803
msgid ""
"The context manager neither implicitly opens a new transaction nor closes "
"the connection."
msgstr ""

#: ../../library/sqlite3.rst:1836
msgid "How to work with SQLite URIs"
msgstr "Så här arbetar du med SQLite URI:er"

#: ../../library/sqlite3.rst:1838
msgid "Some useful URI tricks include:"
msgstr "Några användbara URI-trick inkluderar:"

#: ../../library/sqlite3.rst:1840
msgid "Open a database in read-only mode:"
msgstr "Öppna en databas i skrivskyddat läge:"

#: ../../library/sqlite3.rst:1849
msgid ""
"Do not implicitly create a new database file if it does not already exist; "
"will raise :exc:`~sqlite3.OperationalError` if unable to create a new file:"
msgstr ""
"Skapa inte implicit en ny databasfil om den inte redan finns; kommer att ge "
"upphov till :exc:`~sqlite3.OperationalError` om det inte går att skapa en ny "
"fil:"

#: ../../library/sqlite3.rst:1859
msgid "Create a shared named in-memory database:"
msgstr "Skapa en delad namngiven databas i minnet:"

#: ../../library/sqlite3.rst:1873
msgid ""
"More information about this feature, including a list of parameters, can be "
"found in the `SQLite URI documentation`_."
msgstr ""
"Mer information om den här funktionen, inklusive en lista med parametrar, "
"finns i `SQLite URI-dokumentation`_."

#: ../../library/sqlite3.rst:1882
msgid "How to create and use row factories"
msgstr "Så här skapar och använder du radfabriker"

#: ../../library/sqlite3.rst:1884
msgid ""
"By default, :mod:`!sqlite3` represents each row as a :class:`tuple`. If a :"
"class:`!tuple` does not suit your needs, you can use the :class:`sqlite3."
"Row` class or a custom :attr:`~Cursor.row_factory`."
msgstr ""
"Som standard representerar :mod:`!sqlite3` varje rad som en :class:`tuple`. "
"Om en :class:`!tuple` inte passar dina behov kan du använda :class:`sqlite3."
"Row`\\-klassen eller en anpassad :attr:`~Cursor.row_factory`."

#: ../../library/sqlite3.rst:1889
msgid ""
"While :attr:`!row_factory` exists as an attribute both on the :class:"
"`Cursor` and the :class:`Connection`, it is recommended to set :class:"
"`Connection.row_factory`, so all cursors created from the connection will "
"use the same row factory."
msgstr ""
"Även om :attr:`!row_factory` finns som attribut både för :class:`Cursor` "
"och :class:`Connection`, rekommenderas att man anger :class:`Connection."
"row_factory`, så att alla markörer som skapas från anslutningen använder "
"samma radfabrik."

#: ../../library/sqlite3.rst:1894
msgid ""
":class:`!Row` provides indexed and case-insensitive named access to columns, "
"with minimal memory overhead and performance impact over a :class:`!tuple`. "
"To use :class:`!Row` as a row factory, assign it to the :attr:`!row_factory` "
"attribute:"
msgstr ""
":class:`!Row` ger indexerad och skiftlägesokänslig namngiven åtkomst till "
"kolumner, med minimal minnesbelastning och prestandapåverkan jämfört med en :"
"class:`!tuple`. För att använda :class:`!Row` som en radfabrik, tilldela den "
"till attributet :attr:`!row_factory`:"

#: ../../library/sqlite3.rst:1904
msgid "Queries now return :class:`!Row` objects:"
msgstr "Frågor returnerar nu :class:`!Row`\\-objekt:"

#: ../../library/sqlite3.rst:1919
msgid ""
"You can create a custom :attr:`~Cursor.row_factory` that returns each row as "
"a :class:`dict`, with column names mapped to values:"
msgstr ""
"Du kan skapa en egen :attr:`~Cursor.row_factory` som returnerar varje rad "
"som en :class:`dict`, med kolumnnamn mappade till värden:"

#: ../../library/sqlite3.rst:1928
msgid ""
"Using it, queries now return a :class:`!dict` instead of a :class:`!tuple`:"
msgstr ""
"Med hjälp av den returnerar frågor nu en :class:`!dict` i stället för en :"
"class:`!tuple`:"

#: ../../library/sqlite3.rst:1938
msgid "The following row factory returns a :term:`named tuple`:"
msgstr "Följande radfabrik returnerar en :term:`named tuple`:"

#: ../../library/sqlite3.rst:1949
msgid ":func:`!namedtuple_factory` can be used as follows:"
msgstr ":func:`!namedtuple_factory` kan användas på följande sätt:"

#: ../../library/sqlite3.rst:1964
msgid ""
"With some adjustments, the above recipe can be adapted to use a :class:"
"`~dataclasses.dataclass`, or any other custom class, instead of a :class:"
"`~collections.namedtuple`."
msgstr ""
"Med några justeringar kan ovanstående recept anpassas så att man använder "
"en :class:`~dataclasses.dataclass`, eller någon annan anpassad klass, i "
"stället för en :class:`~collections.namedtuple`."

#: ../../library/sqlite3.rst:1972
msgid "Explanation"
msgstr "Förklaring"

#: ../../library/sqlite3.rst:1977
msgid "Transaction control"
msgstr "Kontroll av transaktioner"

#: ../../library/sqlite3.rst:1979
msgid ""
"The :mod:`!sqlite3` module does not adhere to the transaction handling "
"recommended by :pep:`249`."
msgstr ""

#: ../../library/sqlite3.rst:1982
msgid ""
"If the connection attribute :attr:`~Connection.isolation_level` is not "
"``None``, new transactions are implicitly opened before :meth:`~Cursor."
"execute` and :meth:`~Cursor.executemany` executes ``INSERT``, ``UPDATE``, "
"``DELETE``, or ``REPLACE`` statements; for other statements, no implicit "
"transaction handling is performed. Use the :meth:`~Connection.commit` and :"
"meth:`~Connection.rollback` methods to respectively commit and roll back "
"pending transactions. You can choose the underlying `SQLite transaction "
"behaviour`_ — that is, whether and what type of ``BEGIN`` statements :mod:`!"
"sqlite3` implicitly executes – via the :attr:`~Connection.isolation_level` "
"attribute."
msgstr ""
"Om anslutningsattributet :attr:`~Connection.isolation_level` inte är "
"``None`` öppnas nya transaktioner implicit innan :meth:`~Cursor.execute` "
"och :meth:`~Cursor.executemany` utför ``INSERT``, ``UPDATE``, ``DELETE`` "
"eller ``REPLACE``\\-satser; för andra satser utförs ingen implicit "
"transaktionshantering. Använd metoderna :meth:`~Connection.commit` och :meth:"
"`~Connection.rollback` för att binda respektive rulla tillbaka pågående "
"transaktioner. Du kan välja det underliggande `SQLite-"
"transaktionsbeteendet`_ - det vill säga om och vilken typ av ``BEGIN``\\-"
"satser som :mod:`!sqlite3` implicit utför - via attributet :attr:"
"`~Connection.isolation_level`."

#: ../../library/sqlite3.rst:1995
msgid ""
"If :attr:`~Connection.isolation_level` is set to ``None``, no transactions "
"are implicitly opened at all. This leaves the underlying SQLite library in "
"`autocommit mode`_, but also allows the user to perform their own "
"transaction handling using explicit SQL statements. The underlying SQLite "
"library autocommit mode can be queried using the :attr:`~Connection."
"in_transaction` attribute."
msgstr ""
"Om :attr:`~Connection.isolation_level` är satt till ``None``, öppnas inga "
"transaktioner alls implicit. Detta lämnar det underliggande SQLite-"
"biblioteket i `autocommit mode`_, men gör det också möjligt för användaren "
"att utföra sin egen transaktionshantering med hjälp av explicita SQL-satser. "
"Det underliggande SQLite-bibliotekets autocommit-läge kan efterfrågas med "
"hjälp av attributet :attr:`~Connection.in_transaction`."

#: ../../library/sqlite3.rst:2003
msgid ""
"The :meth:`~Cursor.executescript` method implicitly commits any pending "
"transaction before execution of the given SQL script, regardless of the "
"value of :attr:`~Connection.isolation_level`."
msgstr ""
"Metoden :meth:`~Cursor.executescript` binder implicit alla väntande "
"transaktioner innan det angivna SQL-skriptet körs, oavsett värdet på :attr:"
"`~Connection.isolation_level`."

#: ../../library/sqlite3.rst:2007
msgid ""
":mod:`!sqlite3` used to implicitly commit an open transaction before DDL "
"statements.  This is no longer the case."
msgstr ""
":mod:`!sqlite3` brukade implicit binda en öppen transaktion före DDL-"
"satser.  Detta är inte längre fallet."
