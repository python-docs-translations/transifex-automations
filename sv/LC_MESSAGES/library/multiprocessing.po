# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-07 20:38+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../library/multiprocessing.rst:2
msgid ":mod:`!multiprocessing` --- Process-based parallelism"
msgstr ":mod:`!multiprocessing` --- Processbaserad parallellism"

#: ../../library/multiprocessing.rst:7
msgid "**Source code:** :source:`Lib/multiprocessing/`"
msgstr "**Källkod:** :source:`Lib/multiprocessing/`"

#: ../../includes/wasm-mobile-notavail.rst:3
msgid "Availability"
msgstr "Tillgänglighet"

#: ../../includes/wasm-mobile-notavail.rst:5
msgid ""
"This module is not supported on :ref:`mobile platforms <mobile-"
"availability>` or :ref:`WebAssembly platforms <wasm-availability>`."
msgstr ""
"Denna modul stöds inte på :ref:`mobile platforms <mobile-availability>` "
"eller :ref:`WebAssembly platforms <wasm-availability>`."

#: ../../library/multiprocessing.rst:14
msgid "Introduction"
msgstr "Introduktion"

#: ../../library/multiprocessing.rst:16
msgid ""
":mod:`multiprocessing` is a package that supports spawning processes using "
"an API similar to the :mod:`threading` module.  The :mod:`multiprocessing` "
"package offers both local and remote concurrency, effectively side-stepping "
"the :term:`Global Interpreter Lock <global interpreter lock>` by using "
"subprocesses instead of threads.  Due to this, the :mod:`multiprocessing` "
"module allows the programmer to fully leverage multiple processors on a "
"given machine.  It runs on both POSIX and Windows."
msgstr ""
":mod:`multiprocessing` är ett paket med stöd för att skapa processer med "
"hjälp av ett API som liknar modulen :mod:`threading`.  Paketet :mod:"
"`multiprocessing` erbjuder både lokal och fjärransluten samtidighet, vilket "
"effektivt kringgår :term:`Global Interpreter Lock <global interpreter lock>` "
"genom att använda underprocesser istället för trådar.  På grund av detta "
"tillåter :mod:`multiprocessing`-modulen programmeraren att fullt ut utnyttja "
"flera processorer på en given maskin.  Den körs på både POSIX och Windows."

#: ../../library/multiprocessing.rst:25
msgid ""
"The :mod:`multiprocessing` module also introduces APIs which do not have "
"analogs in the :mod:`threading` module.  A prime example of this is the :"
"class:`~multiprocessing.pool.Pool` object which offers a convenient means of "
"parallelizing the execution of a function across multiple input values, "
"distributing the input data across processes (data parallelism).  The "
"following example demonstrates the common practice of defining such "
"functions in a module so that child processes can successfully import that "
"module.  This basic example of data parallelism using :class:"
"`~multiprocessing.pool.Pool`, ::"
msgstr ""
"Modulen :mod:`multiprocessing` introducerar också API:er som inte har någon "
"motsvarighet i modulen :mod:`threading`.  Ett utmärkt exempel på detta är :"
"class:`~multiprocessing.pool.Pool`-objektet som erbjuder ett bekvämt sätt "
"att parallellisera exekveringen av en funktion över flera indatavärden genom "
"att distribuera indata över processer (dataparallellism).  Följande exempel "
"visar hur det är vanligt att definiera sådana funktioner i en modul så att "
"underordnade processer kan importera den modulen.  Detta grundläggande "
"exempel på dataparallellism använder :class:`~multiprocessing.pool.Pool`, ::"

#: ../../library/multiprocessing.rst:34
msgid ""
"from multiprocessing import Pool\n"
"\n"
"def f(x):\n"
"    return x*x\n"
"\n"
"if __name__ == '__main__':\n"
"    with Pool(5) as p:\n"
"        print(p.map(f, [1, 2, 3]))"
msgstr ""
"från multiprocessing import Pool\n"
"\n"
"def f(x):\n"
"    returnerar x*x\n"
"\n"
"om __name__ == '__main__':\n"
"    med Pool(5) som p:\n"
"        print(p.map(f, [1, 2, 3]))"

#: ../../library/multiprocessing.rst:43
msgid "will print to standard output ::"
msgstr "kommer att skrivas ut till standardutmatningen ::"

#: ../../library/multiprocessing.rst:45
msgid "[1, 4, 9]"
msgstr "[1, 4, 9]"

#: ../../library/multiprocessing.rst:50
msgid ""
":class:`concurrent.futures.ProcessPoolExecutor` offers a higher level "
"interface to push tasks to a background process without blocking execution "
"of the calling process. Compared to using the :class:`~multiprocessing.pool."
"Pool` interface directly, the :mod:`concurrent.futures` API more readily "
"allows the submission of work to the underlying process pool to be separated "
"from waiting for the results."
msgstr ""
":class:`concurrent.futures.ProcessPoolExecutor` erbjuder ett gränssnitt på "
"högre nivå för att flytta uppgifter till en bakgrundsprocess utan att "
"blockera körningen av den anropande processen. Jämfört med att använda "
"gränssnittet :class:`~multiprocessing.pool.Pool` direkt, gör API:t :mod:"
"`concurrent.futures` det lättare att separera inlämning av arbete till den "
"underliggande processpoolen från väntan på resultat."

#: ../../library/multiprocessing.rst:59
msgid "The :class:`Process` class"
msgstr "Klassen :class:`Process"

#: ../../library/multiprocessing.rst:61
msgid ""
"In :mod:`multiprocessing`, processes are spawned by creating a :class:"
"`Process` object and then calling its :meth:`~Process.start` method.  :class:"
"`Process` follows the API of :class:`threading.Thread`.  A trivial example "
"of a multiprocess program is ::"
msgstr ""
"I :mod:`multiprocessing` startas processer genom att skapa ett :class:"
"`Process`-objekt och sedan anropa dess :meth:`~Process.start`-metod. :class:"
"`Process` följer API:et för :class:`threading.Thread`.  Ett trivialt exempel "
"på ett multiprocessprogram är ::"

#: ../../library/multiprocessing.rst:66
msgid ""
"from multiprocessing import Process\n"
"\n"
"def f(name):\n"
"    print('hello', name)\n"
"\n"
"if __name__ == '__main__':\n"
"    p = Process(target=f, args=('bob',))\n"
"    p.start()\n"
"    p.join()"
msgstr ""
"från multiprocessing import Process\n"
"\n"
"def f(namn):\n"
"    print('hallå', namn)\n"
"\n"
"if __name__ == '__main__':\n"
"    p = Process(mål=f, args=('bob',))\n"
"    p.start()\n"
"    p.join()"

#: ../../library/multiprocessing.rst:76
msgid ""
"To show the individual process IDs involved, here is an expanded example::"
msgstr ""
"För att visa de enskilda process-ID:n som är inblandade följer här ett "
"utökat exempel::"

#: ../../library/multiprocessing.rst:78
msgid ""
"from multiprocessing import Process\n"
"import os\n"
"\n"
"def info(title):\n"
"    print(title)\n"
"    print('module name:', __name__)\n"
"    print('parent process:', os.getppid())\n"
"    print('process id:', os.getpid())\n"
"\n"
"def f(name):\n"
"    info('function f')\n"
"    print('hello', name)\n"
"\n"
"if __name__ == '__main__':\n"
"    info('main line')\n"
"    p = Process(target=f, args=('bob',))\n"
"    p.start()\n"
"    p.join()"
msgstr ""
"från multiprocessing import Process\n"
"importera os\n"
"\n"
"def info(titel):\n"
"    print(titel)\n"
"    print('modulens namn:', __name__)\n"
"    print('överordnad process:', os.getppid())\n"
"    print('process-id:', os.getpid())\n"
"\n"
"def f(namn):\n"
"    info('funktion f')\n"
"    print('hallå', namn)\n"
"\n"
"om __name__ == '__main__':\n"
"    info('huvudlinje')\n"
"    p = Process(mål=f, args=('bob',))\n"
"    p.start()\n"
"    p.join()"

#: ../../library/multiprocessing.rst:97
msgid ""
"For an explanation of why the ``if __name__ == '__main__'`` part is "
"necessary, see :ref:`multiprocessing-programming`."
msgstr ""
"För en förklaring till varför ``if __name__ == '__main__'``-delen är "
"nödvändig, se :ref:`multiprocessing-programming`."

#: ../../library/multiprocessing.rst:100
msgid ""
"The arguments to :class:`Process` usually need to be unpickleable from "
"within the child process. If you tried typing the above example directly "
"into a REPL it could lead to an :exc:`AttributeError` in the child process "
"trying to locate the *f* function in the ``__main__`` module."
msgstr ""
"Argumenten till :class:`Process` måste vanligtvis vara omöjliga att plocka "
"upp från barnprocessen. Om du försökte skriva in ovanstående exempel direkt "
"i en REPL skulle det kunna leda till ett :exc:`AttributeError` i "
"barnprocessen som försöker hitta funktionen *f* i modulen ``__main__``."

#: ../../library/multiprocessing.rst:109
msgid "Contexts and start methods"
msgstr "Sammanhang och startmetoder"

#: ../../library/multiprocessing.rst:111
msgid ""
"Depending on the platform, :mod:`multiprocessing` supports three ways to "
"start a process.  These *start methods* are"
msgstr ""
"Beroende på plattform har :mod:`multiprocessing` stöd för tre sätt att "
"starta en process.  Dessa *startmetoder* är"

#: ../../library/multiprocessing.rst:116
msgid "*spawn*"
msgstr "*spawn*"

#: ../../library/multiprocessing.rst:117
msgid ""
"The parent process starts a fresh Python interpreter process.  The child "
"process will only inherit those resources necessary to run the process "
"object's :meth:`~Process.run` method.  In particular, unnecessary file "
"descriptors and handles from the parent process will not be inherited.  "
"Starting a process using this method is rather slow compared to using *fork* "
"or *forkserver*."
msgstr ""
"Den överordnade processen startar en ny Python-tolkprocess.  Barnprocessen "
"kommer endast att ärva de resurser som krävs för att köra processobjektets :"
"meth:`~Process.run`-metod.  I synnerhet kommer onödiga filbeskrivare och "
"handtag från den överordnade processen inte att ärvas.  Att starta en "
"process med den här metoden är ganska långsamt jämfört med att använda "
"*fork* eller *forkserver*."

#: ../../library/multiprocessing.rst:124
msgid ""
"Available on POSIX and Windows platforms.  The default on Windows and macOS."
msgstr ""
"Finns på POSIX- och Windows-plattformar.  Standard på Windows och macOS."

#: ../../library/multiprocessing.rst:128
msgid "*fork*"
msgstr "*gaffel*"

#: ../../library/multiprocessing.rst:129
msgid ""
"The parent process uses :func:`os.fork` to fork the Python interpreter.  The "
"child process, when it begins, is effectively identical to the parent "
"process.  All resources of the parent are inherited by the child process.  "
"Note that safely forking a multithreaded process is problematic."
msgstr ""
"Den överordnade processen använder :func:`os.fork` för att förgrena Python-"
"tolken.  När barnprocessen startar är den i praktiken identisk med den "
"överordnade processen.  Alla resurser från den överordnade processen ärvs av "
"barnprocessen.  Observera att det är problematiskt att på ett säkert sätt "
"forka en flertrådad process."

#: ../../library/multiprocessing.rst:135
msgid "Available on POSIX systems."
msgstr "Tillgänglig på POSIX-system."

#: ../../library/multiprocessing.rst:137
msgid ""
"This is no longer the default start method on any platform. Code that "
"requires *fork* must explicitly specify that via :func:`get_context` or :"
"func:`set_start_method`."
msgstr ""
"Detta är inte längre standardstartmetoden på någon plattform. Kod som kräver "
"*fork* måste uttryckligen ange det via :func:`get_context` eller :func:"
"`set_start_method`."

#: ../../library/multiprocessing.rst:142
msgid ""
"If Python is able to detect that your process has multiple threads, the :"
"func:`os.fork` function that this start method calls internally will raise "
"a :exc:`DeprecationWarning`. Use a different start method. See the :func:`os."
"fork` documentation for further explanation."
msgstr ""
"Om Python kan upptäcka att din process har flera trådar, kommer funktionen :"
"func:`os.fork` som denna startmetod anropar internt att ge upphov till en :"
"exc:`DeprecationWarning`. Använd en annan startmetod. Se dokumentationen "
"för :func:`os.fork` för ytterligare förklaringar."

#: ../../library/multiprocessing.rst:150
msgid "*forkserver*"
msgstr "*forkserver*"

#: ../../library/multiprocessing.rst:151
msgid ""
"When the program starts and selects the *forkserver* start method, a server "
"process is spawned.  From then on, whenever a new process is needed, the "
"parent process connects to the server and requests that it fork a new "
"process.  The fork server process is single threaded unless system libraries "
"or preloaded imports spawn threads as a side-effect so it is generally safe "
"for it to use :func:`os.fork`. No unnecessary resources are inherited."
msgstr ""
"När programmet startas och startmetoden *forkserver* väljs, skapas en "
"serverprocess.  Från och med då, när en ny process behövs, ansluter den "
"överordnade processen till servern och begär att den forkar en ny process.  "
"Fork-serverprocessen är enkeltrådad om inte systembibliotek eller "
"förinstallerade importer skapar trådar som en bieffekt, så det är i "
"allmänhet säkert för den att använda :func:`os.fork`. Inga onödiga resurser "
"ärvs."

#: ../../library/multiprocessing.rst:159
msgid ""
"Available on POSIX platforms which support passing file descriptors over "
"Unix pipes such as Linux.  The default on those."
msgstr ""
"Finns på POSIX-plattformar som stöder överföring av filbeskrivare via Unix "
"pipes, t.ex. Linux.  Standard på dessa."

#: ../../library/multiprocessing.rst:162
msgid "This became the default start method on POSIX platforms."
msgstr "Detta blev standardstartmetoden på POSIX-plattformar."

#: ../../library/multiprocessing.rst:165
msgid ""
"*spawn* added on all POSIX platforms, and *forkserver* added for some POSIX "
"platforms. Child processes no longer inherit all of the parents inheritable "
"handles on Windows."
msgstr ""
"*spawn* har lagts till på alla POSIX-plattformar och *forkserver* har lagts "
"till på vissa POSIX-plattformar. Barnprocesser ärver inte längre alla "
"föräldrarnas ärftliga handtag i Windows."

#: ../../library/multiprocessing.rst:173
msgid ""
"On macOS, the *spawn* start method is now the default.  The *fork* start "
"method should be considered unsafe as it can lead to crashes of the "
"subprocess as macOS system libraries may start threads. See :issue:`33725`."
msgstr ""
"På macOS är startmetoden *spawn* nu standard.  Startmetoden *fork* bör "
"betraktas som osäker eftersom den kan leda till att underprocessen kraschar "
"eftersom systembiblioteken i macOS kan starta trådar. Se :issue:`33725`."

#: ../../library/multiprocessing.rst:179
msgid ""
"On POSIX platforms the default start method was changed from *fork* to "
"*forkserver* to retain the performance but avoid common multithreaded "
"process incompatibilities. See :gh:`84559`."
msgstr ""
"På POSIX-plattformar ändrades standardstartmetoden från *fork* till "
"*forkserver* för att bibehålla prestandan men undvika vanliga "
"inkompatibiliteter med flertrådade processer. Se :gh:`84559`."

#: ../../library/multiprocessing.rst:184
msgid ""
"On POSIX using the *spawn* or *forkserver* start methods will also start a "
"*resource tracker* process which tracks the unlinked named system resources "
"(such as named semaphores or :class:`~multiprocessing.shared_memory."
"SharedMemory` objects) created by processes of the program.  When all "
"processes have exited the resource tracker unlinks any remaining tracked "
"object. Usually there should be none, but if a process was killed by a "
"signal there may be some \"leaked\" resources.  (Neither leaked semaphores "
"nor shared memory segments will be automatically unlinked until the next "
"reboot. This is problematic for both objects because the system allows only "
"a limited number of named semaphores, and shared memory segments occupy some "
"space in the main memory.)"
msgstr ""
"På POSIX startar startmetoderna *spawn* eller *forkserver* även en *resource "
"tracker*-process som spårar de olänkade namngivna systemresurser (t.ex. "
"namngivna semaforer eller :class:`~multiprocessing.shared_memory."
"SharedMemory`-objekt) som skapas av processer i programmet.  När alla "
"processer har avslutats kopplar resursspåraren bort eventuella kvarvarande "
"spårningsobjekt. Vanligtvis bör det inte finnas några, men om en process "
"dödades av en signal kan det finnas några \"läckta\" resurser.  (Varken "
"läckta semaforer eller delade minnessegment kommer automatiskt att avlänkas "
"förrän vid nästa omstart. Detta är problematiskt för båda objekten eftersom "
"systemet endast tillåter ett begränsat antal namngivna semaforer, och delade "
"minnessegment upptar en del utrymme i huvudminnet)"

#: ../../library/multiprocessing.rst:197
msgid ""
"To select a start method you use the :func:`set_start_method` in the ``if "
"__name__ == '__main__'`` clause of the main module.  For example::"
msgstr ""
"För att välja en startmetod använder du :func:`set_start_method` i ``if "
"__name__ == '__main__'`` i huvudmodulens klausul.  Till exempel::"

#: ../../library/multiprocessing.rst:201
msgid ""
"import multiprocessing as mp\n"
"\n"
"def foo(q):\n"
"    q.put('hello')\n"
"\n"
"if __name__ == '__main__':\n"
"    mp.set_start_method('spawn')\n"
"    q = mp.Queue()\n"
"    p = mp.Process(target=foo, args=(q,))\n"
"    p.start()\n"
"    print(q.get())\n"
"    p.join()"
msgstr ""
"importera multiprocessing som mp\n"
"\n"
"def foo(q):\n"
"    q.put('hej')\n"
"\n"
"if __name__ == '__main__':\n"
"    mp.set_start_method('spawn')\n"
"    q = mp.kö()\n"
"    p = mp.Process(mål=foo, args=(q,))\n"
"    p.start()\n"
"    print(q.get())\n"
"    p.join()"

#: ../../library/multiprocessing.rst:214
msgid ""
":func:`set_start_method` should not be used more than once in the program."
msgstr ""
":func:`set_start_method` bör inte användas mer än en gång i programmet."

#: ../../library/multiprocessing.rst:217
msgid ""
"Alternatively, you can use :func:`get_context` to obtain a context object.  "
"Context objects have the same API as the multiprocessing module, and allow "
"one to use multiple start methods in the same program. ::"
msgstr ""
"Alternativt kan du använda :func:`get_context` för att hämta ett "
"kontextobjekt.  Context-objekt har samma API som multiprocessing-modulen och "
"gör att man kan använda flera startmetoder i samma program. ::"

#: ../../library/multiprocessing.rst:222
msgid ""
"import multiprocessing as mp\n"
"\n"
"def foo(q):\n"
"    q.put('hello')\n"
"\n"
"if __name__ == '__main__':\n"
"    ctx = mp.get_context('spawn')\n"
"    q = ctx.Queue()\n"
"    p = ctx.Process(target=foo, args=(q,))\n"
"    p.start()\n"
"    print(q.get())\n"
"    p.join()"
msgstr ""
"importera multiprocessing som mp\n"
"\n"
"def foo(q):\n"
"    q.put('hej')\n"
"\n"
"if __name__ == '__main__':\n"
"    ctx = mp.get_context('spawn')\n"
"    q = ctx.Queue()\n"
"    p = ctx.Process(mål=foo, args=(q,))\n"
"    p.start()\n"
"    print(q.get())\n"
"    p.join()"

#: ../../library/multiprocessing.rst:235
msgid ""
"Note that objects related to one context may not be compatible with "
"processes for a different context.  In particular, locks created using the "
"*fork* context cannot be passed to processes started using the *spawn* or "
"*forkserver* start methods."
msgstr ""
"Observera att objekt som är relaterade till en kontext kanske inte är "
"kompatibla med processer för en annan kontext.  I synnerhet kan lås som "
"skapats med kontexten *fork* inte skickas till processer som startats med "
"startmetoderna *spawn* eller *forkserver*."

#: ../../library/multiprocessing.rst:240
msgid ""
"Libraries using :mod:`multiprocessing` or :class:`~concurrent.futures."
"ProcessPoolExecutor` should be designed to allow their users to provide "
"their own multiprocessing context.  Using a specific context of your own "
"within a library can lead to incompatibilities with the rest of the library "
"user's application.  Always document if your library requires a specific "
"start method."
msgstr ""
"Bibliotek som använder :mod:`multiprocessing` eller :class:`~concurrent."
"futures.ProcessPoolExecutor` bör utformas så att de tillåter sina användare "
"att tillhandahålla sin egen multiprocessing-kontext.  Om du använder en egen "
"specifik kontext i ett bibliotek kan det leda till inkompatibilitet med "
"resten av biblioteksanvändarens applikation.  Dokumentera alltid om ditt "
"bibliotek kräver en specifik startmetod."

#: ../../library/multiprocessing.rst:249
msgid ""
"The ``'spawn'`` and ``'forkserver'`` start methods generally cannot be used "
"with \"frozen\" executables (i.e., binaries produced by packages like "
"**PyInstaller** and **cx_Freeze**) on POSIX systems. The ``'fork'`` start "
"method may work if code does not use threads."
msgstr ""
"Startmetoderna ``'spawn'`` och ``'forkserver'`` kan i allmänhet inte "
"användas med \"frysta\" körbara filer (dvs. binära filer som produceras av "
"paket som **PyInstaller** och **cx_Freeze**) på POSIX-system. Startmetoden "
"``'fork'`` kan fungera om koden inte använder trådar."

#: ../../library/multiprocessing.rst:256
msgid "Exchanging objects between processes"
msgstr "Utbyte av objekt mellan processer"

#: ../../library/multiprocessing.rst:258
msgid ""
":mod:`multiprocessing` supports two types of communication channel between "
"processes:"
msgstr ""
":mod:`multiprocessing` stöder två typer av kommunikationskanaler mellan "
"processer:"

#: ../../library/multiprocessing.rst:261
msgid "**Queues**"
msgstr "**Köer**"

#: ../../library/multiprocessing.rst:263
msgid ""
"The :class:`Queue` class is a near clone of :class:`queue.Queue`.  For "
"example::"
msgstr ""
"Klassen :class:`Queue` är en nära klon av :class:`queue.Queue`.  Till "
"exempel::"

#: ../../library/multiprocessing.rst:266
msgid ""
"from multiprocessing import Process, Queue\n"
"\n"
"def f(q):\n"
"    q.put([42, None, 'hello'])\n"
"\n"
"if __name__ == '__main__':\n"
"    q = Queue()\n"
"    p = Process(target=f, args=(q,))\n"
"    p.start()\n"
"    print(q.get())    # prints \"[42, None, 'hello']\"\n"
"    p.join()"
msgstr ""
"från multiprocessing import Process, Kö\n"
"\n"
"def f(q):\n"
"    q.put([42, None, 'hallå'])\n"
"\n"
"if __name__ == '__main__':\n"
"    q = kö()\n"
"    p = Process(mål=f, args=(q,))\n"
"    p.start()\n"
"    print(q.get()) # skriver ut \"[42, None, 'hello']\"\n"
"    p.join()"

#: ../../library/multiprocessing.rst:278
msgid ""
"Queues are thread and process safe. Any object put into a :mod:"
"`~multiprocessing` queue will be serialized."
msgstr ""
"Köer är tråd- och processäkra. Alla objekt som sätts in i en :mod:"
"`~multiprocessing`-kö kommer att serialiseras."

#: ../../library/multiprocessing.rst:281
msgid "**Pipes**"
msgstr "**Pipor**"

#: ../../library/multiprocessing.rst:283
msgid ""
"The :func:`Pipe` function returns a pair of connection objects connected by "
"a pipe which by default is duplex (two-way).  For example::"
msgstr ""
"Funktionen :func:`Pipe` returnerar ett par anslutningsobjekt som är anslutna "
"med en pipe som standard är duplex (tvåvägs).  Till exempel::"

#: ../../library/multiprocessing.rst:286
msgid ""
"from multiprocessing import Process, Pipe\n"
"\n"
"def f(conn):\n"
"    conn.send([42, None, 'hello'])\n"
"    conn.close()\n"
"\n"
"if __name__ == '__main__':\n"
"    parent_conn, child_conn = Pipe()\n"
"    p = Process(target=f, args=(child_conn,))\n"
"    p.start()\n"
"    print(parent_conn.recv())   # prints \"[42, None, 'hello']\"\n"
"    p.join()"
msgstr ""
"från multiprocessing import Process, Rör\n"
"\n"
"def f(conn):\n"
"    conn.send([42, None, 'hallå'])\n"
"    conn.close()\n"
"\n"
"if __name__ == '__main__':\n"
"    parent_conn, child_conn = Pipe()\n"
"    p = Process(mål=f, args=(barn_conn,))\n"
"    p.start()\n"
"    print(parent_conn.recv()) # skriver ut \"[42, None, 'hello']\"\n"
"    p.join()"

#: ../../library/multiprocessing.rst:299
msgid ""
"The two connection objects returned by :func:`Pipe` represent the two ends "
"of the pipe.  Each connection object has :meth:`~Connection.send` and :meth:"
"`~Connection.recv` methods (among others).  Note that data in a pipe may "
"become corrupted if two processes (or threads) try to read from or write to "
"the *same* end of the pipe at the same time.  Of course there is no risk of "
"corruption from processes using different ends of the pipe at the same time."
msgstr ""
"De två anslutningsobjekt som returneras av :func:`Pipe` representerar rörets "
"två ändar.  Varje anslutningsobjekt har metoderna :meth:`~Connection.send` "
"och :meth:`~Connection.recv` (bland andra).  Observera att data i en pipe "
"kan bli korrumperade om två processer (eller trådar) försöker läsa från "
"eller skriva till *samma* ände av pipen samtidigt.  Naturligtvis finns det "
"ingen risk för korruption från processer som använder olika ändar av pipen "
"samtidigt."

#: ../../library/multiprocessing.rst:307
msgid ""
"The :meth:`~Connection.send` method serializes the object and :meth:"
"`~Connection.recv` re-creates the object."
msgstr ""
"Metoden :meth:`~Connection.send` serialiserar objektet och :meth:"
"`~Connection.recv` återskapar objektet."

#: ../../library/multiprocessing.rst:311
msgid "Synchronization between processes"
msgstr "Synkronisering mellan processer"

#: ../../library/multiprocessing.rst:313
msgid ""
":mod:`multiprocessing` contains equivalents of all the synchronization "
"primitives from :mod:`threading`.  For instance one can use a lock to ensure "
"that only one process prints to standard output at a time::"
msgstr ""
":mod:`multiprocessing` innehåller motsvarigheter till alla "
"synkroniseringsprimitiver från :mod:`threading`.  Till exempel kan man "
"använda ett lås för att säkerställa att endast en process skriver ut till "
"standardutdata åt gången::"

#: ../../library/multiprocessing.rst:317
msgid ""
"from multiprocessing import Process, Lock\n"
"\n"
"def f(l, i):\n"
"    l.acquire()\n"
"    try:\n"
"        print('hello world', i)\n"
"    finally:\n"
"        l.release()\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"\n"
"    for num in range(10):\n"
"        Process(target=f, args=(lock, num)).start()"
msgstr ""
"från multiprocessing import Process, Lås\n"
"\n"
"def f(l, i):\n"
"    l.acquire()\n"
"    försök:\n"
"        print('hello world', i)\n"
"    slutligen:\n"
"        l.release()\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"\n"
"    för num i intervall(10):\n"
"        Process(mål=f, args=(lock, num)).start()"

#: ../../library/multiprocessing.rst:332
msgid ""
"Without using the lock output from the different processes is liable to get "
"all mixed up."
msgstr ""
"Om man inte använder låset kan utdata från de olika processerna blandas ihop."

#: ../../library/multiprocessing.rst:337
msgid "Sharing state between processes"
msgstr "Delning av tillstånd mellan processer"

#: ../../library/multiprocessing.rst:339
msgid ""
"As mentioned above, when doing concurrent programming it is usually best to "
"avoid using shared state as far as possible.  This is particularly true when "
"using multiple processes."
msgstr ""
"Som nämnts ovan är det vid samtidig programmering oftast bäst att undvika "
"att använda delat tillstånd så långt det är möjligt.  Detta gäller särskilt "
"när man använder flera processer."

#: ../../library/multiprocessing.rst:343
msgid ""
"However, if you really do need to use some shared data then :mod:"
"`multiprocessing` provides a couple of ways of doing so."
msgstr ""
"Men om du verkligen behöver använda delade data finns det ett par sätt att "
"göra det på :mod:`multiprocessing`."

#: ../../library/multiprocessing.rst:346
msgid "**Shared memory**"
msgstr "**Gemensamt minne**"

#: ../../library/multiprocessing.rst:348
msgid ""
"Data can be stored in a shared memory map using :class:`Value` or :class:"
"`Array`.  For example, the following code ::"
msgstr ""
"Data kan lagras i en delad minneskarta med hjälp av :class:`Value` eller :"
"class:`Array`.  Till exempel följande kod ::"

#: ../../library/multiprocessing.rst:351
msgid ""
"from multiprocessing import Process, Value, Array\n"
"\n"
"def f(n, a):\n"
"    n.value = 3.1415927\n"
"    for i in range(len(a)):\n"
"        a[i] = -a[i]\n"
"\n"
"if __name__ == '__main__':\n"
"    num = Value('d', 0.0)\n"
"    arr = Array('i', range(10))\n"
"\n"
"    p = Process(target=f, args=(num, arr))\n"
"    p.start()\n"
"    p.join()\n"
"\n"
"    print(num.value)\n"
"    print(arr[:])"
msgstr ""
"från multiprocessing import Process, Värde, Array\n"
"\n"
"def f(n, a):\n"
"    n.värde = 3,1415927\n"
"    for i in range(len(a)):\n"
"        a[i] = -a[i]\n"
"\n"
"if __name__ == '__main__':\n"
"    num = Värde('d', 0.0)\n"
"    arr = Array('i', intervall(10))\n"
"\n"
"    p = Process(mål=f, args=(num, arr))\n"
"    p.start()\n"
"    p.join()\n"
"\n"
"    print(num.värde)\n"
"    print(arr[:])"

#: ../../library/multiprocessing.rst:369 ../../library/multiprocessing.rst:419
msgid "will print ::"
msgstr "kommer att skriva ut ::"

#: ../../library/multiprocessing.rst:371
msgid ""
"3.1415927\n"
"[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]"
msgstr ""
"3.1415927\n"
"[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]"

#: ../../library/multiprocessing.rst:374
msgid ""
"The ``'d'`` and ``'i'`` arguments used when creating ``num`` and ``arr`` are "
"typecodes of the kind used by the :mod:`array` module: ``'d'`` indicates a "
"double precision float and ``'i'`` indicates a signed integer.  These shared "
"objects will be process and thread-safe."
msgstr ""
"Argumenten ``'d'`` och ``'i'`` som används när ``num`` och ``arr`` skapas är "
"typkoder av den typ som används av modulen :mod:`array`: ``'d'`` anger en "
"flottör med dubbel precision och ``'i'`` anger ett signerat heltal.  Dessa "
"delade objekt kommer att vara process- och trådsäkra."

#: ../../library/multiprocessing.rst:379
msgid ""
"For more flexibility in using shared memory one can use the :mod:"
"`multiprocessing.sharedctypes` module which supports the creation of "
"arbitrary ctypes objects allocated from shared memory."
msgstr ""
"För mer flexibilitet vid användning av delat minne kan man använda modulen :"
"mod:`multiprocessing.sharedctypes` som stöder skapandet av godtyckliga "
"ctypes-objekt som allokeras från delat minne."

#: ../../library/multiprocessing.rst:383
msgid "**Server process**"
msgstr "**Serverprocess**"

#: ../../library/multiprocessing.rst:385
msgid ""
"A manager object returned by :func:`Manager` controls a server process which "
"holds Python objects and allows other processes to manipulate them using "
"proxies."
msgstr ""
"Ett manager-objekt som returneras av :func:`Manager` styr en serverprocess "
"som håller Python-objekt och tillåter andra processer att manipulera dem med "
"hjälp av proxies."

#: ../../library/multiprocessing.rst:389
msgid ""
"A manager returned by :func:`Manager` will support types :class:`list`, :"
"class:`dict`, :class:`set`, :class:`~managers.Namespace`, :class:`Lock`, :"
"class:`RLock`, :class:`Semaphore`, :class:`BoundedSemaphore`, :class:"
"`Condition`, :class:`Event`, :class:`Barrier`, :class:`Queue`, :class:"
"`Value` and :class:`Array`.  For example, ::"
msgstr ""
"En manager som returneras av :func:`Manager` kommer att stödja typerna :"
"class:`list`, :class:`dict`, :class:`set`, :class:`~managers.Namespace`, :"
"class:`Lock`, :class:`RLock`, :class:`Semaphore`, :class:"
"`BoundedSemaphore`, :class:`Condition`, :class:`Event`, :class:`Barrier`, :"
"class:`Queue`, :class:`Value` och :class:`Array`.  Till exempel ::"

#: ../../library/multiprocessing.rst:395
msgid ""
"from multiprocessing import Process, Manager\n"
"\n"
"def f(d, l, s):\n"
"    d[1] = '1'\n"
"    d['2'] = 2\n"
"    d[0.25] = None\n"
"    l.reverse()\n"
"    s.add('a')\n"
"    s.add('b')\n"
"\n"
"if __name__ == '__main__':\n"
"    with Manager() as manager:\n"
"        d = manager.dict()\n"
"        l = manager.list(range(10))\n"
"        s = manager.set()\n"
"\n"
"        p = Process(target=f, args=(d, l, s))\n"
"        p.start()\n"
"        p.join()\n"
"\n"
"        print(d)\n"
"        print(l)\n"
"        print(s)"
msgstr ""
"från multiprocessing import Process, Manager\n"
"\n"
"def f(d, l, s):\n"
"    d[1] = '1'\n"
"    d['2'] = 2\n"
"    d[0,25] = Ingen\n"
"    l.reverse()\n"
"    s.add('a')\n"
"    s.add('b')\n"
"\n"
"if __name__ == '__main__':\n"
"    med Manager() som manager:\n"
"        d = manager.dict()\n"
"        l = manager.list(intervall(10))\n"
"        s = manager.set()\n"
"\n"
"        p = Process(mål=f, args=(d, l, s))\n"
"        p.start()\n"
"        p.join()\n"
"\n"
"        print(d)\n"
"        print(l)\n"
"        skriv ut(s)"

#: ../../library/multiprocessing.rst:421
msgid ""
"{0.25: None, 1: '1', '2': 2}\n"
"[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n"
"{'a', 'b'}"
msgstr ""
"{0,25: Ingen, 1: '1', '2': 2}\n"
"[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n"
"{'a', 'b'}"

#: ../../library/multiprocessing.rst:425
msgid ""
"Server process managers are more flexible than using shared memory objects "
"because they can be made to support arbitrary object types.  Also, a single "
"manager can be shared by processes on different computers over a network. "
"They are, however, slower than using shared memory."
msgstr ""
"Serverprocesshanterare är mer flexibla än delade minnesobjekt eftersom de "
"kan göras så att de stöder godtyckliga objekttyper.  Dessutom kan en enda "
"hanterare delas av processer på olika datorer över ett nätverk. De är dock "
"långsammare än om man använder delat minne."

#: ../../library/multiprocessing.rst:432
msgid "Using a pool of workers"
msgstr "Använda en pool av arbetstagare"

#: ../../library/multiprocessing.rst:434
msgid ""
"The :class:`~multiprocessing.pool.Pool` class represents a pool of worker "
"processes.  It has methods which allows tasks to be offloaded to the worker "
"processes in a few different ways."
msgstr ""
"Klassen :class:`~multiprocessing.pool.Pool` representerar en pool av "
"arbetsprocesser.  Den har metoder som gör det möjligt att avlasta uppgifter "
"till arbetsprocesserna på några olika sätt."

#: ../../library/multiprocessing.rst:438
msgid "For example::"
msgstr "Till exempel::"

#: ../../library/multiprocessing.rst:440
msgid ""
"from multiprocessing import Pool, TimeoutError\n"
"import time\n"
"import os\n"
"\n"
"def f(x):\n"
"    return x*x\n"
"\n"
"if __name__ == '__main__':\n"
"    # start 4 worker processes\n"
"    with Pool(processes=4) as pool:\n"
"\n"
"        # print \"[0, 1, 4,..., 81]\"\n"
"        print(pool.map(f, range(10)))\n"
"\n"
"        # print same numbers in arbitrary order\n"
"        for i in pool.imap_unordered(f, range(10)):\n"
"            print(i)\n"
"\n"
"        # evaluate \"f(20)\" asynchronously\n"
"        res = pool.apply_async(f, (20,))      # runs in *only* one process\n"
"        print(res.get(timeout=1))             # prints \"400\"\n"
"\n"
"        # evaluate \"os.getpid()\" asynchronously\n"
"        res = pool.apply_async(os.getpid, ()) # runs in *only* one process\n"
"        print(res.get(timeout=1))             # prints the PID of that "
"process\n"
"\n"
"        # launching multiple evaluations asynchronously *may* use more "
"processes\n"
"        multiple_results = [pool.apply_async(os.getpid, ()) for i in "
"range(4)]\n"
"        print([res.get(timeout=1) for res in multiple_results])\n"
"\n"
"        # make a single worker sleep for 10 seconds\n"
"        res = pool.apply_async(time.sleep, (10,))\n"
"        try:\n"
"            print(res.get(timeout=1))\n"
"        except TimeoutError:\n"
"            print(\"We lacked patience and got a multiprocessing."
"TimeoutError\")\n"
"\n"
"        print(\"For the moment, the pool remains available for more work\")\n"
"\n"
"    # exiting the 'with'-block has stopped the pool\n"
"    print(\"Now the pool is closed and no longer available\")"
msgstr ""
"from multiprocessing import Pool, TimeoutError\n"
"importera tid\n"
"importera os\n"
"\n"
"def f(x):\n"
"    returnerar x*x\n"
"\n"
"if __name__ == '__main__':\n"
"    # starta 4 arbetsprocesser\n"
"    med Pool(processer=4) som pool:\n"
"\n"
"        # print \"[0, 1, 4,..., 81]\"\n"
"        print(pool.map(f, range(10))))\n"
"\n"
"        # skriva ut samma nummer i godtycklig ordning\n"
"        for i in pool.imap_unordered(f, range(10)):\n"
"            print(i)\n"
"\n"
"        # utvärdera \"f(20)\" asynkront\n"
"        res = pool.apply_async(f, (20,))      # körs i *endast* en process\n"
"        print(res.get(timeout=1))             # skriver ut \"400\"\n"
"\n"
"        # utvärdera \"os.getpid()\" asynkront\n"
"        res = pool.apply_async(os.getpid, ()) # körs i *enbart* en process\n"
"        print(res.get(timeout=1))             # skriver ut PID för den "
"processen\n"
"\n"
"        # att starta flera utvärderingar asynkront *kan* använda fler "
"processer\n"
"        multiple_results = [pool.apply_async(os.getpid, ()) for i in "
"range(4)]\n"
"        print([res.get(timeout=1) for res in multiple_results])\n"
"\n"
"        # låt en enda arbetare sova i 10 sekunder\n"
"        res = pool.apply_async(time.sleep, (10,))\n"
"        försök:\n"
"            print(res.get(timeout=1))\n"
"        except TimeoutError:\n"
"            print(\"Vi saknade tålamod och fick ett multiprocessing."
"TimeoutError\")\n"
"\n"
"        print(\"För tillfället är poolen fortfarande tillgänglig för mer "
"arbete\")\n"
"\n"
"    # när du lämnar 'with'-blocket har poolen stoppats\n"
"    print(\"Nu är poolen stängd och inte längre tillgänglig\")"

#: ../../library/multiprocessing.rst:482
msgid ""
"Note that the methods of a pool should only ever be used by the process "
"which created it."
msgstr ""
"Observera att metoderna i en pool endast ska användas av den process som "
"skapade den."

#: ../../library/multiprocessing.rst:487
msgid ""
"Functionality within this package requires that the ``__main__`` module be "
"importable by the children. This is covered in :ref:`multiprocessing-"
"programming` however it is worth pointing out here. This means that some "
"examples, such as the :class:`multiprocessing.pool.Pool` examples will not "
"work in the interactive interpreter. For example::"
msgstr ""
"Funktionalitet inom detta paket kräver att modulen ``__main__`` kan "
"importeras av underordnade program. Detta behandlas i :ref:`multiprocessing-"
"programming` men det är värt att påpeka här. Detta innebär att vissa "
"exempel, såsom :class:`multiprocessing.pool.Pool` exemplen inte kommer att "
"fungera i den interaktiva tolken. Till exempel::"

#: ../../library/multiprocessing.rst:493
msgid ""
">>> from multiprocessing import Pool\n"
">>> p = Pool(5)\n"
">>> def f(x):\n"
"...     return x*x\n"
"...\n"
">>> with p:\n"
"...     p.map(f, [1,2,3])\n"
"Process PoolWorker-1:\n"
"Process PoolWorker-2:\n"
"Process PoolWorker-3:\n"
"Traceback (most recent call last):\n"
"Traceback (most recent call last):\n"
"Traceback (most recent call last):\n"
"AttributeError: Can't get attribute 'f' on <module '__main__' (<class "
"'_frozen_importlib.BuiltinImporter'>)>\n"
"AttributeError: Can't get attribute 'f' on <module '__main__' (<class "
"'_frozen_importlib.BuiltinImporter'>)>\n"
"AttributeError: Can't get attribute 'f' on <module '__main__' (<class "
"'_frozen_importlib.BuiltinImporter'>)>"
msgstr ""
">>> from multiprocessing import Pool\n"
">>> p = Pool(5)\n"
">>> def f(x):\n"
"... returnera x*x\n"
"...\n"
">>> med p:\n"
"... p.map(f, [1,2,3])\n"
"Process PoolWorker-1:\n"
"Process PoolWorker-2:\n"
"Process PoolWorker-3:\n"
"Traceback (senaste anropet senast):\n"
"Traceback (senaste anropet senast):\n"
"Traceback (senaste anropet senast):\n"
"AttributeError: Kan inte hämta attributet 'f' på <modulen "
"'__main__' (<klassen '_frozen_importlib.BuiltinImporter'>)>\n"
"AttributFel: Kan inte få attributet 'f' på <modul '__main__' (<klass "
"'_frozen_importlib.BuiltinImporter'>)>\n"
"AttributFel: Kan inte hämta attributet 'f' på <modul '__main__' (<klass "
"'_frozen_importlib.BuiltinImporter'>)>"

#: ../../library/multiprocessing.rst:510
msgid ""
"(If you try this it will actually output three full tracebacks interleaved "
"in a semi-random fashion, and then you may have to stop the parent process "
"somehow.)"
msgstr ""
"(Om du försöker detta kommer det faktiskt att matas ut tre fullständiga "
"spårningar som är sammanflätade på ett halvt slumpmässigt sätt, och då "
"kanske du måste stoppa den överordnade processen på något sätt)"

#: ../../library/multiprocessing.rst:516
msgid "Reference"
msgstr "Referens"

#: ../../library/multiprocessing.rst:518
msgid ""
"The :mod:`multiprocessing` package mostly replicates the API of the :mod:"
"`threading` module."
msgstr ""
"Paketet :mod:`multiprocessing` replikerar till största delen API:et för "
"modulen :mod:`threading`."

#: ../../library/multiprocessing.rst:523
msgid ":class:`Process` and exceptions"
msgstr ":klass:`Process` och undantag"

#: ../../library/multiprocessing.rst:528
msgid ""
"Process objects represent activity that is run in a separate process. The :"
"class:`Process` class has equivalents of all the methods of :class:"
"`threading.Thread`."
msgstr ""
"Processobjekt representerar aktivitet som körs i en separat process. "
"Klassen :class:`Process` har motsvarigheter till alla metoder i :class:"
"`threading.Thread`."

#: ../../library/multiprocessing.rst:532
msgid ""
"The constructor should always be called with keyword arguments. *group* "
"should always be ``None``; it exists solely for compatibility with :class:"
"`threading.Thread`.  *target* is the callable object to be invoked by the :"
"meth:`run` method.  It defaults to ``None``, meaning nothing is called. "
"*name* is the process name (see :attr:`name` for more details). *args* is "
"the argument tuple for the target invocation.  *kwargs* is a dictionary of "
"keyword arguments for the target invocation.  If provided, the keyword-only "
"*daemon* argument sets the process :attr:`daemon` flag to ``True`` or "
"``False``.  If ``None`` (the default), this flag will be inherited from the "
"creating process."
msgstr ""
"Konstruktorn ska alltid anropas med nyckelordsargument. *group* bör alltid "
"vara ``None``; den existerar enbart för kompatibilitet med :class:`threading."
"Thread`.  *target* är det anropsbara objekt som skall anropas av :meth:`run`-"
"metoden.  Standardvärdet är ``None``, vilket betyder att ingenting anropas. "
"*name* är processnamnet (se :attr:`name` för mer information). *args* är "
"argumenttupeln för målinkallningen.  *kwargs* är en ordbok med "
"nyckelordsargument för målanropet.  Om det tillhandahålls sätter det enda "
"nyckelordsargumentet *daemon* processens flagga :attr:`daemon` till ``True`` "
"eller ``False``.  Om ``None`` (standard), kommer denna flagga att ärvas från "
"den skapande processen."

#: ../../library/multiprocessing.rst:543
msgid ""
"By default, no arguments are passed to *target*. The *args* argument, which "
"defaults to ``()``, can be used to specify a list or tuple of the arguments "
"to pass to *target*."
msgstr ""
"Som standard skickas inga argument till *target*. Argumentet *args*, som som "
"standard är ``()``, kan användas för att ange en lista eller tupel av de "
"argument som ska skickas till *target*."

#: ../../library/multiprocessing.rst:547
msgid ""
"If a subclass overrides the constructor, it must make sure it invokes the "
"base class constructor (``super().__init__()``) before doing anything else "
"to the process."
msgstr ""
"Om en subklass åsidosätter konstruktorn måste den se till att den anropar "
"basklassens konstruktor (``super().__init__()``) innan den gör något annat "
"med processen."

#: ../../library/multiprocessing.rst:553
msgid ""
"In general, all arguments to :class:`Process` must be picklable.  This is "
"frequently observed when trying to create a :class:`Process` or use a :class:"
"`concurrent.futures.ProcessPoolExecutor` from a REPL with a locally defined "
"*target* function."
msgstr ""
"I allmänhet måste alla argument till :class:`Process` vara plockbara.  Detta "
"observeras ofta när man försöker skapa en :class:`Process` eller använda en :"
"class:`concurrent.futures.ProcessPoolExecutor` från en REPL med en lokalt "
"definierad *target*-funktion."

#: ../../library/multiprocessing.rst:558
msgid ""
"Passing a callable object defined in the current REPL session causes the "
"child process to die via an uncaught :exc:`AttributeError` exception when "
"starting as *target* must have been defined within an importable module in "
"order to be loaded during unpickling."
msgstr ""
"Att skicka ett anropsbart objekt som definierats i den aktuella REPL-"
"sessionen gör att barnprocessen dör via ett icke fångat :exc:"
"`AttributeError`-undantag när den startas eftersom *target* måste ha "
"definierats i en importerbar modul för att kunna laddas under unpickling."

#: ../../library/multiprocessing.rst:563
msgid "Example of this uncatchable error from the child::"
msgstr "Exempel på detta oavhjälpliga fel från barnet::"

#: ../../library/multiprocessing.rst:565
msgid ""
">>> import multiprocessing as mp\n"
">>> def knigit():\n"
"...     print(\"Ni!\")\n"
"...\n"
">>> process = mp.Process(target=knigit)\n"
">>> process.start()\n"
">>> Traceback (most recent call last):\n"
"  File \".../multiprocessing/spawn.py\", line ..., in spawn_main\n"
"  File \".../multiprocessing/spawn.py\", line ..., in _main\n"
"AttributeError: module '__main__' has no attribute 'knigit'\n"
">>> process\n"
"<SpawnProcess name='SpawnProcess-1' pid=379473 parent=378707 stopped "
"exitcode=1>"
msgstr ""
">>> importera multiprocessing som mp\n"
">>> def knigit():\n"
"... print(\"Ni!\")\n"
"...\n"
">>> process = mp.process(mål=knigit)\n"
">>> process.start()\n"
">>> Traceback (senaste anropet senast):\n"
"  Fil \".../multiprocessing/spawn.py\", rad ..., i spawn_main\n"
"  Fil \".../multiprocessing/spawn.py\", rad ..., i _main\n"
"AttributeError: modulen '__main__' har inget attribut 'knigit'\n"
">>> process\n"
"<SpawnProcess name='SpawnProcess-1' pid=379473 parent=378707 stopped "
"exitcode=1>"

#: ../../library/multiprocessing.rst:578
msgid ""
"See :ref:`multiprocessing-programming-spawn`.  While this restriction is not "
"true if using the ``\"fork\"`` start method, as of Python ``3.14`` that is "
"no longer the default on any platform.  See :ref:`multiprocessing-start-"
"methods`. See also :gh:`132898`."
msgstr ""
"Se :ref:`multiprocessing-programming-spawn`.  Även om denna begränsning inte "
"är sann om man använder startmetoden ``\"fork\"``, så är den inte längre "
"standard på någon plattform från och med Python ``3.14``.  Se :ref:"
"``multiprocessing-start-methods``. Se även :gh:`132898`."

#: ../../library/multiprocessing.rst:584
msgid "Added the *daemon* parameter."
msgstr "Parametern *daemon* har lagts till."

#: ../../library/multiprocessing.rst:589
msgid "Method representing the process's activity."
msgstr "Metod som representerar processens aktivitet."

#: ../../library/multiprocessing.rst:591
msgid ""
"You may override this method in a subclass.  The standard :meth:`run` method "
"invokes the callable object passed to the object's constructor as the target "
"argument, if any, with sequential and keyword arguments taken from the "
"*args* and *kwargs* arguments, respectively."
msgstr ""
"Du kan åsidosätta denna metod i en subklass.  Standardmetoden :meth:`run` "
"anropar det anropsbara objekt som skickats till objektets konstruktör som "
"målargument, om något, med sekventiella argument och nyckelordsargument som "
"hämtas från argumenten *args* respektive *kwargs*."

#: ../../library/multiprocessing.rst:596
msgid ""
"Using a list or tuple as the *args* argument passed to :class:`Process` "
"achieves the same effect."
msgstr ""
"Samma effekt uppnås genom att använda en lista eller tupel som *args*-"
"argument i :class:`Process`."

#: ../../library/multiprocessing.rst:599
msgid "Example::"
msgstr "Exempel::"

#: ../../library/multiprocessing.rst:601
msgid ""
">>> from multiprocessing import Process\n"
">>> p = Process(target=print, args=[1])\n"
">>> p.run()\n"
"1\n"
">>> p = Process(target=print, args=(1,))\n"
">>> p.run()\n"
"1"
msgstr ""
">>> från multiprocessing import Process\n"
">>> p = Process(mål=utskrift, args=[1])\n"
">>> p.run()\n"
"1\n"
">>> p = Process(mål=utskrift, args=(1,))\n"
">>> p.run()\n"
"1"

#: ../../library/multiprocessing.rst:611
msgid "Start the process's activity."
msgstr "Starta processens aktivitet."

#: ../../library/multiprocessing.rst:613
msgid ""
"This must be called at most once per process object.  It arranges for the "
"object's :meth:`run` method to be invoked in a separate process."
msgstr ""
"Detta måste anropas högst en gång per processobjekt.  Det ordnar så att "
"objektets :meth:`run`-metod anropas i en separat process."

#: ../../library/multiprocessing.rst:618
msgid ""
"If the optional argument *timeout* is ``None`` (the default), the method "
"blocks until the process whose :meth:`join` method is called terminates. If "
"*timeout* is a positive number, it blocks at most *timeout* seconds. Note "
"that the method returns ``None`` if its process terminates or if the method "
"times out.  Check the process's :attr:`exitcode` to determine if it "
"terminated."
msgstr ""
"Om det valfria argumentet *timeout* är ``None`` (standard) blockeras metoden "
"tills den process vars :meth:`join`-metod anropas avslutas. Om *timeout* är "
"ett positivt tal blockeras den i högst *timeout* sekunder. Observera att "
"metoden returnerar ``None`` om dess process avslutas eller om metoden "
"tidsbegränsas.  Kontrollera processens :attr:`exitcode` för att avgöra om "
"den avslutades."

#: ../../library/multiprocessing.rst:625
msgid "A process can be joined many times."
msgstr "En process kan anslutas flera gånger."

#: ../../library/multiprocessing.rst:627
msgid ""
"A process cannot join itself because this would cause a deadlock.  It is an "
"error to attempt to join a process before it has been started."
msgstr ""
"En process kan inte ansluta sig till sig själv eftersom detta skulle orsaka "
"ett dödläge.  Det är ett fel att försöka ansluta sig till en process innan "
"den har startats."

#: ../../library/multiprocessing.rst:632
msgid ""
"The process's name.  The name is a string used for identification purposes "
"only.  It has no semantics.  Multiple processes may be given the same name."
msgstr ""
"Processens namn.  Namnet är en sträng som endast används i "
"identifieringssyfte.  Det har ingen semantik.  Flera processer kan ges samma "
"namn."

#: ../../library/multiprocessing.rst:636
msgid ""
"The initial name is set by the constructor.  If no explicit name is provided "
"to the constructor, a name of the form 'Process-N\\ :sub:`1`:N\\ :sub:"
"`2`:...:N\\ :sub:`k`' is constructed, where each N\\ :sub:`k` is the N-th "
"child of its parent."
msgstr ""
"Det initiala namnet sätts av konstruktören.  Om inget explicit namn anges "
"till konstruktören, konstrueras ett namn av formen \"Process-N\\ :sub:`1`:"
"N\\ :sub:`2`:...:N\\ :sub:`k`\", där varje N\\ :sub:`k` är det N:te barnet "
"till sin förälder."

#: ../../library/multiprocessing.rst:643
msgid "Return whether the process is alive."
msgstr "Returnerar om processen är vid liv."

#: ../../library/multiprocessing.rst:645
msgid ""
"Roughly, a process object is alive from the moment the :meth:`start` method "
"returns until the child process terminates."
msgstr ""
"Ett processobjekt är i princip vid liv från det ögonblick då metoden :meth:"
"`start` returneras till dess att barnprocessen avslutas."

#: ../../library/multiprocessing.rst:650
msgid ""
"The process's daemon flag, a Boolean value.  This must be set before :meth:"
"`start` is called."
msgstr ""
"Processens daemonflagga, ett booleanskt värde.  Detta måste anges innan :"
"meth:`start` anropas."

#: ../../library/multiprocessing.rst:653
msgid "The initial value is inherited from the creating process."
msgstr "Det initiala värdet ärvs från skapandeprocessen."

#: ../../library/multiprocessing.rst:655
msgid ""
"When a process exits, it attempts to terminate all of its daemonic child "
"processes."
msgstr ""
"När en process avslutas försöker den avsluta alla sina daemoniska "
"underordnade processer."

#: ../../library/multiprocessing.rst:658
msgid ""
"Note that a daemonic process is not allowed to create child processes. "
"Otherwise a daemonic process would leave its children orphaned if it gets "
"terminated when its parent process exits. Additionally, these are **not** "
"Unix daemons or services, they are normal processes that will be terminated "
"(and not joined) if non-daemonic processes have exited."
msgstr ""
"Observera att en daemonisk process inte får skapa underordnade processer. I "
"annat fall skulle en daemonisk process lämna sina barn föräldralösa om den "
"avslutas när dess föräldraprocess avslutas. Dessutom är detta **inte** Unix "
"daemons eller tjänster, det är normala processer som kommer att avslutas "
"(och inte anslutas) om icke-daemoniska processer har avslutats."

#: ../../library/multiprocessing.rst:664
msgid ""
"In addition to the  :class:`threading.Thread` API, :class:`Process` objects "
"also support the following attributes and methods:"
msgstr ""
"Förutom API:et :class:`threading.Thread` stöder :class:`Process`-objekten "
"även följande attribut och metoder:"

#: ../../library/multiprocessing.rst:669
msgid ""
"Return the process ID.  Before the process is spawned, this will be ``None``."
msgstr ""
"Returnerar processens ID.  Innan processen startas kommer detta att vara "
"``None``."

#: ../../library/multiprocessing.rst:674
msgid ""
"The child's exit code.  This will be ``None`` if the process has not yet "
"terminated."
msgstr ""
"Barnets utgångskod.  Denna kommer att vara ``None`` om processen ännu inte "
"har avslutats."

#: ../../library/multiprocessing.rst:677
msgid ""
"If the child's :meth:`run` method returned normally, the exit code will be "
"0.  If it terminated via :func:`sys.exit` with an integer argument *N*, the "
"exit code will be *N*."
msgstr ""
"Om barnets :meth:`run`-metod returnerades normalt blir utgångskoden 0. Om "
"den avslutades via :func:`sys.exit` med ett heltalsargument *N* blir "
"utgångskoden *N*."

#: ../../library/multiprocessing.rst:681
msgid ""
"If the child terminated due to an exception not caught within :meth:`run`, "
"the exit code will be 1.  If it was terminated by signal *N*, the exit code "
"will be the negative value *-N*."
msgstr ""
"Om barnet avslutades på grund av ett undantag som inte fångades upp inom :"
"meth:`run`, kommer utgångskoden att vara 1.  Om det avslutades av signalen "
"*N* kommer utgångskoden att vara det negativa värdet *-N*."

#: ../../library/multiprocessing.rst:687
msgid "The process's authentication key (a byte string)."
msgstr "Processens autentiseringsnyckel (en byte-sträng)."

#: ../../library/multiprocessing.rst:689
msgid ""
"When :mod:`multiprocessing` is initialized the main process is assigned a "
"random string using :func:`os.urandom`."
msgstr ""
"När :mod:`multiprocessing` initieras tilldelas huvudprocessen en slumpmässig "
"sträng med hjälp av :func:`os.urandom`."

#: ../../library/multiprocessing.rst:692
msgid ""
"When a :class:`Process` object is created, it will inherit the "
"authentication key of its parent process, although this may be changed by "
"setting :attr:`authkey` to another byte string."
msgstr ""
"När ett :class:`Process`-objekt skapas kommer det att ärva "
"autentiseringsnyckeln för sin överordnade process, även om detta kan ändras "
"genom att ange :attr:`authkey` till en annan byte-sträng."

#: ../../library/multiprocessing.rst:696
msgid "See :ref:`multiprocessing-auth-keys`."
msgstr "Se :ref:`multiprocessing-auth-keys`."

#: ../../library/multiprocessing.rst:700
msgid ""
"A numeric handle of a system object which will become \"ready\" when the "
"process ends."
msgstr ""
"Ett numeriskt handtag för ett systemobjekt som kommer att bli \"klart\" när "
"processen avslutas."

#: ../../library/multiprocessing.rst:703
msgid ""
"You can use this value if you want to wait on several events at once using :"
"func:`multiprocessing.connection.wait`.  Otherwise calling :meth:`join` is "
"simpler."
msgstr ""
"Du kan använda det här värdet om du vill vänta på flera händelser samtidigt "
"med hjälp av :func:`multiprocessing.connection.wait`.  Annars är det enklare "
"att anropa :meth:`join`."

#: ../../library/multiprocessing.rst:707
msgid ""
"On Windows, this is an OS handle usable with the ``WaitForSingleObject`` and "
"``WaitForMultipleObjects`` family of API calls.  On POSIX, this is a file "
"descriptor usable with primitives from the :mod:`select` module."
msgstr ""
"I Windows är detta ett OS-handtag som kan användas med API-anropen "
"``WaitForSingleObject`` och ``WaitForMultipleObjects``.  På POSIX är detta "
"en filbeskrivare som kan användas med primitiver från modulen :mod:`select`."

#: ../../library/multiprocessing.rst:715
msgid ""
"Terminate the process. Works on POSIX using the :py:const:`~signal.SIGINT` "
"signal. Behavior on Windows is undefined."
msgstr ""
"Avslutar processen. Fungerar på POSIX med hjälp av signalen :py:const:"
"`~signal.SIGINT`. Beteendet på Windows är odefinierat."

#: ../../library/multiprocessing.rst:718
msgid ""
"By default, this terminates the child process by raising :exc:"
"`KeyboardInterrupt`. This behavior can be altered by setting the respective "
"signal handler in the child process :func:`signal.signal` for :py:const:"
"`~signal.SIGINT`."
msgstr ""
"Som standard avslutas den underordnade processen genom att :exc:"
"`KeyboardInterrupt` aktiveras. Detta beteende kan ändras genom att ställa in "
"respektive signalhanterare i barnprocessen :func:`signal.signal` för :py:"
"const:`~signal.SIGINT`."

#: ../../library/multiprocessing.rst:722
msgid ""
"Note: if the child process catches and discards :exc:`KeyboardInterrupt`, "
"the process will not be terminated."
msgstr ""
"Obs: om barnprocessen fångar upp och kastar :exc:`KeyboardInterrupt`, kommer "
"processen inte att avslutas."

#: ../../library/multiprocessing.rst:725
msgid ""
"Note: the default behavior will also set :attr:`exitcode` to ``1`` as if an "
"uncaught exception was raised in the child process. To have a different :"
"attr:`exitcode` you may simply catch :exc:`KeyboardInterrupt` and call "
"``exit(your_code)``."
msgstr ""
"Notera: standardbeteendet kommer också att sätta :attr:`exitcode` till ``1`` "
"som om ett undantag utan åtgärd har uppstått i barnprocessen. För att ha en "
"annan :attr:`exitcode` kan du helt enkelt fånga :exc:`KeyboardInterrupt` och "
"anropa ``exit(your_code)``."

#: ../../library/multiprocessing.rst:734
msgid ""
"Terminate the process.  On POSIX this is done using the :py:const:`~signal."
"SIGTERM` signal; on Windows :c:func:`!TerminateProcess` is used.  Note that "
"exit handlers and finally clauses, etc., will not be executed."
msgstr ""
"Avsluta processen.  På POSIX görs detta med hjälp av signalen :py:const:"
"`~signal.SIGTERM`; på Windows används :c:func:`!TerminateProcess`.  "
"Observera att exit-handlers och finally-klausuler etc. inte kommer att "
"exekveras."

#: ../../library/multiprocessing.rst:738
msgid ""
"Note that descendant processes of the process will *not* be terminated -- "
"they will simply become orphaned."
msgstr ""
"Observera att processer som härstammar från processen *inte* kommer att "
"avslutas - de kommer helt enkelt att bli föräldralösa."

#: ../../library/multiprocessing.rst:743
msgid ""
"If this method is used when the associated process is using a pipe or queue "
"then the pipe or queue is liable to become corrupted and may become unusable "
"by other process.  Similarly, if the process has acquired a lock or "
"semaphore etc. then terminating it is liable to cause other processes to "
"deadlock."
msgstr ""
"Om denna metod används när den associerade processen använder en pipe eller "
"en kö, kan pipen eller kön bli skadad och bli oanvändbar för andra "
"processer.  På samma sätt, om processen har förvärvat ett lås eller en "
"semafor etc., kan avslutningen av den leda till att andra processer fastnar."

#: ../../library/multiprocessing.rst:751
msgid "Same as :meth:`terminate` but using the ``SIGKILL`` signal on POSIX."
msgstr ""
"Samma som :meth:`terminate` men använder signalen ``SIGKILL`` på POSIX."

#: ../../library/multiprocessing.rst:757
msgid ""
"Close the :class:`Process` object, releasing all resources associated with "
"it.  :exc:`ValueError` is raised if the underlying process is still "
"running.  Once :meth:`close` returns successfully, most other methods and "
"attributes of the :class:`Process` object will raise :exc:`ValueError`."
msgstr ""
"Stänger :class:`Process`-objektet och frigör alla resurser som är "
"associerade med det. :exc:`ValueError` visas om den underliggande processen "
"fortfarande körs.  När :meth:`close` har returnerats framgångsrikt kommer de "
"flesta andra metoder och attribut för :class:`Process`-objektet att ge "
"upphov till :exc:`ValueError`."

#: ../../library/multiprocessing.rst:765
msgid ""
"Note that the :meth:`start`, :meth:`join`, :meth:`is_alive`, :meth:"
"`terminate` and :attr:`exitcode` methods should only be called by the "
"process that created the process object."
msgstr ""
"Observera att metoderna :meth:`start`, :meth:`join`, :meth:`is_alive`, :meth:"
"`terminate` och :attr:`exitcode` endast ska anropas av den process som "
"skapade processobjektet."

#: ../../library/multiprocessing.rst:769
msgid "Example usage of some of the methods of :class:`Process`:"
msgstr "Exempel på användning av några av metoderna i :class:`Process`:"

#: ../../library/multiprocessing.rst:771
msgid ""
">>> import multiprocessing, time, signal\n"
">>> mp_context = multiprocessing.get_context('spawn')\n"
">>> p = mp_context.Process(target=time.sleep, args=(1000,))\n"
">>> print(p, p.is_alive())\n"
"<...Process ... initial> False\n"
">>> p.start()\n"
">>> print(p, p.is_alive())\n"
"<...Process ... started> True\n"
">>> p.terminate()\n"
">>> time.sleep(0.1)\n"
">>> print(p, p.is_alive())\n"
"<...Process ... stopped exitcode=-SIGTERM> False\n"
">>> p.exitcode == -signal.SIGTERM\n"
"True"
msgstr ""
">>> import multiprocessing, tid, signal\n"
">>> mp_context = multiprocessing.get_context('spawn')\n"
">>> p = mp_context.process(mål=time.sleep, args=(1000,))\n"
">>> print(p, p.is_alive())\n"
"<...Process ... initial> Falsk\n"
">>> p.start()\n"
">>> print(p, p.is_alive())\n"
"<...Processen ... startad> Sant\n"
">>> p.terminate()\n"
">>> tid.sömn(0.1)\n"
">>> print(p, p.is_alive())\n"
"<...Process ... stoppad exitcode=-SIGTERM> Falsk\n"
">>> p.exitcode == -signal.SIGTERM\n"
"Sant"

#: ../../library/multiprocessing.rst:790
msgid "The base class of all :mod:`multiprocessing` exceptions."
msgstr "Basklassen för alla :mod:`multiprocessing`-undantag."

#: ../../library/multiprocessing.rst:794
msgid ""
"Exception raised by :meth:`Connection.recv_bytes_into` when the supplied "
"buffer object is too small for the message read."
msgstr ""
"Exception orsakad av :meth:`Connection.recv_bytes_into` när det medföljande "
"buffertobjektet är för litet för det lästa meddelandet."

#: ../../library/multiprocessing.rst:797
msgid ""
"If ``e`` is an instance of :exc:`BufferTooShort` then ``e.args[0]`` will "
"give the message as a byte string."
msgstr ""
"Om ``e`` är en instans av :exc:`BufferTooShort` så kommer ``e.args[0]``` att "
"ge meddelandet som en byte-sträng."

#: ../../library/multiprocessing.rst:802
msgid "Raised when there is an authentication error."
msgstr "Uppstår när det finns ett autentiseringsfel."

#: ../../library/multiprocessing.rst:806
msgid "Raised by methods with a timeout when the timeout expires."
msgstr "Utlöses av metoder med en timeout när timeouten löper ut."

#: ../../library/multiprocessing.rst:809
msgid "Pipes and Queues"
msgstr "Pipes och köer"

#: ../../library/multiprocessing.rst:811
msgid ""
"When using multiple processes, one generally uses message passing for "
"communication between processes and avoids having to use any synchronization "
"primitives like locks."
msgstr ""
"När man använder flera processer använder man i allmänhet meddelandepassning "
"för kommunikation mellan processerna och undviker att behöva använda "
"synkroniseringsprimitiver som lås."

#: ../../library/multiprocessing.rst:815
msgid ""
"For passing messages one can use :func:`Pipe` (for a connection between two "
"processes) or a queue (which allows multiple producers and consumers)."
msgstr ""
"För att skicka meddelanden kan man använda :func:`Pipe` (för en anslutning "
"mellan två processer) eller en kö (som tillåter flera producenter och "
"konsumenter)."

#: ../../library/multiprocessing.rst:818
msgid ""
"The :class:`Queue`, :class:`SimpleQueue` and :class:`JoinableQueue` types "
"are multi-producer, multi-consumer :abbr:`FIFO (first-in, first-out)` queues "
"modelled on the :class:`queue.Queue` class in the standard library.  They "
"differ in that :class:`Queue` lacks the :meth:`~queue.Queue.task_done` and :"
"meth:`~queue.Queue.join` methods introduced into Python 2.5's :class:`queue."
"Queue` class."
msgstr ""
"Typerna :class:`Queue`, :class:`SimpleQueue` och :class:`JoinableQueue` är "
"köer med flera producenter och flera konsumenter :abbr:`FIFO (först in, "
"först ut)` som är modellerade efter klassen :class:`queue.Queue` i "
"standardbiblioteket.  De skiljer sig åt genom att :class:`Queue` saknar "
"metoderna :meth:`~queue.Queue.task_done` och :meth:`~queue.Queue.join` som "
"introducerades i Python 2.5:s klass :class:`queue.Queue`."

#: ../../library/multiprocessing.rst:825
msgid ""
"If you use :class:`JoinableQueue` then you **must** call :meth:"
"`JoinableQueue.task_done` for each task removed from the queue or else the "
"semaphore used to count the number of unfinished tasks may eventually "
"overflow, raising an exception."
msgstr ""
"Om du använder :class:`JoinableQueue` så **måste** du anropa :meth:"
"`JoinableQueue.task_done` för varje uppgift som tas bort från kön, annars "
"kan semaforen som används för att räkna antalet oavslutade uppgifter så "
"småningom svämma över och orsaka ett undantag."

#: ../../library/multiprocessing.rst:830
msgid ""
"One difference from other Python queue implementations, is that :mod:"
"`multiprocessing` queues serializes all objects that are put into them "
"using :mod:`pickle`. The object return by the get method is a re-created "
"object that does not share memory with the original object."
msgstr ""
"En skillnad från andra köimplementationer i Python är att :mod:"
"`multiprocessing`-köer serialiserar alla objekt som läggs in i dem med :mod:"
"`pickle`. Objektet som returneras av get-metoden är ett återskapat objekt "
"som inte delar minne med det ursprungliga objektet."

#: ../../library/multiprocessing.rst:835
msgid ""
"Note that one can also create a shared queue by using a manager object -- "
"see :ref:`multiprocessing-managers`."
msgstr ""
"Observera att man också kan skapa en delad kö genom att använda ett manager-"
"objekt -- se :ref:`multiprocessing-managers`."

#: ../../library/multiprocessing.rst:840
msgid ""
":mod:`multiprocessing` uses the usual :exc:`queue.Empty` and :exc:`queue."
"Full` exceptions to signal a timeout.  They are not available in the :mod:"
"`multiprocessing` namespace so you need to import them from :mod:`queue`."
msgstr ""
":mod:`multiprocessing` använder de vanliga undantagen :exc:`queue.Empty` "
"och :exc:`queue.Full` för att signalera en timeout.  De är inte tillgängliga "
"i namnrymden :mod:`multiprocessing` så du måste importera dem från :mod:"
"`queue`."

#: ../../library/multiprocessing.rst:847
msgid ""
"When an object is put on a queue, the object is pickled and a background "
"thread later flushes the pickled data to an underlying pipe.  This has some "
"consequences which are a little surprising, but should not cause any "
"practical difficulties -- if they really bother you then you can instead use "
"a queue created with a :ref:`manager <multiprocessing-managers>`."
msgstr ""
"När ett objekt sätts i en kö picklas objektet och en bakgrundstråd spolar "
"senare ut den picklade datan till en underliggande pipe.  Detta har några "
"konsekvenser som är lite överraskande, men bör inte orsaka några praktiska "
"problem - om de verkligen stör dig kan du istället använda en kö som skapats "
"med en :ref:`manager <multiprocessing-managers>`."

#: ../../library/multiprocessing.rst:854
msgid ""
"After putting an object on an empty queue there may be an infinitesimal "
"delay before the queue's :meth:`~Queue.empty` method returns :const:`False` "
"and :meth:`~Queue.get_nowait` can return without raising :exc:`queue.Empty`."
msgstr ""
"Efter att ha lagt ett objekt på en tom kö kan det bli en oändligt liten "
"fördröjning innan köns metod :meth:`~Queue.empty` returnerar :const:`False` "
"och :meth:`~Queue.get_nowait` kan returnera utan att ge upphov till :exc:"
"`queue.Empty`."

#: ../../library/multiprocessing.rst:859
msgid ""
"If multiple processes are enqueuing objects, it is possible for the objects "
"to be received at the other end out-of-order. However, objects enqueued by "
"the same process will always be in the expected order with respect to each "
"other."
msgstr ""
"Om flera processer ställer objekt i kö är det möjligt att objekten tas emot "
"i den andra änden i fel ordning. Objekt som köas av samma process kommer "
"dock alltid att vara i den förväntade ordningen i förhållande till varandra."

#: ../../library/multiprocessing.rst:866
msgid ""
"If a process is killed using :meth:`Process.terminate` or :func:`os.kill` "
"while it is trying to use a :class:`Queue`, then the data in the queue is "
"likely to become corrupted.  This may cause any other process to get an "
"exception when it tries to use the queue later on."
msgstr ""
"Om en process dödas med :meth:`Process.terminate` eller :func:`os.kill` "
"medan den försöker använda en :class:`Queue`, är det troligt att data i kön "
"blir skadade.  Detta kan leda till att en annan process får ett undantag när "
"den försöker använda kön senare."

#: ../../library/multiprocessing.rst:873
msgid ""
"As mentioned above, if a child process has put items on a queue (and it has "
"not used :meth:`JoinableQueue.cancel_join_thread <multiprocessing.Queue."
"cancel_join_thread>`), then that process will not terminate until all "
"buffered items have been flushed to the pipe."
msgstr ""
"Som nämnts ovan, om en underordnad process har lagt objekt i en kö (och inte "
"har använt :meth:`JoinableQueue.cancel_join_thread <multiprocessing.Queue."
"cancel_join_thread>`), kommer den processen inte att avslutas förrän alla "
"buffrade objekt har spolats till pipen."

#: ../../library/multiprocessing.rst:878
msgid ""
"This means that if you try joining that process you may get a deadlock "
"unless you are sure that all items which have been put on the queue have "
"been consumed.  Similarly, if the child process is non-daemonic then the "
"parent process may hang on exit when it tries to join all its non-daemonic "
"children."
msgstr ""
"Det innebär att om du försöker ansluta dig till den processen kan du få ett "
"dödläge om du inte är säker på att alla objekt som har ställts i kö har "
"förbrukats.  På samma sätt, om barnprocessen är icke-daemonisk, kan "
"föräldraprocessen hänga sig vid utgången när den försöker ansluta sig till "
"alla sina icke-daemoniska barn."

#: ../../library/multiprocessing.rst:883
msgid ""
"Note that a queue created using a manager does not have this issue.  See :"
"ref:`multiprocessing-programming`."
msgstr ""
"Observera att en kö som skapats med hjälp av en manager inte har detta "
"problem.  Se :ref:`multiprocessing-programming`."

#: ../../library/multiprocessing.rst:886
msgid ""
"For an example of the usage of queues for interprocess communication see :"
"ref:`multiprocessing-examples`."
msgstr ""
"För ett exempel på användning av köer för kommunikation mellan processer, "
"se :ref:`multiprocessing-examples`."

#: ../../library/multiprocessing.rst:892
msgid ""
"Returns a pair ``(conn1, conn2)`` of :class:`~multiprocessing.connection."
"Connection` objects representing the ends of a pipe."
msgstr ""
"Returnerar ett par ``(conn1, conn2)`` av :class:`~multiprocessing.connection."
"Connection`-objekt som representerar ändarna av ett rör."

#: ../../library/multiprocessing.rst:896
msgid ""
"If *duplex* is ``True`` (the default) then the pipe is bidirectional.  If "
"*duplex* is ``False`` then the pipe is unidirectional: ``conn1`` can only be "
"used for receiving messages and ``conn2`` can only be used for sending "
"messages."
msgstr ""
"Om *duplex* är ``True`` (standard) är röret dubbelriktat.  Om *duplex* är "
"``False`` är pipen enkelriktad: ``conn1`` kan bara användas för att ta emot "
"meddelanden och ``conn2`` kan bara användas för att skicka meddelanden."

#: ../../library/multiprocessing.rst:901
msgid ""
"The :meth:`~multiprocessing.Connection.send` method serializes the object "
"using :mod:`pickle` and the :meth:`~multiprocessing.Connection.recv` re-"
"creates the object."
msgstr ""
"Metoden :meth:`~multiprocessing.Connection.send` serialiserar objektet med "
"hjälp av :mod:`pickle` och metoden :meth:`~multiprocessing.Connection.recv` "
"återskapar objektet."

#: ../../library/multiprocessing.rst:906
msgid ""
"Returns a process shared queue implemented using a pipe and a few locks/"
"semaphores.  When a process first puts an item on the queue a feeder thread "
"is started which transfers objects from a buffer into the pipe."
msgstr ""
"Returnerar en processdelad kö som implementerats med hjälp av en pipe och "
"några lås/semaphores.  När en process först lägger ett objekt i kön startas "
"en matartråd som överför objekt från en buffert till pipen."

#: ../../library/multiprocessing.rst:910
msgid ""
"The usual :exc:`queue.Empty` and :exc:`queue.Full` exceptions from the "
"standard library's :mod:`queue` module are raised to signal timeouts."
msgstr ""
"De vanliga undantagen :exc:`queue.Empty` och :exc:`queue.Full` från "
"standardbibliotekets modul :mod:`queue` används för att signalera "
"tidsavbrott."

#: ../../library/multiprocessing.rst:913
msgid ""
":class:`Queue` implements all the methods of :class:`queue.Queue` except "
"for :meth:`~queue.Queue.task_done` and :meth:`~queue.Queue.join`."
msgstr ""
":class:`Queue` implementerar alla metoder i :class:`queue.Queue` utom :meth:"
"`~queue.Queue.task_done` och :meth:`~queue.Queue.join`."

#: ../../library/multiprocessing.rst:918
msgid ""
"Return the approximate size of the queue.  Because of multithreading/"
"multiprocessing semantics, this number is not reliable."
msgstr ""
"Returnerar den ungefärliga storleken på kön.  På grund av semantiken för "
"multithreading/multiprocessing är detta tal inte tillförlitligt."

#: ../../library/multiprocessing.rst:921
msgid ""
"Note that this may raise :exc:`NotImplementedError` on platforms like macOS "
"where ``sem_getvalue()`` is not implemented."
msgstr ""
"Observera att detta kan ge upphov till :exc:`NotImplementedError` på "
"plattformar som macOS där ``sem_getvalue()`` inte är implementerad."

#: ../../library/multiprocessing.rst:926
msgid ""
"Return ``True`` if the queue is empty, ``False`` otherwise.  Because of "
"multithreading/multiprocessing semantics, this is not reliable."
msgstr ""
"Returnerar ``True`` om kön är tom, annars ``False``.  På grund av semantiken "
"för multithreading/multiprocessing är detta inte tillförlitligt."

#: ../../library/multiprocessing.rst:929
msgid "May raise an :exc:`OSError` on closed queues. (not guaranteed)"
msgstr ""
"Kan ge upphov till ett :exc:`OSError` på stängda köer. (inte garanterat)"

#: ../../library/multiprocessing.rst:933
msgid ""
"Return ``True`` if the queue is full, ``False`` otherwise.  Because of "
"multithreading/multiprocessing semantics, this is not reliable."
msgstr ""
"Returnerar ``True`` om kön är full, annars ``False``.  På grund av "
"semantiken för multithreading/multiprocessing är detta inte tillförlitligt."

#: ../../library/multiprocessing.rst:938
msgid ""
"Put obj into the queue.  If the optional argument *block* is ``True`` (the "
"default) and *timeout* is ``None`` (the default), block if necessary until a "
"free slot is available.  If *timeout* is a positive number, it blocks at "
"most *timeout* seconds and raises the :exc:`queue.Full` exception if no free "
"slot was available within that time.  Otherwise (*block* is ``False``), put "
"an item on the queue if a free slot is immediately available, else raise "
"the :exc:`queue.Full` exception (*timeout* is ignored in that case)."
msgstr ""
"Placerar obj i kön.  Om det valfria argumentet *block* är ``True`` "
"(standard) och *timeout* är ``None`` (standard), blockeras vid behov tills "
"en ledig plats finns tillgänglig.  Om *timeout* är ett positivt tal "
"blockerar den i högst *timeout* sekunder och ger upphov till :exc:`queue."
"Full`-undantaget om ingen ledig plats fanns tillgänglig inom den tiden.  I "
"annat fall (*block* är ``False``), lägg till ett objekt i kön om en ledig "
"plats omedelbart finns tillgänglig, annars utlöses undantaget :exc:`queue."
"Full` (*timeout* ignoreras i det fallet)."

#: ../../library/multiprocessing.rst:947
msgid ""
"If the queue is closed, :exc:`ValueError` is raised instead of :exc:"
"`AssertionError`."
msgstr ""
"Om kön är stängd kommer :exc:`ValueError` att uppstå istället för :exc:"
"`AssertionError`."

#: ../../library/multiprocessing.rst:953
msgid "Equivalent to ``put(obj, False)``."
msgstr "Motsvarar ``put(obj, False)``."

#: ../../library/multiprocessing.rst:957
msgid ""
"Remove and return an item from the queue.  If optional args *block* is "
"``True`` (the default) and *timeout* is ``None`` (the default), block if "
"necessary until an item is available.  If *timeout* is a positive number, it "
"blocks at most *timeout* seconds and raises the :exc:`queue.Empty` exception "
"if no item was available within that time.  Otherwise (block is ``False``), "
"return an item if one is immediately available, else raise the :exc:`queue."
"Empty` exception (*timeout* is ignored in that case)."
msgstr ""
"Tar bort och returnerar ett objekt från kön.  Om de valfria argen *block* är "
"``True`` (standard) och *timeout* är ``None`` (standard), blockeras vid "
"behov tills ett objekt är tillgängligt.  Om *timeout* är ett positivt tal "
"blockerar den högst *timeout* sekunder och ger upphov till :exc:`queue."
"Empty`-undantaget om inget objekt var tillgängligt inom den tiden.  I annat "
"fall (block är ``False``) returneras ett objekt om det finns ett omedelbart "
"tillgängligt, annars uppstår undantaget :exc:`queue.Empty` (*timeout* "
"ignoreras i det fallet)."

#: ../../library/multiprocessing.rst:965
msgid ""
"If the queue is closed, :exc:`ValueError` is raised instead of :exc:"
"`OSError`."
msgstr ""
"Om kön är stängd, genereras :exc:`ValueError` istället för :exc:`OSError`."

#: ../../library/multiprocessing.rst:971
msgid "Equivalent to ``get(False)``."
msgstr "Motsvarar ``get(False)``."

#: ../../library/multiprocessing.rst:973
msgid ""
":class:`multiprocessing.Queue` has a few additional methods not found in :"
"class:`queue.Queue`.  These methods are usually unnecessary for most code:"
msgstr ""
":class:`multiprocessing.Queue` har några ytterligare metoder som inte finns "
"i :class:`queue.Queue`.  Dessa metoder är vanligtvis onödiga för de flesta "
"koder:"

#: ../../library/multiprocessing.rst:979 ../../library/multiprocessing.rst:1027
msgid "Close the queue: release internal resources."
msgstr "Stäng kön: frigör interna resurser."

#: ../../library/multiprocessing.rst:981
msgid ""
"A queue must not be used anymore after it is closed. For example, :meth:"
"`~Queue.get`, :meth:`~Queue.put` and :meth:`~Queue.empty` methods must no "
"longer be called."
msgstr ""
"En kö får inte längre användas efter att den har stängts. Exempelvis får "
"metoderna :meth:`~Queue.get`, :meth:`~Queue.put` och :meth:`~Queue.empty` "
"inte längre anropas."

#: ../../library/multiprocessing.rst:985
msgid ""
"The background thread will quit once it has flushed all buffered data to the "
"pipe.  This is called automatically when the queue is garbage collected."
msgstr ""
"Bakgrundstråden kommer att avslutas när den har spolat all buffrad data till "
"pipen.  Detta anropas automatiskt när kön samlas in (garbage collected)."

#: ../../library/multiprocessing.rst:991
msgid ""
"Join the background thread.  This can only be used after :meth:`close` has "
"been called.  It blocks until the background thread exits, ensuring that all "
"data in the buffer has been flushed to the pipe."
msgstr ""
"Gå med i bakgrundstråden.  Detta kan endast användas efter att :meth:`close` "
"har anropats.  Den blockerar tills bakgrundstråden avslutas och säkerställer "
"att all data i bufferten har spolats till röret."

#: ../../library/multiprocessing.rst:995
msgid ""
"By default if a process is not the creator of the queue then on exit it will "
"attempt to join the queue's background thread.  The process can call :meth:"
"`cancel_join_thread` to make :meth:`join_thread` do nothing."
msgstr ""
"Om en process inte är skaparen av kön kommer den som standard att försöka "
"ansluta sig till köns bakgrundstråd när den avslutas.  Processen kan anropa :"
"meth:`cancel_join_thread` för att få :meth:`join_thread` att inte göra "
"någonting."

#: ../../library/multiprocessing.rst:1001
msgid ""
"Prevent :meth:`join_thread` from blocking.  In particular, this prevents the "
"background thread from being joined automatically when the process exits -- "
"see :meth:`join_thread`."
msgstr ""
"Förhindrar :meth:`join_thread` från att blockera.  I synnerhet förhindrar "
"detta att bakgrundstråden ansluts automatiskt när processen avslutas -- se :"
"meth:`join_thread`."

#: ../../library/multiprocessing.rst:1005
msgid ""
"A better name for this method might be ``allow_exit_without_flush()``.  It "
"is likely to cause enqueued data to be lost, and you almost certainly will "
"not need to use it. It is really only there if you need the current process "
"to exit immediately without waiting to flush enqueued data to the underlying "
"pipe, and you don't care about lost data."
msgstr ""
"Ett bättre namn på den här metoden skulle kunna vara "
"``allow_exit_without_flush()``.  Det är troligt att köade data går förlorade "
"och du kommer nästan aldrig att behöva använda den. Den finns egentligen "
"bara där om du vill att den aktuella processen ska avslutas omedelbart utan "
"att vänta på att spola köade data till den underliggande pipen, och du inte "
"bryr dig om förlorade data."

#: ../../library/multiprocessing.rst:1014
msgid ""
"This class's functionality requires a functioning shared semaphore "
"implementation on the host operating system. Without one, the functionality "
"in this class will be disabled, and attempts to instantiate a :class:`Queue` "
"will result in an :exc:`ImportError`. See :issue:`3770` for additional "
"information.  The same holds true for any of the specialized queue types "
"listed below."
msgstr ""
"Funktionaliteten i denna klass kräver en fungerande implementation av delade "
"semaforer i värdoperativsystemet. Utan en sådan kommer funktionaliteten i "
"denna klass att inaktiveras, och försök att instansiera en :class:`Queue` "
"kommer att resultera i ett :exc:`ImportError`. Se :issue:`3770` för "
"ytterligare information.  Detsamma gäller för någon av de specialiserade "
"kötyper som listas nedan."

#: ../../library/multiprocessing.rst:1023
msgid ""
"It is a simplified :class:`Queue` type, very close to a locked :class:`Pipe`."
msgstr ""
"Det är en förenklad :class:`Queue`-typ, mycket nära en låst :class:`Pipe`."

#: ../../library/multiprocessing.rst:1029
msgid ""
"A queue must not be used anymore after it is closed. For example, :meth:"
"`get`, :meth:`put` and :meth:`empty` methods must no longer be called."
msgstr ""
"En kö får inte längre användas efter att den har stängts. Till exempel får "
"metoderna :meth:`get`, :meth:`put` och :meth:`empty` inte längre anropas."

#: ../../library/multiprocessing.rst:1037
msgid "Return ``True`` if the queue is empty, ``False`` otherwise."
msgstr "Returnerar ``True`` om kön är tom, annars ``False``."

#: ../../library/multiprocessing.rst:1039
msgid "Always raises an :exc:`OSError` if the SimpleQueue is closed."
msgstr "Ger alltid upphov till ett :exc:`OSError` om SimpleQueue stängs."

#: ../../library/multiprocessing.rst:1043
msgid "Remove and return an item from the queue."
msgstr "Ta bort och returnera ett objekt från kön."

#: ../../library/multiprocessing.rst:1047
msgid "Put *item* into the queue."
msgstr "Lägg *objekt* i kön."

#: ../../library/multiprocessing.rst:1052
msgid ""
":class:`JoinableQueue`, a :class:`Queue` subclass, is a queue which "
"additionally has :meth:`task_done` and :meth:`join` methods."
msgstr ""
":class:`JoinableQueue`, en underklass till :class:`Queue`, är en kö som "
"dessutom har metoderna :meth:`task_done` och :meth:`join`."

#: ../../library/multiprocessing.rst:1057
msgid ""
"Indicate that a formerly enqueued task is complete. Used by queue "
"consumers.  For each :meth:`~Queue.get` used to fetch a task, a subsequent "
"call to :meth:`task_done` tells the queue that the processing on the task is "
"complete."
msgstr ""
"Anger att en tidigare köad uppgift är slutförd. Används av köanvändare.  För "
"varje :meth:`~Queue.get` som används för att hämta en uppgift, talar ett "
"efterföljande anrop till :meth:`task_done` om för kön att bearbetningen av "
"uppgiften är klar."

#: ../../library/multiprocessing.rst:1062
msgid ""
"If a :meth:`~queue.Queue.join` is currently blocking, it will resume when "
"all items have been processed (meaning that a :meth:`task_done` call was "
"received for every item that had been :meth:`~Queue.put` into the queue)."
msgstr ""
"Om en :meth:`~queue.Queue.join` för närvarande blockeras kommer den att "
"återupptas när alla objekt har bearbetats (vilket innebär att ett :meth:"
"`task_done`-anrop har mottagits för varje objekt som har :meth:`~Queue.put` "
"i kön)."

#: ../../library/multiprocessing.rst:1066
msgid ""
"Raises a :exc:`ValueError` if called more times than there were items placed "
"in the queue."
msgstr ""
"Utlöser ett :exc:`ValueError` om den anropas fler gånger än det finns objekt "
"i kön."

#: ../../library/multiprocessing.rst:1072
msgid "Block until all items in the queue have been gotten and processed."
msgstr "Blockera tills alla objekt i kön har hämtats och behandlats."

#: ../../library/multiprocessing.rst:1074
msgid ""
"The count of unfinished tasks goes up whenever an item is added to the "
"queue.  The count goes down whenever a consumer calls :meth:`task_done` to "
"indicate that the item was retrieved and all work on it is complete.  When "
"the count of unfinished tasks drops to zero, :meth:`~queue.Queue.join` "
"unblocks."
msgstr ""
"Antalet oavslutade uppgifter ökar varje gång ett objekt läggs till i kön.  "
"Antalet sjunker när en konsument anropar :meth:`task_done` för att ange att "
"objektet hämtades och att allt arbete med det är slutfört.  När antalet "
"oavslutade uppgifter sjunker till noll avblockeras :meth:`~queue.Queue.join`."

#: ../../library/multiprocessing.rst:1082
msgid "Miscellaneous"
msgstr "Diverse"

#: ../../library/multiprocessing.rst:1086
msgid "Return list of all live children of the current process."
msgstr ""
"Returnerar en lista över alla levande barn till den aktuella processen."

#: ../../library/multiprocessing.rst:1088
msgid ""
"Calling this has the side effect of \"joining\" any processes which have "
"already finished."
msgstr ""
"Om du anropar detta får det bieffekten att alla processer som redan har "
"avslutats \"ansluts\"."

#: ../../library/multiprocessing.rst:1093
msgid "Return the number of CPUs in the system."
msgstr "Returnerar antalet CPU:er i systemet."

#: ../../library/multiprocessing.rst:1095
msgid ""
"This number is not equivalent to the number of CPUs the current process can "
"use.  The number of usable CPUs can be obtained with :func:`os."
"process_cpu_count` (or ``len(os.sched_getaffinity(0))``)."
msgstr ""
"Detta antal motsvarar inte det antal processorer som den aktuella processen "
"kan använda.  Antalet användbara processorer kan erhållas med :func:`os."
"process_cpu_count` (eller ``len(os.sched_getaffinity(0))``)."

#: ../../library/multiprocessing.rst:1099
msgid ""
"When the number of CPUs cannot be determined a :exc:`NotImplementedError` is "
"raised."
msgstr ""
"När antalet CPU:er inte kan bestämmas uppstår ett :exc:`NotImplementedError`."

#: ../../library/multiprocessing.rst:1103
msgid ":func:`os.cpu_count` :func:`os.process_cpu_count`"
msgstr ":func:`os.cpu_count` :func:`os.process_cpu_count`"

#: ../../library/multiprocessing.rst:1108
msgid ""
"The return value can also be overridden using the :option:`-X cpu_count <-"
"X>` flag or :envvar:`PYTHON_CPU_COUNT` as this is merely a wrapper around "
"the :mod:`os` cpu count APIs."
msgstr ""
"Returvärdet kan också åsidosättas med flaggan :option:`-X cpu_count <-X>` "
"eller :envvar:`PYTHON_CPU_COUNT` eftersom detta bara är ett omslag runt API:"
"erna för cpu-räkning i :mod:`os`."

#: ../../library/multiprocessing.rst:1114
msgid ""
"Return the :class:`Process` object corresponding to the current process."
msgstr ""
"Returnerar :class:`Process`-objektet som motsvarar den aktuella processen."

#: ../../library/multiprocessing.rst:1116
msgid "An analogue of :func:`threading.current_thread`."
msgstr "En motsvarighet till :func:`threading.current_thread`."

#: ../../library/multiprocessing.rst:1120
msgid ""
"Return the :class:`Process` object corresponding to the parent process of "
"the :func:`current_process`. For the main process, ``parent_process`` will "
"be ``None``."
msgstr ""
"Returnerar :class:`Process`-objektet som motsvarar den överordnade processen "
"för :func:`current_process`. För huvudprocessen kommer ``parent_process`` "
"att vara ``None``."

#: ../../library/multiprocessing.rst:1128
msgid ""
"Add support for when a program which uses :mod:`multiprocessing` has been "
"frozen to produce an executable.  (Has been tested with **py2exe**, "
"**PyInstaller** and **cx_Freeze**.)"
msgstr ""
"Lägg till stöd för när ett program som använder :mod:`multiprocessing` har "
"frysts för att producera en körbar fil.  (Har testats med **py2exe**, "
"**PyInstaller** och **cx_Freeze**.)"

#: ../../library/multiprocessing.rst:1132
msgid ""
"One needs to call this function straight after the ``if __name__ == "
"'__main__'`` line of the main module.  For example::"
msgstr ""
"Man måste anropa den här funktionen direkt efter raden ``if __name__ == "
"'__main__'`` i huvudmodulen.  Till exempel::"

#: ../../library/multiprocessing.rst:1135
msgid ""
"from multiprocessing import Process, freeze_support\n"
"\n"
"def f():\n"
"    print('hello world!')\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    Process(target=f).start()"
msgstr ""
"från multiprocessing import Process, freeze_support\n"
"\n"
"def f():\n"
"    print('hej världen!')\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    Process(mål=f).start()"

#: ../../library/multiprocessing.rst:1144
msgid ""
"If the ``freeze_support()`` line is omitted then trying to run the frozen "
"executable will raise :exc:`RuntimeError`."
msgstr ""
"Om raden ``freeze_support()`` utelämnas kommer försök att köra den frysta "
"körbara filen att ge upphov till :exc:`RuntimeError`."

#: ../../library/multiprocessing.rst:1147
msgid ""
"Calling ``freeze_support()`` has no effect when the start method is not "
"*spawn*. In addition, if the module is being run normally by the Python "
"interpreter (the program has not been frozen), then ``freeze_support()`` has "
"no effect."
msgstr ""
"Anrop av ``freeze_support()`` har ingen effekt när startmetoden inte är "
"*spawn*. Dessutom, om modulen körs normalt av Python-tolken (programmet har "
"inte frysts), har ``freeze_support()`` ingen effekt."

#: ../../library/multiprocessing.rst:1154
msgid ""
"Returns a list of the supported start methods, the first of which is the "
"default.  The possible start methods are ``'fork'``, ``'spawn'`` and "
"``'forkserver'``.  Not all platforms support all methods.  See :ref:"
"`multiprocessing-start-methods`."
msgstr ""
"Returnerar en lista över de startmetoder som stöds, varav den första är "
"standard.  De möjliga startmetoderna är ``'fork'``, ``'spawn'`` och "
"``'forkserver'``.  Alla plattformar stöder inte alla metoder.  Se :ref:"
"`multiprocessing-start-methods`."

#: ../../library/multiprocessing.rst:1163
msgid ""
"Return a context object which has the same attributes as the :mod:"
"`multiprocessing` module."
msgstr ""
"Returnerar ett kontextobjekt som har samma attribut som modulen :mod:"
"`multiprocessing`."

#: ../../library/multiprocessing.rst:1166
msgid ""
"If *method* is ``None`` then the default context is returned. Note that if "
"the global start method has not been set, this will set it to the default "
"method. Otherwise *method* should be ``'fork'``, ``'spawn'``, "
"``'forkserver'``.  :exc:`ValueError` is raised if the specified start method "
"is not available.  See :ref:`multiprocessing-start-methods`."
msgstr ""
"Om *method* är ``None`` returneras standardkontexten. Observera att om den "
"globala startmetoden inte har ställts in, kommer detta att ställa in den "
"till standardmetoden. Annars bör *method* vara ``'fork'``, ``'spawn'``, "
"``'forkserver'``. :exc:`ValueError` uppstår om den angivna startmetoden inte "
"är tillgänglig.  Se :ref:`multiprocessing-start-methods`."

#: ../../library/multiprocessing.rst:1177
msgid "Return the name of start method used for starting processes."
msgstr ""
"Returnerar namnet på den startmetod som används för att starta processer."

#: ../../library/multiprocessing.rst:1179
msgid ""
"If the global start method has not been set and *allow_none* is ``False``, "
"then the start method is set to the default and the name is returned. If the "
"start method has not been set and *allow_none* is ``True`` then ``None`` is "
"returned."
msgstr ""
"Om den globala startmetoden inte har ställts in och *allow_none* är "
"``False``, ställs startmetoden in på standardvärdet och namnet returneras. "
"Om startmetoden inte har ställts in och *allow_none* är ``True`` returneras "
"``None``."

#: ../../library/multiprocessing.rst:1184
msgid ""
"The return value can be ``'fork'``, ``'spawn'``, ``'forkserver'`` or "
"``None``.  See :ref:`multiprocessing-start-methods`."
msgstr ""
"Returvärdet kan vara ``'fork'``, ``'spawn'``, ``'forkserver'`` eller "
"``None``.  Se :ref:`multiprocessing-start-methods`."

#: ../../library/multiprocessing.rst:1191
msgid ""
"On macOS, the *spawn* start method is now the default.  The *fork* start "
"method should be considered unsafe as it can lead to crashes of the "
"subprocess. See :issue:`33725`."
msgstr ""
"På macOS är startmetoden *spawn* nu standard.  Startmetoden *fork* bör "
"betraktas som osäker eftersom den kan leda till att underprocessen kraschar. "
"Se :issue:`33725`."

#: ../../library/multiprocessing.rst:1197
msgid ""
"Set the path of the Python interpreter to use when starting a child process. "
"(By default :data:`sys.executable` is used).  Embedders will probably need "
"to do some thing like ::"
msgstr ""
"Ange sökvägen till den Python-tolk som ska användas när en underordnad "
"process startas. (Som standard används :data:`sys.executable`).  Inbäddare "
"kommer förmodligen att behöva göra något i stil med ::"

#: ../../library/multiprocessing.rst:1201
msgid "set_executable(os.path.join(sys.exec_prefix, 'pythonw.exe'))"
msgstr "set_executable(os.path.join(sys.exec_prefix, 'pythonw.exe'))"

#: ../../library/multiprocessing.rst:1203
msgid "before they can create child processes."
msgstr "innan de kan skapa underordnade processer."

#: ../../library/multiprocessing.rst:1205
msgid "Now supported on POSIX when the ``'spawn'`` start method is used."
msgstr "Stödjs nu på POSIX när startmetoden ``'spawn'`` används."

#: ../../library/multiprocessing.rst:1208
msgid "Accepts a :term:`path-like object`."
msgstr "Accepterar en :term:`path-liknande objekt`."

#: ../../library/multiprocessing.rst:1213
msgid ""
"Set a list of module names for the forkserver main process to attempt to "
"import so that their already imported state is inherited by forked "
"processes. Any :exc:`ImportError` when doing so is silently ignored. This "
"can be used as a performance enhancement to avoid repeated work in every "
"process."
msgstr ""
"Ange en lista med modulnamn som huvudprocessen för forkserver ska försöka "
"importera så att deras redan importerade tillstånd ärvs av förgrenade "
"processer. Alla :exc:`ImportError` när detta görs ignoreras i tysthet. Detta "
"kan användas som en prestandaförbättring för att undvika upprepat arbete i "
"varje process."

#: ../../library/multiprocessing.rst:1219
msgid ""
"For this to work, it must be called before the forkserver process has been "
"launched (before creating a :class:`Pool` or starting a :class:`Process`)."
msgstr ""
"För att detta ska fungera måste det anropas innan forkserver-processen har "
"startats (innan du skapar en :class:`Pool` eller startar en :class:"
"`Process`)."

#: ../../library/multiprocessing.rst:1222
msgid ""
"Only meaningful when using the ``'forkserver'`` start method. See :ref:"
"`multiprocessing-start-methods`."
msgstr ""
"Endast meningsfullt när man använder startmetoden ``'forkserver''. Se :ref:"
"`multiprocessing-start-methods`."

#: ../../library/multiprocessing.rst:1229
msgid ""
"Set the method which should be used to start child processes. The *method* "
"argument can be ``'fork'``, ``'spawn'`` or ``'forkserver'``. Raises :exc:"
"`RuntimeError` if the start method has already been set and *force* is not "
"``True``.  If *method* is ``None`` and *force* is ``True`` then the start "
"method is set to ``None``.  If *method* is ``None`` and *force* is ``False`` "
"then the context is set to the default context."
msgstr ""
"Ange vilken metod som ska användas för att starta underordnade processer. "
"Argumentet *method* kan vara ``'fork'``, ``'spawn'`` eller ``'forkserver'``. "
"Utlöser :exc:`RuntimeError` om startmetoden redan har ställts in och *force* "
"inte är ``True``.  Om *method* är ``None`` och *force* är ``True`` så sätts "
"startmetoden till ``None``.  Om *method* är ``None`` och *force* är "
"``False`` sätts kontexten till standardkontexten."

#: ../../library/multiprocessing.rst:1236
msgid ""
"Note that this should be called at most once, and it should be protected "
"inside the ``if __name__ == '__main__'`` clause of the main module."
msgstr ""
"Observera att detta ska anropas högst en gång och att det ska skyddas i ``if "
"__name__ == '__main__'`` i huvudmodulens klausul."

#: ../../library/multiprocessing.rst:1240
msgid "See :ref:`multiprocessing-start-methods`."
msgstr "Se :ref:`multiprocessing-start-methods`."

#: ../../library/multiprocessing.rst:1246
msgid ""
":mod:`multiprocessing` contains no analogues of :func:`threading."
"active_count`, :func:`threading.enumerate`, :func:`threading.settrace`, :"
"func:`threading.setprofile`, :class:`threading.Timer`, or :class:`threading."
"local`."
msgstr ""
":mod:`multiprocessing` innehåller inga motsvarigheter till :func:`threading."
"active_count`, :func:`threading.enumerate`, :func:`threading.settrace`, :"
"func:`threading.setprofile`, :class:`threading.Timer`, eller :class:"
"`threading.local`."

#: ../../library/multiprocessing.rst:1253
msgid "Connection Objects"
msgstr "Anslutningsobjekt"

#: ../../library/multiprocessing.rst:1257
msgid ""
"Connection objects allow the sending and receiving of picklable objects or "
"strings.  They can be thought of as message oriented connected sockets."
msgstr ""
"Connection-objekt gör det möjligt att skicka och ta emot plockbara objekt "
"eller strängar.  De kan betraktas som meddelandeorienterade anslutna socklar."

#: ../../library/multiprocessing.rst:1260
msgid ""
"Connection objects are usually created using :func:`Pipe <multiprocessing."
"Pipe>` -- see also :ref:`multiprocessing-listeners-clients`."
msgstr ""
"Anslutningsobjekt skapas vanligtvis med :func:`Pipe <multiprocessing.Pipe>` "
"-- se även :ref:`multiprocessing-listeners-clients`."

#: ../../library/multiprocessing.rst:1268
msgid ""
"Send an object to the other end of the connection which should be read "
"using :meth:`recv`."
msgstr ""
"Skicka ett objekt till den andra änden av anslutningen som ska läsas med "
"hjälp av :meth:`recv`."

#: ../../library/multiprocessing.rst:1271
msgid ""
"The object must be picklable.  Very large pickles (approximately 32 MiB+, "
"though it depends on the OS) may raise a :exc:`ValueError` exception."
msgstr ""
"Objektet måste kunna picklas.  Mycket stora pickles (ungefär 32 MiB+, men "
"det beror på operativsystemet) kan ge upphov till ett :exc:`ValueError`-"
"undantag."

#: ../../library/multiprocessing.rst:1276
msgid ""
"Return an object sent from the other end of the connection using :meth:"
"`send`.  Blocks until there is something to receive.  Raises :exc:`EOFError` "
"if there is nothing left to receive and the other end was closed."
msgstr ""
"Returnerar ett objekt som skickats från den andra änden av anslutningen med :"
"meth:`send`.  Blockerar tills det finns något att ta emot.  Utlöser :exc:"
"`EOFError` om det inte finns något kvar att ta emot och den andra änden var "
"stängd."

#: ../../library/multiprocessing.rst:1283
msgid "Return the file descriptor or handle used by the connection."
msgstr "Returnerar filbeskrivaren eller handtaget som används av anslutningen."

#: ../../library/multiprocessing.rst:1287
msgid "Close the connection."
msgstr "Stäng anslutningen."

#: ../../library/multiprocessing.rst:1289
msgid "This is called automatically when the connection is garbage collected."
msgstr "Detta anropas automatiskt när anslutningen garbage collectas."

#: ../../library/multiprocessing.rst:1293
msgid "Return whether there is any data available to be read."
msgstr "Returnerar om det finns någon data tillgänglig för läsning."

#: ../../library/multiprocessing.rst:1295
msgid ""
"If *timeout* is not specified then it will return immediately.  If *timeout* "
"is a number then this specifies the maximum time in seconds to block.  If "
"*timeout* is ``None`` then an infinite timeout is used."
msgstr ""
"Om *timeout* inte anges kommer den att returnera omedelbart.  Om *timeout* "
"är ett tal anger detta den maximala tiden i sekunder för blockering.  Om "
"*timeout* är ``None`` används en oändlig timeout."

#: ../../library/multiprocessing.rst:1299
msgid ""
"Note that multiple connection objects may be polled at once by using :func:"
"`multiprocessing.connection.wait`."
msgstr ""
"Observera att flera anslutningsobjekt kan pollas samtidigt genom att "
"använda :func:`multiprocessing.connection.wait`."

#: ../../library/multiprocessing.rst:1304
msgid "Send byte data from a :term:`bytes-like object` as a complete message."
msgstr ""
"Skicka byte-data från ett :term:`bytesliknande objekt` som ett komplett "
"meddelande."

#: ../../library/multiprocessing.rst:1306
msgid ""
"If *offset* is given then data is read from that position in *buffer*.  If "
"*size* is given then that many bytes will be read from buffer.  Very large "
"buffers (approximately 32 MiB+, though it depends on the OS) may raise a :"
"exc:`ValueError` exception"
msgstr ""
"Om *offset* anges läses data från den positionen i *buffer*.  Om *size* "
"anges kommer så många byte att läsas från bufferten.  Mycket stora buffertar "
"(ungefär 32 MiB+, men det beror på operativsystemet) kan ge upphov till ett :"
"exc:`ValueError`-undantag"

#: ../../library/multiprocessing.rst:1313
msgid ""
"Return a complete message of byte data sent from the other end of the "
"connection as a string.  Blocks until there is something to receive. Raises :"
"exc:`EOFError` if there is nothing left to receive and the other end has "
"closed."
msgstr ""
"Returnerar ett komplett meddelande med byte-data som skickats från den andra "
"änden av anslutningen som en sträng.  Blockerar tills det finns något att ta "
"emot. Utlöser :exc:`EOFError` om det inte finns något kvar att ta emot och "
"den andra änden har stängt."

#: ../../library/multiprocessing.rst:1318
msgid ""
"If *maxlength* is specified and the message is longer than *maxlength* then :"
"exc:`OSError` is raised and the connection will no longer be readable."
msgstr ""
"Om *maxlength* anges och meddelandet är längre än *maxlength* så uppstår :"
"exc:`OSError` och anslutningen kommer inte längre att vara läsbar."

#: ../../library/multiprocessing.rst:1322
msgid ""
"This function used to raise :exc:`IOError`, which is now an alias of :exc:"
"`OSError`."
msgstr ""
"Denna funktion gav tidigare upphov till :exc:`IOError`, som nu är ett alias "
"för :exc:`OSError`."

#: ../../library/multiprocessing.rst:1329
msgid ""
"Read into *buffer* a complete message of byte data sent from the other end "
"of the connection and return the number of bytes in the message.  Blocks "
"until there is something to receive.  Raises :exc:`EOFError` if there is "
"nothing left to receive and the other end was closed."
msgstr ""
"Läser in i *buffer* ett komplett meddelande med byte-data som skickas från "
"den andra änden av anslutningen och returnerar antalet byte i meddelandet.  "
"Blockerar tills det finns något att ta emot.  Utlöser :exc:`EOFError` om det "
"inte finns något kvar att ta emot och den andra änden var stängd."

#: ../../library/multiprocessing.rst:1335
msgid ""
"*buffer* must be a writable :term:`bytes-like object`.  If *offset* is given "
"then the message will be written into the buffer from that position.  Offset "
"must be a non-negative integer less than the length of *buffer* (in bytes)."
msgstr ""
"*buffer* måste vara ett skrivbart :term:`bytesliknande objekt`.  Om *offset* "
"anges kommer meddelandet att skrivas in i bufferten från den positionen.  "
"Offset måste vara ett icke-negativt heltal som är mindre än längden på "
"*buffer* (i byte)."

#: ../../library/multiprocessing.rst:1340
msgid ""
"If the buffer is too short then a :exc:`BufferTooShort` exception is raised "
"and the complete message is available as ``e.args[0]`` where ``e`` is the "
"exception instance."
msgstr ""
"Om bufferten är för kort uppstår ett :exc:`BufferTooShort` undantag och det "
"fullständiga meddelandet finns tillgängligt som ``e.args[0]`` där ``e`` är "
"undantagsinstansen."

#: ../../library/multiprocessing.rst:1344
msgid ""
"Connection objects themselves can now be transferred between processes "
"using :meth:`Connection.send` and :meth:`Connection.recv`."
msgstr ""
"Själva anslutningsobjekten kan nu överföras mellan processer med hjälp av :"
"meth:`Connection.send` och :meth:`Connection.recv`."

#: ../../library/multiprocessing.rst:1348
msgid ""
"Connection objects also now support the context management protocol -- see :"
"ref:`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the "
"connection object, and :meth:`~contextmanager.__exit__` calls :meth:`close`."
msgstr ""
"Anslutningsobjekt stöder nu också kontexthanteringsprotokollet -- se :ref:"
"`typecontextmanager`. :meth:`~contextmanager.__enter__` returnerar "
"anslutningsobjektet och :meth:`~contextmanager.__exit__` anropar :meth:"
"`close`."

#: ../../library/multiprocessing.rst:1352
msgid "For example:"
msgstr "Till exempel:"

#: ../../library/multiprocessing.rst:1354
msgid ""
">>> from multiprocessing import Pipe\n"
">>> a, b = Pipe()\n"
">>> a.send([1, 'hello', None])\n"
">>> b.recv()\n"
"[1, 'hello', None]\n"
">>> b.send_bytes(b'thank you')\n"
">>> a.recv_bytes()\n"
"b'thank you'\n"
">>> import array\n"
">>> arr1 = array.array('i', range(5))\n"
">>> arr2 = array.array('i', [0] * 10)\n"
">>> a.send_bytes(arr1)\n"
">>> count = b.recv_bytes_into(arr2)\n"
">>> assert count == len(arr1) * arr1.itemsize\n"
">>> arr2\n"
"array('i', [0, 1, 2, 3, 4, 0, 0, 0, 0, 0])"
msgstr ""
">>> från multiprocessing import Pipe\n"
">>> a, b = Pipe()\n"
">>> a.send([1, 'hallå', None])\n"
">>> b.recv()\n"
"[1, 'hej', ingen]\n"
">>> b.send_bytes(b'tack')\n"
">>> a.recv_bytes()\n"
"b'tack'\n"
">>> importera array\n"
">>> arr1 = array.array('i', intervall(5))\n"
">>> arr2 = array.array('i', [0] * 10)\n"
">>> a.skicka_bytes(arr1)\n"
">>> count = b.recv_bytes_into(arr2)\n"
">>> assert count == len(arr1) * arr1.itemsize\n"
">>> arr2\n"
"array('i', [0, 1, 2, 3, 4, 0, 0, 0, 0, 0, 0])"

#: ../../library/multiprocessing.rst:1377
msgid ""
"The :meth:`Connection.recv` method automatically unpickles the data it "
"receives, which can be a security risk unless you can trust the process "
"which sent the message."
msgstr ""
"Metoden :meth:`Connection.recv` avplockar automatiskt de data den tar emot, "
"vilket kan vara en säkerhetsrisk om du inte kan lita på den process som "
"skickade meddelandet."

#: ../../library/multiprocessing.rst:1381
msgid ""
"Therefore, unless the connection object was produced using :func:`Pipe` you "
"should only use the :meth:`~Connection.recv` and :meth:`~Connection.send` "
"methods after performing some sort of authentication.  See :ref:"
"`multiprocessing-auth-keys`."
msgstr ""
"Om inte anslutningsobjektet producerades med :func:`Pipe` bör du därför "
"endast använda metoderna :meth:`~Connection.recv` och :meth:`~Connection."
"send` efter att ha utfört någon form av autentisering.  Se :ref:"
"`multiprocessing-auth-keys`."

#: ../../library/multiprocessing.rst:1388
msgid ""
"If a process is killed while it is trying to read or write to a pipe then "
"the data in the pipe is likely to become corrupted, because it may become "
"impossible to be sure where the message boundaries lie."
msgstr ""
"Om en process dödas medan den försöker läsa eller skriva till en pipe kommer "
"data i pipen sannolikt att korrumperas, eftersom det kan bli omöjligt att "
"vara säker på var meddelandegränserna ligger."

#: ../../library/multiprocessing.rst:1394
msgid "Synchronization primitives"
msgstr "Synkroniseringsprimitiver"

#: ../../library/multiprocessing.rst:1398
msgid ""
"Generally synchronization primitives are not as necessary in a multiprocess "
"program as they are in a multithreaded program.  See the documentation for :"
"mod:`threading` module."
msgstr ""
"Generellt sett är synkroniseringsprimitiver inte lika nödvändiga i ett "
"multiprocessprogram som i ett flertrådat program.  Se dokumentationen för "
"modulen :mod:`threading`."

#: ../../library/multiprocessing.rst:1402
msgid ""
"Note that one can also create synchronization primitives by using a manager "
"object -- see :ref:`multiprocessing-managers`."
msgstr ""
"Observera att man också kan skapa synkroniseringsprimitiver genom att "
"använda ett manager-objekt -- se :ref:`multiprocessing-managers`."

#: ../../library/multiprocessing.rst:1407
msgid "A barrier object: a clone of :class:`threading.Barrier`."
msgstr "Ett barriärobjekt: en klon av :class:`threading.Barrier`."

#: ../../library/multiprocessing.rst:1413
msgid ""
"A bounded semaphore object: a close analog of :class:`threading."
"BoundedSemaphore`."
msgstr ""
"Ett begränsat semaforobjekt: en nära analog till :class:`threading."
"BoundedSemaphore`."

#: ../../library/multiprocessing.rst:1416
#: ../../library/multiprocessing.rst:1568
msgid ""
"A solitary difference from its close analog exists: its ``acquire`` method's "
"first argument is named *block*, as is consistent with :meth:`Lock.acquire`."
msgstr ""
"En enda skillnad från dess nära analog finns: dess ``acquire``-metods första "
"argument heter *block*, vilket är i överensstämmelse med :meth:`Lock."
"acquire`."

#: ../../library/multiprocessing.rst:1420
msgid ""
"On macOS, this is indistinguishable from :class:`Semaphore` because "
"``sem_getvalue()`` is not implemented on that platform."
msgstr ""
"På macOS kan detta inte skiljas från :class:`Semaphore` eftersom "
"``sem_getvalue()`` inte är implementerat på den plattformen."

#: ../../library/multiprocessing.rst:1425
msgid "A condition variable: an alias for :class:`threading.Condition`."
msgstr "En villkorsvariabel: ett alias för :class:`threading.Condition`."

#: ../../library/multiprocessing.rst:1427
msgid ""
"If *lock* is specified then it should be a :class:`Lock` or :class:`RLock` "
"object from :mod:`multiprocessing`."
msgstr ""
"Om *lock* anges bör det vara ett :class:`Lock`- eller :class:`RLock`-objekt "
"från :mod:`multiprocessing`."

#: ../../library/multiprocessing.rst:1430
#: ../../library/multiprocessing.rst:1982
msgid "The :meth:`~threading.Condition.wait_for` method was added."
msgstr "Metoden :meth:`~threading.Condition.wait_for` lades till."

#: ../../library/multiprocessing.rst:1435
msgid "A clone of :class:`threading.Event`."
msgstr "En klon av :class:`threading.Event`."

#: ../../library/multiprocessing.rst:1440
msgid ""
"A non-recursive lock object: a close analog of :class:`threading.Lock`. Once "
"a process or thread has acquired a lock, subsequent attempts to acquire it "
"from any process or thread will block until it is released; any process or "
"thread may release it.  The concepts and behaviors of :class:`threading."
"Lock` as it applies to threads are replicated here in :class:"
"`multiprocessing.Lock` as it applies to either processes or threads, except "
"as noted."
msgstr ""
"Ett icke-rekursivt låsobjekt: en nära motsvarighet till :class:`threading."
"Lock`. När en process eller tråd har förvärvat ett lås kommer efterföljande "
"försök att förvärva det från någon annan process eller tråd att blockeras "
"tills det släpps; vilken process eller tråd som helst kan släppa det.  "
"Koncepten och beteendena i :class:`threading.Lock` som gäller för trådar är "
"replikerade här i :class:`multiprocessing.Lock` som gäller för antingen "
"processer eller trådar, förutom vad som anges."

#: ../../library/multiprocessing.rst:1448
msgid ""
"Note that :class:`Lock` is actually a factory function which returns an "
"instance of ``multiprocessing.synchronize.Lock`` initialized with a default "
"context."
msgstr ""
"Observera att :class:`Lock` faktiskt är en fabriksfunktion som returnerar en "
"instans av ``multiprocessing.synchronize.Lock`` initialiserad med en "
"standardkontext."

#: ../../library/multiprocessing.rst:1452
msgid ""
":class:`Lock` supports the :term:`context manager` protocol and thus may be "
"used in :keyword:`with` statements."
msgstr ""
":class:`Lock` stöder protokollet :term:`context manager` och kan därför "
"användas i :keyword:`with`-satser."

#: ../../library/multiprocessing.rst:1457
#: ../../library/multiprocessing.rst:1515
msgid "Acquire a lock, blocking or non-blocking."
msgstr "Förvärva ett lås, blockerande eller icke-blockerande."

#: ../../library/multiprocessing.rst:1459
msgid ""
"With the *block* argument set to ``True`` (the default), the method call "
"will block until the lock is in an unlocked state, then set it to locked and "
"return ``True``.  Note that the name of this first argument differs from "
"that in :meth:`threading.Lock.acquire`."
msgstr ""
"Med *block*-argumentet inställt på ``True`` (standard) kommer metodanropet "
"att blockera tills låset är i ett olåst tillstånd, sedan ställa in det på "
"låst och returnera ``True``.  Observera att namnet på detta första argument "
"skiljer sig från det i :meth:`threading.Lock.acquire`."

#: ../../library/multiprocessing.rst:1464
msgid ""
"With the *block* argument set to ``False``, the method call does not block.  "
"If the lock is currently in a locked state, return ``False``; otherwise set "
"the lock to a locked state and return ``True``."
msgstr ""
"Om argumentet *block* är satt till ``False`` blockeras inte metodanropet.  "
"Om låset för närvarande är i låst tillstånd returneras ``False``; annars "
"sätts låset i låst tillstånd och returneras ``True``."

#: ../../library/multiprocessing.rst:1468
msgid ""
"When invoked with a positive, floating-point value for *timeout*, block for "
"at most the number of seconds specified by *timeout* as long as the lock can "
"not be acquired.  Invocations with a negative value for *timeout* are "
"equivalent to a *timeout* of zero.  Invocations with a *timeout* value of "
"``None`` (the default) set the timeout period to infinite.  Note that the "
"treatment of negative or ``None`` values for *timeout* differs from the "
"implemented behavior in :meth:`threading.Lock.acquire`.  The *timeout* "
"argument has no practical implications if the *block* argument is set to "
"``False`` and is thus ignored.  Returns ``True`` if the lock has been "
"acquired or ``False`` if the timeout period has elapsed."
msgstr ""
"När *timeout* anropas med ett positivt värde i flyttal, blockeras låset i "
"högst det antal sekunder som anges av *timeout* så länge låset inte kan "
"förvärvas.  Anrop med ett negativt värde för *timeout* är likvärdigt med en "
"*timeout* på noll.  Anrop med ett *timeout*-värde på ``None`` (standard) "
"sätter timeout-perioden till oändlig.  Observera att behandlingen av "
"negativa eller ``None``-värden för *timeout* skiljer sig från det "
"implementerade beteendet i :meth:`threading.Lock.acquire`.  Argumentet "
"*timeout* har inga praktiska konsekvenser om argumentet *block* är satt till "
"``False`` och ignoreras därför.  Returnerar ``True`` om låset har förvärvats "
"eller ``False`` om timeout-perioden har löpt ut."

#: ../../library/multiprocessing.rst:1483
msgid ""
"Release a lock.  This can be called from any process or thread, not only the "
"process or thread which originally acquired the lock."
msgstr ""
"Frigör ett lås.  Detta kan anropas från vilken process eller tråd som helst, "
"inte bara från den process eller tråd som ursprungligen förvärvade låset."

#: ../../library/multiprocessing.rst:1486
msgid ""
"Behavior is the same as in :meth:`threading.Lock.release` except that when "
"invoked on an unlocked lock, a :exc:`ValueError` is raised."
msgstr ""
"Beteendet är detsamma som i :meth:`threading.Lock.release` förutom att ett :"
"exc:`ValueError` uppstår när det anropas på ett olåst lås."

#: ../../library/multiprocessing.rst:1492
#: ../../library/multiprocessing.rst:1559
msgid "Return a boolean indicating whether this object is locked right now."
msgstr "Returnerar en boolean som anger om detta objekt är låst just nu."

#: ../../library/multiprocessing.rst:1499
msgid ""
"A recursive lock object: a close analog of :class:`threading.RLock`.  A "
"recursive lock must be released by the process or thread that acquired it. "
"Once a process or thread has acquired a recursive lock, the same process or "
"thread may acquire it again without blocking; that process or thread must "
"release it once for each time it has been acquired."
msgstr ""
"Ett rekursivt låsobjekt: en nära motsvarighet till :class:`threading."
"RLock`.  Ett rekursivt lås måste frigöras av den process eller tråd som "
"förvärvade det. När en process eller tråd har förvärvat ett rekursivt lås "
"kan samma process eller tråd förvärva det igen utan att blockera; den "
"processen eller tråden måste släppa det en gång för varje gång det har "
"förvärvats."

#: ../../library/multiprocessing.rst:1505
msgid ""
"Note that :class:`RLock` is actually a factory function which returns an "
"instance of ``multiprocessing.synchronize.RLock`` initialized with a default "
"context."
msgstr ""
"Observera att :class:`RLock` faktiskt är en fabriksfunktion som returnerar "
"en instans av ``multiprocessing.synchronize.RLock`` initialiserad med en "
"standardkontext."

#: ../../library/multiprocessing.rst:1509
msgid ""
":class:`RLock` supports the :term:`context manager` protocol and thus may be "
"used in :keyword:`with` statements."
msgstr ""
":class:`RLock` stöder protokollet :term:`context manager` och kan därför "
"användas i :keyword:`with`-satser."

#: ../../library/multiprocessing.rst:1517
msgid ""
"When invoked with the *block* argument set to ``True``, block until the lock "
"is in an unlocked state (not owned by any process or thread) unless the lock "
"is already owned by the current process or thread.  The current process or "
"thread then takes ownership of the lock (if it does not already have "
"ownership) and the recursion level inside the lock increments by one, "
"resulting in a return value of ``True``.  Note that there are several "
"differences in this first argument's behavior compared to the implementation "
"of :meth:`threading.RLock.acquire`, starting with the name of the argument "
"itself."
msgstr ""
"När den anropas med argumentet *block* inställt på ``True`` blockeras den "
"tills låset är olåst (inte ägs av någon process eller tråd) om inte låset "
"redan ägs av den aktuella processen eller tråden.  Den aktuella processen "
"eller tråden tar då över ägandet av låset (om den inte redan har ägandet) "
"och rekursionsnivån inuti låset ökar med ett, vilket resulterar i ett "
"returvärde på ``True``.  Observera att det finns flera skillnader i detta "
"första arguments beteende jämfört med implementeringen av :meth:`threading."
"RLock.acquire`, som börjar med namnet på själva argumentet."

#: ../../library/multiprocessing.rst:1527
msgid ""
"When invoked with the *block* argument set to ``False``, do not block. If "
"the lock has already been acquired (and thus is owned) by another process or "
"thread, the current process or thread does not take ownership and the "
"recursion level within the lock is not changed, resulting in a return value "
"of ``False``.  If the lock is in an unlocked state, the current process or "
"thread takes ownership and the recursion level is incremented, resulting in "
"a return value of ``True``."
msgstr ""
"När den anropas med argumentet *block* satt till ``False``, blockeras inte. "
"Om låset redan har förvärvats (och därmed ägs) av en annan process eller "
"tråd, tar den aktuella processen eller tråden inte över ägandet och "
"rekursionsnivån i låset ändras inte, vilket resulterar i ett returvärde på "
"``False``.  Om låset är olåst tar den aktuella processen eller tråden över "
"ägandet och rekursionsnivån ökas, vilket resulterar i ett returvärde på "
"``True``."

#: ../../library/multiprocessing.rst:1535
msgid ""
"Use and behaviors of the *timeout* argument are the same as in :meth:`Lock."
"acquire`.  Note that some of these behaviors of *timeout* differ from the "
"implemented behaviors in :meth:`threading.RLock.acquire`."
msgstr ""
"Användning och beteenden för argumentet *timeout* är desamma som i :meth:"
"`Lock.acquire`.  Observera att vissa av dessa beteenden hos *timeout* "
"skiljer sig från de implementerade beteendena i :meth:`threading.RLock."
"acquire`."

#: ../../library/multiprocessing.rst:1542
msgid ""
"Release a lock, decrementing the recursion level.  If after the decrement "
"the recursion level is zero, reset the lock to unlocked (not owned by any "
"process or thread) and if any other processes or threads are blocked waiting "
"for the lock to become unlocked, allow exactly one of them to proceed.  If "
"after the decrement the recursion level is still nonzero, the lock remains "
"locked and owned by the calling process or thread."
msgstr ""
"Frigör ett lås och dekrementera rekursionsnivån.  Om rekursionsnivån är noll "
"efter dekrementeringen, återställ låset till olåst (ägs inte av någon "
"process eller tråd) och om några andra processer eller trådar är blockerade "
"i väntan på att låset ska bli olåst, låt exakt en av dem fortsätta.  Om "
"rekursionsnivån efter dekrementeringen fortfarande inte är noll, förblir "
"låset låst och ägs av den anropande processen eller tråden."

#: ../../library/multiprocessing.rst:1550
msgid ""
"Only call this method when the calling process or thread owns the lock. An :"
"exc:`AssertionError` is raised if this method is called by a process or "
"thread other than the owner or if the lock is in an unlocked (unowned) "
"state.  Note that the type of exception raised in this situation differs "
"from the implemented behavior in :meth:`threading.RLock.release`."
msgstr ""
"Anropa endast denna metod när den anropande processen eller tråden äger "
"låset. Ett :exc:`AssertionError` uppstår om denna metod anropas av en annan "
"process eller tråd än ägaren eller om låset är i ett olåst (oägt) "
"tillstånd.  Observera att den typ av undantag som uppstår i denna situation "
"skiljer sig från det implementerade beteendet i :meth:`threading.RLock."
"release`."

#: ../../library/multiprocessing.rst:1566
msgid "A semaphore object: a close analog of :class:`threading.Semaphore`."
msgstr ""
"Ett semaforobjekt: en nära motsvarighet till :class:`threading.Semaphore`."

#: ../../library/multiprocessing.rst:1573
msgid ""
"On macOS, ``sem_timedwait`` is unsupported, so calling ``acquire()`` with a "
"timeout will emulate that function's behavior using a sleeping loop."
msgstr ""
"På macOS stöds inte ```em_timedwait``, så om du anropar ``acquire()`` med en "
"timeout kommer den funktionens beteende att emuleras med en sovande loop."

#: ../../library/multiprocessing.rst:1578
msgid ""
"Some of this package's functionality requires a functioning shared semaphore "
"implementation on the host operating system. Without one, the :mod:"
"`multiprocessing.synchronize` module will be disabled, and attempts to "
"import it will result in an :exc:`ImportError`. See :issue:`3770` for "
"additional information."
msgstr ""
"En del av funktionaliteten i detta paket kräver en fungerande implementation "
"av delade semaforer i värdoperativsystemet. Utan en sådan kommer modulen :"
"mod:`multiprocessing.synchronize` att inaktiveras och försök att importera "
"den kommer att resultera i ett :exc:`ImportError`. Se :issue:`3770` för "
"ytterligare information."

#: ../../library/multiprocessing.rst:1586
msgid "Shared :mod:`ctypes` Objects"
msgstr "Delade :mod:`ctypes`-objekt"

#: ../../library/multiprocessing.rst:1588
msgid ""
"It is possible to create shared objects using shared memory which can be "
"inherited by child processes."
msgstr ""
"Det är möjligt att skapa delade objekt med hjälp av delat minne som kan "
"ärvas av underordnade processer."

#: ../../library/multiprocessing.rst:1593
msgid ""
"Return a :mod:`ctypes` object allocated from shared memory.  By default the "
"return value is actually a synchronized wrapper for the object.  The object "
"itself can be accessed via the *value* attribute of a :class:`Value`."
msgstr ""
"Returnerar ett :mod:`ctypes`-objekt som allokerats från ett delat minne.  "
"Som standard är returvärdet faktiskt ett synkroniserat omslag för objektet.  "
"Själva objektet kan nås via *value*-attributet i en :class:`Value`."

#: ../../library/multiprocessing.rst:1597
#: ../../library/multiprocessing.rst:1684
msgid ""
"*typecode_or_type* determines the type of the returned object: it is either "
"a ctypes type or a one character typecode of the kind used by the :mod:"
"`array` module.  *\\*args* is passed on to the constructor for the type."
msgstr ""
"*typecode_or_type* bestämmer typen av det returnerade objektet: det är "
"antingen en ctypes-typ eller en typkod med ett tecken av den typ som används "
"av modulen :mod:`array`.  *\\*args* skickas vidare till konstruktören för "
"typen."

#: ../../library/multiprocessing.rst:1601
msgid ""
"If *lock* is ``True`` (the default) then a new recursive lock object is "
"created to synchronize access to the value.  If *lock* is a :class:`Lock` "
"or :class:`RLock` object then that will be used to synchronize access to the "
"value.  If *lock* is ``False`` then access to the returned object will not "
"be automatically protected by a lock, so it will not necessarily be "
"\"process-safe\"."
msgstr ""
"Om *lock* är ``True`` (standard) skapas ett nytt rekursivt låsobjekt för att "
"synkronisera åtkomsten till värdet.  Om *lock* är ett :class:`Lock`- eller :"
"class:`RLock`-objekt kommer det att användas för att synkronisera åtkomst "
"till värdet.  Om *lock* är ``False`` kommer åtkomst till det returnerade "
"objektet inte automatiskt att skyddas av ett lås, så det kommer inte "
"nödvändigtvis att vara \"processäkert\"."

#: ../../library/multiprocessing.rst:1608
msgid ""
"Operations like ``+=`` which involve a read and write are not atomic.  So "
"if, for instance, you want to atomically increment a shared value it is "
"insufficient to just do ::"
msgstr ""
"Operationer som ``+=`` som involverar en läsning och skrivning är inte "
"atomiska.  Så om du till exempel vill öka ett delat värde atomiskt räcker "
"det inte med att bara göra ::"

#: ../../library/multiprocessing.rst:1612
msgid "counter.value += 1"
msgstr "räknare.värde += 1"

#: ../../library/multiprocessing.rst:1614
msgid ""
"Assuming the associated lock is recursive (which it is by default) you can "
"instead do ::"
msgstr ""
"Förutsatt att det associerade låset är rekursivt (vilket det är som "
"standard) kan du istället göra ::"

#: ../../library/multiprocessing.rst:1617
msgid ""
"with counter.get_lock():\n"
"    counter.value += 1"
msgstr ""
"med counter.get_lock():\n"
"    räknare.värde += 1"

#: ../../library/multiprocessing.rst:1620
#: ../../library/multiprocessing.rst:1710
#: ../../library/multiprocessing.rst:1725
msgid "Note that *lock* is a keyword-only argument."
msgstr "Observera att *lock* är ett argument som endast gäller nyckelord."

#: ../../library/multiprocessing.rst:1624
msgid ""
"Return a ctypes array allocated from shared memory.  By default the return "
"value is actually a synchronized wrapper for the array."
msgstr ""
"Returnerar en ctypes-array som allokerats från delat minne.  Som standard är "
"returvärdet faktiskt ett synkroniserat omslag för arrayen."

#: ../../library/multiprocessing.rst:1627
msgid ""
"*typecode_or_type* determines the type of the elements of the returned "
"array: it is either a ctypes type or a one character typecode of the kind "
"used by the :mod:`array` module.  If *size_or_initializer* is an integer, "
"then it determines the length of the array, and the array will be initially "
"zeroed. Otherwise, *size_or_initializer* is a sequence which is used to "
"initialize the array and whose length determines the length of the array."
msgstr ""
"*typecode_or_type* bestämmer typen av element i den returnerade matrisen: "
"det är antingen en ctypes-typ eller en typkod med ett tecken av den typ som "
"används av modulen :mod:`array`.  Om *size_or_initializer* är ett heltal "
"bestämmer det längden på arrayen, och arrayen nollställs initialt. I annat "
"fall är *size_or_initializer* en sekvens som används för att initiera "
"arrayen och vars längd bestämmer arrayens längd."

#: ../../library/multiprocessing.rst:1634
msgid ""
"If *lock* is ``True`` (the default) then a new lock object is created to "
"synchronize access to the value.  If *lock* is a :class:`Lock` or :class:"
"`RLock` object then that will be used to synchronize access to the value.  "
"If *lock* is ``False`` then access to the returned object will not be "
"automatically protected by a lock, so it will not necessarily be \"process-"
"safe\"."
msgstr ""
"Om *lock* är ``True`` (standard) skapas ett nytt låsobjekt för att "
"synkronisera åtkomsten till värdet.  Om *lock* är ett :class:`Lock`- eller :"
"class:`RLock`-objekt kommer det att användas för att synkronisera åtkomst "
"till värdet.  Om *lock* är ``False`` kommer åtkomsten till det returnerade "
"objektet inte automatiskt att skyddas av ett lås, så det är inte "
"nödvändigtvis \"processäkert\"."

#: ../../library/multiprocessing.rst:1641
msgid "Note that *lock* is a keyword only argument."
msgstr "Observera att *lock* endast är ett nyckelordsargument."

#: ../../library/multiprocessing.rst:1643
msgid ""
"Note that an array of :data:`ctypes.c_char` has *value* and *raw* attributes "
"which allow one to use it to store and retrieve strings."
msgstr ""
"Observera att en array av :data:`ctypes.c_char` har attributen *value* och "
"*raw* som gör att man kan använda den för att lagra och hämta strängar."

#: ../../library/multiprocessing.rst:1648
msgid "The :mod:`multiprocessing.sharedctypes` module"
msgstr ""
"Modulen :mod:`multiprocessing.sharedctypes` (multiprocessing.sharedctypes)"

#: ../../library/multiprocessing.rst:1653
msgid ""
"The :mod:`multiprocessing.sharedctypes` module provides functions for "
"allocating :mod:`ctypes` objects from shared memory which can be inherited "
"by child processes."
msgstr ""
"Modulen :mod:`multiprocessing.sharedctypes` tillhandahåller funktioner för "
"allokering av :mod:`ctypes`-objekt från delat minne som kan ärvas av "
"underordnade processer."

#: ../../library/multiprocessing.rst:1659
msgid ""
"Although it is possible to store a pointer in shared memory remember that "
"this will refer to a location in the address space of a specific process. "
"However, the pointer is quite likely to be invalid in the context of a "
"second process and trying to dereference the pointer from the second process "
"may cause a crash."
msgstr ""
"Även om det är möjligt att lagra en pekare i ett delat minne bör man komma "
"ihåg att den kommer att referera till en plats i adressrymden för en "
"specifik process. Det är dock mycket troligt att pekaren är ogiltig i en "
"andra process och om man försöker dereferentiera pekaren från den andra "
"processen kan det leda till en krasch."

#: ../../library/multiprocessing.rst:1667
msgid "Return a ctypes array allocated from shared memory."
msgstr "Returnerar en ctypes-array som allokerats från delat minne."

#: ../../library/multiprocessing.rst:1669
msgid ""
"*typecode_or_type* determines the type of the elements of the returned "
"array: it is either a ctypes type or a one character typecode of the kind "
"used by the :mod:`array` module.  If *size_or_initializer* is an integer "
"then it determines the length of the array, and the array will be initially "
"zeroed. Otherwise *size_or_initializer* is a sequence which is used to "
"initialize the array and whose length determines the length of the array."
msgstr ""
"*typecode_or_type* bestämmer typen av element i den returnerade matrisen: "
"det är antingen en ctypes-typ eller en typkod med ett tecken av den typ som "
"används av modulen :mod:`array`.  Om *size_or_initializer* är ett heltal "
"bestämmer det längden på arrayen, och arrayen nollställs initialt. Annars är "
"*size_or_initializer* en sekvens som används för att initiera arrayen och "
"vars längd bestämmer arrayens längd."

#: ../../library/multiprocessing.rst:1676
msgid ""
"Note that setting and getting an element is potentially non-atomic -- use :"
"func:`Array` instead to make sure that access is automatically synchronized "
"using a lock."
msgstr ""
"Observera att det kan vara icke-atomiskt att sätta och hämta ett element - "
"använd :func:`Array` istället för att se till att åtkomsten automatiskt "
"synkroniseras med hjälp av ett lås."

#: ../../library/multiprocessing.rst:1682
msgid "Return a ctypes object allocated from shared memory."
msgstr "Returnerar ett ctypes-objekt som allokerats från delat minne."

#: ../../library/multiprocessing.rst:1688
msgid ""
"Note that setting and getting the value is potentially non-atomic -- use :"
"func:`Value` instead to make sure that access is automatically synchronized "
"using a lock."
msgstr ""
"Observera att inställning och hämtning av värdet potentiellt är icke-"
"atomiskt -- använd :func:`Value` istället för att se till att åtkomsten "
"automatiskt synkroniseras med hjälp av ett lås."

#: ../../library/multiprocessing.rst:1692
msgid ""
"Note that an array of :data:`ctypes.c_char` has ``value`` and ``raw`` "
"attributes which allow one to use it to store and retrieve strings -- see "
"documentation for :mod:`ctypes`."
msgstr ""
"Observera att en array av :data:`ctypes.c_char` har attributen ``value`` och "
"``raw`` som gör att man kan använda den för att lagra och hämta strängar -- "
"se dokumentation för :mod:`ctypes`."

#: ../../library/multiprocessing.rst:1698
msgid ""
"The same as :func:`RawArray` except that depending on the value of *lock* a "
"process-safe synchronization wrapper may be returned instead of a raw ctypes "
"array."
msgstr ""
"Samma sak som :func:`RawArray` förutom att beroende på värdet av *lock* kan "
"en processäker synkroniseringsomslag returneras istället för en rå ctypes-"
"array."

#: ../../library/multiprocessing.rst:1702
#: ../../library/multiprocessing.rst:1718
msgid ""
"If *lock* is ``True`` (the default) then a new lock object is created to "
"synchronize access to the value.  If *lock* is a :class:`~multiprocessing."
"Lock` or :class:`~multiprocessing.RLock` object then that will be used to "
"synchronize access to the value.  If *lock* is ``False`` then access to the "
"returned object will not be automatically protected by a lock, so it will "
"not necessarily be \"process-safe\"."
msgstr ""
"Om *lock* är ``True`` (standard) skapas ett nytt låsobjekt för att "
"synkronisera åtkomst till värdet.  Om *lock* är ett :class:`~multiprocessing."
"Lock`- eller :class:`~multiprocessing.RLock`-objekt kommer det att användas "
"för att synkronisera åtkomst till värdet.  Om *lock* är ``False`` kommer "
"åtkomst till det returnerade objektet inte automatiskt att skyddas av ett "
"lås, så det kommer inte nödvändigtvis att vara \"processäkert\"."

#: ../../library/multiprocessing.rst:1714
msgid ""
"The same as :func:`RawValue` except that depending on the value of *lock* a "
"process-safe synchronization wrapper may be returned instead of a raw ctypes "
"object."
msgstr ""
"Samma sak som :func:`RawValue` förutom att beroende på värdet av *lock* kan "
"en processäker synkroniseringsomslag returneras istället för ett rått ctypes-"
"objekt."

#: ../../library/multiprocessing.rst:1729
msgid ""
"Return a ctypes object allocated from shared memory which is a copy of the "
"ctypes object *obj*."
msgstr ""
"Returnerar ett ctypes-objekt som allokerats från delat minne och som är en "
"kopia av ctypes-objektet *obj*."

#: ../../library/multiprocessing.rst:1734
msgid ""
"Return a process-safe wrapper object for a ctypes object which uses *lock* "
"to synchronize access.  If *lock* is ``None`` (the default) then a :class:"
"`multiprocessing.RLock` object is created automatically."
msgstr ""
"Returnerar ett processäkert omslagsobjekt för ett ctypes-objekt som använder "
"*lock* för att synkronisera åtkomst.  Om *lock* är ``None`` (standard) så "
"skapas ett :class:`multiprocessing.RLock`-objekt automatiskt."

#: ../../library/multiprocessing.rst:1738
msgid ""
"A synchronized wrapper will have two methods in addition to those of the "
"object it wraps: :meth:`get_obj` returns the wrapped object and :meth:"
"`get_lock` returns the lock object used for synchronization."
msgstr ""
"En synkroniserad wrapper har två metoder utöver metoderna för det objekt som "
"den omsluter: :meth:`get_obj` returnerar det omslutna objektet och :meth:"
"`get_lock` returnerar det låsobjekt som används för synkronisering."

#: ../../library/multiprocessing.rst:1742
msgid ""
"Note that accessing the ctypes object through the wrapper can be a lot "
"slower than accessing the raw ctypes object."
msgstr ""
"Observera att det kan vara mycket långsammare att komma åt ctypes-objektet "
"via omslaget än att komma åt det obearbetade ctypes-objektet."

#: ../../library/multiprocessing.rst:1745
msgid "Synchronized objects support the :term:`context manager` protocol."
msgstr "Synkroniserade objekt stöder protokollet :term:`context manager`."

#: ../../library/multiprocessing.rst:1749
msgid ""
"The table below compares the syntax for creating shared ctypes objects from "
"shared memory with the normal ctypes syntax.  (In the table ``MyStruct`` is "
"some subclass of :class:`ctypes.Structure`.)"
msgstr ""
"I tabellen nedan jämförs syntaxen för att skapa delade ctypes-objekt från "
"delat minne med den normala ctypes-syntaxen.  (I tabellen är ``MyStruct`` en "
"underklass till :class:`ctypes.Structure`.)"

#: ../../library/multiprocessing.rst:1754
msgid "ctypes"
msgstr "ctyper"

#: ../../library/multiprocessing.rst:1754
msgid "sharedctypes using type"
msgstr "sharedctypes använder typ"

#: ../../library/multiprocessing.rst:1754
msgid "sharedctypes using typecode"
msgstr "delade typer med hjälp av typkod"

#: ../../library/multiprocessing.rst:1756
msgid "c_double(2.4)"
msgstr "c_double(2,4)"

#: ../../library/multiprocessing.rst:1756
msgid "RawValue(c_double, 2.4)"
msgstr "RawValue(c_double, 2,4)"

#: ../../library/multiprocessing.rst:1756
msgid "RawValue('d', 2.4)"
msgstr "RawValue('d', 2.4)"

#: ../../library/multiprocessing.rst:1757
msgid "MyStruct(4, 6)"
msgstr "MyStruct(4, 6)"

#: ../../library/multiprocessing.rst:1757
msgid "RawValue(MyStruct, 4, 6)"
msgstr "RawValue(MyStruct, 4, 6)"

#: ../../library/multiprocessing.rst:1758
msgid "(c_short * 7)()"
msgstr "(c_short * 7)()"

#: ../../library/multiprocessing.rst:1758
msgid "RawArray(c_short, 7)"
msgstr "RawArray(c_short, 7)"

#: ../../library/multiprocessing.rst:1758
msgid "RawArray('h', 7)"
msgstr "RawArray('h', 7)"

#: ../../library/multiprocessing.rst:1759
msgid "(c_int * 3)(9, 2, 8)"
msgstr "(c_int * 3)(9, 2, 8)"

#: ../../library/multiprocessing.rst:1759
msgid "RawArray(c_int, (9, 2, 8))"
msgstr "RawArray(c_int, (9, 2, 8))"

#: ../../library/multiprocessing.rst:1759
msgid "RawArray('i', (9, 2, 8))"
msgstr "RawArray(\"i\", (9, 2, 8))"

#: ../../library/multiprocessing.rst:1763
msgid ""
"Below is an example where a number of ctypes objects are modified by a child "
"process::"
msgstr ""
"Nedan följer ett exempel där ett antal ctypes-objekt ändras av en "
"underordnad process::"

#: ../../library/multiprocessing.rst:1766
msgid ""
"from multiprocessing import Process, Lock\n"
"from multiprocessing.sharedctypes import Value, Array\n"
"from ctypes import Structure, c_double\n"
"\n"
"class Point(Structure):\n"
"    _fields_ = [('x', c_double), ('y', c_double)]\n"
"\n"
"def modify(n, x, s, A):\n"
"    n.value **= 2\n"
"    x.value **= 2\n"
"    s.value = s.value.upper()\n"
"    for a in A:\n"
"        a.x **= 2\n"
"        a.y **= 2\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"\n"
"    n = Value('i', 7)\n"
"    x = Value(c_double, 1.0/3.0, lock=False)\n"
"    s = Array('c', b'hello world', lock=lock)\n"
"    A = Array(Point, [(1.875,-6.25), (-5.75,2.0), (2.375,9.5)], lock=lock)\n"
"\n"
"    p = Process(target=modify, args=(n, x, s, A))\n"
"    p.start()\n"
"    p.join()\n"
"\n"
"    print(n.value)\n"
"    print(x.value)\n"
"    print(s.value)\n"
"    print([(a.x, a.y) for a in A])"
msgstr ""
"från multiprocessing importera Process, Lock\n"
"från multiprocessing.sharedctypes importera Value, Array\n"
"från ctypes import Struktur, c_double\n"
"\n"
"klass Punkt(Struktur):\n"
"    _fields_ = [('x', c_double), ('y', c_double)]\n"
"\n"
"def modify(n, x, s, A):\n"
"    n.värde **= 2\n"
"    x.värde **= 2\n"
"    s.värde = s.värde.upper()\n"
"    för a i A:\n"
"        a.x **= 2\n"
"        a.y **= 2\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"\n"
"    n = Värde('i', 7)\n"
"    x = Värde(c_double, 1,0/3,0, lock=False)\n"
"    s = Array('c', b'hello world', lock=lock)\n"
"    A = Array(Point, [(1,875,-6,25), (-5,75,2,0), (2,375,9,5)], lock=lock)\n"
"\n"
"    p = Process(mål=modifiera, args=(n, x, s, A))\n"
"    p.start()\n"
"    p.join()\n"
"\n"
"    print(n.värde)\n"
"    print(x.värde)\n"
"    print(s.värde)\n"
"    print([(a.x, a.y) för a i A])"

#: ../../library/multiprocessing.rst:1801
msgid "The results printed are ::"
msgstr "De resultat som skrivs ut är ::"

#: ../../library/multiprocessing.rst:1803
msgid ""
"49\n"
"0.1111111111111111\n"
"HELLO WORLD\n"
"[(3.515625, 39.0625), (33.0625, 4.0), (5.640625, 90.25)]"
msgstr ""
"49\n"
"0.1111111111111111\n"
"HALLÅ VÄRLDEN\n"
"[(3.515625, 39.0625), (33.0625, 4.0), (5.640625, 90.25)]"

#: ../../library/multiprocessing.rst:1814
msgid "Managers"
msgstr "Ansvariga"

#: ../../library/multiprocessing.rst:1816
msgid ""
"Managers provide a way to create data which can be shared between different "
"processes, including sharing over a network between processes running on "
"different machines. A manager object controls a server process which manages "
"*shared objects*.  Other processes can access the shared objects by using "
"proxies."
msgstr ""
"Managers är ett sätt att skapa data som kan delas mellan olika processer, "
"inklusive delning över ett nätverk mellan processer som körs på olika "
"maskiner. Ett manager-objekt kontrollerar en serverprocess som hanterar "
"*delade objekt*.  Andra processer kan komma åt de delade objekten genom att "
"använda proxies."

#: ../../library/multiprocessing.rst:1825
msgid ""
"Returns a started :class:`~multiprocessing.managers.SyncManager` object "
"which can be used for sharing objects between processes.  The returned "
"manager object corresponds to a spawned child process and has methods which "
"will create shared objects and return corresponding proxies."
msgstr ""
"Returnerar ett startat :class:`~multiprocessing.managers.SyncManager`-objekt "
"som kan användas för att dela objekt mellan processer.  Det returnerade "
"manager-objektet motsvarar en skapad underordnad process och har metoder som "
"skapar delade objekt och returnerar motsvarande proxyer."

#: ../../library/multiprocessing.rst:1833
msgid ""
"Manager processes will be shutdown as soon as they are garbage collected or "
"their parent process exits.  The manager classes are defined in the :mod:"
"`multiprocessing.managers` module:"
msgstr ""
"Managerprocesser kommer att stängas av så snart som de är garbage collected "
"eller deras överordnade process avslutas.  Managerklasserna är definierade i "
"modulen :mod:`multiprocessing.managers`:"

#: ../../library/multiprocessing.rst:1839
msgid "Create a BaseManager object."
msgstr "Skapa ett BaseManager-objekt."

#: ../../library/multiprocessing.rst:1841
msgid ""
"Once created one should call :meth:`start` or ``get_server()."
"serve_forever()`` to ensure that the manager object refers to a started "
"manager process."
msgstr ""
"När den har skapats bör man anropa :meth:`start` eller ``get_server()."
"serve_forever()`` för att säkerställa att managerobjektet refererar till en "
"startad managerprocess."

#: ../../library/multiprocessing.rst:1844
msgid ""
"*address* is the address on which the manager process listens for new "
"connections.  If *address* is ``None`` then an arbitrary one is chosen."
msgstr ""
"*address* är den adress på vilken manager-processen lyssnar efter nya "
"anslutningar.  Om *address* är ``None`` så väljs en godtycklig adress."

#: ../../library/multiprocessing.rst:1847
msgid ""
"*authkey* is the authentication key which will be used to check the validity "
"of incoming connections to the server process.  If *authkey* is ``None`` "
"then ``current_process().authkey`` is used. Otherwise *authkey* is used and "
"it must be a byte string."
msgstr ""
"*authkey* är autentiseringsnyckeln som kommer att användas för att "
"kontrollera giltigheten av inkommande anslutningar till serverprocessen.  Om "
"*authkey* är ``None`` används ``current_process().authkey``. Annars används "
"*authkey* och den måste vara en byte-sträng."

#: ../../library/multiprocessing.rst:1852
msgid ""
"*serializer* must be ``'pickle'`` (use :mod:`pickle` serialization) or "
"``'xmlrpclib'`` (use :mod:`xmlrpc.client` serialization)."
msgstr ""
"*serializer* måste vara ``'pickle'`` (använd :mod:`pickle` serialisering) "
"eller ``'xmlrpclib'`` (använd :mod:`xmlrpc.client` serialisering)."

#: ../../library/multiprocessing.rst:1855
msgid ""
"*ctx* is a context object, or ``None`` (use the current context). See the :"
"func:`get_context` function."
msgstr ""
"*ctx* är ett kontextobjekt, eller ``None`` (använd aktuell kontext). Se "
"funktionen :func:`get_context`."

#: ../../library/multiprocessing.rst:1858
msgid ""
"*shutdown_timeout* is a timeout in seconds used to wait until the process "
"used by the manager completes in the :meth:`shutdown` method. If the "
"shutdown times out, the process is terminated. If terminating the process "
"also times out, the process is killed."
msgstr ""
"*shutdown_timeout* är en timeout i sekunder som används för att vänta tills "
"den process som används av förvaltaren avslutas i metoden :meth:`shutdown`. "
"Om tiden för nedstängning går ut avslutas processen. Om det också tar tid "
"att avsluta processen dödas processen."

#: ../../library/multiprocessing.rst:1863
msgid "Added the *shutdown_timeout* parameter."
msgstr "Parametern *shutdown_timeout* har lagts till."

#: ../../library/multiprocessing.rst:1868
msgid ""
"Start a subprocess to start the manager.  If *initializer* is not ``None`` "
"then the subprocess will call ``initializer(*initargs)`` when it starts."
msgstr ""
"Starta en underprocess för att starta hanteraren.  Om *initializer* inte är "
"``None`` kommer underprocessen att anropa ``initializer(*initargs)`` när den "
"startar."

#: ../../library/multiprocessing.rst:1873
msgid ""
"Returns a :class:`Server` object which represents the actual server under "
"the control of the Manager. The :class:`Server` object supports the :meth:"
"`serve_forever` method::"
msgstr ""
"Returnerar ett :class:`Server`-objekt som representerar den faktiska servern "
"under Managerns kontroll. Objektet :class:`Server` har stöd för metoden :"
"meth:`serve_forever`::"

#: ../../library/multiprocessing.rst:1877
msgid ""
">>> from multiprocessing.managers import BaseManager\n"
">>> manager = BaseManager(address=('', 50000), authkey=b'abc')\n"
">>> server = manager.get_server()\n"
">>> server.serve_forever()"
msgstr ""
">>> from multiprocessing.managers import BaseManager\n"
">>> manager = BaseManager(adress=('', 50000), authkey=b'abc')\n"
">>> server = manager.get_server()\n"
">>> server.serve_forever()"

#: ../../library/multiprocessing.rst:1882
msgid ":class:`Server` additionally has an :attr:`address` attribute."
msgstr ":class:`Server` har dessutom ett attribut :attr:`address`."

#: ../../library/multiprocessing.rst:1886
msgid "Connect a local manager object to a remote manager process::"
msgstr "Anslut ett lokalt managerobjekt till en fjärrmanagerprocess::"

#: ../../library/multiprocessing.rst:1888
msgid ""
">>> from multiprocessing.managers import BaseManager\n"
">>> m = BaseManager(address=('127.0.0.1', 50000), authkey=b'abc')\n"
">>> m.connect()"
msgstr ""
">>> from multiprocessing.managers import BaseManager\n"
">>> m = BaseManager(adress=('127.0.0.1', 50000), authkey=b'abc')\n"
">>> m.connect()"

#: ../../library/multiprocessing.rst:1894
msgid ""
"Stop the process used by the manager.  This is only available if :meth:"
"`start` has been used to start the server process."
msgstr ""
"Stoppar den process som används av hanteraren.  Detta är endast tillgängligt "
"om :meth:`start` har använts för att starta serverprocessen."

#: ../../library/multiprocessing.rst:1897
msgid "This can be called multiple times."
msgstr "Detta kan anropas flera gånger."

#: ../../library/multiprocessing.rst:1901
msgid ""
"A classmethod which can be used for registering a type or callable with the "
"manager class."
msgstr ""
"En klassmetod som kan användas för att registrera en typ eller en anropsbar "
"kod hos managerklassen."

#: ../../library/multiprocessing.rst:1904
msgid ""
"*typeid* is a \"type identifier\" which is used to identify a particular "
"type of shared object.  This must be a string."
msgstr ""
"*typeid* är en \"typidentifierare\" som används för att identifiera en viss "
"typ av delat objekt.  Detta måste vara en sträng."

#: ../../library/multiprocessing.rst:1907
msgid ""
"*callable* is a callable used for creating objects for this type "
"identifier.  If a manager instance will be connected to the server using "
"the :meth:`connect` method, or if the *create_method* argument is ``False`` "
"then this can be left as ``None``."
msgstr ""
"*callable* är en callable som används för att skapa objekt för denna "
"typidentifierare.  Om en manager-instans kommer att anslutas till servern "
"med :meth:`connect`-metoden, eller om *create_method*-argumentet är "
"``False``, kan detta lämnas som ``None``."

#: ../../library/multiprocessing.rst:1913
msgid ""
"*proxytype* is a subclass of :class:`BaseProxy` which is used to create "
"proxies for shared objects with this *typeid*.  If ``None`` then a proxy "
"class is created automatically."
msgstr ""
"*proxytype* är en underklass till :class:`BaseProxy` som används för att "
"skapa proxy för delade objekt med detta *typeid*.  Om ``None`` så skapas en "
"proxyklass automatiskt."

#: ../../library/multiprocessing.rst:1917
msgid ""
"*exposed* is used to specify a sequence of method names which proxies for "
"this typeid should be allowed to access using :meth:`BaseProxy."
"_callmethod`.  (If *exposed* is ``None`` then :attr:`proxytype._exposed_` is "
"used instead if it exists.)  In the case where no exposed list is specified, "
"all \"public methods\" of the shared object will be accessible.  (Here a "
"\"public method\" means any attribute which has a :meth:`~object.__call__` "
"method and whose name does not begin with ``'_'``.)"
msgstr ""
"*exposed* används för att ange en sekvens av metodnamn som proxyer för detta "
"typeid ska få tillgång till med hjälp av :meth:`BaseProxy._callmethod`.  (Om "
"*exposed* är ``None`` används istället :attr:`proxytype._exposed_` om den "
"finns)  Om ingen exponerad lista anges kommer alla \"offentliga metoder\" i "
"det delade objektet att vara tillgängliga.  (Här betyder en \"publik metod\" "
"alla attribut som har en :meth:`~object.__call__`-metod och vars namn inte "
"börjar med ``'_'``)"

#: ../../library/multiprocessing.rst:1926
msgid ""
"*method_to_typeid* is a mapping used to specify the return type of those "
"exposed methods which should return a proxy.  It maps method names to typeid "
"strings.  (If *method_to_typeid* is ``None`` then :attr:`proxytype."
"_method_to_typeid_` is used instead if it exists.)  If a method's name is "
"not a key of this mapping or if the mapping is ``None`` then the object "
"returned by the method will be copied by value."
msgstr ""
"*method_to_typeid* är en mappning som används för att ange returtypen för de "
"exponerade metoder som ska returnera en proxy.  Den mappar metodnamn till "
"typid-strängar.  (Om *method_to_typeid* är ``None`` används istället :attr:"
"`proxytype._method_to_typeid_` om den finns)  Om en metods namn inte är en "
"nyckel i denna mappning eller om mappningen är ``None`` kommer det objekt "
"som returneras av metoden att kopieras med värde."

#: ../../library/multiprocessing.rst:1933
msgid ""
"*create_method* determines whether a method should be created with name "
"*typeid* which can be used to tell the server process to create a new shared "
"object and return a proxy for it.  By default it is ``True``."
msgstr ""
"*create_method* avgör om en metod ska skapas med namnet *typeid* som kan "
"användas för att tala om för serverprocessen att den ska skapa ett nytt "
"delat objekt och returnera en proxy för det.  Som standard är det ``True``."

#: ../../library/multiprocessing.rst:1937
msgid ":class:`BaseManager` instances also have one read-only property:"
msgstr ":class:`BaseManager`-instanser har också en skrivskyddad egenskap:"

#: ../../library/multiprocessing.rst:1941
msgid "The address used by the manager."
msgstr "Den adress som används av chefen."

#: ../../library/multiprocessing.rst:1943
msgid ""
"Manager objects support the context management protocol -- see :ref:"
"`typecontextmanager`.  :meth:`~contextmanager.__enter__` starts the server "
"process (if it has not already started) and then returns the manager "
"object.  :meth:`~contextmanager.__exit__` calls :meth:`shutdown`."
msgstr ""
"Manager-objekt stöder kontexthanteringsprotokollet -- se :ref:"
"`typecontextmanager`. :meth:`~contextmanager.__enter__` startar "
"serverprocessen (om den inte redan har startat) och returnerar sedan manager-"
"objektet. :meth:`~contextmanager.__exit__` anropar :meth:`shutdown`."

#: ../../library/multiprocessing.rst:1949
msgid ""
"In previous versions :meth:`~contextmanager.__enter__` did not start the "
"manager's server process if it was not already started."
msgstr ""
"I tidigare versioner :meth:`~contextmanager.__enter__` startade inte "
"managerns serverprocess om den inte redan var startad."

#: ../../library/multiprocessing.rst:1954
msgid ""
"A subclass of :class:`BaseManager` which can be used for the synchronization "
"of processes.  Objects of this type are returned by :func:`multiprocessing."
"Manager`."
msgstr ""
"En underklass till :class:`BaseManager` som kan användas för synkronisering "
"av processer.  Objekt av denna typ returneras av :func:`multiprocessing."
"Manager`."

#: ../../library/multiprocessing.rst:1958
msgid ""
"Its methods create and return :ref:`multiprocessing-proxy_objects` for a "
"number of commonly used data types to be synchronized across processes. This "
"notably includes shared lists and dictionaries."
msgstr ""
"Dess metoder skapar och returnerar :ref:`multiprocessing-proxy_objects` för "
"ett antal vanligt förekommande datatyper som ska synkroniseras mellan "
"processer. Detta inkluderar särskilt delade listor och lexikon."

#: ../../library/multiprocessing.rst:1964
msgid ""
"Create a shared :class:`threading.Barrier` object and return a proxy for it."
msgstr ""
"Skapa ett delat :class:`threading.Barrier'-objekt och returnera en proxy för "
"det."

#: ../../library/multiprocessing.rst:1971
msgid ""
"Create a shared :class:`threading.BoundedSemaphore` object and return a "
"proxy for it."
msgstr ""
"Skapa ett delat :class:`threading.BoundedSemaphore'-objekt och returnera en "
"proxy för det."

#: ../../library/multiprocessing.rst:1976
msgid ""
"Create a shared :class:`threading.Condition` object and return a proxy for "
"it."
msgstr ""
"Skapa ett delat :class:`threading.Condition`-objekt och returnera en proxy "
"för det."

#: ../../library/multiprocessing.rst:1979
msgid ""
"If *lock* is supplied then it should be a proxy for a :class:`threading."
"Lock` or :class:`threading.RLock` object."
msgstr ""
"Om *lock* anges bör det vara en proxy för ett :class:`threading.Lock`- "
"eller :class:`threading.RLock`-objekt."

#: ../../library/multiprocessing.rst:1987
msgid ""
"Create a shared :class:`threading.Event` object and return a proxy for it."
msgstr ""
"Skapa ett delat :class:`threading.Event'-objekt och returnera en proxy för "
"det."

#: ../../library/multiprocessing.rst:1991
msgid ""
"Create a shared :class:`threading.Lock` object and return a proxy for it."
msgstr ""
"Skapa ett delat :class:`threading.Lock`-objekt och returnera en proxy för "
"det."

#: ../../library/multiprocessing.rst:1995
msgid "Create a shared :class:`Namespace` object and return a proxy for it."
msgstr ""
"Skapa ett delat :class:`Namespace`-objekt och returnera en proxy för det."

#: ../../library/multiprocessing.rst:1999
msgid "Create a shared :class:`queue.Queue` object and return a proxy for it."
msgstr ""
"Skapa ett delat :class:`queue.Queue'-objekt och returnera en proxy för det."

#: ../../library/multiprocessing.rst:2003
msgid ""
"Create a shared :class:`threading.RLock` object and return a proxy for it."
msgstr ""
"Skapa ett delat :class:`threading.RLock`-objekt och returnera en proxy för "
"det."

#: ../../library/multiprocessing.rst:2007
msgid ""
"Create a shared :class:`threading.Semaphore` object and return a proxy for "
"it."
msgstr ""
"Skapa ett delat :class:`threading.Semaphore'-objekt och returnera en proxy "
"för det."

#: ../../library/multiprocessing.rst:2012
msgid "Create an array and return a proxy for it."
msgstr "Skapa en array och returnera en proxy för den."

#: ../../library/multiprocessing.rst:2016
msgid ""
"Create an object with a writable ``value`` attribute and return a proxy for "
"it."
msgstr ""
"Skapa ett objekt med ett skrivbart ``value``-attribut och returnera en proxy "
"för det."

#: ../../library/multiprocessing.rst:2023
msgid "Create a shared :class:`dict` object and return a proxy for it."
msgstr "Skapa ett delat :class:`dict`-objekt och returnera en proxy för det."

#: ../../library/multiprocessing.rst:2028
msgid "Create a shared :class:`list` object and return a proxy for it."
msgstr "Skapa ett delat :class:`list`-objekt och returnera en proxy för det."

#: ../../library/multiprocessing.rst:2034
msgid "Create a shared :class:`set` object and return a proxy for it."
msgstr "Skapa ett delat :class:`set`-objekt och returnera en proxy för det."

#: ../../library/multiprocessing.rst:2036
msgid ":class:`set` support was added."
msgstr "stöd för :class:`set` har lagts till."

#: ../../library/multiprocessing.rst:2039
msgid ""
"Shared objects are capable of being nested.  For example, a shared container "
"object such as a shared list can contain other shared objects which will all "
"be managed and synchronized by the :class:`SyncManager`."
msgstr ""
"Delade objekt kan vara nästlade.  Ett delat containerobjekt, t.ex. en delad "
"lista, kan innehålla andra delade objekt som alla hanteras och synkroniseras "
"av :class:`SyncManager`."

#: ../../library/multiprocessing.rst:2046
msgid "A type that can register with :class:`SyncManager`."
msgstr "En typ som kan registreras med :class:`SyncManager`."

#: ../../library/multiprocessing.rst:2048
msgid ""
"A namespace object has no public methods, but does have writable attributes. "
"Its representation shows the values of its attributes."
msgstr ""
"Ett namespace-objekt har inga publika metoder, men har skrivbara attribut. "
"Dess representation visar värdena för dess attribut."

#: ../../library/multiprocessing.rst:2051
msgid ""
"However, when using a proxy for a namespace object, an attribute beginning "
"with ``'_'`` will be an attribute of the proxy and not an attribute of the "
"referent:"
msgstr ""
"När man använder en proxy för ett namnrymdsobjekt kommer dock ett attribut "
"som börjar med ``'_'`` att vara ett attribut för proxyn och inte ett "
"attribut för referenten:"

#: ../../library/multiprocessing.rst:2055
msgid ""
">>> mp_context = multiprocessing.get_context('spawn')\n"
">>> manager = mp_context.Manager()\n"
">>> Global = manager.Namespace()\n"
">>> Global.x = 10\n"
">>> Global.y = 'hello'\n"
">>> Global._z = 12.3    # this is an attribute of the proxy\n"
">>> print(Global)\n"
"Namespace(x=10, y='hello')"
msgstr ""
">>> mp_context = multiprocessing.get_context('spawn')\n"
">>> manager = mp_context.manager()\n"
">>> Global = manager.Namespace()\n"
">>> Global.x = 10\n"
">>> Global.y = 'hallå'\n"
">>> Global._z = 12.3 # detta är ett attribut för proxyn\n"
">>> print(Global)\n"
"Namespace(x=10, y='hallå')"

#: ../../library/multiprocessing.rst:2068
msgid "Customized managers"
msgstr "Skräddarsydda chefer"

#: ../../library/multiprocessing.rst:2070
msgid ""
"To create one's own manager, one creates a subclass of :class:`BaseManager` "
"and uses the :meth:`~BaseManager.register` classmethod to register new types "
"or callables with the manager class.  For example::"
msgstr ""
"För att skapa en egen manager skapar man en subklass av :class:`BaseManager` "
"och använder klassmetoden :meth:`~BaseManager.register` för att registrera "
"nya typer eller anropbara objekt i managerklassen.  Till exempel::"

#: ../../library/multiprocessing.rst:2074
msgid ""
"from multiprocessing.managers import BaseManager\n"
"\n"
"class MathsClass:\n"
"    def add(self, x, y):\n"
"        return x + y\n"
"    def mul(self, x, y):\n"
"        return x * y\n"
"\n"
"class MyManager(BaseManager):\n"
"    pass\n"
"\n"
"MyManager.register('Maths', MathsClass)\n"
"\n"
"if __name__ == '__main__':\n"
"    with MyManager() as manager:\n"
"        maths = manager.Maths()\n"
"        print(maths.add(4, 3))         # prints 7\n"
"        print(maths.mul(7, 8))         # prints 56"
msgstr ""
"från multiprocessing.managers import BaseManager\n"
"\n"
"klass MathsClass:\n"
"    def add(self, x, y):\n"
"        returnerar x + y\n"
"    def mul(self, x, y):\n"
"        returnerar x * y\n"
"\n"
"klass MyManager(BaseManager):\n"
"    pass\n"
"\n"
"MyManager.register('Maths', MathsClass)\n"
"\n"
"if __name__ == '__main__':\n"
"    med MyManager() som manager:\n"
"        maths = manager.Maths()\n"
"        print(maths.add(4, 3))         # skriver ut 7\n"
"        print(maths.mul(7, 8))         # skriver ut 56"

#: ../../library/multiprocessing.rst:2095
msgid "Using a remote manager"
msgstr "Använda en fjärrstyrd manager"

#: ../../library/multiprocessing.rst:2097
msgid ""
"It is possible to run a manager server on one machine and have clients use "
"it from other machines (assuming that the firewalls involved allow it)."
msgstr ""
"Det är möjligt att köra en manager-server på en maskin och låta klienter "
"använda den från andra maskiner (förutsatt att de berörda brandväggarna "
"tillåter det)."

#: ../../library/multiprocessing.rst:2100
msgid ""
"Running the following commands creates a server for a single shared queue "
"which remote clients can access::"
msgstr ""
"Om du kör följande kommandon skapas en server för en enda delad kö som "
"fjärrklienter kan komma åt::"

#: ../../library/multiprocessing.rst:2103
msgid ""
">>> from multiprocessing.managers import BaseManager\n"
">>> from queue import Queue\n"
">>> queue = Queue()\n"
">>> class QueueManager(BaseManager): pass\n"
">>> QueueManager.register('get_queue', callable=lambda:queue)\n"
">>> m = QueueManager(address=('', 50000), authkey=b'abracadabra')\n"
">>> s = m.get_server()\n"
">>> s.serve_forever()"
msgstr ""
">>> från multiprocessing.managers importera BaseManager\n"
">>> från queue importera Queue\n"
">>> kö = kö()\n"
">>> class QueueManager(BaseManager): pass\n"
">>> QueueManager.register('get_queue', callable=lambda:queue)\n"
">>> m = QueueManager(adress=('', 50000), authkey=b'abracadabra')\n"
">>> s = m.hämta_server()\n"
">>> s.serve_forever()"

#: ../../library/multiprocessing.rst:2112
msgid "One client can access the server as follows::"
msgstr "En klient kan komma åt servern på följande sätt::"

#: ../../library/multiprocessing.rst:2114
msgid ""
">>> from multiprocessing.managers import BaseManager\n"
">>> class QueueManager(BaseManager): pass\n"
">>> QueueManager.register('get_queue')\n"
">>> m = QueueManager(address=('foo.bar.org', 50000), "
"authkey=b'abracadabra')\n"
">>> m.connect()\n"
">>> queue = m.get_queue()\n"
">>> queue.put('hello')"
msgstr ""
">>> from multiprocessing.managers import BaseManager\n"
">>> class QueueManager(BaseManager): pass\n"
">>> QueueManager.register('get_queue')\n"
">>> m = QueueManager(adress=('foo.bar.org', 50000), authkey=b'abracadabra')\n"
">>> m.connect()\n"
">>> kö = m.hämta_kö()\n"
">>> queue.put('hej')"

#: ../../library/multiprocessing.rst:2122
msgid "Another client can also use it::"
msgstr "En annan kund kan också använda den::"

#: ../../library/multiprocessing.rst:2124
msgid ""
">>> from multiprocessing.managers import BaseManager\n"
">>> class QueueManager(BaseManager): pass\n"
">>> QueueManager.register('get_queue')\n"
">>> m = QueueManager(address=('foo.bar.org', 50000), "
"authkey=b'abracadabra')\n"
">>> m.connect()\n"
">>> queue = m.get_queue()\n"
">>> queue.get()\n"
"'hello'"
msgstr ""
">>> from multiprocessing.managers import BaseManager\n"
">>> class QueueManager(BaseManager): pass\n"
">>> QueueManager.register('get_queue')\n"
">>> m = QueueManager(adress=('foo.bar.org', 50000), authkey=b'abracadabra')\n"
">>> m.connect()\n"
">>> kö = m.get_queue()\n"
">>> queue.get()\n"
"'hej'"

#: ../../library/multiprocessing.rst:2133
msgid ""
"Local processes can also access that queue, using the code from above on the "
"client to access it remotely::"
msgstr ""
"Lokala processer kan också komma åt den kön genom att använda koden från "
"ovan på klienten för att komma åt den på distans::"

#: ../../library/multiprocessing.rst:2136
msgid ""
">>> from multiprocessing import Process, Queue\n"
">>> from multiprocessing.managers import BaseManager\n"
">>> class Worker(Process):\n"
"...     def __init__(self, q):\n"
"...         self.q = q\n"
"...         super().__init__()\n"
"...     def run(self):\n"
"...         self.q.put('local hello')\n"
"...\n"
">>> queue = Queue()\n"
">>> w = Worker(queue)\n"
">>> w.start()\n"
">>> class QueueManager(BaseManager): pass\n"
"...\n"
">>> QueueManager.register('get_queue', callable=lambda: queue)\n"
">>> m = QueueManager(address=('', 50000), authkey=b'abracadabra')\n"
">>> s = m.get_server()\n"
">>> s.serve_forever()"
msgstr ""
">>> från multiprocessing importera Process, Kö\n"
">>> från multiprocessing.managers importera BaseManager\n"
">>> klass Arbetare(Process):\n"
"... def __init__(self, q):\n"
"... self.q = q\n"
"... super().__init__()\n"
"... def run(self):\n"
"... self.q.put('lokalt hej')\n"
"...\n"
">>> kö = kö()\n"
">>> w = arbetare(kö)\n"
">>> w.start()\n"
">>> class QueueManager(BaseManager): pass\n"
"...\n"
">>> QueueManager.register('get_queue', callable=lambda: queue)\n"
">>> m = QueueManager(adress=('', 50000), authkey=b'abracadabra')\n"
">>> s = m.hämta_server()\n"
">>> s.serve_forever()"

#: ../../library/multiprocessing.rst:2158
msgid "Proxy Objects"
msgstr "Proxy-objekt"

#: ../../library/multiprocessing.rst:2160
msgid ""
"A proxy is an object which *refers* to a shared object which lives "
"(presumably) in a different process.  The shared object is said to be the "
"*referent* of the proxy.  Multiple proxy objects may have the same referent."
msgstr ""
"En proxy är ett objekt som *refererar* till ett delat objekt som lever "
"(förmodligen) i en annan process.  Det delade objektet sägs vara proxyns "
"*referent*.  Flera proxyobjekt kan ha samma referent."

#: ../../library/multiprocessing.rst:2164
msgid ""
"A proxy object has methods which invoke corresponding methods of its "
"referent (although not every method of the referent will necessarily be "
"available through the proxy).  In this way, a proxy can be used just like "
"its referent can:"
msgstr ""
"Ett proxyobjekt har metoder som anropar motsvarande metoder hos sin referent "
"(även om inte alla metoder hos referenten nödvändigtvis är tillgängliga via "
"proxyn).  På så sätt kan en proxy användas precis som dess referent kan:"

#: ../../library/multiprocessing.rst:2168
msgid ""
">>> mp_context = multiprocessing.get_context('spawn')\n"
">>> manager = mp_context.Manager()\n"
">>> l = manager.list([i*i for i in range(10)])\n"
">>> print(l)\n"
"[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n"
">>> print(repr(l))\n"
"<ListProxy object, typeid 'list' at 0x...>\n"
">>> l[4]\n"
"16\n"
">>> l[2:5]\n"
"[4, 9, 16]"
msgstr ""
">>> mp_context = multiprocessing.get_context('spawn')\n"
">>> manager = mp_context.manager()\n"
">>> l = manager.list([i*i for i in range(10)])\n"
">>> print(l)\n"
"[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n"
">>> Skriv ut(repr(l))\n"
"<ListProxy-objekt, typid 'list' vid 0x...> >>> l[4\n"
">>> l[4]\n"
"16\n"
">>> l[2:5]\n"
"[4, 9, 16]"

#: ../../library/multiprocessing.rst:2182
msgid ""
"Notice that applying :func:`str` to a proxy will return the representation "
"of the referent, whereas applying :func:`repr` will return the "
"representation of the proxy."
msgstr ""
"Observera att om du använder :func:`str` på en proxy kommer representationen "
"av referenten att returneras, medan om du använder :func:`repr` kommer "
"representationen av proxyn att returneras."

#: ../../library/multiprocessing.rst:2186
msgid ""
"An important feature of proxy objects is that they are picklable so they can "
"be passed between processes.  As such, a referent can contain :ref:"
"`multiprocessing-proxy_objects`.  This permits nesting of these managed "
"lists, dicts, and other :ref:`multiprocessing-proxy_objects`:"
msgstr ""
"En viktig egenskap hos proxyobjekt är att de kan plockas upp så att de kan "
"skickas mellan processer.  Som sådan kan en referent innehålla :ref:"
"`multiprocessing-proxy_objects`.  Detta tillåter nestning av dessa hanterade "
"listor, dicts och andra :ref:`multiprocessing-proxy_objects`:"

#: ../../library/multiprocessing.rst:2191
msgid ""
">>> a = manager.list()\n"
">>> b = manager.list()\n"
">>> a.append(b)         # referent of a now contains referent of b\n"
">>> print(a, b)\n"
"[<ListProxy object, typeid 'list' at ...>] []\n"
">>> b.append('hello')\n"
">>> print(a[0], b)\n"
"['hello'] ['hello']"
msgstr ""
">>> a = chef.lista()\n"
">>> b = chef.lista()\n"
">>> a.append(b) # referent av a innehåller nu referent av b\n"
">>> print(a, b)\n"
"[<ListProxy-objekt, typid 'list' vid ...>] []\n"
">>> b.append('hello')\n"
">>> print(a[0], b)\n"
"['hallå'] ['hallå']"

#: ../../library/multiprocessing.rst:2202
msgid "Similarly, dict and list proxies may be nested inside one another::"
msgstr "På samma sätt kan dict- och list-proxies vara inbäddade i varandra::"

#: ../../library/multiprocessing.rst:2204
msgid ""
">>> l_outer = manager.list([ manager.dict() for i in range(2) ])\n"
">>> d_first_inner = l_outer[0]\n"
">>> d_first_inner['a'] = 1\n"
">>> d_first_inner['b'] = 2\n"
">>> l_outer[1]['c'] = 3\n"
">>> l_outer[1]['z'] = 26\n"
">>> print(l_outer[0])\n"
"{'a': 1, 'b': 2}\n"
">>> print(l_outer[1])\n"
"{'c': 3, 'z': 26}"
msgstr ""
">>> l_outer = manager.list([ manager.dict() for i in range(2) ])\n"
">>> d_first_inner = l_outer[0]\n"
">>> d_first_inner['a'] = 1\n"
">>> d_first_inner['b'] = 2\n"
">>> l_outer[1]['c'] = 3\n"
">>> l_outer[1]['z'] = 26\n"
">>> print(l_outer[0])\n"
"{'a': 1, 'b': 2}\n"
">>> print(l_outer[1])\n"
"{'c': 3, 'z': 26}"

#: ../../library/multiprocessing.rst:2215
msgid ""
"If standard (non-proxy) :class:`list` or :class:`dict` objects are contained "
"in a referent, modifications to those mutable values will not be propagated "
"through the manager because the proxy has no way of knowing when the values "
"contained within are modified.  However, storing a value in a container "
"proxy (which triggers a ``__setitem__`` on the proxy object) does propagate "
"through the manager and so to effectively modify such an item, one could re-"
"assign the modified value to the container proxy::"
msgstr ""
"Om standard (icke-proxy) :class:`list`- eller :class:`dict`-objekt finns i "
"en referent, kommer ändringar av dessa föränderliga värden inte att spridas "
"genom hanteraren eftersom proxyn inte har något sätt att veta när de värden "
"som finns i den ändras.  Att lagra ett värde i en containerproxy (vilket "
"utlöser en ``__setitem__`` på proxyobjektet) sprids dock genom hanteraren "
"och för att effektivt modifiera ett sådant objekt kan man därför tilldela "
"det modifierade värdet till containerproxyn igen::"

#: ../../library/multiprocessing.rst:2223
msgid ""
"# create a list proxy and append a mutable object (a dictionary)\n"
"lproxy = manager.list()\n"
"lproxy.append({})\n"
"# now mutate the dictionary\n"
"d = lproxy[0]\n"
"d['a'] = 1\n"
"d['b'] = 2\n"
"# at this point, the changes to d are not yet synced, but by\n"
"# updating the dictionary, the proxy is notified of the change\n"
"lproxy[0] = d"
msgstr ""
"# skapa en listproxy och lägg till ett föränderligt objekt (en ordbok)\n"
"lproxy = manager.list()\n"
"lproxy.append({})\n"
"# mutera nu ordboken\n"
"d = lproxy[0]\n"
"d['a'] = 1\n"
"d['b'] = 2\n"
"# Vid den här tidpunkten är ändringarna i d ännu inte synkroniserade, men "
"genom att\n"
"# uppdatering av ordlistan meddelas proxyn om ändringen\n"
"lproxy[0] = d"

#: ../../library/multiprocessing.rst:2234
msgid ""
"This approach is perhaps less convenient than employing nested :ref:"
"`multiprocessing-proxy_objects` for most use cases but also demonstrates a "
"level of control over the synchronization."
msgstr ""
"Detta tillvägagångssätt är kanske mindre bekvämt än att använda nästlade :"
"ref:`multiprocessing-proxy_objects` för de flesta användningsfall, men det "
"ger också en viss kontroll över synkroniseringen."

#: ../../library/multiprocessing.rst:2240
msgid ""
"The proxy types in :mod:`multiprocessing` do nothing to support comparisons "
"by value.  So, for instance, we have:"
msgstr ""
"Proxytyperna i :mod:`multiprocessing` har inget stöd för värdejämförelser.  "
"Så, till exempel, vi har:"

#: ../../library/multiprocessing.rst:2243
msgid ""
">>> manager.list([1,2,3]) == [1,2,3]\n"
"False"
msgstr ""
">>> manager.list([1,2,3]) == [1,2,3]\n"
"Falsk"

#: ../../library/multiprocessing.rst:2248
msgid ""
"One should just use a copy of the referent instead when making comparisons."
msgstr ""
"Man bör bara använda en kopia av referenten istället när man gör jämförelser."

#: ../../library/multiprocessing.rst:2252
msgid "Proxy objects are instances of subclasses of :class:`BaseProxy`."
msgstr "Proxyobjekt är instanser av underklasser till :class:`BaseProxy`."

#: ../../library/multiprocessing.rst:2256
msgid "Call and return the result of a method of the proxy's referent."
msgstr "Anropa och returnera resultatet av en metod i proxyns referent."

#: ../../library/multiprocessing.rst:2258
msgid ""
"If ``proxy`` is a proxy whose referent is ``obj`` then the expression ::"
msgstr "Om ``proxy`` är en proxy vars referent är ``obj`` så är uttrycket ::"

#: ../../library/multiprocessing.rst:2260
msgid "proxy._callmethod(methodname, args, kwds)"
msgstr "proxy._callmethod(metodnamn, args, kwds)"

#: ../../library/multiprocessing.rst:2262
msgid "will evaluate the expression ::"
msgstr "kommer att utvärdera uttrycket ::"

#: ../../library/multiprocessing.rst:2264
msgid "getattr(obj, methodname)(*args, **kwds)"
msgstr "getattr(obj, metodnamn)(*args, **kwds)"

#: ../../library/multiprocessing.rst:2266
msgid "in the manager's process."
msgstr "i chefens process."

#: ../../library/multiprocessing.rst:2268
msgid ""
"The returned value will be a copy of the result of the call or a proxy to a "
"new shared object -- see documentation for the *method_to_typeid* argument "
"of :meth:`BaseManager.register`."
msgstr ""
"Det returnerade värdet är en kopia av resultatet av anropet eller en proxy "
"till ett nytt delat objekt - se dokumentation för argumentet "
"*method_to_typeid* i :meth:`BaseManager.register`."

#: ../../library/multiprocessing.rst:2272
msgid ""
"If an exception is raised by the call, then is re-raised by :meth:"
"`_callmethod`.  If some other exception is raised in the manager's process "
"then this is converted into a :exc:`RemoteError` exception and is raised by :"
"meth:`_callmethod`."
msgstr ""
"Om ett undantag uppstår vid anropet, uppstår det på nytt genom :meth:"
"`_callmethod`.  Om något annat undantag uppstår i chefens process så "
"konverteras detta till ett :exc:`RemoteError` undantag och uppstår genom :"
"meth:`_callmethod`."

#: ../../library/multiprocessing.rst:2277
msgid ""
"Note in particular that an exception will be raised if *methodname* has not "
"been *exposed*."
msgstr ""
"Observera särskilt att ett undantag kommer att uppstå om *methodname* inte "
"har *exposed*."

#: ../../library/multiprocessing.rst:2280
msgid "An example of the usage of :meth:`_callmethod`:"
msgstr "Ett exempel på användning av :meth:`_callmethod`:"

#: ../../library/multiprocessing.rst:2282
msgid ""
">>> l = manager.list(range(10))\n"
">>> l._callmethod('__len__')\n"
"10\n"
">>> l._callmethod('__getitem__', (slice(2, 7),)) # equivalent to l[2:7]\n"
"[2, 3, 4, 5, 6]\n"
">>> l._callmethod('__getitem__', (20,))          # equivalent to l[20]\n"
"Traceback (most recent call last):\n"
"...\n"
"IndexError: list index out of range"
msgstr ""
">>> l = manager.list(intervall(10))\n"
">>> l._callmethod('__len__')\n"
"10\n"
">>> l._callmethod('__getitem__', (slice(2, 7),)) # likvärdig med l[2:7]\n"
"[2, 3, 4, 5, 6]\n"
">>> l._callmethod('__getitem__', (20,))          # motsvarar l[20]\n"
"Traceback (senaste anropet senast):\n"
"...\n"
"IndexError: listindex utanför intervallet"

#: ../../library/multiprocessing.rst:2296
msgid "Return a copy of the referent."
msgstr "Returnera en kopia av referenten."

#: ../../library/multiprocessing.rst:2298
msgid "If the referent is unpicklable then this will raise an exception."
msgstr ""
"Om referensen inte är betningsbar kommer detta att leda till ett undantag."

#: ../../library/multiprocessing.rst:2302
msgid "Return a representation of the proxy object."
msgstr "Returnerar en representation av proxyobjektet."

#: ../../library/multiprocessing.rst:2306
msgid "Return the representation of the referent."
msgstr "Returnera representationen av referenten."

#: ../../library/multiprocessing.rst:2310
msgid "Cleanup"
msgstr "Rensa upp"

#: ../../library/multiprocessing.rst:2312
msgid ""
"A proxy object uses a weakref callback so that when it gets garbage "
"collected it deregisters itself from the manager which owns its referent."
msgstr ""
"Ett proxyobjekt använder ett weakref-callback så att det avregistrerar sig "
"från den manager som äger dess referent när det samlas in."

#: ../../library/multiprocessing.rst:2315
msgid ""
"A shared object gets deleted from the manager process when there are no "
"longer any proxies referring to it."
msgstr ""
"Ett delat objekt tas bort från managerprocessen när det inte längre finns "
"några proxyer som hänvisar till det."

#: ../../library/multiprocessing.rst:2320
msgid "Process Pools"
msgstr "Processpooler"

#: ../../library/multiprocessing.rst:2325
msgid ""
"One can create a pool of processes which will carry out tasks submitted to "
"it with the :class:`Pool` class."
msgstr ""
"Med klassen :class:`Pool` kan man skapa en pool av processer som utför "
"uppgifter som skickas till den."

#: ../../library/multiprocessing.rst:2330
msgid ""
"A process pool object which controls a pool of worker processes to which "
"jobs can be submitted.  It supports asynchronous results with timeouts and "
"callbacks and has a parallel map implementation."
msgstr ""
"Ett processpoolobjekt som kontrollerar en pool av arbetsprocesser till vilka "
"jobb kan skickas.  Det stöder asynkrona resultat med timeouts och callbacks "
"och har en parallell map-implementering."

#: ../../library/multiprocessing.rst:2334
msgid ""
"*processes* is the number of worker processes to use.  If *processes* is "
"``None`` then the number returned by :func:`os.process_cpu_count` is used."
msgstr ""
"*processes* är antalet arbetsprocesser som ska användas.  Om *processes* är "
"``None`` används det antal som returneras av :func:`os.process_cpu_count`."

#: ../../library/multiprocessing.rst:2337
#: ../../library/multiprocessing.rst:2901
msgid ""
"If *initializer* is not ``None`` then each worker process will call "
"``initializer(*initargs)`` when it starts."
msgstr ""
"Om *initializer* inte är ``None`` kommer varje arbetsprocess att anropa "
"``initializer(*initargs)`` när den startar."

#: ../../library/multiprocessing.rst:2340
msgid ""
"*maxtasksperchild* is the number of tasks a worker process can complete "
"before it will exit and be replaced with a fresh worker process, to enable "
"unused resources to be freed. The default *maxtasksperchild* is ``None``, "
"which means worker processes will live as long as the pool."
msgstr ""
"*maxtasksperchild* är antalet uppgifter som en arbetsprocess kan slutföra "
"innan den avslutas och ersätts med en ny arbetsprocess, så att oanvända "
"resurser kan frigöras. Standardvärdet för *maxtasksperchild* är ``None``, "
"vilket innebär att arbetsprocesser kommer att leva lika länge som poolen."

#: ../../library/multiprocessing.rst:2345
msgid ""
"*context* can be used to specify the context used for starting the worker "
"processes.  Usually a pool is created using the function :func:"
"`multiprocessing.Pool` or the :meth:`Pool` method of a context object.  In "
"both cases *context* is set appropriately."
msgstr ""
"*context* kan användas för att ange den kontext som används för att starta "
"arbetsprocesserna.  Vanligtvis skapas en pool med hjälp av funktionen :func:"
"`multiprocessing.Pool` eller metoden :meth:`Pool` i ett context-objekt.  I "
"båda fallen anges *context* på lämpligt sätt."

#: ../../library/multiprocessing.rst:2351
msgid ""
"Note that the methods of the pool object should only be called by the "
"process which created the pool."
msgstr ""
"Observera att metoderna i poolobjektet endast ska anropas av den process som "
"skapade poolen."

#: ../../library/multiprocessing.rst:2355
msgid ""
":class:`multiprocessing.pool` objects have internal resources that need to "
"be properly managed (like any other resource) by using the pool as a context "
"manager or by calling :meth:`close` and :meth:`terminate` manually. Failure "
"to do this can lead to the process hanging on finalization."
msgstr ""
":class:`multiprocessing.pool`-objekt har interna resurser som måste hanteras "
"korrekt (som alla andra resurser) genom att använda poolen som en "
"kontexthanterare eller genom att anropa :meth:`close` och :meth:`terminate` "
"manuellt. Om detta inte görs kan det leda till att processen hänger sig när "
"den ska slutföras."

#: ../../library/multiprocessing.rst:2360
msgid ""
"Note that it is **not correct** to rely on the garbage collector to destroy "
"the pool as CPython does not assure that the finalizer of the pool will be "
"called (see :meth:`object.__del__` for more information)."
msgstr ""
"Observera att det är **inte korrekt** att förlita sig på att skräpsamlaren "
"förstör poolen eftersom CPython inte garanterar att poolens finalizer kommer "
"att anropas (se :meth:`object.__del__` för mer information)."

#: ../../library/multiprocessing.rst:2364
msgid "Added the *maxtasksperchild* parameter."
msgstr "Parametern *maxtasksperchild* har lagts till."

#: ../../library/multiprocessing.rst:2367
msgid "Added the *context* parameter."
msgstr "Parametern *context* har lagts till."

#: ../../library/multiprocessing.rst:2370
msgid ""
"*processes* uses :func:`os.process_cpu_count` by default, instead of :func:"
"`os.cpu_count`."
msgstr ""
"*processes* använder :func:`os.process_cpu_count` som standard, istället "
"för :func:`os.cpu_count`."

#: ../../library/multiprocessing.rst:2376
msgid ""
"Worker processes within a :class:`Pool` typically live for the complete "
"duration of the Pool's work queue. A frequent pattern found in other systems "
"(such as Apache, mod_wsgi, etc) to free resources held by workers is to "
"allow a worker within a pool to complete only a set amount of work before "
"being exiting, being cleaned up and a new process spawned to replace the old "
"one. The *maxtasksperchild* argument to the :class:`Pool` exposes this "
"ability to the end user."
msgstr ""
"Arbetsprocesser inom en :class:`Pool` lever normalt under hela den tid som "
"poolens arbetskö varar. Ett vanligt mönster i andra system (t.ex. Apache, "
"mod_wsgi, etc.) för att frigöra resurser som hålls av arbetare är att låta "
"en arbetare i en pool endast slutföra en viss mängd arbete innan den "
"avslutas, rensas upp och en ny process skapas för att ersätta den gamla. "
"Argumentet *maxtasksperchild* till :class:`Pool` gör denna möjlighet "
"tillgänglig för slutanvändaren."

#: ../../library/multiprocessing.rst:2386
msgid ""
"Call *func* with arguments *args* and keyword arguments *kwds*.  It blocks "
"until the result is ready. Given this blocks, :meth:`apply_async` is better "
"suited for performing work in parallel. Additionally, *func* is only "
"executed in one of the workers of the pool."
msgstr ""
"Anropa *func* med argumenten *args* och nyckelordsargumenten *kwds*.  Den "
"blockerar tills resultatet är klart. Med tanke på dessa blockeringar är :"
"meth:`apply_async` bättre lämpad för att utföra arbete parallellt. Dessutom "
"utförs *func* endast i en av poolens arbetare."

#: ../../library/multiprocessing.rst:2393
msgid ""
"A variant of the :meth:`apply` method which returns a :class:"
"`~multiprocessing.pool.AsyncResult` object."
msgstr ""
"En variant av metoden :meth:`apply` som returnerar ett :class:"
"`~multiprocessing.pool.AsyncResult`-objekt."

#: ../../library/multiprocessing.rst:2396
#: ../../library/multiprocessing.rst:2427
msgid ""
"If *callback* is specified then it should be a callable which accepts a "
"single argument.  When the result becomes ready *callback* is applied to it, "
"that is unless the call failed, in which case the *error_callback* is "
"applied instead."
msgstr ""
"Om *callback* specificeras ska det vara en callable som accepterar ett enda "
"argument.  När resultatet är klart används *callback* på det, såvida inte "
"anropet misslyckades, i vilket fall *error_callback* används i stället."

#: ../../library/multiprocessing.rst:2401
#: ../../library/multiprocessing.rst:2432
msgid ""
"If *error_callback* is specified then it should be a callable which accepts "
"a single argument.  If the target function fails, then the *error_callback* "
"is called with the exception instance."
msgstr ""
"Om *error_callback* anges bör det vara en callable som accepterar ett enda "
"argument.  Om målfunktionen misslyckas anropas *error_callback* med "
"undantagsinstansen."

#: ../../library/multiprocessing.rst:2405
#: ../../library/multiprocessing.rst:2436
msgid ""
"Callbacks should complete immediately since otherwise the thread which "
"handles the results will get blocked."
msgstr ""
"Återkallelser bör slutföras omedelbart eftersom den tråd som hanterar "
"resultaten annars blockeras."

#: ../../library/multiprocessing.rst:2410
msgid ""
"A parallel equivalent of the :func:`map` built-in function (it supports only "
"one *iterable* argument though, for multiple iterables see :meth:`starmap`). "
"It blocks until the result is ready."
msgstr ""
"En parallell motsvarighet till den inbyggda funktionen :func:`map` (den "
"stöder dock bara ett *iterable*-argument, för flera iterables se :meth:"
"`starmap`). Den blockerar tills resultatet är klart."

#: ../../library/multiprocessing.rst:2414
msgid ""
"This method chops the iterable into a number of chunks which it submits to "
"the process pool as separate tasks.  The (approximate) size of these chunks "
"can be specified by setting *chunksize* to a positive integer."
msgstr ""
"Den här metoden delar upp iterabeln i ett antal bitar som den skickar till "
"processpoolen som separata uppgifter.  Den (ungefärliga) storleken på dessa "
"bitar kan anges genom att *chunksize* sätts till ett positivt heltal."

#: ../../library/multiprocessing.rst:2418
msgid ""
"Note that it may cause high memory usage for very long iterables. Consider "
"using :meth:`imap` or :meth:`imap_unordered` with explicit *chunksize* "
"option for better efficiency."
msgstr ""
"Observera att det kan orsaka hög minnesanvändning för mycket långa "
"iterabler. Överväg att använda :meth:`imap` eller :meth:`imap_unordered` med "
"explicit *chunksize*-alternativ för bättre effektivitet."

#: ../../library/multiprocessing.rst:2424
msgid ""
"A variant of the :meth:`.map` method which returns a :class:"
"`~multiprocessing.pool.AsyncResult` object."
msgstr ""
"En variant av metoden :meth:`.map` som returnerar ett :class:"
"`~multiprocessing.pool.AsyncResult`-objekt."

#: ../../library/multiprocessing.rst:2441
msgid "A lazier version of :meth:`.map`."
msgstr "En latare version av :meth:`.map`."

#: ../../library/multiprocessing.rst:2443
msgid ""
"The *chunksize* argument is the same as the one used by the :meth:`.map` "
"method.  For very long iterables using a large value for *chunksize* can "
"make the job complete **much** faster than using the default value of ``1``."
msgstr ""
"Argumentet *chunksize* är detsamma som det som används av metoden :meth:`."
"map`.  För mycket långa iterabler kan ett stort värde för *chunksize* göra "
"att jobbet slutförs **mycket** snabbare än om standardvärdet ``1`` används."

#: ../../library/multiprocessing.rst:2448
msgid ""
"Also if *chunksize* is ``1`` then the :meth:`!next` method of the iterator "
"returned by the :meth:`imap` method has an optional *timeout* parameter: "
"``next(timeout)`` will raise :exc:`multiprocessing.TimeoutError` if the "
"result cannot be returned within *timeout* seconds."
msgstr ""
"Även om *chunksize* är ``1`` så har :meth:`!next`-metoden för iteratorn som "
"returneras av :meth:`imap`-metoden en valfri *timeout*-parameter: "
"``next(timeout)`` kommer att ge upphov till :exc:`multiprocessing."
"TimeoutError` om resultatet inte kan returneras inom *timeout* sekunder."

#: ../../library/multiprocessing.rst:2455
msgid ""
"The same as :meth:`imap` except that the ordering of the results from the "
"returned iterator should be considered arbitrary.  (Only when there is only "
"one worker process is the order guaranteed to be \"correct\".)"
msgstr ""
"Samma som :meth:`imap` förutom att ordningsföljden på resultaten från den "
"returnerade iteratorn bör betraktas som godtycklig.  (Endast när det bara "
"finns en arbetsprocess garanteras att ordningen är \"korrekt\")"

#: ../../library/multiprocessing.rst:2461
msgid ""
"Like :meth:`~multiprocessing.pool.Pool.map` except that the elements of the "
"*iterable* are expected to be iterables that are unpacked as arguments."
msgstr ""
"Som :meth:`~multiprocessing.pool.Pool.map` förutom att elementen i "
"*iterable* förväntas vara iterables som packas upp som argument."

#: ../../library/multiprocessing.rst:2465
msgid ""
"Hence an *iterable* of ``[(1,2), (3, 4)]`` results in ``[func(1,2), "
"func(3,4)]``."
msgstr ""
"Därför resulterar en *iterabel* av ``[(1,2), (3,4)]`` i ``[func(1,2), "
"func(3,4)]``."

#: ../../library/multiprocessing.rst:2472
msgid ""
"A combination of :meth:`starmap` and :meth:`map_async` that iterates over "
"*iterable* of iterables and calls *func* with the iterables unpacked. "
"Returns a result object."
msgstr ""
"En kombination av :meth:`starmap` och :meth:`map_async` som itererar över "
"*iterable* av iterabler och anropar *func* med iterablerna uppackade. "
"Returnerar ett resultatobjekt."

#: ../../library/multiprocessing.rst:2480
msgid ""
"Prevents any more tasks from being submitted to the pool.  Once all the "
"tasks have been completed the worker processes will exit."
msgstr ""
"Förhindrar att fler uppgifter skickas till poolen.  När alla uppgifter har "
"slutförts kommer arbetsprocesserna att avslutas."

#: ../../library/multiprocessing.rst:2485
msgid ""
"Stops the worker processes immediately without completing outstanding work.  "
"When the pool object is garbage collected :meth:`terminate` will be called "
"immediately."
msgstr ""
"Stoppar arbetsprocesserna omedelbart utan att slutföra utestående arbete.  "
"När poolobjektet skräpsamlas kommer :meth:`terminate` att anropas omedelbart."

#: ../../library/multiprocessing.rst:2491
msgid ""
"Wait for the worker processes to exit.  One must call :meth:`close` or :meth:"
"`terminate` before using :meth:`join`."
msgstr ""
"Vänta på att arbetsprocesserna ska avslutas.  Man måste anropa :meth:`close` "
"eller :meth:`terminate` innan man använder :meth:`join`."

#: ../../library/multiprocessing.rst:2494
msgid ""
"Pool objects now support the context management protocol -- see :ref:"
"`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the pool "
"object, and :meth:`~contextmanager.__exit__` calls :meth:`terminate`."
msgstr ""
"Poolobjekt stöder nu kontexthanteringsprotokollet -- se :ref:"
"`typecontextmanager`. :meth:`~contextmanager.__enter__` returnerar "
"poolobjektet, och :meth:`~contextmanager.__exit__` anropar :meth:`terminate`."

#: ../../library/multiprocessing.rst:2502
msgid ""
"The class of the result returned by :meth:`Pool.apply_async` and :meth:`Pool."
"map_async`."
msgstr ""
"Klassen för det resultat som returneras av :meth:`Pool.apply_async` och :"
"meth:`Pool.map_async`."

#: ../../library/multiprocessing.rst:2507
msgid ""
"Return the result when it arrives.  If *timeout* is not ``None`` and the "
"result does not arrive within *timeout* seconds then :exc:`multiprocessing."
"TimeoutError` is raised.  If the remote call raised an exception then that "
"exception will be reraised by :meth:`get`."
msgstr ""
"Returnerar resultatet när det anländer.  Om *timeout* inte är ``None`` och "
"resultatet inte anländer inom *timeout* sekunder så kommer :exc:"
"`multiprocessing.TimeoutError` att uppstå.  Om fjärranropet gav upphov till "
"ett undantag kommer detta undantag att återskapas av :meth:`get`."

#: ../../library/multiprocessing.rst:2514
msgid "Wait until the result is available or until *timeout* seconds pass."
msgstr ""
"Vänta tills resultatet är tillgängligt eller tills *timeout* sekunder har "
"passerat."

#: ../../library/multiprocessing.rst:2518
msgid "Return whether the call has completed."
msgstr "Returnerar om samtalet har slutförts."

#: ../../library/multiprocessing.rst:2522
msgid ""
"Return whether the call completed without raising an exception.  Will raise :"
"exc:`ValueError` if the result is not ready."
msgstr ""
"Returnerar om anropet slutfördes utan att ett undantag uppstod.  Kommer att "
"ge :exc:`ValueError` om resultatet inte är klart."

#: ../../library/multiprocessing.rst:2525
msgid ""
"If the result is not ready, :exc:`ValueError` is raised instead of :exc:"
"`AssertionError`."
msgstr ""
"Om resultatet inte är klart kommer :exc:`ValueError` att visas istället för :"
"exc:`AssertionError`."

#: ../../library/multiprocessing.rst:2529
msgid "The following example demonstrates the use of a pool::"
msgstr "Följande exempel visar hur en pool används::"

#: ../../library/multiprocessing.rst:2531
msgid ""
"from multiprocessing import Pool\n"
"import time\n"
"\n"
"def f(x):\n"
"    return x*x\n"
"\n"
"if __name__ == '__main__':\n"
"    with Pool(processes=4) as pool:         # start 4 worker processes\n"
"        result = pool.apply_async(f, (10,)) # evaluate \"f(10)\" "
"asynchronously in a single process\n"
"        print(result.get(timeout=1))        # prints \"100\" unless your "
"computer is *very* slow\n"
"\n"
"        print(pool.map(f, range(10)))       # prints \"[0, 1, 4,..., 81]\"\n"
"\n"
"        it = pool.imap(f, range(10))\n"
"        print(next(it))                     # prints \"0\"\n"
"        print(next(it))                     # prints \"1\"\n"
"        print(it.next(timeout=1))           # prints \"4\" unless your "
"computer is *very* slow\n"
"\n"
"        result = pool.apply_async(time.sleep, (10,))\n"
"        print(result.get(timeout=1))        # raises multiprocessing."
"TimeoutError"
msgstr ""
"från multiprocessing import Pool\n"
"importera tid\n"
"\n"
"def f(x):\n"
"    returnerar x*x\n"
"\n"
"om __name__ == '__main__':\n"
"    med Pool(processer=4) som pool:         # starta 4 arbetsprocesser\n"
"        resultat = pool.apply_async(f, (10,)) # utvärdera \"f(10)\" "
"asynkront i en enda process\n"
"        print(resultat.get(timeout=1))        # skriver ut \"100\" om inte "
"din dator är *mycket* långsam\n"
"\n"
"        print(pool.map(f, range(10))))       # skriver ut \"[0, 1, 4,..., "
"81]\"\n"
"\n"
"        it = pool.imap(f, intervall(10))\n"
"        print(nästa(it))                     # skriver ut \"0\"\n"
"        print(nästa(it))                     # skriver ut \"1\"\n"
"        print(it.next(timeout=1))           # skriver ut \"4\" om inte din "
"dator är *mycket* långsam\n"
"\n"
"        resultat = pool.apply_async(time.sleep, (10,))\n"
"        print(resultat.get(timeout=1))        # ger upphov till "
"multiprocessing.TimeoutError"

#: ../../library/multiprocessing.rst:2556
msgid "Listeners and Clients"
msgstr "Lyssnare och kunder"

#: ../../library/multiprocessing.rst:2561
msgid ""
"Usually message passing between processes is done using queues or by using :"
"class:`~Connection` objects returned by :func:`~multiprocessing.Pipe`."
msgstr ""
"Vanligtvis sker meddelandeöverföring mellan processer med hjälp av köer "
"eller genom att använda :class:`~Connection`-objekt som returneras av :func:"
"`~multiprocessing.Pipe`."

#: ../../library/multiprocessing.rst:2565
msgid ""
"However, the :mod:`multiprocessing.connection` module allows some extra "
"flexibility.  It basically gives a high level message oriented API for "
"dealing with sockets or Windows named pipes.  It also has support for "
"*digest authentication* using the :mod:`hmac` module, and for polling "
"multiple connections at the same time."
msgstr ""
"Modulen :mod:`multiprocessing.connection` ger dock lite extra flexibilitet.  "
"Den ger i princip ett meddelandeorienterat API på hög nivå för hantering av "
"sockets eller Windows named pipes.  Den har också stöd för *digest "
"authentication* med modulen :mod:`hmac`, och för polling av flera "
"anslutningar samtidigt."

#: ../../library/multiprocessing.rst:2574
msgid ""
"Send a randomly generated message to the other end of the connection and "
"wait for a reply."
msgstr ""
"Skicka ett slumpmässigt genererat meddelande till den andra änden av "
"anslutningen och vänta på svar."

#: ../../library/multiprocessing.rst:2577
msgid ""
"If the reply matches the digest of the message using *authkey* as the key "
"then a welcome message is sent to the other end of the connection.  "
"Otherwise :exc:`~multiprocessing.AuthenticationError` is raised."
msgstr ""
"Om svaret matchar sammanfattningen av meddelandet med *authkey* som nyckel "
"skickas ett välkomstmeddelande till den andra änden av anslutningen.  I "
"annat fall genereras :exc:`~multiprocessing.AuthenticationError`."

#: ../../library/multiprocessing.rst:2583
msgid ""
"Receive a message, calculate the digest of the message using *authkey* as "
"the key, and then send the digest back."
msgstr ""
"Ta emot ett meddelande, beräkna sammanfattningen av meddelandet med "
"*authkey* som nyckel och skicka sedan tillbaka sammanfattningen."

#: ../../library/multiprocessing.rst:2586
msgid ""
"If a welcome message is not received, then :exc:`~multiprocessing."
"AuthenticationError` is raised."
msgstr ""
"Om ett välkomstmeddelande inte tas emot kommer :exc:`~multiprocessing."
"AuthenticationError` att uppstå."

#: ../../library/multiprocessing.rst:2591
msgid ""
"Attempt to set up a connection to the listener which is using address "
"*address*, returning a :class:`~Connection`."
msgstr ""
"Försök att upprätta en anslutning till lyssnaren som använder adressen "
"*address*, returnerar en :class:`~Connection`."

#: ../../library/multiprocessing.rst:2594
msgid ""
"The type of the connection is determined by *family* argument, but this can "
"generally be omitted since it can usually be inferred from the format of "
"*address*. (See :ref:`multiprocessing-address-formats`)"
msgstr ""
"Typen av anslutning bestäms av *family*-argumentet, men detta kan i "
"allmänhet utelämnas eftersom det oftast kan härledas från formatet på "
"*address*. (Se :ref:`multiprocessing-address-formats`)"

#: ../../library/multiprocessing.rst:2598
#: ../../library/multiprocessing.rst:2633
msgid ""
"If *authkey* is given and not ``None``, it should be a byte string and will "
"be used as the secret key for an HMAC-based authentication challenge. No "
"authentication is done if *authkey* is ``None``. :exc:`~multiprocessing."
"AuthenticationError` is raised if authentication fails. See :ref:"
"`multiprocessing-auth-keys`."
msgstr ""
"Om *authkey* anges och inte ``None``, bör den vara en bytesträng och kommer "
"att användas som hemlig nyckel för en HMAC-baserad autentiseringsutmaning. "
"Ingen autentisering görs om *authkey* är ``None``. :exc:`~multiprocessing."
"AuthenticationError` genereras om autentiseringen misslyckas. Se :ref:"
"`multiprocessing-auth-keys`."

#: ../../library/multiprocessing.rst:2606
msgid ""
"A wrapper for a bound socket or Windows named pipe which is 'listening' for "
"connections."
msgstr ""
"Ett omslag för en bound socket eller Windows named pipe som \"lyssnar\" på "
"anslutningar."

#: ../../library/multiprocessing.rst:2609
msgid ""
"*address* is the address to be used by the bound socket or named pipe of the "
"listener object."
msgstr ""
"*address* är den adress som ska användas av lyssnarobjektets bundna socket "
"eller namngivna pipe."

#: ../../library/multiprocessing.rst:2614
msgid ""
"If an address of '0.0.0.0' is used, the address will not be a connectable "
"end point on Windows. If you require a connectable end-point, you should use "
"'127.0.0.1'."
msgstr ""
"Om en adress på \"0.0.0.0\" används kommer adressen inte att vara en "
"anslutningsbar slutpunkt i Windows. Om du behöver en anslutningsbar "
"slutpunkt bör du använda \"127.0.0.1\"."

#: ../../library/multiprocessing.rst:2618
msgid ""
"*family* is the type of socket (or named pipe) to use.  This can be one of "
"the strings ``'AF_INET'`` (for a TCP socket), ``'AF_UNIX'`` (for a Unix "
"domain socket) or ``'AF_PIPE'`` (for a Windows named pipe).  Of these only "
"the first is guaranteed to be available.  If *family* is ``None`` then the "
"family is inferred from the format of *address*.  If *address* is also "
"``None`` then a default is chosen.  This default is the family which is "
"assumed to be the fastest available.  See :ref:`multiprocessing-address-"
"formats`.  Note that if *family* is ``'AF_UNIX'`` and address is ``None`` "
"then the socket will be created in a private temporary directory created "
"using :func:`tempfile.mkstemp`."
msgstr ""
"*family* är den typ av socket (eller named pipe) som ska användas.  Detta "
"kan vara en av strängarna ``'AF_INET'`` (för ett TCP-socket), ``'AF_UNIX'`` "
"(för ett Unix-domän-socket) eller ``'AF_PIPE'`` (för en Windows named "
"pipe).  Av dessa är det bara den första som garanterat är tillgänglig.  Om "
"*family* är ``None`` så härleds familjen från formatet på *address*.  Om "
"*address* också är ``None`` väljs ett standardvärde.  Denna standard är den "
"familj som antas vara den snabbaste tillgängliga.  Se :ref:`multiprocessing-"
"address-formats`.  Observera att om *family* är ``'AF_UNIX'`` och adress är "
"``None`` så kommer uttaget att skapas i en privat temporär katalog som "
"skapas med :func:`tempfile.mkstemp`."

#: ../../library/multiprocessing.rst:2629
msgid ""
"If the listener object uses a socket then *backlog* (1 by default) is passed "
"to the :meth:`~socket.socket.listen` method of the socket once it has been "
"bound."
msgstr ""
"Om lyssnarobjektet använder ett uttag skickas *backlog* (1 som standard) "
"till :meth:`~socket.socket.listen`-metoden för uttaget när det har bundits."

#: ../../library/multiprocessing.rst:2641
msgid ""
"Accept a connection on the bound socket or named pipe of the listener object "
"and return a :class:`~Connection` object. If authentication is attempted and "
"fails, then :exc:`~multiprocessing.AuthenticationError` is raised."
msgstr ""
"Acceptera en anslutning på lyssnarobjektets bundna socket eller namngivna "
"pipe och returnera ett :class:`~Connection`-objekt. Om autentiseringsförsök "
"misslyckas genereras :exc:`~multiprocessing.AuthenticationError`."

#: ../../library/multiprocessing.rst:2648
msgid ""
"Close the bound socket or named pipe of the listener object.  This is called "
"automatically when the listener is garbage collected.  However it is "
"advisable to call it explicitly."
msgstr ""
"Stäng lyssnarobjektets bundna socket eller namngivna pipe.  Detta anropas "
"automatiskt när lyssnaren garbage collectas.  Det är dock tillrådligt att "
"anropa det explicit."

#: ../../library/multiprocessing.rst:2652
msgid "Listener objects have the following read-only properties:"
msgstr "Listener-objekt har följande skrivskyddade egenskaper:"

#: ../../library/multiprocessing.rst:2656
msgid "The address which is being used by the Listener object."
msgstr "Den adress som används av Listener-objektet."

#: ../../library/multiprocessing.rst:2660
msgid ""
"The address from which the last accepted connection came.  If this is "
"unavailable then it is ``None``."
msgstr ""
"Den adress som den senast accepterade anslutningen kom från.  Om den inte är "
"tillgänglig är den ``None``."

#: ../../library/multiprocessing.rst:2663
msgid ""
"Listener objects now support the context management protocol -- see :ref:"
"`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the "
"listener object, and :meth:`~contextmanager.__exit__` calls :meth:`close`."
msgstr ""
"Lyssnarobjekt stöder nu kontexthanteringsprotokollet -- se :ref:"
"`typecontextmanager`. :meth:`~contextmanager.__enter__` returnerar "
"lyssnarobjektet, och :meth:`~contextmanager.__exit__` anropar :meth:`close`."

#: ../../library/multiprocessing.rst:2670
msgid ""
"Wait till an object in *object_list* is ready.  Returns the list of those "
"objects in *object_list* which are ready.  If *timeout* is a float then the "
"call blocks for at most that many seconds.  If *timeout* is ``None`` then it "
"will block for an unlimited period. A negative timeout is equivalent to a "
"zero timeout."
msgstr ""
"Vänta tills ett objekt i *object_list* är klart.  Returnerar listan över de "
"objekt i *object_list* som är klara.  Om *timeout* är en float blockeras "
"anropet i högst så många sekunder.  Om *timeout* är ``None`` blockeras "
"anropet under obegränsad tid. En negativ timeout är likvärdig med en timeout "
"på noll."

#: ../../library/multiprocessing.rst:2676
msgid ""
"For both POSIX and Windows, an object can appear in *object_list* if it is"
msgstr ""
"För både POSIX och Windows kan ett objekt visas i *object_list* om det är"

#: ../../library/multiprocessing.rst:2679
msgid "a readable :class:`~multiprocessing.connection.Connection` object;"
msgstr "ett läsbart :class:`~multiprocessing.connection.Connection`-objekt;"

#: ../../library/multiprocessing.rst:2680
msgid "a connected and readable :class:`socket.socket` object; or"
msgstr "ett anslutet och läsbart :class:`socket.socket`-objekt; eller"

#: ../../library/multiprocessing.rst:2681
msgid ""
"the :attr:`~multiprocessing.Process.sentinel` attribute of a :class:"
"`~multiprocessing.Process` object."
msgstr ""
"attributet :attr:`~multiprocessing.Process.sentinel` för ett :class:"
"`~multiprocessing.Process`-objekt."

#: ../../library/multiprocessing.rst:2684
msgid ""
"A connection or socket object is ready when there is data available to be "
"read from it, or the other end has been closed."
msgstr ""
"En anslutning eller ett socketobjekt är klart när det finns data att läsa "
"från det, eller när den andra änden har stängts."

#: ../../library/multiprocessing.rst:2687
msgid ""
"**POSIX**: ``wait(object_list, timeout)`` almost equivalent ``select."
"select(object_list, [], [], timeout)``.  The difference is that, if :func:"
"`select.select` is interrupted by a signal, it can raise :exc:`OSError` with "
"an error number of ``EINTR``, whereas :func:`wait` will not."
msgstr ""
"**POSIX**: ``wait(object_list, timeout)`` nästan likvärdig ``select."
"select(object_list, [], [], timeout)``.  Skillnaden är att om :func:`select."
"select` avbryts av en signal, kan den ge upphov till :exc:`OSError` med ett "
"felnummer på ``EINTR``, medan :func:`wait` inte gör det."

#: ../../library/multiprocessing.rst:2693
msgid ""
"**Windows**: An item in *object_list* must either be an integer handle which "
"is waitable (according to the definition used by the documentation of the "
"Win32 function ``WaitForMultipleObjects()``) or it can be an object with a :"
"meth:`~io.IOBase.fileno` method which returns a socket handle or pipe "
"handle.  (Note that pipe handles and socket handles are **not** waitable "
"handles.)"
msgstr ""
"**Windows**: Ett objekt i *object_list* måste antingen vara ett "
"heltalshandtag som är väntbart (enligt den definition som används i "
"dokumentationen för Win32-funktionen ``WaitForMultipleObjects()``) eller så "
"kan det vara ett objekt med en :meth:`~io.IOBase.fileno`-metod som "
"returnerar ett socket-handtag eller pipe-handtag.  (Observera att pipe- och "
"socket-handtag **inte** är väntande handtag)"

#: ../../library/multiprocessing.rst:2703
msgid "**Examples**"
msgstr "**Exempel**"

#: ../../library/multiprocessing.rst:2705
msgid ""
"The following server code creates a listener which uses ``'secret "
"password'`` as an authentication key.  It then waits for a connection and "
"sends some data to the client::"
msgstr ""
"Följande serverkod skapar en lyssnare som använder ``'hemligt lösenord'`` "
"som autentiseringsnyckel.  Den väntar sedan på en anslutning och skickar "
"några data till klienten::"

#: ../../library/multiprocessing.rst:2709
msgid ""
"from multiprocessing.connection import Listener\n"
"from array import array\n"
"\n"
"address = ('localhost', 6000)     # family is deduced to be 'AF_INET'\n"
"\n"
"with Listener(address, authkey=b'secret password') as listener:\n"
"    with listener.accept() as conn:\n"
"        print('connection accepted from', listener.last_accepted)\n"
"\n"
"        conn.send([2.25, None, 'junk', float])\n"
"\n"
"        conn.send_bytes(b'hello')\n"
"\n"
"        conn.send_bytes(array('i', [42, 1729]))"
msgstr ""
"från multiprocessing.connection importera Listener\n"
"från array importera array\n"
"\n"
"address = ('localhost', 6000) # familjen härleds till att vara 'AF_INET'\n"
"\n"
"med Listener(address, authkey=b'hemligt lösenord') som listener:\n"
"    med listener.accept() som conn:\n"
"        print('anslutning accepterad från', listener.last_accepted)\n"
"\n"
"        conn.send([2.25, None, 'junk', float])\n"
"\n"
"        conn.send_bytes(b'hallå')\n"
"\n"
"        conn.send_bytes(array('i', [42, 1729]))"

#: ../../library/multiprocessing.rst:2724
msgid ""
"The following code connects to the server and receives some data from the "
"server::"
msgstr ""
"Följande kod ansluter till servern och tar emot vissa data från servern::"

#: ../../library/multiprocessing.rst:2727
msgid ""
"from multiprocessing.connection import Client\n"
"from array import array\n"
"\n"
"address = ('localhost', 6000)\n"
"\n"
"with Client(address, authkey=b'secret password') as conn:\n"
"    print(conn.recv())                  # => [2.25, None, 'junk', float]\n"
"\n"
"    print(conn.recv_bytes())            # => 'hello'\n"
"\n"
"    arr = array('i', [0, 0, 0, 0, 0])\n"
"    print(conn.recv_bytes_into(arr))    # => 8\n"
"    print(arr)                          # => array('i', [42, 1729, 0, 0, 0])"
msgstr ""
"from multiprocessing.connection import Klient\n"
"från array importera array\n"
"\n"
"adress = ('localhost', 6000)\n"
"\n"
"med Client(address, authkey=b'secret password') som conn:\n"
"    print(conn.recv()) # => [2.25, None, 'junk', float]\n"
"\n"
"    print(conn.recv_bytes()) # => 'hello'\n"
"\n"
"    arr = array('i', [0, 0, 0, 0, 0, 0])\n"
"    print(conn.recv_bytes_into(arr))    # => 8\n"
"    print(arr) # => array('i', [42, 1729, 0, 0, 0])"

#: ../../library/multiprocessing.rst:2741
msgid ""
"The following code uses :func:`~multiprocessing.connection.wait` to wait for "
"messages from multiple processes at once::"
msgstr ""
"Följande kod använder :func:`~multiprocessing.connection.wait` för att vänta "
"på meddelanden från flera processer samtidigt::"

#: ../../library/multiprocessing.rst:2744
msgid ""
"from multiprocessing import Process, Pipe, current_process\n"
"from multiprocessing.connection import wait\n"
"\n"
"def foo(w):\n"
"    for i in range(10):\n"
"        w.send((i, current_process().name))\n"
"    w.close()\n"
"\n"
"if __name__ == '__main__':\n"
"    readers = []\n"
"\n"
"    for i in range(4):\n"
"        r, w = Pipe(duplex=False)\n"
"        readers.append(r)\n"
"        p = Process(target=foo, args=(w,))\n"
"        p.start()\n"
"        # We close the writable end of the pipe now to be sure that\n"
"        # p is the only process which owns a handle for it.  This\n"
"        # ensures that when p closes its handle for the writable end,\n"
"        # wait() will promptly report the readable end as being ready.\n"
"        w.close()\n"
"\n"
"    while readers:\n"
"        for r in wait(readers):\n"
"            try:\n"
"                msg = r.recv()\n"
"            except EOFError:\n"
"                readers.remove(r)\n"
"            else:\n"
"                print(msg)"
msgstr ""
"från multiprocessing import Process, Pipe, current_process\n"
"från multiprocessing.connection import wait\n"
"\n"
"def foo(w):\n"
"    för i i intervall(10):\n"
"        w.send((i, current_process().name))\n"
"    w.close()\n"
"\n"
"if __name__ == '__main__':\n"
"    läsare = []\n"
"\n"
"    för i i intervall(4):\n"
"        r, w = Pipe(duplex=False)\n"
"        readers.append(r)\n"
"        p = Process(mål=foo, args=(w,))\n"
"        p.start()\n"
"        # Vi stänger den skrivbara änden av röret nu för att vara säkra på "
"att\n"
"        # p är den enda process som äger ett handtag för den.  Detta\n"
"        # säkerställer att när p stänger sitt handtag för den skrivbara "
"änden\n"
"        # kommer wait() omedelbart att rapportera att den läsbara änden är "
"klar.\n"
"        w.close()\n"
"\n"
"    medan läsare:\n"
"        for r in wait(readers):\n"
"            försök:\n"
"                msg = r.recv()\n"
"            utom EOFError:\n"
"                readers.remove(r)\n"
"            else:\n"
"                print(msg)"

#: ../../library/multiprocessing.rst:2779
msgid "Address Formats"
msgstr "Adressformat"

#: ../../library/multiprocessing.rst:2781
msgid ""
"An ``'AF_INET'`` address is a tuple of the form ``(hostname, port)`` where "
"*hostname* is a string and *port* is an integer."
msgstr ""
"En ``'AF_INET'``-adress är en tupel av formen ``(hostname, port)`` där "
"*hostname* är en sträng och *port* är ett heltal."

#: ../../library/multiprocessing.rst:2784
msgid ""
"An ``'AF_UNIX'`` address is a string representing a filename on the "
"filesystem."
msgstr ""
"En ``'AF_UNIX'``-adress är en sträng som representerar ett filnamn i "
"filsystemet."

#: ../../library/multiprocessing.rst:2787
msgid ""
"An ``'AF_PIPE'`` address is a string of the form :samp:`r'\\\\\\\\\\\\.\\"
"\\pipe\\\\\\\\{PipeName}'`.  To use :func:`Client` to connect to a named "
"pipe on a remote computer called *ServerName* one should use an address of "
"the form :samp:`r'\\\\\\\\\\\\\\\\{ServerName}\\\\pipe\\\\\\\\{PipeName}'` "
"instead."
msgstr ""
"En ``'AF_PIPE'``-adress är en sträng av formen :samp:`r'\\\\\\\\\\\\.\\"
"\\pipe\\\\\\\\{PipeName}'`.  Om du vill använda :func:`Client` för att "
"ansluta till en namngiven pipe på en fjärrdator som heter *ServerName* bör "
"du använda en adress av formen :samp:`r'\\\\\\\\\\\\\\\\{ServerName}\\"
"\\pipe\\\\\\\\{PipeName}'` istället."

#: ../../library/multiprocessing.rst:2792
msgid ""
"Note that any string beginning with two backslashes is assumed by default to "
"be an ``'AF_PIPE'`` address rather than an ``'AF_UNIX'`` address."
msgstr ""
"Observera att alla strängar som börjar med två backslash antas som standard "
"vara en ``'AF_PIPE'``-adress i stället för en ``'AF_UNIX'``-adress."

#: ../../library/multiprocessing.rst:2799
msgid "Authentication keys"
msgstr "Autentiseringsnycklar"

#: ../../library/multiprocessing.rst:2801
msgid ""
"When one uses :meth:`Connection.recv <Connection.recv>`, the data received "
"is automatically unpickled. Unfortunately unpickling data from an untrusted "
"source is a security risk. Therefore :class:`Listener` and :func:`Client` "
"use the :mod:`hmac` module to provide digest authentication."
msgstr ""
"När man använder :meth:`Connection.recv <Connection.recv>`, avplockas "
"automatiskt de data som tas emot. Tyvärr är det en säkerhetsrisk att "
"avpickla data från en icke betrodd källa. Därför använder :class:`Listener` "
"och :func:`Client` modulen :mod:`hmac` för att tillhandahålla digest-"
"autentisering."

#: ../../library/multiprocessing.rst:2807
msgid ""
"An authentication key is a byte string which can be thought of as a "
"password: once a connection is established both ends will demand proof that "
"the other knows the authentication key.  (Demonstrating that both ends are "
"using the same key does **not** involve sending the key over the connection.)"
msgstr ""
"En autentiseringsnyckel är en byte-sträng som kan betraktas som ett "
"lösenord: när en anslutning har upprättats kommer båda ändarna att kräva "
"bevis för att den andra känner till autentiseringsnyckeln.  (Att visa att "
"båda ändarna använder samma nyckel innebär **inte** att nyckeln skickas över "
"anslutningen)"

#: ../../library/multiprocessing.rst:2813
msgid ""
"If authentication is requested but no authentication key is specified then "
"the return value of ``current_process().authkey`` is used (see :class:"
"`~multiprocessing.Process`).  This value will be automatically inherited by "
"any :class:`~multiprocessing.Process` object that the current process "
"creates. This means that (by default) all processes of a multi-process "
"program will share a single authentication key which can be used when "
"setting up connections between themselves."
msgstr ""
"Om autentisering begärs men ingen autentiseringsnyckel anges används "
"returvärdet för ``current_process().authkey`` (se :class:`~multiprocessing."
"Process`).  Detta värde kommer automatiskt att ärvas av alla :class:"
"`~multiprocessing.Process`-objekt som den aktuella processen skapar. Detta "
"innebär att (som standard) alla processer i ett multiprocessprogram kommer "
"att dela en enda autentiseringsnyckel som kan användas när de upprättar "
"anslutningar sinsemellan."

#: ../../library/multiprocessing.rst:2821
msgid ""
"Suitable authentication keys can also be generated by using :func:`os."
"urandom`."
msgstr ""
"Lämpliga autentiseringsnycklar kan också genereras med hjälp av :func:`os."
"urandom`."

#: ../../library/multiprocessing.rst:2825
msgid "Logging"
msgstr "Loggning"

#: ../../library/multiprocessing.rst:2827
msgid ""
"Some support for logging is available.  Note, however, that the :mod:"
"`logging` package does not use process shared locks so it is possible "
"(depending on the handler type) for messages from different processes to get "
"mixed up."
msgstr ""
"Visst stöd för loggning finns tillgängligt.  Observera dock att paketet :mod:"
"`logging` inte använder processdelade lås så det är möjligt (beroende på typ "
"av hanterare) att meddelanden från olika processer blandas ihop."

#: ../../library/multiprocessing.rst:2834
msgid ""
"Returns the logger used by :mod:`multiprocessing`.  If necessary, a new one "
"will be created."
msgstr ""
"Returnerar den logger som används av :mod:`multiprocessing`.  Om det behövs "
"skapas en ny."

#: ../../library/multiprocessing.rst:2837
msgid ""
"When first created the logger has level :const:`logging.NOTSET` and no "
"default handler. Messages sent to this logger will not by default propagate "
"to the root logger."
msgstr ""
"När loggern skapas första gången har den nivån :const:`logging.NOTSET` och "
"ingen standardhanterare. Meddelanden som skickas till denna logger kommer "
"som standard inte att spridas till rotloggaren."

#: ../../library/multiprocessing.rst:2841
msgid ""
"Note that on Windows child processes will only inherit the level of the "
"parent process's logger -- any other customization of the logger will not be "
"inherited."
msgstr ""
"Observera att i Windows ärver barnprocesser endast nivån på den överordnade "
"processens logger - alla andra anpassningar av loggern ärvs inte."

#: ../../library/multiprocessing.rst:2848
msgid ""
"This function performs a call to :func:`get_logger` but in addition to "
"returning the logger created by get_logger, it adds a handler which sends "
"output to :data:`sys.stderr` using format ``'[%(levelname)s/%(processName)s] "
"%(message)s'``. You can modify ``levelname`` of the logger by passing a "
"``level`` argument."
msgstr ""
"Denna funktion utför ett anrop till :func:`get_logger` men förutom att "
"returnera den logger som skapats av get_logger lägger den till en hanterare "
"som skickar utdata till :data:`sys.stderr` med formatet ``'[%(levelname)s/"
"%(processName)s] %(message)s'``. Du kan ändra ``levelname`` för loggern "
"genom att skicka ett ``level``-argument."

#: ../../library/multiprocessing.rst:2854
msgid "Below is an example session with logging turned on::"
msgstr "Nedan visas ett exempel på en session med loggning aktiverad::"

#: ../../library/multiprocessing.rst:2856
msgid ""
">>> import multiprocessing, logging\n"
">>> logger = multiprocessing.log_to_stderr()\n"
">>> logger.setLevel(logging.INFO)\n"
">>> logger.warning('doomed')\n"
"[WARNING/MainProcess] doomed\n"
">>> m = multiprocessing.Manager()\n"
"[INFO/SyncManager-...] child process calling self.run()\n"
"[INFO/SyncManager-...] created temp directory /.../pymp-...\n"
"[INFO/SyncManager-...] manager serving at '/.../listener-...'\n"
">>> del m\n"
"[INFO/MainProcess] sending shutdown message to manager\n"
"[INFO/SyncManager-...] manager exiting with exitcode 0"
msgstr ""
">>> import multiprocessing, loggning\n"
">>> logger = multiprocessing.log_to_stderr()\n"
">>> logger.setLevel(logging.INFO)\n"
">>> logger.warning('dödsdömd')\n"
"[VARNING/MainProcess] dödsdömd\n"
">>> m = multiprocessing.Manager()\n"
"[INFO/SyncManager-...] barnprocessen anropar self.run()\n"
"[INFO/SyncManager-...] skapade temporär katalog /.../pymp-...\n"
"[INFO/SyncManager-...] manager serveras på '/.../listener-...'\n"
">>> del m\n"
"[INFO/MainProcess] skickar avstängningsmeddelande till manager\n"
"[INFO/SyncManager-...] chefen avslutas med exitcode 0"

#: ../../library/multiprocessing.rst:2869
msgid "For a full table of logging levels, see the :mod:`logging` module."
msgstr ""
"En fullständig tabell över loggningsnivåer finns i modulen :mod:`logging`."

#: ../../library/multiprocessing.rst:2873
msgid "The :mod:`multiprocessing.dummy` module"
msgstr "Modulen :mod:`multiprocessing.dummy"

#: ../../library/multiprocessing.rst:2878
msgid ""
":mod:`multiprocessing.dummy` replicates the API of :mod:`multiprocessing` "
"but is no more than a wrapper around the :mod:`threading` module."
msgstr ""
":mod:`multiprocessing.dummy` replikerar API:t för :mod:`multiprocessing` men "
"är inte mer än ett omslag runt modulen :mod:`threading`."

#: ../../library/multiprocessing.rst:2883
msgid ""
"In particular, the ``Pool`` function provided by :mod:`multiprocessing."
"dummy` returns an instance of :class:`ThreadPool`, which is a subclass of :"
"class:`Pool` that supports all the same method calls but uses a pool of "
"worker threads rather than worker processes."
msgstr ""
"I synnerhet funktionen ``Pool`` som tillhandahålls av :mod:`multiprocessing."
"dummy` returnerar en instans av :class:`ThreadPool`, som är en underklass "
"till :class:`Pool` som stöder alla samma metodanrop men använder en pool av "
"arbetartrådar i stället för arbetsprocesser."

#: ../../library/multiprocessing.rst:2891
msgid ""
"A thread pool object which controls a pool of worker threads to which jobs "
"can be submitted.  :class:`ThreadPool` instances are fully interface "
"compatible with :class:`Pool` instances, and their resources must also be "
"properly managed, either by using the pool as a context manager or by "
"calling :meth:`~multiprocessing.pool.Pool.close` and :meth:`~multiprocessing."
"pool.Pool.terminate` manually."
msgstr ""
"Ett trådpoolsobjekt som styr en pool av arbetstrådar som jobb kan skickas "
"till. :class:`ThreadPool`-instanser är helt gränssnittskompatibla med :class:"
"`Pool`-instanser och deras resurser måste också hanteras korrekt, antingen "
"genom att använda poolen som en kontexthanterare eller genom att anropa :"
"meth:`~multiprocessing.pool.Pool.close` och :meth:`~multiprocessing.pool."
"Pool.terminate` manuellt."

#: ../../library/multiprocessing.rst:2898
msgid ""
"*processes* is the number of worker threads to use.  If *processes* is "
"``None`` then the number returned by :func:`os.process_cpu_count` is used."
msgstr ""
"*processes* är antalet arbetstrådar som ska användas.  Om *processes* är "
"``None`` används det antal som returneras av :func:`os.process_cpu_count`."

#: ../../library/multiprocessing.rst:2904
msgid ""
"Unlike :class:`Pool`, *maxtasksperchild* and *context* cannot be provided."
msgstr ""
"Till skillnad från :class:`Pool` kan *maxtasksperchild* och *context* inte "
"anges."

#: ../../library/multiprocessing.rst:2908
msgid ""
"A :class:`ThreadPool` shares the same interface as :class:`Pool`, which is "
"designed around a pool of processes and predates the introduction of the :"
"class:`concurrent.futures` module.  As such, it inherits some operations "
"that don't make sense for a pool backed by threads, and it has its own type "
"for representing the status of asynchronous jobs, :class:`AsyncResult`, that "
"is not understood by any other libraries."
msgstr ""
"En :class:`ThreadPool` delar samma gränssnitt som :class:`Pool`, som är "
"utformad kring en pool av processer och föregår introduktionen av :class:"
"`concurrent.futures`-modulen.  Som sådan ärver den vissa operationer som "
"inte är meningsfulla för en pool som backas upp av trådar, och den har en "
"egen typ för att representera statusen för asynkrona jobb, :class:"
"`AsyncResult`, som inte förstås av några andra bibliotek."

#: ../../library/multiprocessing.rst:2915
msgid ""
"Users should generally prefer to use :class:`concurrent.futures."
"ThreadPoolExecutor`, which has a simpler interface that was designed around "
"threads from the start, and which returns :class:`concurrent.futures.Future` "
"instances that are compatible with many other libraries, including :mod:"
"`asyncio`."
msgstr ""
"Användare bör i allmänhet föredra att använda :class:`concurrent.futures."
"ThreadPoolExecutor`, som har ett enklare gränssnitt som utformades kring "
"trådar från början och som returnerar :class:`concurrent.futures.Future`-"
"instanser som är kompatibla med många andra bibliotek, inklusive :mod:"
"`asyncio`."

#: ../../library/multiprocessing.rst:2925
msgid "Programming guidelines"
msgstr "Riktlinjer för programmering"

#: ../../library/multiprocessing.rst:2927
msgid ""
"There are certain guidelines and idioms which should be adhered to when "
"using :mod:`multiprocessing`."
msgstr ""
"Det finns vissa riktlinjer och idiom som bör följas vid användning av :mod:"
"`multiprocessing`."

#: ../../library/multiprocessing.rst:2932
msgid "All start methods"
msgstr "Alla startmetoder"

#: ../../library/multiprocessing.rst:2934
msgid "The following applies to all start methods."
msgstr "Följande gäller för alla startmetoder."

#: ../../library/multiprocessing.rst:2936
msgid "Avoid shared state"
msgstr "Undvik delat tillstånd"

#: ../../library/multiprocessing.rst:2938
msgid ""
"As far as possible one should try to avoid shifting large amounts of data "
"between processes."
msgstr ""
"Så långt det är möjligt bör man försöka undvika att flytta stora mängder "
"data mellan processer."

#: ../../library/multiprocessing.rst:2941
msgid ""
"It is probably best to stick to using queues or pipes for communication "
"between processes rather than using the lower level synchronization "
"primitives."
msgstr ""
"Det är förmodligen bäst att hålla sig till att använda köer eller pipes för "
"kommunikation mellan processer snarare än att använda "
"synkroniseringsprimitiven på lägre nivå."

#: ../../library/multiprocessing.rst:2945
msgid "Picklability"
msgstr "Inläggning"

#: ../../library/multiprocessing.rst:2947
msgid "Ensure that the arguments to the methods of proxies are picklable."
msgstr "Säkerställ att argumenten till metoderna för proxies är picklbara."

#: ../../library/multiprocessing.rst:2949
msgid "Thread safety of proxies"
msgstr "Trådsäkerhet för proxyer"

#: ../../library/multiprocessing.rst:2951
msgid ""
"Do not use a proxy object from more than one thread unless you protect it "
"with a lock."
msgstr ""
"Använd inte ett proxyobjekt från mer än en tråd om du inte skyddar det med "
"ett lås."

#: ../../library/multiprocessing.rst:2954
msgid ""
"(There is never a problem with different processes using the *same* proxy.)"
msgstr ""
"(Det är aldrig något problem att olika processer använder *samma* proxy)"

#: ../../library/multiprocessing.rst:2956
msgid "Joining zombie processes"
msgstr "Ansluta sig till zombieprocesser"

#: ../../library/multiprocessing.rst:2958
msgid ""
"On POSIX when a process finishes but has not been joined it becomes a "
"zombie. There should never be very many because each time a new process "
"starts (or :func:`~multiprocessing.active_children` is called) all completed "
"processes which have not yet been joined will be joined.  Also calling a "
"finished process's :meth:`Process.is_alive <multiprocessing.Process."
"is_alive>` will join the process.  Even so it is probably good practice to "
"explicitly join all the processes that you start."
msgstr ""
"På POSIX blir en process en zombie när den är klar men inte har blivit "
"joinad. Det bör aldrig finnas särskilt många eftersom varje gång en ny "
"process startar (eller :func:`~multiprocessing.active_children` anropas) "
"kommer alla avslutade processer som ännu inte har förenats att förenas.  "
"Även anrop av en avslutad process :meth:`Process.is_alive <multiprocessing."
"Process.is_alive>` kommer att ansluta processen.  Trots detta är det "
"förmodligen god praxis att uttryckligen joina alla processer som du startar."

#: ../../library/multiprocessing.rst:2966
msgid "Better to inherit than pickle/unpickle"
msgstr "Bättre att ärva än att plocka/ta bort"

#: ../../library/multiprocessing.rst:2968
msgid ""
"When using the *spawn* or *forkserver* start methods many types from :mod:"
"`multiprocessing` need to be picklable so that child processes can use "
"them.  However, one should generally avoid sending shared objects to other "
"processes using pipes or queues. Instead you should arrange the program so "
"that a process which needs access to a shared resource created elsewhere can "
"inherit it from an ancestor process."
msgstr ""
"När man använder startmetoderna *spawn* eller *forkserver* måste många typer "
"från :mod:`multiprocessing` vara picklable så att barnprocesser kan använda "
"dem.  Man bör dock i allmänhet undvika att skicka delade objekt till andra "
"processer med hjälp av pipes eller köer. Istället bör man arrangera "
"programmet så att en process som behöver tillgång till en delad resurs som "
"skapats någon annanstans kan ärva den från en förfadersprocess."

#: ../../library/multiprocessing.rst:2976
msgid "Avoid terminating processes"
msgstr "Undvik att avsluta processer"

#: ../../library/multiprocessing.rst:2978
msgid ""
"Using the :meth:`Process.terminate <multiprocessing.Process.terminate>` "
"method to stop a process is liable to cause any shared resources (such as "
"locks, semaphores, pipes and queues) currently being used by the process to "
"become broken or unavailable to other processes."
msgstr ""
"Om du använder metoden :meth:`Process.terminate <multiprocessing.Process."
"terminate>` för att stoppa en process kan det leda till att delade resurser "
"(t.ex. lås, semaforer, rör och köer) som för närvarande används av processen "
"blir trasiga eller otillgängliga för andra processer."

#: ../../library/multiprocessing.rst:2984
msgid ""
"Therefore it is probably best to only consider using :meth:`Process."
"terminate <multiprocessing.Process.terminate>` on processes which never use "
"any shared resources."
msgstr ""
"Därför är det förmodligen bäst att bara överväga att använda :meth:`Process."
"terminate <multiprocessing.Process.terminate>` på processer som aldrig "
"använder några delade resurser."

#: ../../library/multiprocessing.rst:2988
msgid "Joining processes that use queues"
msgstr "Ansluta sig till processer som använder köer"

#: ../../library/multiprocessing.rst:2990
msgid ""
"Bear in mind that a process that has put items in a queue will wait before "
"terminating until all the buffered items are fed by the \"feeder\" thread to "
"the underlying pipe.  (The child process can call the :meth:`Queue."
"cancel_join_thread <multiprocessing.Queue.cancel_join_thread>` method of the "
"queue to avoid this behaviour.)"
msgstr ""
"Tänk på att en process som har lagt objekt i en kö kommer att vänta innan "
"den avslutas tills alla buffrade objekt har matats av \"feeder\"-tråden till "
"den underliggande pipen.  (Barnprocessen kan anropa :meth:`Queue."
"cancel_join_thread <multiprocessing.Queue.cancel_join_thread>`-metoden för "
"kön för att undvika detta beteende)"

#: ../../library/multiprocessing.rst:2996
msgid ""
"This means that whenever you use a queue you need to make sure that all "
"items which have been put on the queue will eventually be removed before the "
"process is joined.  Otherwise you cannot be sure that processes which have "
"put items on the queue will terminate.  Remember also that non-daemonic "
"processes will be joined automatically."
msgstr ""
"Detta innebär att när du använder en kö måste du se till att alla objekt som "
"har lagts i kön så småningom kommer att tas bort innan processen ansluts.  "
"Annars kan du inte vara säker på att processer som har lagt objekt i kön "
"kommer att avslutas.  Kom också ihåg att icke-daemoniska processer kommer "
"att anslutas automatiskt."

#: ../../library/multiprocessing.rst:3002
msgid "An example which will deadlock is the following::"
msgstr "Ett exempel som kommer att låsa sig är följande::"

#: ../../library/multiprocessing.rst:3004
msgid ""
"from multiprocessing import Process, Queue\n"
"\n"
"def f(q):\n"
"    q.put('X' * 1000000)\n"
"\n"
"if __name__ == '__main__':\n"
"    queue = Queue()\n"
"    p = Process(target=f, args=(queue,))\n"
"    p.start()\n"
"    p.join()                    # this deadlocks\n"
"    obj = queue.get()"
msgstr ""
"från multiprocessing import Process, Kö\n"
"\n"
"def f(q):\n"
"    q.put('X' * 1000000)\n"
"\n"
"if __name__ == '__main__':\n"
"    queue = Queue()\n"
"    p = Process(mål=f, args=(kö,))\n"
"    p.start()\n"
"    p.join() # detta leder till dödläge\n"
"    obj = kö.get()"

#: ../../library/multiprocessing.rst:3016
msgid ""
"A fix here would be to swap the last two lines (or simply remove the ``p."
"join()`` line)."
msgstr ""
"En lösning här skulle vara att byta ut de två sista raderna (eller helt "
"enkelt ta bort raden ``p.join()``))."

#: ../../library/multiprocessing.rst:3019
msgid "Explicitly pass resources to child processes"
msgstr "Explicit skicka resurser till underordnade processer"

#: ../../library/multiprocessing.rst:3021
msgid ""
"On POSIX using the *fork* start method, a child process can make use of a "
"shared resource created in a parent process using a global resource.  "
"However, it is better to pass the object as an argument to the constructor "
"for the child process."
msgstr ""
"På POSIX med startmetoden *fork* kan en underordnad process använda en delad "
"resurs som skapats i en överordnad process med hjälp av en global resurs.  "
"Det är dock bättre att skicka objektet som ett argument till konstruktören "
"för barnprocessen."

#: ../../library/multiprocessing.rst:3026
msgid ""
"Apart from making the code (potentially) compatible with Windows and the "
"other start methods this also ensures that as long as the child process is "
"still alive the object will not be garbage collected in the parent process.  "
"This might be important if some resource is freed when the object is garbage "
"collected in the parent process."
msgstr ""
"Förutom att göra koden (potentiellt) kompatibel med Windows och de andra "
"startmetoderna säkerställer detta också att så länge barnprocessen "
"fortfarande är vid liv kommer objektet inte att samlas in i den överordnade "
"processen.  Detta kan vara viktigt om någon resurs frigörs när objektet "
"garbage collectas i den överordnade processen."

#: ../../library/multiprocessing.rst:3033
msgid "So for instance ::"
msgstr "Så till exempel ::"

#: ../../library/multiprocessing.rst:3035
msgid ""
"from multiprocessing import Process, Lock\n"
"\n"
"def f():\n"
"    ... do something using \"lock\" ...\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"    for i in range(10):\n"
"        Process(target=f).start()"
msgstr ""
"från multiprocessing import Process, Lås\n"
"\n"
"def f():\n"
"    ... gör något med hjälp av \"lock\" ...\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"    för i i intervall(10):\n"
"        Process(mål=f).start()"

#: ../../library/multiprocessing.rst:3045
msgid "should be rewritten as ::"
msgstr "bör skrivas om till ::"

#: ../../library/multiprocessing.rst:3047
msgid ""
"from multiprocessing import Process, Lock\n"
"\n"
"def f(l):\n"
"    ... do something using \"l\" ...\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"    for i in range(10):\n"
"        Process(target=f, args=(lock,)).start()"
msgstr ""
"från multiprocessing import Process, Lås\n"
"\n"
"def f(l):\n"
"    ... gör något med hjälp av \"l\" ...\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"    för i i intervall(10):\n"
"        Process(mål=f, args=(lock,)).start()"

#: ../../library/multiprocessing.rst:3057
msgid "Beware of replacing :data:`sys.stdin` with a \"file like object\""
msgstr ""
"Se upp så att du inte ersätter :data:`sys.stdin` med ett \"filliknande "
"objekt\""

#: ../../library/multiprocessing.rst:3059
msgid ":mod:`multiprocessing` originally unconditionally called::"
msgstr ":mod:`multiprocessing` ursprungligen ovillkorligen anropad::"

#: ../../library/multiprocessing.rst:3061
msgid "os.close(sys.stdin.fileno())"
msgstr "os.close(sys.stdin.fileno())"

#: ../../library/multiprocessing.rst:3063
msgid ""
"in the :meth:`multiprocessing.Process._bootstrap` method --- this resulted "
"in issues with processes-in-processes. This has been changed to::"
msgstr ""
"i metoden :meth:`multiprocessing.Process._bootstrap` --- detta resulterade i "
"problem med processer-i-processer. Detta har ändrats till::"

#: ../../library/multiprocessing.rst:3066
msgid ""
"sys.stdin.close()\n"
"sys.stdin = open(os.open(os.devnull, os.O_RDONLY), closefd=False)"
msgstr ""
"sys.stdin.close()\n"
"sys.stdin = open(os.open(os.devnull, os.O_RDONLY), closefd=False)"

#: ../../library/multiprocessing.rst:3069
msgid ""
"Which solves the fundamental issue of processes colliding with each other "
"resulting in a bad file descriptor error, but introduces a potential danger "
"to applications which replace :func:`sys.stdin` with a \"file-like object\" "
"with output buffering.  This danger is that if multiple processes call :meth:"
"`~io.IOBase.close` on this file-like object, it could result in the same "
"data being flushed to the object multiple times, resulting in corruption."
msgstr ""
"Detta löser det grundläggande problemet med processer som kolliderar med "
"varandra och resulterar i ett fel med dålig filbeskrivare, men introducerar "
"en potentiell fara för applikationer som ersätter :func:`sys.stdin` med ett "
"\"filliknande objekt\" med buffring av utdata.  Denna fara är att om flera "
"processer anropar :meth:`~io.IOBase.close` på detta filliknande objekt, kan "
"det resultera i att samma data spolas till objektet flera gånger, vilket "
"resulterar i korruption."

#: ../../library/multiprocessing.rst:3076
msgid ""
"If you write a file-like object and implement your own caching, you can make "
"it fork-safe by storing the pid whenever you append to the cache, and "
"discarding the cache when the pid changes. For example::"
msgstr ""
"Om du skriver ett filliknande objekt och implementerar din egen cachelagring "
"kan du göra den gaffelsäker genom att lagra pid när du lägger till något i "
"cachen och kassera cachen när pid ändras. Till exempel::"

#: ../../library/multiprocessing.rst:3080
msgid ""
"@property\n"
"def cache(self):\n"
"    pid = os.getpid()\n"
"    if pid != self._pid:\n"
"        self._pid = pid\n"
"        self._cache = []\n"
"    return self._cache"
msgstr ""
"@egenskap\n"
"def cache(self):\n"
"    pid = os.getpid()\n"
"    if pid != self._pid:\n"
"        self._pid = pid\n"
"        self._cache = []\n"
"    returnera self._cache"

#: ../../library/multiprocessing.rst:3088
msgid ""
"For more information, see :issue:`5155`, :issue:`5313` and :issue:`5331`"
msgstr "För mer information, se :issue:`5155`, :issue:`5313` och :issue:`5331`"

#: ../../library/multiprocessing.rst:3094
msgid "The *spawn* and *forkserver* start methods"
msgstr "Startmetoderna *spawn* och *forkserver*"

#: ../../library/multiprocessing.rst:3096
msgid ""
"There are a few extra restrictions which don't apply to the *fork* start "
"method."
msgstr ""
"Det finns några extra begränsningar som inte gäller för startmetoden *fork*."

#: ../../library/multiprocessing.rst:3099
msgid "More picklability"
msgstr "Mer betningsbarhet"

#: ../../library/multiprocessing.rst:3101
msgid ""
"Ensure that all arguments to :class:`~multiprocessing.Process` are "
"picklable.  Also, if you subclass ``Process.__init__``, you must make sure "
"that instances will be picklable when the :meth:`Process.start "
"<multiprocessing.Process.start>` method is called."
msgstr ""
"Se till att alla argument till :class:`~multiprocessing.Process` är "
"betningsbara.  Om du subklassar ``Process.__init__`` måste du också se till "
"att instanser kommer att vara betningsbara när metoden :meth:`Process.start "
"<multiprocessing.Process.start>` anropas."

#: ../../library/multiprocessing.rst:3106
msgid "Global variables"
msgstr "Globala variabler"

#: ../../library/multiprocessing.rst:3108
msgid ""
"Bear in mind that if code run in a child process tries to access a global "
"variable, then the value it sees (if any) may not be the same as the value "
"in the parent process at the time that :meth:`Process.start <multiprocessing."
"Process.start>` was called."
msgstr ""
"Tänk på att om kod som körs i en underordnad process försöker komma åt en "
"global variabel, så kanske det värde som visas (om det finns något) inte är "
"detsamma som värdet i den överordnade processen vid den tidpunkt då :meth:"
"`Process.start <multiprocessing.Process.start>` anropades."

#: ../../library/multiprocessing.rst:3113
msgid ""
"However, global variables which are just module level constants cause no "
"problems."
msgstr ""
"Globala variabler som bara är konstanter på modulnivå orsakar dock inga "
"problem."

#: ../../library/multiprocessing.rst:3118
msgid "Safe importing of main module"
msgstr "Säker import av huvudmodul"

#: ../../library/multiprocessing.rst:3120
msgid ""
"Make sure that the main module can be safely imported by a new Python "
"interpreter without causing unintended side effects (such as starting a new "
"process)."
msgstr ""
"Se till att huvudmodulen kan importeras på ett säkert sätt av en ny Python-"
"tolk utan att orsaka oavsiktliga bieffekter (t.ex. att starta en ny process)."

#: ../../library/multiprocessing.rst:3124
msgid ""
"For example, using the *spawn* or *forkserver* start method running the "
"following module would fail with a :exc:`RuntimeError`::"
msgstr ""
"Om du till exempel använder startmetoden *spawn* eller *forkserver* och kör "
"följande modul skulle det misslyckas med :exc:`RuntimeError`::"

#: ../../library/multiprocessing.rst:3128
msgid ""
"from multiprocessing import Process\n"
"\n"
"def foo():\n"
"    print('hello')\n"
"\n"
"p = Process(target=foo)\n"
"p.start()"
msgstr ""
"från multiprocessing import Process\n"
"\n"
"def foo():\n"
"    print('hallå')\n"
"\n"
"p = Process(mål=foo)\n"
"p.start()"

#: ../../library/multiprocessing.rst:3136
msgid ""
"Instead one should protect the \"entry point\" of the program by using ``if "
"__name__ == '__main__':`` as follows::"
msgstr ""
"Istället bör man skydda programmets \"ingångspunkt\" genom att använda ``if "
"__name__ == '__main__':`` på följande sätt::"

#: ../../library/multiprocessing.rst:3139
msgid ""
"from multiprocessing import Process, freeze_support, set_start_method\n"
"\n"
"def foo():\n"
"    print('hello')\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    set_start_method('spawn')\n"
"    p = Process(target=foo)\n"
"    p.start()"
msgstr ""
"from multiprocessing import Process, freeze_support, set_start_method\n"
"\n"
"def foo():\n"
"    print('hello')\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    set_start_method('spawn')\n"
"    p = Process(mål=foo)\n"
"    p.start()"

#: ../../library/multiprocessing.rst:3150
msgid ""
"(The ``freeze_support()`` line can be omitted if the program will be run "
"normally instead of frozen.)"
msgstr ""
"(Raden ``freeze_support()`` kan utelämnas om programmet ska köras normalt "
"istället för att frysas)"

#: ../../library/multiprocessing.rst:3153
msgid ""
"This allows the newly spawned Python interpreter to safely import the module "
"and then run the module's ``foo()`` function."
msgstr ""
"Detta gör att den nystartade Python-tolken kan importera modulen på ett "
"säkert sätt och sedan köra modulens funktion ``foo()``."

#: ../../library/multiprocessing.rst:3156
msgid ""
"Similar restrictions apply if a pool or manager is created in the main "
"module."
msgstr ""
"Liknande begränsningar gäller om en pool eller manager skapas i huvudmodulen."

#: ../../library/multiprocessing.rst:3163
msgid "Examples"
msgstr "Exempel"

#: ../../library/multiprocessing.rst:3165
msgid "Demonstration of how to create and use customized managers and proxies:"
msgstr ""
"Demonstration av hur man skapar och använder anpassade hanterare och "
"fullmakter:"

#: ../../library/multiprocessing.rst:3167
msgid ""
"from multiprocessing import freeze_support\n"
"from multiprocessing.managers import BaseManager, BaseProxy\n"
"import operator\n"
"\n"
"##\n"
"\n"
"class Foo:\n"
"    def f(self):\n"
"        print('you called Foo.f()')\n"
"    def g(self):\n"
"        print('you called Foo.g()')\n"
"    def _h(self):\n"
"        print('you called Foo._h()')\n"
"\n"
"# A simple generator function\n"
"def baz():\n"
"    for i in range(10):\n"
"        yield i*i\n"
"\n"
"# Proxy type for generator objects\n"
"class GeneratorProxy(BaseProxy):\n"
"    _exposed_ = ['__next__']\n"
"    def __iter__(self):\n"
"        return self\n"
"    def __next__(self):\n"
"        return self._callmethod('__next__')\n"
"\n"
"# Function to return the operator module\n"
"def get_operator_module():\n"
"    return operator\n"
"\n"
"##\n"
"\n"
"class MyManager(BaseManager):\n"
"    pass\n"
"\n"
"# register the Foo class; make `f()` and `g()` accessible via proxy\n"
"MyManager.register('Foo1', Foo)\n"
"\n"
"# register the Foo class; make `g()` and `_h()` accessible via proxy\n"
"MyManager.register('Foo2', Foo, exposed=('g', '_h'))\n"
"\n"
"# register the generator function baz; use `GeneratorProxy` to make proxies\n"
"MyManager.register('baz', baz, proxytype=GeneratorProxy)\n"
"\n"
"# register get_operator_module(); make public functions accessible via "
"proxy\n"
"MyManager.register('operator', get_operator_module)\n"
"\n"
"##\n"
"\n"
"def test():\n"
"    manager = MyManager()\n"
"    manager.start()\n"
"\n"
"    print('-' * 20)\n"
"\n"
"    f1 = manager.Foo1()\n"
"    f1.f()\n"
"    f1.g()\n"
"    assert not hasattr(f1, '_h')\n"
"    assert sorted(f1._exposed_) == sorted(['f', 'g'])\n"
"\n"
"    print('-' * 20)\n"
"\n"
"    f2 = manager.Foo2()\n"
"    f2.g()\n"
"    f2._h()\n"
"    assert not hasattr(f2, 'f')\n"
"    assert sorted(f2._exposed_) == sorted(['g', '_h'])\n"
"\n"
"    print('-' * 20)\n"
"\n"
"    it = manager.baz()\n"
"    for i in it:\n"
"        print('<%d>' % i, end=' ')\n"
"    print()\n"
"\n"
"    print('-' * 20)\n"
"\n"
"    op = manager.operator()\n"
"    print('op.add(23, 45) =', op.add(23, 45))\n"
"    print('op.pow(2, 94) =', op.pow(2, 94))\n"
"    print('op._exposed_ =', op._exposed_)\n"
"\n"
"##\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    test()\n"
msgstr ""
"från multiprocessing import freeze_support\n"
"från multiprocessing.managers importera BaseManager, BaseProxy\n"
"importera operator\n"
"\n"
"##\n"
"\n"
"klass Foo:\n"
"    def f(self):\n"
"        print('du kallade Foo.f()')\n"
"    def g(self):\n"
"        print('du anropade Foo.g()')\n"
"    def _h(self):\n"
"        print('du anropade Foo._h()')\n"
"\n"
"# En enkel generatorfunktion\n"
"def baz():\n"
"    för i i intervall(10):\n"
"        avkastning i*i\n"
"\n"
"# Proxytyp för generatorobjekt\n"
"klass GeneratorProxy(BaseProxy):\n"
"    _exposed_ = ['__next__']\n"
"    def __iter__(self):\n"
"        return self\n"
"    def __next__(self):\n"
"        return self._callmethod('__next__')\n"
"\n"
"# Funktion för att returnera operatörsmodulen\n"
"def get_operator_module():\n"
"    returnera operatör\n"
"\n"
"##\n"
"\n"
"klass MyManager(BaseManager):\n"
"    pass\n"
"\n"
"# registrera Foo-klassen; gör `f()` och `g()` tillgängliga via proxy\n"
"MyManager.register('Foo1', Foo)\n"
"\n"
"# registrera Foo-klassen; gör `g()` och `_h()` tillgängliga via proxy\n"
"MyManager.register('Foo2', Foo, exposed=('g', '_h'))\n"
"\n"
"# registrera generatorfunktionen baz; använd `GeneratorProxy` för att göra "
"proxyer\n"
"MyManager.register('baz', baz, proxytyp=GeneratorProxy)\n"
"\n"
"# registrera get_operator_module(); gör offentliga funktioner tillgängliga "
"via proxy\n"
"MyManager.register('operator', get_operator_module)\n"
"\n"
"##\n"
"\n"
"def test():\n"
"    manager = MyManager()\n"
"    manager.start()\n"
"\n"
"    print('-' * 20)\n"
"\n"
"    f1 = manager.Foo1()\n"
"    f1.f()\n"
"    f1.g()\n"
"    assert not hasattr(f1, '_h')\n"
"    assert sorted(f1._exposed_) == sorted(['f', 'g'])\n"
"\n"
"    print('-' * 20)\n"
"\n"
"    f2 = manager.Foo2()\n"
"    f2.g()\n"
"    f2._h()\n"
"    assert not hasattr(f2, 'f')\n"
"    assert sorted(f2._exposed_) == sorted(['g', '_h'])\n"
"\n"
"    print('-' * 20)\n"
"\n"
"    det = manager.baz()\n"
"    för i i it:\n"
"        print('<%d>' % i, end=' ')\n"
"    print()\n"
"\n"
"    print('-' * 20)\n"
"\n"
"    op = manager.operator()\n"
"    print('op.add(23, 45) =', op.add(23, 45))\n"
"    print('op.pow(2, 94) =', op.pow(2, 94))\n"
"    print('op._exposed_ =', op._exposed_)\n"
"\n"
"##\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    test()\n"

#: ../../library/multiprocessing.rst:3171
msgid "Using :class:`~multiprocessing.pool.Pool`:"
msgstr "Använder :klass:`~multiprocessing.pool.Pool`:"

#: ../../library/multiprocessing.rst:3173
msgid ""
"import multiprocessing\n"
"import time\n"
"import random\n"
"import sys\n"
"\n"
"#\n"
"# Functions used by test code\n"
"#\n"
"\n"
"def calculate(func, args):\n"
"    result = func(*args)\n"
"    return '%s says that %s%s = %s' % (\n"
"        multiprocessing.current_process().name,\n"
"        func.__name__, args, result\n"
"        )\n"
"\n"
"def calculatestar(args):\n"
"    return calculate(*args)\n"
"\n"
"def mul(a, b):\n"
"    time.sleep(0.5 * random.random())\n"
"    return a * b\n"
"\n"
"def plus(a, b):\n"
"    time.sleep(0.5 * random.random())\n"
"    return a + b\n"
"\n"
"def f(x):\n"
"    return 1.0 / (x - 5.0)\n"
"\n"
"def pow3(x):\n"
"    return x ** 3\n"
"\n"
"def noop(x):\n"
"    pass\n"
"\n"
"#\n"
"# Test code\n"
"#\n"
"\n"
"def test():\n"
"    PROCESSES = 4\n"
"    print('Creating pool with %d processes\\n' % PROCESSES)\n"
"\n"
"    with multiprocessing.Pool(PROCESSES) as pool:\n"
"        #\n"
"        # Tests\n"
"        #\n"
"\n"
"        TASKS = [(mul, (i, 7)) for i in range(10)] + \\\n"
"                [(plus, (i, 8)) for i in range(10)]\n"
"\n"
"        results = [pool.apply_async(calculate, t) for t in TASKS]\n"
"        imap_it = pool.imap(calculatestar, TASKS)\n"
"        imap_unordered_it = pool.imap_unordered(calculatestar, TASKS)\n"
"\n"
"        print('Ordered results using pool.apply_async():')\n"
"        for r in results:\n"
"            print('\\t', r.get())\n"
"        print()\n"
"\n"
"        print('Ordered results using pool.imap():')\n"
"        for x in imap_it:\n"
"            print('\\t', x)\n"
"        print()\n"
"\n"
"        print('Unordered results using pool.imap_unordered():')\n"
"        for x in imap_unordered_it:\n"
"            print('\\t', x)\n"
"        print()\n"
"\n"
"        print('Ordered results using pool.map() --- will block till "
"complete:')\n"
"        for x in pool.map(calculatestar, TASKS):\n"
"            print('\\t', x)\n"
"        print()\n"
"\n"
"        #\n"
"        # Test error handling\n"
"        #\n"
"\n"
"        print('Testing error handling:')\n"
"\n"
"        try:\n"
"            print(pool.apply(f, (5,)))\n"
"        except ZeroDivisionError:\n"
"            print('\\tGot ZeroDivisionError as expected from pool.apply()')\n"
"        else:\n"
"            raise AssertionError('expected ZeroDivisionError')\n"
"\n"
"        try:\n"
"            print(pool.map(f, list(range(10))))\n"
"        except ZeroDivisionError:\n"
"            print('\\tGot ZeroDivisionError as expected from pool.map()')\n"
"        else:\n"
"            raise AssertionError('expected ZeroDivisionError')\n"
"\n"
"        try:\n"
"            print(list(pool.imap(f, list(range(10)))))\n"
"        except ZeroDivisionError:\n"
"            print('\\tGot ZeroDivisionError as expected from list(pool."
"imap())')\n"
"        else:\n"
"            raise AssertionError('expected ZeroDivisionError')\n"
"\n"
"        it = pool.imap(f, list(range(10)))\n"
"        for i in range(10):\n"
"            try:\n"
"                x = next(it)\n"
"            except ZeroDivisionError:\n"
"                if i == 5:\n"
"                    pass\n"
"            except StopIteration:\n"
"                break\n"
"            else:\n"
"                if i == 5:\n"
"                    raise AssertionError('expected ZeroDivisionError')\n"
"\n"
"        assert i == 9\n"
"        print('\\tGot ZeroDivisionError as expected from IMapIterator."
"next()')\n"
"        print()\n"
"\n"
"        #\n"
"        # Testing timeouts\n"
"        #\n"
"\n"
"        print('Testing ApplyResult.get() with timeout:', end=' ')\n"
"        res = pool.apply_async(calculate, TASKS[0])\n"
"        while 1:\n"
"            sys.stdout.flush()\n"
"            try:\n"
"                sys.stdout.write('\\n\\t%s' % res.get(0.02))\n"
"                break\n"
"            except multiprocessing.TimeoutError:\n"
"                sys.stdout.write('.')\n"
"        print()\n"
"        print()\n"
"\n"
"        print('Testing IMapIterator.next() with timeout:', end=' ')\n"
"        it = pool.imap(calculatestar, TASKS)\n"
"        while 1:\n"
"            sys.stdout.flush()\n"
"            try:\n"
"                sys.stdout.write('\\n\\t%s' % it.next(0.02))\n"
"            except StopIteration:\n"
"                break\n"
"            except multiprocessing.TimeoutError:\n"
"                sys.stdout.write('.')\n"
"        print()\n"
"        print()\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    multiprocessing.freeze_support()\n"
"    test()\n"
msgstr ""
"import multiprocessing\n"
"importera tid\n"
"import slump\n"
"import sys\n"
"\n"
"#\n"
"# Funktioner som används av testkod\n"
"#\n"
"\n"
"def beräkna(func, args):\n"
"    resultat = func(*args)\n"
"    return '%s säger att %s%s = %s' % (\n"
"        multiprocessing.current_process().name,\n"
"        func.__name__, args, resultat\n"
"        )\n"
"\n"
"def calculatestar(args):\n"
"    return beräkna(*args)\n"
"\n"
"def mul(a, b):\n"
"    time.sleep(0,5 * random.random())\n"
"    returnerar a * b\n"
"\n"
"def plus(a, b):\n"
"    tid.sömn(0,5 * slumpmässigt.slumpmässigt())\n"
"    returnerar a + b\n"
"\n"
"def f(x):\n"
"    returnerar 1,0 / (x - 5,0)\n"
"\n"
"def pow3(x):\n"
"    returnerar x ** 3\n"
"\n"
"def noop(x):\n"
"    passera\n"
"\n"
"#\n"
"# Testkod\n"
"#\n"
"\n"
"def test():\n"
"    PROCESSER = 4\n"
"    print('Skapar pool med %d processer\\n' % PROCESSES)\n"
"\n"
"    med multiprocessing.Pool(PROCESSES) som pool:\n"
"        #\n"
"        # Tester\n"
"        #\n"
"\n"
"        TASKS = [(mul, (i, 7)) for i in range(10)] + \\\n"
"                [(plus, (i, 8)) for i in range(10)]\n"
"\n"
"        resultat = [pool.apply_async(calculate, t) for t in TASKS]\n"
"        imap_it = pool.imap(calculatestar, TASKS)\n"
"        imap_unordered_it = pool.imap_unordered(calculatestar, TASKS)\n"
"\n"
"        print('Ordnade resultat med hjälp av pool.apply_async():')\n"
"        för r i resultat:\n"
"            print('\\t', r.get())\n"
"        print()\n"
"\n"
"        print('Ordnade resultat med hjälp av pool.imap():')\n"
"        för x i imap_it:\n"
"            print('\\t', x)\n"
"        print()\n"
"\n"
"        print('Oordnade resultat med användning av pool.imap_unordered():')\n"
"        för x i imap_unordered_it:\n"
"            print('\\t', x)\n"
"        print()\n"
"\n"
"        print('Ordnade resultat med hjälp av pool.map() --- blockeras tills "
"det är klart:')\n"
"        för x i pool.map(calculatestar, TASKS):\n"
"            print('\\t', x)\n"
"        print()\n"
"\n"
"        #\n"
"        # Felhantering vid test\n"
"        #\n"
"\n"
"        print('Testar felhantering:')\n"
"\n"
"        försök:\n"
"            print(pool.apply(f, (5,))))\n"
"        utom ZeroDivisionError:\n"
"            print('\\tFick ZeroDivisionError som förväntat från pool."
"apply()')\n"
"        else:\n"
"            raise AssertionError('förväntat ZeroDivisionError')\n"
"\n"
"        försök:\n"
"            print(pool.map(f, list(intervall(10))))\n"
"        except ZeroDivisionError:\n"
"            print('\\tFick ZeroDivisionError som förväntat från pool."
"map()')\n"
"        else:\n"
"            raise AssertionError('förväntat ZeroDivisionError')\n"
"\n"
"        försök:\n"
"            print(list(pool.imap(f, list(intervall(10)))))\n"
"        except ZeroDivisionError:\n"
"            print('\\tFick ZeroDivisionError som förväntat från list(pool."
"imap())')\n"
"        else:\n"
"            raise AssertionError('förväntat ZeroDivisionError')\n"
"\n"
"        it = pool.imap(f, list(range(10))))\n"
"        för i i intervall(10):\n"
"            försök:\n"
"                x = nästa(it)\n"
"            except ZeroDivisionError:\n"
"                om i == 5:\n"
"                    pass\n"
"            except Stoppa iteration:\n"
"                break\n"
"            else:\n"
"                om i == 5:\n"
"                    raise AssertionError('förväntat nolldivisionsfel')\n"
"\n"
"        assert i == 9\n"
"        print('\\tGick ZeroDivisionError som förväntat från IMapIterator."
"next()')\n"
"        print()\n"
"\n"
"        #\n"
"        # Testa tidsgränser\n"
"        #\n"
"\n"
"        print('Testar ApplyResult.get() med timeout:', end=' ')\n"
"        res = pool.apply_async(beräkna, TASKS[0])\n"
"        while 1:\n"
"            sys.stdout.flush()\n"
"            försök:\n"
"                sys.stdout.write('\\n\\t%s' % res.get(0.02))\n"
"                break\n"
"            except multiprocessing.TimeoutError:\n"
"                sys.stdout.write('.')\n"
"        skriv ut()\n"
"        skriv ut()\n"
"\n"
"        print('Testar IMapIterator.next() med timeout:', end=' ')\n"
"        it = pool.imap(calculatestar, TASKS)\n"
"        while 1:\n"
"            sys.stdout.flush()\n"
"            försök:\n"
"                sys.stdout.write('\\n\\t%s' % it.next(0.02))\n"
"            except StopIteration:\n"
"                break\n"
"            except multiprocessing.TimeoutError:\n"
"                sys.stdout.write('.')\n"
"        print()\n"
"        skriv ut()\n"
"\n"
"\n"
"om __name__ == '__main__':\n"
"    multiprocessing.freeze_support()\n"
"    test()\n"

#: ../../library/multiprocessing.rst:3177
msgid ""
"An example showing how to use queues to feed tasks to a collection of worker "
"processes and collect the results:"
msgstr ""
"Ett exempel som visar hur man använder köer för att mata uppgifter till en "
"samling arbetsprocesser och samla in resultaten:"

#: ../../library/multiprocessing.rst:3180
msgid ""
"import time\n"
"import random\n"
"\n"
"from multiprocessing import Process, Queue, current_process, freeze_support\n"
"\n"
"#\n"
"# Function run by worker processes\n"
"#\n"
"\n"
"def worker(input, output):\n"
"    for func, args in iter(input.get, 'STOP'):\n"
"        result = calculate(func, args)\n"
"        output.put(result)\n"
"\n"
"#\n"
"# Function used to calculate result\n"
"#\n"
"\n"
"def calculate(func, args):\n"
"    result = func(*args)\n"
"    return '%s says that %s%s = %s' % \\\n"
"        (current_process().name, func.__name__, args, result)\n"
"\n"
"#\n"
"# Functions referenced by tasks\n"
"#\n"
"\n"
"def mul(a, b):\n"
"    time.sleep(0.5*random.random())\n"
"    return a * b\n"
"\n"
"def plus(a, b):\n"
"    time.sleep(0.5*random.random())\n"
"    return a + b\n"
"\n"
"#\n"
"#\n"
"#\n"
"\n"
"def test():\n"
"    NUMBER_OF_PROCESSES = 4\n"
"    TASKS1 = [(mul, (i, 7)) for i in range(20)]\n"
"    TASKS2 = [(plus, (i, 8)) for i in range(10)]\n"
"\n"
"    # Create queues\n"
"    task_queue = Queue()\n"
"    done_queue = Queue()\n"
"\n"
"    # Submit tasks\n"
"    for task in TASKS1:\n"
"        task_queue.put(task)\n"
"\n"
"    # Start worker processes\n"
"    for i in range(NUMBER_OF_PROCESSES):\n"
"        Process(target=worker, args=(task_queue, done_queue)).start()\n"
"\n"
"    # Get and print results\n"
"    print('Unordered results:')\n"
"    for i in range(len(TASKS1)):\n"
"        print('\\t', done_queue.get())\n"
"\n"
"    # Add more tasks using `put()`\n"
"    for task in TASKS2:\n"
"        task_queue.put(task)\n"
"\n"
"    # Get and print some more results\n"
"    for i in range(len(TASKS2)):\n"
"        print('\\t', done_queue.get())\n"
"\n"
"    # Tell child processes to stop\n"
"    for i in range(NUMBER_OF_PROCESSES):\n"
"        task_queue.put('STOP')\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    test()\n"
msgstr ""
"importera tid\n"
"importera slump\n"
"\n"
"from multiprocessing import Process, Kö, current_process, freeze_support\n"
"\n"
"#\n"
"# Funktion som körs av arbetsprocesser\n"
"#\n"
"\n"
"def worker(input, output):\n"
"    for func, args in iter(input.get, 'STOP'):\n"
"        resultat = beräkna(func, args)\n"
"        output.put(resultat)\n"
"\n"
"#\n"
"# Funktion som används för att beräkna resultat\n"
"#\n"
"\n"
"def beräkna(func, args):\n"
"    resultat = func(*args)\n"
"    return '%s säger att %s%s = %s' % \\\n"
"        (aktuell_process().namn, func.__name__, args, resultat)\n"
"\n"
"#\n"
"# Funktioner som refereras av uppgifter\n"
"#\n"
"\n"
"def mul(a, b):\n"
"    time.sleep(0.5*random.random())\n"
"    returnerar a * b\n"
"\n"
"def plus(a, b):\n"
"    time.sleep(0.5*slumpmässigt.slumpmässigt())\n"
"    returnerar a + b\n"
"\n"
"#\n"
"#\n"
"#\n"
"\n"
"def test():\n"
"    ANTAL_AV_PROCESSER = 4\n"
"    UPPGIFTER1 = [(mul, (i, 7)) för i i intervallet(20)]\n"
"    UPPGIFTER2 = [(plus, (i, 8)) for i in range(10)]\n"
"\n"
"    # Skapa köer\n"
"    task_queue = kö()\n"
"    done_queue = kö()\n"
"\n"
"    # Skicka in uppgifter\n"
"    för uppgift i TASKS1:\n"
"        task_queue.put(uppgift)\n"
"\n"
"    # Starta arbetsprocesser\n"
"    for i in range(NUMBER_OF_PROCESSES):\n"
"        Process(target=arbetare, args=(task_queue, done_queue)).start()\n"
"\n"
"    # Hämta och skriv ut resultat\n"
"    print('Oordnade resultat:')\n"
"    for i in range(len(TASKS1)):\n"
"        print('\\t', done_queue.get())\n"
"\n"
"    # Lägg till fler uppgifter med hjälp av `put()`\n"
"    för uppgift i TASKS2:\n"
"        task_queue.put(uppgift)\n"
"\n"
"    # Hämta och skriv ut några fler resultat\n"
"    for i in range(len(TASKS2)):\n"
"        print('\\t', done_queue.get())\n"
"\n"
"    # Säg åt underordnade processer att sluta\n"
"    for i in range(NUMBER_OF_PROCESSES):\n"
"        task_queue.put('STOP')\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    test()\n"
