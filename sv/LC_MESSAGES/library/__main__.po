# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-17 17:19+0000\n"
"PO-Revision-Date: 2025-09-22 15:57+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../library/__main__.rst:2
msgid ":mod:`__main__` --- Top-level code environment"
msgstr ""

#: ../../library/__main__.rst:10
msgid ""
"In Python, the special name ``__main__`` is used for two important "
"constructs:"
msgstr ""
"I Python används det speciella namnet ``__main__`` för två viktiga "
"konstruktioner:"

#: ../../library/__main__.rst:12
msgid ""
"the name of the top-level environment of the program, which can be checked "
"using the ``__name__ == '__main__'`` expression; and"
msgstr ""
"namnet på programmets toppnivåmiljö, vilket kan kontrolleras med hjälp av "
"uttrycket ``__name__ == '__main__'``; och"

#: ../../library/__main__.rst:14
msgid "the ``__main__.py`` file in Python packages."
msgstr "filen ``__main__.py`` i Python-paket."

#: ../../library/__main__.rst:16
msgid ""
"Both of these mechanisms are related to Python modules; how users interact "
"with them and how they interact with each other.  They are explained in "
"detail below.  If you're new to Python modules, see the tutorial section :"
"ref:`tut-modules` for an introduction."
msgstr ""
"Båda dessa mekanismer är relaterade till Python-moduler; hur användare "
"interagerar med dem och hur de interagerar med varandra.  De förklaras i "
"detalj nedan.  Om du är nybörjare på Python-moduler, se avsnittet om "
"självstudier :ref:`tut-modules` för en introduktion."

#: ../../library/__main__.rst:25
msgid "``__name__ == '__main__'``"
msgstr "``__name__ == '__main__'``"

#: ../../library/__main__.rst:27
msgid ""
"When a Python module or package is imported, ``__name__`` is set to the "
"module's name.  Usually, this is the name of the Python file itself without "
"the ``.py`` extension::"
msgstr ""
"När en Python-modul eller ett Python-paket importeras sätts ``__name__`` "
"till modulens namn.  Vanligtvis är detta namnet på själva Python-filen utan "
"tillägget ``.py``::"

#: ../../library/__main__.rst:35
msgid ""
"If the file is part of a package, ``__name__`` will also include the parent "
"package's path::"
msgstr ""
"Om filen är en del av ett paket kommer ``__name__`` också att inkludera det "
"överordnade paketets sökväg::"

#: ../../library/__main__.rst:42
msgid ""
"However, if the module is executed in the top-level code environment, its "
"``__name__`` is set to the string ``'__main__'``."
msgstr ""
"Men om modulen körs i kodmiljön på högsta nivån sätts dess ``__name__`` till "
"strängen ``'__main__'``."

#: ../../library/__main__.rst:46
msgid "What is the \"top-level code environment\"?"
msgstr "Vad är \"kodmiljön på högsta nivå\"?"

#: ../../library/__main__.rst:48
msgid ""
"``__main__`` is the name of the environment where top-level code is run. "
"\"Top-level code\" is the first user-specified Python module that starts "
"running. It's \"top-level\" because it imports all other modules that the "
"program needs. Sometimes \"top-level code\" is called an *entry point* to "
"the application."
msgstr ""
"``__main__`` är namnet på den miljö där toppnivåkoden körs. \"Toppnivåkod\" "
"är den första användarspecificerade Python-modulen som börjar köras. Den är "
"\"toppnivå\" eftersom den importerar alla andra moduler som programmet "
"behöver. Ibland kallas \"toppnivåkoden\" för en *ingångspunkt* till "
"programmet."

#: ../../library/__main__.rst:53
msgid "The top-level code environment can be:"
msgstr "Kodmiljön på högsta nivå kan vara:"

#: ../../library/__main__.rst:55
msgid "the scope of an interactive prompt::"
msgstr "omfattningen av en interaktiv uppmaning::"

#: ../../library/__main__.rst:60
msgid "the Python module passed to the Python interpreter as a file argument:"
msgstr "den Python-modul som skickas till Python-tolken som ett filargument:"

#: ../../library/__main__.rst:67
msgid ""
"the Python module or package passed to the Python interpreter with the :"
"option:`-m` argument:"
msgstr ""
"den Python-modul eller det Python-paket som skickas till Python-tolken med :"
"option:`\\-m`\\-argumentet:"

#: ../../library/__main__.rst:75
msgid "Python code read by the Python interpreter from standard input:"
msgstr "Python-kod som läses av Python-tolken från standardinmatningen:"

#: ../../library/__main__.rst:86
msgid ""
"Python code passed to the Python interpreter with the :option:`-c` argument:"
msgstr ""
"Python-kod som skickas till Python-tolken med argumentet :option:`\\-c`:"

#: ../../library/__main__.rst:97
msgid ""
"In each of these situations, the top-level module's ``__name__`` is set to "
"``'__main__'``."
msgstr ""
"I alla dessa situationer sätts toppmodulens ``__name__`` till ``'__main__'``."

#: ../../library/__main__.rst:100
msgid ""
"As a result, a module can discover whether or not it is running in the top-"
"level environment by checking its own ``__name__``, which allows a common "
"idiom for conditionally executing code when the module is not initialized "
"from an import statement::"
msgstr ""
"En modul kan därför upptäcka om den körs i toppnivåmiljön eller inte genom "
"att kontrollera sitt eget ``__name__``, vilket möjliggör ett vanligt idiom "
"för villkorlig exekvering av kod när modulen inte initieras från en "
"importsats::"

#: ../../library/__main__.rst:111
msgid ""
"For a more detailed look at how ``__name__`` is set in all situations, see "
"the tutorial section :ref:`tut-modules`."
msgstr ""
"För en mer detaljerad titt på hur ``__name__`` ställs in i alla situationer, "
"se handledningsavsnittet :ref:`tut-modules`."

#: ../../library/__main__.rst:116 ../../library/__main__.rst:239
msgid "Idiomatic Usage"
msgstr "Idiomatisk användning"

#: ../../library/__main__.rst:118
msgid ""
"Some modules contain code that is intended for script use only, like parsing "
"command-line arguments or fetching data from standard input.  If a module "
"like this was imported from a different module, for example to unit test it, "
"the script code would unintentionally execute as well."
msgstr ""
"Vissa moduler innehåller kod som endast är avsedd för skriptanvändning, t."
"ex. parsning av kommandoradsargument eller hämtning av data från "
"standardinmatning.  Om en sådan modul importeras från en annan modul, t.ex. "
"för att enhetstesta den, skulle skriptkoden oavsiktligt också exekveras."

#: ../../library/__main__.rst:123
msgid ""
"This is where using the ``if __name__ == '__main__'`` code block comes in "
"handy. Code within this block won't run unless the module is executed in the "
"top-level environment."
msgstr ""
"Det är här som kodblocket ``if __name__ == '__main__'`` kommer väl till "
"pass. Kod inom detta block kommer inte att köras om inte modulen exekveras i "
"miljön på högsta nivå."

#: ../../library/__main__.rst:127
msgid ""
"Putting as few statements as possible in the block below ``if __name___ == "
"'__main__'`` can improve code clarity and correctness. Most often, a "
"function named ``main`` encapsulates the program's primary behavior::"
msgstr ""

#: ../../library/__main__.rst:151
msgid ""
"Note that if the module didn't encapsulate code inside the ``main`` function "
"but instead put it directly within the ``if __name__ == '__main__'`` block, "
"the ``phrase`` variable would be global to the entire module.  This is error-"
"prone as other functions within the module could be unintentionally using "
"the global variable instead of a local name.  A ``main`` function solves "
"this problem."
msgstr ""
"Observera att om modulen inte kapslade in koden i funktionen ``main`` utan "
"istället lade den direkt i blocket ``if __name__ == '__main__'``, skulle "
"variabeln ``phrase`` vara global för hela modulen.  Detta är felbenäget "
"eftersom andra funktioner inom modulen oavsiktligt kan använda den globala "
"variabeln istället för ett lokalt namn.  En ``main``\\-funktion löser detta "
"problem."

#: ../../library/__main__.rst:158
msgid ""
"Using a ``main`` function has the added benefit of the ``echo`` function "
"itself being isolated and importable elsewhere. When ``echo.py`` is "
"imported, the ``echo`` and ``main`` functions will be defined, but neither "
"of them will be called, because ``__name__ != '__main__'``."
msgstr ""
"Att använda en ``main`` -funktion har den extra fördelen att ``echo`` -"
"funktionen i sig isoleras och kan importeras till andra ställen. När ``echo."
"py`` importeras kommer funktionerna ``echo`` och ``main`` att definieras, "
"men ingen av dem kommer att anropas, eftersom ``__name__ != '__main__'``."

#: ../../library/__main__.rst:165
msgid "Packaging Considerations"
msgstr "Överväganden om förpackningar"

#: ../../library/__main__.rst:167
msgid ""
"``main`` functions are often used to create command-line tools by specifying "
"them as entry points for console scripts.  When this is done, `pip <https://"
"pip.pypa.io/>`_ inserts the function call into a template script, where the "
"return value of ``main`` is passed into :func:`sys.exit`. For example::"
msgstr ""
"``main`` -funktioner används ofta för att skapa kommandoradsverktyg genom "
"att ange dem som ingångspunkter för konsolskript. När detta görs infogar "
"`pip <https://pip.pypa.io/>`_ funktionsanropet i ett mallscript, där "
"returvärdet för ``main`` skickas till :func:`sys.exit`. Till exempel::"

#: ../../library/__main__.rst:175
msgid ""
"Since the call to ``main`` is wrapped in :func:`sys.exit`, the expectation "
"is that your function will return some value acceptable as an input to :func:"
"`sys.exit`; typically, an integer or ``None`` (which is implicitly returned "
"if your function does not have a return statement)."
msgstr ""
"Eftersom anropet till ``main`` är inkapslat i :func:`sys.exit`, förväntas "
"din funktion returnera något värde som kan accepteras som indata till :func:"
"`sys.exit`; vanligtvis ett heltal eller ``None`` (som returneras implicit om "
"din funktion inte har ett return-svar)."

#: ../../library/__main__.rst:180
msgid ""
"By proactively following this convention ourselves, our module will have the "
"same behavior when run directly (i.e. ``python3 echo.py``) as it will have "
"if we later package it as a console script entry-point in a pip-installable "
"package."
msgstr ""

#: ../../library/__main__.rst:185
msgid ""
"In particular, be careful about returning strings from your ``main`` "
"function. :func:`sys.exit` will interpret a string argument as a failure "
"message, so your program will have an exit code of ``1``, indicating "
"failure, and the string will be written to :data:`sys.stderr`.  The ``echo."
"py`` example from earlier exemplifies using the ``sys.exit(main())`` "
"convention."
msgstr ""
"Var särskilt försiktig med att returnera strängar från din ``main`` -"
"funktion. :func:`sys.exit` tolkar ett strängargument som ett felmeddelande, "
"så ditt program får en avslutningskod på ``1``, vilket indikerar fel, och "
"strängen skrivs till :data:`sys.stderr`. Exemplet ``echo.py`` från tidigare "
"visar hur man använder konventionen ``sys.exit(main())``."

#: ../../library/__main__.rst:193
msgid ""
"`Python Packaging User Guide <https://packaging.python.org/>`_ contains a "
"collection of tutorials and references on how to distribute and install "
"Python packages with modern tools."
msgstr ""
"`Användarhandbok för Python Packaging <https://packaging.python.org/>`_ "
"innehåller en samling handledningar och referenser om hur man distribuerar "
"och installerar Python-paket med moderna verktyg."

#: ../../library/__main__.rst:199
msgid "``__main__.py`` in Python Packages"
msgstr "``__main__.py`` i Python-paket"

#: ../../library/__main__.rst:201
msgid ""
"If you are not familiar with Python packages, see section :ref:`tut-"
"packages` of the tutorial.  Most commonly, the ``__main__.py`` file is used "
"to provide a command-line interface for a package. Consider the following "
"hypothetical package, \"bandclass\":"
msgstr ""
"Om du inte är bekant med Python-paket, se avsnitt :ref:`tut-packages` i "
"handledningen.  Vanligtvis används filen ``__main__.py`` för att "
"tillhandahålla ett kommandoradsgränssnitt för ett paket. Tänk på följande "
"hypotetiska paket, \"bandclass\":"

#: ../../library/__main__.rst:213
msgid ""
"``__main__.py`` will be executed when the package itself is invoked directly "
"from the command line using the :option:`-m` flag. For example:"
msgstr ""
"``__main__.py`` kommer att exekveras när själva paketet anropas direkt från "
"kommandoraden med hjälp av flaggan :option:`\\-m`. Till exempel"

#: ../../library/__main__.rst:220
msgid ""
"This command will cause ``__main__.py`` to run. How you utilize this "
"mechanism will depend on the nature of the package you are writing, but in "
"this hypothetical case, it might make sense to allow the teacher to search "
"for students::"
msgstr ""
"Detta kommando kommer att få ``__main__.py`` att köras. Hur du använder den "
"här mekanismen beror på hur paketet du skriver ser ut, men i det här "
"hypotetiska fallet kan det vara vettigt att låta läraren söka efter elever::"

#: ../../library/__main__.rst:233
msgid ""
"Note that ``from .student import search_students`` is an example of a "
"relative import.  This import style can be used when referencing modules "
"within a package.  For more details, see :ref:`intra-package-references` in "
"the :ref:`tut-modules` section of the tutorial."
msgstr ""
"Observera att ``from .student import search_students`` är ett exempel på en "
"relativ import.  Denna importstil kan användas när man refererar till "
"moduler inom ett paket.  Mer information finns i :ref:`intra-package-"
"references` i avsnittet :ref:`tut-modules` i självstudien."

#: ../../library/__main__.rst:241
msgid ""
"The contents of ``__main__.py`` typically isn't fenced with ``if __name__ == "
"'__main__'`` blocks.  Instead, those files are kept short, functions to "
"execute from other modules.  Those other modules can then be easily unit-"
"tested and are properly reusable."
msgstr ""

#: ../../library/__main__.rst:246
msgid ""
"If used, an ``if __name__ == '__main__'`` block will still work as expected "
"for a ``__main__.py`` file within a package, because its ``__name__`` "
"attribute will include the package's path if imported::"
msgstr ""
"Om det används kommer ett ``if __name__ == '__main__'`` -block fortfarande "
"att fungera som förväntat för en ``__main__.py`` -fil i ett paket, eftersom "
"dess ``__name__`` -attribut kommer att inkludera paketets sökväg om det "
"importeras::"

#: ../../library/__main__.rst:254
msgid ""
"This won't work for ``__main__.py`` files in the root directory of a .zip "
"file though.  Hence, for consistency, minimal ``__main__.py`` like the :mod:"
"`venv` one mentioned below are preferred."
msgstr ""

#: ../../library/__main__.rst:260
msgid ""
"See :mod:`venv` for an example of a package with a minimal ``__main__.py`` "
"in the standard library. It doesn't contain a ``if __name__ == '__main__'`` "
"block. You can invoke it with ``python -m venv [directory]``."
msgstr ""
"Se :mod:`venv` för ett exempel på ett paket med en minimal ``__main__.py`` i "
"standardbiblioteket. Den innehåller inte ett ``if __name__ == '__main__'`` -"
"block. Du kan anropa den med ``python -m venv [directory]``."

#: ../../library/__main__.rst:264
msgid ""
"See :mod:`runpy` for more details on the :option:`-m` flag to the "
"interpreter executable."
msgstr ""
"Se :mod:`runpy` för mer information om :option:`\\-m`\\-flaggan till tolkens "
"körbara fil."

#: ../../library/__main__.rst:267
msgid ""
"See :mod:`zipapp` for how to run applications packaged as *.zip* files. In "
"this case Python looks for a ``__main__.py`` file in the root directory of "
"the archive."
msgstr ""
"Se :mod:`zipapp` för hur man kör program som paketerats som *.zip*-filer. I "
"det här fallet letar Python efter en fil med namnet ``__main__.py`` i "
"arkivets rotkatalog."

#: ../../library/__main__.rst:274
msgid "``import __main__``"
msgstr "``import __main__``"

#: ../../library/__main__.rst:276
msgid ""
"Regardless of which module a Python program was started with, other modules "
"running within that same program can import the top-level environment's "
"scope (:term:`namespace`) by importing the ``__main__`` module.  This "
"doesn't import a ``__main__.py`` file but rather whichever module that "
"received the special name ``'__main__'``."
msgstr ""
"Oavsett vilken modul ett Python-program startades med, kan andra moduler som "
"körs inom samma program importera toppnivåmiljöns scope (:term:`namespace`) "
"genom att importera modulen ``__main__``.  Detta innebär inte import av "
"filen ``__main__.py`` utan snarare av den modul som fått det speciella "
"namnet ``'__main__'``."

#: ../../library/__main__.rst:282
msgid "Here is an example module that consumes the ``__main__`` namespace::"
msgstr "Här är ett exempel på en modul som använder namnrymden ``__main__``::"

#: ../../library/__main__.rst:300
msgid "Example usage of this module could be as follows::"
msgstr "Exempel på användning av denna modul kan vara följande::"

#: ../../library/__main__.rst:319
msgid "Now, if we started our program, the result would look like this:"
msgstr "Om vi nu startade vårt program skulle resultatet se ut så här:"

#: ../../library/__main__.rst:326
msgid ""
"The exit code of the program would be 1, indicating an error. Uncommenting "
"the line with ``my_name = \"Dinsdale\"`` fixes the program and now it exits "
"with status code 0, indicating success:"
msgstr ""
"Programmets utgångskod skulle vara 1, vilket indikerar ett fel. Om du "
"avkommenterar raden med ``my_name = \"Dinsdale\"`` åtgärdas programmet och "
"nu avslutas det med statuskod 0, vilket indikerar framgång:"

#: ../../library/__main__.rst:335
msgid ""
"Note that importing ``__main__`` doesn't cause any issues with "
"unintentionally running top-level code meant for script use which is put in "
"the ``if __name__ == \"__main__\"`` block of the ``start`` module. Why does "
"this work?"
msgstr ""
"Observera att import av ``__main__`` inte orsakar några problem med att "
"oavsiktligt köra toppnivåkod avsedd för skriptanvändning som finns i blocket "
"``if __name__ == \"__main__\"`` i modulen ``start``. Varför fungerar detta?"

#: ../../library/__main__.rst:339
msgid ""
"Python inserts an empty ``__main__`` module in :attr:`sys.modules` at "
"interpreter startup, and populates it by running top-level code. In our "
"example this is the ``start`` module which runs line by line and imports "
"``namely``. In turn, ``namely`` imports ``__main__`` (which is really "
"``start``). That's an import cycle! Fortunately, since the partially "
"populated ``__main__`` module is present in :attr:`sys.modules`, Python "
"passes that to ``namely``. See :ref:`Special considerations for __main__ "
"<import-dunder-main>` in the import system's reference for details on how "
"this works."
msgstr ""

#: ../../library/__main__.rst:348
msgid ""
"The Python REPL is another example of a \"top-level environment\", so "
"anything defined in the REPL becomes part of the ``__main__`` scope::"
msgstr ""
"Python REPL är ett annat exempel på en \"toppnivåmiljö\", så allt som "
"definieras i REPL blir en del av ``__main__`` scope::"

#: ../../library/__main__.rst:364
msgid ""
"Note that in this case the ``__main__`` scope doesn't contain a ``__file__`` "
"attribute as it's interactive."
msgstr ""

#: ../../library/__main__.rst:367
msgid ""
"The ``__main__`` scope is used in the implementation of :mod:`pdb` and :mod:"
"`rlcompleter`."
msgstr ""
"Scope ``__main__`` används i implementeringen av :mod:`pdb` och :mod:"
"`rlcompleter`."
