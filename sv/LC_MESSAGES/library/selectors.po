# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-16 17:23+0000\n"
"PO-Revision-Date: 2025-09-16 00:01+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../library/selectors.rst:2
msgid ":mod:`!selectors` --- High-level I/O multiplexing"
msgstr ":mod:`!selectors` --- I/O-multiplexering på hög nivå"

#: ../../library/selectors.rst:9
msgid "**Source code:** :source:`Lib/selectors.py`"
msgstr "**Källkod:** :source:`Lib/selectors.py`"

#: ../../library/selectors.rst:14
msgid "Introduction"
msgstr "Introduktion"

#: ../../library/selectors.rst:16
msgid ""
"This module allows high-level and efficient I/O multiplexing, built upon "
"the :mod:`select` module primitives. Users are encouraged to use this module "
"instead, unless they want precise control over the OS-level primitives used."
msgstr ""
"Den här modulen möjliggör effektiv I/O-multiplexering på hög nivå och bygger "
"på :mod:`select`\\-modulens primitiver. Användare uppmanas att använda den "
"här modulen istället, såvida de inte vill ha exakt kontroll över de "
"primitiver på OS-nivå som används."

#: ../../library/selectors.rst:20
msgid ""
"It defines a :class:`BaseSelector` abstract base class, along with several "
"concrete implementations "
"(:class:`KqueueSelector`, :class:`EpollSelector`...), that can be used to "
"wait for I/O readiness notification on multiple file objects. In the "
"following, \"file object\" refers to any object with "
"a :meth:`~io.IOBase.fileno` method, or a raw file descriptor. "
"See :term:`file object`."
msgstr ""
"Den definierar en :class:`BaseSelector` abstrakt basklass, tillsammans med "
"flera konkreta implementationer "
"(:class:`KqueueSelector`, :class:`EpollSelector`...), som kan användas för "
"att vänta på I/O-beredskapsmeddelande på flera filobjekt. I det följande "
"avser \"filobjekt\" alla objekt med en :meth:`~io.IOBase.fileno`\\-metod "
"eller en rå filbeskrivare. Se :term:`filobjekt`."

#: ../../library/selectors.rst:26
msgid ""
":class:`DefaultSelector` is an alias to the most efficient implementation "
"available on the current platform: this should be the default choice for "
"most users."
msgstr ""
":class:`DefaultSelector` är ett alias för den mest effektiva "
"implementationen som finns tillgänglig på den aktuella plattformen: detta "
"bör vara standardvalet för de flesta användare."

#: ../../library/selectors.rst:31
msgid ""
"The type of file objects supported depends on the platform: on Windows, "
"sockets are supported, but not pipes, whereas on Unix, both are supported "
"(some other types may be supported as well, such as fifos or special file "
"devices)."
msgstr ""
"Vilken typ av filobjekt som stöds beror på plattformen: på Windows stöds "
"sockets, men inte pipes, medan båda stöds på Unix (vissa andra typer kan "
"också stödjas, t.ex. fifos eller speciella filenheter)."

#: ../../library/selectors.rst:38
msgid ":mod:`select`"
msgstr ":mod:`välja`"

#: ../../library/selectors.rst:39
msgid "Low-level I/O multiplexing module."
msgstr "Modul för I/O-multiplexering på låg nivå."

#: ../../includes/wasm-notavail.rst:3
msgid "Availability"
msgstr "Tillgänglighet"

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly. See :ref:`wasm-"
"availability` for more information."
msgstr ""
"Den här modulen fungerar inte eller är inte tillgänglig på WebAssembly. "
"Se :ref:`wasm-availability` för mer information."

#: ../../library/selectors.rst:44
msgid "Classes"
msgstr "Klasser"

#: ../../library/selectors.rst:46
msgid "Classes hierarchy::"
msgstr "Klasser-hierarki::"

#: ../../library/selectors.rst:48
msgid ""
"BaseSelector\n"
"+-- SelectSelector\n"
"+-- PollSelector\n"
"+-- EpollSelector\n"
"+-- DevpollSelector\n"
"+-- KqueueSelector"
msgstr ""
"BaseSelector\n"
"+-- SelectSelector\n"
"+-- PollSelector\n"
"+-- EpollSelector\n"
"+-- DevpollSelector\n"
"+-- KqueueSelector"

#: ../../library/selectors.rst:56
msgid ""
"In the following, *events* is a bitwise mask indicating which I/O events "
"should be waited for on a given file object. It can be a combination of the "
"modules constants below:"
msgstr ""
"I det följande är *events* en bitvis mask som anger vilka I/O-händelser som "
"ska inväntas för ett visst filobjekt. Den kan vara en kombination av "
"modulkonstanterna nedan:"

#: ../../library/selectors.rst:61
msgid "Constant"
msgstr "Konstant"

#: ../../library/selectors.rst:61
msgid "Meaning"
msgstr "Betydelse"

#: ../../library/selectors.rst:63
msgid "Available for read"
msgstr "Tillgänglig för läsning"

#: ../../library/selectors.rst:65
msgid "Available for write"
msgstr "Tillgänglig för skrivning"

#: ../../library/selectors.rst:71
msgid ""
"A :class:`SelectorKey` is a :class:`~collections.namedtuple` used to "
"associate a file object to its underlying file descriptor, selected event "
"mask and attached data. It is returned by several :class:`BaseSelector` "
"methods."
msgstr ""
"En :class:`SelectorKey` är en :class:`~collections.namedtuple` som används "
"för att associera ett filobjekt till dess underliggande filbeskrivning, "
"valda händelsemask och bifogade data. Den returneras av "
"flera :class:`BaseSelector`\\-metoder."

#: ../../library/selectors.rst:78
msgid "File object registered."
msgstr "Filobjekt registrerat."

#: ../../library/selectors.rst:82
msgid "Underlying file descriptor."
msgstr "Underliggande filbeskrivare."

#: ../../library/selectors.rst:86
msgid "Events that must be waited for on this file object."
msgstr "Händelser som måste inväntas för detta filobjekt."

#: ../../library/selectors.rst:90
msgid ""
"Optional opaque data associated to this file object: for example, this could "
"be used to store a per-client session ID."
msgstr ""
"Valfri opak data som är kopplad till filobjektet: kan t.ex. användas för att "
"lagra ett sessions-ID för varje klient."

#: ../../library/selectors.rst:96
msgid ""
"A :class:`BaseSelector` is used to wait for I/O event readiness on multiple "
"file objects. It supports file stream registration, unregistration, and a "
"method to wait for I/O events on those streams, with an optional timeout. "
"It's an abstract base class, so cannot be instantiated. "
"Use :class:`DefaultSelector` instead, or one "
"of :class:`SelectSelector`, :class:`KqueueSelector` etc. if you want to "
"specifically use an implementation, and your platform supports "
"it. :class:`BaseSelector` and its concrete implementations support "
"the :term:`context manager` protocol."
msgstr ""
"En :class:`BaseSelector` används för att vänta på I/O-händelser på flera "
"filobjekt. Den stöder registrering och avregistrering av filströmmar och en "
"metod för att vänta på I/O-händelser i dessa strömmar, med en valfri "
"timeout. Det är en abstrakt basklass, så den kan inte instansieras. "
"Använd :class:`DefaultSelector` istället, eller en "
"av :class:`SelectSelector`, :class:`KqueueSelector` etc. om du specifikt "
"vill använda en implementation, och din plattform stödjer "
"det. :class:`BaseSelector` och dess konkreta implementationer "
"stödjer :term:`context manager` protokollet."

#: ../../library/selectors.rst:109
msgid "Register a file object for selection, monitoring it for I/O events."
msgstr "Registrera ett filobjekt för val och övervaka det för I/O-händelser."

#: ../../library/selectors.rst:111
msgid ""
"*fileobj* is the file object to monitor.  It may either be an integer file "
"descriptor or an object with a ``fileno()`` method. *events* is a bitwise "
"mask of events to monitor. *data* is an opaque object."
msgstr ""
"*fileobj* är det filobjekt som ska övervakas.  Det kan antingen vara en "
"filbeskrivare med heltal eller ett objekt med en ``fileno()``\\-metod. "
"*events* är en bitvis mask av händelser som ska övervakas. *data* är ett "
"opakt objekt."

#: ../../library/selectors.rst:116
msgid ""
"This returns a new :class:`SelectorKey` instance, or raises "
"a :exc:`ValueError` in case of invalid event mask or file descriptor, "
"or :exc:`KeyError` if the file object is already registered."
msgstr ""
"Detta returnerar en ny :class:`SelectorKey`\\-instans, eller ger upphov till "
"ett :exc:`ValueError` om händelsemasken eller filbeskrivningen är ogiltig, "
"eller :exc:`KeyError` om filobjektet redan är registrerat."

#: ../../library/selectors.rst:123
msgid ""
"Unregister a file object from selection, removing it from monitoring. A file "
"object shall be unregistered prior to being closed."
msgstr ""
"Avregistrera ett filobjekt från urvalet och ta bort det från övervakning. "
"Ett filobjekt ska avregistreras innan det stängs."

#: ../../library/selectors.rst:126
msgid "*fileobj* must be a file object previously registered."
msgstr "*fileobj* måste vara ett filobjekt som tidigare registrerats."

#: ../../library/selectors.rst:128
msgid ""
"This returns the associated :class:`SelectorKey` instance, or raises "
"a :exc:`KeyError` if *fileobj* is not registered.  It will "
"raise :exc:`ValueError` if *fileobj* is invalid (e.g. it has no ``fileno()`` "
"method or its ``fileno()`` method has an invalid return value)."
msgstr ""
"Detta returnerar den associerade :class:`SelectorKey`\\-instansen, eller ger "
"upphov till :exc:`KeyError` om *fileobj* inte är registrerad.  Den ger "
"upphov till :exc:`ValueError` om *fileobj* är ogiltig (t.ex. om den inte har "
"någon ``fileno()``\\-metod eller om dess ``fileno()``\\-metod har ett "
"ogiltigt returvärde)."

#: ../../library/selectors.rst:135
msgid "Change a registered file object's monitored events or attached data."
msgstr ""
"Ändra ett registrerat filobjekts övervakade händelser eller bifogade data."

#: ../../library/selectors.rst:137
msgid ""
"This is equivalent to ``BaseSelector.unregister(fileobj)`` followed by "
"``BaseSelector.register(fileobj, events, data)``, except that it can be "
"implemented more efficiently."
msgstr ""
"Detta är likvärdigt med ``BaseSelector.unregister(fileobj)`` följt av "
"``BaseSelector.register(fileobj, events, data)``, förutom att det kan "
"implementeras mer effektivt."

#: ../../library/selectors.rst:141
msgid ""
"This returns a new :class:`SelectorKey` instance, or raises "
"a :exc:`ValueError` in case of invalid event mask or file descriptor, "
"or :exc:`KeyError` if the file object is not registered."
msgstr ""
"Detta returnerar en ny :class:`SelectorKey`\\-instans, eller ger upphov till "
"ett :exc:`ValueError` i händelse av ogiltig händelsemask eller "
"filbeskrivning, eller :exc:`KeyError` om filobjektet inte är registrerat."

#: ../../library/selectors.rst:148
msgid ""
"Wait until some registered file objects become ready, or the timeout expires."
msgstr ""
"Vänta tills några registrerade filobjekt blir klara eller tills timeouten "
"löper ut."

#: ../../library/selectors.rst:151
msgid ""
"If ``timeout > 0``, this specifies the maximum wait time, in seconds. If "
"``timeout <= 0``, the call won't block, and will report the currently ready "
"file objects. If *timeout* is ``None``, the call will block until a "
"monitored file object becomes ready."
msgstr ""
"Om ``timeout > 0``, anger detta den maximala väntetiden i sekunder. Om "
"``timeout <= 0`` kommer anropet inte att blockeras och rapporterar de "
"filobjekt som för närvarande är klara. Om *timeout* är ``None`` kommer "
"anropet att blockeras tills ett övervakat filobjekt blir klart."

#: ../../library/selectors.rst:157
msgid ""
"This returns a list of ``(key, events)`` tuples, one for each ready file "
"object."
msgstr ""
"Detta returnerar en lista med ``(key, events)``\\-tupler, en för varje "
"färdigt filobjekt."

#: ../../library/selectors.rst:160
msgid ""
"*key* is the :class:`SelectorKey` instance corresponding to a ready file "
"object. *events* is a bitmask of events ready on this file object."
msgstr ""
"*key* är den instans av :class:`SelectorKey` som motsvarar ett färdigt "
"filobjekt. *events* är en bitmask av händelser som är klara för detta "
"filobjekt."

#: ../../library/selectors.rst:165
msgid ""
"This method can return before any file object becomes ready or the timeout "
"has elapsed if the current process receives a signal: in this case, an empty "
"list will be returned."
msgstr ""
"Denna metod kan returneras innan något filobjekt blir klart eller timeouten "
"har löpt ut om den aktuella processen får en signal: i detta fall returneras "
"en tom lista."

#: ../../library/selectors.rst:169
msgid ""
"The selector is now retried with a recomputed timeout when interrupted by a "
"signal if the signal handler did not raise an exception (see :pep:`475` for "
"the rationale), instead of returning an empty list of events before the "
"timeout."
msgstr ""
"Väljaren försöker nu igen med en omräknad timeout när den avbryts av en "
"signal om signalhanteraren inte utlöste ett undantag (se :pep:`475` för "
"förklaringen), istället för att returnera en tom lista med händelser före "
"timeouten."

#: ../../library/selectors.rst:177
msgid "Close the selector."
msgstr "Stäng väljaren."

#: ../../library/selectors.rst:179
msgid ""
"This must be called to make sure that any underlying resource is freed. The "
"selector shall not be used once it has been closed."
msgstr ""
"Detta måste anropas för att säkerställa att alla underliggande resurser är "
"frigjorda. Väljaren får inte användas när den har stängts."

#: ../../library/selectors.rst:184
msgid "Return the key associated with a registered file object."
msgstr "Returnerar nyckeln som är kopplad till ett registrerat filobjekt."

#: ../../library/selectors.rst:186
msgid ""
"This returns the :class:`SelectorKey` instance associated to this file "
"object, or raises :exc:`KeyError` if the file object is not registered."
msgstr ""
"Detta returnerar :class:`SelectorKey`\\-instansen som är associerad med "
"detta filobjekt, eller ger upphov till :exc:`KeyError` om filobjektet inte "
"är registrerat."

#: ../../library/selectors.rst:192
msgid "Return a mapping of file objects to selector keys."
msgstr "Returnerar en mappning av filobjekt till väljarknappar."

#: ../../library/selectors.rst:194
msgid ""
"This returns a :class:`~collections.abc.Mapping` instance mapping registered "
"file objects to their associated :class:`SelectorKey` instance."
msgstr ""
"Detta returnerar en :class:`~collections.abc.Mapping`\\-instans som mappar "
"registrerade filobjekt till deras associerade :class:`SelectorKey`\\-instans."

#: ../../library/selectors.rst:201
msgid ""
"The default selector class, using the most efficient implementation "
"available on the current platform. This should be the default choice for "
"most users."
msgstr ""
"Standardväljarklassen använder den mest effektiva implementeringen som finns "
"tillgänglig på den aktuella plattformen. Detta bör vara standardvalet för de "
"flesta användare."

#: ../../library/selectors.rst:208
msgid ":func:`select.select`-based selector."
msgstr ":func:`select.select`\\-baserad väljare."

#: ../../library/selectors.rst:213
msgid ":func:`select.poll`-based selector."
msgstr ":func:`select.poll`\\-baserad väljare."

#: ../../library/selectors.rst:218
msgid ":func:`select.epoll`-based selector."
msgstr ":func:`select.epoll`\\-baserad väljare."

#: ../../library/selectors.rst:222
msgid ""
"This returns the file descriptor used by the underlying :func:`select.epoll` "
"object."
msgstr ""
"Detta returnerar filbeskrivaren som används av det "
"underliggande :func:`select.epoll`\\-objektet."

#: ../../library/selectors.rst:227
msgid ":func:`select.devpoll`-based selector."
msgstr ":func:`select.devpoll`\\-baserad väljare."

#: ../../library/selectors.rst:231
msgid ""
"This returns the file descriptor used by the "
"underlying :func:`select.devpoll` object."
msgstr ""
"Detta returnerar filbeskrivaren som används av det "
"underliggande :func:`select.devpoll`\\-objektet."

#: ../../library/selectors.rst:238
msgid ":func:`select.kqueue`-based selector."
msgstr ":func:`select.kqueue`\\-baserad väljare."

#: ../../library/selectors.rst:242
msgid ""
"This returns the file descriptor used by the "
"underlying :func:`select.kqueue` object."
msgstr ""
"Detta returnerar filbeskrivaren som används av det "
"underliggande :func:`select.kqueue`\\-objektet."

#: ../../library/selectors.rst:247
msgid "Examples"
msgstr "Exempel"

#: ../../library/selectors.rst:249
msgid "Here is a simple echo server implementation::"
msgstr "Här är en enkel implementering av en ekoserver::"

#: ../../library/selectors.rst:251
msgid ""
"import selectors\n"
"import socket\n"
"\n"
"sel = selectors.DefaultSelector()\n"
"\n"
"def accept(sock, mask):\n"
"    conn, addr = sock.accept()  # Should be ready\n"
"    print('accepted', conn, 'from', addr)\n"
"    conn.setblocking(False)\n"
"    sel.register(conn, selectors.EVENT_READ, read)\n"
"\n"
"def read(conn, mask):\n"
"    data = conn.recv(1000)  # Should be ready\n"
"    if data:\n"
"        print('echoing', repr(data), 'to', conn)\n"
"        conn.send(data)  # Hope it won't block\n"
"    else:\n"
"        print('closing', conn)\n"
"        sel.unregister(conn)\n"
"        conn.close()\n"
"\n"
"sock = socket.socket()\n"
"sock.bind(('localhost', 1234))\n"
"sock.listen(100)\n"
"sock.setblocking(False)\n"
"sel.register(sock, selectors.EVENT_READ, accept)\n"
"\n"
"while True:\n"
"    events = sel.select()\n"
"    for key, mask in events:\n"
"        callback = key.data\n"
"        callback(key.fileobj, mask)"
msgstr ""
"import selectors\n"
"import socket\n"
"\n"
"sel = selectors.DefaultSelector()\n"
"\n"
"def accept(sock, mask):\n"
"    conn, addr = sock.accept()  # Should be ready\n"
"    print('accepted', conn, 'from', addr)\n"
"    conn.setblocking(False)\n"
"    sel.register(conn, selectors.EVENT_READ, read)\n"
"\n"
"def read(conn, mask):\n"
"    data = conn.recv(1000)  # Should be ready\n"
"    if data:\n"
"        print('echoing', repr(data), 'to', conn)\n"
"        conn.send(data)  # Hope it won't block\n"
"    else:\n"
"        print('closing', conn)\n"
"        sel.unregister(conn)\n"
"        conn.close()\n"
"\n"
"sock = socket.socket()\n"
"sock.bind(('localhost', 1234))\n"
"sock.listen(100)\n"
"sock.setblocking(False)\n"
"sel.register(sock, selectors.EVENT_READ, accept)\n"
"\n"
"while True:\n"
"    events = sel.select()\n"
"    for key, mask in events:\n"
"        callback = key.data\n"
"        callback(key.fileobj, mask)"
