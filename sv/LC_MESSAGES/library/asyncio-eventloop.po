# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# python-doc bot, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-25 16:33+0000\n"
"PO-Revision-Date: 2025-09-22 16:49+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../library/asyncio-eventloop.rst:8
msgid "Event Loop"
msgstr "Händelseslinga"

#: ../../library/asyncio-eventloop.rst:10
msgid ""
"**Source code:** :source:`Lib/asyncio/events.py`, "
":source:`Lib/asyncio/base_events.py`"
msgstr ""
"**Källkod:** :source:`Lib/asyncio/events.py`, "
":source:`Lib/asyncio/base_events.py`"

#: ../../library/asyncio-eventloop.rst:16
msgid "Preface"
msgstr "Förord"

#: ../../library/asyncio-eventloop.rst:17
msgid ""
"The event loop is the core of every asyncio application. Event loops run "
"asynchronous tasks and callbacks, perform network IO operations, and run "
"subprocesses."
msgstr ""
"Händelseslingan är kärnan i varje asyncio-applikation. Händelseslingor kör "
"asynkrona uppgifter och återuppringningar, utför IO-operationer i nätverket "
"och kör underprocesser."

#: ../../library/asyncio-eventloop.rst:21
msgid ""
"Application developers should typically use the high-level asyncio "
"functions, such as :func:`asyncio.run`, and should rarely need to reference "
"the loop object or call its methods.  This section is intended mostly for "
"authors of lower-level code, libraries, and frameworks, who need finer "
"control over the event loop behavior."
msgstr ""
"Programutvecklare bör vanligtvis använda asynciofunktionerna på hög nivå, "
"till exempel :func:`asyncio.run`, och bör sällan behöva referera till "
"loopobjektet eller anropa dess metoder.  Det här avsnittet är främst avsett "
"för författare av kod på lägre nivå, bibliotek och ramverk som behöver "
"finare kontroll över händelseslingans beteende."

#: ../../library/asyncio-eventloop.rst:28
msgid "Obtaining the Event Loop"
msgstr "Få fram händelseslingan"

#: ../../library/asyncio-eventloop.rst:29
msgid ""
"The following low-level functions can be used to get, set, or create an "
"event loop:"
msgstr ""
"Följande lågnivåfunktioner kan användas för att hämta, ställa in eller skapa"
" en händelseslinga:"

#: ../../library/asyncio-eventloop.rst:34
msgid "Return the running event loop in the current OS thread."
msgstr "Returnerar den pågående händelseslingan i den aktuella OS-tråden."

#: ../../library/asyncio-eventloop.rst:36
msgid "Raise a :exc:`RuntimeError` if there is no running event loop."
msgstr ""
"Skapa ett :exc:`RuntimeError` om det inte finns någon pågående "
"händelseslinga."

#: ../../library/asyncio-eventloop.rst:38
msgid "This function can only be called from a coroutine or a callback."
msgstr ""
"Denna funktion kan endast anropas från en coroutine eller en callback."

#: ../../library/asyncio-eventloop.rst:44
msgid "Get the current event loop."
msgstr "Hämta den aktuella händelseslingan."

#: ../../library/asyncio-eventloop.rst:46
msgid ""
"When called from a coroutine or a callback (e.g. scheduled with call_soon or"
" similar API), this function will always return the running event loop."
msgstr ""
"När den här funktionen anropas från en coroutine eller en callback (t.ex. "
"schemalagd med call_soon eller liknande API) returnerar den alltid den "
"pågående händelseslingan."

#: ../../library/asyncio-eventloop.rst:50
msgid ""
"If there is no running event loop set, the function will return the result "
"of the ``get_event_loop_policy().get_event_loop()`` call."
msgstr ""
"Om det inte finns någon pågående händelseslinga inställd, returnerar "
"funktionen resultatet av anropet "
"``get_event_loop_policy().get_event_loop()``."

#: ../../library/asyncio-eventloop.rst:53
msgid ""
"Because this function has rather complex behavior (especially when custom "
"event loop policies are in use), using the :func:`get_running_loop` function"
" is preferred to :func:`get_event_loop` in coroutines and callbacks."
msgstr ""
"Eftersom den här funktionen har ett ganska komplext beteende (särskilt när "
"anpassade policys för händelseslingor används) är det bättre att använda "
"funktionen :func:`get_running_loop` än :func:`get_event_loop` i coroutines "
"och callbacks."

#: ../../library/asyncio-eventloop.rst:58
msgid ""
"As noted above, consider using the higher-level :func:`asyncio.run` "
"function, instead of using these lower level functions to manually create "
"and close an event loop."
msgstr ""
"Som nämnts ovan bör du överväga att använda funktionen :func:`asyncio.run` "
"på högre nivå istället för att använda dessa funktioner på lägre nivå för "
"att manuellt skapa och stänga en händelseslinga."

#: ../../library/asyncio-eventloop.rst:63
msgid ""
"In Python versions 3.10.0--3.10.8 and 3.11.0 this function (and other "
"functions which use it implicitly) emitted a :exc:`DeprecationWarning` if "
"there was no running event loop, even if the current loop was set on the "
"policy. In Python versions 3.10.9, 3.11.1 and 3.12 they emit a "
":exc:`DeprecationWarning` if there is no running event loop and no current "
"loop is set. In some future Python release this will become an error."
msgstr ""

#: ../../library/asyncio-eventloop.rst:74
msgid "Set *loop* as the current event loop for the current OS thread."
msgstr "Ange *loop* som aktuell händelseslinga för den aktuella OS-tråden."

#: ../../library/asyncio-eventloop.rst:78
msgid "Create and return a new event loop object."
msgstr "Skapa och returnera ett nytt objekt för händelseslingan."

#: ../../library/asyncio-eventloop.rst:80
msgid ""
"Note that the behaviour of :func:`get_event_loop`, :func:`set_event_loop`, "
"and :func:`new_event_loop` functions can be altered by :ref:`setting a "
"custom event loop policy <asyncio-policies>`."
msgstr ""
"Observera att beteendet hos funktionerna :func:`get_event_loop`, "
":func:`set_event_loop` och :func:`new_event_loop` kan ändras genom "
":ref:`setting a custom event loop policy <asyncio-policies>`."

#: ../../library/asyncio-eventloop.rst:86
msgid "Contents"
msgstr "Innehåll"

#: ../../library/asyncio-eventloop.rst:87
msgid "This documentation page contains the following sections:"
msgstr "Denna dokumentationssida innehåller följande avsnitt:"

#: ../../library/asyncio-eventloop.rst:89
msgid ""
"The `Event Loop Methods`_ section is the reference documentation of the "
"event loop APIs;"
msgstr ""
"Avsnittet `Event Loop Methods`_ är referensdokumentationen för API:erna för "
"händelseslingan;"

#: ../../library/asyncio-eventloop.rst:92
msgid ""
"The `Callback Handles`_ section documents the :class:`Handle` and "
":class:`TimerHandle` instances which are returned from scheduling methods "
"such as :meth:`loop.call_soon` and :meth:`loop.call_later`;"
msgstr ""
"Avsnittet `Callback Handles`_ dokumenterar instanserna :class:`Handle` och "
":class:`TimerHandle` som returneras från schemaläggningsmetoder som "
":meth:`loop.call_soon` och :meth:`loop.call_later`;"

#: ../../library/asyncio-eventloop.rst:96
msgid ""
"The `Server Objects`_ section documents types returned from event loop "
"methods like :meth:`loop.create_server`;"
msgstr ""
"Avsnittet `Server Objects`_ dokumenterar typer som returneras från metoder "
"för händelseslingor som :meth:`loop.create_server`;"

#: ../../library/asyncio-eventloop.rst:99
msgid ""
"The `Event Loop Implementations`_ section documents the "
":class:`SelectorEventLoop` and :class:`ProactorEventLoop` classes;"
msgstr ""
"Avsnittet `Event Loop Implementations`_ dokumenterar klasserna "
":class:`SelectorEventLoop` och :class:`ProactorEventLoop`;"

#: ../../library/asyncio-eventloop.rst:102
msgid ""
"The `Examples`_ section showcases how to work with some event loop APIs."
msgstr ""
"Avsnittet `Examples`_ visar hur man arbetar med vissa API:er för "
"händelseslingor."

#: ../../library/asyncio-eventloop.rst:109
msgid "Event Loop Methods"
msgstr "Metoder för händelseslingor"

#: ../../library/asyncio-eventloop.rst:111
msgid "Event loops have **low-level** APIs for the following:"
msgstr "Händelseslingor har **lågnivå** API:er för följande:"

#: ../../library/asyncio-eventloop.rst:119
msgid "Running and stopping the loop"
msgstr "Starta och stoppa slingan"

#: ../../library/asyncio-eventloop.rst:123
msgid "Run until the *future* (an instance of :class:`Future`) has completed."
msgstr "Kör tills *future* (en instans av :class:`Future`) har slutförts."

#: ../../library/asyncio-eventloop.rst:126
msgid ""
"If the argument is a :ref:`coroutine object <coroutine>` it is implicitly "
"scheduled to run as a :class:`asyncio.Task`."
msgstr ""
"Om argumentet är ett :ref:`coroutine-objekt <coroutine>` schemaläggs det "
"implicit för att köras som en :class:`asyncio.Task`."

#: ../../library/asyncio-eventloop.rst:129
msgid "Return the Future's result or raise its exception."
msgstr "Returnera Framtidens resultat eller ta upp dess undantag."

#: ../../library/asyncio-eventloop.rst:133
msgid "Run the event loop until :meth:`stop` is called."
msgstr "Kör händelseslingan tills :meth:`stop` anropas."

#: ../../library/asyncio-eventloop.rst:135
msgid ""
"If :meth:`stop` is called before :meth:`run_forever()` is called, the loop "
"will poll the I/O selector once with a timeout of zero, run all callbacks "
"scheduled in response to I/O events (and those that were already scheduled),"
" and then exit."
msgstr ""

#: ../../library/asyncio-eventloop.rst:140
msgid ""
"If :meth:`stop` is called while :meth:`run_forever` is running, the loop "
"will run the current batch of callbacks and then exit. Note that new "
"callbacks scheduled by callbacks will not run in this case; instead, they "
"will run the next time :meth:`run_forever` or :meth:`run_until_complete` is "
"called."
msgstr ""
"Om :meth:`stop` anropas medan :meth:`run_forever` körs, kommer loopen att "
"köra den aktuella batchen av callbacks och sedan avslutas. Observera att nya"
" återuppringningar som schemalagts av återuppringningar inte kommer att "
"köras i det här fallet; istället kommer de att köras nästa gång "
":meth:`run_forever` eller :meth:`run_until_complete` anropas."

#: ../../library/asyncio-eventloop.rst:148
msgid "Stop the event loop."
msgstr "Stoppa händelseslingan."

#: ../../library/asyncio-eventloop.rst:152
msgid "Return ``True`` if the event loop is currently running."
msgstr "Returnerar ``True`` om händelseslingan körs för närvarande."

#: ../../library/asyncio-eventloop.rst:156
msgid "Return ``True`` if the event loop was closed."
msgstr "Returnerar ``True`` om händelseslingan stängdes."

#: ../../library/asyncio-eventloop.rst:160
msgid "Close the event loop."
msgstr "Stäng händelseslingan."

#: ../../library/asyncio-eventloop.rst:162
msgid ""
"The loop must not be running when this function is called. Any pending "
"callbacks will be discarded."
msgstr ""
"Slingan får inte vara igång när denna funktion anropas. Alla väntande "
"återuppringningar kommer att kasseras."

#: ../../library/asyncio-eventloop.rst:165
msgid ""
"This method clears all queues and shuts down the executor, but does not wait"
" for the executor to finish."
msgstr ""
"Den här metoden rensar alla köer och stänger av exekveraren, men väntar inte"
" på att exekveraren ska bli klar."

#: ../../library/asyncio-eventloop.rst:168
msgid ""
"This method is idempotent and irreversible.  No other methods should be "
"called after the event loop is closed."
msgstr ""
"Denna metod är idempotent och irreversibel.  Inga andra metoder bör anropas "
"efter att händelseslingan har stängts."

#: ../../library/asyncio-eventloop.rst:173
msgid ""
"Schedule all currently open :term:`asynchronous generator` objects to close "
"with an :meth:`~agen.aclose()` call.  After calling this method, the event "
"loop will issue a warning if a new asynchronous generator is iterated. This "
"should be used to reliably finalize all scheduled asynchronous generators."
msgstr ""

#: ../../library/asyncio-eventloop.rst:179
msgid ""
"Note that there is no need to call this function when :func:`asyncio.run` is"
" used."
msgstr ""
"Observera att det inte finns något behov av att anropa denna funktion när "
":func:`asyncio.run` används."

#: ../../library/asyncio-eventloop.rst:182
#: ../../library/asyncio-eventloop.rst:1225
#: ../../library/asyncio-eventloop.rst:1626
msgid "Example::"
msgstr "Exempel::"

#: ../../library/asyncio-eventloop.rst:194
msgid ""
"Schedule the closure of the default executor and wait for it to join all of "
"the threads in the :class:`~concurrent.futures.ThreadPoolExecutor`. Once "
"this method has been called, using the default executor with "
":meth:`loop.run_in_executor` will raise a :exc:`RuntimeError`."
msgstr ""
"Schemalägg stängningen av standardutföraren och vänta på att den ska ansluta"
" sig till alla trådar i :class:`~concurrent.futures.ThreadPoolExecutor`. När"
" denna metod har anropats, kommer användning av standardutföraren med "
":meth:`loop.run_in_executor` att ge upphov till ett :exc:`RuntimeError`."

#: ../../library/asyncio-eventloop.rst:202
msgid ""
"Do not call this method when using :func:`asyncio.run`, as the latter "
"handles default executor shutdown automatically."
msgstr ""
"Anropa inte den här metoden när du använder :func:`asyncio.run`, eftersom "
"den senare hanterar standardavstängning av exekveraren automatiskt."

#: ../../library/asyncio-eventloop.rst:209
msgid "Scheduling callbacks"
msgstr "Schemaläggning av återuppringningar"

#: ../../library/asyncio-eventloop.rst:213
msgid ""
"Schedule the *callback* :term:`callback` to be called with *args* arguments "
"at the next iteration of the event loop."
msgstr ""
"Schemalägg *callback* :term:`callback` så att den anropas med "
"*args*-argument vid nästa iteration av händelseslingan."

#: ../../library/asyncio-eventloop.rst:216
msgid ""
"Return an instance of :class:`asyncio.Handle`, which can be used later to "
"cancel the callback."
msgstr ""
"Returnerar en instans av :class:`asyncio.Handle`, som kan användas senare "
"för att avbryta återuppringningen."

#: ../../library/asyncio-eventloop.rst:219
msgid ""
"Callbacks are called in the order in which they are registered. Each "
"callback will be called exactly once."
msgstr ""
"Callbacks anropas i den ordning som de registrerades. Varje callback kommer "
"att anropas exakt en gång."

#: ../../library/asyncio-eventloop.rst:222
msgid ""
"The optional keyword-only *context* argument specifies a custom "
":class:`contextvars.Context` for the *callback* to run in. Callbacks use the"
" current context when no *context* is provided."
msgstr ""
"Det valfria argumentet *context*, som endast innehåller nyckelord, anger en "
"anpassad :class:`contextvars.Context` som *callback* ska köras i. "
"Återkallelser använder den aktuella kontexten när ingen *kontext* anges."

#: ../../library/asyncio-eventloop.rst:226
msgid "Unlike :meth:`call_soon_threadsafe`, this method is not thread-safe."
msgstr ""
"Till skillnad från :meth:`call_soon_threadsafe` är den här metoden inte "
"trådsäker."

#: ../../library/asyncio-eventloop.rst:230
msgid ""
"A thread-safe variant of :meth:`call_soon`. When scheduling callbacks from "
"another thread, this function *must* be used, since :meth:`call_soon` is not"
" thread-safe."
msgstr ""
"En trådsäker variant av :meth:`call_soon`. Vid schemaläggning av callbacks "
"från en annan tråd *måste* denna funktion användas, eftersom "
":meth:`call_soon` inte är trådsäker."

#: ../../library/asyncio-eventloop.rst:234
msgid ""
"Raises :exc:`RuntimeError` if called on a loop that's been closed. This can "
"happen on a secondary thread when the main application is shutting down."
msgstr ""
"Utlöser :exc:`RuntimeError` om den anropas i en loop som har stängts. Detta "
"kan hända i en sekundär tråd när huvudapplikationen stängs ner."

#: ../../library/asyncio-eventloop.rst:238
msgid ""
"See the :ref:`concurrency and multithreading <asyncio-multithreading>` "
"section of the documentation."
msgstr ""
"Se :ref:`concurrency and multithreading <asyncio-multithreading>` i "
"dokumentationen."

#: ../../library/asyncio-eventloop.rst:241
#: ../../library/asyncio-eventloop.rst:291
#: ../../library/asyncio-eventloop.rst:311
msgid ""
"The *context* keyword-only parameter was added. See :pep:`567` for more "
"details."
msgstr ""
"Parametern *context* (endast nyckelord) har lagts till. Se :pep:`567` för "
"mer information."

#: ../../library/asyncio-eventloop.rst:249
msgid ""
"Most :mod:`asyncio` scheduling functions don't allow passing keyword "
"arguments.  To do that, use :func:`functools.partial`::"
msgstr ""
"De flesta :mod:`asyncio`\\-schemaläggningsfunktioner tillåter inte att "
"nyckelordsargument skickas.  För att göra det, använd "
":func:`functools.partial`::"

#: ../../library/asyncio-eventloop.rst:256
msgid ""
"Using partial objects is usually more convenient than using lambdas, as "
"asyncio can render partial objects better in debug and error messages."
msgstr ""
"Att använda partiella objekt är vanligtvis mer praktiskt än att använda "
"lambdas, eftersom asyncio kan göra partiella objekt bättre i felsöknings- "
"och felmeddelanden."

#: ../../library/asyncio-eventloop.rst:264
msgid "Scheduling delayed callbacks"
msgstr "Schemaläggning av fördröjda återuppringningar"

#: ../../library/asyncio-eventloop.rst:266
msgid ""
"Event loop provides mechanisms to schedule callback functions to be called "
"at some point in the future.  Event loop uses monotonic clocks to track "
"time."
msgstr ""
"Event loop tillhandahåller mekanismer för att schemalägga callback-"
"funktioner som ska anropas vid någon tidpunkt i framtiden.  Händelseslingan "
"använder monotona klockor för att hålla reda på tiden."

#: ../../library/asyncio-eventloop.rst:273
msgid ""
"Schedule *callback* to be called after the given *delay* number of seconds "
"(can be either an int or a float)."
msgstr ""
"Schemalägg *callback* som ska anropas efter det angivna *delay*-antalet "
"sekunder (kan vara antingen ett int eller ett float)."

#: ../../library/asyncio-eventloop.rst:276
#: ../../library/asyncio-eventloop.rst:308
msgid ""
"An instance of :class:`asyncio.TimerHandle` is returned which can be used to"
" cancel the callback."
msgstr ""
"En instans av :class:`asyncio.TimerHandle` returneras som kan användas för "
"att avbryta återuppringningen."

#: ../../library/asyncio-eventloop.rst:279
msgid ""
"*callback* will be called exactly once.  If two callbacks are scheduled for "
"exactly the same time, the order in which they are called is undefined."
msgstr ""
"*callback* kommer att anropas exakt en gång.  Om två callbacks är "
"schemalagda för exakt samma tid, är ordningen i vilken de anropas "
"odefinierad."

#: ../../library/asyncio-eventloop.rst:283
msgid ""
"The optional positional *args* will be passed to the callback when it is "
"called. If you want the callback to be called with keyword arguments use "
":func:`functools.partial`."
msgstr ""
"De valfria positionella *args* kommer att skickas till callbacken när den "
"anropas. Om du vill att återuppringningen ska anropas med nyckelordsargument"
" använder du :func:`functools.partial`."

#: ../../library/asyncio-eventloop.rst:287
msgid ""
"An optional keyword-only *context* argument allows specifying a custom "
":class:`contextvars.Context` for the *callback* to run in. The current "
"context is used when no *context* is provided."
msgstr ""
"Ett valfritt argument *context* med endast nyckelord gör det möjligt att "
"ange en anpassad :class:`contextvars.Context` som *callback* ska köras i. "
"Den aktuella kontexten används när ingen *kontext* anges."

#: ../../library/asyncio-eventloop.rst:295
msgid ""
"In Python 3.7 and earlier with the default event loop implementation, the "
"*delay* could not exceed one day. This has been fixed in Python 3.8."
msgstr ""
"I Python 3.7 och tidigare med standardimplementeringen av händelseslingan "
"kunde *fördröjningen* inte överstiga en dag. Detta har åtgärdats i Python "
"3.8."

#: ../../library/asyncio-eventloop.rst:302
msgid ""
"Schedule *callback* to be called at the given absolute timestamp *when* (an "
"int or a float), using the same time reference as :meth:`loop.time`."
msgstr ""
"Schemalägg *callback* så att den anropas vid den angivna absoluta "
"tidsstämpeln *when* (en int eller en float), med samma tidsreferens som "
":meth:`loop.time`."

#: ../../library/asyncio-eventloop.rst:306
msgid "This method's behavior is the same as :meth:`call_later`."
msgstr "Den här metodens beteende är detsamma som :meth:`call_later`."

#: ../../library/asyncio-eventloop.rst:315
msgid ""
"In Python 3.7 and earlier with the default event loop implementation, the "
"difference between *when* and the current time could not exceed one day.  "
"This has been fixed in Python 3.8."
msgstr ""
"I Python 3.7 och tidigare med standardimplementeringen av händelseslingan "
"kunde skillnaden mellan *when* och aktuell tid inte överstiga en dag.  Detta"
" har åtgärdats i Python 3.8."

#: ../../library/asyncio-eventloop.rst:322
msgid ""
"Return the current time, as a :class:`float` value, according to the event "
"loop's internal monotonic clock."
msgstr ""
"Returnerar aktuell tid, som ett :class:`float`\\-värde, enligt "
"händelseslingans interna monotona klocka."

#: ../../library/asyncio-eventloop.rst:326
msgid ""
"In Python 3.7 and earlier timeouts (relative *delay* or absolute *when*) "
"should not exceed one day.  This has been fixed in Python 3.8."
msgstr ""
"I Python 3.7 och tidigare skulle timeouts (relativ *delay* eller absolut "
"*when*) inte överstiga en dag.  Detta har åtgärdats i Python 3.8."

#: ../../library/asyncio-eventloop.rst:332
msgid "The :func:`asyncio.sleep` function."
msgstr "Funktionen :func:`asyncio.sleep`."

#: ../../library/asyncio-eventloop.rst:336
msgid "Creating Futures and Tasks"
msgstr "Skapa framtidsutsikter och uppgifter"

#: ../../library/asyncio-eventloop.rst:340
msgid "Create an :class:`asyncio.Future` object attached to the event loop."
msgstr ""
"Skapa ett :class:`asyncio.Future`\\-objekt som är kopplat till "
"händelseslingan."

#: ../../library/asyncio-eventloop.rst:342
msgid ""
"This is the preferred way to create Futures in asyncio. This lets third-"
"party event loops provide alternative implementations of the Future object "
"(with better performance or instrumentation)."
msgstr ""
"Detta är det föredragna sättet att skapa Futures i asyncio. Detta gör det "
"möjligt för tredjeparts händelseslingor att tillhandahålla alternativa "
"implementeringar av Future-objektet (med bättre prestanda eller "
"instrumentering)."

#: ../../library/asyncio-eventloop.rst:350
msgid ""
"Schedule the execution of :ref:`coroutine <coroutine>` *coro*. Return a "
":class:`Task` object."
msgstr ""
"Schemalägg utförandet av :ref:`coroutine <coroutine>` *coro*. Returnerar ett"
" :class:`Task`\\-objekt."

#: ../../library/asyncio-eventloop.rst:353
msgid ""
"Third-party event loops can use their own subclass of :class:`Task` for "
"interoperability. In this case, the result type is a subclass of "
":class:`Task`."
msgstr ""
"Händelseslingor från tredje part kan använda sin egen subklass av "
":class:`Task` för interoperabilitet. I det här fallet är resultattypen en "
"subklass av :class:`Task`."

#: ../../library/asyncio-eventloop.rst:357
msgid ""
"If the *name* argument is provided and not ``None``, it is set as the name "
"of the task using :meth:`Task.set_name`."
msgstr ""
"Om argumentet *name* anges och inte ``None``, anges det som namnet på "
"uppgiften med hjälp av :meth:`Task.set_name`."

#: ../../library/asyncio-eventloop.rst:360
msgid ""
"An optional keyword-only *context* argument allows specifying a custom "
":class:`contextvars.Context` for the *coro* to run in. The current context "
"copy is created when no *context* is provided."
msgstr ""
"Ett valfritt argument *context* med endast nyckelord gör det möjligt att "
"ange en anpassad :class:`contextvars.Context` som *coro* ska köras i. Den "
"aktuella kontextkopian skapas när ingen *kontext* anges."

#: ../../library/asyncio-eventloop.rst:364
msgid "Added the *name* parameter."
msgstr "Parametern *name* har lagts till."

#: ../../library/asyncio-eventloop.rst:367
msgid "Added the *context* parameter."
msgstr "Parametern *context* har lagts till."

#: ../../library/asyncio-eventloop.rst:372
msgid "Set a task factory that will be used by :meth:`loop.create_task`."
msgstr "Ange en uppgiftsfabrik som ska användas av :meth:`loop.create_task`."

#: ../../library/asyncio-eventloop.rst:375
msgid ""
"If *factory* is ``None`` the default task factory will be set. Otherwise, "
"*factory* must be a *callable* with the signature matching ``(loop, coro, "
"context=None)``, where *loop* is a reference to the active event loop, and "
"*coro* is a coroutine object.  The callable must return a "
":class:`asyncio.Future`-compatible object."
msgstr ""

#: ../../library/asyncio-eventloop.rst:383
msgid "Return a task factory or ``None`` if the default one is in use."
msgstr ""
"Returnerar en uppgiftsfabrik eller ``None`` om standardfabriken används."

#: ../../library/asyncio-eventloop.rst:387
msgid "Opening network connections"
msgstr "Öppna nätverksanslutningar"

#: ../../library/asyncio-eventloop.rst:397
msgid ""
"Open a streaming transport connection to a given address specified by *host*"
" and *port*."
msgstr ""
"Öppna en anslutning för strömmande transport till en given adress som "
"specificeras av *host* och *port*."

#: ../../library/asyncio-eventloop.rst:400
msgid ""
"The socket family can be either :py:const:`~socket.AF_INET` or "
":py:const:`~socket.AF_INET6` depending on *host* (or the *family* argument, "
"if provided)."
msgstr ""
"Socketfamiljen kan vara antingen :py:const:`~socket.AF_INET` eller "
":py:const:`~socket.AF_INET6` beroende på *host* (eller argumentet *family*, "
"om det anges)."

#: ../../library/asyncio-eventloop.rst:404
msgid "The socket type will be :py:const:`~socket.SOCK_STREAM`."
msgstr "Socket-typen kommer att vara :py:const:`~socket.SOCK_STREAM`."

#: ../../library/asyncio-eventloop.rst:406
#: ../../library/asyncio-eventloop.rst:1139
#: ../../library/asyncio-eventloop.rst:1155
msgid ""
"*protocol_factory* must be a callable returning an :ref:`asyncio protocol "
"<asyncio-protocol>` implementation."
msgstr ""
"*protocol_factory* måste vara en anropsbar som returnerar en :ref:`asyncio "
"protocol <asyncio-protocol>`\\-implementering."

#: ../../library/asyncio-eventloop.rst:409
msgid ""
"This method will try to establish the connection in the background. When "
"successful, it returns a ``(transport, protocol)`` pair."
msgstr ""
"Denna metod försöker upprätta anslutningen i bakgrunden. Om det lyckas "
"returnerar den ett par ``(transport, protokoll)``."

#: ../../library/asyncio-eventloop.rst:412
msgid "The chronological synopsis of the underlying operation is as follows:"
msgstr ""
"Den kronologiska sammanfattningen av den underliggande transaktionen är "
"följande:"

#: ../../library/asyncio-eventloop.rst:414
msgid ""
"The connection is established and a :ref:`transport <asyncio-transport>` is "
"created for it."
msgstr ""
"Anslutningen upprättas och en :ref:`transport <asyncio-transport>` skapas "
"för den."

#: ../../library/asyncio-eventloop.rst:417
msgid ""
"*protocol_factory* is called without arguments and is expected to return a "
":ref:`protocol <asyncio-protocol>` instance."
msgstr ""
"*protocol_factory* anropas utan argument och förväntas returnera en "
":ref:`protocol <asyncio-protocol>`\\-instans."

#: ../../library/asyncio-eventloop.rst:420
msgid ""
"The protocol instance is coupled with the transport by calling its "
":meth:`~BaseProtocol.connection_made` method."
msgstr ""
"Protokollinstansen kopplas till transporten genom att anropa dess metod "
":meth:`~BaseProtocol.connection_made`."

#: ../../library/asyncio-eventloop.rst:423
msgid "A ``(transport, protocol)`` tuple is returned on success."
msgstr "En tupel ``(transport, protocol)`` returneras vid framgång."

#: ../../library/asyncio-eventloop.rst:425
msgid ""
"The created transport is an implementation-dependent bidirectional stream."
msgstr ""
"Den skapade transporten är en implementationsberoende dubbelriktad ström."

#: ../../library/asyncio-eventloop.rst:428
#: ../../library/asyncio-eventloop.rst:549
msgid "Other arguments:"
msgstr "Övriga argument:"

#: ../../library/asyncio-eventloop.rst:430
msgid ""
"*ssl*: if given and not false, a SSL/TLS transport is created (by default a "
"plain TCP transport is created).  If *ssl* is a :class:`ssl.SSLContext` "
"object, this context is used to create the transport; if *ssl* is "
":const:`True`, a default context returned from "
":func:`ssl.create_default_context` is used."
msgstr ""
"*ssl*: om den anges och inte är false, skapas en SSL/TLS-transport (som "
"standard skapas en vanlig TCP-transport).  Om *ssl* är ett "
":class:`ssl.SSLContext`\\-objekt används detta sammanhang för att skapa "
"transporten; om *ssl* är :const:`True` används ett standardkontext som "
"returneras från :func:`ssl.create_default_context`."

#: ../../library/asyncio-eventloop.rst:436
msgid ":ref:`SSL/TLS security considerations <ssl-security>`"
msgstr ":ref:`SSL/TLS säkerhetsaspekter <ssl-security>`"

#: ../../library/asyncio-eventloop.rst:438
msgid ""
"*server_hostname* sets or overrides the hostname that the target server's "
"certificate will be matched against.  Should only be passed if *ssl* is not "
"``None``.  By default the value of the *host* argument is used.  If *host* "
"is empty, there is no default and you must pass a value for "
"*server_hostname*.  If *server_hostname* is an empty string, hostname "
"matching is disabled (which is a serious security risk, allowing for "
"potential man-in-the-middle attacks)."
msgstr ""
"*server_hostname* anger eller åsidosätter det värdnamn som målserverns "
"certifikat ska matchas mot.  Ska endast skickas om *ssl* inte är ``None``.  "
"Som standard används värdet för *host*-argumentet.  Om *host* är tomt finns "
"det inget standardvärde och du måste ange ett värde för *server_hostname*.  "
"Om *server_hostname* är en tom sträng inaktiveras matchning av värdnamn "
"(vilket är en allvarlig säkerhetsrisk eftersom det möjliggör potentiella "
"man-in-the-middle-attacker)."

#: ../../library/asyncio-eventloop.rst:446
msgid ""
"*family*, *proto*, *flags* are the optional address family, protocol and "
"flags to be passed through to getaddrinfo() for *host* resolution. If given,"
" these should all be integers from the corresponding :mod:`socket` module "
"constants."
msgstr ""
"*family*, *proto*, *flags* är den valfria adressfamiljen, protokollet och "
"flaggorna som ska skickas vidare till getaddrinfo() för upplösning av "
"*host*. Om de anges bör de alla vara heltal från motsvarande "
":mod:`socket`\\-modulkonstanter."

#: ../../library/asyncio-eventloop.rst:451
msgid ""
"*happy_eyeballs_delay*, if given, enables Happy Eyeballs for this "
"connection. It should be a floating-point number representing the amount of "
"time in seconds to wait for a connection attempt to complete, before "
"starting the next attempt in parallel. This is the \"Connection Attempt "
"Delay\" as defined in :rfc:`8305`. A sensible default value recommended by "
"the RFC is ``0.25`` (250 milliseconds)."
msgstr ""
"*happy_eyeballs_delay*, om det anges, aktiverar Happy Eyeballs för den här "
"anslutningen. Det bör vara ett flyttal som representerar den tid i sekunder "
"som ska vänta på att ett anslutningsförsök ska slutföras innan nästa försök "
"påbörjas parallellt. Detta är \"Connection Attempt Delay\" enligt "
"definitionen i :rfc:`8305`. Ett förnuftigt standardvärde som rekommenderas "
"av RFC är ``0,25`` (250 millisekunder)."

#: ../../library/asyncio-eventloop.rst:459
msgid ""
"*interleave* controls address reordering when a host name resolves to "
"multiple IP addresses. If ``0`` or unspecified, no reordering is done, and "
"addresses are tried in the order returned by :meth:`getaddrinfo`. If a "
"positive integer is specified, the addresses are interleaved by address "
"family, and the given integer is interpreted as \"First Address Family "
"Count\" as defined in :rfc:`8305`. The default is ``0`` if "
"*happy_eyeballs_delay* is not specified, and ``1`` if it is."
msgstr ""
"*interleave* styr omordning av adresser när ett värdnamn kopplas till flera "
"IP-adresser. Om ``0`` eller ospecificerat görs ingen omordning och "
"adresserna prövas i den ordning som returneras av :meth:`getaddrinfo`. Om "
"ett positivt heltal anges, sammanflätas adresserna efter adressfamilj och "
"det angivna heltalet tolkas som \"First Address Family Count\" enligt "
"definitionen i :rfc:`8305`. Standardvärdet är ``0`` om "
"*happy_eyeballs_delay* inte har angetts och ``1`` om så är fallet."

#: ../../library/asyncio-eventloop.rst:468
msgid ""
"*sock*, if given, should be an existing, already connected "
":class:`socket.socket` object to be used by the transport. If *sock* is "
"given, none of *host*, *port*, *family*, *proto*, *flags*, "
"*happy_eyeballs_delay*, *interleave* and *local_addr* should be specified."
msgstr ""
"*sock*, om det anges, ska vara ett befintligt, redan anslutet "
":class:`socket.socket` -objekt som ska användas av transporten. Om *sock* "
"anges ska inget av *host*, *port*, *family*, *proto*, *flags*, "
"*happy_eyeballs_delay*, *interleave* eller *local_addr* specificeras."

#: ../../library/asyncio-eventloop.rst:476
#: ../../library/asyncio-eventloop.rst:580
#: ../../library/asyncio-eventloop.rst:808
msgid ""
"The *sock* argument transfers ownership of the socket to the transport "
"created. To close the socket, call the transport's "
":meth:`~asyncio.BaseTransport.close` method."
msgstr ""
"Argumentet *sock* överför ägandet av sockeln till den transport som skapats."
" För att stänga sockeln anropar du transportens "
":meth:`~asyncio.BaseTransport.close`\\-metod."

#: ../../library/asyncio-eventloop.rst:480
msgid ""
"*local_addr*, if given, is a ``(local_host, local_port)`` tuple used to bind"
" the socket locally.  The *local_host* and *local_port* are looked up using "
"``getaddrinfo()``, similarly to *host* and *port*."
msgstr ""
"*local_addr*, om angivet, är en tupel ``(local_host, local_port)`` som "
"används för att binda socketen lokalt. *local_host* och *local_port* söks "
"upp med hjälp av ``getaddrinfo()``, på samma sätt som *host* och *port*."

#: ../../library/asyncio-eventloop.rst:484
#: ../../library/asyncio-eventloop.rst:902
msgid ""
"*ssl_handshake_timeout* is (for a TLS connection) the time in seconds to "
"wait for the TLS handshake to complete before aborting the connection. "
"``60.0`` seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* är (för en TLS-anslutning) den tid i sekunder som "
"ska vänta på att TLS-handskakningen ska slutföras innan anslutningen "
"avbryts. ``60,0`` sekunder om ``None`` (standard)."

#: ../../library/asyncio-eventloop.rst:488
#: ../../library/asyncio-eventloop.rst:725
#: ../../library/asyncio-eventloop.rst:819
#: ../../library/asyncio-eventloop.rst:906
msgid ""
"*ssl_shutdown_timeout* is the time in seconds to wait for the SSL shutdown "
"to complete before aborting the connection. ``30.0`` seconds if ``None`` "
"(default)."
msgstr ""
"*ssl_shutdown_timeout* är den tid i sekunder som ska vänta på att SSL-"
"avstängningen ska slutföras innan anslutningen avbryts. ``30.0`` sekunder om"
" ``None`` (standard)."

#: ../../library/asyncio-eventloop.rst:494
#: ../../library/asyncio-eventloop.rst:737
msgid "Added support for SSL/TLS in :class:`ProactorEventLoop`."
msgstr "Lagt till stöd för SSL/TLS i :class:`ProactorEventLoop`."

#: ../../library/asyncio-eventloop.rst:498
msgid ""
"The socket option :ref:`socket.TCP_NODELAY <socket-unix-constants>` is set "
"by default for all TCP connections."
msgstr ""
"Socket-alternativet :ref:`socket.TCP_NODELAY <socket-unix-constants>` är "
"inställt som standard för alla TCP-anslutningar."

#: ../../library/asyncio-eventloop.rst:503
#: ../../library/asyncio-eventloop.rst:829
msgid "Added the *ssl_handshake_timeout* parameter."
msgstr "Parametern *ssl_handshake_timeout* har lagts till."

#: ../../library/asyncio-eventloop.rst:507
msgid "Added the *happy_eyeballs_delay* and *interleave* parameters."
msgstr "Lagt till parametrarna *happy_eyeballs_delay* och *interleave*."

#: ../../library/asyncio-eventloop.rst:509
msgid ""
"Happy Eyeballs Algorithm: Success with Dual-Stack Hosts. When a server's "
"IPv4 path and protocol are working, but the server's IPv6 path and protocol "
"are not working, a dual-stack client application experiences significant "
"connection delay compared to an IPv4-only client.  This is undesirable "
"because it causes the dual-stack client to have a worse user experience.  "
"This document specifies requirements for algorithms that reduce this user-"
"visible delay and provides an algorithm."
msgstr ""
"Algoritm för glada ögonbollar: Framgång med Dual-Stack-värdar. När en "
"servers IPv4-sökväg och -protokoll fungerar, men serverns IPv6-sökväg och "
"-protokoll inte fungerar, upplever en dual-stack-klientapplikation en "
"betydande anslutningsfördröjning jämfört med en klient med enbart IPv4.  "
"Detta är inte önskvärt eftersom det leder till att dual-stack-klienten får "
"en sämre användarupplevelse.  Detta dokument specificerar krav för "
"algoritmer som minskar denna för användaren synliga fördröjning och "
"tillhandahåller en algoritm."

#: ../../library/asyncio-eventloop.rst:518
msgid "For more information: https://datatracker.ietf.org/doc/html/rfc6555"
msgstr "För mer information: https://datatracker.ietf.org/doc/html/rfc6555"

#: ../../library/asyncio-eventloop.rst:522
#: ../../library/asyncio-eventloop.rst:643
#: ../../library/asyncio-eventloop.rst:751
#: ../../library/asyncio-eventloop.rst:786
#: ../../library/asyncio-eventloop.rst:833
#: ../../library/asyncio-eventloop.rst:914
msgid "Added the *ssl_shutdown_timeout* parameter."
msgstr "Parametern *ssl_shutdown_timeout* har lagts till."

#: ../../library/asyncio-eventloop.rst:526
msgid ""
"The :func:`open_connection` function is a high-level alternative API.  It "
"returns a pair of (:class:`StreamReader`, :class:`StreamWriter`) that can be"
" used directly in async/await code."
msgstr ""
"Funktionen :func:`open_connection` är ett alternativt API på hög nivå.  Den "
"returnerar ett par (:class:`StreamReader`, :class:`StreamWriter`) som kan "
"användas direkt i async/await-kod."

#: ../../library/asyncio-eventloop.rst:536
msgid "Create a datagram connection."
msgstr "Skapa en datagramanslutning."

#: ../../library/asyncio-eventloop.rst:538
msgid ""
"The socket family can be either :py:const:`~socket.AF_INET`, "
":py:const:`~socket.AF_INET6`, or :py:const:`~socket.AF_UNIX`, depending on "
"*host* (or the *family* argument, if provided)."
msgstr ""
"Socketfamiljen kan vara antingen :py:const:`~socket.AF_INET`, "
":py:const:`~socket.AF_INET6` eller :py:const:`~socket.AF_UNIX`, beroende på "
"*host* (eller argumentet *family*, om det anges)."

#: ../../library/asyncio-eventloop.rst:542
msgid "The socket type will be :py:const:`~socket.SOCK_DGRAM`."
msgstr "Socket-typen är :py:const:`~socket.SOCK_DGRAM`."

#: ../../library/asyncio-eventloop.rst:544
#: ../../library/asyncio-eventloop.rst:668
#: ../../library/asyncio-eventloop.rst:800
msgid ""
"*protocol_factory* must be a callable returning a :ref:`protocol <asyncio-"
"protocol>` implementation."
msgstr ""
"*protocol_factory* måste vara en callable som returnerar en :ref:`protocol "
"<asyncio-protocol>` implementation."

#: ../../library/asyncio-eventloop.rst:547
#: ../../library/asyncio-eventloop.rst:625
msgid "A tuple of ``(transport, protocol)`` is returned on success."
msgstr "En tupel av ``(transport, protokoll)`` returneras vid framgång."

#: ../../library/asyncio-eventloop.rst:551
msgid ""
"*local_addr*, if given, is a ``(local_host, local_port)`` tuple used to bind"
" the socket locally.  The *local_host* and *local_port* are looked up using "
":meth:`getaddrinfo`."
msgstr ""
"*local_addr*, om den anges, är en ``(local_host, local_port)``\\-tupel som "
"används för att binda socket lokalt.  *local_host* och *local_port* söks upp"
" med hjälp av :meth:`getaddrinfo`."

#: ../../library/asyncio-eventloop.rst:555
msgid ""
"*remote_addr*, if given, is a ``(remote_host, remote_port)`` tuple used to "
"connect the socket to a remote address.  The *remote_host* and *remote_port*"
" are looked up using :meth:`getaddrinfo`."
msgstr ""
"*remote_addr*, om den anges, är en ``(remote_host, remote_port)``\\-tupel "
"som används för att ansluta sockeln till en fjärradress.  *remote_host* och "
"*remote_port* söks upp med hjälp av :meth:`getaddrinfo`."

#: ../../library/asyncio-eventloop.rst:559
msgid ""
"*family*, *proto*, *flags* are the optional address family, protocol and "
"flags to be passed through to :meth:`getaddrinfo` for *host* resolution. If "
"given, these should all be integers from the corresponding :mod:`socket` "
"module constants."
msgstr ""
"*family*, *proto*, *flags* är den valfria adressfamiljen, protokollet och "
"flaggorna som ska skickas vidare till :meth:`getaddrinfo` för "
"*host*-upplösning. Om de anges bör de alla vara heltal från motsvarande "
":mod:`socket`\\-modulkonstanter."

#: ../../library/asyncio-eventloop.rst:564
msgid ""
"*reuse_port* tells the kernel to allow this endpoint to be bound to the same"
" port as other existing endpoints are bound to, so long as they all set this"
" flag when being created. This option is not supported on Windows and some "
"Unixes. If the :ref:`socket.SO_REUSEPORT <socket-unix-constants>` constant "
"is not defined then this capability is unsupported."
msgstr ""
"*reuse_port* talar om för kärnan att den här ändpunkten får vara bunden till"
" samma port som andra befintliga ändpunkter är bundna till, så länge de alla"
" sätter denna flagga när de skapas. Detta alternativ stöds inte av Windows "
"och vissa Unix. Om konstanten :ref:`socket.SO_REUSEPORT <socket-unix-"
"constants>` inte är definierad stöds inte denna funktion."

#: ../../library/asyncio-eventloop.rst:570
msgid ""
"*allow_broadcast* tells the kernel to allow this endpoint to send messages "
"to the broadcast address."
msgstr ""
"*allow_broadcast* talar om för kärnan att den här slutpunkten får skicka "
"meddelanden till broadcast-adressen."

#: ../../library/asyncio-eventloop.rst:573
msgid ""
"*sock* can optionally be specified in order to use a preexisting, already "
"connected, :class:`socket.socket` object to be used by the transport. If "
"specified, *local_addr* and *remote_addr* should be omitted (must be "
":const:`None`)."
msgstr ""
"*sock* kan eventuellt anges för att använda ett befintligt, redan anslutet, "
":class:`socket.socket`\\-objekt som ska användas av transporten. Om detta "
"anges ska *local_addr* och *remote_addr* utelämnas (måste vara "
":const:`None`)."

#: ../../library/asyncio-eventloop.rst:584
msgid ""
"See :ref:`UDP echo client protocol <asyncio-udp-echo-client-protocol>` and "
":ref:`UDP echo server protocol <asyncio-udp-echo-server-protocol>` examples."
msgstr ""
"Se :ref:`UDP echo client protocol <asyncio-udp-echo-client-protocol>` och "
":ref:`UDP echo server protocol <asyncio-udp-echo-server-protocol>` exempel."

#: ../../library/asyncio-eventloop.rst:587
msgid ""
"The *family*, *proto*, *flags*, *reuse_address*, *reuse_port*, "
"*allow_broadcast*, and *sock* parameters were added."
msgstr ""
"Parametrarna *family*, *proto*, *flags*, *reuse_address*, *reuse_port*, "
"*allow_broadcast* och *sock* har lagts till."

#: ../../library/asyncio-eventloop.rst:591
msgid "Added support for Windows."
msgstr "Stöd för Windows har lagts till."

#: ../../library/asyncio-eventloop.rst:594
msgid ""
"The *reuse_address* parameter is no longer supported, as using "
":ref:`socket.SO_REUSEADDR <socket-unix-constants>` poses a significant "
"security concern for UDP. Explicitly passing ``reuse_address=True`` will "
"raise an exception."
msgstr ""
"Parametern *reuse_address* stöds inte längre, eftersom användning av "
":ref:`socket.SO_REUSEADDR <socket-unix-constants>` utgör ett betydande "
"säkerhetsproblem för UDP. Om du uttryckligen skickar ``reuse_address=True`` "
"kommer ett undantag att uppstå."

#: ../../library/asyncio-eventloop.rst:600
msgid ""
"When multiple processes with differing UIDs assign sockets to an identical "
"UDP socket address with ``SO_REUSEADDR``, incoming packets can become "
"randomly distributed among the sockets."
msgstr ""
"När flera processer med olika UID:er tilldelar uttag till en identisk UDP-"
"socketadress med ``SO_REUSEADDR`` kan inkommande paket fördelas slumpmässigt"
" mellan uttagen."

#: ../../library/asyncio-eventloop.rst:604
msgid ""
"For supported platforms, *reuse_port* can be used as a replacement for "
"similar functionality. With *reuse_port*, :ref:`socket.SO_REUSEPORT <socket-"
"unix-constants>` is used instead, which specifically prevents processes with"
" differing UIDs from assigning sockets to the same socket address."
msgstr ""
"För plattformar som stöds kan *reuse_port* användas som ersättning för "
"liknande funktionalitet. Med *reuse_port* används istället "
":ref:`socket.SO_REUSEPORT <socket-unix-constants>`, vilket specifikt "
"förhindrar att processer med olika UID:n tilldelar uttag till samma "
"uttagsadress."

#: ../../library/asyncio-eventloop.rst:611
msgid ""
"The *reuse_address* parameter, disabled since Python 3.8.1, 3.7.6 and "
"3.6.10, has been entirely removed."
msgstr ""
"Parametern *reuse_address*, som varit inaktiverad sedan Python 3.8.1, 3.7.6 "
"och 3.6.10, har tagits bort helt."

#: ../../library/asyncio-eventloop.rst:620
msgid "Create a Unix connection."
msgstr "Skapa en Unix-anslutning."

#: ../../library/asyncio-eventloop.rst:622
msgid ""
"The socket family will be :py:const:`~socket.AF_UNIX`; socket type will be "
":py:const:`~socket.SOCK_STREAM`."
msgstr ""
"Socket-familjen är :py:const:`~socket.AF_UNIX`; socket-typen är "
":py:const:`~socket.SOCK_STREAM`."

#: ../../library/asyncio-eventloop.rst:627
msgid ""
"*path* is the name of a Unix domain socket and is required, unless a *sock* "
"parameter is specified.  Abstract Unix sockets, :class:`str`, "
":class:`bytes`, and :class:`~pathlib.Path` paths are supported."
msgstr ""
"*path* är namnet på ett Unix-domänuttag och är obligatoriskt om inte "
"parametern *sock* har angetts.  Abstrakta Unix-sockets, :class:`str`, "
":class:`bytes` och :class:`~pathlib.Path`\\-sökvägar stöds."

#: ../../library/asyncio-eventloop.rst:632
msgid ""
"See the documentation of the :meth:`loop.create_connection` method for "
"information about arguments to this method."
msgstr ""
"Se dokumentationen för metoden :meth:`loop.create_connection` för "
"information om argument till denna metod."

#: ../../library/asyncio-eventloop.rst:635
#: ../../library/asyncio-eventloop.rst:777
#: ../../library/asyncio-eventloop.rst:1208
msgid ":ref:`Availability <availability>`: Unix."
msgstr ""

#: ../../library/asyncio-eventloop.rst:637
msgid ""
"Added the *ssl_handshake_timeout* parameter. The *path* parameter can now be"
" a :term:`path-like object`."
msgstr ""
"Parametern *ssl_handshake_timeout* har lagts till. Parametern *path* kan nu "
"vara en :term:`path-like object`."

#: ../../library/asyncio-eventloop.rst:647
msgid "Creating network servers"
msgstr "Skapa nätverksservrar"

#: ../../library/asyncio-eventloop.rst:661
msgid ""
"Create a TCP server (socket type :const:`~socket.SOCK_STREAM`) listening on "
"*port* of the *host* address."
msgstr ""
"Skapa en TCP-server (socket-typ :const:`~socket.SOCK_STREAM`) som lyssnar på"
" *port* på *host*-adressen."

#: ../../library/asyncio-eventloop.rst:664
msgid "Returns a :class:`Server` object."
msgstr "Returnerar ett :class:`Server`\\-objekt."

#: ../../library/asyncio-eventloop.rst:666
msgid "Arguments:"
msgstr "Argument:"

#: ../../library/asyncio-eventloop.rst:671
msgid ""
"The *host* parameter can be set to several types which determine where the "
"server would be listening:"
msgstr ""
"Parametern *host* kan ställas in på flera olika typer som avgör var servern "
"ska lyssna:"

#: ../../library/asyncio-eventloop.rst:674
msgid ""
"If *host* is a string, the TCP server is bound to a single network interface"
" specified by *host*."
msgstr ""
"Om *host* är en sträng är TCP-servern bunden till ett enda "
"nätverksgränssnitt som anges av *host*."

#: ../../library/asyncio-eventloop.rst:677
msgid ""
"If *host* is a sequence of strings, the TCP server is bound to all network "
"interfaces specified by the sequence."
msgstr ""
"Om *host* är en sekvens av strängar, är TCP-servern bunden till alla "
"nätverksgränssnitt som anges av sekvensen."

#: ../../library/asyncio-eventloop.rst:680
msgid ""
"If *host* is an empty string or ``None``, all interfaces are assumed and a "
"list of multiple sockets will be returned (most likely one for IPv4 and "
"another one for IPv6)."
msgstr ""
"Om *host* är en tom sträng eller ``None`` antas alla gränssnitt och en lista"
" med flera socklar returneras (troligen en för IPv4 och en annan för IPv6)."

#: ../../library/asyncio-eventloop.rst:684
msgid ""
"The *port* parameter can be set to specify which port the server should "
"listen on. If ``0`` or ``None`` (the default), a random unused port will be "
"selected (note that if *host* resolves to multiple network interfaces, a "
"different random port will be selected for each interface)."
msgstr ""
"Parametern *port* kan användas för att ange vilken port som servern ska "
"lyssna på. Om ``0`` eller ``None`` (standard) väljs en slumpmässig oanvänd "
"port (observera att om *host* är kopplad till flera nätverksgränssnitt väljs"
" en slumpmässig port för varje gränssnitt)."

#: ../../library/asyncio-eventloop.rst:689
msgid ""
"*family* can be set to either :const:`socket.AF_INET` or "
":const:`~socket.AF_INET6` to force the socket to use IPv4 or IPv6. If not "
"set, the *family* will be determined from host name (defaults to "
":const:`~socket.AF_UNSPEC`)."
msgstr ""
"*family* kan sättas till antingen :const:`socket.AF_INET` eller "
":const:`~socket.AF_INET6` för att tvinga uttaget att använda IPv4 eller "
"IPv6. Om den inte anges kommer *familjen* att bestämmas utifrån värdnamnet "
"(standard är :const:`~socket.AF_UNSPEC`)."

#: ../../library/asyncio-eventloop.rst:694
msgid "*flags* is a bitmask for :meth:`getaddrinfo`."
msgstr "*flags* är en bitmask för :meth:`getaddrinfo`."

#: ../../library/asyncio-eventloop.rst:696
msgid ""
"*sock* can optionally be specified in order to use a preexisting socket "
"object. If specified, *host* and *port* must not be specified."
msgstr ""
"*sock* kan eventuellt anges för att använda ett redan befintligt socket-"
"objekt. Om *host* och *port* anges får de inte specificeras."

#: ../../library/asyncio-eventloop.rst:701
msgid ""
"The *sock* argument transfers ownership of the socket to the server created."
" To close the socket, call the server's :meth:`~asyncio.Server.close` "
"method."
msgstr ""
"Argumentet *sock* överför äganderätten till sockeln till den server som "
"skapats. För att stänga sockeln anropar du serverns "
":meth:`~asyncio.Server.close`\\-metod."

#: ../../library/asyncio-eventloop.rst:705
msgid ""
"*backlog* is the maximum number of queued connections passed to "
":meth:`~socket.socket.listen` (defaults to 100)."
msgstr ""
"*backlog* är det maximala antalet anslutningar i kö som skickas till "
":meth:`~socket.socket.listen` (standardvärde 100)."

#: ../../library/asyncio-eventloop.rst:708
msgid ""
"*ssl* can be set to an :class:`~ssl.SSLContext` instance to enable TLS over "
"the accepted connections."
msgstr ""
"*ssl* kan sättas till en :class:`~ssl.SSLContext`\\-instans för att aktivera"
" TLS över de accepterade anslutningarna."

#: ../../library/asyncio-eventloop.rst:711
msgid ""
"*reuse_address* tells the kernel to reuse a local socket in ``TIME_WAIT`` "
"state, without waiting for its natural timeout to expire. If not specified "
"will automatically be set to ``True`` on Unix."
msgstr ""
"*reuse_address* talar om för kärnan att återanvända en lokal socket i "
"``TIME_WAIT`` -läge utan att vänta på att dess naturliga timeout löper ut. "
"Om detta inte anges kommer det automatiskt att sättas till ``True`` på Unix."

#: ../../library/asyncio-eventloop.rst:716
msgid ""
"*reuse_port* tells the kernel to allow this endpoint to be bound to the same"
" port as other existing endpoints are bound to, so long as they all set this"
" flag when being created. This option is not supported on Windows."
msgstr ""
"*reuse_port* talar om för kärnan att den här ändpunkten får vara bunden till"
" samma port som andra befintliga ändpunkter är bundna till, så länge de alla"
" sätter denna flagga när de skapas. Detta alternativ stöds inte i Windows."

#: ../../library/asyncio-eventloop.rst:721
msgid ""
"*ssl_handshake_timeout* is (for a TLS server) the time in seconds to wait "
"for the TLS handshake to complete before aborting the connection. ``60.0`` "
"seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* är (för en TLS-server) den tid i sekunder som ska "
"vänta på att TLS-handskakningen ska slutföras innan anslutningen avbryts. "
"``60,0`` sekunder om ``None`` (standard)."

#: ../../library/asyncio-eventloop.rst:729
msgid ""
"*start_serving* set to ``True`` (the default) causes the created server to "
"start accepting connections immediately.  When set to ``False``, the user "
"should await on :meth:`Server.start_serving` or :meth:`Server.serve_forever`"
" to make the server to start accepting connections."
msgstr ""
"*start_serving* satt till ``True`` (standard) gör att den skapade servern "
"börjar ta emot anslutningar omedelbart.  När den är inställd på ``False`` "
"bör användaren vänta på :meth:`Server.start_serving` eller "
":meth:`Server.serve_forever` för att få servern att börja acceptera "
"anslutningar."

#: ../../library/asyncio-eventloop.rst:741
msgid "The *host* parameter can be a sequence of strings."
msgstr "Parametern *host* kan vara en sekvens av strängar."

#: ../../library/asyncio-eventloop.rst:745
msgid ""
"Added *ssl_handshake_timeout* and *start_serving* parameters. The socket "
"option :ref:`socket.TCP_NODELAY <socket-unix-constants>` is set by default "
"for all TCP connections."
msgstr ""
"Parametrarna *ssl_handshake_timeout* och *start_serving* har lagts till. "
"Socket-alternativet :ref:`socket.TCP_NODELAY <socket-unix-constants>` är "
"inställt som standard för alla TCP-anslutningar."

#: ../../library/asyncio-eventloop.rst:755
msgid ""
"The :func:`start_server` function is a higher-level alternative API that "
"returns a pair of :class:`StreamReader` and :class:`StreamWriter` that can "
"be used in an async/await code."
msgstr ""
"Funktionen :func:`start_server` är ett alternativt API på högre nivå som "
"returnerar ett par av :class:`StreamReader` och :class:`StreamWriter` som "
"kan användas i en async/await-kod."

#: ../../library/asyncio-eventloop.rst:766
msgid ""
"Similar to :meth:`loop.create_server` but works with the "
":py:const:`~socket.AF_UNIX` socket family."
msgstr ""
"Liknar :meth:`loop.create_server` men fungerar med socketfamiljen "
":py:const:`~socket.AF_UNIX`."

#: ../../library/asyncio-eventloop.rst:769
msgid ""
"*path* is the name of a Unix domain socket, and is required, unless a *sock*"
" argument is provided.  Abstract Unix sockets, :class:`str`, :class:`bytes`,"
" and :class:`~pathlib.Path` paths are supported."
msgstr ""
"*path* är namnet på ett Unix-domänuttag och är obligatoriskt om inte ett "
"*sock*-argument anges.  Abstrakta Unix-sockets, :class:`str`, :class:`bytes`"
" och :class:`~pathlib.Path`\\-sökvägar stöds."

#: ../../library/asyncio-eventloop.rst:774
msgid ""
"See the documentation of the :meth:`loop.create_server` method for "
"information about arguments to this method."
msgstr ""
"Se dokumentationen för metoden :meth:`loop.create_server` för information om"
" argument till den här metoden."

#: ../../library/asyncio-eventloop.rst:781
msgid ""
"Added the *ssl_handshake_timeout* and *start_serving* parameters. The *path*"
" parameter can now be a :class:`~pathlib.Path` object."
msgstr ""
"Parametrarna *ssl_handshake_timeout* och *start_serving* har lagts till. "
"Parametern *path* kan nu vara ett :class:`~pathlib.Path`\\-objekt."

#: ../../library/asyncio-eventloop.rst:793
msgid "Wrap an already accepted connection into a transport/protocol pair."
msgstr ""
"Omhänderta en redan accepterad anslutning till ett transport/protokoll-par."

#: ../../library/asyncio-eventloop.rst:795
msgid ""
"This method can be used by servers that accept connections outside of "
"asyncio but that use asyncio to handle them."
msgstr ""
"Den här metoden kan användas av servrar som accepterar anslutningar utanför "
"asyncio men som använder asyncio för att hantera dem."

#: ../../library/asyncio-eventloop.rst:798
#: ../../library/asyncio-eventloop.rst:888
msgid "Parameters:"
msgstr "Parametrar:"

#: ../../library/asyncio-eventloop.rst:803
msgid ""
"*sock* is a preexisting socket object returned from :meth:`socket.accept "
"<socket.socket.accept>`."
msgstr ""
"*sock* är ett redan existerande socket-objekt som returneras från "
":meth:`socket.accept <socket.socket.accept>`."

#: ../../library/asyncio-eventloop.rst:812
msgid ""
"*ssl* can be set to an :class:`~ssl.SSLContext` to enable SSL over the "
"accepted connections."
msgstr ""
"*ssl* kan sättas till en :class:`~ssl.SSLContext` för att aktivera SSL över "
"de accepterade anslutningarna."

#: ../../library/asyncio-eventloop.rst:815
msgid ""
"*ssl_handshake_timeout* is (for an SSL connection) the time in seconds to "
"wait for the SSL handshake to complete before aborting the connection. "
"``60.0`` seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* är (för en SSL-anslutning) den tid i sekunder som "
"ska vänta på att SSL-handskakningen ska slutföras innan anslutningen "
"avbryts. ``60,0`` sekunder om ``None`` (standard)."

#: ../../library/asyncio-eventloop.rst:823
msgid "Returns a ``(transport, protocol)`` pair."
msgstr "Returnerar ett par ``(transport, protokoll)``."

#: ../../library/asyncio-eventloop.rst:837
msgid "Transferring files"
msgstr "Överföring av filer"

#: ../../library/asyncio-eventloop.rst:842
msgid ""
"Send a *file* over a *transport*.  Return the total number of bytes sent."
msgstr ""
"Skicka en *fil* över en *transport*.  Returnera det totala antalet bytes som"
" skickats."

#: ../../library/asyncio-eventloop.rst:845
msgid "The method uses high-performance :meth:`os.sendfile` if available."
msgstr ""
"Metoden använder högpresterande :meth:`os.sendfile` om sådan finns "
"tillgänglig."

#: ../../library/asyncio-eventloop.rst:847
msgid "*file* must be a regular file object opened in binary mode."
msgstr "*file* måste vara ett vanligt filobjekt som öppnas i binärt läge."

#: ../../library/asyncio-eventloop.rst:849
#: ../../library/asyncio-eventloop.rst:1094
msgid ""
"*offset* tells from where to start reading the file. If specified, *count* "
"is the total number of bytes to transmit as opposed to sending the file "
"until EOF is reached. File position is always updated, even when this method"
" raises an error, and :meth:`file.tell() <io.IOBase.tell>` can be used to "
"obtain the actual number of bytes sent."
msgstr ""
"*offset* anger varifrån filen ska börja läsas. Om det anges är *count* det "
"totala antalet byte som ska överföras i motsats till att skicka filen tills "
"EOF nås. Filens position uppdateras alltid, även om metoden ger upphov till "
"ett fel, och :meth:`file.tell() <io.IOBase.tell>` kan användas för att få "
"fram det faktiska antalet byte som skickats."

#: ../../library/asyncio-eventloop.rst:856
msgid ""
"*fallback* set to ``True`` makes asyncio to manually read and send the file "
"when the platform does not support the sendfile system call (e.g. Windows or"
" SSL socket on Unix)."
msgstr ""
"*fallback* satt till ``True`` gör att asyncio manuellt läser och skickar "
"filen när plattformen inte stöder systemanropet sendfile (t.ex. Windows "
"eller SSL-socket på Unix)."

#: ../../library/asyncio-eventloop.rst:860
msgid ""
"Raise :exc:`SendfileNotAvailableError` if the system does not support the "
"*sendfile* syscall and *fallback* is ``False``."
msgstr ""
"Utlöser :exc:`SendfileNotAvailableError` om systemet inte stöder syscallen "
"*sendfile* och *fallback* är ``False``."

#: ../../library/asyncio-eventloop.rst:867
msgid "TLS Upgrade"
msgstr "TLS-uppgradering"

#: ../../library/asyncio-eventloop.rst:874
msgid "Upgrade an existing transport-based connection to TLS."
msgstr "Uppgradera en befintlig transportbaserad anslutning till TLS."

#: ../../library/asyncio-eventloop.rst:876
msgid ""
"Create a TLS coder/decoder instance and insert it between the *transport* "
"and the *protocol*. The coder/decoder implements both *transport*-facing "
"protocol and *protocol*-facing transport."
msgstr ""
"Skapa en TLS-kodare/avkodare-instans och infoga den mellan *transport* och "
"*protokoll*. Kodaren/avkodaren implementerar både protokoll som vetter mot "
"*transport* och transport som vetter mot *protokoll*."

#: ../../library/asyncio-eventloop.rst:880
msgid ""
"Return the created two-interface instance. After *await*, the *protocol* "
"must stop using the original *transport* and communicate with the returned "
"object only because the coder caches *protocol*-side data and sporadically "
"exchanges extra TLS session packets with *transport*."
msgstr ""
"Returnerar den skapade instansen med två gränssnitt. Efter *await* måste "
"*protokollet* sluta använda den ursprungliga *transporten* och kommunicera "
"med det returnerade objektet endast eftersom kodaren cachar data på "
"*protokollsidan* och sporadiskt utbyter extra TLS-sessionspaket med "
"*transport*."

#: ../../library/asyncio-eventloop.rst:885
msgid ""
"In some situations (e.g. when the passed transport is already closing) this "
"may return ``None``."
msgstr ""
"I vissa situationer (t.ex. när den passerade transporten redan är stängd) "
"kan detta returnera ``None``."

#: ../../library/asyncio-eventloop.rst:890
msgid ""
"*transport* and *protocol* instances that methods like "
":meth:`~loop.create_server` and :meth:`~loop.create_connection` return."
msgstr ""
"*transport* och *protocol* instanser som metoder som "
":meth:`~loop.create_server` och :meth:`~loop.create_connection` returnerar."

#: ../../library/asyncio-eventloop.rst:894
msgid "*sslcontext*: a configured instance of :class:`~ssl.SSLContext`."
msgstr "*sslcontext*: en konfigurerad instans av :class:`~ssl.SSLContext`."

#: ../../library/asyncio-eventloop.rst:896
msgid ""
"*server_side* pass ``True`` when a server-side connection is being upgraded "
"(like the one created by :meth:`~loop.create_server`)."
msgstr ""
"*server_side* passerar ``True`` när en anslutning på serversidan uppgraderas"
" (som den som skapades av :meth:`~loop.create_server`)."

#: ../../library/asyncio-eventloop.rst:899
msgid ""
"*server_hostname*: sets or overrides the host name that the target server's "
"certificate will be matched against."
msgstr ""
"*server_hostname*: anger eller åsidosätter det värdnamn som målserverns "
"certifikat ska matchas mot."

#: ../../library/asyncio-eventloop.rst:919
msgid "Watching file descriptors"
msgstr "Titta på filbeskrivningar"

#: ../../library/asyncio-eventloop.rst:923
msgid ""
"Start monitoring the *fd* file descriptor for read availability and invoke "
"*callback* with the specified arguments once *fd* is available for reading."
msgstr ""
"Börja övervaka filbeskrivaren *fd* för lästillgänglighet och anropa "
"*callback* med de angivna argumenten när *fd* är tillgänglig för läsning."

#: ../../library/asyncio-eventloop.rst:929
msgid ""
"Stop monitoring the *fd* file descriptor for read availability. Returns "
"``True`` if *fd* was previously being monitored for reads."
msgstr ""
"Slutar övervaka filbeskrivaren *fd* för lästillgänglighet. Returnerar "
"``True`` om *fd* tidigare övervakades för läsningar."

#: ../../library/asyncio-eventloop.rst:934
msgid ""
"Start monitoring the *fd* file descriptor for write availability and invoke "
"*callback* with the specified arguments once *fd* is available for writing."
msgstr ""
"Börja övervaka filbeskrivaren *fd* för skrivtillgänglighet och anropa "
"*callback* med de angivna argumenten när *fd* är tillgänglig för skrivning."

#: ../../library/asyncio-eventloop.rst:938
#: ../../library/asyncio-eventloop.rst:1195
msgid ""
"Use :func:`functools.partial` :ref:`to pass keyword arguments <asyncio-pass-"
"keywords>` to *callback*."
msgstr ""
"Använd :func:`functools.partial` :ref:`för att skicka nyckelordsargument "
"<asyncio-pass-keywords>` till *callback*."

#: ../../library/asyncio-eventloop.rst:943
msgid ""
"Stop monitoring the *fd* file descriptor for write availability. Returns "
"``True`` if *fd* was previously being monitored for writes."
msgstr ""
"Slutar övervaka filbeskrivaren *fd* för skrivtillgänglighet. Returnerar "
"``True`` om *fd* tidigare övervakades för skrivningar."

#: ../../library/asyncio-eventloop.rst:946
msgid ""
"See also :ref:`Platform Support <asyncio-platform-support>` section for some"
" limitations of these methods."
msgstr ""
"Se även :ref:`Platformstöd <asyncio-platform-support>` för vissa "
"begränsningar av dessa metoder."

#: ../../library/asyncio-eventloop.rst:951
msgid "Working with socket objects directly"
msgstr "Arbeta direkt med socket-objekt"

#: ../../library/asyncio-eventloop.rst:953
msgid ""
"In general, protocol implementations that use transport-based APIs such as "
":meth:`loop.create_connection` and :meth:`loop.create_server` are faster "
"than implementations that work with sockets directly. However, there are "
"some use cases when performance is not critical, and working with "
":class:`~socket.socket` objects directly is more convenient."
msgstr ""
"I allmänhet är protokollimplementeringar som använder transportbaserade "
"API:er som :meth:`loop.create_connection` och :meth:`loop.create_server` "
"snabbare än implementeringar som arbetar direkt med sockets. Det finns dock "
"vissa användningsfall när prestanda inte är avgörande och det är bekvämare "
"att arbeta med :class:`~socket.socket`\\-objekt direkt."

#: ../../library/asyncio-eventloop.rst:962
msgid ""
"Receive up to *nbytes* from *sock*.  Asynchronous version of "
":meth:`socket.recv() <socket.socket.recv>`."
msgstr ""
"Ta emot upp till *nbytes* från *sock*.  Asynkron version av "
":meth:`socket.recv() <socket.socket.recv>`."

#: ../../library/asyncio-eventloop.rst:965
msgid "Return the received data as a bytes object."
msgstr "Returnerar den mottagna datan som ett bytesobjekt."

#: ../../library/asyncio-eventloop.rst:967
#: ../../library/asyncio-eventloop.rst:981
#: ../../library/asyncio-eventloop.rst:992
#: ../../library/asyncio-eventloop.rst:1004
#: ../../library/asyncio-eventloop.rst:1019
#: ../../library/asyncio-eventloop.rst:1034
#: ../../library/asyncio-eventloop.rst:1044
#: ../../library/asyncio-eventloop.rst:1070
#: ../../library/asyncio-eventloop.rst:1108
msgid "*sock* must be a non-blocking socket."
msgstr "*sock* måste vara ett icke-blockerande uttag."

#: ../../library/asyncio-eventloop.rst:969
msgid ""
"Even though this method was always documented as a coroutine method, "
"releases before Python 3.7 returned a :class:`Future`. Since Python 3.7 this"
" is an ``async def`` method."
msgstr ""
"Även om den här metoden alltid har dokumenterats som en coroutine-metod, "
"returnerade utgåvor före Python 3.7 en :class:`Future`. Sedan Python 3.7 är "
"detta en ``async def``\\ -metod."

#: ../../library/asyncio-eventloop.rst:976
msgid ""
"Receive data from *sock* into the *buf* buffer.  Modeled after the blocking "
":meth:`socket.recv_into() <socket.socket.recv_into>` method."
msgstr ""
"Tar emot data från *sock* till bufferten *buf*.  Modellerad efter den "
"blockerande :meth:`socket.recv_into() <socket.socket.recv_into>`\\-metoden."

#: ../../library/asyncio-eventloop.rst:979
msgid "Return the number of bytes written to the buffer."
msgstr "Returnerar antalet bytes som skrivits till bufferten."

#: ../../library/asyncio-eventloop.rst:987
msgid ""
"Receive a datagram of up to *bufsize* from *sock*.  Asynchronous version of "
":meth:`socket.recvfrom() <socket.socket.recvfrom>`."
msgstr ""
"Ta emot ett datagram på upp till *bufsize* från *sock*.  Asynkron version av"
" :meth:`socket.recvfrom() <socket.socket.recvfrom>`."

#: ../../library/asyncio-eventloop.rst:990
msgid "Return a tuple of (received data, remote address)."
msgstr "Returnera en tupel av (mottagna data, fjärradress)."

#: ../../library/asyncio-eventloop.rst:998
msgid ""
"Receive a datagram of up to *nbytes* from *sock* into *buf*. Asynchronous "
"version of :meth:`socket.recvfrom_into() <socket.socket.recvfrom_into>`."
msgstr ""
"Ta emot ett datagram på upp till *nbytes* från *sock* till *buf*. Asynkron "
"version av :meth:`socket.recvfrom_into() <socket.socket.recvfrom_into>`."

#: ../../library/asyncio-eventloop.rst:1002
msgid "Return a tuple of (number of bytes received, remote address)."
msgstr "Returnera en tupel av (antal mottagna byte, fjärradress)."

#: ../../library/asyncio-eventloop.rst:1010
msgid ""
"Send *data* to the *sock* socket. Asynchronous version of "
":meth:`socket.sendall() <socket.socket.sendall>`."
msgstr ""
"Skicka *data* till *sock* socket. Asynkron version av "
":meth:`socket.sendall() <socket.socket.sendall>`."

#: ../../library/asyncio-eventloop.rst:1013
msgid ""
"This method continues to send to the socket until either all data in *data* "
"has been sent or an error occurs.  ``None`` is returned on success.  On "
"error, an exception is raised. Additionally, there is no way to determine "
"how much data, if any, was successfully processed by the receiving end of "
"the connection."
msgstr ""
"Denna metod fortsätter att skicka till uttaget tills antingen all data i "
"*data* har skickats eller ett fel inträffar.  ``None`` returneras vid "
"framgång.  Vid fel uppstår ett undantag. Dessutom finns det inget sätt att "
"avgöra hur mycket data, om någon, som framgångsrikt behandlades av den "
"mottagande änden av anslutningen."

#: ../../library/asyncio-eventloop.rst:1021
#: ../../library/asyncio-eventloop.rst:1072
msgid ""
"Even though the method was always documented as a coroutine method, before "
"Python 3.7 it returned a :class:`Future`. Since Python 3.7, this is an "
"``async def`` method."
msgstr ""
"Även om metoden alltid dokumenterats som en coroutine-metod, returnerade den"
" före Python 3.7 en :class:`Future`. Sedan Python 3.7 är detta en ``async "
"def``\\ -metod."

#: ../../library/asyncio-eventloop.rst:1028
msgid ""
"Send a datagram from *sock* to *address*. Asynchronous version of "
":meth:`socket.sendto() <socket.socket.sendto>`."
msgstr ""
"Skicka ett datagram från *sock* till *address*. Asynkron version av "
":meth:`socket.sendto() <socket.socket.sendto>`."

#: ../../library/asyncio-eventloop.rst:1032
msgid "Return the number of bytes sent."
msgstr "Returnera antalet bytes som skickats."

#: ../../library/asyncio-eventloop.rst:1040
msgid "Connect *sock* to a remote socket at *address*."
msgstr "Anslut *sock* till en fjärrsockel på *address*."

#: ../../library/asyncio-eventloop.rst:1042
msgid ""
"Asynchronous version of :meth:`socket.connect() <socket.socket.connect>`."
msgstr "Asynkron version av :meth:`socket.connect() <socket.socket.connect>`."

#: ../../library/asyncio-eventloop.rst:1046
msgid ""
"``address`` no longer needs to be resolved.  ``sock_connect`` will try to "
"check if the *address* is already resolved by calling "
":func:`socket.inet_pton`.  If not, :meth:`loop.getaddrinfo` will be used to "
"resolve the *address*."
msgstr ""
"``address`` behöver inte längre lösas.  ``sock_connect`` kommer att försöka "
"kontrollera om *adressen* redan är löst genom att anropa "
":func:`socket.inet_pton`.  Om inte, kommer :meth:`loop.getaddrinfo` att "
"användas för att lösa upp *adressen*."

#: ../../library/asyncio-eventloop.rst:1055
msgid ""
":meth:`loop.create_connection` and  :func:`asyncio.open_connection() "
"<open_connection>`."
msgstr ""
":meth:`loop.create_connection` och :func:`asyncio.open_connection() "
"<open_connection>`."

#: ../../library/asyncio-eventloop.rst:1061
msgid ""
"Accept a connection.  Modeled after the blocking :meth:`socket.accept() "
"<socket.socket.accept>` method."
msgstr ""
"Acceptera en anslutning.  Modellerad efter den blockerande "
":meth:`socket.accept() <socket.socket.accept>`\\-metoden."

#: ../../library/asyncio-eventloop.rst:1064
msgid ""
"The socket must be bound to an address and listening for connections. The "
"return value is a pair ``(conn, address)`` where *conn* is a *new* socket "
"object usable to send and receive data on the connection, and *address* is "
"the address bound to the socket on the other end of the connection."
msgstr ""
"Uttaget måste vara bundet till en adress och lyssna efter anslutningar. "
"Returvärdet är ett par ``(conn, address)`` där *conn* är ett *nytt* "
"socketobjekt som kan användas för att skicka och ta emot data på "
"anslutningen och *address* är den adress som är bunden till sockeln i andra "
"änden av anslutningen."

#: ../../library/asyncio-eventloop.rst:1079
msgid ":meth:`loop.create_server` and :func:`start_server`."
msgstr ":meth:`loop.create_server` och :func:`start_server`."

#: ../../library/asyncio-eventloop.rst:1084
msgid ""
"Send a file using high-performance :mod:`os.sendfile` if possible. Return "
"the total number of bytes sent."
msgstr ""
"Skicka en fil med hjälp av högpresterande :mod:`os.sendfile` om möjligt. "
"Returnerar det totala antalet bytes som skickats."

#: ../../library/asyncio-eventloop.rst:1087
msgid ""
"Asynchronous version of :meth:`socket.sendfile() <socket.socket.sendfile>`."
msgstr ""
"Asynkron version av :meth:`socket.sendfile() <socket.socket.sendfile>`."

#: ../../library/asyncio-eventloop.rst:1089
msgid ""
"*sock* must be a non-blocking :const:`socket.SOCK_STREAM` "
":class:`~socket.socket`."
msgstr ""
"*sock* måste vara en icke-blockerande :const:`socket.SOCK_STREAM` "
":class:`~socket.socket`."

#: ../../library/asyncio-eventloop.rst:1092
msgid "*file* must be a regular file object open in binary mode."
msgstr "*file* måste vara ett vanligt filobjekt som öppnas i binärt läge."

#: ../../library/asyncio-eventloop.rst:1101
msgid ""
"*fallback*, when set to ``True``, makes asyncio manually read and send the "
"file when the platform does not support the sendfile syscall (e.g. Windows "
"or SSL socket on Unix)."
msgstr ""
"*fallback*, när den är inställd på ``True``, gör att asyncio manuellt läser "
"och skickar filen när plattformen inte stöder sendfile syscall (t.ex. "
"Windows eller SSL-socket på Unix)."

#: ../../library/asyncio-eventloop.rst:1105
msgid ""
"Raise :exc:`SendfileNotAvailableError` if the system does not support "
"*sendfile* syscall and *fallback* is ``False``."
msgstr ""
"Utlöser :exc:`SendfileNotAvailableError` om systemet inte stöder syscall "
"*sendfile* och *fallback* är ``False``."

#: ../../library/asyncio-eventloop.rst:1114
msgid "DNS"
msgstr "DNS"

#: ../../library/asyncio-eventloop.rst:1119
msgid "Asynchronous version of :meth:`socket.getaddrinfo`."
msgstr "Asynkron version av :meth:`socket.getaddrinfo`."

#: ../../library/asyncio-eventloop.rst:1123
msgid "Asynchronous version of :meth:`socket.getnameinfo`."
msgstr "Asynkron version av :meth:`socket.getnameinfo`."

#: ../../library/asyncio-eventloop.rst:1125
msgid ""
"Both *getaddrinfo* and *getnameinfo* methods were always documented to "
"return a coroutine, but prior to Python 3.7 they were, in fact, returning "
":class:`asyncio.Future` objects.  Starting with Python 3.7 both methods are "
"coroutines."
msgstr ""
"Både metoderna *getaddrinfo* och *getnameinfo* har alltid dokumenterats att "
"returnera en coroutine, men före Python 3.7 returnerade de i själva verket "
":class:`asyncio.Future`\\-objekt.  Från och med Python 3.7 är båda metoderna"
" coroutines."

#: ../../library/asyncio-eventloop.rst:1133
msgid "Working with pipes"
msgstr "Arbeta med rör"

#: ../../library/asyncio-eventloop.rst:1137
msgid "Register the read end of *pipe* in the event loop."
msgstr "Registrera lässlutet av *pipe* i händelseslingan."

#: ../../library/asyncio-eventloop.rst:1142
msgid "*pipe* is a :term:`file-like object <file object>`."
msgstr "*pipe* är en :term:`filliknande objekt <file object>`."

#: ../../library/asyncio-eventloop.rst:1144
msgid ""
"Return pair ``(transport, protocol)``, where *transport* supports the "
":class:`ReadTransport` interface and *protocol* is an object instantiated by"
" the *protocol_factory*."
msgstr ""
"Returnerar paret ``(transport, protocol)``, där *transport* stöder "
"gränssnittet :class:`ReadTransport` och *protocol* är ett objekt som "
"instantierats av *protocol_factory*."

#: ../../library/asyncio-eventloop.rst:1148
#: ../../library/asyncio-eventloop.rst:1164
msgid ""
"With :class:`SelectorEventLoop` event loop, the *pipe* is set to non-"
"blocking mode."
msgstr ""
"Med :class:`SelectorEventLoop` händelseslinga är *pipe* inställd på icke-"
"blockerande läge."

#: ../../library/asyncio-eventloop.rst:1153
msgid "Register the write end of *pipe* in the event loop."
msgstr "Registrera den skrivande änden av *pipe* i händelseslingan."

#: ../../library/asyncio-eventloop.rst:1158
msgid "*pipe* is :term:`file-like object <file object>`."
msgstr "*pipe* är :term:`filliknande objekt <file object>`."

#: ../../library/asyncio-eventloop.rst:1160
msgid ""
"Return pair ``(transport, protocol)``, where *transport* supports "
":class:`WriteTransport` interface and *protocol* is an object instantiated "
"by the *protocol_factory*."
msgstr ""
"Returnerar paret ``(transport, protocol)``, där *transport* stöder "
":class:`WriteTransport`\\-gränssnittet och *protocol* är ett objekt som "
"instantierats av *protocol_factory*."

#: ../../library/asyncio-eventloop.rst:1169
msgid ""
":class:`SelectorEventLoop` does not support the above methods on Windows.  "
"Use :class:`ProactorEventLoop` instead for Windows."
msgstr ""
":class:`SelectorEventLoop` har inte stöd för ovanstående metoder i Windows."
"  Använd :class:`ProactorEventLoop` istället för Windows."

#: ../../library/asyncio-eventloop.rst:1174
msgid ""
"The :meth:`loop.subprocess_exec` and :meth:`loop.subprocess_shell` methods."
msgstr ""
"Metoderna :meth:`loop.subprocess_exec` och :meth:`loop.subprocess_shell`."

#: ../../library/asyncio-eventloop.rst:1179
msgid "Unix signals"
msgstr "Unix-signaler"

#: ../../library/asyncio-eventloop.rst:1185
msgid "Set *callback* as the handler for the *signum* signal."
msgstr "Ställ in *callback* som hanterare av signalen *signum*."

#: ../../library/asyncio-eventloop.rst:1187
msgid ""
"The callback will be invoked by *loop*, along with other queued callbacks "
"and runnable coroutines of that event loop. Unlike signal handlers "
"registered using :func:`signal.signal`, a callback registered with this "
"function is allowed to interact with the event loop."
msgstr ""
"Återanropet kommer att anropas av *loop*, tillsammans med andra köade "
"återanrop och körbara coroutines i den händelseslingan. Till skillnad från "
"signalhanterare som registreras med :func:`signal.signal`, får en "
"återuppringning som registreras med den här funktionen interagera med "
"händelseslingan."

#: ../../library/asyncio-eventloop.rst:1192
msgid ""
"Raise :exc:`ValueError` if the signal number is invalid or uncatchable. "
"Raise :exc:`RuntimeError` if there is a problem setting up the handler."
msgstr ""
"Ge upphov till :exc:`ValueError` om signalnumret är ogiltigt eller inte kan "
"fångas upp. Raise :exc:`RuntimeError` om det finns ett problem med att "
"konfigurera hanteraren."

#: ../../library/asyncio-eventloop.rst:1198
msgid ""
"Like :func:`signal.signal`, this function must be invoked in the main "
"thread."
msgstr ""
"Precis som :func:`signal.signal` måste den här funktionen anropas i "
"huvudtråden."

#: ../../library/asyncio-eventloop.rst:1203
msgid "Remove the handler for the *sig* signal."
msgstr "Ta bort hanteraren för signalen *sig*."

#: ../../library/asyncio-eventloop.rst:1205
msgid ""
"Return ``True`` if the signal handler was removed, or ``False`` if no "
"handler was set for the given signal."
msgstr ""
"Returnerar ``True`` om signalhanteraren togs bort, eller ``False`` om ingen "
"hanterare ställdes in för den givna signalen."

#: ../../library/asyncio-eventloop.rst:1212
msgid "The :mod:`signal` module."
msgstr "Modulen :mod:`signal`."

#: ../../library/asyncio-eventloop.rst:1216
msgid "Executing code in thread or process pools"
msgstr "Exekvering av kod i tråd- eller processpooler"

#: ../../library/asyncio-eventloop.rst:1220
msgid "Arrange for *func* to be called in the specified executor."
msgstr "Ordna så att *func* anropas i den angivna exekveraren."

#: ../../library/asyncio-eventloop.rst:1222
msgid ""
"The *executor* argument should be an :class:`concurrent.futures.Executor` "
"instance. The default executor is used if *executor* is ``None``."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1267
msgid ""
"Note that the entry point guard (``if __name__ == '__main__'``) is required "
"for option 3 due to the peculiarities of :mod:`multiprocessing`, which is "
"used by :class:`~concurrent.futures.ProcessPoolExecutor`. See :ref:`Safe "
"importing of main module <multiprocessing-safe-main-import>`."
msgstr ""
"Observera att startpunktsskyddet (``if __name__ == '__main__'``) krävs för "
"alternativ 3 på grund av de speciella egenskaperna hos "
":mod:`multiprocessing`, som används av "
":class:`~concurrent.futures.ProcessPoolExecutor`. Se :ref:`Säker import av "
"huvudmodulen <multiprocessing-safe-main-import>`."

#: ../../library/asyncio-eventloop.rst:1272
msgid "This method returns a :class:`asyncio.Future` object."
msgstr "Denna metod returnerar ett :class:`asyncio.Future`\\-objekt."

#: ../../library/asyncio-eventloop.rst:1274
msgid ""
"Use :func:`functools.partial` :ref:`to pass keyword arguments <asyncio-pass-"
"keywords>` to *func*."
msgstr ""
"Använd :func:`functools.partial` :ref:`för att skicka nyckelordsargument "
"<asyncio-pass-keywords>` till *func*."

#: ../../library/asyncio-eventloop.rst:1277
msgid ""
":meth:`loop.run_in_executor` no longer configures the ``max_workers`` of the"
" thread pool executor it creates, instead leaving it up to the thread pool "
"executor (:class:`~concurrent.futures.ThreadPoolExecutor`) to set the "
"default."
msgstr ""
":meth:`loop.run_in_executor` konfigurerar inte längre ``max_workers`` för "
"den trådpoolsexekutor som den skapar, utan överlåter det till "
"trådpoolsexekutorn (:class:`~concurrent.futures.ThreadPoolExecutor`) att "
"ange standardvärdet."

#: ../../library/asyncio-eventloop.rst:1286
msgid ""
"Set *executor* as the default executor used by :meth:`run_in_executor`. "
"*executor* must be an instance of "
":class:`~concurrent.futures.ThreadPoolExecutor`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1290
msgid ""
"*executor* must be an instance of "
":class:`~concurrent.futures.ThreadPoolExecutor`."
msgstr ""
"*executor* måste vara en instans av "
":class:`~concurrent.futures.ThreadPoolExecutor`."

#: ../../library/asyncio-eventloop.rst:1296
msgid "Error Handling API"
msgstr "API för felhantering"

#: ../../library/asyncio-eventloop.rst:1298
msgid "Allows customizing how exceptions are handled in the event loop."
msgstr "Gör det möjligt att anpassa hur undantag hanteras i händelseslingan."

#: ../../library/asyncio-eventloop.rst:1302
msgid "Set *handler* as the new event loop exception handler."
msgstr "Ange *handler* som den nya undantagshanteraren för händelseslingan."

#: ../../library/asyncio-eventloop.rst:1304
msgid ""
"If *handler* is ``None``, the default exception handler will be set.  "
"Otherwise, *handler* must be a callable with the signature matching ``(loop,"
" context)``, where ``loop`` is a reference to the active event loop, and "
"``context`` is a ``dict`` object containing the details of the exception "
"(see :meth:`call_exception_handler` documentation for details about "
"context)."
msgstr ""
"Om *handler* är ``None`` kommer standardhanteraren för undantag att "
"användas.  Annars måste *handler* vara en callable med en signatur som "
"matchar ``(loop, context)``, där ``loop`` är en referens till den aktiva "
"händelseslingan och ``context`` är ett ``dict``\\ -objekt som innehåller "
"detaljer om undantaget (se :meth:`call_exception_handler`\\-dokumentationen "
"för detaljer om context)."

#: ../../library/asyncio-eventloop.rst:1314
msgid ""
"Return the current exception handler, or ``None`` if no custom exception "
"handler was set."
msgstr ""
"Returnerar den aktuella undantagshanteraren, eller ``None`` om ingen egen "
"undantagshanterare har angetts."

#: ../../library/asyncio-eventloop.rst:1321
msgid "Default exception handler."
msgstr "Standardhantering av undantag."

#: ../../library/asyncio-eventloop.rst:1323
msgid ""
"This is called when an exception occurs and no exception handler is set. "
"This can be called by a custom exception handler that wants to defer to the "
"default handler behavior."
msgstr ""
"Detta anropas när ett undantag inträffar och ingen undantagshanterare är "
"inställd. Detta kan anropas av en anpassad undantagshanterare som vill "
"använda standardhanterarens beteende."

#: ../../library/asyncio-eventloop.rst:1327
msgid ""
"*context* parameter has the same meaning as in "
":meth:`call_exception_handler`."
msgstr ""
"*context*-parametern har samma betydelse som i "
":meth:`call_exception_handler`."

#: ../../library/asyncio-eventloop.rst:1332
msgid "Call the current event loop exception handler."
msgstr "Anropa den aktuella undantagshanteraren för händelseslingan."

#: ../../library/asyncio-eventloop.rst:1334
msgid ""
"*context* is a ``dict`` object containing the following keys (new keys may "
"be introduced in future Python versions):"
msgstr ""
"*context* är ett ``dict``\\ -objekt som innehåller följande nycklar (nya "
"nycklar kan komma att införas i framtida Python-versioner):"

#: ../../library/asyncio-eventloop.rst:1337
msgid "'message': Error message;"
msgstr "\"meddelande\": Felmeddelande;"

#: ../../library/asyncio-eventloop.rst:1338
msgid "'exception' (optional): Exception object;"
msgstr "\"undantag\" (valfritt): Objekt för undantag;"

#: ../../library/asyncio-eventloop.rst:1339
msgid "'future' (optional): :class:`asyncio.Future` instance;"
msgstr "\"future\" (valfritt): :class:`asyncio.Future` instans;"

#: ../../library/asyncio-eventloop.rst:1340
msgid "'task' (optional): :class:`asyncio.Task` instance;"
msgstr "'task' (valfritt): :class:`asyncio.Task` instans;"

#: ../../library/asyncio-eventloop.rst:1341
msgid "'handle' (optional): :class:`asyncio.Handle` instance;"
msgstr "'handle' (valfritt): :class:`asyncio.Handle` instans;"

#: ../../library/asyncio-eventloop.rst:1342
msgid "'protocol' (optional): :ref:`Protocol <asyncio-protocol>` instance;"
msgstr "\"protocol\" (valfritt): :ref:`Protocol <asyncio-protocol>` instance;"

#: ../../library/asyncio-eventloop.rst:1343
msgid "'transport' (optional): :ref:`Transport <asyncio-transport>` instance;"
msgstr "\"transport\" (valfritt): :ref:`Transport <asyncio-transport>` instance;"

#: ../../library/asyncio-eventloop.rst:1344
msgid "'socket' (optional): :class:`socket.socket` instance;"
msgstr "'socket' (valfritt): :class:`socket.socket` instans;"

#: ../../library/asyncio-eventloop.rst:1346
msgid "'asyncgen' (optional): Asynchronous generator that caused"
msgstr "\"asyncgen\" (valfritt): Asynkron generator som orsakade"

#: ../../library/asyncio-eventloop.rst:1346
msgid "the exception."
msgstr "undantaget."

#: ../../library/asyncio-eventloop.rst:1350
msgid ""
"This method should not be overloaded in subclassed event loops.  For custom "
"exception handling, use the :meth:`set_exception_handler()` method."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1355
msgid "Enabling debug mode"
msgstr "Aktivering av felsökningsläge"

#: ../../library/asyncio-eventloop.rst:1359
msgid "Get the debug mode (:class:`bool`) of the event loop."
msgstr "Hämta felsökningsläget (:class:`bool`) för händelseslingan."

#: ../../library/asyncio-eventloop.rst:1361
msgid ""
"The default value is ``True`` if the environment variable "
":envvar:`PYTHONASYNCIODEBUG` is set to a non-empty string, ``False`` "
"otherwise."
msgstr ""
"Standardvärdet är ``True`` om miljövariabeln :envvar:`PYTHONASYNCIODEBUG` är"
" inställd på en icke-tom sträng, annars ``False``."

#: ../../library/asyncio-eventloop.rst:1367
msgid "Set the debug mode of the event loop."
msgstr "Ställ in felsökningsläget för händelseslingan."

#: ../../library/asyncio-eventloop.rst:1371
msgid ""
"The new :ref:`Python Development Mode <devmode>` can now also be used to "
"enable the debug mode."
msgstr ""
"Den nya :ref:`Python Development Mode <devmode>` kan nu också användas för "
"att aktivera felsökningsläget."

#: ../../library/asyncio-eventloop.rst:1376
msgid ""
"This attribute can be used to set the minimum execution duration in seconds "
"that is considered \"slow\". When debug mode is enabled, \"slow\" callbacks "
"are logged."
msgstr ""
"Detta attribut kan användas för att ange den minsta exekveringstid i "
"sekunder som anses vara \"långsam\". När felsökningsläget är aktiverat "
"loggas \"långsamma\" callbacks."

#: ../../library/asyncio-eventloop.rst:1380
msgid "Default value is 100 milliseconds."
msgstr "Standardvärdet är 100 millisekunder."

#: ../../library/asyncio-eventloop.rst:1384
msgid "The :ref:`debug mode of asyncio <asyncio-debug-mode>`."
msgstr ":ref:`debuggläge för asyncio <asyncio-debug-mode>`."

#: ../../library/asyncio-eventloop.rst:1388
msgid "Running Subprocesses"
msgstr "Körning av underprocesser"

#: ../../library/asyncio-eventloop.rst:1390
msgid ""
"Methods described in this subsections are low-level.  In regular async/await"
" code consider using the high-level :func:`asyncio.create_subprocess_shell` "
"and :func:`asyncio.create_subprocess_exec` convenience functions instead."
msgstr ""
"Metoder som beskrivs i detta underavsnitt är på låg nivå.  I vanlig "
"async/await-kod bör du överväga att använda bekvämlighetsfunktionerna på hög"
" nivå :func:`asyncio.create_subprocess_shell` och "
":func:`asyncio.create_subprocess_exec` istället."

#: ../../library/asyncio-eventloop.rst:1397
msgid ""
"On Windows, the default event loop :class:`ProactorEventLoop` supports "
"subprocesses, whereas :class:`SelectorEventLoop` does not. See "
":ref:`Subprocess Support on Windows <asyncio-windows-subprocess>` for "
"details."
msgstr ""
"I Windows har standardhändelseslingan :class:`ProactorEventLoop` stöd för "
"underprocesser, medan :class:`SelectorEventLoop` inte har det. Se "
":ref:`Subprocessstöd på Windows <asyncio-windows-subprocess>` för mer "
"information."

#: ../../library/asyncio-eventloop.rst:1408
msgid ""
"Create a subprocess from one or more string arguments specified by *args*."
msgstr ""
"Skapa en subprocess från ett eller flera strängargument som anges av *args*."

#: ../../library/asyncio-eventloop.rst:1411
msgid "*args* must be a list of strings represented by:"
msgstr "*args* måste vara en lista med strängar som representeras av:"

#: ../../library/asyncio-eventloop.rst:1413
msgid ":class:`str`;"
msgstr ":class:`str`;"

#: ../../library/asyncio-eventloop.rst:1414
msgid ""
"or :class:`bytes`, encoded to the :ref:`filesystem encoding <filesystem-"
"encoding>`."
msgstr ""
"eller :class:`bytes`, kodad enligt :ref:`filsystemskodning <filesystem-"
"encoding>`."

#: ../../library/asyncio-eventloop.rst:1417
msgid ""
"The first string specifies the program executable, and the remaining strings"
" specify the arguments.  Together, string arguments form the ``argv`` of the"
" program."
msgstr ""
"Den första strängen anger det körbara programmet och de återstående "
"strängarna anger argumenten.  Tillsammans bildar strängargumenten "
"programmets ``argv``."

#: ../../library/asyncio-eventloop.rst:1421
msgid ""
"This is similar to the standard library :class:`subprocess.Popen` class "
"called with ``shell=False`` and the list of strings passed as the first "
"argument; however, where :class:`~subprocess.Popen` takes a single argument "
"which is list of strings, *subprocess_exec* takes multiple string arguments."
msgstr ""
"Detta liknar standardbibliotekets klass :class:`subprocess.Popen` som "
"anropas med ``shell=False`` och en lista med strängar som första argument; "
"men där :class:`~subprocess.Popen` tar ett enda argument som är en lista med"
" strängar, tar *subprocess_exec* flera strängargument."

#: ../../library/asyncio-eventloop.rst:1427
msgid ""
"The *protocol_factory* must be a callable returning a subclass of the "
":class:`asyncio.SubprocessProtocol` class."
msgstr ""
"*protocol_factory* måste vara en callable som returnerar en subklass av "
"klassen :class:`asyncio.SubprocessProtocol`."

#: ../../library/asyncio-eventloop.rst:1430
msgid "Other parameters:"
msgstr "Övriga parametrar:"

#: ../../library/asyncio-eventloop.rst:1432
msgid "*stdin* can be any of these:"
msgstr "*stdin* kan vara vilket som helst av dessa:"

#: ../../library/asyncio-eventloop.rst:1434
msgid ""
"a file-like object representing a pipe to be connected to the subprocess's "
"standard input stream using :meth:`~loop.connect_write_pipe`"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1437
#: ../../library/asyncio-eventloop.rst:1449
#: ../../library/asyncio-eventloop.rst:1461
msgid ""
"the :const:`subprocess.PIPE` constant (default) which will create a new pipe"
" and connect it,"
msgstr ""
"konstanten :const:`subprocess.PIPE` (standard) som skapar ett nytt rör och "
"ansluter det,"

#: ../../library/asyncio-eventloop.rst:1439
#: ../../library/asyncio-eventloop.rst:1451
#: ../../library/asyncio-eventloop.rst:1463
msgid ""
"the value ``None`` which will make the subprocess inherit the file "
"descriptor from this process"
msgstr ""
"värdet ``None`` som gör att subprocessen ärver filbeskrivaren från den här "
"processen"

#: ../../library/asyncio-eventloop.rst:1441
#: ../../library/asyncio-eventloop.rst:1453
#: ../../library/asyncio-eventloop.rst:1465
msgid ""
"the :const:`subprocess.DEVNULL` constant which indicates that the special "
":data:`os.devnull` file will be used"
msgstr ""
"konstanten :const:`subprocess.DEVNULL` som anger att den speciella filen "
":data:`os.devnull` ska användas"

#: ../../library/asyncio-eventloop.rst:1444
msgid "*stdout* can be any of these:"
msgstr "*stdout* kan vara vilken som helst av dessa:"

#: ../../library/asyncio-eventloop.rst:1446
msgid ""
"a file-like object representing a pipe to be connected to the subprocess's "
"standard output stream using :meth:`~loop.connect_write_pipe`"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1456
msgid "*stderr* can be any of these:"
msgstr "*stderr* kan vara vilken som helst av dessa:"

#: ../../library/asyncio-eventloop.rst:1458
msgid ""
"a file-like object representing a pipe to be connected to the subprocess's "
"standard error stream using :meth:`~loop.connect_write_pipe`"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1467
msgid ""
"the :const:`subprocess.STDOUT` constant which will connect the standard "
"error stream to the process' standard output stream"
msgstr ""
"konstanten :const:`subprocess.STDOUT` som kopplar standardfelströmmen till "
"processens standardutgångsström"

#: ../../library/asyncio-eventloop.rst:1470
msgid ""
"All other keyword arguments are passed to :class:`subprocess.Popen` without "
"interpretation, except for *bufsize*, *universal_newlines*, *shell*, *text*,"
" *encoding* and *errors*, which should not be specified at all."
msgstr ""
"Alla andra nyckelordsargument skickas till :class:`subprocess.Popen` utan "
"tolkning, med undantag för *bufsize*, *universal_newlines*, *shell*, *text*,"
" *encoding* och *errors*, som inte bör anges alls."

#: ../../library/asyncio-eventloop.rst:1475
msgid ""
"The ``asyncio`` subprocess API does not support decoding the streams as "
"text. :func:`bytes.decode` can be used to convert the bytes returned from "
"the stream to text."
msgstr ""
"API:et för underprocesser i ``asyncio`` stöder inte avkodning av strömmar "
"som text. :func:`bytes.decode` kan användas för att konvertera byte som "
"returneras från strömmen till text."

#: ../../library/asyncio-eventloop.rst:1479
msgid ""
"See the constructor of the :class:`subprocess.Popen` class for documentation"
" on other arguments."
msgstr ""
"Se konstruktören för klassen :class:`subprocess.Popen` för dokumentation om "
"andra argument."

#: ../../library/asyncio-eventloop.rst:1482
msgid ""
"Returns a pair of ``(transport, protocol)``, where *transport* conforms to "
"the :class:`asyncio.SubprocessTransport` base class and *protocol* is an "
"object instantiated by the *protocol_factory*."
msgstr ""
"Returnerar ett par ``(transport, protocol)``, där *transport* överensstämmer"
" med basklassen :class:`asyncio.SubprocessTransport` och *protocol* är ett "
"objekt som instantierats av *protocol_factory*."

#: ../../library/asyncio-eventloop.rst:1490
msgid ""
"Create a subprocess from *cmd*, which can be a :class:`str` or a "
":class:`bytes` string encoded to the :ref:`filesystem encoding <filesystem-"
"encoding>`, using the platform's \"shell\" syntax."
msgstr ""
"Skapa en underprocess från *cmd*, som kan vara en :class:`str` eller en "
":class:`bytes`\\-sträng kodad enligt :ref:`filsystemets kodning <filesystem-"
"encoding>`, med hjälp av plattformens \"shell\"-syntax."

#: ../../library/asyncio-eventloop.rst:1495
msgid ""
"This is similar to the standard library :class:`subprocess.Popen` class "
"called with ``shell=True``."
msgstr ""
"Detta liknar standardbibliotekets :class:`subprocess.Popen`\\-klass som "
"anropas med ``shell=True``."

#: ../../library/asyncio-eventloop.rst:1498
msgid ""
"The *protocol_factory* must be a callable returning a subclass of the "
":class:`SubprocessProtocol` class."
msgstr ""
"*protocol_factory* måste vara en callable som returnerar en subklass av "
"klassen :class:`SubprocessProtocol`."

#: ../../library/asyncio-eventloop.rst:1501
msgid ""
"See :meth:`~loop.subprocess_exec` for more details about the remaining "
"arguments."
msgstr ""
"Se :meth:`~loop.subprocess_exec` för mer information om de återstående "
"argumenten."

#: ../../library/asyncio-eventloop.rst:1504
msgid ""
"Returns a pair of ``(transport, protocol)``, where *transport* conforms to "
"the :class:`SubprocessTransport` base class and *protocol* is an object "
"instantiated by the *protocol_factory*."
msgstr ""
"Returnerar ett par ``(transport, protocol)``, där *transport* överensstämmer"
" med basklassen :class:`SubprocessTransport` och *protocol* är ett objekt "
"som instantierats av *protocol_factory*."

#: ../../library/asyncio-eventloop.rst:1509
msgid ""
"It is the application's responsibility to ensure that all whitespace and "
"special characters are quoted appropriately to avoid `shell injection "
"<https://en.wikipedia.org/wiki/Shell_injection#Shell_injection>`_ "
"vulnerabilities. The :func:`shlex.quote` function can be used to properly "
"escape whitespace and special characters in strings that are going to be "
"used to construct shell commands."
msgstr ""
"Det är applikationens ansvar att se till att alla blanksteg och "
"specialtecken citeras på rätt sätt för att undvika `shell injection "
"<https://en.wikipedia.org/wiki/Shell_injection#Shell_injection>`_ "
"sårbarheter. Funktionen :func:`shlex.quote` kan användas för att på rätt "
"sätt undkomma blanksteg och specialtecken i strängar som ska användas för "
"att konstruera skalkommandon."

#: ../../library/asyncio-eventloop.rst:1518
msgid "Callback Handles"
msgstr "Handtag för återuppringning"

#: ../../library/asyncio-eventloop.rst:1522
msgid ""
"A callback wrapper object returned by :meth:`loop.call_soon`, "
":meth:`loop.call_soon_threadsafe`."
msgstr ""
"Ett omslagsobjekt för återuppringning som returneras av "
":meth:`loop.call_soon`, :meth:`loop.call_soon_threadsafe`."

#: ../../library/asyncio-eventloop.rst:1527
msgid ""
"Cancel the callback.  If the callback has already been canceled or executed,"
" this method has no effect."
msgstr ""
"Avbryt återuppringningen.  Om återkallelsen redan har avbrutits eller "
"utförts har denna metod ingen effekt."

#: ../../library/asyncio-eventloop.rst:1532
msgid "Return ``True`` if the callback was cancelled."
msgstr "Returnerar ``True`` om återuppringningen avbröts."

#: ../../library/asyncio-eventloop.rst:1538
msgid ""
"A callback wrapper object returned by :meth:`loop.call_later`, and "
":meth:`loop.call_at`."
msgstr ""
"Ett omslagsobjekt för återuppringning som returneras av "
":meth:`loop.call_later` och :meth:`loop.call_at`."

#: ../../library/asyncio-eventloop.rst:1541
msgid "This class is a subclass of :class:`Handle`."
msgstr "Denna klass är en underklass till :class:`Handle`."

#: ../../library/asyncio-eventloop.rst:1545
msgid "Return a scheduled callback time as :class:`float` seconds."
msgstr "Returnerar en schemalagd callback-tid som :class:`float` sekunder."

#: ../../library/asyncio-eventloop.rst:1547
msgid ""
"The time is an absolute timestamp, using the same time reference as "
":meth:`loop.time`."
msgstr ""
"Tiden är en absolut tidsstämpel som använder samma tidsreferens som "
":meth:`loop.time`."

#: ../../library/asyncio-eventloop.rst:1554
msgid "Server Objects"
msgstr "Serverobjekt"

#: ../../library/asyncio-eventloop.rst:1556
msgid ""
"Server objects are created by :meth:`loop.create_server`, "
":meth:`loop.create_unix_server`, :func:`start_server`, and "
":func:`start_unix_server` functions."
msgstr ""
"Serverobjekt skapas av funktionerna :meth:`loop.create_server`, "
":meth:`loop.create_unix_server`, :func:`start_server` och "
":func:`start_unix_server`."

#: ../../library/asyncio-eventloop.rst:1560
msgid "Do not instantiate the :class:`Server` class directly."
msgstr "Instansiera inte :class:`Server`\\-klassen direkt."

#: ../../library/asyncio-eventloop.rst:1564
msgid ""
"*Server* objects are asynchronous context managers.  When used in an ``async"
" with`` statement, it's guaranteed that the Server object is closed and not "
"accepting new connections when the ``async with`` statement is completed::"
msgstr ""
"*Server*-objekt är asynkrona kontexthanterare. När de används i ett ``async "
"with``\\ -uttryck, garanteras det att Server-objektet stängs och inte "
"accepterar nya anslutningar när ``async with`` -uttrycket är slutfört::"

#: ../../library/asyncio-eventloop.rst:1577
msgid "Server object is an asynchronous context manager since Python 3.7."
msgstr "Server-objektet är en asynkron kontexthanterare sedan Python 3.7."

#: ../../library/asyncio-eventloop.rst:1580
msgid ""
"This class was exposed publicly as ``asyncio.Server`` in Python 3.9.11, "
"3.10.3 and 3.11."
msgstr ""
"Denna klass exponerades offentligt som ``asyncio.Server`` i Python 3.9.11, "
"3.10.3 och 3.11."

#: ../../library/asyncio-eventloop.rst:1585
msgid ""
"Stop serving: close listening sockets and set the :attr:`sockets` attribute "
"to ``None``."
msgstr ""
"Stoppa servering: stäng lyssnande uttag och sätt attributet :attr:`sockets` "
"till ``None``."

#: ../../library/asyncio-eventloop.rst:1588
msgid ""
"The sockets that represent existing incoming client connections are left "
"open."
msgstr ""
"De uttag som representerar befintliga inkommande klientanslutningar lämnas "
"öppna."

#: ../../library/asyncio-eventloop.rst:1591
msgid ""
"The server is closed asynchronously, use the :meth:`wait_closed` coroutine "
"to wait until the server is closed."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1596
msgid "Return the event loop associated with the server object."
msgstr "Returnerar den händelseslinga som är kopplad till serverobjektet."

#: ../../library/asyncio-eventloop.rst:1602
msgid "Start accepting connections."
msgstr "Börja acceptera kontakter."

#: ../../library/asyncio-eventloop.rst:1604
msgid ""
"This method is idempotent, so it can be called when the server is already "
"serving."
msgstr ""
"Denna metod är idempotent, så den kan anropas när servern redan är i drift."

#: ../../library/asyncio-eventloop.rst:1607
msgid ""
"The *start_serving* keyword-only parameter to :meth:`loop.create_server` and"
" :meth:`asyncio.start_server` allows creating a Server object that is not "
"accepting connections initially.  In this case ``Server.start_serving()``, "
"or :meth:`Server.serve_forever` can be used to make the Server start "
"accepting connections."
msgstr ""
"Nyckelordsparametern *start_serving* till :meth:`loop.create_server` och "
":meth:`asyncio.start_server` gör det möjligt att skapa ett serverobjekt som "
"inte accepterar anslutningar initialt.  I det här fallet kan "
"``Server.start_serving()`` eller :meth:`Server.serve_forever` användas för "
"att få servern att börja acceptera anslutningar."

#: ../../library/asyncio-eventloop.rst:1618
msgid ""
"Start accepting connections until the coroutine is cancelled. Cancellation "
"of ``serve_forever`` task causes the server to be closed."
msgstr ""
"Börja acceptera anslutningar tills coroutinen avbryts. Om uppgiften "
"``serve_forever`` avbryts stängs servern."

#: ../../library/asyncio-eventloop.rst:1622
msgid ""
"This method can be called if the server is already accepting connections.  "
"Only one ``serve_forever`` task can exist per one *Server* object."
msgstr ""
"Denna metod kan anropas om servern redan accepterar anslutningar.  Endast en"
" ``serve_forever`` uppgift kan finnas per ett *Server*-objekt."

#: ../../library/asyncio-eventloop.rst:1644
msgid "Return ``True`` if the server is accepting new connections."
msgstr "Returnerar ``True`` om servern accepterar nya anslutningar."

#: ../../library/asyncio-eventloop.rst:1650
msgid "Wait until the :meth:`close` method completes."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1654
msgid ""
"List of socket-like objects, ``asyncio.trsock.TransportSocket``, which the "
"server is listening on."
msgstr ""
"Lista över socket-liknande objekt, ``asyncio.trsock.TransportSocket``, som "
"servern lyssnar på."

#: ../../library/asyncio-eventloop.rst:1657
msgid ""
"Prior to Python 3.7 ``Server.sockets`` used to return an internal list of "
"server sockets directly.  In 3.7 a copy of that list is returned."
msgstr ""
"Före Python 3.7 brukade ``Server.sockets`` returnera en intern lista över "
"serverns sockets direkt.  I 3.7 returneras en kopia av den listan."

#: ../../library/asyncio-eventloop.rst:1667
msgid "Event Loop Implementations"
msgstr "Implementering av händelseslingor"

#: ../../library/asyncio-eventloop.rst:1669
msgid ""
"asyncio ships with two different event loop implementations: "
":class:`SelectorEventLoop` and :class:`ProactorEventLoop`."
msgstr ""
"asyncio levereras med två olika implementationer av händelseslingor: "
":class:`SelectorEventLoop` och :class:`ProactorEventLoop`."

#: ../../library/asyncio-eventloop.rst:1672
msgid ""
"By default asyncio is configured to use :class:`SelectorEventLoop` on Unix "
"and :class:`ProactorEventLoop` on Windows."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1678
msgid "An event loop based on the :mod:`selectors` module."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1680
msgid ""
"Uses the most efficient *selector* available for the given platform.  It is "
"also possible to manually configure the exact selector implementation to be "
"used::"
msgstr ""
"Använder den effektivaste *väljaren* som finns tillgänglig för den givna "
"plattformen.  Det är också möjligt att manuellt konfigurera den exakta "
"implementeringen av väljaren som ska användas::"

#: ../../library/asyncio-eventloop.rst:1695
msgid ":ref:`Availability <availability>`: Unix, Windows."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1700
msgid "An event loop for Windows that uses \"I/O Completion Ports\" (IOCP)."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1702
msgid ":ref:`Availability <availability>`: Windows."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1706
msgid ""
"`MSDN documentation on I/O Completion Ports <https://docs.microsoft.com/en-"
"ca/windows/desktop/FileIO/i-o-completion-ports>`_."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1712
msgid "Abstract base class for asyncio-compliant event loops."
msgstr "Abstrakt basklass för asynciokompatibla händelseslingor."

#: ../../library/asyncio-eventloop.rst:1714
msgid ""
"The :ref:`asyncio-event-loop-methods` section lists all methods that an "
"alternative implementation of ``AbstractEventLoop`` should have defined."
msgstr ""
"Avsnittet :ref:`asyncio-event-loop-methods` listar alla metoder som en "
"alternativ implementation av ``AbstractEventLoop`` borde ha definierat."

#: ../../library/asyncio-eventloop.rst:1720
msgid "Examples"
msgstr "Exempel"

#: ../../library/asyncio-eventloop.rst:1722
msgid ""
"Note that all examples in this section **purposefully** show how to use the "
"low-level event loop APIs, such as :meth:`loop.run_forever` and "
":meth:`loop.call_soon`.  Modern asyncio applications rarely need to be "
"written this way; consider using the high-level functions like "
":func:`asyncio.run`."
msgstr ""
"Observera att alla exempel i detta avsnitt **avsiktligt** visar hur man "
"använder lågnivå-API:er för händelseslingor, som :meth:`loop.run_forever` "
"och :meth:`loop.call_soon`.  Moderna asyncio-applikationer behöver sällan "
"skrivas på det här sättet; överväg att använda högnivåfunktioner som "
":func:`asyncio.run`."

#: ../../library/asyncio-eventloop.rst:1732
msgid "Hello World with call_soon()"
msgstr "Hello World med call_soon()"

#: ../../library/asyncio-eventloop.rst:1734
msgid ""
"An example using the :meth:`loop.call_soon` method to schedule a callback. "
"The callback displays ``\"Hello World\"`` and then stops the event loop::"
msgstr ""
"Ett exempel där metoden :meth:`loop.call_soon` används för att schemalägga "
"en återuppringning. Återkallelsen visar ``\"Hello World\"`` och stoppar "
"sedan händelseslingan::"

#: ../../library/asyncio-eventloop.rst:1758
msgid ""
"A similar :ref:`Hello World <coroutine>` example created with a coroutine "
"and the :func:`run` function."
msgstr ""
"Ett liknande :ref:`Hello World <coroutine>` exempel skapat med en coroutine "
"och funktionen :func:`run`."

#: ../../library/asyncio-eventloop.rst:1765
msgid "Display the current date with call_later()"
msgstr "Visa aktuellt datum med call_later()"

#: ../../library/asyncio-eventloop.rst:1767
msgid ""
"An example of a callback displaying the current date every second. The "
"callback uses the :meth:`loop.call_later` method to reschedule itself after "
"5 seconds, and then stops the event loop::"
msgstr ""
"Ett exempel på en callback som visar aktuellt datum varje sekund. "
"Återuppringningen använder metoden :meth:`loop.call_later` för att "
"schemalägga om sig själv efter 5 sekunder, och stoppar sedan "
"händelseslingan::"

#: ../../library/asyncio-eventloop.rst:1795
msgid ""
"A similar :ref:`current date <asyncio_example_sleep>` example created with a"
" coroutine and the :func:`run` function."
msgstr ""
"Ett liknande :ref:`aktuellt datum <asyncio_example_sleep>` exempel skapat "
"med en coroutine och funktionen :func:`run`."

#: ../../library/asyncio-eventloop.rst:1802
msgid "Watch a file descriptor for read events"
msgstr "Bevaka en filbeskrivare för läshändelser"

#: ../../library/asyncio-eventloop.rst:1804
msgid ""
"Wait until a file descriptor received some data using the "
":meth:`loop.add_reader` method and then close the event loop::"
msgstr ""
"Vänta tills en filbeskrivningsenhet har tagit emot data med hjälp av metoden"
" :meth:`loop.add_reader` och stäng sedan händelseslingan::"

#: ../../library/asyncio-eventloop.rst:1842
msgid ""
"A similar :ref:`example <asyncio_example_create_connection>` using "
"transports, protocols, and the :meth:`loop.create_connection` method."
msgstr ""
"En liknande :ref:`example <asyncio_example_create_connection>` med "
"transporter, protokoll och metoden :meth:`loop.create_connection`."

#: ../../library/asyncio-eventloop.rst:1846
msgid ""
"Another similar :ref:`example <asyncio_example_create_connection-streams>` "
"using the high-level :func:`asyncio.open_connection` function and streams."
msgstr ""
"En annan liknande :ref:`exempel <asyncio_example_create_connection-streams>`"
" som använder högnivåfunktionen :func:`asyncio.open_connection` och streams."

#: ../../library/asyncio-eventloop.rst:1854
msgid "Set signal handlers for SIGINT and SIGTERM"
msgstr "Ange signalhanterare för SIGINT och SIGTERM"

#: ../../library/asyncio-eventloop.rst:1856
msgid "(This ``signals`` example only works on Unix.)"
msgstr "(Detta ``signals``\\-exempel fungerar bara på Unix.)"

#: ../../library/asyncio-eventloop.rst:1858
msgid ""
"Register handlers for signals :const:`~signal.SIGINT` and "
":const:`~signal.SIGTERM` using the :meth:`loop.add_signal_handler` method::"
msgstr ""
"Registrera hanterare för signalerna :const:`~signal.SIGINT` och "
":const:`~signal.SIGTERM` med hjälp av metoden "
":meth:`loop.add_signal_handler`::"
