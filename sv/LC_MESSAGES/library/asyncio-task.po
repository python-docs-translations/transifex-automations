# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2026, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-07 16:01+0000\n"
"PO-Revision-Date: 2025-09-22 16:49+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../library/asyncio-task.rst:6
msgid "Coroutines and Tasks"
msgstr "Coroutines och Tasks"

#: ../../library/asyncio-task.rst:8
msgid ""
"This section outlines high-level asyncio APIs to work with coroutines and "
"Tasks."
msgstr ""
"Detta avsnitt beskriver asyncio-API:er på hög nivå för att arbeta med "
"coroutines och Tasks."

#: ../../library/asyncio-task.rst:19 ../../library/asyncio-task.rst:148
msgid "Coroutines"
msgstr "Coroutines"

#: ../../library/asyncio-task.rst:21
msgid "**Source code:** :source:`Lib/asyncio/coroutines.py`"
msgstr "**Källkod:** :source:`Lib/asyncio/coroutines.py`"

#: ../../library/asyncio-task.rst:25
msgid ""
":term:`Coroutines <coroutine>` declared with the async/await syntax is the "
"preferred way of writing asyncio applications.  For example, the following "
"snippet of code prints \"hello\", waits 1 second, and then prints \"world\"::"
msgstr ""
":term:`Coroutines <coroutine>` deklarerade med async/await-syntaxen är det "
"föredragna sättet att skriva asyncio-applikationer.  Följande kodavsnitt "
"skriver till exempel ut \"hello\", väntar 1 sekund och skriver sedan ut "
"\"world\"::"

#: ../../library/asyncio-task.rst:41
msgid ""
"Note that simply calling a coroutine will not schedule it to be executed::"
msgstr ""
"Observera att det inte räcker med att anropa en coroutine för att den ska "
"exekveras::"

#: ../../library/asyncio-task.rst:47
msgid "To actually run a coroutine, asyncio provides the following mechanisms:"
msgstr ""
"För att faktiskt köra en coroutine tillhandahåller asyncio följande "
"mekanismer:"

#: ../../library/asyncio-task.rst:49
msgid ""
"The :func:`asyncio.run` function to run the top-level entry point \"main()\" "
"function (see the above example.)"
msgstr ""
"Funktionen :func:`asyncio.run` för att köra funktionen \"main()\" på den "
"högsta nivån (se exemplet ovan)"

#: ../../library/asyncio-task.rst:52
msgid ""
"Awaiting on a coroutine.  The following snippet of code will print \"hello\" "
"after waiting for 1 second, and then print \"world\" after waiting for "
"*another* 2 seconds::"
msgstr ""
"Väntar på en coroutine.  Följande kodavsnitt kommer att skriva ut \"hello\" "
"efter att ha väntat i 1 sekund, och sedan skriva ut \"world\" efter att ha "
"väntat i *ytterligare* 2 sekunder::"

#: ../../library/asyncio-task.rst:73
msgid "Expected output::"
msgstr "Förväntad utgång::"

#: ../../library/asyncio-task.rst:80
msgid ""
"The :func:`asyncio.create_task` function to run coroutines concurrently as "
"asyncio :class:`Tasks <Task>`."
msgstr ""
"Funktionen :func:`asyncio.create_task` för att köra coroutines samtidigt som "
"asyncio :class:`Tasks <Task>`."

#: ../../library/asyncio-task.rst:83
msgid ""
"Let's modify the above example and run two ``say_after`` coroutines "
"*concurrently*::"
msgstr ""
"Låt oss modifiera exemplet ovan och köra två ``say_after`` coroutines "
"*samtidigt*::"

#: ../../library/asyncio-task.rst:102
msgid ""
"Note that expected output now shows that the snippet runs 1 second faster "
"than before::"
msgstr ""
"Observera att den förväntade utdata nu visar att utdraget körs 1 sekund "
"snabbare än tidigare::"

#: ../../library/asyncio-task.rst:110
msgid ""
"The :class:`asyncio.TaskGroup` class provides a more modern alternative to :"
"func:`create_task`. Using this API, the last example becomes::"
msgstr ""
"Klassen :class:`asyncio.TaskGroup` ger ett mer modernt alternativ till :func:"
"`create_task`. Med hjälp av detta API blir det sista exemplet::"

#: ../../library/asyncio-task.rst:128
msgid "The timing and output should be the same as for the previous version."
msgstr ""
"Tidpunkten och resultatet ska vara detsamma som för den tidigare versionen."

#: ../../library/asyncio-task.rst:130
msgid ":class:`asyncio.TaskGroup`."
msgstr ":class:`asyncio.TaskGroup`."

#: ../../library/asyncio-task.rst:137
msgid "Awaitables"
msgstr "Förväntansfulla"

#: ../../library/asyncio-task.rst:139
msgid ""
"We say that an object is an **awaitable** object if it can be used in an :"
"keyword:`await` expression.  Many asyncio APIs are designed to accept "
"awaitables."
msgstr ""
"Vi säger att ett objekt är ett **awaitable**-objekt om det kan användas i "
"ett :keyword:`await`\\-uttryck.  Många asyncio API:er är utformade för att "
"acceptera awaitables."

#: ../../library/asyncio-task.rst:143
msgid ""
"There are three main types of *awaitable* objects: **coroutines**, "
"**Tasks**, and **Futures**."
msgstr ""
"Det finns tre huvudtyper av *awaitable*-objekt: **Koroutiner**, "
"**Uppgifter** och **Futures**."

#: ../../library/asyncio-task.rst:149
msgid ""
"Python coroutines are *awaitables* and therefore can be awaited from other "
"coroutines::"
msgstr ""
"Python coroutines är *awaitables* och kan därför väntas från andra "
"coroutines::"

#: ../../library/asyncio-task.rst:170
msgid ""
"In this documentation the term \"coroutine\" can be used for two closely "
"related concepts:"
msgstr ""
"I den här dokumentationen kan termen \"coroutine\" användas för två "
"närbesläktade begrepp:"

#: ../../library/asyncio-task.rst:173
msgid "a *coroutine function*: an :keyword:`async def` function;"
msgstr "en *coroutine-funktion*: en :keyword:`async def`\\-funktion;"

#: ../../library/asyncio-task.rst:175
msgid ""
"a *coroutine object*: an object returned by calling a *coroutine function*."
msgstr ""
"ett *koroutinobjekt*: ett objekt som returneras genom anrop av en "
"*koroutinfunktion*."

#: ../../library/asyncio-task.rst:180
msgid "Tasks"
msgstr "Uppgifter"

#: ../../library/asyncio-task.rst:181
msgid "*Tasks* are used to schedule coroutines *concurrently*."
msgstr "*Tasks* används för att schemalägga coroutines *samtidigt*."

#: ../../library/asyncio-task.rst:183
msgid ""
"When a coroutine is wrapped into a *Task* with functions like :func:`asyncio."
"create_task` the coroutine is automatically scheduled to run soon::"
msgstr ""
"När en coroutine paketeras in i en *Task* med funktioner som :func:`asyncio."
"create_task` schemaläggs coroutinen automatiskt för att köras snart::"

#: ../../library/asyncio-task.rst:205
msgid "Futures"
msgstr "Terminskontrakt"

#: ../../library/asyncio-task.rst:206
msgid ""
"A :class:`Future` is a special **low-level** awaitable object that "
"represents an **eventual result** of an asynchronous operation."
msgstr ""
"En :class:`Future` är ett speciellt **lågnivå** väntande objekt som "
"representerar ett **eventuellt resultat** av en asynkron operation."

#: ../../library/asyncio-task.rst:209
msgid ""
"When a Future object is *awaited* it means that the coroutine will wait "
"until the Future is resolved in some other place."
msgstr ""
"När ett Future-objekt är *awaited* betyder det att coroutinen kommer att "
"vänta tills Future-objektet har lösts upp på något annat ställe."

#: ../../library/asyncio-task.rst:212
msgid ""
"Future objects in asyncio are needed to allow callback-based code to be used "
"with async/await."
msgstr ""
"Framtida objekt i asyncio behövs för att göra det möjligt att använda "
"callback-baserad kod med async/await."

#: ../../library/asyncio-task.rst:215
msgid ""
"Normally **there is no need** to create Future objects at the application "
"level code."
msgstr ""
"Normalt **finns det inget behov** av att skapa Future-objekt på "
"applikationsnivå."

#: ../../library/asyncio-task.rst:218
msgid ""
"Future objects, sometimes exposed by libraries and some asyncio APIs, can be "
"awaited::"
msgstr ""
"Framtida objekt, som ibland exponeras av bibliotek och vissa asyncio API:er, "
"kan inväntas::"

#: ../../library/asyncio-task.rst:230
msgid ""
"A good example of a low-level function that returns a Future object is :meth:"
"`loop.run_in_executor`."
msgstr ""
"Ett bra exempel på en lågnivåfunktion som returnerar ett Future-objekt är :"
"meth:`loop.run_in_executor`."

#: ../../library/asyncio-task.rst:235
msgid "Creating Tasks"
msgstr "Skapa uppgifter"

#: ../../library/asyncio-task.rst:237
msgid "**Source code:** :source:`Lib/asyncio/tasks.py`"
msgstr "**Källkod:** :source:`Lib/asyncio/tasks.py`"

#: ../../library/asyncio-task.rst:243
msgid ""
"Wrap the *coro* :ref:`coroutine <coroutine>` into a :class:`Task` and "
"schedule its execution.  Return the Task object."
msgstr ""
"Packa in *coro* :ref:`coroutine <coroutine>` i en :class:`Task` och "
"schemalägg dess exekvering.  Returnera Task-objektet."

#: ../../library/asyncio-task.rst:246
msgid ""
"If *name* is not ``None``, it is set as the name of the task using :meth:"
"`Task.set_name`."
msgstr ""

#: ../../library/asyncio-task.rst:249
msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the *coro* to run in. The current context "
"copy is created when no *context* is provided."
msgstr ""
"Ett valfritt argument *context* med endast nyckelord gör det möjligt att "
"ange en anpassad :class:`contextvars.Context` som *coro* ska köras i. Den "
"aktuella kontextkopian skapas när ingen *kontext* anges."

#: ../../library/asyncio-task.rst:253
msgid ""
"The task is executed in the loop returned by :func:`get_running_loop`, :exc:"
"`RuntimeError` is raised if there is no running loop in current thread."
msgstr ""
"Uppgiften utförs i den loop som returneras av :func:`get_running_loop`, :exc:"
"`RuntimeError` uppstår om det inte finns någon loop i den aktuella tråden."

#: ../../library/asyncio-task.rst:259
msgid ""
":meth:`asyncio.TaskGroup.create_task` is a newer alternative that allows for "
"convenient waiting for a group of related tasks."
msgstr ""

#: ../../library/asyncio-task.rst:264
msgid ""
"Save a reference to the result of this function, to avoid a task "
"disappearing mid-execution. The event loop only keeps weak references to "
"tasks. A task that isn't referenced elsewhere may get garbage collected at "
"any time, even before it's done. For reliable \"fire-and-forget\" background "
"tasks, gather them in a collection::"
msgstr ""
"Spara en referens till resultatet av denna funktion för att undvika att en "
"uppgift försvinner mitt under utförandet. Händelseslingan behåller bara "
"svaga referenser till uppgifter. En uppgift som inte refereras någon "
"annanstans kan när som helst bli skräpinsamlad, till och med innan den är "
"klar. För tillförlitliga \"skjut-och-glöm\"-bakgrundsuppgifter, samla dem i "
"en samling::"

#: ../../library/asyncio-task.rst:286 ../../library/asyncio-task.rst:1012
msgid "Added the *name* parameter."
msgstr "Parametern *name* har lagts till."

#: ../../library/asyncio-task.rst:289 ../../library/asyncio-task.rst:1019
msgid "Added the *context* parameter."
msgstr "Parametern *context* har lagts till."

#: ../../library/asyncio-task.rst:294
msgid "Task Cancellation"
msgstr "Avbokning av uppdrag"

#: ../../library/asyncio-task.rst:296
msgid ""
"Tasks can easily and safely be cancelled. When a task is cancelled, :exc:"
"`asyncio.CancelledError` will be raised in the task at the next opportunity."
msgstr ""
"Uppgifter kan enkelt och säkert avbrytas. När en uppgift avbryts kommer :exc:"
"`asyncio.CancelledError` att skapas i uppgiften vid nästa tillfälle."

#: ../../library/asyncio-task.rst:300
msgid ""
"It is recommended that coroutines use ``try/finally`` blocks to robustly "
"perform clean-up logic. In case :exc:`asyncio.CancelledError` is explicitly "
"caught, it should generally be propagated when clean-up is complete. :exc:"
"`asyncio.CancelledError` directly subclasses :exc:`BaseException` so most "
"code will not need to be aware of it."
msgstr ""
"Det rekommenderas att coroutines använder ``try/finally`` block för att "
"robust utföra rensningslogik. Om :exc:`asyncio.CancelledError` fångas "
"explicit, bör det i allmänhet spridas när upprensningen är klar. :exc:"
"`asyncio.CancelledError` underklassar direkt :exc:`BaseException` så den "
"mesta koden behöver inte vara medveten om det."

#: ../../library/asyncio-task.rst:306
msgid ""
"The asyncio components that enable structured concurrency, like :class:"
"`asyncio.TaskGroup` and :func:`asyncio.timeout`, are implemented using "
"cancellation internally and might misbehave if a coroutine swallows :exc:"
"`asyncio.CancelledError`. Similarly, user code should not generally call :"
"meth:`uncancel <asyncio.Task.uncancel>`. However, in cases when suppressing :"
"exc:`asyncio.CancelledError` is truly desired, it is necessary to also call "
"``uncancel()`` to completely remove the cancellation state."
msgstr ""
"De asynciokomponenter som möjliggör strukturerad samtidighet, som :class:"
"`asyncio.TaskGroup` och :func:`asyncio.timeout`, implementeras med hjälp av "
"annullering internt och kan bete sig illa om en coroutine sväljer :exc:"
"`asyncio.CancelledError`. På samma sätt bör användarkod i allmänhet inte "
"anropa :meth:`uncancel <asyncio.Task.uncancel>`. Men i de fall då det "
"verkligen är önskvärt att undertrycka :exc:`asyncio.CancelledError`, är det "
"nödvändigt att också anropa ``uncancel()`` för att helt ta bort "
"annulleringstillståndet."

#: ../../library/asyncio-task.rst:318
msgid "Task Groups"
msgstr "Arbetsgrupper"

#: ../../library/asyncio-task.rst:320
msgid ""
"Task groups combine a task creation API with a convenient and reliable way "
"to wait for all tasks in the group to finish."
msgstr ""
"Uppgiftsgrupper kombinerar ett API för skapande av uppgifter med ett bekvämt "
"och tillförlitligt sätt att vänta på att alla uppgifter i gruppen ska bli "
"klara."

#: ../../library/asyncio-task.rst:325
msgid ""
"An :ref:`asynchronous context manager <async-context-managers>` holding a "
"group of tasks. Tasks can be added to the group using :meth:`create_task`. "
"All tasks are awaited when the context manager exits."
msgstr ""
"En :ref:`asynchronous context manager <async-context-managers>` som "
"innehåller en grupp av uppgifter. Uppgifter kan läggas till i gruppen med :"
"meth:`create_task`. Alla uppgifter är väntade när kontexthanteraren avslutas."

#: ../../library/asyncio-task.rst:334
msgid ""
"Create a task in this task group. The signature matches that of :func:"
"`asyncio.create_task`."
msgstr ""

#: ../../library/asyncio-task.rst:337 ../../library/asyncio-task.rst:467
#: ../../library/asyncio-task.rst:595 ../../library/asyncio-task.rst:653
#: ../../library/asyncio-task.rst:679 ../../library/asyncio-task.rst:719
#: ../../library/asyncio-task.rst:815
msgid "Example::"
msgstr "Exempel::"

#: ../../library/asyncio-task.rst:345
msgid ""
"The ``async with`` statement will wait for all tasks in the group to finish. "
"While waiting, new tasks may still be added to the group (for example, by "
"passing ``tg`` into one of the coroutines and calling ``tg.create_task()`` "
"in that coroutine). Once the last task has finished and the ``async with`` "
"block is exited, no new tasks may be added to the group."
msgstr ""
"Satsen ``async with`` väntar på att alla uppgifter i gruppen ska bli klara. "
"Under väntetiden kan nya uppgifter fortfarande läggas till i gruppen (till "
"exempel genom att skicka ``tg`` till en av coroutinerna och anropa ``tg."
"create_task()`` i den coroutinen). När den sista uppgiften har slutförts och "
"``async with``\\-blocket har avslutats, kan inga nya uppgifter läggas till i "
"gruppen."

#: ../../library/asyncio-task.rst:352
msgid ""
"The first time any of the tasks belonging to the group fails with an "
"exception other than :exc:`asyncio.CancelledError`, the remaining tasks in "
"the group are cancelled. No further tasks can then be added to the group. At "
"this point, if the body of the ``async with`` statement is still active (i."
"e., :meth:`~object.__aexit__` hasn't been called yet), the task directly "
"containing the ``async with`` statement is also cancelled. The resulting :"
"exc:`asyncio.CancelledError` will interrupt an ``await``, but it will not "
"bubble out of the containing ``async with`` statement."
msgstr ""
"Första gången någon av uppgifterna i gruppen misslyckas med ett annat "
"undantag än :exc:`asyncio.CancelledError`, avbryts de återstående "
"uppgifterna i gruppen. Inga ytterligare uppgifter kan då läggas till i "
"gruppen. Om kroppen av ``async with`` -satsen fortfarande är aktiv (dvs. :"
"meth:`~object.__aexit__` har ännu inte anropats) avbryts även den uppgift "
"som direkt innehåller ``async with`` -satsen. Det resulterande :exc:`asyncio."
"CancelledError` avbryter ett ``await``, men det sprider sig inte utanför det "
"omgivande ``async with`` -uttrycket."

#: ../../library/asyncio-task.rst:362
msgid ""
"Once all tasks have finished, if any tasks have failed with an exception "
"other than :exc:`asyncio.CancelledError`, those exceptions are combined in "
"an :exc:`ExceptionGroup` or :exc:`BaseExceptionGroup` (as appropriate; see "
"their documentation) which is then raised."
msgstr ""
"När alla uppgifter har slutförts, om några uppgifter har misslyckats med ett "
"annat undantag än :exc:`asyncio.CancelledError`, kombineras dessa undantag i "
"en :exc:`ExceptionGroup` eller :exc:`BaseExceptionGroup` (beroende på vad "
"som är lämpligt; se deras dokumentation) som sedan tas upp."

#: ../../library/asyncio-task.rst:369
msgid ""
"Two base exceptions are treated specially: If any task fails with :exc:"
"`KeyboardInterrupt` or :exc:`SystemExit`, the task group still cancels the "
"remaining tasks and waits for them, but then the initial :exc:"
"`KeyboardInterrupt` or :exc:`SystemExit` is re-raised instead of :exc:"
"`ExceptionGroup` or :exc:`BaseExceptionGroup`."
msgstr ""
"Två basundantag behandlas speciellt: Om någon uppgift misslyckas med :exc:"
"`KeyboardInterrupt` eller :exc:`SystemExit`, avbryter uppgiftsgruppen "
"fortfarande de återstående uppgifterna och väntar på dem, men då återkallas "
"den ursprungliga :exc:`KeyboardInterrupt` eller :exc:`SystemExit` istället "
"för :exc:`ExceptionGroup` eller :exc:`BaseExceptionGroup`."

#: ../../library/asyncio-task.rst:375
msgid ""
"If the body of the ``async with`` statement exits with an exception (so :"
"meth:`~object.__aexit__` is called with an exception set), this is treated "
"the same as if one of the tasks failed: the remaining tasks are cancelled "
"and then waited for, and non-cancellation exceptions are grouped into an "
"exception group and raised. The exception passed into :meth:`~object."
"__aexit__`, unless it is :exc:`asyncio.CancelledError`, is also included in "
"the exception group. The same special case is made for :exc:"
"`KeyboardInterrupt` and :exc:`SystemExit` as in the previous paragraph."
msgstr ""
"Om ``async with``\\-satsens kropp avslutas med ett undantag (så att :meth:"
"`~object.__aexit__` anropas med en undantagsuppsättning), behandlas detta på "
"samma sätt som om en av uppgifterna misslyckades: de återstående uppgifterna "
"avbryts och väntar sedan, och undantag som inte avbryts grupperas i en "
"undantagsgrupp och tas upp. Undantaget som skickas in i :meth:`~object."
"__aexit__`, om det inte är :exc:`asyncio.CancelledError`, ingår också i "
"undantagsgruppen. Samma specialfall görs för :exc:`KeyboardInterrupt` och :"
"exc:`SystemExit` som i föregående stycke."

#: ../../library/asyncio-task.rst:389
msgid "Sleeping"
msgstr "Sovande"

#: ../../library/asyncio-task.rst:393
msgid "Block for *delay* seconds."
msgstr "Blockera i *fördröjning* sekunder."

#: ../../library/asyncio-task.rst:395
msgid ""
"If *result* is provided, it is returned to the caller when the coroutine "
"completes."
msgstr ""
"Om *result* anges returneras det till den som anropar när coroutinen "
"avslutas."

#: ../../library/asyncio-task.rst:398
msgid ""
"``sleep()`` always suspends the current task, allowing other tasks to run."
msgstr ""
"``sleep()`` avbryter alltid den aktuella uppgiften, så att andra uppgifter "
"kan köras."

#: ../../library/asyncio-task.rst:401
msgid ""
"Setting the delay to 0 provides an optimized path to allow other tasks to "
"run. This can be used by long-running functions to avoid blocking the event "
"loop for the full duration of the function call."
msgstr ""
"Om du ställer in fördröjningen till 0 får du en optimerad väg så att andra "
"uppgifter kan köras. Detta kan användas av funktioner som körs under lång "
"tid för att undvika att blockera händelseslingan under hela funktionsanropet."

#: ../../library/asyncio-task.rst:407
msgid ""
"Example of coroutine displaying the current date every second for 5 seconds::"
msgstr ""
"Exempel på coroutine som visar aktuellt datum varannan sekund i 5 sekunder::"

#: ../../library/asyncio-task.rst:425 ../../library/asyncio-task.rst:516
#: ../../library/asyncio-task.rst:570 ../../library/asyncio-task.rst:744
#: ../../library/asyncio-task.rst:798 ../../library/asyncio-task.rst:821
msgid "Removed the *loop* parameter."
msgstr "Parametern *loop* har tagits bort."

#: ../../library/asyncio-task.rst:430
msgid "Running Tasks Concurrently"
msgstr "Köra uppgifter samtidigt"

#: ../../library/asyncio-task.rst:434
msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* sequence "
"*concurrently*."
msgstr ""
"Kör :ref:`awaitable objects <asyncio-awaitables>` i *aws*-sekvensen "
"*samtidigt*."

#: ../../library/asyncio-task.rst:437
msgid ""
"If any awaitable in *aws* is a coroutine, it is automatically scheduled as a "
"Task."
msgstr ""
"Om någon awaitable i *aws* är en coroutine schemaläggs den automatiskt som "
"en Task."

#: ../../library/asyncio-task.rst:440
msgid ""
"If all awaitables are completed successfully, the result is an aggregate "
"list of returned values.  The order of result values corresponds to the "
"order of awaitables in *aws*."
msgstr ""
"Om alla awaitables har slutförts framgångsrikt är resultatet en aggregerad "
"lista över returnerade värden.  Ordningen på resultatvärdena motsvarar "
"ordningen på awaitables i *aws*."

#: ../../library/asyncio-task.rst:444
msgid ""
"If *return_exceptions* is ``False`` (default), the first raised exception is "
"immediately propagated to the task that awaits on ``gather()``.  Other "
"awaitables in the *aws* sequence **won't be cancelled** and will continue to "
"run."
msgstr ""
"Om *return_exceptions* är ``False`` (standard), kommer det första undantaget "
"som uppstår omedelbart att överföras till den uppgift som väntar på "
"``gather()``.  Andra awaitables i *aws*-sekvensen **avbryts inte** och "
"fortsätter att köras."

#: ../../library/asyncio-task.rst:449
msgid ""
"If *return_exceptions* is ``True``, exceptions are treated the same as "
"successful results, and aggregated in the result list."
msgstr ""
"Om *return_exceptions* är ``True``, behandlas undantag på samma sätt som "
"lyckade resultat och sammanställs i resultatlistan."

#: ../../library/asyncio-task.rst:452
msgid ""
"If ``gather()`` is *cancelled*, all submitted awaitables (that have not "
"completed yet) are also *cancelled*."
msgstr ""
"Om ``gather()`` är *avbruten*, är alla inskickade awaitables (som inte har "
"slutförts ännu) också *avbrutna*."

#: ../../library/asyncio-task.rst:455
msgid ""
"If any Task or Future from the *aws* sequence is *cancelled*, it is treated "
"as if it raised :exc:`CancelledError` -- the ``gather()`` call is **not** "
"cancelled in this case.  This is to prevent the cancellation of one "
"submitted Task/Future to cause other Tasks/Futures to be cancelled."
msgstr ""
"Om någon uppgift eller framtid från *aws*-sekvensen *annulleras*, behandlas "
"den som om den gav upphov till :exc:`CancelledError` -- anropet ``gather()`` "
"annulleras **inte** i detta fall.  Detta för att förhindra att avbrytandet "
"av en inskickad Task/Future orsakar avbrytande av andra Tasks/Futures."

#: ../../library/asyncio-task.rst:462
msgid ""
"A more modern way to create and run tasks concurrently and wait for their "
"completion is :class:`asyncio.TaskGroup`."
msgstr ""

#: ../../library/asyncio-task.rst:505
msgid ""
"If *return_exceptions* is False, cancelling gather() after it has been "
"marked done won't cancel any submitted awaitables. For instance, gather can "
"be marked done after propagating an exception to the caller, therefore, "
"calling ``gather.cancel()`` after catching an exception (raised by one of "
"the awaitables) from gather won't cancel any other awaitables."
msgstr ""

#: ../../library/asyncio-task.rst:512
msgid ""
"If the *gather* itself is cancelled, the cancellation is propagated "
"regardless of *return_exceptions*."
msgstr ""
"Om *gather* själv avbryts, sprids avbrottet oavsett *return_exceptions*."

#: ../../library/asyncio-task.rst:519
msgid ""
"Deprecation warning is emitted if no positional arguments are provided or "
"not all positional arguments are Future-like objects and there is no running "
"event loop."
msgstr ""
"Deprecation-varning utfärdas om inga positionella argument anges eller om "
"inte alla positionella argument är Future-liknande objekt och det inte finns "
"någon pågående händelseslinga."

#: ../../library/asyncio-task.rst:526
msgid "Shielding From Cancellation"
msgstr "Avskärmning från annullering"

#: ../../library/asyncio-task.rst:530
msgid ""
"Protect an :ref:`awaitable object <asyncio-awaitables>` from being :meth:"
"`cancelled <Task.cancel>`."
msgstr ""
"Skydda ett :ref:`awaitable object <asyncio-awaitables>` från att bli :meth:"
"`cancelled <Task.cancel>`."

#: ../../library/asyncio-task.rst:533 ../../library/asyncio-task.rst:699
msgid "If *aw* is a coroutine it is automatically scheduled as a Task."
msgstr "Om *aw* är en coroutine schemaläggs den automatiskt som en Task."

#: ../../library/asyncio-task.rst:535
msgid "The statement::"
msgstr "Uttalandet::"

#: ../../library/asyncio-task.rst:540
msgid "is equivalent to::"
msgstr "är likvärdig med::"

#: ../../library/asyncio-task.rst:544
msgid ""
"*except* that if the coroutine containing it is cancelled, the Task running "
"in ``something()`` is not cancelled.  From the point of view of "
"``something()``, the cancellation did not happen. Although its caller is "
"still cancelled, so the \"await\" expression still raises a :exc:"
"`CancelledError`."
msgstr ""
"*utom* att om coroutinen som innehåller den avbryts, avbryts inte den Task "
"som körs i ``något()``.  Ur ``något()`` synvinkel skedde inte avbrytandet. "
"Även om dess anropare fortfarande avbryts, så ger \"await\"-uttrycket "
"fortfarande upphov till ett :exc:`CancelledError`."

#: ../../library/asyncio-task.rst:550
msgid ""
"If ``something()`` is cancelled by other means (i.e. from within itself) "
"that would also cancel ``shield()``."
msgstr ""
"Om ``något()`` upphävs på annat sätt (dvs. inifrån sig själv) skulle det "
"också upphäva ``sköld()``."

#: ../../library/asyncio-task.rst:553
msgid ""
"If it is desired to completely ignore cancellation (not recommended) the "
"``shield()`` function should be combined with a try/except clause, as "
"follows::"
msgstr ""
"Om man vill ignorera annulleringen helt (rekommenderas inte) bör funktionen "
"``shield()`` kombineras med en try/except-sats enligt följande::"

#: ../../library/asyncio-task.rst:565
msgid ""
"Save a reference to tasks passed to this function, to avoid a task "
"disappearing mid-execution. The event loop only keeps weak references to "
"tasks. A task that isn't referenced elsewhere may get garbage collected at "
"any time, even before it's done."
msgstr ""
"Spara en referens till uppgifter som skickas till denna funktion, för att "
"undvika att en uppgift försvinner mitt under utförandet. Händelseslingan "
"behåller bara svaga referenser till uppgifter. En uppgift som inte refereras "
"någon annanstans kan när som helst bli skräpinsamlad, även innan den är klar."

#: ../../library/asyncio-task.rst:573
msgid ""
"Deprecation warning is emitted if *aw* is not Future-like object and there "
"is no running event loop."
msgstr ""
"Deprecation-varning utfärdas om *aw* inte är ett Future-like-objekt och det "
"inte finns någon pågående händelseslinga."

#: ../../library/asyncio-task.rst:579
msgid "Timeouts"
msgstr "Tidsfrister"

#: ../../library/asyncio-task.rst:583
msgid ""
"Return an :ref:`asynchronous context manager <async-context-managers>` that "
"can be used to limit the amount of time spent waiting on something."
msgstr ""
"Returnerar en :ref:`asynkron kontexthanterare <async-context-managers>` som "
"kan användas för att begränsa den tid det tar att vänta på något."

#: ../../library/asyncio-task.rst:587
msgid ""
"*delay* can either be ``None``, or a float/int number of seconds to wait. If "
"*delay* is ``None``, no time limit will be applied; this can be useful if "
"the delay is unknown when the context manager is created."
msgstr ""
"*delay* kan antingen vara ``None``, eller ett float/int antal sekunder att "
"vänta. Om *delay* är ``None`` kommer ingen tidsgräns att tillämpas; detta "
"kan vara användbart om fördröjningen är okänd när kontexthanteraren skapas."

#: ../../library/asyncio-task.rst:592
msgid ""
"In either case, the context manager can be rescheduled after creation using :"
"meth:`Timeout.reschedule`."
msgstr ""
"I båda fallen kan kontexthanteraren omplaneras efter skapandet med hjälp av :"
"meth:`Timeout.reschedule`."

#: ../../library/asyncio-task.rst:601
msgid ""
"If ``long_running_task`` takes more than 10 seconds to complete, the context "
"manager will cancel the current task and handle the resulting :exc:`asyncio."
"CancelledError` internally, transforming it into a :exc:`TimeoutError` which "
"can be caught and handled."
msgstr ""
"Om ``long_running_task`` tar mer än 10 sekunder att slutföra kommer "
"kontexthanteraren att avbryta den aktuella uppgiften och hantera det "
"resulterande :exc:`asyncio.CancelledError` internt och omvandla det till "
"ett :exc:`TimeoutError` som kan fångas upp och hanteras."

#: ../../library/asyncio-task.rst:608
msgid ""
"The :func:`asyncio.timeout` context manager is what transforms the :exc:"
"`asyncio.CancelledError` into a :exc:`TimeoutError`, which means the :exc:"
"`TimeoutError` can only be caught *outside* of the context manager."
msgstr ""
"Kontexthanteraren :func:`asyncio.timeout` omvandlar :exc:`asyncio."
"CancelledError` till ett :exc:`TimeoutError`, vilket innebär att :exc:"
"`TimeoutError` endast kan fångas *utanför* kontexthanteraren."

#: ../../library/asyncio-task.rst:613
msgid "Example of catching :exc:`TimeoutError`::"
msgstr "Exempel på att fånga :exc:`TimeoutError`::"

#: ../../library/asyncio-task.rst:624
msgid ""
"The context manager produced by :func:`asyncio.timeout` can be rescheduled "
"to a different deadline and inspected."
msgstr ""
"Den kontexthanterare som produceras av :func:`asyncio.timeout` kan "
"schemaläggas om till en annan deadline och inspekteras."

#: ../../library/asyncio-task.rst:629
msgid ""
"An :ref:`asynchronous context manager <async-context-managers>` for "
"cancelling overdue coroutines."
msgstr ""
"En :ref:`asynkron kontexthanterare <async-context-managers>` för att avbryta "
"försenade coroutines."

#: ../../library/asyncio-task.rst:632
msgid ""
"``when`` should be an absolute time at which the context should time out, as "
"measured by the event loop's clock:"
msgstr ""
"``when`` ska vara en absolut tidpunkt då kontexten ska ta slut, mätt med "
"händelseslingans klocka:"

#: ../../library/asyncio-task.rst:635
msgid "If ``when`` is ``None``, the timeout will never trigger."
msgstr "Om ``when`` är ``None`` kommer timeouten aldrig att utlösas."

#: ../../library/asyncio-task.rst:636
msgid ""
"If ``when < loop.time()``, the timeout will trigger on the next iteration of "
"the event loop."
msgstr ""
"Om ``when < loop.time()``, kommer timeouten att utlösas vid nästa iteration "
"av händelseslingan."

#: ../../library/asyncio-task.rst:641
msgid ""
"Return the current deadline, or ``None`` if the current deadline is not set."
msgstr ""
"Returnerar den aktuella tidsfristen, eller ``None`` om den aktuella "
"tidsfristen inte har angetts."

#: ../../library/asyncio-task.rst:646
msgid "Reschedule the timeout."
msgstr "Flytta fram timeouten."

#: ../../library/asyncio-task.rst:650
msgid "Return whether the context manager has exceeded its deadline (expired)."
msgstr ""
"Returnerar om kontexthanteraren har överskridit sin tidsfrist (expired)."

#: ../../library/asyncio-task.rst:670
msgid "Timeout context managers can be safely nested."
msgstr "Timeout-kontexthanterare kan säkert nästlas."

#: ../../library/asyncio-task.rst:676
msgid ""
"Similar to :func:`asyncio.timeout`, except *when* is the absolute time to "
"stop waiting, or ``None``."
msgstr ""
"Liknar :func:`asyncio.timeout`, förutom att *when* är den absoluta tiden för "
"att sluta vänta, eller ``None``."

#: ../../library/asyncio-task.rst:696
msgid ""
"Wait for the *aw* :ref:`awaitable <asyncio-awaitables>` to complete with a "
"timeout."
msgstr ""
"Vänta på att *aw* :ref:`awaitable <asyncio-awaitables>` ska slutföras med en "
"timeout."

#: ../../library/asyncio-task.rst:701
msgid ""
"*timeout* can either be ``None`` or a float or int number of seconds to wait "
"for.  If *timeout* is ``None``, block until the future completes."
msgstr ""
"*timeout* kan antingen vara ``None`` eller ett float eller int antal "
"sekunder att vänta på.  Om *timeout* är ``None``, blockeras tills framtiden "
"är klar."

#: ../../library/asyncio-task.rst:705
msgid ""
"If a timeout occurs, it cancels the task and raises :exc:`TimeoutError`."
msgstr ""
"Om en timeout inträffar avbryts uppgiften och :exc:`TimeoutError` visas."

#: ../../library/asyncio-task.rst:708
msgid ""
"To avoid the task :meth:`cancellation <Task.cancel>`, wrap it in :func:"
"`shield`."
msgstr ""
"För att undvika uppgiften :meth:`cancellation <Task.cancel>`, linda in den "
"i :func:`shield`."

#: ../../library/asyncio-task.rst:711
msgid ""
"The function will wait until the future is actually cancelled, so the total "
"wait time may exceed the *timeout*. If an exception happens during "
"cancellation, it is propagated."
msgstr ""
"Funktionen kommer att vänta tills framtiden faktiskt avbryts, så den totala "
"väntetiden kan överstiga *timeout*. Om ett undantag inträffar under "
"annulleringen sprids det."

#: ../../library/asyncio-task.rst:715
msgid "If the wait is cancelled, the future *aw* is also cancelled."
msgstr "Om väntan avbryts, avbryts också den framtida *aw*."

#: ../../library/asyncio-task.rst:739
msgid ""
"When *aw* is cancelled due to a timeout, ``wait_for`` waits for *aw* to be "
"cancelled.  Previously, it raised :exc:`TimeoutError` immediately."
msgstr ""
"När *aw* avbryts på grund av en timeout, väntar ``wait_for`` på att *aw* ska "
"avbrytas.  Tidigare gav det upphov till :exc:`TimeoutError` omedelbart."

#: ../../library/asyncio-task.rst:747
msgid "Raises :exc:`TimeoutError` instead of :exc:`asyncio.TimeoutError`."
msgstr "Utlöser :exc:`TimeoutError` istället för :exc:`asyncio.TimeoutError`."

#: ../../library/asyncio-task.rst:752
msgid "Waiting Primitives"
msgstr "Primitiva väntetider"

#: ../../library/asyncio-task.rst:756
msgid ""
"Run :class:`~asyncio.Future` and :class:`~asyncio.Task` instances in the "
"*aws* iterable concurrently and block until the condition specified by "
"*return_when*."
msgstr ""
"Kör :class:`~asyncio.Future` och :class:`~asyncio.Task`\\-instanser i *aws*-"
"iterabeln samtidigt och blockera till det villkor som anges av *return_when*."

#: ../../library/asyncio-task.rst:760
msgid ""
"The *aws* iterable must not be empty and generators yielding tasks are not "
"accepted."
msgstr ""

#: ../../library/asyncio-task.rst:762
msgid "Returns two sets of Tasks/Futures: ``(done, pending)``."
msgstr "Returnerar två uppsättningar av Tasks/Futures: ``(utförd, väntande)``."

#: ../../library/asyncio-task.rst:764
msgid "Usage::"
msgstr "Användning::"

#: ../../library/asyncio-task.rst:768
msgid ""
"*timeout* (a float or int), if specified, can be used to control the maximum "
"number of seconds to wait before returning."
msgstr ""
"*timeout* (en float eller int), om den anges, kan användas för att styra det "
"maximala antalet sekunder som ska väntas innan återgång."

#: ../../library/asyncio-task.rst:771
msgid ""
"Note that this function does not raise :exc:`TimeoutError`. Futures or Tasks "
"that aren't done when the timeout occurs are simply returned in the second "
"set."
msgstr ""
"Observera att denna funktion inte ger upphov till :exc:`TimeoutError`. "
"Futures eller Tasks som inte är klara när timeouten inträffar returneras "
"helt enkelt i den andra uppsättningen."

#: ../../library/asyncio-task.rst:775
msgid ""
"*return_when* indicates when this function should return.  It must be one of "
"the following constants:"
msgstr ""
"*return_when* anger när denna funktion ska returnera.  Den måste vara en av "
"följande konstanter:"

#: ../../library/asyncio-task.rst:781
msgid "Constant"
msgstr "Konstant"

#: ../../library/asyncio-task.rst:782
msgid "Description"
msgstr "Beskrivning"

#: ../../library/asyncio-task.rst:785
msgid "The function will return when any future finishes or is cancelled."
msgstr ""
"Funktionen kommer att återkomma när någon framtid avslutas eller avbryts."

#: ../../library/asyncio-task.rst:788
msgid ""
"The function will return when any future finishes by raising an exception. "
"If no future raises an exception then it is equivalent to :const:"
"`ALL_COMPLETED`."
msgstr ""
"Funktionen återkommer när en framtid avslutas genom att ett undantag "
"utlöses. Om ingen framtid ger upphov till ett undantag så är det likvärdigt "
"med :const:`ALL_COMPLETED`."

#: ../../library/asyncio-task.rst:793
msgid "The function will return when all futures finish or are cancelled."
msgstr "Funktionen återkommer när alla terminer är avslutade eller avbrutna."

#: ../../library/asyncio-task.rst:795
msgid ""
"Unlike :func:`~asyncio.wait_for`, ``wait()`` does not cancel the futures "
"when a timeout occurs."
msgstr ""
"Till skillnad från :func:`~asyncio.wait_for` avbryter inte ``wait()`` "
"futures när en timeout inträffar."

#: ../../library/asyncio-task.rst:801
msgid "Passing coroutine objects to ``wait()`` directly is forbidden."
msgstr "Det är förbjudet att skicka coroutine-objekt direkt till ``wait()``."

#: ../../library/asyncio-task.rst:806
msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* iterable "
"concurrently. Generators yielding tasks are not accepted as *aws* iterable. "
"Return an iterator of coroutines. Each coroutine returned can be awaited to "
"get the earliest next result from the iterable of the remaining awaitables."
msgstr ""

#: ../../library/asyncio-task.rst:812
msgid ""
"Raises :exc:`TimeoutError` if the timeout occurs before all Futures are done."
msgstr ""

#: ../../library/asyncio-task.rst:824
msgid ""
"Deprecation warning is emitted if not all awaitable objects in the *aws* "
"iterable are Future-like objects and there is no running event loop."
msgstr ""
"Deprecation-varning utfärdas om inte alla awaitable-objekt i *aws*-iterabeln "
"är Future-liknande objekt och det inte finns någon pågående händelseslinga."

#: ../../library/asyncio-task.rst:830
msgid "Running in Threads"
msgstr "Löpande i trådar"

#: ../../library/asyncio-task.rst:834
msgid "Asynchronously run function *func* in a separate thread."
msgstr "Asynkron körning av funktionen *func* i en separat tråd."

#: ../../library/asyncio-task.rst:836
msgid ""
"Any \\*args and \\*\\*kwargs supplied for this function are directly passed "
"to *func*. Also, the current :class:`contextvars.Context` is propagated, "
"allowing context variables from the event loop thread to be accessed in the "
"separate thread."
msgstr ""
"Alla \\*args och \\*\\*kwargs som anges för denna funktion skickas direkt "
"till *func*. Dessutom sprids den aktuella :class:`contextvars.Context`, "
"vilket gör att kontextvariabler från händelseslingans tråd kan nås i den "
"separata tråden."

#: ../../library/asyncio-task.rst:841
msgid ""
"Return a coroutine that can be awaited to get the eventual result of *func*."
msgstr ""
"Returnera en coroutine som kan inväntas för att få det slutliga resultatet "
"av *func*."

#: ../../library/asyncio-task.rst:843
msgid ""
"This coroutine function is primarily intended to be used for executing IO-"
"bound functions/methods that would otherwise block the event loop if they "
"were run in the main thread. For example::"
msgstr ""
"Denna coroutine-funktion är främst avsedd att användas för att köra IO-"
"bundna funktioner/metoder som annars skulle blockera händelseslingan om de "
"kördes i huvudtråden. Till exempel::"

#: ../../library/asyncio-task.rst:873
msgid ""
"Directly calling ``blocking_io()`` in any coroutine would block the event "
"loop for its duration, resulting in an additional 1 second of run time. "
"Instead, by using ``asyncio.to_thread()``, we can run it in a separate "
"thread without blocking the event loop."
msgstr ""
"Att direkt anropa ``blocking_io()`` i en coroutine skulle blockera "
"händelseslingan under hela dess varaktighet, vilket resulterar i ytterligare "
"1 sekunds körtid. Genom att istället använda ``asyncio.to_thread()`` kan vi "
"köra den i en separat tråd utan att blockera händelseslingan."

#: ../../library/asyncio-task.rst:880
msgid ""
"Due to the :term:`GIL`, ``asyncio.to_thread()`` can typically only be used "
"to make IO-bound functions non-blocking. However, for extension modules that "
"release the GIL or alternative Python implementations that don't have one, "
"``asyncio.to_thread()`` can also be used for CPU-bound functions."
msgstr ""
"På grund av :term:`GIL` kan ``asyncio.to_thread()`` vanligtvis bara användas "
"för att göra IO-bundna funktioner icke-blockerande. Men för tilläggsmoduler "
"som släpper GIL eller alternativa Python-implementationer som inte har "
"någon, kan ``asyncio.to_thread()`` även användas för CPU-bundna funktioner."

#: ../../library/asyncio-task.rst:889
msgid "Scheduling From Other Threads"
msgstr "Schemaläggning från andra trådar"

#: ../../library/asyncio-task.rst:893
msgid "Submit a coroutine to the given event loop.  Thread-safe."
msgstr "Skicka en coroutine till den angivna händelseslingan.  Tråd-säker."

#: ../../library/asyncio-task.rst:895
msgid ""
"Return a :class:`concurrent.futures.Future` to wait for the result from "
"another OS thread."
msgstr ""
"Returnera en :class:`concurrent.futures.Future` för att vänta på resultatet "
"från en annan OS-tråd."

#: ../../library/asyncio-task.rst:898
msgid ""
"This function is meant to be called from a different OS thread than the one "
"where the event loop is running.  Example::"
msgstr ""
"Denna funktion är avsedd att anropas från en annan OS-tråd än den där "
"händelseslingan körs.  Exempel::"

#: ../../library/asyncio-task.rst:910
msgid ""
"If an exception is raised in the coroutine, the returned Future will be "
"notified.  It can also be used to cancel the task in the event loop::"
msgstr ""
"Om ett undantag inträffar i coroutinen kommer den returnerade Future att "
"meddelas.  Den kan också användas för att avbryta uppgiften i "
"händelseslingan::"

#: ../../library/asyncio-task.rst:924
msgid ""
"See the :ref:`concurrency and multithreading <asyncio-multithreading>` "
"section of the documentation."
msgstr ""
"Se :ref:`concurrency and multithreading <asyncio-multithreading>` i "
"dokumentationen."

#: ../../library/asyncio-task.rst:927
msgid ""
"Unlike other asyncio functions this function requires the *loop* argument to "
"be passed explicitly."
msgstr ""
"Till skillnad från andra asynciofunktioner kräver den här funktionen att "
"argumentet *loop* skickas explicit."

#: ../../library/asyncio-task.rst:934
msgid "Introspection"
msgstr "Introspektion"

#: ../../library/asyncio-task.rst:939
msgid ""
"Return the currently running :class:`Task` instance, or ``None`` if no task "
"is running."
msgstr ""
"Returnerar den instans av :class:`Task` som körs för tillfället, eller "
"``None`` om ingen uppgift körs."

#: ../../library/asyncio-task.rst:942
msgid ""
"If *loop* is ``None`` :func:`get_running_loop` is used to get the current "
"loop."
msgstr ""
"Om *loop* är ``None`` används :func:`get_running_loop` för att hämta den "
"aktuella loopen."

#: ../../library/asyncio-task.rst:950
msgid "Return a set of not yet finished :class:`Task` objects run by the loop."
msgstr ""
"Returnerar en uppsättning ännu inte avslutade :class:`Task`\\-objekt som "
"körs av slingan."

#: ../../library/asyncio-task.rst:953
msgid ""
"If *loop* is ``None``, :func:`get_running_loop` is used for getting current "
"loop."
msgstr ""
"Om *loop* är ``None``, används :func:`get_running_loop` för att hämta "
"aktuell loop."

#: ../../library/asyncio-task.rst:961
msgid "Return ``True`` if *obj* is a coroutine object."
msgstr "Returnerar ``True`` om *obj* är ett coroutine-objekt."

#: ../../library/asyncio-task.rst:967
msgid "Task Object"
msgstr "Uppgiftsobjekt"

#: ../../library/asyncio-task.rst:971
msgid ""
"A :class:`Future-like <Future>` object that runs a Python :ref:`coroutine "
"<coroutine>`.  Not thread-safe."
msgstr ""
"Ett :class:`Future-liknande <Future>`\\-objekt som kör en Python :ref:"
"`coroutine <coroutine>`.  Inte tråd-säkert."

#: ../../library/asyncio-task.rst:974
msgid ""
"Tasks are used to run coroutines in event loops. If a coroutine awaits on a "
"Future, the Task suspends the execution of the coroutine and waits for the "
"completion of the Future.  When the Future is *done*, the execution of the "
"wrapped coroutine resumes."
msgstr ""
"Tasks används för att köra coroutines i händelseslingor. Om en coroutine "
"väntar på en Future, avbryter Task exekveringen av coroutinen och väntar på "
"att Future ska slutföras.  När framtiden är *färdig* återupptas exekveringen "
"av den omslutna coroutinen."

#: ../../library/asyncio-task.rst:980
msgid ""
"Event loops use cooperative scheduling: an event loop runs one Task at a "
"time.  While a Task awaits for the completion of a Future, the event loop "
"runs other Tasks, callbacks, or performs IO operations."
msgstr ""
"Eventloops använder kooperativ schemaläggning: en eventloop kör en Task åt "
"gången.  Medan en Task väntar på att en Future ska slutföras, kör "
"eventloopen andra Tasks, callbacks eller utför IO-operationer."

#: ../../library/asyncio-task.rst:985
msgid ""
"Use the high-level :func:`asyncio.create_task` function to create Tasks, or "
"the low-level :meth:`loop.create_task` or :func:`ensure_future` functions.  "
"Manual instantiation of Tasks is discouraged."
msgstr ""
"Använd högnivåfunktionen :func:`asyncio.create_task` för att skapa Tasks, "
"eller lågnivåfunktionerna :meth:`loop.create_task` eller :func:"
"`ensure_future`.  Manuell instansiering av Tasks avråds."

#: ../../library/asyncio-task.rst:990
msgid ""
"To cancel a running Task use the :meth:`cancel` method.  Calling it will "
"cause the Task to throw a :exc:`CancelledError` exception into the wrapped "
"coroutine.  If a coroutine is awaiting on a Future object during "
"cancellation, the Future object will be cancelled."
msgstr ""
"För att avbryta en pågående Task används metoden :meth:`cancel`.  Om du "
"anropar den kommer uppgiften att kasta ett :exc:`CancelledError` undantag i "
"den omslutna coroutinen.  Om en coroutine väntar på ett Future-objekt under "
"avbrytandet, kommer Future-objektet att avbrytas."

#: ../../library/asyncio-task.rst:995
msgid ""
":meth:`cancelled` can be used to check if the Task was cancelled. The method "
"returns ``True`` if the wrapped coroutine did not suppress the :exc:"
"`CancelledError` exception and was actually cancelled."
msgstr ""
":meth:`cancelled` kan användas för att kontrollera om uppgiften avbröts. "
"Metoden returnerar ``True`` om den inlindade coroutinen inte undertryckte :"
"exc:`CancelledError` undantaget och faktiskt avbröts."

#: ../../library/asyncio-task.rst:1000
msgid ""
":class:`asyncio.Task` inherits from :class:`Future` all of its APIs except :"
"meth:`Future.set_result` and :meth:`Future.set_exception`."
msgstr ""
":class:`asyncio.Task` ärver från :class:`Future` alla dess API:er utom :meth:"
"`Future.set_result` och :meth:`Future.set_exception`."

#: ../../library/asyncio-task.rst:1004
msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the *coro* to run in. If no *context* is "
"provided, the Task copies the current context and later runs its coroutine "
"in the copied context."
msgstr ""
"Ett valfritt argument *context* med endast nyckelord gör det möjligt att "
"ange en anpassad :class:`contextvars.Context` som *coro* ska köras i. Om "
"ingen *kontext* anges kopierar uppgiften den aktuella kontexten och kör "
"senare sin coroutine i den kopierade kontexten."

#: ../../library/asyncio-task.rst:1009
msgid "Added support for the :mod:`contextvars` module."
msgstr "Lagt till stöd för modulen :mod:`contextvars`."

#: ../../library/asyncio-task.rst:1015
msgid ""
"Deprecation warning is emitted if *loop* is not specified and there is no "
"running event loop."
msgstr ""
"Deprecation-varning utfärdas om *loop* inte anges och det inte finns någon "
"pågående händelseslinga."

#: ../../library/asyncio-task.rst:1024
msgid "Return ``True`` if the Task is *done*."
msgstr "Returnerar ``True`` om uppgiften är *done*."

#: ../../library/asyncio-task.rst:1026
msgid ""
"A Task is *done* when the wrapped coroutine either returned a value, raised "
"an exception, or the Task was cancelled."
msgstr ""
"En Task är *färdig* när den omslutna coroutinen antingen returnerade ett "
"värde, utlöste ett undantag eller när Task avbröts."

#: ../../library/asyncio-task.rst:1031
msgid "Return the result of the Task."
msgstr "Returnera resultatet av uppgiften."

#: ../../library/asyncio-task.rst:1033
msgid ""
"If the Task is *done*, the result of the wrapped coroutine is returned (or "
"if the coroutine raised an exception, that exception is re-raised.)"
msgstr ""
"Om uppgiften är *utförd* returneras resultatet av den omslutna coroutinen "
"(eller om coroutinen gav upphov till ett undantag, ges det undantaget upp "
"igen)"

#: ../../library/asyncio-task.rst:1037 ../../library/asyncio-task.rst:1051
msgid ""
"If the Task has been *cancelled*, this method raises a :exc:`CancelledError` "
"exception."
msgstr ""
"Om uppgiften har *avbrutits* ger den här metoden upphov till ett :exc:"
"`CancelledError`\\-undantag."

#: ../../library/asyncio-task.rst:1040
msgid ""
"If the Task's result isn't yet available, this method raises a :exc:"
"`InvalidStateError` exception."
msgstr ""

#: ../../library/asyncio-task.rst:1045
msgid "Return the exception of the Task."
msgstr "Returnera undantaget för uppgiften."

#: ../../library/asyncio-task.rst:1047
msgid ""
"If the wrapped coroutine raised an exception that exception is returned.  If "
"the wrapped coroutine returned normally this method returns ``None``."
msgstr ""
"Om den inkapslade coroutinen gav upphov till ett undantag returneras "
"undantaget.  Om den inkapslade coroutinen returnerades normalt returnerar "
"denna metod ``None``."

#: ../../library/asyncio-task.rst:1054
msgid ""
"If the Task isn't *done* yet, this method raises an :exc:`InvalidStateError` "
"exception."
msgstr ""
"Om uppgiften inte är *färdig* ännu, ger denna metod upphov till ett :exc:"
"`InvalidStateError`\\-undantag."

#: ../../library/asyncio-task.rst:1059
msgid "Add a callback to be run when the Task is *done*."
msgstr "Lägg till en återuppringning som ska köras när uppgiften är *klar*."

#: ../../library/asyncio-task.rst:1061 ../../library/asyncio-task.rst:1070
msgid "This method should only be used in low-level callback-based code."
msgstr ""
"Denna metod bör endast användas i kod som bygger på återuppringning på låg "
"nivå."

#: ../../library/asyncio-task.rst:1063
msgid ""
"See the documentation of :meth:`Future.add_done_callback` for more details."
msgstr ""
"Se dokumentationen av :meth:`Future.add_done_callback` för mer information."

#: ../../library/asyncio-task.rst:1068
msgid "Remove *callback* from the callbacks list."
msgstr "Ta bort *callback* från listan över callbacks."

#: ../../library/asyncio-task.rst:1072
msgid ""
"See the documentation of :meth:`Future.remove_done_callback` for more "
"details."
msgstr ""
"Se dokumentationen av :meth:`Future.remove_done_callback` för mer "
"information."

#: ../../library/asyncio-task.rst:1077
msgid "Return the list of stack frames for this Task."
msgstr "Returnera listan med stapelramar för denna Task."

#: ../../library/asyncio-task.rst:1079
msgid ""
"If the wrapped coroutine is not done, this returns the stack where it is "
"suspended.  If the coroutine has completed successfully or was cancelled, "
"this returns an empty list. If the coroutine was terminated by an exception, "
"this returns the list of traceback frames."
msgstr ""
"Om den inkapslade coroutinen inte är klar returneras den stack där den är "
"avbruten.  Om coroutinen har slutförts framgångsrikt eller avbrutits, "
"returneras en tom lista. Om coroutinen avslutades av ett undantag returneras "
"listan med spårningsramar."

#: ../../library/asyncio-task.rst:1085
msgid "The frames are always ordered from oldest to newest."
msgstr "Ramarna är alltid sorterade från äldst till nyast."

#: ../../library/asyncio-task.rst:1087
msgid "Only one stack frame is returned for a suspended coroutine."
msgstr "Endast en stackram returneras för en avbruten coroutine."

#: ../../library/asyncio-task.rst:1089
msgid ""
"The optional *limit* argument sets the maximum number of frames to return; "
"by default all available frames are returned. The ordering of the returned "
"list differs depending on whether a stack or a traceback is returned: the "
"newest frames of a stack are returned, but the oldest frames of a traceback "
"are returned.  (This matches the behavior of the traceback module.)"
msgstr ""
"Det valfria argumentet *limit* anger det maximala antalet ramar som ska "
"returneras; som standard returneras alla tillgängliga ramar. Ordningen på "
"listan som returneras skiljer sig åt beroende på om en stack eller en "
"traceback returneras: de nyaste ramarna i en stack returneras, men de äldsta "
"ramarna i en traceback returneras.  (Detta motsvarar beteendet hos traceback-"
"modulen)"

#: ../../library/asyncio-task.rst:1098
msgid "Print the stack or traceback for this Task."
msgstr "Skriv ut stacken eller traceback för den här uppgiften."

#: ../../library/asyncio-task.rst:1100
msgid ""
"This produces output similar to that of the traceback module for the frames "
"retrieved by :meth:`get_stack`."
msgstr ""
"Detta ger liknande utdata som traceback-modulen för de ramar som hämtas av :"
"meth:`get_stack`."

#: ../../library/asyncio-task.rst:1103
msgid "The *limit* argument is passed to :meth:`get_stack` directly."
msgstr "Argumentet *limit* skickas direkt till :meth:`get_stack`."

#: ../../library/asyncio-task.rst:1105
msgid ""
"The *file* argument is an I/O stream to which the output is written; by "
"default output is written to :data:`sys.stdout`."
msgstr ""
"Argumentet *file* är en I/O-ström som utdata skrivs till; som standard "
"skrivs utdata till :data:`sys.stdout`."

#: ../../library/asyncio-task.rst:1110
msgid "Return the coroutine object wrapped by the :class:`Task`."
msgstr "Returnerar coroutine-objektet som omsluts av :class:`Task`."

#: ../../library/asyncio-task.rst:1116
msgid "Return the name of the Task."
msgstr "Returnera namnet på uppgiften."

#: ../../library/asyncio-task.rst:1118
msgid ""
"If no name has been explicitly assigned to the Task, the default asyncio "
"Task implementation generates a default name during instantiation."
msgstr ""
"Om inget namn uttryckligen har tilldelats uppgiften genererar "
"standardimplementeringen av asyncio-uppgiften ett standardnamn under "
"instantiering."

#: ../../library/asyncio-task.rst:1126
msgid "Set the name of the Task."
msgstr "Ange namnet på uppgiften."

#: ../../library/asyncio-task.rst:1128
msgid ""
"The *value* argument can be any object, which is then converted to a string."
msgstr ""
"Argumentet *value* kan vara vilket objekt som helst, som sedan konverteras "
"till en sträng."

#: ../../library/asyncio-task.rst:1131
msgid ""
"In the default Task implementation, the name will be visible in the :func:"
"`repr` output of a task object."
msgstr ""
"I standardimplementeringen av Task kommer namnet att synas i :func:`repr`\\-"
"utmatningen från ett Task-objekt."

#: ../../library/asyncio-task.rst:1138
msgid "Request the Task to be cancelled."
msgstr "Begär att uppgiften ska avbrytas."

#: ../../library/asyncio-task.rst:1140
msgid ""
"This arranges for a :exc:`CancelledError` exception to be thrown into the "
"wrapped coroutine on the next cycle of the event loop."
msgstr ""

#: ../../library/asyncio-task.rst:1143
msgid ""
"The coroutine then has a chance to clean up or even deny the request by "
"suppressing the exception with a :keyword:`try` ... ... ``except "
"CancelledError`` ... :keyword:`finally` block. Therefore, unlike :meth:"
"`Future.cancel`, :meth:`Task.cancel` does not guarantee that the Task will "
"be cancelled, although suppressing cancellation completely is not common and "
"is actively discouraged.  Should the coroutine nevertheless decide to "
"suppress the cancellation, it needs to call :meth:`Task.uncancel` in "
"addition to catching the exception."
msgstr ""
"Coroutinen har sedan en chans att städa upp eller till och med neka begäran "
"genom att undertrycka undantaget med ett :keyword:`try` ... ... ... ``except "
"CancelledError`` ... :keyword:`finally` block. Till skillnad från :meth:"
"`Future.cancel` garanterar därför :meth:`Task.cancel` inte att uppgiften "
"kommer att avbrytas, även om det inte är vanligt att helt undertrycka "
"avbrytande och aktivt avråds från detta.  Om coroutinen ändå bestämmer sig "
"för att undertrycka annulleringen måste den anropa :meth:`Task.uncancel` "
"utöver att fånga upp undantaget."

#: ../../library/asyncio-task.rst:1153
msgid "Added the *msg* parameter."
msgstr "Parametern *msg* har lagts till."

#: ../../library/asyncio-task.rst:1156
msgid "The ``msg`` parameter is propagated from cancelled task to its awaiter."
msgstr ""
"Parametern ``msg`` sprids från den avbrutna uppgiften till den som väntar på "
"den."

#: ../../library/asyncio-task.rst:1161
msgid ""
"The following example illustrates how coroutines can intercept the "
"cancellation request::"
msgstr ""
"Följande exempel illustrerar hur coroutines kan fånga upp begäran om "
"annullering::"

#: ../../library/asyncio-task.rst:1200
msgid "Return ``True`` if the Task is *cancelled*."
msgstr "Returnerar ``True`` om uppgiften är *annullerad*."

#: ../../library/asyncio-task.rst:1202
msgid ""
"The Task is *cancelled* when the cancellation was requested with :meth:"
"`cancel` and the wrapped coroutine propagated the :exc:`CancelledError` "
"exception thrown into it."
msgstr ""
"Uppgiften är *avbruten* när avbrytandet begärdes med :meth:`cancel` och den "
"omslutna coroutinen spred undantaget :exc:`CancelledError` som kastades in i "
"den."

#: ../../library/asyncio-task.rst:1208
msgid "Decrement the count of cancellation requests to this Task."
msgstr "Minska antalet avbokningsbegäranden för den här uppgiften."

#: ../../library/asyncio-task.rst:1210
msgid "Returns the remaining number of cancellation requests."
msgstr "Returnerar det återstående antalet avbokningsbegäranden."

#: ../../library/asyncio-task.rst:1212
msgid ""
"Note that once execution of a cancelled task completed, further calls to :"
"meth:`uncancel` are ineffective."
msgstr ""
"Observera att när en avbruten uppgift har utförts är ytterligare anrop till :"
"meth:`uncancel` ineffektiva."

#: ../../library/asyncio-task.rst:1217
msgid ""
"This method is used by asyncio's internals and isn't expected to be used by "
"end-user code.  In particular, if a Task gets successfully uncancelled, this "
"allows for elements of structured concurrency like :ref:`taskgroups` and :"
"func:`asyncio.timeout` to continue running, isolating cancellation to the "
"respective structured block. For example::"
msgstr ""
"Den här metoden används av asyncios interna funktioner och förväntas inte "
"användas av slutanvändarkod.  I synnerhet, om en uppgift framgångsrikt "
"avbokas, gör detta att element av strukturerad samtidighet som :ref:"
"`taskgroups` och :func:`asyncio.timeout` kan fortsätta att köras, vilket "
"isolerar avbokningen till respektive strukturerat block. Till exempel::"

#: ../../library/asyncio-task.rst:1235
msgid ""
"While the block with ``make_request()`` and ``make_another_request()`` might "
"get cancelled due to the timeout, ``unrelated_code()`` should continue "
"running even in case of the timeout.  This is implemented with :meth:"
"`uncancel`.  :class:`TaskGroup` context managers use :func:`uncancel` in a "
"similar fashion."
msgstr ""
"Medan blocken med ``make_request()`` och ``make_another_request()`` kan "
"avbrytas på grund av timeout, bör ``unrelated_code()`` fortsätta att köras "
"även om timeout inträffar.  Detta implementeras med :meth:`uncancel`. :class:"
"`TaskGroup` kontexthanterare använder :func:`uncancel` på ett liknande sätt."

#: ../../library/asyncio-task.rst:1241
msgid ""
"If end-user code is, for some reason, suppresing cancellation by catching :"
"exc:`CancelledError`, it needs to call this method to remove the "
"cancellation state."
msgstr ""

#: ../../library/asyncio-task.rst:1247
msgid ""
"Return the number of pending cancellation requests to this Task, i.e., the "
"number of calls to :meth:`cancel` less the number of :meth:`uncancel` calls."
msgstr ""
"Returnerar antalet väntande avbokningsbegäranden till denna uppgift, dvs. "
"antalet anrop till :meth:`cancel` minus antalet anrop till :meth:`uncancel`."

#: ../../library/asyncio-task.rst:1251
msgid ""
"Note that if this number is greater than zero but the Task is still "
"executing, :meth:`cancelled` will still return ``False``. This is because "
"this number can be lowered by calling :meth:`uncancel`, which can lead to "
"the task not being cancelled after all if the cancellation requests go down "
"to zero."
msgstr ""
"Observera att om detta antal är större än noll men uppgiften fortfarande "
"körs, kommer :meth:`cancelled` fortfarande att returnera ``False``. Detta "
"beror på att detta antal kan sänkas genom att anropa :meth:`uncancel`, "
"vilket kan leda till att uppgiften inte avbryts trots allt om begäran om "
"avbrytande går ner till noll."

#: ../../library/asyncio-task.rst:1257
msgid ""
"This method is used by asyncio's internals and isn't expected to be used by "
"end-user code.  See :meth:`uncancel` for more details."
msgstr ""
"Den här metoden används av asyncios interna funktioner och förväntas inte "
"användas av slutanvändarkod.  Se :meth:`uncancel` för mer information."
