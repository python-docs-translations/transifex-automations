# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-17 18:07+0000\n"
"PO-Revision-Date: 2025-09-22 17:55+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../library/pickle.rst:2
msgid ":mod:`pickle` --- Python object serialization"
msgstr ""

#: ../../library/pickle.rst:10
msgid "**Source code:** :source:`Lib/pickle.py`"
msgstr "**Källkod:** :source:`Lib/pickle.py`"

#: ../../library/pickle.rst:22
msgid ""
"The :mod:`pickle` module implements binary protocols for serializing and de-"
"serializing a Python object structure.  *\"Pickling\"* is the process "
"whereby a Python object hierarchy is converted into a byte stream, and "
"*\"unpickling\"* is the inverse operation, whereby a byte stream (from a :"
"term:`binary file` or :term:`bytes-like object`) is converted back into an "
"object hierarchy.  Pickling (and unpickling) is alternatively known as "
"\"serialization\", \"marshalling,\" [#]_ or \"flattening\"; however, to "
"avoid confusion, the terms used here are \"pickling\" and \"unpickling\"."
msgstr ""
"Modulen :mod:`pickle` implementerar binära protokoll för serialisering och "
"de-serialisering av en Python-objektstruktur.  *\"Pickling\"* är processen "
"där en Python-objekthierarki konverteras till en byte-ström, och "
"*\"unpickling\"* är den omvända operationen, där en byte-ström (från en :"
"term:`binär fil` eller :term:`bytesliknande objekt`) konverteras tillbaka "
"till en objekthierarki.  Pickling (och unpickling) kallas även "
"\"serialization\", \"marshalling\", [#]_ eller \"flattening\", men för att "
"undvika förvirring används här termerna \"pickling\" och \"unpickling\"."

#: ../../library/pickle.rst:33
msgid "The ``pickle`` module **is not secure**. Only unpickle data you trust."
msgstr ""
"Modulen ``pickle`` är **inte säker**. Plocka endast upp data som du litar på."

#: ../../library/pickle.rst:35
msgid ""
"It is possible to construct malicious pickle data which will **execute "
"arbitrary code during unpickling**. Never unpickle data that could have come "
"from an untrusted source, or that could have been tampered with."
msgstr ""
"Det är möjligt att konstruera skadlig pickle-data som **exekverar godtycklig "
"kod under uppackning**. Plocka aldrig upp data som kan ha kommit från en "
"icke betrodd källa eller som kan ha manipulerats."

#: ../../library/pickle.rst:39
msgid ""
"Consider signing data with :mod:`hmac` if you need to ensure that it has not "
"been tampered with."
msgstr ""
"Överväg att signera data med :mod:`hmac` om du behöver försäkra dig om att "
"de inte har manipulerats."

#: ../../library/pickle.rst:42
msgid ""
"Safer serialization formats such as :mod:`json` may be more appropriate if "
"you are processing untrusted data. See :ref:`comparison-with-json`."
msgstr ""
"Säkrare serialiseringsformat som :mod:`json` kan vara lämpligare om du "
"bearbetar otillförlitliga data. Se :ref:`comparison-with-json`."

#: ../../library/pickle.rst:47
msgid "Relationship to other Python modules"
msgstr "Förhållande till andra Python-moduler"

#: ../../library/pickle.rst:50
msgid "Comparison with ``marshal``"
msgstr "Jämförelse med ``marshal``"

#: ../../library/pickle.rst:52
msgid ""
"Python has a more primitive serialization module called :mod:`marshal`, but "
"in general :mod:`pickle` should always be the preferred way to serialize "
"Python objects.  :mod:`marshal` exists primarily to support Python's :file:`."
"pyc` files."
msgstr ""
"Python har en mer primitiv serialiseringsmodul som heter :mod:`marshal`, men "
"i allmänhet bör :mod:`pickle` alltid vara det föredragna sättet att "
"serialisera Python-objekt. :mod:`marshal` finns främst för att stödja "
"Pythons :file:`.pyc`\\-filer."

#: ../../library/pickle.rst:57
msgid ""
"The :mod:`pickle` module differs from :mod:`marshal` in several significant "
"ways:"
msgstr ""
"Modulen :mod:`pickle` skiljer sig från :mod:`marshal` på flera viktiga sätt:"

#: ../../library/pickle.rst:59
msgid ""
"The :mod:`pickle` module keeps track of the objects it has already "
"serialized, so that later references to the same object won't be serialized "
"again. :mod:`marshal` doesn't do this."
msgstr ""
"Modulen :mod:`pickle` håller reda på de objekt som den redan har "
"serialiserat, så att senare referenser till samma objekt inte behöver "
"serialiseras igen. :mod:`marshal` gör inte detta."

#: ../../library/pickle.rst:63
msgid ""
"This has implications both for recursive objects and object sharing.  "
"Recursive objects are objects that contain references to themselves.  These "
"are not handled by marshal, and in fact, attempting to marshal recursive "
"objects will crash your Python interpreter.  Object sharing happens when "
"there are multiple references to the same object in different places in the "
"object hierarchy being serialized.  :mod:`pickle` stores such objects only "
"once, and ensures that all other references point to the master copy.  "
"Shared objects remain shared, which can be very important for mutable "
"objects."
msgstr ""
"Detta har konsekvenser för både rekursiva objekt och objektdelning.  "
"Rekursiva objekt är objekt som innehåller referenser till sig själva.  Dessa "
"hanteras inte av marshal, och i själva verket kommer försök att marshalera "
"rekursiva objekt att krascha din Python-tolk.  Objektdelning sker när det "
"finns flera referenser till samma objekt på olika platser i objekthierarkin "
"som serialiseras. :mod:`pickle` lagrar sådana objekt endast en gång och ser "
"till att alla andra referenser pekar på huvudkopian.  Delade objekt förblir "
"delade, vilket kan vara mycket viktigt för föränderliga objekt."

#: ../../library/pickle.rst:72
msgid ""
":mod:`marshal` cannot be used to serialize user-defined classes and their "
"instances.  :mod:`pickle` can save and restore class instances "
"transparently, however the class definition must be importable and live in "
"the same module as when the object was stored."
msgstr ""
":mod:`marshal` kan inte användas för att serialisera användardefinierade "
"klasser och deras instanser. :mod:`pickle` kan spara och återställa "
"klassinstanser på ett transparent sätt, men klassdefinitionen måste vara "
"importerbar och finnas i samma modul som när objektet lagrades."

#: ../../library/pickle.rst:77
msgid ""
"The :mod:`marshal` serialization format is not guaranteed to be portable "
"across Python versions.  Because its primary job in life is to support :file:"
"`.pyc` files, the Python implementers reserve the right to change the "
"serialization format in non-backwards compatible ways should the need arise. "
"The :mod:`pickle` serialization format is guaranteed to be backwards "
"compatible across Python releases provided a compatible pickle protocol is "
"chosen and pickling and unpickling code deals with Python 2 to Python 3 type "
"differences if your data is crossing that unique breaking change language "
"boundary."
msgstr ""
"Serialiseringsformatet :mod:`marshal` garanteras inte att vara portabelt "
"mellan olika Python-versioner.  Eftersom dess primära uppgift är att stödja :"
"file:`.pyc`\\-filer, förbehåller sig Python-implementatörerna rätten att "
"ändra serialiseringsformatet på icke-bakåtkompatibla sätt om behov skulle "
"uppstå. Serialiseringsformatet :mod:`pickle` är garanterat bakåtkompatibelt "
"mellan Python-versioner förutsatt att ett kompatibelt pickle-protokoll väljs "
"och att pickling- och unpickling-koden hanterar typskillnader mellan Python "
"2 och Python 3 om dina data passerar den unika språkgränsen."

#: ../../library/pickle.rst:90
msgid "Comparison with ``json``"
msgstr "Jämförelse med ``json``"

#: ../../library/pickle.rst:92
msgid ""
"There are fundamental differences between the pickle protocols and `JSON "
"(JavaScript Object Notation) <http://json.org>`_:"
msgstr ""

#: ../../library/pickle.rst:95
msgid ""
"JSON is a text serialization format (it outputs unicode text, although most "
"of the time it is then encoded to ``utf-8``), while pickle is a binary "
"serialization format;"
msgstr ""
"JSON är ett serialiseringsformat för text (det matar ut unicode-text, även "
"om det för det mesta sedan kodas till ``utf-8``), medan pickle är ett binärt "
"serialiseringsformat;"

#: ../../library/pickle.rst:99
msgid "JSON is human-readable, while pickle is not;"
msgstr "JSON är läsbart för människor, medan pickle inte är det;"

#: ../../library/pickle.rst:101
msgid ""
"JSON is interoperable and widely used outside of the Python ecosystem, while "
"pickle is Python-specific;"
msgstr ""
"JSON är interoperabelt och används ofta utanför Python-ekosystemet, medan "
"pickle är Python-specifikt;"

#: ../../library/pickle.rst:104
msgid ""
"JSON, by default, can only represent a subset of the Python built-in types, "
"and no custom classes; pickle can represent an extremely large number of "
"Python types (many of them automatically, by clever usage of Python's "
"introspection facilities; complex cases can be tackled by implementing :ref:"
"`specific object APIs <pickle-inst>`);"
msgstr ""
"JSON kan som standard bara representera en delmängd av Pythons inbyggda "
"typer, och inga anpassade klasser; pickle kan representera ett extremt stort "
"antal Python-typer (många av dem automatiskt, genom smart användning av "
"Pythons introspektionsmöjligheter; komplexa fall kan hanteras genom att "
"implementera :ref:`specifika objekt-API:er <pickle-inst>`);"

#: ../../library/pickle.rst:110
msgid ""
"Unlike pickle, deserializing untrusted JSON does not in itself create an "
"arbitrary code execution vulnerability."
msgstr ""
"Till skillnad från pickle skapar deserialisering av icke betrodda JSON inte "
"i sig en sårbarhet för godtycklig kodkörning."

#: ../../library/pickle.rst:114
msgid ""
"The :mod:`json` module: a standard library module allowing JSON "
"serialization and deserialization."
msgstr ""
"Modulen :mod:`json`: en standardbiblioteksmodul som möjliggör serialisering "
"och deserialisering av JSON."

#: ../../library/pickle.rst:121
msgid "Data stream format"
msgstr "Format för dataström"

#: ../../library/pickle.rst:126
msgid ""
"The data format used by :mod:`pickle` is Python-specific.  This has the "
"advantage that there are no restrictions imposed by external standards such "
"as JSON or XDR (which can't represent pointer sharing); however it means "
"that non-Python programs may not be able to reconstruct pickled Python "
"objects."
msgstr ""

#: ../../library/pickle.rst:131
msgid ""
"By default, the :mod:`pickle` data format uses a relatively compact binary "
"representation.  If you need optimal size characteristics, you can "
"efficiently :doc:`compress <archiving>` pickled data."
msgstr ""
"Som standard använder :mod:`pickle` dataformatet en relativt kompakt binär "
"representation.  Om du behöver optimala storleksegenskaper kan du på ett "
"effektivt sätt :doc:`komprimera <archiving>` pickled data."

#: ../../library/pickle.rst:135
msgid ""
"The module :mod:`pickletools` contains tools for analyzing data streams "
"generated by :mod:`pickle`.  :mod:`pickletools` source code has extensive "
"comments about opcodes used by pickle protocols."
msgstr ""
"Modulen :mod:`pickletools` innehåller verktyg för att analysera dataströmmar "
"som genereras av :mod:`pickle`. Källkoden till :mod:`pickletools` har "
"omfattande kommentarer om opkoder som används av pickle-protokoll."

#: ../../library/pickle.rst:139
msgid ""
"There are currently 6 different protocols which can be used for pickling. "
"The higher the protocol used, the more recent the version of Python needed "
"to read the pickle produced."
msgstr ""
"Det finns för närvarande 6 olika protokoll som kan användas för betning. Ju "
"högre protokoll som används, desto nyare version av Python behövs för att "
"läsa den pickle som produceras."

#: ../../library/pickle.rst:143
msgid ""
"Protocol version 0 is the original \"human-readable\" protocol and is "
"backwards compatible with earlier versions of Python."
msgstr ""
"Protokollversion 0 är det ursprungliga \"mänskligt läsbara\" protokollet och "
"är bakåtkompatibelt med tidigare versioner av Python."

#: ../../library/pickle.rst:146
msgid ""
"Protocol version 1 is an old binary format which is also compatible with "
"earlier versions of Python."
msgstr ""
"Protokollversion 1 är ett gammalt binärt format som också är kompatibelt med "
"tidigare versioner av Python."

#: ../../library/pickle.rst:149
msgid ""
"Protocol version 2 was introduced in Python 2.3.  It provides much more "
"efficient pickling of :term:`new-style classes <new-style class>`.  Refer "
"to :pep:`307` for information about improvements brought by protocol 2."
msgstr ""
"Protokollversion 2 introducerades i Python 2.3.  Det ger mycket effektivare "
"betning av :term:`nya stilklasser <new-style class>`.  Se :pep:`307` för "
"information om förbättringar som protokoll 2 medför."

#: ../../library/pickle.rst:153
msgid ""
"Protocol version 3 was added in Python 3.0.  It has explicit support for :"
"class:`bytes` objects and cannot be unpickled by Python 2.x.  This was the "
"default protocol in Python 3.0--3.7."
msgstr ""
"Protokollversion 3 lades till i Python 3.0.  Det har uttryckligt stöd för :"
"class:`bytes`\\-objekt och kan inte avplockas av Python 2.x. Detta var "
"standardprotokollet i Python 3.0--3.7."

#: ../../library/pickle.rst:157
msgid ""
"Protocol version 4 was added in Python 3.4.  It adds support for very large "
"objects, pickling more kinds of objects, and some data format "
"optimizations.  It is the default protocol starting with Python 3.8. Refer "
"to :pep:`3154` for information about improvements brought by protocol 4."
msgstr ""

#: ../../library/pickle.rst:163
msgid ""
"Protocol version 5 was added in Python 3.8.  It adds support for out-of-band "
"data and speedup for in-band data.  Refer to :pep:`574` for information "
"about improvements brought by protocol 5."
msgstr ""

#: ../../library/pickle.rst:168
msgid ""
"Serialization is a more primitive notion than persistence; although :mod:"
"`pickle` reads and writes file objects, it does not handle the issue of "
"naming persistent objects, nor the (even more complicated) issue of "
"concurrent access to persistent objects.  The :mod:`pickle` module can "
"transform a complex object into a byte stream and it can transform the byte "
"stream into an object with the same internal structure.  Perhaps the most "
"obvious thing to do with these byte streams is to write them onto a file, "
"but it is also conceivable to send them across a network or store them in a "
"database.  The :mod:`shelve` module provides a simple interface to pickle "
"and unpickle objects on DBM-style database files."
msgstr ""
"Serialisering är ett mer primitivt begrepp än persistens; även om :mod:"
"`pickle` läser och skriver filobjekt, hanterar den inte frågan om "
"namngivning av persistenta objekt eller den (ännu mer komplicerade) frågan "
"om samtidig åtkomst till persistenta objekt.  Modulen :mod:`pickle` kan "
"omvandla ett komplext objekt till en byte-ström och den kan omvandla byte-"
"strömmen till ett objekt med samma interna struktur.  Det kanske mest "
"uppenbara att göra med dessa byteflöden är att skriva dem till en fil, men "
"det är också tänkbart att skicka dem över ett nätverk eller lagra dem i en "
"databas.  Modulen :mod:`shelve` ger ett enkelt gränssnitt för att plocka och "
"plocka upp objekt på DBM-liknande databasfiler."

#: ../../library/pickle.rst:181
msgid "Module Interface"
msgstr "Modulgränssnitt"

#: ../../library/pickle.rst:183
msgid ""
"To serialize an object hierarchy, you simply call the :func:`dumps` "
"function. Similarly, to de-serialize a data stream, you call the :func:"
"`loads` function. However, if you want more control over serialization and "
"de-serialization, you can create a :class:`Pickler` or an :class:`Unpickler` "
"object, respectively."
msgstr ""
"För att serialisera en objekthierarki anropar du helt enkelt funktionen :"
"func:`dumps`. På samma sätt anropar du funktionen :func:`loads` för att "
"avserialisera en dataström. Men om du vill ha mer kontroll över "
"serialisering och de-serialisering kan du skapa ett :class:`Pickler`\\- "
"respektive ett :class:`Unpickler`\\-objekt."

#: ../../library/pickle.rst:188
msgid "The :mod:`pickle` module provides the following constants:"
msgstr "Modulen :mod:`pickle` tillhandahåller följande konstanter:"

#: ../../library/pickle.rst:193
msgid ""
"An integer, the highest :ref:`protocol version <pickle-protocols>` "
"available.  This value can be passed as a *protocol* value to functions :"
"func:`dump` and :func:`dumps` as well as the :class:`Pickler` constructor."
msgstr ""
"Ett heltal, den högsta :ref:`protocol version <pickle-protocols>` som finns "
"tillgänglig.  Detta värde kan skickas som ett *protocol*-värde till "
"funktionerna :func:`dump` och :func:`dumps` samt till :class:`Pickler`\\-"
"konstruktören."

#: ../../library/pickle.rst:200
msgid ""
"An integer, the default :ref:`protocol version <pickle-protocols>` used for "
"pickling.  May be less than :data:`HIGHEST_PROTOCOL`.  Currently the default "
"protocol is 4, first introduced in Python 3.4 and incompatible with previous "
"versions."
msgstr ""

#: ../../library/pickle.rst:207
msgid "The default protocol is 3."
msgstr "Standardprotokollet är 3."

#: ../../library/pickle.rst:211
msgid "The default protocol is 4."
msgstr "Standardprotokollet är 4."

#: ../../library/pickle.rst:213
msgid ""
"The :mod:`pickle` module provides the following functions to make the "
"pickling process more convenient:"
msgstr ""
"Modulen :mod:`pickle` tillhandahåller följande funktioner för att göra "
"betningsprocessen mer bekväm:"

#: ../../library/pickle.rst:218
msgid ""
"Write the pickled representation of the object *obj* to the open :term:`file "
"object` *file*.  This is equivalent to ``Pickler(file, protocol).dump(obj)``."
msgstr ""
"Skriver den picklade representationen av objektet *obj* till det öppna :term:"
"`file object` *file*.  Detta är likvärdigt med ``Pickler(file, protocol)."
"dump(obj)``."

#: ../../library/pickle.rst:222
msgid ""
"Arguments *file*, *protocol*, *fix_imports* and *buffer_callback* have the "
"same meaning as in the :class:`Pickler` constructor."
msgstr ""
"Argumenten *file*, *protocol*, *fix_imports* och *buffer_callback* har samma "
"betydelse som i :class:`Pickler`\\-konstruktorn."

#: ../../library/pickle.rst:225 ../../library/pickle.rst:236
#: ../../library/pickle.rst:328
msgid "The *buffer_callback* argument was added."
msgstr "Argumentet *buffer_callback* har lagts till."

#: ../../library/pickle.rst:230
msgid ""
"Return the pickled representation of the object *obj* as a :class:`bytes` "
"object, instead of writing it to a file."
msgstr ""
"Returnerar den betade representationen av objektet *obj* som ett :class:"
"`bytes`\\-objekt, istället för att skriva det till en fil."

#: ../../library/pickle.rst:233
msgid ""
"Arguments *protocol*, *fix_imports* and *buffer_callback* have the same "
"meaning as in the :class:`Pickler` constructor."
msgstr ""
"Argumenten *protocol*, *fix_imports* och *buffer_callback* har samma "
"betydelse som i :class:`Pickler`\\-konstruktorn."

#: ../../library/pickle.rst:241
msgid ""
"Read the pickled representation of an object from the open :term:`file "
"object` *file* and return the reconstituted object hierarchy specified "
"therein. This is equivalent to ``Unpickler(file).load()``."
msgstr ""
"Läser in den inlagda representationen av ett objekt från den öppna :term:"
"`file object` *file* och returnerar den rekonstruerade objekthierarkin som "
"anges där. Detta är ekvivalent med ``Unpickler(file).load()``."

#: ../../library/pickle.rst:245 ../../library/pickle.rst:260
msgid ""
"The protocol version of the pickle is detected automatically, so no protocol "
"argument is needed.  Bytes past the pickled representation of the object are "
"ignored."
msgstr ""
"Protokollversionen av pickle upptäcks automatiskt, så inget "
"protokollargument behövs.  Bytes som ligger efter objektets picklade "
"representation ignoreras."

#: ../../library/pickle.rst:249
msgid ""
"Arguments *file*, *fix_imports*, *encoding*, *errors*, *strict* and "
"*buffers* have the same meaning as in the :class:`Unpickler` constructor."
msgstr ""
"Argumenten *file*, *fix_imports*, *encoding*, *errors*, *strict* och "
"*buffers* har samma betydelse som i konstruktören :class:`Unpickler`."

#: ../../library/pickle.rst:252 ../../library/pickle.rst:267
#: ../../library/pickle.rst:429
msgid "The *buffers* argument was added."
msgstr "Argumentet *buffertar* har lagts till."

#: ../../library/pickle.rst:257
msgid ""
"Return the reconstituted object hierarchy of the pickled representation "
"*data* of an object. *data* must be a :term:`bytes-like object`."
msgstr ""
"Returnerar den rekonstituerade objekthierarkin för den betade "
"representationen *data* av ett objekt. *data* måste vara en :term:"
"`bytesliknande objekt`."

#: ../../library/pickle.rst:264
msgid ""
"Arguments *fix_imports*, *encoding*, *errors*, *strict* and *buffers* have "
"the same meaning as in the :class:`Unpickler` constructor."
msgstr ""
"Argumenten *fix_imports*, *encoding*, *errors*, *strict* och *buffers* har "
"samma betydelse som i konstruktören :class:`Unpickler`."

#: ../../library/pickle.rst:271
msgid "The :mod:`pickle` module defines three exceptions:"
msgstr "Modulen :mod:`pickle` definierar tre undantag:"

#: ../../library/pickle.rst:275
msgid ""
"Common base class for the other pickling exceptions.  It inherits :exc:"
"`Exception`."
msgstr ""

#: ../../library/pickle.rst:280
msgid ""
"Error raised when an unpicklable object is encountered by :class:`Pickler`. "
"It inherits :exc:`PickleError`."
msgstr ""

#: ../../library/pickle.rst:283
msgid ""
"Refer to :ref:`pickle-picklable` to learn what kinds of objects can be "
"pickled."
msgstr ""
"Se :ref:`pickle-picklable` för att lära dig vilka typer av objekt som kan "
"picklas."

#: ../../library/pickle.rst:288
msgid ""
"Error raised when there is a problem unpickling an object, such as a data "
"corruption or a security violation.  It inherits :exc:`PickleError`."
msgstr ""

#: ../../library/pickle.rst:291
msgid ""
"Note that other exceptions may also be raised during unpickling, including "
"(but not necessarily limited to) AttributeError, EOFError, ImportError, and "
"IndexError."
msgstr ""
"Observera att andra undantag också kan uppstå under unpickling, inklusive "
"(men inte nödvändigtvis begränsat till) AttributeError, EOFError, "
"ImportError och IndexError."

#: ../../library/pickle.rst:296
msgid ""
"The :mod:`pickle` module exports three classes, :class:`Pickler`, :class:"
"`Unpickler` and :class:`PickleBuffer`:"
msgstr ""
"Modulen :mod:`pickle` exporterar tre klasser, :class:`Pickler`, :class:"
"`Unpickler` och :class:`PickleBuffer`:"

#: ../../library/pickle.rst:301
msgid "This takes a binary file for writing a pickle data stream."
msgstr "Detta tar en binär fil för att skriva en pickle-dataström."

#: ../../library/pickle.rst:303
msgid ""
"The optional *protocol* argument, an integer, tells the pickler to use the "
"given protocol; supported protocols are 0 to :data:`HIGHEST_PROTOCOL`. If "
"not specified, the default is :data:`DEFAULT_PROTOCOL`.  If a negative "
"number is specified, :data:`HIGHEST_PROTOCOL` is selected."
msgstr ""
"Det valfria argumentet *protocol*, ett heltal, talar om för betningsmaskinen "
"att den ska använda det angivna protokollet; protokoll som stöds är 0 till :"
"data:`HIGHEST_PROTOCOL`. Om det inte anges är standardvärdet :data:"
"`DEFAULT_PROTOCOL`.  Om ett negativt tal anges väljs :data:"
"`HIGHEST_PROTOCOL`."

#: ../../library/pickle.rst:308
msgid ""
"The *file* argument must have a write() method that accepts a single bytes "
"argument.  It can thus be an on-disk file opened for binary writing, an :"
"class:`io.BytesIO` instance, or any other custom object that meets this "
"interface."
msgstr ""
"Argumentet *file* måste ha en write()-metod som accepterar ett enda bytes-"
"argument.  Det kan alltså vara en fil på disken som är öppen för binär "
"skrivning, en :class:`io.BytesIO`\\-instans eller något annat anpassat "
"objekt som uppfyller detta gränssnitt."

#: ../../library/pickle.rst:313
msgid ""
"If *fix_imports* is true and *protocol* is less than 3, pickle will try to "
"map the new Python 3 names to the old module names used in Python 2, so that "
"the pickle data stream is readable with Python 2."
msgstr ""
"Om *fix_imports* är true och *protocol* är mindre än 3, kommer pickle att "
"försöka mappa de nya Python 3-namnen till de gamla modulnamnen som används i "
"Python 2, så att pickle-dataflödet kan läsas med Python 2."

#: ../../library/pickle.rst:317
msgid ""
"If *buffer_callback* is None (the default), buffer views are serialized into "
"*file* as part of the pickle stream."
msgstr ""

#: ../../library/pickle.rst:320
msgid ""
"If *buffer_callback* is not None, then it can be called any number of times "
"with a buffer view.  If the callback returns a false value (such as None), "
"the given buffer is :ref:`out-of-band <pickle-oob>`; otherwise the buffer is "
"serialized in-band, i.e. inside the pickle stream."
msgstr ""

#: ../../library/pickle.rst:325
msgid ""
"It is an error if *buffer_callback* is not None and *protocol* is None or "
"smaller than 5."
msgstr ""

#: ../../library/pickle.rst:333
msgid ""
"Write the pickled representation of *obj* to the open file object given in "
"the constructor."
msgstr ""
"Skriv den betade representationen av *obj* till open file object som anges i "
"konstruktören."

#: ../../library/pickle.rst:338
msgid "Do nothing by default.  This exists so a subclass can override it."
msgstr ""
"Gör ingenting som standard.  Detta finns så att en underklass kan åsidosätta "
"det."

#: ../../library/pickle.rst:340
msgid ""
"If :meth:`persistent_id` returns ``None``, *obj* is pickled as usual.  Any "
"other value causes :class:`Pickler` to emit the returned value as a "
"persistent ID for *obj*.  The meaning of this persistent ID should be "
"defined by :meth:`Unpickler.persistent_load`.  Note that the value returned "
"by :meth:`persistent_id` cannot itself have a persistent ID."
msgstr ""
"Om :meth:`persistent_id` returnerar ``None`` betas *obj* som vanligt.  Alla "
"andra värden gör att :class:`Pickler` skickar ut det returnerade värdet som "
"ett persistent ID för *obj*.  Betydelsen av detta persistenta ID bör "
"definieras av :meth:`Unpickler.persistent_load`.  Observera att det värde "
"som returneras av :meth:`persistent_id` inte själv kan ha ett persistent ID."

#: ../../library/pickle.rst:346 ../../library/pickle.rst:447
msgid "See :ref:`pickle-persistent` for details and examples of uses."
msgstr ""
"Se :ref:`pickle-persistent` för detaljer och exempel på användningsområden."

#: ../../library/pickle.rst:350
msgid ""
"A pickler object's dispatch table is a registry of *reduction functions* of "
"the kind which can be declared using :func:`copyreg.pickle`.  It is a "
"mapping whose keys are classes and whose values are reduction functions.  A "
"reduction function takes a single argument of the associated class and "
"should conform to the same interface as a :meth:`__reduce__` method."
msgstr ""

#: ../../library/pickle.rst:358
msgid ""
"By default, a pickler object will not have a :attr:`dispatch_table` "
"attribute, and it will instead use the global dispatch table managed by the :"
"mod:`copyreg` module. However, to customize the pickling for a specific "
"pickler object one can set the :attr:`dispatch_table` attribute to a dict-"
"like object.  Alternatively, if a subclass of :class:`Pickler` has a :attr:"
"`dispatch_table` attribute then this will be used as the default dispatch "
"table for instances of that class."
msgstr ""
"Som standard kommer ett pickler-objekt inte att ha ett :attr:"
"`dispatch_table`\\-attribut, och det kommer istället att använda den globala "
"dispatch-tabellen som hanteras av :mod:`copyreg`\\-modulen. För att anpassa "
"betningen för ett specifikt betningsobjekt kan man dock ställa in "
"attributet :attr:`dispatch_table` till ett diktliknande objekt.  "
"Alternativt, om en underklass av :class:`Pickler` har ett :attr:"
"`dispatch_table` attribut så kommer detta att användas som standard dispatch "
"table för instanser av den klassen."

#: ../../library/pickle.rst:367
msgid "See :ref:`pickle-dispatch` for usage examples."
msgstr "Se :ref:`pickle-dispatch` för användningsexempel."

#: ../../library/pickle.rst:373
msgid ""
"Special reducer that can be defined in :class:`Pickler` subclasses. This "
"method has priority over any reducer in the :attr:`dispatch_table`.  It "
"should conform to the same interface as a :meth:`__reduce__` method, and can "
"optionally return ``NotImplemented`` to fallback on :attr:`dispatch_table`-"
"registered reducers to pickle ``obj``."
msgstr ""

#: ../../library/pickle.rst:379
msgid "For a detailed example, see :ref:`reducer_override`."
msgstr "För ett detaljerat exempel, se :ref:`reducer_override`."

#: ../../library/pickle.rst:385
msgid ""
"Deprecated. Enable fast mode if set to a true value.  The fast mode disables "
"the usage of memo, therefore speeding the pickling process by not generating "
"superfluous PUT opcodes.  It should not be used with self-referential "
"objects, doing otherwise will cause :class:`Pickler` to recurse infinitely."
msgstr ""
"Föråldrad. Aktiverar snabbläge om det sätts till ett sant värde.  Det snabba "
"läget inaktiverar användningen av memo, vilket påskyndar betningsprocessen "
"genom att inte generera överflödiga PUT-opkoder.  Det bör inte användas med "
"självrefererande objekt, annars kommer :class:`Pickler` att rekursera "
"oändligt."

#: ../../library/pickle.rst:391
msgid "Use :func:`pickletools.optimize` if you need more compact pickles."
msgstr ""
"Använd :func:`pickletools.optimize` om du behöver mer kompakta pickles."

#: ../../library/pickle.rst:396
msgid "This takes a binary file for reading a pickle data stream."
msgstr "Detta tar en binär fil för att läsa en pickle-dataström."

#: ../../library/pickle.rst:398
msgid ""
"The protocol version of the pickle is detected automatically, so no protocol "
"argument is needed."
msgstr ""
"Protokollversionen av pickle identifieras automatiskt, så inget "
"protokollargument behövs."

#: ../../library/pickle.rst:401
msgid ""
"The argument *file* must have three methods, a read() method that takes an "
"integer argument, a readinto() method that takes a buffer argument and a "
"readline() method that requires no arguments, as in the :class:`io."
"BufferedIOBase` interface.  Thus *file* can be an on-disk file opened for "
"binary reading, an :class:`io.BytesIO` object, or any other custom object "
"that meets this interface."
msgstr ""
"Argumentet *file* måste ha tre metoder, en read()-metod som tar ett "
"heltalsargument, en readinto()-metod som tar ett buffertargument och en "
"readline()-metod som inte kräver några argument, som i gränssnittet :class:"
"`io.BufferedIOBase`.  Således kan *file* vara en diskfil som öppnas för "
"binär läsning, ett :class:`io.BytesIO`\\-objekt eller något annat anpassat "
"objekt som uppfyller detta gränssnitt."

#: ../../library/pickle.rst:408
msgid ""
"The optional arguments *fix_imports*, *encoding* and *errors* are used to "
"control compatibility support for pickle stream generated by Python 2. If "
"*fix_imports* is true, pickle will try to map the old Python 2 names to the "
"new names used in Python 3.  The *encoding* and *errors* tell pickle how to "
"decode 8-bit string instances pickled by Python 2; these default to 'ASCII' "
"and 'strict', respectively.  The *encoding* can be 'bytes' to read these 8-"
"bit string instances as bytes objects. Using ``encoding='latin1'`` is "
"required for unpickling NumPy arrays and instances of :class:`~datetime."
"datetime`, :class:`~datetime.date` and :class:`~datetime.time` pickled by "
"Python 2."
msgstr ""
"De valfria argumenten *fix_imports*, *encoding* och *errors* används för att "
"styra kompatibilitetsstödet för pickle-strömmar som genererats av Python 2. "
"Om *fix_imports* är true kommer pickle att försöka mappa de gamla Python 2-"
"namnen till de nya namn som används i Python 3.  *encoding* och *errors* "
"talar om för pickle hur man avkodar 8-bitars stränginstanser som plockats "
"upp av Python 2; dessa är standardiserade till 'ASCII' respektive 'strict'.  "
"*encoding* kan vara 'bytes' för att läsa dessa 8-bitars stränginstanser som "
"bytes-objekt. Användning av ``encoding='latin1'`` krävs för att avplocka "
"NumPy-arrayer och instanser av :class:`~datetime.datetime`, :class:"
"`~datetime.date` och :class:`~datetime.time` som avplockats av Python 2."

#: ../../library/pickle.rst:419
msgid ""
"If *buffers* is None (the default), then all data necessary for "
"deserialization must be contained in the pickle stream.  This means that the "
"*buffer_callback* argument was None when a :class:`Pickler` was instantiated "
"(or when :func:`dump` or :func:`dumps` was called)."
msgstr ""

#: ../../library/pickle.rst:424
msgid ""
"If *buffers* is not None, it should be an iterable of buffer-enabled objects "
"that is consumed each time the pickle stream references an :ref:`out-of-band "
"<pickle-oob>` buffer view.  Such buffers have been given in order to the "
"*buffer_callback* of a Pickler object."
msgstr ""

#: ../../library/pickle.rst:434
msgid ""
"Read the pickled representation of an object from the open file object given "
"in the constructor, and return the reconstituted object hierarchy specified "
"therein.  Bytes past the pickled representation of the object are ignored."
msgstr ""
"Läser den betade representationen av ett objekt från det öppna filobjektet "
"som anges i konstruktören och returnerar den rekonstruerade objekthierarkin "
"som anges däri.  Byte efter den betade representationen av objektet "
"ignoreras."

#: ../../library/pickle.rst:441
msgid "Raise an :exc:`UnpicklingError` by default."
msgstr "Ger som standard upphov till ett :exc:`UnpicklingError`."

#: ../../library/pickle.rst:443
msgid ""
"If defined, :meth:`persistent_load` should return the object specified by "
"the persistent ID *pid*.  If an invalid persistent ID is encountered, an :"
"exc:`UnpicklingError` should be raised."
msgstr ""
"Om definierat bör :meth:`persistent_load` returnera det objekt som anges av "
"det beständiga ID:t *pid*.  Om ett ogiltigt beständigt ID påträffas bör ett :"
"exc:`UnpicklingError` uppstå."

#: ../../library/pickle.rst:451
msgid ""
"Import *module* if necessary and return the object called *name* from it, "
"where the *module* and *name* arguments are :class:`str` objects.  Note, "
"unlike its name suggests, :meth:`find_class` is also used for finding "
"functions."
msgstr ""
"Importera *modul* om det behövs och returnera objektet som heter *namn* från "
"den, där argumenten *modul* och *namn* är :class:`str`\\-objekt.  Observera "
"att, till skillnad från vad namnet antyder, används :meth:`find_class` också "
"för att hitta funktioner."

#: ../../library/pickle.rst:456
msgid ""
"Subclasses may override this to gain control over what type of objects and "
"how they can be loaded, potentially reducing security risks. Refer to :ref:"
"`pickle-restrict` for details."
msgstr ""
"Underklasser kan åsidosätta detta för att få kontroll över vilken typ av "
"objekt och hur de kan laddas, vilket potentiellt kan minska "
"säkerhetsriskerna. Se :ref:`pickle-restrict` för mer information."

#: ../../library/pickle.rst:460
msgid ""
"Raises an :ref:`auditing event <auditing>` ``pickle.find_class`` with "
"arguments ``module``, ``name``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``pickle.find_class`` med "
"argumenten ``module``, ``name``."

#: ../../library/pickle.rst:464
msgid ""
"A wrapper for a buffer representing picklable data.  *buffer* must be a :ref:"
"`buffer-providing <bufferobjects>` object, such as a :term:`bytes-like "
"object` or a N-dimensional array."
msgstr ""
"Ett omslag för en buffert som representerar betningsbar data.  *buffer* "
"måste vara ett :ref:`buffer-providing <bufferobjects>`\\-objekt, t.ex. ett :"
"term:`bytesliknande objekt` eller en N-dimensionell array."

#: ../../library/pickle.rst:468
msgid ""
":class:`PickleBuffer` is itself a buffer provider, therefore it is possible "
"to pass it to other APIs expecting a buffer-providing object, such as :class:"
"`memoryview`."
msgstr ""
":class:`PickleBuffer` är i sig en buffertleverantör, därför är det möjligt "
"att skicka den till andra API:er som förväntar sig ett buffertlevererande "
"objekt, t.ex. :class:`memoryview`."

#: ../../library/pickle.rst:472
msgid ""
":class:`PickleBuffer` objects can only be serialized using pickle protocol 5 "
"or higher.  They are eligible for :ref:`out-of-band serialization <pickle-"
"oob>`."
msgstr ""
":class:`PickleBuffer`\\-objekt kan endast serialiseras med pickle protokoll "
"5 eller högre.  De är kvalificerade för :ref:`out-of-band serialization "
"<pickle-oob>`."

#: ../../library/pickle.rst:480
msgid ""
"Return a :class:`memoryview` of the memory area underlying this buffer. The "
"returned object is a one-dimensional, C-contiguous memoryview with format "
"``B`` (unsigned bytes).  :exc:`BufferError` is raised if the buffer is "
"neither C- nor Fortran-contiguous."
msgstr ""
"Returnerar en :class:`memoryview` av minnesområdet som ligger bakom denna "
"buffert. Det returnerade objektet är en endimensionell, C-sluten minnesvy "
"med format ``B`` (osignerade byte). :exc:`BufferError` uppstår om bufferten "
"varken är C- eller Fortran-sluten."

#: ../../library/pickle.rst:487
msgid "Release the underlying buffer exposed by the PickleBuffer object."
msgstr ""
"Frigör den underliggande bufferten som exponeras av PickleBuffer-objektet."

#: ../../library/pickle.rst:493
msgid "What can be pickled and unpickled?"
msgstr "Vad kan vara inlagt och oinlagt?"

#: ../../library/pickle.rst:495
msgid "The following types can be pickled:"
msgstr "Följande typer kan picklas:"

#: ../../library/pickle.rst:497
msgid "``None``, ``True``, and ``False``;"
msgstr ""

#: ../../library/pickle.rst:499
msgid "integers, floating-point numbers, complex numbers;"
msgstr "heltal, flyttal, komplexa tal;"

#: ../../library/pickle.rst:501
msgid "strings, bytes, bytearrays;"
msgstr "strängar, byte, bytearrayer;"

#: ../../library/pickle.rst:503
msgid ""
"tuples, lists, sets, and dictionaries containing only picklable objects;"
msgstr ""
"tupler, listor, mängder och lexikon som endast innehåller plockbara objekt;"

#: ../../library/pickle.rst:505
msgid ""
"functions (built-in and user-defined) defined at the top level of a module "
"(using :keyword:`def`, not :keyword:`lambda`);"
msgstr ""

#: ../../library/pickle.rst:508
msgid "classes defined at the top level of a module;"
msgstr ""

#: ../../library/pickle.rst:510
msgid ""
"instances of such classes whose :attr:`~object.__dict__` or the result of "
"calling :meth:`__getstate__` is picklable  (see section :ref:`pickle-inst` "
"for details)."
msgstr ""

#: ../../library/pickle.rst:514
msgid ""
"Attempts to pickle unpicklable objects will raise the :exc:`PicklingError` "
"exception; when this happens, an unspecified number of bytes may have "
"already been written to the underlying file.  Trying to pickle a highly "
"recursive data structure may exceed the maximum recursion depth, a :exc:"
"`RecursionError` will be raised in this case.  You can carefully raise this "
"limit with :func:`sys.setrecursionlimit`."
msgstr ""
"Försök att plocka ut icke-plockbara objekt kommer att ge upphov till "
"undantaget :exc:`PicklingError`; när detta händer kan ett ospecificerat "
"antal byte redan ha skrivits till den underliggande filen.  Att försöka "
"plocka en mycket rekursiv datastruktur kan överskrida det maximala "
"rekursionsdjupet, ett :exc:`RecursionError` kommer att uppstå i detta fall.  "
"Du kan försiktigt höja denna gräns med :func:`sys.setrecursionlimit`."

#: ../../library/pickle.rst:521
msgid ""
"Note that functions (built-in and user-defined) are pickled by fully "
"qualified name, not by value. [#]_  This means that only the function name "
"is pickled, along with the name of the module the function is defined in.  "
"Neither the function's code, nor any of its function attributes are "
"pickled.  Thus the defining module must be importable in the unpickling "
"environment, and the module must contain the named object, otherwise an "
"exception will be raised. [#]_"
msgstr ""

#: ../../library/pickle.rst:528
msgid ""
"Similarly, classes are pickled by fully qualified name, so the same "
"restrictions in the unpickling environment apply.  Note that none of the "
"class's code or data is pickled, so in the following example the class "
"attribute ``attr`` is not restored in the unpickling environment::"
msgstr ""
"På samma sätt betas klasser med fullt kvalificerat namn, så samma "
"restriktioner i betningsmiljön gäller.  Observera att ingen av klassens kod "
"eller data betas in, så i följande exempel återställs inte klassattributet "
"``attr`` i unpickling-miljön::"

#: ../../library/pickle.rst:538
msgid ""
"These restrictions are why picklable functions and classes must be defined "
"at the top level of a module."
msgstr ""
"Dessa begränsningar är skälet till att picklbara funktioner och klasser "
"måste definieras på den översta nivån i en modul."

#: ../../library/pickle.rst:541
msgid ""
"Similarly, when class instances are pickled, their class's code and data are "
"not pickled along with them.  Only the instance data are pickled.  This is "
"done on purpose, so you can fix bugs in a class or add methods to the class "
"and still load objects that were created with an earlier version of the "
"class.  If you plan to have long-lived objects that will see many versions "
"of a class, it may be worthwhile to put a version number in the objects so "
"that suitable conversions can be made by the class's :meth:`__setstate__` "
"method."
msgstr ""

#: ../../library/pickle.rst:553
msgid "Pickling Class Instances"
msgstr "Pickling av klassinstanser"

#: ../../library/pickle.rst:557
msgid ""
"In this section, we describe the general mechanisms available to you to "
"define, customize, and control how class instances are pickled and unpickled."
msgstr ""
"I det här avsnittet beskriver vi de allmänna mekanismer som finns "
"tillgängliga för att definiera, anpassa och styra hur klassinstanser ska "
"picklas och unpicklas."

#: ../../library/pickle.rst:560
msgid ""
"In most cases, no additional code is needed to make instances picklable.  By "
"default, pickle will retrieve the class and the attributes of an instance "
"via introspection. When a class instance is unpickled, its :meth:`__init__` "
"method is usually *not* invoked.  The default behaviour first creates an "
"uninitialized instance and then restores the saved attributes.  The "
"following code shows an implementation of this behaviour::"
msgstr ""

#: ../../library/pickle.rst:575
msgid ""
"Classes can alter the default behaviour by providing one or several special "
"methods:"
msgstr ""
"Klasser kan ändra standardbeteendet genom att tillhandahålla en eller flera "
"specialmetoder:"

#: ../../library/pickle.rst:580
msgid ""
"In protocols 2 and newer, classes that implements the :meth:"
"`__getnewargs_ex__` method can dictate the values passed to the :meth:"
"`__new__` method upon unpickling.  The method must return a pair ``(args, "
"kwargs)`` where *args* is a tuple of positional arguments and *kwargs* a "
"dictionary of named arguments for constructing the object.  Those will be "
"passed to the :meth:`__new__` method upon unpickling."
msgstr ""
"I protokoll 2 och nyare kan klasser som implementerar metoden :meth:"
"`__getnewargs_ex__` diktera de värden som skickas till metoden :meth:"
"`__new__` vid unpickling.  Metoden måste returnera ett par ``(args, "
"kwargs)`` där *args* är en tupel av positionella argument och *kwargs* en "
"dictionary av namngivna argument för att konstruera objektet.  Dessa kommer "
"att skickas till :meth:`__new__`\\-metoden vid uppplockning."

#: ../../library/pickle.rst:588
msgid ""
"You should implement this method if the :meth:`__new__` method of your class "
"requires keyword-only arguments.  Otherwise, it is recommended for "
"compatibility to implement :meth:`__getnewargs__`."
msgstr ""
"Du bör implementera denna metod om metoden :meth:`__new__` i din klass "
"kräver argument som endast innehåller nyckelord.  I annat fall rekommenderas "
"det av kompatibilitetsskäl att implementera :meth:`__getnewargs__`."

#: ../../library/pickle.rst:592
msgid ":meth:`__getnewargs_ex__` is now used in protocols 2 and 3."
msgstr ":meth:`__getnewargs_ex__` används nu i protokoll 2 och 3."

#: ../../library/pickle.rst:598
msgid ""
"This method serves a similar purpose as :meth:`__getnewargs_ex__`, but "
"supports only positional arguments.  It must return a tuple of arguments "
"``args`` which will be passed to the :meth:`__new__` method upon unpickling."
msgstr ""
"Denna metod tjänar ett liknande syfte som :meth:`__getnewargs_ex__`, men "
"stöder endast positionella argument.  Den måste returnera en tupel av "
"argument ``args`` som kommer att skickas till :meth:`__new__`` metoden vid "
"uppplockning."

#: ../../library/pickle.rst:602
msgid ""
":meth:`__getnewargs__` will not be called if :meth:`__getnewargs_ex__` is "
"defined."
msgstr ""
":meth:`__getnewargs__` kommer inte att anropas om :meth:`__getnewargs_ex__` "
"är definierad."

#: ../../library/pickle.rst:605
msgid ""
"Before Python 3.6, :meth:`__getnewargs__` was called instead of :meth:"
"`__getnewargs_ex__` in protocols 2 and 3."
msgstr ""
"Före Python 3.6 anropades :meth:`__getnewargs__` i stället för :meth:"
"`__getnewargs_ex__` i protokoll 2 och 3."

#: ../../library/pickle.rst:612
msgid ""
"Classes can further influence how their instances are pickled; if the class "
"defines the method :meth:`__getstate__`, it is called and the returned "
"object is pickled as the contents for the instance, instead of the contents "
"of the instance's dictionary.  If the :meth:`__getstate__` method is absent, "
"the instance's :attr:`~object.__dict__` is pickled as usual."
msgstr ""

#: ../../library/pickle.rst:621
msgid ""
"Upon unpickling, if the class defines :meth:`__setstate__`, it is called "
"with the unpickled state.  In that case, there is no requirement for the "
"state object to be a dictionary.  Otherwise, the pickled state must be a "
"dictionary and its items are assigned to the new instance's dictionary."
msgstr ""
"Vid unpickling, om klassen definierar :meth:`__setstate__`, anropas den med "
"det unpicklade tillståndet.  I det fallet finns det inget krav på att state-"
"objektet ska vara en dictionary.  Annars måste det inlagda tillståndet vara "
"en ordbok och dess objekt tilldelas den nya instansens ordbok."

#: ../../library/pickle.rst:628
msgid ""
"If :meth:`__getstate__` returns a false value, the :meth:`__setstate__` "
"method will not be called upon unpickling."
msgstr ""

#: ../../library/pickle.rst:632
msgid ""
"Refer to the section :ref:`pickle-state` for more information about how to "
"use the methods :meth:`__getstate__` and :meth:`__setstate__`."
msgstr ""

#: ../../library/pickle.rst:637
msgid ""
"At unpickling time, some methods like :meth:`__getattr__`, :meth:"
"`__getattribute__`, or :meth:`__setattr__` may be called upon the instance.  "
"In case those methods rely on some internal invariant being true, the type "
"should implement :meth:`__new__` to establish such an invariant, as :meth:"
"`__init__` is not called when unpickling an instance."
msgstr ""

#: ../../library/pickle.rst:646
msgid ""
"As we shall see, pickle does not use directly the methods described above.  "
"In fact, these methods are part of the copy protocol which implements the :"
"meth:`__reduce__` special method.  The copy protocol provides a unified "
"interface for retrieving the data necessary for pickling and copying "
"objects. [#]_"
msgstr ""

#: ../../library/pickle.rst:652
msgid ""
"Although powerful, implementing :meth:`__reduce__` directly in your classes "
"is error prone.  For this reason, class designers should use the high-level "
"interface (i.e., :meth:`__getnewargs_ex__`, :meth:`__getstate__` and :meth:"
"`__setstate__`) whenever possible.  We will show, however, cases where "
"using :meth:`__reduce__` is the only option or leads to more efficient "
"pickling or both."
msgstr ""

#: ../../library/pickle.rst:661
msgid ""
"The interface is currently defined as follows.  The :meth:`__reduce__` "
"method takes no argument and shall return either a string or preferably a "
"tuple (the returned object is often referred to as the \"reduce value\")."
msgstr ""
"Gränssnittet är för närvarande definierat enligt följande.  Metoden :meth:"
"`__reduce__` tar inget argument och skall returnera antingen en sträng eller "
"helst en tupel (det returnerade objektet kallas ofta för "
"\"reduktionsvärdet\")."

#: ../../library/pickle.rst:665
msgid ""
"If a string is returned, the string should be interpreted as the name of a "
"global variable.  It should be the object's local name relative to its "
"module; the pickle module searches the module namespace to determine the "
"object's module.  This behaviour is typically useful for singletons."
msgstr ""
"Om en sträng returneras ska strängen tolkas som namnet på en global "
"variabel.  Det bör vara objektets lokala namn i förhållande till dess modul; "
"pickle-modulen söker i modulnamnrymden för att fastställa objektets modul.  "
"Detta beteende är typiskt användbart för singletons."

#: ../../library/pickle.rst:670
msgid ""
"When a tuple is returned, it must be between two and six items long. "
"Optional items can either be omitted, or ``None`` can be provided as their "
"value.  The semantics of each item are in order:"
msgstr ""
"När en tupel returneras måste den vara mellan två och sex poster lång. "
"Valfria objekt kan antingen utelämnas, eller så kan ``None`` anges som "
"värde.  Semantiken för varje objekt är i ordning:"

#: ../../library/pickle.rst:676
msgid ""
"A callable object that will be called to create the initial version of the "
"object."
msgstr ""
"Ett anropsbart objekt som kommer att anropas för att skapa den första "
"versionen av objektet."

#: ../../library/pickle.rst:679
msgid ""
"A tuple of arguments for the callable object.  An empty tuple must be given "
"if the callable does not accept any argument."
msgstr ""
"En tupel av argument för det anropbara objektet.  En tom tupel måste anges "
"om det anropbara objektet inte accepterar något argument."

#: ../../library/pickle.rst:682
msgid ""
"Optionally, the object's state, which will be passed to the object's :meth:"
"`__setstate__` method as previously described.  If the object has no such "
"method then, the value must be a dictionary and it will be added to the "
"object's :attr:`~object.__dict__` attribute."
msgstr ""
"Eventuellt objektets tillstånd, som kommer att skickas till objektets :meth:"
"`__setstate__`\\-metod enligt tidigare beskrivning.  Om objektet inte har "
"någon sådan metod måste värdet vara en dictionary och det kommer att läggas "
"till i objektets attribut :attr:`~object.__dict__`."

#: ../../library/pickle.rst:687
msgid ""
"Optionally, an iterator (and not a sequence) yielding successive items. "
"These items will be appended to the object either using ``obj.append(item)`` "
"or, in batch, using ``obj.extend(list_of_items)``. This is primarily used "
"for list subclasses, but may be used by other classes as long as they have :"
"meth:`append` and :meth:`extend` methods with the appropriate signature.  "
"(Whether :meth:`append` or :meth:`extend` is used depends on which pickle "
"protocol version is used as well as the number of items to append, so both "
"must be supported.)"
msgstr ""

#: ../../library/pickle.rst:696
msgid ""
"Optionally, an iterator (not a sequence) yielding successive key-value "
"pairs.  These items will be stored to the object using ``obj[key] = "
"value``.  This is primarily used for dictionary subclasses, but may be used "
"by other classes as long as they implement :meth:`__setitem__`."
msgstr ""
"Eventuellt en iterator (inte en sekvens) som ger successiva nyckel-värde-"
"par.  Dessa objekt kommer att lagras i objektet med ``obj[key] = value``.  "
"Detta används främst för dictionary-subklasser, men kan användas av andra "
"klasser så länge de implementerar :meth:`__setitem__`."

#: ../../library/pickle.rst:701
msgid ""
"Optionally, a callable with a ``(obj, state)`` signature. This callable "
"allows the user to programmatically control the state-updating behavior of a "
"specific object, instead of using ``obj``'s static :meth:`__setstate__` "
"method. If not ``None``, this callable will have priority over ``obj``'s :"
"meth:`__setstate__`."
msgstr ""
"Eventuellt en anropbar funktion med signaturen ``(obj, state)``. Denna "
"anropsbarhet tillåter användaren att programmatiskt kontrollera "
"tillståndsuppdateringsbeteendet för ett specifikt objekt, istället för att "
"använda ``obj`` statiska :meth:`__setstate__` metod. Om inte ``None``, "
"kommer denna anropsbarhet att ha prioritet över ``obj`` :meth:`__setstate__`."

#: ../../library/pickle.rst:707
msgid "The optional sixth tuple item, ``(obj, state)``, was added."
msgstr "Det valfria sjätte tuple-objektet, ``(obj, state)``, lades till."

#: ../../library/pickle.rst:713
msgid ""
"Alternatively, a :meth:`__reduce_ex__` method may be defined.  The only "
"difference is this method should take a single integer argument, the "
"protocol version.  When defined, pickle will prefer it over the :meth:"
"`__reduce__` method.  In addition, :meth:`__reduce__` automatically becomes "
"a synonym for the extended version.  The main use for this method is to "
"provide backwards-compatible reduce values for older Python releases."
msgstr ""
"Alternativt kan en :meth:`__reduce_ex__`\\-metod definieras.  Den enda "
"skillnaden är att denna metod ska ta ett enda heltalsargument, "
"protokollversionen.  När den definieras kommer pickle att föredra den "
"framför :meth:`__reduce__`\\-metoden.  Dessutom blir :meth:`__reduce__` "
"automatiskt en synonym för den utökade versionen.  Huvudanvändningen för "
"denna metod är att tillhandahålla bakåtkompatibla reduce-värden för äldre "
"Python-versioner."

#: ../../library/pickle.rst:725
msgid "Persistence of External Objects"
msgstr "Persistens för externa objekt"

#: ../../library/pickle.rst:731
msgid ""
"For the benefit of object persistence, the :mod:`pickle` module supports the "
"notion of a reference to an object outside the pickled data stream.  Such "
"objects are referenced by a persistent ID, which should be either a string "
"of alphanumeric characters (for protocol 0) [#]_ or just an arbitrary object "
"(for any newer protocol)."
msgstr ""
"För att underlätta objektets beständighet stöder modulen :mod:`pickle` "
"begreppet referens till ett objekt utanför den betade dataströmmen.  Sådana "
"objekt refereras till med ett beständigt ID, som antingen bör vara en sträng "
"med alfanumeriska tecken (för protokoll 0) [#]_ eller bara ett godtyckligt "
"objekt (för alla nyare protokoll)."

#: ../../library/pickle.rst:737
msgid ""
"The resolution of such persistent IDs is not defined by the :mod:`pickle` "
"module; it will delegate this resolution to the user-defined methods on the "
"pickler and unpickler, :meth:`~Pickler.persistent_id` and :meth:`~Unpickler."
"persistent_load` respectively."
msgstr ""
"Upplösningen av sådana persistenta ID:n definieras inte av modulen :mod:"
"`pickle`; den delegerar denna upplösning till de användardefinierade "
"metoderna på picklern och unpickllern, :meth:`~Pickler.persistent_id` "
"respektive :meth:`~Unpickler.persistent_load`."

#: ../../library/pickle.rst:742
msgid ""
"To pickle objects that have an external persistent ID, the pickler must have "
"a custom :meth:`~Pickler.persistent_id` method that takes an object as an "
"argument and returns either ``None`` or the persistent ID for that object. "
"When ``None`` is returned, the pickler simply pickles the object as normal. "
"When a persistent ID string is returned, the pickler will pickle that "
"object, along with a marker so that the unpickler will recognize it as a "
"persistent ID."
msgstr ""
"För att plocka objekt som har ett externt beständigt ID måste plockaren ha "
"en egen :meth:`~Pickler.persistent_id`\\-metod som tar ett objekt som "
"argument och returnerar antingen ``None`` eller det beständiga ID:t för "
"objektet. När ``None`` returneras betar betaren helt enkelt objektet som "
"normalt. När en persistent ID-sträng returneras kommer picklern att pickla "
"det objektet, tillsammans med en markör så att unpickllern känner igen det "
"som ett persistent ID."

#: ../../library/pickle.rst:749
msgid ""
"To unpickle external objects, the unpickler must have a custom :meth:"
"`~Unpickler.persistent_load` method that takes a persistent ID object and "
"returns the referenced object."
msgstr ""
"För att unpickla externa objekt måste unpicklern ha en anpassad :meth:"
"`~Unpickler.persistent_load`\\-metod som tar ett persistent ID-objekt och "
"returnerar det refererade objektet."

#: ../../library/pickle.rst:753
msgid ""
"Here is a comprehensive example presenting how persistent ID can be used to "
"pickle external objects by reference."
msgstr ""
"Här följer ett omfattande exempel som visar hur persistent ID kan användas "
"för att plocka externa objekt genom referens."

#: ../../library/pickle.rst:761
msgid "Dispatch Tables"
msgstr "Expeditionsbord"

#: ../../library/pickle.rst:763
msgid ""
"If one wants to customize pickling of some classes without disturbing any "
"other code which depends on pickling, then one can create a pickler with a "
"private dispatch table."
msgstr ""
"Om man vill anpassa betningen av vissa klasser utan att störa någon annan "
"kod som är beroende av betningen, kan man skapa en betare med en privat "
"dispatch-tabell."

#: ../../library/pickle.rst:767
msgid ""
"The global dispatch table managed by the :mod:`copyreg` module is available "
"as :data:`copyreg.dispatch_table`.  Therefore, one may choose to use a "
"modified copy of :data:`copyreg.dispatch_table` as a private dispatch table."
msgstr ""

#: ../../library/pickle.rst:772
msgid "For example ::"
msgstr "Till exempel ::"

#: ../../library/pickle.rst:779
msgid ""
"creates an instance of :class:`pickle.Pickler` with a private dispatch table "
"which handles the ``SomeClass`` class specially.  Alternatively, the code ::"
msgstr ""
"skapar en instans av :class:`pickle.Pickler` med en privat dispatch-tabell "
"som hanterar klassen ``SomeClass`` speciellt.  Alternativt kan koden ::"

#: ../../library/pickle.rst:789
msgid ""
"does the same but all instances of ``MyPickler`` will by default share the "
"private dispatch table.  On the other hand, the code ::"
msgstr ""
"gör samma sak men alla instanser av ``MyPickler`` kommer som standard att "
"dela den privata dispatch-tabellen.  Å andra sidan, koden ::"

#: ../../library/pickle.rst:796
msgid ""
"modifies the global dispatch table shared by all users of the :mod:`copyreg` "
"module."
msgstr ""
"ändrar den globala fördelningstabellen som delas av alla användare av "
"modulen :mod:`copyreg`."

#: ../../library/pickle.rst:801
msgid "Handling Stateful Objects"
msgstr "Hantering av Stateful-objekt"

#: ../../library/pickle.rst:807
msgid ""
"Here's an example that shows how to modify pickling behavior for a class. "
"The :class:`TextReader` class opens a text file, and returns the line number "
"and line contents each time its :meth:`!readline` method is called. If a :"
"class:`TextReader` instance is pickled, all attributes *except* the file "
"object member are saved. When the instance is unpickled, the file is "
"reopened, and reading resumes from the last location. The :meth:"
"`__setstate__` and :meth:`__getstate__` methods are used to implement this "
"behavior. ::"
msgstr ""

#: ../../library/pickle.rst:853
msgid "A sample usage might be something like this::"
msgstr "Ett exempel på användning kan vara ungefär så här::"

#: ../../library/pickle.rst:867
msgid "Custom Reduction for Types, Functions, and Other Objects"
msgstr "Anpassad reduktion för typer, funktioner och andra objekt"

#: ../../library/pickle.rst:871
msgid ""
"Sometimes, :attr:`~Pickler.dispatch_table` may not be flexible enough. In "
"particular we may want to customize pickling based on another criterion than "
"the object's type, or we may want to customize the pickling of functions and "
"classes."
msgstr ""
"Ibland kanske :attr:`~Pickler.dispatch_table` inte är tillräckligt flexibel. "
"I synnerhet kanske vi vill anpassa betningen baserat på ett annat kriterium "
"än objektets typ, eller så kanske vi vill anpassa betningen av funktioner "
"och klasser."

#: ../../library/pickle.rst:876
msgid ""
"For those cases, it is possible to subclass from the :class:`Pickler` class "
"and implement a :meth:`~Pickler.reducer_override` method. This method can "
"return an arbitrary reduction tuple (see :meth:`__reduce__`). It can "
"alternatively return ``NotImplemented`` to fallback to the traditional "
"behavior."
msgstr ""

#: ../../library/pickle.rst:881
msgid ""
"If both the :attr:`~Pickler.dispatch_table` and :meth:`~Pickler."
"reducer_override` are defined, then :meth:`~Pickler.reducer_override` method "
"takes priority."
msgstr ""
"Om både :attr:`~Pickler.dispatch_table` och :meth:`~Pickler."
"reducer_override` är definierade, så har metoden :meth:`~Pickler."
"reducer_override` prioritet."

#: ../../library/pickle.rst:886
msgid ""
"For performance reasons, :meth:`~Pickler.reducer_override` may not be called "
"for the following objects: ``None``, ``True``, ``False``, and exact "
"instances of :class:`int`, :class:`float`, :class:`bytes`, :class:`str`, :"
"class:`dict`, :class:`set`, :class:`frozenset`, :class:`list` and :class:"
"`tuple`."
msgstr ""
"Av prestandaskäl får :meth:`~Pickler.reducer_override` inte anropas för "
"följande objekt: ``None``, ``True``, ``False`` och exakta instanser av :"
"class:`int`, :class:`float`, :class:`bytes`, :class:`str`, :class:`dict`, :"
"class:`set`, :class:`frozenset`, :class:`list` och :class:`tuple`."

#: ../../library/pickle.rst:892
msgid ""
"Here is a simple example where we allow pickling and reconstructing a given "
"class::"
msgstr ""
"Här är ett enkelt exempel där vi tillåter betning och rekonstruktion av en "
"given klass::"

#: ../../library/pickle.rst:927
msgid "Out-of-band Buffers"
msgstr "Buffertar utanför bandet"

#: ../../library/pickle.rst:931
msgid ""
"In some contexts, the :mod:`pickle` module is used to transfer massive "
"amounts of data.  Therefore, it can be important to minimize the number of "
"memory copies, to preserve performance and resource consumption.  However, "
"normal operation of the :mod:`pickle` module, as it transforms a graph-like "
"structure of objects into a sequential stream of bytes, intrinsically "
"involves copying data to and from the pickle stream."
msgstr ""
"I vissa sammanhang används modulen :mod:`pickle` för att överföra stora "
"mängder data.  Därför kan det vara viktigt att minimera antalet minneskopior "
"för att bevara prestanda och resursförbrukning.  Normal användning av "
"modulen :mod:`pickle`, som omvandlar en grafliknande struktur av objekt till "
"en sekventiell ström av bytes, innebär dock i sig att data kopieras till och "
"från pickle-strömmen."

#: ../../library/pickle.rst:938
msgid ""
"This constraint can be eschewed if both the *provider* (the implementation "
"of the object types to be transferred) and the *consumer* (the "
"implementation of the communications system) support the out-of-band "
"transfer facilities provided by pickle protocol 5 and higher."
msgstr ""
"Denna begränsning kan undvikas om både *provider* (implementationen av de "
"objekttyper som ska överföras) och *consumer* (implementationen av "
"kommunikationssystemet) stöder de överföringsmöjligheter utanför bandet som "
"tillhandahålls av pickle protocol 5 och högre."

#: ../../library/pickle.rst:944
msgid "Provider API"
msgstr "Leverantörs-API"

#: ../../library/pickle.rst:946
msgid ""
"The large data objects to be pickled must implement a :meth:`__reduce_ex__` "
"method specialized for protocol 5 and higher, which returns a :class:"
"`PickleBuffer` instance (instead of e.g. a :class:`bytes` object) for any "
"large data."
msgstr ""

#: ../../library/pickle.rst:951
msgid ""
"A :class:`PickleBuffer` object *signals* that the underlying buffer is "
"eligible for out-of-band data transfer.  Those objects remain compatible "
"with normal usage of the :mod:`pickle` module.  However, consumers can also "
"opt-in to tell :mod:`pickle` that they will handle those buffers by "
"themselves."
msgstr ""
"Ett :class:`PickleBuffer`\\-objekt *signalerar* att den underliggande "
"bufferten är kvalificerad för dataöverföring utanför bandet.  Dessa objekt "
"förblir kompatibla med normal användning av modulen :mod:`pickle`.  Men "
"konsumenter kan också välja att tala om för :mod:`pickle` att de kommer att "
"hantera dessa buffertar själva."

#: ../../library/pickle.rst:958
msgid "Consumer API"
msgstr "API för konsumenter"

#: ../../library/pickle.rst:960
msgid ""
"A communications system can enable custom handling of the :class:"
"`PickleBuffer` objects generated when serializing an object graph."
msgstr ""
"Ett kommunikationssystem kan möjliggöra anpassad hantering av :class:"
"`PickleBuffer`\\-objekt som genereras vid serialisering av en objektgraf."

#: ../../library/pickle.rst:963
msgid ""
"On the sending side, it needs to pass a *buffer_callback* argument to :class:"
"`Pickler` (or to the :func:`dump` or :func:`dumps` function), which will be "
"called with each :class:`PickleBuffer` generated while pickling the object "
"graph.  Buffers accumulated by the *buffer_callback* will not see their data "
"copied into the pickle stream, only a cheap marker will be inserted."
msgstr ""
"På sändningssidan måste den skicka ett *buffer_callback*-argument till :"
"class:`Pickler` (eller till :func:`dump` eller :func:`dumps`\\-funktionen), "
"som kommer att anropas med varje :class:`PickleBuffer` som genereras när "
"objektgrafen plockas.  Buffertar som ackumuleras av *buffer_callback* kommer "
"inte att få sina data kopierade till pickle-strömmen, endast en billig "
"markör kommer att infogas."

#: ../../library/pickle.rst:970
msgid ""
"On the receiving side, it needs to pass a *buffers* argument to :class:"
"`Unpickler` (or to the :func:`load` or :func:`loads` function), which is an "
"iterable of the buffers which were passed to *buffer_callback*. That "
"iterable should produce buffers in the same order as they were passed to "
"*buffer_callback*.  Those buffers will provide the data expected by the "
"reconstructors of the objects whose pickling produced the original :class:"
"`PickleBuffer` objects."
msgstr ""
"På mottagarsidan måste den skicka ett *buffers*-argument till :class:"
"`Unpickler` (eller till funktionen :func:`load` eller :func:`loads`), som är "
"en iterabel av de buffertar som skickades till *buffer_callback*. Denna "
"iterabel bör producera buffertar i samma ordning som de skickades till "
"*buffer_callback*.  Dessa buffertar kommer att tillhandahålla de data som "
"förväntas av rekonstruktörerna av de objekt vars betning producerade de "
"ursprungliga :class:`PickleBuffer`\\-objekten."

#: ../../library/pickle.rst:978
msgid ""
"Between the sending side and the receiving side, the communications system "
"is free to implement its own transfer mechanism for out-of-band buffers. "
"Potential optimizations include the use of shared memory or datatype-"
"dependent compression."
msgstr ""
"Mellan sändar- och mottagarsidan är kommunikationssystemet fritt att "
"implementera sin egen överföringsmekanism för buffertar utanför bandet. "
"Potentiella optimeringar inkluderar användning av delat minne eller "
"datatypberoende komprimering."

#: ../../library/pickle.rst:984
msgid "Example"
msgstr "Exempel"

#: ../../library/pickle.rst:986
msgid ""
"Here is a trivial example where we implement a :class:`bytearray` subclass "
"able to participate in out-of-band buffer pickling::"
msgstr ""
"Här är ett trivialt exempel där vi implementerar en :class:`bytearray`\\-"
"underklass som kan delta i buffer pickling utanför bandet::"

#: ../../library/pickle.rst:1010
msgid ""
"The reconstructor (the ``_reconstruct`` class method) returns the buffer's "
"providing object if it has the right type.  This is an easy way to simulate "
"zero-copy behaviour on this toy example."
msgstr ""
"Rekonstruktören (klassmetoden ``_reconstruct``) returnerar buffertens "
"tillhandahållande objekt om det har rätt typ.  Detta är ett enkelt sätt att "
"simulera nollkopieringsbeteende i detta leksaksexempel."

#: ../../library/pickle.rst:1014
msgid ""
"On the consumer side, we can pickle those objects the usual way, which when "
"unserialized will give us a copy of the original object::"
msgstr ""
"På konsumentsidan kan vi plocka upp dessa objekt på vanligt sätt, vilket när "
"det är oserialiserat ger oss en kopia av det ursprungliga objektet::"

#: ../../library/pickle.rst:1023
msgid ""
"But if we pass a *buffer_callback* and then give back the accumulated "
"buffers when unserializing, we are able to get back the original object::"
msgstr ""
"Men om vi skickar en *buffer_callback* och sedan ger tillbaka de "
"ackumulerade buffertarna när vi unserialiserar, kan vi få tillbaka det "
"ursprungliga objektet::"

#: ../../library/pickle.rst:1033
msgid ""
"This example is limited by the fact that :class:`bytearray` allocates its "
"own memory: you cannot create a :class:`bytearray` instance that is backed "
"by another object's memory.  However, third-party datatypes such as NumPy "
"arrays do not have this limitation, and allow use of zero-copy pickling (or "
"making as few copies as possible) when transferring between distinct "
"processes or systems."
msgstr ""
"Detta exempel begränsas av det faktum att :class:`bytearray` allokerar sitt "
"eget minne: du kan inte skapa en :class:`bytearray`\\-instans som backas upp "
"av ett annat objekts minne.  Tredjepartsdatatyper som NumPy-arrays har dock "
"inte denna begränsning och tillåter användning av zero-copy pickling (eller "
"att göra så få kopior som möjligt) vid överföring mellan olika processer "
"eller system."

#: ../../library/pickle.rst:1040
msgid ":pep:`574` -- Pickle protocol 5 with out-of-band data"
msgstr ":pep:`574` -- Pickle protokoll 5 med data utanför bandet"

#: ../../library/pickle.rst:1046
msgid "Restricting Globals"
msgstr "Begränsning av globaler"

#: ../../library/pickle.rst:1051
msgid ""
"By default, unpickling will import any class or function that it finds in "
"the pickle data.  For many applications, this behaviour is unacceptable as "
"it permits the unpickler to import and invoke arbitrary code.  Just consider "
"what this hand-crafted pickle data stream does when loaded::"
msgstr ""
"Som standard importerar unpickling alla klasser eller funktioner som den "
"hittar i pickle-data.  För många applikationer är detta beteende "
"oacceptabelt eftersom det tillåter unpickling att importera och anropa "
"godtycklig kod.  Tänk bara på vad den här handgjorda pickle-dataströmmen gör "
"när den laddas::"

#: ../../library/pickle.rst:1061
msgid ""
"In this example, the unpickler imports the :func:`os.system` function and "
"then apply the string argument \"echo hello world\".  Although this example "
"is inoffensive, it is not difficult to imagine one that could damage your "
"system."
msgstr ""
"I det här exemplet importerar unpickler funktionen :func:`os.system` och "
"använder sedan strängargumentet \"echo hello world\".  Även om detta exempel "
"är ofarligt är det inte svårt att föreställa sig ett exempel som kan skada "
"ditt system."

#: ../../library/pickle.rst:1065
msgid ""
"For this reason, you may want to control what gets unpickled by customizing :"
"meth:`Unpickler.find_class`.  Unlike its name suggests, :meth:`Unpickler."
"find_class` is called whenever a global (i.e., a class or a function) is "
"requested.  Thus it is possible to either completely forbid globals or "
"restrict them to a safe subset."
msgstr ""
"Av denna anledning kanske du vill kontrollera vad som blir unpickled genom "
"att anpassa :meth:`Unpickler.find_class`.  Till skillnad från vad namnet "
"antyder anropas :meth:`Unpickler.find_class` när en global (dvs. en klass "
"eller en funktion) begärs.  Det är alltså möjligt att antingen helt förbjuda "
"globaler eller begränsa dem till en säker delmängd."

#: ../../library/pickle.rst:1071
msgid ""
"Here is an example of an unpickler allowing only few safe classes from the :"
"mod:`builtins` module to be loaded::"
msgstr ""
"Här är ett exempel på en unpickler som tillåter att endast ett fåtal säkra "
"klasser från modulen :mod:`builtins` laddas::"

#: ../../library/pickle.rst:1100
msgid "A sample usage of our unpickler working as intended::"
msgstr "Ett exempel på användning av vår unpickler som fungerar som avsett::"

#: ../../library/pickle.rst:1119
msgid ""
"As our examples shows, you have to be careful with what you allow to be "
"unpickled.  Therefore if security is a concern, you may want to consider "
"alternatives such as the marshalling API in :mod:`xmlrpc.client` or third-"
"party solutions."
msgstr ""
"Som våra exempel visar måste du vara försiktig med vad du tillåter att bli "
"unpickled.  Om säkerhet är ett problem kan du därför överväga alternativ som "
"marshalling API i :mod:`xmlrpc.client` eller tredjepartslösningar."

#: ../../library/pickle.rst:1126
msgid "Performance"
msgstr "Prestanda"

#: ../../library/pickle.rst:1128
msgid ""
"Recent versions of the pickle protocol (from protocol 2 and upwards) feature "
"efficient binary encodings for several common features and built-in types. "
"Also, the :mod:`pickle` module has a transparent optimizer written in C."
msgstr ""
"De senaste versionerna av pickle-protokollet (från protokoll 2 och uppåt) "
"har effektiva binära kodningar för flera vanliga funktioner och inbyggda "
"typer. Dessutom har modulen :mod:`pickle` en transparent optimerare skriven "
"i C."

#: ../../library/pickle.rst:1136
msgid "Examples"
msgstr "Exempel"

#: ../../library/pickle.rst:1138
msgid ""
"For the simplest code, use the :func:`dump` and :func:`load` functions. ::"
msgstr ""
"För den enklaste koden, använd funktionerna :func:`dump` och :func:`load`. ::"

#: ../../library/pickle.rst:1154
msgid "The following example reads the resulting pickled data. ::"
msgstr "I följande exempel läses den resulterande picklade datan. ::"

#: ../../library/pickle.rst:1171
msgid "Module :mod:`copyreg`"
msgstr "Modul :mod:`copyreg`"

#: ../../library/pickle.rst:1171
msgid "Pickle interface constructor registration for extension types."
msgstr "Registrering av Pickle-gränssnittskonstruktörer för tilläggstyper."

#: ../../library/pickle.rst:1174
msgid "Module :mod:`pickletools`"
msgstr "Modul :mod:`pickletools`"

#: ../../library/pickle.rst:1174
msgid "Tools for working with and analyzing pickled data."
msgstr "Verktyg för att arbeta med och analysera betade data."

#: ../../library/pickle.rst:1177
msgid "Module :mod:`shelve`"
msgstr "Modul :mod:`shelve`"

#: ../../library/pickle.rst:1177
msgid "Indexed databases of objects; uses :mod:`pickle`."
msgstr "Indexerade databaser med objekt; använder :mod:`pickle`."

#: ../../library/pickle.rst:1180
msgid "Module :mod:`copy`"
msgstr "Modul :mod:`copy`"

#: ../../library/pickle.rst:1180
msgid "Shallow and deep object copying."
msgstr "Kopiering av grunda och djupa objekt."

#: ../../library/pickle.rst:1182
msgid "Module :mod:`marshal`"
msgstr "Modul :mod:`marshal`"

#: ../../library/pickle.rst:1183
msgid "High-performance serialization of built-in types."
msgstr "Högpresterande serialisering av inbyggda typer."

#: ../../library/pickle.rst:1187
msgid "Footnotes"
msgstr "Fotnoter"

#: ../../library/pickle.rst:1188
msgid "Don't confuse this with the :mod:`marshal` module"
msgstr "Förväxla inte detta med modulen :mod:`marshal`"

#: ../../library/pickle.rst:1190
msgid ""
"This is why :keyword:`lambda` functions cannot be pickled:  all :keyword:`!"
"lambda` functions share the same name:  ``<lambda>``."
msgstr ""
"Det är därför som :keyword:`lambda` funktioner inte kan picklas: alla :"
"keyword:`!lambda` funktioner har samma namn: ``<lambda>``."

#: ../../library/pickle.rst:1193
msgid ""
"The exception raised will likely be an :exc:`ImportError` or an :exc:"
"`AttributeError` but it could be something else."
msgstr ""
"Det undantag som tas upp kommer troligen att vara ett :exc:`ImportError` "
"eller ett :exc:`AttributeError`, men det kan vara något annat."

#: ../../library/pickle.rst:1196
msgid ""
"The :mod:`copy` module uses this protocol for shallow and deep copying "
"operations."
msgstr ""
"Modulen :mod:`copy` använder detta protokoll för ytliga och djupa "
"kopieringsoperationer."

#: ../../library/pickle.rst:1199
msgid ""
"The limitation on alphanumeric characters is due to the fact that persistent "
"IDs in protocol 0 are delimited by the newline character.  Therefore if any "
"kind of newline characters occurs in persistent IDs, the resulting pickled "
"data will become unreadable."
msgstr ""
"Begränsningen av alfanumeriska tecken beror på att beständiga ID i protokoll "
"0 avgränsas av tecknet newline.  Om det förekommer någon form av tecken för "
"nya rader i beständiga ID:n blir därför de betade data som blir resultatet "
"oläsliga."
