# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Daniel Nylander <po@danielnylander.se>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-05 14:23+0000\n"
"PO-Revision-Date: 2025-07-18 18:48+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../faq/library.rst:5
msgid "Library and Extension FAQ"
msgstr "Frågor och svar om biblioteket och extension"

#: ../../faq/library.rst:8
msgid "Contents"
msgstr "Innehåll"

#: ../../faq/library.rst:12
msgid "General Library Questions"
msgstr "Allmänna frågor om biblioteket"

#: ../../faq/library.rst:15
msgid "How do I find a module or application to perform task X?"
msgstr "Hur hittar jag en modul eller applikation för att utföra uppgift X?"

#: ../../faq/library.rst:17
msgid ""
"Check :ref:`the Library Reference <library-index>` to see if there's a "
"relevant standard library module.  (Eventually you'll learn what's in the "
"standard library and will be able to skip this step.)"
msgstr ""
"Kontrollera :ref:``the Library Reference <library-index>`` för att se om det"
" finns en relevant modul i standardbiblioteket.  (Så småningom lär du dig "
"vad som finns i standardbiblioteket och kan då hoppa över det här steget)"

#: ../../faq/library.rst:21
msgid ""
"For third-party packages, search the `Python Package Index "
"<https://pypi.org>`_ or try `Google <https://www.google.com>`_ or another "
"web search engine.  Searching for \"Python\" plus a keyword or two for your "
"topic of interest will usually find something helpful."
msgstr ""
"För tredjepartspaket, sök i `Python Package Index <https://pypi.org>`_ eller"
" prova `Google <https://www.google.com>`_ eller en annan webbsökmotor.  Om "
"du söker efter \"Python\" plus ett eller två nyckelord för det ämne du är "
"intresserad av hittar du vanligtvis något användbart."

#: ../../faq/library.rst:28
msgid "Where is the math.py (socket.py, regex.py, etc.) source file?"
msgstr "Var är källfilen math.py (socket.py, regex.py, etc.)?"

#: ../../faq/library.rst:30
msgid ""
"If you can't find a source file for a module it may be a built-in or "
"dynamically loaded module implemented in C, C++ or other compiled language. "
"In this case you may not have the source file or it may be something like "
":file:`mathmodule.c`, somewhere in a C source directory (not on the Python "
"Path)."
msgstr ""
"Om du inte kan hitta en källfil för en modul kan det vara en inbyggd eller "
"dynamiskt laddad modul som implementerats i C, C++ eller annat kompilerat "
"språk. I det här fallet kanske du inte har källfilen eller så kan den vara "
"något i stil med :file:`mathmodule.c`, någonstans i en C-källkatalog (inte "
"på Python Path)."

#: ../../faq/library.rst:35
msgid "There are (at least) three kinds of modules in Python:"
msgstr "Det finns (minst) tre olika typer av moduler i Python:"

#: ../../faq/library.rst:37
msgid "modules written in Python (.py);"
msgstr "moduler skrivna i Python (.py);"

#: ../../faq/library.rst:38
msgid ""
"modules written in C and dynamically loaded (.dll, .pyd, .so, .sl, etc);"
msgstr ""
"moduler skrivna i C och dynamiskt laddade (.dll, .pyd, .so, .sl, etc);"

#: ../../faq/library.rst:39
msgid ""
"modules written in C and linked with the interpreter; to get a list of "
"these, type::"
msgstr ""
"moduler skrivna i C och länkade med tolken; för att få en lista över dessa, "
"skriv::"

#: ../../faq/library.rst:42
msgid ""
"import sys\n"
"print(sys.builtin_module_names)"
msgstr ""
"importera sys\n"
"print(sys.namn_på_byggda_moduler)"

#: ../../faq/library.rst:47
msgid "How do I make a Python script executable on Unix?"
msgstr "Hur gör jag ett Python-skript körbart på Unix?"

#: ../../faq/library.rst:49
msgid ""
"You need to do two things: the script file's mode must be executable and the"
" first line must begin with ``#!`` followed by the path of the Python "
"interpreter."
msgstr ""
"Du måste göra två saker: skriptfilens läge måste vara exekverbart och den "
"första raden måste börja med ``#!`` följt av sökvägen till Python-tolken."

#: ../../faq/library.rst:53
msgid ""
"The first is done by executing ``chmod +x scriptfile`` or perhaps ``chmod "
"755 scriptfile``."
msgstr ""
"Det första görs genom att köra ``chmod +x scriptfile`` eller kanske ``chmod "
"755 scriptfile``."

#: ../../faq/library.rst:56
msgid ""
"The second can be done in a number of ways.  The most straightforward way is"
" to write ::"
msgstr ""
"Det andra kan göras på ett antal olika sätt.  Det mest okomplicerade sättet "
"är att skriva ::"

#: ../../faq/library.rst:59
msgid "#!/usr/local/bin/python"
msgstr "#!/usr/local/bin/python"

#: ../../faq/library.rst:61
msgid ""
"as the very first line of your file, using the pathname for where the Python"
" interpreter is installed on your platform."
msgstr ""
"som den allra första raden i din fil, med sökvägen till den plats där "
"Python-tolken är installerad på din plattform."

#: ../../faq/library.rst:64
msgid ""
"If you would like the script to be independent of where the Python "
"interpreter lives, you can use the :program:`env` program.  Almost all Unix "
"variants support the following, assuming the Python interpreter is in a "
"directory on the user's :envvar:`PATH`::"
msgstr ""
"Om du vill att skriptet ska vara oberoende av var Python-tolken finns, kan "
"du använda programmet :program:`env`.  Nästan alla Unix-varianter stöder "
"följande, förutsatt att Python-tolken finns i en katalog på användarens "
":envvar:`PATH`::"

#: ../../faq/library.rst:69
msgid "#!/usr/bin/env python"
msgstr "#!/usr/bin/env python"

#: ../../faq/library.rst:71
msgid ""
"*Don't* do this for CGI scripts.  The :envvar:`PATH` variable for CGI "
"scripts is often very minimal, so you need to use the actual absolute "
"pathname of the interpreter."
msgstr ""
"*Gör inte* detta för CGI-skript.  Variabeln :envvar:`PATH` för CGI-skript är"
" ofta mycket minimal, så du måste använda det faktiska absoluta "
"sökvägsnamnet för tolken."

#: ../../faq/library.rst:75
msgid ""
"Occasionally, a user's environment is so full that the "
":program:`/usr/bin/env` program fails; or there's no env program at all.  In"
" that case, you can try the following hack (due to Alex Rezinsky):"
msgstr ""
"Ibland är en användares miljö så full att programmet :program:`/usr/bin/env`"
" misslyckas; eller så finns det inget env-program alls.  I så fall kan du "
"prova följande hack (tack vare Alex Rezinsky):"

#: ../../faq/library.rst:79
msgid ""
"#! /bin/sh\n"
"\"\"\":\"\n"
"exec python $0 ${1+\"$@\"}\n"
"\"\"\""
msgstr ""
"#! /bin/sh\n"
"\"\"\":\"\n"
"exekvera python $0 ${1+\"$@\"}\n"
"\"\"\""

#: ../../faq/library.rst:86
msgid ""
"The minor disadvantage is that this defines the script's __doc__ string. "
"However, you can fix that by adding ::"
msgstr ""
"Den lilla nackdelen är att detta definierar skriptets __doc__-sträng. Du kan"
" dock åtgärda det genom att lägga till ::"

#: ../../faq/library.rst:89
msgid "__doc__ = \"\"\"...Whatever...\"\"\""
msgstr "__doc__ = \"\"\"...Vad som helst...\"\"\""

#: ../../faq/library.rst:94
msgid "Is there a curses/termcap package for Python?"
msgstr "Finns det ett curses/termcap-paket för Python?"

#: ../../faq/library.rst:98
msgid ""
"For Unix variants: The standard Python source distribution comes with a "
"curses module in the :source:`Modules` subdirectory, though it's not "
"compiled by default. (Note that this is not available in the Windows "
"distribution -- there is no curses module for Windows.)"
msgstr ""
"För Unix-varianter: Standarddistributionen av Python-källkod innehåller en "
"curses-modul i underkatalogen :source:`Modules`, men den är inte kompilerad "
"som standard. (Observera att detta inte är tillgängligt i Windows-"
"distributionen - det finns ingen curses-modul för Windows)"

#: ../../faq/library.rst:103
msgid ""
"The :mod:`curses` module supports basic curses features as well as many "
"additional functions from ncurses and SYSV curses such as colour, "
"alternative character set support, pads, and mouse support. This means the "
"module isn't compatible with operating systems that only have BSD curses, "
"but there don't seem to be any currently maintained OSes that fall into this"
" category."
msgstr ""
"Modulen :mod:`curses` stöder de grundläggande funktionerna i curses samt "
"många ytterligare funktioner från ncurses och SYSV curses, t.ex. färg, stöd "
"för alternativa teckenuppsättningar, block och musstöd. Detta innebär att "
"modulen inte är kompatibel med operativsystem som endast har BSD curses, men"
" det verkar inte finnas några operativsystem som för närvarande underhålls "
"som faller inom denna kategori."

#: ../../faq/library.rst:111
msgid "Is there an equivalent to C's onexit() in Python?"
msgstr "Finns det en motsvarighet till C:s onexit() i Python?"

#: ../../faq/library.rst:113
msgid ""
"The :mod:`atexit` module provides a register function that is similar to C's"
" :c:func:`!onexit`."
msgstr ""
"Modulen :mod:`atexit` tillhandahåller en registerfunktion som liknar C:s "
":c:func:`!onexit`."

#: ../../faq/library.rst:118
msgid "Why don't my signal handlers work?"
msgstr "Varför fungerar inte mina signalhanterare?"

#: ../../faq/library.rst:120
msgid ""
"The most common problem is that the signal handler is declared with the "
"wrong argument list.  It is called as ::"
msgstr ""
"Det vanligaste problemet är att signalhanteraren deklareras med fel "
"argumentlista.  Det kallas som ::"

#: ../../faq/library.rst:123
msgid "handler(signum, frame)"
msgstr "handler(signum, ram)"

#: ../../faq/library.rst:125
msgid "so it should be declared with two parameters::"
msgstr "så den bör deklareras med två parametrar::"

#: ../../faq/library.rst:127
msgid ""
"def handler(signum, frame):\n"
"    ..."
msgstr ""
"def handler(signum, ram):\n"
"    ..."

#: ../../faq/library.rst:132
msgid "Common tasks"
msgstr "Vanliga uppgifter"

#: ../../faq/library.rst:135
msgid "How do I test a Python program or component?"
msgstr "Hur testar jag ett Python-program eller en Python-komponent?"

#: ../../faq/library.rst:137
msgid ""
"Python comes with two testing frameworks.  The :mod:`doctest` module finds "
"examples in the docstrings for a module and runs them, comparing the output "
"with the expected output given in the docstring."
msgstr ""
"Python levereras med två testramverk.  Modulen :mod:`doctest` hittar exempel"
" i dokumentationen för en modul, kör dem och jämför resultatet med det "
"förväntade resultatet som anges i dokumentationen."

#: ../../faq/library.rst:141
msgid ""
"The :mod:`unittest` module is a fancier testing framework modelled on Java "
"and Smalltalk testing frameworks."
msgstr ""
"Modulen :mod:`unittest` är ett mer avancerat testramverk som bygger på "
"testramverken för Java och Smalltalk."

#: ../../faq/library.rst:144
msgid ""
"To make testing easier, you should use good modular design in your program. "
"Your program should have almost all functionality encapsulated in either "
"functions or class methods -- and this sometimes has the surprising and "
"delightful effect of making the program run faster (because local variable "
"accesses are faster than global accesses).  Furthermore the program should "
"avoid depending on mutating global variables, since this makes testing much "
"more difficult to do."
msgstr ""
"För att göra testningen enklare bör du använda en bra modulär design i ditt "
"program. Programmet bör ha nästan all funktionalitet inkapslad i antingen "
"funktioner eller klassmetoder -- och detta har ibland den överraskande och "
"förtjusande effekten att programmet körs snabbare (eftersom lokala "
"variabelåtkomster är snabbare än globala åtkomster).  Dessutom bör "
"programmet undvika att vara beroende av muterande globala variabler, "
"eftersom detta gör testning mycket svårare att genomföra."

#: ../../faq/library.rst:152
msgid "The \"global main logic\" of your program may be as simple as ::"
msgstr "Den \"globala huvudlogiken\" i ditt program kan vara så enkel som ::"

#: ../../faq/library.rst:154
msgid ""
"if __name__ == \"__main__\":\n"
"    main_logic()"
msgstr ""
"om __name__ == \"__main__\":\n"
"    main_logic()"

#: ../../faq/library.rst:157
msgid "at the bottom of the main module of your program."
msgstr "längst ner i huvudmodulen i ditt program."

#: ../../faq/library.rst:159
msgid ""
"Once your program is organized as a tractable collection of function and "
"class behaviours, you should write test functions that exercise the "
"behaviours.  A test suite that automates a sequence of tests can be "
"associated with each module. This sounds like a lot of work, but since "
"Python is so terse and flexible it's surprisingly easy.  You can make coding"
" much more pleasant and fun by writing your test functions in parallel with "
"the \"production code\", since this makes it easy to find bugs and even "
"design flaws earlier."
msgstr ""
"När ditt program är organiserat som en hanterbar samling funktions- och "
"klassbeteenden bör du skriva testfunktioner som utövar beteendena.  En "
"testsvit som automatiserar en sekvens av tester kan associeras med varje "
"modul. Det här låter som en massa arbete, men eftersom Python är så "
"kortfattat och flexibelt är det förvånansvärt enkelt.  Du kan göra kodningen"
" mycket trevligare och roligare genom att skriva dina testfunktioner "
"parallellt med \"produktionskoden\", eftersom det gör det lätt att hitta "
"buggar och till och med designfel tidigare."

#: ../../faq/library.rst:167
msgid ""
"\"Support modules\" that are not intended to be the main module of a program"
" may include a self-test of the module. ::"
msgstr ""
"\"Stödmoduler\" som inte är avsedda att vara huvudmodulen i ett program kan "
"innehålla ett självtest av modulen:"

#: ../../faq/library.rst:170
msgid ""
"if __name__ == \"__main__\":\n"
"    self_test()"
msgstr ""
"if __name__ == \"__main__\":\n"
"    self_test()"

#: ../../faq/library.rst:173
msgid ""
"Even programs that interact with complex external interfaces may be tested "
"when the external interfaces are unavailable by using \"fake\" interfaces "
"implemented in Python."
msgstr ""
"Även program som interagerar med komplexa externa gränssnitt kan testas när "
"de externa gränssnitten inte är tillgängliga genom att använda \"falska\" "
"gränssnitt som implementerats i Python."

#: ../../faq/library.rst:179
msgid "How do I create documentation from doc strings?"
msgstr "Hur skapar jag dokumentation från dokumentsträngar?"

#: ../../faq/library.rst:181
msgid ""
"The :mod:`pydoc` module can create HTML from the doc strings in your Python "
"source code.  An alternative for creating API documentation purely from "
"docstrings is `epydoc <https://epydoc.sourceforge.net/>`_.  `Sphinx "
"<https://www.sphinx-doc.org>`_ can also include docstring content."
msgstr ""
"Modulen :mod:`pydoc` kan skapa HTML från doc-strängarna i din Python-"
"källkod.  Ett alternativ för att skapa API-dokumentation enbart från "
"docstrings är `epydoc <https://epydoc.sourceforge.net/>`_.  `Sphinx "
"<https://www.sphinx-doc.org>`_ kan också inkludera innehåll från docstrings."

#: ../../faq/library.rst:188
msgid "How do I get a single keypress at a time?"
msgstr "Hur får jag en enda knapptryckning i taget?"

#: ../../faq/library.rst:190
msgid ""
"For Unix variants there are several solutions.  It's straightforward to do "
"this using curses, but curses is a fairly large module to learn."
msgstr ""
"För Unix-varianter finns det flera lösningar.  Det är enkelt att göra detta "
"med hjälp av curses, men curses är en ganska stor modul att lära sig."

#: ../../faq/library.rst:234
msgid "Threads"
msgstr "Trådar"

#: ../../faq/library.rst:237
msgid "How do I program using threads?"
msgstr "Hur programmerar jag med trådar?"

#: ../../faq/library.rst:239
msgid ""
"Be sure to use the :mod:`threading` module and not the :mod:`_thread` "
"module. The :mod:`threading` module builds convenient abstractions on top of"
" the low-level primitives provided by the :mod:`_thread` module."
msgstr ""
"Var noga med att använda modulen :mod:`threading` och inte modulen "
":mod:`_thread`. Modulen :mod:`threading` bygger praktiska abstraktioner "
"ovanpå de primitiver på låg nivå som tillhandahålls av modulen "
":mod:`_thread`."

#: ../../faq/library.rst:245
msgid "None of my threads seem to run: why?"
msgstr "Ingen av mina trådar verkar köras: varför?"

#: ../../faq/library.rst:247
msgid ""
"As soon as the main thread exits, all threads are killed.  Your main thread "
"is running too quickly, giving the threads no time to do any work."
msgstr ""
"Så snart huvudtråden avslutas dödas alla trådar.  Din huvudtråd körs för "
"snabbt, vilket gör att trådarna inte hinner göra något arbete."

#: ../../faq/library.rst:250
msgid ""
"A simple fix is to add a sleep to the end of the program that's long enough "
"for all the threads to finish::"
msgstr ""
"En enkel lösning är att lägga till en sleep i slutet av programmet som är "
"tillräckligt lång för att alla trådar ska hinna bli klara:"

#: ../../faq/library.rst:253
msgid ""
"import threading, time\n"
"\n"
"def thread_task(name, n):\n"
"    for i in range(n):\n"
"        print(name, i)\n"
"\n"
"for i in range(10):\n"
"    T = threading.Thread(target=thread_task, args=(str(i), i))\n"
"    T.start()\n"
"\n"
"time.sleep(10)  # <---------------------------!"
msgstr ""
"import gängning, tid\n"
"\n"
"def thread_task(namn, n):\n"
"    för i i intervall(n):\n"
"        print(namn, i)\n"
"\n"
"för i inom intervallet(10):\n"
"    T = threading.Thread(target=thread_task, args=(str(i), i))\n"
"    T.start()\n"
"\n"
"time.sleep(10) # <---------------------------!"

#: ../../faq/library.rst:265
msgid ""
"But now (on many platforms) the threads don't run in parallel, but appear to"
" run sequentially, one at a time!  The reason is that the OS thread "
"scheduler doesn't start a new thread until the previous thread is blocked."
msgstr ""
"Men nu (på många plattformar) körs trådarna inte parallellt, utan verkar "
"köras sekventiellt, en i taget!  Anledningen är att OS:ets trådschemaläggare"
" inte startar en ny tråd förrän den föregående tråden har blockerats."

#: ../../faq/library.rst:269
msgid "A simple fix is to add a tiny sleep to the start of the run function::"
msgstr ""
"En enkel lösning är att lägga till en liten sömn i början av körfunktionen::"

#: ../../faq/library.rst:271
msgid ""
"def thread_task(name, n):\n"
"    time.sleep(0.001)  # <--------------------!\n"
"    for i in range(n):\n"
"        print(name, i)\n"
"\n"
"for i in range(10):\n"
"    T = threading.Thread(target=thread_task, args=(str(i), i))\n"
"    T.start()\n"
"\n"
"time.sleep(10)"
msgstr ""
"def thread_task(namn, n):\n"
"    time.sleep(0.001) # <--------------------!\n"
"    för i i intervallet(n):\n"
"        print(namn, i)\n"
"\n"
"för i i intervallet(10):\n"
"    T = threading.Thread(target=thread_task, args=(str(i), i))\n"
"    T.start()\n"
"\n"
"tid.sömn(10)"

#: ../../faq/library.rst:282
msgid ""
"Instead of trying to guess a good delay value for :func:`time.sleep`, it's "
"better to use some kind of semaphore mechanism.  One idea is to use the "
":mod:`queue` module to create a queue object, let each thread append a token"
" to the queue when it finishes, and let the main thread read as many tokens "
"from the queue as there are threads."
msgstr ""
"Istället för att försöka gissa ett bra fördröjningsvärde för "
":func:`time.sleep` är det bättre att använda någon form av semaformekanism."
"  En idé är att använda modulen :mod:`queue` för att skapa ett köobjekt, "
"låta varje tråd lägga till en token till kön när den är klar och låta "
"huvudtråden läsa så många tokens från kön som det finns trådar."

#: ../../faq/library.rst:290
msgid "How do I parcel out work among a bunch of worker threads?"
msgstr "Hur delar jag upp arbetet mellan ett antal arbetstrådar?"

#: ../../faq/library.rst:292
msgid ""
"The easiest way is to use the :mod:`concurrent.futures` module, especially "
"the :mod:`~concurrent.futures.ThreadPoolExecutor` class."
msgstr ""
"Det enklaste sättet är att använda modulen :mod:`concurrent.futures`, "
"särskilt klassen :mod:`~concurrent.futures.ThreadPoolExecutor`."

#: ../../faq/library.rst:295
msgid ""
"Or, if you want fine control over the dispatching algorithm, you can write "
"your own logic manually.  Use the :mod:`queue` module to create a queue "
"containing a list of jobs.  The :class:`~queue.Queue` class maintains a list"
" of objects and has a ``.put(obj)`` method that adds items to the queue and "
"a ``.get()`` method to return them.  The class will take care of the locking"
" necessary to ensure that each job is handed out exactly once."
msgstr ""
"Eller, om du vill ha fin kontroll över dispatching-algoritmen, kan du skriva"
" din egen logik manuellt.  Använd modulen :mod:`queue` för att skapa en kö "
"som innehåller en lista med jobb.  Klassen :class:`~queue.Queue` underhåller"
" en lista med objekt och har en metod ``.put(obj)`` som lägger till objekt i"
" kön och en metod ``.get()`` som returnerar dem.  Klassen tar hand om den "
"låsning som krävs för att säkerställa att varje jobb delas ut exakt en gång."

#: ../../faq/library.rst:302
msgid "Here's a trivial example::"
msgstr "Här är ett trivialt exempel::"

#: ../../faq/library.rst:304
msgid ""
"import threading, queue, time\n"
"\n"
"# The worker thread gets jobs off the queue.  When the queue is empty, it\n"
"# assumes there will be no more work and exits.\n"
"# (Realistically workers will run until terminated.)\n"
"def worker():\n"
"    print('Running worker')\n"
"    time.sleep(0.1)\n"
"    while True:\n"
"        try:\n"
"            arg = q.get(block=False)\n"
"        except queue.Empty:\n"
"            print('Worker', threading.current_thread(), end=' ')\n"
"            print('queue empty')\n"
"            break\n"
"        else:\n"
"            print('Worker', threading.current_thread(), end=' ')\n"
"            print('running with argument', arg)\n"
"            time.sleep(0.5)\n"
"\n"
"# Create queue\n"
"q = queue.Queue()\n"
"\n"
"# Start a pool of 5 workers\n"
"for i in range(5):\n"
"    t = threading.Thread(target=worker, name='worker %i' % (i+1))\n"
"    t.start()\n"
"\n"
"# Begin adding work to the queue\n"
"for i in range(50):\n"
"    q.put(i)\n"
"\n"
"# Give threads time to run\n"
"print('Main thread sleeping')\n"
"time.sleep(5)"
msgstr ""
"import trådning, kö, tid\n"
"\n"
"# Arbetartråden tar bort jobb från kön.  När kön är tom antar den\n"
"# antar den att det inte kommer att finnas mer arbete och avslutas.\n"
"# (Realistiskt sett körs arbetare tills de avslutas.)\n"
"def arbetare():\n"
"    print('Kör arbetare')\n"
"    time.sleep(0.1)\n"
"    medan True:\n"
"        try:\n"
"            arg = q.get(block=False)\n"
"        except queue.Empty:\n"
"            print('Worker', threading.current_thread(), end=' ')\n"
"            print('kö tom')\n"
"            break\n"
"        annars:\n"
"            print('Worker', threading.current_thread(), end=' ')\n"
"            print('kör med argument', arg)\n"
"            tid.sömn(0.5)\n"
"\n"
"# Skapa kö\n"
"q = queue.Queue()\n"
"\n"
"# Starta en pool med 5 arbetare\n"
"för i i intervallet(5):\n"
"    t = threading.Thread(target=arbetare, name='arbetare %i' % (i+1))\n"
"    t.start()\n"
"\n"
"# Börja lägga till arbete i kön\n"
"för i i intervallet(50):\n"
"    q.put(i)\n"
"\n"
"# Ge trådarna tid att köra\n"
"print('Huvudtråden sover')\n"
"time.sleep(5)"

#: ../../faq/library.rst:340
msgid "When run, this will produce the following output:"
msgstr "När detta körs kommer det att ge följande resultat:"

#: ../../faq/library.rst:342
msgid ""
"Running worker\n"
"Running worker\n"
"Running worker\n"
"Running worker\n"
"Running worker\n"
"Main thread sleeping\n"
"Worker <Thread(worker 1, started 130283832797456)> running with argument 0\n"
"Worker <Thread(worker 2, started 130283824404752)> running with argument 1\n"
"Worker <Thread(worker 3, started 130283816012048)> running with argument 2\n"
"Worker <Thread(worker 4, started 130283807619344)> running with argument 3\n"
"Worker <Thread(worker 5, started 130283799226640)> running with argument 4\n"
"Worker <Thread(worker 1, started 130283832797456)> running with argument 5\n"
"..."
msgstr ""
"Löpande arbetare\n"
"Löpande arbetare\n"
"Löpande arbetare\n"
"Löpande arbetare\n"
"Löpande arbetare\n"
"Huvudtråden sover\n"
"Arbetare <Tråd(arbetare 1, startade 130283832797456)> körs med argument 0\n"
"Arbetare <Tråd (arbetare 2, startade 130283824404752)> körs med argument 1\n"
"Arbetare <Tråd (arbetare 3, startad 130283816012048)> körs med argument 2\n"
"Arbetare <Tråd (arbetare 4, startad 130283807619344)> körs med argument 3\n"
"Arbetare <Tråd (arbetare 5, startad 130283799226640)> körs med argument 4\n"
"Worker <Thread(worker 1, startad 130283832797456)> körs med argument 5\n"
"..."

#: ../../faq/library.rst:358
msgid ""
"Consult the module's documentation for more details; the "
":class:`~queue.Queue` class provides a featureful interface."
msgstr ""
"Läs modulens dokumentation för mer information; klassen "
":class:`~queue.Queue` ger ett användbart gränssnitt."

#: ../../faq/library.rst:363
msgid "What kinds of global value mutation are thread-safe?"
msgstr "Vilka typer av mutation av globala värden är tråd-säkra?"

#: ../../faq/library.rst:365
msgid ""
"A :term:`global interpreter lock` (GIL) is used internally to ensure that "
"only one thread runs in the Python VM at a time.  In general, Python offers "
"to switch among threads only between bytecode instructions; how frequently "
"it switches can be set via :func:`sys.setswitchinterval`.  Each bytecode "
"instruction and therefore all the C implementation code reached from each "
"instruction is therefore atomic from the point of view of a Python program."
msgstr ""
"En :term:``global interpreter lock`` (GIL) används internt för att "
"säkerställa att endast en tråd körs i Python VM åt gången.  I allmänhet "
"erbjuder Python att växla mellan trådar endast mellan bytecode-"
"instruktioner; hur ofta den växlar kan ställas in via "
":func:`sys.setswitchinterval`.  Varje bytecode-instruktion och därmed all "
"C-implementeringskod som nås från varje instruktion är därför atomisk ur ett"
" Python-programs synvinkel."

#: ../../faq/library.rst:372
msgid ""
"In theory, this means an exact accounting requires an exact understanding of"
" the PVM bytecode implementation.  In practice, it means that operations on "
"shared variables of built-in data types (ints, lists, dicts, etc) that "
"\"look atomic\" really are."
msgstr ""
"I teorin innebär detta att en exakt redovisning kräver en exakt förståelse "
"av PVM:s bytecode-implementering.  I praktiken innebär det att operationer "
"på delade variabler av inbyggda datatyper (ints, lists, dicts, etc) som "
"\"ser atomiska ut\" verkligen är det."

#: ../../faq/library.rst:377
msgid ""
"For example, the following operations are all atomic (L, L1, L2 are lists, "
"D, D1, D2 are dicts, x, y are objects, i, j are ints)::"
msgstr ""
"Till exempel är följande operationer alla atomära (L, L1, L2 är listor, D, "
"D1, D2 är dikter, x, y är objekt, i, j är ints)::"

#: ../../faq/library.rst:380
msgid ""
"L.append(x)\n"
"L1.extend(L2)\n"
"x = L[i]\n"
"x = L.pop()\n"
"L1[i:j] = L2\n"
"L.sort()\n"
"x = y\n"
"x.field = y\n"
"D[x] = y\n"
"D1.update(D2)\n"
"D.keys()"
msgstr ""
"L.append(x)\n"
"L1.extend(L2)\n"
"x = L[i]\n"
"x = L.pop()\n"
"L1[i:j] = L2\n"
"L.sort()\n"
"x = y\n"
"x.fält = y\n"
"D[x] = y\n"
"D1.update(D2)\n"
"D.nycklar()"

#: ../../faq/library.rst:392
msgid "These aren't::"
msgstr "De här är inte::"

#: ../../faq/library.rst:394
msgid ""
"i = i+1\n"
"L.append(L[-1])\n"
"L[i] = L[j]\n"
"D[x] = D[x] + 1"
msgstr ""
"i = i+1\n"
"L.append(L[-1])\n"
"L[i] = L[j]\n"
"D[x] = D[x] + 1"

#: ../../faq/library.rst:399
msgid ""
"Operations that replace other objects may invoke those other objects' "
":meth:`~object.__del__` method when their reference count reaches zero, and "
"that can affect things.  This is especially true for the mass updates to "
"dictionaries and lists.  When in doubt, use a mutex!"
msgstr ""
"Operationer som ersätter andra objekt kan åberopa dessa andra objekts "
":meth:`~object.__del__`-metod när deras referensantal når noll, och det kan "
"påverka saker och ting.  Detta gäller särskilt för massuppdateringar av "
"lexikon och listor.  När du är osäker, använd en mutex!"

#: ../../faq/library.rst:406
msgid "Can't we get rid of the Global Interpreter Lock?"
msgstr "Kan vi inte bli av med det globala tolklåset?"

#: ../../faq/library.rst:408
msgid ""
"The :term:`global interpreter lock` (GIL) is often seen as a hindrance to "
"Python's deployment on high-end multiprocessor server machines, because a "
"multi-threaded Python program effectively only uses one CPU, due to the "
"insistence that (almost) all Python code can only run while the GIL is held."
msgstr ""
"Den :term:`global interpreter lock` (GIL) ses ofta som ett hinder för "
"Pythons användning på avancerade servermaskiner med flera processorer, "
"eftersom ett flertrådat Python-program i praktiken bara använder en CPU, på "
"grund av att (nästan) all Python-kod bara kan köras medan GIL hålls."

#: ../../faq/library.rst:413
msgid ""
"With the approval of :pep:`703` work is now underway to remove the GIL from "
"the CPython implementation of Python.  Initially it will be implemented as "
"an optional compiler flag when building the interpreter, and so separate "
"builds will be available with and without the GIL.  Long-term, the hope is "
"to settle on a single build, once the performance implications of removing "
"the GIL are fully understood.  Python 3.13 is likely to be the first release"
" containing this work, although it may not be completely functional in this "
"release."
msgstr ""
"Med godkännande av :pep:`703` pågår nu arbetet med att ta bort GIL från "
"CPython-implementeringen av Python.  Inledningsvis kommer det att "
"implementeras som en valfri kompilatorflagga när tolken byggs, och därför "
"kommer separata byggen att finnas tillgängliga med och utan GIL.  På lång "
"sikt är förhoppningen att man ska kunna nöja sig med en enda version, när "
"man väl har förstått prestandakonsekvenserna av att ta bort GIL.  Python "
"3.13 kommer sannolikt att vara den första utgåvan som innehåller detta "
"arbete, även om det kanske inte är helt funktionellt i den här utgåvan."

#: ../../faq/library.rst:422
msgid ""
"The current work to remove the GIL is based on a `fork of Python 3.9 with "
"the GIL removed <https://github.com/colesbury/nogil>`_ by Sam Gross. Prior "
"to that, in the days of Python 1.5, Greg Stein actually implemented a "
"comprehensive patch set (the \"free threading\" patches) that removed the "
"GIL and replaced it with fine-grained locking.  Adam Olsen did a similar "
"experiment in his `python-safethread "
"<https://code.google.com/archive/p/python-safethread>`_ project.  "
"Unfortunately, both of these earlier experiments exhibited a sharp drop in "
"single-thread performance (at least 30% slower), due to the amount of fine-"
"grained locking necessary to compensate for the removal of the GIL.  The "
"Python 3.9 fork is the first attempt at removing the GIL with an acceptable "
"performance impact."
msgstr ""
"Det nuvarande arbetet med att ta bort GIL är baserat på en `fork av Python "
"3.9 med GIL borttagen <https://github.com/colesbury/nogil>`_ av Sam Gross. "
"Dessförinnan, under Python 1.5, implementerade Greg Stein faktiskt en "
"omfattande patchuppsättning (\"free threading\"-patcherna) som tog bort GIL "
"och ersatte den med finkornig låsning.  Adam Olsen gjorde ett liknande "
"experiment i sitt `python-safethread "
"<https://code.google.com/archive/p/python-safethread>`_-projekt.  Tyvärr "
"uppvisade båda dessa tidigare experiment en kraftig minskning av prestandan "
"för en tråd (minst 30% slägre) på grund av mängden finkornig låsning som "
"krävs för att kompensera för borttagningen av GIL.  Python 3.9-gaffeln är "
"det första försöket att ta bort GIL med en acceptabel prestandapåverkan."

#: ../../faq/library.rst:437
msgid ""
"The presence of the GIL in current Python releases doesn't mean that you "
"can't make good use of Python on multi-CPU machines! You just have to be "
"creative with dividing the work up between multiple *processes* rather than "
"multiple *threads*.  The :class:`~concurrent.futures.ProcessPoolExecutor` "
"class in the new :mod:`concurrent.futures` module provides an easy way of "
"doing so; the :mod:`multiprocessing` module provides a lower-level API in "
"case you want more control over dispatching of tasks."
msgstr ""
"Närvaron av GIL i nuvarande Python-utgåvor betyder inte att du inte kan "
"använda Python bra på multi-CPU-maskiner! Du måste bara vara kreativ när det"
" gäller att dela upp arbetet mellan flera *processer* snarare än flera "
"*trådar*.  Klassen :class:`~concurrent.futures.ProcessPoolExecutor` i den "
"nya :mod:`concurrent.futures`-modulen ger ett enkelt sätt att göra det; "
":mod:`multiprocessing`-modulen ger ett API på lägre nivå om du vill ha mer "
"kontroll över utskick av uppgifter."

#: ../../faq/library.rst:446
msgid ""
"Judicious use of C extensions will also help; if you use a C extension to "
"perform a time-consuming task, the extension can release the GIL while the "
"thread of execution is in the C code and allow other threads to get some "
"work done.  Some standard library modules such as :mod:`zlib` and "
":mod:`hashlib` already do this."
msgstr ""
"Om du använder ett C-tillägg för att utföra en tidskrävande uppgift kan "
"tillägget släppa GIL medan exekveringstråden befinner sig i C-koden och låta"
" andra trådar få lite arbete gjort.  Vissa standardbiblioteksmoduler som "
":mod:`zlib` och :mod:`hashlib` gör redan detta."

#: ../../faq/library.rst:452
msgid ""
"An alternative approach to reducing the impact of the GIL is to make the GIL"
" a per-interpreter-state lock rather than truly global. This was :ref:`first"
" implemented in Python 3.12 <whatsnew312-pep684>` and is available in the C "
"API. A Python interface to it is expected in Python 3.13. The main "
"limitation to it at the moment is likely to be 3rd party extension modules, "
"since these must be written with multiple interpreters in mind in order to "
"be usable, so many older extension modules will not be usable."
msgstr ""
"En alternativ metod för att minska effekten av GIL är att göra GIL till ett "
"lås per tolkningsstatus i stället för ett globalt lås. Detta implementerades"
" :ref:`först i Python 3.12 <whatsnew312-pep684>` och finns tillgängligt i C "
"API. Ett Python-gränssnitt för det förväntas i Python 3.13. Den största "
"begränsningen för det just nu är sannolikt tilläggsmoduler från tredje part,"
" eftersom dessa måste skrivas med flera tolkar i åtanke för att vara "
"användbara, så många äldre tilläggsmoduler kommer inte att kunna användas."

#: ../../faq/library.rst:462
msgid "Input and Output"
msgstr "Inmatning och utmatning"

#: ../../faq/library.rst:465
msgid "How do I delete a file? (And other file questions...)"
msgstr "Hur tar jag bort en fil? (Och andra frågor om filer...)"

#: ../../faq/library.rst:467
msgid ""
"Use ``os.remove(filename)`` or ``os.unlink(filename)``; for documentation, "
"see the :mod:`os` module.  The two functions are identical; "
":func:`~os.unlink` is simply the name of the Unix system call for this "
"function."
msgstr ""
"Använd ``os.remove(filnamn)`` eller ``os.unlink(filnamn)``; för "
"dokumentation, se modulen :mod:`os`.  De två funktionerna är identiska; "
":func:`~os.unlink` är helt enkelt namnet på Unix systemanrop för den här "
"funktionen."

#: ../../faq/library.rst:471
msgid ""
"To remove a directory, use :func:`os.rmdir`; use :func:`os.mkdir` to create "
"one. ``os.makedirs(path)`` will create any intermediate directories in "
"``path`` that don't exist. ``os.removedirs(path)`` will remove intermediate "
"directories as long as they're empty; if you want to delete an entire "
"directory tree and its contents, use :func:`shutil.rmtree`."
msgstr ""
"För att ta bort en katalog, använd :func:`os.rmdir`; använd :func:`os.mkdir`"
" för att skapa en. ``os.makedirs(path)`` skapar alla mellanliggande "
"kataloger i ``path`` som inte finns. ``os.removedirs(path)`` tar bort "
"mellanliggande kataloger så länge de är tomma; om du vill ta bort ett helt "
"katalogträd och dess innehåll, använd :func:`shutil.rmtree`."

#: ../../faq/library.rst:477
msgid "To rename a file, use ``os.rename(old_path, new_path)``."
msgstr ""
"Om du vill byta namn på en fil använder du ``os.rename(old_path, "
"new_path)``."

#: ../../faq/library.rst:479
msgid ""
"To truncate a file, open it using ``f = open(filename, \"rb+\")``, and use "
"``f.truncate(offset)``; offset defaults to the current seek position.  "
"There's also ``os.ftruncate(fd, offset)`` for files opened with "
":func:`os.open`, where *fd* is the file descriptor (a small integer)."
msgstr ""
"För att trunkera en fil öppnar du den med ``f = open(filnamn, \"rb+\")`` och"
" använder ``f.truncate(offset)``; offset är standardvärdet för den aktuella "
"sökpositionen.  Det finns också ``os.ftruncate(fd, offset)`` för filer som "
"öppnas med :func:`os.open`, där *fd* är filbeskrivaren (ett litet heltal)."

#: ../../faq/library.rst:484
msgid ""
"The :mod:`shutil` module also contains a number of functions to work on "
"files including :func:`~shutil.copyfile`, :func:`~shutil.copytree`, and "
":func:`~shutil.rmtree`."
msgstr ""
"Modulen :mod:`shutil` innehåller också ett antal funktioner för att arbeta "
"med filer, bland annat :func:`~shutil.copyfile`, :func:`~shutil.copytree` "
"och :func:`~shutil.rmtree`."

#: ../../faq/library.rst:490
msgid "How do I copy a file?"
msgstr "Hur kopierar jag en fil?"

#: ../../faq/library.rst:492
msgid ""
"The :mod:`shutil` module contains a :func:`~shutil.copyfile` function. Note "
"that on Windows NTFS volumes, it does not copy `alternate data streams "
"<https://en.wikipedia.org/wiki/NTFS#Alternate_data_stream_(ADS)>`_ nor "
"`resource forks <https://en.wikipedia.org/wiki/Resource_fork>`__ on macOS "
"HFS+ volumes, though both are now rarely used. It also doesn't copy file "
"permissions and metadata, though using :func:`shutil.copy2` instead will "
"preserve most (though not all) of it."
msgstr ""
"Modulen :mod:`shutil` innehåller en :func:`~shutil.copyfile`-funktion. "
"Observera att på Windows NTFS-volymer kopieras inte `alternativa "
"dataströmmar "
"<https://en.wikipedia.org/wiki/NTFS#Alternate_data_stream_(ADS)>`_ eller "
"`resursförgreningar <https://en.wikipedia.org/wiki/Resource_fork>`__ på "
"macOS HFS+-volymer, även om båda nu sällan används. Den kopierar inte heller"
" filbehörigheter och metadata, men om du använder :func:`shutil.copy2` "
"istället bevaras det mesta (men inte allt)."

#: ../../faq/library.rst:503
msgid "How do I read (or write) binary data?"
msgstr "Hur läser (eller skriver) jag binära data?"

#: ../../faq/library.rst:505
msgid ""
"To read or write complex binary data formats, it's best to use the "
":mod:`struct` module.  It allows you to take a string containing binary data"
" (usually numbers) and convert it to Python objects; and vice versa."
msgstr ""
"För att läsa eller skriva komplexa binära dataformat är det bäst att använda"
" modulen :mod:`struct`.  Den låter dig ta en sträng som innehåller binära "
"data (vanligtvis siffror) och konvertera den till Python-objekt; och vice "
"versa."

#: ../../faq/library.rst:509
msgid ""
"For example, the following code reads two 2-byte integers and one 4-byte "
"integer in big-endian format from a file::"
msgstr ""
"Följande kod läser till exempel två 2-bytes heltal och ett 4-bytes heltal i "
"big-endian-format från en fil::"

#: ../../faq/library.rst:512
msgid ""
"import struct\n"
"\n"
"with open(filename, \"rb\") as f:\n"
"    s = f.read(8)\n"
"    x, y, z = struct.unpack(\">hhl\", s)"
msgstr ""
"importera struktur\n"
"\n"
"med open(filnamn, \"rb\") som f:\n"
"    s = f.read(8)\n"
"    x, y, z = struct.unpack(\">hhl\", s)"

#: ../../faq/library.rst:518
msgid ""
"The '>' in the format string forces big-endian data; the letter 'h' reads "
"one \"short integer\" (2 bytes), and 'l' reads one \"long integer\" (4 "
"bytes) from the string."
msgstr ""
"Bokstaven \">\" i formatsträngen tvingar fram big-endian-data; bokstaven "
"\"h\" läser ett \"kort heltal\" (2 byte) och \"l\" läser ett \"långt "
"heltal\" (4 byte) från strängen."

#: ../../faq/library.rst:522
msgid ""
"For data that is more regular (e.g. a homogeneous list of ints or floats), "
"you can also use the :mod:`array` module."
msgstr ""
"För data som är mer regelbundna (t.ex. en homogen lista med ints eller "
"floats) kan du också använda modulen :mod:`array`."

#: ../../faq/library.rst:527
msgid ""
"To read and write binary data, it is mandatory to open the file in binary "
"mode (here, passing ``\"rb\"`` to :func:`open`).  If you use ``\"r\"`` "
"instead (the default), the file will be open in text mode and ``f.read()`` "
"will return :class:`str` objects rather than :class:`bytes` objects."
msgstr ""
"För att läsa och skriva binära data är det obligatoriskt att öppna filen i "
"binärt läge (här genom att skicka ``\"rb\"`` till :func:`open`).  Om du "
"istället använder ``\"r\"`` (standard) kommer filen att öppnas i textläge "
"och ``f.read()`` kommer att returnera :class:`str`-objekt istället för "
":class:`bytes`-objekt."

#: ../../faq/library.rst:535
msgid "I can't seem to use os.read() on a pipe created with os.popen(); why?"
msgstr ""
"Jag verkar inte kunna använda os.read() på en pipe som skapats med "
"os.popen(); varför?"

#: ../../faq/library.rst:537
msgid ""
":func:`os.read` is a low-level function which takes a file descriptor, a "
"small integer representing the opened file.  :func:`os.popen` creates a "
"high-level file object, the same type returned by the built-in :func:`open` "
"function. Thus, to read *n* bytes from a pipe *p* created with "
":func:`os.popen`, you need to use ``p.read(n)``."
msgstr ""
":func:`os.read` är en lågnivåfunktion som tar en filbeskrivare, ett litet "
"heltal som representerar den öppnade filen. :func:`os.popen` skapar ett "
"filobjekt på hög nivå, samma typ som returneras av den inbyggda funktionen "
":func:`open`. För att läsa *n* byte från en pipe *p* som skapats med "
":func:`os.popen` måste du alltså använda ``p.read(n)``."

#: ../../faq/library.rst:545
msgid "How do I access the serial (RS232) port?"
msgstr "Hur kommer jag åt den seriella (RS232) porten?"

#: ../../faq/library.rst:547
msgid "For Win32, OSX, Linux, BSD, Jython, IronPython:"
msgstr "För Win32, OSX, Linux, BSD, Jython, IronPython:"

#: ../../faq/library.rst:549
msgid ":pypi:`pyserial`"
msgstr ":pypi:`pyserial`"

#: ../../faq/library.rst:551
msgid "For Unix, see a Usenet post by Mitch Chapman:"
msgstr "För Unix, se ett Usenet-inlägg av Mitch Chapman:"

#: ../../faq/library.rst:553
msgid "https://groups.google.com/groups?selm=34A04430.CF9@ohioee.com"
msgstr "https://groups.google.com/groups?selm=34A04430.CF9@ohioee.com"

#: ../../faq/library.rst:557
msgid "Why doesn't closing sys.stdout (stdin, stderr) really close it?"
msgstr "Varför stänger inte sys.stdout (stdin, stderr) verkligen sys.stdout?"

#: ../../faq/library.rst:559
msgid ""
"Python :term:`file objects <file object>` are a high-level layer of "
"abstraction on low-level C file descriptors."
msgstr ""
"Python :term:`filobjekt <file object>` är ett abstraktionslager på hög nivå "
"för C-filbeskrivare på låg nivå."

#: ../../faq/library.rst:562
msgid ""
"For most file objects you create in Python via the built-in :func:`open` "
"function, ``f.close()`` marks the Python file object as being closed from "
"Python's point of view, and also arranges to close the underlying C file "
"descriptor.  This also happens automatically in ``f``'s destructor, when "
"``f`` becomes garbage."
msgstr ""
"För de flesta filobjekt som du skapar i Python via den inbyggda "
":func:`open`-funktionen, markerar ``f.close()`` Python-filobjektet som "
"stängt ur Pythons synvinkel, och ser också till att stänga den underliggande"
" C-filbeskrivaren.  Detta sker också automatiskt i ``f``'s destruktor, när "
"``f`` blir skräp."

#: ../../faq/library.rst:568
msgid ""
"But stdin, stdout and stderr are treated specially by Python, because of the"
" special status also given to them by C.  Running ``sys.stdout.close()`` "
"marks the Python-level file object as being closed, but does *not* close the"
" associated C file descriptor."
msgstr ""
"Men stdin, stdout och stderr behandlas speciellt av Python, på grund av den "
"speciella status som de också har i C. Att köra ``sys.stdout.close()`` "
"markerar filobjektet på Python-nivå som stängt, men stänger *inte* den "
"associerade C-filbeskrivaren."

#: ../../faq/library.rst:573
msgid ""
"To close the underlying C file descriptor for one of these three, you should"
" first be sure that's what you really want to do (e.g., you may confuse "
"extension modules trying to do I/O).  If it is, use :func:`os.close`::"
msgstr ""
"För att stänga den underliggande C-filbeskrivaren för en av dessa tre bör du"
" först vara säker på att det är vad du verkligen vill göra (t.ex. kan du "
"förvirra tilläggsmoduler som försöker göra I/O).  Om det är det, använd "
":func:`os.close`::"

#: ../../faq/library.rst:577
msgid ""
"os.close(stdin.fileno())\n"
"os.close(stdout.fileno())\n"
"os.close(stderr.fileno())"
msgstr ""
"os.close(stdin.fileno())\n"
"os.close(stdout.fileno())\n"
"os.close(stderr.fileno())"

#: ../../faq/library.rst:581
msgid "Or you can use the numeric constants 0, 1 and 2, respectively."
msgstr "Eller så kan du använda de numeriska konstanterna 0, 1 respektive 2."

#: ../../faq/library.rst:585
msgid "Network/Internet Programming"
msgstr "Programmering av nätverk/internet"

#: ../../faq/library.rst:588
msgid "What WWW tools are there for Python?"
msgstr "Vilka WWW-verktyg finns det för Python?"

#: ../../faq/library.rst:590
msgid ""
"See the chapters titled :ref:`internet` and :ref:`netdata` in the Library "
"Reference Manual.  Python has many modules that will help you build server-"
"side and client-side web systems."
msgstr ""
"Se kapitlen :ref:`internet` och :ref:`netdata` i bibliotekets "
"referensmanual.  Python har många moduler som hjälper dig att bygga "
"webbsystem på server- och klientsidan."

#: ../../faq/library.rst:596
msgid ""
"A summary of available frameworks is maintained by Paul Boddie at "
"https://wiki.python.org/moin/WebProgramming\\ ."
msgstr ""
"En sammanfattning av tillgängliga ramverk upprätthålls av Paul Boddie på "
"https://wiki.python.org/moin/WebProgramming ."

#: ../../faq/library.rst:601
msgid "What module should I use to help with generating HTML?"
msgstr "Vilken modul ska jag använda för att generera HTML?"

#: ../../faq/library.rst:605
msgid ""
"You can find a collection of useful links on the `Web Programming wiki page "
"<https://wiki.python.org/moin/WebProgramming>`_."
msgstr ""
"Du kan hitta en samling användbara länkar på wikisidan för webbprogrammering"
" <https://wiki.python.org/moin/WebProgramming>`_."

#: ../../faq/library.rst:610
msgid "How do I send mail from a Python script?"
msgstr "Hur skickar jag e-post från ett Python-skript?"

#: ../../faq/library.rst:612
msgid "Use the standard library module :mod:`smtplib`."
msgstr "Använd standardbiblioteksmodulen :mod:`smtplib`."

#: ../../faq/library.rst:614
msgid ""
"Here's a very simple interactive mail sender that uses it.  This method will"
" work on any host that supports an SMTP listener. ::"
msgstr ""
"Här är en mycket enkel interaktiv e-postavsändare som använder den.  Den här"
" metoden fungerar på alla värdar som har stöd för en SMTP-lyssnare:"

#: ../../faq/library.rst:617
msgid ""
"import sys, smtplib\n"
"\n"
"fromaddr = input(\"From: \")\n"
"toaddrs  = input(\"To: \").split(',')\n"
"print(\"Enter message, end with ^D:\")\n"
"msg = ''\n"
"while True:\n"
"    line = sys.stdin.readline()\n"
"    if not line:\n"
"        break\n"
"    msg += line\n"
"\n"
"# The actual mail send\n"
"server = smtplib.SMTP('localhost')\n"
"server.sendmail(fromaddr, toaddrs, msg)\n"
"server.quit()"
msgstr ""
"importera sys, smtplib\n"
"\n"
"fromaddr = inmatning(\"Från: \")\n"
"toaddrs = input(\"To: \").split(',')\n"
"print(\"Ange meddelande, avsluta med ^D:\")\n"
"msg = ''\n"
"while True:\n"
"    linje = sys.stdin.readline()\n"
"    om inte rad:\n"
"        break\n"
"    msg += rad\n"
"\n"
"# Själva e-postutskicket\n"
"server = smtplib.SMTP('localhost')\n"
"server.sendmail(fromaddr, toaddrs, msg)\n"
"server.quit()"

#: ../../faq/library.rst:634
msgid ""
"A Unix-only alternative uses sendmail.  The location of the sendmail program"
" varies between systems; sometimes it is ``/usr/lib/sendmail``, sometimes "
"``/usr/sbin/sendmail``.  The sendmail manual page will help you out.  Here's"
" some sample code::"
msgstr ""
"Ett alternativ för Unix använder sendmail.  Platsen för sendmail-programmet "
"varierar mellan olika system; ibland är det ``/usr/lib/sendmail``, ibland "
"``/usr/sbin/sendmail``.  Manualsidan för sendmail hjälper dig.  Här är några"
" exempel på kod::"

#: ../../faq/library.rst:639
msgid ""
"import os\n"
"\n"
"SENDMAIL = \"/usr/sbin/sendmail\"  # sendmail location\n"
"p = os.popen(\"%s -t -i\" % SENDMAIL, \"w\")\n"
"p.write(\"To: receiver@example.com\\n\")\n"
"p.write(\"Subject: test\\n\")\n"
"p.write(\"\\n\")  # blank line separating headers from body\n"
"p.write(\"Some text\\n\")\n"
"p.write(\"some more text\\n\")\n"
"sts = p.close()\n"
"if sts != 0:\n"
"    print(\"Sendmail exit status\", sts)"
msgstr ""
"importera os\n"
"\n"
"SENDMAIL = \"/usr/sbin/sendmail\" # plats för sendmail\n"
"p = os.popen(\"%s -t -i\" % SENDMAIL, \"w\")\n"
"p.write(\"Till: receiver@example.com\\n\")\n"
"p.write(\"Ämne: test\\n\")\n"
"p.write(\"\\n\") # blank rad som skiljer rubriker från brödtext\n"
"p.write(\"Lite text\\n\")\n"
"p.write(\"lite mer text\\n\")\n"
"sts = p.stäng()\n"
"om sts != 0:\n"
"    print(\"Sendmail avslutningsstatus\", sts)"

#: ../../faq/library.rst:654
msgid "How do I avoid blocking in the connect() method of a socket?"
msgstr "Hur undviker jag blockering i connect()-metoden för ett uttag?"

#: ../../faq/library.rst:656
msgid ""
"The :mod:`select` module is commonly used to help with asynchronous I/O on "
"sockets."
msgstr ""
"Modulen :mod:`select` används ofta för att hjälpa till med asynkron I/O på "
"socklar."

#: ../../faq/library.rst:659
msgid ""
"To prevent the TCP connect from blocking, you can set the socket to non-"
"blocking mode.  Then when you do the :meth:`~socket.socket.connect`, you "
"will either connect immediately (unlikely) or get an exception that contains"
" the error number as ``.errno``. ``errno.EINPROGRESS`` indicates that the "
"connection is in progress, but hasn't finished yet.  Different OSes will "
"return different values, so you're going to have to check what's returned on"
" your system."
msgstr ""
"För att förhindra att TCP-anslutningen blockeras kan du ställa in uttaget "
"till icke-blockerande läge.  När du sedan gör :meth:`~socket.socket.connect`"
" kommer du antingen att ansluta omedelbart (osannolikt) eller få ett "
"undantag som innehåller felnumret som ``.errno``. ``errno.EINPROGRESS`` "
"indikerar att anslutningen pågår, men inte har avslutats ännu.  Olika "
"operativsystem kommer att returnera olika värden, så du måste kontrollera "
"vad som returneras på ditt system."

#: ../../faq/library.rst:667
msgid ""
"You can use the :meth:`~socket.socket.connect_ex` method to avoid creating "
"an exception. It will just return the errno value. To poll, you can call "
":meth:`~socket.socket.connect_ex` again later -- ``0`` or ``errno.EISCONN`` "
"indicate that you're connected -- or you can pass this socket to "
":meth:`select.select` to check if it's writable."
msgstr ""
"Du kan använda metoden :meth:`~socket.socket.connect_ex` för att undvika att"
" skapa ett undantag. Den kommer bara att returnera errno värdet. För att "
"polla kan du anropa :meth:`~socket.socket.connect_ex` igen senare -- ``0`` "
"eller ``errno.EISCONN`` indikerar att du är ansluten -- eller så kan du "
"skicka denna socket till :meth:`select.select` för att kontrollera om den är"
" skrivbar."

#: ../../faq/library.rst:675
msgid ""
"The :mod:`asyncio` module provides a general purpose single-threaded and "
"concurrent asynchronous library, which can be used for writing non-blocking "
"network code. The third-party `Twisted <https://twisted.org/>`_ library is a"
" popular and feature-rich alternative."
msgstr ""
"Modulen :mod:`asyncio` tillhandahåller ett allmänt asynkront bibliotek med "
"en enda tråd och samtidiga trådar, som kan användas för att skriva icke-"
"blockerande nätverkskod. Tredjepartsbiblioteket `Twisted "
"<https://twisted.org/>`_ är ett populärt och funktionsrikt alternativ."

#: ../../faq/library.rst:683
msgid "Databases"
msgstr "Databaser"

#: ../../faq/library.rst:686
msgid "Are there any interfaces to database packages in Python?"
msgstr "Finns det några gränssnitt till databaspaket i Python?"

#: ../../faq/library.rst:688
msgid "Yes."
msgstr "Ja."

#: ../../faq/library.rst:690
msgid ""
"Interfaces to disk-based hashes such as :mod:`DBM <dbm.ndbm>` and :mod:`GDBM"
" <dbm.gnu>` are also included with standard Python.  There is also the "
":mod:`sqlite3` module, which provides a lightweight disk-based relational "
"database."
msgstr ""
"Gränssnitt för diskbaserade hashar som :mod:`DBM <dbm.ndbm>` och :mod:`GDBM "
"<dbm.gnu>` ingår också i standard Python.  Det finns också modulen "
":mod:`sqlite3`, som tillhandahåller en lättviktig diskbaserad "
"relationsdatabas."

#: ../../faq/library.rst:695
msgid ""
"Support for most relational databases is available.  See the "
"`DatabaseProgramming wiki page "
"<https://wiki.python.org/moin/DatabaseProgramming>`_ for details."
msgstr ""
"Stöd för de flesta relationsdatabaser finns tillgängligt.  Se wikisidan "
"`DatabaseProgramming <https://wiki.python.org/moin/DatabaseProgramming>`_ "
"för mer information."

#: ../../faq/library.rst:701
msgid "How do you implement persistent objects in Python?"
msgstr "Hur implementerar man persistenta objekt i Python?"

#: ../../faq/library.rst:703
msgid ""
"The :mod:`pickle` library module solves this in a very general way (though "
"you still can't store things like open files, sockets or windows), and the "
":mod:`shelve` library module uses pickle and (g)dbm to create persistent "
"mappings containing arbitrary Python objects."
msgstr ""
"Biblioteksmodulen :mod:`pickle` löser detta på ett mycket allmänt sätt (även"
" om du fortfarande inte kan lagra saker som öppna filer, sockets eller "
"fönster), och biblioteksmodulen :mod:`shelve` använder pickle och (g)dbm för"
" att skapa beständiga mappningar som innehåller godtyckliga Python-objekt."

#: ../../faq/library.rst:710
msgid "Mathematics and Numerics"
msgstr "Matematik och numerik"

#: ../../faq/library.rst:713
msgid "How do I generate random numbers in Python?"
msgstr "Hur genererar jag slumpmässiga nummer i Python?"

#: ../../faq/library.rst:715
msgid ""
"The standard module :mod:`random` implements a random number generator.  "
"Usage is simple::"
msgstr ""
"Standardmodulen :mod:`random` implementerar en slumptalsgenerator.  "
"Användningen är enkel::"

#: ../../faq/library.rst:718
msgid ""
"import random\n"
"random.random()"
msgstr ""
"importera slumpmässigt\n"
"random.random()"

#: ../../faq/library.rst:721
msgid "This returns a random floating-point number in the range [0, 1)."
msgstr "Detta returnerar ett slumpmässigt flyttal i intervallet [0, 1]."

#: ../../faq/library.rst:723
msgid ""
"There are also many other specialized generators in this module, such as:"
msgstr ""
"Det finns också många andra specialiserade generatorer i denna modul, t.ex:"

#: ../../faq/library.rst:725
msgid "``randrange(a, b)`` chooses an integer in the range [a, b)."
msgstr "``randrange(a, b)`` väljer ett heltal i intervallet [a, b]."

#: ../../faq/library.rst:726
msgid "``uniform(a, b)`` chooses a floating-point number in the range [a, b)."
msgstr "``uniform(a, b)`` väljer ett flyttal i intervallet [a, b]."

#: ../../faq/library.rst:727
msgid ""
"``normalvariate(mean, sdev)`` samples the normal (Gaussian) distribution."
msgstr ""
"``normalvariate(mean, sdev)`` samplar den normala (gaussiska) fördelningen."

#: ../../faq/library.rst:729
msgid "Some higher-level functions operate on sequences directly, such as:"
msgstr "Vissa funktioner på högre nivå arbetar direkt med sekvenser, t.ex:"

#: ../../faq/library.rst:731
msgid "``choice(S)`` chooses a random element from a given sequence."
msgstr "``choice(S)`` väljer ett slumpmässigt element från en given sekvens."

#: ../../faq/library.rst:732
msgid "``shuffle(L)`` shuffles a list in-place, i.e. permutes it randomly."
msgstr ""
"``shuffle(L)`` blandar en lista på plats, d.v.s. permuterar den "
"slumpmässigt."

#: ../../faq/library.rst:734
msgid ""
"There's also a ``Random`` class you can instantiate to create independent "
"multiple random number generators."
msgstr ""
"Det finns också en klass ``Random`` som du kan instansiera för att skapa "
"oberoende multipla slumptalsgeneratorer."
