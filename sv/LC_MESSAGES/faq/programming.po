# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# python-doc bot, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-25 15:05+0000\n"
"PO-Revision-Date: 2025-09-15 01:03+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../faq/programming.rst:5
msgid "Programming FAQ"
msgstr "Vanliga frågor om programmering"

#: ../../faq/programming.rst:8
msgid "Contents"
msgstr "Innehåll"

#: ../../faq/programming.rst:12
msgid "General Questions"
msgstr "Allmänna frågor"

#: ../../faq/programming.rst:15
msgid ""
"Is there a source code level debugger with breakpoints, single-stepping, "
"etc.?"
msgstr ""
"Finns det en debugger på källkodsnivå med brytpunkter, single-stepping, etc"

#: ../../faq/programming.rst:17 ../../faq/programming.rst:58
msgid "Yes."
msgstr "Ja."

#: ../../faq/programming.rst:19
msgid ""
"Several debuggers for Python are described below, and the built-in function "
":func:`breakpoint` allows you to drop into any of them."
msgstr ""
"Flera debuggers för Python beskrivs nedan, och den inbyggda funktionen "
":func:`breakpoint` gör att du kan hoppa in i vilken som helst av dem."

#: ../../faq/programming.rst:22
msgid ""
"The pdb module is a simple but adequate console-mode debugger for Python. It"
" is part of the standard Python library, and is :mod:`documented in the "
"Library Reference Manual <pdb>`. You can also write your own debugger by "
"using the code for pdb as an example."
msgstr ""
"Modulen pdb är en enkel men adekvat felsökare i konsolläge för Python. Den "
"är en del av Pythons standardbibliotek och :mod:`dokumenteras i Library "
"Reference Manual <pdb>`. Du kan också skriva din egen felsökare genom att "
"använda koden för pdb som ett exempel."

#: ../../faq/programming.rst:27
msgid ""
"The IDLE interactive development environment, which is part of the standard "
"Python distribution (normally available as `Tools/scripts/idle3 "
"<https://github.com/python/cpython/blob/main/Tools/scripts/idle3>`_), "
"includes a graphical debugger."
msgstr ""
"Den interaktiva utvecklingsmiljön IDLE, som ingår i standarddistributionen "
"av Python (normalt tillgänglig som `Tools/scripts/idle3 "
"<https://github.com/python/cpython/blob/main/Tools/scripts/idle3>`_), "
"innehåller en grafisk felsökare."

#: ../../faq/programming.rst:32
msgid ""
"PythonWin is a Python IDE that includes a GUI debugger based on pdb.  The "
"PythonWin debugger colors breakpoints and has quite a few cool features such"
" as debugging non-PythonWin programs.  PythonWin is available as part of "
"`pywin32 <https://github.com/mhammond/pywin32>`_ project and as a part of "
"the `ActivePython <https://www.activestate.com/products/python/>`_ "
"distribution."
msgstr ""
"PythonWin är en Python IDE som innehåller en GUI-felsökare baserad på pdb.  "
"PythonWin-felsökaren färgar brytpunkter och har en hel del coola funktioner,"
" till exempel felsökning av icke-PythonWin-program.  PythonWin är "
"tillgängligt som en del av `pywin32 "
"<https://github.com/mhammond/pywin32>`_-projektet och som en del av "
"`ActivePython "
"<https://www.activestate.com/products/python/>`_-distributionen."

#: ../../faq/programming.rst:39
msgid ""
"`Eric <https://eric-ide.python-projects.org/>`_ is an IDE built on PyQt and "
"the Scintilla editing component."
msgstr ""
"`Eric <https://eric-ide.python-projects.org/>`_ är en IDE som bygger på PyQt"
" och redigeringskomponenten Scintilla."

#: ../../faq/programming.rst:42
msgid ""
"`trepan3k <https://github.com/rocky/python3-trepan/>`_ is a gdb-like "
"debugger."
msgstr ""
"`trepan3k <https://github.com/rocky/python3-trepan/>`_ är en gdb-liknande "
"felsökare."

#: ../../faq/programming.rst:44
msgid ""
"`Visual Studio Code <https://code.visualstudio.com/>`_ is an IDE with "
"debugging tools that integrates with version-control software."
msgstr ""
"`Visual Studio Code <https://code.visualstudio.com/>`_ är en IDE med "
"felsökningsverktyg som kan integreras med programvara för versionshantering."

#: ../../faq/programming.rst:47
msgid ""
"There are a number of commercial Python IDEs that include graphical "
"debuggers. They include:"
msgstr ""
"Det finns ett antal kommersiella Python IDE:er som innehåller grafiska "
"debuggers. De inkluderar:"

#: ../../faq/programming.rst:50
msgid "`Wing IDE <https://wingware.com/>`_"
msgstr "`Wing IDE <https://wingware.com/>`_"

#: ../../faq/programming.rst:51
msgid "`Komodo IDE <https://www.activestate.com/products/komodo-ide/>`_"
msgstr "`Komodo IDE <https://www.activestate.com/products/komodo-ide/>`_"

#: ../../faq/programming.rst:52
msgid "`PyCharm <https://www.jetbrains.com/pycharm/>`_"
msgstr "`PyCharm <https://www.jetbrains.com/pycharm/>`_"

#: ../../faq/programming.rst:56
msgid "Are there tools to help find bugs or perform static analysis?"
msgstr ""
"Finns det verktyg som hjälper till att hitta buggar eller utföra statisk "
"analys?"

#: ../../faq/programming.rst:60
msgid ""
"`Pylint <https://pylint.pycqa.org/en/latest/index.html>`_ and `Pyflakes "
"<https://github.com/PyCQA/pyflakes>`_ do basic checking that will help you "
"catch bugs sooner."
msgstr ""
"`Pylint <https://pylint.pycqa.org/en/latest/index.html>`_ och `Pyflakes "
"<https://github.com/PyCQA/pyflakes>`_ gör grundläggande kontroller som "
"hjälper dig att hitta buggar snabbare."

#: ../../faq/programming.rst:64
msgid ""
"Static type checkers such as `Mypy <https://mypy-lang.org/>`_, `Pyre "
"<https://pyre-check.org/>`_, and `Pytype "
"<https://github.com/google/pytype>`_ can check type hints in Python source "
"code."
msgstr ""
"Statiska typkontrollprogram som `Mypy <https://mypy-lang.org/>`_, `Pyre "
"<https://pyre-check.org/>`_ och `Pytype <https://github.com/google/pytype>`_"
" kan kontrollera typtips i Pythons källkod."

#: ../../faq/programming.rst:73
msgid "How can I create a stand-alone binary from a Python script?"
msgstr "Hur kan jag skapa en fristående binär från ett Python-skript?"

#: ../../faq/programming.rst:75
msgid ""
"You don't need the ability to compile Python to C code if all you want is a "
"stand-alone program that users can download and run without having to "
"install the Python distribution first.  There are a number of tools that "
"determine the set of modules required by a program and bind these modules "
"together with a Python binary to produce a single executable."
msgstr ""
"Du behöver inte kunna kompilera Python till C-kod om du bara vill ha ett "
"fristående program som användarna kan ladda ner och köra utan att först "
"behöva installera Python-distributionen.  Det finns ett antal verktyg som "
"fastställer den uppsättning moduler som krävs av ett program och binder "
"samman dessa moduler med en Python-binärfil för att producera en enda körbar"
" fil."

#: ../../faq/programming.rst:81
msgid ""
"One is to use the freeze tool, which is included in the Python source tree "
"as `Tools/freeze "
"<https://github.com/python/cpython/tree/main/Tools/freeze>`_. It converts "
"Python byte code to C arrays; with a C compiler you can embed all your "
"modules into a new program, which is then linked with the standard Python "
"modules."
msgstr ""
"Ett sätt är att använda verktyget freeze, som ingår i Pythons källträd som "
"`Tools/freeze <https://github.com/python/cpython/tree/main/Tools/freeze>`_. "
"Det konverterar Pythons bytekod till C-arrayer; med en C-kompilator kan du "
"bädda in alla dina moduler i ett nytt program, som sedan länkas med Pythons "
"standardmoduler."

#: ../../faq/programming.rst:87
msgid ""
"It works by scanning your source recursively for import statements (in both "
"forms) and looking for the modules in the standard Python path as well as in"
" the source directory (for built-in modules).  It then turns the bytecode "
"for modules written in Python into C code (array initializers that can be "
"turned into code objects using the marshal module) and creates a custom-made"
" config file that only contains those built-in modules which are actually "
"used in the program.  It then compiles the generated C code and links it "
"with the rest of the Python interpreter to form a self-contained binary "
"which acts exactly like your script."
msgstr ""
"Det fungerar genom att skanna din källkod rekursivt efter importmeddelanden "
"(i båda formerna) och leta efter modulerna i Pythons standardsökväg samt i "
"källkatalogen (för inbyggda moduler).  Därefter omvandlas bytekoden för "
"moduler skrivna i Python till C-kod (array-initialiserare som kan omvandlas "
"till kodobjekt med hjälp av marshal-modulen) och en skräddarsydd "
"konfigurationsfil skapas som endast innehåller de inbyggda moduler som "
"faktiskt används i programmet.  Därefter kompileras den genererade C-koden "
"och länkas med resten av Python-tolken för att bilda en fristående binär fil"
" som fungerar precis som ditt skript."

#: ../../faq/programming.rst:96
msgid ""
"The following packages can help with the creation of console and GUI "
"executables:"
msgstr ""
"Följande paket kan hjälpa till att skapa körbara konsol- och GUI-program:"

#: ../../faq/programming.rst:99
msgid "`Nuitka <https://nuitka.net/>`_ (Cross-platform)"
msgstr "`Nuitka <https://nuitka.net/>`_ (plattformsoberoende)"

#: ../../faq/programming.rst:100
msgid "`PyInstaller <https://pyinstaller.org/>`_ (Cross-platform)"
msgstr "`PyInstaller <https://pyinstaller.org/>`_ (plattformsoberoende)"

#: ../../faq/programming.rst:101
msgid ""
"`PyOxidizer <https://pyoxidizer.readthedocs.io/en/stable/>`_ (Cross-"
"platform)"
msgstr ""
"`PyOxidizer <https://pyoxidizer.readthedocs.io/en/stable/>`_ "
"(plattformsoberoende)"

#: ../../faq/programming.rst:102
msgid ""
"`cx_Freeze <https://marcelotduarte.github.io/cx_Freeze/>`_ (Cross-platform)"
msgstr ""
"`cx_Freeze <https://marcelotduarte.github.io/cx_Freeze/>`_ "
"(plattformsoberoende)"

#: ../../faq/programming.rst:103
msgid "`py2app <https://github.com/ronaldoussoren/py2app>`_ (macOS only)"
msgstr "`py2app <https://github.com/ronaldoussoren/py2app>`_ (endast macOS)"

#: ../../faq/programming.rst:104
msgid "`py2exe <https://www.py2exe.org/>`_ (Windows only)"
msgstr "`py2exe <https://www.py2exe.org/>`_ (endast Windows)"

#: ../../faq/programming.rst:107
msgid "Are there coding standards or a style guide for Python programs?"
msgstr "Finns det kodningsstandarder eller en stilguide för Python-program?"

#: ../../faq/programming.rst:109
msgid ""
"Yes.  The coding style required for standard library modules is documented "
"as :pep:`8`."
msgstr ""
"Ja. Den kodningsstil som krävs för standardbiblioteksmoduler är dokumenterad"
" som :pep:`8`."

#: ../../faq/programming.rst:114
msgid "Core Language"
msgstr "Kärnspråk"

#: ../../faq/programming.rst:119
msgid "Why am I getting an UnboundLocalError when the variable has a value?"
msgstr "Varför får jag ett UnboundLocalError när variabeln har ett värde?"

#: ../../faq/programming.rst:121
msgid ""
"It can be a surprise to get the :exc:`UnboundLocalError` in previously "
"working code when it is modified by adding an assignment statement somewhere"
" in the body of a function."
msgstr ""
"Det kan vara en överraskning att få :exc:`UnboundLocalError` i tidigare "
"fungerande kod när den ändras genom att lägga till en assignment-sats "
"någonstans i en funktions kropp."

#: ../../faq/programming.rst:125
msgid "This code:"
msgstr "Den här koden:"

#: ../../faq/programming.rst:134
msgid "works, but this code:"
msgstr "fungerar, men den här koden:"

#: ../../faq/programming.rst:141
msgid "results in an :exc:`!UnboundLocalError`:"
msgstr "resulterar i en :exc:`!UnboundLocalError`:"

#: ../../faq/programming.rst:148
msgid ""
"This is because when you make an assignment to a variable in a scope, that "
"variable becomes local to that scope and shadows any similarly named "
"variable in the outer scope.  Since the last statement in foo assigns a new "
"value to ``x``, the compiler recognizes it as a local variable.  "
"Consequently when the earlier ``print(x)`` attempts to print the "
"uninitialized local variable and an error results."
msgstr ""
"Det beror på att när du gör en tilldelning till en variabel i ett scope, "
"blir variabeln lokal i detta scope och skuggar alla variabler med liknande "
"namn i det yttre scopet.  Eftersom den sista satsen i foo tilldelar ett nytt"
" värde till ``x``, känner kompilatorn igen den som en lokal variabel.  "
"Följaktligen när den tidigare ``print(x)`` försöker skriva ut den "
"oinitialiserade lokala variabeln och ett fel uppstår."

#: ../../faq/programming.rst:155
msgid ""
"In the example above you can access the outer scope variable by declaring it"
" global:"
msgstr ""
"I exemplet ovan kan du komma åt den yttre scopevariabeln genom att deklarera"
" den som global:"

#: ../../faq/programming.rst:167
msgid ""
"This explicit declaration is required in order to remind you that (unlike "
"the superficially analogous situation with class and instance variables) you"
" are actually modifying the value of the variable in the outer scope:"
msgstr ""
"Denna uttryckliga deklaration krävs för att påminna dig om att du faktiskt "
"ändrar variabelns värde i det yttre omfånget (till skillnad från den ytligt "
"sett analoga situationen med klass- och instansvariabler):"

#: ../../faq/programming.rst:174
msgid ""
"You can do a similar thing in a nested scope using the :keyword:`nonlocal` "
"keyword:"
msgstr ""
"Du kan göra något liknande i ett nästlat scope med hjälp av nyckelordet "
":keyword:`nonlocal`:"

#: ../../faq/programming.rst:192
msgid "What are the rules for local and global variables in Python?"
msgstr "Vilka är reglerna för lokala och globala variabler i Python?"

#: ../../faq/programming.rst:194
msgid ""
"In Python, variables that are only referenced inside a function are "
"implicitly global.  If a variable is assigned a value anywhere within the "
"function's body, it's assumed to be a local unless explicitly declared as "
"global."
msgstr ""
"I Python är variabler som endast refereras till inom en funktion implicit "
"globala.  Om en variabel tilldelas ett värde någonstans inom funktionens "
"kropp antas den vara lokal om den inte uttryckligen deklareras som global."

#: ../../faq/programming.rst:198
msgid ""
"Though a bit surprising at first, a moment's consideration explains this.  "
"On one hand, requiring :keyword:`global` for assigned variables provides a "
"bar against unintended side-effects.  On the other hand, if ``global`` was "
"required for all global references, you'd be using ``global`` all the time."
"  You'd have to declare as global every reference to a built-in function or "
"to a component of an imported module.  This clutter would defeat the "
"usefulness of the ``global`` declaration for identifying side-effects."
msgstr ""
"Även om det är lite förvånande i början, förklarar en stunds övervägande "
"detta.  Å ena sidan ger kravet på :keyword:`global` för tilldelade variabler"
" en spärr mot oavsiktliga bieffekter.  Å andra sidan, om ``global`` krävdes "
"för alla globala referenser, skulle du använda ``global`` hela tiden.  Man "
"skulle vara tvungen att deklarera varje referens till en inbyggd funktion "
"eller till en komponent i en importerad modul som global.  Denna röra skulle"
" omintetgöra nyttan av ``global``\\-deklarationen för att identifiera "
"bieffekter."

#: ../../faq/programming.rst:208
msgid ""
"Why do lambdas defined in a loop with different values all return the same "
"result?"
msgstr ""
"Varför returnerar lambdas som definieras i en loop med olika värden alla "
"samma resultat?"

#: ../../faq/programming.rst:210
msgid ""
"Assume you use a for loop to define a few different lambdas (or even plain "
"functions), e.g.::"
msgstr ""
"Antag att du använder en for-slinga för att definiera några olika lambdas "
"(eller till och med vanliga funktioner), t.ex.::"

#: ../../faq/programming.rst:213
msgid ""
">>> squares = []\n"
">>> for x in range(5):\n"
"...     squares.append(lambda: x**2)"
msgstr ""
">>> squares = []\n"
">>> for x in range(5):\n"
"...     squares.append(lambda: x**2)"

#: ../../faq/programming.rst:217
msgid ""
"This gives you a list that contains 5 lambdas that calculate ``x**2``.  You "
"might expect that, when called, they would return, respectively, ``0``, "
"``1``, ``4``, ``9``, and ``16``.  However, when you actually try you will "
"see that they all return ``16``::"
msgstr ""
"Detta ger dig en lista som innehåller 5 lambdas som beräknar ``x**2``.  Du "
"kan förvänta dig att när de anropas skulle de returnera ``0``, ``1``, ``4``,"
" ``9`` och ``16``.  Men när du faktiskt försöker kommer du att se att de "
"alla returnerar ``16``::"

#: ../../faq/programming.rst:222
msgid ""
">>> squares[2]()\n"
"16\n"
">>> squares[4]()\n"
"16"
msgstr ""
">>> squares[2]()\n"
"16\n"
">>> squares[4]()\n"
"16"

#: ../../faq/programming.rst:227
msgid ""
"This happens because ``x`` is not local to the lambdas, but is defined in "
"the outer scope, and it is accessed when the lambda is called --- not when "
"it is defined.  At the end of the loop, the value of ``x`` is ``4``, so all "
"the functions now return ``4**2``, i.e. ``16``.  You can also verify this by"
" changing the value of ``x`` and see how the results of the lambdas change::"
msgstr ""
"Detta beror på att ``x`` inte är lokalt för lambdan utan definieras i det "
"yttre scope, och den nås när lambdan anropas --- inte när den definieras.  I"
" slutet av slingan är värdet på ``x`` ``4``, så alla funktioner returnerar "
"nu ``4**2``, dvs ``16``.  Du kan också verifiera detta genom att ändra "
"värdet på ``x`` och se hur resultaten av lambdas ändras::"

#: ../../faq/programming.rst:233
msgid ""
">>> x = 8\n"
">>> squares[2]()\n"
"64"
msgstr ""
">>> x = 8\n"
">>> squares[2]()\n"
"64"

#: ../../faq/programming.rst:237
msgid ""
"In order to avoid this, you need to save the values in variables local to "
"the lambdas, so that they don't rely on the value of the global ``x``::"
msgstr ""
"För att undvika detta måste du spara värdena i variabler som är lokala för "
"lambdan, så att de inte är beroende av värdet på den globala ``x``::"

#: ../../faq/programming.rst:240
msgid ""
">>> squares = []\n"
">>> for x in range(5):\n"
"...     squares.append(lambda n=x: n**2)"
msgstr ""
">>> squares = []\n"
">>> for x in range(5):\n"
"...     squares.append(lambda n=x: n**2)"

#: ../../faq/programming.rst:244
msgid ""
"Here, ``n=x`` creates a new variable ``n`` local to the lambda and computed "
"when the lambda is defined so that it has the same value that ``x`` had at "
"that point in the loop.  This means that the value of ``n`` will be ``0`` in"
" the first lambda, ``1`` in the second, ``2`` in the third, and so on. "
"Therefore each lambda will now return the correct result::"
msgstr ""
"Här skapar ``n=x`` en ny variabel ``n`` som är lokal för lambdan och som "
"beräknas när lambdan definieras så att den har samma värde som ``x`` hade "
"vid den tidpunkten i loopen.  Detta innebär att värdet på ``n`` kommer att "
"vara ``0`` i den första lambdan, ``1`` i den andra, ``2`` i den tredje och "
"så vidare. Därför kommer varje lambda nu att returnera rätt resultat::"

#: ../../faq/programming.rst:250
msgid ""
">>> squares[2]()\n"
"4\n"
">>> squares[4]()\n"
"16"
msgstr ""
">>> squares[2]()\n"
"4\n"
">>> squares[4]()\n"
"16"

#: ../../faq/programming.rst:255
msgid ""
"Note that this behaviour is not peculiar to lambdas, but applies to regular "
"functions too."
msgstr ""
"Observera att detta beteende inte är unikt för lambdas, utan även gäller för"
" vanliga funktioner."

#: ../../faq/programming.rst:260
msgid "How do I share global variables across modules?"
msgstr "Hur delar jag globala variabler mellan moduler?"

#: ../../faq/programming.rst:262
msgid ""
"The canonical way to share information across modules within a single "
"program is to create a special module (often called config or cfg).  Just "
"import the config module in all modules of your application; the module then"
" becomes available as a global name.  Because there is only one instance of "
"each module, any changes made to the module object get reflected everywhere."
"  For example:"
msgstr ""
"Det vanligaste sättet att dela information mellan moduler inom ett och samma"
" program är att skapa en speciell modul (ofta kallad config eller cfg).  "
"Importera bara config-modulen i alla moduler i ditt program; modulen blir då"
" tillgänglig som ett globalt namn.  Eftersom det bara finns en instans av "
"varje modul kommer alla ändringar som görs i modulobjektet att återspeglas "
"överallt.  Ett exempel:"

#: ../../faq/programming.rst:268
msgid "config.py::"
msgstr "config.py::"

#: ../../faq/programming.rst:270
msgid "x = 0   # Default value of the 'x' configuration setting"
msgstr "x = 0 # Standardvärde för konfigurationsinställningen \"x"

#: ../../faq/programming.rst:272
msgid "mod.py::"
msgstr "mod.py::"

#: ../../faq/programming.rst:274
msgid ""
"import config\n"
"config.x = 1"
msgstr ""
"import config\n"
"config.x = 1"

#: ../../faq/programming.rst:277
msgid "main.py::"
msgstr "main.py::"

#: ../../faq/programming.rst:279
msgid ""
"import config\n"
"import mod\n"
"print(config.x)"
msgstr ""
"import config\n"
"import mod\n"
"print(config.x)"

#: ../../faq/programming.rst:283
msgid ""
"Note that using a module is also the basis for implementing the singleton "
"design pattern, for the same reason."
msgstr ""
"Observera att användning av en modul också är grunden för att implementera "
"designmönstret singleton, av samma anledning."

#: ../../faq/programming.rst:288
msgid "What are the \"best practices\" for using import in a module?"
msgstr "Vilka är de \"bästa metoderna\" för att använda import i en modul?"

#: ../../faq/programming.rst:290
msgid ""
"In general, don't use ``from modulename import *``.  Doing so clutters the "
"importer's namespace, and makes it much harder for linters to detect "
"undefined names."
msgstr ""
"I allmänhet ska du inte använda ``from modulename import *``.  Om du gör det"
" blir importörens namnrymd rörig och det blir mycket svårare för linters att"
" upptäcka odefinierade namn."

#: ../../faq/programming.rst:294
msgid ""
"Import modules at the top of a file.  Doing so makes it clear what other "
"modules your code requires and avoids questions of whether the module name "
"is in scope. Using one import per line makes it easy to add and delete "
"module imports, but using multiple imports per line uses less screen space."
msgstr ""
"Importera moduler längst upp i en fil.  På så sätt blir det tydligt vilka "
"andra moduler din kod kräver och du undviker frågor om modulnamnet är inom "
"räckvidden. Om du använder en import per rad är det enkelt att lägga till "
"och ta bort modulimporter, men om du använder flera importer per rad tar det"
" mindre plats på skärmen."

#: ../../faq/programming.rst:299
msgid "It's good practice if you import modules in the following order:"
msgstr "Det är bra om du importerar moduler i följande ordning:"

#: ../../faq/programming.rst:301
msgid ""
"standard library modules -- e.g. :mod:`sys`, :mod:`os`, :mod:`argparse`, "
":mod:`re`"
msgstr ""
"standardbiblioteksmoduler -- t.ex. :mod:`sys`, :mod:`os`, :mod:`argparse`, "
":mod:`re`"

#: ../../faq/programming.rst:302
msgid ""
"third-party library modules (anything installed in Python's site-packages "
"directory) -- e.g. :mod:`!dateutil`, :mod:`!requests`, :mod:`!PIL.Image`"
msgstr ""
"biblioteksmoduler från tredje part (allt som installeras i Pythons site-"
"packages-katalog) -- t.ex. :mod:`!dateutil`, :mod:`!requests`, "
":mod:`!PIL.Image`"

#: ../../faq/programming.rst:304
msgid "locally developed modules"
msgstr "lokalt utvecklade moduler"

#: ../../faq/programming.rst:306
msgid ""
"It is sometimes necessary to move imports to a function or class to avoid "
"problems with circular imports.  Gordon McMillan says:"
msgstr ""
"Det är ibland nödvändigt att flytta import till en funktion eller klass för "
"att undvika problem med cirkulär import.  Gordon McMillan säger:"

#: ../../faq/programming.rst:309
msgid ""
"Circular imports are fine where both modules use the \"import <module>\" "
"form of import.  They fail when the 2nd module wants to grab a name out of "
"the first (\"from module import name\") and the import is at the top level."
"  That's because names in the 1st are not yet available, because the first "
"module is busy importing the 2nd."
msgstr ""
"Cirkulär import fungerar bra när båda modulerna använder importformen "
"\"import <module>\".  De misslyckas när den andra modulen vill hämta ett "
"namn från den första (\"from module import name\") och importen sker på "
"högsta nivån.  Det beror på att namnen i den första modulen ännu inte är "
"tillgängliga, eftersom den första modulen är upptagen med att importera den "
"andra."

#: ../../faq/programming.rst:315
msgid ""
"In this case, if the second module is only used in one function, then the "
"import can easily be moved into that function.  By the time the import is "
"called, the first module will have finished initializing, and the second "
"module can do its import."
msgstr ""
"I det här fallet, om den andra modulen bara används i en funktion, kan "
"importen enkelt flyttas till den funktionen.  När importen anropas kommer "
"den första modulen att ha initialiserats färdigt och den andra modulen kan "
"göra sin import."

#: ../../faq/programming.rst:320
msgid ""
"It may also be necessary to move imports out of the top level of code if "
"some of the modules are platform-specific.  In that case, it may not even be"
" possible to import all of the modules at the top of the file.  In this "
"case, importing the correct modules in the corresponding platform-specific "
"code is a good option."
msgstr ""
"Det kan också vara nödvändigt att flytta importen från den översta kodnivån "
"om några av modulerna är plattformsspecifika.  I så fall kanske det inte ens"
" är möjligt att importera alla moduler högst upp i filen.  I så fall är det "
"ett bra alternativ att importera rätt moduler i motsvarande "
"plattformsspecifika kod."

#: ../../faq/programming.rst:325
msgid ""
"Only move imports into a local scope, such as inside a function definition, "
"if it's necessary to solve a problem such as avoiding a circular import or "
"are trying to reduce the initialization time of a module.  This technique is"
" especially helpful if many of the imports are unnecessary depending on how "
"the program executes.  You may also want to move imports into a function if "
"the modules are only ever used in that function.  Note that loading a module"
" the first time may be expensive because of the one time initialization of "
"the module, but loading a module multiple times is virtually free, costing "
"only a couple of dictionary lookups.  Even if the module name has gone out "
"of scope, the module is probably available in :data:`sys.modules`."
msgstr ""
"Flytta bara import till ett lokalt scope, t.ex. inuti en "
"funktionsdefinition, om det är nödvändigt för att lösa ett problem, t.ex. "
"för att undvika cirkulär import eller för att minska initialiseringstiden "
"för en modul.  Den här tekniken är särskilt användbar om många av importerna"
" är onödiga beroende på hur programmet exekveras.  Du kanske också vill "
"flytta importen till en funktion om modulerna bara används i den funktionen."
"  Observera att det kan vara dyrt att ladda en modul första gången eftersom "
"modulen initialiseras en gång, men att ladda en modul flera gånger är "
"praktiskt taget gratis och kostar bara ett par ordboksuppslagningar.  Även "
"om modulnamnet har försvunnit finns modulen förmodligen tillgänglig i "
":data:`sys.modules`."

#: ../../faq/programming.rst:338
msgid "Why are default values shared between objects?"
msgstr "Varför delas standardvärden mellan objekt?"

#: ../../faq/programming.rst:340
msgid ""
"This type of bug commonly bites neophyte programmers.  Consider this "
"function::"
msgstr ""
"Denna typ av bugg drabbar ofta nybörjare inom programmering.  Tänk på den "
"här funktionen::"

#: ../../faq/programming.rst:342
msgid ""
"def foo(mydict={}):  # Danger: shared reference to one dict for all calls\n"
"    ... compute something ...\n"
"    mydict[key] = value\n"
"    return mydict"
msgstr ""
"def foo(mydict={}):  # Fara: delad referens till en dict för alla anrop\n"
"    ... beräkna något ...\n"
"    mydict[nyckel] = värde\n"
"    returnera mydict"

#: ../../faq/programming.rst:347
msgid ""
"The first time you call this function, ``mydict`` contains a single item.  "
"The second time, ``mydict`` contains two items because when ``foo()`` begins"
" executing, ``mydict`` starts out with an item already in it."
msgstr ""
"Första gången du anropar den här funktionen innehåller ``mydict`` ett enda "
"objekt.  Andra gången innehåller ``mydict`` två objekt eftersom när "
"``foo()`` börjar exekveras, börjar ``mydict`` med ett objekt redan i den."

#: ../../faq/programming.rst:351
msgid ""
"It is often expected that a function call creates new objects for default "
"values. This is not what happens. Default values are created exactly once, "
"when the function is defined.  If that object is changed, like the "
"dictionary in this example, subsequent calls to the function will refer to "
"this changed object."
msgstr ""
"Man förväntar sig ofta att ett funktionsanrop skapar nya objekt för "
"standardvärden. Detta är inte vad som händer. Standardvärden skapas exakt en"
" gång, när funktionen definieras.  Om det objektet ändras, som ordboken i "
"det här exemplet, kommer efterföljande anrop av funktionen att hänvisa till "
"det ändrade objektet."

#: ../../faq/programming.rst:356
msgid ""
"By definition, immutable objects such as numbers, strings, tuples, and "
"``None``, are safe from change. Changes to mutable objects such as "
"dictionaries, lists, and class instances can lead to confusion."
msgstr ""
"Per definition är oföränderliga objekt som tal, strängar, tupler och "
"``None`` säkra från ändringar. Ändringar av föränderliga objekt som "
"ordböcker, listor och klassinstanser kan leda till förvirring."

#: ../../faq/programming.rst:360
msgid ""
"Because of this feature, it is good programming practice to not use mutable "
"objects as default values.  Instead, use ``None`` as the default value and "
"inside the function, check if the parameter is ``None`` and create a new "
"list/dictionary/whatever if it is.  For example, don't write::"
msgstr ""
"På grund av denna funktion är det god programmeringspraxis att inte använda "
"föränderliga objekt som standardvärden.  Använd istället ``None`` som "
"standardvärde och kontrollera i funktionen om parametern är ``None`` och "
"skapa en ny lista/dictionary/whatever om den är det.  Skriv till exempel "
"inte::"

#: ../../faq/programming.rst:365
msgid ""
"def foo(mydict={}):\n"
"    ..."
msgstr ""
"def foo(mydict={}):\n"
"    ..."

#: ../../faq/programming.rst:368
msgid "but::"
msgstr "men::"

#: ../../faq/programming.rst:370
msgid ""
"def foo(mydict=None):\n"
"    if mydict is None:\n"
"        mydict = {}  # create a new dict for local namespace"
msgstr ""
"def foo(mydict=None):\n"
"    om mydict är None:\n"
"        mydict = {} # skapa en ny dict för lokal namnrymd"

#: ../../faq/programming.rst:374
msgid ""
"This feature can be useful.  When you have a function that's time-consuming "
"to compute, a common technique is to cache the parameters and the resulting "
"value of each call to the function, and return the cached value if the same "
"value is requested again.  This is called \"memoizing\", and can be "
"implemented like this::"
msgstr ""
"Den här funktionen kan vara användbar.  När du har en funktion som är "
"tidskrävande att beräkna är en vanlig teknik att cachelagra parametrarna och"
" det resulterande värdet för varje anrop till funktionen och returnera det "
"cachelagrade värdet om samma värde begärs igen.  Detta kallas \"memoizing\" "
"och kan implementeras så här::"

#: ../../faq/programming.rst:379
msgid ""
"# Callers can only provide two parameters and optionally pass _cache by keyword\n"
"def expensive(arg1, arg2, *, _cache={}):\n"
"    if (arg1, arg2) in _cache:\n"
"        return _cache[(arg1, arg2)]\n"
"\n"
"    # Calculate the value\n"
"    result = ... expensive computation ...\n"
"    _cache[(arg1, arg2)] = result           # Store result in the cache\n"
"    return result"
msgstr ""
"# Anroparen kan bara ange två parametrar och eventuellt skicka _cache med nyckelord\n"
"def expensive(arg1, arg2, *, _cache={}):\n"
"    if (arg1, arg2) i _cache:\n"
"        returnera _cache[(arg1, arg2)]\n"
"\n"
"    # Beräkna värdet\n"
"    resultat = ... dyr beräkning ...\n"
"    _cache[(arg1, arg2)] = result # Lagra resultatet i cacheminnet\n"
"    returnera resultat"

#: ../../faq/programming.rst:389
msgid ""
"You could use a global variable containing a dictionary instead of the "
"default value; it's a matter of taste."
msgstr ""
"Du kan använda en global variabel som innehåller en ordbok i stället för "
"standardvärdet; det är en smaksak."

#: ../../faq/programming.rst:394
msgid ""
"How can I pass optional or keyword parameters from one function to another?"
msgstr ""
"Hur kan jag skicka valfria parametrar eller nyckelordsparametrar från en "
"funktion till en annan?"

#: ../../faq/programming.rst:396
msgid ""
"Collect the arguments using the ``*`` and ``**`` specifiers in the "
"function's parameter list; this gives you the positional arguments as a "
"tuple and the keyword arguments as a dictionary.  You can then pass these "
"arguments when calling another function by using ``*`` and ``**``::"
msgstr ""
"Samla argumenten med hjälp av specifikatorerna ``*`` och ``**`` i "
"funktionens parameterlista, så att du får de positionella argumenten som en "
"tupel och nyckelordsargumenten som en ordbok.  Du kan sedan skicka dessa "
"argument när du anropar en annan funktion genom att använda ``*`` och "
"``**``::"

#: ../../faq/programming.rst:401
msgid ""
"def f(x, *args, **kwargs):\n"
"    ...\n"
"    kwargs['width'] = '14.3c'\n"
"    ...\n"
"    g(x, *args, **kwargs)"
msgstr ""
"def f(x, *args, **kwargs):\n"
"    ...\n"
"    kwargs['bredd'] = '14.3c'\n"
"    ...\n"
"    g(x, *args, **kwargs)"

#: ../../faq/programming.rst:415
msgid "What is the difference between arguments and parameters?"
msgstr "Vad är skillnaden mellan argument och parametrar?"

#: ../../faq/programming.rst:417
msgid ""
":term:`Parameters <parameter>` are defined by the names that appear in a "
"function definition, whereas :term:`arguments <argument>` are the values "
"actually passed to a function when calling it.  Parameters define what "
":term:`kind of arguments <parameter>` a function can accept.  For example, "
"given the function definition::"
msgstr ""
":term:`Parametrar <parameter>` definieras av de namn som förekommer i en "
"funktionsdefinition, medan :term:`argument <argument>` är de värden som "
"faktiskt skickas till en funktion när den anropas.  Parametrar definierar "
"vilken :term:`typ av argument <parameter>` som en funktion kan acceptera.  "
"Till exempel, givet funktionsdefinitionen::"

#: ../../faq/programming.rst:423
msgid ""
"def func(foo, bar=None, **kwargs):\n"
"    pass"
msgstr ""
"def func(foo, bar=None, **kwargs):\n"
"    pass"

#: ../../faq/programming.rst:426
msgid ""
"*foo*, *bar* and *kwargs* are parameters of ``func``.  However, when calling"
" ``func``, for example::"
msgstr ""
"*foo*, *bar* och *kwargs* är parametrar för ``func``.  Men när man anropar "
"``func``, till exempel::"

#: ../../faq/programming.rst:429
msgid "func(42, bar=314, extra=somevar)"
msgstr "func(42, bar=314, extra=somevar)"

#: ../../faq/programming.rst:431
msgid "the values ``42``, ``314``, and ``somevar`` are arguments."
msgstr "värdena ``42``, ``314`` och ``somevar`` är argument."

#: ../../faq/programming.rst:435
msgid "Why did changing list 'y' also change list 'x'?"
msgstr "Varför ändrades listan \"y\" samtidigt som listan \"x\" ändrades?"

#: ../../faq/programming.rst:437
msgid "If you wrote code like::"
msgstr "Om du skrev kod som::"

#: ../../faq/programming.rst:439
msgid ""
">>> x = []\n"
">>> y = x\n"
">>> y.append(10)\n"
">>> y\n"
"[10]\n"
">>> x\n"
"[10]"
msgstr ""
">>> x = []\n"
">>> y = x\n"
">>> y.append(10)\n"
">>> y\n"
"[10]\n"
">>> x\n"
"[10]"

#: ../../faq/programming.rst:447
msgid ""
"you might be wondering why appending an element to ``y`` changed ``x`` too."
msgstr ""
"kanske du undrar varför ett tillägg av ett element till ``y`` ändrade ``x`` "
"också."

#: ../../faq/programming.rst:449
msgid "There are two factors that produce this result:"
msgstr "Det finns två faktorer som ger detta resultat:"

#: ../../faq/programming.rst:451
msgid ""
"Variables are simply names that refer to objects.  Doing ``y = x`` doesn't "
"create a copy of the list -- it creates a new variable ``y`` that refers to "
"the same object ``x`` refers to.  This means that there is only one object "
"(the list), and both ``x`` and ``y`` refer to it."
msgstr ""
"Variabler är helt enkelt namn som refererar till objekt.  Om du gör ``y = "
"x`` skapas inte en kopia av listan - det skapas en ny variabel ``y`` som "
"refererar till samma objekt som ``x`` refererar till.  Det betyder att det "
"bara finns ett objekt (listan) och att både ``x`` och ``y`` refererar till "
"det."

#: ../../faq/programming.rst:455
msgid ""
"Lists are :term:`mutable`, which means that you can change their content."
msgstr ""
"Listor är :term:`mutable`, vilket innebär att du kan ändra deras innehåll."

#: ../../faq/programming.rst:457
msgid ""
"After the call to :meth:`~sequence.append`, the content of the mutable "
"object has changed from ``[]`` to ``[10]``.  Since both the variables refer "
"to the same object, using either name accesses the modified value ``[10]``."
msgstr ""

#: ../../faq/programming.rst:461
msgid "If we instead assign an immutable object to ``x``::"
msgstr "Om vi istället tilldelar ett oföränderligt objekt till ``x``::"

#: ../../faq/programming.rst:463
msgid ""
">>> x = 5  # ints are immutable\n"
">>> y = x\n"
">>> x = x + 1  # 5 can't be mutated, we are creating a new object here\n"
">>> x\n"
"6\n"
">>> y\n"
"5"
msgstr ""
">>> x = 5  # ints are immutable\n"
">>> y = x\n"
">>> x = x + 1  # 5 can't be mutated, we are creating a new object here\n"
">>> x\n"
"6\n"
">>> y\n"
"5"

#: ../../faq/programming.rst:471
msgid ""
"we can see that in this case ``x`` and ``y`` are not equal anymore.  This is"
" because integers are :term:`immutable`, and when we do ``x = x + 1`` we are"
" not mutating the int ``5`` by incrementing its value; instead, we are "
"creating a new object (the int ``6``) and assigning it to ``x`` (that is, "
"changing which object ``x`` refers to).  After this assignment we have two "
"objects (the ints ``6`` and ``5``) and two variables that refer to them "
"(``x`` now refers to ``6`` but ``y`` still refers to ``5``)."
msgstr ""
"kan vi se att i detta fall är ``x`` och ``y`` inte lika längre.  Detta beror"
" på att heltal är :term:`immutable`, och när vi gör ``x = x + 1`` muterar vi"
" inte int ``5`` genom att öka dess värde; istället skapar vi ett nytt objekt"
" (int ``6``) och tilldelar det till ``x`` (det vill säga ändrar vilket "
"objekt ``x`` refererar till).  Efter denna tilldelning har vi två objekt "
"(int ``6`` och ``5``) och två variabler som hänvisar till dem (``x`` "
"hänvisar nu till ``6`` men ``y`` hänvisar fortfarande till ``5``)."

#: ../../faq/programming.rst:479
msgid ""
"Some operations (for example ``y.append(10)`` and ``y.sort()``) mutate the "
"object, whereas superficially similar operations (for example ``y = y + "
"[10]`` and :func:`sorted(y) <sorted>`) create a new object.  In general in "
"Python (and in all cases in the standard library) a method that mutates an "
"object will return ``None`` to help avoid getting the two types of "
"operations confused.  So if you mistakenly write ``y.sort()`` thinking it "
"will give you a sorted copy of ``y``, you'll instead end up with ``None``, "
"which will likely cause your program to generate an easily diagnosed error."
msgstr ""
"Vissa operationer (till exempel ``y.append(10)`` och ``y.sort()``) muterar "
"objektet, medan ytligt sett liknande operationer (till exempel ``y = y + "
"[10]`` och :func:`sorted(y) <sorted>`) skapar ett nytt objekt.  I allmänhet "
"i Python (och i alla fall i standardbiblioteket) kommer en metod som muterar"
" ett objekt att returnera ``None`` för att undvika att de två typerna av "
"operationer förväxlas.  Så om du felaktigt skriver ``y.sort()`` och tror att"
" det kommer att ge dig en sorterad kopia av ``y``, kommer du istället att "
"sluta med ``None``, vilket sannolikt kommer att leda till att ditt program "
"genererar ett lättdiagnostiserat fel."

#: ../../faq/programming.rst:488
msgid ""
"However, there is one class of operations where the same operation sometimes"
" has different behaviors with different types:  the augmented assignment "
"operators.  For example, ``+=`` mutates lists but not tuples or ints "
"(``a_list += [1, 2, 3]`` is equivalent to ``a_list.extend([1, 2, 3])`` and "
"mutates ``a_list``, whereas ``some_tuple += (1, 2, 3)`` and ``some_int += "
"1`` create new objects)."
msgstr ""
"Det finns dock en klass av operationer där samma operation ibland har olika "
"beteenden med olika typer: de utökade tilldelningsoperatorerna.  Till "
"exempel muterar ``+=`` listor men inte tupler eller ints (``a_list += [1, 2,"
" 3]`` motsvarar ``a_list.extend([1, 2, 3])`` och muterar ``a_list``, medan "
"``some_tuple += (1, 2, 3)`` och ``some_int += 1`` skapar nya objekt)."

#: ../../faq/programming.rst:495
msgid "In other words:"
msgstr "Med andra ord..:"

#: ../../faq/programming.rst:497
msgid ""
"If we have a mutable object (:class:`list`, :class:`dict`, :class:`set`, "
"etc.), we can use some specific operations to mutate it and all the "
"variables that refer to it will see the change."
msgstr ""
"Om vi har ett muterbart objekt (:class:`list`, :class:`dict`, :class:`set`, "
"etc.), kan vi använda vissa specifika operationer för att mutera det och "
"alla variabler som hänvisar till det kommer att se förändringen."

#: ../../faq/programming.rst:500
msgid ""
"If we have an immutable object (:class:`str`, :class:`int`, :class:`tuple`, "
"etc.), all the variables that refer to it will always see the same value, "
"but operations that transform that value into a new value always return a "
"new object."
msgstr ""
"Om vi har ett oföränderligt objekt (:class:`str`, :class:`int`, "
":class:`tuple`, etc.) kommer alla variabler som refererar till det alltid "
"att ha samma värde, men operationer som omvandlar det värdet till ett nytt "
"värde returnerar alltid ett nytt objekt."

#: ../../faq/programming.rst:505
msgid ""
"If you want to know if two variables refer to the same object or not, you "
"can use the :keyword:`is` operator, or the built-in function :func:`id`."
msgstr ""
"Om du vill veta om två variabler refererar till samma objekt eller inte, kan"
" du använda operatorn :keyword:`is` eller den inbyggda funktionen "
":func:`id`."

#: ../../faq/programming.rst:510
msgid "How do I write a function with output parameters (call by reference)?"
msgstr "Hur skriver jag en funktion med utparametrar (call by reference)?"

#: ../../faq/programming.rst:512
msgid ""
"Remember that arguments are passed by assignment in Python.  Since "
"assignment just creates references to objects, there's no alias between an "
"argument name in the caller and callee, and so no call-by-reference per se."
"  You can achieve the desired effect in a number of ways."
msgstr ""
"Kom ihåg att argument skickas via assignment i Python.  Eftersom tilldelning"
" bara skapar referenser till objekt finns det inget alias mellan ett "
"argumentnamn i den som anropar och den som tar emot anropet, och därmed "
"inget anrop genom referens i sig.  Du kan uppnå önskad effekt på ett antal "
"olika sätt."

#: ../../faq/programming.rst:517
msgid "By returning a tuple of the results::"
msgstr "Genom att returnera en tupel av resultaten::"

#: ../../faq/programming.rst:519
msgid ""
">>> def func1(a, b):\n"
"...     a = 'new-value'        # a and b are local names\n"
"...     b = b + 1              # assigned to new objects\n"
"...     return a, b            # return new values\n"
"...\n"
">>> x, y = 'old-value', 99\n"
">>> func1(x, y)\n"
"('new-value', 100)"
msgstr ""
">>> def func1(a, b):\n"
"...     a = 'new-value'        # a and b are local names\n"
"...     b = b + 1              # assigned to new objects\n"
"...     return a, b            # return new values\n"
"...\n"
">>> x, y = 'old-value', 99\n"
">>> func1(x, y)\n"
"('new-value', 100)"

#: ../../faq/programming.rst:528
msgid "This is almost always the clearest solution."
msgstr "Detta är nästan alltid den tydligaste lösningen."

#: ../../faq/programming.rst:530
msgid ""
"By using global variables.  This isn't thread-safe, and is not recommended."
msgstr ""
"Genom att använda globala variabler.  Detta är inte trådsäkert och "
"rekommenderas inte."

#: ../../faq/programming.rst:532
msgid "By passing a mutable (changeable in-place) object::"
msgstr "Genom att skicka ett muterbart (förändringsbart på plats) objekt::"

#: ../../faq/programming.rst:534
msgid ""
">>> def func2(a):\n"
"...     a[0] = 'new-value'     # 'a' references a mutable list\n"
"...     a[1] = a[1] + 1        # changes a shared object\n"
"...\n"
">>> args = ['old-value', 99]\n"
">>> func2(args)\n"
">>> args\n"
"['new-value', 100]"
msgstr ""
">>> def func2(a):\n"
"...     a[0] = 'new-value'     # 'a' references a mutable list\n"
"...     a[1] = a[1] + 1        # changes a shared object\n"
"...\n"
">>> args = ['old-value', 99]\n"
">>> func2(args)\n"
">>> args\n"
"['new-value', 100]"

#: ../../faq/programming.rst:543
msgid "By passing in a dictionary that gets mutated::"
msgstr "Genom att skicka in en ordbok som muteras::"

#: ../../faq/programming.rst:545
msgid ""
">>> def func3(args):\n"
"...     args['a'] = 'new-value'     # args is a mutable dictionary\n"
"...     args['b'] = args['b'] + 1   # change it in-place\n"
"...\n"
">>> args = {'a': 'old-value', 'b': 99}\n"
">>> func3(args)\n"
">>> args\n"
"{'a': 'new-value', 'b': 100}"
msgstr ""
">>> def func3(args):\n"
"...     args['a'] = 'new-value'     # args is a mutable dictionary\n"
"...     args['b'] = args['b'] + 1   # change it in-place\n"
"...\n"
">>> args = {'a': 'old-value', 'b': 99}\n"
">>> func3(args)\n"
">>> args\n"
"{'a': 'new-value', 'b': 100}"

#: ../../faq/programming.rst:554
msgid "Or bundle up values in a class instance::"
msgstr "Eller samla ihop värden i en klassinstans::"

#: ../../faq/programming.rst:556
msgid ""
">>> class Namespace:\n"
"...     def __init__(self, /, **args):\n"
"...         for key, value in args.items():\n"
"...             setattr(self, key, value)\n"
"...\n"
">>> def func4(args):\n"
"...     args.a = 'new-value'        # args is a mutable Namespace\n"
"...     args.b = args.b + 1         # change object in-place\n"
"...\n"
">>> args = Namespace(a='old-value', b=99)\n"
">>> func4(args)\n"
">>> vars(args)\n"
"{'a': 'new-value', 'b': 100}"
msgstr ""
">>> class Namespace:\n"
"...     def __init__(self, /, **args):\n"
"...         for key, value in args.items():\n"
"...             setattr(self, key, value)\n"
"...\n"
">>> def func4(args):\n"
"...     args.a = 'new-value'        # args is a mutable Namespace\n"
"...     args.b = args.b + 1         # change object in-place\n"
"...\n"
">>> args = Namespace(a='old-value', b=99)\n"
">>> func4(args)\n"
">>> vars(args)\n"
"{'a': 'new-value', 'b': 100}"

#: ../../faq/programming.rst:571
msgid "There's almost never a good reason to get this complicated."
msgstr ""
"Det finns nästan aldrig någon bra anledning att göra det så här komplicerat."

#: ../../faq/programming.rst:573
msgid "Your best choice is to return a tuple containing the multiple results."
msgstr ""
"Det bästa alternativet är att returnera en tupel som innehåller flera "
"resultat."

#: ../../faq/programming.rst:577
msgid "How do you make a higher order function in Python?"
msgstr "Hur gör man en funktion av högre ordning i Python?"

#: ../../faq/programming.rst:579
msgid ""
"You have two choices: you can use nested scopes or you can use callable "
"objects. For example, suppose you wanted to define ``linear(a,b)`` which "
"returns a function ``f(x)`` that computes the value ``a*x+b``.  Using nested"
" scopes::"
msgstr ""
"Du har två val: du kan använda nästlade scopes eller så kan du använda "
"anropsbara objekt. Anta till exempel att du vill definiera ``linear(a,b)`` "
"som returnerar en funktion ``f(x)`` som beräknar värdet ``a*x+b``.  Använda "
"nästlade scopes::"

#: ../../faq/programming.rst:583
msgid ""
"def linear(a, b):\n"
"    def result(x):\n"
"        return a * x + b\n"
"    return result"
msgstr ""
"def linear(a, b):\n"
"    def resultat(x):\n"
"        returnerar a * x + b\n"
"    returnera resultat"

#: ../../faq/programming.rst:588
msgid "Or using a callable object::"
msgstr "Eller använda ett anropsbart objekt::"

#: ../../faq/programming.rst:590
msgid ""
"class linear:\n"
"\n"
"    def __init__(self, a, b):\n"
"        self.a, self.b = a, b\n"
"\n"
"    def __call__(self, x):\n"
"        return self.a * x + self.b"
msgstr ""
"class linear:\n"
"\n"
"    def __init__(self, a, b):\n"
"        self.a, self.b = a, b\n"
"\n"
"    def __call__(self, x):\n"
"        return self.a * x + self.b"

#: ../../faq/programming.rst:598
msgid "In both cases, ::"
msgstr "I båda fallen gäller::"

#: ../../faq/programming.rst:600
msgid "taxes = linear(0.3, 2)"
msgstr "skatter = linjär(0,3, 2)"

#: ../../faq/programming.rst:602
msgid "gives a callable object where ``taxes(10e6) == 0.3 * 10e6 + 2``."
msgstr "ger ett anropbart objekt där ``taxes(10e6) == 0.3 * 10e6 + 2``."

#: ../../faq/programming.rst:604
msgid ""
"The callable object approach has the disadvantage that it is a bit slower "
"and results in slightly longer code.  However, note that a collection of "
"callables can share their signature via inheritance::"
msgstr ""
"Metoden med anropsbara objekt har nackdelen att den är lite långsammare och "
"resulterar i något längre kod.  Observera dock att en samling callables kan "
"dela sin signatur via arv::"

#: ../../faq/programming.rst:608
msgid ""
"class exponential(linear):\n"
"    # __init__ inherited\n"
"    def __call__(self, x):\n"
"        return self.a * (x ** self.b)"
msgstr ""
"class exponential(linear):\n"
"    # __init__ inherited\n"
"    def __call__(self, x):\n"
"        return self.a * (x ** self.b)"

#: ../../faq/programming.rst:613
msgid "Object can encapsulate state for several methods::"
msgstr "Objekt kan kapsla in tillstånd för flera metoder::"

#: ../../faq/programming.rst:615
msgid ""
"class counter:\n"
"\n"
"    value = 0\n"
"\n"
"    def set(self, x):\n"
"        self.value = x\n"
"\n"
"    def up(self):\n"
"        self.value = self.value + 1\n"
"\n"
"    def down(self):\n"
"        self.value = self.value - 1\n"
"\n"
"count = counter()\n"
"inc, dec, reset = count.up, count.down, count.set"
msgstr ""
"class counter:\n"
"\n"
"    value = 0\n"
"\n"
"    def set(self, x):\n"
"        self.value = x\n"
"\n"
"    def up(self):\n"
"        self.value = self.value + 1\n"
"\n"
"    def down(self):\n"
"        self.value = self.value - 1\n"
"\n"
"count = counter()\n"
"inc, dec, reset = count.up, count.down, count.set"

#: ../../faq/programming.rst:631
msgid ""
"Here ``inc()``, ``dec()`` and ``reset()`` act like functions which share the"
" same counting variable."
msgstr ""
"Här fungerar ``inc()``, ``dec()`` och ``reset()`` som funktioner som delar "
"samma räknevariabel."

#: ../../faq/programming.rst:636
msgid "How do I copy an object in Python?"
msgstr "Hur kopierar jag ett objekt i Python?"

#: ../../faq/programming.rst:638
msgid ""
"In general, try :func:`copy.copy` or :func:`copy.deepcopy` for the general "
"case. Not all objects can be copied, but most can."
msgstr ""
"I allmänhet kan du prova :func:`copy.copy` eller :func:`copy.deepcopy` för "
"det allmänna fallet. Alla objekt kan inte kopieras, men de flesta kan det."

#: ../../faq/programming.rst:641
msgid ""
"Some objects can be copied more easily.  Dictionaries have a "
":meth:`~dict.copy` method::"
msgstr ""
"Vissa objekt kan kopieras lättare.  Dictionaries har en :meth:`~dict.copy` "
"metod::"

#: ../../faq/programming.rst:644
msgid "newdict = olddict.copy()"
msgstr "newdict = olddict.copy()"

#: ../../faq/programming.rst:646
msgid "Sequences can be copied by slicing::"
msgstr "Sekvenser kan kopieras genom att skära::"

#: ../../faq/programming.rst:648
msgid "new_l = l[:]"
msgstr "ny_l = l[:]"

#: ../../faq/programming.rst:652
msgid "How can I find the methods or attributes of an object?"
msgstr "Hur hittar jag metoder eller attribut för ett objekt?"

#: ../../faq/programming.rst:654
msgid ""
"For an instance ``x`` of a user-defined class, :func:`dir(x) <dir>` returns "
"an alphabetized list of the names containing the instance attributes and "
"methods and attributes defined by its class."
msgstr ""
"För en instans ``x`` av en användardefinierad klass returnerar :func:`dir(x)"
" <dir>` en alfabetiserad lista över de namn som innehåller de "
"instansattribut, metoder och attribut som definieras av klassen."

#: ../../faq/programming.rst:660
msgid "How can my code discover the name of an object?"
msgstr "Hur kan min kod ta reda på namnet på ett objekt?"

#: ../../faq/programming.rst:662
msgid ""
"Generally speaking, it can't, because objects don't really have names. "
"Essentially, assignment always binds a name to a value; the same is true of "
"``def`` and ``class`` statements, but in that case the value is a callable. "
"Consider the following code::"
msgstr ""
"Generellt sett kan det inte det, eftersom objekt egentligen inte har några "
"namn. I princip binder assignment alltid ett namn till ett värde; samma sak "
"gäller för ``def`` och ``class`` statements, men i det fallet är värdet en "
"callable. Tänk på följande kod::"

#: ../../faq/programming.rst:667
msgid ""
">>> class A:\n"
"...     pass\n"
"...\n"
">>> B = A\n"
">>> a = B()\n"
">>> b = a\n"
">>> print(b)\n"
"<__main__.A object at 0x16D07CC>\n"
">>> print(a)\n"
"<__main__.A object at 0x16D07CC>"
msgstr ""
">>> class A:\n"
"...     pass\n"
"...\n"
">>> B = A\n"
">>> a = B()\n"
">>> b = a\n"
">>> print(b)\n"
"<__main__.A object at 0x16D07CC>\n"
">>> print(a)\n"
"<__main__.A object at 0x16D07CC>"

#: ../../faq/programming.rst:678
msgid ""
"Arguably the class has a name: even though it is bound to two names and "
"invoked through the name ``B`` the created instance is still reported as an "
"instance of class ``A``.  However, it is impossible to say whether the "
"instance's name is ``a`` or ``b``, since both names are bound to the same "
"value."
msgstr ""
"Man kan hävda att klassen har ett namn: även om den är bunden till två namn "
"och anropas via namnet ``B`` rapporteras den skapade instansen fortfarande "
"som en instans av klassen ``A``.  Det är dock omöjligt att säga om "
"instansens namn är ``a`` eller ``b``, eftersom båda namnen är bundna till "
"samma värde."

#: ../../faq/programming.rst:683
msgid ""
"Generally speaking it should not be necessary for your code to \"know the "
"names\" of particular values. Unless you are deliberately writing "
"introspective programs, this is usually an indication that a change of "
"approach might be beneficial."
msgstr ""
"Generellt sett bör det inte vara nödvändigt för din kod att \"känna till "
"namnen\" på vissa värden. Om du inte avsiktligt skriver introspektiva "
"program är detta vanligtvis en indikation på att det kan vara bra att ändra "
"tillvägagångssätt."

#: ../../faq/programming.rst:688
msgid ""
"In comp.lang.python, Fredrik Lundh once gave an excellent analogy in answer "
"to this question:"
msgstr ""
"I comp.lang.python gav Fredrik Lundh en gång en utmärkt liknelse som svar på"
" denna fråga:"

#: ../../faq/programming.rst:691
msgid ""
"The same way as you get the name of that cat you found on your porch: the "
"cat (object) itself cannot tell you its name, and it doesn't really care -- "
"so the only way to find out what it's called is to ask all your neighbours "
"(namespaces) if it's their cat (object)..."
msgstr ""
"På samma sätt som du får reda på namnet på katten du hittade på din veranda:"
" katten (objektet) själv kan inte berätta vad den heter, och den bryr sig "
"egentligen inte - så det enda sättet att få reda på vad den heter är att "
"fråga alla dina grannar (namnrymder) om det är deras katt (objekt)..."

#: ../../faq/programming.rst:696
msgid ""
"....and don't be surprised if you'll find that it's known by many names, or "
"no name at all!"
msgstr ""
".... och bli inte förvånad om du upptäcker att den är känd under många namn,"
" eller inget namn alls!"

#: ../../faq/programming.rst:701
msgid "What's up with the comma operator's precedence?"
msgstr "Vad är det med kommatecknets företräde?"

#: ../../faq/programming.rst:703
msgid "Comma is not an operator in Python.  Consider this session::"
msgstr "Komma är inte en operator i Python.  Tänk på denna session::"

#: ../../faq/programming.rst:705
msgid ""
">>> \"a\" in \"b\", \"a\"\n"
"(False, 'a')"
msgstr ""
">>> \"a\" in \"b\", \"a\"\n"
"(False, 'a')"

#: ../../faq/programming.rst:708
msgid ""
"Since the comma is not an operator, but a separator between expressions the "
"above is evaluated as if you had entered::"
msgstr ""
"Eftersom kommatecknet inte är en operator, utan en separator mellan uttryck,"
" utvärderas ovanstående som om du hade skrivit::"

#: ../../faq/programming.rst:711
msgid "(\"a\" in \"b\"), \"a\""
msgstr "(\"a\" i \"b\"), \"a\""

#: ../../faq/programming.rst:713
msgid "not::"
msgstr "inte::"

#: ../../faq/programming.rst:715
msgid "\"a\" in (\"b\", \"a\")"
msgstr "\"a\" i (\"b\", \"a\")"

#: ../../faq/programming.rst:717
msgid ""
"The same is true of the various assignment operators (``=``, ``+=`` etc).  "
"They are not truly operators but syntactic delimiters in assignment "
"statements."
msgstr ""
"Detsamma gäller för de olika tilldelningsoperatorerna (``=``, ``+=`` etc).  "
"De är egentligen inte operatorer utan syntaktiska avgränsare i assignment-"
"satser."

#: ../../faq/programming.rst:722
msgid "Is there an equivalent of C's \"?:\" ternary operator?"
msgstr "Finns det en motsvarighet till C:s \"?:\" ternära operator?"

#: ../../faq/programming.rst:724
msgid "Yes, there is. The syntax is as follows::"
msgstr "Ja, det finns det. Syntaxen är som följer::"

#: ../../faq/programming.rst:726
msgid ""
"[on_true] if [expression] else [on_false]\n"
"\n"
"x, y = 50, 25\n"
"small = x if x < y else y"
msgstr ""
"[on_true] if [expression] else [on_false]\n"
"\n"
"x, y = 50, 25\n"
"small = x om x < y annars y"

#: ../../faq/programming.rst:731
msgid ""
"Before this syntax was introduced in Python 2.5, a common idiom was to use "
"logical operators::"
msgstr ""
"Innan denna syntax introducerades i Python 2.5 var ett vanligt idiom att "
"använda logiska operatorer::"

#: ../../faq/programming.rst:734
msgid "[expression] and [on_true] or [on_false]"
msgstr "[uttryck] och [on_true] eller [on_false]"

#: ../../faq/programming.rst:736
msgid ""
"However, this idiom is unsafe, as it can give wrong results when *on_true* "
"has a false boolean value.  Therefore, it is always better to use the ``... "
"if ... else ...`` form."
msgstr ""
"Detta idiom är dock osäkert, eftersom det kan ge fel resultat när *on_true* "
"har ett falskt booleskt värde.  Därför är det alltid bättre att använda "
"formen ``... if ... else ...``."

#: ../../faq/programming.rst:742
msgid "Is it possible to write obfuscated one-liners in Python?"
msgstr "Är det möjligt att skriva obfuskerade one-liners i Python?"

#: ../../faq/programming.rst:744
msgid ""
"Yes.  Usually this is done by nesting :keyword:`lambda` within "
":keyword:`!lambda`.  See the following three examples, slightly adapted from"
" Ulf Bartelt::"
msgstr ""
"Ja, det gör jag.  Vanligtvis görs detta genom att nesta :keyword:`lambda` "
"inom :keyword:`!lambda`.  Se följande tre exempel, något anpassade från Ulf "
"Bartelt::"

#: ../../faq/programming.rst:747
msgid ""
"from functools import reduce\n"
"\n"
"# Primes < 1000\n"
"print(list(filter(None,map(lambda y:y*reduce(lambda x,y:x*y!=0,\n"
"map(lambda x,y=y:y%x,range(2,int(pow(y,0.5)+1))),1),range(2,1000)))))\n"
"\n"
"# First 10 Fibonacci numbers\n"
"print(list(map(lambda x,f=lambda x,f:(f(x-1,f)+f(x-2,f)) if x>1 else 1:\n"
"f(x,f), range(10))))\n"
"\n"
"# Mandelbrot set\n"
"print((lambda Ru,Ro,Iu,Io,IM,Sx,Sy:reduce(lambda x,y:x+'\\n'+y,map(lambda y,\n"
"Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,Sy=Sy,L=lambda yc,Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,i=IM,\n"
"Sx=Sx,Sy=Sy:reduce(lambda x,y:x+y,map(lambda x,xc=Ru,yc=yc,Ru=Ru,Ro=Ro,\n"
"i=i,Sx=Sx,F=lambda xc,yc,x,y,k,f=lambda xc,yc,x,y,k,f:(k<=0)or (x*x+y*y\n"
">=4.0) or 1+f(xc,yc,x*x-y*y+xc,2.0*x*y+yc,k-1,f):f(xc,yc,x,y,k,f):chr(\n"
"64+F(Ru+x*(Ro-Ru)/Sx,yc,0,0,i)),range(Sx))):L(Iu+y*(Io-Iu)/Sy),range(Sy\n"
"))))(-2.1, 0.7, -1.2, 1.2, 30, 80, 24))\n"
"#    \\___ ___/  \\___ ___/  |   |   |__ lines on screen\n"
"#        V          V      |   |______ columns on screen\n"
"#        |          |      |__________ maximum of \"iterations\"\n"
"#        |          |_________________ range on y axis\n"
"#        |____________________________ range on x axis"
msgstr ""
"from functools import reduce\n"
"\n"
"# Primes < 1000\n"
"print(list(filter(None,map(lambda y:y*reduce(lambda x,y:x*y!=0,\n"
"map(lambda x,y=y:y%x,range(2,int(pow(y,0.5)+1))),1),range(2,1000)))))\n"
"\n"
"# First 10 Fibonacci numbers\n"
"print(list(map(lambda x,f=lambda x,f:(f(x-1,f)+f(x-2,f)) if x>1 else 1:\n"
"f(x,f), range(10))))\n"
"\n"
"# Mandelbrot set\n"
"print((lambda Ru,Ro,Iu,Io,IM,Sx,Sy:reduce(lambda x,y:x+'\\n'+y,map(lambda y,\n"
"Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,Sy=Sy,L=lambda yc,Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,i=IM,\n"
"Sx=Sx,Sy=Sy:reduce(lambda x,y:x+y,map(lambda x,xc=Ru,yc=yc,Ru=Ru,Ro=Ro,\n"
"i=i,Sx=Sx,F=lambda xc,yc,x,y,k,f=lambda xc,yc,x,y,k,f:(k<=0)or (x*x+y*y\n"
">=4.0) or 1+f(xc,yc,x*x-y*y+xc,2.0*x*y+yc,k-1,f):f(xc,yc,x,y,k,f):chr(\n"
"64+F(Ru+x*(Ro-Ru)/Sx,yc,0,0,i)),range(Sx))):L(Iu+y*(Io-Iu)/Sy),range(Sy\n"
"))))(-2.1, 0.7, -1.2, 1.2, 30, 80, 24))\n"
"#    \\___ ___/  \\___ ___/  |   |   |__ lines on screen\n"
"#        V          V      |   |______ columns on screen\n"
"#        |          |      |__________ maximum of \"iterations\"\n"
"#        |          |_________________ range on y axis\n"
"#        |____________________________ range on x axis"

#: ../../faq/programming.rst:771
msgid "Don't try this at home, kids!"
msgstr "Prova inte det här hemma, barn!"

#: ../../faq/programming.rst:777
msgid "What does the slash(/) in the parameter list of a function mean?"
msgstr "Vad betyder snedstrecket(/) i parameterlistan för en funktion?"

#: ../../faq/programming.rst:779
msgid ""
"A slash in the argument list of a function denotes that the parameters prior"
" to it are positional-only.  Positional-only parameters are the ones without"
" an externally usable name.  Upon calling a function that accepts "
"positional-only parameters, arguments are mapped to parameters based solely "
"on their position. For example, :func:`divmod` is a function that accepts "
"positional-only parameters. Its documentation looks like this::"
msgstr ""
"Ett snedstreck i argumentlistan för en funktion anger att parametrarna före "
"det är enbart positionella.  Endast positionella parametrar är de som saknar"
" ett externt användbart namn.  När du anropar en funktion som accepterar "
"enbart positionella parametrar mappas argumenten till parametrar enbart "
"baserat på deras position. Exempelvis är :func:`divmod` en funktion som "
"accepterar enbart positionella parametrar. Dess dokumentation ser ut så "
"här::"

#: ../../faq/programming.rst:786
msgid ""
">>> help(divmod)\n"
"Help on built-in function divmod in module builtins:\n"
"\n"
"divmod(x, y, /)\n"
"    Return the tuple (x//y, x%y).  Invariant: div*y + mod == x."
msgstr ""
">>> help(divmod)\n"
"Help on built-in function divmod in module builtins:\n"
"\n"
"divmod(x, y, /)\n"
"    Return the tuple (x//y, x%y).  Invariant: div*y + mod == x."

#: ../../faq/programming.rst:792
msgid ""
"The slash at the end of the parameter list means that both parameters are "
"positional-only. Thus, calling :func:`divmod` with keyword arguments would "
"lead to an error::"
msgstr ""
"Snedstrecket i slutet av parameterlistan betyder att båda parametrarna "
"endast är positionella. Således skulle ett anrop av :func:`divmod` med "
"nyckelordsargument leda till ett fel::"

#: ../../faq/programming.rst:796
msgid ""
">>> divmod(x=3, y=4)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: divmod() takes no keyword arguments"
msgstr ""
">>> divmod(x=3, y=4)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: divmod() takes no keyword arguments"

#: ../../faq/programming.rst:803
msgid "Numbers and strings"
msgstr "Siffror och strängar"

#: ../../faq/programming.rst:806
msgid "How do I specify hexadecimal and octal integers?"
msgstr "Hur anger jag hexadecimala och oktala heltal?"

#: ../../faq/programming.rst:808
msgid ""
"To specify an octal digit, precede the octal value with a zero, and then a "
"lower or uppercase \"o\".  For example, to set the variable \"a\" to the "
"octal value \"10\" (8 in decimal), type::"
msgstr ""
"För att ange en oktalsiffra föregår du oktalvärdet med en nolla och sedan "
"ett litet eller stort \"o\".  Om du till exempel vill ställa in variabeln "
"\"a\" till oktalvärdet \"10\" (8 i decimal) skriver du::"

#: ../../faq/programming.rst:812
msgid ""
">>> a = 0o10\n"
">>> a\n"
"8"
msgstr ""
">>> a = 0o10\n"
">>> a\n"
"8"

#: ../../faq/programming.rst:816
msgid ""
"Hexadecimal is just as easy.  Simply precede the hexadecimal number with a "
"zero, and then a lower or uppercase \"x\".  Hexadecimal digits can be "
"specified in lower or uppercase.  For example, in the Python interpreter::"
msgstr ""
"Hexadecimalt är lika enkelt.  Det hexadecimala talet föregås helt enkelt av "
"en nolla och sedan ett \"x\" med liten eller stor bokstav.  Hexadecimala "
"siffror kan anges med små eller stora bokstäver.  Till exempel i Python-"
"tolken::"

#: ../../faq/programming.rst:820
msgid ""
">>> a = 0xa5\n"
">>> a\n"
"165\n"
">>> b = 0XB2\n"
">>> b\n"
"178"
msgstr ""
">>> a = 0xa5\n"
">>> a\n"
"165\n"
">>> b = 0XB2\n"
">>> b\n"
"178"

#: ../../faq/programming.rst:829
msgid "Why does -22 // 10 return -3?"
msgstr "Varför returnerar -22 // 10 -3?"

#: ../../faq/programming.rst:831
msgid ""
"It's primarily driven by the desire that ``i % j`` have the same sign as "
"``j``. If you want that, and also want::"
msgstr ""
"Den drivs främst av önskemålet att ``i % j`` ska ha samma tecken som ``j``. "
"Om du vill ha det, och också vill ha::"

#: ../../faq/programming.rst:834
msgid "i == (i // j) * j + (i % j)"
msgstr "i == (i // j) * j + (i % j)"

#: ../../faq/programming.rst:836
msgid ""
"then integer division has to return the floor.  C also requires that "
"identity to hold, and then compilers that truncate ``i // j`` need to make "
"``i % j`` have the same sign as ``i``."
msgstr ""
"så måste heltalsdivision ge golvet.  C kräver också att identiteten ska "
"gälla, och då måste kompilatorer som trunkerar ``i // j`` se till att ``i % "
"j`` har samma tecken som ``i``."

#: ../../faq/programming.rst:840
msgid ""
"There are few real use cases for ``i % j`` when ``j`` is negative.  When "
"``j`` is positive, there are many, and in virtually all of them it's more "
"useful for ``i % j`` to be ``>= 0``.  If the clock says 10 now, what did it "
"say 200 hours ago?  ``-190 % 12 == 2`` is useful; ``-190 % 12 == -10`` is a "
"bug waiting to bite."
msgstr ""
"Det finns få verkliga användningsfall för ``i % j`` när ``j`` är negativ.  "
"När ``j`` är positiv finns det många, och i praktiskt taget alla är det mer "
"användbart för ``i % j`` att vara ``>= 0``.  Om klockan visar 10 nu, vad "
"visade den då för 200 timmar sedan?  ``\\-190 % 12 == 2`` är användbart; "
"``\\-190 % 12 == -10`` är en bugg som väntar på att bita."

#: ../../faq/programming.rst:848
msgid "How do I get int literal attribute instead of SyntaxError?"
msgstr "Hur får jag int literal-attribut istället för SyntaxError?"

#: ../../faq/programming.rst:850
msgid ""
"Trying to lookup an ``int`` literal attribute in the normal manner gives a "
":exc:`SyntaxError` because the period is seen as a decimal point::"
msgstr ""
"Att försöka slå upp ett ``int`` bokstavligt attribut på normalt sätt ger ett"
" :exc:`SyntaxError` eftersom punkten ses som ett decimaltecken::"

#: ../../faq/programming.rst:853
msgid ""
">>> 1.__class__\n"
"  File \"<stdin>\", line 1\n"
"  1.__class__\n"
"   ^\n"
"SyntaxError: invalid decimal literal"
msgstr ""
">>> 1.__class__\n"
"  File \"<stdin>\", line 1\n"
"  1.__class__\n"
"   ^\n"
"SyntaxError: invalid decimal literal"

#: ../../faq/programming.rst:859
msgid ""
"The solution is to separate the literal from the period with either a space "
"or parentheses."
msgstr ""
"Lösningen är att skilja bokstav från punkt med antingen ett mellanslag eller"
" en parentes."

#: ../../faq/programming.rst:869
msgid "How do I convert a string to a number?"
msgstr "Hur konverterar jag en sträng till ett tal?"

#: ../../faq/programming.rst:871
msgid ""
"For integers, use the built-in :func:`int` type constructor, e.g. "
"``int('144') == 144``.  Similarly, :func:`float` converts to a floating-"
"point number, e.g. ``float('144') == 144.0``."
msgstr ""
"För heltal används den inbyggda typkonstruktören :func:`int`, t.ex. "
"``int('144') == 144``.  På samma sätt konverterar :func:`float` till ett "
"flyttal, t.ex. ``float('144') == 144.0``."

#: ../../faq/programming.rst:875
msgid ""
"By default, these interpret the number as decimal, so that ``int('0144') == "
"144`` holds true, and ``int('0x144')`` raises :exc:`ValueError`. "
"``int(string, base)`` takes the base to convert from as a second optional "
"argument, so ``int( '0x144', 16) == 324``.  If the base is specified as 0, "
"the number is interpreted using Python's rules: a leading '0o' indicates "
"octal, and '0x' indicates a hex number."
msgstr ""
"Som standard tolkar dessa talet som decimaltal, så att ``int('0144') == "
"144`` är sant och ``int('0x144')`` ger upphov till :exc:`ValueError`. "
"``int(string, base)`` tar basen att konvertera från som ett andra valfritt "
"argument, så ``int( '0x144', 16) == 324``.  Om basen anges som 0 tolkas "
"talet enligt Pythons regler: ett inledande '0o' indikerar oktal och '0x' "
"indikerar ett hextal."

#: ../../faq/programming.rst:882
msgid ""
"Do not use the built-in function :func:`eval` if all you need is to convert "
"strings to numbers.  :func:`eval` will be significantly slower and it "
"presents a security risk: someone could pass you a Python expression that "
"might have unwanted side effects.  For example, someone could pass "
"``__import__('os').system(\"rm -rf $HOME\")`` which would erase your home "
"directory."
msgstr ""
"Använd inte den inbyggda funktionen :func:`eval` om allt du behöver är att "
"konvertera strängar till tal. :func:`eval` blir betydligt långsammare och "
"det innebär en säkerhetsrisk: någon kan skicka ett Python-uttryck till dig "
"som kan ha oönskade bieffekter.  Till exempel skulle någon kunna skicka "
"``__import__('os').system(\"rm -rf $HOME\")`` vilket skulle radera din "
"hemkatalog."

#: ../../faq/programming.rst:889
msgid ""
":func:`eval` also has the effect of interpreting numbers as Python "
"expressions, so that e.g. ``eval('09')`` gives a syntax error because Python"
" does not allow leading '0' in a decimal number (except '0')."
msgstr ""
":func:`eval` har också effekten att siffror tolkas som Python-uttryck, så "
"att t.ex. ``eval('09')`` ger ett syntaxfel eftersom Python inte tillåter "
"inledande '0' i ett decimaltal (utom '0')."

#: ../../faq/programming.rst:895
msgid "How do I convert a number to a string?"
msgstr "Hur konverterar jag ett tal till en sträng?"

#: ../../faq/programming.rst:897
msgid ""
"To convert, e.g., the number ``144`` to the string ``'144'``, use the built-"
"in type constructor :func:`str`.  If you want a hexadecimal or octal "
"representation, use the built-in functions :func:`hex` or :func:`oct`.  For "
"fancy formatting, see the :ref:`f-strings` and :ref:`formatstrings` "
"sections, e.g. ``\"{:04d}\".format(144)`` yields ``'0144'`` and "
"``\"{:.3f}\".format(1.0/3.0)`` yields ``'0.333'``."
msgstr ""
"För att konvertera t.ex. talet ``144`` till strängen ``'144'``, använd den "
"inbyggda typkonstruktören :func:`str`.  Om du vill ha en hexadecimal eller "
"oktal representation, använd de inbyggda funktionerna :func:`hex` eller "
":func:`oct`.  För tjusig formatering, se avsnitten :ref:`f-strings` och "
":ref:`formatstrings`, t.ex. ``\"{:04d}\".format(144)`` ger ``'0144'`` och "
"``\"{:.3f}\".format(1.0/3.0)`` ger ``'0.333'``."

#: ../../faq/programming.rst:906
msgid "How do I modify a string in place?"
msgstr "Hur ändrar jag en sträng på plats?"

#: ../../faq/programming.rst:908
msgid ""
"You can't, because strings are immutable.  In most situations, you should "
"simply construct a new string from the various parts you want to assemble it"
" from.  However, if you need an object with the ability to modify in-place "
"unicode data, try using an :class:`io.StringIO` object or the :mod:`array` "
"module::"
msgstr ""
"Det kan du inte, eftersom strängar är oföränderliga.  I de flesta "
"situationer bör du helt enkelt konstruera en ny sträng från de olika delar "
"som du vill sätta ihop den av.  Men om du behöver ett objekt med möjlighet "
"att modifiera unicode-data på plats kan du försöka använda ett "
":class:`io.StringIO`\\-objekt eller :mod:`array`\\-modulen::"

#: ../../faq/programming.rst:914
msgid ""
">>> import io\n"
">>> s = \"Hello, world\"\n"
">>> sio = io.StringIO(s)\n"
">>> sio.getvalue()\n"
"'Hello, world'\n"
">>> sio.seek(7)\n"
"7\n"
">>> sio.write(\"there!\")\n"
"6\n"
">>> sio.getvalue()\n"
"'Hello, there!'\n"
"\n"
">>> import array\n"
">>> a = array.array('w', s)\n"
">>> print(a)\n"
"array('w', 'Hello, world')\n"
">>> a[0] = 'y'\n"
">>> print(a)\n"
"array('w', 'yello, world')\n"
">>> a.tounicode()\n"
"'yello, world'"
msgstr ""
">>> import io\n"
">>> s = \"Hello, world\"\n"
">>> sio = io.StringIO(s)\n"
">>> sio.getvalue()\n"
"'Hello, world'\n"
">>> sio.seek(7)\n"
"7\n"
">>> sio.write(\"there!\")\n"
"6\n"
">>> sio.getvalue()\n"
"'Hello, there!'\n"
"\n"
">>> import array\n"
">>> a = array.array('w', s)\n"
">>> print(a)\n"
"array('w', 'Hello, world')\n"
">>> a[0] = 'y'\n"
">>> print(a)\n"
"array('w', 'yello, world')\n"
">>> a.tounicode()\n"
"'yello, world'"

#: ../../faq/programming.rst:938
msgid "How do I use strings to call functions/methods?"
msgstr "Hur använder jag strängar för att anropa funktioner/metoder?"

#: ../../faq/programming.rst:940
msgid "There are various techniques."
msgstr "Det finns olika tekniker."

#: ../../faq/programming.rst:942
msgid ""
"The best is to use a dictionary that maps strings to functions.  The primary"
" advantage of this technique is that the strings do not need to match the "
"names of the functions.  This is also the primary technique used to emulate "
"a case construct::"
msgstr ""
"Det bästa är att använda en ordbok som mappar strängar till funktioner.  Den"
" främsta fördelen med den här tekniken är att strängarna inte behöver matcha"
" namnen på funktionerna.  Detta är också den primära teknik som används för "
"att emulera en fallkonstruktion::"

#: ../../faq/programming.rst:947
msgid ""
"def a():\n"
"    pass\n"
"\n"
"def b():\n"
"    pass\n"
"\n"
"dispatch = {'go': a, 'stop': b}  # Note lack of parens for funcs\n"
"\n"
"dispatch[get_input()]()  # Note trailing parens to call function"
msgstr ""
"def a():\n"
"    pass\n"
"\n"
"def b():\n"
"    pass\n"
"\n"
"dispatch = {'go': a, 'stop': b} # Observera avsaknad av parenteser för funcs\n"
"\n"
"dispatch[get_input()]() # Notera efterföljande parenteser för att anropa funktion"

#: ../../faq/programming.rst:957
msgid "Use the built-in function :func:`getattr`::"
msgstr "Använd den inbyggda funktionen :func:`getattr`::"

#: ../../faq/programming.rst:959
msgid ""
"import foo\n"
"getattr(foo, 'bar')()"
msgstr ""
"import foo\n"
"getattr(foo, 'bar')()"

#: ../../faq/programming.rst:962
msgid ""
"Note that :func:`getattr` works on any object, including classes, class "
"instances, modules, and so on."
msgstr ""
"Observera att :func:`getattr` fungerar på alla objekt, inklusive klasser, "
"klassinstanser, moduler och så vidare."

#: ../../faq/programming.rst:965
msgid "This is used in several places in the standard library, like this::"
msgstr ""
"Detta används på flera ställen i standardbiblioteket, till exempel så här::"

#: ../../faq/programming.rst:967
msgid ""
"class Foo:\n"
"    def do_foo(self):\n"
"        ...\n"
"\n"
"    def do_bar(self):\n"
"        ...\n"
"\n"
"f = getattr(foo_instance, 'do_' + opname)\n"
"f()"
msgstr ""
"class Foo:\n"
"    def do_foo(self):\n"
"        ...\n"
"\n"
"    def do_bar(self):\n"
"        ...\n"
"\n"
"f = getattr(foo_instance, 'do_' + opname)\n"
"f()"

#: ../../faq/programming.rst:978
msgid "Use :func:`locals` to resolve the function name::"
msgstr "Använd :func:`locals` för att lösa upp funktionsnamnet::"

#: ../../faq/programming.rst:980
msgid ""
"def myFunc():\n"
"    print(\"hello\")\n"
"\n"
"fname = \"myFunc\"\n"
"\n"
"f = locals()[fname]\n"
"f()"
msgstr ""
"def myFunc():\n"
"    print(\"hallå\")\n"
"\n"
"fname = \"myFunc\"\n"
"\n"
"f = locals()[fnamn]\n"
"f()"

#: ../../faq/programming.rst:990
msgid ""
"Is there an equivalent to Perl's ``chomp()`` for removing trailing newlines "
"from strings?"
msgstr ""
"Finns det en motsvarighet till Perls ``chomp()`` för att ta bort "
"efterföljande nya rader från strängar?"

#: ../../faq/programming.rst:992
msgid ""
"You can use ``S.rstrip(\"\\r\\n\")`` to remove all occurrences of any line "
"terminator from the end of the string ``S`` without removing other trailing "
"whitespace.  If the string ``S`` represents more than one line, with several"
" empty lines at the end, the line terminators for all the blank lines will "
"be removed::"
msgstr ""
"Du kan använda ``S.rstrip(\"\\r\\n\")`` för att ta bort alla förekomster av "
"en radavslutare från slutet av strängen ``S`` utan att ta bort andra "
"efterföljande blanksteg.  Om strängen ``S`` representerar mer än en rad, med"
" flera tomma rader i slutet, kommer radavslutarna för alla de tomma raderna "
"att tas bort::"

#: ../../faq/programming.rst:998
msgid ""
">>> lines = (\"line 1 \\r\\n\"\n"
"...          \"\\r\\n\"\n"
"...          \"\\r\\n\")\n"
">>> lines.rstrip(\"\\n\\r\")\n"
"'line 1 '"
msgstr ""
">>> lines = (\"line 1 \\r\\n\"\n"
"...          \"\\r\\n\"\n"
"...          \"\\r\\n\")\n"
">>> lines.rstrip(\"\\n\\r\")\n"
"'line 1 '"

#: ../../faq/programming.rst:1004
msgid ""
"Since this is typically only desired when reading text one line at a time, "
"using ``S.rstrip()`` this way works well."
msgstr ""
"Eftersom detta vanligtvis bara är önskvärt när man läser text en rad i "
"taget, fungerar det bra att använda ``S.rstrip()`` på detta sätt."

#: ../../faq/programming.rst:1009
msgid "Is there a ``scanf()`` or ``sscanf()`` equivalent?"
msgstr "Finns det en motsvarighet till ``scanf()`` eller ``sscanf()``?"

#: ../../faq/programming.rst:1011
msgid "Not as such."
msgstr "Inte som sådan."

#: ../../faq/programming.rst:1013
msgid ""
"For simple input parsing, the easiest approach is usually to split the line "
"into whitespace-delimited words using the :meth:`~str.split` method of "
"string objects and then convert decimal strings to numeric values using "
":func:`int` or :func:`float`.  :meth:`!split` supports an optional \"sep\" "
"parameter which is useful if the line uses something other than whitespace "
"as a separator."
msgstr ""
"För enkel parsning av indata är det enklast att dela upp raden i ord som är "
"avgränsade med blanksteg med hjälp av metoden :meth:`~str.split` för "
"strängobjekt och sedan konvertera decimalsträngar till numeriska värden med "
"hjälp av :func:`int` eller :func:`float`. :meth:`!split` stöder en valfri "
"parameter \"sep\" som är användbar om raden använder något annat än "
"blanksteg som avgränsare."

#: ../../faq/programming.rst:1019
msgid ""
"For more complicated input parsing, regular expressions are more powerful "
"than C's ``sscanf`` and better suited for the task."
msgstr ""
"För mer komplicerad parsning av indata är reguljära uttryck kraftfullare än "
"C:s ``sscanf`` och bättre lämpade för uppgiften."

#: ../../faq/programming.rst:1024
msgid "What does ``UnicodeDecodeError`` or ``UnicodeEncodeError`` error mean?"
msgstr "Vad betyder ``UnicodeDecodeError`` eller ``UnicodeEncodeError`` fel?"

#: ../../faq/programming.rst:1026
msgid "See the :ref:`unicode-howto`."
msgstr "Se :ref:`unicode-howto`."

#: ../../faq/programming.rst:1032
msgid "Can I end a raw string with an odd number of backslashes?"
msgstr "Kan jag avsluta en rå sträng med ett udda antal backslash?"

#: ../../faq/programming.rst:1034
msgid ""
"A raw string ending with an odd number of backslashes will escape the "
"string's quote::"
msgstr ""
"En rå sträng som slutar med ett udda antal backslashes kommer att undkomma "
"strängens quote::"

#: ../../faq/programming.rst:1036
msgid ""
">>> r'C:\\this\\will\\not\\work\\'\n"
"  File \"<stdin>\", line 1\n"
"    r'C:\\this\\will\\not\\work\\'\n"
"    ^\n"
"SyntaxError: unterminated string literal (detected at line 1)"
msgstr ""
">>> r'C:\\this\\will\\not\\work\\'\n"
"  File \"<stdin>\", line 1\n"
"    r'C:\\this\\will\\not\\work\\'\n"
"    ^\n"
"SyntaxError: unterminated string literal (detected at line 1)"

#: ../../faq/programming.rst:1042
msgid ""
"There are several workarounds for this. One is to use regular strings and "
"double the backslashes::"
msgstr ""
"Det finns flera lösningar på detta. En är att använda vanliga strängar och "
"dubbla de bakre bindestrecken::"

#: ../../faq/programming.rst:1045
msgid ""
">>> 'C:\\\\this\\\\will\\\\work\\\\'\n"
"'C:\\\\this\\\\will\\\\work\\\\'"
msgstr ""
">>> 'C:\\\\this\\\\will\\\\work\\\\'\n"
"'C:\\\\this\\\\will\\\\work\\\\'"

#: ../../faq/programming.rst:1048
msgid ""
"Another is to concatenate a regular string containing an escaped backslash "
"to the raw string::"
msgstr ""
"Ett annat sätt är att konkatenera en reguljär sträng som innehåller en "
"undangömd backslash till råsträngen::"

#: ../../faq/programming.rst:1051
msgid ""
">>> r'C:\\this\\will\\work' '\\\\'\n"
"'C:\\\\this\\\\will\\\\work\\\\'"
msgstr ""
">>> r'C:\\this\\will\\work' '\\\\'\n"
"'C:\\\\this\\\\will\\\\work\\\\'"

#: ../../faq/programming.rst:1054
msgid ""
"It is also possible to use :func:`os.path.join` to append a backslash on "
"Windows::"
msgstr ""
"Det är också möjligt att använda :func:`os.path.join` för att lägga till ett"
" backslash i Windows::"

#: ../../faq/programming.rst:1056
msgid ""
">>> os.path.join(r'C:\\this\\will\\work', '')\n"
"'C:\\\\this\\\\will\\\\work\\\\'"
msgstr ""
">>> os.path.join(r'C:\\this\\will\\work', '')\n"
"'C:\\\\this\\\\will\\\\work\\\\'"

#: ../../faq/programming.rst:1059
msgid ""
"Note that while a backslash will \"escape\" a quote for the purposes of "
"determining where the raw string ends, no escaping occurs when interpreting "
"the value of the raw string. That is, the backslash remains present in the "
"value of the raw string::"
msgstr ""
"Observera att även om en backslash \"escapar\" ett citattecken för att "
"avgöra var råsträngen slutar, sker ingen escaping när råsträngens värde "
"tolkas. Det vill säga, det bakre snedstrecket finns kvar i värdet av den råa"
" strängen::"

#: ../../faq/programming.rst:1064
msgid ""
">>> r'backslash\\'preserved'\n"
"\"backslash\\\\'preserved\""
msgstr ""
">>> r'backslash\\'preserved'\n"
"\"backslash\\\\'preserved\""

#: ../../faq/programming.rst:1067
msgid "Also see the specification in the :ref:`language reference <strings>`."
msgstr "Se även specifikationen i :ref:`language reference <strings>`."

#: ../../faq/programming.rst:1070
msgid "Performance"
msgstr "Prestanda"

#: ../../faq/programming.rst:1073
msgid "My program is too slow. How do I speed it up?"
msgstr "Mitt program är för långsamt. Hur snabbar jag upp det?"

#: ../../faq/programming.rst:1075
msgid ""
"That's a tough one, in general.  First, here are a list of things to "
"remember before diving further:"
msgstr ""
"Det är en svår fråga, generellt sett.  Här är en lista på saker att komma "
"ihåg innan du dyker vidare:"

#: ../../faq/programming.rst:1078
msgid ""
"Performance characteristics vary across Python implementations.  This FAQ "
"focuses on :term:`CPython`."
msgstr ""
"Prestandaegenskaperna varierar mellan olika Python-implementationer.  Denna "
"FAQ fokuserar på :term:`CPython`."

#: ../../faq/programming.rst:1080
msgid ""
"Behaviour can vary across operating systems, especially when talking about "
"I/O or multi-threading."
msgstr ""
"Beteendet kan variera mellan olika operativsystem, särskilt när det gäller "
"I/O eller multi-threading."

#: ../../faq/programming.rst:1082
msgid ""
"You should always find the hot spots in your program *before* attempting to "
"optimize any code (see the :mod:`profile` module)."
msgstr ""
"Du bör alltid hitta de hetaste punkterna i ditt program *innan* du försöker "
"optimera någon kod (se modulen :mod:`profile`)."

#: ../../faq/programming.rst:1084
msgid ""
"Writing benchmark scripts will allow you to iterate quickly when searching "
"for improvements (see the :mod:`timeit` module)."
msgstr ""
"Genom att skriva benchmark-skript kan du snabbt iterera när du söker efter "
"förbättringar (se modulen :mod:`timeit`)."

#: ../../faq/programming.rst:1086
msgid ""
"It is highly recommended to have good code coverage (through unit testing or"
" any other technique) before potentially introducing regressions hidden in "
"sophisticated optimizations."
msgstr ""
"Det är starkt rekommenderat att ha god kodtäckning (genom enhetstestning "
"eller någon annan teknik) innan man eventuellt introducerar regressioner som"
" döljs i sofistikerade optimeringar."

#: ../../faq/programming.rst:1090
msgid ""
"That being said, there are many tricks to speed up Python code.  Here are "
"some general principles which go a long way towards reaching acceptable "
"performance levels:"
msgstr ""
"Med detta sagt finns det många knep för att snabba upp Python-kod.  Här är "
"några allmänna principer som räcker långt för att nå acceptabla "
"prestandanivåer:"

#: ../../faq/programming.rst:1094
msgid ""
"Making your algorithms faster (or changing to faster ones) can yield much "
"larger benefits than trying to sprinkle micro-optimization tricks all over "
"your code."
msgstr ""
"Att göra dina algoritmer snabbare (eller byta till snabbare algoritmer) kan "
"ge mycket större fördelar än att försöka strö mikrooptimeringsknep över hela"
" koden."

#: ../../faq/programming.rst:1098
msgid ""
"Use the right data structures.  Study documentation for the :ref:`bltin-"
"types` and the :mod:`collections` module."
msgstr ""
"Använd rätt datastrukturer.  Studera dokumentationen för modulen "
":ref:`bltin-types` och :mod:`collections`."

#: ../../faq/programming.rst:1101
msgid ""
"When the standard library provides a primitive for doing something, it is "
"likely (although not guaranteed) to be faster than any alternative you may "
"come up with.  This is doubly true for primitives written in C, such as "
"builtins and some extension types.  For example, be sure to use either the "
":meth:`list.sort` built-in method or the related :func:`sorted` function to "
"do sorting (and see the :ref:`sortinghowto` for examples of moderately "
"advanced usage)."
msgstr ""
"När standardbiblioteket tillhandahåller en primitiv metod för att göra något"
" är det troligt (men inte garanterat) att den är snabbare än något "
"alternativ som du kan komma på.  Detta gäller i ännu högre grad för "
"primitiver som är skrivna i C, t.ex. inbyggda program och vissa "
"tilläggstyper.  Se till exempel till att använda antingen den inbyggda "
"metoden :meth:`list.sort` eller den relaterade funktionen :func:`sorted` för"
" att göra sortering (och se :ref:`sortinghowto` för exempel på måttligt "
"avancerad användning)."

#: ../../faq/programming.rst:1109
msgid ""
"Abstractions tend to create indirections and force the interpreter to work "
"more.  If the levels of indirection outweigh the amount of useful work done,"
" your program will be slower.  You should avoid excessive abstraction, "
"especially under the form of tiny functions or methods (which are also often"
" detrimental to readability)."
msgstr ""
"Abstraktioner tenderar att skapa indirektioner och tvinga tolken att arbeta "
"mer.  Om nivåerna av indirekta åtgärder uppväger mängden användbart arbete "
"som utförs, blir ditt program långsammare.  Du bör undvika överdriven "
"abstraktion, särskilt i form av små funktioner eller metoder (som också ofta"
" är skadliga för läsbarheten)."

#: ../../faq/programming.rst:1115
msgid ""
"If you have reached the limit of what pure Python can allow, there are tools"
" to take you further away.  For example, `Cython <https://cython.org>`_ can "
"compile a slightly modified version of Python code into a C extension, and "
"can be used on many different platforms.  Cython can take advantage of "
"compilation (and optional type annotations) to make your code significantly "
"faster than when interpreted.  If you are confident in your C programming "
"skills, you can also :ref:`write a C extension module <extending-index>` "
"yourself."
msgstr ""
"Om du har nått gränsen för vad ren Python kan tillåta, finns det verktyg som"
" tar dig längre bort.  Till exempel kan `Cython <https://cython.org>`_ "
"kompilera en något modifierad version av Python-kod till ett C-tillägg och "
"kan användas på många olika plattformar.  Cython kan dra nytta av "
"kompilering (och valfria typannoteringar) för att göra din kod betydligt "
"snabbare än när den tolkas.  Om du är säker på dina färdigheter i "
"C-programmering kan du också :ref:`skriva en C-tilläggsmodul <extending-"
"index>` själv."

#: ../../faq/programming.rst:1125
msgid ""
"The wiki page devoted to `performance tips "
"<https://wiki.python.org/moin/PythonSpeed/PerformanceTips>`_."
msgstr ""
"Wikisidan som ägnas åt `prestandatips "
"<https://wiki.python.org/moin/PythonSpeed/PerformanceTips>`_."

#: ../../faq/programming.rst:1131
msgid "What is the most efficient way to concatenate many strings together?"
msgstr ""
"Vad är det mest effektiva sättet att konkatenera många strängar tillsammans?"

#: ../../faq/programming.rst:1133
msgid ""
":class:`str` and :class:`bytes` objects are immutable, therefore "
"concatenating many strings together is inefficient as each concatenation "
"creates a new object.  In the general case, the total runtime cost is "
"quadratic in the total string length."
msgstr ""
"objekten :class:`str` och :class:`bytes` är oföränderliga, och därför är det"
" ineffektivt att sammanfoga många strängar eftersom varje sammanfogning "
"skapar ett nytt objekt.  I det allmänna fallet är den totala "
"körtidskostnaden kvadratisk i den totala stränglängden."

#: ../../faq/programming.rst:1138
msgid ""
"To accumulate many :class:`str` objects, the recommended idiom is to place "
"them into a list and call :meth:`str.join` at the end::"
msgstr ""
"För att samla många :class:`str`\\-objekt är det rekommenderade idiomet att "
"placera dem i en lista och anropa :meth:`str.join` i slutet::"

#: ../../faq/programming.rst:1141
msgid ""
"chunks = []\n"
"for s in my_strings:\n"
"    chunks.append(s)\n"
"result = ''.join(chunks)"
msgstr ""
"chunks = []\n"
"för s i my_strings:\n"
"    chunks.append(s)\n"
"resultat = ''.join(chunks)"

#: ../../faq/programming.rst:1146
msgid "(another reasonably efficient idiom is to use :class:`io.StringIO`)"
msgstr ""
"(ett annat rimligt effektivt idiom är att använda :class:`io.StringIO`)"

#: ../../faq/programming.rst:1148
msgid ""
"To accumulate many :class:`bytes` objects, the recommended idiom is to "
"extend a :class:`bytearray` object using in-place concatenation (the ``+=`` "
"operator)::"
msgstr ""
"För att ackumulera många :class:`bytes`\\-objekt är det rekommenderade "
"idiomet att utöka ett :class:`bytearray`\\-objekt med hjälp av konkatenering"
" på plats (operatorn ``+=``)::"

#: ../../faq/programming.rst:1151
msgid ""
"result = bytearray()\n"
"for b in my_bytes_objects:\n"
"    result += b"
msgstr ""
"resultat = bytearray()\n"
"för b i my_bytes_objects:\n"
"    resultat += b"

#: ../../faq/programming.rst:1157
msgid "Sequences (Tuples/Lists)"
msgstr "Sekvenser (Tupler/Listor)"

#: ../../faq/programming.rst:1160
msgid "How do I convert between tuples and lists?"
msgstr "Hur konverterar jag mellan tupler och listor?"

#: ../../faq/programming.rst:1162
msgid ""
"The type constructor ``tuple(seq)`` converts any sequence (actually, any "
"iterable) into a tuple with the same items in the same order."
msgstr ""
"Typkonstruktören ``tuple(seq)`` konverterar vilken sekvens som helst "
"(egentligen vilken iterabel som helst) till en tuple med samma objekt i "
"samma ordning."

#: ../../faq/programming.rst:1165
msgid ""
"For example, ``tuple([1, 2, 3])`` yields ``(1, 2, 3)`` and ``tuple('abc')`` "
"yields ``('a', 'b', 'c')``.  If the argument is a tuple, it does not make a "
"copy but returns the same object, so it is cheap to call :func:`tuple` when "
"you aren't sure that an object is already a tuple."
msgstr ""
"Till exempel ger ``tuple([1, 2, 3])`` ``(1, 2, 3)`` och ``tuple('abc')`` ger"
" ``('a', 'b', 'c')``.  Om argumentet är en tupel görs ingen kopia utan samma"
" objekt returneras, så det är billigt att anropa :func:`tuple` när du inte "
"är säker på att ett objekt redan är en tupel."

#: ../../faq/programming.rst:1170
msgid ""
"The type constructor ``list(seq)`` converts any sequence or iterable into a "
"list with the same items in the same order.  For example, ``list((1, 2, "
"3))`` yields ``[1, 2, 3]`` and ``list('abc')`` yields ``['a', 'b', 'c']``.  "
"If the argument is a list, it makes a copy just like ``seq[:]`` would."
msgstr ""
"Typkonstruktören ``list(seq)`` konverterar en sekvens eller iterabel till en"
" lista med samma objekt i samma ordning.  Till exempel ger ``list((1, 2, "
"3))`` ``[1, 2, 3]`` och ``list('abc')`` ger ``['a', 'b', 'c']``.  Om "
"argumentet är en lista gör den en kopia precis som ``seq[:]`` skulle göra."

#: ../../faq/programming.rst:1177
msgid "What's a negative index?"
msgstr "Vad är ett negativt index?"

#: ../../faq/programming.rst:1179
msgid ""
"Python sequences are indexed with positive numbers and negative numbers.  "
"For positive numbers 0 is the first index 1 is the second index and so "
"forth.  For negative indices -1 is the last index and -2 is the penultimate "
"(next to last) index and so forth.  Think of ``seq[-n]`` as the same as "
"``seq[len(seq)-n]``."
msgstr ""
"Pythonsekvenser är indexerade med positiva och negativa tal.  För positiva "
"tal är 0 det första indexet 1 är det andra indexet och så vidare.  För "
"negativa index är -1 det sista indexet och -2 är det näst sista indexet och "
"så vidare.  Tänk på ``seq[-n]`` som samma sak som ``seq[len(seq)-n]``."

#: ../../faq/programming.rst:1184
msgid ""
"Using negative indices can be very convenient.  For example ``S[:-1]`` is "
"all of the string except for its last character, which is useful for "
"removing the trailing newline from a string."
msgstr ""
"Att använda negativa index kan vara mycket praktiskt.  Till exempel är "
"``S[:-1]`` hela strängen utom det sista tecknet, vilket är användbart när "
"man vill ta bort den efterföljande nya raden från en sträng."

#: ../../faq/programming.rst:1190
msgid "How do I iterate over a sequence in reverse order?"
msgstr "Hur itererar jag över en sekvens i omvänd ordning?"

#: ../../faq/programming.rst:1192
msgid "Use the :func:`reversed` built-in function::"
msgstr "Använd den inbyggda funktionen :func:`reversed`::"

#: ../../faq/programming.rst:1194
msgid ""
"for x in reversed(sequence):\n"
"    ...  # do something with x ..."
msgstr ""
"för x i omvänd(sekvens):\n"
"    ...  # gör något med x ..."

#: ../../faq/programming.rst:1197
msgid ""
"This won't touch your original sequence, but build a new copy with reversed "
"order to iterate over."
msgstr ""
"Detta påverkar inte din ursprungliga sekvens, men skapar en ny kopia med "
"omvänd ordning som du kan iterera över."

#: ../../faq/programming.rst:1202
msgid "How do you remove duplicates from a list?"
msgstr "Hur tar man bort dubbletter från en lista?"

#: ../../faq/programming.rst:1204
msgid "See the Python Cookbook for a long discussion of many ways to do this:"
msgstr ""
"Se Python Cookbook för en lång diskussion om många sätt att göra detta:"

#: ../../faq/programming.rst:1206
msgid "https://code.activestate.com/recipes/52560/"
msgstr "https://code.activestate.com/recipes/52560/"

#: ../../faq/programming.rst:1208
msgid ""
"If you don't mind reordering the list, sort it and then scan from the end of"
" the list, deleting duplicates as you go::"
msgstr ""
"Om du inte har något emot att ändra ordning på listan kan du sortera den och"
" sedan skanna från slutet av listan och ta bort dubbletter efter hand:"

#: ../../faq/programming.rst:1211
msgid ""
"if mylist:\n"
"    mylist.sort()\n"
"    last = mylist[-1]\n"
"    for i in range(len(mylist)-2, -1, -1):\n"
"        if last == mylist[i]:\n"
"            del mylist[i]\n"
"        else:\n"
"            last = mylist[i]"
msgstr ""
"if mylist:\n"
"    mylist.sort()\n"
"    sista = mylist[-1]\n"
"    for i in range(len(mylist)-2, -1, -1):\n"
"        if last == mylist[i]:\n"
"            del mylist[i]\n"
"        annars:\n"
"            last = mylist[i]"

#: ../../faq/programming.rst:1220
msgid ""
"If all elements of the list may be used as set keys (i.e. they are all "
":term:`hashable`) this is often faster ::"
msgstr ""
"Om alla element i listan kan användas som set-nycklar (dvs. de är alla "
":term:`hashable`) är detta ofta snabbare ::"

#: ../../faq/programming.rst:1223
msgid "mylist = list(set(mylist))"
msgstr "mylist = list(set(mylist))"

#: ../../faq/programming.rst:1225
msgid ""
"This converts the list into a set, thereby removing duplicates, and then "
"back into a list."
msgstr ""
"Detta omvandlar listan till en uppsättning, varvid dubbletter tas bort, och "
"sedan tillbaka till en lista."

#: ../../faq/programming.rst:1230
msgid "How do you remove multiple items from a list"
msgstr "Hur tar du bort flera objekt från en lista"

#: ../../faq/programming.rst:1232
msgid ""
"As with removing duplicates, explicitly iterating in reverse with a delete "
"condition is one possibility.  However, it is easier and faster to use slice"
" replacement with an implicit or explicit forward iteration. Here are three "
"variations.::"
msgstr ""
"Precis som vid borttagning av dubbletter är det en möjlighet att explicit "
"iterera baklänges med ett delete-villkor.  Det är dock enklare och snabbare "
"att använda slice replacement med en implicit eller explicit iteration "
"framåt. Här är tre varianter:::"

#: ../../faq/programming.rst:1237
msgid ""
"mylist[:] = filter(keep_function, mylist)\n"
"mylist[:] = (x for x in mylist if keep_condition)\n"
"mylist[:] = [x for x in mylist if keep_condition]"
msgstr ""
"mylist[:] = filter(keep_function, mylist)\n"
"mylist[:] = (x för x i mylist if keep_condition)\n"
"mylist[:] = [x for x in mylist if keep_condition] (x för x i mylist if keep_condition)"

#: ../../faq/programming.rst:1241
msgid "The list comprehension may be fastest."
msgstr "Förståelsen av listan kan vara snabbast."

#: ../../faq/programming.rst:1245
msgid "How do you make an array in Python?"
msgstr "Hur gör du en matris i Python?"

#: ../../faq/programming.rst:1247
msgid "Use a list::"
msgstr "Använd en lista::"

#: ../../faq/programming.rst:1249
msgid "[\"this\", 1, \"is\", \"an\", \"array\"]"
msgstr "[\"detta\", 1, \"är\", \"en\", \"array\"]"

#: ../../faq/programming.rst:1251
msgid ""
"Lists are equivalent to C or Pascal arrays in their time complexity; the "
"primary difference is that a Python list can contain objects of many "
"different types."
msgstr ""
"Listor motsvarar matriser i C eller Pascal när det gäller tidskomplexitet; "
"den främsta skillnaden är att en Python-lista kan innehålla objekt av många "
"olika typer."

#: ../../faq/programming.rst:1254
msgid ""
"The ``array`` module also provides methods for creating arrays of fixed "
"types with compact representations, but they are slower to index than lists."
"  Also note that `NumPy <https://numpy.org/>`_ and other third party "
"packages define array-like structures with various characteristics as well."
msgstr ""
"Modulen ``array`` tillhandahåller också metoder för att skapa matriser av "
"fasta typer med kompakta representationer, men de är långsammare att "
"indexera än listor.  Observera också att `NumPy <https://numpy.org/>`_ och "
"andra tredjepartspaket också definierar array-liknande strukturer med olika "
"egenskaper."

#: ../../faq/programming.rst:1260
msgid ""
"To get Lisp-style linked lists, you can emulate *cons cells* using tuples::"
msgstr ""
"För att få länkade listor i Lisp-stil kan du emulera *cons cells* med hjälp "
"av tuples::"

#: ../../faq/programming.rst:1262
msgid "lisp_list = (\"like\",  (\"this\",  (\"example\", None) ) )"
msgstr "lisp_list = (\"som\", (\"detta\", (\"exempel\", None) ) )"

#: ../../faq/programming.rst:1264
msgid ""
"If mutability is desired, you could use lists instead of tuples.  Here the "
"analogue of a Lisp *car* is ``lisp_list[0]`` and the analogue of *cdr* is "
"``lisp_list[1]``.  Only do this if you're sure you really need to, because "
"it's usually a lot slower than using Python lists."
msgstr ""
"Om man vill ha mutabilitet kan man använda listor i stället för tupler.  Här"
" är motsvarigheten till en Lisp *car* ``lisp_list[0]`` och motsvarigheten "
"till *cdr* är ``lisp_list[1]``.  Gör bara detta om du är säker på att du "
"verkligen behöver det, eftersom det vanligtvis är mycket långsammare än att "
"använda Python-listor."

#: ../../faq/programming.rst:1273
msgid "How do I create a multidimensional list?"
msgstr "Hur skapar jag en flerdimensionell lista?"

#: ../../faq/programming.rst:1275
msgid "You probably tried to make a multidimensional array like this::"
msgstr "Du har säkert försökt skapa en flerdimensionell matris så här::"

#: ../../faq/programming.rst:1277
msgid ">>> A = [[None] * 2] * 3"
msgstr ">>> A = [[None] * 2] * 3"

#: ../../faq/programming.rst:1279
msgid "This looks correct if you print it:"
msgstr "Detta ser korrekt ut om du skriver ut det:"

#: ../../faq/programming.rst:1285
msgid ""
">>> A\n"
"[[None, None], [None, None], [None, None]]"
msgstr ""
">>> A\n"
"[[None, None], [None, None], [None, None]]"

#: ../../faq/programming.rst:1290
msgid "But when you assign a value, it shows up in multiple places:"
msgstr "Men när du tilldelar ett värde dyker det upp på flera ställen:"

#: ../../faq/programming.rst:1296
msgid ""
">>> A[0][0] = 5\n"
">>> A\n"
"[[5, None], [5, None], [5, None]]"
msgstr ""
">>> A[0][0] = 5\n"
">>> A\n"
"[[5, None], [5, None], [5, None]]"

#: ../../faq/programming.rst:1302
msgid ""
"The reason is that replicating a list with ``*`` doesn't create copies, it "
"only creates references to the existing objects.  The ``*3`` creates a list "
"containing 3 references to the same list of length two.  Changes to one row "
"will show in all rows, which is almost certainly not what you want."
msgstr ""
"Anledningen är att replikering av en lista med ``*`` inte skapar kopior, det"
" skapar bara referenser till de befintliga objekten.  Med ``*3`` skapas en "
"lista som innehåller 3 referenser till samma lista med längden två.  "
"Ändringar i en rad kommer att visas i alla rader, vilket nästan säkert inte "
"är vad du vill."

#: ../../faq/programming.rst:1307
msgid ""
"The suggested approach is to create a list of the desired length first and "
"then fill in each element with a newly created list::"
msgstr ""
"Det föreslagna tillvägagångssättet är att först skapa en lista med önskad "
"längd och sedan fylla i varje element med en nyskapad lista::"

#: ../../faq/programming.rst:1310
msgid ""
"A = [None] * 3\n"
"for i in range(3):\n"
"    A[i] = [None] * 2"
msgstr ""
"A = [Ingen] * 3\n"
"för i i intervall(3):\n"
"    A[i] = [Ingen] * 2"

#: ../../faq/programming.rst:1314
msgid ""
"This generates a list containing 3 different lists of length two.  You can "
"also use a list comprehension::"
msgstr ""
"Detta genererar en lista som innehåller 3 olika listor med längden två.  Du "
"kan också använda en listkomprehension::"

#: ../../faq/programming.rst:1317
msgid ""
"w, h = 2, 3\n"
"A = [[None] * w for i in range(h)]"
msgstr ""
"w, h = 2, 3\n"
"A = [[None] * w for i in range(h)]"

#: ../../faq/programming.rst:1320
msgid ""
"Or, you can use an extension that provides a matrix datatype; `NumPy "
"<https://numpy.org/>`_ is the best known."
msgstr ""
"Eller så kan du använda ett tillägg som tillhandahåller en matrisdatatyp; "
"`NumPy <https://numpy.org/>`_ är den mest kända."

#: ../../faq/programming.rst:1325
msgid "How do I apply a method or function to a sequence of objects?"
msgstr "Hur tillämpar jag en metod eller funktion på en sekvens av objekt?"

#: ../../faq/programming.rst:1327
msgid ""
"To call a method or function and accumulate the return values is a list, a "
":term:`list comprehension` is an elegant solution::"
msgstr ""
"Att anropa en metod eller funktion och ackumulera returvärdena är en lista, "
"en :term:`list comprehension` är en elegant lösning::"

#: ../../faq/programming.rst:1330
msgid ""
"result = [obj.method() for obj in mylist]\n"
"\n"
"result = [function(obj) for obj in mylist]"
msgstr ""
"resultat = [obj.method() för obj i mylist]\n"
"\n"
"resultat = [funktion(obj) för obj i mylist]"

#: ../../faq/programming.rst:1334
msgid ""
"To just run the method or function without saving the return values, a plain"
" :keyword:`for` loop will suffice::"
msgstr ""
"Om du bara vill köra metoden eller funktionen utan att spara returvärdena "
"räcker det med en vanlig :keyword:`for`\\-loop::"

#: ../../faq/programming.rst:1337
msgid ""
"for obj in mylist:\n"
"    obj.method()\n"
"\n"
"for obj in mylist:\n"
"    function(obj)"
msgstr ""
"för obj i mylist:\n"
"    obj.metod()\n"
"\n"
"för obj i mylist:\n"
"    funktion(obj)"

#: ../../faq/programming.rst:1346
msgid ""
"Why does a_tuple[i] += ['item'] raise an exception when the addition works?"
msgstr ""
"Varför ger a_tuple[i] += ['item'] upphov till ett undantag när tillägget "
"fungerar?"

#: ../../faq/programming.rst:1348
msgid ""
"This is because of a combination of the fact that augmented assignment "
"operators are *assignment* operators, and the difference between mutable and"
" immutable objects in Python."
msgstr ""
"Detta beror på en kombination av det faktum att utökade "
"tilldelningsoperatorer är *tilldelningsoperatorer* och skillnaden mellan "
"muterbara och oföränderliga objekt i Python."

#: ../../faq/programming.rst:1352
msgid ""
"This discussion applies in general when augmented assignment operators are "
"applied to elements of a tuple that point to mutable objects, but we'll use "
"a ``list`` and ``+=`` as our exemplar."
msgstr ""
"Den här diskussionen gäller i allmänhet när utökade tilldelningsoperatorer "
"tillämpas på element i en tupel som pekar på föränderliga objekt, men vi "
"använder en ``list`` och ``+=`` som vårt exempel."

#: ../../faq/programming.rst:1356
msgid "If you wrote::"
msgstr "Om du skrev::"

#: ../../faq/programming.rst:1358
msgid ""
">>> a_tuple = (1, 2)\n"
">>> a_tuple[0] += 1\n"
"Traceback (most recent call last):\n"
"   ...\n"
"TypeError: 'tuple' object does not support item assignment"
msgstr ""
">>> a_tuple = (1, 2)\n"
">>> a_tuple[0] += 1\n"
"Traceback (most recent call last):\n"
"   ...\n"
"TypeError: 'tuple' object does not support item assignment"

#: ../../faq/programming.rst:1364
msgid ""
"The reason for the exception should be immediately clear: ``1`` is added to "
"the object ``a_tuple[0]`` points to (``1``), producing the result object, "
"``2``, but when we attempt to assign the result of the computation, ``2``, "
"to element ``0`` of the tuple, we get an error because we can't change what "
"an element of a tuple points to."
msgstr ""
"Anledningen till undantaget bör vara omedelbart klar: ``1`` läggs till "
"objektet ``a_tuple[0]`` pekar på (``1``), vilket ger resultatobjektet ``2``,"
" men när vi försöker tilldela resultatet av beräkningen, ``2``, till "
"elementet ``0`` i tupeln, får vi ett fel eftersom vi inte kan ändra vad ett "
"element i en tuple pekar på."

#: ../../faq/programming.rst:1370
msgid ""
"Under the covers, what this augmented assignment statement is doing is "
"approximately this::"
msgstr ""
"Under täckmanteln gör den här utökade uppdragsbeskrivningen ungefär så här::"

#: ../../faq/programming.rst:1373
msgid ""
">>> result = a_tuple[0] + 1\n"
">>> a_tuple[0] = result\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: 'tuple' object does not support item assignment"
msgstr ""
">>> result = a_tuple[0] + 1\n"
">>> a_tuple[0] = result\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: 'tuple' object does not support item assignment"

#: ../../faq/programming.rst:1379
msgid ""
"It is the assignment part of the operation that produces the error, since a "
"tuple is immutable."
msgstr ""
"Det är tilldelningsdelen av operationen som ger upphov till felet, eftersom "
"en tuple är oföränderlig."

#: ../../faq/programming.rst:1382
msgid "When you write something like::"
msgstr "När du skriver något i stil med::"

#: ../../faq/programming.rst:1384
msgid ""
">>> a_tuple = (['foo'], 'bar')\n"
">>> a_tuple[0] += ['item']\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: 'tuple' object does not support item assignment"
msgstr ""
">>> a_tuple = (['foo'], 'bar')\n"
">>> a_tuple[0] += ['item']\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: 'tuple' object does not support item assignment"

#: ../../faq/programming.rst:1390
msgid ""
"The exception is a bit more surprising, and even more surprising is the fact"
" that even though there was an error, the append worked::"
msgstr ""
"Undantaget är lite mer överraskande, och ännu mer överraskande är det faktum"
" att även om det fanns ett fel, fungerade tillägget::"

#: ../../faq/programming.rst:1393
msgid ""
">>> a_tuple[0]\n"
"['foo', 'item']"
msgstr ""
">>> a_tuple[0]\n"
"['foo', 'item']"

#: ../../faq/programming.rst:1396
msgid ""
"To see why this happens, you need to know that (a) if an object implements "
"an :meth:`~object.__iadd__` magic method, it gets called when the ``+=`` "
"augmented assignment is executed, and its return value is what gets used in "
"the assignment statement; and (b) for lists, :meth:`!__iadd__` is equivalent"
" to calling :meth:`~sequence.extend` on the list and returning the list. "
"That's why we say that for lists, ``+=`` is a \"shorthand\" for "
":meth:`list.extend`::"
msgstr ""

#: ../../faq/programming.rst:1404
msgid ""
">>> a_list = []\n"
">>> a_list += [1]\n"
">>> a_list\n"
"[1]"
msgstr ""
">>> a_list = []\n"
">>> a_list += [1]\n"
">>> a_list\n"
"[1]"

#: ../../faq/programming.rst:1409
msgid "This is equivalent to::"
msgstr "Detta är likvärdigt med::"

#: ../../faq/programming.rst:1411
msgid ""
">>> result = a_list.__iadd__([1])\n"
">>> a_list = result"
msgstr ""
">>> result = a_list.__iadd__([1])\n"
">>> a_list = result"

#: ../../faq/programming.rst:1414
msgid ""
"The object pointed to by a_list has been mutated, and the pointer to the "
"mutated object is assigned back to ``a_list``.  The end result of the "
"assignment is a no-op, since it is a pointer to the same object that "
"``a_list`` was previously pointing to, but the assignment still happens."
msgstr ""
"Det objekt som a_list pekar på har muterats och pekaren till det muterade "
"objektet tilldelas tillbaka till ``a_list``.  Slutresultatet av "
"tilldelningen är en no-op, eftersom det är en pekare till samma objekt som "
"``a_list`` tidigare pekade på, men tilldelningen sker ändå."

#: ../../faq/programming.rst:1419
msgid "Thus, in our tuple example what is happening is equivalent to::"
msgstr "I vårt tuplexempel är det som händer alltså likvärdigt med::"

#: ../../faq/programming.rst:1421
msgid ""
">>> result = a_tuple[0].__iadd__(['item'])\n"
">>> a_tuple[0] = result\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: 'tuple' object does not support item assignment"
msgstr ""
">>> result = a_tuple[0].__iadd__(['item'])\n"
">>> a_tuple[0] = result\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: 'tuple' object does not support item assignment"

#: ../../faq/programming.rst:1427
msgid ""
"The :meth:`!__iadd__` succeeds, and thus the list is extended, but even "
"though ``result`` points to the same object that ``a_tuple[0]`` already "
"points to, that final assignment still results in an error, because tuples "
"are immutable."
msgstr ""
":meth:`!__iadd__` lyckas och därmed utökas listan, men även om ``result`` "
"pekar på samma objekt som ``a_tuple[0]`` redan pekar på, resulterar den "
"slutliga tilldelningen fortfarande i ett fel, eftersom tuples är "
"oföränderliga."

#: ../../faq/programming.rst:1433
msgid ""
"I want to do a complicated sort: can you do a Schwartzian Transform in "
"Python?"
msgstr ""
"Jag vill göra en komplicerad sortering: kan du göra en Schwartzian-transform"
" i Python?"

#: ../../faq/programming.rst:1435
msgid ""
"The technique, attributed to Randal Schwartz of the Perl community, sorts "
"the elements of a list by a metric which maps each element to its \"sort "
"value\". In Python, use the ``key`` argument for the :meth:`list.sort` "
"method::"
msgstr ""
"Tekniken, som tillskrivs Randal Schwartz från Perl-gemenskapen, sorterar "
"elementen i en lista med en metrisk som mappar varje element till dess "
"\"sorteringsvärde\". I Python använder du argumentet ``key`` för metoden "
":meth:`list.sort`::"

#: ../../faq/programming.rst:1439
msgid ""
"Isorted = L[:]\n"
"Isorted.sort(key=lambda s: int(s[10:15]))"
msgstr ""
"Isorted = L[:]\n"
"Isorted.sort(key=lambda s: int(s[10:15]))"

#: ../../faq/programming.rst:1444
msgid "How can I sort one list by values from another list?"
msgstr "Hur kan jag sortera en lista efter värden från en annan lista?"

#: ../../faq/programming.rst:1446
msgid ""
"Merge them into an iterator of tuples, sort the resulting list, and then "
"pick out the element you want. ::"
msgstr ""
"Slå samman dem till en iterator av tupler, sortera den resulterande listan "
"och välj sedan ut det element du vill ha:"

#: ../../faq/programming.rst:1449
msgid ""
">>> list1 = [\"what\", \"I'm\", \"sorting\", \"by\"]\n"
">>> list2 = [\"something\", \"else\", \"to\", \"sort\"]\n"
">>> pairs = zip(list1, list2)\n"
">>> pairs = sorted(pairs)\n"
">>> pairs\n"
"[(\"I'm\", 'else'), ('by', 'sort'), ('sorting', 'to'), ('what', 'something')]\n"
">>> result = [x[1] for x in pairs]\n"
">>> result\n"
"['else', 'sort', 'to', 'something']"
msgstr ""
">>> list1 = [\"what\", \"I'm\", \"sorting\", \"by\"]\n"
">>> list2 = [\"something\", \"else\", \"to\", \"sort\"]\n"
">>> pairs = zip(list1, list2)\n"
">>> pairs = sorted(pairs)\n"
">>> pairs\n"
"[(\"I'm\", 'else'), ('by', 'sort'), ('sorting', 'to'), ('what', 'something')]\n"
">>> result = [x[1] for x in pairs]\n"
">>> result\n"
"['else', 'sort', 'to', 'something']"

#: ../../faq/programming.rst:1461
msgid "Objects"
msgstr "Objekt"

#: ../../faq/programming.rst:1464
msgid "What is a class?"
msgstr "Vad är en klass?"

#: ../../faq/programming.rst:1466
msgid ""
"A class is the particular object type created by executing a class "
"statement. Class objects are used as templates to create instance objects, "
"which embody both the data (attributes) and code (methods) specific to a "
"datatype."
msgstr ""
"En klass är den särskilda objekttyp som skapas genom att en class-sats körs."
" Klassobjekt används som mallar för att skapa instansobjekt, som innehåller "
"både data (attribut) och kod (metoder) som är specifika för en datatyp."

#: ../../faq/programming.rst:1470
msgid ""
"A class can be based on one or more other classes, called its base "
"class(es). It then inherits the attributes and methods of its base classes. "
"This allows an object model to be successively refined by inheritance.  You "
"might have a generic ``Mailbox`` class that provides basic accessor methods "
"for a mailbox, and subclasses such as ``MboxMailbox``, ``MaildirMailbox``, "
"``OutlookMailbox`` that handle various specific mailbox formats."
msgstr ""
"En klass kan baseras på en eller flera andra klasser, som kallas dess "
"basklass(er). Den ärver då attribut och metoder från sina basklasser. Detta "
"gör att en objektmodell successivt kan förfinas genom arv.  Du kanske har en"
" generisk klass ``Mailbox`` som tillhandahåller grundläggande åtkomstmetoder"
" för en brevlåda, och underklasser som ``MboxMailbox``, ``MaildirMailbox``, "
"``OutlookMailbox`` som hanterar olika specifika brevlådeformat."

#: ../../faq/programming.rst:1479
msgid "What is a method?"
msgstr "Vad är en metod?"

#: ../../faq/programming.rst:1481
msgid ""
"A method is a function on some object ``x`` that you normally call as "
"``x.name(arguments...)``.  Methods are defined as functions inside the class"
" definition::"
msgstr ""
"En metod är en funktion på något objekt ``x`` som du normalt anropar som "
"``x.name(arguments...)``.  Metoder definieras som funktioner inuti "
"klassdefinitionen::"

#: ../../faq/programming.rst:1485
msgid ""
"class C:\n"
"    def meth(self, arg):\n"
"        return arg * 2 + self.attribute"
msgstr ""
"class C:\n"
"    def meth(self, arg):\n"
"        return arg * 2 + self.attribute"

#: ../../faq/programming.rst:1491
msgid "What is self?"
msgstr "Vad är jaget?"

#: ../../faq/programming.rst:1493
msgid ""
"Self is merely a conventional name for the first argument of a method.  A "
"method defined as ``meth(self, a, b, c)`` should be called as ``x.meth(a, b,"
" c)`` for some instance ``x`` of the class in which the definition occurs; "
"the called method will think it is called as ``meth(x, a, b, c)``."
msgstr ""
"Self är bara ett konventionellt namn för det första argumentet i en metod.  "
"En metod som definieras som ``meth(self, a, b, c)`` bör anropas som "
"``x.meth(a, b, c)`` för någon instans ``x`` av den klass där definitionen "
"förekommer; den anropade metoden kommer att tro att den anropas som "
"``meth(x, a, b, c)``."

#: ../../faq/programming.rst:1498
msgid "See also :ref:`why-self`."
msgstr "Se även :ref:`why-self`."

#: ../../faq/programming.rst:1502
msgid ""
"How do I check if an object is an instance of a given class or of a subclass"
" of it?"
msgstr ""
"Hur kontrollerar jag om ett objekt är en instans av en viss klass eller av "
"en underklass av den?"

#: ../../faq/programming.rst:1504
msgid ""
"Use the built-in function :func:`isinstance(obj, cls) <isinstance>`.  You "
"can check if an object is an instance of any of a number of classes by "
"providing a tuple instead of a single class, e.g. ``isinstance(obj, (class1,"
" class2, ...))``, and can also check whether an object is one of Python's "
"built-in types, e.g. ``isinstance(obj, str)`` or ``isinstance(obj, (int, "
"float, complex))``."
msgstr ""
"Använd den inbyggda funktionen :func:`isinstance(obj, cls) <isinstance>`.  "
"Du kan kontrollera om ett objekt är en instans av någon av ett antal klasser"
" genom att ange en tupel istället för en enda klass, t.ex. ``isinstance(obj,"
" (class1, class2, ...))``, och du kan också kontrollera om ett objekt är en "
"av Pythons inbyggda typer, t.ex. ``isinstance(obj, str)`` eller "
"``isinstance(obj, (int, float, complex))``."

#: ../../faq/programming.rst:1511
msgid ""
"Note that :func:`isinstance` also checks for virtual inheritance from an "
":term:`abstract base class`.  So, the test will return ``True`` for a "
"registered class even if hasn't directly or indirectly inherited from it.  "
"To test for \"true inheritance\", scan the :term:`MRO` of the class:"
msgstr ""
"Observera att :func:`isinstance` även kontrollerar för virtuellt arv från en"
" :term:`abstract base class`.  Så testet kommer att returnera ``True`` för "
"en registrerad klass även om den inte direkt eller indirekt har ärvt från "
"den.  För att testa för \"true inheritance\", skanna klassens :term:`MRO`:"

#: ../../faq/programming.rst:1516
msgid ""
"from collections.abc import Mapping\n"
"\n"
"class P:\n"
"     pass\n"
"\n"
"class C(P):\n"
"    pass\n"
"\n"
"Mapping.register(P)"
msgstr ""
"from collections.abc import Mapping\n"
"\n"
"class P:\n"
"     pass\n"
"\n"
"class C(P):\n"
"    pass\n"
"\n"
"Mapping.register(P)"

#: ../../faq/programming.rst:1528
msgid ""
">>> c = C()\n"
">>> isinstance(c, C)        # direct\n"
"True\n"
">>> isinstance(c, P)        # indirect\n"
"True\n"
">>> isinstance(c, Mapping)  # virtual\n"
"True\n"
"\n"
"# Actual inheritance chain\n"
">>> type(c).__mro__\n"
"(<class 'C'>, <class 'P'>, <class 'object'>)\n"
"\n"
"# Test for \"true inheritance\"\n"
">>> Mapping in type(c).__mro__\n"
"False"
msgstr ""
">>> c = C()\n"
">>> isinstance(c, C)        # direct\n"
"True\n"
">>> isinstance(c, P)        # indirect\n"
"True\n"
">>> isinstance(c, Mapping)  # virtual\n"
"True\n"
"\n"
"# Actual inheritance chain\n"
">>> type(c).__mro__\n"
"(<class 'C'>, <class 'P'>, <class 'object'>)\n"
"\n"
"# Test for \"true inheritance\"\n"
">>> Mapping in type(c).__mro__\n"
"False"

#: ../../faq/programming.rst:1546
msgid ""
"Note that most programs do not use :func:`isinstance` on user-defined "
"classes very often.  If you are developing the classes yourself, a more "
"proper object-oriented style is to define methods on the classes that "
"encapsulate a particular behaviour, instead of checking the object's class "
"and doing a different thing based on what class it is.  For example, if you "
"have a function that does something::"
msgstr ""
"Observera att de flesta program inte använder :func:`isinstance` på "
"användardefinierade klasser särskilt ofta.  Om du utvecklar klasserna själv "
"är en mer korrekt objektorienterad stil att definiera metoder på klasserna "
"som kapslar in ett visst beteende, istället för att kontrollera objektets "
"klass och göra en annan sak baserat på vilken klass det är.  Om man t.ex. "
"har en funktion som gör något::"

#: ../../faq/programming.rst:1553
msgid ""
"def search(obj):\n"
"    if isinstance(obj, Mailbox):\n"
"        ...  # code to search a mailbox\n"
"    elif isinstance(obj, Document):\n"
"        ...  # code to search a document\n"
"    elif ..."
msgstr ""
"def search(obj):\n"
"    if isinstance(obj, Brevlåda):\n"
"        ...  # kod för att söka i en brevlåda\n"
"    elif isinstance(obj, Dokument):\n"
"        ...  # kod för att söka i ett dokument\n"
"    elif ..."

#: ../../faq/programming.rst:1560
msgid ""
"A better approach is to define a ``search()`` method on all the classes and "
"just call it::"
msgstr ""
"Ett bättre tillvägagångssätt är att definiera en ``search()``\\-metod för "
"alla klasser och bara anropa den::"

#: ../../faq/programming.rst:1563
msgid ""
"class Mailbox:\n"
"    def search(self):\n"
"        ...  # code to search a mailbox\n"
"\n"
"class Document:\n"
"    def search(self):\n"
"        ...  # code to search a document\n"
"\n"
"obj.search()"
msgstr ""
"class Mailbox:\n"
"    def search(self):\n"
"        ...  # code to search a mailbox\n"
"\n"
"class Document:\n"
"    def search(self):\n"
"        ...  # code to search a document\n"
"\n"
"obj.search()"

#: ../../faq/programming.rst:1575
msgid "What is delegation?"
msgstr "Vad är delegering?"

#: ../../faq/programming.rst:1577
msgid ""
"Delegation is an object oriented technique (also called a design pattern). "
"Let's say you have an object ``x`` and want to change the behaviour of just "
"one of its methods.  You can create a new class that provides a new "
"implementation of the method you're interested in changing and delegates all"
" other methods to the corresponding method of ``x``."
msgstr ""
"Delegering är en objektorienterad teknik (även kallad designmönster). Låt "
"oss säga att du har ett objekt ``x`` och vill ändra beteendet hos bara en av"
" dess metoder.  Du kan skapa en ny klass som tillhandahåller en ny "
"implementering av den metod du är intresserad av att ändra och delegerar "
"alla andra metoder till motsvarande metod i ``x``."

#: ../../faq/programming.rst:1583
msgid ""
"Python programmers can easily implement delegation.  For example, the "
"following class implements a class that behaves like a file but converts all"
" written data to uppercase::"
msgstr ""
"Python-programmerare kan enkelt implementera delegering.  Till exempel, "
"följande klass implementerar en klass som beter sig som en fil men "
"konverterar all skriven data till versaler::"

#: ../../faq/programming.rst:1587
msgid ""
"class UpperOut:\n"
"\n"
"    def __init__(self, outfile):\n"
"        self._outfile = outfile\n"
"\n"
"    def write(self, s):\n"
"        self._outfile.write(s.upper())\n"
"\n"
"    def __getattr__(self, name):\n"
"        return getattr(self._outfile, name)"
msgstr ""
"class UpperOut:\n"
"\n"
"    def __init__(self, outfile):\n"
"        self._outfile = outfile\n"
"\n"
"    def write(self, s):\n"
"        self._outfile.write(s.upper())\n"
"\n"
"    def __getattr__(self, name):\n"
"        return getattr(self._outfile, name)"

#: ../../faq/programming.rst:1598
msgid ""
"Here the ``UpperOut`` class redefines the ``write()`` method to convert the "
"argument string to uppercase before calling the underlying "
"``self._outfile.write()`` method.  All other methods are delegated to the "
"underlying ``self._outfile`` object.  The delegation is accomplished via the"
" :meth:`~object.__getattr__` method; consult :ref:`the language reference "
"<attribute-access>` for more information about controlling attribute access."
msgstr ""
"Här omdefinierar klassen ``UpperOut`` metoden ``write()`` så att "
"argumentsträngen konverteras till versaler innan den underliggande metoden "
"``self._outfile.write()`` anropas.  Alla andra metoder delegeras till det "
"underliggande objektet ``self._outfile``.  Delegeringen sker via metoden "
":meth:`~object.__getattr__`; se :ref:`språkreferensen <attribute-access>` "
"för mer information om hur man kontrollerar attributåtkomst."

#: ../../faq/programming.rst:1605
msgid ""
"Note that for more general cases delegation can get trickier. When "
"attributes must be set as well as retrieved, the class must define a "
":meth:`~object.__setattr__` method too, and it must do so carefully.  The "
"basic implementation of :meth:`!__setattr__` is roughly equivalent to the "
"following::"
msgstr ""
"Observera att för mer allmänna fall kan delegering bli knepigare. När "
"attribut måste ställas in såväl som hämtas måste klassen definiera en "
":meth:`~object.__setattr__`\\-metod också, och den måste göra det noggrant."
"  Den grundläggande implementationen av :meth:`!__setattr__` är ungefär "
"likvärdig med följande::"

#: ../../faq/programming.rst:1610
msgid ""
"class X:\n"
"    ...\n"
"    def __setattr__(self, name, value):\n"
"        self.__dict__[name] = value\n"
"    ..."
msgstr ""
"class X:\n"
"    ...\n"
"    def __setattr__(self, name, value):\n"
"        self.__dict__[name] = value\n"
"    ..."

#: ../../faq/programming.rst:1616
msgid ""
"Many :meth:`~object.__setattr__` implementations call "
":meth:`!object.__setattr__` to set an attribute on self without causing "
"infinite recursion::"
msgstr ""
"Många :meth:`~object.__setattr__`\\-implementationer anropar "
":meth:`!object.__setattr__` för att sätta ett attribut på self utan att "
"orsaka oändlig rekursion::"

#: ../../faq/programming.rst:1619
msgid ""
"class X:\n"
"    def __setattr__(self, name, value):\n"
"        # Custom logic here...\n"
"        object.__setattr__(self, name, value)"
msgstr ""
"class X:\n"
"    def __setattr__(self, name, value):\n"
"        # Custom logic here...\n"
"        object.__setattr__(self, name, value)"

#: ../../faq/programming.rst:1624
msgid ""
"Alternatively, it is possible to set attributes by inserting entries into "
":attr:`self.__dict__ <object.__dict__>` directly."
msgstr ""
"Alternativt är det möjligt att ställa in attribut genom att infoga poster i "
":attr:`self.__dict__ <object.__dict__>` direkt."

#: ../../faq/programming.rst:1629
msgid ""
"How do I call a method defined in a base class from a derived class that "
"extends it?"
msgstr ""
"Hur anropar jag en metod som är definierad i en basklass från en härledd "
"klass som utökar den?"

#: ../../faq/programming.rst:1631
msgid "Use the built-in :func:`super` function::"
msgstr "Använd den inbyggda funktionen :func:`super`::"

#: ../../faq/programming.rst:1633
msgid ""
"class Derived(Base):\n"
"    def meth(self):\n"
"        super().meth()  # calls Base.meth"
msgstr ""
"class Derived(Base):\n"
"    def meth(self):\n"
"        super().meth()  # calls Base.meth"

#: ../../faq/programming.rst:1637
msgid ""
"In the example, :func:`super` will automatically determine the instance from"
" which it was called (the ``self`` value), look up the :term:`method "
"resolution order` (MRO) with ``type(self).__mro__``, and return the next in "
"line after ``Derived`` in the MRO: ``Base``."
msgstr ""
"I exemplet kommer :func:`super` automatiskt att bestämma från vilken instans"
" den anropades (värdet ``self``), leta upp :term:`method resolution order` "
"(MRO) med ``type(self).__mro__`` och returnera nästa i raden efter "
"``Derived`` i MRO: ``Base``."

#: ../../faq/programming.rst:1644
msgid "How can I organize my code to make it easier to change the base class?"
msgstr ""
"Hur kan jag organisera min kod för att göra det lättare att ändra "
"basklassen?"

#: ../../faq/programming.rst:1646
msgid ""
"You could assign the base class to an alias and derive from the alias.  Then"
" all you have to change is the value assigned to the alias.  Incidentally, "
"this trick is also handy if you want to decide dynamically (e.g. depending "
"on availability of resources) which base class to use.  Example::"
msgstr ""
"Du kan tilldela basklassen till ett alias och härleda från aliaset.  Då "
"behöver man bara ändra det värde som tilldelats aliaset.  För övrigt är "
"detta trick också praktiskt om du vill bestämma dynamiskt (t.ex. beroende på"
" tillgängliga resurser) vilken basklass som ska användas.  Exempel::"

#: ../../faq/programming.rst:1651
msgid ""
"class Base:\n"
"    ...\n"
"\n"
"BaseAlias = Base\n"
"\n"
"class Derived(BaseAlias):\n"
"    ..."
msgstr ""
"class Base:\n"
"    ...\n"
"\n"
"BaseAlias = Base\n"
"\n"
"class Derived(BaseAlias):\n"
"    ..."

#: ../../faq/programming.rst:1661
msgid "How do I create static class data and static class methods?"
msgstr "Hur skapar jag statiska klassdata och statiska klassmetoder?"

#: ../../faq/programming.rst:1663
msgid ""
"Both static data and static methods (in the sense of C++ or Java) are "
"supported in Python."
msgstr ""
"Både statiska data och statiska metoder (i den mening som avses i C++ eller "
"Java) stöds i Python."

#: ../../faq/programming.rst:1666
msgid ""
"For static data, simply define a class attribute.  To assign a new value to "
"the attribute, you have to explicitly use the class name in the assignment::"
msgstr ""
"För statiska data definierar du helt enkelt ett klassattribut.  För att "
"tilldela ett nytt värde till attributet måste du uttryckligen använda "
"klassnamnet i tilldelningen::"

#: ../../faq/programming.rst:1669
msgid ""
"class C:\n"
"    count = 0   # number of times C.__init__ called\n"
"\n"
"    def __init__(self):\n"
"        C.count = C.count + 1\n"
"\n"
"    def getcount(self):\n"
"        return C.count  # or return self.count"
msgstr ""
"class C:\n"
"    count = 0   # number of times C.__init__ called\n"
"\n"
"    def __init__(self):\n"
"        C.count = C.count + 1\n"
"\n"
"    def getcount(self):\n"
"        return C.count  # or return self.count"

#: ../../faq/programming.rst:1678
msgid ""
"``c.count`` also refers to ``C.count`` for any ``c`` such that "
"``isinstance(c, C)`` holds, unless overridden by ``c`` itself or by some "
"class on the base-class search path from ``c.__class__`` back to ``C``."
msgstr ""
"``c.count`` refererar också till ``C.count`` för varje ``c`` så att "
"``isinstance(c, C)`` gäller, såvida det inte åsidosätts av ``c`` själv eller"
" av någon klass på basklasssökvägen från ``c.__class__`` tillbaka till "
"``C``."

#: ../../faq/programming.rst:1682
msgid ""
"Caution: within a method of C, an assignment like ``self.count = 42`` "
"creates a new and unrelated instance named \"count\" in ``self``'s own dict."
"  Rebinding of a class-static data name must always specify the class "
"whether inside a method or not::"
msgstr ""
"Varning: Inom en metod i C skapar en tilldelning som ``self.count = 42`` en "
"ny och orelaterad instans med namnet \"count\" i ``self`` egen dict.  "
"Ombindning av ett klass-statiskt datanamn måste alltid specificera klassen "
"oavsett om det är inom en metod eller inte::"

#: ../../faq/programming.rst:1687
msgid "C.count = 314"
msgstr "C.count = 314"

#: ../../faq/programming.rst:1689
msgid "Static methods are possible::"
msgstr "Statiska metoder är möjliga::"

#: ../../faq/programming.rst:1691
msgid ""
"class C:\n"
"    @staticmethod\n"
"    def static(arg1, arg2, arg3):\n"
"        # No 'self' parameter!\n"
"        ..."
msgstr ""
"class C:\n"
"    @staticmethod\n"
"    def static(arg1, arg2, arg3):\n"
"        # No 'self' parameter!\n"
"        ..."

#: ../../faq/programming.rst:1697
msgid ""
"However, a far more straightforward way to get the effect of a static method"
" is via a simple module-level function::"
msgstr ""
"Ett mycket enklare sätt att få effekten av en statisk metod är dock via en "
"enkel funktion på modulnivå::"

#: ../../faq/programming.rst:1700
msgid ""
"def getcount():\n"
"    return C.count"
msgstr ""
"def getcount():\n"
"    returnera C.count"

#: ../../faq/programming.rst:1703
msgid ""
"If your code is structured so as to define one class (or tightly related "
"class hierarchy) per module, this supplies the desired encapsulation."
msgstr ""
"Om din kod är strukturerad så att du definierar en klass (eller en nära "
"relaterad klasshierarki) per modul, ger detta den önskade inkapslingen."

#: ../../faq/programming.rst:1708
msgid "How can I overload constructors (or methods) in Python?"
msgstr "Hur kan jag överbelasta konstruktörer (eller metoder) i Python?"

#: ../../faq/programming.rst:1710
msgid ""
"This answer actually applies to all methods, but the question usually comes "
"up first in the context of constructors."
msgstr ""
"Det här svaret gäller egentligen alla metoder, men frågan dyker oftast upp "
"först i samband med konstruktörer."

#: ../../faq/programming.rst:1713
msgid "In C++ you'd write"
msgstr "I C++ skulle du skriva"

#: ../../faq/programming.rst:1715
msgid ""
"class C {\n"
"    C() { cout << \"No arguments\\n\"; }\n"
"    C(int i) { cout << \"Argument is \" << i << \"\\n\"; }\n"
"}"
msgstr ""
"class C {\n"
"    C() { cout << \"No arguments\\n\"; }\n"
"    C(int i) { cout << \"Argument is \" << i << \"\\n\"; }\n"
"}"

#: ../../faq/programming.rst:1722
msgid ""
"In Python you have to write a single constructor that catches all cases "
"using default arguments.  For example::"
msgstr ""
"I Python måste man skriva en enda konstruktor som fångar upp alla fall med "
"hjälp av standardargument.  Till exempel::"

#: ../../faq/programming.rst:1725
msgid ""
"class C:\n"
"    def __init__(self, i=None):\n"
"        if i is None:\n"
"            print(\"No arguments\")\n"
"        else:\n"
"            print(\"Argument is\", i)"
msgstr ""
"class C:\n"
"    def __init__(self, i=None):\n"
"        if i is None:\n"
"            print(\"No arguments\")\n"
"        else:\n"
"            print(\"Argument is\", i)"

#: ../../faq/programming.rst:1732
msgid "This is not entirely equivalent, but close enough in practice."
msgstr "Detta är inte helt likvärdigt, men tillräckligt nära i praktiken."

#: ../../faq/programming.rst:1734
msgid "You could also try a variable-length argument list, e.g. ::"
msgstr "Du kan också prova en argumentlista med variabel längd, t.ex. ::"

#: ../../faq/programming.rst:1736
msgid ""
"def __init__(self, *args):\n"
"    ..."
msgstr ""
"def __init__(self, *args):\n"
"    ..."

#: ../../faq/programming.rst:1739
msgid "The same approach works for all method definitions."
msgstr "Samma tillvägagångssätt fungerar för alla metoddefinitioner."

#: ../../faq/programming.rst:1743
msgid "I try to use __spam and I get an error about _SomeClassName__spam."
msgstr ""
"Jag försöker använda __spam och jag får ett fel om _SomeClassName__spam."

#: ../../faq/programming.rst:1745
msgid ""
"Variable names with double leading underscores are \"mangled\" to provide a "
"simple but effective way to define class private variables.  Any identifier "
"of the form ``__spam`` (at least two leading underscores, at most one "
"trailing underscore) is textually replaced with ``_classname__spam``, where "
"``classname`` is the current class name with any leading underscores "
"stripped."
msgstr ""
"Variabelnamn med dubbla inledande understreck \"manglas\" för att ge ett "
"enkelt men effektivt sätt att definiera privata klassvariabler.  Alla "
"identifierare av formen ``__spam`` (minst två inledande understrykningar, "
"högst en efterföljande understrykning) ersätts textuellt med "
"``_classname__spam``, där ``classname`` är det aktuella klassnamnet med "
"eventuella inledande understrykningar borttagna."

#: ../../faq/programming.rst:1751
msgid ""
"The identifier can be used unchanged within the class, but to access it "
"outside the class, the mangled name must be used:"
msgstr ""
"Identifieraren kan användas oförändrad inom klassen, men för att komma åt "
"den utanför klassen måste det manglade namnet användas:"

#: ../../faq/programming.rst:1754
msgid ""
"class A:\n"
"    def __one(self):\n"
"        return 1\n"
"    def two(self):\n"
"        return 2 * self.__one()\n"
"\n"
"class B(A):\n"
"    def three(self):\n"
"        return 3 * self._A__one()\n"
"\n"
"four = 4 * A()._A__one()"
msgstr ""
"class A:\n"
"    def __one(self):\n"
"        return 1\n"
"    def two(self):\n"
"        return 2 * self.__one()\n"
"\n"
"class B(A):\n"
"    def three(self):\n"
"        return 3 * self._A__one()\n"
"\n"
"four = 4 * A()._A__one()"

#: ../../faq/programming.rst:1768
msgid ""
"In particular, this does not guarantee privacy since an outside user can "
"still deliberately access the private attribute; many Python programmers "
"never bother to use private variable names at all."
msgstr ""
"I synnerhet garanterar detta inte sekretess eftersom en utomstående "
"användare fortfarande avsiktligt kan komma åt det privata attributet; många "
"Python-programmerare bryr sig aldrig om att använda privata variabelnamn "
"alls."

#: ../../faq/programming.rst:1774
msgid ""
"The :ref:`private name mangling specifications <private-name-mangling>` for "
"details and special cases."
msgstr ""
"Specifikationerna för :ref:`privat namnmangling <private-name-mangling>` för"
" detaljer och specialfall."

#: ../../faq/programming.rst:1778
msgid ""
"My class defines __del__ but it is not called when I delete the object."
msgstr ""
"Min klass definierar __del__ men den anropas inte när jag tar bort objektet."

#: ../../faq/programming.rst:1780
msgid "There are several possible reasons for this."
msgstr "Det finns flera möjliga orsaker till detta."

#: ../../faq/programming.rst:1782
msgid ""
"The :keyword:`del` statement does not necessarily call "
":meth:`~object.__del__` -- it simply decrements the object's reference "
"count, and if this reaches zero :meth:`!__del__` is called."
msgstr ""
"Satsen :keyword:`del` anropar inte nödvändigtvis :meth:`~object.__del__` -- "
"den minskar helt enkelt objektets referensantal, och om det når noll anropas"
" :meth:`!__del__`."

#: ../../faq/programming.rst:1786
msgid ""
"If your data structures contain circular links (e.g. a tree where each child"
" has a parent reference and each parent has a list of children) the "
"reference counts will never go back to zero.  Once in a while Python runs an"
" algorithm to detect such cycles, but the garbage collector might run some "
"time after the last reference to your data structure vanishes, so your "
":meth:`!__del__` method may be called at an inconvenient and random time. "
"This is inconvenient if you're trying to reproduce a problem. Worse, the "
"order in which object's :meth:`!__del__` methods are executed is arbitrary."
"  You can run :func:`gc.collect` to force a collection, but there *are* "
"pathological cases where objects will never be collected."
msgstr ""
"Om dina datastrukturer innehåller cirkulära länkar (t.ex. ett träd där varje"
" barn har en föräldrareferens och varje förälder har en lista med barn) "
"kommer referensantalet aldrig att gå tillbaka till noll.  Då och då kör "
"Python en algoritm för att upptäcka sådana cykler, men skräpsamlaren kan "
"köras en tid efter att den sista referensen till din datastruktur "
"försvinner, så din :meth:`!__del__`\\-metod kan anropas vid en obekväm och "
"slumpmässig tidpunkt. Detta är obekvämt om du försöker återskapa ett "
"problem. Ännu värre är att ordningen i vilken objektets "
":meth:`!__del__`\\-metoder utförs är godtycklig.  Du kan köra "
":func:`gc.collect` för att tvinga fram en insamling, men det *finns* "
"patologiska fall där objekt aldrig kommer att samlas in."

#: ../../faq/programming.rst:1797
msgid ""
"Despite the cycle collector, it's still a good idea to define an explicit "
"``close()`` method on objects to be called whenever you're done with them.  "
"The ``close()`` method can then remove attributes that refer to subobjects."
"  Don't call :meth:`!__del__` directly -- :meth:`!__del__` should call "
"``close()`` and ``close()`` should make sure that it can be called more than"
" once for the same object."
msgstr ""
"Trots cykelinsamlaren är det fortfarande en bra idé att definiera en "
"explicit ``close()`` -metod på objekt som ska anropas när du är klar med "
"dem. Metoden ``close()`` kan sedan ta bort attribut som refererar till "
"underobjekt. Anropa inte :meth:`!__del__` direkt – :meth:`!__del__` ska "
"anropa ``close()`` och ``close()`` ska se till att den kan anropas mer än en"
" gång för samma objekt."

#: ../../faq/programming.rst:1804
msgid ""
"Another way to avoid cyclical references is to use the :mod:`weakref` "
"module, which allows you to point to objects without incrementing their "
"reference count. Tree data structures, for instance, should use weak "
"references for their parent and sibling references (if they need them!)."
msgstr ""
"Ett annat sätt att undvika cykliska referenser är att använda modulen "
":mod:`weakref`, som gör att du kan peka på objekt utan att öka deras "
"referensantal. Träddatastrukturer, till exempel, bör använda svaga "
"referenser för sina föräldra- och syskonreferenser (om de behöver dem!)."

#: ../../faq/programming.rst:1817
msgid ""
"Finally, if your :meth:`!__del__` method raises an exception, a warning "
"message is printed to :data:`sys.stderr`."
msgstr ""
"Slutligen, om din :meth:`!__del__`\\-metod ger upphov till ett undantag, "
"skrivs ett varningsmeddelande ut till :data:`sys.stderr`."

#: ../../faq/programming.rst:1822
msgid "How do I get a list of all instances of a given class?"
msgstr "Hur får jag en lista över alla instanser av en viss klass?"

#: ../../faq/programming.rst:1824
msgid ""
"Python does not keep track of all instances of a class (or of a built-in "
"type). You can program the class's constructor to keep track of all "
"instances by keeping a list of weak references to each instance."
msgstr ""
"Python håller inte reda på alla instanser av en klass (eller av en inbyggd "
"typ). Du kan programmera klassens konstruktor att hålla reda på alla "
"instanser genom att hålla en lista med svaga referenser till varje instans."

#: ../../faq/programming.rst:1830
msgid "Why does the result of ``id()`` appear to be not unique?"
msgstr "Varför verkar resultatet av ``id()`` inte vara unikt?"

#: ../../faq/programming.rst:1832
msgid ""
"The :func:`id` builtin returns an integer that is guaranteed to be unique "
"during the lifetime of the object.  Since in CPython, this is the object's "
"memory address, it happens frequently that after an object is deleted from "
"memory, the next freshly created object is allocated at the same position in"
" memory.  This is illustrated by this example:"
msgstr ""
"Inbyggda :func:`id` returnerar ett heltal som garanterat är unikt under "
"objektets livstid.  Eftersom detta i CPython är objektets minnesadress "
"händer det ofta att efter att ett objekt har raderats från minnet, allokeras"
" nästa nyskapade objekt på samma position i minnet.  Detta illustreras av "
"detta exempel:"

#: ../../faq/programming.rst:1843
msgid ""
"The two ids belong to different integer objects that are created before, and"
" deleted immediately after execution of the ``id()`` call.  To be sure that "
"objects whose id you want to examine are still alive, create another "
"reference to the object:"
msgstr ""
"De två id:na tillhör olika heltalsobjekt som skapas före och raderas "
"omedelbart efter att anropet ``id()`` har utförts.  För att vara säker på "
"att objekt vars id du vill undersöka fortfarande är vid liv, skapar du en "
"annan referens till objektet:"

#: ../../faq/programming.rst:1856
msgid "When can I rely on identity tests with the *is* operator?"
msgstr "När kan jag förlita mig på identitetstester med operatorn *is*?"

#: ../../faq/programming.rst:1858
msgid ""
"The ``is`` operator tests for object identity.  The test ``a is b`` is "
"equivalent to ``id(a) == id(b)``."
msgstr ""
"Operatorn ``is`` testar objektets identitet.  Testet ``a is b`` är "
"likvärdigt med ``id(a) == id(b)``."

#: ../../faq/programming.rst:1861
msgid ""
"The most important property of an identity test is that an object is always "
"identical to itself, ``a is a`` always returns ``True``.  Identity tests are"
" usually faster than equality tests.  And unlike equality tests, identity "
"tests are guaranteed to return a boolean ``True`` or ``False``."
msgstr ""
"Den viktigaste egenskapen hos ett identitetstest är att ett objekt alltid är"
" identiskt med sig självt, ``a is a`` returnerar alltid ``True``.  "
"Identitetstester är vanligtvis snabbare än likhetstester.  Och till skillnad"
" från likhetstester är identitetstester garanterade att returnera en boolean"
" ``True`` eller ``False``."

#: ../../faq/programming.rst:1866
msgid ""
"However, identity tests can *only* be substituted for equality tests when "
"object identity is assured.  Generally, there are three circumstances where "
"identity is guaranteed:"
msgstr ""
"Identitetstester kan dock *endast* ersättas med likhetstester när objektets "
"identitet är säkerställd.  I allmänhet finns det tre omständigheter där "
"identiteten är garanterad:"

#: ../../faq/programming.rst:1870
msgid ""
"Assignments create new names but do not change object identity.  After the "
"assignment ``new = old``, it is guaranteed that ``new is old``."
msgstr ""
"Tilldelningar skapar nya namn men ändrar inte objektets identitet.  Efter "
"tilldelningen ``new = old`` är det garanterat att ``new is old``."

#: ../../faq/programming.rst:1873
msgid ""
"Putting an object in a container that stores object references does not "
"change object identity.  After the list assignment ``s[0] = x``, it is "
"guaranteed that ``s[0] is x``."
msgstr ""
"Att placera ett objekt i en behållare som lagrar objektreferenser ändrar "
"inte objektets identitet.  Efter listtilldelningen ``s[0] = x`` är det "
"garanterat att ``s[0] is x``."

#: ../../faq/programming.rst:1877
msgid ""
"If an object is a singleton, it means that only one instance of that object "
"can exist.  After the assignments ``a = None`` and ``b = None``, it is "
"guaranteed that ``a is b`` because ``None`` is a singleton."
msgstr ""
"Om ett objekt är en singleton betyder det att det bara kan finnas en instans"
" av objektet.  Efter tilldelningarna ``a = None`` och ``b = None`` är det "
"garanterat att ``a is b`` eftersom ``None`` är en singleton."

#: ../../faq/programming.rst:1881
msgid ""
"In most other circumstances, identity tests are inadvisable and equality "
"tests are preferred.  In particular, identity tests should not be used to "
"check constants such as :class:`int` and :class:`str` which aren't "
"guaranteed to be singletons::"
msgstr ""
"Under de flesta andra omständigheter är identitetstester inte tillrådliga "
"och likhetstester är att föredra.  I synnerhet bör identitetstester inte "
"användas för att kontrollera konstanter som :class:`int` och :class:`str` "
"som inte garanterat är singletoner::"

#: ../../faq/programming.rst:1886
msgid ""
">>> a = 1000\n"
">>> b = 500\n"
">>> c = b + 500\n"
">>> a is c\n"
"False\n"
"\n"
">>> a = 'Python'\n"
">>> b = 'Py'\n"
">>> c = b + 'thon'\n"
">>> a is c\n"
"False"
msgstr ""
">>> a = 1000\n"
">>> b = 500\n"
">>> c = b + 500\n"
">>> a is c\n"
"False\n"
"\n"
">>> a = 'Python'\n"
">>> b = 'Py'\n"
">>> c = b + 'thon'\n"
">>> a is c\n"
"False"

#: ../../faq/programming.rst:1898
msgid "Likewise, new instances of mutable containers are never identical::"
msgstr "På samma sätt är nya instanser av mutabla behållare aldrig identiska:"

#: ../../faq/programming.rst:1900
msgid ""
">>> a = []\n"
">>> b = []\n"
">>> a is b\n"
"False"
msgstr ""
">>> a = []\n"
">>> b = []\n"
">>> a is b\n"
"False"

#: ../../faq/programming.rst:1905
msgid ""
"In the standard library code, you will see several common patterns for "
"correctly using identity tests:"
msgstr ""
"I standardbibliotekskoden ser du flera vanliga mönster för korrekt "
"användning av identitetstester:"

#: ../../faq/programming.rst:1908
msgid ""
"As recommended by :pep:`8`, an identity test is the preferred way to check "
"for ``None``.  This reads like plain English in code and avoids confusion "
"with other objects that may have boolean values that evaluate to false."
msgstr ""
"Som rekommenderas av :pep:`8`, är ett identitetstest det föredragna sättet "
"att kontrollera för ``None``.  Detta låter som vanlig engelska i koden och "
"undviker förvirring med andra objekt som kan ha booleska värden som "
"utvärderas till false."

#: ../../faq/programming.rst:1912
msgid ""
"Detecting optional arguments can be tricky when ``None`` is a valid input "
"value.  In those situations, you can create a singleton sentinel object "
"guaranteed to be distinct from other objects.  For example, here is how to "
"implement a method that behaves like :meth:`dict.pop`:"
msgstr ""
"Det kan vara svårt att upptäcka valfria argument när ``None`` är ett giltigt"
" inmatningsvärde.  I sådana situationer kan du skapa ett singleton sentinel-"
"objekt som garanterat skiljer sig från andra objekt.  Så här kan du till "
"exempel implementera en metod som beter sig som :meth:`dict.pop`:"

#: ../../faq/programming.rst:1917
msgid ""
"_sentinel = object()\n"
"\n"
"def pop(self, key, default=_sentinel):\n"
"    if key in self:\n"
"        value = self[key]\n"
"        del self[key]\n"
"        return value\n"
"    if default is _sentinel:\n"
"        raise KeyError(key)\n"
"    return default"
msgstr ""
"_sentinel = objekt()\n"
"\n"
"def pop(self, key, default=_sentinel):\n"
"    if nyckel i self:\n"
"        värde = self[nyckel]\n"
"        del self[nyckel]\n"
"        returnera värde\n"
"    om standard är _sentinel:\n"
"        raise KeyError(nyckel)\n"
"    returnera standard"

#: ../../faq/programming.rst:1930
msgid ""
"Container implementations sometimes need to augment equality tests with "
"identity tests.  This prevents the code from being confused by objects such "
"as ``float('NaN')`` that are not equal to themselves."
msgstr ""
"Containerimplementationer behöver ibland komplettera likhetstester med "
"identitetstester.  Detta förhindrar att koden blir förvirrad av objekt som "
"``float('NaN')`` som inte är lika med sig själva."

#: ../../faq/programming.rst:1934
msgid ""
"For example, here is the implementation of "
":meth:`!collections.abc.Sequence.__contains__`::"
msgstr ""
"Här är till exempel implementeringen av "
":meth:`!collections.abc.Sequence.__contains__`::"

#: ../../faq/programming.rst:1937
msgid ""
"def __contains__(self, value):\n"
"    for v in self:\n"
"        if v is value or v == value:\n"
"            return True\n"
"    return False"
msgstr ""
"def __contains__(self, värde):\n"
"    for v in self:\n"
"        om v är värde eller v == värde:\n"
"            return True\n"
"    returnera Falskt"

#: ../../faq/programming.rst:1945
msgid ""
"How can a subclass control what data is stored in an immutable instance?"
msgstr ""
"Hur kan en underklass styra vilka data som lagras i en oföränderlig instans?"

#: ../../faq/programming.rst:1947
msgid ""
"When subclassing an immutable type, override the :meth:`~object.__new__` "
"method instead of the :meth:`~object.__init__` method.  The latter only runs"
" *after* an instance is created, which is too late to alter data in an "
"immutable instance."
msgstr ""
"När du subklassar en oföränderlig typ ska du åsidosätta metoden "
":meth:`~object.__new__` i stället för metoden :meth:`~object.__init__`.  Den"
" senare körs bara *efter* att en instans har skapats, vilket är för sent för"
" att ändra data i en oföränderlig instans."

#: ../../faq/programming.rst:1952
msgid ""
"All of these immutable classes have a different signature than their parent "
"class:"
msgstr ""
"Alla dessa oföränderliga klasser har en annan signatur än sin överordnade "
"klass:"

#: ../../faq/programming.rst:1955
msgid ""
"from datetime import date\n"
"\n"
"class FirstOfMonthDate(date):\n"
"    \"Always choose the first day of the month\"\n"
"    def __new__(cls, year, month, day):\n"
"        return super().__new__(cls, year, month, 1)\n"
"\n"
"class NamedInt(int):\n"
"    \"Allow text names for some numbers\"\n"
"    xlat = {'zero': 0, 'one': 1, 'ten': 10}\n"
"    def __new__(cls, value):\n"
"        value = cls.xlat.get(value, value)\n"
"        return super().__new__(cls, value)\n"
"\n"
"class TitleStr(str):\n"
"    \"Convert str to name suitable for a URL path\"\n"
"    def __new__(cls, s):\n"
"        s = s.lower().replace(' ', '-')\n"
"        s = ''.join([c for c in s if c.isalnum() or c == '-'])\n"
"        return super().__new__(cls, s)"
msgstr ""
"from datetime import date\n"
"\n"
"class FirstOfMonthDate(date):\n"
"    \"Always choose the first day of the month\"\n"
"    def __new__(cls, year, month, day):\n"
"        return super().__new__(cls, year, month, 1)\n"
"\n"
"class NamedInt(int):\n"
"    \"Allow text names for some numbers\"\n"
"    xlat = {'zero': 0, 'one': 1, 'ten': 10}\n"
"    def __new__(cls, value):\n"
"        value = cls.xlat.get(value, value)\n"
"        return super().__new__(cls, value)\n"
"\n"
"class TitleStr(str):\n"
"    \"Convert str to name suitable for a URL path\"\n"
"    def __new__(cls, s):\n"
"        s = s.lower().replace(' ', '-')\n"
"        s = ''.join([c for c in s if c.isalnum() or c == '-'])\n"
"        return super().__new__(cls, s)"

#: ../../faq/programming.rst:1978
msgid "The classes can be used like this:"
msgstr "Klasserna kan användas på följande sätt:"

#: ../../faq/programming.rst:1980
msgid ""
">>> FirstOfMonthDate(2012, 2, 14)\n"
"FirstOfMonthDate(2012, 2, 1)\n"
">>> NamedInt('ten')\n"
"10\n"
">>> NamedInt(20)\n"
"20\n"
">>> TitleStr('Blog: Why Python Rocks')\n"
"'blog-why-python-rocks'"
msgstr ""
">>> FirstOfMonthDate(2012, 2, 14)\n"
"FirstOfMonthDate(2012, 2, 1)\n"
">>> NamedInt('ten')\n"
"10\n"
">>> NamedInt(20)\n"
"20\n"
">>> TitleStr('Blog: Why Python Rocks')\n"
"'blog-why-python-rocks'"

#: ../../faq/programming.rst:1995
msgid "How do I cache method calls?"
msgstr "Hur cachar jag metodanrop?"

#: ../../faq/programming.rst:1997
msgid ""
"The two principal tools for caching methods are "
":func:`functools.cached_property` and :func:`functools.lru_cache`.  The "
"former stores results at the instance level and the latter at the class "
"level."
msgstr ""
"De två viktigaste verktygen för att cachelagra metoder är "
":func:`functools.cached_property` och :func:`functools.lru_cache`.  Det "
"förstnämnda lagrar resultat på instansnivå och det sistnämnda på klassnivå."

#: ../../faq/programming.rst:2002
msgid ""
"The *cached_property* approach only works with methods that do not take any "
"arguments.  It does not create a reference to the instance.  The cached "
"method result will be kept only as long as the instance is alive."
msgstr ""
"Metoden *cached_property* fungerar bara med metoder som inte tar några "
"argument.  Den skapar inte någon referens till instansen.  Det cachade "
"metodresultatet sparas bara så länge som instansen är vid liv."

#: ../../faq/programming.rst:2006
msgid ""
"The advantage is that when an instance is no longer used, the cached method "
"result will be released right away.  The disadvantage is that if instances "
"accumulate, so too will the accumulated method results.  They can grow "
"without bound."
msgstr ""
"Fördelen är att när en instans inte längre används kommer det cachade "
"metodresultatet att släppas direkt.  Nackdelen är att om instanser "
"ackumuleras, så kommer även de ackumulerade metodresultaten att göra det.  "
"De kan växa utan gräns."

#: ../../faq/programming.rst:2011
msgid ""
"The *lru_cache* approach works with methods that have :term:`hashable` "
"arguments.  It creates a reference to the instance unless special efforts "
"are made to pass in weak references."
msgstr ""
"Metoden *lru_cache* fungerar med metoder som har "
":term:`hashable`\\-argument.  Den skapar en referens till instansen om inte "
"särskilda ansträngningar görs för att skicka in svaga referenser."

#: ../../faq/programming.rst:2015
msgid ""
"The advantage of the least recently used algorithm is that the cache is "
"bounded by the specified *maxsize*.  The disadvantage is that instances are "
"kept alive until they age out of the cache or until the cache is cleared."
msgstr ""
"Fördelen med den senast använda algoritmen är att cacheminnet begränsas av "
"den angivna *maxstorleken*.  Nackdelen är att instanser hålls vid liv tills "
"de åldras ur cacheminnet eller tills cacheminnet rensas."

#: ../../faq/programming.rst:2020
msgid "This example shows the various techniques::"
msgstr "Detta exempel visar de olika teknikerna::"

#: ../../faq/programming.rst:2022
msgid ""
"class Weather:\n"
"    \"Lookup weather information on a government website\"\n"
"\n"
"    def __init__(self, station_id):\n"
"        self._station_id = station_id\n"
"        # The _station_id is private and immutable\n"
"\n"
"    def current_temperature(self):\n"
"        \"Latest hourly observation\"\n"
"        # Do not cache this because old results\n"
"        # can be out of date.\n"
"\n"
"    @cached_property\n"
"    def location(self):\n"
"        \"Return the longitude/latitude coordinates of the station\"\n"
"        # Result only depends on the station_id\n"
"\n"
"    @lru_cache(maxsize=20)\n"
"    def historic_rainfall(self, date, units='mm'):\n"
"        \"Rainfall on a given date\"\n"
"        # Depends on the station_id, date, and units."
msgstr ""
"class Weather:\n"
"    \"Lookup weather information on a government website\"\n"
"\n"
"    def __init__(self, station_id):\n"
"        self._station_id = station_id\n"
"        # The _station_id is private and immutable\n"
"\n"
"    def current_temperature(self):\n"
"        \"Latest hourly observation\"\n"
"        # Do not cache this because old results\n"
"        # can be out of date.\n"
"\n"
"    @cached_property\n"
"    def location(self):\n"
"        \"Return the longitude/latitude coordinates of the station\"\n"
"        # Result only depends on the station_id\n"
"\n"
"    @lru_cache(maxsize=20)\n"
"    def historic_rainfall(self, date, units='mm'):\n"
"        \"Rainfall on a given date\"\n"
"        # Depends on the station_id, date, and units."

#: ../../faq/programming.rst:2044
msgid ""
"The above example assumes that the *station_id* never changes.  If the "
"relevant instance attributes are mutable, the *cached_property* approach "
"can't be made to work because it cannot detect changes to the attributes."
msgstr ""
"I exemplet ovan antas att *station_id* aldrig ändras.  Om de relevanta "
"instansattributen är föränderliga kan *cached_property*-metoden inte fungera"
" eftersom den inte kan upptäcka ändringar av attributen."

#: ../../faq/programming.rst:2049
msgid ""
"To make the *lru_cache* approach work when the *station_id* is mutable, the "
"class needs to define the :meth:`~object.__eq__` and "
":meth:`~object.__hash__` methods so that the cache can detect relevant "
"attribute updates::"
msgstr ""
"För att *lru_cache*-strategin ska fungera när *station_id* är föränderligt "
"måste klassen definiera metoderna :meth:`~object.__eq__` och "
":meth:`~object.__hash__` så att cachen kan upptäcka relevanta "
"attributuppdateringar::"

#: ../../faq/programming.rst:2053
msgid ""
"class Weather:\n"
"    \"Example with a mutable station identifier\"\n"
"\n"
"    def __init__(self, station_id):\n"
"        self.station_id = station_id\n"
"\n"
"    def change_station(self, station_id):\n"
"        self.station_id = station_id\n"
"\n"
"    def __eq__(self, other):\n"
"        return self.station_id == other.station_id\n"
"\n"
"    def __hash__(self):\n"
"        return hash(self.station_id)\n"
"\n"
"    @lru_cache(maxsize=20)\n"
"    def historic_rainfall(self, date, units='cm'):\n"
"        'Rainfall on a given date'\n"
"        # Depends on the station_id, date, and units."
msgstr ""
"class Weather:\n"
"    \"Example with a mutable station identifier\"\n"
"\n"
"    def __init__(self, station_id):\n"
"        self.station_id = station_id\n"
"\n"
"    def change_station(self, station_id):\n"
"        self.station_id = station_id\n"
"\n"
"    def __eq__(self, other):\n"
"        return self.station_id == other.station_id\n"
"\n"
"    def __hash__(self):\n"
"        return hash(self.station_id)\n"
"\n"
"    @lru_cache(maxsize=20)\n"
"    def historic_rainfall(self, date, units='cm'):\n"
"        'Rainfall on a given date'\n"
"        # Depends on the station_id, date, and units."

#: ../../faq/programming.rst:2075
msgid "Modules"
msgstr "Moduler"

#: ../../faq/programming.rst:2078
msgid "How do I create a .pyc file?"
msgstr "Hur skapar jag en .pyc-fil?"

#: ../../faq/programming.rst:2080
msgid ""
"When a module is imported for the first time (or when the source file has "
"changed since the current compiled file was created) a ``.pyc`` file "
"containing the compiled code should be created in a ``__pycache__`` "
"subdirectory of the directory containing the ``.py`` file.  The ``.pyc`` "
"file will have a filename that starts with the same name as the ``.py`` "
"file, and ends with ``.pyc``, with a middle component that depends on the "
"particular ``python`` binary that created it.  (See :pep:`3147` for "
"details.)"
msgstr ""
"När en modul importeras för första gången (eller när källfilen har ändrats "
"sedan den aktuella kompilerade filen skapades) ska en fil med namnet "
"``.pyc`` som innehåller den kompilerade koden skapas i en underkatalog med "
"namnet ``__pycache__`` i katalogen som innehåller filen ``.py``. Filen "
"``.pyc`` har ett filnamn som börjar med samma namn som filen ``.py`` och "
"slutar med ``.pyc``, med en mittdel som beror på den specifika "
"``python``\\-binärfil som skapade den. (Se :pep:`3147` för mer information.)"

#: ../../faq/programming.rst:2088
msgid ""
"One reason that a ``.pyc`` file may not be created is a permissions problem "
"with the directory containing the source file, meaning that the "
"``__pycache__`` subdirectory cannot be created. This can happen, for "
"example, if you develop as one user but run as another, such as if you are "
"testing with a web server."
msgstr ""
"En anledning till att en ``.pyc`` -fil inte skapas kan vara ett "
"behörighetsproblem med katalogen som innehåller källfilen, vilket innebär "
"att underkatalogen ``__pycache__`` inte kan skapas. Detta kan till exempel "
"inträffa om du utvecklar som en användare men kör som en annan, till exempel"
" om du testar med en webbserver."

#: ../../faq/programming.rst:2093
msgid ""
"Unless the :envvar:`PYTHONDONTWRITEBYTECODE` environment variable is set, "
"creation of a .pyc file is automatic if you're importing a module and Python"
" has the ability (permissions, free space, etc...) to create a "
"``__pycache__`` subdirectory and write the compiled module to that "
"subdirectory."
msgstr ""
"Om inte miljövariabeln :envvar:`PYTHONDONTWRITEBYTECODE` är inställd, skapas"
" en .pyc-fil automatiskt om du importerar en modul och Python har möjlighet "
"(behörigheter, ledigt utrymme, etc...) att skapa en ``__pycache__`` "
"underkatalog och skriva den kompilerade modulen till den underkatalogen."

#: ../../faq/programming.rst:2098
msgid ""
"Running Python on a top level script is not considered an import and no "
"``.pyc`` will be created.  For example, if you have a top-level module "
"``foo.py`` that imports another module ``xyz.py``, when you run ``foo`` (by "
"typing ``python foo.py`` as a shell command), a ``.pyc`` will be created for"
" ``xyz`` because ``xyz`` is imported, but no ``.pyc`` file will be created "
"for ``foo`` since ``foo.py`` isn't being imported."
msgstr ""
"Att köra Python på ett skript på högsta nivå betraktas inte som en import "
"och ingen ``.pyc`` kommer att skapas. Om du till exempel har en modul på "
"högsta nivå ``foo.py`` som importerar en annan modul ``xyz.py``, kommer en "
"``.pyc`` att skapas för ``xyz`` när du kör ``foo`` (genom att skriva "
"``python foo.py`` som ett skal-kommando) skapas en ``.pyc`` för ``xyz`` "
"eftersom ``xyz`` importeras, men ingen ``.pyc``\\-fil skapas för ``foo`` "
"eftersom ``foo.py`` inte importeras."

#: ../../faq/programming.rst:2105
msgid ""
"If you need to create a ``.pyc`` file for ``foo`` -- that is, to create a "
"``.pyc`` file for a module that is not imported -- you can, using the "
":mod:`py_compile` and :mod:`compileall` modules."
msgstr ""
"Om du behöver skapa en ``.pyc``\\-fil för ``foo`` -- det vill säga skapa en "
"``.pyc``\\-fil för en modul som inte importeras -- kan du göra det med "
"modulerna :mod:`py_compile` och :mod:`compileall`."

#: ../../faq/programming.rst:2109
msgid ""
"The :mod:`py_compile` module can manually compile any module.  One way is to"
" use the ``compile()`` function in that module interactively::"
msgstr ""
"Modulen :mod:`py_compile` kan manuellt kompilera valfri modul.  Ett sätt är "
"att använda ``compile()``\\-funktionen i den modulen interaktivt::"

#: ../../faq/programming.rst:2112
msgid ""
">>> import py_compile\n"
">>> py_compile.compile('foo.py')"
msgstr ""
">>> import py_compile\n"
">>> py_compile.compile('foo.py')"

#: ../../faq/programming.rst:2115
msgid ""
"This will write the ``.pyc`` to a ``__pycache__`` subdirectory in the same "
"location as ``foo.py`` (or you can override that with the optional parameter"
" ``cfile``)."
msgstr ""
"Detta kommer att skriva ``.pyc`` till en ``__pycache__`` underkatalog på "
"samma plats som ``foo.py`` (eller så kan du åsidosätta det med den valfria "
"parametern ``cfile``)."

#: ../../faq/programming.rst:2119
msgid ""
"You can also automatically compile all files in a directory or directories "
"using the :mod:`compileall` module.  You can do it from the shell prompt by "
"running ``compileall.py`` and providing the path of a directory containing "
"Python files to compile::"
msgstr ""
"Du kan också automatiskt kompilera alla filer i en katalog eller flera "
"kataloger med modulen :mod:`compileall`.  Du kan göra det från skalprompten "
"genom att köra ``compileall.py`` och ange sökvägen till en katalog som "
"innehåller Python-filer som ska kompileras::"

#: ../../faq/programming.rst:2124
msgid "python -m compileall ."
msgstr "python -m compileall ."

#: ../../faq/programming.rst:2128
msgid "How do I find the current module name?"
msgstr "Hur hittar jag det aktuella modulnamnet?"

#: ../../faq/programming.rst:2130
msgid ""
"A module can find out its own module name by looking at the predefined "
"global variable ``__name__``.  If this has the value ``'__main__'``, the "
"program is running as a script.  Many modules that are usually used by "
"importing them also provide a command-line interface or a self-test, and "
"only execute this code after checking ``__name__``::"
msgstr ""
"En modul kan ta reda på sitt eget modulnamn genom att titta på den "
"fördefinierade globala variabeln ``__name__``.  Om denna har värdet "
"``'__main__'`` körs programmet som ett skript.  Många moduler som vanligtvis"
" används genom att importera dem tillhandahåller också ett "
"kommandoradsgränssnitt eller ett självtest, och kör endast denna kod efter "
"att ha kontrollerat ``__name__``::"

#: ../../faq/programming.rst:2136
msgid ""
"def main():\n"
"    print('Running test...')\n"
"    ...\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""
"def main():\n"
"    print('Kör test...')\n"
"    ...\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"

#: ../../faq/programming.rst:2145
msgid "How can I have modules that mutually import each other?"
msgstr "Hur kan jag ha moduler som ömsesidigt importerar varandra?"

#: ../../faq/programming.rst:2147
msgid "Suppose you have the following modules:"
msgstr "Anta att du har följande moduler:"

#: ../../faq/programming.rst:2149
msgid ":file:`foo.py`::"
msgstr ":file:`foo.py`::"

#: ../../faq/programming.rst:2151
msgid ""
"from bar import bar_var\n"
"foo_var = 1"
msgstr ""
"from bar import bar_var\n"
"foo_var = 1"

#: ../../faq/programming.rst:2154
msgid ":file:`bar.py`::"
msgstr ":file:`bar.py`::"

#: ../../faq/programming.rst:2156
msgid ""
"from foo import foo_var\n"
"bar_var = 2"
msgstr ""
"from foo import foo_var\n"
"bar_var = 2"

#: ../../faq/programming.rst:2159
msgid "The problem is that the interpreter will perform the following steps:"
msgstr "Problemet är att tolken kommer att utföra följande steg:"

#: ../../faq/programming.rst:2161
msgid "main imports ``foo``"
msgstr "main imports ``foo``"

#: ../../faq/programming.rst:2162
msgid "Empty globals for ``foo`` are created"
msgstr "Tomma globaler för ``foo`` skapas"

#: ../../faq/programming.rst:2163
msgid "``foo`` is compiled and starts executing"
msgstr "``foo`` kompileras och börjar exekveras"

#: ../../faq/programming.rst:2164
msgid "``foo`` imports ``bar``"
msgstr "``foo`` imports ``bar``"

#: ../../faq/programming.rst:2165
msgid "Empty globals for ``bar`` are created"
msgstr "Tomma globaler för ``bar`` skapas"

#: ../../faq/programming.rst:2166
msgid "``bar`` is compiled and starts executing"
msgstr "``bar`` kompileras och börjar exekveras"

#: ../../faq/programming.rst:2167
msgid ""
"``bar`` imports ``foo`` (which is a no-op since there already is a module "
"named ``foo``)"
msgstr ""
"``bar`` imports ``foo`` (vilket är en no-op eftersom det redan finns en "
"modul som heter ``foo``)"

#: ../../faq/programming.rst:2168
msgid ""
"The import mechanism tries to read ``foo_var`` from ``foo`` globals, to set "
"``bar.foo_var = foo.foo_var``"
msgstr ""
"Importmekanismen försöker läsa ``foo_var`` från ``foo`` globaler, för att "
"ställa in ``bar.foo_var = foo.foo_var``"

#: ../../faq/programming.rst:2170
msgid ""
"The last step fails, because Python isn't done with interpreting ``foo`` yet"
" and the global symbol dictionary for ``foo`` is still empty."
msgstr ""
"Det sista steget misslyckas, eftersom Python inte är klar med tolkningen av "
"``foo`` ännu och den globala symbolordboken för ``foo`` fortfarande är tom."

#: ../../faq/programming.rst:2173
msgid ""
"The same thing happens when you use ``import foo``, and then try to access "
"``foo.foo_var`` in global code."
msgstr ""
"Samma sak händer när man använder ``import foo`` och sedan försöker komma åt"
" ``foo.foo_var`` i global kod."

#: ../../faq/programming.rst:2176
msgid "There are (at least) three possible workarounds for this problem."
msgstr "Det finns (minst) tre möjliga lösningar på det här problemet."

#: ../../faq/programming.rst:2178
msgid ""
"Guido van Rossum recommends avoiding all uses of ``from <module> import "
"...``, and placing all code inside functions.  Initializations of global "
"variables and class variables should use constants or built-in functions "
"only.  This means everything from an imported module is referenced as "
"``<module>.<name>``."
msgstr ""
"Guido van Rossum rekommenderar att man undviker all användning av ``from "
"<module> import ...`` och att all kod placeras i funktioner.  "
"Initialiseringar av globala variabler och klassvariabler bör endast använda "
"konstanter eller inbyggda funktioner.  Detta innebär att allt från en "
"importerad modul refereras som ``<module>.<name>``."

#: ../../faq/programming.rst:2183
msgid ""
"Jim Roskind suggests performing steps in the following order in each module:"
msgstr ""
"Jim Roskind föreslår att du utför stegen i följande ordning i varje modul:"

#: ../../faq/programming.rst:2185
msgid ""
"exports (globals, functions, and classes that don't need imported base "
"classes)"
msgstr ""
"export (globaler, funktioner och klasser som inte behöver importerade "
"basklasser)"

#: ../../faq/programming.rst:2187
msgid "``import`` statements"
msgstr "``import`` statements"

#: ../../faq/programming.rst:2188
msgid ""
"active code (including globals that are initialized from imported values)."
msgstr "aktiv kod (inklusive globaler som initieras från importerade värden)."

#: ../../faq/programming.rst:2190
msgid ""
"Van Rossum doesn't like this approach much because the imports appear in a "
"strange place, but it does work."
msgstr ""
"Van Rossum tycker inte så mycket om den här metoden eftersom importen hamnar"
" på ett konstigt ställe, men den fungerar."

#: ../../faq/programming.rst:2193
msgid ""
"Matthias Urlichs recommends restructuring your code so that the recursive "
"import is not necessary in the first place."
msgstr ""
"Matthias Urlichs rekommenderar att du omstrukturerar din kod så att den "
"rekursiva importen inte är nödvändig i första hand."

#: ../../faq/programming.rst:2196
msgid "These solutions are not mutually exclusive."
msgstr "Dessa lösningar utesluter inte varandra."

#: ../../faq/programming.rst:2200
msgid "__import__('x.y.z') returns <module 'x'>; how do I get z?"
msgstr "__import__('x.y.z') returnerar <modul 'x'>; hur får jag z?"

#: ../../faq/programming.rst:2202
msgid ""
"Consider using the convenience function :func:`~importlib.import_module` "
"from :mod:`importlib` instead::"
msgstr ""
"Överväg att använda bekvämlighetsfunktionen :func:`~importlib.import_module`"
" från :mod:`importlib` istället::"

#: ../../faq/programming.rst:2205
msgid "z = importlib.import_module('x.y.z')"
msgstr "z = importlib.import_module('x.y.z')"

#: ../../faq/programming.rst:2209
msgid ""
"When I edit an imported module and reimport it, the changes don't show up.  "
"Why does this happen?"
msgstr ""
"När jag redigerar en importerad modul och importerar den på nytt visas inte "
"ändringarna.  Varför händer detta?"

#: ../../faq/programming.rst:2211
msgid ""
"For reasons of efficiency as well as consistency, Python only reads the "
"module file on the first time a module is imported.  If it didn't, in a "
"program consisting of many modules where each one imports the same basic "
"module, the basic module would be parsed and re-parsed many times.  To force"
" re-reading of a changed module, do this::"
msgstr ""
"Av både effektivitets- och konsekvensskäl läser Python bara modulfilen "
"första gången en modul importeras.  Om den inte gjorde det, i ett program "
"som består av många moduler där var och en importerar samma grundmodul, "
"skulle grundmodulen analyseras och omanalyseras många gånger.  Gör så här "
"för att tvinga fram omläsning av en ändrad modul::"

#: ../../faq/programming.rst:2217
msgid ""
"import importlib\n"
"import modname\n"
"importlib.reload(modname)"
msgstr ""
"import importlib\n"
"import modname\n"
"importlib.reload(modname)"

#: ../../faq/programming.rst:2221
msgid ""
"Warning: this technique is not 100% fool-proof.  In particular, modules "
"containing statements like ::"
msgstr ""
"Varning: denna teknik är inte 100% fool-säker.  I synnerhet moduler som "
"innehåller uttalanden som ::"

#: ../../faq/programming.rst:2224
msgid "from modname import some_objects"
msgstr "from modname import some_objects"

#: ../../faq/programming.rst:2226
msgid ""
"will continue to work with the old version of the imported objects.  If the "
"module contains class definitions, existing class instances will *not* be "
"updated to use the new class definition.  This can result in the following "
"paradoxical behaviour::"
msgstr ""
"kommer att fortsätta att fungera med den gamla versionen av de importerade "
"objekten.  Om modulen innehåller klassdefinitioner kommer befintliga "
"klassinstanser *inte* att uppdateras för att använda den nya "
"klassdefinitionen.  Detta kan resultera i följande paradoxala beteende::"

#: ../../faq/programming.rst:2231
msgid ""
">>> import importlib\n"
">>> import cls\n"
">>> c = cls.C()                # Create an instance of C\n"
">>> importlib.reload(cls)\n"
"<module 'cls' from 'cls.py'>\n"
">>> isinstance(c, cls.C)       # isinstance is false?!?\n"
"False"
msgstr ""
">>> import importlib\n"
">>> import cls\n"
">>> c = cls.C()                # Create an instance of C\n"
">>> importlib.reload(cls)\n"
"<module 'cls' from 'cls.py'>\n"
">>> isinstance(c, cls.C)       # isinstance is false?!?\n"
"False"

#: ../../faq/programming.rst:2239
msgid ""
"The nature of the problem is made clear if you print out the \"identity\" of"
" the class objects::"
msgstr ""
"Problemets natur klargörs om man skriver ut klassobjektens \"identitet\"::"

#: ../../faq/programming.rst:2242
msgid ""
">>> hex(id(c.__class__))\n"
"'0x7352a0'\n"
">>> hex(id(cls.C))\n"
"'0x4198d0'"
msgstr ""
">>> hex(id(c.__class__))\n"
"'0x7352a0'\n"
">>> hex(id(cls.C))\n"
"'0x4198d0'"

#: ../../faq/programming.rst:408
msgid "argument"
msgstr "argument"

#: ../../faq/programming.rst:408
msgid "difference from parameter"
msgstr "skillnad från parameter"

#: ../../faq/programming.rst:408
msgid "parameter"
msgstr "parameter"

#: ../../faq/programming.rst:408
msgid "difference from argument"
msgstr "skillnad från argument"
