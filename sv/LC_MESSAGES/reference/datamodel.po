# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-16 17:23+0000\n"
"PO-Revision-Date: 2025-09-16 00:02+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../reference/datamodel.rst:6
msgid "Data model"
msgstr "Datamodell"

#: ../../reference/datamodel.rst:12
msgid "Objects, values and types"
msgstr "Objekt, värden och typer"

#: ../../reference/datamodel.rst:18
msgid ""
":dfn:`Objects` are Python's abstraction for data.  All data in a Python "
"program is represented by objects or by relations between objects. (In a "
"sense, and in conformance to Von Neumann's model of a \"stored program "
"computer\", code is also represented by objects.)"
msgstr ""
":dfn:`Objekt` är Pythons abstraktion för data.  Alla data i ett Python-"
"program representeras av objekt eller av relationer mellan objekt. (På sätt "
"och vis, och i enlighet med Von Neumanns modell av en \"dator med lagrade "
"program\", representeras kod också av objekt)"

#: ../../reference/datamodel.rst:35
msgid ""
"Every object has an identity, a type and a value.  An object's *identity* "
"never changes once it has been created; you may think of it as the object's "
"address in memory.  The :keyword:`is` operator compares the identity of two "
"objects; the :func:`id` function returns an integer representing its "
"identity."
msgstr ""
"Varje objekt har en identitet, en typ och ett värde.  Ett objekts "
"*identitet* ändras aldrig när det väl har skapats; du kan tänka på det som "
"objektets adress i minnet.  Operatorn :keyword:`is` jämför identiteten hos "
"två objekt; funktionen :func:`id` returnerar ett heltal som representerar "
"dess identitet."

#: ../../reference/datamodel.rst:42
msgid "For CPython, ``id(x)`` is the memory address where ``x`` is stored."
msgstr "För CPython är ``id(x)`` den minnesadress där ``x`` lagras."

#: ../../reference/datamodel.rst:44
msgid ""
"An object's type determines the operations that the object supports (e.g., "
"\"does it have a length?\") and also defines the possible values for objects "
"of that type.  The :func:`type` function returns an object's type (which is "
"an object itself).  Like its identity, an object's :dfn:`type` is also "
"unchangeable. [#]_"
msgstr ""
"Ett objekts typ avgör vilka operationer som objektet stöder (t.ex. \"har det "
"en längd?\") och definierar också de möjliga värdena för objekt av den "
"typen.  Funktionen :func:`type` returnerar ett objekts typ (som i sin tur är "
"ett objekt).  Liksom dess identitet är ett objekts :dfn:`type` också "
"oföränderlig. [#]_"

#: ../../reference/datamodel.rst:50
msgid ""
"The *value* of some objects can change.  Objects whose value can change are "
"said to be *mutable*; objects whose value is unchangeable once they are "
"created are called *immutable*. (The value of an immutable container object "
"that contains a reference to a mutable object can change when the latter's "
"value is changed; however the container is still considered immutable, "
"because the collection of objects it contains cannot be changed.  So, "
"immutability is not strictly the same as having an unchangeable value, it is "
"more subtle.) An object's mutability is determined by its type; for "
"instance, numbers, strings and tuples are immutable, while dictionaries and "
"lists are mutable."
msgstr ""
"Vissa objekts *värde* kan förändras.  Objekt vars värde kan ändras sägs vara "
"*mutabla*; objekt vars värde är oföränderligt när de skapas kallas "
"*immutable*. (Värdet på ett oföränderligt containerobjekt som innehåller en "
"referens till ett föränderligt objekt kan ändras när det senare objektets "
"värde ändras; containern anses dock fortfarande vara oföränderlig, eftersom "
"samlingen av objekt som den innehåller inte kan ändras.  Så oföränderlighet "
"är inte riktigt samma sak som att ha ett oföränderligt värde, det är mer "
"subtilt) Ett objekts föränderlighet bestäms av dess typ; till exempel är "
"tal, strängar och tupler oföränderliga, medan ordböcker och listor är "
"föränderliga."

#: ../../reference/datamodel.rst:65
msgid ""
"Objects are never explicitly destroyed; however, when they become "
"unreachable they may be garbage-collected.  An implementation is allowed to "
"postpone garbage collection or omit it altogether --- it is a matter of "
"implementation quality how garbage collection is implemented, as long as no "
"objects are collected that are still reachable."
msgstr ""
"Objekt förstörs aldrig explicit, men när de blir oåtkomliga kan de bli "
"föremål för garbage-collection.  En implementering får skjuta upp "
"skräpinsamlingen eller helt utelämna den --- det är en fråga om "
"implementeringskvalitet hur skräpinsamlingen implementeras, så länge inga "
"objekt samlas in som fortfarande är nåbara."

#: ../../reference/datamodel.rst:73
msgid ""
"CPython currently uses a reference-counting scheme with (optional) delayed "
"detection of cyclically linked garbage, which collects most objects as soon "
"as they become unreachable, but is not guaranteed to collect garbage "
"containing circular references.  See the documentation of the :mod:`gc` "
"module for information on controlling the collection of cyclic garbage. "
"Other implementations act differently and CPython may change. Do not depend "
"on immediate finalization of objects when they become unreachable (so you "
"should always close files explicitly)."
msgstr ""
"CPython använder för närvarande ett referensräkningsschema med (valfri) "
"fördröjd upptäckt av cykliskt länkat skräp, som samlar in de flesta objekt "
"så snart de blir onåbara, men det är inte garanterat att skräp som "
"innehåller cirkulära referenser samlas in.  Se dokumentationen för "
"modulen :mod:`gc` för information om hur du kontrollerar insamlingen av "
"cykliskt skräp. Andra implementationer agerar annorlunda och CPython kan "
"ändras. Förlita dig inte på omedelbar slutbehandling av objekt när de blir "
"oåtkomliga (så du bör alltid stänga filer explicit)."

#: ../../reference/datamodel.rst:82
msgid ""
"Note that the use of the implementation's tracing or debugging facilities "
"may keep objects alive that would normally be collectable. Also note that "
"catching an exception with a :keyword:`try`...\\ :keyword:`except` statement "
"may keep objects alive."
msgstr ""
"Observera att användningen av implementationens spårnings- eller "
"felsökningsfunktioner kan hålla objekt vid liv som normalt skulle vara "
"insamlingsbara. Observera också att om du fångar ett undantag med "
"en :keyword:`try`...\\ :keyword:`except`\\-sats kan det hålla objekt vid liv."

#: ../../reference/datamodel.rst:87
msgid ""
"Some objects contain references to \"external\" resources such as open files "
"or windows.  It is understood that these resources are freed when the object "
"is garbage-collected, but since garbage collection is not guaranteed to "
"happen, such objects also provide an explicit way to release the external "
"resource, usually a :meth:`!close` method. Programs are strongly recommended "
"to explicitly close such objects.  The :keyword:`try`..."
"\\ :keyword:`finally` statement and the :keyword:`with` statement provide "
"convenient ways to do this."
msgstr ""
"Vissa objekt innehåller referenser till \"externa\" resurser, t.ex. öppna "
"filer eller fönster.  Det är underförstått att dessa resurser frigörs när "
"objektet garbage-collected, men eftersom garbage-collection inte garanterat "
"kommer att ske, tillhandahåller sådana objekt också ett explicit sätt att "
"frigöra den externa resursen, vanligtvis en :meth:`!close`\\-metod. Program "
"rekommenderas starkt att explicit stänga sådana objekt.  "
"Satsen :keyword:`try`...\\ :keyword:`finally` och :keyword:`with` är "
"praktiska sätt att göra detta."

#: ../../reference/datamodel.rst:97
msgid ""
"Some objects contain references to other objects; these are called "
"*containers*. Examples of containers are tuples, lists and dictionaries.  "
"The references are part of a container's value.  In most cases, when we talk "
"about the value of a container, we imply the values, not the identities of "
"the contained objects; however, when we talk about the mutability of a "
"container, only the identities of the immediately contained objects are "
"implied.  So, if an immutable container (like a tuple) contains a reference "
"to a mutable object, its value changes if that mutable object is changed."
msgstr ""
"Vissa objekt innehåller referenser till andra objekt, dessa kallas för "
"*containers*. Exempel på containrar är tupler, listor och lexikon.  "
"Referenserna är en del av en containers värde.  I de flesta fall, när vi "
"talar om värdet på en container, menar vi värdena, inte identiteterna på de "
"ingående objekten; men när vi talar om föränderligheten hos en container, är "
"det bara identiteterna på de omedelbart ingående objekten som avses.  Så om "
"en oföränderlig behållare (som en tupel) innehåller en referens till ett "
"föränderligt objekt, ändras dess värde om det föränderliga objektet ändras."

#: ../../reference/datamodel.rst:106
msgid ""
"Types affect almost all aspects of object behavior.  Even the importance of "
"object identity is affected in some sense: for immutable types, operations "
"that compute new values may actually return a reference to any existing "
"object with the same type and value, while for mutable objects this is not "
"allowed. For example, after ``a = 1; b = 1``, *a* and *b* may or may not "
"refer to the same object with the value one, depending on the "
"implementation. This is because :class:`int` is an immutable type, so the "
"reference to ``1`` can be reused. This behaviour depends on the "
"implementation used, so should not be relied upon, but is something to be "
"aware of when making use of object identity tests. However, after ``c = []; "
"d = []``, *c* and *d* are guaranteed to refer to two different, unique, "
"newly created empty lists. (Note that ``e = f = []`` assigns the *same* "
"object to both *e* and *f*.)"
msgstr ""
"Typer påverkar nästan alla aspekter av objektets beteende.  Till och med "
"vikten av objektets identitet påverkas i någon mening: för oföränderliga "
"typer kan operationer som beräknar nya värden faktiskt returnera en referens "
"till ett befintligt objekt med samma typ och värde, medan detta inte är "
"tillåtet för föränderliga objekt. Till exempel, efter ``a = 1; b = 1``, kan "
"*a* och *b* referera till samma objekt med värdet ett eller inte, beroende "
"på implementeringen. Detta beror på att :class:`int` är en oföränderlig typ, "
"så referensen till ``1`` kan återanvändas. Detta beteende beror på vilken "
"implementation som används och bör därför inte åberopas, men det är något "
"att vara medveten om när man använder sig av objektidentitetstester. Efter "
"``c = []; d = []`` är det dock garanterat att *c* och *d* refererar till två "
"olika, unika, nyskapade tomma listor. (Observera att ``e = f = []`` "
"tilldelar *samma* objekt till både *e* och *f*)"

#: ../../reference/datamodel.rst:124
msgid "The standard type hierarchy"
msgstr "Standardtypens hierarki"

#: ../../reference/datamodel.rst:133
msgid ""
"Below is a list of the types that are built into Python.  Extension modules "
"(written in C, Java, or other languages, depending on the implementation) "
"can define additional types.  Future versions of Python may add types to the "
"type hierarchy (e.g., rational numbers, efficiently stored arrays of "
"integers, etc.), although such additions will often be provided via the "
"standard library instead."
msgstr ""
"Nedan finns en lista över de typer som är inbyggda i Python.  "
"Tilläggsmoduler (skrivna i C, Java eller andra språk, beroende på "
"implementeringen) kan definiera ytterligare typer.  Framtida versioner av "
"Python kan lägga till typer i typhierarkin (t.ex. rationella tal, effektivt "
"lagrade matriser av heltal etc.), även om sådana tillägg ofta kommer att "
"tillhandahållas via standardbiblioteket istället."

#: ../../reference/datamodel.rst:144
msgid ""
"Some of the type descriptions below contain a paragraph listing 'special "
"attributes.'  These are attributes that provide access to the implementation "
"and are not intended for general use.  Their definition may change in the "
"future."
msgstr ""
"Vissa av typbeskrivningarna nedan innehåller ett stycke som listar "
"\"specialattribut\"  Detta är attribut som ger tillgång till "
"implementationen och som inte är avsedda för allmänt bruk.  Deras definition "
"kan komma att ändras i framtiden."

#: ../../reference/datamodel.rst:150 ../../reference/datamodel.rst:152
msgid "None"
msgstr "None"

#: ../../reference/datamodel.rst:154
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``None``. It is used to "
"signify the absence of a value in many situations, e.g., it is returned from "
"functions that don't explicitly return anything. Its truth value is false."
msgstr ""
"Denna typ har ett enda värde.  Det finns ett enda objekt med detta värde. "
"Detta objekt nås genom det inbyggda namnet ``None``. Det används för att "
"beteckna avsaknaden av ett värde i många situationer, t.ex. returneras det "
"från funktioner som inte uttryckligen returnerar något. Dess sanningsvärde "
"är false."

#: ../../reference/datamodel.rst:161 ../../reference/datamodel.rst:163
msgid "NotImplemented"
msgstr "NotImplemented"

#: ../../reference/datamodel.rst:165
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name :data:`NotImplemented`. "
"Numeric methods and rich comparison methods should return this value if they "
"do not implement the operation for the operands provided.  (The interpreter "
"will then try the reflected operation, or some other fallback, depending on "
"the operator.)  It should not be evaluated in a boolean context."
msgstr ""
"Denna typ har ett enda värde.  Det finns ett enda objekt med detta värde. "
"Detta objekt är åtkomligt genom det inbyggda namnet :data:`NotImplemented`. "
"Numeriska metoder och rika jämförelsemetoder bör returnera detta värde om de "
"inte implementerar operationen för de operander som tillhandahålls.  (Tolken "
"kommer då att prova den reflekterade operationen, eller någon annan "
"fallback, beroende på operatorn)  Det bör inte utvärderas i en boolesk "
"kontext."

#: ../../reference/datamodel.rst:172
msgid "See :ref:`implementing-the-arithmetic-operations` for more details."
msgstr "Se :ref:`implementing-the-arithmetic-operations` för mer information."

#: ../../reference/datamodel.rst:176
msgid "Evaluating :data:`NotImplemented` in a boolean context was deprecated."
msgstr ""
"Utvärdering av :data:`NotImplemented` i en boolesk kontext var föråldrad."

#: ../../reference/datamodel.rst:179
msgid ""
"Evaluating :data:`NotImplemented` in a boolean context now raises "
"a :exc:`TypeError`. It previously evaluated to :const:`True` and emitted "
"a :exc:`DeprecationWarning` since Python 3.9."
msgstr ""
"Utvärdering av :data:`NotImplemented` i en booleansk kontext ger nu upphov "
"till ett :exc:`TypeError`. Det utvärderades tidigare till :const:`True` och "
"gav upphov till en :exc:`DeprecationWarning` sedan Python 3.9."

#: ../../reference/datamodel.rst:186 ../../reference/datamodel.rst:187
msgid "Ellipsis"
msgstr "Ellipsis"

#: ../../reference/datamodel.rst:191
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the literal ``...`` or the built-in name "
"``Ellipsis``.  Its truth value is true."
msgstr ""
"Denna typ har ett enda värde.  Det finns ett enda objekt med detta värde. "
"Detta objekt nås genom det bokstavliga ``...`` eller det inbyggda namnet "
"``Ellipsis``.  Dess sanningsvärde är true."

#: ../../reference/datamodel.rst:197
msgid ":class:`numbers.Number`"
msgstr ":class:`numbers.Number`"

#: ../../reference/datamodel.rst:201
msgid ""
"These are created by numeric literals and returned as results by arithmetic "
"operators and arithmetic built-in functions.  Numeric objects are immutable; "
"once created their value never changes.  Python numbers are of course "
"strongly related to mathematical numbers, but subject to the limitations of "
"numerical representation in computers."
msgstr ""
"Dessa skapas av numeriska literaler och returneras som resultat av "
"aritmetiska operatorer och inbyggda aritmetiska funktioner.  Numeriska "
"objekt är oföränderliga; när de väl har skapats ändras aldrig deras värde.  "
"Pythontal är naturligtvis starkt relaterade till matematiska tal, men är "
"föremål för begränsningarna för numerisk representation i datorer."

#: ../../reference/datamodel.rst:207
msgid ""
"The string representations of the numeric classes, computed "
"by :meth:`~object.__repr__` and :meth:`~object.__str__`, have the following "
"properties:"
msgstr ""
"Strängrepresentationerna av de numeriska klasserna, beräknade "
"med :meth:`~object.__repr__` och :meth:`~object.__str__`, har följande "
"egenskaper:"

#: ../../reference/datamodel.rst:211
msgid ""
"They are valid numeric literals which, when passed to their class "
"constructor, produce an object having the value of the original numeric."
msgstr ""
"De är giltiga numeriska literaler som, när de skickas till sin "
"klasskonstruktör, producerar ett objekt som har värdet av den ursprungliga "
"numeriska."

#: ../../reference/datamodel.rst:215
msgid "The representation is in base 10, when possible."
msgstr "Representationen är i bas 10, när så är möjligt."

#: ../../reference/datamodel.rst:217
msgid ""
"Leading zeros, possibly excepting a single zero before a decimal point, are "
"not shown."
msgstr ""
"Ledande nollor, möjligen med undantag för en enda nolla före ett "
"decimaltecken, visas inte."

#: ../../reference/datamodel.rst:220
msgid ""
"Trailing zeros, possibly excepting a single zero after a decimal point, are "
"not shown."
msgstr ""
"Efterföljande nollor, eventuellt med undantag för en enda nolla efter ett "
"decimaltecken, visas inte."

#: ../../reference/datamodel.rst:223
msgid "A sign is shown only when the number is negative."
msgstr "Ett tecken visas endast när talet är negativt."

#: ../../reference/datamodel.rst:225
msgid ""
"Python distinguishes between integers, floating-point numbers, and complex "
"numbers:"
msgstr "Python skiljer mellan heltal, flyttal och komplexa tal:"

#: ../../reference/datamodel.rst:230
msgid ":class:`numbers.Integral`"
msgstr ":class:`numbers.Integral`"

#: ../../reference/datamodel.rst:234
msgid ""
"These represent elements from the mathematical set of integers (positive and "
"negative)."
msgstr ""
"Dessa representerar element från den matematiska uppsättningen av heltal "
"(positiva och negativa)."

#: ../../reference/datamodel.rst:240
msgid ""
"The rules for integer representation are intended to give the most "
"meaningful interpretation of shift and mask operations involving negative "
"integers."
msgstr ""
"Reglerna för representation av heltal är avsedda att ge den mest "
"meningsfulla tolkningen av skift- och maskoperationer som involverar "
"negativa heltal."

#: ../../reference/datamodel.rst:243
msgid "There are two types of integers:"
msgstr "Det finns två typer av heltal:"

#: ../../reference/datamodel.rst:245
msgid "Integers (:class:`int`)"
msgstr "Heltal (:class:`int`)"

#: ../../reference/datamodel.rst:246
msgid ""
"These represent numbers in an unlimited range, subject to available "
"(virtual) memory only.  For the purpose of shift and mask operations, a "
"binary representation is assumed, and negative numbers are represented in a "
"variant of 2's complement which gives the illusion of an infinite string of "
"sign bits extending to the left."
msgstr ""
"Dessa representerar tal i ett obegränsat intervall, endast beroende på "
"tillgängligt (virtuellt) minne.  Vid skift- och maskoperationer förutsätts "
"en binär representation och negativa tal representeras i en variant av 2:ans "
"komplement som ger illusionen av en oändlig sträng av teckenbitar som "
"sträcker sig åt vänster."

#: ../../reference/datamodel.rst:252
msgid "Booleans (:class:`bool`)"
msgstr "Booleaner (:class:`bool`)"

#: ../../reference/datamodel.rst:258
msgid ""
"These represent the truth values False and True.  The two objects "
"representing the values ``False`` and ``True`` are the only Boolean objects. "
"The Boolean type is a subtype of the integer type, and Boolean values behave "
"like the values 0 and 1, respectively, in almost all contexts, the exception "
"being that when converted to a string, the strings ``\"False\"`` or "
"``\"True\"`` are returned, respectively."
msgstr ""
"Dessa representerar sanningsvärdena False och True.  De två objekt som "
"representerar värdena ``False`` och ``True`` är de enda booleska objekten. "
"Den booleska typen är en subtyp av heltalstypen, och booleska värden beter "
"sig som värdena 0 respektive 1 i nästan alla sammanhang, med undantaget att "
"när de konverteras till en sträng returneras strängarna ``\"False\"`` "
"respektive ``\"True\"``."

#: ../../reference/datamodel.rst:268
msgid ":class:`numbers.Real` (:class:`float`)"
msgstr ":class:`numbers.Real` (:class:`float`)"

#: ../../reference/datamodel.rst:276
msgid ""
"These represent machine-level double precision floating-point numbers. You "
"are at the mercy of the underlying machine architecture (and C or Java "
"implementation) for the accepted range and handling of overflow. Python does "
"not support single-precision floating-point numbers; the savings in "
"processor and memory usage that are usually the reason for using these are "
"dwarfed by the overhead of using objects in Python, so there is no reason to "
"complicate the language with two kinds of floating-point numbers."
msgstr ""
"Dessa representerar flyttal med dubbel precision på maskinnivå. Du är "
"utlämnad till den underliggande maskinarkitekturen (och C- eller Java-"
"implementeringen) för det accepterade intervallet och hanteringen av "
"överflöd. Python stöder inte flyttal med enkel precision; besparingarna i "
"processor- och minnesanvändning som vanligtvis är skälet till att använda "
"dessa dvärgas av omkostnaderna för att använda objekt i Python, så det finns "
"ingen anledning att komplicera språket med två typer av flyttal."

#: ../../reference/datamodel.rst:286
msgid ":class:`numbers.Complex` (:class:`complex`)"
msgstr ":class:`numbers.Complex` (:class:`complex`)"

#: ../../reference/datamodel.rst:292
msgid ""
"These represent complex numbers as a pair of machine-level double precision "
"floating-point numbers.  The same caveats apply as for floating-point "
"numbers. The real and imaginary parts of a complex number ``z`` can be "
"retrieved through the read-only attributes ``z.real`` and ``z.imag``."
msgstr ""
"Dessa representerar komplexa tal som ett par flyttal med dubbel precision på "
"maskinnivå.  Samma försiktighetsåtgärder gäller som för flyttal. De reella "
"och imaginära delarna av ett komplext tal ``z`` kan hämtas genom de "
"skrivskyddade attributen ``z.real`` och ``z.imag``."

#: ../../reference/datamodel.rst:299
msgid "Sequences"
msgstr "Sekvenser"

#: ../../reference/datamodel.rst:308
msgid ""
"These represent finite ordered sets indexed by non-negative numbers. The "
"built-in function :func:`len` returns the number of items of a sequence. "
"When the length of a sequence is *n*, the index set contains the numbers 0, "
"1, ..., *n*-1.  Item *i* of sequence *a* is selected by ``a[i]``. Some "
"sequences, including built-in sequences, interpret negative subscripts by "
"adding the sequence length. For example, ``a[-2]`` equals ``a[n-2]``, the "
"second to last item of sequence a with length ``n``."
msgstr ""
"Dessa representerar ändliga ordnade mängder indexerade med icke-negativa "
"tal. Den inbyggda funktionen :func:`len` returnerar antalet objekt i en "
"sekvens. När längden på en sekvens är *n* innehåller indexuppsättningen "
"siffrorna 0, 1, ..., *n*-1.  Objekt *i* i sekvensen *a* väljs av ``a[i]``. "
"Vissa sekvenser, inklusive inbyggda sekvenser, tolkar negativa "
"subskriptioner genom att lägga till sekvenslängden. Till exempel är "
"``a[-2]`` lika med ``a[n-2]``, det näst sista objektet i sekvensen a med "
"längden ``n``."

#: ../../reference/datamodel.rst:318
msgid ""
"Sequences also support slicing: ``a[i:j]`` selects all items with index *k* "
"such that *i* ``<=`` *k* ``<`` *j*.  When used as an expression, a slice is "
"a sequence of the same type. The comment above about negative indexes also "
"applies to negative slice positions."
msgstr ""
"Sekvenser stöder också skivning: ``a[i:j]`` väljer alla objekt med index *k* "
"så att *i* ``<=`` *k* ``<`` *j*.  När en slice används som ett uttryck är "
"den en sekvens av samma typ. Kommentaren ovan om negativa index gäller även "
"för negativa slicepositioner."

#: ../../reference/datamodel.rst:323
msgid ""
"Some sequences also support \"extended slicing\" with a third \"step\" "
"parameter: ``a[i:j:k]`` selects all items of *a* with index *x* where ``x = "
"i + n*k``, *n* ``>=`` ``0`` and *i* ``<=`` *x* ``<`` *j*."
msgstr ""
"Vissa sekvenser stöder också \"extended slicing\" med en tredje parameter "
"\"step\": ``a[i:j:k]`` väljer alla objekt i *a* med index *x* där ``x = i + "
"n*k``, *n* ``>=`` ``0`` och *i* ``<=`` *x* ``<`` *j*."

#: ../../reference/datamodel.rst:327
msgid "Sequences are distinguished according to their mutability:"
msgstr "Sekvenserna skiljer sig åt beroende på hur föränderliga de är:"

#: ../../reference/datamodel.rst:331
msgid "Immutable sequences"
msgstr "Oföränderliga sekvenser"

#: ../../reference/datamodel.rst:337
msgid ""
"An object of an immutable sequence type cannot change once it is created.  "
"(If the object contains references to other objects, these other objects may "
"be mutable and may be changed; however, the collection of objects directly "
"referenced by an immutable object cannot change.)"
msgstr ""
"Ett objekt av en oföränderlig sekvenstyp kan inte ändras när det väl har "
"skapats.  (Om objektet innehåller referenser till andra objekt kan dessa "
"andra objekt vara föränderliga och kan ändras, men samlingen av objekt som "
"ett oföränderligt objekt refererar direkt till kan inte ändras)"

#: ../../reference/datamodel.rst:342
msgid "The following types are immutable sequences:"
msgstr "Följande typer är oföränderliga sekvenser:"

#: ../../reference/datamodel.rst:347
msgid "Strings"
msgstr "Strängar"

#: ../../reference/datamodel.rst:355
msgid ""
"A string is a sequence of values that represent Unicode code points. All the "
"code points in the range ``U+0000 - U+10FFFF`` can be represented in a "
"string.  Python doesn't have a :c:expr:`char` type; instead, every code "
"point in the string is represented as a string object with length ``1``.  "
"The built-in function :func:`ord` converts a code point from its string form "
"to an integer in the range ``0 - 10FFFF``; :func:`chr` converts an integer "
"in the range ``0 - 10FFFF`` to the corresponding length ``1`` string "
"object. :meth:`str.encode` can be used to convert a :class:`str` "
"to :class:`bytes` using the given text encoding, and :meth:`bytes.decode` "
"can be used to achieve the opposite."
msgstr ""
"En sträng är en sekvens av värden som representerar Unicode-kodpunkter. Alla "
"kodpunkter i intervallet ``U+0000 - U+10FFFF`` kan representeras i en "
"sträng.  Python har inte någon :c:expr:`char`\\-typ, utan varje kodpunkt i "
"strängen representeras som ett strängobjekt med längden ``1``.  Den inbyggda "
"funktionen :func:`ord` konverterar en kodpunkt från dess strängform till ett "
"heltal i intervallet ``0 - 10FFFF``; :func:`chr` konverterar ett heltal i "
"intervallet ``0 - 10FFFF`` till motsvarande strängobjekt med längden "
"``1``. :meth:`str.encode` kan användas för att konvertera en :class:`str` "
"till :class:`bytes` med den givna textkodningen, och :meth:`bytes.decode` "
"kan användas för att uppnå motsatsen."

#: ../../reference/datamodel.rst:367
msgid "Tuples"
msgstr "Tupler"

#: ../../reference/datamodel.rst:373
msgid ""
"The items of a tuple are arbitrary Python objects. Tuples of two or more "
"items are formed by comma-separated lists of expressions.  A tuple of one "
"item (a 'singleton') can be formed by affixing a comma to an expression (an "
"expression by itself does not create a tuple, since parentheses must be "
"usable for grouping of expressions).  An empty tuple can be formed by an "
"empty pair of parentheses."
msgstr ""
"Objekten i en tupel är godtyckliga Python-objekt. Tuplar med två eller flera "
"objekt bildas av kommaseparerade listor med uttryck.  En tupel med ett "
"objekt (en \"singleton\") kan bildas genom att ett uttryck förses med ett "
"kommatecken (ett uttryck i sig skapar inte en tupel, eftersom parenteser "
"måste kunna användas för gruppering av uttryck).  En tom tupel kan bildas av "
"ett tomt par parenteser."

#: ../../reference/datamodel.rst:380
msgid "Bytes"
msgstr "Byte"

#: ../../reference/datamodel.rst:383
msgid ""
"A bytes object is an immutable array.  The items are 8-bit bytes, "
"represented by integers in the range 0 <= x < 256.  Bytes literals (like "
"``b'abc'``) and the built-in :func:`bytes` constructor can be used to create "
"bytes objects.  Also, bytes objects can be decoded to strings via "
"the :meth:`~bytes.decode` method."
msgstr ""
"Ett bytes-objekt är en oföränderlig array.  Objekten är 8-bitars byte, "
"representerade av heltal i intervallet 0 <= x < 256.  Byteslitteraler (som "
"``b'abc'``) och den inbyggda :func:`bytes`\\-konstruktorn kan användas för "
"att skapa bytes-objekt.  Bytesobjekt kan också avkodas till strängar via "
"metoden :meth:`~bytes.decode`."

#: ../../reference/datamodel.rst:391
msgid "Mutable sequences"
msgstr "Mutabla sekvenser"

#: ../../reference/datamodel.rst:400
msgid ""
"Mutable sequences can be changed after they are created.  The subscription "
"and slicing notations can be used as the target of assignment "
"and :keyword:`del` (delete) statements."
msgstr ""
"Mutabla sekvenser kan ändras efter att de har skapats.  Subscriptions- och "
"slicing-notationerna kan användas som mål för assignment- och :keyword:`del` "
"(delete)-satser."

#: ../../reference/datamodel.rst:408
msgid ""
"The :mod:`collections` and :mod:`array` module provide additional examples "
"of mutable sequence types."
msgstr ""
"Modulerna :mod:`collections` och :mod:`array` ger ytterligare exempel på "
"föränderliga sekvenstyper."

#: ../../reference/datamodel.rst:411
msgid "There are currently two intrinsic mutable sequence types:"
msgstr "Det finns för närvarande två inneboende muterbara sekvenstyper:"

#: ../../reference/datamodel.rst:413
msgid "Lists"
msgstr "Listor"

#: ../../reference/datamodel.rst:416
msgid ""
"The items of a list are arbitrary Python objects.  Lists are formed by "
"placing a comma-separated list of expressions in square brackets. (Note that "
"there are no special cases needed to form lists of length 0 or 1.)"
msgstr ""
"Objekten i en lista är godtyckliga Python-objekt.  Listor bildas genom att "
"placera en kommaseparerad lista med uttryck inom hakparenteser. (Observera "
"att det inte behövs några specialfall för att bilda listor med längden 0 "
"eller 1)"

#: ../../reference/datamodel.rst:420
msgid "Byte Arrays"
msgstr "Byte-arrayer"

#: ../../reference/datamodel.rst:423
msgid ""
"A bytearray object is a mutable array. They are created by the built-"
"in :func:`bytearray` constructor.  Aside from being mutable (and hence "
"unhashable), byte arrays otherwise provide the same interface and "
"functionality as immutable :class:`bytes` objects."
msgstr ""
"Ett bytearray-objekt är en föränderlig array. De skapas av den "
"inbyggda :func:`bytearray`\\-konstruktören.  Bortsett från att bytearray är "
"föränderliga (och därmed ohashbara), har de i övrigt samma gränssnitt och "
"funktionalitet som oföränderliga :class:`bytes`\\-objekt."

#: ../../reference/datamodel.rst:430
msgid "Set types"
msgstr "Uppsättningstyper"

#: ../../reference/datamodel.rst:436
msgid ""
"These represent unordered, finite sets of unique, immutable objects. As "
"such, they cannot be indexed by any subscript. However, they can be iterated "
"over, and the built-in function :func:`len` returns the number of items in a "
"set. Common uses for sets are fast membership testing, removing duplicates "
"from a sequence, and computing mathematical operations such as intersection, "
"union, difference, and symmetric difference."
msgstr ""
"Dessa representerar oordnade, ändliga uppsättningar av unika, oföränderliga "
"objekt. Som sådana kan de inte indexeras med något subskript. De kan dock "
"itereras över och den inbyggda funktionen :func:`len` returnerar antalet "
"objekt i en uppsättning. Vanliga användningsområden för set är snabb "
"testning av medlemskap, borttagning av dubbletter från en sekvens och "
"beräkning av matematiska operationer som intersektion, union, differens och "
"symmetrisk differens."

#: ../../reference/datamodel.rst:443
msgid ""
"For set elements, the same immutability rules apply as for dictionary keys. "
"Note that numeric types obey the normal rules for numeric comparison: if two "
"numbers compare equal (e.g., ``1`` and ``1.0``), only one of them can be "
"contained in a set."
msgstr ""
"För set-element gäller samma regler för oföränderlighet som för nycklar i "
"ordböcker. Observera att numeriska typer följer de normala reglerna för "
"numerisk jämförelse: om två tal jämförs lika (t.ex. ``1`` och ``1.0``) kan "
"endast ett av dem ingå i en uppsättning."

#: ../../reference/datamodel.rst:448
msgid "There are currently two intrinsic set types:"
msgstr "Det finns för närvarande två typer av intrinsic set:"

#: ../../reference/datamodel.rst:451
msgid "Sets"
msgstr "Uppsättningar"

#: ../../reference/datamodel.rst:454
msgid ""
"These represent a mutable set. They are created by the built-in :func:`set` "
"constructor and can be modified afterwards by several methods, such "
"as :meth:`add <frozenset.add>`."
msgstr ""

#: ../../reference/datamodel.rst:459
msgid "Frozen sets"
msgstr "Frysta uppsättningar"

#: ../../reference/datamodel.rst:462
msgid ""
"These represent an immutable set.  They are created by the built-"
"in :func:`frozenset` constructor.  As a frozenset is immutable "
"and :term:`hashable`, it can be used again as an element of another set, or "
"as a dictionary key."
msgstr ""
"Dessa representerar en oföränderlig uppsättning.  De skapas av den "
"inbyggda :func:`frozenset`\\-konstruktören.  Eftersom en frozenset är "
"oföränderlig och :term:`hashable` kan den användas igen som ett element i en "
"annan uppsättning eller som en nyckel i en ordbok."

#: ../../reference/datamodel.rst:469
msgid "Mappings"
msgstr "Mappningar"

#: ../../reference/datamodel.rst:476
msgid ""
"These represent finite sets of objects indexed by arbitrary index sets. The "
"subscript notation ``a[k]`` selects the item indexed by ``k`` from the "
"mapping ``a``; this can be used in expressions and as the target of "
"assignments or :keyword:`del` statements. The built-in function :func:`len` "
"returns the number of items in a mapping."
msgstr ""
"Dessa representerar ändliga uppsättningar av objekt indexerade med "
"godtyckliga indexuppsättningar. Subscript-notationen ``a[k]`` väljer "
"objektet indexerat med ``k`` från mappningen ``a``; detta kan användas i "
"uttryck och som mål för tilldelningar eller :keyword:`del`\\-satser. Den "
"inbyggda funktionen :func:`len` returnerar antalet objekt i en mappning."

#: ../../reference/datamodel.rst:482
msgid "There is currently a single intrinsic mapping type:"
msgstr "Det finns för närvarande en enda intrinsic mappningstyp:"

#: ../../reference/datamodel.rst:486
msgid "Dictionaries"
msgstr "Ordböcker"

#: ../../reference/datamodel.rst:490
msgid ""
"These represent finite sets of objects indexed by nearly arbitrary values.  "
"The only types of values not acceptable as keys are values containing lists "
"or dictionaries or other mutable types that are compared by value rather "
"than by object identity, the reason being that the efficient implementation "
"of dictionaries requires a key's hash value to remain constant. Numeric "
"types used for keys obey the normal rules for numeric comparison: if two "
"numbers compare equal (e.g., ``1`` and ``1.0``) then they can be used "
"interchangeably to index the same dictionary entry."
msgstr ""
"Dessa representerar ändliga uppsättningar av objekt indexerade med nästan "
"godtyckliga värden.  De enda typer av värden som inte kan accepteras som "
"nycklar är värden som innehåller listor eller lexikon eller andra "
"föränderliga typer som jämförs med värde i stället för med objektets "
"identitet, eftersom en effektiv implementering av lexikon kräver att en "
"nyckels hashvärde förblir konstant. Numeriska typer som används för nycklar "
"följer de normala reglerna för numerisk jämförelse: om två tal jämförs lika "
"(t.ex. ``1`` och ``1.0``) kan de användas omväxlande för att indexera samma "
"ordbokspost."

#: ../../reference/datamodel.rst:499
msgid ""
"Dictionaries preserve insertion order, meaning that keys will be produced in "
"the same order they were added sequentially over the dictionary. Replacing "
"an existing key does not change the order, however removing a key and re-"
"inserting it will add it to the end instead of keeping its old place."
msgstr ""
"Ordböcker bevarar inmatningsordningen, vilket innebär att nycklar kommer att "
"produceras i samma ordning som de lades till sekventiellt över ordboken. Om "
"du ersätter en befintlig nyckel ändras inte ordningen, men om du tar bort en "
"nyckel och sätter in den igen läggs den till i slutet i stället för att "
"behålla sin gamla plats."

#: ../../reference/datamodel.rst:504
msgid ""
"Dictionaries are mutable; they can be created by the ``{}`` notation (see "
"section :ref:`dict`)."
msgstr ""
"Dictionaries är mutabla; de kan skapas med notationen ``{}`` (se "
"avsnitt :ref:`dict`)."

#: ../../reference/datamodel.rst:511
msgid ""
"The extension modules :mod:`dbm.ndbm` and :mod:`dbm.gnu` provide additional "
"examples of mapping types, as does the :mod:`collections` module."
msgstr ""
"Tilläggsmodulerna :mod:`dbm.ndbm` och :mod:`dbm.gnu` ger ytterligare exempel "
"på mappningstyper, liksom modulen :mod:`collections`."

#: ../../reference/datamodel.rst:515
msgid ""
"Dictionaries did not preserve insertion order in versions of Python before "
"3.6. In CPython 3.6, insertion order was preserved, but it was considered an "
"implementation detail at that time rather than a language guarantee."
msgstr ""
"Ordböcker bevarade inte insättningsordning i versioner av Python före 3.6. I "
"CPython 3.6 bevarades insättningsordningen, men det ansågs vara en "
"implementeringsdetalj vid den tiden snarare än en språkgaranti."

#: ../../reference/datamodel.rst:522
msgid "Callable types"
msgstr "Kallbara typer"

#: ../../reference/datamodel.rst:530
msgid ""
"These are the types to which the function call operation (see "
"section :ref:`calls`) can be applied:"
msgstr ""
"Dessa är de typer på vilka funktionsanropsoperationen (se "
"avsnitt :ref:`calls`) kan tillämpas:"

#: ../../reference/datamodel.rst:537
msgid "User-defined functions"
msgstr "Användardefinierade funktioner"

#: ../../reference/datamodel.rst:544
msgid ""
"A user-defined function object is created by a function definition (see "
"section :ref:`function`).  It should be called with an argument list "
"containing the same number of items as the function's formal parameter list."
msgstr ""
"Ett användardefinierat funktionsobjekt skapas genom en funktionsdefinition "
"(se avsnitt :ref:`function`).  Den bör anropas med en argumentlista som "
"innehåller samma antal objekt som funktionens formella parameterlista."

#: ../../reference/datamodel.rst:550 ../../reference/datamodel.rst:1443
#: ../../reference/datamodel.rst:1644
msgid "Special read-only attributes"
msgstr "Särskilda skrivskyddade attribut"

#: ../../reference/datamodel.rst:560 ../../reference/datamodel.rst:596
#: ../../reference/datamodel.rst:1198
msgid "Attribute"
msgstr "Attribut"

#: ../../reference/datamodel.rst:561 ../../reference/datamodel.rst:597
#: ../../reference/datamodel.rst:1199
msgid "Meaning"
msgstr "Betydelse"

#: ../../reference/datamodel.rst:564
msgid ""
"A reference to the :class:`dictionary <dict>` that holds the "
"function's :ref:`global variables <naming>` -- the global namespace of the "
"module in which the function was defined."
msgstr ""
"En referens till :class:`dictionary <dict>` som innehåller "
"funktionens :ref:`global variables <naming>` -- den globala namnrymden i den "
"modul där funktionen definierades."

#: ../../reference/datamodel.rst:569
msgid ""
"``None`` or a :class:`tuple` of cells that contain bindings for the names "
"specified in the :attr:`~codeobject.co_freevars` attribute of the "
"function's :attr:`code object <function.__code__>`."
msgstr ""
"``None`` eller en :class:`tuple` av celler som innehåller bindningar för de "
"namn som anges i attributet :attr:`~codeobject.co_freevars` i "
"funktionens :attr:`code object <function.__code__>`."

#: ../../reference/datamodel.rst:573
msgid ""
"A cell object has the attribute ``cell_contents``. This can be used to get "
"the value of the cell, as well as set the value."
msgstr ""
"Ett cellobjekt har attributet ``cell_contents``. Detta kan användas för att "
"hämta cellens värde och för att ställa in värdet."

#: ../../reference/datamodel.rst:577 ../../reference/datamodel.rst:1692
msgid "Special writable attributes"
msgstr "Särskilda skrivbara attribut"

#: ../../reference/datamodel.rst:591
msgid "Most of these attributes check the type of the assigned value:"
msgstr ""
"De flesta av dessa attribut kontrollerar typen av det tilldelade värdet:"

#: ../../reference/datamodel.rst:600
msgid "The function's documentation string, or ``None`` if unavailable."
msgstr ""
"Funktionens dokumentationssträng, eller ``None`` om den inte finns "
"tillgänglig."

#: ../../reference/datamodel.rst:603
msgid ""
"The function's name. See also: :attr:`__name__ attributes "
"<definition.__name__>`."
msgstr ""
"Funktionens namn. Se även: :attr:`__name__ attribut <definition.__name__>`."

#: ../../reference/datamodel.rst:607
msgid ""
"The function's :term:`qualified name`. See also: :attr:`__qualname__ "
"attributes <definition.__qualname__>`."
msgstr ""
"Funktionens :term:`qualified name`. Se även: :attr:`__qualname__-attribut "
"<definition.__qualname__>`."

#: ../../reference/datamodel.rst:613
msgid ""
"The name of the module the function was defined in, or ``None`` if "
"unavailable."
msgstr ""
"Namnet på den modul som funktionen definierades i, eller ``None`` om den "
"inte är tillgänglig."

#: ../../reference/datamodel.rst:617
msgid ""
"A :class:`tuple` containing default :term:`parameter` values for those "
"parameters that have defaults, or ``None`` if no parameters have a default "
"value."
msgstr ""
"En :class:`tuple` som innehåller standardvärden för :term:`parameter` för de "
"parametrar som har standardvärden, eller ``None`` om inga parametrar har ett "
"standardvärde."

#: ../../reference/datamodel.rst:622
msgid ""
"The :ref:`code object <code-objects>` representing the compiled function "
"body."
msgstr ""
"Den :ref:`code object <code-objects>` som representerar den kompilerade "
"funktionskroppen."

#: ../../reference/datamodel.rst:626
msgid ""
"The namespace supporting arbitrary function attributes. See "
"also: :attr:`__dict__ attributes <object.__dict__>`."
msgstr ""
"Namnrymden som stöder godtyckliga funktionsattribut. Se "
"även: :attr:`__dict__ attribut <object.__dict__>`."

#: ../../reference/datamodel.rst:630
msgid ""
"A :class:`dictionary <dict>` containing annotations of :term:`parameters "
"<parameter>`. The keys of the dictionary are the parameter names, and "
"``'return'`` for the return annotation, if provided. See "
"also: :attr:`object.__annotations__`."
msgstr ""
"En :class:`dictionary <dict>` som innehåller annoteringar "
"av :term:`parameters <parameter>`. Nycklarna i dictionariet är "
"parameternamnen och ``'return'`` för returannoteringen, om en sådan har "
"angetts. Se även: :attr:`object.__annotations__`."

#: ../../reference/datamodel.rst:636 ../../reference/datamodel.rst:1105
#: ../../reference/datamodel.rst:1249
msgid ""
"Annotations are now :ref:`lazily evaluated <lazy-evaluation>`. "
"See :pep:`649`."
msgstr ""
"Annotationer är nu :ref:`lazily evaluated <lazy-evaluation>`. Se :pep:`649`."

#: ../../reference/datamodel.rst:641
msgid ""
"The :term:`annotate function` for this function, or ``None`` if the function "
"has no annotations. See :attr:`object.__annotate__`."
msgstr ""
":term:`annotate function` för denna funktion, eller ``None`` om funktionen "
"inte har några annotationer. Se :attr:`object.__annotate__`."

#: ../../reference/datamodel.rst:647
msgid ""
"A :class:`dictionary <dict>` containing defaults for keyword-"
"only :term:`parameters <parameter>`."
msgstr ""
"En :class:`dictionary <dict>` som innehåller standardvärden för "
"nyckelordsspecifika :term:`parameters <parameter>`."

#: ../../reference/datamodel.rst:651
msgid ""
"A :class:`tuple` containing the :ref:`type parameters <type-params>` of "
"a :ref:`generic function <generic-functions>`."
msgstr ""
"En :class:`tuple` som innehåller :ref:`typ-parametrarna <type-params>` för "
"en :ref:`generisk funktion <generic-functions>`."

#: ../../reference/datamodel.rst:656
msgid ""
"Function objects also support getting and setting arbitrary attributes, "
"which can be used, for example, to attach metadata to functions.  Regular "
"attribute dot-notation is used to get and set such attributes."
msgstr ""
"Funktionsobjekt stöder också hämtning och inställning av godtyckliga "
"attribut, som t.ex. kan användas för att koppla metadata till funktioner.  "
"Vanlig attributpunktnotation används för att hämta och ställa in sådana "
"attribut."

#: ../../reference/datamodel.rst:662
msgid ""
"CPython's current implementation only supports function attributes on user-"
"defined functions. Function attributes on :ref:`built-in functions <builtin-"
"functions>` may be supported in the future."
msgstr ""
"CPythons nuvarande implementering stöder endast funktionsattribut på "
"användardefinierade funktioner. Funktionsattribut på :ref:`inbyggda "
"funktioner <builtin-functions>` kan komma att stödjas i framtiden."

#: ../../reference/datamodel.rst:667
msgid ""
"Additional information about a function's definition can be retrieved from "
"its :ref:`code object <code-objects>` (accessible via "
"the :attr:`~function.__code__` attribute)."
msgstr ""
"Ytterligare information om en funktions definition kan hämtas från "
"dess :ref:`code object <code-objects>` (tillgänglig via "
"attributet :attr:`~function.__code__`)."

#: ../../reference/datamodel.rst:675
msgid "Instance methods"
msgstr "Instansmetoder"

#: ../../reference/datamodel.rst:682
msgid ""
"An instance method object combines a class, a class instance and any "
"callable object (normally a user-defined function)."
msgstr ""
"Ett instansmetodobjekt kombinerar en klass, en klassinstans och ett "
"anropsbart objekt (normalt en användardefinierad funktion)."

#: ../../reference/datamodel.rst:692 ../../reference/datamodel.rst:1788
msgid "Special read-only attributes:"
msgstr "Särskilda skrivskyddade attribut:"

#: ../../reference/datamodel.rst:697
msgid ""
"Refers to the class instance object to which the method is :ref:`bound "
"<method-binding>`"
msgstr ""
"Hänvisar till klassens instansobjekt som metoden är :ref:`bunden till "
"<method-binding>`"

#: ../../reference/datamodel.rst:701
msgid "Refers to the original :ref:`function object <user-defined-funcs>`"
msgstr ""
"Hänvisar till det ursprungliga :ref:`funktionsobjektet <user-defined-funcs>`"

#: ../../reference/datamodel.rst:704
msgid ""
"The method's documentation (same as :attr:`method.__func__.__doc__ "
"<function.__doc__>`). A :class:`string <str>` if the original function had a "
"docstring, else ``None``."
msgstr ""
"Metodens dokumentation (samma som :attr:`method.__func__.__doc__ "
"<function.__doc__>`). En :class:`sträng <str>` om den ursprungliga "
"funktionen hade en dokumentsträng, annars ``None``."

#: ../../reference/datamodel.rst:710
msgid ""
"The name of the method (same as :attr:`method.__func__.__name__ "
"<function.__name__>`)"
msgstr ""
"Namnet på metoden (samma som :attr:`method.__func__.__name__ "
"<function.__name__>`)"

#: ../../reference/datamodel.rst:714
msgid ""
"The name of the module the method was defined in, or ``None`` if unavailable."
msgstr ""
"Namnet på den modul som metoden definierades i, eller ``None`` om den inte "
"är tillgänglig."

#: ../../reference/datamodel.rst:717
msgid ""
"Methods also support accessing (but not setting) the arbitrary function "
"attributes on the underlying :ref:`function object <user-defined-funcs>`."
msgstr ""
"Metoderna stöder också åtkomst till (men inte inställning av) godtyckliga "
"funktionsattribut på det underliggande :ref:`funktionsobjektet <user-defined-"
"funcs>`."

#: ../../reference/datamodel.rst:720
msgid ""
"User-defined method objects may be created when getting an attribute of a "
"class (perhaps via an instance of that class), if that attribute is a user-"
"defined :ref:`function object <user-defined-funcs>` or "
"a :class:`classmethod` object."
msgstr ""
"Användardefinierade metodobjekt kan skapas när man hämtar ett attribut för "
"en klass (kanske via en instans av den klassen), om attributet är ett "
"användardefinierat :ref:`funktionsobjekt <user-defined-funcs>` eller "
"ett :class:`klassmetod`\\-objekt."

#: ../../reference/datamodel.rst:727
msgid ""
"When an instance method object is created by retrieving a user-"
"defined :ref:`function object <user-defined-funcs>` from a class via one of "
"its instances, its :attr:`~method.__self__` attribute is the instance, and "
"the method object is said to be *bound*.  The new "
"method's :attr:`~method.__func__` attribute is the original function object."
msgstr ""
"När ett instansmetodobjekt skapas genom att hämta ett "
"användardefinierat :ref:`funktionsobjekt <user-defined-funcs>` från en klass "
"via en av dess instanser, är dess :attr:`~method.__self__`\\-attribut "
"instansen, och metodobjektet sägs vara *bundet*.  Den nya metodens "
"attribut :attr:`~method.__func__` är det ursprungliga funktionsobjektet."

#: ../../reference/datamodel.rst:733
msgid ""
"When an instance method object is created by retrieving "
"a :class:`classmethod` object from a class or instance, "
"its :attr:`~method.__self__` attribute is the class itself, and "
"its :attr:`~method.__func__` attribute is the function object underlying the "
"class method."
msgstr ""
"När ett instansmetodobjekt skapas genom att ett :class:`classmethod`\\-"
"objekt hämtas från en klass eller instans, är dess "
"attribut :attr:`~method.__self__` klassen själv och dess "
"attribut :attr:`~method.__func__` är det funktionsobjekt som ligger till "
"grund för klassmetoden."

#: ../../reference/datamodel.rst:738
msgid ""
"When an instance method object is called, the underlying function "
"(:attr:`~method.__func__`) is called, inserting the class instance "
"(:attr:`~method.__self__`) in front of the argument list.  For instance, "
"when :class:`!C` is a class which contains a definition for a "
"function :meth:`!f`, and ``x`` is an instance of :class:`!C`, calling "
"``x.f(1)`` is equivalent to calling ``C.f(x, 1)``."
msgstr ""
"När ett instansmetodobjekt anropas, anropas den underliggande funktionen "
"(:attr:`~method.__func__`), varvid klassinstansen (:attr:`~method.__self__`) "
"infogas framför argumentlistan.  Till exempel, när :class:`!C` är en klass "
"som innehåller en definition för en funktion :meth:`!f`, och ``x`` är en "
"instans av :class:`!C`, är anrop av ``x.f(1)`` likvärdigt med anrop av "
"``C.f(x, 1)``."

#: ../../reference/datamodel.rst:745
msgid ""
"When an instance method object is derived from a :class:`classmethod` "
"object, the \"class instance\" stored in :attr:`~method.__self__` will "
"actually be the class itself, so that calling either ``x.f(1)`` or "
"``C.f(1)`` is equivalent to calling ``f(C,1)`` where ``f`` is the underlying "
"function."
msgstr ""
"När ett instansmetodobjekt härleds från ett :class:`classmethod`\\-objekt "
"kommer den \"klassinstans\" som lagras i :attr:`~method.__self__` faktiskt "
"att vara själva klassen, så att anrop av antingen ``x.f(1)`` eller "
"``C.f(1)`` motsvarar anrop av ``f(C,1)`` där ``f`` är den underliggande "
"funktionen."

#: ../../reference/datamodel.rst:750
msgid ""
"It is important to note that user-defined functions which are attributes of "
"a class instance are not converted to bound methods; this *only* happens "
"when the function is an attribute of the class."
msgstr ""
"Det är viktigt att notera att användardefinierade funktioner som är attribut "
"till en klassinstans inte konverteras till bundna metoder; detta sker "
"*endast* när funktionen är ett attribut till klassen."

#: ../../reference/datamodel.rst:757
msgid "Generator functions"
msgstr "Generatorfunktioner"

#: ../../reference/datamodel.rst:763
msgid ""
"A function or method which uses the :keyword:`yield` statement (see "
"section :ref:`yield`) is called a :dfn:`generator function`.  Such a "
"function, when called, always returns an :term:`iterator` object which can "
"be used to execute the body of the function:  calling the "
"iterator's :meth:`iterator.__next__` method will cause the function to "
"execute until it provides a value using the :keyword:`!yield` statement.  "
"When the function executes a :keyword:`return` statement or falls off the "
"end, a :exc:`StopIteration` exception is raised and the iterator will have "
"reached the end of the set of values to be returned."
msgstr ""
"En funktion eller metod som använder :keyword:`yield`\\-satsen (se "
"avsnitt :ref:`yield`) kallas en :dfn:`generatorfunktion`.  När en sådan "
"funktion anropas returnerar den alltid ett :term:`iterator`\\-objekt som kan "
"användas för att exekvera funktionens kropp: om "
"iteratorns :meth:`iterator.__next__`\\-metod anropas kommer funktionen att "
"exekveras tills den ger ett värde med hjälp av :keyword:`!yield`\\-satsen.  "
"När funktionen exekverar en :keyword:`return`\\-sats eller faller av i "
"slutet, kommer ett :exc:`StopIteration`\\-undantag att uppstå och iteratorn "
"kommer att ha nått slutet av uppsättningen värden som ska returneras."

#: ../../reference/datamodel.rst:775
msgid "Coroutine functions"
msgstr "Coroutine-funktioner"

#: ../../reference/datamodel.rst:780
msgid ""
"A function or method which is defined using :keyword:`async def` is called "
"a :dfn:`coroutine function`.  Such a function, when called, returns "
"a :term:`coroutine` object.  It may contain :keyword:`await` expressions, as "
"well as :keyword:`async with` and :keyword:`async for` statements. See also "
"the :ref:`coroutine-objects` section."
msgstr ""
"En funktion eller metod som definieras med hjälp av :keyword:`async def` "
"kallas en :dfn:`coroutine function`.  En sådan funktion returnerar "
"ett :term:`coroutine`\\-objekt när den anropas.  Det kan "
"innehålla :keyword:`await`\\-uttryck, samt :keyword:`async with` "
"och :keyword:`async for`\\-satser. Se även avsnittet :ref:`coroutine-"
"objects`."

#: ../../reference/datamodel.rst:788
msgid "Asynchronous generator functions"
msgstr "Asynkrongeneratorfunktioner"

#: ../../reference/datamodel.rst:794
msgid ""
"A function or method which is defined using :keyword:`async def` and which "
"uses the :keyword:`yield` statement is called a :dfn:`asynchronous generator "
"function`.  Such a function, when called, returns an :term:`asynchronous "
"iterator` object which can be used in an :keyword:`async for` statement to "
"execute the body of the function."
msgstr ""
"En funktion eller metod som definieras med :keyword:`async def` och som "
"använder :keyword:`yield` kallas en :dfn:`asynchronous generator function`.  "
"En sådan funktion returnerar, när den anropas, ett :term:`asynkron "
"iterator`\\-objekt som kan användas i en :keyword:`async for`\\-sats för att "
"exekvera funktionens kropp."

#: ../../reference/datamodel.rst:800
msgid ""
"Calling the asynchronous iterator's :meth:`aiterator.__anext__ "
"<object.__anext__>` method will return an :term:`awaitable` which when "
"awaited will execute until it provides a value using the :keyword:`yield` "
"expression.  When the function executes an empty :keyword:`return` statement "
"or falls off the end, a :exc:`StopAsyncIteration` exception is raised and "
"the asynchronous iterator will have reached the end of the set of values to "
"be yielded."
msgstr ""
"Anrop av den asynkrona iteratorns metod :meth:`aiterator.__anext__ "
"<object.__anext__>` returnerar en :term:`awaitable` som när den är väntad "
"kommer att exekveras tills den ger ett värde med hjälp av "
"uttrycket :keyword:`yield`.  När funktionen exekverar en "
"tom :keyword:`return`\\-sats eller faller av i slutet, kommer "
"ett :exc:`StopAsyncIteration`\\-undantag att uppstå och den asynkrona "
"iteratorn kommer att ha nått slutet av den uppsättning värden som ska ges."

#: ../../reference/datamodel.rst:813
msgid "Built-in functions"
msgstr "Inbyggda funktioner"

#: ../../reference/datamodel.rst:820
msgid ""
"A built-in function object is a wrapper around a C function.  Examples of "
"built-in functions are :func:`len` and :func:`math.sin` (:mod:`math` is a "
"standard built-in module). The number and type of the arguments are "
"determined by the C function. Special read-only attributes:"
msgstr ""
"Ett inbyggt funktionsobjekt är ett omslag runt en C-funktion.  Exempel på "
"inbyggda funktioner är :func:`len` och :func:`math.sin` (:mod:`math` är en "
"inbyggd standardmodul). Antalet och typen av argument bestäms av C-"
"funktionen. Särskilda skrivskyddade attribut:"

#: ../../reference/datamodel.rst:825
msgid ""
":attr:`!__doc__` is the function's documentation string, or ``None`` if "
"unavailable. See :attr:`function.__doc__`."
msgstr ""
":attr:`!__doc__` är funktionens dokumentationssträng, eller ``None`` om den "
"inte är tillgänglig. Se :attr:`function.__doc__`."

#: ../../reference/datamodel.rst:827
msgid ""
":attr:`!__name__` is the function's name. See :attr:`function.__name__`."
msgstr ":attr:`!__name__` är funktionens namn. Se :attr:`function.__name__`."

#: ../../reference/datamodel.rst:828
msgid ":attr:`!__self__` is set to ``None`` (but see the next item)."
msgstr ":attr:`!__self__` är satt till ``None`` (men se nästa punkt)."

#: ../../reference/datamodel.rst:829
msgid ""
":attr:`!__module__` is the name of the module the function was defined in or "
"``None`` if unavailable. See :attr:`function.__module__`."
msgstr ""
":attr:`!__module__` är namnet på den modul som funktionen definierades i "
"eller ``None`` om den inte är tillgänglig. Se :attr:`function.__module__`."

#: ../../reference/datamodel.rst:837
msgid "Built-in methods"
msgstr "Inbyggda metoder"

#: ../../reference/datamodel.rst:844
msgid ""
"This is really a different disguise of a built-in function, this time "
"containing an object passed to the C function as an implicit extra "
"argument.  An example of a built-in method is ``alist.append()``, assuming "
"*alist* is a list object. In this case, the special read-only "
"attribute :attr:`!__self__` is set to the object denoted by *alist*. (The "
"attribute has the same semantics as it does with :attr:`other instance "
"methods <method.__self__>`.)"
msgstr ""
"Detta är egentligen en annan förklädnad av en inbyggd funktion, som den här "
"gången innehåller ett objekt som skickas till C-funktionen som ett implicit "
"extra argument.  Ett exempel på en inbyggd metod är ``alist.append()``, "
"förutsatt att *alist* är ett listobjekt. I detta fall sätts det speciella "
"skrivskyddade attributet :attr:`!__self__` till det objekt som betecknas av "
"*alist*. (Attributet har samma semantik som det har med :attr:`andra "
"instansmetoder <method.__self__>`.)"

#: ../../reference/datamodel.rst:854
msgid "Classes"
msgstr "Klasser"

#: ../../reference/datamodel.rst:856
msgid ""
"Classes are callable.  These objects normally act as factories for new "
"instances of themselves, but variations are possible for class types that "
"override :meth:`~object.__new__`.  The arguments of the call are passed "
"to :meth:`!__new__` and, in the typical case, to :meth:`~object.__init__` to "
"initialize the new instance."
msgstr ""
"Klasser är anropsbara.  Dessa objekt fungerar normalt som fabriker för nya "
"instanser av sig själva, men variationer är möjliga för klasstyper som "
"åsidosätter :meth:`~object.__new__`.  Argumenten för anropet skickas "
"till :meth:`!__new__` och, i det typiska fallet, "
"till :meth:`~object.__init__` för att initiera den nya instansen."

#: ../../reference/datamodel.rst:864
msgid "Class Instances"
msgstr "Klassinstanser"

#: ../../reference/datamodel.rst:866
msgid ""
"Instances of arbitrary classes can be made callable by defining "
"a :meth:`~object.__call__` method in their class."
msgstr ""
"Instanser av godtyckliga klasser kan göras anropbara genom att definiera "
"en :meth:`~object.__call__`\\-metod i sin klass."

#: ../../reference/datamodel.rst:873
msgid "Modules"
msgstr "Moduler"

#: ../../reference/datamodel.rst:879
msgid ""
"Modules are a basic organizational unit of Python code, and are created by "
"the :ref:`import system <importsystem>` as invoked either by "
"the :keyword:`import` statement, or by calling functions such "
"as :func:`importlib.import_module` and built-in :func:`__import__`.  A "
"module object has a namespace implemented by a :class:`dictionary <dict>` "
"object (this is the dictionary referenced by "
"the :attr:`~function.__globals__` attribute of functions defined in the "
"module).  Attribute references are translated to lookups in this dictionary, "
"e.g., ``m.x`` is equivalent to ``m.__dict__[\"x\"]``. A module object does "
"not contain the code object used to initialize the module (since it isn't "
"needed once the initialization is done)."
msgstr ""
"Moduler är en grundläggande organisatorisk enhet i Python-kod, och skapas "
"av :ref:`import system <importsystem>` som anropas antingen "
"av :keyword:`import`\\-satsen, eller genom att anropa funktioner "
"som :func:`importlib.import_module` och inbyggda :func:`__import__`.  Ett "
"modulobjekt har ett namnrymd som implementeras av ett :class:`dictionary "
"<dict>`\\-objekt (detta är den ordbok som refereras av "
"attributet :attr:`~function.__globals__` för funktioner som definieras i "
"modulen).  Attributreferenser översätts till uppslagningar i denna ordbok, "
"t.ex. är ``m.x`` likvärdigt med ``m.__dict__[\"x\"]``. Ett modulobjekt "
"innehåller inte det kodobjekt som används för att initiera modulen (eftersom "
"det inte behövs när initieringen är klar)."

#: ../../reference/datamodel.rst:892
msgid ""
"Attribute assignment updates the module's namespace dictionary, e.g., ``m.x "
"= 1`` is equivalent to ``m.__dict__[\"x\"] = 1``."
msgstr ""
"Attributtilldelning uppdaterar modulens namnrymdsordbok, t.ex. ``m.x = 1`` "
"är likvärdigt med ``m.__dict__[\"x\"] = 1``."

#: ../../reference/datamodel.rst:911
msgid "Import-related attributes on module objects"
msgstr "Importrelaterade attribut på modulobjekt"

#: ../../reference/datamodel.rst:913
msgid ""
"Module objects have the following attributes that relate to the :ref:`import "
"system <importsystem>`. When a module is created using the machinery "
"associated with the import system, these attributes are filled in based on "
"the module's :term:`spec <module spec>`, before the :term:`loader` executes "
"and loads the module."
msgstr ""
"Modulobjekt har följande attribut som relaterar till :ref:`importsystemet "
"<importsystem>`. När en modul skapas med hjälp av de maskiner som är "
"associerade med importsystemet fylls dessa attribut i baserat på "
"modulens :term:`spec <module spec>`, innan :term:`loader` körs och laddar "
"modulen."

#: ../../reference/datamodel.rst:919
msgid ""
"To create a module dynamically rather than using the import system, it's "
"recommended to use :func:`importlib.util.module_from_spec`, which will set "
"the various import-controlled attributes to appropriate values. It's also "
"possible to use the :class:`types.ModuleType` constructor to create modules "
"directly, but this technique is more error-prone, as most attributes must be "
"manually set on the module object after it has been created when using this "
"approach."
msgstr ""
"Om du vill skapa en modul dynamiskt i stället för att använda importsystemet "
"rekommenderas att du använder :func:`importlib.util.module_from_spec`, som "
"sätter de olika importkontrollerade attributen till lämpliga värden. Det är "
"också möjligt att använda :class:`types.ModuleType`\\-konstruktören för att "
"skapa moduler direkt, men den här tekniken är mer felbenägen, eftersom de "
"flesta attribut måste ställas in manuellt på modulobjektet efter att det har "
"skapats med den här metoden."

#: ../../reference/datamodel.rst:929
msgid ""
"With the exception of :attr:`~module.__name__`, it is **strongly** "
"recommended that you rely on :attr:`~module.__spec__` and its attributes "
"instead of any of the other individual attributes listed in this subsection. "
"Note that updating an attribute on :attr:`!__spec__` will not update the "
"corresponding attribute on the module itself:"
msgstr ""
"Med undantag för :attr:`~module.__name__` rekommenderas **starkt** att du "
"förlitar dig på :attr:`~module.__spec__` och dess attribut istället för "
"något av de andra enskilda attributen som listas i detta underavsnitt. "
"Observera att uppdatering av ett attribut på :attr:`!__spec__` inte kommer "
"att uppdatera motsvarande attribut på själva modulen:"

#: ../../reference/datamodel.rst:935
msgid ""
">>> import typing\n"
">>> typing.__name__, typing.__spec__.name\n"
"('typing', 'typing')\n"
">>> typing.__spec__.name = 'spelling'\n"
">>> typing.__name__, typing.__spec__.name\n"
"('typing', 'spelling')\n"
">>> typing.__name__ = 'keyboard_smashing'\n"
">>> typing.__name__, typing.__spec__.name\n"
"('keyboard_smashing', 'spelling')"
msgstr ""
">>> import typing\n"
">>> typing.__name__, typing.__spec__.name\n"
"('typing', 'typing')\n"
">>> typing.__spec__.name = 'spelling'\n"
">>> typing.__name__, typing.__spec__.name\n"
"('typing', 'spelling')\n"
">>> typing.__name__ = 'keyboard_smashing'\n"
">>> typing.__name__, typing.__spec__.name\n"
"('keyboard_smashing', 'spelling')"

#: ../../reference/datamodel.rst:949
msgid ""
"The name used to uniquely identify the module in the import system. For a "
"directly executed module, this will be set to ``\"__main__\"``."
msgstr ""
"Det namn som används för att unikt identifiera modulen i importsystemet. För "
"en direkt exekverad modul kommer detta att sättas till ``\"__main__\"``."

#: ../../reference/datamodel.rst:952
msgid ""
"This attribute must be set to the fully qualified name of the module. It is "
"expected to match the value of :attr:`module.__spec__.name "
"<importlib.machinery.ModuleSpec.name>`."
msgstr ""
"Detta attribut måste vara inställt på modulens fullständiga kvalificerade "
"namn. Det förväntas matcha värdet av :attr:`module.__spec__.name "
"<importlib.machinery.ModuleSpec.name>`."

#: ../../reference/datamodel.rst:958
msgid "A record of the module's import-system-related state."
msgstr "En registrering av modulens importsystemrelaterade tillstånd."

#: ../../reference/datamodel.rst:960
msgid ""
"Set to the :class:`module spec <importlib.machinery.ModuleSpec>` that was "
"used when importing the module. See :ref:`module-specs` for more details."
msgstr ""
"Ställdes in till :class:`modulspecifikation "
"<importlib.machinery.ModuleSpec>` som användes vid import av modulen. "
"Se :ref:`module-specs` för mer information."

#: ../../reference/datamodel.rst:967
msgid "The :term:`package` a module belongs to."
msgstr "Den :term:`package` som en modul tillhör."

#: ../../reference/datamodel.rst:969
msgid ""
"If the module is top-level (that is, not a part of any specific package) "
"then the attribute should be set to ``''`` (the empty string). Otherwise, it "
"should be set to the name of the module's package (which can be equal "
"to :attr:`module.__name__` if the module itself is a package). "
"See :pep:`366` for further details."
msgstr ""
"Om modulen är på toppnivå (dvs. inte ingår i något specifikt paket) ska "
"attributet anges till ``''`` (den tomma strängen). Annars bör det sättas "
"till namnet på modulens paket (som kan vara lika med :attr:`module.__name__` "
"om modulen själv är ett paket). Se :pep:`366` för ytterligare detaljer."

#: ../../reference/datamodel.rst:975
msgid ""
"This attribute is used instead of :attr:`~module.__name__` to calculate "
"explicit relative imports for main modules. It defaults to ``None`` for "
"modules created dynamically using the :class:`types.ModuleType` constructor; "
"use :func:`importlib.util.module_from_spec` instead to ensure the attribute "
"is set to a :class:`str`."
msgstr ""
"Detta attribut används i stället för :attr:`~module.__name__` för att "
"beräkna explicit relativ import för huvudmoduler. Standardvärdet är ``None`` "
"för moduler som skapas dynamiskt med hjälp av :class:`types.ModuleType`\\-"
"konstruktören; använd :func:`importlib.util.module_from_spec` istället för "
"att säkerställa att attributet är inställt på en :class:`str`."

#: ../../reference/datamodel.rst:981
msgid ""
"It is **strongly** recommended that you use :attr:`module.__spec__.parent "
"<importlib.machinery.ModuleSpec.parent>` instead of :attr:`!"
"module.__package__`. :attr:`__package__` is now only used as a fallback "
"if :attr:`!__spec__.parent` is not set, and this fallback path is deprecated."
msgstr ""
"Det rekommenderas **starkt** att du använder :attr:`module.__spec__.parent "
"<importlib.machinery.ModuleSpec.parent>` i stället för :attr:`!"
"module.__package__`. :attr:`__package__` används nu endast som en reservväg "
"om :attr:`!__spec__.parent` inte har angetts, och denna reservväg är "
"föråldrad."

#: ../../reference/datamodel.rst:987 ../../reference/datamodel.rst:1028
msgid ""
"This attribute now defaults to ``None`` for modules created dynamically "
"using the :class:`types.ModuleType` constructor. Previously the attribute "
"was optional."
msgstr ""
"Detta attribut är nu standard för ``None`` för moduler som skapas dynamiskt "
"med hjälp av konstruktören :class:`types.ModuleType`. Tidigare var "
"attributet valfritt."

#: ../../reference/datamodel.rst:992
msgid ""
"The value of :attr:`!__package__` is expected to be the same "
"as :attr:`__spec__.parent "
"<importlib.machinery.ModuleSpec.parent>`. :attr:`__package__` is now only "
"used as a fallback during import resolution if :attr:`!__spec__.parent` is "
"not defined."
msgstr ""
"Värdet på :attr:`!__package__` förväntas vara detsamma "
"som :attr:`__spec__.parent "
"<importlib.machinery.ModuleSpec.parent>`. :attr:`__package__` används nu "
"endast som en reservlösning vid importupplösning om :attr:`!__spec__.parent` "
"inte är definierad."

#: ../../reference/datamodel.rst:998
msgid ""
":exc:`ImportWarning` is raised if an import resolution falls back to :attr:`!"
"__package__` instead of :attr:`__spec__.parent "
"<importlib.machinery.ModuleSpec.parent>`."
msgstr ""
":exc:`ImportWarning` tas upp om en importresolution faller tillbaka "
"till :attr:`!__package__` istället för :attr:`__spec__.parent "
"<importlib.machinery.ModuleSpec.parent>`."

#: ../../reference/datamodel.rst:1003
msgid ""
"Raise :exc:`DeprecationWarning` instead of :exc:`ImportWarning` when falling "
"back to :attr:`!__package__` during import resolution."
msgstr ""
"Skicka :exc:`DeprecationWarning` istället för :exc:`ImportWarning` när man "
"faller tillbaka till :attr:`!__package__` under importlösning."

#: ../../reference/datamodel.rst:1007
msgid ""
":attr:`!__package__` will cease to be set or taken into consideration by the "
"import system or standard library."
msgstr ""
":attr:`!__package__` kommer inte längre att ställas in eller tas i beaktande "
"av importsystemet eller standardbiblioteket."

#: ../../reference/datamodel.rst:1013
msgid ""
"The :term:`loader` object that the import machinery used to load the module."
msgstr ""
"Det :term:`loader`\\-objekt som importmaskinen använde för att ladda modulen."

#: ../../reference/datamodel.rst:1015
msgid ""
"This attribute is mostly useful for introspection, but can be used for "
"additional loader-specific functionality, for example getting data "
"associated with a loader."
msgstr ""
"Detta attribut är mest användbart för introspektion, men kan användas för "
"ytterligare laddningsspecifika funktioner, t.ex. för att hämta data som är "
"associerade med en laddare."

#: ../../reference/datamodel.rst:1019
msgid ""
":attr:`!__loader__` defaults to ``None`` for modules created dynamically "
"using the :class:`types.ModuleType` constructor; "
"use :func:`importlib.util.module_from_spec` instead to ensure the attribute "
"is set to a :term:`loader` object."
msgstr ""
":attr:`!__loader__` är som standard ``None`` för moduler som skapas "
"dynamiskt med hjälp av konstruktören :class:`types.ModuleType`; använd "
"istället :func:`importlib.util.module_from_spec` för att se till att "
"attributet sätts till ett :term:`loader`\\-objekt."

#: ../../reference/datamodel.rst:1024
msgid ""
"It is **strongly** recommended that you use :attr:`module.__spec__.loader "
"<importlib.machinery.ModuleSpec.loader>` instead of :attr:`!"
"module.__loader__`."
msgstr ""
"Det rekommenderas **starkt** att du använder :attr:`module.__spec__.loader "
"<importlib.machinery.ModuleSpec.loader>` i stället för :attr:`!"
"module.__loader__`."

#: ../../reference/datamodel.rst:1033
msgid ""
"Setting :attr:`!__loader__` on a module while failing to set :attr:`!"
"__spec__.loader` is deprecated. In Python 3.16, :attr:`!__loader__` will "
"cease to be set or taken into consideration by the import system or the "
"standard library."
msgstr ""
"Att ange :attr:`!__loader__` för en modul utan att ange :attr:`!"
"__spec__.loader` är föråldrat. I Python 3.16 kommer :attr:`!__loader__` inte "
"längre att anges eller tas i beaktande av importsystemet eller "
"standardbiblioteket."

#: ../../reference/datamodel.rst:1041
msgid ""
"A (possibly empty) :term:`sequence` of strings enumerating the locations "
"where the package's submodules will be found. Non-package modules should not "
"have a :attr:`!__path__` attribute. See :ref:`package-path-rules` for more "
"details."
msgstr ""
"En (eventuellt tom) :term:`sequence` av strängar som räknar upp de platser "
"där paketets undermoduler kommer att hittas. Icke-paketmoduler bör inte ha "
"ett :attr:`!__path__`\\-attribut. Se :ref:`package-path-rules` för mer "
"information."

#: ../../reference/datamodel.rst:1046
msgid ""
"It is **strongly** recommended that you "
"use :attr:`module.__spec__.submodule_search_locations "
"<importlib.machinery.ModuleSpec.submodule_search_locations>` instead "
"of :attr:`!module.__path__`."
msgstr ""
"Det rekommenderas **starkt** att du "
"använder :attr:`module.__spec__.submodule_search_locations "
"<importlib.machinery.ModuleSpec.submodule_search_locations>` i stället "
"för :attr:`!module.__path__`."

#: ../../reference/datamodel.rst:1053
msgid ""
":attr:`!__file__` and :attr:`!__cached__` are both optional attributes that "
"may or may not be set. Both attributes should be a :class:`str` when they "
"are available."
msgstr ""
":attr:`!__file__` och :attr:`!__cached__` är båda valfria attribut som kan "
"eller inte kan anges. Båda attributen bör vara en :class:`str` när de är "
"tillgängliga."

#: ../../reference/datamodel.rst:1057
msgid ""
":attr:`!__file__` indicates the pathname of the file from which the module "
"was loaded (if loaded from a file), or the pathname of the shared library "
"file for extension modules loaded dynamically from a shared library. It "
"might be missing for certain types of modules, such as C modules that are "
"statically linked into the interpreter, and the :ref:`import system "
"<importsystem>` may opt to leave it unset if it has no semantic meaning (for "
"example, a module loaded from a database)."
msgstr ""
":attr:`!__file__` anger sökvägen till den fil från vilken modulen laddades "
"(om den laddades från en fil), eller sökvägen till den delade "
"biblioteksfilen för tilläggsmoduler som laddas dynamiskt från ett delat "
"bibliotek. Det kan saknas för vissa typer av moduler, t.ex. C-moduler som "
"länkas statiskt till tolken, och ::ref:`import-systemet <importsystem>` kan "
"välja att lämna det oinställt om det inte har någon semantisk betydelse "
"(t.ex. en modul som laddas från en databas)."

#: ../../reference/datamodel.rst:1065
msgid ""
"If :attr:`!__file__` is set then the :attr:`!__cached__` attribute might "
"also be set,  which is the path to any compiled version of the code (for "
"example, a byte-compiled file). The file does not need to exist to set this "
"attribute; the path can simply point to where the compiled file *would* "
"exist (see :pep:`3147`)."
msgstr ""
"Om :attr:`!__file__` anges kan även attributet :attr:`!__cached__` anges, "
"vilket är sökvägen till en kompilerad version av koden (t.ex. en "
"bytekompilerad fil). Filen behöver inte existera för att detta attribut ska "
"kunna anges; sökvägen kan helt enkelt peka på var den kompilerade filen "
"*skulle* finnas (se :pep:`3147`)."

#: ../../reference/datamodel.rst:1071
msgid ""
"Note that :attr:`!__cached__` may be set even if :attr:`!__file__` is not "
"set.  However, that scenario is quite atypical.  Ultimately, "
"the :term:`loader` is what makes use of the module spec provided by "
"the :term:`finder` (from which :attr:`!__file__` and :attr:`!__cached__` are "
"derived).  So if a loader can load from a cached module but otherwise does "
"not load from a file, that atypical scenario may be appropriate."
msgstr ""
"Observera att :attr:`!__cached__` kan anges även om :attr:`!__file__` inte "
"anges.  Det scenariot är dock ganska atypiskt.  I slutändan är "
"det :term:`loader` som använder modulspecifikationen som tillhandahålls "
"av :term:`finder` (från vilken :attr:`!__file__` och :attr:`!__cached__` "
"härleds).  Så om en laddare kan ladda från en cachad modul men i övrigt inte "
"laddar från en fil, kan det atypiska scenariot vara lämpligt."

#: ../../reference/datamodel.rst:1078
msgid ""
"It is **strongly** recommended that you use :attr:`module.__spec__.cached "
"<importlib.machinery.ModuleSpec.cached>` instead of :attr:`!"
"module.__cached__`."
msgstr ""
"Det rekommenderas **starkt** att du använder :attr:`module.__spec__.cached "
"<importlib.machinery.ModuleSpec.cached>` i stället för :attr:`!"
"module.__cached__`."

#: ../../reference/datamodel.rst:1082
msgid ""
"Setting :attr:`!__cached__` on a module while failing to set :attr:`!"
"__spec__.cached` is deprecated. In Python 3.15, :attr:`!__cached__` will "
"cease to be set or taken into consideration by the import system or standard "
"library."
msgstr ""
"Att ställa in :attr:`!__cached__` på en modul samtidigt som man misslyckas "
"med att ställa in :attr:`!__spec__.cached` är föråldrat. I Python 3.15 "
"kommer :attr:`!__cached__` inte längre att anges eller tas i beaktande av "
"importsystemet eller standardbiblioteket."

#: ../../reference/datamodel.rst:1089
msgid "Other writable attributes on module objects"
msgstr "Andra skrivbara attribut på modulobjekt"

#: ../../reference/datamodel.rst:1091
msgid ""
"As well as the import-related attributes listed above, module objects also "
"have the following writable attributes:"
msgstr ""
"Förutom de importrelaterade attribut som anges ovan har modulobjekten även "
"följande skrivbara attribut:"

#: ../../reference/datamodel.rst:1096
msgid ""
"The module's documentation string, or ``None`` if unavailable. See "
"also: :attr:`__doc__ attributes <definition.__doc__>`."
msgstr ""
"Modulens dokumentationssträng, eller ``None`` om den inte är tillgänglig. Se "
"även: :attr:`__doc__-attribut <definition.__doc__>`."

#: ../../reference/datamodel.rst:1101
msgid ""
"A dictionary containing :term:`variable annotations <variable annotation>` "
"collected during module body execution.  For best practices on working "
"with :attr:`!__annotations__`, see :mod:`annotationlib`."
msgstr ""
"En ordbok som innehåller :term:`variable annotations <variable annotation>` "
"som samlats in under modulens exekvering.  För bästa praxis för att arbeta "
"med :attr:`!__annotations__`, se :mod:`annotationlib`."

#: ../../reference/datamodel.rst:1111
msgid ""
"The :term:`annotate function` for this module, or ``None`` if the module has "
"no annotations. See also: :attr:`~object.__annotate__` attributes."
msgstr ""
":term:`annotate function` för denna modul, eller ``None`` om modulen inte "
"har några annotationer. Se även: :attr:`~object.__annotate__` attribut."

#: ../../reference/datamodel.rst:1117
msgid "Module dictionaries"
msgstr "Modul ordböcker"

#: ../../reference/datamodel.rst:1119
msgid "Module objects also have the following special read-only attribute:"
msgstr "Modulobjekt har också följande speciella skrivskyddade attribut:"

#: ../../reference/datamodel.rst:1124
msgid ""
"The module's namespace as a dictionary object. Uniquely among the attributes "
"listed here, :attr:`!__dict__` cannot be accessed as a global variable from "
"within a module; it can only be accessed as an attribute on module objects."
msgstr ""
"Modulens namnrymd som ett ordboksobjekt. En unik egenskap bland de attribut "
"som listas här är att :attr:`!__dict__` inte kan nås som en global variabel "
"från en modul, utan endast som ett attribut på modulobjekt."

#: ../../reference/datamodel.rst:1130
msgid ""
"Because of the way CPython clears module dictionaries, the module dictionary "
"will be cleared when the module falls out of scope even if the dictionary "
"still has live references.  To avoid this, copy the dictionary or keep the "
"module around while using its dictionary directly."
msgstr ""
"På grund av hur CPython rensar modulordböcker kommer modulordboken att "
"rensas när modulen faller ur räckvidden även om ordboken fortfarande har "
"levande referenser.  För att undvika detta, kopiera ordlistan eller behåll "
"modulen medan du använder dess ordlista direkt."

#: ../../reference/datamodel.rst:1139
msgid "Custom classes"
msgstr "Anpassade klasser"

#: ../../reference/datamodel.rst:1141
msgid ""
"Custom class types are typically created by class definitions (see "
"section :ref:`class`).  A class has a namespace implemented by a dictionary "
"object. Class attribute references are translated to lookups in this "
"dictionary, e.g., ``C.x`` is translated to ``C.__dict__[\"x\"]`` (although "
"there are a number of hooks which allow for other means of locating "
"attributes). When the attribute name is not found there, the attribute "
"search continues in the base classes. This search of the base classes uses "
"the C3 method resolution order which behaves correctly even in the presence "
"of 'diamond' inheritance structures where there are multiple inheritance "
"paths leading back to a common ancestor. Additional details on the C3 MRO "
"used by Python can be found at :ref:`python_2.3_mro`."
msgstr ""
"Anpassade klasstyper skapas vanligen genom klassdefinitioner (se "
"avsnitt :ref:`class`).  En klass har ett namnrymd som implementeras av ett "
"ordboksobjekt. Referenser till klassattribut översätts till uppslagningar i "
"denna ordbok, t.ex. översätts ``C.x`` till ``C.__dict__[\"x\"]`` (även om "
"det finns ett antal hooks som tillåter andra sätt att lokalisera attribut). "
"Om attributnamnet inte hittas där fortsätter sökningen i basklasserna. Vid "
"denna sökning i basklasserna används C3-metodens upplösningsordning som "
"fungerar korrekt även när det finns \"diamantformade\" arvsstrukturer där "
"det finns flera arvsvägar som leder tillbaka till en gemensam förfader. "
"Ytterligare detaljer om C3 MRO som används av Python finns "
"på :ref:`python_2.3_mro`."

#: ../../reference/datamodel.rst:1162
msgid ""
"When a class attribute reference (for class :class:`!C`, say) would yield a "
"class method object, it is transformed into an instance method object "
"whose :attr:`~method.__self__` attribute is :class:`!C`. When it would yield "
"a :class:`staticmethod` object, it is transformed into the object wrapped by "
"the static method object. See section :ref:`descriptors` for another way in "
"which attributes retrieved from a class may differ from those actually "
"contained in its :attr:`~object.__dict__`."
msgstr ""
"När en referens till ett klassattribut (t.ex. för klassen :class:`!C`) "
"skulle ge ett klassmetodobjekt, omvandlas det till ett instansmetodobjekt "
"vars attribut :attr:`~method.__self__` är :class:`!C`. När det skulle ge "
"ett :class:`staticmethod`\\-objekt, omvandlas det till det objekt som "
"omsluts av det statiska metodobjektet. Se avsnitt :ref:`descriptors` för ett "
"annat sätt på vilket attribut som hämtas från en klass kan skilja sig från "
"de som faktiskt finns i dess :attr:`~object.__dict__`."

#: ../../reference/datamodel.rst:1173
msgid ""
"Class attribute assignments update the class's dictionary, never the "
"dictionary of a base class."
msgstr ""
"Tilldelningar av klassattribut uppdaterar klassens ordbok, aldrig en "
"basklass ordbok."

#: ../../reference/datamodel.rst:1178
msgid ""
"A class object can be called (see above) to yield a class instance (see "
"below)."
msgstr ""
"Ett klassobjekt kan anropas (se ovan) för att ge en klassinstans (se nedan)."

#: ../../reference/datamodel.rst:1181 ../../reference/datamodel.rst:1349
msgid "Special attributes"
msgstr "Särskilda egenskaper"

#: ../../reference/datamodel.rst:1202
msgid ""
"The class's name. See also: :attr:`__name__ attributes "
"<definition.__name__>`."
msgstr ""
"Klassens namn. Se även: :attr:`__name__ attribut <definition.__name__>`."

#: ../../reference/datamodel.rst:1206
msgid ""
"The class's :term:`qualified name`. See also: :attr:`__qualname__ attributes "
"<definition.__qualname__>`."
msgstr ""
"Klassens :term:`qualified name`. Se även: :attr:`__qualname__\\-attribut "
"<definition.__qualname__>`."

#: ../../reference/datamodel.rst:1210
msgid "The name of the module in which the class was defined."
msgstr "Namnet på den modul i vilken klassen definierades."

#: ../../reference/datamodel.rst:1213
msgid ""
"A :class:`mapping proxy <types.MappingProxyType>` providing a read-only view "
"of the class's namespace. See also: :attr:`__dict__ attributes "
"<object.__dict__>`."
msgstr ""
"En :class:`mappningsproxy <types.MappingProxyType>` som ger en skrivskyddad "
"vy av klassens namnrymd. Se även: :attr:`__dict__-attribut "
"<object.__dict__>`."

#: ../../reference/datamodel.rst:1218
msgid ""
"A :class:`tuple` containing the class's bases. In most cases, for a class "
"defined as ``class X(A, B, C)``, ``X.__bases__`` will be exactly equal to "
"``(A, B, C)``."
msgstr ""
"En :class:`tuple` som innehåller klassens baser. I de flesta fall, för en "
"klass definierad som ``class X(A, B, C)``, kommer ``X.__bases__`` att vara "
"exakt lika med ``(A, B, C)``."

#: ../../reference/datamodel.rst:1223
msgid ""
"The class's documentation string, or ``None`` if undefined. Not inherited by "
"subclasses."
msgstr ""
"Klassens dokumentationssträng, eller ``None`` om den är odefinierad. Ärvs "
"inte av underklasser."

#: ../../reference/datamodel.rst:1227
msgid ""
"A dictionary containing :term:`variable annotations <variable annotation>` "
"collected during class body execution. See also: :attr:`__annotations__ "
"attributes <object.__annotations__>`."
msgstr ""
"En ordbok som innehåller :term:`variable annotations <variable annotation>` "
"som samlats in under klassens exekvering. Se även: :attr:`__annotations__ "
"attribut <object.__annotations__>`."

#: ../../reference/datamodel.rst:1232
msgid ""
"For best practices on working with :attr:`~object.__annotations__`, please "
"see :mod:`annotationlib`. Use :func:`annotationlib.get_annotations` instead "
"of accessing this attribute directly."
msgstr ""
"För bästa praxis för att arbeta med :attr:`~object.__annotations__`, "
"se :mod:`annotationlib`. Använd :func:`annotationlib.get_annotations` "
"istället för att komma åt detta attribut direkt."

#: ../../reference/datamodel.rst:1239
msgid ""
"Accessing the :attr:`!__annotations__` attribute directly on a class object "
"may return annotations for the wrong class, specifically in certain cases "
"where the class, its base class, or a metaclass is defined under ``from "
"__future__ import annotations``. See :pep:`749 <749#pep749-metaclasses>` for "
"details."
msgstr ""
"Om du använder attributet :attr:`!__annotations__` direkt på ett klassobjekt "
"kan du få tillbaka annoteringar för fel klass, särskilt i vissa fall där "
"klassen, dess basklass eller en metaklass definieras under ``from __future__ "
"import annotations``. Se :pep:`749 <749#pep749-metaclasses>` för detaljer."

#: ../../reference/datamodel.rst:1245
msgid ""
"This attribute does not exist on certain builtin classes. On user-defined "
"classes without ``__annotations__``, it is an empty dictionary."
msgstr ""
"Detta attribut finns inte i vissa inbyggda klasser. På användardefinierade "
"klasser utan ``__annotations__`` är det en tom ordbok."

#: ../../reference/datamodel.rst:1254
msgid ""
"The :term:`annotate function` for this class, or ``None`` if the class has "
"no annotations. See also: :attr:`__annotate__ attributes "
"<object.__annotate__>`."
msgstr ""
":term:`annotate function` för denna klass, eller ``None`` om klassen inte "
"har några annoteringar. Se även: :attr:`__annotate__-attribut "
"<object.__annotate__>`."

#: ../../reference/datamodel.rst:1261
msgid ""
"A :class:`tuple` containing the :ref:`type parameters <type-params>` of "
"a :ref:`generic class <generic-classes>`."
msgstr ""
"En :class:`tuple` som innehåller :ref:`type parameters <type-params>` för "
"en :ref:`generic class <generic-classes>`."

#: ../../reference/datamodel.rst:1267
msgid ""
"A :class:`tuple` containing names of attributes of this class which are "
"assigned through ``self.X`` from any function in its body."
msgstr ""
"En :class:`tuple` som innehåller namn på attribut för denna klass som "
"tilldelas via ``self.X`` från någon funktion i dess kropp."

#: ../../reference/datamodel.rst:1273
msgid ""
"The line number of the first line of the class definition, including "
"decorators. Setting the :attr:`~type.__module__` attribute removes "
"the :attr:`!__firstlineno__` item from the type's dictionary."
msgstr ""

#: ../../reference/datamodel.rst:1281
msgid ""
"The :class:`tuple` of classes that are considered when looking for base "
"classes during method resolution."
msgstr ""
"Den :class:`tupel` av klasser som beaktas när man letar efter basklasser "
"under metodresolution."

#: ../../reference/datamodel.rst:1286
msgid "Special methods"
msgstr "Särskilda metoder"

#: ../../reference/datamodel.rst:1288
msgid ""
"In addition to the special attributes described above, all Python classes "
"also have the following two methods available:"
msgstr ""
"Förutom de specialattribut som beskrivs ovan har alla Python-klasser också "
"följande två metoder tillgängliga:"

#: ../../reference/datamodel.rst:1293
msgid ""
"This method can be overridden by a metaclass to customize the method "
"resolution order for its instances.  It is called at class instantiation, "
"and its result is stored in :attr:`~type.__mro__`."
msgstr ""
"Den här metoden kan åsidosättas av en metaklass för att anpassa "
"metodupplösningsordningen för dess instanser.  Den anropas vid klassens "
"instansiering och dess resultat lagras i :attr:`~type.__mro__`."

#: ../../reference/datamodel.rst:1299
msgid ""
"Each class keeps a list of weak references to its immediate subclasses. This "
"method returns a list of all those references still alive. The list is in "
"definition order. Example:"
msgstr ""
"Varje klass har en lista över svaga referenser till sina närmaste "
"underklasser. Denna metod returnerar en lista över alla dessa referenser som "
"fortfarande är vid liv. Listan är i definitionsordning. Ett exempel:"

#: ../../reference/datamodel.rst:1303
msgid ""
">>> class A: pass\n"
">>> class B(A): pass\n"
">>> A.__subclasses__()\n"
"[<class 'B'>]"
msgstr ""
">>> class A: pass\n"
">>> class B(A): pass\n"
">>> A.__subclasses__()\n"
"[<class 'B'>]"

#: ../../reference/datamodel.rst:1311
msgid "Class instances"
msgstr "Klassinstanser"

#: ../../reference/datamodel.rst:1319
msgid ""
"A class instance is created by calling a class object (see above).  A class "
"instance has a namespace implemented as a dictionary which is the first "
"place in which attribute references are searched.  When an attribute is not "
"found there, and the instance's class has an attribute by that name, the "
"search continues with the class attributes.  If a class attribute is found "
"that is a user-defined function object, it is transformed into an instance "
"method object whose :attr:`~method.__self__` attribute is the instance.  "
"Static method and class method objects are also transformed; see above under "
"\"Classes\".  See section :ref:`descriptors` for another way in which "
"attributes of a class retrieved via its instances may differ from the "
"objects actually stored in the class's :attr:`~object.__dict__`.  If no "
"class attribute is found, and the object's class has "
"a :meth:`~object.__getattr__` method, that is called to satisfy the lookup."
msgstr ""
"En klassinstans skapas genom att anropa ett klassobjekt (se ovan).  En "
"klassinstans har ett namnrymd som är implementerat som en ordbok som är det "
"första stället där attributreferenser söks.  Om ett attribut inte hittas där "
"och instansens klass har ett attribut med samma namn, fortsätter sökningen "
"med klassattributen.  Om ett klassattribut hittas som är ett "
"användardefinierat funktionsobjekt omvandlas det till ett instansmetodobjekt "
"vars attribut :attr:`~method.__self__` är instansen.  Statiska metod- och "
"klassmetodobjekt transformeras också; se ovan under \"Klasser\".  Se "
"avsnitt :ref:`descriptors` för ett annat sätt på vilket attribut för en "
"klass som hämtas via dess instanser kan skilja sig från de objekt som "
"faktiskt lagras i klassens :attr:`~object.__dict__`.  Om inget klassattribut "
"hittas, och objektets klass har en :meth:`~object.__getattr__`\\-metod, "
"anropas den för att uppfylla sökningen."

#: ../../reference/datamodel.rst:1335
msgid ""
"Attribute assignments and deletions update the instance's dictionary, never "
"a class's dictionary.  If the class has a :meth:`~object.__setattr__` "
"or :meth:`~object.__delattr__` method, this is called instead of updating "
"the instance dictionary directly."
msgstr ""
"Tilldelning och borttagning av attribut uppdaterar instansens dictionary, "
"aldrig en klass' dictionary.  Om klassen har en "
"metod :meth:`~object.__setattr__` eller :meth:`~object.__delattr__` anropas "
"denna istället för att uppdatera instansens dictionary direkt."

#: ../../reference/datamodel.rst:1345
msgid ""
"Class instances can pretend to be numbers, sequences, or mappings if they "
"have methods with certain special names.  See section :ref:`specialnames`."
msgstr ""
"Klassinstanser kan låtsas vara tal, sekvenser eller avbildningar om de har "
"metoder med vissa speciella namn.  Se avsnitt :ref:`specialnames`."

#: ../../reference/datamodel.rst:1357
msgid "The class to which a class instance belongs."
msgstr "Den klass som en klassinstans tillhör."

#: ../../reference/datamodel.rst:1361
msgid ""
"A dictionary or other mapping object used to store an object's (writable) "
"attributes. Not all instances have a :attr:`!__dict__` attribute; see the "
"section on :ref:`slots` for more details."
msgstr ""
"En ordbok eller annat mappningsobjekt som används för att lagra ett objekts "
"(skrivbara) attribut. Inte alla instanser har ett :attr:`!__dict__`\\-"
"attribut; se avsnittet om :ref:`slots` för mer information."

#: ../../reference/datamodel.rst:1367
msgid "I/O objects (also known as file objects)"
msgstr "I/O-objekt (även kända som filobjekt)"

#: ../../reference/datamodel.rst:1382
msgid ""
"A :term:`file object` represents an open file.  Various shortcuts are "
"available to create file objects: the :func:`open` built-in function, and "
"also :func:`os.popen`, :func:`os.fdopen`, and "
"the :meth:`~socket.socket.makefile` method of socket objects (and perhaps by "
"other functions or methods provided by extension modules)."
msgstr ""
"Ett :term:`filobjekt` representerar en öppen fil.  Olika genvägar finns "
"tillgängliga för att skapa filobjekt: den inbyggda funktionen :func:`open`, "
"och även :func:`os.popen`, :func:`os.fdopen` och "
"metoden :meth:`~socket.socket.makefile` för socketobjekt (och kanske andra "
"funktioner eller metoder som tillhandahålls av tilläggsmoduler)."

#: ../../reference/datamodel.rst:1388
msgid ""
"The objects ``sys.stdin``, ``sys.stdout`` and ``sys.stderr`` are initialized "
"to file objects corresponding to the interpreter's standard input, output "
"and error streams; they are all open in text mode and therefore follow the "
"interface defined by the :class:`io.TextIOBase` abstract class."
msgstr ""
"Objekten ``sys.stdin``, ``sys.stdout`` och ``sys.stderr`` initialiseras till "
"filobjekt som motsvarar tolkens standardflöden för inmatning, utmatning och "
"fel; de är alla öppna i textläge och följer därför det gränssnitt som "
"definieras av den abstrakta klassen :class:`io.TextIOBase`."

#: ../../reference/datamodel.rst:1396
msgid "Internal types"
msgstr "Interna typer"

#: ../../reference/datamodel.rst:1402
msgid ""
"A few types used internally by the interpreter are exposed to the user. "
"Their definitions may change with future versions of the interpreter, but "
"they are mentioned here for completeness."
msgstr ""
"Några typer som används internt av tolken är exponerade för användaren. "
"Deras definitioner kan komma att ändras i framtida versioner av tolken, men "
"de nämns här för fullständighetens skull."

#: ../../reference/datamodel.rst:1410
msgid "Code objects"
msgstr "Kodobjekt"

#: ../../reference/datamodel.rst:1414
msgid ""
"Code objects represent *byte-compiled* executable Python code, "
"or :term:`bytecode`. The difference between a code object and a function "
"object is that the function object contains an explicit reference to the "
"function's globals (the module in which it was defined), while a code object "
"contains no context; also the default argument values are stored in the "
"function object, not in the code object (because they represent values "
"calculated at run-time).  Unlike function objects, code objects are "
"immutable and contain no references (directly or indirectly) to mutable "
"objects."
msgstr ""
"Kodobjekt representerar *byte-kompilerad* exekverbar Python-kod, "
"eller :term:`bytecode`. Skillnaden mellan ett kodobjekt och ett "
"funktionsobjekt är att funktionsobjektet innehåller en explicit referens "
"till funktionens globaler (den modul där den definierades), medan ett "
"kodobjekt inte innehåller någon kontext; även standardargumentvärdena lagras "
"i funktionsobjektet, inte i kodobjektet (eftersom de representerar värden "
"som beräknas vid körning).  Till skillnad från funktionsobjekt är kodobjekt "
"oföränderliga och innehåller inga referenser (vare sig direkt eller "
"indirekt) till föränderliga objekt."

#: ../../reference/datamodel.rst:1448
msgid "The function name"
msgstr "Funktionens namn"

#: ../../reference/datamodel.rst:1451
msgid "The fully qualified function name"
msgstr "Det fullständigt kvalificerade funktionsnamnet"

#: ../../reference/datamodel.rst:1456
msgid ""
"The total number of positional :term:`parameters <parameter>` (including "
"positional-only parameters and parameters with default values) that the "
"function has"
msgstr ""
"Det totala antalet positionella :term:`parametrar <parameter>` (inklusive "
"enbart positionella parametrar och parametrar med standardvärden) som "
"funktionen har"

#: ../../reference/datamodel.rst:1461
msgid ""
"The number of positional-only :term:`parameters <parameter>` (including "
"arguments with default values) that the function has"
msgstr ""
"Antalet positionsbestämda :term:`parametrar <parameter>` (inklusive argument "
"med standardvärden) som funktionen har"

#: ../../reference/datamodel.rst:1465
msgid ""
"The number of keyword-only :term:`parameters <parameter>` (including "
"arguments with default values) that the function has"
msgstr ""
"Antalet nyckelordsspecifika :term:`parametrar <parameter>` (inklusive "
"argument med standardvärden) som funktionen har"

#: ../../reference/datamodel.rst:1469
msgid ""
"The number of :ref:`local variables <naming>` used by the function "
"(including parameters)"
msgstr ""
"Antalet :ref:`lokala variabler <naming>` som används av funktionen "
"(inklusive parametrar)"

#: ../../reference/datamodel.rst:1473
msgid ""
"A :class:`tuple` containing the names of the local variables in the function "
"(starting with the parameter names)"
msgstr ""
"En :class:`tuple` som innehåller namnen på de lokala variablerna i "
"funktionen (börjar med parameternamnen)"

#: ../../reference/datamodel.rst:1477
msgid ""
"A :class:`tuple` containing the names of :ref:`local variables <naming>` "
"that are referenced from at least one :term:`nested scope` inside the "
"function"
msgstr ""
"En :class:`tuple` som innehåller namnen på :ref:`lokala variabler <naming>` "
"som refereras från minst en :term:`nested scope` inuti funktionen"

#: ../../reference/datamodel.rst:1481
msgid ""
"A :class:`tuple` containing the names of :term:`free (closure) variables "
"<closure variable>` that a :term:`nested scope` references in an outer "
"scope. See also :attr:`function.__closure__`."
msgstr ""
"En :class:`tupel` som innehåller namnen på :term:`free (closure) variables "
"<closure variable>` som en :term:`nested scope` refererar till i ett yttre "
"scope. Se även :attr:`function.__closure__`."

#: ../../reference/datamodel.rst:1485
msgid "Note: references to global and builtin names are *not* included."
msgstr "Obs: referenser till globala och inbyggda namn är *inte* inkluderade."

#: ../../reference/datamodel.rst:1488
msgid ""
"A string representing the sequence of :term:`bytecode` instructions in the "
"function"
msgstr ""
"En sträng som representerar sekvensen av :term:`bytecode`\\-instruktioner i "
"funktionen"

#: ../../reference/datamodel.rst:1492
msgid ""
"A :class:`tuple` containing the literals used by the :term:`bytecode` in the "
"function"
msgstr ""
"En :class:`tuple` som innehåller de literaler som används "
"av :term:`bytecode` i funktionen"

#: ../../reference/datamodel.rst:1496
msgid ""
"A :class:`tuple` containing the names used by the :term:`bytecode` in the "
"function"
msgstr ""
"En :class:`tuple` som innehåller de namn som används av :term:`bytecode` i "
"funktionen"

#: ../../reference/datamodel.rst:1500
msgid "The name of the file from which the code was compiled"
msgstr "Namnet på den fil som koden kompilerades från"

#: ../../reference/datamodel.rst:1503
msgid "The line number of the first line of the function"
msgstr "Radnumret för den första raden i funktionen"

#: ../../reference/datamodel.rst:1506
msgid ""
"A string encoding the mapping from :term:`bytecode` offsets to line numbers. "
"For details, see the source code of the interpreter."
msgstr ""
"En sträng som kodar mappningen från :term:`bytecode`\\-offsets till "
"radnummer. För detaljer, se källkoden för tolken."

#: ../../reference/datamodel.rst:1509
msgid ""
"This attribute of code objects is deprecated, and may be removed in Python "
"3.15."
msgstr ""
"Detta attribut för kodobjekt är föråldrat och kan komma att tas bort i "
"Python 3.15."

#: ../../reference/datamodel.rst:1514
msgid "The required stack size of the code object"
msgstr "Den nödvändiga stackstorleken för kodobjektet"

#: ../../reference/datamodel.rst:1517
msgid ""
"An :class:`integer <int>` encoding a number of flags for the interpreter."
msgstr "En :class:`integer <int>` som kodar ett antal flaggor för tolken."

#: ../../reference/datamodel.rst:1522
msgid ""
"The following flag bits are defined for :attr:`~codeobject.co_flags`: bit "
"``0x04`` is set if the function uses the ``*arguments`` syntax to accept an "
"arbitrary number of positional arguments; bit ``0x08`` is set if the "
"function uses the ``**keywords`` syntax to accept arbitrary keyword "
"arguments; bit ``0x20`` is set if the function is a generator. "
"See :ref:`inspect-module-co-flags` for details on the semantics of each "
"flags that might be present."
msgstr ""
"Följande flaggbitar är definierade för :attr:`~codeobject.co_flags`: bit "
"``0x04`` sätts om funktionen använder syntaxen ``*arguments`` för att "
"acceptera ett godtyckligt antal positionella argument; bit ``0x08`` sätts om "
"funktionen använder syntaxen ``**keywords`` för att acceptera godtyckliga "
"nyckelordsargument; bit ``0x20`` sätts om funktionen är en generator. "
"Se :ref:`inspect-module-co-flags` för detaljer om semantiken för varje "
"flagga som kan förekomma."

#: ../../reference/datamodel.rst:1530
msgid ""
"Future feature declarations (for example, ``from __future__ import "
"division``) also use bits in :attr:`~codeobject.co_flags` to indicate "
"whether a code object was compiled with a particular feature enabled. "
"See :attr:`~__future__._Feature.compiler_flag`."
msgstr ""
"Deklarationer av framtida funktioner (t.ex. ``from __future__ import "
"division``) använder också bitar i :attr:`~codeobject.co_flags` för att ange "
"om ett kodobjekt kompilerades med en viss funktion aktiverad. "
"Se :attr:`~__future__._Feature.compiler_flag`."

#: ../../reference/datamodel.rst:1534
msgid ""
"Other bits in :attr:`~codeobject.co_flags` are reserved for internal use."
msgstr ""
"Övriga bitar i :attr:`~codeobject.co_flags` är reserverade för internt bruk."

#: ../../reference/datamodel.rst:1538
msgid ""
"If a code object represents a function and has a docstring, "
"the :data:`~inspect.CO_HAS_DOCSTRING` bit is set "
"in :attr:`~codeobject.co_flags` and the first item "
"in :attr:`~codeobject.co_consts` is the docstring of the function."
msgstr ""
"Om ett kodobjekt representerar en funktion och har en docstring, sätts "
"bit :data:`~inspect.CO_HAS_DOCSTRING` i :attr:`~codeobject.co_flags` och det "
"första objektet i :attr:`~codeobject.co_consts` är funktionens docstring."

#: ../../reference/datamodel.rst:1544
msgid "Methods on code objects"
msgstr "Metoder på kodobjekt"

#: ../../reference/datamodel.rst:1548
msgid ""
"Returns an iterable over the source code positions of each :term:`bytecode` "
"instruction in the code object."
msgstr ""
"Returnerar en iterabel över källkodspositionerna för "
"varje :term:`bytecode`\\-instruktion i kodobjektet."

#: ../../reference/datamodel.rst:1551
msgid ""
"The iterator returns :class:`tuple`\\s containing the ``(start_line, "
"end_line, start_column, end_column)``. The *i-th* tuple corresponds to the "
"position of the source code that compiled to the *i-th* code unit. Column "
"information is 0-indexed utf-8 byte offsets on the given source line."
msgstr ""
"Iteratorn returnerar :class:`tuple`` som innehåller ``(start_line, end_line, "
"start_column, end_column)``. Tupeln *i-th* motsvarar positionen för den "
"källkod som kompilerades till kodenheten *i-th*. Kolumninformationen är 0-"
"indexerade utf-8-byteoffset på den angivna källkodsraden."

#: ../../reference/datamodel.rst:1557
msgid ""
"This positional information can be missing. A non-exhaustive lists of cases "
"where this may happen:"
msgstr ""
"Denna positionsinformation kan saknas. En icke uttömmande lista över fall "
"där detta kan inträffa:"

#: ../../reference/datamodel.rst:1560
msgid "Running the interpreter with :option:`-X` ``no_debug_ranges``."
msgstr "Kör tolken med :option:`\\-X` ``no_debug_ranges``."

#: ../../reference/datamodel.rst:1561
msgid ""
"Loading a pyc file compiled while using :option:`-X` ``no_debug_ranges``."
msgstr ""
"Läser in en pyc-fil som kompilerats med :option:`\\-X` ``no_debug_ranges``."

#: ../../reference/datamodel.rst:1562
msgid "Position tuples corresponding to artificial instructions."
msgstr "Positionstuplar som motsvarar artificiella instruktioner."

#: ../../reference/datamodel.rst:1563
msgid ""
"Line and column numbers that can't be represented due to implementation "
"specific limitations."
msgstr ""
"Rad- och kolumnnummer som inte kan representeras på grund av "
"implementationsspecifika begränsningar."

#: ../../reference/datamodel.rst:1566
msgid ""
"When this occurs, some or all of the tuple elements can be :const:`None`."
msgstr ""
"När detta inträffar kan vissa eller alla element i tupeln vara :const:`None`."

#: ../../reference/datamodel.rst:1572
msgid ""
"This feature requires storing column positions in code objects which may "
"result in a small increase of disk usage of compiled Python files or "
"interpreter memory usage. To avoid storing the extra information and/or "
"deactivate printing the extra traceback information, the :option:`-X` "
"``no_debug_ranges`` command line flag or the :envvar:`PYTHONNODEBUGRANGES` "
"environment variable can be used."
msgstr ""
"Den här funktionen kräver att kolumnpositioner lagras i kodobjekt, vilket "
"kan leda till en liten ökning av diskanvändningen för kompilerade Python-"
"filer eller tolkens minnesanvändning. För att undvika att lagra den extra "
"informationen och/eller avaktivera utskrift av extra spårningsinformation "
"kan kommandoradsflaggan :option:`\\-X` ``no_debug_ranges`` eller "
"miljövariabeln :envvar:`PYTHONNODEBUGRANGES` användas."

#: ../../reference/datamodel.rst:1581
msgid ""
"Returns an iterator that yields information about successive ranges "
"of :term:`bytecode`\\s. Each item yielded is a ``(start, end, "
"lineno)`` :class:`tuple`:"
msgstr ""
"Returnerar en iterator som ger information om successiva intervall "
"av :term:`bytecode`\\-element. Varje objekt som returneras är en ``(start, "
"end, lineno)`` :class:`tuple`:"

#: ../../reference/datamodel.rst:1585
msgid ""
"``start`` (an :class:`int`) represents the offset (inclusive) of the start "
"of the :term:`bytecode` range"
msgstr ""
"``start`` (en :class:`int`) representerar förskjutningen (inklusive) av "
"början på :term:`bytecode`\\-intervallet"

#: ../../reference/datamodel.rst:1587
msgid ""
"``end`` (an :class:`int`) represents the offset (exclusive) of the end of "
"the :term:`bytecode` range"
msgstr ""
"``end`` (en :class:`int`) representerar förskjutningen (exklusiv) av slutet "
"på :term:`bytecode`\\-intervallet"

#: ../../reference/datamodel.rst:1589
msgid ""
"``lineno`` is an :class:`int` representing the line number of "
"the :term:`bytecode` range, or ``None`` if the bytecodes in the given range "
"have no line number"
msgstr ""
"``lineno`` är en :class:`int` som representerar radnumret "
"i :term:`bytecode`\\-intervallet, eller ``None`` om bytekoderna i det "
"angivna intervallet inte har något radnummer"

#: ../../reference/datamodel.rst:1593
msgid "The items yielded will have the following properties:"
msgstr "De produkter som erhålls kommer att ha följande egenskaper:"

#: ../../reference/datamodel.rst:1595
msgid "The first range yielded will have a ``start`` of 0."
msgstr "Det första intervallet som genereras har ``start`` 0."

#: ../../reference/datamodel.rst:1596
msgid ""
"The ``(start, end)`` ranges will be non-decreasing and consecutive. That is, "
"for any pair of :class:`tuple`\\s, the ``start`` of the second will be equal "
"to the ``end`` of the first."
msgstr ""
"Områdena ``(start, end)`` kommer att vara icke avtagande och konsekutiva. "
"Det vill säga, för varje par av :class:`tuple` kommer ``start`` för det "
"andra att vara lika med ``end`` för det första."

#: ../../reference/datamodel.rst:1599
msgid "No range will be backwards: ``end >= start`` for all triples."
msgstr ""
"Inget intervall kommer att vara bakåtriktat: ``end >= start`` för alla "
"tripplar."

#: ../../reference/datamodel.rst:1600
msgid ""
"The last :class:`tuple` yielded will have ``end`` equal to the size of "
"the :term:`bytecode`."
msgstr ""
"Den sista :class:`tuple` som erhålls kommer att ha ``end`` lika med "
"storleken på :term:`bytecode`."

#: ../../reference/datamodel.rst:1603
msgid ""
"Zero-width ranges, where ``start == end``, are allowed. Zero-width ranges "
"are used for lines that are present in the source code, but have been "
"eliminated by the :term:`bytecode` compiler."
msgstr ""
"Nollbreddsområden, där ``start == end``, är tillåtna. Områden med nollbredd "
"används för rader som finns i källkoden, men som har eliminerats av "
"kompilatorn :term:`bytecode`."

#: ../../reference/datamodel.rst:1611
msgid ":pep:`626` - Precise line numbers for debugging and other tools."
msgstr ":pep:`626` - Exakta radnummer för felsökning och andra verktyg."

#: ../../reference/datamodel.rst:1612
msgid "The PEP that introduced the :meth:`!co_lines` method."
msgstr "Den PEP som introducerade metoden :meth:`!co_lines`."

#: ../../reference/datamodel.rst:1616
msgid ""
"Return a copy of the code object with new values for the specified fields."
msgstr ""
"Returnerar en kopia av kodobjektet med nya värden för de angivna fälten."

#: ../../reference/datamodel.rst:1618
msgid ""
"Code objects are also supported by the generic function :func:`copy.replace`."
msgstr ""
"Kodobjekt stöds också av den generiska funktionen :func:`copy.replace`."

#: ../../reference/datamodel.rst:1626
msgid "Frame objects"
msgstr "Ramobjekt"

#: ../../reference/datamodel.rst:1630
msgid ""
"Frame objects represent execution frames.  They may occur in :ref:`traceback "
"objects <traceback-objects>`, and are also passed to registered trace "
"functions."
msgstr ""
"Frame-objekt representerar exekveringsramar.  De kan förekomma "
"i :ref:`traceback-objekt <traceback-objects>`, och skickas också till "
"registrerade spårningsfunktioner."

#: ../../reference/datamodel.rst:1649
msgid ""
"Points to the previous stack frame (towards the caller), or ``None`` if this "
"is the bottom stack frame"
msgstr ""
"Pekar på föregående stapelram (mot den som anropar), eller ``None`` om detta "
"är den nedersta stapelramen"

#: ../../reference/datamodel.rst:1653
msgid ""
"The :ref:`code object <code-objects>` being executed in this frame. "
"Accessing this attribute raises an :ref:`auditing event <auditing>` "
"``object.__getattr__`` with arguments ``obj`` and ``\"f_code\"``."
msgstr ""
"Det :ref:`code object <code-objects>` som exekveras i denna frame. Åtkomst "
"till detta attribut ger upphov till en :ref:`auditing event <auditing>` "
"``object.__getattr__`` med argumenten ``obj`` och ``\"f_code\"``."

#: ../../reference/datamodel.rst:1658
msgid ""
"The mapping used by the frame to look up :ref:`local variables <naming>`. If "
"the frame refers to an :term:`optimized scope`, this may return a write-"
"through proxy object."
msgstr ""
"Den mappning som används av ramen för att leta upp :ref:`lokala variabler "
"<naming>`. Om ramen refererar till en :term:`optimized scope`, kan detta "
"returnera ett write-through proxy-objekt."

#: ../../reference/datamodel.rst:1663
msgid "Return a proxy for optimized scopes."
msgstr "Returnera en proxy för optimerade scopes."

#: ../../reference/datamodel.rst:1667
msgid ""
"The dictionary used by the frame to look up :ref:`global variables <naming>`"
msgstr ""
"Den ordbok som används av ramen för att slå upp :ref:`globala variabler "
"<naming>`"

#: ../../reference/datamodel.rst:1671
msgid ""
"The dictionary used by the frame to look up :ref:`built-in (intrinsic) names "
"<naming>`"
msgstr ""
"Den ordbok som används av ramen för att slå upp :ref:`inbyggda (intrinsic) "
"namn <naming>`"

#: ../../reference/datamodel.rst:1675
msgid ""
"The \"precise instruction\" of the frame object (this is an index into "
"the :term:`bytecode` string of the :ref:`code object <code-objects>`)"
msgstr ""
"Den \"exakta instruktionen\" för ramobjektet (detta är ett index "
"i :term:`bytecode`\\-strängen i :ref:`code object <code-objects>`)"

#: ../../reference/datamodel.rst:1680
msgid ""
"The :term:`generator` or :term:`coroutine` object that owns this frame, or "
"``None`` if the frame is a normal function."
msgstr ""

#: ../../reference/datamodel.rst:1697
msgid ""
"If not ``None``, this is a function called for various events during code "
"execution (this is used by debuggers). Normally an event is triggered for "
"each new source line (see :attr:`~frame.f_trace_lines`)."
msgstr ""
"Om inte ``None``, är detta en funktion som anropas för olika händelser under "
"kodkörning (detta används av debuggar). Normalt utlöses en händelse för "
"varje ny källkodsrad (se :attr:`~frame.f_trace_lines`)."

#: ../../reference/datamodel.rst:1702
msgid ""
"Set this attribute to :const:`False` to disable triggering a tracing event "
"for each source line."
msgstr ""
"Ställ in detta attribut på :const:`False` för att inaktivera utlösningen av "
"en spårningshändelse för varje källrad."

#: ../../reference/datamodel.rst:1706
msgid ""
"Set this attribute to :const:`True` to allow per-opcode events to be "
"requested. Note that this may lead to undefined interpreter behaviour if "
"exceptions raised by the trace function escape to the function being traced."
msgstr ""
"Sätt detta attribut till :const:`True` för att tillåta att händelser per "
"operationskod begärs. Observera att detta kan leda till ett odefinierat "
"tolkbeteende om undantag som skapas av spårningsfunktionen flyr till den "
"funktion som spåras."

#: ../../reference/datamodel.rst:1712
msgid ""
"The current line number of the frame -- writing to this from within a trace "
"function jumps to the given line (only for the bottom-most frame).  A "
"debugger can implement a Jump command (aka Set Next Statement) by writing to "
"this attribute."
msgstr ""
"Det aktuella radnumret för ramen - om du skriver till detta från en "
"spårningsfunktion hoppar du till den angivna raden (endast för den nedersta "
"ramen).  En debugger kan implementera ett Jump-kommando (även kallat Set "
"Next Statement) genom att skriva till detta attribut."

#: ../../reference/datamodel.rst:1718
msgid "Frame object methods"
msgstr "Metoder för ramobjekt"

#: ../../reference/datamodel.rst:1720
msgid "Frame objects support one method:"
msgstr "Ramobjekt stöder en metod:"

#: ../../reference/datamodel.rst:1724
msgid ""
"This method clears all references to :ref:`local variables <naming>` held by "
"the frame.  Also, if the frame belonged to a :term:`generator`, the "
"generator is finalized.  This helps break reference cycles involving frame "
"objects (for example when catching an :ref:`exception <bltin-exceptions>` "
"and storing its :ref:`traceback <traceback-objects>` for later use)."
msgstr ""
"Denna metod rensar alla referenser till :ref:`lokala variabler <naming>` som "
"finns i ramen.  Dessutom, om ramen tillhörde en :term:`generator`, slutförs "
"generatorn.  Detta hjälper till att bryta referenscykler som involverar "
"ramobjekt (till exempel när man fångar ett :ref:`exception <bltin-"
"exceptions>` och lagrar dess :ref:`traceback <traceback-objects>` för senare "
"användning)."

#: ../../reference/datamodel.rst:1730
msgid ""
":exc:`RuntimeError` is raised if the frame is currently executing or "
"suspended."
msgstr ""
":exc:`RuntimeError` uppstår om ramen för närvarande körs eller avbryts."

#: ../../reference/datamodel.rst:1735
msgid ""
"Attempting to clear a suspended frame raises :exc:`RuntimeError` (as has "
"always been the case for executing frames)."
msgstr ""
"Försök att rensa en suspenderad ram ger upphov till :exc:`RuntimeError` "
"(vilket alltid har varit fallet för exekverande ramar)."

#: ../../reference/datamodel.rst:1743
msgid "Traceback objects"
msgstr "Spårningsobjekt"

#: ../../reference/datamodel.rst:1756
msgid ""
"Traceback objects represent the stack trace of an :ref:`exception <tut-"
"errors>`. A traceback object is implicitly created when an exception occurs, "
"and may also be explicitly created by calling :class:`types.TracebackType`."
msgstr ""
"Traceback-objekt representerar stackspårningen av ett :ref:`exception <tut-"
"errors>`. Ett traceback-objekt skapas implicit när ett undantag inträffar, "
"och kan också skapas explicit genom att anropa :class:`types.TracebackType`."

#: ../../reference/datamodel.rst:1761
msgid "Traceback objects can now be explicitly instantiated from Python code."
msgstr "Traceback-objekt kan nu uttryckligen instansieras från Python-kod."

#: ../../reference/datamodel.rst:1764
msgid ""
"For implicitly created tracebacks, when the search for an exception handler "
"unwinds the execution stack, at each unwound level a traceback object is "
"inserted in front of the current traceback.  When an exception handler is "
"entered, the stack trace is made available to the program. (See "
"section :ref:`try`.) It is accessible as the third item of the tuple "
"returned by :func:`sys.exc_info`, and as "
"the :attr:`~BaseException.__traceback__` attribute of the caught exception."
msgstr ""
"För implicit skapade spårningar, när sökningen efter en undantagshanterare "
"rullar upp exekveringsstacken, infogas ett spårningsobjekt framför den "
"aktuella spårningen på varje upprullningsnivå.  När en undantagshanterare "
"anges görs stackspårningen tillgänglig för programmet. (Se "
"avsnitt :ref:`try`.) Det är tillgängligt som det tredje objektet i den tupel "
"som returneras av :func:`sys.exc_info`, och som "
"attributet :attr:`~BaseException.__traceback__` för det fångade undantaget."

#: ../../reference/datamodel.rst:1773
msgid ""
"When the program contains no suitable handler, the stack trace is written "
"(nicely formatted) to the standard error stream; if the interpreter is "
"interactive, it is also made available to the user "
"as :data:`sys.last_traceback`."
msgstr ""
"När programmet inte innehåller någon lämplig hanterare skrivs stackspåret "
"(snyggt formaterat) till standardfelsflödet; om tolken är interaktiv görs "
"det också tillgängligt för användaren som :data:`sys.last_traceback`."

#: ../../reference/datamodel.rst:1778
msgid ""
"For explicitly created tracebacks, it is up to the creator of the traceback "
"to determine how the :attr:`~traceback.tb_next` attributes should be linked "
"to form a full stack trace."
msgstr ""
"För explicit skapade spårningar är det upp till skaparen av spårningen att "
"avgöra hur :attr:`~traceback.tb_next`\\-attributen ska länkas för att bilda "
"en fullständig stackspårning."

#: ../../reference/datamodel.rst:1793
msgid ""
"Points to the execution :ref:`frame <frame-objects>` of the current level."
msgstr ""
"Pekar på exekveringen :ref:`frame <frame-objects>` av den aktuella nivån."

#: ../../reference/datamodel.rst:1796
msgid ""
"Accessing this attribute raises an :ref:`auditing event <auditing>` "
"``object.__getattr__`` with arguments ``obj`` and ``\"tb_frame\"``."
msgstr ""
"Åtkomst till detta attribut ger upphov till en :ref:`auditing event "
"<auditing>` ``object.__getattr__`` med argumenten ``obj`` och "
"``\"tb_frame\"``."

#: ../../reference/datamodel.rst:1801
msgid "Gives the line number where the exception occurred"
msgstr "Ger radnumret där undantaget inträffade"

#: ../../reference/datamodel.rst:1804
msgid "Indicates the \"precise instruction\"."
msgstr "Anger \"exakt instruktion\"."

#: ../../reference/datamodel.rst:1806
msgid ""
"The line number and last instruction in the traceback may differ from the "
"line number of its :ref:`frame object <frame-objects>` if the exception "
"occurred in a :keyword:`try` statement with no matching except clause or "
"with a :keyword:`finally` clause."
msgstr ""
"Radnumret och den sista instruktionen i spårningen kan skilja sig från "
"radnumret i dess :ref:`frame object <frame-objects>` om undantaget "
"inträffade i en :keyword:`try`\\-sats utan någon matchande except-sats eller "
"med en :keyword:`finally`\\-sats."

#: ../../reference/datamodel.rst:1817
msgid ""
"The special writable attribute :attr:`!tb_next` is the next level in the "
"stack trace (towards the frame where the exception occurred), or ``None`` if "
"there is no next level."
msgstr ""
"Det speciella skrivbara attributet :attr:`!tb_next` är nästa nivå i "
"stackspårningen (mot den ram där undantaget inträffade), eller ``None`` om "
"det inte finns någon nästa nivå."

#: ../../reference/datamodel.rst:1821
msgid "This attribute is now writable"
msgstr "Detta attribut är nu skrivbart"

#: ../../reference/datamodel.rst:1826
msgid "Slice objects"
msgstr "Skiva objekt"

#: ../../reference/datamodel.rst:1830
msgid ""
"Slice objects are used to represent slices for :meth:`~object.__getitem__` "
"methods.  They are also created by the built-in :func:`slice` function."
msgstr ""
"Slice-objekt används för att representera slices "
"för :meth:`~object.__getitem__`\\-metoder.  De skapas också av den inbyggda "
"funktionen :func:`slice`."

#: ../../reference/datamodel.rst:1839
msgid ""
"Special read-only attributes: :attr:`~slice.start` is the lower "
"bound; :attr:`~slice.stop` is the upper bound; :attr:`~slice.step` is the "
"step value; each is ``None`` if omitted.  These attributes can have any type."
msgstr ""
"Särskilda skrivskyddade attribut: :attr:`~slice.start` är den nedre "
"gränsen; :attr:`~slice.stop` är den övre gränsen; :attr:`~slice.step` är "
"stegvärdet; varje attribut är ``None`` om det utelämnas.  Dessa attribut kan "
"ha vilken typ som helst."

#: ../../reference/datamodel.rst:1843
msgid "Slice objects support one method:"
msgstr "Slice-objekt stöder en metod:"

#: ../../reference/datamodel.rst:1847
msgid ""
"This method takes a single integer argument *length* and computes "
"information about the slice that the slice object would describe if applied "
"to a sequence of *length* items.  It returns a tuple of three integers; "
"respectively these are the *start* and *stop* indices and the *step* or "
"stride length of the slice. Missing or out-of-bounds indices are handled in "
"a manner consistent with regular slices."
msgstr ""
"Denna metod tar ett enda heltalsargument *length* och beräknar information "
"om den del som slice-objektet skulle beskriva om det tillämpades på en "
"sekvens av *length*-objekt.  Den returnerar en tupel av tre heltal; dessa är "
"indexen *start* och *stop* respektive *step* eller stride-längden för "
"skivan. Saknade index eller index utanför gränserna hanteras på ett sätt som "
"överensstämmer med vanliga slices."

#: ../../reference/datamodel.rst:1856
msgid "Static method objects"
msgstr "Statiska metodobjekt"

#: ../../reference/datamodel.rst:1858
msgid ""
"Static method objects provide a way of defeating the transformation of "
"function objects to method objects described above. A static method object "
"is a wrapper around any other object, usually a user-defined method object. "
"When a static method object is retrieved from a class or a class instance, "
"the object actually returned is the wrapped object, which is not subject to "
"any further transformation. Static method objects are also callable. Static "
"method objects are created by the built-in :func:`staticmethod` constructor."
msgstr ""
"Statiska metodobjekt är ett sätt att motverka den omvandling av "
"funktionsobjekt till metodobjekt som beskrivs ovan. Ett statiskt metodobjekt "
"är ett omslag runt ett annat objekt, vanligtvis ett användardefinierat "
"metodobjekt. När ett statiskt metodobjekt hämtas från en klass eller en "
"klassinstans är det objekt som faktiskt returneras det omslutna objektet, "
"som inte är föremål för någon ytterligare omvandling. Statiska metodobjekt "
"är också anropsbara. Statiska metodobjekt skapas av den "
"inbyggda :func:`staticmethod`\\-konstruktören."

#: ../../reference/datamodel.rst:1868
msgid "Class method objects"
msgstr "Klassmetodobjekt"

#: ../../reference/datamodel.rst:1870
msgid ""
"A class method object, like a static method object, is a wrapper around "
"another object that alters the way in which that object is retrieved from "
"classes and class instances. The behaviour of class method objects upon such "
"retrieval is described above, under :ref:`\"instance methods\" <instance-"
"methods>`. Class method objects are created by the built-"
"in :func:`classmethod` constructor."
msgstr ""
"Ett klassmetodobjekt, liksom ett statiskt metodobjekt, är ett omslag runt "
"ett annat objekt som ändrar det sätt på vilket det objektet hämtas från "
"klasser och klassinstanser. Klassmetodobjektens beteende vid sådan hämtning "
"beskrivs ovan, under :ref:`\"instansmetoder\" <instance-methods>`. "
"Klassmetodobjekt skapas av den inbyggda :func:`classmethod`\\-konstruktören."

#: ../../reference/datamodel.rst:1880
msgid "Special method names"
msgstr "Särskilda metodnamn"

#: ../../reference/datamodel.rst:1886
msgid ""
"A class can implement certain operations that are invoked by special syntax "
"(such as arithmetic operations or subscripting and slicing) by defining "
"methods with special names. This is Python's approach to :dfn:`operator "
"overloading`, allowing classes to define their own behavior with respect to "
"language operators.  For instance, if a class defines a method "
"named :meth:`~object.__getitem__`, and ``x`` is an instance of this class, "
"then ``x[i]`` is roughly equivalent to ``type(x).__getitem__(x, i)``.  "
"Except where mentioned, attempts to execute an operation raise an exception "
"when no appropriate method is defined (typically :exc:`AttributeError` "
"or :exc:`TypeError`)."
msgstr ""
"En klass kan implementera vissa operationer som anropas med speciell syntax "
"(t.ex. aritmetiska operationer eller subscripting och slicing) genom att "
"definiera metoder med speciella namn. Detta är Pythons sätt att "
"använda :dfn:`operator overloading`, vilket gör det möjligt för klasser att "
"definiera sitt eget beteende med avseende på språkoperatorer.  Om en klass "
"till exempel definierar en metod med namnet :meth:`~object.__getitem__`, och "
"``x`` är en instans av denna klass, så är ``x[i]`` ungefär likvärdig med "
"``type(x).__getitem__(x, i)``.  Om inget annat anges leder försök att utföra "
"en operation till ett undantag om ingen lämplig metod är definierad "
"(typiskt :exc:`AttributeError` eller :exc:`TypeError`)."

#: ../../reference/datamodel.rst:1897
msgid ""
"Setting a special method to ``None`` indicates that the corresponding "
"operation is not available.  For example, if a class "
"sets :meth:`~object.__iter__` to ``None``, the class is not iterable, so "
"calling :func:`iter` on its instances will raise a :exc:`TypeError` (without "
"falling back to :meth:`~object.__getitem__`). [#]_"
msgstr ""
"Om en specialmetod sätts till ``None`` innebär det att motsvarande operation "
"inte är tillgänglig.  Om en klass till exempel "
"sätter :meth:`~object.__iter__` till ``None`` är klassen inte iterabel, så "
"anrop av :func:`iter` på dess instanser kommer att ge upphov till "
"ett :exc:`TypeError` (utan att falla tillbaka "
"på :meth:`~object.__getitem__`). [#]_"

#: ../../reference/datamodel.rst:1903
msgid ""
"When implementing a class that emulates any built-in type, it is important "
"that the emulation only be implemented to the degree that it makes sense for "
"the object being modelled.  For example, some sequences may work well with "
"retrieval of individual elements, but extracting a slice may not make sense. "
"(One example of this is the :ref:`NodeList <dom-nodelist-objects>` interface "
"in the W3C's Document Object Model.)"
msgstr ""

#: ../../reference/datamodel.rst:1914
msgid "Basic customization"
msgstr "Grundläggande anpassning"

#: ../../reference/datamodel.rst:1920
msgid ""
"Called to create a new instance of class *cls*.  :meth:`__new__` is a static "
"method (special-cased so you need not declare it as such) that takes the "
"class of which an instance was requested as its first argument.  The "
"remaining arguments are those passed to the object constructor expression "
"(the call to the class).  The return value of :meth:`__new__` should be the "
"new object instance (usually an instance of *cls*)."
msgstr ""
"Anropas för att skapa en ny instans av klassen *cls*. :meth:`__new__` är en "
"statisk metod (specialklassad så att du inte behöver deklarera den som "
"sådan) som tar den klass som en instans begärdes av som sitt första "
"argument.  De återstående argumenten är de som skickas till "
"objektkonstruktörens uttryck (anropet till klassen).  Returvärdet "
"för :meth:`__new__` bör vara den nya objektinstansen (vanligtvis en instans "
"av *cls*)."

#: ../../reference/datamodel.rst:1927
msgid ""
"Typical implementations create a new instance of the class by invoking the "
"superclass's :meth:`__new__` method using ``super().__new__(cls[, ...])`` "
"with appropriate arguments and then modifying the newly created instance as "
"necessary before returning it."
msgstr ""
"Typiska implementeringar skapar en ny instans av klassen genom att anropa "
"superklassens :meth:`__new__`\\-metod genom att använda "
"``super().__new__(cls[, ...])`` med lämpliga argument och sedan modifiera "
"den nyskapade instansen efter behov innan den returneras."

#: ../../reference/datamodel.rst:1932
msgid ""
"If :meth:`__new__` is invoked during object construction and it returns an "
"instance of *cls*, then the new instance’s :meth:`__init__` method will be "
"invoked like ``__init__(self[, ...])``, where *self* is the new instance and "
"the remaining arguments are the same as were passed to the object "
"constructor."
msgstr ""
"Om :meth:`__new__` anropas under objektkonstruktionen och den returnerar en "
"instans av *cls*, kommer den nya instansens :meth:`__init__`\\-metod att "
"anropas som ``__init__(self[, ...])``, där *self* är den nya instansen och "
"de återstående argumenten är desamma som skickades till objektkonstruktören."

#: ../../reference/datamodel.rst:1937
msgid ""
"If :meth:`__new__` does not return an instance of *cls*, then the new "
"instance's :meth:`__init__` method will not be invoked."
msgstr ""
"Om :meth:`__new__` inte returnerar en instans av *cls*, kommer den nya "
"instansens :meth:`__init__`\\-metod inte att anropas."

#: ../../reference/datamodel.rst:1940
msgid ""
":meth:`__new__` is intended mainly to allow subclasses of immutable types "
"(like int, str, or tuple) to customize instance creation.  It is also "
"commonly overridden in custom metaclasses in order to customize class "
"creation."
msgstr ""
":meth:`__new__` är främst avsedd för att tillåta underklasser av "
"oföränderliga typer (som int, str eller tuple) att anpassa skapandet av "
"instanser.  Den åsidosätts också ofta i anpassade metaklasser för att "
"anpassa skapandet av klasser."

#: ../../reference/datamodel.rst:1949
msgid ""
"Called after the instance has been created (by :meth:`__new__`), but before "
"it is returned to the caller.  The arguments are those passed to the class "
"constructor expression.  If a base class has an :meth:`__init__` method, the "
"derived class's :meth:`__init__` method, if any, must explicitly call it to "
"ensure proper initialization of the base class part of the instance; for "
"example: ``super().__init__([args...])``."
msgstr ""
"Anropas efter att instansen har skapats (av :meth:`__new__`), men innan den "
"returneras till den som anropar.  Argumenten är de som skickas till klassens "
"konstruktörsuttryck.  Om en basklass har en :meth:`__init__`\\-metod, måste "
"den härledda klassens :meth:`__init__`\\-metod, om någon, uttryckligen "
"anropa den för att säkerställa korrekt initialisering av basklassens del av "
"instansen; till exempel: ``super().__init__([args...])``."

#: ../../reference/datamodel.rst:1956
msgid ""
"Because :meth:`__new__` and :meth:`__init__` work together in constructing "
"objects (:meth:`__new__` to create it, and :meth:`__init__` to customize "
"it), no non-``None`` value may be returned by :meth:`__init__`; doing so "
"will cause a :exc:`TypeError` to be raised at runtime."
msgstr ""
"Eftersom :meth:`__new__` och :meth:`__init__` arbetar tillsammans för att "
"konstruera objekt (:meth:`__new__` för att skapa det och :meth:`__init__` "
"för att anpassa det), får inget värde som inte är ``None`` returneras "
"av :meth:`__init__`; om så sker kommer ett :exc:`TypeError` att uppstå vid "
"körning."

#: ../../reference/datamodel.rst:1969
msgid ""
"Called when the instance is about to be destroyed.  This is also called a "
"finalizer or (improperly) a destructor.  If a base class has "
"a :meth:`__del__` method, the derived class's :meth:`__del__` method, if "
"any, must explicitly call it to ensure proper deletion of the base class "
"part of the instance."
msgstr ""
"Anropas när instansen är på väg att förstöras.  Detta kallas också en "
"finalizer eller (felaktigt) en destructor.  Om en basklass har "
"en :meth:`__del__`\\-metod, måste den härledda klassens :meth:`__del__`\\-"
"metod, om någon, uttryckligen anropa den för att säkerställa korrekt "
"radering av basklassens del av instansen."

#: ../../reference/datamodel.rst:1975
msgid ""
"It is possible (though not recommended!) for the :meth:`__del__` method to "
"postpone destruction of the instance by creating a new reference to it.  "
"This is called object *resurrection*.  It is implementation-dependent "
"whether :meth:`__del__` is called a second time when a resurrected object is "
"about to be destroyed; the current :term:`CPython` implementation only calls "
"it once."
msgstr ""
"Det är möjligt (men inte rekommenderat!) för metoden :meth:`__del__` att "
"skjuta upp destruktionen av instansen genom att skapa en ny referens till "
"den.  Detta kallas objektets *återuppståndelse*.  Det är "
"implementationsberoende om :meth:`__del__` anropas en andra gång när ett "
"återuppstått objekt är på väg att förstöras; den nuvarande :term:`CPython`\\-"
"implementationen anropar den bara en gång."

#: ../../reference/datamodel.rst:1982
msgid ""
"It is not guaranteed that :meth:`__del__` methods are called for objects "
"that still exist when the interpreter exits. :class:`weakref.finalize` "
"provides a straightforward way to register a cleanup function to be called "
"when an object is garbage collected."
msgstr ""
"Det är inte garanterat att :meth:`__del__`\\-metoder anropas för objekt som "
"fortfarande existerar när tolken avslutas. :class:`weakref.finalize` ger ett "
"enkelt sätt att registrera en rensningsfunktion som ska anropas när ett "
"objekt samlas in."

#: ../../reference/datamodel.rst:1989
msgid ""
"``del x`` doesn't directly call ``x.__del__()`` --- the former decrements "
"the reference count for ``x`` by one, and the latter is only called when "
"``x``'s reference count reaches zero."
msgstr ""
"``del x`` anropar inte direkt ``x.__del__()`` --- den förra minskar "
"referensantalet för ``x`` med ett, och den senare anropas endast när ``x`` "
"referensantal når noll."

#: ../../reference/datamodel.rst:1994
msgid ""
"It is possible for a reference cycle to prevent the reference count of an "
"object from going to zero.  In this case, the cycle will be later detected "
"and deleted by the :term:`cyclic garbage collector <garbage collection>`.  A "
"common cause of reference cycles is when an exception has been caught in a "
"local variable.  The frame's locals then reference the exception, which "
"references its own traceback, which references the locals of all frames "
"caught in the traceback."
msgstr ""
"Det är möjligt för en referenscykel att förhindra att referensantalet för "
"ett objekt går ner till noll.  I så fall kommer cykeln senare att upptäckas "
"och raderas av :term:`cyklisk skräpsamlare <garbage collection>`.  En vanlig "
"orsak till referenscykler är när ett undantag har fångats upp i en lokal "
"variabel.  Ramens lokala variabler refererar då till undantaget, som "
"refererar till sin egen traceback, som refererar till de lokala variablerna "
"i alla ramar som fångas i tracebacken."

#: ../../reference/datamodel.rst:2004
msgid "Documentation for the :mod:`gc` module."
msgstr "Dokumentation för modulen :mod:`gc`."

#: ../../reference/datamodel.rst:2008
msgid ""
"Due to the precarious circumstances under which :meth:`__del__` methods are "
"invoked, exceptions that occur during their execution are ignored, and a "
"warning is printed to ``sys.stderr`` instead.  In particular:"
msgstr ""
"På grund av de prekära omständigheter under vilka :meth:`__del__`\\-"
"metoderna anropas, ignoreras undantag som inträffar under deras exekvering "
"och en varning skrivs ut till ``sys.stderr`` istället.  I synnerhet:"

#: ../../reference/datamodel.rst:2012
msgid ""
":meth:`__del__` can be invoked when arbitrary code is being executed, "
"including from any arbitrary thread.  If :meth:`__del__` needs to take a "
"lock or invoke any other blocking resource, it may deadlock as the resource "
"may already be taken by the code that gets interrupted to "
"execute :meth:`__del__`."
msgstr ""
":meth:`__del__` kan anropas när godtycklig kod körs, inklusive från en "
"godtycklig tråd.  Om :meth:`__del__` behöver ta ett lås eller anropa någon "
"annan blockerande resurs kan det leda till dödläge eftersom resursen redan "
"kan vara tagen av den kod som avbryts för att exekvera :meth:`__del__`."

#: ../../reference/datamodel.rst:2018
msgid ""
":meth:`__del__` can be executed during interpreter shutdown.  As a "
"consequence, the global variables it needs to access (including other "
"modules) may already have been deleted or set to ``None``. Python guarantees "
"that globals whose name begins with a single underscore are deleted from "
"their module before other globals are deleted; if no other references to "
"such globals exist, this may help in assuring that imported modules are "
"still available at the time when the :meth:`__del__` method is called."
msgstr ""
":meth:`__del__` kan köras när tolken stängs av.  Som en följd av detta kan "
"de globala variabler som den behöver komma åt (inklusive andra moduler) "
"redan ha raderats eller satts till ``None``. Python garanterar att globaler "
"vars namn börjar med ett enda understreck raderas från sin modul innan andra "
"globaler raderas; om det inte finns några andra referenser till sådana "
"globaler kan detta hjälpa till att säkerställa att importerade moduler "
"fortfarande är tillgängliga vid den tidpunkt då metoden :meth:`__del__` "
"anropas."

#: ../../reference/datamodel.rst:2033
msgid ""
"Called by the :func:`repr` built-in function to compute the \"official\" "
"string representation of an object.  If at all possible, this should look "
"like a valid Python expression that could be used to recreate an object with "
"the same value (given an appropriate environment).  If this is not possible, "
"a string of the form ``<...some useful description...>`` should be returned. "
"The return value must be a string object. If a class "
"defines :meth:`__repr__` but not :meth:`__str__`, then :meth:`__repr__` is "
"also used when an \"informal\" string representation of instances of that "
"class is required."
msgstr ""
"Anropas av den inbyggda funktionen :func:`repr` för att beräkna den "
"\"officiella\" strängrepresentationen av ett objekt.  Om det är möjligt bör "
"detta se ut som ett giltigt Python-uttryck som kan användas för att "
"återskapa ett objekt med samma värde (i en lämplig miljö).  Om detta inte är "
"möjligt bör en sträng av formen ``<...some useful description...>`` "
"returneras. Returvärdet måste vara ett strängobjekt. Om en klass "
"definierar :meth:`__repr__` men inte :meth:`__str__`, så "
"används :meth:`__repr__` också när en \"informell\" strängrepresentation av "
"instanser av klassen krävs."

#: ../../reference/datamodel.rst:2042
msgid ""
"This is typically used for debugging, so it is important that the "
"representation is information-rich and unambiguous. A default implementation "
"is provided by the :class:`object` class itself."
msgstr ""
"Detta används vanligtvis för felsökning, så det är viktigt att "
"representationen är informationsrik och otvetydig. En standardimplementation "
"tillhandahålls av :class:`object`\\-klassen själv."

#: ../../reference/datamodel.rst:2054
msgid ""
"Called by :func:`str(object) <str>`, the default :meth:`__format__` "
"implementation, and the built-in function :func:`print`, to compute the "
"\"informal\" or nicely printable string representation of an object.  The "
"return value must be a :ref:`str <textseq>` object."
msgstr ""
"Anropas av :func:`str(object) <str>`, "
"standardimplementeringen :meth:`__format__` och den inbyggda "
"funktionen :func:`print`, för att beräkna den \"informella\" eller snyggt "
"utskrivbara strängrepresentationen av ett objekt.  Returvärdet måste vara "
"ett :ref:`str <textseq>`\\-objekt."

#: ../../reference/datamodel.rst:2059
msgid ""
"This method differs from :meth:`object.__repr__` in that there is no "
"expectation that :meth:`__str__` return a valid Python expression: a more "
"convenient or concise representation can be used."
msgstr ""
"Den här metoden skiljer sig från :meth:`object.__repr__` genom att det inte "
"finns någon förväntan på att :meth:`__str__` ska returnera ett giltigt "
"Python-uttryck: en mer bekväm eller kortfattad representation kan användas."

#: ../../reference/datamodel.rst:2063
msgid ""
"The default implementation defined by the built-in type :class:`object` "
"calls :meth:`object.__repr__`."
msgstr ""
"Standardimplementeringen som definieras av den inbyggda "
"typen :class:`object` anropar :meth:`object.__repr__`."

#: ../../reference/datamodel.rst:2073
msgid ""
"Called by :ref:`bytes <func-bytes>` to compute a byte-string representation "
"of an object. This should return a :class:`bytes` object. "
"The :class:`object` class itself does not provide this method."
msgstr ""
"Anropas av :ref:`bytes <func-bytes>` för att beräkna en byte-"
"strängrepresentation av ett objekt. Detta bör returnera ett :class:`bytes`\\-"
"objekt. Klassen :class:`object` tillhandahåller inte själv denna metod."

#: ../../reference/datamodel.rst:2085
msgid ""
"Called by the :func:`format` built-in function, and by extension, evaluation "
"of :ref:`formatted string literals <f-strings>` and the :meth:`str.format` "
"method, to produce a \"formatted\" string representation of an object. The "
"*format_spec* argument is a string that contains a description of the "
"formatting options desired. The interpretation of the *format_spec* argument "
"is up to the type implementing :meth:`__format__`, however most classes will "
"either delegate formatting to one of the built-in types, or use a similar "
"formatting option syntax."
msgstr ""
"Anropas av den inbyggda funktionen :func:`format`, och i förlängningen "
"utvärdering av :ref:`formatted string literals <f-strings>` och "
"metoden :meth:`str.format`, för att producera en \"formaterad\" "
"strängrepresentation av ett objekt. Argumentet *format_spec* är en sträng "
"som innehåller en beskrivning av de formateringsalternativ som önskas. "
"Tolkningen av argumentet *format_spec* är upp till den typ som "
"implementerar :meth:`__format__`, men de flesta klasser kommer antingen att "
"delegera formateringen till en av de inbyggda typerna eller använda en "
"liknande syntax för formateringsalternativ."

#: ../../reference/datamodel.rst:2095
msgid ""
"See :ref:`formatspec` for a description of the standard formatting syntax."
msgstr ""
"Se :ref:`formatspec` för en beskrivning av standardformateringssyntaxen."

#: ../../reference/datamodel.rst:2097
msgid "The return value must be a string object."
msgstr "Returvärdet måste vara ett strängobjekt."

#: ../../reference/datamodel.rst:2099
msgid ""
"The default implementation by the :class:`object` class should be given an "
"empty *format_spec* string. It delegates to :meth:`__str__`."
msgstr ""
"Standardimplementeringen av :class:`object`\\-klassen bör ges en tom "
"*format_spec*-sträng. Den delegerar till :meth:`__str__`."

#: ../../reference/datamodel.rst:2102
msgid ""
"The __format__ method of ``object`` itself raises a :exc:`TypeError` if "
"passed any non-empty string."
msgstr ""
"Metoden __format__ i ``object`` själv ger upphov till ett :exc:`TypeError` "
"om den skickar en icke-tom sträng."

#: ../../reference/datamodel.rst:2106
msgid ""
"``object.__format__(x, '')`` is now equivalent to ``str(x)`` rather than "
"``format(str(x), '')``."
msgstr ""
"``object.__format__(x, '')`` är nu likvärdigt med ``str(x)`` i stället för "
"``format(str(x), '')``."

#: ../../reference/datamodel.rst:2122
msgid ""
"These are the so-called \"rich comparison\" methods. The correspondence "
"between operator symbols and method names is as follows: ``x<y`` calls "
"``x.__lt__(y)``, ``x<=y`` calls ``x.__le__(y)``, ``x==y`` calls "
"``x.__eq__(y)``, ``x!=y`` calls ``x.__ne__(y)``, ``x>y`` calls "
"``x.__gt__(y)``, and ``x>=y`` calls ``x.__ge__(y)``."
msgstr ""
"Dessa är de så kallade \"rich comparison\"-metoderna. Korrespondensen mellan "
"operatorsymboler och metodnamn är följande: ``x<y`` kallar ``x.__lt__(y)``, "
"``x<=y`` kallar ``x.__le__(y)``, ``x==y`` kallar ``x.__eq__(y)``, ``x!=y`` "
"kallar ``x.__ne__(y)``, ``x>y`` kallar ``x.__gt__(y)`` och ``x>=y`` kallar "
"``x.__ge__(y)``."

#: ../../reference/datamodel.rst:2128
msgid ""
"A rich comparison method may return the singleton :data:`NotImplemented` if "
"it does not implement the operation for a given pair of arguments. By "
"convention, ``False`` and ``True`` are returned for a successful comparison. "
"However, these methods can return any value, so if the comparison operator "
"is used in a Boolean context (e.g., in the condition of an ``if`` "
"statement), Python will call :func:`bool` on the value to determine if the "
"result is true or false."
msgstr ""
"En rik jämförelsemetod kan returnera singleton :data:`NotImplemented` om den "
"inte implementerar operationen för ett givet par argument. Av konvention "
"returneras ``False`` och ``True`` för en lyckad jämförelse. Dessa metoder "
"kan dock returnera vilket värde som helst, så om jämförelseoperatorn används "
"i ett booleskt sammanhang (t.ex. i villkoret för en ``if``\\-sats), kommer "
"Python att anropa :func:`bool` på värdet för att avgöra om resultatet är "
"sant eller falskt."

#: ../../reference/datamodel.rst:2135
msgid ""
"By default, ``object`` implements :meth:`__eq__` by using ``is``, "
"returning :data:`NotImplemented` in the case of a false comparison: ``True "
"if x is y else NotImplemented``. For :meth:`__ne__`, by default it delegates "
"to :meth:`__eq__` and inverts the result unless it is :data:`!"
"NotImplemented`.  There are no other implied relationships among the "
"comparison operators or default implementations; for example, the truth of "
"``(x<y or x==y)`` does not imply ``x<=y``. To automatically generate "
"ordering operations from a single root operation, "
"see :func:`functools.total_ordering`."
msgstr ""
"Som standard implementerar ``object`` :meth:`__eq__` genom att använda "
"``is`` och returnerar :data:`NotImplemented`` vid en falsk jämförelse: "
"``True if x is y else NotImplemented``. För :meth:`__ne__` delegerar den som "
"standard till :meth:`__eq__` och inverterar resultatet om det inte "
"är :data:`!NotImplemented`.  Det finns inga andra underförstådda relationer "
"mellan jämförelseoperatorerna eller standardimplementeringarna; till exempel "
"innebär sanningen i ``(x<y eller x==y)`` inte ``x<=y``. För att automatiskt "
"generera ordningsoperationer från en enda rotoperation, "
"se :func:`functools.total_ordering`."

#: ../../reference/datamodel.rst:2144
msgid ""
"By default, the :class:`object` class provides implementations consistent "
"with :ref:`expressions-value-comparisons`: equality compares according to "
"object identity, and order comparisons raise :exc:`TypeError`. Each default "
"method may generate these results directly, but may also "
"return :data:`NotImplemented`."
msgstr ""
"Som standard tillhandahåller klassen :class:`object` implementeringar som "
"överensstämmer med :ref:`expressions-value-comparisons`: jämlikhet jämförs "
"enligt objektets identitet, och ordningsjämförelser ger upphov "
"till :exc:`TypeError`. Varje standardmetod kan generera dessa resultat "
"direkt, men kan också returnera :data:`NotImplemented`."

#: ../../reference/datamodel.rst:2150
msgid ""
"See the paragraph on :meth:`__hash__` for some important notes on "
"creating :term:`hashable` objects which support custom comparison operations "
"and are usable as dictionary keys."
msgstr ""
"Se stycket om :meth:`__hash__` för några viktiga anvisningar om hur du "
"skapar :term:`hashable`\\-objekt som stöder anpassade jämförelseoperationer "
"och kan användas som nycklar i ordböcker."

#: ../../reference/datamodel.rst:2154
msgid ""
"There are no swapped-argument versions of these methods (to be used when the "
"left argument does not support the operation but the right argument does); "
"rather, :meth:`__lt__` and :meth:`__gt__` are each other's "
"reflection, :meth:`__le__` and :meth:`__ge__` are each other's reflection, "
"and :meth:`__eq__` and :meth:`__ne__` are their own reflection. If the "
"operands are of different types, and the right operand's type is a direct or "
"indirect subclass of the left operand's type, the reflected method of the "
"right operand has priority, otherwise the left operand's method has "
"priority.  Virtual subclassing is not considered."
msgstr ""
"Det finns inga versioner med utbytta argument av dessa metoder (som ska "
"användas när det vänstra argumentet inte stöder operationen men det högra "
"argumentet gör det); istället är :meth:`__lt__` och :meth:`__gt__` varandras "
"reflektion, :meth:`__le__` och :meth:`__ge__` är varandras reflektion, "
"och :meth:`__eq__` och :meth:`__ne__` är deras egen reflektion. Om "
"operanderna är av olika typer och den högra operandens typ är en direkt "
"eller indirekt subklass av den vänstra operandens typ, har den reflekterade "
"metoden för den högra operanden prioritet, annars har den vänstra operandens "
"metod prioritet.  Virtuell subklassning beaktas inte."

#: ../../reference/datamodel.rst:2165
msgid ""
"When no appropriate method returns any value other "
"than :data:`NotImplemented`, the ``==`` and ``!=`` operators will fall back "
"to ``is`` and ``is not``, respectively."
msgstr ""
"När ingen lämplig metod returnerar något annat värde "
"än :data:`NotImplemented`, kommer operatorerna ``==`` och ``!=`` att falla "
"tillbaka till ``is`` respektive ``is not``."

#: ../../reference/datamodel.rst:2174
msgid ""
"Called by built-in function :func:`hash` and for operations on members of "
"hashed collections including :class:`set`, :class:`frozenset`, "
"and :class:`dict`.  The ``__hash__()`` method should return an integer. The "
"only required property is that objects which compare equal have the same "
"hash value; it is advised to mix together the hash values of the components "
"of the object that also play a part in comparison of objects by packing them "
"into a tuple and hashing the tuple. Example::"
msgstr ""
"Anropas av den inbyggda funktionen :func:`hash` och för operationer på "
"medlemmar i hashade samlingar inklusive :class:`set`, :class:`frozenset` "
"och :class:`dict`.  Metoden ``__hash__()`` bör returnera ett heltal. Den "
"enda egenskap som krävs är att objekt som jämförs lika har samma hashvärde; "
"det är lämpligt att blanda ihop hashvärdena för de komponenter i objektet "
"som också spelar en roll vid jämförelse av objekt genom att packa dem i en "
"tupel och hasha tupeln. Exempel::"

#: ../../reference/datamodel.rst:2182
msgid ""
"def __hash__(self):\n"
"    return hash((self.name, self.nick, self.color))"
msgstr ""
"def __hash__(self):\n"
"    return hash((self.name, self.nick, self.color))"

#: ../../reference/datamodel.rst:2187
msgid ""
":func:`hash` truncates the value returned from an object's "
"custom :meth:`__hash__` method to the size of a :c:type:`Py_ssize_t`.  This "
"is typically 8 bytes on 64-bit builds and 4 bytes on 32-bit builds.  If an "
"object's   :meth:`__hash__` must interoperate on builds of different bit "
"sizes, be sure to check the width on all supported builds.  An easy way to "
"do this is with ``python -c \"import sys; print(sys.hash_info.width)\"``."
msgstr ""
":func:`hash` trunkerar värdet som returneras från ett objekts "
"anpassade :meth:`__hash__`\\-metod till storleken på "
"en :c:type:`Py_ssize_t`.  Detta är vanligtvis 8 byte på 64-bitarsversioner "
"och 4 byte på 32-bitarsversioner.  Om ett objekts :meth:`__hash__` måste "
"fungera på byggsystem med olika bitstorlekar, se till att kontrollera "
"bredden på alla byggsystem som stöds.  Ett enkelt sätt att göra detta är med "
"``python -c \"import sys; print(sys.hash_info.width)\"``."

#: ../../reference/datamodel.rst:2195
msgid ""
"If a class does not define an :meth:`__eq__` method it should not define "
"a :meth:`__hash__` operation either; if it defines :meth:`__eq__` but "
"not :meth:`__hash__`, its instances will not be usable as items in hashable "
"collections.  If a class defines mutable objects and implements "
"an :meth:`__eq__` method, it should not implement :meth:`__hash__`, since "
"the implementation of :term:`hashable` collections requires that a key's "
"hash value is immutable (if the object's hash value changes, it will be in "
"the wrong hash bucket)."
msgstr ""
"Om en klass inte definierar en :meth:`__eq__`\\-metod bör den inte heller "
"definiera en :meth:`__hash__`\\-operation; om den definierar :meth:`__eq__` "
"men inte :meth:`__hash__` kommer dess instanser inte att kunna användas som "
"objekt i hashbara samlingar.  Om en klass definierar föränderliga objekt och "
"implementerar en :meth:`__eq__`\\-metod, bör den inte "
"implementera :meth:`__hash__`, eftersom implementeringen "
"av :term:`hashable`\\-samlingar kräver att en nyckels hashvärde är "
"oföränderligt (om objektets hashvärde ändras kommer det att finnas i fel "
"hashhink)."

#: ../../reference/datamodel.rst:2204
msgid ""
"User-defined classes have :meth:`__eq__` and :meth:`__hash__` methods by "
"default (inherited from the :class:`object` class); with them, all objects "
"compare unequal (except with themselves) and ``x.__hash__()`` returns an "
"appropriate value such that ``x == y`` implies both that ``x is y`` and "
"``hash(x) == hash(y)``."
msgstr ""
"Användardefinierade klasser har metoderna :meth:`__eq__` "
"och :meth:`__hash__` som standard (ärvda från klassen :class:`object`); med "
"dem jämförs alla objekt olika (utom med sig själva) och ``x.__hash__()`` "
"returnerar ett lämpligt värde så att ``x == y`` innebär både att ``x är y`` "
"och ``hash(x) == hash(y)``."

#: ../../reference/datamodel.rst:2209
msgid ""
"A class that overrides :meth:`__eq__` and does not define :meth:`__hash__` "
"will have its :meth:`__hash__` implicitly set to ``None``.  When "
"the :meth:`__hash__` method of a class is ``None``, instances of the class "
"will raise an appropriate :exc:`TypeError` when a program attempts to "
"retrieve their hash value, and will also be correctly identified as "
"unhashable when checking ``isinstance(obj, collections.abc.Hashable)``."
msgstr ""
"En klass som åsidosätter :meth:`__eq__` och inte definierar :meth:`__hash__` "
"kommer att ha sin :meth:`__hash__` implicit satt till ``None``.  När "
"metoden :meth:`__hash__` för en klass är ``None``, kommer instanser av "
"klassen att ge upphov till ett lämpligt :exc:`TypeError`` när ett program "
"försöker hämta deras hashvärde, och kommer också att identifieras korrekt "
"som unhashable när man kontrollerar ``isinstance(obj, "
"collections.abc.Hashable)``."

#: ../../reference/datamodel.rst:2216
msgid ""
"If a class that overrides :meth:`__eq__` needs to retain the implementation "
"of :meth:`__hash__` from a parent class, the interpreter must be told this "
"explicitly by setting ``__hash__ = <ParentClass>.__hash__``."
msgstr ""
"Om en klass som åsidosätter :meth:`__eq__` behöver behålla implementeringen "
"av :meth:`__hash__` från en överordnad klass, måste tolken uttryckligen få "
"veta detta genom att ange ``__hash__ = <ParentClass>.__hash__``."

#: ../../reference/datamodel.rst:2220
msgid ""
"If a class that does not override :meth:`__eq__` wishes to suppress hash "
"support, it should include ``__hash__ = None`` in the class definition. A "
"class which defines its own :meth:`__hash__` that explicitly raises "
"a :exc:`TypeError` would be incorrectly identified as hashable by an "
"``isinstance(obj, collections.abc.Hashable)`` call."
msgstr ""
"Om en klass som inte åsidosätter :meth:`__eq__` vill undertrycka hash-stöd, "
"bör den inkludera ``__hash__ = None`` i klassdefinitionen. En klass som "
"definierar sin egen :meth:`__hash__` som uttryckligen ger upphov till "
"ett :exc:`TypeError` skulle felaktigt identifieras som hashable av ett "
"``isinstance(obj, collections.abc.Hashable)``\\-anrop."

#: ../../reference/datamodel.rst:2229
msgid ""
"By default, the :meth:`__hash__` values of str and bytes objects are "
"\"salted\" with an unpredictable random value.  Although they remain "
"constant within an individual Python process, they are not predictable "
"between repeated invocations of Python."
msgstr ""
"Som standard är :meth:`__hash__`\\-värdena för str- och bytes-objekt "
"\"saltade\" med ett oförutsägbart slumpmässigt värde.  Även om de förblir "
"konstanta inom en enskild Python-process, är de inte förutsägbara mellan "
"upprepade anrop av Python."

#: ../../reference/datamodel.rst:2234
msgid ""
"This is intended to provide protection against a denial-of-service caused by "
"carefully chosen inputs that exploit the worst case performance of a dict "
"insertion, *O*\\ (*n*\\ :sup:`2`) complexity.  See http://ocert.org/"
"advisories/ocert-2011-003.html for details."
msgstr ""
"Detta är avsett att ge skydd mot en överbelastningsattack som orsakas av "
"noggrant utvalda inmatningar som utnyttjar den sämsta prestandan för en "
"diktinmatning, *O*\\ (*n*\\ :sup:`2`) komplexitet.  Se http://ocert.org/"
"advisories/ocert-2011-003.html för mer information."

#: ../../reference/datamodel.rst:2239
msgid ""
"Changing hash values affects the iteration order of sets. Python has never "
"made guarantees about this ordering (and it typically varies between 32-bit "
"and 64-bit builds)."
msgstr ""
"Om du ändrar hashvärden påverkas iterationsordningen för uppsättningar. "
"Python har aldrig gett några garantier för denna ordning (och den varierar "
"vanligtvis mellan 32-bitars och 64-bitars versioner)."

#: ../../reference/datamodel.rst:2243
msgid "See also :envvar:`PYTHONHASHSEED`."
msgstr "Se även :envvar:`PYTHONHASHSEED`."

#: ../../reference/datamodel.rst:2245
msgid "Hash randomization is enabled by default."
msgstr "Hash-randomisering är aktiverad som standard."

#: ../../reference/datamodel.rst:2253
msgid ""
"Called to implement truth value testing and the built-in operation "
"``bool()``; should return ``False`` or ``True``.  When this method is not "
"defined, :meth:`~object.__len__` is called, if it is defined, and the object "
"is considered true if its result is nonzero.  If a class defines "
"neither :meth:`!__len__` nor :meth:`!__bool__` (which is true of "
"the :class:`object` class itself), all its instances are considered true."
msgstr ""
"Anropas för att implementera sanningsvärdestestning och den inbyggda "
"operationen ``bool()``; bör returnera ``False`` eller ``True``.  När denna "
"metod inte är definierad anropas :meth:`~object.__len__`, om den är "
"definierad, och objektet anses vara sant om resultatet är ett annat än "
"noll.  Om en klass varken definierar :meth:`!__len__` eller :meth:`!"
"__bool__` (vilket gäller för själva klassen :class:`object`), anses alla "
"dess instanser vara sanna."

#: ../../reference/datamodel.rst:2264
msgid "Customizing attribute access"
msgstr "Anpassning av attributåtkomst"

#: ../../reference/datamodel.rst:2266
msgid ""
"The following methods can be defined to customize the meaning of attribute "
"access (use of, assignment to, or deletion of ``x.name``) for class "
"instances."
msgstr ""
"Följande metoder kan definieras för att anpassa betydelsen av "
"attributåtkomst (användning av, tilldelning till eller borttagning av "
"``x.name``) för klassinstanser."

#: ../../reference/datamodel.rst:2274
msgid ""
"Called when the default attribute access fails with an :exc:`AttributeError` "
"(either :meth:`__getattribute__` raises an :exc:`AttributeError` because "
"*name* is not an instance attribute or an attribute in the class tree for "
"``self``; or :meth:`__get__` of a *name* property "
"raises :exc:`AttributeError`).  This method should either return the "
"(computed) attribute value or raise an :exc:`AttributeError` exception. "
"The :class:`object` class itself does not provide this method."
msgstr ""
"Anropas när standardattributåtkomsten misslyckas med "
"ett :exc:`AttributeError` (antingen :meth:`__getattribute__` ger upphov till "
"ett :exc:`AttributeError` eftersom *namn* inte är ett instansattribut eller "
"ett attribut i klassträdet för ``self``; eller :meth:`__get__` av en *namn*-"
"egenskap ger upphov till :exc:`AttributeError`).  Denna metod bör antingen "
"returnera det (beräknade) attributvärdet eller ge upphov till "
"ett :exc:`AttributeError` undantag. Klassen :class:`object` tillhandahåller "
"inte själv denna metod."

#: ../../reference/datamodel.rst:2282
msgid ""
"Note that if the attribute is found through the normal "
"mechanism, :meth:`__getattr__` is not called.  (This is an intentional "
"asymmetry between :meth:`__getattr__` and :meth:`__setattr__`.) This is done "
"both for efficiency reasons and because otherwise :meth:`__getattr__` would "
"have no way to access other attributes of the instance.  Note that at least "
"for instance variables, you can take total control by not inserting any "
"values in the instance attribute dictionary (but instead inserting them in "
"another object).  See the :meth:`__getattribute__` method below for a way to "
"actually get total control over attribute access."
msgstr ""
"Observera att om attributet hittas genom den normala mekanismen anropas "
"inte :meth:`__getattr__`.  (Detta är en avsiktlig asymmetri "
"mellan :meth:`__getattr__` och :meth:`__setattr__`) Detta görs både av "
"effektivitetsskäl och för att :meth:`__getattr__` annars inte skulle ha "
"något sätt att komma åt andra attribut hos instansen.  Observera att "
"åtminstone för instansvariabler kan du ta total kontroll genom att inte "
"infoga några värden i instansens attributordbok (utan istället infoga dem i "
"ett annat objekt).  Se metoden :meth:`__getattribute__` nedan för ett sätt "
"att faktiskt få total kontroll över attributåtkomst."

#: ../../reference/datamodel.rst:2295
msgid ""
"Called unconditionally to implement attribute accesses for instances of the "
"class. If the class also defines :meth:`__getattr__`, the latter will not be "
"called unless :meth:`__getattribute__` either calls it explicitly or raises "
"an :exc:`AttributeError`. This method should return the (computed) attribute "
"value or raise an :exc:`AttributeError` exception. In order to avoid "
"infinite recursion in this method, its implementation should always call the "
"base class method with the same name to access any attributes it needs, for "
"example, ``object.__getattribute__(self, name)``."
msgstr ""
"Anropas ovillkorligen för att implementera attributåtkomst för instanser av "
"klassen. Om klassen också definierar :meth:`__getattr__`, kommer den senare "
"inte att anropas om inte :meth:`__getattribute__` antingen anropar den "
"explicit eller ger upphov till ett :exc:`AttributeError`. Denna metod bör "
"returnera det (beräknade) attributvärdet eller ge upphov till "
"ett :exc:`AttributeError` undantag. För att undvika oändlig rekursion i "
"denna metod bör dess implementering alltid anropa basklassens metod med "
"samma namn för att komma åt de attribut den behöver, till exempel "
"``object.__getattribute__(self, name)``."

#: ../../reference/datamodel.rst:2306
msgid ""
"This method may still be bypassed when looking up special methods as the "
"result of implicit invocation via language syntax or :ref:`built-in "
"functions <builtin-functions>`. See :ref:`special-lookup`."
msgstr ""
"Denna metod kan fortfarande förbigås när man letar upp specialmetoder som "
"ett resultat av implicit anrop via språksyntax eller :ref:`inbyggda "
"funktioner <builtin-functions>`. Se :ref::ref:`special-lookup`."

#: ../../reference/datamodel.rst:2311 ../../reference/datamodel.rst:2313
msgid ""
"For certain sensitive attribute accesses, raises an :ref:`auditing event "
"<auditing>` ``object.__getattr__`` with arguments ``obj`` and ``name``."
msgstr ""
"För vissa känsliga attributåtkomster, väcker en :ref:`auditing event "
"<auditing>` ``object.__getattr__`` med argumenten ``obj`` och ``name``."

#: ../../reference/datamodel.rst:2320
msgid ""
"Called when an attribute assignment is attempted.  This is called instead of "
"the normal mechanism (i.e. store the value in the instance dictionary). "
"*name* is the attribute name, *value* is the value to be assigned to it."
msgstr ""
"Anropas när ett försök till attributtilldelning görs.  Detta anropas i "
"stället för den normala mekanismen (dvs. lagra värdet i instansordboken). "
"*name* är attributets namn, *value* är det värde som ska tilldelas "
"attributet."

#: ../../reference/datamodel.rst:2324
msgid ""
"If :meth:`__setattr__` wants to assign to an instance attribute, it should "
"call the base class method with the same name, for example, "
"``object.__setattr__(self, name, value)``."
msgstr ""
"Om :meth:`__setattr__` vill tilldela ett instansattribut ska den anropa "
"basklassens metod med samma namn, t.ex. ``object.__setattr__(self, name, "
"value)``."

#: ../../reference/datamodel.rst:2328 ../../reference/datamodel.rst:2330
msgid ""
"For certain sensitive attribute assignments, raises an :ref:`auditing event "
"<auditing>` ``object.__setattr__`` with arguments ``obj``, ``name``, "
"``value``."
msgstr ""
"För vissa känsliga attributtilldelningar, väcker en :ref:`auditing event "
"<auditing>` ``object.__setattr__`` med argumenten ``obj``, ``name``, "
"``value``."

#: ../../reference/datamodel.rst:2337
msgid ""
"Like :meth:`__setattr__` but for attribute deletion instead of assignment.  "
"This should only be implemented if ``del obj.name`` is meaningful for the "
"object."
msgstr ""
"Som :meth:`__setattr__` men för borttagning av attribut istället för "
"tilldelning.  Detta bör endast implementeras om ``del obj.name`` är "
"meningsfullt för objektet."

#: ../../reference/datamodel.rst:2340 ../../reference/datamodel.rst:2342
msgid ""
"For certain sensitive attribute deletions, raises an :ref:`auditing event "
"<auditing>` ``object.__delattr__`` with arguments ``obj`` and ``name``."
msgstr ""
"För vissa känsliga attribut raderingar, väcker en :ref:`auditing event "
"<auditing>` ``object.__delattr__`` med argument ``obj`` och ``name``."

#: ../../reference/datamodel.rst:2349
msgid ""
"Called when :func:`dir` is called on the object. An iterable must be "
"returned. :func:`dir` converts the returned iterable to a list and sorts it."
msgstr ""
"Anropas när :func:`dir` anropas på objektet. En iterabel måste "
"returneras. :func:`dir` konverterar den returnerade iterabeln till en lista "
"och sorterar den."

#: ../../reference/datamodel.rst:2354
msgid "Customizing module attribute access"
msgstr "Anpassa åtkomst till modulattribut"

#: ../../reference/datamodel.rst:2364
msgid ""
"Special names ``__getattr__`` and ``__dir__`` can be also used to customize "
"access to module attributes. The ``__getattr__`` function at the module "
"level should accept one argument which is the name of an attribute and "
"return the computed value or raise an :exc:`AttributeError`. If an attribute "
"is not found on a module object through the normal lookup, "
"i.e. :meth:`object.__getattribute__`, then ``__getattr__`` is searched in "
"the module ``__dict__`` before raising an :exc:`AttributeError`. If found, "
"it is called with the attribute name and the result is returned."
msgstr ""
"Specialnamnen ``__getattr__`` och ``__dir__`` kan också användas för att "
"anpassa åtkomsten till modulattribut. Funktionen ``__getattr__`` på "
"modulnivå bör acceptera ett argument som är namnet på ett attribut och "
"returnera det beräknade värdet eller ge upphov till "
"ett :exc:`AttributeError`. Om ett attribut inte hittas på ett modulobjekt "
"genom den normala sökningen, dvs :meth:`object.__getattribute__`, söks "
"``__getattr__`` i modulen ``__dict__`` innan ett :exc:`AttributeError`` "
"avges. Om det hittas anropas det med attributnamnet och resultatet "
"returneras."

#: ../../reference/datamodel.rst:2373
msgid ""
"The ``__dir__`` function should accept no arguments, and return an iterable "
"of strings that represents the names accessible on module. If present, this "
"function overrides the standard :func:`dir` search on a module."
msgstr ""
"Funktionen ``__dir__`` ska inte acceptera några argument och returnera en "
"iterabel av strängar som representerar de namn som är tillgängliga i "
"modulen. Om den finns, åsidosätter den här funktionen standard :func:`dir`\\-"
"sökningen på en modul."

#: ../../reference/datamodel.rst:2379
msgid ""
"For a more fine grained customization of the module behavior (setting "
"attributes, properties, etc.), one can set the ``__class__`` attribute of a "
"module object to a subclass of :class:`types.ModuleType`. For example::"
msgstr ""
"För en mer finkornig anpassning av modulens beteende (inställning av "
"attribut, egenskaper etc.) kan man ställa in attributet ``__class__`` för "
"ett modulobjekt till en underklass av :class:`types.ModuleType`. Till "
"exempel::"

#: ../../reference/datamodel.rst:2383
msgid ""
"import sys\n"
"from types import ModuleType\n"
"\n"
"class VerboseModule(ModuleType):\n"
"    def __repr__(self):\n"
"        return f'Verbose {self.__name__}'\n"
"\n"
"    def __setattr__(self, attr, value):\n"
"        print(f'Setting {attr}...')\n"
"        super().__setattr__(attr, value)\n"
"\n"
"sys.modules[__name__].__class__ = VerboseModule"
msgstr ""
"import sys\n"
"from types import ModuleType\n"
"\n"
"class VerboseModule(ModuleType):\n"
"    def __repr__(self):\n"
"        return f'Verbose {self.__name__}'\n"
"\n"
"    def __setattr__(self, attr, value):\n"
"        print(f'Setting {attr}...')\n"
"        super().__setattr__(attr, value)\n"
"\n"
"sys.modules[__name__].__class__ = VerboseModule"

#: ../../reference/datamodel.rst:2397
msgid ""
"Defining module ``__getattr__`` and setting module ``__class__`` only affect "
"lookups made using the attribute access syntax -- directly accessing the "
"module globals (whether by code within the module, or via a reference to the "
"module's globals dictionary) is unaffected."
msgstr ""
"Att definiera modulen ``__getattr__`` och ställa in modulen ``__class__`` "
"påverkar endast uppslagningar som görs med hjälp av syntaxen för "
"attributåtkomst - direkt åtkomst till modulens globaler (oavsett om det sker "
"med kod i modulen eller via en referens till modulens globals-ordbok) "
"påverkas inte."

#: ../../reference/datamodel.rst:2402
msgid "``__class__`` module attribute is now writable."
msgstr "modulattributet ``__class__`` är nu skrivbart."

#: ../../reference/datamodel.rst:2405
msgid "``__getattr__`` and ``__dir__`` module attributes."
msgstr "modulattributen ``__getattr__`` och ``__dir__``."

#: ../../reference/datamodel.rst:2410
msgid ":pep:`562` - Module __getattr__ and __dir__"
msgstr ":pep:`562` - Modulerna __getattr__ och __dir__"

#: ../../reference/datamodel.rst:2411
msgid "Describes the ``__getattr__`` and ``__dir__`` functions on modules."
msgstr "Beskriver funktionerna ``__getattr__`` och ``__dir__`` för moduler."

#: ../../reference/datamodel.rst:2417
msgid "Implementing Descriptors"
msgstr "Implementering av deskriptorer"

#: ../../reference/datamodel.rst:2419
msgid ""
"The following methods only apply when an instance of the class containing "
"the method (a so-called *descriptor* class) appears in an *owner* class (the "
"descriptor must be in either the owner's class dictionary or in the class "
"dictionary for one of its parents).  In the examples below, \"the "
"attribute\" refers to the attribute whose name is the key of the property in "
"the owner class' :attr:`~object.__dict__`.  The :class:`object` class itself "
"does not implement any of these protocols."
msgstr ""
"Följande metoder gäller endast när en instans av den klass som innehåller "
"metoden (en så kallad *descriptor*-klass) förekommer i en *owner*-klass "
"(descriptorn måste finnas i antingen ägarens klassordbok eller i "
"klassordboken för en av dess föräldrar).  I exemplen nedan syftar "
"\"attributet\" på det attribut vars namn är nyckeln till egenskapen i "
"ägarklassens :attr:`~object.__dict__`.  Klassen :class:`object` i sig "
"implementerar inte något av dessa protokoll."

#: ../../reference/datamodel.rst:2429
msgid ""
"Called to get the attribute of the owner class (class attribute access) or "
"of an instance of that class (instance attribute access). The optional "
"*owner* argument is the owner class, while *instance* is the instance that "
"the attribute was accessed through, or ``None`` when the attribute is "
"accessed through the *owner*."
msgstr ""
"Anropas för att hämta attributet för ägarklassen (tillgång till "
"klassattribut) eller för en instans av den klassen (tillgång till "
"instansattribut). Det valfria argumentet *owner* är ägarklassen, medan "
"*instance* är den instans som attributet åtkom genom, eller ``None`` när "
"attributet åtkom genom *owner*."

#: ../../reference/datamodel.rst:2435
msgid ""
"This method should return the computed attribute value or raise "
"an :exc:`AttributeError` exception."
msgstr ""
"Denna metod bör returnera det beräknade attributvärdet eller ge upphov till "
"ett :exc:`AttributeError` undantag."

#: ../../reference/datamodel.rst:2438
msgid ""
":PEP:`252` specifies that :meth:`__get__` is callable with one or two "
"arguments.  Python's own built-in descriptors support this specification; "
"however, it is likely that some third-party tools have descriptors that "
"require both arguments.  Python's own :meth:`__getattribute__` "
"implementation always passes in both arguments whether they are required or "
"not."
msgstr ""
":PEP:`252` specificerar att :meth:`__get__` är anropsbar med ett eller två "
"argument.  Pythons egna inbyggda deskriptorer stöder denna specifikation, "
"men det är troligt att vissa tredjepartsverktyg har deskriptorer som kräver "
"båda argumenten.  Pythons egen implementation av :meth:`__getattribute__` "
"skickar alltid in båda argumenten oavsett om de krävs eller inte."

#: ../../reference/datamodel.rst:2447
msgid ""
"Called to set the attribute on an instance *instance* of the owner class to "
"a new value, *value*."
msgstr ""
"Anropas för att sätta attributet på en instans *instans* av ägarklassen till "
"ett nytt värde, *värde*."

#: ../../reference/datamodel.rst:2450
msgid ""
"Note, adding :meth:`__set__` or :meth:`__delete__` changes the kind of "
"descriptor to a \"data descriptor\".  See :ref:`descriptor-invocation` for "
"more details."
msgstr ""
"Observera att om du lägger till :meth:`__set__` eller :meth:`__delete__` "
"ändras typen av deskriptor till en \"data descriptor\".  Se :ref:`descriptor-"
"invocation` för mer information."

#: ../../reference/datamodel.rst:2456
msgid ""
"Called to delete the attribute on an instance *instance* of the owner class."
msgstr ""
"Anropas för att ta bort attributet på en instans *instans* av ägarklassen."

#: ../../reference/datamodel.rst:2458
msgid ""
"Instances of descriptors may also have the :attr:`!__objclass__` attribute "
"present:"
msgstr ""
"Instanser av deskriptorer kan också ha attributet :attr:`!__objclass__` "
"närvarande:"

#: ../../reference/datamodel.rst:2463
msgid ""
"The attribute :attr:`!__objclass__` is interpreted by the :mod:`inspect` "
"module as specifying the class where this object was defined (setting this "
"appropriately can assist in runtime introspection of dynamic class "
"attributes). For callables, it may indicate that an instance of the given "
"type (or a subclass) is expected or required as the first positional "
"argument (for example, CPython sets this attribute for unbound methods that "
"are implemented in C)."
msgstr ""
"Attributet :attr:`!__objclass__` tolkas av modulen :mod:`inspect` som att "
"det anger den klass där objektet definierades (om detta anges på rätt sätt "
"kan det underlätta introspektion av dynamiska klassattribut under körning). "
"För anropsbara objekt kan det indikera att en instans av den angivna typen "
"(eller en underklass) förväntas eller krävs som det första positionella "
"argumentet (CPython anger till exempel detta attribut för obundna metoder "
"som implementeras i C)."

#: ../../reference/datamodel.rst:2474
msgid "Invoking Descriptors"
msgstr "Anropa beskrivare"

#: ../../reference/datamodel.rst:2476
msgid ""
"In general, a descriptor is an object attribute with \"binding behavior\", "
"one whose attribute access has been overridden by methods in the descriptor "
"protocol:  :meth:`~object.__get__`, :meth:`~object.__set__`, "
"and :meth:`~object.__delete__`. If any of those methods are defined for an "
"object, it is said to be a descriptor."
msgstr ""
"I allmänhet är en descriptor ett objektattribut med \"bindningsbeteende\", "
"ett attribut vars attributåtkomst har åsidosatts av metoder i "
"descriptorprotokollet: :meth:`~object.__get__`, :meth:`~object.__set__` "
"och :meth:`~object.__delete__`. Om någon av dessa metoder är definierade för "
"ett objekt, sägs det vara en deskriptor."

#: ../../reference/datamodel.rst:2482
msgid ""
"The default behavior for attribute access is to get, set, or delete the "
"attribute from an object's dictionary. For instance, ``a.x`` has a lookup "
"chain starting with ``a.__dict__['x']``, then ``type(a).__dict__['x']``, and "
"continuing through the base classes of ``type(a)`` excluding metaclasses."
msgstr ""
"Standardbeteendet för attributåtkomst är att hämta, ställa in eller ta bort "
"attributet från ett objekts ordbok. Till exempel har ``a.x`` en "
"uppslagskedja som börjar med ``a.__dict__['x']``, sedan "
"``type(a).__dict__['x']`` och fortsätter genom basklasserna för ``type(a)`` "
"exklusive metaklasser."

#: ../../reference/datamodel.rst:2487
msgid ""
"However, if the looked-up value is an object defining one of the descriptor "
"methods, then Python may override the default behavior and invoke the "
"descriptor method instead.  Where this occurs in the precedence chain "
"depends on which descriptor methods were defined and how they were called."
msgstr ""
"Men om det sökta värdet är ett objekt som definierar en av "
"deskriptormetoderna, kan Python åsidosätta standardbeteendet och anropa "
"deskriptormetoden istället.  Var detta inträffar i prioriteringskedjan beror "
"på vilka descriptormetoder som definierades och hur de anropades."

#: ../../reference/datamodel.rst:2492
msgid ""
"The starting point for descriptor invocation is a binding, ``a.x``. How the "
"arguments are assembled depends on ``a``:"
msgstr ""
"Utgångspunkten för anrop av beskrivare är en bindning, ``a.x``. Hur "
"argumenten sammanställs beror på ``a``:"

#: ../../reference/datamodel.rst:2495
msgid "Direct Call"
msgstr "Direktsamtal"

#: ../../reference/datamodel.rst:2496
msgid ""
"The simplest and least common call is when user code directly invokes a "
"descriptor method:    ``x.__get__(a)``."
msgstr ""
"Det enklaste och minst vanliga anropet är när användarkoden direkt anropar "
"en deskriptormetod: ``x.__get__(a)``."

#: ../../reference/datamodel.rst:2499
msgid "Instance Binding"
msgstr "Bindning av instans"

#: ../../reference/datamodel.rst:2500
msgid ""
"If binding to an object instance, ``a.x`` is transformed into the call: "
"``type(a).__dict__['x'].__get__(a, type(a))``."
msgstr ""
"Om bindning sker till en objektinstans omvandlas ``a.x`` till anropet: "
"``type(a).__dict__['x'].__get__(a, type(a))``."

#: ../../reference/datamodel.rst:2503
msgid "Class Binding"
msgstr "Klassbindning"

#: ../../reference/datamodel.rst:2504
msgid ""
"If binding to a class, ``A.x`` is transformed into the call: "
"``A.__dict__['x'].__get__(None, A)``."
msgstr ""
"Om bindning sker till en klass omvandlas ``A.x`` till anropet: "
"``A.__dict__['x'].__get__(None, A)``."

#: ../../reference/datamodel.rst:2507
msgid "Super Binding"
msgstr "Super bindning"

#: ../../reference/datamodel.rst:2508
msgid ""
"A dotted lookup such as ``super(A, a).x`` searches ``a.__class__.__mro__`` "
"for a base class ``B`` following ``A`` and then returns "
"``B.__dict__['x'].__get__(a, A)``.  If not a descriptor, ``x`` is returned "
"unchanged."
msgstr ""
"En prickad uppslagning som ``super(A, a).x`` söker i ``a.__class__.__mro__`` "
"efter en basklass ``B`` efter ``A`` och returnerar sedan "
"``B.__dict__['x'].__get__(a, A)``.  Om det inte är en deskriptor returneras "
"``x`` oförändrad."

#: ../../reference/datamodel.rst:2545
msgid ""
"For instance bindings, the precedence of descriptor invocation depends on "
"which descriptor methods are defined.  A descriptor can define any "
"combination of :meth:`~object.__get__`, :meth:`~object.__set__` "
"and :meth:`~object.__delete__`.  If it does not define :meth:`!__get__`, "
"then accessing the attribute will return the descriptor object itself unless "
"there is a value in the object's instance dictionary.  If the descriptor "
"defines :meth:`!__set__` and/or :meth:`!__delete__`, it is a data "
"descriptor; if it defines neither, it is a non-data descriptor.  Normally, "
"data descriptors define both :meth:`!__get__` and :meth:`!__set__`, while "
"non-data descriptors have just the :meth:`!__get__` method.  Data "
"descriptors with :meth:`!__get__` and :meth:`!__set__` (and/or :meth:`!"
"__delete__`) defined always override a redefinition in an instance "
"dictionary.  In contrast, non-data descriptors can be overridden by "
"instances."
msgstr ""
"För instansbindningar beror företrädet för anrop av deskriptorer på vilka "
"deskriptormetoder som är definierade.  En descriptor kan definiera valfri "
"kombination av :meth:`~object.__get__`, :meth:`~object.__set__` "
"och :meth:`~object.__delete__`.  Om den inte definierar :meth:`!__get__`, "
"kommer åtkomst till attributet att returnera deskriptorobjektet självt om "
"det inte finns ett värde i objektets instansordbok.  Om deskriptorn "
"definierar :meth:`!__set__` och/eller :meth:`!__delete__` är den en "
"datadeskriptor; om den inte definierar någotdera är den en icke-"
"datadeskriptor.  Normalt definierar datadescriptorer både :meth:`!__get__` "
"och :meth:`!__set__`, medan icke-datadescriptorer bara har metoden :meth:`!"
"__get__`.  Databeskrivare med :meth:`!__get__` och :meth:`!__set__` (och/"
"eller :meth:`!__delete__`) definierade åsidosätter alltid en omdefiniering i "
"en instansordbok.  Däremot kan deskriptorer som inte är data åsidosättas av "
"instanser."

#: ../../reference/datamodel.rst:2560
msgid ""
"Python methods (including those decorated with :func:`@staticmethod "
"<staticmethod>` and :func:`@classmethod <classmethod>`) are implemented as "
"non-data descriptors.  Accordingly, instances can redefine and override "
"methods.  This allows individual instances to acquire behaviors that differ "
"from other instances of the same class."
msgstr ""
"Python-metoder (inklusive de som dekoreras med :func:`@staticmethod "
"<staticmethod>` och :func:`@classmethod <classmethod>`) implementeras som "
"icke-databeskrivare.  Följaktligen kan instanser omdefiniera och åsidosätta "
"metoder.  Detta gör att enskilda instanser kan få beteenden som skiljer sig "
"från andra instanser av samma klass."

#: ../../reference/datamodel.rst:2566
msgid ""
"The :func:`property` function is implemented as a data descriptor. "
"Accordingly, instances cannot override the behavior of a property."
msgstr ""
"Funktionen :func:`property` är implementerad som en databeskrivare. "
"Följaktligen kan instanser inte åsidosätta beteendet hos en egenskap."

#: ../../reference/datamodel.rst:2573
msgid "__slots__"
msgstr "__slots__"

#: ../../reference/datamodel.rst:2575
msgid ""
"*__slots__* allow us to explicitly declare data members (like properties) "
"and deny the creation of :attr:`~object.__dict__` and *__weakref__* (unless "
"explicitly declared in *__slots__* or available in a parent.)"
msgstr ""
"*__slots__* tillåter oss att uttryckligen deklarera datamedlemmar (som "
"egenskaper) och neka skapandet av :attr:`~object.__dict__` och *__weakref__* "
"(om inte uttryckligen deklarerat i *__slots__* eller tillgängligt i en "
"förälder.)"

#: ../../reference/datamodel.rst:2579
msgid ""
"The space saved over using :attr:`~object.__dict__` can be significant. "
"Attribute lookup speed can be significantly improved as well."
msgstr ""
"Det utrymme som sparas jämfört med att använda :attr:`~object.__dict__` kan "
"vara betydande. Hastigheten för attributuppslagning kan också förbättras "
"avsevärt."

#: ../../reference/datamodel.rst:2584
msgid ""
"This class variable can be assigned a string, iterable, or sequence of "
"strings with variable names used by instances.  *__slots__* reserves space "
"for the declared variables and prevents the automatic creation "
"of :attr:`~object.__dict__` and *__weakref__* for each instance."
msgstr ""
"Denna klassvariabel kan tilldelas en sträng, en iterabel eller en sekvens av "
"strängar med variabelnamn som används av instanser.  *__slots__* reserverar "
"utrymme för de deklarerade variablerna och förhindrar automatiskt skapande "
"av :attr:`~object.__dict__` och *__weakref__* för varje instans."

#: ../../reference/datamodel.rst:2593
msgid "Notes on using *__slots__*:"
msgstr "Anvisningar för användning av *__slots__*:"

#: ../../reference/datamodel.rst:2595
msgid ""
"When inheriting from a class without *__slots__*, "
"the :attr:`~object.__dict__` and *__weakref__* attribute of the instances "
"will always be accessible."
msgstr ""
"När du ärver från en klass utan *__slots__* kommer "
"attributen :attr:`~object.__dict__` och *__weakref__* för instanserna alltid "
"att vara tillgängliga."

#: ../../reference/datamodel.rst:2599
msgid ""
"Without a :attr:`~object.__dict__` variable, instances cannot be assigned "
"new variables not listed in the *__slots__* definition.  Attempts to assign "
"to an unlisted variable name raises :exc:`AttributeError`. If dynamic "
"assignment of new variables is desired, then add ``'__dict__'`` to the "
"sequence of strings in the *__slots__* declaration."
msgstr ""
"Utan variabeln :attr:`~object.__dict__` kan instanser inte tilldelas nya "
"variabler som inte listas i *__slots__*-definitionen.  Försök att tilldela "
"ett olistat variabelnamn ger upphov till :exc:`AttributeError`. Om dynamisk "
"tilldelning av nya variabler önskas, lägg då till ``'__dict__'`` till "
"sekvensen av strängar i *__slots__*-deklarationen."

#: ../../reference/datamodel.rst:2606
msgid ""
"Without a *__weakref__* variable for each instance, classes defining "
"*__slots__* do not support :mod:`weak references <weakref>` to its "
"instances. If weak reference support is needed, then add ``'__weakref__'`` "
"to the sequence of strings in the *__slots__* declaration."
msgstr ""
"Utan en *__weakref__*\\-variabel för varje instans stöder klasser som "
"definierar *__slots__* inte :mod:`svaga referenser <weakref>` till sina "
"instanser. Om stöd för svaga referenser behövs, lägg till ``'__weakref__'`` "
"till sekvensen av strängar i *__slots__*\\-deklarationen."

#: ../../reference/datamodel.rst:2612
msgid ""
"*__slots__* are implemented at the class level by creating :ref:`descriptors "
"<descriptors>` for each variable name.  As a result, class attributes cannot "
"be used to set default values for instance variables defined by *__slots__*; "
"otherwise, the class attribute would overwrite the descriptor assignment."
msgstr ""
"*__slots__* implementeras på klassnivå genom att skapa :ref:`deskriptorer "
"<descriptors>` för varje variabelnamn.  Därför kan klassattribut inte "
"användas för att ange standardvärden för instansvariabler som definieras av "
"*__slots__*; i annat fall skulle klassattributet skriva över "
"deskriptortilldelningen."

#: ../../reference/datamodel.rst:2618
msgid ""
"The action of a *__slots__* declaration is not limited to the class where it "
"is defined.  *__slots__* declared in parents are available in child classes. "
"However, instances of a child subclass will get a :attr:`~object.__dict__` "
"and *__weakref__* unless the subclass also defines *__slots__* (which should "
"only contain names of any *additional* slots)."
msgstr ""
"Verkan av en *__slots__*-deklaration är inte begränsad till den klass där "
"den är definierad.  *__slots__* som deklareras i föräldraklasser är "
"tillgängliga i underordnade klasser. Instanser av en underordnad underklass "
"kommer dock att få en :attr:`~object.__dict__` och *__weakref__* om inte "
"underklassen också definierar *__slots__* (som bara bör innehålla namn på "
"eventuella *ytterligare* slots)."

#: ../../reference/datamodel.rst:2624
msgid ""
"If a class defines a slot also defined in a base class, the instance "
"variable defined by the base class slot is inaccessible (except by "
"retrieving its descriptor directly from the base class). This renders the "
"meaning of the program undefined.  In the future, a check may be added to "
"prevent this."
msgstr ""
"Om en klass definierar en slot som också definieras i en basklass, är den "
"instansvariabel som definieras av basklassens slot otillgänglig (utom genom "
"att hämta dess deskriptor direkt från basklassen). Detta gör programmets "
"innebörd odefinierad.  I framtiden kan en kontroll läggas till för att "
"förhindra detta."

#: ../../reference/datamodel.rst:2629
msgid ""
":exc:`TypeError` will be raised if nonempty *__slots__* are defined for a "
"class derived from a :c:member:`\"variable-length\" built-in type "
"<PyTypeObject.tp_itemsize>` such as :class:`int`, :class:`bytes`, "
"and :class:`tuple`."
msgstr ""
":exc:`TypeError` kommer att uppstå om icke-tomma *__slots__* definieras för "
"en klass som härrör från en :c:member:`\"variabel-längd\" inbyggd typ "
"<PyTypeObject.tp_itemsize>` såsom :class:`int`, :class:`bytes` "
"och :class:`tuple`."

#: ../../reference/datamodel.rst:2634
msgid "Any non-string :term:`iterable` may be assigned to *__slots__*."
msgstr "Alla icke-strängformade :term:`iterable` kan tilldelas *__slots__*."

#: ../../reference/datamodel.rst:2636
msgid ""
"If a :class:`dictionary <dict>` is used to assign *__slots__*, the "
"dictionary keys will be used as the slot names. The values of the dictionary "
"can be used to provide per-attribute docstrings that will be recognised "
"by :func:`inspect.getdoc` and displayed in the output of :func:`help`."
msgstr ""
"Om en :class:`dictionary <dict>` används för att tilldela *__slots__*, "
"kommer nycklarna i ordlistan att användas som slotnamn. Värdena i ordlistan "
"kan användas för att tillhandahålla dokumentsträngar per attribut som kommer "
"att identifieras av :func:`inspect.getdoc` och visas i utdata "
"från :func:`help`."

#: ../../reference/datamodel.rst:2641
msgid ""
":attr:`~object.__class__` assignment works only if both classes have the "
"same *__slots__*."
msgstr ""
":attr:`~object.__class__` fungerar endast om båda klasserna har samma "
"*__slots__*."

#: ../../reference/datamodel.rst:2644
msgid ""
":ref:`Multiple inheritance <tut-multiple>` with multiple slotted parent "
"classes can be used, but only one parent is allowed to have attributes "
"created by slots (the other bases must have empty slot layouts) - violations "
"raise :exc:`TypeError`."
msgstr ""
":ref:`Multiple inheritance <tut-multiple>` med flera slotted föräldraklasser "
"kan användas, men endast en förälder får ha attribut som skapats av slots "
"(de andra baserna måste ha tomma slot layouter) - överträdelser ger upphov "
"till :exc:`TypeError`."

#: ../../reference/datamodel.rst:2650
msgid ""
"If an :term:`iterator` is used for *__slots__* then a :term:`descriptor` is "
"created for each of the iterator's values. However, the *__slots__* "
"attribute will be an empty iterator."
msgstr ""
"Om en :term:`iterator` används för *__slots__* skapas en :term:`descriptor` "
"för vart och ett av iteratorns värden. Attributet *__slots__* kommer dock "
"att vara en tom iterator."

#: ../../reference/datamodel.rst:2658
msgid "Customizing class creation"
msgstr "Anpassa skapandet av klasser"

#: ../../reference/datamodel.rst:2660
msgid ""
"Whenever a class inherits from another "
"class, :meth:`~object.__init_subclass__` is called on the parent class. This "
"way, it is possible to write classes which change the behavior of "
"subclasses. This is closely related to class decorators, but where class "
"decorators only affect the specific class they're applied to, "
"``__init_subclass__`` solely applies to future subclasses of the class "
"defining the method."
msgstr ""
"När en klass ärver från en annan klass "
"anropas :meth:`~object.__init_subclass__` på moderklassen. På så sätt är det "
"möjligt att skriva klasser som ändrar beteendet hos underklasser. Detta är "
"nära besläktat med klassdekoratorer, men där klassdekoratorer endast "
"påverkar den specifika klass som de tillämpas på, gäller "
"``__init_subclass__`` endast framtida subklasser av den klass som definierar "
"metoden."

#: ../../reference/datamodel.rst:2669
msgid ""
"This method is called whenever the containing class is subclassed. *cls* is "
"then the new subclass. If defined as a normal instance method, this method "
"is implicitly converted to a class method."
msgstr ""
"Denna metod anropas när den innehållande klassen underklassas. *cls* är då "
"den nya subklassen. Om den definieras som en normal instansmetod konverteras "
"denna metod implicit till en klassmetod."

#: ../../reference/datamodel.rst:2673
msgid ""
"Keyword arguments which are given to a new class are passed to the parent "
"class's ``__init_subclass__``. For compatibility with other classes using "
"``__init_subclass__``, one should take out the needed keyword arguments and "
"pass the others over to the base class, as in::"
msgstr ""
"Nyckelordsargument som ges till en ny klass skickas till moderklassens "
"``__init_subclass__``. För kompatibilitet med andra klasser som använder "
"``__init_subclass__``, bör man ta ut de nyckelordsargument som behövs och "
"skicka de andra till basklassen, som i::"

#: ../../reference/datamodel.rst:2679
msgid ""
"class Philosopher:\n"
"    def __init_subclass__(cls, /, default_name, **kwargs):\n"
"        super().__init_subclass__(**kwargs)\n"
"        cls.default_name = default_name\n"
"\n"
"class AustralianPhilosopher(Philosopher, default_name=\"Bruce\"):\n"
"    pass"
msgstr ""
"class Philosopher:\n"
"    def __init_subclass__(cls, /, default_name, **kwargs):\n"
"        super().__init_subclass__(**kwargs)\n"
"        cls.default_name = default_name\n"
"\n"
"class AustralianPhilosopher(Philosopher, default_name=\"Bruce\"):\n"
"    pass"

#: ../../reference/datamodel.rst:2687
msgid ""
"The default implementation ``object.__init_subclass__`` does nothing, but "
"raises an error if it is called with any arguments."
msgstr ""
"Standardimplementeringen ``object.__init_subclass__`` gör ingenting, men ger "
"upphov till ett fel om den anropas med några argument."

#: ../../reference/datamodel.rst:2692
msgid ""
"The metaclass hint ``metaclass`` is consumed by the rest of the type "
"machinery, and is never passed to ``__init_subclass__`` implementations. The "
"actual metaclass (rather than the explicit hint) can be accessed as "
"``type(cls)``."
msgstr ""
"Metaklasstipset ``metaclass`` används av resten av typmaskineriet och "
"skickas aldrig till implementationer av ``__init_subclass__``. Den faktiska "
"metaklassen (snarare än den explicita ledtråden) kan nås som ``type(cls)``."

#: ../../reference/datamodel.rst:2700
msgid ""
"When a class is created, :meth:`!type.__new__` scans the class variables and "
"makes callbacks to those with a :meth:`~object.__set_name__` hook."
msgstr ""

#: ../../reference/datamodel.rst:2705
msgid ""
"Automatically called at the time the owning class *owner* is created. The "
"object has been assigned to *name* in that class::"
msgstr ""
"Anropas automatiskt när den ägande klassen *owner* skapas. Objektet har "
"tilldelats *namn* i den klassen::"

#: ../../reference/datamodel.rst:2708
msgid ""
"class A:\n"
"    x = C()  # Automatically calls: x.__set_name__(A, 'x')"
msgstr ""
"class A:\n"
"    x = C()  # Anropar automatiskt: x.__set_name__(A, 'x')"

#: ../../reference/datamodel.rst:2711
msgid ""
"If the class variable is assigned after the class is "
"created, :meth:`__set_name__` will not be called automatically. If "
"needed, :meth:`__set_name__` can be called directly::"
msgstr ""
"Om klassvariabeln tilldelas efter att klassen har skapats, "
"kommer :meth:`__set_name__` inte att anropas automatiskt. Om det behövs "
"kan :meth:`__set_name__` anropas direkt::"

#: ../../reference/datamodel.rst:2715
msgid ""
"class A:\n"
"   pass\n"
"\n"
"c = C()\n"
"A.x = c                  # The hook is not called\n"
"c.__set_name__(A, 'x')   # Manually invoke the hook"
msgstr ""
"class A:\n"
"   pass\n"
"\n"
"c = C()\n"
"A.x = c                  # The hook is not called\n"
"c.__set_name__(A, 'x')   # Manually invoke the hook"

#: ../../reference/datamodel.rst:2722
msgid "See :ref:`class-object-creation` for more details."
msgstr "Se :ref:`class-object-creation` för mer information."

#: ../../reference/datamodel.rst:2730
msgid "Metaclasses"
msgstr "Metaklasser"

#: ../../reference/datamodel.rst:2737
msgid ""
"By default, classes are constructed using :func:`type`. The class body is "
"executed in a new namespace and the class name is bound locally to the "
"result of ``type(name, bases, namespace)``."
msgstr ""
"Som standard konstrueras klasser med hjälp av :func:`type`. Klassens kropp "
"exekveras i ett nytt namnrymd och klassnamnet binds lokalt till resultatet "
"av ``type(name, bases, namespace)``."

#: ../../reference/datamodel.rst:2741
msgid ""
"The class creation process can be customized by passing the ``metaclass`` "
"keyword argument in the class definition line, or by inheriting from an "
"existing class that included such an argument. In the following example, "
"both ``MyClass`` and ``MySubclass`` are instances of ``Meta``::"
msgstr ""
"Processen för att skapa klasser kan anpassas genom att skicka "
"nyckelordsargumentet ``metaclass`` i klassdefinitionsraden, eller genom att "
"ärva från en befintlig klass som innehåller ett sådant argument. I följande "
"exempel är både ``MyClass`` och ``MySubclass`` instanser av ``Meta``::"

#: ../../reference/datamodel.rst:2746
msgid ""
"class Meta(type):\n"
"    pass\n"
"\n"
"class MyClass(metaclass=Meta):\n"
"    pass\n"
"\n"
"class MySubclass(MyClass):\n"
"    pass"
msgstr ""
"class Meta(type):\n"
"    pass\n"
"\n"
"class MyClass(metaclass=Meta):\n"
"    pass\n"
"\n"
"class MySubclass(MyClass):\n"
"    pass"

#: ../../reference/datamodel.rst:2755
msgid ""
"Any other keyword arguments that are specified in the class definition are "
"passed through to all metaclass operations described below."
msgstr ""
"Alla andra nyckelordsargument som anges i klassdefinitionen skickas vidare "
"till alla metaklassoperationer som beskrivs nedan."

#: ../../reference/datamodel.rst:2758
msgid "When a class definition is executed, the following steps occur:"
msgstr "När en klassdefinition exekveras sker följande steg:"

#: ../../reference/datamodel.rst:2760
msgid "MRO entries are resolved;"
msgstr "MRO-posterna är åtgärdade;"

#: ../../reference/datamodel.rst:2761
msgid "the appropriate metaclass is determined;"
msgstr "bestäms vilken metaklass som är lämplig;"

#: ../../reference/datamodel.rst:2762
msgid "the class namespace is prepared;"
msgstr "klassnamnrymden är förberedd;"

#: ../../reference/datamodel.rst:2763
msgid "the class body is executed;"
msgstr "klassens kropp exekveras;"

#: ../../reference/datamodel.rst:2764
msgid "the class object is created."
msgstr "skapas klassobjektet."

#: ../../reference/datamodel.rst:2768
msgid "Resolving MRO entries"
msgstr "Lösning av MRO-poster"

#: ../../reference/datamodel.rst:2772
msgid ""
"If a base that appears in a class definition is not an instance "
"of :class:`type`, then an :meth:`!__mro_entries__` method is searched on the "
"base. If an :meth:`!__mro_entries__` method is found, the base is "
"substituted with the result of a call to :meth:`!__mro_entries__` when "
"creating the class. The method is called with the original bases tuple "
"passed to the *bases* parameter, and must return a tuple of classes that "
"will be used instead of the base. The returned tuple may be empty: in these "
"cases, the original base is ignored."
msgstr ""
"Om en bas som förekommer i en klassdefinition inte är en instans "
"av :class:`type`, söks en :meth:`!__mro_entries__`\\-metod på basen. Om "
"en :meth:`!__mro_entries__`\\-metod hittas ersätts basen med resultatet av "
"ett anrop till :meth:`!__mro_entries__` när klassen skapades. Metoden "
"anropas med den ursprungliga tupeln av baser som skickas till parametern "
"*bases* och måste returnera en tupel av klasser som ska användas i stället "
"för basen. Den returnerade tupeln kan vara tom: i dessa fall ignoreras den "
"ursprungliga basen."

#: ../../reference/datamodel.rst:2783
msgid ":func:`types.resolve_bases`"
msgstr ":func:`types.resolve_bases`"

#: ../../reference/datamodel.rst:2784
msgid "Dynamically resolve bases that are not instances of :class:`type`."
msgstr "Dynamisk upplösning av baser som inte är instanser av :class:`type`."

#: ../../reference/datamodel.rst:2786
msgid ":func:`types.get_original_bases`"
msgstr ":func:`types.get_original_bases`"

#: ../../reference/datamodel.rst:2787
msgid ""
"Retrieve a class's \"original bases\" prior to modifications "
"by :meth:`~object.__mro_entries__`."
msgstr ""
"Hämta en klass \"ursprungliga baser\" före modifieringar "
"med :meth:`~object.__mro_entries__`."

#: ../../reference/datamodel.rst:2790
msgid ":pep:`560`"
msgstr ":pep:`560`"

#: ../../reference/datamodel.rst:2791
msgid "Core support for typing module and generic types."
msgstr "Kärnstöd för typningsmodul och generiska typer."

#: ../../reference/datamodel.rst:2795
msgid "Determining the appropriate metaclass"
msgstr "Fastställande av lämplig metaklass"

#: ../../reference/datamodel.rst:2799
msgid ""
"The appropriate metaclass for a class definition is determined as follows:"
msgstr ""
"Vilken metaklass som är lämplig för en klassdefinition bestäms på följande "
"sätt:"

#: ../../reference/datamodel.rst:2801
msgid ""
"if no bases and no explicit metaclass are given, then :func:`type` is used;"
msgstr ""
"om inga baser och ingen explicit metaklass anges, används :func:`type`;"

#: ../../reference/datamodel.rst:2802
msgid ""
"if an explicit metaclass is given and it is *not* an instance "
"of :func:`type`, then it is used directly as the metaclass;"
msgstr ""
"om en explicit metaklass anges och den *inte* är en instans av :func:`type`, "
"så används den direkt som metaklass;"

#: ../../reference/datamodel.rst:2804
msgid ""
"if an instance of :func:`type` is given as the explicit metaclass, or bases "
"are defined, then the most derived metaclass is used."
msgstr ""
"om en instans av :func:`type` anges som explicit metaklass, eller om baser "
"har definierats, används den mest härledda metaklassen."

#: ../../reference/datamodel.rst:2807
msgid ""
"The most derived metaclass is selected from the explicitly specified "
"metaclass (if any) and the metaclasses (i.e. ``type(cls)``) of all specified "
"base classes. The most derived metaclass is one which is a subtype of *all* "
"of these candidate metaclasses. If none of the candidate metaclasses meets "
"that criterion, then the class definition will fail with ``TypeError``."
msgstr ""
"Den mest härledda metaklassen väljs från den explicit angivna metaklassen "
"(om någon) och metaklasserna (dvs. ``type(cls)``) för alla angivna "
"basklasser. Den mest härledda metaklassen är en metaklass som är en subtyp "
"av *alla* dessa kandidatmetaklasser. Om ingen av kandidatmetaklasserna "
"uppfyller detta kriterium kommer klassdefinitionen att misslyckas med "
"``TypeError``."

#: ../../reference/datamodel.rst:2817
msgid "Preparing the class namespace"
msgstr "Förbereda klassens namnrymd"

#: ../../reference/datamodel.rst:2822
msgid ""
"Once the appropriate metaclass has been identified, then the class namespace "
"is prepared. If the metaclass has a ``__prepare__`` attribute, it is called "
"as ``namespace = metaclass.__prepare__(name, bases, **kwds)`` (where the "
"additional keyword arguments, if any, come from the class definition). The "
"``__prepare__`` method should be implemented as a :func:`classmethod "
"<classmethod>`. The namespace returned by ``__prepare__`` is passed in to "
"``__new__``, but when the final class object is created the namespace is "
"copied into a new ``dict``."
msgstr ""
"När rätt metaklass har identifierats förbereds klassens namnrymd. Om "
"metaklassen har ett attribut ``__prepare__``, anropas det som ``namespace = "
"metaclass.__prepare__(name, bases, **kwds)`` (där eventuella ytterligare "
"nyckelordsargument kommer från klassdefinitionen). Metoden ``__prepare__`` "
"bör implementeras som en :func:`classmethod <classmethod>`. Namnrymden som "
"returneras av ``__prepare__`` skickas till ``__new__``, men när det slutliga "
"klassobjektet skapas kopieras namnrymden till en ny ``dict``."

#: ../../reference/datamodel.rst:2831
msgid ""
"If the metaclass has no ``__prepare__`` attribute, then the class namespace "
"is initialised as an empty ordered mapping."
msgstr ""
"Om metaklassen inte har något ``__prepare__``\\-attribut initieras "
"klassnamnrymden som en tom ordnad mappning."

#: ../../reference/datamodel.rst:2836
msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ":pep:`3115` - Metaklasser i Python 3000"

#: ../../reference/datamodel.rst:2837
msgid "Introduced the ``__prepare__`` namespace hook"
msgstr "Införde namnrymdshaken ``__prepare__``"

#: ../../reference/datamodel.rst:2841
msgid "Executing the class body"
msgstr "Exekvering av klassens kropp"

#: ../../reference/datamodel.rst:2846
msgid ""
"The class body is executed (approximately) as ``exec(body, globals(), "
"namespace)``. The key difference from a normal call to :func:`exec` is that "
"lexical scoping allows the class body (including any methods) to reference "
"names from the current and outer scopes when the class definition occurs "
"inside a function."
msgstr ""
"Klassens kropp exekveras (ungefär) som ``exec(body, globals(), namespace)``. "
"Den viktigaste skillnaden mot ett normalt anrop till :func:`exec` är att "
"lexical scoping gör att klassens kropp (inklusive alla metoder) kan referera "
"till namn från det aktuella och det yttre scopet när klassdefinitionen finns "
"inuti en funktion."

#: ../../reference/datamodel.rst:2852
msgid ""
"However, even when the class definition occurs inside the function, methods "
"defined inside the class still cannot see names defined at the class scope. "
"Class variables must be accessed through the first parameter of instance or "
"class methods, or through the implicit lexically scoped ``__class__`` "
"reference described in the next section."
msgstr ""
"Men även om klassdefinitionen finns i funktionen kan metoder som definieras "
"i klassen fortfarande inte se namn som definieras i klassens scope. "
"Klassvariabler måste nås via den första parametern i instans- eller "
"klassmetoder, eller via den implicita lexikaliskt scopade ``__class__``\\-"
"referensen som beskrivs i nästa avsnitt."

#: ../../reference/datamodel.rst:2861
msgid "Creating the class object"
msgstr "Skapa klassobjektet"

#: ../../reference/datamodel.rst:2868
msgid ""
"Once the class namespace has been populated by executing the class body, the "
"class object is created by calling ``metaclass(name, bases, namespace, "
"**kwds)`` (the additional keywords passed here are the same as those passed "
"to ``__prepare__``)."
msgstr ""
"När klassens namnrymd har fyllts genom att exekvera klassens kropp, skapas "
"klassobjektet genom att anropa ``metaclass(name, bases, namespace, **kwds)`` "
"(de ytterligare nyckelord som skickas här är desamma som de som skickas till "
"``__prepare__``)."

#: ../../reference/datamodel.rst:2873
msgid ""
"This class object is the one that will be referenced by the zero-argument "
"form of :func:`super`. ``__class__`` is an implicit closure reference "
"created by the compiler if any methods in a class body refer to either "
"``__class__`` or ``super``. This allows the zero argument form "
"of :func:`super` to correctly identify the class being defined based on "
"lexical scoping, while the class or instance that was used to make the "
"current call is identified based on the first argument passed to the method."
msgstr ""
"Detta klassobjekt är det som kommer att refereras till av nollargumentformen "
"av :func:`super`. ``__class__`` är en implicit stängningsreferens som skapas "
"av kompilatorn om några metoder i en klass kropp refererar till antingen "
"``__class__`` eller ``super``. Detta gör att nollargumentformen "
"av :func:`super` korrekt identifierar den klass som definieras baserat på "
"lexikal scoping, medan den klass eller instans som användes för att göra det "
"aktuella anropet identifieras baserat på det första argumentet som skickas "
"till metoden."

#: ../../reference/datamodel.rst:2883
msgid ""
"In CPython 3.6 and later, the ``__class__`` cell is passed to the metaclass "
"as a ``__classcell__`` entry in the class namespace. If present, this must "
"be propagated up to the ``type.__new__`` call in order for the class to be "
"initialised correctly. Failing to do so will result in a :exc:`RuntimeError` "
"in Python 3.8."
msgstr ""
"I CPython 3.6 och senare skickas cellen ``__class__`` till metaklassen som "
"en ``__classcell__``\\-post i klassnamnrymden. Om den finns måste den "
"spridas upp till ``type.__new__``\\-anropet för att klassen ska "
"initialiseras korrekt. Om detta inte görs resulterar det i "
"ett :exc:`RuntimeError` i Python 3.8."

#: ../../reference/datamodel.rst:2889
msgid ""
"When using the default metaclass :class:`type`, or any metaclass that "
"ultimately calls ``type.__new__``, the following additional customization "
"steps are invoked after creating the class object:"
msgstr ""
"När du använder standardmetaklassen :class:`type`, eller en metaklass som i "
"slutändan anropar ``type.__new__``, anropas följande ytterligare "
"anpassningssteg efter att klassobjektet har skapats:"

#: ../../reference/datamodel.rst:2893
msgid ""
"The ``type.__new__`` method collects all of the attributes in the class "
"namespace that define a :meth:`~object.__set_name__` method;"
msgstr ""
"Metoden ``type.__new__`` samlar in alla attribut i klassens namnrymd som "
"definierar en :meth:`~object.__set_name__`\\-metod;"

#: ../../reference/datamodel.rst:2895
msgid ""
"Those ``__set_name__`` methods are called with the class being defined and "
"the assigned name of that particular attribute;"
msgstr ""
"Dessa ``__set_name__``\\-metoder anropas med den klass som definieras och "
"det tilldelade namnet på det specifika attributet;"

#: ../../reference/datamodel.rst:2897
msgid ""
"The :meth:`~object.__init_subclass__` hook is called on the immediate parent "
"of the new class in its method resolution order."
msgstr ""
"Hooken :meth:`~object.__init_subclass__` anropas på den nya klassens "
"omedelbara förälder i dess metodresolutionsordning."

#: ../../reference/datamodel.rst:2900
msgid ""
"After the class object is created, it is passed to the class decorators "
"included in the class definition (if any) and the resulting object is bound "
"in the local namespace as the defined class."
msgstr ""
"När klassobjektet har skapats skickas det till de klassdekoratorer som ingår "
"i klassdefinitionen (om sådana finns) och det resulterande objektet binds i "
"det lokala namnrymden som den definierade klassen."

#: ../../reference/datamodel.rst:2904
msgid ""
"When a new class is created by ``type.__new__``, the object provided as the "
"namespace parameter is copied to a new ordered mapping and the original "
"object is discarded. The new copy is wrapped in a read-only proxy, which "
"becomes the :attr:`~type.__dict__` attribute of the class object."
msgstr ""
"När en ny klass skapas med ``type.__new__`` kopieras det objekt som anges "
"som namnrymdsparameter till en ny ordnad mappning och originalobjektet "
"kasseras. Den nya kopian förpackas i en skrivskyddad proxy, som blir "
"attributet :attr:`~type.__dict__` för klassobjektet."

#: ../../reference/datamodel.rst:2911
msgid ":pep:`3135` - New super"
msgstr ":pep:`3135` - Ny super"

#: ../../reference/datamodel.rst:2912
msgid "Describes the implicit ``__class__`` closure reference"
msgstr "Beskriver den implicita ``__class__`` stängningsreferensen"

#: ../../reference/datamodel.rst:2916
msgid "Uses for metaclasses"
msgstr "Användningsområden för metaklasser"

#: ../../reference/datamodel.rst:2918
msgid ""
"The potential uses for metaclasses are boundless. Some ideas that have been "
"explored include enum, logging, interface checking, automatic delegation, "
"automatic property creation, proxies, frameworks, and automatic resource "
"locking/synchronization."
msgstr ""
"De potentiella användningsområdena för metaklasser är gränslösa. Några idéer "
"som har utforskats är enum, loggning, gränssnittskontroll, automatisk "
"delegering, automatiskt skapande av egenskaper, proxies, ramverk och "
"automatisk resurslåsning/synkronisering."

#: ../../reference/datamodel.rst:2925
msgid "Customizing instance and subclass checks"
msgstr "Anpassa kontroller av instanser och underklasser"

#: ../../reference/datamodel.rst:2927
msgid ""
"The following methods are used to override the default behavior of "
"the :func:`isinstance` and :func:`issubclass` built-in functions."
msgstr ""
"Följande metoder används för att åsidosätta standardbeteendet för de "
"inbyggda funktionerna :func:`isinstance` och :func:`issubclass`."

#: ../../reference/datamodel.rst:2930
msgid ""
"In particular, the metaclass :class:`abc.ABCMeta` implements these methods "
"in order to allow the addition of Abstract Base Classes (ABCs) as \"virtual "
"base classes\" to any class or type (including built-in types), including "
"other ABCs."
msgstr ""
"I synnerhet metaklassen :class:`abc.ABCMeta` implementerar dessa metoder för "
"att göra det möjligt att lägga till abstrakta basklasser (ABC) som "
"\"virtuella basklasser\" till vilken klass eller typ som helst (inklusive "
"inbyggda typer), inklusive andra ABC."

#: ../../reference/datamodel.rst:2937
msgid ""
"Return true if *instance* should be considered a (direct or indirect) "
"instance of *class*. If defined, called to implement ``isinstance(instance, "
"class)``."
msgstr ""
"Returnerar true om *instance* ska betraktas som en (direkt eller indirekt) "
"instans av *class*. Om definierad, anropas för att implementera "
"``isinstance(instance, class)``."

#: ../../reference/datamodel.rst:2944
msgid ""
"Return true if *subclass* should be considered a (direct or indirect) "
"subclass of *class*.  If defined, called to implement ``issubclass(subclass, "
"class)``."
msgstr ""
"Returnerar true om *subclass* ska betraktas som en (direkt eller indirekt) "
"underklass till *class*.  Om definierad, anropas för att implementera "
"``issubclass(subclass, class)``."

#: ../../reference/datamodel.rst:2949
msgid ""
"Note that these methods are looked up on the type (metaclass) of a class.  "
"They cannot be defined as class methods in the actual class.  This is "
"consistent with the lookup of special methods that are called on instances, "
"only in this case the instance is itself a class."
msgstr ""
"Observera att dessa metoder söks upp i typen (metaklassen) för en klass.  De "
"kan inte definieras som klassmetoder i den faktiska klassen.  Detta "
"överensstämmer med uppslagningen av specialmetoder som anropas på instanser, "
"men i det här fallet är instansen själv en klass."

#: ../../reference/datamodel.rst:2956
msgid ":pep:`3119` - Introducing Abstract Base Classes"
msgstr ":pep:`3119` - Introduktion av abstrakta basklasser"

#: ../../reference/datamodel.rst:2957
msgid ""
"Includes the specification for customizing :func:`isinstance` "
"and :func:`issubclass` behavior through :meth:`~type.__instancecheck__` "
"and :meth:`~type.__subclasscheck__`, with motivation for this functionality "
"in the context of adding Abstract Base Classes (see the :mod:`abc` module) "
"to the language."
msgstr ""
"Innehåller specifikationen för anpassning av :func:`isinstance` "
"och :func:`issubclass` beteende genom :meth:`~type.__instancecheck__` "
"och :meth:`~type.__subclasscheck__`, med motivering för denna funktionalitet "
"i samband med tillägg av abstrakta basklasser (se modulen :mod:`abc`) till "
"språket."

#: ../../reference/datamodel.rst:2965
msgid "Emulating generic types"
msgstr "Emulering av generiska typer"

#: ../../reference/datamodel.rst:2967
msgid ""
"When using :term:`type annotations<annotation>`, it is often useful to "
"*parameterize* a :term:`generic type` using Python's square-brackets "
"notation. For example, the annotation ``list[int]`` might be used to signify "
"a :class:`list` in which all the elements are of type :class:`int`."
msgstr ""
"När man använder :term:`type annotations<annotation>`, är det ofta "
"användbart att *parametrisera* en :term:`generic type` med Pythons "
"hakparentesnotation. Till exempel kan annoteringen ``list[int]`` användas "
"för att beteckna en :class:`list` där alla element är av typen :class:`int`."

#: ../../reference/datamodel.rst:2974
msgid ":pep:`484` - Type Hints"
msgstr ":pep:`484` - Tips om typ"

#: ../../reference/datamodel.rst:2975
msgid "Introducing Python's framework for type annotations"
msgstr "Introduktion till Pythons ramverk för typannoteringar"

#: ../../reference/datamodel.rst:2977
msgid ":ref:`Generic Alias Types<types-genericalias>`"
msgstr ":ref:`Generiska alias-typer<types-genericalias>`"

#: ../../reference/datamodel.rst:2978
msgid "Documentation for objects representing parameterized generic classes"
msgstr ""
"Dokumentation för objekt som representerar parametriserade generiska klasser"

#: ../../reference/datamodel.rst:2980
msgid ""
":ref:`Generics`, :ref:`user-defined generics<user-defined-generics>` "
"and :class:`typing.Generic`"
msgstr ""
":ref:`Generics`, :ref:`användardefinierad generik<user-defined-generics>` "
"och :class:`typing.Generic`"

#: ../../reference/datamodel.rst:2981
msgid ""
"Documentation on how to implement generic classes that can be parameterized "
"at runtime and understood by static type-checkers."
msgstr ""
"Dokumentation om hur man implementerar generiska klasser som kan "
"parametriseras vid körning och förstås av statiska typkontrollanter."

#: ../../reference/datamodel.rst:2984
msgid ""
"A class can *generally* only be parameterized if it defines the special "
"class method ``__class_getitem__()``."
msgstr ""
"En klass kan *generellt* endast parametriseras om den definierar den "
"speciella klassmetoden ``__class_getitem__()``."

#: ../../reference/datamodel.rst:2989
msgid ""
"Return an object representing the specialization of a generic class by type "
"arguments found in *key*."
msgstr ""
"Returnerar ett objekt som representerar specialiseringen av en generisk "
"klass med typargument som finns i *key*."

#: ../../reference/datamodel.rst:2992
msgid ""
"When defined on a class, ``__class_getitem__()`` is automatically a class "
"method. As such, there is no need for it to be decorated "
"with :func:`@classmethod<classmethod>` when it is defined."
msgstr ""
"När den definieras för en klass är ``__class_getitem__()`` automatiskt en "
"klassmetod. Som sådan behöver den inte dekoreras "
"med :func:`@classmethod<classmethod>` när den definieras."

#: ../../reference/datamodel.rst:2998
msgid "The purpose of *__class_getitem__*"
msgstr "Syftet med *__class_getitem__*"

#: ../../reference/datamodel.rst:3000
msgid ""
"The purpose of :meth:`~object.__class_getitem__` is to allow runtime "
"parameterization of standard-library generic classes in order to more easily "
"apply :term:`type hints<type hint>` to these classes."
msgstr ""
"Syftet med :meth:`~object.__class_getitem__` är att tillåta runtime-"
"parametrisering av generiska klasser i standardbibliotek för att lättare "
"kunna tillämpa :term:`type hints<type hint>` på dessa klasser."

#: ../../reference/datamodel.rst:3004
msgid ""
"To implement custom generic classes that can be parameterized at runtime and "
"understood by static type-checkers, users should either inherit from a "
"standard library class that already "
"implements :meth:`~object.__class_getitem__`, or inherit "
"from :class:`typing.Generic`, which has its own implementation of "
"``__class_getitem__()``."
msgstr ""
"För att implementera anpassade generiska klasser som kan parametriseras vid "
"körning och förstås av statiska typkontrollanter, bör användare antingen "
"ärva från en standardbiblioteksklass som redan "
"implementerar :meth:`~object.__class_getitem__`, eller ärva "
"från :class:`typing.Generic`, som har sin egen implementering av "
"``__class_getitem__()``."

#: ../../reference/datamodel.rst:3010
msgid ""
"Custom implementations of :meth:`~object.__class_getitem__` on classes "
"defined outside of the standard library may not be understood by third-party "
"type-checkers such as mypy. Using ``__class_getitem__()`` on any class for "
"purposes other than type hinting is discouraged."
msgstr ""
"Anpassade implementeringar av :meth:`~object.__class_getitem__` på klasser "
"som definieras utanför standardbiblioteket kanske inte förstås av "
"typkontrollprogram från tredje part, t.ex. mypy. Att använda "
"``__class_getitem__()`` på någon klass för andra syften än typhinting är "
"avrådande."

#: ../../reference/datamodel.rst:3020
msgid "*__class_getitem__* versus *__getitem__*"
msgstr "*__class_getitem__* kontra *__getitem__*"

#: ../../reference/datamodel.rst:3022
msgid ""
"Usually, the :ref:`subscription<subscriptions>` of an object using square "
"brackets will call the :meth:`~object.__getitem__` instance method defined "
"on the object's class. However, if the object being subscribed is itself a "
"class, the class method :meth:`~object.__class_getitem__` may be called "
"instead. ``__class_getitem__()`` should return a :ref:`GenericAlias<types-"
"genericalias>` object if it is properly defined."
msgstr ""
"Vanligtvis anropar :ref:`subscription<subscriptions>` för ett objekt med "
"hakparenteser :meth:`~object.__getitem__`\\-instansmetoden som definieras i "
"objektets klass. Men om objektet som prenumereras i sig är en klass, kan "
"klassmetoden :meth:`~object.__class_getitem__` anropas istället. "
"``__class_getitem__()`` bör returnera ett :ref:`GenericAlias<types-"
"genericalias>` objekt om det är korrekt definierat."

#: ../../reference/datamodel.rst:3029
msgid ""
"Presented with the :term:`expression` ``obj[x]``, the Python interpreter "
"follows something like the following process to decide "
"whether :meth:`~object.__getitem__` or :meth:`~object.__class_getitem__` "
"should be called::"
msgstr ""
"När :term:`expression` ``obj[x]`` presenteras, följer Python-tolken ungefär "
"följande process för att avgöra om :meth:`~object.__getitem__` "
"eller :meth:`~object.__class_getitem__` ska anropas::"

#: ../../reference/datamodel.rst:3034
msgid ""
"from inspect import isclass\n"
"\n"
"def subscribe(obj, x):\n"
"    \"\"\"Return the result of the expression 'obj[x]'\"\"\"\n"
"\n"
"    class_of_obj = type(obj)\n"
"\n"
"    # If the class of obj defines __getitem__,\n"
"    # call class_of_obj.__getitem__(obj, x)\n"
"    if hasattr(class_of_obj, '__getitem__'):\n"
"        return class_of_obj.__getitem__(obj, x)\n"
"\n"
"    # Else, if obj is a class and defines __class_getitem__,\n"
"    # call obj.__class_getitem__(x)\n"
"    elif isclass(obj) and hasattr(obj, '__class_getitem__'):\n"
"        return obj.__class_getitem__(x)\n"
"\n"
"    # Else, raise an exception\n"
"    else:\n"
"        raise TypeError(\n"
"            f\"'{class_of_obj.__name__}' object is not subscriptable\"\n"
"        )"
msgstr ""
"from inspect import isclass\n"
"\n"
"def subscribe(obj, x):\n"
"    \"\"\"Return the result of the expression 'obj[x]'\"\"\"\n"
"\n"
"    class_of_obj = type(obj)\n"
"\n"
"    # If the class of obj defines __getitem__,\n"
"    # call class_of_obj.__getitem__(obj, x)\n"
"    if hasattr(class_of_obj, '__getitem__'):\n"
"        return class_of_obj.__getitem__(obj, x)\n"
"\n"
"    # Else, if obj is a class and defines __class_getitem__,\n"
"    # call obj.__class_getitem__(x)\n"
"    elif isclass(obj) and hasattr(obj, '__class_getitem__'):\n"
"        return obj.__class_getitem__(x)\n"
"\n"
"    # Else, raise an exception\n"
"    else:\n"
"        raise TypeError(\n"
"            f\"'{class_of_obj.__name__}' object is not subscriptable\"\n"
"        )"

#: ../../reference/datamodel.rst:3057
msgid ""
"In Python, all classes are themselves instances of other classes. The class "
"of a class is known as that class's :term:`metaclass`, and most classes have "
"the :class:`type` class as their metaclass. :class:`type` does not "
"define :meth:`~object.__getitem__`, meaning that expressions such as "
"``list[int]``, ``dict[str, float]`` and ``tuple[str, bytes]`` all result "
"in :meth:`~object.__class_getitem__` being called::"
msgstr ""
"I Python är alla klasser själva instanser av andra klasser. Klassen för en "
"klass är känd som klassens :term:`metaklass`, och de flesta klasser har "
"klassen :class:`type` som sin metaklass. :class:`type` definierar "
"inte :meth:`~object.__getitem__`, vilket innebär att uttryck som "
"``list[int]``, ``dict[str, float]`` och ``tuple[str, bytes]`` alla "
"resulterar i att :meth:`~object.__class_getitem__` anropas::"

#: ../../reference/datamodel.rst:3064
msgid ""
">>> # list has class \"type\" as its metaclass, like most classes:\n"
">>> type(list)\n"
"<class 'type'>\n"
">>> type(dict) == type(list) == type(tuple) == type(str) == type(bytes)\n"
"True\n"
">>> # \"list[int]\" calls \"list.__class_getitem__(int)\"\n"
">>> list[int]\n"
"list[int]\n"
">>> # list.__class_getitem__ returns a GenericAlias object:\n"
">>> type(list[int])\n"
"<class 'types.GenericAlias'>"
msgstr ""
">>> # list has class \"type\" as its metaclass, like most classes:\n"
">>> type(list)\n"
"<class 'type'>\n"
">>> type(dict) == type(list) == type(tuple) == type(str) == type(bytes)\n"
"True\n"
">>> # \"list[int]\" calls \"list.__class_getitem__(int)\"\n"
">>> list[int]\n"
"list[int]\n"
">>> # list.__class_getitem__ returns a GenericAlias object:\n"
">>> type(list[int])\n"
"<class 'types.GenericAlias'>"

#: ../../reference/datamodel.rst:3076
msgid ""
"However, if a class has a custom metaclass that "
"defines :meth:`~object.__getitem__`, subscribing the class may result in "
"different behaviour. An example of this can be found in the :mod:`enum` "
"module::"
msgstr ""
"Men om en klass har en egen metaklass som "
"definierar :meth:`~object.__getitem__`, kan en prenumeration av klassen "
"resultera i ett annat beteende. Ett exempel på detta finns i "
"modulen :mod:`enum`::"

#: ../../reference/datamodel.rst:3080
msgid ""
">>> from enum import Enum\n"
">>> class Menu(Enum):\n"
"...     \"\"\"A breakfast menu\"\"\"\n"
"...     SPAM = 'spam'\n"
"...     BACON = 'bacon'\n"
"...\n"
">>> # Enum classes have a custom metaclass:\n"
">>> type(Menu)\n"
"<class 'enum.EnumMeta'>\n"
">>> # EnumMeta defines __getitem__,\n"
">>> # so __class_getitem__ is not called,\n"
">>> # and the result is not a GenericAlias object:\n"
">>> Menu['SPAM']\n"
"<Menu.SPAM: 'spam'>\n"
">>> type(Menu['SPAM'])\n"
"<enum 'Menu'>"
msgstr ""
">>> from enum import Enum\n"
">>> class Menu(Enum):\n"
"...     \"\"\"A breakfast menu\"\"\"\n"
"...     SPAM = 'spam'\n"
"...     BACON = 'bacon'\n"
"...\n"
">>> # Enum classes have a custom metaclass:\n"
">>> type(Menu)\n"
"<class 'enum.EnumMeta'>\n"
">>> # EnumMeta defines __getitem__,\n"
">>> # so __class_getitem__ is not called,\n"
">>> # and the result is not a GenericAlias object:\n"
">>> Menu['SPAM']\n"
"<Menu.SPAM: 'spam'>\n"
">>> type(Menu['SPAM'])\n"
"<enum 'Menu'>"

#: ../../reference/datamodel.rst:3099
msgid ":pep:`560` - Core Support for typing module and generic types"
msgstr ":pep:`560` - Kärnstöd för typning av moduler och generiska typer"

#: ../../reference/datamodel.rst:3100
msgid ""
"Introducing :meth:`~object.__class_getitem__`, and outlining when "
"a :ref:`subscription<subscriptions>` results in ``__class_getitem__()`` "
"being called instead of :meth:`~object.__getitem__`"
msgstr ""
"Introducerar :meth:`~object.__class_getitem__`, och beskriver när "
"en :ref:`subscription<subscriptions>` resulterar i att "
"``__class_getitem__()`` anropas istället för :meth:`~object.__getitem__`"

#: ../../reference/datamodel.rst:3108
msgid "Emulating callable objects"
msgstr "Emulering av anropsbara objekt"

#: ../../reference/datamodel.rst:3115
msgid ""
"Called when the instance is \"called\" as a function; if this method is "
"defined, ``x(arg1, arg2, ...)`` roughly translates to ``type(x).__call__(x, "
"arg1, ...)``. The :class:`object` class itself does not provide this method."
msgstr ""
"Anropas när instansen \"anropas\" som en funktion; om denna metod är "
"definierad översätts ``x(arg1, arg2, ...)`` ungefär till "
"``type(x).__call__(x, arg1, ...)``. Klassen :class:`object` tillhandahåller "
"inte själv denna metod."

#: ../../reference/datamodel.rst:3123
msgid "Emulating container types"
msgstr "Emulering av containertyper"

#: ../../reference/datamodel.rst:3125
msgid ""
"The following methods can be defined to implement container objects. None of "
"them are provided by the :class:`object` class itself. Containers usually "
"are :term:`sequences <sequence>` (such as :class:`lists <list>` "
"or :class:`tuples <tuple>`) or :term:`mappings <mapping>` "
"(like :term:`dictionaries <dictionary>`), but can represent other containers "
"as well.  The first set of methods is used either to emulate a sequence or "
"to emulate a mapping; the difference is that for a sequence, the allowable "
"keys should be the integers *k* for which ``0 <= k < N`` where *N* is the "
"length of the sequence, or :class:`slice` objects, which define a range of "
"items.  It is also recommended that mappings provide the methods :meth:`!"
"keys`, :meth:`!values`, :meth:`!items`, :meth:`!get`, :meth:`!"
"clear`, :meth:`!setdefault`, :meth:`!pop`, :meth:`!popitem`, :meth:`!copy`, "
"and :meth:`!update` behaving similar to those for Python's "
"standard :class:`dictionary <dict>` objects.  The :mod:`collections.abc` "
"module provides a :class:`~collections.abc.MutableMapping` :term:`abstract "
"base class` to help create those methods from a base set "
"of :meth:`~object.__getitem__`, :meth:`~object.__setitem__`, :meth:`~object.__delitem__`, "
"and :meth:`!keys`."
msgstr ""

#: ../../reference/datamodel.rst:3144
msgid ""
"Mutable sequences should provide "
"methods :meth:`~sequence.append`, :meth:`~sequence.clear`, :meth:`~sequence.count`, :meth:`~sequence.extend`, :meth:`~sequence.index`, :meth:`~sequence.insert`, :meth:`~sequence.pop`, :meth:`~sequence.remove`, "
"and :meth:`~sequence.reverse`, like Python standard :class:`list` objects. "
"Finally, sequence types should implement addition (meaning concatenation) "
"and multiplication (meaning repetition) by defining the "
"methods :meth:`~object.__add__`, :meth:`~object.__radd__`, :meth:`~object.__iadd__`, :meth:`~object.__mul__`, :meth:`~object.__rmul__` "
"and :meth:`~object.__imul__` described below; they should not define other "
"numerical operators."
msgstr ""

#: ../../reference/datamodel.rst:3156
msgid ""
"It is recommended that both mappings and sequences implement "
"the :meth:`~object.__contains__` method to allow efficient use of the ``in`` "
"operator; for mappings, ``in`` should search the mapping's keys; for "
"sequences, it should search through the values.  It is further recommended "
"that both mappings and sequences implement the :meth:`~object.__iter__` "
"method to allow efficient iteration through the container; for "
"mappings, :meth:`!__iter__` should iterate through the object's keys; for "
"sequences, it should iterate through the values."
msgstr ""

#: ../../reference/datamodel.rst:3171
msgid ""
"Called to implement the built-in function :func:`len`.  Should return the "
"length of the object, an integer ``>=`` 0.  Also, an object that doesn't "
"define a :meth:`~object.__bool__` method and whose :meth:`!__len__` method "
"returns zero is considered to be false in a Boolean context."
msgstr ""
"Anropas för att implementera den inbyggda funktionen :func:`len`.  Bör "
"returnera objektets längd, ett heltal ``>=`` 0. Dessutom anses ett objekt "
"som inte definierar en :meth:`~object.__bool__`\\-metod och vars :meth:`!"
"__len__`\\-metod returnerar noll vara falskt i en boolesk kontext."

#: ../../reference/datamodel.rst:3178
msgid ""
"In CPython, the length is required to be at most :data:`sys.maxsize`. If the "
"length is larger than :data:`!sys.maxsize` some features (such "
"as :func:`len`) may raise :exc:`OverflowError`.  To prevent raising :exc:`!"
"OverflowError` by truth value testing, an object must define "
"a :meth:`~object.__bool__` method."
msgstr ""
"I CPython krävs det att längden är högst :data:`sys.maxsize`. Om längden är "
"större än :data:`!sys.maxsize` kan vissa funktioner (t.ex. :func:`len`) ge "
"upphov till :exc:`OverflowError`.  För att förhindra att :exc:`!"
"OverflowError` uppstår genom sanningsvärdestestning måste ett objekt "
"definiera en :meth:`~object.__bool__`\\-metod."

#: ../../reference/datamodel.rst:3187
msgid ""
"Called to implement :func:`operator.length_hint`. Should return an estimated "
"length for the object (which may be greater or less than the actual length). "
"The length must be an integer ``>=`` 0. The return value may also "
"be :data:`NotImplemented`, which is treated the same as if the "
"``__length_hint__`` method didn't exist at all. This method is purely an "
"optimization and is never required for correctness."
msgstr ""
"Anropas för att implementera :func:`operator.length_hint`. Bör returnera en "
"uppskattad längd för objektet (som kan vara större eller mindre än den "
"faktiska längden). Längden måste vara ett heltal ``>=`` 0. Returvärdet kan "
"också vara :data:`NotImplemented`, vilket behandlas på samma sätt som om "
"metoden ``__length_hint__`` inte existerade alls. Denna metod är enbart en "
"optimering och krävs aldrig för korrekthet."

#: ../../reference/datamodel.rst:3201
msgid ""
"Slicing is done exclusively with the following three methods.  A call like ::"
msgstr "Slicing görs uteslutande med följande tre metoder.  Ett anrop som ::"

#: ../../reference/datamodel.rst:3203
msgid "a[1:2] = b"
msgstr "a[1:2] = b"

#: ../../reference/datamodel.rst:3205
msgid "is translated to ::"
msgstr "är översatt till ::"

#: ../../reference/datamodel.rst:3207
msgid "a[slice(1, 2, None)] = b"
msgstr "a[slice(1, 2, None)] = b"

#: ../../reference/datamodel.rst:3209
msgid "and so forth.  Missing slice items are always filled in with ``None``."
msgstr "och så vidare.  Saknade slice-objekt fylls alltid i med ``None``."

#: ../../reference/datamodel.rst:3214
msgid ""
"Called to implement evaluation of ``self[key]``. For :term:`sequence` types, "
"the accepted keys should be integers. Optionally, they may "
"support :class:`slice` objects as well.  Negative index support is also "
"optional. If *key* is of an inappropriate type, :exc:`TypeError` may be "
"raised; if *key* is a value outside the set of indexes for the sequence "
"(after any special interpretation of negative values), :exc:`IndexError` "
"should be raised. For :term:`mapping` types, if *key* is missing (not in the "
"container), :exc:`KeyError` should be raised."
msgstr ""
"Anropas för att implementera utvärdering av ``self[key]``. "
"För :term:`sequence`\\-typer bör de accepterade nycklarna vara heltal. "
"Eventuellt kan de även stödja :class:`slice`\\-objekt.  Stöd för negativa "
"index är också valfritt. Om *key* är av en olämplig typ kan :exc:`TypeError` "
"visas; om *key* är ett värde som ligger utanför uppsättningen index för "
"sekvensen (efter eventuell speciell tolkning av negativa värden) "
"bör :exc:`IndexError` visas. För :term:`mapping`\\-typer, om *key* saknas "
"(inte i behållaren), bör :exc:`KeyError` anges."

#: ../../reference/datamodel.rst:3226
msgid ""
":keyword:`for` loops expect that an :exc:`IndexError` will be raised for "
"illegal indexes to allow proper detection of the end of the sequence."
msgstr ""
":keyword:`for` loopar förväntar sig att ett :exc:`IndexError` kommer att "
"uppstå för olagliga index för att möjliggöra korrekt upptäckt av slutet av "
"sekvensen."

#: ../../reference/datamodel.rst:3231
msgid ""
"When :ref:`subscripting<subscriptions>` a *class*, the special class "
"method :meth:`~object.__class_getitem__` may be called instead of "
"``__getitem__()``. See :ref:`classgetitem-versus-getitem` for more details."
msgstr ""
"När :ref:`subscripting<subscriptions>` en *klass*, kan den speciella "
"klassmetoden :meth:`~object.__class_getitem__` anropas istället för "
"``__getitem__()``. Se :ref:`classgetitem-versus-getitem` för mer information."

#: ../../reference/datamodel.rst:3239
msgid ""
"Called to implement assignment to ``self[key]``.  Same note as "
"for :meth:`__getitem__`.  This should only be implemented for mappings if "
"the objects support changes to the values for keys, or if new keys can be "
"added, or for sequences if elements can be replaced.  The same exceptions "
"should be raised for improper *key* values as for the :meth:`__getitem__` "
"method."
msgstr ""
"Anropas för att implementera tilldelning till ``self[key]``.  Samma "
"anmärkning som för :meth:`__getitem__`.  Detta bör endast implementeras för "
"mappningar om objekten stöder ändringar av värden för nycklar, eller om nya "
"nycklar kan läggas till, eller för sekvenser om element kan ersättas.  Samma "
"undantag bör göras för felaktiga *nyckel*-värden som för "
"metoden :meth:`__getitem__`."

#: ../../reference/datamodel.rst:3248
msgid ""
"Called to implement deletion of ``self[key]``.  Same note as "
"for :meth:`__getitem__`.  This should only be implemented for mappings if "
"the objects support removal of keys, or for sequences if elements can be "
"removed from the sequence.  The same exceptions should be raised for "
"improper *key* values as for the :meth:`__getitem__` method."
msgstr ""
"Anropas för att implementera borttagning av ``self[key]``.  Samma anmärkning "
"som för :meth:`__getitem__`.  Detta bör endast implementeras för mappningar "
"om objekten stöder borttagning av nycklar, eller för sekvenser om element "
"kan tas bort från sekvensen.  Samma undantag bör göras för felaktiga *key*-"
"värden som för metoden :meth:`__getitem__`."

#: ../../reference/datamodel.rst:3257
msgid ""
"Called by :class:`dict`\\ .\\ :meth:`__getitem__` to implement ``self[key]`` "
"for dict subclasses when key is not in the dictionary."
msgstr ""
"Anropas av :class:`dict` .\\ :meth:`__getitem__` för att implementera "
"``self[key]`` för dict-subklasser när key inte finns i ordlistan."

#: ../../reference/datamodel.rst:3263
msgid ""
"This method is called when an :term:`iterator` is required for a container. "
"This method should return a new iterator object that can iterate over all "
"the objects in the container.  For mappings, it should iterate over the keys "
"of the container."
msgstr ""
"Denna metod anropas när en :term:`iterator` krävs för en container. Denna "
"metod bör returnera ett nytt iteratorobjekt som kan iterera över alla objekt "
"i containern.  För mappningar bör den iterera över nycklarna i behållaren."

#: ../../reference/datamodel.rst:3271
msgid ""
"Called (if present) by the :func:`reversed` built-in to implement reverse "
"iteration.  It should return a new iterator object that iterates over all "
"the objects in the container in reverse order."
msgstr ""
"Anropas (om det finns) av den inbyggda :func:`reversed` för att implementera "
"omvänd iteration.  Det bör returnera ett nytt iteratorobjekt som itererar "
"över alla objekt i behållaren i omvänd ordning."

#: ../../reference/datamodel.rst:3275
msgid ""
"If the :meth:`__reversed__` method is not provided, the :func:`reversed` "
"built-in will fall back to using the sequence protocol (:meth:`__len__` "
"and :meth:`__getitem__`).  Objects that support the sequence protocol should "
"only provide :meth:`__reversed__` if they can provide an implementation that "
"is more efficient than the one provided by :func:`reversed`."
msgstr ""
"Om metoden :meth:`__reversed__` inte tillhandahålls kommer den "
"inbyggda :func:`reversed` att falla tillbaka till att använda "
"sekvensprotokollet (:meth:`__len__` och :meth:`__getitem__`).  Objekt som "
"stöder sekvensprotokollet bör endast tillhandahålla :meth:`__reversed__` om "
"de kan tillhandahålla en implementering som är mer effektiv än den som "
"tillhandahålls av :func:`reversed`."

#: ../../reference/datamodel.rst:3282
msgid ""
"The membership test operators (:keyword:`in` and :keyword:`not in`) are "
"normally implemented as an iteration through a container. However, container "
"objects can supply the following special method with a more efficient "
"implementation, which also does not require the object be iterable."
msgstr ""
"Operatorerna för medlemskapstest (:keyword:`in` och :keyword:`not in`) "
"implementeras normalt som en iteration genom en behållare. Containerobjekt "
"kan dock förse följande specialmetod med en mer effektiv implementering, som "
"inte heller kräver att objektet är itererbart."

#: ../../reference/datamodel.rst:3289
msgid ""
"Called to implement membership test operators.  Should return true if *item* "
"is in *self*, false otherwise.  For mapping objects, this should consider "
"the keys of the mapping rather than the values or the key-item pairs."
msgstr ""
"Anropas för att implementera operatorer för medlemskapstest.  Bör returnera "
"true om *item* finns i *self*, false annars.  För mappningsobjekt bör detta "
"beakta nycklarna i mappningen snarare än värdena eller paren nyckel-objekt."

#: ../../reference/datamodel.rst:3293
msgid ""
"For objects that don't define :meth:`__contains__`, the membership test "
"first tries iteration via :meth:`__iter__`, then the old sequence iteration "
"protocol via :meth:`__getitem__`, see :ref:`this section in the language "
"reference <membership-test-details>`."
msgstr ""
"För objekt som inte definierar :meth:`__contains__` försöker "
"medlemskapstestet först iteration via :meth:`__iter__`, sedan det gamla "
"sekvensiterationsprotokollet via :meth:`__getitem__`, se :ref:`det här "
"avsnittet i språkreferensen <membership-test-details>`."

#: ../../reference/datamodel.rst:3302
msgid "Emulating numeric types"
msgstr "Emulering av numeriska typer"

#: ../../reference/datamodel.rst:3304
msgid ""
"The following methods can be defined to emulate numeric objects. Methods "
"corresponding to operations that are not supported by the particular kind of "
"number implemented (e.g., bitwise operations for non-integral numbers) "
"should be left undefined."
msgstr ""
"Följande metoder kan definieras för att emulera numeriska objekt. Metoder "
"som motsvarar operationer som inte stöds av den särskilda typ av tal som "
"implementeras (t.ex. bitvisa operationer för icke-integrala tal) bör lämnas "
"odefinierade."

#: ../../reference/datamodel.rst:3330
msgid ""
"These methods are called to implement the binary arithmetic operations "
"(``+``, ``-``, ``*``, ``@``, ``/``, ``//``, "
"``%``, :func:`divmod`, :func:`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|"
"``).  For instance, to evaluate the expression ``x + y``, where *x* is an "
"instance of a class that has an :meth:`__add__` method, ``type(x).__add__(x, "
"y)`` is called.  The :meth:`__divmod__` method should be the equivalent to "
"using :meth:`__floordiv__` and :meth:`__mod__`; it should not be related "
"to :meth:`__truediv__`.  Note that :meth:`__pow__` should be defined to "
"accept an optional third argument if the three-argument version of the built-"
"in :func:`pow` function is to be supported."
msgstr ""
"Dessa metoder anropas för att implementera binära aritmetiska operationer "
"(``+``, ``\\-``, ``*``, ``@``, ``/``, ``//``, "
"``%``, :func:`divmod`, :func:`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|"
"``).  För att t.ex. utvärdera uttrycket ``x + y``, där *x* är en instans av "
"en klass som har en :meth:`__add__`\\-metod, anropas ``type(x).__add__(x, "
"y)``.  Metoden :meth:`__divmod__` bör vara likvärdig med att "
"använda :meth:`__floordiv__` och :meth:`__mod__`; den bör inte vara "
"relaterad till :meth:`__truediv__`.  Observera att :meth:`__pow__` bör "
"definieras så att den accepterar ett valfritt tredje argument om "
"treargumentversionen av den inbyggda funktionen :func:`pow` skall stödjas."

#: ../../reference/datamodel.rst:3341
msgid ""
"If one of those methods does not support the operation with the supplied "
"arguments, it should return :data:`NotImplemented`."
msgstr ""
"Om en av dessa metoder inte stöder operationen med de angivna argumenten, "
"bör den returnera :data:`NotImplemented`."

#: ../../reference/datamodel.rst:3364
msgid ""
"These methods are called to implement the binary arithmetic operations "
"(``+``, ``-``, ``*``, ``@``, ``/``, ``//``, "
"``%``, :func:`divmod`, :func:`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|"
"``) with reflected (swapped) operands.  These functions are only called if "
"the operands are of different types, when the left operand does not support "
"the corresponding operation [#]_, or the right operand's class is derived "
"from the left operand's class. [#]_ For instance, to evaluate the expression "
"``x - y``, where *y* is an instance of a class that has an :meth:`__rsub__` "
"method, ``type(y).__rsub__(y, x)`` is called if ``type(x).__sub__(x, y)`` "
"returns :data:`NotImplemented` or ``type(y)`` is a subclass of ``type(x)``. "
"[#]_"
msgstr ""
"Dessa metoder anropas för att implementera binära aritmetiska operationer "
"(``+``, ``\\-``, ``*``, ``@``, ``/``, ``//``, "
"``%``, :func:`divmod`, :func:`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|"
"``) med reflekterade (swappade) operander.  Dessa funktioner anropas endast "
"om operanderna är av olika typer, om den vänstra operanden inte stöder "
"motsvarande operation [#]_ eller om den högra operandens klass är härledd "
"från den vänstra operandens klass. [#]_ Till exempel, för att utvärdera "
"uttrycket ``x - y``, där *y* är en instans av en klass som har "
"en :meth:`__rsub__` metod, anropas ``type(y).__rsub__(y, x)`` om "
"``type(x).__sub__(x, y)`` returnerar :data:`NotImplemented` eller "
"``type(y)`` är en subklass av ``type(x)``. [#]_"

#: ../../reference/datamodel.rst:3375
msgid ""
"Note that :meth:`__rpow__` should be defined to accept an optional third "
"argument if the three-argument version of the built-in :func:`pow` function "
"is to be supported."
msgstr ""
"Observera att :meth:`__rpow__` bör definieras så att den accepterar ett "
"valfritt tredje argument om treargumentversionen av den "
"inbyggda :func:`pow`\\-funktionen skall stödjas."

#: ../../reference/datamodel.rst:3381
msgid ""
"Three-argument :func:`pow` now try calling :meth:`~object.__rpow__` if "
"necessary. Previously it was only called in two-argument :func:`!pow` and "
"the binary power operator."
msgstr ""
"Tre-argument :func:`pow` försöker nu anropa :meth:`~object.__rpow__` om det "
"behövs. Tidigare anropades det bara i två-argument :func:`!pow` och den "
"binära potensoperatorn."

#: ../../reference/datamodel.rst:3387
msgid ""
"If the right operand's type is a subclass of the left operand's type and "
"that subclass provides a different implementation of the reflected method "
"for the operation, this method will be called before the left operand's non-"
"reflected method. This behavior allows subclasses to override their "
"ancestors' operations."
msgstr ""
"Om den högra operandens typ är en subklass av den vänstra operandens typ och "
"denna subklass tillhandahåller en annan implementering av den reflekterade "
"metoden för operationen, kommer denna metod att anropas före den vänstra "
"operandens icke-reflekterade metod. Detta beteende gör det möjligt för "
"subklasser att åsidosätta sina förfäders operationer."

#: ../../reference/datamodel.rst:3407
msgid ""
"These methods are called to implement the augmented arithmetic assignments "
"(``+=``, ``-=``, ``*=``, ``@=``, ``/=``, ``//=``, ``%=``, ``**=``, ``<<=``, "
"``>>=``, ``&=``, ``^=``, ``|=``).  These methods should attempt to do the "
"operation in-place (modifying *self*) and return the result (which could be, "
"but does not have to be, *self*).  If a specific method is not defined, or "
"if that method returns :data:`NotImplemented`, the augmented assignment "
"falls back to the normal methods.  For instance, if *x* is an instance of a "
"class with an :meth:`__iadd__` method, ``x += y`` is equivalent to ``x = "
"x.__iadd__(y)`` . If :meth:`__iadd__` does not exist, or if "
"``x.__iadd__(y)`` returns :data:`!NotImplemented`, ``x.__add__(y)`` and "
"``y.__radd__(x)`` are considered, as with the evaluation of ``x + y``. In "
"certain situations, augmented assignment can result in unexpected errors "
"(see :ref:`faq-augmented-assignment-tuple-error`), but this behavior is in "
"fact part of the data model."
msgstr ""
"Dessa metoder anropas för att implementera de utökade aritmetiska "
"tilldelningarna (``+=``, ``\\-=``, ``*=``, ``@=``, ``/=``, ``//=``, ``%=``, "
"``**=``, ``<<=``, ``>>=``, ``&=``, ``^=``, ``|=``).  Dessa metoder bör "
"försöka utföra operationen på plats (modifiera *self*) och returnera "
"resultatet (som kan vara, men inte behöver vara, *self*).  Om en specifik "
"metod inte är definierad, eller om metoden "
"returnerar :data:`NotImplemented`, faller det utökade uppdraget tillbaka på "
"de normala metoderna.  Om till exempel *x* är en instans av en klass med "
"en :meth:`__iadd__-metod, är ``x += y`` ekvivalent med ``x = "
"x.__iadd__(y)`` . Om :meth:`__iadd__` inte finns, eller om ``x.__iadd__(y)`` "
"returnerar :data:`!NotImplemented`, beaktas ``x.__add__(y)`` och "
"``y.__radd__(x)``, precis som vid utvärderingen av ``x + y``. I vissa "
"situationer kan augmented assignment resultera i oväntade fel (se :ref:`faq-"
"augmented-assignment-tuple-error`), men detta beteende är i själva verket en "
"del av datamodellen."

#: ../../reference/datamodel.rst:3430
msgid ""
"Called to implement the unary arithmetic operations (``-``, "
"``+``, :func:`abs` and ``~``)."
msgstr ""
"Anropas för att implementera de unära aritmetiska operationerna (``\\-``, "
"``+``, :func:`abs` och ``~``)."

#: ../../reference/datamodel.rst:3443
msgid ""
"Called to implement the built-in functions :func:`complex`, :func:`int` "
"and :func:`float`.  Should return a value of the appropriate type."
msgstr ""
"Anropas för att implementera de inbyggda "
"funktionerna :func:`complex`, :func:`int` och :func:`float`.  Bör returnera "
"ett värde av lämplig typ."

#: ../../reference/datamodel.rst:3450
msgid ""
"Called to implement :func:`operator.index`, and whenever Python needs to "
"losslessly convert the numeric object to an integer object (such as in "
"slicing, or in the built-in :func:`bin`, :func:`hex` and :func:`oct` "
"functions). Presence of this method indicates that the numeric object is an "
"integer type.  Must return an integer."
msgstr ""
"Anropas för att implementera :func:`operator.index`, och när Python behöver "
"konvertera det numeriska objektet till ett heltalsobjekt (t.ex. vid slicing, "
"eller i de inbyggda funktionerna :func:`bin`, :func:`hex` och :func:`oct`). "
"Närvaron av denna metod indikerar att det numeriska objektet är en "
"heltalstyp.  Måste returnera ett heltal."

#: ../../reference/datamodel.rst:3456
msgid ""
"If :meth:`__int__`, :meth:`__float__` and :meth:`__complex__` are not "
"defined then corresponding built-in functions :func:`int`, :func:`float` "
"and :func:`complex` fall back to :meth:`__index__`."
msgstr ""
"Om :meth:`__int__`, :meth:`__float__` och :meth:`__complex__` inte är "
"definierade faller motsvarande inbyggda "
"funktioner :func:`int`, :func:`float` och :func:`complex` tillbaka "
"på :meth:`__index__`."

#: ../../reference/datamodel.rst:3468
msgid ""
"Called to implement the built-in function :func:`round` and :mod:`math` "
"functions :func:`~math.trunc`, :func:`~math.floor` and :func:`~math.ceil`. "
"Unless *ndigits* is passed to :meth:`!__round__` all these methods should "
"return the value of the object truncated to an :class:`~numbers.Integral` "
"(typically an :class:`int`)."
msgstr ""
"Anropas för att implementera den inbyggda funktionen :func:`round` "
"och :mod:`math` funktionerna :func:`~math.trunc`, :func:`~math.floor` "
"och :func:`~math.ceil`. Om inte *ndigits* skickas till :meth:`!__round__` "
"bör alla dessa metoder returnera värdet av objektet trunkerat till "
"en :class:`~numbers.Integral` (typiskt en :class:`int`)."

#: ../../reference/datamodel.rst:3474
msgid ""
":func:`int` no longer delegates to the :meth:`~object.__trunc__` method."
msgstr ""
":func:`int` delegerar inte längre till metoden :meth:`~object.__trunc__`."

#: ../../reference/datamodel.rst:3481
msgid "With Statement Context Managers"
msgstr "Med uttalande från kontextansvariga"

#: ../../reference/datamodel.rst:3483
msgid ""
"A :dfn:`context manager` is an object that defines the runtime context to be "
"established when executing a :keyword:`with` statement. The context manager "
"handles the entry into, and the exit from, the desired runtime context for "
"the execution of the block of code.  Context managers are normally invoked "
"using the :keyword:`!with` statement (described in section :ref:`with`), but "
"can also be used by directly invoking their methods."
msgstr ""
"En :dfn:`context manager` är ett objekt som definierar det körtidssammanhang "
"som skall upprättas när en :keyword:`with`\\-sats exekveras. "
"Kontexthanteraren hanterar inträdet i och utträdet ur den önskade "
"körtidskontexten för exekveringen av kodblocket.  Kontexthanterare anropas "
"normalt med hjälp av :keyword:`!with`\\-satsen (beskrivs i "
"avsnitt :ref:`with`), men kan också användas genom att direkt anropa deras "
"metoder."

#: ../../reference/datamodel.rst:3494
msgid ""
"Typical uses of context managers include saving and restoring various kinds "
"of global state, locking and unlocking resources, closing opened files, etc."
msgstr ""
"Typiska användningsområden för kontexthanterare är att spara och återställa "
"olika typer av globala tillstånd, låsa och låsa upp resurser, stänga öppnade "
"filer etc."

#: ../../reference/datamodel.rst:3497
msgid ""
"For more information on context managers, see :ref:`typecontextmanager`. "
"The :class:`object` class itself does not provide the context manager "
"methods."
msgstr ""
"För mer information om kontexthanterare, se :ref:`typecontextmanager`. "
"Klassen :class:`object` i sig tillhandahåller inte "
"kontexthanteringsmetoderna."

#: ../../reference/datamodel.rst:3503
msgid ""
"Enter the runtime context related to this object. The :keyword:`with` "
"statement will bind this method's return value to the target(s) specified in "
"the :keyword:`!as` clause of the statement, if any."
msgstr ""
"Ange den runtime-kontext som är relaterad till detta objekt. "
"Satsen :keyword:`with` kommer att binda denna metods returvärde till det "
"eller de mål som anges i satsens :keyword:`!as`\\-klausul, om det finns "
"något."

#: ../../reference/datamodel.rst:3510
msgid ""
"Exit the runtime context related to this object. The parameters describe the "
"exception that caused the context to be exited. If the context was exited "
"without an exception, all three arguments will be :const:`None`."
msgstr ""
"Avslutar runtime-kontexten som är relaterad till detta objekt. Parametrarna "
"beskriver det undantag som orsakade att kontexten avslutades. Om kontexten "
"avslutades utan ett undantag, kommer alla tre argumenten att "
"vara :const:`None`."

#: ../../reference/datamodel.rst:3514
msgid ""
"If an exception is supplied, and the method wishes to suppress the exception "
"(i.e., prevent it from being propagated), it should return a true value. "
"Otherwise, the exception will be processed normally upon exit from this "
"method."
msgstr ""
"Om ett undantag anges och metoden vill undertrycka undantaget (dvs. "
"förhindra att det sprids), ska den returnera ett sant värde. Annars kommer "
"undantaget att behandlas normalt när metoden avslutas."

#: ../../reference/datamodel.rst:3518
msgid ""
"Note that :meth:`~object.__exit__` methods should not reraise the passed-in "
"exception; this is the caller's responsibility."
msgstr ""
"Observera att :meth:`~object.__exit__` -metoder inte bör återskapa det "
"överlämnade undantaget; detta är anroparens ansvar."

#: ../../reference/datamodel.rst:3524
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - Uttalandet \"med\""

#: ../../reference/datamodel.rst:3525
msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr ""
"Specifikation, bakgrund och exempel för Pythons :keyword:`with`\\-sats."

#: ../../reference/datamodel.rst:3532
msgid "Customizing positional arguments in class pattern matching"
msgstr "Anpassning av positionella argument vid matchning av klassmönster"

#: ../../reference/datamodel.rst:3534
msgid ""
"When using a class name in a pattern, positional arguments in the pattern "
"are not allowed by default, i.e. ``case MyClass(x, y)`` is typically invalid "
"without special support in ``MyClass``. To be able to use that kind of "
"pattern, the class needs to define a *__match_args__* attribute."
msgstr ""
"När ett klassnamn används i ett mönster tillåts inte positionella argument i "
"mönstret som standard, dvs. ``case MyClass(x, y)`` är typiskt ogiltigt utan "
"särskilt stöd i ``MyClass``. För att kunna använda den typen av mönster "
"måste klassen definiera ett *__match_args__*\\-attribut."

#: ../../reference/datamodel.rst:3541
msgid ""
"This class variable can be assigned a tuple of strings. When this class is "
"used in a class pattern with positional arguments, each positional argument "
"will be converted into a keyword argument, using the corresponding value in "
"*__match_args__* as the keyword. The absence of this attribute is equivalent "
"to setting it to ``()``."
msgstr ""
"Denna klassvariabel kan tilldelas en tupel av strängar. När den här klassen "
"används i ett klassmönster med positionella argument konverteras varje "
"positionellt argument till ett nyckelordsargument, med motsvarande värde i "
"*__match_args__** som nyckelord. Avsaknaden av detta attribut är likvärdigt "
"med att sätta det till ``()``."

#: ../../reference/datamodel.rst:3547
msgid ""
"For example, if ``MyClass.__match_args__`` is ``(\"left\", \"center\", "
"\"right\")`` that means that ``case MyClass(x, y)`` is equivalent to ``case "
"MyClass(left=x, center=y)``. Note that the number of arguments in the "
"pattern must be smaller than or equal to the number of elements in "
"*__match_args__*; if it is larger, the pattern match attempt will raise "
"a :exc:`TypeError`."
msgstr ""
"Om till exempel ``MyClass.__match_args__`` är ``(\"left\", \"center\", "
"\"right\")`` betyder det att ``case MyClass(x, y)`` är likvärdigt med ``case "
"MyClass(left=x, center=y)``. Observera att antalet argument i mönstret måste "
"vara mindre än eller lika med antalet element i *__match_args__*; om det är "
"större kommer försöket att matcha mönstret att ge upphov till "
"ett :exc:`TypeError`."

#: ../../reference/datamodel.rst:3557
msgid ":pep:`634` - Structural Pattern Matching"
msgstr ":pep:`634` - Matchning av strukturella mönster"

#: ../../reference/datamodel.rst:3558
msgid "The specification for the Python ``match`` statement."
msgstr "Specifikationen för Pythons ``match``\\-sats."

#: ../../reference/datamodel.rst:3564
msgid "Emulating buffer types"
msgstr "Emulering av bufferttyper"

#: ../../reference/datamodel.rst:3566
msgid ""
"The :ref:`buffer protocol <bufferobjects>` provides a way for Python objects "
"to expose efficient access to a low-level memory array. This protocol is "
"implemented by builtin types such as :class:`bytes` and :class:`memoryview`, "
"and third-party libraries may define additional buffer types."
msgstr ""
":ref:`buffer protocol <bufferobjects>` ger Python-objekt ett sätt att "
"exponera effektiv åtkomst till en minnesmatris på låg nivå. Detta protokoll "
"implementeras av inbyggda typer som :class:`bytes` och :class:`memoryview`, "
"och tredjepartsbibliotek kan definiera ytterligare bufferttyper."

#: ../../reference/datamodel.rst:3571
msgid ""
"While buffer types are usually implemented in C, it is also possible to "
"implement the protocol in Python."
msgstr ""
"Bufferttyper implementeras vanligtvis i C, men det är också möjligt att "
"implementera protokollet i Python."

#: ../../reference/datamodel.rst:3576
msgid ""
"Called when a buffer is requested from *self* (for example, by "
"the :class:`memoryview` constructor). The *flags* argument is an integer "
"representing the kind of buffer requested, affecting for example whether the "
"returned buffer is read-only or writable. :class:`inspect.BufferFlags` "
"provides a convenient way to interpret the flags. The method must return "
"a :class:`memoryview` object."
msgstr ""
"Anropas när en buffert begärs från *self* (t.ex. av :class:`memoryview`\\-"
"konstruktören). Argumentet *flags* är ett heltal som representerar den typ "
"av buffert som begärs, vilket t.ex. påverkar om den returnerade bufferten är "
"skrivskyddad eller skrivbar. :class:`inspect.BufferFlags` ger ett bekvämt "
"sätt att tolka flaggorna. Metoden måste returnera ett :class:`memoryview`\\-"
"objekt."

#: ../../reference/datamodel.rst:3585
msgid ""
"Called when a buffer is no longer needed. The *buffer* argument is "
"a :class:`memoryview` object that was previously returned "
"by :meth:`~object.__buffer__`. The method must release any resources "
"associated with the buffer. This method should return ``None``. Buffer "
"objects that do not need to perform any cleanup are not required to "
"implement this method."
msgstr ""
"Anropas när en buffert inte längre behövs. Argumentet *buffer* är ett objekt "
"av :class:`memoryview` som tidigare returnerats "
"av :meth:`~object.__buffer__`. Metoden måste frigöra alla resurser som är "
"associerade med bufferten. Denna metod bör returnera ``None``. Buffertobjekt "
"som inte behöver utföra någon rensning behöver inte implementera den här "
"metoden."

#: ../../reference/datamodel.rst:3596
msgid ":pep:`688` - Making the buffer protocol accessible in Python"
msgstr ":pep:`688` - Att göra buffertprotokollet tillgängligt i Python"

#: ../../reference/datamodel.rst:3597
msgid ""
"Introduces the Python ``__buffer__`` and ``__release_buffer__`` methods."
msgstr ""
"Presenterar Python-metoderna ``__buffer__`` och ``__release_buffer__``."

#: ../../reference/datamodel.rst:3599
msgid ":class:`collections.abc.Buffer`"
msgstr ":class:`samlingar.abc.buffert`"

#: ../../reference/datamodel.rst:3600
msgid "ABC for buffer types."
msgstr "ABC för bufferttyper."

#: ../../reference/datamodel.rst:3603
msgid "Annotations"
msgstr "Anteckningar"

#: ../../reference/datamodel.rst:3605
msgid ""
"Functions, classes, and modules may contain :term:`annotations "
"<annotation>`, which are a way to associate information (usually :term:`type "
"hints <type hint>`) with a symbol."
msgstr ""
"Funktioner, klasser och moduler kan innehålla :term:`annotations "
"<annotation>`, som är ett sätt att associera information "
"(vanligtvis :term:`type hints <type hint>`) med en symbol."

#: ../../reference/datamodel.rst:3611
msgid ""
"This attribute contains the annotations for an object. It is :ref:`lazily "
"evaluated <lazy-evaluation>`, so accessing the attribute may execute "
"arbitrary code and raise exceptions. If evaluation is successful, the "
"attribute is set to a dictionary mapping from variable names to annotations."
msgstr ""
"Detta attribut innehåller annoteringarna för ett objekt. "
"Det :ref:`utvärderas slentrianmässigt <lazy-evaluation>`, så åtkomst till "
"attributet kan exekvera godtycklig kod och ge upphov till undantag. Om "
"utvärderingen lyckas sätts attributet till en dictionary-mappning från "
"variabelnamn till annotationer."

#: ../../reference/datamodel.rst:3616
msgid "Annotations are now lazily evaluated."
msgstr "Annotationer utvärderas nu på ett lättsamt sätt."

#: ../../reference/datamodel.rst:3621
msgid ""
"An :term:`annotate function`. Returns a new dictionary object mapping "
"attribute/parameter names to their annotation values."
msgstr ""
"En :term:`annotate function`. Returnerar ett nytt ordboksobjekt som mappar "
"attribut-/parameternamn till deras annoteringsvärden."

#: ../../reference/datamodel.rst:3624
msgid ""
"Takes a format parameter specifying the format in which annotations values "
"should be provided. It must be a member of the :class:`annotationlib.Format` "
"enum, or an integer with a value corresponding to a member of the enum."
msgstr ""
"Tar emot en formatparameter som anger i vilket format värden för "
"anteckningar ska anges. Den måste vara en medlem i "
"enum :class:`annotationlib.Format`, eller ett heltal med ett värde som "
"motsvarar en medlem i enum."

#: ../../reference/datamodel.rst:3628
msgid ""
"If an annotate function doesn't support the requested format, it must "
"raise :exc:`NotImplementedError`. Annotate functions must always "
"support :attr:`~annotationlib.Format.VALUE` format; they must not "
"raise :exc:`NotImplementedError()` when called with this format."
msgstr ""
"Om en annoteringsfunktion inte stöder det begärda formatet måste den ge "
"upphov till :exc:`NotImplementedError`. Annoteringsfunktioner måste alltid "
"stödja formatet :attr:`~annotationlib.Format.VALUE`; de får inte ge upphov "
"till :exc:`NotImplementedError()` när de anropas med detta format."

#: ../../reference/datamodel.rst:3633
msgid ""
"When called with  :attr:`~annotationlib.Format.VALUE` format, an annotate "
"function may raise :exc:`NameError`; it must not raise :exc:`!NameError` "
"when called requesting any other format."
msgstr ""
"När en annotate-funktion anropas med :attr:`~annotationlib.Format.VALUE`\\-"
"format kan den ge upphov till :exc:`NameError`; den får inte ge upphov "
"till :exc:`!NameError` när den anropas med något annat format."

#: ../../reference/datamodel.rst:3636
msgid ""
"If an object does not have any annotations, :attr:`~object.__annotate__` "
"should preferably be set to ``None`` (it can’t be deleted), rather than set "
"to a function that returns an empty dict."
msgstr ""
"Om ett objekt inte har några annoteringar bör :attr:`~object.__annotate__` "
"helst sättas till ``None`` (det kan inte tas bort), snarare än att sättas "
"till en funktion som returnerar en tom dict."

#: ../../reference/datamodel.rst:3643
msgid ":pep:`649` --- Deferred evaluation of annotation using descriptors"
msgstr ""
":pep:`649` --- Uppskjuten utvärdering av annotering med hjälp av deskriptorer"

#: ../../reference/datamodel.rst:3644
msgid ""
"Introduces lazy evaluation of annotations and the ``__annotate__`` function."
msgstr ""
"Introducerar latent utvärdering av annoteringar och funktionen "
"``__annotate__``."

#: ../../reference/datamodel.rst:3650
msgid "Special method lookup"
msgstr "Särskild metoduppslagning"

#: ../../reference/datamodel.rst:3652
msgid ""
"For custom classes, implicit invocations of special methods are only "
"guaranteed to work correctly if defined on an object's type, not in the "
"object's instance dictionary.  That behaviour is the reason why the "
"following code raises an exception::"
msgstr ""
"För anpassade klasser garanteras implicita anrop av specialmetoder att "
"fungera korrekt endast om de definieras på ett objekts typ, inte i objektets "
"instansordbok.  Detta beteende är anledningen till att följande kod ger "
"upphov till ett undantag::"

#: ../../reference/datamodel.rst:3657
msgid ""
">>> class C:\n"
"...     pass\n"
"...\n"
">>> c = C()\n"
">>> c.__len__ = lambda: 5\n"
">>> len(c)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: object of type 'C' has no len()"
msgstr ""
">>> class C:\n"
"...     pass\n"
"...\n"
">>> c = C()\n"
">>> c.__len__ = lambda: 5\n"
">>> len(c)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: object of type 'C' has no len()"

#: ../../reference/datamodel.rst:3667
msgid ""
"The rationale behind this behaviour lies with a number of special methods "
"such as :meth:`~object.__hash__` and :meth:`~object.__repr__` that are "
"implemented by all objects, including type objects. If the implicit lookup "
"of these methods used the conventional lookup process, they would fail when "
"invoked on the type object itself::"
msgstr ""
"Anledningen till detta beteende är ett antal specialmetoder "
"som :meth:`~object.__hash__` och :meth:`~object.__repr__` som implementeras "
"av alla objekt, inklusive typobjekt. Om den implicita uppslagningen av dessa "
"metoder använde den konventionella uppslagningsprocessen skulle de "
"misslyckas när de anropas på typobjektet självt::"

#: ../../reference/datamodel.rst:3674
msgid ""
">>> 1 .__hash__() == hash(1)\n"
"True\n"
">>> int.__hash__() == hash(int)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: descriptor '__hash__' of 'int' object needs an argument"
msgstr ""
">>> 1 .__hash__() == hash(1)\n"
"True\n"
">>> int.__hash__() == hash(int)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: descriptor '__hash__' of 'int' object needs an argument"

#: ../../reference/datamodel.rst:3681
msgid ""
"Incorrectly attempting to invoke an unbound method of a class in this way is "
"sometimes referred to as 'metaclass confusion', and is avoided by bypassing "
"the instance when looking up special methods::"
msgstr ""
"Att felaktigt försöka anropa en obunden metod i en klass på detta sätt "
"kallas ibland \"metaklassförvirring\" och undviks genom att förbigå "
"instansen när man söker efter speciella metoder::"

#: ../../reference/datamodel.rst:3685
msgid ""
">>> type(1).__hash__(1) == hash(1)\n"
"True\n"
">>> type(int).__hash__(int) == hash(int)\n"
"True"
msgstr ""
">>> type(1).__hash__(1) == hash(1)\n"
"True\n"
">>> type(int).__hash__(int) == hash(int)\n"
"True"

#: ../../reference/datamodel.rst:3690
msgid ""
"In addition to bypassing any instance attributes in the interest of "
"correctness, implicit special method lookup generally also bypasses "
"the :meth:`~object.__getattribute__` method even of the object's metaclass::"
msgstr ""
"Förutom att implicit specialmetoduppslagning förbigår alla instansattribut "
"för korrekthetens skull, förbigår den i allmänhet "
"också :meth:`~object.__getattribute__`\\-metoden, även för objektets "
"metaklass::"

#: ../../reference/datamodel.rst:3694
msgid ""
">>> class Meta(type):\n"
"...     def __getattribute__(*args):\n"
"...         print(\"Metaclass getattribute invoked\")\n"
"...         return type.__getattribute__(*args)\n"
"...\n"
">>> class C(object, metaclass=Meta):\n"
"...     def __len__(self):\n"
"...         return 10\n"
"...     def __getattribute__(*args):\n"
"...         print(\"Class getattribute invoked\")\n"
"...         return object.__getattribute__(*args)\n"
"...\n"
">>> c = C()\n"
">>> c.__len__()                 # Explicit lookup via instance\n"
"Class getattribute invoked\n"
"10\n"
">>> type(c).__len__(c)          # Explicit lookup via type\n"
"Metaclass getattribute invoked\n"
"10\n"
">>> len(c)                      # Implicit lookup\n"
"10"
msgstr ""
">>> class Meta(type):\n"
"...     def __getattribute__(*args):\n"
"...         print(\"Metaclass getattribute invoked\")\n"
"...         return type.__getattribute__(*args)\n"
"...\n"
">>> class C(object, metaclass=Meta):\n"
"...     def __len__(self):\n"
"...         return 10\n"
"...     def __getattribute__(*args):\n"
"...         print(\"Class getattribute invoked\")\n"
"...         return object.__getattribute__(*args)\n"
"...\n"
">>> c = C()\n"
">>> c.__len__()                 # Explicit lookup via instance\n"
"Class getattribute invoked\n"
"10\n"
">>> type(c).__len__(c)          # Explicit lookup via type\n"
"Metaclass getattribute invoked\n"
"10\n"
">>> len(c)                      # Implicit lookup\n"
"10"

#: ../../reference/datamodel.rst:3716
msgid ""
"Bypassing the :meth:`~object.__getattribute__` machinery in this fashion "
"provides significant scope for speed optimisations within the interpreter, "
"at the cost of some flexibility in the handling of special methods (the "
"special method *must* be set on the class object itself in order to be "
"consistently invoked by the interpreter)."
msgstr ""
"Att kringgå :meth:`~object.__getattribute__`\\-maskineriet på detta sätt ger "
"betydande utrymme för hastighetsoptimeringar i tolken, på bekostnad av viss "
"flexibilitet i hanteringen av specialmetoder (specialmetoden *måste* ställas "
"in på själva klassobjektet för att konsekvent kunna anropas av tolken)."

#: ../../reference/datamodel.rst:3727
msgid "Coroutines"
msgstr "Coroutines"

#: ../../reference/datamodel.rst:3731
msgid "Awaitable Objects"
msgstr "Väntande objekt"

#: ../../reference/datamodel.rst:3733
msgid ""
"An :term:`awaitable` object generally implements "
"an :meth:`~object.__await__` method. :term:`Coroutine objects <coroutine>` "
"returned from :keyword:`async def` functions are awaitable."
msgstr ""
"Ett :term:`awaitable`\\-objekt implementerar i allmänhet "
"en :meth:`~object.__await__`\\-metod. :term:`Coroutine objects <coroutine>` "
"som returneras från :keyword:`async def`\\-funktioner är awaitable."

#: ../../reference/datamodel.rst:3739
msgid ""
"The :term:`generator iterator` objects returned from generators decorated "
"with :func:`types.coroutine` are also awaitable, but they do not "
"implement :meth:`~object.__await__`."
msgstr ""
"De :term:`generator iterator`\\-objekt som returneras från generatorer "
"dekorerade med :func:`types.coroutine` är också awaitable, men de "
"implementerar inte :meth:`~object.__await__`."

#: ../../reference/datamodel.rst:3745
msgid ""
"Must return an :term:`iterator`.  Should be used to "
"implement :term:`awaitable` objects.  For instance, :class:`asyncio.Future` "
"implements this method to be compatible with the :keyword:`await` "
"expression. The :class:`object` class itself is not awaitable and does not "
"provide this method."
msgstr ""
"Måste returnera en :term:`iterator`.  Bör användas för att "
"implementera :term:`awaitable`\\-objekt.  Till exempel "
"implementerar :class:`asyncio.Future` den här metoden för att vara "
"kompatibel med :keyword:`await`\\-uttrycket. Klassen :class:`object` i sig "
"är inte awaitable och tillhandahåller inte denna metod."

#: ../../reference/datamodel.rst:3753
msgid ""
"The language doesn't place any restriction on the type or value of the "
"objects yielded by the iterator returned by ``__await__``, as this is "
"specific to the implementation of the asynchronous execution framework "
"(e.g. :mod:`asyncio`) that will be managing the :term:`awaitable` object."
msgstr ""
"Språket lägger inga restriktioner på typen eller värdet av de objekt som "
"iteratorn som returneras av ``__await__`` ger, eftersom detta är specifikt "
"för implementeringen av ramverket för asynkron exekvering "
"(t.ex. :mod:`asyncio``) som kommer att hantera objektet :term:`awaitable`."

#: ../../reference/datamodel.rst:3761
msgid ":pep:`492` for additional information about awaitable objects."
msgstr ":pep:`492` för ytterligare information om awaitable-objekt."

#: ../../reference/datamodel.rst:3767
msgid "Coroutine Objects"
msgstr "Coroutine-objekt"

#: ../../reference/datamodel.rst:3769
msgid ""
":term:`Coroutine objects <coroutine>` are :term:`awaitable` objects. A "
"coroutine's execution can be controlled by calling :meth:`~object.__await__` "
"and iterating over the result.  When the coroutine has finished executing "
"and returns, the iterator raises :exc:`StopIteration`, and the "
"exception's :attr:`~StopIteration.value` attribute holds the return value.  "
"If the coroutine raises an exception, it is propagated by the iterator.  "
"Coroutines should not directly raise unhandled :exc:`StopIteration` "
"exceptions."
msgstr ""
":term:`Coroutine-objekt <coroutine>` är :term:`awaitable`\\-objekt. En "
"coroutines exekvering kan kontrolleras genom att "
"anropa :meth:`~object.__await__` och iterera över resultatet.  När "
"coroutinen har exekverats färdigt och returnerar, ger iteratorn upphov "
"till :exc:`StopIteration`, och undantagets "
"attribut :attr:`~StopIteration.value` innehåller returvärdet.  Om coroutinen "
"ger upphov till ett undantag sprids det vidare av iteratorn.  Coroutines bör "
"inte direkt ge upphov till ohanterade :exc:`StopIteration`\\-undantag."

#: ../../reference/datamodel.rst:3777
msgid ""
"Coroutines also have the methods listed below, which are analogous to those "
"of generators (see :ref:`generator-methods`).  However, unlike generators, "
"coroutines do not directly support iteration."
msgstr ""
"Coroutines har också de metoder som anges nedan, vilka är analoga med dem "
"för generatorer (se :ref:`generator-methods`).  Till skillnad från "
"generatorer har coroutines dock inte direkt stöd för iteration."

#: ../../reference/datamodel.rst:3781
msgid "It is a :exc:`RuntimeError` to await on a coroutine more than once."
msgstr ""
"Det är ett :exc:`RuntimeError` att awaita på en coroutine mer än en gång."

#: ../../reference/datamodel.rst:3787
msgid ""
"Starts or resumes execution of the coroutine.  If *value* is ``None``, this "
"is equivalent to advancing the iterator returned "
"by :meth:`~object.__await__`.  If *value* is not ``None``, this method "
"delegates to the :meth:`~generator.send` method of the iterator that caused "
"the coroutine to suspend.  The result (return value, :exc:`StopIteration`, "
"or other exception) is the same as when iterating over the :meth:`!"
"__await__` return value, described above."
msgstr ""
"Startar eller återupptar körningen av coroutinen.  Om *värde* är ``None``, "
"motsvarar detta att flytta fram iteratorn som returneras "
"av :meth:`~object.__await__`.  Om *value* inte är ``None`` delegerar denna "
"metod till metoden :meth:`~generator.send` för den iterator som orsakade att "
"coroutinen avbröts.  Resultatet (returvärde, :exc:`StopIteration` eller "
"annat undantag) är detsamma som när man itererar över returvärdet "
"för :meth:`!__await__`, som beskrivs ovan."

#: ../../reference/datamodel.rst:3798
msgid ""
"Raises the specified exception in the coroutine.  This method delegates to "
"the :meth:`~generator.throw` method of the iterator that caused the "
"coroutine to suspend, if it has such a method.  Otherwise, the exception is "
"raised at the suspension point.  The result (return "
"value, :exc:`StopIteration`, or other exception) is the same as when "
"iterating over the :meth:`~object.__await__` return value, described above.  "
"If the exception is not caught in the coroutine, it propagates back to the "
"caller."
msgstr ""
"Utlöser det angivna undantaget i coroutinen.  Denna metod delegerar "
"till :meth:`~generator.throw`\\-metoden för den iterator som orsakade att "
"coroutinen avbröts, om den har en sådan metod.  Annars tas undantaget upp "
"vid avbrottspunkten.  Resultatet (returvärde, :exc:`StopIteration` eller "
"annat undantag) är detsamma som när man itererar över returvärdet "
"för :meth:`~object.__await__`, som beskrivs ovan.  Om undantaget inte fångas "
"upp i coroutinen sprids det tillbaka till den som anropar."

#: ../../reference/datamodel.rst:3809
msgid ""
"The second signature \\(type\\[, value\\[, traceback\\]\\]\\) is deprecated "
"and may be removed in a future version of Python."
msgstr ""
"Den andra signaturen \\(type\\[, value\\[, traceback\\]\\]\\ \\) är "
"föråldrad och kan tas bort i en framtida version av Python."

#: ../../reference/datamodel.rst:3814
msgid ""
"Causes the coroutine to clean itself up and exit.  If the coroutine is "
"suspended, this method first delegates to the :meth:`~generator.close` "
"method of the iterator that caused the coroutine to suspend, if it has such "
"a method.  Then it raises :exc:`GeneratorExit` at the suspension point, "
"causing the coroutine to immediately clean itself up. Finally, the coroutine "
"is marked as having finished executing, even if it was never started."
msgstr ""
"Gör att coroutinen rensar upp sig själv och avslutas.  Om coroutinen är "
"avbruten delegerar den här metoden först till :meth:`~generator.close`\\-"
"metoden för den iterator som fick coroutinen att avbrytas, om den har en "
"sådan metod.  Sedan utlöser den :exc:`GeneratorExit` vid avbrottspunkten, "
"vilket gör att coroutinen omedelbart rensar upp sig själv. Slutligen "
"markeras coroutinen som färdig exekverad, även om den aldrig startades."

#: ../../reference/datamodel.rst:3822
msgid ""
"Coroutine objects are automatically closed using the above process when they "
"are about to be destroyed."
msgstr ""
"Coroutine-objekt stängs automatiskt med hjälp av ovanstående process när de "
"är på väg att förstöras."

#: ../../reference/datamodel.rst:3828
msgid "Asynchronous Iterators"
msgstr "Asynkrona Iteratorer"

#: ../../reference/datamodel.rst:3830
msgid ""
"An *asynchronous iterator* can call asynchronous code in its ``__anext__`` "
"method."
msgstr ""
"En *asynkron iterator* kan anropa asynkron kod i sin metod ``__anext__``."

#: ../../reference/datamodel.rst:3833
msgid ""
"Asynchronous iterators can be used in an :keyword:`async for` statement."
msgstr "Asynkrona iteratorer kan användas i en :keyword:`async for`\\-sats."

#: ../../reference/datamodel.rst:3835 ../../reference/datamodel.rst:3884
msgid "The :class:`object` class itself does not provide these methods."
msgstr "Klassen :class:`object` i sig tillhandahåller inte dessa metoder."

#: ../../reference/datamodel.rst:3840
msgid "Must return an *asynchronous iterator* object."
msgstr "Måste returnera ett *asynkront iterator*-objekt."

#: ../../reference/datamodel.rst:3844
msgid ""
"Must return an *awaitable* resulting in a next value of the iterator.  "
"Should raise a :exc:`StopAsyncIteration` error when the iteration is over."
msgstr ""
"Måste returnera en *awaitable* som resulterar i ett nästa värde för "
"iteratorn.  Bör ge upphov till ett :exc:`StopAsyncIteration`\\-fel när "
"iterationen är över."

#: ../../reference/datamodel.rst:3847
msgid "An example of an asynchronous iterable object::"
msgstr "Ett exempel på ett asynkront iterabelt objekt::"

#: ../../reference/datamodel.rst:3849
msgid ""
"class Reader:\n"
"    async def readline(self):\n"
"        ...\n"
"\n"
"    def __aiter__(self):\n"
"        return self\n"
"\n"
"    async def __anext__(self):\n"
"        val = await self.readline()\n"
"        if val == b'':\n"
"            raise StopAsyncIteration\n"
"        return val"
msgstr ""
"class Reader:\n"
"    async def readline(self):\n"
"        ...\n"
"\n"
"    def __aiter__(self):\n"
"        return self\n"
"\n"
"    async def __anext__(self):\n"
"        val = await self.readline()\n"
"        if val == b'':\n"
"            raise StopAsyncIteration\n"
"        return val"

#: ../../reference/datamodel.rst:3864
msgid ""
"Prior to Python 3.7, :meth:`~object.__aiter__` could return an *awaitable* "
"that would resolve to an :term:`asynchronous iterator <asynchronous "
"iterator>`."
msgstr ""
"Före Python 3.7 kunde :meth:`~object.__aiter__` returnera en *awaitable* som "
"skulle lösas till en :term:`asynkron iterator <asynchronous iterator>`."

#: ../../reference/datamodel.rst:3869
msgid ""
"Starting with Python 3.7, :meth:`~object.__aiter__` must return an "
"asynchronous iterator object.  Returning anything else will result in "
"a :exc:`TypeError` error."
msgstr ""
"Från och med Python 3.7 måste :meth:`~object.__aiter__` returnera ett "
"asynkront iteratorobjekt.  Om något annat returneras kommer det att "
"resultera i ett :exc:`TypeError`\\-fel."

#: ../../reference/datamodel.rst:3877
msgid "Asynchronous Context Managers"
msgstr "Asynkrona kontexthanterare"

#: ../../reference/datamodel.rst:3879
msgid ""
"An *asynchronous context manager* is a *context manager* that is able to "
"suspend execution in its ``__aenter__`` and ``__aexit__`` methods."
msgstr ""
"En *asynkron kontexthanterare* är en *kontexthanterare* som kan avbryta "
"exekveringen i sina metoder ``__aenter__`` och ``__aexit__``."

#: ../../reference/datamodel.rst:3882
msgid ""
"Asynchronous context managers can be used in an :keyword:`async with` "
"statement."
msgstr ""
"Asynkrona kontexthanterare kan användas i en :keyword:`async with`\\-sats."

#: ../../reference/datamodel.rst:3888
msgid ""
"Semantically similar to :meth:`~object.__enter__`, the only difference being "
"that it must return an *awaitable*."
msgstr ""
"Semantiskt lik :meth:`~object.__enter__`, den enda skillnaden är att den "
"måste returnera en *awaitable*."

#: ../../reference/datamodel.rst:3893
msgid ""
"Semantically similar to :meth:`~object.__exit__`, the only difference being "
"that it must return an *awaitable*."
msgstr ""
"Semantiskt lik :meth:`~object.__exit__`, den enda skillnaden är att den "
"måste returnera en *awaitable*."

#: ../../reference/datamodel.rst:3896
msgid "An example of an asynchronous context manager class::"
msgstr "Ett exempel på en asynkron kontexthanteringsklass::"

#: ../../reference/datamodel.rst:3898
msgid ""
"class AsyncContextManager:\n"
"    async def __aenter__(self):\n"
"        await log('entering context')\n"
"\n"
"    async def __aexit__(self, exc_type, exc, tb):\n"
"        await log('exiting context')"
msgstr ""
"class AsyncContextManager:\n"
"    async def __aenter__(self):\n"
"        await log('entering context')\n"
"\n"
"    async def __aexit__(self, exc_type, exc, tb):\n"
"        await log('exiting context')"

#: ../../reference/datamodel.rst:3909
msgid "Footnotes"
msgstr "Fotnoter"

#: ../../reference/datamodel.rst:3910
msgid ""
"It *is* possible in some cases to change an object's type, under certain "
"controlled conditions. It generally isn't a good idea though, since it can "
"lead to some very strange behaviour if it is handled incorrectly."
msgstr ""
"Det *är* möjligt att i vissa fall ändra ett objekts typ, under vissa "
"kontrollerade förhållanden. Det är dock i allmänhet ingen bra idé, eftersom "
"det kan leda till mycket konstiga beteenden om det hanteras felaktigt."

#: ../../reference/datamodel.rst:3914
msgid ""
"The :meth:`~object.__hash__`, :meth:`~object.__iter__`, :meth:`~object.__reversed__`, :meth:`~object.__contains__`, :meth:`~object.__class_getitem__` "
"and :meth:`~os.PathLike.__fspath__` methods have special handling for this. "
"Others will still raise a :exc:`TypeError`, but may do so by relying on the "
"behavior that ``None`` is not callable."
msgstr ""
"Metoderna :meth:`~object.__hash__`, :meth:`~object.__iter__`, :meth:`~object.__reversed__`, :meth:`~object.__contains__`, :meth:`~object.__class_getitem__` "
"och :meth:`~os.PathLike.__fspath__` har särskild hantering för detta. Andra "
"kommer fortfarande att ge upphov till ett :exc:`TypeError`, men kan göra det "
"genom att förlita sig på beteendet att ``None`` inte är anropbart."

#: ../../reference/datamodel.rst:3921
msgid ""
"\"Does not support\" here means that the class has no such method, or the "
"method returns :data:`NotImplemented`.  Do not set the method to ``None`` if "
"you want to force fallback to the right operand's reflected method—that will "
"instead have the opposite effect of explicitly *blocking* such fallback."
msgstr ""
"\"Stöder inte\" betyder här att klassen inte har någon sådan metod, eller "
"att metoden returnerar :data:`NotImplemented`.  Sätt inte metoden till "
"``None`` om du vill tvinga fram fallback till den högra operandens "
"reflekterade metod - det kommer istället att ha motsatt effekt att explicit "
"*blockera* sådan fallback."

#: ../../reference/datamodel.rst:3927
msgid ""
"For operands of the same type, it is assumed that if the non-reflected "
"method (such as :meth:`~object.__add__`) fails then the operation is not "
"supported, which is why the reflected method is not called."
msgstr ""
"För operander av samma typ antas det att om den icke-reflekterade metoden "
"(t.ex. :meth:`~object.__add__`) misslyckas stöds inte operationen, varför "
"den reflekterade metoden inte anropas."

#: ../../reference/datamodel.rst:3931
msgid ""
"If the right operand's type is a subclass of the left operand's type, the "
"reflected method having precedence allows subclasses to override their "
"ancestors' operations."
msgstr ""
"Om den högra operandens typ är en subklass av den vänstra operandens typ, "
"har den reflekterade metoden företräde, vilket gör att subklasser kan "
"åsidosätta sina förfäders operationer."

#: ../../reference/datamodel.rst:14 ../../reference/datamodel.rst:152
#: ../../reference/datamodel.rst:163 ../../reference/datamodel.rst:187
#: ../../reference/datamodel.rst:199 ../../reference/datamodel.rst:232
#: ../../reference/datamodel.rst:253 ../../reference/datamodel.rst:270
#: ../../reference/datamodel.rst:288 ../../reference/datamodel.rst:301
#: ../../reference/datamodel.rst:333 ../../reference/datamodel.rst:368
#: ../../reference/datamodel.rst:393 ../../reference/datamodel.rst:414
#: ../../reference/datamodel.rst:432 ../../reference/datamodel.rst:452
#: ../../reference/datamodel.rst:460 ../../reference/datamodel.rst:471
#: ../../reference/datamodel.rst:488 ../../reference/datamodel.rst:524
#: ../../reference/datamodel.rst:539 ../../reference/datamodel.rst:677
#: ../../reference/datamodel.rst:815 ../../reference/datamodel.rst:839
#: ../../reference/datamodel.rst:875 ../../reference/datamodel.rst:1153
#: ../../reference/datamodel.rst:1313 ../../reference/datamodel.rst:1340
#: ../../reference/datamodel.rst:1412 ../../reference/datamodel.rst:1520
#: ../../reference/datamodel.rst:1628 ../../reference/datamodel.rst:1745
#: ../../reference/datamodel.rst:2170 ../../reference/datamodel.rst:3197
msgid "object"
msgstr "objekt"

#: ../../reference/datamodel.rst:14 ../../reference/datamodel.rst:126
msgid "data"
msgstr "data"

#: ../../reference/datamodel.rst:23 ../../reference/datamodel.rst:301
#: ../../reference/datamodel.rst:348 ../../reference/datamodel.rst:432
#: ../../reference/datamodel.rst:471 ../../reference/datamodel.rst:815
#: ../../reference/datamodel.rst:1369 ../../reference/datamodel.rst:1828
#: ../../reference/datamodel.rst:2071 ../../reference/datamodel.rst:2077
#: ../../reference/datamodel.rst:2170 ../../reference/datamodel.rst:2732
#: ../../reference/datamodel.rst:3167 ../../reference/datamodel.rst:3325
#: ../../reference/datamodel.rst:3360 ../../reference/datamodel.rst:3428
#: ../../reference/datamodel.rst:3438 ../../reference/datamodel.rst:3466
msgid "built-in function"
msgstr "inbyggd funktion"

#: ../../reference/datamodel.rst:23
msgid "id"
msgstr "id"

#: ../../reference/datamodel.rst:23 ../../reference/datamodel.rst:126
#: ../../reference/datamodel.rst:2732
msgid "type"
msgstr "typ"

#: ../../reference/datamodel.rst:23
msgid "identity of an object"
msgstr "identitet för ett objekt"

#: ../../reference/datamodel.rst:23
msgid "value of an object"
msgstr "värdet av ett objekt"

#: ../../reference/datamodel.rst:23
msgid "type of an object"
msgstr "typ av ett objekt"

#: ../../reference/datamodel.rst:23
msgid "mutable object"
msgstr "föränderligt objekt"

#: ../../reference/datamodel.rst:23
msgid "immutable object"
msgstr "oföränderligt objekt"

#: ../../reference/datamodel.rst:60
msgid "garbage collection"
msgstr "skräpsamlare"

#: ../../reference/datamodel.rst:60
msgid "reference counting"
msgstr "referensräkning"

#: ../../reference/datamodel.rst:60
msgid "unreachable object"
msgstr "oåtkomligt objekt"

#: ../../reference/datamodel.rst:95 ../../reference/datamodel.rst:1153
msgid "container"
msgstr "behållare"

#: ../../reference/datamodel.rst:126
msgid "hierarchy"
msgstr "hierarki"

#: ../../reference/datamodel.rst:126
msgid "extension"
msgstr "tillägg"

#: ../../reference/datamodel.rst:126 ../../reference/datamodel.rst:405
#: ../../reference/datamodel.rst:406 ../../reference/datamodel.rst:507
#: ../../reference/datamodel.rst:875 ../../reference/datamodel.rst:895
#: ../../reference/datamodel.rst:1369
msgid "module"
msgstr "modul"

#: ../../reference/datamodel.rst:126 ../../reference/datamodel.rst:270
#: ../../reference/datamodel.rst:815
msgid "C"
msgstr "C"

#: ../../reference/datamodel.rst:126 ../../reference/datamodel.rst:270
#: ../../reference/datamodel.rst:815
msgid "language"
msgstr "språk"

#: ../../reference/datamodel.rst:139 ../../reference/datamodel.rst:1153
#: ../../reference/datamodel.rst:1171 ../../reference/datamodel.rst:1313
#: ../../reference/datamodel.rst:1333
msgid "attribute"
msgstr "attribut"

#: ../../reference/datamodel.rst:139
msgid "special"
msgstr "speciella"

#: ../../reference/datamodel.rst:139
msgid "generic"
msgstr "generisk"

#: ../../reference/datamodel.rst:187
msgid "..."
msgstr "..."

#: ../../reference/datamodel.rst:187
msgid "ellipsis literal"
msgstr "ellips bokstavlig"

#: ../../reference/datamodel.rst:199 ../../reference/datamodel.rst:1340
msgid "numeric"
msgstr "numeriska"

#: ../../reference/datamodel.rst:232 ../../reference/datamodel.rst:238
#: ../../reference/datamodel.rst:348
msgid "integer"
msgstr "heltal"

#: ../../reference/datamodel.rst:238
msgid "representation"
msgstr "representation"

#: ../../reference/datamodel.rst:253
msgid "Boolean"
msgstr "Boolean"

#: ../../reference/datamodel.rst:253
msgid "False"
msgstr "Falskt"

#: ../../reference/datamodel.rst:253
msgid "True"
msgstr "Sant"

#: ../../reference/datamodel.rst:270
msgid "floating-point"
msgstr "flyttal"

#: ../../reference/datamodel.rst:270 ../../reference/datamodel.rst:288
msgid "number"
msgstr "nummer"

#: ../../reference/datamodel.rst:270
msgid "Java"
msgstr "Java"

#: ../../reference/datamodel.rst:288 ../../reference/datamodel.rst:3438
msgid "complex"
msgstr "komplex"

#: ../../reference/datamodel.rst:301 ../../reference/datamodel.rst:432
#: ../../reference/datamodel.rst:471 ../../reference/datamodel.rst:3167
msgid "len"
msgstr "len"

#: ../../reference/datamodel.rst:301 ../../reference/datamodel.rst:1340
msgid "sequence"
msgstr "sekvens"

#: ../../reference/datamodel.rst:301
msgid "index operation"
msgstr "indexoperation"

#: ../../reference/datamodel.rst:301
msgid "item selection"
msgstr "val av objekt"

#: ../../reference/datamodel.rst:301 ../../reference/datamodel.rst:393
#: ../../reference/datamodel.rst:471
msgid "subscription"
msgstr "prenumeration"

#: ../../reference/datamodel.rst:316 ../../reference/datamodel.rst:393
msgid "slicing"
msgstr "skivning"

#: ../../reference/datamodel.rst:333
msgid "immutable sequence"
msgstr "oföränderlig sekvens"

#: ../../reference/datamodel.rst:333
msgid "immutable"
msgstr "oföränderlig"

#: ../../reference/datamodel.rst:344 ../../reference/datamodel.rst:2046
#: ../../reference/datamodel.rst:2077
msgid "string"
msgstr "sträng"

#: ../../reference/datamodel.rst:344
msgid "immutable sequences"
msgstr "oföränderliga sekvenser"

#: ../../reference/datamodel.rst:348
msgid "chr"
msgstr "chr"

#: ../../reference/datamodel.rst:348
msgid "ord"
msgstr "ord"

#: ../../reference/datamodel.rst:348
msgid "character"
msgstr "tecken"

#: ../../reference/datamodel.rst:348
msgid "Unicode"
msgstr "Unicode"

#: ../../reference/datamodel.rst:368
msgid "tuple"
msgstr "tupel"

#: ../../reference/datamodel.rst:368
msgid "singleton"
msgstr "singleton"

#: ../../reference/datamodel.rst:368
msgid "empty"
msgstr "tom"

#: ../../reference/datamodel.rst:381 ../../reference/datamodel.rst:2071
msgid "bytes"
msgstr "byte"

#: ../../reference/datamodel.rst:381
msgid "byte"
msgstr "byte"

#: ../../reference/datamodel.rst:393
msgid "mutable sequence"
msgstr "muterbar sekvens"

#: ../../reference/datamodel.rst:393
msgid "mutable"
msgstr "föränderlig"

#: ../../reference/datamodel.rst:393 ../../reference/datamodel.rst:1171
#: ../../reference/datamodel.rst:1333
msgid "assignment"
msgstr "uppgift"

#: ../../reference/datamodel.rst:393 ../../reference/datamodel.rst:875
#: ../../reference/datamodel.rst:1782 ../../reference/datamodel.rst:1964
#: ../../reference/datamodel.rst:3490
msgid "statement"
msgstr "uttalande"

#: ../../reference/datamodel.rst:405
msgid "array"
msgstr "array"

#: ../../reference/datamodel.rst:406
msgid "collections"
msgstr "samlingar"

#: ../../reference/datamodel.rst:414
msgid "list"
msgstr "lista"

#: ../../reference/datamodel.rst:421
msgid "bytearray"
msgstr "bytearray"

#: ../../reference/datamodel.rst:432
msgid "set type"
msgstr "inställd typ"

#: ../../reference/datamodel.rst:452
msgid "set"
msgstr "set"

#: ../../reference/datamodel.rst:460
msgid "frozenset"
msgstr "frozenset"

#: ../../reference/datamodel.rst:471 ../../reference/datamodel.rst:1340
msgid "mapping"
msgstr "kartläggning"

#: ../../reference/datamodel.rst:488 ../../reference/datamodel.rst:1153
#: ../../reference/datamodel.rst:2170
msgid "dictionary"
msgstr "ordbok"

#: ../../reference/datamodel.rst:507
msgid "dbm.ndbm"
msgstr "dbm.ndbm"

#: ../../reference/datamodel.rst:507
msgid "dbm.gnu"
msgstr "dbm.gnu"

#: ../../reference/datamodel.rst:524
msgid "callable"
msgstr "anropsbar"

#: ../../reference/datamodel.rst:524 ../../reference/datamodel.rst:539
#: ../../reference/datamodel.rst:759 ../../reference/datamodel.rst:777
#: ../../reference/datamodel.rst:790 ../../reference/datamodel.rst:815
msgid "function"
msgstr "funktion"

#: ../../reference/datamodel.rst:524 ../../reference/datamodel.rst:1153
#: ../../reference/datamodel.rst:1176 ../../reference/datamodel.rst:3113
msgid "call"
msgstr "ring upp"

#: ../../reference/datamodel.rst:524
msgid "invocation"
msgstr "påkallande"

#: ../../reference/datamodel.rst:524
msgid "argument"
msgstr "argument"

#: ../../reference/datamodel.rst:539 ../../reference/datamodel.rst:677
msgid "user-defined"
msgstr "användardefinierad"

#: ../../reference/datamodel.rst:539
msgid "user-defined function"
msgstr "användardefinierad funktion"

#: ../../reference/datamodel.rst:552
msgid "__closure__ (function attribute)"
msgstr "__closure__ (funktionsattribut)"

#: ../../reference/datamodel.rst:552
msgid "__globals__ (function attribute)"
msgstr "__globals__ (funktionsattribut)"

#: ../../reference/datamodel.rst:552
msgid "global"
msgstr "globala"

#: ../../reference/datamodel.rst:552 ../../reference/datamodel.rst:895
msgid "namespace"
msgstr "namnrymd"

#: ../../reference/datamodel.rst:579
msgid "__doc__ (function attribute)"
msgstr "__doc__ (funktionsattribut)"

#: ../../reference/datamodel.rst:579
msgid "__name__ (function attribute)"
msgstr "__name__ (funktionsattribut)"

#: ../../reference/datamodel.rst:579
msgid "__module__ (function attribute)"
msgstr "__module__ (funktionsattribut)"

#: ../../reference/datamodel.rst:579
msgid "__dict__ (function attribute)"
msgstr "__dict__ (funktionsattribut)"

#: ../../reference/datamodel.rst:579
msgid "__defaults__ (function attribute)"
msgstr "__defaults__ (funktion attribut)"

#: ../../reference/datamodel.rst:579
msgid "__code__ (function attribute)"
msgstr "__code__ (funktionsattribut)"

#: ../../reference/datamodel.rst:579
msgid "__annotations__ (function attribute)"
msgstr "__annotationer__ (funktion attribut)"

#: ../../reference/datamodel.rst:579
msgid "__annotate__ (function attribute)"
msgstr "__annotate__ (funktion attribut)"

#: ../../reference/datamodel.rst:579
msgid "__kwdefaults__ (function attribute)"
msgstr "__kwdefaults__ (funktionsattribut)"

#: ../../reference/datamodel.rst:579
msgid "__type_params__ (function attribute)"
msgstr "__type_params__ (funktionsattribut)"

#: ../../reference/datamodel.rst:677 ../../reference/datamodel.rst:839
msgid "method"
msgstr "metod"

#: ../../reference/datamodel.rst:677
msgid "user-defined method"
msgstr "användardefinierad metod"

#: ../../reference/datamodel.rst:685
msgid "__func__ (method attribute)"
msgstr "__func__ (metodattribut)"

#: ../../reference/datamodel.rst:685
msgid "__self__ (method attribute)"
msgstr "__self__ (metodattribut)"

#: ../../reference/datamodel.rst:685
msgid "__doc__ (method attribute)"
msgstr "__doc__ (metodattribut)"

#: ../../reference/datamodel.rst:685
msgid "__name__ (method attribute)"
msgstr "__name__ (metodattribut)"

#: ../../reference/datamodel.rst:685
msgid "__module__ (method attribute)"
msgstr "__module__ (metodattribut)"

#: ../../reference/datamodel.rst:759 ../../reference/datamodel.rst:1520
msgid "generator"
msgstr "generator"

#: ../../reference/datamodel.rst:759
msgid "iterator"
msgstr "iterator"

#: ../../reference/datamodel.rst:777 ../../reference/datamodel.rst:3723
msgid "coroutine"
msgstr "coroutine"

#: ../../reference/datamodel.rst:790
msgid "asynchronous generator"
msgstr "asynkron generator"

#: ../../reference/datamodel.rst:790
msgid "asynchronous iterator"
msgstr "asynkron iterator"

#: ../../reference/datamodel.rst:839
msgid "built-in method"
msgstr "inbyggd metod"

#: ../../reference/datamodel.rst:839
msgid "built-in"
msgstr "inbyggd"

#: ../../reference/datamodel.rst:875
msgid "import"
msgstr "importera"

#: ../../reference/datamodel.rst:895
msgid "__name__ (module attribute)"
msgstr "__name__ (attribut för modul)"

#: ../../reference/datamodel.rst:895
msgid "__spec__ (module attribute)"
msgstr "__spec__ (modulattribut)"

#: ../../reference/datamodel.rst:895
msgid "__package__ (module attribute)"
msgstr "__package__ (modulattribut)"

#: ../../reference/datamodel.rst:895
msgid "__loader__ (module attribute)"
msgstr "__loader__ (modulattribut)"

#: ../../reference/datamodel.rst:895
msgid "__path__ (module attribute)"
msgstr "__path__ (modulattribut)"

#: ../../reference/datamodel.rst:895
msgid "__file__ (module attribute)"
msgstr "__file__ (modulattribut)"

#: ../../reference/datamodel.rst:895
msgid "__cached__ (module attribute)"
msgstr "__cached__ (modulattribut)"

#: ../../reference/datamodel.rst:895
msgid "__doc__ (module attribute)"
msgstr "__doc__ (modulattribut)"

#: ../../reference/datamodel.rst:895
msgid "__annotations__ (module attribute)"
msgstr "__annotationer__ (modulattribut)"

#: ../../reference/datamodel.rst:895
msgid "__annotate__ (module attribute)"
msgstr "__annotate__ (modulattribut)"

#: ../../reference/datamodel.rst:1121
msgid "__dict__ (module attribute)"
msgstr "__dict__ (modulattribut)"

#: ../../reference/datamodel.rst:1153 ../../reference/datamodel.rst:1171
#: ../../reference/datamodel.rst:1313 ../../reference/datamodel.rst:1947
#: ../../reference/datamodel.rst:2843
msgid "class"
msgstr "klass"

#: ../../reference/datamodel.rst:1153 ../../reference/datamodel.rst:1313
#: ../../reference/datamodel.rst:1333
msgid "class instance"
msgstr "klassinstans"

#: ../../reference/datamodel.rst:1153 ../../reference/datamodel.rst:1313
#: ../../reference/datamodel.rst:3113
msgid "instance"
msgstr "instans"

#: ../../reference/datamodel.rst:1153 ../../reference/datamodel.rst:1176
msgid "class object"
msgstr "klassobjekt"

#: ../../reference/datamodel.rst:1183
msgid "__name__ (class attribute)"
msgstr "__name__ (klassattribut)"

#: ../../reference/datamodel.rst:1183
msgid "__module__ (class attribute)"
msgstr "__module__ (klassattribut)"

#: ../../reference/datamodel.rst:1183
msgid "__dict__ (class attribute)"
msgstr "__dict__ (klassattribut)"

#: ../../reference/datamodel.rst:1183
msgid "__bases__ (class attribute)"
msgstr "__bases__ (klassattribut)"

#: ../../reference/datamodel.rst:1183
msgid "__doc__ (class attribute)"
msgstr "__doc__ (klassattribut)"

#: ../../reference/datamodel.rst:1183
msgid "__annotations__ (class attribute)"
msgstr "__annotations__ (klassattribut)"

#: ../../reference/datamodel.rst:1183
msgid "__annotate__ (class attribute)"
msgstr "__annotate__ (klassattribut)"

#: ../../reference/datamodel.rst:1183
msgid "__type_params__ (class attribute)"
msgstr "__type_params__ (klassattribut)"

#: ../../reference/datamodel.rst:1183
msgid "__static_attributes__ (class attribute)"
msgstr "__static_attributes__ (klassattribut)"

#: ../../reference/datamodel.rst:1183
msgid "__firstlineno__ (class attribute)"
msgstr "__firstlineno__ (klassattribut)"

#: ../../reference/datamodel.rst:1351
msgid "__dict__ (instance attribute)"
msgstr "__dict__ (instansattribut)"

#: ../../reference/datamodel.rst:1351
msgid "__class__ (instance attribute)"
msgstr "__class__ (instansattribut)"

#: ../../reference/datamodel.rst:1369
msgid "open"
msgstr "öppen"

#: ../../reference/datamodel.rst:1369
msgid "io"
msgstr "io"

#: ../../reference/datamodel.rst:1369
msgid "popen() (in module os)"
msgstr "popen() (i modul os)"

#: ../../reference/datamodel.rst:1369
msgid "makefile() (socket method)"
msgstr "makefile() (socket-metod)"

#: ../../reference/datamodel.rst:1369
msgid "sys.stdin"
msgstr "sys.stdin"

#: ../../reference/datamodel.rst:1369
msgid "sys.stdout"
msgstr "sys.stdout"

#: ../../reference/datamodel.rst:1369
msgid "sys.stderr"
msgstr "sys.stderr"

#: ../../reference/datamodel.rst:1369
msgid "stdio"
msgstr "stdio"

#: ../../reference/datamodel.rst:1369
msgid "stdin (in module sys)"
msgstr "stdin (i modul sys)"

#: ../../reference/datamodel.rst:1369
msgid "stdout (in module sys)"
msgstr "stdout (i modul sys)"

#: ../../reference/datamodel.rst:1369
msgid "stderr (in module sys)"
msgstr "stderr (i modul sys)"

#: ../../reference/datamodel.rst:1398
msgid "internal type"
msgstr "intern typ"

#: ../../reference/datamodel.rst:1398
msgid "types, internal"
msgstr "typer, interna"

#: ../../reference/datamodel.rst:1412
msgid "bytecode"
msgstr "bytekod"

#: ../../reference/datamodel.rst:1412
msgid "code"
msgstr "kod"

#: ../../reference/datamodel.rst:1412
msgid "code object"
msgstr "kodobjekt"

#: ../../reference/datamodel.rst:1423
msgid "co_argcount (code object attribute)"
msgstr "co_argcount (kodobjektattribut)"

#: ../../reference/datamodel.rst:1423
msgid "co_posonlyargcount (code object attribute)"
msgstr "co_posonlyargcount (kodobjektattribut)"

#: ../../reference/datamodel.rst:1423
msgid "co_kwonlyargcount (code object attribute)"
msgstr "co_kwonlyargcount (kodobjektattribut)"

#: ../../reference/datamodel.rst:1423
msgid "co_code (code object attribute)"
msgstr "co_code (attribut för kodobjekt)"

#: ../../reference/datamodel.rst:1423
msgid "co_consts (code object attribute)"
msgstr "co_consts (attribut för kodobjekt)"

#: ../../reference/datamodel.rst:1423
msgid "co_filename (code object attribute)"
msgstr "co_filename (kodobjektattribut)"

#: ../../reference/datamodel.rst:1423
msgid "co_firstlineno (code object attribute)"
msgstr "co_firstlineno (kodobjektattribut)"

#: ../../reference/datamodel.rst:1423
msgid "co_flags (code object attribute)"
msgstr "co_flags (attribut för kodobjekt)"

#: ../../reference/datamodel.rst:1423
msgid "co_lnotab (code object attribute)"
msgstr "co_lnotab (attribut för kodobjekt)"

#: ../../reference/datamodel.rst:1423
msgid "co_name (code object attribute)"
msgstr "co_name (kodobjektattribut)"

#: ../../reference/datamodel.rst:1423
msgid "co_names (code object attribute)"
msgstr "co_names (kodobjektattribut)"

#: ../../reference/datamodel.rst:1423
msgid "co_nlocals (code object attribute)"
msgstr "co_nlocals (kodobjektattribut)"

#: ../../reference/datamodel.rst:1423
msgid "co_stacksize (code object attribute)"
msgstr "co_stacksize (kodobjektattribut)"

#: ../../reference/datamodel.rst:1423
msgid "co_varnames (code object attribute)"
msgstr "co_varnames (kodobjektattribut)"

#: ../../reference/datamodel.rst:1423
msgid "co_cellvars (code object attribute)"
msgstr "co_cellvars (kodobjektattribut)"

#: ../../reference/datamodel.rst:1423
msgid "co_freevars (code object attribute)"
msgstr "co_freevars (kodobjektattribut)"

#: ../../reference/datamodel.rst:1423
msgid "co_qualname (code object attribute)"
msgstr "co_qualname (kodobjektattribut)"

#: ../../reference/datamodel.rst:1536
msgid "documentation string"
msgstr "dokumentationssträng"

#: ../../reference/datamodel.rst:1628
msgid "frame"
msgstr "ram"

#: ../../reference/datamodel.rst:1634
msgid "f_back (frame attribute)"
msgstr "f_back (ramattribut)"

#: ../../reference/datamodel.rst:1634
msgid "f_code (frame attribute)"
msgstr "f_code (ramattribut)"

#: ../../reference/datamodel.rst:1634
msgid "f_globals (frame attribute)"
msgstr "f_globals (ramattribut)"

#: ../../reference/datamodel.rst:1634
msgid "f_locals (frame attribute)"
msgstr "f_locals (ramattribut)"

#: ../../reference/datamodel.rst:1634
msgid "f_lasti (frame attribute)"
msgstr "f_lasti (ramattribut)"

#: ../../reference/datamodel.rst:1634
msgid "f_builtins (frame attribute)"
msgstr "f_builtins (ramattribut)"

#: ../../reference/datamodel.rst:1634
msgid "f_generator (frame attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1685
msgid "f_trace (frame attribute)"
msgstr "f_trace (ramattribut)"

#: ../../reference/datamodel.rst:1685
msgid "f_trace_lines (frame attribute)"
msgstr "f_trace_lines (ramattribut)"

#: ../../reference/datamodel.rst:1685
msgid "f_trace_opcodes (frame attribute)"
msgstr "f_trace_opcodes (ramattribut)"

#: ../../reference/datamodel.rst:1685
msgid "f_lineno (frame attribute)"
msgstr "f_lineno (ramattribut)"

#: ../../reference/datamodel.rst:1745
msgid "traceback"
msgstr "spårning"

#: ../../reference/datamodel.rst:1745
msgid "stack"
msgstr "stack"

#: ../../reference/datamodel.rst:1745
msgid "trace"
msgstr "spår"

#: ../../reference/datamodel.rst:1745
msgid "exception"
msgstr "undantag"

#: ../../reference/datamodel.rst:1745
msgid "handler"
msgstr "handläggare"

#: ../../reference/datamodel.rst:1745
msgid "execution"
msgstr "avrättning"

#: ../../reference/datamodel.rst:1745
msgid "exc_info (in module sys)"
msgstr "exc_info (i modul sys)"

#: ../../reference/datamodel.rst:1745
msgid "last_traceback (in module sys)"
msgstr "last_traceback (i modul sys)"

#: ../../reference/datamodel.rst:1745
msgid "sys.exc_info"
msgstr "sys.exc_info"

#: ../../reference/datamodel.rst:1745
msgid "sys.exception"
msgstr "sys.undantag"

#: ../../reference/datamodel.rst:1745
msgid "sys.last_traceback"
msgstr "sys.sista_traceback"

#: ../../reference/datamodel.rst:1782
msgid "tb_frame (traceback attribute)"
msgstr "tb_frame (spårningsattribut)"

#: ../../reference/datamodel.rst:1782
msgid "tb_lineno (traceback attribute)"
msgstr "tb_lineno (traceback-attribut)"

#: ../../reference/datamodel.rst:1782
msgid "tb_lasti (traceback attribute)"
msgstr "tb_lasti (traceback-attribut)"

#: ../../reference/datamodel.rst:1782
msgid "try"
msgstr "försök"

#: ../../reference/datamodel.rst:1812
msgid "tb_next (traceback attribute)"
msgstr "tb_next (spårningsattribut)"

#: ../../reference/datamodel.rst:1828 ../../reference/datamodel.rst:3197
msgid "slice"
msgstr "skiva"

#: ../../reference/datamodel.rst:1834
msgid "start (slice object attribute)"
msgstr "start (attribut för skivobjekt)"

#: ../../reference/datamodel.rst:1834
msgid "stop (slice object attribute)"
msgstr "stopp (attribut för skivobjekt)"

#: ../../reference/datamodel.rst:1834
msgid "step (slice object attribute)"
msgstr "steg (objektattribut för skiva)"

#: ../../reference/datamodel.rst:1882
msgid "operator"
msgstr "operator"

#: ../../reference/datamodel.rst:1882
msgid "overloading"
msgstr "överlastning"

#: ../../reference/datamodel.rst:1882
msgid "__getitem__() (mapping object method)"
msgstr "__getitem__() (metod för mappningsobjekt)"

#: ../../reference/datamodel.rst:1918
msgid "subclassing"
msgstr "underklassificering"

#: ../../reference/datamodel.rst:1918
msgid "immutable types"
msgstr "oföränderliga typer"

#: ../../reference/datamodel.rst:1947
msgid "constructor"
msgstr "konstruktör"

#: ../../reference/datamodel.rst:1964
msgid "destructor"
msgstr "destruktor"

#: ../../reference/datamodel.rst:1964
msgid "finalizer"
msgstr "slutbehandlare"

#: ../../reference/datamodel.rst:1964
msgid "del"
msgstr "rad"

#: ../../reference/datamodel.rst:2028
msgid "repr() (built-in function)"
msgstr "repr() (inbyggd funktion)"

#: ../../reference/datamodel.rst:2028
msgid "__repr__() (object method)"
msgstr "__repr__() (objektmetod)"

#: ../../reference/datamodel.rst:2046
msgid "__str__() (object method)"
msgstr "__str__() (objektmetod)"

#: ../../reference/datamodel.rst:2046
msgid "format() (built-in function)"
msgstr "format() (inbyggd funktion)"

#: ../../reference/datamodel.rst:2046
msgid "print() (built-in function)"
msgstr "print() (inbyggd funktion)"

#: ../../reference/datamodel.rst:2077
msgid "__format__() (object method)"
msgstr "__format__() (objektmetod)"

#: ../../reference/datamodel.rst:2077
msgid "conversion"
msgstr "omvandling"

#: ../../reference/datamodel.rst:2077
msgid "print"
msgstr "skriv ut"

#: ../../reference/datamodel.rst:2119
msgid "comparisons"
msgstr "jämförelser"

#: ../../reference/datamodel.rst:2170
msgid "hash"
msgstr "hash"

#: ../../reference/datamodel.rst:2251
msgid "__len__() (mapping object method)"
msgstr "__len__() (metod för mappningsobjekt)"

#: ../../reference/datamodel.rst:2356
msgid "__getattr__ (module attribute)"
msgstr "__getattr__ (modulattribut)"

#: ../../reference/datamodel.rst:2356
msgid "__dir__ (module attribute)"
msgstr "__dir__ (modulattribut)"

#: ../../reference/datamodel.rst:2356
msgid "__class__ (module attribute)"
msgstr "__class__ (modulattribut)"

#: ../../reference/datamodel.rst:2732
msgid "metaclass"
msgstr "metaklass"

#: ../../reference/datamodel.rst:2732
msgid "= (equals)"
msgstr "= (lika med)"

#: ../../reference/datamodel.rst:2732
msgid "class definition"
msgstr "klassdefinition"

#: ../../reference/datamodel.rst:2796
msgid "metaclass hint"
msgstr "tips om metaklass"

#: ../../reference/datamodel.rst:2819
msgid "__prepare__ (metaclass method)"
msgstr "__prepare__ (metaklassmetod)"

#: ../../reference/datamodel.rst:2843
msgid "body"
msgstr "body"

#: ../../reference/datamodel.rst:2863
msgid "__class__ (method cell)"
msgstr "__class__ (metodcell)"

#: ../../reference/datamodel.rst:2863
msgid "__classcell__ (class namespace entry)"
msgstr "__classcell__ (klassnamnsrymdsangivelse)"

#: ../../reference/datamodel.rst:3167
msgid "__bool__() (object method)"
msgstr "__bool__() (objektmetod)"

#: ../../reference/datamodel.rst:3325 ../../reference/datamodel.rst:3360
msgid "divmod"
msgstr "divmod"

#: ../../reference/datamodel.rst:3325 ../../reference/datamodel.rst:3360
msgid "pow"
msgstr "kraft"

#: ../../reference/datamodel.rst:3428
msgid "abs"
msgstr "abs"

#: ../../reference/datamodel.rst:3438
msgid "int"
msgstr "int"

#: ../../reference/datamodel.rst:3438
msgid "float"
msgstr "flyt"

#: ../../reference/datamodel.rst:3466
msgid "round"
msgstr "avrundat"

#: ../../reference/datamodel.rst:3490
msgid "with"
msgstr "med"

#: ../../reference/datamodel.rst:3490
msgid "context manager"
msgstr "kontexthanterare"
