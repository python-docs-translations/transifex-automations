# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-17 16:35+0000\n"
"PO-Revision-Date: 2025-09-22 16:51+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../reference/expressions.rst:6
msgid "Expressions"
msgstr "Uttryck"

#: ../../reference/expressions.rst:10
msgid ""
"This chapter explains the meaning of the elements of expressions in Python."
msgstr "I detta kapitel förklaras betydelsen av elementen i uttryck i Python."

#: ../../reference/expressions.rst:12
msgid ""
"**Syntax Notes:** In this and the following chapters, extended BNF notation "
"will be used to describe syntax, not lexical analysis.  When (one "
"alternative of) a syntax rule has the form"
msgstr ""
"**I detta och de följande kapitlen används utökad BNF-notation för att "
"beskriva syntax, inte lexikal analys.  När (ett alternativ till) en "
"syntaxregel har formen"

#: ../../reference/expressions.rst:19
msgid ""
"and no semantics are given, the semantics of this form of ``name`` are the "
"same as for ``othername``."
msgstr ""
"och ingen semantik anges, är semantiken för denna form av ``name`` densamma "
"som för ``othername``."

#: ../../reference/expressions.rst:26
msgid "Arithmetic conversions"
msgstr "Aritmetiska omvandlingar"

#: ../../reference/expressions.rst:30
msgid ""
"When a description of an arithmetic operator below uses the phrase \"the "
"numeric arguments are converted to a common type\", this means that the "
"operator implementation for built-in types works as follows:"
msgstr ""

#: ../../reference/expressions.rst:34
msgid ""
"If either argument is a complex number, the other is converted to complex;"
msgstr ""

#: ../../reference/expressions.rst:36
msgid ""
"otherwise, if either argument is a floating point number, the other is "
"converted to floating point;"
msgstr ""

#: ../../reference/expressions.rst:39
msgid "otherwise, both must be integers and no conversion is necessary."
msgstr "i annat fall måste båda vara heltal och ingen konvertering behövs."

#: ../../reference/expressions.rst:41
msgid ""
"Some additional rules apply for certain operators (e.g., a string as a left "
"argument to the '%' operator).  Extensions must define their own conversion "
"behavior."
msgstr ""
"Vissa ytterligare regler gäller för vissa operatorer (t.ex. en sträng som "
"vänster argument till operatorn '%').  Tillägg måste definiera sitt eget "
"konverteringsbeteende."

#: ../../reference/expressions.rst:49
msgid "Atoms"
msgstr "Atomer"

#: ../../reference/expressions.rst:53
msgid ""
"Atoms are the most basic elements of expressions.  The simplest atoms are "
"identifiers or literals.  Forms enclosed in parentheses, brackets or braces "
"are also categorized syntactically as atoms.  The syntax for atoms is:"
msgstr ""
"Atomer är de mest grundläggande elementen i uttryck.  De enklaste atomerna "
"är identifierare eller literaler.  Former inom parenteser, hakparenteser "
"eller parenteser kategoriseras också syntaktiskt som atomer.  Syntaxen för "
"atomer är:"

#: ../../reference/expressions.rst:66
msgid "Identifiers (Names)"
msgstr "Identifierare (namn)"

#: ../../reference/expressions.rst:70
msgid ""
"An identifier occurring as an atom is a name.  See section :ref:"
"`identifiers` for lexical definition and section :ref:`naming` for "
"documentation of naming and binding."
msgstr ""
"En identifierare som förekommer som en atom är ett namn.  Se avsnitt :ref:"
"`identifiers` för lexikal definition och avsnitt :ref:`naming` för "
"dokumentation av namngivning och bindning."

#: ../../reference/expressions.rst:76
msgid ""
"When the name is bound to an object, evaluation of the atom yields that "
"object. When a name is not bound, an attempt to evaluate it raises a :exc:"
"`NameError` exception."
msgstr ""
"När namnet är bundet till ett objekt, ger utvärderingen av atomen det "
"objektet. När ett namn inte är bundet, ger ett försök att utvärdera det "
"upphov till ett :exc:`NameError` undantag."

#: ../../reference/expressions.rst:86
msgid ""
"**Private name mangling:** When an identifier that textually occurs in a "
"class definition begins with two or more underscore characters and does not "
"end in two or more underscores, it is considered a :dfn:`private name` of "
"that class. Private names are transformed to a longer form before code is "
"generated for them.  The transformation inserts the class name, with leading "
"underscores removed and a single underscore inserted, in front of the name.  "
"For example, the identifier ``__spam`` occurring in a class named ``Ham`` "
"will be transformed to ``_Ham__spam``.  This transformation is independent "
"of the syntactical context in which the identifier is used.  If the "
"transformed name is extremely long (longer than 255 characters), "
"implementation defined truncation may happen. If the class name consists "
"only of underscores, no transformation is done."
msgstr ""

#: ../../reference/expressions.rst:102
msgid "Literals"
msgstr "Bokstäver"

#: ../../reference/expressions.rst:106
msgid "Python supports string and bytes literals and various numeric literals:"
msgstr ""
"Python stöder sträng- och byteslitteraler samt olika numeriska litteraler:"

#: ../../reference/expressions.rst:112
msgid ""
"Evaluation of a literal yields an object of the given type (string, bytes, "
"integer, floating point number, complex number) with the given value.  The "
"value may be approximated in the case of floating point and imaginary "
"(complex) literals.  See section :ref:`literals` for details."
msgstr ""

#: ../../reference/expressions.rst:121
msgid ""
"All literals correspond to immutable data types, and hence the object's "
"identity is less important than its value.  Multiple evaluations of literals "
"with the same value (either the same occurrence in the program text or a "
"different occurrence) may obtain the same object or a different object with "
"the same value."
msgstr ""
"Alla literaler motsvarar oföränderliga datatyper, och därför är objektets "
"identitet mindre viktig än dess värde.  Flera utvärderingar av litteraler "
"med samma värde (antingen samma förekomst i programtexten eller en annan "
"förekomst) kan ge samma objekt eller ett annat objekt med samma värde."

#: ../../reference/expressions.rst:131
msgid "Parenthesized forms"
msgstr "Formulär inom parentes"

#: ../../reference/expressions.rst:137
msgid ""
"A parenthesized form is an optional expression list enclosed in parentheses:"
msgstr "En parentesform är en lista med valfria uttryck inom parentes:"

#: ../../reference/expressions.rst:142
msgid ""
"A parenthesized expression list yields whatever that expression list yields: "
"if the list contains at least one comma, it yields a tuple; otherwise, it "
"yields the single expression that makes up the expression list."
msgstr ""
"En uttrycksförteckning med parenteser ger det som uttrycksförteckningen ger: "
"om förteckningen innehåller minst ett kommatecken ger den en tupel, annars "
"ger den det enskilda uttryck som utgör uttrycksförteckningen."

#: ../../reference/expressions.rst:148
msgid ""
"An empty pair of parentheses yields an empty tuple object.  Since tuples are "
"immutable, the same rules as for literals apply (i.e., two occurrences of "
"the empty tuple may or may not yield the same object)."
msgstr ""
"Ett tomt par parenteser ger ett tomt tupelobjekt.  Eftersom tuplar är "
"oföränderliga gäller samma regler som för literals (dvs. två förekomster av "
"den tomma tupeln kan ge eller inte ge samma objekt)."

#: ../../reference/expressions.rst:156
msgid ""
"Note that tuples are not formed by the parentheses, but rather by use of the "
"comma.  The exception is the empty tuple, for which parentheses *are* "
"required --- allowing unparenthesized \"nothing\" in expressions would cause "
"ambiguities and allow common typos to pass uncaught."
msgstr ""
"Observera att tupler inte bildas av parenteserna, utan snarare genom att "
"använda kommatecken.  Undantaget är den tomma tupeln, för vilken parenteser "
"*krävs* --- att tillåta \"ingenting\" utan parenteser i uttryck skulle "
"orsaka tvetydigheter och tillåta vanliga typfel att passera utan att "
"upptäckas."

#: ../../reference/expressions.rst:165
msgid "Displays for lists, sets and dictionaries"
msgstr "Displayer för listor, uppsättningar och ordböcker"

#: ../../reference/expressions.rst:169
msgid ""
"For constructing a list, a set or a dictionary Python provides special "
"syntax called \"displays\", each of them in two flavors:"
msgstr ""
"För att konstruera en lista, en uppsättning eller en ordbok tillhandahåller "
"Python en speciell syntax som kallas \"displays\", var och en av dem i två "
"varianter:"

#: ../../reference/expressions.rst:172
msgid "either the container contents are listed explicitly, or"
msgstr "antingen anges innehållet i behållaren uttryckligen, eller"

#: ../../reference/expressions.rst:174
msgid ""
"they are computed via a set of looping and filtering instructions, called a :"
"dfn:`comprehension`."
msgstr ""
"de beräknas via en uppsättning loopnings- och filtreringsinstruktioner, "
"kallad en :dfn:`comprehension`."

#: ../../reference/expressions.rst:182
msgid "Common syntax elements for comprehensions are:"
msgstr "Vanliga syntaxelement för förståelser är:"

#: ../../reference/expressions.rst:190
msgid ""
"The comprehension consists of a single expression followed by at least one :"
"keyword:`!for` clause and zero or more :keyword:`!for` or :keyword:`!if` "
"clauses. In this case, the elements of the new container are those that "
"would be produced by considering each of the :keyword:`!for` or :keyword:`!"
"if` clauses a block, nesting from left to right, and evaluating the "
"expression to produce an element each time the innermost block is reached."
msgstr ""
"Förståelsen består av ett enda uttryck följt av minst en :keyword:`!for`-"
"klausul och noll eller fler :keyword:`!for`- eller :keyword:`!if`-klausuler. "
"I detta fall är elementen i den nya behållaren de som skulle produceras "
"genom att betrakta var och en av :keyword:`!for`- eller :keyword:`!if`-"
"klausulerna som ett block, nestning från vänster till höger och utvärdering "
"av uttrycket för att producera ett element varje gång det innersta blocket "
"nås."

#: ../../reference/expressions.rst:197
msgid ""
"However, aside from the iterable expression in the leftmost :keyword:`!for` "
"clause, the comprehension is executed in a separate implicitly nested scope. "
"This ensures that names assigned to in the target list don't \"leak\" into "
"the enclosing scope."
msgstr ""
"Bortsett från det iterabla uttrycket i :keyword:`!for`-satsen längst till "
"vänster utförs dock förståelsen i ett separat implicit nästlat scope. Detta "
"säkerställer att namn som tilldelats i mållistan inte \"läcker\" in i det "
"omslutande scopet."

#: ../../reference/expressions.rst:201
msgid ""
"The iterable expression in the leftmost :keyword:`!for` clause is evaluated "
"directly in the enclosing scope and then passed as an argument to the "
"implicitly nested scope. Subsequent :keyword:`!for` clauses and any filter "
"condition in the leftmost :keyword:`!for` clause cannot be evaluated in the "
"enclosing scope as they may depend on the values obtained from the leftmost "
"iterable. For example: ``[x*y for x in range(10) for y in range(x, x+10)]``."
msgstr ""
"Det iterabla uttrycket i :keyword:`!for`-satsen längst till vänster "
"utvärderas direkt i det inneslutande scopet och skickas sedan som ett "
"argument till det implicit nästlade scopet. Efterföljande :keyword:`!for`-"
"satser och eventuella filtervillkor i :keyword:`!for`-satsen längst till "
"vänster kan inte utvärderas i det inneslutande scopet eftersom de kan vara "
"beroende av de värden som erhålls från iterabeln längst till vänster. Till "
"exempel: ``[x*y for x in range(10) for y in range(x, x+10)]``."

#: ../../reference/expressions.rst:208
msgid ""
"To ensure the comprehension always results in a container of the appropriate "
"type, ``yield`` and ``yield from`` expressions are prohibited in the "
"implicitly nested scope."
msgstr ""
"För att säkerställa att förståelsen alltid resulterar i en container av rätt "
"typ, är uttrycken ``yield`` och ``yield from`` förbjudna i det implicit "
"nästlade omfånget."

#: ../../reference/expressions.rst:215
msgid ""
"Since Python 3.6, in an :keyword:`async def` function, an :keyword:`!async "
"for` clause may be used to iterate over a :term:`asynchronous iterator`. A "
"comprehension in an :keyword:`!async def` function may consist of either a :"
"keyword:`!for` or :keyword:`!async for` clause following the leading "
"expression, may contain additional :keyword:`!for` or :keyword:`!async for` "
"clauses, and may also use :keyword:`await` expressions. If a comprehension "
"contains either :keyword:`!async for` clauses or :keyword:`!await` "
"expressions or other asynchronous comprehensions it is called an :dfn:"
"`asynchronous comprehension`.  An asynchronous comprehension may suspend the "
"execution of the coroutine function in which it appears. See also :pep:`530`."
msgstr ""

#: ../../reference/expressions.rst:227
msgid "Asynchronous comprehensions were introduced."
msgstr "Asynkrona förståelser introducerades."

#: ../../reference/expressions.rst:230 ../../reference/expressions.rst:408
msgid "``yield`` and ``yield from`` prohibited in the implicitly nested scope."
msgstr ""
"``yield`` och ``yield from`` förbjudna i det implicit nästlade omfånget."

#: ../../reference/expressions.rst:233
msgid ""
"Asynchronous comprehensions are now allowed inside comprehensions in "
"asynchronous functions. Outer comprehensions implicitly become asynchronous."
msgstr ""
"Asynkrona förståelser är nu tillåtna inuti förståelser i asynkrona "
"funktioner. Yttre förståelser blir implicit asynkrona."

#: ../../reference/expressions.rst:242
msgid "List displays"
msgstr "Lista visar"

#: ../../reference/expressions.rst:252
msgid ""
"A list display is a possibly empty series of expressions enclosed in square "
"brackets:"
msgstr ""
"En listdisplay är en eventuellt tom serie av uttryck inom hakparenteser:"

#: ../../reference/expressions.rst:258
msgid ""
"A list display yields a new list object, the contents being specified by "
"either a list of expressions or a comprehension.  When a comma-separated "
"list of expressions is supplied, its elements are evaluated from left to "
"right and placed into the list object in that order.  When a comprehension "
"is supplied, the list is constructed from the elements resulting from the "
"comprehension."
msgstr ""
"En listvisning resulterar i ett nytt listobjekt, vars innehåll specificeras "
"av antingen en lista med uttryck eller en förståelse.  När en kommaseparerad "
"lista med uttryck anges, utvärderas dess element från vänster till höger och "
"placeras i listobjektet i den ordningen.  När en förståelse anges "
"konstrueras listan av de element som blir resultatet av förståelsen."

#: ../../reference/expressions.rst:268
msgid "Set displays"
msgstr "Ställ in skärmar"

#: ../../reference/expressions.rst:277
msgid ""
"A set display is denoted by curly braces and distinguishable from dictionary "
"displays by the lack of colons separating keys and values:"
msgstr ""
"En set-display betecknas med hakparenteser och skiljer sig från en "
"dictionary-display genom att det inte finns några kolon som separerar "
"nycklar och värden:"

#: ../../reference/expressions.rst:283
msgid ""
"A set display yields a new mutable set object, the contents being specified "
"by either a sequence of expressions or a comprehension.  When a comma-"
"separated list of expressions is supplied, its elements are evaluated from "
"left to right and added to the set object.  When a comprehension is "
"supplied, the set is constructed from the elements resulting from the "
"comprehension."
msgstr ""
"En set-visning ger ett nytt muterbart set-objekt, vars innehåll specificeras "
"av antingen en sekvens av uttryck eller en förståelse.  När en "
"kommaseparerad lista med uttryck anges, utvärderas dess element från vänster "
"till höger och läggs till i set-objektet.  När en förståelse anges "
"konstrueras setet av de element som blir resultatet av förståelsen."

#: ../../reference/expressions.rst:289
msgid ""
"An empty set cannot be constructed with ``{}``; this literal constructs an "
"empty dictionary."
msgstr ""
"En tom uppsättning kan inte konstrueras med ``{}``; denna bokstav "
"konstruerar en tom ordbok."

#: ../../reference/expressions.rst:296
msgid "Dictionary displays"
msgstr "Ordbok visar"

#: ../../reference/expressions.rst:307
msgid ""
"A dictionary display is a possibly empty series of dict items (key/value "
"pairs) enclosed in curly braces:"
msgstr ""
"En dictionary-display är en eventuellt tom serie av dict-objekt (nyckel/"
"värde-par) inneslutna inom hakparenteser:"

#: ../../reference/expressions.rst:316
msgid "A dictionary display yields a new dictionary object."
msgstr "En ordboksvisning resulterar i ett nytt ordboksobjekt."

#: ../../reference/expressions.rst:318
msgid ""
"If a comma-separated sequence of dict items is given, they are evaluated "
"from left to right to define the entries of the dictionary: each key object "
"is used as a key into the dictionary to store the corresponding value.  This "
"means that you can specify the same key multiple times in the dict item "
"list, and the final dictionary's value for that key will be the last one "
"given."
msgstr ""
"Om en kommaseparerad sekvens av dict-objekt anges utvärderas de från vänster "
"till höger för att definiera posterna i ordlistan: varje nyckelobjekt "
"används som en nyckel i ordlistan för att lagra motsvarande värde.  Det "
"innebär att du kan ange samma nyckel flera gånger i listan med dict-objekt, "
"och det slutliga värdet i ordboken för den nyckeln kommer att vara det "
"senast angivna."

#: ../../reference/expressions.rst:328
msgid ""
"A double asterisk ``**`` denotes :dfn:`dictionary unpacking`. Its operand "
"must be a :term:`mapping`.  Each mapping item is added to the new "
"dictionary.  Later values replace values already set by earlier dict items "
"and earlier dictionary unpackings."
msgstr ""
"En dubbel asterisk ``**`` betecknar :dfn:`dictionary unpacking`. Dess "
"operand måste vara en :term:`mappning`.  Varje mappningsobjekt läggs till i "
"den nya ordboken.  Senare värden ersätter värden som redan ställts in av "
"tidigare dict-objekt och tidigare uppackningar av ordböcker."

#: ../../reference/expressions.rst:333
msgid "Unpacking into dictionary displays, originally proposed by :pep:`448`."
msgstr ""
"Unpacking into dictionary displays, ursprungligen föreslagen av :pep:`448`."

#: ../../reference/expressions.rst:336
msgid ""
"A dict comprehension, in contrast to list and set comprehensions, needs two "
"expressions separated with a colon followed by the usual \"for\" and \"if\" "
"clauses. When the comprehension is run, the resulting key and value elements "
"are inserted in the new dictionary in the order they are produced."
msgstr ""
"En dict-förståelse, till skillnad från list- och set-förståelser, behöver "
"två uttryck åtskilda med ett kolon följt av de vanliga \"for\"- och \"if\"-"
"klausulerna. När förståelsen körs infogas de resulterande nyckel- och "
"värdeelementen i den nya ordlistan i den ordning de producerades."

#: ../../reference/expressions.rst:344
msgid ""
"Restrictions on the types of the key values are listed earlier in section :"
"ref:`types`.  (To summarize, the key type should be :term:`hashable`, which "
"excludes all mutable objects.)  Clashes between duplicate keys are not "
"detected; the last value (textually rightmost in the display) stored for a "
"given key value prevails."
msgstr ""
"Restriktioner för typerna av nyckelvärden anges tidigare i avsnitt :ref:"
"`types`.  (Sammanfattningsvis bör nyckeltypen vara :term:`hashable`, vilket "
"utesluter alla föränderliga objekt)  Kollisioner mellan duplicerade nycklar "
"upptäcks inte; det sista värdet (textuellt längst till höger i displayen) "
"som lagras för ett visst nyckelvärde har företräde."

#: ../../reference/expressions.rst:350
msgid ""
"Prior to Python 3.8, in dict comprehensions, the evaluation order of key and "
"value was not well-defined.  In CPython, the value was evaluated before the "
"key.  Starting with 3.8, the key is evaluated before the value, as proposed "
"by :pep:`572`."
msgstr ""
"Före Python 3.8 var utvärderingsordningen för nyckel och värde inte "
"väldefinierad i dict-comprehensions.  I CPython utvärderades värdet före "
"nyckeln.  Från och med 3.8 utvärderas nyckeln före värdet, enligt förslaget "
"i :pep:`572`."

#: ../../reference/expressions.rst:360
msgid "Generator expressions"
msgstr "Generatoruttryck"

#: ../../reference/expressions.rst:367
msgid "A generator expression is a compact generator notation in parentheses:"
msgstr "Ett generatoruttryck är en kompakt generatornotation inom parentes:"

#: ../../reference/expressions.rst:372
msgid ""
"A generator expression yields a new generator object.  Its syntax is the "
"same as for comprehensions, except that it is enclosed in parentheses "
"instead of brackets or curly braces."
msgstr ""
"Ett generatoruttryck ger upphov till ett nytt generatorobjekt.  Syntaxen är "
"densamma som för förståelser, förutom att det omges av parenteser istället "
"för parenteser eller hakparenteser."

#: ../../reference/expressions.rst:376
msgid ""
"Variables used in the generator expression are evaluated lazily when the :"
"meth:`~generator.__next__` method is called for the generator object (in the "
"same fashion as normal generators).  However, the iterable expression in the "
"leftmost :keyword:`!for` clause is immediately evaluated, so that an error "
"produced by it will be emitted at the point where the generator expression "
"is defined, rather than at the point where the first value is retrieved. "
"Subsequent :keyword:`!for` clauses and any filter condition in the leftmost :"
"keyword:`!for` clause cannot be evaluated in the enclosing scope as they may "
"depend on the values obtained from the leftmost iterable. For example: "
"``(x*y for x in range(10) for y in range(x, x+10))``."
msgstr ""

#: ../../reference/expressions.rst:387
msgid ""
"The parentheses can be omitted on calls with only one argument.  See "
"section :ref:`calls` for details."
msgstr ""
"Parentesen kan utelämnas vid anrop med endast ett argument.  Se avsnitt :ref:"
"`calls` för detaljer."

#: ../../reference/expressions.rst:390
msgid ""
"To avoid interfering with the expected operation of the generator expression "
"itself, ``yield`` and ``yield from`` expressions are prohibited in the "
"implicitly defined generator."
msgstr ""
"För att inte störa den förväntade funktionen hos själva generatoruttrycket "
"är uttrycken ``yield`` och ``yield from`` förbjudna i den implicit "
"definierade generatorn."

#: ../../reference/expressions.rst:394
msgid ""
"If a generator expression contains either :keyword:`!async for` clauses or :"
"keyword:`await` expressions it is called an :dfn:`asynchronous generator "
"expression`.  An asynchronous generator expression returns a new "
"asynchronous generator object, which is an asynchronous iterator (see :ref:"
"`async-iterators`)."
msgstr ""
"Om ett generatoruttryck innehåller antingen :keyword:`!async for`-klausuler "
"eller :keyword:`await`-uttryck kallas det ett :dfn:`asynkront "
"generatoruttryck`.  Ett asynkront generatoruttryck returnerar ett nytt "
"asynkront generatorobjekt, som är en asynkron iterator (se :ref:`async-"
"iterators`)."

#: ../../reference/expressions.rst:400
msgid "Asynchronous generator expressions were introduced."
msgstr "Asynkrona generatoruttryck infördes."

#: ../../reference/expressions.rst:403
msgid ""
"Prior to Python 3.7, asynchronous generator expressions could only appear "
"in :keyword:`async def` coroutines.  Starting with 3.7, any function can use "
"asynchronous generator expressions."
msgstr ""
"Före Python 3.7 kunde asynkrona generatoruttryck endast förekomma i :keyword:"
"`async def` coroutines.  Från och med 3.7 kan alla funktioner använda "
"asynkrona generatoruttryck."

#: ../../reference/expressions.rst:415
msgid "Yield expressions"
msgstr "Avkastningsuttryck"

#: ../../reference/expressions.rst:428
msgid ""
"The yield expression is used when defining a :term:`generator` function or "
"an :term:`asynchronous generator` function and thus can only be used in the "
"body of a function definition.  Using a yield expression in a function's "
"body causes that function to be a generator function, and using it in an :"
"keyword:`async def` function's body causes that coroutine function to be an "
"asynchronous generator function. For example::"
msgstr ""
"Yield-uttrycket används när man definierar en :term:`generator`-funktion "
"eller en :term:`asynkron generator`-funktion och kan därför bara användas i "
"en funktionsdefinition.  Om du använder ett yield-uttryck i en funktions "
"kropp blir funktionen en generatorfunktion och om du använder det i en :"
"keyword:`async def`-funktions kropp blir coroutine-funktionen en asynkron "
"generatorfunktion. Till exempel::"

#: ../../reference/expressions.rst:441
msgid ""
"Due to their side effects on the containing scope, ``yield`` expressions are "
"not permitted as part of the implicitly defined scopes used to implement "
"comprehensions and generator expressions."
msgstr ""
"På grund av sina bieffekter på det innehållande omfånget är ``yield``-"
"uttryck inte tillåtna som en del av de implicit definierade omfång som "
"används för att implementera förståelser och generatoruttryck."

#: ../../reference/expressions.rst:445
msgid ""
"Yield expressions prohibited in the implicitly nested scopes used to "
"implement comprehensions and generator expressions."
msgstr ""
"Yield-uttryck som är förbjudna i de implicit nästlade scopes som används för "
"att implementera förståelser och generatoruttryck."

#: ../../reference/expressions.rst:449
msgid ""
"Generator functions are described below, while asynchronous generator "
"functions are described separately in section :ref:`asynchronous-generator-"
"functions`."
msgstr ""
"Generatorfunktioner beskrivs nedan, medan asynkrona generatorfunktioner "
"beskrivs separat i avsnitt :ref:``asynchronous-generator-functions``."

#: ../../reference/expressions.rst:453
msgid ""
"When a generator function is called, it returns an iterator known as a "
"generator.  That generator then controls the execution of the generator "
"function.  The execution starts when one of the generator's methods is "
"called. At that time, the execution proceeds to the first yield expression, "
"where it is suspended again, returning the value of :token:`~python-grammar:"
"expression_list` to the generator's caller, or ``None`` if :token:`~python-"
"grammar:expression_list` is omitted. By suspended, we mean that all local "
"state is retained, including the current bindings of local variables, the "
"instruction pointer, the internal evaluation stack, and the state of any "
"exception handling. When the execution is resumed by calling one of the "
"generator's methods, the function can proceed exactly as if the yield "
"expression were just another external call.  The value of the yield "
"expression after resuming depends on the method which resumed the "
"execution.  If :meth:`~generator.__next__` is used (typically via either a :"
"keyword:`for` or the :func:`next` builtin) then the result is :const:"
"`None`.  Otherwise, if :meth:`~generator.send` is used, then the result will "
"be the value passed in to that method."
msgstr ""

#: ../../reference/expressions.rst:473
msgid ""
"All of this makes generator functions quite similar to coroutines; they "
"yield multiple times, they have more than one entry point and their "
"execution can be suspended.  The only difference is that a generator "
"function cannot control where the execution should continue after it yields; "
"the control is always transferred to the generator's caller."
msgstr ""
"Allt detta gör generatorfunktioner ganska lika coroutines; de ger flera "
"gånger, de har mer än en ingångspunkt och deras exekvering kan avbrytas.  "
"Den enda skillnaden är att en generatorfunktion inte kan styra var "
"exekveringen ska fortsätta efter att den har gett upp; kontrollen överförs "
"alltid till generatorns anropare."

#: ../../reference/expressions.rst:479
msgid ""
"Yield expressions are allowed anywhere in a :keyword:`try` construct.  If "
"the generator is not resumed before it is finalized (by reaching a zero "
"reference count or by being garbage collected), the generator-iterator's :"
"meth:`~generator.close` method will be called, allowing any pending :keyword:"
"`finally` clauses to execute."
msgstr ""
"Yield-uttryck är tillåtna var som helst i en :keyword:`try`-konstruktion.  "
"Om generatorn inte återupptas innan den är avslutad (genom att "
"referensantalet blir noll eller genom att den samlas in), kommer generator-"
"iteratorns :meth:`~generator.close`-metod att anropas, vilket gör att alla "
"väntande :keyword:`finally`-klausuler kan utföras."

#: ../../reference/expressions.rst:488
msgid ""
"When ``yield from <expr>`` is used, the supplied expression must be an "
"iterable. The values produced by iterating that iterable are passed directly "
"to the caller of the current generator's methods. Any values passed in with :"
"meth:`~generator.send` and any exceptions passed in with :meth:`~generator."
"throw` are passed to the underlying iterator if it has the appropriate "
"methods.  If this is not the case, then :meth:`~generator.send` will raise :"
"exc:`AttributeError` or :exc:`TypeError`, while :meth:`~generator.throw` "
"will just raise the passed in exception immediately."
msgstr ""
"När ``yield from <expr>`` används måste det medföljande uttrycket vara en "
"iterabel. De värden som produceras genom att iterera denna iterabel skickas "
"direkt till den som anropar den aktuella generatorns metoder. Alla värden "
"som skickas in med :meth:`~generator.send` och alla undantag som skickas in "
"med :meth:`~generator.throw` skickas till den underliggande iteratorn om den "
"har lämpliga metoder.  Om så inte är fallet kommer :meth:`~generator.send` "
"att ge upphov till :exc:`AttributeError` eller :exc:`TypeError`, medan :meth:"
"`~generator.throw` bara kommer att ge upphov till det undantag som skickats "
"in omedelbart."

#: ../../reference/expressions.rst:497
msgid ""
"When the underlying iterator is complete, the :attr:`~StopIteration.value` "
"attribute of the raised :exc:`StopIteration` instance becomes the value of "
"the yield expression. It can be either set explicitly when raising :exc:"
"`StopIteration`, or automatically when the subiterator is a generator (by "
"returning a value from the subgenerator)."
msgstr ""
"När den underliggande iteratorn är klar blir attributet :attr:"
"`~StopIteration.value` i den upphöjda :exc:`StopIteration`-instansen värdet "
"på yield-uttrycket. Det kan antingen sättas explicit när :exc:"
"`StopIteration` väcks, eller automatiskt när subiteratorn är en generator "
"(genom att returnera ett värde från subgeneratorn)."

#: ../../reference/expressions.rst:503
msgid "Added ``yield from <expr>`` to delegate control flow to a subiterator."
msgstr ""
"Lagt till ``yield from <expr>`` för att delegera kontrollflödet till en "
"subiterator."

#: ../../reference/expressions.rst:506
msgid ""
"The parentheses may be omitted when the yield expression is the sole "
"expression on the right hand side of an assignment statement."
msgstr ""
"Parenteserna kan utelämnas när yield-uttrycket är det enda uttrycket på "
"höger sida av en assignment-sats."

#: ../../reference/expressions.rst:512
msgid ":pep:`255` - Simple Generators"
msgstr ":pep:`255` - Enkla generatorer"

#: ../../reference/expressions.rst:512
msgid ""
"The proposal for adding generators and the :keyword:`yield` statement to "
"Python."
msgstr ""
"Förslaget att lägga till generatorer och :keyword:`yield`-satsen i Python."

#: ../../reference/expressions.rst:516
msgid ":pep:`342` - Coroutines via Enhanced Generators"
msgstr ":pep:`342` - Coroutines via förbättrade generatorer"

#: ../../reference/expressions.rst:515
msgid ""
"The proposal to enhance the API and syntax of generators, making them usable "
"as simple coroutines."
msgstr ""
"Förslaget att förbättra API:et och syntaxen för generatorer, så att de kan "
"användas som enkla coroutines."

#: ../../reference/expressions.rst:520
msgid ":pep:`380` - Syntax for Delegating to a Subgenerator"
msgstr ":pep:`380` - Syntax för att delegera till en undergenerator"

#: ../../reference/expressions.rst:519
msgid ""
"The proposal to introduce the :token:`~python-grammar:yield_from` syntax, "
"making delegation to subgenerators easy."
msgstr ""
"Förslaget att införa syntaxen :token:`~python-grammar:yield_from`, vilket "
"gör det enkelt att delegera till undergenererare."

#: ../../reference/expressions.rst:523
msgid ":pep:`525` - Asynchronous Generators"
msgstr ":pep:`525` - Asynkrona generatorer"

#: ../../reference/expressions.rst:523
msgid ""
"The proposal that expanded on :pep:`492` by adding generator capabilities to "
"coroutine functions."
msgstr ""
"Förslaget som utökade :pep:`492` genom att lägga till generatormöjligheter "
"till coroutine-funktioner."

#: ../../reference/expressions.rst:530
msgid "Generator-iterator methods"
msgstr "Generator-iterator-metoder"

#: ../../reference/expressions.rst:532
msgid ""
"This subsection describes the methods of a generator iterator.  They can be "
"used to control the execution of a generator function."
msgstr ""
"I detta underavsnitt beskrivs metoderna för en generatoriterator.  De kan "
"användas för att styra utförandet av en generatorfunktion."

#: ../../reference/expressions.rst:535
msgid ""
"Note that calling any of the generator methods below when the generator is "
"already executing raises a :exc:`ValueError` exception."
msgstr ""
"Observera att anrop av någon av generatormetoderna nedan när generatorn "
"redan körs ger upphov till ett :exc:`ValueError`-undantag."

#: ../../reference/expressions.rst:543
msgid ""
"Starts the execution of a generator function or resumes it at the last "
"executed yield expression.  When a generator function is resumed with a :"
"meth:`~generator.__next__` method, the current yield expression always "
"evaluates to :const:`None`.  The execution then continues to the next yield "
"expression, where the generator is suspended again, and the value of the :"
"token:`~python-grammar:expression_list` is returned to :meth:`__next__`'s "
"caller.  If the generator exits without yielding another value, a :exc:"
"`StopIteration` exception is raised."
msgstr ""

#: ../../reference/expressions.rst:552
msgid ""
"This method is normally called implicitly, e.g. by a :keyword:`for` loop, or "
"by the built-in :func:`next` function."
msgstr ""
"Denna metod anropas normalt implicit, t.ex. av en :keyword:`for`-loop, eller "
"av den inbyggda :func:`next`-funktionen."

#: ../../reference/expressions.rst:558
msgid ""
"Resumes the execution and \"sends\" a value into the generator function.  "
"The *value* argument becomes the result of the current yield expression.  "
"The :meth:`send` method returns the next value yielded by the generator, or "
"raises :exc:`StopIteration` if the generator exits without yielding another "
"value.  When :meth:`send` is called to start the generator, it must be "
"called with :const:`None` as the argument, because there is no yield "
"expression that could receive the value."
msgstr ""
"Återupptar exekveringen och \"skickar\" ett värde till generatorfunktionen.  "
"Argumentet *value* blir resultatet av det aktuella yield-uttrycket.  "
"Metoden :meth:`send` returnerar nästa värde som generatorn ger, eller ger "
"upphov till :exc:`StopIteration` om generatorn avslutas utan att ge något "
"annat värde.  När :meth:`send` anropas för att starta generatorn måste den "
"anropas med :const:`None` som argument, eftersom det inte finns något yield-"
"uttryck som kan ta emot värdet."

#: ../../reference/expressions.rst:570
msgid ""
"Raises an exception at the point where the generator was paused, and returns "
"the next value yielded by the generator function.  If the generator exits "
"without yielding another value, a :exc:`StopIteration` exception is raised.  "
"If the generator function does not catch the passed-in exception, or raises "
"a different exception, then that exception propagates to the caller."
msgstr ""
"Utlöser ett undantag vid den punkt där generatorn pausades och returnerar "
"nästa värde som generatorns funktion ger.  Om generatorn avslutas utan att "
"ge något annat värde, utlöses ett :exc:`StopIteration`-undantag.  Om "
"generatorfunktionen inte fångar upp det överlämnade undantaget, eller om ett "
"annat undantag uppstår, sprids undantaget till den som anropar."

#: ../../reference/expressions.rst:576
msgid ""
"In typical use, this is called with a single exception instance similar to "
"the way the :keyword:`raise` keyword is used."
msgstr ""
"I normal användning anropas detta med en enda undantagsinstans på liknande "
"sätt som nyckelordet :keyword:`raise` används."

#: ../../reference/expressions.rst:579
msgid ""
"For backwards compatibility, however, the second signature is supported, "
"following a convention from older versions of Python. The *type* argument "
"should be an exception class, and *value* should be an exception instance. "
"If the *value* is not provided, the *type* constructor is called to get an "
"instance. If *traceback* is provided, it is set on the exception, otherwise "
"any existing :attr:`~BaseException.__traceback__` attribute stored in "
"*value* may be cleared."
msgstr ""
"För bakåtkompatibilitet stöds dock den andra signaturen, enligt en "
"konvention från äldre versioner av Python. Argumentet *type* ska vara en "
"undantagsklass och *value* ska vara en undantagsinstans. Om *value* inte "
"anges anropas konstruktören *type* för att hämta en instans. Om *traceback* "
"anges, sätts det på undantaget, annars kan alla befintliga :attr:"
"`~BaseException.__traceback__`-attribut som lagras i *value* rensas."

#: ../../reference/expressions.rst:593
msgid ""
"Raises a :exc:`GeneratorExit` at the point where the generator function was "
"paused.  If the generator function then exits gracefully, is already closed, "
"or raises :exc:`GeneratorExit` (by not catching the exception), close "
"returns to its caller.  If the generator yields a value, a :exc:"
"`RuntimeError` is raised.  If the generator raises any other exception, it "
"is propagated to the caller.  :meth:`close` does nothing if the generator "
"has already exited due to an exception or normal exit."
msgstr ""

#: ../../reference/expressions.rst:604
msgid "Examples"
msgstr "Exempel"

#: ../../reference/expressions.rst:606
msgid ""
"Here is a simple example that demonstrates the behavior of generators and "
"generator functions::"
msgstr ""
"Här följer ett enkelt exempel som visar hur generatorer och "
"generatorfunktioner fungerar::"

#: ../../reference/expressions.rst:633
msgid ""
"For examples using ``yield from``, see :ref:`pep-380` in \"What's New in "
"Python.\""
msgstr ""
"För exempel på användning av ``yield from``, se :ref:`pep-380` i \"What's "
"New in Python\""

#: ../../reference/expressions.rst:639
msgid "Asynchronous generator functions"
msgstr "Asynkrongeneratorfunktioner"

#: ../../reference/expressions.rst:641
msgid ""
"The presence of a yield expression in a function or method defined using :"
"keyword:`async def` further defines the function as an :term:`asynchronous "
"generator` function."
msgstr ""
"Närvaron av ett yield-uttryck i en funktion eller metod som definieras med :"
"keyword:`async def` definierar funktionen ytterligare som en :term:`asynkron "
"generator`-funktion."

#: ../../reference/expressions.rst:645
msgid ""
"When an asynchronous generator function is called, it returns an "
"asynchronous iterator known as an asynchronous generator object. That object "
"then controls the execution of the generator function. An asynchronous "
"generator object is typically used in an :keyword:`async for` statement in a "
"coroutine function analogously to how a generator object would be used in a :"
"keyword:`for` statement."
msgstr ""
"När en asynkron generatorfunktion anropas returnerar den en asynkron "
"iterator, ett så kallat asynkront generatorobjekt. Det objektet styr sedan "
"exekveringen av generatorfunktionen. Ett asynkront generatorobjekt används "
"vanligtvis i en :keyword:`async for`-sats i en coroutine-funktion på samma "
"sätt som ett generatorobjekt skulle användas i en :keyword:`for`-sats."

#: ../../reference/expressions.rst:652
msgid ""
"Calling one of the asynchronous generator's methods returns an :term:"
"`awaitable` object, and the execution starts when this object is awaited on. "
"At that time, the execution proceeds to the first yield expression, where it "
"is suspended again, returning the value of :token:`~python-grammar:"
"expression_list` to the awaiting coroutine. As with a generator, suspension "
"means that all local state is retained, including the current bindings of "
"local variables, the instruction pointer, the internal evaluation stack, and "
"the state of any exception handling. When the execution is resumed by "
"awaiting on the next object returned by the asynchronous generator's "
"methods, the function can proceed exactly as if the yield expression were "
"just another external call. The value of the yield expression after resuming "
"depends on the method which resumed the execution.  If :meth:`~agen."
"__anext__` is used then the result is :const:`None`. Otherwise, if :meth:"
"`~agen.asend` is used, then the result will be the value passed in to that "
"method."
msgstr ""

#: ../../reference/expressions.rst:667
msgid ""
"If an asynchronous generator happens to exit early by :keyword:`break`, the "
"caller task being cancelled, or other exceptions, the generator's async "
"cleanup code will run and possibly raise exceptions or access context "
"variables in an unexpected context--perhaps after the lifetime of tasks it "
"depends, or during the event loop shutdown when the async-generator garbage "
"collection hook is called. To prevent this, the caller must explicitly close "
"the async generator by calling :meth:`~agen.aclose` method to finalize the "
"generator and ultimately detach it from the event loop."
msgstr ""
"Om en asynkron generator avslutas tidigt genom :keyword:`break`, att den "
"anropande uppgiften avbryts eller andra undantag, kommer generatorns "
"asynkrona uppstädningskod att köras och eventuellt ge upphov till undantag "
"eller åtkomst till kontextvariabler i ett oväntat sammanhang - kanske efter "
"livstiden för de uppgifter den är beroende av, eller under nedstängningen av "
"händelseslingan när async-generatorens garbage collection hook anropas. För "
"att förhindra detta måste anroparen uttryckligen stänga async-generatorn "
"genom att anropa :meth:`~agen.aclose`-metoden för att slutföra generatorn "
"och slutligen koppla bort den från händelseslingan."

#: ../../reference/expressions.rst:677
msgid ""
"In an asynchronous generator function, yield expressions are allowed "
"anywhere in a :keyword:`try` construct. However, if an asynchronous "
"generator is not resumed before it is finalized (by reaching a zero "
"reference count or by being garbage collected), then a yield expression "
"within a :keyword:`!try` construct could result in a failure to execute "
"pending :keyword:`finally` clauses.  In this case, it is the responsibility "
"of the event loop or scheduler running the asynchronous generator to call "
"the asynchronous generator-iterator's :meth:`~agen.aclose` method and run "
"the resulting coroutine object, thus allowing any pending :keyword:`!"
"finally` clauses to execute."
msgstr ""
"I en asynkron generatorfunktion är yield-uttryck tillåtna var som helst i "
"en :keyword:`try`-konstruktion. Men om en asynkron generator inte återupptas "
"innan den avslutas (genom att referensantalet blir noll eller genom att den "
"samlas in i en s.k. garbage collection), kan ett yield-uttryck i en :keyword:"
"`!try`-konstruktion leda till att väntande :keyword:`finally`-klausuler inte "
"kan exekveras.  I detta fall är det ansvaret för den händelseslinga eller "
"schemaläggare som kör den asynkrona generatorn att anropa den asynkrona "
"generator-iteratorns :meth:`~agen.aclose`-metod och köra det resulterande "
"coroutine-objektet, så att eventuella väntande :keyword:`!finally`-klausuler "
"kan exekveras."

#: ../../reference/expressions.rst:688
msgid ""
"To take care of finalization upon event loop termination, an event loop "
"should define a *finalizer* function which takes an asynchronous generator-"
"iterator and presumably calls :meth:`~agen.aclose` and executes the "
"coroutine. This  *finalizer* may be registered by calling :func:`sys."
"set_asyncgen_hooks`. When first iterated over, an asynchronous generator-"
"iterator will store the registered *finalizer* to be called upon "
"finalization. For a reference example of a *finalizer* method see the "
"implementation of ``asyncio.Loop.shutdown_asyncgens`` in :source:`Lib/"
"asyncio/base_events.py`."
msgstr ""
"För att ta hand om avslutning vid avslutning av en händelseslinga bör en "
"händelseslinga definiera en *finalizer*-funktion som tar en asynkron "
"generator-iterator och förmodligen anropar :meth:`~agen.aclose` och kör "
"coroutinen. Denna *finalizer* kan registreras genom att anropa :func:`sys."
"set_asyncgen_hooks`. Vid första iterationen över en asynkron generator-"
"iterator lagras den registrerade *finalizer* som anropas vid slutförande. "
"För ett referensexempel på en *finalizer*-metod se implementeringen av "
"``asyncio.Loop.shutdown_asyncgens`` i :source:`Lib/asyncio/base_events.py`."

#: ../../reference/expressions.rst:697
msgid ""
"The expression ``yield from <expr>`` is a syntax error when used in an "
"asynchronous generator function."
msgstr ""
"Uttrycket ``yield from <expr>`` är ett syntaxfel när det används i en "
"asynkron generatorfunktion."

#: ../../reference/expressions.rst:704
msgid "Asynchronous generator-iterator methods"
msgstr "Asynkrona generator-iterator-metoder"

#: ../../reference/expressions.rst:706
msgid ""
"This subsection describes the methods of an asynchronous generator iterator, "
"which are used to control the execution of a generator function."
msgstr ""
"I detta underavsnitt beskrivs metoderna för en asynkron generatoriterator, "
"som används för att styra exekveringen av en generatorfunktion."

#: ../../reference/expressions.rst:714
msgid ""
"Returns an awaitable which when run starts to execute the asynchronous "
"generator or resumes it at the last executed yield expression.  When an "
"asynchronous generator function is resumed with an :meth:`~agen.__anext__` "
"method, the current yield expression always evaluates to :const:`None` in "
"the returned awaitable, which when run will continue to the next yield "
"expression. The value of the :token:`~python-grammar:expression_list` of the "
"yield expression is the value of the :exc:`StopIteration` exception raised "
"by the completing coroutine.  If the asynchronous generator exits without "
"yielding another value, the awaitable instead raises a :exc:"
"`StopAsyncIteration` exception, signalling that the asynchronous iteration "
"has completed."
msgstr ""

#: ../../reference/expressions.rst:726
msgid ""
"This method is normally called implicitly by a :keyword:`async for` loop."
msgstr ""
"Denna metod anropas normalt implicit av en :keyword:`async for`-slinga."

#: ../../reference/expressions.rst:731
msgid ""
"Returns an awaitable which when run resumes the execution of the "
"asynchronous generator. As with the :meth:`~generator.send()` method for a "
"generator, this \"sends\" a value into the asynchronous generator function, "
"and the *value* argument becomes the result of the current yield expression. "
"The awaitable returned by the :meth:`asend` method will return the next "
"value yielded by the generator as the value of the raised :exc:"
"`StopIteration`, or raises :exc:`StopAsyncIteration` if the asynchronous "
"generator exits without yielding another value.  When :meth:`asend` is "
"called to start the asynchronous generator, it must be called with :const:"
"`None` as the argument, because there is no yield expression that could "
"receive the value."
msgstr ""

#: ../../reference/expressions.rst:747
msgid ""
"Returns an awaitable that raises an exception of type ``type`` at the point "
"where the asynchronous generator was paused, and returns the next value "
"yielded by the generator function as the value of the raised :exc:"
"`StopIteration` exception.  If the asynchronous generator exits without "
"yielding another value, a :exc:`StopAsyncIteration` exception is raised by "
"the awaitable. If the generator function does not catch the passed-in "
"exception, or raises a different exception, then when the awaitable is run "
"that exception propagates to the caller of the awaitable."
msgstr ""
"Returnerar en awaitable som utlöser ett undantag av typen ``type`` vid den "
"punkt där den asynkrona generatorn pausades, och returnerar nästa värde som "
"genereras av generatorfunktionen som värdet på det utlösta :exc:"
"`StopIteration`-undantaget.  Om den asynkrona generatorn avslutas utan att "
"ge något annat värde, väcks ett :exc:`StopAsyncIteration`-undantag av "
"awaitable. Om generatorfunktionen inte fångar upp det överlämnade "
"undantaget, eller väcker ett annat undantag, när awaitable körs, sprids "
"undantaget till den som anropar awaitable."

#: ../../reference/expressions.rst:762
msgid ""
"Returns an awaitable that when run will throw a :exc:`GeneratorExit` into "
"the asynchronous generator function at the point where it was paused. If the "
"asynchronous generator function then exits gracefully, is already closed, or "
"raises :exc:`GeneratorExit` (by not catching the exception), then the "
"returned awaitable will raise a :exc:`StopIteration` exception. Any further "
"awaitables returned by subsequent calls to the asynchronous generator will "
"raise a :exc:`StopAsyncIteration` exception.  If the asynchronous generator "
"yields a value, a :exc:`RuntimeError` is raised by the awaitable.  If the "
"asynchronous generator raises any other exception, it is propagated to the "
"caller of the awaitable.  If the asynchronous generator has already exited "
"due to an exception or normal exit, then further calls to :meth:`aclose` "
"will return an awaitable that does nothing."
msgstr ""
"Returnerar en awaitable som när den körs kommer att kasta en :exc:"
"`GeneratorExit` till den asynkrona generatorfunktionen vid den punkt där den "
"pausades. Om den asynkrona generatorfunktionen sedan avslutas på ett elegant "
"sätt, redan är stängd, eller ger upphov till :exc:`GeneratorExit` (genom att "
"inte fånga upp undantaget), så kommer den returnerade awaitable att ge "
"upphov till ett :exc:`StopIteration` undantag. Alla ytterligare awaitables "
"som returneras av efterföljande anrop till den asynkrona generatorn kommer "
"att ge upphov till ett :exc:`StopAsyncIteration`-undantag.  Om den asynkrona "
"generatorn ger ett värde, kommer ett :exc:`RuntimeError` att uppstå i "
"awaitable.  Om den asynkrona generatorn ger upphov till något annat "
"undantag, sprids det till den som anropar awaitable.  Om den asynkrona "
"generatorn redan har avslutats på grund av ett undantag eller en normal "
"avslutning, kommer ytterligare anrop till :meth:`aclose` att returnera en "
"awaitable som inte gör någonting."

#: ../../reference/expressions.rst:778
msgid "Primaries"
msgstr "Primärval"

#: ../../reference/expressions.rst:782
msgid ""
"Primaries represent the most tightly bound operations of the language. Their "
"syntax is:"
msgstr ""
"Primaries representerar de mest bundna operationerna i språket. Deras syntax "
"är:"

#: ../../reference/expressions.rst:792
msgid "Attribute references"
msgstr "Attributreferenser"

#: ../../reference/expressions.rst:798
msgid "An attribute reference is a primary followed by a period and a name:"
msgstr "En attributreferens är en primär följt av en punkt och ett namn:"

#: ../../reference/expressions.rst:808
msgid ""
"The primary must evaluate to an object of a type that supports attribute "
"references, which most objects do.  This object is then asked to produce the "
"attribute whose name is the identifier. The type and value produced is "
"determined by the object.  Multiple evaluations of the same attribute "
"reference may yield different objects."
msgstr ""
"Primären måste utvärderas till ett objekt av en typ som stöder "
"attributreferenser, vilket de flesta objekt gör.  Detta objekt ombeds sedan "
"att producera det attribut vars namn är identifieraren. Den typ och det "
"värde som produceras bestäms av objektet.  Flera utvärderingar av samma "
"attributreferens kan ge olika objekt."

#: ../../reference/expressions.rst:814
msgid ""
"This production can be customized by overriding the :meth:`~object."
"__getattribute__` method or the :meth:`~object.__getattr__` method.  The :"
"meth:`!__getattribute__` method is called first and either returns a value "
"or raises :exc:`AttributeError` if the attribute is not available."
msgstr ""
"Denna produktion kan anpassas genom att åsidosätta metoden :meth:`~object."
"__getattribute__` eller metoden :meth:`~object.__getattr__`.  Metoden :meth:"
"`!__getattribute__` anropas först och returnerar antingen ett värde eller "
"ger upphov till :exc:`AttributeError` om attributet inte är tillgängligt."

#: ../../reference/expressions.rst:820
msgid ""
"If an :exc:`AttributeError` is raised and the object has a :meth:`!"
"__getattr__` method, that method is called as a fallback."
msgstr ""
"Om ett :exc:`AttributeError` uppstår och objektet har en :meth:`!"
"__getattr__`-metod, anropas den metoden som en fallback."

#: ../../reference/expressions.rst:826
msgid "Subscriptions"
msgstr "Prenumerationer"

#: ../../reference/expressions.rst:841
msgid ""
"The subscription of an instance of a :ref:`container class <sequence-types>` "
"will generally select an element from the container. The subscription of a :"
"term:`generic class <generic type>` will generally return a :ref:"
"`GenericAlias <types-genericalias>` object."
msgstr ""
"Prenumerationen av en instans av en :ref:`container class <sequence-types>` "
"kommer i allmänhet att välja ett element från containern. Prenumerationen av "
"en :term:`generic class <generic type>` kommer i allmänhet att returnera "
"ett :ref:`GenericAlias <types-genericalias>` objekt."

#: ../../reference/expressions.rst:849
msgid ""
"When an object is subscripted, the interpreter will evaluate the primary and "
"the expression list."
msgstr ""
"När ett objekt prenumereras kommer tolken att utvärdera primären och "
"uttrycksförteckningen."

#: ../../reference/expressions.rst:852
msgid ""
"The primary must evaluate to an object that supports subscription. An object "
"may support subscription through defining one or both of :meth:`~object."
"__getitem__` and :meth:`~object.__class_getitem__`. When the primary is "
"subscripted, the evaluated result of the expression list will be passed to "
"one of these methods. For more details on when ``__class_getitem__`` is "
"called instead of ``__getitem__``, see :ref:`classgetitem-versus-getitem`."
msgstr ""
"Primären måste utvärderas till ett objekt som stöder prenumeration. Ett "
"objekt kan stödja prenumeration genom att definiera en eller båda av :meth:"
"`~object.__getitem__` och :meth:`~object.__class_getitem__`. När primären är "
"abonnerad kommer det utvärderade resultatet av uttryckslistan att skickas "
"till en av dessa metoder. För mer information om när ``__class_getitem__`` "
"anropas i stället för ``__getitem__``, se :ref:`classgetitem-versus-getitem`."

#: ../../reference/expressions.rst:859
msgid ""
"If the expression list contains at least one comma, it will evaluate to a :"
"class:`tuple` containing the items of the expression list. Otherwise, the "
"expression list will evaluate to the value of the list's sole member."
msgstr ""

#: ../../reference/expressions.rst:863
msgid ""
"For built-in objects, there are two types of objects that support "
"subscription via :meth:`~object.__getitem__`:"
msgstr ""
"För inbyggda objekt finns det två typer av objekt som stöder prenumeration "
"via :meth:`~object.__getitem__`:"

#: ../../reference/expressions.rst:866
msgid ""
"Mappings. If the primary is a :term:`mapping`, the expression list must "
"evaluate to an object whose value is one of the keys of the mapping, and the "
"subscription selects the value in the mapping that corresponds to that key. "
"An example of a builtin mapping class is the :class:`dict` class."
msgstr ""
"Mappningar. Om primären är en :term:`mappning` måste uttryckslistan "
"utvärderas till ett objekt vars värde är en av nycklarna i mappningen, och "
"prenumerationen väljer det värde i mappningen som motsvarar den nyckeln. Ett "
"exempel på en inbyggd mappningsklass är klassen :class:`dict`."

#: ../../reference/expressions.rst:870
msgid ""
"Sequences. If the primary is a :term:`sequence`, the expression list must "
"evaluate to an :class:`int` or a :class:`slice` (as discussed in the "
"following section). Examples of builtin sequence classes include the :class:"
"`str`, :class:`list` and :class:`tuple` classes."
msgstr ""
"Sekvenser. Om primären är en :term:`sequence` måste uttryckslistan "
"utvärderas till en :class:`int` eller en :class:`slice` (som beskrivs i "
"följande avsnitt). Exempel på inbyggda sekvensklasser är klasserna :class:"
"`str`, :class:`list` och :class:`tuple`."

#: ../../reference/expressions.rst:875
msgid ""
"The formal syntax makes no special provision for negative indices in :term:"
"`sequences <sequence>`. However, built-in sequences all provide a :meth:"
"`~object.__getitem__` method that interprets negative indices by adding the "
"length of the sequence to the index so that, for example, ``x[-1]`` selects "
"the last item of ``x``. The resulting value must be a nonnegative integer "
"less than the number of items in the sequence, and the subscription selects "
"the item whose index is that value (counting from zero). Since the support "
"for negative indices and slicing occurs in the object's :meth:`~object."
"__getitem__` method, subclasses overriding this method will need to "
"explicitly add that support."
msgstr ""
"Den formella syntaxen innehåller inga särskilda bestämmelser för negativa "
"index i :term:`sekvenser <sequence>`. Alla inbyggda sekvenser har dock en :"
"meth:`~object.__getitem__`-metod som tolkar negativa index genom att lägga "
"till sekvensens längd till indexet så att till exempel ``x[-1]`` väljer det "
"sista objektet i ``x``. Det resulterande värdet måste vara ett icke-negativt "
"heltal som är mindre än antalet objekt i sekvensen, och prenumerationen "
"väljer det objekt vars index är det värdet (räknat från noll). Eftersom "
"stödet för negativa index och slicing finns i objektets :meth:`~object."
"__getitem__`-metod, måste subklasser som åsidosätter denna metod "
"uttryckligen lägga till detta stöd."

#: ../../reference/expressions.rst:889
msgid ""
"A :class:`string <str>` is a special kind of sequence whose items are "
"*characters*. A character is not a separate data type but a string of "
"exactly one character."
msgstr ""
"En :class:`sträng <str>` är en speciell typ av sekvens vars element är "
"*tecken*. Ett tecken är inte en separat datatyp utan en sträng med exakt ett "
"tecken."

#: ../../reference/expressions.rst:897
msgid "Slicings"
msgstr "Skivor"

#: ../../reference/expressions.rst:911
msgid ""
"A slicing selects a range of items in a sequence object (e.g., a string, "
"tuple or list).  Slicings may be used as expressions or as targets in "
"assignment or :keyword:`del` statements.  The syntax for a slicing:"
msgstr ""
"En slicing väljer ut ett intervall av objekt i ett sekvensobjekt (t.ex. en "
"sträng, tupel eller lista).  Slicings kan användas som uttryck eller som mål "
"i assignment- eller :keyword:`del`-satser.  Syntaxen för en slicing:"

#: ../../reference/expressions.rst:924
msgid ""
"There is ambiguity in the formal syntax here: anything that looks like an "
"expression list also looks like a slice list, so any subscription can be "
"interpreted as a slicing.  Rather than further complicating the syntax, this "
"is disambiguated by defining that in this case the interpretation as a "
"subscription takes priority over the interpretation as a slicing (this is "
"the case if the slice list contains no proper slice)."
msgstr ""
"Det finns en tvetydighet i den formella syntaxen här: allt som ser ut som en "
"uttryckslista ser också ut som en skivlista, så alla prenumerationer kan "
"tolkas som en skivning.  I stället för att ytterligare komplicera syntaxen, "
"kan detta klargöras genom att definiera att i detta fall har tolkningen som "
"en prenumeration prioritet över tolkningen som en skivning (detta är fallet "
"om skivlistan inte innehåller någon riktig skiva)."

#: ../../reference/expressions.rst:936
msgid ""
"The semantics for a slicing are as follows.  The primary is indexed (using "
"the same :meth:`~object.__getitem__` method as normal subscription) with a "
"key that is constructed from the slice list, as follows.  If the slice list "
"contains at least one comma, the key is a tuple containing the conversion of "
"the slice items; otherwise, the conversion of the lone slice item is the "
"key.  The conversion of a slice item that is an expression is that "
"expression.  The conversion of a proper slice is a slice object (see "
"section :ref:`types`) whose :attr:`~slice.start`, :attr:`~slice.stop` and :"
"attr:`~slice.step` attributes are the values of the expressions given as "
"lower bound, upper bound and stride, respectively, substituting ``None`` for "
"missing expressions."
msgstr ""
"Semantiken för en slicing är som följer.  Primären indexeras (med samma :"
"meth:`~object.__getitem__`-metod som vid normal prenumeration) med en nyckel "
"som konstrueras från slice-listan, enligt följande.  Om slice-listan "
"innehåller minst ett kommatecken är nyckeln en tupel som innehåller "
"konverteringen av slice-objekten; i annat fall är konverteringen av det enda "
"slice-objektet nyckeln.  Konverteringen av ett slice-objekt som är ett "
"uttryck är detta uttryck.  Konverteringen av en riktig slice är ett slice-"
"objekt (se avsnitt :ref:`types`) vars attribut :attr:`~slice.start`, :attr:"
"`~slice.stop` och :attr:`~slice.step` är värdena för de uttryck som anges "
"som lower bound, upper bound respektive stride, med ``None`` som ersättning "
"för uttryck som saknas."

#: ../../reference/expressions.rst:960
msgid "Calls"
msgstr "Calls"

#: ../../reference/expressions.rst:962
msgid ""
"A call calls a callable object (e.g., a :term:`function`) with a possibly "
"empty series of :term:`arguments <argument>`:"
msgstr ""
"Ett anrop anropar ett anropbart objekt (t.ex. en :term:`funktion`) med en "
"eventuellt tom serie av :term:`argument <argument>`:"

#: ../../reference/expressions.rst:979
msgid ""
"An optional trailing comma may be present after the positional and keyword "
"arguments but does not affect the semantics."
msgstr ""
"Ett valfritt efterföljande kommatecken kan finnas efter positions- och "
"nyckelordsargumenten, men påverkar inte semantiken."

#: ../../reference/expressions.rst:985
msgid ""
"The primary must evaluate to a callable object (user-defined functions, "
"built-in functions, methods of built-in objects, class objects, methods of "
"class instances, and all objects having a :meth:`~object.__call__` method "
"are callable).  All argument expressions are evaluated before the call is "
"attempted.  Please refer to section :ref:`function` for the syntax of "
"formal :term:`parameter` lists."
msgstr ""
"Det primära måste utvärderas till ett anropbart objekt (användardefinierade "
"funktioner, inbyggda funktioner, metoder för inbyggda objekt, klassobjekt, "
"metoder för klassinstanser och alla objekt som har en :meth:`~object."
"__call__`-metod är anropbara).  Alla argumentuttryck utvärderas innan "
"anropet görs.  Se avsnitt :ref:`function` för syntaxen för formella :term:"
"`parameter`-listor."

#: ../../reference/expressions.rst:993
msgid ""
"If keyword arguments are present, they are first converted to positional "
"arguments, as follows.  First, a list of unfilled slots is created for the "
"formal parameters.  If there are N positional arguments, they are placed in "
"the first N slots.  Next, for each keyword argument, the identifier is used "
"to determine the corresponding slot (if the identifier is the same as the "
"first formal parameter name, the first slot is used, and so on).  If the "
"slot is already filled, a :exc:`TypeError` exception is raised. Otherwise, "
"the argument is placed in the slot, filling it (even if the expression is "
"``None``, it fills the slot).  When all arguments have been processed, the "
"slots that are still unfilled are filled with the corresponding default "
"value from the function definition.  (Default values are calculated, once, "
"when the function is defined; thus, a mutable object such as a list or "
"dictionary used as default value will be shared by all calls that don't "
"specify an argument value for the corresponding slot; this should usually be "
"avoided.)  If there are any unfilled slots for which no default value is "
"specified, a :exc:`TypeError` exception is raised.  Otherwise, the list of "
"filled slots is used as the argument list for the call."
msgstr ""
"Om nyckelordsargument förekommer konverteras de först till positionsargument "
"på följande sätt.  Först skapas en lista med ofyllda slots för de formella "
"parametrarna.  Om det finns N positionella argument placeras de i de första "
"N platserna.  Därefter används identifieraren för varje nyckelordsargument "
"för att bestämma motsvarande plats (om identifieraren är densamma som det "
"första formella parameternamnet används den första platsen, och så vidare).  "
"Om platsen redan är fylld utlöses ett :exc:`TypeError`-undantag. I annat "
"fall placeras argumentet i slotten och fyller den (även om uttrycket är "
"``None`` fyller det slotten).  När alla argument har behandlats fylls de "
"platser som fortfarande är ofyllda med motsvarande standardvärde från "
"funktionsdefinitionen.  (Standardvärden beräknas en gång när funktionen "
"definieras; ett föränderligt objekt som en lista eller en ordbok som används "
"som standardvärde kommer därför att delas av alla anrop som inte anger ett "
"argumentvärde för motsvarande slot; detta bör vanligtvis undvikas)  Om det "
"finns några ofyllda slots för vilka inget standardvärde har angetts, uppstår "
"ett :exc:`TypeError` undantag.  I annat fall används listan med fyllda slots "
"som argumentlista för anropet."

#: ../../reference/expressions.rst:1013
msgid ""
"An implementation may provide built-in functions whose positional parameters "
"do not have names, even if they are 'named' for the purpose of "
"documentation, and which therefore cannot be supplied by keyword.  In "
"CPython, this is the case for functions implemented in C that use :c:func:"
"`PyArg_ParseTuple` to parse their arguments."
msgstr ""
"En implementation kan tillhandahålla inbyggda funktioner vars positionella "
"parametrar inte har namn, även om de \"namnges\" i dokumentationssyfte, och "
"som därför inte kan anges med nyckelord.  I CPython är detta fallet för "
"funktioner som implementerats i C och som använder :c:func:"
"`PyArg_ParseTuple` för att analysera sina argument."

#: ../../reference/expressions.rst:1019
msgid ""
"If there are more positional arguments than there are formal parameter "
"slots, a :exc:`TypeError` exception is raised, unless a formal parameter "
"using the syntax ``*identifier`` is present; in this case, that formal "
"parameter receives a tuple containing the excess positional arguments (or an "
"empty tuple if there were no excess positional arguments)."
msgstr ""
"Om det finns fler positionella argument än det finns formella "
"parameterplatser, uppstår ett :exc:`TypeError`-undantag, såvida inte en "
"formell parameter med syntaxen ``*identifier`` finns; i så fall får den "
"formella parametern en tupel som innehåller de överflödiga positionella "
"argumenten (eller en tom tupel om det inte fanns några överflödiga "
"positionella argument)."

#: ../../reference/expressions.rst:1025
msgid ""
"If any keyword argument does not correspond to a formal parameter name, a :"
"exc:`TypeError` exception is raised, unless a formal parameter using the "
"syntax ``**identifier`` is present; in this case, that formal parameter "
"receives a dictionary containing the excess keyword arguments (using the "
"keywords as keys and the argument values as corresponding values), or a "
"(new) empty dictionary if there were no excess keyword arguments."
msgstr ""
"Om något nyckelordsargument inte motsvarar ett formellt parameternamn, "
"uppstår ett :exc:`TypeError`-undantag, såvida inte en formell parameter med "
"syntaxen ``**identifier`` finns; i så fall får den formella parametern en "
"ordbok som innehåller de överflödiga nyckelordsargumenten (med nyckelorden "
"som nycklar och argumentvärdena som motsvarande värden), eller en (ny) tom "
"ordbok om det inte fanns några överflödiga nyckelordsargument."

#: ../../reference/expressions.rst:1036
msgid ""
"If the syntax ``*expression`` appears in the function call, ``expression`` "
"must evaluate to an :term:`iterable`.  Elements from these iterables are "
"treated as if they were additional positional arguments.  For the call "
"``f(x1, x2, *y, x3, x4)``, if *y* evaluates to a sequence *y1*, ..., *yM*, "
"this is equivalent to a call with M+4 positional arguments *x1*, *x2*, "
"*y1*, ..., *yM*, *x3*, *x4*."
msgstr ""
"Om syntaxen ``*expression`` förekommer i funktionsanropet måste "
"``expression`` utvärderas till en :term:`iterable`.  Element från dessa "
"iterabler behandlas som om de vore ytterligare positionella argument.  För "
"anropet ``f(x1, x2, *y, x3, x4)``, om *y* utvärderas till en sekvens "
"*y1*, ..., *yM*, är detta likvärdigt med ett anrop med M+4 positionella "
"argument *x1*, *x2*, *y1*, ..., *yM*, *x3*, *x4*."

#: ../../reference/expressions.rst:1043
msgid ""
"A consequence of this is that although the ``*expression`` syntax may appear "
"*after* explicit keyword arguments, it is processed *before* the keyword "
"arguments (and any ``**expression`` arguments -- see below).  So::"
msgstr ""
"En konsekvens av detta är att även om syntaxen ``*expression`` kan visas "
"*efter* explicita nyckelordsargument, bearbetas den *före* "
"nyckelordsargumenten (och eventuella ``**expression``-argument - se nedan).  "
"Så::"

#: ../../reference/expressions.rst:1059
msgid ""
"It is unusual for both keyword arguments and the ``*expression`` syntax to "
"be used in the same call, so in practice this confusion does not often arise."
msgstr ""
"Det är ovanligt att både nyckelordsargument och syntaxen ``*expression`` "
"används i samma anrop, så i praktiken uppstår inte denna förvirring särskilt "
"ofta."

#: ../../reference/expressions.rst:1065
msgid ""
"If the syntax ``**expression`` appears in the function call, ``expression`` "
"must evaluate to a :term:`mapping`, the contents of which are treated as "
"additional keyword arguments. If a parameter matching a key has already been "
"given a value (by an explicit keyword argument, or from another unpacking), "
"a :exc:`TypeError` exception is raised."
msgstr ""
"Om syntaxen ``**expression`` förekommer i funktionsanropet, måste "
"``expression`` utvärderas till en :term:`mapping`, vars innehåll behandlas "
"som ytterligare nyckelordsargument. Om en parameter som matchar en nyckel "
"redan har fått ett värde (genom ett explicit nyckelordsargument, eller från "
"en annan uppackning), uppstår ett :exc:`TypeError` undantag."

#: ../../reference/expressions.rst:1071
msgid ""
"When ``**expression`` is used, each key in this mapping must be a string. "
"Each value from the mapping is assigned to the first formal parameter "
"eligible for keyword assignment whose name is equal to the key. A key need "
"not be a Python identifier (e.g. ``\"max-temp °F\"`` is acceptable, although "
"it will not match any formal parameter that could be declared). If there is "
"no match to a formal parameter the key-value pair is collected by the ``**`` "
"parameter, if there is one, or if there is not, a :exc:`TypeError` exception "
"is raised."
msgstr ""
"När ``**expression`` används måste varje nyckel i denna mappning vara en "
"sträng. Varje värde från mappningen tilldelas den första formella parametern "
"som är kvalificerad för nyckelordstilldelning vars namn är lika med nyckeln. "
"En nyckel behöver inte vara en Python-identifierare (t.ex. ``\"max-temp "
"°F\"`` är acceptabelt, även om det inte kommer att matcha någon formell "
"parameter som kan deklareras). Om det inte finns någon matchning till en "
"formell parameter samlas nyckel-värdeparet in av parametern ``**``, om det "
"finns en, eller om det inte finns en, ett :exc:`TypeError` undantag tas upp."

#: ../../reference/expressions.rst:1081
msgid ""
"Formal parameters using the syntax ``*identifier`` or ``**identifier`` "
"cannot be used as positional argument slots or as keyword argument names."
msgstr ""
"Formella parametrar som använder syntaxen ``*identifier`` eller "
"``**identifier`` kan inte användas som positionella argumentplatser eller "
"som nyckelordsargumentnamn."

#: ../../reference/expressions.rst:1084
msgid ""
"Function calls accept any number of ``*`` and ``**`` unpackings, positional "
"arguments may follow iterable unpackings (``*``), and keyword arguments may "
"follow dictionary unpackings (``**``). Originally proposed by :pep:`448`."
msgstr ""
"Funktionsanrop accepterar valfritt antal ``*`` och ``**`` uppackningar, "
"positionella argument kan följa iterabla uppackningar (``*``) och "
"nyckelordsargument kan följa uppackningar av ordböcker (``**``). "
"Ursprungligen föreslagen av :pep:`448`."

#: ../../reference/expressions.rst:1090
msgid ""
"A call always returns some value, possibly ``None``, unless it raises an "
"exception.  How this value is computed depends on the type of the callable "
"object."
msgstr ""
"Ett anrop returnerar alltid ett värde, eventuellt ``None``, såvida det inte "
"leder till ett undantag.  Hur detta värde beräknas beror på typen av det "
"anropbara objektet."

#: ../../reference/expressions.rst:1094
msgid "If it is---"
msgstr "Om det är det.."

#: ../../reference/expressions.rst:1107
msgid "a user-defined function:"
msgstr "en användardefinierad funktion:"

#: ../../reference/expressions.rst:1103
msgid ""
"The code block for the function is executed, passing it the argument list.  "
"The first thing the code block will do is bind the formal parameters to the "
"arguments; this is described in section :ref:`function`.  When the code "
"block executes a :keyword:`return` statement, this specifies the return "
"value of the function call."
msgstr ""

#: ../../reference/expressions.rst:1121
msgid "a built-in function or method:"
msgstr "en inbyggd funktion eller metod:"

#: ../../reference/expressions.rst:1120
msgid ""
"The result is up to the interpreter; see :ref:`built-in-funcs` for the "
"descriptions of built-in functions and methods."
msgstr ""
"Resultatet är upp till tolken; se :ref:`built-in-funcs` för beskrivningar av "
"inbyggda funktioner och metoder."

#: ../../reference/expressions.rst:1128
msgid "a class object:"
msgstr "ett klassobjekt:"

#: ../../reference/expressions.rst:1128
msgid "A new instance of that class is returned."
msgstr "En ny instans av den klassen returneras."

#: ../../reference/expressions.rst:1138
msgid "a class instance method:"
msgstr "en metod för klassinstans:"

#: ../../reference/expressions.rst:1136
msgid ""
"The corresponding user-defined function is called, with an argument list "
"that is one longer than the argument list of the call: the instance becomes "
"the first argument."
msgstr ""
"Motsvarande användardefinierade funktion anropas, med en argumentlista som "
"är en längre än anropets argumentlista: instansen blir det första argumentet."

#: ../../reference/expressions.rst:1147
msgid "a class instance:"
msgstr "en klassinstans:"

#: ../../reference/expressions.rst:1145
msgid ""
"The class must define a :meth:`~object.__call__` method; the effect is then "
"the same as if that method was called."
msgstr ""
"Klassen måste definiera en :meth:`~object.__call__`-metod; effekten blir då "
"densamma som om den metoden anropades."

#: ../../reference/expressions.rst:1153 ../../reference/expressions.rst:1936
msgid "Await expression"
msgstr "Avvakta uttryck"

#: ../../reference/expressions.rst:1155
msgid ""
"Suspend the execution of :term:`coroutine` on an :term:`awaitable` object. "
"Can only be used inside a :term:`coroutine function`."
msgstr ""
"Avbryter exekveringen av :term:`coroutine` på ett :term:`awaitable`-objekt. "
"Kan endast användas inuti en :term:`coroutine function`."

#: ../../reference/expressions.rst:1167
msgid "The power operator"
msgstr "Den kraftfulla operatören"

#: ../../reference/expressions.rst:1173
msgid ""
"The power operator binds more tightly than unary operators on its left; it "
"binds less tightly than unary operators on its right.  The syntax is:"
msgstr ""
"Power-operatorn binder hårdare än unära operatorer till vänster om den; den "
"binder mindre hårt än unära operatorer till höger om den.  Syntaxen är:"

#: ../../reference/expressions.rst:1179
msgid ""
"Thus, in an unparenthesized sequence of power and unary operators, the "
"operators are evaluated from right to left (this does not constrain the "
"evaluation order for the operands): ``-1**2`` results in ``-1``."
msgstr ""
"I en sekvens av potens- och unära operatorer som inte är parentetisk "
"utvärderas operatörerna från höger till vänster (detta begränsar inte "
"utvärderingsordningen för operanderna): ``-1**2`` resulterar i ``-1``."

#: ../../reference/expressions.rst:1183
msgid ""
"The power operator has the same semantics as the built-in :func:`pow` "
"function, when called with two arguments: it yields its left argument raised "
"to the power of its right argument.  The numeric arguments are first "
"converted to a common type, and the result is of that type."
msgstr ""
"Potensoperatorn har samma semantik som den inbyggda funktionen :func:`pow`, "
"när den anropas med två argument: den ger sitt vänstra argument upphöjt till "
"potensen av sitt högra argument.  De numeriska argumenten konverteras först "
"till en gemensam typ, och resultatet är av den typen."

#: ../../reference/expressions.rst:1188
msgid ""
"For int operands, the result has the same type as the operands unless the "
"second argument is negative; in that case, all arguments are converted to "
"float and a float result is delivered. For example, ``10**2`` returns "
"``100``, but ``10**-2`` returns ``0.01``."
msgstr ""
"För int-operander har resultatet samma typ som operanderna om inte det andra "
"argumentet är negativt; i så fall konverteras alla argument till float och "
"ett float-resultat levereras. Till exempel ger ``10**2`` resultatet ``100``, "
"men ``10**-2`` ger ``0,01``."

#: ../../reference/expressions.rst:1193
msgid ""
"Raising ``0.0`` to a negative power results in a :exc:`ZeroDivisionError`. "
"Raising a negative number to a fractional power results in a :class:"
"`complex` number. (In earlier versions it raised a :exc:`ValueError`.)"
msgstr ""
"Att höja ``0.0`` till en negativ potens resulterar i ett :exc:"
"`ZeroDivisionError`. Att höja ett negativt tal till en bråkpotens resulterar "
"i ett :class:`komplex` tal. (I tidigare versioner gav det upphov till ett :"
"exc:`ValueError`.)"

#: ../../reference/expressions.rst:1197
msgid ""
"This operation can be customized using the special :meth:`~object.__pow__` "
"method."
msgstr ""

#: ../../reference/expressions.rst:1202
msgid "Unary arithmetic and bitwise operations"
msgstr "Unär aritmetik och bitvisa operationer"

#: ../../reference/expressions.rst:1208
msgid "All unary arithmetic and bitwise operations have the same priority:"
msgstr "Alla unära aritmetiska och bitvisa operationer har samma prioritet:"

#: ../../reference/expressions.rst:1219
msgid ""
"The unary ``-`` (minus) operator yields the negation of its numeric "
"argument; the operation can be overridden with the :meth:`~object.__neg__` "
"special method."
msgstr ""
"Den unära operatorn ``-`` (minus) ger negationen av sitt numeriska argument; "
"operationen kan åsidosättas med specialmetoden :meth:`~object.__neg__`."

#: ../../reference/expressions.rst:1227
msgid ""
"The unary ``+`` (plus) operator yields its numeric argument unchanged; the "
"operation can be overridden with the :meth:`~object.__pos__` special method."
msgstr ""
"Den unära operatorn ``+`` (plus) ger sitt numeriska argument oförändrat; "
"operationen kan åsidosättas med specialmetoden :meth:`~object.__pos__`."

#: ../../reference/expressions.rst:1234
msgid ""
"The unary ``~`` (invert) operator yields the bitwise inversion of its "
"integer argument.  The bitwise inversion of ``x`` is defined as ``-(x+1)``.  "
"It only applies to integral numbers or to custom objects that override the :"
"meth:`~object.__invert__` special method."
msgstr ""
"Den unära operatorn ``~`` (invert) ger den bitvisa inverteringen av dess "
"heltalsargument.  Den bitvisa inverteringen av ``x`` definieras som ``-"
"(x+1)``.  Den gäller endast för heltal eller för anpassade objekt som "
"åsidosätter specialmetoden :meth:`~object.__invert__`."

#: ../../reference/expressions.rst:1243
msgid ""
"In all three cases, if the argument does not have the proper type, a :exc:"
"`TypeError` exception is raised."
msgstr ""
"I alla tre fallen, om argumentet inte har rätt typ, uppstår ett :exc:"
"`TypeError` undantag."

#: ../../reference/expressions.rst:1250
msgid "Binary arithmetic operations"
msgstr "Binära aritmetiska operationer"

#: ../../reference/expressions.rst:1254
msgid ""
"The binary arithmetic operations have the conventional priority levels.  "
"Note that some of these operations also apply to certain non-numeric types.  "
"Apart from the power operator, there are only two levels, one for "
"multiplicative operators and one for additive operators:"
msgstr ""
"De binära aritmetiska operationerna har de konventionella "
"prioritetsnivåerna.  Observera att vissa av dessa operationer även gäller "
"för vissa icke-numeriska typer.  Bortsett från potensoperatorn finns det "
"bara två nivåer, en för multiplikativa operatorer och en för additiva "
"operatorer:"

#: ../../reference/expressions.rst:1269
msgid ""
"The ``*`` (multiplication) operator yields the product of its arguments.  "
"The arguments must either both be numbers, or one argument must be an "
"integer and the other must be a sequence. In the former case, the numbers "
"are converted to a common type and then multiplied together.  In the latter "
"case, sequence repetition is performed; a negative repetition factor yields "
"an empty sequence."
msgstr ""

#: ../../reference/expressions.rst:1275
msgid ""
"This operation can be customized using the special :meth:`~object.__mul__` "
"and :meth:`~object.__rmul__` methods."
msgstr ""
"Denna operation kan anpassas med hjälp av specialmetoderna :meth:`~object."
"__mul__` och :meth:`~object.__rmul__`."

#: ../../reference/expressions.rst:1282
msgid ""
"The ``@`` (at) operator is intended to be used for matrix multiplication.  "
"No builtin Python types implement this operator."
msgstr ""
"Operatorn ``@`` (at) är avsedd att användas för matrismultiplikation.  Inga "
"inbyggda Python-typer implementerar denna operator."

#: ../../reference/expressions.rst:1293
msgid ""
"The ``/`` (division) and ``//`` (floor division) operators yield the "
"quotient of their arguments.  The numeric arguments are first converted to a "
"common type. Division of integers yields a float, while floor division of "
"integers results in an integer; the result is that of mathematical division "
"with the 'floor' function applied to the result.  Division by zero raises "
"the :exc:`ZeroDivisionError` exception."
msgstr ""
"Operatörerna ``/`` (division) och ``//`` (golvdivision) ger kvoten av sina "
"argument.  De numeriska argumenten konverteras först till en gemensam typ. "
"Division av heltal ger en float, medan golvdivision av heltal ger ett "
"heltal; resultatet är detsamma som matematisk division med \"golv\"-"
"funktionen tillämpad på resultatet.  Division med noll ger upphov till "
"undantaget :exc:`ZeroDivisionError`."

#: ../../reference/expressions.rst:1300
msgid ""
"This operation can be customized using the special :meth:`~object."
"__truediv__` and :meth:`~object.__floordiv__` methods."
msgstr ""

#: ../../reference/expressions.rst:1307
msgid ""
"The ``%`` (modulo) operator yields the remainder from the division of the "
"first argument by the second.  The numeric arguments are first converted to "
"a common type.  A zero right argument raises the :exc:`ZeroDivisionError` "
"exception.  The arguments may be floating point numbers, e.g., ``3.14%0.7`` "
"equals ``0.34`` (since ``3.14`` equals ``4*0.7 + 0.34``.)  The modulo "
"operator always yields a result with the same sign as its second operand (or "
"zero); the absolute value of the result is strictly smaller than the "
"absolute value of the second operand [#]_."
msgstr ""

#: ../../reference/expressions.rst:1316
msgid ""
"The floor division and modulo operators are connected by the following "
"identity: ``x == (x//y)*y + (x%y)``.  Floor division and modulo are also "
"connected with the built-in function :func:`divmod`: ``divmod(x, y) == (x//"
"y, x%y)``. [#]_."
msgstr ""
"Operatorerna vågdivision och modulo är förbundna med varandra genom följande "
"identitet: ``x == (x//y)*y + (x%y)``.  Våningsdivision och modulo är också "
"kopplade till den inbyggda funktionen :func:`divmod`: ``divmod(x, y) == (x//"
"y, x%y)``. [#]_."

#: ../../reference/expressions.rst:1321
msgid ""
"In addition to performing the modulo operation on numbers, the ``%`` "
"operator is also overloaded by string objects to perform old-style string "
"formatting (also known as interpolation).  The syntax for string formatting "
"is described in the Python Library Reference, section :ref:`old-string-"
"formatting`."
msgstr ""
"Förutom att utföra modulo-operationen på tal, är operatorn ``%`` också "
"överbelastad av strängobjekt för att utföra gammaldags strängformatering "
"(även känd som interpolering).  Syntaxen för strängformatering beskrivs i "
"Python Library Reference, avsnitt :ref:`old-string-formatting`."

#: ../../reference/expressions.rst:1326
msgid ""
"The *modulo* operation can be customized using the special :meth:`~object."
"__mod__` method."
msgstr ""

#: ../../reference/expressions.rst:1328
msgid ""
"The floor division operator, the modulo operator, and the :func:`divmod` "
"function are not defined for complex numbers.  Instead, convert to a "
"floating point number using the :func:`abs` function if appropriate."
msgstr ""

#: ../../reference/expressions.rst:1337
msgid ""
"The ``+`` (addition) operator yields the sum of its arguments.  The "
"arguments must either both be numbers or both be sequences of the same "
"type.  In the former case, the numbers are converted to a common type and "
"then added together. In the latter case, the sequences are concatenated."
msgstr ""

#: ../../reference/expressions.rst:1342
msgid ""
"This operation can be customized using the special :meth:`~object.__add__` "
"and :meth:`~object.__radd__` methods."
msgstr ""
"Denna operation kan anpassas med hjälp av specialmetoderna :meth:`~object."
"__add__` och :meth:`~object.__radd__`."

#: ../../reference/expressions.rst:1350
msgid ""
"The ``-`` (subtraction) operator yields the difference of its arguments.  "
"The numeric arguments are first converted to a common type."
msgstr ""

#: ../../reference/expressions.rst:1353
msgid ""
"This operation can be customized using the special :meth:`~object.__sub__` "
"method."
msgstr ""

#: ../../reference/expressions.rst:1359
msgid "Shifting operations"
msgstr "Skiftande verksamhet"

#: ../../reference/expressions.rst:1366
msgid ""
"The shifting operations have lower priority than the arithmetic operations:"
msgstr ""
"Skiftoperationerna har lägre prioritet än de aritmetiska operationerna:"

#: ../../reference/expressions.rst:1371
msgid ""
"These operators accept integers as arguments.  They shift the first argument "
"to the left or right by the number of bits given by the second argument."
msgstr ""
"Dessa operatorer accepterar heltal som argument.  De förskjuter det första "
"argumentet åt vänster eller höger med det antal bitar som anges i det andra "
"argumentet."

#: ../../reference/expressions.rst:1374
msgid ""
"This operation can be customized using the special :meth:`~object."
"__lshift__` and :meth:`~object.__rshift__` methods."
msgstr ""

#: ../../reference/expressions.rst:1379
msgid ""
"A right shift by *n* bits is defined as floor division by ``pow(2,n)``.  A "
"left shift by *n* bits is defined as multiplication with ``pow(2,n)``."
msgstr ""
"En högerförskjutning med *n* bitar definieras som golvdivision med ``pow(2,"
"n)``.  En vänsterförskjutning med *n* bitar definieras som multiplikation "
"med ``pow(2,n)``."

#: ../../reference/expressions.rst:1386
msgid "Binary bitwise operations"
msgstr "Binära bitvisa operationer"

#: ../../reference/expressions.rst:1390
msgid "Each of the three bitwise operations has a different priority level:"
msgstr "Var och en av de tre bitvisa operationerna har olika prioritetsnivå:"

#: ../../reference/expressions.rst:1401
msgid ""
"The ``&`` operator yields the bitwise AND of its arguments, which must be "
"integers or one of them must be a custom object overriding :meth:`~object."
"__and__` or :meth:`~object.__rand__` special methods."
msgstr ""
"Operatorn ``&`` ger det bitvisa AND av sina argument, som måste vara heltal "
"eller ett av dem måste vara ett anpassat objekt som åsidosätter "
"specialmetoderna :meth:`~object.__and__` eller :meth:`~object.__rand__`."

#: ../../reference/expressions.rst:1410
msgid ""
"The ``^`` operator yields the bitwise XOR (exclusive OR) of its arguments, "
"which must be integers or one of them must be a custom object overriding :"
"meth:`~object.__xor__` or :meth:`~object.__rxor__` special methods."
msgstr ""
"Operatorn ``^`` ger bitvis XOR (exclusive OR) av sina argument, som måste "
"vara heltal eller ett av dem måste vara ett anpassat objekt som åsidosätter "
"specialmetoderna :meth:`~object.__xor__` eller :meth:`~object.__rxor__`."

#: ../../reference/expressions.rst:1419
msgid ""
"The ``|`` operator yields the bitwise (inclusive) OR of its arguments, which "
"must be integers or one of them must be a custom object overriding :meth:"
"`~object.__or__` or :meth:`~object.__ror__` special methods."
msgstr ""
"Operatorn ``|`` ger det bitvisa (inkluderande) OR av dess argument, som "
"måste vara heltal eller så måste ett av dem vara ett anpassat objekt som "
"åsidosätter specialmetoderna :meth:`~object.__or__` eller :meth:`~object."
"__ror__`."

#: ../../reference/expressions.rst:1427
msgid "Comparisons"
msgstr "Jämförelser"

#: ../../reference/expressions.rst:1439
msgid ""
"Unlike C, all comparison operations in Python have the same priority, which "
"is lower than that of any arithmetic, shifting or bitwise operation.  Also "
"unlike C, expressions like ``a < b < c`` have the interpretation that is "
"conventional in mathematics:"
msgstr ""
"Till skillnad från C har alla jämförelseoperationer i Python samma "
"prioritet, som är lägre än den för aritmetiska, skiftande eller bitvisa "
"operationer.  Till skillnad från C har också uttryck som ``a < b < c`` den "
"tolkning som är konventionell inom matematiken:"

#: ../../reference/expressions.rst:1449
msgid ""
"Comparisons yield boolean values: ``True`` or ``False``. Custom :dfn:`rich "
"comparison methods` may return non-boolean values. In this case Python will "
"call :func:`bool` on such value in boolean contexts."
msgstr ""
"Jämförelser ger booleska värden: ``True`` eller ``False``. Anpassade :dfn:"
"`rika jämförelsemetoder` kan returnera icke-booleska värden. I detta fall "
"kommer Python att anropa :func:`bool` på sådana värden i booleska kontexter."

#: ../../reference/expressions.rst:1455
msgid ""
"Comparisons can be chained arbitrarily, e.g., ``x < y <= z`` is equivalent "
"to ``x < y and y <= z``, except that ``y`` is evaluated only once (but in "
"both cases ``z`` is not evaluated at all when ``x < y`` is found to be "
"false)."
msgstr ""
"Jämförelser kan kedjas godtyckligt, t.ex. är ``x < y <= z`` ekvivalent med "
"``x < y och y <= z``, förutom att ``y`` bara utvärderas en gång (men i båda "
"fallen utvärderas inte ``z`` alls när ``x < y`` visar sig vara falskt)."

#: ../../reference/expressions.rst:1459
msgid ""
"Formally, if *a*, *b*, *c*, ..., *y*, *z* are expressions and *op1*, "
"*op2*, ..., *opN* are comparison operators, then ``a op1 b op2 c ... y opN "
"z`` is equivalent to ``a op1 b and b op2 c and ... y opN z``, except that "
"each expression is evaluated at most once."
msgstr ""
"Formellt, om *a*, *b*, *c*, ..., *y*, *z* är uttryck och *op1*, *op2*, ..., "
"*opN* är jämförelseoperatorer, så är ``a op1 b op2 c ... y opN z`` "
"ekvivalent med ``a op1 b och b op2 c och ... y opN z``, förutom att varje "
"uttryck utvärderas högst en gång."

#: ../../reference/expressions.rst:1464
msgid ""
"Note that ``a op1 b op2 c`` doesn't imply any kind of comparison between *a* "
"and *c*, so that, e.g., ``x < y > z`` is perfectly legal (though perhaps not "
"pretty)."
msgstr ""
"Observera att ``a op1 b op2 c`` inte innebär någon form av jämförelse mellan "
"*a* och *c*, så att t.ex. ``x < y > z`` är helt lagligt (men kanske inte "
"vackert)."

#: ../../reference/expressions.rst:1471
msgid "Value comparisons"
msgstr "Värdejämförelser"

#: ../../reference/expressions.rst:1473
msgid ""
"The operators ``<``, ``>``, ``==``, ``>=``, ``<=``, and ``!=`` compare the "
"values of two objects.  The objects do not need to have the same type."
msgstr ""
"Operatorerna ``<``, ``>``, ``==``, ``>=``, ``<=`` och ``!=`` jämför värdena "
"hos två objekt.  Objekten behöver inte ha samma typ."

#: ../../reference/expressions.rst:1476
msgid ""
"Chapter :ref:`objects` states that objects have a value (in addition to type "
"and identity).  The value of an object is a rather abstract notion in "
"Python: For example, there is no canonical access method for an object's "
"value.  Also, there is no requirement that the value of an object should be "
"constructed in a particular way, e.g. comprised of all its data attributes. "
"Comparison operators implement a particular notion of what the value of an "
"object is.  One can think of them as defining the value of an object "
"indirectly, by means of their comparison implementation."
msgstr ""
"Kapitel :ref:`objects` anger att objekt har ett värde (utöver typ och "
"identitet).  Värdet på ett objekt är ett ganska abstrakt begrepp i Python: "
"Det finns t.ex. ingen kanonisk åtkomstmetod för ett objekts värde.  Det "
"finns inte heller något krav på att ett objekts värde ska vara konstruerat "
"på ett visst sätt, t.ex. bestå av alla dess dataattribut. "
"Jämförelseoperatorer implementerar en särskild uppfattning om vad ett "
"objekts värde är.  Man kan se det som att de definierar ett objekts värde "
"indirekt, med hjälp av sin jämförelseimplementering."

#: ../../reference/expressions.rst:1485
msgid ""
"Because all types are (direct or indirect) subtypes of :class:`object`, they "
"inherit the default comparison behavior from :class:`object`.  Types can "
"customize their comparison behavior by implementing :dfn:`rich comparison "
"methods` like :meth:`~object.__lt__`, described in :ref:`customization`."
msgstr ""
"Eftersom alla typer är (direkta eller indirekta) subtyper av :class:"
"`object`, ärver de standardjämförelsebeteendet från :class:`object`.  Typer "
"kan anpassa sitt jämförelsebeteende genom att implementera :dfn:`rika "
"jämförelsemetoder` som :meth:`~object.__lt__`, som beskrivs i :ref:"
"`customization`."

#: ../../reference/expressions.rst:1491
msgid ""
"The default behavior for equality comparison (``==`` and ``!=``) is based on "
"the identity of the objects.  Hence, equality comparison of instances with "
"the same identity results in equality, and equality comparison of instances "
"with different identities results in inequality.  A motivation for this "
"default behavior is the desire that all objects should be reflexive (i.e. "
"``x is y`` implies ``x == y``)."
msgstr ""
"Standardbeteendet för jämlikhetsjämförelser (``==`` och ``!=``) baseras på "
"objektens identitet.  Därför resulterar jämlikhetsjämförelse av instanser "
"med samma identitet i jämlikhet, och jämlikhetsjämförelse av instanser med "
"olika identiteter resulterar i ojämlikhet.  Ett motiv för detta "
"standardbeteende är önskemålet att alla objekt ska vara reflexiva (dvs. ``x "
"är y`` innebär ``x == y``)."

#: ../../reference/expressions.rst:1498
msgid ""
"A default order comparison (``<``, ``>``, ``<=``, and ``>=``) is not "
"provided; an attempt raises :exc:`TypeError`.  A motivation for this default "
"behavior is the lack of a similar invariant as for equality."
msgstr ""
"En standardjämförelseordning (``<``, ``>``, ``<=`` och ``>=``) "
"tillhandahålls inte; ett försök ger upphov till :exc:`TypeError`.  Ett motiv "
"för detta standardbeteende är avsaknaden av en liknande invariant som för "
"likhet."

#: ../../reference/expressions.rst:1502
msgid ""
"The behavior of the default equality comparison, that instances with "
"different identities are always unequal, may be in contrast to what types "
"will need that have a sensible definition of object value and value-based "
"equality.  Such types will need to customize their comparison behavior, and "
"in fact, a number of built-in types have done that."
msgstr ""
"Standardjämförelsen för jämlikhet, att instanser med olika identiteter "
"alltid är ojämlika, kan stå i kontrast till vad typer behöver som har en "
"vettig definition av objektvärde och värdebaserad jämlikhet.  Sådana typer "
"kommer att behöva anpassa sitt jämförelsebeteende, och det har faktiskt ett "
"antal inbyggda typer gjort."

#: ../../reference/expressions.rst:1508
msgid ""
"The following list describes the comparison behavior of the most important "
"built-in types."
msgstr ""
"I följande lista beskrivs jämförelsebeteendet för de viktigaste inbyggda "
"typerna."

#: ../../reference/expressions.rst:1511
msgid ""
"Numbers of built-in numeric types (:ref:`typesnumeric`) and of the standard "
"library types :class:`fractions.Fraction` and :class:`decimal.Decimal` can "
"be compared within and across their types, with the restriction that complex "
"numbers do not support order comparison.  Within the limits of the types "
"involved, they compare mathematically (algorithmically) correct without loss "
"of precision."
msgstr ""
"Tal av inbyggda numeriska typer (:ref:`typesnumeric`) och av "
"standardbibliotekets typer :class:`fractions.Fraction` och :class:`decimal."
"Decimal` kan jämföras inom och mellan sina typer, med begränsningen att "
"komplexa tal inte stöder orderjämförelse.  Inom gränserna för de berörda "
"typerna jämförs de matematiskt (algoritmiskt) korrekt utan förlust av "
"precision."

#: ../../reference/expressions.rst:1518
msgid ""
"The not-a-number values ``float('NaN')`` and ``decimal.Decimal('NaN')`` are "
"special.  Any ordered comparison of a number to a not-a-number value is "
"false. A counter-intuitive implication is that not-a-number values are not "
"equal to themselves.  For example, if ``x = float('NaN')``, ``3 < x``, ``x < "
"3`` and ``x == x`` are all false, while ``x != x`` is true.  This behavior "
"is compliant with IEEE 754."
msgstr ""
"Värdena \"not-a-number\" ``float('NaN')`` och ``decimal.decimal('NaN')`` är "
"speciella.  Varje ordnad jämförelse av ett tal med ett värde som inte är ett "
"tal är falsk. En kontraintuitiv implikation är att värden som inte är ett "
"tal inte är lika med sig själva.  Till exempel, om ``x = float('NaN')``, ``3 "
"< x``, ``x < 3`` och ``x == x`` är alla falska, medan ``x != x`` är sant.  "
"Detta beteende är förenligt med IEEE 754."

#: ../../reference/expressions.rst:1525
msgid ""
"``None`` and :data:`NotImplemented` are singletons.  :PEP:`8` advises that "
"comparisons for singletons should always be done with ``is`` or ``is not``, "
"never the equality operators."
msgstr ""
"``None`` och :data:`NotImplemented`` är singletoner. :PEP:`8`` rekommenderar "
"att jämförelser för singletoner alltid skall göras med ``is`` eller ``is "
"not``, aldrig med jämställdhetsoperatorerna."

#: ../../reference/expressions.rst:1529
msgid ""
"Binary sequences (instances of :class:`bytes` or :class:`bytearray`) can be "
"compared within and across their types.  They compare lexicographically "
"using the numeric values of their elements."
msgstr ""
"Binära sekvenser (instanser av :class:`bytes` eller :class:`bytearray`) kan "
"jämföras inom och mellan sina typer.  De jämförs lexikografiskt med hjälp av "
"de numeriska värdena för sina element."

#: ../../reference/expressions.rst:1533
msgid ""
"Strings (instances of :class:`str`) compare lexicographically using the "
"numerical Unicode code points (the result of the built-in function :func:"
"`ord`) of their characters. [#]_"
msgstr ""
"Strängar (instanser av :class:`str`) jämförs lexikografiskt med hjälp av de "
"numeriska Unicode-kodpunkterna (resultatet av den inbyggda funktionen :func:"
"`ord`) för sina tecken. "

#: ../../reference/expressions.rst:1537
msgid "Strings and binary sequences cannot be directly compared."
msgstr "Strängar och binära sekvenser kan inte jämföras direkt."

#: ../../reference/expressions.rst:1539
msgid ""
"Sequences (instances of :class:`tuple`, :class:`list`, or :class:`range`) "
"can be compared only within each of their types, with the restriction that "
"ranges do not support order comparison.  Equality comparison across these "
"types results in inequality, and ordering comparison across these types "
"raises :exc:`TypeError`."
msgstr ""
"Sekvenser (instanser av :class:`tuple`, :class:`list` eller :class:`range`) "
"kan endast jämföras inom var och en av sina typer, med begränsningen att "
"intervall inte stöder orderjämförelse.  Jämlikhetsjämförelse mellan dessa "
"typer resulterar i ojämlikhet, och ordningsjämförelse mellan dessa typer ger "
"upphov till :exc:`TypeError`."

#: ../../reference/expressions.rst:1545
msgid ""
"Sequences compare lexicographically using comparison of corresponding "
"elements.  The built-in containers typically assume identical objects are "
"equal to themselves.  That lets them bypass equality tests for identical "
"objects to improve performance and to maintain their internal invariants."
msgstr ""
"Sekvenser jämförs lexikografiskt med hjälp av jämförelse av motsvarande "
"element.  De inbyggda behållarna antar vanligtvis att identiska objekt är "
"lika med sig själva.  Det gör att de kan kringgå likhetstester för identiska "
"objekt för att förbättra prestanda och för att upprätthålla sina interna "
"invarianter."

#: ../../reference/expressions.rst:1550
msgid ""
"Lexicographical comparison between built-in collections works as follows:"
msgstr ""
"Lexikografisk jämförelse mellan inbyggda samlingar fungerar på följande sätt:"

#: ../../reference/expressions.rst:1552
msgid ""
"For two collections to compare equal, they must be of the same type, have "
"the same length, and each pair of corresponding elements must compare equal "
"(for example, ``[1,2] == (1,2)`` is false because the type is not the same)."
msgstr ""
"För att två samlingar ska kunna jämföras lika måste de vara av samma typ, ha "
"samma längd och varje par av motsvarande element måste jämföras lika (till "
"exempel är ``[1,2] == (1,2)`` falskt eftersom typen inte är densamma)."

#: ../../reference/expressions.rst:1557
msgid ""
"Collections that support order comparison are ordered the same as their "
"first unequal elements (for example, ``[1,2,x] <= [1,2,y]`` has the same "
"value as ``x <= y``).  If a corresponding element does not exist, the "
"shorter collection is ordered first (for example, ``[1,2] < [1,2,3]`` is "
"true)."
msgstr ""
"Samlingar som stöder orderjämförelse ordnas på samma sätt som deras första "
"ojämna element (till exempel har ``[1,2,x] <= [1,2,y]`` samma värde som ``x "
"<= y``).  Om det inte finns något motsvarande element ordnas den kortare "
"samlingen först (t.ex. ``[1,2] < [1,2,3]`` är sant)."

#: ../../reference/expressions.rst:1563
msgid ""
"Mappings (instances of :class:`dict`) compare equal if and only if they have "
"equal ``(key, value)`` pairs. Equality comparison of the keys and values "
"enforces reflexivity."
msgstr ""
"Avbildningar (instanser av :class:`dict`) jämför lika om och endast om de "
"har lika ``(nyckel, värde)``-par. Jämförelse av nycklar och värden som är "
"lika verkställer reflexivitet."

#: ../../reference/expressions.rst:1567
msgid ""
"Order comparisons (``<``, ``>``, ``<=``, and ``>=``) raise :exc:`TypeError`."
msgstr ""
"Orderjämförelser (``<``, ``>``, ``<=`` och ``>=``) ger upphov till :exc:"
"`TypeError`."

#: ../../reference/expressions.rst:1569
msgid ""
"Sets (instances of :class:`set` or :class:`frozenset`) can be compared "
"within and across their types."
msgstr ""
"Uppsättningar (instanser av :class:`set` eller :class:`frozenset`) kan "
"jämföras inom och mellan sina typer."

#: ../../reference/expressions.rst:1572
msgid ""
"They define order comparison operators to mean subset and superset tests.  "
"Those relations do not define total orderings (for example, the two sets "
"``{1,2}`` and ``{2,3}`` are not equal, nor subsets of one another, nor "
"supersets of one another).  Accordingly, sets are not appropriate arguments "
"for functions which depend on total ordering (for example, :func:`min`, :"
"func:`max`, and :func:`sorted` produce undefined results given a list of "
"sets as inputs)."
msgstr ""
"De definierar operatorer för jämförelse av ordningar som innebär test av "
"delmängder och övermängder.  Dessa relationer definierar inte totalordning "
"(till exempel är de två mängderna ``{1,2}`` och ``{2,3}`` inte lika, och "
"inte heller delmängder av varandra eller övermängder av varandra).  "
"Följaktligen är mängder inte lämpliga argument för funktioner som är "
"beroende av total ordning (till exempel :func:`min`, :func:`max` och :func:"
"`sorted` ger odefinierade resultat om de får en lista med mängder som "
"indata)."

#: ../../reference/expressions.rst:1580
msgid "Comparison of sets enforces reflexivity of its elements."
msgstr ""
"Jämförelse av uppsättningar tvingar fram reflexivitet hos dess element."

#: ../../reference/expressions.rst:1582
msgid ""
"Most other built-in types have no comparison methods implemented, so they "
"inherit the default comparison behavior."
msgstr ""
"De flesta andra inbyggda typer har inga jämförelsemetoder implementerade, så "
"de ärver standardjämförelsebeteendet."

#: ../../reference/expressions.rst:1585
msgid ""
"User-defined classes that customize their comparison behavior should follow "
"some consistency rules, if possible:"
msgstr ""
"Användardefinierade klasser som anpassar sitt jämförelsebeteende bör om "
"möjligt följa vissa konsistensregler:"

#: ../../reference/expressions.rst:1588
msgid ""
"Equality comparison should be reflexive. In other words, identical objects "
"should compare equal:"
msgstr ""
"Jämförelse av jämlikhet bör vara reflexiv. Med andra ord bör identiska "
"objekt jämföras lika:"

#: ../../reference/expressions.rst:1591
msgid "``x is y`` implies ``x == y``"
msgstr "``x är y`` innebär ``x == y``"

#: ../../reference/expressions.rst:1593
msgid ""
"Comparison should be symmetric. In other words, the following expressions "
"should have the same result:"
msgstr ""
"Jämförelsen ska vara symmetrisk. Med andra ord ska följande uttryck ge samma "
"resultat:"

#: ../../reference/expressions.rst:1596
msgid "``x == y`` and ``y == x``"
msgstr "``x == y`` och ``y == x``"

#: ../../reference/expressions.rst:1598
msgid "``x != y`` and ``y != x``"
msgstr "``x != y`` och ``y != x``"

#: ../../reference/expressions.rst:1600
msgid "``x < y`` and ``y > x``"
msgstr "``x < y`` och ``y > x``"

#: ../../reference/expressions.rst:1602
msgid "``x <= y`` and ``y >= x``"
msgstr "``x <= y`` och ``y >= x``"

#: ../../reference/expressions.rst:1604
msgid ""
"Comparison should be transitive. The following (non-exhaustive) examples "
"illustrate that:"
msgstr ""
"Jämförelsen ska vara transitiv. Följande (icke uttömmande) exempel "
"illustrerar detta:"

#: ../../reference/expressions.rst:1607
msgid "``x > y and y > z`` implies ``x > z``"
msgstr "``x > y och y > z`` innebär ``x > z``"

#: ../../reference/expressions.rst:1609
msgid "``x < y and y <= z`` implies ``x < z``"
msgstr "``x < y och y <= z`` innebär ``x < z``"

#: ../../reference/expressions.rst:1611
msgid ""
"Inverse comparison should result in the boolean negation. In other words, "
"the following expressions should have the same result:"
msgstr ""
"Omvänd jämförelse bör resultera i den booleska negationen. Med andra ord bör "
"följande uttryck ge samma resultat:"

#: ../../reference/expressions.rst:1614
msgid "``x == y`` and ``not x != y``"
msgstr "``x == y`` och ``not x != y``"

#: ../../reference/expressions.rst:1616
msgid "``x < y`` and ``not x >= y`` (for total ordering)"
msgstr "``x < y`` och ``not x >= y`` (för total ordning)"

#: ../../reference/expressions.rst:1618
msgid "``x > y`` and ``not x <= y`` (for total ordering)"
msgstr "``x > y`` och ``not x <= y`` (för total ordning)"

#: ../../reference/expressions.rst:1620
msgid ""
"The last two expressions apply to totally ordered collections (e.g. to "
"sequences, but not to sets or mappings). See also the :func:`~functools."
"total_ordering` decorator."
msgstr ""
"De två sista uttrycken gäller för totalt ordnade samlingar (t.ex. sekvenser, "
"men inte för mängder eller avbildningar). Se även dekoratorn :func:"
"`~functools.total_ordering`."

#: ../../reference/expressions.rst:1624
msgid ""
"The :func:`hash` result should be consistent with equality. Objects that are "
"equal should either have the same hash value, or be marked as unhashable."
msgstr ""
"Resultatet av :func:`hash` bör vara förenligt med likhet. Objekt som är lika "
"bör antingen ha samma hashvärde eller markeras som icke-hashbara."

#: ../../reference/expressions.rst:1628
msgid ""
"Python does not enforce these consistency rules. In fact, the not-a-number "
"values are an example for not following these rules."
msgstr ""
"Python upprätthåller inte dessa konsistensregler. Faktum är att värdena för "
"not-a-number är ett exempel på att dessa regler inte följs."

#: ../../reference/expressions.rst:1637
msgid "Membership test operations"
msgstr "Testverksamhet för medlemskap"

#: ../../reference/expressions.rst:1639
msgid ""
"The operators :keyword:`in` and :keyword:`not in` test for membership.  ``x "
"in s`` evaluates to ``True`` if *x* is a member of *s*, and ``False`` "
"otherwise. ``x not in s`` returns the negation of ``x in s``.  All built-in "
"sequences and set types support this as well as dictionary, for which :"
"keyword:`!in` tests whether the dictionary has a given key. For container "
"types such as list, tuple, set, frozenset, dict, or collections.deque, the "
"expression ``x in y`` is equivalent to ``any(x is e or x == e for e in y)``."
msgstr ""
"Operatorerna :keyword:`in` och :keyword:`not in` testar medlemskap.  ``x in "
"s`` utvärderas till ``True`` om *x* är en medlem av *s*, och ``False`` "
"annars. ``x not in s`` returnerar negationen av ``x in s``.  Alla inbyggda "
"sekvenser och set-typer stöder detta liksom dictionary, för vilket :keyword:"
"`!in` testar om dictionary har en given nyckel. För containertyper som list, "
"tuple, set, frozenset, dict eller collections.deque är uttrycket ``x in y`` "
"ekvivalent med ``any(x is e or x == e for e in y)``."

#: ../../reference/expressions.rst:1647
msgid ""
"For the string and bytes types, ``x in y`` is ``True`` if and only if *x* is "
"a substring of *y*.  An equivalent test is ``y.find(x) != -1``.  Empty "
"strings are always considered to be a substring of any other string, so "
"``\"\" in \"abc\"`` will return ``True``."
msgstr ""
"För sträng- och bytestyperna är ``x in y`` ``True`` om och endast om *x* är "
"en delsträng av *y*.  Ett motsvarande test är ``y.find(x) != -1``.  Tomma "
"strängar anses alltid vara en delsträng av någon annan sträng, så ``\"\" i "
"\"abc\"`` kommer att returnera ``True``."

#: ../../reference/expressions.rst:1652
msgid ""
"For user-defined classes which define the :meth:`~object.__contains__` "
"method, ``x in y`` returns ``True`` if ``y.__contains__(x)`` returns a true "
"value, and ``False`` otherwise."
msgstr ""
"För användardefinierade klasser som definierar metoden :meth:`~object."
"__contains__` returnerar ``x in y`` ``True`` om ``y.__contains__(x)`` "
"returnerar ett sant värde och ``False`` annars."

#: ../../reference/expressions.rst:1656
msgid ""
"For user-defined classes which do not define :meth:`~object.__contains__` "
"but do define :meth:`~object.__iter__`, ``x in y`` is ``True`` if some value "
"``z``, for which the expression ``x is z or x == z`` is true, is produced "
"while iterating over ``y``. If an exception is raised during the iteration, "
"it is as if :keyword:`in` raised that exception."
msgstr ""
"För användardefinierade klasser som inte definierar :meth:`~object."
"__contains__` men som definierar :meth:`~object.__iter__`, är ``x in y`` "
"``True`` om något värde ``z``, för vilket uttrycket ``x är z eller x == z`` "
"är sant, produceras under iteration över ``y``. Om ett undantag görs under "
"iterationen, är det som om :keyword:`in` gjorde detta undantag."

#: ../../reference/expressions.rst:1662
msgid ""
"Lastly, the old-style iteration protocol is tried: if a class defines :meth:"
"`~object.__getitem__`, ``x in y`` is ``True`` if and only if there is a non-"
"negative integer index *i* such that ``x is y[i] or x == y[i]``, and no "
"lower integer index raises the :exc:`IndexError` exception.  (If any other "
"exception is raised, it is as if :keyword:`in` raised that exception)."
msgstr ""
"Slutligen prövas det gamla iterationsprotokollet: om en klass definierar :"
"meth:`~object.__getitem__`, är ``x in y`` ``True`` om och endast om det "
"finns ett icke-negativt heltalsindex *i* så att ``x är y[i] eller x == "
"y[i]``, och inget lägre heltalsindex ger upphov till :exc:`IndexError`-"
"undantaget.  (Om något annat undantag görs, är det som om :keyword:`in` "
"gjorde det undantaget)."

#: ../../reference/expressions.rst:1674
msgid ""
"The operator :keyword:`not in` is defined to have the inverse truth value "
"of :keyword:`in`."
msgstr ""
"Operatorn :keyword:`not in` är definierad att ha det omvända sanningsvärdet "
"av :keyword:`in`."

#: ../../reference/expressions.rst:1687
msgid "Identity comparisons"
msgstr "Identitetsjämförelser"

#: ../../reference/expressions.rst:1689
msgid ""
"The operators :keyword:`is` and :keyword:`is not` test for an object's "
"identity: ``x is y`` is true if and only if *x* and *y* are the same "
"object.  An Object's identity is determined using the :meth:`id` function.  "
"``x is not y`` yields the inverse truth value. [#]_"
msgstr ""
"Operatorerna :keyword:`is` och :keyword:`is not` testar ett objekts "
"identitet: ``x är y`` är sant om och endast om *x* och *y* är samma objekt.  "
"Ett objekts identitet bestäms med hjälp av funktionen :meth:`id`.  ``x är "
"inte y`` ger det omvända sanningsvärdet. "

#: ../../reference/expressions.rst:1701
msgid "Boolean operations"
msgstr "Booleska operationer"

#: ../../reference/expressions.rst:1712
msgid ""
"In the context of Boolean operations, and also when expressions are used by "
"control flow statements, the following values are interpreted as false: "
"``False``, ``None``, numeric zero of all types, and empty strings and "
"containers (including strings, tuples, lists, dictionaries, sets and "
"frozensets).  All other values are interpreted as true.  User-defined "
"objects can customize their truth value by providing a :meth:`~object."
"__bool__` method."
msgstr ""
"I samband med booleska operationer, och även när uttryck används av "
"kontrollflödessatser, tolkas följande värden som falska: ``False``, "
"``None``, numeriska nollor av alla typer, och tomma strängar och behållare "
"(inklusive strängar, tupler, listor, ordböcker, mängder och frozensets).  "
"Alla andra värden tolkas som sanna.  Användardefinierade objekt kan anpassa "
"sitt sanningsvärde genom att tillhandahålla en :meth:`~object.__bool__`-"
"metod."

#: ../../reference/expressions.rst:1721
msgid ""
"The operator :keyword:`not` yields ``True`` if its argument is false, "
"``False`` otherwise."
msgstr ""
"Operatorn :keyword:`not` ger ``True`` om dess argument är falskt, ``False`` "
"annars."

#: ../../reference/expressions.rst:1726
msgid ""
"The expression ``x and y`` first evaluates *x*; if *x* is false, its value "
"is returned; otherwise, *y* is evaluated and the resulting value is returned."
msgstr ""
"Uttrycket ``x och y`` utvärderar först *x*; om *x* är falskt returneras dess "
"värde; i annat fall utvärderas *y* och det resulterande värdet returneras."

#: ../../reference/expressions.rst:1731
msgid ""
"The expression ``x or y`` first evaluates *x*; if *x* is true, its value is "
"returned; otherwise, *y* is evaluated and the resulting value is returned."
msgstr ""
"Uttrycket ``x eller y`` utvärderar först *x*; om *x* är sant returneras dess "
"värde; annars utvärderas *y* och det resulterande värdet returneras."

#: ../../reference/expressions.rst:1734
msgid ""
"Note that neither :keyword:`and` nor :keyword:`or` restrict the value and "
"type they return to ``False`` and ``True``, but rather return the last "
"evaluated argument.  This is sometimes useful, e.g., if ``s`` is a string "
"that should be replaced by a default value if it is empty, the expression "
"``s or 'foo'`` yields the desired value.  Because :keyword:`not` has to "
"create a new value, it returns a boolean value regardless of the type of its "
"argument (for example, ``not 'foo'`` produces ``False`` rather than ``''``.)"
msgstr ""
"Observera att varken :keyword:`and` eller :keyword:`or` begränsar värdet och "
"typen som returneras till ``False`` och ``True``, utan returnerar det senast "
"utvärderade argumentet.  Detta är ibland användbart, t.ex. om ``s`` är en "
"sträng som ska ersättas med ett standardvärde om den är tom, ger uttrycket "
"``s eller 'foo'`` det önskade värdet.  Eftersom :keyword:`not` måste skapa "
"ett nytt värde, returnerar det ett booleskt värde oavsett typen av argument "
"(till exempel, ``not 'foo'`` producerar ``False`` snarare än ``''``)"

#: ../../reference/expressions.rst:1750
msgid "Assignment expressions"
msgstr "Uppdragets uttryck"

#: ../../reference/expressions.rst:1755
msgid ""
"An assignment expression (sometimes also called a \"named expression\" or "
"\"walrus\") assigns an :token:`~python-grammar:expression` to an :token:"
"`~python-grammar:identifier`, while also returning the value of the :token:"
"`~python-grammar:expression`."
msgstr ""
"Ett tilldelningsuttryck (ibland även kallat \"namngivet uttryck\" eller "
"\"valross\") tilldelar en :token:`~python-grammar:expression` till en :token:"
"`~python-grammar:identifier`, samtidigt som det returnerar värdet av :token:"
"`~python-grammar:expression`."

#: ../../reference/expressions.rst:1760
msgid "One common use case is when handling matched regular expressions:"
msgstr ""
"Ett vanligt användningsfall är när man hanterar matchade reguljära uttryck:"

#: ../../reference/expressions.rst:1767
msgid "Or, when processing a file stream in chunks:"
msgstr "Eller när du bearbetar en filström i bitar:"

#: ../../reference/expressions.rst:1774
msgid ""
"Assignment expressions must be surrounded by parentheses when used as "
"expression statements and when used as sub-expressions in slicing, "
"conditional, lambda, keyword-argument, and comprehension-if expressions and "
"in ``assert``, ``with``, and ``assignment`` statements. In all other places "
"where they can be used, parentheses are not required, including in ``if`` "
"and ``while`` statements."
msgstr ""
"Tilldelningsuttryck måste omges av parenteser när de används som "
"uttryckssatser och när de används som underuttryck i slicing-, conditional-, "
"lambda-, keyword-argument- och comprehension-if-uttryck samt i ``assert``-, "
"``with``- och ``assignment``-satser. Parenteser behövs inte på alla andra "
"ställen där de kan användas, inklusive i ``if``- och ``while``-satser."

#: ../../reference/expressions.rst:1782
msgid "See :pep:`572` for more details about assignment expressions."
msgstr "Se :pep:`572` för mer information om assignment-uttryck."

#: ../../reference/expressions.rst:1789
msgid "Conditional expressions"
msgstr "Villkorliga uttryck"

#: ../../reference/expressions.rst:1801
msgid ""
"Conditional expressions (sometimes called a \"ternary operator\") have the "
"lowest priority of all Python operations."
msgstr ""
"Villkorliga uttryck (kallas ibland \"ternär operator\") har den lägsta "
"prioriteten av alla Python-operationer."

#: ../../reference/expressions.rst:1804
msgid ""
"The expression ``x if C else y`` first evaluates the condition, *C* rather "
"than *x*. If *C* is true, *x* is evaluated and its value is returned; "
"otherwise, *y* is evaluated and its value is returned."
msgstr ""
"Uttrycket ``x if C else y`` utvärderar först villkoret *C* i stället för "
"*x*. Om *C* är sant, utvärderas *x* och dess värde returneras; annars "
"utvärderas *y* och dess värde returneras."

#: ../../reference/expressions.rst:1808
msgid "See :pep:`308` for more details about conditional expressions."
msgstr "Se :pep:`308` för mer information om villkorliga uttryck."

#: ../../reference/expressions.rst:1815
msgid "Lambdas"
msgstr "Lambdas"

#: ../../reference/expressions.rst:1826
msgid ""
"Lambda expressions (sometimes called lambda forms) are used to create "
"anonymous functions. The expression ``lambda parameters: expression`` yields "
"a function object.  The unnamed object behaves like a function object "
"defined with:"
msgstr ""
"Lambda-uttryck (ibland kallade lambda-formulär) används för att skapa "
"anonyma funktioner. Uttrycket ``lambda parameters: expression`` ger ett "
"funktionsobjekt.  Det namnlösa objektet beter sig som ett funktionsobjekt "
"definierat med:"

#: ../../reference/expressions.rst:1835
msgid ""
"See section :ref:`function` for the syntax of parameter lists.  Note that "
"functions created with lambda expressions cannot contain statements or "
"annotations."
msgstr ""
"Se avsnitt :ref:`function` för syntaxen för parameterlistor.  Observera att "
"funktioner som skapas med lambda-uttryck inte kan innehålla satser eller "
"annoteringar."

#: ../../reference/expressions.rst:1843
msgid "Expression lists"
msgstr "Uttryckslistor"

#: ../../reference/expressions.rst:1857
msgid ""
"Except when part of a list or set display, an expression list containing at "
"least one comma yields a tuple.  The length of the tuple is the number of "
"expressions in the list.  The expressions are evaluated from left to right."
msgstr ""
"En uttrycksförteckning som innehåller minst ett kommatecken ger en tupel, "
"utom när den ingår i en list- eller set-visning.  Längden på tupeln är lika "
"med antalet uttryck i listan.  Uttrycken utvärderas från vänster till höger."

#: ../../reference/expressions.rst:1866
msgid ""
"An asterisk ``*`` denotes :dfn:`iterable unpacking`.  Its operand must be "
"an :term:`iterable`.  The iterable is expanded into a sequence of items, "
"which are included in the new tuple, list, or set, at the site of the "
"unpacking."
msgstr ""
"En asterisk ``*`` betecknar :dfn:`iterable unpacking`.  Dess operand måste "
"vara en :term:`iterable`.  Den iterabla expanderas till en sekvens av objekt "
"som ingår i den nya tupeln, listan eller mängden på platsen för uppackningen."

#: ../../reference/expressions.rst:1871
msgid ""
"Iterable unpacking in expression lists, originally proposed by :pep:`448`."
msgstr ""
"Iterabel uppackning i uttrycksförteckningar, ursprungligen föreslagen av :"
"pep:`448`."

#: ../../reference/expressions.rst:1876
msgid ""
"A trailing comma is required only to create a one-item tuple, such as ``1,"
"``; it is optional in all other cases. A single expression without a "
"trailing comma doesn't create a tuple, but rather yields the value of that "
"expression. (To create an empty tuple, use an empty pair of parentheses: "
"``()``.)"
msgstr ""
"Ett efterföljande kommatecken krävs endast för att skapa en tupel med en "
"post, t.ex. ``1,``; det är valfritt i alla andra fall. Ett enstaka uttryck "
"utan efterföljande kommatecken skapar inte en tupel, utan ger värdet av "
"uttrycket. (Om du vill skapa en tom tupel använder du ett tomt par "
"parenteser: ``()``.)"

#: ../../reference/expressions.rst:1887
msgid "Evaluation order"
msgstr "Utvärderingsorder"

#: ../../reference/expressions.rst:1891
msgid ""
"Python evaluates expressions from left to right.  Notice that while "
"evaluating an assignment, the right-hand side is evaluated before the left-"
"hand side."
msgstr ""
"Python utvärderar uttryck från vänster till höger.  Lägg märke till att när "
"du utvärderar en tilldelning utvärderas högersidan före vänstersidan."

#: ../../reference/expressions.rst:1894
msgid ""
"In the following lines, expressions will be evaluated in the arithmetic "
"order of their suffixes::"
msgstr ""
"I följande rader kommer uttrycken att utvärderas i aritmetisk ordning efter "
"sina suffix::"

#: ../../reference/expressions.rst:1908
msgid "Operator precedence"
msgstr "Operatörens företräde"

#: ../../reference/expressions.rst:1913
msgid ""
"The following table summarizes the operator precedence in Python, from "
"highest precedence (most binding) to lowest precedence (least binding).  "
"Operators in the same box have the same precedence.  Unless the syntax is "
"explicitly given, operators are binary.  Operators in the same box group "
"left to right (except for exponentiation and conditional expressions, which "
"group from right to left)."
msgstr ""
"Följande tabell sammanfattar operatörsprioriteringen i Python, från högsta "
"prioritet (mest bindande) till lägsta prioritet (minst bindande).  "
"Operatorer i samma ruta har samma företräde.  Om inte syntaxen uttryckligen "
"anges är operatorer binära.  Operatorer i samma ruta grupperas från vänster "
"till höger (med undantag för exponentiering och villkorliga uttryck, som "
"grupperas från höger till vänster)."

#: ../../reference/expressions.rst:1919
msgid ""
"Note that comparisons, membership tests, and identity tests, all have the "
"same precedence and have a left-to-right chaining feature as described in "
"the :ref:`comparisons` section."
msgstr ""
"Observera att jämförelser, medlemskapstest och identitetstest alla har samma "
"företräde och har en vänster-till-höger kedjefunktion som beskrivs i "
"avsnittet :ref:`comparisons`."

#: ../../reference/expressions.rst:1925
msgid "Operator"
msgstr "Operatör"

#: ../../reference/expressions.rst:1925
msgid "Description"
msgstr "Beskrivning"

#: ../../reference/expressions.rst:1927
msgid "``(expressions...)``,"
msgstr "``(uttryck...)``,"

#: ../../reference/expressions.rst:1929
msgid "``[expressions...]``, ``{key: value...}``, ``{expressions...}``"
msgstr "``[uttryck...]``, ``{nyckel: värde...}`, ``{expressions...}``"

#: ../../reference/expressions.rst:1927
msgid ""
"Binding or parenthesized expression, list display, dictionary display, set "
"display"
msgstr ""
"Bindande eller parentetiskt uttryck, listvisning, ordboksvisning, set-visning"

#: ../../reference/expressions.rst:1933
msgid "``x[index]``, ``x[index:index]``, ``x(arguments...)``, ``x.attribute``"
msgstr "``x[index]``, ``x[index:index]``, ``x(argument...)``, ``x.attribute``"

#: ../../reference/expressions.rst:1933
msgid "Subscription, slicing, call, attribute reference"
msgstr "Prenumeration, slicing, samtal, attributreferens"

#: ../../reference/expressions.rst:1936
msgid ":keyword:`await x <await>`"
msgstr ":nyckelord:`await x <await>`"

#: ../../reference/expressions.rst:1938
msgid "``**``"
msgstr "``**``"

#: ../../reference/expressions.rst:1938
msgid "Exponentiation [#]_"
msgstr "Exponentiering [#]_"

#: ../../reference/expressions.rst:1940
msgid "``+x``, ``-x``, ``~x``"
msgstr "``+x``, ``-x``, ``~x``"

#: ../../reference/expressions.rst:1940
msgid "Positive, negative, bitwise NOT"
msgstr "Positiv, negativ, bitvis NOT"

#: ../../reference/expressions.rst:1942
msgid "``*``, ``@``, ``/``, ``//``, ``%``"
msgstr "``*``, ``@``, ``/``, ``//``, ``%``"

#: ../../reference/expressions.rst:1942
msgid ""
"Multiplication, matrix multiplication, division, floor division, remainder "
"[#]_"
msgstr ""
"Multiplikation, matrismultiplikation, division, våningsdivision, rest [#]_"

#: ../../reference/expressions.rst:1946
msgid "``+``, ``-``"
msgstr "``+``, ``-``"

#: ../../reference/expressions.rst:1946
msgid "Addition and subtraction"
msgstr "Addition och subtraktion"

#: ../../reference/expressions.rst:1948
msgid "``<<``, ``>>``"
msgstr "``<<``, ``>>``"

#: ../../reference/expressions.rst:1948
msgid "Shifts"
msgstr "Skift"

#: ../../reference/expressions.rst:1950
msgid "``&``"
msgstr "``&``"

#: ../../reference/expressions.rst:1950
msgid "Bitwise AND"
msgstr "Bitvis AND"

#: ../../reference/expressions.rst:1952
msgid "``^``"
msgstr "``^``"

#: ../../reference/expressions.rst:1952
msgid "Bitwise XOR"
msgstr "Bitvis XOR"

#: ../../reference/expressions.rst:1954
msgid "``|``"
msgstr "``|``"

#: ../../reference/expressions.rst:1954
msgid "Bitwise OR"
msgstr "Bitvis OR"

#: ../../reference/expressions.rst:1956
msgid ""
":keyword:`in`, :keyword:`not in`, :keyword:`is`, :keyword:`is not`, ``<``, "
"``<=``, ``>``, ``>=``, ``!=``, ``==``"
msgstr ""
":keyword:`in`, :keyword:`not in`, :keyword:`is`, :keyword:`is not`, ``<``, "
"``<=``, ``>``, ``>=``, ``!=``, ``==``"

#: ../../reference/expressions.rst:1956
msgid "Comparisons, including membership tests and identity tests"
msgstr "Jämförelser, inklusive medlemstester och identitetstester"

#: ../../reference/expressions.rst:1960
msgid ":keyword:`not x <not>`"
msgstr ":nyckelord:`inte x <not>`"

#: ../../reference/expressions.rst:1960
msgid "Boolean NOT"
msgstr "Boolean NOT"

#: ../../reference/expressions.rst:1962
msgid ":keyword:`and`"
msgstr ":nyckelord:`och`"

#: ../../reference/expressions.rst:1962
msgid "Boolean AND"
msgstr "Booleansk AND"

#: ../../reference/expressions.rst:1964
msgid ":keyword:`or`"
msgstr ":nyckelord:`eller`"

#: ../../reference/expressions.rst:1964
msgid "Boolean OR"
msgstr "Booleansk OR"

#: ../../reference/expressions.rst:1966
msgid ":keyword:`if <if_expr>` -- :keyword:`!else`"
msgstr ":keyword:`if <if_expr>` -- :keyword:`!else`"

#: ../../reference/expressions.rst:1966
msgid "Conditional expression"
msgstr "Villkorligt uttryck"

#: ../../reference/expressions.rst:1968
msgid ":keyword:`lambda`"
msgstr ":nyckelord:`lambda`"

#: ../../reference/expressions.rst:1968
msgid "Lambda expression"
msgstr "Lambda-uttryck"

#: ../../reference/expressions.rst:1970
msgid "``:=``"
msgstr "``:=``"

#: ../../reference/expressions.rst:1970
msgid "Assignment expression"
msgstr "Uppdragets uttryck"

#: ../../reference/expressions.rst:1975
msgid "Footnotes"
msgstr "Fotnoter"

#: ../../reference/expressions.rst:1976
msgid ""
"While ``abs(x%y) < abs(y)`` is true mathematically, for floats it may not be "
"true numerically due to roundoff.  For example, and assuming a platform on "
"which a Python float is an IEEE 754 double-precision number, in order that "
"``-1e-100 % 1e100`` have the same sign as ``1e100``, the computed result is "
"``-1e-100 + 1e100``, which is numerically exactly equal to ``1e100``.  The "
"function :func:`math.fmod` returns a result whose sign matches the sign of "
"the first argument instead, and so returns ``-1e-100`` in this case. Which "
"approach is more appropriate depends on the application."
msgstr ""
"Medan ``abs(x%y) < abs(y)`` är sant matematiskt, är det för flottörer kanske "
"inte sant numeriskt på grund av avrundning.  Till exempel, och förutsatt att "
"en plattform där en Python float är ett IEEE 754 dubbelprecisionstal, för "
"att ``-1e-100 % 1e100`` ska ha samma tecken som ``1e100``, är det beräknade "
"resultatet ``-1e-100 + 1e100``, vilket är numeriskt exakt lika med "
"``1e100``.  Funktionen :func:`math.fmod` returnerar istället ett resultat "
"vars tecken matchar tecknet på det första argumentet, och returnerar alltså "
"``-1e-100`` i det här fallet. Vilket tillvägagångssätt som är lämpligast "
"beror på tillämpningen."

#: ../../reference/expressions.rst:1985
msgid ""
"If x is very close to an exact integer multiple of y, it's possible for ``x//"
"y`` to be one larger than ``(x-x%y)//y`` due to rounding.  In such cases, "
"Python returns the latter result, in order to preserve that ``divmod(x,y)[0] "
"* y + x % y`` be very close to ``x``."
msgstr ""
"Om x är mycket nära en exakt heltalsmultipel av y, är det möjligt att ``x//"
"y`` är ett större än ``(x-x%y)//y`` på grund av avrundning.  I sådana fall "
"returnerar Python det senare resultatet, för att bevara att ``divmod(x,y)[0] "
"* y + x % y`` är mycket nära ``x``."

#: ../../reference/expressions.rst:1990
msgid ""
"The Unicode standard distinguishes between :dfn:`code points` (e.g. U+0041) "
"and :dfn:`abstract characters` (e.g. \"LATIN CAPITAL LETTER A\"). While most "
"abstract characters in Unicode are only represented using one code point, "
"there is a number of abstract characters that can in addition be represented "
"using a sequence of more than one code point.  For example, the abstract "
"character \"LATIN CAPITAL LETTER C WITH CEDILLA\" can be represented as a "
"single :dfn:`precomposed character` at code position U+00C7, or as a "
"sequence of a :dfn:`base character` at code position U+0043 (LATIN CAPITAL "
"LETTER C), followed by a :dfn:`combining character` at code position U+0327 "
"(COMBINING CEDILLA)."
msgstr ""
"Unicode-standarden skiljer mellan :dfn:`kodpunkter` (t.ex. U+0041) och :dfn:"
"`abstrakta tecken` (t.ex. \"LATIN CAPITAL LETTER A\"). Även om de flesta "
"abstrakta tecken i Unicode endast representeras med en kodpunkt, finns det "
"ett antal abstrakta tecken som dessutom kan representeras med en sekvens av "
"mer än en kodpunkt.  Till exempel kan det abstrakta tecknet \"LATIN CAPITAL "
"LETTER C WITH CEDILLA\" representeras som ett enda :dfn:`förkomponerat "
"tecken` vid kodposition U+00C7, eller som en sekvens av ett :dfn:`bas-"
"tecken` vid kodposition U+0043 (LATIN CAPITAL LETTER C), följt av ett :dfn:"
"`kombinationstecken` vid kodposition U+0327 (KOMBINERANDE CEDILLA)."

#: ../../reference/expressions.rst:2001
msgid ""
"The comparison operators on strings compare at the level of Unicode code "
"points. This may be counter-intuitive to humans.  For example, ``\"\\u00C7\" "
"== \"\\u0043\\u0327\"`` is ``False``, even though both strings represent the "
"same abstract character \"LATIN CAPITAL LETTER C WITH CEDILLA\"."
msgstr ""
"Jämförelseoperatorerna på strängar jämför på nivån för Unicode-kodpunkter. "
"Detta kan vara kontraintuitivt för människor.  Till exempel är ``\"\\u00C7\" "
"== \"\\u0043\\u0327\"``falskt``, även om båda strängarna representerar samma "
"abstrakta tecken \"LATIN CAPITAL LETTER C WITH CEDILLA\"."

#: ../../reference/expressions.rst:2006
msgid ""
"To compare strings at the level of abstract characters (that is, in a way "
"intuitive to humans), use :func:`unicodedata.normalize`."
msgstr ""
"Om du vill jämföra strängar på nivån för abstrakta tecken (dvs. på ett sätt "
"som är intuitivt för människor) använder du :func:`unicodedata.normalize`."

#: ../../reference/expressions.rst:2009
msgid ""
"Due to automatic garbage-collection, free lists, and the dynamic nature of "
"descriptors, you may notice seemingly unusual behaviour in certain uses of "
"the :keyword:`is` operator, like those involving comparisons between "
"instance methods, or constants.  Check their documentation for more info."
msgstr ""
"På grund av automatisk garbage-collection, fria listor och deskriptorns "
"dynamiska natur kan du märka ett till synes ovanligt beteende i vissa "
"användningar av operatorn :keyword:`is`, till exempel när det gäller "
"jämförelser mellan instansmetoder eller konstanter.  Kontrollera deras "
"dokumentation för mer information."

#: ../../reference/expressions.rst:2014
msgid ""
"The power operator ``**`` binds less tightly than an arithmetic or bitwise "
"unary operator on its right, that is, ``2**-1`` is ``0.5``."
msgstr ""
"Potensoperatorn ``**`` binder mindre hårt än en aritmetisk eller bitvis unär "
"operator till höger om den, det vill säga ``2**-1`` är ``0,5``."

#: ../../reference/expressions.rst:2017
msgid ""
"The ``%`` operator is also used for string formatting; the same precedence "
"applies."
msgstr ""
"Operatorn ``%`` används också för strängformatering; samma företräde gäller."

#: ../../reference/expressions.rst:8 ../../reference/expressions.rst:362
#: ../../reference/expressions.rst:417 ../../reference/expressions.rst:1703
#: ../../reference/expressions.rst:1791 ../../reference/expressions.rst:1817
#: ../../reference/expressions.rst:1845
msgid "expression"
msgstr "uttryck"

#: ../../reference/expressions.rst:8
msgid "BNF"
msgstr "BNF"

#: ../../reference/expressions.rst:28 ../../reference/expressions.rst:1204
#: ../../reference/expressions.rst:1252
msgid "arithmetic"
msgstr "aritmetisk"

#: ../../reference/expressions.rst:28
msgid "conversion"
msgstr "omvandling"

#: ../../reference/expressions.rst:51
msgid "atom"
msgstr "atom"

#: ../../reference/expressions.rst:68 ../../reference/expressions.rst:82
msgid "name"
msgstr "namn"

#: ../../reference/expressions.rst:68
msgid "identifier"
msgstr "identifierare"

#: ../../reference/expressions.rst:74 ../../reference/expressions.rst:538
#: ../../reference/expressions.rst:588 ../../reference/expressions.rst:710
#: ../../reference/expressions.rst:757 ../../reference/expressions.rst:803
#: ../../reference/expressions.rst:1241 ../../reference/expressions.rst:1287
#: ../../reference/expressions.rst:1377
msgid "exception"
msgstr "undantag"

#: ../../reference/expressions.rst:74
msgid "NameError"
msgstr "NamnFel"

#: ../../reference/expressions.rst:82
msgid "mangling"
msgstr "mangling"

#: ../../reference/expressions.rst:82
msgid "private"
msgstr "privat"

#: ../../reference/expressions.rst:82
msgid "names"
msgstr "namn"

#: ../../reference/expressions.rst:104
msgid "literal"
msgstr "bokstavlig"

#: ../../reference/expressions.rst:117 ../../reference/expressions.rst:341
msgid "immutable"
msgstr "oföränderlig"

#: ../../reference/expressions.rst:117
msgid "data"
msgstr "data"

#: ../../reference/expressions.rst:117
msgid "type"
msgstr "type"

#: ../../reference/expressions.rst:117 ../../reference/expressions.rst:244
#: ../../reference/expressions.rst:270 ../../reference/expressions.rst:298
#: ../../reference/expressions.rst:341 ../../reference/expressions.rst:362
#: ../../reference/expressions.rst:526 ../../reference/expressions.rst:700
#: ../../reference/expressions.rst:803 ../../reference/expressions.rst:832
#: ../../reference/expressions.rst:905 ../../reference/expressions.rst:949
#: ../../reference/expressions.rst:1097 ../../reference/expressions.rst:1110
#: ../../reference/expressions.rst:1124 ../../reference/expressions.rst:1131
#: ../../reference/expressions.rst:1668 ../../reference/expressions.rst:1855
msgid "object"
msgstr "object"

#: ../../reference/expressions.rst:133
msgid "parenthesized form"
msgstr "parentesform"

#: ../../reference/expressions.rst:133 ../../reference/expressions.rst:362
#: ../../reference/expressions.rst:949
msgid "() (parentheses)"
msgstr "() (inom parentes)"

#: ../../reference/expressions.rst:133
msgid "tuple display"
msgstr "tupelvisning"

#: ../../reference/expressions.rst:146 ../../reference/expressions.rst:244
msgid "empty"
msgstr "tom"

#: ../../reference/expressions.rst:146 ../../reference/expressions.rst:832
#: ../../reference/expressions.rst:905 ../../reference/expressions.rst:1855
msgid "tuple"
msgstr "tupel"

#: ../../reference/expressions.rst:152 ../../reference/expressions.rst:1874
msgid "comma"
msgstr "komma"

#: ../../reference/expressions.rst:152 ../../reference/expressions.rst:244
#: ../../reference/expressions.rst:270 ../../reference/expressions.rst:298
#: ../../reference/expressions.rst:899 ../../reference/expressions.rst:949
#: ../../reference/expressions.rst:1845
msgid ", (comma)"
msgstr ", (kommatecken)"

#: ../../reference/expressions.rst:167 ../../reference/expressions.rst:244
#: ../../reference/expressions.rst:270 ../../reference/expressions.rst:298
msgid "comprehensions"
msgstr "förståelser"

#: ../../reference/expressions.rst:177
msgid "for"
msgstr "för"

#: ../../reference/expressions.rst:177 ../../reference/expressions.rst:212
msgid "in comprehensions"
msgstr "i förståelser"

#: ../../reference/expressions.rst:177 ../../reference/expressions.rst:1791
msgid "if"
msgstr "om"

#: ../../reference/expressions.rst:177
msgid "async for"
msgstr "asynkron för"

#: ../../reference/expressions.rst:212 ../../reference/expressions.rst:1149
msgid "await"
msgstr "await"

#: ../../reference/expressions.rst:244 ../../reference/expressions.rst:803
#: ../../reference/expressions.rst:832 ../../reference/expressions.rst:905
#: ../../reference/expressions.rst:1845
msgid "list"
msgstr "list"

#: ../../reference/expressions.rst:244 ../../reference/expressions.rst:270
#: ../../reference/expressions.rst:298
msgid "display"
msgstr "display"

#: ../../reference/expressions.rst:244 ../../reference/expressions.rst:828
msgid "[] (square brackets)"
msgstr "[] (hakparenteser)"

#: ../../reference/expressions.rst:244
msgid "list expression"
msgstr "lista uttryck"

#: ../../reference/expressions.rst:244 ../../reference/expressions.rst:270
#: ../../reference/expressions.rst:1845
msgid "expression list"
msgstr "uttrycksförteckning"

#: ../../reference/expressions.rst:270
msgid "set"
msgstr "set"

#: ../../reference/expressions.rst:270 ../../reference/expressions.rst:298
msgid "{} (curly brackets)"
msgstr "{} (inom hakparentes)"

#: ../../reference/expressions.rst:270
msgid "set expression"
msgstr "inställt uttryck"

#: ../../reference/expressions.rst:298 ../../reference/expressions.rst:324
#: ../../reference/expressions.rst:832
msgid "dictionary"
msgstr "ordbok"

#: ../../reference/expressions.rst:298
msgid "key"
msgstr "nyckel"

#: ../../reference/expressions.rst:298
msgid "value"
msgstr "värde"

#: ../../reference/expressions.rst:298
msgid "key/value pair"
msgstr "nyckel/värde-par"

#: ../../reference/expressions.rst:298
msgid "dictionary expression"
msgstr "ordboksuttryck"

#: ../../reference/expressions.rst:298 ../../reference/expressions.rst:899
#: ../../reference/expressions.rst:1817
msgid ": (colon)"
msgstr ": (kolon)"

#: ../../reference/expressions.rst:298
msgid "in dictionary expressions"
msgstr "i ordboksuttryck"

#: ../../reference/expressions.rst:298 ../../reference/expressions.rst:324
msgid "in dictionary displays"
msgstr "i ordboksuppslagningar"

#: ../../reference/expressions.rst:324 ../../reference/expressions.rst:1032
#: ../../reference/expressions.rst:1862
msgid "unpacking"
msgstr "uppackning"

#: ../../reference/expressions.rst:324 ../../reference/expressions.rst:1062
#: ../../reference/expressions.rst:1169
msgid "**"
msgstr "**"

#: ../../reference/expressions.rst:341
msgid "hashable"
msgstr "hashbar"

#: ../../reference/expressions.rst:362 ../../reference/expressions.rst:417
#: ../../reference/expressions.rst:526
msgid "generator"
msgstr "generator"

#: ../../reference/expressions.rst:362
msgid "generator expression"
msgstr "generatoruttryck"

#: ../../reference/expressions.rst:417 ../../reference/expressions.rst:1149
msgid "keyword"
msgstr "sökord"

#: ../../reference/expressions.rst:417 ../../reference/expressions.rst:601
msgid "yield"
msgstr "avkastning"

#: ../../reference/expressions.rst:417 ../../reference/expressions.rst:485
msgid "from"
msgstr "from"

#: ../../reference/expressions.rst:417 ../../reference/expressions.rst:1097
#: ../../reference/expressions.rst:1110 ../../reference/expressions.rst:1817
msgid "function"
msgstr "function"

#: ../../reference/expressions.rst:471
msgid "coroutine"
msgstr "coroutine"

#: ../../reference/expressions.rst:485
msgid "yield from expression"
msgstr "avkastning från uttryck"

#: ../../reference/expressions.rst:538
msgid "StopIteration"
msgstr "StopIteration"

#: ../../reference/expressions.rst:588 ../../reference/expressions.rst:757
msgid "GeneratorExit"
msgstr "GeneratorExit"

#: ../../reference/expressions.rst:601
msgid "examples"
msgstr "exempel"

#: ../../reference/expressions.rst:700
msgid "asynchronous-generator"
msgstr "asynkron-generator"

#: ../../reference/expressions.rst:710
msgid "StopAsyncIteration"
msgstr "StoppaAsyncIteration"

#: ../../reference/expressions.rst:780
msgid "primary"
msgstr "primär"

#: ../../reference/expressions.rst:794
msgid "attribute"
msgstr "attribut"

#: ../../reference/expressions.rst:794
msgid "reference"
msgstr "referens"

#: ../../reference/expressions.rst:794
msgid ". (dot)"
msgstr ". (punkt)"

#: ../../reference/expressions.rst:794
msgid "attribute reference"
msgstr "attributreferens"

#: ../../reference/expressions.rst:803
msgid "AttributeError"
msgstr "AttributFel"

#: ../../reference/expressions.rst:803
msgid "module"
msgstr "module"

#: ../../reference/expressions.rst:828
msgid "subscription"
msgstr "prenumeration"

#: ../../reference/expressions.rst:832 ../../reference/expressions.rst:905
#: ../../reference/expressions.rst:1668
msgid "sequence"
msgstr "sekvens"

#: ../../reference/expressions.rst:832
msgid "mapping"
msgstr "kartläggning"

#: ../../reference/expressions.rst:832 ../../reference/expressions.rst:885
#: ../../reference/expressions.rst:905
msgid "string"
msgstr "sträng"

#: ../../reference/expressions.rst:832 ../../reference/expressions.rst:885
msgid "item"
msgstr "objekt"

#: ../../reference/expressions.rst:885
msgid "character"
msgstr "tecken"

#: ../../reference/expressions.rst:899
msgid "slicing"
msgstr "skivning"

#: ../../reference/expressions.rst:899
msgid "slice"
msgstr "skiva"

#: ../../reference/expressions.rst:931
msgid "start (slice object attribute)"
msgstr "start (attribut för skivobjekt)"

#: ../../reference/expressions.rst:931
msgid "stop (slice object attribute)"
msgstr "stopp (attribut för skivobjekt)"

#: ../../reference/expressions.rst:931
msgid "step (slice object attribute)"
msgstr "steg (objektattribut för skiva)"

#: ../../reference/expressions.rst:949
msgid "callable"
msgstr "anropsbar"

#: ../../reference/expressions.rst:949 ../../reference/expressions.rst:1097
#: ../../reference/expressions.rst:1110 ../../reference/expressions.rst:1124
#: ../../reference/expressions.rst:1131 ../../reference/expressions.rst:1141
msgid "call"
msgstr "ring upp"

#: ../../reference/expressions.rst:949
msgid "argument"
msgstr "argument"

#: ../../reference/expressions.rst:949 ../../reference/expressions.rst:982
msgid "call semantics"
msgstr "semantik för anrop"

#: ../../reference/expressions.rst:949
msgid "argument list"
msgstr "argumentlista"

#: ../../reference/expressions.rst:949
msgid "= (equals)"
msgstr "= (lika med)"

#: ../../reference/expressions.rst:949 ../../reference/expressions.rst:1032
#: ../../reference/expressions.rst:1062
msgid "in function calls"
msgstr "i funktionsanrop"

#: ../../reference/expressions.rst:982
msgid "parameter"
msgstr "parameter"

#: ../../reference/expressions.rst:1032 ../../reference/expressions.rst:1265
#: ../../reference/expressions.rst:1862
msgid "* (asterisk)"
msgstr "* (asterisk)"

#: ../../reference/expressions.rst:1097
msgid "user-defined"
msgstr "användardefinierad"

#: ../../reference/expressions.rst:1097
msgid "user-defined function"
msgstr "användardefinierad funktion"

#: ../../reference/expressions.rst:1110
msgid "built-in function"
msgstr "inbyggd funktion"

#: ../../reference/expressions.rst:1110
msgid "method"
msgstr "metod"

#: ../../reference/expressions.rst:1110
msgid "built-in method"
msgstr "inbyggd metod"

#: ../../reference/expressions.rst:1124
msgid "class"
msgstr "class"

#: ../../reference/expressions.rst:1124
msgid "class object"
msgstr "klassobjekt"

#: ../../reference/expressions.rst:1131
msgid "class instance"
msgstr "klassinstans"

#: ../../reference/expressions.rst:1131 ../../reference/expressions.rst:1141
msgid "instance"
msgstr "instans"

#: ../../reference/expressions.rst:1141
msgid "__call__() (object method)"
msgstr "__call__() (objektmetod)"

#: ../../reference/expressions.rst:1169
msgid "power"
msgstr "kraft"

#: ../../reference/expressions.rst:1169 ../../reference/expressions.rst:1204
#: ../../reference/expressions.rst:1252 ../../reference/expressions.rst:1361
#: ../../reference/expressions.rst:1388 ../../reference/expressions.rst:1703
msgid "operation"
msgstr "drift"

#: ../../reference/expressions.rst:1169 ../../reference/expressions.rst:1213
#: ../../reference/expressions.rst:1222 ../../reference/expressions.rst:1230
#: ../../reference/expressions.rst:1265 ../../reference/expressions.rst:1278
#: ../../reference/expressions.rst:1287 ../../reference/expressions.rst:1303
#: ../../reference/expressions.rst:1332 ../../reference/expressions.rst:1345
#: ../../reference/expressions.rst:1361 ../../reference/expressions.rst:1397
#: ../../reference/expressions.rst:1405 ../../reference/expressions.rst:1414
#: ../../reference/expressions.rst:1429 ../../reference/expressions.rst:1668
#: ../../reference/expressions.rst:1677 ../../reference/expressions.rst:1719
#: ../../reference/expressions.rst:1724 ../../reference/expressions.rst:1729
#: ../../reference/expressions.rst:1791 ../../reference/expressions.rst:1910
msgid "operator"
msgstr "operator"

#: ../../reference/expressions.rst:1204
msgid "unary"
msgstr "unär"

#: ../../reference/expressions.rst:1204 ../../reference/expressions.rst:1388
#: ../../reference/expressions.rst:1397 ../../reference/expressions.rst:1405
#: ../../reference/expressions.rst:1414
msgid "bitwise"
msgstr "bitvis"

#: ../../reference/expressions.rst:1213
msgid "negation"
msgstr "förnekande"

#: ../../reference/expressions.rst:1213
msgid "minus"
msgstr "minus"

#: ../../reference/expressions.rst:1213 ../../reference/expressions.rst:1345
msgid "- (minus)"
msgstr "- (minus)"

#: ../../reference/expressions.rst:1213 ../../reference/expressions.rst:1222
msgid "unary operator"
msgstr "unär operator"

#: ../../reference/expressions.rst:1222
msgid "plus"
msgstr "plus"

#: ../../reference/expressions.rst:1222 ../../reference/expressions.rst:1332
msgid "+ (plus)"
msgstr "+ (plus)"

#: ../../reference/expressions.rst:1230
msgid "inversion"
msgstr "inversion"

#: ../../reference/expressions.rst:1230
msgid "~ (tilde)"
msgstr "~ (tilde)"

#: ../../reference/expressions.rst:1241
msgid "TypeError"
msgstr "Typfel"

#: ../../reference/expressions.rst:1252 ../../reference/expressions.rst:1388
msgid "binary"
msgstr "binär"

#: ../../reference/expressions.rst:1265
msgid "multiplication"
msgstr "multiplikation"

#: ../../reference/expressions.rst:1278
msgid "matrix multiplication"
msgstr "matrismultiplikation"

#: ../../reference/expressions.rst:1278
msgid "@ (at)"
msgstr "@ (vid)"

#: ../../reference/expressions.rst:1287
msgid "ZeroDivisionError"
msgstr "NollDivisionFel"

#: ../../reference/expressions.rst:1287
msgid "division"
msgstr "division"

#: ../../reference/expressions.rst:1287
msgid "/ (slash)"
msgstr "/ (snedstreck)"

#: ../../reference/expressions.rst:1287
msgid "//"
msgstr "//"

#: ../../reference/expressions.rst:1303
msgid "modulo"
msgstr "modulo"

#: ../../reference/expressions.rst:1303
msgid "% (percent)"
msgstr "% (procent)"

#: ../../reference/expressions.rst:1332
msgid "addition"
msgstr "tillägg"

#: ../../reference/expressions.rst:1332 ../../reference/expressions.rst:1345
msgid "binary operator"
msgstr "binär operatör"

#: ../../reference/expressions.rst:1345
msgid "subtraction"
msgstr "subtraktion"

#: ../../reference/expressions.rst:1361
msgid "shifting"
msgstr "förskjutning"

#: ../../reference/expressions.rst:1361
msgid "<<"
msgstr "<<"

#: ../../reference/expressions.rst:1361
msgid ">>"
msgstr ">>"

#: ../../reference/expressions.rst:1377
msgid "ValueError"
msgstr "VärdeFel"

#: ../../reference/expressions.rst:1397 ../../reference/expressions.rst:1724
msgid "and"
msgstr "och"

#: ../../reference/expressions.rst:1397
msgid "& (ampersand)"
msgstr "& (ampersand)"

#: ../../reference/expressions.rst:1405
msgid "xor"
msgstr "xor"

#: ../../reference/expressions.rst:1405
msgid "exclusive"
msgstr "exklusiv"

#: ../../reference/expressions.rst:1405 ../../reference/expressions.rst:1414
#: ../../reference/expressions.rst:1729
msgid "or"
msgstr "eller"

#: ../../reference/expressions.rst:1405
msgid "^ (caret)"
msgstr "^ (caret)"

#: ../../reference/expressions.rst:1414
msgid "inclusive"
msgstr "inkluderande"

#: ../../reference/expressions.rst:1414
msgid "| (vertical bar)"
msgstr "| (vertikal stapel)"

#: ../../reference/expressions.rst:1429
msgid "comparison"
msgstr "jämförelse"

#: ../../reference/expressions.rst:1429
msgid "C"
msgstr "C"

#: ../../reference/expressions.rst:1429
msgid "language"
msgstr "språk"

#: ../../reference/expressions.rst:1429
msgid "< (less)"
msgstr "< (mindre)"

#: ../../reference/expressions.rst:1429
msgid "> (greater)"
msgstr "> (större)"

#: ../../reference/expressions.rst:1429
msgid "<="
msgstr "<="

#: ../../reference/expressions.rst:1429
msgid ">="
msgstr ">="

#: ../../reference/expressions.rst:1429
msgid "=="
msgstr "=="

#: ../../reference/expressions.rst:1429
msgid "!="
msgstr "!="

#: ../../reference/expressions.rst:1453
msgid "chaining"
msgstr "kedja"

#: ../../reference/expressions.rst:1453
msgid "comparisons"
msgstr "jämförelser"

#: ../../reference/expressions.rst:1668
msgid "in"
msgstr "i"

#: ../../reference/expressions.rst:1668
msgid "not in"
msgstr "inte i"

#: ../../reference/expressions.rst:1668
msgid "membership"
msgstr "medlemskap"

#: ../../reference/expressions.rst:1668 ../../reference/expressions.rst:1677
msgid "test"
msgstr "test"

#: ../../reference/expressions.rst:1677
msgid "is"
msgstr "är"

#: ../../reference/expressions.rst:1677
msgid "is not"
msgstr "är inte"

#: ../../reference/expressions.rst:1677
msgid "identity"
msgstr "identitet"

#: ../../reference/expressions.rst:1703
msgid "Conditional"
msgstr "Villkorlig"

#: ../../reference/expressions.rst:1703
msgid "Boolean"
msgstr "Boolean"

#: ../../reference/expressions.rst:1719
msgid "not"
msgstr "inte"

#: ../../reference/expressions.rst:1743
msgid ":= (colon equals)"
msgstr ":= (kolon är lika med)"

#: ../../reference/expressions.rst:1743
msgid "assignment expression"
msgstr "uppdragets uttryck"

#: ../../reference/expressions.rst:1743
msgid "walrus operator"
msgstr "valrossoperatör"

#: ../../reference/expressions.rst:1743
msgid "named expression"
msgstr "namngivet uttryck"

#: ../../reference/expressions.rst:1791
msgid "conditional"
msgstr "villkorlig"

#: ../../reference/expressions.rst:1791
msgid "ternary"
msgstr "ternär"

#: ../../reference/expressions.rst:1791
msgid "conditional expression"
msgstr "villkorligt uttryck"

#: ../../reference/expressions.rst:1791
msgid "else"
msgstr "annat"

#: ../../reference/expressions.rst:1817
msgid "lambda"
msgstr "lambda"

#: ../../reference/expressions.rst:1817
msgid "form"
msgstr "formulär"

#: ../../reference/expressions.rst:1817
msgid "anonymous"
msgstr "anonym"

#: ../../reference/expressions.rst:1817
msgid "lambda expression"
msgstr "lambda-uttryck"

#: ../../reference/expressions.rst:1862
msgid "iterable"
msgstr "itererbar"

#: ../../reference/expressions.rst:1862
msgid "in expression lists"
msgstr "i uttrycksförteckningar"

#: ../../reference/expressions.rst:1874
msgid "trailing"
msgstr "efterföljande"

#: ../../reference/expressions.rst:1889
msgid "evaluation"
msgstr "utvärdering"

#: ../../reference/expressions.rst:1889
msgid "order"
msgstr "order"

#: ../../reference/expressions.rst:1910
msgid "precedence"
msgstr "företräde"
