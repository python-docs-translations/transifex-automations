# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-22 14:43+0000\n"
"PO-Revision-Date: 2025-09-16 00:02+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../reference/compound_stmts.rst:5
msgid "Compound statements"
msgstr "Compound statements"

#: ../../reference/compound_stmts.rst:9
msgid ""
"Compound statements contain (groups of) other statements; they affect or "
"control the execution of those other statements in some way.  In general, "
"compound statements span multiple lines, although in simple incarnations a "
"whole compound statement may be contained in one line."
msgstr ""
"Compound statements innehåller (grupper av) andra statements; de påverkar "
"eller styr utförandet av dessa andra statements på något sätt.  I allmänhet "
"sträcker sig sammansatta statements över flera rader, men i enkla varianter "
"kan en hel sammansatta statements rymmas på en rad."

#: ../../reference/compound_stmts.rst:14
msgid ""
"The :keyword:`if`, :keyword:`while` and :keyword:`for` statements implement "
"traditional control flow constructs.  :keyword:`try` specifies exception "
"handlers and/or cleanup code for a group of statements, while "
"the :keyword:`with` statement allows the execution of initialization and "
"finalization code around a block of code.  Function and class definitions "
"are also syntactically compound statements."
msgstr ""
"Satserna :keyword:`if`, :keyword:`while` och :keyword:`for` implementerar "
"traditionella kontrollflödeskonstruktioner. :keyword:`try` specificerar "
"undantagshanterare och/eller uppstädningskod för en grupp satser, medan "
"satsen :keyword:`with` gör det möjligt att exekvera initialiserings- och "
"finaliseringskod runt ett kodblock.  Funktions- och klassdefinitioner är "
"också syntaktiskt sammansatta satser."

#: ../../reference/compound_stmts.rst:26
msgid ""
"A compound statement consists of one or more 'clauses.'  A clause consists "
"of a header and a 'suite.'  The clause headers of a particular compound "
"statement are all at the same indentation level. Each clause header begins "
"with a uniquely identifying keyword and ends with a colon.  A suite is a "
"group of statements controlled by a clause.  A suite can be one or more "
"semicolon-separated simple statements on the same line as the header, "
"following the header's colon, or it can be one or more indented statements "
"on subsequent lines.  Only the latter form of a suite can contain nested "
"compound statements; the following is illegal, mostly because it wouldn't be "
"clear to which :keyword:`if` clause a following :keyword:`else` clause would "
"belong::"
msgstr ""
"Ett sammansatt uttalande består av en eller flera \"klausuler\"  En klausul "
"består av en rubrik och en \"svit\"  Klausulrubrikerna i en viss sammansatt "
"sats har alla samma indragningsnivå. Varje klausulrubrik börjar med ett "
"unikt identifierande nyckelord och slutar med kolon.  En svit är en grupp "
"satser som styrs av en klausul.  En svit kan bestå av en eller flera "
"semikolonseparerade enkla satser på samma rad som rubriken, efter rubrikens "
"kolon, eller av en eller flera indragna satser på efterföljande rader.  "
"Endast den senare formen av en svit kan innehålla nästlade sammansatta "
"satser; följande är olagligt, mest för att det inte skulle vara tydligt till "
"vilken :keyword:`if`\\-sats en följande :keyword:`else`\\-sats skulle höra::"

#: ../../reference/compound_stmts.rst:37
msgid "if test1: if test2: print(x)"
msgstr "if test1: if test2: print(x)"

#: ../../reference/compound_stmts.rst:39
msgid ""
"Also note that the semicolon binds tighter than the colon in this context, "
"so that in the following example, either all or none of the :func:`print` "
"calls are executed::"
msgstr ""
"Observera också att semikolon binder hårdare än kolon i detta sammanhang, så "
"att i följande exempel utförs antingen alla eller inga av :func:`print`\\-"
"anropen::"

#: ../../reference/compound_stmts.rst:43
msgid "if x < y < z: print(x); print(y); print(z)"
msgstr "if x < y < z: print(x); print(y); print(z)"

#: ../../reference/compound_stmts.rst:45
msgid "Summarizing:"
msgstr "Sammanfatta:"

#: ../../reference/compound_stmts.rst:69
msgid ""
"Note that statements always end in a ``NEWLINE`` possibly followed by a "
"``DEDENT``.  Also note that optional continuation clauses always begin with "
"a keyword that cannot start a statement, thus there are no ambiguities (the "
"'dangling :keyword:`else`' problem is solved in Python by requiring "
"nested :keyword:`if` statements to be indented)."
msgstr ""
"Observera att satser alltid avslutas med en ``NEWLINE``, eventuellt följd av "
"en ``DEDENT``.  Observera också att valfria fortsättningssatser alltid "
"börjar med ett nyckelord som inte kan börja en sats, så det finns inga "
"tvetydigheter (problemet med \"dinglande :keyword:`else`\" löses i Python "
"genom att kräva att nästlade :keyword:`if`\\-satser är indragna)."

#: ../../reference/compound_stmts.rst:75
msgid ""
"The formatting of the grammar rules in the following sections places each "
"clause on a separate line for clarity."
msgstr ""
"I formateringen av grammatikreglerna i följande avsnitt placeras varje sats "
"på en separat rad för tydlighetens skull."

#: ../../reference/compound_stmts.rst:84
msgid "The :keyword:`!if` statement"
msgstr "Nyckelordet: `!if`\\-satsen"

#: ../../reference/compound_stmts.rst:92
msgid "The :keyword:`if` statement is used for conditional execution:"
msgstr "Satsen :keyword:`if` används för villkorlig exekvering:"

#: ../../reference/compound_stmts.rst:99
msgid ""
"It selects exactly one of the suites by evaluating the expressions one by "
"one until one is found to be true (see section :ref:`booleans` for the "
"definition of true and false); then that suite is executed (and no other "
"part of the :keyword:`if` statement is executed or evaluated).  If all "
"expressions are false, the suite of the :keyword:`else` clause, if present, "
"is executed."
msgstr ""
"Den väljer exakt en av sviterna genom att utvärdera uttrycken ett efter ett "
"tills ett av dem visar sig vara sant (se avsnitt :ref:`booleans` för "
"definition av true och false); då körs den sviten (och ingen annan del "
"av :keyword:`if`\\-satsen körs eller utvärderas).  Om alla uttryck är "
"falska, utförs sviten i :keyword:`else`\\-satsen, om den finns."

#: ../../reference/compound_stmts.rst:109
msgid "The :keyword:`!while` statement"
msgstr "Nyckelordet: `!while`\\-satsen"

#: ../../reference/compound_stmts.rst:117
msgid ""
"The :keyword:`while` statement is used for repeated execution as long as an "
"expression is true:"
msgstr ""
"Satsen :keyword:`while` används för upprepad exekvering så länge som ett "
"uttryck är sant:"

#: ../../reference/compound_stmts.rst:124
msgid ""
"This repeatedly tests the expression and, if it is true, executes the first "
"suite; if the expression is false (which may be the first time it is tested) "
"the suite of the :keyword:`!else` clause, if present, is executed and the "
"loop terminates."
msgstr ""
"Detta testar uttrycket upprepade gånger och, om det är sant, körs den första "
"sviten; om uttrycket är falskt (vilket kan vara första gången det testas) "
"körs sviten i :keyword:`!else`\\-satsen, om den finns, och slingan avslutas."

#: ../../reference/compound_stmts.rst:133
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop "
"without executing the :keyword:`!else` clause's suite.  "
"A :keyword:`continue` statement executed in the first suite skips the rest "
"of the suite and goes back to testing the expression."
msgstr ""
"En :keyword:`break`\\-sats som exekveras i den första sviten avslutar "
"slingan utan att exekvera :keyword:`!else`\\-satsens svit.  "
"En :keyword:`continue`\\-sats som exekveras i den första sviten hoppar över "
"resten av sviten och går tillbaka till att testa uttrycket."

#: ../../reference/compound_stmts.rst:142
msgid "The :keyword:`!for` statement"
msgstr ":keyword:`!for`\\-satsen"

#: ../../reference/compound_stmts.rst:153
msgid ""
"The :keyword:`for` statement is used to iterate over the elements of a "
"sequence (such as a string, tuple or list) or other iterable object:"
msgstr ""
"Satsen :keyword:`for` används för att iterera över elementen i en sekvens "
"(t.ex. en sträng, tupel eller lista) eller ett annat itererbart objekt:"

#: ../../reference/compound_stmts.rst:160
msgid ""
"The :token:`~python-grammar:starred_expression_list` expression is evaluated "
"once; it should yield an :term:`iterable` object. An :term:`iterator` is "
"created for that iterable. The first item provided by the iterator is then "
"assigned to the target list using the standard rules for assignments "
"(see :ref:`assignment`), and the suite is executed. This repeats for each "
"item provided by the iterator. When the iterator is exhausted, the suite in "
"the :keyword:`!else` clause, if present, is executed, and the loop "
"terminates."
msgstr ""
"Uttrycket :token:`~python-grammar:starred_expression_list` utvärderas en "
"gång; det bör ge ett :term:`iterable`\\-objekt. En :term:`iterator` skapas "
"för denna iterable. Det första objektet som tillhandahålls av iteratorn "
"tilldelas sedan till mållistan med hjälp av standardreglerna för "
"tilldelningar (se :ref:`assignment`), och sviten exekveras. Detta upprepas "
"för varje objekt som tillhandahålls av iteratorn. När iteratorn är uttömd "
"körs sviten i :keyword:`!else`\\-satsen, om den finns, och loopen avslutas."

#: ../../reference/compound_stmts.rst:173
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop "
"without executing the :keyword:`!else` clause's suite.  "
"A :keyword:`continue` statement executed in the first suite skips the rest "
"of the suite and continues with the next item, or with the :keyword:`!else` "
"clause if there is no next item."
msgstr ""
"En :keyword:`break`\\-sats som exekveras i den första sviten avslutar "
"slingan utan att exekvera :keyword:`!else`\\-satsens svit.  "
"En :keyword:`continue`\\-sats som utförs i den första sviten hoppar över "
"resten av sviten och fortsätter med nästa objekt, eller med :keyword:`!"
"else`\\-satsen om det inte finns något nästa objekt."

#: ../../reference/compound_stmts.rst:179
msgid ""
"The for-loop makes assignments to the variables in the target list. This "
"overwrites all previous assignments to those variables including those made "
"in the suite of the for-loop::"
msgstr ""
"For-slingan gör tilldelningar till variablerna i mållistan. Detta skriver "
"över alla tidigare tilldelningar till dessa variabler, inklusive de som "
"gjorts i sviten av for-slingan::"

#: ../../reference/compound_stmts.rst:183
msgid ""
"for i in range(10):\n"
"    print(i)\n"
"    i = 5             # this will not affect the for-loop\n"
"                      # because i will be overwritten with the next\n"
"                      # index in the range"
msgstr ""
"för i inom intervall(10):\n"
"    print(i)\n"
"    i = 5 # detta kommer inte att påverka for-slingan\n"
"                      # eftersom i kommer att skrivas över med nästa\n"
"                      # index i intervallet"

#: ../../reference/compound_stmts.rst:193
msgid ""
"Names in the target list are not deleted when the loop is finished, but if "
"the sequence is empty, they will not have been assigned to at all by the "
"loop.  Hint: the built-in type :func:`range` represents immutable arithmetic "
"sequences of integers. For instance, iterating ``range(3)`` successively "
"yields 0, 1, and then 2."
msgstr ""
"Namnen i mållistan raderas inte när slingan är klar, men om sekvensen är tom "
"kommer de inte alls att ha tilldelats av slingan.  Tips: Den inbyggda "
"typen :func:`range` representerar oföränderliga aritmetiska sekvenser av "
"heltal. Till exempel ger iterering av ``range(3)`` successivt 0, 1 och sedan "
"2."

#: ../../reference/compound_stmts.rst:198
msgid "Starred elements are now allowed in the expression list."
msgstr "Stjärnmärkta element är nu tillåtna i uttrycksförteckningen."

#: ../../reference/compound_stmts.rst:205
msgid "The :keyword:`!try` statement"
msgstr ":keyword:`!try`\\-satsen"

#: ../../reference/compound_stmts.rst:215
msgid ""
"The :keyword:`!try` statement specifies exception handlers and/or cleanup "
"code for a group of statements:"
msgstr ""
"Satsen :keyword:`!try` specificerar undantagshanterare och/eller "
"upprensningskod för en grupp satser:"

#: ../../reference/compound_stmts.rst:231
msgid ""
"Additional information on exceptions can be found in "
"section :ref:`exceptions`, and information on using the :keyword:`raise` "
"statement to generate exceptions may be found in section :ref:`raise`."
msgstr ""
"Ytterligare information om undantag finns i avsnittet :ref:`exceptions`, och "
"information om hur man använder :keyword:`raise` för att generera undantag "
"finns i avsnittet :ref:`raise`."

#: ../../reference/compound_stmts.rst:235
msgid ""
"Support for optionally dropping grouping parentheses when using multiple "
"exception types. See :pep:`758`."
msgstr ""
"Stöd för att eventuellt släppa grupperingsparenteser när flera "
"undantagstyper används. Se :pep:`758`."

#: ../../reference/compound_stmts.rst:241
msgid ":keyword:`!except` clause"
msgstr ":keyword:`!except` klausul"

#: ../../reference/compound_stmts.rst:243
msgid ""
"The :keyword:`!except` clause(s) specify one or more exception handlers. "
"When no exception occurs in the :keyword:`try` clause, no exception handler "
"is executed. When an exception occurs in the :keyword:`!try` suite, a search "
"for an exception handler is started. This search inspects the :keyword:`!"
"except` clauses in turn until one is found that matches the exception. An "
"expression-less :keyword:`!except` clause, if present, must be last; it "
"matches any exception."
msgstr ""
"Klausulen :keyword:`!except` specificerar en eller flera undantagshanterare. "
"När inget undantag inträffar i :keyword:`try`\\-satsen utförs ingen "
"undantagshanterare. När ett undantag inträffar i :keyword:`!try`\\-sviten "
"startas en sökning efter en undantagshanterare. Denna sökning "
"inspekterar :keyword:`!except`\\-klausulerna i tur och ordning tills en "
"hittas som matchar undantaget. En uttryckslös :keyword:`!except`\\-klausul, "
"om den finns, måste vara sist; den matchar alla undantag."

#: ../../reference/compound_stmts.rst:251
msgid ""
"For an :keyword:`!except` clause with an expression, the expression must "
"evaluate to an exception type or a tuple of exception types. Parentheses can "
"be dropped if multiple exception types are provided and the ``as`` clause is "
"not used. The raised exception matches an :keyword:`!except` clause whose "
"expression evaluates to the class or a :term:`non-virtual base class "
"<abstract base class>` of the exception object, or to a tuple that contains "
"such a class."
msgstr ""
"För en :keyword:`!except`\\-klausul med ett uttryck måste uttrycket "
"utvärderas till en undantagstyp eller en tupel av undantagstyper. Parenteser "
"kan utelämnas om flera undantagstyper anges och ``as``\\-satsen inte "
"används. Det uppkomna undantaget matchar en :keyword:`!except`\\-sats vars "
"uttryck utvärderas till klassen eller en :term:`icke-virtuell basklass "
"<abstract base class>` för undantagsobjektet, eller till en tupel som "
"innehåller en sådan klass."

#: ../../reference/compound_stmts.rst:258
msgid ""
"If no :keyword:`!except` clause matches the exception, the search for an "
"exception handler continues in the surrounding code and on the invocation "
"stack.  [#]_"
msgstr ""
"Om ingen :keyword:`!except`\\-klausul matchar undantaget fortsätter sökandet "
"efter en undantagshanterare i den omgivande koden och på anropsstacken.  [#]_"

#: ../../reference/compound_stmts.rst:262
msgid ""
"If the evaluation of an expression in the header of an :keyword:`!except` "
"clause raises an exception, the original search for a handler is canceled "
"and a search starts for the new exception in the surrounding code and on the "
"call stack (it is treated as if the entire :keyword:`try` statement raised "
"the exception)."
msgstr ""
"Om utvärderingen av ett uttryck i rubriken till en :keyword:`!except`\\-sats "
"ger upphov till ett undantag, avbryts den ursprungliga sökningen efter en "
"hanterare och en sökning efter det nya undantaget påbörjas i den omgivande "
"koden och på anropsstacken (det behandlas som om hela :keyword:`try`\\-"
"satsen gav upphov till undantaget)."

#: ../../reference/compound_stmts.rst:270
msgid ""
"When a matching :keyword:`!except` clause is found, the exception is "
"assigned to the target specified after the :keyword:`!as` keyword in "
"that :keyword:`!except` clause, if present, and the :keyword:`!except` "
"clause's suite is executed. All :keyword:`!except` clauses must have an "
"executable block. When the end of this block is reached, execution continues "
"normally after the entire :keyword:`try` statement. (This means that if two "
"nested handlers exist for the same exception, and the exception occurs in "
"the :keyword:`!try` clause of the inner handler, the outer handler will not "
"handle the exception.)"
msgstr ""
"När en matchande :keyword:`!except`\\-klausul hittas, tilldelas undantaget "
"till det mål som anges efter :keyword:`!as`\\-keywordet i den :keyword:`!"
"except`\\-klausulen, om det finns, och :keyword:`!except`\\-klausulens svit "
"exekveras. Alla :keyword:`!except`\\-klausuler måste ha ett exekverbart "
"block. När slutet av detta block nås, fortsätter exekveringen normalt efter "
"hela :keyword:`try`\\-satsen. (Detta innebär att om det finns två nästlade "
"hanterare för samma undantag, och undantaget inträffar i :keyword:`!try`\\-"
"satsen i den inre hanteraren, kommer den yttre hanteraren inte att hantera "
"undantaget)"

#: ../../reference/compound_stmts.rst:281
msgid ""
"When an exception has been assigned using ``as target``, it is cleared at "
"the end of the :keyword:`!except` clause.  This is as if ::"
msgstr ""
"När ett undantag har tilldelats med hjälp av ``as target``, rensas det i "
"slutet av :keyword:`!except`\\-satsen.  Detta är som om ::"

#: ../../reference/compound_stmts.rst:284
msgid ""
"except E as N:\n"
"    foo"
msgstr ""
"utom E som N:\n"
"    foo"

#: ../../reference/compound_stmts.rst:287
msgid "was translated to ::"
msgstr "översattes till ::"

#: ../../reference/compound_stmts.rst:289
msgid ""
"except E as N:\n"
"    try:\n"
"        foo\n"
"    finally:\n"
"        del N"
msgstr ""
"utom E som N:\n"
"    try:\n"
"        foo\n"
"    slutligen: foo\n"
"        del N"

#: ../../reference/compound_stmts.rst:295
msgid ""
"This means the exception must be assigned to a different name to be able to "
"refer to it after the :keyword:`!except` clause. Exceptions are cleared "
"because with the traceback attached to them, they form a reference cycle "
"with the stack frame, keeping all locals in that frame alive until the next "
"garbage collection occurs."
msgstr ""
"Detta innebär att undantaget måste tilldelas ett annat namn för att kunna "
"referera till det efter :keyword:`!except`\\-klausulen. Undantag rensas "
"eftersom de med den spårning som är kopplad till dem bildar en referenscykel "
"med stapelramen, vilket håller alla lokala objekt i den ramen vid liv tills "
"nästa skräpsamling sker."

#: ../../reference/compound_stmts.rst:305
msgid ""
"Before an :keyword:`!except` clause's suite is executed, the exception is "
"stored in the :mod:`sys` module, where it can be accessed from within the "
"body of the :keyword:`!except` clause by calling :func:`sys.exception`. When "
"leaving an exception handler, the exception stored in the :mod:`sys` module "
"is reset to its previous value::"
msgstr ""
"Innan en :keyword:`!except`\\-klausuls svit exekveras lagras undantaget i "
"modulen :mod:`sys`, där det kan nås från :keyword:`!except`\\-klausulens "
"kropp genom att anropa :func:`sys.exception`. När du lämnar en "
"undantagshanterare återställs undantaget som lagrats i modulen :mod:`sys` "
"till sitt tidigare värde::"

#: ../../reference/compound_stmts.rst:311
msgid ""
">>> print(sys.exception())\n"
"None\n"
">>> try:\n"
"...     raise TypeError\n"
"... except:\n"
"...     print(repr(sys.exception()))\n"
"...     try:\n"
"...          raise ValueError\n"
"...     except:\n"
"...         print(repr(sys.exception()))\n"
"...     print(repr(sys.exception()))\n"
"...\n"
"TypeError()\n"
"ValueError()\n"
"TypeError()\n"
">>> print(sys.exception())\n"
"None"
msgstr ""
">>> print(sys.exception())\n"
"None\n"
">>> try:\n"
"...     raise TypeError\n"
"... except:\n"
"...     print(repr(sys.exception()))\n"
"...     try:\n"
"...          raise ValueError\n"
"...     except:\n"
"...         print(repr(sys.exception()))\n"
"...     print(repr(sys.exception()))\n"
"...\n"
"TypeError()\n"
"ValueError()\n"
"TypeError()\n"
">>> print(sys.exception())\n"
"None"

#: ../../reference/compound_stmts.rst:336
msgid ":keyword:`!except*` clause"
msgstr ":keyword:`!except*` klausul"

#: ../../reference/compound_stmts.rst:338
msgid ""
"The :keyword:`!except*` clause(s) are used for "
"handling :exc:`ExceptionGroup`\\s. The exception type for matching is "
"interpreted as in the case of :keyword:`except`, but in the case of "
"exception groups we can have partial matches when the type matches some of "
"the exceptions in the group. This means that multiple :keyword:`!except*` "
"clauses can execute, each handling part of the exception group. Each clause "
"executes at most once and handles an exception group of all matching "
"exceptions.  Each exception in the group is handled by at most "
"one :keyword:`!except*` clause, the first that matches it. ::"
msgstr ""
"Klausulerna :keyword:`!except*` används för att "
"hantera :exc:`ExceptionGroup`. Undantagstypen för matchning tolkas som i "
"fallet med :keyword:`except`, men i fallet med undantagsgrupper kan vi ha "
"partiella matchningar när typen matchar några av undantagen i gruppen. Detta "
"innebär att flera :keyword:`!except*`\\-klausuler kan köras, var och en "
"hanterar en del av undantagsgruppen. Varje klausul exekveras högst en gång "
"och hanterar en undantagsgrupp med alla matchande undantag.  Varje undantag "
"i gruppen hanteras av högst en :keyword:`!except*`\\-sats, den första som "
"matchar det. ::"

#: ../../reference/compound_stmts.rst:348
msgid ""
">>> try:\n"
"...     raise ExceptionGroup(\"eg\",\n"
"...         [ValueError(1), TypeError(2), OSError(3), OSError(4)])\n"
"... except* TypeError as e:\n"
"...     print(f'caught {type(e)} with nested {e.exceptions}')\n"
"... except* OSError as e:\n"
"...     print(f'caught {type(e)} with nested {e.exceptions}')\n"
"...\n"
"caught <class 'ExceptionGroup'> with nested (TypeError(2),)\n"
"caught <class 'ExceptionGroup'> with nested (OSError(3), OSError(4))\n"
"  + Exception Group Traceback (most recent call last):\n"
"  |   File \"<stdin>\", line 2, in <module>\n"
"  | ExceptionGroup: eg\n"
"  +-+---------------- 1 ----------------\n"
"    | ValueError: 1\n"
"    +------------------------------------"
msgstr ""
">>> try:\n"
"...     raise ExceptionGroup(\"eg\",\n"
"...         [ValueError(1), TypeError(2), OSError(3), OSError(4)])\n"
"... except* TypeError as e:\n"
"...     print(f'caught {type(e)} with nested {e.exceptions}')\n"
"... except* OSError as e:\n"
"...     print(f'caught {type(e)} with nested {e.exceptions}')\n"
"...\n"
"caught <class 'ExceptionGroup'> with nested (TypeError(2),)\n"
"caught <class 'ExceptionGroup'> with nested (OSError(3), OSError(4))\n"
"  + Exception Group Traceback (most recent call last):\n"
"  |   File \"<stdin>\", line 2, in <module>\n"
"  | ExceptionGroup: eg\n"
"  +-+---------------- 1 ----------------\n"
"    | ValueError: 1\n"
"    +------------------------------------"

#: ../../reference/compound_stmts.rst:366
msgid ""
"Any remaining exceptions that were not handled by any :keyword:`!except*` "
"clause are re-raised at the end, along with all exceptions that were raised "
"from within the :keyword:`!except*` clauses. If this list contains more than "
"one exception to reraise, they are combined into an exception group."
msgstr ""
"Eventuella återstående undantag som inte hanterades av någon :keyword:`!"
"except*`\\-klausul tas upp igen i slutet, tillsammans med alla undantag som "
"togs upp från :keyword:`!except*`\\-klausulerna. Om denna lista innehåller "
"mer än ett undantag som ska tas upp på nytt, kombineras de till en "
"undantagsgrupp."

#: ../../reference/compound_stmts.rst:372
msgid ""
"If the raised exception is not an exception group and its type matches one "
"of the :keyword:`!except*` clauses, it is caught and wrapped by an exception "
"group with an empty message string. ::"
msgstr ""
"Om det undantag som tas upp inte är en undantagsgrupp och dess typ matchar "
"en av :keyword:`!except*`\\-klausulerna, fångas det upp och omsluts av en "
"undantagsgrupp med en tom meddelandesträng. ::"

#: ../../reference/compound_stmts.rst:376
msgid ""
">>> try:\n"
"...     raise BlockingIOError\n"
"... except* BlockingIOError as e:\n"
"...     print(repr(e))\n"
"...\n"
"ExceptionGroup('', (BlockingIOError()))"
msgstr ""
">>> try:\n"
"...     raise BlockingIOError\n"
"... except* BlockingIOError as e:\n"
"...     print(repr(e))\n"
"...\n"
"ExceptionGroup('', (BlockingIOError()))"

#: ../../reference/compound_stmts.rst:383
msgid ""
"An :keyword:`!except*` clause must have a matching expression; it cannot be "
"``except*:``. Furthermore, this expression cannot contain exception group "
"types, because that would have ambiguous semantics."
msgstr ""
"En :keyword:`!except*`\\-klausul måste ha ett matchande uttryck; det kan "
"inte vara ``except*:``. Dessutom kan detta uttryck inte innehålla "
"undantagsgrupptyper, eftersom det skulle ha en tvetydig semantik."

#: ../../reference/compound_stmts.rst:387
msgid ""
"It is not possible to mix :keyword:`except` and :keyword:`!except*` in the "
"same :keyword:`try`. The :keyword:`break`, :keyword:`continue`, "
"and :keyword:`return` statements cannot appear in an :keyword:`!except*` "
"clause."
msgstr ""

#: ../../reference/compound_stmts.rst:402
msgid ":keyword:`!else` clause"
msgstr ":keyword:`!else` klausul"

#: ../../reference/compound_stmts.rst:404
msgid ""
"The optional :keyword:`!else` clause is executed if the control flow leaves "
"the :keyword:`try` suite, no exception was raised, and "
"no :keyword:`return`, :keyword:`continue`, or :keyword:`break` statement was "
"executed.  Exceptions in the :keyword:`!else` clause are not handled by the "
"preceding :keyword:`except` clauses."
msgstr ""
"Den valfria :keyword:`!else`\\-klausulen exekveras om kontrollflödet "
"lämnar :keyword:`try`\\-sviten, inget undantag har uppstått och "
"ingen :keyword:`return`\\-, :keyword:`continue`\\- eller :keyword:`break`\\-"
"sats har exekverats.  Undantag i :keyword:`!else`\\-klausulen hanteras inte "
"av de föregående :keyword:`except`\\-klausulerna."

#: ../../reference/compound_stmts.rst:416
msgid ":keyword:`!finally` clause"
msgstr ":keyword:`!finally` klausul"

#: ../../reference/compound_stmts.rst:418
msgid ""
"If :keyword:`!finally` is present, it specifies a 'cleanup' handler.  "
"The :keyword:`try` clause is executed, including any :keyword:`except` "
"and :keyword:`else <except_else>` clauses. If an exception occurs in any of "
"the clauses and is not handled, the exception is temporarily saved. "
"The :keyword:`!finally` clause is executed.  If there is a saved exception "
"it is re-raised at the end of the :keyword:`!finally` clause. If "
"the :keyword:`!finally` clause raises another exception, the saved exception "
"is set as the context of the new exception. If the :keyword:`!finally` "
"clause executes a :keyword:`return`, :keyword:`break` or :keyword:`continue` "
"statement, the saved exception is discarded. For example, this function "
"returns 42."
msgstr ""

#: ../../reference/compound_stmts.rst:431
msgid ""
"def f():\n"
"    try:\n"
"        1/0\n"
"    finally:\n"
"        return 42"
msgstr ""
"def f():\n"
"    försök:\n"
"        1/0\n"
"    slutligen:\n"
"        retur 42"

#: ../../reference/compound_stmts.rst:439
msgid ""
"The exception information is not available to the program during execution "
"of the :keyword:`!finally` clause."
msgstr ""
"Undantagsinformationen är inte tillgänglig för programmet under exekveringen "
"av :keyword:`!finally`\\-satsen."

#: ../../reference/compound_stmts.rst:447
msgid ""
"When a :keyword:`return`, :keyword:`break` or :keyword:`continue` statement "
"is executed in the :keyword:`try` suite of a :keyword:`!try`...\\ :keyword:`!"
"finally` statement, the :keyword:`!finally` clause is also executed 'on the "
"way out.'"
msgstr ""
"När en :keyword:`return`, :keyword:`break` eller :keyword:`continue`\\-sats "
"exekveras i :keyword:`try`\\-sviten av en :keyword:`!try`...\\ :keyword:`!"
"finally`\\-sats, exekveras även :keyword:`!finally`\\-klausulen \"på vägen "
"ut\""

#: ../../reference/compound_stmts.rst:451
msgid ""
"The return value of a function is determined by the last :keyword:`return` "
"statement executed.  Since the :keyword:`!finally` clause always executes, "
"a :keyword:`!return` statement executed in the :keyword:`!finally` clause "
"will always be the last one executed. The following function returns "
"'finally'."
msgstr ""
"Returvärdet för en funktion bestäms av den sista :keyword:`return`\\-satsen "
"som exekveras.  Eftersom :keyword:`!finally`\\-satsen alltid exekveras, "
"kommer en :keyword:`!return`\\-sats som exekveras i :keyword:`!finally`\\-"
"satsen alltid att vara den sista som exekveras. Följande funktion returnerar "
"'finally'."

#: ../../reference/compound_stmts.rst:456
msgid ""
"def foo():\n"
"    try:\n"
"        return 'try'\n"
"    finally:\n"
"        return 'finally'"
msgstr ""
"def foo():\n"
"    try:\n"
"        returnera 'try'\n"
"    finally: return 'finally':\n"
"        returnera 'finally'"

#: ../../reference/compound_stmts.rst:464
msgid ""
"Prior to Python 3.8, a :keyword:`continue` statement was illegal in "
"the :keyword:`!finally` clause due to a problem with the implementation."
msgstr ""
"Före Python 3.8 var en :keyword:`continue`\\-sats olaglig i :keyword:`!"
"finally`\\-satsen på grund av ett problem med implementeringen."

#: ../../reference/compound_stmts.rst:468
msgid ""
"The compiler emits a :exc:`SyntaxWarning` when "
"a :keyword:`return`, :keyword:`break` or :keyword:`continue` appears in "
"a :keyword:`!finally` block (see :pep:`765`)."
msgstr ""
"Kompilatorn avger en :exc:`SyntaxWarning` när "
"ett :keyword:`return`, :keyword:`break` eller :keyword:`continue` förekommer "
"i ett :keyword:`!finally`\\-block (se :pep:`765`)."

#: ../../reference/compound_stmts.rst:478
msgid "The :keyword:`!with` statement"
msgstr ":keyword:`!with`\\-satsen"

#: ../../reference/compound_stmts.rst:487
msgid ""
"The :keyword:`with` statement is used to wrap the execution of a block with "
"methods defined by a context manager (see section :ref:`context-managers`). "
"This allows common :keyword:`try`...\\ :keyword:`except`..."
"\\ :keyword:`finally` usage patterns to be encapsulated for convenient reuse."
msgstr ""
"Satsen :keyword:`with` används för att omsluta exekveringen av ett block med "
"metoder som definieras av en kontexthanterare (se avsnitt :ref:`context-"
"managers`). Detta gör att vanliga :keyword:`try`...\\ :keyword:`except`..."
"\\ :keyword:`finally` användningsmönster kan kapslas in för bekväm "
"återanvändning."

#: ../../reference/compound_stmts.rst:497
msgid ""
"The execution of the :keyword:`with` statement with one \"item\" proceeds as "
"follows:"
msgstr ""
"Exekveringen av :keyword:`with`\\-satsen med ett \"objekt\" går till på "
"följande sätt:"

#: ../../reference/compound_stmts.rst:499
msgid ""
"The context expression (the expression given in the :token:`~python-"
"grammar:with_item`) is evaluated to obtain a context manager."
msgstr ""
"Kontextuttrycket (det uttryck som anges i :token:`~python-"
"grammar:with_item`) utvärderas för att få fram en kontexthanterare."

#: ../../reference/compound_stmts.rst:502
msgid ""
"The context manager's :meth:`~object.__enter__` is loaded for later use."
msgstr ""
"Kontexthanterarens :meth:`~object.__enter__` laddas för senare användning."

#: ../../reference/compound_stmts.rst:504
msgid "The context manager's :meth:`~object.__exit__` is loaded for later use."
msgstr ""
"Kontexthanterarens :meth:`~object.__exit__` laddas för senare användning."

#: ../../reference/compound_stmts.rst:506
msgid "The context manager's :meth:`~object.__enter__` method is invoked."
msgstr "Kontexthanterarens metod :meth:`~object.__enter__` anropas."

#: ../../reference/compound_stmts.rst:508
msgid ""
"If a target was included in the :keyword:`with` statement, the return value "
"from :meth:`~object.__enter__` is assigned to it."
msgstr ""
"Om ett mål ingick i :keyword:`with`\\-satsen tilldelas det returvärdet "
"från :meth:`~object.__enter__`."

#: ../../reference/compound_stmts.rst:513
msgid ""
"The :keyword:`with` statement guarantees that if "
"the :meth:`~object.__enter__` method returns without an error, "
"then :meth:`~object.__exit__` will always be called. Thus, if an error "
"occurs during the assignment to the target list, it will be treated the same "
"as an error occurring within the suite would be. See step 7 below."
msgstr ""
"Satsen :keyword:`with` garanterar att om metoden :meth:`~object.__enter__` "
"returneras utan fel, så kommer :meth:`~object.__exit__` alltid att anropas. "
"Om ett fel inträffar under tilldelningen till mållistan kommer det alltså "
"att behandlas på samma sätt som ett fel som inträffar inom sviten skulle ha "
"behandlats. Se steg 7 nedan."

#: ../../reference/compound_stmts.rst:519
msgid "The suite is executed."
msgstr "Sviten är genomförd."

#: ../../reference/compound_stmts.rst:521
msgid ""
"The context manager's :meth:`~object.__exit__` method is invoked.  If an "
"exception caused the suite to be exited, its type, value, and traceback are "
"passed as arguments to :meth:`~object.__exit__`. Otherwise, "
"three :const:`None` arguments are supplied."
msgstr ""
"Kontexthanterarens metod :meth:`~object.__exit__` anropas.  Om ett undantag "
"orsakade att sviten avslutades, skickas dess typ, värde och traceback som "
"argument till :meth:`~object.__exit__`. Annars anges tre :const:`None`\\-"
"argument."

#: ../../reference/compound_stmts.rst:526
msgid ""
"If the suite was exited due to an exception, and the return value from "
"the :meth:`~object.__exit__` method was false, the exception is reraised.  "
"If the return value was true, the exception is suppressed, and execution "
"continues with the statement following the :keyword:`with` statement."
msgstr ""
"Om sviten avslutades på grund av ett undantag och returvärdet från "
"metoden :meth:`~object.__exit__` var falskt, återskapas undantaget.  Om "
"returvärdet var sant undertrycks undantaget och exekveringen fortsätter med "
"det uttalande som följer på :keyword:`with`\\-satsen."

#: ../../reference/compound_stmts.rst:531
msgid ""
"If the suite was exited for any reason other than an exception, the return "
"value from :meth:`~object.__exit__` is ignored, and execution proceeds at "
"the normal location for the kind of exit that was taken."
msgstr ""
"Om sviten avslutades av någon annan anledning än ett undantag ignoreras "
"returvärdet från :meth:`~object.__exit__`, och exekveringen fortsätter på "
"den normala platsen för den typ av avslut som gjordes."

#: ../../reference/compound_stmts.rst:535
#: ../../reference/compound_stmts.rst:1553
#: ../../reference/compound_stmts.rst:1594
msgid "The following code::"
msgstr "Följande kod::"

#: ../../reference/compound_stmts.rst:537
msgid ""
"with EXPRESSION as TARGET:\n"
"    SUITE"
msgstr ""
"med EXPRESSION som MÅL:\n"
"    SUITE"

#: ../../reference/compound_stmts.rst:540
#: ../../reference/compound_stmts.rst:565
#: ../../reference/compound_stmts.rst:1599
msgid "is semantically equivalent to::"
msgstr "är semantiskt ekvivalent med::"

#: ../../reference/compound_stmts.rst:542
msgid ""
"manager = (EXPRESSION)\n"
"enter = type(manager).__enter__\n"
"exit = type(manager).__exit__\n"
"value = enter(manager)\n"
"hit_except = False\n"
"\n"
"try:\n"
"    TARGET = value\n"
"    SUITE\n"
"except:\n"
"    hit_except = True\n"
"    if not exit(manager, *sys.exc_info()):\n"
"        raise\n"
"finally:\n"
"    if not hit_except:\n"
"        exit(manager, None, None, None)"
msgstr ""
"manager = (Uttryck)\n"
"enter = typ(chef).__enter__\n"
"exit = typ(chef).__exit__\n"
"värde = enter(chef)\n"
"hit_except = Falsk\n"
"\n"
"försök:\n"
"    TARGET = värde\n"
"    SUITE\n"
"undantag:\n"
"    hit_except = True\n"
"    if not exit(manager, *sys.exc_info()):\n"
"        raise\n"
"slutligen:\n"
"    if not hit_except:\n"
"        exit(manager, Ingen, Ingen, Ingen)"

#: ../../reference/compound_stmts.rst:559
msgid ""
"With more than one item, the context managers are processed as if "
"multiple :keyword:`with` statements were nested::"
msgstr ""
"Med mer än ett objekt bearbetas kontexthanterarna som om "
"flera :keyword:`with`\\-satser var nästlade:"

#: ../../reference/compound_stmts.rst:562
msgid ""
"with A() as a, B() as b:\n"
"    SUITE"
msgstr ""
"med A() som a, B() som b:\n"
"    SUITE"

#: ../../reference/compound_stmts.rst:567
msgid ""
"with A() as a:\n"
"    with B() as b:\n"
"        SUITE"
msgstr ""
"med A() som a:\n"
"    med B() som b:\n"
"        SUITE"

#: ../../reference/compound_stmts.rst:571
msgid ""
"You can also write multi-item context managers in multiple lines if the "
"items are surrounded by parentheses. For example::"
msgstr ""
"Du kan också skriva kontexthanterare med flera objekt på flera rader om "
"objekten omges av parenteser. Till exempel::"

#: ../../reference/compound_stmts.rst:574
msgid ""
"with (\n"
"    A() as a,\n"
"    B() as b,\n"
"):\n"
"    SUITE"
msgstr ""
"med (\n"
"    A() som a,\n"
"    B() som b,\n"
"):\n"
"    SUITE"

#: ../../reference/compound_stmts.rst:580
msgid "Support for multiple context expressions."
msgstr "Stöd för flera kontextuttryck."

#: ../../reference/compound_stmts.rst:583
msgid ""
"Support for using grouping parentheses to break the statement in multiple "
"lines."
msgstr ""
"Stöd för att använda grupperingsparenteser för att dela upp uttalandet i "
"flera rader."

#: ../../reference/compound_stmts.rst:588
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - Uttalandet \"med\""

#: ../../reference/compound_stmts.rst:589
msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr ""
"Specifikation, bakgrund och exempel för Pythons :keyword:`with`\\-sats."

#: ../../reference/compound_stmts.rst:596
msgid "The :keyword:`!match` statement"
msgstr ":keyword:`!match`\\-satsen"

#: ../../reference/compound_stmts.rst:610
msgid "The match statement is used for pattern matching.  Syntax:"
msgstr "Match-satsen används för mönstermatchning.  Syntax:"

#: ../../reference/compound_stmts.rst:619
msgid ""
"This section uses single quotes to denote :ref:`soft keywords <soft-"
"keywords>`."
msgstr ""
"I detta avsnitt används enkla citationstecken för att beteckna :ref:`mjuka "
"nyckelord <soft-keywords>`."

#: ../../reference/compound_stmts.rst:622
msgid ""
"Pattern matching takes a pattern as input (following ``case``) and a subject "
"value (following ``match``).  The pattern (which may contain subpatterns) is "
"matched against the subject value.  The outcomes are:"
msgstr ""
"Mönstermatchning tar ett mönster som indata (efter ``case``) och ett "
"ämnesvärde (efter ``match``).  Mönstret (som kan innehålla undermönster) "
"matchas mot ämnesvärdet.  Utfallet är följande:"

#: ../../reference/compound_stmts.rst:626
msgid "A match success or failure (also termed a pattern success or failure)."
msgstr ""
"En lyckad eller misslyckad matchning (även kallad ett lyckat eller "
"misslyckat mönster)."

#: ../../reference/compound_stmts.rst:628
msgid ""
"Possible binding of matched values to a name.  The prerequisites for this "
"are further discussed below."
msgstr ""
"Möjlig bindning av matchade värden till ett namn.  Förutsättningarna för "
"detta diskuteras vidare nedan."

#: ../../reference/compound_stmts.rst:631
msgid ""
"The ``match`` and ``case`` keywords are :ref:`soft keywords <soft-keywords>`."
msgstr ""
"Nyckelorden ``match`` och ``case`` är :ref:`mjuka nyckelord <soft-keywords>`."

#: ../../reference/compound_stmts.rst:635
#: ../../reference/compound_stmts.rst:1192
msgid ":pep:`634` -- Structural Pattern Matching: Specification"
msgstr ":pep:`634` -- Matchning av strukturella mönster: Specifikation"

#: ../../reference/compound_stmts.rst:636
#: ../../reference/compound_stmts.rst:1193
msgid ":pep:`636` -- Structural Pattern Matching: Tutorial"
msgstr ":pep:`636` -- Matchning av strukturella mönster: Handledning"

#: ../../reference/compound_stmts.rst:640
msgid "Overview"
msgstr "Översikt"

#: ../../reference/compound_stmts.rst:642
msgid "Here's an overview of the logical flow of a match statement:"
msgstr "Här följer en översikt över det logiska flödet i ett matchningsbesked:"

#: ../../reference/compound_stmts.rst:645
msgid ""
"The subject expression ``subject_expr`` is evaluated and a resulting subject "
"value obtained. If the subject expression contains a comma, a tuple is "
"constructed using :ref:`the standard rules <typesseq-tuple>`."
msgstr ""
"Subjektuttrycket ``subject_expr`` utvärderas och ett resulterande "
"subjektvärde erhålls. Om ämnesuttrycket innehåller ett kommatecken "
"konstrueras en tupel med hjälp av :ref:`standardreglerna <typesseq-tuple>`."

#: ../../reference/compound_stmts.rst:649
msgid ""
"Each pattern in a ``case_block`` is attempted to match with the subject "
"value. The specific rules for success or failure are described below. The "
"match attempt can also bind some or all of the standalone names within the "
"pattern. The precise pattern binding rules vary per pattern type and are "
"specified below.  **Name bindings made during a successful pattern match "
"outlive the executed block and can be used after the match statement**."
msgstr ""
"Varje mönster i ett ``case_block`` försöker matchas med ämnesvärdet. De "
"specifika reglerna för framgång eller misslyckande beskrivs nedan. "
"Matchningsförsöket kan också binda vissa eller alla fristående namn inom "
"mönstret. De exakta reglerna för mönsterbindning varierar beroende på "
"mönstertyp och anges nedan.  **Namnbindningar som görs under en lyckad "
"mönstermatchning överlever det exekverade blocket och kan användas efter "
"matchningssatsen**."

#: ../../reference/compound_stmts.rst:658
msgid ""
"During failed pattern matches, some subpatterns may succeed.  Do not rely on "
"bindings being made for a failed match.  Conversely, do not rely on "
"variables remaining unchanged after a failed match.  The exact behavior is "
"dependent on implementation and may vary.  This is an intentional decision "
"made to allow different implementations to add optimizations."
msgstr ""
"Vid misslyckade mönstermatchningar kan vissa undermönster lyckas.  Förlita "
"dig inte på att bindningar görs för en misslyckad matchning.  Omvänt ska du "
"inte förlita dig på att variabler förblir oförändrade efter en misslyckad "
"matchning.  Det exakta beteendet är beroende av implementeringen och kan "
"variera.  Detta är ett avsiktligt beslut som fattats för att olika "
"implementationer ska kunna lägga till optimeringar."

#: ../../reference/compound_stmts.rst:665
msgid ""
"If the pattern succeeds, the corresponding guard (if present) is evaluated. "
"In this case all name bindings are guaranteed to have happened."
msgstr ""
"Om mönstret lyckas utvärderas motsvarande skydd (om sådant finns). I detta "
"fall garanteras att alla namnbindningar har inträffat."

#: ../../reference/compound_stmts.rst:668
msgid ""
"If the guard evaluates as true or is missing, the ``block`` inside "
"``case_block`` is executed."
msgstr ""
"Om skyddet utvärderas som sant eller saknas, körs ``block`` inuti "
"``case_block``."

#: ../../reference/compound_stmts.rst:671
msgid "Otherwise, the next ``case_block`` is attempted as described above."
msgstr "I annat fall försöker nästa ``case_block`` enligt beskrivningen ovan."

#: ../../reference/compound_stmts.rst:673
msgid "If there are no further case blocks, the match statement is completed."
msgstr "Om det inte finns några fler fallblock är matchningsöversikten klar."

#: ../../reference/compound_stmts.rst:677
msgid ""
"Users should generally never rely on a pattern being evaluated.  Depending "
"on implementation, the interpreter may cache values or use other "
"optimizations which skip repeated evaluations."
msgstr ""
"Användare bör i allmänhet aldrig förlita sig på att ett mönster utvärderas.  "
"Beroende på implementering kan tolken cacha värden eller använda andra "
"optimeringar som hoppar över upprepade utvärderingar."

#: ../../reference/compound_stmts.rst:681
msgid "A sample match statement::"
msgstr "Ett exempel på ett matchningsbesked::"

#: ../../reference/compound_stmts.rst:683
msgid ""
">>> flag = False\n"
">>> match (100, 200):\n"
"...    case (100, 300):  # Mismatch: 200 != 300\n"
"...        print('Case 1')\n"
"...    case (100, 200) if flag:  # Successful match, but guard fails\n"
"...        print('Case 2')\n"
"...    case (100, y):  # Matches and binds y to 200\n"
"...        print(f'Case 3, y: {y}')\n"
"...    case _:  # Pattern not attempted\n"
"...        print('Case 4, I match anything!')\n"
"...\n"
"Case 3, y: 200"
msgstr ""
">>> flag = False\n"
">>> match (100, 200):\n"
"...    case (100, 300):  # Mismatch: 200 != 300\n"
"...        print('Case 1')\n"
"...    case (100, 200) if flag:  # Successful match, but guard fails\n"
"...        print('Case 2')\n"
"...    case (100, y):  # Matches and binds y to 200\n"
"...        print(f'Case 3, y: {y}')\n"
"...    case _:  # Pattern not attempted\n"
"...        print('Case 4, I match anything!')\n"
"...\n"
"Case 3, y: 200"

#: ../../reference/compound_stmts.rst:697
msgid ""
"In this case, ``if flag`` is a guard.  Read more about that in the next "
"section."
msgstr ""
"I det här fallet är ``if flag`` en guard.  Läs mer om det i nästa avsnitt."

#: ../../reference/compound_stmts.rst:700
msgid "Guards"
msgstr "Vakter"

#: ../../reference/compound_stmts.rst:707
msgid ""
"A ``guard`` (which is part of the ``case``) must succeed for code inside the "
"``case`` block to execute.  It takes the form: :keyword:`if` followed by an "
"expression."
msgstr ""
"En ``guard`` (som är en del av ``case``) måste lyckas för att koden i "
"``case``\\-blocket ska kunna exekveras.  Den har formen: :keyword:`if` följt "
"av ett uttryck."

#: ../../reference/compound_stmts.rst:712
msgid "The logical flow of a ``case`` block with a ``guard`` follows:"
msgstr ""
"Det logiska flödet i ett ``case``\\-block med en ``guard`` är följande:"

#: ../../reference/compound_stmts.rst:714
msgid ""
"Check that the pattern in the ``case`` block succeeded.  If the pattern "
"failed, the ``guard`` is not evaluated and the next ``case`` block is "
"checked."
msgstr ""
"Kontrollera att mönstret i ``case``\\-blocket lyckades. Om mönstret "
"misslyckades utvärderas inte ``guard`` och nästa ``case``\\-block "
"kontrolleras."

#: ../../reference/compound_stmts.rst:718
msgid "If the pattern succeeded, evaluate the ``guard``."
msgstr "Om mönstret lyckades, utvärdera ``guard``."

#: ../../reference/compound_stmts.rst:720
msgid ""
"If the ``guard`` condition evaluates as true, the case block is selected."
msgstr "Om villkoret ``guard`` utvärderas som sant, väljs fallblocket."

#: ../../reference/compound_stmts.rst:723
msgid ""
"If the ``guard`` condition evaluates as false, the case block is not "
"selected."
msgstr ""
"Om villkoret ``guard`` utvärderas som falskt, väljs inte ärendeblocket."

#: ../../reference/compound_stmts.rst:726
msgid ""
"If the ``guard`` raises an exception during evaluation, the exception "
"bubbles up."
msgstr ""
"Om ``guard`` ger upphov till ett undantag under utvärderingen, bubblar "
"undantaget upp."

#: ../../reference/compound_stmts.rst:729
msgid ""
"Guards are allowed to have side effects as they are expressions.  Guard "
"evaluation must proceed from the first to the last case block, one at a "
"time, skipping case blocks whose pattern(s) don't all succeed. (I.e., guard "
"evaluation must happen in order.) Guard evaluation must stop once a case "
"block is selected."
msgstr ""
"Guards får ha bieffekter eftersom de är uttryck.  Guard-utvärderingen måste "
"gå från det första till det sista fallblocket, ett i taget, och hoppa över "
"fallblock där inte alla mönster lyckas. (D.v.s. utvärderingen av guarden "
"måste ske i ordning.) Utvärderingen av guarden måste avbrytas när ett "
"fallblock har valts."

#: ../../reference/compound_stmts.rst:739
msgid "Irrefutable Case Blocks"
msgstr "Obestridliga fallblock"

#: ../../reference/compound_stmts.rst:743
msgid ""
"An irrefutable case block is a match-all case block.  A match statement may "
"have at most one irrefutable case block, and it must be last."
msgstr ""
"Ett obestridligt fallblock är ett match-all fallblock.  Ett "
"matchningsuttalande kan ha högst ett oåterkalleligt fallblock och det måste "
"vara det sista."

#: ../../reference/compound_stmts.rst:746
msgid ""
"A case block is considered irrefutable if it has no guard and its pattern is "
"irrefutable.  A pattern is considered irrefutable if we can prove from its "
"syntax alone that it will always succeed.  Only the following patterns are "
"irrefutable:"
msgstr ""
"Ett case-block anses vara oåterkalleligt om det inte har någon guard och om "
"dess mönster är oåterkalleligt.  Ett mönster anses vara oåterkalleligt om vi "
"enbart utifrån dess syntax kan bevisa att det alltid kommer att lyckas.  "
"Endast följande mönster är oåterkalleliga:"

#: ../../reference/compound_stmts.rst:751
msgid ":ref:`as-patterns` whose left-hand side is irrefutable"
msgstr ":ref:`as-patterns` vars vänstra sida är oåterkallelig"

#: ../../reference/compound_stmts.rst:753
msgid ":ref:`or-patterns` containing at least one irrefutable pattern"
msgstr ":ref:`or-patterns` som innehåller minst ett obestridligt mönster"

#: ../../reference/compound_stmts.rst:755
msgid ":ref:`capture-patterns`"
msgstr ":ref:`capture-patterns`"

#: ../../reference/compound_stmts.rst:757
msgid ":ref:`wildcard-patterns`"
msgstr ":ref:`wildcard-patterns`"

#: ../../reference/compound_stmts.rst:759
msgid "parenthesized irrefutable patterns"
msgstr "parentes ovedersägliga mönster"

#: ../../reference/compound_stmts.rst:763
msgid "Patterns"
msgstr "Blockmönster"

#: ../../reference/compound_stmts.rst:770
msgid "This section uses grammar notations beyond standard EBNF:"
msgstr "I detta avsnitt används grammatiska notationer utöver standard EBNF:"

#: ../../reference/compound_stmts.rst:772
msgid "the notation ``SEP.RULE+`` is shorthand for ``RULE (SEP RULE)*``"
msgstr "notationen ``SEP.RULE+`` är en förkortning för ``RULE (SEP RULE)*``"

#: ../../reference/compound_stmts.rst:774
msgid "the notation ``!RULE`` is shorthand for a negative lookahead assertion"
msgstr ""
"notationen ``!RULE`` är en förkortning för ett negativt framåtblickande "
"påstående"

#: ../../reference/compound_stmts.rst:777
msgid "The top-level syntax for ``patterns`` is:"
msgstr "Syntaxen på högsta nivå för ``patterns`` är:"

#: ../../reference/compound_stmts.rst:791
msgid ""
"The descriptions below will include a description \"in simple terms\" of "
"what a pattern does for illustration purposes (credits to Raymond Hettinger "
"for a document that inspired most of the descriptions). Note that these "
"descriptions are purely for illustration purposes and **may not** reflect "
"the underlying implementation.  Furthermore, they do not cover all valid "
"forms."
msgstr ""
"Beskrivningarna nedan innehåller en beskrivning \"i enkla ordalag\" av vad "
"ett mönster gör i illustrationssyfte (tack till Raymond Hettinger för ett "
"dokument som inspirerat de flesta av beskrivningarna). Observera att dessa "
"beskrivningar endast är avsedda som illustrationer och **måste** inte "
"återspegla den underliggande implementeringen.  Dessutom täcker de inte alla "
"giltiga former."

#: ../../reference/compound_stmts.rst:801
msgid "OR Patterns"
msgstr "OR-mönster"

#: ../../reference/compound_stmts.rst:803
msgid ""
"An OR pattern is two or more patterns separated by vertical bars ``|``.  "
"Syntax:"
msgstr ""
"Ett OR-mönster är två eller flera mönster åtskilda av vertikala streck ``|"
"``.  Syntax:"

#: ../../reference/compound_stmts.rst:809
msgid ""
"Only the final subpattern may be :ref:`irrefutable <irrefutable_case>`, and "
"each subpattern must bind the same set of names to avoid ambiguity."
msgstr ""
"Endast det sista undermönstret kan vara :ref:`irrefutable "
"<irrefutable_case>`, och varje undermönster måste binda samma uppsättning "
"namn för att undvika tvetydighet."

#: ../../reference/compound_stmts.rst:812
msgid ""
"An OR pattern matches each of its subpatterns in turn to the subject value, "
"until one succeeds.  The OR pattern is then considered successful.  "
"Otherwise, if none of the subpatterns succeed, the OR pattern fails."
msgstr ""
"Ett OR-mönster matchar vart och ett av sina undermönster i tur och ordning "
"med ämnesvärdet, tills ett lyckas.  OR-mönstret anses då vara "
"framgångsrikt.  I annat fall, om inget av undermönstren lyckas, misslyckas "
"OR-mönstret."

#: ../../reference/compound_stmts.rst:816
msgid ""
"In simple terms, ``P1 | P2 | ...`` will try to match ``P1``, if it fails it "
"will try to match ``P2``, succeeding immediately if any succeeds, failing "
"otherwise."
msgstr ""
"Enkelt uttryckt kommer ``P1 | P2 | ...`` att försöka matcha ``P1``, om det "
"misslyckas kommer det att försöka matcha ``P2``, lyckas omedelbart om någon "
"lyckas, misslyckas annars."

#: ../../reference/compound_stmts.rst:822
msgid "AS Patterns"
msgstr "AS-mönster"

#: ../../reference/compound_stmts.rst:824
msgid ""
"An AS pattern matches an OR pattern on the left of the :keyword:`as` keyword "
"against a subject.  Syntax:"
msgstr ""
"Ett AS-mönster matchar ett OR-mönster till vänster om "
"nyckelordet :keyword:`as` mot ett ämne.  Syntax för detta:"

#: ../../reference/compound_stmts.rst:830
msgid ""
"If the OR pattern fails, the AS pattern fails.  Otherwise, the AS pattern "
"binds the subject to the name on the right of the as keyword and succeeds. "
"``capture_pattern`` cannot be a ``_``."
msgstr ""
"Om OR-mönstret misslyckas, misslyckas AS-mönstret.  I annat fall binder AS-"
"mönstret subjektet till namnet till höger om as-nyckelordet och lyckas. "
"``capture_pattern`` kan inte vara en ``_``."

#: ../../reference/compound_stmts.rst:834
msgid ""
"In simple terms ``P as NAME`` will match with ``P``, and on success it will "
"set ``NAME = <subject>``."
msgstr ""
"Enkelt uttryckt kommer ``P as NAME`` att matcha med ``P``, och vid framgång "
"kommer den att sätta ``NAME = <subject>``."

#: ../../reference/compound_stmts.rst:841
msgid "Literal Patterns"
msgstr "Bokstavliga mönster"

#: ../../reference/compound_stmts.rst:843
msgid ""
"A literal pattern corresponds to most :ref:`literals <literals>` in Python.  "
"Syntax:"
msgstr ""
"Ett bokstavsmönster motsvarar de flesta :ref:`literals <literals>` i "
"Python.  Syntax:"

#: ../../reference/compound_stmts.rst:856
msgid ""
"The rule ``strings`` and the token ``NUMBER`` are defined in "
"the :doc:`standard Python grammar <./grammar>`.  Triple-quoted strings are "
"supported.  Raw strings and byte strings are supported.  :ref:`f-strings` "
"and :ref:`t-strings` are not supported."
msgstr ""
"Regeln ``strings`` och token ``NUMBER`` är definierade i :doc:`standard "
"Python grammar <./grammar>`.  Trippelciterade strängar stöds.  Råa strängar "
"och byte-strängar stöds. :ref:`f-strings` och :ref:`t-strings` stöds inte."

#: ../../reference/compound_stmts.rst:861
msgid ""
"The forms ``signed_number '+' NUMBER`` and ``signed_number '-' NUMBER`` are "
"for expressing :ref:`complex numbers <imaginary>`; they require a real "
"number on the left and an imaginary number on the right. E.g. ``3 + 4j``."
msgstr ""
"Formerna ``signed_number '+' NUMBER`` och ``signed_number '-' NUMBER`` är "
"till för att uttrycka :ref:`komplexa tal <imaginary>`; de kräver ett reellt "
"tal till vänster och ett imaginärt tal till höger. T.ex. ``3 + 4j``."

#: ../../reference/compound_stmts.rst:865
msgid ""
"In simple terms, ``LITERAL`` will succeed only if ``<subject> == LITERAL``. "
"For the singletons ``None``, ``True`` and ``False``, the :keyword:`is` "
"operator is used."
msgstr ""
"Enkelt uttryckt kommer ``LITERAL`` att lyckas endast om ``<subject> == "
"LITERAL``. För singletonerna ``None``, ``True`` och ``False`` används "
"operatorn :keyword:`is`."

#: ../../reference/compound_stmts.rst:871
msgid "Capture Patterns"
msgstr "Fångstmönster"

#: ../../reference/compound_stmts.rst:873
msgid "A capture pattern binds the subject value to a name. Syntax:"
msgstr "Ett capture-mönster binder ämnesvärdet till ett namn. Syntax:"

#: ../../reference/compound_stmts.rst:879
msgid ""
"A single underscore ``_`` is not a capture pattern (this is what ``!'_'`` "
"expresses). It is instead treated as a :token:`~python-"
"grammar:wildcard_pattern`."
msgstr ""
"En enda understrykning ``_`` är inte ett fångstmönster (det är vad ``!'_'`` "
"uttrycker). Det behandlas istället som en :token:`~python-"
"grammar:wildcard_pattern`."

#: ../../reference/compound_stmts.rst:883
msgid ""
"In a given pattern, a given name can only be bound once.  E.g. ``case x, "
"x: ...`` is invalid while ``case [x] | x: ...`` is allowed."
msgstr ""
"I ett givet mönster kan ett givet namn bara bindas en gång.  T.ex. ``case x, "
"x: ...`` är ogiltigt medan ``case [x] | x: ...`` är tillåtet."

#: ../../reference/compound_stmts.rst:886
msgid ""
"Capture patterns always succeed.  The binding follows scoping rules "
"established by the assignment expression operator in :pep:`572`; the name "
"becomes a local variable in the closest containing function scope unless "
"there's an applicable :keyword:`global` or :keyword:`nonlocal` statement."
msgstr ""
"Fångstmönster lyckas alltid.  Bindningen följer scoping-regler som "
"fastställts av operatorn för tilldelningsuttryck i :pep:`572`; namnet blir "
"en lokal variabel i den närmaste innehållande funktionens scope om det inte "
"finns ett tillämpligt :keyword:`global` eller :keyword:`nonlocal` uttalande."

#: ../../reference/compound_stmts.rst:891
msgid ""
"In simple terms ``NAME`` will always succeed and it will set ``NAME = "
"<subject>``."
msgstr ""
"Enkelt uttryckt kommer ``NAME`` alltid att lyckas och den kommer att ställa "
"in ``NAME = <subject>``."

#: ../../reference/compound_stmts.rst:896
msgid "Wildcard Patterns"
msgstr "Jokerteckenmönster"

#: ../../reference/compound_stmts.rst:898
msgid ""
"A wildcard pattern always succeeds (matches anything) and binds no name.  "
"Syntax:"
msgstr ""
"Ett jokerteckenmönster är alltid framgångsrikt (matchar allt) och binder "
"inget namn.  Syntax för:"

#: ../../reference/compound_stmts.rst:904
msgid ""
"``_`` is a :ref:`soft keyword <soft-keywords>` within any pattern, but only "
"within patterns.  It is an identifier, as usual, even within ``match`` "
"subject expressions, ``guard``\\ s, and ``case`` blocks."
msgstr ""
"``_`` är ett :ref:`mjukt nyckelord <soft-keywords>` inom alla mönster, men "
"bara inom mönster.  Det är en identifierare, som vanligt, även inom "
"``match`` ämnesuttryck, ``guard`` och ``case`` block."

#: ../../reference/compound_stmts.rst:908
msgid "In simple terms, ``_`` will always succeed."
msgstr "Enkelt uttryckt kommer ``_`` alltid att lyckas."

#: ../../reference/compound_stmts.rst:913
msgid "Value Patterns"
msgstr "Värdemönster"

#: ../../reference/compound_stmts.rst:915
msgid "A value pattern represents a named value in Python. Syntax:"
msgstr ""
"Ett värdemönster representerar ett namngivet värde i Python. Syntaxen är"

#: ../../reference/compound_stmts.rst:923
msgid ""
"The dotted name in the pattern is looked up using standard Python :ref:`name "
"resolution rules <resolve_names>`.  The pattern succeeds if the value found "
"compares equal to the subject value (using the ``==`` equality operator)."
msgstr ""
"Det prickade namnet i mönstret söks upp med hjälp av standardreglerna för "
"namnuppslagning i Python :ref:`name resolution rules <resolve_names>`. "
"Mönstret är korrekt om det värde som hittas är lika med det sökta värdet "
"(med hjälp av jämlikhetsoperatorn ``==``)."

#: ../../reference/compound_stmts.rst:928
msgid ""
"In simple terms ``NAME1.NAME2`` will succeed only if ``<subject> == "
"NAME1.NAME2``"
msgstr ""
"Enkelt uttryckt kommer ``NAME1.NAME2`` att lyckas endast om ``<subject> == "
"NAME1.NAME2``"

#: ../../reference/compound_stmts.rst:932
msgid ""
"If the same value occurs multiple times in the same match statement, the "
"interpreter may cache the first value found and reuse it rather than repeat "
"the same lookup.  This cache is strictly tied to a given execution of a "
"given match statement."
msgstr ""
"Om samma värde förekommer flera gånger i samma matchningsuttalande kan "
"tolken cacha det första värdet som hittas och återanvända det i stället för "
"att upprepa samma uppslagning.  Denna cache är strikt knuten till en viss "
"exekvering av en viss matchningssats."

#: ../../reference/compound_stmts.rst:940
msgid "Group Patterns"
msgstr "Gruppmönster"

#: ../../reference/compound_stmts.rst:942
msgid ""
"A group pattern allows users to add parentheses around patterns to emphasize "
"the intended grouping.  Otherwise, it has no additional syntax. Syntax:"
msgstr ""
"Ett gruppmönster gör det möjligt för användare att lägga till parenteser "
"runt mönster för att betona den avsedda grupperingen.  I övrigt har det "
"ingen ytterligare syntax. Syntax för gruppmönster:"

#: ../../reference/compound_stmts.rst:949
msgid "In simple terms ``(P)`` has the same effect as ``P``."
msgstr "Enkelt uttryckt har ``(P)`` samma effekt som ``P``."

#: ../../reference/compound_stmts.rst:954
msgid "Sequence Patterns"
msgstr "Sekvensmönster"

#: ../../reference/compound_stmts.rst:956
msgid ""
"A sequence pattern contains several subpatterns to be matched against "
"sequence elements. The syntax is similar to the unpacking of a list or tuple."
msgstr ""
"Ett sekvensmönster innehåller flera undermönster som ska matchas mot "
"sekvenselement. Syntaxen liknar uppackningen av en lista eller tupel."

#: ../../reference/compound_stmts.rst:967
msgid ""
"There is no difference if parentheses  or square brackets are used for "
"sequence patterns (i.e. ``(...)`` vs ``[...]`` )."
msgstr ""
"Det är ingen skillnad om parenteser eller hakparenteser används för "
"sekvensmönster (t.ex. ``(...)`` vs ``[...]`` )."

#: ../../reference/compound_stmts.rst:971
msgid ""
"A single pattern enclosed in parentheses without a trailing comma (e.g. ``(3 "
"| 4)``) is a :ref:`group pattern <group-patterns>`. While a single pattern "
"enclosed in square brackets (e.g. ``[3 | 4]``) is still a sequence pattern."
msgstr ""
"Ett enskilt mönster inom parentes utan efterföljande kommatecken (t.ex. ``(3 "
"| 4)``) är ett :ref:`gruppmönster <group-patterns>`. Medan ett enskilt "
"mönster inom hakparenteser (t.ex. ``[3 | 4]``) fortfarande är ett "
"sekvensmönster."

#: ../../reference/compound_stmts.rst:976
msgid ""
"At most one star subpattern may be in a sequence pattern.  The star "
"subpattern may occur in any position. If no star subpattern is present, the "
"sequence pattern is a fixed-length sequence pattern; otherwise it is a "
"variable-length sequence pattern."
msgstr ""
"Högst ett stjärnundermönster kan finnas i ett sekvensmönster.  "
"Stjärnsubmönstret kan förekomma i vilken position som helst. Om inget "
"stjärnundermönster förekommer är sekvensmönstret ett sekvensmönster med fast "
"längd; annars är det ett sekvensmönster med variabel längd."

#: ../../reference/compound_stmts.rst:981
msgid ""
"The following is the logical flow for matching a sequence pattern against a "
"subject value:"
msgstr ""
"Följande är det logiska flödet för att matcha ett sekvensmönster mot ett "
"ämnesvärde:"

#: ../../reference/compound_stmts.rst:984
msgid ""
"If the subject value is not a sequence [#]_, the sequence pattern fails."
msgstr "Om ämnesvärdet inte är en sekvens [#]_ misslyckas sekvensmönstret."

#: ../../reference/compound_stmts.rst:987
msgid ""
"If the subject value is an instance of ``str``, ``bytes`` or ``bytearray`` "
"the sequence pattern fails."
msgstr ""
"Om ämnesvärdet är en instans av ``str``, ``bytes`` eller ``bytearray`` "
"misslyckas sekvensmönstret."

#: ../../reference/compound_stmts.rst:990
msgid ""
"The subsequent steps depend on whether the sequence pattern is fixed or "
"variable-length."
msgstr ""
"De följande stegen beror på om sekvensmönstret är fast eller har variabel "
"längd."

#: ../../reference/compound_stmts.rst:993
msgid "If the sequence pattern is fixed-length:"
msgstr "Om sekvensmönstret är av fast längd:"

#: ../../reference/compound_stmts.rst:995
msgid ""
"If the length of the subject sequence is not equal to the number of "
"subpatterns, the sequence pattern fails"
msgstr ""
"Om längden på den aktuella sekvensen inte är lika med antalet undermönster "
"misslyckas sekvensmönstret"

#: ../../reference/compound_stmts.rst:998
msgid ""
"Subpatterns in the sequence pattern are matched to their corresponding items "
"in the subject sequence from left to right.  Matching stops as soon as a "
"subpattern fails.  If all subpatterns succeed in matching their "
"corresponding item, the sequence pattern succeeds."
msgstr ""
"Submönster i sekvensmönstret matchas med motsvarande objekt i ämnessekvensen "
"från vänster till höger.  Matchningen stoppas så snart ett undermönster "
"misslyckas.  Om alla undermönster lyckas matcha sina motsvarande objekt, "
"lyckas sekvensmönstret."

#: ../../reference/compound_stmts.rst:1003
msgid "Otherwise, if the sequence pattern is variable-length:"
msgstr "Annars, om sekvensmönstret är av variabel längd:"

#: ../../reference/compound_stmts.rst:1005
msgid ""
"If the length of the subject sequence is less than the number of non-star "
"subpatterns, the sequence pattern fails."
msgstr ""
"Om längden på den aktuella sekvensen är mindre än antalet icke-stjärnformade "
"undermönster misslyckas sekvensmönstret."

#: ../../reference/compound_stmts.rst:1008
msgid ""
"The leading non-star subpatterns are matched to their corresponding items as "
"for fixed-length sequences."
msgstr ""
"De ledande icke-stjärniga undermönstren matchas med sina motsvarande objekt "
"på samma sätt som för sekvenser med fast längd."

#: ../../reference/compound_stmts.rst:1011
msgid ""
"If the previous step succeeds, the star subpattern matches a list formed of "
"the remaining subject items, excluding the remaining items corresponding to "
"non-star subpatterns following the star subpattern."
msgstr ""
"Om föregående steg lyckas, matchar det stjärnformade undermönstret en lista "
"som består av de återstående ämnesobjekten, exklusive de återstående objekt "
"som motsvarar icke-stjärnformade undermönster som följer på det "
"stjärnformade undermönstret."

#: ../../reference/compound_stmts.rst:1015
msgid ""
"Remaining non-star subpatterns are matched to their corresponding subject "
"items, as for a fixed-length sequence."
msgstr ""
"Återstående submönster som inte är stjärnformade matchas med motsvarande "
"ämnesord, precis som för en sekvens med fast längd."

#: ../../reference/compound_stmts.rst:1018
msgid ""
"The length of the subject sequence is obtained via :func:`len` (i.e. via "
"the :meth:`~object.__len__` protocol). This length may be cached by the "
"interpreter in a similar manner as :ref:`value patterns <value-patterns>`."
msgstr ""

#: ../../reference/compound_stmts.rst:1024
msgid ""
"In simple terms ``[P1, P2, P3,`` ... ``, P<N>]`` matches only if all the "
"following happens:"
msgstr ""
"Enkelt uttryckt ``[P1, P2, P3,`` ... ``, P<N>]`` matchar endast om alla "
"följande händelser inträffar:"

#: ../../reference/compound_stmts.rst:1027
msgid "check ``<subject>`` is a sequence"
msgstr "kontrollera ``<subject>`` är en sekvens"

#: ../../reference/compound_stmts.rst:1028
msgid "``len(subject) == <N>``"
msgstr "``len(subject) == <N>``"

#: ../../reference/compound_stmts.rst:1029
msgid ""
"``P1`` matches ``<subject>[0]`` (note that this match can also bind names)"
msgstr ""
"``P1`` matchar ``<subject>[0]`` (observera att denna matchning också kan "
"binda namn)"

#: ../../reference/compound_stmts.rst:1030
msgid ""
"``P2`` matches ``<subject>[1]`` (note that this match can also bind names)"
msgstr ""
"``P2`` matchar ``<subject>[1]`` (observera att denna matchning också kan "
"binda namn)"

#: ../../reference/compound_stmts.rst:1031
msgid "... and so on for the corresponding pattern/element."
msgstr "... och så vidare för motsvarande mönster/element."

#: ../../reference/compound_stmts.rst:1036
msgid "Mapping Patterns"
msgstr "Kartläggning av mönster"

#: ../../reference/compound_stmts.rst:1038
msgid ""
"A mapping pattern contains one or more key-value patterns.  The syntax is "
"similar to the construction of a dictionary. Syntax:"
msgstr ""
"Ett mappningsmönster innehåller ett eller flera nyckel-värde-mönster.  "
"Syntaxen liknar konstruktionen av en ordbok. Syntax för:"

#: ../../reference/compound_stmts.rst:1049
msgid ""
"At most one double star pattern may be in a mapping pattern.  The double "
"star pattern must be the last subpattern in the mapping pattern."
msgstr ""
"Högst ett dubbelstjärnmönster får finnas i ett mappningsmönster.  "
"Dubbelstjärnmönstret måste vara det sista undermönstret i mappningsmönstret."

#: ../../reference/compound_stmts.rst:1052
msgid ""
"Duplicate keys in mapping patterns are disallowed. Duplicate literal keys "
"will raise a :exc:`SyntaxError`. Two keys that otherwise have the same value "
"will raise a :exc:`ValueError` at runtime."
msgstr ""
"Duplicerade nycklar i mappningsmönster är inte tillåtna. Duplicerade "
"bokstavliga nycklar ger upphov till ett :exc:`SyntaxError`. Två nycklar som "
"annars har samma värde kommer att ge upphov till ett :exc:`ValueError` vid "
"körning."

#: ../../reference/compound_stmts.rst:1056
msgid ""
"The following is the logical flow for matching a mapping pattern against a "
"subject value:"
msgstr ""
"Följande är det logiska flödet för att matcha ett mappningsmönster mot ett "
"ämnesvärde:"

#: ../../reference/compound_stmts.rst:1059
msgid "If the subject value is not a mapping [#]_,the mapping pattern fails."
msgstr "Om ämnesvärdet inte är en mappning [#]_ misslyckas mappningsmönstret."

#: ../../reference/compound_stmts.rst:1061
msgid ""
"If every key given in the mapping pattern is present in the subject mapping, "
"and the pattern for each key matches the corresponding item of the subject "
"mapping, the mapping pattern succeeds."
msgstr ""
"Om varje nyckel som anges i mappningsmönstret finns i ämnesmappningen och "
"mönstret för varje nyckel matchar motsvarande post i ämnesmappningen, lyckas "
"mappningsmönstret."

#: ../../reference/compound_stmts.rst:1065
msgid ""
"If duplicate keys are detected in the mapping pattern, the pattern is "
"considered invalid. A :exc:`SyntaxError` is raised for duplicate literal "
"values; or a :exc:`ValueError` for named keys of the same value."
msgstr ""
"Om duplicerade nycklar upptäcks i mappningsmönstret anses mönstret vara "
"ogiltigt. Ett :exc:`SyntaxError` uppstår för duplicerade bokstavliga värden; "
"eller ett :exc:`ValueError` för namngivna nycklar med samma värde."

#: ../../reference/compound_stmts.rst:1069
msgid ""
"Key-value pairs are matched using the two-argument form of the mapping "
"subject's ``get()`` method.  Matched key-value pairs must already be present "
"in the mapping, and not created on-the-fly via :meth:`~object.__missing__` "
"or :meth:`~object.__getitem__`."
msgstr ""

#: ../../reference/compound_stmts.rst:1074
msgid ""
"In simple terms ``{KEY1: P1, KEY2: P2, ... }`` matches only if all the "
"following happens:"
msgstr ""
"Enkelt uttryckt ``{KEY1: P1, KEY2: P2, ... }`` matchar endast om alla "
"följande händelser inträffar:"

#: ../../reference/compound_stmts.rst:1077
msgid "check ``<subject>`` is a mapping"
msgstr "kontrollera att ``<subject>`` är en mappning"

#: ../../reference/compound_stmts.rst:1078
msgid "``KEY1 in <subject>``"
msgstr "``KEY1 in <subject>``"

#: ../../reference/compound_stmts.rst:1079
msgid "``P1`` matches ``<subject>[KEY1]``"
msgstr "``P1`` matchar ``<subject>[KEY1]``"

#: ../../reference/compound_stmts.rst:1080
msgid "... and so on for the corresponding KEY/pattern pair."
msgstr "... och så vidare för motsvarande KEY/mönsterpar."

#: ../../reference/compound_stmts.rst:1086
msgid "Class Patterns"
msgstr "Klassmönster"

#: ../../reference/compound_stmts.rst:1088
msgid ""
"A class pattern represents a class and its positional and keyword arguments "
"(if any).  Syntax:"
msgstr ""
"Ett klassmönster representerar en klass och dess positions- och "
"nyckelordsargument (om sådana finns).  Syntaxen är"

#: ../../reference/compound_stmts.rst:1099
msgid "The same keyword should not be repeated in class patterns."
msgstr "Samma nyckelord bör inte upprepas i klassmönster."

#: ../../reference/compound_stmts.rst:1101
msgid ""
"The following is the logical flow for matching a class pattern against a "
"subject value:"
msgstr ""
"Följande är det logiska flödet för att matcha ett klassmönster mot ett "
"ämnesvärde:"

#: ../../reference/compound_stmts.rst:1104
msgid ""
"If ``name_or_attr`` is not an instance of the builtin :class:`type` , "
"raise :exc:`TypeError`."
msgstr ""
"Om ``name_or_attr`` inte är en instans av den inbyggda :class:`type` , "
"raise :exc:`TypeError`."

#: ../../reference/compound_stmts.rst:1107
msgid ""
"If the subject value is not an instance of ``name_or_attr`` (tested "
"via :func:`isinstance`), the class pattern fails."
msgstr ""
"Om ämnesvärdet inte är en instans av ``name_or_attr`` (testas "
"via :func:`isinstance`) misslyckas klassmönstret."

#: ../../reference/compound_stmts.rst:1110
msgid ""
"If no pattern arguments are present, the pattern succeeds.  Otherwise, the "
"subsequent steps depend on whether keyword or positional argument patterns "
"are present."
msgstr ""
"Om det inte finns några mönsterargument lyckas mönstret.  I annat fall beror "
"de efterföljande stegen på om det finns nyckelords- eller "
"positionsargumentmönster."

#: ../../reference/compound_stmts.rst:1114
msgid ""
"For a number of built-in types (specified below), a single positional "
"subpattern is accepted which will match the entire subject; for these types "
"keyword patterns also work as for other types."
msgstr ""
"För ett antal inbyggda typer (specificeras nedan) accepteras ett enda "
"positionellt undermönster som matchar hela ämnet; för dessa typer fungerar "
"nyckelordsmönster också som för andra typer."

#: ../../reference/compound_stmts.rst:1118
msgid ""
"If only keyword patterns are present, they are processed as follows, one by "
"one:"
msgstr ""
"Om det bara finns nyckelordsmönster behandlas de enligt följande, ett efter "
"ett:"

#: ../../reference/compound_stmts.rst:1121
msgid "I. The keyword is looked up as an attribute on the subject."
msgstr "I. Nyckelordet ses som ett attribut i ämnet."

#: ../../reference/compound_stmts.rst:1123
msgid ""
"If this raises an exception other than :exc:`AttributeError`, the exception "
"bubbles up."
msgstr ""
"Om detta ger upphov till ett annat undantag än :exc:`AttributeError`, "
"bubblar undantaget upp."

#: ../../reference/compound_stmts.rst:1126
msgid "If this raises :exc:`AttributeError`, the class pattern has failed."
msgstr ""
"Om detta ger upphov till :exc:`AttributeError`, har klassmönstret "
"misslyckats."

#: ../../reference/compound_stmts.rst:1128
msgid ""
"Else, the subpattern associated with the keyword pattern is matched against "
"the subject's attribute value.  If this fails, the class pattern fails; if "
"this succeeds, the match proceeds to the next keyword."
msgstr ""
"Annars matchas det undermönster som är associerat med nyckelordsmönstret mot "
"subjektets attributvärde.  Om detta misslyckas, misslyckas klassmönstret; om "
"detta lyckas, fortsätter matchningen till nästa nyckelord."

#: ../../reference/compound_stmts.rst:1133
msgid "II. If all keyword patterns succeed, the class pattern succeeds."
msgstr "II. Om alla nyckelordsmönster lyckas, lyckas klassmönstret."

#: ../../reference/compound_stmts.rst:1135
msgid ""
"If any positional patterns are present, they are converted to keyword "
"patterns using the :data:`~object.__match_args__` attribute on the class "
"``name_or_attr`` before matching:"
msgstr ""
"Om det finns positionella mönster konverteras de till nyckelordsmönster med "
"hjälp av attributet :data:`~object.__match_args__` på klassen "
"``name_or_attr`` före matchning:"

#: ../../reference/compound_stmts.rst:1139
msgid ""
"I. The equivalent of ``getattr(cls, \"__match_args__\", ())`` is called."
msgstr ""
"I. Motsvarigheten till ``getattr(cls, \"__match_args__\", ())`` anropas."

#: ../../reference/compound_stmts.rst:1141
msgid "If this raises an exception, the exception bubbles up."
msgstr "Om detta ger upphov till ett undantag, bubblar undantaget upp."

#: ../../reference/compound_stmts.rst:1143
msgid ""
"If the returned value is not a tuple, the conversion fails "
"and :exc:`TypeError` is raised."
msgstr ""
"Om det returnerade värdet inte är en tupel misslyckas konverteringen "
"och :exc:`TypeError` aktiveras."

#: ../../reference/compound_stmts.rst:1146
msgid ""
"If there are more positional patterns than "
"``len(cls.__match_args__)``, :exc:`TypeError` is raised."
msgstr ""
"Om det finns fler positionsmönster än ``len(cls.__match_args__)``, "
"uppstår :exc:`TypeError`."

#: ../../reference/compound_stmts.rst:1149
msgid ""
"Otherwise, positional pattern ``i`` is converted to a keyword pattern using "
"``__match_args__[i]`` as the keyword.  ``__match_args__[i]`` must be a "
"string; if not :exc:`TypeError` is raised."
msgstr ""
"Annars konverteras det positionella mönstret ``i`` till ett "
"nyckelordsmönster med ``__match_args__[i]`` som nyckelord.  "
"``__match_args__[i]`` måste vara en sträng; om inte :exc:`TypeError` tas upp."

#: ../../reference/compound_stmts.rst:1153
msgid "If there are duplicate keywords, :exc:`TypeError` is raised."
msgstr "Om det finns dubbla nyckelord kommer :exc:`TypeError` att tas upp."

#: ../../reference/compound_stmts.rst:1155
msgid ":ref:`class-pattern-matching`"
msgstr ":ref:`class-pattern-matching`"

#: ../../reference/compound_stmts.rst:1157
msgid ""
"II. Once all positional patterns have been converted to keyword patterns,"
msgstr "II. När alla positionsmönster har omvandlats till sökordsmönster,"

#: ../../reference/compound_stmts.rst:1158
msgid "the match proceeds as if there were only keyword patterns."
msgstr "matchningen fortsätter som om det bara fanns nyckelordsmönster."

#: ../../reference/compound_stmts.rst:1160
msgid ""
"For the following built-in types the handling of positional subpatterns is "
"different:"
msgstr ""
"För följande inbyggda typer är hanteringen av positionella submönster "
"annorlunda:"

#: ../../reference/compound_stmts.rst:1163
msgid ":class:`bool`"
msgstr ":class:`bool`"

#: ../../reference/compound_stmts.rst:1164
msgid ":class:`bytearray`"
msgstr ":class:`bytearray`"

#: ../../reference/compound_stmts.rst:1165
msgid ":class:`bytes`"
msgstr ":class:`bytes`"

#: ../../reference/compound_stmts.rst:1166
msgid ":class:`dict`"
msgstr ":class:`dict`"

#: ../../reference/compound_stmts.rst:1167
msgid ":class:`float`"
msgstr ":class:`float`"

#: ../../reference/compound_stmts.rst:1168
msgid ":class:`frozenset`"
msgstr ":class:`frozenset`"

#: ../../reference/compound_stmts.rst:1169
msgid ":class:`int`"
msgstr ":class:`int`"

#: ../../reference/compound_stmts.rst:1170
#: ../../reference/compound_stmts.rst:1928
msgid ":class:`list`"
msgstr ":class:`lista`"

#: ../../reference/compound_stmts.rst:1171
msgid ":class:`set`"
msgstr ":class:`set`"

#: ../../reference/compound_stmts.rst:1172
msgid ":class:`str`"
msgstr ":class:`str`"

#: ../../reference/compound_stmts.rst:1173
#: ../../reference/compound_stmts.rst:1931
msgid ":class:`tuple`"
msgstr ":class:`tuple`"

#: ../../reference/compound_stmts.rst:1175
msgid ""
"These classes accept a single positional argument, and the pattern there is "
"matched against the whole object rather than an attribute. For example "
"``int(0|1)`` matches the value ``0``, but not the value ``0.0``."
msgstr ""
"Dessa klasser accepterar ett enda positionellt argument, och mönstret där "
"matchas mot hela objektet snarare än ett attribut. Till exempel ``int(0|1)`` "
"matchar värdet ``0``, men inte värdet ``0,0``."

#: ../../reference/compound_stmts.rst:1179
msgid ""
"In simple terms ``CLS(P1, attr=P2)`` matches only if the following happens:"
msgstr ""
"Enkelt uttryckt ``CLS(P1, attr=P2)`` matchar endast om följande inträffar:"

#: ../../reference/compound_stmts.rst:1181
msgid "``isinstance(<subject>, CLS)``"
msgstr "``isinstance(<subject>, CLS)``"

#: ../../reference/compound_stmts.rst:1182
msgid "convert ``P1`` to a keyword pattern using ``CLS.__match_args__``"
msgstr ""
"konvertera ``P1`` till ett nyckelordsmönster med ``CLS.__match_args__``"

#: ../../reference/compound_stmts.rst:1183
msgid "For each keyword argument ``attr=P2``:"
msgstr "För varje nyckelordsargument ``attr=P2``:"

#: ../../reference/compound_stmts.rst:1185
msgid "``hasattr(<subject>, \"attr\")``"
msgstr "``hasattr(<subject>, \"attr\")``"

#: ../../reference/compound_stmts.rst:1186
msgid "``P2`` matches ``<subject>.attr``"
msgstr "``P2`` matchar ``<subject>.attr``"

#: ../../reference/compound_stmts.rst:1188
msgid "... and so on for the corresponding keyword argument/pattern pair."
msgstr "... och så vidare för motsvarande nyckelordsargument/mönsterpar."

#: ../../reference/compound_stmts.rst:1203
msgid "Function definitions"
msgstr "Definitioner av funktioner"

#: ../../reference/compound_stmts.rst:1218
msgid ""
"A function definition defines a user-defined function object (see "
"section :ref:`types`):"
msgstr ""
"En funktionsdefinition definierar ett användardefinierat funktionsobjekt (se "
"avsnitt :ref:`types`):"

#: ../../reference/compound_stmts.rst:1240
msgid ""
"A function definition is an executable statement.  Its execution binds the "
"function name in the current local namespace to a function object (a wrapper "
"around the executable code for the function).  This function object contains "
"a reference to the current global namespace as the global namespace to be "
"used when the function is called."
msgstr ""
"En funktionsdefinition är en exekverbar sats.  När den exekveras binds "
"funktionsnamnet i den aktuella lokala namnrymden till ett funktionsobjekt "
"(ett omslag runt den exekverbara koden för funktionen).  Detta "
"funktionsobjekt innehåller en referens till den aktuella globala namnrymden "
"som den globala namnrymd som ska användas när funktionen anropas."

#: ../../reference/compound_stmts.rst:1246
msgid ""
"The function definition does not execute the function body; this gets "
"executed only when the function is called. [#]_"
msgstr ""
"Funktionsdefinitionen exekverar inte funktionens kropp; denna exekveras "
"först när funktionen anropas. [#]_"

#: ../../reference/compound_stmts.rst:1252
msgid ""
"A function definition may be wrapped by one or more :term:`decorator` "
"expressions. Decorator expressions are evaluated when the function is "
"defined, in the scope that contains the function definition.  The result "
"must be a callable, which is invoked with the function object as the only "
"argument. The returned value is bound to the function name instead of the "
"function object.  Multiple decorators are applied in nested fashion. For "
"example, the following code ::"
msgstr ""
"En funktionsdefinition kan omslutas av ett eller flera :term:`decorator` "
"-uttryck. Dekoratoruttryck utvärderas när funktionen definieras, i det scope "
"som innehåller funktionsdefinitionen.  Resultatet måste vara en callable, "
"som anropas med funktionsobjektet som enda argument. Det returnerade värdet "
"är bundet till funktionsnamnet i stället för till funktionsobjektet.  Flera "
"dekoratorer tillämpas på ett nästlat sätt. Till exempel följande kod ::"

#: ../../reference/compound_stmts.rst:1259
msgid ""
"@f1(arg)\n"
"@f2\n"
"def func(): pass"
msgstr ""
"@f1(arg)\n"
"@f2\n"
"def func(): pass"

#: ../../reference/compound_stmts.rst:1263
#: ../../reference/compound_stmts.rst:1452
msgid "is roughly equivalent to ::"
msgstr "är ungefär likvärdigt med ::"

#: ../../reference/compound_stmts.rst:1265
msgid ""
"def func(): pass\n"
"func = f1(arg)(f2(func))"
msgstr ""
"def func(): pass\n"
"func = f1(arg)(f2(func))"

#: ../../reference/compound_stmts.rst:1268
msgid ""
"except that the original function is not temporarily bound to the name "
"``func``."
msgstr ""
"förutom att den ursprungliga funktionen inte är temporärt bunden till namnet "
"``func``."

#: ../../reference/compound_stmts.rst:1270
msgid ""
"Functions may be decorated with any valid :token:`~python-"
"grammar:assignment_expression`. Previously, the grammar was much more "
"restrictive; see :pep:`614` for details."
msgstr ""
"Funktioner kan dekoreras med valfri giltig :token:`~python-"
"grammar:assignment_expression`. Tidigare var grammatiken mycket mer "
"restriktiv; se :pep:`614` för detaljer."

#: ../../reference/compound_stmts.rst:1275
msgid ""
"A list of :ref:`type parameters <type-params>` may be given in square "
"brackets between the function's name and the opening parenthesis for its "
"parameter list. This indicates to static type checkers that the function is "
"generic. At runtime, the type parameters can be retrieved from the "
"function's :attr:`~function.__type_params__` attribute. See :ref:`generic-"
"functions` for more."
msgstr ""
"En lista med :ref:`typ parametrar <type-params>` kan anges inom hakparentes "
"mellan funktionens namn och den inledande parentesen för dess "
"parameterlista. Detta indikerar för statiska typkontrollanter att funktionen "
"är generisk. Vid körning kan typparametrarna hämtas från "
"funktionens :attr:`~function.__type_params__`\\-attribut. Se :ref:`generic-"
"functions` för mer information."

#: ../../reference/compound_stmts.rst:1282
#: ../../reference/compound_stmts.rst:1471
msgid "Type parameter lists are new in Python 3.12."
msgstr "Typ-parameterlistor är nya i Python 3.12."

#: ../../reference/compound_stmts.rst:1290
msgid ""
"When one or more :term:`parameters <parameter>` have the form *parameter* "
"``=`` *expression*, the function is said to have \"default parameter values."
"\"  For a parameter with a default value, the corresponding :term:`argument` "
"may be omitted from a call, in which case the parameter's default value is "
"substituted.  If a parameter has a default value, all following parameters "
"up until the \"``*``\" must also have a default value --- this is a "
"syntactic restriction that is not expressed by the grammar."
msgstr ""
"När en eller flera :term:`parametrar <parameter>` har formen *parameter* "
"``=`` *uttryck*, sägs funktionen ha \"default parameter values\"  För en "
"parameter med ett standardvärde kan motsvarande :term:`argument` utelämnas "
"från ett anrop, varvid parameterns standardvärde ersätts.  Om en parameter "
"har ett standardvärde måste alla följande parametrar fram till \"``*``\" "
"också ha ett standardvärde --- detta är en syntaktisk restriktion som inte "
"uttrycks av grammatiken."

#: ../../reference/compound_stmts.rst:1298
msgid ""
"**Default parameter values are evaluated from left to right when the "
"function definition is executed.** This means that the expression is "
"evaluated once, when the function is defined, and that the same \"pre-"
"computed\" value is used for each call.  This is especially important to "
"understand when a default parameter value is a mutable object, such as a "
"list or a dictionary: if the function modifies the object (e.g. by appending "
"an item to a list), the default parameter value is in effect modified.  This "
"is generally not what was intended.  A way around this is to use ``None`` as "
"the default, and explicitly test for it in the body of the function, e.g.::"
msgstr ""
"**Standardparametervärden utvärderas från vänster till höger när "
"funktionsdefinitionen exekveras.** Detta innebär att uttrycket utvärderas en "
"gång när funktionen definieras och att samma \"förberäknade\" värde används "
"vid varje anrop.  Detta är särskilt viktigt att förstå när ett "
"standardparametervärde är ett föränderligt objekt, t.ex. en lista eller en "
"ordbok: om funktionen ändrar objektet (t.ex. genom att lägga till ett objekt "
"i en lista), ändras i själva verket standardparametervärdet.  Detta är i "
"allmänhet inte vad som var avsett.  Ett sätt att komma runt detta är att "
"använda ``None`` som standard och uttryckligen testa för det i funktionens "
"kropp, t.ex.::"

#: ../../reference/compound_stmts.rst:1308
msgid ""
"def whats_on_the_telly(penguin=None):\n"
"    if penguin is None:\n"
"        penguin = []\n"
"    penguin.append(\"property of the zoo\")\n"
"    return penguin"
msgstr ""
"def whats_on_the_telly(penguin=None):\n"
"    om penguin är None:\n"
"        penguin = []\n"
"    penguin.append(\"djurparkens egendom\")\n"
"    returnera pingvin"

#: ../../reference/compound_stmts.rst:1319
msgid ""
"Function call semantics are described in more detail in "
"section :ref:`calls`. A function call always assigns values to all "
"parameters mentioned in the parameter list, either from positional "
"arguments, from keyword arguments, or from default values.  If the form "
"\"``*identifier``\" is present, it is initialized to a tuple receiving any "
"excess positional parameters, defaulting to the empty tuple. If the form "
"\"``**identifier``\" is present, it is initialized to a new ordered mapping "
"receiving any excess keyword arguments, defaulting to a new empty mapping of "
"the same type.  Parameters after \"``*``\" or \"``*identifier``\" are "
"keyword-only parameters and may only be passed by keyword arguments.  "
"Parameters before \"``/``\" are positional-only parameters and may only be "
"passed by positional arguments."
msgstr ""
"Semantiken för funktionsanrop beskrivs mer i detalj i avsnitt :ref:`calls`. "
"Ett funktionsanrop tilldelar alltid värden till alla parametrar som nämns i "
"parameterlistan, antingen från positionella argument, från "
"nyckelordsargument eller från standardvärden.  Om formen \"``*identifier``\" "
"finns initialiseras den till en tupel som tar emot eventuella överflödiga "
"positionella parametrar, med den tomma tupeln som standard. Om formen "
"\"``**identifier``\" finns initieras den till en ny ordnad mappning som tar "
"emot eventuella överflödiga nyckelordsargument, med en ny tom mappning av "
"samma typ som standard.  Parametrar efter \"``*``\" eller "
"\"``*identifier``\" är endast nyckelordsparametrar och kan endast skickas "
"med nyckelordsargument.  Parametrar före \"``/``\" är endast "
"positionsparametrar och kan endast överföras med positionsargument."

#: ../../reference/compound_stmts.rst:1331
msgid ""
"The ``/`` function parameter syntax may be used to indicate positional-only "
"parameters. See :pep:`570` for details."
msgstr ""
"Syntaxen ``/`` för funktionsparametrar kan användas för att ange parametrar "
"som endast är positionella. Se :pep:`570` för detaljer."

#: ../../reference/compound_stmts.rst:1340
msgid ""
"Parameters may have an :term:`annotation <function annotation>` of the form "
"\"``: expression``\" following the parameter name.  Any parameter may have "
"an annotation, even those of the form ``*identifier`` or ``**identifier``. "
"(As a special case, parameters of the form ``*identifier`` may have an "
"annotation \"``: *expression``\".) Functions may have \"return\" annotation "
"of the form \"``-> expression``\" after the parameter list.  These "
"annotations can be any valid Python expression.  The presence of annotations "
"does not change the semantics of a function. See :ref:`annotations` for more "
"information on annotations."
msgstr ""
"Parametrar kan ha en :term:`annotation <function annotation>` av formen "
"\"``: expression``\" efter parameternamnet.  Alla parametrar kan ha en "
"annotering, även de av formen ``*identifier`` eller ``**identifier``. (Som "
"ett specialfall kan parametrar av formen ``*identifier`` ha annotationen "
"\"``: *expression``\") Funktioner kan ha en \"return\"-annotation av formen "
"\"``\\-> expression``\" efter parameterlistan.  Dessa annotationer kan vara "
"vilket giltigt Python-uttryck som helst.  Förekomsten av annoteringar ändrar "
"inte semantiken för en funktion. Se :ref:`annotations` för mer information "
"om annotationer."

#: ../../reference/compound_stmts.rst:1348
msgid ""
"Parameters of the form \"``*identifier``\" may have an annotation \"``: "
"*expression``\". See :pep:`646`."
msgstr ""
"Parametrar av formen \"``*identifier``\" kan ha en annotation \"``: "
"*uttryck``\". Se :pep:`646`."

#: ../../reference/compound_stmts.rst:1354
msgid ""
"It is also possible to create anonymous functions (functions not bound to a "
"name), for immediate use in expressions.  This uses lambda expressions, "
"described in section :ref:`lambda`.  Note that the lambda expression is "
"merely a shorthand for a simplified function definition; a function defined "
"in a \":keyword:`def`\" statement can be passed around or assigned to "
"another name just like a function defined by a lambda expression.  The "
"\":keyword:`!def`\" form is actually more powerful since it allows the "
"execution of multiple statements and annotations."
msgstr ""
"Det är också möjligt att skapa anonyma funktioner (funktioner som inte är "
"knutna till ett namn) för omedelbar användning i uttryck.  Här används "
"lambda-uttryck, som beskrivs i avsnitt :ref:`lambda`.  Observera att "
"lambdauttrycket bara är en förkortning för en förenklad funktionsdefinition; "
"en funktion som definieras i en \":keyword:`def`\"-sats kan skickas runt "
"eller tilldelas ett annat namn precis som en funktion som definieras av ett "
"lambdauttryck.  Formen \":keyword:`!def`\" är faktiskt mer kraftfull "
"eftersom den tillåter exekvering av flera satser och annoteringar."

#: ../../reference/compound_stmts.rst:1362
msgid ""
"**Programmer's note:** Functions are first-class objects.  A \"``def``\" "
"statement executed inside a function definition defines a local function "
"that can be returned or passed around.  Free variables used in the nested "
"function can access the local variables of the function containing the def.  "
"See section :ref:`naming` for details."
msgstr ""
"**Programmerarens anmärkning:** Funktioner är första klassens objekt.  En "
"\"``def``\"-sats som exekveras inuti en funktionsdefinition definierar en "
"lokal funktion som kan returneras eller skickas runt.  Fria variabler som "
"används i den nästlade funktionen kan komma åt de lokala variablerna i den "
"funktion som innehåller def. Se avsnitt :ref:`naming` för detaljer."

#: ../../reference/compound_stmts.rst:1370
msgid ":pep:`3107` - Function Annotations"
msgstr ":pep:`3107` - Funktionskommentarer"

#: ../../reference/compound_stmts.rst:1371
msgid "The original specification for function annotations."
msgstr "Den ursprungliga specifikationen för funktionsannoteringar."

#: ../../reference/compound_stmts.rst:1373
msgid ":pep:`484` - Type Hints"
msgstr ":pep:`484` - Tips om typ"

#: ../../reference/compound_stmts.rst:1374
msgid "Definition of a standard meaning for annotations: type hints."
msgstr "Definition av en standardbetydelse för annotationer: typ hints."

#: ../../reference/compound_stmts.rst:1376
msgid ":pep:`526` - Syntax for Variable Annotations"
msgstr ":pep:`526` - Syntax för variabelkommentarer"

#: ../../reference/compound_stmts.rst:1377
msgid ""
"Ability to type hint variable declarations, including class variables and "
"instance variables."
msgstr ""
"Möjlighet att typhinta variabeldeklarationer, inklusive klassvariabler och "
"instansvariabler."

#: ../../reference/compound_stmts.rst:1380
msgid ":pep:`563` - Postponed Evaluation of Annotations"
msgstr ":pep:`563` - Uppskjuten utvärdering av annoteringar"

#: ../../reference/compound_stmts.rst:1381
msgid ""
"Support for forward references within annotations by preserving annotations "
"in a string form at runtime instead of eager evaluation."
msgstr ""
"Stöd för framåtriktade referenser inom annotationer genom att bevara "
"annotationer i strängform vid körning istället för ivrig utvärdering."

#: ../../reference/compound_stmts.rst:1384
msgid ":pep:`318` - Decorators for Functions and Methods"
msgstr ":pep:`318` - Dekoratorer för funktioner och metoder"

#: ../../reference/compound_stmts.rst:1385
msgid ""
"Function and method decorators were introduced. Class decorators were "
"introduced in :pep:`3129`."
msgstr ""
"Funktions- och metoddekoratorer introducerades. Klassdekoratorer "
"introducerades i :pep:`3129`."

#: ../../reference/compound_stmts.rst:1391
msgid "Class definitions"
msgstr "Klassdefinitioner"

#: ../../reference/compound_stmts.rst:1406
msgid "A class definition defines a class object (see section :ref:`types`):"
msgstr ""
"En klassdefinition definierar ett klassobjekt (se avsnitt :ref:`types`):"

#: ../../reference/compound_stmts.rst:1413
msgid ""
"A class definition is an executable statement.  The inheritance list usually "
"gives a list of base classes (see :ref:`metaclasses` for more advanced "
"uses), so each item in the list should evaluate to a class object which "
"allows subclassing.  Classes without an inheritance list inherit, by "
"default, from the base class :class:`object`; hence, ::"
msgstr ""
"En klassdefinition är ett körbart uttalande.  Arvslistan ger vanligtvis en "
"lista över basklasser (se :ref:`metaclasses` för mer avancerade "
"användningsområden), så varje objekt i listan bör utvärderas till ett "
"klassobjekt som tillåter underklassning.  Klasser utan en arvslista ärver, "
"som standard, från basklassen :class:`object`; därav ::"

#: ../../reference/compound_stmts.rst:1419
msgid ""
"class Foo:\n"
"    pass"
msgstr ""
"class Foo:\n"
"    pass"

#: ../../reference/compound_stmts.rst:1422
msgid "is equivalent to ::"
msgstr "är likvärdig med ::"

#: ../../reference/compound_stmts.rst:1424
msgid ""
"class Foo(object):\n"
"    pass"
msgstr ""
"class Foo(object):\n"
"    pass"

#: ../../reference/compound_stmts.rst:1427
msgid ""
"The class's suite is then executed in a new execution frame "
"(see :ref:`naming`), using a newly created local namespace and the original "
"global namespace. (Usually, the suite contains mostly function "
"definitions.)  When the class's suite finishes execution, its execution "
"frame is discarded but its local namespace is saved. [#]_ A class object is "
"then created using the inheritance list for the base classes and the saved "
"local namespace for the attribute dictionary.  The class name is bound to "
"this class object in the original local namespace."
msgstr ""
"Klassens svit exekveras sedan i en ny exekveringsram (se :ref:`naming`), med "
"en nyskapad lokal namnrymd och den ursprungliga globala namnrymden. "
"(Vanligtvis innehåller sviten mest funktionsdefinitioner.) När klassens svit "
"är färdig exekverad kasseras dess exekveringsram men dess lokala namnrymd "
"sparas. [#]_ Ett klassobjekt skapas sedan med hjälp av arvslistan för "
"basklasserna och det sparade lokala namnrymden för attributdictionariet.  "
"Klassnamnet är bundet till detta klassobjekt i den ursprungliga lokala "
"namnrymden."

#: ../../reference/compound_stmts.rst:1436
msgid ""
"The order in which attributes are defined in the class body is preserved in "
"the new class's :attr:`~type.__dict__`.  Note that this is reliable only "
"right after the class is created and only for classes that were defined "
"using the definition syntax."
msgstr ""
"Den ordning i vilken attributen definieras i klassens kropp bevaras i den "
"nya klassens :attr:`~type.__dict__`.  Observera att detta endast är "
"tillförlitligt direkt efter att klassen har skapats och endast för klasser "
"som definierades med definitionssyntaxen."

#: ../../reference/compound_stmts.rst:1441
msgid ""
"Class creation can be customized heavily using :ref:`metaclasses "
"<metaclasses>`."
msgstr ""
"Skapandet av klasser kan anpassas kraftigt med hjälp av :ref:`metaclasses "
"<metaclasses>`."

#: ../../reference/compound_stmts.rst:1446
msgid "Classes can also be decorated: just like when decorating functions, ::"
msgstr ""
"Klasser kan också dekoreras: precis som när du dekorerar funktioner, ::"

#: ../../reference/compound_stmts.rst:1448
msgid ""
"@f1(arg)\n"
"@f2\n"
"class Foo: pass"
msgstr ""
"@f1(arg)\n"
"@f2\n"
"class Foo: pass"

#: ../../reference/compound_stmts.rst:1454
msgid ""
"class Foo: pass\n"
"Foo = f1(arg)(f2(Foo))"
msgstr ""
"class Foo: pass\n"
"Foo = f1(arg)(f2(Foo))"

#: ../../reference/compound_stmts.rst:1457
msgid ""
"The evaluation rules for the decorator expressions are the same as for "
"function decorators.  The result is then bound to the class name."
msgstr ""
"Utvärderingsreglerna för dekoratoruttrycken är desamma som för "
"funktionsdekoratorer.  Resultatet binds sedan till klassnamnet."

#: ../../reference/compound_stmts.rst:1460
msgid ""
"Classes may be decorated with any valid :token:`~python-"
"grammar:assignment_expression`. Previously, the grammar was much more "
"restrictive; see :pep:`614` for details."
msgstr ""
"Klasser kan dekoreras med valfri giltig :token:`~python-"
"grammar:assignment_expression`. Tidigare var grammatiken mycket mer "
"restriktiv; se :pep:`614` för detaljer."

#: ../../reference/compound_stmts.rst:1465
msgid ""
"A list of :ref:`type parameters <type-params>` may be given in square "
"brackets immediately after the class's name. This indicates to static type "
"checkers that the class is generic. At runtime, the type parameters can be "
"retrieved from the class's :attr:`~type.__type_params__` attribute. "
"See :ref:`generic-classes` for more."
msgstr ""
"En lista med :ref:`typ-parametrar <type-params>` kan anges inom "
"hakparenteser omedelbart efter klassens namn. Detta indikerar för statiska "
"typkontrollanter att klassen är generisk. Vid körning kan typ-parametrarna "
"hämtas från klassens :attr:`~type.__type_params__`\\-attribut. "
"Se :ref:`generic-classes` för mer information."

#: ../../reference/compound_stmts.rst:1474
msgid ""
"**Programmer's note:** Variables defined in the class definition are class "
"attributes; they are shared by instances.  Instance attributes can be set in "
"a method with ``self.name = value``.  Both class and instance attributes are "
"accessible through the notation \"``self.name``\", and an instance attribute "
"hides a class attribute with the same name when accessed in this way.  Class "
"attributes can be used as defaults for instance attributes, but using "
"mutable values there can lead to unexpected results.  :ref:`Descriptors "
"<descriptors>` can be used to create instance variables with different "
"implementation details."
msgstr ""
"**Programmerarens anteckning:** Variabler som definieras i klassdefinitionen "
"är klassattribut; de delas av instanser.  Instansattribut kan ställas in i "
"en metod med ``self.name = value``.  Både klass- och instansattribut är "
"åtkomliga genom notationen \"``self.name``\", och ett instansattribut döljer "
"ett klassattribut med samma namn när det är åtkomligt på detta sätt.  "
"Klassattribut kan användas som standard för instansattribut, men att använda "
"föränderliga värden där kan leda till oväntade resultat. :ref:`Deskriptorer "
"<descriptors>` kan användas för att skapa instansvariabler med olika "
"implementationsdetaljer."

#: ../../reference/compound_stmts.rst:1486
msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ":pep:`3115` - Metaklasser i Python 3000"

#: ../../reference/compound_stmts.rst:1487
msgid ""
"The proposal that changed the declaration of metaclasses to the current "
"syntax, and the semantics for how classes with metaclasses are constructed."
msgstr ""
"Förslaget som ändrade deklarationen av metaklasser till den nuvarande "
"syntaxen, och semantiken för hur klasser med metaklasser konstrueras."

#: ../../reference/compound_stmts.rst:1491
msgid ":pep:`3129` - Class Decorators"
msgstr ":pep:`3129` - Klassdekoratorer"

#: ../../reference/compound_stmts.rst:1492
msgid ""
"The proposal that added class decorators.  Function and method decorators "
"were introduced in :pep:`318`."
msgstr ""
"Förslaget som lade till klassdekoratorer.  Funktions- och metoddekoratorer "
"introducerades i :pep:`318`."

#: ../../reference/compound_stmts.rst:1499
msgid "Coroutines"
msgstr "Coroutines"

#: ../../reference/compound_stmts.rst:1507
msgid "Coroutine function definition"
msgstr "Definition av Coroutine-funktion"

#: ../../reference/compound_stmts.rst:1517
msgid ""
"Execution of Python coroutines can be suspended and resumed at many points "
"(see :term:`coroutine`). :keyword:`await` expressions, :keyword:`async for` "
"and :keyword:`async with` can only be used in the body of a coroutine "
"function."
msgstr ""
"Exekveringen av Python coroutines kan avbrytas och återupptas på många "
"ställen (se :term:`coroutine`). uttrycken :keyword:`await`, :keyword:`async "
"for` och :keyword:`async with` kan endast användas i en coroutine-funktion."

#: ../../reference/compound_stmts.rst:1521
msgid ""
"Functions defined with ``async def`` syntax are always coroutine functions, "
"even if they do not contain ``await`` or ``async`` keywords."
msgstr ""
"Funktioner som definieras med syntaxen ``async def`` är alltid coroutine-"
"funktioner, även om de inte innehåller nyckelorden ``await`` eller ``async``."

#: ../../reference/compound_stmts.rst:1524
msgid ""
"It is a :exc:`SyntaxError` to use a ``yield from`` expression inside the "
"body of a coroutine function."
msgstr ""
"Det är ett :exc:`SyntaxError` att använda ett ``yield from``\\ -uttryck "
"inuti en coroutine-funktion."

#: ../../reference/compound_stmts.rst:1527
msgid "An example of a coroutine function::"
msgstr "Ett exempel på en coroutine-funktion::"

#: ../../reference/compound_stmts.rst:1529
msgid ""
"async def func(param1, param2):\n"
"    do_stuff()\n"
"    await some_coroutine()"
msgstr ""
"async def func(param1, param2):\n"
"    do_stuff()\n"
"    await någon_coroutine()"

#: ../../reference/compound_stmts.rst:1533
msgid ""
"``await`` and ``async`` are now keywords; previously they were only treated "
"as such inside the body of a coroutine function."
msgstr ""
"``await`` och ``async`` är nu nyckelord; tidigare behandlades de bara som "
"sådana inom en coroutine-funktion."

#: ../../reference/compound_stmts.rst:1541
msgid "The :keyword:`!async for` statement"
msgstr "Nyckelordet: `!async for`\\-satsen"

#: ../../reference/compound_stmts.rst:1546
msgid ""
"An :term:`asynchronous iterable` provides an ``__aiter__`` method that "
"directly returns an :term:`asynchronous iterator`, which can call "
"asynchronous code in its ``__anext__`` method."
msgstr ""
"Ett :term:`asynchronous iterable` tillhandahåller en ``__aiter__``\\-metod "
"som direkt returnerar en :term:`asynchronous iterator`, som kan anropa "
"asynkron kod i sin ``__anext__``\\-metod."

#: ../../reference/compound_stmts.rst:1550
msgid ""
"The ``async for`` statement allows convenient iteration over asynchronous "
"iterables."
msgstr ""
"Satsen ``async for`` möjliggör bekväm iteration över asynkrona iterabler."

#: ../../reference/compound_stmts.rst:1555
msgid ""
"async for TARGET in ITER:\n"
"    SUITE\n"
"else:\n"
"    SUITE2"
msgstr ""
"asynkron för TARGET i ITER:\n"
"    SUITE\n"
"annat:\n"
"    SUITE2"

#: ../../reference/compound_stmts.rst:1560
msgid "Is semantically equivalent to::"
msgstr "Är semantiskt ekvivalent med::"

#: ../../reference/compound_stmts.rst:1562
msgid ""
"iter = (ITER)\n"
"iter = type(iter).__aiter__(iter)\n"
"running = True\n"
"\n"
"while running:\n"
"    try:\n"
"        TARGET = await type(iter).__anext__(iter)\n"
"    except StopAsyncIteration:\n"
"        running = False\n"
"    else:\n"
"        SUITE\n"
"else:\n"
"    SUITE2"
msgstr ""
"iter = (ITER)\n"
"iter = typ(iter).__aiter__(iter)\n"
"kör = sant\n"
"\n"
"medan körs:\n"
"    try:\n"
"        TARGET = await typ(iter).__anext__(iter)\n"
"    except StopAsyncIteration:\n"
"        running = False\n"
"    else:\n"
"        SUITE\n"
"else:\n"
"    SUITE2"

#: ../../reference/compound_stmts.rst:1576
msgid ""
"See also :meth:`~object.__aiter__` and :meth:`~object.__anext__` for details."
msgstr ""
"Se även :meth:`~object.__aiter__` och :meth:`~object.__anext__` för mer "
"information."

#: ../../reference/compound_stmts.rst:1578
msgid ""
"It is a :exc:`SyntaxError` to use an ``async for`` statement outside the "
"body of a coroutine function."
msgstr ""
"Det är ett :exc:`SyntaxError` att använda en ``async for``\\-sats utanför "
"kroppen på en coroutine-funktion."

#: ../../reference/compound_stmts.rst:1586
msgid "The :keyword:`!async with` statement"
msgstr "Nyckelordet: `!async with`\\-satsen"

#: ../../reference/compound_stmts.rst:1591
msgid ""
"An :term:`asynchronous context manager` is a :term:`context manager` that is "
"able to suspend execution in its *enter* and *exit* methods."
msgstr ""
"En :term:`asynchronous context manager` är en :term:`context manager` som "
"kan avbryta exekveringen i sina *enter*- och *exit*-metoder."

#: ../../reference/compound_stmts.rst:1596
msgid ""
"async with EXPRESSION as TARGET:\n"
"    SUITE"
msgstr ""
"async med EXPRESSION som TARGET:\n"
"    SUITE"

#: ../../reference/compound_stmts.rst:1601
msgid ""
"manager = (EXPRESSION)\n"
"aenter = type(manager).__aenter__\n"
"aexit = type(manager).__aexit__\n"
"value = await aenter(manager)\n"
"hit_except = False\n"
"\n"
"try:\n"
"    TARGET = value\n"
"    SUITE\n"
"except:\n"
"    hit_except = True\n"
"    if not await aexit(manager, *sys.exc_info()):\n"
"        raise\n"
"finally:\n"
"    if not hit_except:\n"
"        await aexit(manager, None, None, None)"
msgstr ""
"manager = (Uttryck)\n"
"aenter = typ(chef).__aenter__\n"
"aexit = typ(manager).__aexit__\n"
"value = await aenter(chef)\n"
"hit_except = Falsk\n"
"\n"
"försök:\n"
"    TARGET = värde\n"
"    SUITE\n"
"undantag:\n"
"    hit_except = True\n"
"    if not await aexit(manager, *sys.exc_info()):\n"
"        höjning\n"
"slutligen:\n"
"    om inte hit_except:\n"
"        await aexit(chef, Ingen, Ingen, Ingen)"

#: ../../reference/compound_stmts.rst:1618
msgid ""
"See also :meth:`~object.__aenter__` and :meth:`~object.__aexit__` for "
"details."
msgstr ""
"Se även :meth:`~object.__aenter__` och :meth:`~object.__aexit__` för mer "
"information."

#: ../../reference/compound_stmts.rst:1620
msgid ""
"It is a :exc:`SyntaxError` to use an ``async with`` statement outside the "
"body of a coroutine function."
msgstr ""
"Det är ett :exc:`SyntaxError` att använda en ``async with``\\-sats utanför "
"kroppen på en coroutine-funktion."

#: ../../reference/compound_stmts.rst:1625
msgid ":pep:`492` - Coroutines with async and await syntax"
msgstr ":pep:`492` - Coroutines med async- och await-syntax"

#: ../../reference/compound_stmts.rst:1626
msgid ""
"The proposal that made coroutines a proper standalone concept in Python, and "
"added supporting syntax."
msgstr ""
"Förslaget som gjorde coroutines till ett riktigt fristående koncept i Python "
"och lade till stödjande syntax."

#: ../../reference/compound_stmts.rst:1632
msgid "Type parameter lists"
msgstr "Typ parameterlistor"

#: ../../reference/compound_stmts.rst:1636
msgid "Support for default values was added (see :pep:`696`)."
msgstr "Stöd för standardvärden har lagts till (se :pep:`696`)."

#: ../../reference/compound_stmts.rst:1649
msgid ""
":ref:`Functions <def>` (including :ref:`coroutines <async "
"def>`), :ref:`classes <class>` and :ref:`type aliases <type>` may contain a "
"type parameter list::"
msgstr ""
":ref:`Functions <def>` (inklusive :ref:`coroutines <async "
"def>`), :ref:`classes <class>` och :ref:`type aliases <type>` kan innehålla "
"en typ parameter list::"

#: ../../reference/compound_stmts.rst:1653
msgid ""
"def max[T](args: list[T]) -> T:\n"
"    ...\n"
"\n"
"async def amax[T](args: list[T]) -> T:\n"
"    ...\n"
"\n"
"class Bag[T]:\n"
"    def __iter__(self) -> Iterator[T]:\n"
"        ...\n"
"\n"
"    def add(self, arg: T) -> None:\n"
"        ...\n"
"\n"
"type ListOrSet[T] = list[T] | set[T]"
msgstr ""
"def max[T](args: list[T]) -> T:\n"
"    ...\n"
"\n"
"async def amax[T](args: list[T]) -> T:\n"
"    ...\n"
"\n"
"class Bag[T]:\n"
"    def __iter__(self) -> Iterator[T]:\n"
"        ...\n"
"\n"
"    def add(self, arg: T) -> None:\n"
"        ...\n"
"\n"
"type ListOrSet[T] = list[T] | set[T]"

#: ../../reference/compound_stmts.rst:1668
msgid ""
"Semantically, this indicates that the function, class, or type alias is "
"generic over a type variable. This information is primarily used by static "
"type checkers, and at runtime, generic objects behave much like their non-"
"generic counterparts."
msgstr ""
"Semantiskt sett indikerar detta att funktionen, klassen eller typaliaset är "
"generiskt över en typvariabel. Denna information används främst av statiska "
"typkontrollanter, och vid körning beter sig generiska objekt ungefär som "
"sina icke-generiska motsvarigheter."

#: ../../reference/compound_stmts.rst:1673
msgid ""
"Type parameters are declared in square brackets (``[]``) immediately after "
"the name of the function, class, or type alias. The type parameters are "
"accessible within the scope of the generic object, but not elsewhere. Thus, "
"after a declaration ``def func[T](): pass``, the name ``T`` is not available "
"in the module scope. Below, the semantics of generic objects are described "
"with more precision. The scope of type parameters is modeled with a special "
"function (technically, an :ref:`annotation scope <annotation-scopes>`) that "
"wraps the creation of the generic object."
msgstr ""
"Typparametrar deklareras inom hakparenteser (``[]``) omedelbart efter namnet "
"på funktionen, klassen eller typaliaset. Typ-parametrarna är åtkomliga inom "
"det generiska objektets scope, men inte någon annanstans. Efter en "
"deklaration ``def func[T](): pass`` är således namnet ``T`` inte "
"tillgängligt i modulens scope. Nedan beskrivs semantiken för generiska "
"objekt med större precision. Omfattningen av typparametrar modelleras med en "
"speciell funktion (tekniskt sett en :ref:`annotation scope <annotation-"
"scopes>`) som omsluter skapandet av det generiska objektet."

#: ../../reference/compound_stmts.rst:1682
msgid ""
"Generic functions, classes, and type aliases have "
"a :attr:`~definition.__type_params__` attribute listing their type "
"parameters."
msgstr ""
"Generiska funktioner, klasser och typaliaser har "
"ett :attr:`~definition.__type_params__`\\-attribut som listar deras "
"typparametrar."

#: ../../reference/compound_stmts.rst:1685
msgid "Type parameters come in three kinds:"
msgstr "Det finns tre olika typer av parametrar:"

#: ../../reference/compound_stmts.rst:1687
msgid ""
":data:`typing.TypeVar`, introduced by a plain name (e.g., ``T``). "
"Semantically, this represents a single type to a type checker."
msgstr ""
":data:`typing.TypeVar`, inleds med ett vanligt namn (t.ex. ``T``). "
"Semantiskt representerar detta en enda typ för en typkontrollör."

#: ../../reference/compound_stmts.rst:1689
msgid ""
":data:`typing.TypeVarTuple`, introduced by a name prefixed with a single "
"asterisk (e.g., ``*Ts``). Semantically, this stands for a tuple of any "
"number of types."
msgstr ""
":data:`typing.TypeVarTuple`, inleds med ett namn som föregås av en asterisk "
"(t.ex. ``*Ts``). Semantiskt står detta för en tupel av valfritt antal typer."

#: ../../reference/compound_stmts.rst:1692
msgid ""
":data:`typing.ParamSpec`, introduced by a name prefixed with two asterisks "
"(e.g., ``**P``). Semantically, this stands for the parameters of a callable."
msgstr ""
":data:`typing.ParamSpec`, inleds med ett namn som föregås av två asterisker "
"(t.ex. ``**P``). Semantiskt står detta för parametrarna för en callable."

#: ../../reference/compound_stmts.rst:1695
msgid ""
":data:`typing.TypeVar` declarations can define *bounds* and *constraints* "
"with a colon (``:``) followed by an expression. A single expression after "
"the colon indicates a bound (e.g. ``T: int``). Semantically, this means that "
"the :data:`!typing.TypeVar` can only represent types that are a subtype of "
"this bound. A parenthesized tuple of expressions after the colon indicates a "
"set of constraints (e.g. ``T: (str, bytes)``). Each member of the tuple "
"should be a type (again, this is not enforced at runtime). Constrained type "
"variables can only take on one of the types in the list of constraints."
msgstr ""
":data:`typing.TypeVar`\\-deklarationer kan definiera *gränser* och "
"*begränsningar* med ett kolon (``:``) följt av ett uttryck. Ett enda uttryck "
"efter kolon anger en bound (t.ex. ``T: int``). Semantiskt innebär detta "
"att :data:`!typing.TypeVar` endast kan representera typer som är en subtyp "
"av denna bound. En parentesförsedd tupel av uttryck efter kolon anger en "
"uppsättning begränsningar (t.ex. ``T: (str, bytes)``). Varje medlem i tupeln "
"bör vara en typ (återigen, detta verkställs inte vid körning). Variabler av "
"typen Constrained kan bara anta en av typerna i listan med begränsningar."

#: ../../reference/compound_stmts.rst:1704
msgid ""
"For :data:`!typing.TypeVar`\\ s declared using the type parameter list "
"syntax, the bound and constraints are not evaluated when the generic object "
"is created, but only when the value is explicitly accessed through the "
"attributes ``__bound__`` and ``__constraints__``. To accomplish this, the "
"bounds or constraints are evaluated in a separate :ref:`annotation scope "
"<annotation-scopes>`."
msgstr ""
"För :data:`!typing.TypeVar`` som deklareras med hjälp av syntaxen för typ-"
"parameterlistan utvärderas inte bindningarna och begränsningarna när det "
"generiska objektet skapas, utan endast när värdet uttryckligen nås via "
"attributen ``__bound__`` och ``__constraints__``. För att åstadkomma detta "
"utvärderas gränserna eller begränsningarna i en separat :ref:`annotation "
"scope <annotation-scopes>`."

#: ../../reference/compound_stmts.rst:1710
msgid ""
":data:`typing.TypeVarTuple`\\ s and :data:`typing.ParamSpec`\\ s cannot have "
"bounds or constraints."
msgstr ""
":data:`typing.TypeVarTuple` s och :data:`typing.ParamSpec` s kan inte ha "
"gränser eller begränsningar."

#: ../../reference/compound_stmts.rst:1713
msgid ""
"All three flavors of type parameters can also have a *default value*, which "
"is used when the type parameter is not explicitly provided. This is added by "
"appending a single equals sign (``=``) followed by an expression. Like the "
"bounds and constraints of type variables, the default value is not evaluated "
"when the object is created, but only when the type parameter's "
"``__default__`` attribute is accessed. To this end, the default value is "
"evaluated in a separate :ref:`annotation scope <annotation-scopes>`. If no "
"default value is specified for a type parameter, the ``__default__`` "
"attribute is set to the special sentinel object :data:`typing.NoDefault`."
msgstr ""
"Alla tre typerna av typparametrar kan också ha ett *standardvärde*, som "
"används när typparametern inte anges explicit. Detta läggs till genom att "
"lägga till ett enda likhetstecken (``=``) följt av ett uttryck. Precis som "
"typvariablernas gränser och begränsningar utvärderas inte standardvärdet när "
"objektet skapas, utan först när typparameterns attribut ``__default__`` "
"används. Därför utvärderas standardvärdet i en separat :ref:`annotation "
"scope <annotation-scopes>`. Om inget standardvärde anges för en typparameter "
"sätts attributet ``__default__`` till det speciella sentinel-"
"objektet :data:`typing.NoDefault`."

#: ../../reference/compound_stmts.rst:1723
msgid ""
"The following example indicates the full set of allowed type parameter "
"declarations::"
msgstr ""
"Följande exempel visar hela uppsättningen av tillåtna deklarationer av "
"typparametrar::"

#: ../../reference/compound_stmts.rst:1725
msgid ""
"def overly_generic[\n"
"   SimpleTypeVar,\n"
"   TypeVarWithDefault = int,\n"
"   TypeVarWithBound: int,\n"
"   TypeVarWithConstraints: (str, bytes),\n"
"   *SimpleTypeVarTuple = (int, float),\n"
"   **SimpleParamSpec = (str, bytearray),\n"
"](\n"
"   a: SimpleTypeVar,\n"
"   b: TypeVarWithDefault,\n"
"   c: TypeVarWithBound,\n"
"   d: Callable[SimpleParamSpec, TypeVarWithConstraints],\n"
"   *e: SimpleTypeVarTuple,\n"
"): ..."
msgstr ""
"def overly_generic[\n"
"   SimpleTypeVar,\n"
"   TypeVarWithDefault = int,\n"
"   TypeVarWithBound: int,\n"
"   TypeVarWithConstraints: (str, bytes),\n"
"   *SimpleTypeVarTuple = (int, float),\n"
"   **SimpleParamSpec = (str, bytearray),\n"
"](\n"
"   a: SimpleTypeVar,\n"
"   b: TypeVarWithDefault,\n"
"   c: TypeVarWithBound,\n"
"   d: Callable[SimpleParamSpec, TypeVarWithConstraints],\n"
"   *e: SimpleTypeVarTuple,\n"
"): ..."

#: ../../reference/compound_stmts.rst:1743
msgid "Generic functions"
msgstr "Generiska funktioner"

#: ../../reference/compound_stmts.rst:1745
msgid "Generic functions are declared as follows::"
msgstr "Generiska funktioner deklareras på följande sätt::"

#: ../../reference/compound_stmts.rst:1747
msgid "def func[T](arg: T): ..."
msgstr "def func[T](arg: T): ..."

#: ../../reference/compound_stmts.rst:1749
#: ../../reference/compound_stmts.rst:1809
msgid "This syntax is equivalent to::"
msgstr "Denna syntax är likvärdig med::"

#: ../../reference/compound_stmts.rst:1751
msgid ""
"annotation-def TYPE_PARAMS_OF_func():\n"
"    T = typing.TypeVar(\"T\")\n"
"    def func(arg: T): ...\n"
"    func.__type_params__ = (T,)\n"
"    return func\n"
"func = TYPE_PARAMS_OF_func()"
msgstr ""
"annotation-def TYPE_PARAMS_OF_func():\n"
"    T = typing.TypeVar(\"T\")\n"
"    def func(arg: T): ...\n"
"    func.__type_params__ = (T,)\n"
"    returnera func\n"
"func = TYPE_PARAMS_OF_func()"

#: ../../reference/compound_stmts.rst:1758
msgid ""
"Here ``annotation-def`` indicates an :ref:`annotation scope <annotation-"
"scopes>`, which is not actually bound to any name at runtime. (One other "
"liberty is taken in the translation: the syntax does not go through "
"attribute access on the :mod:`typing` module, but creates an instance "
"of :data:`typing.TypeVar` directly.)"
msgstr ""
"Här anger ``annotation-def`` en :ref:`annotation scope <annotation-scopes>`, "
"som inte är bunden till något namn vid körning. (En annan frihet tas i "
"översättningen: syntaxen går inte genom attributåtkomst på "
"modulen :mod:`typing`, utan skapar en instans av :data:`typing.TypeVar` "
"direkt)"

#: ../../reference/compound_stmts.rst:1764
msgid ""
"The annotations of generic functions are evaluated within the annotation "
"scope used for declaring the type parameters, but the function's defaults "
"and decorators are not."
msgstr ""
"Annoteringarna för generiska funktioner utvärderas inom det "
"annoteringsområde som används för att deklarera typparametrarna, men det gör "
"inte funktionens standardvärden och dekoratorer."

#: ../../reference/compound_stmts.rst:1768
msgid ""
"The following example illustrates the scoping rules for these cases, as well "
"as for additional flavors of type parameters::"
msgstr ""
"Följande exempel illustrerar scopingreglerna för dessa fall, samt för "
"ytterligare varianter av typparametrar::"

#: ../../reference/compound_stmts.rst:1771
msgid ""
"@decorator\n"
"def func[T: int, *Ts, **P](*args: *Ts, arg: Callable[P, T] = some_default):\n"
"    ..."
msgstr ""
"@dekorator\n"
"def func[T: int, *Ts, **P](*args: *Ts, arg: Callable[P, T] = some_default):\n"
"    ..."

#: ../../reference/compound_stmts.rst:1775
msgid ""
"Except for the :ref:`lazy evaluation <lazy-evaluation>` of "
"the :class:`~typing.TypeVar` bound, this is equivalent to::"
msgstr ""
"Med undantag för :ref:`lazy evaluation <lazy-evaluation>` "
"av :class:`~typing.TypeVar`\\-bindningen, är detta likvärdigt med::"

#: ../../reference/compound_stmts.rst:1778
msgid ""
"DEFAULT_OF_arg = some_default\n"
"\n"
"annotation-def TYPE_PARAMS_OF_func():\n"
"\n"
"    annotation-def BOUND_OF_T():\n"
"        return int\n"
"    # In reality, BOUND_OF_T() is evaluated only on demand.\n"
"    T = typing.TypeVar(\"T\", bound=BOUND_OF_T())\n"
"\n"
"    Ts = typing.TypeVarTuple(\"Ts\")\n"
"    P = typing.ParamSpec(\"P\")\n"
"\n"
"    def func(*args: *Ts, arg: Callable[P, T] = DEFAULT_OF_arg):\n"
"        ...\n"
"\n"
"    func.__type_params__ = (T, Ts, P)\n"
"    return func\n"
"func = decorator(TYPE_PARAMS_OF_func())"
msgstr ""
"DEFAULT_OF_arg = någon_default\n"
"\n"
"annotation-def TYPE_PARAMS_OF_func():\n"
"\n"
"    annotation-def BOUND_OF_T():\n"
"        returnera int\n"
"    # I verkligheten utvärderas BOUND_OF_T() endast på begäran.\n"
"    T = typing.TypeVar(\"T\", bound=BOUND_OF_T())\n"
"\n"
"    Ts = typing.TypeVarTuple(\"Ts\")\n"
"    P = typing.ParamSpec(\"P\")\n"
"\n"
"    def func(*args: *Ts, arg: Callable[P, T] = DEFAULT_OF_arg):\n"
"        ...\n"
"\n"
"    func.__type_params__ = (T, Ts, P)\n"
"    returnera func\n"
"func = dekorator(TYPE_PARAMS_OF_func())"

#: ../../reference/compound_stmts.rst:1797
msgid ""
"The capitalized names like ``DEFAULT_OF_arg`` are not actually bound at "
"runtime."
msgstr ""
"De versala namnen som ``DEFAULT_OF_arg`` är faktiskt inte bundna vid körning."

#: ../../reference/compound_stmts.rst:1803
msgid "Generic classes"
msgstr "Generiska klasser"

#: ../../reference/compound_stmts.rst:1805
msgid "Generic classes are declared as follows::"
msgstr "Generiska klasser deklareras på följande sätt::"

#: ../../reference/compound_stmts.rst:1807
msgid "class Bag[T]: ..."
msgstr "class Bag[T]: ..."

#: ../../reference/compound_stmts.rst:1811
msgid ""
"annotation-def TYPE_PARAMS_OF_Bag():\n"
"    T = typing.TypeVar(\"T\")\n"
"    class Bag(typing.Generic[T]):\n"
"        __type_params__ = (T,)\n"
"        ...\n"
"    return Bag\n"
"Bag = TYPE_PARAMS_OF_Bag()"
msgstr ""
"annotation-def TYPE_PARAMS_OF_Bag():\n"
"    T = typing.TypeVar(\"T\")\n"
"    class Bag(typing.Generic[T]):\n"
"        __type_params__ = (T,)\n"
"        ...\n"
"    returnera Bag\n"
"Bag = TYPE_PARAMS_OF_Bag()"

#: ../../reference/compound_stmts.rst:1819
msgid ""
"Here again ``annotation-def`` (not a real keyword) indicates "
"an :ref:`annotation scope <annotation-scopes>`, and the name "
"``TYPE_PARAMS_OF_Bag`` is not actually bound at runtime."
msgstr ""
"Även här anger ``annotation-def`` (inte ett riktigt nyckelord) "
"en :ref:`annotation scope <annotation-scopes>`, och namnet "
"``TYPE_PARAMS_OF_Bag`` är inte faktiskt bundet vid körning."

#: ../../reference/compound_stmts.rst:1823
msgid ""
"Generic classes implicitly inherit from :data:`typing.Generic`. The base "
"classes and keyword arguments of generic classes are evaluated within the "
"type scope for the type parameters, and decorators are evaluated outside "
"that scope. This is illustrated by this example::"
msgstr ""
"Generiska klasser ärver implicit från :data:`typing.Generic`. Basklasserna "
"och nyckelordsargumenten för generiska klasser utvärderas inom typomfånget "
"för typparametrarna, och dekoratorer utvärderas utanför detta omfång. Detta "
"illustreras av detta exempel::"

#: ../../reference/compound_stmts.rst:1829
msgid ""
"@decorator\n"
"class Bag(Base[T], arg=T): ..."
msgstr ""
"@dekoratör\n"
"class Bag(Base[T], arg=T): ..."

#: ../../reference/compound_stmts.rst:1832
msgid "This is equivalent to::"
msgstr "Detta är likvärdigt med::"

#: ../../reference/compound_stmts.rst:1834
msgid ""
"annotation-def TYPE_PARAMS_OF_Bag():\n"
"    T = typing.TypeVar(\"T\")\n"
"    class Bag(Base[T], typing.Generic[T], arg=T):\n"
"        __type_params__ = (T,)\n"
"        ...\n"
"    return Bag\n"
"Bag = decorator(TYPE_PARAMS_OF_Bag())"
msgstr ""
"annotation-def TYPE_PARAMS_OF_Bag():\n"
"    T = typing.TypeVar(\"T\")\n"
"    class Bag(Base[T], typing.Generic[T], arg=T):\n"
"        __type_params__ = (T,)\n"
"        ...\n"
"    return Bag\n"
"Bag = dekorator(TYPE_PARAMS_OF_Bag())"

#: ../../reference/compound_stmts.rst:1845
msgid "Generic type aliases"
msgstr "Alias för generiska typer"

#: ../../reference/compound_stmts.rst:1847
msgid ""
"The :keyword:`type` statement can also be used to create a generic type "
"alias::"
msgstr ""
"Satsen :keyword:`type` kan också användas för att skapa ett generiskt "
"typalias::"

#: ../../reference/compound_stmts.rst:1849
msgid "type ListOrSet[T] = list[T] | set[T]"
msgstr "typ ListOrSet[T] = list[T] | set[T]"

#: ../../reference/compound_stmts.rst:1851
msgid ""
"Except for the :ref:`lazy evaluation <lazy-evaluation>` of the value, this "
"is equivalent to::"
msgstr ""
"Med undantag för :ref:`långsam utvärdering <lazy-evaluation>` av värdet, är "
"detta likvärdigt med::"

#: ../../reference/compound_stmts.rst:1854
msgid ""
"annotation-def TYPE_PARAMS_OF_ListOrSet():\n"
"    T = typing.TypeVar(\"T\")\n"
"\n"
"    annotation-def VALUE_OF_ListOrSet():\n"
"        return list[T] | set[T]\n"
"    # In reality, the value is lazily evaluated\n"
"    return typing.TypeAliasType(\"ListOrSet\", VALUE_OF_ListOrSet(), "
"type_params=(T,))\n"
"ListOrSet = TYPE_PARAMS_OF_ListOrSet()"
msgstr ""
"annotation-def TYPE_PARAMS_OF_ListOrSet():\n"
"    T = typing.TypeVar(\"T\")\n"
"\n"
"    annotation-def VALUE_OF_ListOrSet():\n"
"        return list[T] | set[T]\n"
"    # I verkligheten utvärderas värdet lättsinnigt\n"
"    return typing.TypeAliasType(\"ListOrSet\", VALUE_OF_ListOrSet(), "
"type_params=(T,))\n"
"ListOrSet = TYPE_PARAMS_OF_ListOrSet()"

#: ../../reference/compound_stmts.rst:1863
msgid ""
"Here, ``annotation-def`` (not a real keyword) indicates an :ref:`annotation "
"scope <annotation-scopes>`. The capitalized names like "
"``TYPE_PARAMS_OF_ListOrSet`` are not actually bound at runtime."
msgstr ""
"Här anger ``annotation-def`` (inte ett riktigt nyckelord) "
"en :ref:`annotation scope <annotation-scopes>`. De versala namnen som "
"``TYPE_PARAMS_OF_ListOrSet`` är faktiskt inte bundna vid körning."

#: ../../reference/compound_stmts.rst:1870
msgid "Annotations"
msgstr "Anteckningar"

#: ../../reference/compound_stmts.rst:1872
msgid "Annotations are now lazily evaluated by default."
msgstr "Annotationer utvärderas nu lättsamt som standard."

#: ../../reference/compound_stmts.rst:1875
msgid ""
"Variables and function parameters may carry :term:`annotations "
"<annotation>`, created by adding a colon after the name, followed by an "
"expression::"
msgstr ""
"Variabler och funktionsparametrar kan ha :term:`annotationer <annotation>`, "
"som skapas genom att lägga till ett kolon efter namnet, följt av ett "
"uttryck::"

#: ../../reference/compound_stmts.rst:1878
msgid ""
"x: annotation = 1\n"
"def f(param: annotation): ..."
msgstr ""
"x: anteckning = 1\n"
"def f(param: annotation): ..."

#: ../../reference/compound_stmts.rst:1881
msgid "Functions may also carry a return annotation following an arrow::"
msgstr "Funktioner kan också ha en returannotering som följer en pil::"

#: ../../reference/compound_stmts.rst:1883
msgid "def f() -> annotation: ..."
msgstr "def f() -> annotation: ..."

#: ../../reference/compound_stmts.rst:1885
msgid ""
"Annotations are conventionally used for :term:`type hints <type hint>`, but "
"this is not enforced by the language, and in general annotations may contain "
"arbitrary expressions. The presence of annotations does not change the "
"runtime semantics of the code, except if some mechanism is used that "
"introspects and uses the annotations (such as :mod:`dataclasses` "
"or :func:`functools.singledispatch`)."
msgstr ""
"Annotationer används konventionellt för :term:`type hints <type hint>`, men "
"detta är inte påtvingat av språket, och i allmänhet kan annotationer "
"innehålla godtyckliga uttryck. Förekomsten av annoteringar ändrar inte "
"kodens körtidssemantik, förutom om någon mekanism används som introspekterar "
"och använder annoteringarna (t.ex. :mod:`dataclasses` "
"eller :func:`functools.singledispatch`)."

#: ../../reference/compound_stmts.rst:1891
msgid ""
"By default, annotations are lazily evaluated in an :ref:`annotation scope "
"<annotation-scopes>`. This means that they are not evaluated when the code "
"containing the annotation is evaluated. Instead, the interpreter saves "
"information that can be used to evaluate the annotation later if requested. "
"The :mod:`annotationlib` module provides tools for evaluating annotations."
msgstr ""
"Som standard utvärderas annoteringar i ett :ref:`annotation scope "
"<annotation-scopes>`. Detta innebär att de inte utvärderas när koden som "
"innehåller annotationen utvärderas. Istället sparar tolken information som "
"kan användas för att utvärdera annotationen senare om så begärs. "
"Modulen :mod:`annotationlib` tillhandahåller verktyg för att utvärdera "
"annotationer."

#: ../../reference/compound_stmts.rst:1896
msgid ""
"If the :ref:`future statement <future>` ``from __future__ import "
"annotations`` is present, all annotations are instead stored as strings::"
msgstr ""
"Om :ref:`future-satsen <future>` ``from __future__ import annotations`` är "
"närvarande, lagras alla annotationer istället som strängar::"

#: ../../reference/compound_stmts.rst:1899
msgid ""
">>> from __future__ import annotations\n"
">>> def f(param: annotation): ...\n"
">>> f.__annotations__\n"
"{'param': 'annotation'}"
msgstr ""
">>> from __future__ import annotations\n"
">>> def f(param: annotation): ...\n"
">>> f.__annotations__\n"
"{'param': 'annotation'}"

#: ../../reference/compound_stmts.rst:1904
msgid ""
"This future statement will be deprecated and removed in a future version of "
"Python, but not before Python 3.13 reaches its end of life (see :pep:`749`). "
"When it is used, introspection tools "
"like :func:`annotationlib.get_annotations` and :func:`typing.get_type_hints` "
"are less likely to be able to resolve annotations at runtime."
msgstr ""
"Detta framtida uttalande kommer att vara föråldrat och tas bort i en "
"framtida version av Python, men inte innan Python 3.13 når sitt livs slut "
"(se :pep:`749`). När det används är det mindre sannolikt att "
"introspektionsverktyg som :func:`annotationlib.get_annotations` "
"och :func:`typing.get_type_hints` kan lösa annoteringar vid körning."

#: ../../reference/compound_stmts.rst:1912
msgid "Footnotes"
msgstr "Fotnoter"

#: ../../reference/compound_stmts.rst:1913
msgid ""
"The exception is propagated to the invocation stack unless there is "
"a :keyword:`finally` clause which happens to raise another exception. That "
"new exception causes the old one to be lost."
msgstr ""
"Undantaget sprids till anropsstacken om det inte finns "
"en :keyword:`finally`\\-klausul som råkar ge upphov till ett annat undantag. "
"Det nya undantaget gör att det gamla går förlorat."

#: ../../reference/compound_stmts.rst:1917
msgid "In pattern matching, a sequence is defined as one of the following:"
msgstr "Vid mönstermatchning definieras en sekvens som något av följande:"

#: ../../reference/compound_stmts.rst:1919
msgid "a class that inherits from :class:`collections.abc.Sequence`"
msgstr "en klass som ärver från :class:`collections.abc.Sequence`"

#: ../../reference/compound_stmts.rst:1920
msgid ""
"a Python class that has been registered as :class:`collections.abc.Sequence`"
msgstr ""
"en Python-klass som har registrerats som :class:`collections.abc.Sequence`"

#: ../../reference/compound_stmts.rst:1921
msgid ""
"a builtin class that has its (CPython) :c:macro:`Py_TPFLAGS_SEQUENCE` bit set"
msgstr ""
"en inbyggd klass som har sin (CPython) :c:macro:`Py_TPFLAGS_SEQUENCE` bit "
"inställd"

#: ../../reference/compound_stmts.rst:1922
#: ../../reference/compound_stmts.rst:1941
msgid "a class that inherits from any of the above"
msgstr "en klass som ärver från någon av ovanstående"

#: ../../reference/compound_stmts.rst:1924
msgid "The following standard library classes are sequences:"
msgstr "Följande standardbiblioteksklasser är sekvenser:"

#: ../../reference/compound_stmts.rst:1926
msgid ":class:`array.array`"
msgstr ":class:`array.array`"

#: ../../reference/compound_stmts.rst:1927
msgid ":class:`collections.deque`"
msgstr ":class:`collections.deque`"

#: ../../reference/compound_stmts.rst:1929
msgid ":class:`memoryview`"
msgstr ":class:`memoryview`"

#: ../../reference/compound_stmts.rst:1930
msgid ":class:`range`"
msgstr ":class:`intervall`"

#: ../../reference/compound_stmts.rst:1933
msgid ""
"Subject values of type ``str``, ``bytes``, and ``bytearray`` do not match "
"sequence patterns."
msgstr ""
"Ämnesvärden av typen ``str``, ``bytes`` och ``bytearray`` matchar inte "
"sekvensmönster."

#: ../../reference/compound_stmts.rst:1936
msgid "In pattern matching, a mapping is defined as one of the following:"
msgstr "Vid mönstermatchning definieras en mappning som något av följande:"

#: ../../reference/compound_stmts.rst:1938
msgid "a class that inherits from :class:`collections.abc.Mapping`"
msgstr "en klass som ärver från :class:`collections.abc.Mapping`"

#: ../../reference/compound_stmts.rst:1939
msgid ""
"a Python class that has been registered as :class:`collections.abc.Mapping`"
msgstr ""
"en Python-klass som har registrerats som :class:`collections.abc.Mapping`"

#: ../../reference/compound_stmts.rst:1940
msgid ""
"a builtin class that has its (CPython) :c:macro:`Py_TPFLAGS_MAPPING` bit set"
msgstr ""
"en inbyggd klass som har sin (CPython) :c:macro:`Py_TPFLAGS_MAPPING` bit "
"inställd"

#: ../../reference/compound_stmts.rst:1943
msgid ""
"The standard library classes :class:`dict` "
"and :class:`types.MappingProxyType` are mappings."
msgstr ""
"Standardbiblioteksklasserna :class:`dict` "
"och :class:`types.MappingProxyType` är mappningar."

#: ../../reference/compound_stmts.rst:1946
msgid ""
"A string literal appearing as the first statement in the function body is "
"transformed into the function's :attr:`~function.__doc__` attribute and "
"therefore the function's :term:`docstring`."
msgstr ""
"En bokstavlig sträng som förekommer som första sats i funktionens kropp "
"omvandlas till funktionens :attr:`~function.__doc__`\\-attribut och därmed "
"till funktionens :term:`docstring`."

#: ../../reference/compound_stmts.rst:1950
msgid ""
"A string literal appearing as the first statement in the class body is "
"transformed into the namespace's :attr:`~type.__doc__` item and therefore "
"the class's :term:`docstring`."
msgstr ""
"En bokstavlig sträng som förekommer som första sats i klassens kropp "
"omvandlas till namnrymdens :attr:`~type.__doc__`\\-objekt och därmed till "
"klassens :term:`docstring`."

#: ../../reference/compound_stmts.rst:7
msgid "compound"
msgstr "förening"

#: ../../reference/compound_stmts.rst:7 ../../reference/compound_stmts.rst:86
#: ../../reference/compound_stmts.rst:111
#: ../../reference/compound_stmts.rst:129
#: ../../reference/compound_stmts.rst:144
#: ../../reference/compound_stmts.rst:169
#: ../../reference/compound_stmts.rst:207
#: ../../reference/compound_stmts.rst:393
#: ../../reference/compound_stmts.rst:442
#: ../../reference/compound_stmts.rst:480
#: ../../reference/compound_stmts.rst:598
#: ../../reference/compound_stmts.rst:1205
#: ../../reference/compound_stmts.rst:1393
#: ../../reference/compound_stmts.rst:1503
#: ../../reference/compound_stmts.rst:1537
#: ../../reference/compound_stmts.rst:1582
msgid "statement"
msgstr "uttalande"

#: ../../reference/compound_stmts.rst:21
msgid "clause"
msgstr "klausul"

#: ../../reference/compound_stmts.rst:21
msgid "suite"
msgstr "svit"

#: ../../reference/compound_stmts.rst:21
msgid "; (semicolon)"
msgstr "; (semikolon)"

#: ../../reference/compound_stmts.rst:64
msgid "NEWLINE token"
msgstr "NEWLINE-token"

#: ../../reference/compound_stmts.rst:64
msgid "DEDENT token"
msgstr "DEDENT-token"

#: ../../reference/compound_stmts.rst:64
msgid "dangling"
msgstr "dinglande"

#: ../../reference/compound_stmts.rst:64 ../../reference/compound_stmts.rst:86
#: ../../reference/compound_stmts.rst:111
#: ../../reference/compound_stmts.rst:144
#: ../../reference/compound_stmts.rst:207
#: ../../reference/compound_stmts.rst:393
msgid "else"
msgstr "annat"

#: ../../reference/compound_stmts.rst:86 ../../reference/compound_stmts.rst:598
msgid "if"
msgstr "om"

#: ../../reference/compound_stmts.rst:86 ../../reference/compound_stmts.rst:111
#: ../../reference/compound_stmts.rst:144
#: ../../reference/compound_stmts.rst:207
#: ../../reference/compound_stmts.rst:330
#: ../../reference/compound_stmts.rst:393
#: ../../reference/compound_stmts.rst:411
#: ../../reference/compound_stmts.rst:480
#: ../../reference/compound_stmts.rst:598
#: ../../reference/compound_stmts.rst:1513
msgid "keyword"
msgstr "sökord"

#: ../../reference/compound_stmts.rst:86
msgid "elif"
msgstr "elif"

#: ../../reference/compound_stmts.rst:86 ../../reference/compound_stmts.rst:111
#: ../../reference/compound_stmts.rst:144
#: ../../reference/compound_stmts.rst:207
#: ../../reference/compound_stmts.rst:480
#: ../../reference/compound_stmts.rst:598
#: ../../reference/compound_stmts.rst:1205
#: ../../reference/compound_stmts.rst:1335
#: ../../reference/compound_stmts.rst:1393
msgid ": (colon)"
msgstr ": (kolon)"

#: ../../reference/compound_stmts.rst:86 ../../reference/compound_stmts.rst:111
#: ../../reference/compound_stmts.rst:144
#: ../../reference/compound_stmts.rst:207
#: ../../reference/compound_stmts.rst:480
#: ../../reference/compound_stmts.rst:598
#: ../../reference/compound_stmts.rst:1205
#: ../../reference/compound_stmts.rst:1393
msgid "compound statement"
msgstr "sammansatt uttalande"

#: ../../reference/compound_stmts.rst:111
msgid "while"
msgstr "medan"

#: ../../reference/compound_stmts.rst:111
#: ../../reference/compound_stmts.rst:144
msgid "loop"
msgstr "loop"

#: ../../reference/compound_stmts.rst:129
#: ../../reference/compound_stmts.rst:169
#: ../../reference/compound_stmts.rst:393
#: ../../reference/compound_stmts.rst:442
msgid "break"
msgstr "bryta"

#: ../../reference/compound_stmts.rst:129
#: ../../reference/compound_stmts.rst:169
#: ../../reference/compound_stmts.rst:393
#: ../../reference/compound_stmts.rst:442
msgid "continue"
msgstr "fortsätta"

#: ../../reference/compound_stmts.rst:144
msgid "for"
msgstr "för"

#: ../../reference/compound_stmts.rst:144
msgid "in"
msgstr "i"

#: ../../reference/compound_stmts.rst:144
msgid "target"
msgstr "lokation"

#: ../../reference/compound_stmts.rst:144
msgid "list"
msgstr "lista"

#: ../../reference/compound_stmts.rst:144
#: ../../reference/compound_stmts.rst:301
#: ../../reference/compound_stmts.rst:1205
#: ../../reference/compound_stmts.rst:1393
msgid "object"
msgstr "objekt"

#: ../../reference/compound_stmts.rst:144
msgid "sequence"
msgstr "sekvens"

#: ../../reference/compound_stmts.rst:190
msgid "built-in function"
msgstr "inbyggd funktion"

#: ../../reference/compound_stmts.rst:190
msgid "range"
msgstr "intervall"

#: ../../reference/compound_stmts.rst:207
msgid "try"
msgstr "försök"

#: ../../reference/compound_stmts.rst:207
msgid "except"
msgstr "utom"

#: ../../reference/compound_stmts.rst:207
#: ../../reference/compound_stmts.rst:411
msgid "finally"
msgstr "slutligen"

#: ../../reference/compound_stmts.rst:207
#: ../../reference/compound_stmts.rst:268
#: ../../reference/compound_stmts.rst:480
#: ../../reference/compound_stmts.rst:598
msgid "as"
msgstr "som"

#: ../../reference/compound_stmts.rst:268
msgid "except clause"
msgstr "utom klausul"

#: ../../reference/compound_stmts.rst:301
msgid "module"
msgstr "modul"

#: ../../reference/compound_stmts.rst:301
msgid "sys"
msgstr "system"

#: ../../reference/compound_stmts.rst:301
msgid "traceback"
msgstr "spårning"

#: ../../reference/compound_stmts.rst:330
msgid "except_star"
msgstr "utom_stjärna"

#: ../../reference/compound_stmts.rst:393
#: ../../reference/compound_stmts.rst:442
msgid "return"
msgstr "tillbaka"

#: ../../reference/compound_stmts.rst:480
msgid "with"
msgstr "med"

#: ../../reference/compound_stmts.rst:480
msgid "with statement"
msgstr "med uttalande"

#: ../../reference/compound_stmts.rst:480
#: ../../reference/compound_stmts.rst:1205
#: ../../reference/compound_stmts.rst:1393
msgid ", (comma)"
msgstr ", (kommatecken)"

#: ../../reference/compound_stmts.rst:598
msgid "match"
msgstr "matcha"

#: ../../reference/compound_stmts.rst:598
msgid "case"
msgstr "referens"

#: ../../reference/compound_stmts.rst:598
msgid "pattern matching"
msgstr "mönstermatchning"

#: ../../reference/compound_stmts.rst:598
msgid "match statement"
msgstr "matchningsförklaring"

#: ../../reference/compound_stmts.rst:702
msgid "guard"
msgstr "vakt"

#: ../../reference/compound_stmts.rst:741
msgid "irrefutable case block"
msgstr "obestridligt fallblock"

#: ../../reference/compound_stmts.rst:741
msgid "case block"
msgstr "fallblock"

#: ../../reference/compound_stmts.rst:765
msgid "! patterns"
msgstr "! mönster"

#: ../../reference/compound_stmts.rst:765
msgid "AS pattern, OR pattern, capture pattern, wildcard pattern"
msgstr "AS-mönster, OR-mönster, capture-mönster, jokerteckenmönster"

#: ../../reference/compound_stmts.rst:1196
#: ../../reference/compound_stmts.rst:1285
msgid "parameter"
msgstr "parameter"

#: ../../reference/compound_stmts.rst:1196
#: ../../reference/compound_stmts.rst:1205
#: ../../reference/compound_stmts.rst:1249
#: ../../reference/compound_stmts.rst:1285
#: ../../reference/compound_stmts.rst:1314
msgid "function definition"
msgstr "definition av funktion"

#: ../../reference/compound_stmts.rst:1205
msgid "def"
msgstr "def"

#: ../../reference/compound_stmts.rst:1205
#: ../../reference/compound_stmts.rst:1335
msgid "function"
msgstr "funktion"

#: ../../reference/compound_stmts.rst:1205
#: ../../reference/compound_stmts.rst:1393
msgid "definition"
msgstr "definition"

#: ../../reference/compound_stmts.rst:1205
#: ../../reference/compound_stmts.rst:1393
msgid "name"
msgstr "namn"

#: ../../reference/compound_stmts.rst:1205
#: ../../reference/compound_stmts.rst:1393
msgid "binding"
msgstr "bindning"

#: ../../reference/compound_stmts.rst:1205
msgid "user-defined function"
msgstr "användardefinierad funktion"

#: ../../reference/compound_stmts.rst:1205
#: ../../reference/compound_stmts.rst:1393
msgid "() (parentheses)"
msgstr "() (inom parentes)"

#: ../../reference/compound_stmts.rst:1205
msgid "parameter list"
msgstr "parameterlista"

#: ../../reference/compound_stmts.rst:1249
#: ../../reference/compound_stmts.rst:1443
msgid "@ (at)"
msgstr "@ (vid)"

#: ../../reference/compound_stmts.rst:1285
msgid "default"
msgstr "standard"

#: ../../reference/compound_stmts.rst:1285
msgid "value"
msgstr "värde"

#: ../../reference/compound_stmts.rst:1285
msgid "argument"
msgstr "argument"

#: ../../reference/compound_stmts.rst:1285
msgid "= (equals)"
msgstr "= (lika med)"

#: ../../reference/compound_stmts.rst:1314
msgid "/ (slash)"
msgstr "/ (snedstreck)"

#: ../../reference/compound_stmts.rst:1314
msgid "* (asterisk)"
msgstr "* (asterisk)"

#: ../../reference/compound_stmts.rst:1314
msgid "**"
msgstr "**"

#: ../../reference/compound_stmts.rst:1335
msgid "annotations"
msgstr "anteckningar"

#: ../../reference/compound_stmts.rst:1335
msgid "->"
msgstr "->"

#: ../../reference/compound_stmts.rst:1335
msgid "function annotations"
msgstr "funktionskommentarer"

#: ../../reference/compound_stmts.rst:1352
msgid "lambda"
msgstr "lambda"

#: ../../reference/compound_stmts.rst:1352
msgid "expression"
msgstr "uttryck"

#: ../../reference/compound_stmts.rst:1393
msgid "class"
msgstr "klass"

#: ../../reference/compound_stmts.rst:1393
msgid "execution"
msgstr "avrättning"

#: ../../reference/compound_stmts.rst:1393
msgid "frame"
msgstr "ram"

#: ../../reference/compound_stmts.rst:1393
msgid "inheritance"
msgstr "arv"

#: ../../reference/compound_stmts.rst:1393
msgid "docstring"
msgstr "dokumentsträng"

#: ../../reference/compound_stmts.rst:1393
#: ../../reference/compound_stmts.rst:1443
msgid "class definition"
msgstr "klassdefinition"

#: ../../reference/compound_stmts.rst:1393
msgid "expression list"
msgstr "uttrycksförteckning"

#: ../../reference/compound_stmts.rst:1503
msgid "async def"
msgstr "asynkron def"

#: ../../reference/compound_stmts.rst:1513
msgid "async"
msgstr "asynkron"

#: ../../reference/compound_stmts.rst:1513
msgid "await"
msgstr "invänta"

#: ../../reference/compound_stmts.rst:1537
msgid "async for"
msgstr "asynkron för"

#: ../../reference/compound_stmts.rst:1582
msgid "async with"
msgstr "asynkron med"

#: ../../reference/compound_stmts.rst:1639
msgid "type parameters"
msgstr "typ parametrar"
