# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# python-doc bot, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-25 17:21+0000\n"
"PO-Revision-Date: 2025-09-22 15:58+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../reference/simple_stmts.rst:6
msgid "Simple statements"
msgstr "Enkla statements"

#: ../../reference/simple_stmts.rst:10
msgid ""
"A simple statement is comprised within a single logical line. Several simple"
" statements may occur on a single line separated by semicolons.  The syntax "
"for simple statements is:"
msgstr ""
"Ett enkelt statement består av en enda logisk rad. Flera enkla satser kan "
"förekomma på en och samma rad, åtskilda av semikolon.  Syntaxen för enkla "
"satser är:"

#: ../../reference/simple_stmts.rst:36
msgid "Expression statements"
msgstr "Uttrycksförklaringar"

#: ../../reference/simple_stmts.rst:43
msgid ""
"Expression statements are used (mostly interactively) to compute and write a"
" value, or (usually) to call a procedure (a function that returns no "
"meaningful result; in Python, procedures return the value ``None``).  Other "
"uses of expression statements are allowed and occasionally useful.  The "
"syntax for an expression statement is:"
msgstr ""
"Uttryckssatser används (oftast interaktivt) för att beräkna och skriva ett "
"värde, eller (vanligtvis) för att anropa en procedur (en funktion som inte "
"returnerar något meningsfullt resultat; i Python returnerar procedurer "
"värdet ``None``).  Andra användningar av expression-satser är tillåtna och "
"ibland användbara.  Syntaxen för en expression-sats är:"

#: ../../reference/simple_stmts.rst:52
msgid ""
"An expression statement evaluates the expression list (which may be a single"
" expression)."
msgstr ""
"En expression-sats utvärderar uttrycksförteckningen (som kan vara ett enda "
"uttryck)."

#: ../../reference/simple_stmts.rst:64
msgid ""
"In interactive mode, if the value is not ``None``, it is converted to a "
"string using the built-in :func:`repr` function and the resulting string is "
"written to standard output on a line by itself (except if the result is "
"``None``, so that procedure calls do not cause any output.)"
msgstr ""
"I interaktivt läge, om värdet inte är ``None``, konverteras det till en "
"sträng med hjälp av den inbyggda funktionen :func:`repr` och den "
"resulterande strängen skrivs till standardutdata på en rad för sig själv "
"(utom om resultatet är ``None``, så att proceduranrop inte orsakar någon "
"utdata)"

#: ../../reference/simple_stmts.rst:72
msgid "Assignment statements"
msgstr "Uppdragsinformation"

#: ../../reference/simple_stmts.rst:82
msgid ""
"Assignment statements are used to (re)bind names to values and to modify "
"attributes or items of mutable objects:"
msgstr ""
"Assignment-satser används för att (om)binda namn till värden och för att "
"ändra attribut eller objekt i föränderliga objekt:"

#: ../../reference/simple_stmts.rst:96
msgid ""
"(See section :ref:`primaries` for the syntax definitions for *attributeref*,"
" *subscription*, and *slicing*.)"
msgstr ""
"(Se avsnitt :ref:`primaries` för syntaxdefinitionerna för *attributeref*, "
"*subscription* och *slicing*)"

#: ../../reference/simple_stmts.rst:99
msgid ""
"An assignment statement evaluates the expression list (remember that this "
"can be a single expression or a comma-separated list, the latter yielding a "
"tuple) and assigns the single resulting object to each of the target lists, "
"from left to right."
msgstr ""
"En assignment-sats utvärderar uttryckslistan (kom ihåg att detta kan vara "
"ett enda uttryck eller en kommaseparerad lista, där det senare ger en tupel)"
" och tilldelar det enda resulterande objektet till var och en av "
"mållistorna, från vänster till höger."

#: ../../reference/simple_stmts.rst:108
msgid ""
"Assignment is defined recursively depending on the form of the target "
"(list). When a target is part of a mutable object (an attribute reference, "
"subscription or slicing), the mutable object must ultimately perform the "
"assignment and decide about its validity, and may raise an exception if the "
"assignment is unacceptable.  The rules observed by various types and the "
"exceptions raised are given with the definition of the object types (see "
"section :ref:`types`)."
msgstr ""
"Tilldelning definieras rekursivt beroende på målets form (lista). När ett "
"mål är en del av ett föränderligt objekt (en attributreferens, prenumeration"
" eller slicing), måste det föränderliga objektet i slutändan utföra "
"tilldelningen och besluta om dess giltighet, och kan ge upphov till ett "
"undantag om tilldelningen är oacceptabel.  De regler som observeras av olika"
" typer och de undantag som uppstår anges i samband med definitionen av "
"objekttyperna (se avsnitt :ref:`types`)."

#: ../../reference/simple_stmts.rst:121
msgid ""
"Assignment of an object to a target list, optionally enclosed in parentheses"
" or square brackets, is recursively defined as follows."
msgstr ""
"Tilldelning av ett objekt till en mållista, eventuellt innesluten i "
"parenteser eller hakparenteser, definieras rekursivt på följande sätt."

#: ../../reference/simple_stmts.rst:124
msgid ""
"If the target list is a single target with no trailing comma, optionally in "
"parentheses, the object is assigned to that target."
msgstr ""
"Om mållistan är ett enda mål utan efterföljande kommatecken, eventuellt inom"
" parentes, tilldelas objektet till det målet."

#: ../../reference/simple_stmts.rst:127
msgid "Else:"
msgstr "Else:"

#: ../../reference/simple_stmts.rst:129
msgid ""
"If the target list contains one target prefixed with an asterisk, called a "
"\"starred\" target: The object must be an iterable with at least as many "
"items as there are targets in the target list, minus one.  The first items "
"of the iterable are assigned, from left to right, to the targets before the "
"starred target.  The final items of the iterable are assigned to the targets"
" after the starred target.  A list of the remaining items in the iterable is"
" then assigned to the starred target (the list can be empty)."
msgstr ""
"Om mållistan innehåller ett mål med en asterisk som prefix kallas det för "
"ett \"stjärnmärkt\" mål: Objektet måste vara en iterabel med minst lika "
"många objekt som det finns mål i mållistan, minus ett.  De första objekten i"
" iterabeln tilldelas, från vänster till höger, till målen före det "
"stjärnmärkta målet.  De sista objekten i iterabeln tilldelas målen efter det"
" stjärnmärkta målet.  En lista över de återstående objekten i iterationen "
"tilldelas sedan det stjärnmärkta målet (listan kan vara tom)."

#: ../../reference/simple_stmts.rst:137
msgid ""
"Else: The object must be an iterable with the same number of items as there "
"are targets in the target list, and the items are assigned, from left to "
"right, to the corresponding targets."
msgstr ""
"Annars: Objektet måste vara en iterabel med samma antal objekt som det finns"
" mål i mållistan, och objekten tilldelas, från vänster till höger, till "
"motsvarande mål."

#: ../../reference/simple_stmts.rst:141
msgid ""
"Assignment of an object to a single target is recursively defined as "
"follows."
msgstr ""
"Tilldelning av ett objekt till ett enda mål definieras rekursivt enligt "
"följande."

#: ../../reference/simple_stmts.rst:143
msgid "If the target is an identifier (name):"
msgstr "Om målet är en identifierare (namn):"

#: ../../reference/simple_stmts.rst:145
msgid ""
"If the name does not occur in a :keyword:`global` or :keyword:`nonlocal` "
"statement in the current code block: the name is bound to the object in the "
"current local namespace."
msgstr ""
"Om namnet inte förekommer i en :keyword:`global`\\- eller "
":keyword:`nonlocal`\\-sats i det aktuella kodblocket: namnet är bundet till "
"objektet i den aktuella lokala namnrymden."

#: ../../reference/simple_stmts.rst:149
msgid ""
"Otherwise: the name is bound to the object in the global namespace or the "
"outer namespace determined by :keyword:`nonlocal`, respectively."
msgstr ""
"Annars: namnet är bundet till objektet i den globala namnrymden eller den "
"yttre namnrymden som bestäms av :keyword:`nonlocal`, respektive."

#: ../../reference/simple_stmts.rst:154
msgid ""
"The name is rebound if it was already bound.  This may cause the reference "
"count for the object previously bound to the name to reach zero, causing the"
" object to be deallocated and its destructor (if it has one) to be called."
msgstr ""
"Namnet reboundas om det redan var bundet.  Detta kan leda till att "
"referensantalet för det objekt som tidigare var bundet till namnet når noll,"
" vilket leder till att objektet avallokeras och att dess destruktor (om det "
"har en sådan) anropas."

#: ../../reference/simple_stmts.rst:160
msgid ""
"If the target is an attribute reference: The primary expression in the "
"reference is evaluated.  It should yield an object with assignable "
"attributes; if this is not the case, :exc:`TypeError` is raised.  That "
"object is then asked to assign the assigned object to the given attribute; "
"if it cannot perform the assignment, it raises an exception (usually but not"
" necessarily :exc:`AttributeError`)."
msgstr ""
"Om målet är en attributreferens: Det primära uttrycket i referensen "
"utvärderas.  Det bör resultera i ett objekt med tilldelningsbara attribut; "
"om så inte är fallet anges :exc:`TypeError`.  Objektet ombeds sedan att "
"tilldela det tilldelade objektet till det givna attributet; om det inte kan "
"utföra tilldelningen utlöses ett undantag (vanligtvis men inte nödvändigtvis"
" :exc:`AttributeError`)."

#: ../../reference/simple_stmts.rst:169
msgid ""
"Note: If the object is a class instance and the attribute reference occurs "
"on both sides of the assignment operator, the right-hand side expression, "
"``a.x`` can access either an instance attribute or (if no instance attribute"
" exists) a class attribute.  The left-hand side target ``a.x`` is always set"
" as an instance attribute, creating it if necessary.  Thus, the two "
"occurrences of ``a.x`` do not necessarily refer to the same attribute: if "
"the right-hand side expression refers to a class attribute, the left-hand "
"side creates a new instance attribute as the target of the assignment::"
msgstr ""
"Observera: Om objektet är en klassinstans och attributreferensen förekommer "
"på båda sidor om tilldelningsoperatorn, kan uttrycket på höger sida, "
"``a.x``, få åtkomst till antingen ett instansattribut eller (om inget "
"instansattribut finns) ett klassattribut.  Målet på vänstersidan, ``a.x``, "
"anges alltid som ett instansattribut och skapas vid behov.  De två "
"förekomsterna av ``a.x`` behöver alltså inte nödvändigtvis referera till "
"samma attribut: om uttrycket på högersidan refererar till ett klassattribut,"
" skapar vänstersidan ett nytt instansattribut som mål för tilldelningen::"

#: ../../reference/simple_stmts.rst:183
msgid ""
"This description does not necessarily apply to descriptor attributes, such "
"as properties created with :func:`property`."
msgstr ""
"Denna beskrivning gäller inte nödvändigtvis deskriptorattribut, t.ex. "
"egenskaper som skapats med :func:`property`."

#: ../../reference/simple_stmts.rst:190
msgid ""
"If the target is a subscription: The primary expression in the reference is "
"evaluated.  It should yield either a mutable sequence object (such as a "
"list) or a mapping object (such as a dictionary).  Next, the subscript "
"expression is evaluated."
msgstr ""
"Om målet är en prenumeration: Det primära uttrycket i referensen utvärderas."
"  Det bör ge antingen ett muterbart sekvensobjekt (t.ex. en lista) eller ett"
" mappningsobjekt (t.ex. en ordbok).  Därefter utvärderas det subskriberade "
"uttrycket."

#: ../../reference/simple_stmts.rst:199
msgid ""
"If the primary is a mutable sequence object (such as a list), the subscript "
"must yield an integer.  If it is negative, the sequence's length is added to"
" it.  The resulting value must be a nonnegative integer less than the "
"sequence's length, and the sequence is asked to assign the assigned object "
"to its item with that index.  If the index is out of range, "
":exc:`IndexError` is raised (assignment to a subscripted sequence cannot add"
" new items to a list)."
msgstr ""
"Om primären är ett muterbart sekvensobjekt (t.ex. en lista) måste subscript "
"ge ett heltal.  Om det är negativt adderas sekvensens längd till det.  Det "
"resulterande värdet måste vara ett icke-negativt heltal som är mindre än "
"sekvensens längd, och sekvensen uppmanas att tilldela det tilldelade "
"objektet till sitt objekt med det indexet.  Om indexet är utanför "
"intervallet, :exc:`IndexError` (tilldelning till en abonnerad sekvens kan "
"inte lägga till nya objekt i en lista)."

#: ../../reference/simple_stmts.rst:210
msgid ""
"If the primary is a mapping object (such as a dictionary), the subscript "
"must have a type compatible with the mapping's key type, and the mapping is "
"then asked to create a key/datum pair which maps the subscript to the "
"assigned object.  This can either replace an existing key/value pair with "
"the same key value, or insert a new key/value pair (if no key with the same "
"value existed)."
msgstr ""

#: ../../reference/simple_stmts.rst:216
msgid ""
"For user-defined objects, the :meth:`__setitem__` method is called with "
"appropriate arguments."
msgstr ""

#: ../../reference/simple_stmts.rst:221
msgid ""
"If the target is a slicing: The primary expression in the reference is "
"evaluated.  It should yield a mutable sequence object (such as a list).  The"
" assigned object should be a sequence object of the same type.  Next, the "
"lower and upper bound expressions are evaluated, insofar they are present; "
"defaults are zero and the sequence's length.  The bounds should evaluate to "
"integers. If either bound is negative, the sequence's length is added to it."
"  The resulting bounds are clipped to lie between zero and the sequence's "
"length, inclusive.  Finally, the sequence object is asked to replace the "
"slice with the items of the assigned sequence.  The length of the slice may "
"be different from the length of the assigned sequence, thus changing the "
"length of the target sequence, if the target sequence allows it."
msgstr ""
"Om målet är en skivning: Det primära uttrycket i referensen utvärderas.  Det"
" bör ge ett muterbart sekvensobjekt (t.ex. en lista).  Det tilldelade "
"objektet ska vara ett sekvensobjekt av samma typ.  Därefter utvärderas de "
"nedre och övre gränsuttrycken, i den mån de finns; standardvärdena är noll "
"och sekvensens längd.  Gränserna bör utvärderas till heltal. Om någon av "
"gränserna är negativ adderas sekvensens längd till den.  De resulterande "
"gränserna klipps så att de ligger mellan noll och sekvensens längd, "
"inklusive.  Slutligen ombeds sekvensobjektet att ersätta skivan med objekten"
" i den tilldelade sekvensen.  Slice-längden kan skilja sig från längden på "
"den tilldelade sekvensen och därmed ändra längden på målsekvensen, om "
"målsekvensen tillåter det."

#: ../../reference/simple_stmts.rst:235
msgid ""
"In the current implementation, the syntax for targets is taken to be the "
"same as for expressions, and invalid syntax is rejected during the code "
"generation phase, causing less detailed error messages."
msgstr ""
"I den nuvarande implementeringen anses syntaxen för mål vara densamma som "
"för uttryck, och ogiltig syntax avvisas under kodgenereringsfasen, vilket "
"orsakar mindre detaljerade felmeddelanden."

#: ../../reference/simple_stmts.rst:239
msgid ""
"Although the definition of assignment implies that overlaps between the "
"left-hand side and the right-hand side are 'simultaneous' (for example ``a, "
"b = b, a`` swaps two variables), overlaps *within* the collection of "
"assigned-to variables occur left-to-right, sometimes resulting in confusion."
"  For instance, the following program prints ``[0, 2]``::"
msgstr ""
"Även om definitionen av tilldelning innebär att överlappningar mellan "
"vänster och höger sida är \"samtidiga\" (t.ex. ``a, b = b, a`` byter två "
"variabler), sker överlappningar *inom* samlingen av variabler som tilldelats"
" till vänster till höger, vilket ibland leder till förvirring.  Till exempel"
" skriver följande program ut ``[0, 2]``::"

#: ../../reference/simple_stmts.rst:253
msgid ":pep:`3132` - Extended Iterable Unpacking"
msgstr ":pep:`3132` - Utökad uppackning av iterabel"

#: ../../reference/simple_stmts.rst:254
msgid "The specification for the ``*target`` feature."
msgstr "Specifikationen för funktionen ``*target``."

#: ../../reference/simple_stmts.rst:260
msgid "Augmented assignment statements"
msgstr "Utökade uppdragsbeskrivningar"

#: ../../reference/simple_stmts.rst:278
msgid ""
"Augmented assignment is the combination, in a single statement, of a binary "
"operation and an assignment statement:"
msgstr ""
"Augmented assignment är en kombination av en binär operation och en "
"assignment-sats i en och samma sats:"

#: ../../reference/simple_stmts.rst:287
msgid ""
"(See section :ref:`primaries` for the syntax definitions of the last three "
"symbols.)"
msgstr ""
"(Se avsnitt :ref:`primaries` för syntaxdefinitioner av de tre sista "
"symbolerna)"

#: ../../reference/simple_stmts.rst:290
msgid ""
"An augmented assignment evaluates the target (which, unlike normal "
"assignment statements, cannot be an unpacking) and the expression list, "
"performs the binary operation specific to the type of assignment on the two "
"operands, and assigns the result to the original target.  The target is only"
" evaluated once."
msgstr ""
"En utökad tilldelning utvärderar målet (som, till skillnad från normala "
"tilldelningssatser, inte kan vara en uppackning) och uttryckslistan, utför "
"den binära operation som är specifik för tilldelningstypen på de två "
"operanderna och tilldelar resultatet till det ursprungliga målet.  Målet "
"utvärderas bara en gång."

#: ../../reference/simple_stmts.rst:295
msgid ""
"An augmented assignment expression like ``x += 1`` can be rewritten as ``x ="
" x + 1`` to achieve a similar, but not exactly equal effect. In the "
"augmented version, ``x`` is only evaluated once. Also, when possible, the "
"actual operation is performed *in-place*, meaning that rather than creating "
"a new object and assigning that to the target, the old object is modified "
"instead."
msgstr ""

#: ../../reference/simple_stmts.rst:301
msgid ""
"Unlike normal assignments, augmented assignments evaluate the left-hand side"
" *before* evaluating the right-hand side.  For example, ``a[i] += f(x)`` "
"first looks-up ``a[i]``, then it evaluates ``f(x)`` and performs the "
"addition, and lastly, it writes the result back to ``a[i]``."
msgstr ""
"Till skillnad från normala uppdrag utvärderar utökade uppdrag vänstersidan "
"*innan* högersidan utvärderas.  Till exempel, ``a[i] += f(x)`` letar först "
"upp ``a[i]``, sedan utvärderar den ``f(x)`` och utför additionen, och "
"slutligen skriver den tillbaka resultatet till ``a[i]``."

#: ../../reference/simple_stmts.rst:306
msgid ""
"With the exception of assigning to tuples and multiple targets in a single "
"statement, the assignment done by augmented assignment statements is handled"
" the same way as normal assignments. Similarly, with the exception of the "
"possible *in-place* behavior, the binary operation performed by augmented "
"assignment is the same as the normal binary operations."
msgstr ""
"Med undantag för tilldelning till tupler och flera mål i en enda sats, "
"hanteras tilldelningen som utförs av augmented assignment-satser på samma "
"sätt som normala tilldelningar. På samma sätt, med undantag för det möjliga "
"*in-place*-beteendet, är den binära operation som utförs av augmented "
"assignment densamma som de normala binära operationerna."

#: ../../reference/simple_stmts.rst:312
msgid ""
"For targets which are attribute references, the same :ref:`caveat about "
"class and instance attributes <attr-target-note>` applies as for regular "
"assignments."
msgstr ""
"För mål som är attributreferenser gäller samma :ref:`avrådan om klass- och "
"instansattribut <attr-target-note>` som för vanliga uppdrag."

#: ../../reference/simple_stmts.rst:319
msgid "Annotated assignment statements"
msgstr "Kommenterade uppdragsbeskrivningar"

#: ../../reference/simple_stmts.rst:326
msgid ""
":term:`Annotation <variable annotation>` assignment is the combination, in a"
" single statement, of a variable or attribute annotation and an optional "
"assignment statement:"
msgstr ""
":term:`Annotation <variable annotation>` assignment är kombinationen, i en "
"enda sats, av en variabel- eller attributannotation och en valfri "
"assignment-sats:"

#: ../../reference/simple_stmts.rst:333
msgid ""
"The difference from normal :ref:`assignment` is that only a single target is"
" allowed."
msgstr ""
"Skillnaden mot normal :ref:`assignment` är att endast ett enda mål är "
"tillåtet."

#: ../../reference/simple_stmts.rst:335
msgid ""
"For simple names as assignment targets, if in class or module scope, the "
"annotations are evaluated and stored in a special class or module attribute "
":attr:`__annotations__` that is a dictionary mapping from variable names "
"(mangled if private) to evaluated annotations. This attribute is writable "
"and is automatically created at the start of class or module body execution,"
" if annotations are found statically."
msgstr ""

#: ../../reference/simple_stmts.rst:343
msgid ""
"For expressions as assignment targets, the annotations are evaluated if in "
"class or module scope, but not stored."
msgstr ""

#: ../../reference/simple_stmts.rst:346
msgid ""
"If a name is annotated in a function scope, then this name is local for that"
" scope. Annotations are never evaluated and stored in function scopes."
msgstr ""
"Om ett namn annoteras i ett funktionsomfång är namnet lokalt för detta "
"omfång. Annoteringar utvärderas och lagras aldrig i funktionsscopes."

#: ../../reference/simple_stmts.rst:349
msgid ""
"If the right hand side is present, an annotated assignment performs the "
"actual assignment before evaluating annotations (where applicable). If the "
"right hand side is not present for an expression target, then the "
"interpreter evaluates the target except for the last :meth:`__setitem__` or "
":meth:`__setattr__` call."
msgstr ""

#: ../../reference/simple_stmts.rst:360
msgid ":pep:`526` - Syntax for Variable Annotations"
msgstr ":pep:`526` - Syntax för variabelkommentarer"

#: ../../reference/simple_stmts.rst:358
msgid ""
"The proposal that added syntax for annotating the types of variables "
"(including class variables and instance variables), instead of expressing "
"them through comments."
msgstr ""
"Förslaget som lade till syntax för att kommentera typerna av variabler "
"(inklusive klassvariabler och instansvariabler), istället för att uttrycka "
"dem genom kommentarer."

#: ../../reference/simple_stmts.rst:364
msgid ":pep:`484` - Type hints"
msgstr ":pep:`484` - Typ av ledtrådar"

#: ../../reference/simple_stmts.rst:363
msgid ""
"The proposal that added the :mod:`typing` module to provide a standard "
"syntax for type annotations that can be used in static analysis tools and "
"IDEs."
msgstr ""
"Förslaget som lade till modulen :mod:`typing` för att tillhandahålla en "
"standardsyntax för typannoteringar som kan användas i verktyg för statisk "
"analys och IDE:er."

#: ../../reference/simple_stmts.rst:367
msgid ""
"Now annotated assignments allow the same expressions in the right hand side "
"as regular assignments. Previously, some expressions (like un-parenthesized "
"tuple expressions) caused a syntax error."
msgstr ""
"Nu tillåter annoterade uppdrag samma uttryck på höger sida som vanliga "
"uppdrag. Tidigare orsakade vissa uttryck (t.ex. tupeluttryck som inte var "
"föräldradefinierade) ett syntaxfel."

#: ../../reference/simple_stmts.rst:376
msgid "The :keyword:`!assert` statement"
msgstr ":keyword:`!assert`\\-satsen"

#: ../../reference/simple_stmts.rst:383
msgid ""
"Assert statements are a convenient way to insert debugging assertions into a"
" program:"
msgstr ""
"Assert-satser är ett bekvämt sätt att infoga felsökningssatser i ett "
"program:"

#: ../../reference/simple_stmts.rst:389
msgid "The simple form, ``assert expression``, is equivalent to ::"
msgstr "Den enkla formen, ``assert expression``, är likvärdig med ::"

#: ../../reference/simple_stmts.rst:394
msgid ""
"The extended form, ``assert expression1, expression2``, is equivalent to ::"
msgstr ""
"Den utökade formen, ``assert expression1, expression2``, är likvärdig med ::"

#: ../../reference/simple_stmts.rst:403
msgid ""
"These equivalences assume that :const:`__debug__` and :exc:`AssertionError` "
"refer to the built-in variables with those names.  In the current "
"implementation, the built-in variable :const:`__debug__` is ``True`` under "
"normal circumstances, ``False`` when optimization is requested (command line"
" option :option:`-O`).  The current code generator emits no code for an "
"assert statement when optimization is requested at compile time.  Note that "
"it is unnecessary to include the source code for the expression that failed "
"in the error message; it will be displayed as part of the stack trace."
msgstr ""

#: ../../reference/simple_stmts.rst:412
msgid ""
"Assignments to :const:`__debug__` are illegal.  The value for the built-in "
"variable is determined when the interpreter starts."
msgstr ""
"Tilldelningar till :const:`__debug__` är olagliga.  Värdet för den inbyggda "
"variabeln bestäms när tolken startar."

#: ../../reference/simple_stmts.rst:419
msgid "The :keyword:`!pass` statement"
msgstr ":keyword:`!pass`\\-satsen"

#: ../../reference/simple_stmts.rst:429
msgid ""
":keyword:`pass` is a null operation --- when it is executed, nothing "
"happens. It is useful as a placeholder when a statement is required "
"syntactically, but no code needs to be executed, for example::"
msgstr ""
":keyword:`pass` är en null operation --- när den utförs händer ingenting. "
"Det är användbart som en platshållare när ett uttalande krävs syntaktiskt, "
"men ingen kod behöver exekveras, till exempel::"

#: ../../reference/simple_stmts.rst:441
msgid "The :keyword:`!del` statement"
msgstr ":keyword:`!del`\\-satsen"

#: ../../reference/simple_stmts.rst:451
msgid ""
"Deletion is recursively defined very similar to the way assignment is "
"defined. Rather than spelling it out in full details, here are some hints."
msgstr ""
"Deletion definieras rekursivt på samma sätt som assignment definieras. I "
"stället för att beskriva det i detalj kommer här några ledtrådar."

#: ../../reference/simple_stmts.rst:454
msgid ""
"Deletion of a target list recursively deletes each target, from left to "
"right."
msgstr ""
"Radering av en mållista innebär att varje mål raderas rekursivt, från "
"vänster till höger."

#: ../../reference/simple_stmts.rst:460
msgid ""
"Deletion of a name removes the binding of that name from the local or global"
" namespace, depending on whether the name occurs in a :keyword:`global` "
"statement in the same code block.  If the name is unbound, a "
":exc:`NameError` exception will be raised."
msgstr ""
"Om ett namn raderas tas bindningen av namnet bort från den lokala eller "
"globala namnrymden, beroende på om namnet förekommer i en "
":keyword:`global`\\-sats i samma kodblock.  Om namnet är obundet kommer ett "
":exc:`NameError` undantag att uppstå."

#: ../../reference/simple_stmts.rst:467
msgid ""
"Deletion of attribute references, subscriptions and slicings is passed to "
"the primary object involved; deletion of a slicing is in general equivalent "
"to assignment of an empty slice of the right type (but even this is "
"determined by the sliced object)."
msgstr ""
"Radering av attributreferenser, prenumerationer och skivningar skickas till "
"det primära objekt som berörs; radering av en skivning är i allmänhet "
"likvärdig med tilldelning av en tom skivning av rätt typ (men även detta "
"bestäms av det skivade objektet)."

#: ../../reference/simple_stmts.rst:472
msgid ""
"Previously it was illegal to delete a name from the local namespace if it "
"occurs as a free variable in a nested block."
msgstr ""
"Tidigare var det olagligt att ta bort ett namn från den lokala namnrymden om"
" det förekom som en fri variabel i ett nästlat block."

#: ../../reference/simple_stmts.rst:480
msgid "The :keyword:`!return` statement"
msgstr "Nyckelordet: `!return`\\-satsen"

#: ../../reference/simple_stmts.rst:490
msgid ""
":keyword:`return` may only occur syntactically nested in a function "
"definition, not within a nested class definition."
msgstr ""
":keyword:`return` får endast förekomma syntaktiskt nästlad i en "
"funktionsdefinition, inte inom en nästlad klassdefinition."

#: ../../reference/simple_stmts.rst:493
msgid ""
"If an expression list is present, it is evaluated, else ``None`` is "
"substituted."
msgstr ""
"Om det finns en uttrycksförteckning utvärderas den, annars ersätts den med "
"``None``."

#: ../../reference/simple_stmts.rst:495
msgid ""
":keyword:`return` leaves the current function call with the expression list "
"(or ``None``) as return value."
msgstr ""
":keyword:`return` lämnar det aktuella funktionsanropet med "
"uttrycksförteckningen (eller ``None``) som returvärde."

#: ../../reference/simple_stmts.rst:500
msgid ""
"When :keyword:`return` passes control out of a :keyword:`try` statement with"
" a :keyword:`finally` clause, that :keyword:`!finally` clause is executed "
"before really leaving the function."
msgstr ""
"När :keyword:`return` skickar ut kontrollen från en :keyword:`try`\\-sats "
"med en :keyword:`finally`\\-sats, exekveras :keyword:`!finally`\\-satsen "
"innan funktionen verkligen lämnar funktionen."

#: ../../reference/simple_stmts.rst:504
msgid ""
"In a generator function, the :keyword:`return` statement indicates that the "
"generator is done and will cause :exc:`StopIteration` to be raised. The "
"returned value (if any) is used as an argument to construct "
":exc:`StopIteration` and becomes the :attr:`StopIteration.value` attribute."
msgstr ""
"I en generatorfunktion anger :keyword:`return` att generatorn är klar och "
"kommer att orsaka att :exc:`StopIteration` aktiveras. Det returnerade värdet"
" (om något) används som ett argument för att konstruera :exc:`StopIteration`"
" och blir attributet :attr:`StopIteration.value`."

#: ../../reference/simple_stmts.rst:509
msgid ""
"In an asynchronous generator function, an empty :keyword:`return` statement "
"indicates that the asynchronous generator is done and will cause "
":exc:`StopAsyncIteration` to be raised.  A non-empty :keyword:`!return` "
"statement is a syntax error in an asynchronous generator function."
msgstr ""
"I en asynkron generatorfunktion anger en tom :keyword:`return`\\-sats att "
"den asynkrona generatorn är klar och kommer att orsaka att "
":exc:`StopAsyncIteration` aktiveras.  En icke-tom :keyword:`!return`\\-sats "
"är ett syntaxfel i en asynkron generatorfunktion."

#: ../../reference/simple_stmts.rst:517
msgid "The :keyword:`!yield` statement"
msgstr ":keyword:`!yield`\\-satsen"

#: ../../reference/simple_stmts.rst:529
msgid ""
"A :keyword:`yield` statement is semantically equivalent to a :ref:`yield "
"expression <yieldexpr>`. The yield statement can be used to omit the "
"parentheses that would otherwise be required in the equivalent yield "
"expression statement. For example, the yield statements ::"
msgstr ""

#: ../../reference/simple_stmts.rst:537
msgid "are equivalent to the yield expression statements ::"
msgstr "är ekvivalenta med uttrycket yield statements ::"

#: ../../reference/simple_stmts.rst:542
msgid ""
"Yield expressions and statements are only used when defining a "
":term:`generator` function, and are only used in the body of the generator "
"function.  Using yield in a function definition is sufficient to cause that "
"definition to create a generator function instead of a normal function."
msgstr ""

#: ../../reference/simple_stmts.rst:547
msgid ""
"For full details of :keyword:`yield` semantics, refer to the "
":ref:`yieldexpr` section."
msgstr ""
"För fullständig information om :keyword:`yield` semantik, se avsnittet "
":ref:`yieldexpr`."

#: ../../reference/simple_stmts.rst:553
msgid "The :keyword:`!raise` statement"
msgstr ":keyword:`!raise`\\-satsen"

#: ../../reference/simple_stmts.rst:564
msgid ""
"If no expressions are present, :keyword:`raise` re-raises the exception that"
" is currently being handled, which is also known as the *active exception*. "
"If there isn't currently an active exception, a :exc:`RuntimeError` "
"exception is raised indicating that this is an error."
msgstr ""
"Om inga uttryck finns kommer :keyword:`raise` att återskapa det undantag som"
" för närvarande hanteras, vilket också kallas det *aktiva undantaget*. Om "
"det för närvarande inte finns något aktivt undantag, kommer ett "
":exc:`RuntimeError` undantag att uppstå som indikerar att detta är ett fel."

#: ../../reference/simple_stmts.rst:569
msgid ""
"Otherwise, :keyword:`raise` evaluates the first expression as the exception "
"object.  It must be either a subclass or an instance of "
":class:`BaseException`. If it is a class, the exception instance will be "
"obtained when needed by instantiating the class with no arguments."
msgstr ""
"Annars utvärderar :keyword:`raise` det första uttrycket som "
"undantagsobjektet.  Det måste vara antingen en underklass eller en instans "
"av :class:`BaseException`. Om det är en klass, kommer undantagsinstansen att"
" erhållas när det behövs genom att instansiera klassen utan argument."

#: ../../reference/simple_stmts.rst:574
msgid ""
"The :dfn:`type` of the exception is the exception instance's class, the "
":dfn:`value` is the instance itself."
msgstr ""
"Undantagets :dfn:`type` är undantagsinstansens klass, och :dfn:`value` är "
"själva instansen."

#: ../../reference/simple_stmts.rst:579
msgid ""
"A traceback object is normally created automatically when an exception is "
"raised and attached to it as the :attr:`__traceback__` attribute, which is "
"writable. You can create an exception and set your own traceback in one step"
" using the :meth:`~BaseException.with_traceback` exception method (which "
"returns the same exception instance, with its traceback set to its "
"argument), like so::"
msgstr ""

#: ../../reference/simple_stmts.rst:591
msgid ""
"The ``from`` clause is used for exception chaining: if given, the second "
"*expression* must be another exception class or instance. If the second "
"expression is an exception instance, it will be attached to the raised "
"exception as the :attr:`__cause__` attribute (which is writable). If the "
"expression is an exception class, the class will be instantiated and the "
"resulting exception instance will be attached to the raised exception as the"
" :attr:`__cause__` attribute. If the raised exception is not handled, both "
"exceptions will be printed::"
msgstr ""

#: ../../reference/simple_stmts.rst:615
msgid ""
"A similar mechanism works implicitly if a new exception is raised when an "
"exception is already being handled.  An exception may be handled when an "
":keyword:`except` or :keyword:`finally` clause, or a :keyword:`with` "
"statement, is used.  The previous exception is then attached as the new "
"exception's :attr:`__context__` attribute::"
msgstr ""

#: ../../reference/simple_stmts.rst:636
msgid ""
"Exception chaining can be explicitly suppressed by specifying :const:`None` "
"in the ``from`` clause::"
msgstr ""

#: ../../reference/simple_stmts.rst:648
msgid ""
"Additional information on exceptions can be found in section "
":ref:`exceptions`, and information about handling exceptions is in section "
":ref:`try`."
msgstr ""
"Ytterligare information om undantag finns i avsnitt :ref:`exceptions`, och "
"information om hantering av undantag finns i avsnitt :ref:`try`."

#: ../../reference/simple_stmts.rst:651
msgid ":const:`None` is now permitted as ``Y`` in ``raise X from Y``."
msgstr ":const:`None` är nu tillåtet som ``Y`` i ``raise X from Y``."

#: ../../reference/simple_stmts.rst:654
msgid ""
"The ``__suppress_context__`` attribute to suppress automatic display of the "
"exception context."
msgstr ""

#: ../../reference/simple_stmts.rst:661
msgid "The :keyword:`!break` statement"
msgstr ":keyword:`!break`\\-satsen"

#: ../../reference/simple_stmts.rst:672
msgid ""
":keyword:`break` may only occur syntactically nested in a :keyword:`for` or "
":keyword:`while` loop, but not nested in a function or class definition "
"within that loop."
msgstr ""
":keyword:`break` kan endast förekomma syntaktiskt inbäddad i en "
":keyword:`for`\\- eller :keyword:`while`\\-loop, men inte inbäddad i en "
"funktions- eller klassdefinition inom den loopen."

#: ../../reference/simple_stmts.rst:679
msgid ""
"It terminates the nearest enclosing loop, skipping the optional "
":keyword:`!else` clause if the loop has one."
msgstr ""
"Den avslutar den närmaste omslutande slingan och hoppar över den valfria "
":keyword:`!else`\\-satsen om slingan har en sådan."

#: ../../reference/simple_stmts.rst:682
msgid ""
"If a :keyword:`for` loop is terminated by :keyword:`break`, the loop control"
" target keeps its current value."
msgstr ""
"Om en :keyword:`for`\\-loop avslutas med :keyword:`break`, behåller loopens "
"kontrollmål sitt aktuella värde."

#: ../../reference/simple_stmts.rst:687
msgid ""
"When :keyword:`break` passes control out of a :keyword:`try` statement with "
"a :keyword:`finally` clause, that :keyword:`!finally` clause is executed "
"before really leaving the loop."
msgstr ""
"När :keyword:`break` skickar kontrollen ut ur en :keyword:`try`\\-sats med "
"en :keyword:`finally`\\-klausul, exekveras :keyword:`!finally`\\-klausulen "
"innan den lämnar slingan."

#: ../../reference/simple_stmts.rst:695
msgid "The :keyword:`!continue` statement"
msgstr "Nyckelordet: `!continue`\\-satsen"

#: ../../reference/simple_stmts.rst:707
msgid ""
":keyword:`continue` may only occur syntactically nested in a :keyword:`for` "
"or :keyword:`while` loop, but not nested in a function or class definition "
"within that loop.  It continues with the next cycle of the nearest enclosing"
" loop."
msgstr ""
":keyword:`continue` kan bara förekomma syntaktiskt inbäddad i en "
":keyword:`for` eller :keyword:`while`\\-loop, men inte inbäddad i en "
"funktions- eller klassdefinition inom den loopen.  Den fortsätter med nästa "
"cykel i den närmaste omslutande slingan."

#: ../../reference/simple_stmts.rst:711
msgid ""
"When :keyword:`continue` passes control out of a :keyword:`try` statement "
"with a :keyword:`finally` clause, that :keyword:`!finally` clause is "
"executed before really starting the next loop cycle."
msgstr ""
"När :keyword:`continue` skickar ut kontrollen från en :keyword:`try`\\-sats "
"med en :keyword:`finally`\\-klausul, utförs :keyword:`!finally`\\-klausulen "
"innan nästa loopcykel påbörjas."

#: ../../reference/simple_stmts.rst:720
msgid "The :keyword:`!import` statement"
msgstr "Nyckelordet: `!import`\\-satsen"

#: ../../reference/simple_stmts.rst:741
msgid ""
"The basic import statement (no :keyword:`from` clause) is executed in two "
"steps:"
msgstr ""
"Den grundläggande importsatsen (ingen :keyword:`from`\\-klausul) utförs i "
"två steg:"

#: ../../reference/simple_stmts.rst:744
msgid "find a module, loading and initializing it if necessary"
msgstr "hitta en modul, ladda och initiera den om det behövs"

#: ../../reference/simple_stmts.rst:745
msgid ""
"define a name or names in the local namespace for the scope where the "
":keyword:`import` statement occurs."
msgstr ""
"definiera ett eller flera namn i den lokala namnrymden för det scope där "
":keyword:`import`\\-satsen förekommer."

#: ../../reference/simple_stmts.rst:748
msgid ""
"When the statement contains multiple clauses (separated by commas) the two "
"steps are carried out separately for each clause, just as though the clauses"
" had been separated out into individual import statements."
msgstr ""
"Om deklarationen innehåller flera klausuler (åtskilda med kommatecken) "
"utförs de två stegen separat för varje klausul, precis som om klausulerna "
"hade varit uppdelade i enskilda importdeklarationer."

#: ../../reference/simple_stmts.rst:753
msgid ""
"The details of the first step, finding and loading modules, are described in"
" greater detail in the section on the :ref:`import system <importsystem>`, "
"which also describes the various types of packages and modules that can be "
"imported, as well as all the hooks that can be used to customize the import "
"system. Note that failures in this step may indicate either that the module "
"could not be located, *or* that an error occurred while initializing the "
"module, which includes execution of the module's code."
msgstr ""
"Detaljerna i det första steget, att hitta och ladda moduler, beskrivs mer "
"ingående i avsnittet om :ref:`import system <importsystem>`, där även de "
"olika typerna av paket och moduler som kan importeras beskrivs, liksom alla "
"de hooks som kan användas för att anpassa importsystemet. Observera att fel "
"i det här steget antingen kan bero på att modulen inte kunde hittas, *eller*"
" att ett fel inträffade under initieringen av modulen, vilket inkluderar "
"exekvering av modulens kod."

#: ../../reference/simple_stmts.rst:761
msgid ""
"If the requested module is retrieved successfully, it will be made available"
" in the local namespace in one of three ways:"
msgstr ""
"Om den begärda modulen hämtas framgångsrikt kommer den att göras tillgänglig"
" i det lokala namnrymden på ett av tre sätt:"

#: ../../reference/simple_stmts.rst:766
msgid ""
"If the module name is followed by :keyword:`!as`, then the name following "
":keyword:`!as` is bound directly to the imported module."
msgstr ""
"Om modulnamnet följs av :keyword:`!as`, så är namnet som följer efter "
":keyword:`!as` bundet direkt till den importerade modulen."

#: ../../reference/simple_stmts.rst:768
msgid ""
"If no other name is specified, and the module being imported is a top level "
"module, the module's name is bound in the local namespace as a reference to "
"the imported module"
msgstr ""
"Om inget annat namn anges och den modul som importeras är en modul på högsta"
" nivån, binds modulens namn i det lokala namnrymden som en referens till den"
" importerade modulen"

#: ../../reference/simple_stmts.rst:771
msgid ""
"If the module being imported is *not* a top level module, then the name of "
"the top level package that contains the module is bound in the local "
"namespace as a reference to the top level package. The imported module must "
"be accessed using its full qualified name rather than directly"
msgstr ""
"Om den modul som importeras *inte* är en toppnivåmodul, binds namnet på det "
"toppnivåpaket som innehåller modulen i den lokala namnrymden som en referens"
" till toppnivåpaketet. Den importerade modulen måste nås med hjälp av dess "
"fullständiga kvalificerade namn i stället för direkt"

#: ../../reference/simple_stmts.rst:781
msgid "The :keyword:`from` form uses a slightly more complex process:"
msgstr "I formuläret :keyword:`from` används en något mer komplex process:"

#: ../../reference/simple_stmts.rst:783
msgid ""
"find the module specified in the :keyword:`from` clause, loading and "
"initializing it if necessary;"
msgstr ""
"hittar den modul som anges i :keyword:`from`\\-satsen, laddar och initierar "
"den vid behov;"

#: ../../reference/simple_stmts.rst:785
msgid ""
"for each of the identifiers specified in the :keyword:`import` clauses:"
msgstr ""
"för var och en av de identifierare som anges i "
":keyword:`import`\\-klausulerna:"

#: ../../reference/simple_stmts.rst:787
msgid "check if the imported module has an attribute by that name"
msgstr ""
"kontrollera om den importerade modulen har ett attribut med det namnet"

#: ../../reference/simple_stmts.rst:788
msgid ""
"if not, attempt to import a submodule with that name and then check the "
"imported module again for that attribute"
msgstr ""
"om inte, försök att importera en undermodul med det namnet och kontrollera "
"sedan den importerade modulen igen för det attributet"

#: ../../reference/simple_stmts.rst:790
msgid "if the attribute is not found, :exc:`ImportError` is raised."
msgstr "om attributet inte hittas, uppstår :exc:`ImportError`."

#: ../../reference/simple_stmts.rst:791
msgid ""
"otherwise, a reference to that value is stored in the local namespace, using"
" the name in the :keyword:`!as` clause if it is present, otherwise using the"
" attribute name"
msgstr ""
"annars lagras en referens till värdet i den lokala namnrymden med hjälp av "
"namnet i :keyword:`!as`\\-satsen om det finns, annars med hjälp av "
"attributnamnet"

#: ../../reference/simple_stmts.rst:795
msgid "Examples::"
msgstr "Exempel::"

#: ../../reference/simple_stmts.rst:805
msgid ""
"If the list of identifiers is replaced by a star (``'*'``), all public names"
" defined in the module are bound in the local namespace for the scope where "
"the :keyword:`import` statement occurs."
msgstr ""
"Om listan med identifierare ersätts av en stjärna (``'*'``), binds alla "
"publika namn som definieras i modulen i den lokala namnrymden för det scope "
"där :keyword:`import`\\-satsen förekommer."

#: ../../reference/simple_stmts.rst:811
msgid ""
"The *public names* defined by a module are determined by checking the "
"module's namespace for a variable named ``__all__``; if defined, it must be "
"a sequence of strings which are names defined or imported by that module.  "
"The names given in ``__all__`` are all considered public and are required to"
" exist.  If ``__all__`` is not defined, the set of public names includes all"
" names found in the module's namespace which do not begin with an underscore"
" character (``'_'``).  ``__all__`` should contain the entire public API. It "
"is intended to avoid accidentally exporting items that are not part of the "
"API (such as library modules which were imported and used within the "
"module)."
msgstr ""
"De *publika namn* som definieras av en modul bestäms genom att kontrollera "
"modulens namnrymd för en variabel som heter ``__all__``; om den definieras "
"måste den vara en sekvens av strängar som är namn som definieras eller "
"importeras av den modulen.  De namn som anges i ``__all__`` anses alla vara "
"publika och måste existera.  Om ``__all__`` inte är definierat, inkluderar "
"uppsättningen av publika namn alla namn som finns i modulens namnrymd och "
"som inte börjar med ett understreck (``'_'``).  ``__all__`` bör innehålla "
"hela det publika API:et. Syftet är att undvika oavsiktlig export av objekt "
"som inte är en del av API:et (t.ex. biblioteksmoduler som importerats och "
"används i modulen)."

#: ../../reference/simple_stmts.rst:821
msgid ""
"The wild card form of import --- ``from module import *`` --- is only "
"allowed at the module level.  Attempting to use it in class or function "
"definitions will raise a :exc:`SyntaxError`."
msgstr ""
"Jokerteckenformen av import --- ``from module import *`` --- är endast "
"tillåten på modulnivå.  Försök att använda den i klass- eller "
"funktionsdefinitioner kommer att ge upphov till ett :exc:`SyntaxError`."

#: ../../reference/simple_stmts.rst:828
msgid ""
"When specifying what module to import you do not have to specify the "
"absolute name of the module. When a module or package is contained within "
"another package it is possible to make a relative import within the same top"
" package without having to mention the package name. By using leading dots "
"in the specified module or package after :keyword:`from` you can specify how"
" high to traverse up the current package hierarchy without specifying exact "
"names. One leading dot means the current package where the module making the"
" import exists. Two dots means up one package level. Three dots is up two "
"levels, etc. So if you execute ``from . import mod`` from a module in the "
"``pkg`` package then you will end up importing ``pkg.mod``. If you execute "
"``from ..subpkg2 import mod`` from within ``pkg.subpkg1`` you will import "
"``pkg.subpkg2.mod``. The specification for relative imports is contained in "
"the :ref:`relativeimports` section."
msgstr ""
"När du anger vilken modul som ska importeras behöver du inte ange modulens "
"absoluta namn. När en modul eller ett paket ingår i ett annat paket är det "
"möjligt att göra en relativ import inom samma topp-paket utan att behöva "
"nämna paketnamnet. Genom att använda ledande punkter i den angivna modulen "
"eller paketet efter :keyword:`from` kan du ange hur högt upp i den aktuella "
"pakethierarkin du ska gå utan att ange exakta namn. En ledande prick betyder"
" det aktuella paketet där modulen som gör importen finns. Två punkter "
"innebär en paketnivå uppåt. Tre punkter är två nivåer högre, osv. Så om du "
"kör ``from . import mod`` från en modul i paketet ``pkg`` kommer du att "
"importera ``pkg.mod``. Om du exekverar ``from ..subpkg2 import mod`` från "
"``pkg.subpkg1`` kommer du att importera ``pkg.subpkg2.mod``. Specifikationen"
" för relativ import finns i avsnittet :ref:`relativeimports`."

#: ../../reference/simple_stmts.rst:842
msgid ""
":func:`importlib.import_module` is provided to support applications that "
"determine dynamically the modules to be loaded."
msgstr ""
":func:`importlib.import_module` tillhandahålls för att stödja applikationer "
"som dynamiskt bestämmer vilka moduler som ska laddas."

#: ../../reference/simple_stmts.rst:845
msgid ""
"Raises an :ref:`auditing event <auditing>` ``import`` with arguments "
"``module``, ``filename``, ``sys.path``, ``sys.meta_path``, "
"``sys.path_hooks``."
msgstr ""
"Skapar en :ref:`auditing event <auditing>` ``import`` med argumenten "
"``module``, ``filename``, ``sys.path``, ``sys.meta_path``, "
"``sys.path_hooks``."

#: ../../reference/simple_stmts.rst:850
msgid "Future statements"
msgstr "Framtida uttalanden"

#: ../../reference/simple_stmts.rst:856
msgid ""
"A :dfn:`future statement` is a directive to the compiler that a particular "
"module should be compiled using syntax or semantics that will be available "
"in a specified future release of Python where the feature becomes standard."
msgstr ""
"En :dfn:`future statement` är ett direktiv till kompilatorn att en viss "
"modul ska kompileras med syntax eller semantik som kommer att finnas "
"tillgänglig i en specificerad framtida version av Python där funktionen blir"
" standard."

#: ../../reference/simple_stmts.rst:860
msgid ""
"The future statement is intended to ease migration to future versions of "
"Python that introduce incompatible changes to the language.  It allows use "
"of the new features on a per-module basis before the release in which the "
"feature becomes standard."
msgstr ""
"Future Statement är avsett att underlätta migrering till framtida versioner "
"av Python som introducerar inkompatibla förändringar av språket.  Det "
"tillåter användning av de nya funktionerna per modul innan den version där "
"funktionen blir standard."

#: ../../reference/simple_stmts.rst:872
msgid ""
"A future statement must appear near the top of the module.  The only lines "
"that can appear before a future statement are:"
msgstr ""
"En framtidsförklaring måste stå längst upp i modulen.  De enda rader som kan"
" förekomma före en framtidsförklaring är:"

#: ../../reference/simple_stmts.rst:875
msgid "the module docstring (if any),"
msgstr "modulens dokumentsträng (om sådan finns),"

#: ../../reference/simple_stmts.rst:876
msgid "comments,"
msgstr "kommentarer,"

#: ../../reference/simple_stmts.rst:877
msgid "blank lines, and"
msgstr "tomma rader och"

#: ../../reference/simple_stmts.rst:878
msgid "other future statements."
msgstr "andra framtida uttalanden."

#: ../../reference/simple_stmts.rst:880
msgid ""
"The only feature that requires using the future statement is ``annotations``"
" (see :pep:`563`)."
msgstr ""
"Den enda funktion som kräver användning av future statement är "
"``annotations`` (se :pep:`563`)."

#: ../../reference/simple_stmts.rst:883
msgid ""
"All historical features enabled by the future statement are still recognized"
" by Python 3.  The list includes ``absolute_import``, ``division``, "
"``generators``, ``generator_stop``, ``unicode_literals``, "
"``print_function``, ``nested_scopes`` and ``with_statement``.  They are all "
"redundant because they are always enabled, and only kept for backwards "
"compatibility."
msgstr ""
"Alla historiska funktioner som aktiveras av future statement känns "
"fortfarande igen av Python 3.  Listan inkluderar ``absolute_import``, "
"``division``, ``generators``, ``generator_stop``, ``unicode_literals``, "
"``print_function``, ``nested_scopes`` och ``with_statement``.  De är alla "
"överflödiga eftersom de alltid är aktiverade och endast behålls för "
"bakåtkompatibilitet."

#: ../../reference/simple_stmts.rst:890
msgid ""
"A future statement is recognized and treated specially at compile time: "
"Changes to the semantics of core constructs are often implemented by "
"generating different code.  It may even be the case that a new feature "
"introduces new incompatible syntax (such as a new reserved word), in which "
"case the compiler may need to parse the module differently.  Such decisions "
"cannot be pushed off until runtime."
msgstr ""
"Ett framtida uttalande identifieras och behandlas speciellt vid "
"kompileringstillfället: Ändringar i semantiken för kärnkonstruktioner "
"implementeras ofta genom att annan kod genereras.  Det kan till och med vara"
" så att en ny funktion introducerar ny inkompatibel syntax (t.ex. ett nytt "
"reserverat ord), i vilket fall kompilatorn kan behöva analysera modulen på "
"ett annat sätt.  Sådana beslut kan inte skjutas upp till runtime."

#: ../../reference/simple_stmts.rst:897
msgid ""
"For any given release, the compiler knows which feature names have been "
"defined, and raises a compile-time error if a future statement contains a "
"feature not known to it."
msgstr ""
"För varje given version vet kompilatorn vilka funktionsnamn som har "
"definierats och ger upphov till ett fel vid kompilering om ett framtida "
"uttalande innehåller en funktion som kompilatorn inte känner till."

#: ../../reference/simple_stmts.rst:901
msgid ""
"The direct runtime semantics are the same as for any import statement: there"
" is a standard module :mod:`__future__`, described later, and it will be "
"imported in the usual way at the time the future statement is executed."
msgstr ""
"Den direkta körtidssemantiken är densamma som för alla import-satser: det "
"finns en standardmodul :mod:`__future__`, som beskrivs senare, och den "
"kommer att importeras på vanligt sätt när future-satsen exekveras."

#: ../../reference/simple_stmts.rst:905
msgid ""
"The interesting runtime semantics depend on the specific feature enabled by "
"the future statement."
msgstr ""
"Den intressanta semantiken för körtiden beror på den specifika funktion som "
"möjliggörs av framtidsuttalandet."

#: ../../reference/simple_stmts.rst:908
msgid "Note that there is nothing special about the statement::"
msgstr "Observera att det inte finns något speciellt med uttalandet::"

#: ../../reference/simple_stmts.rst:912
msgid ""
"That is not a future statement; it's an ordinary import statement with no "
"special semantics or syntax restrictions."
msgstr ""
"Det är inte en future-sats, utan en vanlig import-sats utan någon speciell "
"semantik eller syntaxrestriktioner."

#: ../../reference/simple_stmts.rst:915
msgid ""
"Code compiled by calls to the built-in functions :func:`exec` and "
":func:`compile` that occur in a module :mod:`M` containing a future "
"statement will, by default, use the new syntax or semantics associated with "
"the future statement.  This can be controlled by optional arguments to "
":func:`compile` --- see the documentation of that function for details."
msgstr ""

#: ../../reference/simple_stmts.rst:921
msgid ""
"A future statement typed at an interactive interpreter prompt will take "
"effect for the rest of the interpreter session.  If an interpreter is "
"started with the :option:`-i` option, is passed a script name to execute, "
"and the script includes a future statement, it will be in effect in the "
"interactive session started after the script is executed."
msgstr ""
"En future-sats som skrivs vid en interaktiv tolks prompt kommer att gälla "
"under resten av tolksessionen.  Om en tolk startas med alternativet "
":option:`\\-i`, får ett skriptnamn som ska exekveras och skriptet innehåller"
" en future-sats, kommer den att gälla i den interaktiva session som startas "
"efter att skriptet har exekverats."

#: ../../reference/simple_stmts.rst:929
msgid ":pep:`236` - Back to the __future__"
msgstr ":pep:`236` - Tillbaka till __future__"

#: ../../reference/simple_stmts.rst:930
msgid "The original proposal for the __future__ mechanism."
msgstr "Det ursprungliga förslaget till mekanismen __future__."

#: ../../reference/simple_stmts.rst:936
msgid "The :keyword:`!global` statement"
msgstr ":keyword:`!global`\\-satsen"

#: ../../reference/simple_stmts.rst:946
msgid ""
"The :keyword:`global` statement is a declaration which holds for the entire "
"current code block.  It means that the listed identifiers are to be "
"interpreted as globals.  It would be impossible to assign to a global "
"variable without :keyword:`!global`, although free variables may refer to "
"globals without being declared global."
msgstr ""

#: ../../reference/simple_stmts.rst:952
msgid ""
"Names listed in a :keyword:`global` statement must not be used in the same "
"code block textually preceding that :keyword:`!global` statement."
msgstr ""

#: ../../reference/simple_stmts.rst:955
msgid ""
"Names listed in a :keyword:`global` statement must not be defined as formal "
"parameters, or as targets in :keyword:`with` statements or :keyword:`except`"
" clauses, or in a :keyword:`for` target list, :keyword:`class` definition, "
"function definition, :keyword:`import` statement, or variable annotation."
msgstr ""

#: ../../reference/simple_stmts.rst:962
msgid ""
"The current implementation does not enforce some of these restrictions, but "
"programs should not abuse this freedom, as future implementations may "
"enforce them or silently change the meaning of the program."
msgstr ""

#: ../../reference/simple_stmts.rst:971
msgid ""
"**Programmer's note:** :keyword:`global` is a directive to the parser.  It "
"applies only to code parsed at the same time as the :keyword:`!global` "
"statement. In particular, a :keyword:`!global` statement contained in a "
"string or code object supplied to the built-in :func:`exec` function does "
"not affect the code block *containing* the function call, and code contained"
" in such a string is unaffected by :keyword:`!global` statements in the code"
" containing the function call.  The same applies to the :func:`eval` and "
":func:`compile` functions."
msgstr ""
"**Programmerarens anmärkning:** :keyword:`global` är ett direktiv till "
"parsern.  Det gäller endast för kod som analyseras samtidigt som "
":keyword:`!global`\\-satsen. I synnerhet påverkar inte en "
":keyword:`!global`\\-sats som ingår i en sträng eller ett kodobjekt som "
"levereras till den inbyggda funktionen :func:`exec` kodblocket som "
"*innehåller* funktionsanropet, och kod som ingår i en sådan sträng påverkas "
"inte av :keyword:`!global`\\-satser i koden som innehåller funktionsanropet."
"  Detsamma gäller för funktionerna :func:`eval` och :func:`compile`."

#: ../../reference/simple_stmts.rst:983
msgid "The :keyword:`!nonlocal` statement"
msgstr ":keyword:`!nonlocal`\\-satsen"

#: ../../reference/simple_stmts.rst:991
msgid ""
"The :keyword:`nonlocal` statement causes the listed identifiers to refer to "
"previously bound variables in the nearest enclosing scope excluding globals."
" This is important because the default behavior for binding is to search the"
" local namespace first.  The statement allows encapsulated code to rebind "
"variables outside of the local scope besides the global (module) scope."
msgstr ""

#: ../../reference/simple_stmts.rst:997
msgid ""
"Names listed in a :keyword:`nonlocal` statement, unlike those listed in a "
":keyword:`global` statement, must refer to pre-existing bindings in an "
"enclosing scope (the scope in which a new binding should be created cannot "
"be determined unambiguously)."
msgstr ""

#: ../../reference/simple_stmts.rst:1002
msgid ""
"Names listed in a :keyword:`nonlocal` statement must not collide with pre-"
"existing bindings in the local scope."
msgstr ""

#: ../../reference/simple_stmts.rst:1007
msgid ":pep:`3104` - Access to Names in Outer Scopes"
msgstr ":pep:`3104` - Åtkomst till namn i ytterområden (Outer Scopes)"

#: ../../reference/simple_stmts.rst:1008
msgid "The specification for the :keyword:`nonlocal` statement."
msgstr "Specifikationen för :keyword:`nonlocal` statement."
