# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-17 17:19+0000\n"
"PO-Revision-Date: 2025-09-22 15:58+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../reference/lexical_analysis.rst:6
msgid "Lexical analysis"
msgstr "Lexikalisk analys"

#: ../../reference/lexical_analysis.rst:10
msgid ""
"A Python program is read by a *parser*.  Input to the parser is a stream of "
"*tokens*, generated by the *lexical analyzer*.  This chapter describes how "
"the lexical analyzer breaks a file into tokens."
msgstr ""

#: ../../reference/lexical_analysis.rst:14
msgid ""
"Python reads program text as Unicode code points; the encoding of a source "
"file can be given by an encoding declaration and defaults to UTF-8, see :pep:"
"`3120` for details.  If the source file cannot be decoded, a :exc:"
"`SyntaxError` is raised."
msgstr ""
"Python läser programtext som Unicode-kodpunkter; kodningen av en källfil kan "
"anges med en kodningsdeklaration och standardvärdet är UTF-8, se :pep:`3120` "
"för detaljer.  Om källfilen inte kan avkodas uppstår ett :exc:`SyntaxError`."

#: ../../reference/lexical_analysis.rst:23
msgid "Line structure"
msgstr "Linjestruktur"

#: ../../reference/lexical_analysis.rst:27
msgid "A Python program is divided into a number of *logical lines*."
msgstr "Ett Python-program är indelat i ett antal *logiska rader*."

#: ../../reference/lexical_analysis.rst:33
msgid "Logical lines"
msgstr "Logiska linjer"

#: ../../reference/lexical_analysis.rst:37
msgid ""
"The end of a logical line is represented by the token NEWLINE.  Statements "
"cannot cross logical line boundaries except where NEWLINE is allowed by the "
"syntax (e.g., between statements in compound statements). A logical line is "
"constructed from one or more *physical lines* by following the explicit or "
"implicit *line joining* rules."
msgstr ""

#: ../../reference/lexical_analysis.rst:47
msgid "Physical lines"
msgstr "Fysiska linjer"

#: ../../reference/lexical_analysis.rst:49
msgid ""
"A physical line is a sequence of characters terminated by an end-of-line "
"sequence.  In source files and strings, any of the standard platform line "
"termination sequences can be used - the Unix form using ASCII LF (linefeed), "
"the Windows form using the ASCII sequence CR LF (return followed by "
"linefeed), or the old Macintosh form using the ASCII CR (return) character.  "
"All of these forms can be used equally, regardless of platform. The end of "
"input also serves as an implicit terminator for the final physical line."
msgstr ""

#: ../../reference/lexical_analysis.rst:57
msgid ""
"When embedding Python, source code strings should be passed to Python APIs "
"using the standard C conventions for newline characters (the ``\\n`` "
"character, representing ASCII LF, is the line terminator)."
msgstr ""

#: ../../reference/lexical_analysis.rst:65
msgid "Comments"
msgstr "Kommentarer"

#: ../../reference/lexical_analysis.rst:70
msgid ""
"A comment starts with a hash character (``#``) that is not part of a string "
"literal, and ends at the end of the physical line.  A comment signifies the "
"end of the logical line unless the implicit line joining rules are invoked. "
"Comments are ignored by the syntax."
msgstr ""
"En kommentar börjar med ett hash-tecken (``#``) som inte är en del av en "
"bokstavlig sträng och slutar vid slutet av den fysiska raden.  En kommentar "
"innebär slutet på den logiska raden om inte de implicita reglerna för "
"radförlängning används. Kommentarer ignoreras av syntaxen."

#: ../../reference/lexical_analysis.rst:79
msgid "Encoding declarations"
msgstr "Deklarationer för kodning"

#: ../../reference/lexical_analysis.rst:84
msgid ""
"If a comment in the first or second line of the Python script matches the "
"regular expression ``coding[=:]\\s*([-\\w.]+)``, this comment is processed "
"as an encoding declaration; the first group of this expression names the "
"encoding of the source code file. The encoding declaration must appear on a "
"line of its own. If it is the second line, the first line must also be a "
"comment-only line. The recommended forms of an encoding expression are ::"
msgstr ""
"Om en kommentar på den första eller andra raden i Python-skriptet matchar "
"det reguljära uttrycket ``coding[=:]\\s*([-\\w.]+)``, behandlas denna "
"kommentar som en kodningsdeklaration; den första gruppen i detta uttryck "
"anger kodningen för källkodsfilen. Kodningsdeklarationen måste stå på en "
"egen rad. Om det är den andra raden, måste den första raden också vara en "
"rad med enbart kommentarer. De rekommenderade formerna för ett "
"kodningsuttryck är ::"

#: ../../reference/lexical_analysis.rst:93
msgid "which is recognized also by GNU Emacs, and ::"
msgstr "som också känns igen av GNU Emacs, och ::"

#: ../../reference/lexical_analysis.rst:97
msgid "which is recognized by Bram Moolenaar's VIM."
msgstr "som är erkänd av Bram Moolenaars VIM."

#: ../../reference/lexical_analysis.rst:99
msgid ""
"If no encoding declaration is found, the default encoding is UTF-8.  In "
"addition, if the first bytes of the file are the UTF-8 byte-order mark "
"(``b'\\xef\\xbb\\xbf'``), the declared file encoding is UTF-8 (this is "
"supported, among others, by Microsoft's :program:`notepad`)."
msgstr ""

#: ../../reference/lexical_analysis.rst:104
msgid ""
"If an encoding is declared, the encoding name must be recognized by Python "
"(see :ref:`standard-encodings`). The encoding is used for all lexical "
"analysis, including string literals, comments and identifiers."
msgstr ""
"Om en kodning deklareras, måste kodningsnamnet kännas igen av Python (se :"
"ref:`standard-encodings`). Kodningen används för all lexikal analys, "
"inklusive stränglitteraler, kommentarer och identifierare."

#: ../../reference/lexical_analysis.rst:113
msgid "Explicit line joining"
msgstr "Explicit sammanfogning av linjer"

#: ../../reference/lexical_analysis.rst:117
msgid ""
"Two or more physical lines may be joined into logical lines using backslash "
"characters (``\\``), as follows: when a physical line ends in a backslash "
"that is not part of a string literal or comment, it is joined with the "
"following forming a single logical line, deleting the backslash and the "
"following end-of-line character.  For example::"
msgstr ""
"Två eller flera fysiska rader kan sammanfogas till logiska rader med hjälp "
"av backslash-tecken (``\\``) enligt följande: När en fysisk rad slutar med "
"ett backslash-tecken som inte är en del av en bokstavlig sträng eller en "
"kommentar, sammanfogas den med den följande och bildar en enda logisk rad, "
"varvid backslash-tecknet och det följande radslutstecknet tas bort.  Till "
"exempel::"

#: ../../reference/lexical_analysis.rst:128
msgid ""
"A line ending in a backslash cannot carry a comment.  A backslash does not "
"continue a comment.  A backslash does not continue a token except for string "
"literals (i.e., tokens other than string literals cannot be split across "
"physical lines using a backslash).  A backslash is illegal elsewhere on a "
"line outside a string literal."
msgstr ""
"En rad som slutar med ett backslash kan inte innehålla en kommentar.  En "
"backslash fortsätter inte en kommentar.  En backslash fortsätter inte en "
"token utom för stränglitteraler (dvs. andra tokens än stränglitteraler kan "
"inte delas över fysiska rader med hjälp av en backslash).  Ett backslash är "
"olagligt på andra ställen på en rad utanför en stränglitteral."

#: ../../reference/lexical_analysis.rst:138
msgid "Implicit line joining"
msgstr "Implicit sammanfogning av linjer"

#: ../../reference/lexical_analysis.rst:140
msgid ""
"Expressions in parentheses, square brackets or curly braces can be split "
"over more than one physical line without using backslashes. For example::"
msgstr ""
"Uttryck inom parenteser, hakparenteser eller hakklamrar kan delas upp på mer "
"än en fysisk rad utan att använda bindestreck. Till exempel::"

#: ../../reference/lexical_analysis.rst:148
msgid ""
"Implicitly continued lines can carry comments.  The indentation of the "
"continuation lines is not important.  Blank continuation lines are allowed. "
"There is no NEWLINE token between implicit continuation lines.  Implicitly "
"continued lines can also occur within triple-quoted strings (see below); in "
"that case they cannot carry comments."
msgstr ""
"Implicit fortsatta rader kan innehålla kommentarer.  Indraget på "
"fortsättningsraderna är inte viktigt.  Tomma fortsättningsrader är tillåtna. "
"Det finns ingen NEWLINE-token mellan implicita fortsättningsrader.  Implicit "
"fortsatta rader kan också förekomma inom trippelciterade strängar (se "
"nedan); i så fall kan de inte innehålla kommentarer."

#: ../../reference/lexical_analysis.rst:158
msgid "Blank lines"
msgstr "Tomma rader"

#: ../../reference/lexical_analysis.rst:162
msgid ""
"A logical line that contains only spaces, tabs, formfeeds and possibly a "
"comment, is ignored (i.e., no NEWLINE token is generated).  During "
"interactive input of statements, handling of a blank line may differ "
"depending on the implementation of the read-eval-print loop.  In the "
"standard interactive interpreter, an entirely blank logical line (i.e. one "
"containing not even whitespace or a comment) terminates a multi-line "
"statement."
msgstr ""

#: ../../reference/lexical_analysis.rst:173
msgid "Indentation"
msgstr "Indrag"

#: ../../reference/lexical_analysis.rst:177
msgid ""
"Leading whitespace (spaces and tabs) at the beginning of a logical line is "
"used to compute the indentation level of the line, which in turn is used to "
"determine the grouping of statements."
msgstr ""
"Ledande blanksteg (mellanslag och tabbar) i början av en logisk rad används "
"för att beräkna indragningsnivån på raden, som i sin tur används för att "
"bestämma grupperingen av satser."

#: ../../reference/lexical_analysis.rst:181
msgid ""
"Tabs are replaced (from left to right) by one to eight spaces such that the "
"total number of characters up to and including the replacement is a multiple "
"of eight (this is intended to be the same rule as used by Unix).  The total "
"number of spaces preceding the first non-blank character then determines the "
"line's indentation.  Indentation cannot be split over multiple physical "
"lines using backslashes; the whitespace up to the first backslash determines "
"the indentation."
msgstr ""
"Tabbar ersätts (från vänster till höger) med ett till åtta mellanslag så att "
"det totala antalet tecken fram till och med ersättningen är en multipel av "
"åtta (detta är tänkt att vara samma regel som används av Unix).  Det totala "
"antalet mellanslag före det första tecknet som inte är blankt avgör sedan "
"radens indrag.  Indrag kan inte delas upp på flera fysiska rader med hjälp "
"av backslash; blanksteg fram till första backslash bestämmer indraget."

#: ../../reference/lexical_analysis.rst:189
msgid ""
"Indentation is rejected as inconsistent if a source file mixes tabs and "
"spaces in a way that makes the meaning dependent on the worth of a tab in "
"spaces; a :exc:`TabError` is raised in that case."
msgstr ""
"Indragning avvisas som inkonsekvent om en källfil blandar tabbar och "
"mellanslag på ett sätt som gör att betydelsen är beroende av värdet av en "
"tabb i mellanslag; ett :exc:`TabError` uppstår i så fall."

#: ../../reference/lexical_analysis.rst:193
msgid ""
"**Cross-platform compatibility note:** because of the nature of text editors "
"on non-UNIX platforms, it is unwise to use a mixture of spaces and tabs for "
"the indentation in a single source file.  It should also be noted that "
"different platforms may explicitly limit the maximum indentation level."
msgstr ""
"**Kompatibilitet mellan plattformar:** På grund av textredigerare på andra "
"plattformar än UNIX är det oklokt att använda en blandning av mellanslag och "
"tabbar för indragning i en och samma källfil.  Det bör också noteras att "
"olika plattformar uttryckligen kan begränsa den maximala indragningsnivån."

#: ../../reference/lexical_analysis.rst:198
msgid ""
"A formfeed character may be present at the start of the line; it will be "
"ignored for the indentation calculations above.  Formfeed characters "
"occurring elsewhere in the leading whitespace have an undefined effect (for "
"instance, they may reset the space count to zero)."
msgstr ""
"Ett formfeed-tecken kan finnas i början av raden; det kommer att ignoreras "
"vid indragningsberäkningarna ovan.  Formfeed-tecken som förekommer på andra "
"ställen i det inledande blanksteget har en odefinierad effekt (de kan t.ex. "
"återställa blankstegsräkningen till noll)."

#: ../../reference/lexical_analysis.rst:205
msgid ""
"The indentation levels of consecutive lines are used to generate INDENT and "
"DEDENT tokens, using a stack, as follows."
msgstr ""

#: ../../reference/lexical_analysis.rst:208
msgid ""
"Before the first line of the file is read, a single zero is pushed on the "
"stack; this will never be popped off again.  The numbers pushed on the stack "
"will always be strictly increasing from bottom to top.  At the beginning of "
"each logical line, the line's indentation level is compared to the top of "
"the stack. If it is equal, nothing happens. If it is larger, it is pushed on "
"the stack, and one INDENT token is generated.  If it is smaller, it *must* "
"be one of the numbers occurring on the stack; all numbers on the stack that "
"are larger are popped off, and for each number popped off a DEDENT token is "
"generated.  At the end of the file, a DEDENT token is generated for each "
"number remaining on the stack that is larger than zero."
msgstr ""

#: ../../reference/lexical_analysis.rst:219
msgid ""
"Here is an example of a correctly (though confusingly) indented piece of "
"Python code::"
msgstr ""
"Här är ett exempel på en korrekt (men förvirrande) indragen bit Python-kod::"

#: ../../reference/lexical_analysis.rst:234
msgid "The following example shows various indentation errors::"
msgstr "Följande exempel visar olika indragningsfel::"

#: ../../reference/lexical_analysis.rst:244
msgid ""
"(Actually, the first three errors are detected by the parser; only the last "
"error is found by the lexical analyzer --- the indentation of ``return r`` "
"does not match a level popped off the stack.)"
msgstr ""
"(I själva verket upptäcks de tre första felen av parsern; endast det sista "
"felet upptäcks av den lexikala analysatorn --- indragningen av ``return r`` "
"matchar inte en nivå som poppats från stacken)"

#: ../../reference/lexical_analysis.rst:252
msgid "Whitespace between tokens"
msgstr "Mellanslag mellan symboler"

#: ../../reference/lexical_analysis.rst:254
msgid ""
"Except at the beginning of a logical line or in string literals, the "
"whitespace characters space, tab and formfeed can be used interchangeably to "
"separate tokens.  Whitespace is needed between two tokens only if their "
"concatenation could otherwise be interpreted as a different token (e.g., ab "
"is one token, but a b is two tokens)."
msgstr ""

#: ../../reference/lexical_analysis.rst:264
msgid "Other tokens"
msgstr "Andra symboler"

#: ../../reference/lexical_analysis.rst:266
msgid ""
"Besides NEWLINE, INDENT and DEDENT, the following categories of tokens "
"exist: *identifiers*, *keywords*, *literals*, *operators*, and *delimiters*. "
"Whitespace characters (other than line terminators, discussed earlier) are "
"not tokens, but serve to delimit tokens. Where ambiguity exists, a token "
"comprises the longest possible string that forms a legal token, when read "
"from left to right."
msgstr ""

#: ../../reference/lexical_analysis.rst:276
msgid "Identifiers and keywords"
msgstr ""

#: ../../reference/lexical_analysis.rst:280
msgid ""
"Identifiers (also referred to as *names*) are described by the following "
"lexical definitions."
msgstr ""

#: ../../reference/lexical_analysis.rst:283
msgid ""
"The syntax of identifiers in Python is based on the Unicode standard annex "
"UAX-31, with elaboration and changes as defined below; see also :pep:`3131` "
"for further details."
msgstr ""

#: ../../reference/lexical_analysis.rst:287
msgid ""
"Within the ASCII range (U+0001..U+007F), the valid characters for "
"identifiers are the same as in Python 2.x: the uppercase and lowercase "
"letters ``A`` through ``Z``, the underscore ``_`` and, except for the first "
"character, the digits ``0`` through ``9``."
msgstr ""

#: ../../reference/lexical_analysis.rst:292
msgid ""
"Python 3.0 introduces additional characters from outside the ASCII range "
"(see :pep:`3131`).  For these characters, the classification uses the "
"version of the Unicode Character Database as included in the :mod:"
"`unicodedata` module."
msgstr ""

#: ../../reference/lexical_analysis.rst:296
msgid "Identifiers are unlimited in length.  Case is significant."
msgstr ""

#: ../../reference/lexical_analysis.rst:305
msgid "The Unicode category codes mentioned above stand for:"
msgstr ""

#: ../../reference/lexical_analysis.rst:307
msgid "*Lu* - uppercase letters"
msgstr ""

#: ../../reference/lexical_analysis.rst:308
msgid "*Ll* - lowercase letters"
msgstr ""

#: ../../reference/lexical_analysis.rst:309
msgid "*Lt* - titlecase letters"
msgstr ""

#: ../../reference/lexical_analysis.rst:310
msgid "*Lm* - modifier letters"
msgstr ""

#: ../../reference/lexical_analysis.rst:311
msgid "*Lo* - other letters"
msgstr ""

#: ../../reference/lexical_analysis.rst:312
msgid "*Nl* - letter numbers"
msgstr ""

#: ../../reference/lexical_analysis.rst:313
msgid "*Mn* - nonspacing marks"
msgstr ""

#: ../../reference/lexical_analysis.rst:314
msgid "*Mc* - spacing combining marks"
msgstr ""

#: ../../reference/lexical_analysis.rst:315
msgid "*Nd* - decimal numbers"
msgstr ""

#: ../../reference/lexical_analysis.rst:316
msgid "*Pc* - connector punctuations"
msgstr ""

#: ../../reference/lexical_analysis.rst:317
msgid ""
"*Other_ID_Start* - explicit list of characters in `PropList.txt <https://www."
"unicode.org/Public/13.0.0/ucd/PropList.txt>`_ to support backwards "
"compatibility"
msgstr ""

#: ../../reference/lexical_analysis.rst:320
msgid "*Other_ID_Continue* - likewise"
msgstr ""

#: ../../reference/lexical_analysis.rst:322
msgid ""
"All identifiers are converted into the normal form NFKC while parsing; "
"comparison of identifiers is based on NFKC."
msgstr ""

#: ../../reference/lexical_analysis.rst:325
msgid ""
"A non-normative HTML file listing all valid identifier characters for "
"Unicode 4.1 can be found at https://www.unicode.org/Public/13.0.0/ucd/"
"DerivedCoreProperties.txt"
msgstr ""

#: ../../reference/lexical_analysis.rst:333
msgid "Keywords"
msgstr "Nyckelord"

#: ../../reference/lexical_analysis.rst:339
msgid ""
"The following identifiers are used as reserved words, or *keywords* of the "
"language, and cannot be used as ordinary identifiers.  They must be spelled "
"exactly as written here:"
msgstr ""

#: ../../reference/lexical_analysis.rst:357
msgid "Soft Keywords"
msgstr "Mjuka nyckelord"

#: ../../reference/lexical_analysis.rst:363
msgid ""
"Some identifiers are only reserved under specific contexts. These are known "
"as *soft keywords*.  The identifiers ``match``, ``case`` and ``_`` can "
"syntactically act as keywords in contexts related to the pattern matching "
"statement, but this distinction is done at the parser level, not when "
"tokenizing."
msgstr ""

#: ../../reference/lexical_analysis.rst:369
msgid ""
"As soft keywords, their use with pattern matching is possible while still "
"preserving compatibility with existing code that uses ``match``, ``case`` "
"and ``_`` as identifier names."
msgstr ""

#: ../../reference/lexical_analysis.rst:380
msgid "Reserved classes of identifiers"
msgstr "Reserverade klasser av identifierare"

#: ../../reference/lexical_analysis.rst:382
msgid ""
"Certain classes of identifiers (besides keywords) have special meanings.  "
"These classes are identified by the patterns of leading and trailing "
"underscore characters:"
msgstr ""
"Vissa klasser av identifierare (förutom nyckelord) har speciella "
"betydelser.  Dessa klasser identifieras av mönstren för inledande och "
"avslutande understrykningstecken:"

#: ../../reference/lexical_analysis.rst:387
msgid "``_*``"
msgstr "``_*``"

#: ../../reference/lexical_analysis.rst:387
msgid "Not imported by ``from module import *``."
msgstr "Inte importerad av ``from module import *``."

#: ../../reference/lexical_analysis.rst:408
msgid "``_``"
msgstr "``_``"

#: ../../reference/lexical_analysis.rst:390
msgid ""
"In a ``case`` pattern within a :keyword:`match` statement, ``_`` is a :ref:"
"`soft keyword <soft-keywords>` that denotes a :ref:`wildcard <wildcard-"
"patterns>`."
msgstr ""
"I ett ``case`` -mönster inom ett :keyword:`match` -uttryck är ``_`` ett :ref:"
"`mjukt nyckelord <soft-keywords>` som betecknar ett :ref:`jokertecken "
"<wildcard-patterns>`."

#: ../../reference/lexical_analysis.rst:394
msgid ""
"Separately, the interactive interpreter makes the result of the last "
"evaluation available in the variable ``_``. (It is stored in the :mod:"
"`builtins` module, alongside built-in functions like ``print``.)"
msgstr ""
"Separat gör den interaktiva tolken resultatet av den senaste utvärderingen "
"tillgängligt i variabeln ``_``. (Den lagras i modulen :mod:`builtins`, "
"tillsammans med inbyggda funktioner som ``print``)"

#: ../../reference/lexical_analysis.rst:399
msgid ""
"Elsewhere, ``_`` is a regular identifier. It is often used to name "
"\"special\" items, but it is not special to Python itself."
msgstr ""
"På andra ställen är ``_`` en vanlig identifierare. Det används ofta för att "
"namnge \"speciella\" objekt, men det är inte speciellt för Python självt."

#: ../../reference/lexical_analysis.rst:404
msgid ""
"The name ``_`` is often used in conjunction with internationalization; refer "
"to the documentation for the :mod:`gettext` module for more information on "
"this convention."
msgstr ""
"Namnet ``_`` används ofta i samband med internationalisering; se "
"dokumentationen för modulen :mod:`gettext` för mer information om denna "
"konvention."

#: ../../reference/lexical_analysis.rst:408
msgid "It is also commonly used for unused variables."
msgstr "Det används också ofta för oanvända variabler."

#: ../../reference/lexical_analysis.rst:416
msgid "``__*__``"
msgstr "``__*__``"

#: ../../reference/lexical_analysis.rst:411
msgid ""
"System-defined names, informally known as \"dunder\" names. These names are "
"defined by the interpreter and its implementation (including the standard "
"library). Current system names are discussed in the :ref:`specialnames` "
"section and elsewhere. More will likely be defined in future versions of "
"Python.  *Any* use of ``__*__`` names, in any context, that does not follow "
"explicitly documented use, is subject to breakage without warning."
msgstr ""
"Systemdefinierade namn, informellt kända som \"dunder\"-namn. Dessa namn "
"definieras av tolken och dess implementation (inklusive "
"standardbiblioteket). Nuvarande systemnamn diskuteras i avsnittet :ref:"
"`specialnames` och på andra ställen. Fler kommer troligen att definieras i "
"framtida versioner av Python.  *All* användning av ``__*__``\\-namn, i "
"vilket sammanhang som helst, som inte följer explicit dokumenterad "
"användning, är föremål för avbrott utan varning."

#: ../../reference/lexical_analysis.rst:423
msgid "``__*``"
msgstr "``__*``"

#: ../../reference/lexical_analysis.rst:419
msgid ""
"Class-private names.  Names in this category, when used within the context "
"of a class definition, are re-written to use a mangled form to help avoid "
"name clashes between \"private\" attributes of base and derived classes. See "
"section :ref:`atom-identifiers`."
msgstr ""
"Klass-privata namn.  Namn i denna kategori, när de används inom ramen för en "
"klassdefinition, skrivs om för att använda en manglad form för att undvika "
"namnkollisioner mellan \"privata\" attribut i bas- och härledda klasser. Se "
"avsnittet :ref:`atom-identifiers`."

#: ../../reference/lexical_analysis.rst:428
msgid "Literals"
msgstr "Bokstäver"

#: ../../reference/lexical_analysis.rst:432
msgid "Literals are notations for constant values of some built-in types."
msgstr "Literals är beteckningar för konstanta värden av vissa inbyggda typer."

#: ../../reference/lexical_analysis.rst:443
msgid "String and Bytes literals"
msgstr "Sträng- och Bytes-litteraler"

#: ../../reference/lexical_analysis.rst:445
msgid "String literals are described by the following lexical definitions:"
msgstr ""

#: ../../reference/lexical_analysis.rst:470
msgid ""
"One syntactic restriction not indicated by these productions is that "
"whitespace is not allowed between the :token:`~python-grammar:stringprefix` "
"or :token:`~python-grammar:bytesprefix` and the rest of the literal. The "
"source character set is defined by the encoding declaration; it is UTF-8 if "
"no encoding declaration is given in the source file; see section :ref:"
"`encodings`."
msgstr ""

#: ../../reference/lexical_analysis.rst:480
msgid ""
"In plain English: Both types of literals can be enclosed in matching single "
"quotes (``'``) or double quotes (``\"``).  They can also be enclosed in "
"matching groups of three single or double quotes (these are generally "
"referred to as *triple-quoted strings*). The backslash (``\\``) character is "
"used to give special meaning to otherwise ordinary characters like ``n``, "
"which means 'newline' when escaped (``\\n``). It can also be used to escape "
"characters that otherwise have a special meaning, such as newline, backslash "
"itself, or the quote character. See :ref:`escape sequences <escape-"
"sequences>` below for examples."
msgstr ""

#: ../../reference/lexical_analysis.rst:493
msgid ""
"Bytes literals are always prefixed with ``'b'`` or ``'B'``; they produce an "
"instance of the :class:`bytes` type instead of the :class:`str` type.  They "
"may only contain ASCII characters; bytes with a numeric value of 128 or "
"greater must be expressed with escapes."
msgstr ""

#: ../../reference/lexical_analysis.rst:502
msgid ""
"Both string and bytes literals may optionally be prefixed with a letter "
"``'r'`` or ``'R'``; such strings are called :dfn:`raw strings` and treat "
"backslashes as literal characters.  As a result, in string literals, "
"``'\\U'`` and ``'\\u'`` escapes in raw strings are not treated specially. "
"Given that Python 2.x's raw unicode literals behave differently than Python "
"3.x's the ``'ur'`` syntax is not supported."
msgstr ""

#: ../../reference/lexical_analysis.rst:509
msgid ""
"The ``'rb'`` prefix of raw bytes literals has been added as a synonym of "
"``'br'``."
msgstr ""
"Prefixet ``'rb'`` för råa byteslitteraler har lagts till som en synonym till "
"``'br'``."

#: ../../reference/lexical_analysis.rst:513
msgid ""
"Support for the unicode legacy literal (``u'value'``) was reintroduced to "
"simplify the maintenance of dual Python 2.x and 3.x codebases. See :pep:"
"`414` for more information."
msgstr ""
"Stöd för unicode legacy literal (``u'value'``) återinfördes för att förenkla "
"underhållet av dubbla Python 2.x och 3.x kodbaser. Se :pep:`414` för mer "
"information."

#: ../../reference/lexical_analysis.rst:522
msgid ""
"A string literal with ``'f'`` or ``'F'`` in its prefix is a :dfn:`formatted "
"string literal`; see :ref:`f-strings`.  The ``'f'`` may be combined with "
"``'r'``, but not with ``'b'`` or ``'u'``, therefore raw formatted strings "
"are possible, but formatted bytes literals are not."
msgstr ""

#: ../../reference/lexical_analysis.rst:527
msgid ""
"In triple-quoted literals, unescaped newlines and quotes are allowed (and "
"are retained), except that three unescaped quotes in a row terminate the "
"literal.  (A \"quote\" is the character used to open the literal, i.e. "
"either ``'`` or ``\"``.)"
msgstr ""

#: ../../reference/lexical_analysis.rst:548
msgid ""
"Unless an ``'r'`` or ``'R'`` prefix is present, escape sequences in string "
"and bytes literals are interpreted according to rules similar to those used "
"by Standard C.  The recognized escape sequences are:"
msgstr ""

#: ../../reference/lexical_analysis.rst:553
#: ../../reference/lexical_analysis.rst:586
msgid "Escape Sequence"
msgstr "Avbrottssekvens"

#: ../../reference/lexical_analysis.rst:553
#: ../../reference/lexical_analysis.rst:586
msgid "Meaning"
msgstr "Betydelse"

#: ../../reference/lexical_analysis.rst:553
#: ../../reference/lexical_analysis.rst:586
msgid "Notes"
msgstr "Anteckningar"

#: ../../reference/lexical_analysis.rst:555
msgid "``\\``\\ <newline>"
msgstr "``\\``\\ <newline>"

#: ../../reference/lexical_analysis.rst:555
msgid "Backslash and newline ignored"
msgstr ""

#: ../../reference/lexical_analysis.rst:555
msgid "\\(1)"
msgstr "\\(1)"

#: ../../reference/lexical_analysis.rst:557
msgid "``\\\\``"
msgstr "``\\\\``"

#: ../../reference/lexical_analysis.rst:557
msgid "Backslash (``\\``)"
msgstr ""

#: ../../reference/lexical_analysis.rst:559
msgid "``\\'``"
msgstr "``\\'``"

#: ../../reference/lexical_analysis.rst:559
msgid "Single quote (``'``)"
msgstr ""

#: ../../reference/lexical_analysis.rst:561
msgid "``\\\"``"
msgstr "``\\\"``"

#: ../../reference/lexical_analysis.rst:561
msgid "Double quote (``\"``)"
msgstr ""

#: ../../reference/lexical_analysis.rst:563
msgid "``\\a``"
msgstr "``\\a``"

#: ../../reference/lexical_analysis.rst:563
msgid "ASCII Bell (BEL)"
msgstr "ASCII Klocka (BEL)"

#: ../../reference/lexical_analysis.rst:565
msgid "``\\b``"
msgstr "``\\b``"

#: ../../reference/lexical_analysis.rst:565
msgid "ASCII Backspace (BS)"
msgstr "ASCII Backspace (BS)"

#: ../../reference/lexical_analysis.rst:567
msgid "``\\f``"
msgstr "``\\f``"

#: ../../reference/lexical_analysis.rst:567
msgid "ASCII Formfeed (FF)"
msgstr "ASCII Formfeed (FF)"

#: ../../reference/lexical_analysis.rst:569
msgid "``\\n``"
msgstr "``\\n``"

#: ../../reference/lexical_analysis.rst:569
msgid "ASCII Linefeed (LF)"
msgstr "ASCII radmatning (LF)"

#: ../../reference/lexical_analysis.rst:571
msgid "``\\r``"
msgstr "``\\r``"

#: ../../reference/lexical_analysis.rst:571
msgid "ASCII Carriage Return (CR)"
msgstr "ASCII vagnsretur (CR)"

#: ../../reference/lexical_analysis.rst:573
msgid "``\\t``"
msgstr "``\\t``"

#: ../../reference/lexical_analysis.rst:573
msgid "ASCII Horizontal Tab (TAB)"
msgstr "ASCII Horisontell tabb (TAB)"

#: ../../reference/lexical_analysis.rst:575
msgid "``\\v``"
msgstr "``\\v``"

#: ../../reference/lexical_analysis.rst:575
msgid "ASCII Vertical Tab (VT)"
msgstr "ASCII Vertikal tabb (VT)"

#: ../../reference/lexical_analysis.rst:577
msgid "``\\ooo``"
msgstr ""

#: ../../reference/lexical_analysis.rst:577
msgid "Character with octal value *ooo*"
msgstr ""

#: ../../reference/lexical_analysis.rst:577
msgid "(2,4)"
msgstr ""

#: ../../reference/lexical_analysis.rst:580
msgid "``\\xhh``"
msgstr ""

#: ../../reference/lexical_analysis.rst:580
msgid "Character with hex value *hh*"
msgstr ""

#: ../../reference/lexical_analysis.rst:580
msgid "(3,4)"
msgstr ""

#: ../../reference/lexical_analysis.rst:583
msgid "Escape sequences only recognized in string literals are:"
msgstr ""

#: ../../reference/lexical_analysis.rst:588
msgid "``\\N{name}``"
msgstr ""

#: ../../reference/lexical_analysis.rst:588
msgid "Character named *name* in the Unicode database"
msgstr ""

#: ../../reference/lexical_analysis.rst:588
msgid "\\(5)"
msgstr "\\(5)"

#: ../../reference/lexical_analysis.rst:591
msgid "``\\uxxxx``"
msgstr ""

#: ../../reference/lexical_analysis.rst:591
msgid "Character with 16-bit hex value *xxxx*"
msgstr ""

#: ../../reference/lexical_analysis.rst:591
msgid "\\(6)"
msgstr "\\(6)"

#: ../../reference/lexical_analysis.rst:594
msgid "``\\Uxxxxxxxx``"
msgstr ""

#: ../../reference/lexical_analysis.rst:594
msgid "Character with 32-bit hex value *xxxxxxxx*"
msgstr ""

#: ../../reference/lexical_analysis.rst:594
msgid "\\(7)"
msgstr "\\(7)"

#: ../../reference/lexical_analysis.rst:598
msgid "Notes:"
msgstr "Anteckningar:"

#: ../../reference/lexical_analysis.rst:601
msgid "A backslash can be added at the end of a line to ignore the newline::"
msgstr ""
"En backslash kan läggas till i slutet av en rad för att ignorera nystrecket::"

#: ../../reference/lexical_analysis.rst:607
msgid ""
"The same result can be achieved using :ref:`triple-quoted strings "
"<strings>`, or parentheses and :ref:`string literal concatenation <string-"
"concatenation>`."
msgstr ""
"Samma resultat kan uppnås med hjälp av :ref:`triple-quoted strings "
"<strings>`, eller parenteser och :ref:`string literal concatenation <string-"
"concatenation>`."

#: ../../reference/lexical_analysis.rst:611
msgid "As in Standard C, up to three octal digits are accepted."
msgstr ""

#: ../../reference/lexical_analysis.rst:614
msgid "Unlike in Standard C, exactly two hex digits are required."
msgstr "Till skillnad från i Standard C krävs exakt två hexadecimala siffror."

#: ../../reference/lexical_analysis.rst:617
msgid ""
"In a bytes literal, hexadecimal and octal escapes denote the byte with the "
"given value. In a string literal, these escapes denote a Unicode character "
"with the given value."
msgstr ""

#: ../../reference/lexical_analysis.rst:622
msgid "Support for name aliases [#]_ has been added."
msgstr ""

#: ../../reference/lexical_analysis.rst:626
msgid "Exactly four hex digits are required."
msgstr ""

#: ../../reference/lexical_analysis.rst:629
msgid ""
"Any Unicode character can be encoded this way.  Exactly eight hex digits are "
"required."
msgstr ""

#: ../../reference/lexical_analysis.rst:635
msgid ""
"Unlike Standard C, all unrecognized escape sequences are left in the string "
"unchanged, i.e., *the backslash is left in the result*.  (This behavior is "
"useful when debugging: if an escape sequence is mistyped, the resulting "
"output is more easily recognized as broken.)  It is also important to note "
"that the escape sequences only recognized in string literals fall into the "
"category of unrecognized escapes for bytes literals."
msgstr ""

#: ../../reference/lexical_analysis.rst:642
msgid ""
"Unrecognized escape sequences produce a :exc:`DeprecationWarning`.  In a "
"future Python version they will be a :exc:`SyntaxWarning` and eventually a :"
"exc:`SyntaxError`."
msgstr ""

#: ../../reference/lexical_analysis.rst:647
msgid ""
"Even in a raw literal, quotes can be escaped with a backslash, but the "
"backslash remains in the result; for example, ``r\"\\\"\"`` is a valid "
"string literal consisting of two characters: a backslash and a double quote; "
"``r\"\\\"`` is not a valid string literal (even a raw string cannot end in "
"an odd number of backslashes).  Specifically, *a raw literal cannot end in a "
"single backslash* (since the backslash would escape the following quote "
"character).  Note also that a single backslash followed by a newline is "
"interpreted as those two characters as part of the literal, *not* as a line "
"continuation."
msgstr ""
"Även i en rå bokstav kan citattecken undkomma med ett backslash, men "
"backslash kvarstår i resultatet; till exempel är ``r\"\\\"\"`` en giltig "
"stränglitteral som består av två tecken: ett backslash och ett dubbelt "
"citattecken; ``r\"\\\"`` är inte en giltig stränglitteral (även en rå sträng "
"kan inte sluta med ett udda antal backslash).  Specifikt kan *en rå bokstav "
"inte sluta med ett enda backslash* (eftersom backslash skulle undkomma det "
"följande citattecknet).  Observera också att ett enkelt backslash följt av "
"en ny rad tolkas som att de två tecknen är en del av den bokstavliga texten, "
"*inte* som en radfortsättning."

#: ../../reference/lexical_analysis.rst:660
msgid "String literal concatenation"
msgstr "Sammankoppling av strängbokstäver"

#: ../../reference/lexical_analysis.rst:662
msgid ""
"Multiple adjacent string or bytes literals (delimited by whitespace), "
"possibly using different quoting conventions, are allowed, and their meaning "
"is the same as their concatenation.  Thus, ``\"hello\" 'world'`` is "
"equivalent to ``\"helloworld\"``.  This feature can be used to reduce the "
"number of backslashes needed, to split long strings conveniently across long "
"lines, or even to add comments to parts of strings, for example::"
msgstr ""

#: ../../reference/lexical_analysis.rst:673
msgid ""
"Note that this feature is defined at the syntactical level, but implemented "
"at compile time.  The '+' operator must be used to concatenate string "
"expressions at run time.  Also note that literal concatenation can use "
"different quoting styles for each component (even mixing raw strings and "
"triple quoted strings), and formatted string literals may be concatenated "
"with plain string literals."
msgstr ""

#: ../../reference/lexical_analysis.rst:694
msgid "Formatted string literals"
msgstr ""

#: ../../reference/lexical_analysis.rst:698
msgid ""
"A :dfn:`formatted string literal` or :dfn:`f-string` is a string literal "
"that is prefixed with ``'f'`` or ``'F'``.  These strings may contain "
"replacement fields, which are expressions delimited by curly braces ``{}``. "
"While other string literals always have a constant value, formatted strings "
"are really expressions evaluated at run time."
msgstr ""

#: ../../reference/lexical_analysis.rst:704
msgid ""
"Escape sequences are decoded like in ordinary string literals (except when a "
"literal is also marked as a raw string).  After decoding, the grammar for "
"the contents of the string is:"
msgstr ""
"Escape-sekvenser avkodas på samma sätt som vanliga stränglitteraler (utom "
"när en literal också markeras som en rå sträng).  Efter avkodning är "
"grammatiken för strängens innehåll följande:"

#: ../../reference/lexical_analysis.rst:718
msgid ""
"The parts of the string outside curly braces are treated literally, except "
"that any doubled curly braces ``'{{'`` or ``'}}'`` are replaced with the "
"corresponding single curly brace.  A single opening curly bracket ``'{'`` "
"marks a replacement field, which starts with a Python expression. To display "
"both the expression text and its value after evaluation, (useful in "
"debugging), an equal sign ``'='`` may be added after the expression. A "
"conversion field, introduced by an exclamation point ``'!'`` may follow.  A "
"format specifier may also be appended, introduced by a colon ``':'``. A "
"replacement field ends with a closing curly bracket ``'}'``."
msgstr ""
"De delar av strängen som står utanför hakparenteser behandlas bokstavligt, "
"förutom att eventuella dubbla hakparenteser ``'{{'`` eller ``'}}'`` ersätts "
"med motsvarande enkla hakparentes.  En enkel öppnande hakparentes ``'{'`` "
"markerar ett ersättningsfält, som börjar med ett Python-uttryck. För att "
"visa både uttryckstexten och dess värde efter utvärdering (användbart vid "
"felsökning), kan ett likhetstecken ``'='`` läggas till efter uttrycket. Ett "
"konverteringsfält, som inleds med ett utropstecken ``'!'`` kan följa.  En "
"formatspecifikator kan också läggas till, inledd med ett kolon ``':'``. Ett "
"ersättningsfält avslutas med en avslutande hakparentes ``'}'``."

#: ../../reference/lexical_analysis.rst:728
msgid ""
"Expressions in formatted string literals are treated like regular Python "
"expressions surrounded by parentheses, with a few exceptions. An empty "
"expression is not allowed, and both :keyword:`lambda`  and assignment "
"expressions ``:=`` must be surrounded by explicit parentheses. Replacement "
"expressions can contain line breaks (e.g. in triple-quoted strings), but "
"they cannot contain comments.  Each expression is evaluated in the context "
"where the formatted string literal appears, in order from left to right."
msgstr ""

#: ../../reference/lexical_analysis.rst:737
msgid ""
"Prior to Python 3.7, an :keyword:`await` expression and comprehensions "
"containing an :keyword:`async for` clause were illegal in the expressions in "
"formatted string literals due to a problem with the implementation."
msgstr ""
"Före Python 3.7 var ett :keyword:`await`\\-uttryck och förståelser som "
"innehöll en :keyword:`async for`\\-klausul olagliga i uttryck i formaterade "
"stränglitteraler på grund av ett problem med implementeringen."

#: ../../reference/lexical_analysis.rst:742
msgid ""
"When the equal sign ``'='`` is provided, the output will have the expression "
"text, the ``'='`` and the evaluated value. Spaces after the opening brace "
"``'{'``, within the expression and after the ``'='`` are all retained in the "
"output. By default, the ``'='`` causes the :func:`repr` of the expression to "
"be provided, unless there is a format specified. When a format is specified "
"it defaults to the :func:`str` of the expression unless a conversion ``'!"
"r'`` is declared."
msgstr ""
"När likhetstecknet ``'='`` anges, kommer utdata att innehålla "
"uttryckstexten, ``'='`` och det utvärderade värdet. Mellanrum efter den "
"inledande parentesen ``'{'``, inom uttrycket och efter ``'='`` behålls i "
"utdata. Som standard orsakar ``'='`` att :func:`repr` av uttrycket "
"tillhandahålls, såvida inte ett format har angetts. När ett format är "
"specificerat är standardvärdet :func:`str` av uttrycket om inte en "
"konvertering ``'!r'`` är deklarerad."

#: ../../reference/lexical_analysis.rst:750
msgid "The equal sign ``'='``."
msgstr "Likhetstecknet ``'='``."

#: ../../reference/lexical_analysis.rst:753
msgid ""
"If a conversion is specified, the result of evaluating the expression is "
"converted before formatting.  Conversion ``'!s'`` calls :func:`str` on the "
"result, ``'!r'`` calls :func:`repr`, and ``'!a'`` calls :func:`ascii`."
msgstr ""
"Om en konvertering anges, konverteras resultatet av utvärderingen av "
"uttrycket innan det formateras.  Konvertering ``'!s'`` anropar :func:`str` "
"på resultatet, ``'!r'`` anropar :func:`repr`, och ``'!a'`` anropar :func:"
"`ascii`."

#: ../../reference/lexical_analysis.rst:757
msgid ""
"The result is then formatted using the :func:`format` protocol.  The format "
"specifier is passed to the :meth:`__format__` method of the expression or "
"conversion result.  An empty string is passed when the format specifier is "
"omitted.  The formatted result is then included in the final value of the "
"whole string."
msgstr ""

#: ../../reference/lexical_analysis.rst:763
msgid ""
"Top-level format specifiers may include nested replacement fields. These "
"nested fields may include their own conversion fields and :ref:`format "
"specifiers <formatspec>`, but may not include more deeply nested replacement "
"fields. The :ref:`format specifier mini-language <formatspec>` is the same "
"as that used by the :meth:`str.format` method."
msgstr ""
"Formatspecifikatorer på högsta nivån kan innehålla nästlade ersättningsfält. "
"Dessa nästlade fält kan inkludera sina egna konverteringsfält och :ref:"
"`formatspecifikatorer <formatspec>`, men kan inte inkludera mer djupt "
"nästlade ersättningsfält. Den :ref:`formatspecifikator mini-språk "
"<formatspec>` är densamma som används av :meth:`str.format`\\-metoden."

#: ../../reference/lexical_analysis.rst:769
msgid ""
"Formatted string literals may be concatenated, but replacement fields cannot "
"be split across literals."
msgstr ""
"Formaterade stränglitteraler kan konkateneras, men ersättningsfält kan inte "
"delas upp mellan litteraler."

#: ../../reference/lexical_analysis.rst:772
msgid "Some examples of formatted string literals::"
msgstr "Några exempel på formaterade stränglitteraler::"

#: ../../reference/lexical_analysis.rst:804
msgid ""
"A consequence of sharing the same syntax as regular string literals is that "
"characters in the replacement fields must not conflict with the quoting used "
"in the outer formatted string literal::"
msgstr ""

#: ../../reference/lexical_analysis.rst:811
msgid ""
"Backslashes are not allowed in format expressions and will raise an error::"
msgstr ""

#: ../../reference/lexical_analysis.rst:816
msgid ""
"To include a value in which a backslash escape is required, create a "
"temporary variable."
msgstr ""

#: ../../reference/lexical_analysis.rst:823
msgid ""
"Formatted string literals cannot be used as docstrings, even if they do not "
"include expressions."
msgstr ""
"Formaterade stränglitteraler kan inte användas som docstrings, även om de "
"inte innehåller uttryck."

#: ../../reference/lexical_analysis.rst:834
msgid ""
"See also :pep:`498` for the proposal that added formatted string literals, "
"and :meth:`str.format`, which uses a related format string mechanism."
msgstr ""
"Se även :pep:`498` för förslaget som lade till formaterade stränglitteraler, "
"och :meth:`str.format`, som använder en relaterad formatsträngmekanism."

#: ../../reference/lexical_analysis.rst:841
msgid "Numeric literals"
msgstr "Numeriska bokstäver"

#: ../../reference/lexical_analysis.rst:847
msgid ""
"There are three types of numeric literals: integers, floating point numbers, "
"and imaginary numbers.  There are no complex literals (complex numbers can "
"be formed by adding a real number and an imaginary number)."
msgstr ""

#: ../../reference/lexical_analysis.rst:851
msgid ""
"Note that numeric literals do not include a sign; a phrase like ``-1`` is "
"actually an expression composed of the unary operator '``-``' and the "
"literal ``1``."
msgstr ""

#: ../../reference/lexical_analysis.rst:865
msgid "Integer literals"
msgstr "Heltalslitteraler"

#: ../../reference/lexical_analysis.rst:867
msgid "Integer literals are described by the following lexical definitions:"
msgstr ""

#: ../../reference/lexical_analysis.rst:881
msgid ""
"There is no limit for the length of integer literals apart from what can be "
"stored in available memory."
msgstr ""

#: ../../reference/lexical_analysis.rst:884
msgid ""
"Underscores are ignored for determining the numeric value of the literal.  "
"They can be used to group digits for enhanced readability.  One underscore "
"can occur between digits, and after base specifiers like ``0x``."
msgstr ""

#: ../../reference/lexical_analysis.rst:888
msgid ""
"Note that leading zeros in a non-zero decimal number are not allowed. This "
"is for disambiguation with C-style octal literals, which Python used before "
"version 3.0."
msgstr ""

#: ../../reference/lexical_analysis.rst:892
msgid "Some examples of integer literals::"
msgstr ""

#: ../../reference/lexical_analysis.rst:898
#: ../../reference/lexical_analysis.rst:930
msgid "Underscores are now allowed for grouping purposes in literals."
msgstr "Underscores är nu tillåtna för grupperingsändamål i literals."

#: ../../reference/lexical_analysis.rst:909
msgid "Floating point literals"
msgstr ""

#: ../../reference/lexical_analysis.rst:911
msgid ""
"Floating point literals are described by the following lexical definitions:"
msgstr ""

#: ../../reference/lexical_analysis.rst:921
msgid ""
"Note that the integer and exponent parts are always interpreted using radix "
"10. For example, ``077e010`` is legal, and denotes the same number as "
"``77e10``. The allowed range of floating point literals is implementation-"
"dependent.  As in integer literals, underscores are supported for digit "
"grouping."
msgstr ""

#: ../../reference/lexical_analysis.rst:926
msgid "Some examples of floating point literals::"
msgstr ""

#: ../../reference/lexical_analysis.rst:939
msgid "Imaginary literals"
msgstr "Imaginära bokstäver"

#: ../../reference/lexical_analysis.rst:941
msgid "Imaginary literals are described by the following lexical definitions:"
msgstr ""

#: ../../reference/lexical_analysis.rst:946
msgid ""
"An imaginary literal yields a complex number with a real part of 0.0.  "
"Complex numbers are represented as a pair of floating point numbers and have "
"the same restrictions on their range.  To create a complex number with a "
"nonzero real part, add a floating point number to it, e.g., ``(3+4j)``.  "
"Some examples of imaginary literals::"
msgstr ""

#: ../../reference/lexical_analysis.rst:958
msgid "Operators"
msgstr "Operatorer"

#: ../../reference/lexical_analysis.rst:962
msgid "The following tokens are operators:"
msgstr ""

#: ../../reference/lexical_analysis.rst:975
msgid "Delimiters"
msgstr ""

#: ../../reference/lexical_analysis.rst:979
msgid "The following tokens serve as delimiters in the grammar:"
msgstr ""

#: ../../reference/lexical_analysis.rst:988
msgid ""
"The period can also occur in floating-point and imaginary literals.  A "
"sequence of three periods has a special meaning as an ellipsis literal. The "
"second half of the list, the augmented assignment operators, serve lexically "
"as delimiters, but also perform an operation."
msgstr ""

#: ../../reference/lexical_analysis.rst:993
msgid ""
"The following printing ASCII characters have special meaning as part of "
"other tokens or are otherwise significant to the lexical analyzer:"
msgstr ""

#: ../../reference/lexical_analysis.rst:1000
msgid ""
"The following printing ASCII characters are not used in Python.  Their "
"occurrence outside string literals and comments is an unconditional error:"
msgstr ""

#: ../../reference/lexical_analysis.rst:1009
msgid "Footnotes"
msgstr "Fotnoter"

#: ../../reference/lexical_analysis.rst:1010
msgid "https://www.unicode.org/Public/11.0.0/ucd/NameAliases.txt"
msgstr ""
