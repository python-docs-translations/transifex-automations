# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-11 14:15+0000\n"
"PO-Revision-Date: 2025-09-16 00:00+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../glossary.rst:5
msgid "Glossary"
msgstr "Ordlista"

#: ../../glossary.rst:10
msgid "``>>>``"
msgstr "``>>>``"

#: ../../glossary.rst:12
msgid ""
"The default Python prompt of the :term:`interactive` shell.  Often seen for "
"code examples which can be executed interactively in the interpreter."
msgstr ""
"Standardprompten för Python i skalet :term:`interactive`.  Används ofta för "
"kodexempel som kan köras interaktivt i tolken."

#: ../../glossary.rst:15
msgid "``...``"
msgstr "``...``"

#: ../../glossary.rst:17
msgid "Can refer to:"
msgstr "Kan hänvisa till:"

#: ../../glossary.rst:19
msgid ""
"The default Python prompt of the :term:`interactive` shell when entering the "
"code for an indented code block, when within a pair of matching left and "
"right delimiters (parentheses, square brackets, curly braces or triple "
"quotes), or after specifying a decorator."
msgstr ""
"Standardprompten i Python för skalet :term:`interactive` när du anger koden "
"för ett indraget kodblock, när du befinner dig inom ett par matchande "
"vänster- och högeravgränsare (parenteser, hakparenteser, krullparenteser "
"eller trippelcitat) eller efter att ha angett en dekorator."

#: ../../glossary.rst:26
msgid ""
"The three dots form of the :ref:`Ellipsis <bltin-ellipsis-object>` object."
msgstr ""

#: ../../glossary.rst:27
msgid "abstract base class"
msgstr "abstrakt basklass"

#: ../../glossary.rst:29
msgid ""
"Abstract base classes complement :term:`duck-typing` by providing a way to "
"define interfaces when other techniques like :func:`hasattr` would be clumsy "
"or subtly wrong (for example with :ref:`magic methods <special-lookup>`).  "
"ABCs introduce virtual subclasses, which are classes that don't inherit from "
"a class but are still recognized by :func:`isinstance` and :func:"
"`issubclass`; see the :mod:`abc` module documentation.  Python comes with "
"many built-in ABCs for data structures (in the :mod:`collections.abc` "
"module), numbers (in the :mod:`numbers` module), streams (in the :mod:`io` "
"module), import finders and loaders (in the :mod:`importlib.abc` module).  "
"You can create your own ABCs with the :mod:`abc` module."
msgstr ""
"Abstrakta basklasser kompletterar :term:`duck-typing` genom att "
"tillhandahålla ett sätt att definiera gränssnitt när andra tekniker som :"
"func:`hasattr` skulle vara klumpiga eller subtilt felaktiga (till exempel "
"med :ref:`magic methods <special-lookup>`).  ABC introducerar virtuella "
"subklasser, vilket är klasser som inte ärver från en klass men som "
"fortfarande känns igen av :func:`isinstance` och :func:`issubclass`; se :mod:"
"`abc` modulens dokumentation.  Python kommer med många inbyggda ABC för "
"datastrukturer (i modulen :mod:`collections.abc`), tal (i modulen :mod:"
"`numbers`), strömmar (i modulen :mod:`io`), importsökare och laddare (i "
"modulen :mod:`importlib.abc`).  Du kan skapa din egen ABC med modulen :mod:"
"`abc`."

#: ../../glossary.rst:40
msgid "annotate function"
msgstr "annotera funktion"

#: ../../glossary.rst:42
msgid ""
"A function that can be called to retrieve the :term:`annotations "
"<annotation>` of an object. This function is accessible as the :attr:"
"`~object.__annotate__` attribute of functions, classes, and modules. "
"Annotate functions are a subset of :term:`evaluate functions <evaluate "
"function>`."
msgstr ""
"En funktion som kan anropas för att hämta :term:`annotations <annotation>` "
"för ett objekt. Denna funktion är tillgänglig som attributet :attr:`~object."
"__annotate__` för funktioner, klasser och moduler. Annoteringsfunktioner är "
"en delmängd av :term:``evaluate functions <evaluate function>`."

#: ../../glossary.rst:46
msgid "annotation"
msgstr "anteckning"

#: ../../glossary.rst:48
msgid ""
"A label associated with a variable, a class attribute or a function "
"parameter or return value, used by convention as a :term:`type hint`."
msgstr ""
"En etikett som är associerad med en variabel, ett klassattribut eller en "
"funktionsparameter eller ett returvärde och som används som :term:`type "
"hint`."

#: ../../glossary.rst:52
msgid ""
"Annotations of local variables cannot be accessed at runtime, but "
"annotations of global variables, class attributes, and functions can be "
"retrieved by calling :func:`annotationlib.get_annotations` on modules, "
"classes, and functions, respectively."
msgstr ""
"Annoteringar av lokala variabler kan inte nås under körning, men "
"annoteringar av globala variabler, klassattribut och funktioner kan hämtas "
"genom att anropa :func:`annotationlib.get_annotations` på moduler, klasser "
"respektive funktioner."

#: ../../glossary.rst:57
msgid ""
"See :term:`variable annotation`, :term:`function annotation`, :pep:`484`, :"
"pep:`526`, and :pep:`649`, which describe this functionality. Also see :ref:"
"`annotations-howto` for best practices on working with annotations."
msgstr ""
"Se :term:`variable annotation`, :term:`function annotation`, :pep:`484`, :"
"pep:`526` och :pep:`649`, som beskriver denna funktionalitet. Se även :ref:"
"`annotations-howto` för bästa praxis för att arbeta med annoteringar."

#: ../../glossary.rst:61
msgid "argument"
msgstr "argument"

#: ../../glossary.rst:63
msgid ""
"A value passed to a :term:`function` (or :term:`method`) when calling the "
"function.  There are two kinds of argument:"
msgstr ""
"Ett värde som skickas till en :term:`function` (eller :term:`method`) när "
"funktionen anropas.  Det finns två typer av argument:"

#: ../../glossary.rst:66
msgid ""
":dfn:`keyword argument`: an argument preceded by an identifier (e.g. "
"``name=``) in a function call or passed as a value in a dictionary preceded "
"by ``**``.  For example, ``3`` and ``5`` are both keyword arguments in the "
"following calls to :func:`complex`::"
msgstr ""
":dfn:`keyword argument`: ett argument som föregås av en identifierare (t.ex. "
"``name=``) i ett funktionsanrop eller som skickas som ett värde i en ordbok "
"som föregås av ``**``.  Till exempel är ``3`` och ``5`` båda "
"nyckelordsargument i följande anrop till :func:`complex`::"

#: ../../glossary.rst:71
msgid ""
"complex(real=3, imag=5)\n"
"complex(**{'real': 3, 'imag': 5})"
msgstr ""
"komplex(real=3, imag=5)\n"
"komplex(**{'real': 3, 'imag': 5})"

#: ../../glossary.rst:74
msgid ""
":dfn:`positional argument`: an argument that is not a keyword argument. "
"Positional arguments can appear at the beginning of an argument list and/or "
"be passed as elements of an :term:`iterable` preceded by ``*``. For example, "
"``3`` and ``5`` are both positional arguments in the following calls::"
msgstr ""
":dfn:`positionellt argument`: ett argument som inte är ett "
"nyckelordsargument. Positionella argument kan visas i början av en "
"argumentlista och/eller skickas som element i en :term:`iterable` som "
"föregås av ``*``. Till exempel är ``3`` och ``5`` båda positionella argument "
"i följande anrop::"

#: ../../glossary.rst:80
msgid ""
"complex(3, 5)\n"
"complex(*(3, 5))"
msgstr ""
"komplex(3, 5)\n"
"komplex(*(3, 5))"

#: ../../glossary.rst:83
msgid ""
"Arguments are assigned to the named local variables in a function body. See "
"the :ref:`calls` section for the rules governing this assignment. "
"Syntactically, any expression can be used to represent an argument; the "
"evaluated value is assigned to the local variable."
msgstr ""
"Argument tilldelas de namngivna lokala variablerna i en funktionskropp. Se "
"avsnittet :ref:`calls` för de regler som styr denna tilldelning. Syntaktiskt "
"sett kan vilket uttryck som helst användas för att representera ett "
"argument; det utvärderade värdet tilldelas den lokala variabeln."

#: ../../glossary.rst:88
msgid ""
"See also the :term:`parameter` glossary entry, the FAQ question on :ref:`the "
"difference between arguments and parameters <faq-argument-vs-parameter>`, "
"and :pep:`362`."
msgstr ""
"Se även ordlistan :term:`parameter`, FAQ-frågan om :ref:``skillnaden mellan "
"argument och parametrar <faq-argument-vs-parameter>`, och :pep:`362`."

#: ../../glossary.rst:91
msgid "asynchronous context manager"
msgstr "asynkron kontexthanterare"

#: ../../glossary.rst:93
msgid ""
"An object which controls the environment seen in an :keyword:`async with` "
"statement by defining :meth:`~object.__aenter__` and :meth:`~object."
"__aexit__` methods.  Introduced by :pep:`492`."
msgstr ""
"Ett objekt som styr den miljö som visas i en :keyword:`async with`-sats "
"genom att definiera metoderna :meth:`~object.__aenter__` och :meth:`~object."
"__aexit__`.  Införd av :pep:`492`."

#: ../../glossary.rst:96
msgid "asynchronous generator"
msgstr "asynkron generator"

#: ../../glossary.rst:98
msgid ""
"A function which returns an :term:`asynchronous generator iterator`.  It "
"looks like a coroutine function defined with :keyword:`async def` except "
"that it contains :keyword:`yield` expressions for producing a series of "
"values usable in an :keyword:`async for` loop."
msgstr ""
"En funktion som returnerar en :term:`asynkron generator iterator`.  Den ser "
"ut som en coroutinefunktion definierad med :keyword:`async def` förutom att "
"den innehåller :keyword:`yield`-uttryck för att producera en serie värden "
"som kan användas i en :keyword:`async for`-loop."

#: ../../glossary.rst:103
msgid ""
"Usually refers to an asynchronous generator function, but may refer to an "
"*asynchronous generator iterator* in some contexts.  In cases where the "
"intended meaning isn't clear, using the full terms avoids ambiguity."
msgstr ""
"Hänvisar vanligtvis till en asynkron generatorfunktion, men kan i vissa "
"sammanhang hänvisa till en *asynkron generatoriterator*.  I fall där den "
"avsedda betydelsen inte är klar, undviker man tvetydighet genom att använda "
"de fullständiga termerna."

#: ../../glossary.rst:107
msgid ""
"An asynchronous generator function may contain :keyword:`await` expressions "
"as well as :keyword:`async for`, and :keyword:`async with` statements."
msgstr ""
"En asynkron generatorfunktion kan innehålla såväl :keyword:`await`-uttryck "
"som :keyword:`async for`- och :keyword:`async with`-satser."

#: ../../glossary.rst:110
msgid "asynchronous generator iterator"
msgstr "asynkron generator iterator"

#: ../../glossary.rst:112
msgid "An object created by an :term:`asynchronous generator` function."
msgstr ""

#: ../../glossary.rst:114
msgid ""
"This is an :term:`asynchronous iterator` which when called using the :meth:"
"`~object.__anext__` method returns an awaitable object which will execute "
"the body of the asynchronous generator function until the next :keyword:"
"`yield` expression."
msgstr ""
"Detta är en :term:`asynkron iterator` som när den anropas med metoden :meth:"
"`~object.__anext__` returnerar ett väntande objekt som kommer att exekvera "
"den asynkrona generatorfunktionens kropp fram till nästa :keyword:`yield`-"
"uttryck."

#: ../../glossary.rst:119
msgid ""
"Each :keyword:`yield` temporarily suspends processing, remembering the "
"execution state (including local variables and pending try-statements).  "
"When the *asynchronous generator iterator* effectively resumes with another "
"awaitable returned by :meth:`~object.__anext__`, it picks up where it left "
"off.  See :pep:`492` and :pep:`525`."
msgstr ""
"Varje :keyword:`yield` avbryter temporärt bearbetningen och kommer ihåg "
"exekveringstillståndet (inklusive lokala variabler och väntande try-"
"statements).  När *asynkron generator iterator* effektivt återupptas med en "
"annan awaitable som returneras av :meth:`~object.__anext__`, fortsätter den "
"där den slutade.  Se :pep:`492` och :pep:`525`."

#: ../../glossary.rst:124
msgid "asynchronous iterable"
msgstr "asynkron iterabel"

#: ../../glossary.rst:126
msgid ""
"An object, that can be used in an :keyword:`async for` statement. Must "
"return an :term:`asynchronous iterator` from its :meth:`~object.__aiter__` "
"method.  Introduced by :pep:`492`."
msgstr ""
"Ett objekt som kan användas i en :keyword:`async for`-sats. Måste returnera "
"en :term:`asynkron iterator` från dess :meth:`~object.__aiter__` metod.  "
"Införd av :pep:`492`."

#: ../../glossary.rst:129
msgid "asynchronous iterator"
msgstr "asynkron iterator"

#: ../../glossary.rst:131
msgid ""
"An object that implements the :meth:`~object.__aiter__` and :meth:`~object."
"__anext__` methods.  :meth:`~object.__anext__` must return an :term:"
"`awaitable` object. :keyword:`async for` resolves the awaitables returned by "
"an asynchronous iterator's :meth:`~object.__anext__` method until it raises "
"a :exc:`StopAsyncIteration` exception.  Introduced by :pep:`492`."
msgstr ""
"Ett objekt som implementerar metoderna :meth:`~object.__aiter__` och :meth:"
"`~object.__anext__`. :meth:`~object.__anext__` måste returnera ett :term:"
"`awaitable`-objekt. :keyword:`async for` löser awaitables som returneras av "
"en asynkron iterators :meth:`~object.__anext__`-metod tills den utlöser ett :"
"exc:`StopAsyncIteration`-undantag.  Införd av :pep:`492`."

#: ../../glossary.rst:136
msgid "attached thread state"
msgstr "ansluten trådstatus"

#: ../../glossary.rst:139
msgid "A :term:`thread state` that is active for the current OS thread."
msgstr "En :term:`thread state` som är aktiv för den aktuella OS-tråden."

#: ../../glossary.rst:141
msgid ""
"When a :term:`thread state` is attached, the OS thread has access to the "
"full Python C API and can safely invoke the bytecode interpreter."
msgstr ""
"När en :term:`thread state` är kopplad har OS-tråden tillgång till hela "
"Python C API och kan på ett säkert sätt anropa bytekodstolken."

#: ../../glossary.rst:145
msgid ""
"Unless a function explicitly notes otherwise, attempting to call the C API "
"without an attached thread state will result in a fatal error or undefined "
"behavior.  A thread state can be attached and detached explicitly by the "
"user through the C API, or implicitly by the runtime, including during "
"blocking C calls and by the bytecode interpreter in between calls."
msgstr ""
"Om inte en funktion uttryckligen anger något annat kommer försök att anropa "
"C API utan ett kopplat trådtillstånd att resultera i ett fatalt fel eller "
"odefinierat beteende.  Ett trådtillstånd kan kopplas till och från explicit "
"av användaren via C API, eller implicit av körtiden, inklusive under "
"blockerande C-anrop och av bytekodstolken mellan anrop."

#: ../../glossary.rst:152
msgid ""
"On most builds of Python, having an attached thread state implies that the "
"caller holds the :term:`GIL` for the current interpreter, so only one OS "
"thread can have an attached thread state at a given moment. In :term:`free-"
"threaded <free threading>` builds of Python, threads can concurrently hold "
"an attached thread state, allowing for true parallelism of the bytecode "
"interpreter."
msgstr ""
"I de flesta Python-versioner innebär ett anslutet trådtillstånd att den som "
"anropar innehar :term:`GIL` för den aktuella tolken, så endast en OS-tråd "
"kan ha ett anslutet trådtillstånd vid ett givet tillfälle. I :term:``free-"
"threaded <free threading>`-versioner av Python kan trådar samtidigt ha ett "
"attached thread state, vilket möjliggör verklig parallellitet i "
"bytekodstolken."

#: ../../glossary.rst:158
msgid "attribute"
msgstr "attribut"

#: ../../glossary.rst:160
msgid ""
"A value associated with an object which is usually referenced by name using "
"dotted expressions. For example, if an object *o* has an attribute *a* it "
"would be referenced as *o.a*."
msgstr ""
"Ett värde som är associerat med ett objekt och som vanligtvis refereras till "
"med namn med hjälp av prickade uttryck. Om till exempel ett objekt *o* har "
"ett attribut *a* refereras det som *o.a*."

#: ../../glossary.rst:165
msgid ""
"It is possible to give an object an attribute whose name is not an "
"identifier as defined by :ref:`identifiers`, for example using :func:"
"`setattr`, if the object allows it. Such an attribute will not be accessible "
"using a dotted expression, and would instead need to be retrieved with :func:"
"`getattr`."
msgstr ""
"Det är möjligt att ge ett objekt ett attribut vars namn inte är en "
"identifierare enligt definitionen i :ref:`identifiers`, t.ex. med :func:"
"`setattr`, om objektet tillåter det. Ett sådant attribut kommer inte att "
"vara tillgängligt med ett prickat uttryck, utan måste istället hämtas med :"
"func:`getattr`."

#: ../../glossary.rst:170
msgid "awaitable"
msgstr "avvaktande"

#: ../../glossary.rst:172
msgid ""
"An object that can be used in an :keyword:`await` expression.  Can be a :"
"term:`coroutine` or an object with an :meth:`~object.__await__` method. See "
"also :pep:`492`."
msgstr ""
"Ett objekt som kan användas i ett :keyword:`await`-uttryck.  Kan vara en :"
"term:`coroutine` eller ett objekt med en :meth:`~object.__await__`-metod. Se "
"även :pep:`492`."

#: ../../glossary.rst:175
msgid "BDFL"
msgstr "BDFL"

#: ../../glossary.rst:177
msgid ""
"Benevolent Dictator For Life, a.k.a. `Guido van Rossum <https://gvanrossum."
"github.io/>`_, Python's creator."
msgstr ""
"Benevolent Dictator For Life, a.k.a. `Guido van Rossum <https://gvanrossum."
"github.io/>`_, Pythons skapare."

#: ../../glossary.rst:179
msgid "binary file"
msgstr "binär fil"

#: ../../glossary.rst:181
msgid ""
"A :term:`file object` able to read and write :term:`bytes-like objects "
"<bytes-like object>`. Examples of binary files are files opened in binary "
"mode (``'rb'``, ``'wb'`` or ``'rb+'``), :data:`sys.stdin.buffer <sys."
"stdin>`, :data:`sys.stdout.buffer <sys.stdout>`, and instances of :class:`io."
"BytesIO` and :class:`gzip.GzipFile`."
msgstr ""
"Ett :term:`filobjekt` som kan läsa och skriva :term:`bytesliknande objekt "
"<bytes-like object>`. Exempel på binära filer är filer som öppnas i binärt "
"läge (``'rb'``, ``'wb'`` eller ``'rb+'``), :data:`sys.stdin.buffer <sys."
"stdin>`, :data:`sys.stdout.buffer <sys.stdout>`, och instanser av :class:`io."
"BytesIO` och :class:`gzip.GzipFile`."

#: ../../glossary.rst:188
msgid ""
"See also :term:`text file` for a file object able to read and write :class:"
"`str` objects."
msgstr ""
"Se även :term:`text file` för ett filobjekt som kan läsa och skriva :class:"
"`str`-objekt."

#: ../../glossary.rst:190
msgid "borrowed reference"
msgstr "lånad referens"

#: ../../glossary.rst:192
msgid ""
"In Python's C API, a borrowed reference is a reference to an object, where "
"the code using the object does not own the reference. It becomes a dangling "
"pointer if the object is destroyed. For example, a garbage collection can "
"remove the last :term:`strong reference` to the object and so destroy it."
msgstr ""
"I Pythons C API är en lånad referens en referens till ett objekt, där koden "
"som använder objektet inte äger referensen. Den blir en dinglande pekare om "
"objektet förstörs. Till exempel kan en garbage collection ta bort den sista :"
"term:`strong-referensen till objektet och på så sätt förstöra det."

#: ../../glossary.rst:198
msgid ""
"Calling :c:func:`Py_INCREF` on the :term:`borrowed reference` is recommended "
"to convert it to a :term:`strong reference` in-place, except when the object "
"cannot be destroyed before the last usage of the borrowed reference. The :c:"
"func:`Py_NewRef` function can be used to create a new :term:`strong "
"reference`."
msgstr ""
"Att anropa :c:func:`Py_INCREF` på :term:`borrowed reference` rekommenderas "
"för att konvertera den till en :term:`strong reference` på plats, utom när "
"objektet inte kan förstöras innan den sista användningen av den lånade "
"referensen. Funktionen :c:func:`Py_NewRef` kan användas för att skapa en ny :"
"term:`strong reference`."

#: ../../glossary.rst:203
msgid "bytes-like object"
msgstr "bytesliknande objekt"

#: ../../glossary.rst:205
msgid ""
"An object that supports the :ref:`bufferobjects` and can export a C-:term:"
"`contiguous` buffer. This includes all :class:`bytes`, :class:`bytearray`, "
"and :class:`array.array` objects, as well as many common :class:`memoryview` "
"objects.  Bytes-like objects can be used for various operations that work "
"with binary data; these include compression, saving to a binary file, and "
"sending over a socket."
msgstr ""
"Ett objekt som stöder :ref:`bufferobjects` och kan exportera en C-:term:"
"`contiguous` buffert. Detta inkluderar alla :class:`bytes`-, :class:"
"`bytearray`- och :class:`array.array`-objekt, samt många vanliga :class:"
"`memoryview`-objekt.  Bytes-liknande objekt kan användas för olika "
"operationer som arbetar med binära data; dessa inkluderar komprimering, "
"spara till en binär fil och skicka över en socket."

#: ../../glossary.rst:212
msgid ""
"Some operations need the binary data to be mutable.  The documentation often "
"refers to these as \"read-write bytes-like objects\".  Example mutable "
"buffer objects include :class:`bytearray` and a :class:`memoryview` of a :"
"class:`bytearray`. Other operations require the binary data to be stored in "
"immutable objects (\"read-only bytes-like objects\"); examples of these "
"include :class:`bytes` and a :class:`memoryview` of a :class:`bytes` object."
msgstr ""
"Vissa operationer kräver att binärdata är föränderliga.  Dokumentationen "
"hänvisar ofta till dessa som \"skriv-läs bytes-liknande objekt\".  Exempel "
"på föränderliga buffertobjekt är :class:`bytearray` och en :class:"
"`memoryview` av en :class:`bytearray`. Andra operationer kräver att "
"binärdata lagras i oföränderliga objekt (\"read-only bytes-like objects\"); "
"exempel på dessa är :class:`bytes` och en :class:`memoryview` av ett :class:"
"`bytes`-objekt."

#: ../../glossary.rst:220
msgid "bytecode"
msgstr "bytekod"

#: ../../glossary.rst:222
msgid ""
"Python source code is compiled into bytecode, the internal representation of "
"a Python program in the CPython interpreter.  The bytecode is also cached in "
"``.pyc`` files so that executing the same file is faster the second time "
"(recompilation from source to bytecode can be avoided).  This \"intermediate "
"language\" is said to run on a :term:`virtual machine` that executes the "
"machine code corresponding to each bytecode. Do note that bytecodes are not "
"expected to work between different Python virtual machines, nor to be stable "
"between Python releases."
msgstr ""
"Python-källkod kompileras till bytecode, den interna representationen av ett "
"Python-program i CPython-tolken.  Bytekoden cachas också i ``.pyc``-filer så "
"att det går snabbare att köra samma fil andra gången (omkompilering från "
"källkod till bytekod kan undvikas).  Detta \"mellanspråk\" sägs köras på en :"
"term:`virtuell maskin` som exekverar den maskinkod som motsvarar varje "
"bytecode. Observera att bytekoder inte förväntas fungera mellan olika "
"virtuella Python-maskiner eller vara stabila mellan olika Python-versioner."

#: ../../glossary.rst:232
msgid ""
"A list of bytecode instructions can be found in the documentation for :ref:"
"`the dis module <bytecodes>`."
msgstr ""
"En lista med bytecode-instruktioner finns i dokumentationen för :ref:`the "
"dis module <bytecodes>`."

#: ../../glossary.rst:234
msgid "callable"
msgstr "anropsbar"

#: ../../glossary.rst:236
msgid ""
"A callable is an object that can be called, possibly with a set of arguments "
"(see :term:`argument`), with the following syntax::"
msgstr ""
"En anropsbar är ett objekt som kan anropas, eventuellt med en uppsättning "
"argument (se :term:`argument`), med följande syntax::"

#: ../../glossary.rst:239
msgid "callable(argument1, argument2, argumentN)"
msgstr "anropbar(argument1, argument2, argumentN)"

#: ../../glossary.rst:241
msgid ""
"A :term:`function`, and by extension a :term:`method`, is a callable. An "
"instance of a class that implements the :meth:`~object.__call__` method is "
"also a callable."
msgstr ""
"En :term:`function`, och i förlängningen en :term:`method`, är en callable. "
"En instans av en klass som implementerar metoden :meth:`~object.__call__` är "
"också en anropbar."

#: ../../glossary.rst:244
msgid "callback"
msgstr "återuppringning"

#: ../../glossary.rst:246
msgid ""
"A subroutine function which is passed as an argument to be executed at some "
"point in the future."
msgstr ""
"En subrutinfunktion som skickas som ett argument för att utföras vid någon "
"tidpunkt i framtiden."

#: ../../glossary.rst:248
msgid "class"
msgstr "klass"

#: ../../glossary.rst:250
msgid ""
"A template for creating user-defined objects. Class definitions normally "
"contain method definitions which operate on instances of the class."
msgstr ""
"En mall för att skapa användardefinierade objekt. Klassdefinitioner "
"innehåller normalt metoddefinitioner som fungerar på instanser av klassen."

#: ../../glossary.rst:253
msgid "class variable"
msgstr "klassvariabel"

#: ../../glossary.rst:255
msgid ""
"A variable defined in a class and intended to be modified only at class "
"level (i.e., not in an instance of the class)."
msgstr ""
"En variabel som definieras i en klass och som är avsedd att ändras endast på "
"klassnivå (dvs. inte i en instans av klassen)."

#: ../../glossary.rst:257
msgid "closure variable"
msgstr "stängningsvariabel"

#: ../../glossary.rst:259
msgid ""
"A :term:`free variable` referenced from a :term:`nested scope` that is "
"defined in an outer scope rather than being resolved at runtime from the "
"globals or builtin namespaces. May be explicitly defined with the :keyword:"
"`nonlocal` keyword to allow write access, or implicitly defined if the "
"variable is only being read."
msgstr ""
"En :term:`free variable` som refereras från en :term:`nested scope` som "
"definieras i ett yttre scope istället för att lösas vid körning från globals "
"eller inbyggda namnrymder. Kan definieras explicit med nyckelordet :keyword:"
"`nonlocal` för att tillåta skrivåtkomst, eller definieras implicit om "
"variabeln bara läses."

#: ../../glossary.rst:264
msgid ""
"For example, in the ``inner`` function in the following code, both ``x`` and "
"``print`` are :term:`free variables <free variable>`, but only ``x`` is a "
"*closure variable*::"
msgstr ""
"Till exempel, i funktionen ``inner`` i följande kod är både ``x`` och "
"``print`` :term:`fria variabler <free variable>`, men bara ``x`` är en "
"*sluten variabel*::"

#: ../../glossary.rst:267
msgid ""
"def outer():\n"
"    x = 0\n"
"    def inner():\n"
"        nonlocal x\n"
"        x += 1\n"
"        print(x)\n"
"    return inner"
msgstr ""
"def yttre():\n"
"    x = 0\n"
"    def inre():\n"
"        icke-lokala x\n"
"        x += 1\n"
"        print(x)\n"
"    returnerar inner"

#: ../../glossary.rst:275
msgid ""
"Due to the :attr:`codeobject.co_freevars` attribute (which, despite its "
"name, only includes the names of closure variables rather than listing all "
"referenced free variables), the more general :term:`free variable` term is "
"sometimes used even when the intended meaning is to refer specifically to "
"closure variables."
msgstr ""
"På grund av attributet :attr:`codeobject.co_freevars` (som, trots sitt namn, "
"endast innehåller namnen på stängningsvariablerna i stället för att lista "
"alla refererade fria variabler) används ibland den mer allmänna termen :term:"
"`free variable` även när den avsedda betydelsen är att referera specifikt "
"till stängningsvariabler."

#: ../../glossary.rst:279
msgid "complex number"
msgstr "komplext tal"

#: ../../glossary.rst:281
msgid ""
"An extension of the familiar real number system in which all numbers are "
"expressed as a sum of a real part and an imaginary part.  Imaginary numbers "
"are real multiples of the imaginary unit (the square root of ``-1``), often "
"written ``i`` in mathematics or ``j`` in engineering.  Python has built-in "
"support for complex numbers, which are written with this latter notation; "
"the imaginary part is written with a ``j`` suffix, e.g., ``3+1j``.  To get "
"access to complex equivalents of the :mod:`math` module, use :mod:`cmath`.  "
"Use of complex numbers is a fairly advanced mathematical feature.  If you're "
"not aware of a need for them, it's almost certain you can safely ignore them."
msgstr ""
"En utvidgning av det välkända reella talsystemet där alla tal uttrycks som "
"en summa av en reell del och en imaginär del.  Imaginära tal är reella "
"multiplar av den imaginära enheten (kvadratroten av ``-1``), ofta skrivet "
"``i`` inom matematiken eller ``j`` inom ingenjörsvetenskapen.  Python har "
"inbyggt stöd för komplexa tal, som skrivs med denna senare notation; den "
"imaginära delen skrivs med ett ``j``-suffix, t.ex. ``3+1j``.  För att få "
"tillgång till komplexa ekvivalenter av modulen :mod:`math`, använd :mod:"
"`cmath`.  Användningen av komplexa tal är en ganska avancerad matematisk "
"funktion.  Om du inte känner till något behov av dem, är det nästan säkert "
"att du kan ignorera dem."

#: ../../glossary.rst:291
msgid "context"
msgstr "sammanhang"

#: ../../glossary.rst:293
msgid ""
"This term has different meanings depending on where and how it is used. Some "
"common meanings:"
msgstr ""
"Denna term har olika betydelser beroende på var och hur den används. Några "
"vanliga betydelser:"

#: ../../glossary.rst:296
msgid ""
"The temporary state or environment established by a :term:`context manager` "
"via a :keyword:`with` statement."
msgstr ""
"Det tillfälliga tillstånd eller den miljö som skapas av en :term:`context "
"manager` via ett :keyword:`with` statement."

#: ../../glossary.rst:298
msgid ""
"The collection of key­value bindings associated with a particular :class:"
"`contextvars.Context` object and accessed via :class:`~contextvars."
"ContextVar` objects.  Also see :term:`context variable`."
msgstr ""
"Samlingen av nyckelvärdesbindningar som associeras med ett visst :class:"
"`contextvars.Context`-objekt och som nås via :class:`~contextvars."
"ContextVar`-objekt.  Se även :term:`kontextvariabel`."

#: ../../glossary.rst:302
msgid ""
"A :class:`contextvars.Context` object.  Also see :term:`current context`."
msgstr ""
"Ett :class:`contextvars.Context`-objekt.  Se även :term:`aktuellt "
"sammanhang`."

#: ../../glossary.rst:304
msgid "context management protocol"
msgstr "protokoll för kontexthantering"

#: ../../glossary.rst:306
msgid ""
"The :meth:`~object.__enter__` and :meth:`~object.__exit__` methods called by "
"the :keyword:`with` statement.  See :pep:`343`."
msgstr ""
"Metoderna :meth:`~object.__enter__` och :meth:`~object.__exit__` som anropas "
"av :keyword:`with`-satsen.  Se :pep:`343`."

#: ../../glossary.rst:308
msgid "context manager"
msgstr "kontexthanterare"

#: ../../glossary.rst:310
msgid ""
"An object which implements the :term:`context management protocol` and "
"controls the environment seen in a :keyword:`with` statement.  See :pep:"
"`343`."
msgstr ""
"Ett objekt som implementerar :term:`context management protocol` och styr "
"den miljö som visas i en :keyword:`with`-sats.  Se :pep:`343`."

#: ../../glossary.rst:313
msgid "context variable"
msgstr "kontextvariabel"

#: ../../glossary.rst:315
msgid ""
"A variable whose value depends on which context is the :term:`current "
"context`.  Values are accessed via :class:`contextvars.ContextVar` objects.  "
"Context variables are primarily used to isolate state between concurrent "
"asynchronous tasks."
msgstr ""
"En variabel vars värde beror på vilken kontext som är :term:`aktuell "
"kontext`.  Värdena nås via :class:`contextvars.ContextVar`-objekt.  "
"Kontextvariabler används främst för att isolera tillstånd mellan samtidiga "
"asynkrona uppgifter."

#: ../../glossary.rst:319
msgid "contiguous"
msgstr "angränsande"

#: ../../glossary.rst:323
msgid ""
"A buffer is considered contiguous exactly if it is either *C-contiguous* or "
"*Fortran contiguous*.  Zero-dimensional buffers are C and Fortran "
"contiguous.  In one-dimensional arrays, the items must be laid out in memory "
"next to each other, in order of increasing indexes starting from zero.  In "
"multidimensional C-contiguous arrays, the last index varies the fastest when "
"visiting items in order of memory address.  However, in Fortran contiguous "
"arrays, the first index varies the fastest."
msgstr ""
"En buffert anses vara sammanhängande exakt om den är antingen *C-"
"sammanhängande* eller *Fortran-sammanhängande*.  Nolldimensionella buffertar "
"är C- och Fortran-slutna.  I endimensionella matriser måste objekten "
"placeras i minnet bredvid varandra, i ordning efter ökande index med början "
"från noll.  I flerdimensionella C-kontiguösa matriser varierar det sista "
"indexet snabbast när man besöker objekten i ordning efter minnesadress.  I "
"Fortrans sammanhängande matriser är det dock det första indexet som varierar "
"snabbast."

#: ../../glossary.rst:331
msgid "coroutine"
msgstr "coroutine"

#: ../../glossary.rst:333
msgid ""
"Coroutines are a more generalized form of subroutines. Subroutines are "
"entered at one point and exited at another point.  Coroutines can be "
"entered, exited, and resumed at many different points.  They can be "
"implemented with the :keyword:`async def` statement.  See also :pep:`492`."
msgstr ""
"Coroutines är en mer generaliserad form av subroutines. Subrutiner startas "
"vid en punkt och avslutas vid en annan punkt.  Coroutines kan startas, "
"avslutas och återupptas på många olika ställen.  De kan implementeras med :"
"keyword:`async def`-satsen.  Se även :pep:`492`."

#: ../../glossary.rst:338
msgid "coroutine function"
msgstr "coroutine-funktion"

#: ../../glossary.rst:340
msgid ""
"A function which returns a :term:`coroutine` object.  A coroutine function "
"may be defined with the :keyword:`async def` statement, and may contain :"
"keyword:`await`, :keyword:`async for`, and :keyword:`async with` keywords.  "
"These were introduced by :pep:`492`."
msgstr ""
"En funktion som returnerar ett :term:`coroutine`-objekt.  En coroutine-"
"funktion kan definieras med :keyword:`async def`-satsen och kan innehålla "
"nyckelorden :keyword:`await`, :keyword:`async for` och :keyword:`async "
"with`.  Dessa introducerades av :pep:`492`."

#: ../../glossary.rst:345
msgid "CPython"
msgstr "CPython"

#: ../../glossary.rst:347
msgid ""
"The canonical implementation of the Python programming language, as "
"distributed on `python.org <https://www.python.org>`_.  The term \"CPython\" "
"is used when necessary to distinguish this implementation from others such "
"as Jython or IronPython."
msgstr ""
"Den kanoniska implementationen av programmeringsspråket Python, som "
"distribueras på `python.org <https://www.python.org>`_.  Termen \"CPython\" "
"används när det är nödvändigt för att skilja denna implementering från andra "
"som Jython eller IronPython."

#: ../../glossary.rst:351
msgid "current context"
msgstr "nuvarande sammanhang"

#: ../../glossary.rst:353
msgid ""
"The :term:`context` (:class:`contextvars.Context` object) that is currently "
"used by :class:`~contextvars.ContextVar` objects to access (get or set) the "
"values of :term:`context variables <context variable>`.  Each thread has its "
"own current context.  Frameworks for executing asynchronous tasks (see :mod:"
"`asyncio`) associate each task with a context which becomes the current "
"context whenever the task starts or resumes execution."
msgstr ""
"Den :term:`kontext` (:class:`contextvars.Context`-objekt) som för närvarande "
"används av :class:`~contextvars.ContextVar`-objekt för att komma åt (hämta "
"eller ställa in) värdena för :term:`kontextvariabler <context variable>`.  "
"Varje tråd har sin egen aktuella kontext.  Ramverk för att utföra asynkrona "
"uppgifter (se :mod:`asyncio`) associerar varje uppgift med en kontext som "
"blir den aktuella kontexten när uppgiften startar eller återupptar körningen."

#: ../../glossary.rst:359
msgid "cyclic isolate"
msgstr "cykliskt isolat"

#: ../../glossary.rst:361
msgid ""
"A subgroup of one or more objects that reference each other in a reference "
"cycle, but are not referenced by objects outside the group.  The goal of "
"the :term:`cyclic garbage collector <garbage collection>` is to identify "
"these groups and break the reference cycles so that the memory can be "
"reclaimed."
msgstr ""
"En undergrupp av ett eller flera objekt som refererar till varandra i en "
"referenscykel, men som inte refereras till av objekt utanför gruppen.  Målet "
"med :term:``cyclic garbage collector <garbage collection>`` är att "
"identifiera dessa grupper och bryta referenscyklerna så att minnet kan "
"återvinnas."

#: ../../glossary.rst:365
msgid "decorator"
msgstr "dekoratör"

#: ../../glossary.rst:367
msgid ""
"A function returning another function, usually applied as a function "
"transformation using the ``@wrapper`` syntax.  Common examples for "
"decorators are :func:`classmethod` and :func:`staticmethod`."
msgstr ""
"En funktion som returnerar en annan funktion, vanligtvis tillämpad som en "
"funktionstransformation med hjälp av syntaxen ``@wrapper``.  Vanliga exempel "
"på dekoratorer är :func:`classmethod` och :func:`staticmethod`."

#: ../../glossary.rst:371
msgid ""
"The decorator syntax is merely syntactic sugar, the following two function "
"definitions are semantically equivalent::"
msgstr ""
"Dekoratorsyntaxen är bara syntaktiskt socker, följande två "
"funktionsdefinitioner är semantiskt likvärdiga::"

#: ../../glossary.rst:374
msgid ""
"def f(arg):\n"
"    ...\n"
"f = staticmethod(f)\n"
"\n"
"@staticmethod\n"
"def f(arg):\n"
"    ..."
msgstr ""
"def f(arg):\n"
"    ...\n"
"f = staticmethod(f)\n"
"\n"
"@statiskmetod\n"
"def f(arg):\n"
"    ..."

#: ../../glossary.rst:382
msgid ""
"The same concept exists for classes, but is less commonly used there.  See "
"the documentation for :ref:`function definitions <function>` and :ref:`class "
"definitions <class>` for more about decorators."
msgstr ""
"Samma koncept finns för klasser, men är mindre vanligt förekommande där.  Se "
"dokumentationen för :ref:`funktionsdefinitioner <function>` och :ref:"
"`klassdefinitioner <class>` för mer information om dekoratorer."

#: ../../glossary.rst:385
msgid "descriptor"
msgstr "deskriptor"

#: ../../glossary.rst:387
msgid ""
"Any object which defines the methods :meth:`~object.__get__`, :meth:`~object."
"__set__`, or :meth:`~object.__delete__`. When a class attribute is a "
"descriptor, its special binding behavior is triggered upon attribute "
"lookup.  Normally, using *a.b* to get, set or delete an attribute looks up "
"the object named *b* in the class dictionary for *a*, but if *b* is a "
"descriptor, the respective descriptor method gets called.  Understanding "
"descriptors is a key to a deep understanding of Python because they are the "
"basis for many features including functions, methods, properties, class "
"methods, static methods, and reference to super classes."
msgstr ""
"Alla objekt som definierar metoderna :meth:`~object.__get__`, :meth:`~object."
"__set__` eller :meth:`~object.__delete__`. När ett klassattribut är en "
"deskriptor utlöses dess speciella bindningsbeteende vid "
"attributuppslagning.  Om du använder *a.b* för att hämta, ställa in eller ta "
"bort ett attribut slås normalt objektet med namnet *b* upp i klassordlistan "
"för *a*, men om *b* är en deskriptor anropas respektive deskriptormetod.  "
"Att förstå deskriptorer är en nyckel till en djup förståelse av Python "
"eftersom de utgör grunden för många funktioner, inklusive funktioner, "
"metoder, egenskaper, klassmetoder, statiska metoder och referenser till "
"superklasser."

#: ../../glossary.rst:398
msgid ""
"For more information about descriptors' methods, see :ref:`descriptors` or "
"the :ref:`Descriptor How To Guide <descriptorhowto>`."
msgstr ""
"Mer information om metoder för beskrivare finns i :ref:`descriptors` eller :"
"ref:`Descriptor How To Guide <descriptorhowto>`."

#: ../../glossary.rst:400
msgid "dictionary"
msgstr "ordbok"

#: ../../glossary.rst:402
msgid ""
"An associative array, where arbitrary keys are mapped to values.  The keys "
"can be any object with :meth:`~object.__hash__` and :meth:`~object.__eq__` "
"methods. Called a hash in Perl."
msgstr ""
"En associativ array där godtyckliga nycklar mappas till värden.  Nycklarna "
"kan vara valfritt objekt med metoderna :meth:`~object.__hash__` och :meth:"
"`~object.__eq__`. Kallas en hash i Perl."

#: ../../glossary.rst:406
msgid "dictionary comprehension"
msgstr "ordbok förståelse"

#: ../../glossary.rst:408
msgid ""
"A compact way to process all or part of the elements in an iterable and "
"return a dictionary with the results. ``results = {n: n ** 2 for n in "
"range(10)}`` generates a dictionary containing key ``n`` mapped to value ``n "
"** 2``. See :ref:`comprehensions`."
msgstr ""
"Ett kompakt sätt att bearbeta alla eller delar av elementen i en iterabel "
"och returnera en ordbok med resultaten. ``results = {n: n ** 2 for n in "
"range(10)}`` genererar en ordbok som innehåller nyckeln ``n`` mappad till "
"värdet ``n ** 2``. Se :ref:`förståelse`."

#: ../../glossary.rst:412
msgid "dictionary view"
msgstr "ordboksvy"

#: ../../glossary.rst:414
msgid ""
"The objects returned from :meth:`dict.keys`, :meth:`dict.values`, and :meth:"
"`dict.items` are called dictionary views. They provide a dynamic view on the "
"dictionary’s entries, which means that when the dictionary changes, the view "
"reflects these changes. To force the dictionary view to become a full list "
"use ``list(dictview)``.  See :ref:`dict-views`."
msgstr ""
"De objekt som returneras från :meth:`dict.keys`, :meth:`dict.values` och :"
"meth:`dict.items` kallas ordboksvyer. De ger en dynamisk vy över ordbokens "
"poster, vilket innebär att när ordboken ändras återspeglas dessa ändringar i "
"vyn. För att tvinga ordboksvyn att bli en fullständig lista, använd "
"``list(dictview)``.  Se :ref:`dict-views`."

#: ../../glossary.rst:420
msgid "docstring"
msgstr "dokumentsträng"

#: ../../glossary.rst:422
msgid ""
"A string literal which appears as the first expression in a class, function "
"or module.  While ignored when the suite is executed, it is recognized by "
"the compiler and put into the :attr:`~definition.__doc__` attribute of the "
"enclosing class, function or module.  Since it is available via "
"introspection, it is the canonical place for documentation of the object."
msgstr ""
"En bokstavsträng som visas som det första uttrycket i en klass, funktion "
"eller modul.  Även om den ignoreras när sviten exekveras, identifieras den "
"av kompilatorn och läggs in i attributet :attr:`~definition.__doc__` i den "
"omslutande klassen, funktionen eller modulen.  Eftersom det är tillgängligt "
"via introspektion är det den kanoniska platsen för dokumentation av objektet."

#: ../../glossary.rst:428
msgid "duck-typing"
msgstr "anka-typning"

#: ../../glossary.rst:430
msgid ""
"A programming style which does not look at an object's type to determine if "
"it has the right interface; instead, the method or attribute is simply "
"called or used (\"If it looks like a duck and quacks like a duck, it must be "
"a duck.\")  By emphasizing interfaces rather than specific types, well-"
"designed code improves its flexibility by allowing polymorphic "
"substitution.  Duck-typing avoids tests using :func:`type` or :func:"
"`isinstance`.  (Note, however, that duck-typing can be complemented with :"
"term:`abstract base classes <abstract base class>`.)  Instead, it typically "
"employs :func:`hasattr` tests or :term:`EAFP` programming."
msgstr ""
"En programmeringsstil som inte tittar på ett objekts typ för att avgöra om "
"det har rätt gränssnitt; istället anropas eller används metoden eller "
"attributet helt enkelt (\"Om det ser ut som en anka och kvackar som en anka, "
"måste det vara en anka.\") Genom att betona gränssnitt snarare än specifika "
"typer förbättrar väldesignad kod sin flexibilitet genom att tillåta polymorf "
"substitution.  Duck-typning undviker tester som använder :func:`type` eller :"
"func:`isinstance`.  (Observera dock att duck-typing kan kompletteras med :"
"term:`abstrakta basklasser <abstract base class>`.)  Istället används "
"typiskt :func:`hasattr`-tester eller :term:`EAFP`-programmering."

#: ../../glossary.rst:439
msgid "dunder"
msgstr "dunder"

#: ../../glossary.rst:441
msgid ""
"An informal short-hand for \"double underscore\", used when talking about a :"
"term:`special method`. For example, ``__init__`` is often pronounced "
"\"dunder init\"."
msgstr ""

#: ../../glossary.rst:444
msgid "EAFP"
msgstr "EAFP"

#: ../../glossary.rst:446
msgid ""
"Easier to ask for forgiveness than permission.  This common Python coding "
"style assumes the existence of valid keys or attributes and catches "
"exceptions if the assumption proves false.  This clean and fast style is "
"characterized by the presence of many :keyword:`try` and :keyword:`except` "
"statements.  The technique contrasts with the :term:`LBYL` style common to "
"many other languages such as C."
msgstr ""
"Lättare att be om förlåtelse än om tillåtelse.  Denna vanliga Python-"
"kodningsstil förutsätter att det finns giltiga nycklar eller attribut och "
"fångar upp undantag om antagandet visar sig vara felaktigt.  Denna rena och "
"snabba stil kännetecknas av att det finns många :keyword:`try` och :keyword:"
"`except`-satser.  Tekniken står i kontrast till :term:`LBYL`-stilen som är "
"vanlig i många andra språk, t.ex. C."

#: ../../glossary.rst:452
msgid "evaluate function"
msgstr "utvärdera funktion"

#: ../../glossary.rst:454
msgid ""
"A function that can be called to evaluate a lazily evaluated attribute of an "
"object, such as the value of type aliases created with the :keyword:`type` "
"statement."
msgstr ""
"En funktion som kan anropas för att utvärdera ett attribut i ett objekt som "
"utvärderas på ett lättsamt sätt, t.ex. värdet på typaliaser som skapats med :"
"keyword:`type`."

#: ../../glossary.rst:457
msgid "expression"
msgstr "uttryck"

#: ../../glossary.rst:459
msgid ""
"A piece of syntax which can be evaluated to some value.  In other words, an "
"expression is an accumulation of expression elements like literals, names, "
"attribute access, operators or function calls which all return a value.  In "
"contrast to many other languages, not all language constructs are "
"expressions.  There are also :term:`statement`\\s which cannot be used as "
"expressions, such as :keyword:`while`.  Assignments are also statements, not "
"expressions."
msgstr ""
"En del av syntaxen som kan utvärderas till ett visst värde.  Med andra ord "
"är ett uttryck en ansamling av uttryckselement som literaler, namn, "
"attributåtkomst, operatorer eller funktionsanrop som alla returnerar ett "
"värde.  I motsats till många andra språk är inte alla språkkonstruktioner "
"uttryck.  Det finns också :term:`statement` som inte kan användas som "
"uttryck, t.ex. :keyword:`while`.  Tilldelningar är också påståenden, inte "
"uttryck."

#: ../../glossary.rst:466
msgid "extension module"
msgstr "förlängningsmodul"

#: ../../glossary.rst:468
msgid ""
"A module written in C or C++, using Python's C API to interact with the core "
"and with user code."
msgstr ""
"En modul skriven i C eller C++ som använder Pythons C API för att interagera "
"med kärnan och med användarkod."

#: ../../glossary.rst:470
msgid "f-string"
msgstr "f-sträng"

#: ../../glossary.rst:471
msgid "f-strings"
msgstr "f-strängar"

#: ../../glossary.rst:473
msgid ""
"String literals prefixed with ``f`` or ``F`` are commonly called \"f-"
"strings\" which is short for :ref:`formatted string literals <f-strings>`.  "
"See also :pep:`498`."
msgstr ""
"Stränglitteraler med prefixet ``f`` eller ``F`` kallas vanligen \"f-"
"strings\" vilket är en förkortning av :ref:`formatted string literals <f-"
"strings>`.  Se även :pep:`498`."

#: ../../glossary.rst:476
msgid "file object"
msgstr "filobjekt"

#: ../../glossary.rst:478
msgid ""
"An object exposing a file-oriented API (with methods such as :meth:`!read` "
"or :meth:`!write`) to an underlying resource.  Depending on the way it was "
"created, a file object can mediate access to a real on-disk file or to "
"another type of storage or communication device (for example standard input/"
"output, in-memory buffers, sockets, pipes, etc.).  File objects are also "
"called :dfn:`file-like objects` or :dfn:`streams`."
msgstr ""
"Ett objekt som exponerar ett filorienterat API (med metoder som :meth:`!"
"read` eller :meth:`!write`) till en underliggande resurs.  Beroende på hur "
"det skapades kan ett filobjekt förmedla åtkomst till en riktig fil på disken "
"eller till en annan typ av lagrings- eller kommunikationsenhet (t.ex. "
"standardinmatning/utmatning, minnesbuffertar, socklar, pipes etc.).  "
"Filobjekt kallas också :dfn:`filliknande objekt` eller :dfn:`strömmar`."

#: ../../glossary.rst:486
msgid ""
"There are actually three categories of file objects: raw :term:`binary files "
"<binary file>`, buffered :term:`binary files <binary file>` and :term:`text "
"files <text file>`. Their interfaces are defined in the :mod:`io` module.  "
"The canonical way to create a file object is by using the :func:`open` "
"function."
msgstr ""
"Det finns faktiskt tre kategorier av filobjekt: råa :term:`binärfiler "
"<binary file>`, buffrade :term:`binärfiler <binary file>` och :term:"
"`textfiler <text file>`. Deras gränssnitt definieras i modulen :mod:`io`.  "
"Det kanoniska sättet att skapa ett filobjekt är genom att använda "
"funktionen :func:`open`."

#: ../../glossary.rst:491
msgid "file-like object"
msgstr "filliknande objekt"

#: ../../glossary.rst:493
msgid "A synonym for :term:`file object`."
msgstr "En synonym till :term:`filobjekt`."

#: ../../glossary.rst:494
msgid "filesystem encoding and error handler"
msgstr "kodning av filsystem och felhantering"

#: ../../glossary.rst:496
msgid ""
"Encoding and error handler used by Python to decode bytes from the operating "
"system and encode Unicode to the operating system."
msgstr ""
"Kodning och felhantering som används av Python för att avkoda bytes från "
"operativsystemet och koda Unicode till operativsystemet."

#: ../../glossary.rst:499
msgid ""
"The filesystem encoding must guarantee to successfully decode all bytes "
"below 128. If the file system encoding fails to provide this guarantee, API "
"functions can raise :exc:`UnicodeError`."
msgstr ""
"Filsystemets kodning måste garantera att alla byte under 128 avkodas "
"framgångsrikt. Om filsystemets kodning inte kan ge denna garanti kan API-"
"funktioner ge upphov till :exc:`UnicodeError`."

#: ../../glossary.rst:503
msgid ""
"The :func:`sys.getfilesystemencoding` and :func:`sys."
"getfilesystemencodeerrors` functions can be used to get the filesystem "
"encoding and error handler."
msgstr ""
"Funktionerna :func:`sys.getfilesystemencoding` och :func:`sys."
"getfilesystemencodeerrors` kan användas för att hämta filsystemets kodning "
"och felhantering."

#: ../../glossary.rst:507
msgid ""
"The :term:`filesystem encoding and error handler` are configured at Python "
"startup by the :c:func:`PyConfig_Read` function: see :c:member:`~PyConfig."
"filesystem_encoding` and :c:member:`~PyConfig.filesystem_errors` members of :"
"c:type:`PyConfig`."
msgstr ""
":term:`filsystemets kodning och felhantering` konfigureras vid Python-start "
"av funktionen :c:func:`PyConfig_Read`: se :c:member:`~PyConfig."
"filesystem_encoding` och :c:member:`~PyConfig.filesystem_errors` i :c:type:"
"`PyConfig`."

#: ../../glossary.rst:512
msgid "See also the :term:`locale encoding`."
msgstr "Se även :term:`locale encoding`."

#: ../../glossary.rst:513
msgid "finder"
msgstr "sökare"

#: ../../glossary.rst:515
msgid ""
"An object that tries to find the :term:`loader` for a module that is being "
"imported."
msgstr ""
"Ett objekt som försöker hitta :term:`loader` för en modul som håller på att "
"importeras."

#: ../../glossary.rst:518
msgid ""
"There are two types of finder: :term:`meta path finders <meta path finder>` "
"for use with :data:`sys.meta_path`, and :term:`path entry finders <path "
"entry finder>` for use with :data:`sys.path_hooks`."
msgstr ""
"Det finns två typer av sökare: :term:`meta path finders <meta path finder>` "
"för användning med :data:`sys.meta_path`, och :term:`path entry finders "
"<path entry finder>` för användning med :data:`sys.path_hooks`."

#: ../../glossary.rst:522
msgid ""
"See :ref:`finders-and-loaders` and :mod:`importlib` for much more detail."
msgstr ""
"Se :ref:`finders-and-loaders` och :mod:`importlib` för mycket mer "
"information."

#: ../../glossary.rst:523
msgid "floor division"
msgstr "våningsindelning"

#: ../../glossary.rst:525
msgid ""
"Mathematical division that rounds down to nearest integer.  The floor "
"division operator is ``//``.  For example, the expression ``11 // 4`` "
"evaluates to ``2`` in contrast to the ``2.75`` returned by float true "
"division.  Note that ``(-11) // 4`` is ``-3`` because that is ``-2.75`` "
"rounded *downward*. See :pep:`238`."
msgstr ""
"Matematisk division som avrundar ner till närmaste heltal.  Operatorn för "
"golvdivision är ``//``.  Till exempel utvärderas uttrycket ``11 // 4`` till "
"``2`` i motsats till ``2,75`` som returneras av float true division.  "
"Observera att ``(-11) // 4`` är ``-3`` eftersom det är ``-2,75`` avrundat "
"*nedåt*. Se :pep:`238`."

#: ../../glossary.rst:530
msgid "free threading"
msgstr "gratis trådning"

#: ../../glossary.rst:532
msgid ""
"A threading model where multiple threads can run Python bytecode "
"simultaneously within the same interpreter.  This is in contrast to the :"
"term:`global interpreter lock` which allows only one thread to execute "
"Python bytecode at a time.  See :pep:`703`."
msgstr ""
"En trådningsmodell där flera trådar kan köra Python-bytekod samtidigt inom "
"samma tolk.  Detta är i motsats till :term:`global interpreter lock` som "
"tillåter endast en tråd att köra Python bytecode åt gången.  Se :pep:`703`."

#: ../../glossary.rst:536
msgid "free variable"
msgstr "fri variabel"

#: ../../glossary.rst:538
msgid ""
"Formally, as defined in the :ref:`language execution model <bind_names>`, a "
"free variable is any variable used in a namespace which is not a local "
"variable in that namespace. See :term:`closure variable` for an example. "
"Pragmatically, due to the name of the :attr:`codeobject.co_freevars` "
"attribute, the term is also sometimes used as a synonym for :term:`closure "
"variable`."
msgstr ""
"Formellt, enligt definitionen i :ref:``language execution model "
"<bind_names>`, är en fri variabel en variabel som används i en namnrymd och "
"som inte är en lokal variabel i den namnrymden. Se :term:`closure variable` "
"för ett exempel. Pragmatiskt, på grund av namnet på attributet :attr:"
"`codeobject.co_freevars`, används termen ibland också som en synonym till :"
"term:`closure variable`."

#: ../../glossary.rst:543
msgid "function"
msgstr "funktion"

#: ../../glossary.rst:545
msgid ""
"A series of statements which returns some value to a caller. It can also be "
"passed zero or more :term:`arguments <argument>` which may be used in the "
"execution of the body. See also :term:`parameter`, :term:`method`, and the :"
"ref:`function` section."
msgstr ""
"En serie satser som returnerar ett värde till den som anropar. Den kan också "
"få noll eller fler :term:`arguments <argument>` som kan användas vid "
"exekveringen. Se även :term:`parameter`, :term:`method` och avsnittet :ref:"
"`function`."

#: ../../glossary.rst:549
msgid "function annotation"
msgstr "funktion anteckning"

#: ../../glossary.rst:551
msgid "An :term:`annotation` of a function parameter or return value."
msgstr "En :term:`annotation` av en funktionsparameter eller ett returvärde."

#: ../../glossary.rst:553
msgid ""
"Function annotations are usually used for :term:`type hints <type hint>`: "
"for example, this function is expected to take two :class:`int` arguments "
"and is also expected to have an :class:`int` return value::"
msgstr ""
"Funktionsannoteringar används vanligtvis för :term:`type hints <type hint>`: "
"till exempel förväntas den här funktionen ta två :class:`int`-argument och "
"förväntas också ha ett :class:`int`-returvärde::"

#: ../../glossary.rst:558
msgid ""
"def sum_two_numbers(a: int, b: int) -> int:\n"
"   return a + b"
msgstr ""
"def sum_two_numbers(a: int, b: int) -> int:\n"
"   returnerar a + b"

#: ../../glossary.rst:561
msgid "Function annotation syntax is explained in section :ref:`function`."
msgstr ""
"Syntaxen för funktionsannoteringar förklaras i avsnittet :ref:`function`."

#: ../../glossary.rst:563
msgid ""
"See :term:`variable annotation` and :pep:`484`, which describe this "
"functionality. Also see :ref:`annotations-howto` for best practices on "
"working with annotations."
msgstr ""
"Se :term:`variable annotation` och :pep:`484`, som beskriver denna "
"funktionalitet. Se även :ref:`annotations-howto` för bästa praxis för att "
"arbeta med annoteringar."

#: ../../glossary.rst:567
msgid "__future__"
msgstr "__framtid__"

#: ../../glossary.rst:569
msgid ""
"A :ref:`future statement <future>`, ``from __future__ import <feature>``, "
"directs the compiler to compile the current module using syntax or semantics "
"that will become standard in a future release of Python. The :mod:"
"`__future__` module documents the possible values of *feature*.  By "
"importing this module and evaluating its variables, you can see when a new "
"feature was first added to the language and when it will (or did) become the "
"default::"
msgstr ""
"En :ref:``future statement <future>`, ``from __future__ import <feature>``, "
"instruerar kompilatorn att kompilera den aktuella modulen med syntax eller "
"semantik som kommer att bli standard i en framtida version av Python. "
"Modulen :mod:`__future__` dokumenterar de möjliga värdena för *feature*.  "
"Genom att importera denna modul och utvärdera dess variabler kan du se när "
"en ny funktion först lades till i språket och när den kommer att (eller har) "
"bli standard::"

#: ../../glossary.rst:577
msgid ""
">>> import __future__\n"
">>> __future__.division\n"
"_Feature((2, 2, 0, 'alpha', 2), (3, 0, 0, 'alpha', 0), 8192)"
msgstr ""
">>> import __future__\n"
">>> __future__.division\n"
"_Feature((2, 2, 0, 'alpha', 2), (3, 0, 0, 'alpha', 0), 8192)"

#: ../../glossary.rst:580
msgid "garbage collection"
msgstr "sophämtning"

#: ../../glossary.rst:582
msgid ""
"The process of freeing memory when it is not used anymore.  Python performs "
"garbage collection via reference counting and a cyclic garbage collector "
"that is able to detect and break reference cycles.  The garbage collector "
"can be controlled using the :mod:`gc` module."
msgstr ""
"Processen att frigöra minne när det inte längre används.  Python utför "
"garbage collection via referensräkning och en cyklisk garbage collector som "
"kan upptäcka och bryta referenscykler.  Skräpsamlaren kan styras med hjälp "
"av modulen :mod:`gc`."

#: ../../glossary.rst:587 ../../glossary.rst:588
msgid "generator"
msgstr "generator"

#: ../../glossary.rst:590
msgid ""
"A function which returns a :term:`generator iterator`.  It looks like a "
"normal function except that it contains :keyword:`yield` expressions for "
"producing a series of values usable in a for-loop or that can be retrieved "
"one at a time with the :func:`next` function."
msgstr ""
"En funktion som returnerar en :term:`generator iterator`.  Den ser ut som en "
"vanlig funktion förutom att den innehåller :keyword:`yield`-uttryck för att "
"producera en serie värden som kan användas i en for-loop eller som kan "
"hämtas ett i taget med funktionen :func:`next`."

#: ../../glossary.rst:595
msgid ""
"Usually refers to a generator function, but may refer to a *generator "
"iterator* in some contexts.  In cases where the intended meaning isn't "
"clear, using the full terms avoids ambiguity."
msgstr ""
"Hänvisar vanligtvis till en generatorfunktion, men kan i vissa sammanhang "
"hänvisa till en *generatoriterator*.  I fall där den avsedda betydelsen inte "
"är tydlig, undviker man tvetydighet genom att använda de fullständiga "
"termerna."

#: ../../glossary.rst:598
msgid "generator iterator"
msgstr "generator iterator"

#: ../../glossary.rst:600
msgid "An object created by a :term:`generator` function."
msgstr "Ett objekt som skapats av en :term:`generator`-funktion."

#: ../../glossary.rst:602
msgid ""
"Each :keyword:`yield` temporarily suspends processing, remembering the "
"execution state (including local variables and pending try-statements).  "
"When the *generator iterator* resumes, it picks up where it left off (in "
"contrast to functions which start fresh on every invocation)."
msgstr ""
"Varje :keyword:`yield` avbryter temporärt bearbetningen och kommer ihåg "
"exekveringstillståndet (inklusive lokala variabler och väntande try-"
"statements).  När *generator iterator* återupptas, fortsätter den där den "
"slutade (i motsats till funktioner som börjar om på nytt vid varje anrop)."

#: ../../glossary.rst:608 ../../glossary.rst:609
msgid "generator expression"
msgstr "generatoruttryck"

#: ../../glossary.rst:611
msgid ""
"An :term:`expression` that returns an :term:`iterator`.  It looks like a "
"normal expression followed by a :keyword:`!for` clause defining a loop "
"variable, range, and an optional :keyword:`!if` clause.  The combined "
"expression generates values for an enclosing function::"
msgstr ""
"En :term:`expression` som returnerar en :term:`iterator`.  Det ser ut som "
"ett vanligt uttryck följt av en :keyword:`!for`-sats som definierar en "
"loopvariabel, ett intervall och en valfri :keyword:`!if`-sats.  Det "
"kombinerade uttrycket genererar värden för en omslutande funktion::"

#: ../../glossary.rst:616
msgid ""
">>> sum(i*i for i in range(10))         # sum of squares 0, 1, 4, ... 81\n"
"285"
msgstr ""
">>> sum(i*i for i in range(10))         # summan av kvadraterna 0, 1, 4, ... "
"81\n"
"285"

#: ../../glossary.rst:618
msgid "generic function"
msgstr "generisk funktion"

#: ../../glossary.rst:620
msgid ""
"A function composed of multiple functions implementing the same operation "
"for different types. Which implementation should be used during a call is "
"determined by the dispatch algorithm."
msgstr ""
"En funktion som består av flera funktioner som implementerar samma operation "
"för olika typer. Vilken implementation som ska användas under ett anrop "
"avgörs av dispatchalgoritmen."

#: ../../glossary.rst:624
msgid ""
"See also the :term:`single dispatch` glossary entry, the :func:`functools."
"singledispatch` decorator, and :pep:`443`."
msgstr ""
"Se även ordlisteposten :term:`single dispatch`, dekoratorn :func:`functools."
"singledispatch` och :pep:`443`."

#: ../../glossary.rst:626
msgid "generic type"
msgstr "generisk typ"

#: ../../glossary.rst:628
msgid ""
"A :term:`type` that can be parameterized; typically a :ref:`container "
"class<sequence-types>` such as :class:`list` or :class:`dict`. Used for :"
"term:`type hints <type hint>` and :term:`annotations <annotation>`."
msgstr ""
"En :term:`typ` som kan parametriseras; typiskt en :ref:`container "
"class<sequence-types>` såsom :class:`list` eller :class:`dict`. Används för :"
"term:`type hints <type hint>` och :term:`annotations <annotation>`."

#: ../../glossary.rst:633
msgid ""
"For more details, see :ref:`generic alias types<types-genericalias>`, :pep:"
"`483`, :pep:`484`, :pep:`585`, and the :mod:`typing` module."
msgstr ""
"För mer information, se :ref:`generic alias types<types-genericalias>`, :pep:"
"`483`, :pep:`484`, :pep:`585`, och modulen :mod:`typing`."

#: ../../glossary.rst:635
msgid "GIL"
msgstr "GIL"

#: ../../glossary.rst:637
msgid "See :term:`global interpreter lock`."
msgstr "Se :term:`globalt tolklås`."

#: ../../glossary.rst:638
msgid "global interpreter lock"
msgstr "globalt tolklås"

#: ../../glossary.rst:640
msgid ""
"The mechanism used by the :term:`CPython` interpreter to assure that only "
"one thread executes Python :term:`bytecode` at a time. This simplifies the "
"CPython implementation by making the object model (including critical built-"
"in types such as :class:`dict`) implicitly safe against concurrent access.  "
"Locking the entire interpreter makes it easier for the interpreter to be "
"multi-threaded, at the expense of much of the parallelism afforded by multi-"
"processor machines."
msgstr ""
"Den mekanism som används av :term:`CPython`-tolken för att säkerställa att "
"endast en tråd kör Python :term:`bytecode` åt gången. Detta förenklar "
"CPython-implementeringen genom att göra objektmodellen (inklusive kritiska "
"inbyggda typer som :class:`dict`) implicit säker mot samtidig åtkomst.  "
"Genom att låsa hela tolken blir det lättare för tolken att vara flertrådad, "
"på bekostnad av mycket av den parallellism som erbjuds av maskiner med flera "
"processorer."

#: ../../glossary.rst:649
msgid ""
"However, some extension modules, either standard or third-party, are "
"designed so as to release the GIL when doing computationally intensive tasks "
"such as compression or hashing.  Also, the GIL is always released when doing "
"I/O."
msgstr ""
"Vissa tilläggsmoduler, antingen standard eller från tredje part, är dock "
"utformade så att de frigör GIL när de utför beräkningsintensiva uppgifter "
"som komprimering eller hashing.  Dessutom frigörs alltid GIL när I/O utförs."

#: ../../glossary.rst:654
msgid ""
"As of Python 3.13, the GIL can be disabled using the :option:`--disable-gil` "
"build configuration. After building Python with this option, code must be "
"run with :option:`-X gil=0 <-X>` or after setting the :envvar:`PYTHON_GIL=0 "
"<PYTHON_GIL>` environment variable. This feature enables improved "
"performance for multi-threaded applications and makes it easier to use multi-"
"core CPUs efficiently. For more details, see :pep:`703`."
msgstr ""
"Från och med Python 3.13 kan GIL inaktiveras med hjälp av "
"byggkonfigurationen :option:`--disable-gil`. Efter att Python har byggts med "
"detta alternativ måste koden köras med :option:`-X gil=0 <-X>` eller efter "
"att miljövariabeln :envvar:`PYTHON_GIL=0 <PYTHON_GIL>` har ställts in. Denna "
"funktion ger förbättrad prestanda för flertrådade program och gör det "
"lättare att använda flerkärniga processorer på ett effektivt sätt. För mer "
"information, se :pep:`703`."

#: ../../glossary.rst:661
msgid ""
"In prior versions of Python's C API, a function might declare that it "
"requires the GIL to be held in order to use it. This refers to having an :"
"term:`attached thread state`."
msgstr ""
"I tidigare versioner av Pythons C API kan en funktion deklarera att den "
"kräver att GIL hålls för att den ska kunna användas. Detta hänvisar till att "
"ha en :term:`attached thread state`."

#: ../../glossary.rst:664
msgid "hash-based pyc"
msgstr "hash-baserad pyc"

#: ../../glossary.rst:666
msgid ""
"A bytecode cache file that uses the hash rather than the last-modified time "
"of the corresponding source file to determine its validity. See :ref:`pyc-"
"invalidation`."
msgstr ""
"En bytecode-cachefil som använder hashen i stället för den senaste "
"modifierade tiden för motsvarande källfil för att avgöra dess giltighet. Se :"
"ref:`pyc-invalidation`."

#: ../../glossary.rst:669
msgid "hashable"
msgstr "hashbar"

#: ../../glossary.rst:671
msgid ""
"An object is *hashable* if it has a hash value which never changes during "
"its lifetime (it needs a :meth:`~object.__hash__` method), and can be "
"compared to other objects (it needs an :meth:`~object.__eq__` method). "
"Hashable objects which compare equal must have the same hash value."
msgstr ""
"Ett objekt är *hashbart* om det har ett hashvärde som aldrig ändras under "
"dess livstid (det behöver en metod :meth:`~object.__hash__`) och kan "
"jämföras med andra objekt (det behöver en metod :meth:`~object.__eq__`). "
"Hashbara objekt som jämförs med varandra måste ha samma hashvärde."

#: ../../glossary.rst:677
msgid ""
"Hashability makes an object usable as a dictionary key and a set member, "
"because these data structures use the hash value internally."
msgstr ""
"Hashbarhet gör att ett objekt kan användas som nyckel i en ordbok och som "
"medlem i ett set, eftersom dessa datastrukturer använder hashvärdet internt."

#: ../../glossary.rst:680
msgid ""
"Most of Python's immutable built-in objects are hashable; mutable containers "
"(such as lists or dictionaries) are not; immutable containers (such as "
"tuples and frozensets) are only hashable if their elements are hashable.  "
"Objects which are instances of user-defined classes are hashable by "
"default.  They all compare unequal (except with themselves), and their hash "
"value is derived from their :func:`id`."
msgstr ""
"De flesta av Pythons oföränderliga inbyggda objekt är hashbara; föränderliga "
"behållare (som listor eller dictionaries) är det inte; oföränderliga "
"behållare (som tuples och frozensets) är bara hashbara om deras element är "
"hashbara.  Objekt som är instanser av användardefinierade klasser är "
"hashbara som standard.  De jämför alla ojämnt (utom med sig själva), och "
"deras hashvärde härleds från deras :func:`id`."

#: ../../glossary.rst:687
msgid "IDLE"
msgstr "IDLE"

#: ../../glossary.rst:689
msgid ""
"An Integrated Development and Learning Environment for Python. :ref:`idle` "
"is a basic editor and interpreter environment which ships with the standard "
"distribution of Python."
msgstr ""
"En integrerad utvecklings- och inlärningsmiljö för Python. :ref:`idle` är en "
"grundläggande redigerings- och tolkmiljö som levereras med "
"standarddistributionen av Python."

#: ../../glossary.rst:692
msgid "immortal"
msgstr "odödlig"

#: ../../glossary.rst:694
msgid ""
"*Immortal objects* are a CPython implementation detail introduced in :pep:"
"`683`."
msgstr ""
"*Immortal objects* är en CPython implementationsdetalj som introducerades i :"
"pep:`683`."

#: ../../glossary.rst:697
msgid ""
"If an object is immortal, its :term:`reference count` is never modified, and "
"therefore it is never deallocated while the interpreter is running. For "
"example, :const:`True` and :const:`None` are immortal in CPython."
msgstr ""
"Om ett objekt är odödligt ändras aldrig dess :term:`referensantal`, och "
"därför avallokeras det aldrig medan tolken körs. Till exempel är :const:"
"`True` och :const:`None` odödliga i CPython."

#: ../../glossary.rst:701
msgid ""
"Immortal objects can be identified via :func:`sys._is_immortal`, or via :c:"
"func:`PyUnstable_IsImmortal` in the C API."
msgstr ""
"Odödliga objekt kan identifieras via :func:`sys._is_immortal`, eller via :c:"
"func:`PyUnstable_IsImmortal` i C API."

#: ../../glossary.rst:703
msgid "immutable"
msgstr "oföränderlig"

#: ../../glossary.rst:705
msgid ""
"An object with a fixed value.  Immutable objects include numbers, strings "
"and tuples.  Such an object cannot be altered.  A new object has to be "
"created if a different value has to be stored.  They play an important role "
"in places where a constant hash value is needed, for example as a key in a "
"dictionary."
msgstr ""
"Ett objekt med ett fast värde.  Till de oföränderliga objekten hör tal, "
"strängar och tupler.  Ett sådant objekt kan inte ändras.  Ett nytt objekt "
"måste skapas om ett annat värde ska lagras.  De spelar en viktig roll på "
"platser där det behövs ett konstant hashvärde, till exempel som nyckel i en "
"ordbok."

#: ../../glossary.rst:710
msgid "import path"
msgstr "importväg"

#: ../../glossary.rst:712
msgid ""
"A list of locations (or :term:`path entries <path entry>`) that are searched "
"by the :term:`path based finder` for modules to import. During import, this "
"list of locations usually comes from :data:`sys.path`, but for subpackages "
"it may also come from the parent package's ``__path__`` attribute."
msgstr ""
"En lista med platser (eller :term:`path entries <path entry>`) som söks av :"
"term:`path based finder` efter moduler att importera. Under importen kommer "
"denna lista med platser vanligtvis från :data:`sys.path`, men för underpaket "
"kan den också komma från det överordnade paketets ``__path__``-attribut."

#: ../../glossary.rst:717
msgid "importing"
msgstr "import"

#: ../../glossary.rst:719
msgid ""
"The process by which Python code in one module is made available to Python "
"code in another module."
msgstr ""
"Den process genom vilken Python-kod i en modul görs tillgänglig för Python-"
"kod i en annan modul."

#: ../../glossary.rst:721
msgid "importer"
msgstr "importör"

#: ../../glossary.rst:723
msgid ""
"An object that both finds and loads a module; both a :term:`finder` and :"
"term:`loader` object."
msgstr ""
"Ett objekt som både hittar och laddar en modul; både ett :term:`finder`- "
"och :term:`loader`-objekt."

#: ../../glossary.rst:725
msgid "interactive"
msgstr "interaktiv"

#: ../../glossary.rst:727
msgid ""
"Python has an interactive interpreter which means you can enter statements "
"and expressions at the interpreter prompt, immediately execute them and see "
"their results.  Just launch ``python`` with no arguments (possibly by "
"selecting it from your computer's main menu). It is a very powerful way to "
"test out new ideas or inspect modules and packages (remember ``help(x)``). "
"For more on interactive mode, see :ref:`tut-interac`."
msgstr ""
"Python har en interaktiv tolk, vilket innebär att du kan skriva in satser "
"och uttryck i tolkens prompt, omedelbart utföra dem och se resultatet.  "
"Starta bara ``python`` utan argument (eventuellt genom att välja det från "
"datorns huvudmeny). Det är ett mycket kraftfullt sätt att testa nya idéer "
"eller inspektera moduler och paket (kom ihåg ``help(x)``). För mer "
"information om interaktivt läge, se :ref:`tut-interac`."

#: ../../glossary.rst:734
msgid "interpreted"
msgstr "tolkad"

#: ../../glossary.rst:736
msgid ""
"Python is an interpreted language, as opposed to a compiled one, though the "
"distinction can be blurry because of the presence of the bytecode compiler.  "
"This means that source files can be run directly without explicitly creating "
"an executable which is then run. Interpreted languages typically have a "
"shorter development/debug cycle than compiled ones, though their programs "
"generally also run more slowly.  See also :term:`interactive`."
msgstr ""
"Python är ett tolkat språk, i motsats till ett kompilerat, även om "
"skillnaden kan vara suddig på grund av förekomsten av bytecode-kompilatorn.  "
"Detta innebär att källfiler kan köras direkt utan att explicit skapa en "
"körbar fil som sedan körs. Tolkade språk har vanligtvis en kortare "
"utvecklings-/debugcykel än kompilerade språk, även om deras program i "
"allmänhet också körs långsammare.  Se även :term:`interaktiv`."

#: ../../glossary.rst:743
msgid "interpreter shutdown"
msgstr "avstängning av tolk"

#: ../../glossary.rst:745
msgid ""
"When asked to shut down, the Python interpreter enters a special phase where "
"it gradually releases all allocated resources, such as modules and various "
"critical internal structures.  It also makes several calls to the :term:"
"`garbage collector <garbage collection>`. This can trigger the execution of "
"code in user-defined destructors or weakref callbacks. Code executed during "
"the shutdown phase can encounter various exceptions as the resources it "
"relies on may not function anymore (common examples are library modules or "
"the warnings machinery)."
msgstr ""
"När Python-tolken ombeds att stänga ner går den in i en speciell fas där den "
"gradvis frigör alla tilldelade resurser, t.ex. moduler och olika kritiska "
"interna strukturer.  Den gör också flera anrop till :term:`garbage collector "
"<garbage collection>`. Detta kan utlösa exekvering av kod i "
"användardefinierade destruktorer eller weakref callbacks. Kod som exekveras "
"under nedstängningsfasen kan stöta på olika undantag eftersom de resurser "
"den förlitar sig på kanske inte fungerar längre (vanliga exempel är "
"biblioteksmoduler eller varningsmaskineriet)."

#: ../../glossary.rst:754
msgid ""
"The main reason for interpreter shutdown is that the ``__main__`` module or "
"the script being run has finished executing."
msgstr ""
"Den främsta orsaken till att tolken stängs av är att modulen ``__main__`` "
"eller det skript som körs har avslutats."

#: ../../glossary.rst:756
msgid "iterable"
msgstr "itererbar"

#: ../../glossary.rst:758
msgid ""
"An object capable of returning its members one at a time. Examples of "
"iterables include all sequence types (such as :class:`list`, :class:`str`, "
"and :class:`tuple`) and some non-sequence types like :class:`dict`, :term:"
"`file objects <file object>`, and objects of any classes you define with an :"
"meth:`~object.__iter__` method or with a :meth:`~object.__getitem__` method "
"that implements :term:`sequence` semantics."
msgstr ""
"Ett objekt som kan returnera sina medlemmar en i taget. Exempel på iterabler "
"är alla sekvenstyper (t.ex. :class:`list`, :class:`str` och :class:`tuple`) "
"och vissa icke-sekvenstyper som :class:`dict`, :term:`file objects <file "
"object>`, och objekt av alla klasser som du definierar med en :meth:`~object."
"__iter__`-metod eller med en :meth:`~object.__getitem__`-metod som "
"implementerar :term:`sequence`-semantik."

#: ../../glossary.rst:766
msgid ""
"Iterables can be used in a :keyword:`for` loop and in many other places "
"where a sequence is needed (:func:`zip`, :func:`map`, ...).  When an "
"iterable object is passed as an argument to the built-in function :func:"
"`iter`, it returns an iterator for the object.  This iterator is good for "
"one pass over the set of values.  When using iterables, it is usually not "
"necessary to call :func:`iter` or deal with iterator objects yourself.  The :"
"keyword:`for` statement does that automatically for you, creating a "
"temporary unnamed variable to hold the iterator for the duration of the "
"loop.  See also :term:`iterator`, :term:`sequence`, and :term:`generator`."
msgstr ""
"Iterabler kan användas i en :keyword:`for`-loop och på många andra ställen "
"där en sekvens behövs (:func:`zip`, :func:`map`, ...).  När ett itererbart "
"objekt skickas som argument till den inbyggda funktionen :func:`iter` "
"returnerar den en iterator för objektet.  Denna iterator räcker för en "
"passage över värdeuppsättningen.  När du använder iterables är det "
"vanligtvis inte nödvändigt att anropa :func:`iter` eller hantera "
"iteratorobjekt själv.  Satsen :keyword:`for` gör det automatiskt åt dig och "
"skapar en tillfällig namnlös variabel som håller iteratorn under hela "
"slingan.  Se även :term:`iterator`, :term:`sequence` och :term:`generator`."

#: ../../glossary.rst:776
msgid "iterator"
msgstr "iterator"

#: ../../glossary.rst:778
msgid ""
"An object representing a stream of data.  Repeated calls to the iterator's :"
"meth:`~iterator.__next__` method (or passing it to the built-in function :"
"func:`next`) return successive items in the stream.  When no more data are "
"available a :exc:`StopIteration` exception is raised instead.  At this "
"point, the iterator object is exhausted and any further calls to its :meth:`!"
"__next__` method just raise :exc:`StopIteration` again.  Iterators are "
"required to have an :meth:`~iterator.__iter__` method that returns the "
"iterator object itself so every iterator is also iterable and may be used in "
"most places where other iterables are accepted.  One notable exception is "
"code which attempts multiple iteration passes.  A container object (such as "
"a :class:`list`) produces a fresh new iterator each time you pass it to the :"
"func:`iter` function or use it in a :keyword:`for` loop.  Attempting this "
"with an iterator will just return the same exhausted iterator object used in "
"the previous iteration pass, making it appear like an empty container."
msgstr ""
"Ett objekt som representerar en dataström.  Upprepade anrop till iteratorns "
"metod :meth:`~iterator.__next__` (eller genom att skicka den till den "
"inbyggda funktionen :func:`next`) returnerar successiva objekt i strömmen.  "
"När inga fler data finns tillgängliga utlöses istället ett :exc:"
"`StopIteration`-undantag.  Vid denna tidpunkt är iteratorobjektet uttömt och "
"eventuella ytterligare anrop till dess :meth:`!__next__`-metod ger bara "
"upphov till :exc:`StopIteration` igen.  Iteratorer måste ha en :meth:"
"`~iterator.__iter__`-metod som returnerar själva iteratorobjektet, så varje "
"iterator är också en iterabel och kan användas på de flesta ställen där "
"andra iterabler accepteras.  Ett anmärkningsvärt undantag är kod som "
"försöker sig på flera iterationspass.  Ett containerobjekt (t.ex. en :class:"
"`list`) producerar en ny iterator varje gång du skickar den till :func:"
"`iter`-funktionen eller använder den i en :keyword:`for`-loop.  Om du "
"försöker göra detta med en iterator kommer du bara att returnera samma "
"uttömda iteratorobjekt som användes i föregående iterationspass, vilket får "
"det att se ut som en tom behållare."

#: ../../glossary.rst:793
msgid "More information can be found in :ref:`typeiter`."
msgstr "Mer information finns i :ref:`typeiter`."

#: ../../glossary.rst:797
msgid ""
"CPython does not consistently apply the requirement that an iterator define :"
"meth:`~iterator.__iter__`. And also please note that the free-threading "
"CPython does not guarantee the thread-safety of iterator operations."
msgstr ""
"CPython tillämpar inte konsekvent kravet på att en iterator definierar :meth:"
"`~iterator.__iter__`. Observera också att CPython med fri trådning inte "
"garanterar trådsäkerhet för iteratoroperationer."

#: ../../glossary.rst:802
msgid "key function"
msgstr "knappfunktion"

#: ../../glossary.rst:804
msgid ""
"A key function or collation function is a callable that returns a value used "
"for sorting or ordering.  For example, :func:`locale.strxfrm` is used to "
"produce a sort key that is aware of locale specific sort conventions."
msgstr ""
"En nyckelfunktion eller sorteringsfunktion är en anropsbar funktion som "
"returnerar ett värde som används för sortering eller ordning.  Till exempel "
"används :func:`locale.strxfrm` för att producera en sorteringsnyckel som är "
"medveten om lokalspecifika sorteringskonventioner."

#: ../../glossary.rst:809
msgid ""
"A number of tools in Python accept key functions to control how elements are "
"ordered or grouped.  They include :func:`min`, :func:`max`, :func:`sorted`, :"
"meth:`list.sort`, :func:`heapq.merge`, :func:`heapq.nsmallest`, :func:`heapq."
"nlargest`, and :func:`itertools.groupby`."
msgstr ""
"Ett antal verktyg i Python accepterar nyckelfunktioner för att styra hur "
"element ordnas eller grupperas.  De inkluderar :func:`min`, :func:`max`, :"
"func:`sorted`, :meth:`list.sort`, :func:`heapq.merge`, :func:`heapq."
"nsmallest`, :func:`heapq.nlargest` och :func:`itertools.groupby`."

#: ../../glossary.rst:815
msgid ""
"There are several ways to create a key function.  For example. the :meth:"
"`str.lower` method can serve as a key function for case insensitive sorts.  "
"Alternatively, a key function can be built from a :keyword:`lambda` "
"expression such as ``lambda r: (r[0], r[2])``.  Also, :func:`operator."
"attrgetter`, :func:`operator.itemgetter`, and :func:`operator.methodcaller` "
"are three key function constructors.  See the :ref:`Sorting HOW TO "
"<sortinghowto>` for examples of how to create and use key functions."
msgstr ""
"Det finns flera sätt att skapa en nyckelfunktion.  Till exempel kan metoden :"
"meth:`str.lower` fungera som en nyckelfunktion för sortering utan hänsyn "
"till skiftlägesskillnader.  Alternativt kan en nyckelfunktion byggas upp "
"från ett :keyword:`lambda`-uttryck som till exempel ``lambda r: (r[0], "
"r[2])``.  Även :func:`operator.attrgetter`, :func:`operator.itemgetter` och :"
"func:`operator.methodcaller` är tre konstruktörer av nyckelfunktioner.  Se :"
"ref:`Sortering HUR <sortinghowto>` för exempel på hur man skapar och "
"använder nyckelfunktioner."

#: ../../glossary.rst:822
msgid "keyword argument"
msgstr "nyckelordsargument"

#: ../../glossary.rst:824 ../../glossary.rst:1148
msgid "See :term:`argument`."
msgstr "Se :term:`argument`."

#: ../../glossary.rst:825
msgid "lambda"
msgstr "lambda"

#: ../../glossary.rst:827
msgid ""
"An anonymous inline function consisting of a single :term:`expression` which "
"is evaluated when the function is called.  The syntax to create a lambda "
"function is ``lambda [parameters]: expression``"
msgstr ""
"En anonym inline-funktion som består av en enda :term:`expression` som "
"utvärderas när funktionen anropas.  Syntaxen för att skapa en lambda-"
"funktion är ``lambda [parametrar]: uttryck``"

#: ../../glossary.rst:830
msgid "LBYL"
msgstr "LBYL"

#: ../../glossary.rst:832
msgid ""
"Look before you leap.  This coding style explicitly tests for pre-conditions "
"before making calls or lookups.  This style contrasts with the :term:`EAFP` "
"approach and is characterized by the presence of many :keyword:`if` "
"statements."
msgstr ""
"Titta innan du hoppar.  Denna kodningsstil testar explicit för "
"förhandsvillkor innan anrop eller uppslagningar görs.  Den här stilen står i "
"kontrast till :term:`EAFP` och kännetecknas av att den innehåller många :"
"keyword:`if`-satser."

#: ../../glossary.rst:837
msgid ""
"In a multi-threaded environment, the LBYL approach can risk introducing a "
"race condition between \"the looking\" and \"the leaping\".  For example, "
"the code, ``if key in mapping: return mapping[key]`` can fail if another "
"thread removes *key* from *mapping* after the test, but before the lookup. "
"This issue can be solved with locks or by using the EAFP approach."
msgstr ""
"I en flertrådig miljö kan LBYL-metoden riskera att införa ett "
"tävlingsvillkor mellan \"the looking\" och \"the leaping\".  Till exempel "
"kan koden ``if key in mapping: return mapping[key]`` misslyckas om en annan "
"tråd tar bort *key* från *mapping* efter testet, men före uppslagningen. "
"Detta problem kan lösas med lås eller genom att använda EAFP-metoden."

#: ../../glossary.rst:842
msgid "lexical analyzer"
msgstr "lexikal analysator"

#: ../../glossary.rst:845
msgid "Formal name for the *tokenizer*; see :term:`token`."
msgstr "Formellt namn för *tokenizer*; se :term:`token`."

#: ../../glossary.rst:846
msgid "list"
msgstr "lista"

#: ../../glossary.rst:848
msgid ""
"A built-in Python :term:`sequence`.  Despite its name it is more akin to an "
"array in other languages than to a linked list since access to elements is "
"*O*\\ (1)."
msgstr ""
"En inbyggd Python :term:`sequence`.  Trots sitt namn är den mer lik en array "
"i andra språk än en länkad lista eftersom åtkomst till element är *O*\\ (1)."

#: ../../glossary.rst:851
msgid "list comprehension"
msgstr "listförståelse"

#: ../../glossary.rst:853
msgid ""
"A compact way to process all or part of the elements in a sequence and "
"return a list with the results.  ``result = ['{:#04x}'.format(x) for x in "
"range(256) if x % 2 == 0]`` generates a list of strings containing even hex "
"numbers (0x..) in the range from 0 to 255. The :keyword:`if` clause is "
"optional.  If omitted, all elements in ``range(256)`` are processed."
msgstr ""
"Ett kompakt sätt att bearbeta alla eller delar av elementen i en sekvens och "
"returnera en lista med resultaten.  ``result = ['{:#04x}'.format(x) for x in "
"range(256) if x % 2 == 0]``` genererar en lista med strängar som innehåller "
"jämna hextal (0x...) i intervallet 0 till 255. Klausulen :keyword:`if` är "
"valfri.  Om den utelämnas bearbetas alla element i ``range(256)``."

#: ../../glossary.rst:859
msgid "loader"
msgstr "lastare"

#: ../../glossary.rst:861
msgid ""
"An object that loads a module. It must define the :meth:`!exec_module` and :"
"meth:`!create_module` methods to implement the :class:`~importlib.abc."
"Loader` interface. A loader is typically returned by a :term:`finder`. See "
"also:"
msgstr ""
"Ett objekt som laddar en modul. Det måste definiera metoderna :meth:`!"
"exec_module` och :meth:`!create_module` för att implementera gränssnittet :"
"class:`~importlib.abc.Loader`. En laddare returneras vanligtvis av en :term:"
"`finder`. Se även följande:"

#: ../../glossary.rst:867
msgid ":ref:`finders-and-loaders`"
msgstr ":ref:`sökare-och-laddare`"

#: ../../glossary.rst:868
msgid ":class:`importlib.abc.Loader`"
msgstr ":klass:`importlib.abc.Loader`"

#: ../../glossary.rst:869
msgid ":pep:`302`"
msgstr ":pep:`302``"

#: ../../glossary.rst:870
msgid "locale encoding"
msgstr "lokal kodning"

#: ../../glossary.rst:872
msgid ""
"On Unix, it is the encoding of the LC_CTYPE locale. It can be set with :func:"
"`locale.setlocale(locale.LC_CTYPE, new_locale) <locale.setlocale>`."
msgstr ""
"På Unix är det kodningen av LC_CTYPE-localen. Den kan ställas in med :func:"
"`locale.setlocale(locale.LC_CTYPE, new_locale) <locale.setlocale>`."

#: ../../glossary.rst:875
msgid "On Windows, it is the ANSI code page (ex: ``\"cp1252\"``)."
msgstr "I Windows är det ANSI-kodsidan (t.ex. ``\"cp1252\"``)."

#: ../../glossary.rst:877
msgid ""
"On Android and VxWorks, Python uses ``\"utf-8\"`` as the locale encoding."
msgstr ""
"På Android och VxWorks använder Python ``\"utf-8\"`` som lokal kodning."

#: ../../glossary.rst:879
msgid ":func:`locale.getencoding` can be used to get the locale encoding."
msgstr ""
":func:`locale.getencoding` kan användas för att hämta locale-kodningen."

#: ../../glossary.rst:881
msgid "See also the :term:`filesystem encoding and error handler`."
msgstr "Se även :term:`filsystemets kodning och felhantering`."

#: ../../glossary.rst:882
msgid "magic method"
msgstr "magisk metod"

#: ../../glossary.rst:886
msgid "An informal synonym for :term:`special method`."
msgstr "En informell synonym till :term:`specialmetod`."

#: ../../glossary.rst:887
msgid "mapping"
msgstr "kartläggning"

#: ../../glossary.rst:889
msgid ""
"A container object that supports arbitrary key lookups and implements the "
"methods specified in the :class:`collections.abc.Mapping` or :class:"
"`collections.abc.MutableMapping` :ref:`abstract base classes <collections-"
"abstract-base-classes>`.  Examples include :class:`dict`, :class:"
"`collections.defaultdict`, :class:`collections.OrderedDict` and :class:"
"`collections.Counter`."
msgstr ""
"Ett containerobjekt som stöder godtyckliga nyckeluppslagningar och "
"implementerar de metoder som anges i :class:`collections.abc.Mapping` eller :"
"class:`collections.abc.MutableMapping` :ref:`abstrakta basklasser "
"<collections-abstract-base-classes>`.  Exempel är :class:`dict`, :class:"
"`collections.defaultdict`, :class:`collections.OrderedDict` och :class:"
"`collections.Counter`."

#: ../../glossary.rst:895
msgid "meta path finder"
msgstr "meta sökväg sökare"

#: ../../glossary.rst:897
msgid ""
"A :term:`finder` returned by a search of :data:`sys.meta_path`.  Meta path "
"finders are related to, but different from :term:`path entry finders <path "
"entry finder>`."
msgstr ""
"En :term:`finner` som returneras av en sökning i :data:`sys.meta_path`.  "
"Meta path finders är relaterade till, men skiljer sig från, :term:`path "
"entry finders <path entry finder>`."

#: ../../glossary.rst:901
msgid ""
"See :class:`importlib.abc.MetaPathFinder` for the methods that meta path "
"finders implement."
msgstr ""
"Se :class:`importlib.abc.MetaPathFinder` för de metoder som "
"metasökvägssökare implementerar."

#: ../../glossary.rst:903
msgid "metaclass"
msgstr "metaklass"

#: ../../glossary.rst:905
msgid ""
"The class of a class.  Class definitions create a class name, a class "
"dictionary, and a list of base classes.  The metaclass is responsible for "
"taking those three arguments and creating the class.  Most object oriented "
"programming languages provide a default implementation.  What makes Python "
"special is that it is possible to create custom metaclasses.  Most users "
"never need this tool, but when the need arises, metaclasses can provide "
"powerful, elegant solutions.  They have been used for logging attribute "
"access, adding thread-safety, tracking object creation, implementing "
"singletons, and many other tasks."
msgstr ""
"Klassen i en klass.  Klassdefinitioner skapar ett klassnamn, en klassordbok "
"och en lista över basklasser.  Metaklassen är ansvarig för att ta dessa tre "
"argument och skapa klassen.  De flesta objektorienterade programmeringsspråk "
"tillhandahåller en standardimplementering.  Det som gör Python speciellt är "
"att det är möjligt att skapa egna metaklasser.  De flesta användare behöver "
"aldrig detta verktyg, men när behovet uppstår kan metaklasser ge kraftfulla "
"och eleganta lösningar.  De har använts för att logga attributåtkomst, lägga "
"till trådsäkerhet, spåra objektskapande, implementera singletons och många "
"andra uppgifter."

#: ../../glossary.rst:915
msgid "More information can be found in :ref:`metaclasses`."
msgstr "Mer information finns i :ref:`metaclasses`."

#: ../../glossary.rst:884 ../../glossary.rst:916 ../../glossary.rst:1299
msgid "method"
msgstr "metod"

#: ../../glossary.rst:918
msgid ""
"A function which is defined inside a class body.  If called as an attribute "
"of an instance of that class, the method will get the instance object as its "
"first :term:`argument` (which is usually called ``self``). See :term:"
"`function` and :term:`nested scope`."
msgstr ""
"En funktion som är definierad inuti en klass.  Om den anropas som ett "
"attribut till en instans av den klassen, kommer metoden att få "
"instansobjektet som sitt första :term:`argument` (som vanligtvis kallas "
"``self``). Se :term:`function` och :term:`nested scope`."

#: ../../glossary.rst:922
msgid "method resolution order"
msgstr "metod upplösning ordning"

#: ../../glossary.rst:924
msgid ""
"Method Resolution Order is the order in which base classes are searched for "
"a member during lookup. See :ref:`python_2.3_mro` for details of the "
"algorithm used by the Python interpreter since the 2.3 release."
msgstr ""
"Method Resolution Order är den ordning i vilken basklasser söks efter en "
"medlem vid uppslagning. Se :ref:`python_2.3_mro` för detaljer om den "
"algoritm som används av Python-tolken sedan 2.3-versionen."

#: ../../glossary.rst:927
msgid "module"
msgstr "modul"

#: ../../glossary.rst:929
msgid ""
"An object that serves as an organizational unit of Python code.  Modules "
"have a namespace containing arbitrary Python objects.  Modules are loaded "
"into Python by the process of :term:`importing`."
msgstr ""
"Ett objekt som fungerar som en organisatorisk enhet i Python-kod.  Moduler "
"har ett namnrymd som innehåller godtyckliga Python-objekt.  Moduler laddas "
"in i Python genom processen :term:`importing`."

#: ../../glossary.rst:933
msgid "See also :term:`package`."
msgstr "Se även :term:`package`."

#: ../../glossary.rst:934
msgid "module spec"
msgstr "modulspecifikation"

#: ../../glossary.rst:936
msgid ""
"A namespace containing the import-related information used to load a module. "
"An instance of :class:`importlib.machinery.ModuleSpec`."
msgstr ""
"En namnrymd som innehåller den importrelaterade information som används för "
"att ladda en modul. En instans av :class:`importlib.machinery.ModuleSpec`."

#: ../../glossary.rst:939
msgid "See also :ref:`module-specs`."
msgstr "Se även :ref:`modul-specs`."

#: ../../glossary.rst:940
msgid "MRO"
msgstr "MRO"

#: ../../glossary.rst:942
msgid "See :term:`method resolution order`."
msgstr "Se :term:`Metodbeslutsordning`."

#: ../../glossary.rst:943
msgid "mutable"
msgstr "föränderlig"

#: ../../glossary.rst:945
msgid ""
"Mutable objects can change their value but keep their :func:`id`.  See also :"
"term:`immutable`."
msgstr ""
"Mutabla objekt kan ändra sitt värde men behålla sitt :func:`id`.  Se även :"
"term:`immutable`."

#: ../../glossary.rst:947
msgid "named tuple"
msgstr "namngiven tupel"

#: ../../glossary.rst:949
msgid ""
"The term \"named tuple\" applies to any type or class that inherits from "
"tuple and whose indexable elements are also accessible using named "
"attributes.  The type or class may have other features as well."
msgstr ""
"Termen \"named tuple\" gäller för en typ eller klass som ärver från tuple "
"och vars indexerbara element också är tillgängliga med hjälp av namngivna "
"attribut.  Typen eller klassen kan även ha andra egenskaper."

#: ../../glossary.rst:953
msgid ""
"Several built-in types are named tuples, including the values returned by :"
"func:`time.localtime` and :func:`os.stat`.  Another example is :data:`sys."
"float_info`::"
msgstr ""
"Flera inbyggda typer kallas tupler, bland annat de värden som returneras av :"
"func:`time.localtime` och :func:`os.stat`.  Ett annat exempel är :data:`sys."
"float_info`::"

#: ../../glossary.rst:957
msgid ""
">>> sys.float_info[1]                   # indexed access\n"
"1024\n"
">>> sys.float_info.max_exp              # named field access\n"
"1024\n"
">>> isinstance(sys.float_info, tuple)   # kind of tuple\n"
"True"
msgstr ""
">>> sys.float_info[1] # indexerad åtkomst\n"
"1024\n"
">>> sys.float_info.max_exp # named field access\n"
"1024\n"
">>> isinstance(sys.float_info, tuple) # typ av tuple\n"
"Sant"

#: ../../glossary.rst:964
msgid ""
"Some named tuples are built-in types (such as the above examples). "
"Alternatively, a named tuple can be created from a regular class definition "
"that inherits from :class:`tuple` and that defines named fields.  Such a "
"class can be written by hand, or it can be created by inheriting :class:"
"`typing.NamedTuple`, or with the factory function :func:`collections."
"namedtuple`.  The latter techniques also add some extra methods that may not "
"be found in hand-written or built-in named tuples."
msgstr ""
"Vissa namngivna tuplar är inbyggda typer (som exemplen ovan). Alternativt "
"kan en namngiven tupel skapas från en vanlig klassdefinition som ärver från :"
"class:`tuple` och som definierar namngivna fält.  En sådan klass kan skrivas "
"för hand, eller så kan den skapas genom att ärva :class:`typing.NamedTuple`, "
"eller med fabriksfunktionen :func:`collections.namedtuple`.  De senare "
"teknikerna lägger också till några extra metoder som kanske inte finns i "
"handskrivna eller inbyggda namngivna tuplar."

#: ../../glossary.rst:972
msgid "namespace"
msgstr "namnrymd"

#: ../../glossary.rst:974
msgid ""
"The place where a variable is stored.  Namespaces are implemented as "
"dictionaries.  There are the local, global and built-in namespaces as well "
"as nested namespaces in objects (in methods).  Namespaces support modularity "
"by preventing naming conflicts.  For instance, the functions :func:`builtins."
"open <.open>` and :func:`os.open` are distinguished by their namespaces.  "
"Namespaces also aid readability and maintainability by making it clear which "
"module implements a function.  For instance, writing :func:`random.seed` or :"
"func:`itertools.islice` makes it clear that those functions are implemented "
"by the :mod:`random` and :mod:`itertools` modules, respectively."
msgstr ""
"Den plats där en variabel lagras.  Namnrymder är implementerade som "
"ordböcker.  Det finns lokala, globala och inbyggda namnrymder samt nästlade "
"namnrymder i objekt (i metoder).  Namnrymder stöder modularitet genom att "
"förhindra namnkonflikter.  Exempelvis skiljer sig funktionerna :func:"
"`builtins.open <.open>` och :func:`os.open` åt genom sina namnrymder.  "
"Namnrymder underlättar också läsbarhet och underhåll genom att göra det "
"tydligt vilken modul som implementerar en funktion.  Om man till exempel "
"skriver :func:`random.seed` eller :func:`itertools.islice` framgår det "
"tydligt att dessa funktioner implementeras av modulerna :mod:`random` "
"respektive :mod:`itertools`."

#: ../../glossary.rst:984
msgid "namespace package"
msgstr "namnområde paket"

#: ../../glossary.rst:986
msgid ""
"A :term:`package` which serves only as a container for subpackages. "
"Namespace packages may have no physical representation, and specifically are "
"not like a :term:`regular package` because they have no ``__init__.py`` file."
msgstr ""
"Ett :term:`paket` som endast fungerar som en behållare för underpaket. "
"Namnrymdspaket får inte ha någon fysisk representation, och är specifikt "
"inte som ett :term:`vanligt paket` eftersom de inte har någon ``__init__."
"py``-fil."

#: ../../glossary.rst:991
msgid ""
"Namespace packages allow several individually installable packages to have a "
"common parent package. Otherwise, it is recommended to use a :term:`regular "
"package`."
msgstr ""
"Namnområdespaket gör det möjligt för flera individuellt installerbara paket "
"att ha ett gemensamt överordnat paket. I annat fall rekommenderas det att "
"använda en :term:`vanlig paket`."

#: ../../glossary.rst:994
msgid ""
"For more information, see :pep:`420` and :ref:`reference-namespace-package`."
msgstr ""
"För mer information, se :pep:`420` och :ref:`reference-namespace-package`."

#: ../../glossary.rst:996
msgid "See also :term:`module`."
msgstr "Se även :term:`modul`."

#: ../../glossary.rst:997
msgid "nested scope"
msgstr "nästlat omfång"

#: ../../glossary.rst:999
msgid ""
"The ability to refer to a variable in an enclosing definition.  For "
"instance, a function defined inside another function can refer to variables "
"in the outer function.  Note that nested scopes by default work only for "
"reference and not for assignment.  Local variables both read and write in "
"the innermost scope.  Likewise, global variables read and write to the "
"global namespace.  The :keyword:`nonlocal` allows writing to outer scopes."
msgstr ""
"Möjligheten att referera till en variabel i en omslutande definition.  "
"Exempelvis kan en funktion som definieras inuti en annan funktion referera "
"till variabler i den yttre funktionen.  Observera att nästlade scopes som "
"standard endast fungerar för referens och inte för tilldelning.  Lokala "
"variabler både läser och skriver i det innersta scopet.  På samma sätt läser "
"och skriver globala variabler i det globala namnrymden.  Nyckelordet: "
"`nonlocal` tillåter skrivning till yttre scopes."

#: ../../glossary.rst:1006
msgid "new-style class"
msgstr "klass med ny stil"

#: ../../glossary.rst:1008
msgid ""
"Old name for the flavor of classes now used for all class objects.  In "
"earlier Python versions, only new-style classes could use Python's newer, "
"versatile features like :attr:`~object.__slots__`, descriptors, properties, :"
"meth:`~object.__getattribute__`, class methods, and static methods."
msgstr ""
"Gammalt namn för den variant av klasser som nu används för alla "
"klassobjekt.  I tidigare Python-versioner kunde endast klasser i ny stil "
"använda Pythons nyare, mångsidiga funktioner som :attr:`~object.__slots__`, "
"deskriptorer, egenskaper, :meth:`~object.__getattribute__`, klassmetoder och "
"statiska metoder."

#: ../../glossary.rst:1013
msgid "object"
msgstr "objekt"

#: ../../glossary.rst:1015
msgid ""
"Any data with state (attributes or value) and defined behavior (methods).  "
"Also the ultimate base class of any :term:`new-style class`."
msgstr ""
"Alla data med tillstånd (attribut eller värde) och definierat beteende "
"(metoder).  Också den ultimata basklassen för alla :term:`new-style class`."

#: ../../glossary.rst:1018
msgid "optimized scope"
msgstr "optimerad omfattning"

#: ../../glossary.rst:1020
msgid ""
"A scope where target local variable names are reliably known to the compiler "
"when the code is compiled, allowing optimization of read and write access to "
"these names. The local namespaces for functions, generators, coroutines, "
"comprehensions, and generator expressions are optimized in this fashion. "
"Note: most interpreter optimizations are applied to all scopes, only those "
"relying on a known set of local and nonlocal variable names are restricted "
"to optimized scopes."
msgstr ""
"Ett område där namnen på lokala målvariabler är tillförlitligt kända för "
"kompilatorn när koden kompileras, vilket möjliggör optimering av läs- och "
"skrivåtkomst till dessa namn. De lokala namnrymderna för funktioner, "
"generatorer, coroutines, comprehensions och generatoruttryck optimeras på "
"detta sätt. Observera: De flesta tolkningsoptimeringar tillämpas på alla "
"scopes, endast de som förlitar sig på en känd uppsättning lokala och icke-"
"lokala variabelnamn begränsas till optimerade scopes."

#: ../../glossary.rst:1027
msgid "optional module"
msgstr ""

#: ../../glossary.rst:1029
msgid ""
"An :term:`extension module` that is part of the :term:`standard library`, "
"but may be absent in some builds of :term:`CPython`, usually due to missing "
"third-party libraries or because the module is not available for a given "
"platform."
msgstr ""

#: ../../glossary.rst:1034
msgid ""
"See :ref:`optional-module-requirements` for a list of optional modules that "
"require third-party libraries."
msgstr ""

#: ../../glossary.rst:1036
msgid "package"
msgstr "paket"

#: ../../glossary.rst:1038
msgid ""
"A Python :term:`module` which can contain submodules or recursively, "
"subpackages.  Technically, a package is a Python module with a ``__path__`` "
"attribute."
msgstr ""
"En Python :term:`modul` som kan innehålla undermoduler eller rekursivt, "
"underpaket.  Tekniskt sett är ett paket en Python-modul med attributet "
"``__path__``."

#: ../../glossary.rst:1042
msgid "See also :term:`regular package` and :term:`namespace package`."
msgstr "Se även :term:`regular package` och :term:`namespace package`."

#: ../../glossary.rst:1043
msgid "parameter"
msgstr "parameter"

#: ../../glossary.rst:1045
msgid ""
"A named entity in a :term:`function` (or method) definition that specifies "
"an :term:`argument` (or in some cases, arguments) that the function can "
"accept.  There are five kinds of parameter:"
msgstr ""
"En namngiven enhet i en :term:`funktions` (eller metod)-definition som anger "
"ett :term:`argument` (eller i vissa fall flera argument) som funktionen kan "
"acceptera.  Det finns fem olika typer av parametrar:"

#: ../../glossary.rst:1049
msgid ""
":dfn:`positional-or-keyword`: specifies an argument that can be passed "
"either :term:`positionally <argument>` or as a :term:`keyword argument "
"<argument>`.  This is the default kind of parameter, for example *foo* and "
"*bar* in the following::"
msgstr ""
":dfn:`positional-or-keyword`: anger ett argument som kan skickas antingen :"
"term:`positionellt <argument>` eller som ett :term:`keyword-argument "
"<argument>`.  Detta är standardtypen av parameter, t.ex. *foo* och *bar* i "
"följande::"

#: ../../glossary.rst:1054
msgid "def func(foo, bar=None): ..."
msgstr "def func(foo, bar=None): ..."

#: ../../glossary.rst:1058
msgid ""
":dfn:`positional-only`: specifies an argument that can be supplied only by "
"position. Positional-only parameters can be defined by including a ``/`` "
"character in the parameter list of the function definition after them, for "
"example *posonly1* and *posonly2* in the following::"
msgstr ""
":dfn:`positional-only`: anger ett argument som endast kan anges med "
"position. Parametrar med enbart position kan definieras genom att inkludera "
"ett ``/``-tecken i parameterlistan i funktionsdefinitionen efter dem, till "
"exempel *posonly1* och *posonly2* i följande::"

#: ../../glossary.rst:1063
msgid "def func(posonly1, posonly2, /, positional_or_keyword): ..."
msgstr "def func(posonly1, posonly2, /, positional_or_keyword): ..."

#: ../../glossary.rst:1067
msgid ""
":dfn:`keyword-only`: specifies an argument that can be supplied only by "
"keyword.  Keyword-only parameters can be defined by including a single var-"
"positional parameter or bare ``*`` in the parameter list of the function "
"definition before them, for example *kw_only1* and *kw_only2* in the "
"following::"
msgstr ""
":dfn:`keyword-only`: anger ett argument som endast kan anges med nyckelord.  "
"Parametrar som endast innehåller nyckelord kan definieras genom att "
"inkludera en enda var-positionell parameter eller bara ``*`` i "
"parameterlistan för funktionsdefinitionen före dem, till exempel *kw_only1* "
"och *kw_only2* i följande::"

#: ../../glossary.rst:1073
msgid "def func(arg, *, kw_only1, kw_only2): ..."
msgstr "def func(arg, *, kw_only1, kw_only2): ..."

#: ../../glossary.rst:1075
msgid ""
":dfn:`var-positional`: specifies that an arbitrary sequence of positional "
"arguments can be provided (in addition to any positional arguments already "
"accepted by other parameters).  Such a parameter can be defined by "
"prepending the parameter name with ``*``, for example *args* in the "
"following::"
msgstr ""
":dfn:`var-positional`: anger att en godtycklig sekvens av positionella "
"argument kan anges (utöver de positionella argument som redan accepteras av "
"andra parametrar).  En sådan parameter kan definieras genom att "
"parameternamnet föregås av ``*``, t.ex. *args* i följande::"

#: ../../glossary.rst:1081
msgid "def func(*args, **kwargs): ..."
msgstr "def func(*args, **kwargs): ..."

#: ../../glossary.rst:1083
msgid ""
":dfn:`var-keyword`: specifies that arbitrarily many keyword arguments can be "
"provided (in addition to any keyword arguments already accepted by other "
"parameters).  Such a parameter can be defined by prepending the parameter "
"name with ``**``, for example *kwargs* in the example above."
msgstr ""
":dfn:`var-keyword`: anger att godtyckligt många nyckelordsargument kan anges "
"(utöver eventuella nyckelordsargument som redan accepteras av andra "
"parametrar).  En sådan parameter kan definieras genom att parameternamnet "
"föregås av ``**``, t.ex. *kwargs* i exemplet ovan."

#: ../../glossary.rst:1089
msgid ""
"Parameters can specify both optional and required arguments, as well as "
"default values for some optional arguments."
msgstr ""
"Parametrar kan ange både valfria och obligatoriska argument, samt "
"standardvärden för vissa valfria argument."

#: ../../glossary.rst:1092
msgid ""
"See also the :term:`argument` glossary entry, the FAQ question on :ref:`the "
"difference between arguments and parameters <faq-argument-vs-parameter>`, "
"the :class:`inspect.Parameter` class, the :ref:`function` section, and :pep:"
"`362`."
msgstr ""
"Se även ordlisteposten :term:`argument`, FAQ-frågan om :ref:``skillnaden "
"mellan argument och parametrar <faq-argument-vs-parameter>`, klassen :class:"
"`inspect.Parameter`, avsnittet :ref:`function` och :pep:`362`."

#: ../../glossary.rst:1096
msgid "path entry"
msgstr "väg in"

#: ../../glossary.rst:1098
msgid ""
"A single location on the :term:`import path` which the :term:`path based "
"finder` consults to find modules for importing."
msgstr ""
"En plats på :term:`import path` som :term:`path based finder` konsulterar "
"för att hitta moduler att importera."

#: ../../glossary.rst:1100
msgid "path entry finder"
msgstr "sökare för sökväg"

#: ../../glossary.rst:1102
msgid ""
"A :term:`finder` returned by a callable on :data:`sys.path_hooks` (i.e. a :"
"term:`path entry hook`) which knows how to locate modules given a :term:"
"`path entry`."
msgstr ""
"En :term:`finder` som returneras av en anropsbar på :data:`sys.path_hooks` "
"(dvs. en :term:`path entry hook`) som vet hur man lokaliserar moduler givet "
"en :term:`path entry`."

#: ../../glossary.rst:1106
msgid ""
"See :class:`importlib.abc.PathEntryFinder` for the methods that path entry "
"finders implement."
msgstr ""
"Se :class:`importlib.abc.PathEntryFinder` för de metoder som sökare av "
"sökvägsposter implementerar."

#: ../../glossary.rst:1108
msgid "path entry hook"
msgstr "väg inmatning krok"

#: ../../glossary.rst:1110
msgid ""
"A callable on the :data:`sys.path_hooks` list which returns a :term:`path "
"entry finder` if it knows how to find modules on a specific :term:`path "
"entry`."
msgstr ""
"En anropsbarhet på listan :data:`sys.path_hooks` som returnerar en :term:"
"`path entry finder` om den vet hur man hittar moduler på en specifik :term:"
"`path entry`."

#: ../../glossary.rst:1113
msgid "path based finder"
msgstr "sökvägsbaserad sökare"

#: ../../glossary.rst:1115
msgid ""
"One of the default :term:`meta path finders <meta path finder>` which "
"searches an :term:`import path` for modules."
msgstr ""
"En av standard :term:`meta path finders <meta path finder>` som söker efter "
"moduler i en :term:`import path`."

#: ../../glossary.rst:1117
msgid "path-like object"
msgstr "stigliknande objekt"

#: ../../glossary.rst:1119
msgid ""
"An object representing a file system path. A path-like object is either a :"
"class:`str` or :class:`bytes` object representing a path, or an object "
"implementing the :class:`os.PathLike` protocol. An object that supports the :"
"class:`os.PathLike` protocol can be converted to a :class:`str` or :class:"
"`bytes` file system path by calling the :func:`os.fspath` function; :func:"
"`os.fsdecode` and :func:`os.fsencode` can be used to guarantee a :class:"
"`str` or :class:`bytes` result instead, respectively. Introduced by :pep:"
"`519`."
msgstr ""
"Ett objekt som representerar en filsystemssökväg. Ett sökvägsliknande objekt "
"är antingen ett :class:`str`- eller :class:`bytes`-objekt som representerar "
"en sökväg, eller ett objekt som implementerar :class:`os.PathLike`-"
"protokollet. Ett objekt som stöder protokollet :class:`os.PathLike` kan "
"konverteras till en filsystemssökväg av typen :class:`str` eller :class:"
"`bytes` genom att anropa funktionen :func:`os.fspath`; :func:`os.fsdecode` "
"och :func:`os.fsencode` kan användas för att garantera ett resultat av "
"typen :class:`str` respektive :class:`bytes` istället. Införd av :pep:`519`."

#: ../../glossary.rst:1127
msgid "PEP"
msgstr "PEP"

#: ../../glossary.rst:1129
msgid ""
"Python Enhancement Proposal. A PEP is a design document providing "
"information to the Python community, or describing a new feature for Python "
"or its processes or environment. PEPs should provide a concise technical "
"specification and a rationale for proposed features."
msgstr ""
"Python Enhancement Proposal (förslag till förbättring av Python). Ett PEP är "
"ett designdokument som ger information till Python-gemenskapen eller "
"beskriver en ny funktion för Python eller dess processer eller miljö. PEP:er "
"ska innehålla en kortfattad teknisk specifikation och en motivering till "
"föreslagna funktioner."

#: ../../glossary.rst:1135
msgid ""
"PEPs are intended to be the primary mechanisms for proposing major new "
"features, for collecting community input on an issue, and for documenting "
"the design decisions that have gone into Python. The PEP author is "
"responsible for building consensus within the community and documenting "
"dissenting opinions."
msgstr ""
"PEP:er är avsedda att vara de primära mekanismerna för att föreslå större "
"nya funktioner, för att samla in synpunkter på en fråga och för att "
"dokumentera de designbeslut som har tagits i Python. PEP-författaren är "
"ansvarig för att bygga konsensus inom gemenskapen och dokumentera avvikande "
"åsikter."

#: ../../glossary.rst:1141
msgid "See :pep:`1`."
msgstr "Se :pep:`1`."

#: ../../glossary.rst:1142
msgid "portion"
msgstr "del"

#: ../../glossary.rst:1144
msgid ""
"A set of files in a single directory (possibly stored in a zip file) that "
"contribute to a namespace package, as defined in :pep:`420`."
msgstr ""
"En uppsättning filer i en enda katalog (eventuellt lagrad i en zip-fil) som "
"bidrar till ett namnrymdspaket, enligt definitionen i :pep:`420`."

#: ../../glossary.rst:1146
msgid "positional argument"
msgstr "positionsargument"

#: ../../glossary.rst:1149
msgid "provisional API"
msgstr "provisoriskt API"

#: ../../glossary.rst:1151
msgid ""
"A provisional API is one which has been deliberately excluded from the "
"standard library's backwards compatibility guarantees.  While major changes "
"to such interfaces are not expected, as long as they are marked provisional, "
"backwards incompatible changes (up to and including removal of the "
"interface) may occur if deemed necessary by core developers.  Such changes "
"will not be made gratuitously -- they will occur only if serious fundamental "
"flaws are uncovered that were missed prior to the inclusion of the API."
msgstr ""
"Ett provisoriskt API är ett API som avsiktligt har undantagits från "
"standardbibliotekets garantier för bakåtkompatibilitet.  Även om större "
"förändringar av sådana gränssnitt inte förväntas, så länge de är markerade "
"som provisoriska, kan bakåtkompatibla förändringar (upp till och inklusive "
"borttagning av gränssnittet) ske om det anses nödvändigt av kärnutvecklare.  "
"Sådana ändringar kommer inte att göras omotiverat - de kommer endast att ske "
"om allvarliga grundläggande brister upptäcks som missades innan API:et "
"inkluderades."

#: ../../glossary.rst:1160
msgid ""
"Even for provisional APIs, backwards incompatible changes are seen as a "
"\"solution of last resort\" - every attempt will still be made to find a "
"backwards compatible resolution to any identified problems."
msgstr ""
"Även för provisoriska API:er ses bakåtkompatibla ändringar som en \"sista "
"utväg\" - alla försök kommer ändå att göras för att hitta en bakåtkompatibel "
"lösning på eventuella identifierade problem."

#: ../../glossary.rst:1164
msgid ""
"This process allows the standard library to continue to evolve over time, "
"without locking in problematic design errors for extended periods of time.  "
"See :pep:`411` for more details."
msgstr ""
"Denna process gör att standardbiblioteket kan fortsätta att utvecklas över "
"tiden, utan att problematiska designfel låses fast under längre "
"tidsperioder.  Se :pep:`411` för mer information."

#: ../../glossary.rst:1167
msgid "provisional package"
msgstr "preliminärt paket"

#: ../../glossary.rst:1169
msgid "See :term:`provisional API`."
msgstr "Se :term:`provisoriskt API`."

#: ../../glossary.rst:1170
msgid "Python 3000"
msgstr "Python 3000"

#: ../../glossary.rst:1172
msgid ""
"Nickname for the Python 3.x release line (coined long ago when the release "
"of version 3 was something in the distant future.)  This is also abbreviated "
"\"Py3k\"."
msgstr ""
"Smeknamn för Python 3.x release line (myntades för länge sedan när "
"lanseringen av version 3 var något i en avlägsen framtid)  Detta är också "
"förkortat \"Py3k\"."

#: ../../glossary.rst:1175
msgid "Pythonic"
msgstr "Pythonisk"

#: ../../glossary.rst:1177
msgid ""
"An idea or piece of code which closely follows the most common idioms of the "
"Python language, rather than implementing code using concepts common to "
"other languages.  For example, a common idiom in Python is to loop over all "
"elements of an iterable using a :keyword:`for` statement.  Many other "
"languages don't have this type of construct, so people unfamiliar with "
"Python sometimes use a numerical counter instead::"
msgstr ""
"En idé eller kod som nära följer de vanligaste idiomen i Python-språket, "
"snarare än att implementera kod med hjälp av koncept som är vanliga i andra "
"språk.  Ett vanligt idiom i Python är till exempel att loopa över alla "
"element i en iterabel med hjälp av en :keyword:`for`-sats.  Många andra "
"språk har inte denna typ av konstruktion, så människor som inte känner till "
"Python använder ibland en numerisk räknare istället::"

#: ../../glossary.rst:1184
msgid ""
"for i in range(len(food)):\n"
"    print(food[i])"
msgstr ""
"för i i intervallet(len(livsmedel)):\n"
"    print(livsmedel[i])"

#: ../../glossary.rst:1187
msgid "As opposed to the cleaner, Pythonic method::"
msgstr "I motsats till den renare, pytoniska metoden::"

#: ../../glossary.rst:1189
msgid ""
"for piece in food:\n"
"    print(piece)"
msgstr ""
"för bit i mat:\n"
"    print(bit)"

#: ../../glossary.rst:1191
msgid "qualified name"
msgstr "kvalificerat namn"

#: ../../glossary.rst:1193
msgid ""
"A dotted name showing the \"path\" from a module's global scope to a class, "
"function or method defined in that module, as defined in :pep:`3155`.  For "
"top-level functions and classes, the qualified name is the same as the "
"object's name::"
msgstr ""
"Ett prickat namn som visar \"sökvägen\" från en moduls globala omfattning "
"till en klass, funktion eller metod som definieras i den modulen, enligt "
"definitionen i :pep:`3155`.  För funktioner och klasser på högsta nivå är "
"det kvalificerade namnet detsamma som objektets namn::"

#: ../../glossary.rst:1198
msgid ""
">>> class C:\n"
"...     class D:\n"
"...         def meth(self):\n"
"...             pass\n"
"...\n"
">>> C.__qualname__\n"
"'C'\n"
">>> C.D.__qualname__\n"
"'C.D'\n"
">>> C.D.meth.__qualname__\n"
"'C.D.meth'"
msgstr ""
">>> klass C:\n"
"... klass D:\n"
"... def meth(self):\n"
"... pass\n"
"...\n"
">>> C.__qualname__\n"
"'C'\n"
">>> C.D.__kvalnamn__ 'C'\n"
"'C.D'\n"
">>> C.D.meth.__kvalnamn__ 'C.D'\n"
"'C.D.meth'"

#: ../../glossary.rst:1210
msgid ""
"When used to refer to modules, the *fully qualified name* means the entire "
"dotted path to the module, including any parent packages, e.g. ``email.mime."
"text``::"
msgstr ""
"När det används för att hänvisa till moduler betyder det *fullständigt "
"kvalificerade namnet* hela den prickade sökvägen till modulen, inklusive "
"eventuella överordnade paket, t.ex. ``email.mime.text``::"

#: ../../glossary.rst:1214
msgid ""
">>> import email.mime.text\n"
">>> email.mime.text.__name__\n"
"'email.mime.text'"
msgstr ""
">>> import e-post.mime.text\n"
">>> email.mime.text.__name__\n"
"'e-post.mime.text'"

#: ../../glossary.rst:1217
msgid "reference count"
msgstr "referensantal"

#: ../../glossary.rst:1219
msgid ""
"The number of references to an object.  When the reference count of an "
"object drops to zero, it is deallocated.  Some objects are :term:`immortal` "
"and have reference counts that are never modified, and therefore the objects "
"are never deallocated.  Reference counting is generally not visible to "
"Python code, but it is a key element of the :term:`CPython` implementation.  "
"Programmers can call the :func:`sys.getrefcount` function to return the "
"reference count for a particular object."
msgstr ""
"Antalet referenser till ett objekt.  När referensantalet för ett objekt "
"sjunker till noll, avallokeras det.  Vissa objekt är :term:``odödliga`` och "
"har referensräkningar som aldrig ändras, och därför avallokeras objekten "
"aldrig.  Referensräkning är i allmänhet inte synlig för Python-kod, men det "
"är en viktig del av :term:`CPython`-implementeringen.  Programmerare kan "
"anropa funktionen :func:`sys.getrefcount` för att returnera referensantalet "
"för ett visst objekt."

#: ../../glossary.rst:1228
msgid ""
"In :term:`CPython`, reference counts are not considered to be stable or well-"
"defined values; the number of references to an object, and how that number "
"is affected by Python code, may be different between versions."
msgstr ""
"I :term:`CPython` anses inte referensantal vara stabila eller väldefinierade "
"värden; antalet referenser till ett objekt, och hur detta antal påverkas av "
"Python-kod, kan skilja sig mellan olika versioner."

#: ../../glossary.rst:1232
msgid "regular package"
msgstr "ordinarie paket"

#: ../../glossary.rst:1234
msgid ""
"A traditional :term:`package`, such as a directory containing an ``__init__."
"py`` file."
msgstr ""
"En traditionell :term:`package`, t.ex. en katalog som innehåller filen "
"``__init__.py``."

#: ../../glossary.rst:1237
msgid "See also :term:`namespace package`."
msgstr "Se även :term:`namespace package`."

#: ../../glossary.rst:1238
msgid "REPL"
msgstr "REPL"

#: ../../glossary.rst:1240
msgid ""
"An acronym for the \"read–eval–print loop\", another name for the :term:"
"`interactive` interpreter shell."
msgstr ""
"En akronym för \"read-eval-print loop\", ett annat namn för :term:"
"`interactive` interpreter shell."

#: ../../glossary.rst:1242
msgid "__slots__"
msgstr "__slots__"

#: ../../glossary.rst:1244
msgid ""
"A declaration inside a class that saves memory by pre-declaring space for "
"instance attributes and eliminating instance dictionaries.  Though popular, "
"the technique is somewhat tricky to get right and is best reserved for rare "
"cases where there are large numbers of instances in a memory-critical "
"application."
msgstr ""
"En deklaration inuti en klass som sparar minne genom att i förväg deklarera "
"utrymme för instansattribut och eliminera instansordlistor.  Även om "
"tekniken är populär är den lite knepig att få till på rätt sätt och är bäst "
"reserverad för sällsynta fall där det finns ett stort antal instanser i en "
"minneskritisk applikation."

#: ../../glossary.rst:1249
msgid "sequence"
msgstr "sekvens"

#: ../../glossary.rst:1251
msgid ""
"An :term:`iterable` which supports efficient element access using integer "
"indices via the :meth:`~object.__getitem__` special method and defines a :"
"meth:`~object.__len__` method that returns the length of the sequence. Some "
"built-in sequence types are :class:`list`, :class:`str`, :class:`tuple`, "
"and :class:`bytes`. Note that :class:`dict` also supports :meth:`~object."
"__getitem__` and :meth:`!__len__`, but is considered a mapping rather than a "
"sequence because the lookups use arbitrary :term:`hashable` keys rather than "
"integers."
msgstr ""
"En :term:`iterable` som stöder effektiv elementåtkomst med hjälp av "
"heltalsindex via specialmetoden :meth:`~object.__getitem__` och definierar "
"en :meth:`~object.__len__`-metod som returnerar sekvensens längd. Några "
"inbyggda sekvenstyper är :class:`list`, :class:`str`, :class:`tuple` och :"
"class:`bytes`. Observera att :class:`dict` också stöder :meth:`~object."
"__getitem__` och :meth:`!__len__`, men betraktas som en mappning snarare än "
"en sekvens eftersom uppslagningarna använder godtyckliga :term:`hashable`-"
"nycklar i stället för heltal."

#: ../../glossary.rst:1260
msgid ""
"The :class:`collections.abc.Sequence` abstract base class defines a much "
"richer interface that goes beyond just :meth:`~object.__getitem__` and :meth:"
"`~object.__len__`, adding :meth:`~sequence.count`, :meth:`~sequence.index`, :"
"meth:`~object.__contains__`, and :meth:`~object.__reversed__`. Types that "
"implement this expanded interface can be registered explicitly using :func:"
"`~abc.ABCMeta.register`. For more documentation on sequence methods "
"generally, see :ref:`Common Sequence Operations <typesseq-common>`."
msgstr ""

#: ../../glossary.rst:1270
msgid "set comprehension"
msgstr "inställd förståelse"

#: ../../glossary.rst:1272
msgid ""
"A compact way to process all or part of the elements in an iterable and "
"return a set with the results. ``results = {c for c in 'abracadabra' if c "
"not in 'abc'}`` generates the set of strings ``{'r', 'd'}``.  See :ref:"
"`comprehensions`."
msgstr ""
"Ett kompakt sätt att bearbeta alla eller delar av elementen i en iterabel "
"och returnera en uppsättning med resultaten. ``results = {c for c in "
"'abracadabra' if c not in 'abc'}`` genererar uppsättningen strängar ``{'r', "
"'d'}``.  Se :ref:`förståelser`."

#: ../../glossary.rst:1276
msgid "single dispatch"
msgstr "enstaka sändning"

#: ../../glossary.rst:1278
msgid ""
"A form of :term:`generic function` dispatch where the implementation is "
"chosen based on the type of a single argument."
msgstr ""
"En form av :term:`generic function` dispatch där implementationen väljs "
"baserat på typen av ett enda argument."

#: ../../glossary.rst:1280
msgid "slice"
msgstr "skiva"

#: ../../glossary.rst:1282
msgid ""
"An object usually containing a portion of a :term:`sequence`.  A slice is "
"created using the subscript notation, ``[]`` with colons between numbers "
"when several are given, such as in ``variable_name[1:3:5]``.  The bracket "
"(subscript) notation uses :class:`slice` objects internally."
msgstr ""
"Ett objekt som vanligtvis innehåller en del av en :term:`sekvens`.  En slice "
"skapas med hjälp av subscript-notationen, ``[]`` med kolon mellan siffrorna "
"när flera anges, t.ex. i ``variabelnamn[1:3:5]``.  Parentesnotationen "
"(subscript) använder :class:`slice`-objekt internt."

#: ../../glossary.rst:1286
msgid "soft deprecated"
msgstr "mjuk föråldrad"

#: ../../glossary.rst:1288
msgid ""
"A soft deprecated API should not be used in new code, but it is safe for "
"already existing code to use it. The API remains documented and tested, but "
"will not be enhanced further."
msgstr ""
"Ett soft deprecated API bör inte användas i ny kod, men det är säkert för "
"redan befintlig kod att använda det. API:et förblir dokumenterat och testat, "
"men kommer inte att förbättras ytterligare."

#: ../../glossary.rst:1292
msgid ""
"Soft deprecation, unlike normal deprecation, does not plan on removing the "
"API and will not emit warnings."
msgstr ""
"Mjuk depreciering, till skillnad från normal depreciering, planerar inte att "
"ta bort API:et och kommer inte att ge upphov till varningar."

#: ../../glossary.rst:1295
msgid ""
"See `PEP 387: Soft Deprecation <https://peps.python.org/pep-0387/#soft-"
"deprecation>`_."
msgstr ""
"Se `PEP 387: Mjuk depreciering <https://peps.python.org/pep-0387/#soft-"
"deprecation>`_."

#: ../../glossary.rst:1297
msgid "special method"
msgstr "särskild metod"

#: ../../glossary.rst:1301
msgid ""
"A method that is called implicitly by Python to execute a certain operation "
"on a type, such as addition.  Such methods have names starting and ending "
"with double underscores.  Special methods are documented in :ref:"
"`specialnames`."
msgstr ""
"En metod som anropas implicit av Python för att utföra en viss operation på "
"en typ, t.ex. addition.  Sådana metoder har namn som börjar och slutar med "
"dubbla understreck.  Speciella metoder finns dokumenterade i :ref:"
"`specialnames`."

#: ../../glossary.rst:1305
msgid "standard library"
msgstr "standardbibliotek"

#: ../../glossary.rst:1307
msgid ""
"The collection of :term:`packages <package>`, :term:`modules <module>` and :"
"term:`extension modules <extension module>` distributed as a part of the "
"official Python interpreter package.  The exact membership of the collection "
"may vary based on platform, available system libraries, or other criteria.  "
"Documentation can be found at :ref:`library-index`."
msgstr ""
"Samlingen av :term:`packages <package>`, :term:`modules <module>` och :term:"
"`extension modules <extension module>` som distribueras som en del av det "
"officiella Python-tolkpaketet.  Exakt vilka som ingår i samlingen kan "
"variera beroende på plattform, tillgängliga systembibliotek eller andra "
"kriterier.  Dokumentation finns på :ref:`library-index`."

#: ../../glossary.rst:1313
msgid ""
"See also :data:`sys.stdlib_module_names` for a list of all possible standard "
"library module names."
msgstr ""
"Se även :data:`sys.stdlib_module_names` för en lista över alla möjliga namn "
"på standardbiblioteksmoduler."

#: ../../glossary.rst:1315
msgid "statement"
msgstr "uttalande"

#: ../../glossary.rst:1317
msgid ""
"A statement is part of a suite (a \"block\" of code).  A statement is either "
"an :term:`expression` or one of several constructs with a keyword, such as :"
"keyword:`if`, :keyword:`while` or :keyword:`for`."
msgstr ""
"Ett statement är en del av en svit (ett \"block\" av kod).  En sats är "
"antingen ett :term:`uttryck` eller en av flera konstruktioner med ett "
"nyckelord, t.ex. :keyword:`if`, :keyword:`while` eller :keyword:`for`."

#: ../../glossary.rst:1320
msgid "static type checker"
msgstr "statisk typkontroll"

#: ../../glossary.rst:1322
msgid ""
"An external tool that reads Python code and analyzes it, looking for issues "
"such as incorrect types. See also :term:`type hints <type hint>` and the :"
"mod:`typing` module."
msgstr ""
"Ett externt verktyg som läser Python-kod och analyserar den, och letar efter "
"problem som felaktiga typer. Se även :term:`type hints <type hint>` och :mod:"
"`typing`-modulen."

#: ../../glossary.rst:1325
msgid "stdlib"
msgstr "stdlib"

#: ../../glossary.rst:1327
msgid "An abbreviation of :term:`standard library`."
msgstr "En förkortning av :term:`standard library`."

#: ../../glossary.rst:1328
msgid "strong reference"
msgstr "stark referens"

#: ../../glossary.rst:1330
msgid ""
"In Python's C API, a strong reference is a reference to an object which is "
"owned by the code holding the reference.  The strong reference is taken by "
"calling :c:func:`Py_INCREF` when the reference is created and released with :"
"c:func:`Py_DECREF` when the reference is deleted."
msgstr ""
"I Pythons C API är en stark referens en referens till ett objekt som ägs av "
"den kod som håller referensen.  Den starka referensen tas genom att anropa :"
"c:func:`Py_INCREF` när referensen skapas och släpps med :c:func:`Py_DECREF` "
"när referensen raderas."

#: ../../glossary.rst:1336
msgid ""
"The :c:func:`Py_NewRef` function can be used to create a strong reference to "
"an object. Usually, the :c:func:`Py_DECREF` function must be called on the "
"strong reference before exiting the scope of the strong reference, to avoid "
"leaking one reference."
msgstr ""
"Funktionen :c:func:`Py_NewRef` kan användas för att skapa en stark referens "
"till ett objekt. Vanligtvis måste funktionen :c:func:`Py_DECREF` anropas på "
"den starka referensen innan den lämnar den starka referensens scope, för att "
"undvika att en referens läcker ut."

#: ../../glossary.rst:1341
msgid "See also :term:`borrowed reference`."
msgstr "Se även :term:`lånad referens`."

#: ../../glossary.rst:1342
msgid "t-string"
msgstr "t-sträng"

#: ../../glossary.rst:1343
msgid "t-strings"
msgstr "t-strängar"

#: ../../glossary.rst:1345
msgid ""
"String literals prefixed with ``t`` or ``T`` are commonly called \"t-"
"strings\" which is short for :ref:`template string literals <t-strings>`."
msgstr ""
"Stränglitteraler med prefixet ``t`` eller ``T`` kallas vanligen \"t-"
"strängar\", vilket är en förkortning av :ref:`template string literals <t-"
"strings>`."

#: ../../glossary.rst:1348
msgid "text encoding"
msgstr "textkodning"

#: ../../glossary.rst:1350
msgid ""
"A string in Python is a sequence of Unicode code points (in range "
"``U+0000``--``U+10FFFF``). To store or transfer a string, it needs to be "
"serialized as a sequence of bytes."
msgstr ""
"En sträng i Python är en sekvens av Unicode-kodpunkter (i intervallet "
"``U+0000``--``U+10FFFF``). För att lagra eller överföra en sträng måste den "
"serialiseras som en sekvens av bytes."

#: ../../glossary.rst:1354
msgid ""
"Serializing a string into a sequence of bytes is known as \"encoding\", and "
"recreating the string from the sequence of bytes is known as \"decoding\"."
msgstr ""
"Serialisering av en sträng till en sekvens av bytes kallas \"kodning\", och "
"återskapande av strängen från sekvensen av bytes kallas \"avkodning\"."

#: ../../glossary.rst:1357
msgid ""
"There are a variety of different text serialization :ref:`codecs <standard-"
"encodings>`, which are collectively referred to as \"text encodings\"."
msgstr ""
"Det finns en mängd olika textserialiseringar :ref:`codecs <standard-"
"encodings>`, som tillsammans kallas \"textkodningar\"."

#: ../../glossary.rst:1360
msgid "text file"
msgstr "textfil"

#: ../../glossary.rst:1362
msgid ""
"A :term:`file object` able to read and write :class:`str` objects. Often, a "
"text file actually accesses a byte-oriented datastream and handles the :term:"
"`text encoding` automatically. Examples of text files are files opened in "
"text mode (``'r'`` or ``'w'``), :data:`sys.stdin`, :data:`sys.stdout`, and "
"instances of :class:`io.StringIO`."
msgstr ""
"Ett :term:`file-objekt` som kan läsa och skriva :class:`str`-objekt. Ofta "
"har en textfil faktiskt tillgång till en byteorienterad dataström och "
"hanterar :term:`text encoding` automatiskt. Exempel på textfiler är filer "
"som öppnas i textläge (``'r'`` eller ``'w'``), :data:`sys.stdin`, :data:`sys."
"stdout` och instanser av :class:`io.StringIO`."

#: ../../glossary.rst:1369
msgid ""
"See also :term:`binary file` for a file object able to read and write :term:"
"`bytes-like objects <bytes-like object>`."
msgstr ""
"Se även :term:``binary file`` för ett filobjekt som kan läsa och skriva :"
"term:``bytesliknande objekt <bytes-like object>``."

#: ../../glossary.rst:1371
msgid "thread state"
msgstr "trådstatus"

#: ../../glossary.rst:1374
msgid ""
"The information used by the :term:`CPython` runtime to run in an OS thread. "
"For example, this includes the current exception, if any, and the state of "
"the bytecode interpreter."
msgstr ""
"Den information som används av :term:`CPython` runtime för att köra i en OS-"
"tråd. Detta inkluderar till exempel det aktuella undantaget, om något, och "
"bytecode-tolkarens tillstånd."

#: ../../glossary.rst:1378
msgid ""
"Each thread state is bound to a single OS thread, but threads may have many "
"thread states available.  At most, one of them may be :term:`attached "
"<attached thread state>` at once."
msgstr ""
"Varje trådstatus är knuten till en enda OS-tråd, men trådar kan ha många "
"trådstatus tillgängliga.  Som mest kan en av dem vara :term:`attached "
"<attached thread state>` samtidigt."

#: ../../glossary.rst:1382
msgid ""
"An :term:`attached thread state` is required to call most of Python's C API, "
"unless a function explicitly documents otherwise. The bytecode interpreter "
"only runs under an attached thread state."
msgstr ""
"En :term:`attached thread state` krävs för att anropa det mesta av Pythons C "
"API, såvida inte en funktion uttryckligen dokumenterar något annat. "
"Bytekodstolkaren körs endast under ett anslutet trådtillstånd."

#: ../../glossary.rst:1386
msgid ""
"Each thread state belongs to a single interpreter, but each interpreter may "
"have many thread states, including multiple for the same OS thread. Thread "
"states from multiple interpreters may be bound to the same thread, but only "
"one can be :term:`attached <attached thread state>` in that thread at any "
"given moment."
msgstr ""
"Varje trådtillstånd hör till en enda tolk, men varje tolk kan ha många "
"trådtillstånd, inklusive flera för samma OS-tråd. Trådtillstånd från flera "
"tolkar kan vara bundna till samma tråd, men endast en kan vara :term:"
"`attached <attached thread state>` i den tråden vid varje givet tillfälle."

#: ../../glossary.rst:1392
msgid ""
"See :ref:`Thread State and the Global Interpreter Lock <threads>` for more "
"information."
msgstr ""
"Se :ref:`Thread State and the Global Interpreter Lock <threads>` för mer "
"information."

#: ../../glossary.rst:1394
msgid "token"
msgstr "symbol"

#: ../../glossary.rst:1397
msgid ""
"A small unit of source code, generated by the :ref:`lexical analyzer "
"<lexical>` (also called the *tokenizer*). Names, numbers, strings, "
"operators, newlines and similar are represented by tokens."
msgstr ""
"En liten enhet av källkod, genererad av :ref:``lexical analyzer <lexical>`` "
"(även kallad *tokenizer*). Namn, siffror, strängar, operatorer, nya linjer "
"och liknande representeras av tokens."

#: ../../glossary.rst:1402
msgid ""
"The :mod:`tokenize` module exposes Python's lexical analyzer. The :mod:"
"`token` module contains information on the various types of tokens."
msgstr ""
"Modulen :mod:`tokenize` exponerar Pythons lexikala analysator. Modulen :mod:"
"`token` innehåller information om de olika typerna av tokens."

#: ../../glossary.rst:1405
msgid "triple-quoted string"
msgstr "trippelciterad sträng"

#: ../../glossary.rst:1407
msgid ""
"A string which is bound by three instances of either a quotation mark (\") "
"or an apostrophe (').  While they don't provide any functionality not "
"available with single-quoted strings, they are useful for a number of "
"reasons.  They allow you to include unescaped single and double quotes "
"within a string and they can span multiple lines without the use of the "
"continuation character, making them especially useful when writing "
"docstrings."
msgstr ""
"En sträng som är bunden av tre instanser av antingen ett citattecken (\") "
"eller en apostrof (').  Även om de inte ger någon funktionalitet som inte är "
"tillgänglig med enkelciterade strängar, är de användbara av flera skäl.  De "
"gör det möjligt att inkludera enkla och dubbla citattecken i en sträng och "
"de kan sträcka sig över flera rader utan att använda fortsättningstecknet, "
"vilket gör dem särskilt användbara när man skriver dokumentsträngar."

#: ../../glossary.rst:1414
msgid "type"
msgstr "typ"

#: ../../glossary.rst:1416
msgid ""
"The type of a Python object determines what kind of object it is; every "
"object has a type.  An object's type is accessible as its :attr:`~object."
"__class__` attribute or can be retrieved with ``type(obj)``."
msgstr ""
"Typen av ett Python-objekt avgör vilken typ av objekt det är; varje objekt "
"har en typ.  Ett objekts typ är tillgänglig som dess :attr:`~object."
"__class__`-attribut eller kan hämtas med ``type(obj)``."

#: ../../glossary.rst:1420
msgid "type alias"
msgstr "typ alias"

#: ../../glossary.rst:1422
msgid "A synonym for a type, created by assigning the type to an identifier."
msgstr ""
"En synonym för en typ, som skapas genom att typen tilldelas en identifierare."

#: ../../glossary.rst:1424
msgid ""
"Type aliases are useful for simplifying :term:`type hints <type hint>`. For "
"example::"
msgstr ""
"Type aliases är användbara för att förenkla :term:`type hints <type hint>`. "
"Till exempel::"

#: ../../glossary.rst:1427
msgid ""
"def remove_gray_shades(\n"
"        colors: list[tuple[int, int, int]]) -> list[tuple[int, int, int]]:\n"
"    pass"
msgstr ""
"def remove_gray_shades(\n"
"        färger: lista[tupel[int, int, int]]) -> lista[tupel[int, int, "
"int]]:\n"
"    pass"

#: ../../glossary.rst:1431
msgid "could be made more readable like this::"
msgstr "skulle kunna göras mer läsbar på följande sätt::"

#: ../../glossary.rst:1433
msgid ""
"Color = tuple[int, int, int]\n"
"\n"
"def remove_gray_shades(colors: list[Color]) -> list[Color]:\n"
"    pass"
msgstr ""
"Color = tuple[int, int, int]\n"
"\n"
"def remove_gray_shades(colors: list[Color]) -> list[Color]:\n"
"    pass"

#: ../../glossary.rst:1438 ../../glossary.rst:1452
msgid "See :mod:`typing` and :pep:`484`, which describe this functionality."
msgstr "Se :mod:`typing` och :pep:`484`, som beskriver denna funktionalitet."

#: ../../glossary.rst:1439
msgid "type hint"
msgstr "typ ledtråd"

#: ../../glossary.rst:1441
msgid ""
"An :term:`annotation` that specifies the expected type for a variable, a "
"class attribute, or a function parameter or return value."
msgstr ""
"En :term:`annotation` som anger den förväntade typen för en variabel, ett "
"klassattribut eller en funktionsparameter eller ett returvärde."

#: ../../glossary.rst:1444
msgid ""
"Type hints are optional and are not enforced by Python but they are useful "
"to :term:`static type checkers <static type checker>`. They can also aid "
"IDEs with code completion and refactoring."
msgstr ""
"Typtips är valfria och tillämpas inte av Python, men de är användbara för :"
"term:`statiska typkontrollprogram <static type checker>`. De kan också "
"hjälpa IDE:er med kodkomplettering och refaktorisering."

#: ../../glossary.rst:1448
msgid ""
"Type hints of global variables, class attributes, and functions, but not "
"local variables, can be accessed using :func:`typing.get_type_hints`."
msgstr ""
"Typtips för globala variabler, klassattribut och funktioner, men inte för "
"lokala variabler, kan hämtas med :func:`typing.get_type_hints`."

#: ../../glossary.rst:1453
msgid "universal newlines"
msgstr "universella nya rader"

#: ../../glossary.rst:1455
msgid ""
"A manner of interpreting text streams in which all of the following are "
"recognized as ending a line: the Unix end-of-line convention ``'\\n'``, the "
"Windows convention ``'\\r\\n'``, and the old Macintosh convention "
"``'\\r'``.  See :pep:`278` and :pep:`3116`, as well as :func:`bytes."
"splitlines` for an additional use."
msgstr ""
"Ett sätt att tolka textflöden där alla följande tecken anses avsluta en rad: "
"Unix radavslutskonvention ``'\\n'``, Windows-konventionen ``'\\r\\n'`` och "
"den gamla Macintosh-konventionen ``'\\r'``.  Se :pep:`278` och :pep:`3116`, "
"samt :func:`bytes.splitlines` för ytterligare en användning."

#: ../../glossary.rst:1460
msgid "variable annotation"
msgstr "variabel annotation"

#: ../../glossary.rst:1462
msgid "An :term:`annotation` of a variable or a class attribute."
msgstr "En :term:`annotation` av en variabel eller ett klassattribut."

#: ../../glossary.rst:1464
msgid ""
"When annotating a variable or a class attribute, assignment is optional::"
msgstr ""
"Vid annotering av en variabel eller ett klassattribut är tilldelningen "
"valfri::"

#: ../../glossary.rst:1466
msgid ""
"class C:\n"
"    field: 'annotation'"
msgstr ""
"klass C:\n"
"    fält: \"annotation"

#: ../../glossary.rst:1469
msgid ""
"Variable annotations are usually used for :term:`type hints <type hint>`: "
"for example this variable is expected to take :class:`int` values::"
msgstr ""
"Variabelannoteringar används vanligtvis för :term:`type hints <type hint>`: "
"till exempel förväntas denna variabel ta :class:`int`-värden::"

#: ../../glossary.rst:1473
msgid "count: int = 0"
msgstr "antal: int = 0"

#: ../../glossary.rst:1475
msgid "Variable annotation syntax is explained in section :ref:`annassign`."
msgstr ""
"Syntaxen för variabelannoteringar förklaras i avsnittet :ref:`annassign`."

#: ../../glossary.rst:1477
msgid ""
"See :term:`function annotation`, :pep:`484` and :pep:`526`, which describe "
"this functionality. Also see :ref:`annotations-howto` for best practices on "
"working with annotations."
msgstr ""
"Se :term:`function annotation`, :pep:`484` och :pep:`526`, som beskriver "
"denna funktionalitet. Se även :ref:`annotations-howto` för bästa praxis för "
"att arbeta med annoteringar."

#: ../../glossary.rst:1481
msgid "virtual environment"
msgstr "virtuell miljö"

#: ../../glossary.rst:1483
msgid ""
"A cooperatively isolated runtime environment that allows Python users and "
"applications to install and upgrade Python distribution packages without "
"interfering with the behaviour of other Python applications running on the "
"same system."
msgstr ""
"En kooperativt isolerad körtidsmiljö som gör det möjligt för Python-"
"användare och -program att installera och uppgradera Python-"
"distributionspaket utan att störa beteendet hos andra Python-program som "
"körs på samma system."

#: ../../glossary.rst:1488
msgid "See also :mod:`venv`."
msgstr "Se även :mod:`venv`."

#: ../../glossary.rst:1489
msgid "virtual machine"
msgstr "virtuell maskin"

#: ../../glossary.rst:1491
msgid ""
"A computer defined entirely in software.  Python's virtual machine executes "
"the :term:`bytecode` emitted by the bytecode compiler."
msgstr ""
"En dator som är helt definierad i programvara.  Pythons virtuella maskin "
"exekverar den :term:`bytekod` som bytekodskompilatorn ger ut."

#: ../../glossary.rst:1493
msgid "walrus operator"
msgstr "valrossoperatör"

#: ../../glossary.rst:1495
msgid ""
"A light-hearted way to refer to the :ref:`assignment expression <assignment-"
"expressions>` operator ``:=`` because it looks a bit like a walrus if you "
"turn your head."
msgstr ""

#: ../../glossary.rst:1498
msgid "Zen of Python"
msgstr "Zen av Python"

#: ../../glossary.rst:1500
msgid ""
"Listing of Python design principles and philosophies that are helpful in "
"understanding and using the language.  The listing can be found by typing "
"\"``import this``\" at the interactive prompt."
msgstr ""
"Lista över Pythons designprinciper och filosofier som är till hjälp för att "
"förstå och använda språket.  Listan kan hittas genom att skriva \"``import "
"this``\" vid den interaktiva prompten."

#: ../../glossary.rst:24
msgid "..."
msgstr "..."

#: ../../glossary.rst:24
msgid "ellipsis literal"
msgstr "ellips bokstavlig"

#: ../../glossary.rst:321
msgid "C-contiguous"
msgstr "C-slutande"

#: ../../glossary.rst:321
msgid "Fortran contiguous"
msgstr "Fortran sammanhängande"

#: ../../glossary.rst:884
msgid "magic"
msgstr "magi"

#: ../../glossary.rst:1299
msgid "special"
msgstr "speciella"
