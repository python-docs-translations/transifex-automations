# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# python-doc bot, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-25 16:33+0000\n"
"PO-Revision-Date: 2025-09-22 16:51+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../tutorial/inputoutput.rst:5
msgid "Input and Output"
msgstr "Inmatning och utmatning"

#: ../../tutorial/inputoutput.rst:7
msgid ""
"There are several ways to present the output of a program; data can be "
"printed in a human-readable form, or written to a file for future use. This "
"chapter will discuss some of the possibilities."
msgstr ""
"Det finns flera sätt att presentera utdata från ett program; data kan "
"skrivas ut i en läsbar form eller skrivas till en fil för framtida "
"användning. I detta kapitel diskuteras några av dessa möjligheter."

#: ../../tutorial/inputoutput.rst:15
msgid "Fancier Output Formatting"
msgstr "Mer avancerad utmatningsformatering"

#: ../../tutorial/inputoutput.rst:17
msgid ""
"So far we've encountered two ways of writing values: *expression statements*"
" and the :func:`print` function.  (A third way is using the "
":meth:`~io.TextIOBase.write` method of file objects; the standard output "
"file can be referenced as ``sys.stdout``. See the Library Reference for more"
" information on this.)"
msgstr ""
"Hittills har vi stött på två sätt att skriva värden: *uttryckssatser* och "
"funktionen :func:`print`.  (Ett tredje sätt är att använda metoden "
":meth:`~io.TextIOBase.write` för filobjekt; standardutdatafilen kan "
"refereras till som ``sys.stdout``. Se biblioteksreferensen för mer "
"information om detta)"

#: ../../tutorial/inputoutput.rst:22
msgid ""
"Often you'll want more control over the formatting of your output than "
"simply printing space-separated values. There are several ways to format "
"output."
msgstr ""
"Ofta vill du ha mer kontroll över formateringen av dina utdata än att bara "
"skriva ut mellanslagsseparerade värden. Det finns flera sätt att formatera "
"utdata."

#: ../../tutorial/inputoutput.rst:25
msgid ""
"To use :ref:`formatted string literals <tut-f-strings>`, begin a string with"
" ``f`` or ``F`` before the opening quotation mark or triple quotation mark. "
"Inside this string, you can write a Python expression between ``{`` and "
"``}`` characters that can refer to variables or literal values."
msgstr ""
"För att använda :ref:`formaterade stränglitteraler <tut-f-strings>`, börja "
"en sträng med ``f`` eller ``F`` före det inledande citattecknet eller "
"trippelcitationstecknet. Inuti denna sträng kan du skriva ett Python-uttryck"
" mellan tecknen ``{`` och ``}`` som kan referera till variabler eller "
"bokstavliga värden."

#: ../../tutorial/inputoutput.rst:37
msgid ""
"The :meth:`str.format` method of strings requires more manual effort.  "
"You'll still use ``{`` and ``}`` to mark where a variable will be "
"substituted and can provide detailed formatting directives, but you'll also "
"need to provide the information to be formatted."
msgstr ""

#: ../../tutorial/inputoutput.rst:50
msgid ""
"Finally, you can do all the string handling yourself by using string slicing"
" and concatenation operations to create any layout you can imagine.  The "
"string type has some methods that perform useful operations for padding "
"strings to a given column width."
msgstr ""
"Slutligen kan du göra all stränghantering själv genom att använda "
"strängskärning och konkatenering för att skapa vilken layout du än kan tänka"
" dig.  Strängtypen har några metoder som utför användbara operationer för "
"att fylla ut strängar till en given kolumnbredd."

#: ../../tutorial/inputoutput.rst:55
msgid ""
"When you don't need fancy output but just want a quick display of some "
"variables for debugging purposes, you can convert any value to a string with"
" the :func:`repr` or :func:`str` functions."
msgstr ""
"Om du inte behöver några avancerade utdata utan bara vill ha en snabb "
"visning av några variabler för felsökning kan du konvertera valfritt värde "
"till en sträng med funktionerna :func:`repr` eller :func:`str`."

#: ../../tutorial/inputoutput.rst:59
msgid ""
"The :func:`str` function is meant to return representations of values which "
"are fairly human-readable, while :func:`repr` is meant to generate "
"representations which can be read by the interpreter (or will force a "
":exc:`SyntaxError` if there is no equivalent syntax).  For objects which "
"don't have a particular representation for human consumption, :func:`str` "
"will return the same value as :func:`repr`.  Many values, such as numbers or"
" structures like lists and dictionaries, have the same representation using "
"either function.  Strings, in particular, have two distinct representations."
msgstr ""
"Funktionen :func:`str` är tänkt att returnera representationer av värden som"
" är någorlunda läsbara för människor, medan :func:`repr` är tänkt att "
"generera representationer som kan läsas av tolken (eller tvinga fram ett "
":exc:`SyntaxError` om det inte finns någon motsvarande syntax).  För objekt "
"som inte har en särskild representation för mänsklig konsumtion, kommer "
":func:`str` att returnera samma värde som :func:`repr`.  Många värden, t.ex."
" tal eller strukturer som listor och ordböcker, har samma representation med"
" båda funktionerna.  Strängar, i synnerhet, har två olika representationer."

#: ../../tutorial/inputoutput.rst:68
msgid "Some examples::"
msgstr "Några exempel::"

#: ../../tutorial/inputoutput.rst:91
msgid ""
"The :mod:`string` module contains a :class:`~string.Template` class that "
"offers yet another way to substitute values into strings, using placeholders"
" like ``$x`` and replacing them with values from a dictionary, but offers "
"much less control of the formatting."
msgstr ""

#: ../../tutorial/inputoutput.rst:100
msgid "Formatted String Literals"
msgstr "Formaterade strängbokstäver"

#: ../../tutorial/inputoutput.rst:102
msgid ""
":ref:`Formatted string literals <f-strings>` (also called f-strings for "
"short) let you include the value of Python expressions inside a string by "
"prefixing the string with ``f`` or ``F`` and writing expressions as "
"``{expression}``."
msgstr ""
":ref:`Formaterade stränglitteraler <f-strings>` (även kallade f-strängar i "
"korthet) låter dig inkludera värdet av Python-uttryck inuti en sträng genom "
"att prefixera strängen med ``f`` eller ``F`` och skriva uttryck som "
"``{expression}``."

#: ../../tutorial/inputoutput.rst:107
msgid ""
"An optional format specifier can follow the expression. This allows greater "
"control over how the value is formatted. The following example rounds pi to "
"three places after the decimal::"
msgstr ""
"En valfri formatspecifikator kan följa efter uttrycket. Detta ger större "
"kontroll över hur värdet formateras. I följande exempel avrundas pi till tre"
" ställen efter decimalen::"

#: ../../tutorial/inputoutput.rst:115
msgid ""
"Passing an integer after the ``':'`` will cause that field to be a minimum "
"number of characters wide.  This is useful for making columns line up. ::"
msgstr ""
"Om du skickar ett heltal efter ``':'`` blir fältet minst ett antal tecken "
"brett.  Detta är användbart för att få kolumner att rada upp sig. ::"

#: ../../tutorial/inputoutput.rst:126
msgid ""
"Other modifiers can be used to convert the value before it is formatted. "
"``'!a'`` applies :func:`ascii`, ``'!s'`` applies :func:`str`, and ``'!r'`` "
"applies :func:`repr`::"
msgstr ""
"Andra modifierare kan användas för att konvertera värdet innan det "
"formateras. ``'!a'`` tillämpar :func:`ascii`, ``'!s'`` tillämpar "
":func:`str`, och ``'!r'`` tillämpar :func:`repr`::"

#: ../../tutorial/inputoutput.rst:136
msgid ""
"The ``=`` specifier can be used to expand an expression to the text of the "
"expression, an equal sign, then the representation of the evaluated "
"expression:"
msgstr ""
"Specificeraren ``=`` kan användas för att expandera ett uttryck till texten "
"i uttrycket, ett likhetstecken och sedan representationen av det utvärderade"
" uttrycket:"

#: ../../tutorial/inputoutput.rst:145
msgid ""
"See :ref:`self-documenting expressions <bpo-36817-whatsnew>` for more "
"information on the ``=`` specifier. For a reference on these format "
"specifications, see the reference guide for the :ref:`formatspec`."
msgstr ""
"Se :ref:`self-documenting expressions <bpo-36817-whatsnew>` för mer "
"information om ``=`` specifikatorn. För en referens om dessa "
"formatspecifikationer, se referensguiden för :ref:`formatspec`."

#: ../../tutorial/inputoutput.rst:152
msgid "The String format() Method"
msgstr "Metoden String format()"

#: ../../tutorial/inputoutput.rst:154
msgid "Basic usage of the :meth:`str.format` method looks like this::"
msgstr ""
"Grundläggande användning av metoden :meth:`str.format` ser ut så här::"

#: ../../tutorial/inputoutput.rst:159
msgid ""
"The brackets and characters within them (called format fields) are replaced "
"with the objects passed into the :meth:`str.format` method.  A number in the"
" brackets can be used to refer to the position of the object passed into the"
" :meth:`str.format` method. ::"
msgstr ""
"Parenteserna och tecknen inom dem (som kallas formatfält) ersätts med de "
"objekt som skickas till metoden :meth:`str.format`.  Ett tal inom parentes "
"kan användas för att referera till positionen för det objekt som skickas "
"till metoden :meth:`str.format`. ::"

#: ../../tutorial/inputoutput.rst:169
msgid ""
"If keyword arguments are used in the :meth:`str.format` method, their values"
" are referred to by using the name of the argument. ::"
msgstr ""
"Om nyckelordsargument används i metoden :meth:`str.format` refereras till "
"deras värden genom att använda argumentets namn. ::"

#: ../../tutorial/inputoutput.rst:176
msgid "Positional and keyword arguments can be arbitrarily combined::"
msgstr "Positions- och nyckelordsargument kan kombineras godtyckligt::"

#: ../../tutorial/inputoutput.rst:182
msgid ""
"If you have a really long format string that you don't want to split up, it "
"would be nice if you could reference the variables to be formatted by name "
"instead of by position.  This can be done by simply passing the dict and "
"using square brackets ``'[]'`` to access the keys. ::"
msgstr ""
"Om du har en riktigt lång formatsträng som du inte vill dela upp, skulle det"
" vara bra om du kunde referera till variablerna som ska formateras med namn "
"istället för med position.  Detta kan göras genom att helt enkelt skicka "
"dict och använda hakparenteser ``'[]'`` för att komma åt nycklarna. ::"

#: ../../tutorial/inputoutput.rst:192
msgid ""
"This could also be done by passing the ``table`` dictionary as keyword "
"arguments with the ``**`` notation. ::"
msgstr ""
"Detta kan också göras genom att skicka ordboken ``table`` som "
"nyckelordsargument med notation ``**``. ::"

#: ../../tutorial/inputoutput.rst:199
msgid ""
"This is particularly useful in combination with the built-in function "
":func:`vars`, which returns a dictionary containing all local variables."
msgstr ""

#: ../../tutorial/inputoutput.rst:202
msgid ""
"As an example, the following lines produce a tidily aligned set of columns "
"giving integers and their squares and cubes::"
msgstr ""
"Som exempel kan nämnas att följande rader ger en välordnad uppsättning "
"kolumner med heltal och deras kvadrater och kuber::"

#: ../../tutorial/inputoutput.rst:219
msgid ""
"For a complete overview of string formatting with :meth:`str.format`, see "
":ref:`formatstrings`."
msgstr ""
"För en fullständig översikt över strängformatering med :meth:`str.format`, "
"se :ref:`formatstrings`."

#: ../../tutorial/inputoutput.rst:224
msgid "Manual String Formatting"
msgstr "Manuell strängformatering"

#: ../../tutorial/inputoutput.rst:226
msgid "Here's the same table of squares and cubes, formatted manually::"
msgstr "Här är samma tabell med kvadrater och kuber, formaterad manuellt::"

#: ../../tutorial/inputoutput.rst:244
msgid ""
"(Note that the one space between each column was added by the way "
":func:`print` works: it always adds spaces between its arguments.)"
msgstr ""
"(Observera att ett mellanslag mellan varje kolumn lades till på grund av hur"
" :func:`print` fungerar: den lägger alltid till mellanslag mellan sina "
"argument)"

#: ../../tutorial/inputoutput.rst:247
msgid ""
"The :meth:`str.rjust` method of string objects right-justifies a string in a"
" field of a given width by padding it with spaces on the left. There are "
"similar methods :meth:`str.ljust` and :meth:`str.center`. These methods do "
"not write anything, they just return a new string. If the input string is "
"too long, they don't truncate it, but return it unchanged; this will mess up"
" your column lay-out but that's usually better than the alternative, which "
"would be lying about a value. (If you really want truncation you can always "
"add a slice operation, as in ``x.ljust(n)[:n]``.)"
msgstr ""
"Metoden :meth:`str.rjust` för strängobjekt högerjusterar en sträng i ett "
"fält med en given bredd genom att fylla ut den med mellanslag till vänster. "
"Det finns liknande metoder :meth:`str.ljust` och :meth:`str.center`. Dessa "
"metoder skriver inte något, de returnerar bara en ny sträng. Om "
"indatasträngen är för lång trunkerar de den inte utan returnerar den "
"oförändrad; detta kommer att röra till din kolumnlayout men det är "
"vanligtvis bättre än alternativet, vilket skulle vara att ljuga om ett "
"värde. (Om du verkligen vill ha trunkering kan du alltid lägga till en "
"slice-operation, som i ``x.ljust(n)[:n]``)"

#: ../../tutorial/inputoutput.rst:256
msgid ""
"There is another method, :meth:`str.zfill`, which pads a numeric string on "
"the left with zeros.  It understands about plus and minus signs::"
msgstr ""
"Det finns en annan metod, :meth:`str.zfill`, som fyller ut en numerisk "
"sträng till vänster med nollor.  Den förstår sig på plus- och minustecken::"

#: ../../tutorial/inputoutput.rst:268
msgid "Old string formatting"
msgstr "Gammal strängformatering"

#: ../../tutorial/inputoutput.rst:270
msgid ""
"The % operator (modulo) can also be used for string formatting. Given "
"``'string' % values``, instances of ``%`` in ``string`` are replaced with "
"zero or more elements of ``values``. This operation is commonly known as "
"string interpolation. For example::"
msgstr ""

#: ../../tutorial/inputoutput.rst:279
msgid ""
"More information can be found in the :ref:`old-string-formatting` section."
msgstr "Mer information finns i avsnittet :ref:`old-string-formatting`."

#: ../../tutorial/inputoutput.rst:285
msgid "Reading and Writing Files"
msgstr "Läsa och skriva filer"

#: ../../tutorial/inputoutput.rst:291
msgid ""
":func:`open` returns a :term:`file object`, and is most commonly used with "
"two positional arguments and one keyword argument: ``open(filename, mode, "
"encoding=None)``"
msgstr ""
":func:`open` returnerar ett :term:`file object`, och används oftast med två "
"positionella argument och ett nyckelordsargument: ``open(filename, mode, "
"encoding=None)``"

#: ../../tutorial/inputoutput.rst:304
msgid ""
"The first argument is a string containing the filename.  The second argument"
" is another string containing a few characters describing the way in which "
"the file will be used.  *mode* can be ``'r'`` when the file will only be "
"read, ``'w'`` for only writing (an existing file with the same name will be "
"erased), and ``'a'`` opens the file for appending; any data written to the "
"file is automatically added to the end.  ``'r+'`` opens the file for both "
"reading and writing. The *mode* argument is optional; ``'r'`` will be "
"assumed if it's omitted."
msgstr ""
"Det första argumentet är en sträng som innehåller filnamnet.  Det andra "
"argumentet är en annan sträng som innehåller några tecken som beskriver hur "
"filen ska användas.  *mode* kan vara ``'r'`` om filen bara ska läsas, "
"``'w'`` om den bara ska skrivas (en befintlig fil med samma namn raderas), "
"och ``'a'`` öppnar filen för tillägg; all data som skrivs till filen läggs "
"automatiskt till i slutet.  ``'r+'`` öppnar filen för både läsning och "
"skrivning. Argumentet *mode* är valfritt; ``'r'`` kommer att antas om det "
"utelämnas."

#: ../../tutorial/inputoutput.rst:313
msgid ""
"Normally, files are opened in :dfn:`text mode`, that means, you read and "
"write strings from and to the file, which are encoded in a specific "
"*encoding*. If *encoding* is not specified, the default is platform "
"dependent (see :func:`open`). Because UTF-8 is the modern de-facto standard,"
" ``encoding=\"utf-8\"`` is recommended unless you know that you need to use "
"a different encoding. Appending a ``'b'`` to the mode opens the file in "
":dfn:`binary mode`. Binary mode data is read and written as :class:`bytes` "
"objects. You can not specify *encoding* when opening file in binary mode."
msgstr ""
"Normalt öppnas filer i :dfn:`text mode`, vilket innebär att du läser och "
"skriver strängar från och till filen, som är kodade i en specifik "
"*encoding*. Om *encoding* inte anges är standardinställningen "
"plattformsberoende (se :func:`open`). Eftersom UTF-8 är den moderna de-"
"facto-standarden rekommenderas ``encoding=\"utf-8\"`` om du inte vet att du "
"behöver använda en annan kodning. Genom att lägga till ``'b'`` till mode "
"öppnas filen i :dfn:`binary mode`. Data i binärt läge läses och skrivs som "
":class:`bytes`\\-objekt. Du kan inte ange *kodning* när du öppnar en fil i "
"binärt läge."

#: ../../tutorial/inputoutput.rst:323
msgid ""
"In text mode, the default when reading is to convert platform-specific line "
"endings (``\\n`` on Unix, ``\\r\\n`` on Windows) to just ``\\n``.  When "
"writing in text mode, the default is to convert occurrences of ``\\n`` back "
"to platform-specific line endings.  This behind-the-scenes modification to "
"file data is fine for text files, but will corrupt binary data like that in "
":file:`JPEG` or :file:`EXE` files.  Be very careful to use binary mode when "
"reading and writing such files."
msgstr ""
"I textläge är standardinställningen vid läsning att konvertera "
"plattformsspecifika radavslutningar (``\\n`` på Unix, ``\\r\\n`` på Windows)"
" till bara ``\\n``.  När du skriver i textläge är standardinställningen att "
"konvertera förekomster av ``\\n`` tillbaka till plattformsspecifika "
"radavslut.  Denna bakomliggande modifiering av fildata är bra för textfiler,"
" men kommer att korrumpera binära data som i :file:`JPEG`\\- eller "
":file:`EXE`\\-filer.  Var mycket försiktig med att använda binärt läge när "
"du läser och skriver sådana filer."

#: ../../tutorial/inputoutput.rst:331
msgid ""
"It is good practice to use the :keyword:`with` keyword when dealing with "
"file objects.  The advantage is that the file is properly closed after its "
"suite finishes, even if an exception is raised at some point.  Using "
":keyword:`!with` is also much shorter than writing equivalent "
":keyword:`try`\\ -\\ :keyword:`finally` blocks::"
msgstr ""
"Det är god praxis att använda nyckelordet :keyword:`with` när man hanterar "
"filobjekt.  Fördelen är att filen stängs på rätt sätt när dess svit är klar,"
" även om ett undantag uppstår vid något tillfälle.  Att använda "
":keyword:`!with` är också mycket kortare än att skriva motsvarande "
":keyword:`try`\\- :keyword:`finally`\\-block::"

#: ../../tutorial/inputoutput.rst:344
msgid ""
"If you're not using the :keyword:`with` keyword, then you should call "
"``f.close()`` to close the file and immediately free up any system resources"
" used by it."
msgstr ""
"Om du inte använder nyckelordet :keyword:`with` bör du anropa ``f.close()`` "
"för att stänga filen och omedelbart frigöra alla systemresurser som används "
"av den."

#: ../../tutorial/inputoutput.rst:349
msgid ""
"Calling ``f.write()`` without using the :keyword:`!with` keyword or calling "
"``f.close()`` **might** result in the arguments of ``f.write()`` not being "
"completely written to the disk, even if the program exits successfully."
msgstr ""
"Anrop av ``f.write()`` utan att använda nyckelordet :keyword:`!with` eller "
"anrop av ``f.close()`` **kan** resultera i att argumenten i ``f.write()`` "
"inte skrivs ut fullständigt till disken, även om programmet avslutas "
"framgångsrikt."

#: ../../tutorial/inputoutput.rst:357
msgid ""
"After a file object is closed, either by a :keyword:`with` statement or by "
"calling ``f.close()``, attempts to use the file object will automatically "
"fail. ::"
msgstr ""
"När ett filobjekt har stängts, antingen genom en :keyword:`with`\\-sats "
"eller genom att anropa ``f.close()``, kommer försök att använda filobjektet "
"automatiskt att misslyckas. ::"

#: ../../tutorial/inputoutput.rst:371
msgid "Methods of File Objects"
msgstr "Metoder för filobjekt"

#: ../../tutorial/inputoutput.rst:373
msgid ""
"The rest of the examples in this section will assume that a file object "
"called ``f`` has already been created."
msgstr ""
"I resten av exemplen i det här avsnittet förutsätts att ett filobjekt med "
"namnet ``f`` redan har skapats."

#: ../../tutorial/inputoutput.rst:376
msgid ""
"To read a file's contents, call ``f.read(size)``, which reads some quantity "
"of data and returns it as a string (in text mode) or bytes object (in binary"
" mode). *size* is an optional numeric argument.  When *size* is omitted or "
"negative, the entire contents of the file will be read and returned; it's "
"your problem if the file is twice as large as your machine's memory. "
"Otherwise, at most *size* characters (in text mode) or *size* bytes (in "
"binary mode) are read and returned. If the end of the file has been reached,"
" ``f.read()`` will return an empty string (``''``).  ::"
msgstr ""
"För att läsa en fils innehåll, anropa ``f.read(size)``, som läser en viss "
"mängd data och returnerar den som en sträng (i textläge) eller ett "
"bytesobjekt (i binärt läge). *size* är ett valfritt numeriskt argument.  När"
" *size* utelämnas eller är negativt kommer hela filens innehåll att läsas "
"och returneras; det är ditt problem om filen är dubbelt så stor som din "
"maskins minne. Annars läses och returneras högst *size* tecken (i textläge) "
"eller *size* byte (i binärt läge). Om slutet av filen har nåtts kommer "
"``f.read()`` att returnera en tom sträng (``''``).  ::"

#: ../../tutorial/inputoutput.rst:390
msgid ""
"``f.readline()`` reads a single line from the file; a newline character "
"(``\\n``) is left at the end of the string, and is only omitted on the last "
"line of the file if the file doesn't end in a newline.  This makes the "
"return value unambiguous; if ``f.readline()`` returns an empty string, the "
"end of the file has been reached, while a blank line is represented by "
"``'\\n'``, a string containing only a single newline.  ::"
msgstr ""
"``f.readline()`` läser en enda rad från filen; ett tecken för ny rad "
"(``\\n``) lämnas i slutet av strängen och utelämnas endast på den sista "
"raden i filen om filen inte slutar med en ny rad.  Detta gör returvärdet "
"otvetydigt; om ``f.readline()`` returnerar en tom sträng har slutet på filen"
" nåtts, medan en tom rad representeras av ``'\\n'``, en sträng som bara "
"innehåller en enda ny rad. ::"

#: ../../tutorial/inputoutput.rst:404
msgid ""
"For reading lines from a file, you can loop over the file object. This is "
"memory efficient, fast, and leads to simple code::"
msgstr ""
"För att läsa rader från en fil kan du loopa över filobjektet. Detta är "
"minnessnålt, snabbt och leder till enkel kod::"

#: ../../tutorial/inputoutput.rst:413
msgid ""
"If you want to read all the lines of a file in a list you can also use "
"``list(f)`` or ``f.readlines()``."
msgstr ""
"Om du vill läsa alla rader i en fil i en lista kan du också använda "
"``list(f)`` eller ``f.readlines()``."

#: ../../tutorial/inputoutput.rst:416
msgid ""
"``f.write(string)`` writes the contents of *string* to the file, returning "
"the number of characters written. ::"
msgstr ""
"``f.write(string)`` skriver innehållet i *string* till filen och returnerar "
"antalet tecken som skrivits. ::"

#: ../../tutorial/inputoutput.rst:422
msgid ""
"Other types of objects need to be converted -- either to a string (in text "
"mode) or a bytes object (in binary mode) -- before writing them::"
msgstr ""
"Andra typer av objekt måste konverteras - antingen till en sträng (i "
"textläge) eller till ett bytesobjekt (i binärt läge) - innan de skrivs::"

#: ../../tutorial/inputoutput.rst:430
msgid ""
"``f.tell()`` returns an integer giving the file object's current position in"
" the file represented as number of bytes from the beginning of the file when"
" in binary mode and an opaque number when in text mode."
msgstr ""
"``f.tell()`` returnerar ett heltal som anger filobjektets aktuella position "
"i filen representerat som antal byte från början av filen i binärläge och "
"ett opakt tal i textläge."

#: ../../tutorial/inputoutput.rst:434
msgid ""
"To change the file object's position, use ``f.seek(offset, whence)``.  The "
"position is computed from adding *offset* to a reference point; the "
"reference point is selected by the *whence* argument.  A *whence* value of 0"
" measures from the beginning of the file, 1 uses the current file position, "
"and 2 uses the end of the file as the reference point.  *whence* can be "
"omitted and defaults to 0, using the beginning of the file as the reference "
"point. ::"
msgstr ""
"Om du vill ändra filobjektets position använder du ``f.seek(offset, "
"whence)``.  Positionen beräknas genom att lägga till *offset* till en "
"referenspunkt; referenspunkten väljs med argumentet *whence*.  Ett "
"*whence*-värde på 0 mäter från början av filen, 1 använder den aktuella "
"filpositionen och 2 använder slutet av filen som referenspunkt.  *whence* "
"kan utelämnas och har standardvärdet 0, vilket innebär att filens början "
"används som referenspunkt. ::"

#: ../../tutorial/inputoutput.rst:453
msgid ""
"In text files (those opened without a ``b`` in the mode string), only seeks "
"relative to the beginning of the file are allowed (the exception being "
"seeking to the very file end with ``seek(0, 2)``) and the only valid "
"*offset* values are those returned from the ``f.tell()``, or zero. Any other"
" *offset* value produces undefined behaviour."
msgstr ""
"I textfiler (som öppnas utan ``b`` i lägessträngen) tillåts endast sökningar"
" relativt början av filen (undantaget är sökning till slutet av filen med "
"``seek(0, 2)``) och de enda giltiga *offset*-värdena är de som returneras "
"från ``f.tell()``, eller noll. Alla andra *offset*-värden ger ett "
"odefinierat beteende."

#: ../../tutorial/inputoutput.rst:459
msgid ""
"File objects have some additional methods, such as :meth:`~io.IOBase.isatty`"
" and :meth:`~io.IOBase.truncate` which are less frequently used; consult the"
" Library Reference for a complete guide to file objects."
msgstr ""
"Filobjekt har några ytterligare metoder, t.ex. :meth:`~io.IOBase.isatty` och"
" :meth:`~io.IOBase.truncate` som används mindre ofta; se Library Reference "
"för en fullständig guide till filobjekt."

#: ../../tutorial/inputoutput.rst:467
msgid "Saving structured data with :mod:`json`"
msgstr "Spara strukturerad data med :mod:`json`"

#: ../../tutorial/inputoutput.rst:471
msgid ""
"Strings can easily be written to and read from a file.  Numbers take a bit "
"more effort, since the :meth:`~io.TextIOBase.read` method only returns "
"strings, which will have to be passed to a function like :func:`int`, which "
"takes a string like ``'123'`` and returns its numeric value 123.  When you "
"want to save more complex data types like nested lists and dictionaries, "
"parsing and serializing by hand becomes complicated."
msgstr ""
"Strängar kan enkelt skrivas till och läsas från en fil.  Siffror kräver lite"
" mer ansträngning, eftersom metoden :meth:`~io.TextIOBase.read` bara "
"returnerar strängar, som måste skickas till en funktion som :func:`int`, som"
" tar en sträng som ``'123'`` och returnerar dess numeriska värde 123.  När "
"du vill spara mer komplexa datatyper som nästlade listor och lexikon blir "
"det komplicerat att parsa och serialisera för hand."

#: ../../tutorial/inputoutput.rst:478
msgid ""
"Rather than having users constantly writing and debugging code to save "
"complicated data types to files, Python allows you to use the popular data "
"interchange format called `JSON (JavaScript Object Notation) "
"<https://json.org>`_.  The standard module called :mod:`json` can take "
"Python data hierarchies, and convert them to string representations; this "
"process is called :dfn:`serializing`.  Reconstructing the data from the "
"string representation is called :dfn:`deserializing`.  Between serializing "
"and deserializing, the string representing the object may have been stored "
"in a file or data, or sent over a network connection to some distant "
"machine."
msgstr ""
"I stället för att användarna ständigt måste skriva och felsöka kod för att "
"spara komplicerade datatyper i filer, kan du med Python använda det populära"
" datautbytesformatet `JSON (JavaScript Object Notation) "
"<https://json.org>`_.  Standardmodulen som kallas :mod:`json` kan ta Python-"
"datahierarkier och konvertera dem till strängrepresentationer; denna process"
" kallas :dfn:`serializing`.  Att rekonstruera data från "
"strängrepresentationen kallas :dfn:`deserializing`.  Mellan serialisering "
"och deserialisering kan strängen som representerar objektet ha lagrats i en "
"fil eller data, eller skickats över en nätverksanslutning till någon "
"avlägsen maskin."

#: ../../tutorial/inputoutput.rst:489
msgid ""
"The JSON format is commonly used by modern applications to allow for data "
"exchange.  Many programmers are already familiar with it, which makes it a "
"good choice for interoperability."
msgstr ""
"JSON-formatet används ofta av moderna applikationer för att möjliggöra "
"datautbyte.  Många programmerare är redan bekanta med det, vilket gör det "
"till ett bra val för interoperabilitet."

#: ../../tutorial/inputoutput.rst:493
msgid ""
"If you have an object ``x``, you can view its JSON string representation "
"with a simple line of code::"
msgstr ""
"Om du har ett objekt ``x`` kan du visa dess JSON-strängrepresentation med en"
" enkel kodrad::"

#: ../../tutorial/inputoutput.rst:501
msgid ""
"Another variant of the :func:`~json.dumps` function, called "
":func:`~json.dump`, simply serializes the object to a :term:`text file`.  So"
" if ``f`` is a :term:`text file` object opened for writing, we can do this::"
msgstr ""
"En annan variant av funktionen :func:`~json.dumps`, som kallas "
":func:`~json.dump`, serialiserar helt enkelt objektet till en "
":term:`textfil`.  Så om ``f`` är ett :term:`text file`\\-objekt som är öppet"
" för skrivning kan vi göra så här::"

#: ../../tutorial/inputoutput.rst:507
msgid ""
"To decode the object again, if ``f`` is a :term:`binary file` or :term:`text"
" file` object which has been opened for reading::"
msgstr ""
"För att avkoda objektet igen, om ``f`` är ett :term:`binary file`\\- eller "
":term:`textfil`\\-objekt som har öppnats för läsning::"

#: ../../tutorial/inputoutput.rst:513
msgid ""
"JSON files must be encoded in UTF-8. Use ``encoding=\"utf-8\"`` when opening"
" JSON file as a :term:`text file` for both of reading and writing."
msgstr ""
"JSON-filer måste vara kodade i UTF-8. Använd ``encoding=\"utf-8\"`` när du "
"öppnar JSON-filen som en :term:`textfil` för både läsning och skrivning."

#: ../../tutorial/inputoutput.rst:516
msgid ""
"This simple serialization technique can handle lists and dictionaries, but "
"serializing arbitrary class instances in JSON requires a bit of extra "
"effort. The reference for the :mod:`json` module contains an explanation of "
"this."
msgstr ""
"Denna enkla serialiseringsteknik kan hantera listor och ordböcker, men "
"serialisering av godtyckliga klassinstanser i JSON kräver lite extra "
"ansträngning. Referensen för modulen :mod:`json` innehåller en förklaring av"
" detta."

#: ../../tutorial/inputoutput.rst:522
msgid ":mod:`pickle` - the pickle module"
msgstr ":mod:`pickle` - pickle-modulen"

#: ../../tutorial/inputoutput.rst:524
msgid ""
"Contrary to :ref:`JSON <tut-json>`, *pickle* is a protocol which allows the "
"serialization of arbitrarily complex Python objects.  As such, it is "
"specific to Python and cannot be used to communicate with applications "
"written in other languages.  It is also insecure by default: deserializing "
"pickle data coming from an untrusted source can execute arbitrary code, if "
"the data was crafted by a skilled attacker."
msgstr ""
"I motsats till :ref:`JSON <tut-json>` är *pickle* ett protokoll som tillåter"
" serialisering av godtyckligt komplexa Python-objekt.  Som sådant är det "
"specifikt för Python och kan inte användas för att kommunicera med "
"applikationer skrivna på andra språk.  Det är också osäkert som standard: "
"deserialisering av pickle-data som kommer från en icke betrodd källa kan "
"exekvera godtycklig kod om data har skapats av en skicklig angripare."

#: ../../tutorial/inputoutput.rst:287
msgid "built-in function"
msgstr "inbyggd funktion"

#: ../../tutorial/inputoutput.rst:287
msgid "open"
msgstr "öppen"

#: ../../tutorial/inputoutput.rst:287
msgid "object"
msgstr "object"

#: ../../tutorial/inputoutput.rst:287
msgid "file"
msgstr "fil"

#: ../../tutorial/inputoutput.rst:469
msgid "module"
msgstr "module"

#: ../../tutorial/inputoutput.rst:469
msgid "json"
msgstr "json"
