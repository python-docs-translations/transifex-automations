# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-10 15:26+0000\n"
"PO-Revision-Date: 2023-05-24 02:08+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Spanish (Spain) (https://app.transifex.com/python-doc/"
"teams/5390/es_ES/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es_ES\n"
"Plural-Forms: nplurals=3; plural=n == 1 ? 0 : n != 0 && n % 1000000 == 0 ? "
"1 : 2;\n"

#: ../../c-api/buffer.rst:11
msgid "Buffer Protocol"
msgstr "Protocolo de Búfer"

#: ../../c-api/buffer.rst:18
msgid ""
"Certain objects available in Python wrap access to an underlying memory "
"array or *buffer*.  Such objects include the built-in :class:`bytes` and :"
"class:`bytearray`, and some extension types like :class:`array.array`. Third-"
"party libraries may define their own types for special purposes, such as "
"image processing or numeric analysis."
msgstr ""
"Ciertos objetos disponibles en Python envuelven el acceso a una matriz de "
"memoria subyacente o * búfer*. Dichos objetos incluyen los built-in :class:"
"`bytes` y :class:`bytearray`, y algunos tipos de extensiones como :class:"
"`array.array`. Las bibliotecas de terceros pueden definir sus propios tipos "
"para fines especiales, como el procesamiento de imágenes o el análisis "
"numérico."

#: ../../c-api/buffer.rst:24
msgid ""
"While each of these types have their own semantics, they share the common "
"characteristic of being backed by a possibly large memory buffer.  It is "
"then desirable, in some situations, to access that buffer directly and "
"without intermediate copying."
msgstr ""
"Si bien cada uno de estos tipos tiene su propia semántica, comparten la "
"característica común de estar respaldados por un búfer de memoria "
"posiblemente grande. Así, en algunas ocasiones, es deseable acceder a esa "
"memoria intermedia directamente y sin copia intermedia."

#: ../../c-api/buffer.rst:29
msgid ""
"Python provides such a facility at the C level in the form of the :ref:"
"`buffer protocol <bufferobjects>`.  This protocol has two sides:"
msgstr ""
"Python proporciona tal facilidad en el nivel C en forma de  :ref:`buffer "
"protocolo <bufferobjects>`.  Este protocolo tiene dos lados:"

#: ../../c-api/buffer.rst:34
msgid ""
"on the producer side, a type can export a \"buffer interface\" which allows "
"objects of that type to expose information about their underlying buffer. "
"This interface is described in the section :ref:`buffer-structs`;"
msgstr ""
"en el lado del productor, un tipo puede exportar una \"interfaz de búfer\" "
"que permite a los objetos de ese tipo exponer información sobre su búfer "
"subyacente. Esta interfaz se describe en la sección:ref:`buffer-structs`;"

#: ../../c-api/buffer.rst:38
msgid ""
"on the consumer side, several means are available to obtain a pointer to the "
"raw underlying data of an object (for example a method parameter)."
msgstr ""
"en el lado del consumidor, hay disponibles varios medios para obtener un "
"puntero a los datos subyacentes sin procesar de un objeto (por ejemplo, un "
"parámetro de método)."

#: ../../c-api/buffer.rst:41
msgid ""
"Simple objects such as :class:`bytes` and :class:`bytearray` expose their "
"underlying buffer in byte-oriented form.  Other forms are possible; for "
"example, the elements exposed by an :class:`array.array` can be multi-byte "
"values."
msgstr ""
"Objetos simples como :class:`bytes` y :class:`bytearray` exponen el "
"contenido de su buffer en forma de byte. Otras formas son posibles; por "
"ejemplo, los elementos expuestos por un :class:`array.array` pueden tener "
"valores multi-byte."

#: ../../c-api/buffer.rst:45
msgid ""
"An example consumer of the buffer interface is the :meth:`~io.BufferedIOBase."
"write` method of file objects: any object that can export a series of bytes "
"through the buffer interface can be written to a file.  While :meth:`!write` "
"only needs read-only access to the internal contents of the object passed to "
"it, other methods such as :meth:`~io.BufferedIOBase.readinto` need write "
"access to the contents of their argument.  The buffer interface allows "
"objects to selectively allow or reject exporting of read-write and read-only "
"buffers."
msgstr ""
"Un ejemplo de consumidor de la interfaz de búfer es el método :meth:`~io."
"BufferedIOBase.write` de los objetos de archivo: cualquier objeto que pueda "
"exportar una serie de bytes a través de la interfaz de búfer puede "
"escribirse en un archivo.  Mientras que :meth:`!write` sólo necesita acceso "
"de sólo lectura al contenido interno del objeto que se le pasa, otros "
"métodos como :meth:`~io.BufferedIOBase.readinto` necesitan acceso de "
"escritura al contenido de su argumento.  La interfaz de búfer permite a los "
"objetos permitir o rechazar selectivamente la exportación de búferes de "
"lectura-escritura y de sólo lectura."

#: ../../c-api/buffer.rst:53
msgid ""
"There are two ways for a consumer of the buffer interface to acquire a "
"buffer over a target object:"
msgstr ""
"Existen dos vías para que un consumidor de la interfaz buffer adquiera un "
"buffer sobre un objeto determinado:"

#: ../../c-api/buffer.rst:56
msgid "call :c:func:`PyObject_GetBuffer` with the right parameters;"
msgstr "llamada a  :c:func:`PyObject_GetBuffer`  con los parámetros correctos;"

#: ../../c-api/buffer.rst:58
msgid ""
"call :c:func:`PyArg_ParseTuple` (or one of its siblings) with one of the "
"``y*``, ``w*`` or ``s*`` :ref:`format codes <arg-parsing>`."
msgstr ""
"llamada a :c:func:`PyArg_ParseTuple` (o algunos de sus hermanos) con uno de "
"los :ref:`códigos de formato <arg-parsing>`,  ``y*``, ``w*`` ó ``s*``."

#: ../../c-api/buffer.rst:61
msgid ""
"In both cases, :c:func:`PyBuffer_Release` must be called when the buffer "
"isn't needed anymore.  Failure to do so could lead to various issues such as "
"resource leaks."
msgstr ""
"En ambos casos, se debe llamar :c:func:`PyBuffer_Release` cuando ya no se "
"necesita más el buffer. Fallar al hacer esto puede conllevar varios "
"problemas como fugas de recursos."

#: ../../c-api/buffer.rst:69
msgid "Buffer structure"
msgstr "Estructura de Buffer"

#: ../../c-api/buffer.rst:71
msgid ""
"Buffer structures (or simply \"buffers\") are useful as a way to expose the "
"binary data from another object to the Python programmer.  They can also be "
"used as a zero-copy slicing mechanism.  Using their ability to reference a "
"block of memory, it is possible to expose any data to the Python programmer "
"quite easily.  The memory could be a large, constant array in a C extension, "
"it could be a raw block of memory for manipulation before passing to an "
"operating system library, or it could be used to pass around structured data "
"in its native, in-memory format."
msgstr ""
"Las estructuras de Buffer (o simplemente \"buffers\") son útiles como forma "
"de exponer datos binarios de otro objeto al programador Python. También se "
"pueden utilizar como mecanismo de troceado \"zero-copy\". Utilizando su "
"habilidad para referenciar un bloque de memoria, es posible exponer "
"cualquier dato al programador Python fácilmente. La memoria puede ser una "
"gran, constante matriz en una extensión C, puede ser un bloque de memoria "
"subyacente para manipular antes de pasarlo a una librería de sistema, o "
"puede se utilizar para pasar como datos estructurados en su formato de "
"memoria nativo."

#: ../../c-api/buffer.rst:80
msgid ""
"Contrary to most data types exposed by the Python interpreter, buffers are "
"not :c:type:`PyObject` pointers but rather simple C structures.  This allows "
"them to be created and copied very simply.  When a generic wrapper around a "
"buffer is needed, a :ref:`memoryview <memoryview-objects>` object can be "
"created."
msgstr ""
"De forma contraria a la mayoría de tipos de dato expuestos por el Intérprete "
"Python, los buffers no son apuntadores :c:type:`PyObject` si no simples "
"estructuras C. Esto permite que se creen y copien muy fácilmente. Cuando se "
"necesita un contenedor genérico de un buffer, se puede crear un objeto :ref:"
"`memoryview <memoryview-objects>`."

#: ../../c-api/buffer.rst:86
msgid ""
"For short instructions how to write an exporting object, see :ref:`Buffer "
"Object Structures <buffer-structs>`. For obtaining a buffer, see :c:func:"
"`PyObject_GetBuffer`."
msgstr ""
"Para instrucciones más cortas sobre como escribir un objeto exportable, ver :"
"ref:`Buffer Object Structures <buffer-structs>`. Para obtener un búfer, ver :"
"c:func:`PyObject_GetBuffer`."

#: ../../c-api/buffer.rst:94
msgid ""
"A pointer to the start of the logical structure described by the buffer "
"fields. This can be any location within the underlying physical memory block "
"of the exporter. For example, with negative :c:member:`~Py_buffer.strides` "
"the value may point to the end of the memory block."
msgstr ""
"Un apuntador al comienzo de la estructura lógica descrita por los campos de "
"búfer, puede ser una localización con el bloque de memoria física subyacente "
"del exportador. Por ejemplo, con  :c:member:`~Py_buffer.strides` negativo, "
"el valor puede apuntar al final del bloque de memoria."

#: ../../c-api/buffer.rst:99
msgid ""
"For :term:`contiguous` arrays, the value points to the beginning of the "
"memory block."
msgstr ""
"Para matrices :term:`contiguous`, el valor apunta al principio del bloque de "
"memoria."

#: ../../c-api/buffer.rst:104
msgid ""
"A new reference to the exporting object. The reference is owned by the "
"consumer and automatically released (i.e. reference count decremented) and "
"set to ``NULL`` by :c:func:`PyBuffer_Release`. The field is the equivalent "
"of the return value of any standard C-API function."
msgstr ""
"Una nueva referencia al objeto exportador. La referencia es propiedad del "
"consumidor y se libera automáticamente (es decir, se reduce el recuento de "
"referencias) y se establece en ``NULL`` mediante :c:func:`PyBuffer_Release`. "
"El campo es equivalente al valor de retorno de cualquier función C-API "
"estándar."

#: ../../c-api/buffer.rst:111
msgid ""
"As a special case, for *temporary* buffers that are wrapped by :c:func:"
"`PyMemoryView_FromBuffer` or :c:func:`PyBuffer_FillInfo` this field is "
"``NULL``. In general, exporting objects MUST NOT use this scheme."
msgstr ""
"Como caso especial, para búferes *temporales* envueltos por:c:func:"
"`PyMemoryView_FromBuffer` o :c:func:`PyBuffer_FillInfo` este campo "
"es``NULL``. En general, la exportación de objetos NO DEBE utilizar este "
"esquema."

#: ../../c-api/buffer.rst:118
msgid ""
"``product(shape) * itemsize``. For contiguous arrays, this is the length of "
"the underlying memory block. For non-contiguous arrays, it is the length "
"that the logical structure would have if it were copied to a contiguous "
"representation."
msgstr ""
"``product(shape) * itemsize``. Para arreglos contigüos, ésta es la longitud "
"del bloque de memoria subyacente. Para arreglos no contgüos, es la longitud "
"que una estructura lógica tendría si fuera copiada a una representación "
"contigüa."

#: ../../c-api/buffer.rst:123
msgid ""
"Accessing ``((char *)buf)[0] up to ((char *)buf)[len-1]`` is only valid if "
"the buffer has been obtained by a request that guarantees contiguity. In "
"most cases such a request will be :c:macro:`PyBUF_SIMPLE` or :c:macro:"
"`PyBUF_WRITABLE`."
msgstr ""
"Acceder a  ``((char *)buf)[0] up to ((char *)buf)[len-1]`` sólo es válido si "
"se ha conseguido el búfer por una petición que garantiza contigüidad. En la "
"mayoría de los casos en los que una petición sea :c:macro:`PyBUF_SIMPLE` o :"
"c:macro:`PyBUF_WRITABLE`."

#: ../../c-api/buffer.rst:129
msgid ""
"An indicator of whether the buffer is read-only. This field is controlled by "
"the :c:macro:`PyBUF_WRITABLE` flag."
msgstr ""
"Un indicador para comprobar si el búfer es de sólo lectura. Este campo se "
"controla mediante la bandera :c:macro:`PyBUF_WRITABLE`."

#: ../../c-api/buffer.rst:134
msgid ""
"Item size in bytes of a single element. Same as the value of :func:`struct."
"calcsize` called on non-``NULL`` :c:member:`~Py_buffer.format` values."
msgstr ""
"Tamaño de elemento en bytes de un solo elemento. Igual que el valor de:func:"
"`struct.calcsize` llamado en valores no-``NULL`` :c:member:`~Py_buffer."
"format`."

#: ../../c-api/buffer.rst:137
msgid ""
"Important exception: If a consumer requests a buffer without the :c:macro:"
"`PyBUF_FORMAT` flag, :c:member:`~Py_buffer.format` will be set to  "
"``NULL``,  but :c:member:`~Py_buffer.itemsize` still has the value for the "
"original format."
msgstr ""
"Excepción importante: Si un consumidor solicita un búfer sin la bandera, :c:"
"macro:`PyBUF_FORMAT`, :c:member:`~Py_buffer.format` se establecerá en  "
"``NULL``,  pero :c:member:`~Py_buffer.itemsize` aún tiene el valor para el "
"formato original."

#: ../../c-api/buffer.rst:142
msgid ""
"If :c:member:`~Py_buffer.shape` is present, the equality ``product(shape) * "
"itemsize == len`` still holds and the consumer can use :c:member:`~Py_buffer."
"itemsize` to navigate the buffer."
msgstr ""
"Si está presente :c:member:`~Py_buffer.shape`, la igualdad ``product(shape) "
"* itemsize == len``  aún se mantiene y el consumidor puede usar  :c:member:"
"`~Py_buffer.itemsize` para navegar por el búfer."

#: ../../c-api/buffer.rst:146
msgid ""
"If :c:member:`~Py_buffer.shape` is ``NULL`` as a result of a :c:macro:"
"`PyBUF_SIMPLE` or a :c:macro:`PyBUF_WRITABLE` request, the consumer must "
"disregard :c:member:`~Py_buffer.itemsize` and assume ``itemsize == 1``."
msgstr ""
"Si :c:member:`~Py_buffer.shape` es ``NULL`` como resultado de una solicitud :"
"c:macro:`PyBUF_SIMPLE` o una :c:macro:`PyBUF_WRITABLE`, el consumidor debe "
"hacer caso omiso:c:member:`~Py_buffer.itemsize` y asumir``itemsize == 1``."

#: ../../c-api/buffer.rst:152
msgid ""
"A *NUL* terminated string in :mod:`struct` module style syntax describing "
"the contents of a single item. If this is ``NULL``, ``\"B\"`` (unsigned "
"bytes) is assumed."
msgstr ""
"Una cadena terminada en *NUL* en :mod:`struct` sintaxis de estilo de módulo "
"que describe el contenido de un solo elemento. Si es ``NULL``, se asume "
"``\"B\"`` (bytes sin signo)."

#: ../../c-api/buffer.rst:156
msgid "This field is controlled by the :c:macro:`PyBUF_FORMAT` flag."
msgstr "Este campo es controlado por el flag  :c:macro:`PyBUF_FORMAT`."

#: ../../c-api/buffer.rst:160
msgid ""
"The number of dimensions the memory represents as an n-dimensional array. If "
"it is ``0``, :c:member:`~Py_buffer.buf` points to a single item representing "
"a scalar. In this case, :c:member:`~Py_buffer.shape`, :c:member:`~Py_buffer."
"strides` and :c:member:`~Py_buffer.suboffsets` MUST be ``NULL``. The maximum "
"number of dimensions is given by :c:macro:`PyBUF_MAX_NDIM`."
msgstr ""
"El número de dimensiones que la memoria representa como un array n-"
"dimensional. Si es ``0``, :c:member:`~Py_buffer.buf` apunta a un único "
"elemento que representa un escalar. En este caso, :c:member:`~Py_buffer."
"shape`, :c:member:`~Py_buffer.strides` y :c:member:`~Py_buffer.suboffsets` "
"DEBEN ser ``NULL``. El número máximo de dimensiones viene dado por :c:macro:"
"`PyBUF_MAX_NDIM`."

#: ../../c-api/buffer.rst:168
msgid ""
"An array of :c:type:`Py_ssize_t` of length :c:member:`~Py_buffer.ndim` "
"indicating the shape of the memory as an n-dimensional array. Note that "
"``shape[0] * ... * shape[ndim-1] * itemsize`` MUST be equal to :c:member:"
"`~Py_buffer.len`."
msgstr ""
"Un array de :c:type:`Py_ssize_t` de longitud:c:member:`~Py_buffer.ndim` "
"indicando la forma de la memoria como una matriz n-dimensional. Tenga en "
"cuenta que``shape[0] * ... * shape[ndim-1] * itemsize`` DEBE de ser igual a :"
"c:member:`~Py_buffer.len`."

#: ../../c-api/buffer.rst:173
msgid ""
"Shape values are restricted to ``shape[n] >= 0``. The case ``shape[n] == 0`` "
"requires special attention. See `complex arrays`_ for further information."
msgstr ""
"Los valores shape están restringidos a ``shape[n] >= 0``. El caso ``shape[n] "
"== 0`` requires special attention. See `complex arrays`_ for further "
"information. requiere atención especial. Ver `complex arrays`_ para obtener "
"más información."

#: ../../c-api/buffer.rst:177
msgid "The shape array is read-only for the consumer."
msgstr "La matriz de formas es de solo lectura para el consumidor."

#: ../../c-api/buffer.rst:181
msgid ""
"An array of :c:type:`Py_ssize_t` of length :c:member:`~Py_buffer.ndim` "
"giving the number of bytes to skip to get to a new element in each dimension."
msgstr ""
"Un array de :c:type:`Py_ssize_t` de longitud :c:member:`~Py_buffer.ndim` "
"dando el número de bytes a saltar para llegar a un nuevo elemento en cada "
"dimensión."

#: ../../c-api/buffer.rst:185
msgid ""
"Stride values can be any integer. For regular arrays, strides are usually "
"positive, but a consumer MUST be able to handle the case ``strides[n] <= "
"0``. See `complex arrays`_ for further information."
msgstr ""
"Los valores de forma pueden ser cualquier número entero. Para matrices "
"regulares, las formas suelen ser positivos, pero un consumidor DEBE poder "
"manejar el caso ``strides[n] <= 0``. Para más información ver `complex "
"arrays`_ ."

#: ../../c-api/buffer.rst:189
msgid "The strides array is read-only for the consumer."
msgstr "La matriz de formas es de solo lectura para el consumidor."

#: ../../c-api/buffer.rst:193
msgid ""
"An array of :c:type:`Py_ssize_t` of length :c:member:`~Py_buffer.ndim`. If "
"``suboffsets[n] >= 0``, the values stored along the nth dimension are "
"pointers and the suboffset value dictates how many bytes to add to each "
"pointer after de-referencing. A suboffset value that is negative indicates "
"that no de-referencing should occur (striding in a contiguous memory block)."
msgstr ""
"Una matriz de :c:type:`Py_ssize_t` de longitud :c:member:`~Py_buffer.ndim`. "
"Si ``suboffsets[n] >= 0``, los valores almacenados a lo largo de la enésima "
"dimensión son punteros y el valor de desplazamiento secundario dicta cuántos "
"bytes agregar a cada puntero después de la desreferenciación. Un valor de "
"subdesviación que es negativo indica que no debe producirse ninguna "
"desreferenciación (caminar en un bloque de memoria contiguo)."

#: ../../c-api/buffer.rst:200
msgid ""
"If all suboffsets are negative (i.e. no de-referencing is needed), then this "
"field must be ``NULL`` (the default value)."
msgstr ""
"Si todos los subdesplazamientos son negativos (es decir, no se necesita "
"desreferenciar), este campo debe ser ``NULL`` (el valor por defecto)."

#: ../../c-api/buffer.rst:203
msgid ""
"This type of array representation is used by the Python Imaging Library "
"(PIL). See `complex arrays`_ for further information how to access elements "
"of such an array."
msgstr ""
"Este tipo de representación de matriz es usado por la Biblioteca de imágenes "
"de Python (PIL). Ver 'complex arrays' _ para obtener más información sobre "
"cómo acceder a los elementos de dicha matriz."

#: ../../c-api/buffer.rst:207
msgid "The suboffsets array is read-only for the consumer."
msgstr "La matriz de subdesviaciones es de solo lectura para el consumidor."

#: ../../c-api/buffer.rst:211
msgid ""
"This is for use internally by the exporting object. For example, this might "
"be re-cast as an integer by the exporter and used to store flags about "
"whether or not the shape, strides, and suboffsets arrays must be freed when "
"the buffer is released. The consumer MUST NOT alter this value."
msgstr ""
"Esto es para uso interno del objeto exportador. Por ejemplo, el exportador "
"podría volver a convertirlo en un número entero y usarlo para almacenar "
"indicadores sobre si las matrices de formas, pasos y subdesplazamientos "
"deben liberarse o no cuando se libera el búfer. El consumidor NO DEBE "
"alterar este valor."

#: ../../c-api/buffer.rst:218
msgid "Constants:"
msgstr "Constantes:"

#: ../../c-api/buffer.rst:222
msgid ""
"The maximum number of dimensions the memory represents. Exporters MUST "
"respect this limit, consumers of multi-dimensional buffers SHOULD be able to "
"handle up to :c:macro:`!PyBUF_MAX_NDIM` dimensions. Currently set to 64."
msgstr ""
"El número máximo de dimensiones que representa la memoria. Los exportadores "
"DEBEN respetar este límite, los consumidores de memorias multidimensionales "
"DEBERÍAN ser capaces de manejar hasta :c:macro:`!PyBUF_MAX_NDIM` "
"dimensiones. Actualmente está fijado en 64."

#: ../../c-api/buffer.rst:231
msgid "Buffer request types"
msgstr "Tipos de solicitud de búfer"

#: ../../c-api/buffer.rst:233
msgid ""
"Buffers are usually obtained by sending a buffer request to an exporting "
"object via :c:func:`PyObject_GetBuffer`. Since the complexity of the logical "
"structure of the memory can vary drastically, the consumer uses the *flags* "
"argument to specify the exact buffer type it can handle."
msgstr ""
"Los búferes generalmente se obtienen enviando una solicitud de búfer a un "
"objeto exportador a través de :c:func:`PyObject_GetBuffer`. Dado que la "
"complejidad de la estructura lógica de la memoria puede variar "
"drásticamente, el consumidor utiliza el argumento *flags* para especificar "
"el tipo de búfer exacto que puede manejar."

#: ../../c-api/buffer.rst:238
msgid ""
"All :c:type:`Py_buffer` fields are unambiguously defined by the request type."
msgstr ""
"Todos los campos de :c:type:`Py_buffer` están definidos inequívocamente por "
"el tipo de solicitud."

#: ../../c-api/buffer.rst:242
msgid "request-independent fields"
msgstr "campos independientes-de-la-solicitud"

#: ../../c-api/buffer.rst:243
msgid ""
"The following fields are not influenced by *flags* and must always be filled "
"in with the correct values: :c:member:`~Py_buffer.obj`, :c:member:"
"`~Py_buffer.buf`, :c:member:`~Py_buffer.len`, :c:member:`~Py_buffer."
"itemsize`, :c:member:`~Py_buffer.ndim`."
msgstr ""
"Los siguientes campos no están influenciados por *banderas* y siempre deben "
"completarse con los valores correctos: :c:member:`~Py_buffer.obj`, :c:member:"
"`~Py_buffer.buf`, :c:member:`~Py_buffer.len`, :c:member:`~Py_buffer."
"itemsize`, :c:member:`~Py_buffer.ndim`."

#: ../../c-api/buffer.rst:249
msgid "readonly, format"
msgstr "formato de solo lectura"

#: ../../c-api/buffer.rst:253
msgid ""
"Controls the :c:member:`~Py_buffer.readonly` field. If set, the exporter "
"MUST provide a writable buffer or else report failure. Otherwise, the "
"exporter MAY provide either a read-only or writable buffer, but the choice "
"MUST be consistent for all consumers."
msgstr ""
"Controa el campo :c:member:`~Py_buffer.readonly`. Si se establece, el "
"exportador DEBE proporcionar un búfer grabable o, de lo contrario, informar "
"de un error. De lo contrario, el exportador PUEDE proporcionar un búfer de "
"solo lectura o de escritura, pero la elección DEBE ser coherente para todos "
"los consumidores."

#: ../../c-api/buffer.rst:260
msgid ""
"Controls the :c:member:`~Py_buffer.format` field. If set, this field MUST be "
"filled in correctly. Otherwise, this field MUST be ``NULL``."
msgstr ""
"Controla el campo :c:member:`~Py_buffer.format`.Si se establece, este campo "
"DEBE completarse correctamente. De lo contrario, este campo DEBE ser "
"``NULL``."

#: ../../c-api/buffer.rst:264
msgid ""
":c:macro:`PyBUF_WRITABLE` can be \\|'d to any of the flags in the next "
"section. Since :c:macro:`PyBUF_SIMPLE` is defined as 0, :c:macro:"
"`PyBUF_WRITABLE` can be used as a stand-alone flag to request a simple "
"writable buffer."
msgstr ""
":c:macro:`PyBUF_WRITABLE` puede ser \\|'d a cualquiera de los indicadores de "
"la siguiente sección. Ya que :c:macro:`PyBUF_SIMPLE` se define como  0, :c:"
"macro:`PyBUF_WRITABLE` se puede usar como indicador independiente para "
"solicitar un búfer de escritura simple."

#: ../../c-api/buffer.rst:268
msgid ""
":c:macro:`PyBUF_FORMAT` can be \\|'d to any of the flags except :c:macro:"
"`PyBUF_SIMPLE`. The latter already implies format ``B`` (unsigned bytes)."
msgstr ""
":c:macro:`PyBUF_FORMAT` puede ser \\|'d a cualquiera de las banderas excepto:"
"c:macro:`PyBUF_SIMPLE`. Esto último ya implica formato``B`` (bytes sin "
"signo)."

#: ../../c-api/buffer.rst:273
msgid "shape, strides, suboffsets"
msgstr "forma, ritmo, sub-compensaciones"

#: ../../c-api/buffer.rst:275
msgid ""
"The flags that control the logical structure of the memory are listed in "
"decreasing order of complexity. Note that each flag contains all bits of the "
"flags below it."
msgstr ""
"Los indicadores que controlan la estructura lógica de la memoria se enumeran "
"en orden decreciente de complejidad. Obsérvese que cadaindicador contiene "
"todos los bits de los indicadores debajo del mismo."

#: ../../c-api/buffer.rst:282 ../../c-api/buffer.rst:306
#: ../../c-api/buffer.rst:331
msgid "Request"
msgstr "Solicitud"

#: ../../c-api/buffer.rst:282 ../../c-api/buffer.rst:306
#: ../../c-api/buffer.rst:331
msgid "shape"
msgstr "forma"

#: ../../c-api/buffer.rst:282 ../../c-api/buffer.rst:306
#: ../../c-api/buffer.rst:331
msgid "strides"
msgstr "progreso"

#: ../../c-api/buffer.rst:282 ../../c-api/buffer.rst:306
#: ../../c-api/buffer.rst:331
msgid "suboffsets"
msgstr "subdesviaciones"

#: ../../c-api/buffer.rst:284 ../../c-api/buffer.rst:286
#: ../../c-api/buffer.rst:288 ../../c-api/buffer.rst:308
#: ../../c-api/buffer.rst:310 ../../c-api/buffer.rst:312
#: ../../c-api/buffer.rst:314 ../../c-api/buffer.rst:333
#: ../../c-api/buffer.rst:335 ../../c-api/buffer.rst:337
#: ../../c-api/buffer.rst:339 ../../c-api/buffer.rst:341
#: ../../c-api/buffer.rst:343 ../../c-api/buffer.rst:345
#: ../../c-api/buffer.rst:347
msgid "yes"
msgstr "si"

#: ../../c-api/buffer.rst:284 ../../c-api/buffer.rst:333
#: ../../c-api/buffer.rst:335
msgid "if needed"
msgstr "si se necesita"

#: ../../c-api/buffer.rst:286 ../../c-api/buffer.rst:288
#: ../../c-api/buffer.rst:290 ../../c-api/buffer.rst:308
#: ../../c-api/buffer.rst:310 ../../c-api/buffer.rst:312
#: ../../c-api/buffer.rst:314 ../../c-api/buffer.rst:337
#: ../../c-api/buffer.rst:339 ../../c-api/buffer.rst:341
#: ../../c-api/buffer.rst:343 ../../c-api/buffer.rst:345
#: ../../c-api/buffer.rst:347
msgid "NULL"
msgstr "NULL"

#: ../../c-api/buffer.rst:297
msgid "contiguity requests"
msgstr "peticiones de contigüidad"

#: ../../c-api/buffer.rst:299
msgid ""
"C or Fortran :term:`contiguity <contiguous>` can be explicitly requested, "
"with and without stride information. Without stride information, the buffer "
"must be C-contiguous."
msgstr ""
"C o Fortran :term:`contiguity <contiguous>` se puede solicitar "
"explícitamente, con y sin información de progreso. Sin información de "
"progreso, la memoria intermedia debe ser contigua en C."

#: ../../c-api/buffer.rst:306 ../../c-api/buffer.rst:331
msgid "contig"
msgstr "contig"

#: ../../c-api/buffer.rst:308 ../../c-api/buffer.rst:314
#: ../../c-api/buffer.rst:345 ../../c-api/buffer.rst:347
msgid "C"
msgstr "C"

#: ../../c-api/buffer.rst:310
msgid "F"
msgstr "F"

#: ../../c-api/buffer.rst:312
msgid "C or F"
msgstr "C o F"

#: ../../c-api/buffer.rst:314
msgid ":c:macro:`PyBUF_ND`"
msgstr ":c:macro:`PyBUF_ND`"

#: ../../c-api/buffer.rst:319
msgid "compound requests"
msgstr "peticiones compuestas"

#: ../../c-api/buffer.rst:321
msgid ""
"All possible requests are fully defined by some combination of the flags in "
"the previous section. For convenience, the buffer protocol provides "
"frequently used combinations as single flags."
msgstr ""
"Todas las peticiones posibles son totalmente definidas por alguna "
"combinación de flags en la sección previa. Por conveniencia, el protocolo "
"buffer proporciona combinaciones utilizadas frecuentemente como flags únicos."

#: ../../c-api/buffer.rst:325
msgid ""
"In the following table *U* stands for undefined contiguity. The consumer "
"would have to call :c:func:`PyBuffer_IsContiguous` to determine contiguity."
msgstr ""
"En la siguiente tabla *U* indica contigüidad indefinida. El consumidor podrá "
"llamar a :c:func:`PyBuffer_IsContiguous` para determinar la contigüidad."

#: ../../c-api/buffer.rst:331
msgid "readonly"
msgstr "sololectura"

#: ../../c-api/buffer.rst:331
msgid "format"
msgstr "formato"

#: ../../c-api/buffer.rst:333 ../../c-api/buffer.rst:335
#: ../../c-api/buffer.rst:337 ../../c-api/buffer.rst:339
#: ../../c-api/buffer.rst:341 ../../c-api/buffer.rst:343
msgid "U"
msgstr "U"

#: ../../c-api/buffer.rst:333 ../../c-api/buffer.rst:337
#: ../../c-api/buffer.rst:341 ../../c-api/buffer.rst:345
msgid "0"
msgstr "0"

#: ../../c-api/buffer.rst:335 ../../c-api/buffer.rst:339
#: ../../c-api/buffer.rst:343 ../../c-api/buffer.rst:347
msgid "1 or 0"
msgstr "1 o 0"

#: ../../c-api/buffer.rst:352
msgid "Complex arrays"
msgstr "Arreglos complejos"

#: ../../c-api/buffer.rst:355
msgid "NumPy-style: shape and strides"
msgstr "Estilo NumPy: forma y progresos"

#: ../../c-api/buffer.rst:357
msgid ""
"The logical structure of NumPy-style arrays is defined by :c:member:"
"`~Py_buffer.itemsize`, :c:member:`~Py_buffer.ndim`, :c:member:`~Py_buffer."
"shape` and :c:member:`~Py_buffer.strides`."
msgstr ""
"La estructura lógica de las matrices NumPy-style está definida por :c:member:"
"`~Py_buffer.itemsize`, :c:member:`~Py_buffer.ndim`, :c:member:`~Py_buffer."
"shape` y :c:member:`~Py_buffer.strides`."

#: ../../c-api/buffer.rst:360
msgid ""
"If ``ndim == 0``, the memory location pointed to by :c:member:`~Py_buffer."
"buf` is interpreted as a scalar of size :c:member:`~Py_buffer.itemsize`. In "
"that case, both :c:member:`~Py_buffer.shape` and :c:member:`~Py_buffer."
"strides` are ``NULL``."
msgstr ""
"Si ``ndim == 0``, la ubicación de la memoria señalada por:c:member:"
"`~Py_buffer.buf` se interpreta como un escalar de tamaño :c:member:"
"`~Py_buffer.itemsize`. en ese caso, tanto :c:member:`~Py_buffer.shape` como :"
"c:member:`~Py_buffer.strides` son ``NULL``."

#: ../../c-api/buffer.rst:364
msgid ""
"If :c:member:`~Py_buffer.strides` is ``NULL``, the array is interpreted as a "
"standard n-dimensional C-array. Otherwise, the consumer must access an n-"
"dimensional array as follows:"
msgstr ""
"Si :c:member:`~Py_buffer.strides` es ``NULL``, la matriz se interpreta como "
"una n-dimensional C-array estándar. De lo contrario, el consumidor debe "
"acceder a una matriz n-dimensional de la siguiente manera:"

#: ../../c-api/buffer.rst:374
msgid ""
"As noted above, :c:member:`~Py_buffer.buf` can point to any location within "
"the actual memory block. An exporter can check the validity of a buffer with "
"this function:"
msgstr ""
"Como se puede ver, :c:member:`~Py_buffer.buf` puede apuntar a cualquier "
"ubicación dentro del bloque de memoria real. Un exportador puede comprobar "
"la validez de un búfer con esta función:"

#: ../../c-api/buffer.rst:408
msgid "PIL-style: shape, strides and suboffsets"
msgstr "PIL-style: forma, ritmo, sub-compensaciones"

#: ../../c-api/buffer.rst:410
msgid ""
"In addition to the regular items, PIL-style arrays can contain pointers that "
"must be followed in order to get to the next element in a dimension. For "
"example, the regular three-dimensional C-array ``char v[2][2][3]`` can also "
"be viewed as an array of 2 pointers to 2 two-dimensional arrays: ``char "
"(*v[2])[2][3]``. In suboffsets representation, those two pointers can be "
"embedded at the start of :c:member:`~Py_buffer.buf`, pointing to two ``char "
"x[2][3]`` arrays that can be located anywhere in memory."
msgstr ""
"Además de los elementos normales, las matrices de estilo PIL pueden contener "
"punteros que deben seguirse para llegar al siguiente elemento de una "
"dimensión. Por ejemplo, la matriz C tridimensional regular ``char v[2][2]"
"[3]`` también se puede ver como una matriz de 2 punteros a 2 matrices "
"bidimensionales: ``char (*v[2])[2][3]``.En la representación de "
"subdesplazamientos, esos dos punteros se pueden incrustar al comienzo de:c:"
"member:`~Py_buffer.buf`, señalando a dos ``char x[2][3]`` matrices que se "
"pueden situar en cualquier lugar de la memoria."

#: ../../c-api/buffer.rst:419
msgid ""
"Here is a function that returns a pointer to the element in an N-D array "
"pointed to by an N-dimensional index when there are both non-``NULL`` "
"strides and suboffsets::"
msgstr ""
"Aquí hay una función que devuelve un puntero al elemento en un NDarray "
"apuntado por un índice N-dimensional cuando hay pasos y subdesplazamientos "
"no -``NULL``::"

#: ../../c-api/buffer.rst:438
msgid "Buffer-related functions"
msgstr "Funciones relacionadas con el búfer"

#: ../../c-api/buffer.rst:442
msgid ""
"Return ``1`` if *obj* supports the buffer interface otherwise ``0``.  When "
"``1`` is returned, it doesn't guarantee that :c:func:`PyObject_GetBuffer` "
"will succeed.  This function always succeeds."
msgstr ""
"Devuelve ``1``si *obj* admite la interfaz de búfer, de lo contrario,``0``.  "
"Cuando devuelve ``1`` no garantiza que :c:func:`PyObject_GetBuffer` tenga "
"éxito. Esta función siempre tiene éxito."

#: ../../c-api/buffer.rst:449
msgid ""
"Send a request to *exporter* to fill in *view* as specified by  *flags*. If "
"the exporter cannot provide a buffer of the exact type, it MUST raise :exc:"
"`BufferError`, set ``view->obj`` to ``NULL`` and return ``-1``."
msgstr ""
"Envía una petición a *exporter* para que rellene *view* según lo "
"especificado por *flags*. Si el exportador no puede proporcionar un buffer "
"del tipo exacto, DEBE levantar :exc:`BufferError`, poner ``view->obj`` en "
"``NULL`` y devolver ``-1``."

#: ../../c-api/buffer.rst:454
msgid ""
"On success, fill in *view*, set ``view->obj`` to a new reference to "
"*exporter* and return 0. In the case of chained buffer providers that "
"redirect requests to a single object, ``view->obj`` MAY refer to this object "
"instead of *exporter* (See :ref:`Buffer Object Structures <buffer-structs>`)."
msgstr ""
"En caso de éxito, completar * view*, fijar``view->obj`` a una nueva "
"referencia a *exporter* y devuelve 0. En el caso de proveedores de búfer "
"encadenados que redirigen solicitudes a un solo objeto,``view->obj`` PUEDE "
"hacer referencia a este objeto en lugar de *exporter* (Ver :ref:`Buffer "
"Object Structures <buffer-structs>`)."

#: ../../c-api/buffer.rst:459
msgid ""
"Successful calls to :c:func:`PyObject_GetBuffer` must be paired with calls "
"to :c:func:`PyBuffer_Release`, similar to :c:func:`malloc` and :c:func:"
"`free`. Thus, after the consumer is done with the buffer, :c:func:"
"`PyBuffer_Release` must be called exactly once."
msgstr ""
"Llamadas con éxito a :c:func:`PyObject_GetBuffer` deben estar emparejadas "
"con llamadas a:c:func:`PyBuffer_Release`, similar a :c:func:`malloc` y :c:"
"func:`free`. Por lo tanto, después de que el consumidor haya terminado con "
"el buffer,:c:func:`PyBuffer_Release` debe llamarse exactamente una vez."

#: ../../c-api/buffer.rst:467
msgid ""
"Release the buffer *view* and release the :term:`strong reference` (i.e. "
"decrement the reference count) to the view's supporting object, ``view-"
">obj``. This function MUST be called when the buffer is no longer being "
"used, otherwise reference leaks may occur."
msgstr ""
"Libera el buffer *view* y libera la referencia :term:`strong` (es decir, "
"disminuye la cuenta de referencias) al objeto de soporte de la vista, ``view-"
">obj``. Esta función DEBE ser llamada cuando el buffer ya no esté siendo "
"utilizado, de lo contrario pueden producirse fugas de referencias."

#: ../../c-api/buffer.rst:472
msgid ""
"It is an error to call this function on a buffer that was not obtained via :"
"c:func:`PyObject_GetBuffer`."
msgstr ""
"Es un error llamar a esta función en un búfer que no se obtuvo a través de:c:"
"func:`PyObject_GetBuffer`."

#: ../../c-api/buffer.rst:478
msgid ""
"Return the implied :c:member:`~Py_buffer.itemsize` from :c:member:"
"`~Py_buffer.format`. On error, raise an exception and return -1."
msgstr ""
"Devuelve el :c:member:`~Py_buffer.itemsize` implícito de :c:member:"
"`~Py_buffer.format`. En caso de error, lanza una excepción y devuelve -1."

#: ../../c-api/buffer.rst:486
msgid ""
"Return ``1`` if the memory defined by the *view* is C-style (*order* is "
"``'C'``) or Fortran-style (*order* is ``'F'``) :term:`contiguous` or either "
"one (*order* is ``'A'``).  Return ``0`` otherwise.  This function always "
"succeeds."
msgstr ""
"Devuelve ``1`` si la memoria definida por la *view* es C-style (*order* es "
"``'C'``) o Fortran-style (*order* es ``'F'``) :term:`contiguous` o "
"cualquiera de los dos (*order* es``'A'``).  Devuelve ``0`` de lo contrario. "
"Esta función siempre tiene éxito."

#: ../../c-api/buffer.rst:493
msgid ""
"Get the memory area pointed to by the *indices* inside the given *view*. "
"*indices* must point to an array of ``view->ndim`` indices."
msgstr ""
"Consigue el área de memoria señalada por los *índex* en la *view* dada. "
"*index* debe apuntar a una matriz de índices ``view->ndim``."

#: ../../c-api/buffer.rst:499
msgid ""
"Copy contiguous *len* bytes from *buf* to *view*. *fort* can be ``'C'`` or "
"``'F'`` (for C-style or Fortran-style ordering). ``0`` is returned on "
"success, ``-1`` on error."
msgstr ""
"Copiar bytes *len* contiguos de *buf* a *view*. *strong* puede ser``'C'`` o "
"``'F'`` para órdenes C-style o Fortran-style) (. ``0``se devuelve en caso de "
"éxitos, en caso de error ``-1``."

#: ../../c-api/buffer.rst:506
msgid ""
"Copy *len* bytes from *src* to its contiguous representation in *buf*. "
"*order* can be ``'C'`` or ``'F'`` or ``'A'`` (for C-style or Fortran-style "
"ordering or either one). ``0`` is returned on success, ``-1`` on error."
msgstr ""
"Copiar los bytes *len* de *src* a su representación contigua en *buf*. "
"*order* puede ser ``'C'`` o ``'F'`` o ``'A'`` (para órdenes C-style o "
"Fortran-style o cualquiera de los dos). ``0``se devuelve en caso de éxitos, "
"en caso de error ``-1``."

#: ../../c-api/buffer.rst:510
msgid "This function fails if *len* != *src->len*."
msgstr "Esta función falla si *len* != * src - > len*."

#: ../../c-api/buffer.rst:515
msgid ""
"Copy data from *src* to *dest* buffer. Can convert between C-style and or "
"Fortran-style buffers."
msgstr ""
"Copia datos del buffer *src* al *dest*. Puede convertir entre buffers de "
"estilo C y/o Fortran."

#: ../../c-api/buffer.rst:518
msgid "``0`` is returned on success, ``-1`` on error."
msgstr "``0`` se devuelve en caso de éxito, ``-1`` en caso de error."

#: ../../c-api/buffer.rst:522
msgid ""
"Fill the *strides* array with byte-strides of a :term:`contiguous` (C-style "
"if *order* is ``'C'`` or Fortran-style if *order* is ``'F'``) array of the "
"given shape with the given number of bytes per element."
msgstr ""
"Rellenar la matriz *strides* con bytes-strydes de una matriz: term: "
"'contiguo' (C-style si *order* es ``'C'`` o Fortran-style sí *order* es "
"``'F'``) de la forma dada con el número dado de bytes por elemento."

#: ../../c-api/buffer.rst:529
msgid ""
"Handle buffer requests for an exporter that wants to expose *buf* of size "
"*len* with writability set according to *readonly*. *buf* is interpreted as "
"a sequence of unsigned bytes."
msgstr ""
"Ajustar las solicitudes de búfer para un exportador que quiera exponer *buf* "
"de tamaño *len* con capacidad de escritura establecida de acuerdo con *solo "
"lectura*. * buf * se interpreta como una secuencia de bytes sin signo."

#: ../../c-api/buffer.rst:533
msgid ""
"The *flags* argument indicates the request type. This function always fills "
"in *view* as specified by flags, unless *buf* has been designated as read-"
"only and :c:macro:`PyBUF_WRITABLE` is set in *flags*."
msgstr ""
"El argumento *flags* indica el tipo de solicitud. Esta función siempre "
"rellena *view* según lo especificado por flags, a menos que se haya "
"designado *buf* como de solo lectura y :c:macro:`PyBUF_WRITABLE` esté "
"configurado en *flags*."

#: ../../c-api/buffer.rst:537
msgid ""
"On success, set ``view->obj`` to a new reference to *exporter* and return 0. "
"Otherwise, raise :exc:`BufferError`, set ``view->obj`` to ``NULL`` and "
"return ``-1``;"
msgstr ""
"Si tiene éxito, asigna a ``view->obj`` una nueva referencia a *exporter* y "
"devuelve 0. En caso contrario, eleva :exc:`BufferError`, establece ``view-"
">obj`` a ``NULL`` y devuelve ``-1``;"

#: ../../c-api/buffer.rst:541
msgid ""
"If this function is used as part of a :ref:`getbufferproc <buffer-structs>`, "
"*exporter* MUST be set to the exporting object and *flags* must be passed "
"unmodified. Otherwise, *exporter* MUST be ``NULL``."
msgstr ""
"Si esta función se usa como parte de una :ref:`getbufferproc <buffer-"
"structs>`, *exporter* se DEBE poner en el objeto de exportación y se debe "
"pasar *flags* sin modificar. De otra forma, *exporter* HA de ser ``NULL``."

#: ../../c-api/buffer.rst:3
msgid "buffer protocol"
msgstr "protocolo de búfer"

#: ../../c-api/buffer.rst:3
msgid "buffer interface"
msgstr "interfaz de búfer"

#: ../../c-api/buffer.rst:3
msgid "(see buffer protocol)"
msgstr "(ver protocolo de búfer)"

#: ../../c-api/buffer.rst:3
msgid "buffer object"
msgstr "objeto búfer"

#: ../../c-api/buffer.rst:32
msgid "PyBufferProcs (C type)"
msgstr "PyBufferProcs (tipo C)"

#: ../../c-api/buffer.rst:294
msgid "contiguous"
msgstr "contiguo"

#: ../../c-api/buffer.rst:294
msgid "C-contiguous"
msgstr "C-contiguous"

#: ../../c-api/buffer.rst:294
msgid "Fortran contiguous"
msgstr "Fortran contiguo"
