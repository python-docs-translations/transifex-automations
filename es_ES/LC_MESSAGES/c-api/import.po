# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-10 15:26+0000\n"
"PO-Revision-Date: 2023-05-24 02:08+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Spanish (Spain) (https://app.transifex.com/python-doc/"
"teams/5390/es_ES/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es_ES\n"
"Plural-Forms: nplurals=3; plural=n == 1 ? 0 : n != 0 && n % 1000000 == 0 ? "
"1 : 2;\n"

#: ../../c-api/import.rst:6
msgid "Importing Modules"
msgstr "Importación de módulos"

#: ../../c-api/import.rst:16
msgid ""
"This is a wrapper around :c:func:`PyImport_Import()` which takes a :c:expr:"
"`const char *` as an argument instead of a :c:expr:`PyObject *`."
msgstr ""
"Se trata de una envoltura alrededor de :c:func:`PyImport_Import()` que toma "
"un :c:expr:`const char *` como argumento en lugar de un :c:expr:`PyObject *`."

#: ../../c-api/import.rst:21
msgid "This function is a deprecated alias of :c:func:`PyImport_ImportModule`."
msgstr "Esta función es un alias obsoleto de :c:func:`PyImport_ImportModule`."

#: ../../c-api/import.rst:23
msgid ""
"This function used to fail immediately when the import lock was held by "
"another thread.  In Python 3.3 though, the locking scheme switched to per-"
"module locks for most purposes, so this function's special behaviour isn't "
"needed anymore."
msgstr ""
"Esta función solía fallar inmediatamente cuando el bloqueo de importación "
"estaba en manos de otro hilo.  Sin embargo, en Python 3.3, el esquema de "
"bloqueo cambió a bloqueos por módulo para la mayoría de los propósitos, así "
"ya no es necesaria la conducta especial de esta función."

#: ../../c-api/import.rst:34
msgid ""
"Import a module.  This is best described by referring to the built-in Python "
"function :func:`__import__`."
msgstr ""
"Importar un módulo.  Esto se describe mejor haciendo referencia a la función "
"incorporada de Python :func:`__import__`."

#: ../../c-api/import.rst:37 ../../c-api/import.rst:53
msgid ""
"The return value is a new reference to the imported module or top-level "
"package, or ``NULL`` with an exception set on failure.  Like for :func:"
"`__import__`, the return value when a submodule of a package was requested "
"is normally the top-level package, unless a non-empty *fromlist* was given."
msgstr ""
"El valor de retorno es una nueva referencia al módulo importado o al paquete "
"de nivel superior, o ``NULL`` con una excepción en caso de fallo.  Al igual "
"que para :func:`__import__`, el valor de retorno cuando se solicita un "
"submódulo de un paquete es normalmente el paquete de nivel superior, a menos "
"que se proporcione una *fromlist* no vacía."

#: ../../c-api/import.rst:43
msgid ""
"Failing imports remove incomplete module objects, like with :c:func:"
"`PyImport_ImportModule`."
msgstr ""
"Las importaciones fallidas eliminan objetos de módulo incompletos, como "
"ocurre con :c:func:`PyImport_ImportModule`."

#: ../../c-api/import.rst:49
msgid ""
"Import a module.  This is best described by referring to the built-in Python "
"function :func:`__import__`, as the standard :func:`__import__` function "
"calls this function directly."
msgstr ""
"Importar un módulo.  Esto se describe mejor haciendo referencia a la función "
"incorporada de Python :func:`__import__`, ya que la función estándar :func:"
"`__import__` llama directamente a esta función."

#: ../../c-api/import.rst:63
msgid ""
"Similar to :c:func:`PyImport_ImportModuleLevelObject`, but the name is a "
"UTF-8 encoded string instead of a Unicode object."
msgstr ""
"Similar a :c:func:`PyImport_ImportModuleLevelObject`, pero el nombre es una "
"cadena codificada en UTF-8 en lugar de un objeto Unicode."

#: ../../c-api/import.rst:66
msgid "Negative values for *level* are no longer accepted."
msgstr "Ya no se aceptan valores negativos para *level*."

#: ../../c-api/import.rst:71
msgid ""
"This is a higher-level interface that calls the current \"import hook "
"function\" (with an explicit *level* of 0, meaning absolute import).  It "
"invokes the :func:`__import__` function from the ``__builtins__`` of the "
"current globals.  This means that the import is done using whatever import "
"hooks are installed in the current environment."
msgstr ""
"Se trata de una interfaz de nivel superior que llama a la \"función gancho "
"de importación\" actual (con un *nivel* explícito de 0, que significa "
"importación absoluta).  Invoca la función :func:`__import__` desde "
"``__builtins__`` de los globales actuales.  Esto significa que la "
"importación se realiza utilizando cualquier gancho de importación instalado "
"en el entorno actual."

#: ../../c-api/import.rst:77
msgid "This function always uses absolute imports."
msgstr "Esta función utiliza siempre importaciones absolutas."

#: ../../c-api/import.rst:82
msgid ""
"Reload a module.  Return a new reference to the reloaded module, or ``NULL`` "
"with an exception set on failure (the module still exists in this case)."
msgstr ""
"Recarga un módulo.  Devuelve una nueva referencia al módulo recargado, o "
"``NULL`` con una excepción establecida en caso de fallo (el módulo sigue "
"existiendo en este caso)."

#: ../../c-api/import.rst:88
msgid ""
"Return the module object corresponding to a module name.  The *name* "
"argument may be of the form ``package.module``. First check the modules "
"dictionary if there's one there, and if not, create a new one and insert it "
"in the modules dictionary. Return ``NULL`` with an exception set on failure."
msgstr ""
"Devuelve el objeto módulo correspondiente a un nombre de módulo.  El "
"argumento *name* puede ser de la forma ``package.module``. Primero comprueba "
"el diccionario de módulos si hay uno, y si no, crea uno nuevo y lo inserta "
"en el diccionario de módulos. Devuelve ``NULL`` con una excepción en caso de "
"fallo."

#: ../../c-api/import.rst:95
msgid ""
"This function does not load or import the module; if the module wasn't "
"already loaded, you will get an empty module object. Use :c:func:"
"`PyImport_ImportModule` or one of its variants to import a module.  Package "
"structures implied by a dotted name for *name* are not created if not "
"already present."
msgstr ""
"Esta función no carga ni importa el módulo; si el módulo no estaba ya "
"cargado, obtendrá un objeto módulo vacío. Utilice :c:func:"
"`PyImport_ImportModule` o una de sus variantes para importar un módulo.  Las "
"estructuras de paquete implicadas por un nombre con puntos para *name* no se "
"crean si no están ya presentes."

#: ../../c-api/import.rst:105
msgid ""
"Similar to :c:func:`PyImport_AddModuleObject`, but the name is a UTF-8 "
"encoded string instead of a Unicode object."
msgstr ""
"Similar a :c:func:`PyImport_AddModuleObject`, pero el nombre es una cadena "
"codificada en UTF-8 en lugar de un objeto Unicode."

#: ../../c-api/import.rst:113
msgid ""
"Given a module name (possibly of the form ``package.module``) and a code "
"object read from a Python bytecode file or obtained from the built-in "
"function :func:`compile`, load the module.  Return a new reference to the "
"module object, or ``NULL`` with an exception set if an error occurred.  "
"*name* is removed from :data:`sys.modules` in error cases, even if *name* "
"was already in :data:`sys.modules` on entry to :c:func:"
"`PyImport_ExecCodeModule`.  Leaving incompletely initialized modules in :"
"data:`sys.modules` is dangerous, as imports of such modules have no way to "
"know that the module object is an unknown (and probably damaged with respect "
"to the module author's intents) state."
msgstr ""
"Dado un nombre de módulo (posiblemente de la forma ``package.module``) y un "
"objeto de código leído de un archivo bytecode de Python u obtenido de la "
"función incorporada :func:`compile`, carga el módulo.  Devuelve una nueva "
"referencia al objeto módulo, o ``NULL`` con una excepción establecida si se "
"ha producido un error.  *nombre* se elimina de :data:`sys.modules` en casos "
"de error, incluso si *nombre* ya estaba en :data:`sys.modules` al entrar en :"
"c:func:`PyImport_ExecCodeModule`.  Dejar módulos incompletamente "
"inicializados en :data:`sys.modules` es peligroso, ya que las importaciones "
"de tales módulos no tienen forma de saber que el objeto módulo está en un "
"estado desconocido (y probablemente dañado con respecto a las intenciones "
"del autor del módulo)."

#: ../../c-api/import.rst:123
msgid ""
"The module's :attr:`__spec__` and :attr:`__loader__` will be set, if not set "
"already, with the appropriate values.  The spec's loader will be set to the "
"module's ``__loader__`` (if set) and to an instance of :class:`~importlib."
"machinery.SourceFileLoader` otherwise."
msgstr ""
":attr:`__spec__` y :attr:`__loader__` del módulo se establecerán, si no lo "
"están ya, con los valores apropiados.  El cargador de la especificación se "
"establecerá en ``__loader__`` del módulo (si está establecido) y en una "
"instancia de :class:`~importlib.machinery.SourceFileLoader` en caso "
"contrario."

#: ../../c-api/import.rst:128
msgid ""
"The module's :attr:`__file__` attribute will be set to the code object's :"
"attr:`~codeobject.co_filename`.  If applicable, :attr:`__cached__` will also "
"be set."
msgstr ""
"El atributo :attr:`__file__` del módulo se establecerá en :attr:`~codeobject."
"co_filename` del objeto de código. Si procede, también se establecerá :attr:"
"`__cached__`."

#: ../../c-api/import.rst:132
msgid ""
"This function will reload the module if it was already imported.  See :c:"
"func:`PyImport_ReloadModule` for the intended way to reload a module."
msgstr ""
"Esta función recargará el módulo si ya fue importado.  Consultar :c:func:"
"`PyImport_ReloadModule` para conocer la forma prevista de recargar un módulo."

#: ../../c-api/import.rst:135
msgid ""
"If *name* points to a dotted name of the form ``package.module``, any "
"package structures not already created will still not be created."
msgstr ""
"Si *name* apunta a un nombre con puntos de la forma ``package.module``, "
"cualquier estructura de paquete que no esté ya creada seguirá sin crearse."

#: ../../c-api/import.rst:138
msgid ""
"See also :c:func:`PyImport_ExecCodeModuleEx` and :c:func:"
"`PyImport_ExecCodeModuleWithPathnames`."
msgstr ""
"Ver también :c:func:`PyImport_ExecCodeModuleEx` y :c:func:"
"`PyImport_ExecCodeModuleWithPathnames`."

#: ../../c-api/import.rst:144
msgid ""
"Like :c:func:`PyImport_ExecCodeModule`, but the :attr:`__file__` attribute "
"of the module object is set to *pathname* if it is non-``NULL``."
msgstr ""
"Como :c:func:`PyImport_ExecCodeModule`, pero el atributo :attr:`__file__` "
"del objeto de módulo se establece en *pathname* si no es``NULL``."

#: ../../c-api/import.rst:147
msgid "See also :c:func:`PyImport_ExecCodeModuleWithPathnames`."
msgstr "Ver también :c:func:`PyImport_ExecCodeModuleWithPathnames`."

#: ../../c-api/import.rst:152
msgid ""
"Like :c:func:`PyImport_ExecCodeModuleEx`, but the :attr:`__cached__` "
"attribute of the module object is set to *cpathname* if it is non-``NULL``.  "
"Of the three functions, this is the preferred one to use."
msgstr ""
"Como :c:func:`PyImport_ExecCodeModuleEx`, pero el atributo :attr:"
"`__cached__` del objeto módulo se establece en *cpathname* si no "
"es``NULL``.  De las tres funciones, ésta es la preferida."

#: ../../c-api/import.rst:161
msgid ""
"Like :c:func:`PyImport_ExecCodeModuleObject`, but *name*, *pathname* and "
"*cpathname* are UTF-8 encoded strings. Attempts are also made to figure out "
"what the value for *pathname* should be from *cpathname* if the former is "
"set to ``NULL``."
msgstr ""
"Como :c:func:`PyImport_ExecCodeModuleObject`, pero *name*, *pathname* y "
"*cpathname* son cadenas codificadas en UTF-8. También se intenta averiguar "
"cuál debería ser el valor de *pathname* a partir de *cpathname* si el "
"primero se establece en ``NULL``."

#: ../../c-api/import.rst:167
msgid ""
"Uses :func:`imp.source_from_cache()` in calculating the source path if only "
"the bytecode path is provided."
msgstr ""

#: ../../c-api/import.rst:174
msgid ""
"Return the magic number for Python bytecode files (a.k.a. :file:`.pyc` "
"file). The magic number should be present in the first four bytes of the "
"bytecode file, in little-endian byte order. Returns ``-1`` on error."
msgstr ""
"Devuelve el número mágico de los archivos de código de bytes de Python "
"(también conocido como archivo :file:`.pyc` ). El número mágico debe estar "
"presente en los primeros cuatro bytes del archivo bytecode, en orden little-"
"endian. Devuelve ``-1`` en caso de error."

#: ../../c-api/import.rst:178
msgid "Return value of ``-1`` upon failure."
msgstr "Valor de retorno de ``-1`` en caso de fallo."

#: ../../c-api/import.rst:184
msgid ""
"Return the magic tag string for :pep:`3147` format Python bytecode file "
"names.  Keep in mind that the value at ``sys.implementation.cache_tag`` is "
"authoritative and should be used instead of this function."
msgstr ""
"Devuelve la cadena de etiquetas mágicas para nombres de archivos de código "
"de bytes de Python con formato :pep:`3147`.  Tener en cuenta que el valor en "
"``sys.implementation.cache_tag`` es autoritativo y debe utilizarse en lugar "
"de esta función."

#: ../../c-api/import.rst:192
msgid ""
"Return the dictionary used for the module administration (a.k.a. ``sys."
"modules``).  Note that this is a per-interpreter variable."
msgstr ""
"Devuelve el diccionario utilizado para la administración del módulo (también "
"conocido como ``sys.modules``).  Tener en cuenta que se trata de una "
"variable por intérprete."

#: ../../c-api/import.rst:197
msgid ""
"Return the already imported module with the given name.  If the module has "
"not been imported yet then returns ``NULL`` but does not set an error.  "
"Returns ``NULL`` and sets an error if the lookup failed."
msgstr ""
"Devuelve el módulo ya importado con el nombre dado.  Si el módulo aún no se "
"ha importado, devuelve ``NULL`` pero no genera ningún error.  Si la búsqueda "
"falla, devuelve ``NULL`` y genera un error."

#: ../../c-api/import.rst:205
msgid ""
"Return a finder object for a :data:`sys.path`/:attr:`!pkg.__path__` item "
"*path*, possibly by fetching it from the :data:`sys.path_importer_cache` "
"dict.  If it wasn't yet cached, traverse :data:`sys.path_hooks` until a hook "
"is found that can handle the path item.  Return ``None`` if no hook could; "
"this tells our caller that the :term:`path based finder` could not find a "
"finder for this path item. Cache the result in :data:`sys."
"path_importer_cache`. Return a new reference to the finder object."
msgstr ""
"Devuelve un objeto buscador para un elemento *ruta* de :data:`sys.path`/:"
"attr:`!pkg.__path__`, posiblemente obteniéndolo del dict :data:`sys."
"path_importer_cache`.  Si aún no se ha almacenado en caché, recorre :data:"
"`sys.path_hooks` hasta encontrar un gancho que pueda manejar el elemento "
"path.  Devuelve ``None`` si no hay ningún gancho que pueda hacerlo; esto "
"indica a quien llama que el :term:`buscador basado en ruta` no pudo "
"encontrar un buscador para este elemento de ruta. Almacena el resultado en :"
"data:`sys.path_importer_cache`. Devuelve una nueva referencia al objeto "
"buscador."

#: ../../c-api/import.rst:216
msgid ""
"Load a frozen module named *name*.  Return ``1`` for success, ``0`` if the "
"module is not found, and ``-1`` with an exception set if the initialization "
"failed.  To access the imported module on a successful load, use :c:func:"
"`PyImport_ImportModule`.  (Note the misnomer --- this function would reload "
"the module if it was already imported.)"
msgstr ""
"Carga un módulo congelado llamado *name*.  Devuelve ``1`` en caso de éxito, "
"``0`` si el módulo no se encuentra, y ``-1`` con una excepción si la "
"inicialización falló.  Para acceder al módulo importado en una carga con "
"éxito, usar :c:func:`PyImport_ImportModule`. (Notar el nombre equivocado --- "
"esta función recargaría el módulo si ya estuviera importado)."

#: ../../c-api/import.rst:224
msgid "The ``__file__`` attribute is no longer set on the module."
msgstr "El atributo ``__file__`` ya no se establece en el módulo."

#: ../../c-api/import.rst:230
msgid ""
"Similar to :c:func:`PyImport_ImportFrozenModuleObject`, but the name is a "
"UTF-8 encoded string instead of a Unicode object."
msgstr ""
"Similar a :c:func:`PyImport_ImportFrozenModuleObject`, pero el nombre es una "
"cadena codificada en UTF-8 en lugar de un objeto Unicode."

#: ../../c-api/import.rst:238
msgid ""
"This is the structure type definition for frozen module descriptors, as "
"generated by the :program:`freeze` utility (see :file:`Tools/freeze/` in the "
"Python source distribution).  Its definition, found in :file:`Include/import."
"h`, is::"
msgstr ""
"Esta es la definición del tipo de estructura para los descriptores de "
"módulos congelados, generada por la utilidad :program:`freeze` (ver :file:"
"`Tools/freeze/` en la distribución del código fuente de Python).  Su "
"definición, que se encuentra en :file:`Include/import.h`, es::"

#: ../../c-api/import.rst:250
msgid ""
"The new ``is_package`` field indicates whether the module is a package or "
"not. This replaces setting the ``size`` field to a negative value."
msgstr ""
"El nuevo campo ``is_package`` indica si el módulo es un paquete o no. Esto "
"sustituye al valor negativo del campo ``size``."

#: ../../c-api/import.rst:256
msgid ""
"This pointer is initialized to point to an array of :c:struct:`_frozen` "
"records, terminated by one whose members are all ``NULL`` or zero.  When a "
"frozen module is imported, it is searched in this table.  Third-party code "
"could play tricks with this to provide a dynamically created collection of "
"frozen modules."
msgstr ""
"Este puntero se inicializa para apuntar a una matriz de registros :c:struct:"
"`_frozen`, terminada por uno cuyos miembros son todos ``NULL`` o cero.  "
"Cuando se importa un módulo congelado, se busca en esta tabla.  El código de "
"terceros podría jugar con esto para proporcionar una colección de módulos "
"congelados creada dinámicamente."

#: ../../c-api/import.rst:264
msgid ""
"Add a single module to the existing table of built-in modules.  This is a "
"convenience wrapper around :c:func:`PyImport_ExtendInittab`, returning "
"``-1`` if the table could not be extended.  The new module can be imported "
"by the name *name*, and uses the function *initfunc* as the initialization "
"function called on the first attempted import.  This should be called "
"before :c:func:`Py_Initialize`."
msgstr ""
"Añade un único módulo a la tabla existente de módulos incorporados.  Esta es "
"una envoltura de conveniencia alrededor de :c:func:`PyImport_ExtendInittab`, "
"devolviendo ``-1`` si la tabla no pudo ser extendida.  El nuevo módulo se "
"puede importar por el nombre *name*, y utiliza la función *initfunc* como "
"función de inicialización llamada en el primer intento de importación.  Esta "
"se debe llamar antes de :c:func:`Py_Initialize`."

#: ../../c-api/import.rst:274
msgid ""
"Structure describing a single entry in the list of built-in modules. "
"Programs which embed Python may use an array of these structures in "
"conjunction with :c:func:`PyImport_ExtendInittab` to provide additional "
"built-in modules. The structure consists of two members:"
msgstr ""
"Estructura que describe una única entrada en la lista de módulos "
"incorporados. Los programas que incrustan Python pueden utilizar una matriz "
"de estas estructuras junto con :c:func:`PyImport_ExtendInittab` para "
"proporcionar módulos incorporados adicionales. La estructura consta de dos "
"miembros:"

#: ../../c-api/import.rst:282
msgid "The module name, as an ASCII encoded string."
msgstr "El nombre del módulo, como cadena codificada en ASCII."

#: ../../c-api/import.rst:286
msgid "Initialization function for a module built into the interpreter."
msgstr "Función de inicialización de un módulo integrado en el intérprete."

#: ../../c-api/import.rst:291
msgid ""
"Add a collection of modules to the table of built-in modules.  The *newtab* "
"array must end with a sentinel entry which contains ``NULL`` for the :c:"
"member:`~_inittab.name` field; failure to provide the sentinel value can "
"result in a memory fault. Returns ``0`` on success or ``-1`` if insufficient "
"memory could be allocated to extend the internal table.  In the event of "
"failure, no modules are added to the internal table.  This must be called "
"before :c:func:`Py_Initialize`."
msgstr ""
"Añade una colección de módulos a la tabla de módulos incorporados.  La "
"matriz *newtab* debe terminar con una entrada centinela que contenga "
"``NULL`` para el campo :c:member:`~_inittab.name`; si no se proporciona el "
"valor centinela puede producirse un fallo de memoria. Devuelve ``0`` en caso "
"de éxito o ``-1`` si no se ha podido asignar memoria suficiente para ampliar "
"la tabla interna.  En caso de fallo, no se añade ningún módulo a la tabla "
"interna.  Debe invocarse antes de :c:func:`Py_Initialize`."

#: ../../c-api/import.rst:298
msgid ""
"If Python is initialized multiple times, :c:func:`PyImport_AppendInittab` "
"or :c:func:`PyImport_ExtendInittab` must be called before each Python "
"initialization."
msgstr ""
"Si Python se inicializa varias veces, se debe llamar a :c:func:"
"`PyImport_AppendInittab` o :c:func:`PyImport_ExtendInittab` antes de cada "
"inicialización de Python."

#: ../../c-api/import.rst:11
msgid "package variable"
msgstr "variable de paquete"

#: ../../c-api/import.rst:11
msgid "__all__"
msgstr "__all__"

#: ../../c-api/import.rst:11
msgid "__all__ (package variable)"
msgstr "__all__ (variable de paquete)"

#: ../../c-api/import.rst:11
msgid "modules (in module sys)"
msgstr "módulos (en módulo sys)"

#: ../../c-api/import.rst:32 ../../c-api/import.rst:111
msgid "built-in function"
msgstr "función incorporada"

#: ../../c-api/import.rst:32
msgid "__import__"
msgstr "__import__"

#: ../../c-api/import.rst:111
msgid "compile"
msgstr "compilar"

#: ../../c-api/import.rst:236
msgid "freeze utility"
msgstr "utilidad de congelación"
