# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 15:00+0000\n"
"PO-Revision-Date: 2025-07-18 19:21+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Spanish (Spain) (https://app.transifex.com/python-doc/"
"teams/5390/es_ES/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es_ES\n"
"Plural-Forms: nplurals=3; plural=n == 1 ? 0 : n != 0 && n % 1000000 == 0 ? "
"1 : 2;\n"

#: ../../c-api/unicode.rst:6
msgid "Unicode Objects and Codecs"
msgstr "Objetos Unicode y Codecs"

#: ../../c-api/unicode.rst:12
msgid "Unicode Objects"
msgstr "Objetos Unicode"

#: ../../c-api/unicode.rst:14
msgid ""
"Since the implementation of :pep:`393` in Python 3.3, Unicode objects "
"internally use a variety of representations, in order to allow handling the "
"complete range of Unicode characters while staying memory efficient.  There "
"are special cases for strings where all code points are below 128, 256, or "
"65536; otherwise, code points must be below 1114112 (which is the full "
"Unicode range)."
msgstr ""
"Desde la implementación de :pep:`393` en Python 3.3, los objetos Unicode "
"utilizan internamente una variedad de representaciones para permitir el "
"manejo de la gama completa de caracteres Unicode mientras se mantiene la "
"eficiencia de memoria. Hay casos especiales para cadenas donde todos los "
"puntos de código están por debajo de 128, 256 o 65536; de lo contrario, los "
"puntos de código deben estar por debajo de 1114112 (que es el rango completo "
"de Unicode)."

#: ../../c-api/unicode.rst:20
msgid ""
"UTF-8 representation is created on demand and cached in the Unicode object."
msgstr ""
"Представление UTF-8 создается по требованию и кэшируется в объекте Unicode."

#: ../../c-api/unicode.rst:23
msgid ""
"The :c:type:`Py_UNICODE` representation has been removed since Python 3.12 "
"with deprecated APIs. See :pep:`623` for more information."
msgstr ""
"Представление :c:type:`Py_UNICODE` было удалено начиная с версии Python 3.12 "
"с устаревшими API. См. :pep:`623` для получения дополнительной информации."

#: ../../c-api/unicode.rst:29
msgid "Unicode Type"
msgstr "Tipo Unicode"

#: ../../c-api/unicode.rst:31
msgid ""
"These are the basic Unicode object types used for the Unicode implementation "
"in Python:"
msgstr ""
"Estos son los tipos básicos de objetos Unicode utilizados para la "
"implementación de Unicode en Python."

#: ../../c-api/unicode.rst:38
msgid ""
"These types are typedefs for unsigned integer types wide enough to contain "
"characters of 32 bits, 16 bits and 8 bits, respectively.  When dealing with "
"single Unicode characters, use :c:type:`Py_UCS4`."
msgstr ""
"Estos tipos son typedefs para tipos de enteros sin signo lo suficientemente "
"amplios para contener caracteres de 32 bits, 16 bits y 8 bits, "
"respectivamente. Al tratar con caracteres Unicode individuales, utiliza :c:"
"type:`Py_UCS4`."

#: ../../c-api/unicode.rst:47
msgid ""
"This is a typedef of :c:type:`wchar_t`, which is a 16-bit type or 32-bit "
"type depending on the platform."
msgstr ""

#: ../../c-api/unicode.rst:50
msgid ""
"In previous versions, this was a 16-bit type or a 32-bit type depending on "
"whether you selected a \"narrow\" or \"wide\" Unicode version of Python at "
"build time."
msgstr ""
"En versiones anteriores, esto era un tipo de 16 bits o un tipo de 32 bits "
"dependiendo de si seleccionaste una versión de Python \"narrow\" o \"wide\" "
"de Unicode en el momento de la compilación."

#: ../../c-api/unicode.rst:62
msgid ""
"These subtypes of :c:type:`PyObject` represent a Python Unicode object.  In "
"almost all cases, they shouldn't be used directly, since all API functions "
"that deal with Unicode objects take and return :c:type:`PyObject` pointers."
msgstr ""
"Estos subtipos de :c:type:`PyObject` representan un objeto Unicode de "
"Python. En casi todos los casos, no se deberían utilizar directamente, ya "
"que todas las funciones de la API que trabajan con objetos Unicode toman y "
"devuelven punteros :c:type:`PyObject`."

#: ../../c-api/unicode.rst:71
msgid ""
"This instance of :c:type:`PyTypeObject` represents the Python Unicode type. "
"It is exposed to Python code as ``str``."
msgstr ""

#: ../../c-api/unicode.rst:77
msgid ""
"This instance of :c:type:`PyTypeObject` represents the Python Unicode "
"iterator type. It is used to iterate over Unicode string objects."
msgstr ""
"Esta instância de :c:type:`PyTypeObject` representa o tipo iterador Unicode "
"do Python. É usada para iterar sobre objetos string Unicode."

#: ../../c-api/unicode.rst:81
msgid ""
"The following APIs are C macros and static inlined functions for fast checks "
"and access to internal read-only data of Unicode objects:"
msgstr ""
"Следующие API представляют собой макросы C и статические встроенные функции "
"для быстрых проверок и доступа к внутренним данным объектов Unicode, "
"доступным только для чтения:"

#: ../../c-api/unicode.rst:86
msgid ""
"Return true if the object *obj* is a Unicode object or an instance of a "
"Unicode subtype.  This function always succeeds."
msgstr ""
"Возвращайте true, если объект *obj* является объектом Юникода или "
"экземпляром подтипа Юникода. Эта функция всегда завершается успешно."

#: ../../c-api/unicode.rst:92
msgid ""
"Return true if the object *obj* is a Unicode object, but not an instance of "
"a subtype.  This function always succeeds."
msgstr ""
"Возвращайте true, если объект *obj* является объектом Юникода, но не "
"экземпляром подтипа. Эта функция всегда завершается успешно."

#: ../../c-api/unicode.rst:98
msgid "Returns ``0``. This API is kept only for backward compatibility."
msgstr ""

#: ../../c-api/unicode.rst:102
msgid "This API does nothing since Python 3.12."
msgstr ""

#: ../../c-api/unicode.rst:108
msgid ""
"Return the length of the Unicode string, in code points.  *unicode* has to "
"be a Unicode object in the \"canonical\" representation (not checked)."
msgstr ""
"Возвращает длину строки Юникода в кодовых точках. *unicode* должен быть "
"объектом Unicode в «каноническом» представлении (не отмечено)."

#: ../../c-api/unicode.rst:118
msgid ""
"Return a pointer to the canonical representation cast to UCS1, UCS2 or UCS4 "
"integer types for direct character access.  No checks are performed if the "
"canonical representation has the correct character size; use :c:func:"
"`PyUnicode_KIND` to select the right function."
msgstr ""
"Возвращает указатель на каноническое представление, приведенное к "
"целочисленным типам UCS1, UCS2 или UCS4 для прямого доступа к символам. "
"Никакие проверки не выполняются, если каноническое представление имеет "
"правильный размер символов; используйте :c:func:`PyUnicode_KIND`, чтобы "
"выбрать правильную функцию."

#: ../../c-api/unicode.rst:130
msgid "Return values of the :c:func:`PyUnicode_KIND` macro."
msgstr "Valores de retorno de la macro :c:func:`PyUnicode_KIND`."

#: ../../c-api/unicode.rst:134
msgid "``PyUnicode_WCHAR_KIND`` has been removed."
msgstr "``PyUnicode_WCHAR_KIND`` был удален."

#: ../../c-api/unicode.rst:140
msgid ""
"Return one of the PyUnicode kind constants (see above) that indicate how "
"many bytes per character this Unicode object uses to store its data.  "
"*unicode* has to be a Unicode object in the \"canonical\" representation "
"(not checked)."
msgstr ""
"Возвращает одну из констант типа PyUnicode (см. выше), которая указывает, "
"сколько байтов на символ этот объект Unicode использует для хранения своих "
"данных. *unicode* должен быть объектом Unicode в «каноническом» "
"представлении (не отмечено)."

#: ../../c-api/unicode.rst:149
msgid ""
"Return a void pointer to the raw Unicode buffer.  *unicode* has to be a "
"Unicode object in the \"canonical\" representation (not checked)."
msgstr ""
"Верните указатель void в необработанный буфер Юникода. *unicode* должен быть "
"объектом Unicode в «каноническом» представлении (не отмечено)."

#: ../../c-api/unicode.rst:158
msgid ""
"Write into a canonical representation *data* (as obtained with :c:func:"
"`PyUnicode_DATA`).  This function performs no sanity checks, and is intended "
"for usage in loops.  The caller should cache the *kind* value and *data* "
"pointer as obtained from other calls.  *index* is the index in the string "
"(starts at 0) and *value* is the new code point value which should be "
"written to that location."
msgstr ""

#: ../../c-api/unicode.rst:171
msgid ""
"Read a code point from a canonical representation *data* (as obtained with :"
"c:func:`PyUnicode_DATA`).  No checks or ready calls are performed."
msgstr ""
"Lea un punto de código desde una representación canónica *data* (como se "
"obtiene con :c:func:`PyUnicode_DATA`). No se realizan comprobaciones ni "
"llamadas listas."

#: ../../c-api/unicode.rst:179
msgid ""
"Read a character from a Unicode object *unicode*, which must be in the "
"\"canonical\" representation.  This is less efficient than :c:func:"
"`PyUnicode_READ` if you do multiple consecutive reads."
msgstr ""
"Считайте символ из объекта Юникода *unicode*, который должен находиться в "
"«каноническом» представлении. Это менее эффективно, чем :c:func:"
"`PyUnicode_READ`, если вы выполняете несколько последовательных чтений."

#: ../../c-api/unicode.rst:188
msgid ""
"Return the maximum code point that is suitable for creating another string "
"based on *unicode*, which must be in the \"canonical\" representation.  This "
"is always an approximation but more efficient than iterating over the string."
msgstr ""
"Возвращает максимальную кодовую точку, подходящую для создания другой строки "
"на основе *unicode*, которая должна быть в «каноническом» представлении. Это "
"всегда приближение, но более эффективное, чем перебор строки."

#: ../../c-api/unicode.rst:197
msgid ""
"Return ``1`` if the string is a valid identifier according to the language "
"definition, section :ref:`identifiers`. Return ``0`` otherwise."
msgstr ""
"Devuelve ``1`` si la cadena es un identificador válido según la definición "
"del lenguaje, sección :ref:`identifiers`. Devuelve ``0`` en caso contrario."

#: ../../c-api/unicode.rst:200
msgid ""
"The function does not call :c:func:`Py_FatalError` anymore if the string is "
"not ready."
msgstr ""
"La función ya no llama a :c:func:`Py_FatalError` si la cadena no está lista."

#: ../../c-api/unicode.rst:206
msgid "Unicode Character Properties"
msgstr "Propiedades de los caracteres Unicode"

#: ../../c-api/unicode.rst:208
msgid ""
"Unicode provides many different character properties. The most often needed "
"ones are available through these macros which are mapped to C functions "
"depending on the Python configuration."
msgstr ""
"Unicode proporciona muchas propiedades de caracteres diferentes. Los más "
"necesarios están disponibles a través de estas macros que se asignan a "
"funciones C dependiendo de la configuración de Python."

#: ../../c-api/unicode.rst:215
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a whitespace character."
msgstr ""
"Devuelve ``1`` o ``0`` dependiendo de si *ch* es un carácter de espacio en "
"blanco."

#: ../../c-api/unicode.rst:220
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a lowercase character."
msgstr ""
"Devuelve ``1`` o ``0`` dependiendo de si *ch* es un carácter en minúscula."

#: ../../c-api/unicode.rst:225
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is an uppercase character."
msgstr ""
"Devuelve ``1`` o ``0`` dependiendo de si *ch* es un carácter en mayúscula."

#: ../../c-api/unicode.rst:230
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a titlecase character."
msgstr ""
"Devuelve ``1`` o ``0`` dependiendo de si *ch* es un carácter en mayúscula "
"inicial."

#: ../../c-api/unicode.rst:235
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a linebreak character."
msgstr ""
"Devuelve ``1`` o ``0`` dependiendo de si *ch* es un carácter de salto de "
"línea."

#: ../../c-api/unicode.rst:240
msgid "Return ``1`` or ``0`` depending on whether *ch* is a decimal character."
msgstr "Devuelve ``1`` o ``0`` dependiendo de si *ch* es un carácter decimal."

#: ../../c-api/unicode.rst:245
msgid "Return ``1`` or ``0`` depending on whether *ch* is a digit character."
msgstr "Devuelve ``1`` o ``0`` dependiendo de si *ch* es un carácter numérico."

#: ../../c-api/unicode.rst:250
msgid "Return ``1`` or ``0`` depending on whether *ch* is a numeric character."
msgstr "Devuelve ``1`` o ``0`` dependiendo de si *ch* es un carácter numérico."

#: ../../c-api/unicode.rst:255
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is an alphabetic character."
msgstr ""
"Devuelve ``1`` o ``0`` dependiendo de si *ch* es un carácter alfabético."

#: ../../c-api/unicode.rst:260
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is an alphanumeric character."
msgstr ""
"Devuelve ``1`` o ``0`` dependiendo de si *ch* es un carácter alfanumérico."

#: ../../c-api/unicode.rst:265
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a printable character, in "
"the sense of :meth:`str.isprintable`."
msgstr ""
"Возвращает ``1`` или ``0`` в зависимости от того, является ли *ch* печатным "
"символом в смысле :meth:`str.isprintable`."

#: ../../c-api/unicode.rst:269
msgid "These APIs can be used for fast direct character conversions:"
msgstr ""
"Estas APIs se pueden utilizar para conversiones de caracteres directas y "
"rápidas."

#: ../../c-api/unicode.rst:274
msgid "Return the character *ch* converted to lower case."
msgstr "Devuelve el carácter *ch* convertido a minúscula."

#: ../../c-api/unicode.rst:279
msgid "Return the character *ch* converted to upper case."
msgstr "Devuelve el carácter *ch* convertido a mayúsculas."

#: ../../c-api/unicode.rst:284
msgid "Return the character *ch* converted to title case."
msgstr "Devuelve el carácter *ch* convertido a título."

#: ../../c-api/unicode.rst:289
msgid ""
"Return the character *ch* converted to a decimal positive integer.  Return "
"``-1`` if this is not possible.  This function does not raise exceptions."
msgstr ""
"Возвращает символ *ch*, преобразованный в десятичное положительное целое "
"число. Верните ``-1``, если это невозможно. Эта функция не вызывает "
"исключений."

#: ../../c-api/unicode.rst:295
msgid ""
"Return the character *ch* converted to a single digit integer. Return ``-1`` "
"if this is not possible.  This function does not raise exceptions."
msgstr ""
"Возвращает символ *ch*, преобразованный в однозначное целое число. Верните "
"``-1``, если это невозможно. Эта функция не вызывает исключений."

#: ../../c-api/unicode.rst:301
msgid ""
"Return the character *ch* converted to a double. Return ``-1.0`` if this is "
"not possible.  This function does not raise exceptions."
msgstr ""
"Возвращает символ *ch*, преобразованный в двойной. Верните ``-1.0``, если "
"это невозможно. Эта функция не вызывает исключений."

#: ../../c-api/unicode.rst:305
msgid "These APIs can be used to work with surrogates:"
msgstr "Estas APIs se pueden utilizar para trabajar con sustitutos."

#: ../../c-api/unicode.rst:309
msgid "Check if *ch* is a surrogate (``0xD800 <= ch <= 0xDFFF``)."
msgstr "Comprueba si *ch* es un sustituto (``0xD800 <= ch <= 0xDFFF``)."

#: ../../c-api/unicode.rst:313
msgid "Check if *ch* is a high surrogate (``0xD800 <= ch <= 0xDBFF``)."
msgstr "Comprueba si *ch* es un alto sustituto (``0xD800 <= ch <= 0xDBFF``)."

#: ../../c-api/unicode.rst:317
msgid "Check if *ch* is a low surrogate (``0xDC00 <= ch <= 0xDFFF``)."
msgstr "Comprueba si *ch* es un sustituto bajo (``0xDC00 <= ch <= 0xDFFF``)."

#: ../../c-api/unicode.rst:321
msgid ""
"Join two surrogate code points and return a single :c:type:`Py_UCS4` value. "
"*high* and *low* are respectively the leading and trailing surrogates in a "
"surrogate pair. *high* must be in the range [0xD800; 0xDBFF] and *low* must "
"be in the range [0xDC00; 0xDFFF]."
msgstr ""
"Объедините две суррогатные точки кода и верните одно значение :c:type:"
"`Py_UCS4`. *high* и *low* являются ведущими и конечными заместителями в "
"суррогатной паре соответственно. *high* должен находиться в диапазоне "
"[0xD800; 0xDBFF] и *low* должны находиться в диапазоне [0xDC00; 0xDFFF]."

#: ../../c-api/unicode.rst:328
msgid "Creating and accessing Unicode strings"
msgstr "Crear y acceder a cadenas Unicode"

#: ../../c-api/unicode.rst:330
msgid ""
"To create Unicode objects and access their basic sequence properties, use "
"these APIs:"
msgstr ""
"Para crear objetos Unicode y acceder a sus propiedades básicas de secuencia, "
"utiliza estas APIs:"

#: ../../c-api/unicode.rst:335
msgid ""
"Create a new Unicode object.  *maxchar* should be the true maximum code "
"point to be placed in the string.  As an approximation, it can be rounded up "
"to the nearest value in the sequence 127, 255, 65535, 1114111."
msgstr ""
"Crear un nuevo objeto Unicode. *maxchar* debería ser el verdadero punto de "
"código máximo que se colocará en la cadena. Como aproximación, se puede "
"redondear al valor más cercano en la secuencia 127, 255, 65535, 1114111."

#: ../../c-api/unicode.rst:339
msgid ""
"This is the recommended way to allocate a new Unicode object.  Objects "
"created using this function are not resizable."
msgstr ""
"Esta es la forma recomendada de asignar un nuevo objeto Unicode. Los objetos "
"creados usando esta función no son redimensionables."

#: ../../c-api/unicode.rst:342
msgid "On error, set an exception and return ``NULL``."
msgstr "При ошибке установите исключение и верните ``NULL``."

#: ../../c-api/unicode.rst:350
msgid ""
"Create a new Unicode object with the given *kind* (possible values are :c:"
"macro:`PyUnicode_1BYTE_KIND` etc., as returned by :c:func:"
"`PyUnicode_KIND`).  The *buffer* must point to an array of *size* units of "
"1, 2 or 4 bytes per character, as given by the kind."
msgstr ""
"Crear un nuevo objeto Unicode con el *kind* dado (los valores posibles son :"
"c:macro:`PyUnicode_1BYTE_KIND`, etc., como se devuelve por :c:func:"
"`PyUnicode_KIND`). El *buffer* debe apuntar a un array de *size* unidades de "
"1, 2 o 4 bytes por carácter, según el *kind* dado."

#: ../../c-api/unicode.rst:355
msgid ""
"If necessary, the input *buffer* is copied and transformed into the "
"canonical representation.  For example, if the *buffer* is a UCS4 string (:c:"
"macro:`PyUnicode_4BYTE_KIND`) and it consists only of codepoints in the UCS1 "
"range, it will be transformed into UCS1 (:c:macro:`PyUnicode_1BYTE_KIND`)."
msgstr ""
"При необходимости входной *буфер* копируется и преобразуется в каноническое "
"представление. Например, если *buffer* представляет собой строку UCS4 (:c:"
"macro:`PyUnicode_4BYTE_KIND`) и состоит только из кодовых точек в диапазоне "
"UCS1, он будет преобразован в UCS1 (:c:macro:`PyUnicode_1BYTE_KIND`)."

#: ../../c-api/unicode.rst:366
msgid ""
"Create a Unicode object from the char buffer *str*.  The bytes will be "
"interpreted as being UTF-8 encoded.  The buffer is copied into the new "
"object. The return value might be a shared object, i.e. modification of the "
"data is not allowed."
msgstr ""
"Создайте объект Unicode из буфера символов *str*. Байты будут "
"интерпретироваться как кодированные UTF-8. Буфер копируется в новый объект. "
"Возвращаемое значение может быть общим объектом, т. е. изменение данных не "
"допускается."

#: ../../c-api/unicode.rst:372
msgid "This function raises :exc:`SystemError` when:"
msgstr "Эта функция вызывает :exc:`SystemError`, когда:"

#: ../../c-api/unicode.rst:374
msgid "*size* < 0,"
msgstr "*size* < 0,"

#: ../../c-api/unicode.rst:375
msgid "*str* is ``NULL`` and *size* > 0"
msgstr "*str* равно ``NULL`` и *size* > 0"

#: ../../c-api/unicode.rst:377
msgid "*str* == ``NULL`` with *size* > 0 is not allowed anymore."
msgstr "*str* == ``NULL`` с *size* > 0 больше не допускается."

#: ../../c-api/unicode.rst:383
msgid ""
"Create a Unicode object from a UTF-8 encoded null-terminated char buffer "
"*str*."
msgstr ""
"Создайте объект Unicode из буфера символов с нулевым завершением в кодировке "
"UTF-8 *str*."

#: ../../c-api/unicode.rst:389
msgid ""
"Take a C :c:func:`printf`\\ -style *format* string and a variable number of "
"arguments, calculate the size of the resulting Python Unicode string and "
"return a string with the values formatted into it.  The variable arguments "
"must be C types and must correspond exactly to the format characters in the "
"*format* ASCII-encoded string."
msgstr ""
"Возьмите строку C :c:func:`printf`\\ -style *format* и переменное количество "
"аргументов, вычислите размер результирующей строки Python Unicode и верните "
"строку со отформатированными в ней значениями. Переменные аргументы должны "
"быть типами C и должны точно соответствовать символам формата в строке "
"*format* в кодировке ASCII."

#: ../../c-api/unicode.rst:395
msgid ""
"A conversion specifier contains two or more characters and has the following "
"components, which must occur in this order:"
msgstr ""
"Un especificador de conversión contiene dos o más caracteres y tiene los "
"siguientes componentes, que deben aparecer en este orden:"

#: ../../c-api/unicode.rst:398
msgid "The ``'%'`` character, which marks the start of the specifier."
msgstr "El carácter ``'%'``, que marca el inicio del especificador."

#: ../../c-api/unicode.rst:400
msgid ""
"Conversion flags (optional), which affect the result of some conversion "
"types."
msgstr ""
"Indicadores de conversión (opcionales), que afectan al resultado de algunos "
"tipos de conversión."

#: ../../c-api/unicode.rst:403
msgid ""
"Minimum field width (optional). If specified as an ``'*'`` (asterisk), the "
"actual width is given in the next argument, which must be of type :c:expr:"
"`int`, and the object to convert comes after the minimum field width and "
"optional precision."
msgstr ""
"Минимальная ширина поля (необязательно). Если указано как ``'*'`` "
"(звездочка), фактическая ширина указывается в следующем аргументе, который "
"должен иметь тип :c:expr:`int`, а преобразуемый объект располагается после "
"минимальной ширины поля. и дополнительная точность."

#: ../../c-api/unicode.rst:408
msgid ""
"Precision (optional), given as a ``'.'`` (dot) followed by the precision. If "
"specified as ``'*'`` (an asterisk), the actual precision is given in the "
"next argument, which must be of type :c:expr:`int`, and the value to convert "
"comes after the precision."
msgstr ""
"Точность (необязательно), указывается как ``'.'`` (точка), за которой "
"следует точность. Если указано как ``'*'`` (звездочка), фактическая точность "
"указывается в следующем аргументе, который должен иметь тип :c:expr:`int`, а "
"преобразуемое значение идет после точности."

#: ../../c-api/unicode.rst:413
msgid "Length modifier (optional)."
msgstr "Modificador de longitud (opcional)."

#: ../../c-api/unicode.rst:415
msgid "Conversion type."
msgstr "Tipo de conversión."

#: ../../c-api/unicode.rst:417
msgid "The conversion flag characters are:"
msgstr "Los caracteres de la bandera de conversión son:"

#: ../../c-api/unicode.rst:422
msgid "Flag"
msgstr "Bandera"

#: ../../c-api/unicode.rst:422
msgid "Meaning"
msgstr "Significado"

#: ../../c-api/unicode.rst:424
msgid "``0``"
msgstr "``0``"

#: ../../c-api/unicode.rst:424
msgid "The conversion will be zero padded for numeric values."
msgstr "La conversión tendrá un relleno cero para los valores numéricos."

#: ../../c-api/unicode.rst:426
msgid "``-``"
msgstr "``-``"

#: ../../c-api/unicode.rst:426
msgid ""
"The converted value is left adjusted (overrides the ``0`` flag if both are "
"given)."
msgstr ""
"Преобразованное значение остается скорректированным (переопределяет флаг "
"``0``, если заданы оба)."

#: ../../c-api/unicode.rst:430
msgid ""
"The length modifiers for following integer conversions (``d``, ``i``, ``o``, "
"``u``, ``x``, or ``X``) specify the type of the argument (:c:expr:`int` by "
"default):"
msgstr ""
"Модификаторы длины для следующих целочисленных преобразований (``d``, ``i``, "
"``o``, ``u``, ``x`` или ``X``) определяют тип аргумент (:c:expr:`int` по "
"умолчанию):"

#: ../../c-api/unicode.rst:437
msgid "Modifier"
msgstr "Модификатор"

#: ../../c-api/unicode.rst:437
msgid "Types"
msgstr "Tipos"

#: ../../c-api/unicode.rst:439
msgid "``l``"
msgstr "``l``"

#: ../../c-api/unicode.rst:439
msgid ":c:expr:`long` or :c:expr:`unsigned long`"
msgstr ":c:expr:`long` или :c:expr:`unsigned long`"

#: ../../c-api/unicode.rst:441
msgid "``ll``"
msgstr "``ll``"

#: ../../c-api/unicode.rst:441
msgid ":c:expr:`long long` or :c:expr:`unsigned long long`"
msgstr ":c:expr:`long long` или :c:expr:`unsigned long long`."

#: ../../c-api/unicode.rst:443
msgid "``j``"
msgstr "``j``"

#: ../../c-api/unicode.rst:443
msgid ":c:type:`intmax_t` or :c:type:`uintmax_t`"
msgstr ":c:type:`intmax_t` или :c:type:`uintmax_t`"

#: ../../c-api/unicode.rst:445
msgid "``z``"
msgstr "``z``"

#: ../../c-api/unicode.rst:445
msgid ":c:type:`size_t` or :c:type:`ssize_t`"
msgstr ":c:type:`size_t` или :c:type:`ssize_t`"

#: ../../c-api/unicode.rst:447
msgid "``t``"
msgstr "``t``"

#: ../../c-api/unicode.rst:447
msgid ":c:type:`ptrdiff_t`"
msgstr ":c:type:`ptrdiff_t`"

#: ../../c-api/unicode.rst:450
msgid ""
"The length modifier ``l`` for following conversions ``s`` or ``V`` specify "
"that the type of the argument is :c:expr:`const wchar_t*`."
msgstr ""
"Модификатор длины l для следующих преобразований ``s`` или ``V`` указывает, "
"что тип аргумента — :c:expr:`const wchar_t*`."

#: ../../c-api/unicode.rst:453
msgid "The conversion specifiers are:"
msgstr "Спецификаторы преобразования:"

#: ../../c-api/unicode.rst:459
msgid "Conversion Specifier"
msgstr "Спецификатор преобразования"

#: ../../c-api/unicode.rst:460
msgid "Type"
msgstr "Tipo"

#: ../../c-api/unicode.rst:461
msgid "Comment"
msgstr "Comentario"

#: ../../c-api/unicode.rst:463
msgid "``%``"
msgstr "``%``"

#: ../../c-api/unicode.rst:464
msgid "*n/a*"
msgstr "*n/a*"

#: ../../c-api/unicode.rst:465
msgid "The literal ``%`` character."
msgstr "Буквальный символ ``%``."

#: ../../c-api/unicode.rst:467
msgid "``d``, ``i``"
msgstr "``d``, ``i``"

#: ../../c-api/unicode.rst:468 ../../c-api/unicode.rst:472
#: ../../c-api/unicode.rst:476 ../../c-api/unicode.rst:480
#: ../../c-api/unicode.rst:484
msgid "Specified by the length modifier"
msgstr "Задается модификатором длины"

#: ../../c-api/unicode.rst:469
msgid "The decimal representation of a signed C integer."
msgstr "Десятичное представление целого числа C со знаком."

#: ../../c-api/unicode.rst:471
msgid "``u``"
msgstr "``u``"

#: ../../c-api/unicode.rst:473
msgid "The decimal representation of an unsigned C integer."
msgstr "Десятичное представление целого числа C без знака."

#: ../../c-api/unicode.rst:475
msgid "``o``"
msgstr "``o``"

#: ../../c-api/unicode.rst:477
msgid "The octal representation of an unsigned C integer."
msgstr "Восьмеричное представление целого числа C без знака."

#: ../../c-api/unicode.rst:479
msgid "``x``"
msgstr "``x``"

#: ../../c-api/unicode.rst:481
msgid "The hexadecimal representation of an unsigned C integer (lowercase)."
msgstr ""
"Шестнадцатеричное представление целого числа C без знака (в нижнем регистре)."

#: ../../c-api/unicode.rst:483
msgid "``X``"
msgstr "``X``"

#: ../../c-api/unicode.rst:485
msgid "The hexadecimal representation of an unsigned C integer (uppercase)."
msgstr ""
"Шестнадцатеричное представление целого числа C без знака (заглавные буквы)."

#: ../../c-api/unicode.rst:487
msgid "``c``"
msgstr "``c``"

#: ../../c-api/unicode.rst:488
msgid ":c:expr:`int`"
msgstr ":c:expr:`int`"

#: ../../c-api/unicode.rst:489
msgid "A single character."
msgstr "Один символ."

#: ../../c-api/unicode.rst:491
msgid "``s``"
msgstr "``s``"

#: ../../c-api/unicode.rst:492
msgid ":c:expr:`const char*` or :c:expr:`const wchar_t*`"
msgstr ":c:expr:`const char*` или :c:expr:`const wchar_t*`"

#: ../../c-api/unicode.rst:493
msgid "A null-terminated C character array."
msgstr "Una matriz de caracteres C terminada en nulo."

#: ../../c-api/unicode.rst:495
msgid "``p``"
msgstr "``p``"

#: ../../c-api/unicode.rst:496
msgid ":c:expr:`const void*`"
msgstr ":c:expr:`const void*`"

#: ../../c-api/unicode.rst:497
msgid ""
"The hex representation of a C  pointer. Mostly equivalent to "
"``printf(\"%p\")`` except that it is guaranteed to start with the literal "
"``0x`` regardless of what the platform's ``printf`` yields."
msgstr ""
"Шестнадцатеричное представление указателя C. В основном эквивалентно "
"``printf(\" %p \")`` за исключением того, что он гарантированно начинается с "
"литерала ``0x`` независимо от того, что выдает ``printf`` платформы."

#: ../../c-api/unicode.rst:502
msgid "``A``"
msgstr "``A``"

#: ../../c-api/unicode.rst:503 ../../c-api/unicode.rst:507
#: ../../c-api/unicode.rst:517 ../../c-api/unicode.rst:521
#: ../../c-api/unicode.rst:525 ../../c-api/unicode.rst:530
msgid ":c:expr:`PyObject*`"
msgstr ":c:expr:`PyObject*`"

#: ../../c-api/unicode.rst:504
msgid "The result of calling :func:`ascii`."
msgstr "El resultado de llamar a :func:`ascii`."

#: ../../c-api/unicode.rst:506
msgid "``U``"
msgstr "``U``"

#: ../../c-api/unicode.rst:508
msgid "A Unicode object."
msgstr "Un objeto Unicode."

#: ../../c-api/unicode.rst:510
msgid "``V``"
msgstr "``V``"

#: ../../c-api/unicode.rst:511
msgid ":c:expr:`PyObject*`, :c:expr:`const char*` or :c:expr:`const wchar_t*`"
msgstr ""
":c:expr:`PyObject*`, :c:expr:`const char*` или :c:expr:`const wchar_t*`"

#: ../../c-api/unicode.rst:512
msgid ""
"A Unicode object (which may be ``NULL``) and a null-terminated C character "
"array as a second parameter (which will be used, if the first parameter is "
"``NULL``)."
msgstr ""
"Un objeto Unicode (que puede ser ``NULL``) y una matriz de caracteres C "
"terminada en cero como segundo parámetro (que se utilizará si el primer "
"parámetro es ``NULL``)."

#: ../../c-api/unicode.rst:516
msgid "``S``"
msgstr "``S``"

#: ../../c-api/unicode.rst:518
msgid "The result of calling :c:func:`PyObject_Str`."
msgstr "El resultado de llamar a :c:func:`PyObject_Str`."

#: ../../c-api/unicode.rst:520
msgid "``R``"
msgstr "``R``"

#: ../../c-api/unicode.rst:522
msgid "The result of calling :c:func:`PyObject_Repr`."
msgstr "El resultado de llamar a :c:func:`PyObject_Repr`."

#: ../../c-api/unicode.rst:524
msgid "``T``"
msgstr "``T``"

#: ../../c-api/unicode.rst:526
msgid ""
"Get the fully qualified name of an object type; call :c:func:"
"`PyType_GetFullyQualifiedName`."
msgstr ""
"Получить полное имя типа объекта; вызов :c:func:"
"`PyType_GetFullyQualifiedName`."

#: ../../c-api/unicode.rst:529
msgid "``#T``"
msgstr "``#T``"

#: ../../c-api/unicode.rst:531
msgid ""
"Similar to ``T`` format, but use a colon (``:``) as separator between the "
"module name and the qualified name."
msgstr ""
"Аналогичен формату ``T``, но в качестве разделителя между именем модуля и "
"уточненным именем используется двоеточие (``:``)."

#: ../../c-api/unicode.rst:534
msgid "``N``"
msgstr "``N``"

#: ../../c-api/unicode.rst:535 ../../c-api/unicode.rst:540
msgid ":c:expr:`PyTypeObject*`"
msgstr ":c:expr:`PyTypeObject*`"

#: ../../c-api/unicode.rst:536
msgid ""
"Get the fully qualified name of a type; call :c:func:"
"`PyType_GetFullyQualifiedName`."
msgstr ""
"Получить полное имя типа; вызов :c:func:`PyType_GetFullyQualifiedName`."

#: ../../c-api/unicode.rst:539
msgid "``#N``"
msgstr "``#N``"

#: ../../c-api/unicode.rst:541
msgid ""
"Similar to ``N`` format, but use a colon (``:``) as separator between the "
"module name and the qualified name."
msgstr ""
"Аналогичен формату ``N``, но в качестве разделителя между именем модуля и "
"уточненным именем используется двоеточие (``:``)."

#: ../../c-api/unicode.rst:545
msgid ""
"The width formatter unit is number of characters rather than bytes. The "
"precision formatter unit is number of bytes or :c:type:`wchar_t` items (if "
"the length modifier ``l`` is used) for ``\"%s\"`` and ``\"%V\"`` (if the "
"``PyObject*`` argument is ``NULL``), and a number of characters for "
"``\"%A\"``, ``\"%U\"``, ``\"%S\"``, ``\"%R\"`` and ``\"%V\"`` (if the "
"``PyObject*`` argument is not ``NULL``)."
msgstr ""
"Единицей форматирования ширины является количество символов, а не байтов. "
"Единицей форматирования точности является количество байтов или элементов :c:"
"type:`wchar_t` (если используется модификатор длины ``l``) для ``\" %s \"`` "
"и ``\"%V\"`` (если аргумент ``PyObject*`` равен ``NULL``), а также "
"количество символов для ``\" %А \"``, ``\"%U\"``, ``\"%S\"``, ``\"%R\"`` и "
"``\"%V\"`` (если аргумент ``PyObject*`` равен не ``NULL``)."

#: ../../c-api/unicode.rst:553
msgid ""
"Unlike to C :c:func:`printf` the ``0`` flag has effect even when a precision "
"is given for integer conversions (``d``, ``i``, ``u``, ``o``, ``x``, or "
"``X``)."
msgstr ""
"В отличие от C :c:func:`printf` флаг ``0`` действует, даже если для "
"целочисленных преобразований задана точность (``d``, ``i``, ``u``, `` o``, "
"``x`` или ``X``)."

#: ../../c-api/unicode.rst:557
msgid "Support for ``\"%lld\"`` and ``\"%llu\"`` added."
msgstr "Se ha añadido compatibilidad con ``\"%lld\"`` y ``\"%llu\"``."

#: ../../c-api/unicode.rst:560
msgid "Support for ``\"%li\"``, ``\"%lli\"`` and ``\"%zi\"`` added."
msgstr ""
"Se ha añadido compatibilidad con ``\"%li\"``, ``\"%lli\"`` y ``\"%zi\"``."

#: ../../c-api/unicode.rst:563
msgid ""
"Support width and precision formatter for ``\"%s\"``, ``\"%A\"``, "
"``\"%U\"``, ``\"%V\"``, ``\"%S\"``, ``\"%R\"`` added."
msgstr ""
"Formateador de ancho y precisión para ``\"%s\"``, ``\"%A\"``, ``\"%U\"``, "
"``\"%V\"``, ``\"%S\"``, ``\"%R\"`` añadido."

#: ../../c-api/unicode.rst:567
msgid ""
"Support for conversion specifiers ``o`` and ``X``. Support for length "
"modifiers ``j`` and ``t``. Length modifiers are now applied to all integer "
"conversions. Length modifier ``l`` is now applied to conversion specifiers "
"``s`` and ``V``. Support for variable width and precision ``*``. Support for "
"flag ``-``."
msgstr ""
"Поддержка спецификаторов преобразования ``o`` и ``X``. Поддержка "
"модификаторов длины ``j`` и ``t``. Модификаторы длины теперь применяются ко "
"всем целочисленным преобразованиям. Модификатор длины ``l`` теперь "
"применяется к спецификаторам преобразования ``s`` и ``V``. Поддержка "
"переменной ширины и точности ``*``. Поддержка флага ``-``."

#: ../../c-api/unicode.rst:575
msgid ""
"An unrecognized format character now sets a :exc:`SystemError`. In previous "
"versions it caused all the rest of the format string to be copied as-is to "
"the result string, and any extra arguments discarded."
msgstr ""
"Нераспознанный символ формата теперь устанавливает :exc:`SystemError`. В "
"предыдущих версиях это приводило к тому, что вся остальная часть строки "
"формата копировалась в результирующую строку как есть, а все дополнительные "
"аргументы отбрасывались."

#: ../../c-api/unicode.rst:579
msgid "Support for ``%T``, ``%#T``, ``%N`` and ``%#N`` formats added."
msgstr "Добавлена ​​поддержка форматов ``%T``, ``%#T``, ``%N`` и ``%#N``."

#: ../../c-api/unicode.rst:585
msgid ""
"Identical to :c:func:`PyUnicode_FromFormat` except that it takes exactly two "
"arguments."
msgstr ""
"Idéntico a :c:func:`PyUnicode_FromFormat` excepto que toma exactamente dos "
"argumentos."

#: ../../c-api/unicode.rst:591
msgid ""
"Copy an instance of a Unicode subtype to a new true Unicode object if "
"necessary. If *obj* is already a true Unicode object (not a subtype), return "
"a new :term:`strong reference` to the object."
msgstr ""
"При необходимости скопируйте экземпляр подтипа Юникода в новый настоящий "
"объект Юникода. Если *obj* уже является настоящим объектом Unicode (а не "
"подтипом), верните новую :term:`strong ссылку` на объект."

#: ../../c-api/unicode.rst:595
msgid ""
"Objects other than Unicode or its subtypes will cause a :exc:`TypeError`."
msgstr ""
"Los objetos que no sean Unicode o sus subtipos causarán un :exc:`TypeError`."

#: ../../c-api/unicode.rst:600
msgid "Create a Unicode Object from the given Unicode code point *ordinal*."
msgstr "Создать объект Unicode из заданной кодовой точки Unicode *order*."

#: ../../c-api/unicode.rst:602
msgid ""
"The ordinal must be in ``range(0x110000)``. A :exc:`ValueError` is raised in "
"the case it is not."
msgstr ""
"Порядковый номер должен быть в диапазоне ``range(0x110000)``. В противном "
"случае возникает :exc:`ValueError`."

#: ../../c-api/unicode.rst:609
msgid "Decode an encoded object *obj* to a Unicode object."
msgstr "Decodifica un objeto codificado *obj* a un objeto Unicode."

#: ../../c-api/unicode.rst:611
msgid ""
":class:`bytes`, :class:`bytearray` and other :term:`bytes-like objects "
"<bytes-like object>` are decoded according to the given *encoding* and using "
"the error handling defined by *errors*. Both can be ``NULL`` to have the "
"interface use the default values (see :ref:`builtincodecs` for details)."
msgstr ""
":class:`bytes` :class:`bytearray` y otros objetos :term:`bytes-like `  "
"<bytes-like object> se decodifican de acuerdo con la *codificación* dada y "
"usando el tratamiento de errores definido por *errors*. Ambos pueden ser  "
"``NULL`` para que la interfaz use los valores por defecto (ver :ref:"
"`builtincodecs` para más detalles)."

#: ../../c-api/unicode.rst:617
msgid ""
"All other objects, including Unicode objects, cause a :exc:`TypeError` to be "
"set."
msgstr ""
"Todos los demás objetos, incluidos los Unicode, hacen que se establezca un :"
"exc:`TypeError`."

#: ../../c-api/unicode.rst:620
msgid ""
"The API returns ``NULL`` if there was an error.  The caller is responsible "
"for decref'ing the returned objects."
msgstr ""
"La API devuelve ``NULL`` si se ha producido un error.  Quien llama es "
"responsable de decref'ing los objetos devueltos."

#: ../../c-api/unicode.rst:626
msgid ""
"Return a mapping suitable for decoding a custom single-byte encoding. Given "
"a Unicode string *string* of up to 256 characters representing an encoding "
"table, returns either a compact internal mapping object or a dictionary "
"mapping character ordinals to byte values. Raises a :exc:`TypeError` and "
"return ``NULL`` on invalid input. .. versionadded:: 3.2"
msgstr ""

#: ../../c-api/unicode.rst:636
msgid ""
"Return the name of the default string encoding, ``\"utf-8\"``. See :func:"
"`sys.getdefaultencoding`."
msgstr ""
"Возвращает имя кодировки строки по умолчанию, ``\"utf-8\"``. См. :func:`sys."
"getdefaultencoding`."

#: ../../c-api/unicode.rst:639
msgid ""
"The returned string does not need to be freed, and is valid until "
"interpreter shutdown."
msgstr ""
"Возвращенную строку не нужно освобождать, она действительна до завершения "
"работы интерпретатора."

#: ../../c-api/unicode.rst:645
msgid "Return the length of the Unicode object, in code points."
msgstr "Devuelve la longitud del objeto Unicode, en puntos de código."

#: ../../c-api/unicode.rst:647
msgid "On error, set an exception and return ``-1``."
msgstr "В случае ошибки установить исключение и вернуть ``-1``."

#: ../../c-api/unicode.rst:658
msgid ""
"Copy characters from one Unicode object into another.  This function "
"performs character conversion when necessary and falls back to :c:func:`!"
"memcpy` if possible.  Returns ``-1`` and sets an exception on error, "
"otherwise returns the number of copied characters."
msgstr ""
"Копирование символов из одного объекта Unicode в другой. Эта функция "
"выполняет преобразование символов, когда это необходимо, и, если возможно, "
"возвращается к :c:func:`!memcpy`. Возвращает ``-1`` и устанавливает "
"исключение в случае ошибки, в противном случае возвращает количество "
"скопированных символов."

#: ../../c-api/unicode.rst:669
msgid ""
"Fill a string with a character: write *fill_char* into ``unicode[start:"
"start+length]``."
msgstr ""
"Llena una cadena con un carácter: escribe *fill_char* en ``unicode[start:"
"start+length]``."

#: ../../c-api/unicode.rst:672
msgid ""
"Fail if *fill_char* is bigger than the string maximum character, or if the "
"string has more than 1 reference."
msgstr ""
"Fallo si *fill_char* es mayor que el carácter máximo de la cadena, o si la "
"cadena tiene más de 1 referencia."

#: ../../c-api/unicode.rst:675
msgid ""
"Return the number of written character, or return ``-1`` and raise an "
"exception on error."
msgstr ""
"Devuelve el número de caracteres escritos, o devuelve ``-1`` y lanza una "
"excepción en caso de error."

#: ../../c-api/unicode.rst:684
msgid ""
"Write a character to a string.  The string must have been created through :c:"
"func:`PyUnicode_New`.  Since Unicode strings are supposed to be immutable, "
"the string must not be shared, or have been hashed yet."
msgstr ""
"Escriba un carácter en una cadena. La cadena se debe haber creado a través "
"de :c:func:`PyUnicode_New`. Dado que se supone que las cadenas Unicode son "
"inmutables, la cadena no debe ser compartida ni haber sido hasheada todavía."

#: ../../c-api/unicode.rst:688
msgid ""
"This function checks that *unicode* is a Unicode object, that the index is "
"not out of bounds, and that the object can be modified safely (i.e. that it "
"its reference count is one)."
msgstr ""
"Esta función verifica que *unicode* sea un objeto Unicode, que el índice no "
"esté fuera de límites y que el objeto se pueda modificar de forma segura (es "
"decir, que su recuento de referencias sea uno)."

#: ../../c-api/unicode.rst:692
msgid "Return ``0`` on success, ``-1`` on error with an exception set."
msgstr ""

#: ../../c-api/unicode.rst:699
msgid ""
"Read a character from a string.  This function checks that *unicode* is a "
"Unicode object and the index is not out of bounds, in contrast to :c:func:"
"`PyUnicode_READ_CHAR`, which performs no error checking."
msgstr ""
"Считайте символ из строки. Эта функция проверяет, что *unicode* является "
"объектом Unicode и индекс не выходит за пределы, в отличие от :c:func:"
"`PyUnicode_READ_CHAR`, которая не выполняет проверку ошибок."

#: ../../c-api/unicode.rst:703
msgid "Return character on success, ``-1`` on error with an exception set."
msgstr ""
"Возвращаемый символ в случае успеха, ``-1`` в случае ошибки с установленным "
"исключением."

#: ../../c-api/unicode.rst:711
msgid ""
"Return a substring of *unicode*, from character index *start* (included) to "
"character index *end* (excluded).  Negative indices are not supported. On "
"error, set an exception and return ``NULL``."
msgstr ""
"Возвращает подстроку *unicode* от индекса символов *start* (включено) до "
"индекса символов *end* (исключено). Отрицательные индексы не поддерживаются. "
"В случае ошибки установить исключение и вернуть ``NULL``."

#: ../../c-api/unicode.rst:721
msgid ""
"Copy the string *unicode* into a UCS4 buffer, including a null character, if "
"*copy_null* is set.  Returns ``NULL`` and sets an exception on error (in "
"particular, a :exc:`SystemError` if *buflen* is smaller than the length of "
"*unicode*).  *buffer* is returned on success."
msgstr ""
"Скопируйте строку *unicode* в буфер UCS4, включая нулевой символ, если "
"установлено *copy_null*. Возвращает ``NULL`` и устанавливает исключение в "
"случае ошибки (в частности, :exc:`SystemError`, если *buflen* меньше длины "
"*unicode*). *buffer* возвращается в случае успеха."

#: ../../c-api/unicode.rst:731
msgid ""
"Copy the string *unicode* into a new UCS4 buffer that is allocated using :c:"
"func:`PyMem_Malloc`.  If this fails, ``NULL`` is returned with a :exc:"
"`MemoryError` set.  The returned buffer always has an extra null code point "
"appended."
msgstr ""
"Скопируйте строку *unicode* в новый буфер UCS4, выделенный с помощью :c:func:"
"`PyMem_Malloc`. Если это не удается, возвращается ``NULL`` с установленным :"
"exc:`MemoryError`. К возвращенному буферу всегда добавляется дополнительная "
"нулевая кодовая точка."

#: ../../c-api/unicode.rst:740
msgid "Locale Encoding"
msgstr "Codificación local"

#: ../../c-api/unicode.rst:742
msgid ""
"The current locale encoding can be used to decode text from the operating "
"system."
msgstr ""
"La codificación local actual se puede utilizar para decodificar texto del "
"sistema operativo."

#: ../../c-api/unicode.rst:749
msgid ""
"Decode a string from UTF-8 on Android and VxWorks, or from the current "
"locale encoding on other platforms. The supported error handlers are "
"``\"strict\"`` and ``\"surrogateescape\"`` (:pep:`383`). The decoder uses "
"``\"strict\"`` error handler if *errors* is ``NULL``.  *str* must end with a "
"null character but cannot contain embedded null characters."
msgstr ""
"Decodifica una cadena desde UTF-8 en Android y VxWorks, o desde la "
"codificación local actual en otras plataformas. Los manejadores de error "
"soportados son ``\"strict\"`` y ``\"surrogateescape\"`` (:pep:`383`). El "
"descodificador utiliza el gestor de errores ``\"strict\"`` si *errors* es "
"``NULL``.  *str* debe terminar con un carácter nulo pero no puede contener "
"caracteres nulos incrustados."

#: ../../c-api/unicode.rst:756
msgid ""
"Use :c:func:`PyUnicode_DecodeFSDefaultAndSize` to decode a string from the :"
"term:`filesystem encoding and error handler`."
msgstr ""
"Используйте :c:func:`PyUnicode_DecodeFSDefaultAndSize` для декодирования "
"строки из :term:`кодирования файловой системы и обработчика ошибок`."

#: ../../c-api/unicode.rst:759 ../../c-api/unicode.rst:794
msgid "This function ignores the :ref:`Python UTF-8 Mode <utf8-mode>`."
msgstr "Ця функція ігнорує :ref:`Режим Python UTF-8 <utf8-mode>`."

#: ../../c-api/unicode.rst:763 ../../c-api/unicode.rst:879
msgid "The :c:func:`Py_DecodeLocale` function."
msgstr "La función :c:func:`Py_DecodeLocale`."

#: ../../c-api/unicode.rst:767
msgid ""
"The function now also uses the current locale encoding for the "
"``surrogateescape`` error handler, except on Android. Previously, :c:func:"
"`Py_DecodeLocale` was used for the ``surrogateescape``, and the current "
"locale encoding was used for ``strict``."
msgstr ""
"La función ahora también utiliza la codificación de la configuración "
"regional actual para el gestor de errores ``surrogateescape``, excepto en "
"Android. Anteriormente, se utilizaba :c:func:`Py_DecodeLocale` para "
"``surrogateescape``, y la codificación regional actual para ``strict``."

#: ../../c-api/unicode.rst:776
msgid ""
"Similar to :c:func:`PyUnicode_DecodeLocaleAndSize`, but compute the string "
"length using :c:func:`!strlen`."
msgstr ""
"Аналогично :c:func:`PyUnicode_DecodeLocaleAndSize`, но длину строки "
"вычислите, используя :c:func:`!strlen`."

#: ../../c-api/unicode.rst:784
msgid ""
"Encode a Unicode object to UTF-8 on Android and VxWorks, or to the current "
"locale encoding on other platforms. The supported error handlers are "
"``\"strict\"`` and ``\"surrogateescape\"`` (:pep:`383`). The encoder uses "
"``\"strict\"`` error handler if *errors* is ``NULL``. Return a :class:"
"`bytes` object. *unicode* cannot contain embedded null characters."
msgstr ""
"Codifica un objeto Unicode a UTF-8 en Android y VxWorks, o a la codificación "
"regional actual en otras plataformas. Los manejadores de error soportados "
"son ``\"strict\"`` y ``\"surrogateescape\"`` (:pep:`383`). El codificador "
"utiliza el gestor de errores ``\"strict\"`` si *errors* es ``NULL``. "
"Devuelve un objeto :class:`bytes`. *unicode* no puede contener caracteres "
"nulos incrustados."

#: ../../c-api/unicode.rst:791
msgid ""
"Use :c:func:`PyUnicode_EncodeFSDefault` to encode a string to the :term:"
"`filesystem encoding and error handler`."
msgstr ""
"Используйте :c:func:`PyUnicode_EncodeFSDefault` для кодирования строки в :"
"term:`кодирование файловой системы и обработчик ошибок`."

#: ../../c-api/unicode.rst:798 ../../c-api/unicode.rst:910
msgid "The :c:func:`Py_EncodeLocale` function."
msgstr "La función :c:func:`Py_EncodeLocale`."

#: ../../c-api/unicode.rst:802
msgid ""
"The function now also uses the current locale encoding for the "
"``surrogateescape`` error handler, except on Android. Previously, :c:func:"
"`Py_EncodeLocale` was used for the ``surrogateescape``, and the current "
"locale encoding was used for ``strict``."
msgstr ""
"La función ahora también utiliza la codificación de la configuración "
"regional actual para el gestor de errores ``surrogateescape``, excepto en "
"Android. Anteriormente, se utilizaba :c:func:`Py_EncodeLocale` para "
"``surrogateescape``, y la codificación regional actual para ``strict``."

#: ../../c-api/unicode.rst:811
msgid "File System Encoding"
msgstr "Sistema de codificación de archivos"

#: ../../c-api/unicode.rst:813
msgid ""
"Functions encoding to and decoding from the :term:`filesystem encoding and "
"error handler` (:pep:`383` and :pep:`529`)."
msgstr ""
"Функции кодирования и декодирования из :term:`кодирования файловой системы и "
"обработчика ошибок` (:pep:`383` и :pep:`529`)."

#: ../../c-api/unicode.rst:816
msgid ""
"To encode file names to :class:`bytes` during argument parsing, the "
"``\"O&\"`` converter should be used, passing :c:func:`!"
"PyUnicode_FSConverter` as the conversion function:"
msgstr ""
"Чтобы закодировать имена файлов в :class:`bytes` во время разбора "
"аргументов, следует использовать конвертер ``\"O&\"``, передав :c:func:`!"
"PyUnicode_FSConverter` в качестве функции преобразования:"

#: ../../c-api/unicode.rst:822
msgid ""
":ref:`PyArg_Parse\\* converter <arg-parsing>`: encode :class:`str` objects "
"-- obtained directly or through the :class:`os.PathLike` interface -- to :"
"class:`bytes` using :c:func:`PyUnicode_EncodeFSDefault`; :class:`bytes` "
"objects are output as-is. *result* must be an address of a C variable of "
"type :c:expr:`PyObject*` (or :c:expr:`PyBytesObject*`). On success, set the "
"variable to a new :term:`strong reference` to a :ref:`bytes object "
"<bytesobjects>` which must be released when it is no longer used and return "
"a non-zero value (:c:macro:`Py_CLEANUP_SUPPORTED`). Embedded null bytes are "
"not allowed in the result. On failure, return ``0`` with an exception set."
msgstr ""
": ref: `pyarg_parse \\* converter <gard-parsing>`: encode: class: `str` "
"objects-получено напрямую или через: класс:` os.pathlike` interface-to: "
"class: `bytes` с использованием: C: Func: `pyunicode_encodefsdefault`; : "
"class: `bytes 'объекты выводятся как есть. *Результат*Должен быть адрес с "
"переменной C типа: C: expr: `pyobject*` (или: c: expr: `pybytesobject*`). "
"При успехе установите переменную на новый термин: `‘ Сильная ссылка на: ref: "
"`` object <bytesobjects> `, которые должны быть выпущены, когда она больше "
"не используется, и вернуть ненулевое значение (: c: macro : "
"`Py_cleanup_supported`). Встроенные нулевые байты не допускаются в "
"результате. При сбое верните `` 0`` с набором исключений."

#: ../../c-api/unicode.rst:834
msgid ""
"If *obj* is ``NULL``, the function releases a strong reference stored in the "
"variable referred by *result* and returns ``1``."
msgstr ""
"Если *obj* равен ``NULL``, функция освобождает сильную ссылку, хранящуюся в "
"переменной, на которую ссылается *result*, и возвращает ``1``."

#: ../../c-api/unicode.rst:839 ../../c-api/unicode.rst:866
msgid "Accepts a :term:`path-like object`."
msgstr "Acepta un ::term:`path-like object`."

#: ../../c-api/unicode.rst:842
msgid ""
"To decode file names to :class:`str` during argument parsing, the ``\"O&\"`` "
"converter should be used, passing :c:func:`!PyUnicode_FSDecoder` as the "
"conversion function:"
msgstr ""
"Для декодирования имен файлов в :class:`str` во время разбора аргументов "
"следует использовать конвертер ``\"O&\"``, передав :c:func:`!"
"PyUnicode_FSDecoder` в качестве функции преобразования:"

#: ../../c-api/unicode.rst:848
msgid ""
":ref:`PyArg_Parse\\* converter <arg-parsing>`: decode :class:`bytes` objects "
"-- obtained either directly or indirectly through the :class:`os.PathLike` "
"interface -- to :class:`str` using :c:func:"
"`PyUnicode_DecodeFSDefaultAndSize`; :class:`str` objects are output as-is. "
"*result* must be an address of a C variable of type :c:expr:`PyObject*` (or :"
"c:expr:`PyUnicodeObject*`). On success, set the variable to a new :term:"
"`strong reference` to a :ref:`Unicode object <unicodeobjects>` which must be "
"released when it is no longer used and return a non-zero value (:c:macro:"
"`Py_CLEANUP_SUPPORTED`). Embedded null characters are not allowed in the "
"result. On failure, return ``0`` with an exception set."
msgstr ""
": ref: `pyarg_parse \\* converter <gard-parsing>`: decode: class: `bytes` "
"объекты-получены прямо или косвенно через: класс:` os.pathlike` interface-"
"to: class: `str` Использование: C: Func: "
"`pyunicode_decodefsdefaultAndsize`; : class: `str`-объекты выводятся как "
"есть. *Результат*Должен быть адрес с переменной C типа: C: expr: `pyobject*` "
"(или: c: expr: `pyunicodeobject*`). При успехе установите переменную на "
"новую: термин: `сильная ссылка на A: ref:` unicode Object <UnicodeObjects> "
"`, которые должны быть опубликованы, когда оно больше не используется, и "
"вернуть ненулевое значение (: c: macro : `Py_cleanup_supported`). Встроенные "
"нулевые символы не допускаются в результате. При сбое верните `` 0`` с "
"набором исключений."

#: ../../c-api/unicode.rst:861
msgid ""
"If *obj* is ``NULL``, release the strong reference to the object referred to "
"by *result* and return ``1``."
msgstr ""
"Если *obj* равен ``NULL``, освободить сильную ссылку на объект, на который "
"ссылается *result*, и вернуть ``1``."

#: ../../c-api/unicode.rst:872
msgid "Decode a string from the :term:`filesystem encoding and error handler`."
msgstr "Декодуйте рядок із :term:`filesystem encoding and error handler`."

#: ../../c-api/unicode.rst:874
msgid ""
"If you need to decode a string from the current locale encoding, use :c:func:"
"`PyUnicode_DecodeLocaleAndSize`."
msgstr ""
"Если вам нужно декодировать строку из текущей кодировки локали, используйте :"
"c:func:`PyUnicode_DecodeLocaleAndSize`."

#: ../../c-api/unicode.rst:881 ../../c-api/unicode.rst:894
#: ../../c-api/unicode.rst:914
msgid ""
"The :term:`filesystem error handler <filesystem encoding and error handler>` "
"is now used."
msgstr ""
"Теперь используется :term:`обработчик ошибок файловой системы <кодировка "
"файловой системы и обработчик ошибок>`."

#: ../../c-api/unicode.rst:888
msgid ""
"Decode a null-terminated string from the :term:`filesystem encoding and "
"error handler`."
msgstr ""
"Декодуйте рядок із нульовим закінченням із :term:`filesystem encoding and "
"error handler`."

#: ../../c-api/unicode.rst:891
msgid ""
"If the string length is known, use :c:func:"
"`PyUnicode_DecodeFSDefaultAndSize`."
msgstr ""
"Если длина строки известна, используйте :c:func:"
"`PyUnicode_DecodeFSDefaultAndSize`."

#: ../../c-api/unicode.rst:901
msgid ""
"Encode a Unicode object to the :term:`filesystem encoding and error "
"handler`, and return :class:`bytes`. Note that the resulting :class:`bytes` "
"object can contain null bytes."
msgstr ""
"Закодируйте объект Unicode в :term:`кодирование файловой системы и "
"обработчик ошибок` и верните :class:`bytes`. Обратите внимание, что "
"результирующий объект :class:`bytes` может содержать нулевые байты."

#: ../../c-api/unicode.rst:905
msgid ""
"If you need to encode a string to the current locale encoding, use :c:func:"
"`PyUnicode_EncodeLocale`."
msgstr ""
"Если вам нужно закодировать строку в кодировку текущей локали, используйте :"
"c:func:`PyUnicode_EncodeLocale`."

#: ../../c-api/unicode.rst:919
msgid "wchar_t Support"
msgstr "wchar_t Support"

#: ../../c-api/unicode.rst:921
msgid ":c:type:`wchar_t` support for platforms which support it:"
msgstr ":c:type:`wchar_t` підтримка платформ, які її підтримують:"

#: ../../c-api/unicode.rst:925
msgid ""
"Create a Unicode object from the :c:type:`wchar_t` buffer *wstr* of the "
"given *size*. Passing ``-1`` as the *size* indicates that the function must "
"itself compute the length, using :c:func:`!wcslen`. Return ``NULL`` on "
"failure."
msgstr ""
"Создайте объект Unicode из буфера :c:type:`wchar_t` *wstr* заданного "
"*размера*. Передача ``-1`` в качестве *size* указывает, что функция должна "
"сама вычислить длину, используя :c:func:`!wcslen`. Возвращайте ``NULL`` в "
"случае неудачи."

#: ../../c-api/unicode.rst:933
msgid ""
"Copy the Unicode object contents into the :c:type:`wchar_t` buffer *wstr*.  "
"At most *size* :c:type:`wchar_t` characters are copied (excluding a possibly "
"trailing null termination character).  Return the number of :c:type:"
"`wchar_t` characters copied or ``-1`` in case of an error."
msgstr ""
"Скопируйте содержимое объекта Unicode в буфер :c:type:`wchar_t` *wstr*. "
"Копируется не более символов *size* :c:type:`wchar_t` (исключая, возможно, "
"завершающий нулевой символ завершения). Возвращает количество скопированных "
"символов :c:type:`wchar_t` или ``-1`` в случае ошибки."

#: ../../c-api/unicode.rst:938
msgid ""
"When *wstr* is ``NULL``, instead return the *size* that would be required to "
"store all of *unicode* including a terminating null."
msgstr ""
"Если *wstr* имеет значение ``NULL``, вместо этого возвращайте *size*, "
"который потребуется для хранения всего *unicode*, включая завершающий нуль."

#: ../../c-api/unicode.rst:941
msgid ""
"Note that the resulting :c:expr:`wchar_t*` string may or may not be null-"
"terminated.  It is the responsibility of the caller to make sure that the :c:"
"expr:`wchar_t*` string is null-terminated in case this is required by the "
"application. Also, note that the :c:expr:`wchar_t*` string might contain "
"null characters, which would cause the string to be truncated when used with "
"most C functions."
msgstr ""
"Обратите внимание, что результирующая строка :c:expr:`wchar_t*` может "
"заканчиваться нулем, а может и не заканчиваться. Вызывающая сторона несет "
"ответственность за то, чтобы строка :c:expr:`wchar_t*` завершалась нулем, "
"если это требуется приложению. Также обратите внимание, что строка :c:expr:"
"`wchar_t*` может содержать нулевые символы, что приведет к усечению строки "
"при использовании с большинством функций C."

#: ../../c-api/unicode.rst:951
msgid ""
"Convert the Unicode object to a wide character string. The output string "
"always ends with a null character. If *size* is not ``NULL``, write the "
"number of wide characters (excluding the trailing null termination "
"character) into *\\*size*. Note that the resulting :c:type:`wchar_t` string "
"might contain null characters, which would cause the string to be truncated "
"when used with most C functions. If *size* is ``NULL`` and the :c:expr:"
"`wchar_t*` string contains null characters a :exc:`ValueError` is raised."
msgstr ""
"Преобразуйте объект Unicode в строку широких символов. Выходная строка "
"всегда заканчивается нулевым символом. Если *size* не равно ``NULL``, "
"запишите количество широких символов (исключая завершающий нулевой символ "
"завершения) в *\\*size*. Обратите внимание, что результирующая строка :c:"
"type:`wchar_t` может содержать нулевые символы, что приведет к усечению "
"строки при использовании с большинством функций C. Если *size* имеет "
"значение ``NULL`` и строка :c:expr:`wchar_t*` содержит нулевые символы, "
"возникает :exc:`ValueError`."

#: ../../c-api/unicode.rst:959
msgid ""
"Returns a buffer allocated by :c:macro:`PyMem_New` (use :c:func:`PyMem_Free` "
"to free it) on success. On error, returns ``NULL`` and *\\*size* is "
"undefined. Raises a :exc:`MemoryError` if memory allocation is failed."
msgstr ""
"Возвращает буфер, выделенный :c:macro:`PyMem_New` (используйте :c:func:"
"`PyMem_Free`, чтобы освободить его) в случае успеха. В случае ошибки "
"возвращается ``NULL`` и *\\*size* не определен. Вызывает :exc:`MemoryError`, "
"если выделение памяти не удалось."

#: ../../c-api/unicode.rst:966
msgid ""
"Raises a :exc:`ValueError` if *size* is ``NULL`` and the :c:expr:`wchar_t*` "
"string contains null characters."
msgstr ""
"Вызывает ошибку :exc:`ValueError`, если *size* имеет значение ``NULL`` и "
"строка :c:expr:`wchar_t*` содержит нулевые символы."

#: ../../c-api/unicode.rst:974
msgid "Built-in Codecs"
msgstr "Codecs integrados"

#: ../../c-api/unicode.rst:976
msgid ""
"Python provides a set of built-in codecs which are written in C for speed. "
"All of these codecs are directly usable via the following functions."
msgstr ""
"Python proporciona un conjunto de códecs integrados que están escritos en C "
"para mayor velocidad. Todos estos códecs son directamente utilizables a "
"través de las siguientes funciones."

#: ../../c-api/unicode.rst:979
msgid ""
"Many of the following APIs take two arguments encoding and errors, and they "
"have the same semantics as the ones of the built-in :func:`str` string "
"object constructor."
msgstr ""
"Muchas de las siguientes APIs toman dos argumentos encoding y errors, y "
"tienen la misma semántica que las del constructor de objetos de cadena :func:"
"`str` incorporado."

#: ../../c-api/unicode.rst:983
msgid ""
"Setting encoding to ``NULL`` causes the default encoding to be used which is "
"UTF-8.  The file system calls should use :c:func:`PyUnicode_FSConverter` for "
"encoding file names. This uses the :term:`filesystem encoding and error "
"handler` internally."
msgstr ""
"Установка для кодировки значения ``NULL`` приводит к использованию кодировки "
"по умолчанию - UTF-8. Вызовы файловой системы должны использовать :c:func:"
"`PyUnicode_FSConverter` для кодирования имен файлов. При этом используется "
"внутренняя кодировка файловой системы и обработчик ошибок."

#: ../../c-api/unicode.rst:988
msgid ""
"Error handling is set by errors which may also be set to ``NULL`` meaning to "
"use the default handling defined for the codec.  Default error handling for "
"all built-in codecs is \"strict\" (:exc:`ValueError` is raised)."
msgstr ""
"El manejo de errores se establece mediante errores que también pueden "
"establecerse como ``NULL``, lo que significa usar el manejo predeterminado "
"definido para el códec. El manejo de errores predeterminado para todos los "
"códecs incorporados es \"estricto\" (se genera :exc:`ValueError`)."

#: ../../c-api/unicode.rst:992
msgid ""
"The codecs all use a similar interface.  Only deviations from the following "
"generic ones are documented for simplicity."
msgstr ""
"Los codecs utilizan todos una interfaz similar. Solo se documentan las "
"desviaciones de las siguientes genéricas por simplicidad."

#: ../../c-api/unicode.rst:997
msgid "Generic Codecs"
msgstr "Códecs genéricos"

#: ../../c-api/unicode.rst:999
msgid "These are the generic codec APIs:"
msgstr "Estas son las API genéricas de los códecs:"

#: ../../c-api/unicode.rst:1005
msgid ""
"Create a Unicode object by decoding *size* bytes of the encoded string "
"*str*. *encoding* and *errors* have the same meaning as the parameters of "
"the same name in the :func:`str` built-in function.  The codec to be used is "
"looked up using the Python codec registry.  Return ``NULL`` if an exception "
"was raised by the codec."
msgstr ""
"Создайте объект Unicode, декодировав *size* байты закодированной строки "
"*str*. *encoding* и *errors* имеют то же значение, что и одноименные "
"параметры во встроенной функции :func:`str`. Кодек, который будет "
"использоваться, ищется в реестре кодеков Python. Верните NULL, если кодек "
"вызвал исключение."

#: ../../c-api/unicode.rst:1015
msgid ""
"Encode a Unicode object and return the result as Python bytes object. "
"*encoding* and *errors* have the same meaning as the parameters of the same "
"name in the Unicode :meth:`~str.encode` method. The codec to be used is "
"looked up using the Python codec registry. Return ``NULL`` if an exception "
"was raised by the codec."
msgstr ""
"Codifica un objeto Unicode y devuelve el resultado como un objeto bytes de "
"Python. *encoding* y *errors* tienen el mismo significado que los parámetros "
"del mismo nombre en el método :meth:`~str.encode` de Unicode. El códec a "
"utilizar se busca en el registro de códecs de Python. Devuelve ``NULL`` si "
"se produjo una excepción en el códec."

#: ../../c-api/unicode.rst:1023
msgid "UTF-8 Codecs"
msgstr "Códecs UTF-8"

#: ../../c-api/unicode.rst:1025
msgid "These are the UTF-8 codec APIs:"
msgstr "Estas son las API de códecs UTF-8:"

#: ../../c-api/unicode.rst:1030
msgid ""
"Create a Unicode object by decoding *size* bytes of the UTF-8 encoded string "
"*str*. Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"Создайте объект Unicode, декодировав *size* байты строки *str* в кодировке "
"UTF-8. Верните NULL, если кодек вызвал исключение."

#: ../../c-api/unicode.rst:1037
msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeUTF8`. If "
"*consumed* is not ``NULL``, trailing incomplete UTF-8 byte sequences will "
"not be treated as an error. Those bytes will not be decoded and the number "
"of bytes that have been decoded will be stored in *consumed*."
msgstr ""
"Si *consumed* es ``NULL``, comportarse como :c:func:`PyUnicode_DecodeUTF8`. "
"Si *consumed* no es ``NULL``, las secuencias de bytes UTF-8 incompletas al "
"final no se tratarán como un error. Esos bytes no se decodificarán y el "
"número de bytes que se han decodificado se almacenará en *consumed*."

#: ../../c-api/unicode.rst:1045
msgid ""
"Encode a Unicode object using UTF-8 and return the result as Python bytes "
"object.  Error handling is \"strict\".  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""
"Codifica un objeto Unicode utilizando UTF-8 y devuelve el resultado como un "
"objeto de bytes de Python. El manejo de errores es \"estricto\". Devuelve "
"``NULL`` si se produjo una excepción por parte del códec."

#: ../../c-api/unicode.rst:1049 ../../c-api/unicode.rst:1064
msgid ""
"The function fails if the string contains surrogate code points (``U+D800`` "
"- ``U+DFFF``)."
msgstr ""
"Функция завершается ошибкой, если строка содержит суррогатные кодовые точки "
"(``U+D800`` - ``U+DFFF``)."

#: ../../c-api/unicode.rst:1055
msgid ""
"Return a pointer to the UTF-8 encoding of the Unicode object, and store the "
"size of the encoded representation (in bytes) in *size*.  The *size* "
"argument can be ``NULL``; in this case no size will be stored.  The returned "
"buffer always has an extra null byte appended (not included in *size*), "
"regardless of whether there are any other null code points."
msgstr ""
"Devuelve un puntero a la codificación UTF-8 del objeto Unicode y almacena el "
"tamaño de la representación codificada (en bytes) en *size*. El argumento "
"*size* puede ser ``NULL``; en este caso no se almacenará ningún tamaño. El "
"búfer devuelto siempre tiene un byte nulo adicional al final (no incluido en "
"*size*), independientemente de si hay otros puntos de código nulos."

#: ../../c-api/unicode.rst:1061
msgid ""
"On error, set an exception, set *size* to ``-1`` (if it's not NULL) and "
"return ``NULL``."
msgstr ""
"В случае ошибки установите исключение, установите для *size* значение ``-1`` "
"(если оно не NULL) и верните ``NULL``."

#: ../../c-api/unicode.rst:1067
msgid ""
"This caches the UTF-8 representation of the string in the Unicode object, "
"and subsequent calls will return a pointer to the same buffer.  The caller "
"is not responsible for deallocating the buffer. The buffer is deallocated "
"and pointers to it become invalid when the Unicode object is garbage "
"collected."
msgstr ""
"Esto almacena en caché la representación UTF-8 de la cadena en el objeto "
"Unicode, y las llamadas posteriores devolverán un puntero al mismo búfer.  "
"La persona que realiza la llamada no es responsable de desasignar el búfer. "
"El búfer se desasigna y los punteros al mismo pierden su validez cuando el "
"objeto Unicode es recolectado."

#: ../../c-api/unicode.rst:1074 ../../c-api/unicode.rst:1096
msgid "The return type is now ``const char *`` rather of ``char *``."
msgstr "El tipo de retorno es ahora ``const char *`` en lugar de ``char *``."

#: ../../c-api/unicode.rst:1077
msgid "This function is a part of the :ref:`limited API <limited-c-api>`."
msgstr "Эта функция является частью :ref:`limited API <limited-c-api>`."

#: ../../c-api/unicode.rst:1083
msgid "As :c:func:`PyUnicode_AsUTF8AndSize`, but does not store the size."
msgstr "Como :c:func:`PyUnicode_AsUTF8AndSize`, pero no almacena el tamaño."

#: ../../c-api/unicode.rst:1087
msgid ""
"This function does not have any special behavior for `null characters "
"<https://en.wikipedia.org/wiki/Null_character>`_ embedded within *unicode*. "
"As a result, strings containing null characters will remain in the returned "
"string, which some C functions might interpret as the end of the string, "
"leading to truncation. If truncation is an issue, it is recommended to use :"
"c:func:`PyUnicode_AsUTF8AndSize` instead."
msgstr ""
"Эта функция не имеет особого поведения для `нулевых символов <https://en."
"wikipedia.org/wiki/null_character>` _ встроено в *Unicode *. В результате "
"строки, содержащие нулевые символы, останутся в возвращенной строке, которую "
"некоторые функции C могут интерпретировать как конец строки, что приведет к "
"усечению. Если усечение является проблемой, рекомендуется использовать: C: "
"Func: `pyunicode_asutf8 и размер"

#: ../../c-api/unicode.rst:1101
msgid "UTF-32 Codecs"
msgstr "Códecs UTF-32"

#: ../../c-api/unicode.rst:1103
msgid "These are the UTF-32 codec APIs:"
msgstr "Estas son las API de códecs UTF-32:"

#: ../../c-api/unicode.rst:1109
msgid ""
"Decode *size* bytes from a UTF-32 encoded buffer string and return the "
"corresponding Unicode object.  *errors* (if non-``NULL``) defines the error "
"handling. It defaults to \"strict\"."
msgstr ""
"Decodifica *size* de bytes de una cadena de búfer codificada en UTF-32 y "
"devuelve el objeto Unicode correspondiente.  *errors* (si no es``NULL``) "
"define el tratamiento de errores. Por defecto es \"strict\"."

#: ../../c-api/unicode.rst:1113 ../../c-api/unicode.rst:1163
msgid ""
"If *byteorder* is non-``NULL``, the decoder starts decoding using the given "
"byte order::"
msgstr ""
"Si *byteorder* no es``NULL``, el descodificador empieza a descodificar "
"utilizando el orden de bytes dado::"

#: ../../c-api/unicode.rst:1116 ../../c-api/unicode.rst:1166
msgid ""
"*byteorder == -1: little endian\n"
"*byteorder == 0:  native order\n"
"*byteorder == 1:  big endian"
msgstr ""
"*byteorder == -1: little endian\n"
"*byteorder == 0:  native order\n"
"*byteorder == 1:  big endian"

#: ../../c-api/unicode.rst:1120
msgid ""
"If ``*byteorder`` is zero, and the first four bytes of the input data are a "
"byte order mark (BOM), the decoder switches to this byte order and the BOM "
"is not copied into the resulting Unicode string.  If ``*byteorder`` is "
"``-1`` or ``1``, any byte order mark is copied to the output."
msgstr ""
"Si ``*byteorder`` es cero, y los cuatro primeros bytes de los datos de "
"entrada son una marca de orden de bytes (BOM), el descodificador cambia a "
"este orden de bytes y la BOM no se copia en la cadena Unicode resultante.  "
"Si ``*byteorder`` es ``-1`` o ``1``, cualquier marca de orden de bytes se "
"copia en la salida."

#: ../../c-api/unicode.rst:1125
msgid ""
"After completion, *\\*byteorder* is set to the current byte order at the end "
"of input data."
msgstr ""
"Tras la finalización, *\\*byteorder* se establece en el orden actual de "
"bytes al final de los datos de entrada."

#: ../../c-api/unicode.rst:1128 ../../c-api/unicode.rst:1179
msgid "If *byteorder* is ``NULL``, the codec starts in native order mode."
msgstr ""
"Si *byteorder* es ``NULL``, el códec se inicia en modo de orden nativo."

#: ../../c-api/unicode.rst:1130 ../../c-api/unicode.rst:1181
msgid "Return ``NULL`` if an exception was raised by the codec."
msgstr "Devuelve ``NULL`` si el códec ha lanzado una excepción."

#: ../../c-api/unicode.rst:1136
msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeUTF32`. If "
"*consumed* is not ``NULL``, :c:func:`PyUnicode_DecodeUTF32Stateful` will not "
"treat trailing incomplete UTF-32 byte sequences (such as a number of bytes "
"not divisible by four) as an error. Those bytes will not be decoded and the "
"number of bytes that have been decoded will be stored in *consumed*."
msgstr ""
"Si *consumed* es ``NULL``, se comportará como :c:func:"
"`PyUnicode_DecodeUTF32`. Si *consumed* no es ``NULL``, :c:func:"
"`PyUnicode_DecodeUTF32Stateful` no tratará las secuencias de bytes UTF-32 "
"incompletas (como un número de bytes no divisible por cuatro) como un error. "
"Esos bytes no serán decodificados y el número de bytes que han sido "
"decodificados será almacenado en *consumed*."

#: ../../c-api/unicode.rst:1145
msgid ""
"Return a Python byte string using the UTF-32 encoding in native byte order. "
"The string always starts with a BOM mark.  Error handling is \"strict\". "
"Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"Devuelve una cadena de bytes Python utilizando la codificación UTF-32 en "
"orden nativo de bytes. La cadena siempre comienza con una marca BOM.  El "
"tratamiento de errores es \"estricto\". Devuelve ``NULL`` si el códec ha "
"lanzado una excepción."

#: ../../c-api/unicode.rst:1151
msgid "UTF-16 Codecs"
msgstr "Códecs UTF-16"

#: ../../c-api/unicode.rst:1153
msgid "These are the UTF-16 codec APIs:"
msgstr "Estas son las APIs de codec UTF-16."

#: ../../c-api/unicode.rst:1159
msgid ""
"Decode *size* bytes from a UTF-16 encoded buffer string and return the "
"corresponding Unicode object.  *errors* (if non-``NULL``) defines the error "
"handling. It defaults to \"strict\"."
msgstr ""
"Decodifica *size* de bytes de una cadena de búfer codificada en UTF-16 y "
"devuelve el objeto Unicode correspondiente.  *errors* (si no es``NULL``) "
"define el tratamiento de errores. Por defecto es \"strict\"."

#: ../../c-api/unicode.rst:1170
msgid ""
"If ``*byteorder`` is zero, and the first two bytes of the input data are a "
"byte order mark (BOM), the decoder switches to this byte order and the BOM "
"is not copied into the resulting Unicode string.  If ``*byteorder`` is "
"``-1`` or ``1``, any byte order mark is copied to the output (where it will "
"result in either a ``\\ufeff`` or a ``\\ufffe`` character)."
msgstr ""
"Si ``*byteorder`` es cero, y los dos primeros bytes de los datos de entrada "
"son una marca de orden de bytes (BOM), el descodificador cambia a este orden "
"de bytes y la BOM no se copia en la cadena Unicode resultante.  Si "
"``*byteorder`` es ``-1`` o ``1``, cualquier marca de orden de bytes se copia "
"a la salida (donde dará como resultado un carácter ``\\ufeff`` o "
"``\\ufffe`` )."

#: ../../c-api/unicode.rst:1176
msgid ""
"After completion, ``*byteorder`` is set to the current byte order at the end "
"of input data."
msgstr ""
"Tras la finalización, ``*byteorder`` se establece en el orden actual de "
"bytes al final de los datos de entrada."

#: ../../c-api/unicode.rst:1187
msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeUTF16`. If "
"*consumed* is not ``NULL``, :c:func:`PyUnicode_DecodeUTF16Stateful` will not "
"treat trailing incomplete UTF-16 byte sequences (such as an odd number of "
"bytes or a split surrogate pair) as an error. Those bytes will not be "
"decoded and the number of bytes that have been decoded will be stored in "
"*consumed*."
msgstr ""
"Si *consumed* es ``NULL``, se comporta como :c:func:`PyUnicode_DecodeUTF16`. "
"Si *consumed* no es ``NULL``, :c:func:`PyUnicode_DecodeUTF16Stateful` no "
"tratará las secuencias de bytes UTF-16 incompletas (como un número impar de "
"bytes o un par de sustitutos dividido) como un error. Esos bytes no serán "
"decodificados y el número de bytes que han sido decodificados será "
"almacenado en *consumed*."

#: ../../c-api/unicode.rst:1196
msgid ""
"Return a Python byte string using the UTF-16 encoding in native byte order. "
"The string always starts with a BOM mark.  Error handling is \"strict\". "
"Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"Devuelve una cadena de bytes Python utilizando la codificación UTF-16 en "
"orden nativo de bytes. La cadena siempre comienza con una marca BOM.  El "
"tratamiento de errores es \"estricto\". Devuelve ``NULL`` si el códec ha "
"lanzado una excepción."

#: ../../c-api/unicode.rst:1202
msgid "UTF-7 Codecs"
msgstr "Códecs UTF-7"

#: ../../c-api/unicode.rst:1204
msgid "These are the UTF-7 codec APIs:"
msgstr "Estas son las APIs del códec UTF-7."

#: ../../c-api/unicode.rst:1209
msgid ""
"Create a Unicode object by decoding *size* bytes of the UTF-7 encoded string "
"*str*.  Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"Создайте объект Unicode, декодировав *size* байты строки *str* в кодировке "
"UTF-7. Верните NULL, если кодек вызвал исключение."

#: ../../c-api/unicode.rst:1216
msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeUTF7`.  If "
"*consumed* is not ``NULL``, trailing incomplete UTF-7 base-64 sections will "
"not be treated as an error.  Those bytes will not be decoded and the number "
"of bytes that have been decoded will be stored in *consumed*."
msgstr ""
"Si *consumed* es ``NULL``, se comportar como :c:func:`PyUnicode_DecodeUTF7`. "
"Si *consumed* no es ``NULL``, las secciones incompletas de base-64 UTF-7 al "
"final no se tratarán como un error. Esos bytes no se decodificarán y el "
"número de bytes que se han decodificado se almacenará en *consumed*."

#: ../../c-api/unicode.rst:1223
msgid "Unicode-Escape Codecs"
msgstr "Unicode-Escape Codecs"

#: ../../c-api/unicode.rst:1225
msgid "These are the \"Unicode Escape\" codec APIs:"
msgstr "Estas son las API del códec \"Unicode Escape\":"

#: ../../c-api/unicode.rst:1231
msgid ""
"Create a Unicode object by decoding *size* bytes of the Unicode-Escape "
"encoded string *str*.  Return ``NULL`` if an exception was raised by the "
"codec."
msgstr ""
"Создайте объект Unicode, декодировав *size* байты строки *str* в кодировке "
"Unicode-Escape. Верните NULL, если кодек вызвал исключение."

#: ../../c-api/unicode.rst:1237
msgid ""
"Encode a Unicode object using Unicode-Escape and return the result as a "
"bytes object.  Error handling is \"strict\".  Return ``NULL`` if an "
"exception was raised by the codec."
msgstr ""
"Codifica un objeto Unicode utilizando Unicode-Escape y devuelve el resultado "
"como un objeto de bytes. El manejo de errores es \"estricto\". Devuelve "
"``NULL`` si se produjo una excepción por el códec."

#: ../../c-api/unicode.rst:1243
msgid "Raw-Unicode-Escape Codecs"
msgstr "Códecs Raw-Unicode-Escape"

#: ../../c-api/unicode.rst:1245
msgid "These are the \"Raw Unicode Escape\" codec APIs:"
msgstr "Estas son las APIs del códec \"Raw Unicode Escape\"."

#: ../../c-api/unicode.rst:1251
msgid ""
"Create a Unicode object by decoding *size* bytes of the Raw-Unicode-Escape "
"encoded string *str*.  Return ``NULL`` if an exception was raised by the "
"codec."
msgstr ""
"Создайте объект Unicode, декодировав *size* байты строки *str* в кодировке "
"Raw-Unicode-Escape. Верните NULL, если кодек вызвал исключение."

#: ../../c-api/unicode.rst:1257
msgid ""
"Encode a Unicode object using Raw-Unicode-Escape and return the result as a "
"bytes object.  Error handling is \"strict\".  Return ``NULL`` if an "
"exception was raised by the codec."
msgstr ""
"Codifica un objeto Unicode utilizando Raw-Unicode-Escape y devuelve el "
"resultado como un objeto de bytes. El manejo de errores es \"estricto\". "
"Devuelve ``NULL`` si se produjo una excepción en el códec."

#: ../../c-api/unicode.rst:1263
msgid "Latin-1 Codecs"
msgstr "Códecs de Latin-1"

#: ../../c-api/unicode.rst:1265
msgid ""
"These are the Latin-1 codec APIs: Latin-1 corresponds to the first 256 "
"Unicode ordinals and only these are accepted by the codecs during encoding."
msgstr ""
"Estas son las API del códec Latin-1: Latin-1 corresponde a los primeros 256 "
"ordinales Unicode y solo estos son aceptados por los códecs durante la "
"codificación."

#: ../../c-api/unicode.rst:1271
msgid ""
"Create a Unicode object by decoding *size* bytes of the Latin-1 encoded "
"string *str*.  Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"Создайте объект Unicode, декодировав *size* байты строки *str* в кодировке "
"Latin-1. Верните NULL, если кодек вызвал исключение."

#: ../../c-api/unicode.rst:1277
msgid ""
"Encode a Unicode object using Latin-1 and return the result as Python bytes "
"object.  Error handling is \"strict\".  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""
"Codifica un objeto Unicode utilizando Latin-1 y devuelve el resultado como "
"un objeto de bytes de Python. El manejo de errores es \"estricto\". Devuelve "
"``NULL`` si se produjo una excepción por parte del códec."

#: ../../c-api/unicode.rst:1283
msgid "ASCII Codecs"
msgstr "Códecs ASCII"

#: ../../c-api/unicode.rst:1285
msgid ""
"These are the ASCII codec APIs.  Only 7-bit ASCII data is accepted. All "
"other codes generate errors."
msgstr ""
"Estas son las API del códec ASCII. Solo se aceptan datos ASCII de 7 bits. "
"Todos los demás códigos generan errores."

#: ../../c-api/unicode.rst:1291
msgid ""
"Create a Unicode object by decoding *size* bytes of the ASCII encoded string "
"*str*.  Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"Создайте объект Unicode, декодировав *size* байты строки *str* в кодировке "
"ASCII. Верните NULL, если кодек вызвал исключение."

#: ../../c-api/unicode.rst:1297
msgid ""
"Encode a Unicode object using ASCII and return the result as Python bytes "
"object.  Error handling is \"strict\".  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""
"Codifica un objeto Unicode usando ASCII y devuelve el resultado como un "
"objeto Python bytes.  El tratamiento de errores es \"estricto\".  Devuelve "
"``NULL`` si el códec ha lanzado una excepción."

#: ../../c-api/unicode.rst:1303
msgid "Character Map Codecs"
msgstr "Mapa de caracteres Códecs"

#: ../../c-api/unicode.rst:1305
msgid ""
"This codec is special in that it can be used to implement many different "
"codecs (and this is in fact what was done to obtain most of the standard "
"codecs included in the :mod:`!encodings` package). The codec uses mappings "
"to encode and decode characters.  The mapping objects provided must support "
"the :meth:`~object.__getitem__` mapping interface; dictionaries and "
"sequences work well."
msgstr ""
"Этот кодек уникален тем, что с его помощью можно реализовать множество "
"различных кодеков (именно это и было сделано для получения большинства "
"стандартных кодеков, включенных в пакет :mod:`!encodings`). Кодек использует "
"сопоставления для кодирования и декодирования символов. Предоставленные "
"объекты сопоставления должны поддерживать интерфейс сопоставления :meth:"
"`~object.__getitem__`; словари и последовательности работают хорошо."

#: ../../c-api/unicode.rst:1311
msgid "These are the mapping codec APIs:"
msgstr "Estas son las APIs de mapeo de códecs."

#: ../../c-api/unicode.rst:1316
msgid ""
"Create a Unicode object by decoding *size* bytes of the encoded string *str* "
"using the given *mapping* object.  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""
"Создайте объект Unicode, декодировав *size* байты закодированной строки "
"*str*, используя данный объект *mapping*. Верните NULL, если кодек вызвал "
"исключение."

#: ../../c-api/unicode.rst:1320
msgid ""
"If *mapping* is ``NULL``, Latin-1 decoding will be applied.  Else *mapping* "
"must map bytes ordinals (integers in the range from 0 to 255) to Unicode "
"strings, integers (which are then interpreted as Unicode ordinals) or "
"``None``.  Unmapped data bytes -- ones which cause a :exc:`LookupError`, as "
"well as ones which get mapped to ``None``, ``0xFFFE`` or ``'\\ufffe'``, are "
"treated as undefined mappings and cause an error."
msgstr ""
"Si *mapping* es ``NULL``, se aplicará la decodificación Latin-1. De lo "
"contrario, *mapping* debe mapear los bytes ordinales (enteros en el rango de "
"0 a 255) a cadenas Unicode, enteros (que luego se interpretan como ordinales "
"Unicode) o ``None``. Los bytes de datos no mapeados, aquellos que causan un :"
"exc:`LookupError`, así como aquellos que se mapean a ``None``, ``0xFFFE`` o "
"``'\\ufffe'``, se tratan como mapeos indefinidos y causan un error."

#: ../../c-api/unicode.rst:1331
msgid ""
"Encode a Unicode object using the given *mapping* object and return the "
"result as a bytes object.  Error handling is \"strict\".  Return ``NULL`` if "
"an exception was raised by the codec."
msgstr ""
"Codifica un objeto Unicode utilizando el objeto *mapping* dado y devuelve el "
"resultado como un objeto bytes.  El tratamiento de errores es \"estricto\".  "
"Devuelve ``NULL`` si el códec ha lanzado una excepción."

#: ../../c-api/unicode.rst:1335
msgid ""
"The *mapping* object must map Unicode ordinal integers to bytes objects, "
"integers in the range from 0 to 255 or ``None``.  Unmapped character "
"ordinals (ones which cause a :exc:`LookupError`) as well as mapped to "
"``None`` are treated as \"undefined mapping\" and cause an error."
msgstr ""
"El objeto *mapping* debe mapear enteros ordinales Unicode a objetos de "
"bytes, enteros en el rango de 0 a 255 o ``None``. Los ordinales de "
"caracteres no mapeados (aquellos que causan un :exc:`LookupError`) así como "
"los mapeados a ``None`` se tratan como \"mapeo indefinido\" y causan un "
"error."

#: ../../c-api/unicode.rst:1341
msgid "The following codec API is special in that maps Unicode to Unicode."
msgstr ""
"El siguiente API de códec es especial en el sentido de que mapea Unicode a "
"Unicode."

#: ../../c-api/unicode.rst:1345
msgid ""
"Translate a string by applying a character mapping table to it and return "
"the resulting Unicode object. Return ``NULL`` if an exception was raised by "
"the codec."
msgstr ""
"Traduce una cadena aplicándole una tabla de asignación de caracteres y "
"devuelve el objeto Unicode resultante. Devuelve ``NULL`` si el códec ha "
"lanzado una excepción."

#: ../../c-api/unicode.rst:1349
msgid ""
"The mapping table must map Unicode ordinal integers to Unicode ordinal "
"integers or ``None`` (causing deletion of the character)."
msgstr ""
"La tabla de asignación debe asignar enteros ordinales Unicode a enteros "
"ordinales Unicode o ``None`` (provocando la eliminación del carácter)."

#: ../../c-api/unicode.rst:1352
msgid ""
"Mapping tables need only provide the :meth:`~object.__getitem__` interface; "
"dictionaries and sequences work well.  Unmapped character ordinals (ones "
"which cause a :exc:`LookupError`) are left untouched and are copied as-is."
msgstr ""
"Таблицы отображения должны предоставлять только интерфейс :meth:`~object."
"__getitem__`; словари и последовательности работают хорошо. Несопоставленные "
"порядковые номера символов (те, которые вызывают ошибку :exc:`LookupError`) "
"остаются нетронутыми и копируются как есть."

#: ../../c-api/unicode.rst:1356
msgid ""
"*errors* has the usual meaning for codecs. It may be ``NULL`` which "
"indicates to use the default error handling."
msgstr ""
"*errors* tiene el significado habitual para los codecs. Puede ser ``NULL``, "
"lo cual indica usar el manejo de errores predeterminado."

#: ../../c-api/unicode.rst:1361
msgid "MBCS codecs for Windows"
msgstr "Códecs MBCS para Windows"

#: ../../c-api/unicode.rst:1363
msgid ""
"These are the MBCS codec APIs. They are currently only available on Windows "
"and use the Win32 MBCS converters to implement the conversions.  Note that "
"MBCS (or DBCS) is a class of encodings, not just one.  The target encoding "
"is defined by the user settings on the machine running the codec."
msgstr ""
"Estas son las API del códec MBCS. Actualmente solo están disponibles en "
"Windows y utilizan los convertidores MBCS de Win32 para implementar las "
"conversiones. Tener en cuenta que MBCS (o DBCS) es una clase de "
"codificaciones, no solo una. La codificación objetivo está definida por la "
"configuración del usuario en la máquina que ejecuta el códec."

#: ../../c-api/unicode.rst:1370
msgid ""
"Create a Unicode object by decoding *size* bytes of the MBCS encoded string "
"*str*. Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"Создайте объект Unicode, декодировав *size* байты строки в кодировке MBCS "
"*str*. Верните NULL, если кодек вызвал исключение."

#: ../../c-api/unicode.rst:1377
msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeMBCS`. If "
"*consumed* is not ``NULL``, :c:func:`PyUnicode_DecodeMBCSStateful` will not "
"decode trailing lead byte and the number of bytes that have been decoded "
"will be stored in *consumed*."
msgstr ""
"Si *consumed* es ``NULL``, se comportará como :c:func:"
"`PyUnicode_DecodeMBCS`. Si *consumed* no es ``NULL``, :c:func:"
"`PyUnicode_DecodeMBCSStateful` no descodificará el byte inicial y el número "
"de bytes descodificados se almacenará en *consumed*."

#: ../../c-api/unicode.rst:1386
msgid ""
"Similar to :c:func:`PyUnicode_DecodeMBCSStateful`, except uses the code page "
"specified by *code_page*."
msgstr ""
"Аналогично :c:func:`PyUnicode_DecodeMBCSStateful`, за исключением того, что "
"использует кодовую страницу, указанную *code_page*."

#: ../../c-api/unicode.rst:1392
msgid ""
"Encode a Unicode object using MBCS and return the result as Python bytes "
"object.  Error handling is \"strict\".  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""
"Codificar un objeto Unicode utilizando MBCS y devolver el resultado como un "
"objeto bytes de Python. El manejo de errores es \"estricto\". Devolver "
"``NULL`` si se produjo una excepción por parte del códec."

#: ../../c-api/unicode.rst:1399
msgid ""
"Encode the Unicode object using the specified code page and return a Python "
"bytes object.  Return ``NULL`` if an exception was raised by the codec. Use :"
"c:macro:`!CP_ACP` code page to get the MBCS encoder."
msgstr ""
"Закодируйте объект Unicode, используя указанную кодовую страницу, и верните "
"байтовый объект Python. Верните NULL, если кодек вызвал исключение. "
"Используйте кодовую страницу :c:macro:`!CP_ACP`, чтобы получить кодировщик "
"MBCS."

#: ../../c-api/unicode.rst:1409
msgid "Methods and Slot Functions"
msgstr "Métodos y Funciones de Ranura"

#: ../../c-api/unicode.rst:1411
msgid ""
"The following APIs are capable of handling Unicode objects and strings on "
"input (we refer to them as strings in the descriptions) and return Unicode "
"objects or integers as appropriate."
msgstr ""
"Las siguientes APIs son capaces de manejar objetos y cadenas Unicode en la "
"entrada (nos referimos a ellos como cadenas en las descripciones) y "
"devuelven objetos Unicode o enteros según corresponda."

#: ../../c-api/unicode.rst:1415
msgid "They all return ``NULL`` or ``-1`` if an exception occurs."
msgstr "Todos ellos devuelven ``NULL`` o ``-1`` si se produce una excepción."

#: ../../c-api/unicode.rst:1420
msgid "Concat two strings giving a new Unicode string."
msgstr "Concatena dos cadenas dando una nueva cadena Unicode."

#: ../../c-api/unicode.rst:1425
msgid ""
"Split a string giving a list of Unicode strings.  If *sep* is ``NULL``, "
"splitting will be done at all whitespace substrings.  Otherwise, splits "
"occur at the given separator.  At most *maxsplit* splits will be done.  If "
"negative, no limit is set.  Separators are not included in the resulting "
"list."
msgstr ""
"Divide una cadena dando una lista de cadenas Unicode.  Si *sep* es ``NULL``, "
"la división se realizará en todas las subcadenas de espacios en blanco.  En "
"caso contrario, las divisiones se producen en el separador dado.  Se "
"realizarán como máximo *maxsplit* divisiones.  Si es negativo, no se "
"establece ningún límite.  Los separadores no se incluyen en la lista "
"resultante."

#: ../../c-api/unicode.rst:1430 ../../c-api/unicode.rst:1440
#: ../../c-api/unicode.rst:1461 ../../c-api/unicode.rst:1474
msgid "On error, return ``NULL`` with an exception set."
msgstr "В случае ошибки вернуть ``NULL`` с набором исключений."

#: ../../c-api/unicode.rst:1432
msgid "Equivalent to :py:meth:`str.split`."
msgstr "Эквивалентно :py:meth:`str.split`."

#: ../../c-api/unicode.rst:1437
msgid ""
"Similar to :c:func:`PyUnicode_Split`, but splitting will be done beginning "
"at the end of the string."
msgstr ""
"Аналогично :c:func:`PyUnicode_Split`, но разделение будет выполняться, "
"начиная с конца строки."

#: ../../c-api/unicode.rst:1442
msgid "Equivalent to :py:meth:`str.rsplit`."
msgstr "Эквивалентно :py:meth:`str.rsplit`."

#: ../../c-api/unicode.rst:1447
msgid ""
"Split a Unicode string at line breaks, returning a list of Unicode strings. "
"CRLF is considered to be one line break.  If *keepends* is ``0``, the Line "
"break characters are not included in the resulting strings."
msgstr ""
"Разделите строку Юникода по разрывам строк, вернув список строк Юникода. "
"CRLF считается разрывом одной строки. Если *keepends* имеет значение ``0``, "
"символы разрыва строки не включаются в результирующие строки."

#: ../../c-api/unicode.rst:1454
msgid ""
"Split a Unicode string at the first occurrence of *sep*, and return a 3-"
"tuple containing the part before the separator, the separator itself, and "
"the part after the separator. If the separator is not found, return a 3-"
"tuple containing the string itself, followed by two empty strings."
msgstr ""
"Разделите строку Unicode при первом появлении *Sep *и верните 3-пробег, "
"содержащую деталь перед сепаратором, самого сепаратора и детали после "
"сепаратора. Если сепаратор не найден, верните 3-закусный, содержащий саму "
"строку, а затем две пустые строки."

#: ../../c-api/unicode.rst:1459 ../../c-api/unicode.rst:1472
msgid "*sep* must not be empty."
msgstr "*sep* не может быть пустым."

#: ../../c-api/unicode.rst:1463
msgid "Equivalent to :py:meth:`str.partition`."
msgstr "Эквивалентно :py:meth:`str.partition`."

#: ../../c-api/unicode.rst:1468
msgid ""
"Similar to :c:func:`PyUnicode_Partition`, but split a Unicode string at the "
"last occurrence of *sep*. If the separator is not found, return a 3-tuple "
"containing two empty strings, followed by the string itself."
msgstr ""
"Аналогично :c:func:`PyUnicode_Partition`, но разделяет строку Unicode по "
"последнему вхождению *sep*. Если разделитель не найден, возвращает 3-кортеж, "
"содержащий две пустые строки, за которыми следует сама строка."

#: ../../c-api/unicode.rst:1476
msgid "Equivalent to :py:meth:`str.rpartition`."
msgstr "Эквивалентно :py:meth:`str.rpartition`."

#: ../../c-api/unicode.rst:1481
msgid ""
"Join a sequence of strings using the given *separator* and return the "
"resulting Unicode string."
msgstr ""
"Unir una secuencia de cadenas utilizando el *separador* proporcionado y "
"devolver la cadena Unicode resultante."

#: ../../c-api/unicode.rst:1488
msgid ""
"Return ``1`` if *substr* matches ``unicode[start:end]`` at the given tail "
"end (*direction* == ``-1`` means to do a prefix match, *direction* == ``1`` "
"a suffix match), ``0`` otherwise. Return ``-1`` if an error occurred."
msgstr ""
"Возвращает ``1``, если *substr* соответствует ``unicode[start:end]`` в "
"заданном конце (*direction* == ``-1`` означает совпадение префикса, "
"*direction* == ``1`` соответствует суффиксу), ``0`` в противном случае. "
"Верните ``-1``, если произошла ошибка."

#: ../../c-api/unicode.rst:1496
msgid ""
"Return the first position of *substr* in ``unicode[start:end]`` using the "
"given *direction* (*direction* == ``1`` means to do a forward search, "
"*direction* == ``-1`` a backward search).  The return value is the index of "
"the first match; a value of ``-1`` indicates that no match was found, and "
"``-2`` indicates that an error occurred and an exception has been set."
msgstr ""
"Вернуть первую позицию *substr* в ``unicode[start:end]``, используя заданное "
"*direction* (*direction* == ``1`` означает прямой поиск, *direction* == `` "
"-1`` обратный поиск). Возвращаемое значение — это индекс первого совпадения; "
"значение ``-1`` указывает, что совпадение не найдено, а ``-2`` указывает, "
"что произошла ошибка и было установлено исключение."

#: ../../c-api/unicode.rst:1506
msgid ""
"Return the first position of the character *ch* in ``unicode[start:end]`` "
"using the given *direction* (*direction* == ``1`` means to do a forward "
"search, *direction* == ``-1`` a backward search).  The return value is the "
"index of the first match; a value of ``-1`` indicates that no match was "
"found, and ``-2`` indicates that an error occurred and an exception has been "
"set."
msgstr ""
"Вернуть первую позицию символа *ch* в ``unicode[start:end]``, используя "
"заданное *направление* (*direction* == ``1`` означает прямой поиск, "
"*direction* == ``-1`` обратный поиск). Возвращаемое значение — это индекс "
"первого совпадения; значение ``-1`` указывает, что совпадение не найдено, а "
"``-2`` указывает, что произошла ошибка и было установлено исключение."

#: ../../c-api/unicode.rst:1514
msgid ""
"*start* and *end* are now adjusted to behave like ``unicode[start:end]``."
msgstr ""
"*start* и *end* теперь настроены так, чтобы вести себя как ``unicode[start:"
"end]``."

#: ../../c-api/unicode.rst:1521
msgid ""
"Return the number of non-overlapping occurrences of *substr* in "
"``unicode[start:end]``.  Return ``-1`` if an error occurred."
msgstr ""
"Возвращает количество непересекающихся вхождений *substr* в ``unicode[start:"
"end]``. Верните ``-1``, если произошла ошибка."

#: ../../c-api/unicode.rst:1528
msgid ""
"Replace at most *maxcount* occurrences of *substr* in *unicode* with "
"*replstr* and return the resulting Unicode object. *maxcount* == ``-1`` "
"means replace all occurrences."
msgstr ""
"Замените не более *maxcount* вхождений *substr* в *unicode* на *replstr* и "
"верните полученный объект Unicode. *maxcount* == ``-1`` означает замену всех "
"вхождений."

#: ../../c-api/unicode.rst:1535
msgid ""
"Compare two strings and return ``-1``, ``0``, ``1`` for less than, equal, "
"and greater than, respectively."
msgstr ""
"Comparar dos cadenas y devolver ``-1``, ``0``, ``1`` para menor que, igual y "
"mayor que, respectivamente."

#: ../../c-api/unicode.rst:1538
msgid ""
"This function returns ``-1`` upon failure, so one should call :c:func:"
"`PyErr_Occurred` to check for errors."
msgstr ""
"Esta función devuelve ``-1`` en caso de fallo, por lo que se debe llamar a :"
"c:func:`PyErr_Occurred` para comprobar errores."

#: ../../c-api/unicode.rst:1544
msgid ""
"Compare a Unicode object with a char buffer which is interpreted as being "
"UTF-8 or ASCII encoded and return true (``1``) if they are equal, or false "
"(``0``) otherwise. If the Unicode object contains surrogate code points "
"(``U+D800`` - ``U+DFFF``) or the C string is not valid UTF-8, false (``0``) "
"is returned."
msgstr ""
"Сравните объект Unicode с буфером символов, который интерпретируется как "
"кодированный UTF-8 или ASCII, и верните true («1»), если они равны, или "
"false («0») в противном случае. Если объект Unicode содержит суррогатные "
"кодовые точки (``U+D800`` - ``U+DFFF``) или строка C недействительна в "
"формате UTF-8, возвращается false (``0``)."

#: ../../c-api/unicode.rst:1551 ../../c-api/unicode.rst:1572
msgid "This function does not raise exceptions."
msgstr "Esta función no genera excepciones."

#: ../../c-api/unicode.rst:1558
msgid ""
"Similar to :c:func:`PyUnicode_EqualToUTF8AndSize`, but compute *string* "
"length using :c:func:`!strlen`. If the Unicode object contains null "
"characters, false (``0``) is returned."
msgstr ""
"Аналогично :c:func:`PyUnicode_EqualToUTF8AndSize`, но длину *строки* "
"вычисляйте, используя :c:func:`!strlen`. Если объект Unicode содержит "
"нулевые символы, возвращается false («0»)."

#: ../../c-api/unicode.rst:1567
msgid ""
"Compare a Unicode object, *unicode*, with *string* and return ``-1``, ``0``, "
"``1`` for less than, equal, and greater than, respectively. It is best to "
"pass only ASCII-encoded strings, but the function interprets the input "
"string as ISO-8859-1 if it contains non-ASCII characters."
msgstr ""
"Сравните объект Unicode *unicode* со *string* и верните ``-1``, ``0``, ``1`` "
"для значений меньше, равно и больше соответственно. Лучше всего передавать "
"только строки в кодировке ASCII, но функция интерпретирует входную строку "
"как ISO-8859-1, если она содержит символы, отличные от ASCII."

#: ../../c-api/unicode.rst:1577
msgid "Rich compare two Unicode strings and return one of the following:"
msgstr ""
"Comparar dos cadenas Unicode ricas y devolver una de las siguientes opciones:"

#: ../../c-api/unicode.rst:1579
msgid "``NULL`` in case an exception was raised"
msgstr "``NULL`` en caso de que se haya producido una excepción."

#: ../../c-api/unicode.rst:1580
msgid ":c:data:`Py_True` or :c:data:`Py_False` for successful comparisons"
msgstr ":c:data:`Py_True` или :c:data:`Py_False` для успешного сравнения."

#: ../../c-api/unicode.rst:1581
msgid ":c:data:`Py_NotImplemented` in case the type combination is unknown"
msgstr ":c:data:`Py_NotImplemented` в случае, если комбинация типов неизвестна"

#: ../../c-api/unicode.rst:1583
msgid ""
"Possible values for *op* are :c:macro:`Py_GT`, :c:macro:`Py_GE`, :c:macro:"
"`Py_EQ`, :c:macro:`Py_NE`, :c:macro:`Py_LT`, and :c:macro:`Py_LE`."
msgstr ""
"Возможные значения для *op*: :c:macro:`Py_GT`, :c:macro:`Py_GE`, :c:macro:"
"`Py_EQ`, :c:macro:`Py_NE`, :c:macro:`Py_LT ` и :c:macro:`Py_LE`."

#: ../../c-api/unicode.rst:1589
msgid ""
"Return a new string object from *format* and *args*; this is analogous to "
"``format % args``."
msgstr ""
"Devuelve un nuevo objeto de cadena a partir de *format* y *args*; esto es "
"análogo a ``format % args``."

#: ../../c-api/unicode.rst:1595
msgid ""
"Check whether *substr* is contained in *unicode* and return true or false "
"accordingly."
msgstr ""
"Проверьте, содержится ли *substr* в *unicode*, и верните true или false "
"соответственно."

#: ../../c-api/unicode.rst:1598
msgid ""
"*substr* has to coerce to a one element Unicode string. ``-1`` is returned "
"if there was an error."
msgstr ""
"*substr* должен привести к одноэлементной строке Unicode. ``-1`` "
"возвращается, если произошла ошибка."

#: ../../c-api/unicode.rst:1604
msgid ""
"Intern the argument :c:expr:`*p_unicode` in place.  The argument must be the "
"address of a pointer variable pointing to a Python Unicode string object.  "
"If there is an existing interned string that is the same as :c:expr:"
"`*p_unicode`, it sets :c:expr:`*p_unicode` to it (releasing the reference to "
"the old string object and creating a new :term:`strong reference` to the "
"interned string object), otherwise it leaves :c:expr:`*p_unicode` alone and "
"interns it."
msgstr ""
"Интернируйте аргумент :c:expr:`*p_unicode` на место. Аргумент должен быть "
"адресом переменной-указателя, указывающей на строковый объект Unicode "
"Python. Если существует существующая интернированная строка, такая же, как :"
"c:expr:`*p_unicode`, она устанавливает для нее :c:expr:`*p_unicode` "
"(освобождая ссылку на старый строковый объект и создавая новый :term :"
"`strong reference` на интернированный строковый объект), в противном случае "
"он оставляет :c:expr:`*p_unicode` в покое и интернирует его."

#: ../../c-api/unicode.rst:1611
msgid ""
"(Clarification: even though there is a lot of talk about references, think "
"of this function as reference-neutral. You must own the object you pass in; "
"after the call you no longer own the passed-in reference, but you newly own "
"the result.)"
msgstr ""
"(Уточнение: хотя о ссылках много говорят, думайте об этой функции как о "
"ссылочно-нейтральной. Вы должны владеть объектом, который передаете; после "
"вызова вы больше не владеете переданной ссылкой, но вы вновь владеете "
"результат.)"

#: ../../c-api/unicode.rst:1616
msgid ""
"This function never raises an exception. On error, it leaves its argument "
"unchanged without interning it."
msgstr ""
"Эта функция никогда не вызывает исключения. В случае ошибки он оставляет "
"свой аргумент неизменным, не интернируя его."

#: ../../c-api/unicode.rst:1619
msgid ""
"Instances of subclasses of :py:class:`str` may not be interned, that is, :c:"
"expr:`PyUnicode_CheckExact(*p_unicode)` must be true. If it is not, then -- "
"as with any other error -- the argument is left unchanged."
msgstr ""
"Экземпляры подклассов :py:class:`str` не могут быть интернированы, то есть :"
"c:expr:`PyUnicode_CheckExact(*p_unicode)` должно иметь значение true. Если "
"это не так, то, как и при любой другой ошибке, аргумент остается неизменным."

#: ../../c-api/unicode.rst:1623
msgid ""
"Note that interned strings are not “immortal”. You must keep a reference to "
"the result to benefit from interning."
msgstr ""
"Обратите внимание, что интернированные строки не являются «бессмертными». Вы "
"должны сохранить ссылку на результат, чтобы получить выгоду от стажировки."

#: ../../c-api/unicode.rst:1629
msgid ""
"A combination of :c:func:`PyUnicode_FromString` and :c:func:"
"`PyUnicode_InternInPlace`, meant for statically allocated strings."
msgstr ""
"Комбинация :c:func:`PyUnicode_FromString` и :c:func:"
"`PyUnicode_InternInPlace`, предназначенная для статически выделенных строк."

#: ../../c-api/unicode.rst:1632
msgid ""
"Return a new (\"owned\") reference to either a new Unicode string object "
"that has been interned, or an earlier interned string object with the same "
"value."
msgstr ""
"Возвращает новую («принадлежащую») ссылку либо на новый строковый объект "
"Юникода, который был интернирован, либо на ранее интернированный строковый "
"объект с тем же значением."

#: ../../c-api/unicode.rst:1636
msgid ""
"Python may keep a reference to the result, or make it :term:`immortal`, "
"preventing it from being garbage-collected promptly. For interning an "
"unbounded number of different strings, such as ones coming from user input, "
"prefer calling :c:func:`PyUnicode_FromString` and :c:func:"
"`PyUnicode_InternInPlace` directly."
msgstr ""
"Python может сохранить ссылку на результат или сделать его «бессмертным», "
"предотвращая его быструю сборку мусора. Для интернирования неограниченного "
"количества различных строк, например, поступающих из пользовательского "
"ввода, предпочтительнее вызывать :c:func:`PyUnicode_FromString` и :c:func:"
"`PyUnicode_InternInPlace` напрямую."
