# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 15:00+0000\n"
"PO-Revision-Date: 2025-07-18 19:21+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Spanish (Spain) (https://app.transifex.com/python-doc/"
"teams/5390/es_ES/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es_ES\n"
"Plural-Forms: nplurals=3; plural=n == 1 ? 0 : n != 0 && n % 1000000 == 0 ? "
"1 : 2;\n"

#: ../../c-api/typeobj.rst:6
msgid "Type Object Structures"
msgstr "Тип Объектные Структуры"

#: ../../c-api/typeobj.rst:8
msgid ""
"Perhaps one of the most important structures of the Python object system is "
"the structure that defines a new type: the :c:type:`PyTypeObject` "
"structure.  Type objects can be handled using any of the ``PyObject_*`` or "
"``PyType_*`` functions, but do not offer much that's interesting to most "
"Python applications. These objects are fundamental to how objects behave, so "
"they are very important to the interpreter itself and to any extension "
"module that implements new types."
msgstr ""
"Возможно, одной из наиболее важных структур объектной системы Python "
"является структура, определяющая новый тип: структура :c:type:"
"`PyTypeObject`. Объекты типа могут обрабатываться с помощью любой из функций "
"PyObject_* или PyType_*, но они не предлагают многого из того, что интересно "
"большинству приложений Python. Эти объекты имеют фундаментальное значение "
"для поведения объектов, поэтому они очень важны для самого интерпретатора и "
"для любого модуля расширения, реализующего новые типы."

#: ../../c-api/typeobj.rst:16
msgid ""
"Type objects are fairly large compared to most of the standard types. The "
"reason for the size is that each type object stores a large number of "
"values, mostly C function pointers, each of which implements a small part of "
"the type's functionality.  The fields of the type object are examined in "
"detail in this section.  The fields will be described in the order in which "
"they occur in the structure."
msgstr ""
"Los objetos de tipo son bastante grandes en comparación con la mayoría de "
"los tipos estándar. La razón del tamaño es que cada objeto de tipo almacena "
"una gran cantidad de valores, en su mayoría punteros a funciones C, cada uno "
"de los cuales implementa una pequeña parte de la funcionalidad del tipo. Los "
"campos del objeto de tipo se examinan en detalle en esta sección. Los campos "
"se describirán en el orden en que aparecen en la estructura."

#: ../../c-api/typeobj.rst:23
msgid ""
"In addition to the following quick reference, the :ref:`typedef-examples` "
"section provides at-a-glance insight into the meaning and use of :c:type:"
"`PyTypeObject`."
msgstr ""
"Además de la siguiente referencia rápida, la sección :ref:`typedef-examples` "
"proporciona una visión rápida sobre el significado y uso de :c:type:"
"`PyTypeObject`."

#: ../../c-api/typeobj.rst:29
msgid "Quick Reference"
msgstr "Referencia rápida"

#: ../../c-api/typeobj.rst:34
msgid "\"tp slots\""
msgstr "\"tp slots\""

#: ../../c-api/typeobj.rst:40
msgid "PyTypeObject Slot [#slots]_"
msgstr "PyTypeObject Ranura [#slots]_"

#: ../../c-api/typeobj.rst:40 ../../c-api/typeobj.rst:201
msgid ":ref:`Type <slot-typedefs-table>`"
msgstr ":ref:`Type <slot-typedefs-table>`"

#: ../../c-api/typeobj.rst:40
msgid "special methods/attrs"
msgstr "métodos/attrs especiales"

#: ../../c-api/typeobj.rst:40
msgid "Info [#cols]_"
msgstr "Info [#cols]_"

#: ../../c-api/typeobj.rst:42
msgid "O"
msgstr "O"

#: ../../c-api/typeobj.rst:42
msgid "T"
msgstr "T"

#: ../../c-api/typeobj.rst:42
msgid "D"
msgstr "D"

#: ../../c-api/typeobj.rst:42
msgid "I"
msgstr "I"

#: ../../c-api/typeobj.rst:44
msgid "<R> :c:member:`~PyTypeObject.tp_name`"
msgstr "<R> :c:member:`~PyTypeObject.tp_name`"

#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:44
#: ../../c-api/typeobj.rst:86
msgid "const char *"
msgstr "const char *"

#: ../../c-api/typeobj.rst:44
msgid "__name__"
msgstr "__name__"

#: ../../c-api/typeobj.rst:44 ../../c-api/typeobj.rst:46
#: ../../c-api/typeobj.rst:48 ../../c-api/typeobj.rst:50
#: ../../c-api/typeobj.rst:52 ../../c-api/typeobj.rst:62
#: ../../c-api/typeobj.rst:70 ../../c-api/typeobj.rst:72
#: ../../c-api/typeobj.rst:74 ../../c-api/typeobj.rst:76
#: ../../c-api/typeobj.rst:79 ../../c-api/typeobj.rst:84
#: ../../c-api/typeobj.rst:86 ../../c-api/typeobj.rst:88
#: ../../c-api/typeobj.rst:90 ../../c-api/typeobj.rst:92
#: ../../c-api/typeobj.rst:99 ../../c-api/typeobj.rst:101
#: ../../c-api/typeobj.rst:103 ../../c-api/typeobj.rst:105
#: ../../c-api/typeobj.rst:107 ../../c-api/typeobj.rst:109
#: ../../c-api/typeobj.rst:111 ../../c-api/typeobj.rst:115
#: ../../c-api/typeobj.rst:117 ../../c-api/typeobj.rst:120
#: ../../c-api/typeobj.rst:122 ../../c-api/typeobj.rst:124
#: ../../c-api/typeobj.rst:126 ../../c-api/typeobj.rst:128
#: ../../c-api/typeobj.rst:130 ../../c-api/typeobj.rst:146
msgid "X"
msgstr "X"

#: ../../c-api/typeobj.rst:46
msgid ":c:member:`~PyTypeObject.tp_basicsize`"
msgstr ":c:member:`~PyTypeObject.tp_basicsize`"

#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:46
#: ../../c-api/typeobj.rst:48 ../../c-api/typeobj.rst:52
#: ../../c-api/typeobj.rst:99 ../../c-api/typeobj.rst:120
#: ../../c-api/typeobj.rst:417
msgid ":c:type:`Py_ssize_t`"
msgstr ":c:type:`Py_ssize_t`"

#: ../../c-api/typeobj.rst:48
msgid ":c:member:`~PyTypeObject.tp_itemsize`"
msgstr ":c:member:`~PyTypeObject.tp_itemsize`"

#: ../../c-api/typeobj.rst:50
msgid ":c:member:`~PyTypeObject.tp_dealloc`"
msgstr ":c:member:`~PyTypeObject.tp_dealloc`"

#: ../../c-api/typeobj.rst:50 ../../c-api/typeobj.rst:142
#: ../../c-api/typeobj.rst:146 ../../c-api/typeobj.rst:347
msgid ":c:type:`destructor`"
msgstr ":c:type:`destructor`"

#: ../../c-api/typeobj.rst:52
msgid ":c:member:`~PyTypeObject.tp_vectorcall_offset`"
msgstr ":c:member:`~PyTypeObject.tp_vectorcall_offset`"

#: ../../c-api/typeobj.rst:54
msgid "(:c:member:`~PyTypeObject.tp_getattr`)"
msgstr "(:c:member:`~PyTypeObject.tp_getattr`)"

#: ../../c-api/typeobj.rst:54 ../../c-api/typeobj.rst:371
msgid ":c:type:`getattrfunc`"
msgstr ":c:type:`getattrfunc`"

#: ../../c-api/typeobj.rst:54 ../../c-api/typeobj.rst:76
msgid "__getattribute__, __getattr__"
msgstr "__getattribute__, __getattr__"

#: ../../c-api/typeobj.rst:54 ../../c-api/typeobj.rst:57
#: ../../c-api/typeobj.rst:70 ../../c-api/typeobj.rst:76
#: ../../c-api/typeobj.rst:79 ../../c-api/typeobj.rst:88
#: ../../c-api/typeobj.rst:90 ../../c-api/typeobj.rst:92
msgid "G"
msgstr "G"

#: ../../c-api/typeobj.rst:57
msgid "(:c:member:`~PyTypeObject.tp_setattr`)"
msgstr "(:c:member:`~PyTypeObject.tp_setattr`)"

#: ../../c-api/typeobj.rst:57 ../../c-api/typeobj.rst:376
msgid ":c:type:`setattrfunc`"
msgstr ":c:type:`setattrfunc`"

#: ../../c-api/typeobj.rst:57 ../../c-api/typeobj.rst:79
msgid "__setattr__, __delattr__"
msgstr "__setattr__, __delattr__"

#: ../../c-api/typeobj.rst:60
msgid ":c:member:`~PyTypeObject.tp_as_async`"
msgstr ":c:member:`~PyTypeObject.tp_as_async`"

#: ../../c-api/typeobj.rst:60
msgid ":c:type:`PyAsyncMethods` *"
msgstr ":c:type:`PyAsyncMethods` *"

#: ../../c-api/typeobj.rst:60 ../../c-api/typeobj.rst:64
#: ../../c-api/typeobj.rst:66 ../../c-api/typeobj.rst:68
#: ../../c-api/typeobj.rst:82
msgid ":ref:`sub-slots`"
msgstr ":ref:`sub-slots`"

#: ../../c-api/typeobj.rst:60 ../../c-api/typeobj.rst:64
#: ../../c-api/typeobj.rst:66 ../../c-api/typeobj.rst:68
#: ../../c-api/typeobj.rst:82
msgid "%"
msgstr "%"

#: ../../c-api/typeobj.rst:62
msgid ":c:member:`~PyTypeObject.tp_repr`"
msgstr ":c:member:`~PyTypeObject.tp_repr`"

#: ../../c-api/typeobj.rst:62 ../../c-api/typeobj.rst:74
#: ../../c-api/typeobj.rst:369
msgid ":c:type:`reprfunc`"
msgstr ":c:type:`reprfunc`"

#: ../../c-api/typeobj.rst:62
msgid "__repr__"
msgstr "__repr__"

#: ../../c-api/typeobj.rst:64
msgid ":c:member:`~PyTypeObject.tp_as_number`"
msgstr ":c:member:`~PyTypeObject.tp_as_number`"

#: ../../c-api/typeobj.rst:64
msgid ":c:type:`PyNumberMethods` *"
msgstr ":c:type:`PyNumberMethods` *"

#: ../../c-api/typeobj.rst:66
msgid ":c:member:`~PyTypeObject.tp_as_sequence`"
msgstr ":c:member:`~PyTypeObject.tp_as_sequence`"

#: ../../c-api/typeobj.rst:66
msgid ":c:type:`PySequenceMethods` *"
msgstr ":c:type:`PySequenceMethods` *"

#: ../../c-api/typeobj.rst:68
msgid ":c:member:`~PyTypeObject.tp_as_mapping`"
msgstr ":c:member:`~PyTypeObject.tp_as_mapping`"

#: ../../c-api/typeobj.rst:68
msgid ":c:type:`PyMappingMethods` *"
msgstr ":c:type:`PyMappingMethods` *"

#: ../../c-api/typeobj.rst:70
msgid ":c:member:`~PyTypeObject.tp_hash`"
msgstr ":c:member:`~PyTypeObject.tp_hash`"

#: ../../c-api/typeobj.rst:70 ../../c-api/typeobj.rst:405
msgid ":c:type:`hashfunc`"
msgstr ":c:type:`hashfunc`"

#: ../../c-api/typeobj.rst:70
msgid "__hash__"
msgstr "__hash__"

#: ../../c-api/typeobj.rst:72
msgid ":c:member:`~PyTypeObject.tp_call`"
msgstr ":c:member:`~PyTypeObject.tp_call`"

#: ../../c-api/typeobj.rst:72 ../../c-api/typeobj.rst:237
#: ../../c-api/typeobj.rst:240 ../../c-api/typeobj.rst:441
msgid ":c:type:`ternaryfunc`"
msgstr ":c:type:`ternaryfunc`"

#: ../../c-api/typeobj.rst:72
msgid "__call__"
msgstr "__call__"

#: ../../c-api/typeobj.rst:74
msgid ":c:member:`~PyTypeObject.tp_str`"
msgstr ":c:member:`~PyTypeObject.tp_str`"

#: ../../c-api/typeobj.rst:74
msgid "__str__"
msgstr "__str__"

#: ../../c-api/typeobj.rst:76
msgid ":c:member:`~PyTypeObject.tp_getattro`"
msgstr ":c:member:`~PyTypeObject.tp_getattro`"

#: ../../c-api/typeobj.rst:76 ../../c-api/typeobj.rst:382
msgid ":c:type:`getattrofunc`"
msgstr ":c:type:`getattrofunc`"

#: ../../c-api/typeobj.rst:79
msgid ":c:member:`~PyTypeObject.tp_setattro`"
msgstr ":c:member:`~PyTypeObject.tp_setattro`"

#: ../../c-api/typeobj.rst:79 ../../c-api/typeobj.rst:387
msgid ":c:type:`setattrofunc`"
msgstr ":c:type:`setattrofunc`"

#: ../../c-api/typeobj.rst:82
msgid ":c:member:`~PyTypeObject.tp_as_buffer`"
msgstr ":c:member:`~PyTypeObject.tp_as_buffer`"

#: ../../c-api/typeobj.rst:82
msgid ":c:type:`PyBufferProcs` *"
msgstr ":c:type:`PyBufferProcs` *"

#: ../../c-api/typeobj.rst:84
msgid ":c:member:`~PyTypeObject.tp_flags`"
msgstr ":c:member:`~PyTypeObject.tp_flags`"

#: ../../c-api/typeobj.rst:84
msgid "unsigned long"
msgstr "int sin firmar"

#: ../../c-api/typeobj.rst:84 ../../c-api/typeobj.rst:99
#: ../../c-api/typeobj.rst:113 ../../c-api/typeobj.rst:120
#: ../../c-api/typeobj.rst:124 ../../c-api/typeobj.rst:126
#: ../../c-api/typeobj.rst:128
msgid "?"
msgstr "?"

#: ../../c-api/typeobj.rst:86
msgid ":c:member:`~PyTypeObject.tp_doc`"
msgstr ":c:member:`~PyTypeObject.tp_doc`"

#: ../../c-api/typeobj.rst:86
msgid "__doc__"
msgstr "__doc__"

#: ../../c-api/typeobj.rst:88
msgid ":c:member:`~PyTypeObject.tp_traverse`"
msgstr ":c:member:`~PyTypeObject.tp_traverse`"

#: ../../c-api/typeobj.rst:88 ../../c-api/typeobj.rst:351
msgid ":c:type:`traverseproc`"
msgstr ":c:type:`traverseproc`"

#: ../../c-api/typeobj.rst:90
msgid ":c:member:`~PyTypeObject.tp_clear`"
msgstr ":c:member:`~PyTypeObject.tp_clear`"

#: ../../c-api/typeobj.rst:90 ../../c-api/typeobj.rst:130
#: ../../c-api/typeobj.rst:248 ../../c-api/typeobj.rst:430
msgid ":c:type:`inquiry`"
msgstr ":c:type:`inquiry`"

#: ../../c-api/typeobj.rst:92
msgid ":c:member:`~PyTypeObject.tp_richcompare`"
msgstr ":c:member:`~PyTypeObject.tp_richcompare`"

#: ../../c-api/typeobj.rst:92 ../../c-api/typeobj.rst:407
msgid ":c:type:`richcmpfunc`"
msgstr ":c:type:`richcmpfunc`"

#: ../../c-api/typeobj.rst:92
msgid "__lt__, __le__, __eq__, __ne__, __gt__, __ge__"
msgstr "__lt__, __le__, __eq__, __ne__, __gt__, __ge__"

#: ../../c-api/typeobj.rst:99
msgid "(:c:member:`~PyTypeObject.tp_weaklistoffset`)"
msgstr "(:c:member:`~PyTypeObject.tp_weaklistoffset`)"

#: ../../c-api/typeobj.rst:101
msgid ":c:member:`~PyTypeObject.tp_iter`"
msgstr ":c:member:`~PyTypeObject.tp_iter`"

#: ../../c-api/typeobj.rst:101 ../../c-api/typeobj.rst:413
msgid ":c:type:`getiterfunc`"
msgstr ":c:type:`getiterfunc`"

#: ../../c-api/typeobj.rst:101
msgid "__iter__"
msgstr "__iter__"

#: ../../c-api/typeobj.rst:103
msgid ":c:member:`~PyTypeObject.tp_iternext`"
msgstr ":c:member:`~PyTypeObject.tp_iternext`"

#: ../../c-api/typeobj.rst:103 ../../c-api/typeobj.rst:415
msgid ":c:type:`iternextfunc`"
msgstr ":c:type:`iternextfunc`"

#: ../../c-api/typeobj.rst:103
msgid "__next__"
msgstr "__next__"

#: ../../c-api/typeobj.rst:105
msgid ":c:member:`~PyTypeObject.tp_methods`"
msgstr ":c:member:`~PyTypeObject.tp_methods`"

#: ../../c-api/typeobj.rst:105
msgid ":c:type:`PyMethodDef` []"
msgstr ":c:type:`PyMethodDef` []"

#: ../../c-api/typeobj.rst:107
msgid ":c:member:`~PyTypeObject.tp_members`"
msgstr ":c:member:`~PyTypeObject.tp_members`"

#: ../../c-api/typeobj.rst:107
msgid ":c:type:`PyMemberDef` []"
msgstr ":c:type:`PyMemberDef` []"

#: ../../c-api/typeobj.rst:109
msgid ":c:member:`~PyTypeObject.tp_getset`"
msgstr ":c:member:`~PyTypeObject.tp_getset`"

#: ../../c-api/typeobj.rst:109
msgid ":c:type:`PyGetSetDef` []"
msgstr ":c:type:`PyGetSetDef` []"

#: ../../c-api/typeobj.rst:111
msgid ":c:member:`~PyTypeObject.tp_base`"
msgstr ":c:member:`~PyTypeObject.tp_base`"

#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:111
msgid ":c:type:`PyTypeObject` *"
msgstr ":c:type:`PyTypeObject` *"

#: ../../c-api/typeobj.rst:111
msgid "__base__"
msgstr "__base__"

#: ../../c-api/typeobj.rst:113
msgid ":c:member:`~PyTypeObject.tp_dict`"
msgstr ":c:member:`~PyTypeObject.tp_dict`"

#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:113
#: ../../c-api/typeobj.rst:132 ../../c-api/typeobj.rst:134
#: ../../c-api/typeobj.rst:136 ../../c-api/typeobj.rst:140
#: ../../c-api/typeobj.rst:342 ../../c-api/typeobj.rst:347
#: ../../c-api/typeobj.rst:357 ../../c-api/typeobj.rst:369
#: ../../c-api/typeobj.rst:371 ../../c-api/typeobj.rst:382
#: ../../c-api/typeobj.rst:393 ../../c-api/typeobj.rst:405
#: ../../c-api/typeobj.rst:407 ../../c-api/typeobj.rst:413
#: ../../c-api/typeobj.rst:415 ../../c-api/typeobj.rst:417
#: ../../c-api/typeobj.rst:430 ../../c-api/typeobj.rst:432
#: ../../c-api/typeobj.rst:436 ../../c-api/typeobj.rst:441
#: ../../c-api/typeobj.rst:447
msgid ":c:type:`PyObject` *"
msgstr ":c:type:`PyObject` *"

#: ../../c-api/typeobj.rst:113
msgid "__dict__"
msgstr "__dict__"

#: ../../c-api/typeobj.rst:115
msgid ":c:member:`~PyTypeObject.tp_descr_get`"
msgstr ":c:member:`~PyTypeObject.tp_descr_get`"

#: ../../c-api/typeobj.rst:115 ../../c-api/typeobj.rst:393
msgid ":c:type:`descrgetfunc`"
msgstr ":c:type:`descrgetfunc`"

#: ../../c-api/typeobj.rst:115
msgid "__get__"
msgstr "__get__"

#: ../../c-api/typeobj.rst:117
msgid ":c:member:`~PyTypeObject.tp_descr_set`"
msgstr ":c:member:`~PyTypeObject.tp_descr_set`"

#: ../../c-api/typeobj.rst:117 ../../c-api/typeobj.rst:399
msgid ":c:type:`descrsetfunc`"
msgstr ":c:type:`descrsetfunc`"

#: ../../c-api/typeobj.rst:117
msgid "__set__, __delete__"
msgstr "__set__, __delete__"

#: ../../c-api/typeobj.rst:120
msgid "(:c:member:`~PyTypeObject.tp_dictoffset`)"
msgstr "(:c:member:`~PyTypeObject.tp_dictoffset`)"

#: ../../c-api/typeobj.rst:122
msgid ":c:member:`~PyTypeObject.tp_init`"
msgstr ":c:member:`~PyTypeObject.tp_init`"

#: ../../c-api/typeobj.rst:122 ../../c-api/typeobj.rst:363
msgid ":c:type:`initproc`"
msgstr ":c:type:`initproc`"

#: ../../c-api/typeobj.rst:122
msgid "__init__"
msgstr "__init__"

#: ../../c-api/typeobj.rst:124
msgid ":c:member:`~PyTypeObject.tp_alloc`"
msgstr ":c:member:`~PyTypeObject.tp_alloc`"

#: ../../c-api/typeobj.rst:124 ../../c-api/typeobj.rst:342
msgid ":c:type:`allocfunc`"
msgstr ":c:type:`allocfunc`"

#: ../../c-api/typeobj.rst:126
msgid ":c:member:`~PyTypeObject.tp_new`"
msgstr ":c:member:`~PyTypeObject.tp_new`"

#: ../../c-api/typeobj.rst:126 ../../c-api/typeobj.rst:357
msgid ":c:type:`newfunc`"
msgstr ":c:type:`newfunc`"

#: ../../c-api/typeobj.rst:126
msgid "__new__"
msgstr "__new__"

#: ../../c-api/typeobj.rst:128
msgid ":c:member:`~PyTypeObject.tp_free`"
msgstr ":c:member:`~PyTypeObject.tp_free`"

#: ../../c-api/typeobj.rst:128 ../../c-api/typeobj.rst:349
msgid ":c:type:`freefunc`"
msgstr ":c:type:`freefunc`"

#: ../../c-api/typeobj.rst:130
msgid ":c:member:`~PyTypeObject.tp_is_gc`"
msgstr ":c:member:`~PyTypeObject.tp_is_gc`"

#: ../../c-api/typeobj.rst:132
msgid "<:c:member:`~PyTypeObject.tp_bases`>"
msgstr "<:c:member:`~PyTypeObject.tp_bases`>"

#: ../../c-api/typeobj.rst:132
msgid "__bases__"
msgstr "__bases__"

#: ../../c-api/typeobj.rst:132 ../../c-api/typeobj.rst:134
msgid "~"
msgstr "~"

#: ../../c-api/typeobj.rst:134
msgid "<:c:member:`~PyTypeObject.tp_mro`>"
msgstr "<:c:member:`~PyTypeObject.tp_mro`>"

#: ../../c-api/typeobj.rst:134
msgid "__mro__"
msgstr "__mro__"

#: ../../c-api/typeobj.rst:136
msgid "[:c:member:`~PyTypeObject.tp_cache`]"
msgstr "[:c:member:`~PyTypeObject.tp_cache`]"

#: ../../c-api/typeobj.rst:138
msgid "[:c:member:`~PyTypeObject.tp_subclasses`]"
msgstr "[:c:member:`~PyTypeObject.tp_subclasses`]"

#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:138
#: ../../c-api/typeobj.rst:279 ../../c-api/typeobj.rst:349
msgid "void *"
msgstr "void *"

#: ../../c-api/typeobj.rst:138
msgid "__subclasses__"
msgstr "__subclasses__"

#: ../../c-api/typeobj.rst:140
msgid "[:c:member:`~PyTypeObject.tp_weaklist`]"
msgstr "[:c:member:`~PyTypeObject.tp_weaklist`]"

#: ../../c-api/typeobj.rst:142
msgid "(:c:member:`~PyTypeObject.tp_del`)"
msgstr "(:c:member:`~PyTypeObject.tp_del`)"

#: ../../c-api/typeobj.rst:144
msgid "[:c:member:`~PyTypeObject.tp_version_tag`]"
msgstr "[:c:member:`~PyTypeObject.tp_version_tag`]"

#: ../../c-api/typeobj.rst:144
msgid "unsigned int"
msgstr "int sin firmar"

#: ../../c-api/typeobj.rst:146
msgid ":c:member:`~PyTypeObject.tp_finalize`"
msgstr ":c:member:`~PyTypeObject.tp_finalize`"

#: ../../c-api/typeobj.rst:146
msgid "__del__"
msgstr "__del__"

#: ../../c-api/typeobj.rst:148
msgid ":c:member:`~PyTypeObject.tp_vectorcall`"
msgstr ":c:member:`~PyTypeObject.tp_vectorcall`"

#: ../../c-api/typeobj.rst:148
msgid ":c:type:`vectorcallfunc`"
msgstr ":c:type:`vectorcallfunc`"

#: ../../c-api/typeobj.rst:150
msgid "[:c:member:`~PyTypeObject.tp_watched`]"
msgstr "[:c:member:`~PyTypeObject.tp_watched`]"

#: ../../c-api/typeobj.rst:150
msgid "unsigned char"
msgstr "unsigned char"

#: ../../c-api/typeobj.rst:155
msgid ""
"**()**: A slot name in parentheses indicates it is (effectively) deprecated."
msgstr ""
"**()**: имя слота в круглых скобках указывает на то, что он (фактически) "
"устарел."

#: ../../c-api/typeobj.rst:157
msgid ""
"**<>**: Names in angle brackets should be initially set to ``NULL`` and "
"treated as read-only."
msgstr ""
"*<>**: Имена в угловых скобках должны изначально иметь значение ``NULL`` и "
"рассматриваться как доступные только для чтения."

#: ../../c-api/typeobj.rst:160
msgid "**[]**: Names in square brackets are for internal use only."
msgstr ""
"**[]**: Имена в квадратных скобках предназначены только для внутреннего "
"использования."

#: ../../c-api/typeobj.rst:162
msgid ""
"**<R>** (as a prefix) means the field is required (must be non-``NULL``)."
msgstr ""
"**<R>** (в качестве префикса) означает, что поле является обязательным (не "
"должно иметь значение NULL)."

#: ../../c-api/typeobj.rst:164
msgid "Columns:"
msgstr "Columnas:"

#: ../../c-api/typeobj.rst:166
msgid "**\"O\"**:  set on :c:data:`PyBaseObject_Type`"
msgstr "**\"O\"**: установлено в :c:data:`PyBaseObject_Type`"

#: ../../c-api/typeobj.rst:168
msgid "**\"T\"**:  set on :c:data:`PyType_Type`"
msgstr "**\"T\"**: установлено в :c:data:`PyType_Type`"

#: ../../c-api/typeobj.rst:170
msgid "**\"D\"**:  default (if slot is set to ``NULL``)"
msgstr "**\"D \"**: por defecto (si la ranura está configurada en ``NULL``)"

#: ../../c-api/typeobj.rst:172
msgid ""
"X - PyType_Ready sets this value if it is NULL\n"
"~ - PyType_Ready always sets this value (it should be NULL)\n"
"? - PyType_Ready may set this value depending on other slots\n"
"\n"
"Also see the inheritance column (\"I\")."
msgstr ""
"X — PyType_Ready устанавливает это значение, если оно равно NULL. ~ — "
"PyType_Ready всегда устанавливает это значение (оно должно быть NULL) ? - "
"PyType_Ready может установить это значение в зависимости от других слотов. "
"Также см. столбец наследования («I»)."

#: ../../c-api/typeobj.rst:180
msgid "**\"I\"**:  inheritance"
msgstr "**\"I \"**: herencia"

#: ../../c-api/typeobj.rst:182
msgid ""
"X - type slot is inherited via *PyType_Ready* if defined with a *NULL* "
"value\n"
"% - the slots of the sub-struct are inherited individually\n"
"G - inherited, but only in combination with other slots; see the slot's "
"description\n"
"? - it's complicated; see the slot's description"
msgstr ""
"X - type slot is inherited via *PyType_Ready* if defined with a *NULL* "
"value\n"
"% - the slots of the sub-struct are inherited individually\n"
"G - inherited, but only in combination with other slots; see the slot's "
"description\n"
"? - it's complicated; see the slot's description"

#: ../../c-api/typeobj.rst:189
msgid ""
"Note that some slots are effectively inherited through the normal attribute "
"lookup chain."
msgstr ""
"Tener en cuenta que algunas ranuras se heredan a través de la cadena normal "
"de búsqueda de atributos."

#: ../../c-api/typeobj.rst:195
msgid "sub-slots"
msgstr "sub-slots"

#: ../../c-api/typeobj.rst:201
msgid "Slot"
msgstr "Slot"

#: ../../c-api/typeobj.rst:201
msgid "special methods"
msgstr "métodos especiales"

#: ../../c-api/typeobj.rst:204
msgid ":c:member:`~PyAsyncMethods.am_await`"
msgstr ":c:member:`~PyAsyncMethods.am_await`"

#: ../../c-api/typeobj.rst:204 ../../c-api/typeobj.rst:206
#: ../../c-api/typeobj.rst:208 ../../c-api/typeobj.rst:242
#: ../../c-api/typeobj.rst:244 ../../c-api/typeobj.rst:246
#: ../../c-api/typeobj.rst:250 ../../c-api/typeobj.rst:277
#: ../../c-api/typeobj.rst:281 ../../c-api/typeobj.rst:291
#: ../../c-api/typeobj.rst:432
msgid ":c:type:`unaryfunc`"
msgstr ":c:type:`unaryfunc`"

#: ../../c-api/typeobj.rst:204
msgid "__await__"
msgstr "__await__"

#: ../../c-api/typeobj.rst:206
msgid ":c:member:`~PyAsyncMethods.am_aiter`"
msgstr ":c:member:`~PyAsyncMethods.am_aiter`"

#: ../../c-api/typeobj.rst:206
msgid "__aiter__"
msgstr "__aiter__"

#: ../../c-api/typeobj.rst:208
msgid ":c:member:`~PyAsyncMethods.am_anext`"
msgstr ":c:member:`~PyAsyncMethods.am_anext`"

#: ../../c-api/typeobj.rst:208
msgid "__anext__"
msgstr "__anext__"

#: ../../c-api/typeobj.rst:210
msgid ":c:member:`~PyAsyncMethods.am_send`"
msgstr ":c:member:`~PyAsyncMethods.am_send`"

#: ../../c-api/typeobj.rst:210
msgid ":c:type:`sendfunc`"
msgstr ":c:type:`sendfunc`"

#: ../../c-api/typeobj.rst:214
msgid ":c:member:`~PyNumberMethods.nb_add`"
msgstr ":c:member:`~PyNumberMethods.nb_add`"

#: ../../c-api/typeobj.rst:214 ../../c-api/typeobj.rst:217
#: ../../c-api/typeobj.rst:219 ../../c-api/typeobj.rst:222
#: ../../c-api/typeobj.rst:224 ../../c-api/typeobj.rst:227
#: ../../c-api/typeobj.rst:229 ../../c-api/typeobj.rst:232
#: ../../c-api/typeobj.rst:234 ../../c-api/typeobj.rst:252
#: ../../c-api/typeobj.rst:255 ../../c-api/typeobj.rst:257
#: ../../c-api/typeobj.rst:260 ../../c-api/typeobj.rst:262
#: ../../c-api/typeobj.rst:265 ../../c-api/typeobj.rst:267
#: ../../c-api/typeobj.rst:270 ../../c-api/typeobj.rst:272
#: ../../c-api/typeobj.rst:275 ../../c-api/typeobj.rst:283
#: ../../c-api/typeobj.rst:285 ../../c-api/typeobj.rst:287
#: ../../c-api/typeobj.rst:289 ../../c-api/typeobj.rst:293
#: ../../c-api/typeobj.rst:296 ../../c-api/typeobj.rst:302
#: ../../c-api/typeobj.rst:311 ../../c-api/typeobj.rst:322
#: ../../c-api/typeobj.rst:436
msgid ":c:type:`binaryfunc`"
msgstr ":c:type:`binaryfunc`"

#: ../../c-api/typeobj.rst:214
msgid "__add__ __radd__"
msgstr "__add__ __radd__"

#: ../../c-api/typeobj.rst:217
msgid ":c:member:`~PyNumberMethods.nb_inplace_add`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_add`"

#: ../../c-api/typeobj.rst:217 ../../c-api/typeobj.rst:322
msgid "__iadd__"
msgstr "__iadd__"

#: ../../c-api/typeobj.rst:219
msgid ":c:member:`~PyNumberMethods.nb_subtract`"
msgstr ":c:member:`~PyNumberMethods.nb_subtract`"

#: ../../c-api/typeobj.rst:219
msgid "__sub__ __rsub__"
msgstr "__sub__ __rsub__"

#: ../../c-api/typeobj.rst:222
msgid ":c:member:`~PyNumberMethods.nb_inplace_subtract`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_subtract`"

#: ../../c-api/typeobj.rst:222
msgid "__isub__"
msgstr "__isub__"

#: ../../c-api/typeobj.rst:224
msgid ":c:member:`~PyNumberMethods.nb_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_multiply`"

#: ../../c-api/typeobj.rst:224
msgid "__mul__ __rmul__"
msgstr "__mul__ __rmul__"

#: ../../c-api/typeobj.rst:227
msgid ":c:member:`~PyNumberMethods.nb_inplace_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_multiply`"

#: ../../c-api/typeobj.rst:227 ../../c-api/typeobj.rst:324
msgid "__imul__"
msgstr "__imul__"

#: ../../c-api/typeobj.rst:229
msgid ":c:member:`~PyNumberMethods.nb_remainder`"
msgstr ":c:member:`~PyNumberMethods.nb_remainder`"

#: ../../c-api/typeobj.rst:229
msgid "__mod__ __rmod__"
msgstr "__mod__ __rmod__"

#: ../../c-api/typeobj.rst:232
msgid ":c:member:`~PyNumberMethods.nb_inplace_remainder`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_remainder`"

#: ../../c-api/typeobj.rst:232
msgid "__imod__"
msgstr "__imod__"

#: ../../c-api/typeobj.rst:234
msgid ":c:member:`~PyNumberMethods.nb_divmod`"
msgstr ":c:member:`~PyNumberMethods.nb_divmod`"

#: ../../c-api/typeobj.rst:234
msgid "__divmod__ __rdivmod__"
msgstr "__divmod__ __rdivmod__"

#: ../../c-api/typeobj.rst:237
msgid ":c:member:`~PyNumberMethods.nb_power`"
msgstr ":c:member:`~PyNumberMethods.nb_power`"

#: ../../c-api/typeobj.rst:237
msgid "__pow__ __rpow__"
msgstr "__pow__ __rpow__"

#: ../../c-api/typeobj.rst:240
msgid ":c:member:`~PyNumberMethods.nb_inplace_power`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_power`"

#: ../../c-api/typeobj.rst:240
msgid "__ipow__"
msgstr "__ipow__"

#: ../../c-api/typeobj.rst:242
msgid ":c:member:`~PyNumberMethods.nb_negative`"
msgstr ":c:member:`~PyNumberMethods.nb_negative`"

#: ../../c-api/typeobj.rst:242
msgid "__neg__"
msgstr "__neg__"

#: ../../c-api/typeobj.rst:244
msgid ":c:member:`~PyNumberMethods.nb_positive`"
msgstr ":c:member:`~PyNumberMethods.nb_positive`"

#: ../../c-api/typeobj.rst:244
msgid "__pos__"
msgstr "__pos__"

#: ../../c-api/typeobj.rst:246
msgid ":c:member:`~PyNumberMethods.nb_absolute`"
msgstr ":c:member:`~PyNumberMethods.nb_absolute`"

#: ../../c-api/typeobj.rst:246
msgid "__abs__"
msgstr "__abs__"

#: ../../c-api/typeobj.rst:248
msgid ":c:member:`~PyNumberMethods.nb_bool`"
msgstr ":c:member:`~PyNumberMethods.nb_bool`"

#: ../../c-api/typeobj.rst:248
msgid "__bool__"
msgstr "__bool__"

#: ../../c-api/typeobj.rst:250
msgid ":c:member:`~PyNumberMethods.nb_invert`"
msgstr ":c:member:`~PyNumberMethods.nb_invert`"

#: ../../c-api/typeobj.rst:250
msgid "__invert__"
msgstr "__invert__"

#: ../../c-api/typeobj.rst:252
msgid ":c:member:`~PyNumberMethods.nb_lshift`"
msgstr ":c:member:`~PyNumberMethods.nb_lshift`"

#: ../../c-api/typeobj.rst:252
msgid "__lshift__ __rlshift__"
msgstr "__lshift__ __rlshift__"

#: ../../c-api/typeobj.rst:255
msgid ":c:member:`~PyNumberMethods.nb_inplace_lshift`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_lshift`"

#: ../../c-api/typeobj.rst:255
msgid "__ilshift__"
msgstr "__ilshift__"

#: ../../c-api/typeobj.rst:257
msgid ":c:member:`~PyNumberMethods.nb_rshift`"
msgstr ":c:member:`~PyNumberMethods.nb_rshift`"

#: ../../c-api/typeobj.rst:257
msgid "__rshift__ __rrshift__"
msgstr "__rshift__ __rrshift__"

#: ../../c-api/typeobj.rst:260
msgid ":c:member:`~PyNumberMethods.nb_inplace_rshift`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_rshift`"

#: ../../c-api/typeobj.rst:260
msgid "__irshift__"
msgstr "__irshift__"

#: ../../c-api/typeobj.rst:262
msgid ":c:member:`~PyNumberMethods.nb_and`"
msgstr ":c:member:`~PyNumberMethods.nb_and`"

#: ../../c-api/typeobj.rst:262
msgid "__and__ __rand__"
msgstr "__and__ __rand__"

#: ../../c-api/typeobj.rst:265
msgid ":c:member:`~PyNumberMethods.nb_inplace_and`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_and`"

#: ../../c-api/typeobj.rst:265
msgid "__iand__"
msgstr "__iand__"

#: ../../c-api/typeobj.rst:267
msgid ":c:member:`~PyNumberMethods.nb_xor`"
msgstr ":c:member:`~PyNumberMethods.nb_xor`"

#: ../../c-api/typeobj.rst:267
msgid "__xor__ __rxor__"
msgstr "__xor__ __rxor__"

#: ../../c-api/typeobj.rst:270
msgid ":c:member:`~PyNumberMethods.nb_inplace_xor`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_xor`"

#: ../../c-api/typeobj.rst:270
msgid "__ixor__"
msgstr "__ixor__"

#: ../../c-api/typeobj.rst:272
msgid ":c:member:`~PyNumberMethods.nb_or`"
msgstr ":c:member:`~PyNumberMethods.nb_or`"

#: ../../c-api/typeobj.rst:272
msgid "__or__ __ror__"
msgstr "__or__ __ror__"

#: ../../c-api/typeobj.rst:275
msgid ":c:member:`~PyNumberMethods.nb_inplace_or`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_or`"

#: ../../c-api/typeobj.rst:275
msgid "__ior__"
msgstr "__ior__"

#: ../../c-api/typeobj.rst:277
msgid ":c:member:`~PyNumberMethods.nb_int`"
msgstr ":c:member:`~PyNumberMethods.nb_int`"

#: ../../c-api/typeobj.rst:277
msgid "__int__"
msgstr "__int__"

#: ../../c-api/typeobj.rst:279
msgid ":c:member:`~PyNumberMethods.nb_reserved`"
msgstr ":c:member:`~PyNumberMethods.nb_reserved`"

#: ../../c-api/typeobj.rst:281
msgid ":c:member:`~PyNumberMethods.nb_float`"
msgstr ":c:member:`~PyNumberMethods.nb_float`"

#: ../../c-api/typeobj.rst:281
msgid "__float__"
msgstr "__float__"

#: ../../c-api/typeobj.rst:283
msgid ":c:member:`~PyNumberMethods.nb_floor_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_floor_divide`"

#: ../../c-api/typeobj.rst:283
msgid "__floordiv__"
msgstr "__floordiv__"

#: ../../c-api/typeobj.rst:285
msgid ":c:member:`~PyNumberMethods.nb_inplace_floor_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_floor_divide`"

#: ../../c-api/typeobj.rst:285
msgid "__ifloordiv__"
msgstr "__ifloordiv__"

#: ../../c-api/typeobj.rst:287
msgid ":c:member:`~PyNumberMethods.nb_true_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_true_divide`"

#: ../../c-api/typeobj.rst:287
msgid "__truediv__"
msgstr "__truediv__"

#: ../../c-api/typeobj.rst:289
msgid ":c:member:`~PyNumberMethods.nb_inplace_true_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_true_divide`"

#: ../../c-api/typeobj.rst:289
msgid "__itruediv__"
msgstr "__itruediv__"

#: ../../c-api/typeobj.rst:291
msgid ":c:member:`~PyNumberMethods.nb_index`"
msgstr ":c:member:`~PyNumberMethods.nb_index`"

#: ../../c-api/typeobj.rst:291
msgid "__index__"
msgstr "__index__"

#: ../../c-api/typeobj.rst:293
msgid ":c:member:`~PyNumberMethods.nb_matrix_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_matrix_multiply`"

#: ../../c-api/typeobj.rst:293
msgid "__matmul__ __rmatmul__"
msgstr "__matmul__ __rmatmul__"

#: ../../c-api/typeobj.rst:296
msgid ":c:member:`~PyNumberMethods.nb_inplace_matrix_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_matrix_multiply`"

#: ../../c-api/typeobj.rst:296
msgid "__imatmul__"
msgstr "__imatmul__"

#: ../../c-api/typeobj.rst:300
msgid ":c:member:`~PyMappingMethods.mp_length`"
msgstr ":c:member:`~PyMappingMethods.mp_length`"

#: ../../c-api/typeobj.rst:300 ../../c-api/typeobj.rst:309
#: ../../c-api/typeobj.rst:417
msgid ":c:type:`lenfunc`"
msgstr ":c:type:`lenfunc`"

#: ../../c-api/typeobj.rst:300 ../../c-api/typeobj.rst:309
msgid "__len__"
msgstr "__len__"

#: ../../c-api/typeobj.rst:302
msgid ":c:member:`~PyMappingMethods.mp_subscript`"
msgstr ":c:member:`~PyMappingMethods.mp_subscript`"

#: ../../c-api/typeobj.rst:302 ../../c-api/typeobj.rst:315
msgid "__getitem__"
msgstr "__getitem__"

#: ../../c-api/typeobj.rst:304
msgid ":c:member:`~PyMappingMethods.mp_ass_subscript`"
msgstr ":c:member:`~PyMappingMethods.mp_ass_subscript`"

#: ../../c-api/typeobj.rst:304 ../../c-api/typeobj.rst:463
msgid ":c:type:`objobjargproc`"
msgstr ":c:type:`objobjargproc`"

#: ../../c-api/typeobj.rst:304
msgid "__setitem__, __delitem__"
msgstr "__setitem__, __delitem__"

#: ../../c-api/typeobj.rst:309
msgid ":c:member:`~PySequenceMethods.sq_length`"
msgstr ":c:member:`~PySequenceMethods.sq_length`"

#: ../../c-api/typeobj.rst:311
msgid ":c:member:`~PySequenceMethods.sq_concat`"
msgstr ":c:member:`~PySequenceMethods.sq_concat`"

#: ../../c-api/typeobj.rst:311
msgid "__add__"
msgstr "__add__"

#: ../../c-api/typeobj.rst:313
msgid ":c:member:`~PySequenceMethods.sq_repeat`"
msgstr ":c:member:`~PySequenceMethods.sq_repeat`"

#: ../../c-api/typeobj.rst:313 ../../c-api/typeobj.rst:315
#: ../../c-api/typeobj.rst:324 ../../c-api/typeobj.rst:447
msgid ":c:type:`ssizeargfunc`"
msgstr ":c:type:`ssizeargfunc`"

#: ../../c-api/typeobj.rst:313
msgid "__mul__"
msgstr "__mul__"

#: ../../c-api/typeobj.rst:315
msgid ":c:member:`~PySequenceMethods.sq_item`"
msgstr ":c:member:`~PySequenceMethods.sq_item`"

#: ../../c-api/typeobj.rst:317
msgid ":c:member:`~PySequenceMethods.sq_ass_item`"
msgstr ":c:member:`~PySequenceMethods.sq_ass_item`"

#: ../../c-api/typeobj.rst:317 ../../c-api/typeobj.rst:452
msgid ":c:type:`ssizeobjargproc`"
msgstr ":c:type:`ssizeobjargproc`"

#: ../../c-api/typeobj.rst:317
msgid "__setitem__ __delitem__"
msgstr "__setitem__ __delitem__"

#: ../../c-api/typeobj.rst:320
msgid ":c:member:`~PySequenceMethods.sq_contains`"
msgstr ":c:member:`~PySequenceMethods.sq_contains`"

#: ../../c-api/typeobj.rst:320 ../../c-api/typeobj.rst:458
msgid ":c:type:`objobjproc`"
msgstr ":c:type:`objobjproc`"

#: ../../c-api/typeobj.rst:320
msgid "__contains__"
msgstr "__contains__"

#: ../../c-api/typeobj.rst:322
msgid ":c:member:`~PySequenceMethods.sq_inplace_concat`"
msgstr ":c:member:`~PySequenceMethods.sq_inplace_concat`"

#: ../../c-api/typeobj.rst:324
msgid ":c:member:`~PySequenceMethods.sq_inplace_repeat`"
msgstr ":c:member:`~PySequenceMethods.sq_inplace_repeat`"

#: ../../c-api/typeobj.rst:328
msgid ":c:member:`~PyBufferProcs.bf_getbuffer`"
msgstr ":c:member:`~PyBufferProcs.bf_getbuffer`"

#: ../../c-api/typeobj.rst:328
msgid ":c:func:`getbufferproc`"
msgstr ":c:func:`getbufferproc`"

#: ../../c-api/typeobj.rst:328
msgid "__buffer__"
msgstr "__buffer__"

#: ../../c-api/typeobj.rst:330
msgid ":c:member:`~PyBufferProcs.bf_releasebuffer`"
msgstr ":c:member:`~PyBufferProcs.bf_releasebuffer`"

#: ../../c-api/typeobj.rst:330
msgid ":c:func:`releasebufferproc`"
msgstr ":c:func:`releasebufferproc`"

#: ../../c-api/typeobj.rst:330
msgid "__release_\\ buffer\\__"
msgstr "__release_\\ buffer\\__"

#: ../../c-api/typeobj.rst:337
msgid "slot typedefs"
msgstr "tipos de ranura"

#: ../../c-api/typeobj.rst:340
msgid "typedef"
msgstr "typedef"

#: ../../c-api/typeobj.rst:340
msgid "Parameter Types"
msgstr "Tipos de parámetros"

#: ../../c-api/typeobj.rst:340
msgid "Return Type"
msgstr "Tipo de retorno"

#: ../../c-api/typeobj.rst:347 ../../c-api/typeobj.rst:349
#: ../../c-api/typeobj.rst:425
msgid "void"
msgstr "void"

#: ../../c-api/typeobj.rst:0
msgid ":c:type:`visitproc`"
msgstr ":c:type:`visitproc`"

#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:351
#: ../../c-api/typeobj.rst:363 ../../c-api/typeobj.rst:376
#: ../../c-api/typeobj.rst:387 ../../c-api/typeobj.rst:399
#: ../../c-api/typeobj.rst:419 ../../c-api/typeobj.rst:430
#: ../../c-api/typeobj.rst:452 ../../c-api/typeobj.rst:458
#: ../../c-api/typeobj.rst:463
msgid "int"
msgstr "int"

#: ../../c-api/typeobj.rst:405
msgid "Py_hash_t"
msgstr "Py_hash_t"

#: ../../c-api/typeobj.rst:419
msgid ":c:type:`getbufferproc`"
msgstr ":c:type:`getbufferproc`"

#: ../../c-api/typeobj.rst:0
msgid ":c:type:`Py_buffer` *"
msgstr ":c:type:`Py_buffer` *"

#: ../../c-api/typeobj.rst:425
msgid ":c:type:`releasebufferproc`"
msgstr ":c:type:`releasebufferproc`"

#: ../../c-api/typeobj.rst:470
msgid "See :ref:`slot-typedefs` below for more detail."
msgstr "Ver a continuación para más detalles :ref:`slot-typedefs`."

#: ../../c-api/typeobj.rst:474
msgid "PyTypeObject Definition"
msgstr "Definición de PyTypeObject"

#: ../../c-api/typeobj.rst:476
msgid ""
"The structure definition for :c:type:`PyTypeObject` can be found in :file:"
"`Include/cpython/object.h`.  For convenience of reference, this repeats the "
"definition found there:"
msgstr ""
"Определение структуры для :c:type:`PyTypeObject` можно найти в :file:"
"`Include/cpython/object.h`. Для удобства ссылки, это повторяет определение, "
"найденное там:"

#: ../../c-api/typeobj.rst:482
msgid ""
"typedef struct _typeobject {\n"
"    PyObject_VAR_HEAD\n"
"    const char *tp_name; /* For printing, in format \"<module>.<name>\" */\n"
"    Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */\n"
"\n"
"    /* Methods to implement standard operations */\n"
"\n"
"    destructor tp_dealloc;\n"
"    Py_ssize_t tp_vectorcall_offset;\n"
"    getattrfunc tp_getattr;\n"
"    setattrfunc tp_setattr;\n"
"    PyAsyncMethods *tp_as_async; /* formerly known as tp_compare (Python 2)\n"
"                                    or tp_reserved (Python 3) */\n"
"    reprfunc tp_repr;\n"
"\n"
"    /* Method suites for standard classes */\n"
"\n"
"    PyNumberMethods *tp_as_number;\n"
"    PySequenceMethods *tp_as_sequence;\n"
"    PyMappingMethods *tp_as_mapping;\n"
"\n"
"    /* More standard operations (here for binary compatibility) */\n"
"\n"
"    hashfunc tp_hash;\n"
"    ternaryfunc tp_call;\n"
"    reprfunc tp_str;\n"
"    getattrofunc tp_getattro;\n"
"    setattrofunc tp_setattro;\n"
"\n"
"    /* Functions to access object as input/output buffer */\n"
"    PyBufferProcs *tp_as_buffer;\n"
"\n"
"    /* Flags to define presence of optional/expanded features */\n"
"    unsigned long tp_flags;\n"
"\n"
"    const char *tp_doc; /* Documentation string */\n"
"\n"
"    /* Assigned meaning in release 2.0 */\n"
"    /* call function for all accessible objects */\n"
"    traverseproc tp_traverse;\n"
"\n"
"    /* delete references to contained objects */\n"
"    inquiry tp_clear;\n"
"\n"
"    /* Assigned meaning in release 2.1 */\n"
"    /* rich comparisons */\n"
"    richcmpfunc tp_richcompare;\n"
"\n"
"    /* weak reference enabler */\n"
"    Py_ssize_t tp_weaklistoffset;\n"
"\n"
"    /* Iterators */\n"
"    getiterfunc tp_iter;\n"
"    iternextfunc tp_iternext;\n"
"\n"
"    /* Attribute descriptor and subclassing stuff */\n"
"    struct PyMethodDef *tp_methods;\n"
"    struct PyMemberDef *tp_members;\n"
"    struct PyGetSetDef *tp_getset;\n"
"    // Strong reference on a heap type, borrowed reference on a static type\n"
"    struct _typeobject *tp_base;\n"
"    PyObject *tp_dict;\n"
"    descrgetfunc tp_descr_get;\n"
"    descrsetfunc tp_descr_set;\n"
"    Py_ssize_t tp_dictoffset;\n"
"    initproc tp_init;\n"
"    allocfunc tp_alloc;\n"
"    newfunc tp_new;\n"
"    freefunc tp_free; /* Low-level free-memory routine */\n"
"    inquiry tp_is_gc; /* For PyObject_IS_GC */\n"
"    PyObject *tp_bases;\n"
"    PyObject *tp_mro; /* method resolution order */\n"
"    PyObject *tp_cache;\n"
"    PyObject *tp_subclasses;\n"
"    PyObject *tp_weaklist;\n"
"    destructor tp_del;\n"
"\n"
"    /* Type attribute cache version tag. Added in version 2.6 */\n"
"    unsigned int tp_version_tag;\n"
"\n"
"    destructor tp_finalize;\n"
"    vectorcallfunc tp_vectorcall;\n"
"\n"
"    /* bitset of which type-watchers care about this type */\n"
"    unsigned char tp_watched;\n"
"} PyTypeObject;\n"
msgstr ""

#: ../../c-api/typeobj.rst:486
msgid "PyObject Slots"
msgstr "Ranuras PyObject"

#: ../../c-api/typeobj.rst:488
msgid ""
"The type object structure extends the :c:type:`PyVarObject` structure. The :"
"c:member:`~PyVarObject.ob_size` field is used for dynamic types (created by :"
"c:func:`!type_new`, usually called from a class statement). Note that :c:"
"data:`PyType_Type` (the metatype) initializes :c:member:`~PyTypeObject."
"tp_itemsize`, which means that its instances (i.e. type objects) *must* have "
"the :c:member:`~PyVarObject.ob_size` field."
msgstr ""
"Структура объекта типа расширяет структуру :c:type:`PyVarObject`. Поле :c:"
"member:`~PyVarObject.ob_size` используется для динамических типов "
"(создаваемых :c:func:`!type_new`, обычно вызываемых из оператора класса). "
"Обратите внимание, что :c:data:`PyType_Type` (метатип) инициализирует :c:"
"member:`~PyTypeObject.tp_itemsize`, что означает, что его экземпляры (т.е. "
"объекты типа) *должны* иметь :c:member:`~PyVarObject Поле .ob_size`."

#: ../../c-api/typeobj.rst:497
msgid ""
"This is the type object's reference count, initialized to ``1`` by the "
"``PyObject_HEAD_INIT`` macro.  Note that for :ref:`statically allocated type "
"objects <static-types>`, the type's instances (objects whose :c:member:"
"`~PyObject.ob_type` points back to the type) do *not* count as references.  "
"But for :ref:`dynamically allocated type objects <heap-types>`, the "
"instances *do* count as references."
msgstr ""

#: ../../c-api/typeobj.rst:504 ../../c-api/typeobj.rst:527
#: ../../c-api/typeobj.rst:544 ../../c-api/typeobj.rst:588
#: ../../c-api/typeobj.rst:666 ../../c-api/typeobj.rst:742
#: ../../c-api/typeobj.rst:783 ../../c-api/typeobj.rst:800
#: ../../c-api/typeobj.rst:817 ../../c-api/typeobj.rst:835
#: ../../c-api/typeobj.rst:859 ../../c-api/typeobj.rst:876
#: ../../c-api/typeobj.rst:888 ../../c-api/typeobj.rst:900
#: ../../c-api/typeobj.rst:933 ../../c-api/typeobj.rst:955
#: ../../c-api/typeobj.rst:975 ../../c-api/typeobj.rst:996
#: ../../c-api/typeobj.rst:1022 ../../c-api/typeobj.rst:1041
#: ../../c-api/typeobj.rst:1057 ../../c-api/typeobj.rst:1096
#: ../../c-api/typeobj.rst:1107 ../../c-api/typeobj.rst:1117
#: ../../c-api/typeobj.rst:1127 ../../c-api/typeobj.rst:1141
#: ../../c-api/typeobj.rst:1159 ../../c-api/typeobj.rst:1182
#: ../../c-api/typeobj.rst:1200 ../../c-api/typeobj.rst:1213
#: ../../c-api/typeobj.rst:1235 ../../c-api/typeobj.rst:1279
#: ../../c-api/typeobj.rst:1300 ../../c-api/typeobj.rst:1319
#: ../../c-api/typeobj.rst:1349 ../../c-api/typeobj.rst:1371
#: ../../c-api/typeobj.rst:1397 ../../c-api/typeobj.rst:1482
#: ../../c-api/typeobj.rst:1556 ../../c-api/typeobj.rst:1617
#: ../../c-api/typeobj.rst:1653 ../../c-api/typeobj.rst:1678
#: ../../c-api/typeobj.rst:1701 ../../c-api/typeobj.rst:1714
#: ../../c-api/typeobj.rst:1729 ../../c-api/typeobj.rst:1743
#: ../../c-api/typeobj.rst:1773 ../../c-api/typeobj.rst:1805
#: ../../c-api/typeobj.rst:1831 ../../c-api/typeobj.rst:1849
#: ../../c-api/typeobj.rst:1878 ../../c-api/typeobj.rst:1922
#: ../../c-api/typeobj.rst:1939 ../../c-api/typeobj.rst:1980
#: ../../c-api/typeobj.rst:2002 ../../c-api/typeobj.rst:2034
#: ../../c-api/typeobj.rst:2062 ../../c-api/typeobj.rst:2075
#: ../../c-api/typeobj.rst:2085 ../../c-api/typeobj.rst:2102
#: ../../c-api/typeobj.rst:2119 ../../c-api/typeobj.rst:2133
#: ../../c-api/typeobj.rst:2166 ../../c-api/typeobj.rst:2189
msgid "**Inheritance:**"
msgstr "**Herencia:**"

#: ../../c-api/typeobj.rst:506 ../../c-api/typeobj.rst:546
#: ../../c-api/typeobj.rst:590
msgid "This field is not inherited by subtypes."
msgstr "Este campo no lo heredan los subtipos."

#: ../../c-api/typeobj.rst:511
msgid ""
"This is the type's type, in other words its metatype.  It is initialized by "
"the argument to the ``PyObject_HEAD_INIT`` macro, and its value should "
"normally be ``&PyType_Type``.  However, for dynamically loadable extension "
"modules that must be usable on Windows (at least), the compiler complains "
"that this is not a valid initializer.  Therefore, the convention is to pass "
"``NULL`` to the ``PyObject_HEAD_INIT`` macro and to initialize this field "
"explicitly at the start of the module's initialization function, before "
"doing anything else.  This is typically done like this::"
msgstr ""
"Es el tipo del tipo, es decir, su metatipo.  Se inicializa mediante el "
"argumento de la macro ``PyObject_HEAD_INIT``, y su valor debería ser "
"normalmente ``&PyType_Type``.  Sin embargo, para los módulos de extensión "
"cargables dinámicamente que se deben utilizar en Windows (al menos), el "
"compilador se queja de que éste no es un inicializador válido.  Por lo "
"tanto, la convención es pasar ``NULL`` a la macro ``PyObject_HEAD_INIT`` e "
"inicializar este campo explícitamente al comienzo de la función de "
"inicialización del módulo, antes de hacer cualquier otra cosa.  Esto se hace "
"típicamente así::"

#: ../../c-api/typeobj.rst:520
msgid "Foo_Type.ob_type = &PyType_Type;"
msgstr "Foo_Type.ob_type = &PyType_Type;"

#: ../../c-api/typeobj.rst:522
msgid ""
"This should be done before any instances of the type are created. :c:func:"
"`PyType_Ready` checks if :c:member:`~PyObject.ob_type` is ``NULL``, and if "
"so, initializes it to the :c:member:`~PyObject.ob_type` field of the base "
"class. :c:func:`PyType_Ready` will not change this field if it is non-zero."
msgstr ""
"Это следует сделать до создания экземпляров типа. :c:func:`PyType_Ready` "
"проверяет, имеет ли :c:member:`~PyObject.ob_type` значение ``NULL``, и если "
"да, то инициализирует его значением поля :c:member:`~PyObject.ob_type` "
"базовый класс. :c:func:`PyType_Ready` не изменит это поле, если оно не равно "
"нулю."

#: ../../c-api/typeobj.rst:529 ../../c-api/typeobj.rst:744
#: ../../c-api/typeobj.rst:861 ../../c-api/typeobj.rst:957
#: ../../c-api/typeobj.rst:977 ../../c-api/typeobj.rst:1680
#: ../../c-api/typeobj.rst:1703 ../../c-api/typeobj.rst:1833
#: ../../c-api/typeobj.rst:1851 ../../c-api/typeobj.rst:1924
#: ../../c-api/typeobj.rst:2036 ../../c-api/typeobj.rst:2168
msgid "This field is inherited by subtypes."
msgstr "Este campo es heredado por los subtipos."

#: ../../c-api/typeobj.rst:533
msgid "PyVarObject Slots"
msgstr "Ranuras PyVarObject"

#: ../../c-api/typeobj.rst:537
msgid ""
"For :ref:`statically allocated type objects <static-types>`, this should be "
"initialized to zero. For :ref:`dynamically allocated type objects <heap-"
"types>`, this field has a special internal meaning."
msgstr ""
"Для :ref:`статично виділених об’єктів типу <static-types>`, це має бути "
"ініціалізовано нулем. Для :ref:`динамічно виділених об’єктів типу <heap-"
"types>` це поле має особливе внутрішнє значення."

#: ../../c-api/typeobj.rst:541
msgid ""
"This field should be accessed using the :c:func:`Py_SIZE()` and :c:func:"
"`Py_SET_SIZE()` macros."
msgstr ""

#: ../../c-api/typeobj.rst:550
msgid "PyTypeObject Slots"
msgstr "Ranuras PyTypeObject"

#: ../../c-api/typeobj.rst:552
msgid ""
"Each slot has a section describing inheritance.  If :c:func:`PyType_Ready` "
"may set a value when the field is set to ``NULL`` then there will also be a "
"\"Default\" section.  (Note that many fields set on :c:data:"
"`PyBaseObject_Type` and :c:data:`PyType_Type` effectively act as defaults.)"
msgstr ""
"В каждом слоте есть раздел, описывающий наследование. Если :c:func:"
"`PyType_Ready` может установить значение, когда поле установлено в ``NULL``, "
"тогда также будет раздел «По умолчанию». (Обратите внимание, что многие "
"поля, установленные в :c:data:`PyBaseObject_Type` и :c:data:`PyType_Type`, "
"фактически действуют как значения по умолчанию.)"

#: ../../c-api/typeobj.rst:559
msgid ""
"Pointer to a NUL-terminated string containing the name of the type. For "
"types that are accessible as module globals, the string should be the full "
"module name, followed by a dot, followed by the type name; for built-in "
"types, it should be just the type name.  If the module is a submodule of a "
"package, the full package name is part of the full module name.  For "
"example, a type named :class:`!T` defined in module :mod:`!M` in subpackage :"
"mod:`!Q` in package :mod:`!P` should have the :c:member:`~PyTypeObject."
"tp_name` initializer ``\"P.Q.M.T\"``."
msgstr ""
"Указатель на строку, завершающуюся NUL, содержащую имя типа. Для типов, "
"доступных как глобальные переменные модуля, строка должна представлять собой "
"полное имя модуля, за которым следует точка, за которой следует имя типа; "
"для встроенных типов это должно быть просто имя типа. Если модуль является "
"подмодулем пакета, полное имя пакета является частью полного имени модуля. "
"Например, тип с именем :class:`!T`, определенный в модуле :mod:`!M` в "
"подпакете :mod:`!Q` в пакете :mod:`!P`, должен иметь :c:member:` "
"~PyTypeObject.tp_name` инициализатор ``\"PQMT\"``."

#: ../../c-api/typeobj.rst:567
msgid ""
"For :ref:`dynamically allocated type objects <heap-types>`, this should just "
"be the type name, and the module name explicitly stored in the type dict as "
"the value for key ``'__module__'``."
msgstr ""
"Для :ref:`динамічно виділених об’єктів типу <heap-types>`, це має бути лише "
"ім’я типу, а ім’я модуля явно зберігається в dict типу як значення для ключа "
"``'__module__'``."

#: ../../c-api/typeobj.rst:572
msgid ""
"For :ref:`statically allocated type objects <static-types>`, the *tp_name* "
"field should contain a dot. Everything before the last dot is made "
"accessible as the :attr:`~type.__module__` attribute, and everything after "
"the last dot is made accessible as the :attr:`~type.__name__` attribute."
msgstr ""
"Для :ref:`статически выделенных объектов типа <static-types>` поле *tp_name* "
"должно содержать точку. Все, что находится до последней точки, доступно как "
"атрибут :attr:`~type.__module__`, а все, что после последней точки, доступно "
"как атрибут :attr:`~type.__name__`."

#: ../../c-api/typeobj.rst:578
msgid ""
"If no dot is present, the entire :c:member:`~PyTypeObject.tp_name` field is "
"made accessible as the :attr:`~type.__name__` attribute, and the :attr:"
"`~type.__module__` attribute is undefined (unless explicitly set in the "
"dictionary, as explained above).  This means your type will be impossible to "
"pickle.  Additionally, it will not be listed in module documentations "
"created with pydoc."
msgstr ""
"Если точка отсутствует, все поле :c:member:`~PyTypeObject.tp_name` "
"становится доступным как атрибут :attr:`~type.__name__`, а атрибут :attr:"
"`~type.__module__` не определен. (если явно не указано в словаре, как "
"описано выше). Это значит, что ваш тип будет невозможно замариновать. Кроме "
"того, он не будет указан в документации модуля, созданной с помощью pydoc."

#: ../../c-api/typeobj.rst:584
msgid ""
"This field must not be ``NULL``.  It is the only required field in :c:func:"
"`PyTypeObject` (other than potentially :c:member:`~PyTypeObject."
"tp_itemsize`)."
msgstr ""
"Este campo no debe ser ``NULL``. Es el único campo requerido en :c:func:"
"`PyTypeObject` (además de potencialmente :c:member:`~PyTypeObject."
"tp_itemsize`)."

#: ../../c-api/typeobj.rst:596
msgid ""
"These fields allow calculating the size in bytes of instances of the type."
msgstr ""
"Estos campos permiten calcular el tamaño en bytes de las instancias del tipo."

#: ../../c-api/typeobj.rst:598
msgid ""
"There are two kinds of types: types with fixed-length instances have a zero :"
"c:member:`!tp_itemsize` field, types with variable-length instances have a "
"non-zero :c:member:`!tp_itemsize` field.  For a type with fixed-length "
"instances, all instances have the same size, given in :c:member:`!"
"tp_basicsize`. (Exceptions to this rule can be made using :c:func:"
"`PyUnstable_Object_GC_NewWithExtraData`.)"
msgstr ""
"Существует два вида типов: типы с экземплярами фиксированной длины имеют "
"нулевое поле :c:member:`!tp_itemsize`, типы с экземплярами переменной длины "
"имеют ненулевое поле :c:member:`!tp_itemsize`. Для типа с экземплярами "
"фиксированной длины все экземпляры имеют одинаковый размер, заданный в :c:"
"member:`!tp_basicsize`. (Исключения из этого правила можно сделать с "
"помощью :c:func:`PyUnstable_Object_GC_NewWithExtraData`.)"

#: ../../c-api/typeobj.rst:605
msgid ""
"For a type with variable-length instances, the instances must have an :c:"
"member:`~PyVarObject.ob_size` field, and the instance size is :c:member:`!"
"tp_basicsize` plus N times :c:member:`!tp_itemsize`, where N is the "
"\"length\" of the object."
msgstr ""
"Для типа с экземплярами переменной длины экземпляры должны иметь поле :c:"
"member:`~PyVarObject.ob_size`, а размер экземпляра равен :c:member:`!"
"tp_basicsize` плюс N раз :c:member:`!tp_itemsize`, где N — «длина» объекта."

#: ../../c-api/typeobj.rst:610
msgid ""
"Functions like :c:func:`PyObject_NewVar` will take the value of N as an "
"argument, and store in the instance's :c:member:`~PyVarObject.ob_size` "
"field. Note that the :c:member:`~PyVarObject.ob_size` field may later be "
"used for other purposes. For example, :py:type:`int` instances use the bits "
"of :c:member:`~PyVarObject.ob_size` in an implementation-defined way; the "
"underlying storage and its size should be accessed using :c:func:"
"`PyLong_Export`."
msgstr ""
"Функции типа :c:func:`PyObject_NewVar` будут принимать значение N в качестве "
"аргумента и сохранять его в поле :c:member:`~PyVarObject.ob_size` "
"экземпляра. Обратите внимание, что поле :c:member:`~PyVarObject.ob_size` "
"может позже использоваться для других целей. Например, экземпляры :py:type:"
"`int` используют биты :c:member:`~PyVarObject.ob_size` способом, "
"определяемым реализацией; доступ к базовому хранилищу и его размеру следует "
"осуществлять с помощью :c:func:`PyLong_Export`."

#: ../../c-api/typeobj.rst:620
msgid ""
"The :c:member:`~PyVarObject.ob_size` field should be accessed using the :c:"
"func:`Py_SIZE()` and :c:func:`Py_SET_SIZE()` macros."
msgstr ""
"Доступ к полю :c:member:`~PyVarObject.ob_size` следует осуществлять с "
"помощью макросов :c:func:`Py_SIZE()` и :c:func:`Py_SET_SIZE()`."

#: ../../c-api/typeobj.rst:623
msgid ""
"Also, the presence of an :c:member:`~PyVarObject.ob_size` field in the "
"instance layout doesn't mean that the instance structure is variable-length. "
"For example, the :py:type:`list` type has fixed-length instances, yet those "
"instances have a :c:member:`~PyVarObject.ob_size` field. (As with :py:type:"
"`int`, avoid reading lists' :c:member:`!ob_size` directly. Call :c:func:"
"`PyList_Size` instead.)"
msgstr ""
"Кроме того, наличие поля :c:member:`~PyVarObject.ob_size` в макете "
"экземпляра не означает, что структура экземпляра имеет переменную длину. "
"Например, тип :py:type:`list` имеет экземпляры фиксированной длины, но эти "
"экземпляры имеют поле :c:member:`~PyVarObject.ob_size`. (Как и в случае с :"
"py:type:`int`, избегайте прямого чтения :c:member:`!ob_size` списков. Вместо "
"этого вызывайте :c:func:`PyList_Size`.)"

#: ../../c-api/typeobj.rst:630
msgid ""
"The :c:member:`!tp_basicsize` includes size needed for data of the type's :c:"
"member:`~PyTypeObject.tp_base`, plus any extra data needed by each instance."
msgstr ""
":c:member:`!tp_basicsize` включает размер, необходимый для данных типа :c:"
"member:`~PyTypeObject.tp_base`, а также любые дополнительные данные, "
"необходимые каждому экземпляру."

#: ../../c-api/typeobj.rst:634
msgid ""
"The  correct way to set :c:member:`!tp_basicsize` is to use the ``sizeof`` "
"operator on the struct used to declare the instance layout. This struct must "
"include the struct used to declare the base type. In other words, :c:member:"
"`!tp_basicsize` must be greater than or equal to the base's :c:member:`!"
"tp_basicsize`."
msgstr ""
"Правильный способ задать :c:member:`!tp_basicsize` — использовать оператор "
"``sizeof`` в структуре, используемой для объявления макета экземпляра. Эта "
"структура должна включать структуру, используемую для объявления базового "
"типа. Другими словами, :c:member:`!tp_basicsize` должно быть больше или "
"равно базовому :c:member:`!tp_basicsize`."

#: ../../c-api/typeobj.rst:640
msgid ""
"Since every type is a subtype of :py:type:`object`, this struct must "
"include :c:type:`PyObject` or :c:type:`PyVarObject` (depending on whether :c:"
"member:`~PyVarObject.ob_size` should be included). These are usually defined "
"by the macro :c:macro:`PyObject_HEAD` or :c:macro:`PyObject_VAR_HEAD`, "
"respectively."
msgstr ""
"Поскольку каждый тип является подтипом :py:type:`object`, эта структура "
"должна включать :c:type:`PyObject` или :c:type:`PyVarObject` (в зависимости "
"от того, следует ли включать :c:member:`~PyVarObject.ob_size`). Обычно они "
"определяются макросом :c:macro:`PyObject_HEAD` или :c:macro:"
"`PyObject_VAR_HEAD` соответственно."

#: ../../c-api/typeobj.rst:646
msgid ""
"The basic size does not include the GC header size, as that header is not "
"part of :c:macro:`PyObject_HEAD`."
msgstr ""
"Базовый размер не включает размер заголовка GC, поскольку этот заголовок не "
"является частью :c:macro:`PyObject_HEAD`."

#: ../../c-api/typeobj.rst:649
msgid ""
"For cases where struct used to declare the base type is unknown, see :c:"
"member:`PyType_Spec.basicsize` and :c:func:`PyType_FromMetaclass`."
msgstr ""
"Для случаев, когда структура, используемая для объявления базового типа, "
"неизвестна, см. :c:member:`PyType_Spec.basicsize` и :c:func:"
"`PyType_FromMetaclass`."

#: ../../c-api/typeobj.rst:652
msgid "Notes about alignment:"
msgstr "Примечания по выравниванию:"

#: ../../c-api/typeobj.rst:654
msgid ""
":c:member:`!tp_basicsize` must be a multiple of ``_Alignof(PyObject)``. When "
"using ``sizeof`` on a ``struct`` that includes :c:macro:`PyObject_HEAD`, as "
"recommended, the compiler ensures this. When not using a C ``struct``, or "
"when using compiler extensions like ``__attribute__((packed))``, it is up to "
"you."
msgstr ""
":c:member:`!tp_basicsize` должен быть кратен ``_Alignof(PyObject)``. При "
"использовании ``sizeof`` в ``struct``, включающей :c:macro:`PyObject_HEAD`, "
"как рекомендуется, компилятор обеспечивает это. Если не используется C "
"``struct`` или используются расширения компилятора, такие как "
"``__attribute__((packed))``, это зависит от вас."

#: ../../c-api/typeobj.rst:659
msgid ""
"If the variable items require a particular alignment, :c:member:`!"
"tp_basicsize` and :c:member:`!tp_itemsize` must each be a multiple of that "
"alignment. For example, if a type's variable part stores a ``double``, it is "
"your responsibility that both fields are a multiple of ``_Alignof(double)``."
msgstr ""
"Если переменные элементы требуют определенного выравнивания, :c:member:`!"
"tp_basicsize` и :c:member:`!tp_itemsize` должны быть кратны этому "
"выравниванию. Например, если переменная часть типа хранит ``double``, вы "
"несете ответственность за то, чтобы оба поля были кратны "
"``_Alignof(double)``."

#: ../../c-api/typeobj.rst:668
msgid ""
"These fields are inherited separately by subtypes. (That is, if the field is "
"set to zero, :c:func:`PyType_Ready` will copy the value from the base type, "
"indicating that the instances do not need additional storage.)"
msgstr ""
"Эти поля наследуются отдельно подтипами. (То есть, если поле установлено в "
"ноль, :c:func:`PyType_Ready` скопирует значение из базового типа, указывая, "
"что экземплярам не требуется дополнительное хранилище.)"

#: ../../c-api/typeobj.rst:673
msgid ""
"If the base type has a non-zero :c:member:`~PyTypeObject.tp_itemsize`, it is "
"generally not safe to set :c:member:`~PyTypeObject.tp_itemsize` to a "
"different non-zero value in a subtype (though this depends on the "
"implementation of the base type)."
msgstr ""
"Если базовый тип имеет ненулевое значение :c:member:`~PyTypeObject."
"tp_itemsize`, то, как правило, небезопасно устанавливать :c:member:"
"`~PyTypeObject.tp_itemsize` в другое ненулевое значение в подтипе (хотя это "
"зависит от реализации базового типа)."

#: ../../c-api/typeobj.rst:680
msgid ""
"A pointer to the instance destructor function.  This function must be "
"defined unless the type guarantees that its instances will never be "
"deallocated (as is the case for the singletons ``None`` and ``Ellipsis``).  "
"The function signature is::"
msgstr ""
"Un puntero a la función destructora de instancias.  Esta función debe "
"definirse a menos que el tipo garantice que sus instancias nunca serán "
"desasignadas (como es el caso de los singletons ``None`` y ``Ellipsis``).  "
"La firma de la función es::"

#: ../../c-api/typeobj.rst:684
msgid "void tp_dealloc(PyObject *self);"
msgstr "void tp_dealloc(PyObject *self);"

#: ../../c-api/typeobj.rst:686
msgid ""
"The destructor function is called by the :c:func:`Py_DECREF` and :c:func:"
"`Py_XDECREF` macros when the new reference count is zero.  At this point, "
"the instance is still in existence, but there are no references to it.  The "
"destructor function should free all references which the instance owns, free "
"all memory buffers owned by the instance (using the freeing function "
"corresponding to the allocation function used to allocate the buffer), and "
"call the type's :c:member:`~PyTypeObject.tp_free` function.  If the type is "
"not subtypable (doesn't have the :c:macro:`Py_TPFLAGS_BASETYPE` flag bit "
"set), it is permissible to call the object deallocator directly instead of "
"via :c:member:`~PyTypeObject.tp_free`.  The object deallocator should be the "
"one used to allocate the instance; this is normally :c:func:`PyObject_Del` "
"if the instance was allocated using :c:macro:`PyObject_New` or :c:macro:"
"`PyObject_NewVar`, or :c:func:`PyObject_GC_Del` if the instance was "
"allocated using :c:macro:`PyObject_GC_New` or :c:macro:`PyObject_GC_NewVar`."
msgstr ""

#: ../../c-api/typeobj.rst:701
msgid ""
"If the type supports garbage collection (has the :c:macro:"
"`Py_TPFLAGS_HAVE_GC` flag bit set), the destructor should call :c:func:"
"`PyObject_GC_UnTrack` before clearing any member fields."
msgstr ""

#: ../../c-api/typeobj.rst:705
msgid ""
"static void foo_dealloc(foo_object *self) {\n"
"    PyObject_GC_UnTrack(self);\n"
"    Py_CLEAR(self->ref);\n"
"    Py_TYPE(self)->tp_free((PyObject *)self);\n"
"}"
msgstr ""

#: ../../c-api/typeobj.rst:713
msgid ""
"Finally, if the type is heap allocated (:c:macro:`Py_TPFLAGS_HEAPTYPE`), the "
"deallocator should release the owned reference to its type object (via :c:"
"func:`Py_DECREF`)  after calling the type deallocator. In order to avoid "
"dangling pointers, the recommended way to achieve this is:"
msgstr ""

#: ../../c-api/typeobj.rst:719
msgid ""
"static void foo_dealloc(foo_object *self) {\n"
"    PyTypeObject *tp = Py_TYPE(self);\n"
"    // free references and buffers here\n"
"    tp->tp_free(self);\n"
"    Py_DECREF(tp);\n"
"}"
msgstr ""

#: ../../c-api/typeobj.rst:730
msgid ""
"In a garbage collected Python, :c:member:`!tp_dealloc` may be called from "
"any Python thread, not just the thread which created the object (if the "
"object becomes part of a refcount cycle, that cycle might be collected by a "
"garbage collection on any thread).  This is not a problem for Python API "
"calls, since the thread on which :c:member:`!tp_dealloc` is called will own "
"the Global Interpreter Lock (GIL).  However, if the object being destroyed "
"in turn destroys objects from some other C or C++ library, care should be "
"taken to ensure that destroying those objects on the thread which called :c:"
"member:`!tp_dealloc` will not violate any assumptions of the library."
msgstr ""

#: ../../c-api/typeobj.rst:749
msgid ""
"An optional offset to a per-instance function that implements calling the "
"object using the :ref:`vectorcall protocol <vectorcall>`, a more efficient "
"alternative of the simpler :c:member:`~PyTypeObject.tp_call`."
msgstr ""
"Un desplazamiento opcional a una función por instancia que implementa la "
"llamada al objeto utilizando el protocolo :ref:`vectorcall <vectorcall>`, "
"una alternativa más eficiente del más simple :c:member:`~PyTypeObject."
"tp_call`."

#: ../../c-api/typeobj.rst:754
msgid ""
"This field is only used if the flag :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` is "
"set. If so, this must be a positive integer containing the offset in the "
"instance of a :c:type:`vectorcallfunc` pointer."
msgstr ""
"Это поле используется только в том случае, если установлен флаг :c:macro:"
"`Py_TPFLAGS_HAVE_VECTORCALL`. Если да, то это должно быть положительное "
"целое число, содержащее смещение в экземпляре указателя :c:type:"
"`vectorcallfunc`."

#: ../../c-api/typeobj.rst:758
msgid ""
"The *vectorcallfunc* pointer may be ``NULL``, in which case the instance "
"behaves as if :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` was not set: calling the "
"instance falls back to :c:member:`~PyTypeObject.tp_call`."
msgstr ""
"Указатель *vectorcallfunc* может иметь значение NULL, и в этом случае "
"экземпляр ведет себя так, как если бы :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` "
"не был установлен: вызов экземпляра возвращается к :c:member:`~PyTypeObject."
"tp_call` ."

#: ../../c-api/typeobj.rst:762
msgid ""
"Any class that sets ``Py_TPFLAGS_HAVE_VECTORCALL`` must also set :c:member:"
"`~PyTypeObject.tp_call` and make sure its behaviour is consistent with the "
"*vectorcallfunc* function. This can be done by setting *tp_call* to :c:func:"
"`PyVectorcall_Call`."
msgstr ""
"Cualquier clase que establezca ``Py_TPFLAGS_HAVE_VECTORCALL`` debe también "
"establecer :c:member:`~PyTypeObject.tp_call` y asegurarse de que su "
"comportamiento es consistente con la función *vectorcallfunc*. Esto puede "
"hacerse estableciendo *tp_call* a :c:func:`PyVectorcall_Call`."

#: ../../c-api/typeobj.rst:769
msgid ""
"Before version 3.8, this slot was named ``tp_print``. In Python 2.x, it was "
"used for printing to a file. In Python 3.0 to 3.7, it was unused."
msgstr ""
"Antes de la versión 3.8, esta ranura se llamaba ``tp_print``. En Python 2.x, "
"se usaba para imprimir en un fichero. En Python 3.0 a 3.7, no se utilizaba."

#: ../../c-api/typeobj.rst:775
msgid ""
"Before version 3.12, it was not recommended for :ref:`mutable heap types "
"<heap-types>` to implement the vectorcall protocol. When a user sets :attr:"
"`~object.__call__` in Python code, only *tp_call* is updated, likely making "
"it inconsistent with the vectorcall function. Since 3.12, setting "
"``__call__`` will disable vectorcall optimization by clearing the :c:macro:"
"`Py_TPFLAGS_HAVE_VECTORCALL` flag."
msgstr ""
"До версии 3.12 не рекомендовалось для изменяемых типов кучи <heap-types>` "
"реализовывать протокол векторного вызова. Когда пользователь устанавливает :"
"attr:`~object.__call__` в коде Python, обновляется только *tp_call*, что, "
"вероятно, делает его несовместимым с функцией Vectorcall. Начиная с версии "
"3.12, установка ``__call__`` отключит оптимизацию векторного вызова, очистив "
"флаг :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL`."

#: ../../c-api/typeobj.rst:785
msgid ""
"This field is always inherited. However, the :c:macro:"
"`Py_TPFLAGS_HAVE_VECTORCALL` flag is not always inherited. If it's not set, "
"then the subclass won't use :ref:`vectorcall <vectorcall>`, except when :c:"
"func:`PyVectorcall_Call` is explicitly called."
msgstr ""
"Это поле всегда наследуется. Однако флаг :c:macro:"
"`Py_TPFLAGS_HAVE_VECTORCALL` не всегда наследуется. Если он не установлен, "
"то подкласс не будет использовать :ref:`vectorcall <vectorcall>`, за "
"исключением случаев, когда :c:func:`PyVectorcall_Call` вызывается явно."

#: ../../c-api/typeobj.rst:794
msgid "An optional pointer to the get-attribute-string function."
msgstr "Un puntero opcional a la función get-attribute-string."

#: ../../c-api/typeobj.rst:796
msgid ""
"This field is deprecated.  When it is defined, it should point to a function "
"that acts the same as the :c:member:`~PyTypeObject.tp_getattro` function, "
"but taking a C string instead of a Python string object to give the "
"attribute name."
msgstr ""
"Este campo está obsoleto.  Cuando se defina, debe apuntar a una función que "
"actúe igual que la función :c:member:`~PyTypeObject.tp_getattro`, pero "
"tomando una cadena C en lugar de un objeto cadena Python para dar el nombre "
"del atributo."

#: ../../c-api/typeobj.rst:802 ../../c-api/typeobj.rst:998
msgid ""
"Group: :c:member:`~PyTypeObject.tp_getattr`, :c:member:`~PyTypeObject."
"tp_getattro`"
msgstr ""
"Группа: :c:member:`~PyTypeObject.tp_getattr`, :c:member:`~PyTypeObject."
"tp_getattro`"

#: ../../c-api/typeobj.rst:804
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_getattro`: a subtype inherits both :c:member:`~PyTypeObject.tp_getattr` "
"and :c:member:`~PyTypeObject.tp_getattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_getattr` and :c:member:`~PyTypeObject."
"tp_getattro` are both ``NULL``."
msgstr ""
"Este campo es heredado por los subtipos junto con :c:member:`~PyTypeObject."
"tp_getattro`: un subtipo hereda tanto :c:member:`~PyTypeObject.tp_getattr` "
"como :c:member:`~PyTypeObject.tp_getattro` de su tipo base cuando :c:member:"
"`~PyTypeObject.tp_getattr` y :c:member:`~PyTypeObject.tp_getattro` del "
"subtipo son ambos ``NULL``."

#: ../../c-api/typeobj.rst:811 ../../c-api/typeobj.rst:1011
msgid ""
"An optional pointer to the function for setting and deleting attributes."
msgstr "Un puntero opcional a la función para establecer y eliminar atributos."

#: ../../c-api/typeobj.rst:813
msgid ""
"This field is deprecated.  When it is defined, it should point to a function "
"that acts the same as the :c:member:`~PyTypeObject.tp_setattro` function, "
"but taking a C string instead of a Python string object to give the "
"attribute name."
msgstr ""
"Este campo está obsoleto.  Cuando se defina, debe apuntar a una función que "
"actúe igual que la función :c:member:`~PyTypeObject.tp_setattro`, pero "
"tomando una cadena C en lugar de un objeto cadena Python para dar el nombre "
"del atributo."

#: ../../c-api/typeobj.rst:819 ../../c-api/typeobj.rst:1024
msgid ""
"Group: :c:member:`~PyTypeObject.tp_setattr`, :c:member:`~PyTypeObject."
"tp_setattro`"
msgstr ""
"Группа: :c:member:`~PyTypeObject.tp_setattr`, :c:member:`~PyTypeObject."
"tp_setattro`"

#: ../../c-api/typeobj.rst:821
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_setattro`: a subtype inherits both :c:member:`~PyTypeObject.tp_setattr` "
"and :c:member:`~PyTypeObject.tp_setattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_setattr` and :c:member:`~PyTypeObject."
"tp_setattro` are both ``NULL``."
msgstr ""
"Este campo es heredado por los subtipos junto con :c:member:`~PyTypeObject."
"tp_setattro`: un subtipo hereda tanto :c:member:`~PyTypeObject.tp_setattr` "
"como :c:member:`~PyTypeObject.tp_setattro` de su tipo base cuando :c:member:"
"`~PyTypeObject.tp_setattr` y :c:member:`~PyTypeObject.tp_setattro` del "
"subtipo son ambos ``NULL``."

#: ../../c-api/typeobj.rst:828
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement :term:`awaitable` and :term:`asynchronous iterator` "
"protocols at the C-level.  See :ref:`async-structs` for details."
msgstr ""
"Puntero a una estructura adicional que contiene campos relevantes sólo para "
"objetos que implementan los protocolos :term:`awaitable` y :term:"
"`asynchronous iterator` a nivel C.  Ver :ref:`async-structs` para obtener "
"más información."

#: ../../c-api/typeobj.rst:832
msgid "Formerly known as ``tp_compare`` and ``tp_reserved``."
msgstr "Anteriormente conocido como ``tp_compare`` y ``tp_reserved``."

#: ../../c-api/typeobj.rst:837
msgid ""
"The :c:member:`~PyTypeObject.tp_as_async` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"El campo :c:member:`~PyTypeObject.tp_as_async` no se hereda, pero los campos "
"contenidos sí se heredan individualmente."

#: ../../c-api/typeobj.rst:845
msgid ""
"An optional pointer to a function that implements the built-in function :"
"func:`repr`."
msgstr ""
"Un puntero opcional a una función que implementa la función incorporada :"
"func:`repr`."

#: ../../c-api/typeobj.rst:848
msgid "The signature is the same as for :c:func:`PyObject_Repr`::"
msgstr "La firma es la misma que para :c:func:`PyObject_Repr`::"

#: ../../c-api/typeobj.rst:850
msgid "PyObject *tp_repr(PyObject *self);"
msgstr "PyObject *tp_repr(PyObject *self);"

#: ../../c-api/typeobj.rst:852
msgid ""
"The function must return a string or a Unicode object.  Ideally, this "
"function should return a string that, when passed to :func:`eval`, given a "
"suitable environment, returns an object with the same value.  If this is not "
"feasible, it should return a string starting with ``'<'`` and ending with "
"``'>'`` from which both the type and the value of the object can be deduced."
msgstr ""
"La función debe devolver una cadena o un objeto Unicode.  Idealmente, esta "
"función debería devolver una cadena que, cuando se pasa a :func:`eval`, dado "
"un entorno adecuado, devuelve un objeto con el mismo valor.  Si esto no es "
"factible, debe devolver una cadena que empiece por ``'<'`` y termine por "
"``'>'`` a partir de la cual puedan deducirse tanto el tipo como el valor del "
"objeto."

#: ../../c-api/typeobj.rst:863 ../../c-api/typeobj.rst:942
#: ../../c-api/typeobj.rst:979 ../../c-api/typeobj.rst:1004
#: ../../c-api/typeobj.rst:1030 ../../c-api/typeobj.rst:1071
#: ../../c-api/typeobj.rst:1626 ../../c-api/typeobj.rst:1660
#: ../../c-api/typeobj.rst:1777 ../../c-api/typeobj.rst:1810
#: ../../c-api/typeobj.rst:1885 ../../c-api/typeobj.rst:1926
#: ../../c-api/typeobj.rst:1944 ../../c-api/typeobj.rst:1986
#: ../../c-api/typeobj.rst:2007 ../../c-api/typeobj.rst:2038
msgid "**Default:**"
msgstr "**Por defecto:**"

#: ../../c-api/typeobj.rst:865
msgid ""
"When this field is not set, a string of the form ``<%s object at %p>`` is "
"returned, where ``%s`` is replaced by the type name, and ``%p`` by the "
"object's memory address."
msgstr ""
"Si no se define este campo, se devuelve una cadena de caracteres del tipo "
"``<%s object at %p>``, donde ``%s`` se sustituye por el nombre del tipo y "
"``%p`` por la dirección de memoria del objeto."

#: ../../c-api/typeobj.rst:872
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the number protocol.  These fields are documented "
"in :ref:`number-structs`."
msgstr ""
"Puntero a una estructura adicional que contiene campos relevantes sólo para "
"los objetos que implementan el protocolo numérico.  Estos campos están "
"documentados en :ref:`number-structs`."

#: ../../c-api/typeobj.rst:878
msgid ""
"The :c:member:`~PyTypeObject.tp_as_number` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"El campo :c:member:`~PyTypeObject.tp_as_number` no se hereda, pero los "
"campos contenidos sí se heredan individualmente."

#: ../../c-api/typeobj.rst:884
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the sequence protocol.  These fields are documented "
"in :ref:`sequence-structs`."
msgstr ""
"Puntero a una estructura adicional que contiene campos relevantes sólo para "
"los objetos que implementan el protocolo de secuencia.  Estos campos están "
"documentados en :ref:`sequence-structs`."

#: ../../c-api/typeobj.rst:890
msgid ""
"The :c:member:`~PyTypeObject.tp_as_sequence` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"El campo :c:member:`~PyTypeObject.tp_as_sequence` no se hereda, pero los "
"campos contenidos sí se heredan individualmente."

#: ../../c-api/typeobj.rst:896
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the mapping protocol.  These fields are documented "
"in :ref:`mapping-structs`."
msgstr ""
"Puntero a una estructura adicional que contiene campos relevantes sólo para "
"los objetos que implementan el protocolo de mapeo.  Estos campos están "
"documentados en :ref:`mapping-structs`."

#: ../../c-api/typeobj.rst:902
msgid ""
"The :c:member:`~PyTypeObject.tp_as_mapping` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"El campo :c:member:`~PyTypeObject.tp_as_mapping` no se hereda, pero los "
"campos contenidos sí se heredan individualmente."

#: ../../c-api/typeobj.rst:910
msgid ""
"An optional pointer to a function that implements the built-in function :"
"func:`hash`."
msgstr ""
"Un puntero opcional a una función que implementa la función incorporada :"
"func:`hash`."

#: ../../c-api/typeobj.rst:913
msgid "The signature is the same as for :c:func:`PyObject_Hash`::"
msgstr "La firma es la misma que para :c:func:`PyObject_Hash`::"

#: ../../c-api/typeobj.rst:915
msgid "Py_hash_t tp_hash(PyObject *);"
msgstr "Py_hash_t tp_hash(PyObject *);"

#: ../../c-api/typeobj.rst:917
msgid ""
"The value ``-1`` should not be returned as a normal return value; when an "
"error occurs during the computation of the hash value, the function should "
"set an exception and return ``-1``."
msgstr ""
"El valor ``-1`` no se debe devolver como valor de retorno normal; cuando se "
"produce un error durante el cálculo del valor hash, la función debe "
"establecer una excepción y devolver ``-1``."

#: ../../c-api/typeobj.rst:921
msgid ""
"When this field is not set (*and* :c:member:`~PyTypeObject.tp_richcompare` "
"is not set), an attempt to take the hash of the object raises :exc:"
"`TypeError`. This is the same as setting it to :c:func:"
"`PyObject_HashNotImplemented`."
msgstr ""
"Если это поле не установлено (*и* :c:member:`~PyTypeObject.tp_richcompare` "
"не установлено), попытка получить хэш объекта вызывает :exc:`TypeError`. Это "
"то же самое, что установить для него значение :c:func:"
"`PyObject_HashNotImplemented`."

#: ../../c-api/typeobj.rst:925
msgid ""
"This field can be set explicitly to :c:func:`PyObject_HashNotImplemented` to "
"block inheritance of the hash method from a parent type. This is interpreted "
"as the equivalent of ``__hash__ = None`` at the Python level, causing "
"``isinstance(o, collections.Hashable)`` to correctly return ``False``. Note "
"that the converse is also true - setting ``__hash__ = None`` on a class at "
"the Python level will result in the ``tp_hash`` slot being set to :c:func:"
"`PyObject_HashNotImplemented`."
msgstr ""
"Este campo puede establecerse explícitamente a :c:func:"
"`PyObject_HashNotImplemented` para bloquear la herencia del método hash de "
"un tipo padre. Esto se interpreta como el equivalente de ``__hash__ = None`` "
"a nivel de Python, haciendo que ``isinstance(o, collections.Hashable)`` "
"devuelva correctamente ``False``. Tenga en cuenta que lo contrario también "
"es cierto - establecer ``__hash__ = None`` en una clase a nivel Python "
"resultará en que el campo ``tp_hash`` se establezca en :c:func:"
"`PyObject_HashNotImplemented`."

#: ../../c-api/typeobj.rst:935 ../../c-api/typeobj.rst:1619
msgid ""
"Group: :c:member:`~PyTypeObject.tp_hash`, :c:member:`~PyTypeObject."
"tp_richcompare`"
msgstr ""
"Группа: :c:member:`~PyTypeObject.tp_hash`, :c:member:`~PyTypeObject."
"tp_richcompare`"

#: ../../c-api/typeobj.rst:937
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_richcompare`: a subtype inherits both of :c:member:`~PyTypeObject."
"tp_richcompare` and :c:member:`~PyTypeObject.tp_hash`, when the subtype's :c:"
"member:`~PyTypeObject.tp_richcompare` and :c:member:`~PyTypeObject.tp_hash` "
"are both ``NULL``."
msgstr ""
"Este campo es heredado por los subtipos junto con :c:member:`~PyTypeObject."
"tp_richcompare`: un subtipo hereda ambos de :c:member:`~PyTypeObject."
"tp_richcompare` y :c:member:`~PyTypeObject.tp_hash`, cuando los :c:member:"
"`~PyTypeObject.tp_richcompare` y :c:member:`~PyTypeObject.tp_hash` del "
"subtipo son ambos ``NULL``."

#: ../../c-api/typeobj.rst:944
msgid ":c:data:`PyBaseObject_Type` uses :c:func:`PyObject_GenericHash`."
msgstr ":c:data:`PyBaseObject_Type` использует :c:func:`PyObject_GenericHash`."

#: ../../c-api/typeobj.rst:949
msgid ""
"An optional pointer to a function that implements calling the object.  This "
"should be ``NULL`` if the object is not callable.  The signature is the same "
"as for :c:func:`PyObject_Call`::"
msgstr ""
"Un puntero opcional a una función que implementa la llamada al objeto.  Debe "
"ser ``NULL`` si el objeto no es invocable.  La firma es la misma que para :c:"
"func:`PyObject_Call`::"

#: ../../c-api/typeobj.rst:953
msgid "PyObject *tp_call(PyObject *self, PyObject *args, PyObject *kwargs);"
msgstr "PyObject *tp_call(PyObject *self, PyObject *args, PyObject *kwargs);"

#: ../../c-api/typeobj.rst:962
msgid ""
"An optional pointer to a function that implements the built-in operation :"
"func:`str`.  (Note that :class:`str` is a type now, and :func:`str` calls "
"the constructor for that type.  This constructor calls :c:func:"
"`PyObject_Str` to do the actual work, and :c:func:`PyObject_Str` will call "
"this handler.)"
msgstr ""
"Un puntero opcional a una función que implementa la operación incorporada :"
"func:`str`.  (Observar que :class:`str` es ahora un tipo, y :func:`str` "
"llama al constructor para ese tipo.  Este constructor llama a :c:func:"
"`PyObject_Str` para hacer el trabajo real, y :c:func:`PyObject_Str` llamará "
"a este manejador)."

#: ../../c-api/typeobj.rst:967
msgid "The signature is the same as for :c:func:`PyObject_Str`::"
msgstr "La firma es la misma que para :c:func:`PyObject_Str`::"

#: ../../c-api/typeobj.rst:969
msgid "PyObject *tp_str(PyObject *self);"
msgstr "PyObject *tp_str(PyObject *self);"

#: ../../c-api/typeobj.rst:971
msgid ""
"The function must return a string or a Unicode object.  It should be a "
"\"friendly\" string representation of the object, as this is the "
"representation that will be used, among other things, by the :func:`print` "
"function."
msgstr ""
"La función debe devolver una cadena o un objeto Unicode.  Debe ser una "
"representación de cadena \"amigable\" del objeto, ya que ésta es la "
"representación que utilizará, entre otras cosas, la función :func:`print`."

#: ../../c-api/typeobj.rst:981
msgid ""
"When this field is not set, :c:func:`PyObject_Repr` is called to return a "
"string representation."
msgstr ""
"Cuando este campo no está definido, se llama a :c:func:`PyObject_Repr` para "
"que devuelva una representación de cadena."

#: ../../c-api/typeobj.rst:987
msgid "An optional pointer to the get-attribute function."
msgstr "Un puntero opcional a la función get-attribute."

#: ../../c-api/typeobj.rst:989
msgid "The signature is the same as for :c:func:`PyObject_GetAttr`::"
msgstr "La firma es la misma que para :c:func:`PyObject_GetAttr`::"

#: ../../c-api/typeobj.rst:991
msgid "PyObject *tp_getattro(PyObject *self, PyObject *attr);"
msgstr "PyObject *tp_getattro(PyObject *self, PyObject *attr);"

#: ../../c-api/typeobj.rst:993
msgid ""
"It is usually convenient to set this field to :c:func:"
"`PyObject_GenericGetAttr`, which implements the normal way of looking for "
"object attributes."
msgstr ""
"Suele ser conveniente establecer este campo en :c:func:"
"`PyObject_GenericGetAttr`, que implementa la forma normal de buscar "
"atributos de objetos."

#: ../../c-api/typeobj.rst:1000
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_getattr`: a subtype inherits both :c:member:`~PyTypeObject.tp_getattr` "
"and :c:member:`~PyTypeObject.tp_getattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_getattr` and :c:member:`~PyTypeObject."
"tp_getattro` are both ``NULL``."
msgstr ""
"Este campo es heredado por los subtipos junto con :c:member:`~PyTypeObject."
"tp_getattr`: un subtipo hereda tanto :c:member:`~PyTypeObject.tp_getattr` "
"como :c:member:`~PyTypeObject.tp_getattro` de su tipo base cuando :c:member:"
"`~PyTypeObject.tp_getattr` y :c:member:`~PyTypeObject.tp_getattro` del "
"subtipo son ambos ``NULL``."

#: ../../c-api/typeobj.rst:1006
msgid ":c:data:`PyBaseObject_Type` uses :c:func:`PyObject_GenericGetAttr`."
msgstr ""
":c:data:`PyBaseObject_Type` использует :c:func:`PyObject_GenericGetAttr`."

#: ../../c-api/typeobj.rst:1013
msgid "The signature is the same as for :c:func:`PyObject_SetAttr`::"
msgstr "La firma es la misma que para :c:func:`PyObject_SetAttr`::"

#: ../../c-api/typeobj.rst:1015
msgid "int tp_setattro(PyObject *self, PyObject *attr, PyObject *value);"
msgstr "int tp_setattro(PyObject *self, PyObject *attr, PyObject *value);"

#: ../../c-api/typeobj.rst:1017
msgid ""
"In addition, setting *value* to ``NULL`` to delete an attribute must be "
"supported.  It is usually convenient to set this field to :c:func:"
"`PyObject_GenericSetAttr`, which implements the normal way of setting object "
"attributes."
msgstr ""
"Además, debe admitirse la posibilidad de establecer *value* en ``NULL`` para "
"eliminar un atributo.  Suele ser conveniente establecer este campo en :c:"
"func:`PyObject_GenericSetAttr`, que implementa la forma normal de establecer "
"atributos de objetos."

#: ../../c-api/typeobj.rst:1026
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_setattr`: a subtype inherits both :c:member:`~PyTypeObject.tp_setattr` "
"and :c:member:`~PyTypeObject.tp_setattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_setattr` and :c:member:`~PyTypeObject."
"tp_setattro` are both ``NULL``."
msgstr ""
"Este campo es heredado por los subtipos junto con :c:member:`~PyTypeObject."
"tp_setattr`: un subtipo hereda tanto :c:member:`~PyTypeObject.tp_setattr` "
"como :c:member:`~PyTypeObject.tp_setattro` de su tipo base cuando :c:member:"
"`~PyTypeObject.tp_setattr` y :c:member:`~PyTypeObject.tp_setattro` del "
"subtipo son ambos ``NULL``."

#: ../../c-api/typeobj.rst:1032
msgid ":c:data:`PyBaseObject_Type` uses :c:func:`PyObject_GenericSetAttr`."
msgstr ""
":c:data:`PyBaseObject_Type` использует :c:func:`PyObject_GenericSetAttr`."

#: ../../c-api/typeobj.rst:1037
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the buffer interface.  These fields are documented "
"in :ref:`buffer-structs`."
msgstr ""
"Puntero a una estructura adicional que contiene campos relevantes sólo para "
"los objetos que implementan la interfaz de búfer.  Estos campos están "
"documentados en :ref:`buffer-structs`."

#: ../../c-api/typeobj.rst:1043
msgid ""
"The :c:member:`~PyTypeObject.tp_as_buffer` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"El campo :c:member:`~PyTypeObject.tp_as_buffer` no se hereda, pero los "
"campos contenidos sí se heredan individualmente."

#: ../../c-api/typeobj.rst:1049
msgid ""
"This field is a bit mask of various flags.  Some flags indicate variant "
"semantics for certain situations; others are used to indicate that certain "
"fields in the type object (or in the extension structures referenced via :c:"
"member:`~PyTypeObject.tp_as_number`, :c:member:`~PyTypeObject."
"tp_as_sequence`, :c:member:`~PyTypeObject.tp_as_mapping`, and :c:member:"
"`~PyTypeObject.tp_as_buffer`) that were historically not always present are "
"valid; if such a flag bit is clear, the type fields it guards must not be "
"accessed and must be considered to have a zero or ``NULL`` value instead."
msgstr ""
"Este campo es una máscara de bits de varios indicadores.  Algunas banderas "
"indican variantes semánticas para ciertas situaciones; otras se utilizan "
"para indicar que ciertos campos en el objeto de tipo (o en las estructuras "
"de extensión referenciadas mediante :c:member:`~PyTypeObject.tp_as_number`, :"
"c:member:`~PyTypeObject.tp_as_sequence`, :c:member:`~PyTypeObject."
"tp_as_mapping`, y :c:member:`~PyTypeObject.tp_as_buffer`) que históricamente "
"no estaban siempre presentes son válidos; si un bit de bandera de este tipo "
"está despejado, no se debe acceder a los campos de tipo que guarda y en su "
"lugar se debe considerar que tienen un valor cero o ``NULL``."

#: ../../c-api/typeobj.rst:1059
msgid ""
"Inheritance of this field is complicated.  Most flag bits are inherited "
"individually, i.e. if the base type has a flag bit set, the subtype inherits "
"this flag bit.  The flag bits that pertain to extension structures are "
"strictly inherited if the extension structure is inherited, i.e. the base "
"type's value of the flag bit is copied into the subtype together with a "
"pointer to the extension structure.  The :c:macro:`Py_TPFLAGS_HAVE_GC` flag "
"bit is inherited together with the :c:member:`~PyTypeObject.tp_traverse` "
"and :c:member:`~PyTypeObject.tp_clear` fields, i.e. if the :c:macro:"
"`Py_TPFLAGS_HAVE_GC` flag bit is clear in the subtype and the :c:member:"
"`~PyTypeObject.tp_traverse` and :c:member:`~PyTypeObject.tp_clear` fields in "
"the subtype exist and have ``NULL`` values. .. XXX are most flag bits "
"*really* inherited individually?"
msgstr ""

#: ../../c-api/typeobj.rst:1073
msgid ""
":c:data:`PyBaseObject_Type` uses ``Py_TPFLAGS_DEFAULT | "
"Py_TPFLAGS_BASETYPE``."
msgstr ""
":c:data:`PyBaseObject_Type` uses ``Py_TPFLAGS_DEFAULT | "
"Py_TPFLAGS_BASETYPE``."

#: ../../c-api/typeobj.rst:1076
msgid "**Bit Masks:**"
msgstr "**Máscaras de bits**"

#: ../../c-api/typeobj.rst:1080
msgid ""
"The following bit masks are currently defined; these can be ORed together "
"using the ``|`` operator to form the value of the :c:member:`~PyTypeObject."
"tp_flags` field.  The macro :c:func:`PyType_HasFeature` takes a type and a "
"flags value, *tp* and *f*, and checks whether ``tp->tp_flags & f`` is non-"
"zero."
msgstr ""
"Actualmente están definidas las siguientes máscaras de bits, que pueden "
"unirse mediante el operador ``|`` para formar el valor del campo :c:member:"
"`~PyTypeObject.tp_flags`.  La macro :c:func:`PyType_HasFeature` toma un tipo "
"y un valor flags, *tp* y *f*, y comprueba si ``tp->tp_flags & f`` es "
"distinto de cero."

#: ../../c-api/typeobj.rst:1087
msgid ""
"This bit is set when the type object itself is allocated on the heap, for "
"example, types created dynamically using :c:func:`PyType_FromSpec`.  In this "
"case, the :c:member:`~PyObject.ob_type` field of its instances is considered "
"a reference to the type, and the type object is INCREF'ed when a new "
"instance is created, and DECREF'ed when an instance is destroyed (this does "
"not apply to instances of subtypes; only the type referenced by the "
"instance's ob_type gets INCREF'ed or DECREF'ed). Heap types should also :ref:"
"`support garbage collection <supporting-cycle-detection>` as they can form a "
"reference cycle with their own module object."
msgstr ""
"Этот бит устанавливается, когда сам объект типа выделяется в куче, например, "
"типы создаются динамически с использованием :c:func:`PyType_FromSpec`. В "
"этом случае поле :c:member:`~PyObject.ob_type` его экземпляров считается "
"ссылкой на тип, а объект типа обрабатывается INCREF при создании нового "
"экземпляра и DECREF при создании экземпляра. уничтожается (это не относится "
"к экземплярам подтипов; только тип, на который ссылается ob_type экземпляра, "
"получает INCREF или DECREF). Типы кучи также должны поддерживать сборку "
"мусора <supporting-cycle-detection>, поскольку они могут формировать "
"ссылочный цикл со своим собственным объектом модуля."

#: ../../c-api/typeobj.rst:1098 ../../c-api/typeobj.rst:1109
#: ../../c-api/typeobj.rst:1119 ../../c-api/typeobj.rst:1129
#: ../../c-api/typeobj.rst:1161
msgid "???"
msgstr "???"

#: ../../c-api/typeobj.rst:1103
msgid ""
"This bit is set when the type can be used as the base type of another type.  "
"If this bit is clear, the type cannot be subtyped (similar to a \"final\" "
"class in Java)."
msgstr ""
"Este bit se activa cuando el tipo puede utilizarse como tipo base de otro "
"tipo.  Si este bit está despejado, el tipo no puede ser subtipado (similar a "
"una clase \"final\" en Java)."

#: ../../c-api/typeobj.rst:1114
msgid ""
"This bit is set when the type object has been fully initialized by :c:func:"
"`PyType_Ready`."
msgstr ""
"Este bit se activa cuando el objeto de tipo ha sido totalmente inicializado "
"por :c:func:`PyType_Ready`."

#: ../../c-api/typeobj.rst:1124
msgid ""
"This bit is set while :c:func:`PyType_Ready` is in the process of "
"initializing the type object."
msgstr ""
"Este bit se establece mientras :c:func:`PyType_Ready` está en proceso de "
"inicializar el objeto de tipo."

#: ../../c-api/typeobj.rst:1134
msgid ""
"This bit is set when the object supports garbage collection.  If this bit is "
"set, instances must be created using :c:macro:`PyObject_GC_New` and "
"destroyed using :c:func:`PyObject_GC_Del`.  More information in section :ref:"
"`supporting-cycle-detection`.  This bit also implies that the GC-related "
"fields :c:member:`~PyTypeObject.tp_traverse` and :c:member:`~PyTypeObject."
"tp_clear` are present in the type object."
msgstr ""

#: ../../c-api/typeobj.rst:1143 ../../c-api/typeobj.rst:1484
#: ../../c-api/typeobj.rst:1558
msgid ""
"Group: :c:macro:`Py_TPFLAGS_HAVE_GC`, :c:member:`~PyTypeObject."
"tp_traverse`, :c:member:`~PyTypeObject.tp_clear`"
msgstr ""
"Group: :c:macro:`Py_TPFLAGS_HAVE_GC`, :c:member:`~PyTypeObject."
"tp_traverse`, :c:member:`~PyTypeObject.tp_clear`"

#: ../../c-api/typeobj.rst:1145
msgid ""
"The :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is inherited together with the :c:"
"member:`~PyTypeObject.tp_traverse` and :c:member:`~PyTypeObject.tp_clear` "
"fields, i.e.  if the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is clear in the "
"subtype and the :c:member:`~PyTypeObject.tp_traverse` and :c:member:"
"`~PyTypeObject.tp_clear` fields in the subtype exist and have ``NULL`` "
"values."
msgstr ""
"The :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is inherited together with the :c:"
"member:`~PyTypeObject.tp_traverse` and :c:member:`~PyTypeObject.tp_clear` "
"fields, i.e.  if the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is clear in the "
"subtype and the :c:member:`~PyTypeObject.tp_traverse` and :c:member:"
"`~PyTypeObject.tp_clear` fields in the subtype exist and have ``NULL`` "
"values."

#: ../../c-api/typeobj.rst:1155
msgid ""
"This is a bitmask of all the bits that pertain to the existence of certain "
"fields in the type object and its extension structures. Currently, it "
"includes the following bits: :c:macro:`Py_TPFLAGS_HAVE_STACKLESS_EXTENSION`."
msgstr ""
"Это битовая маска всех битов, которые относятся к существованию определенных "
"полей в объекте типа и его структурах расширения. В настоящее время он "
"включает в себя следующие биты: :c:macro:"
"`Py_TPFLAGS_HAVE_STACKLESS_EXTENSION`."

#: ../../c-api/typeobj.rst:1166
msgid "This bit indicates that objects behave like unbound methods."
msgstr ""
"Este fragmento indica que los objetos se comportan como métodos no "
"vinculados."

#: ../../c-api/typeobj.rst:1168
msgid "If this flag is set for ``type(meth)``, then:"
msgstr "Si esta bandera se establece para ``type(meth)``, entonces:"

#: ../../c-api/typeobj.rst:1170
msgid ""
"``meth.__get__(obj, cls)(*args, **kwds)`` (with ``obj`` not None) must be "
"equivalent to ``meth(obj, *args, **kwds)``."
msgstr ""
"``meth.__get__(obj, cls)(*args, **kwds)`` (con ``obj`` no siendo None) debe "
"ser equivalente a ``meth(obj, *args, **kwds)``."

#: ../../c-api/typeobj.rst:1173
msgid ""
"``meth.__get__(None, cls)(*args, **kwds)`` must be equivalent to "
"``meth(*args, **kwds)``."
msgstr ""
"``meth.__get__(None, cls)(*args, **kwds)`` debe ser equivalente a "
"``meth(*args, **kwds)``."

#: ../../c-api/typeobj.rst:1176
msgid ""
"This flag enables an optimization for typical method calls like ``obj."
"meth()``: it avoids creating a temporary \"bound method\" object for ``obj."
"meth``."
msgstr ""
"Este indicador habilita una optimización para llamadas de método típicas "
"como ``obj.meth()``: evita crear un objeto temporal de \"método vinculado\" "
"para ``obj.meth``."

#: ../../c-api/typeobj.rst:1184
msgid ""
"This flag is never inherited by types without the :c:macro:"
"`Py_TPFLAGS_IMMUTABLETYPE` flag set.  For extension types, it is inherited "
"whenever :c:member:`~PyTypeObject.tp_descr_get` is inherited."
msgstr ""
"Этот флаг никогда не наследуется типами без установленного флага :c:macro:"
"`Py_TPFLAGS_IMMUTABLETYPE`. Для типов расширения он наследуется всякий раз, "
"когда наследуется :c:member:`~PyTypeObject.tp_descr_get`."

#: ../../c-api/typeobj.rst:1190
msgid ""
"This bit indicates that instances of the class have a :attr:`~object."
"__dict__` attribute, and that the space for the dictionary is managed by the "
"VM."
msgstr ""
"该比特位指明类的实例具有 :attr:`~object.__dict__` 属性，并且该字典的空间是由 "
"VM 管理的。"

#: ../../c-api/typeobj.rst:1193
msgid "If this flag is set, :c:macro:`Py_TPFLAGS_HAVE_GC` should also be set."
msgstr ""
"Если этот флаг установлен, также должен быть установлен :c:macro:"
"`Py_TPFLAGS_HAVE_GC`."

#: ../../c-api/typeobj.rst:1195
msgid ""
"The type traverse function must call :c:func:`PyObject_VisitManagedDict` and "
"its clear function must call :c:func:`PyObject_ClearManagedDict`."
msgstr ""
"Функция перемещения типа должна вызывать :c:func:"
"`PyObject_VisitManagedDict`, а ее функция очистки должна вызывать :c:func:"
"`PyObject_ClearManagedDict`."

#: ../../c-api/typeobj.rst:1202
msgid ""
"This flag is inherited unless the :c:member:`~PyTypeObject.tp_dictoffset` "
"field is set in a superclass."
msgstr ""
"Этот флаг наследуется, если в суперклассе не установлено поле :c:member:"
"`~PyTypeObject.tp_dictoffset`."

#: ../../c-api/typeobj.rst:1208
msgid ""
"This bit indicates that instances of the class should be weakly "
"referenceable."
msgstr ""
"Этот бит указывает, что экземпляры класса должны быть слабо доступны для "
"ссылок."

#: ../../c-api/typeobj.rst:1215
msgid ""
"This flag is inherited unless the :c:member:`~PyTypeObject."
"tp_weaklistoffset` field is set in a superclass."
msgstr ""
"Этот флаг наследуется, если в суперклассе не установлено поле :c:member:"
"`~PyTypeObject.tp_weaklistoffset`."

#: ../../c-api/typeobj.rst:1221
msgid ""
"Only usable with variable-size types, i.e. ones with non-zero :c:member:"
"`~PyTypeObject.tp_itemsize`."
msgstr ""
"Можно использовать только с типами переменного размера, т.е. с ненулевым :c:"
"member:`~PyTypeObject.tp_itemsize`."

#: ../../c-api/typeobj.rst:1224
msgid ""
"Indicates that the variable-sized portion of an instance of this type is at "
"the end of the instance's memory area, at an offset of ``Py_TYPE(obj)-"
">tp_basicsize`` (which may be different in each subclass)."
msgstr ""
"Указывает, что часть экземпляра этого типа с переменным размером находится в "
"конце области памяти экземпляра со смещением ``Py_TYPE(obj)->tp_basicsize`` "
"(которое может быть разным в каждом подклассе)."

#: ../../c-api/typeobj.rst:1229
msgid ""
"When setting this flag, be sure that all superclasses either use this memory "
"layout, or are not variable-sized. Python does not check this."
msgstr ""
"Устанавливая этот флаг, убедитесь, что все суперклассы либо используют это "
"расположение памяти, либо не имеют переменного размера. Python не проверяет "
"это."

#: ../../c-api/typeobj.rst:1237
msgid "This flag is inherited."
msgstr "Этот флаг наследуется."

#: ../../c-api/typeobj.rst:1251
msgid ""
"These flags are used by functions such as :c:func:`PyLong_Check` to quickly "
"determine if a type is a subclass of a built-in type; such specific checks "
"are faster than a generic check, like :c:func:`PyObject_IsInstance`. Custom "
"types that inherit from built-ins should have their :c:member:`~PyTypeObject."
"tp_flags` set appropriately, or the code that interacts with such types will "
"behave differently depending on what kind of check is used."
msgstr ""
"Estas banderas son utilizadas por funciones como :c:func:`PyLong_Check` para "
"determinar rápidamente si un tipo es una subclase de un tipo incorporado; "
"estas comprobaciones específicas son más rápidas que una comprobación "
"genérica, como :c:func:`PyObject_IsInstance`. Los tipos personalizados que "
"heredan de los tipos incorporados deben tener sus :c:member:`~PyTypeObject."
"tp_flags` configurados adecuadamente, o el código que interactúa con dichos "
"tipos se comportará de manera diferente dependiendo del tipo de comprobación "
"que se utilice."

#: ../../c-api/typeobj.rst:1262
msgid ""
"This bit is set when the :c:member:`~PyTypeObject.tp_finalize` slot is "
"present in the type structure."
msgstr ""
"Este bit se establece cuando la ranura:c:member:`~PyTypeObject.tp_finalize` "
"está presente en la estructura del tipo."

#: ../../c-api/typeobj.rst:1267
msgid ""
"This flag isn't necessary anymore, as the interpreter assumes the :c:member:"
"`~PyTypeObject.tp_finalize` slot is always present in the type structure."
msgstr ""
"Esta bandera ya no es necesaria, ya que el intérprete asume que la ranura :c:"
"member:`~PyTypeObject.tp_finalize` siempre está presente en la estructura "
"del tipo."

#: ../../c-api/typeobj.rst:1275
msgid ""
"This bit is set when the class implements the :ref:`vectorcall protocol "
"<vectorcall>`. See :c:member:`~PyTypeObject.tp_vectorcall_offset` for "
"details."
msgstr ""
"Este bit se establece cuando la clase implementa el protocolo :ref:"
"`vectorcall <vectorcall>`. Ver para más detalles :c:member:`~PyTypeObject."
"tp_vectorcall_offset`."

#: ../../c-api/typeobj.rst:1281
msgid ""
"This bit is inherited if :c:member:`~PyTypeObject.tp_call` is also inherited."
msgstr ""
"Этот бит наследуется, если :c:member:`~PyTypeObject.tp_call` также "
"унаследован."

#: ../../c-api/typeobj.rst:1288
msgid ""
"This flag is now removed from a class when the class's :py:meth:`~object."
"__call__` method is reassigned."
msgstr ""
"Этот флаг теперь удаляется из класса при переназначении метода :py:meth:"
"`~object.__call__`."

#: ../../c-api/typeobj.rst:1291
msgid "This flag can now be inherited by mutable classes."
msgstr "Этот флаг теперь может наследоваться изменяемыми классами."

#: ../../c-api/typeobj.rst:1295
msgid ""
"This bit is set for type objects that are immutable: type attributes cannot "
"be set nor deleted."
msgstr ""
"Цей біт встановлено для об’єктів типу, які є незмінними: атрибути типу не "
"можна ні встановити, ні видалити."

#: ../../c-api/typeobj.rst:1297
msgid ""
":c:func:`PyType_Ready` automatically applies this flag to :ref:`static types "
"<static-types>`."
msgstr ""
":c:func:`PyType_Ready` автоматично застосовує цей прапорець до :ref:"
"`статичних типів <static-types>`."

#: ../../c-api/typeobj.rst:1302
msgid "This flag is not inherited."
msgstr "Цей прапорець не успадковується."

#: ../../c-api/typeobj.rst:1308
msgid ""
"Disallow creating instances of the type: set :c:member:`~PyTypeObject."
"tp_new` to NULL and don't create the ``__new__`` key in the type dictionary."
msgstr ""
"Заборонити створення екземплярів типу: установіть для :c:member:"
"`~PyTypeObject.tp_new` значення NULL і не створюйте ключ ``__new__`` у "
"словнику типу."

#: ../../c-api/typeobj.rst:1312
msgid ""
"The flag must be set before creating the type, not after. For example, it "
"must be set before :c:func:`PyType_Ready` is called on the type."
msgstr ""
"Прапор має бути встановлений до створення типу, а не після. Наприклад, його "
"потрібно встановити перед викликом :c:func:`PyType_Ready` для типу."

#: ../../c-api/typeobj.rst:1315
msgid ""
"The flag is set automatically on :ref:`static types <static-types>` if :c:"
"member:`~PyTypeObject.tp_base` is NULL or ``&PyBaseObject_Type`` and :c:"
"member:`~PyTypeObject.tp_new` is NULL."
msgstr ""
"Прапорець автоматично встановлюється для :ref:`статичних типів <static-"
"types>`, якщо :c:member:`~PyTypeObject.tp_base` має значення NULL або "
"``&PyBaseObject_Type`` і :c:member:`~PyTypeObject.tp_new` має значення NULL."

#: ../../c-api/typeobj.rst:1321
msgid ""
"This flag is not inherited. However, subclasses will not be instantiable "
"unless they provide a non-NULL :c:member:`~PyTypeObject.tp_new` (which is "
"only possible via the C API)."
msgstr ""
"Этот флаг не наследуется. Однако подклассы не будут создавать экземпляры, "
"если они не предоставят не NULL :c:member:`~PyTypeObject.tp_new` (что "
"возможно только через C API)."

#: ../../c-api/typeobj.rst:1328
msgid ""
"To disallow instantiating a class directly but allow instantiating its "
"subclasses (e.g. for an :term:`abstract base class`), do not use this flag. "
"Instead, make :c:member:`~PyTypeObject.tp_new` only succeed for subclasses."
msgstr ""
"Чтобы запретить создание экземпляра класса напрямую, но разрешить создание "
"экземпляров его подклассов (например, для :term:`абстрактного базового "
"класса`), не используйте этот флаг. Вместо этого сделайте :c:member:"
"`~PyTypeObject.tp_new` успешным только для подклассов."

#: ../../c-api/typeobj.rst:1339
msgid ""
"This bit indicates that instances of the class may match mapping patterns "
"when used as the subject of a :keyword:`match` block. It is automatically "
"set when registering or subclassing :class:`collections.abc.Mapping`, and "
"unset when registering :class:`collections.abc.Sequence`."
msgstr ""
"Цей біт вказує на те, що екземпляри класу можуть відповідати шаблонам "
"відображення, якщо використовуються як суб’єкт блоку :keyword:`match`. Він "
"автоматично встановлюється під час реєстрації або підкласу :class:"
"`collections.abc.Mapping` і скасовується під час реєстрації :class:"
"`collections.abc.Sequence`."

#: ../../c-api/typeobj.rst:1346 ../../c-api/typeobj.rst:1368
msgid ""
":c:macro:`Py_TPFLAGS_MAPPING` and :c:macro:`Py_TPFLAGS_SEQUENCE` are "
"mutually exclusive; it is an error to enable both flags simultaneously."
msgstr ""
":c:macro:`Py_TPFLAGS_MAPPING` и :c:macro:`Py_TPFLAGS_SEQUENCE` являются "
"взаимоисключающими; одновременное включение обоих флагов является ошибкой."

#: ../../c-api/typeobj.rst:1351
msgid ""
"This flag is inherited by types that do not already set :c:macro:"
"`Py_TPFLAGS_SEQUENCE`."
msgstr ""
"Этот флаг наследуется типами, которые еще не установили :c:macro:"
"`Py_TPFLAGS_SEQUENCE`."

#: ../../c-api/typeobj.rst:1354 ../../c-api/typeobj.rst:1376
msgid ":pep:`634` -- Structural Pattern Matching: Specification"
msgstr ":pep:`634` -- Зіставлення структурних шаблонів: Специфікація"

#: ../../c-api/typeobj.rst:1361
msgid ""
"This bit indicates that instances of the class may match sequence patterns "
"when used as the subject of a :keyword:`match` block. It is automatically "
"set when registering or subclassing :class:`collections.abc.Sequence`, and "
"unset when registering :class:`collections.abc.Mapping`."
msgstr ""
"Цей біт вказує на те, що екземпляри класу можуть відповідати шаблонам "
"послідовності, коли використовуються як суб’єкт блоку :keyword:`match`. Він "
"автоматично встановлюється під час реєстрації або підкласу :class:"
"`collections.abc.Sequence` і скасовується під час реєстрації :class:"
"`collections.abc.Mapping`."

#: ../../c-api/typeobj.rst:1373
msgid ""
"This flag is inherited by types that do not already set :c:macro:"
"`Py_TPFLAGS_MAPPING`."
msgstr ""
"Этот флаг наследуется типами, которые еще не установили :c:macro:"
"`Py_TPFLAGS_MAPPING`."

#: ../../c-api/typeobj.rst:1383
msgid ""
"Internal. Do not set or unset this flag. To indicate that a class has "
"changed call :c:func:`PyType_Modified`"
msgstr ""
"Внутренний. Не устанавливайте и не снимайте этот флаг. Чтобы указать, что "
"класс изменился, вызовите :c:func:`PyType_Modified`"

#: ../../c-api/typeobj.rst:1387
msgid ""
"This flag is present in header files, but is not be used. It will be removed "
"in a future version of CPython"
msgstr ""
"Этот флаг присутствует в файлах заголовков, но не используется. Он будет "
"удален в будущей версии CPython."

#: ../../c-api/typeobj.rst:1393
msgid ""
"An optional pointer to a NUL-terminated C string giving the docstring for "
"this type object.  This is exposed as the :attr:`~type.__doc__` attribute on "
"the type and instances of the type."
msgstr ""
"Необязательный указатель на строку C, завершающуюся NUL, дающую строку "
"документации для этого объекта типа. Это отображается как атрибут :attr:"
"`~type.__doc__` для типа и экземпляров типа."

#: ../../c-api/typeobj.rst:1399
msgid "This field is *not* inherited by subtypes."
msgstr "Este campo *no* se hereda por los subtipos."

#: ../../c-api/typeobj.rst:1404
msgid ""
"An optional pointer to a traversal function for the garbage collector.  This "
"is only used if the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is set.  The "
"signature is::"
msgstr ""
"Необязательный указатель на функцию обхода сборщика мусора. Используется "
"только в том случае, если установлен бит флага :c:macro:"
"`Py_TPFLAGS_HAVE_GC`. Подпись такая::"

#: ../../c-api/typeobj.rst:1407
msgid "int tp_traverse(PyObject *self, visitproc visit, void *arg);"
msgstr "int tp_traverse(PyObject *self, visitproc visit, void *arg);"

#: ../../c-api/typeobj.rst:1409 ../../c-api/typeobj.rst:1553
msgid ""
"More information about Python's garbage collection scheme can be found in "
"section :ref:`supporting-cycle-detection`."
msgstr ""
"Más información sobre el esquema de recolección de basura de Python se puede "
"encontrar en la sección :ref:`supporting-cycle-detection`."

#: ../../c-api/typeobj.rst:1412
msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` pointer is used by the garbage "
"collector to detect reference cycles. A typical implementation of a :c:"
"member:`~PyTypeObject.tp_traverse` function simply calls :c:func:`Py_VISIT` "
"on each of the instance's members that are Python objects that the instance "
"owns. For example, this is function :c:func:`!local_traverse` from the :mod:"
"`!_thread` extension module::"
msgstr ""
"Указатель :c:member:`~PyTypeObject.tp_traverse` используется сборщиком "
"мусора для обнаружения ссылочных циклов. Типичная реализация функции :c:"
"member:`~PyTypeObject.tp_traverse` просто вызывает :c:func:`Py_VISIT` для "
"каждого из членов экземпляра, которые являются объектами Python, "
"принадлежащими экземпляру. Например, это функция :c:func:`!local_traverse` "
"из модуля расширения :mod:`!_thread`::"

#: ../../c-api/typeobj.rst:1418
msgid ""
"static int\n"
"local_traverse(localobject *self, visitproc visit, void *arg)\n"
"{\n"
"    Py_VISIT(self->args);\n"
"    Py_VISIT(self->kw);\n"
"    Py_VISIT(self->dict);\n"
"    return 0;\n"
"}"
msgstr ""

#: ../../c-api/typeobj.rst:1427
msgid ""
"Note that :c:func:`Py_VISIT` is called only on those members that can "
"participate in reference cycles.  Although there is also a ``self->key`` "
"member, it can only be ``NULL`` or a Python string and therefore cannot be "
"part of a reference cycle."
msgstr ""
"Tener en cuenta que :c:func:`Py_VISIT` solo se llama en aquellos miembros "
"que pueden participar en ciclos de referencia. Aunque también hay un miembro "
"``self->key``, solo puede ser ``NULL`` o una cadena de Python y, por lo "
"tanto, no puede formar parte de un ciclo de referencia."

#: ../../c-api/typeobj.rst:1431
msgid ""
"On the other hand, even if you know a member can never be part of a cycle, "
"as a debugging aid you may want to visit it anyway just so the :mod:`gc` "
"module's :func:`~gc.get_referents` function will include it."
msgstr ""
"Por otro lado, incluso si sabes que un miembro nunca puede formar parte de "
"un ciclo, como ayuda para depurar, es posible que desees visitarlo de todos "
"modos para que la función :func:`~gc.get_referents` del módulo :mod:`gc` lo "
"incluya."

#: ../../c-api/typeobj.rst:1435
msgid ""
"Heap types (:c:macro:`Py_TPFLAGS_HEAPTYPE`) must visit their type with::"
msgstr ""
"Heap types (:c:macro:`Py_TPFLAGS_HEAPTYPE`) must visit their type with::"

#: ../../c-api/typeobj.rst:1437
msgid "Py_VISIT(Py_TYPE(self));"
msgstr "Py_VISIT(Py_TYPE(self));"

#: ../../c-api/typeobj.rst:1439
msgid ""
"It is only needed since Python 3.9. To support Python 3.8 and older, this "
"line must be conditional::"
msgstr ""
"Это необходимо только начиная с Python 3.9. Для поддержки Python 3.8 и "
"старше эта строка должна быть условной:"

#: ../../c-api/typeobj.rst:1442
msgid ""
"#if PY_VERSION_HEX >= 0x03090000\n"
"    Py_VISIT(Py_TYPE(self));\n"
"#endif"
msgstr ""
"#if PY_VERSION_HEX >= 0x03090000\n"
"    Py_VISIT(Py_TYPE(self));\n"
"#endif"

#: ../../c-api/typeobj.rst:1446
msgid ""
"If the :c:macro:`Py_TPFLAGS_MANAGED_DICT` bit is set in the :c:member:"
"`~PyTypeObject.tp_flags` field, the traverse function must call :c:func:"
"`PyObject_VisitManagedDict` like this::"
msgstr ""
"Если в поле :c:member:`~PyTypeObject.tp_flags` установлен бит :c:macro:"
"`Py_TPFLAGS_MANAGED_DICT`, функция перемещения должна вызвать :c:func:"
"`PyObject_VisitManagedDict` следующим образом::"

#: ../../c-api/typeobj.rst:1450
msgid "PyObject_VisitManagedDict((PyObject*)self, visit, arg);"
msgstr "PyObject_VisitManagedDict((PyObject*)self, visit, arg);"

#: ../../c-api/typeobj.rst:1453
msgid ""
"When implementing :c:member:`~PyTypeObject.tp_traverse`, only the members "
"that the instance *owns* (by having :term:`strong references <strong "
"reference>` to them) must be visited. For instance, if an object supports "
"weak references via the :c:member:`~PyTypeObject.tp_weaklist` slot, the "
"pointer supporting the linked list (what *tp_weaklist* points to) must "
"**not** be visited as the instance does not directly own the weak references "
"to itself (the weakreference list is there to support the weak reference "
"machinery, but the instance has no strong reference to the elements inside "
"it, as they are allowed to be removed even if the instance is still alive)."
msgstr ""
"Під час реалізації :c:member:`~PyTypeObject.tp_traverse` необхідно відвідати "
"лише члени, якими *володіє* примірник (через наявність :term:`сильних "
"посилань <strong reference>` на них). Наприклад, якщо об’єкт підтримує "
"слабкі посилання через слот :c:member:`~PyTypeObject.tp_weaklist`, "
"вказівник, що підтримує зв’язаний список (на що вказує *tp_weaklist*), "
"**не** має відвідуватися, як це робить екземпляр не володіє безпосередньо "
"слабкими посиланнями на себе (список слабких посилань існує для підтримки "
"механізму слабких посилань, але екземпляр не має сильного посилання на "
"елементи всередині нього, оскільки їх можна видалити, навіть якщо екземпляр "
"все ще живий)."

#: ../../c-api/typeobj.rst:1464
msgid ""
"Note that :c:func:`Py_VISIT` requires the *visit* and *arg* parameters to :c:"
"func:`!local_traverse` to have these specific names; don't name them just "
"anything."
msgstr ""
"Обратите внимание, что :c:func:`Py_VISIT` требует, чтобы параметры *visit* и "
"*arg* :c:func:`!local_traverse` имели эти конкретные имена; не называйте их "
"просто так."

#: ../../c-api/typeobj.rst:1468
msgid ""
"Instances of :ref:`heap-allocated types <heap-types>` hold a reference to "
"their type. Their traversal function must therefore either visit :c:func:"
"`Py_TYPE(self) <Py_TYPE>`, or delegate this responsibility by calling "
"``tp_traverse`` of another heap-allocated type (such as a heap-allocated "
"superclass). If they do not, the type object may not be garbage-collected."
msgstr ""
"Екземпляри :ref:`виділених у купі типів <heap-types>` містять посилання на "
"свій тип. Таким чином, їх функція обходу повинна або відвідати :c:func:"
"`Py_TYPE(self) <Py_TYPE>`, або делегувати цю відповідальність, викликавши "
"``tp_traverse`` іншого типу, виділеного купою (наприклад, суперкласу, "
"виділеного купою). Якщо вони цього не роблять, об’єкт типу може не збиратися "
"сміттям."

#: ../../c-api/typeobj.rst:1477
msgid ""
"Heap-allocated types are expected to visit ``Py_TYPE(self)`` in "
"``tp_traverse``.  In earlier versions of Python, due to `bug 40217 <https://"
"bugs.python.org/issue40217>`_, doing this may lead to crashes in subclasses."
msgstr ""
"Los tipos asignados en el montón se espera que visiten ``Py_TYPE(self)`` en "
"``tp_traverse``. En versiones anteriores de Python, debido a `bug 40217 "
"<https://bugs.python.org/issue40217>`_, hacer esto puede provocar fallos en "
"las subclases."

#: ../../c-api/typeobj.rst:1486
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_clear` and the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit: the flag bit, :c:"
"member:`~PyTypeObject.tp_traverse`, and :c:member:`~PyTypeObject.tp_clear` "
"are all inherited from the base type if they are all zero in the subtype."
msgstr ""
"Это поле наследуется подтипами вместе с :c:member:`~PyTypeObject.tp_clear` и "
"битом флага :c:macro:`Py_TPFLAGS_HAVE_GC`: бит флага, :c:member:"
"`~PyTypeObject.tp_traverse` и : c:member:`~PyTypeObject.tp_clear` все "
"наследуются от базового типа, если все они равны нулю в подтипе."

#: ../../c-api/typeobj.rst:1494
msgid ""
"An optional pointer to a clear function for the garbage collector. This is "
"only used if the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is set.  The "
"signature is::"
msgstr ""

#: ../../c-api/typeobj.rst:1497
msgid "int tp_clear(PyObject *);"
msgstr "int tp_clear(PyObject *);"

#: ../../c-api/typeobj.rst:1499
msgid ""
"The :c:member:`~PyTypeObject.tp_clear` member function is used to break "
"reference cycles in cyclic garbage detected by the garbage collector.  Taken "
"together, all :c:member:`~PyTypeObject.tp_clear` functions in the system "
"must combine to break all reference cycles.  This is subtle, and if in any "
"doubt supply a :c:member:`~PyTypeObject.tp_clear` function.  For example, "
"the tuple type does not implement a :c:member:`~PyTypeObject.tp_clear` "
"function, because it's possible to prove that no reference cycle can be "
"composed entirely of tuples. Therefore the :c:member:`~PyTypeObject."
"tp_clear` functions of other types must be sufficient to break any cycle "
"containing a tuple.  This isn't immediately obvious, and there's rarely a "
"good reason to avoid implementing :c:member:`~PyTypeObject.tp_clear`."
msgstr ""
"La función miembro :c:member:`~PyTypeObject.tp_clear` se utiliza para romper "
"ciclos de referencia en la basura cíclica detectada por el recolector de "
"basura.  En conjunto, todas las funciones :c:member:`~PyTypeObject.tp_clear` "
"del sistema deben combinarse para romper todos los ciclos de referencia.  "
"Esto es sutil, y en caso de duda suministre una función :c:member:"
"`~PyTypeObject.tp_clear`.  Por ejemplo, el tipo tupla no implementa una "
"función :c:member:`~PyTypeObject.tp_clear`, porque es posible demostrar que "
"ningún ciclo de referencia puede estar compuesto enteramente por tuplas. Por "
"lo tanto, las funciones :c:member:`~PyTypeObject.tp_clear` de otros tipos "
"deben ser suficientes para romper cualquier ciclo que contenga una tupla.  "
"Esto no es inmediatamente obvio, y raramente hay una buena razón para evitar "
"implementar :c:member:`~PyTypeObject.tp_clear`."

#: ../../c-api/typeobj.rst:1509
msgid ""
"Implementations of :c:member:`~PyTypeObject.tp_clear` should drop the "
"instance's references to those of its members that may be Python objects, "
"and set its pointers to those members to ``NULL``, as in the following "
"example::"
msgstr ""
"Implementaciones de :c:member:`~PyTypeObject.tp_clear` deben eliminar las "
"referencias de la instancia a aquellos de sus miembros que puedan ser "
"objetos de Python, y establecer los punteros a esos miembros a ``NULL``, "
"como en el siguiente ejemplo::"

#: ../../c-api/typeobj.rst:1513
msgid ""
"static int\n"
"local_clear(localobject *self)\n"
"{\n"
"    Py_CLEAR(self->key);\n"
"    Py_CLEAR(self->args);\n"
"    Py_CLEAR(self->kw);\n"
"    Py_CLEAR(self->dict);\n"
"    return 0;\n"
"}"
msgstr ""

#: ../../c-api/typeobj.rst:1523
msgid ""
"The :c:func:`Py_CLEAR` macro should be used, because clearing references is "
"delicate:  the reference to the contained object must not be released (via :"
"c:func:`Py_DECREF`) until after the pointer to the contained object is set "
"to ``NULL``.  This is because releasing the reference may cause the "
"contained object to become trash, triggering a chain of reclamation activity "
"that may include invoking arbitrary Python code (due to finalizers, or "
"weakref callbacks, associated with the contained object). If it's possible "
"for such code to reference *self* again, it's important that the pointer to "
"the contained object be ``NULL`` at that time, so that *self* knows the "
"contained object can no longer be used.  The :c:func:`Py_CLEAR` macro "
"performs the operations in a safe order."
msgstr ""
"Следует использовать макрос :c:func:`Py_CLEAR`, поскольку очистка ссылок "
"является деликатной задачей: ссылка на содержащийся объект не должна "
"освобождаться (через :c:func:`Py_DECREF`) до тех пор, пока указатель на "
"содержащийся объект не будет освобожден. установлен в ``NULL``. Это связано "
"с тем, что освобождение ссылки может привести к тому, что содержащийся "
"объект станет мусором, что вызовет цепочку действий по восстановлению, "
"которая может включать вызов произвольного кода Python (из-за финализаторов "
"или обратных вызовов слабых ссылок, связанных с содержащимся объектом). Если "
"такой код может снова ссылаться на *self*, важно, чтобы указатель на "
"содержащийся объект в этот момент был равен NULL, чтобы *self* знал, что "
"содержащийся объект больше нельзя использовать. Макрос :c:func:`Py_CLEAR` "
"выполняет операции в безопасном порядке."

#: ../../c-api/typeobj.rst:1535
msgid ""
"If the :c:macro:`Py_TPFLAGS_MANAGED_DICT` bit is set in the :c:member:"
"`~PyTypeObject.tp_flags` field, the traverse function must call :c:func:"
"`PyObject_ClearManagedDict` like this::"
msgstr ""
"Если в поле :c:member:`~PyTypeObject.tp_flags` установлен бит :c:macro:"
"`Py_TPFLAGS_MANAGED_DICT`, функция перемещения должна вызвать :c:func:"
"`PyObject_ClearManagedDict` следующим образом::"

#: ../../c-api/typeobj.rst:1539
msgid "PyObject_ClearManagedDict((PyObject*)self);"
msgstr "PyObject_ClearManagedDict((PyObject*)self);"

#: ../../c-api/typeobj.rst:1541
msgid ""
"Note that :c:member:`~PyTypeObject.tp_clear` is not *always* called before "
"an instance is deallocated. For example, when reference counting is enough "
"to determine that an object is no longer used, the cyclic garbage collector "
"is not involved and :c:member:`~PyTypeObject.tp_dealloc` is called directly."
msgstr ""
"Tener en cuenta que :c:member:`~PyTypeObject.tp_clear` no siempre se llama "
"*siempre* antes de que se desasigne una instancia. Por ejemplo, cuando el "
"recuento de referencias es suficiente para determinar que un objeto ya no se "
"utiliza, el recolector de basura cíclico no está involucrado y se llama "
"directamente a :c:member:`~PyTypeObject.tp_dealloc`."

#: ../../c-api/typeobj.rst:1547
msgid ""
"Because the goal of :c:member:`~PyTypeObject.tp_clear` functions is to break "
"reference cycles, it's not necessary to clear contained objects like Python "
"strings or Python integers, which can't participate in reference cycles. On "
"the other hand, it may be convenient to clear all contained Python objects, "
"and write the type's :c:member:`~PyTypeObject.tp_dealloc` function to "
"invoke :c:member:`~PyTypeObject.tp_clear`."
msgstr ""
"Dado que el objetivo de las funciones :c:member:`~PyTypeObject.tp_clear` es "
"romper los ciclos de referencia, no es necesario borrar los objetos "
"contenidos como cadenas Python o enteros Python, que no pueden participar en "
"ciclos de referencia. Por otro lado, puede ser conveniente borrar todos los "
"objetos Python contenidos, y escribir la función :c:member:`~PyTypeObject."
"tp_dealloc` del tipo para invocar a :c:member:`~PyTypeObject.tp_clear`."

#: ../../c-api/typeobj.rst:1560
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_traverse` and the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit: the flag bit, :"
"c:member:`~PyTypeObject.tp_traverse`, and :c:member:`~PyTypeObject.tp_clear` "
"are all inherited from the base type if they are all zero in the subtype."
msgstr ""
"Это поле наследуется подтипами вместе с :c:member:`~PyTypeObject."
"tp_traverse` и битом флага :c:macro:`Py_TPFLAGS_HAVE_GC`: бит флага, :c:"
"member:`~PyTypeObject.tp_traverse` и : c:member:`~PyTypeObject.tp_clear` все "
"наследуются от базового типа, если все они равны нулю в подтипе."

#: ../../c-api/typeobj.rst:1568
msgid ""
"An optional pointer to the rich comparison function, whose signature is::"
msgstr ""
"Un puntero opcional a la función de comparación enriquecida, cuya firma es::"

#: ../../c-api/typeobj.rst:1570
msgid "PyObject *tp_richcompare(PyObject *self, PyObject *other, int op);"
msgstr "PyObject *tp_richcompare(PyObject *self, PyObject *other, int op);"

#: ../../c-api/typeobj.rst:1572
msgid ""
"The first parameter is guaranteed to be an instance of the type that is "
"defined by :c:type:`PyTypeObject`."
msgstr ""
"Se garantiza que el primer parámetro es una instancia del tipo definido por :"
"c:type:`PyTypeObject`."

#: ../../c-api/typeobj.rst:1575
msgid ""
"The function should return the result of the comparison (usually ``Py_True`` "
"or ``Py_False``).  If the comparison is undefined, it must return "
"``Py_NotImplemented``, if another error occurred it must return ``NULL`` and "
"set an exception condition."
msgstr ""
"La función debe devolver el resultado de la comparación (normalmente "
"``Py_True`` o ``Py_False``).  Si la comparación es indefinida, debe devolver "
"``Py_NotImplemented``, si se ha producido otro error debe devolver ``NULL`` "
"y establecer una condición de excepción."

#: ../../c-api/typeobj.rst:1580
msgid ""
"The following constants are defined to be used as the third argument for :c:"
"member:`~PyTypeObject.tp_richcompare` and for :c:func:`PyObject_RichCompare`:"
msgstr ""
"Las siguientes constantes están definidas para utilizarse como tercer "
"argumento para :c:member:`~PyTypeObject.tp_richcompare` y para :c:func:"
"`PyObject_RichCompare`."

#: ../../c-api/typeobj.rst:1586
msgid "Constant"
msgstr "Constante"

#: ../../c-api/typeobj.rst:1586
msgid "Comparison"
msgstr "Comparación"

#: ../../c-api/typeobj.rst:1588
msgid "``<``"
msgstr "``<``"

#: ../../c-api/typeobj.rst:1590
msgid "``<=``"
msgstr "``<=``"

#: ../../c-api/typeobj.rst:1592
msgid "``==``"
msgstr "``==``"

#: ../../c-api/typeobj.rst:1594
msgid "``!=``"
msgstr "``!=``"

#: ../../c-api/typeobj.rst:1596
msgid "``>``"
msgstr "``>``"

#: ../../c-api/typeobj.rst:1598
msgid "``>=``"
msgstr "``>=``"

#: ../../c-api/typeobj.rst:1601
msgid ""
"The following macro is defined to ease writing rich comparison functions:"
msgstr ""
"La siguiente macro está definida para facilitar la escritura de funciones de "
"comparación ricas."

#: ../../c-api/typeobj.rst:1605
msgid ""
"Return ``Py_True`` or ``Py_False`` from the function, depending on the "
"result of a comparison. VAL_A and VAL_B must be orderable by C comparison "
"operators (for example, they may be C ints or floats). The third argument "
"specifies the requested operation, as for :c:func:`PyObject_RichCompare`."
msgstr ""
"Devuelve ``Py_True`` o ``Py_False`` de la función, dependiendo del resultado "
"de una comparación. VAL_A y VAL_B deben ser ordenables por operadores de "
"comparación de C (por ejemplo, pueden ser ints o floats de C). El tercer "
"argumento especifica la operación solicitada, como para :c:func:"
"`PyObject_RichCompare`."

#: ../../c-api/typeobj.rst:1611
msgid "The returned value is a new :term:`strong reference`."
msgstr "Возвращаемое значение представляет собой новую :term:`сильную ссылку`."

#: ../../c-api/typeobj.rst:1613
msgid "On error, sets an exception and returns ``NULL`` from the function."
msgstr ""
"En caso de error, establece una excepción y devuelve ``NULL`` de la función."

#: ../../c-api/typeobj.rst:1621
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_hash`: a subtype inherits :c:member:`~PyTypeObject.tp_richcompare` and :c:"
"member:`~PyTypeObject.tp_hash` when the subtype's :c:member:`~PyTypeObject."
"tp_richcompare` and :c:member:`~PyTypeObject.tp_hash` are both ``NULL``."
msgstr ""
"Este campo es heredado por los subtipos junto con :c:member:`~PyTypeObject."
"tp_hash`: un subtipo hereda :c:member:`~PyTypeObject.tp_richcompare` y :c:"
"member:`~PyTypeObject.tp_hash` cuando :c:member:`~PyTypeObject."
"tp_richcompare` y :c:member:`~PyTypeObject.tp_hash` del subtipo son ambos "
"``NULL``."

#: ../../c-api/typeobj.rst:1628
msgid ""
":c:data:`PyBaseObject_Type` provides a :c:member:`~PyTypeObject."
"tp_richcompare` implementation, which may be inherited.  However, if only :c:"
"member:`~PyTypeObject.tp_hash` is defined, not even the inherited function "
"is used and instances of the type will not be able to participate in any "
"comparisons."
msgstr ""
":c:data:`PyBaseObject_Type` предоставляет реализацию :c:member:"
"`~PyTypeObject.tp_richcompare`, которая может передаваться по наследству. "
"Однако если определен только :c:member:`~PyTypeObject.tp_hash`, даже "
"унаследованная функция не используется и экземпляры типа не смогут "
"участвовать ни в каких сравнениях."

#: ../../c-api/typeobj.rst:1637
msgid ""
"While this field is still supported, :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` "
"should be used instead, if at all possible."
msgstr ""
"Хотя это поле все еще поддерживается, вместо него следует использовать :c:"
"macro:`Py_TPFLAGS_MANAGED_WEAKREF`, если это вообще возможно."

#: ../../c-api/typeobj.rst:1640
msgid ""
"If the instances of this type are weakly referenceable, this field is "
"greater than zero and contains the offset in the instance structure of the "
"weak reference list head (ignoring the GC header, if present); this offset "
"is used by :c:func:`PyObject_ClearWeakRefs` and the ``PyWeakref_*`` "
"functions.  The instance structure needs to include a field of type :c:expr:"
"`PyObject*` which is initialized to ``NULL``."
msgstr ""
"Если экземпляры этого типа имеют слабую ссылку, это поле больше нуля и "
"содержит смещение в структуре экземпляра заголовка списка слабых ссылок "
"(игнорируя заголовок GC, если он присутствует); это смещение используется "
"функциями :c:func:`PyObject_ClearWeakRefs` и ``PyWeakref_*``. Структура "
"экземпляра должна включать поле типа :c:expr:`PyObject*`, которое "
"инициализируется значением ``NULL``."

#: ../../c-api/typeobj.rst:1647
msgid ""
"Do not confuse this field with :c:member:`~PyTypeObject.tp_weaklist`; that "
"is the list head for weak references to the type object itself."
msgstr ""
"No confundir este campo con :c:member:`~PyTypeObject.tp_weaklist`; que es la "
"cabecera de la lista para referencias débiles al propio objeto de tipo."

#: ../../c-api/typeobj.rst:1650
msgid ""
"It is an error to set both the :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` bit "
"and :c:member:`~PyTypeObject.tp_weaklistoffset`."
msgstr ""
"Установка одновременно бита :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` и :c:"
"member:`~PyTypeObject.tp_weaklistoffset` является ошибкой."

#: ../../c-api/typeobj.rst:1655
msgid ""
"This field is inherited by subtypes, but see the rules listed below. A "
"subtype may override this offset; this means that the subtype uses a "
"different weak reference list head than the base type.  Since the list head "
"is always found via :c:member:`~PyTypeObject.tp_weaklistoffset`, this should "
"not be a problem."
msgstr ""
"Este campo es heredado por los subtipos, pero véanse las reglas indicadas a "
"continuación. Un subtipo puede anular este desplazamiento; esto significa "
"que el subtipo utiliza un encabezado de lista de referencia débil diferente "
"al del tipo base.  Dado que la cabeza de lista siempre se encuentra a través "
"de :c:member:`~PyTypeObject.tp_weaklistoffset`, esto no debería ser un "
"problema."

#: ../../c-api/typeobj.rst:1662
msgid ""
"If the :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` bit is set in the :c:member:"
"`~PyTypeObject.tp_flags` field, then :c:member:`~PyTypeObject."
"tp_weaklistoffset` will be set to a negative value, to indicate that it is "
"unsafe to use this field."
msgstr ""
"Если бит :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` установлен в поле :c:member:"
"`~PyTypeObject.tp_flags`, то :c:member:`~PyTypeObject.tp_weaklistoffset` "
"будет установлен в отрицательное значение, чтобы указать что использовать "
"это поле небезопасно."

#: ../../c-api/typeobj.rst:1670
msgid ""
"An optional pointer to a function that returns an :term:`iterator` for the "
"object.  Its presence normally signals that the instances of this type are :"
"term:`iterable` (although sequences may be iterable without this function)."
msgstr ""
"Додатковий покажчик на функцію, яка повертає :term:`iterator` для об’єкта. "
"Його наявність зазвичай сигналізує про те, що екземпляри цього типу :term:"
"`iterable` (хоча послідовності можуть бути ітерованими без цієї функції)."

#: ../../c-api/typeobj.rst:1674
msgid "This function has the same signature as :c:func:`PyObject_GetIter`::"
msgstr "Esta función tiene la misma firma que :c:func:`PyObject_GetIter`::."

#: ../../c-api/typeobj.rst:1676
msgid "PyObject *tp_iter(PyObject *self);"
msgstr "PyObject *tp_iter(PyObject *self);"

#: ../../c-api/typeobj.rst:1685
msgid ""
"An optional pointer to a function that returns the next item in an :term:"
"`iterator`. The signature is::"
msgstr ""
"Додатковий покажчик на функцію, яка повертає наступний елемент у :term:"
"`iterator`. Підпис::"

#: ../../c-api/typeobj.rst:1688
msgid "PyObject *tp_iternext(PyObject *self);"
msgstr "PyObject *tp_iternext(PyObject *self);"

#: ../../c-api/typeobj.rst:1690
msgid ""
"When the iterator is exhausted, it must return ``NULL``; a :exc:"
"`StopIteration` exception may or may not be set.  When another error occurs, "
"it must return ``NULL`` too.  Its presence signals that the instances of "
"this type are iterators."
msgstr ""
"Cuando el iterador se agota, debe devolver ``NULL``; se puede establecer o "
"no una excepción :exc:`StopIteration`.  Cuando se produce otro error, "
"también debe devolver ``NULL``.  Su presencia señala que las instancias de "
"este tipo son iteradores."

#: ../../c-api/typeobj.rst:1695
msgid ""
"Iterator types should also define the :c:member:`~PyTypeObject.tp_iter` "
"function, and that function should return the iterator instance itself (not "
"a new iterator instance)."
msgstr ""
"Los tipos de iterador también deben definir la función :c:member:"
"`~PyTypeObject.tp_iter`, y esa función debe devolver la propia instancia del "
"iterador (no una nueva instancia del iterador)."

#: ../../c-api/typeobj.rst:1699
msgid "This function has the same signature as :c:func:`PyIter_Next`."
msgstr "Esta función tiene la misma firma que :c:func:`PyIter_Next`."

#: ../../c-api/typeobj.rst:1708
msgid ""
"An optional pointer to a static ``NULL``-terminated array of :c:type:"
"`PyMethodDef` structures, declaring regular methods of this type."
msgstr ""
"Un puntero opcional a un array estático terminado en ``NULL`` de "
"estructuras :c:type:`PyMethodDef`, que declara métodos regulares de este "
"tipo."

#: ../../c-api/typeobj.rst:1711
msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a method descriptor."
msgstr ""
"Para cada entrada en el array, se añade una entrada al diccionario del tipo "
"(ver :c:member:`~PyTypeObject.tp_dict` abajo) que contiene un descriptor de "
"método."

#: ../../c-api/typeobj.rst:1716
msgid ""
"This field is not inherited by subtypes (methods are inherited through a "
"different mechanism)."
msgstr ""
"Este campo no se hereda por los subtipos (los métodos se heredan a través de "
"un mecanismo diferente)."

#: ../../c-api/typeobj.rst:1722
msgid ""
"An optional pointer to a static ``NULL``-terminated array of :c:type:"
"`PyMemberDef` structures, declaring regular data members (fields or slots) "
"of instances of this type."
msgstr ""
"Un puntero opcional a una matriz estática terminada en ``NULL`` de "
"estructuras :c:type:`PyMemberDef`, que declara miembros de datos regulares "
"(campos o ranuras) de instancias de este tipo."

#: ../../c-api/typeobj.rst:1726
msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a member descriptor."
msgstr ""
"Para cada entrada de la matriz, se añade una entrada al diccionario del tipo "
"(ver :c:member:`~PyTypeObject.tp_dict` más abajo) que contiene un descriptor "
"de miembro."

#: ../../c-api/typeobj.rst:1731
msgid ""
"This field is not inherited by subtypes (members are inherited through a "
"different mechanism)."
msgstr ""
"Este campo no se hereda por los subtipos (los miembros se heredan a través "
"de un mecanismo diferente)."

#: ../../c-api/typeobj.rst:1737
msgid ""
"An optional pointer to a static ``NULL``-terminated array of :c:type:"
"`PyGetSetDef` structures, declaring computed attributes of instances of this "
"type."
msgstr ""
"Un puntero opcional a una matriz estática ``NULL``-terminada de estructuras :"
"c:type:`PyGetSetDef`, declarando atributos computados de instancias de este "
"tipo."

#: ../../c-api/typeobj.rst:1740
msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a getset descriptor."
msgstr ""
"Para cada entrada de la matriz, se añade una entrada al diccionario del tipo "
"(ver :c:member:`~PyTypeObject.tp_dict` más abajo) que contiene un descriptor "
"getset."

#: ../../c-api/typeobj.rst:1745
msgid ""
"This field is not inherited by subtypes (computed attributes are inherited "
"through a different mechanism)."
msgstr ""
"Este campo no se hereda por los subtipos (los atributos calculados se "
"heredan a través de un mecanismo diferente)."

#: ../../c-api/typeobj.rst:1751
msgid ""
"An optional pointer to a base type from which type properties are "
"inherited.  At this level, only single inheritance is supported; multiple "
"inheritance require dynamically creating a type object by calling the "
"metatype."
msgstr ""
"Un puntero opcional a un tipo base del cual se heredan las propiedades del "
"tipo. A este nivel, solo se admite la herencia simple; la herencia múltiple "
"requiere crear dinámicamente un objeto de tipo llamando al metatipo."

#: ../../c-api/typeobj.rst:1759
msgid ""
"Slot initialization is subject to the rules of initializing globals. C99 "
"requires the initializers to be \"address constants\".  Function designators "
"like :c:func:`PyType_GenericNew`, with implicit conversion to a pointer, are "
"valid C99 address constants."
msgstr ""
"La inicialización de ranuras está sujeta a las reglas de inicialización de "
"globales. C99 requiere que los inicializadores sean \"constantes de "
"dirección\". Los designadores de funciones como :c:func:`PyType_GenericNew`, "
"con conversión implícita a un puntero, son constantes de dirección válidas "
"en C99."

#: ../../c-api/typeobj.rst:1764
msgid ""
"However, the unary '&' operator applied to a non-static variable like :c:"
"data:`PyBaseObject_Type` is not required to produce an address constant.  "
"Compilers may support this (gcc does), MSVC does not. Both compilers are "
"strictly standard conforming in this particular behavior."
msgstr ""
"Однако унарный оператор «&», примененный к нестатической переменной, такой "
"как :c:data:`PyBaseObject_Type`, не требуется для создания адресной "
"константы. Компиляторы могут поддерживать это (gcc поддерживает), MSVC — "
"нет. Оба компилятора строго соответствуют стандартам в этом конкретном "
"поведении."

#: ../../c-api/typeobj.rst:1770
msgid ""
"Consequently, :c:member:`~PyTypeObject.tp_base` should be set in the "
"extension module's init function."
msgstr ""
"En consecuencia, :c:member:`~PyTypeObject.tp_base` debe establecerse en la "
"función init del módulo de extensión."

#: ../../c-api/typeobj.rst:1775
msgid "This field is not inherited by subtypes (obviously)."
msgstr "Este campo no lo heredan los subtipos (evidentemente)."

#: ../../c-api/typeobj.rst:1779
msgid ""
"This field defaults to ``&PyBaseObject_Type`` (which to Python programmers "
"is known as the type :class:`object`)."
msgstr ""
"Este campo se establece por defecto en ``&PyBaseObject_Type`` (que para los "
"programadores de Python es conocido como el tipo :class:`object`)."

#: ../../c-api/typeobj.rst:1785
msgid "The type's dictionary is stored here by :c:func:`PyType_Ready`."
msgstr "El diccionario del tipo se almacena aquí por :c:func:`PyType_Ready`."

#: ../../c-api/typeobj.rst:1787
msgid ""
"This field should normally be initialized to ``NULL`` before PyType_Ready is "
"called; it may also be initialized to a dictionary containing initial "
"attributes for the type.  Once :c:func:`PyType_Ready` has initialized the "
"type, extra attributes for the type may be added to this dictionary only if "
"they don't correspond to overloaded operations (like :meth:`~object."
"__add__`).  Once initialization for the type has finished, this field should "
"be treated as read-only."
msgstr ""
"Обычно это поле должно быть инициализировано значением NULL перед вызовом "
"PyType_Ready; он также может быть инициализирован словарем, содержащим "
"начальные атрибуты типа. После того как :c:func:`PyType_Ready` "
"инициализирует тип, дополнительные атрибуты для типа могут быть добавлены в "
"этот словарь, только если они не соответствуют перегруженным операциям "
"(например, :meth:`~object.__add__`). После завершения инициализации типа это "
"поле следует рассматривать как доступное только для чтения."

#: ../../c-api/typeobj.rst:1795
msgid ""
"Some types may not store their dictionary in this slot. Use :c:func:"
"`PyType_GetDict` to retrieve the dictionary for an arbitrary type."
msgstr ""
"Некоторые типы могут не хранить свой словарь в этом слоте. Используйте :c:"
"func:`PyType_GetDict` для получения словаря произвольного типа."

#: ../../c-api/typeobj.rst:1801
msgid ""
"Internals detail: For static builtin types, this is always ``NULL``. "
"Instead, the dict for such types is stored on ``PyInterpreterState``. Use :c:"
"func:`PyType_GetDict` to get the dict for an arbitrary type."
msgstr ""
"Детали внутреннего устройства: для статических встроенных типов это всегда "
"значение NULL. Вместо этого описание таких типов хранится в "
"PyInterpreterState. Используйте :c:func:`PyType_GetDict`, чтобы получить "
"dict для произвольного типа."

#: ../../c-api/typeobj.rst:1807
msgid ""
"This field is not inherited by subtypes (though the attributes defined in "
"here are inherited through a different mechanism)."
msgstr ""
"Este campo no lo heredan los subtipos (aunque los atributos aquí definidos "
"se heredan a través de un mecanismo diferente)."

#: ../../c-api/typeobj.rst:1812
msgid ""
"If this field is ``NULL``, :c:func:`PyType_Ready` will assign a new "
"dictionary to it."
msgstr ""
"Si este campo es ``NULL``, :c:func:`PyType_Ready` le asignará un nuevo "
"diccionario."

#: ../../c-api/typeobj.rst:1817
msgid ""
"It is not safe to use :c:func:`PyDict_SetItem` on or otherwise modify :c:"
"member:`~PyTypeObject.tp_dict` with the dictionary C-API."
msgstr ""
"No es seguro utilizar :c:func:`PyDict_SetItem` o modificar de otra manera :c:"
"member:`~PyTypeObject.tp_dict` con la API de diccionario en C."

#: ../../c-api/typeobj.rst:1823
msgid "An optional pointer to a \"descriptor get\" function."
msgstr "Un puntero opcional a una función \"descriptor get\"."

#: ../../c-api/typeobj.rst:1825 ../../c-api/typeobj.rst:1841
#: ../../c-api/typeobj.rst:1905 ../../c-api/typeobj.rst:1935
#: ../../c-api/typeobj.rst:1959
msgid "The function signature is::"
msgstr "La firma de la función es::"

#: ../../c-api/typeobj.rst:1827
msgid "PyObject * tp_descr_get(PyObject *self, PyObject *obj, PyObject *type);"
msgstr ""
"PyObject * tp_descr_get(PyObject *self, PyObject *obj, PyObject *type);"

#: ../../c-api/typeobj.rst:1838
msgid ""
"An optional pointer to a function for setting and deleting a descriptor's "
"value."
msgstr ""
"Un puntero opcional a una función para establecer y eliminar el valor de un "
"descriptor."

#: ../../c-api/typeobj.rst:1843
msgid "int tp_descr_set(PyObject *self, PyObject *obj, PyObject *value);"
msgstr "int tp_descr_set(PyObject *self, PyObject *obj, PyObject *value);"

#: ../../c-api/typeobj.rst:1845
msgid "The *value* argument is set to ``NULL`` to delete the value."
msgstr ""
"El argumento *value* se establece como ``NULL`` para eliminar el valor."

#: ../../c-api/typeobj.rst:1856
msgid ""
"While this field is still supported, :c:macro:`Py_TPFLAGS_MANAGED_DICT` "
"should be used instead, if at all possible."
msgstr ""
"Хотя это поле все еще поддерживается, вместо него следует использовать :c:"
"macro:`Py_TPFLAGS_MANAGED_DICT`, если это вообще возможно."

#: ../../c-api/typeobj.rst:1859
msgid ""
"If the instances of this type have a dictionary containing instance "
"variables, this field is non-zero and contains the offset in the instances "
"of the type of the instance variable dictionary; this offset is used by :c:"
"func:`PyObject_GenericGetAttr`."
msgstr ""
"Si las instancias de este tipo tienen un diccionario que contiene variables "
"de instancia, este campo es distinto de cero y contiene el desplazamiento en "
"las instancias del tipo del diccionario de variables de instancia; este "
"desplazamiento lo utiliza  :c:func:`PyObject_GenericGetAttr`."

#: ../../c-api/typeobj.rst:1864
msgid ""
"Do not confuse this field with :c:member:`~PyTypeObject.tp_dict`; that is "
"the dictionary for attributes of the type object itself."
msgstr ""
"No confundir este campo con :c:member:`~PyTypeObject.tp_dict`; ese es el "
"diccionario para atributos del propio objeto de tipo."

#: ../../c-api/typeobj.rst:1867
msgid ""
"The value specifies the offset of the dictionary from the start of the "
"instance structure."
msgstr "Значение определяет смещение словаря от начала структуры экземпляра."

#: ../../c-api/typeobj.rst:1869
msgid ""
"The :c:member:`~PyTypeObject.tp_dictoffset` should be regarded as write-"
"only. To get the pointer to the dictionary call :c:func:"
"`PyObject_GenericGetDict`. Calling :c:func:`PyObject_GenericGetDict` may "
"need to allocate memory for the dictionary, so it is may be more efficient "
"to call :c:func:`PyObject_GetAttr` when accessing an attribute on the object."
msgstr ""
":c:member:`~PyTypeObject.tp_dictoffset` следует рассматривать как доступный "
"только для записи. Чтобы получить указатель на словарь, вызовите :c:func:"
"`PyObject_GenericGetDict`. Вызов :c:func:`PyObject_GenericGetDict` может "
"потребовать выделения памяти для словаря, поэтому может оказаться более "
"эффективным вызвать :c:func:`PyObject_GetAttr` при доступе к атрибуту "
"объекта."

#: ../../c-api/typeobj.rst:1875
msgid ""
"It is an error to set both the :c:macro:`Py_TPFLAGS_MANAGED_DICT` bit and :c:"
"member:`~PyTypeObject.tp_dictoffset`."
msgstr ""
"Ошибкой является установка одновременно бита :c:macro:"
"`Py_TPFLAGS_MANAGED_DICT` и :c:member:`~PyTypeObject.tp_dictoffset`."

#: ../../c-api/typeobj.rst:1880
msgid ""
"This field is inherited by subtypes. A subtype should not override this "
"offset; doing so could be unsafe, if C code tries to access the dictionary "
"at the previous offset. To properly support inheritance, use :c:macro:"
"`Py_TPFLAGS_MANAGED_DICT`."
msgstr ""
"Это поле наследуется подтипами. Подтип не должен переопределять это "
"смещение; это может быть небезопасно, если код C попытается получить доступ "
"к словарю по предыдущему смещению. Чтобы правильно поддерживать "
"наследование, используйте :c:macro:`Py_TPFLAGS_MANAGED_DICT`."

#: ../../c-api/typeobj.rst:1887
msgid ""
"This slot has no default.  For :ref:`static types <static-types>`, if the "
"field is ``NULL`` then no :attr:`~object.__dict__` gets created for "
"instances."
msgstr ""
"Этот слот не имеет значения по умолчанию. Для :ref:`статических типов "
"<static-types>`, если поле равно ``NULL``, то :attr:`~object.__dict__` для "
"экземпляров не создается."

#: ../../c-api/typeobj.rst:1890
msgid ""
"If the :c:macro:`Py_TPFLAGS_MANAGED_DICT` bit is set in the :c:member:"
"`~PyTypeObject.tp_flags` field, then :c:member:`~PyTypeObject.tp_dictoffset` "
"will be set to ``-1``, to indicate that it is unsafe to use this field."
msgstr ""
"Если в поле :c:member:`~PyTypeObject.tp_flags` установлен бит :c:macro:"
"`Py_TPFLAGS_MANAGED_DICT`, то :c:member:`~PyTypeObject.tp_dictoffset` будет "
"установлен в ``-1`` , чтобы указать, что использовать это поле небезопасно."

#: ../../c-api/typeobj.rst:1898
msgid "An optional pointer to an instance initialization function."
msgstr "Un puntero opcional a una función de inicialización de instancia."

#: ../../c-api/typeobj.rst:1900
msgid ""
"This function corresponds to the :meth:`~object.__init__` method of "
"classes.  Like :meth:`!__init__`, it is possible to create an instance "
"without calling :meth:`!__init__`, and it is possible to reinitialize an "
"instance by calling its :meth:`!__init__` method again."
msgstr ""
"Эта функция соответствует методу классов :meth:`~object.__init__`. Как и :"
"meth:`!__init__`, можно создать экземпляр без вызова :meth:`!__init__`, а "
"также можно повторно инициализировать экземпляр, снова вызвав его метод :"
"meth:`!__init__`."

#: ../../c-api/typeobj.rst:1907
msgid "int tp_init(PyObject *self, PyObject *args, PyObject *kwds);"
msgstr "int tp_init(PyObject *self, PyObject *args, PyObject *kwds);"

#: ../../c-api/typeobj.rst:1909
msgid ""
"The self argument is the instance to be initialized; the *args* and *kwds* "
"arguments represent positional and keyword arguments of the call to :meth:"
"`~object.__init__`."
msgstr ""
"Аргумент self — это экземпляр, который нужно инициализировать; Аргументы "
"*args* и *kwds* представляют собой позиционные и ключевые аргументы вызова :"
"meth:`~object.__init__`."

#: ../../c-api/typeobj.rst:1913
msgid ""
"The :c:member:`~PyTypeObject.tp_init` function, if not ``NULL``, is called "
"when an instance is created normally by calling its type, after the type's :"
"c:member:`~PyTypeObject.tp_new` function has returned an instance of the "
"type.  If the :c:member:`~PyTypeObject.tp_new` function returns an instance "
"of some other type that is not a subtype of the original type, no :c:member:"
"`~PyTypeObject.tp_init` function is called; if :c:member:`~PyTypeObject."
"tp_new` returns an instance of a subtype of the original type, the "
"subtype's :c:member:`~PyTypeObject.tp_init` is called."
msgstr ""
"La función :c:member:`~PyTypeObject.tp_init`, si no es ``NULL``, se llama "
"cuando se crea una instancia normalmente llamando a su tipo, después de que "
"la función :c:member:`~PyTypeObject.tp_new` del tipo haya devuelto una "
"instancia del tipo. Si la función :c:member:`~PyTypeObject.tp_new` devuelve "
"una instancia de algún otro tipo que no sea un subtipo del tipo original, no "
"se llama a la función :c:member:`~PyTypeObject.tp_init`; si :c:member:"
"`~PyTypeObject.tp_new` devuelve una instancia de un subtipo del tipo "
"original, se llama a :c:member:`~PyTypeObject.tp_init` del subtipo."

#: ../../c-api/typeobj.rst:1920
msgid "Returns ``0`` on success, ``-1`` and sets an exception on error."
msgstr ""
"Devuelve ``0`` en caso de éxito, ``-1`` y establece una excepción en caso de "
"error."

#: ../../c-api/typeobj.rst:1928
msgid ""
"For :ref:`static types <static-types>` this field does not have a default."
msgstr ""
"Для :ref:`статичних типів <static-types>` це поле не має значення за "
"замовчуванням."

#: ../../c-api/typeobj.rst:1933
msgid "An optional pointer to an instance allocation function."
msgstr "Un puntero opcional a una función de asignación de instancias."

#: ../../c-api/typeobj.rst:1937
msgid "PyObject *tp_alloc(PyTypeObject *self, Py_ssize_t nitems);"
msgstr "PyObject *tp_alloc(PyTypeObject *self, Py_ssize_t nitems);"

#: ../../c-api/typeobj.rst:1941
msgid ""
"This field is inherited by static subtypes, but not by dynamic subtypes "
"(subtypes created by a class statement)."
msgstr ""
"Este campo es heredado por subtipos estáticos, pero no por subtipos "
"dinámicos (subtipos creados por una declaración de clase)."

#: ../../c-api/typeobj.rst:1946
msgid ""
"For dynamic subtypes, this field is always set to :c:func:"
"`PyType_GenericAlloc`, to force a standard heap allocation strategy."
msgstr ""
"Para subtipos dinámicos, este campo siempre se establece en :c:func:"
"`PyType_GenericAlloc`, para forzar una estrategia de asignación de montón "
"estándar."

#: ../../c-api/typeobj.rst:1950
msgid ""
"For static subtypes, :c:data:`PyBaseObject_Type` uses :c:func:"
"`PyType_GenericAlloc`.  That is the recommended value for all statically "
"defined types."
msgstr ""

#: ../../c-api/typeobj.rst:1957
msgid "An optional pointer to an instance creation function."
msgstr "Un puntero opcional a una función de creación de instancias."

#: ../../c-api/typeobj.rst:1961
msgid ""
"PyObject *tp_new(PyTypeObject *subtype, PyObject *args, PyObject *kwds);"
msgstr ""
"PyObject *tp_new(PyTypeObject *subtype, PyObject *args, PyObject *kwds);"

#: ../../c-api/typeobj.rst:1963
msgid ""
"The *subtype* argument is the type of the object being created; the *args* "
"and *kwds* arguments represent positional and keyword arguments of the call "
"to the type.  Note that *subtype* doesn't have to equal the type whose :c:"
"member:`~PyTypeObject.tp_new` function is called; it may be a subtype of "
"that type (but not an unrelated type)."
msgstr ""
"El argumento *subtype* es el tipo del objeto que se está creando; los "
"argumentos *args* y *kwds* representan argumentos posicionales y de palabras "
"clave de la llamada al tipo. Tener en cuenta que *subtype* no tiene que ser "
"igual al tipo cuya función :c:member:`~PyTypeObject.tp_new` se llama; puede "
"ser un subtipo de ese tipo (pero no un tipo no relacionado)."

#: ../../c-api/typeobj.rst:1969
msgid ""
"The :c:member:`~PyTypeObject.tp_new` function should call ``subtype-"
">tp_alloc(subtype, nitems)`` to allocate space for the object, and then do "
"only as much further initialization as is absolutely necessary.  "
"Initialization that can safely be ignored or repeated should be placed in "
"the :c:member:`~PyTypeObject.tp_init` handler.  A good rule of thumb is that "
"for immutable types, all initialization should take place in :c:member:"
"`~PyTypeObject.tp_new`, while for mutable types, most initialization should "
"be deferred to :c:member:`~PyTypeObject.tp_init`."
msgstr ""
"La función :c:member:`~PyTypeObject.tp_new` debería llamar a ``subtype-"
">tp_alloc(subtype, nitems)`` para asignar espacio para el objeto, y luego "
"realizar solo la inicialización adicional necesaria. La inicialización que "
"se pueda ignorar o repetir de forma segura debe colocarse en el controlador :"
"c:member:`~PyTypeObject.tp_init`. Una buena regla general es que, para tipos "
"inmutables, toda la inicialización debe tener lugar en :c:member:"
"`~PyTypeObject.tp_new`, mientras que, para tipos mutables, la mayoría de la "
"inicialización debe posponerse a :c:member:`~PyTypeObject.tp_init`."

#: ../../c-api/typeobj.rst:1977
msgid ""
"Set the :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION` flag to disallow "
"creating instances of the type in Python."
msgstr ""
"Установите флаг :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION`, чтобы "
"запретить создание экземпляров этого типа в Python."

#: ../../c-api/typeobj.rst:1982
msgid ""
"This field is inherited by subtypes, except it is not inherited by :ref:"
"`static types <static-types>` whose :c:member:`~PyTypeObject.tp_base` is "
"``NULL`` or ``&PyBaseObject_Type``."
msgstr ""
"Це поле успадковується підтипами, за винятком :ref:`статичних типів <static-"
"types>`, у яких :c:member:`~PyTypeObject.tp_base` має значення ``NULL`` або "
"``&PyBaseObject_Type``."

#: ../../c-api/typeobj.rst:1988
msgid ""
"For :ref:`static types <static-types>` this field has no default. This means "
"if the slot is defined as ``NULL``, the type cannot be called to create new "
"instances; presumably there is some other way to create instances, like a "
"factory function."
msgstr ""
"Для :ref:`статичних типів <static-types>` це поле не має типового значення. "
"Це означає, що якщо слот визначено як ``NULL``, тип не можна викликати для "
"створення нових екземплярів; мабуть, існує якийсь інший спосіб створення "
"екземплярів, як-от фабрична функція."

#: ../../c-api/typeobj.rst:1996
msgid ""
"An optional pointer to an instance deallocation function.  Its signature is::"
msgstr ""
"Un puntero opcional a una función de desasignación de instancias. Su firma "
"es:"

#: ../../c-api/typeobj.rst:1998
msgid "void tp_free(void *self);"
msgstr "void tp_free(void *self);"

#: ../../c-api/typeobj.rst:2000
msgid ""
"An initializer that is compatible with this signature is :c:func:"
"`PyObject_Free`."
msgstr "Un inicializador compatible con esta firma es :c:func:`PyObject_Free`."

#: ../../c-api/typeobj.rst:2004
msgid ""
"This field is inherited by static subtypes, but not by dynamic subtypes "
"(subtypes created by a class statement)"
msgstr ""
"Este campo es heredado por subtipos estáticos, pero no por subtipos "
"dinámicos (subtipos creados por una declaración de clase)"

#: ../../c-api/typeobj.rst:2009
msgid ""
"In dynamic subtypes, this field is set to a deallocator suitable to match :c:"
"func:`PyType_GenericAlloc` and the value of the :c:macro:"
"`Py_TPFLAGS_HAVE_GC` flag bit."
msgstr ""

#: ../../c-api/typeobj.rst:2013
msgid ""
"For static subtypes, :c:data:`PyBaseObject_Type` uses :c:func:`PyObject_Del`."
msgstr ""

#: ../../c-api/typeobj.rst:2018
msgid "An optional pointer to a function called by the garbage collector."
msgstr "Un puntero opcional a una función llamada por el recolector de basura."

#: ../../c-api/typeobj.rst:2020
msgid ""
"The garbage collector needs to know whether a particular object is "
"collectible or not.  Normally, it is sufficient to look at the object's "
"type's :c:member:`~PyTypeObject.tp_flags` field, and check the :c:macro:"
"`Py_TPFLAGS_HAVE_GC` flag bit.  But some types have a mixture of statically "
"and dynamically allocated instances, and the statically allocated instances "
"are not collectible.  Such types should define this function; it should "
"return ``1`` for a collectible instance, and ``0`` for a non-collectible "
"instance. The signature is::"
msgstr ""
"Сборщику мусора необходимо знать, можно ли собирать конкретный объект или "
"нет. Обычно достаточно просмотреть поле :c:member:`~PyTypeObject.tp_flags` "
"типа объекта и проверить бит флага :c:macro:`Py_TPFLAGS_HAVE_GC`. Но "
"некоторые типы содержат смесь статически и динамически выделяемых "
"экземпляров, и статически выделенные экземпляры не подлежат сбору. Такие "
"типы должны определять эту функцию; он должен возвращать ``1`` для "
"коллекционного экземпляра и ``0`` для неколлекционируемого экземпляра. "
"Подпись такая::"

#: ../../c-api/typeobj.rst:2028
msgid "int tp_is_gc(PyObject *self);"
msgstr "int tp_is_gc(PyObject *self);"

#: ../../c-api/typeobj.rst:2030
msgid ""
"(The only example of this are types themselves.  The metatype, :c:data:"
"`PyType_Type`, defines this function to distinguish between statically and :"
"ref:`dynamically allocated types <heap-types>`.)"
msgstr ""
"(Єдиним прикладом цього є самі типи. Метатип :c:data:`PyType_Type` визначає "
"цю функцію, щоб розрізняти статично та :ref:`динамічно виділені типи <heap-"
"types>`.)"

#: ../../c-api/typeobj.rst:2040
msgid ""
"This slot has no default.  If this field is ``NULL``, :c:macro:"
"`Py_TPFLAGS_HAVE_GC` is used as the functional equivalent."
msgstr ""
"Этот слот не имеет значения по умолчанию. Если это поле равно NULL, в "
"качестве функционального эквивалента используется :c:macro:"
"`Py_TPFLAGS_HAVE_GC`."

#: ../../c-api/typeobj.rst:2046
msgid "Tuple of base types."
msgstr "Tupla de tipos base."

#: ../../c-api/typeobj.rst:2048 ../../c-api/typeobj.rst:2072
msgid ""
"This field should be set to ``NULL`` and treated as read-only. Python will "
"fill it in when the type is :c:func:`initialized <PyType_Ready>`."
msgstr ""
"Это поле должно быть установлено в NULL и рассматриваться как доступное "
"только для чтения. Python заполнит его, если тип :c:func:`initialized "
"<PyType_Ready>`."

#: ../../c-api/typeobj.rst:2051
msgid ""
"For dynamically created classes, the ``Py_tp_bases`` :c:type:`slot "
"<PyType_Slot>` can be used instead of the *bases* argument of :c:func:"
"`PyType_FromSpecWithBases`. The argument form is preferred."
msgstr ""
"Для динамически создаваемых классов вместо аргумента *bases* функции :c:func:"
"`PyType_FromSpecWithBases` можно использовать ``Py_tp_bases`` :c:type:`slot "
"<PyType_Slot>`. Форма аргумента является предпочтительной."

#: ../../c-api/typeobj.rst:2058
msgid ""
"Multiple inheritance does not work well for statically defined types. If you "
"set ``tp_bases`` to a tuple, Python will not raise an error, but some slots "
"will only be inherited from the first base."
msgstr ""
"Множественное наследование не работает для статически определенных типов. "
"Если вы установите для tp_bases кортеж, Python не выдаст ошибку, но "
"некоторые слоты будут унаследованы только от первой базы."

#: ../../c-api/typeobj.rst:2064 ../../c-api/typeobj.rst:2087
#: ../../c-api/typeobj.rst:2104 ../../c-api/typeobj.rst:2121
#: ../../c-api/typeobj.rst:2135
msgid "This field is not inherited."
msgstr "Este campo no se hereda."

#: ../../c-api/typeobj.rst:2069
msgid ""
"Tuple containing the expanded set of base types, starting with the type "
"itself and ending with :class:`object`, in Method Resolution Order."
msgstr ""
"Tupla que contiene el conjunto ampliado de tipos base, comenzando con el "
"propio tipo y terminando con :class:`object`, en el Orden de Resolución de "
"Métodos."

#: ../../c-api/typeobj.rst:2077
msgid ""
"This field is not inherited; it is calculated fresh by :c:func:"
"`PyType_Ready`."
msgstr ""
"Este campo no se hereda; se calcula de nuevo mediante :c:func:`PyType_Ready`."

#: ../../c-api/typeobj.rst:2083
msgid "Unused.  Internal use only."
msgstr "Sin utilizar. Solo para uso interno."

#: ../../c-api/typeobj.rst:2092
msgid ""
"A collection of subclasses.  Internal use only.  May be an invalid pointer."
msgstr ""
"Коллекция подклассов. Только для внутреннего использования. Возможно, это "
"неверный указатель."

#: ../../c-api/typeobj.rst:2094
msgid ""
"To get a list of subclasses, call the Python method :py:meth:`~type."
"__subclasses__`."
msgstr ""
"Чтобы получить список подклассов, вызовите метод Python :py:meth:`~type."
"__subclasses__`."

#: ../../c-api/typeobj.rst:2099
msgid ""
"For some types, this field does not hold a valid :c:expr:`PyObject*`. The "
"type was changed to :c:expr:`void*` to indicate this."
msgstr ""
"Для некоторых типов это поле не содержит допустимого значения :c:expr:"
"`PyObject*`. Чтобы указать на это, тип был изменен на :c:expr:`void*`."

#: ../../c-api/typeobj.rst:2109
msgid ""
"Weak reference list head, for weak references to this type object.  Not "
"inherited.  Internal use only."
msgstr ""
"Lista de referencia débil principal, para referencias débiles a este objeto "
"de tipo. No heredado. Solo para uso interno."

#: ../../c-api/typeobj.rst:2114
msgid ""
"Internals detail: For the static builtin types this is always ``NULL``, even "
"if weakrefs are added.  Instead, the weakrefs for each are stored on "
"``PyInterpreterState``.  Use the public C-API or the internal "
"``_PyObject_GET_WEAKREFS_LISTPTR()`` macro to avoid the distinction."
msgstr ""
"Детали внутреннего устройства: для статических встроенных типов это всегда "
"NULL, даже если добавлены слабые ссылки. Вместо этого слабые ссылки для "
"каждого хранятся в PyInterpreterState. Используйте общедоступный C-API или "
"внутренний макрос ``_PyObject_GET_WEAKREFS_LISTPTR()``, чтобы избежать "
"различия."

#: ../../c-api/typeobj.rst:2126
msgid ""
"This field is deprecated.  Use :c:member:`~PyTypeObject.tp_finalize` instead."
msgstr ""
"Este campo está obsoleto. Usar :c:member:`~PyTypeObject.tp_finalize` en su "
"lugar."

#: ../../c-api/typeobj.rst:2131
msgid "Used to index into the method cache.  Internal use only."
msgstr "Utilizado para indexar en la caché del método. Uso interno solamente."

#: ../../c-api/typeobj.rst:2140
msgid ""
"An optional pointer to an instance finalization function.  Its signature is::"
msgstr ""
"Un puntero opcional a una función de finalización de instancia. Su firma es:"

#: ../../c-api/typeobj.rst:2142
msgid "void tp_finalize(PyObject *self);"
msgstr "void tp_finalize(PyObject *self);"

#: ../../c-api/typeobj.rst:2144
msgid ""
"If :c:member:`~PyTypeObject.tp_finalize` is set, the interpreter calls it "
"once when finalizing an instance.  It is called either from the garbage "
"collector (if the instance is part of an isolated reference cycle) or just "
"before the object is deallocated.  Either way, it is guaranteed to be called "
"before attempting to break reference cycles, ensuring that it finds the "
"object in a sane state."
msgstr ""
"Si :c:member:`~PyTypeObject.tp_finalize` está configurado, el intérprete lo "
"llama una vez al finalizar una instancia. Se llama ya sea desde el "
"recolector de basura (si la instancia es parte de un ciclo de referencia "
"aislado) o justo antes de que el objeto sea desasignado. De cualquier "
"manera, se garantiza que se llame antes de intentar romper los ciclos de "
"referencia, asegurando que encuentre el objeto en un estado coherente."

#: ../../c-api/typeobj.rst:2151
msgid ""
":c:member:`~PyTypeObject.tp_finalize` should not mutate the current "
"exception status; therefore, a recommended way to write a non-trivial "
"finalizer is::"
msgstr ""
":c:member:`~PyTypeObject.tp_finalize` no debe modificar el estado actual de "
"la excepción; por lo tanto, una forma recomendada de escribir un finalizador "
"no trivial es:"

#: ../../c-api/typeobj.rst:2154
msgid ""
"static void\n"
"local_finalize(PyObject *self)\n"
"{\n"
"    /* Save the current exception, if any. */\n"
"    PyObject *exc = PyErr_GetRaisedException();\n"
"\n"
"    /* ... */\n"
"\n"
"    /* Restore the saved exception. */\n"
"    PyErr_SetRaisedException(exc);\n"
"}"
msgstr ""

#: ../../c-api/typeobj.rst:2174
msgid ""
"Before version 3.8 it was necessary to set the :c:macro:"
"`Py_TPFLAGS_HAVE_FINALIZE` flags bit in order for this field to be used.  "
"This is no longer required."
msgstr ""
"До версии 3.8 необходимо было установить бит флагов :c:macro:"
"`Py_TPFLAGS_HAVE_FINALIZE`, чтобы это поле можно было использовать. Это "
"больше не требуется."

#: ../../c-api/typeobj.rst:2178
msgid "\"Safe object finalization\" (:pep:`442`)"
msgstr "\"Finalización segura de objetos\" (:pep:`442`)"

#: ../../c-api/typeobj.rst:2183
msgid ""
"Vectorcall function to use for calls of this type object. In other words, it "
"is used to implement :ref:`vectorcall <vectorcall>` for ``type.__call__``. "
"If ``tp_vectorcall`` is ``NULL``, the default call implementation using :"
"meth:`~object.__new__` and :meth:`~object.__init__` is used."
msgstr ""

#: ../../c-api/typeobj.rst:2191
msgid "This field is never inherited."
msgstr "Este campo nunca se hereda."

#: ../../c-api/typeobj.rst:2193
msgid "(the field exists since 3.8 but it's only used since 3.9)"
msgstr ""
"(el campo existe desde la versión 3.8 pero solo se utiliza desde la versión "
"3.9)"

#: ../../c-api/typeobj.rst:2198
msgid "Internal. Do not use."
msgstr "Внутренний. Не используйте."

#: ../../c-api/typeobj.rst:2206
msgid "Static Types"
msgstr "Статичні типи"

#: ../../c-api/typeobj.rst:2208
msgid ""
"Traditionally, types defined in C code are *static*, that is, a static :c:"
"type:`PyTypeObject` structure is defined directly in code and initialized "
"using :c:func:`PyType_Ready`."
msgstr ""
"Tradicionalmente, los tipos definidos en el código C son *estáticos*, es "
"decir, se define una estructura estática :c:type:`PyTypeObject` directamente "
"en el código y se inicializa utilizando :c:func:`PyType_Ready`."

#: ../../c-api/typeobj.rst:2212
msgid ""
"This results in types that are limited relative to types defined in Python:"
msgstr ""
"Esto resulta en tipos que están limitados en comparación con los tipos "
"definidos en Python:"

#: ../../c-api/typeobj.rst:2214
msgid ""
"Static types are limited to one base, i.e. they cannot use multiple "
"inheritance."
msgstr ""
"Los tipos estáticos están limitados a una base, es decir, no pueden utilizar "
"herencia múltiple."

#: ../../c-api/typeobj.rst:2216
msgid ""
"Static type objects (but not necessarily their instances) are immutable. It "
"is not possible to add or modify the type object's attributes from Python."
msgstr ""
"Los objetos de tipo estático (pero no necesariamente sus instancias) son "
"inmutables. No es posible agregar o modificar los atributos del objeto de "
"tipo desde Python."

#: ../../c-api/typeobj.rst:2218
msgid ""
"Static type objects are shared across :ref:`sub-interpreters <sub-"
"interpreter-support>`, so they should not include any subinterpreter-"
"specific state."
msgstr ""
"Los objetos de tipo estático se comparten entre :ref:`ssub-interpreters <sub-"
"interpreter-support>`, por lo que no deben incluir ningún estado específico "
"del sub-intérprete."

#: ../../c-api/typeobj.rst:2222
msgid ""
"Also, since :c:type:`PyTypeObject` is only part of the :ref:`Limited API "
"<limited-c-api>` as an opaque struct, any extension modules using static "
"types must be compiled for a specific Python minor version."
msgstr ""
"Кроме того, поскольку :c:type:`PyTypeObject` является лишь частью :ref:"
"`Limited API <limited-c-api>` как непрозрачная структура, любые модули "
"расширения, использующие статические типы, должны быть скомпилированы для "
"конкретной дополнительной версии Python. ."

#: ../../c-api/typeobj.rst:2230
msgid "Heap Types"
msgstr "Tipos de montón"

#: ../../c-api/typeobj.rst:2232
msgid ""
"An alternative to :ref:`static types <static-types>` is *heap-allocated "
"types*, or *heap types* for short, which correspond closely to classes "
"created by Python's ``class`` statement. Heap types have the :c:macro:"
"`Py_TPFLAGS_HEAPTYPE` flag set."
msgstr ""
"Альтернативой статическим типам <static-types>` являются *типы, выделяемые в "
"куче*, или для краткости *типы в куче*, которые близко соответствуют "
"классам, созданным оператором Python ``class``. Для типов кучи установлен "
"флаг :c:macro:`Py_TPFLAGS_HEAPTYPE`."

#: ../../c-api/typeobj.rst:2237
msgid ""
"This is done by filling a :c:type:`PyType_Spec` structure and calling :c:"
"func:`PyType_FromSpec`, :c:func:`PyType_FromSpecWithBases`, :c:func:"
"`PyType_FromModuleAndSpec`, or :c:func:`PyType_FromMetaclass`."
msgstr ""
"Это делается путем заполнения структуры :c:type:`PyType_Spec` и вызова :c:"
"func:`PyType_FromSpec`, :c:func:`PyType_FromSpecWithBases`, :c:func:"
"`PyType_FromModuleAndSpec` или :c:func: `PyType_FromMetaclass`."

#: ../../c-api/typeobj.rst:2245
msgid "Number Object Structures"
msgstr "Estructuras de objetos numéricos"

#: ../../c-api/typeobj.rst:2252
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the number protocol.  Each function is used by the function of "
"similar name documented in the :ref:`number` section."
msgstr ""
"Esta estructura contiene punteros a las funciones que un objeto utiliza para "
"implementar el protocolo numérico.  Cada función es utilizada por la función "
"de nombre similar documentada en la sección :ref:`number`."

#: ../../c-api/typeobj.rst:2258 ../../c-api/typeobj.rst:2582
msgid "Here is the structure definition::"
msgstr "Aquí está la definición de la estructura::"

#: ../../c-api/typeobj.rst:2260
msgid ""
"typedef struct {\n"
"     binaryfunc nb_add;\n"
"     binaryfunc nb_subtract;\n"
"     binaryfunc nb_multiply;\n"
"     binaryfunc nb_remainder;\n"
"     binaryfunc nb_divmod;\n"
"     ternaryfunc nb_power;\n"
"     unaryfunc nb_negative;\n"
"     unaryfunc nb_positive;\n"
"     unaryfunc nb_absolute;\n"
"     inquiry nb_bool;\n"
"     unaryfunc nb_invert;\n"
"     binaryfunc nb_lshift;\n"
"     binaryfunc nb_rshift;\n"
"     binaryfunc nb_and;\n"
"     binaryfunc nb_xor;\n"
"     binaryfunc nb_or;\n"
"     unaryfunc nb_int;\n"
"     void *nb_reserved;\n"
"     unaryfunc nb_float;\n"
"\n"
"     binaryfunc nb_inplace_add;\n"
"     binaryfunc nb_inplace_subtract;\n"
"     binaryfunc nb_inplace_multiply;\n"
"     binaryfunc nb_inplace_remainder;\n"
"     ternaryfunc nb_inplace_power;\n"
"     binaryfunc nb_inplace_lshift;\n"
"     binaryfunc nb_inplace_rshift;\n"
"     binaryfunc nb_inplace_and;\n"
"     binaryfunc nb_inplace_xor;\n"
"     binaryfunc nb_inplace_or;\n"
"\n"
"     binaryfunc nb_floor_divide;\n"
"     binaryfunc nb_true_divide;\n"
"     binaryfunc nb_inplace_floor_divide;\n"
"     binaryfunc nb_inplace_true_divide;\n"
"\n"
"     unaryfunc nb_index;\n"
"\n"
"     binaryfunc nb_matrix_multiply;\n"
"     binaryfunc nb_inplace_matrix_multiply;\n"
"} PyNumberMethods;"
msgstr ""
"typedef struct {\n"
"     binaryfunc nb_add;\n"
"     binaryfunc nb_subtract;\n"
"     binaryfunc nb_multiply;\n"
"     binaryfunc nb_remainder;\n"
"     binaryfunc nb_divmod;\n"
"     ternaryfunc nb_power;\n"
"     unaryfunc nb_negative;\n"
"     unaryfunc nb_positive;\n"
"     unaryfunc nb_absolute;\n"
"     inquiry nb_bool;\n"
"     unaryfunc nb_invert;\n"
"     binaryfunc nb_lshift;\n"
"     binaryfunc nb_rshift;\n"
"     binaryfunc nb_and;\n"
"     binaryfunc nb_xor;\n"
"     binaryfunc nb_or;\n"
"     unaryfunc nb_int;\n"
"     void *nb_reserved;\n"
"     unaryfunc nb_float;\n"
"\n"
"     binaryfunc nb_inplace_add;\n"
"     binaryfunc nb_inplace_subtract;\n"
"     binaryfunc nb_inplace_multiply;\n"
"     binaryfunc nb_inplace_remainder;\n"
"     ternaryfunc nb_inplace_power;\n"
"     binaryfunc nb_inplace_lshift;\n"
"     binaryfunc nb_inplace_rshift;\n"
"     binaryfunc nb_inplace_and;\n"
"     binaryfunc nb_inplace_xor;\n"
"     binaryfunc nb_inplace_or;\n"
"\n"
"     binaryfunc nb_floor_divide;\n"
"     binaryfunc nb_true_divide;\n"
"     binaryfunc nb_inplace_floor_divide;\n"
"     binaryfunc nb_inplace_true_divide;\n"
"\n"
"     unaryfunc nb_index;\n"
"\n"
"     binaryfunc nb_matrix_multiply;\n"
"     binaryfunc nb_inplace_matrix_multiply;\n"
"} PyNumberMethods;"

#: ../../c-api/typeobj.rst:2305
msgid ""
"Binary and ternary functions must check the type of all their operands, and "
"implement the necessary conversions (at least one of the operands is an "
"instance of the defined type).  If the operation is not defined for the "
"given operands, binary and ternary functions must return "
"``Py_NotImplemented``, if another error occurred they must return ``NULL`` "
"and set an exception."
msgstr ""
"Las funciones binarias y ternarias deben comprobar el tipo de todos sus "
"operandos e implementar las conversiones necesarias (al menos uno de los "
"operandos es una instancia del tipo definido).  Si la operación no está "
"definida para los operandos dados, las funciones binarias y ternarias deben "
"devolver ``Py_NotImplemented``, si se ha producido otro error deben devolver "
"``NULL`` y establecer una excepción."

#: ../../c-api/typeobj.rst:2314
msgid ""
"The :c:member:`~PyNumberMethods.nb_reserved` field should always be "
"``NULL``.  It was previously called :c:member:`!nb_long`, and was renamed in "
"Python 3.0.1."
msgstr ""
"Поле :c:member:`~PyNumberMethods.nb_reserved` всегда должно быть ``NULL``. "
"Ранее он назывался :c:member:`!nb_long` и был переименован в Python 3.0.1."

#: ../../c-api/typeobj.rst:2359
msgid "Mapping Object Structures"
msgstr "Mapeo de Estructuras de Objetos"

#: ../../c-api/typeobj.rst:2366
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the mapping protocol.  It has three members:"
msgstr ""
"Esta estructura contiene punteros a las funciones que un objeto utiliza para "
"implementar el protocolo de mapeo. Tiene tres miembros:"

#: ../../c-api/typeobj.rst:2371
msgid ""
"This function is used by :c:func:`PyMapping_Size` and :c:func:"
"`PyObject_Size`, and has the same signature.  This slot may be set to "
"``NULL`` if the object has no defined length."
msgstr ""
"Esta función es utilizada por :c:func:`PyMapping_Size` y :c:func:"
"`PyObject_Size`, y tiene la misma firma.  Esta ranura puede establecerse en "
"``NULL`` si el objeto no tiene una longitud definida."

#: ../../c-api/typeobj.rst:2377
msgid ""
"This function is used by :c:func:`PyObject_GetItem` and :c:func:"
"`PySequence_GetSlice`, and has the same signature as :c:func:`!"
"PyObject_GetItem`.  This slot must be filled for the :c:func:"
"`PyMapping_Check` function to return ``1``, it can be ``NULL`` otherwise."
msgstr ""
"Esta función es utilizada por :c:func:`PyObject_GetItem` y :c:func:"
"`PySequence_GetSlice`, y tiene la misma firma que :c:func:`!"
"PyObject_GetItem`.  Esta ranura debe estar llena para que la función :c:func:"
"`PyMapping_Check` devuelva ``1``, puede ser ``NULL`` en caso contrario."

#: ../../c-api/typeobj.rst:2385
msgid ""
"This function is used by :c:func:`PyObject_SetItem`, :c:func:"
"`PyObject_DelItem`, :c:func:`PySequence_SetSlice` and :c:func:"
"`PySequence_DelSlice`.  It has the same signature as :c:func:`!"
"PyObject_SetItem`, but *v* can also be set to ``NULL`` to delete an item.  "
"If this slot is ``NULL``, the object does not support item assignment and "
"deletion."
msgstr ""
"Эта функция используется :c:func:`PyObject_SetItem`, :c:func:"
"`PyObject_DelItem`, :c:func:`PySequence_SetSlice` и :c:func:"
"`PySequence_DelSlice`. Он имеет ту же подпись, что и :c:func:`!"
"PyObject_SetItem`, но для *v* также можно установить значение ``NULL`` для "
"удаления элемента. Если этот слот равен NULL, объект не поддерживает "
"назначение и удаление элементов."

#: ../../c-api/typeobj.rst:2396
msgid "Sequence Object Structures"
msgstr "Estructuras de objetos de secuencia"

#: ../../c-api/typeobj.rst:2403
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the sequence protocol."
msgstr ""
"Esta estructura contiene punteros a las funciones que un objeto utiliza para "
"implementar el protocolo de secuencia."

#: ../../c-api/typeobj.rst:2408
msgid ""
"This function is used by :c:func:`PySequence_Size` and :c:func:"
"`PyObject_Size`, and has the same signature.  It is also used for handling "
"negative indices via the :c:member:`~PySequenceMethods.sq_item` and the :c:"
"member:`~PySequenceMethods.sq_ass_item` slots."
msgstr ""
"Esta función es utilizada por :c:func:`PySequence_Size` y :c:func:"
"`PyObject_Size`, y tiene la misma firma.  También se utiliza para manejar "
"índices negativos a través de las ranuras :c:member:`~PySequenceMethods."
"sq_item` y :c:member:`~PySequenceMethods.sq_ass_item`."

#: ../../c-api/typeobj.rst:2415
msgid ""
"This function is used by :c:func:`PySequence_Concat` and has the same "
"signature.  It is also used by the ``+`` operator, after trying the numeric "
"addition via the :c:member:`~PyNumberMethods.nb_add` slot."
msgstr ""
"Esta función es utilizada por :c:func:`PySequence_Concat` y tiene la misma "
"firma.  También es utilizada por el operador ``+``, después de intentar la "
"suma numérica a través de la ranura :c:member:`~PyNumberMethods.nb_add`."

#: ../../c-api/typeobj.rst:2421
msgid ""
"This function is used by :c:func:`PySequence_Repeat` and has the same "
"signature.  It is also used by the ``*`` operator, after trying numeric "
"multiplication via the :c:member:`~PyNumberMethods.nb_multiply` slot."
msgstr ""
"Esta función es utilizada por :c:func:`PySequence_Repeat` y tiene la misma "
"firma.  También es utilizada por el operador ``*``, después de intentar la "
"multiplicación numérica a través de la ranura :c:member:`~PyNumberMethods."
"nb_multiply`."

#: ../../c-api/typeobj.rst:2427
msgid ""
"This function is used by :c:func:`PySequence_GetItem` and has the same "
"signature.  It is also used by :c:func:`PyObject_GetItem`, after trying the "
"subscription via the :c:member:`~PyMappingMethods.mp_subscript` slot. This "
"slot must be filled for the :c:func:`PySequence_Check` function to return "
"``1``, it can be ``NULL`` otherwise."
msgstr ""
"Esta función es utilizada por :c:func:`PySequence_GetItem` y tiene la misma "
"firma.  También es utilizada por :c:func:`PyObject_GetItem`, después de "
"intentar la suscripción a través de la ranura :c:member:`~PyMappingMethods."
"mp_subscript`. Esta ranura debe estar llena para que la función :c:func:"
"`PySequence_Check` devuelva ``1``, puede ser ``NULL`` en caso contrario."

#: ../../c-api/typeobj.rst:2433
msgid ""
"Negative indexes are handled as follows: if the :c:member:"
"`~PySequenceMethods.sq_length` slot is filled, it is called and the sequence "
"length is used to compute a positive index which is passed to  :c:member:"
"`~PySequenceMethods.sq_item`.  If :c:member:`!sq_length` is ``NULL``, the "
"index is passed as is to the function."
msgstr ""
"Отрицательные индексы обрабатываются следующим образом: если слот :c:member:"
"`~PySequenceMethods.sq_length` заполнен, он вызывается, и длина "
"последовательности используется для вычисления положительного индекса, "
"который передается в :c:member:`~PySequenceMethods .sq_item`. Если :c:member:"
"`!sq_length` имеет значение ``NULL``, индекс передается в функцию как есть."

#: ../../c-api/typeobj.rst:2440
msgid ""
"This function is used by :c:func:`PySequence_SetItem` and has the same "
"signature.  It is also used by :c:func:`PyObject_SetItem` and :c:func:"
"`PyObject_DelItem`, after trying the item assignment and deletion via the :c:"
"member:`~PyMappingMethods.mp_ass_subscript` slot. This slot may be left to "
"``NULL`` if the object does not support item assignment and deletion."
msgstr ""
"Esta función la utiliza :c:func:`PySequence_SetItem` y tiene la misma firma. "
"También la usa :c:func:`PyObject_SetItem` y :c:func:`PyObject_DelItem`, "
"después de intentar la asignación y eliminación de elementos a través del "
"espacio de nombres :c:member:`~PyMappingMethods.mp_ass_subscript`. Este "
"espacio de nombres puede quedar como ``NULL`` si el objeto no admite la "
"asignación y eliminación de elementos."

#: ../../c-api/typeobj.rst:2449
msgid ""
"This function may be used by :c:func:`PySequence_Contains` and has the same "
"signature.  This slot may be left to ``NULL``, in this case :c:func:`!"
"PySequence_Contains` simply traverses the sequence until it finds a match."
msgstr ""
"Esta función la puede utilizar :c:func:`PySequence_Contains` y tiene la "
"misma firma.  Esta ranura se puede dejar ``NULL``, en este caso :c:func:`!"
"PySequence_Contains` simplemente recorre la secuencia hasta que encuentra "
"una coincidencia."

#: ../../c-api/typeobj.rst:2456
msgid ""
"This function is used by :c:func:`PySequence_InPlaceConcat` and has the same "
"signature.  It should modify its first operand, and return it.  This slot "
"may be left to ``NULL``, in this case :c:func:`!PySequence_InPlaceConcat` "
"will fall back to :c:func:`PySequence_Concat`.  It is also used by the "
"augmented assignment ``+=``, after trying numeric in-place addition via the :"
"c:member:`~PyNumberMethods.nb_inplace_add` slot."
msgstr ""
"Esta función la utiliza :c:func:`PySequence_InPlaceConcat` y tiene la misma "
"firma.  Debe modificar su primer operando y devolverlo.  Esta ranura puede "
"dejarse ``NULL``, en este caso :c:func:`!PySequence_InPlaceConcat` "
"retrocederá a :c:func:`PySequence_Concat`. También la utiliza la asignación "
"aumentada ``+=``, después de intentar la suma numérica en el lugar a través "
"de la ranura :c:member:`~PyNumberMethods.nb_inplace_add`."

#: ../../c-api/typeobj.rst:2465
msgid ""
"This function is used by :c:func:`PySequence_InPlaceRepeat` and has the same "
"signature.  It should modify its first operand, and return it.  This slot "
"may be left to ``NULL``, in this case :c:func:`!PySequence_InPlaceRepeat` "
"will fall back to :c:func:`PySequence_Repeat`.  It is also used by the "
"augmented assignment ``*=``, after trying numeric in-place multiplication "
"via the :c:member:`~PyNumberMethods.nb_inplace_multiply` slot."
msgstr ""
"Esta función la utiliza :c:func:`PySequence_InPlaceRepeat` y tiene la misma "
"firma.  Debe modificar su primer operando y devolverlo.  Esta ranura se "
"puede dejar ``NULL``, en este caso :c:func:`!PySequence_InPlaceRepeat` "
"retrocederá a :c:func:`PySequence_Repeat`. También la utiliza la asignación "
"aumentada ``*=``, después de intentar la multiplicación numérica en el lugar "
"a través de la ranura :c:member:`~PyNumberMethods.nb_inplace_multiply`."

#: ../../c-api/typeobj.rst:2476
msgid "Buffer Object Structures"
msgstr "Estructuras de objetos de memoria intermedia"

#: ../../c-api/typeobj.rst:2484
msgid ""
"This structure holds pointers to the functions required by the :ref:`Buffer "
"protocol <bufferobjects>`. The protocol defines how an exporter object can "
"expose its internal data to consumer objects."
msgstr ""
"Esta estructura contiene punteros a las funciones requeridas por el :ref:"
"`Buffer protocol <bufferobjects>`. El protocolo define cómo un objeto "
"exportador puede exponer sus datos internos a los objetos consumidores."

#: ../../c-api/typeobj.rst:2490 ../../c-api/typeobj.rst:2539
#: ../../c-api/typeobj.rst:2593 ../../c-api/typeobj.rst:2604
#: ../../c-api/typeobj.rst:2616 ../../c-api/typeobj.rst:2626
msgid "The signature of this function is::"
msgstr "La firma de esta función es::"

#: ../../c-api/typeobj.rst:2492
msgid "int (PyObject *exporter, Py_buffer *view, int flags);"
msgstr "int (PyObject *exporter, Py_buffer *view, int flags);"

#: ../../c-api/typeobj.rst:2494
msgid ""
"Handle a request to *exporter* to fill in *view* as specified by *flags*. "
"Except for point (3), an implementation of this function MUST take these "
"steps:"
msgstr ""
"Maneja una petición a *exporter* para rellenar *view* según lo especificado "
"por *flags*. Excepto el punto (3), una implementación de esta función DEBE "
"seguir estos pasos:"

#: ../../c-api/typeobj.rst:2498
msgid ""
"Check if the request can be met. If not, raise :exc:`BufferError`, set :c:"
"expr:`view->obj` to ``NULL`` and return ``-1``."
msgstr ""
"Проверьте, может ли запрос быть удовлетворен. Если нет, поднимите :exc:"
"`BufferError`, установите :c:expr:`view->obj` в ``NULL`` и верните ``-1``."

#: ../../c-api/typeobj.rst:2501
msgid "Fill in the requested fields."
msgstr "Rellene los campos solicitados."

#: ../../c-api/typeobj.rst:2503
msgid "Increment an internal counter for the number of exports."
msgstr "Incrementar un contador interno para el número de exportaciones."

#: ../../c-api/typeobj.rst:2505
msgid ""
"Set :c:expr:`view->obj` to *exporter* and increment :c:expr:`view->obj`."
msgstr ""
"Установите для :c:expr:`view->obj` значение *exporter* и увеличьте :c:expr:"
"`view->obj`."

#: ../../c-api/typeobj.rst:2507
msgid "Return ``0``."
msgstr "Devolver ``0``."

#: ../../c-api/typeobj.rst:2509
msgid ""
"If *exporter* is part of a chain or tree of buffer providers, two main "
"schemes can be used:"
msgstr ""
"Si *exporter* forma parte de una cadena o árbol de proveedores de búfer, se "
"pueden utilizar dos esquemas principales."

#: ../../c-api/typeobj.rst:2512
msgid ""
"Re-export: Each member of the tree acts as the exporting object and sets :c:"
"expr:`view->obj` to a new reference to itself."
msgstr ""
"Реэкспорт: каждый член дерева действует как экспортируемый объект и "
"устанавливает :c:expr:`view->obj` в новую ссылку на самого себя."

#: ../../c-api/typeobj.rst:2515
msgid ""
"Redirect: The buffer request is redirected to the root object of the tree. "
"Here, :c:expr:`view->obj` will be a new reference to the root object."
msgstr ""
"Перенаправление: запрос буфера перенаправляется на корневой объект дерева. "
"Здесь :c:expr:`view->obj` будет новой ссылкой на корневой объект."

#: ../../c-api/typeobj.rst:2519
msgid ""
"The individual fields of *view* are described in section :ref:`Buffer "
"structure <buffer-structure>`, the rules how an exporter must react to "
"specific requests are in section :ref:`Buffer request types <buffer-request-"
"types>`."
msgstr ""
"Los campos individuales de *view* se describen en la sección :ref:`Buffer "
"structure <buffer-structure>`, las reglas sobre cómo debe reaccionar un "
"exportador a solicitudes específicas se encuentran en la sección :ref:"
"`Buffer request types <buffer-request-types>`."

#: ../../c-api/typeobj.rst:2524
msgid ""
"All memory pointed to in the :c:type:`Py_buffer` structure belongs to the "
"exporter and must remain valid until there are no consumers left. :c:member:"
"`~Py_buffer.format`, :c:member:`~Py_buffer.shape`, :c:member:`~Py_buffer."
"strides`, :c:member:`~Py_buffer.suboffsets` and :c:member:`~Py_buffer."
"internal` are read-only for the consumer."
msgstr ""
"Toda la memoria apuntada en la estructura :c:type:`Py_buffer` pertenece al "
"exportador y debe permanecer válida hasta que no queden consumidores. :c:"
"member:`~Py_buffer.format`, :c:member:`~Py_buffer.shape`, :c:member:"
"`~Py_buffer.strides`, :c:member:`~Py_buffer.suboffsets` y :c:member:"
"`~Py_buffer.internal` son de sólo lectura para el consumidor."

#: ../../c-api/typeobj.rst:2531
msgid ""
":c:func:`PyBuffer_FillInfo` provides an easy way of exposing a simple bytes "
"buffer while dealing correctly with all request types."
msgstr ""
":c:func:`PyBuffer_FillInfo` proporciona una forma sencilla de exponer un "
"simple búfer de bytes a la vez que trata correctamente todos los tipos de "
"peticiones."

#: ../../c-api/typeobj.rst:2534
msgid ""
":c:func:`PyObject_GetBuffer` is the interface for the consumer that wraps "
"this function."
msgstr ""
":c:func:`PyObject_GetBuffer` es la interfaz para el consumidor que envuelve "
"esta función."

#: ../../c-api/typeobj.rst:2541
msgid "void (PyObject *exporter, Py_buffer *view);"
msgstr "void (PyObject *exporter, Py_buffer *view);"

#: ../../c-api/typeobj.rst:2543
msgid ""
"Handle a request to release the resources of the buffer. If no resources "
"need to be released, :c:member:`PyBufferProcs.bf_releasebuffer` may be "
"``NULL``. Otherwise, a standard implementation of this function will take "
"these optional steps:"
msgstr ""
"Manejar una solicitud para liberar los recursos del búfer. Si no es "
"necesario liberar recursos, :c:member:`PyBufferProcs.bf_releasebuffer` puede "
"ser ``NULL``. De lo contrario, una implementación estándar de esta función "
"tomará los siguientes pasos opcionales:"

#: ../../c-api/typeobj.rst:2548
msgid "Decrement an internal counter for the number of exports."
msgstr "Decrementar un contador interno para el número de exportaciones."

#: ../../c-api/typeobj.rst:2550
msgid "If the counter is ``0``, free all memory associated with *view*."
msgstr "Si el contador es ``0``, liberar toda la memoria asociada con *view*."

#: ../../c-api/typeobj.rst:2552
msgid ""
"The exporter MUST use the :c:member:`~Py_buffer.internal` field to keep "
"track of buffer-specific resources. This field is guaranteed to remain "
"constant, while a consumer MAY pass a copy of the original buffer as the "
"*view* argument."
msgstr ""
"El exportador DEBE utilizar el campo :c:member:`~Py_buffer.internal` para "
"realizar un seguimiento de los recursos específicos del búfer. Se garantiza "
"que este campo permanece constante, mientras que un consumidor PUEDE pasar "
"una copia del búfer original como argumento *view*."

#: ../../c-api/typeobj.rst:2558
msgid ""
"This function MUST NOT decrement :c:expr:`view->obj`, since that is done "
"automatically in :c:func:`PyBuffer_Release` (this scheme is useful for "
"breaking reference cycles)."
msgstr ""
"Эта функция НЕ ДОЛЖНА уменьшать :c:expr:`view->obj`, поскольку это делается "
"автоматически в :c:func:`PyBuffer_Release` (эта схема полезна для разрыва "
"ссылочных циклов)."

#: ../../c-api/typeobj.rst:2563
msgid ""
":c:func:`PyBuffer_Release` is the interface for the consumer that wraps this "
"function."
msgstr ""
":c:func:`PyBuffer_Release` es la interfaz para el consumidor que envuelve "
"esta función."

#: ../../c-api/typeobj.rst:2571
msgid "Async Object Structures"
msgstr "Estructuras de objetos asíncronos"

#: ../../c-api/typeobj.rst:2579
msgid ""
"This structure holds pointers to the functions required to implement :term:"
"`awaitable` and :term:`asynchronous iterator` objects."
msgstr ""
"Esta estructura contiene punteros a las funciones necesarias para "
"implementar objetos :term:`awaitable` y :term:`asynchronous iterator`."

#: ../../c-api/typeobj.rst:2584
msgid ""
"typedef struct {\n"
"    unaryfunc am_await;\n"
"    unaryfunc am_aiter;\n"
"    unaryfunc am_anext;\n"
"    sendfunc am_send;\n"
"} PyAsyncMethods;"
msgstr ""
"typedef struct {\n"
"    unaryfunc am_await;\n"
"    unaryfunc am_aiter;\n"
"    unaryfunc am_anext;\n"
"    sendfunc am_send;\n"
"} PyAsyncMethods;"

#: ../../c-api/typeobj.rst:2595
msgid "PyObject *am_await(PyObject *self);"
msgstr "PyObject *am_await(PyObject *self);"

#: ../../c-api/typeobj.rst:2597
msgid ""
"The returned object must be an :term:`iterator`, i.e. :c:func:`PyIter_Check` "
"must return ``1`` for it."
msgstr ""
"Повернений об’єкт має бути :term:`iterator`, тобто :c:func:`PyIter_Check` "
"має повернути для нього ``1``."

#: ../../c-api/typeobj.rst:2600
msgid ""
"This slot may be set to ``NULL`` if an object is not an :term:`awaitable`."
msgstr ""
"Esta ranura puede establecerse en ``NULL`` si un objeto no es un :term:"
"`awaitable`."

#: ../../c-api/typeobj.rst:2606
msgid "PyObject *am_aiter(PyObject *self);"
msgstr "PyObject *am_aiter(PyObject *self);"

#: ../../c-api/typeobj.rst:2608
msgid ""
"Must return an :term:`asynchronous iterator` object. See :meth:`~object."
"__anext__` for details."
msgstr ""
"Должен возвращать объект асинхронного итератора. Подробности смотрите в :"
"meth:`~object.__anext__`."

#: ../../c-api/typeobj.rst:2611
msgid ""
"This slot may be set to ``NULL`` if an object does not implement "
"asynchronous iteration protocol."
msgstr ""
"Esta ranura puede establecerse en ``NULL`` si un objeto no implementa el "
"protocolo de iteración asíncrona."

#: ../../c-api/typeobj.rst:2618
msgid "PyObject *am_anext(PyObject *self);"
msgstr "PyObject *am_anext(PyObject *self);"

#: ../../c-api/typeobj.rst:2620
msgid ""
"Must return an :term:`awaitable` object. See :meth:`~object.__anext__` for "
"details. This slot may be set to ``NULL``."
msgstr ""
"Должен возвращать объект :term:`awaitable`. Подробности смотрите в :meth:"
"`~object.__anext__`. Этот слот может быть установлен в значение NULL."

#: ../../c-api/typeobj.rst:2628
msgid "PySendResult am_send(PyObject *self, PyObject *arg, PyObject **result);"
msgstr ""
"PySendResult am_send(PyObject *self, PyObject *arg, PyObject **result);"

#: ../../c-api/typeobj.rst:2630
msgid ""
"See :c:func:`PyIter_Send` for details. This slot may be set to ``NULL``."
msgstr ""
"Дивіться :c:func:`PyIter_Send` для деталей. Цей слот може мати значення "
"``NULL``."

#: ../../c-api/typeobj.rst:2639
msgid "Slot Type typedefs"
msgstr "Tipos de ranura"

#: ../../c-api/typeobj.rst:2643
msgid ""
"The purpose of this function is to separate memory allocation from memory "
"initialization.  It should return a pointer to a block of memory of adequate "
"length for the instance, suitably aligned, and initialized to zeros, but "
"with :c:member:`~PyObject.ob_refcnt` set to ``1`` and :c:member:`~PyObject."
"ob_type` set to the type argument.  If the type's :c:member:`~PyTypeObject."
"tp_itemsize` is non-zero, the object's :c:member:`~PyVarObject.ob_size` "
"field should be initialized to *nitems* and the length of the allocated "
"memory block should be ``tp_basicsize + nitems*tp_itemsize``, rounded up to "
"a multiple of ``sizeof(void*)``; otherwise, *nitems* is not used and the "
"length of the block should be :c:member:`~PyTypeObject.tp_basicsize`."
msgstr ""
"Цель этой функции — отделить выделение памяти от инициализации памяти. Он "
"должен возвращать указатель на блок памяти адекватной длины для экземпляра, "
"соответствующим образом выровненный и инициализированный нулями, но с :c:"
"member:`~PyObject.ob_refcnt` установленным в ``1`` и :c:member :`~PyObject."
"ob_type` установлен в аргумент типа. Если :c:member:`~PyTypeObject."
"tp_itemsize` типа не равно нулю, поле :c:member:`~PyVarObject.ob_size` "
"объекта должно быть инициализировано значением *nitems*, а длина выделенного "
"блока памяти должна быть равна ``tp_basicsize + nitems*tp_itemsize``, "
"округляется до кратного ``sizeof(void*)``; в противном случае *nitems* не "
"используется, а длина блока должна быть :c:member:`~PyTypeObject."
"tp_basicsize`."

#: ../../c-api/typeobj.rst:2653
msgid ""
"This function should not do any other instance initialization, not even to "
"allocate additional memory; that should be done by :c:member:`~PyTypeObject."
"tp_new`."
msgstr ""
"Esta función no debe realizar ninguna otra inicialización de instancia, ni "
"siquiera para asignar memoria adicional; eso debe hacerlo :c:member:"
"`~PyTypeObject.tp_new`."

#: ../../c-api/typeobj.rst:2660
msgid "See :c:member:`~PyTypeObject.tp_free`."
msgstr "Ver :c:member:`~PyTypeObject.tp_free`."

#: ../../c-api/typeobj.rst:2664
msgid "See :c:member:`~PyTypeObject.tp_new`."
msgstr "Ver :c:member:`~PyTypeObject.tp_new`."

#: ../../c-api/typeobj.rst:2668
msgid "See :c:member:`~PyTypeObject.tp_init`."
msgstr "Ver :c:member:`~PyTypeObject.tp_init`."

#: ../../c-api/typeobj.rst:2672
msgid "See :c:member:`~PyTypeObject.tp_repr`."
msgstr "Ver :c:member:`~PyTypeObject.tp_repr`."

#: ../../c-api/typeobj.rst:2676 ../../c-api/typeobj.rst:2685
msgid "Return the value of the named attribute for the object."
msgstr "Devuelve el valor del atributo nombrado para el objeto."

#: ../../c-api/typeobj.rst:2680 ../../c-api/typeobj.rst:2691
msgid ""
"Set the value of the named attribute for the object. The value argument is "
"set to ``NULL`` to delete the attribute."
msgstr ""
"Establecer el valor del atributo nombrado para el objeto. El argumento de "
"valor se establece en ``NULL`` para eliminar el atributo."

#: ../../c-api/typeobj.rst:2687
msgid "See :c:member:`~PyTypeObject.tp_getattro`."
msgstr "Ver :c:member:`~PyTypeObject.tp_getattro`."

#: ../../c-api/typeobj.rst:2694
msgid "See :c:member:`~PyTypeObject.tp_setattro`."
msgstr "Ver :c:member:`~PyTypeObject.tp_setattro`."

#: ../../c-api/typeobj.rst:2698
msgid "See :c:member:`~PyTypeObject.tp_descr_get`."
msgstr "См. :c:member:`~PyTypeObject.tp_descr_get`."

#: ../../c-api/typeobj.rst:2702
msgid "See :c:member:`~PyTypeObject.tp_descr_set`."
msgstr "См. :c:member:`~PyTypeObject.tp_descr_set`."

#: ../../c-api/typeobj.rst:2706
msgid "See :c:member:`~PyTypeObject.tp_hash`."
msgstr "Ver :c:member:`~PyTypeObject.tp_hash`."

#: ../../c-api/typeobj.rst:2710
msgid "See :c:member:`~PyTypeObject.tp_richcompare`."
msgstr "Ver :c:member:`~PyTypeObject.tp_richcompare`."

#: ../../c-api/typeobj.rst:2714
msgid "See :c:member:`~PyTypeObject.tp_iter`."
msgstr "Ver :c:member:`~PyTypeObject.tp_iter`."

#: ../../c-api/typeobj.rst:2718
msgid "See :c:member:`~PyTypeObject.tp_iternext`."
msgstr "Ver :c:member:`~PyTypeObject.tp_iternext`."

#: ../../c-api/typeobj.rst:2732
msgid "See :c:member:`~PyAsyncMethods.am_send`."
msgstr "Перегляньте :c:member:`~PyAsyncMethods.am_send`."

#: ../../c-api/typeobj.rst:2748
msgid "Examples"
msgstr "Ejemplos"

#: ../../c-api/typeobj.rst:2750
msgid ""
"The following are simple examples of Python type definitions.  They include "
"common usage you may encounter.  Some demonstrate tricky corner cases.  For "
"more examples, practical info, and a tutorial, see :ref:`defining-new-types` "
"and :ref:`new-types-topics`."
msgstr ""
"Los siguientes son ejemplos simples de definiciones de tipos en Python. "
"Incluyen usos comunes que puedes encontrar. Algunos demuestran casos "
"complicados. Para más ejemplos, información práctica y un tutorial, "
"consulta :ref:`defining-new-types` y :ref:`new-types-topics`."

#: ../../c-api/typeobj.rst:2755
msgid "A basic :ref:`static type <static-types>`::"
msgstr "Базовий :ref:`статичний тип <static-types>`::"

#: ../../c-api/typeobj.rst:2757
msgid ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"    const char *data;\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"    .tp_basicsize = sizeof(MyObject),\n"
"    .tp_doc = PyDoc_STR(\"My objects\"),\n"
"    .tp_new = myobj_new,\n"
"    .tp_dealloc = (destructor)myobj_dealloc,\n"
"    .tp_repr = (reprfunc)myobj_repr,\n"
"};"
msgstr ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"    const char *data;\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"    .tp_basicsize = sizeof(MyObject),\n"
"    .tp_doc = PyDoc_STR(\"My objects\"),\n"
"    .tp_new = myobj_new,\n"
"    .tp_dealloc = (destructor)myobj_dealloc,\n"
"    .tp_repr = (reprfunc)myobj_repr,\n"
"};"

#: ../../c-api/typeobj.rst:2772
msgid ""
"You may also find older code (especially in the CPython code base) with a "
"more verbose initializer::"
msgstr ""
"También puede encontrar código antiguo (especialmente en la base de código "
"CPython) con un inicializador más verboso::"

#: ../../c-api/typeobj.rst:2775
msgid ""
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    \"mymod.MyObject\",               /* tp_name */\n"
"    sizeof(MyObject),               /* tp_basicsize */\n"
"    0,                              /* tp_itemsize */\n"
"    (destructor)myobj_dealloc,      /* tp_dealloc */\n"
"    0,                              /* tp_vectorcall_offset */\n"
"    0,                              /* tp_getattr */\n"
"    0,                              /* tp_setattr */\n"
"    0,                              /* tp_as_async */\n"
"    (reprfunc)myobj_repr,           /* tp_repr */\n"
"    0,                              /* tp_as_number */\n"
"    0,                              /* tp_as_sequence */\n"
"    0,                              /* tp_as_mapping */\n"
"    0,                              /* tp_hash */\n"
"    0,                              /* tp_call */\n"
"    0,                              /* tp_str */\n"
"    0,                              /* tp_getattro */\n"
"    0,                              /* tp_setattro */\n"
"    0,                              /* tp_as_buffer */\n"
"    0,                              /* tp_flags */\n"
"    PyDoc_STR(\"My objects\"),        /* tp_doc */\n"
"    0,                              /* tp_traverse */\n"
"    0,                              /* tp_clear */\n"
"    0,                              /* tp_richcompare */\n"
"    0,                              /* tp_weaklistoffset */\n"
"    0,                              /* tp_iter */\n"
"    0,                              /* tp_iternext */\n"
"    0,                              /* tp_methods */\n"
"    0,                              /* tp_members */\n"
"    0,                              /* tp_getset */\n"
"    0,                              /* tp_base */\n"
"    0,                              /* tp_dict */\n"
"    0,                              /* tp_descr_get */\n"
"    0,                              /* tp_descr_set */\n"
"    0,                              /* tp_dictoffset */\n"
"    0,                              /* tp_init */\n"
"    0,                              /* tp_alloc */\n"
"    myobj_new,                      /* tp_new */\n"
"};"
msgstr ""
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    \"mymod.MyObject\",               /* tp_name */\n"
"    sizeof(MyObject),               /* tp_basicsize */\n"
"    0,                              /* tp_itemsize */\n"
"    (destructor)myobj_dealloc,      /* tp_dealloc */\n"
"    0,                              /* tp_vectorcall_offset */\n"
"    0,                              /* tp_getattr */\n"
"    0,                              /* tp_setattr */\n"
"    0,                              /* tp_as_async */\n"
"    (reprfunc)myobj_repr,           /* tp_repr */\n"
"    0,                              /* tp_as_number */\n"
"    0,                              /* tp_as_sequence */\n"
"    0,                              /* tp_as_mapping */\n"
"    0,                              /* tp_hash */\n"
"    0,                              /* tp_call */\n"
"    0,                              /* tp_str */\n"
"    0,                              /* tp_getattro */\n"
"    0,                              /* tp_setattro */\n"
"    0,                              /* tp_as_buffer */\n"
"    0,                              /* tp_flags */\n"
"    PyDoc_STR(\"My objects\"),        /* tp_doc */\n"
"    0,                              /* tp_traverse */\n"
"    0,                              /* tp_clear */\n"
"    0,                              /* tp_richcompare */\n"
"    0,                              /* tp_weaklistoffset */\n"
"    0,                              /* tp_iter */\n"
"    0,                              /* tp_iternext */\n"
"    0,                              /* tp_methods */\n"
"    0,                              /* tp_members */\n"
"    0,                              /* tp_getset */\n"
"    0,                              /* tp_base */\n"
"    0,                              /* tp_dict */\n"
"    0,                              /* tp_descr_get */\n"
"    0,                              /* tp_descr_set */\n"
"    0,                              /* tp_dictoffset */\n"
"    0,                              /* tp_init */\n"
"    0,                              /* tp_alloc */\n"
"    myobj_new,                      /* tp_new */\n"
"};"

#: ../../c-api/typeobj.rst:2816
msgid "A type that supports weakrefs, instance dicts, and hashing::"
msgstr "Un tipo que admite weakrefs, instance dicts y hashing::"

#: ../../c-api/typeobj.rst:2818
msgid ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"    const char *data;\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"    .tp_basicsize = sizeof(MyObject),\n"
"    .tp_doc = PyDoc_STR(\"My objects\"),\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |\n"
"         Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_MANAGED_DICT |\n"
"         Py_TPFLAGS_MANAGED_WEAKREF,\n"
"    .tp_new = myobj_new,\n"
"    .tp_traverse = (traverseproc)myobj_traverse,\n"
"    .tp_clear = (inquiry)myobj_clear,\n"
"    .tp_alloc = PyType_GenericNew,\n"
"    .tp_dealloc = (destructor)myobj_dealloc,\n"
"    .tp_repr = (reprfunc)myobj_repr,\n"
"    .tp_hash = (hashfunc)myobj_hash,\n"
"    .tp_richcompare = PyBaseObject_Type.tp_richcompare,\n"
"};"
msgstr ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"    const char *data;\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"    .tp_basicsize = sizeof(MyObject),\n"
"    .tp_doc = PyDoc_STR(\"My objects\"),\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |\n"
"         Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_MANAGED_DICT |\n"
"         Py_TPFLAGS_MANAGED_WEAKREF,\n"
"    .tp_new = myobj_new,\n"
"    .tp_traverse = (traverseproc)myobj_traverse,\n"
"    .tp_clear = (inquiry)myobj_clear,\n"
"    .tp_alloc = PyType_GenericNew,\n"
"    .tp_dealloc = (destructor)myobj_dealloc,\n"
"    .tp_repr = (reprfunc)myobj_repr,\n"
"    .tp_hash = (hashfunc)myobj_hash,\n"
"    .tp_richcompare = PyBaseObject_Type.tp_richcompare,\n"
"};"

#: ../../c-api/typeobj.rst:2841
msgid ""
"A str subclass that cannot be subclassed and cannot be called to create "
"instances (e.g. uses a separate factory func) using :c:macro:"
"`Py_TPFLAGS_DISALLOW_INSTANTIATION` flag::"
msgstr ""
"Подкласс str, который не может быть подклассом и не может быть вызван для "
"создания экземпляров (например, использует отдельную фабричную функцию) с "
"использованием флага :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION`::"

#: ../../c-api/typeobj.rst:2845
msgid ""
"typedef struct {\n"
"    PyUnicodeObject raw;\n"
"    char *extra;\n"
"} MyStr;\n"
"\n"
"static PyTypeObject MyStr_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyStr\",\n"
"    .tp_basicsize = sizeof(MyStr),\n"
"    .tp_base = NULL,  // set to &PyUnicode_Type in module init\n"
"    .tp_doc = PyDoc_STR(\"my custom str\"),\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_DISALLOW_INSTANTIATION,\n"
"    .tp_repr = (reprfunc)myobj_repr,\n"
"};"
msgstr ""
"typedef struct {\n"
"    PyUnicodeObject raw;\n"
"    char *extra;\n"
"} MyStr;\n"
"\n"
"static PyTypeObject MyStr_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyStr\",\n"
"    .tp_basicsize = sizeof(MyStr),\n"
"    .tp_base = NULL,  // set to &PyUnicode_Type in module init\n"
"    .tp_doc = PyDoc_STR(\"my custom str\"),\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_DISALLOW_INSTANTIATION,\n"
"    .tp_repr = (reprfunc)myobj_repr,\n"
"};"

#: ../../c-api/typeobj.rst:2860
msgid ""
"The simplest :ref:`static type <static-types>` with fixed-length instances::"
msgstr ""
"Найпростіший :ref:`статичний тип <static-types>` з екземплярами фіксованої "
"довжини::"

#: ../../c-api/typeobj.rst:2862
msgid ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"};"
msgstr ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"};"

#: ../../c-api/typeobj.rst:2871
msgid ""
"The simplest :ref:`static type <static-types>` with variable-length "
"instances::"
msgstr ""
"Найпростіший :ref:`статичний тип <static-types>` з екземплярами змінної "
"довжини::"

#: ../../c-api/typeobj.rst:2873
msgid ""
"typedef struct {\n"
"    PyObject_VAR_HEAD\n"
"    const char *data[1];\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"    .tp_basicsize = sizeof(MyObject) - sizeof(char *),\n"
"    .tp_itemsize = sizeof(char *),\n"
"};"
msgstr ""
"typedef struct {\n"
"    PyObject_VAR_HEAD\n"
"    const char *data[1];\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"    .tp_basicsize = sizeof(MyObject) - sizeof(char *),\n"
"    .tp_itemsize = sizeof(char *),\n"
"};"

#: ../../c-api/typeobj.rst:843 ../../c-api/typeobj.rst:908
msgid "built-in function"
msgstr "funkcja wbudowana"

#: ../../c-api/typeobj.rst:843
msgid "repr"
msgstr "repr"

#: ../../c-api/typeobj.rst:908
msgid "hash"
msgstr "hash"
