# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# eulalio barbero espinosa <eulalio@disroot.org>, 2024
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-21 22:53+0000\n"
"PO-Revision-Date: 2022-11-05 17:21+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Spanish (Spain) (https://app.transifex.com/python-doc/"
"teams/5390/es_ES/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es_ES\n"
"Plural-Forms: nplurals=3; plural=n == 1 ? 0 : n != 0 && n % 1000000 == 0 ? "
"1 : 2;\n"

#: ../../c-api/typeobj.rst:6
msgid "Type Objects"
msgstr "Objetos tipo "

#: ../../c-api/typeobj.rst:8
msgid ""
"Perhaps one of the most important structures of the Python object system is "
"the structure that defines a new type: the :c:type:`PyTypeObject` "
"structure.  Type objects can be handled using any of the ``PyObject_*`` or "
"``PyType_*`` functions, but do not offer much that's interesting to most "
"Python applications. These objects are fundamental to how objects behave, so "
"they are very important to the interpreter itself and to any extension "
"module that implements new types."
msgstr ""
"Quizás una de las estructuras más importantes del sistema de objetos de "
"Python es la estructura que define un nuevo tipo: la estructura :c:type:"
"`PyTypeObject`.  Los objetos de tipo pueden manejarse usando cualquiera de "
"las funciones ``PyObject_*`` o ``PyType_*``, pero no ofrecen mucho que sea "
"interesante para la mayoría de las aplicaciones Python. Estos objetos son "
"fundamentales para el comportamiento de los objetos, por lo que son muy "
"importantes para el propio intérprete y para cualquier módulo de extensión "
"que implemente nuevos tipos."

#: ../../c-api/typeobj.rst:16
msgid ""
"Type objects are fairly large compared to most of the standard types. The "
"reason for the size is that each type object stores a large number of "
"values, mostly C function pointers, each of which implements a small part of "
"the type's functionality.  The fields of the type object are examined in "
"detail in this section.  The fields will be described in the order in which "
"they occur in the structure."
msgstr ""
"Los objetos de tipo son bastante grandes en comparación con la mayoría de "
"los tipos estándar. La razón del tamaño es que cada objeto de tipo almacena "
"una gran cantidad de valores, en su mayoría punteros a funciones C, cada uno "
"de los cuales implementa una pequeña parte de la funcionalidad del tipo. Los "
"campos del objeto de tipo se examinan en detalle en esta sección. Los campos "
"se describirán en el orden en que aparecen en la estructura."

#: ../../c-api/typeobj.rst:23
msgid ""
"In addition to the following quick reference, the :ref:`typedef-examples` "
"section provides at-a-glance insight into the meaning and use of :c:type:"
"`PyTypeObject`."
msgstr ""
"Además de la siguiente referencia rápida, la sección :ref:`typedef-examples` "
"proporciona una visión rápida sobre el significado y uso de :c:type:"
"`PyTypeObject`."

#: ../../c-api/typeobj.rst:29
msgid "Quick Reference"
msgstr "Referencia rápida"

#: ../../c-api/typeobj.rst:34
msgid "\"tp slots\""
msgstr "\"tp slots\""

#: ../../c-api/typeobj.rst:40
msgid "PyTypeObject Slot [#slots]_"
msgstr "PyTypeObject Ranura [#slots]_"

#: ../../c-api/typeobj.rst:40 ../../c-api/typeobj.rst:199
msgid ":ref:`Type <slot-typedefs-table>`"
msgstr ":ref:`Type <slot-typedefs-table>`"

#: ../../c-api/typeobj.rst:40
msgid "special methods/attrs"
msgstr "métodos/attrs especiales"

#: ../../c-api/typeobj.rst:40
msgid "Info [#cols]_"
msgstr "Info [#cols]_"

#: ../../c-api/typeobj.rst:42
msgid "O"
msgstr "O"

#: ../../c-api/typeobj.rst:42
msgid "T"
msgstr "T"

#: ../../c-api/typeobj.rst:42
msgid "D"
msgstr "D"

#: ../../c-api/typeobj.rst:42
msgid "I"
msgstr "I"

#: ../../c-api/typeobj.rst:44
msgid "<R> :c:member:`~PyTypeObject.tp_name`"
msgstr "<R> :c:member:`~PyTypeObject.tp_name`"

#: ../../c-api/typeobj.rst:44 ../../c-api/typeobj.rst:86
#: ../../c-api/typeobj.rst:0
msgid "const char *"
msgstr "const char *"

#: ../../c-api/typeobj.rst:44
msgid "__name__"
msgstr "__name__"

#: ../../c-api/typeobj.rst:44 ../../c-api/typeobj.rst:46
#: ../../c-api/typeobj.rst:48 ../../c-api/typeobj.rst:50
#: ../../c-api/typeobj.rst:52 ../../c-api/typeobj.rst:62
#: ../../c-api/typeobj.rst:70 ../../c-api/typeobj.rst:72
#: ../../c-api/typeobj.rst:74 ../../c-api/typeobj.rst:76
#: ../../c-api/typeobj.rst:79 ../../c-api/typeobj.rst:84
#: ../../c-api/typeobj.rst:86 ../../c-api/typeobj.rst:88
#: ../../c-api/typeobj.rst:90 ../../c-api/typeobj.rst:92
#: ../../c-api/typeobj.rst:99 ../../c-api/typeobj.rst:101
#: ../../c-api/typeobj.rst:103 ../../c-api/typeobj.rst:105
#: ../../c-api/typeobj.rst:107 ../../c-api/typeobj.rst:109
#: ../../c-api/typeobj.rst:111 ../../c-api/typeobj.rst:115
#: ../../c-api/typeobj.rst:117 ../../c-api/typeobj.rst:120
#: ../../c-api/typeobj.rst:122 ../../c-api/typeobj.rst:124
#: ../../c-api/typeobj.rst:126 ../../c-api/typeobj.rst:128
#: ../../c-api/typeobj.rst:130 ../../c-api/typeobj.rst:146
msgid "X"
msgstr "X"

#: ../../c-api/typeobj.rst:46
msgid ":c:member:`~PyTypeObject.tp_basicsize`"
msgstr ":c:member:`~PyTypeObject.tp_basicsize`"

#: ../../c-api/typeobj.rst:46 ../../c-api/typeobj.rst:48
#: ../../c-api/typeobj.rst:52 ../../c-api/typeobj.rst:99
#: ../../c-api/typeobj.rst:120 ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:414
msgid ":c:type:`Py_ssize_t`"
msgstr ":c:type:`Py_ssize_t`"

#: ../../c-api/typeobj.rst:48
msgid ":c:member:`~PyTypeObject.tp_itemsize`"
msgstr ":c:member:`~PyTypeObject.tp_itemsize`"

#: ../../c-api/typeobj.rst:50
msgid ":c:member:`~PyTypeObject.tp_dealloc`"
msgstr ":c:member:`~PyTypeObject.tp_dealloc`"

#: ../../c-api/typeobj.rst:50 ../../c-api/typeobj.rst:142
#: ../../c-api/typeobj.rst:146 ../../c-api/typeobj.rst:344
msgid ":c:type:`destructor`"
msgstr ":c:type:`destructor`"

#: ../../c-api/typeobj.rst:52
msgid ":c:member:`~PyTypeObject.tp_vectorcall_offset`"
msgstr ":c:member:`~PyTypeObject.tp_vectorcall_offset`"

#: ../../c-api/typeobj.rst:54
msgid "(:c:member:`~PyTypeObject.tp_getattr`)"
msgstr "(:c:member:`~PyTypeObject.tp_getattr`)"

#: ../../c-api/typeobj.rst:54 ../../c-api/typeobj.rst:368
msgid ":c:type:`getattrfunc`"
msgstr ":c:type:`getattrfunc`"

#: ../../c-api/typeobj.rst:54 ../../c-api/typeobj.rst:76
msgid "__getattribute__, __getattr__"
msgstr "__getattribute__, __getattr__"

#: ../../c-api/typeobj.rst:54 ../../c-api/typeobj.rst:57
#: ../../c-api/typeobj.rst:70 ../../c-api/typeobj.rst:76
#: ../../c-api/typeobj.rst:79 ../../c-api/typeobj.rst:88
#: ../../c-api/typeobj.rst:90 ../../c-api/typeobj.rst:92
msgid "G"
msgstr "G"

#: ../../c-api/typeobj.rst:57
msgid "(:c:member:`~PyTypeObject.tp_setattr`)"
msgstr "(:c:member:`~PyTypeObject.tp_setattr`)"

#: ../../c-api/typeobj.rst:57 ../../c-api/typeobj.rst:373
msgid ":c:type:`setattrfunc`"
msgstr ":c:type:`setattrfunc`"

#: ../../c-api/typeobj.rst:57 ../../c-api/typeobj.rst:79
msgid "__setattr__, __delattr__"
msgstr "__setattr__, __delattr__"

#: ../../c-api/typeobj.rst:60
msgid ":c:member:`~PyTypeObject.tp_as_async`"
msgstr ":c:member:`~PyTypeObject.tp_as_async`"

#: ../../c-api/typeobj.rst:60
msgid ":c:type:`PyAsyncMethods` *"
msgstr ":c:type:`PyAsyncMethods` *"

#: ../../c-api/typeobj.rst:60 ../../c-api/typeobj.rst:64
#: ../../c-api/typeobj.rst:66 ../../c-api/typeobj.rst:68
msgid ":ref:`sub-slots`"
msgstr ":ref:`sub-slots`"

#: ../../c-api/typeobj.rst:60 ../../c-api/typeobj.rst:64
#: ../../c-api/typeobj.rst:66 ../../c-api/typeobj.rst:68
#: ../../c-api/typeobj.rst:82
msgid "%"
msgstr "%"

#: ../../c-api/typeobj.rst:62
msgid ":c:member:`~PyTypeObject.tp_repr`"
msgstr ":c:member:`~PyTypeObject.tp_repr`"

#: ../../c-api/typeobj.rst:62 ../../c-api/typeobj.rst:74
#: ../../c-api/typeobj.rst:366
msgid ":c:type:`reprfunc`"
msgstr ":c:type:`reprfunc`"

#: ../../c-api/typeobj.rst:62
msgid "__repr__"
msgstr "__repr__"

#: ../../c-api/typeobj.rst:64
msgid ":c:member:`~PyTypeObject.tp_as_number`"
msgstr ":c:member:`~PyTypeObject.tp_as_number`"

#: ../../c-api/typeobj.rst:64
msgid ":c:type:`PyNumberMethods` *"
msgstr ":c:type:`PyNumberMethods` *"

#: ../../c-api/typeobj.rst:66
msgid ":c:member:`~PyTypeObject.tp_as_sequence`"
msgstr ":c:member:`~PyTypeObject.tp_as_sequence`"

#: ../../c-api/typeobj.rst:66
msgid ":c:type:`PySequenceMethods` *"
msgstr ":c:type:`PySequenceMethods` *"

#: ../../c-api/typeobj.rst:68
msgid ":c:member:`~PyTypeObject.tp_as_mapping`"
msgstr ":c:member:`~PyTypeObject.tp_as_mapping`"

#: ../../c-api/typeobj.rst:68
msgid ":c:type:`PyMappingMethods` *"
msgstr ":c:type:`PyMappingMethods` *"

#: ../../c-api/typeobj.rst:70
msgid ":c:member:`~PyTypeObject.tp_hash`"
msgstr ":c:member:`~PyTypeObject.tp_hash`"

#: ../../c-api/typeobj.rst:70 ../../c-api/typeobj.rst:402
msgid ":c:type:`hashfunc`"
msgstr ":c:type:`hashfunc`"

#: ../../c-api/typeobj.rst:70
msgid "__hash__"
msgstr "__hash__"

#: ../../c-api/typeobj.rst:72
msgid ":c:member:`~PyTypeObject.tp_call`"
msgstr ":c:member:`~PyTypeObject.tp_call`"

#: ../../c-api/typeobj.rst:72 ../../c-api/typeobj.rst:235
#: ../../c-api/typeobj.rst:238 ../../c-api/typeobj.rst:438
msgid ":c:type:`ternaryfunc`"
msgstr ":c:type:`ternaryfunc`"

#: ../../c-api/typeobj.rst:72
msgid "__call__"
msgstr "__call__"

#: ../../c-api/typeobj.rst:74
msgid ":c:member:`~PyTypeObject.tp_str`"
msgstr ":c:member:`~PyTypeObject.tp_str`"

#: ../../c-api/typeobj.rst:74
msgid "__str__"
msgstr "__str__"

#: ../../c-api/typeobj.rst:76
msgid ":c:member:`~PyTypeObject.tp_getattro`"
msgstr ":c:member:`~PyTypeObject.tp_getattro`"

#: ../../c-api/typeobj.rst:76 ../../c-api/typeobj.rst:379
msgid ":c:type:`getattrofunc`"
msgstr ":c:type:`getattrofunc`"

#: ../../c-api/typeobj.rst:79
msgid ":c:member:`~PyTypeObject.tp_setattro`"
msgstr ":c:member:`~PyTypeObject.tp_setattro`"

#: ../../c-api/typeobj.rst:79 ../../c-api/typeobj.rst:384
msgid ":c:type:`setattrofunc`"
msgstr ":c:type:`setattrofunc`"

#: ../../c-api/typeobj.rst:82
msgid ":c:member:`~PyTypeObject.tp_as_buffer`"
msgstr ":c:member:`~PyTypeObject.tp_as_buffer`"

#: ../../c-api/typeobj.rst:82
msgid ":c:type:`PyBufferProcs` *"
msgstr ":c:type:`PyBufferProcs` *"

#: ../../c-api/typeobj.rst:84
msgid ":c:member:`~PyTypeObject.tp_flags`"
msgstr ":c:member:`~PyTypeObject.tp_flags`"

#: ../../c-api/typeobj.rst:84
msgid "unsigned long"
msgstr "int sin firmar"

#: ../../c-api/typeobj.rst:84 ../../c-api/typeobj.rst:99
#: ../../c-api/typeobj.rst:113 ../../c-api/typeobj.rst:120
#: ../../c-api/typeobj.rst:124 ../../c-api/typeobj.rst:126
#: ../../c-api/typeobj.rst:128
msgid "?"
msgstr "?"

#: ../../c-api/typeobj.rst:86
msgid ":c:member:`~PyTypeObject.tp_doc`"
msgstr ":c:member:`~PyTypeObject.tp_doc`"

#: ../../c-api/typeobj.rst:86
msgid "__doc__"
msgstr "__doc__"

#: ../../c-api/typeobj.rst:88
msgid ":c:member:`~PyTypeObject.tp_traverse`"
msgstr ":c:member:`~PyTypeObject.tp_traverse`"

#: ../../c-api/typeobj.rst:88 ../../c-api/typeobj.rst:348
msgid ":c:type:`traverseproc`"
msgstr ":c:type:`traverseproc`"

#: ../../c-api/typeobj.rst:90
msgid ":c:member:`~PyTypeObject.tp_clear`"
msgstr ":c:member:`~PyTypeObject.tp_clear`"

#: ../../c-api/typeobj.rst:90 ../../c-api/typeobj.rst:130
#: ../../c-api/typeobj.rst:246 ../../c-api/typeobj.rst:427
msgid ":c:type:`inquiry`"
msgstr ":c:type:`inquiry`"

#: ../../c-api/typeobj.rst:92
msgid ":c:member:`~PyTypeObject.tp_richcompare`"
msgstr ":c:member:`~PyTypeObject.tp_richcompare`"

#: ../../c-api/typeobj.rst:92 ../../c-api/typeobj.rst:404
msgid ":c:type:`richcmpfunc`"
msgstr ":c:type:`richcmpfunc`"

#: ../../c-api/typeobj.rst:92
msgid "__lt__, __le__, __eq__, __ne__, __gt__, __ge__"
msgstr "__lt__, __le__, __eq__, __ne__, __gt__, __ge__"

#: ../../c-api/typeobj.rst:99
msgid ":c:member:`~PyTypeObject.tp_weaklistoffset`"
msgstr ":c:member:`~PyTypeObject.tp_weaklistoffset`"

#: ../../c-api/typeobj.rst:101
msgid ":c:member:`~PyTypeObject.tp_iter`"
msgstr ":c:member:`~PyTypeObject.tp_iter`"

#: ../../c-api/typeobj.rst:101 ../../c-api/typeobj.rst:410
msgid ":c:type:`getiterfunc`"
msgstr ":c:type:`getiterfunc`"

#: ../../c-api/typeobj.rst:101
msgid "__iter__"
msgstr "__iter__"

#: ../../c-api/typeobj.rst:103
msgid ":c:member:`~PyTypeObject.tp_iternext`"
msgstr ":c:member:`~PyTypeObject.tp_iternext`"

#: ../../c-api/typeobj.rst:103 ../../c-api/typeobj.rst:412
msgid ":c:type:`iternextfunc`"
msgstr ":c:type:`iternextfunc`"

#: ../../c-api/typeobj.rst:103
msgid "__next__"
msgstr "__next__"

#: ../../c-api/typeobj.rst:105
msgid ":c:member:`~PyTypeObject.tp_methods`"
msgstr ":c:member:`~PyTypeObject.tp_methods`"

#: ../../c-api/typeobj.rst:105
msgid ":c:type:`PyMethodDef` []"
msgstr ":c:type:`PyMethodDef` []"

#: ../../c-api/typeobj.rst:107
msgid ":c:member:`~PyTypeObject.tp_members`"
msgstr ":c:member:`~PyTypeObject.tp_members`"

#: ../../c-api/typeobj.rst:107
msgid ":c:type:`PyMemberDef` []"
msgstr ":c:type:`PyMemberDef` []"

#: ../../c-api/typeobj.rst:109
msgid ":c:member:`~PyTypeObject.tp_getset`"
msgstr ":c:member:`~PyTypeObject.tp_getset`"

#: ../../c-api/typeobj.rst:109
msgid ":c:type:`PyGetSetDef` []"
msgstr ":c:type:`PyGetSetDef` []"

#: ../../c-api/typeobj.rst:111
msgid ":c:member:`~PyTypeObject.tp_base`"
msgstr ":c:member:`~PyTypeObject.tp_base`"

#: ../../c-api/typeobj.rst:111 ../../c-api/typeobj.rst:0
msgid ":c:type:`PyTypeObject` *"
msgstr ":c:type:`PyTypeObject` *"

#: ../../c-api/typeobj.rst:111
msgid "__base__"
msgstr "__base__"

#: ../../c-api/typeobj.rst:113
msgid ":c:member:`~PyTypeObject.tp_dict`"
msgstr ":c:member:`~PyTypeObject.tp_dict`"

#: ../../c-api/typeobj.rst:113 ../../c-api/typeobj.rst:132
#: ../../c-api/typeobj.rst:134 ../../c-api/typeobj.rst:136
#: ../../c-api/typeobj.rst:138 ../../c-api/typeobj.rst:140
#: ../../c-api/typeobj.rst:339 ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:354 ../../c-api/typeobj.rst:366
#: ../../c-api/typeobj.rst:368 ../../c-api/typeobj.rst:379
#: ../../c-api/typeobj.rst:390 ../../c-api/typeobj.rst:402
#: ../../c-api/typeobj.rst:404 ../../c-api/typeobj.rst:410
#: ../../c-api/typeobj.rst:412 ../../c-api/typeobj.rst:414
#: ../../c-api/typeobj.rst:429 ../../c-api/typeobj.rst:433
#: ../../c-api/typeobj.rst:438 ../../c-api/typeobj.rst:444
msgid ":c:type:`PyObject` *"
msgstr ":c:type:`PyObject` *"

#: ../../c-api/typeobj.rst:113
msgid "__dict__"
msgstr "__dict__"

#: ../../c-api/typeobj.rst:115
msgid ":c:member:`~PyTypeObject.tp_descr_get`"
msgstr ":c:member:`~PyTypeObject.tp_descr_get`"

#: ../../c-api/typeobj.rst:115 ../../c-api/typeobj.rst:390
msgid ":c:type:`descrgetfunc`"
msgstr ":c:type:`descrgetfunc`"

#: ../../c-api/typeobj.rst:115
msgid "__get__"
msgstr "__get__"

#: ../../c-api/typeobj.rst:117
msgid ":c:member:`~PyTypeObject.tp_descr_set`"
msgstr ":c:member:`~PyTypeObject.tp_descr_set`"

#: ../../c-api/typeobj.rst:117 ../../c-api/typeobj.rst:396
msgid ":c:type:`descrsetfunc`"
msgstr ":c:type:`descrsetfunc`"

#: ../../c-api/typeobj.rst:117
msgid "__set__, __delete__"
msgstr "__set__, __delete__"

#: ../../c-api/typeobj.rst:120
msgid ":c:member:`~PyTypeObject.tp_dictoffset`"
msgstr ":c:member:`~PyTypeObject.tp_dictoffset`"

#: ../../c-api/typeobj.rst:122
msgid ":c:member:`~PyTypeObject.tp_init`"
msgstr ":c:member:`~PyTypeObject.tp_init`"

#: ../../c-api/typeobj.rst:122 ../../c-api/typeobj.rst:360
msgid ":c:type:`initproc`"
msgstr ":c:type:`initproc`"

#: ../../c-api/typeobj.rst:122
msgid "__init__"
msgstr "__init__"

#: ../../c-api/typeobj.rst:124
msgid ":c:member:`~PyTypeObject.tp_alloc`"
msgstr ":c:member:`~PyTypeObject.tp_alloc`"

#: ../../c-api/typeobj.rst:124 ../../c-api/typeobj.rst:339
msgid ":c:type:`allocfunc`"
msgstr ":c:type:`allocfunc`"

#: ../../c-api/typeobj.rst:126
msgid ":c:member:`~PyTypeObject.tp_new`"
msgstr ":c:member:`~PyTypeObject.tp_new`"

#: ../../c-api/typeobj.rst:126 ../../c-api/typeobj.rst:354
msgid ":c:type:`newfunc`"
msgstr ":c:type:`newfunc`"

#: ../../c-api/typeobj.rst:126
msgid "__new__"
msgstr "__new__"

#: ../../c-api/typeobj.rst:128
msgid ":c:member:`~PyTypeObject.tp_free`"
msgstr ":c:member:`~PyTypeObject.tp_free`"

#: ../../c-api/typeobj.rst:128 ../../c-api/typeobj.rst:346
msgid ":c:type:`freefunc`"
msgstr ":c:type:`freefunc`"

#: ../../c-api/typeobj.rst:130
msgid ":c:member:`~PyTypeObject.tp_is_gc`"
msgstr ":c:member:`~PyTypeObject.tp_is_gc`"

#: ../../c-api/typeobj.rst:132
msgid "<:c:member:`~PyTypeObject.tp_bases`>"
msgstr "<:c:member:`~PyTypeObject.tp_bases`>"

#: ../../c-api/typeobj.rst:132
msgid "__bases__"
msgstr "__bases__"

#: ../../c-api/typeobj.rst:132 ../../c-api/typeobj.rst:134
msgid "~"
msgstr "~"

#: ../../c-api/typeobj.rst:134
msgid "<:c:member:`~PyTypeObject.tp_mro`>"
msgstr "<:c:member:`~PyTypeObject.tp_mro`>"

#: ../../c-api/typeobj.rst:134
msgid "__mro__"
msgstr "__mro__"

#: ../../c-api/typeobj.rst:136
msgid "[:c:member:`~PyTypeObject.tp_cache`]"
msgstr "[:c:member:`~PyTypeObject.tp_cache`]"

#: ../../c-api/typeobj.rst:138
msgid "[:c:member:`~PyTypeObject.tp_subclasses`]"
msgstr "[:c:member:`~PyTypeObject.tp_subclasses`]"

#: ../../c-api/typeobj.rst:138
msgid "__subclasses__"
msgstr "__subclasses__"

#: ../../c-api/typeobj.rst:140
msgid "[:c:member:`~PyTypeObject.tp_weaklist`]"
msgstr "[:c:member:`~PyTypeObject.tp_weaklist`]"

#: ../../c-api/typeobj.rst:142
msgid "(:c:member:`~PyTypeObject.tp_del`)"
msgstr "(:c:member:`~PyTypeObject.tp_del`)"

#: ../../c-api/typeobj.rst:144
msgid "[:c:member:`~PyTypeObject.tp_version_tag`]"
msgstr "[:c:member:`~PyTypeObject.tp_version_tag`]"

#: ../../c-api/typeobj.rst:144
msgid "unsigned int"
msgstr "int sin firmar"

#: ../../c-api/typeobj.rst:146
msgid ":c:member:`~PyTypeObject.tp_finalize`"
msgstr ":c:member:`~PyTypeObject.tp_finalize`"

#: ../../c-api/typeobj.rst:146
msgid "__del__"
msgstr "__del__"

#: ../../c-api/typeobj.rst:148
msgid ":c:member:`~PyTypeObject.tp_vectorcall`"
msgstr ":c:member:`~PyTypeObject.tp_vectorcall`"

#: ../../c-api/typeobj.rst:148
msgid ":c:type:`vectorcallfunc`"
msgstr ":c:type:`vectorcallfunc`"

#: ../../c-api/typeobj.rst:153
msgid ""
"**()**: A slot name in parentheses indicates it is (effectively) deprecated."
msgstr ""
"**()**: Un nombre de ranura entre paréntesis indica que está (efectivamente) "
"obsoleto."

#: ../../c-api/typeobj.rst:155
msgid ""
"**<>**: Names in angle brackets should be initially set to ``NULL`` and "
"treated as read-only."
msgstr ""
"**<>**: Los nombres entre paréntesis angulares deben establecerse "
"inicialmente en ``NULL`` y tratarse como de sólo lectura."

#: ../../c-api/typeobj.rst:158
msgid "**[]**: Names in square brackets are for internal use only."
msgstr "**[]**: Los nombres entre corchetes son de uso interno."

#: ../../c-api/typeobj.rst:160
msgid ""
"**<R>** (as a prefix) means the field is required (must be non-``NULL``)."
msgstr ""
"**<R>** (como prefijo) significa que el campo es obligatorio (debe ser "
"distinto de``NULL``)."

#: ../../c-api/typeobj.rst:162
msgid "Columns:"
msgstr "Columnas:"

#: ../../c-api/typeobj.rst:164
msgid "**\"O\"**:  set on :c:type:`PyBaseObject_Type`"
msgstr "**\"O \"**: encendido :c:type:`PyBaseObject_Type`"

#: ../../c-api/typeobj.rst:166
msgid "**\"T\"**:  set on :c:type:`PyType_Type`"
msgstr "**\"T \"**: encendido :c:type:`PyType_Type`"

#: ../../c-api/typeobj.rst:168
msgid "**\"D\"**:  default (if slot is set to ``NULL``)"
msgstr "**\"D \"**: por defecto (si la ranura está configurada en ``NULL``)"

#: ../../c-api/typeobj.rst:178
msgid "**\"I\"**:  inheritance"
msgstr "**\"I \"**: herencia"

#: ../../c-api/typeobj.rst:187
msgid ""
"Note that some slots are effectively inherited through the normal attribute "
"lookup chain."
msgstr ""
"Tener en cuenta que algunas ranuras se heredan a través de la cadena normal "
"de búsqueda de atributos."

#: ../../c-api/typeobj.rst:193
msgid "sub-slots"
msgstr "sub-slots"

#: ../../c-api/typeobj.rst:199
msgid "Slot"
msgstr "Slot"

#: ../../c-api/typeobj.rst:199
msgid "special methods"
msgstr "métodos especiales"

#: ../../c-api/typeobj.rst:202
msgid ":c:member:`~PyAsyncMethods.am_await`"
msgstr ":c:member:`~PyAsyncMethods.am_await`"

#: ../../c-api/typeobj.rst:202 ../../c-api/typeobj.rst:204
#: ../../c-api/typeobj.rst:206 ../../c-api/typeobj.rst:240
#: ../../c-api/typeobj.rst:242 ../../c-api/typeobj.rst:244
#: ../../c-api/typeobj.rst:248 ../../c-api/typeobj.rst:275
#: ../../c-api/typeobj.rst:279 ../../c-api/typeobj.rst:289
#: ../../c-api/typeobj.rst:429
msgid ":c:type:`unaryfunc`"
msgstr ":c:type:`unaryfunc`"

#: ../../c-api/typeobj.rst:202
msgid "__await__"
msgstr "__await__"

#: ../../c-api/typeobj.rst:204
msgid ":c:member:`~PyAsyncMethods.am_aiter`"
msgstr ":c:member:`~PyAsyncMethods.am_aiter`"

#: ../../c-api/typeobj.rst:204
msgid "__aiter__"
msgstr "__aiter__"

#: ../../c-api/typeobj.rst:206
msgid ":c:member:`~PyAsyncMethods.am_anext`"
msgstr ":c:member:`~PyAsyncMethods.am_anext`"

#: ../../c-api/typeobj.rst:206
msgid "__anext__"
msgstr "__anext__"

#: ../../c-api/typeobj.rst:208
msgid ":c:member:`~PyAsyncMethods.am_send`"
msgstr ":c:member:`~PyAsyncMethods.am_send`"

#: ../../c-api/typeobj.rst:208
msgid ":c:type:`sendfunc`"
msgstr ":c:type:`sendfunc`"

#: ../../c-api/typeobj.rst:212
msgid ":c:member:`~PyNumberMethods.nb_add`"
msgstr ":c:member:`~PyNumberMethods.nb_add`"

#: ../../c-api/typeobj.rst:212 ../../c-api/typeobj.rst:215
#: ../../c-api/typeobj.rst:217 ../../c-api/typeobj.rst:220
#: ../../c-api/typeobj.rst:222 ../../c-api/typeobj.rst:225
#: ../../c-api/typeobj.rst:227 ../../c-api/typeobj.rst:230
#: ../../c-api/typeobj.rst:232 ../../c-api/typeobj.rst:250
#: ../../c-api/typeobj.rst:253 ../../c-api/typeobj.rst:255
#: ../../c-api/typeobj.rst:258 ../../c-api/typeobj.rst:260
#: ../../c-api/typeobj.rst:263 ../../c-api/typeobj.rst:265
#: ../../c-api/typeobj.rst:268 ../../c-api/typeobj.rst:270
#: ../../c-api/typeobj.rst:273 ../../c-api/typeobj.rst:281
#: ../../c-api/typeobj.rst:283 ../../c-api/typeobj.rst:285
#: ../../c-api/typeobj.rst:287 ../../c-api/typeobj.rst:291
#: ../../c-api/typeobj.rst:294 ../../c-api/typeobj.rst:300
#: ../../c-api/typeobj.rst:309 ../../c-api/typeobj.rst:320
#: ../../c-api/typeobj.rst:433
msgid ":c:type:`binaryfunc`"
msgstr ":c:type:`binaryfunc`"

#: ../../c-api/typeobj.rst:212
msgid "__add__ __radd__"
msgstr "__add__ __radd__"

#: ../../c-api/typeobj.rst:215
msgid ":c:member:`~PyNumberMethods.nb_inplace_add`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_add`"

#: ../../c-api/typeobj.rst:215 ../../c-api/typeobj.rst:320
msgid "__iadd__"
msgstr "__iadd__"

#: ../../c-api/typeobj.rst:217
msgid ":c:member:`~PyNumberMethods.nb_subtract`"
msgstr ":c:member:`~PyNumberMethods.nb_subtract`"

#: ../../c-api/typeobj.rst:217
msgid "__sub__ __rsub__"
msgstr "__sub__ __rsub__"

#: ../../c-api/typeobj.rst:220
msgid ":c:member:`~PyNumberMethods.nb_inplace_subtract`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_subtract`"

#: ../../c-api/typeobj.rst:220
msgid "__isub__"
msgstr "__isub__"

#: ../../c-api/typeobj.rst:222
msgid ":c:member:`~PyNumberMethods.nb_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_multiply`"

#: ../../c-api/typeobj.rst:222
msgid "__mul__ __rmul__"
msgstr "__mul__ __rmul__"

#: ../../c-api/typeobj.rst:225
msgid ":c:member:`~PyNumberMethods.nb_inplace_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_multiply`"

#: ../../c-api/typeobj.rst:225 ../../c-api/typeobj.rst:322
msgid "__imul__"
msgstr "__imul__"

#: ../../c-api/typeobj.rst:227
msgid ":c:member:`~PyNumberMethods.nb_remainder`"
msgstr ":c:member:`~PyNumberMethods.nb_remainder`"

#: ../../c-api/typeobj.rst:227
msgid "__mod__ __rmod__"
msgstr "__mod__ __rmod__"

#: ../../c-api/typeobj.rst:230
msgid ":c:member:`~PyNumberMethods.nb_inplace_remainder`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_remainder`"

#: ../../c-api/typeobj.rst:230
msgid "__imod__"
msgstr "__imod__"

#: ../../c-api/typeobj.rst:232
msgid ":c:member:`~PyNumberMethods.nb_divmod`"
msgstr ":c:member:`~PyNumberMethods.nb_divmod`"

#: ../../c-api/typeobj.rst:232
msgid "__divmod__ __rdivmod__"
msgstr "__divmod__ __rdivmod__"

#: ../../c-api/typeobj.rst:235
msgid ":c:member:`~PyNumberMethods.nb_power`"
msgstr ":c:member:`~PyNumberMethods.nb_power`"

#: ../../c-api/typeobj.rst:235
msgid "__pow__ __rpow__"
msgstr "__pow__ __rpow__"

#: ../../c-api/typeobj.rst:238
msgid ":c:member:`~PyNumberMethods.nb_inplace_power`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_power`"

#: ../../c-api/typeobj.rst:238
msgid "__ipow__"
msgstr "__ipow__"

#: ../../c-api/typeobj.rst:240
msgid ":c:member:`~PyNumberMethods.nb_negative`"
msgstr ":c:member:`~PyNumberMethods.nb_negative`"

#: ../../c-api/typeobj.rst:240
msgid "__neg__"
msgstr "__neg__"

#: ../../c-api/typeobj.rst:242
msgid ":c:member:`~PyNumberMethods.nb_positive`"
msgstr ":c:member:`~PyNumberMethods.nb_positive`"

#: ../../c-api/typeobj.rst:242
msgid "__pos__"
msgstr "__pos__"

#: ../../c-api/typeobj.rst:244
msgid ":c:member:`~PyNumberMethods.nb_absolute`"
msgstr ":c:member:`~PyNumberMethods.nb_absolute`"

#: ../../c-api/typeobj.rst:244
msgid "__abs__"
msgstr "__abs__"

#: ../../c-api/typeobj.rst:246
msgid ":c:member:`~PyNumberMethods.nb_bool`"
msgstr ":c:member:`~PyNumberMethods.nb_bool`"

#: ../../c-api/typeobj.rst:246
msgid "__bool__"
msgstr "__bool__"

#: ../../c-api/typeobj.rst:248
msgid ":c:member:`~PyNumberMethods.nb_invert`"
msgstr ":c:member:`~PyNumberMethods.nb_invert`"

#: ../../c-api/typeobj.rst:248
msgid "__invert__"
msgstr "__invert__"

#: ../../c-api/typeobj.rst:250
msgid ":c:member:`~PyNumberMethods.nb_lshift`"
msgstr ":c:member:`~PyNumberMethods.nb_lshift`"

#: ../../c-api/typeobj.rst:250
msgid "__lshift__ __rlshift__"
msgstr "__lshift__ __rlshift__"

#: ../../c-api/typeobj.rst:253
msgid ":c:member:`~PyNumberMethods.nb_inplace_lshift`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_lshift`"

#: ../../c-api/typeobj.rst:253
msgid "__ilshift__"
msgstr "__ilshift__"

#: ../../c-api/typeobj.rst:255
msgid ":c:member:`~PyNumberMethods.nb_rshift`"
msgstr ":c:member:`~PyNumberMethods.nb_rshift`"

#: ../../c-api/typeobj.rst:255
msgid "__rshift__ __rrshift__"
msgstr "__rshift__ __rrshift__"

#: ../../c-api/typeobj.rst:258
msgid ":c:member:`~PyNumberMethods.nb_inplace_rshift`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_rshift`"

#: ../../c-api/typeobj.rst:258
msgid "__irshift__"
msgstr "__irshift__"

#: ../../c-api/typeobj.rst:260
msgid ":c:member:`~PyNumberMethods.nb_and`"
msgstr ":c:member:`~PyNumberMethods.nb_and`"

#: ../../c-api/typeobj.rst:260
msgid "__and__ __rand__"
msgstr "__and__ __rand__"

#: ../../c-api/typeobj.rst:263
msgid ":c:member:`~PyNumberMethods.nb_inplace_and`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_and`"

#: ../../c-api/typeobj.rst:263
msgid "__iand__"
msgstr "__iand__"

#: ../../c-api/typeobj.rst:265
msgid ":c:member:`~PyNumberMethods.nb_xor`"
msgstr ":c:member:`~PyNumberMethods.nb_xor`"

#: ../../c-api/typeobj.rst:265
msgid "__xor__ __rxor__"
msgstr "__xor__ __rxor__"

#: ../../c-api/typeobj.rst:268
msgid ":c:member:`~PyNumberMethods.nb_inplace_xor`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_xor`"

#: ../../c-api/typeobj.rst:268
msgid "__ixor__"
msgstr "__ixor__"

#: ../../c-api/typeobj.rst:270
msgid ":c:member:`~PyNumberMethods.nb_or`"
msgstr ":c:member:`~PyNumberMethods.nb_or`"

#: ../../c-api/typeobj.rst:270
msgid "__or__ __ror__"
msgstr "__or__ __ror__"

#: ../../c-api/typeobj.rst:273
msgid ":c:member:`~PyNumberMethods.nb_inplace_or`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_or`"

#: ../../c-api/typeobj.rst:273
msgid "__ior__"
msgstr "__ior__"

#: ../../c-api/typeobj.rst:275
msgid ":c:member:`~PyNumberMethods.nb_int`"
msgstr ":c:member:`~PyNumberMethods.nb_int`"

#: ../../c-api/typeobj.rst:275
msgid "__int__"
msgstr "__int__"

#: ../../c-api/typeobj.rst:277
msgid ":c:member:`~PyNumberMethods.nb_reserved`"
msgstr ":c:member:`~PyNumberMethods.nb_reserved`"

#: ../../c-api/typeobj.rst:277 ../../c-api/typeobj.rst:344
#: ../../c-api/typeobj.rst:346 ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:427
msgid "void *"
msgstr "void *"

#: ../../c-api/typeobj.rst:279
msgid ":c:member:`~PyNumberMethods.nb_float`"
msgstr ":c:member:`~PyNumberMethods.nb_float`"

#: ../../c-api/typeobj.rst:279
msgid "__float__"
msgstr "__float__"

#: ../../c-api/typeobj.rst:281
msgid ":c:member:`~PyNumberMethods.nb_floor_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_floor_divide`"

#: ../../c-api/typeobj.rst:281
msgid "__floordiv__"
msgstr "__floordiv__"

#: ../../c-api/typeobj.rst:283
msgid ":c:member:`~PyNumberMethods.nb_inplace_floor_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_floor_divide`"

#: ../../c-api/typeobj.rst:283
msgid "__ifloordiv__"
msgstr "__ifloordiv__"

#: ../../c-api/typeobj.rst:285
msgid ":c:member:`~PyNumberMethods.nb_true_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_true_divide`"

#: ../../c-api/typeobj.rst:285
msgid "__truediv__"
msgstr "__truediv__"

#: ../../c-api/typeobj.rst:287
msgid ":c:member:`~PyNumberMethods.nb_inplace_true_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_true_divide`"

#: ../../c-api/typeobj.rst:287
msgid "__itruediv__"
msgstr "__itruediv__"

#: ../../c-api/typeobj.rst:289
msgid ":c:member:`~PyNumberMethods.nb_index`"
msgstr ":c:member:`~PyNumberMethods.nb_index`"

#: ../../c-api/typeobj.rst:289
msgid "__index__"
msgstr "__index__"

#: ../../c-api/typeobj.rst:291
msgid ":c:member:`~PyNumberMethods.nb_matrix_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_matrix_multiply`"

#: ../../c-api/typeobj.rst:291
msgid "__matmul__ __rmatmul__"
msgstr "__matmul__ __rmatmul__"

#: ../../c-api/typeobj.rst:294
msgid ":c:member:`~PyNumberMethods.nb_inplace_matrix_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_matrix_multiply`"

#: ../../c-api/typeobj.rst:294
msgid "__imatmul__"
msgstr "__imatmul__"

#: ../../c-api/typeobj.rst:298
msgid ":c:member:`~PyMappingMethods.mp_length`"
msgstr ":c:member:`~PyMappingMethods.mp_length`"

#: ../../c-api/typeobj.rst:298 ../../c-api/typeobj.rst:307
#: ../../c-api/typeobj.rst:414
msgid ":c:type:`lenfunc`"
msgstr ":c:type:`lenfunc`"

#: ../../c-api/typeobj.rst:298 ../../c-api/typeobj.rst:307
msgid "__len__"
msgstr "__len__"

#: ../../c-api/typeobj.rst:300
msgid ":c:member:`~PyMappingMethods.mp_subscript`"
msgstr ":c:member:`~PyMappingMethods.mp_subscript`"

#: ../../c-api/typeobj.rst:300 ../../c-api/typeobj.rst:313
msgid "__getitem__"
msgstr "__getitem__"

#: ../../c-api/typeobj.rst:302
msgid ":c:member:`~PyMappingMethods.mp_ass_subscript`"
msgstr ":c:member:`~PyMappingMethods.mp_ass_subscript`"

#: ../../c-api/typeobj.rst:302 ../../c-api/typeobj.rst:460
msgid ":c:type:`objobjargproc`"
msgstr ":c:type:`objobjargproc`"

#: ../../c-api/typeobj.rst:302
msgid "__setitem__, __delitem__"
msgstr "__setitem__, __delitem__"

#: ../../c-api/typeobj.rst:307
msgid ":c:member:`~PySequenceMethods.sq_length`"
msgstr ":c:member:`~PySequenceMethods.sq_length`"

#: ../../c-api/typeobj.rst:309
msgid ":c:member:`~PySequenceMethods.sq_concat`"
msgstr ":c:member:`~PySequenceMethods.sq_concat`"

#: ../../c-api/typeobj.rst:309
msgid "__add__"
msgstr "__add__"

#: ../../c-api/typeobj.rst:311
msgid ":c:member:`~PySequenceMethods.sq_repeat`"
msgstr ":c:member:`~PySequenceMethods.sq_repeat`"

#: ../../c-api/typeobj.rst:311 ../../c-api/typeobj.rst:313
#: ../../c-api/typeobj.rst:322 ../../c-api/typeobj.rst:444
msgid ":c:type:`ssizeargfunc`"
msgstr ":c:type:`ssizeargfunc`"

#: ../../c-api/typeobj.rst:311
msgid "__mul__"
msgstr "__mul__"

#: ../../c-api/typeobj.rst:313
msgid ":c:member:`~PySequenceMethods.sq_item`"
msgstr ":c:member:`~PySequenceMethods.sq_item`"

#: ../../c-api/typeobj.rst:315
msgid ":c:member:`~PySequenceMethods.sq_ass_item`"
msgstr ":c:member:`~PySequenceMethods.sq_ass_item`"

#: ../../c-api/typeobj.rst:315 ../../c-api/typeobj.rst:449
msgid ":c:type:`ssizeobjargproc`"
msgstr ":c:type:`ssizeobjargproc`"

#: ../../c-api/typeobj.rst:315
msgid "__setitem__ __delitem__"
msgstr "__setitem__ __delitem__"

#: ../../c-api/typeobj.rst:318
msgid ":c:member:`~PySequenceMethods.sq_contains`"
msgstr ":c:member:`~PySequenceMethods.sq_contains`"

#: ../../c-api/typeobj.rst:318 ../../c-api/typeobj.rst:455
msgid ":c:type:`objobjproc`"
msgstr ":c:type:`objobjproc`"

#: ../../c-api/typeobj.rst:318
msgid "__contains__"
msgstr "__contains__"

#: ../../c-api/typeobj.rst:320
msgid ":c:member:`~PySequenceMethods.sq_inplace_concat`"
msgstr ":c:member:`~PySequenceMethods.sq_inplace_concat`"

#: ../../c-api/typeobj.rst:322
msgid ":c:member:`~PySequenceMethods.sq_inplace_repeat`"
msgstr ":c:member:`~PySequenceMethods.sq_inplace_repeat`"

#: ../../c-api/typeobj.rst:326
msgid ":c:member:`~PyBufferProcs.bf_getbuffer`"
msgstr ":c:member:`~PyBufferProcs.bf_getbuffer`"

#: ../../c-api/typeobj.rst:326
msgid ":c:func:`getbufferproc`"
msgstr ":c:func:`getbufferproc`"

#: ../../c-api/typeobj.rst:328
msgid ":c:member:`~PyBufferProcs.bf_releasebuffer`"
msgstr ":c:member:`~PyBufferProcs.bf_releasebuffer`"

#: ../../c-api/typeobj.rst:328
msgid ":c:func:`releasebufferproc`"
msgstr ":c:func:`releasebufferproc`"

#: ../../c-api/typeobj.rst:334
msgid "slot typedefs"
msgstr "tipos de ranura"

#: ../../c-api/typeobj.rst:337
msgid "typedef"
msgstr "typedef"

#: ../../c-api/typeobj.rst:337
msgid "Parameter Types"
msgstr "Tipos de parámetros"

#: ../../c-api/typeobj.rst:337
msgid "Return Type"
msgstr "Tipo de retorno"

#: ../../c-api/typeobj.rst:344 ../../c-api/typeobj.rst:346
#: ../../c-api/typeobj.rst:422
msgid "void"
msgstr "void"

#: ../../c-api/typeobj.rst:0
msgid ":c:type:`visitproc`"
msgstr ":c:type:`visitproc`"

#: ../../c-api/typeobj.rst:348 ../../c-api/typeobj.rst:360
#: ../../c-api/typeobj.rst:373 ../../c-api/typeobj.rst:384
#: ../../c-api/typeobj.rst:396 ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:416 ../../c-api/typeobj.rst:427
#: ../../c-api/typeobj.rst:449 ../../c-api/typeobj.rst:455
#: ../../c-api/typeobj.rst:460
msgid "int"
msgstr "int"

#: ../../c-api/typeobj.rst:402
msgid "Py_hash_t"
msgstr "Py_hash_t"

#: ../../c-api/typeobj.rst:416
msgid ":c:type:`getbufferproc`"
msgstr ":c:type:`getbufferproc`"

#: ../../c-api/typeobj.rst:0
msgid ":c:type:`Py_buffer` *"
msgstr ":c:type:`Py_buffer` *"

#: ../../c-api/typeobj.rst:422
msgid ":c:type:`releasebufferproc`"
msgstr ":c:type:`releasebufferproc`"

#: ../../c-api/typeobj.rst:467
msgid "See :ref:`slot-typedefs` below for more detail."
msgstr "Ver a continuación para más detalles :ref:`slot-typedefs`."

#: ../../c-api/typeobj.rst:471
msgid "PyTypeObject Definition"
msgstr "Definición de PyTypeObject"

#: ../../c-api/typeobj.rst:473
msgid ""
"The structure definition for :c:type:`PyTypeObject` can be found in :file:"
"`Include/object.h`.  For convenience of reference, this repeats the "
"definition found there:"
msgstr ""
"La definición de estructura para :c:type:`PyTypeObject` se puede encontrar "
"en :file:`Include/object.h`. Para mayor comodidad de referencia, esto repite "
"la definición encontrada allí."

#: ../../c-api/typeobj.rst:483
msgid "PyObject Slots"
msgstr "Ranuras PyObject"

#: ../../c-api/typeobj.rst:485
msgid ""
"The type object structure extends the :c:type:`PyVarObject` structure. The :"
"attr:`ob_size` field is used for dynamic types (created by :func:`type_new`, "
"usually called from a class statement). Note that :c:data:`PyType_Type` (the "
"metatype) initializes :c:member:`~PyTypeObject.tp_itemsize`, which means "
"that its instances (i.e. type objects) *must* have the :attr:`ob_size` field."
msgstr ""
"La estructura del objeto tipo extiende la estructura :c:type:`PyVarObject`. "
"El campo :attr:`ob_size` se utiliza para tipos dinámicos (creados por :func:"
"`type_new`, generalmente llamados desde una declaración de clase). Tener en "
"cuenta que :c:data:`PyType_Type` (el metatipo) inicializa :c:member:"
"`~PyTypeObject.tp_itemsize`, lo que significa que sus instancias (es decir, "
"objetos tipo) *deben* tener el campo :attr:`ob_size`."

#: ../../c-api/typeobj.rst:494
msgid ""
"This is the type object's reference count, initialized to ``1`` by the "
"``PyObject_HEAD_INIT`` macro.  Note that for :ref:`statically allocated type "
"objects <static-types>`, the type's instances (objects whose :attr:`ob_type` "
"points back to the type) do *not* count as references.  But for :ref:"
"`dynamically allocated type objects <heap-types>`, the instances *do* count "
"as references."
msgstr ""
"Este es el recuento de referencias del objeto de tipo, inicializado a ``1`` "
"por la macro ``PyObject_HEAD_INIT``.  Observar que para :ref:`objetos de "
"tipo asignados estáticamente <static-types>`, las instancias del tipo "
"(objetos cuyo :attr:`ob_type` apunta al tipo) *no* cuentan como "
"referencias.  Pero para :ref:`objetos de tipo asignados dinámicamente <heap-"
"types>`, las instancias *cuentan* como referencias."

#: ../../c-api/typeobj.rst:501 ../../c-api/typeobj.rst:524
#: ../../c-api/typeobj.rst:546 ../../c-api/typeobj.rst:560
#: ../../c-api/typeobj.rst:604 ../../c-api/typeobj.rst:647
#: ../../c-api/typeobj.rst:706 ../../c-api/typeobj.rst:744
#: ../../c-api/typeobj.rst:763 ../../c-api/typeobj.rst:780
#: ../../c-api/typeobj.rst:798 ../../c-api/typeobj.rst:822
#: ../../c-api/typeobj.rst:839 ../../c-api/typeobj.rst:851
#: ../../c-api/typeobj.rst:863 ../../c-api/typeobj.rst:896
#: ../../c-api/typeobj.rst:914 ../../c-api/typeobj.rst:934
#: ../../c-api/typeobj.rst:955 ../../c-api/typeobj.rst:981
#: ../../c-api/typeobj.rst:1000 ../../c-api/typeobj.rst:1016
#: ../../c-api/typeobj.rst:1053 ../../c-api/typeobj.rst:1064
#: ../../c-api/typeobj.rst:1074 ../../c-api/typeobj.rst:1084
#: ../../c-api/typeobj.rst:1098 ../../c-api/typeobj.rst:1116
#: ../../c-api/typeobj.rst:1139 ../../c-api/typeobj.rst:1186
#: ../../c-api/typeobj.rst:1201 ../../c-api/typeobj.rst:1220
#: ../../c-api/typeobj.rst:1250 ../../c-api/typeobj.rst:1272
#: ../../c-api/typeobj.rst:1288 ../../c-api/typeobj.rst:1356
#: ../../c-api/typeobj.rst:1424 ../../c-api/typeobj.rst:1483
#: ../../c-api/typeobj.rst:1513 ../../c-api/typeobj.rst:1545
#: ../../c-api/typeobj.rst:1568 ../../c-api/typeobj.rst:1581
#: ../../c-api/typeobj.rst:1596 ../../c-api/typeobj.rst:1610
#: ../../c-api/typeobj.rst:1640 ../../c-api/typeobj.rst:1660
#: ../../c-api/typeobj.rst:1686 ../../c-api/typeobj.rst:1704
#: ../../c-api/typeobj.rst:1744 ../../c-api/typeobj.rst:1795
#: ../../c-api/typeobj.rst:1812 ../../c-api/typeobj.rst:1853
#: ../../c-api/typeobj.rst:1875 ../../c-api/typeobj.rst:1907
#: ../../c-api/typeobj.rst:1935 ../../c-api/typeobj.rst:1948
#: ../../c-api/typeobj.rst:1958 ../../c-api/typeobj.rst:1967
#: ../../c-api/typeobj.rst:1977 ../../c-api/typeobj.rst:1991
#: ../../c-api/typeobj.rst:2037 ../../c-api/typeobj.rst:2060
msgid "**Inheritance:**"
msgstr "**Herencia:**"

#: ../../c-api/typeobj.rst:503 ../../c-api/typeobj.rst:562
#: ../../c-api/typeobj.rst:606
msgid "This field is not inherited by subtypes."
msgstr "Este campo no lo heredan los subtipos."

#: ../../c-api/typeobj.rst:508
msgid ""
"This is the type's type, in other words its metatype.  It is initialized by "
"the argument to the ``PyObject_HEAD_INIT`` macro, and its value should "
"normally be ``&PyType_Type``.  However, for dynamically loadable extension "
"modules that must be usable on Windows (at least), the compiler complains "
"that this is not a valid initializer.  Therefore, the convention is to pass "
"``NULL`` to the ``PyObject_HEAD_INIT`` macro and to initialize this field "
"explicitly at the start of the module's initialization function, before "
"doing anything else.  This is typically done like this::"
msgstr ""
"Es el tipo del tipo, es decir, su metatipo.  Se inicializa mediante el "
"argumento de la macro ``PyObject_HEAD_INIT``, y su valor debería ser "
"normalmente ``&PyType_Type``.  Sin embargo, para los módulos de extensión "
"cargables dinámicamente que se deben utilizar en Windows (al menos), el "
"compilador se queja de que éste no es un inicializador válido.  Por lo "
"tanto, la convención es pasar ``NULL`` a la macro ``PyObject_HEAD_INIT`` e "
"inicializar este campo explícitamente al comienzo de la función de "
"inicialización del módulo, antes de hacer cualquier otra cosa.  Esto se hace "
"típicamente así::"

#: ../../c-api/typeobj.rst:519
msgid ""
"This should be done before any instances of the type are created. :c:func:"
"`PyType_Ready` checks if :attr:`ob_type` is ``NULL``, and if so, initializes "
"it to the :attr:`ob_type` field of the base class. :c:func:`PyType_Ready` "
"will not change this field if it is non-zero."
msgstr ""
"Esto debería hacerse antes de crear ninguna instancia del tipo. :c:func:"
"`PyType_Ready` comprueba si :attr:`ob_type` es ``NULL``, y si es así, lo "
"inicializa al campo :attr:`ob_type` de la clase base. :c:func:`PyType_Ready` "
"no cambiará este campo si es distinto de cero."

#: ../../c-api/typeobj.rst:526 ../../c-api/typeobj.rst:708
#: ../../c-api/typeobj.rst:824 ../../c-api/typeobj.rst:916
#: ../../c-api/typeobj.rst:936 ../../c-api/typeobj.rst:1547
#: ../../c-api/typeobj.rst:1570 ../../c-api/typeobj.rst:1688
#: ../../c-api/typeobj.rst:1706 ../../c-api/typeobj.rst:1797
#: ../../c-api/typeobj.rst:1909 ../../c-api/typeobj.rst:2039
msgid "This field is inherited by subtypes."
msgstr "Este campo es heredado por los subtipos."

#: ../../c-api/typeobj.rst:532
msgid ""
"These fields are only present when the macro ``Py_TRACE_REFS`` is defined "
"(see the :option:`configure --with-trace-refs option <--with-trace-refs>`)."
msgstr ""
"Estos campos sólo están presentes cuando se define la macro "
"``Py_TRACE_REFS`` (véase la opción :option:`configure --with-trace-refs "
"option <--with-trace-refs>`)."

#: ../../c-api/typeobj.rst:535
msgid ""
"Their initialization to ``NULL`` is taken care of by the "
"``PyObject_HEAD_INIT`` macro.  For :ref:`statically allocated objects "
"<static-types>`, these fields always remain ``NULL``.  For :ref:`dynamically "
"allocated objects <heap-types>`, these two fields are used to link the "
"object into a doubly linked list of *all* live objects on the heap."
msgstr ""
"De su inicialización a ``NULL`` se encarga la macro ``PyObject_HEAD_INIT``.  "
"Para :ref:`objetos asignados estáticamente <static-types>`, estos campos "
"siempre permanecen ``NULL``.  Para :ref:`dynamically allocated objects <heap-"
"types>`, estos dos campos se usan para enlazar el objeto en una lista "
"doblemente enlazada de *todos* los objetos vivos del montón."

#: ../../c-api/typeobj.rst:541
msgid ""
"This could be used for various debugging purposes; currently the only uses "
"are the :func:`sys.getobjects` function and to print the objects that are "
"still alive at the end of a run when the environment variable :envvar:"
"`PYTHONDUMPREFS` is set."
msgstr ""
"Esto podría usarse para varios propósitos de depuración; actualmente los "
"únicos usos son la función :func:`sys.getobjects` y para imprimir los "
"objetos que todavía están vivos al final de una ejecución cuando se "
"establece la variable de entorno :envvar:`PYTHONDUMPREFS`."

#: ../../c-api/typeobj.rst:548
msgid "These fields are not inherited by subtypes."
msgstr "Estos campos no son heredados por los subtipos."

#: ../../c-api/typeobj.rst:552
msgid "PyVarObject Slots"
msgstr "Ranuras PyVarObject"

#: ../../c-api/typeobj.rst:556
msgid ""
"For :ref:`statically allocated type objects <static-types>`, this should be "
"initialized to zero. For :ref:`dynamically allocated type objects <heap-"
"types>`, this field has a special internal meaning."
msgstr ""
"Para  :ref:`statically allocated type objects <static-types>`, debe "
"inicializarse a cero. Para :ref:`dynamically allocated type objects <heap-"
"types>`, este campo tiene un significado interno especial."

#: ../../c-api/typeobj.rst:566
msgid "PyTypeObject Slots"
msgstr "Ranuras PyTypeObject"

#: ../../c-api/typeobj.rst:568
msgid ""
"Each slot has a section describing inheritance.  If :c:func:`PyType_Ready` "
"may set a value when the field is set to ``NULL`` then there will also be a "
"\"Default\" section.  (Note that many fields set on :c:type:"
"`PyBaseObject_Type` and :c:type:`PyType_Type` effectively act as defaults.)"
msgstr ""
"Cada ranura tiene una sección que describe la herencia.  Si :c:func:"
"`PyType_Ready` puede establecer un valor cuando el campo se establece en "
"``NULL``, entonces también habrá una sección \"Por defecto\".  (Tener en "
"cuenta que muchos campos establecidos en :c:type:`PyBaseObject_Type` y :c:"
"type:`PyType_Type` actúan efectivamente como predeterminados)."

#: ../../c-api/typeobj.rst:575
msgid ""
"Pointer to a NUL-terminated string containing the name of the type. For "
"types that are accessible as module globals, the string should be the full "
"module name, followed by a dot, followed by the type name; for built-in "
"types, it should be just the type name.  If the module is a submodule of a "
"package, the full package name is part of the full module name.  For "
"example, a type named :class:`T` defined in module :mod:`M` in subpackage :"
"mod:`Q` in package :mod:`P` should have the :c:member:`~PyTypeObject."
"tp_name` initializer ``\"P.Q.M.T\"``."
msgstr ""
"Puntero a una cadena terminada en NUL que contiene el nombre del tipo. Para "
"los tipos accesibles como globales de módulo, la cadena debe ser el nombre "
"completo del módulo, seguido de un punto, seguido del nombre del tipo; para "
"los tipos incorporados, debe ser sólo el nombre del tipo.  Si el módulo es "
"un submódulo de un paquete, el nombre completo del paquete forma parte del "
"nombre completo del módulo.  Por ejemplo, un tipo llamado :class:`T` "
"definido en el módulo :mod:`M` en el subpaquete :mod:`Q` del paquete :mod:"
"`P` debería tener el inicializador :c:member:`~PyTypeObject.tp_name` ``\"P.Q."
"M.T\"`` ."

#: ../../c-api/typeobj.rst:583
msgid ""
"For :ref:`dynamically allocated type objects <heap-types>`, this should just "
"be the type name, and the module name explicitly stored in the type dict as "
"the value for key ``'__module__'``."
msgstr ""
"Para :ref:`dynamically allocated type objects <heap-types>`, esto debería "
"ser sólo el nombre del tipo, y el nombre del módulo almacenado "
"explícitamente en el dict de tipo como valor para la clave ``'__module__'``."

#: ../../c-api/typeobj.rst:588
msgid ""
"For :ref:`statically allocated type objects <static-types>`, the *tp_name* "
"field should contain a dot. Everything before the last dot is made "
"accessible as the :attr:`__module__` attribute, and everything after the "
"last dot is made accessible as the :attr:`~definition.__name__` attribute."
msgstr ""
"Para :ref:`statically allocated type objects <static-types>`, el campo "
"*tp_name* debe contener un punto. Todo lo que hay antes del último punto se "
"hace accesible como atributo :attr:`__module__`, y todo lo que hay después "
"del último punto se hace accesible como atributo :attr:`~definition."
"__name__`."

#: ../../c-api/typeobj.rst:594
msgid ""
"If no dot is present, the entire :c:member:`~PyTypeObject.tp_name` field is "
"made accessible as the :attr:`~definition.__name__` attribute, and the :attr:"
"`__module__` attribute is undefined (unless explicitly set in the "
"dictionary, as explained above).  This means your type will be impossible to "
"pickle.  Additionally, it will not be listed in module documentations "
"created with pydoc."
msgstr ""
"Si no hay un punto presente, el campo completo :c:member:`~PyTypeObject."
"tp_name` se hace accesible como el atributo :attr:`~definition.__name__`, y "
"el atributo :attr:`__module__` no está definido (a menos que se establezca "
"explícitamente en el diccionario, como se explica anteriormente). Esto "
"significa que su tipo será imposible de serializar. Además, no se mostrará "
"en la documentación del módulo creada con pydoc."

#: ../../c-api/typeobj.rst:600
msgid ""
"This field must not be ``NULL``.  It is the only required field in :c:func:"
"`PyTypeObject` (other than potentially :c:member:`~PyTypeObject."
"tp_itemsize`)."
msgstr ""
"Este campo no debe ser ``NULL``. Es el único campo requerido en :c:func:"
"`PyTypeObject` (además de potencialmente :c:member:`~PyTypeObject."
"tp_itemsize`)."

#: ../../c-api/typeobj.rst:612
msgid ""
"These fields allow calculating the size in bytes of instances of the type."
msgstr ""
"Estos campos permiten calcular el tamaño en bytes de las instancias del tipo."

#: ../../c-api/typeobj.rst:614
msgid ""
"There are two kinds of types: types with fixed-length instances have a zero :"
"c:member:`~PyTypeObject.tp_itemsize` field, types with variable-length "
"instances have a non-zero :c:member:`~PyTypeObject.tp_itemsize` field.  For "
"a type with fixed-length instances, all instances have the same size, given "
"in :c:member:`~PyTypeObject.tp_basicsize`."
msgstr ""
"Hay dos clases de tipos: los tipos con instancias de longitud fija tienen un "
"campo :c:member:`~PyTypeObject.tp_itemsize` cero, los tipos con instancias "
"de longitud variable tienen un campo :c:member:`~PyTypeObject.tp_itemsize` "
"distinto de cero.  Para un tipo con instancias de longitud fija, todas las "
"instancias tienen el mismo tamaño, dado en :c:member:`~PyTypeObject."
"tp_basicsize`."

#: ../../c-api/typeobj.rst:619
msgid ""
"For a type with variable-length instances, the instances must have an :attr:"
"`ob_size` field, and the instance size is :c:member:`~PyTypeObject."
"tp_basicsize` plus N times :c:member:`~PyTypeObject.tp_itemsize`, where N is "
"the \"length\" of the object.  The value of N is typically stored in the "
"instance's :attr:`ob_size` field.  There are exceptions:  for example, ints "
"use a negative :attr:`ob_size` to indicate a negative number, and N is "
"``abs(ob_size)`` there.  Also, the presence of an :attr:`ob_size` field in "
"the instance layout doesn't mean that the instance structure is variable-"
"length (for example, the structure for the list type has fixed-length "
"instances, yet those instances have a meaningful :attr:`ob_size` field)."
msgstr ""
"Para un tipo con instancias de longitud variable, las instancias deben tener "
"un campo :attr:`ob_size`, y el tamaño de la instancia es :c:member:"
"`~PyTypeObject.tp_basicsize` más N veces :c:member:`~PyTypeObject."
"tp_itemsize`, donde N es la \"longitud\" del objeto.  El valor de N suele "
"almacenarse en el campo :attr:`ob_size` de la instancia.  Hay excepciones: "
"por ejemplo, los ints utilizan un :attr:`ob_size` negativo para indicar un "
"número negativo, y allí N es ``abs(ob_size)``.  Además, la presencia de un "
"campo :attr:`ob_size` en el diseño de la instancia no significa que la "
"estructura de la instancia sea de longitud variable (por ejemplo, la "
"estructura para el tipo lista tiene instancias de longitud fija, y sin "
"embargo esas instancias tienen un campo :attr:`ob_size` significativo)."

#: ../../c-api/typeobj.rst:630
msgid ""
"The basic size includes the fields in the instance declared by the macro :c:"
"macro:`PyObject_HEAD` or :c:macro:`PyObject_VAR_HEAD` (whichever is used to "
"declare the instance struct) and this in turn includes the :attr:`_ob_prev` "
"and :attr:`_ob_next` fields if they are present.  This means that the only "
"correct way to get an initializer for the :c:member:`~PyTypeObject."
"tp_basicsize` is to use the ``sizeof`` operator on the struct used to "
"declare the instance layout. The basic size does not include the GC header "
"size."
msgstr ""
"El tamaño básico incluye los campos de la instancia declarada por la macro :"
"c:macro:`PyObject_HEAD` o :c:macro:`PyObject_VAR_HEAD` (cualquiera que se "
"utilice para declarar la estructura de instancia) y ésta a su vez incluye "
"los campos :attr:`_ob_prev` y :attr:`_ob_next` si están presentes.  Esto "
"significa que la única forma correcta de obtener un inicializador para :c:"
"member:`~PyTypeObject.tp_basicsize` es utilizar el operador ``sizeof`` en la "
"struct utilizada para declarar la estructura de instancia. El tamaño básico "
"no incluye el tamaño de la cabecera GC."

#: ../../c-api/typeobj.rst:638
msgid ""
"A note about alignment: if the variable items require a particular "
"alignment, this should be taken care of by the value of :c:member:"
"`~PyTypeObject.tp_basicsize`.  Example: suppose a type implements an array "
"of ``double``. :c:member:`~PyTypeObject.tp_itemsize` is ``sizeof(double)``. "
"It is the programmer's responsibility that :c:member:`~PyTypeObject."
"tp_basicsize` is a multiple of ``sizeof(double)`` (assuming this is the "
"alignment requirement for ``double``)."
msgstr ""
"Una nota sobre la alineación: si los elementos de la variable requieren una "
"alineación particular, el valor de :c:member:`~PyTypeObject.tp_basicsize` "
"debería encargarse de ello. Ejemplo: supongamos que un tipo implementa una "
"matriz de ``double``. :c:member:`~PyTypeObject.tp_itemsize` es "
"``sizeof(double)``. Es responsabilidad del programador que :c:member:"
"`~PyTypeObject.tp_basicsize` sea múltiplo de ``sizeof(double)`` (suponiendo "
"que éste sea el requisito de alineación para ``double``)."

#: ../../c-api/typeobj.rst:645
msgid ""
"For any type with variable-length instances, this field must not be ``NULL``."
msgstr ""
"Para cualquier tipo con instancias de longitud variable, este campo no debe "
"ser ``NULL``."

#: ../../c-api/typeobj.rst:649
msgid ""
"These fields are inherited separately by subtypes.  If the base type has a "
"non-zero :c:member:`~PyTypeObject.tp_itemsize`, it is generally not safe to "
"set :c:member:`~PyTypeObject.tp_itemsize` to a different non-zero value in a "
"subtype (though this depends on the implementation of the base type)."
msgstr ""
"Los subtipos heredan estos campos por separado.  Si el tipo base tiene un "
"valor distinto de cero :c:member:`~PyTypeObject.tp_itemsize`, generalmente "
"no es seguro establecer :c:member:`~PyTypeObject.tp_itemsize` a un valor "
"distinto de cero diferente en un subtipo (aunque esto depende de la "
"implementación del tipo base)."

#: ../../c-api/typeobj.rst:657
msgid ""
"A pointer to the instance destructor function.  This function must be "
"defined unless the type guarantees that its instances will never be "
"deallocated (as is the case for the singletons ``None`` and ``Ellipsis``).  "
"The function signature is::"
msgstr ""
"Un puntero a la función destructora de instancias.  Esta función debe "
"definirse a menos que el tipo garantice que sus instancias nunca serán "
"desasignadas (como es el caso de los singletons ``None`` y ``Ellipsis``).  "
"La firma de la función es::"

#: ../../c-api/typeobj.rst:663
msgid ""
"The destructor function is called by the :c:func:`Py_DECREF` and :c:func:"
"`Py_XDECREF` macros when the new reference count is zero.  At this point, "
"the instance is still in existence, but there are no references to it.  The "
"destructor function should free all references which the instance owns, free "
"all memory buffers owned by the instance (using the freeing function "
"corresponding to the allocation function used to allocate the buffer), and "
"call the type's :c:member:`~PyTypeObject.tp_free` function.  If the type is "
"not subtypable (doesn't have the :const:`Py_TPFLAGS_BASETYPE` flag bit set), "
"it is permissible to call the object deallocator directly instead of via :c:"
"member:`~PyTypeObject.tp_free`.  The object deallocator should be the one "
"used to allocate the instance; this is normally :c:func:`PyObject_Del` if "
"the instance was allocated using :c:func:`PyObject_New` or :c:func:"
"`PyObject_VarNew`, or :c:func:`PyObject_GC_Del` if the instance was "
"allocated using :c:func:`PyObject_GC_New` or :c:func:`PyObject_GC_NewVar`."
msgstr ""
"La función destructor es llamada por las macros :c:func:`Py_DECREF` y :c:"
"func:`Py_XDECREF` cuando el nuevo recuento de referencias es cero.  En este "
"punto, la instancia sigue existiendo, pero no hay referencias a ella.  La "
"función destructora debe liberar todas las referencias que posee la "
"instancia, liberar todos los búferes de memoria que posee la instancia "
"(utilizando la función de liberación correspondiente a la función de "
"asignación utilizada para asignar el búfer) y llamar a la función :c:member:"
"`~PyTypeObject.tp_free` del tipo.  Si el tipo no es subtipable (no tiene el "
"bit de bandera :const:`Py_TPFLAGS_BASETYPE` activado), se permite llamar al "
"liberador de objetos directamente en lugar de a través de :c:member:"
"`~PyTypeObject.tp_free`.  El desasignador de objetos debe ser el que se "
"utilizó para asignar la instancia; normalmente es :c:func:`PyObject_Del` si "
"la instancia se asignó utilizando :c:func:`PyObject_New` o :c:func:"
"`PyObject_VarNew`, o :c:func:`PyObject_GC_Del` si la instancia se asignó "
"utilizando :c:func:`PyObject_GC_New` o :c:func:`PyObject_GC_NewVar`."

#: ../../c-api/typeobj.rst:678
msgid ""
"If the type supports garbage collection (has the :const:`Py_TPFLAGS_HAVE_GC` "
"flag bit set), the destructor should call :c:func:`PyObject_GC_UnTrack` "
"before clearing any member fields."
msgstr ""
"Si el tipo admite la recolección de basura (tiene el bit de bandera :const:"
"`Py_TPFLAGS_HAVE_GC` activado), el destructor debe llamar a :c:func:"
"`PyObject_GC_UnTrack` antes de borrar cualquier campo miembro."

#: ../../c-api/typeobj.rst:690
msgid ""
"Finally, if the type is heap allocated (:const:`Py_TPFLAGS_HEAPTYPE`), the "
"deallocator should release the owned reference to its type object (via :c:"
"func:`Py_DECREF`)  after calling the type deallocator. In order to avoid "
"dangling pointers, the recommended way to achieve this is:"
msgstr ""
"Finalmente, si el tipo está asignado al heap (:const:`Py_TPFLAGS_HEAPTYPE`), "
"el liberador debería liberar la referencia propia a su objeto de tipo (vía :"
"c:func:`Py_DECREF`) después de llamar al liberador de tipos. Para evitar "
"punteros colgantes, la forma recomendada de conseguirlo es:"

#: ../../c-api/typeobj.rst:713
msgid ""
"An optional offset to a per-instance function that implements calling the "
"object using the :ref:`vectorcall protocol <vectorcall>`, a more efficient "
"alternative of the simpler :c:member:`~PyTypeObject.tp_call`."
msgstr ""
"Un desplazamiento opcional a una función por instancia que implementa la "
"llamada al objeto utilizando el protocolo :ref:`vectorcall <vectorcall>`, "
"una alternativa más eficiente del más simple :c:member:`~PyTypeObject."
"tp_call`."

#: ../../c-api/typeobj.rst:718
msgid ""
"This field is only used if the flag :const:`Py_TPFLAGS_HAVE_VECTORCALL` is "
"set. If so, this must be a positive integer containing the offset in the "
"instance of a :c:type:`vectorcallfunc` pointer."
msgstr ""
"Este campo sólo se utiliza si el indicador :const:"
"`Py_TPFLAGS_HAVE_VECTORCALL` está activado. Si es así, debe ser un entero "
"positivo que contenga el desplazamiento en la instancia de un puntero :c:"
"type:`vectorcallfunc`."

#: ../../c-api/typeobj.rst:722
msgid ""
"The *vectorcallfunc* pointer may be ``NULL``, in which case the instance "
"behaves as if :const:`Py_TPFLAGS_HAVE_VECTORCALL` was not set: calling the "
"instance falls back to :c:member:`~PyTypeObject.tp_call`."
msgstr ""
"El puntero *vectorcallfunc* puede ser ``NULL``, en cuyo caso la instancia se "
"comporta como si :const:`Py_TPFLAGS_HAVE_VECTORCALL` no estuviera "
"establecido: la llamada a la instancia retrocede a :c:member:`~PyTypeObject."
"tp_call`."

#: ../../c-api/typeobj.rst:726
msgid ""
"Any class that sets ``Py_TPFLAGS_HAVE_VECTORCALL`` must also set :c:member:"
"`~PyTypeObject.tp_call` and make sure its behaviour is consistent with the "
"*vectorcallfunc* function. This can be done by setting *tp_call* to :c:func:"
"`PyVectorcall_Call`."
msgstr ""
"Cualquier clase que establezca ``Py_TPFLAGS_HAVE_VECTORCALL`` debe también "
"establecer :c:member:`~PyTypeObject.tp_call` y asegurarse de que su "
"comportamiento es consistente con la función *vectorcallfunc*. Esto puede "
"hacerse estableciendo *tp_call* a :c:func:`PyVectorcall_Call`."

#: ../../c-api/typeobj.rst:733
msgid ""
"It is not recommended for :ref:`heap types <heap-types>` to implement the "
"vectorcall protocol. When a user sets :attr:`__call__` in Python code, only "
"*tp_call* is updated, likely making it inconsistent with the vectorcall "
"function."
msgstr ""
"No se recomienda que :ref:`heap types <heap-types>` implemente el protocolo "
"vectorcall. Cuando un usuario establece :attr:`__call__` en código Python, "
"sólo se actualiza *tp_call*, lo que probablemente lo hace inconsistente con "
"la función vectorcall."

#: ../../c-api/typeobj.rst:740
msgid ""
"Before version 3.8, this slot was named ``tp_print``. In Python 2.x, it was "
"used for printing to a file. In Python 3.0 to 3.7, it was unused."
msgstr ""
"Antes de la versión 3.8, esta ranura se llamaba ``tp_print``. En Python 2.x, "
"se usaba para imprimir en un fichero. En Python 3.0 a 3.7, no se utilizaba."

#: ../../c-api/typeobj.rst:746
msgid ""
"This field is always inherited. However, the :const:"
"`Py_TPFLAGS_HAVE_VECTORCALL` flag is not always inherited. If it's not, then "
"the subclass won't use :ref:`vectorcall <vectorcall>`, except when :c:func:"
"`PyVectorcall_Call` is explicitly called. This is in particular the case "
"for :ref:`heap types <heap-types>` (including subclasses defined in Python)."
msgstr ""
"Este campo siempre se hereda. Sin embargo, la bandera :const:"
"`Py_TPFLAGS_HAVE_VECTORCALL` no siempre se hereda. Si no lo es, entonces la "
"subclase no utilizará :ref:`vectorcall <vectorcall>`, excepto cuando se "
"llame explícitamente a :c:func:`PyVectorcall_Call`. Este es en particular el "
"caso de :ref:`heap types <heap-types>` (incluyendo subclases definidas en "
"Python)."

#: ../../c-api/typeobj.rst:757
msgid "An optional pointer to the get-attribute-string function."
msgstr "Un puntero opcional a la función get-attribute-string."

#: ../../c-api/typeobj.rst:759
msgid ""
"This field is deprecated.  When it is defined, it should point to a function "
"that acts the same as the :c:member:`~PyTypeObject.tp_getattro` function, "
"but taking a C string instead of a Python string object to give the "
"attribute name."
msgstr ""
"Este campo está obsoleto.  Cuando se defina, debe apuntar a una función que "
"actúe igual que la función :c:member:`~PyTypeObject.tp_getattro`, pero "
"tomando una cadena C en lugar de un objeto cadena Python para dar el nombre "
"del atributo."

#: ../../c-api/typeobj.rst:765 ../../c-api/typeobj.rst:957
msgid "Group: :attr:`tp_getattr`, :attr:`tp_getattro`"
msgstr "Grupo: :attr:`tp_getattr`, :attr:`tp_getattro`"

#: ../../c-api/typeobj.rst:767
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_getattro`: a subtype inherits both :c:member:`~PyTypeObject.tp_getattr` "
"and :c:member:`~PyTypeObject.tp_getattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_getattr` and :c:member:`~PyTypeObject."
"tp_getattro` are both ``NULL``."
msgstr ""
"Este campo es heredado por los subtipos junto con :c:member:`~PyTypeObject."
"tp_getattro`: un subtipo hereda tanto :c:member:`~PyTypeObject.tp_getattr` "
"como :c:member:`~PyTypeObject.tp_getattro` de su tipo base cuando :c:member:"
"`~PyTypeObject.tp_getattr` y :c:member:`~PyTypeObject.tp_getattro` del "
"subtipo son ambos ``NULL``."

#: ../../c-api/typeobj.rst:774 ../../c-api/typeobj.rst:970
msgid ""
"An optional pointer to the function for setting and deleting attributes."
msgstr "Un puntero opcional a la función para establecer y eliminar atributos."

#: ../../c-api/typeobj.rst:776
msgid ""
"This field is deprecated.  When it is defined, it should point to a function "
"that acts the same as the :c:member:`~PyTypeObject.tp_setattro` function, "
"but taking a C string instead of a Python string object to give the "
"attribute name."
msgstr ""
"Este campo está obsoleto.  Cuando se defina, debe apuntar a una función que "
"actúe igual que la función :c:member:`~PyTypeObject.tp_setattro`, pero "
"tomando una cadena C en lugar de un objeto cadena Python para dar el nombre "
"del atributo."

#: ../../c-api/typeobj.rst:782 ../../c-api/typeobj.rst:983
msgid "Group: :attr:`tp_setattr`, :attr:`tp_setattro`"
msgstr "Grupo: :attr:`tp_setattr`, :attr:`tp_setattro`"

#: ../../c-api/typeobj.rst:784
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_setattro`: a subtype inherits both :c:member:`~PyTypeObject.tp_setattr` "
"and :c:member:`~PyTypeObject.tp_setattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_setattr` and :c:member:`~PyTypeObject."
"tp_setattro` are both ``NULL``."
msgstr ""
"Este campo es heredado por los subtipos junto con :c:member:`~PyTypeObject."
"tp_setattro`: un subtipo hereda tanto :c:member:`~PyTypeObject.tp_setattr` "
"como :c:member:`~PyTypeObject.tp_setattro` de su tipo base cuando :c:member:"
"`~PyTypeObject.tp_setattr` y :c:member:`~PyTypeObject.tp_setattro` del "
"subtipo son ambos ``NULL``."

#: ../../c-api/typeobj.rst:791
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement :term:`awaitable` and :term:`asynchronous iterator` "
"protocols at the C-level.  See :ref:`async-structs` for details."
msgstr ""
"Puntero a una estructura adicional que contiene campos relevantes sólo para "
"objetos que implementan los protocolos :term:`awaitable` y :term:"
"`asynchronous iterator` a nivel C.  Ver :ref:`async-structs` para obtener "
"más información."

#: ../../c-api/typeobj.rst:795
msgid "Formerly known as ``tp_compare`` and ``tp_reserved``."
msgstr "Anteriormente conocido como ``tp_compare`` y ``tp_reserved``."

#: ../../c-api/typeobj.rst:800
msgid ""
"The :c:member:`~PyTypeObject.tp_as_async` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"El campo :c:member:`~PyTypeObject.tp_as_async` no se hereda, pero los campos "
"contenidos sí se heredan individualmente."

#: ../../c-api/typeobj.rst:808
msgid ""
"An optional pointer to a function that implements the built-in function :"
"func:`repr`."
msgstr ""
"Un puntero opcional a una función que implementa la función incorporada :"
"func:`repr`."

#: ../../c-api/typeobj.rst:811
msgid "The signature is the same as for :c:func:`PyObject_Repr`::"
msgstr "La firma es la misma que para :c:func:`PyObject_Repr`::"

#: ../../c-api/typeobj.rst:815
msgid ""
"The function must return a string or a Unicode object.  Ideally, this "
"function should return a string that, when passed to :func:`eval`, given a "
"suitable environment, returns an object with the same value.  If this is not "
"feasible, it should return a string starting with ``'<'`` and ending with "
"``'>'`` from which both the type and the value of the object can be deduced."
msgstr ""
"La función debe devolver una cadena o un objeto Unicode.  Idealmente, esta "
"función debería devolver una cadena que, cuando se pasa a :func:`eval`, dado "
"un entorno adecuado, devuelve un objeto con el mismo valor.  Si esto no es "
"factible, debe devolver una cadena que empiece por ``'<'`` y termine por "
"``'>'`` a partir de la cual puedan deducirse tanto el tipo como el valor del "
"objeto."

#: ../../c-api/typeobj.rst:826 ../../c-api/typeobj.rst:938
#: ../../c-api/typeobj.rst:963 ../../c-api/typeobj.rst:989
#: ../../c-api/typeobj.rst:1031 ../../c-api/typeobj.rst:1492
#: ../../c-api/typeobj.rst:1644 ../../c-api/typeobj.rst:1665
#: ../../c-api/typeobj.rst:1763 ../../c-api/typeobj.rst:1799
#: ../../c-api/typeobj.rst:1817 ../../c-api/typeobj.rst:1859
#: ../../c-api/typeobj.rst:1880 ../../c-api/typeobj.rst:1911
msgid "**Default:**"
msgstr "**Por defecto:**"

#: ../../c-api/typeobj.rst:828
msgid ""
"When this field is not set, a string of the form ``<%s object at %p>`` is "
"returned, where ``%s`` is replaced by the type name, and ``%p`` by the "
"object's memory address."
msgstr ""
"Si no se define este campo, se devuelve una cadena de caracteres del tipo "
"``<%s object at %p>``, donde ``%s`` se sustituye por el nombre del tipo y "
"``%p`` por la dirección de memoria del objeto."

#: ../../c-api/typeobj.rst:835
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the number protocol.  These fields are documented "
"in :ref:`number-structs`."
msgstr ""
"Puntero a una estructura adicional que contiene campos relevantes sólo para "
"los objetos que implementan el protocolo numérico.  Estos campos están "
"documentados en :ref:`number-structs`."

#: ../../c-api/typeobj.rst:841
msgid ""
"The :c:member:`~PyTypeObject.tp_as_number` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"El campo :c:member:`~PyTypeObject.tp_as_number` no se hereda, pero los "
"campos contenidos sí se heredan individualmente."

#: ../../c-api/typeobj.rst:847
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the sequence protocol.  These fields are documented "
"in :ref:`sequence-structs`."
msgstr ""
"Puntero a una estructura adicional que contiene campos relevantes sólo para "
"los objetos que implementan el protocolo de secuencia.  Estos campos están "
"documentados en :ref:`sequence-structs`."

#: ../../c-api/typeobj.rst:853
msgid ""
"The :c:member:`~PyTypeObject.tp_as_sequence` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"El campo :c:member:`~PyTypeObject.tp_as_sequence` no se hereda, pero los "
"campos contenidos sí se heredan individualmente."

#: ../../c-api/typeobj.rst:859
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the mapping protocol.  These fields are documented "
"in :ref:`mapping-structs`."
msgstr ""
"Puntero a una estructura adicional que contiene campos relevantes sólo para "
"los objetos que implementan el protocolo de mapeo.  Estos campos están "
"documentados en :ref:`mapping-structs`."

#: ../../c-api/typeobj.rst:865
msgid ""
"The :c:member:`~PyTypeObject.tp_as_mapping` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"El campo :c:member:`~PyTypeObject.tp_as_mapping` no se hereda, pero los "
"campos contenidos sí se heredan individualmente."

#: ../../c-api/typeobj.rst:873
msgid ""
"An optional pointer to a function that implements the built-in function :"
"func:`hash`."
msgstr ""
"Un puntero opcional a una función que implementa la función incorporada :"
"func:`hash`."

#: ../../c-api/typeobj.rst:876
msgid "The signature is the same as for :c:func:`PyObject_Hash`::"
msgstr "La firma es la misma que para :c:func:`PyObject_Hash`::"

#: ../../c-api/typeobj.rst:880
msgid ""
"The value ``-1`` should not be returned as a normal return value; when an "
"error occurs during the computation of the hash value, the function should "
"set an exception and return ``-1``."
msgstr ""
"El valor ``-1`` no se debe devolver como valor de retorno normal; cuando se "
"produce un error durante el cálculo del valor hash, la función debe "
"establecer una excepción y devolver ``-1``."

#: ../../c-api/typeobj.rst:884
msgid ""
"When this field is not set (*and* :attr:`tp_richcompare` is not set), an "
"attempt to take the hash of the object raises :exc:`TypeError`. This is the "
"same as setting it to :c:func:`PyObject_HashNotImplemented`."
msgstr ""
"Cuando este campo no está establecido (*y* :attr:`tp_richcompare` no está "
"establecido), un intento de tomar el hash del objeto eleva :exc:`TypeError`. "
"Esto es lo mismo que establecerlo en :c:func:`PyObject_HashNotImplemented`."

#: ../../c-api/typeobj.rst:888
msgid ""
"This field can be set explicitly to :c:func:`PyObject_HashNotImplemented` to "
"block inheritance of the hash method from a parent type. This is interpreted "
"as the equivalent of ``__hash__ = None`` at the Python level, causing "
"``isinstance(o, collections.Hashable)`` to correctly return ``False``. Note "
"that the converse is also true - setting ``__hash__ = None`` on a class at "
"the Python level will result in the ``tp_hash`` slot being set to :c:func:"
"`PyObject_HashNotImplemented`."
msgstr ""
"Este campo puede establecerse explícitamente a :c:func:"
"`PyObject_HashNotImplemented` para bloquear la herencia del método hash de "
"un tipo padre. Esto se interpreta como el equivalente de ``__hash__ = None`` "
"a nivel de Python, haciendo que ``isinstance(o, collections.Hashable)`` "
"devuelva correctamente ``False``. Tenga en cuenta que lo contrario también "
"es cierto - establecer ``__hash__ = None`` en una clase a nivel Python "
"resultará en que el campo ``tp_hash`` se establezca en :c:func:"
"`PyObject_HashNotImplemented`."

#: ../../c-api/typeobj.rst:898 ../../c-api/typeobj.rst:1485
msgid "Group: :attr:`tp_hash`, :attr:`tp_richcompare`"
msgstr "Grupo: :attr:`tp_hash`, :attr:`tp_richcompare`"

#: ../../c-api/typeobj.rst:900
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_richcompare`: a subtype inherits both of :c:member:`~PyTypeObject."
"tp_richcompare` and :c:member:`~PyTypeObject.tp_hash`, when the subtype's :c:"
"member:`~PyTypeObject.tp_richcompare` and :c:member:`~PyTypeObject.tp_hash` "
"are both ``NULL``."
msgstr ""
"Este campo es heredado por los subtipos junto con :c:member:`~PyTypeObject."
"tp_richcompare`: un subtipo hereda ambos de :c:member:`~PyTypeObject."
"tp_richcompare` y :c:member:`~PyTypeObject.tp_hash`, cuando los :c:member:"
"`~PyTypeObject.tp_richcompare` y :c:member:`~PyTypeObject.tp_hash` del "
"subtipo son ambos ``NULL``."

#: ../../c-api/typeobj.rst:908
msgid ""
"An optional pointer to a function that implements calling the object.  This "
"should be ``NULL`` if the object is not callable.  The signature is the same "
"as for :c:func:`PyObject_Call`::"
msgstr ""
"Un puntero opcional a una función que implementa la llamada al objeto.  Debe "
"ser ``NULL`` si el objeto no es invocable.  La firma es la misma que para :c:"
"func:`PyObject_Call`::"

#: ../../c-api/typeobj.rst:921
msgid ""
"An optional pointer to a function that implements the built-in operation :"
"func:`str`.  (Note that :class:`str` is a type now, and :func:`str` calls "
"the constructor for that type.  This constructor calls :c:func:"
"`PyObject_Str` to do the actual work, and :c:func:`PyObject_Str` will call "
"this handler.)"
msgstr ""
"Un puntero opcional a una función que implementa la operación incorporada :"
"func:`str`.  (Observar que :class:`str` es ahora un tipo, y :func:`str` "
"llama al constructor para ese tipo.  Este constructor llama a :c:func:"
"`PyObject_Str` para hacer el trabajo real, y :c:func:`PyObject_Str` llamará "
"a este manejador)."

#: ../../c-api/typeobj.rst:926
msgid "The signature is the same as for :c:func:`PyObject_Str`::"
msgstr "La firma es la misma que para :c:func:`PyObject_Str`::"

#: ../../c-api/typeobj.rst:930
msgid ""
"The function must return a string or a Unicode object.  It should be a "
"\"friendly\" string representation of the object, as this is the "
"representation that will be used, among other things, by the :func:`print` "
"function."
msgstr ""
"La función debe devolver una cadena o un objeto Unicode.  Debe ser una "
"representación de cadena \"amigable\" del objeto, ya que ésta es la "
"representación que utilizará, entre otras cosas, la función :func:`print`."

#: ../../c-api/typeobj.rst:940
msgid ""
"When this field is not set, :c:func:`PyObject_Repr` is called to return a "
"string representation."
msgstr ""
"Cuando este campo no está definido, se llama a :c:func:`PyObject_Repr` para "
"que devuelva una representación de cadena."

#: ../../c-api/typeobj.rst:946
msgid "An optional pointer to the get-attribute function."
msgstr "Un puntero opcional a la función get-attribute."

#: ../../c-api/typeobj.rst:948
msgid "The signature is the same as for :c:func:`PyObject_GetAttr`::"
msgstr "La firma es la misma que para :c:func:`PyObject_GetAttr`::"

#: ../../c-api/typeobj.rst:952
msgid ""
"It is usually convenient to set this field to :c:func:"
"`PyObject_GenericGetAttr`, which implements the normal way of looking for "
"object attributes."
msgstr ""
"Suele ser conveniente establecer este campo en :c:func:"
"`PyObject_GenericGetAttr`, que implementa la forma normal de buscar "
"atributos de objetos."

#: ../../c-api/typeobj.rst:959
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_getattr`: a subtype inherits both :c:member:`~PyTypeObject.tp_getattr` "
"and :c:member:`~PyTypeObject.tp_getattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_getattr` and :c:member:`~PyTypeObject."
"tp_getattro` are both ``NULL``."
msgstr ""
"Este campo es heredado por los subtipos junto con :c:member:`~PyTypeObject."
"tp_getattr`: un subtipo hereda tanto :c:member:`~PyTypeObject.tp_getattr` "
"como :c:member:`~PyTypeObject.tp_getattro` de su tipo base cuando :c:member:"
"`~PyTypeObject.tp_getattr` y :c:member:`~PyTypeObject.tp_getattro` del "
"subtipo son ambos ``NULL``."

#: ../../c-api/typeobj.rst:965
msgid ":c:type:`PyBaseObject_Type` uses :c:func:`PyObject_GenericGetAttr`."
msgstr ":c:type:`PyBaseObject_Type` utiliza :c:func:`PyObject_GenericGetAttr`."

#: ../../c-api/typeobj.rst:972
msgid "The signature is the same as for :c:func:`PyObject_SetAttr`::"
msgstr "La firma es la misma que para :c:func:`PyObject_SetAttr`::"

#: ../../c-api/typeobj.rst:976
msgid ""
"In addition, setting *value* to ``NULL`` to delete an attribute must be "
"supported.  It is usually convenient to set this field to :c:func:"
"`PyObject_GenericSetAttr`, which implements the normal way of setting object "
"attributes."
msgstr ""
"Además, debe admitirse la posibilidad de establecer *value* en ``NULL`` para "
"eliminar un atributo.  Suele ser conveniente establecer este campo en :c:"
"func:`PyObject_GenericSetAttr`, que implementa la forma normal de establecer "
"atributos de objetos."

#: ../../c-api/typeobj.rst:985
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_setattr`: a subtype inherits both :c:member:`~PyTypeObject.tp_setattr` "
"and :c:member:`~PyTypeObject.tp_setattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_setattr` and :c:member:`~PyTypeObject."
"tp_setattro` are both ``NULL``."
msgstr ""
"Este campo es heredado por los subtipos junto con :c:member:`~PyTypeObject."
"tp_setattr`: un subtipo hereda tanto :c:member:`~PyTypeObject.tp_setattr` "
"como :c:member:`~PyTypeObject.tp_setattro` de su tipo base cuando :c:member:"
"`~PyTypeObject.tp_setattr` y :c:member:`~PyTypeObject.tp_setattro` del "
"subtipo son ambos ``NULL``."

#: ../../c-api/typeobj.rst:991
msgid ":c:type:`PyBaseObject_Type` uses :c:func:`PyObject_GenericSetAttr`."
msgstr ":c:type:`PyBaseObject_Type` usa :c:func:`PyObject_GenericSetAttr`."

#: ../../c-api/typeobj.rst:996
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the buffer interface.  These fields are documented "
"in :ref:`buffer-structs`."
msgstr ""
"Puntero a una estructura adicional que contiene campos relevantes sólo para "
"los objetos que implementan la interfaz de búfer.  Estos campos están "
"documentados en :ref:`buffer-structs`."

#: ../../c-api/typeobj.rst:1002
msgid ""
"The :c:member:`~PyTypeObject.tp_as_buffer` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"El campo :c:member:`~PyTypeObject.tp_as_buffer` no se hereda, pero los "
"campos contenidos sí se heredan individualmente."

#: ../../c-api/typeobj.rst:1008
msgid ""
"This field is a bit mask of various flags.  Some flags indicate variant "
"semantics for certain situations; others are used to indicate that certain "
"fields in the type object (or in the extension structures referenced via :c:"
"member:`~PyTypeObject.tp_as_number`, :c:member:`~PyTypeObject."
"tp_as_sequence`, :c:member:`~PyTypeObject.tp_as_mapping`, and :c:member:"
"`~PyTypeObject.tp_as_buffer`) that were historically not always present are "
"valid; if such a flag bit is clear, the type fields it guards must not be "
"accessed and must be considered to have a zero or ``NULL`` value instead."
msgstr ""
"Este campo es una máscara de bits de varios indicadores.  Algunas banderas "
"indican variantes semánticas para ciertas situaciones; otras se utilizan "
"para indicar que ciertos campos en el objeto de tipo (o en las estructuras "
"de extensión referenciadas mediante :c:member:`~PyTypeObject.tp_as_number`, :"
"c:member:`~PyTypeObject.tp_as_sequence`, :c:member:`~PyTypeObject."
"tp_as_mapping`, y :c:member:`~PyTypeObject.tp_as_buffer`) que históricamente "
"no estaban siempre presentes son válidos; si un bit de bandera de este tipo "
"está despejado, no se debe acceder a los campos de tipo que guarda y en su "
"lugar se debe considerar que tienen un valor cero o ``NULL``."

#: ../../c-api/typeobj.rst:1018
msgid ""
"Inheritance of this field is complicated.  Most flag bits are inherited "
"individually, i.e. if the base type has a flag bit set, the subtype inherits "
"this flag bit.  The flag bits that pertain to extension structures are "
"strictly inherited if the extension structure is inherited, i.e. the base "
"type's value of the flag bit is copied into the subtype together with a "
"pointer to the extension structure.  The :const:`Py_TPFLAGS_HAVE_GC` flag "
"bit is inherited together with the :c:member:`~PyTypeObject.tp_traverse` "
"and :c:member:`~PyTypeObject.tp_clear` fields, i.e. if the :const:"
"`Py_TPFLAGS_HAVE_GC` flag bit is clear in the subtype and the :c:member:"
"`~PyTypeObject.tp_traverse` and :c:member:`~PyTypeObject.tp_clear` fields in "
"the subtype exist and have ``NULL`` values."
msgstr ""
"La herencia de este campo es complicada.  La mayoría de los bits de bandera "
"se heredan individualmente, es decir, si el tipo base tiene un bit de "
"bandera activado, el subtipo hereda este bit de bandera.  Los bits de "
"bandera que pertenecen a estructuras de extensión se heredan estrictamente "
"si se hereda la estructura de extensión, es decir, el valor del bit de "
"bandera del tipo base se copia en el subtipo junto con un puntero a la "
"estructura de extensión.  El bit de bandera :const:`Py_TPFLAGS_HAVE_GC` se "
"hereda junto con los campos :c:member:`~PyTypeObject.tp_traverse` y :c:"
"member:`~PyTypeObject.tp_clear`, es decir, si el bit de bandera :const:"
"`Py_TPFLAGS_HAVE_GC` está despejado en el subtipo y los campos :c:member:"
"`~PyTypeObject.tp_traverse` y :c:member:`~PyTypeObject.tp_clear` en el "
"subtipo existen y tienen valores ``NULL``."

#: ../../c-api/typeobj.rst:1033
msgid ""
":c:type:`PyBaseObject_Type` uses ``Py_TPFLAGS_DEFAULT | "
"Py_TPFLAGS_BASETYPE``."
msgstr ""
":c:type:`PyBaseObject_Type` utiliza ``Py_TPFLAGS_DEFAULT | "
"Py_TPFLAGS_BASETYPE``."

#: ../../c-api/typeobj.rst:1036
msgid "**Bit Masks:**"
msgstr "**Máscaras de bits**"

#: ../../c-api/typeobj.rst:1038
msgid ""
"The following bit masks are currently defined; these can be ORed together "
"using the ``|`` operator to form the value of the :c:member:`~PyTypeObject."
"tp_flags` field.  The macro :c:func:`PyType_HasFeature` takes a type and a "
"flags value, *tp* and *f*, and checks whether ``tp->tp_flags & f`` is non-"
"zero."
msgstr ""
"Actualmente están definidas las siguientes máscaras de bits, que pueden "
"unirse mediante el operador ``|`` para formar el valor del campo :c:member:"
"`~PyTypeObject.tp_flags`.  La macro :c:func:`PyType_HasFeature` toma un tipo "
"y un valor flags, *tp* y *f*, y comprueba si ``tp->tp_flags & f`` es "
"distinto de cero."

#: ../../c-api/typeobj.rst:1045
msgid ""
"This bit is set when the type object itself is allocated on the heap, for "
"example, types created dynamically using :c:func:`PyType_FromSpec`.  In this "
"case, the :attr:`ob_type` field of its instances is considered a reference "
"to the type, and the type object is INCREF'ed when a new instance is "
"created, and DECREF'ed when an instance is destroyed (this does not apply to "
"instances of subtypes; only the type referenced by the instance's ob_type "
"gets INCREF'ed or DECREF'ed)."
msgstr ""
"Este bit se activa cuando el propio objeto de tipo se asigna en el montón, "
"por ejemplo, los tipos creados dinámicamente utilizando :c:func:"
"`PyType_FromSpec`.  En este caso, el campo :attr:`ob_type` de sus instancias "
"se considera una referencia al tipo, y el objeto de tipo es INCREF'ed cuando "
"se crea una nueva instancia, y DECREF'ed cuando se destruye una instancia "
"(esto no se aplica a instancias de subtipos; sólo el tipo referenciado por "
"el ob_type de la instancia es INCREF'ed o DECREF'ed)."

#: ../../c-api/typeobj.rst:1055 ../../c-api/typeobj.rst:1066
#: ../../c-api/typeobj.rst:1076 ../../c-api/typeobj.rst:1086
#: ../../c-api/typeobj.rst:1118
msgid "???"
msgstr "???"

#: ../../c-api/typeobj.rst:1060
msgid ""
"This bit is set when the type can be used as the base type of another type.  "
"If this bit is clear, the type cannot be subtyped (similar to a \"final\" "
"class in Java)."
msgstr ""
"Este bit se activa cuando el tipo puede utilizarse como tipo base de otro "
"tipo.  Si este bit está despejado, el tipo no puede ser subtipado (similar a "
"una clase \"final\" en Java)."

#: ../../c-api/typeobj.rst:1071
msgid ""
"This bit is set when the type object has been fully initialized by :c:func:"
"`PyType_Ready`."
msgstr ""
"Este bit se activa cuando el objeto de tipo ha sido totalmente inicializado "
"por :c:func:`PyType_Ready`."

#: ../../c-api/typeobj.rst:1081
msgid ""
"This bit is set while :c:func:`PyType_Ready` is in the process of "
"initializing the type object."
msgstr ""
"Este bit se establece mientras :c:func:`PyType_Ready` está en proceso de "
"inicializar el objeto de tipo."

#: ../../c-api/typeobj.rst:1091
msgid ""
"This bit is set when the object supports garbage collection.  If this bit is "
"set, instances must be created using :c:func:`PyObject_GC_New` and destroyed "
"using :c:func:`PyObject_GC_Del`.  More information in section :ref:"
"`supporting-cycle-detection`.  This bit also implies that the GC-related "
"fields :c:member:`~PyTypeObject.tp_traverse` and :c:member:`~PyTypeObject."
"tp_clear` are present in the type object."
msgstr ""
"Este bit se establece cuando el objeto admite la recolección de basura. Si "
"este bit está establecido, las instancias deben crearse utilizando :c:func:"
"`PyObject_GC_New` y destruirse utilizando :c:func:`PyObject_GC_Del`. Más "
"información en la sección :ref:`supporting-cycle-detection`. Este bit "
"también implica que los campos relacionados con la GC :c:member:"
"`~PyTypeObject.tp_traverse` y :c:member:`~PyTypeObject.tp_clear` están "
"presentes en el objeto de tipo."

#: ../../c-api/typeobj.rst:1100 ../../c-api/typeobj.rst:1358
#: ../../c-api/typeobj.rst:1426
msgid ""
"Group: :const:`Py_TPFLAGS_HAVE_GC`, :attr:`tp_traverse`, :attr:`tp_clear`"
msgstr ""
"Grupo: :const:`Py_TPFLAGS_HAVE_GC`, :attr:`tp_traverse`, :attr:`tp_clear`"

#: ../../c-api/typeobj.rst:1102
msgid ""
"The :const:`Py_TPFLAGS_HAVE_GC` flag bit is inherited together with the :"
"attr:`tp_traverse` and :attr:`tp_clear` fields, i.e.  if the :const:"
"`Py_TPFLAGS_HAVE_GC` flag bit is clear in the subtype and the :attr:"
"`tp_traverse` and :attr:`tp_clear` fields in the subtype exist and have "
"``NULL`` values."
msgstr ""
"El bit de la bandera :const:`Py_TPFLAGS_HAVE_GC` se hereda junto con los "
"campos :attr:`tp_traverse` y :attr:`tp_clear`, es decir, si el bit de la "
"bandera :const:`Py_TPFLAGS_HAVE_GC` está desactivado en el subtipo y los "
"campos :attr:`tp_traverse` y :attr:`tp_clear` existen en el subtipo y tienen "
"valores ``NULL``."

#: ../../c-api/typeobj.rst:1112
msgid ""
"This is a bitmask of all the bits that pertain to the existence of certain "
"fields in the type object and its extension structures. Currently, it "
"includes the following bits: :const:`Py_TPFLAGS_HAVE_STACKLESS_EXTENSION`."
msgstr ""
"Esta es una máscara de bits de todos los bits que se refieren a la "
"existencia de ciertos campos en el objeto de tipo y sus estructuras de "
"extensión. Actualmente, incluye los siguientes bits: :const:"
"`Py_TPFLAGS_HAVE_STACKLESS_EXTENSION`."

#: ../../c-api/typeobj.rst:1123
msgid "This bit indicates that objects behave like unbound methods."
msgstr ""
"Este fragmento indica que los objetos se comportan como métodos no "
"vinculados."

#: ../../c-api/typeobj.rst:1125
msgid "If this flag is set for ``type(meth)``, then:"
msgstr "Si esta bandera se establece para ``type(meth)``, entonces:"

#: ../../c-api/typeobj.rst:1127
msgid ""
"``meth.__get__(obj, cls)(*args, **kwds)`` (with ``obj`` not None) must be "
"equivalent to ``meth(obj, *args, **kwds)``."
msgstr ""
"``meth.__get__(obj, cls)(*args, **kwds)`` (con ``obj`` no siendo None) debe "
"ser equivalente a ``meth(obj, *args, **kwds)``."

#: ../../c-api/typeobj.rst:1130
msgid ""
"``meth.__get__(None, cls)(*args, **kwds)`` must be equivalent to "
"``meth(*args, **kwds)``."
msgstr ""
"``meth.__get__(None, cls)(*args, **kwds)`` debe ser equivalente a "
"``meth(*args, **kwds)``."

#: ../../c-api/typeobj.rst:1133
msgid ""
"This flag enables an optimization for typical method calls like ``obj."
"meth()``: it avoids creating a temporary \"bound method\" object for ``obj."
"meth``."
msgstr ""
"Este indicador habilita una optimización para llamadas de método típicas "
"como ``obj.meth()``: evita crear un objeto temporal de \"método vinculado\" "
"para ``obj.meth``."

#: ../../c-api/typeobj.rst:1141
msgid ""
"This flag is never inherited by :ref:`heap types <heap-types>`. For "
"extension types, it is inherited whenever :c:member:`~PyTypeObject."
"tp_descr_get` is inherited."
msgstr ""
"Esta bandera nunca es heredada por :ref:`heap types <heap-types>`. Para "
"tipos de extensión, es heredada siempre que se herede :c:member:"
"`~PyTypeObject.tp_descr_get`."

#: ../../c-api/typeobj.rst:1158
msgid ""
"These flags are used by functions such as :c:func:`PyLong_Check` to quickly "
"determine if a type is a subclass of a built-in type; such specific checks "
"are faster than a generic check, like :c:func:`PyObject_IsInstance`. Custom "
"types that inherit from built-ins should have their :c:member:`~PyTypeObject."
"tp_flags` set appropriately, or the code that interacts with such types will "
"behave differently depending on what kind of check is used."
msgstr ""
"Estas banderas son utilizadas por funciones como :c:func:`PyLong_Check` para "
"determinar rápidamente si un tipo es una subclase de un tipo incorporado; "
"estas comprobaciones específicas son más rápidas que una comprobación "
"genérica, como :c:func:`PyObject_IsInstance`. Los tipos personalizados que "
"heredan de los tipos incorporados deben tener sus :c:member:`~PyTypeObject."
"tp_flags` configurados adecuadamente, o el código que interactúa con dichos "
"tipos se comportará de manera diferente dependiendo del tipo de comprobación "
"que se utilice."

#: ../../c-api/typeobj.rst:1169
msgid ""
"This bit is set when the :c:member:`~PyTypeObject.tp_finalize` slot is "
"present in the type structure."
msgstr ""
"Este bit se establece cuando la ranura:c:member:`~PyTypeObject.tp_finalize` "
"está presente en la estructura del tipo."

#: ../../c-api/typeobj.rst:1174
msgid ""
"This flag isn't necessary anymore, as the interpreter assumes the :c:member:"
"`~PyTypeObject.tp_finalize` slot is always present in the type structure."
msgstr ""
"Esta bandera ya no es necesaria, ya que el intérprete asume que la ranura :c:"
"member:`~PyTypeObject.tp_finalize` siempre está presente en la estructura "
"del tipo."

#: ../../c-api/typeobj.rst:1182
msgid ""
"This bit is set when the class implements the :ref:`vectorcall protocol "
"<vectorcall>`. See :c:member:`~PyTypeObject.tp_vectorcall_offset` for "
"details."
msgstr ""
"Este bit se establece cuando la clase implementa el protocolo :ref:"
"`vectorcall <vectorcall>`. Ver para más detalles :c:member:`~PyTypeObject."
"tp_vectorcall_offset`."

#: ../../c-api/typeobj.rst:1188
msgid ""
"This bit is inherited for :ref:`static subtypes <static-types>` if :c:member:"
"`~PyTypeObject.tp_call` is also inherited. :ref:`Heap types <heap-types>` do "
"not inherit ``Py_TPFLAGS_HAVE_VECTORCALL``."
msgstr ""
"Este fragmento se hereda para :ref:`static subtypes <static-types>` si "
"también se hereda :c:member:`~PyTypeObject.tp_call`. Los :ref:`Heap types "
"<heap-types>` no heredan ``Py_TPFLAGS_HAVE_VECTORCALL``."

#: ../../c-api/typeobj.rst:1196
msgid ""
"This bit is set for type objects that are immutable: type attributes cannot "
"be set nor deleted."
msgstr ""
"Este bit se establece para los objetos de tipo que son inmutables: los "
"atributos de tipo no se pueden establecer ni eliminar."

#: ../../c-api/typeobj.rst:1198
msgid ""
":c:func:`PyType_Ready` automatically applies this flag to :ref:`static types "
"<static-types>`."
msgstr ""
":c:func:`PyType_Ready` aplica automáticamente esta bandera a :ref:`static "
"types <static-types>`."

#: ../../c-api/typeobj.rst:1203
msgid "This flag is not inherited."
msgstr "Esta bandera no se hereda."

#: ../../c-api/typeobj.rst:1209
msgid ""
"Disallow creating instances of the type: set :c:member:`~PyTypeObject."
"tp_new` to NULL and don't create the ``__new__`` key in the type dictionary."
msgstr ""
"No permita la creación de instancias del tipo: establezca :c:member:"
"`~PyTypeObject.tp_new` en NULL y no cree la clave ``__new__`` en el "
"diccionario de tipos."

#: ../../c-api/typeobj.rst:1213
msgid ""
"The flag must be set before creating the type, not after. For example, it "
"must be set before :c:func:`PyType_Ready` is called on the type."
msgstr ""
"El indicador debe activarse antes de crear el tipo, no después. Por ejemplo, "
"debe establecerse antes de llamar a :c:func:`PyType_Ready` en el tipo."

#: ../../c-api/typeobj.rst:1216
msgid ""
"The flag is set automatically on :ref:`static types <static-types>` if :c:"
"member:`~PyTypeObject.tp_base` is NULL or ``&PyBaseObject_Type`` and :c:"
"member:`~PyTypeObject.tp_new` is NULL."
msgstr ""
"La bandera se establece automáticamente en :ref:`tipos estáticos <static-"
"types>` si :c:member:`~PyTypeObject.tp_base` es NULL o "
"``&PyBaseObject_Type`` y :c:member:`~PyTypeObject.tp_new` es NULL."

#: ../../c-api/typeobj.rst:1222
msgid ""
"This flag is not inherited. However, subclasses will not be instantiable "
"unless they provide a non-NULL :c:member:`~PyTypeObject.tp_new` (which is "
"only possible via the C API)."
msgstr ""
"Esta bandera no se hereda. Sin embargo, las subclases no serán instanciables "
"a menos que proporcionen un :c:member:`~PyTypeObject.tp_new` no NULL (que "
"sólo es posible a través de la API de C)."

#: ../../c-api/typeobj.rst:1229
msgid ""
"To disallow instantiating a class directly but allow instantiating its "
"subclasses (e.g. for an :term:`abstract base class`), do not use this flag. "
"Instead, make :c:member:`~PyTypeObject.tp_new` only succeed for subclasses."
msgstr ""
"Para no permitir la instanciación directa de una clase pero sí la de sus "
"subclases (por ejemplo, para una clase base abstracta), no utilice este "
"indicador. En su lugar, haga que :c:member:`~PyTypeObject.tp_new` sólo tenga "
"éxito para las subclases."

#: ../../c-api/typeobj.rst:1240
msgid ""
"This bit indicates that instances of the class may match mapping patterns "
"when used as the subject of a :keyword:`match` block. It is automatically "
"set when registering or subclassing :class:`collections.abc.Mapping`, and "
"unset when registering :class:`collections.abc.Sequence`."
msgstr ""
"Este bit indica que las instancias de la clase pueden coincidir con patrones "
"de asignación cuando se utilizan como asunto de un bloque :keyword:`match`. "
"Se activa automáticamente al registrar o subclasificar :class:`collections."
"abc.Mapping`, y se desactiva al registrar :class:`collections.abc.Sequence`."

#: ../../c-api/typeobj.rst:1247 ../../c-api/typeobj.rst:1269
msgid ""
":const:`Py_TPFLAGS_MAPPING` and :const:`Py_TPFLAGS_SEQUENCE` are mutually "
"exclusive; it is an error to enable both flags simultaneously."
msgstr ""
":const:`Py_TPFLAGS_MAPPING` y :const:`Py_TPFLAGS_SEQUENCE` son mutuamente "
"excluyentes; es un error habilitar ambos indicadores simultáneamente."

#: ../../c-api/typeobj.rst:1252
msgid ""
"This flag is inherited by types that do not already set :const:"
"`Py_TPFLAGS_SEQUENCE`."
msgstr ""
"Esta bandera se hereda por los tipos que no establecen :const:"
"`Py_TPFLAGS_SEQUENCE` previamente."

#: ../../c-api/typeobj.rst:1255 ../../c-api/typeobj.rst:1277
msgid ":pep:`634` -- Structural Pattern Matching: Specification"
msgstr ""
":pep:`634` -- Correspondencia de patrones estructurales: especificación"

#: ../../c-api/typeobj.rst:1262
msgid ""
"This bit indicates that instances of the class may match sequence patterns "
"when used as the subject of a :keyword:`match` block. It is automatically "
"set when registering or subclassing :class:`collections.abc.Sequence`, and "
"unset when registering :class:`collections.abc.Mapping`."
msgstr ""
"Este bit indica que las instancias de la clase pueden coincidir con patrones "
"de secuencia cuando se utilizan como sujeto de un bloque :keyword:`match`. "
"Se activa automáticamente al registrar o subclasificar :class:`collections."
"abc.Sequence`, y se desactiva al registrar :class:`collections.abc.Mapping`."

#: ../../c-api/typeobj.rst:1274
msgid ""
"This flag is inherited by types that do not already set :const:"
"`Py_TPFLAGS_MAPPING`."
msgstr ""
"Esta bandera se hereda por los tipos que no establecen :const:"
"`Py_TPFLAGS_MAPPING` previamente."

#: ../../c-api/typeobj.rst:1284
msgid ""
"An optional pointer to a NUL-terminated C string giving the docstring for "
"this type object.  This is exposed as the :attr:`__doc__` attribute on the "
"type and instances of the type."
msgstr ""
"Un puntero opcional a una cadena de caracteres C terminada en NUL que "
"proporciona la cadena de documentación para este objeto de tipo. Esto se "
"expone como el atributo :attr:`__doc__` en el tipo y las instancias del tipo."

#: ../../c-api/typeobj.rst:1290
msgid "This field is *not* inherited by subtypes."
msgstr "Este campo *no* se hereda por los subtipos."

#: ../../c-api/typeobj.rst:1295
msgid ""
"An optional pointer to a traversal function for the garbage collector.  This "
"is only used if the :const:`Py_TPFLAGS_HAVE_GC` flag bit is set.  The "
"signature is::"
msgstr ""
"Un puntero opcional a una función de recorrido para el recolector de basura. "
"Esto solo se utiliza si se establece el bit de la bandera :const:"
"`Py_TPFLAGS_HAVE_GC`. La firma es::"

#: ../../c-api/typeobj.rst:1300 ../../c-api/typeobj.rst:1421
msgid ""
"More information about Python's garbage collection scheme can be found in "
"section :ref:`supporting-cycle-detection`."
msgstr ""
"Más información sobre el esquema de recolección de basura de Python se puede "
"encontrar en la sección :ref:`supporting-cycle-detection`."

#: ../../c-api/typeobj.rst:1303
msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` pointer is used by the garbage "
"collector to detect reference cycles. A typical implementation of a :c:"
"member:`~PyTypeObject.tp_traverse` function simply calls :c:func:`Py_VISIT` "
"on each of the instance's members that are Python objects that the instance "
"owns. For example, this is function :c:func:`local_traverse` from the :mod:"
"`_thread` extension module::"
msgstr ""
"El puntero :c:member:`~PyTypeObject.tp_traverse` se utiliza por el "
"recolector de basura para detectar ciclos de referencia. Una implementación "
"típica de una función :c:member:`~PyTypeObject.tp_traverse` simplemente "
"llama a :c:func:`Py_VISIT` en cada uno de los miembros de la instancia que "
"son objetos de Python que la instancia posee. Por ejemplo, esta es la "
"función :c:func:`local_traverse` del módulo de extensión :mod:`_thread`::"

#: ../../c-api/typeobj.rst:1318
msgid ""
"Note that :c:func:`Py_VISIT` is called only on those members that can "
"participate in reference cycles.  Although there is also a ``self->key`` "
"member, it can only be ``NULL`` or a Python string and therefore cannot be "
"part of a reference cycle."
msgstr ""
"Tener en cuenta que :c:func:`Py_VISIT` solo se llama en aquellos miembros "
"que pueden participar en ciclos de referencia. Aunque también hay un miembro "
"``self->key``, solo puede ser ``NULL`` o una cadena de Python y, por lo "
"tanto, no puede formar parte de un ciclo de referencia."

#: ../../c-api/typeobj.rst:1322
msgid ""
"On the other hand, even if you know a member can never be part of a cycle, "
"as a debugging aid you may want to visit it anyway just so the :mod:`gc` "
"module's :func:`~gc.get_referents` function will include it."
msgstr ""
"Por otro lado, incluso si sabes que un miembro nunca puede formar parte de "
"un ciclo, como ayuda para depurar, es posible que desees visitarlo de todos "
"modos para que la función :func:`~gc.get_referents` del módulo :mod:`gc` lo "
"incluya."

#: ../../c-api/typeobj.rst:1327
msgid ""
"When implementing :c:member:`~PyTypeObject.tp_traverse`, only the members "
"that the instance *owns* (by having :term:`strong references <strong "
"reference>` to them) must be visited. For instance, if an object supports "
"weak references via the :c:member:`~PyTypeObject.tp_weaklist` slot, the "
"pointer supporting the linked list (what *tp_weaklist* points to) must "
"**not** be visited as the instance does not directly own the weak references "
"to itself (the weakreference list is there to support the weak reference "
"machinery, but the instance has no strong reference to the elements inside "
"it, as they are allowed to be removed even if the instance is still alive)."
msgstr ""
"Cuando se implementa :c:member:`~PyTypeObject.tp_traverse`, sólo los "
"miembros que la instancia *owns* (teniendo :term:`strong references <strong "
"reference>` a ellos) se deben visitar. Por ejemplo, si un objeto soporta "
"referencias débiles a través de la ranura :c:member:`~PyTypeObject."
"tp_weaklist`, el puntero que soporta la lista enlazada (a lo que "
"*tp_weaklist* apunta) no se debe visitar, ya que la instancia no posee "
"directamente las referencias débiles a sí misma (la lista de referencias "
"débiles está ahí para soportar la maquinaria de referencias débiles, pero la "
"instancia no tiene referencias fuertes a los elementos dentro de ella, ya "
"que se les permite ser eliminados incluso si la instancia sigue viva)."

#: ../../c-api/typeobj.rst:1338
msgid ""
"Note that :c:func:`Py_VISIT` requires the *visit* and *arg* parameters to :c:"
"func:`local_traverse` to have these specific names; don't name them just "
"anything."
msgstr ""
"Tener en cuenta que :c:func:`Py_VISIT` requiere que los parámetros *visit* y "
"*arg* de :c:func:`local_traverse` tengan estos nombres específicos; no los "
"nombre simplemente como cualquier cosa."

#: ../../c-api/typeobj.rst:1342
msgid ""
"Instances of :ref:`heap-allocated types <heap-types>` hold a reference to "
"their type. Their traversal function must therefore either visit :c:func:"
"`Py_TYPE(self) <Py_TYPE>`, or delegate this responsibility by calling "
"``tp_traverse`` of another heap-allocated type (such as a heap-allocated "
"superclass). If they do not, the type object may not be garbage-collected."
msgstr ""
"Las instancias de :ref:`heap-allocated types <heap-types>` contienen una "
"referencia a su tipo. Por lo tanto, su función transversal debe visitar :c:"
"func:`Py_TYPE(self) <Py_TYPE>`, o delegar esta responsabilidad llamando a "
"``tp_traverse`` de otro tipo heap-allocated (como una superclase heap-"
"allocated). Si no lo hacen, el objeto de tipo puede no ser recolectado."

#: ../../c-api/typeobj.rst:1351
msgid ""
"Heap-allocated types are expected to visit ``Py_TYPE(self)`` in "
"``tp_traverse``.  In earlier versions of Python, due to `bug 40217 <https://"
"bugs.python.org/issue40217>`_, doing this may lead to crashes in subclasses."
msgstr ""
"Los tipos asignados en el montón se espera que visiten ``Py_TYPE(self)`` en "
"``tp_traverse``. En versiones anteriores de Python, debido a `bug 40217 "
"<https://bugs.python.org/issue40217>`_, hacer esto puede provocar fallos en "
"las subclases."

#: ../../c-api/typeobj.rst:1360
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_clear` and the :const:`Py_TPFLAGS_HAVE_GC` flag bit: the flag bit, :c:"
"member:`~PyTypeObject.tp_traverse`, and :c:member:`~PyTypeObject.tp_clear` "
"are all inherited from the base type if they are all zero in the subtype."
msgstr ""
"Este campo es heredado por los subtipos junto con :c:member:`~PyTypeObject."
"tp_clear` y el bit de bandera :const:`Py_TPFLAGS_HAVE_GC`: el bit de "
"bandera, :c:member:`~PyTypeObject.tp_traverse`, y :c:member:`~PyTypeObject."
"tp_clear` son heredados del tipo base si son todos cero en el subtipo."

#: ../../c-api/typeobj.rst:1368
msgid ""
"An optional pointer to a clear function for the garbage collector. This is "
"only used if the :const:`Py_TPFLAGS_HAVE_GC` flag bit is set.  The signature "
"is::"
msgstr ""
"Un puntero opcional a una función de borrado para el recolector de basura. "
"Sólo se utiliza si el bit :const:`Py_TPFLAGS_HAVE_GC` está activado.  La "
"firma es::"

#: ../../c-api/typeobj.rst:1373
msgid ""
"The :c:member:`~PyTypeObject.tp_clear` member function is used to break "
"reference cycles in cyclic garbage detected by the garbage collector.  Taken "
"together, all :c:member:`~PyTypeObject.tp_clear` functions in the system "
"must combine to break all reference cycles.  This is subtle, and if in any "
"doubt supply a :c:member:`~PyTypeObject.tp_clear` function.  For example, "
"the tuple type does not implement a :c:member:`~PyTypeObject.tp_clear` "
"function, because it's possible to prove that no reference cycle can be "
"composed entirely of tuples. Therefore the :c:member:`~PyTypeObject."
"tp_clear` functions of other types must be sufficient to break any cycle "
"containing a tuple.  This isn't immediately obvious, and there's rarely a "
"good reason to avoid implementing :c:member:`~PyTypeObject.tp_clear`."
msgstr ""
"La función miembro :c:member:`~PyTypeObject.tp_clear` se utiliza para romper "
"ciclos de referencia en la basura cíclica detectada por el recolector de "
"basura.  En conjunto, todas las funciones :c:member:`~PyTypeObject.tp_clear` "
"del sistema deben combinarse para romper todos los ciclos de referencia.  "
"Esto es sutil, y en caso de duda suministre una función :c:member:"
"`~PyTypeObject.tp_clear`.  Por ejemplo, el tipo tupla no implementa una "
"función :c:member:`~PyTypeObject.tp_clear`, porque es posible demostrar que "
"ningún ciclo de referencia puede estar compuesto enteramente por tuplas. Por "
"lo tanto, las funciones :c:member:`~PyTypeObject.tp_clear` de otros tipos "
"deben ser suficientes para romper cualquier ciclo que contenga una tupla.  "
"Esto no es inmediatamente obvio, y raramente hay una buena razón para evitar "
"implementar :c:member:`~PyTypeObject.tp_clear`."

#: ../../c-api/typeobj.rst:1383
msgid ""
"Implementations of :c:member:`~PyTypeObject.tp_clear` should drop the "
"instance's references to those of its members that may be Python objects, "
"and set its pointers to those members to ``NULL``, as in the following "
"example::"
msgstr ""
"Implementaciones de :c:member:`~PyTypeObject.tp_clear` deben eliminar las "
"referencias de la instancia a aquellos de sus miembros que puedan ser "
"objetos de Python, y establecer los punteros a esos miembros a ``NULL``, "
"como en el siguiente ejemplo::"

#: ../../c-api/typeobj.rst:1397
msgid ""
"The :c:func:`Py_CLEAR` macro should be used, because clearing references is "
"delicate:  the reference to the contained object must not be released (via :"
"c:func:`Py_DECREF`) until after the pointer to the contained object is set "
"to ``NULL``.  This is because releasing the reference may cause the "
"contained object to become trash, triggering a chain of reclamation activity "
"that may include invoking arbitrary Python code (due to finalizers, or "
"weakref callbacks, associated with the contained object). If it's possible "
"for such code to reference *self* again, it's important that the pointer to "
"the contained object be ``NULL`` at that time, so that *self* knows the "
"contained object can no longer be used.  The :c:func:`Py_CLEAR` macro "
"performs the operations in a safe order."
msgstr ""
"Debería usarse la macro :c:func:`Py_CLEAR`, porque limpiar referencias es "
"delicado: la referencia al objeto contenido no debe ser liberada (vía :c:"
"func:`Py_DECREF`) hasta después de que el puntero al objeto contenido sea "
"puesto a ``NULL``. Esto es porque liberar la referencia puede causar que el "
"objeto contenido se convierta en basura, desencadenando una cadena de "
"actividad de reclamación que puede incluir la invocación de código Python "
"arbitrario (debido a finalizadores, o callbacks weakref, asociados con el "
"objeto contenido). Si es posible que dicho código haga referencia a *self* "
"de nuevo, es importante que el puntero al objeto contenido sea ``NULL`` en "
"ese momento, para que *self* sepa que el objeto contenido ya no puede ser "
"usado.  La macro :c:func:`Py_CLEAR` realiza las operaciones en un orden "
"seguro."

#: ../../c-api/typeobj.rst:1409
msgid ""
"Note that :c:member:`~PyTypeObject.tp_clear` is not *always* called before "
"an instance is deallocated. For example, when reference counting is enough "
"to determine that an object is no longer used, the cyclic garbage collector "
"is not involved and :c:member:`~PyTypeObject.tp_dealloc` is called directly."
msgstr ""
"Tener en cuenta que :c:member:`~PyTypeObject.tp_clear` no siempre se llama "
"*siempre* antes de que se desasigne una instancia. Por ejemplo, cuando el "
"recuento de referencias es suficiente para determinar que un objeto ya no se "
"utiliza, el recolector de basura cíclico no está involucrado y se llama "
"directamente a :c:member:`~PyTypeObject.tp_dealloc`."

#: ../../c-api/typeobj.rst:1415
msgid ""
"Because the goal of :c:member:`~PyTypeObject.tp_clear` functions is to break "
"reference cycles, it's not necessary to clear contained objects like Python "
"strings or Python integers, which can't participate in reference cycles. On "
"the other hand, it may be convenient to clear all contained Python objects, "
"and write the type's :c:member:`~PyTypeObject.tp_dealloc` function to "
"invoke :c:member:`~PyTypeObject.tp_clear`."
msgstr ""
"Dado que el objetivo de las funciones :c:member:`~PyTypeObject.tp_clear` es "
"romper los ciclos de referencia, no es necesario borrar los objetos "
"contenidos como cadenas Python o enteros Python, que no pueden participar en "
"ciclos de referencia. Por otro lado, puede ser conveniente borrar todos los "
"objetos Python contenidos, y escribir la función :c:member:`~PyTypeObject."
"tp_dealloc` del tipo para invocar a :c:member:`~PyTypeObject.tp_clear`."

#: ../../c-api/typeobj.rst:1428
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_traverse` and the :const:`Py_TPFLAGS_HAVE_GC` flag bit: the flag bit, :c:"
"member:`~PyTypeObject.tp_traverse`, and :c:member:`~PyTypeObject.tp_clear` "
"are all inherited from the base type if they are all zero in the subtype."
msgstr ""
"Este campo se hereda junto con :c:member:`~PyTypeObject.tp_traverse` y el "
"bit de la bandera :const:`Py_TPFLAGS_HAVE_GC`: el bit de la bandera, :c:"
"member:`~PyTypeObject.tp_traverse` y :c:member:`~PyTypeObject.tp_clear` se "
"heredan todos del tipo base si todos son cero en el subtipo."

#: ../../c-api/typeobj.rst:1436
msgid ""
"An optional pointer to the rich comparison function, whose signature is::"
msgstr ""
"Un puntero opcional a la función de comparación enriquecida, cuya firma es::"

#: ../../c-api/typeobj.rst:1440
msgid ""
"The first parameter is guaranteed to be an instance of the type that is "
"defined by :c:type:`PyTypeObject`."
msgstr ""
"Se garantiza que el primer parámetro es una instancia del tipo definido por :"
"c:type:`PyTypeObject`."

#: ../../c-api/typeobj.rst:1443
msgid ""
"The function should return the result of the comparison (usually ``Py_True`` "
"or ``Py_False``).  If the comparison is undefined, it must return "
"``Py_NotImplemented``, if another error occurred it must return ``NULL`` and "
"set an exception condition."
msgstr ""
"La función debe devolver el resultado de la comparación (normalmente "
"``Py_True`` o ``Py_False``).  Si la comparación es indefinida, debe devolver "
"``Py_NotImplemented``, si se ha producido otro error debe devolver ``NULL`` "
"y establecer una condición de excepción."

#: ../../c-api/typeobj.rst:1448
msgid ""
"The following constants are defined to be used as the third argument for :c:"
"member:`~PyTypeObject.tp_richcompare` and for :c:func:`PyObject_RichCompare`:"
msgstr ""
"Las siguientes constantes están definidas para utilizarse como tercer "
"argumento para :c:member:`~PyTypeObject.tp_richcompare` y para :c:func:"
"`PyObject_RichCompare`."

#: ../../c-api/typeobj.rst:1452
msgid "Constant"
msgstr "Constante"

#: ../../c-api/typeobj.rst:1452
msgid "Comparison"
msgstr "Comparación"

#: ../../c-api/typeobj.rst:1454
msgid ":const:`Py_LT`"
msgstr ":const:`Py_LT`"

#: ../../c-api/typeobj.rst:1454
msgid "``<``"
msgstr "``<``"

#: ../../c-api/typeobj.rst:1456
msgid ":const:`Py_LE`"
msgstr ":const:`Py_LE`"

#: ../../c-api/typeobj.rst:1456
msgid "``<=``"
msgstr "``<=``"

#: ../../c-api/typeobj.rst:1458
msgid ":const:`Py_EQ`"
msgstr ":const:`Py_EQ`"

#: ../../c-api/typeobj.rst:1458
msgid "``==``"
msgstr "``==``"

#: ../../c-api/typeobj.rst:1460
msgid ":const:`Py_NE`"
msgstr ":const:`Py_NE`"

#: ../../c-api/typeobj.rst:1460
msgid "``!=``"
msgstr "``!=``"

#: ../../c-api/typeobj.rst:1462
msgid ":const:`Py_GT`"
msgstr ":const:`Py_GT`"

#: ../../c-api/typeobj.rst:1462
msgid "``>``"
msgstr "``>``"

#: ../../c-api/typeobj.rst:1464
msgid ":const:`Py_GE`"
msgstr ":const:`Py_GE`"

#: ../../c-api/typeobj.rst:1464
msgid "``>=``"
msgstr "``>=``"

#: ../../c-api/typeobj.rst:1467
msgid ""
"The following macro is defined to ease writing rich comparison functions:"
msgstr ""
"La siguiente macro está definida para facilitar la escritura de funciones de "
"comparación ricas."

#: ../../c-api/typeobj.rst:1471
msgid ""
"Return ``Py_True`` or ``Py_False`` from the function, depending on the "
"result of a comparison. VAL_A and VAL_B must be orderable by C comparison "
"operators (for example, they may be C ints or floats). The third argument "
"specifies the requested operation, as for :c:func:`PyObject_RichCompare`."
msgstr ""
"Devuelve ``Py_True`` o ``Py_False`` de la función, dependiendo del resultado "
"de una comparación. VAL_A y VAL_B deben ser ordenables por operadores de "
"comparación de C (por ejemplo, pueden ser ints o floats de C). El tercer "
"argumento especifica la operación solicitada, como para :c:func:"
"`PyObject_RichCompare`."

#: ../../c-api/typeobj.rst:1477
msgid "The returned value is a new :term:`strong reference`."
msgstr "El valor devuelto es una nueva :term:`strong reference`."

#: ../../c-api/typeobj.rst:1479
msgid "On error, sets an exception and returns ``NULL`` from the function."
msgstr ""
"En caso de error, establece una excepción y devuelve ``NULL`` de la función."

#: ../../c-api/typeobj.rst:1487
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_hash`: a subtype inherits :c:member:`~PyTypeObject.tp_richcompare` and :c:"
"member:`~PyTypeObject.tp_hash` when the subtype's :c:member:`~PyTypeObject."
"tp_richcompare` and :c:member:`~PyTypeObject.tp_hash` are both ``NULL``."
msgstr ""
"Este campo es heredado por los subtipos junto con :c:member:`~PyTypeObject."
"tp_hash`: un subtipo hereda :c:member:`~PyTypeObject.tp_richcompare` y :c:"
"member:`~PyTypeObject.tp_hash` cuando :c:member:`~PyTypeObject."
"tp_richcompare` y :c:member:`~PyTypeObject.tp_hash` del subtipo son ambos "
"``NULL``."

#: ../../c-api/typeobj.rst:1494
msgid ""
":c:type:`PyBaseObject_Type` provides a :attr:`tp_richcompare` "
"implementation, which may be inherited.  However, if only :attr:`tp_hash` is "
"defined, not even the inherited function is used and instances of the type "
"will not be able to participate in any comparisons."
msgstr ""
":c:type:`PyBaseObject_Type` proporciona una implementación de :attr:"
"`tp_richcompare`, que puede ser heredada.  Sin embargo, si sólo se define :"
"attr:`tp_hash`, ni siquiera se utiliza la función heredada y las instancias "
"del tipo no podrán participar en ninguna comparación."

#: ../../c-api/typeobj.rst:1503
msgid ""
"If the instances of this type are weakly referenceable, this field is "
"greater than zero and contains the offset in the instance structure of the "
"weak reference list head (ignoring the GC header, if present); this offset "
"is used by :c:func:`PyObject_ClearWeakRefs` and the ``PyWeakref_*`` "
"functions.  The instance structure needs to include a field of type :c:expr:"
"`PyObject*` which is initialized to ``NULL``."
msgstr ""
"Si las instancias de este tipo son débilmente referenciables, este campo es "
"mayor que cero y contiene el desplazamiento en la estructura de instancia de "
"la cabecera de la lista de referencia débil (ignorando la cabecera GC, si "
"está presente); este desplazamiento es utilizado por :c:func:"
"`PyObject_ClearWeakRefs` y las funciones ``PyWeakref_*``.  La estructura de "
"instancia debe incluir un campo de tipo :c:expr:`PyObject*` que se "
"inicializa en ``NULL``."

#: ../../c-api/typeobj.rst:1510
msgid ""
"Do not confuse this field with :c:member:`~PyTypeObject.tp_weaklist`; that "
"is the list head for weak references to the type object itself."
msgstr ""
"No confundir este campo con :c:member:`~PyTypeObject.tp_weaklist`; que es la "
"cabecera de la lista para referencias débiles al propio objeto de tipo."

#: ../../c-api/typeobj.rst:1515
msgid ""
"This field is inherited by subtypes, but see the rules listed below. A "
"subtype may override this offset; this means that the subtype uses a "
"different weak reference list head than the base type.  Since the list head "
"is always found via :c:member:`~PyTypeObject.tp_weaklistoffset`, this should "
"not be a problem."
msgstr ""
"Este campo es heredado por los subtipos, pero véanse las reglas indicadas a "
"continuación. Un subtipo puede anular este desplazamiento; esto significa "
"que el subtipo utiliza un encabezado de lista de referencia débil diferente "
"al del tipo base.  Dado que la cabeza de lista siempre se encuentra a través "
"de :c:member:`~PyTypeObject.tp_weaklistoffset`, esto no debería ser un "
"problema."

#: ../../c-api/typeobj.rst:1520
msgid ""
"When a type defined by a class statement has no :attr:`~object.__slots__` "
"declaration, and none of its base types are weakly referenceable, the type "
"is made weakly referenceable by adding a weak reference list head slot to "
"the instance layout and setting the :c:member:`~PyTypeObject."
"tp_weaklistoffset` of that slot's offset."
msgstr ""
"Cuando un tipo definido por una declaración de clase no tiene declaración :"
"attr:`~object.__slots__`, y ninguno de sus tipos base es débilmente "
"referenciable, el tipo se hace débilmente referenciable añadiendo una ranura "
"de cabecera de lista de referencias débiles al diseño de instancia y "
"estableciendo el :c:member:`~PyTypeObject.tp_weaklistoffset` del offset de "
"esa ranura."

#: ../../c-api/typeobj.rst:1525
msgid ""
"When a type's :attr:`__slots__` declaration contains a slot named :attr:"
"`__weakref__`, that slot becomes the weak reference list head for instances "
"of the type, and the slot's offset is stored in the type's :c:member:"
"`~PyTypeObject.tp_weaklistoffset`."
msgstr ""
"Cuando la declaración :attr:`__slots__` de un tipo contiene una ranura "
"denominada :attr:`__weakref__`, dicha ranura se convierte en la cabecera de "
"la lista de referencias débiles para las instancias del tipo, y el "
"desplazamiento de la ranura se almacena en :c:member:`~PyTypeObject."
"tp_weaklistoffset` del tipo."

#: ../../c-api/typeobj.rst:1530
msgid ""
"When a type's :attr:`__slots__` declaration does not contain a slot named :"
"attr:`__weakref__`, the type inherits its :c:member:`~PyTypeObject."
"tp_weaklistoffset` from its base type."
msgstr ""
"Cuando la declaración :attr:`__slots__` de un tipo no contiene una ranura "
"denominada :attr:`__weakref__`, el tipo hereda su :c:member:`~PyTypeObject."
"tp_weaklistoffset` de su tipo base."

#: ../../c-api/typeobj.rst:1537
msgid ""
"An optional pointer to a function that returns an :term:`iterator` for the "
"object.  Its presence normally signals that the instances of this type are :"
"term:`iterable` (although sequences may be iterable without this function)."
msgstr ""
"Un puntero opcional a una función que devuelve un :term:`iterator` para el "
"objeto.  Su presencia normalmente indica que las instancias de este tipo "
"son :term:`iterables` (aunque las secuencias pueden ser iterables sin esta "
"función)."

#: ../../c-api/typeobj.rst:1541
msgid "This function has the same signature as :c:func:`PyObject_GetIter`::"
msgstr "Esta función tiene la misma firma que :c:func:`PyObject_GetIter`::."

#: ../../c-api/typeobj.rst:1552
msgid ""
"An optional pointer to a function that returns the next item in an :term:"
"`iterator`. The signature is::"
msgstr ""
"Un puntero opcional a una función que devuelve el siguiente elemento de un :"
"term:`iterator`. La firma es::"

#: ../../c-api/typeobj.rst:1557
msgid ""
"When the iterator is exhausted, it must return ``NULL``; a :exc:"
"`StopIteration` exception may or may not be set.  When another error occurs, "
"it must return ``NULL`` too.  Its presence signals that the instances of "
"this type are iterators."
msgstr ""
"Cuando el iterador se agota, debe devolver ``NULL``; se puede establecer o "
"no una excepción :exc:`StopIteration`.  Cuando se produce otro error, "
"también debe devolver ``NULL``.  Su presencia señala que las instancias de "
"este tipo son iteradores."

#: ../../c-api/typeobj.rst:1562
msgid ""
"Iterator types should also define the :c:member:`~PyTypeObject.tp_iter` "
"function, and that function should return the iterator instance itself (not "
"a new iterator instance)."
msgstr ""
"Los tipos de iterador también deben definir la función :c:member:"
"`~PyTypeObject.tp_iter`, y esa función debe devolver la propia instancia del "
"iterador (no una nueva instancia del iterador)."

#: ../../c-api/typeobj.rst:1566
msgid "This function has the same signature as :c:func:`PyIter_Next`."
msgstr "Esta función tiene la misma firma que :c:func:`PyIter_Next`."

#: ../../c-api/typeobj.rst:1575
msgid ""
"An optional pointer to a static ``NULL``-terminated array of :c:type:"
"`PyMethodDef` structures, declaring regular methods of this type."
msgstr ""
"Un puntero opcional a un array estático terminado en ``NULL`` de "
"estructuras :c:type:`PyMethodDef`, que declara métodos regulares de este "
"tipo."

#: ../../c-api/typeobj.rst:1578
msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a method descriptor."
msgstr ""
"Para cada entrada en el array, se añade una entrada al diccionario del tipo "
"(ver :c:member:`~PyTypeObject.tp_dict` abajo) que contiene un descriptor de "
"método."

#: ../../c-api/typeobj.rst:1583
msgid ""
"This field is not inherited by subtypes (methods are inherited through a "
"different mechanism)."
msgstr ""
"Este campo no se hereda por los subtipos (los métodos se heredan a través de "
"un mecanismo diferente)."

#: ../../c-api/typeobj.rst:1589
msgid ""
"An optional pointer to a static ``NULL``-terminated array of :c:type:"
"`PyMemberDef` structures, declaring regular data members (fields or slots) "
"of instances of this type."
msgstr ""
"Un puntero opcional a una matriz estática terminada en ``NULL`` de "
"estructuras :c:type:`PyMemberDef`, que declara miembros de datos regulares "
"(campos o ranuras) de instancias de este tipo."

#: ../../c-api/typeobj.rst:1593
msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a member descriptor."
msgstr ""
"Para cada entrada de la matriz, se añade una entrada al diccionario del tipo "
"(ver :c:member:`~PyTypeObject.tp_dict` más abajo) que contiene un descriptor "
"de miembro."

#: ../../c-api/typeobj.rst:1598
msgid ""
"This field is not inherited by subtypes (members are inherited through a "
"different mechanism)."
msgstr ""
"Este campo no se hereda por los subtipos (los miembros se heredan a través "
"de un mecanismo diferente)."

#: ../../c-api/typeobj.rst:1604
msgid ""
"An optional pointer to a static ``NULL``-terminated array of :c:type:"
"`PyGetSetDef` structures, declaring computed attributes of instances of this "
"type."
msgstr ""
"Un puntero opcional a una matriz estática ``NULL``-terminada de estructuras :"
"c:type:`PyGetSetDef`, declarando atributos computados de instancias de este "
"tipo."

#: ../../c-api/typeobj.rst:1607
msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a getset descriptor."
msgstr ""
"Para cada entrada de la matriz, se añade una entrada al diccionario del tipo "
"(ver :c:member:`~PyTypeObject.tp_dict` más abajo) que contiene un descriptor "
"getset."

#: ../../c-api/typeobj.rst:1612
msgid ""
"This field is not inherited by subtypes (computed attributes are inherited "
"through a different mechanism)."
msgstr ""
"Este campo no se hereda por los subtipos (los atributos calculados se "
"heredan a través de un mecanismo diferente)."

#: ../../c-api/typeobj.rst:1618
msgid ""
"An optional pointer to a base type from which type properties are "
"inherited.  At this level, only single inheritance is supported; multiple "
"inheritance require dynamically creating a type object by calling the "
"metatype."
msgstr ""
"Un puntero opcional a un tipo base del cual se heredan las propiedades del "
"tipo. A este nivel, solo se admite la herencia simple; la herencia múltiple "
"requiere crear dinámicamente un objeto de tipo llamando al metatipo."

#: ../../c-api/typeobj.rst:1626
msgid ""
"Slot initialization is subject to the rules of initializing globals. C99 "
"requires the initializers to be \"address constants\".  Function designators "
"like :c:func:`PyType_GenericNew`, with implicit conversion to a pointer, are "
"valid C99 address constants."
msgstr ""
"La inicialización de ranuras está sujeta a las reglas de inicialización de "
"globales. C99 requiere que los inicializadores sean \"constantes de "
"dirección\". Los designadores de funciones como :c:func:`PyType_GenericNew`, "
"con conversión implícita a un puntero, son constantes de dirección válidas "
"en C99."

#: ../../c-api/typeobj.rst:1631
msgid ""
"However, the unary '&' operator applied to a non-static variable like :c:"
"func:`PyBaseObject_Type` is not required to produce an address constant.  "
"Compilers may support this (gcc does), MSVC does not. Both compilers are "
"strictly standard conforming in this particular behavior."
msgstr ""
"Sin embargo, el operador unario '&amp;' aplicado a una variable no estática "
"como :c:func:`PyBaseObject_Type` no es necesario para producir una constante "
"de dirección.  Los compiladores pueden soportar esto (gcc lo hace), MSVC no. "
"Ambos compiladores cumplen estrictamente la norma en este comportamiento "
"concreto."

#: ../../c-api/typeobj.rst:1637
msgid ""
"Consequently, :c:member:`~PyTypeObject.tp_base` should be set in the "
"extension module's init function."
msgstr ""
"En consecuencia, :c:member:`~PyTypeObject.tp_base` debe establecerse en la "
"función init del módulo de extensión."

#: ../../c-api/typeobj.rst:1642
msgid "This field is not inherited by subtypes (obviously)."
msgstr "Este campo no lo heredan los subtipos (evidentemente)."

#: ../../c-api/typeobj.rst:1646
msgid ""
"This field defaults to ``&PyBaseObject_Type`` (which to Python programmers "
"is known as the type :class:`object`)."
msgstr ""
"Este campo se establece por defecto en ``&PyBaseObject_Type`` (que para los "
"programadores de Python es conocido como el tipo :class:`object`)."

#: ../../c-api/typeobj.rst:1652
msgid "The type's dictionary is stored here by :c:func:`PyType_Ready`."
msgstr "El diccionario del tipo se almacena aquí por :c:func:`PyType_Ready`."

#: ../../c-api/typeobj.rst:1654
msgid ""
"This field should normally be initialized to ``NULL`` before PyType_Ready is "
"called; it may also be initialized to a dictionary containing initial "
"attributes for the type.  Once :c:func:`PyType_Ready` has initialized the "
"type, extra attributes for the type may be added to this dictionary only if "
"they don't correspond to overloaded operations (like :meth:`__add__`)."
msgstr ""
"Este campo debería inicializarse normalmente como ``NULL`` antes de llamar a "
"PyType_Ready; también se puede inicializar como un diccionario que contenga "
"atributos iniciales para el tipo. Una vez que :c:func:`PyType_Ready` haya "
"inicializado el tipo, se pueden agregar atributos adicionales para el tipo a "
"este diccionario solo si no corresponden a operaciones sobrecargadas (como :"
"meth:`__add__`)."

#: ../../c-api/typeobj.rst:1662
msgid ""
"This field is not inherited by subtypes (though the attributes defined in "
"here are inherited through a different mechanism)."
msgstr ""
"Este campo no lo heredan los subtipos (aunque los atributos aquí definidos "
"se heredan a través de un mecanismo diferente)."

#: ../../c-api/typeobj.rst:1667
msgid ""
"If this field is ``NULL``, :c:func:`PyType_Ready` will assign a new "
"dictionary to it."
msgstr ""
"Si este campo es ``NULL``, :c:func:`PyType_Ready` le asignará un nuevo "
"diccionario."

#: ../../c-api/typeobj.rst:1672
msgid ""
"It is not safe to use :c:func:`PyDict_SetItem` on or otherwise modify :c:"
"member:`~PyTypeObject.tp_dict` with the dictionary C-API."
msgstr ""
"No es seguro utilizar :c:func:`PyDict_SetItem` o modificar de otra manera :c:"
"member:`~PyTypeObject.tp_dict` con la API de diccionario en C."

#: ../../c-api/typeobj.rst:1678
msgid "An optional pointer to a \"descriptor get\" function."
msgstr "Un puntero opcional a una función \"descriptor get\"."

#: ../../c-api/typeobj.rst:1680 ../../c-api/typeobj.rst:1696
#: ../../c-api/typeobj.rst:1778 ../../c-api/typeobj.rst:1808
#: ../../c-api/typeobj.rst:1832
msgid "The function signature is::"
msgstr "La firma de la función es::"

#: ../../c-api/typeobj.rst:1693
msgid ""
"An optional pointer to a function for setting and deleting a descriptor's "
"value."
msgstr ""
"Un puntero opcional a una función para establecer y eliminar el valor de un "
"descriptor."

#: ../../c-api/typeobj.rst:1700
msgid "The *value* argument is set to ``NULL`` to delete the value."
msgstr ""
"El argumento *value* se establece como ``NULL`` para eliminar el valor."

#: ../../c-api/typeobj.rst:1711
msgid ""
"If the instances of this type have a dictionary containing instance "
"variables, this field is non-zero and contains the offset in the instances "
"of the type of the instance variable dictionary; this offset is used by :c:"
"func:`PyObject_GenericGetAttr`."
msgstr ""
"Si las instancias de este tipo tienen un diccionario que contiene variables "
"de instancia, este campo es distinto de cero y contiene el desplazamiento en "
"las instancias del tipo del diccionario de variables de instancia; este "
"desplazamiento lo utiliza  :c:func:`PyObject_GenericGetAttr`."

#: ../../c-api/typeobj.rst:1716
msgid ""
"Do not confuse this field with :c:member:`~PyTypeObject.tp_dict`; that is "
"the dictionary for attributes of the type object itself."
msgstr ""
"No confundir este campo con :c:member:`~PyTypeObject.tp_dict`; ese es el "
"diccionario para atributos del propio objeto de tipo."

#: ../../c-api/typeobj.rst:1719
msgid ""
"If the value of this field is greater than zero, it specifies the offset "
"from the start of the instance structure.  If the value is less than zero, "
"it specifies the offset from the *end* of the instance structure.  A "
"negative offset is more expensive to use, and should only be used when the "
"instance structure contains a variable-length part.  This is used for "
"example to add an instance variable dictionary to subtypes of :class:`str` "
"or :class:`tuple`. Note that the :c:member:`~PyTypeObject.tp_basicsize` "
"field should account for the dictionary added to the end in that case, even "
"though the dictionary is not included in the basic object layout.  On a "
"system with a pointer size of 4 bytes, :c:member:`~PyTypeObject."
"tp_dictoffset` should be set to ``-4`` to indicate that the dictionary is at "
"the very end of the structure."
msgstr ""
"Si el valor de este campo es mayor que cero, especifica el desplazamiento "
"desde el inicio de la estructura de la instancia. Si el valor es menor que "
"cero, especifica el desplazamiento desde el *final* de la estructura de la "
"instancia. Un desplazamiento negativo es más costoso de usar y solo debe "
"usarse cuando la estructura de la instancia contiene una parte de longitud "
"variable. Esto se utiliza, por ejemplo, para agregar un diccionario de "
"variables de instancia a subtipos de :class:`str` o :class:`tuple`. Hay que "
"considerar que el campo :c:member:`~PyTypeObject.tp_basicsize` debe tener en "
"cuenta el diccionario agregado al final en ese caso, aunque el diccionario "
"no esté incluido en el diseño básico del objeto. En un sistema con un tamaño "
"de puntero de 4 bytes, :c:member:`~PyTypeObject.tp_dictoffset` debe "
"establecerse en ``-4`` para indicar que el diccionario está al final de la "
"estructura."

#: ../../c-api/typeobj.rst:1731
msgid ""
"The real dictionary offset in an instance can be computed from a negative :c:"
"member:`~PyTypeObject.tp_dictoffset` as follows::"
msgstr ""
"El desplazamiento real del diccionario en una instancia se puede calcular a "
"partir de un :c:member:`~PyTypeObject.tp_dictoffset` negativo de la "
"siguiente manera::"

#: ../../c-api/typeobj.rst:1738
msgid ""
"where :c:member:`~PyTypeObject.tp_basicsize`, :c:member:`~PyTypeObject."
"tp_itemsize` and :c:member:`~PyTypeObject.tp_dictoffset` are taken from the "
"type object, and :attr:`ob_size` is taken from the instance.  The absolute "
"value is taken because ints use the sign of :attr:`ob_size` to store the "
"sign of the number.  (There's never a need to do this calculation yourself; "
"it is done for you by :c:func:`_PyObject_GetDictPtr`.)"
msgstr ""
"donde :c:member:`~PyTypeObject.tp_basicsize`, :c:member:`~PyTypeObject."
"tp_itemsize` y :c:member:`~PyTypeObject.tp_dictoffset` se toman del objeto "
"de tipo, y :attr:`ob_size` se toma de la instancia. Se toma el valor "
"absoluto porque los enteros usan el signo de :attr:`ob_size` para almacenar "
"el signo del número. (No hay necesidad de hacer el cálculo por uno mismo; se "
"hace mediante :c:func:`_PyObject_GetDictPtr`)."

#: ../../c-api/typeobj.rst:1746
msgid ""
"This field is inherited by subtypes, but see the rules listed below. A "
"subtype may override this offset; this means that the subtype instances "
"store the dictionary at a difference offset than the base type.  Since the "
"dictionary is always found via :c:member:`~PyTypeObject.tp_dictoffset`, this "
"should not be a problem."
msgstr ""
"Este campo lo heredan los subtipos, pero ver las reglas enumeradas a "
"continuación. Un subtipo puede anular este desplazamiento; esto significa "
"que las instancias del subtipo almacenan el diccionario en un desplazamiento "
"diferente al del tipo base. Dado que el diccionario siempre se encuentra a "
"través de :c:member:`~PyTypeObject.tp_dictoffset`, esto no debería ser un "
"problema."

#: ../../c-api/typeobj.rst:1751
msgid ""
"When a type defined by a class statement has no :attr:`~object.__slots__` "
"declaration, and none of its base types has an instance variable dictionary, "
"a dictionary slot is added to the instance layout and the :c:member:"
"`~PyTypeObject.tp_dictoffset` is set to that slot's offset."
msgstr ""
"Cuando un tipo definido por una declaración de clase no tiene una "
"declaración :attr:`~object.__slots__`, y ninguno de sus tipos base tiene un "
"diccionario de variables de instancia, se agrega una ranura de diccionario a "
"la disposición de la instancia y se establece :c:member:`~PyTypeObject."
"tp_dictoffset` en el desplazamiento de esa ranura."

#: ../../c-api/typeobj.rst:1756
msgid ""
"When a type defined by a class statement has a :attr:`__slots__` "
"declaration, the type inherits its :c:member:`~PyTypeObject.tp_dictoffset` "
"from its base type."
msgstr ""
"Cuando un tipo definido por una declaración de clase tiene una declaración :"
"attr:`__slots__`, el tipo hereda su :c:member:`~PyTypeObject.tp_dictoffset` "
"de su tipo base."

#: ../../c-api/typeobj.rst:1759
msgid ""
"(Adding a slot named :attr:`~object.__dict__` to the :attr:`__slots__` "
"declaration does not have the expected effect, it just causes confusion.  "
"Maybe this should be added as a feature just like :attr:`__weakref__` "
"though.)"
msgstr ""
"(Añadir una ranura llamada :attr:`~object.__dict__` a la declaración de :"
"attr:`__slots__` no tiene el efecto esperado, solo causa confusión. Tal vez "
"esto debería agregarse como una característica al igual que :attr:"
"`__weakref__`.)"

#: ../../c-api/typeobj.rst:1765
msgid ""
"This slot has no default.  For :ref:`static types <static-types>`, if the "
"field is ``NULL`` then no :attr:`__dict__` gets created for instances."
msgstr ""
"Este slot no tiene un valor predeterminado. Para  :ref:`static types <static-"
"types>`, si el campo es ``NULL``, entonces no se crea :attr:`__dict__` para "
"las instancias."

#: ../../c-api/typeobj.rst:1771
msgid "An optional pointer to an instance initialization function."
msgstr "Un puntero opcional a una función de inicialización de instancia."

#: ../../c-api/typeobj.rst:1773
msgid ""
"This function corresponds to the :meth:`__init__` method of classes.  Like :"
"meth:`__init__`, it is possible to create an instance without calling :meth:"
"`__init__`, and it is possible to reinitialize an instance by calling its :"
"meth:`__init__` method again."
msgstr ""
"Esta función corresponde al método :meth:`__init__` de las clases. Al igual "
"que :meth:`__init__`, es posible crear una instancia sin llamar a :meth:"
"`__init__`, y es posible reinicializar una instancia llamando de nuevo a su "
"método :meth:`__init__`."

#: ../../c-api/typeobj.rst:1782
msgid ""
"The self argument is the instance to be initialized; the *args* and *kwds* "
"arguments represent positional and keyword arguments of the call to :meth:"
"`__init__`."
msgstr ""
"El argumento self es la instancia que se va a inicializar; los argumentos "
"*args* y *kwds* representan argumentos posicionales y de palabras clave de "
"la llamada a :meth:`__init__`."

#: ../../c-api/typeobj.rst:1786
msgid ""
"The :c:member:`~PyTypeObject.tp_init` function, if not ``NULL``, is called "
"when an instance is created normally by calling its type, after the type's :"
"c:member:`~PyTypeObject.tp_new` function has returned an instance of the "
"type.  If the :c:member:`~PyTypeObject.tp_new` function returns an instance "
"of some other type that is not a subtype of the original type, no :c:member:"
"`~PyTypeObject.tp_init` function is called; if :c:member:`~PyTypeObject."
"tp_new` returns an instance of a subtype of the original type, the "
"subtype's :c:member:`~PyTypeObject.tp_init` is called."
msgstr ""
"La función :c:member:`~PyTypeObject.tp_init`, si no es ``NULL``, se llama "
"cuando se crea una instancia normalmente llamando a su tipo, después de que "
"la función :c:member:`~PyTypeObject.tp_new` del tipo haya devuelto una "
"instancia del tipo. Si la función :c:member:`~PyTypeObject.tp_new` devuelve "
"una instancia de algún otro tipo que no sea un subtipo del tipo original, no "
"se llama a la función :c:member:`~PyTypeObject.tp_init`; si :c:member:"
"`~PyTypeObject.tp_new` devuelve una instancia de un subtipo del tipo "
"original, se llama a :c:member:`~PyTypeObject.tp_init` del subtipo."

#: ../../c-api/typeobj.rst:1793
msgid "Returns ``0`` on success, ``-1`` and sets an exception on error."
msgstr ""
"Devuelve ``0`` en caso de éxito, ``-1`` y establece una excepción en caso de "
"error."

#: ../../c-api/typeobj.rst:1801
msgid ""
"For :ref:`static types <static-types>` this field does not have a default."
msgstr ""
"Para los tipos :ref:`static <static-types>` este campo no tiene valor por "
"defecto."

#: ../../c-api/typeobj.rst:1806
msgid "An optional pointer to an instance allocation function."
msgstr "Un puntero opcional a una función de asignación de instancias."

#: ../../c-api/typeobj.rst:1814
msgid ""
"This field is inherited by static subtypes, but not by dynamic subtypes "
"(subtypes created by a class statement)."
msgstr ""
"Este campo es heredado por subtipos estáticos, pero no por subtipos "
"dinámicos (subtipos creados por una declaración de clase)."

#: ../../c-api/typeobj.rst:1819
msgid ""
"For dynamic subtypes, this field is always set to :c:func:"
"`PyType_GenericAlloc`, to force a standard heap allocation strategy."
msgstr ""
"Para subtipos dinámicos, este campo siempre se establece en :c:func:"
"`PyType_GenericAlloc`, para forzar una estrategia de asignación de montón "
"estándar."

#: ../../c-api/typeobj.rst:1823
msgid ""
"For static subtypes, :c:type:`PyBaseObject_Type` uses :c:func:"
"`PyType_GenericAlloc`.  That is the recommended value for all statically "
"defined types."
msgstr ""
"Para subtipos estáticos, :c:type:`PyBaseObject_Type` utiliza :c:func:"
"`PyType_GenericAlloc`. Ese es el valor recomendado para todos los tipos "
"definidos estáticamente."

#: ../../c-api/typeobj.rst:1830
msgid "An optional pointer to an instance creation function."
msgstr "Un puntero opcional a una función de creación de instancias."

#: ../../c-api/typeobj.rst:1836
msgid ""
"The *subtype* argument is the type of the object being created; the *args* "
"and *kwds* arguments represent positional and keyword arguments of the call "
"to the type.  Note that *subtype* doesn't have to equal the type whose :c:"
"member:`~PyTypeObject.tp_new` function is called; it may be a subtype of "
"that type (but not an unrelated type)."
msgstr ""
"El argumento *subtype* es el tipo del objeto que se está creando; los "
"argumentos *args* y *kwds* representan argumentos posicionales y de palabras "
"clave de la llamada al tipo. Tener en cuenta que *subtype* no tiene que ser "
"igual al tipo cuya función :c:member:`~PyTypeObject.tp_new` se llama; puede "
"ser un subtipo de ese tipo (pero no un tipo no relacionado)."

#: ../../c-api/typeobj.rst:1842
msgid ""
"The :c:member:`~PyTypeObject.tp_new` function should call ``subtype-"
">tp_alloc(subtype, nitems)`` to allocate space for the object, and then do "
"only as much further initialization as is absolutely necessary.  "
"Initialization that can safely be ignored or repeated should be placed in "
"the :c:member:`~PyTypeObject.tp_init` handler.  A good rule of thumb is that "
"for immutable types, all initialization should take place in :c:member:"
"`~PyTypeObject.tp_new`, while for mutable types, most initialization should "
"be deferred to :c:member:`~PyTypeObject.tp_init`."
msgstr ""
"La función :c:member:`~PyTypeObject.tp_new` debería llamar a ``subtype-"
">tp_alloc(subtype, nitems)`` para asignar espacio para el objeto, y luego "
"realizar solo la inicialización adicional necesaria. La inicialización que "
"se pueda ignorar o repetir de forma segura debe colocarse en el controlador :"
"c:member:`~PyTypeObject.tp_init`. Una buena regla general es que, para tipos "
"inmutables, toda la inicialización debe tener lugar en :c:member:"
"`~PyTypeObject.tp_new`, mientras que, para tipos mutables, la mayoría de la "
"inicialización debe posponerse a :c:member:`~PyTypeObject.tp_init`."

#: ../../c-api/typeobj.rst:1850
msgid ""
"Set the :const:`Py_TPFLAGS_DISALLOW_INSTANTIATION` flag to disallow creating "
"instances of the type in Python."
msgstr ""
"Establecer la bandera :const:`Py_TPFLAGS_DISALLOW_INSTANTIATION` para "
"prohibir la creación de instancias del tipo en Python."

#: ../../c-api/typeobj.rst:1855
msgid ""
"This field is inherited by subtypes, except it is not inherited by :ref:"
"`static types <static-types>` whose :c:member:`~PyTypeObject.tp_base` is "
"``NULL`` or ``&PyBaseObject_Type``."
msgstr ""
"Este campo es heredado por los subtipos, excepto que no es heredado por los :"
"ref:`static types <static-types>` cuyo :c:member:`~PyTypeObject.tp_base` es "
"``NULL`` o ``&PyBaseObject_Type``."

#: ../../c-api/typeobj.rst:1861
msgid ""
"For :ref:`static types <static-types>` this field has no default. This means "
"if the slot is defined as ``NULL``, the type cannot be called to create new "
"instances; presumably there is some other way to create instances, like a "
"factory function."
msgstr ""
"Para ref:`static types <static-types>` este campo no tiene valor por "
"defecto. Esto significa que si la ranura se define como ``NULL``, el tipo no "
"puede ser llamado para crear nuevas instancias; presumiblemente hay alguna "
"otra forma de crear instancias, como una función de fábrica."

#: ../../c-api/typeobj.rst:1869
msgid ""
"An optional pointer to an instance deallocation function.  Its signature is::"
msgstr ""
"Un puntero opcional a una función de desasignación de instancias. Su firma "
"es:"

#: ../../c-api/typeobj.rst:1873
msgid ""
"An initializer that is compatible with this signature is :c:func:"
"`PyObject_Free`."
msgstr "Un inicializador compatible con esta firma es :c:func:`PyObject_Free`."

#: ../../c-api/typeobj.rst:1877
msgid ""
"This field is inherited by static subtypes, but not by dynamic subtypes "
"(subtypes created by a class statement)"
msgstr ""
"Este campo es heredado por subtipos estáticos, pero no por subtipos "
"dinámicos (subtipos creados por una declaración de clase)"

#: ../../c-api/typeobj.rst:1882
msgid ""
"In dynamic subtypes, this field is set to a deallocator suitable to match :c:"
"func:`PyType_GenericAlloc` and the value of the :const:`Py_TPFLAGS_HAVE_GC` "
"flag bit."
msgstr ""
"En subtipos dinámicos, este campo se establece en un desasignador adecuado "
"para coincidir con :c:func:`PyType_GenericAlloc` y el valor del bit de la "
"bandera :const:`Py_TPFLAGS_HAVE_GC`."

#: ../../c-api/typeobj.rst:1886
msgid "For static subtypes, :c:type:`PyBaseObject_Type` uses PyObject_Del."
msgstr ""
"Para subtipos estáticos, :c:type:`PyBaseObject_Type` utiliza PyObject_Del."

#: ../../c-api/typeobj.rst:1891
msgid "An optional pointer to a function called by the garbage collector."
msgstr "Un puntero opcional a una función llamada por el recolector de basura."

#: ../../c-api/typeobj.rst:1893
msgid ""
"The garbage collector needs to know whether a particular object is "
"collectible or not.  Normally, it is sufficient to look at the object's "
"type's :c:member:`~PyTypeObject.tp_flags` field, and check the :const:"
"`Py_TPFLAGS_HAVE_GC` flag bit.  But some types have a mixture of statically "
"and dynamically allocated instances, and the statically allocated instances "
"are not collectible.  Such types should define this function; it should "
"return ``1`` for a collectible instance, and ``0`` for a non-collectible "
"instance. The signature is::"
msgstr ""
"El recolector de basura necesita saber si un objeto en particular es "
"coleccionable o no. Normalmente, es suficiente con mirar el campo :c:member:"
"`~PyTypeObject.tp_flags` del tipo de objeto y comprobar el bit de la "
"bandera :const:`Py_TPFLAGS_HAVE_GC`. Pero algunos tipos tienen una mezcla de "
"instancias asignadas estáticamente y dinámicamente, y las instancias "
"asignadas estáticamente no son coleccionables. Dichos tipos deben definir "
"esta función; debe devolver ``1`` para una instancia coleccionable y ``0`` "
"para una instancia no coleccionable. La firma es::"

#: ../../c-api/typeobj.rst:1903
msgid ""
"(The only example of this are types themselves.  The metatype, :c:data:"
"`PyType_Type`, defines this function to distinguish between statically and :"
"ref:`dynamically allocated types <heap-types>`.)"
msgstr ""
"(El único ejemplo de esto son los propios tipos.  El metateipo, :c:data:"
"`PyType_Type`, define esta función para distinguir entre tipos asignados "
"estáticamente y :ref:`dinámicamente <heap-types>`)."

#: ../../c-api/typeobj.rst:1913
msgid ""
"This slot has no default.  If this field is ``NULL``, :const:"
"`Py_TPFLAGS_HAVE_GC` is used as the functional equivalent."
msgstr ""
"Esta ranura no tiene valor por defecto.  Si este campo es ``NULL``, se "
"utiliza :const:`Py_TPFLAGS_HAVE_GC` como equivalente funcional."

#: ../../c-api/typeobj.rst:1919
msgid "Tuple of base types."
msgstr "Tupla de tipos base."

#: ../../c-api/typeobj.rst:1921 ../../c-api/typeobj.rst:1945
msgid ""
"This field should be set to ``NULL`` and treated as read-only. Python will "
"fill it in when the type is :c:func:`initialized <PyType_Ready>`."
msgstr ""
"Este campo debe establecerse en ``NULL`` y tratarse como de sólo lectura. "
"Python lo rellenará cuando el tipo sea :c:func:`initialized <PyType_Ready>`."

#: ../../c-api/typeobj.rst:1924
msgid ""
"For dynamically created classes, the ``Py_tp_bases`` :c:type:`slot "
"<PyType_Slot>` can be used instead of the *bases* argument of :c:func:"
"`PyType_FromSpecWithBases`. The argument form is preferred."
msgstr ""
"Para las clases creadas dinámicamente, se puede utilizar el argumento "
"``Py_tp_bases``:c:type:`slot <PyType_Slot>` en lugar del argumento *bases* "
"de :c:func:`PyType_FromSpecWithBases`. Se prefiere la forma de argumento."

#: ../../c-api/typeobj.rst:1931
msgid ""
"Multiple inheritance does not work well for statically defined types. If you "
"set ``tp_bases`` to a tuple, Python will not raise an error, but some slots "
"will only be inherited from the first base."
msgstr ""
"La herencia múltiple no funciona bien para tipos definidos estáticamente. Si "
"establece ``tp_bases`` en una tupla, Python no generará un error, pero "
"algunas ranuras sólo se heredarán de la primera base."

#: ../../c-api/typeobj.rst:1937 ../../c-api/typeobj.rst:1960
#: ../../c-api/typeobj.rst:1969 ../../c-api/typeobj.rst:1979
#: ../../c-api/typeobj.rst:1993
msgid "This field is not inherited."
msgstr "Este campo no se hereda."

#: ../../c-api/typeobj.rst:1942
msgid ""
"Tuple containing the expanded set of base types, starting with the type "
"itself and ending with :class:`object`, in Method Resolution Order."
msgstr ""
"Tupla que contiene el conjunto ampliado de tipos base, comenzando con el "
"propio tipo y terminando con :class:`object`, en el Orden de Resolución de "
"Métodos."

#: ../../c-api/typeobj.rst:1950
msgid ""
"This field is not inherited; it is calculated fresh by :c:func:"
"`PyType_Ready`."
msgstr ""
"Este campo no se hereda; se calcula de nuevo mediante :c:func:`PyType_Ready`."

#: ../../c-api/typeobj.rst:1956
msgid "Unused.  Internal use only."
msgstr "Sin utilizar. Solo para uso interno."

#: ../../c-api/typeobj.rst:1965
msgid "List of weak references to subclasses.  Internal use only."
msgstr "Lista de referencias débiles a subclases. Uso interno únicamente."

#: ../../c-api/typeobj.rst:1974
msgid ""
"Weak reference list head, for weak references to this type object.  Not "
"inherited.  Internal use only."
msgstr ""
"Lista de referencia débil principal, para referencias débiles a este objeto "
"de tipo. No heredado. Solo para uso interno."

#: ../../c-api/typeobj.rst:1984
msgid ""
"This field is deprecated.  Use :c:member:`~PyTypeObject.tp_finalize` instead."
msgstr ""
"Este campo está obsoleto. Usar :c:member:`~PyTypeObject.tp_finalize` en su "
"lugar."

#: ../../c-api/typeobj.rst:1989
msgid "Used to index into the method cache.  Internal use only."
msgstr "Utilizado para indexar en la caché del método. Uso interno solamente."

#: ../../c-api/typeobj.rst:1998
msgid ""
"An optional pointer to an instance finalization function.  Its signature is::"
msgstr ""
"Un puntero opcional a una función de finalización de instancia. Su firma es:"

#: ../../c-api/typeobj.rst:2002
msgid ""
"If :c:member:`~PyTypeObject.tp_finalize` is set, the interpreter calls it "
"once when finalizing an instance.  It is called either from the garbage "
"collector (if the instance is part of an isolated reference cycle) or just "
"before the object is deallocated.  Either way, it is guaranteed to be called "
"before attempting to break reference cycles, ensuring that it finds the "
"object in a sane state."
msgstr ""
"Si :c:member:`~PyTypeObject.tp_finalize` está configurado, el intérprete lo "
"llama una vez al finalizar una instancia. Se llama ya sea desde el "
"recolector de basura (si la instancia es parte de un ciclo de referencia "
"aislado) o justo antes de que el objeto sea desasignado. De cualquier "
"manera, se garantiza que se llame antes de intentar romper los ciclos de "
"referencia, asegurando que encuentre el objeto en un estado coherente."

#: ../../c-api/typeobj.rst:2009
msgid ""
":c:member:`~PyTypeObject.tp_finalize` should not mutate the current "
"exception status; therefore, a recommended way to write a non-trivial "
"finalizer is::"
msgstr ""
":c:member:`~PyTypeObject.tp_finalize` no debe modificar el estado actual de "
"la excepción; por lo tanto, una forma recomendada de escribir un finalizador "
"no trivial es:"

#: ../../c-api/typeobj.rst:2026
msgid ""
"Also, note that, in a garbage collected Python, :c:member:`~PyTypeObject."
"tp_dealloc` may be called from any Python thread, not just the thread which "
"created the object (if the object becomes part of a refcount cycle, that "
"cycle might be collected by a garbage collection on any thread).  This is "
"not a problem for Python API calls, since the thread on which tp_dealloc is "
"called will own the Global Interpreter Lock (GIL). However, if the object "
"being destroyed in turn destroys objects from some other C or C++ library, "
"care should be taken to ensure that destroying those objects on the thread "
"which called tp_dealloc will not violate any assumptions of the library."
msgstr ""
"También, tener en cuenta que, en un Python con recolección de basura, se "
"puede llamar :c:member:`~PyTypeObject.tp_dealloc` desde cualquier hilo de "
"Python, no solo desde el hilo que creó el objeto (si el objeto se convierte "
"en parte de un ciclo de referencia, ese ciclo podría ser recolectado por una "
"recolección de basura en cualquier hilo). Esto no es un problema para las "
"llamadas a la API de Python, ya que el hilo en el que se llama a tp_dealloc "
"será el propietario del Bloqueo Global del Intérprete (GIL). Sin embargo, si "
"el objeto que se está destruyendo a su vez destruye objetos de alguna otra "
"biblioteca en C o C++, se debe tener cuidado para asegurarse de que la "
"destrucción de esos objetos en el hilo que llamó a tp_dealloc no viole "
"ninguna suposición de la biblioteca."

#: ../../c-api/typeobj.rst:2045
msgid ""
"Before version 3.8 it was necessary to set the :const:"
"`Py_TPFLAGS_HAVE_FINALIZE` flags bit in order for this field to be used.  "
"This is no longer required."
msgstr ""
"Antes de la versión 3.8 era necesario establecer el bit de bandera :const:"
"`Py_TPFLAGS_HAVE_FINALIZE` para que se utilizara este campo. Esto ya no es "
"necesario."

#: ../../c-api/typeobj.rst:2049
msgid "\"Safe object finalization\" (:pep:`442`)"
msgstr "\"Finalización segura de objetos\" (:pep:`442`)"

#: ../../c-api/typeobj.rst:2054
msgid ""
"Vectorcall function to use for calls of this type object. In other words, it "
"is used to implement :ref:`vectorcall <vectorcall>` for ``type.__call__``. "
"If ``tp_vectorcall`` is ``NULL``, the default call implementation using :"
"attr:`__new__` and :attr:`__init__` is used."
msgstr ""
"Función Vectorcall para usar en llamadas de este tipo de objeto. En otras "
"palabras, se utiliza para implementar :ref:`vectorcall <vectorcall>` para "
"``type.__call__``. Si ``tp_vectorcall`` es ``NULL``, se utiliza la "
"implementación de llamada predeterminada utilizando :attr:`__new__` y :attr:"
"`__init__`."

#: ../../c-api/typeobj.rst:2062
msgid "This field is never inherited."
msgstr "Este campo nunca se hereda."

#: ../../c-api/typeobj.rst:2064
msgid "(the field exists since 3.8 but it's only used since 3.9)"
msgstr ""
"(el campo existe desde la versión 3.8 pero solo se utiliza desde la versión "
"3.9)"

#: ../../c-api/typeobj.rst:2070
msgid "Static Types"
msgstr "Tipos estáticos"

#: ../../c-api/typeobj.rst:2072
msgid ""
"Traditionally, types defined in C code are *static*, that is, a static :c:"
"type:`PyTypeObject` structure is defined directly in code and initialized "
"using :c:func:`PyType_Ready`."
msgstr ""
"Tradicionalmente, los tipos definidos en el código C son *estáticos*, es "
"decir, se define una estructura estática :c:type:`PyTypeObject` directamente "
"en el código y se inicializa utilizando :c:func:`PyType_Ready`."

#: ../../c-api/typeobj.rst:2076
msgid ""
"This results in types that are limited relative to types defined in Python:"
msgstr ""
"Esto resulta en tipos que están limitados en comparación con los tipos "
"definidos en Python:"

#: ../../c-api/typeobj.rst:2078
msgid ""
"Static types are limited to one base, i.e. they cannot use multiple "
"inheritance."
msgstr ""
"Los tipos estáticos están limitados a una base, es decir, no pueden utilizar "
"herencia múltiple."

#: ../../c-api/typeobj.rst:2080
msgid ""
"Static type objects (but not necessarily their instances) are immutable. It "
"is not possible to add or modify the type object's attributes from Python."
msgstr ""
"Los objetos de tipo estático (pero no necesariamente sus instancias) son "
"inmutables. No es posible agregar o modificar los atributos del objeto de "
"tipo desde Python."

#: ../../c-api/typeobj.rst:2082
msgid ""
"Static type objects are shared across :ref:`sub-interpreters <sub-"
"interpreter-support>`, so they should not include any subinterpreter-"
"specific state."
msgstr ""
"Los objetos de tipo estático se comparten entre :ref:`ssub-interpreters <sub-"
"interpreter-support>`, por lo que no deben incluir ningún estado específico "
"del sub-intérprete."

#: ../../c-api/typeobj.rst:2086
msgid ""
"Also, since :c:type:`PyTypeObject` is only part of the :ref:`Limited API "
"<stable>` as an opaque struct, any extension modules using static types must "
"be compiled for a specific Python minor version."
msgstr ""
"Además, dado que :c:type:`PyTypeObject` sólo forma parte de la :ref:`Limited "
"API <stable>` como estructura opaca, cualquier módulo de ampliación que "
"utilice tipos estáticos debe compilarse para una versión menor específica de "
"Python."

#: ../../c-api/typeobj.rst:2094
msgid "Heap Types"
msgstr "Tipos de montón"

#: ../../c-api/typeobj.rst:2096
msgid ""
"An alternative to :ref:`static types <static-types>` is *heap-allocated "
"types*, or *heap types* for short, which correspond closely to classes "
"created by Python's ``class`` statement. Heap types have the :const:"
"`Py_TPFLAGS_HEAPTYPE` flag set."
msgstr ""
"Una alternativa a  :ref:`static types <static-types>` son los *tipos "
"asignados en el montón*, o *tipos de montón* en resumen, que se corresponden "
"estrechamente con las clases creadas por la declaración ``class`` de Python. "
"Los tipos de montón tienen la bandera :const:`Py_TPFLAGS_HEAPTYPE` "
"establecida."

#: ../../c-api/typeobj.rst:2101
msgid ""
"This is done by filling a :c:type:`PyType_Spec` structure and calling :c:"
"func:`PyType_FromSpec`, :c:func:`PyType_FromSpecWithBases`, or :c:func:"
"`PyType_FromModuleAndSpec`."
msgstr ""
"Esto se hace rellenando una estructura :c:type:`PyType_Spec` y llamando a :c:"
"func:`PyType_FromSpec`, :c:func:`PyType_FromSpecWithBases` o :c:func:"
"`PyType_FromModuleAndSpec`."

#: ../../c-api/typeobj.rst:2109
msgid "Number Object Structures"
msgstr "Estructuras de objetos numéricos"

#: ../../c-api/typeobj.rst:2116
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the number protocol.  Each function is used by the function of "
"similar name documented in the :ref:`number` section."
msgstr ""
"Esta estructura contiene punteros a las funciones que un objeto utiliza para "
"implementar el protocolo numérico.  Cada función es utilizada por la función "
"de nombre similar documentada en la sección :ref:`number`."

#: ../../c-api/typeobj.rst:2122 ../../c-api/typeobj.rst:2446
msgid "Here is the structure definition::"
msgstr "Aquí está la definición de la estructura::"

#: ../../c-api/typeobj.rst:2169
msgid ""
"Binary and ternary functions must check the type of all their operands, and "
"implement the necessary conversions (at least one of the operands is an "
"instance of the defined type).  If the operation is not defined for the "
"given operands, binary and ternary functions must return "
"``Py_NotImplemented``, if another error occurred they must return ``NULL`` "
"and set an exception."
msgstr ""
"Las funciones binarias y ternarias deben comprobar el tipo de todos sus "
"operandos e implementar las conversiones necesarias (al menos uno de los "
"operandos es una instancia del tipo definido).  Si la operación no está "
"definida para los operandos dados, las funciones binarias y ternarias deben "
"devolver ``Py_NotImplemented``, si se ha producido otro error deben devolver "
"``NULL`` y establecer una excepción."

#: ../../c-api/typeobj.rst:2178
msgid ""
"The :c:data:`nb_reserved` field should always be ``NULL``.  It was "
"previously called :c:data:`nb_long`, and was renamed in Python 3.0.1."
msgstr ""
"El campo :c:data:`nb_reserved` siempre debe ser ``NULL``. Anteriormente se "
"llamaba :c:data:`nb_long` y se renombró en Python 3.0.1."

#: ../../c-api/typeobj.rst:2223
msgid "Mapping Object Structures"
msgstr "Mapeo de Estructuras de Objetos"

#: ../../c-api/typeobj.rst:2230
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the mapping protocol.  It has three members:"
msgstr ""
"Esta estructura contiene punteros a las funciones que un objeto utiliza para "
"implementar el protocolo de mapeo. Tiene tres miembros:"

#: ../../c-api/typeobj.rst:2235
msgid ""
"This function is used by :c:func:`PyMapping_Size` and :c:func:"
"`PyObject_Size`, and has the same signature.  This slot may be set to "
"``NULL`` if the object has no defined length."
msgstr ""
"Esta función es utilizada por :c:func:`PyMapping_Size` y :c:func:"
"`PyObject_Size`, y tiene la misma firma.  Esta ranura puede establecerse en "
"``NULL`` si el objeto no tiene una longitud definida."

#: ../../c-api/typeobj.rst:2241
msgid ""
"This function is used by :c:func:`PyObject_GetItem` and :c:func:"
"`PySequence_GetSlice`, and has the same signature as :c:func:`!"
"PyObject_GetItem`.  This slot must be filled for the :c:func:"
"`PyMapping_Check` function to return ``1``, it can be ``NULL`` otherwise."
msgstr ""
"Esta función es utilizada por :c:func:`PyObject_GetItem` y :c:func:"
"`PySequence_GetSlice`, y tiene la misma firma que :c:func:`!"
"PyObject_GetItem`.  Esta ranura debe estar llena para que la función :c:func:"
"`PyMapping_Check` devuelva ``1``, puede ser ``NULL`` en caso contrario."

#: ../../c-api/typeobj.rst:2249
msgid ""
"This function is used by :c:func:`PyObject_SetItem`, :c:func:"
"`PyObject_DelItem`, :c:func:`PyObject_SetSlice` and :c:func:"
"`PyObject_DelSlice`.  It has the same signature as :c:func:`!"
"PyObject_SetItem`, but *v* can also be set to ``NULL`` to delete an item.  "
"If this slot is ``NULL``, the object does not support item assignment and "
"deletion."
msgstr ""
"Esta función es utilizada por :c:func:`PyObject_SetItem`, :c:func:"
"`PyObject_DelItem`, :c:func:`PyObject_SetSlice` y :c:func:"
"`PyObject_DelSlice`. Tiene la misma firma que :c:func:`!PyObject_SetItem`, "
"pero *v* también se puede establecer en ``NULL`` para eliminar un elemento.  "
"Si esta ranura es ``NULL``, el objeto no admite la asignación y eliminación "
"de elementos."

#: ../../c-api/typeobj.rst:2260
msgid "Sequence Object Structures"
msgstr "Estructuras de objetos de secuencia"

#: ../../c-api/typeobj.rst:2267
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the sequence protocol."
msgstr ""
"Esta estructura contiene punteros a las funciones que un objeto utiliza para "
"implementar el protocolo de secuencia."

#: ../../c-api/typeobj.rst:2272
msgid ""
"This function is used by :c:func:`PySequence_Size` and :c:func:"
"`PyObject_Size`, and has the same signature.  It is also used for handling "
"negative indices via the :c:member:`~PySequenceMethods.sq_item` and the :c:"
"member:`~PySequenceMethods.sq_ass_item` slots."
msgstr ""
"Esta función es utilizada por :c:func:`PySequence_Size` y :c:func:"
"`PyObject_Size`, y tiene la misma firma.  También se utiliza para manejar "
"índices negativos a través de las ranuras :c:member:`~PySequenceMethods."
"sq_item` y :c:member:`~PySequenceMethods.sq_ass_item`."

#: ../../c-api/typeobj.rst:2279
msgid ""
"This function is used by :c:func:`PySequence_Concat` and has the same "
"signature.  It is also used by the ``+`` operator, after trying the numeric "
"addition via the :c:member:`~PyNumberMethods.nb_add` slot."
msgstr ""
"Esta función es utilizada por :c:func:`PySequence_Concat` y tiene la misma "
"firma.  También es utilizada por el operador ``+``, después de intentar la "
"suma numérica a través de la ranura :c:member:`~PyNumberMethods.nb_add`."

#: ../../c-api/typeobj.rst:2285
msgid ""
"This function is used by :c:func:`PySequence_Repeat` and has the same "
"signature.  It is also used by the ``*`` operator, after trying numeric "
"multiplication via the :c:member:`~PyNumberMethods.nb_multiply` slot."
msgstr ""
"Esta función es utilizada por :c:func:`PySequence_Repeat` y tiene la misma "
"firma.  También es utilizada por el operador ``*``, después de intentar la "
"multiplicación numérica a través de la ranura :c:member:`~PyNumberMethods."
"nb_multiply`."

#: ../../c-api/typeobj.rst:2291
msgid ""
"This function is used by :c:func:`PySequence_GetItem` and has the same "
"signature.  It is also used by :c:func:`PyObject_GetItem`, after trying the "
"subscription via the :c:member:`~PyMappingMethods.mp_subscript` slot. This "
"slot must be filled for the :c:func:`PySequence_Check` function to return "
"``1``, it can be ``NULL`` otherwise."
msgstr ""
"Esta función es utilizada por :c:func:`PySequence_GetItem` y tiene la misma "
"firma.  También es utilizada por :c:func:`PyObject_GetItem`, después de "
"intentar la suscripción a través de la ranura :c:member:`~PyMappingMethods."
"mp_subscript`. Esta ranura debe estar llena para que la función :c:func:"
"`PySequence_Check` devuelva ``1``, puede ser ``NULL`` en caso contrario."

#: ../../c-api/typeobj.rst:2297
msgid ""
"Negative indexes are handled as follows: if the :attr:`sq_length` slot is "
"filled, it is called and the sequence length is used to compute a positive "
"index which is passed to :attr:`sq_item`.  If :attr:`sq_length` is ``NULL``, "
"the index is passed as is to the function."
msgstr ""
"Los índices negativos se tratan de la siguiente manera: si la ranura :attr:"
"`sq_length` está llena, se llama y la longitud de la secuencia se utiliza "
"para calcular un índice positivo que se pasa a :attr:`sq_item`. Si :attr:"
"`sq_length` es ``NULL``, el índice se pasa tal cual a la función."

#: ../../c-api/typeobj.rst:2304
msgid ""
"This function is used by :c:func:`PySequence_SetItem` and has the same "
"signature.  It is also used by :c:func:`PyObject_SetItem` and :c:func:"
"`PyObject_DelItem`, after trying the item assignment and deletion via the :c:"
"member:`~PyMappingMethods.mp_ass_subscript` slot. This slot may be left to "
"``NULL`` if the object does not support item assignment and deletion."
msgstr ""
"Esta función la utiliza :c:func:`PySequence_SetItem` y tiene la misma firma. "
"También la usa :c:func:`PyObject_SetItem` y :c:func:`PyObject_DelItem`, "
"después de intentar la asignación y eliminación de elementos a través del "
"espacio de nombres :c:member:`~PyMappingMethods.mp_ass_subscript`. Este "
"espacio de nombres puede quedar como ``NULL`` si el objeto no admite la "
"asignación y eliminación de elementos."

#: ../../c-api/typeobj.rst:2313
msgid ""
"This function may be used by :c:func:`PySequence_Contains` and has the same "
"signature.  This slot may be left to ``NULL``, in this case :c:func:`!"
"PySequence_Contains` simply traverses the sequence until it finds a match."
msgstr ""
"Esta función la puede utilizar :c:func:`PySequence_Contains` y tiene la "
"misma firma.  Esta ranura se puede dejar ``NULL``, en este caso :c:func:`!"
"PySequence_Contains` simplemente recorre la secuencia hasta que encuentra "
"una coincidencia."

#: ../../c-api/typeobj.rst:2320
msgid ""
"This function is used by :c:func:`PySequence_InPlaceConcat` and has the same "
"signature.  It should modify its first operand, and return it.  This slot "
"may be left to ``NULL``, in this case :c:func:`!PySequence_InPlaceConcat` "
"will fall back to :c:func:`PySequence_Concat`.  It is also used by the "
"augmented assignment ``+=``, after trying numeric in-place addition via the :"
"c:member:`~PyNumberMethods.nb_inplace_add` slot."
msgstr ""
"Esta función la utiliza :c:func:`PySequence_InPlaceConcat` y tiene la misma "
"firma.  Debe modificar su primer operando y devolverlo.  Esta ranura puede "
"dejarse ``NULL``, en este caso :c:func:`!PySequence_InPlaceConcat` "
"retrocederá a :c:func:`PySequence_Concat`. También la utiliza la asignación "
"aumentada ``+=``, después de intentar la suma numérica en el lugar a través "
"de la ranura :c:member:`~PyNumberMethods.nb_inplace_add`."

#: ../../c-api/typeobj.rst:2329
msgid ""
"This function is used by :c:func:`PySequence_InPlaceRepeat` and has the same "
"signature.  It should modify its first operand, and return it.  This slot "
"may be left to ``NULL``, in this case :c:func:`!PySequence_InPlaceRepeat` "
"will fall back to :c:func:`PySequence_Repeat`.  It is also used by the "
"augmented assignment ``*=``, after trying numeric in-place multiplication "
"via the :c:member:`~PyNumberMethods.nb_inplace_multiply` slot."
msgstr ""
"Esta función la utiliza :c:func:`PySequence_InPlaceRepeat` y tiene la misma "
"firma.  Debe modificar su primer operando y devolverlo.  Esta ranura se "
"puede dejar ``NULL``, en este caso :c:func:`!PySequence_InPlaceRepeat` "
"retrocederá a :c:func:`PySequence_Repeat`. También la utiliza la asignación "
"aumentada ``*=``, después de intentar la multiplicación numérica en el lugar "
"a través de la ranura :c:member:`~PyNumberMethods.nb_inplace_multiply`."

#: ../../c-api/typeobj.rst:2340
msgid "Buffer Object Structures"
msgstr "Estructuras de objetos de memoria intermedia"

#: ../../c-api/typeobj.rst:2348
msgid ""
"This structure holds pointers to the functions required by the :ref:`Buffer "
"protocol <bufferobjects>`. The protocol defines how an exporter object can "
"expose its internal data to consumer objects."
msgstr ""
"Esta estructura contiene punteros a las funciones requeridas por el :ref:"
"`Buffer protocol <bufferobjects>`. El protocolo define cómo un objeto "
"exportador puede exponer sus datos internos a los objetos consumidores."

#: ../../c-api/typeobj.rst:2354 ../../c-api/typeobj.rst:2403
#: ../../c-api/typeobj.rst:2457 ../../c-api/typeobj.rst:2468
#: ../../c-api/typeobj.rst:2480 ../../c-api/typeobj.rst:2489
msgid "The signature of this function is::"
msgstr "La firma de esta función es::"

#: ../../c-api/typeobj.rst:2358
msgid ""
"Handle a request to *exporter* to fill in *view* as specified by *flags*. "
"Except for point (3), an implementation of this function MUST take these "
"steps:"
msgstr ""
"Maneja una petición a *exporter* para rellenar *view* según lo especificado "
"por *flags*. Excepto el punto (3), una implementación de esta función DEBE "
"seguir estos pasos:"

#: ../../c-api/typeobj.rst:2362
msgid ""
"Check if the request can be met. If not, raise :c:data:`PyExc_BufferError`, "
"set :c:expr:`view->obj` to ``NULL`` and return ``-1``."
msgstr ""
"Comprobar si se puede cumplir la solicitud. Si no es posible, lanzar :c:data:"
"`PyExc_BufferError`, establecer :c:expr:`view->obj` a ``NULL`` y devolver "
"``-1``."

#: ../../c-api/typeobj.rst:2365
msgid "Fill in the requested fields."
msgstr "Rellene los campos solicitados."

#: ../../c-api/typeobj.rst:2367
msgid "Increment an internal counter for the number of exports."
msgstr "Incrementar un contador interno para el número de exportaciones."

#: ../../c-api/typeobj.rst:2369
msgid ""
"Set :c:expr:`view->obj` to *exporter* and increment :c:expr:`view->obj`."
msgstr ""
"Establezca :c:expr:`view->obj` en *exporter* e incremente :c:expr:`view-"
">obj`."

#: ../../c-api/typeobj.rst:2371
msgid "Return ``0``."
msgstr "Devolver ``0``."

#: ../../c-api/typeobj.rst:2373
msgid ""
"If *exporter* is part of a chain or tree of buffer providers, two main "
"schemes can be used:"
msgstr ""
"Si *exporter* forma parte de una cadena o árbol de proveedores de búfer, se "
"pueden utilizar dos esquemas principales."

#: ../../c-api/typeobj.rst:2376
msgid ""
"Re-export: Each member of the tree acts as the exporting object and sets :c:"
"expr:`view->obj` to a new reference to itself."
msgstr ""
"Reexportación: Cada miembro del árbol actúa como objeto exportador y "
"establece :c:expr:`view->obj` en una nueva referencia a sí mismo."

#: ../../c-api/typeobj.rst:2379
msgid ""
"Redirect: The buffer request is redirected to the root object of the tree. "
"Here, :c:expr:`view->obj` will be a new reference to the root object."
msgstr ""
"Redirigir: La petición del buffer se redirige al objeto raíz del árbol. "
"Aquí, :c:expr:`view->obj` será una nueva referencia al objeto raíz."

#: ../../c-api/typeobj.rst:2383
msgid ""
"The individual fields of *view* are described in section :ref:`Buffer "
"structure <buffer-structure>`, the rules how an exporter must react to "
"specific requests are in section :ref:`Buffer request types <buffer-request-"
"types>`."
msgstr ""
"Los campos individuales de *view* se describen en la sección :ref:`Buffer "
"structure <buffer-structure>`, las reglas sobre cómo debe reaccionar un "
"exportador a solicitudes específicas se encuentran en la sección :ref:"
"`Buffer request types <buffer-request-types>`."

#: ../../c-api/typeobj.rst:2388
msgid ""
"All memory pointed to in the :c:type:`Py_buffer` structure belongs to the "
"exporter and must remain valid until there are no consumers left. :c:member:"
"`~Py_buffer.format`, :c:member:`~Py_buffer.shape`, :c:member:`~Py_buffer."
"strides`, :c:member:`~Py_buffer.suboffsets` and :c:member:`~Py_buffer."
"internal` are read-only for the consumer."
msgstr ""
"Toda la memoria apuntada en la estructura :c:type:`Py_buffer` pertenece al "
"exportador y debe permanecer válida hasta que no queden consumidores. :c:"
"member:`~Py_buffer.format`, :c:member:`~Py_buffer.shape`, :c:member:"
"`~Py_buffer.strides`, :c:member:`~Py_buffer.suboffsets` y :c:member:"
"`~Py_buffer.internal` son de sólo lectura para el consumidor."

#: ../../c-api/typeobj.rst:2395
msgid ""
":c:func:`PyBuffer_FillInfo` provides an easy way of exposing a simple bytes "
"buffer while dealing correctly with all request types."
msgstr ""
":c:func:`PyBuffer_FillInfo` proporciona una forma sencilla de exponer un "
"simple búfer de bytes a la vez que trata correctamente todos los tipos de "
"peticiones."

#: ../../c-api/typeobj.rst:2398
msgid ""
":c:func:`PyObject_GetBuffer` is the interface for the consumer that wraps "
"this function."
msgstr ""
":c:func:`PyObject_GetBuffer` es la interfaz para el consumidor que envuelve "
"esta función."

#: ../../c-api/typeobj.rst:2407
msgid ""
"Handle a request to release the resources of the buffer. If no resources "
"need to be released, :c:member:`PyBufferProcs.bf_releasebuffer` may be "
"``NULL``. Otherwise, a standard implementation of this function will take "
"these optional steps:"
msgstr ""
"Manejar una solicitud para liberar los recursos del búfer. Si no es "
"necesario liberar recursos, :c:member:`PyBufferProcs.bf_releasebuffer` puede "
"ser ``NULL``. De lo contrario, una implementación estándar de esta función "
"tomará los siguientes pasos opcionales:"

#: ../../c-api/typeobj.rst:2412
msgid "Decrement an internal counter for the number of exports."
msgstr "Decrementar un contador interno para el número de exportaciones."

#: ../../c-api/typeobj.rst:2414
msgid "If the counter is ``0``, free all memory associated with *view*."
msgstr "Si el contador es ``0``, liberar toda la memoria asociada con *view*."

#: ../../c-api/typeobj.rst:2416
msgid ""
"The exporter MUST use the :c:member:`~Py_buffer.internal` field to keep "
"track of buffer-specific resources. This field is guaranteed to remain "
"constant, while a consumer MAY pass a copy of the original buffer as the "
"*view* argument."
msgstr ""
"El exportador DEBE utilizar el campo :c:member:`~Py_buffer.internal` para "
"realizar un seguimiento de los recursos específicos del búfer. Se garantiza "
"que este campo permanece constante, mientras que un consumidor PUEDE pasar "
"una copia del búfer original como argumento *view*."

#: ../../c-api/typeobj.rst:2422
msgid ""
"This function MUST NOT decrement :c:expr:`view->obj`, since that is done "
"automatically in :c:func:`PyBuffer_Release` (this scheme is useful for "
"breaking reference cycles)."
msgstr ""
"Esta función NO DEBE decrementar :c:expr:`view->obj`, ya que eso se hace "
"automáticamente en :c:func:`PyBuffer_Release` (este esquema es útil para "
"romper ciclos de referencia)."

#: ../../c-api/typeobj.rst:2427
msgid ""
":c:func:`PyBuffer_Release` is the interface for the consumer that wraps this "
"function."
msgstr ""
":c:func:`PyBuffer_Release` es la interfaz para el consumidor que envuelve "
"esta función."

#: ../../c-api/typeobj.rst:2435
msgid "Async Object Structures"
msgstr "Estructuras de objetos asíncronos"

#: ../../c-api/typeobj.rst:2443
msgid ""
"This structure holds pointers to the functions required to implement :term:"
"`awaitable` and :term:`asynchronous iterator` objects."
msgstr ""
"Esta estructura contiene punteros a las funciones necesarias para "
"implementar objetos :term:`awaitable` y :term:`asynchronous iterator`."

#: ../../c-api/typeobj.rst:2461
msgid ""
"The returned object must be an :term:`iterator`, i.e. :c:func:`PyIter_Check` "
"must return ``1`` for it."
msgstr ""
"El objeto devuelto debe ser un :term:`iterator`, es decir, :c:func:"
"`PyIter_Check` debe devolver ``1`` para él."

#: ../../c-api/typeobj.rst:2464
msgid ""
"This slot may be set to ``NULL`` if an object is not an :term:`awaitable`."
msgstr ""
"Esta ranura puede establecerse en ``NULL`` si un objeto no es un :term:"
"`awaitable`."

#: ../../c-api/typeobj.rst:2472
msgid ""
"Must return an :term:`asynchronous iterator` object. See :meth:`__anext__` "
"for details."
msgstr ""
"Debe devolver un objeto :term:`asynchronous iterator`. Ver :meth:`__anext__` "
"para más detalles."

#: ../../c-api/typeobj.rst:2475
msgid ""
"This slot may be set to ``NULL`` if an object does not implement "
"asynchronous iteration protocol."
msgstr ""
"Esta ranura puede establecerse en ``NULL`` si un objeto no implementa el "
"protocolo de iteración asíncrona."

#: ../../c-api/typeobj.rst:2484
msgid ""
"Must return an :term:`awaitable` object.  See :meth:`__anext__` for details. "
"This slot may be set to ``NULL``."
msgstr ""
"Debe devolver un objeto :term:`awaitable`.  Ver :meth:`__anext__` para más "
"detalles. Esta ranura puede establecerse en ``NULL``."

#: ../../c-api/typeobj.rst:2493
msgid ""
"See :c:func:`PyIter_Send` for details. This slot may be set to ``NULL``."
msgstr ""
"Ver :c:func:`PyIter_Send` para más detalles. Esta ranura puede configurarse "
"en ``NULL``."

#: ../../c-api/typeobj.rst:2502
msgid "Slot Type typedefs"
msgstr "Tipos de ranura"

#: ../../c-api/typeobj.rst:2506
msgid ""
"The purpose of this function is to separate memory allocation from memory "
"initialization.  It should return a pointer to a block of memory of adequate "
"length for the instance, suitably aligned, and initialized to zeros, but "
"with :attr:`ob_refcnt` set to ``1`` and :attr:`ob_type` set to the type "
"argument.  If the type's :c:member:`~PyTypeObject.tp_itemsize` is non-zero, "
"the object's :attr:`ob_size` field should be initialized to *nitems* and the "
"length of the allocated memory block should be ``tp_basicsize + "
"nitems*tp_itemsize``, rounded up to a multiple of ``sizeof(void*)``; "
"otherwise, *nitems* is not used and the length of the block should be :c:"
"member:`~PyTypeObject.tp_basicsize`."
msgstr ""
"El propósito de esta función es separar la asignación de memoria de la "
"inicialización de memoria.  Debe devolver un puntero a un bloque de memoria "
"de longitud adecuada para la instancia, convenientemente alineado e "
"inicializado a ceros, pero con :attr:`ob_refcnt` establecido a ``1`` y :attr:"
"`ob_type` establecido al argumento de tipo.  Si el tipo :c:member:"
"`~PyTypeObject.tp_itemsize` es distinto de cero, el campo :attr:`ob_size` "
"del objeto debe inicializarse a *nitems* y la longitud del bloque de memoria "
"asignado debe ser ``tp_basicsize + nitems*tp_itemsize``, redondeado a un "
"múltiplo de ``sizeof(void*)``; en caso contrario, *nitems* no se utiliza y "
"la longitud del bloque debe ser :c:member:`~PyTypeObject.tp_basicsize`."

#: ../../c-api/typeobj.rst:2516
msgid ""
"This function should not do any other instance initialization, not even to "
"allocate additional memory; that should be done by :c:member:`~PyTypeObject."
"tp_new`."
msgstr ""
"Esta función no debe realizar ninguna otra inicialización de instancia, ni "
"siquiera para asignar memoria adicional; eso debe hacerlo :c:member:"
"`~PyTypeObject.tp_new`."

#: ../../c-api/typeobj.rst:2523
msgid "See :c:member:`~PyTypeObject.tp_free`."
msgstr "Ver :c:member:`~PyTypeObject.tp_free`."

#: ../../c-api/typeobj.rst:2527
msgid "See :c:member:`~PyTypeObject.tp_new`."
msgstr "Ver :c:member:`~PyTypeObject.tp_new`."

#: ../../c-api/typeobj.rst:2531
msgid "See :c:member:`~PyTypeObject.tp_init`."
msgstr "Ver :c:member:`~PyTypeObject.tp_init`."

#: ../../c-api/typeobj.rst:2535
msgid "See :c:member:`~PyTypeObject.tp_repr`."
msgstr "Ver :c:member:`~PyTypeObject.tp_repr`."

#: ../../c-api/typeobj.rst:2539 ../../c-api/typeobj.rst:2548
msgid "Return the value of the named attribute for the object."
msgstr "Devuelve el valor del atributo nombrado para el objeto."

#: ../../c-api/typeobj.rst:2543 ../../c-api/typeobj.rst:2554
msgid ""
"Set the value of the named attribute for the object. The value argument is "
"set to ``NULL`` to delete the attribute."
msgstr ""
"Establecer el valor del atributo nombrado para el objeto. El argumento de "
"valor se establece en ``NULL`` para eliminar el atributo."

#: ../../c-api/typeobj.rst:2550
msgid "See :c:member:`~PyTypeObject.tp_getattro`."
msgstr "Ver :c:member:`~PyTypeObject.tp_getattro`."

#: ../../c-api/typeobj.rst:2557
msgid "See :c:member:`~PyTypeObject.tp_setattro`."
msgstr "Ver :c:member:`~PyTypeObject.tp_setattro`."

#: ../../c-api/typeobj.rst:2561
msgid "See :c:member:`~PyTypeObject.tp_descr_get`."
msgstr "Ver :c:member:`~PyTypeObject.tp_descr_get`."

#: ../../c-api/typeobj.rst:2565
msgid "See :c:member:`~PyTypeObject.tp_descr_set`."
msgstr "Ver :c:member:`~PyTypeObject.tp_descr_set`."

#: ../../c-api/typeobj.rst:2569
msgid "See :c:member:`~PyTypeObject.tp_hash`."
msgstr "Ver :c:member:`~PyTypeObject.tp_hash`."

#: ../../c-api/typeobj.rst:2573
msgid "See :c:member:`~PyTypeObject.tp_richcompare`."
msgstr "Ver :c:member:`~PyTypeObject.tp_richcompare`."

#: ../../c-api/typeobj.rst:2577
msgid "See :c:member:`~PyTypeObject.tp_iter`."
msgstr "Ver :c:member:`~PyTypeObject.tp_iter`."

#: ../../c-api/typeobj.rst:2581
msgid "See :c:member:`~PyTypeObject.tp_iternext`."
msgstr "Ver :c:member:`~PyTypeObject.tp_iternext`."

#: ../../c-api/typeobj.rst:2595
msgid "See :c:member:`~PyAsyncMethods.am_send`."
msgstr "Ver :c:member:`~PyAsyncMethods.am_send`."

#: ../../c-api/typeobj.rst:2611
msgid "Examples"
msgstr "Ejemplos"

#: ../../c-api/typeobj.rst:2613
msgid ""
"The following are simple examples of Python type definitions.  They include "
"common usage you may encounter.  Some demonstrate tricky corner cases.  For "
"more examples, practical info, and a tutorial, see :ref:`defining-new-types` "
"and :ref:`new-types-topics`."
msgstr ""
"Los siguientes son ejemplos simples de definiciones de tipos en Python. "
"Incluyen usos comunes que puedes encontrar. Algunos demuestran casos "
"complicados. Para más ejemplos, información práctica y un tutorial, "
"consulta :ref:`defining-new-types` y :ref:`new-types-topics`."

#: ../../c-api/typeobj.rst:2618
msgid "A basic :ref:`static type <static-types>`::"
msgstr "Un básicoo :ref:`static type<static-types>`::"

#: ../../c-api/typeobj.rst:2635
msgid ""
"You may also find older code (especially in the CPython code base) with a "
"more verbose initializer::"
msgstr ""
"También puede encontrar código antiguo (especialmente en la base de código "
"CPython) con un inicializador más verboso::"

#: ../../c-api/typeobj.rst:2679
msgid "A type that supports weakrefs, instance dicts, and hashing::"
msgstr "Un tipo que admite weakrefs, instance dicts y hashing::"

#: ../../c-api/typeobj.rst:2706
msgid ""
"A str subclass that cannot be subclassed and cannot be called to create "
"instances (e.g. uses a separate factory func) using :c:data:"
"`Py_TPFLAGS_DISALLOW_INSTANTIATION` flag::"
msgstr ""
"Una subclase str que no se puede subclasificar y no se puede llamar para "
"crear instancias (por ejemplo, utiliza una función de fábrica separada) "
"utilizando la bandera:c:data:`Py_TPFLAGS_DISALLOW_INSTANTIATION`::"

#: ../../c-api/typeobj.rst:2725
msgid ""
"The simplest :ref:`static type <static-types>` with fixed-length instances::"
msgstr ""
"El :ref:`static type <static-types>` más sencillo con instancias de longitud "
"fija::"

#: ../../c-api/typeobj.rst:2736
msgid ""
"The simplest :ref:`static type <static-types>` with variable-length "
"instances::"
msgstr ""
"El  :ref:`static type <static-types>` más sencillo con instancias de "
"longitud variable::"
