# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 15:28+0000\n"
"PO-Revision-Date: 2023-05-24 02:09+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Spanish (Spain) (https://app.transifex.com/python-doc/"
"teams/5390/es_ES/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es_ES\n"
"Plural-Forms: nplurals=3; plural=n == 1 ? 0 : n != 0 && n % 1000000 == 0 ? "
"1 : 2;\n"

#: ../../c-api/structures.rst:6
msgid "Common Object Structures"
msgstr "Estructuras de objetos comunes"

#: ../../c-api/structures.rst:8
msgid ""
"There are a large number of structures which are used in the definition of "
"object types for Python.  This section describes these structures and how "
"they are used."
msgstr ""
"Hay un gran número de estructuras que se utilizan en la definición de tipos "
"de objetos para Python.  Esta sección describe estas estructuras y cómo se "
"utilizan."

#: ../../c-api/structures.rst:14
msgid "Base object types and macros"
msgstr "Tipos de objetos base y macros"

#: ../../c-api/structures.rst:16
msgid ""
"All Python objects ultimately share a small number of fields at the "
"beginning of the object's representation in memory.  These are represented "
"by the :c:type:`PyObject` and :c:type:`PyVarObject` types, which are "
"defined, in turn, by the expansions of some macros also used, whether "
"directly or indirectly, in the definition of all other Python objects."
msgstr ""

#: ../../c-api/structures.rst:25
msgid ""
"All object types are extensions of this type.  This is a type which contains "
"the information Python needs to treat a pointer to an object as an object.  "
"In a normal \"release\" build, it contains only the object's reference count "
"and a pointer to the corresponding type object. Nothing is actually declared "
"to be a :c:type:`PyObject`, but every pointer to a Python object can be cast "
"to a :c:expr:`PyObject*`.  Access to the members must be done by using the "
"macros :c:macro:`Py_REFCNT` and :c:macro:`Py_TYPE`."
msgstr ""
"Todos los tipos de objeto son extensiones de este tipo.  Es un tipo que "
"contiene la información que Python necesita para tratar un puntero a un "
"objeto como un objeto.  En una construcción normal de \"liberación\", sólo "
"contiene el recuento de referencias del objeto y un puntero al objeto de "
"tipo correspondiente. En realidad, nada se declara como un :c:type:"
"`PyObject`, pero todo puntero a un objeto Python puede ser lanzado a un :c:"
"expr:`PyObject*`. El acceso a los miembros debe hacerse utilizando las "
"macros :c:macro:`Py_REFCNT` y :c:macro:`Py_TYPE`."

#: ../../c-api/structures.rst:37
msgid ""
"This is an extension of :c:type:`PyObject` that adds the :c:member:"
"`~PyVarObject.ob_size` field.  This is only used for objects that have some "
"notion of *length*. This type does not often appear in the Python/C API. "
"Access to the members must be done by using the macros :c:macro:"
"`Py_REFCNT`, :c:macro:`Py_TYPE`, and :c:macro:`Py_SIZE`."
msgstr ""
"Se trata de una extensión de :c:type:`PyObject` que añade el campo :c:member:"
"`~PyVarObject.ob_size`.  Sólo se utiliza para objetos que tienen alguna "
"noción de *longitud*. Este tipo no suele aparecer en la API de Python/C. El "
"acceso a los miembros debe hacerse utilizando las macros :c:macro:"
"`Py_REFCNT`, :c:macro:`Py_TYPE`, y :c:macro:`Py_SIZE`."

#: ../../c-api/structures.rst:46
msgid ""
"This is a macro used when declaring new types which represent objects "
"without a varying length.  The PyObject_HEAD macro expands to::"
msgstr ""
"Este es un macro utilizado al declarar nuevos tipos que representan objetos "
"sin una longitud variable. El macro PyObject_HEAD se expande a:"

#: ../../c-api/structures.rst:51
msgid "See documentation of :c:type:`PyObject` above."
msgstr "Ver documentación de :c:type:`PyObject` arriba."

#: ../../c-api/structures.rst:56
msgid ""
"This is a macro used when declaring new types which represent objects with a "
"length that varies from instance to instance. The PyObject_VAR_HEAD macro "
"expands to::"
msgstr ""
"Este es un macro utilizado al declarar nuevos tipos que representan objetos "
"con una longitud que varía de instancia a instancia. El macro "
"PyObject_VAR_HEAD se expande a:"

#: ../../c-api/structures.rst:62
msgid "See documentation of :c:type:`PyVarObject` above."
msgstr "Ver documentación de :c:type:`PyVarObject` arriba."

#: ../../c-api/structures.rst:67
msgid ""
"Test if the *x* object is the *y* object, the same as ``x is y`` in Python."
msgstr ""
"Prueba si el objeto *x* es el objeto *y*, igual que ``x is y`` en Python."

#: ../../c-api/structures.rst:74
msgid ""
"Test if an object is the ``None`` singleton, the same as ``x is None`` in "
"Python."
msgstr ""
"Prueba si un objeto es el singleton ``None``, lo mismo que ``x is None`` en "
"Python."

#: ../../c-api/structures.rst:82
msgid ""
"Test if an object is the ``True`` singleton, the same as ``x is True`` in "
"Python."
msgstr ""
"Prueba si un objeto es el singleton ``True``, lo mismo que ``x is True`` en "
"Python."

#: ../../c-api/structures.rst:90
msgid ""
"Test if an object is the ``False`` singleton, the same as ``x is False`` in "
"Python."
msgstr ""
"Prueba si un objeto es el singleton ``False``, lo mismo que ``x is False`` "
"en Python."

#: ../../c-api/structures.rst:98
msgid "Get the type of the Python object *o*."
msgstr "Obtener el tipo del objeto Python *o*."

#: ../../c-api/structures.rst:100
msgid "Return a :term:`borrowed reference`."
msgstr "Devuelve un :term:`borrowed reference`."

#: ../../c-api/structures.rst:102
msgid "Use the :c:func:`Py_SET_TYPE` function to set an object type."
msgstr ""
"Utilice la función :c:func:`Py_SET_TYPE` para establecer un tipo de objeto."

#: ../../c-api/structures.rst:104
msgid ""
":c:func:`Py_TYPE()` is changed to an inline static function. The parameter "
"type is no longer :c:expr:`const PyObject*`."
msgstr ""
":c:func:`Py_TYPE()` se convierte en una función estática en línea. El tipo "
"de parámetro ya no es :c:expr:`const PyObject*`."

#: ../../c-api/structures.rst:111
msgid ""
"Return non-zero if the object *o* type is *type*. Return zero otherwise. "
"Equivalent to: ``Py_TYPE(o) == type``."
msgstr ""
"Devuelve un valor distinto de cero si el tipo del objeto *o* es *type*. "
"Devuelve cero en caso contrario. Equivalente a: ``Py_TYPE(o) == type``."

#: ../../c-api/structures.rst:119
msgid "Set the object *o* type to *type*."
msgstr "Establece el tipo del objeto *o* en *tipo*."

#: ../../c-api/structures.rst:126
msgid "Get the reference count of the Python object *o*."
msgstr "Obtiene el recuento de referencias del objeto Python *o*."

#: ../../c-api/structures.rst:128
msgid ""
"Use the :c:func:`Py_SET_REFCNT()` function to set an object reference count."
msgstr ""
"Usar la función :c:func:`Py_SET_REFCNT()` para establecer un recuento de "
"referencias a objetos."

#: ../../c-api/structures.rst:130
msgid "The parameter type is no longer :c:expr:`const PyObject*`."
msgstr "El tipo de parámetro ya no es :c:expr:`const PyObject*`."

#: ../../c-api/structures.rst:133
msgid ":c:func:`Py_REFCNT()` is changed to the inline static function."
msgstr ":c:func:`Py_REFCNT()` se cambia a la función estática en línea."

#: ../../c-api/structures.rst:139
msgid "Set the object *o* reference counter to *refcnt*."
msgstr "Establecer el contador de referencia del objeto *o* a *refcnt*."

#: ../../c-api/structures.rst:146
msgid "Get the size of the Python object *o*."
msgstr "Obtener el tamaño del objeto Python *o*."

#: ../../c-api/structures.rst:148
msgid "Use the :c:func:`Py_SET_SIZE` function to set an object size."
msgstr ""
"Utilice la función :c:func:`Py_SET_SIZE` para establecer el tamaño de un "
"objeto."

#: ../../c-api/structures.rst:150
msgid ""
":c:func:`Py_SIZE()` is changed to an inline static function. The parameter "
"type is no longer :c:expr:`const PyVarObject*`."
msgstr ""
":c:func:`Py_SIZE()` se convierte en una función estática en línea. El tipo "
"de parámetro ya no es :c:expr:`const PyVarObject*`."

#: ../../c-api/structures.rst:157
msgid "Set the object *o* size to *size*."
msgstr "Establece el tamaño del objeto *o* en *tamaño*."

#: ../../c-api/structures.rst:164
msgid ""
"This is a macro which expands to initialization values for a new :c:type:"
"`PyObject` type.  This macro expands to::"
msgstr ""
"Esta es una macro que se expande a valores de inicialización para un nuevo "
"tipo :c:type:`PyObject`.  Esta macro se expande a::"

#: ../../c-api/structures.rst:173
msgid ""
"This is a macro which expands to initialization values for a new :c:type:"
"`PyVarObject` type, including the :c:member:`~PyVarObject.ob_size` field. "
"This macro expands to::"
msgstr ""
"Se trata de una macro que se expande a valores de inicialización para un "
"nuevo tipo :c:type:`PyVarObject`, incluido el campo :c:member:`~PyVarObject."
"ob_size`. Esta macro se expande a::"

#: ../../c-api/structures.rst:182
msgid "Implementing functions and methods"
msgstr "Implementación de funciones y métodos"

#: ../../c-api/structures.rst:186
msgid ""
"Type of the functions used to implement most Python callables in C. "
"Functions of this type take two :c:expr:`PyObject*` parameters and return "
"one such value.  If the return value is ``NULL``, an exception shall have "
"been set.  If not ``NULL``, the return value is interpreted as the return "
"value of the function as exposed in Python.  The function must return a new "
"reference."
msgstr ""
"Tipo de las funciones utilizadas para implementar la mayoría de las llamadas "
"Python en C. Las funciones de este tipo toman dos parámetros :c:expr:"
"`PyObject*` y devuelven un valor de este tipo.  Si el valor de retorno es "
"``NULL``, se habrá establecido una excepción.  Si no es ``NULL``, el valor "
"de retorno se interpreta como el valor de retorno de la función tal y como "
"se expone en Python.  La función debe devolver una nueva referencia."

#: ../../c-api/structures.rst:193
msgid "The function signature is::"
msgstr "La firma de la función es::"

#: ../../c-api/structures.rst:200
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :ref:`METH_VARARGS | METH_KEYWORDS <METH_VARARGS-METH_KEYWORDS>`. "
"The function signature is::"
msgstr ""
"Tipo de las funciones utilizadas para implementar llamadas de Python en C "
"con firma :ref:`METH_VARARGS | METH_KEYWORDS <METH_VARARGS-METH_KEYWORDS>`. "
"La firma de la función es::"

#: ../../c-api/structures.rst:211
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :c:macro:`METH_FASTCALL`. The function signature is::"
msgstr ""
"Tipo de las funciones utilizadas para implementar callables Python en C con "
"la firma :c:macro:`METH_FASTCALL`. La firma de la función es::"

#: ../../c-api/structures.rst:221
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-"
"METH_KEYWORDS>`. The function signature is::"
msgstr ""
"Tipo de las funciones utilizadas para implementar callables de Python en C "
"con firma :ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-"
"METH_KEYWORDS>`. La firma de la función es::"

#: ../../c-api/structures.rst:232
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :ref:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS <METH_METHOD-"
"METH_FASTCALL-METH_KEYWORDS>`. The function signature is::"
msgstr ""
"Tipo de las funciones utilizadas para implementar callables de Python en C "
"con firma :ref:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS <METH_METHOD-"
"METH_FASTCALL-METH_KEYWORDS>`. La firma de la función es::"

#: ../../c-api/structures.rst:247
msgid ""
"Structure used to describe a method of an extension type.  This structure "
"has four fields:"
msgstr ""
"Estructura utilizada para describir un método de un tipo de extensión.  Esta "
"estructura tiene cuatro campos:"

#: ../../c-api/structures.rst:252
msgid "Name of the method."
msgstr "Nombre del método."

#: ../../c-api/structures.rst:256
msgid "Pointer to the C implementation."
msgstr "Puntero a la implementación en C."

#: ../../c-api/structures.rst:260
msgid "Flags bits indicating how the call should be constructed."
msgstr "Bits de bandera que indican cómo debe construirse la llamada."

#: ../../c-api/structures.rst:264
msgid "Points to the contents of the docstring."
msgstr "Apunta al contenido del docstring."

#: ../../c-api/structures.rst:266
msgid ""
"The :c:member:`~PyMethodDef.ml_meth` is a C function pointer. The functions "
"may be of different types, but they always return :c:expr:`PyObject*`.  If "
"the function is not of the :c:type:`PyCFunction`, the compiler will require "
"a cast in the method table. Even though :c:type:`PyCFunction` defines the "
"first parameter as :c:expr:`PyObject*`, it is common that the method "
"implementation uses the specific C type of the *self* object."
msgstr ""
":c:member:`~PyMethodDef.ml_meth` es un puntero a una función C. Las "
"funciones pueden ser de diferentes tipos, pero siempre devuelven :c:expr:"
"`PyObject*`.  Si la función no es del tipo :c:type:`PyCFunction`, el "
"compilador requerirá un cast en la tabla de métodos. Aunque :c:type:"
"`PyCFunction` defina el primer parámetro como :c:expr:`PyObject*`, es "
"habitual que la implementación del método utilice el tipo C específico del "
"objeto *self*."

#: ../../c-api/structures.rst:274
msgid ""
"The :c:member:`~PyMethodDef.ml_flags` field is a bitfield which can include "
"the following flags. The individual flags indicate either a calling "
"convention or a binding convention."
msgstr ""
"El campo :c:member:`~PyMethodDef.ml_flags` es un campo de bits que puede "
"incluir los siguientes indicadores. Las banderas individuales indican una "
"convención de llamada o una convención de enlace."

#: ../../c-api/structures.rst:279
msgid "There are these calling conventions:"
msgstr "Existen estas convenciones de llamada:"

#: ../../c-api/structures.rst:283
msgid ""
"This is the typical calling convention, where the methods have the type :c:"
"type:`PyCFunction`. The function expects two :c:expr:`PyObject*` values. The "
"first one is the *self* object for methods; for module functions, it is the "
"module object.  The second parameter (often called *args*) is a tuple object "
"representing all arguments. This parameter is typically processed using :c:"
"func:`PyArg_ParseTuple` or :c:func:`PyArg_UnpackTuple`."
msgstr ""
"Esta es la convención de llamada típica, en la que los métodos tienen el "
"tipo :c:type:`PyCFunction`. La función espera dos valores :c:expr:"
"`PyObject*`. El primero es el objeto *self* para los métodos; para las "
"funciones de módulo, es el objeto módulo.  El segundo parámetro (a menudo "
"llamado *args*) es un objeto tupla que representa todos los argumentos. Este "
"parámetro se procesa normalmente utilizando :c:func:`PyArg_ParseTuple` o :c:"
"func:`PyArg_UnpackTuple`."

#: ../../c-api/structures.rst:293
msgid ""
"Can only be used in certain combinations with other flags: :ref:"
"`METH_VARARGS | METH_KEYWORDS <METH_VARARGS-METH_KEYWORDS>`, :ref:"
"`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-METH_KEYWORDS>` and :ref:"
"`METH_METHOD | METH_FASTCALL | METH_KEYWORDS <METH_METHOD-METH_FASTCALL-"
"METH_KEYWORDS>`."
msgstr ""
"Sólo puede utilizarse en determinadas combinaciones con otros indicadores: :"
"ref:`METH_VARARGS | METH_KEYWORDS <METH_VARARGS-METH_KEYWORDS>`, :ref:"
"`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-METH_KEYWORDS>` y :ref:"
"`METH_METHOD | METH_FASTCALL | METH_KEYWORDS <METH_METHOD-METH_FASTCALL-"
"METH_KEYWORDS>`."

#: ../../c-api/structures.rst:307
msgid ":c:expr:`METH_VARARGS | METH_KEYWORDS`"
msgstr ":c:expr:`METH_VARARGS | METH_KEYWORDS`"

#: ../../c-api/structures.rst:302
msgid ""
"Methods with these flags must be of type :c:type:`PyCFunctionWithKeywords`. "
"The function expects three parameters: *self*, *args*, *kwargs* where "
"*kwargs* is a dictionary of all the keyword arguments or possibly ``NULL`` "
"if there are no keyword arguments.  The parameters are typically processed "
"using :c:func:`PyArg_ParseTupleAndKeywords`."
msgstr ""
"Los métodos con estas banderas deben ser del tipo :c:type:"
"`PyCFunctionWithKeywords`. La función espera tres parámetros: *self*, "
"*args*, *kwargs* donde *kwargs* es un diccionario de todos los argumentos de "
"palabra clave o posiblemente ``NULL`` si no hay argumentos de palabra "
"clave.  Los parámetros se procesan normalmente utilizando :c:func:"
"`PyArg_ParseTupleAndKeywords`."

#: ../../c-api/structures.rst:311
msgid ""
"Fast calling convention supporting only positional arguments. The methods "
"have the type :c:type:`_PyCFunctionFast`. The first parameter is *self*, the "
"second parameter is a C array of :c:expr:`PyObject*` values indicating the "
"arguments and the third parameter is the number of arguments (the length of "
"the array)."
msgstr ""
"Convención de llamada rápida que sólo admite argumentos posicionales. Los "
"métodos tienen el tipo :c:type:`_PyCFunctionFast`. El primer parámetro es "
"*self*, el segundo parámetro es una matriz C de valores :c:expr:`PyObject*` "
"que indican los argumentos y el tercer parámetro es el número de argumentos "
"(la longitud de la matriz)."

#: ../../c-api/structures.rst:321
msgid "``METH_FASTCALL`` is now part of the :ref:`stable ABI <stable-abi>`."
msgstr ""
"``METH_FASTCALL`` forma parte ahora de la :ref:`stable ABI <stable-abi>`."

#: ../../c-api/structures.rst:338
msgid ":c:expr:`METH_FASTCALL | METH_KEYWORDS`"
msgstr ":c:expr:`METH_FASTCALL | METH_KEYWORDS`"

#: ../../c-api/structures.rst:327
msgid ""
"Extension of :c:macro:`METH_FASTCALL` supporting also keyword arguments, "
"with methods of type :c:type:`_PyCFunctionFastWithKeywords`. Keyword "
"arguments are passed the same way as in the :ref:`vectorcall protocol "
"<vectorcall>`: there is an additional fourth :c:expr:`PyObject*` parameter "
"which is a tuple representing the names of the keyword arguments (which are "
"guaranteed to be strings) or possibly ``NULL`` if there are no keywords.  "
"The values of the keyword arguments are stored in the *args* array, after "
"the positional arguments."
msgstr ""
"Extensión de :c:macro:`METH_FASTCALL` que admite también argumentos de "
"palabra clave, con métodos de tipo :c:type:`_PyCFunctionFastWithKeywords`. "
"Los argumentos de palabra clave se pasan de la misma forma que en el "
"protocolo :ref:`vectorcall <vectorcall>`: hay un cuarto parámetro adicional :"
"c:expr:`PyObject*` que es una tupla que representa los nombres de los "
"argumentos de palabra clave (que se garantiza que son cadenas) o "
"posiblemente ``NULL`` si no hay palabras clave.  Los valores de los "
"argumentos de palabra clave se almacenan en la matriz *args*, después de los "
"argumentos posicionales."

#: ../../c-api/structures.rst:342
msgid ""
"Can only be used in the combination with other flags: :ref:`METH_METHOD | "
"METH_FASTCALL | METH_KEYWORDS <METH_METHOD-METH_FASTCALL-METH_KEYWORDS>`."
msgstr ""
"Sólo puede utilizarse en combinación con otros indicadores: :ref:"
"`METH_METHOD | METH_FASTCALL | METH_KEYWORDS <METH_METHOD-METH_FASTCALL-"
"METH_KEYWORDS>`."

#: ../../c-api/structures.rst:359
msgid ":c:expr:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS`"
msgstr ":c:expr:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS`"

#: ../../c-api/structures.rst:349
msgid ""
"Extension of :ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-"
"METH_KEYWORDS>` supporting the *defining class*, that is, the class that "
"contains the method in question. The defining class might be a superclass of "
"``Py_TYPE(self)``."
msgstr ""
"Extensión de :ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-"
"METH_KEYWORDS>` que admite la *clase definidora*, es decir, la clase que "
"contiene el método en cuestión. La clase definidora puede ser una superclase "
"de ``Py_TYPE(self)``."

#: ../../c-api/structures.rst:354
msgid ""
"The method needs to be of type :c:type:`PyCMethod`, the same as for "
"``METH_FASTCALL | METH_KEYWORDS`` with ``defining_class`` argument added "
"after ``self``."
msgstr ""
"El método debe ser del tipo :c:type:`PyCMethod`, igual que para "
"``METH_FASTCALL | METH_KEYWORDS`` con el argumento ``defining_class`` "
"añadido después de ``self``."

#: ../../c-api/structures.rst:363
msgid ""
"Methods without parameters don't need to check whether arguments are given "
"if they are listed with the :c:macro:`METH_NOARGS` flag.  They need to be of "
"type :c:type:`PyCFunction`.  The first parameter is typically named *self* "
"and will hold a reference to the module or object instance.  In all cases "
"the second parameter will be ``NULL``."
msgstr ""
"Los métodos sin parámetros no necesitan comprobar si se dan argumentos si se "
"enumeran con la bandera :c:macro:`METH_NOARGS`.  Necesitan ser del tipo :c:"
"type:`PyCFunction`.  El primer parámetro suele llamarse *self* y contendrá "
"una referencia al módulo o a la instancia del objeto.  En todos los casos, "
"el segundo parámetro será ``NULL``."

#: ../../c-api/structures.rst:369
msgid ""
"The function must have 2 parameters. Since the second parameter is unused, :"
"c:macro:`Py_UNUSED` can be used to prevent a compiler warning."
msgstr ""
"La función debe tener 2 parámetros. Dado que el segundo parámetro no se "
"utiliza, se puede utilizar :c:macro:`Py_UNUSED` para evitar una advertencia "
"del compilador."

#: ../../c-api/structures.rst:375
msgid ""
"Methods with a single object argument can be listed with the :c:macro:"
"`METH_O` flag, instead of invoking :c:func:`PyArg_ParseTuple` with a "
"``\"O\"`` argument. They have the type :c:type:`PyCFunction`, with the "
"*self* parameter, and a :c:expr:`PyObject*` parameter representing the "
"single argument."
msgstr ""
"Los métodos con un único argumento objeto pueden listarse con la bandera :c:"
"macro:`METH_O`, en lugar de invocar :c:func:`PyArg_ParseTuple` con un "
"argumento ``\"O\"``. Tienen el tipo :c:type:`PyCFunction`, con el parámetro "
"*self*, y un parámetro :c:expr:`PyObject*` que representa el argumento único."

#: ../../c-api/structures.rst:381
msgid ""
"These two constants are not used to indicate the calling convention but the "
"binding when use with methods of classes.  These may not be used for "
"functions defined for modules.  At most one of these flags may be set for "
"any given method."
msgstr ""
"Estas dos constantes no se utilizan para indicar la convención de llamada, "
"sino la vinculación cuando se usan con métodos de clases. No se pueden usar "
"para funciones definidas en módulos. Como máximo, se puede establecer una de "
"estas banderas para cualquier método dado."

#: ../../c-api/structures.rst:391
msgid ""
"The method will be passed the type object as the first parameter rather than "
"an instance of the type.  This is used to create *class methods*, similar to "
"what is created when using the :func:`classmethod` built-in function."
msgstr ""
"El método recibirá el objeto de tipo como primer parámetro en lugar de una "
"instancia del tipo. Esto se utiliza para crear *métodos de clase*, similares "
"a los que se crean al usar la función integrada :func:`classmethod`."

#: ../../c-api/structures.rst:401
msgid ""
"The method will be passed ``NULL`` as the first parameter rather than an "
"instance of the type.  This is used to create *static methods*, similar to "
"what is created when using the :func:`staticmethod` built-in function."
msgstr ""
"Al método se le pasará ``NULL`` como primer parámetro en lugar de una "
"instancia del tipo.  Esto se utiliza para crear *métodos estáticos*, "
"similares a los que se crean cuando se utiliza la función incorporada :func:"
"`staticmethod`."

#: ../../c-api/structures.rst:405
msgid ""
"One other constant controls whether a method is loaded in place of another "
"definition with the same method name."
msgstr ""
"Otra constante controla si un método se carga en lugar de otra definición "
"con el mismo nombre de método."

#: ../../c-api/structures.rst:411
msgid ""
"The method will be loaded in place of existing definitions.  Without "
"*METH_COEXIST*, the default is to skip repeated definitions.  Since slot "
"wrappers are loaded before the method table, the existence of a "
"*sq_contains* slot, for example, would generate a wrapped method named :meth:"
"`~object.__contains__` and preclude the loading of a corresponding "
"PyCFunction with the same name.  With the flag defined, the PyCFunction will "
"be loaded in place of the wrapper object and will co-exist with the slot.  "
"This is helpful because calls to PyCFunctions are optimized more than "
"wrapper object calls."
msgstr ""
"El método se cargará en lugar de las definiciones existentes.  Sin "
"*METH_COEXIST*, por defecto se omiten las definiciones repetidas.  Dado que "
"las envolturas de ranuras se cargan antes que la tabla de métodos, la "
"existencia de una ranura *sq_contains*, por ejemplo, generaría un método "
"envuelto llamado :meth:`~object.__contains__` e impediría la carga de una "
"PyCFunction correspondiente con el mismo nombre.  Con la bandera definida, "
"la PyCFunction se cargará en lugar del objeto envoltorio y coexistirá con la "
"ranura.  Esto es útil porque las llamadas a PyCFunctions están más "
"optimizadas que las llamadas al objeto envoltorio."

#: ../../c-api/structures.rst:423
msgid ""
"Turn *ml* into a Python :term:`callable` object. The caller must ensure that "
"*ml* outlives the :term:`callable`. Typically, *ml* is defined as a static "
"variable."
msgstr ""
"Convierte *ml* en un objeto :term:`callable` de Python. El invocador debe "
"asegurarse de que *ml* sobrevive al :term:`callable`. Normalmente, *ml* se "
"define como una variable estática."

#: ../../c-api/structures.rst:427
msgid ""
"The *self* parameter will be passed as the *self* argument to the C function "
"in ``ml->ml_meth`` when invoked. *self* can be ``NULL``."
msgstr ""
"El parámetro *self* se pasará como argumento *self* a la función C en ``ml-"
">ml_meth`` cuando se invoque. *self* puede ser ``NULL``."

#: ../../c-api/structures.rst:431
msgid ""
"The :term:`callable` object's ``__module__`` attribute can be set from the "
"given *module* argument. *module* should be a Python string, which will be "
"used as name of the module the function is defined in. If unavailable, it "
"can be set to :const:`None` or ``NULL``."
msgstr ""
"El atributo ``__module__`` del objeto :term:`callable` puede establecerse a "
"partir del argumento *module* dado. *module* debe ser una cadena de Python, "
"que se utilizará como nombre del módulo en el que se define la función. Si "
"no está disponible, puede establecerse como :const:`None` o ``NULL``."

#: ../../c-api/structures.rst:437
msgid ":attr:`function.__module__`"
msgstr ":attr:`function.__module__`"

#: ../../c-api/structures.rst:439
msgid ""
"The *cls* parameter will be passed as the *defining_class* argument to the C "
"function. Must be set if :c:macro:`METH_METHOD` is set on ``ml->ml_flags``."
msgstr ""
"El parámetro *cls* se pasará como argumento *defining_class* a la función C. "
"Debe establecerse si :c:macro:`METH_METHOD` se establece en ``ml->ml_flags``."

#: ../../c-api/structures.rst:448
msgid "Equivalent to ``PyCMethod_New(ml, self, module, NULL)``."
msgstr "Equivalente a ``PyCMethod_New(ml, self, module, NULL)``."

#: ../../c-api/structures.rst:453
msgid "Equivalent to ``PyCMethod_New(ml, self, NULL, NULL)``."
msgstr "Equivalente a ``PyCMethod_New(ml, self, NULL, NULL)``."

#: ../../c-api/structures.rst:457
msgid "Accessing attributes of extension types"
msgstr "Acceso a los atributos de los tipos de extensión"

#: ../../c-api/structures.rst:461
msgid ""
"Structure which describes an attribute of a type which corresponds to a C "
"struct member.  Its fields are:"
msgstr ""

#: ../../c-api/structures.rst:465 ../../c-api/structures.rst:561
msgid "Field"
msgstr "Campo"

#: ../../c-api/structures.rst:465 ../../c-api/structures.rst:561
msgid "C Type"
msgstr "Tipo C"

#: ../../c-api/structures.rst:465 ../../c-api/structures.rst:561
msgid "Meaning"
msgstr "Significado"

#: ../../c-api/structures.rst:467
msgid ":attr:`name`"
msgstr ""

#: ../../c-api/structures.rst:467 ../../c-api/structures.rst:480
#: ../../c-api/structures.rst:496 ../../c-api/structures.rst:563
#: ../../c-api/structures.rst:571
msgid "const char \\*"
msgstr ""

#: ../../c-api/structures.rst:467
msgid "name of the member"
msgstr ""

#: ../../c-api/structures.rst:469
msgid ":attr:`!type`"
msgstr ""

#: ../../c-api/structures.rst:469 ../../c-api/structures.rst:476
#: ../../c-api/structures.rst:492
msgid "int"
msgstr "int"

#: ../../c-api/structures.rst:469
msgid "the type of the member in the C struct"
msgstr ""

#: ../../c-api/structures.rst:472
msgid ":attr:`offset`"
msgstr ""

#: ../../c-api/structures.rst:472 ../../c-api/structures.rst:508
msgid "Py_ssize_t"
msgstr ""

#: ../../c-api/structures.rst:472
msgid ""
"the offset in bytes that the member is located on the type's object struct"
msgstr ""

#: ../../c-api/structures.rst:476
msgid ":attr:`flags`"
msgstr ""

#: ../../c-api/structures.rst:476
msgid "flag bits indicating if the field should be read-only or writable"
msgstr ""

#: ../../c-api/structures.rst:480
msgid ":attr:`doc`"
msgstr ""

#: ../../c-api/structures.rst:480
msgid "points to the contents of the docstring"
msgstr ""

#: ../../c-api/structures.rst:484
msgid ""
":attr:`!type` can be one of many ``T_`` macros corresponding to various C "
"types.  When the member is accessed in Python, it will be converted to the "
"equivalent Python type."
msgstr ""

#: ../../c-api/structures.rst:489
msgid "Macro name"
msgstr "Nombre de la macro"

#: ../../c-api/structures.rst:489
msgid "C type"
msgstr "Tipo C"

#: ../../c-api/structures.rst:491
msgid "T_SHORT"
msgstr ""

#: ../../c-api/structures.rst:491
msgid "short"
msgstr ""

#: ../../c-api/structures.rst:492
msgid "T_INT"
msgstr ""

#: ../../c-api/structures.rst:493
msgid "T_LONG"
msgstr ""

#: ../../c-api/structures.rst:493
msgid "long"
msgstr "long"

#: ../../c-api/structures.rst:494
msgid "T_FLOAT"
msgstr ""

#: ../../c-api/structures.rst:494
msgid "float"
msgstr "flotante"

#: ../../c-api/structures.rst:495
msgid "T_DOUBLE"
msgstr ""

#: ../../c-api/structures.rst:495
msgid "double"
msgstr "doble"

#: ../../c-api/structures.rst:496
msgid "T_STRING"
msgstr ""

#: ../../c-api/structures.rst:497
msgid "T_OBJECT"
msgstr ""

#: ../../c-api/structures.rst:497 ../../c-api/structures.rst:498
msgid "PyObject \\*"
msgstr ""

#: ../../c-api/structures.rst:498
msgid "T_OBJECT_EX"
msgstr ""

#: ../../c-api/structures.rst:499
msgid "T_CHAR"
msgstr ""

#: ../../c-api/structures.rst:499 ../../c-api/structures.rst:500
#: ../../c-api/structures.rst:505
msgid "char"
msgstr "char"

#: ../../c-api/structures.rst:500
msgid "T_BYTE"
msgstr ""

#: ../../c-api/structures.rst:501
msgid "T_UBYTE"
msgstr ""

#: ../../c-api/structures.rst:501
msgid "unsigned char"
msgstr "unsigned char"

#: ../../c-api/structures.rst:502
msgid "T_UINT"
msgstr ""

#: ../../c-api/structures.rst:502
msgid "unsigned int"
msgstr "int sin firmar"

#: ../../c-api/structures.rst:503
msgid "T_USHORT"
msgstr ""

#: ../../c-api/structures.rst:503
msgid "unsigned short"
msgstr "corto sin signo"

#: ../../c-api/structures.rst:504
msgid "T_ULONG"
msgstr ""

#: ../../c-api/structures.rst:504
msgid "unsigned long"
msgstr "int sin firmar"

#: ../../c-api/structures.rst:505
msgid "T_BOOL"
msgstr ""

#: ../../c-api/structures.rst:506
msgid "T_LONGLONG"
msgstr ""

#: ../../c-api/structures.rst:506
msgid "long long"
msgstr ""

#: ../../c-api/structures.rst:507
msgid "T_ULONGLONG"
msgstr ""

#: ../../c-api/structures.rst:507
msgid "unsigned long long"
msgstr "sin firmar long long"

#: ../../c-api/structures.rst:508
msgid "T_PYSSIZET"
msgstr ""

#: ../../c-api/structures.rst:511
msgid ""
":c:macro:`T_OBJECT` and :c:macro:`T_OBJECT_EX` differ in that :c:macro:"
"`T_OBJECT` returns ``None`` if the member is ``NULL`` and :c:macro:"
"`T_OBJECT_EX` raises an :exc:`AttributeError`.  Try to use :c:macro:"
"`T_OBJECT_EX` over :c:macro:`T_OBJECT` because :c:macro:`T_OBJECT_EX` "
"handles use of the :keyword:`del` statement on that attribute more correctly "
"than :c:macro:`T_OBJECT`."
msgstr ""

#: ../../c-api/structures.rst:518
msgid ""
":attr:`flags` can be ``0`` for write and read access or :c:macro:`READONLY` "
"for read-only access.  Using :c:macro:`T_STRING` for :attr:`type` implies :c:"
"macro:`READONLY`.  :c:macro:`T_STRING` data is interpreted as UTF-8. Only :c:"
"macro:`T_OBJECT` and :c:macro:`T_OBJECT_EX` members can be deleted.  (They "
"are set to ``NULL``)."
msgstr ""

#: ../../c-api/structures.rst:526
msgid ""
"Heap allocated types (created using :c:func:`PyType_FromSpec` or similar), "
"``PyMemberDef`` may contain definitions for the special members "
"``__dictoffset__``, ``__weaklistoffset__`` and ``__vectorcalloffset__``, "
"corresponding to :c:member:`~PyTypeObject.tp_dictoffset`, :c:member:"
"`~PyTypeObject.tp_weaklistoffset` and :c:member:`~PyTypeObject."
"tp_vectorcall_offset` in type objects. These must be defined with "
"``T_PYSSIZET`` and ``READONLY``, for example::"
msgstr ""

#: ../../c-api/structures.rst:543
msgid ""
"Get an attribute belonging to the object at address *obj_addr*.  The "
"attribute is described by ``PyMemberDef`` *m*.  Returns ``NULL`` on error."
msgstr ""
"Obtener un atributo perteneciente al objeto en la dirección *obj_addr*.  El "
"atributo se describe en ``PyMemberDef`` *m*.  Devuelve ``NULL`` en caso de "
"error."

#: ../../c-api/structures.rst:550
msgid ""
"Set an attribute belonging to the object at address *obj_addr* to object "
"*o*. The attribute to set is described by ``PyMemberDef`` *m*.  Returns "
"``0`` if successful and a negative value on failure."
msgstr ""
"Establece un atributo perteneciente al objeto en la dirección *obj_addr* al "
"objeto *o*. El atributo a establecer se describe en ``PyMemberDef`` *m*.  "
"Devuelve ``0`` si tiene éxito y un valor negativo en caso de fallo."

#: ../../c-api/structures.rst:557
msgid ""
"Structure to define property-like access for a type. See also description of "
"the :c:member:`PyTypeObject.tp_getset` slot."
msgstr ""
"Estructura para definir el acceso tipo propiedad para un tipo. Véase también "
"la descripción de la ranura :c:member:`PyTypeObject.tp_getset`."

#: ../../c-api/structures.rst:563
msgid "name"
msgstr "nombre"

#: ../../c-api/structures.rst:563
msgid "attribute name"
msgstr "nombre de atributo"

#: ../../c-api/structures.rst:565
msgid "get"
msgstr ""

#: ../../c-api/structures.rst:565
msgid "getter"
msgstr ""

#: ../../c-api/structures.rst:565
msgid "C function to get the attribute"
msgstr ""

#: ../../c-api/structures.rst:567
msgid "set"
msgstr "conjunto"

#: ../../c-api/structures.rst:567
msgid "setter"
msgstr ""

#: ../../c-api/structures.rst:567
msgid ""
"optional C function to set or delete the attribute, if omitted the attribute "
"is readonly"
msgstr ""

#: ../../c-api/structures.rst:571
msgid "doc"
msgstr ""

#: ../../c-api/structures.rst:571
msgid "optional docstring"
msgstr "docstring opcional"

#: ../../c-api/structures.rst:573
msgid "closure"
msgstr ""

#: ../../c-api/structures.rst:573
msgid "void \\*"
msgstr ""

#: ../../c-api/structures.rst:573
msgid ""
"optional user data pointer, providing additional data for getter and setter"
msgstr ""

#: ../../c-api/structures.rst:578
msgid ""
"The ``get`` function takes one :c:expr:`PyObject*` parameter (the instance) "
"and a user data pointer (the associated ``closure``)::"
msgstr ""

#: ../../c-api/structures.rst:583
msgid ""
"It should return a new reference on success or ``NULL`` with a set exception "
"on failure."
msgstr ""
"Debe devolver una nueva referencia en caso de éxito o ``NULL`` con una "
"excepción establecida en caso de fallo."

#: ../../c-api/structures.rst:586
msgid ""
"``set`` functions take two :c:expr:`PyObject*` parameters (the instance and "
"the value to be set) and a user data pointer (the associated ``closure``)::"
msgstr ""

#: ../../c-api/structures.rst:591
msgid ""
"In case the attribute should be deleted the second parameter is ``NULL``. "
"Should return ``0`` on success or ``-1`` with a set exception on failure."
msgstr ""
"En caso de que el atributo se deba borrar el segundo parámetro es ``NULL``. "
"Debe devolver ``0`` en caso de éxito o ``-1`` con una excepción establecida "
"en caso de fallo."

#: ../../c-api/structures.rst:389 ../../c-api/structures.rst:399
msgid "built-in function"
msgstr "función incorporada"

#: ../../c-api/structures.rst:389
msgid "classmethod"
msgstr "classmethod"

#: ../../c-api/structures.rst:399
msgid "staticmethod"
msgstr "método estático"
