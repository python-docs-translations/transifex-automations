# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# eulalio barbero espinosa <eulalio@disroot.org>, 2023
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-10 16:06+0000\n"
"PO-Revision-Date: 2022-11-05 17:21+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Spanish (Spain) (https://app.transifex.com/python-doc/"
"teams/5390/es_ES/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es_ES\n"
"Plural-Forms: nplurals=3; plural=n == 1 ? 0 : n != 0 && n % 1000000 == 0 ? "
"1 : 2;\n"

#: ../../c-api/structures.rst:6
msgid "Common Object Structures"
msgstr "Estructuras de objetos comunes"

#: ../../c-api/structures.rst:8
msgid ""
"There are a large number of structures which are used in the definition of "
"object types for Python.  This section describes these structures and how "
"they are used."
msgstr ""
"Hay un gran número de estructuras que se utilizan en la definición de tipos "
"de objetos para Python.  Esta sección describe estas estructuras y cómo se "
"utilizan."

#: ../../c-api/structures.rst:14
msgid "Base object types and macros"
msgstr "Tipos de objetos base y macros"

#: ../../c-api/structures.rst:16
msgid ""
"All Python objects ultimately share a small number of fields at the "
"beginning of the object's representation in memory.  These are represented "
"by the :c:type:`PyObject` and :c:type:`PyVarObject` types, which are "
"defined, in turn, by the expansions of some macros also used, whether "
"directly or indirectly, in the definition of all other Python objects."
msgstr ""
"Todos los objetos Python comparten, en última instancia, un pequeño número "
"de campos al principio de la representación del objeto en memoria.  Éstos "
"están representados por los tipos :c:type:`PyObject` y :c:type:"
"`PyVarObject`, definidos, a su vez, por las expansiones de algunas macros "
"utilizadas también, directa o indirectamente, en la definición de todos los "
"demás objetos Python."

#: ../../c-api/structures.rst:25
msgid ""
"All object types are extensions of this type.  This is a type which contains "
"the information Python needs to treat a pointer to an object as an object.  "
"In a normal \"release\" build, it contains only the object's reference count "
"and a pointer to the corresponding type object. Nothing is actually declared "
"to be a :c:type:`PyObject`, but every pointer to a Python object can be cast "
"to a :c:expr:`PyObject*`.  Access to the members must be done by using the "
"macros :c:macro:`Py_REFCNT` and :c:macro:`Py_TYPE`."
msgstr ""
"Todos los tipos de objeto son extensiones de este tipo.  Es un tipo que "
"contiene la información que Python necesita para tratar un puntero a un "
"objeto como un objeto.  En una construcción normal de \"liberación\", sólo "
"contiene el recuento de referencias del objeto y un puntero al objeto de "
"tipo correspondiente. En realidad, nada se declara como un :c:type:"
"`PyObject`, pero todo puntero a un objeto Python puede ser lanzado a un :c:"
"expr:`PyObject*`. El acceso a los miembros debe hacerse utilizando las "
"macros :c:macro:`Py_REFCNT` y :c:macro:`Py_TYPE`."

#: ../../c-api/structures.rst:37
msgid ""
"This is an extension of :c:type:`PyObject` that adds the :attr:`ob_size` "
"field.  This is only used for objects that have some notion of *length*. "
"This type does not often appear in the Python/C API. Access to the members "
"must be done by using the macros :c:macro:`Py_REFCNT`, :c:macro:`Py_TYPE`, "
"and :c:macro:`Py_SIZE`."
msgstr ""
"Esta es una extensión de :c:type:`PyObject` que agrega el campo :attr:"
"`ob_size`. Esto solo se utiliza para objetos que tienen alguna noción de "
"*longitud*. Este tipo no aparece a menudo en la API de Python/C. El acceso a "
"los miembros debe hacerse utilizando las macros :c:macro:`Py_REFCNT`, :c:"
"macro:`Py_TYPE` y :c:macro:`Py_SIZE`."

#: ../../c-api/structures.rst:46
msgid ""
"This is a macro used when declaring new types which represent objects "
"without a varying length.  The PyObject_HEAD macro expands to::"
msgstr ""
"Este es un macro utilizado al declarar nuevos tipos que representan objetos "
"sin una longitud variable. El macro PyObject_HEAD se expande a:"

#: ../../c-api/structures.rst:51
msgid "See documentation of :c:type:`PyObject` above."
msgstr "Ver documentación de :c:type:`PyObject` arriba."

#: ../../c-api/structures.rst:56
msgid ""
"This is a macro used when declaring new types which represent objects with a "
"length that varies from instance to instance. The PyObject_VAR_HEAD macro "
"expands to::"
msgstr ""
"Este es un macro utilizado al declarar nuevos tipos que representan objetos "
"con una longitud que varía de instancia a instancia. El macro "
"PyObject_VAR_HEAD se expande a:"

#: ../../c-api/structures.rst:62
msgid "See documentation of :c:type:`PyVarObject` above."
msgstr "Ver documentación de :c:type:`PyVarObject` arriba."

#: ../../c-api/structures.rst:67
msgid ""
"Test if the *x* object is the *y* object, the same as ``x is y`` in Python."
msgstr ""
"Prueba si el objeto *x* es el objeto *y*, igual que ``x is y`` en Python."

#: ../../c-api/structures.rst:74
msgid ""
"Test if an object is the ``None`` singleton, the same as ``x is None`` in "
"Python."
msgstr ""
"Prueba si un objeto es el singleton ``None``, lo mismo que ``x is None`` en "
"Python."

#: ../../c-api/structures.rst:82
msgid ""
"Test if an object is the ``True`` singleton, the same as ``x is True`` in "
"Python."
msgstr ""
"Prueba si un objeto es el singleton ``True``, lo mismo que ``x is True`` en "
"Python."

#: ../../c-api/structures.rst:90
msgid ""
"Test if an object is the ``False`` singleton, the same as ``x is False`` in "
"Python."
msgstr ""
"Prueba si un objeto es el singleton ``False``, lo mismo que ``x is False`` "
"en Python."

#: ../../c-api/structures.rst:98
msgid "Get the type of the Python object *o*."
msgstr "Obtener el tipo del objeto Python *o*."

#: ../../c-api/structures.rst:100
msgid "Return a :term:`borrowed reference`."
msgstr "Devuelve un :term:`borrowed reference`."

#: ../../c-api/structures.rst:102
msgid "Use the :c:func:`Py_SET_TYPE` function to set an object type."
msgstr ""
"Utilice la función :c:func:`Py_SET_TYPE` para establecer un tipo de objeto."

#: ../../c-api/structures.rst:107
msgid ""
"Return non-zero if the object *o* type is *type*. Return zero otherwise. "
"Equivalent to: ``Py_TYPE(o) == type``."
msgstr ""
"Devuelve un valor distinto de cero si el tipo del objeto *o* es *type*. "
"Devuelve cero en caso contrario. Equivalente a: ``Py_TYPE(o) == type``."

#: ../../c-api/structures.rst:115
msgid "Set the object *o* type to *type*."
msgstr "Establece el tipo del objeto *o* en *tipo*."

#: ../../c-api/structures.rst:122
msgid "Get the reference count of the Python object *o*."
msgstr "Obtiene el recuento de referencias del objeto Python *o*."

#: ../../c-api/structures.rst:124
msgid ""
":c:func:`Py_REFCNT()` is changed to the inline static function. Use :c:func:"
"`Py_SET_REFCNT()` to set an object reference count."
msgstr ""
":c:func:`Py_REFCNT()` se cambia a la función estática en línea. Usar :c:func:"
"`Py_SET_REFCNT()` para establecer un recuento de referencias a objetos."

#: ../../c-api/structures.rst:131
msgid "Set the object *o* reference counter to *refcnt*."
msgstr "Establecer el contador de referencia del objeto *o* a *refcnt*."

#: ../../c-api/structures.rst:138
msgid "Get the size of the Python object *o*."
msgstr "Obtener el tamaño del objeto Python *o*."

#: ../../c-api/structures.rst:140
msgid "Use the :c:func:`Py_SET_SIZE` function to set an object size."
msgstr ""
"Utilice la función :c:func:`Py_SET_SIZE` para establecer el tamaño de un "
"objeto."

#: ../../c-api/structures.rst:145
msgid "Set the object *o* size to *size*."
msgstr "Establece el tamaño del objeto *o* en *tamaño*."

#: ../../c-api/structures.rst:152
msgid ""
"This is a macro which expands to initialization values for a new :c:type:"
"`PyObject` type.  This macro expands to::"
msgstr ""
"Esta es una macro que se expande a valores de inicialización para un nuevo "
"tipo :c:type:`PyObject`.  Esta macro se expande a::"

#: ../../c-api/structures.rst:161
msgid ""
"This is a macro which expands to initialization values for a new :c:type:"
"`PyVarObject` type, including the :attr:`ob_size` field. This macro expands "
"to::"
msgstr ""
"Se trata de una macro que se expande a valores de inicialización para un "
"nuevo tipo :c:type:`PyVarObject`, incluido el campo :attr:`ob_size`. Esta "
"macro se expande a::"

#: ../../c-api/structures.rst:170
msgid "Implementing functions and methods"
msgstr "Implementación de funciones y métodos"

#: ../../c-api/structures.rst:174
msgid ""
"Type of the functions used to implement most Python callables in C. "
"Functions of this type take two :c:expr:`PyObject*` parameters and return "
"one such value.  If the return value is ``NULL``, an exception shall have "
"been set.  If not ``NULL``, the return value is interpreted as the return "
"value of the function as exposed in Python.  The function must return a new "
"reference."
msgstr ""
"Tipo de las funciones utilizadas para implementar la mayoría de las llamadas "
"Python en C. Las funciones de este tipo toman dos parámetros :c:expr:"
"`PyObject*` y devuelven un valor de este tipo.  Si el valor de retorno es "
"``NULL``, se habrá establecido una excepción.  Si no es ``NULL``, el valor "
"de retorno se interpreta como el valor de retorno de la función tal y como "
"se expone en Python.  La función debe devolver una nueva referencia."

#: ../../c-api/structures.rst:181
msgid "The function signature is::"
msgstr "La firma de la función es::"

#: ../../c-api/structures.rst:188
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :const:`METH_VARARGS | METH_KEYWORDS`. The function signature is::"
msgstr ""
"Tipo de las funciones utilizadas para implementar callables de Python en C "
"con firma :const:`METH_VARARGS | METH_KEYWORDS`. La firma de la función es::"

#: ../../c-api/structures.rst:199
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :const:`METH_FASTCALL`. The function signature is::"
msgstr ""
"Tipo de funciones utilizadas para implementar llamables de Python en C con "
"la firma :const:`METH_FASTCALL`. La firma de la función es::"

#: ../../c-api/structures.rst:209
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :const:`METH_FASTCALL | METH_KEYWORDS`. The function signature is::"
msgstr ""
"Tipo de las funciones utilizadas para implementar callables de Python en C "
"con firma :const:`METH_FASTCALL | METH_KEYWORDS`. La firma de la función es::"

#: ../../c-api/structures.rst:220
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :const:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS`. The function "
"signature is::"
msgstr ""
"Tipo de las funciones utilizadas para implementar callables de Python en C "
"con firma :const:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS`. La firma de "
"la función es::"

#: ../../c-api/structures.rst:235
msgid ""
"Structure used to describe a method of an extension type.  This structure "
"has four fields:"
msgstr ""
"Estructura utilizada para describir un método de un tipo de extensión.  Esta "
"estructura tiene cuatro campos:"

#: ../../c-api/structures.rst:240
msgid "name of the method"
msgstr "nombre del método"

#: ../../c-api/structures.rst:244
msgid "pointer to the C implementation"
msgstr "puntero a la implementación C"

#: ../../c-api/structures.rst:248
msgid "flags bits indicating how the call should be constructed"
msgstr "flags bits que indican cómo debe construirse la llamada"

#: ../../c-api/structures.rst:252 ../../c-api/structures.rst:411
msgid "points to the contents of the docstring"
msgstr "apunta al contenido del docstring"

#: ../../c-api/structures.rst:254
msgid ""
"The :c:member:`ml_meth` is a C function pointer.  The functions may be of "
"different types, but they always return :c:expr:`PyObject*`.  If the "
"function is not of the :c:type:`PyCFunction`, the compiler will require a "
"cast in the method table. Even though :c:type:`PyCFunction` defines the "
"first parameter as :c:expr:`PyObject*`, it is common that the method "
"implementation uses the specific C type of the *self* object."
msgstr ""
"El :c:member:`ml_meth` es un puntero a una función C. Las funciones pueden "
"ser de diferentes tipos, pero siempre devuelven :c:expr:`PyObject*`. Si la "
"función no es del tipo :c:type:`PyCFunction`, el compilador requerirá una "
"conversión en la tabla de métodos. Aunque :c:type:`PyCFunction` define el "
"primer parámetro como :c:expr:`PyObject*`, es común que la implementación "
"del método utilice el tipo C específico del objeto *self*."

#: ../../c-api/structures.rst:261
msgid ""
"The :c:member:`ml_flags` field is a bitfield which can include the following "
"flags. The individual flags indicate either a calling convention or a "
"binding convention."
msgstr ""
"El campo :c:member:`ml_flags` es un campo de bits que puede incluir los "
"siguientes indicadores. Las banderas individuales indican una convención de "
"llamada o una convención de enlace."

#: ../../c-api/structures.rst:265
msgid "There are these calling conventions:"
msgstr "Existen estas convenciones de llamada:"

#: ../../c-api/structures.rst:269
msgid ""
"This is the typical calling convention, where the methods have the type :c:"
"type:`PyCFunction`. The function expects two :c:expr:`PyObject*` values. The "
"first one is the *self* object for methods; for module functions, it is the "
"module object.  The second parameter (often called *args*) is a tuple object "
"representing all arguments. This parameter is typically processed using :c:"
"func:`PyArg_ParseTuple` or :c:func:`PyArg_UnpackTuple`."
msgstr ""
"Esta es la convención de llamada típica, en la que los métodos tienen el "
"tipo :c:type:`PyCFunction`. La función espera dos valores :c:expr:"
"`PyObject*`. El primero es el objeto *self* para los métodos; para las "
"funciones de módulo, es el objeto módulo.  El segundo parámetro (a menudo "
"llamado *args*) es un objeto tupla que representa todos los argumentos. Este "
"parámetro se procesa normalmente utilizando :c:func:`PyArg_ParseTuple` o :c:"
"func:`PyArg_UnpackTuple`."

#: ../../c-api/structures.rst:279
msgid ""
"Methods with these flags must be of type :c:type:`PyCFunctionWithKeywords`. "
"The function expects three parameters: *self*, *args*, *kwargs* where "
"*kwargs* is a dictionary of all the keyword arguments or possibly ``NULL`` "
"if there are no keyword arguments.  The parameters are typically processed "
"using :c:func:`PyArg_ParseTupleAndKeywords`."
msgstr ""
"Los métodos con estas banderas deben ser del tipo :c:type:"
"`PyCFunctionWithKeywords`. La función espera tres parámetros: *self*, "
"*args*, *kwargs* donde *kwargs* es un diccionario de todos los argumentos de "
"palabra clave o posiblemente ``NULL`` si no hay argumentos de palabra "
"clave.  Los parámetros se procesan normalmente utilizando :c:func:"
"`PyArg_ParseTupleAndKeywords`."

#: ../../c-api/structures.rst:288
msgid ""
"Fast calling convention supporting only positional arguments. The methods "
"have the type :c:type:`_PyCFunctionFast`. The first parameter is *self*, the "
"second parameter is a C array of :c:expr:`PyObject*` values indicating the "
"arguments and the third parameter is the number of arguments (the length of "
"the array)."
msgstr ""
"Convención de llamada rápida que sólo admite argumentos posicionales. Los "
"métodos tienen el tipo :c:type:`_PyCFunctionFast`. El primer parámetro es "
"*self*, el segundo parámetro es una matriz C de valores :c:expr:`PyObject*` "
"que indican los argumentos y el tercer parámetro es el número de argumentos "
"(la longitud de la matriz)."

#: ../../c-api/structures.rst:298
msgid "``METH_FASTCALL`` is now part of the stable ABI."
msgstr "``METH_FASTCALL`` ya forma parte del ABI estable."

#: ../../c-api/structures.rst:303
msgid ""
"Extension of :const:`METH_FASTCALL` supporting also keyword arguments, with "
"methods of type :c:type:`_PyCFunctionFastWithKeywords`. Keyword arguments "
"are passed the same way as in the :ref:`vectorcall protocol <vectorcall>`: "
"there is an additional fourth :c:expr:`PyObject*` parameter which is a tuple "
"representing the names of the keyword arguments (which are guaranteed to be "
"strings) or possibly ``NULL`` if there are no keywords.  The values of the "
"keyword arguments are stored in the *args* array, after the positional "
"arguments."
msgstr ""
"Extensión de :const:`METH_FASTCALL` que admite también argumentos de palabra "
"clave, con métodos de tipo :c:type:`_PyCFunctionFastWithKeywords`. Los "
"argumentos de palabra clave se pasan de la misma forma que en el protocolo :"
"ref:`vectorcall <vectorcall>`: hay un cuarto parámetro adicional :c:expr:"
"`PyObject*` que es una tupla que representa los nombres de los argumentos de "
"palabra clave (que se garantiza que son cadenas) o posiblemente ``NULL`` si "
"no hay palabras clave.  Los valores de los argumentos de palabra clave se "
"almacenan en la matriz *args*, después de los argumentos posicionales."

#: ../../c-api/structures.rst:318
msgid ""
"Extension of :const:`METH_FASTCALL | METH_KEYWORDS` supporting the *defining "
"class*, that is, the class that contains the method in question. The "
"defining class might be a superclass of ``Py_TYPE(self)``."
msgstr ""
"Extensión de :const:`METH_FASTCALL | METH_KEYWORDS` que admite la *clase "
"definidora*, es decir, la clase que contiene el método en cuestión. La clase "
"definidora puede ser una superclase de ``Py_TYPE(self)``."

#: ../../c-api/structures.rst:322
msgid ""
"The method needs to be of type :c:type:`PyCMethod`, the same as for "
"``METH_FASTCALL | METH_KEYWORDS`` with ``defining_class`` argument added "
"after ``self``."
msgstr ""
"El método debe ser del tipo :c:type:`PyCMethod`, igual que para "
"``METH_FASTCALL | METH_KEYWORDS`` con el argumento ``defining_class`` "
"añadido después de ``self``."

#: ../../c-api/structures.rst:331
msgid ""
"Methods without parameters don't need to check whether arguments are given "
"if they are listed with the :const:`METH_NOARGS` flag.  They need to be of "
"type :c:type:`PyCFunction`.  The first parameter is typically named *self* "
"and will hold a reference to the module or object instance.  In all cases "
"the second parameter will be ``NULL``."
msgstr ""
"Los métodos sin parámetros no necesitan verificar si se proporcionan "
"argumentos si se enumeran con la bandera :const:`METH_NOARGS`. Deben ser del "
"tipo :c:type:`PyCFunction`. El primer parámetro generalmente se llama *self* "
"y contendrá una referencia al módulo o instancia del objeto. En todos los "
"casos, el segundo parámetro será ``NULL``."

#: ../../c-api/structures.rst:340
msgid ""
"Methods with a single object argument can be listed with the :const:`METH_O` "
"flag, instead of invoking :c:func:`PyArg_ParseTuple` with a ``\"O\"`` "
"argument. They have the type :c:type:`PyCFunction`, with the *self* "
"parameter, and a :c:expr:`PyObject*` parameter representing the single "
"argument."
msgstr ""
"Los métodos con un único argumento de objeto se pueden enumerar con la "
"bandera :const:`METH_O`, en lugar de invocar :c:func:`PyArg_ParseTuple` con "
"un argumento ``\"O\"``. Tienen el tipo :c:type:`PyCFunction`, con el "
"parámetro *self* y un parámetro :c:expr:`PyObject*` que representa el único "
"argumento."

#: ../../c-api/structures.rst:346
msgid ""
"These two constants are not used to indicate the calling convention but the "
"binding when use with methods of classes.  These may not be used for "
"functions defined for modules.  At most one of these flags may be set for "
"any given method."
msgstr ""
"Estas dos constantes no se utilizan para indicar la convención de llamada, "
"sino la vinculación cuando se usan con métodos de clases. No se pueden usar "
"para funciones definidas en módulos. Como máximo, se puede establecer una de "
"estas banderas para cualquier método dado."

#: ../../c-api/structures.rst:356
msgid ""
"The method will be passed the type object as the first parameter rather than "
"an instance of the type.  This is used to create *class methods*, similar to "
"what is created when using the :func:`classmethod` built-in function."
msgstr ""
"El método recibirá el objeto de tipo como primer parámetro en lugar de una "
"instancia del tipo. Esto se utiliza para crear *métodos de clase*, similares "
"a los que se crean al usar la función integrada :func:`classmethod`."

#: ../../c-api/structures.rst:366
msgid ""
"The method will be passed ``NULL`` as the first parameter rather than an "
"instance of the type.  This is used to create *static methods*, similar to "
"what is created when using the :func:`staticmethod` built-in function."
msgstr ""
"Al método se le pasará ``NULL`` como primer parámetro en lugar de una "
"instancia del tipo.  Esto se utiliza para crear *métodos estáticos*, "
"similares a los que se crean cuando se utiliza la función incorporada :func:"
"`staticmethod`."

#: ../../c-api/structures.rst:370
msgid ""
"One other constant controls whether a method is loaded in place of another "
"definition with the same method name."
msgstr ""
"Otra constante controla si un método se carga en lugar de otra definición "
"con el mismo nombre de método."

#: ../../c-api/structures.rst:376
msgid ""
"The method will be loaded in place of existing definitions.  Without "
"*METH_COEXIST*, the default is to skip repeated definitions.  Since slot "
"wrappers are loaded before the method table, the existence of a "
"*sq_contains* slot, for example, would generate a wrapped method named :meth:"
"`__contains__` and preclude the loading of a corresponding PyCFunction with "
"the same name.  With the flag defined, the PyCFunction will be loaded in "
"place of the wrapper object and will co-exist with the slot.  This is "
"helpful because calls to PyCFunctions are optimized more than wrapper object "
"calls."
msgstr ""
"El método se cargará en lugar de las definiciones existentes.  Sin "
"*METH_COEXIST*, por defecto se omiten las definiciones repetidas.  Dado que "
"las envolturas de ranuras se cargan antes que la tabla de métodos, la "
"existencia de una ranura *sq_contains*, por ejemplo, generaría un método "
"envuelto llamado :meth:`__contains__` e impediría la carga de una "
"PyCFunction correspondiente con el mismo nombre.  Con la bandera definida, "
"la PyCFunction se cargará en lugar del objeto envoltorio y coexistirá con la "
"ranura.  Esto es útil porque las llamadas a PyCFunctions están más "
"optimizadas que las llamadas al objeto envoltorio."

#: ../../c-api/structures.rst:388
msgid "Accessing attributes of extension types"
msgstr "Acceso a los atributos de los tipos de extensión"

#: ../../c-api/structures.rst:392
msgid ""
"Structure which describes an attribute of a type which corresponds to a C "
"struct member.  Its fields are:"
msgstr ""
"Estructura que describe un atributo de un tipo que corresponde a un miembro "
"de una estructura C. Sus campos son:"

#: ../../c-api/structures.rst:396 ../../c-api/structures.rst:492
msgid "Field"
msgstr "Campo"

#: ../../c-api/structures.rst:396 ../../c-api/structures.rst:492
msgid "C Type"
msgstr "Tipo C"

#: ../../c-api/structures.rst:396 ../../c-api/structures.rst:492
msgid "Meaning"
msgstr "Significado"

#: ../../c-api/structures.rst:398
msgid ":attr:`name`"
msgstr ":attr:`name`"

#: ../../c-api/structures.rst:398 ../../c-api/structures.rst:411
#: ../../c-api/structures.rst:427 ../../c-api/structures.rst:494
#: ../../c-api/structures.rst:502
msgid "const char \\*"
msgstr "const char \\*"

#: ../../c-api/structures.rst:398
msgid "name of the member"
msgstr "nombre del miembro"

#: ../../c-api/structures.rst:400
msgid ":attr:`!type`"
msgstr ":attr:`!type`"

#: ../../c-api/structures.rst:400 ../../c-api/structures.rst:407
#: ../../c-api/structures.rst:423
msgid "int"
msgstr "int"

#: ../../c-api/structures.rst:400
msgid "the type of the member in the C struct"
msgstr "el tipo del miembro en la estructura C"

#: ../../c-api/structures.rst:403
msgid ":attr:`offset`"
msgstr ":attr:`offset`"

#: ../../c-api/structures.rst:403 ../../c-api/structures.rst:439
msgid "Py_ssize_t"
msgstr "Py_ssize_t"

#: ../../c-api/structures.rst:403
msgid ""
"the offset in bytes that the member is located on the type's object struct"
msgstr ""
"el desplazamiento en bytes en el que se encuentra el miembro en la "
"estructura del objeto del tipo"

#: ../../c-api/structures.rst:407
msgid ":attr:`flags`"
msgstr ":attr:`flags`"

#: ../../c-api/structures.rst:407
msgid "flag bits indicating if the field should be read-only or writable"
msgstr ""
"bits de bandera que indican si el campo debe ser de solo lectura o editable"

#: ../../c-api/structures.rst:411
msgid ":attr:`doc`"
msgstr ":attr:`doc`"

#: ../../c-api/structures.rst:415
msgid ""
":attr:`!type` can be one of many ``T_`` macros corresponding to various C "
"types.  When the member is accessed in Python, it will be converted to the "
"equivalent Python type."
msgstr ""
":attr:`!type` puede ser una de las muchas macros de ``T_`` correspondientes "
"a varios tipos de C.  Cuando se accede al miembro en Python, se convertirá "
"al tipo Python equivalente."

#: ../../c-api/structures.rst:420
msgid "Macro name"
msgstr "Nombre de la macro"

#: ../../c-api/structures.rst:420
msgid "C type"
msgstr "Tipo C"

#: ../../c-api/structures.rst:422
msgid "T_SHORT"
msgstr "T_SHORT"

#: ../../c-api/structures.rst:422
msgid "short"
msgstr "corto"

#: ../../c-api/structures.rst:423
msgid "T_INT"
msgstr "T_INT"

#: ../../c-api/structures.rst:424
msgid "T_LONG"
msgstr "T_LARGO"

#: ../../c-api/structures.rst:424
msgid "long"
msgstr "long"

#: ../../c-api/structures.rst:425
msgid "T_FLOAT"
msgstr "T_FLOAT"

#: ../../c-api/structures.rst:425
msgid "float"
msgstr "flotante"

#: ../../c-api/structures.rst:426
msgid "T_DOUBLE"
msgstr "T_DOUBLE"

#: ../../c-api/structures.rst:426
msgid "double"
msgstr "doble"

#: ../../c-api/structures.rst:427
msgid "T_STRING"
msgstr "T_STRING"

#: ../../c-api/structures.rst:428
msgid "T_OBJECT"
msgstr "T_OBJECT"

#: ../../c-api/structures.rst:428 ../../c-api/structures.rst:429
msgid "PyObject \\*"
msgstr "PyObject \\*"

#: ../../c-api/structures.rst:429
msgid "T_OBJECT_EX"
msgstr "T_OBJECT_EX"

#: ../../c-api/structures.rst:430
msgid "T_CHAR"
msgstr "T_CHAR"

#: ../../c-api/structures.rst:430 ../../c-api/structures.rst:431
#: ../../c-api/structures.rst:436
msgid "char"
msgstr "char"

#: ../../c-api/structures.rst:431
msgid "T_BYTE"
msgstr "T_BYTE"

#: ../../c-api/structures.rst:432
msgid "T_UBYTE"
msgstr "T_UBYTE"

#: ../../c-api/structures.rst:432
msgid "unsigned char"
msgstr "unsigned char"

#: ../../c-api/structures.rst:433
msgid "T_UINT"
msgstr "T_UINT"

#: ../../c-api/structures.rst:433
msgid "unsigned int"
msgstr "int sin firmar"

#: ../../c-api/structures.rst:434
msgid "T_USHORT"
msgstr "T_USHORT"

#: ../../c-api/structures.rst:434
msgid "unsigned short"
msgstr "corto sin signo"

#: ../../c-api/structures.rst:435
msgid "T_ULONG"
msgstr "T_ULONG"

#: ../../c-api/structures.rst:435
msgid "unsigned long"
msgstr "int sin firmar"

#: ../../c-api/structures.rst:436
msgid "T_BOOL"
msgstr "T_BOOL"

#: ../../c-api/structures.rst:437
msgid "T_LONGLONG"
msgstr "T_LONGLONG"

#: ../../c-api/structures.rst:437
msgid "long long"
msgstr "long long"

#: ../../c-api/structures.rst:438
msgid "T_ULONGLONG"
msgstr "T_ULONGLONG"

#: ../../c-api/structures.rst:438
msgid "unsigned long long"
msgstr "sin firmar long long"

#: ../../c-api/structures.rst:439
msgid "T_PYSSIZET"
msgstr "T_PYSSIZET"

#: ../../c-api/structures.rst:442
msgid ""
":c:macro:`T_OBJECT` and :c:macro:`T_OBJECT_EX` differ in that :c:macro:"
"`T_OBJECT` returns ``None`` if the member is ``NULL`` and :c:macro:"
"`T_OBJECT_EX` raises an :exc:`AttributeError`.  Try to use :c:macro:"
"`T_OBJECT_EX` over :c:macro:`T_OBJECT` because :c:macro:`T_OBJECT_EX` "
"handles use of the :keyword:`del` statement on that attribute more correctly "
"than :c:macro:`T_OBJECT`."
msgstr ""
":c:macro:`T_OBJECT` y :c:macro:`T_OBJECT_EX` se diferencian en que :c:macro:"
"`T_OBJECT` devuelve ``None`` si el miembro es ``NULL`` y :c:macro:"
"`T_OBJECT_EX` genera un :exc:`AttributeError`. Intentar utilizar :c:macro:"
"`T_OBJECT_EX` en lugar de :c:macro:`T_OBJECT` porque :c:macro:`T_OBJECT_EX` "
"gestiona el uso de la sentencia :keyword:`del` en ese atributo más "
"correctamente que :c:macro:`T_OBJECT`."

#: ../../c-api/structures.rst:449
msgid ""
":attr:`flags` can be ``0`` for write and read access or :c:macro:`READONLY` "
"for read-only access.  Using :c:macro:`T_STRING` for :attr:`type` implies :c:"
"macro:`READONLY`.  :c:macro:`T_STRING` data is interpreted as UTF-8. Only :c:"
"macro:`T_OBJECT` and :c:macro:`T_OBJECT_EX` members can be deleted.  (They "
"are set to ``NULL``)."
msgstr ""
":attr:`flags` puede ser ``0`` para acceso de escritura y lectura o :c:macro:"
"`READONLY` para acceso de sólo lectura.  El uso de :c:macro:`T_STRING` para :"
"attr:`type` implica :c:macro:`READONLY`. Los datos de :c:macro:`T_STRING` se "
"interpretan como UTF-8. Sólo pueden borrarse los miembros :c:macro:"
"`T_OBJECT` y :c:macro:`T_OBJECT_EX`.  (Se establecen en ``NULL``)."

#: ../../c-api/structures.rst:457
msgid ""
"Heap allocated types (created using :c:func:`PyType_FromSpec` or similar), "
"``PyMemberDef`` may contain definitions for the special members "
"``__dictoffset__``, ``__weaklistoffset__`` and ``__vectorcalloffset__``, "
"corresponding to :c:member:`~PyTypeObject.tp_dictoffset`, :c:member:"
"`~PyTypeObject.tp_weaklistoffset` and :c:member:`~PyTypeObject."
"tp_vectorcall_offset` in type objects. These must be defined with "
"``T_PYSSIZET`` and ``READONLY``, for example::"
msgstr ""
"Tipos asignados en el montón (creados usando :c:func:`PyType_FromSpec` o "
"similar), ``PyMemberDef`` puede contener definiciones para los miembros "
"especiales ``__dictoffset__``, ``__weaklistoffset__`` y "
"``__vectorcalloffset__``, correspondientes a :c:member:`~PyTypeObject."
"tp_dictoffset`, :c:member:`~PyTypeObject.tp_weaklistoffset` y :c:member:"
"`~PyTypeObject.tp_vectorcall_offset` en objetos de tipo. Estos deben "
"definirse con ``T_PYSSIZET`` y ``READONLY``, por ejemplo::"

#: ../../c-api/structures.rst:474
msgid ""
"Get an attribute belonging to the object at address *obj_addr*.  The "
"attribute is described by ``PyMemberDef`` *m*.  Returns ``NULL`` on error."
msgstr ""
"Obtener un atributo perteneciente al objeto en la dirección *obj_addr*.  El "
"atributo se describe en ``PyMemberDef`` *m*.  Devuelve ``NULL`` en caso de "
"error."

#: ../../c-api/structures.rst:481
msgid ""
"Set an attribute belonging to the object at address *obj_addr* to object "
"*o*. The attribute to set is described by ``PyMemberDef`` *m*.  Returns "
"``0`` if successful and a negative value on failure."
msgstr ""
"Establece un atributo perteneciente al objeto en la dirección *obj_addr* al "
"objeto *o*. El atributo a establecer se describe en ``PyMemberDef`` *m*.  "
"Devuelve ``0`` si tiene éxito y un valor negativo en caso de fallo."

#: ../../c-api/structures.rst:488
msgid ""
"Structure to define property-like access for a type. See also description of "
"the :c:member:`PyTypeObject.tp_getset` slot."
msgstr ""
"Estructura para definir el acceso tipo propiedad para un tipo. Véase también "
"la descripción de la ranura :c:member:`PyTypeObject.tp_getset`."

#: ../../c-api/structures.rst:494
msgid "name"
msgstr "nombre"

#: ../../c-api/structures.rst:494
msgid "attribute name"
msgstr "nombre de atributo"

#: ../../c-api/structures.rst:496
msgid "get"
msgstr "consesguir"

#: ../../c-api/structures.rst:496
msgid "getter"
msgstr "captador"

#: ../../c-api/structures.rst:496
msgid "C function to get the attribute"
msgstr "Función C para obtener el atributo"

#: ../../c-api/structures.rst:498
msgid "set"
msgstr "conjunto"

#: ../../c-api/structures.rst:498
msgid "setter"
msgstr "setter"

#: ../../c-api/structures.rst:498
msgid ""
"optional C function to set or delete the attribute, if omitted the attribute "
"is readonly"
msgstr ""
"función C opcional para establecer o eliminar el atributo, si se omite el "
"atributo es de sólo lectura"

#: ../../c-api/structures.rst:502
msgid "doc"
msgstr "doc"

#: ../../c-api/structures.rst:502
msgid "optional docstring"
msgstr "docstring opcional"

#: ../../c-api/structures.rst:504
msgid "closure"
msgstr "cierre"

#: ../../c-api/structures.rst:504
msgid "void \\*"
msgstr "void \\*"

#: ../../c-api/structures.rst:504
msgid ""
"optional function pointer, providing additional data for getter and setter"
msgstr ""
"puntero de función opcional, que proporciona datos adicionales para getter y "
"setter"

#: ../../c-api/structures.rst:509
msgid ""
"The ``get`` function takes one :c:expr:`PyObject*` parameter (the instance) "
"and a function pointer (the associated ``closure``)::"
msgstr ""
"La función ``get`` toma un parámetro :c:expr:`PyObject*` (la instancia) y un "
"puntero de función (el ``closure`` asociado)::"

#: ../../c-api/structures.rst:514
msgid ""
"It should return a new reference on success or ``NULL`` with a set exception "
"on failure."
msgstr ""
"Debe devolver una nueva referencia en caso de éxito o ``NULL`` con una "
"excepción establecida en caso de fallo."

#: ../../c-api/structures.rst:517
msgid ""
"``set`` functions take two :c:expr:`PyObject*` parameters (the instance and "
"the value to be set) and a function pointer (the associated ``closure``)::"
msgstr ""
"``set`` toman dos parámetros :c:expr:`PyObject*` (la instancia y el valor a "
"establecer) y un puntero de función (el ``closure`` asociado)::"

#: ../../c-api/structures.rst:522
msgid ""
"In case the attribute should be deleted the second parameter is ``NULL``. "
"Should return ``0`` on success or ``-1`` with a set exception on failure."
msgstr ""
"En caso de que el atributo se deba borrar el segundo parámetro es ``NULL``. "
"Debe devolver ``0`` en caso de éxito o ``-1`` con una excepción establecida "
"en caso de fallo."
