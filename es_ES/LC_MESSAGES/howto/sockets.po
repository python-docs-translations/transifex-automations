# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# eulalio barbero espinosa <eulalio@disroot.org>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-17 14:51+0000\n"
"PO-Revision-Date: 2024-05-11 00:32+0000\n"
"Last-Translator: eulalio barbero espinosa <eulalio@disroot.org>, 2025\n"
"Language-Team: Spanish (Spain) (https://app.transifex.com/python-doc/"
"teams/5390/es_ES/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es_ES\n"
"Plural-Forms: nplurals=3; plural=n == 1 ? 0 : n != 0 && n % 1000000 == 0 ? "
"1 : 2;\n"

#: ../../howto/sockets.rst:5
msgid "Socket Programming HOWTO"
msgstr "CÓMO de programación de sockets"

#: ../../howto/sockets.rst:0
msgid "Author"
msgstr "Autor"

#: ../../howto/sockets.rst:7
msgid "Gordon McMillan"
msgstr "Gordon McMillan"

#: ../../howto/sockets.rst-1
msgid "Abstract"
msgstr "Resumen"

#: ../../howto/sockets.rst:12
msgid ""
"Sockets are used nearly everywhere, but are one of the most severely "
"misunderstood technologies around. This is a 10,000 foot overview of "
"sockets. It's not really a tutorial - you'll still have work to do in "
"getting things operational. It doesn't cover the fine points (and there are "
"a lot of them), but I hope it will give you enough background to begin using "
"them decently."
msgstr ""
"Los zócalos se utilizan en casi todas partes, pero son una de las "
"tecnologías más incomprendidas. Esta es una visión general de los sockets "
"-10.000 pies-. No es realmente un tutorial - todavía tendrás trabajo que "
"hacer para conseguir que las cosas funcionen. No cubre los puntos finos (y "
"hay un montón de ellos), pero espero que le dará suficiente fondo para "
"empezar a usarlos decentemente."

#: ../../howto/sockets.rst:20
msgid "Sockets"
msgstr "Sockets"

#: ../../howto/sockets.rst:22
msgid ""
"I'm only going to talk about INET (i.e. IPv4) sockets, but they account for "
"at least 99% of the sockets in use. And I'll only talk about STREAM (i.e. "
"TCP) sockets - unless you really know what you're doing (in which case this "
"HOWTO isn't for you!), you'll get better behavior and performance from a "
"STREAM socket than anything else. I will try to clear up the mystery of what "
"a socket is, as well as some hints on how to work with blocking and non-"
"blocking sockets. But I'll start by talking about blocking sockets. You'll "
"need to know how they work before dealing with non-blocking sockets."
msgstr ""
"Sólo voy a hablar de sockets INET (es decir, IPv4), pero representan al "
"menos el 99% de los sockets en uso. Y sólo hablaré de sockets STREAM (es "
"decir, TCP) - a menos que realmente sepas lo que estás haciendo (¡en cuyo "
"caso este CÓMO no es para ti!), obtendrás mejor comportamiento y rendimiento "
"de un socket STREAM que de cualquier otra cosa. Intentaré aclarar el "
"misterio de lo que es un socket, así como algunas pistas sobre cómo trabajar "
"con sockets bloqueantes y no bloqueantes. Pero empezaré hablando de los "
"sockets bloqueantes. Necesitarás saber cómo funcionan antes de tratar con "
"los sockets no bloqueantes."

#: ../../howto/sockets.rst:31
msgid ""
"Part of the trouble with understanding these things is that \"socket\" can "
"mean a number of subtly different things, depending on context. So first, "
"let's make a distinction between a \"client\" socket - an endpoint of a "
"conversation, and a \"server\" socket, which is more like a switchboard "
"operator. The client application (your browser, for example) uses \"client\" "
"sockets exclusively; the web server it's talking to uses both \"server\" "
"sockets and \"client\" sockets."
msgstr ""
"Parte del problema para entender estas cosas es que \"socket\" puede "
"significar una serie de cosas sutilmente diferentes, dependiendo del "
"contexto. Así que, en primer lugar, vamos a distinguir entre un socket "
"\"cliente\" - un punto final de una conversación, y un socket \"servidor\", "
"que es más como un operador de centralita. La aplicación cliente (tu "
"navegador, por ejemplo) utiliza exclusivamente sockets \"cliente\"; el "
"servidor web con el que habla utiliza tanto sockets \"servidor\" como "
"sockets \"cliente\"."

#: ../../howto/sockets.rst:40
msgid "History"
msgstr "Historia"

#: ../../howto/sockets.rst:42
msgid ""
"Of the various forms of :abbr:`IPC (Inter Process Communication)`, sockets "
"are by far the most popular.  On any given platform, there are likely to be "
"other forms of IPC that are faster, but for cross-platform communication, "
"sockets are about the only game in town."
msgstr ""
"De las diversas formas de :abbr:`IPC (Inter Process Communication)`, los "
"sockets son, con diferencia, las más populares.  En cualquier plataforma, es "
"probable que haya otras formas de IPC que sean más rápidas, pero para la "
"comunicación entre plataformas, los sockets son el único juego en la ciudad."

#: ../../howto/sockets.rst:47
msgid ""
"They were invented in Berkeley as part of the BSD flavor of Unix. They "
"spread like wildfire with the internet. With good reason --- the combination "
"of sockets with INET makes talking to arbitrary machines around the world "
"unbelievably easy (at least compared to other schemes)."
msgstr ""
"Se inventaron en Berkeley como parte de la versión BSD de Unix. Se "
"extendieron como la pólvora con Internet. Y con razón: la combinación de "
"sockets con INET hace que hablar con máquinas arbitrarias de todo el mundo "
"sea increíblemente fácil (al menos comparado con otros sistemas)."

#: ../../howto/sockets.rst:54
msgid "Creating a Socket"
msgstr "Creación de un zócalo"

#: ../../howto/sockets.rst:56
msgid ""
"Roughly speaking, when you clicked on the link that brought you to this "
"page, your browser did something like the following::"
msgstr ""
"A grandes rasgos, cuando ha hecho clic en el enlace que le ha llevado a esta "
"página, su navegador ha hecho algo parecido a lo siguiente::"

#: ../../howto/sockets.rst:59
msgid ""
"# create an INET, STREAMing socket\n"
"s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"# now connect to the web server on port 80 - the normal http port\n"
"s.connect((\"www.python.org\", 80))"
msgstr ""
"# crear un socket INET, STREAMing\n"
"s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"# ahora conéctate al servidor web en el puerto 80 - el puerto http normal\n"
"s.connect((\"www.python.org\", 80))"

#: ../../howto/sockets.rst:64
msgid ""
"When the ``connect`` completes, the socket ``s`` can be used to send in a "
"request for the text of the page. The same socket will read the reply, and "
"then be destroyed. That's right, destroyed. Client sockets are normally only "
"used for one exchange (or a small set of sequential exchanges)."
msgstr ""
"Cuando ``connect`` finaliza, el socket ``s`` puede utilizarse para enviar "
"una solicitud del texto de la página. El mismo socket leerá la respuesta, y "
"luego será destruido. Así es, destruido. Normalmente, los sockets cliente "
"sólo se utilizan para un intercambio (o un pequeño conjunto de intercambios "
"secuenciales)."

#: ../../howto/sockets.rst:70
msgid ""
"What happens in the web server is a bit more complex. First, the web server "
"creates a \"server socket\"::"
msgstr ""
"Lo que ocurre en el servidor web es un poco más complejo. En primer lugar, "
"el servidor web crea un \"socket de servidor\"::"

#: ../../howto/sockets.rst:73
msgid ""
"# create an INET, STREAMing socket\n"
"serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"# bind the socket to a public host, and a well-known port\n"
"serversocket.bind((socket.gethostname(), 80))\n"
"# become a server socket\n"
"serversocket.listen(5)"
msgstr ""
"# crear un socket INET, STREAMing\n"
"serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"# enlaza el socket a un host público y a un puerto conocido\n"
"serversocket.bind((socket.gethostname(), 80))\n"
"# conviértete en un socket servidor\n"
"serversocket.listen(5)"

#: ../../howto/sockets.rst:80
msgid ""
"A couple things to notice: we used ``socket.gethostname()`` so that the "
"socket would be visible to the outside world.  If we had used ``s."
"bind(('localhost', 80))`` or ``s.bind(('127.0.0.1', 80))`` we would still "
"have a \"server\" socket, but one that was only visible within the same "
"machine.  ``s.bind(('', 80))`` specifies that the socket is reachable by any "
"address the machine happens to have."
msgstr ""
"Un par de cosas a tener en cuenta: usamos ``socket.gethostname()`` para que "
"el socket fuera visible al mundo exterior.  Si hubiésemos usado ``s."
"bind(('localhost', 80))`` o ``s.bind(('127.0.0.1', 80))`` aún tendríamos un "
"socket \"servidor\", pero sólo visible dentro de la misma máquina. ``s."
"bind(('', 80))`` especifica que el socket es accesible por cualquier "
"dirección que tenga la máquina."

#: ../../howto/sockets.rst:87
msgid ""
"A second thing to note: low number ports are usually reserved for \"well "
"known\" services (HTTP, SNMP etc). If you're playing around, use a nice high "
"number (4 digits)."
msgstr ""
"Una segunda cosa a tener en cuenta: los puertos con números bajos suelen "
"estar reservados para servicios \"bien conocidos\" (HTTP, SNMP, etc.). Si "
"estás jugando, utiliza un buen número alto (4 dígitos)."

#: ../../howto/sockets.rst:91
msgid ""
"Finally, the argument to ``listen`` tells the socket library that we want it "
"to queue up as many as 5 connect requests (the normal max) before refusing "
"outside connections. If the rest of the code is written properly, that "
"should be plenty."
msgstr ""
"Por último, el argumento a ``listen`` indica a la biblioteca de sockets que "
"queremos que ponga en cola hasta 5 peticiones de conexión (el máximo normal) "
"antes de rechazar conexiones externas. Si el resto del código está bien "
"escrito, debería ser suficiente."

#: ../../howto/sockets.rst:95
msgid ""
"Now that we have a \"server\" socket, listening on port 80, we can enter the "
"mainloop of the web server::"
msgstr ""
"Ahora que tenemos un socket \"servidor\", escuchando en el puerto 80, "
"podemos entrar en el mainloop del servidor web::"

#: ../../howto/sockets.rst:98
msgid ""
"while True:\n"
"    # accept connections from outside\n"
"    (clientsocket, address) = serversocket.accept()\n"
"    # now do something with the clientsocket\n"
"    # in this case, we'll pretend this is a threaded server\n"
"    ct = client_thread(clientsocket)\n"
"    ct.run()"
msgstr ""
"while True:\n"
"    # aceptar conexiones desde el exterior\n"
"    (clientsocket, address) = serversocket.accept()\n"
"    # ahora haz algo con el clientsocket\n"
"    # en este caso, fingiremos que se trata de un servidor enhebrado\n"
"    ct = client_thread(clientsocket)\n"
"ct.run()"

#: ../../howto/sockets.rst:106
msgid ""
"There's actually 3 general ways in which this loop could work - dispatching "
"a thread to handle ``clientsocket``, create a new process to handle "
"``clientsocket``, or restructure this app to use non-blocking sockets, and "
"multiplex between our \"server\" socket and any active ``clientsocket``\\ s "
"using ``select``. More about that later. The important thing to understand "
"now is this: this is *all* a \"server\" socket does. It doesn't send any "
"data. It doesn't receive any data. It just produces \"client\" sockets. Each "
"``clientsocket`` is created in response to some *other* \"client\" socket "
"doing a ``connect()`` to the host and port we're bound to. As soon as we've "
"created that ``clientsocket``, we go back to listening for more connections. "
"The two \"clients\" are free to chat it up - they are using some dynamically "
"allocated port which will be recycled when the conversation ends."
msgstr ""
"En realidad hay 3 maneras generales en las que este bucle podría funcionar - "
"despachar un hilo para manejar ``clientsocket``, crear un nuevo proceso para "
"manejar ``clientsocket``, o reestructurar esta aplicación para utilizar "
"sockets no bloqueantes, y multiplexar entre nuestro socket \"servidor\" y "
"cualquier ``clientsocket``\\ s activo utilizando ``select``. Más adelante "
"hablaremos de ello. Lo importante ahora es entender esto: esto es *todo* lo "
"que hace un socket \"servidor\". No envía ningún dato. No recibe datos. Sólo "
"produce sockets \"cliente\". Cada ``clientsocket`` se crea en respuesta a "
"algún *otro* socket \"cliente\" que hace un ``connect()`` al host y puerto "
"al que estamos vinculados. Tan pronto como hemos creado ese "
"``clientsocket``, volvemos a escuchar más conexiones. Los dos \"clientes\" "
"son libres de charlar - están usando algún puerto asignado dinámicamente que "
"será reciclado cuando la conversación termine."

#: ../../howto/sockets.rst:121
msgid "IPC"
msgstr "IPC"

#: ../../howto/sockets.rst:123
msgid ""
"If you need fast IPC between two processes on one machine, you should look "
"into pipes or shared memory.  If you do decide to use AF_INET sockets, bind "
"the \"server\" socket to ``'localhost'``. On most platforms, this will take "
"a shortcut around a couple of layers of network code and be quite a bit "
"faster."
msgstr ""
"Si necesita un IPC rápido entre dos procesos en una máquina, debería buscar "
"tuberías o memoria compartida.  Si decide utilizar sockets AF_INET, vincule "
"el socket \"servidor\" a ``'localhost'``. En la mayoría de las plataformas, "
"esto tomará un atajo alrededor de un par de capas de código de red y será "
"bastante más rápido."

#: ../../howto/sockets.rst:129
msgid ""
"The :mod:`multiprocessing` integrates cross-platform IPC into a higher-level "
"API."
msgstr ""
":mod:`multiprocessing` integra IPC multiplataforma en una API de nivel "
"superior."

#: ../../howto/sockets.rst:134
msgid "Using a Socket"
msgstr "Utilización de un socket"

#: ../../howto/sockets.rst:136
msgid ""
"The first thing to note, is that the web browser's \"client\" socket and the "
"web server's \"client\" socket are identical beasts. That is, this is a "
"\"peer to peer\" conversation. Or to put it another way, *as the designer, "
"you will have to decide what the rules of etiquette are for a conversation*. "
"Normally, the ``connect``\\ ing socket starts the conversation, by sending "
"in a request, or perhaps a signon. But that's a design decision - it's not a "
"rule of sockets."
msgstr ""
"Lo primero que hay que tener en cuenta es que el socket \"cliente\" del "
"navegador web y el socket \"cliente\" del servidor web son bestias "
"idénticas. Es decir, se trata de una conversación \"peer to peer\". O dicho "
"de otro modo, *como diseñador, tendrás que decidir cuáles son las reglas de "
"etiqueta de una conversación*. Normalmente, el ``connect``\\ ing socket "
"inicia la conversación, mediante el envío de una solicitud, o tal vez un "
"signon. Pero eso es una decisión de diseño, no una regla de los sockets."

#: ../../howto/sockets.rst:143
msgid ""
"Now there are two sets of verbs to use for communication. You can use "
"``send`` and ``recv``, or you can transform your client socket into a file-"
"like beast and use ``read`` and ``write``. The latter is the way Java "
"presents its sockets. I'm not going to talk about it here, except to warn "
"you that you need to use ``flush`` on sockets. These are buffered \"files\", "
"and a common mistake is to ``write`` something, and then ``read`` for a "
"reply. Without a ``flush`` in there, you may wait forever for the reply, "
"because the request may still be in your output buffer."
msgstr ""
"Ahora hay dos conjuntos de verbos para usar en la comunicación. Puedes usar "
"``send`` y ``recv``, o puedes transformar tu socket cliente en una cosa "
"parecida a un archivo y usar ``read`` y ``write``. Esta última es la forma "
"en que Java presenta sus sockets. No voy a hablar de ello aquí, excepto para "
"advertirte de que necesitas usar ``flush`` en los sockets. Estos son "
"\"archivos\" con buffer, y un error común es ``write`` algo, y luego "
"``read`` para una respuesta. Sin un ``flush`` ahí, puedes esperar una "
"eternidad por la respuesta, porque la petición puede estar todavía en tu "
"buffer de salida."

#: ../../howto/sockets.rst:152
msgid ""
"Now we come to the major stumbling block of sockets - ``send`` and ``recv`` "
"operate on the network buffers. They do not necessarily handle all the bytes "
"you hand them (or expect from them), because their major focus is handling "
"the network buffers. In general, they return when the associated network "
"buffers have been filled (``send``) or emptied (``recv``). They then tell "
"you how many bytes they handled. It is *your* responsibility to call them "
"again until your message has been completely dealt with."
msgstr ""
"Ahora llegamos al mayor escollo de los sockets - ``send`` y ``recv`` operan "
"en los buffers de red. No necesariamente manejan todos los bytes que les "
"pasas (o esperas de ellos), porque su principal objetivo es manejar los "
"buffers de red. En general, regresan cuando los buffers de red asociados se "
"han llenado (``send``) o vaciado (``recv``). Entonces te dicen cuántos bytes "
"han manejado. Es *su* responsabilidad llamarlos de nuevo hasta que su "
"mensaje haya sido tratado completamente."

#: ../../howto/sockets.rst:160
msgid ""
"When a ``recv`` returns 0 bytes, it means the other side has closed (or is "
"in the process of closing) the connection.  You will not receive any more "
"data on this connection. Ever.  You may be able to send data successfully; "
"I'll talk more about this later."
msgstr ""
"Cuando un ``recv`` devuelve 0 bytes, significa que el otro lado ha cerrado "
"(o está en proceso de cerrar) la conexión.  No recibirás más datos en esta "
"conexión. Sin duda.  Es posible que puedas enviar datos con éxito; hablaré "
"más sobre esto más adelante."

#: ../../howto/sockets.rst:165
msgid ""
"A protocol like HTTP uses a socket for only one transfer. The client sends a "
"request, then reads a reply.  That's it. The socket is discarded. This means "
"that a client can detect the end of the reply by receiving 0 bytes."
msgstr ""
"Un protocolo como HTTP utiliza un socket para una sola transferencia. El "
"cliente envía una solicitud, luego lee una respuesta.  Y ya está. El socket "
"se descarta. Esto significa que un cliente puede detectar el final de la "
"respuesta recibiendo 0 bytes."

#: ../../howto/sockets.rst:169
msgid ""
"But if you plan to reuse your socket for further transfers, you need to "
"realize that *there is no* :abbr:`EOT (End of Transfer)` *on a socket.* I "
"repeat: if a socket ``send`` or ``recv`` returns after handling 0 bytes, the "
"connection has been broken.  If the connection has *not* been broken, you "
"may wait on a ``recv`` forever, because the socket will *not* tell you that "
"there's nothing more to read (for now).  Now if you think about that a bit, "
"you'll come to realize a fundamental truth of sockets: *messages must either "
"be fixed length* (yuck), *or be delimited* (shrug), *or indicate how long "
"they are* (much better), *or end by shutting down the connection*. The "
"choice is entirely yours, (but some ways are righter than others)."
msgstr ""
"Pero si planeas reutilizar tu socket para más transferencias, necesitas "
"darte cuenta de que *no hay* :abbr:`EOT (End of Transfer)` * *en un socket.* "
"Repito: si un socket ``send`` o ``recv`` vuelve después de manejar 0 bytes, "
"la conexión se ha roto.  Si la conexión *no* se ha roto, puedes esperar en "
"un ``recv`` para siempre, porque el socket *no* te dirá que no hay nada más "
"que leer (por ahora).  Ahora, si piensas un poco sobre esto, te darás cuenta "
"de una verdad fundamental de los sockets: *los mensajes deben tener una "
"longitud fija* (puaj), *o delimitarse* (encogerse de hombros), *o indicar su "
"longitud* (mucho mejor), *o terminar cerrando la conexión*. La elección es "
"enteramente tuya, (pero algunas formas son más correctas que otras)."

#: ../../howto/sockets.rst:180
msgid ""
"Assuming you don't want to end the connection, the simplest solution is a "
"fixed length message::"
msgstr ""
"Suponiendo que no desee finalizar la conexión, la solución más sencilla es "
"un mensaje de longitud fija::"

#: ../../howto/sockets.rst:183
msgid ""
"class MySocket:\n"
"    \"\"\"demonstration class only\n"
"      - coded for clarity, not efficiency\n"
"    \"\"\"\n"
"\n"
"    def __init__(self, sock=None):\n"
"        if sock is None:\n"
"            self.sock = socket.socket(\n"
"                            socket.AF_INET, socket.SOCK_STREAM)\n"
"        else:\n"
"            self.sock = sock\n"
"\n"
"    def connect(self, host, port):\n"
"        self.sock.connect((host, port))\n"
"\n"
"    def mysend(self, msg):\n"
"        totalsent = 0\n"
"        while totalsent < MSGLEN:\n"
"            sent = self.sock.send(msg[totalsent:])\n"
"            if sent == 0:\n"
"                raise RuntimeError(\"socket connection broken\")\n"
"            totalsent = totalsent + sent\n"
"\n"
"    def myreceive(self):\n"
"        chunks = []\n"
"        bytes_recd = 0\n"
"        while bytes_recd < MSGLEN:\n"
"            chunk = self.sock.recv(min(MSGLEN - bytes_recd, 2048))\n"
"            if chunk == b'':\n"
"                raise RuntimeError(\"socket connection broken\")\n"
"            chunks.append(chunk)\n"
"            bytes_recd = bytes_recd + len(chunk)\n"
"        return b''.join(chunks)"
msgstr ""
"class MySocket:\n"
"    \"\"\"demonstration class only\n"
"      - coded for clarity, not efficiency\n"
"    \"\"\"\n"
"\n"
"    def __init__(self, sock=None):\n"
"        if sock is None:\n"
"            self.sock = socket.socket(\n"
"                            socket.AF_INET, socket.SOCK_STREAM)\n"
"        else:\n"
"            self.sock = sock\n"
"\n"
"    def connect(self, host, port):\n"
"        self.sock.connect((host, port))\n"
"\n"
"    def mysend(self, msg):\n"
"        totalsent = 0\n"
"        while totalsent < MSGLEN:\n"
"            sent = self.sock.send(msg[totalsent:])\n"
"            if sent == 0:\n"
"                raise RuntimeError(\"socket connection broken\")\n"
"            totalsent = totalsent + sent\n"
"\n"
"    def myreceive(self):\n"
"        chunks = []\n"
"        bytes_recd = 0\n"
"        while bytes_recd < MSGLEN:\n"
"            chunk = self.sock.recv(min(MSGLEN - bytes_recd, 2048))\n"
"            if chunk == b'':\n"
"                raise RuntimeError(\"socket connection broken\")\n"
"            chunks.append(chunk)\n"
"            bytes_recd = bytes_recd + len(chunk)\n"
"        return b''.join(chunks)"

#: ../../howto/sockets.rst:217
msgid ""
"The sending code here is usable for almost any messaging scheme - in Python "
"you send strings, and you can use ``len()`` to determine its length (even if "
"it has embedded ``\\0`` characters). It's mostly the receiving code that "
"gets more complex. (And in C, it's not much worse, except you can't use "
"``strlen`` if the message has embedded ``\\0``\\ s.)"
msgstr ""
"El código de envío aquí es utilizable para casi cualquier esquema de "
"mensajería - en Python envías cadenas, y puedes usar ``len()`` para "
"determinar su longitud (incluso si tiene caracteres ``\\0`` incrustados). Lo "
"más complejo es el código de recepción. (Y en C, no es mucho peor, excepto "
"que no puedes usar ``strlen`` si el mensaje tiene ``\\0``\\ s incrustados)."

#: ../../howto/sockets.rst:223
msgid ""
"The easiest enhancement is to make the first character of the message an "
"indicator of message type, and have the type determine the length. Now you "
"have two ``recv``\\ s - the first to get (at least) that first character so "
"you can look up the length, and the second in a loop to get the rest. If you "
"decide to go the delimited route, you'll be receiving in some arbitrary "
"chunk size, (4096 or 8192 is frequently a good match for network buffer "
"sizes), and scanning what you've received for a delimiter."
msgstr ""
"La mejora más sencilla es hacer que el primer carácter del mensaje sea un "
"indicador del tipo de mensaje, y que el tipo determine la longitud. Ahora "
"tiene dos ``recv``- el primero para obtener (al menos) el primer carácter "
"para que pueda buscar la longitud, y el segundo en un bucle para obtener el "
"resto. Si decides ir por la ruta delimitada, estarás recibiendo en algún "
"tamaño de trozo arbitrario, (4096 o 8192 es frecuentemente una buena "
"coincidencia para tamaños de búfer de red), y escaneando lo que has recibido "
"para un delimitador."

#: ../../howto/sockets.rst:231
msgid ""
"One complication to be aware of: if your conversational protocol allows "
"multiple messages to be sent back to back (without some kind of reply), and "
"you pass ``recv`` an arbitrary chunk size, you may end up reading the start "
"of a following message. You'll need to put that aside and hold onto it, "
"until it's needed."
msgstr ""
"Una complicación a tener en cuenta: si tu protocolo de conversación permite "
"enviar varios mensajes seguidos (sin ningún tipo de respuesta), y pasas a "
"``recv`` un tamaño de trozo arbitrario, puede que acabes leyendo el "
"principio de un mensaje siguiente. Tendrás que dejarlo a un lado y guardarlo "
"hasta que sea necesario."

#: ../../howto/sockets.rst:237
msgid ""
"Prefixing the message with its length (say, as 5 numeric characters) gets "
"more complex, because (believe it or not), you may not get all 5 characters "
"in one ``recv``. In playing around, you'll get away with it; but in high "
"network loads, your code will very quickly break unless you use two ``recv`` "
"loops - the first to determine the length, the second to get the data part "
"of the message. Nasty. This is also when you'll discover that ``send`` does "
"not always manage to get rid of everything in one pass. And despite having "
"read this, you will eventually get bit by it!"
msgstr ""
"Prefijar el mensaje con su longitud (digamos, como 5 caracteres numéricos) "
"se vuelve más complejo, porque (lo creas o no), puede que no obtengas los 5 "
"caracteres en un ``recv``. Jugando, te saldrás con la tuya; pero con cargas "
"de red altas, tu código se romperá muy rápidamente a menos que utilices dos "
"bucles ``recv`` - el primero para determinar la longitud, el segundo para "
"obtener la parte de datos del mensaje. Asqueroso. Aquí es también cuando "
"descubrirás que ``send`` no siempre consigue deshacerse de todo en una sola "
"pasada. Y a pesar de haber leído esto, ¡al final te picará!"

#: ../../howto/sockets.rst:246
msgid ""
"In the interests of space, building your character, (and preserving my "
"competitive position), these enhancements are left as an exercise for the "
"reader. Lets move on to cleaning up."
msgstr ""
"En interés del espacio, la construcción de su carácter, (y preservar mi "
"posición competitiva), estas mejoras se dejan como un ejercicio para el "
"lector. Pasemos a la limpieza."

#: ../../howto/sockets.rst:252
msgid "Binary Data"
msgstr "Datos binarios"

#: ../../howto/sockets.rst:254
msgid ""
"It is perfectly possible to send binary data over a socket. The major "
"problem is that not all machines use the same formats for binary data. For "
"example, `network byte order <https://en.wikipedia.org/wiki/"
"Endianness#Networking>`_ is big-endian, with the most significant byte "
"first, so a 16 bit integer with the value ``1`` would be the two hex bytes "
"``00 01``. However, most common processors (x86/AMD64, ARM, RISC-V), are "
"little-endian, with the least significant byte first - that same ``1`` would "
"be ``01 00``."
msgstr ""
"Es perfectamente posible enviar datos binarios a través de un socket. El "
"mayor problema es que no todas las máquinas utilizan los mismos formatos "
"para los datos binarios. Por ejemplo, `el orden de bytes de red <https://en."
"wikipedia.org/wiki/Endianness#Networking>`_ es big-endian, con el byte más "
"significativo primero, por lo que un entero de 16 bits con el valor ``1`` "
"serían los dos bytes hexadecimales ``00 01``. Sin embargo, los procesadores "
"más comunes (x86/AMD64, ARM, RISC-V), son little-endian, con el byte menos "
"significativo primero - ese mismo ``1`` sería ``01 00``."

#: ../../howto/sockets.rst:262
msgid ""
"Socket libraries have calls for converting 16 and 32 bit integers - ``ntohl, "
"htonl, ntohs, htons`` where \"n\" means *network* and \"h\" means *host*, "
"\"s\" means *short* and \"l\" means *long*. Where network order is host "
"order, these do nothing, but where the machine is byte-reversed, these swap "
"the bytes around appropriately."
msgstr ""
"Las bibliotecas de sockets tienen llamadas para convertir enteros de 16 y 32 "
"bits - ``ntohl, htonl, ntohs, htons`` donde \"n\" significa *red* y \"h\" "
"significa *host*, \"s\" significa *corto* y \"l\" significa *largo*. Si el "
"orden de la red es el mismo que el del host, no hacen nada, pero si la "
"máquina está invertida en bytes, intercambian los bytes adecuadamente."

#: ../../howto/sockets.rst:268
msgid ""
"In these days of 64-bit machines, the ASCII representation of binary data is "
"frequently smaller than the binary representation. That's because a "
"surprising amount of the time, most integers have the value 0, or maybe 1. "
"The string ``\"0\"`` would be two bytes, while a full 64-bit integer would "
"be 8. Of course, this doesn't fit well with fixed-length messages. "
"Decisions, decisions."
msgstr ""
"En estos tiempos de máquinas de 64 bits, la representación ASCII de los "
"datos binarios suele ser más pequeña que la representación binaria. Esto se "
"debe a que, sorprendentemente, la mayoría de los números enteros tienen el "
"valor 0, o quizás 1. La cadena ``\"0\"`` tendría dos bytes, mientras que un "
"entero completo de 64 bits tendría 8. Por supuesto, esto no encaja bien con "
"los mensajes de longitud fija. Decisiones, decisiones."

#: ../../howto/sockets.rst:277
msgid "Disconnecting"
msgstr "Desconectando"

#: ../../howto/sockets.rst:279
msgid ""
"Strictly speaking, you're supposed to use ``shutdown`` on a socket before "
"you ``close`` it.  The ``shutdown`` is an advisory to the socket at the "
"other end. Depending on the argument you pass it, it can mean \"I'm not "
"going to send anymore, but I'll still listen\", or \"I'm not listening, good "
"riddance!\".  Most socket libraries, however, are so used to programmers "
"neglecting to use this piece of etiquette that normally a ``close`` is the "
"same as ``shutdown(); close()``.  So in most situations, an explicit "
"``shutdown`` is not needed."
msgstr ""
"Estrictamente hablando, se supone que debes usar ``shutdown`` en un socket "
"antes de ``close``.  El ``shutdown`` es un aviso al socket en el otro "
"extremo. Dependiendo del argumento que le pases, puede significar \"no voy a "
"enviar más, pero seguiré escuchando\", o \"no estoy escuchando, ¡buen viaje!"
"\".  La mayoría de las librerías de sockets, sin embargo, están tan "
"acostumbradas a que los programadores descuiden el uso de esta pieza de "
"etiqueta que normalmente un ``close`` es lo mismo que ``shutdown(); "
"close()``.  Así que en la mayoría de las situaciones, un ``shutdown`` "
"explícito no es necesario."

#: ../../howto/sockets.rst:287
msgid ""
"One way to use ``shutdown`` effectively is in an HTTP-like exchange. The "
"client sends a request and then does a ``shutdown(1)``. This tells the "
"server \"This client is done sending, but can still receive.\"  The server "
"can detect \"EOF\" by a receive of 0 bytes. It can assume it has the "
"complete request.  The server sends a reply. If the ``send`` completes "
"successfully then, indeed, the client was still receiving."
msgstr ""
"Una forma de utilizar ``shutdown`` eficazmente es en un intercambio tipo "
"HTTP. El cliente envía una petición y luego hace un ``shutdown(1)``. Esto le "
"dice al servidor \"Este cliente ha terminado de enviar, pero aún puede "
"recibir\".  El servidor puede detectar \"EOF\" por una recepción de 0 bytes. "
"Puede asumir que tiene la petición completa.  El servidor envía una "
"respuesta. Si la ``send`` se completa con éxito entonces, efectivamente, el "
"cliente todavía estaba recibiendo."

#: ../../howto/sockets.rst:294
msgid ""
"Python takes the automatic shutdown a step further, and says that when a "
"socket is garbage collected, it will automatically do a ``close`` if it's "
"needed. But relying on this is a very bad habit. If your socket just "
"disappears without doing a ``close``, the socket at the other end may hang "
"indefinitely, thinking you're just being slow. *Please* ``close`` your "
"sockets when you're done."
msgstr ""
"Python lleva el apagado automático un paso más allá, y dice que cuando un "
"socket es recolectado de basura, hará automáticamente un ``close`` si es "
"necesario. Pero confiar en esto es un muy mal hábito. Si tu socket "
"simplemente desaparece sin hacer un ``close``, el socket en el otro extremo "
"puede colgarse indefinidamente, pensando que sólo estás siendo lento. *Por "
"favor* ``close`` tus sockets cuando termines."

#: ../../howto/sockets.rst:302
msgid "When Sockets Die"
msgstr "Cuando mueren los sockets"

#: ../../howto/sockets.rst:304
msgid ""
"Probably the worst thing about using blocking sockets is what happens when "
"the other side comes down hard (without doing a ``close``). Your socket is "
"likely to hang. TCP is a reliable protocol, and it will wait a long, long "
"time before giving up on a connection. If you're using threads, the entire "
"thread is essentially dead. There's not much you can do about it. As long as "
"you aren't doing something dumb, like holding a lock while doing a blocking "
"read, the thread isn't really consuming much in the way of resources. Do "
"*not* try to kill the thread - part of the reason that threads are more "
"efficient than processes is that they avoid the overhead associated with the "
"automatic recycling of resources. In other words, if you do manage to kill "
"the thread, your whole process is likely to be screwed up."
msgstr ""
"Probablemente, lo peor de utilizar zócalos de bloqueo es lo que ocurre "
"cuando el otro lado baja con fuerza (sin hacer un ``close``). Es probable "
"que tu socket se cuelgue. TCP es un protocolo fiable, y esperará mucho, "
"mucho tiempo antes de abandonar una conexión. Si estás usando hilos, el hilo "
"entero está esencialmente muerto. No hay mucho que puedas hacer al respecto. "
"Mientras no estés haciendo algo estúpido, como mantener un bloqueo mientras "
"haces una lectura bloqueante, el hilo no está consumiendo muchos recursos. "
"No *intente* matar el hilo - parte de la razón por la que los hilos son más "
"eficientes que los procesos es que evitan la sobrecarga asociada con el "
"reciclaje automático de recursos. En otras palabras, si consigues matar el "
"hilo, es probable que todo tu proceso se fastidie."

#: ../../howto/sockets.rst:318
msgid "Non-blocking Sockets"
msgstr "Sockets no bloqueantes"

#: ../../howto/sockets.rst:320
msgid ""
"If you've understood the preceding, you already know most of what you need "
"to know about the mechanics of using sockets. You'll still use the same "
"calls, in much the same ways. It's just that, if you do it right, your app "
"will be almost inside-out."
msgstr ""
"Si has entendido lo anterior, ya sabes la mayor parte de lo que necesitas "
"saber sobre la mecánica del uso de sockets. Seguirás usando las mismas "
"llamadas, de la misma manera. Sólo que, si lo haces bien, tu aplicación "
"estará casi dentro-fuera."

#: ../../howto/sockets.rst:325
msgid ""
"In Python, you use ``socket.setblocking(False)`` to make it non-blocking. In "
"C, it's more complex, (for one thing, you'll need to choose between the BSD "
"flavor ``O_NONBLOCK`` and the almost indistinguishable POSIX flavor "
"``O_NDELAY``, which is completely different from ``TCP_NODELAY``), but it's "
"the exact same idea. You do this after creating the socket, but before using "
"it. (Actually, if you're nuts, you can switch back and forth.)"
msgstr ""
"En Python, se utiliza ``socket.setblocking(False)`` para hacerlo no "
"bloqueante. En C, es más complejo, (por un lado, tendrás que elegir entre el "
"sabor BSD ``O_NONBLOCK`` y el casi indistinguible sabor POSIX ``O_NDELAY``, "
"que es completamente diferente de ``TCP_NODELAY``), pero es exactamente la "
"misma idea. Esto se hace después de crear el socket, pero antes de usarlo. "
"(En realidad, si estás loco, puedes cambiar de un lado a otro)."

#: ../../howto/sockets.rst:332
msgid ""
"The major mechanical difference is that ``send``, ``recv``, ``connect`` and "
"``accept`` can return without having done anything. You have (of course) a "
"number of choices. You can check return code and error codes and generally "
"drive yourself crazy. If you don't believe me, try it sometime. Your app "
"will grow large, buggy and suck CPU. So let's skip the brain-dead solutions "
"and do it right."
msgstr ""
"La principal diferencia mecánica es que ``send``, ``recv``, ``connect`` y "
"``accept`` pueden volver sin haber hecho nada. Tienes (por supuesto) varias "
"opciones. Puedes comprobar el código de retorno y los códigos de error y, en "
"general, volverte loco. Si no me crees, pruébalo alguna vez. Tu aplicación "
"crecerá, tendrá errores y chupará CPU. Así que dejémonos de soluciones "
"descerebradas y hagámoslo bien."

#: ../../howto/sockets.rst:339
msgid "Use ``select``."
msgstr "Utilice ``select``."

#: ../../howto/sockets.rst:341
msgid ""
"In C, coding ``select`` is fairly complex. In Python, it's a piece of cake, "
"but it's close enough to the C version that if you understand ``select`` in "
"Python, you'll have little trouble with it in C::"
msgstr ""
"En C, codificar ``select`` es bastante complejo. En Python, es pan comido, "
"pero se parece lo suficiente a la versión en C como para que, si entiendes "
"``select`` en Python, no te cueste mucho hacerlo en C::"

#: ../../howto/sockets.rst:345
msgid ""
"ready_to_read, ready_to_write, in_error = \\\n"
"               select.select(\n"
"                  potential_readers,\n"
"                  potential_writers,\n"
"                  potential_errs,\n"
"                  timeout)"
msgstr ""
"ready_to_read, ready_to_write, in_error = \\\n"
"               select.select(\n"
"                  potential_readers,\n"
"                  potential_writers,\n"
"                  potential_errs,\n"
"                  timeout)"

#: ../../howto/sockets.rst:352
msgid ""
"You pass ``select`` three lists: the first contains all sockets that you "
"might want to try reading; the second all the sockets you might want to try "
"writing to, and the last (normally left empty) those that you want to check "
"for errors. You should note that a socket can go into more than one list. "
"The ``select`` call is blocking, but you can give it a timeout. This is "
"generally a sensible thing to do - give it a nice long timeout (say a "
"minute) unless you have good reason to do otherwise."
msgstr ""
"A ``select`` se le pasan tres listas: la primera contiene todos los sockets "
"que se quiere intentar leer; la segunda todos los sockets a los que se "
"quiere intentar escribir, y la última (que normalmente se deja vacía) los "
"que se quiere comprobar si hay errores. Ten en cuenta que un socket puede ir "
"en más de una lista. La llamada a ``select`` es bloqueante, pero puedes "
"darle un tiempo de espera. Esto es generalmente lo más sensato - dale un "
"tiempo de espera largo (digamos un minuto) a menos que tengas una buena "
"razón para hacer lo contrario."

#: ../../howto/sockets.rst:360
msgid ""
"In return, you will get three lists. They contain the sockets that are "
"actually readable, writable and in error. Each of these lists is a subset "
"(possibly empty) of the corresponding list you passed in."
msgstr ""
"A cambio, obtendrás tres listas. Contienen los sockets que son realmente "
"legibles, escribibles y en error. Cada una de estas listas es un subconjunto "
"(posiblemente vacío) de la lista correspondiente que le pasaste."

#: ../../howto/sockets.rst:364
msgid ""
"If a socket is in the output readable list, you can be as-close-to-certain-"
"as-we-ever-get-in-this-business that a ``recv`` on that socket will return "
"*something*. Same idea for the writable list. You'll be able to send "
"*something*. Maybe not all you want to, but *something* is better than "
"nothing.  (Actually, any reasonably healthy socket will return as writable - "
"it just means outbound network buffer space is available.)"
msgstr ""
"Si un socket está en la lista de salida legible, puedes estar tan cerca de "
"estar seguro de que un ``recv`` en ese socket devolverá *algo*. La misma "
"idea para la lista de escritura. Podrás enviar *algo*. Tal vez no todo lo "
"que quieras, pero *algo* es mejor que nada.  (En realidad, cualquier socket "
"razonablemente sano devolverá como escribible - sólo significa que el "
"espacio de búfer de red saliente está disponible)."

#: ../../howto/sockets.rst:371
msgid ""
"If you have a \"server\" socket, put it in the potential_readers list. If it "
"comes out in the readable list, your ``accept`` will (almost certainly) "
"work. If you have created a new socket to ``connect`` to someone else, put "
"it in the potential_writers list. If it shows up in the writable list, you "
"have a decent chance that it has connected."
msgstr ""
"Si tienes un socket \"servidor\", ponlo en la lista potential_readers. Si "
"sale en la lista de legibles, tu ``accept`` funcionará (casi seguro). Si has "
"creado un nuevo socket para ``connect`` a otra persona, ponlo en la lista "
"potential_writers. Si sale en la lista de escribibles, tienes bastantes "
"posibilidades de que se haya conectado."

#: ../../howto/sockets.rst:377
msgid ""
"Actually, ``select`` can be handy even with blocking sockets. It's one way "
"of determining whether you will block - the socket returns as readable when "
"there's something in the buffers.  However, this still doesn't help with the "
"problem of determining whether the other end is done, or just busy with "
"something else."
msgstr ""
"En realidad, ``select`` puede ser útil incluso con sockets bloqueantes. Es "
"una forma de determinar si se va a bloquear - el socket retorna como legible "
"cuando hay algo en los buffers.  Sin embargo, esto todavía no ayuda con el "
"problema de determinar si el otro extremo ha terminado, o simplemente está "
"ocupado con otra cosa."

#: ../../howto/sockets.rst:382
msgid ""
"**Portability alert**: On Unix, ``select`` works both with the sockets and "
"files. Don't try this on Windows. On Windows, ``select`` works with sockets "
"only. Also note that in C, many of the more advanced socket options are done "
"differently on Windows. In fact, on Windows I usually use threads (which "
"work very, very well) with my sockets."
msgstr ""
"**Alerta de portabilidad**: En Unix, ``select`` funciona tanto con los "
"sockets como con los ficheros. No lo intentes en Windows. En Windows, "
"``select`` funciona sólo con sockets. También ten en cuenta que en C, muchas "
"de las opciones más avanzadas de sockets se hacen de forma diferente en "
"Windows. De hecho, en Windows suelo usar hilos (que funcionan muy, muy bien) "
"con mis sockets."
