# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# eulalio barbero espinosa <eulalio@disroot.org>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-10 14:49+0000\n"
"PO-Revision-Date: 2024-05-11 00:32+0000\n"
"Last-Translator: eulalio barbero espinosa <eulalio@disroot.org>, 2024\n"
"Language-Team: Spanish (Spain) (https://app.transifex.com/python-doc/"
"teams/5390/es_ES/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es_ES\n"
"Plural-Forms: nplurals=3; plural=n == 1 ? 0 : n != 0 && n % 1000000 == 0 ? "
"1 : 2;\n"

#: ../../howto/curses.rst:5
msgid "Curses Programming with Python"
msgstr "Programación con Python"

#: ../../howto/curses.rst:0
msgid "Author"
msgstr "Autor"

#: ../../howto/curses.rst:9
msgid "A.M. Kuchling, Eric S. Raymond"
msgstr "A.M. Kuchling, Eric S. Raymond"

#: ../../howto/curses.rst:0
msgid "Release"
msgstr "Publique"

#: ../../howto/curses.rst:10
msgid "2.04"
msgstr "2.04"

#: ../../howto/curses.rst-1
msgid "Abstract"
msgstr "Resumen"

#: ../../howto/curses.rst:15
msgid ""
"This document describes how to use the :mod:`curses` extension module to "
"control text-mode displays."
msgstr ""
"Este documento describe cómo utilizar el módulo de extensión :mod:`curses` "
"para controlar las pantallas en modo texto."

#: ../../howto/curses.rst:20
msgid "What is curses?"
msgstr "¿Qué son las reglas?"

#: ../../howto/curses.rst:22
msgid ""
"The curses library supplies a terminal-independent screen-painting and "
"keyboard-handling facility for text-based terminals; such terminals include "
"VT100s, the Linux console, and the simulated terminal provided by various "
"programs.  Display terminals support various control codes to perform common "
"operations such as moving the cursor, scrolling the screen, and erasing "
"areas.  Different terminals use widely differing codes, and often have their "
"own minor quirks."
msgstr ""
"La biblioteca de reglas proporciona una herramienta independiente de "
"terminal para pintar la pantalla y manejar el teclado para terminales "
"basados en texto; tales terminales incluyen VT100s, la consola Linux, y el "
"terminal simulado proporcionado por varios programas.  Los terminales de "
"pantalla admiten varios códigos de control para realizar operaciones comunes "
"como mover el cursor, desplazar la pantalla y borrar áreas.  Los distintos "
"terminales utilizan códigos muy diferentes y a menudo tienen sus propias "
"peculiaridades."

#: ../../howto/curses.rst:30
msgid ""
"In a world of graphical displays, one might ask \"why bother\"?  It's true "
"that character-cell display terminals are an obsolete technology, but there "
"are niches in which being able to do fancy things with them are still "
"valuable.  One niche is on small-footprint or embedded Unixes that don't run "
"an X server.  Another is tools such as OS installers and kernel "
"configurators that may have to run before any graphical support is available."
msgstr ""
"En un mundo de pantallas gráficas, cabe preguntarse \"¿para qué molestarse?  "
"Es cierto que los terminales con pantalla de celdas de caracteres son una "
"tecnología obsoleta, pero hay nichos en los que poder hacer cosas "
"sofisticadas con ellos sigue siendo valioso.  Un nicho es el de los Unix "
"integrados o de pequeño tamaño que no ejecutan un servidor X. Otro es el de "
"las herramientas como los instaladores de sistemas operativos.  Otro son las "
"herramientas como los instaladores de SO y los configuradores de kernel que "
"pueden tener que ejecutarse antes de disponer de soporte gráfico."

#: ../../howto/curses.rst:38
msgid ""
"The curses library provides fairly basic functionality, providing the "
"programmer with an abstraction of a display containing multiple non-"
"overlapping windows of text.  The contents of a window can be changed in "
"various ways---adding text, erasing it, changing its appearance---and the "
"curses library will figure out what control codes need to be sent to the "
"terminal to produce the right output.  curses doesn't provide many user-"
"interface concepts such as buttons, checkboxes, or dialogs; if you need such "
"features, consider a user interface library such as :pypi:`Urwid`."
msgstr ""
"La biblioteca curses ofrece una funcionalidad bastante básica, "
"proporcionando al programador una abstracción de una pantalla que contiene "
"múltiples ventanas de texto no superpuestas.  El contenido de una ventana "
"puede cambiarse de varias maneras -añadiendo texto, borrándolo, cambiando su "
"apariencia- y la biblioteca curses averiguará qué códigos de control deben "
"enviarse al terminal para producir la salida correcta. curses no proporciona "
"muchos conceptos de interfaz de usuario como botones, casillas de "
"verificación o diálogos; si necesita tales características, considere una "
"biblioteca de interfaz de usuario como :pypi:`Urwid`."

#: ../../howto/curses.rst:48
msgid ""
"The curses library was originally written for BSD Unix; the later System V "
"versions of Unix from AT&T added many enhancements and new functions. BSD "
"curses is no longer maintained, having been replaced by ncurses, which is an "
"open-source implementation of the AT&T interface.  If you're using an open-"
"source Unix such as Linux or FreeBSD, your system almost certainly uses "
"ncurses.  Since most current commercial Unix versions are based on System V "
"code, all the functions described here will probably be available.  The "
"older versions of curses carried by some proprietary Unixes may not support "
"everything, though."
msgstr ""
"La biblioteca de reglas se escribió para BSD Unix; las posteriores versiones "
"System V de Unix de AT&T añadieron muchas mejoras y nuevas funciones. Las "
"reglas BSD ya no se mantiene, se han reemplazado por nreglas, que es una "
"implementación de código abierto de la interfaz de AT&T.  Si está usando un "
"Unix de código abierto como Linux o FreeBSD, su sistema casi seguro que usa "
"nreglas.  Dado que la mayoría de las versiones comerciales actuales de Unix "
"están basadas en código System V, todas las funciones descritas aquí "
"probablemente estarán disponibles.  Sin embargo, las versiones más antiguas "
"de reglas que llevan algunos Unix propietarios pueden no soportarlo todo."

#: ../../howto/curses.rst:58
msgid ""
"The Windows version of Python doesn't include the :mod:`curses` module.  A "
"ported version called :pypi:`UniCurses` is available."
msgstr ""
"La versión de Python para Windows no incluye el módulo :mod:`curses`.  "
"Existe una versión adaptada llamada :pypi:`UniCurses`."

#: ../../howto/curses.rst:63
msgid "The Python curses module"
msgstr "El módulo curses de Python"

#: ../../howto/curses.rst:65
msgid ""
"The Python module is a fairly simple wrapper over the C functions provided "
"by curses; if you're already familiar with curses programming in C, it's "
"really easy to transfer that knowledge to Python.  The biggest difference is "
"that the Python interface makes things simpler by merging different C "
"functions such as :c:func:`!addstr`, :c:func:`!mvaddstr`, and :c:func:`!"
"mvwaddstr` into a single :meth:`~curses.window.addstr` method.  You'll see "
"this covered in more detail later."
msgstr ""
"El módulo Python es una envoltura bastante simple sobre las funciones C "
"proporcionadas por curses; si ya está familiarizado con la programación de "
"curses en C, es realmente fácil transferir ese conocimiento a Python.  La "
"mayor diferencia es que la interfaz de Python simplifica las cosas "
"fusionando diferentes funciones C como :c:func:`!addstr`, :c:func:`!"
"mvaddstr`, y :c:func:`!mvwaddstr` en un único método :meth:`~curses.window."
"addstr`.  Verás esto con más detalle más adelante."

#: ../../howto/curses.rst:73
msgid ""
"This HOWTO is an introduction to writing text-mode programs with curses and "
"Python. It doesn't attempt to be a complete guide to the curses API; for "
"that, see the Python library guide's section on ncurses, and the C manual "
"pages for ncurses.  It will, however, give you the basic ideas."
msgstr ""
"Este COMO es una introducción a la escritura de programas en modo texto con "
"curses y Python. No pretende ser una guía completa de la API de curses; para "
"eso, vea la sección de ncurses de la guía de bibliotecas de Python, y las "
"páginas del manual de C para ncurses.  Sin embargo, le dará las ideas "
"básicas."

#: ../../howto/curses.rst:80
msgid "Starting and ending a curses application"
msgstr "Iniciar y finalizar una aplicación curses"

#: ../../howto/curses.rst:82
msgid ""
"Before doing anything, curses must be initialized.  This is done by calling "
"the :func:`~curses.initscr` function, which will determine the terminal "
"type, send any required setup codes to the terminal, and create various "
"internal data structures.  If successful, :func:`!initscr` returns a window "
"object representing the entire screen; this is usually called ``stdscr`` "
"after the name of the corresponding C variable. ::"
msgstr ""
"Antes de hacer nada, curses debe inicializarse.  Esto se hace llamando a la "
"función :func:`~curses.initscr`, que determinará el tipo de terminal, "
"enviará los códigos de configuración necesarios al terminal y creará varias "
"estructuras de datos internas.  Si tiene éxito, :func:`!initscr` devuelve un "
"objeto ventana que representa toda la pantalla; normalmente se llama "
"``stdscr`` después del nombre de la variable C correspondiente. ::"

#: ../../howto/curses.rst:90
msgid ""
"import curses\n"
"stdscr = curses.initscr()"
msgstr ""
"import curses\n"
"stdscr = curses.initscr()"

#: ../../howto/curses.rst:93
msgid ""
"Usually curses applications turn off automatic echoing of keys to the "
"screen, in order to be able to read keys and only display them under certain "
"circumstances.  This requires calling the :func:`~curses.noecho` function. ::"
msgstr ""
"Normalmente las aplicaciones curses desactivan el eco automático de las "
"teclas en la pantalla, para poder leer las teclas y mostrarlas sólo en "
"determinadas circunstancias.  Para ello es necesario llamar a la función :"
"func:`~curses.noecho`. ::"

#: ../../howto/curses.rst:98
msgid "curses.noecho()"
msgstr "curses.noecho()"

#: ../../howto/curses.rst:100
msgid ""
"Applications will also commonly need to react to keys instantly, without "
"requiring the Enter key to be pressed; this is called cbreak mode, as "
"opposed to the usual buffered input mode. ::"
msgstr ""
"Las aplicaciones también suelen necesitar reaccionar a las teclas de forma "
"instantánea, sin necesidad de pulsar la tecla Intro; esto se denomina modo "
"cbreak, en contraposición al modo habitual de entrada con búfer. ::"

#: ../../howto/curses.rst:104
msgid "curses.cbreak()"
msgstr "curses.cbreak()"

#: ../../howto/curses.rst:106
msgid ""
"Terminals usually return special keys, such as the cursor keys or navigation "
"keys such as Page Up and Home, as a multibyte escape sequence.  While you "
"could write your application to expect such sequences and process them "
"accordingly, curses can do it for you, returning a special value such as :"
"const:`curses.KEY_LEFT`.  To get curses to do the job, you'll have to enable "
"keypad mode. ::"
msgstr ""
"Los terminales normalmente devuelven teclas especiales, como las teclas de "
"cursor o las teclas de navegación como Re Pág y Inicio, como una secuencia "
"de escape multibyte.  Mientras que usted podría escribir su aplicación para "
"esperar tales secuencias y procesarlas en consecuencia, curses puede hacerlo "
"por usted, devolviendo un valor especial como :const:`curses.KEY_LEFT`.  "
"Para que curses haga el trabajo, tendrá que habilitar el modo de teclado ::"

#: ../../howto/curses.rst:113
msgid "stdscr.keypad(True)"
msgstr "stdscr.keypad(True)"

#: ../../howto/curses.rst:115
msgid ""
"Terminating a curses application is much easier than starting one. You'll "
"need to call::"
msgstr ""
"Terminar una aplicación curses es mucho más fácil que iniciarla. Necesitará "
"llamar a::"

#: ../../howto/curses.rst:118
msgid ""
"curses.nocbreak()\n"
"stdscr.keypad(False)\n"
"curses.echo()"
msgstr ""
"curses.nocbreak()\n"
"stdscr.keypad(False)\n"
"curses.echo()"

#: ../../howto/curses.rst:122
msgid ""
"to reverse the curses-friendly terminal settings. Then call the :func:"
"`~curses.endwin` function to restore the terminal to its original operating "
"mode. ::"
msgstr ""
"para invertir la configuración del terminal \"curses-friendly\". A "
"continuación, llame a la función :func:`~curses.endwin` para restaurar el "
"terminal a su modo de funcionamiento original. ::"

#: ../../howto/curses.rst:126
msgid "curses.endwin()"
msgstr "curses.endwin()"

#: ../../howto/curses.rst:128
msgid ""
"A common problem when debugging a curses application is to get your terminal "
"messed up when the application dies without restoring the terminal to its "
"previous state.  In Python this commonly happens when your code is buggy and "
"raises an uncaught exception.  Keys are no longer echoed to the screen when "
"you type them, for example, which makes using the shell difficult."
msgstr ""
"Un problema común al depurar una aplicación curses es que tu terminal se "
"cuelga cuando la aplicación muere sin restaurar la terminal a su estado "
"anterior.  En Python esto sucede comúnmente cuando tu código tiene errores y "
"lanza una excepción no capturada.  Las teclas ya no se repiten en la "
"pantalla cuando las tecleas, por ejemplo, lo que dificulta el uso del shell."

#: ../../howto/curses.rst:134
msgid ""
"In Python you can avoid these complications and make debugging much easier "
"by importing the :func:`curses.wrapper` function and using it like this::"
msgstr ""
"En Python puedes evitar estas complicaciones y hacer la depuración mucho más "
"fácil importando la función :func:`curses.wrapper` y usándola así::"

#: ../../howto/curses.rst:137
msgid ""
"from curses import wrapper\n"
"\n"
"def main(stdscr):\n"
"    # Clear screen\n"
"    stdscr.clear()\n"
"\n"
"    # This raises ZeroDivisionError when i == 10.\n"
"    for i in range(0, 11):\n"
"        v = i-10\n"
"        stdscr.addstr(i, 0, '10 divided by {} is {}'.format(v, 10/v))\n"
"\n"
"    stdscr.refresh()\n"
"    stdscr.getkey()\n"
"\n"
"wrapper(main)"
msgstr ""
"from curses import wrapper\n"
"\n"
"def main(stdscr):\n"
"    # Clear screen\n"
"    stdscr.clear()\n"
"\n"
"    # This raises ZeroDivisionError when i == 10.\n"
"    for i in range(0, 11):\n"
"        v = i-10\n"
"        stdscr.addstr(i, 0, '10 divided by {} is {}'.format(v, 10/v))\n"
"\n"
"    stdscr.refresh()\n"
"    stdscr.getkey()\n"
"\n"
"wrapper(main)"

#: ../../howto/curses.rst:153
msgid ""
"The :func:`~curses.wrapper` function takes a callable object and does the "
"initializations described above, also initializing colors if color support "
"is present.  :func:`!wrapper` then runs your provided callable. Once the "
"callable returns, :func:`!wrapper` will restore the original state of the "
"terminal.  The callable is called inside a :keyword:`try`...\\ :keyword:"
"`except` that catches exceptions, restores the state of the terminal, and "
"then re-raises the exception.  Therefore your terminal won't be left in a "
"funny state on exception and you'll be able to read the exception's message "
"and traceback."
msgstr ""
"La función :func:`~curses.wrapper` toma un objeto callable y realiza las "
"inicializaciones descritas anteriormente, también inicializa los colores si "
"el soporte de color está presente. :func:`!wrapper` entonces ejecuta el "
"callable proporcionado. Una vez que el callable retorna, :func:`!wrapper` "
"restaurará el estado original de la terminal.  El callable es llamado dentro "
"de un :keyword:`try`...\\ :keyword:`except` que captura excepciones, "
"restaura el estado de la terminal, y luego vuelve a lanzar la excepción.  "
"Por lo tanto, tu terminal no se quedará en un estado extraño en la excepción "
"y podrás leer el mensaje de la excepción y el rastreo."

#: ../../howto/curses.rst:165
msgid "Windows and Pads"
msgstr "Ventanas y almohadillas"

#: ../../howto/curses.rst:167
msgid ""
"Windows are the basic abstraction in curses.  A window object represents a "
"rectangular area of the screen, and supports methods to display text, erase "
"it, allow the user to input strings, and so forth."
msgstr ""
"Las ventanas son la abstracción básica en curses.  Un objeto ventana "
"representa un área rectangular de la pantalla, y soporta métodos para "
"mostrar texto, borrarlo, permitir al usuario introducir cadenas, etc."

#: ../../howto/curses.rst:171
msgid ""
"The ``stdscr`` object returned by the :func:`~curses.initscr` function is a "
"window object that covers the entire screen.  Many programs may need only "
"this single window, but you might wish to divide the screen into smaller "
"windows, in order to redraw or clear them separately. The :func:`~curses."
"newwin` function creates a new window of a given size, returning the new "
"window object. ::"
msgstr ""
"El objeto ``stdscr`` devuelto por la función :func:`~curses.initscr` es un "
"objeto ventana que cubre toda la pantalla.  Muchos programas pueden "
"necesitar sólo esta única ventana, pero es posible que desee dividir la "
"pantalla en ventanas más pequeñas, con el fin de redibujarlas o borrarlas "
"por separado. La función :func:`~curses.newwin` crea una nueva ventana de un "
"tamaño dado, devolviendo el nuevo objeto ventana. ::"

#: ../../howto/curses.rst:178
msgid ""
"begin_x = 20; begin_y = 7\n"
"height = 5; width = 40\n"
"win = curses.newwin(height, width, begin_y, begin_x)"
msgstr ""
"begin_x = 20; begin_y = 7\n"
"height = 5; width = 40\n"
"win = curses.newwin(height, width, begin_y, begin_x)"

#: ../../howto/curses.rst:182
msgid ""
"Note that the coordinate system used in curses is unusual. Coordinates are "
"always passed in the order *y,x*, and the top-left corner of a window is "
"coordinate (0,0).  This breaks the normal convention for handling "
"coordinates where the *x* coordinate comes first.  This is an unfortunate "
"difference from most other computer applications, but it's been part of "
"curses since it was first written, and it's too late to change things now."
msgstr ""
"Tener en cuenta que el sistema de coordenadas utilizado en curses es "
"inusual. Las coordenadas siempre se pasan en el orden *y,x*, y la esquina "
"superior izquierda de una ventana es la coordenada (0,0).  Esto rompe la "
"convención normal para el manejo de coordenadas donde la coordenada *x* "
"viene primero.  Esta es una desafortunada diferencia con la mayoría de las "
"otras aplicaciones informáticas, pero ha sido parte de curses desde que fue "
"escrito, y es demasiado tarde para cambiar las cosas ahora."

#: ../../howto/curses.rst:190
msgid ""
"Your application can determine the size of the screen by using the :data:"
"`curses.LINES` and :data:`curses.COLS` variables to obtain the *y* and *x* "
"sizes.  Legal coordinates will then extend from ``(0,0)`` to ``(curses.LINES "
"- 1, curses.COLS - 1)``."
msgstr ""
"Su aplicación puede determinar el tamaño de la pantalla utilizando las "
"variables :data:`curses.LINES` y :data:`curses.COLS` para obtener los "
"tamaños *y* y *x*.  Las coordenadas legales se extenderán entonces desde "
"``(0,0)`` hasta ``(curses.LINES - 1, curses.COLS - 1)``."

#: ../../howto/curses.rst:195
msgid ""
"When you call a method to display or erase text, the effect doesn't "
"immediately show up on the display.  Instead you must call the :meth:"
"`~curses.window.refresh` method of window objects to update the screen."
msgstr ""
"Cuando se llama a un método para mostrar o borrar texto, el efecto no "
"aparece inmediatamente en la pantalla.  En su lugar, debes llamar al método :"
"meth:`~curses.window.refresh` de los objetos ventana para actualizar la "
"pantalla."

#: ../../howto/curses.rst:200
msgid ""
"This is because curses was originally written with slow 300-baud terminal "
"connections in mind; with these terminals, minimizing the time required to "
"redraw the screen was very important.  Instead curses accumulates changes to "
"the screen and displays them in the most efficient manner when you call :"
"meth:`!refresh`.  For example, if your program displays some text in a "
"window and then clears the window, there's no need to send the original text "
"because they're never visible."
msgstr ""
"Esto se debe a que curses fue escrito originalmente pensando en conexiones "
"lentas de terminales de 300 baudios; con estos terminales, minimizar el "
"tiempo necesario para redibujar la pantalla era muy importante.  En su lugar "
"curses acumula los cambios en la pantalla y los muestra de la manera más "
"eficiente cuando usted llama a :meth:`!refresh`.  Por ejemplo, si su "
"programa muestra algún texto en una ventana y luego borra la ventana, no hay "
"necesidad de enviar el texto original porque nunca son visibles."

#: ../../howto/curses.rst:209
msgid ""
"In practice, explicitly telling curses to redraw a window doesn't really "
"complicate programming with curses much. Most programs go into a flurry of "
"activity, and then pause waiting for a keypress or some other action on the "
"part of the user.  All you have to do is to be sure that the screen has been "
"redrawn before pausing to wait for user input, by first calling :meth:`!"
"stdscr.refresh` or the :meth:`!refresh` method of some other relevant window."
msgstr ""
"En la práctica, decirle explícitamente a curses que redibuje una ventana no "
"complica mucho la programación con curses. La mayoría de los programas "
"entran en un frenesí de actividad, y luego hacen una pausa esperando a que "
"el usuario pulse una tecla o realice alguna otra acción.  Todo lo que tiene "
"que hacer es asegurarse de que la pantalla ha sido redibujada antes de hacer "
"una pausa para esperar la entrada del usuario, llamando primero a :meth:`!"
"stdscr.refresh` o al método :meth:`!refresh` de alguna otra ventana "
"relevante."

#: ../../howto/curses.rst:217
msgid ""
"A pad is a special case of a window; it can be larger than the actual "
"display screen, and only a portion of the pad displayed at a time. Creating "
"a pad requires the pad's height and width, while refreshing a pad requires "
"giving the coordinates of the on-screen area where a subsection of the pad "
"will be displayed.  ::"
msgstr ""
"Un pad es un caso especial de ventana; puede ser más grande que la pantalla "
"de visualización real, y sólo una parte del pad se muestra a la vez. Para "
"crear un pad se necesita la altura y la anchura del pad, mientras que para "
"actualizarlo hay que dar las coordenadas de la zona de la pantalla en la que "
"se mostrará una subsección del pad. ::"

#: ../../howto/curses.rst:223
msgid ""
"pad = curses.newpad(100, 100)\n"
"# These loops fill the pad with letters; addch() is\n"
"# explained in the next section\n"
"for y in range(0, 99):\n"
"    for x in range(0, 99):\n"
"        pad.addch(y,x, ord('a') + (x*x+y*y) % 26)\n"
"\n"
"# Displays a section of the pad in the middle of the screen.\n"
"# (0,0) : coordinate of upper-left corner of pad area to display.\n"
"# (5,5) : coordinate of upper-left corner of window area to be filled\n"
"#         with pad content.\n"
"# (20, 75) : coordinate of lower-right corner of window area to be\n"
"#          : filled with pad content.\n"
"pad.refresh( 0,0, 5,5, 20,75)"
msgstr ""
"pad = curses.newpad(100, 100)\n"
"# Estos bucles llenan el pad con letras; addch() is\n"
"# se explica en la siguiente sección\n"
"para y en rango(0, 99):\n"
"    for x in range(0, 99):\n"
"        pad.addch(y,x, ord('a') + (x*x+y*y) % 26)\n"
"\n"
"# Muestra una sección del pad en el centro de la pantalla.\n"
"# (0,0) : coordenada de la esquina superior izquierda del área del pad a "
"mostrar.\n"
"# (5,5) : coordenada de la esquina superior izquierda del área de la ventana "
"que se rellenará\n"
"# con el contenido del pad.\n"
"(20, 75) : coordenada de la esquina inferior derecha del área de la ventana "
"que se llenará # con el contenido del pad.\n"
"# : rellenar con el contenido del pad.\n"
"pad.refresh( 0,0, 5,5, 20,75)"

#: ../../howto/curses.rst:238
msgid ""
"The :meth:`!refresh` call displays a section of the pad in the rectangle "
"extending from coordinate (5,5) to coordinate (20,75) on the screen; the "
"upper left corner of the displayed section is coordinate (0,0) on the pad.  "
"Beyond that difference, pads are exactly like ordinary windows and support "
"the same methods."
msgstr ""
"La llamada a :meth:`!refresh` muestra una sección del pad en el rectángulo "
"que se extiende desde la coordenada (5,5) hasta la coordenada (20,75) en la "
"pantalla; la esquina superior izquierda de la sección mostrada es la "
"coordenada (0,0) en el pad.  Más allá de esta diferencia, los pads son "
"exactamente iguales que las ventanas normales y admiten los mismos métodos."

#: ../../howto/curses.rst:244
msgid ""
"If you have multiple windows and pads on screen there is a more efficient "
"way to update the screen and prevent annoying screen flicker as each part of "
"the screen gets updated.  :meth:`!refresh` actually does two things:"
msgstr ""
"Si tienes varias ventanas y pads en pantalla, hay una forma más eficiente de "
"actualizar la pantalla y evitar el molesto parpadeo de la pantalla a medida "
"que se actualiza cada parte de la pantalla. :meth:`!refresh` en realidad "
"hace dos cosas:"

#: ../../howto/curses.rst:249
msgid ""
"Calls the :meth:`~curses.window.noutrefresh` method of each window to update "
"an underlying data structure representing the desired state of the screen."
msgstr ""
"Llama al método :meth:`~curses.window.noutrefresh` de cada ventana para "
"actualizar una estructura de datos subyacente que representa el estado "
"deseado de la pantalla."

#: ../../howto/curses.rst:252
msgid ""
"Calls the function :func:`~curses.doupdate` function to change the physical "
"screen to match the desired state recorded in the data structure."
msgstr ""
"Llama a la función :func:`~curses.doupdate` función para cambiar la pantalla "
"física para que coincida con el estado deseado registrado en la estructura "
"de datos."

#: ../../howto/curses.rst:255
msgid ""
"Instead you can call :meth:`!noutrefresh` on a number of windows to update "
"the data structure, and then call :func:`!doupdate` to update the screen."
msgstr ""
"En su lugar, puede llamar a :meth:`!noutrefresh` en varias ventanas para "
"actualizar la estructura de datos y, a continuación, llamar a :func:`!"
"doupdate` para actualizar la pantalla."

#: ../../howto/curses.rst:261
msgid "Displaying Text"
msgstr "Mostrar texto"

#: ../../howto/curses.rst:263
msgid ""
"From a C programmer's point of view, curses may sometimes look like a twisty "
"maze of functions, all subtly different.  For example, :c:func:`!addstr` "
"displays a string at the current cursor location in the ``stdscr`` window, "
"while :c:func:`!mvaddstr` moves to a given y,x coordinate first before "
"displaying the string. :c:func:`!waddstr` is just like :c:func:`!addstr`, "
"but allows specifying a window to use instead of using ``stdscr`` by "
"default. :c:func:`!mvwaddstr` allows specifying both a window and a "
"coordinate."
msgstr ""
"Desde el punto de vista de un programador de C, los curses pueden parecer a "
"veces un laberinto de funciones, todas ellas sutilmente diferentes.  Por "
"ejemplo, :c:func:`!addstr` muestra una cadena en la posición actual del "
"cursor en la ventana ``stdscr``, mientras que :c:func:`!mvaddstr` se mueve "
"primero a una coordenada y,x dada antes de mostrar la cadena. :c:func:`!"
"waddstr` es igual que :c:func:`!addstr`, pero permite especificar una "
"ventana a utilizar en lugar de utilizar ``stdscr`` por defecto. :c:func:`!"
"mvwaddstr` permite especificar tanto una ventana como una coordenada."

#: ../../howto/curses.rst:272
msgid ""
"Fortunately the Python interface hides all these details.  ``stdscr`` is a "
"window object like any other, and methods such as :meth:`~curses.window."
"addstr` accept multiple argument forms.  Usually there are four different "
"forms."
msgstr ""
"Afortunadamente, la interfaz de Python oculta todos estos detalles. "
"``stdscr`` es un objeto ventana como cualquier otro, y métodos como :meth:"
"`~curses.window.addstr` aceptan múltiples formas de argumento.  Normalmente "
"hay cuatro formas diferentes."

#: ../../howto/curses.rst:278
msgid "Form"
msgstr "Formulario"

#: ../../howto/curses.rst:278 ../../howto/curses.rst:346
msgid "Description"
msgstr "Description"

#: ../../howto/curses.rst:280
msgid "*str* or *ch*"
msgstr "*str* o *ch*"

#: ../../howto/curses.rst:280
msgid "Display the string *str* or character *ch* at the current position"
msgstr "Mostrar la cadena *str* o el carácter *ch* en la posición actual"

#: ../../howto/curses.rst:283
msgid "*str* or *ch*, *attr*"
msgstr "*str* o *ch*, *attr*"

#: ../../howto/curses.rst:283
msgid ""
"Display the string *str* or character *ch*, using attribute *attr* at the "
"current position"
msgstr ""
"Mostrar la cadena *str* o el carácter *ch*, utilizando el atributo *attr* en "
"la posición actual"

#: ../../howto/curses.rst:287
msgid "*y*, *x*, *str* or *ch*"
msgstr "*y*, *x*, *str* o *ch*"

#: ../../howto/curses.rst:287
msgid "Move to position *y,x* within the window, and display *str* or *ch*"
msgstr "Mover a la posición *y,x* dentro de la ventana, y mostrar *str* o *ch"

#: ../../howto/curses.rst:290
msgid "*y*, *x*, *str* or *ch*, *attr*"
msgstr "*y*, *x*, *str* o *ch*, *attr*"

#: ../../howto/curses.rst:290
msgid ""
"Move to position *y,x* within the window, and display *str* or *ch*, using "
"attribute *attr*"
msgstr ""
"Mover a la posición *y,x* dentro de la ventana, y mostrar *str* o *ch*, "
"usando el atributo *attr*"

#: ../../howto/curses.rst:294
msgid ""
"Attributes allow displaying text in highlighted forms such as boldface, "
"underline, reverse code, or in color.  They'll be explained in more detail "
"in the next subsection."
msgstr ""
"Los atributos permiten mostrar el texto en formas resaltadas, como negrita, "
"subrayado, código inverso o en color.  Se explicarán con más detalle en la "
"siguiente subsección."

#: ../../howto/curses.rst:299
msgid ""
"The :meth:`~curses.window.addstr` method takes a Python string or bytestring "
"as the value to be displayed.  The contents of bytestrings are sent to the "
"terminal as-is.  Strings are encoded to bytes using the value of the "
"window's :attr:`~window.encoding` attribute; this defaults to the default "
"system encoding as returned by :func:`locale.getencoding`."
msgstr ""
"El método :meth:`~curses.window.addstr` toma una cadena Python o bytestring "
"como valor a mostrar.  El contenido de las cadenas de bytes se envía al "
"terminal tal cual.  Las cadenas se codifican en bytes utilizando el valor "
"del atributo :attr:`~window.encoding` de la ventana; este valor por defecto "
"es la codificación del sistema devuelta por :func:`locale.getencoding`."

#: ../../howto/curses.rst:305
msgid ""
"The :meth:`~curses.window.addch` methods take a character, which can be "
"either a string of length 1, a bytestring of length 1, or an integer."
msgstr ""
"Los métodos :meth:`~curses.window.addch` toman un carácter, que puede ser "
"una cadena de longitud 1, una bytestring de longitud 1 o un entero."

#: ../../howto/curses.rst:308
msgid ""
"Constants are provided for extension characters; these constants are "
"integers greater than 255.  For example, :const:`ACS_PLMINUS` is a +/- "
"symbol, and :const:`ACS_ULCORNER` is the upper left corner of a box (handy "
"for drawing borders).  You can also use the appropriate Unicode character."
msgstr ""
"Se proporcionan constantes para los caracteres de extensión; estas "
"constantes son números enteros mayores que 255.  Por ejemplo, :const:"
"`ACS_PLMINUS` es un símbolo +/-, y :const:`ACS_ULCORNER` es la esquina "
"superior izquierda de una caja (útil para dibujar bordes).  También puede "
"utilizar el carácter Unicode apropiado."

#: ../../howto/curses.rst:314
msgid ""
"Windows remember where the cursor was left after the last operation, so if "
"you leave out the *y,x* coordinates, the string or character will be "
"displayed wherever the last operation left off.  You can also move the "
"cursor with the ``move(y,x)`` method.  Because some terminals always display "
"a flashing cursor, you may want to ensure that the cursor is positioned in "
"some location where it won't be distracting; it can be confusing to have the "
"cursor blinking at some apparently random location."
msgstr ""
"Windows recuerda dónde quedó el cursor después de la última operación, por "
"lo que si omite las coordenadas *y,x*, la cadena o carácter se mostrará "
"donde lo dejó la última operación.  También puede mover el cursor con el "
"método ``move(y,x)``.  Debido a que algunas terminales siempre muestran un "
"cursor parpadeante, es posible que desee asegurarse de que el cursor se "
"coloca en algún lugar donde no se distraiga; puede ser confuso tener el "
"cursor parpadeando en algún lugar aparentemente al azar."

#: ../../howto/curses.rst:322
msgid ""
"If your application doesn't need a blinking cursor at all, you can call "
"``curs_set(False)`` to make it invisible.  For compatibility with older "
"curses versions, there's a ``leaveok(bool)`` function that's a synonym for :"
"func:`~curses.curs_set`.  When *bool* is true, the curses library will "
"attempt to suppress the flashing cursor, and you won't need to worry about "
"leaving it in odd locations."
msgstr ""
"Si su aplicación no necesita un cursor parpadeante, puede llamar a "
"``curs_set(False)`` para hacerlo invisible.  Por compatibilidad con "
"versiones anteriores de curses, existe una función ``leaveok(bool)`` que es "
"sinónimo de :func:`~curses.curs_set`.  Cuando *bool* es true, la librería "
"curses intentará suprimir el cursor parpadeante, y no tendrá que preocuparse "
"de dejarlo en lugares extraños."

#: ../../howto/curses.rst:331
msgid "Attributes and Color"
msgstr "Atributos y color"

#: ../../howto/curses.rst:333
msgid ""
"Characters can be displayed in different ways.  Status lines in a text-based "
"application are commonly shown in reverse video, or a text viewer may need "
"to highlight certain words.  curses supports this by allowing you to specify "
"an attribute for each cell on the screen."
msgstr ""
"Los caracteres pueden mostrarse de diferentes maneras.  Las líneas de estado "
"en una aplicación basada en texto se muestran comúnmente en vídeo inverso, o "
"un visor de texto puede necesitar resaltar ciertas palabras. curses soporta "
"esto permitiéndole especificar un atributo para cada celda en la pantalla."

#: ../../howto/curses.rst:338
msgid ""
"An attribute is an integer, each bit representing a different attribute.  "
"You can try to display text with multiple attribute bits set, but curses "
"doesn't guarantee that all the possible combinations are available, or that "
"they're all visually distinct.  That depends on the ability of the terminal "
"being used, so it's safest to stick to the most commonly available "
"attributes, listed here."
msgstr ""
"Un atributo es un número entero, cada bit representa un atributo diferente.  "
"Puede intentar mostrar texto con múltiples bits de atributo, pero curses no "
"garantiza que todas las combinaciones posibles estén disponibles, o que "
"todas sean visualmente distintas.  Eso depende de la capacidad del terminal "
"que se esté usando, así que lo más seguro es ceñirse a los atributos más "
"comúnmente disponibles, listados aquí."

#: ../../howto/curses.rst:346
msgid "Attribute"
msgstr "Atributo"

#: ../../howto/curses.rst:348
msgid ":const:`A_BLINK`"
msgstr ":const:`A_BLINK`"

#: ../../howto/curses.rst:348
msgid "Blinking text"
msgstr "Texto intermitente"

#: ../../howto/curses.rst:350
msgid ":const:`A_BOLD`"
msgstr ":const:`A_BOLD`"

#: ../../howto/curses.rst:350
msgid "Extra bright or bold text"
msgstr "Texto muy brillante o en negrita"

#: ../../howto/curses.rst:352
msgid ":const:`A_DIM`"
msgstr ":const:`A_DIM`"

#: ../../howto/curses.rst:352
msgid "Half bright text"
msgstr "Texto medio brillante"

#: ../../howto/curses.rst:354
msgid ":const:`A_REVERSE`"
msgstr ":const:`A_REVERSE`"

#: ../../howto/curses.rst:354
msgid "Reverse-video text"
msgstr "Texto de vídeo inverso"

#: ../../howto/curses.rst:356
msgid ":const:`A_STANDOUT`"
msgstr ":const:`A_STANDOUT`"

#: ../../howto/curses.rst:356
msgid "The best highlighting mode available"
msgstr "El mejor modo de resaltado disponible"

#: ../../howto/curses.rst:358
msgid ":const:`A_UNDERLINE`"
msgstr ":const:`A_UNDERLINE`"

#: ../../howto/curses.rst:358
msgid "Underlined text"
msgstr "Texto subrayado"

#: ../../howto/curses.rst:361
msgid ""
"So, to display a reverse-video status line on the top line of the screen, "
"you could code::"
msgstr ""
"Así, para mostrar una línea de estado de vídeo inverso en la línea superior "
"de la pantalla, podrías codificar::"

#: ../../howto/curses.rst:364
msgid ""
"stdscr.addstr(0, 0, \"Current mode: Typing mode\",\n"
"              curses.A_REVERSE)\n"
"stdscr.refresh()"
msgstr ""
"stdscr.addstr(0, 0, \"Modo actual: Typing mode\",\n"
"              curses.A_REVERSE)\n"
"stdscr.refresh()"

#: ../../howto/curses.rst:368
msgid ""
"The curses library also supports color on those terminals that provide it. "
"The most common such terminal is probably the Linux console, followed by "
"color xterms."
msgstr ""
"La biblioteca curses también soporta color en aquellos terminales que lo "
"proporcionan. El terminal más común es probablemente la consola de Linux, "
"seguido de xterms en color."

#: ../../howto/curses.rst:372
msgid ""
"To use color, you must call the :func:`~curses.start_color` function soon "
"after calling :func:`~curses.initscr`, to initialize the default color set "
"(the :func:`curses.wrapper` function does this automatically).  Once that's "
"done, the :func:`~curses.has_colors` function returns TRUE if the terminal "
"in use can actually display color.  (Note: curses uses the American spelling "
"'color', instead of the Canadian/British spelling 'colour'.  If you're used "
"to the British spelling, you'll have to resign yourself to misspelling it "
"for the sake of these functions.)"
msgstr ""
"Para utilizar el color, debe llamar a la función :func:`~curses.start_color` "
"poco después de llamar a :func:`~curses.initscr`, para inicializar el "
"conjunto de colores por defecto (la función :func:`curses.wrapper` lo hace "
"automáticamente).  Una vez hecho esto, la función :func:`~curses.has_colors` "
"devuelve TRUE si el terminal en uso puede realmente mostrar color. (Nota: "
"curses utiliza la ortografía americana 'color', en lugar de la ortografía "
"canadiense/británica 'color'.  Si está acostumbrado a la ortografía "
"británica, tendrá que resignarse a escribirlo mal por el bien de estas "
"funciones)."

#: ../../howto/curses.rst:382
msgid ""
"The curses library maintains a finite number of color pairs, containing a "
"foreground (or text) color and a background color.  You can get the "
"attribute value corresponding to a color pair with the :func:`~curses."
"color_pair` function; this can be bitwise-OR'ed with other attributes such "
"as :const:`A_REVERSE`, but again, such combinations are not guaranteed to "
"work on all terminals."
msgstr ""
"La biblioteca curses mantiene un número finito de pares de colores, que "
"contienen un color de primer plano (o texto) y un color de fondo.  Puede "
"obtener el valor del atributo correspondiente a un par de colores con la "
"función :func:`~curses.color_pair`; esto puede ser bitwise-OR con otros "
"atributos como :const:`A_REVERSE`, pero de nuevo, no se garantiza que tales "
"combinaciones funcionen en todos los terminales."

#: ../../howto/curses.rst:389
msgid "An example, which displays a line of text using color pair 1::"
msgstr ""
"Un ejemplo, que muestra una línea de texto utilizando el par de colores 1::"

#: ../../howto/curses.rst:391
msgid ""
"stdscr.addstr(\"Pretty text\", curses.color_pair(1))\n"
"stdscr.refresh()"
msgstr ""
"stdscr.addstr(\"Texto bonito\", curses.color_pair(1))\n"
"stdscr.refresh()"

#: ../../howto/curses.rst:394
msgid ""
"As I said before, a color pair consists of a foreground and background "
"color. The ``init_pair(n, f, b)`` function changes the definition of color "
"pair *n*, to foreground color f and background color b.  Color pair 0 is "
"hard-wired to white on black, and cannot be changed."
msgstr ""
"Como he dicho antes, un par de colores consiste en un color de primer plano "
"y un color de fondo. La función ``init_pair(n, f, b)`` cambia la definición "
"del par de colores *n*, a color de primer plano f y color de fondo b. El par "
"de colores 0 está programado para blanco sobre negro, y no se puede cambiar."

#: ../../howto/curses.rst:399
msgid ""
"Colors are numbered, and :func:`start_color` initializes 8 basic colors when "
"it activates color mode.  They are: 0:black, 1:red, 2:green, 3:yellow, 4:"
"blue, 5:magenta, 6:cyan, and 7:white.  The :mod:`curses` module defines "
"named constants for each of these colors: :const:`curses.COLOR_BLACK`, :"
"const:`curses.COLOR_RED`, and so forth."
msgstr ""
"Los colores están numerados, y :func:`start_color` inicializa 8 colores "
"básicos cuando activa el modo color.  Estos son: 0:negro, 1:rojo, 2:verde, 3:"
"amarillo, 4:azul, 5:magenta, 6:cian y 7:blanco.  El módulo :mod:`curses` "
"define constantes con nombre para cada uno de estos colores: :const:`curses."
"COLOR_BLACK`, :const:`curses.COLOR_RED`, y así sucesivamente."

#: ../../howto/curses.rst:405
msgid ""
"Let's put all this together. To change color 1 to red text on a white "
"background, you would call::"
msgstr ""
"Pongamos todo esto junto. Para cambiar el color 1 a texto rojo sobre fondo "
"blanco, se llamaría::"

#: ../../howto/curses.rst:408
msgid "curses.init_pair(1, curses.COLOR_RED, curses.COLOR_WHITE)"
msgstr "curses.init_pair(1, curses.COLOR_RED, curses.COLOR_WHITE)"

#: ../../howto/curses.rst:410
msgid ""
"When you change a color pair, any text already displayed using that color "
"pair will change to the new colors.  You can also display new text in this "
"color with::"
msgstr ""
"Cuando cambie un par de colores, cualquier texto que ya se muestre "
"utilizando ese par de colores cambiará a los nuevos colores.  También puede "
"mostrar texto nuevo en este color con::"

#: ../../howto/curses.rst:414
msgid "stdscr.addstr(0,0, \"RED ALERT!\", curses.color_pair(1))"
msgstr "stdscr.addstr(0,0, \"RED ALERT!\", curses.color_pair(1))"

#: ../../howto/curses.rst:416
msgid ""
"Very fancy terminals can change the definitions of the actual colors to a "
"given RGB value.  This lets you change color 1, which is usually red, to "
"purple or blue or any other color you like.  Unfortunately, the Linux "
"console doesn't support this, so I'm unable to try it out, and can't provide "
"any examples.  You can check if your terminal can do this by calling :func:"
"`~curses.can_change_color`, which returns ``True`` if the capability is "
"there.  If you're lucky enough to have such a talented terminal, consult "
"your system's man pages for more information."
msgstr ""
"Los terminales más sofisticados pueden cambiar las definiciones de los "
"colores reales a un valor RGB determinado.  Esto te permite cambiar el color "
"1, que normalmente es rojo, a púrpura o azul o cualquier otro color que te "
"guste.  Desafortunadamente, la consola de Linux no soporta esto, así que no "
"puedo probarlo, y no puedo proporcionar ningún ejemplo.  Puedes comprobar si "
"tu terminal puede hacer esto llamando a :func:`~curses.can_change_color`, "
"que devuelve ``True`` si la capacidad está ahí.  Si tienes la suerte de "
"tener un terminal tan inteligente, consulta las páginas man de tu sistema "
"para más información."

#: ../../howto/curses.rst:427
msgid "User Input"
msgstr "Entrada del usuario"

#: ../../howto/curses.rst:429
msgid ""
"The C curses library offers only very simple input mechanisms. Python's :mod:"
"`curses` module adds a basic text-input widget.  (Other libraries such as :"
"pypi:`Urwid` have more extensive collections of widgets.)"
msgstr ""
"La biblioteca C curses sólo ofrece mecanismos de entrada muy simples. El "
"módulo :mod:`curses` de Python añade un widget básico de entrada de texto.  "
"(Otras bibliotecas como :pypi:`Urwid` tienen colecciones más extensas de "
"widgets)."

#: ../../howto/curses.rst:433
msgid "There are two methods for getting input from a window:"
msgstr "Existen dos métodos para obtener información de una ventana:"

#: ../../howto/curses.rst:435
msgid ""
":meth:`~curses.window.getch` refreshes the screen and then waits for the "
"user to hit a key, displaying the key if :func:`~curses.echo` has been "
"called earlier.  You can optionally specify a coordinate to which the cursor "
"should be moved before pausing."
msgstr ""
":meth:`~curses.window.getch` refresca la pantalla y luego espera a que el "
"usuario pulse una tecla, mostrando la tecla si se ha llamado antes a :func:"
"`~curses.echo`.  Opcionalmente se puede especificar una coordenada a la que "
"se debe mover el cursor antes de hacer una pausa."

#: ../../howto/curses.rst:440
msgid ""
":meth:`~curses.window.getkey` does the same thing but converts the integer "
"to a string.  Individual characters are returned as 1-character strings, and "
"special keys such as function keys return longer strings containing a key "
"name such as ``KEY_UP`` or ``^G``."
msgstr ""
":meth:`~curses.window.getkey` hace lo mismo pero convierte el entero en una "
"cadena.  Los caracteres individuales se devuelven como cadenas de 1 "
"carácter, y las teclas especiales, como las teclas de función, devuelven "
"cadenas más largas que contienen un nombre de tecla como ``KEY_UP`` o ``^G``."

#: ../../howto/curses.rst:445
msgid ""
"It's possible to not wait for the user using the :meth:`~curses.window."
"nodelay` window method. After ``nodelay(True)``, :meth:`!getch` and :meth:`!"
"getkey` for the window become non-blocking. To signal that no input is "
"ready, :meth:`!getch` returns ``curses.ERR`` (a value of -1) and :meth:`!"
"getkey` raises an exception. There's also a :func:`~curses.halfdelay` "
"function, which can be used to (in effect) set a timer on each :meth:`!"
"getch`; if no input becomes available within a specified delay (measured in "
"tenths of a second), curses raises an exception."
msgstr ""
"Es posible no esperar al usuario utilizando el método de ventana :meth:"
"`~curses.window.nodelay`. Después de ``nodelay(True)``, :meth:`!getch` y :"
"meth:`!getkey` para la ventana se convierten en no bloqueantes. Para señalar "
"que no hay ninguna entrada lista, :meth:`!getch` devuelve ``curses.ERR`` (un "
"valor de -1) y :meth:`!getkey` lanza una excepción. También hay una función :"
"func:`~curses.halfdelay`, que se puede utilizar para (en efecto) establecer "
"un temporizador en cada :meth:`!getch`; si no hay ninguna entrada disponible "
"dentro de un retardo especificado (medido en décimas de segundo), curses "
"lanza una excepción."

#: ../../howto/curses.rst:455
msgid ""
"The :meth:`!getch` method returns an integer; if it's between 0 and 255, it "
"represents the ASCII code of the key pressed.  Values greater than 255 are "
"special keys such as Page Up, Home, or the cursor keys. You can compare the "
"value returned to constants such as :const:`curses.KEY_PPAGE`, :const:"
"`curses.KEY_HOME`, or :const:`curses.KEY_LEFT`.  The main loop of your "
"program may look something like this::"
msgstr ""
"El método :meth:`!getch` devuelve un número entero; si está entre 0 y 255, "
"representa el código ASCII de la tecla pulsada.  Los valores superiores a "
"255 son teclas especiales como Re Pág, Inicio o las teclas del cursor. Puede "
"comparar el valor devuelto con constantes como :const:`curses.KEY_PPAGE`, :"
"const:`curses.KEY_HOME`, o :const:`curses.KEY_LEFT`. El bucle principal de "
"su programa puede ser algo parecido a esto::"

#: ../../howto/curses.rst:462
msgid ""
"while True:\n"
"    c = stdscr.getch()\n"
"    if c == ord('p'):\n"
"        PrintDocument()\n"
"    elif c == ord('q'):\n"
"        break  # Exit the while loop\n"
"    elif c == curses.KEY_HOME:\n"
"        x = y = 0"
msgstr ""
"while True:\n"
"    c = stdscr.getch()\n"
"    if c == ord('p'):\n"
"        PrintDocument()\n"
"    elif c == ord('q'):\n"
"        break # Salir del bucle while\n"
"    elif c == curses.KEY_HOME:\n"
"        x = y = 0"

#: ../../howto/curses.rst:471
msgid ""
"The :mod:`curses.ascii` module supplies ASCII class membership functions "
"that take either integer or 1-character string arguments; these may be "
"useful in writing more readable tests for such loops.  It also supplies "
"conversion functions  that take either integer or 1-character-string "
"arguments and return the same type.  For example, :func:`curses.ascii.ctrl` "
"returns the control character corresponding to its argument."
msgstr ""
"El módulo :mod:`curses.ascii` proporciona funciones de pertenencia a la "
"clase ASCII que toman argumentos enteros o de cadena de 1 carácter; pueden "
"ser útiles para escribir pruebas más legibles para este tipo de bucles.  "
"También proporciona funciones de conversión que toman argumentos enteros o "
"de cadena de 1 carácter y devuelven el mismo tipo.  Por ejemplo, :func:"
"`curses.ascii.ctrl` devuelve el carácter de control correspondiente a su "
"argumento."

#: ../../howto/curses.rst:478
msgid ""
"There's also a method to retrieve an entire string, :meth:`~curses.window."
"getstr`.  It isn't used very often, because its functionality is quite "
"limited; the only editing keys available are the backspace key and the Enter "
"key, which terminates the string.  It can optionally be limited to a fixed "
"number of characters. ::"
msgstr ""
"También existe un método para recuperar una cadena completa, :meth:`~curses."
"window.getstr`.  No se utiliza muy a menudo, porque su funcionalidad es "
"bastante limitada; las únicas teclas de edición disponibles son la tecla de "
"retroceso y la tecla Intro, que termina la cadena.  Opcionalmente, puede "
"limitarse a un número fijo de caracteres. ::"

#: ../../howto/curses.rst:484
msgid ""
"curses.echo()            # Enable echoing of characters\n"
"\n"
"# Get a 15-character string, with the cursor on the top line\n"
"s = stdscr.getstr(0,0, 15)"
msgstr ""
"curses.echo() # Activar el eco de caracteres\n"
"\n"
"# Obtener una cadena de 15 caracteres, con el cursor en la línea superior\n"
"s = stdscr.getstr(0,0, 15)"

#: ../../howto/curses.rst:489
msgid ""
"The :mod:`curses.textpad` module supplies a text box that supports an Emacs-"
"like set of keybindings.  Various methods of the :class:`~curses.textpad."
"Textbox` class support editing with input validation and gathering the edit "
"results either with or without trailing spaces.  Here's an example::"
msgstr ""
"El módulo :mod:`curses.textpad` proporciona un cuadro de texto que admite un "
"conjunto de combinaciones de teclas similar al de Emacs.  Varios métodos de "
"la clase :class:`~curses.textpad.Textbox` soportan la edición con validación "
"de entrada y recogen los resultados de la edición con o sin espacios "
"finales.  He aquí un ejemplo::"

#: ../../howto/curses.rst:495
msgid ""
"import curses\n"
"from curses.textpad import Textbox, rectangle\n"
"\n"
"def main(stdscr):\n"
"    stdscr.addstr(0, 0, \"Enter IM message: (hit Ctrl-G to send)\")\n"
"\n"
"    editwin = curses.newwin(5,30, 2,1)\n"
"    rectangle(stdscr, 1,0, 1+5+1, 1+30+1)\n"
"    stdscr.refresh()\n"
"\n"
"    box = Textbox(editwin)\n"
"\n"
"    # Let the user edit until Ctrl-G is struck.\n"
"    box.edit()\n"
"\n"
"    # Get resulting contents\n"
"    message = box.gather()"
msgstr ""
"import curses\n"
"from curses.textpad  import Textbox, rectangle\n"
"\n"
"def main(stdscr):\n"
"    stdscr.addstr(0, 0, \"Introducir mensaje de MI: (pulsa Ctrl-G para "
"enviar)\")\n"
"\n"
"    editwin = curses.newwin(5,30, 2,1)\n"
"    rectangle(stdscr, 1,0, 1+5+1, 1+30+1)\n"
"    stdscr.refresh()\n"
"\n"
"    box = Textbox(editwin)\n"
"\n"
"    # Deja que el usuario edite hasta que pulse Ctrl-G.\n"
"    box.edit()\n"
"\n"
"    # Obtener el contenido resultante\n"
"    message = box.gather()"

#: ../../howto/curses.rst:513
msgid ""
"See the library documentation on :mod:`curses.textpad` for more details."
msgstr ""
"Ver la documentación de la biblioteca en :mod:`curses.textpad` para más "
"detalles."

#: ../../howto/curses.rst:517
msgid "For More Information"
msgstr "Para más información"

#: ../../howto/curses.rst:519
msgid ""
"This HOWTO doesn't cover some advanced topics, such as reading the contents "
"of the screen or capturing mouse events from an xterm instance, but the "
"Python library page for the :mod:`curses` module is now reasonably "
"complete.  You should browse it next."
msgstr ""
"Este CÓMO no cubre algunos temas avanzados, como la lectura del contenido de "
"la pantalla o la captura de eventos del ratón desde una instancia de xterm, "
"pero la página de la librería Python para el módulo :mod:`curses` está ahora "
"razonablemente completa.  Deberías navegar por ella a continuación."

#: ../../howto/curses.rst:524
msgid ""
"If you're in doubt about the detailed behavior of the curses functions, "
"consult the manual pages for your curses implementation, whether it's "
"ncurses or a proprietary Unix vendor's.  The manual pages will document any "
"quirks, and provide complete lists of all the functions, attributes, and :"
"ref:`ACS_\\* <curses-acs-codes>` characters available to you."
msgstr ""
"Si tiene dudas sobre el comportamiento detallado de las funciones de curses, "
"consulte las páginas de manual de su implementación de curses, ya sea "
"ncurses o un vendedor propietario de Unix.  Las páginas del manual "
"documentarán cualquier peculiaridad, y le proporcionarán listas completas de "
"todas las funciones, atributos, y caracteres :ref:`ACS_\\* <curses-acs-"
"codes>` disponibles para usted."

#: ../../howto/curses.rst:531
msgid ""
"Because the curses API is so large, some functions aren't supported in the "
"Python interface.  Often this isn't because they're difficult to implement, "
"but because no one has needed them yet.  Also, Python doesn't yet support "
"the menu library associated with ncurses. Patches adding support for these "
"would be welcome; see `the Python Developer's Guide <https://devguide.python."
"org/>`_ to learn more about submitting patches to Python."
msgstr ""
"Debido a que la API de curses es tan grande, algunas funciones no están "
"soportadas en la interfaz de Python.  A menudo esto no es porque sean "
"difíciles de implementar, sino porque nadie las ha necesitado todavía.  "
"Además, Python todavía no soporta la biblioteca de menús asociada con "
"ncurses. Parches que añadan soporte para esto serían bienvenidos; vea `the "
"Python Developer's Guide <https://devguide.python.org/>`_ para aprender más "
"sobre el envío de parches a Python."

#: ../../howto/curses.rst:539
msgid ""
"`Writing Programs with NCURSES <https://invisible-island.net/ncurses/ncurses-"
"intro.html>`_: a lengthy tutorial for C programmers."
msgstr ""
"`Writing Programs with NCURSES <https://invisible-island.net/ncurses/ncurses-"
"intro.html>`_: a longy tutorial for C programmers."

#: ../../howto/curses.rst:541
msgid "`The ncurses man page <https://linux.die.net/man/3/ncurses>`_"
msgstr "`La página man de ncurses <https://linux.die.net/man/3/ncurses>`_"

#: ../../howto/curses.rst:542
msgid ""
"`The ncurses FAQ <https://invisible-island.net/ncurses/ncurses.faq.html>`_"
msgstr ""
"Las ncurses FAQ <https://invisible-island.net/ncurses/ncurses.faq.html>`_"

#: ../../howto/curses.rst:543
msgid ""
"`\"Use curses... don't swear\" <https://www.youtube.com/watch?"
"v=eN1eZtjLEnU>`_: video of a PyCon 2013 talk on controlling terminals using "
"curses or Urwid."
msgstr ""
"'\"Use curses -maldiciones-... no jures\"<https://www.youtube.com/watch?"
"v=eN1eZtjLEnU>`_: vídeo de una charla de PyCon 2013 sobre el control de "
"terminales usando curses o Urwid."

#: ../../howto/curses.rst:545
msgid ""
"`\"Console Applications with Urwid\" <https://pyvideo.org/video/1568/console-"
"applications-with-urwid>`_: video of a PyCon CA 2012 talk demonstrating some "
"applications written using Urwid."
msgstr ""
"`\"Console Applications with Urwid\" <https://pyvideo.org/video/1568/console-"
"applications-with-urwid>`_: vídeo de una charla de PyCon CA 2012 demostrando "
"algunas aplicaciones escritas usando Urwid."
