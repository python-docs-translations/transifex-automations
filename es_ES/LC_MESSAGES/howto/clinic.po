# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# eulalio barbero espinosa <eulalio@disroot.org>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-21 22:53+0000\n"
"PO-Revision-Date: 2022-11-05 17:21+0000\n"
"Last-Translator: eulalio barbero espinosa <eulalio@disroot.org>, 2024\n"
"Language-Team: Spanish (Spain) (https://app.transifex.com/python-doc/"
"teams/5390/es_ES/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es_ES\n"
"Plural-Forms: nplurals=3; plural=n == 1 ? 0 : n != 0 && n % 1000000 == 0 ? "
"1 : 2;\n"

#: ../../howto/clinic.rst:7
msgid "Argument Clinic How-To"
msgstr "Clínica de la argumentación"

#: ../../howto/clinic.rst:0
msgid "author"
msgstr "autor"

#: ../../howto/clinic.rst:9
msgid "Larry Hastings"
msgstr "Larry Hastings"

#: ../../howto/clinic.rstNone
msgid "Abstract"
msgstr "Resumen"

#: ../../howto/clinic.rst:14
msgid ""
"Argument Clinic is a preprocessor for CPython C files. Its purpose is to "
"automate all the boilerplate involved with writing argument parsing code for "
"\"builtins\". This document shows you how to convert your first C function "
"to work with Argument Clinic, and then introduces some advanced topics on "
"Argument Clinic usage."
msgstr ""
"Argument Clinic es un preprocesador para archivos C de CPython. Su propósito "
"es automatizar todo el trabajo de escribir código de análisis de argumentos "
"para \"builtins\". Este documento le muestra cómo convertir su primera "
"función C para trabajar con Argument Clinic, y luego introduce algunos temas "
"avanzados sobre el uso de Argument Clinic."

#: ../../howto/clinic.rst:21
msgid ""
"Currently Argument Clinic is considered internal-only for CPython.  Its use "
"is not supported for files outside CPython, and no guarantees are made "
"regarding backwards compatibility for future versions.  In other words: if "
"you maintain an external C extension for CPython, you're welcome to "
"experiment with Argument Clinic in your own code.  But the version of "
"Argument Clinic that ships with the next version of CPython *could* be "
"totally incompatible and break all your code."
msgstr ""
"Actualmente Argument Clinic se considera sólo interno para CPython.  Su uso "
"no está soportado para archivos fuera de CPython, y no se garantiza la "
"compatibilidad con versiones futuras.  En otras palabras: si mantienes una "
"extensión C externa para CPython, eres bienvenido a experimentar con "
"Argument Clinic en tu propio código.  Pero la versión de Argument Clinic que "
"venga con la próxima versión de CPython *podría* ser totalmente incompatible "
"y romper todo tu código."

#: ../../howto/clinic.rst:31
msgid "The Goals Of Argument Clinic"
msgstr "Los objetivos de la clínica de la argumentación"

#: ../../howto/clinic.rst:33
msgid ""
"Argument Clinic's primary goal is to take over responsibility for all "
"argument parsing code inside CPython.  This means that, when you convert a "
"function to work with Argument Clinic, that function should no longer do any "
"of its own argument parsing—the code generated by Argument Clinic should be "
"a \"black box\" to you, where CPython calls in at the top, and your code "
"gets called at the bottom, with ``PyObject *args`` (and maybe ``PyObject "
"*kwargs``) magically converted into the C variables and types you need."
msgstr ""
"El objetivo principal de Argument Clinic es asumir la responsabilidad de "
"todo el código de análisis de argumentos dentro de CPython.  Esto significa "
"que, cuando se convierte una función para trabajar con Argument Clinic, esa "
"función ya no debe hacer nada de su propio análisis de argumentos - el "
"código generado por Argument Clinic debe ser una \"caja negra\" para usted, "
"donde CPython llama en la parte superior, y su código es llamado en la parte "
"inferior, con ``PyObject *args`` (y tal vez ``PyObject *kwargs``) convertido "
"mágicamente en las variables C y los tipos que necesita."

#: ../../howto/clinic.rst:43
msgid ""
"In order for Argument Clinic to accomplish its primary goal, it must be easy "
"to use.  Currently, working with CPython's argument parsing library is a "
"chore, requiring maintaining redundant information in a surprising number of "
"places. When you use Argument Clinic, you don't have to repeat yourself."
msgstr ""
"Para que Argument Clinic cumpla su objetivo principal, debe ser fácil de "
"usar.  Actualmente, trabajar con la biblioteca de análisis sintáctico de "
"argumentos de CPython es una tarea, que requiere mantener información "
"redundante en un sorprendente número de lugares. Cuando usas Argument "
"Clinic, no tienes que repetirte."

#: ../../howto/clinic.rst:49
msgid ""
"Obviously, no one would want to use Argument Clinic unless it's solving "
"their problem—and without creating new problems of its own. So it's "
"paramount that Argument Clinic generate correct code. It'd be nice if the "
"code was faster, too, but at the very least it should not introduce a major "
"speed regression.  (Eventually Argument Clinic *should* make a major speedup "
"possible—we could rewrite its code generator to produce tailor-made argument "
"parsing code, rather than calling the general-purpose CPython argument "
"parsing library.  That would make for the fastest argument parsing possible!)"
msgstr ""
"Obviamente, nadie querría usar Argument Clinic a menos que resuelva su "
"problema, y sin crear nuevos problemas propios. Así que es primordial que "
"Argument Clinic genere código correcto. También estaría bien que el código "
"fuera más rápido, pero como mínimo no debería introducir una regresión "
"importante en la velocidad.  (Eventualmente Argument Clinic *debería* hacer "
"posible un aumento de velocidad mayor -podríamos reescribir su generador de "
"código para producir código de análisis de argumentos a medida, en lugar de "
"llamar a la biblioteca de análisis de argumentos CPython de propósito "
"general.  Eso haría el análisis de argumentos más rápido posible)."

#: ../../howto/clinic.rst:61
msgid ""
"Additionally, Argument Clinic must be flexible enough to work with any "
"approach to argument parsing.  Python has some functions with some very "
"strange parsing behaviors; Argument Clinic's goal is to support all of them."
msgstr ""
"Además, Argument Clinic debe ser lo suficientemente flexible como para "
"trabajar con cualquier enfoque de análisis sintáctico de argumentos.  Python "
"tiene algunas funciones con comportamientos de análisis muy extraños; el "
"objetivo de Argument Clinic es soportarlos todos."

#: ../../howto/clinic.rst:66
msgid ""
"Finally, the original motivation for Argument Clinic was to provide "
"introspection \"signatures\" for CPython builtins. It used to be, the "
"introspection query functions would throw an exception if you passed in a "
"builtin.  With Argument Clinic, that's a thing of the past!"
msgstr ""
"Por último, la motivación original de Argument Clinic era proporcionar "
"\"firmas\" de introspección para los builtins de CPython. Antes, las "
"funciones de consulta de introspección lanzaban una excepción si pasabas un "
"builtin.  Con Argument Clinic, ¡eso es cosa del pasado!"

#: ../../howto/clinic.rst:72
msgid ""
"One idea you should keep in mind, as you work with Argument Clinic: the more "
"information you give it, the better job it'll be able to do. Argument Clinic "
"is admittedly relatively simple right now.  But as it evolves it will get "
"more sophisticated, and it should be able to do many interesting and smart "
"things with all the information you give it."
msgstr ""
"Una idea que debes tener en cuenta cuando trabajes con Argument Clinic: "
"cuanta más información le des, mejor trabajo podrá hacer. En estos momentos, "
"Argument Clinic es relativamente sencillo.  Pero a medida que evolucione se "
"volverá más sofisticado, y debería ser capaz de hacer muchas cosas "
"interesantes e inteligentes con toda la información que le des."

#: ../../howto/clinic.rst:82
msgid "Basic Concepts And Usage"
msgstr "Conceptos básicos y uso"

#: ../../howto/clinic.rst:84
msgid ""
"Argument Clinic ships with CPython; you'll find it in ``Tools/clinic/clinic."
"py``. If you run that script, specifying a C file as an argument:"
msgstr ""
"Argument Clinic viene con CPython; lo encontrarás en ``Tools/clinic/clinic."
"py``. Si ejecutas ese script, especificando un archivo C como argumento:"

#: ../../howto/clinic.rst:91
msgid ""
"Argument Clinic will scan over the file looking for lines that look exactly "
"like this:"
msgstr ""
"Argument Clinic escaneará el archivo en busca de líneas exactamente iguales "
"a ésta:"

#: ../../howto/clinic.rst:98
msgid ""
"When it finds one, it reads everything up to a line that looks exactly like "
"this:"
msgstr ""
"Cuando encuentra una, lee todo hasta una línea exactamente igual a ésta:"

#: ../../howto/clinic.rst:105
msgid ""
"Everything in between these two lines is input for Argument Clinic. All of "
"these lines, including the beginning and ending comment lines, are "
"collectively called an Argument Clinic \"block\"."
msgstr ""
"Todo lo que hay entre estas dos líneas es entrada para Argument Clinic. "
"Todas estas líneas, incluidas las líneas de comentario inicial y final, se "
"denominan colectivamente \"bloque\" de Argument Clinic."

#: ../../howto/clinic.rst:109
msgid ""
"When Argument Clinic parses one of these blocks, it generates output.  This "
"output is rewritten into the C file immediately after the block, followed by "
"a comment containing a checksum. The Argument Clinic block now looks like "
"this:"
msgstr ""
"Cuando Argument Clinic analiza uno de estos bloques, genera una salida.  "
"Esta salida se reescribe en el archivo C inmediatamente después del bloque, "
"seguido de un comentario que contiene una suma de comprobación. El bloque "
"Argument Clinic tiene ahora este aspecto:"

#: ../../howto/clinic.rst:122
msgid ""
"If you run Argument Clinic on the same file a second time, Argument Clinic "
"will discard the old output and write out the new output with a fresh "
"checksum line.  However, if the input hasn't changed, the output won't "
"change either."
msgstr ""
"Si ejecuta Argument Clinic en el mismo archivo por segunda vez, Argument "
"Clinic descartará la salida anterior y escribirá la nueva salida con una "
"nueva línea de suma de comprobación.  Sin embargo, si la entrada no ha "
"cambiado, la salida tampoco lo hará."

#: ../../howto/clinic.rst:126
msgid ""
"You should never modify the output portion of an Argument Clinic block.  "
"Instead, change the input until it produces the output you want.  (That's "
"the purpose of the checksum—to detect if someone changed the output, as "
"these edits would be lost the next time Argument Clinic writes out fresh "
"output.)"
msgstr ""
"Nunca debe modificar la parte de salida de un bloque Argument Clinic.  En su "
"lugar, cambie la entrada hasta que produzca la salida que desea.  (Ese es el "
"propósito de la suma de comprobación: detectar si alguien cambió la salida, "
"ya que estas ediciones se perderían la próxima vez que Argument Clinic "
"escriba una salida nueva)."

#: ../../howto/clinic.rst:131
msgid ""
"For the sake of clarity, here's the terminology we'll use with Argument "
"Clinic:"
msgstr ""
"En aras de la claridad, ésta es la terminología que utilizaremos con "
"Argument Clinic:"

#: ../../howto/clinic.rst:133
msgid ""
"The first line of the comment (``/*[clinic input]``) is the *start line*."
msgstr ""
"La primera línea del comentario (``/*[clinic input]``) es la *línea de "
"inicio*."

#: ../../howto/clinic.rst:134
msgid ""
"The last line of the initial comment (``[clinic start generated code]*/``) "
"is the *end line*."
msgstr ""
"La última línea del comentario inicial (``[clinic start generated code]*/``) "
"es la *línea final*."

#: ../../howto/clinic.rst:135
msgid ""
"The last line (``/*[clinic end generated code: checksum=...]*/``) is the "
"*checksum line*."
msgstr ""
"La última línea (``/*[clinic end generated code: checksum=...]*/``) es la "
"*línea de comprobación*."

#: ../../howto/clinic.rst:136
msgid "In between the start line and the end line is the *input*."
msgstr "Entre la línea de inicio y la línea final se encuentra la *entrada*."

#: ../../howto/clinic.rst:137
msgid "In between the end line and the checksum line is the *output*."
msgstr ""
"Entre la línea final y la línea de suma de comprobación está la *salida*."

#: ../../howto/clinic.rst:138
msgid ""
"All the text collectively, from the start line to the checksum line "
"inclusively, is the *block*.  (A block that hasn't been successfully "
"processed by Argument Clinic yet doesn't have output or a checksum line, but "
"it's still considered a block.)"
msgstr ""
"Todo el texto en conjunto, desde la línea de inicio hasta la línea de suma "
"de comprobación inclusive, es el *bloque*.  (Un bloque que aún no ha sido "
"procesado con éxito por la Clínica de Argumentos no tiene salida ni línea de "
"suma de comprobación, pero sigue considerándose un bloque)."

#: ../../howto/clinic.rst:145
msgid "Converting Your First Function"
msgstr "Conversión de la primera función"

#: ../../howto/clinic.rst:147
msgid ""
"The best way to get a sense of how Argument Clinic works is to convert a "
"function to work with it.  Here, then, are the bare minimum steps you'd need "
"to follow to convert a function to work with Argument Clinic.  Note that for "
"code you plan to check in to CPython, you really should take the conversion "
"farther, using some of the advanced concepts you'll see later on in the "
"document (like \"return converters\" and \"self converters\"). But we'll "
"keep it simple for this walkthrough so you can learn."
msgstr ""
"La mejor manera de hacerse una idea de cómo funciona Argument Clinic es "
"convertir una función para que funcione con ella.  Aquí, entonces, están los "
"pasos mínimos que necesitas seguir para convertir una función para trabajar "
"con Argument Clinic.  Ten en cuenta que para el código que planeas registrar "
"en CPython, realmente deberías llevar la conversión más lejos, usando "
"algunos de los conceptos avanzados que verás más adelante en el documento "
"(como \"convertidores de retorno\" y \"autoconvertidores\"). Pero lo "
"mantendremos simple para que puedas aprender."

#: ../../howto/clinic.rst:156
msgid "Let's dive in!"
msgstr "Sumerjámonos."

#: ../../howto/clinic.rst:158
msgid ""
"Make sure you're working with a freshly updated checkout of the CPython "
"trunk."
msgstr ""
"Asegúrate de que estás trabajando con una versión actualizada del trunk de "
"CPython."

#: ../../howto/clinic.rst:161
msgid ""
"Find a Python builtin that calls either :c:func:`PyArg_ParseTuple` or :c:"
"func:`PyArg_ParseTupleAndKeywords`, and hasn't been converted to work with "
"Argument Clinic yet. For my example I'm using ``_pickle.Pickler.dump()``."
msgstr ""
"Encuentra un builtin de Python que llame a :c:func:`PyArg_ParseTuple` o :c:"
"func:`PyArg_ParseTupleAndKeywords`, y que aún no haya sido convertido para "
"trabajar con Argument Clinic. Para mi ejemplo estoy usando ``_pickle.Pickler."
"dump()``."

#: ../../howto/clinic.rst:166
msgid ""
"If the call to the ``PyArg_Parse`` function uses any of the following format "
"units:"
msgstr ""
"Si la llamada a la función ``PyArg_Parse`` utiliza alguna de las siguientes "
"unidades de formato:"

#: ../../howto/clinic.rst:178
msgid ""
"or if it has multiple calls to :c:func:`PyArg_ParseTuple`, you should choose "
"a different function.  Argument Clinic *does* support all of these "
"scenarios.  But these are advanced topics—let's do something simpler for "
"your first function."
msgstr ""
"o si tiene múltiples llamadas a :c:func:`PyArg_ParseTuple`, debe elegir una "
"función diferente.  Argument Clinic *soporta* todos estos escenarios.  Pero "
"estos son temas avanzados, hagamos algo más simple para su primera función."

#: ../../howto/clinic.rst:183
msgid ""
"Also, if the function has multiple calls to :c:func:`PyArg_ParseTuple` or :c:"
"func:`PyArg_ParseTupleAndKeywords` where it supports different types for the "
"same argument, or if the function uses something besides PyArg_Parse "
"functions to parse its arguments, it probably isn't suitable for conversion "
"to Argument Clinic.  Argument Clinic doesn't support generic functions or "
"polymorphic parameters."
msgstr ""
"Además, si la función tiene múltiples llamadas a :c:func:`PyArg_ParseTuple` "
"o :c:func:`PyArg_ParseTupleAndKeywords` donde admite diferentes tipos para "
"el mismo argumento, o si la función utiliza algo más que las funciones "
"PyArg_Parse para analizar sus argumentos, probablemente no sea adecuada para "
"la conversión a Argument Clinic.  Argument Clinic no soporta funciones "
"genéricas o parámetros polimórficos."

#: ../../howto/clinic.rst:190
msgid "Add the following boilerplate above the function, creating our block::"
msgstr ""
"Añade el siguiente boilerplate encima de la función, creando nuestro bloque::"

#: ../../howto/clinic.rst:195
msgid ""
"Cut the docstring and paste it in between the ``[clinic]`` lines, removing "
"all the junk that makes it a properly quoted C string. When you're done you "
"should have just the text, based at the left margin, with no line wider than "
"80 characters. (Argument Clinic will preserve indents inside the docstring.)"
msgstr ""
"Corta el docstring y pégalo entre las líneas de ``[clinic]``, eliminando "
"toda la basura que lo convierte en una cadena C correctamente "
"entrecomillada. Cuando hayas terminado deberías tener sólo el texto, basado "
"en el margen izquierdo, sin ninguna línea de más de 80 caracteres. (Argument "
"Clinic preservará las sangrías dentro del docstring)."

#: ../../howto/clinic.rst:201
msgid ""
"If the old docstring had a first line that looked like a function signature, "
"throw that line away.  (The docstring doesn't need it anymore—when you use "
"``help()`` on your builtin in the future, the first line will be built "
"automatically based on the function's signature.)"
msgstr ""
"Si el antiguo docstring tenía una primera línea que parecía la firma de una "
"función, elimínela.  (El docstring ya no lo necesita: cuando en el futuro "
"utilice ``help()`` en su builtin, la primera línea se construirá "
"automáticamente basándose en la firma de la función)."

#: ../../howto/clinic.rst:207 ../../howto/clinic.rst:228
#: ../../howto/clinic.rst:252 ../../howto/clinic.rst:310
#: ../../howto/clinic.rst:350 ../../howto/clinic.rst:377
#: ../../howto/clinic.rst:483 ../../howto/clinic.rst:535
msgid "Sample::"
msgstr "Muestra::"

#: ../../howto/clinic.rst:213
msgid ""
"If your docstring doesn't have a \"summary\" line, Argument Clinic will "
"complain.  So let's make sure it has one.  The \"summary\" line should be a "
"paragraph consisting of a single 80-column line at the beginning of the "
"docstring."
msgstr ""
"Si tu docstring no tiene una línea de \"resumen\", Argument Clinic se "
"quejará.  Así que asegurémonos de que tiene una.  La línea \"resumen\" debe "
"ser un párrafo consistente en una única línea de 80 columnas al principio "
"del docstring."

#: ../../howto/clinic.rst:218
msgid ""
"(Our example docstring consists solely of a summary line, so the sample code "
"doesn't have to change for this step.)"
msgstr ""
"(Nuestro docstring de ejemplo consiste únicamente en una línea de resumen, "
"por lo que el código de ejemplo no tiene que cambiar para este paso)."

#: ../../howto/clinic.rst:221
msgid ""
"Above the docstring, enter the name of the function, followed by a blank "
"line.  This should be the Python name of the function, and should be the "
"full dotted path to the function—it should start with the name of the "
"module, include any sub-modules, and if the function is a method on a class "
"it should include the class name too."
msgstr ""
"Encima del docstring, introduzca el nombre de la función, seguido de una "
"línea en blanco.  Este debe ser el nombre Python de la función, y debe ser "
"la ruta punteada completa a la función - debe comenzar con el nombre del "
"módulo, incluir cualquier sub-módulo, y si la función es un método en una "
"clase debe incluir el nombre de la clase también."

#: ../../howto/clinic.rst:236
msgid ""
"If this is the first time that module or class has been used with Argument "
"Clinic in this C file, you must declare the module and/or class.  Proper "
"Argument Clinic hygiene prefers declaring these in a separate block "
"somewhere near the top of the C file, in the same way that include files and "
"statics go at the top.  (In our sample code we'll just show the two blocks "
"next to each other.)"
msgstr ""
"Si es la primera vez que ese módulo o clase se ha usado con Argument Clinic "
"en este fichero C, debes declarar el módulo y/o la clase.  La correcta "
"higiene de Argument Clinic prefiere declararlos en un bloque separado en "
"algún lugar cerca de la parte superior del archivo C, de la misma manera que "
"los archivos de inclusión y los estáticos van al principio. (En nuestro "
"código de ejemplo sólo mostraremos los dos bloques uno al lado del otro)."

#: ../../howto/clinic.rst:244
msgid ""
"The name of the class and module should be the same as the one seen by "
"Python.  Check the name defined in the :c:type:`PyModuleDef` or :c:type:"
"`PyTypeObject` as appropriate."
msgstr ""
"El nombre de la clase y del módulo debe ser el mismo que el visto por "
"Python.  Compruebe el nombre definido en :c:type:`PyModuleDef` o :c:type:"
"`PyTypeObject` según corresponda."

#: ../../howto/clinic.rst:248
msgid ""
"When you declare a class, you must also specify two aspects of its type in "
"C: the type declaration you'd use for a pointer to an instance of this "
"class, and a pointer to the :c:type:`PyTypeObject` for this class."
msgstr ""
"Cuando declaras una clase, también debes especificar dos aspectos de su tipo "
"en C: la declaración de tipo que utilizarías para un puntero a una instancia "
"de esta clase, y un puntero a la :c:type:`PyTypeObject` para esta clase."

#: ../../howto/clinic.rst:268
msgid ""
"Declare each of the parameters to the function.  Each parameter should get "
"its own line.  All the parameter lines should be indented from the function "
"name and the docstring."
msgstr ""
"Declare cada uno de los parámetros de la función.  Cada parámetro debe tener "
"su propia línea.  Todas las líneas de parámetros deben estar sangradas desde "
"el nombre de la función y el docstring."

#: ../../howto/clinic.rst:272
msgid "The general form of these parameter lines is as follows:"
msgstr "La forma general de estas líneas de parámetros es la siguiente:"

#: ../../howto/clinic.rst:278
msgid "If the parameter has a default value, add that after the converter:"
msgstr ""
"Si el parámetro tiene un valor por defecto, añádalo después del conversor:"

#: ../../howto/clinic.rst:285
msgid ""
"Argument Clinic's support for \"default values\" is quite sophisticated; "
"please see :ref:`the section below on default values <default_values>` for "
"more information."
msgstr ""
"El soporte de Argument Clinic para \"valores por defecto\" es bastante "
"sofisticado; consulte :ref:`la sección siguiente sobre valores por defecto "
"<default_values>` para obtener más información."

#: ../../howto/clinic.rst:289
msgid "Add a blank line below the parameters."
msgstr "Añada una línea en blanco debajo de los parámetros."

#: ../../howto/clinic.rst:291
msgid ""
"What's a \"converter\"?  It establishes both the type of the variable used "
"in C, and the method to convert the Python value into a C value at runtime. "
"For now you're going to use what's called a \"legacy converter\"—a "
"convenience syntax intended to make porting old code into Argument Clinic "
"easier."
msgstr ""
"¿Qué es un \"convertidor\"?  Establece tanto el tipo de la variable usada en "
"C, como el método para convertir el valor Python en un valor C en tiempo de "
"ejecución. Por ahora vas a utilizar lo que se llama un \"convertidor de "
"legado\" - una sintaxis de conveniencia destinada a facilitar la "
"portabilidad de código antiguo a Argument Clinic."

#: ../../howto/clinic.rst:298
msgid ""
"For each parameter, copy the \"format unit\" for that parameter from the "
"``PyArg_Parse()`` format argument and specify *that* as its converter, as a "
"quoted string.  (\"format unit\" is the formal name for the one-to-three "
"character substring of the ``format`` parameter that tells the argument "
"parsing function what the type of the variable is and how to convert it.  "
"For more on format units please see :ref:`arg-parsing`.)"
msgstr ""
"Para cada parámetro, copie la \"unidad de formato\" para ese parámetro desde "
"el argumento de formato ``PyArg_Parse()`` y especifique *eso* como su "
"convertidor, como una cadena entre comillas.  (\"unidad de formato\" es el "
"nombre formal de la subcadena de uno a tres caracteres del parámetro "
"``format`` que indica a la función de análisis sintáctico de argumentos cuál "
"es el tipo de la variable y cómo convertirla.  Para más información sobre "
"las unidades de formato, consulte :ref:`arg-parsing`.)"

#: ../../howto/clinic.rst:307
msgid ""
"For multicharacter format units like ``z#``, use the entire two-or-three "
"character string."
msgstr ""
"Para unidades de formato multicarácter como ``z#``, utilice la cadena "
"completa de dos o tres caracteres."

#: ../../howto/clinic.rst:325
msgid ""
"If your function has ``|`` in the format string, meaning some parameters "
"have default values, you can ignore it.  Argument Clinic infers which "
"parameters are optional based on whether or not they have default values."
msgstr ""
"Si su función tiene ``|`` en la cadena de formato, lo que significa que "
"algunos parámetros tienen valores por defecto, puede ignorarlo.  Argument "
"Clinic infiere qué parámetros son opcionales en función de si tienen o no "
"valores por defecto."

#: ../../howto/clinic.rst:330
msgid ""
"If your function has ``$`` in the format string, meaning it takes keyword-"
"only arguments, specify ``*`` on a line by itself before the first keyword-"
"only argument, indented the same as the parameter lines."
msgstr ""
"Si su función tiene ``$`` en la cadena de formato, lo que significa que toma "
"argumentos de sólo palabra clave, especifique ``*`` en una línea por sí "
"misma antes del primer argumento de sólo palabra clave, con la misma sangría "
"que las líneas de parámetros."

#: ../../howto/clinic.rst:335
msgid "(``_pickle.Pickler.dump`` has neither, so our sample is unchanged.)"
msgstr ""
"(``_pickle.Pickler.dump`` no tiene ninguno de los dos, por lo que nuestra "
"muestra no cambia)."

#: ../../howto/clinic.rst:338
msgid ""
"If the existing C function calls :c:func:`PyArg_ParseTuple` (as opposed to :"
"c:func:`PyArg_ParseTupleAndKeywords`), then all its arguments are positional-"
"only."
msgstr ""
"Si la función C existente llama a :c:func:`PyArg_ParseTuple` (en lugar de :c:"
"func:`PyArg_ParseTupleAndKeywords`), entonces todos sus argumentos son sólo "
"posicionales."

#: ../../howto/clinic.rst:342
msgid ""
"To mark all parameters as positional-only in Argument Clinic, add a ``/`` on "
"a line by itself after the last parameter, indented the same as the "
"parameter lines."
msgstr ""
"Para marcar todos los parámetros como sólo posicionales en Argument Clinic, "
"añada un ``/`` en una línea aparte después del último parámetro, con la "
"misma sangría que las líneas de los parámetros."

#: ../../howto/clinic.rst:346
msgid ""
"Currently this is all-or-nothing; either all parameters are positional-only, "
"or none of them are.  (In the future Argument Clinic may relax this "
"restriction.)"
msgstr ""
"Actualmente esto es todo o nada; o todos los parámetros son sólo "
"posicionales, o ninguno de ellos lo es.  (En el futuro Argument Clinic "
"podría relajar esta restricción)."

#: ../../howto/clinic.rst:366
msgid ""
"It's helpful to write a per-parameter docstring for each parameter. But per-"
"parameter docstrings are optional; you can skip this step if you prefer."
msgstr ""
"Es útil escribir una documentación por parámetro para cada parámetro. Pero "
"los docstrings por parámetro son opcionales; puedes saltarte este paso si lo "
"prefieres."

#: ../../howto/clinic.rst:370
msgid ""
"Here's how to add a per-parameter docstring.  The first line of the per-"
"parameter docstring must be indented further than the parameter definition.  "
"The left margin of this first line establishes the left margin for the whole "
"per-parameter docstring; all the text you write will be outdented by this "
"amount.  You can write as much text as you like, across multiple lines if "
"you wish."
msgstr ""
"A continuación se explica cómo añadir un docstring por parámetro.  La "
"primera línea de la docstring por parámetro debe tener una sangría mayor que "
"la definición del parámetro.  El margen izquierdo de esta primera línea "
"establece el margen izquierdo para toda la docstring por parámetro; todo el "
"texto que escriba se sangrará en esta cantidad.  Puede escribir todo el "
"texto que desee, en varias líneas si lo desea."

#: ../../howto/clinic.rst:394
msgid ""
"Save and close the file, then run ``Tools/clinic/clinic.py`` on it.  With "
"luck everything worked---your block now has output, and a ``.c.h`` file has "
"been generated! Reopen the file in your text editor to see::"
msgstr ""
"Guarde y cierre el archivo y ejecute ``Tools/clinic/clinic.py``.  Con "
"suerte, todo ha funcionado: ¡tu bloque ya tiene salida y se ha generado un "
"archivo ``.c.h``! Vuelva a abrir el archivo en su editor de texto para ver::"

#: ../../howto/clinic.rst:413
msgid ""
"Obviously, if Argument Clinic didn't produce any output, it's because it "
"found an error in your input.  Keep fixing your errors and retrying until "
"Argument Clinic processes your file without complaint."
msgstr ""
"Obviamente, si Argument Clinic no produjo ninguna salida, es porque encontró "
"un error en su entrada.  Siga corrigiendo sus errores y reintentando hasta "
"que Argument Clinic procese su archivo sin quejarse."

#: ../../howto/clinic.rst:417
msgid ""
"For readability, most of the glue code has been generated to a ``.c.h`` "
"file.  You'll need to include that in your original ``.c`` file, typically "
"right after the clinic module block::"
msgstr ""
"Para facilitar la lectura, la mayor parte del código de cola se ha generado "
"en un archivo ``.c.h``.  Tendrás que incluirlo en tu archivo original ``."
"c``, normalmente justo después del bloque del módulo clínico::"

#: ../../howto/clinic.rst:423
msgid ""
"Double-check that the argument-parsing code Argument Clinic generated looks "
"basically the same as the existing code."
msgstr ""
"Compruebe que el código de análisis de argumentos generado por Argument "
"Clinic es básicamente igual al código existente."

#: ../../howto/clinic.rst:426
msgid ""
"First, ensure both places use the same argument-parsing function. The "
"existing code must call either :c:func:`PyArg_ParseTuple` or :c:func:"
"`PyArg_ParseTupleAndKeywords`; ensure that the code generated by Argument "
"Clinic calls the *exact* same function."
msgstr ""
"En primer lugar, asegúrese de que ambos sitios utilizan la misma función de "
"análisis de argumentos. El código existente debe llamar a :c:func:"
"`PyArg_ParseTuple` o a :c:func:`PyArg_ParseTupleAndKeywords`; asegúrese de "
"que el código generado por Argument Clinic llama *exactamente* a la misma "
"función."

#: ../../howto/clinic.rst:432
msgid ""
"Second, the format string passed in to :c:func:`PyArg_ParseTuple` or :c:func:"
"`PyArg_ParseTupleAndKeywords` should be *exactly* the same as the hand-"
"written one in the existing function, up to the colon or semi-colon."
msgstr ""
"En segundo lugar, la cadena de formato pasada a :c:func:`PyArg_ParseTuple` "
"o :c:func:`PyArg_ParseTupleAndKeywords` debe ser *exactamente* la misma que "
"la escrita a mano en la función existente, hasta los dos puntos o el punto y "
"coma."

#: ../../howto/clinic.rst:437
msgid ""
"(Argument Clinic always generates its format strings with a ``:`` followed "
"by the name of the function.  If the existing code's format string ends with "
"``;``, to provide usage help, this change is harmless—don't worry about it.)"
msgstr ""
"(Argument Clinic siempre genera sus cadenas de formato con un ``:`` seguido "
"del nombre de la función.  Si la cadena de formato del código existente "
"termina con ``;``, para proporcionar ayuda de uso, este cambio es inofensivo-"
"no te preocupes)."

#: ../../howto/clinic.rst:442
msgid ""
"Third, for parameters whose format units require two arguments (like a "
"length variable, or an encoding string, or a pointer to a conversion "
"function), ensure that the second argument is *exactly* the same between the "
"two invocations."
msgstr ""
"En tercer lugar, para los parámetros cuyas unidades de formato requieren dos "
"argumentos (como una variable de longitud, o una cadena de codificación, o "
"un puntero a una función de conversión), asegúrese de que el segundo "
"argumento es *exactamente* el mismo entre las dos invocaciones."

#: ../../howto/clinic.rst:447
msgid ""
"Fourth, inside the output portion of the block you'll find a preprocessor "
"macro defining the appropriate static :c:type:`PyMethodDef` structure for "
"this builtin::"
msgstr ""
"En cuarto lugar, dentro de la parte de salida del bloque encontrarás una "
"macro de preprocesador que define la estructura estática :c:type:"
"`PyMethodDef` adecuada para este builtin::"

#: ../../howto/clinic.rst:454
msgid ""
"This static structure should be *exactly* the same as the existing static :c:"
"type:`PyMethodDef` structure for this builtin."
msgstr ""
"Esta estructura estática debe ser *exactamente* la misma que la estructura "
"estática :c:type:`PyMethodDef` existente para este builtin."

#: ../../howto/clinic.rst:457
msgid ""
"If any of these items differ in *any way*, adjust your Argument Clinic "
"function specification and rerun ``Tools/clinic/clinic.py`` until they *are* "
"the same."
msgstr ""
"Si alguno de estos elementos difiere en *algo*, ajuste la especificación de "
"la función Argument Clinic y vuelva a ejecutar ``Tools/clinic/clinic.py`` "
"hasta que *coincidan*."

#: ../../howto/clinic.rst:462
msgid ""
"Notice that the last line of its output is the declaration of your \"impl\" "
"function.  This is where the builtin's implementation goes. Delete the "
"existing prototype of the function you're modifying, but leave the opening "
"curly brace.  Now delete its argument parsing code and the declarations of "
"all the variables it dumps the arguments into. Notice how the Python "
"arguments are now arguments to this impl function; if the implementation "
"used different names for these variables, fix it."
msgstr ""
"Observe que la última línea de su salida es la declaración de su función "
"\"impl\".  Aquí es donde va la implementación del builtin. Borra el "
"prototipo existente de la función que estás modificando, pero deja la llave "
"de apertura.  Ahora borra su código de análisis de argumentos y las "
"declaraciones de todas las variables en las que vuelca los argumentos. "
"Observa cómo los argumentos de Python son ahora argumentos de esta función "
"impl; si la implementación usaba nombres diferentes para estas variables, "
"arréglalo."

#: ../../howto/clinic.rst:470
msgid ""
"Let's reiterate, just because it's kind of weird.  Your code should now look "
"like this::"
msgstr ""
"Vamos a reiterar, sólo porque es un poco raro.  Su código ahora debe tener "
"este aspecto::"

#: ../../howto/clinic.rst:479
msgid ""
"Argument Clinic generated the checksum line and the function prototype just "
"above it.  You should write the opening (and closing) curly braces for the "
"function, and the implementation inside."
msgstr ""
"Argument Clinic generó la línea checksum y el prototipo de la función justo "
"encima.  Debe escribir las llaves de apertura (y cierre) para la función, y "
"la implementación dentro."

#: ../../howto/clinic.rst:524
msgid ""
"Remember the macro with the :c:type:`PyMethodDef` structure for this "
"function?  Find the existing :c:type:`PyMethodDef` structure for this "
"function and replace it with a reference to the macro.  (If the builtin is "
"at module scope, this will probably be very near the end of the file; if the "
"builtin is a class method, this will probably be below but relatively near "
"to the implementation.)"
msgstr ""
"¿Recuerdas la macro con la estructura :c:type:`PyMethodDef` para esta "
"función?  Busque la estructura :c:type:`PyMethodDef` existente para esta "
"función y sustitúyala por una referencia a la macro.  (Si el builtin está en "
"el ámbito del módulo, esto será probablemente muy cerca del final del "
"archivo; si el builtin es un método de clase, esto será probablemente por "
"debajo pero relativamente cerca de la implementación)."

#: ../../howto/clinic.rst:531
msgid ""
"Note that the body of the macro contains a trailing comma.  So when you "
"replace the existing static :c:type:`PyMethodDef` structure with the macro, "
"*don't* add a comma to the end."
msgstr ""
"Tenga en cuenta que el cuerpo de la macro contiene una coma al final.  Por "
"lo tanto, cuando sustituya la estructura estática :c:type:`PyMethodDef` "
"existente por la macro, *no* añada una coma al final."

#: ../../howto/clinic.rst:544
msgid ""
"Compile, then run the relevant portions of the regression-test suite. This "
"change should not introduce any new compile-time warnings or errors, and "
"there should be no externally visible change to Python's behavior."
msgstr ""
"Compila y ejecuta las partes relevantes del conjunto de pruebas de "
"regresión. Este cambio no debería introducir nuevas advertencias o errores "
"en tiempo de compilación, y no debería haber ningún cambio visible "
"externamente en el comportamiento de Python."

#: ../../howto/clinic.rst:548
msgid ""
"Well, except for one difference: ``inspect.signature()`` run on your "
"function should now provide a valid signature!"
msgstr ""
"Bueno, excepto por una diferencia: ¡la ejecución de ``inspect.signature()`` "
"sobre tu función debería proporcionar ahora una firma válida!"

#: ../../howto/clinic.rst:551
msgid ""
"Congratulations, you've ported your first function to work with Argument "
"Clinic!"
msgstr ""
"Enhorabuena, has adaptado tu primera función para que funcione con Argument "
"Clinic."

#: ../../howto/clinic.rst:554
msgid "Advanced Topics"
msgstr "Temas avanzados"

#: ../../howto/clinic.rst:556
msgid ""
"Now that you've had some experience working with Argument Clinic, it's time "
"for some advanced topics."
msgstr ""
"Ahora que ya tiene cierta experiencia trabajando con Argument Clinic, es el "
"momento de abordar algunos temas avanzados."

#: ../../howto/clinic.rst:561
msgid "Symbolic default values"
msgstr "Valores simbólicos por defecto"

#: ../../howto/clinic.rst:563
msgid ""
"The default value you provide for a parameter can't be any arbitrary "
"expression.  Currently the following are explicitly supported:"
msgstr ""
"El valor por defecto de un parámetro no puede ser una expresión arbitraria.  "
"Actualmente se admiten explícitamente los siguientes:"

#: ../../howto/clinic.rst:566
msgid "Numeric constants (integer and float)"
msgstr "Constantes numéricas (enteros y flotantes)"

#: ../../howto/clinic.rst:567
msgid "String constants"
msgstr "Constantes de cadena"

#: ../../howto/clinic.rst:568
msgid "``True``, ``False``, and ``None``"
msgstr "``True``, ``False``, y ``None``"

#: ../../howto/clinic.rst:569
msgid ""
"Simple symbolic constants like ``sys.maxsize``, which must start with the "
"name of the module"
msgstr ""
"Constantes simbólicas simples como ``sys.maxsize``, que debe empezar por el "
"nombre del módulo."

#: ../../howto/clinic.rst:572
msgid ""
"In case you're curious, this is implemented in  ``from_builtin()`` in ``Lib/"
"inspect.py``."
msgstr ""
"Por si tiene curiosidad, esto se implementa en ``from_builtin()`` en ``Lib/"
"inspect.py``."

#: ../../howto/clinic.rst:575
msgid ""
"(In the future, this may need to get even more elaborate, to allow full "
"expressions like ``CONSTANT - 1``.)"
msgstr ""
"(En el futuro, es posible que esto tenga que ser aún más elaborado, para "
"permitir expresiones completas como ``CONSTANT - 1``.)"

#: ../../howto/clinic.rst:580
msgid "Renaming the C functions and variables generated by Argument Clinic"
msgstr "Renombrar las funciones y variables C generadas por Argument Clinic"

#: ../../howto/clinic.rst:582
msgid ""
"Argument Clinic automatically names the functions it generates for you. "
"Occasionally this may cause a problem, if the generated name collides with "
"the name of an existing C function.  There's an easy solution: override the "
"names used for the C functions.  Just add the keyword ``\"as\"`` to your "
"function declaration line, followed by the function name you wish to use. "
"Argument Clinic will use that function name for the base (generated) "
"function, then add ``\"_impl\"`` to the end and use that for the name of the "
"impl function."
msgstr ""
"Argument Clinic asigna automáticamente un nombre a las funciones que genera. "
"Ocasionalmente esto puede causar un problema, si el nombre generado "
"colisiona con el nombre de una función C existente.  Hay una solución fácil: "
"anular los nombres utilizados para las funciones C.  Sólo tiene que añadir "
"la palabra clave ``\"as\"`` a la línea de declaración de la función, seguida "
"del nombre de la función que desee utilizar. Argument Clinic utilizará ese "
"nombre de función para la función base (generada), luego añadirá "
"``\"_impl\"`` al final y lo utilizará para el nombre de la función impl."

#: ../../howto/clinic.rst:590
msgid ""
"For example, if we wanted to rename the C function names generated for "
"``pickle.Pickler.dump``, it'd look like this::"
msgstr ""
"Por ejemplo, si quisiéramos renombrar los nombres de función C generados "
"para ``pickle.Pickler.dump``, quedaría así::"

#: ../../howto/clinic.rst:598
msgid ""
"The base function would now be named ``pickler_dumper()``, and the impl "
"function would now be named ``pickler_dumper_impl()``."
msgstr ""
"La función base pasaría a llamarse ``pickler_dumper()``, y la función impl "
"pasaría a llamarse ``pickler_dumper_impl()``."

#: ../../howto/clinic.rst:602
msgid ""
"Similarly, you may have a problem where you want to give a parameter a "
"specific Python name, but that name may be inconvenient in C.  Argument "
"Clinic allows you to give a parameter different names in Python and in C, "
"using the same ``\"as\"`` syntax::"
msgstr ""
"De forma similar, puedes tener un problema en el que quieras dar a un "
"parámetro un nombre específico de Python, pero ese nombre puede ser "
"inconveniente en C. Argument Clinic te permite dar a un parámetro diferentes "
"nombres en Python y en C, usando la misma sintaxis ``\"as\"``::"

#: ../../howto/clinic.rst:616
msgid ""
"Here, the name used in Python (in the signature and the ``keywords`` array) "
"would be ``file``, but the C variable would be named ``file_obj``."
msgstr ""
"Aquí, el nombre utilizado en Python (en la firma y en la matriz "
"``keywords`` ) sería ``file``, pero la variable C se llamaría ``file_obj``."

#: ../../howto/clinic.rst:619
msgid "You can use this to rename the ``self`` parameter too!"
msgstr ""
"También puede utilizarlo para cambiar el nombre del parámetro ``self``."

#: ../../howto/clinic.rst:623
msgid "Converting functions using PyArg_UnpackTuple"
msgstr "Convertir funciones usando PyArg_UnpackTuple"

#: ../../howto/clinic.rst:625
msgid ""
"To convert a function parsing its arguments with :c:func:"
"`PyArg_UnpackTuple`, simply write out all the arguments, specifying each as "
"an ``object``.  You may specify the ``type`` argument to cast the type as "
"appropriate.  All arguments should be marked positional-only (add a ``/`` on "
"a line by itself after the last argument)."
msgstr ""
"Para convertir una función analizando sus argumentos con :c:func:"
"`PyArg_UnpackTuple`, simplemente escriba todos los argumentos, especificando "
"cada uno como un ``object``. Puede especificar el argumento ``type`` para "
"convertir el tipo según corresponda.  Todos los argumentos deben marcarse "
"como sólo posicionales (añada un ``/`` en una línea por sí mismo después del "
"último argumento)."

#: ../../howto/clinic.rst:631
msgid ""
"Currently the generated code will use :c:func:`PyArg_ParseTuple`, but this "
"will change soon."
msgstr ""
"Actualmente el código generado utilizará :c:func:`PyArg_ParseTuple`, pero "
"esto cambiará pronto."

#: ../../howto/clinic.rst:635
msgid "Optional Groups"
msgstr "Grupos opcionales"

#: ../../howto/clinic.rst:637
msgid ""
"Some legacy functions have a tricky approach to parsing their arguments: "
"they count the number of positional arguments, then use a ``switch`` "
"statement to call one of several different :c:func:`PyArg_ParseTuple` calls "
"depending on how many positional arguments there are.  (These functions "
"cannot accept keyword-only arguments.)  This approach was used to simulate "
"optional arguments back before :c:func:`PyArg_ParseTupleAndKeywords` was "
"created."
msgstr ""
"Algunas funciones heredadas tienen un enfoque complicado para analizar sus "
"argumentos: cuentan el número de argumentos posicionales, luego usan una "
"sentencia ``switch`` para llamar a una de varias llamadas diferentes a :c:"
"func:`PyArg_ParseTuple` dependiendo de cuántos argumentos posicionales "
"haya.  (Estas funciones no pueden aceptar argumentos de sólo palabra clave.) "
"Este método se utilizaba para simular argumentos opcionales antes de que se "
"creara :c:func:`PyArg_ParseTupleAndKeywords`."

#: ../../howto/clinic.rst:644
msgid ""
"While functions using this approach can often be converted to use :c:func:"
"`PyArg_ParseTupleAndKeywords`, optional arguments, and default values, it's "
"not always possible.  Some of these legacy functions have behaviors :c:func:"
"`PyArg_ParseTupleAndKeywords` doesn't directly support. The most obvious "
"example is the builtin function ``range()``, which has an optional argument "
"on the *left* side of its required argument! Another example is ``curses."
"window.addch()``, which has a group of two arguments that must always be "
"specified together.  (The arguments are called ``x`` and ``y``; if you call "
"the function passing in ``x``, you must also pass in ``y``—and if you don't "
"pass in ``x`` you may not pass in ``y`` either.)"
msgstr ""
"Aunque las funciones que utilizan este enfoque a menudo pueden convertirse "
"para usar :c:func:`PyArg_ParseTupleAndKeywords`, argumentos opcionales y "
"valores por defecto, no siempre es posible. Algunas de estas funciones "
"heredadas tienen comportamientos que :c:func:`PyArg_ParseTupleAndKeywords` "
"no soportan directamente. El ejemplo más obvio es la función incorporada "
"``range()``, ¡que tiene un argumento opcional a la *izquierda* de su "
"argumento obligatorio!. Otro ejemplo es``curses.window.addch()``, que tiene "
"un grupo de dos argumentos que siempre deben especificarse juntos. (Los "
"argumentos se llaman``x`` y ``y``; si llama a la función pasando en ``x``, "
"también debe pasar en ``y``—y si no pasa en ``x`` tampoco puede pasar en "
"``y`` .)"

#: ../../howto/clinic.rst:656
msgid ""
"In any case, the goal of Argument Clinic is to support argument parsing for "
"all existing CPython builtins without changing their semantics. Therefore "
"Argument Clinic supports this alternate approach to parsing, using what are "
"called *optional groups*. Optional groups are groups of arguments that must "
"all be passed in together. They can be to the left or the right of the "
"required arguments.  They can *only* be used with positional-only parameters."
msgstr ""
"En cualquier caso, el objetivo de Argument Clinic es soportar el análisis "
"sintáctico de argumentos para todos los buildins existentes de CPython sin "
"cambiar su semántica. Por lo tanto Argument Clinic soporta esta aproximación "
"alternativa al análisis sintáctico, usando lo que se llama *grupos "
"opcionales*. Los grupos opcionales son grupos de argumentos que deben "
"pasarse juntos. Pueden estar a la izquierda o a la derecha de los argumentos "
"requeridos.  Sólo se pueden utilizar con parámetros de sólo posición."

#: ../../howto/clinic.rst:664
msgid ""
"Optional groups are *only* intended for use when converting functions that "
"make multiple calls to :c:func:`PyArg_ParseTuple`! Functions that use *any* "
"other approach for parsing arguments should *almost never* be converted to "
"Argument Clinic using optional groups.  Functions using optional groups "
"currently cannot have accurate signatures in Python, because Python just "
"doesn't understand the concept.  Please avoid using optional groups wherever "
"possible."
msgstr ""
"¡Los grupos opcionales están *únicamente* pensados para su uso al convertir "
"funciones que realizan múltiples llamadas a :c:func:`PyArg_ParseTuple`! Las "
"funciones que usan *cualquier* otro enfoque para analizar argumentos no "
"deberían *casi nunca* ser convertidas a Argument Clinic usando grupos "
"opcionales.  Las funciones que usan grupos opcionales actualmente no pueden "
"tener firmas precisas en Python, porque Python no entiende el concepto.  Por "
"favor, evite usar grupos opcionales siempre que sea posible."

#: ../../howto/clinic.rst:673
msgid ""
"To specify an optional group, add a ``[`` on a line by itself before the "
"parameters you wish to group together, and a ``]`` on a line by itself after "
"these parameters.  As an example, here's how ``curses.window.addch`` uses "
"optional groups to make the first two parameters and the last parameter "
"optional::"
msgstr ""
"Para especificar un grupo opcional, añada un ``[`` en una línea por sí mismo "
"antes de los parámetros que desea agrupar, y un ``]`` en una línea por sí "
"mismo después de estos parámetros.  A modo de ejemplo, a continuación se "
"muestra cómo ``curses.window.addch`` utiliza grupos opcionales para que los "
"dos primeros parámetros y el último parámetro sean opcionales::"

#: ../../howto/clinic.rst:702
msgid "Notes:"
msgstr "Notas:"

#: ../../howto/clinic.rst:704
msgid ""
"For every optional group, one additional parameter will be passed into the "
"impl function representing the group.  The parameter will be an int named "
"``group_{direction}_{number}``, where ``{direction}`` is either ``right`` or "
"``left`` depending on whether the group is before or after the required "
"parameters, and ``{number}`` is a monotonically increasing number (starting "
"at 1) indicating how far away the group is from the required parameters.  "
"When the impl is called, this parameter will be set to zero if this group "
"was unused, and set to non-zero if this group was used. (By used or unused, "
"I mean whether or not the parameters received arguments in this invocation.)"
msgstr ""
"Por cada grupo opcional, se pasará un parámetro adicional a la función impl "
"que representa al grupo.  El parámetro será un int llamado "
"``group_{direction}_{number}``, donde ``{direction}`` es ``right`` o "
"``left`` dependiendo de si el grupo está antes o después de los parámetros "
"requeridos, y ``{number}`` es un número monótonamente creciente (empezando "
"en 1) que indica lo lejos que está el grupo de los parámetros requeridos.  "
"Cuando se llame a la impl, este parámetro se pondrá a cero si este grupo no "
"se utilizó, y se pondrá a un valor distinto de cero si este grupo se "
"utilizó. (Por usado o no usado, me refiero a si los parámetros recibieron o "
"no argumentos en esta invocación)."

#: ../../howto/clinic.rst:715
msgid ""
"If there are no required arguments, the optional groups will behave as if "
"they're to the right of the required arguments."
msgstr ""
"Si no hay argumentos obligatorios, los grupos opcionales se comportarán como "
"si estuvieran a la derecha de los argumentos obligatorios."

#: ../../howto/clinic.rst:718
msgid ""
"In the case of ambiguity, the argument parsing code favors parameters on the "
"left (before the required parameters)."
msgstr ""
"En caso de ambigüedad, el código de análisis sintáctico de argumentos "
"favorece los parámetros de la izquierda (antes de los parámetros "
"obligatorios)."

#: ../../howto/clinic.rst:721
msgid "Optional groups can only contain positional-only parameters."
msgstr "Los grupos opcionales sólo pueden contener parámetros de posición."

#: ../../howto/clinic.rst:723
msgid ""
"Optional groups are *only* intended for legacy code.  Please do not use "
"optional groups for new code."
msgstr ""
"Los grupos opcionales están *únicamente* pensados para código heredado.  No "
"utilice grupos opcionales para código nuevo."

#: ../../howto/clinic.rst:728
msgid "Using real Argument Clinic converters, instead of \"legacy converters\""
msgstr ""
"Uso de convertidores reales de Argument Clinic, en lugar de \"convertidores "
"heredados\"."

#: ../../howto/clinic.rst:730
msgid ""
"To save time, and to minimize how much you need to learn to achieve your "
"first port to Argument Clinic, the walkthrough above tells you to use "
"\"legacy converters\".  \"Legacy converters\" are a convenience, designed "
"explicitly to make porting existing code to Argument Clinic easier.  And to "
"be clear, their use is acceptable when porting code for Python 3.4."
msgstr ""
"Para ahorrar tiempo, y minimizar lo mucho que necesitas aprender para lograr "
"tu primera portabilidad a Argument Clinic, el tutorial anterior te dice que "
"uses \"conversores heredados\".  Los \"conversores heredados\" son una "
"conveniencia, diseñados explícitamente para hacer más fácil la portabilidad "
"de código existente a Argument Clinic.  Y para ser claros, su uso es "
"aceptable al portar código para Python 3.4."

#: ../../howto/clinic.rst:737
msgid ""
"However, in the long term we probably want all our blocks to use Argument "
"Clinic's real syntax for converters.  Why?  A couple reasons:"
msgstr ""
"Sin embargo, a largo plazo probablemente queramos que todos nuestros bloques "
"utilicen la sintaxis real de Argument Clinic para los conversores.  ¿Por "
"qué?  Por un par de razones:"

#: ../../howto/clinic.rst:741
msgid ""
"The proper converters are far easier to read and clearer in their intent."
msgstr ""
"Los conversores adecuados son mucho más fáciles de leer y más claros en su "
"intención."

#: ../../howto/clinic.rst:742
msgid ""
"There are some format units that are unsupported as \"legacy converters\", "
"because they require arguments, and the legacy converter syntax doesn't "
"support specifying arguments."
msgstr ""
"Hay algunas unidades de formato que no se admiten como \"conversores "
"heredados\", porque requieren argumentos y la sintaxis de los conversores "
"heredados no admite la especificación de argumentos."

#: ../../howto/clinic.rst:745
msgid ""
"In the future we may have a new argument parsing library that isn't "
"restricted to what :c:func:`PyArg_ParseTuple` supports; this flexibility "
"won't be available to parameters using legacy converters."
msgstr ""
"Es posible que en el futuro dispongamos de una nueva biblioteca de análisis "
"sintáctico de argumentos que no se limite a lo que admite :c:func:"
"`PyArg_ParseTuple`; esta flexibilidad no estará disponible para los "
"parámetros que utilicen convertidores heredados."

#: ../../howto/clinic.rst:749
msgid ""
"Therefore, if you don't mind a little extra effort, please use the normal "
"converters instead of legacy converters."
msgstr ""
"Por lo tanto, si no le importa hacer un pequeño esfuerzo adicional, utilice "
"los conversores normales en lugar de los conversores heredados."

#: ../../howto/clinic.rst:752
msgid ""
"In a nutshell, the syntax for Argument Clinic (non-legacy) converters looks "
"like a Python function call.  However, if there are no explicit arguments to "
"the function (all functions take their default values), you may omit the "
"parentheses.  Thus ``bool`` and ``bool()`` are exactly the same converters."
msgstr ""
"En pocas palabras, la sintaxis de los conversores Argument Clinic (no "
"legacy) se parece a la de una llamada a una función de Python.  Sin embargo, "
"si no hay argumentos explícitos para la función (todas las funciones toman "
"sus valores por defecto), puede omitir los paréntesis.  Así, ``bool`` y "
"``bool()`` son exactamente los mismos convertidores."

#: ../../howto/clinic.rst:758
msgid ""
"All arguments to Argument Clinic converters are keyword-only. All Argument "
"Clinic converters accept the following arguments:"
msgstr ""
"Todos los argumentos de los conversores de Argument Clinic son sólo palabras "
"clave. Todos los conversores de Argument Clinic aceptan los siguientes "
"argumentos:"

#: ../../howto/clinic.rst:766 ../../howto/clinic.rst:1316
msgid "``c_default``"
msgstr "``c_default``"

#: ../../howto/clinic.rst:762
msgid ""
"The default value for this parameter when defined in C. Specifically, this "
"will be the initializer for the variable declared in the \"parse "
"function\".  See :ref:`the section on default values <default_values>` for "
"how to use this. Specified as a string."
msgstr ""
"El valor por defecto para este parámetro cuando se define en C. "
"Específicamente, este será el inicializador para la variable declarada en la "
"\"función parse\".  Ver :ref:`la sección sobre valores por defecto "
"<default_values>` para saber cómo utilizarlo. Especificado como una cadena."

#: ../../howto/clinic.rst:771
msgid "``annotation``"
msgstr "``annotation``"

#: ../../howto/clinic.rst:769
msgid ""
"The annotation value for this parameter.  Not currently supported, because :"
"pep:`8` mandates that the Python library may not use annotations."
msgstr ""
"El valor de la anotación para este parámetro.  Actualmente no se admite "
"porque :pep:`8` establece que la biblioteca Python no puede utilizar "
"anotaciones."

#: ../../howto/clinic.rst:773
msgid ""
"In addition, some converters accept additional arguments.  Here is a list of "
"these arguments, along with their meanings:"
msgstr ""
"Además, algunos conversores aceptan argumentos adicionales.  He aquí una "
"lista de estos argumentos, junto con sus significados:"

#: ../../howto/clinic.rst:782
msgid "``accept``"
msgstr "``accept``"

#: ../../howto/clinic.rst:777
msgid ""
"A set of Python types (and possibly pseudo-types); this restricts the "
"allowable Python argument to values of these types. (This is not a general-"
"purpose facility; as a rule it only supports specific lists of types as "
"shown in the legacy converter table.)"
msgstr ""
"Un conjunto de tipos Python (y posiblemente pseudotipos); esto restringe el "
"argumento Python permitido a valores de estos tipos. (Esta no es una "
"facilidad de propósito general; como regla sólo soporta listas específicas "
"de tipos como se muestra en la tabla de conversores heredados)."

#: ../../howto/clinic.rst:782
msgid "To accept ``None``, add ``NoneType`` to this set."
msgstr "Para aceptar ``None``, añada ``NoneType`` a este conjunto."

#: ../../howto/clinic.rst:787
msgid "``bitwise``"
msgstr "``bitwise``"

#: ../../howto/clinic.rst:785
msgid ""
"Only supported for unsigned integers.  The native integer value of this "
"Python argument will be written to the parameter without any range checking, "
"even for negative values."
msgstr ""
"Sólo soportado para enteros sin signo.  El valor entero nativo de este "
"argumento de Python se escribirá en el parámetro sin ninguna comprobación de "
"rango, incluso para valores negativos."

#: ../../howto/clinic.rst:792 ../../howto/clinic.rst:1330
msgid "``converter``"
msgstr "``converter``"

#: ../../howto/clinic.rst:790
msgid ""
"Only supported by the ``object`` converter.  Specifies the name of a :ref:`C "
"\"converter function\" <o_ampersand>` to use to convert this object to a "
"native type."
msgstr ""
"Sólo soportado por el convertidor ``object``.  Especifica el nombre de una :"
"ref:`C \"converter function\" <o_ampersand>` a utilizar para convertir este "
"objeto a un tipo nativo."

#: ../../howto/clinic.rst:797
msgid "``encoding``"
msgstr "``encoding``"

#: ../../howto/clinic.rst:795
msgid ""
"Only supported for strings.  Specifies the encoding to use when converting "
"this string from a Python str (Unicode) value into a C ``char *`` value."
msgstr ""
"Sólo se admite para cadenas.  Especifica la codificación que se utilizará al "
"convertir esta cadena de un valor str (Unicode) de Python a un valor ``char "
"*`` de C."

#: ../../howto/clinic.rst:801
msgid "``subclass_of``"
msgstr "``subclass_of``"

#: ../../howto/clinic.rst:800
msgid ""
"Only supported for the ``object`` converter.  Requires that the Python value "
"be a subclass of a Python type, as expressed in C."
msgstr ""
"Sólo compatible con el convertidor ``object``.  Requiere que el valor Python "
"sea una subclase de un tipo Python, expresado en C."

#: ../../howto/clinic.rst:806 ../../howto/clinic.rst:1302
msgid "``type``"
msgstr "``type``"

#: ../../howto/clinic.rst:804
msgid ""
"Only supported for the ``object`` and ``self`` converters.  Specifies the C "
"type that will be used to declare the variable.  Default value is "
"``\"PyObject *\"``."
msgstr ""
"Sólo compatible con los convertidores ``object`` y ``self``.  Especifica el "
"tipo C que se utilizará para declarar la variable.  El valor por defecto es "
"``\"PyObject *\"``."

#: ../../howto/clinic.rst:812
msgid "``zeroes``"
msgstr "``zeroes``"

#: ../../howto/clinic.rst:809
msgid ""
"Only supported for strings.  If true, embedded NUL bytes (``'\\\\0'``) are "
"permitted inside the value.  The length of the string will be passed in to "
"the impl function, just after the string parameter, as a parameter named "
"``<parameter_name>_length``."
msgstr ""
"Sólo se admite para cadenas.  Si es verdadero, se permiten bytes NUL "
"incrustados (``'\\\\0'``) dentro del valor.  La longitud de la cadena se "
"pasará a la función impl, justo después del parámetro de cadena, como un "
"parámetro llamado ``<parameter_name>_length``."

#: ../../howto/clinic.rst:814
msgid ""
"Please note, not every possible combination of arguments will work. Usually "
"these arguments are implemented by specific ``PyArg_ParseTuple`` *format "
"units*, with specific behavior.  For example, currently you cannot call "
"``unsigned_short`` without also specifying ``bitwise=True``. Although it's "
"perfectly reasonable to think this would work, these semantics don't map to "
"any existing format unit.  So Argument Clinic doesn't support it.  (Or, at "
"least, not yet.)"
msgstr ""
"Tenga en cuenta que no todas las combinaciones posibles de argumentos "
"funcionarán. Normalmente estos argumentos son implementados por "
"``PyArg_ParseTuple`` *unidades de formato* específicas, con un "
"comportamiento específico.  Por ejemplo, actualmente no se puede llamar a "
"``unsigned_short`` sin especificar también ``bitwise=True``. Aunque es "
"perfectamente razonable pensar que esto funcionaría, esta semántica no se "
"corresponde con ninguna unidad de formato existente.  Así que Argument "
"Clinic no lo admite.  (O, al menos, todavía no)."

#: ../../howto/clinic.rst:822
msgid ""
"Below is a table showing the mapping of legacy converters into real Argument "
"Clinic converters.  On the left is the legacy converter, on the right is the "
"text you'd replace it with."
msgstr ""
"A continuación se muestra una tabla con la correspondencia entre los "
"conversores antiguos y los conversores reales de Argument Clinic.  A la "
"izquierda está el conversor heredado, a la derecha el texto con el que lo "
"sustituirías."

#: ../../howto/clinic.rst:827
msgid "``'B'``"
msgstr "``'B'``"

#: ../../howto/clinic.rst:827
msgid "``unsigned_char(bitwise=True)``"
msgstr "``unsigned_char(bitwise=True)``"

#: ../../howto/clinic.rst:828
msgid "``'b'``"
msgstr "``'b'``"

#: ../../howto/clinic.rst:828
msgid "``unsigned_char``"
msgstr "``unsigned_char``"

#: ../../howto/clinic.rst:829
msgid "``'c'``"
msgstr "``'c'``"

#: ../../howto/clinic.rst:829
msgid "``char``"
msgstr "``char``"

#: ../../howto/clinic.rst:830
msgid "``'C'``"
msgstr "``'C'``"

#: ../../howto/clinic.rst:830
msgid "``int(accept={str})``"
msgstr "``int(accept={str})``"

#: ../../howto/clinic.rst:831
msgid "``'d'``"
msgstr "``'d'``"

#: ../../howto/clinic.rst:831
msgid "``double``"
msgstr "``double``"

#: ../../howto/clinic.rst:832
msgid "``'D'``"
msgstr "``'D'``"

#: ../../howto/clinic.rst:832
msgid "``Py_complex``"
msgstr "``Py_complex``"

#: ../../howto/clinic.rst:833
msgid "``'es'``"
msgstr "``'es'``"

#: ../../howto/clinic.rst:833
msgid "``str(encoding='name_of_encoding')``"
msgstr "``str(encoding='name_of_encoding')``"

#: ../../howto/clinic.rst:834
msgid "``'es#'``"
msgstr "``'es#'``"

#: ../../howto/clinic.rst:834
msgid "``str(encoding='name_of_encoding', zeroes=True)``"
msgstr "``str(encoding='name_of_encoding', zeroes=True)``"

#: ../../howto/clinic.rst:835
msgid "``'et'``"
msgstr "``'et'``"

#: ../../howto/clinic.rst:835
msgid "``str(encoding='name_of_encoding', accept={bytes, bytearray, str})``"
msgstr "``str(encoding='name_of_encoding', accept={bytes, bytearray, str})``"

#: ../../howto/clinic.rst:836
msgid "``'et#'``"
msgstr "``'et#'``"

#: ../../howto/clinic.rst:836
msgid ""
"``str(encoding='name_of_encoding', accept={bytes, bytearray, str}, "
"zeroes=True)``"
msgstr ""
"``str(encoding='name_of_encoding', accept={bytes, bytearray, str}, "
"zeroes=True)``"

#: ../../howto/clinic.rst:837
msgid "``'f'``"
msgstr "``'f'``"

#: ../../howto/clinic.rst:837
msgid "``float``"
msgstr "``float``"

#: ../../howto/clinic.rst:838
msgid "``'h'``"
msgstr "``'h'``"

#: ../../howto/clinic.rst:838
msgid "``short``"
msgstr "``short``"

#: ../../howto/clinic.rst:839
msgid "``'H'``"
msgstr "``'H'``"

#: ../../howto/clinic.rst:839
msgid "``unsigned_short(bitwise=True)``"
msgstr "``unsigned_short(bitwise=True)``"

#: ../../howto/clinic.rst:840
msgid "``'i'``"
msgstr "``'i'``"

#: ../../howto/clinic.rst:840
msgid "``int``"
msgstr "``int``"

#: ../../howto/clinic.rst:841
msgid "``'I'``"
msgstr "``'I'``"

#: ../../howto/clinic.rst:841
msgid "``unsigned_int(bitwise=True)``"
msgstr "``unsigned_int(bitwise=True)``"

#: ../../howto/clinic.rst:842
msgid "``'k'``"
msgstr "``'k'``"

#: ../../howto/clinic.rst:842
msgid "``unsigned_long(bitwise=True)``"
msgstr "``unsigned_long(bitwise=True)``"

#: ../../howto/clinic.rst:843
msgid "``'K'``"
msgstr "``'K'``"

#: ../../howto/clinic.rst:843
msgid "``unsigned_long_long(bitwise=True)``"
msgstr "``unsigned_long_long(bitwise=True)``"

#: ../../howto/clinic.rst:844
msgid "``'l'``"
msgstr "``'l'``"

#: ../../howto/clinic.rst:844
msgid "``long``"
msgstr "``long``"

#: ../../howto/clinic.rst:845
msgid "``'L'``"
msgstr "``'L'``"

#: ../../howto/clinic.rst:845
msgid "``long long``"
msgstr "``long long``"

#: ../../howto/clinic.rst:846
msgid "``'n'``"
msgstr "``'n'``"

#: ../../howto/clinic.rst:846
msgid "``Py_ssize_t``"
msgstr "``Py_ssize_t``"

#: ../../howto/clinic.rst:847
msgid "``'O'``"
msgstr "``'O'``"

#: ../../howto/clinic.rst:847
msgid "``object``"
msgstr "``object``"

#: ../../howto/clinic.rst:848
msgid "``'O!'``"
msgstr "``'O!'``"

#: ../../howto/clinic.rst:848
msgid "``object(subclass_of='&PySomething_Type')``"
msgstr "``object(subclass_of='&PySomething_Type')``"

#: ../../howto/clinic.rst:849
msgid "``'O&'``"
msgstr "``'O&'``"

#: ../../howto/clinic.rst:849
msgid "``object(converter='name_of_c_function')``"
msgstr "``object(converter='name_of_c_function')``"

#: ../../howto/clinic.rst:850
msgid "``'p'``"
msgstr "``'p'``"

#: ../../howto/clinic.rst:850
msgid "``bool``"
msgstr "``bool``"

#: ../../howto/clinic.rst:851
msgid "``'S'``"
msgstr "``'S'``"

#: ../../howto/clinic.rst:851
msgid "``PyBytesObject``"
msgstr "``PyBytesObject``"

#: ../../howto/clinic.rst:852
msgid "``'s'``"
msgstr "``'s'``"

#: ../../howto/clinic.rst:852
msgid "``str``"
msgstr "``str``"

#: ../../howto/clinic.rst:853
msgid "``'s#'``"
msgstr "``'s#'``"

#: ../../howto/clinic.rst:853
msgid "``str(zeroes=True)``"
msgstr "``str(zeroes=True)``"

#: ../../howto/clinic.rst:854
msgid "``'s*'``"
msgstr "``'s*'``"

#: ../../howto/clinic.rst:854
msgid "``Py_buffer(accept={buffer, str})``"
msgstr "``Py_buffer(accept={buffer, str})``"

#: ../../howto/clinic.rst:855
msgid "``'U'``"
msgstr "``'U'``"

#: ../../howto/clinic.rst:855
msgid "``unicode``"
msgstr "``unicode``"

#: ../../howto/clinic.rst:856
msgid "``'u'``"
msgstr "``'u'``"

#: ../../howto/clinic.rst:856
msgid "``Py_UNICODE``"
msgstr "``Py_UNICODE``"

#: ../../howto/clinic.rst:857
msgid "``'u#'``"
msgstr "``'u#'``"

#: ../../howto/clinic.rst:857
msgid "``Py_UNICODE(zeroes=True)``"
msgstr "``Py_UNICODE(zeroes=True)``"

#: ../../howto/clinic.rst:858
msgid "``'w*'``"
msgstr "``'w*'``"

#: ../../howto/clinic.rst:858
msgid "``Py_buffer(accept={rwbuffer})``"
msgstr "``Py_buffer(accept={rwbuffer})``"

#: ../../howto/clinic.rst:859
msgid "``'Y'``"
msgstr "``'Y'``"

#: ../../howto/clinic.rst:859
msgid "``PyByteArrayObject``"
msgstr "``PyByteArrayObject``"

#: ../../howto/clinic.rst:860
msgid "``'y'``"
msgstr "``'y'``"

#: ../../howto/clinic.rst:860
msgid "``str(accept={bytes})``"
msgstr "``str(accept={bytes})``"

#: ../../howto/clinic.rst:861
msgid "``'y#'``"
msgstr "``'y#'``"

#: ../../howto/clinic.rst:861
msgid "``str(accept={robuffer}, zeroes=True)``"
msgstr "``str(accept={robuffer}, zeroes=True)``"

#: ../../howto/clinic.rst:862
msgid "``'y*'``"
msgstr "``'y*'``"

#: ../../howto/clinic.rst:862
msgid "``Py_buffer``"
msgstr "``Py_buffer``"

#: ../../howto/clinic.rst:863
msgid "``'Z'``"
msgstr "``'Z'``"

#: ../../howto/clinic.rst:863
msgid "``Py_UNICODE(accept={str, NoneType})``"
msgstr "``Py_UNICODE(accept={str, NoneType})``"

#: ../../howto/clinic.rst:864
msgid "``'Z#'``"
msgstr "``'Z#'``"

#: ../../howto/clinic.rst:864
msgid "``Py_UNICODE(accept={str, NoneType}, zeroes=True)``"
msgstr "``Py_UNICODE(accept={str, NoneType}, zeroes=True)``"

#: ../../howto/clinic.rst:865
msgid "``'z'``"
msgstr "``'z'``"

#: ../../howto/clinic.rst:865
msgid "``str(accept={str, NoneType})``"
msgstr "``str(accept={str, NoneType})``"

#: ../../howto/clinic.rst:866
msgid "``'z#'``"
msgstr "``'z#'``"

#: ../../howto/clinic.rst:866
msgid "``str(accept={str, NoneType}, zeroes=True)``"
msgstr "``str(accept={str, NoneType}, zeroes=True)``"

#: ../../howto/clinic.rst:867
msgid "``'z*'``"
msgstr "``'z*'``"

#: ../../howto/clinic.rst:867
msgid "``Py_buffer(accept={buffer, str, NoneType})``"
msgstr "``Py_buffer(accept={buffer, str, NoneType})``"

#: ../../howto/clinic.rst:870
msgid ""
"As an example, here's our sample ``pickle.Pickler.dump`` using the proper "
"converter::"
msgstr ""
"Como ejemplo, aquí está nuestro ejemplo ``pickle.Pickler.dump`` utilizando "
"el convertidor adecuado::"

#: ../../howto/clinic.rst:883
msgid ""
"One advantage of real converters is that they're more flexible than legacy "
"converters.  For example, the ``unsigned_int`` converter (and all the "
"``unsigned_`` converters) can be specified without ``bitwise=True``.  Their "
"default behavior performs range checking on the value, and they won't accept "
"negative numbers.  You just can't do that with a legacy converter!"
msgstr ""
"Una ventaja de los conversores reales es que son más flexibles que los "
"conversores heredados.  Por ejemplo, el conversor ``unsigned_int`` (y todos "
"los conversores ``unsigned_`` ) pueden especificarse sin ``bitwise=True``.  "
"Su comportamiento por defecto comprueba el rango del valor y no acepta "
"números negativos.  Eso no se puede hacer con un convertidor heredado."

#: ../../howto/clinic.rst:889
msgid ""
"Argument Clinic will show you all the converters it has available.  For each "
"converter it'll show you all the parameters it accepts, along with the "
"default value for each parameter. Just run ``Tools/clinic/clinic.py --"
"converters`` to see the full list."
msgstr ""
"Argument Clinic te mostrará todos los conversores que tiene disponibles.  "
"Para cada conversor te mostrará todos los parámetros que acepta, junto con "
"el valor por defecto de cada parámetro. Ejecute ``Tools/clinic/clinic.py --"
"converters`` para ver la lista completa."

#: ../../howto/clinic.rst:895
msgid "Py_buffer"
msgstr "Py_buffer"

#: ../../howto/clinic.rst:897
msgid ""
"When using the ``Py_buffer`` converter (or the ``'s*'``, ``'w*'``, ``'*y'``, "
"or ``'z*'`` legacy converters), you *must* not call :c:func:"
"`PyBuffer_Release` on the provided buffer. Argument Clinic generates code "
"that does it for you (in the parsing function)."
msgstr ""
"Cuando utilice el conversor ``Py_buffer`` (o los conversores heredados "
"``'s*'``, ``'w*'``, ``'*y'``, o ``'z*'`` ), *no debe* llamar a :c:func:"
"`PyBuffer_Release` en el búfer proporcionado. Argument Clinic genera código "
"que lo hace por ti (en la función de análisis)."

#: ../../howto/clinic.rst:905
msgid "Advanced converters"
msgstr "Convertidores avanzados"

#: ../../howto/clinic.rst:907
msgid ""
"Remember those format units you skipped for your first time because they "
"were advanced?  Here's how to handle those too."
msgstr ""
"¿Recuerdas esas unidades de formato que te saltaste la primera vez porque "
"eran avanzadas?  Aquí tienes cómo manejarlas también."

#: ../../howto/clinic.rst:910
msgid ""
"The trick is, all those format units take arguments—either conversion "
"functions, or types, or strings specifying an encoding. (But \"legacy "
"converters\" don't support arguments.  That's why we skipped them for your "
"first function.)  The argument you specified to the format unit is now an "
"argument to the converter; this argument is either ``converter`` (for "
"``O&``), ``subclass_of`` (for ``O!``), or ``encoding`` (for all the format "
"units that start with ``e``)."
msgstr ""
"El truco es que todas esas unidades de formato aceptan argumentos, ya sean "
"funciones de conversión, tipos o cadenas que especifican una codificación. "
"(Pero los \"conversores heredados\" no admiten argumentos.  Por eso los "
"omitimos para tu primera función).  El argumento que especificó para la "
"unidad de formato es ahora un argumento para el conversor; este argumento es "
"``converter`` (para ``O&``), ``subclass_of`` (para ``O!``), o ``encoding`` "
"(para todas las unidades de formato que empiezan por ``e``)."

#: ../../howto/clinic.rst:918
msgid ""
"When using ``subclass_of``, you may also want to use the other custom "
"argument for ``object()``: ``type``, which lets you set the type actually "
"used for the parameter.  For example, if you want to ensure that the object "
"is a subclass of ``PyUnicode_Type``, you probably want to use the converter "
"``object(type='PyUnicodeObject *', subclass_of='&PyUnicode_Type')``."
msgstr ""
"Al utilizar ``subclass_of``, puede que también desee utilizar el otro "
"argumento personalizado para ``object()``: ``type`` que le permite "
"establecer el tipo utilizado realmente para el parámetro.  Por ejemplo, si "
"desea asegurarse de que el objeto es una subclase de ``PyUnicode_Type``, es "
"probable que desee utilizar el convertidor ``object(type='PyUnicodeObject "
"*', subclass_of='&PyUnicode_Type')``."

#: ../../howto/clinic.rst:924
msgid ""
"One possible problem with using Argument Clinic: it takes away some possible "
"flexibility for the format units starting with ``e``.  When writing a "
"``PyArg_Parse`` call by hand, you could theoretically decide at runtime what "
"encoding string to pass in to :c:func:`PyArg_ParseTuple`.   But now this "
"string must be hard-coded at Argument-Clinic-preprocessing-time.  This "
"limitation is deliberate; it made supporting this format unit much easier, "
"and may allow for future optimizations. This restriction doesn't seem "
"unreasonable; CPython itself always passes in static hard-coded encoding "
"strings for parameters whose format units start with ``e``."
msgstr ""
"Un posible problema de la utilización de Argument Clinic es que resta "
"flexibilidad a las unidades de formato que empiezan por ``e``.  Cuando se "
"escribe una llamada a ``PyArg_Parse`` a mano, teóricamente se podría decidir "
"en tiempo de ejecución qué cadena de codificación pasar a :c:func:"
"`PyArg_ParseTuple`. Pero ahora esta cadena debe ser codificada en tiempo de "
"preprocesamiento de Argument-Clinic.  Esta limitación es deliberada; hace "
"que el soporte de esta unidad de formato sea mucho más fácil, y puede "
"permitir futuras optimizaciones. Esta restricción no parece irrazonable; el "
"propio CPython siempre pasa cadenas de codificación estáticas codificadas "
"para parámetros cuyas unidades de formato empiezan por ``e``."

#: ../../howto/clinic.rst:937
msgid "Parameter default values"
msgstr "Valores por defecto de los parámetros"

#: ../../howto/clinic.rst:939
msgid ""
"Default values for parameters can be any of a number of values. At their "
"simplest, they can be string, int, or float literals:"
msgstr ""
"Los valores por defecto de los parámetros pueden ser de varios tipos. En su "
"forma más simple, pueden ser literales string, int o float:"

#: ../../howto/clinic.rst:948
msgid "They can also use any of Python's built-in constants:"
msgstr ""
"También pueden utilizar cualquiera de las constantes incorporadas en Python:"

#: ../../howto/clinic.rst:956
msgid ""
"There's also special support for a default value of ``NULL``, and for simple "
"expressions, documented in the following sections."
msgstr ""
"También hay soporte especial para un valor por defecto de ``NULL``, y para "
"expresiones simples, documentadas en las siguientes secciones."

#: ../../howto/clinic.rst:961
msgid "The ``NULL`` default value"
msgstr "El valor por defecto ``NULL`` "

#: ../../howto/clinic.rst:963
msgid ""
"For string and object parameters, you can set them to ``None`` to indicate "
"that there's no default.  However, that means the C variable will be "
"initialized to ``Py_None``.  For convenience's sakes, there's a special "
"value called ``NULL`` for just this reason: from Python's perspective it "
"behaves like a default value of ``None``, but the C variable is initialized "
"with ``NULL``."
msgstr ""
"En el caso de los parámetros de cadena y objeto, puede establecerlos en "
"``None`` para indicar que no hay ningún valor por defecto.  Sin embargo, eso "
"significa que la variable C se inicializará a ``Py_None``.  Por "
"conveniencia, hay un valor especial llamado ``NULL`` precisamente por esta "
"razón: desde la perspectiva de Python se comporta como un valor por defecto "
"de ``None``, pero la variable C se inicializa con ``NULL``."

#: ../../howto/clinic.rst:971
msgid "Expressions specified as default values"
msgstr "Expresiones especificadas como valores por defecto"

#: ../../howto/clinic.rst:973
msgid ""
"The default value for a parameter can be more than just a literal value. It "
"can be an entire expression, using math operators and looking up attributes "
"on objects.  However, this support isn't exactly simple, because of some non-"
"obvious semantics."
msgstr ""
"El valor por defecto de un parámetro puede ser algo más que un valor "
"literal. Puede ser una expresión completa, que utilice operadores "
"matemáticos y busque atributos en los objetos.  Sin embargo, este soporte no "
"es exactamente sencillo, debido a algunas semánticas no obvias."

#: ../../howto/clinic.rst:978
msgid "Consider the following example:"
msgstr "Considere el siguiente ejemplo:"

#: ../../howto/clinic.rst:984
msgid ""
"``sys.maxsize`` can have different values on different platforms.  Therefore "
"Argument Clinic can't simply evaluate that expression locally and hard-code "
"it in C.  So it stores the default in such a way that it will get evaluated "
"at runtime, when the user asks for the function's signature."
msgstr ""
"``sys.maxsize`` puede tener diferentes valores en diferentes plataformas.  "
"Por lo tanto, Argument Clinic no puede simplemente evaluar esa expresión "
"localmente y codificarla en C. Así que almacena el valor predeterminado de "
"tal manera que se evaluará en tiempo de ejecución, cuando el usuario "
"pregunte por la firma de la función."

#: ../../howto/clinic.rst:989
msgid ""
"What namespace is available when the expression is evaluated?  It's "
"evaluated in the context of the module the builtin came from.  So, if your "
"module has an attribute called \"``max_widgets``\", you may simply use it:"
msgstr ""
"¿Qué espacio de nombres está disponible cuando se evalúa la expresión?  Se "
"evalúa en el contexto del módulo del que procede el builtin.  Por lo tanto, "
"si su módulo tiene un atributo llamado \"``max_widgets``\", puede "
"simplemente utilizarlo:"

#: ../../howto/clinic.rst:997
msgid ""
"If the symbol isn't found in the current module, it fails over to looking in "
"``sys.modules``.  That's how it can find ``sys.maxsize`` for example.  "
"(Since you don't know in advance what modules the user will load into their "
"interpreter, it's best to restrict yourself to modules that are preloaded by "
"Python itself.)"
msgstr ""
"Si el símbolo no se encuentra en el módulo actual, pasa a buscarlo en ``sys."
"modules``.  Así es como puede encontrar ``sys.maxsize``, por ejemplo.  (Dado "
"que no sabes de antemano qué módulos cargará el usuario en su intérprete, es "
"mejor limitarse a los módulos precargados por el propio Python)."

#: ../../howto/clinic.rst:1002
msgid ""
"Evaluating default values only at runtime means Argument Clinic can't "
"compute the correct equivalent C default value.  So you need to tell it "
"explicitly. When you use an expression, you must also specify the equivalent "
"expression in C, using the ``c_default`` parameter to the converter:"
msgstr ""
"Evaluar los valores por defecto sólo en tiempo de ejecución significa que "
"Argument Clinic no puede calcular el valor por defecto C equivalente "
"correcto.  Así que tienes que decírselo explícitamente. Cuando utilices una "
"expresión, también debes especificar la expresión equivalente en C, "
"utilizando el parámetro ``c_default`` del conversor:"

#: ../../howto/clinic.rst:1011
msgid ""
"Another complication: Argument Clinic can't know in advance whether or not "
"the expression you supply is valid.  It parses it to make sure it looks "
"legal, but it can't *actually* know.  You must be very careful when using "
"expressions to specify values that are guaranteed to be valid at runtime!"
msgstr ""
"Otra complicación: Argument Clinic no puede saber de antemano si la "
"expresión que proporcionas es válida o no.  La analiza para asegurarse de "
"que parece legal, pero no puede saberlo *realmente*.  Debes tener mucho "
"cuidado cuando utilices expresiones para especificar valores cuya validez "
"esté garantizada en tiempo de ejecución."

#: ../../howto/clinic.rst:1016
msgid ""
"Finally, because expressions must be representable as static C values, there "
"are many restrictions on legal expressions.  Here's a list of Python "
"features you're not permitted to use:"
msgstr ""
"Por último, dado que las expresiones deben ser representables como valores "
"estáticos de C, existen muchas restricciones sobre las expresiones legales.  "
"Aquí tienes una lista de funciones de Python que no puedes usar:"

#: ../../howto/clinic.rst:1020
msgid "Function calls."
msgstr "Llamadas a función."

#: ../../howto/clinic.rst:1021
msgid "Inline if statements (``3 if foo else 5``)."
msgstr "Sentencias if en línea (``3 if foo else 5``)."

#: ../../howto/clinic.rst:1022
msgid "Automatic sequence unpacking (``*[1, 2, 3]``)."
msgstr "Desembalaje secuencial automático (``*[1, 2, 3]``)."

#: ../../howto/clinic.rst:1023
msgid "List/set/dict comprehensions and generator expressions."
msgstr "Comprensiones list/set/dict y expresiones generadoras."

#: ../../howto/clinic.rst:1024
msgid "Tuple/list/set/dict literals."
msgstr "Literales tuple/list/set/dict ."

#: ../../howto/clinic.rst:1029
msgid "Using a return converter"
msgstr "Utilizar un convertidor de retorno"

#: ../../howto/clinic.rst:1031
msgid ""
"By default the impl function Argument Clinic generates for you returns "
"``PyObject *``. But your C function often computes some C type, then "
"converts it into the ``PyObject *`` at the last moment.  Argument Clinic "
"handles converting your inputs from Python types into native C types—why not "
"have it convert your return value from a native C type into a Python type "
"too?"
msgstr ""
"Por defecto, la función impl que Argument Clinic genera para ti devuelve "
"``PyObject *``. Pero tu función C a menudo calcula algún tipo C, y luego lo "
"convierte en ``PyObject *`` en el último momento.  Argument Clinic se "
"encarga de convertir tus entradas de tipos Python a tipos C nativos, ¿por "
"qué no hacer que convierta también tu valor de retorno de un tipo C nativo a "
"un tipo Python?"

#: ../../howto/clinic.rst:1037
msgid ""
"That's what a \"return converter\" does.  It changes your impl function to "
"return some C type, then adds code to the generated (non-impl) function to "
"handle converting that value into the appropriate ``PyObject *``."
msgstr ""
"Eso es lo que hace un \"convertidor de retorno\".  Cambia tu función impl "
"para que devuelva algún tipo C, luego añade código a la función generada (no "
"impl) para manejar la conversión de ese valor en el apropiado ``PyObject *``."

#: ../../howto/clinic.rst:1041
msgid ""
"The syntax for return converters is similar to that of parameter converters. "
"You specify the return converter like it was a return annotation on the "
"function itself.  Return converters behave much the same as parameter "
"converters; they take arguments, the arguments are all keyword-only, and if "
"you're not changing any of the default arguments you can omit the "
"parentheses."
msgstr ""
"La sintaxis de los convertidores de retorno es similar a la de los "
"convertidores de parámetros. Se especifica el convertidor de retorno como si "
"fuera una anotación de retorno en la propia función.  Los convertidores de "
"retorno se comportan de forma muy similar a los convertidores de parámetros; "
"toman argumentos, los argumentos son todos de palabra clave y, si no vas a "
"cambiar ninguno de los argumentos predeterminados, puedes omitir los "
"paréntesis."

#: ../../howto/clinic.rst:1047
msgid ""
"(If you use both ``\"as\"`` *and* a return converter for your function, the "
"``\"as\"`` should come before the return converter.)"
msgstr ""
"(Si utiliza tanto ``\"as\"`` *como* un convertidor de retorno para su "
"función, el ``\"as\"`` debe ir antes del convertidor de retorno)."

#: ../../howto/clinic.rst:1050
msgid ""
"There's one additional complication when using return converters: how do you "
"indicate an error has occurred?  Normally, a function returns a valid (non-"
"``NULL``) pointer for success, and ``NULL`` for failure.  But if you use an "
"integer return converter, all integers are valid.  How can Argument Clinic "
"detect an error?  Its solution: each return converter implicitly looks for a "
"special value that indicates an error.  If you return that value, and an "
"error has been set (``PyErr_Occurred()`` returns a true value), then the "
"generated code will propagate the error.  Otherwise it will encode the value "
"you return like normal."
msgstr ""
"Hay una complicación adicional cuando se utilizan convertidores de retorno: "
"¿cómo se indica que se ha producido un error?  Normalmente, una función "
"devuelve un puntero válido (no``NULL``) en caso de éxito, y ``NULL`` en caso "
"de error.  Pero si se utiliza un convertidor de retorno de enteros, todos "
"los enteros son válidos.  ¿Cómo puede Argument Clinic detectar un error?  Su "
"solución: cada convertidor de retorno busca implícitamente un valor especial "
"que indica un error.  Si devuelve ese valor, y se ha establecido un error "
"(``PyErr_Occurred()`` devuelve un valor verdadero), entonces el código "
"generado propagará el error.  De lo contrario, codificará el valor que "
"devuelve como normal."

#: ../../howto/clinic.rst:1059
msgid "Currently Argument Clinic supports only a few return converters:"
msgstr ""
"Actualmente, Argument Clinic sólo admite unos pocos conversores de retorno:"

#: ../../howto/clinic.rst:1074
msgid ""
"None of these take parameters.  For the first three, return -1 to indicate "
"error.  For ``DecodeFSDefault``, the return type is ``const char *``; return "
"a ``NULL`` pointer to indicate an error."
msgstr ""
"Ninguna de ellas toma parámetros.  Para los tres primeros, devuelva -1 para "
"indicar error.  Para ``DecodeFSDefault``, el tipo de retorno es ``const char "
"*``; devuelve un puntero ``NULL`` para indicar un error."

#: ../../howto/clinic.rst:1078
msgid ""
"(There's also an experimental ``NoneType`` converter, which lets you return "
"``Py_None`` on success or ``NULL`` on failure, without having to increment "
"the reference count on ``Py_None``.  I'm not sure it adds enough clarity to "
"be worth using.)"
msgstr ""
"(También existe un conversor experimental ``NoneType``, que permite devolver "
"``Py_None`` en caso de éxito o ``NULL`` en caso de fallo, sin tener que "
"incrementar el recuento de referencias en ``Py_None``.  No estoy seguro de "
"que añada suficiente claridad como para que merezca la pena usarlo)."

#: ../../howto/clinic.rst:1083
msgid ""
"To see all the return converters Argument Clinic supports, along with their "
"parameters (if any), just run ``Tools/clinic/clinic.py --converters`` for "
"the full list."
msgstr ""
"Para ver todos los conversores de retorno que admite Argument Clinic, junto "
"con sus parámetros (si los hay), basta con ejecutar ``Tools/clinic/clinic.py "
"--converters`` para obtener la lista completa."

#: ../../howto/clinic.rst:1089
msgid "Cloning existing functions"
msgstr "Clonación de funciones existentes"

#: ../../howto/clinic.rst:1091
msgid ""
"If you have a number of functions that look similar, you may be able to use "
"Clinic's \"clone\" feature.  When you clone an existing function, you reuse:"
msgstr ""
"Si tiene varias funciones parecidas, puede utilizar la función \"clonar\" de "
"Clinic.  Cuando clonas una función existente, la reutilizas:"

#: ../../howto/clinic.rst:1095
msgid "its parameters, including"
msgstr "sus parámetros, incluidos"

#: ../../howto/clinic.rst:1097
msgid "their names,"
msgstr "sus nombres,"

#: ../../howto/clinic.rst:1099
msgid "their converters, with all parameters,"
msgstr "sus convertidores, con todos los parámetros,"

#: ../../howto/clinic.rst:1101
msgid "their default values,"
msgstr "sus valores por defecto,"

#: ../../howto/clinic.rst:1103
msgid "their per-parameter docstrings,"
msgstr "sus docstrings por parámetro,"

#: ../../howto/clinic.rst:1105
msgid ""
"their *kind* (whether they're positional only, positional or keyword, or "
"keyword only), and"
msgstr ""
"su *tipo* (si son sólo posicionales, posicionales o de palabra clave, o sólo "
"de palabra clave), y"

#: ../../howto/clinic.rst:1108
msgid "its return converter."
msgstr "su convertidor de retorno."

#: ../../howto/clinic.rst:1110
msgid ""
"The only thing not copied from the original function is its docstring; the "
"syntax allows you to specify a new docstring."
msgstr ""
"Lo único que no se copia de la función original es su docstring; la sintaxis "
"permite especificar un nuevo docstring."

#: ../../howto/clinic.rst:1113
msgid "Here's the syntax for cloning a function::"
msgstr "Esta es la sintaxis para clonar una función::"

#: ../../howto/clinic.rst:1121
msgid ""
"(The functions can be in different modules or classes.  I wrote ``module."
"class`` in the sample just to illustrate that you must use the full path to "
"*both* functions.)"
msgstr ""
"(Las funciones pueden estar en diferentes módulos o clases.  Escribí "
"``module.class`` en el ejemplo solo para ilustrar que debe utilizar la ruta "
"completa a *ambas* funciones)."

#: ../../howto/clinic.rst:1125
msgid ""
"Sorry, there's no syntax for partially cloning a function, or cloning a "
"function then modifying it.  Cloning is an all-or nothing proposition."
msgstr ""
"Lo siento, no hay sintaxis para clonar parcialmente una función, o clonar "
"una función y luego modificarla.  La clonación es una proposición de todo o "
"nada."

#: ../../howto/clinic.rst:1128
msgid ""
"Also, the function you are cloning from must have been previously defined in "
"the current file."
msgstr ""
"Además, la función de la que se clona debe haber sido definida previamente "
"en el archivo actual."

#: ../../howto/clinic.rst:1132
msgid "Calling Python code"
msgstr "Llamada al código Python"

#: ../../howto/clinic.rst:1134
msgid ""
"The rest of the advanced topics require you to write Python code which lives "
"inside your C file and modifies Argument Clinic's runtime state.  This is "
"simple: you simply define a Python block."
msgstr ""
"El resto de los temas avanzados requieren que escribas código Python que "
"viva dentro de tu archivo C y modifique el estado en tiempo de ejecución de "
"Argument Clinic.  Esto es sencillo: basta con definir un bloque Python."

#: ../../howto/clinic.rst:1138
msgid ""
"A Python block uses different delimiter lines than an Argument Clinic "
"function block.  It looks like this::"
msgstr ""
"Un bloque Python utiliza líneas delimitadoras diferentes a las de un bloque "
"de función Argument Clinic.  Su aspecto es el siguiente::"

#: ../../howto/clinic.rst:1145
msgid ""
"All the code inside the Python block is executed at the time it's parsed.  "
"All text written to stdout inside the block is redirected into the "
"\"output\" after the block."
msgstr ""
"Todo el código dentro del bloque Python se ejecuta en el momento en que se "
"analiza.  Todo el texto escrito en stdout dentro del bloque se redirige a la "
"\"output\" después del bloque."

#: ../../howto/clinic.rst:1149
msgid ""
"As an example, here's a Python block that adds a static integer variable to "
"the C code::"
msgstr ""
"Como ejemplo, he aquí un bloque Python que añade una variable entera "
"estática al código C::"

#: ../../howto/clinic.rst:1160
msgid "Using a \"self converter\""
msgstr "Utilizar un \"autoconversor\""

#: ../../howto/clinic.rst:1162
msgid ""
"Argument Clinic automatically adds a \"self\" parameter for you using a "
"default converter.  It automatically sets the ``type`` of this parameter to "
"the \"pointer to an instance\" you specified when you declared the type.  "
"However, you can override Argument Clinic's converter and specify one "
"yourself. Just add your own ``self`` parameter as the first parameter in a "
"block, and ensure that its converter is an instance of ``self_converter`` or "
"a subclass thereof."
msgstr ""
"Argument Clinic añade automáticamente un parámetro \"self\" utilizando un "
"conversor predeterminado.  Establece automáticamente el ``type`` de este "
"parámetro al \"puntero a una instancia\" que especificaste cuando declaraste "
"el tipo.  Sin embargo, puedes anular el conversor de Argument Clinic y "
"especificar uno tú mismo. Sólo tienes que añadir tu propio parámetro "
"``self`` como primer parámetro de un bloque y asegurarte de que su conversor "
"es una instancia de ``self_converter`` o una subclase del mismo."

#: ../../howto/clinic.rst:1171
msgid ""
"What's the point?  This lets you override the type of ``self``, or give it a "
"different default name."
msgstr ""
"¿Para qué sirve?  Esto le permite anular el tipo de ``self``, o darle un "
"nombre por defecto diferente."

#: ../../howto/clinic.rst:1174
msgid ""
"How do you specify the custom type you want to cast ``self`` to? If you only "
"have one or two functions with the same type for ``self``, you can directly "
"use Argument Clinic's existing ``self`` converter, passing in the type you "
"want to use as the ``type`` parameter::"
msgstr ""
"¿Cómo especifica el tipo personalizado al que desea convertir ``self``? Si "
"sólo tiene una o dos funciones con el mismo tipo para ``self``, puede "
"utilizar directamente el convertidor ``self`` existente en Argument Clinic, "
"pasando el tipo que desea utilizar como parámetro ``type``::"

#: ../../howto/clinic.rst:1190
msgid ""
"On the other hand, if you have a lot of functions that will use the same "
"type for ``self``, it's best to create your own converter, subclassing "
"``self_converter`` but overwriting the ``type`` member::"
msgstr ""
"Por otro lado, si tiene muchas funciones que utilizarán el mismo tipo para "
"``self``, es mejor crear su propio convertidor, subclasificando "
"``self_converter`` pero sobrescribiendo el miembro ``type``::"

#: ../../howto/clinic.rst:1212
msgid "Using a \"defining class\" converter"
msgstr "Utilizar un convertidor de \"clase definitoria\""

#: ../../howto/clinic.rst:1214
msgid ""
"Argument Clinic facilitates gaining access to the defining class of a "
"method. This is useful for :ref:`heap type <heap-types>` methods that need "
"to fetch module level state.  Use :c:func:`PyType_FromModuleAndSpec` to "
"associate a new heap type with a module.  You can now use :c:func:"
"`PyType_GetModuleState` on the defining class to fetch the module state, for "
"example from a module method."
msgstr ""
"Argument Clinic facilita el acceso a la clase definidora de un método. Esto "
"es útil para los métodos :ref:`heap type <heap-types>` que necesitan obtener "
"el estado a nivel de módulo.  Utilice :c:func:`PyType_FromModuleAndSpec` "
"para asociar un nuevo tipo de montón a un módulo.  Ahora puede utilizar :c:"
"func:`PyType_GetModuleState` en la clase definidora para obtener el estado "
"del módulo, por ejemplo, de un método del módulo."

#: ../../howto/clinic.rst:1220
msgid ""
"Example from ``Modules/zlibmodule.c``.  First, ``defining_class`` is added "
"to the clinic input::"
msgstr ""
"Ejemplo de ``Modules/zlibmodule.c``.  En primer lugar, ``defining_class`` se "
"añade a la entrada de la clínica::"

#: ../../howto/clinic.rst:1232
msgid ""
"After running the Argument Clinic tool, the following function signature is "
"generated::"
msgstr ""
"Tras ejecutar la herramienta Argument Clinic, se genera la siguiente firma "
"de función::"

#: ../../howto/clinic.rst:1242
msgid ""
"The following code can now use ``PyType_GetModuleState(cls)`` to fetch the "
"module state::"
msgstr ""
"El siguiente código puede ahora utilizar ``PyType_GetModuleState(cls)`` para "
"obtener el estado del módulo::"

#: ../../howto/clinic.rst:1248
msgid ""
"Each method may only have one argument using this converter, and it must "
"appear after ``self``, or, if ``self`` is not used, as the first argument.  "
"The argument will be of type ``PyTypeObject *``.  The argument will not "
"appear in the ``__text_signature__``."
msgstr ""
"Cada método sólo puede tener un argumento utilizando este convertidor, y "
"debe aparecer después de ``self``, o, si no se utiliza ``self``, como primer "
"argumento.  El argumento será del tipo ``PyTypeObject *``.  El argumento no "
"aparecerá en ``__text_signature__``."

#: ../../howto/clinic.rst:1253
msgid ""
"The ``defining_class`` converter is not compatible with ``__init__`` and "
"``__new__`` methods, which cannot use the ``METH_METHOD`` convention."
msgstr ""
"El conversor ``defining_class`` no es compatible con los métodos "
"``__init__`` y ``__new__``, que no pueden utilizar la convención "
"``METH_METHOD``."

#: ../../howto/clinic.rst:1256
msgid ""
"It is not possible to use ``defining_class`` with slot methods.  In order to "
"fetch the module state from such methods, use ``_PyType_GetModuleByDef`` to "
"look up the module and then :c:func:`PyModule_GetState` to fetch the module "
"state.  Example from the ``setattro`` slot method in ``Modules/_threadmodule."
"c``::"
msgstr ""
"No es posible utilizar ``defining_class`` con métodos de ranura.  Para "
"obtener el estado del módulo a partir de dichos métodos, utilice "
"``_PyType_GetModuleByDef`` para buscar el módulo y, a continuación, :c:func:"
"`PyModule_GetState` para obtener el estado del módulo.  Ejemplo del método "
"de ranura ``setattro`` en ``Modules/_threadmodule.c``::"

#: ../../howto/clinic.rst:1271
msgid "See also :pep:`573`."
msgstr "Ver también :pep:`573`."

#: ../../howto/clinic.rst:1275
msgid "Writing a custom converter"
msgstr "Escribir un conversor personalizado"

#: ../../howto/clinic.rst:1277
msgid ""
"As we hinted at in the previous section... you can write your own "
"converters! A converter is simply a Python class that inherits from "
"``CConverter``. The main purpose of a custom converter is if you have a "
"parameter using the ``O&`` format unit—parsing this parameter means calling "
"a :c:func:`PyArg_ParseTuple` \"converter function\"."
msgstr ""
"Como insinuamos en la sección anterior... ¡puedes escribir tus propios "
"conversores! Un conversor es simplemente una clase Python que hereda de "
"``CConverter``. El principal propósito de un conversor personalizado es si "
"tienes un parámetro que utiliza el formato ``O&`` parsear por unidades este "
"parámetro significa llamar a una \"función conversora\" de :c:func:"
"`PyArg_ParseTuple`."

#: ../../howto/clinic.rst:1283
msgid ""
"Your converter class should be named ``*something*_converter``. If the name "
"follows this convention, then your converter class will be automatically "
"registered with Argument Clinic; its name will be the name of your class "
"with the ``_converter`` suffix stripped off.  (This is accomplished with a "
"metaclass.)"
msgstr ""
"Su clase convertidora debe llamarse ``*something*_converter``. Si el nombre "
"sigue esta convención, entonces tu clase convertidora se registrará "
"automáticamente en Argument Clinic; su nombre será el nombre de tu clase con "
"el sufijo ``_converter`` eliminado.  (Esto se consigue con una metaclase)."

#: ../../howto/clinic.rst:1289
msgid ""
"You shouldn't subclass ``CConverter.__init__``.  Instead, you should write a "
"``converter_init()`` function.  ``converter_init()`` always accepts a "
"``self`` parameter; after that, all additional parameters *must* be keyword-"
"only.  Any arguments passed in to the converter in Argument Clinic will be "
"passed along to your ``converter_init()``."
msgstr ""
"No debería subclasificar ``CConverter.__init__``.  En su lugar, debe "
"escribir una función ``converter_init()``. ``converter_init()`` siempre "
"acepta un parámetro ``self``; después de eso, todos los parámetros "
"adicionales *deben* ser sólo de palabra clave.  Todos los argumentos que se "
"pasen al conversor en Argument Clinic se pasarán a su ``converter_init()``."

#: ../../howto/clinic.rst:1296
msgid ""
"There are some additional members of ``CConverter`` you may wish to specify "
"in your subclass.  Here's the current list:"
msgstr ""
"Hay algunos miembros adicionales de ``CConverter`` que tal vez desee "
"especificar en su subclase.  Aquí está la lista actual:"

#: ../../howto/clinic.rst:1300
msgid ""
"The C type to use for this variable. ``type`` should be a Python string "
"specifying the type, e.g. ``int``. If this is a pointer type, the type "
"string should end with ``' *'``."
msgstr ""
"El tipo C que se utilizará para esta variable. ``type`` debe ser una cadena "
"Python que especifique el tipo, por ejemplo ``int``. Si se trata de un tipo "
"de puntero, la cadena de tipo debe terminar con ``' *'``."

#: ../../howto/clinic.rst:1306
msgid "``default``"
msgstr "``default``"

#: ../../howto/clinic.rst:1305
msgid ""
"The Python default value for this parameter, as a Python value. Or the magic "
"value ``unspecified`` if there is no default."
msgstr ""
"El valor por defecto de Python para este parámetro, como valor de Python. O "
"el valor mágico ``unspecified`` si no hay valor por defecto."

#: ../../howto/clinic.rst:1311
msgid "``py_default``"
msgstr "``py_default``"

#: ../../howto/clinic.rst:1309
msgid ""
"``default`` as it should appear in Python code, as a string. Or ``None`` if "
"there is no default."
msgstr ""
"``default`` como debería aparecer en el código Python, como una cadena. O "
"``None`` si no existe por defecto."

#: ../../howto/clinic.rst:1314
msgid ""
"``default`` as it should appear in C code, as a string. Or ``None`` if there "
"is no default."
msgstr ""
"``default`` como debería aparecer en código C, como una cadena. O ``None`` "
"si no existe por defecto."

#: ../../howto/clinic.rst:1327
msgid "``c_ignored_default``"
msgstr "``c_ignored_default``"

#: ../../howto/clinic.rst:1319
msgid ""
"The default value used to initialize the C variable when there is no "
"default, but not specifying a default may result in an \"uninitialized "
"variable\" warning.  This can easily happen when using option groups—"
"although properly written code will never actually use this value, the "
"variable does get passed in to the impl, and the C compiler will complain "
"about the \"use\" of the uninitialized value.  This value should always be a "
"non-empty string."
msgstr ""
"El valor por defecto utilizado para inicializar la variable C cuando no hay "
"un valor por defecto, pero no especificar un valor por defecto puede "
"resultar en una advertencia de \"variable no inicializada\".  Esto puede "
"ocurrir fácilmente cuando se utilizan grupos de opciones, aunque el código "
"escrito correctamente nunca utilizará este valor, la variable se pasa al "
"impl y el compilador de C se quejará del \"uso\" del valor no inicializado.  "
"Este valor debe ser siempre una cadena no vacía."

#: ../../howto/clinic.rst:1330
msgid "The name of the C converter function, as a string."
msgstr "El nombre de la función de conversión de C, como cadena."

#: ../../howto/clinic.rst:1335
msgid "``impl_by_reference``"
msgstr "``impl_by_reference``"

#: ../../howto/clinic.rst:1333
msgid ""
"A boolean value.  If true, Argument Clinic will add a ``&`` in front of the "
"name of the variable when passing it into the impl function."
msgstr ""
"Valor booleano.  Si es verdadero, Argument Clinic añadirá un ``&`` delante "
"del nombre de la variable cuando la pase a la función impl."

#: ../../howto/clinic.rst:1341
msgid "``parse_by_reference``"
msgstr "``parse_by_reference``"

#: ../../howto/clinic.rst:1338
msgid ""
"A boolean value.  If true, Argument Clinic will add a ``&`` in front of the "
"name of the variable when passing it into :c:func:`PyArg_ParseTuple`."
msgstr ""
"Valor booleano.  Si es verdadero, Argument Clinic añadirá un ``&`` delante "
"del nombre de la variable cuando la pase a :c:func:`PyArg_ParseTuple`."

#: ../../howto/clinic.rst:1343
msgid ""
"Here's the simplest example of a custom converter, from ``Modules/zlibmodule."
"c``::"
msgstr ""
"Este es el ejemplo más sencillo de conversor personalizado, de ``Modules/"
"zlibmodule.c``::"

#: ../../howto/clinic.rst:1354
msgid ""
"This block adds a converter to Argument Clinic named ``ssize_t``.  "
"Parameters declared as ``ssize_t`` will be declared as type :c:type:"
"`Py_ssize_t`, and will be parsed by the ``'O&'`` format unit, which will "
"call the ``ssize_t_converter`` converter function.  ``ssize_t`` variables "
"automatically support default values."
msgstr ""
"Este bloque añade un conversor a Argument Clinic denominado ``ssize_t``.  "
"Los parámetros declarados como ``ssize_t`` se declararán como tipo :c:type:"
"`Py_ssize_t`, y serán analizados por la unidad de formato ``'O&'``, que "
"llamará a la función del conversor ``ssize_t_converter``. Las variables "
"``ssize_t`` admiten automáticamente valores por defecto."

#: ../../howto/clinic.rst:1360
msgid ""
"More sophisticated custom converters can insert custom C code to handle "
"initialization and cleanup. You can see more examples of custom converters "
"in the CPython source tree; grep the C files for the string ``CConverter``."
msgstr ""
"Convertidores personalizados más sofisticados pueden insertar código C "
"personalizado para manejar la inicialización y limpieza. Puede ver más "
"ejemplos de convertidores personalizados en el árbol de fuentes de CPython; "
"busque en los archivos C la cadena ``CConverter``."

#: ../../howto/clinic.rst:1366
msgid "Writing a custom return converter"
msgstr "Escribir un convertidor de retorno personalizado"

#: ../../howto/clinic.rst:1368
msgid ""
"Writing a custom return converter is much like writing a custom converter.  "
"Except it's somewhat simpler, because return converters are themselves much "
"simpler."
msgstr ""
"Escribir un convertidor return personalizado es muy parecido a escribir un "
"convertidor personalizado.  Excepto que es algo más sencillo, porque los "
"convertidores de retorno son en sí mismos mucho más sencillos."

#: ../../howto/clinic.rst:1372
msgid ""
"Return converters must subclass ``CReturnConverter``. There are no examples "
"yet of custom return converters, because they are not widely used yet.  If "
"you wish to write your own return converter, please read ``Tools/clinic/"
"clinic.py``, specifically the implementation of ``CReturnConverter`` and all "
"its subclasses."
msgstr ""
"Los convertidores de retorno deben subclasificar ``CReturnConverter``. Aún "
"no hay ejemplos de convertidores de retorno personalizados, porque todavía "
"no se utilizan mucho.  Si desea escribir su propio convertidor de retorno, "
"por favor lea ``Tools/clinic/clinic.py``, específicamente la implementación "
"de ``CReturnConverter`` y todas sus subclases."

#: ../../howto/clinic.rst:1380
msgid "METH_O and METH_NOARGS"
msgstr "METH_O y METH_NOARGS"

#: ../../howto/clinic.rst:1382
msgid ""
"To convert a function using ``METH_O``, make sure the function's single "
"argument is using the ``object`` converter, and mark the arguments as "
"positional-only::"
msgstr ""
"Para convertir una función utilizando ``METH_O``, asegúrese de que el único "
"argumento de la función utiliza el conversor ``object``, y marque los "
"argumentos como sólo posicionales::"

#: ../../howto/clinic.rst:1394
msgid ""
"To convert a function using ``METH_NOARGS``, just don't specify any "
"arguments."
msgstr ""
"Para convertir una función utilizando ``METH_NOARGS``, basta con no "
"especificar ningún argumento."

#: ../../howto/clinic.rst:1397
msgid ""
"You can still use a self converter, a return converter, and specify a "
"``type`` argument to the object converter for ``METH_O``."
msgstr ""
"Puede seguir utilizando un autoconversor, un conversor de retorno y "
"especificar un argumento ``type`` al conversor de objetos para ``METH_O``."

#: ../../howto/clinic.rst:1401
msgid "tp_new and tp_init functions"
msgstr "tp_new y funciones tp_init"

#: ../../howto/clinic.rst:1403
msgid ""
"You can convert ``tp_new`` and ``tp_init`` functions.  Just name them "
"``__new__`` or ``__init__`` as appropriate.  Notes:"
msgstr ""
"Puede convertir las funciones ``tp_new`` y ``tp_init``.  Basta con "
"nombrarlas ``__new__`` o ``__init__`` según corresponda.  Notas:"

#: ../../howto/clinic.rst:1406
msgid ""
"The function name generated for ``__new__`` doesn't end in ``__new__`` like "
"it would by default.  It's just the name of the class, converted into a "
"valid C identifier."
msgstr ""
"El nombre de la función generado para ``__new__`` no termina en ``__new__`` "
"como lo haría por defecto.  Es sólo el nombre de la clase, convertido en un "
"identificador C válido."

#: ../../howto/clinic.rst:1410
msgid "No ``PyMethodDef`` ``#define`` is generated for these functions."
msgstr "No se genera ``PyMethodDef`` ``#define`` para estas funciones."

#: ../../howto/clinic.rst:1412
msgid "``__init__`` functions return ``int``, not ``PyObject *``."
msgstr "``__init__`` las funciones devuelven ``int``, no ``PyObject *``."

#: ../../howto/clinic.rst:1414
msgid "Use the docstring as the class docstring."
msgstr "Utiliza el docstring como docstring de la clase."

#: ../../howto/clinic.rst:1416
msgid ""
"Although ``__new__`` and ``__init__`` functions must always accept both the "
"``args`` and ``kwargs`` objects, when converting you may specify any "
"signature for these functions that you like. (If your function doesn't "
"support keywords, the parsing function generated will throw an exception if "
"it receives any.)"
msgstr ""
"Aunque las funciones ``__new__`` y ``__init__`` siempre deben aceptar los "
"objetos ``args`` y ``kwargs``, al convertir puede especificar cualquier "
"firma para estas funciones que desee. (Si su función no admite palabras "
"clave, la función de análisis sintáctico generada lanzará una excepción si "
"recibe alguna)."

#: ../../howto/clinic.rst:1423
msgid "Changing and redirecting Clinic's output"
msgstr "Modificar y redirigir la salida de Clinic"

#: ../../howto/clinic.rst:1425
msgid ""
"It can be inconvenient to have Clinic's output interspersed with your "
"conventional hand-edited C code.  Luckily, Clinic is configurable: you can "
"buffer up its output for printing later (or earlier!), or write its output "
"to a separate file.  You can also add a prefix or suffix to every line of "
"Clinic's generated output."
msgstr ""
"Puede ser incómodo tener la salida de Clinic entremezclada con tu código C "
"convencional editado a mano.  Por suerte, Clinic es configurable: puede "
"almacenar su salida para imprimirla más tarde (¡o antes!), o escribirla en "
"un archivo separado.  También puede añadir un prefijo o sufijo a cada línea "
"de la salida generada por Clinic."

#: ../../howto/clinic.rst:1431
msgid ""
"While changing Clinic's output in this manner can be a boon to readability, "
"it may result in Clinic code using types before they are defined, or your "
"code attempting to use Clinic-generated code before it is defined. These "
"problems can be easily solved by rearranging the declarations in your file, "
"or moving where Clinic's generated code goes.  (This is why the default "
"behavior of Clinic is to output everything into the current block; while "
"many people consider this hampers readability, it will never require "
"rearranging your code to fix definition-before-use problems.)"
msgstr ""
"Aunque cambiar la salida de Clinic de esta manera puede ser una ayuda para "
"la legibilidad, puede resultar en que el código de Clinic use tipos antes de "
"que estén definidos, o que tu código intente usar código generado por Clinic "
"antes de que esté definido. Estos problemas pueden resolverse fácilmente "
"reordenando las declaraciones en tu fichero, o moviendo el lugar donde va el "
"código generado por Clinic.  (Esta es la razón por la que el comportamiento "
"por defecto de Clinic es mostrar todo en el bloque actual; aunque mucha "
"gente considera que esto dificulta la legibilidad, nunca será necesario "
"reordenar tu código para solucionar problemas de definición-antes-de-uso)."

#: ../../howto/clinic.rst:1440
msgid "Let's start with defining some terminology:"
msgstr "Empecemos por definir algunos términos:"

#: ../../howto/clinic.rst:1467
msgid "*field*"
msgstr "*field*"

#: ../../howto/clinic.rst:1443
msgid ""
"A field, in this context, is a subsection of Clinic's output. For example, "
"the ``#define`` for the ``PyMethodDef`` structure is a field, called "
"``methoddef_define``.  Clinic has seven different fields it can output per "
"function definition:"
msgstr ""
"Un  field, en este contexto, es una subsección de la salida de Clinic. Por "
"ejemplo, el ``#define`` para la estructura ``PyMethodDef`` es un campo, "
"llamado ``methoddef_define``.  Clinic dispone de siete campos diferentes que "
"puede generar por definición de función:"

#: ../../howto/clinic.rst:1458
msgid ""
"All the names are of the form ``\"<a>_<b>\"``, where ``\"<a>\"`` is the "
"semantic object represented (the parsing function, the impl function, the "
"docstring, or the methoddef structure) and ``\"<b>\"`` represents what kind "
"of statement the field is.  Field names that end in ``\"_prototype\"`` "
"represent forward declarations of that thing, without the actual body/data "
"of the thing; field names that end in ``\"_definition\"`` represent the "
"actual definition of the thing, with the body/data of the thing.  "
"(``\"methoddef\"`` is special, it's the only one that ends with "
"``\"_define\"``, representing that it's a preprocessor #define.)"
msgstr ""
"Todos los nombres tienen la forma ``\"<a>_<b>\"``, donde ``\"<a>\"`` es el "
"objeto semántico representado (la función de análisis sintáctico, la función "
"impl, el docstring o la estructura methoddef) y ``\"<b>\"`` representa qué "
"tipo de declaración es el campo.  Los nombres de campo que terminan en "
"``\"_prototype\"`` representan declaraciones hacia adelante de esa cosa, sin "
"el cuerpo/datos reales de la cosa; los nombres de campo que terminan en "
"``\"_definition\"`` representan la definición real de la cosa, con el cuerpo/"
"datos de la cosa.  (``\"methoddef\"`` es especial, es el único que termina "
"en ``\"_define\"``, representando que es una #define del preprocesador)."

#: ../../howto/clinic.rst:1501
msgid "*destination*"
msgstr "*destination*"

#: ../../howto/clinic.rst:1470
msgid ""
"A destination is a place Clinic can write output to.  There are five built-"
"in destinations:"
msgstr ""
"Un destino es un lugar en el que Clinic puede escribir la salida.  Hay cinco "
"destinos incorporados:"

#: ../../howto/clinic.rst:1475 ../../howto/clinic.rst:1550
#: ../../howto/clinic.rst:1628
msgid "``block``"
msgstr "``block``"

#: ../../howto/clinic.rst:1474
msgid ""
"The default destination: printed in the output section of the current Clinic "
"block."
msgstr ""
"El destino por defecto: se imprime en la sección de salida del bloque de la "
"Clínica actual."

#: ../../howto/clinic.rst:1481 ../../howto/clinic.rst:1577
#: ../../howto/clinic.rst:1631
msgid "``buffer``"
msgstr "``buffer``"

#: ../../howto/clinic.rst:1478
msgid ""
"A text buffer where you can save text for later.  Text sent here is appended "
"to the end of any existing text.  It's an error to have any text left in the "
"buffer when Clinic finishes processing a file."
msgstr ""
"Un búfer de texto donde puedes guardar texto para más tarde.  El texto "
"enviado aquí se añade al final de cualquier texto existente.  Es un error "
"que quede texto en el búfer cuando Clinic termina de procesar un archivo."

#: ../../howto/clinic.rst:1492 ../../howto/clinic.rst:1563
#: ../../howto/clinic.rst:1657
msgid "``file``"
msgstr "``file``"

#: ../../howto/clinic.rst:1484
msgid ""
"A separate \"clinic file\" that will be created automatically by Clinic. The "
"filename chosen for the file is ``{basename}.clinic{extension}``, where "
"``basename`` and ``extension`` were assigned the output from ``os.path."
"splitext()`` run on the current file.  (Example: the ``file`` destination "
"for ``_pickle.c`` would be written to ``_pickle.clinic.c``.)"
msgstr ""
"Un \"archivo clínico\" independiente que será creado automáticamente por "
"Clinic. El nombre elegido para el archivo es ``{basename}.clinic{extension}"
"``, donde ``basename`` y ``extension`` se asignaron a la salida de ``os.path."
"splitext()`` ejecutada en el archivo actual.  (Ejemplo: el destino ``file`` "
"para ``_pickle.c`` se escribiría en ``_pickle.clinic.c``.)"

#: ../../howto/clinic.rst:1491
msgid ""
"**Important: When using a** ``file`` **destination, you** *must check in* "
"**the generated file!**"
msgstr ""
"**Importante: Cuando se utiliza un** ``file`` **destino, se** *debe "
"registrar* **el archivo generado!**"

#: ../../howto/clinic.rst:1497 ../../howto/clinic.rst:1590
#: ../../howto/clinic.rst:1661
msgid "``two-pass``"
msgstr "``two-pass``"

#: ../../howto/clinic.rst:1495
msgid ""
"A buffer like ``buffer``.  However, a two-pass buffer can only be dumped "
"once, and it prints out all text sent to it during all processing, even from "
"Clinic blocks *after* the dumping point."
msgstr ""
"Un búfer como ``buffer``. Sin embargo, un búfer de dos pasadas sólo puede "
"volcarse una vez, e imprime todo el texto que se le envía durante todo el "
"procesamiento, incluso de los bloques de la Clínica *después* del punto de "
"volcado."

#: ../../howto/clinic.rst:1501 ../../howto/clinic.rst:1624
msgid "``suppress``"
msgstr "``suppress``"

#: ../../howto/clinic.rst:1500
msgid "The text is suppressed—thrown away."
msgstr "El texto se suprime, se desecha."

#: ../../howto/clinic.rst:1503
msgid "Clinic defines five new directives that let you reconfigure its output."
msgstr ""
"Clinic define cinco nuevas directivas que permiten reconfigurar su salida."

#: ../../howto/clinic.rst:1505
msgid "The first new directive is ``dump``:"
msgstr "La primera directiva nueva es ``dump``:"

#: ../../howto/clinic.rst:1511
msgid ""
"This dumps the current contents of the named destination into the output of "
"the current block, and empties it.  This only works with ``buffer`` and "
"``two-pass`` destinations."
msgstr ""
"Vuelca el contenido actual del destino indicado en la salida del bloque "
"actual y lo vacía.  Sólo funciona con los destinos ``buffer`` y ``two-pass``."

#: ../../howto/clinic.rst:1515
msgid ""
"The second new directive is ``output``.  The most basic form of ``output`` "
"is like this:"
msgstr ""
"La segunda directiva nueva es ``output``.  La forma más básica de ``output`` "
"es la siguiente:"

#: ../../howto/clinic.rst:1522
msgid ""
"This tells Clinic to output *field* to *destination*.  ``output`` also "
"supports a special meta-destination, called ``everything``, which tells "
"Clinic to output *all* fields to that *destination*."
msgstr ""
"Esto indica a Clinic que envíe *campo* a *destino*. ``output`` también "
"admite un meta-destino especial, llamado ``everything``, que indica a Clinic "
"que envíe *todos* los campos a ese *destino*."

#: ../../howto/clinic.rst:1526
msgid "``output`` has a number of other functions:"
msgstr "``output`` tiene otras funciones:"

#: ../../howto/clinic.rst:1535
msgid ""
"``output push`` and ``output pop`` allow you to push and pop configurations "
"on an internal configuration stack, so that you can temporarily modify the "
"output configuration, then easily restore the previous configuration.  "
"Simply push before your change to save the current configuration, then pop "
"when you wish to restore the previous configuration."
msgstr ""
"``output push`` y ``output pop`` le permiten insertar y extraer "
"configuraciones en una pila de configuración interna, de forma que pueda "
"modificar temporalmente la configuración de salida y, a continuación, "
"restaurar fácilmente la configuración anterior.  Basta con pulsar antes del "
"cambio para guardar la configuración actual y pulsar cuando se desee "
"restaurar la configuración anterior."

#: ../../howto/clinic.rst:1542
msgid ""
"``output preset`` sets Clinic's output to one of several built-in preset "
"configurations, as follows:"
msgstr ""
"``output preset`` ajusta la salida del Clinic a una de las configuraciones "
"preestablecidas, como se indica a continuación:"

#: ../../howto/clinic.rst:1546
msgid ""
"Clinic's original starting configuration.  Writes everything immediately "
"after the input block."
msgstr ""
"Configuración inicial original de la clínica.  Escribe todo inmediatamente "
"después del bloque de entrada."

#: ../../howto/clinic.rst:1549
msgid ""
"Suppress the ``parser_prototype`` and ``docstring_prototype``, write "
"everything else to ``block``."
msgstr ""
"Suprima ``parser_prototype`` y ``docstring_prototype``, escriba todo lo "
"demás en ``block``."

#: ../../howto/clinic.rst:1553
msgid ""
"Designed to write everything to the \"clinic file\" that it can. You then "
"``#include`` this file near the top of your file. You may need to rearrange "
"your file to make this work, though usually this just means creating forward "
"declarations for various ``typedef`` and ``PyTypeObject`` definitions."
msgstr ""
"Diseñado para escribir todo lo que pueda en el \"archivo de la clínica\". "
"Entonces ``#include`` este archivo cerca de la parte superior de su archivo. "
"Es posible que tenga que reorganizar su archivo para que esto funcione, "
"aunque por lo general esto sólo significa la creación de declaraciones hacia "
"adelante para varias definiciones ``typedef`` y ``PyTypeObject``."

#: ../../howto/clinic.rst:1559
msgid ""
"Suppress the ``parser_prototype`` and ``docstring_prototype``, write the "
"``impl_definition`` to ``block``, and write everything else to ``file``."
msgstr ""
"Suprima ``parser_prototype`` y ``docstring_prototype``, escriba "
"``impl_definition`` en ``block``, y escriba todo lo demás en ``file``."

#: ../../howto/clinic.rst:1563
msgid "The default filename is ``\"{dirname}/clinic/{basename}.h\"``."
msgstr ""
"El nombre de archivo por defecto es ``\"{dirname}/clinic/{basename}.h\"``."

#: ../../howto/clinic.rst:1566
msgid ""
"Save up most of the output from Clinic, to be written into your file near "
"the end.  For Python files implementing modules or builtin types, it's "
"recommended that you dump the buffer just above the static structures for "
"your module or builtin type; these are normally very near the end.  Using "
"``buffer`` may require even more editing than ``file``, if your file has "
"static ``PyMethodDef`` arrays defined in the middle of the file."
msgstr ""
"Guarda la mayor parte de la salida de Clinic, para escribirla en tu fichero "
"cerca del final.  Para archivos Python que implementen módulos o tipos "
"incorporados, se recomienda que vuelque el buffer justo encima de las "
"estructuras estáticas para su módulo o tipo incorporado; éstas están "
"normalmente muy cerca del final.  Usar ``buffer`` puede requerir incluso más "
"edición que ``file``, si tu archivo tiene arrays estáticos ``PyMethodDef`` "
"definidos en medio del archivo."

#: ../../howto/clinic.rst:1575
msgid ""
"Suppress the ``parser_prototype``, ``impl_prototype``, and "
"``docstring_prototype``, write the ``impl_definition`` to ``block``, and "
"write everything else to ``file``."
msgstr ""
"Suprima ``parser_prototype``, ``impl_prototype``, y ``docstring_prototype``, "
"escriba ``impl_definition`` en ``block``, y escriba todo lo demás en "
"``file``."

#: ../../howto/clinic.rst:1580
msgid ""
"Similar to the ``buffer`` preset, but writes forward declarations to the "
"``two-pass`` buffer, and definitions to the ``buffer``. This is similar to "
"the ``buffer`` preset, but may require less editing than ``buffer``.  Dump "
"the ``two-pass`` buffer near the top of your file, and dump the ``buffer`` "
"near the end just like you would when using the ``buffer`` preset."
msgstr ""
"Similar al preajuste ``buffer``, pero escribe las declaraciones hacia "
"adelante en el búfer ``two-pass``, y las definiciones en ``buffer``. Es "
"similar al preajuste ``buffer``, pero puede requerir menos edición que "
"``buffer``. Vuelca el búfer ``two-pass`` cerca de la parte superior de su "
"archivo, y vuelca el ``buffer`` cerca del final tal como lo haría cuando "
"utiliza el preajuste ``buffer``."

#: ../../howto/clinic.rst:1587
msgid ""
"Suppresses the ``impl_prototype``, write the ``impl_definition`` to "
"``block``, write ``docstring_prototype``, ``methoddef_define``, and "
"``parser_prototype`` to ``two-pass``, write everything else to ``buffer``."
msgstr ""
"Suprime el ``impl_prototype``, escribe el ``impl_definition`` en ``block``, "
"escribe ``docstring_prototype``, ``methoddef_define``, y "
"``parser_prototype`` en ``two-pass``, escribe todo lo demás en ``buffer``."

#: ../../howto/clinic.rst:1601
msgid "``partial-buffer``"
msgstr "``partial-buffer``"

#: ../../howto/clinic.rst:1593
msgid ""
"Similar to the ``buffer`` preset, but writes more things to ``block``, only "
"writing the really big chunks of generated code to ``buffer``. This avoids "
"the definition-before-use problem of ``buffer`` completely, at the small "
"cost of having slightly more stuff in the block's output. Dump the "
"``buffer`` near the end, just like you would when using the ``buffer`` "
"preset."
msgstr ""
"Similar al preajuste ``buffer``, pero escribe más cosas en ``block``, "
"escribiendo sólo los trozos realmente grandes de código generado en "
"``buffer``. Esto evita completamente el problema de definición antes de uso "
"de ``buffer``, con el pequeño coste de tener un poco más de cosas en la "
"salida del bloque. Descargue ``buffer`` cerca del final, como haría con el "
"preajuste ``buffer``."

#: ../../howto/clinic.rst:1600
msgid ""
"Suppresses the ``impl_prototype``, write the ``docstring_definition`` and "
"``parser_definition`` to ``buffer``, write everything else to ``block``."
msgstr ""
"Suprime el ``impl_prototype``, escribe el ``docstring_definition`` y "
"``parser_definition`` en ``buffer``, escribe todo lo demás en ``block``."

#: ../../howto/clinic.rst:1603
msgid "The third new directive is ``destination``:"
msgstr "La tercera nueva directiva es ``destination``:"

#: ../../howto/clinic.rst:1609
msgid "This performs an operation on the destination named ``name``."
msgstr "Esto realiza una operación en el destino llamado ``name``."

#: ../../howto/clinic.rst:1611
msgid "There are two defined subcommands: ``new`` and ``clear``."
msgstr "Hay dos subcomandos definidos: ``new`` y ``clear``."

#: ../../howto/clinic.rst:1613
msgid "The ``new`` subcommand works like this:"
msgstr "El subcomando ``new`` funciona así:"

#: ../../howto/clinic.rst:1619
msgid ""
"This creates a new destination with name ``<name>`` and type ``<type>``."
msgstr ""
"Esto crea un nuevo destino con el nombre ``<name>`` y el tipo ``<type>``."

#: ../../howto/clinic.rst:1621
msgid "There are five destination types:"
msgstr "Existen cinco tipos de destino:"

#: ../../howto/clinic.rst:1624
msgid "Throws the text away."
msgstr "Tira el texto."

#: ../../howto/clinic.rst:1627
msgid ""
"Writes the text to the current block.  This is what Clinic originally did."
msgstr ""
"Escribe el texto en el bloque actual.  Esto es lo que Clinic hacía "
"originalmente."

#: ../../howto/clinic.rst:1631
msgid "A simple text buffer, like the \"buffer\" builtin destination above."
msgstr ""
"Un simple búfer de texto, como el destino \"buffer\" incorporado más arriba."

#: ../../howto/clinic.rst:1634
msgid ""
"A text file.  The file destination takes an extra argument, a template to "
"use for building the filename, like so:"
msgstr ""
"Un archivo de texto.  El destino del fichero toma un argumento extra, una "
"plantilla a usar para construir el nombre del fichero, así:"

#: ../../howto/clinic.rst:1637
msgid "destination <name> new <type> <file_template>"
msgstr "destino <name> nuevo <type> <file_template>"

#: ../../howto/clinic.rst:1639
msgid ""
"The template can use three strings internally that will be replaced by bits "
"of the filename:"
msgstr ""
"La plantilla puede utilizar internamente tres cadenas que serán sustituidas "
"por bits del nombre de archivo:"

#: ../../howto/clinic.rst:1642
msgid "{path}"
msgstr "{path}"

#: ../../howto/clinic.rst:1643
msgid "The full path to the file, including directory and full filename."
msgstr ""
"La ruta completa al archivo, incluyendo el directorio y el nombre completo "
"del archivo."

#: ../../howto/clinic.rst:1644
msgid "{dirname}"
msgstr "{dirname}"

#: ../../howto/clinic.rst:1645
msgid "The name of the directory the file is in."
msgstr "El nombre del directorio en el que se encuentra el archivo."

#: ../../howto/clinic.rst:1646
msgid "{basename}"
msgstr "{basename}"

#: ../../howto/clinic.rst:1647
msgid "Just the name of the file, not including the directory."
msgstr "Sólo el nombre del archivo, sin incluir el directorio."

#: ../../howto/clinic.rst:1649
msgid "{basename_root}"
msgstr "{basename_root}"

#: ../../howto/clinic.rst:1649
msgid ""
"Basename with the extension clipped off (everything up to but not including "
"the last '.')."
msgstr ""
"Nombre base con la extensión recortada (todo hasta el último '.', pero sin "
"incluirlo)."

#: ../../howto/clinic.rst:1653
msgid "{basename_extension}"
msgstr "{basename_extension}"

#: ../../howto/clinic.rst:1652
msgid ""
"The last '.' and everything after it.  If the basename does not contain a "
"period, this will be the empty string."
msgstr ""
"El último '.' y todo lo que le sigue.  Si el nombre base no contiene un "
"punto, será la cadena vacía."

#: ../../howto/clinic.rst:1655
msgid ""
"If there are no periods in the filename, {basename} and {filename} are the "
"same, and {extension} is empty.  \"{basename}{extension}\" is always exactly "
"the same as \"{filename}\".\""
msgstr ""
"Si no hay puntos en el nombre del archivo, {basename} y {filename} son "
"iguales, y {extension} está vacío.  \"{basename}{extension} \" es siempre "
"exactamente igual que \"{filename}\".\""

#: ../../howto/clinic.rst:1660
msgid "A two-pass buffer, like the \"two-pass\" builtin destination above."
msgstr ""
"Un búfer de dos pasos, como el destino incorporado \"two-pass\" anterior."

#: ../../howto/clinic.rst:1663
msgid "The ``clear`` subcommand works like this:"
msgstr "El subcomando ``clear`` funciona así:"

#: ../../howto/clinic.rst:1669
msgid ""
"It removes all the accumulated text up to this point in the destination. (I "
"don't know what you'd need this for, but I thought maybe it'd be useful "
"while someone's experimenting.)"
msgstr ""
"Elimina todo el texto acumulado hasta este punto en el destino. (No sé para "
"qué necesitarías esto, pero pensé que quizá sería útil mientras alguien "
"experimenta)."

#: ../../howto/clinic.rst:1673
msgid "The fourth new directive is ``set``:"
msgstr "La cuarta nueva directiva es ``set``:"

#: ../../howto/clinic.rst:1680
msgid ""
"``set`` lets you set two internal variables in Clinic. ``line_prefix`` is a "
"string that will be prepended to every line of Clinic's output; "
"``line_suffix`` is a string that will be appended to every line of Clinic's "
"output."
msgstr ""
"``set`` permite establecer dos variables internas en Clinic. ``line_prefix`` "
"es una cadena que se antepondrá a cada línea de la salida de Clinic; "
"``line_suffix`` es una cadena que se añadirá a cada línea de la salida de "
"Clinic."

#: ../../howto/clinic.rst:1684
msgid "Both of these support two format strings:"
msgstr "Ambos admiten dos cadenas de formato:"

#: ../../howto/clinic.rst:1687
msgid "``{block comment start}``"
msgstr "``{block comment start}``"

#: ../../howto/clinic.rst:1687
msgid ""
"Turns into the string ``/*``, the start-comment text sequence for C files."
msgstr ""
"Convierte en la cadena ``/*``, la secuencia de texto de inicio-comentario "
"para archivos C."

#: ../../howto/clinic.rst:1690
msgid "``{block comment end}``"
msgstr "``{block comment end}``"

#: ../../howto/clinic.rst:1690
msgid ""
"Turns into the string ``*/``, the end-comment text sequence for C files."
msgstr ""
"Convierte en la cadena ``*/``, la secuencia de texto de fin de comentario "
"para archivos C."

#: ../../howto/clinic.rst:1692
msgid ""
"The final new directive is one you shouldn't need to use directly, called "
"``preserve``:"
msgstr ""
"La última directiva nueva es una que no debería tener que utilizar "
"directamente, denominada ``preserve``:"

#: ../../howto/clinic.rst:1699
msgid ""
"This tells Clinic that the current contents of the output should be kept, "
"unmodified. This is used internally by Clinic when dumping output into "
"``file`` files; wrapping it in a Clinic block lets Clinic use its existing "
"checksum functionality to ensure the file was not modified by hand before it "
"gets overwritten."
msgstr ""
"Indica a Clinic que el contenido actual de la salida debe mantenerse sin "
"modificaciones. Esto es utilizado internamente por Clinic cuando vuelca la "
"salida en archivos ``file``; envolverlo en un bloque de Clinic permite a "
"Clinic utilizar su funcionalidad de suma de comprobación existente para "
"asegurarse de que el archivo no fue modificado a mano antes de que se "
"sobrescriba."

#: ../../howto/clinic.rst:1706
msgid "The #ifdef trick"
msgstr "El truco #ifdef"

#: ../../howto/clinic.rst:1708
msgid ""
"If you're converting a function that isn't available on all platforms, "
"there's a trick you can use to make life a little easier.  The existing code "
"probably looks like this::"
msgstr ""
"Si estás convirtiendo una función que no está disponible en todas las "
"plataformas, hay un truco que puedes utilizar para hacerte la vida un poco "
"más fácil.  El código existente probablemente se parece a esto::"

#: ../../howto/clinic.rst:1719
msgid ""
"And then in the ``PyMethodDef`` structure at the bottom the existing code "
"will have:"
msgstr ""
"Y luego en la estructura ``PyMethodDef`` en la parte inferior el código "
"existente tendrá:"

#: ../../howto/clinic.rst:1728
msgid ""
"In this scenario, you should enclose the body of your impl function inside "
"the ``#ifdef``, like so::"
msgstr ""
"En este caso, debe encerrar el cuerpo de la función impl dentro de "
"``#ifdef``, de la siguiente manera::"

#: ../../howto/clinic.rst:1742
msgid ""
"Then, remove those three lines from the ``PyMethodDef`` structure, replacing "
"them with the macro Argument Clinic generated:"
msgstr ""
"A continuación, elimine esas tres líneas de la estructura ``PyMethodDef``, "
"sustituyéndolas por la macro Argument Clinic generada:"

#: ../../howto/clinic.rst:1749
msgid ""
"(You can find the real name for this macro inside the generated code. Or you "
"can calculate it yourself: it's the name of your function as defined on the "
"first line of your block, but with periods changed to underscores, "
"uppercased, and ``\"_METHODDEF\"`` added to the end.)"
msgstr ""
"(Puede encontrar el nombre real de esta macro dentro del código generado. O "
"puedes calcularlo tú mismo: es el nombre de tu función tal y como se define "
"en la primera línea de tu bloque, pero con los puntos cambiados por guiones "
"bajos, en mayúsculas y añadiendo ``\"_METHODDEF\"`` al final)."

#: ../../howto/clinic.rst:1754
msgid ""
"Perhaps you're wondering: what if ``HAVE_FUNCTIONNAME`` isn't defined? The "
"``MODULE_FUNCTIONNAME_METHODDEF`` macro won't be defined either!"
msgstr ""
"Tal vez se pregunte: ¿y si ``HAVE_FUNCTIONNAME`` no está definida? La macro "
"``MODULE_FUNCTIONNAME_METHODDEF`` tampoco estará definida."

#: ../../howto/clinic.rst:1757
msgid ""
"Here's where Argument Clinic gets very clever.  It actually detects that the "
"Argument Clinic block might be deactivated by the ``#ifdef``.  When that "
"happens, it generates a little extra code that looks like this::"
msgstr ""
"Aquí es donde Argument Clinic se vuelve muy inteligente.  De hecho, detecta "
"que el bloque Argument Clinic podría estar desactivado por el ``#ifdef``. "
"Cuando eso sucede, genera un poco de código extra que se parece a esto::"

#: ../../howto/clinic.rst:1765
msgid ""
"That means the macro always works.  If the function is defined, this turns "
"into the correct structure, including the trailing comma.  If the function "
"is undefined, this turns into nothing."
msgstr ""
"Esto significa que la macro siempre funciona.  Si la función está definida, "
"se convierte en la estructura correcta, incluida la coma final.  Si la "
"función no está definida, se convierte en nada."

#: ../../howto/clinic.rst:1769
msgid ""
"However, this causes one ticklish problem: where should Argument Clinic put "
"this extra code when using the \"block\" output preset?  It can't go in the "
"output block, because that could be deactivated by the ``#ifdef``.  (That's "
"the whole point!)"
msgstr ""
"Sin embargo, esto causa un problema delicado: ¿dónde debe poner Argument "
"Clinic este código extra cuando se utiliza el preajuste de salida "
"\"bloque\"?  No puede ir en el bloque de salida, porque podría ser "
"desactivado por ``#ifdef``. (¡De eso se trata!)"

#: ../../howto/clinic.rst:1773
msgid ""
"In this situation, Argument Clinic writes the extra code to the \"buffer\" "
"destination. This may mean that you get a complaint from Argument Clinic:"
msgstr ""
"En esta situación, Argument Clinic escribe el código extra en el destino "
"\"buffer\". Esto puede significar que recibas una queja de Argument Clinic:"

#: ../../howto/clinic.rst:1781
msgid ""
"When this happens, just open your file, find the ``dump buffer`` block that "
"Argument Clinic added to your file (it'll be at the very bottom), then move "
"it above the ``PyMethodDef`` structure where that macro is used."
msgstr ""
"Cuando esto ocurra, simplemente abra su archivo, encuentre el bloque ``dump "
"buffer`` que Argument Clinic añadió a su archivo (estará en la parte "
"inferior), y muévalo por encima de la estructura ``PyMethodDef`` donde se "
"utiliza esa macro."

#: ../../howto/clinic.rst:1788
msgid "Using Argument Clinic in Python files"
msgstr "Uso de Argument Clinic en archivos Python"

#: ../../howto/clinic.rst:1790
msgid ""
"It's actually possible to use Argument Clinic to preprocess Python files. "
"There's no point to using Argument Clinic blocks, of course, as the output "
"wouldn't make any sense to the Python interpreter.  But using Argument "
"Clinic to run Python blocks lets you use Python as a Python preprocessor!"
msgstr ""
"Es posible utilizar Argument Clinic para preprocesar ficheros Python. No "
"tiene sentido usar bloques de Argument Clinic, por supuesto, ya que la "
"salida no tendría ningún sentido para el intérprete de Python.  Pero usar "
"Argument Clinic para ejecutar bloques de Python te permite usar Python como "
"un preprocesador de Python."

#: ../../howto/clinic.rst:1795
msgid ""
"Since Python comments are different from C comments, Argument Clinic blocks "
"embedded in Python files look slightly different.  They look like this:"
msgstr ""
"Dado que los comentarios en Python son diferentes de los comentarios en C, "
"los bloques Argument Clinic incrustados en archivos Python tienen un aspecto "
"ligeramente diferente.  Tienen este aspecto:"
