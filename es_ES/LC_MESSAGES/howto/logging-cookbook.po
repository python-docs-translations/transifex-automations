# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# eulalio barbero espinosa <eulalio@disroot.org>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-02-28 14:56+0000\n"
"PO-Revision-Date: 2024-05-11 00:32+0000\n"
"Last-Translator: eulalio barbero espinosa <eulalio@disroot.org>, 2025\n"
"Language-Team: Spanish (Spain) (https://app.transifex.com/python-doc/"
"teams/5390/es_ES/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es_ES\n"
"Plural-Forms: nplurals=3; plural=n == 1 ? 0 : n != 0 && n % 1000000 == 0 ? "
"1 : 2;\n"

#: ../../howto/logging-cookbook.rst:5
msgid "Logging Cookbook"
msgstr "Libro de recetas de registro"

#: ../../howto/logging-cookbook.rst:0
msgid "Author"
msgstr "Autor"

#: ../../howto/logging-cookbook.rst:7
msgid "Vinay Sajip <vinay_sajip at red-dove dot com>"
msgstr "Vinay Sajip <vinay_sajip at red-dove dot com>"

#: ../../howto/logging-cookbook.rst:9
msgid ""
"This page contains a number of recipes related to logging, which have been "
"found useful in the past. For links to tutorial and reference information, "
"please see :ref:`cookbook-ref-links`."
msgstr ""
"Esta página contiene una serie de recetas relacionadas con el registro, que "
"han resultado útiles en el pasado. Para obtener enlaces a tutoriales e "
"información de referencia, consulte :ref:`cookbook-ref-links`."

#: ../../howto/logging-cookbook.rst:16
msgid "Using logging in multiple modules"
msgstr "Uso del registro en varios módulos"

#: ../../howto/logging-cookbook.rst:18
msgid ""
"Multiple calls to ``logging.getLogger('someLogger')`` return a reference to "
"the same logger object.  This is true not only within the same module, but "
"also across modules as long as it is in the same Python interpreter "
"process.  It is true for references to the same object; additionally, "
"application code can define and configure a parent logger in one module and "
"create (but not configure) a child logger in a separate module, and all "
"logger calls to the child will pass up to the parent.  Here is a main "
"module::"
msgstr ""
"Múltiples llamadas a ``logging.getLogger('someLogger')`` devuelven una "
"referencia al mismo objeto logger.  Esto es cierto no sólo dentro del mismo "
"módulo, sino también a través de los módulos, siempre y cuando esté en el "
"mismo proceso de intérprete de Python.  Es cierto para referencias al mismo "
"objeto; además, el código de la aplicación puede definir y configurar un "
"logger padre en un módulo y crear (pero no configurar) un logger hijo en un "
"módulo separado, y todas las llamadas al logger hijo pasarán al padre.  He "
"aquí un módulo principal::"

#: ../../howto/logging-cookbook.rst:26
msgid ""
"import logging\n"
"import auxiliary_module\n"
"\n"
"# create logger with 'spam_application'\n"
"logger = logging.getLogger('spam_application')\n"
"logger.setLevel(logging.DEBUG)\n"
"# create file handler which logs even debug messages\n"
"fh = logging.FileHandler('spam.log')\n"
"fh.setLevel(logging.DEBUG)\n"
"# create console handler with a higher log level\n"
"ch = logging.StreamHandler()\n"
"ch.setLevel(logging.ERROR)\n"
"# create formatter and add it to the handlers\n"
"formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - "
"%(message)s')\n"
"fh.setFormatter(formatter)\n"
"ch.setFormatter(formatter)\n"
"# add the handlers to the logger\n"
"logger.addHandler(fh)\n"
"logger.addHandler(ch)\n"
"\n"
"logger.info('creating an instance of auxiliary_module.Auxiliary')\n"
"a = auxiliary_module.Auxiliary()\n"
"logger.info('created an instance of auxiliary_module.Auxiliary')\n"
"logger.info('calling auxiliary_module.Auxiliary.do_something')\n"
"a.do_something()\n"
"logger.info('finished auxiliary_module.Auxiliary.do_something')\n"
"logger.info('calling auxiliary_module.some_function()')\n"
"auxiliary_module.some_function()\n"
"logger.info('done with auxiliary_module.some_function()')"
msgstr ""
"import logging\n"
"import auxiliary_module\n"
"\n"
"# crear logger con 'spam_application'\n"
"logger = logging.getLogger('spam_application')\n"
"logger.setLevel(logging.DEBUG)\n"
"# crea un gestor de archivos que registre incluso los mensajes de "
"depuración\n"
"fh = logging.FileHandler('spam.log')\n"
"fh.setLevel(logging.DEBUG)\n"
"# crea un manejador de consola con un nivel de registro más alto\n"
"ch = logging.StreamHandler()\n"
"ch.setLevel(logging.ERROR)\n"
"# crea un formateador y añádelo a los manejadores\n"
"formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - "
"%(message)s')\n"
"fh.setFormatter(formatter)\n"
"ch.setFormatter(formatter)\n"
"# añade los manejadores al logger\n"
"logger.addHandler(fh)\n"
"logger.addHandler(ch)\n"
"\n"
"logger.info('creando una instancia de auxiliary_module.Auxiliary')\n"
"a = auxiliary_module.Auxiliary()\n"
"logger.info('creada una instancia de auxiliary_module.Auxiliary')\n"
"logger.info('llamando a auxiliary_module.Auxiliary.do_something')\n"
"a.hacer_algo()\n"
"logger.info('terminada auxiliary_module.Auxiliary.do_something')\n"
"logger.info('llamando a auxiliary_module.some_function()')\n"
"auxiliary_module.alguna_funcion()\n"
"logger.info('finalizado auxiliary_module.some_function()')"

#: ../../howto/logging-cookbook.rst:56
msgid "Here is the auxiliary module::"
msgstr "Aquí está el módulo auxiliar::"

#: ../../howto/logging-cookbook.rst:58
msgid ""
"import logging\n"
"\n"
"# create logger\n"
"module_logger = logging.getLogger('spam_application.auxiliary')\n"
"\n"
"class Auxiliary:\n"
"    def __init__(self):\n"
"        self.logger = logging.getLogger('spam_application.auxiliary."
"Auxiliary')\n"
"        self.logger.info('creating an instance of Auxiliary')\n"
"\n"
"    def do_something(self):\n"
"        self.logger.info('doing something')\n"
"        a = 1 + 1\n"
"        self.logger.info('done doing something')\n"
"\n"
"def some_function():\n"
"    module_logger.info('received a call to \"some_function\"')"
msgstr ""
"import logging\n"
"\n"
"# create logger\n"
"module_logger = logging.getLogger('spam_application.auxiliary')\n"
"\n"
"class Auxiliary:\n"
"    def __init__(self):\n"
"        self.logger = logging.getLogger('spam_application.auxiliary."
"Auxiliary')\n"
"        self.logger.info('creating an instance of Auxiliary')\n"
"\n"
"    def do_something(self):\n"
"        self.logger.info('doing something')\n"
"        a = 1 + 1\n"
"        self.logger.info('done doing something')\n"
"\n"
"def some_function():\n"
"    module_logger.info(''recibida una llamada a \"alguna_funcion\"\"')"

#: ../../howto/logging-cookbook.rst:76
msgid "The output looks like this:"
msgstr "El resultado es el siguiente:"

#: ../../howto/logging-cookbook.rst:78
msgid ""
"2005-03-23 23:47:11,663 - spam_application - INFO -\n"
"   creating an instance of auxiliary_module.Auxiliary\n"
"2005-03-23 23:47:11,665 - spam_application.auxiliary.Auxiliary - INFO -\n"
"   creating an instance of Auxiliary\n"
"2005-03-23 23:47:11,665 - spam_application - INFO -\n"
"   created an instance of auxiliary_module.Auxiliary\n"
"2005-03-23 23:47:11,668 - spam_application - INFO -\n"
"   calling auxiliary_module.Auxiliary.do_something\n"
"2005-03-23 23:47:11,668 - spam_application.auxiliary.Auxiliary - INFO -\n"
"   doing something\n"
"2005-03-23 23:47:11,669 - spam_application.auxiliary.Auxiliary - INFO -\n"
"   done doing something\n"
"2005-03-23 23:47:11,670 - spam_application - INFO -\n"
"   finished auxiliary_module.Auxiliary.do_something\n"
"2005-03-23 23:47:11,671 - spam_application - INFO -\n"
"   calling auxiliary_module.some_function()\n"
"2005-03-23 23:47:11,672 - spam_application.auxiliary - INFO -\n"
"   received a call to 'some_function'\n"
"2005-03-23 23:47:11,673 - spam_application - INFO -\n"
"   done with auxiliary_module.some_function()"
msgstr ""
"2005-03-23 23:47:11,663 - spam_application - INFO -\n"
"   creating an instance of auxiliary_module.Auxiliary\n"
"2005-03-23 23:47:11,665 - spam_application.auxiliary.Auxiliary - INFO -\n"
"   creating an instance of Auxiliary\n"
"2005-03-23 23:47:11,665 - spam_application - INFO -\n"
"   created an instance of auxiliary_module.Auxiliary\n"
"2005-03-23 23:47:11,668 - spam_application - INFO -\n"
"   calling auxiliary_module.Auxiliary.do_something\n"
"2005-03-23 23:47:11,668 - spam_application.auxiliary.Auxiliary - INFO -\n"
"   doing something\n"
"2005-03-23 23:47:11,669 - spam_application.auxiliary.Auxiliary - INFO -\n"
"   done doing something\n"
"2005-03-23 23:47:11,670 - spam_application - INFO -\n"
"   finished auxiliary_module.Auxiliary.do_something\n"
"2005-03-23 23:47:11,671 - spam_application - INFO -\n"
"   calling auxiliary_module.some_function()\n"
"2005-03-23 23:47:11,672 - spam_application.auxiliary - INFO -\n"
"   received a call to 'some_function'\n"
"2005-03-23 23:47:11,673 - spam_application - INFO -\n"
"   done with auxiliary_module.some_function()"

#: ../../howto/logging-cookbook.rst:102
msgid "Logging from multiple threads"
msgstr "Registro desde varios hilos"

#: ../../howto/logging-cookbook.rst:104
msgid ""
"Logging from multiple threads requires no special effort. The following "
"example shows logging from the main (initial) thread and another thread::"
msgstr ""
"El registro desde varios subprocesos no requiere ningún esfuerzo especial. "
"El siguiente ejemplo muestra el registro desde el hilo principal (inicial) y "
"otro hilo::"

#: ../../howto/logging-cookbook.rst:107
msgid ""
"import logging\n"
"import threading\n"
"import time\n"
"\n"
"def worker(arg):\n"
"    while not arg['stop']:\n"
"        logging.debug('Hi from myfunc')\n"
"        time.sleep(0.5)\n"
"\n"
"def main():\n"
"    logging.basicConfig(level=logging.DEBUG, format='%(relativeCreated)6d "
"%(threadName)s %(message)s')\n"
"    info = {'stop': False}\n"
"    thread = threading.Thread(target=worker, args=(info,))\n"
"    thread.start()\n"
"    while True:\n"
"        try:\n"
"            logging.debug('Hello from main')\n"
"            time.sleep(0.75)\n"
"        except KeyboardInterrupt:\n"
"            info['stop'] = True\n"
"            break\n"
"    thread.join()\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""
"import logging\n"
"import threading\n"
"import time\n"
"\n"
"def worker(arg):\n"
"    while not arg['stop']:\n"
"        logging.debug('Hi from myfunc')\n"
"        time.sleep(0.5)\n"
"\n"
"def main():\n"
"    logging.basicConfig(level=logging.DEBUG, format='%(relativeCreated)6d "
"%(threadName)s %(message)s')\n"
"    info = {'stop': False}\n"
"    thread = threading.Thread(target=worker, args=(info,))\n"
"    thread.start()\n"
"    while True:\n"
"        try:\n"
"            logging.debug('Hello from main')\n"
"            time.sleep(0.75)\n"
"        except KeyboardInterrupt:\n"
"            info['stop'] = True\n"
"            break\n"
"    thread.join()\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"

#: ../../howto/logging-cookbook.rst:133
msgid "When run, the script should print something like the following:"
msgstr "Cuando se ejecuta, el script debe imprimir algo como lo siguiente:"

#: ../../howto/logging-cookbook.rst:135
msgid ""
"   0 Thread-1 Hi from myfunc\n"
"   3 MainThread Hello from main\n"
" 505 Thread-1 Hi from myfunc\n"
" 755 MainThread Hello from main\n"
"1007 Thread-1 Hi from myfunc\n"
"1507 MainThread Hello from main\n"
"1508 Thread-1 Hi from myfunc\n"
"2010 Thread-1 Hi from myfunc\n"
"2258 MainThread Hello from main\n"
"2512 Thread-1 Hi from myfunc\n"
"3009 MainThread Hello from main\n"
"3013 Thread-1 Hi from myfunc\n"
"3515 Thread-1 Hi from myfunc\n"
"3761 MainThread Hello from main\n"
"4017 Thread-1 Hi from myfunc\n"
"4513 MainThread Hello from main\n"
"4518 Thread-1 Hi from myfunc"
msgstr ""
"   0 Thread-1 Hi from myfunc\n"
"   3 MainThread Hello from main\n"
" 505 Thread-1 Hi from myfunc\n"
" 755 MainThread Hello from main\n"
"1007 Thread-1 Hi from myfunc\n"
"1507 MainThread Hello from main\n"
"1508 Thread-1 Hi from myfunc\n"
"2010 Thread-1 Hi from myfunc\n"
"2258 MainThread Hello from main\n"
"2512 Thread-1 Hi from myfunc\n"
"3009 MainThread Hello from main\n"
"3013 Thread-1 Hi from myfunc\n"
"3515 Thread-1 Hi from myfunc\n"
"3761 MainThread Hello from main\n"
"4017 Thread-1 Hi from myfunc\n"
"4513 MainThread Hello from main\n"
"4518 Thread-1 Hi from myfunc"

#: ../../howto/logging-cookbook.rst:155
msgid ""
"This shows the logging output interspersed as one might expect. This "
"approach works for more threads than shown here, of course."
msgstr ""
"Esto muestra la salida de registro intercalada como cabría esperar. Este "
"enfoque funciona para más hilos que los mostrados aquí, por supuesto."

#: ../../howto/logging-cookbook.rst:159
msgid "Multiple handlers and formatters"
msgstr "Múltiples manipuladores y formateadores"

#: ../../howto/logging-cookbook.rst:161
msgid ""
"Loggers are plain Python objects.  The :meth:`~Logger.addHandler` method has "
"no minimum or maximum quota for the number of handlers you may add.  "
"Sometimes it will be beneficial for an application to log all messages of "
"all severities to a text file while simultaneously logging errors or above "
"to the console.  To set this up, simply configure the appropriate handlers.  "
"The logging calls in the application code will remain unchanged.  Here is a "
"slight modification to the previous simple module-based configuration "
"example::"
msgstr ""
"Los registradores son objetos Python planos.  El método :meth:`~Logger."
"addHandler` no tiene una cuota mínima o máxima para el número de manejadores "
"que puede añadir.  A veces será beneficioso para una aplicación registrar "
"todos los mensajes de todas las severidades en un archivo de texto mientras "
"que simultáneamente se registran los errores o lo anterior en la consola.  "
"Para configurar esto, simplemente configure los manejadores apropiados.  Las "
"llamadas de registro en el código de la aplicación permanecerán sin "
"cambios.  He aquí una ligera modificación del ejemplo anterior de "
"configuración simple basada en módulos::"

#: ../../howto/logging-cookbook.rst:169
msgid ""
"import logging\n"
"\n"
"logger = logging.getLogger('simple_example')\n"
"logger.setLevel(logging.DEBUG)\n"
"# create file handler which logs even debug messages\n"
"fh = logging.FileHandler('spam.log')\n"
"fh.setLevel(logging.DEBUG)\n"
"# create console handler with a higher log level\n"
"ch = logging.StreamHandler()\n"
"ch.setLevel(logging.ERROR)\n"
"# create formatter and add it to the handlers\n"
"formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - "
"%(message)s')\n"
"ch.setFormatter(formatter)\n"
"fh.setFormatter(formatter)\n"
"# add the handlers to logger\n"
"logger.addHandler(ch)\n"
"logger.addHandler(fh)\n"
"\n"
"# 'application' code\n"
"logger.debug('debug message')\n"
"logger.info('info message')\n"
"logger.warning('warn message')\n"
"logger.error('error message')\n"
"logger.critical('critical message')"
msgstr ""
"import logging\n"
"\n"
"logger = logging.getLogger('simple_example)\n"
"logger.setLevel(logging.DEBUG)\n"
"# crear un gestor de archivos que registre incluso los mensajes de "
"depuración\n"
"fh = logging.FileHandler('spam.log')\n"
"fh.setLevel(logging.DEBUG)\n"
"# crea un manejador de consola con un nivel de registro más alto\n"
"ch = logging.StreamHandler()\n"
"ch.setLevel(logging.ERROR)\n"
"# crear formateador y añadirlo a los manejadores\n"
"formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - "
"%(message)s')\n"
"ch.setFormatter(formatter)\n"
"fh.setFormatter(formatter)\n"
"# añade los manejadores al logger\n"
"logger.addHandler(ch)\n"
"logger.addHandler(fh)\n"
"\n"
"# código 'aplicación\n"
"logger.debug('mensaje de depuración')\n"
"logger.info('mensaje de información')\n"
"logger.warning('mensaje de advertencia')\n"
"logger.error('mensaje de error')\n"
"logger.critical('mensaje crítico')"

#: ../../howto/logging-cookbook.rst:194
msgid ""
"Notice that the 'application' code does not care about multiple handlers.  "
"All that changed was the addition and configuration of a new handler named "
"*fh*."
msgstr ""
"Observe que el código de la 'aplicación' no se preocupa por los múltiples "
"manejadores.  Todo lo que cambió fue la adición y configuración de un nuevo "
"manejador llamado *fh*."

#: ../../howto/logging-cookbook.rst:197
msgid ""
"The ability to create new handlers with higher- or lower-severity filters "
"can be very helpful when writing and testing an application.  Instead of "
"using many ``print`` statements for debugging, use ``logger.debug``: Unlike "
"the print statements, which you will have to delete or comment out later, "
"the logger.debug statements can remain intact in the source code and remain "
"dormant until you need them again.  At that time, the only change that needs "
"to happen is to modify the severity level of the logger and/or handler to "
"debug."
msgstr ""
"La posibilidad de crear nuevos manejadores con filtros de mayor o menor "
"gravedad puede ser muy útil a la hora de escribir y probar una aplicación.  "
"En lugar de utilizar muchas sentencias ``print`` para depurar, utilice "
"``logger.debug``: A diferencia de las sentencias print, que tendrá que "
"borrar o comentar más tarde, las sentencias logger.debug pueden permanecer "
"intactas en el código fuente y permanecer inactivas hasta que vuelva a "
"necesitarlas.  En ese momento, el único cambio que hay que hacer es "
"modificar el nivel de gravedad del logger y/o handler a debug."

#: ../../howto/logging-cookbook.rst:208
msgid "Logging to multiple destinations"
msgstr "Registro en varios destinos"

#: ../../howto/logging-cookbook.rst:210
msgid ""
"Let's say you want to log to console and file with different message formats "
"and in differing circumstances. Say you want to log messages with levels of "
"DEBUG and higher to file, and those messages at level INFO and higher to the "
"console. Let's also assume that the file should contain timestamps, but the "
"console messages should not. Here's how you can achieve this::"
msgstr ""
"Digamos que se quiere registrar en consola y fichero con diferentes formatos "
"de mensaje y en diferentes circunstancias. Digamos que se quiere registrar "
"los mensajes con niveles de DEBUG y superiores en el fichero, y los mensajes "
"con nivel INFO y superiores en la consola. Supongamos también que el fichero "
"debe contener marcas de tiempo, pero los mensajes de la consola no. He aquí "
"cómo se puede lograr esto::"

#: ../../howto/logging-cookbook.rst:216
msgid ""
"import logging\n"
"\n"
"# set up logging to file - see previous section for more details\n"
"logging.basicConfig(level=logging.DEBUG,\n"
"                    format='%(asctime)s %(name)-12s %(levelname)-8s "
"%(message)s',\n"
"                    datefmt='%m-%d %H:%M',\n"
"                    filename='/tmp/myapp.log',\n"
"                    filemode='w')\n"
"# define a Handler which writes INFO messages or higher to the sys.stderr\n"
"console = logging.StreamHandler()\n"
"console.setLevel(logging.INFO)\n"
"# set a format which is simpler for console use\n"
"formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')\n"
"# tell the handler to use this format\n"
"console.setFormatter(formatter)\n"
"# add the handler to the root logger\n"
"logging.getLogger('').addHandler(console)\n"
"\n"
"# Now, we can log to the root logger, or any other logger. First the "
"root...\n"
"logging.info('Jackdaws love my big sphinx of quartz.')\n"
"\n"
"# Now, define a couple of other loggers which might represent areas in your\n"
"# application:\n"
"\n"
"logger1 = logging.getLogger('myapp.area1')\n"
"logger2 = logging.getLogger('myapp.area2')\n"
"\n"
"logger1.debug('Quick zephyrs blow, vexing daft Jim.')\n"
"logger1.info('How quickly daft jumping zebras vex.')\n"
"logger2.warning('Jail zesty vixen who grabbed pay from quack.')\n"
"logger2.error('The five boxing wizards jump quickly.')"
msgstr ""
"import logging\n"
"\n"
"# configurar el registro en un archivo - ver la sección anterior para más "
"detalles\n"
"logging.basicConfig(level=logging.DEBUG,\n"
"                    format='%(asctime)s %(name)-12s %(levelname)-8s "
"%(message)s ',\n"
"                    datefmt='%m-%d %H:%M',\n"
"                    filename='/tmp/myapp.log',\n"
"                    filemode='w')\n"
"# define un Handler que escriba los mensajes INFO o superiores en sys."
"stderr\n"
"console = logging.StreamHandler()\n"
"console.setLevel(logging.INFO)\n"
"# define un formato que sea más simple para uso en consola\n"
"formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s ')\n"
"# dile al manejador que use este formato\n"
"console.setFormatter(formatter)\n"
"# añade el manejador al logger raíz\n"
"logging.getLogger('').addHandler(console)\n"
"\n"
"# Ahora, podemos registrar en el logger raíz, o en cualquier otro logger. "
"Primero el raíz...\n"
"logging.info('A los grajos les encanta mi gran esfinge de cuarzo.')\n"
"\n"
"# Ahora, define un par de otros loggers que puedan representar áreas en tu\n"
"# aplicación:\n"
"\n"
"logger1 = logging.getLogger('myapp.area1')\n"
"logger2 = logging.getLogger('myapp.area2')\n"
"\n"
"logger1.debug('Rápido soplan los céfiros, vejando al tonto Jim.')\n"
"logger1.info('Qué rápido soplan los céfiros, vejando al tonto Jim.')\n"
"logger2.warning('Encarcela a quién le quitó la paga al charlatán')\n"
"logger2.error('Los cinco magos boxeadores saltan rápidamente.')"

#: ../../howto/logging-cookbook.rst:248
msgid "When you run this, on the console you will see"
msgstr "Cuando ejecutes esto, en la consola verás"

#: ../../howto/logging-cookbook.rst:250
msgid ""
"root        : INFO     Jackdaws love my big sphinx of quartz.\n"
"myapp.area1 : INFO     How quickly daft jumping zebras vex.\n"
"myapp.area2 : WARNING  Jail zesty vixen who grabbed pay from quack.\n"
"myapp.area2 : ERROR    The five boxing wizards jump quickly."
msgstr ""
"root : INFO A los grajos les encanta mi gran esfinge de cuarzo.\n"
"myapp.area1 : INFO Qué rápido saltan las zebras.\n"
"myapp.area2 : ADVERTENCIA La zorra de la cárcel que le quitó la paga al "
"curandero.\n"
"myapp.area2 : ERROR Qué rápido saltan los cinco magos boxeadores."

#: ../../howto/logging-cookbook.rst:257
msgid "and in the file you will see something like"
msgstr "y en el archivo se verá algo como"

#: ../../howto/logging-cookbook.rst:259
msgid ""
"10-22 22:19 root         INFO     Jackdaws love my big sphinx of quartz.\n"
"10-22 22:19 myapp.area1  DEBUG    Quick zephyrs blow, vexing daft Jim.\n"
"10-22 22:19 myapp.area1  INFO     How quickly daft jumping zebras vex.\n"
"10-22 22:19 myapp.area2  WARNING  Jail zesty vixen who grabbed pay from "
"quack.\n"
"10-22 22:19 myapp.area2  ERROR    The five boxing wizards jump quickly."
msgstr ""
"10-22 22:19 root INFO A las grajillas les encanta mi gran esfinge de "
"cuarzo.\n"
"10-22 22:19 myapp.area1 DEBUG Qué rápido soplan los céfiros, vejando al "
"tonto Jim.\n"
"10-22 22:19 myapp.area1 INFO Con qué rapidez molestan las cebras "
"saltarinas.\n"
"10-22 22:19 myapp.area2 ADVERTENCIA Encarcela a la zorra que le quitó la "
"paga al charlatán.\n"
"10-22 22:19 myapp.area2 ERROR Los cinco magos boxeadores saltan rápidamente."

#: ../../howto/logging-cookbook.rst:267
msgid ""
"As you can see, the DEBUG message only shows up in the file. The other "
"messages are sent to both destinations."
msgstr ""
"Como se puede ver, el mensaje DEBUG sólo aparece en el archivo. Los demás "
"mensajes se envían a ambos destinos."

#: ../../howto/logging-cookbook.rst:270
msgid ""
"This example uses console and file handlers, but you can use any number and "
"combination of handlers you choose."
msgstr ""
"Este ejemplo utiliza manejadores de consola y archivo, pero puede utilizar "
"cualquier número y combinación de manejadores que se elija."

#: ../../howto/logging-cookbook.rst:273
msgid ""
"Note that the above choice of log filename ``/tmp/myapp.log`` implies use of "
"a standard location for temporary files on POSIX systems. On Windows, you "
"may need to choose a different directory name for the log - just ensure that "
"the directory exists and that you have the permissions to create and update "
"files in it."
msgstr ""
"Tener en cuenta que la elección anterior del nombre del archivo de registro "
"``/tmp/myapp.log`` implica el uso de una ubicación estándar para archivos "
"temporales en sistemas POSIX. En Windows, es posible que se  tenga que "
"elegir un nombre de directorio diferente para el registro - asegurarse sólo "
"de que el directorio exista y que se tienen los permisos para crear y "
"actualizar archivos en él."

#: ../../howto/logging-cookbook.rst:282
msgid "Custom handling of levels"
msgstr "Gestión personalizada de niveles"

#: ../../howto/logging-cookbook.rst:284
msgid ""
"Sometimes, you might want to do something slightly different from the "
"standard handling of levels in handlers, where all levels above a threshold "
"get processed by a handler. To do this, you need to use filters. Let's look "
"at a scenario where you want to arrange things as follows:"
msgstr ""
"A veces, es posible que se desee hacer algo distinto del manejo estándar de "
"los niveles en los manejadores, donde todos los niveles por encima de un "
"umbral son procesados por un manejador. Para ello, es necesario utilizar "
"filtros. Veamos un escenario en el que se desea organizar las cosas de la "
"siguiente manera:"

#: ../../howto/logging-cookbook.rst:289
msgid "Send messages of severity ``INFO`` and ``WARNING`` to ``sys.stdout``"
msgstr "Enviar mensajes de gravedad ``INFO`` y ``WARNING`` a ``sys.stdout``"

#: ../../howto/logging-cookbook.rst:290
msgid "Send messages of severity ``ERROR`` and above to ``sys.stderr``"
msgstr "Enviar mensajes de gravedad ``ERROR`` y superiores a ``sys.stderr``"

#: ../../howto/logging-cookbook.rst:291
msgid "Send messages of severity ``DEBUG`` and above to file ``app.log``"
msgstr ""
"Enviar mensajes de gravedad ``DEBUG`` y superiores al archivo ``app.log``"

#: ../../howto/logging-cookbook.rst:293
msgid "Suppose you configure logging with the following JSON:"
msgstr "Suponga que se configura el registro con el siguiente JSON:"

#: ../../howto/logging-cookbook.rst:295
msgid ""
"{\n"
"    \"version\": 1,\n"
"    \"disable_existing_loggers\": false,\n"
"    \"formatters\": {\n"
"        \"simple\": {\n"
"            \"format\": \"%(levelname)-8s - %(message)s\"\n"
"        }\n"
"    },\n"
"    \"handlers\": {\n"
"        \"stdout\": {\n"
"            \"class\": \"logging.StreamHandler\",\n"
"            \"level\": \"INFO\",\n"
"            \"formatter\": \"simple\",\n"
"            \"stream\": \"ext://sys.stdout\"\n"
"        },\n"
"        \"stderr\": {\n"
"            \"class\": \"logging.StreamHandler\",\n"
"            \"level\": \"ERROR\",\n"
"            \"formatter\": \"simple\",\n"
"            \"stream\": \"ext://sys.stderr\"\n"
"        },\n"
"        \"file\": {\n"
"            \"class\": \"logging.FileHandler\",\n"
"            \"formatter\": \"simple\",\n"
"            \"filename\": \"app.log\",\n"
"            \"mode\": \"w\"\n"
"        }\n"
"    },\n"
"    \"root\": {\n"
"        \"level\": \"DEBUG\",\n"
"        \"handlers\": [\n"
"            \"stderr\",\n"
"            \"stdout\",\n"
"            \"file\"\n"
"        ]\n"
"    }\n"
"}"
msgstr ""
"{\n"
"    \"version\": 1,\n"
"    \"disable_existing_loggers\": false,\n"
"    \"formatters\": {\n"
"        \"simple\": {\n"
"            \"format\": \"%(levelname)-8s - %(message)s\"\n"
"        }\n"
"    },\n"
"    \"handlers\": {\n"
"        \"stdout\": {\n"
"            \"class\": \"logging.StreamHandler\",\n"
"            \"level\": \"INFO\",\n"
"            \"formatter\": \"simple\",\n"
"            \"stream\": \"ext://sys.stdout\"\n"
"        },\n"
"        \"stderr\": {\n"
"            \"class\": \"logging.StreamHandler\",\n"
"            \"level\": \"ERROR\",\n"
"            \"formatter\": \"simple\",\n"
"            \"stream\": \"ext://sys.stderr\"\n"
"        },\n"
"        \"file\": {\n"
"            \"class\": \"logging.FileHandler\",\n"
"            \"formatter\": \"simple\",\n"
"            \"filename\": \"app.log\",\n"
"            \"mode\": \"w\"\n"
"        }\n"
"    },\n"
"    \"root\": {\n"
"        \"level\": \"DEBUG\",\n"
"        \"handlers\": [\n"
"            \"stderr\",\n"
"            \"stdout\",\n"
"            \"file\"\n"
"        ]\n"
"    }\n"
"}"

#: ../../howto/logging-cookbook.rst:335
msgid ""
"This configuration does *almost* what we want, except that ``sys.stdout`` "
"would show messages of severity ``ERROR`` and above as well as ``INFO`` and "
"``WARNING`` messages. To prevent this, we can set up a filter which excludes "
"those messages and add it to the relevant handler. This can be configured by "
"adding a ``filters`` section parallel to ``formatters`` and ``handlers``:"
msgstr ""
"Esta configuración hace *casi* lo que queremos, excepto que ``sys.stdout`` "
"mostraría los mensajes de gravedad ``ERROR`` y superior, así como los "
"mensajes ``INFO`` y ``WARNING``. Para evitarlo, podemos configurar un filtro "
"que excluya esos mensajes y añadirlo al manejador correspondiente. Esto "
"puede configurarse añadiendo una sección ``filters`` paralela a "
"``formatters`` y ``handlers``:"

#: ../../howto/logging-cookbook.rst:341
msgid ""
"{\n"
"    \"filters\": {\n"
"        \"warnings_and_below\": {\n"
"            \"()\" : \"__main__.filter_maker\",\n"
"            \"level\": \"WARNING\"\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"{\n"
"    \"filters\": {\n"
"        \"warnings_and_below\": {\n"
"            \"()\" : \"__main__.filter_maker\",\n"
"            \"level\": \"WARNING\"\n"
"        }\n"
"    }\n"
"}"

#: ../../howto/logging-cookbook.rst:352
msgid "and changing the section on the ``stdout`` handler to add it:"
msgstr "y cambiando la sección del manejador ``stdout`` para añadirlo:"

#: ../../howto/logging-cookbook.rst:354
msgid ""
"{\n"
"    \"stdout\": {\n"
"        \"class\": \"logging.StreamHandler\",\n"
"        \"level\": \"INFO\",\n"
"        \"formatter\": \"simple\",\n"
"        \"stream\": \"ext://sys.stdout\",\n"
"        \"filters\": [\"warnings_and_below\"]\n"
"    }\n"
"}"
msgstr ""
"{\n"
"    \"stdout\": {\n"
"        \"class\": \"logging.StreamHandler\",\n"
"        \"level\": \"INFO\",\n"
"        \"formatter\": \"simple\",\n"
"        \"stream\": \"ext://sys.stdout\",\n"
"        \"filters\": [\"warnings_and_below\"]\n"
"    }\n"
"}"

#: ../../howto/logging-cookbook.rst:366
msgid ""
"A filter is just a function, so we can define the ``filter_maker`` (a "
"factory function) as follows:"
msgstr ""
"Un filtro no es más que una función, por lo que podemos definir el "
"``filter_maker`` (una función de fábrica) de la siguiente manera:"

#: ../../howto/logging-cookbook.rst:369
msgid ""
"def filter_maker(level):\n"
"    level = getattr(logging, level)\n"
"\n"
"    def filter(record):\n"
"        return record.levelno <= level\n"
"\n"
"    return filter"
msgstr ""
"def filter_maker(level):\n"
"    level = getattr(logging, level)\n"
"\n"
"    def filter(record):\n"
"        return record.levelno <= level\n"
"\n"
"    return filter"

#: ../../howto/logging-cookbook.rst:379
msgid ""
"This converts the string argument passed in to a numeric level, and returns "
"a function which only returns ``True`` if the level of the passed in record "
"is at or below the specified level. Note that in this example I have defined "
"the ``filter_maker`` in a test script ``main.py`` that I run from the "
"command line, so its module will be ``__main__`` - hence the ``__main__."
"filter_maker`` in the filter configuration. You will need to change that if "
"you define it in a different module."
msgstr ""
"Convierte el argumento de cadena introducido en un nivel numérico y devuelve "
"una función que sólo devuelve ``True`` si el nivel del registro introducido "
"es igual o inferior al nivel especificado. Tenga en cuenta que en este "
"ejemplo he definido ``filter_maker`` en un script de prueba ``main.py`` que "
"ejecuto desde la línea de comandos, por lo que su módulo será ``__main__`` - "
"de ahí ``__main__.filter_maker`` en la configuración del filtro. Habrá que "
"cambiar esto si se define en un módulo diferente."

#: ../../howto/logging-cookbook.rst:387
msgid "With the filter added, we can run ``main.py``, which in full is:"
msgstr ""
"Con el filtro añadido, podemos ejecutar ``main.py``, que en su totalidad es:"

#: ../../howto/logging-cookbook.rst:389
msgid ""
"import json\n"
"import logging\n"
"import logging.config\n"
"\n"
"CONFIG = '''\n"
"{\n"
"    \"version\": 1,\n"
"    \"disable_existing_loggers\": false,\n"
"    \"formatters\": {\n"
"        \"simple\": {\n"
"            \"format\": \"%(levelname)-8s - %(message)s\"\n"
"        }\n"
"    },\n"
"    \"filters\": {\n"
"        \"warnings_and_below\": {\n"
"            \"()\" : \"__main__.filter_maker\",\n"
"            \"level\": \"WARNING\"\n"
"        }\n"
"    },\n"
"    \"handlers\": {\n"
"        \"stdout\": {\n"
"            \"class\": \"logging.StreamHandler\",\n"
"            \"level\": \"INFO\",\n"
"            \"formatter\": \"simple\",\n"
"            \"stream\": \"ext://sys.stdout\",\n"
"            \"filters\": [\"warnings_and_below\"]\n"
"        },\n"
"        \"stderr\": {\n"
"            \"class\": \"logging.StreamHandler\",\n"
"            \"level\": \"ERROR\",\n"
"            \"formatter\": \"simple\",\n"
"            \"stream\": \"ext://sys.stderr\"\n"
"        },\n"
"        \"file\": {\n"
"            \"class\": \"logging.FileHandler\",\n"
"            \"formatter\": \"simple\",\n"
"            \"filename\": \"app.log\",\n"
"            \"mode\": \"w\"\n"
"        }\n"
"    },\n"
"    \"root\": {\n"
"        \"level\": \"DEBUG\",\n"
"        \"handlers\": [\n"
"            \"stderr\",\n"
"            \"stdout\",\n"
"            \"file\"\n"
"        ]\n"
"    }\n"
"}\n"
"'''\n"
"\n"
"def filter_maker(level):\n"
"    level = getattr(logging, level)\n"
"\n"
"    def filter(record):\n"
"        return record.levelno <= level\n"
"\n"
"    return filter\n"
"\n"
"logging.config.dictConfig(json.loads(CONFIG))\n"
"logging.debug('A DEBUG message')\n"
"logging.info('An INFO message')\n"
"logging.warning('A WARNING message')\n"
"logging.error('An ERROR message')\n"
"logging.critical('A CRITICAL message')"
msgstr ""
"import json\n"
"import logging\n"
"import logging.config\n"
"\n"
"CONFIG = '''\n"
"{\n"
"    \"version\": 1,\n"
"    \"disable_existing_loggers\": false,\n"
"    \"formatters\": {\n"
"        \"simple\": {\n"
"            \"format\": \"%(levelname)-8s - %(message)s\"\n"
"        }\n"
"    },\n"
"    \"filters\": {\n"
"        \"warnings_and_below\": {\n"
"            \"()\" : \"__main__.filter_maker\",\n"
"            \"level\": \"WARNING\"\n"
"        }\n"
"    },\n"
"    \"handlers\": {\n"
"        \"stdout\": {\n"
"            \"class\": \"logging.StreamHandler\",\n"
"            \"level\": \"INFO\",\n"
"            \"formatter\": \"simple\",\n"
"            \"stream\": \"ext://sys.stdout\",\n"
"            \"filters\": [\"warnings_and_below\"]\n"
"        },\n"
"        \"stderr\": {\n"
"            \"class\": \"logging.StreamHandler\",\n"
"            \"level\": \"ERROR\",\n"
"            \"formatter\": \"simple\",\n"
"            \"stream\": \"ext://sys.stderr\"\n"
"        },\n"
"        \"file\": {\n"
"            \"class\": \"logging.FileHandler\",\n"
"            \"formatter\": \"simple\",\n"
"            \"filename\": \"app.log\",\n"
"            \"mode\": \"w\"\n"
"        }\n"
"    },\n"
"    \"root\": {\n"
"        \"level\": \"DEBUG\",\n"
"        \"handlers\": [\n"
"            \"stderr\",\n"
"            \"stdout\",\n"
"            \"file\"\n"
"        ]\n"
"    }\n"
"}\n"
"'''\n"
"\n"
"def filter_maker(level):\n"
"    level = getattr(logging, level)\n"
"\n"
"    def filter(record):\n"
"        return record.levelno <= level\n"
"\n"
"    return filter\n"
"\n"
"logging.config.dictConfig(json.loads(CONFIG))\n"
"logging.debug('A DEBUG message')\n"
"logging.info('An INFO message')\n"
"logging.warning('A WARNING message')\n"
"logging.error('An ERROR message')\n"
"logging.critical('A CRITICAL message')"

#: ../../howto/logging-cookbook.rst:457
msgid "And after running it like this:"
msgstr "Y después de ejecutarlo así:"

#: ../../howto/logging-cookbook.rst:459
msgid "python main.py 2>stderr.log >stdout.log"
msgstr "python main.py 2>stderr.log >stdout.log"

#: ../../howto/logging-cookbook.rst:463
msgid "We can see the results are as expected:"
msgstr "Podemos ver que los resultados son los esperados:"

#: ../../howto/logging-cookbook.rst:465
msgid ""
"$ more *.log\n"
"::::::::::::::\n"
"app.log\n"
"::::::::::::::\n"
"DEBUG    - A DEBUG message\n"
"INFO     - An INFO message\n"
"WARNING  - A WARNING message\n"
"ERROR    - An ERROR message\n"
"CRITICAL - A CRITICAL message\n"
"::::::::::::::\n"
"stderr.log\n"
"::::::::::::::\n"
"ERROR    - An ERROR message\n"
"CRITICAL - A CRITICAL message\n"
"::::::::::::::\n"
"stdout.log\n"
"::::::::::::::\n"
"INFO     - An INFO message\n"
"WARNING  - A WARNING message"
msgstr ""
"$ more *.log\n"
"::::::::::::::\n"
"app.log\n"
"::::::::::::::\n"
"DEBUG    - A DEBUG message\n"
"INFO     - An INFO message\n"
"WARNING  - A WARNING message\n"
"ERROR    - An ERROR message\n"
"CRITICAL - A CRITICAL message\n"
"::::::::::::::\n"
"stderr.log\n"
"::::::::::::::\n"
"ERROR    - An ERROR message\n"
"CRITICAL - A CRITICAL message\n"
"::::::::::::::\n"
"stdout.log\n"
"::::::::::::::\n"
"INFO     - An INFO message\n"
"WARNING  - A WARNING message"

#: ../../howto/logging-cookbook.rst:489
msgid "Configuration server example"
msgstr "Ejemplo de servidor de configuración"

#: ../../howto/logging-cookbook.rst:491
msgid "Here is an example of a module using the logging configuration server::"
msgstr ""
"He aquí un ejemplo de un módulo que utiliza el servidor de configuración de "
"registro::"

#: ../../howto/logging-cookbook.rst:493
msgid ""
"import logging\n"
"import logging.config\n"
"import time\n"
"import os\n"
"\n"
"# read initial config file\n"
"logging.config.fileConfig('logging.conf')\n"
"\n"
"# create and start listener on port 9999\n"
"t = logging.config.listen(9999)\n"
"t.start()\n"
"\n"
"logger = logging.getLogger('simpleExample')\n"
"\n"
"try:\n"
"    # loop through logging calls to see the difference\n"
"    # new configurations make, until Ctrl+C is pressed\n"
"    while True:\n"
"        logger.debug('debug message')\n"
"        logger.info('info message')\n"
"        logger.warning('warn message')\n"
"        logger.error('error message')\n"
"        logger.critical('critical message')\n"
"        time.sleep(5)\n"
"except KeyboardInterrupt:\n"
"    # cleanup\n"
"    logging.config.stopListening()\n"
"    t.join()"
msgstr ""
"import logging\n"
"import logging.config\n"
"import time\n"
"import os\n"
"\n"
"# leer archivo de configuración inicial\n"
"logging.config.fileConfig('logging.conf')\n"
"\n"
"# crear e iniciar listener en el puerto 9999\n"
"t = logging.config.listen(9999)\n"
"t.start()\n"
"\n"
"logger = logging.getLogger('simpleExample')\n"
"\n"
"try:\n"
"   # bucle a través de las llamadas de registro para ver la diferencia\n"
"   # nuevas configuraciones, hasta que se pulse Ctrl+C\n"
"    while True:\n"
"        logger.debug('debug message')\n"
"        logger.info('info message')\n"
"        logger.warning('warn message')\n"
"        logger.error('error message')\n"
"        logger.critical('critical message')\n"
"        time.sleep(5)\n"
"except KeyboardInterrupt:\n"
" # limpia\n"
"    logging.config.stopListening()\n"
"    t.join()"

#: ../../howto/logging-cookbook.rst:522
msgid ""
"And here is a script that takes a filename and sends that file to the "
"server, properly preceded with the binary-encoded length, as the new logging "
"configuration::"
msgstr ""
"Y aquí hay un script que toma un nombre de archivo y envía ese archivo al "
"servidor, debidamente precedido con la longitud de codificación binaria, "
"como la nueva configuración de registro::"

#: ../../howto/logging-cookbook.rst:526
msgid ""
"#!/usr/bin/env python\n"
"import socket, sys, struct\n"
"\n"
"with open(sys.argv[1], 'rb') as f:\n"
"    data_to_send = f.read()\n"
"\n"
"HOST = 'localhost'\n"
"PORT = 9999\n"
"s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"print('connecting...')\n"
"s.connect((HOST, PORT))\n"
"print('sending config...')\n"
"s.send(struct.pack('>L', len(data_to_send)))\n"
"s.send(data_to_send)\n"
"s.close()\n"
"print('complete')"
msgstr ""
"#!/usr/bin/env python\n"
"import socket, sys, struct\n"
"\n"
"with open(sys.argv[1], 'rb') as f:\n"
"    data_to_send = f.read()\n"
"\n"
"HOST = 'localhost'\n"
"PORT = 9999\n"
"s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"print('connecting...')\n"
"s.connect((HOST, PORT))\n"
"print('sending config...')\n"
"s.send(struct.pack('>L', len(data_to_send)))\n"
"s.send(data_to_send)\n"
"s.close()\n"
"print('complete')"

#: ../../howto/logging-cookbook.rst:547
msgid "Dealing with handlers that block"
msgstr "Manipuladores que se bloquean"

#: ../../howto/logging-cookbook.rst:551
msgid ""
"Sometimes you have to get your logging handlers to do their work without "
"blocking the thread you're logging from. This is common in web applications, "
"though of course it also occurs in other scenarios."
msgstr ""
"A veces se tiene que conseguir que los manejadores de registro hagan su "
"trabajo sin bloquear el hilo desde el que se está registrando. Esto es común "
"en aplicaciones web, aunque por supuesto también ocurre en otros escenarios."

#: ../../howto/logging-cookbook.rst:555
msgid ""
"A common culprit which demonstrates sluggish behaviour is the :class:"
"`SMTPHandler`: sending emails can take a long time, for a number of reasons "
"outside the developer's control (for example, a poorly performing mail or "
"network infrastructure). But almost any network-based handler can block: "
"Even a :class:`SocketHandler` operation may do a DNS query under the hood "
"which is too slow (and this query can be deep in the socket library code, "
"below the Python layer, and outside your control)."
msgstr ""
"Un culpable común que demuestra un comportamiento lento es :class:"
"`SMTPHandler`: el envío de correos electrónicos puede tardar mucho tiempo, "
"por una serie de razones que escapan al control del desarrollador (por "
"ejemplo, un mal funcionamiento de la infraestructura de correo o de red). "
"Pero casi cualquier manejador basado en la red puede bloquearse: Incluso una "
"operación de :class:`SocketHandler` puede hacer una consulta DNS bajo el "
"capó que sea demasiado lenta (y esta consulta puede estar en lo más profundo "
"del código de la biblioteca de sockets, por debajo de la capa de Python, y "
"fuera de tu control)."

#: ../../howto/logging-cookbook.rst:563
msgid ""
"One solution is to use a two-part approach. For the first part, attach only "
"a :class:`QueueHandler` to those loggers which are accessed from performance-"
"critical threads. They simply write to their queue, which can be sized to a "
"large enough capacity or initialized with no upper bound to their size. The "
"write to the queue will typically be accepted quickly, though you will "
"probably need to catch the :exc:`queue.Full` exception as a precaution in "
"your code. If you are a library developer who has performance-critical "
"threads in their code, be sure to document this (together with a suggestion "
"to attach only ``QueueHandlers`` to your loggers) for the benefit of other "
"developers who will use your code."
msgstr ""
"Una solución es utilizar un enfoque en dos partes. Para la primera parte, "
"adjunte sólo un :class:`QueueHandler` a aquellos registradores a los que se "
"accede desde subprocesos críticos para el rendimiento. Simplemente escriben "
"en su cola, que puede ser de un tamaño suficientemente grande o inicializada "
"sin límite superior a su tamaño. La escritura en la cola suele ser aceptada "
"rápidamente, aunque es probable que tenga que capturar la excepción :exc:"
"`queue.Full` como precaución en su código. Si eres un desarrollador de "
"bibliotecas que tiene hilos críticos para el rendimiento en su código, "
"asegúrate de documentar esto (junto con una sugerencia de adjuntar sólo "
"``QueueHandlers`` a tus registradores) en beneficio de otros desarrolladores "
"que vayan a utilizar tu código."

#: ../../howto/logging-cookbook.rst:574
msgid ""
"The second part of the solution is :class:`QueueListener`, which has been "
"designed as the counterpart to :class:`QueueHandler`.  A :class:"
"`QueueListener` is very simple: it's passed a queue and some handlers, and "
"it fires up an internal thread which listens to its queue for LogRecords "
"sent from ``QueueHandlers`` (or any other source of ``LogRecords``, for that "
"matter). The ``LogRecords`` are removed from the queue and passed to the "
"handlers for processing."
msgstr ""
"La segunda parte de la solución es :class:`QueueListener`, que se ha "
"diseñado como contrapartida de :class:`QueueHandler`.  Un :class:"
"`QueueListener` es muy simple: se le pasa una cola y algunos manejadores, y "
"se inicia un hilo interno que escucha en su cola los LogRecords enviados "
"desde ``QueueHandlers`` (o cualquier otra fuente de ``LogRecords``, para el "
"caso). Los ``LogRecords`` se retiran de la cola y se pasan a los manejadores "
"para su procesamiento."

#: ../../howto/logging-cookbook.rst:582
msgid ""
"The advantage of having a separate :class:`QueueListener` class is that you "
"can use the same instance to service multiple ``QueueHandlers``. This is "
"more resource-friendly than, say, having threaded versions of the existing "
"handler classes, which would eat up one thread per handler for no particular "
"benefit."
msgstr ""
"La ventaja de tener una clase :class:`QueueListener` separada es que puedes "
"usar la misma instancia para dar servicio a múltiples ``QueueHandlers``. "
"Esto es más respetuoso con los recursos que, por ejemplo, tener versiones "
"con subprocesos de las clases manejadoras existentes, que consumirían un "
"subproceso por manejador sin ningún beneficio particular."

#: ../../howto/logging-cookbook.rst:587
msgid "An example of using these two classes follows (imports omitted)::"
msgstr ""
"A continuación se muestra un ejemplo de uso de estas dos clases (se omiten "
"las importaciones)::"

#: ../../howto/logging-cookbook.rst:589
msgid ""
"que = queue.Queue(-1)  # no limit on size\n"
"queue_handler = QueueHandler(que)\n"
"handler = logging.StreamHandler()\n"
"listener = QueueListener(que, handler)\n"
"root = logging.getLogger()\n"
"root.addHandler(queue_handler)\n"
"formatter = logging.Formatter('%(threadName)s: %(message)s')\n"
"handler.setFormatter(formatter)\n"
"listener.start()\n"
"# The log output will display the thread which generated\n"
"# the event (the main thread) rather than the internal\n"
"# thread which monitors the internal queue. This is what\n"
"# you want to happen.\n"
"root.warning('Look out!')\n"
"listener.stop()"
msgstr ""
"que = queue.Queue(-1)  # sin límite de tamaño\n"
"queue_handler = QueueHandler(que)\n"
"handler = logging.StreamHandler()\n"
"listener = QueueListener(que, handler)\n"
"root = logging.getLogger()\n"
"root.addHandler(queue_handler)\n"
"formatter = logging.Formatter('%(threadName)s: %(message)s')\n"
"handler.setFormatter(formatter)\n"
"listener.start()\n"
"# La salida del log mostrará el hilo que generó\n"
"# el evento (el hilo principal) en lugar del hilo interno\n"
"# que monitoriza la cola interna. Esto es lo que\n"
"# que quieres que ocurra.\n"
"root.warning('Cuidado!')\n"
"listener.stop()"

#: ../../howto/logging-cookbook.rst:605
msgid "which, when run, will produce:"
msgstr "que, cuando se ejecute, producirá:"

#: ../../howto/logging-cookbook.rst:607
msgid "MainThread: Look out!"
msgstr "Hilo principal: ¡Cuidado!"

#: ../../howto/logging-cookbook.rst:611
msgid ""
"Although the earlier discussion wasn't specifically talking about async "
"code, but rather about slow logging handlers, it should be noted that when "
"logging from async code, network and even file handlers could lead to "
"problems (blocking the event loop) because some logging is done from :mod:"
"`asyncio` internals. It might be best, if any async code is used in an "
"application, to use the above approach for logging, so that any blocking "
"code runs only in the ``QueueListener`` thread."
msgstr ""
"Aunque la discusión anterior no se refería específicamente al código "
"asíncrono, sino más bien a los lentos manejadores de registro, debe tenerse "
"en cuenta que cuando se realiza el registro desde código asíncrono, los "
"manejadores de red e incluso de archivos podrían dar problemas (bloqueando "
"el bucle de eventos) porque parte del registro se realiza desde los internos "
"de :mod:`asyncio`. Sería mejor, si se utiliza código asíncrono en una "
"aplicación, utilizar el enfoque anterior para el registro, de modo que "
"cualquier código de bloqueo se ejecute sólo en el hilo ``QueueListener``."

#: ../../howto/logging-cookbook.rst:619
msgid ""
"Prior to Python 3.5, the :class:`QueueListener` always passed every message "
"received from the queue to every handler it was initialized with. (This was "
"because it was assumed that level filtering was all done on the other side, "
"where the queue is filled.) From 3.5 onwards, this behaviour can be changed "
"by passing a keyword argument ``respect_handler_level=True`` to the "
"listener's constructor. When this is done, the listener compares the level "
"of each message with the handler's level, and only passes a message to a "
"handler if it's appropriate to do so."
msgstr ""
"Antes de Python 3.5, :class:`QueueListener` siempre pasaba cada mensaje "
"recibido de la cola a cada manejador con el que se inicializaba. (Esto se "
"debía a que se asumía que el filtrado de nivel se hacía todo en el otro "
"lado, donde se llena la cola). A partir de la versión 3.5, este "
"comportamiento puede cambiarse pasando un argumento de palabra clave "
"``respect_handler_level=True`` al constructor del receptor. Cuando se hace "
"esto, el receptor compara el nivel de cada mensaje con el nivel del "
"manejador, y sólo pasa un mensaje a un manejador si es apropiado hacerlo."

#: ../../howto/logging-cookbook.rst:632
msgid "Sending and receiving logging events across a network"
msgstr "Envío y recepción de eventos de registro a través de una red"

#: ../../howto/logging-cookbook.rst:634
msgid ""
"Let's say you want to send logging events across a network, and handle them "
"at the receiving end. A simple way of doing this is attaching a :class:"
"`SocketHandler` instance to the root logger at the sending end::"
msgstr ""
"Digamos que quieres enviar eventos de registro a través de una red, y "
"manejarlos en el extremo receptor. Una forma sencilla de hacerlo es adjuntar "
"una instancia de :class:`SocketHandler` al registrador raíz en el extremo "
"emisor::"

#: ../../howto/logging-cookbook.rst:638
msgid ""
"import logging, logging.handlers\n"
"\n"
"rootLogger = logging.getLogger('')\n"
"rootLogger.setLevel(logging.DEBUG)\n"
"socketHandler = logging.handlers.SocketHandler('localhost',\n"
"                    logging.handlers.DEFAULT_TCP_LOGGING_PORT)\n"
"# don't bother with a formatter, since a socket handler sends the event as\n"
"# an unformatted pickle\n"
"rootLogger.addHandler(socketHandler)\n"
"\n"
"# Now, we can log to the root logger, or any other logger. First the "
"root...\n"
"logging.info('Jackdaws love my big sphinx of quartz.')\n"
"\n"
"# Now, define a couple of other loggers which might represent areas in your\n"
"# application:\n"
"\n"
"logger1 = logging.getLogger('myapp.area1')\n"
"logger2 = logging.getLogger('myapp.area2')\n"
"\n"
"logger1.debug('Quick zephyrs blow, vexing daft Jim.')\n"
"logger1.info('How quickly daft jumping zebras vex.')\n"
"logger2.warning('Jail zesty vixen who grabbed pay from quack.')\n"
"logger2.error('The five boxing wizards jump quickly.')"
msgstr ""
"import logging, logging.handlers\n"
"\n"
"rootLogger = logging.getLogger('')\n"
"rootLogger.setLevel(logging.DEBUG)\n"
"socketHandler = logging.handlers.SocketHandler('localhost',\n"
"                    logging.handlers.DEFAULT_TCP_LOGGING_PORT)\n"
"# no te molestes con un formateador, ya que un manejador de socket envía el "
"evento como\n"
"# un pickle sin formato\n"
"rootLogger.addHandler(socketHandler)\n"
"\n"
"# Ahora, podemos registrar en el root logger, o en cualquier otro logger. "
"Primero el root...\n"
"logging.info('A los grajos les encanta mi gran esfinge de cuarzo.')\n"
"\n"
"# Ahora, define un par de otros loggers que podrían representar áreas en tu\n"
"# aplicación:\n"
"\n"
"logger1 = logging.getLogger('myapp.area1')\n"
"logger2 = logging.getLogger('myapp.area2')\n"
"\n"
"logger1.debug('Rápido soplan los céfiros, vejando al tonto Jim.')\n"
"logger1.info('Qué rápido soplan las cebras saltarinas')\n"
"logger2.warning('Encarcela a la zorra que le quitó la paga al charlatán')\n"
"logger2.error('Los cinco magos boxeadores saltan rápidamente.')"

#: ../../howto/logging-cookbook.rst:662
msgid ""
"At the receiving end, you can set up a receiver using the :mod:"
"`socketserver` module. Here is a basic working example::"
msgstr ""
"En el extremo receptor, puede configurar un receptor utilizando el módulo :"
"mod:`socketserver`. He aquí un ejemplo de funcionamiento básico::"

#: ../../howto/logging-cookbook.rst:665
msgid ""
"import pickle\n"
"import logging\n"
"import logging.handlers\n"
"import socketserver\n"
"import struct\n"
"\n"
"\n"
"class LogRecordStreamHandler(socketserver.StreamRequestHandler):\n"
"    \"\"\"Handler for a streaming logging request.\n"
"\n"
"    This basically logs the record using whatever logging policy is\n"
"    configured locally.\n"
"    \"\"\"\n"
"\n"
"    def handle(self):\n"
"        \"\"\"\n"
"        Handle multiple requests - each expected to be a 4-byte length,\n"
"        followed by the LogRecord in pickle format. Logs the record\n"
"        according to whatever policy is configured locally.\n"
"        \"\"\"\n"
"        while True:\n"
"            chunk = self.connection.recv(4)\n"
"            if len(chunk) < 4:\n"
"                break\n"
"            slen = struct.unpack('>L', chunk)[0]\n"
"            chunk = self.connection.recv(slen)\n"
"            while len(chunk) < slen:\n"
"                chunk = chunk + self.connection.recv(slen - len(chunk))\n"
"            obj = self.unPickle(chunk)\n"
"            record = logging.makeLogRecord(obj)\n"
"            self.handleLogRecord(record)\n"
"\n"
"    def unPickle(self, data):\n"
"        return pickle.loads(data)\n"
"\n"
"    def handleLogRecord(self, record):\n"
"        # if a name is specified, we use the named logger rather than the "
"one\n"
"        # implied by the record.\n"
"        if self.server.logname is not None:\n"
"            name = self.server.logname\n"
"        else:\n"
"            name = record.name\n"
"        logger = logging.getLogger(name)\n"
"        # N.B. EVERY record gets logged. This is because Logger.handle\n"
"        # is normally called AFTER logger-level filtering. If you want\n"
"        # to do filtering, do it at the client end to save wasting\n"
"        # cycles and network bandwidth!\n"
"        logger.handle(record)\n"
"\n"
"class LogRecordSocketReceiver(socketserver.ThreadingTCPServer):\n"
"    \"\"\"\n"
"    Simple TCP socket-based logging receiver suitable for testing.\n"
"    \"\"\"\n"
"\n"
"    allow_reuse_address = True\n"
"\n"
"    def __init__(self, host='localhost',\n"
"                 port=logging.handlers.DEFAULT_TCP_LOGGING_PORT,\n"
"                 handler=LogRecordStreamHandler):\n"
"        socketserver.ThreadingTCPServer.__init__(self, (host, port), "
"handler)\n"
"        self.abort = 0\n"
"        self.timeout = 1\n"
"        self.logname = None\n"
"\n"
"    def serve_until_stopped(self):\n"
"        import select\n"
"        abort = 0\n"
"        while not abort:\n"
"            rd, wr, ex = select.select([self.socket.fileno()],\n"
"                                       [], [],\n"
"                                       self.timeout)\n"
"            if rd:\n"
"                self.handle_request()\n"
"            abort = self.abort\n"
"\n"
"def main():\n"
"    logging.basicConfig(\n"
"        format='%(relativeCreated)5d %(name)-15s %(levelname)-8s "
"%(message)s')\n"
"    tcpserver = LogRecordSocketReceiver()\n"
"    print('About to start TCP server...')\n"
"    tcpserver.serve_until_stopped()\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""
"import pickle\n"
"import logging\n"
"import logging.handlers\n"
"import socketserver\n"
"import struct\n"
"\n"
"\n"
"class LogRecordStreamHandler(socketserver.StreamRequestHandler):\n"
"   \"\"\"Manejador para una petición de registro de flujo.\n"
"\n"
"   Básicamente registra el registro utilizando la política de registro\n"
"   configurada localmente.\n"
"   \"\"\"\n"
"\n"
"    def handle(self):\n"
"       \"\"\"\n"
"       Maneja múltiples peticiones - se espera que cada una tenga una      "
"longitud de 4 bytes,\n"
"       seguido por el LogRecord en formato pickle. Registra el registro\n"
"según la política configurada localmente.\n"
"       \"\"\"\n"
"        while True:\n"
"            chunk = self.connection.recv(4)\n"
"            if len(chunk) < 4:\n"
"                break\n"
"            slen = struct.unpack('>L', chunk)[0]\n"
"            chunk = self.connection.recv(slen)\n"
"            while len(chunk) < slen:\n"
"                chunk = chunk + self.connection.recv(slen - len(chunk))\n"
"            obj = self.unPickle(chunk)\n"
"            record = logging.makeLogRecord(obj)\n"
"            self.handleLogRecord(record)\n"
"\n"
"    def unPickle(self, data):\n"
"        return pickle.loads(data)\n"
"\n"
"    def handleLogRecord(self, record):\n"
"        # si se especifica un nombre, usamos el logger nombrado en lugar del "
"que\n"
"        # implícito en el registro.\n"
"        si self.server.logname no es None:\n"
"            name = self.server.logname\n"
"        else:\n"
"            name = record.name\n"
"        logger = logging.getLogger(name)\n"
"       # N.B. TODOS los registros se registran. Esto se debe a que Logger."
"handle\n"
"       # normalmente se llama DESPUÉS del filtrado a nivel de logger. Si "
"desea\n"
"       # hacer el filtrado, hágalo en el extremo del cliente para ahorrar "
"ciclos de\n"
"       # ciclos y ancho de banda de la red.\n"
"        logger.handle(record)\n"
"\n"
"class LogRecordSocketReceiver(socketserver.ThreadingTCPServer):\n"
"     \"\"\"\n"
"    Simple receptor de registro basado en socket TCP adecuado para pruebas.\n"
"    \"\"\"\n"
"\n"
"    allow_reuse_address = True\n"
"\n"
"    def __init__(self, host='localhost',\n"
"                 port=logging.handlers.DEFAULT_TCP_LOGGING_PORT,\n"
"                 handler=LogRecordStreamHandler):\n"
"        socketserver.ThreadingTCPServer.__init__(self, (host, port), "
"handler)\n"
"        self.abort = 0\n"
"        self.timeout = 1\n"
"        self.logname = None\n"
"\n"
"    def serve_until_stopped(self):\n"
"        import select\n"
"        abort = 0\n"
"        while not abort:\n"
"            rd, wr, ex = select.select([self.socket.fileno()],\n"
"                                       [], [],\n"
"                                       self.timeout)\n"
"            if rd:\n"
"                self.handle_request()\n"
"            abort = self.abort\n"
"\n"
"def main():\n"
"    logging.basicConfig(\n"
"        format='%(relativeCreated)5d %(name)-15s %(levelname)-8s "
"%(message)s')\n"
"    tcpserver = LogRecordSocketReceiver()\n"
"    print('About to start TCP server...')\n"
"    tcpserver.serve_until_stopped()\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"

#: ../../howto/logging-cookbook.rst:750
msgid ""
"First run the server, and then the client. On the client side, nothing is "
"printed on the console; on the server side, you should see something like:"
msgstr ""
"Primero se ejecuta el servidor y luego el cliente. En el lado del cliente, "
"nada se imprime en la consola; en el lado del servidor, se debería ver algo "
"como:"

#: ../../howto/logging-cookbook.rst:753
msgid ""
"About to start TCP server...\n"
"   59 root            INFO     Jackdaws love my big sphinx of quartz.\n"
"   59 myapp.area1     DEBUG    Quick zephyrs blow, vexing daft Jim.\n"
"   69 myapp.area1     INFO     How quickly daft jumping zebras vex.\n"
"   69 myapp.area2     WARNING  Jail zesty vixen who grabbed pay from quack.\n"
"   69 myapp.area2     ERROR    The five boxing wizards jump quickly."
msgstr ""
"A punto de iniciar el servidor TCP...\n"
"   59 root INFO A los grajos les encanta mi gran esfinge de cuarzo.\n"
"   59 myapp.area1 DEBUG Rápido soplan los céfiros, vejando al tonto Jim.\n"
"   69 myapp.area1 INFO Qué rápidas son las cebras saltarinas.\n"
"   69 myapp.area2 WARNING Encarcela a la zorra que le quitó la paga al "
"charlatán.\n"
"   69 myapp.area2 ERROR Los cinco magos boxeadores saltan rápidamente."

#: ../../howto/logging-cookbook.rst:762
msgid ""
"Note that there are some security issues with pickle in some scenarios. If "
"these affect you, you can use an alternative serialization scheme by "
"overriding the :meth:`~SocketHandler.makePickle` method and implementing "
"your alternative there, as well as adapting the above script to use your "
"alternative serialization."
msgstr ""
"Ten en cuenta que hay algunos problemas de seguridad con pickle en algunos "
"escenarios. Si esto afecta, se puede usar un esquema de serialización "
"alternativo anulando el método :meth:`~SocketHandler.makePickle` e "
"implementando tu alternativa allí, así como adaptando el script anterior "
"para usar tu serialización alternativa."

#: ../../howto/logging-cookbook.rst:770
msgid "Running a logging socket listener in production"
msgstr "Ejecutar un receptor de socket de registro en producción"

#: ../../howto/logging-cookbook.rst:774
msgid ""
"To run a logging listener in production, you may need to use a process-"
"management tool such as `Supervisor <http://supervisord.org/>`_. `Here is a "
"Gist <socket-listener-gist_>`__ which provides the bare-bones files to run "
"the above functionality using Supervisor. It consists of the following files:"
msgstr ""
"Para ejecutar un logging listener en producción, puede que necesite utilizar "
"una herramienta de gestión de procesos como `Supervisor <http://supervisord."
"org/>`_. Aquí hay un Gist <socket-listener-gist_>`__ que proporciona los "
"archivos básicos para ejecutar la funcionalidad anterior utilizando "
"Supervisor. Consiste en los siguientes archivos:"

#: ../../howto/logging-cookbook.rst:781
msgid "File"
msgstr "Archivo"

#: ../../howto/logging-cookbook.rst:781
msgid "Purpose"
msgstr "Propósito"

#: ../../howto/logging-cookbook.rst:783
msgid ":file:`prepare.sh`"
msgstr ":file:`prepare.sh`"

#: ../../howto/logging-cookbook.rst:783
msgid "A Bash script to prepare the environment for testing"
msgstr "Un script Bash para preparar el entorno de pruebas"

#: ../../howto/logging-cookbook.rst:786
msgid ":file:`supervisor.conf`"
msgstr ":file:`supervisor.conf`"

#: ../../howto/logging-cookbook.rst:786
msgid ""
"The Supervisor configuration file, which has entries for the listener and a "
"multi-process web application"
msgstr ""
"El archivo de configuración del Supervisor, que contiene entradas para el "
"listener y una aplicación web multiproceso"

#: ../../howto/logging-cookbook.rst:790
msgid ":file:`ensure_app.sh`"
msgstr ":file:`ensure_app.sh`"

#: ../../howto/logging-cookbook.rst:790
msgid ""
"A Bash script to ensure that Supervisor is running with the above "
"configuration"
msgstr ""
"Un script Bash para asegurar que Supervisor se ejecuta con la configuración "
"anterior"

#: ../../howto/logging-cookbook.rst:793
msgid ":file:`log_listener.py`"
msgstr ":file:`log_listener.py`"

#: ../../howto/logging-cookbook.rst:793
msgid ""
"The socket listener program which receives log events and records them to a "
"file"
msgstr ""
"El programa de escucha de sockets que recibe los eventos de registro y los "
"graba en un archivo"

#: ../../howto/logging-cookbook.rst:796
msgid ":file:`main.py`"
msgstr ":file:`main.py`"

#: ../../howto/logging-cookbook.rst:796
msgid ""
"A simple web application which performs logging via a socket connected to "
"the listener"
msgstr ""
"Una aplicación web sencilla que realiza el registro a través de un socket "
"conectado al listener"

#: ../../howto/logging-cookbook.rst:799
msgid ":file:`webapp.json`"
msgstr ":file:`webapp.json`"

#: ../../howto/logging-cookbook.rst:799
msgid "A JSON configuration file for the web application"
msgstr "Un archivo de configuración JSON para la aplicación web"

#: ../../howto/logging-cookbook.rst:801
msgid ":file:`client.py`"
msgstr ":file:`client.py`"

#: ../../howto/logging-cookbook.rst:801
msgid "A Python script to exercise the web application"
msgstr "Un script en Python para ejercitar la aplicación web"

#: ../../howto/logging-cookbook.rst:804
msgid ""
"The web application uses `Gunicorn <https://gunicorn.org/>`_, which is a "
"popular web application server that starts multiple worker processes to "
"handle requests. This example setup shows how the workers can write to the "
"same log file without conflicting with one another --- they all go through "
"the socket listener."
msgstr ""
"La aplicación web utiliza `Gunicorn <https://gunicorn.org/>`_, que es un "
"popular servidor de aplicaciones web que inicia múltiples procesos worker "
"para manejar las peticiones. Este ejemplo de configuración muestra cómo los "
"trabajadores pueden escribir en el mismo archivo de registro sin entrar en "
"conflicto unos con otros --- todos van a través del socket listener."

#: ../../howto/logging-cookbook.rst:809
msgid "To test these files, do the following in a POSIX environment:"
msgstr "Para probar estos archivos, haga lo siguiente en un entorno POSIX:"

#: ../../howto/logging-cookbook.rst:811
msgid ""
"Download `the Gist <socket-listener-gist_>`__ as a ZIP archive using the :"
"guilabel:`Download ZIP` button."
msgstr ""
"Descargue `the Gist <socket-listener-gist_>`__ como archivo ZIP utilizando "
"el botón :guilabel:`Download ZIP`."

#: ../../howto/logging-cookbook.rst:814
msgid "Unzip the above files from the archive into a scratch directory."
msgstr ""
"Descomprima los archivos anteriores del archivo en un directorio de inicio."

#: ../../howto/logging-cookbook.rst:816
msgid ""
"In the scratch directory, run ``bash prepare.sh`` to get things ready. This "
"creates a :file:`run` subdirectory to contain Supervisor-related and log "
"files, and a :file:`venv` subdirectory to contain a virtual environment into "
"which ``bottle``, ``gunicorn`` and ``supervisor`` are installed."
msgstr ""
"En el directorio scratch, ejecute ``bash prepare.sh`` para preparar las "
"cosas. Esto crea un subdirectorio :file:`run` para contener los archivos "
"relacionados con el Supervisor y los archivos de registro, y un "
"subdirectorio :file:`venv` para contener un entorno virtual en el que se "
"instalan ``bottle``, ``gunicorn`` y ``supervisor``."

#: ../../howto/logging-cookbook.rst:821
msgid ""
"Run ``bash ensure_app.sh`` to ensure that Supervisor is running with the "
"above configuration."
msgstr ""
"Ejecute ``bash ensure_app.sh`` para asegurarse de que el Supervisor funciona "
"con la configuración anterior."

#: ../../howto/logging-cookbook.rst:824
msgid ""
"Run ``venv/bin/python client.py`` to exercise the web application, which "
"will lead to records being written to the log."
msgstr ""
"Ejecute ``venv/bin/python client.py`` para ejercitar la aplicación web, lo "
"que hará que se escriban registros en el log."

#: ../../howto/logging-cookbook.rst:827
msgid ""
"Inspect the log files in the :file:`run` subdirectory. You should see the "
"most recent log lines in files matching the pattern :file:`app.log*`. They "
"won't be in any particular order, since they have been handled concurrently "
"by different worker processes in a non-deterministic way."
msgstr ""
"Inspeccione los archivos de registro en el subdirectorio :file:`run`. "
"Debería ver las líneas de registro más recientes en archivos que coincidan "
"con el patrón :file:`app.log*`. No estarán en ningún orden en particular, ya "
"que han sido manejados concurrentemente por diferentes procesos de trabajo "
"de una manera no determinista."

#: ../../howto/logging-cookbook.rst:832
msgid ""
"You can shut down the listener and the web application by running ``venv/bin/"
"supervisorctl -c supervisor.conf shutdown``."
msgstr ""
"Puede cerrar el listener y la aplicación web ejecutando ``venv/bin/"
"supervisorctl -c supervisor.conf shutdown``."

#: ../../howto/logging-cookbook.rst:835
msgid ""
"You may need to tweak the configuration files in the unlikely event that the "
"configured ports clash with something else in your test environment."
msgstr ""
"Es posible que tenga que modificar los archivos de configuración en el "
"improbable caso de que los puertos configurados choquen con alguna otra cosa "
"en su entorno de pruebas."

#: ../../howto/logging-cookbook.rst:838
msgid ""
"The default configuration uses a TCP socket on port 9020. You can use a Unix "
"Domain socket instead of a TCP socket by doing the following:"
msgstr ""
"La configuración por defecto utiliza un socket TCP en el puerto 9020. Puede "
"utilizar un socket de dominio Unix en lugar de un socket TCP haciendo lo "
"siguiente:"

#: ../../howto/logging-cookbook.rst:841
msgid ""
"In :file:`listener.json`, add a ``socket`` key with the path to the domain "
"socket you want to use. If this key is present, the listener listens on the "
"corresponding domain socket and not on a TCP socket (the ``port`` key is "
"ignored)."
msgstr ""
"En :file:`listener.json`, añada una clave ``socket`` con la ruta al socket "
"de dominio que desea utilizar. Si esta clave está presente, el oyente "
"escucha en el socket de dominio correspondiente y no en un socket TCP (la "
"clave ``port`` se ignora)."

#: ../../howto/logging-cookbook.rst:846
msgid ""
"In :file:`webapp.json`, change the socket handler configuration dictionary "
"so that the ``host`` value is the path to the domain socket, and set the "
"``port`` value to ``null``."
msgstr ""
"En :file:`webapp.json`, cambie el diccionario de configuración del gestor de "
"sockets para que el valor ``host`` sea la ruta al socket del dominio, y "
"establezca el valor ``port`` en ``null``."

#: ../../howto/logging-cookbook.rst:856
msgid "Adding contextual information to your logging output"
msgstr "Añadir información contextual a la salida de registro"

#: ../../howto/logging-cookbook.rst:858
msgid ""
"Sometimes you want logging output to contain contextual information in "
"addition to the parameters passed to the logging call. For example, in a "
"networked application, it may be desirable to log client-specific "
"information in the log (e.g. remote client's username, or IP address). "
"Although you could use the *extra* parameter to achieve this, it's not "
"always convenient to pass the information in this way. While it might be "
"tempting to create :class:`Logger` instances on a per-connection basis, this "
"is not a good idea because these instances are not garbage collected. While "
"this is not a problem in practice, when the number of :class:`Logger` "
"instances is dependent on the level of granularity you want to use in "
"logging an application, it could be hard to manage if the number of :class:"
"`Logger` instances becomes effectively unbounded."
msgstr ""
"A veces se desea que la salida de registro contenga información contextual "
"además de los parámetros pasados a la llamada de registro. Por ejemplo, en "
"una aplicación en red, puede ser deseable registrar información específica "
"del cliente en el registro (por ejemplo, el nombre de usuario del cliente "
"remoto, o la dirección IP). Aunque podría utilizar el parámetro *extra* para "
"conseguirlo, no siempre es conveniente pasar la información de esta forma. "
"Aunque puede ser tentador crear instancias de :class:`Logger` por conexión, "
"no es una buena idea porque estas instancias no se recogen de la basura. Si "
"bien esto no es un problema en la práctica, cuando el número de instancias :"
"class:`Logger` depende del nivel de granularidad que se desea utilizar en el "
"registro de una aplicación, podría ser difícil de gestionar si el número de "
"instancias :class:`Logger` se vuelve efectivamente ilimitado."

#: ../../howto/logging-cookbook.rst:873
msgid "Using LoggerAdapters to impart contextual information"
msgstr "Uso de LoggerAdapters para transmitir información contextual"

#: ../../howto/logging-cookbook.rst:875
msgid ""
"An easy way in which you can pass contextual information to be output along "
"with logging event information is to use the :class:`LoggerAdapter` class. "
"This class is designed to look like a :class:`Logger`, so that you can call :"
"meth:`debug`, :meth:`info`, :meth:`warning`, :meth:`error`, :meth:"
"`exception`, :meth:`critical` and :meth:`log`. These methods have the same "
"signatures as their counterparts in :class:`Logger`, so you can use the two "
"types of instances interchangeably."
msgstr ""
"Una forma sencilla de pasar información contextual a la salida junto con la "
"información de eventos de registro es utilizar la clase :class:"
"`LoggerAdapter`. Esta clase está diseñada para parecerse a :class:`Logger`, "
"de modo que puede llamar a :meth:`debug`, :meth:`info`, :meth:`warning`, :"
"meth:`error`, :meth:`exception`, :meth:`critical` y :meth:`log`. Estos "
"métodos tienen las mismas firmas que sus homólogos en :class:`Logger`, por "
"lo que puede utilizar los dos tipos de instancias indistintamente."

#: ../../howto/logging-cookbook.rst:883
msgid ""
"When you create an instance of :class:`LoggerAdapter`, you pass it a :class:"
"`Logger` instance and a dict-like object which contains your contextual "
"information. When you call one of the logging methods on an instance of :"
"class:`LoggerAdapter`, it delegates the call to the underlying instance of :"
"class:`Logger` passed to its constructor, and arranges to pass the "
"contextual information in the delegated call. Here's a snippet from the code "
"of :class:`LoggerAdapter`::"
msgstr ""
"Cuando creas una instancia de :class:`LoggerAdapter`, le pasas una instancia "
"de :class:`Logger` y un objeto tipo dict que contiene tu información "
"contextual. Cuando se llama a uno de los métodos de registro en una "
"instancia de :class:`LoggerAdapter`, se delega la llamada a la instancia "
"subyacente de :class:`Logger` pasada a su constructor, y se arregla para "
"pasar la información contextual en la llamada delegada. He aquí un fragmento "
"del código de :class:`LoggerAdapter`::"

#: ../../howto/logging-cookbook.rst:891
msgid ""
"def debug(self, msg, /, *args, **kwargs):\n"
"    \"\"\"\n"
"    Delegate a debug call to the underlying logger, after adding\n"
"    contextual information from this adapter instance.\n"
"    \"\"\"\n"
"    msg, kwargs = self.process(msg, kwargs)\n"
"    self.logger.debug(msg, *args, **kwargs)"
msgstr ""
"def debug(self, msg, /, *args, **kwargs):\n"
"    \"\"\"\n"
"    Delegar una llamada de depuración al registrador subyacente, después de "
"añadir\n"
"    información contextual de esta instancia de adaptador.\n"
"    \"\"\"\n"
"    msg, kwargs = self.process(msg, kwargs)\n"
"    self.logger.debug(msg, *args, **kwargs)"

#: ../../howto/logging-cookbook.rst:899
msgid ""
"The :meth:`~LoggerAdapter.process` method of :class:`LoggerAdapter` is where "
"the contextual information is added to the logging output. It's passed the "
"message and keyword arguments of the logging call, and it passes back "
"(potentially) modified versions of these to use in the call to the "
"underlying logger. The default implementation of this method leaves the "
"message alone, but inserts an 'extra' key in the keyword argument whose "
"value is the dict-like object passed to the constructor. Of course, if you "
"had passed an 'extra' keyword argument in the call to the adapter, it will "
"be silently overwritten."
msgstr ""
"El método :meth:`~LoggerAdapter.process` de :class:`LoggerAdapter` es donde "
"se añade la información contextual a la salida de registro. Se le pasan los "
"argumentos de mensaje y palabra clave de la llamada de registro, y devuelve "
"versiones (potencialmente) modificadas de éstos para usarlas en la llamada "
"al registrador subyacente. La implementación por defecto de este método deja "
"el mensaje como está, pero inserta una clave 'extra' en el argumento de la "
"palabra clave cuyo valor es el objeto tipo dict pasado al constructor. Por "
"supuesto, si has pasado un argumento de palabra clave 'extra' en la llamada "
"al adaptador, se sobrescribirá silenciosamente."

#: ../../howto/logging-cookbook.rst:908
msgid ""
"The advantage of using 'extra' is that the values in the dict-like object "
"are merged into the :class:`LogRecord` instance's __dict__, allowing you to "
"use customized strings with your :class:`Formatter` instances which know "
"about the keys of the dict-like object. If you need a different method, e.g. "
"if you want to prepend or append the contextual information to the message "
"string, you just need to subclass :class:`LoggerAdapter` and override :meth:"
"`~LoggerAdapter.process` to do what you need. Here is a simple example::"
msgstr ""
"La ventaja de usar 'extra' es que los valores del objeto dict-like se "
"fusionan en el __dict__ de la instancia :class:`LogRecord`, permitiendo usar "
"cadenas personalizadas con tus instancias :class:`Formatter` que conocen las "
"claves del objeto dict-like. Si necesita un método diferente, por ejemplo, "
"si se desea añadir :class:`LoggerAdapter`la información contextual a la "
"cadena de mensaje, sólo tiene que subdividir  y anular :meth:`~LoggerAdapter."
"process` para hacer lo que necesita. He aquí un ejemplo sencillo::"

#: ../../howto/logging-cookbook.rst:916
msgid ""
"class CustomAdapter(logging.LoggerAdapter):\n"
"    \"\"\"\n"
"    This example adapter expects the passed in dict-like object to have a\n"
"    'connid' key, whose value in brackets is prepended to the log message.\n"
"    \"\"\"\n"
"    def process(self, msg, kwargs):\n"
"        return '[%s] %s' % (self.extra['connid'], msg), kwargs"
msgstr ""
"class CustomAdapter(logging.LoggerAdapter):\n"
"    \"\"\"\n"
"    Este adaptador de ejemplo espera que el objeto dict-like pasado tenga "
"una clave\n"
"    cuyo valor entre paréntesis se añade al mensaje de registro.\n"
"    \"\"\"\n"
"    def process(self, msg, kwargs):\n"
"        return '[%s] %s' % (self.extra['connid'], msg), kwargs"

#: ../../howto/logging-cookbook.rst:924
msgid "which you can use like this::"
msgstr "que puedes usar así::"

#: ../../howto/logging-cookbook.rst:926
msgid ""
"logger = logging.getLogger(__name__)\n"
"adapter = CustomAdapter(logger, {'connid': some_conn_id})"
msgstr ""
"logger = logging.getLogger(__name__)\n"
"adapter = CustomAdapter(logger, {'connid': some_conn_id})"

#: ../../howto/logging-cookbook.rst:929
msgid ""
"Then any events that you log to the adapter will have the value of "
"``some_conn_id`` prepended to the log messages."
msgstr ""
"Entonces, cualquier hecho que registre en el adaptador tendrá el valor de "
"``some_conn_id`` añadido a los mensajes de registro."

#: ../../howto/logging-cookbook.rst:933
msgid "Using objects other than dicts to pass contextual information"
msgstr ""
"Utilización de objetos distintos de los dicts para transmitir información "
"contextual"

#: ../../howto/logging-cookbook.rst:935
msgid ""
"You don't need to pass an actual dict to a :class:`LoggerAdapter` - you "
"could pass an instance of a class which implements ``__getitem__`` and "
"``__iter__`` so that it looks like a dict to logging. This would be useful "
"if you want to generate values dynamically (whereas the values in a dict "
"would be constant)."
msgstr ""
"No se necesita pasar un dict real a :class:`LoggerAdapter` - se puede pasar "
"una instancia de una clase que implemente ``__getitem__`` y ``__iter__`` "
"para que parezca un dict en el registro. Esto sería útil si se quiere "
"generar valores dinámicamente (mientras que los valores en un dict serían "
"constantes)."

#: ../../howto/logging-cookbook.rst:944
msgid "Using Filters to impart contextual information"
msgstr "Filtros para dar información contextual"

#: ../../howto/logging-cookbook.rst:946
msgid ""
"You can also add contextual information to log output using a user-defined :"
"class:`Filter`. ``Filter`` instances are allowed to modify the "
"``LogRecords`` passed to them, including adding additional attributes which "
"can then be output using a suitable format string, or if needed a custom :"
"class:`Formatter`."
msgstr ""
"También se puede añadir información contextual a la salida del registro "
"utilizando un :class:`Filter` definido por el usuario. Las instancias de "
"``Filter`` pueden modificar el ``LogRecords`` que se les pasa, incluyendo la "
"adición de atributos adicionales que luego pueden ser emitidos utilizando "
"una cadena de formato adecuada o, si es necesario, un :class:`Formatter` "
"personalizado."

#: ../../howto/logging-cookbook.rst:951
msgid ""
"For example in a web application, the request being processed (or at least, "
"the interesting parts of it) can be stored in a threadlocal (:class:"
"`threading.local`) variable, and then accessed from a ``Filter`` to add, "
"say, information from the request - say, the remote IP address and remote "
"user's username - to the ``LogRecord``, using the attribute names 'ip' and "
"'user' as in the ``LoggerAdapter`` example above. In that case, the same "
"format string can be used to get similar output to that shown above. Here's "
"an example script::"
msgstr ""
"Por ejemplo, en una aplicación web, la petición que está siendo procesada (o "
"al menos, las partes interesantes de la misma) se pueden almacenar en una "
"variable threadlocal (:class:`threading.local`), y luego accedida desde "
"``Filter`` para añadir, digamos, información de la petición - digamos, la "
"dirección IP remota y el nombre de usuario del usuario remoto - a "
"``LogRecord``, usando los nombres de atributo 'ip' y 'user' como en el "
"ejemplo ``LoggerAdapter`` anterior. En ese caso, se puede utilizar la misma "
"cadena de formato para obtener una salida similar a la mostrada "
"anteriormente. He aquí un script de ejemplo::"

#: ../../howto/logging-cookbook.rst:960
msgid ""
"import logging\n"
"from random import choice\n"
"\n"
"class ContextFilter(logging.Filter):\n"
"    \"\"\"\n"
"    This is a filter which injects contextual information into the log.\n"
"\n"
"    Rather than use actual contextual information, we just use random\n"
"    data in this demo.\n"
"    \"\"\"\n"
"\n"
"    USERS = ['jim', 'fred', 'sheila']\n"
"    IPS = ['123.231.231.123', '127.0.0.1', '192.168.0.1']\n"
"\n"
"    def filter(self, record):\n"
"\n"
"        record.ip = choice(ContextFilter.IPS)\n"
"        record.user = choice(ContextFilter.USERS)\n"
"        return True\n"
"\n"
"if __name__ == '__main__':\n"
"    levels = (logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR, "
"logging.CRITICAL)\n"
"    logging.basicConfig(level=logging.DEBUG,\n"
"                        format='%(asctime)-15s %(name)-5s %(levelname)-8s "
"IP: %(ip)-15s User: %(user)-8s %(message)s')\n"
"    a1 = logging.getLogger('a.b.c')\n"
"    a2 = logging.getLogger('d.e.f')\n"
"\n"
"    f = ContextFilter()\n"
"    a1.addFilter(f)\n"
"    a2.addFilter(f)\n"
"    a1.debug('A debug message')\n"
"    a1.info('An info message with %s', 'some parameters')\n"
"    for x in range(10):\n"
"        lvl = choice(levels)\n"
"        lvlname = logging.getLevelName(lvl)\n"
"        a2.log(lvl, 'A message at %s level with %d %s', lvlname, 2, "
"'parameters')"
msgstr ""
"import logging\n"
"from random import election\n"
"\n"
"class ContextFilter(logging.Filter):\n"
"    \"\"\"\n"
"    Se trata de un filtro que inyecta información contextual en el "
"registro.\n"
"\n"
"    En lugar de utilizar información contextual real, en esta demostración "
"utilizamos datos aleatorios.\n"
"    aleatorios en esta demostración.\n"
"    \"\"\"\n"
"\n"
"    USERS = ['jim', 'fred', 'sheila']\n"
"    IPS = ['123.231.231.123', '127.0.0.1', '192.168.0.1']\n"
"\n"
"    def filter(self, record):\n"
"\n"
"        record.ip = choice(ContextFilter.IPS)\n"
"        record.user = choice(ContextFilter.USERS)\n"
"       return True\n"
"\n"
"if __name__ == '__main__':\n"
"    levels = (logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR, "
"logging.CRITICAL)\n"
"    logging.basicConfig(nivel=logging.DEBUG,\n"
"                        format='%(asctime)-15s %(name)-5s %(levelname)-8s "
"IP: %(ip)-15s Usuario: %(user)-8s %(message)s ')\n"
"    a1 = logging.getLogger('a.b.c')\n"
"    a2 = logging.getLogger('d.e.f')\n"
"\n"
"    f = ContextFilter()\n"
"    a1.addFilter(f)\n"
"    a2.addFilter(f)\n"
"    a1.debug('Un mensaje de depuración')\n"
"    a1.info('Un mensaje de información con %s', 'algunos parámetros')\n"
"    for x in range(10):\n"
"        lvl = choice(niveles)\n"
"        lvlname = logging.getNombreNivel(lvl)\n"
"        a2.log(lvl, 'Un mensaje en el nivel %s con %d %s ', lvlname, 2, "
"'parámetros')"

#: ../../howto/logging-cookbook.rst:997
msgid "which, when run, produces something like:"
msgstr "que, cuando se ejecuta, produce algo como:"

#: ../../howto/logging-cookbook.rst:999
msgid ""
"2010-09-06 22:38:15,292 a.b.c DEBUG    IP: 123.231.231.123 User: fred     A "
"debug message\n"
"2010-09-06 22:38:15,300 a.b.c INFO     IP: 192.168.0.1     User: sheila   An "
"info message with some parameters\n"
"2010-09-06 22:38:15,300 d.e.f CRITICAL IP: 127.0.0.1       User: sheila   A "
"message at CRITICAL level with 2 parameters\n"
"2010-09-06 22:38:15,300 d.e.f ERROR    IP: 127.0.0.1       User: jim      A "
"message at ERROR level with 2 parameters\n"
"2010-09-06 22:38:15,300 d.e.f DEBUG    IP: 127.0.0.1       User: sheila   A "
"message at DEBUG level with 2 parameters\n"
"2010-09-06 22:38:15,300 d.e.f ERROR    IP: 123.231.231.123 User: fred     A "
"message at ERROR level with 2 parameters\n"
"2010-09-06 22:38:15,300 d.e.f CRITICAL IP: 192.168.0.1     User: jim      A "
"message at CRITICAL level with 2 parameters\n"
"2010-09-06 22:38:15,300 d.e.f CRITICAL IP: 127.0.0.1       User: sheila   A "
"message at CRITICAL level with 2 parameters\n"
"2010-09-06 22:38:15,300 d.e.f DEBUG    IP: 192.168.0.1     User: jim      A "
"message at DEBUG level with 2 parameters\n"
"2010-09-06 22:38:15,301 d.e.f ERROR    IP: 127.0.0.1       User: sheila   A "
"message at ERROR level with 2 parameters\n"
"2010-09-06 22:38:15,301 d.e.f DEBUG    IP: 123.231.231.123 User: fred     A "
"message at DEBUG level with 2 parameters\n"
"2010-09-06 22:38:15,301 d.e.f INFO     IP: 123.231.231.123 User: fred     A "
"message at INFO level with 2 parameters"
msgstr ""
"2010-09-06 22:38:15,292 a.b.c DEBUG    IP: 123.231.231.123 User: fred     A "
"debug message\n"
"2010-09-06 22:38:15,300 a.b.c INFO     IP: 192.168.0.1     User: sheila   An "
"info message with some parameters\n"
"2010-09-06 22:38:15,300 d.e.f CRITICAL IP: 127.0.0.1       User: sheila   A "
"message at CRITICAL level with 2 parameters\n"
"2010-09-06 22:38:15,300 d.e.f ERROR    IP: 127.0.0.1       User: jim      A "
"message at ERROR level with 2 parameters\n"
"2010-09-06 22:38:15,300 d.e.f DEBUG    IP: 127.0.0.1       User: sheila   A "
"message at DEBUG level with 2 parameters\n"
"2010-09-06 22:38:15,300 d.e.f ERROR    IP: 123.231.231.123 User: fred     A "
"message at ERROR level with 2 parameters\n"
"2010-09-06 22:38:15,300 d.e.f CRITICAL IP: 192.168.0.1     User: jim      A "
"message at CRITICAL level with 2 parameters\n"
"2010-09-06 22:38:15,300 d.e.f CRITICAL IP: 127.0.0.1       User: sheila   A "
"message at CRITICAL level with 2 parameters\n"
"2010-09-06 22:38:15,300 d.e.f DEBUG    IP: 192.168.0.1     User: jim      A "
"message at DEBUG level with 2 parameters\n"
"2010-09-06 22:38:15,301 d.e.f ERROR    IP: 127.0.0.1       User: sheila   A "
"message at ERROR level with 2 parameters\n"
"2010-09-06 22:38:15,301 d.e.f DEBUG    IP: 123.231.231.123 User: fred     A "
"message at DEBUG level with 2 parameters\n"
"2010-09-06 22:38:15,301 d.e.f INFO     IP: 123.231.231.123 User: fred     A "
"message at INFO level with 2 parameters"

#: ../../howto/logging-cookbook.rst:1015
msgid "Use of ``contextvars``"
msgstr "Uso de ``contextvars``"

#: ../../howto/logging-cookbook.rst:1017
msgid ""
"Since Python 3.7, the :mod:`contextvars` module has provided context-local "
"storage which works for both :mod:`threading` and :mod:`asyncio` processing "
"needs. This type of storage may thus be generally preferable to thread-"
"locals. The following example shows how, in a multi-threaded environment, "
"logs can populated with contextual information such as, for example, request "
"attributes handled by web applications."
msgstr ""
"Desde Python 3.7, el módulo :mod:`contextvars` ha proporcionado "
"almacenamiento local de contexto que funciona tanto para las necesidades de "
"procesamiento de :mod:`threading` como de :mod:`asyncio`. Por lo tanto, este "
"tipo de almacenamiento puede ser generalmente preferible a los thread-"
"locals. El siguiente ejemplo muestra cómo, en un entorno multihilo, los "
"registros pueden rellenarse con información contextual como, por ejemplo, "
"atributos de petición manejados por aplicaciones web."

#: ../../howto/logging-cookbook.rst:1023
msgid ""
"For the purposes of illustration, say that you have different web "
"applications, each independent of the other but running in the same Python "
"process and using a library common to them. How can each of these "
"applications have their own log, where all logging messages from the library "
"(and other request processing code) are directed to the appropriate "
"application's log file, while including in the log additional contextual "
"information such as client IP, HTTP request method and client username?"
msgstr ""
"A efectos ilustrativos, supongamos que tenemos diferentes aplicaciones web, "
"cada una independiente de la otra pero ejecutándose en el mismo proceso "
"Python y utilizando una librería común a todas ellas. ¿Cómo puede cada una "
"de estas aplicaciones tener su propio registro, donde todos los mensajes de "
"registro de la biblioteca (y otro código de procesamiento de peticiones) se "
"dirijan al archivo de registro de la aplicación apropiada, incluyendo al "
"mismo tiempo en el registro información contextual adicional como la IP del "
"cliente, el método de petición HTTP y el nombre de usuario del cliente?"

#: ../../howto/logging-cookbook.rst:1030
msgid "Let's assume that the library can be simulated by the following code:"
msgstr ""
"Supongamos que la biblioteca puede simularse mediante el siguiente código:"

#: ../../howto/logging-cookbook.rst:1032
msgid ""
"# webapplib.py\n"
"import logging\n"
"import time\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"def useful():\n"
"    # Just a representative event logged from the library\n"
"    logger.debug('Hello from webapplib!')\n"
"    # Just sleep for a bit so other threads get to run\n"
"    time.sleep(0.01)"
msgstr ""
"# webapplib.py\n"
"import logging\n"
"import time\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"def útil():\n"
"    # Sólo un hecho representativo registrado desde la librería\n"
"    logger.debug('¡Hola desde webapplib!')\n"
"    # Duerme un poco para que otros hilos puedan ejecutarse\n"
"    time.sleep(0.01)"

#: ../../howto/logging-cookbook.rst:1046
msgid ""
"We can simulate the multiple web applications by means of two simple "
"classes, ``Request`` and ``WebApp``. These simulate how real threaded web "
"applications work - each request is handled by a thread:"
msgstr ""
"Podemos simular las aplicaciones web múltiples mediante dos clases "
"sencillas, ``Request`` y ``WebApp``. Éstas simulan cómo funcionan las "
"aplicaciones web con hilos reales: cada petición es gestionada por un hilo:"

#: ../../howto/logging-cookbook.rst:1050
msgid ""
"# main.py\n"
"import argparse\n"
"from contextvars import ContextVar\n"
"import logging\n"
"import os\n"
"from random import choice\n"
"import threading\n"
"import webapplib\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"root = logging.getLogger()\n"
"root.setLevel(logging.DEBUG)\n"
"\n"
"class Request:\n"
"    \"\"\"\n"
"    A simple dummy request class which just holds dummy HTTP request "
"method,\n"
"    client IP address and client username\n"
"    \"\"\"\n"
"    def __init__(self, method, ip, user):\n"
"        self.method = method\n"
"        self.ip = ip\n"
"        self.user = user\n"
"\n"
"# A dummy set of requests which will be used in the simulation - we'll just "
"pick\n"
"# from this list randomly. Note that all GET requests are from 192.168.2."
"XXX\n"
"# addresses, whereas POST requests are from 192.16.3.XXX addresses. Three "
"users\n"
"# are represented in the sample requests.\n"
"\n"
"REQUESTS = [\n"
"    Request('GET', '192.168.2.20', 'jim'),\n"
"    Request('POST', '192.168.3.20', 'fred'),\n"
"    Request('GET', '192.168.2.21', 'sheila'),\n"
"    Request('POST', '192.168.3.21', 'jim'),\n"
"    Request('GET', '192.168.2.22', 'fred'),\n"
"    Request('POST', '192.168.3.22', 'sheila'),\n"
"]\n"
"\n"
"# Note that the format string includes references to request context "
"information\n"
"# such as HTTP method, client IP and username\n"
"\n"
"formatter = logging.Formatter('%(threadName)-11s %(appName)s %(name)-9s "
"%(user)-6s %(ip)s %(method)-4s %(message)s')\n"
"\n"
"# Create our context variables. These will be filled at the start of "
"request\n"
"# processing, and used in the logging that happens during that processing\n"
"\n"
"ctx_request = ContextVar('request')\n"
"ctx_appname = ContextVar('appname')\n"
"\n"
"class InjectingFilter(logging.Filter):\n"
"    \"\"\"\n"
"    A filter which injects context-specific information into logs and "
"ensures\n"
"    that only information for a specific webapp is included in its log\n"
"    \"\"\"\n"
"    def __init__(self, app):\n"
"        self.app = app\n"
"\n"
"    def filter(self, record):\n"
"        request = ctx_request.get()\n"
"        record.method = request.method\n"
"        record.ip = request.ip\n"
"        record.user = request.user\n"
"        record.appName = appName = ctx_appname.get()\n"
"        return appName == self.app.name\n"
"\n"
"class WebApp:\n"
"    \"\"\"\n"
"    A dummy web application class which has its own handler and filter for "
"a\n"
"    webapp-specific log.\n"
"    \"\"\"\n"
"    def __init__(self, name):\n"
"        self.name = name\n"
"        handler = logging.FileHandler(name + '.log', 'w')\n"
"        f = InjectingFilter(self)\n"
"        handler.setFormatter(formatter)\n"
"        handler.addFilter(f)\n"
"        root.addHandler(handler)\n"
"        self.num_requests = 0\n"
"\n"
"    def process_request(self, request):\n"
"        \"\"\"\n"
"        This is the dummy method for processing a request. It's called on a\n"
"        different thread for every request. We store the context information "
"into\n"
"        the context vars before doing anything else.\n"
"        \"\"\"\n"
"        ctx_request.set(request)\n"
"        ctx_appname.set(self.name)\n"
"        self.num_requests += 1\n"
"        logger.debug('Request processing started')\n"
"        webapplib.useful()\n"
"        logger.debug('Request processing finished')\n"
"\n"
"def main():\n"
"    fn = os.path.splitext(os.path.basename(__file__))[0]\n"
"    adhf = argparse.ArgumentDefaultsHelpFormatter\n"
"    ap = argparse.ArgumentParser(formatter_class=adhf, prog=fn,\n"
"                                 description='Simulate a couple of web '\n"
"                                             'applications handling some '\n"
"                                             'requests, showing how request "
"'\n"
"                                             'context can be used to '\n"
"                                             'populate logs')\n"
"    aa = ap.add_argument\n"
"    aa('--count', '-c', type=int, default=100, help='How many requests to "
"simulate')\n"
"    options = ap.parse_args()\n"
"\n"
"    # Create the dummy webapps and put them in a list which we can use to "
"select\n"
"    # from randomly\n"
"    app1 = WebApp('app1')\n"
"    app2 = WebApp('app2')\n"
"    apps = [app1, app2]\n"
"    threads = []\n"
"    # Add a common handler which will capture all events\n"
"    handler = logging.FileHandler('app.log', 'w')\n"
"    handler.setFormatter(formatter)\n"
"    root.addHandler(handler)\n"
"\n"
"    # Generate calls to process requests\n"
"    for i in range(options.count):\n"
"        try:\n"
"            # Pick an app at random and a request for it to process\n"
"            app = choice(apps)\n"
"            request = choice(REQUESTS)\n"
"            # Process the request in its own thread\n"
"            t = threading.Thread(target=app.process_request, "
"args=(request,))\n"
"            threads.append(t)\n"
"            t.start()\n"
"        except KeyboardInterrupt:\n"
"            break\n"
"\n"
"    # Wait for the threads to terminate\n"
"    for t in threads:\n"
"        t.join()\n"
"\n"
"    for app in apps:\n"
"        print('%s processed %s requests' % (app.name, app.num_requests))\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""
"# main.py\n"
"import argparse\n"
"from contextvars import ContextVar\n"
"import logging\n"
"import os\n"
"from random import choice\n"
"import threading\n"
"import webapplib\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"root = logging.getLogger()\n"
"root.setLevel(logging.DEBUG)\n"
"\n"
"class Request:\n"
"    \"\"\"\n"
"    Una simple clase de petición que sólo contiene un método de petición "
"HTTP ficticio,\n"
"    dirección IP y nombre de usuario del cliente\n"
"    \"\"\"\n"
"    def __init__(self, method, ip, user):\n"
"        self.method = method\n"
"        self.ip = ip\n"
"        self.usuario = usuario\n"
"\n"
"# Un conjunto ficticio de peticiones que se utilizarán en la simulación.\n"
"# de esta lista aleatoriamente. Nótese que todas las peticiones GET "
"provienen de direcciones 192.168.2.XXX\n"
"# mientras que las peticiones POST provienen de 192.16.3.XXX. Tres usuarios\n"
"# están representados en las peticiones de ejemplo.\n"
"\n"
"REQUESTS = [\n"
"    Request('GET', '192.168.2.20', 'jim'),\n"
"    Request('POST', '192.168.3.20', 'fred'),\n"
"    Request('GET', '192.168.2.21', 'sheila'),\n"
"    Request('POST', '192.168.3.21', 'jim'),\n"
"    Request('GET', '192.168.2.22', 'fred'),\n"
"    Request('POST', '192.168.3.22', 'sheila'),\n"
"]\n"
"\n"
"# Tenga en cuenta que la cadena de formato incluye referencias a la "
"información de contexto de la solicitud\n"
"# como el método HTTP, la IP del cliente y el nombre de usuario\n"
"\n"
"formatter = logging.Formatter('%(threadName)-11s %(appName)s %(name)-9s "
"%(user)-6s %(ip)s %(method)-4s %(message)s ')\n"
"\n"
"# Crear nuestras variables de contexto. Se rellenarán al inicio del "
"procesamiento # de la petición y se utilizarán en el registro.\n"
"# y se utilizarán en el registro que se produzca durante ese procesamiento.\n"
"\n"
"ctx_request = ContextVar('request')\n"
"ctx_appname = ContextVar('appname')\n"
"\n"
"class InjectingFilter(logging.Filter):\n"
"    \"\"\"\n"
"    Un filtro que inyecta información específica del contexto en los "
"registros y garantiza\n"
"    que sólo la información para una aplicación web específica se incluye en "
"su registro\n"
"    \"\"\"\n"
"    def __init__(self, app):\n"
"        self.app = app\n"
"\n"
"    def filter(self, registro):\n"
"        request = ctx_request.get()\n"
"        record.method = request.method\n"
"        record.ip = request.ip\n"
"        record.user = request.user\n"
"        record.appName = appName = ctx_appname.get()\n"
"        return appName == self.app.name\n"
"\n"
"clase WebApp:\n"
"    \"\"\"\n"
"    Una clase de aplicación web ficticia que tiene su propio manejador y "
"filtro para un\n"
"    registro específico de la aplicación web.\n"
"    \"\"\"\n"
"    def __init__(self, name):\n"
"           self.name = name\n"
"           handler = logging.FileHandler(name + '.log', 'w')\n"
"            f = InjectingFilter(self)\n"
"            handler.setFormatter(formatter)\n"
"            handler.addFilter(f)\n"
"            root.addHandler(handler)\n"
"            self.num_requests = 0\n"
"\n"
"def process_request(self, request)::\n"
"        \"\"\"\n"
"        Este es el método ficticio para procesar una petición. Es llamado en "
"un\n"
"        diferente para cada petición. Almacenamos la información de contexto "
"en\n"
"        en las variables de contexto antes de hacer nada más.\n"
"        \"\"\"\n"
"        ctx_request.set(request)\n"
"        ctx_appname.set(self.name)\n"
"        self.num_requests += 1\n"
"        logger.debug('Request processing started')\n"
"        webapplib.useful()\n"
"        logger.debug('Request processing finished')\n"
"def main():\n"
"       fn = os.path.splitext(os.path.basename(__file__))[0]\n"
"       adhf = argparse.ArgumentDefaultsHelpFormatter\n"
"       ap = argparse.ArgumentParser(formatter_class=adhf, prog=fn,\n"
"                                 description='Simular un par de aplicaciones "
"web '\n"
"                                             'aplicaciones web que gestionan "
"algunas '\n"
"                                             'peticiones, mostrando cómo el "
"contexto '\n"
"                                             'se puede utilizar para '\n"
"                                             'rellenar registros')\n"
"    aa = ap.add_argument\n"
"    aa('--count', '-c', type=int, default=100, help='Cuántas peticiones "
"simular')\n"
"    options = ap.parse_args()\n"
"\n"
"    # Crear las webapps ficticias y ponerlas en una lista que podamos usar "
"para seleccionar\n"
"    # de forma aleatoria\n"
"    app1 = WebApp('app1')\n"
"    app2 = WebApp('app2')\n"
"    apps = [app1, app2]\n"
"    hilos = []\n"
"    # Añade un manejador común que capturará todos los hechos\n"
"    handler = logging.FileHandler('app.log', 'w')\n"
"    handler.setFormatter(formatter)\n"
"    root.addHandler(handler)\n"
"\n"
"    # Generar llamadas para procesar peticiones\n"
"    for i in range(options.count):\n"
"        try:\n"
"            # Elige una app al azar y una petición para procesar\n"
"            app = choice(apps)\n"
"            request = choice(REQUESTS)\n"
"            # Procesar la solicitud en su propio hilo\n"
"            t = threading.Thread(target=app.process_request, "
"args=(request,))\n"
"            threads.append(t)\n"
"            t.start()\n"
"        except KeyboardInterrupt:\n"
"            break\n"
"\n"
"    # Esperar a que los hilos terminen\n"
"    for t in hilos:\n"
"        t.join()\n"
"\n"
"    for app in apps:\n"
"        print('%s processed %s requests' % (app.name, app.num_requests))\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"

#: ../../howto/logging-cookbook.rst:1190
msgid ""
"If you run the above, you should find that roughly half the requests go "
"into :file:`app1.log` and the rest into :file:`app2.log`, and the all the "
"requests are logged to :file:`app.log`. Each webapp-specific log will "
"contain only log entries for only that webapp, and the request information "
"will be displayed consistently in the log (i.e. the information in each "
"dummy request will always appear together in a log line). This is "
"illustrated by the following shell output:"
msgstr ""
"Si ejecuta lo anterior, debería encontrar que aproximadamente la mitad de "
"las peticiones van a :file:`app1.log` y el resto a :file:`app2.log`, y que "
"todas las peticiones se registran en :file:`app.log`. Cada registro "
"específico de la aplicación web contendrá sólo entradas de registro para esa "
"aplicación web, y la información de la petición se mostrará de forma "
"consistente en el registro (es decir, la información de cada petición "
"ficticia aparecerá siempre junta en una línea de registro). Esto se ilustra "
"con la siguiente salida del shell:"

#: ../../howto/logging-cookbook.rst:1197
msgid ""
"~/logging-contextual-webapp$ python main.py\n"
"app1 processed 51 requests\n"
"app2 processed 49 requests\n"
"~/logging-contextual-webapp$ wc -l *.log\n"
"  153 app1.log\n"
"  147 app2.log\n"
"  300 app.log\n"
"  600 total\n"
"~/logging-contextual-webapp$ head -3 app1.log\n"
"Thread-3 (process_request) app1 __main__  jim    192.168.3.21 POST Request "
"processing started\n"
"Thread-3 (process_request) app1 webapplib jim    192.168.3.21 POST Hello "
"from webapplib!\n"
"Thread-5 (process_request) app1 __main__  jim    192.168.3.21 POST Request "
"processing started\n"
"~/logging-contextual-webapp$ head -3 app2.log\n"
"Thread-1 (process_request) app2 __main__  sheila 192.168.2.21 GET  Request "
"processing started\n"
"Thread-1 (process_request) app2 webapplib sheila 192.168.2.21 GET  Hello "
"from webapplib!\n"
"Thread-2 (process_request) app2 __main__  jim    192.168.2.20 GET  Request "
"processing started\n"
"~/logging-contextual-webapp$ head app.log\n"
"Thread-1 (process_request) app2 __main__  sheila 192.168.2.21 GET  Request "
"processing started\n"
"Thread-1 (process_request) app2 webapplib sheila 192.168.2.21 GET  Hello "
"from webapplib!\n"
"Thread-2 (process_request) app2 __main__  jim    192.168.2.20 GET  Request "
"processing started\n"
"Thread-3 (process_request) app1 __main__  jim    192.168.3.21 POST Request "
"processing started\n"
"Thread-2 (process_request) app2 webapplib jim    192.168.2.20 GET  Hello "
"from webapplib!\n"
"Thread-3 (process_request) app1 webapplib jim    192.168.3.21 POST Hello "
"from webapplib!\n"
"Thread-4 (process_request) app2 __main__  fred   192.168.2.22 GET  Request "
"processing started\n"
"Thread-5 (process_request) app1 __main__  jim    192.168.3.21 POST Request "
"processing started\n"
"Thread-4 (process_request) app2 webapplib fred   192.168.2.22 GET  Hello "
"from webapplib!\n"
"Thread-6 (process_request) app1 __main__  jim    192.168.3.21 POST Request "
"processing started\n"
"~/logging-contextual-webapp$ grep app1 app1.log | wc -l\n"
"153\n"
"~/logging-contextual-webapp$ grep app2 app2.log | wc -l\n"
"147\n"
"~/logging-contextual-webapp$ grep app1 app.log | wc -l\n"
"153\n"
"~/logging-contextual-webapp$ grep app2 app.log | wc -l\n"
"147"
msgstr ""
"~/logging-contextual-webapp$ python main.py\n"
"app1 processed 51 requests\n"
"app2 processed 49 requests\n"
"~/logging-contextual-webapp$ wc -l *.log\n"
"  153 app1.log\n"
"  147 app2.log\n"
"  300 app.log\n"
"  600 total\n"
"~/logging-contextual-webapp$ head -3 app1.log\n"
"Thread-3 (process_request) app1 __main__  jim    192.168.3.21 POST Request "
"processing started\n"
"Thread-3 (process_request) app1 webapplib jim    192.168.3.21 POST Hello "
"from webapplib!\n"
"Thread-5 (process_request) app1 __main__  jim    192.168.3.21 POST Request "
"processing started\n"
"~/logging-contextual-webapp$ head -3 app2.log\n"
"Thread-1 (process_request) app2 __main__  sheila 192.168.2.21 GET  Request "
"processing started\n"
"Thread-1 (process_request) app2 webapplib sheila 192.168.2.21 GET  Hello "
"from webapplib!\n"
"Thread-2 (process_request) app2 __main__  jim    192.168.2.20 GET  Request "
"processing started\n"
"~/logging-contextual-webapp$ head app.log\n"
"Thread-1 (process_request) app2 __main__  sheila 192.168.2.21 GET  Request "
"processing started\n"
"Thread-1 (process_request) app2 webapplib sheila 192.168.2.21 GET  Hello "
"from webapplib!\n"
"Thread-2 (process_request) app2 __main__  jim    192.168.2.20 GET  Request "
"processing started\n"
"Thread-3 (process_request) app1 __main__  jim    192.168.3.21 POST Request "
"processing started\n"
"Thread-2 (process_request) app2 webapplib jim    192.168.2.20 GET  Hello "
"from webapplib!\n"
"Thread-3 (process_request) app1 webapplib jim    192.168.3.21 POST Hello "
"from webapplib!\n"
"Thread-4 (process_request) app2 __main__  fred   192.168.2.22 GET  Request "
"processing started\n"
"Thread-5 (process_request) app1 __main__  jim    192.168.3.21 POST Request "
"processing started\n"
"Thread-4 (process_request) app2 webapplib fred   192.168.2.22 GET  Hello "
"from webapplib!\n"
"Thread-6 (process_request) app1 __main__  jim    192.168.3.21 POST Request "
"processing started\n"
"~/logging-contextual-webapp$ grep app1 app1.log | wc -l\n"
"153\n"
"~/logging-contextual-webapp$ grep app2 app2.log | wc -l\n"
"147\n"
"~/logging-contextual-webapp$ grep app1 app.log | wc -l\n"
"153\n"
"~/logging-contextual-webapp$ grep app2 app.log | wc -l\n"
"147"

#: ../../howto/logging-cookbook.rst:1237
msgid "Imparting contextual information in handlers"
msgstr "Información contextual en los manipuladores"

#: ../../howto/logging-cookbook.rst:1239
msgid ""
"Each :class:`~Handler` has its own chain of filters. If you want to add "
"contextual information to a :class:`LogRecord` without leaking it to other "
"handlers, you can use a filter that returns a new :class:`~LogRecord` "
"instead of modifying it in-place, as shown in the following script::"
msgstr ""
"Cada :class:`~Handler` tiene su propia cadena de filtros. Si desea añadir "
"información contextual a un :class:`LogRecord` sin filtrarla a otros "
"manejadores, puede utilizar un filtro que devuelva un nuevo :class:"
"`~LogRecord` en lugar de modificarlo in situ, como se muestra en el "
"siguiente script::"

#: ../../howto/logging-cookbook.rst:1244
msgid ""
"import copy\n"
"import logging\n"
"\n"
"def filter(record: logging.LogRecord):\n"
"    record = copy.copy(record)\n"
"    record.user = 'jim'\n"
"    return record\n"
"\n"
"if __name__ == '__main__':\n"
"    logger = logging.getLogger()\n"
"    logger.setLevel(logging.INFO)\n"
"    handler = logging.StreamHandler()\n"
"    formatter = logging.Formatter('%(message)s from %(user)-8s')\n"
"    handler.setFormatter(formatter)\n"
"    handler.addFilter(filter)\n"
"    logger.addHandler(handler)\n"
"\n"
"    logger.info('A log message')"
msgstr ""
"import copy\n"
"import logging\n"
"\n"
"def filter(record: logging.LogRecord):\n"
"    record = copy.copy(record)\n"
"    record.user = 'jim'\n"
"    return record\n"
"\n"
"if __name__ == '__main__':\n"
"    logger = logging.getLogger()\n"
"    logger.setLevel(logging.INFO)\n"
"    handler = logging.StreamHandler()\n"
"    formatter = logging.Formatter('%(message)s from %(user)-8s')\n"
"    handler.setFormatter(formatter)\n"
"    handler.addFilter(filter)\n"
"    logger.addHandler(handler)\n"
"\n"
"    logger.info('A log message')"

#: ../../howto/logging-cookbook.rst:1266
msgid "Logging to a single file from multiple processes"
msgstr "Registro en un único archivo desde varios procesos"

#: ../../howto/logging-cookbook.rst:1268
msgid ""
"Although logging is thread-safe, and logging to a single file from multiple "
"threads in a single process *is* supported, logging to a single file from "
"*multiple processes* is *not* supported, because there is no standard way to "
"serialize access to a single file across multiple processes in Python. If "
"you need to log to a single file from multiple processes, one way of doing "
"this is to have all the processes log to a :class:`~handlers.SocketHandler`, "
"and have a separate process which implements a socket server which reads "
"from the socket and logs to file. (If you prefer, you can dedicate one "
"thread in one of the existing processes to perform this function.) :ref:"
"`This section <network-logging>` documents this approach in more detail and "
"includes a working socket receiver which can be used as a starting point for "
"you to adapt in your own applications."
msgstr ""
"Aunque el registro es seguro para hilos, y el registro en un único fichero "
"desde múltiples hilos en un único proceso *está* soportado, el registro en "
"un único fichero desde *múltiples procesos* *no está* soportado, porque no "
"hay una forma estándar de serializar el acceso a un único fichero a través "
"de múltiples procesos en Python. Si necesitas registrar en un único fichero "
"desde múltiples procesos, una forma de hacerlo es hacer que todos los "
"procesos registren en :class:`~handlers.SocketHandler`, y tener un proceso "
"separado que implemente un servidor de socket que lea desde el socket y "
"registre en el fichero. (Si lo prefiere, puede dedicar un hilo en uno de los "
"procesos existentes para realizar esta función). :ref:`Esta sección <network-"
"logging>` documenta este enfoque con más detalle e incluye un receptor de "
"sockets que puede ser utilizado como punto de partida para que lo adaptes a "
"tus propias aplicaciones."

#: ../../howto/logging-cookbook.rst:1281
msgid ""
"You could also write your own handler which uses the :class:"
"`~multiprocessing.Lock` class from the :mod:`multiprocessing` module to "
"serialize access to the file from your processes. The existing :class:"
"`FileHandler` and subclasses do not make use of :mod:`multiprocessing` at "
"present, though they may do so in the future. Note that at present, the :mod:"
"`multiprocessing` module does not provide working lock functionality on all "
"platforms (see https://bugs.python.org/issue3770)."
msgstr ""
"También puedes escribir tu propio manejador que utilice la clase :class:"
"`~multiprocessing.Lock` del módulo :mod:`multiprocessing` para serializar el "
"acceso al fichero desde tus procesos. Las clases :class:`FileHandler` y "
"subclases existentes no hacen uso de :mod:`multiprocessing` en la "
"actualidad, aunque podrían hacerlo en el futuro. Tenga en cuenta que en la "
"actualidad, el módulo :mod:`multiprocessing` no proporciona funcionalidad de "
"bloqueo de trabajo en todas las plataformas (ver https://bugs.python.org/"
"issue3770)."

#: ../../howto/logging-cookbook.rst:1291
msgid ""
"Alternatively, you can use a ``Queue`` and a :class:`QueueHandler` to send "
"all logging events to one of the processes in your multi-process "
"application. The following example script demonstrates how you can do this; "
"in the example a separate listener process listens for events sent by other "
"processes and logs them according to its own logging configuration. Although "
"the example only demonstrates one way of doing it (for example, you may want "
"to use a listener thread rather than a separate listener process -- the "
"implementation would be analogous) it does allow for completely different "
"logging configurations for the listener and the other processes in your "
"application, and can be used as the basis for code meeting your own specific "
"requirements::"
msgstr ""
"Alternativamente, se puede utilizar ``Queue`` y :class:`QueueHandler` para "
"enviar todos los sucesos de registro a uno de los procesos de su aplicación "
"multiproceso. El siguiente script de ejemplo demuestra cómo se puede hacer "
"esto; en el ejemplo un proceso oyente separado escucha los eventos enviados "
"por otros procesos y los registra de acuerdo a su propia configuración de "
"registro. Aunque el ejemplo sólo muestra una forma de hacerlo (por ejemplo, "
"se puede querer usar un hilo de escucha en lugar de un proceso de escucha "
"separado -- la implementación sería análoga) permite configuraciones de "
"registro completamente diferentes para el proceso de escucha y los otros "
"procesos de la aplicación, y puede usarse como base para código que cumpla "
"los propios requisitos específicos::"

#: ../../howto/logging-cookbook.rst:1302
msgid ""
"# You'll need these imports in your own code\n"
"import logging\n"
"import logging.handlers\n"
"import multiprocessing\n"
"\n"
"# Next two import lines for this demo only\n"
"from random import choice, random\n"
"import time\n"
"\n"
"#\n"
"# Because you'll want to define the logging configurations for listener and "
"workers, the\n"
"# listener and worker process functions take a configurer parameter which is "
"a callable\n"
"# for configuring logging for that process. These functions are also passed "
"the queue,\n"
"# which they use for communication.\n"
"#\n"
"# In practice, you can configure the listener however you want, but note "
"that in this\n"
"# simple example, the listener does not apply level or filter logic to "
"received records.\n"
"# In practice, you would probably want to do this logic in the worker "
"processes, to avoid\n"
"# sending events which would be filtered out between processes.\n"
"#\n"
"# The size of the rotated files is made small so you can see the results "
"easily.\n"
"def listener_configurer():\n"
"    root = logging.getLogger()\n"
"    h = logging.handlers.RotatingFileHandler('mptest.log', 'a', 300, 10)\n"
"    f = logging.Formatter('%(asctime)s %(processName)-10s %(name)s "
"%(levelname)-8s %(message)s')\n"
"    h.setFormatter(f)\n"
"    root.addHandler(h)\n"
"\n"
"# This is the listener process top-level loop: wait for logging events\n"
"# (LogRecords)on the queue and handle them, quit when you get a None for a\n"
"# LogRecord.\n"
"def listener_process(queue, configurer):\n"
"    configurer()\n"
"    while True:\n"
"        try:\n"
"            record = queue.get()\n"
"            if record is None:  # We send this as a sentinel to tell the "
"listener to quit.\n"
"                break\n"
"            logger = logging.getLogger(record.name)\n"
"            logger.handle(record)  # No level or filter logic applied - just "
"do it!\n"
"        except Exception:\n"
"            import sys, traceback\n"
"            print('Whoops! Problem:', file=sys.stderr)\n"
"            traceback.print_exc(file=sys.stderr)\n"
"\n"
"# Arrays used for random selections in this demo\n"
"\n"
"LEVELS = [logging.DEBUG, logging.INFO, logging.WARNING,\n"
"          logging.ERROR, logging.CRITICAL]\n"
"\n"
"LOGGERS = ['a.b.c', 'd.e.f']\n"
"\n"
"MESSAGES = [\n"
"    'Random message #1',\n"
"    'Random message #2',\n"
"    'Random message #3',\n"
"]\n"
"\n"
"# The worker configuration is done at the start of the worker process run.\n"
"# Note that on Windows you can't rely on fork semantics, so each process\n"
"# will run the logging configuration code when it starts.\n"
"def worker_configurer(queue):\n"
"    h = logging.handlers.QueueHandler(queue)  # Just the one handler needed\n"
"    root = logging.getLogger()\n"
"    root.addHandler(h)\n"
"    # send all messages, for demo; no other level or filter logic applied.\n"
"    root.setLevel(logging.DEBUG)\n"
"\n"
"# This is the worker process top-level loop, which just logs ten events "
"with\n"
"# random intervening delays before terminating.\n"
"# The print messages are just so you know it's doing something!\n"
"def worker_process(queue, configurer):\n"
"    configurer(queue)\n"
"    name = multiprocessing.current_process().name\n"
"    print('Worker started: %s' % name)\n"
"    for i in range(10):\n"
"        time.sleep(random())\n"
"        logger = logging.getLogger(choice(LOGGERS))\n"
"        level = choice(LEVELS)\n"
"        message = choice(MESSAGES)\n"
"        logger.log(level, message)\n"
"    print('Worker finished: %s' % name)\n"
"\n"
"# Here's where the demo gets orchestrated. Create the queue, create and "
"start\n"
"# the listener, create ten workers and start them, wait for them to finish,\n"
"# then send a None to the queue to tell the listener to finish.\n"
"def main():\n"
"    queue = multiprocessing.Queue(-1)\n"
"    listener = multiprocessing.Process(target=listener_process,\n"
"                                       args=(queue, listener_configurer))\n"
"    listener.start()\n"
"    workers = []\n"
"    for i in range(10):\n"
"        worker = multiprocessing.Process(target=worker_process,\n"
"                                         args=(queue, worker_configurer))\n"
"        workers.append(worker)\n"
"        worker.start()\n"
"    for w in workers:\n"
"        w.join()\n"
"    queue.put_nowait(None)\n"
"    listener.join()\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""
"# Necesitarás estas importaciones en tu propio código\n"
"import logging\n"
"import logging.handlers\n"
"import multiprocessing\n"
"\n"
"# Las siguientes dos líneas de importación son sólo para esta demo\n"
"from random import choice, random\n"
"import time\n"
"\n"
"#\n"
"# Dado que querrás definir las configuraciones de registro para listener y "
"workers, las funciones\n"
"# funciones de los procesos listener y worker toman un parámetro configurer "
"que es un callable\n"
"# para configurar el registro para ese proceso. A estas funciones también se "
"les pasa la cola\n"
"# que utilizan para la comunicación.\n"
"#\n"
"# En la práctica, puedes configurar el listener como quieras, pero ten en "
"cuenta que en este\n"
"# ejemplo simple, el listener no aplica lógica de nivel o filtro a los "
"registros recibidos.\n"
"# En la práctica, probablemente quieras hacer esta lógica en los procesos "
"worker, para evitar\n"
"# enviar eventos que serían filtrados entre procesos.\n"
"#\n"
"# El tamaño de los ficheros rotados se hace pequeño para que puedas ver los "
"resultados fácilmente.\n"
"def listener_configurer():\n"
"    root = logging.getLogger()\n"
"    h = logging.handlers.RotatingFileHandler('mptest.log', 'a', 300, 10)\n"
"    f = logging.Formatter('%(asctime)s %(processName)-10s %(name)s "
"%(levelname)-8s %(message)s ')\n"
"    h.setFormatter(f)\n"
"    root.addHandler(h)\n"
"\n"
"# Este es el bucle de nivel superior del proceso de escucha: esperar eventos "
"de logging\n"
"# (LogRecords)en la cola y manejarlos, salir cuando se obtiene un None para "
"un\n"
"# LogRecord.\n"
"def listener_process(queue, configurer):\n"
"       configurer()\n"
"       while True:\n"
"            try:\n"
"                    record = queue.get()\n"
"                    if record is None:  # Enviamos esto como centinela para "
"decirle al listener que salga.\n"
"                          break\n"
"                    logger = logging.getLogger(record.name)\n"
"                     logger.handle(record) # No se aplica lógica de nivel o "
"filtro - ¡simplemente hazlo!\n"
"        except Excepción:\n"
"                      import sys, traceback\n"
"                      print('¡Vaya! Problema:', file=sys.stderr)\n"
"                      traceback.print_exc(file=sys.stderr)\n"
"\n"
"# Matrices utilizadas para selecciones aleatorias en esta demo\n"
"\n"
"NIVELES = [logging.DEBUG, logging.INFO, logging.WARNING,\n"
"          logging.ERROR, logging.CRITICAL]\n"
"\n"
"LOGGERS = ['a.b.c', 'd.e.f']\n"
"\n"
"MESSAGES = [\n"
"          'Random message #1',\n"
"           'Random message #2',\n"
"           'Random message #3',\n"
"]\n"
"\n"
"# La configuración del trabajador se realiza al inicio de la ejecución del "
"proceso trabajador.\n"
"# Ten en cuenta que en Windows no puedes confiar en la semántica del fork, "
"así que cada proceso\n"
"# ejecutará el código de configuración del logging cuando se inicie.\n"
"def trabajador_configurador(cola):\n"
"    h = logging.handlers.QueueHandler(queue) # Sólo el manejador necesario\n"
"    root = logging.getLogger()\n"
"    root.addHandler(h)\n"
"    # envía todos los mensajes, para demostración; no se aplica ningún otro "
"nivel o lógica de filtrado.\n"
"    root.setLevel(logging.DEBUG)\n"
"\n"
"# Este es el bucle de nivel superior del proceso de trabajo, que sólo "
"registra diez eventos con\n"
"# retardos aleatorios antes de terminar.\n"
"# ¡Los mensajes impresos son sólo para que sepas que está haciendo algo!\n"
"def proceso_trabajador(cola, configurador):\n"
"    configurer(queue)\n"
"    name = multiprocessing.current_process().name\n"
"    print('Worker started: ' % name)\n"
"    for i in range(10):\n"
"          time.sleep(random())\n"
"          logger = logging.getLogger(choice(LOGGERS))\n"
"          level = choice(LEVELS)\n"
"          message = choice(MESSAGES)\n"
"          logger.log(level, message)\n"
"print('Worker finished: ' % name)\n"
"\n"
"# Aquí es donde se orquesta la demo. Crear la cola, crear e iniciar\n"
"# el listener, crear diez workers y arrancarlos, esperar a que terminen,\n"
"# luego envía un None a la cola para decirle al listener que termine.\n"
"def main():\n"
"       queue = multiprocessing.Queue(-1)\n"
"       listener = multiprocessing.Process(target=listener_process,\n"
"                                                                 args=(queue, "
"listener_configurer))\n"
"                                                                 listener."
"start()\n"
"        listener.start()\n"
"      workers = []\n"
"        for i in range(10):\n"
"              worker = multiprocessing.Process(target=worker_process,\n"
"                                                                 args=(queue, "
"worker_configurer))\n"
"                                                                 workers."
"append(worker)\n"
"               worker.start()\n"
"        for w in workers:\n"
"              w.join()\n"
"        queue.put_nowait(None)\n"
"        listener.join()\n"
"\n"
"if __name__ == '__main__':\n"
"     main()"

#: ../../howto/logging-cookbook.rst:1407
msgid ""
"A variant of the above script keeps the logging in the main process, in a "
"separate thread::"
msgstr ""
"Una variante del anterior script mantiene el registro en el proceso "
"principal, en un hilo separado::"

#: ../../howto/logging-cookbook.rst:1410
msgid ""
"import logging\n"
"import logging.config\n"
"import logging.handlers\n"
"from multiprocessing import Process, Queue\n"
"import random\n"
"import threading\n"
"import time\n"
"\n"
"def logger_thread(q):\n"
"    while True:\n"
"        record = q.get()\n"
"        if record is None:\n"
"            break\n"
"        logger = logging.getLogger(record.name)\n"
"        logger.handle(record)\n"
"\n"
"\n"
"def worker_process(q):\n"
"    qh = logging.handlers.QueueHandler(q)\n"
"    root = logging.getLogger()\n"
"    root.setLevel(logging.DEBUG)\n"
"    root.addHandler(qh)\n"
"    levels = [logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR,\n"
"              logging.CRITICAL]\n"
"    loggers = ['foo', 'foo.bar', 'foo.bar.baz',\n"
"               'spam', 'spam.ham', 'spam.ham.eggs']\n"
"    for i in range(100):\n"
"        lvl = random.choice(levels)\n"
"        logger = logging.getLogger(random.choice(loggers))\n"
"        logger.log(lvl, 'Message no. %d', i)\n"
"\n"
"if __name__ == '__main__':\n"
"    q = Queue()\n"
"    d = {\n"
"        'version': 1,\n"
"        'formatters': {\n"
"            'detailed': {\n"
"                'class': 'logging.Formatter',\n"
"                'format': '%(asctime)s %(name)-15s %(levelname)-8s "
"%(processName)-10s %(message)s'\n"
"            }\n"
"        },\n"
"        'handlers': {\n"
"            'console': {\n"
"                'class': 'logging.StreamHandler',\n"
"                'level': 'INFO',\n"
"            },\n"
"            'file': {\n"
"                'class': 'logging.FileHandler',\n"
"                'filename': 'mplog.log',\n"
"                'mode': 'w',\n"
"                'formatter': 'detailed',\n"
"            },\n"
"            'foofile': {\n"
"                'class': 'logging.FileHandler',\n"
"                'filename': 'mplog-foo.log',\n"
"                'mode': 'w',\n"
"                'formatter': 'detailed',\n"
"            },\n"
"            'errors': {\n"
"                'class': 'logging.FileHandler',\n"
"                'filename': 'mplog-errors.log',\n"
"                'mode': 'w',\n"
"                'level': 'ERROR',\n"
"                'formatter': 'detailed',\n"
"            },\n"
"        },\n"
"        'loggers': {\n"
"            'foo': {\n"
"                'handlers': ['foofile']\n"
"            }\n"
"        },\n"
"        'root': {\n"
"            'level': 'DEBUG',\n"
"            'handlers': ['console', 'file', 'errors']\n"
"        },\n"
"    }\n"
"    workers = []\n"
"    for i in range(5):\n"
"        wp = Process(target=worker_process, name='worker %d' % (i + 1), "
"args=(q,))\n"
"        workers.append(wp)\n"
"        wp.start()\n"
"    logging.config.dictConfig(d)\n"
"    lp = threading.Thread(target=logger_thread, args=(q,))\n"
"    lp.start()\n"
"    # At this point, the main process could do some useful work of its own\n"
"    # Once it's done that, it can wait for the workers to terminate...\n"
"    for wp in workers:\n"
"        wp.join()\n"
"    # And now tell the logging thread to finish up, too\n"
"    q.put(None)\n"
"    lp.join()"
msgstr ""
"import logging\n"
"import logging.config\n"
"import logging.handlers\n"
"from multiprocessing import Process, Queue\n"
"import random\n"
"import threading\n"
"import time\n"
"\n"
"def logger_thread(q):\n"
"    while True:\n"
"        record = q.get()\n"
"        if record is None:\n"
"            break\n"
"        logger = logging.getLogger(record.name)\n"
"        logger.handle(record)\n"
"\n"
"\n"
"def worker_process(q):\n"
"    qh = logging.handlers.QueueHandler(q)\n"
"    root = logging.getLogger()\n"
"    root.setLevel(logging.DEBUG)\n"
"    root.addHandler(qh)\n"
"    levels = [logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR,\n"
"              logging.CRITICAL]\n"
"    loggers = ['foo', 'foo.bar', 'foo.bar.baz',\n"
"               'spam', 'spam.ham', 'spam.ham.eggs']\n"
"    for i in range(100):\n"
"        lvl = random.choice(levels)\n"
"        logger = logging.getLogger(random.choice(loggers))\n"
"        logger.log(lvl, 'Message no. %d', i)\n"
"\n"
"if __name__ == '__main__':\n"
"    q = Queue()\n"
"    d = {\n"
"        'version': 1,\n"
"        'formatters': {\n"
"            'detailed': {\n"
"                'class': 'logging.Formatter',\n"
"                'format': '%(asctime)s %(name)-15s %(levelname)-8s "
"%(processName)-10s %(message)s'\n"
"            }\n"
"        },\n"
"        'handlers': {\n"
"            'console': {\n"
"                'class': 'logging.StreamHandler',\n"
"                'level': 'INFO',\n"
"            },\n"
"            'file': {\n"
"                'class': 'logging.FileHandler',\n"
"                'filename': 'mplog.log',\n"
"                'mode': 'w',\n"
"                'formatter': 'detailed',\n"
"            },\n"
"            'foofile': {\n"
"                'class': 'logging.FileHandler',\n"
"                'filename': 'mplog-foo.log',\n"
"                'mode': 'w',\n"
"                'formatter': 'detailed',\n"
"            },\n"
"            'errors': {\n"
"                'class': 'logging.FileHandler',\n"
"                'filename': 'mplog-errors.log',\n"
"                'mode': 'w',\n"
"                'level': 'ERROR',\n"
"                'formatter': 'detailed',\n"
"            },\n"
"        },\n"
"        'loggers': {\n"
"            'foo': {\n"
"                'handlers': ['foofile']\n"
"            }\n"
"        },\n"
"        'root': {\n"
"            'level': 'DEBUG',\n"
"            'handlers': ['console', 'file', 'errors']\n"
"        },\n"
"    }\n"
"    workers = []\n"
"    for i in range(5):\n"
"        wp = Process(target=worker_process, name='worker %d' % (i + 1), "
"args=(q,))\n"
"        workers.append(wp)\n"
"        wp.start()\n"
"    logging.config.dictConfig(d)\n"
"    lp = threading.Thread(target=logger_thread, args=(q,))\n"
"    lp.start()\n"
"    # En este punto, el proceso principal podría hacer algún trabajo útil "
"por sí mismo\n"
"     # Una vez hecho esto, puede esperar a que los trabajadores terminen...\n"
"    for wp in workers:\n"
"        wp.join()\n"
"     # Y ahora dile al hilo de registro que termine también          q."
"put(None)\n"
"    lp.join()"

#: ../../howto/logging-cookbook.rst:1502
msgid ""
"This variant shows how you can e.g. apply configuration for particular "
"loggers - e.g. the ``foo`` logger has a special handler which stores all "
"events in the ``foo`` subsystem in a file ``mplog-foo.log``. This will be "
"used by the logging machinery in the main process (even though the logging "
"events are generated in the worker processes) to direct the messages to the "
"appropriate destinations."
msgstr ""
"Esta variante muestra cómo se puede, por ejemplo, aplicar la configuración "
"para determinados registradores - por ejemplo, el registrador ``foo`` tiene "
"un manejador especial que almacena todos los eventos en el subsistema "
"``foo`` en un archivo ``mplog-foo.log``. Esto será utilizado por la "
"maquinaria de registro en el proceso principal (aunque los eventos de "
"registro se generen en los procesos de los trabajadores) para dirigir los "
"mensajes a los destinos apropiados."

#: ../../howto/logging-cookbook.rst:1509
msgid "Using concurrent.futures.ProcessPoolExecutor"
msgstr "Using concurrent.futures.ProcessPoolExecutor"

#: ../../howto/logging-cookbook.rst:1511
msgid ""
"If you want to use :class:`concurrent.futures.ProcessPoolExecutor` to start "
"your worker processes, you need to create the queue slightly differently. "
"Instead of"
msgstr ""
"Si desea utilizar :class:`concurrent.futures.ProcessPoolExecutor` para "
"iniciar sus procesos de trabajo, deberá crear la cola de forma ligeramente "
"diferente. En lugar de"

#: ../../howto/logging-cookbook.rst:1515
msgid "queue = multiprocessing.Queue(-1)"
msgstr "queue = multiprocessing.Queue(-1)"

#: ../../howto/logging-cookbook.rst:1519
msgid "you should use"
msgstr "debe utilizar"

#: ../../howto/logging-cookbook.rst:1521
msgid ""
"queue = multiprocessing.Manager().Queue(-1)  # also works with the examples "
"above"
msgstr ""
"queue = multiprocessing.Manager().Queue(-1) # también funciona con los "
"ejemplos anteriores"

#: ../../howto/logging-cookbook.rst:1525
msgid "and you can then replace the worker creation from this::"
msgstr "y luego puede reemplazar la creación elaborada de este::"

#: ../../howto/logging-cookbook.rst:1527
msgid ""
"workers = []\n"
"for i in range(10):\n"
"    worker = multiprocessing.Process(target=worker_process,\n"
"                                     args=(queue, worker_configurer))\n"
"    workers.append(worker)\n"
"    worker.start()\n"
"for w in workers:\n"
"    w.join()"
msgstr ""
"workers = []\n"
"for i in range(10):\n"
"    worker = multiprocessing.Process(target=worker_process,\n"
"                                     args=(queue, worker_configurer))\n"
"    workers.append(worker)\n"
"    worker.start()\n"
"for w in workers:\n"
"    w.join()"

#: ../../howto/logging-cookbook.rst:1536
msgid "to this (remembering to first import :mod:`concurrent.futures`)::"
msgstr "a esto (recordar importar primero :mod:`concurrent.futures`)::"

#: ../../howto/logging-cookbook.rst:1538
msgid ""
"with concurrent.futures.ProcessPoolExecutor(max_workers=10) as executor:\n"
"    for i in range(10):\n"
"        executor.submit(worker_process, queue, worker_configurer)"
msgstr ""
"with concurrent.futures.ProcessPoolExecutor(max_workers=10) as executor:\n"
"    for i in range(10):\n"
"        executor.submit(worker_process, queue, worker_configurer)"

#: ../../howto/logging-cookbook.rst:1543
msgid "Deploying Web applications using Gunicorn and uWSGI"
msgstr "Despliegue de aplicaciones web con Gunicorn y uWSGI"

#: ../../howto/logging-cookbook.rst:1545
msgid ""
"When deploying Web applications using `Gunicorn <https://gunicorn.org/>`_ or "
"`uWSGI <https://uwsgi-docs.readthedocs.io/en/latest/>`_ (or similar), "
"multiple worker processes are created to handle client requests. In such "
"environments, avoid creating file-based handlers directly in your web "
"application. Instead, use a :class:`SocketHandler` to log from the web "
"application to a listener in a separate process. This can be set up using a "
"process management tool such as Supervisor - see `Running a logging socket "
"listener in production`_ for more details."
msgstr ""
"Cuando se despliegan aplicaciones web utilizando `Gunicorn <https://gunicorn."
"org/>`_ o `uWSGI <https://uwsgi-docs.readthedocs.io/en/latest/>`_ (o "
"similares), se crean múltiples procesos de trabajo para gestionar las "
"peticiones de los clientes. En tales entornos, eviar crear manejadores "
"basados en archivos directamente en la aplicación web. En su lugar, utilizar "
"un :class:`SocketHandler` para registrar desde la aplicación web a un "
"listener en un proceso separado. Esto se puede configurar utilizando una "
"herramienta de gestión de procesos como Supervisor - ver `Running a logging "
"socket listener in production`_ para más detalles."

#: ../../howto/logging-cookbook.rst:1555
msgid "Using file rotation"
msgstr "Rotación de archivos"

#: ../../howto/logging-cookbook.rst:1560
msgid ""
"Sometimes you want to let a log file grow to a certain size, then open a new "
"file and log to that. You may want to keep a certain number of these files, "
"and when that many files have been created, rotate the files so that the "
"number of files and the size of the files both remain bounded. For this "
"usage pattern, the logging package provides a :class:`RotatingFileHandler`::"
msgstr ""
"A veces se quiere dejar que un archivo de registro crezca hasta un cierto "
"tamaño, y luego abrir un nuevo archivo y registrar en él. Es posible que se "
"desee mantener un cierto número de estos archivos, y cuando ese número de "
"archivos se han creado, rotar los archivos para que el número de archivos y "
"el tamaño de los archivos estén limitados. Para este patrón de uso, el "
"paquete de registro proporciona un :class:`RotatingFileHandler`::"

#: ../../howto/logging-cookbook.rst:1566
msgid ""
"import glob\n"
"import logging\n"
"import logging.handlers\n"
"\n"
"LOG_FILENAME = 'logging_rotatingfile_example.out'\n"
"\n"
"# Set up a specific logger with our desired output level\n"
"my_logger = logging.getLogger('MyLogger')\n"
"my_logger.setLevel(logging.DEBUG)\n"
"\n"
"# Add the log message handler to the logger\n"
"handler = logging.handlers.RotatingFileHandler(\n"
"              LOG_FILENAME, maxBytes=20, backupCount=5)\n"
"\n"
"my_logger.addHandler(handler)\n"
"\n"
"# Log some messages\n"
"for i in range(20):\n"
"    my_logger.debug('i = %d' % i)\n"
"\n"
"# See what files are created\n"
"logfiles = glob.glob('%s*' % LOG_FILENAME)\n"
"\n"
"for filename in logfiles:\n"
"    print(filename)"
msgstr ""
"import glob\n"
"import logging\n"
"import logging.handlers\n"
"\n"
"LOG_FILENAME = 'logging_rotatingfile_example.out'\n"
"\n"
"# Configurar un logger específico con nuestro nivel de salida deseado\n"
"my_logger = logging.getLogger('MyLogger')\n"
"my_logger.setLevel(logging.DEBUG)\n"
"\n"
"# Añade el gestor de mensajes al logger\n"
"handler = logging.handlers.RotatingFileHandler(\n"
"              LOG_FILENAME, maxBytes=20, backupCount=5)\n"
"\n"
"my_logger.addHandler(handler)\n"
"\n"
"# Registrar algunos mensajes\n"
"for i in range(20):\n"
"    my_logger.debug('i = %d' % i)\n"
"\n"
"# Ver qué archivos se crean\n"
"logfiles = glob.glob('%s*' % LOG_FILENAME)\n"
"\n"
"for filename in logfiles:\n"
"    print(filename)"

#: ../../howto/logging-cookbook.rst:1592
msgid ""
"The result should be 6 separate files, each with part of the log history for "
"the application:"
msgstr ""
"El resultado deberían ser 6 archivos separados, cada uno con parte del "
"historial de registro de la aplicación:"

#: ../../howto/logging-cookbook.rst:1595
msgid ""
"logging_rotatingfile_example.out\n"
"logging_rotatingfile_example.out.1\n"
"logging_rotatingfile_example.out.2\n"
"logging_rotatingfile_example.out.3\n"
"logging_rotatingfile_example.out.4\n"
"logging_rotatingfile_example.out.5"
msgstr ""
"logging_rotatingfile_example.out\n"
"logging_rotatingfile_example.out.1\n"
"logging_rotatingfile_example.out.2\n"
"logging_rotatingfile_example.out.3\n"
"logging_rotatingfile_example.out.4\n"
"logging_rotatingfile_example.out.5"

#: ../../howto/logging-cookbook.rst:1604
msgid ""
"The most current file is always :file:`logging_rotatingfile_example.out`, "
"and each time it reaches the size limit it is renamed with the suffix "
"``.1``. Each of the existing backup files is renamed to increment the suffix "
"(``.1`` becomes ``.2``, etc.)  and the ``.6`` file is erased."
msgstr ""
"El archivo más actual es siempre :file:`logging_rotatingfile_example.out`, y "
"cada vez que alcanza el límite de tamaño se renombra con el sufijo ``.1``. "
"Cada uno de los archivos de copia de seguridad existentes se renombra para "
"incrementar el sufijo (``.1`` se convierte en ``.2``, etc.) y el archivo "
"``.6`` se borra."

#: ../../howto/logging-cookbook.rst:1609
msgid ""
"Obviously this example sets the log length much too small as an extreme "
"example.  You would want to set *maxBytes* to an appropriate value."
msgstr ""
"Obviamente, este ejemplo establece la longitud del registro demasiado "
"pequeño como un ejemplo extremo.  Usted querría fijar *maxBytes* a un valor "
"apropiado."

#: ../../howto/logging-cookbook.rst:1617
msgid "Use of alternative formatting styles"
msgstr "Uso de estilos de formato alternativos"

#: ../../howto/logging-cookbook.rst:1619
msgid ""
"When logging was added to the Python standard library, the only way of "
"formatting messages with variable content was to use the %-formatting "
"method. Since then, Python has gained two new formatting approaches: :class:"
"`string.Template` (added in Python 2.4) and :meth:`str.format` (added in "
"Python 2.6)."
msgstr ""
"Cuando se añadió el registro a la biblioteca estándar de Python, la única "
"forma de formatear mensajes con contenido variable era utilizar el método %-"
"formatting. Desde entonces, Python ha adquirido dos nuevos métodos de "
"formateo: :class:`string.Template` (añadido en Python 2.4) y :meth:`str."
"format` (añadido en Python 2.6)."

#: ../../howto/logging-cookbook.rst:1625
msgid ""
"Logging (as of 3.2) provides improved support for these two additional "
"formatting styles. The :class:`Formatter` class been enhanced to take an "
"additional, optional keyword parameter named ``style``. This defaults to "
"``'%'``, but other possible values are ``'{'`` and ``'$'``, which correspond "
"to the other two formatting styles. Backwards compatibility is maintained by "
"default (as you would expect), but by explicitly specifying a style "
"parameter, you get the ability to specify format strings which work with :"
"meth:`str.format` or :class:`string.Template`. Here's an example console "
"session to show the possibilities:"
msgstr ""
"El registro (a partir de 3.2) proporciona soporte mejorado para estos dos "
"estilos de formato adicionales. La clase :class:`Formatter` se ha mejorado "
"para tomar un parámetro de palabra clave adicional y opcional denominado "
"``style``. Por defecto es ``'%'``, pero otros valores posibles son ``'{'`` y "
"``'$'``, que corresponden a los otros dos estilos de formato. La "
"compatibilidad hacia atrás se mantiene por defecto (como era de esperar), "
"pero especificando explícitamente un parámetro de estilo, se obtiene la "
"capacidad de especificar cadenas de formato que funcionan con :meth:`str."
"format` o :class:`string.Template`. He aquí un ejemplo de sesión de consola "
"para mostrar las posibilidades:"

#: ../../howto/logging-cookbook.rst:1635
msgid ""
">>> import logging\n"
">>> root = logging.getLogger()\n"
">>> root.setLevel(logging.DEBUG)\n"
">>> handler = logging.StreamHandler()\n"
">>> bf = logging.Formatter('{asctime} {name} {levelname:8s} {message}',\n"
"...                        style='{')\n"
">>> handler.setFormatter(bf)\n"
">>> root.addHandler(handler)\n"
">>> logger = logging.getLogger('foo.bar')\n"
">>> logger.debug('This is a DEBUG message')\n"
"2010-10-28 15:11:55,341 foo.bar DEBUG    This is a DEBUG message\n"
">>> logger.critical('This is a CRITICAL message')\n"
"2010-10-28 15:12:11,526 foo.bar CRITICAL This is a CRITICAL message\n"
">>> df = logging.Formatter('$asctime $name ${levelname} $message',\n"
"...                        style='$')\n"
">>> handler.setFormatter(df)\n"
">>> logger.debug('This is a DEBUG message')\n"
"2010-10-28 15:13:06,924 foo.bar DEBUG This is a DEBUG message\n"
">>> logger.critical('This is a CRITICAL message')\n"
"2010-10-28 15:13:11,494 foo.bar CRITICAL This is a CRITICAL message\n"
">>>"
msgstr ""
">>> import logging\n"
">>> root = logging.getLogger()\n"
">>> root.setLevel(logging.DEBUG)\n"
">>> handler = logging.StreamHandler()\n"
">>> bf = logging.Formatter('{asctime} {name} {levelname:8s} {message}',\n"
"...                        style='{')\n"
">>> handler.setFormatter(bf)\n"
">>> root.addHandler(handler)\n"
">>> logger = logging.getLogger('foo.bar')\n"
">>> logger.debug('This is a DEBUG message')\n"
"2010-10-28 15:11:55,341 foo.bar DEBUG    This is a DEBUG message\n"
">>> logger.critical('This is a CRITICAL message')\n"
"2010-10-28 15:12:11,526 foo.bar CRITICAL This is a CRITICAL message\n"
">>> df = logging.Formatter('$asctime $name ${levelname} $message',\n"
"...                        style='$')\n"
">>> handler.setFormatter(df)\n"
">>> logger.debug('This is a DEBUG message')\n"
"2010-10-28 15:13:06,924 foo.bar DEBUG This is a DEBUG message\n"
">>> logger.critical('This is a CRITICAL message')\n"
"2010-10-28 15:13:11,494 foo.bar CRITICAL This is a CRITICAL message\n"
">>>"

#: ../../howto/logging-cookbook.rst:1659
msgid ""
"Note that the formatting of logging messages for final output to logs is "
"completely independent of how an individual logging message is constructed. "
"That can still use %-formatting, as shown here::"
msgstr ""
"Tenga en cuenta que el formato de los mensajes de registro para la salida "
"final a los registros es completamente independiente de cómo se construye un "
"mensaje de registro individual. Que todavía puede utilizar %-formatting, "
"como se muestra aquí::"

#: ../../howto/logging-cookbook.rst:1663
msgid ""
">>> logger.error('This is an%s %s %s', 'other,', 'ERROR,', 'message')\n"
"2010-10-28 15:19:29,833 foo.bar ERROR This is another, ERROR, message\n"
">>>"
msgstr ""
">>> logger.error('This is an%s %s %s', 'other,', 'ERROR,', 'message')\n"
"2010-10-28 15:19:29,833 foo.bar ERROR This is another, ERROR, message\n"
">>>"

#: ../../howto/logging-cookbook.rst:1667
msgid ""
"Logging calls (``logger.debug()``, ``logger.info()`` etc.) only take "
"positional parameters for the actual logging message itself, with keyword "
"parameters used only for determining options for how to handle the actual "
"logging call (e.g. the ``exc_info`` keyword parameter to indicate that "
"traceback information should be logged, or the ``extra`` keyword parameter "
"to indicate additional contextual information to be added to the log). So "
"you cannot directly make logging calls using :meth:`str.format` or :class:"
"`string.Template` syntax, because internally the logging package uses %-"
"formatting to merge the format string and the variable arguments. There "
"would be no changing this while preserving backward compatibility, since all "
"logging calls which are out there in existing code will be using %-format "
"strings."
msgstr ""
"Las llamadas de registro (``logger.debug()``, ``logger.info()`` etc.) sólo "
"toman parámetros posicionales para el mensaje de registro en sí, con "
"parámetros de palabra clave utilizados sólo para determinar las opciones de "
"cómo manejar la llamada de registro real (por ejemplo, el parámetro de "
"palabra clave ``exc_info`` para indicar que la información de rastreo debe "
"ser registrada, o el parámetro de palabra clave ``extra`` para indicar "
"información contextual adicional que se añadirá al registro). Por lo tanto, "
"no se pueden realizar directamente llamadas de registro utilizando la "
"sintaxis :meth:`str.format` o :class:`string.Template`, porque internamente "
"el paquete de registro utiliza %-fomatting para fusionar la cadena de "
"formato y los argumentos variables. No habría forma de cambiar esto "
"preservando la compatibilidad con versiones anteriores, ya que todas las "
"llamadas de registro que existen en el código actual utilizarán cadenas %-"
"format."

#: ../../howto/logging-cookbook.rst:1680
msgid ""
"There is, however, a way that you can use {}- and $- formatting to construct "
"your individual log messages. Recall that for a message you can use an "
"arbitrary object as a message format string, and that the logging package "
"will call ``str()`` on that object to get the actual format string. Consider "
"the following two classes::"
msgstr ""
"Existe, sin embargo, una forma de utilizar los formatos {}- y $- para "
"construir mensajes de registro individuales. Recuerde que para un mensaje "
"puede utilizar un objeto arbitrario como cadena de formato de mensaje, y que "
"el paquete de registro llamará a ``str()`` sobre ese objeto para obtener la "
"cadena de formato real. Considere las dos clases siguientes::"

#: ../../howto/logging-cookbook.rst:1686 ../../howto/logging-cookbook.rst:2774
msgid ""
"class BraceMessage:\n"
"    def __init__(self, fmt, /, *args, **kwargs):\n"
"        self.fmt = fmt\n"
"        self.args = args\n"
"        self.kwargs = kwargs\n"
"\n"
"    def __str__(self):\n"
"        return self.fmt.format(*self.args, **self.kwargs)\n"
"\n"
"class DollarMessage:\n"
"    def __init__(self, fmt, /, **kwargs):\n"
"        self.fmt = fmt\n"
"        self.kwargs = kwargs\n"
"\n"
"    def __str__(self):\n"
"        from string import Template\n"
"        return Template(self.fmt).substitute(**self.kwargs)"
msgstr ""
"class BraceMessage:\n"
"    def __init__(self, fmt, /, *args, **kwargs):\n"
"        self.fmt = fmt\n"
"        self.args = args\n"
"        self.kwargs = kwargs\n"
"\n"
"    def __str__(self):\n"
"        return self.fmt.format(*self.args, **self.kwargs)\n"
"\n"
"class DollarMessage:\n"
"    def __init__(self, fmt, /, **kwargs):\n"
"        self.fmt = fmt\n"
"        self.kwargs = kwargs\n"
"\n"
"    def __str__(self):\n"
"        from string import Template\n"
"        return Template(self.fmt).substitute(**self.kwargs)"

#: ../../howto/logging-cookbook.rst:1704
msgid ""
"Either of these can be used in place of a format string, to allow {}- or $-"
"formatting to be used to build the actual \"message\" part which appears in "
"the formatted log output in place of \"%(message)s\" or \"{message}\" or "
"\"$message\". It's a little unwieldy to use the class names whenever you "
"want to log something, but it's quite palatable if you use an alias such as "
"__ (double underscore --- not to be confused with _, the single underscore "
"used as a synonym/alias for :func:`gettext.gettext` or its brethren)."
msgstr ""
"Cualquiera de estos se puede utilizar en lugar de una cadena de formato, "
"para permitir {}- o $-formato que se utilizará para construir la parte real "
"\"mensaje\" que aparece en la salida de registro con formato en lugar de "
"\"%(message)s\" o \"{message}\" o \"$message\". Es un poco engorroso "
"utilizar los nombres de clase cada vez que se quiere registrar algo, pero es "
"bastante agradable si se utiliza un alias como __ (guión bajo doble --- no "
"confundir con _, el guión bajo simple utilizado como sinónimo/alias para :"
"func:`gettext.gettext` o sus hermanos)."

#: ../../howto/logging-cookbook.rst:1712
msgid ""
"The above classes are not included in Python, though they're easy enough to "
"copy and paste into your own code. They can be used as follows (assuming "
"that they're declared in a module called ``wherever``):"
msgstr ""
"Las clases anteriores no están incluidas en Python, aunque son bastante "
"fáciles de copiar y pegar en tu propio código. Se pueden utilizar de la "
"siguiente manera (suponiendo que se declaran en un módulo llamado "
"``wherever``):"

#: ../../howto/logging-cookbook.rst:1716
msgid ""
">>> from wherever import BraceMessage as __\n"
">>> print(__('Message with {0} {name}', 2, name='placeholders'))\n"
"Message with 2 placeholders\n"
">>> class Point: pass\n"
"...\n"
">>> p = Point()\n"
">>> p.x = 0.5\n"
">>> p.y = 0.5\n"
">>> print(__('Message with coordinates: ({point.x:.2f}, {point.y:.2f})',\n"
"...       point=p))\n"
"Message with coordinates: (0.50, 0.50)\n"
">>> from wherever import DollarMessage as __\n"
">>> print(__('Message with $num $what', num=2, what='placeholders'))\n"
"Message with 2 placeholders\n"
">>>"
msgstr ""
">>> from wherever import BraceMessage as __\n"
">>> print(__('Message with {0} {name}', 2, name='placeholders'))\n"
"Message with 2 placeholders\n"
">>> class Point: pass\n"
"...\n"
">>> p = Point()\n"
">>> p.x = 0.5\n"
">>> p.y = 0.5\n"
">>> print(__('Message with coordinates: ({point.x:.2f}, {point.y:.2f})',\n"
"...       point=p))\n"
"Message with coordinates: (0.50, 0.50)\n"
">>> from wherever import DollarMessage as __\n"
">>> print(__('Message with $num $what', num=2, what='placeholders'))\n"
"Message with 2 placeholders\n"
">>>"

#: ../../howto/logging-cookbook.rst:1734
msgid ""
"While the above examples use ``print()`` to show how the formatting works, "
"you would of course use ``logger.debug()`` or similar to actually log using "
"this approach."
msgstr ""
"Aunque los ejemplos anteriores utilizan ``print()`` para mostrar cómo "
"funciona el formateo, por supuesto utilizarías ``logger.debug()`` o similar "
"para registrar realmente utilizando este enfoque."

#: ../../howto/logging-cookbook.rst:1738
msgid ""
"One thing to note is that you pay no significant performance penalty with "
"this approach: the actual formatting happens not when you make the logging "
"call, but when (and if) the logged message is actually about to be output to "
"a log by a handler. So the only slightly unusual thing which might trip you "
"up is that the parentheses go around the format string and the arguments, "
"not just the format string. That's because the __ notation is just syntax "
"sugar for a constructor call to one of the :samp:`{XXX}Message` classes."
msgstr ""
"Una cosa a tener en cuenta es que no se paga ninguna penalización de "
"rendimiento significativa con este enfoque: el formateo real no ocurre "
"cuando se hace la llamada de registro, sino cuando (y si) el mensaje "
"registrado está a punto de ser enviado a un registro por un manejador. La "
"única cosa un poco inusual que podría confundirte es que los paréntesis "
"rodean la cadena de formato y los argumentos, no sólo la cadena de formato. "
"Esto se debe a que la notación __ no es más que azúcar sintáctico para una "
"llamada al constructor de una de las clases de :samp:`{XXX}Message`."

#: ../../howto/logging-cookbook.rst:1746
msgid ""
"If you prefer, you can use a :class:`LoggerAdapter` to achieve a similar "
"effect to the above, as in the following example::"
msgstr ""
"Si lo prefiere, puede utilizar :class:`LoggerAdapter` para conseguir un "
"efecto similar al anterior, como en el siguiente ejemplo::"

#: ../../howto/logging-cookbook.rst:1749
msgid ""
"import logging\n"
"\n"
"class Message:\n"
"    def __init__(self, fmt, args):\n"
"        self.fmt = fmt\n"
"        self.args = args\n"
"\n"
"    def __str__(self):\n"
"        return self.fmt.format(*self.args)\n"
"\n"
"class StyleAdapter(logging.LoggerAdapter):\n"
"    def log(self, level, msg, /, *args, stacklevel=1, **kwargs):\n"
"        if self.isEnabledFor(level):\n"
"            msg, kwargs = self.process(msg, kwargs)\n"
"            self.logger.log(level, Message(msg, args), **kwargs,\n"
"                            stacklevel=stacklevel+1)\n"
"\n"
"logger = StyleAdapter(logging.getLogger(__name__))\n"
"\n"
"def main():\n"
"    logger.debug('Hello, {}', 'world!')\n"
"\n"
"if __name__ == '__main__':\n"
"    logging.basicConfig(level=logging.DEBUG)\n"
"    main()"
msgstr ""
"import logging\n"
"\n"
"class Message:\n"
"    def __init__(self, fmt, args):\n"
"        self.fmt = fmt\n"
"        self.args = args\n"
"\n"
"    def __str__(self):\n"
"        return self.fmt.format(*self.args)\n"
"\n"
"class StyleAdapter(logging.LoggerAdapter):\n"
"    def log(self, level, msg, /, *args, stacklevel=1, **kwargs):\n"
"        if self.isEnabledFor(level):\n"
"            msg, kwargs = self.process(msg, kwargs)\n"
"            self.logger.log(level, Message(msg, args), **kwargs,\n"
"                            stacklevel=stacklevel+1)\n"
"\n"
"logger = StyleAdapter(logging.getLogger(__name__))\n"
"\n"
"def main():\n"
"    logger.debug('Hello, {}', 'world!')\n"
"\n"
"if __name__ == '__main__':\n"
"    logging.basicConfig(level=logging.DEBUG)\n"
"    main()"

#: ../../howto/logging-cookbook.rst:1775
msgid ""
"The above script should log the message ``Hello, world!`` when run with "
"Python 3.8 or later."
msgstr ""
"El script anterior debería registrar el mensaje ``Hello, world!`` cuando se "
"ejecuta con Python 3.8 o posterior."

#: ../../howto/logging-cookbook.rst:1784
msgid "Customizing ``LogRecord``"
msgstr "Personalización ``LogRecord``"

#: ../../howto/logging-cookbook.rst:1786
msgid ""
"Every logging event is represented by a :class:`LogRecord` instance. When an "
"event is logged and not filtered out by a logger's level, a :class:"
"`LogRecord` is created, populated with information about the event and then "
"passed to the handlers for that logger (and its ancestors, up to and "
"including the logger where further propagation up the hierarchy is "
"disabled). Before Python 3.2, there were only two places where this creation "
"was done:"
msgstr ""
"Cada acto de registro está representado por una instancia de :class:"
"`LogRecord`. Cuando se registra un hecho y no se filtra por el nivel de un "
"registrador, se crea un :class:`LogRecord`, se rellena con información sobre "
"el mismo y se pasa a los manejadores para ese registrador (y sus ancestros, "
"hasta e incluyendo el registrador donde la propagación hacia arriba en la "
"jerarquía está deshabilitada). Antes de Python 3.2, sólo había dos lugares "
"donde se realizaba esta creación:"

#: ../../howto/logging-cookbook.rst:1793
msgid ""
":meth:`Logger.makeRecord`, which is called in the normal process of logging "
"an event. This invoked :class:`LogRecord` directly to create an instance."
msgstr ""
":meth:`Logger.makeRecord`que se llama en el proceso normal de registro de un "
"evento. Esto invoca :class:`LogRecord` directamente para crear una instancia."

#: ../../howto/logging-cookbook.rst:1796
msgid ""
":func:`makeLogRecord`, which is called with a dictionary containing "
"attributes to be added to the LogRecord. This is typically invoked when a "
"suitable dictionary has been received over the network (e.g. in pickle form "
"via a :class:`~handlers.SocketHandler`, or in JSON form via an :class:"
"`~handlers.HTTPHandler`)."
msgstr ""
":func:`makeLogRecord`que se invoca con un diccionario que contiene atributos "
"que deben añadirse al LogRecord. Normalmente se invoca cuando se ha recibido "
"un diccionario adecuado a través de la red (por ejemplo, en forma de pickle "
"a través de :class:`~handlers.SocketHandler`, o en forma de JSON a través "
"de :class:`~handlers.HTTPHandler`)."

#: ../../howto/logging-cookbook.rst:1802
msgid ""
"This has usually meant that if you need to do anything special with a :class:"
"`LogRecord`, you've had to do one of the following."
msgstr ""
"Por lo general, esto ha significado que, si se necesita hacer algo especial "
"con un :class:`LogRecord`, se ha tenido que hacer una de las siguientes "
"cosas."

#: ../../howto/logging-cookbook.rst:1805
msgid ""
"Create your own :class:`Logger` subclass, which overrides :meth:`Logger."
"makeRecord`, and set it using :func:`~logging.setLoggerClass` before any "
"loggers that you care about are instantiated."
msgstr ""
"Cree su propia subclase :class:`Logger`, que sobrescribe :meth:`Logger."
"makeRecord`, y configúrela utilizando :func:`~logging.setLoggerClass` antes "
"de instanciar cualquier registrador que le interese."

#: ../../howto/logging-cookbook.rst:1808
msgid ""
"Add a :class:`Filter` to a logger or handler, which does the necessary "
"special manipulation you need when its :meth:`~Filter.filter` method is "
"called."
msgstr ""
"Añade un :class:`Filter` a un registrador o manejador, que realiza la "
"manipulación especial necesaria cuando se llama a su método :meth:`~Filter."
"filter`."

#: ../../howto/logging-cookbook.rst:1812
msgid ""
"The first approach would be a little unwieldy in the scenario where (say) "
"several different libraries wanted to do different things. Each would "
"attempt to set its own :class:`Logger` subclass, and the one which did this "
"last would win."
msgstr ""
"El primer enfoque sería un poco difícil de manejar en el caso de que "
"(digamos) varias bibliotecas diferentes quisieran hacer cosas distintas. "
"Cada una intentaría establecer su propia subclase :class:`Logger`, y ganaría "
"la que lo hiciera en último lugar."

#: ../../howto/logging-cookbook.rst:1817
msgid ""
"The second approach works reasonably well for many cases, but does not allow "
"you to e.g. use a specialized subclass of :class:`LogRecord`. Library "
"developers can set a suitable filter on their loggers, but they would have "
"to remember to do this every time they introduced a new logger (which they "
"would do simply by adding new packages or modules and doing ::"
msgstr ""
"El segundo enfoque funciona razonablemente bien para muchos casos, pero no "
"permite, por ejemplo, utilizar una subclase especializada de :class:"
"`LogRecord`. Los desarrolladores de bibliotecas pueden establecer un filtro "
"adecuado en sus registradores, pero tendrían que acordarse de hacerlo cada "
"vez que introdujeran un nuevo registrador (lo que harían simplemente "
"añadiendo nuevos paquetes o módulos y haciendo ::"

#: ../../howto/logging-cookbook.rst:1823
msgid "logger = logging.getLogger(__name__)"
msgstr "logger = logging.getLogger(__name__)"

#: ../../howto/logging-cookbook.rst:1825
msgid ""
"at module level). It's probably one too many things to think about. "
"Developers could also add the filter to a :class:`~logging.NullHandler` "
"attached to their top-level logger, but this would not be invoked if an "
"application developer attached a handler to a lower-level library logger --- "
"so output from that handler would not reflect the intentions of the library "
"developer."
msgstr ""
"a nivel de módulo). Es probablemente una de las demasiadas cosas en las que "
"pensar. Los desarrolladores también podrían añadir el filtro a un :class:"
"`~logging.NullHandler` adjunto a su registrador de nivel superior, pero esto "
"no se invocaría si un desarrollador de aplicaciones adjuntara un manejador a "
"un registrador de biblioteca de nivel inferior --- por lo que la salida de "
"ese manejador no reflejaría las intenciones del desarrollador de la "
"biblioteca."

#: ../../howto/logging-cookbook.rst:1831
msgid ""
"In Python 3.2 and later, :class:`~logging.LogRecord` creation is done "
"through a factory, which you can specify. The factory is just a callable you "
"can set with :func:`~logging.setLogRecordFactory`, and interrogate with :"
"func:`~logging.getLogRecordFactory`. The factory is invoked with the same "
"signature as the :class:`~logging.LogRecord` constructor, as :class:"
"`LogRecord` is the default setting for the factory."
msgstr ""
"En Python 3.2 y posteriores, la creación de :class:`~logging.LogRecord` se "
"realiza a través de una fábrica, que puedes especificar. La fábrica es sólo "
"una llamada que puedes establecer con :func:`~logging.setLogRecordFactory`, "
"e interrogar con :func:`~logging.getLogRecordFactory`. La fábrica se invoca "
"con la misma firma que el constructor :class:`~logging.LogRecord`, ya que :"
"class:`LogRecord` es la configuración por defecto de la fábrica."

#: ../../howto/logging-cookbook.rst:1838
msgid ""
"This approach allows a custom factory to control all aspects of LogRecord "
"creation. For example, you could return a subclass, or just add some "
"additional attributes to the record once created, using a pattern similar to "
"this::"
msgstr ""
"Este enfoque permite que una fábrica personalizada controle todos los "
"aspectos de la creación de LogRecord. Por ejemplo, podría devolver una "
"subclase, o simplemente añadir algunos atributos adicionales al registro una "
"vez creado, utilizando un patrón similar a este::"

#: ../../howto/logging-cookbook.rst:1842
msgid ""
"old_factory = logging.getLogRecordFactory()\n"
"\n"
"def record_factory(*args, **kwargs):\n"
"    record = old_factory(*args, **kwargs)\n"
"    record.custom_attribute = 0xdecafbad\n"
"    return record\n"
"\n"
"logging.setLogRecordFactory(record_factory)"
msgstr ""
"old_factory = logging.getLogRecordFactory()\n"
"\n"
"def record_factory(*args, **kwargs):\n"
"    record = old_factory(*args, **kwargs)\n"
"    record.custom_attribute = 0xdecafbad\n"
"    return record\n"
"\n"
"logging.setLogRecordFactory(record_factory)"

#: ../../howto/logging-cookbook.rst:1851
msgid ""
"This pattern allows different libraries to chain factories together, and as "
"long as they don't overwrite each other's attributes or unintentionally "
"overwrite the attributes provided as standard, there should be no surprises. "
"However, it should be borne in mind that each link in the chain adds run-"
"time overhead to all logging operations, and the technique should only be "
"used when the use of a :class:`Filter` does not provide the desired result."
msgstr ""
"Este patrón permite a diferentes bibliotecas encadenar fábricas, y mientras "
"no sobrescriban los atributos de las demás o sobrescriban involuntariamente "
"los atributos proporcionados como estándar, no debería haber sorpresas. Sin "
"embargo, debe tenerse en cuenta que cada eslabón de la cadena añade "
"sobrecarga en tiempo de ejecución a todas las operaciones de registro, y la "
"técnica sólo debe utilizarse cuando el uso de :class:`Filter` no proporcione "
"el resultado deseado."

#: ../../howto/logging-cookbook.rst:1863
msgid "Subclassing QueueHandler and QueueListener- a ZeroMQ example"
msgstr ""
"Subclasificación de QueueHandler y QueueListener - un ejemplo de ZeroMQ"

#: ../../howto/logging-cookbook.rst:1866 ../../howto/logging-cookbook.rst:1999
msgid "Subclass ``QueueHandler``"
msgstr "Subclase ``QueueHandler``"

#: ../../howto/logging-cookbook.rst:1868
msgid ""
"You can use a :class:`QueueHandler` subclass to send messages to other kinds "
"of queues, for example a ZeroMQ 'publish' socket. In the example below,the "
"socket is created separately and passed to the handler (as its 'queue')::"
msgstr ""
"Puede utilizar una subclase de :class:`QueueHandler` para enviar mensajes a "
"otros tipos de colas, por ejemplo un socket 'publish' de ZeroMQ. En el "
"siguiente ejemplo,el socket se crea por separado y se pasa al manejador "
"(como su 'cola')::"

#: ../../howto/logging-cookbook.rst:1872
msgid ""
"import zmq   # using pyzmq, the Python binding for ZeroMQ\n"
"import json  # for serializing records portably\n"
"\n"
"ctx = zmq.Context()\n"
"sock = zmq.Socket(ctx, zmq.PUB)  # or zmq.PUSH, or other suitable value\n"
"sock.bind('tcp://*:5556')        # or wherever\n"
"\n"
"class ZeroMQSocketHandler(QueueHandler):\n"
"    def enqueue(self, record):\n"
"        self.queue.send_json(record.__dict__)\n"
"\n"
"\n"
"handler = ZeroMQSocketHandler(sock)"
msgstr ""
"import zmq # usando pyzmq, el enlace Python para ZeroMQ\n"
"import json # para serializar registros de forma portable\n"
"\n"
"ctx = zmq.Context()\n"
"sock = zmq.Socket(ctx, zmq.PUB) # o zmq.PUSH, u otro valor adecuado\n"
"sock.bind('tcp://*:5556') # o donde sea\n"
"\n"
"class ZeroMQSocketHandler(QueueHandler):\n"
"    def enqueue(self, record):\n"
"        self.queue.send_json(record.__dict__)\n"
"\n"
"\n"
"handler = ZeroMQSocketHandler(sock)"

#: ../../howto/logging-cookbook.rst:1887
msgid ""
"Of course there are other ways of organizing this, for example passing in "
"the data needed by the handler to create the socket::"
msgstr ""
"Por supuesto hay otras formas de organizar esto, por ejemplo pasando los "
"datos que necesita el handler para crear el socket::"

#: ../../howto/logging-cookbook.rst:1890
msgid ""
"class ZeroMQSocketHandler(QueueHandler):\n"
"    def __init__(self, uri, socktype=zmq.PUB, ctx=None):\n"
"        self.ctx = ctx or zmq.Context()\n"
"        socket = zmq.Socket(self.ctx, socktype)\n"
"        socket.bind(uri)\n"
"        super().__init__(socket)\n"
"\n"
"    def enqueue(self, record):\n"
"        self.queue.send_json(record.__dict__)\n"
"\n"
"    def close(self):\n"
"        self.queue.close()"
msgstr ""
"class ZeroMQSocketHandler(QueueHandler):\n"
"    def __init__(self, uri, socktype=zmq.PUB, ctx=None):\n"
"        self.ctx = ctx or zmq.Context()\n"
"        socket = zmq.Socket(self.ctx, socktype)\n"
"        socket.bind(uri)\n"
"        super().__init__(socket)\n"
"\n"
"    def enqueue(self, record):\n"
"        self.queue.send_json(record.__dict__)\n"
"\n"
"    def close(self):\n"
"        self.queue.close()"

#: ../../howto/logging-cookbook.rst:1905 ../../howto/logging-cookbook.rst:1935
msgid "Subclass ``QueueListener``"
msgstr "Subclase ``QueueListener``"

#: ../../howto/logging-cookbook.rst:1907
msgid ""
"You can also subclass :class:`QueueListener` to get messages from other "
"kinds of queues, for example a ZeroMQ 'subscribe' socket. Here's an example::"
msgstr ""
"También puedes subclasificar :class:`QueueListener` para obtener mensajes de "
"otros tipos de colas, por ejemplo un socket 'subscribe' de ZeroMQ. He aquí "
"un ejemplo::"

#: ../../howto/logging-cookbook.rst:1910
msgid ""
"class ZeroMQSocketListener(QueueListener):\n"
"    def __init__(self, uri, /, *handlers, **kwargs):\n"
"        self.ctx = kwargs.get('ctx') or zmq.Context()\n"
"        socket = zmq.Socket(self.ctx, zmq.SUB)\n"
"        socket.setsockopt_string(zmq.SUBSCRIBE, '')  # subscribe to "
"everything\n"
"        socket.connect(uri)\n"
"        super().__init__(socket, *handlers, **kwargs)\n"
"\n"
"    def dequeue(self):\n"
"        msg = self.queue.recv_json()\n"
"        return logging.makeLogRecord(msg)"
msgstr ""
"class ZeroMQSocketListener(QueueListener):\n"
"    def __init__(self, uri, /, *handlers, **kwargs):\n"
"        self.ctx = kwargs.get('ctx') or zmq.Context()\n"
"        socket = zmq.Socket(self.ctx, zmq.SUB)\n"
"        socket.setsockopt_string(zmq.SUBSCRIBE, '')  # subscribe to "
"everything\n"
"        socket.connect(uri)\n"
"        super().__init__(socket, *handlers, **kwargs)\n"
"\n"
"    def dequeue(self):\n"
"        msg = self.queue.recv_json()\n"
"        return logging.makeLogRecord(msg)"

#: ../../howto/logging-cookbook.rst:1925
msgid "Subclassing QueueHandler and QueueListener- a ``pynng`` example"
msgstr "Subclassing QueueHandler and QueueListener- un ejemplo ``pynng`` "

#: ../../howto/logging-cookbook.rst:1927
msgid ""
"In a similar way to the above section, we can implement a listener and "
"handler using :pypi:`pynng`, which is a Python binding to `NNG <https://nng."
"nanomsg.org/>`_, billed as a spiritual successor to ZeroMQ. The following "
"snippets illustrate -- you can test them in an environment which has "
"``pynng`` installed. Just for variety, we present the listener first."
msgstr ""
"De forma similar a la sección anterior, podemos implementar un listener y un "
"handler utilizando :pypi:`pynng`, que es un enlace de Python a `NNG <https://"
"nng.nanomsg.org/>`_, considerado el sucesor espiritual de ZeroMQ. Los "
"siguientes fragmentos ilustran -- puedes probarlos en un entorno que tenga "
"instalado ``pynng``. Para variar, presentamos primero el listener."

#: ../../howto/logging-cookbook.rst:1937
msgid ""
"# listener.py\n"
"import json\n"
"import logging\n"
"import logging.handlers\n"
"\n"
"import pynng\n"
"\n"
"DEFAULT_ADDR = \"tcp://localhost:13232\"\n"
"\n"
"interrupted = False\n"
"\n"
"class NNGSocketListener(logging.handlers.QueueListener):\n"
"\n"
"    def __init__(self, uri, /, *handlers, **kwargs):\n"
"        # Have a timeout for interruptability, and open a\n"
"        # subscriber socket\n"
"        socket = pynng.Sub0(listen=uri, recv_timeout=500)\n"
"        # The b'' subscription matches all topics\n"
"        topics = kwargs.pop('topics', None) or b''\n"
"        socket.subscribe(topics)\n"
"        # We treat the socket as a queue\n"
"        super().__init__(socket, *handlers, **kwargs)\n"
"\n"
"    def dequeue(self, block):\n"
"        data = None\n"
"        # Keep looping while not interrupted and no data received over the\n"
"        # socket\n"
"        while not interrupted:\n"
"            try:\n"
"                data = self.queue.recv(block=block)\n"
"                break\n"
"            except pynng.Timeout:\n"
"                pass\n"
"            except pynng.Closed:  # sometimes happens when you hit Ctrl-C\n"
"                break\n"
"        if data is None:\n"
"            return None\n"
"        # Get the logging event sent from a publisher\n"
"        event = json.loads(data.decode('utf-8'))\n"
"        return logging.makeLogRecord(event)\n"
"\n"
"    def enqueue_sentinel(self):\n"
"        # Not used in this implementation, as the socket isn't really a\n"
"        # queue\n"
"        pass\n"
"\n"
"logging.getLogger('pynng').propagate = False\n"
"listener = NNGSocketListener(DEFAULT_ADDR, logging.StreamHandler(), "
"topics=b'')\n"
"listener.start()\n"
"print('Press Ctrl-C to stop.')\n"
"try:\n"
"    while True:\n"
"        pass\n"
"except KeyboardInterrupt:\n"
"    interrupted = True\n"
"finally:\n"
"    listener.stop()"
msgstr ""
"# listener.py\n"
"import json\n"
"import logging\n"
"import logging.handlers\n"
"\n"
"import pynng\n"
"\n"
"DEFAULT_ADDR = \"tcp://localhost:13232\"\n"
"\n"
"interrumpido = False\n"
"\n"
"class NNGSocketListener(logging.handlers.QueueListener):\n"
"\n"
"    def __init__(self, uri, /, *handlers, **kwargs):\n"
"        # Tener un tiempo de espera para la interrumpibilidad, y abrir un\n"
"        # subscriber socket\n"
"        socket = pynng.Sub0(listen=uri, recv_timeout=500)\n"
"        # La suscripción b'' coincide con todos los temas\n"
"        topics = kwargs.pop('topics', None) o b''\n"
"        socket.subscribe(topics)\n"
"        # Tratamos el socket como una cola\n"
"        super().__init__(socket, *handlers, **kwargs)\n"
"\n"
"    def dequeue(self, block):\n"
"        data = None\n"
"        # Mantener el bucle mientras no se interrumpa y no se reciban datos "
"sobre el\n"
"        # socket\n"
"        mientras no se interrumpa:\n"
"            try:\n"
"                data = self.queue.recv(block=bloque)\n"
"                break\n"
"            except pynng.Timeout:\n"
"                pass\n"
"            excepto pynng.Closed:  # a veces ocurre cuando pulsas Ctrl-C\n"
"                break\n"
"        si los datos son None\n"
"            return None\n"
"        # Obtener el dato de registro enviado desde un editor\n"
"        event = json.loads(data.decode('utf-8'))\n"
"        return logging.makeLogRecord(evento)\n"
"\n"
"    def enqueue_sentinel(self):\n"
"        # No se usa en esta implementación, ya que el socket no es realmente "
"una\n"
"        # cola\n"
"        pass\n"
"\n"
"logging.getLogger('pynng').propagate = False\n"
"listener = NNGSocketListener(DEFAULT_ADDR, logging.StreamHandler(), "
"topics=b'')\n"
"listener.start()\n"
"print('Pulse Ctrl-C para parar.')\n"
"probar:\n"
"    while True\n"
"        pass\n"
"excepto KeyboardInterrupt:\n"
"    interrumpido = True\n"
"finalmente:\n"
"    listener.stop()"

#: ../../howto/logging-cookbook.rst:2003
msgid ""
"# sender.py\n"
"import json\n"
"import logging\n"
"import logging.handlers\n"
"import time\n"
"import random\n"
"\n"
"import pynng\n"
"\n"
"DEFAULT_ADDR = \"tcp://localhost:13232\"\n"
"\n"
"class NNGSocketHandler(logging.handlers.QueueHandler):\n"
"\n"
"    def __init__(self, uri):\n"
"        socket = pynng.Pub0(dial=uri, send_timeout=500)\n"
"        super().__init__(socket)\n"
"\n"
"    def enqueue(self, record):\n"
"        # Send the record as UTF-8 encoded JSON\n"
"        d = dict(record.__dict__)\n"
"        data = json.dumps(d)\n"
"        self.queue.send(data.encode('utf-8'))\n"
"\n"
"    def close(self):\n"
"        self.queue.close()\n"
"\n"
"logging.getLogger('pynng').propagate = False\n"
"handler = NNGSocketHandler(DEFAULT_ADDR)\n"
"# Make sure the process ID is in the output\n"
"logging.basicConfig(level=logging.DEBUG,\n"
"                    handlers=[logging.StreamHandler(), handler],\n"
"                    format='%(levelname)-8s %(name)10s %(process)6s "
"%(message)s')\n"
"levels = (logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR,\n"
"          logging.CRITICAL)\n"
"logger_names = ('myapp', 'myapp.lib1', 'myapp.lib2')\n"
"msgno = 1\n"
"while True:\n"
"    # Just randomly select some loggers and levels and log away\n"
"    level = random.choice(levels)\n"
"    logger = logging.getLogger(random.choice(logger_names))\n"
"    logger.log(level, 'Message no. %5d' % msgno)\n"
"    msgno += 1\n"
"    delay = random.random() * 2 + 0.5\n"
"    time.sleep(delay)"
msgstr ""
"# sender.py\n"
"import json\n"
"import logging\n"
"import logging.handlers\n"
"import tiempo\n"
"import random\n"
"\n"
"import pynng\n"
"\n"
"DEFAULT_ADDR = \"tcp://localhost:13232\"\n"
"\n"
"class NNGSocketHandler(logging.handlers.QueueHandler):\n"
"\n"
"    def __init__(self, uri):\n"
"        socket = pynng.Pub0(dial=uri, send_timeout=500)\n"
"        super().__init__(socket)\n"
"\n"
"    def enqueue(self, record):\n"
"        # Envía el registro como JSON codificado en UTF-8\n"
"        d = dict(registro.__dict__)\n"
"        data = json.dumps(d)\n"
"        self.queue.send(data.encode('utf-8'))\n"
"\n"
"    def close(self):\n"
"        self.queue.close()\n"
"\n"
"logging.getLogger('pynng').propagate = False\n"
"handler = NNGSocketHandler(DEFAULT_ADDR)\n"
"# Asegúrese de que el ID del proceso está en la salida\n"
"logging.basicConfig(level=logging.DEBUG,\n"
"                    handlers=[logging.StreamHandler(), handler],\n"
"                    format='%(levelname)-8s %(name)10s %(process)6s "
"%(message)s ')\n"
"levels = (logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR,\n"
"          logging.CRITICAL)\n"
"logger_names = ('myapp', 'myapp.lib1', 'myapp.lib2')\n"
"msgno = 1\n"
"while True:\n"
"    # Selecciona aleatoriamente algunos loggers y niveles y registra\n"
"    level = random.choice(levels)\n"
"    logger = logging.getLogger(random.choice(logger_names))\n"
"    logger.log(level, 'Mensaje nº %5d' % msgno)\n"
"    msgno += 1\n"
"    retardo = random.random() * 2 + 0.5\n"
"    time.sleep(retardo)"

#: ../../howto/logging-cookbook.rst:2050
msgid ""
"You can run the above two snippets in separate command shells. If we run the "
"listener in one shell and run the sender in two separate shells, we should "
"see something like the following. In the first sender shell:"
msgstr ""
"Puede ejecutar los dos fragmentos anteriores en shells de comandos "
"separados. Si ejecutamos el listener en un shell y ejecutamos el sender en "
"dos shells separados, deberíamos ver algo como lo siguiente. En la primera "
"shell del emisor:"

#: ../../howto/logging-cookbook.rst:2054
msgid ""
"$ python sender.py\n"
"DEBUG         myapp    613 Message no.     1\n"
"WARNING  myapp.lib2    613 Message no.     2\n"
"CRITICAL myapp.lib2    613 Message no.     3\n"
"WARNING  myapp.lib2    613 Message no.     4\n"
"CRITICAL myapp.lib1    613 Message no.     5\n"
"DEBUG         myapp    613 Message no.     6\n"
"CRITICAL myapp.lib1    613 Message no.     7\n"
"INFO     myapp.lib1    613 Message no.     8\n"
"(and so on)"
msgstr ""
"$ python sender.py\n"
"DEBUG         myapp    613 Message no.     1\n"
"WARNING  myapp.lib2    613 Message no.     2\n"
"CRITICAL myapp.lib2    613 Message no.     3\n"
"WARNING  myapp.lib2    613 Message no.     4\n"
"CRITICAL myapp.lib1    613 Message no.     5\n"
"DEBUG         myapp    613 Message no.     6\n"
"CRITICAL myapp.lib1    613 Message no.     7\n"
"INFO     myapp.lib1    613 Message no.     8\n"
"(and so on)"

#: ../../howto/logging-cookbook.rst:2067
msgid "In the second sender shell:"
msgstr "En el segundo shell emisor:"

#: ../../howto/logging-cookbook.rst:2069
msgid ""
"$ python sender.py\n"
"INFO     myapp.lib2    657 Message no.     1\n"
"CRITICAL myapp.lib2    657 Message no.     2\n"
"CRITICAL      myapp    657 Message no.     3\n"
"CRITICAL myapp.lib1    657 Message no.     4\n"
"INFO     myapp.lib1    657 Message no.     5\n"
"WARNING  myapp.lib2    657 Message no.     6\n"
"CRITICAL      myapp    657 Message no.     7\n"
"DEBUG    myapp.lib1    657 Message no.     8\n"
"(and so on)"
msgstr ""
"$ python sender.py\n"
"INFO     myapp.lib2    657 Message no.     1\n"
"CRITICAL myapp.lib2    657 Message no.     2\n"
"CRITICAL      myapp    657 Message no.     3\n"
"CRITICAL myapp.lib1    657 Message no.     4\n"
"INFO     myapp.lib1    657 Message no.     5\n"
"WARNING  myapp.lib2    657 Message no.     6\n"
"CRITICAL      myapp    657 Message no.     7\n"
"DEBUG    myapp.lib1    657 Message no.     8\n"
"(and so on)"

#: ../../howto/logging-cookbook.rst:2082
msgid "In the listener shell:"
msgstr "En el shell del oyente:"

#: ../../howto/logging-cookbook.rst:2084
msgid ""
"$ python listener.py\n"
"Press Ctrl-C to stop.\n"
"DEBUG         myapp    613 Message no.     1\n"
"WARNING  myapp.lib2    613 Message no.     2\n"
"INFO     myapp.lib2    657 Message no.     1\n"
"CRITICAL myapp.lib2    613 Message no.     3\n"
"CRITICAL myapp.lib2    657 Message no.     2\n"
"CRITICAL      myapp    657 Message no.     3\n"
"WARNING  myapp.lib2    613 Message no.     4\n"
"CRITICAL myapp.lib1    613 Message no.     5\n"
"CRITICAL myapp.lib1    657 Message no.     4\n"
"INFO     myapp.lib1    657 Message no.     5\n"
"DEBUG         myapp    613 Message no.     6\n"
"WARNING  myapp.lib2    657 Message no.     6\n"
"CRITICAL      myapp    657 Message no.     7\n"
"CRITICAL myapp.lib1    613 Message no.     7\n"
"INFO     myapp.lib1    613 Message no.     8\n"
"DEBUG    myapp.lib1    657 Message no.     8\n"
"(and so on)"
msgstr ""
"$ python listener.py\n"
"Press Ctrl-C to stop.\n"
"DEBUG         myapp    613 Message no.     1\n"
"WARNING  myapp.lib2    613 Message no.     2\n"
"INFO     myapp.lib2    657 Message no.     1\n"
"CRITICAL myapp.lib2    613 Message no.     3\n"
"CRITICAL myapp.lib2    657 Message no.     2\n"
"CRITICAL      myapp    657 Message no.     3\n"
"WARNING  myapp.lib2    613 Message no.     4\n"
"CRITICAL myapp.lib1    613 Message no.     5\n"
"CRITICAL myapp.lib1    657 Message no.     4\n"
"INFO     myapp.lib1    657 Message no.     5\n"
"DEBUG         myapp    613 Message no.     6\n"
"WARNING  myapp.lib2    657 Message no.     6\n"
"CRITICAL      myapp    657 Message no.     7\n"
"CRITICAL myapp.lib1    613 Message no.     7\n"
"INFO     myapp.lib1    613 Message no.     8\n"
"DEBUG    myapp.lib1    657 Message no.     8\n"
"(and so on)"

#: ../../howto/logging-cookbook.rst:2106
msgid ""
"As you can see, the logging from the two sender processes is interleaved in "
"the listener's output."
msgstr ""
"Como puede ver, el registro de los dos procesos emisores se intercala en la "
"salida del oyente."

#: ../../howto/logging-cookbook.rst:2111
msgid "An example dictionary-based configuration"
msgstr "Ejemplo de configuración basada en diccionarios"

#: ../../howto/logging-cookbook.rst:2113
msgid ""
"Below is an example of a logging configuration dictionary - it's taken from "
"the `documentation on the Django project <https://docs.djangoproject.com/en/"
"stable/topics/logging/#configuring-logging>`_. This dictionary is passed to :"
"func:`~config.dictConfig` to put the configuration into effect::"
msgstr ""
"A continuación se muestra un ejemplo de un diccionario de configuración de "
"registro - está tomado de la `documentación sobre el proyecto Django "
"<https://docs.djangoproject.com/en/stable/topics/logging/#configuring-"
"logging>`_. Este diccionario se pasa a :func:`~config.dictConfig` para poner "
"la configuración en efecto::"

#: ../../howto/logging-cookbook.rst:2117
msgid ""
"LOGGING = {\n"
"    'version': 1,\n"
"    'disable_existing_loggers': False,\n"
"    'formatters': {\n"
"        'verbose': {\n"
"            'format': '{levelname} {asctime} {module} {process:d} {thread:d} "
"{message}',\n"
"            'style': '{',\n"
"        },\n"
"        'simple': {\n"
"            'format': '{levelname} {message}',\n"
"            'style': '{',\n"
"        },\n"
"    },\n"
"    'filters': {\n"
"        'special': {\n"
"            '()': 'project.logging.SpecialFilter',\n"
"            'foo': 'bar',\n"
"        },\n"
"    },\n"
"    'handlers': {\n"
"        'console': {\n"
"            'level': 'INFO',\n"
"            'class': 'logging.StreamHandler',\n"
"            'formatter': 'simple',\n"
"        },\n"
"        'mail_admins': {\n"
"            'level': 'ERROR',\n"
"            'class': 'django.utils.log.AdminEmailHandler',\n"
"            'filters': ['special']\n"
"        }\n"
"    },\n"
"    'loggers': {\n"
"        'django': {\n"
"            'handlers': ['console'],\n"
"            'propagate': True,\n"
"        },\n"
"        'django.request': {\n"
"            'handlers': ['mail_admins'],\n"
"            'level': 'ERROR',\n"
"            'propagate': False,\n"
"        },\n"
"        'myproject.custom': {\n"
"            'handlers': ['console', 'mail_admins'],\n"
"            'level': 'INFO',\n"
"            'filters': ['special']\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"LOGGING = {\n"
"    versión 1,\n"
"    'disable_existing_loggers': False,\n"
"    formateadores': {\n"
"        verbose': {\n"
"            'format': '{levelname} {asctime} {module} {process:d} {thread:d} "
"{message}',\n"
"            'style': '{',\n"
"        },\n"
"        'simple': {\n"
"            'format': '{levelname} {message}',\n"
"            'style': '{',\n"
"        },\n"
"    },\n"
"    filtros\": {\n"
"        'special': {\n"
"            '()': 'project.logging.SpecialFilter',\n"
"            'foo': 'bar',\n"
"        },\n"
"    },\n"
"    'handlers': {\n"
"        'console': {\n"
"            'level': 'INFO',\n"
"            'class': 'logging.StreamHandler',\n"
"            'formatter': 'simple',\n"
"        },\n"
"        'mail_admins': {\n"
"            'level': 'ERROR',\n"
"            'class': 'django.utils.log.AdminEmailHandler',\n"
"            'filters': ['special']\n"
"        }\n"
"    },\n"
"    'loggers': {\n"
"        'django': {\n"
"            'handlers': ['console'],\n"
"            'propagate': True,\n"
"        },\n"
"        'django.request': {\n"
"            'handlers': ['mail_admins'],\n"
"            'level': 'ERROR',\n"
"            'propagate': 'False',\n"
"        },\n"
"        'myproject.custom': {\n"
"            'handlers': ['console', 'mail_admins'],\n"
"            'level': 'INFO',\n"
"            'filters': ['special']\n"
"        }\n"
"    }\n"
"}"

#: ../../howto/logging-cookbook.rst:2166
msgid ""
"For more information about this configuration, you can see the `relevant "
"section <https://docs.djangoproject.com/en/stable/topics/logging/"
"#configuring-logging>`_ of the Django documentation."
msgstr ""
"Para más información sobre esta configuración, puedes consultar la `sección "
"relevante <https://docs.djangoproject.com/en/stable/topics/logging/"
"#configuring-logging>`_ de la documentación de Django."

#: ../../howto/logging-cookbook.rst:2173
msgid "Using a rotator and namer to customize log rotation processing"
msgstr ""
"Uso de un rotador y un namer para personalizar el procesamiento de la "
"rotación de registros"

#: ../../howto/logging-cookbook.rst:2175
msgid ""
"An example of how you can define a namer and rotator is given in the "
"following runnable script, which shows gzip compression of the log file::"
msgstr ""
"Un ejemplo de cómo puede definir un namer y un rotator se da en el siguiente "
"script ejecutable, que muestra la compresión gzip del archivo de registro::"

#: ../../howto/logging-cookbook.rst:2178
msgid ""
"import gzip\n"
"import logging\n"
"import logging.handlers\n"
"import os\n"
"import shutil\n"
"\n"
"def namer(name):\n"
"    return name + \".gz\"\n"
"\n"
"def rotator(source, dest):\n"
"    with open(source, 'rb') as f_in:\n"
"        with gzip.open(dest, 'wb') as f_out:\n"
"            shutil.copyfileobj(f_in, f_out)\n"
"    os.remove(source)\n"
"\n"
"\n"
"rh = logging.handlers.RotatingFileHandler('rotated.log', maxBytes=128, "
"backupCount=5)\n"
"rh.rotator = rotator\n"
"rh.namer = namer\n"
"\n"
"root = logging.getLogger()\n"
"root.setLevel(logging.INFO)\n"
"root.addHandler(rh)\n"
"f = logging.Formatter('%(asctime)s %(message)s')\n"
"rh.setFormatter(f)\n"
"for i in range(1000):\n"
"    root.info(f'Message no. {i + 1}')"
msgstr ""
"import gzip\n"
"import logging\n"
"import logging.handlers\n"
"import os\n"
"import shutil\n"
"\n"
"def namer(name):\n"
"    return name + \".gz\"\n"
"\n"
"def rotator(source, dest):\n"
"    with open(source, 'rb') as f_in:\n"
"        with gzip.open(dest, 'wb') as f_out:\n"
"            shutil.copyfileobj(f_in, f_out)\n"
"    os.remove(source)\n"
"\n"
"\n"
"rh = logging.handlers.RotatingFileHandler('rotated.log', maxBytes=128, "
"backupCount=5)\n"
"rh.rotator = rotator\n"
"rh.namer = namer\n"
"\n"
"root = logging.getLogger()\n"
"root.setLevel(logging.INFO)\n"
"root.addHandler(rh)\n"
"f = logging.Formatter('%(asctime)s %(message)s')\n"
"rh.setFormatter(f)\n"
"for i in range(1000):\n"
"    root.info(f'Message no. {i + 1}')"

#: ../../howto/logging-cookbook.rst:2206
msgid ""
"After running this, you will see six new files, five of which are compressed:"
msgstr ""
"Después de ejecutar esto, verá seis nuevos archivos, cinco de los cuales "
"están comprimidos:"

#: ../../howto/logging-cookbook.rst:2208
msgid ""
"$ ls rotated.log*\n"
"rotated.log       rotated.log.2.gz  rotated.log.4.gz\n"
"rotated.log.1.gz  rotated.log.3.gz  rotated.log.5.gz\n"
"$ zcat rotated.log.1.gz\n"
"2023-01-20 02:28:17,767 Message no. 996\n"
"2023-01-20 02:28:17,767 Message no. 997\n"
"2023-01-20 02:28:17,767 Message no. 998"
msgstr ""
"$ ls rotated.log*\n"
"rotated.log       rotated.log.2.gz  rotated.log.4.gz\n"
"rotated.log.1.gz  rotated.log.3.gz  rotated.log.5.gz\n"
"$ zcat rotated.log.1.gz\n"
"2023-01-20 02:28:17,767 Message no. 996\n"
"2023-01-20 02:28:17,767 Message no. 997\n"
"2023-01-20 02:28:17,767 Message no. 998"

#: ../../howto/logging-cookbook.rst:2219
msgid "A more elaborate multiprocessing example"
msgstr "Un ejemplo más elaborado de multiproceso"

#: ../../howto/logging-cookbook.rst:2221
msgid ""
"The following working example shows how logging can be used with "
"multiprocessing using configuration files. The configurations are fairly "
"simple, but serve to illustrate how more complex ones could be implemented "
"in a real multiprocessing scenario."
msgstr ""
"El siguiente ejemplo de trabajo muestra cómo se puede utilizar el registro "
"con multiproceso utilizando archivos de configuración. Las configuraciones "
"son bastante sencillas, pero sirven para ilustrar cómo podrían implementarse "
"otras más complejas en un escenario real de multiproco."

#: ../../howto/logging-cookbook.rst:2226
msgid ""
"In the example, the main process spawns a listener process and some worker "
"processes. Each of the main process, the listener and the workers have three "
"separate configurations (the workers all share the same configuration). We "
"can see logging in the main process, how the workers log to a QueueHandler "
"and how the listener implements a QueueListener and a more complex logging "
"configuration, and arranges to dispatch events received via the queue to the "
"handlers specified in the configuration. Note that these configurations are "
"purely illustrative, but you should be able to adapt this example to your "
"own scenario."
msgstr ""
"En el ejemplo, el proceso principal genera un proceso de escucha y algunos "
"procesos de trabajo. Cada proceso principal, el listener y los workers "
"tienen tres configuraciones separadas (los workers comparten la misma "
"configuración). Podemos ver el registro en el proceso principal, cómo los "
"trabajadores se registran en un QueueHandler y cómo el listener implementa "
"un QueueListener y una configuración de registro más compleja, y se encarga "
"de enviar los eventos recibidos a través de la cola a los handlers "
"especificados en la configuración. Ten en cuenta que estas configuraciones "
"son puramente ilustrativas, pero deberías ser capaz de adaptar este ejemplo "
"a tu propio escenario."

#: ../../howto/logging-cookbook.rst:2236
msgid ""
"Here's the script - the docstrings and the comments hopefully explain how it "
"works::"
msgstr ""
"Aquí está el script - los docstrings y los comentarios esperan explicar cómo "
"funciona::"

#: ../../howto/logging-cookbook.rst:2239
msgid ""
"import logging\n"
"import logging.config\n"
"import logging.handlers\n"
"from multiprocessing import Process, Queue, Event, current_process\n"
"import os\n"
"import random\n"
"import time\n"
"\n"
"class MyHandler:\n"
"    \"\"\"\n"
"    A simple handler for logging events. It runs in the listener process "
"and\n"
"    dispatches events to loggers based on the name in the received record,\n"
"    which then get dispatched, by the logging system, to the handlers\n"
"    configured for those loggers.\n"
"    \"\"\"\n"
"\n"
"    def handle(self, record):\n"
"        if record.name == \"root\":\n"
"            logger = logging.getLogger()\n"
"        else:\n"
"            logger = logging.getLogger(record.name)\n"
"\n"
"        if logger.isEnabledFor(record.levelno):\n"
"            # The process name is transformed just to show that it's the "
"listener\n"
"            # doing the logging to files and console\n"
"            record.processName = '%s (for %s)' % (current_process().name, "
"record.processName)\n"
"            logger.handle(record)\n"
"\n"
"def listener_process(q, stop_event, config):\n"
"    \"\"\"\n"
"    This could be done in the main process, but is just done in a separate\n"
"    process for illustrative purposes.\n"
"\n"
"    This initialises logging according to the specified configuration,\n"
"    starts the listener and waits for the main process to signal completion\n"
"    via the event. The listener is then stopped, and the process exits.\n"
"    \"\"\"\n"
"    logging.config.dictConfig(config)\n"
"    listener = logging.handlers.QueueListener(q, MyHandler())\n"
"    listener.start()\n"
"    if os.name == 'posix':\n"
"        # On POSIX, the setup logger will have been configured in the\n"
"        # parent process, but should have been disabled following the\n"
"        # dictConfig call.\n"
"        # On Windows, since fork isn't used, the setup logger won't\n"
"        # exist in the child, so it would be created and the message\n"
"        # would appear - hence the \"if posix\" clause.\n"
"        logger = logging.getLogger('setup')\n"
"        logger.critical('Should not appear, because of disabled "
"logger ...')\n"
"    stop_event.wait()\n"
"    listener.stop()\n"
"\n"
"def worker_process(config):\n"
"    \"\"\"\n"
"    A number of these are spawned for the purpose of illustration. In\n"
"    practice, they could be a heterogeneous bunch of processes rather than\n"
"    ones which are identical to each other.\n"
"\n"
"    This initialises logging according to the specified configuration,\n"
"    and logs a hundred messages with random levels to randomly selected\n"
"    loggers.\n"
"\n"
"    A small sleep is added to allow other processes a chance to run. This\n"
"    is not strictly needed, but it mixes the output from the different\n"
"    processes a bit more than if it's left out.\n"
"    \"\"\"\n"
"    logging.config.dictConfig(config)\n"
"    levels = [logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR,\n"
"              logging.CRITICAL]\n"
"    loggers = ['foo', 'foo.bar', 'foo.bar.baz',\n"
"               'spam', 'spam.ham', 'spam.ham.eggs']\n"
"    if os.name == 'posix':\n"
"        # On POSIX, the setup logger will have been configured in the\n"
"        # parent process, but should have been disabled following the\n"
"        # dictConfig call.\n"
"        # On Windows, since fork isn't used, the setup logger won't\n"
"        # exist in the child, so it would be created and the message\n"
"        # would appear - hence the \"if posix\" clause.\n"
"        logger = logging.getLogger('setup')\n"
"        logger.critical('Should not appear, because of disabled "
"logger ...')\n"
"    for i in range(100):\n"
"        lvl = random.choice(levels)\n"
"        logger = logging.getLogger(random.choice(loggers))\n"
"        logger.log(lvl, 'Message no. %d', i)\n"
"        time.sleep(0.01)\n"
"\n"
"def main():\n"
"    q = Queue()\n"
"    # The main process gets a simple configuration which prints to the "
"console.\n"
"    config_initial = {\n"
"        'version': 1,\n"
"        'handlers': {\n"
"            'console': {\n"
"                'class': 'logging.StreamHandler',\n"
"                'level': 'INFO'\n"
"            }\n"
"        },\n"
"        'root': {\n"
"            'handlers': ['console'],\n"
"            'level': 'DEBUG'\n"
"        }\n"
"    }\n"
"    # The worker process configuration is just a QueueHandler attached to "
"the\n"
"    # root logger, which allows all messages to be sent to the queue.\n"
"    # We disable existing loggers to disable the \"setup\" logger used in "
"the\n"
"    # parent process. This is needed on POSIX because the logger will\n"
"    # be there in the child following a fork().\n"
"    config_worker = {\n"
"        'version': 1,\n"
"        'disable_existing_loggers': True,\n"
"        'handlers': {\n"
"            'queue': {\n"
"                'class': 'logging.handlers.QueueHandler',\n"
"                'queue': q\n"
"            }\n"
"        },\n"
"        'root': {\n"
"            'handlers': ['queue'],\n"
"            'level': 'DEBUG'\n"
"        }\n"
"    }\n"
"    # The listener process configuration shows that the full flexibility of\n"
"    # logging configuration is available to dispatch events to handlers "
"however\n"
"    # you want.\n"
"    # We disable existing loggers to disable the \"setup\" logger used in "
"the\n"
"    # parent process. This is needed on POSIX because the logger will\n"
"    # be there in the child following a fork().\n"
"    config_listener = {\n"
"        'version': 1,\n"
"        'disable_existing_loggers': True,\n"
"        'formatters': {\n"
"            'detailed': {\n"
"                'class': 'logging.Formatter',\n"
"                'format': '%(asctime)s %(name)-15s %(levelname)-8s "
"%(processName)-10s %(message)s'\n"
"            },\n"
"            'simple': {\n"
"                'class': 'logging.Formatter',\n"
"                'format': '%(name)-15s %(levelname)-8s %(processName)-10s "
"%(message)s'\n"
"            }\n"
"        },\n"
"        'handlers': {\n"
"            'console': {\n"
"                'class': 'logging.StreamHandler',\n"
"                'formatter': 'simple',\n"
"                'level': 'INFO'\n"
"            },\n"
"            'file': {\n"
"                'class': 'logging.FileHandler',\n"
"                'filename': 'mplog.log',\n"
"                'mode': 'w',\n"
"                'formatter': 'detailed'\n"
"            },\n"
"            'foofile': {\n"
"                'class': 'logging.FileHandler',\n"
"                'filename': 'mplog-foo.log',\n"
"                'mode': 'w',\n"
"                'formatter': 'detailed'\n"
"            },\n"
"            'errors': {\n"
"                'class': 'logging.FileHandler',\n"
"                'filename': 'mplog-errors.log',\n"
"                'mode': 'w',\n"
"                'formatter': 'detailed',\n"
"                'level': 'ERROR'\n"
"            }\n"
"        },\n"
"        'loggers': {\n"
"            'foo': {\n"
"                'handlers': ['foofile']\n"
"            }\n"
"        },\n"
"        'root': {\n"
"            'handlers': ['console', 'file', 'errors'],\n"
"            'level': 'DEBUG'\n"
"        }\n"
"    }\n"
"    # Log some initial events, just to show that logging in the parent "
"works\n"
"    # normally.\n"
"    logging.config.dictConfig(config_initial)\n"
"    logger = logging.getLogger('setup')\n"
"    logger.info('About to create workers ...')\n"
"    workers = []\n"
"    for i in range(5):\n"
"        wp = Process(target=worker_process, name='worker %d' % (i + 1),\n"
"                     args=(config_worker,))\n"
"        workers.append(wp)\n"
"        wp.start()\n"
"        logger.info('Started worker: %s', wp.name)\n"
"    logger.info('About to create listener ...')\n"
"    stop_event = Event()\n"
"    lp = Process(target=listener_process, name='listener',\n"
"                 args=(q, stop_event, config_listener))\n"
"    lp.start()\n"
"    logger.info('Started listener')\n"
"    # We now hang around for the workers to finish their work.\n"
"    for wp in workers:\n"
"        wp.join()\n"
"    # Workers all done, listening can now stop.\n"
"    # Logging in the parent still works normally.\n"
"    logger.info('Telling listener to stop ...')\n"
"    stop_event.set()\n"
"    lp.join()\n"
"    logger.info('All done.')\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""
"import logging\n"
"import logging.config\n"
"import logging.handlers\n"
"from multiprocessing import Process, Queue, Event, current_process\n"
"import os\n"
"import random\n"
"import time\n"
"\n"
"class MyHandler:\n"
"    \"\"\"\n"
"   Un simple manejador de sucesos de registro. Se ejecuta en el proceso de "
"escucha y\n"
"     envía sucesos a los registradores basándose en el nombre del registro "
"recibido,\n"
"      que luego los envía el sistema de registro, a los manejadores\n"
"       configurados para esos registradores.\n"
"    \"\"\"\n"
"\n"
"    def handle(self, record):\n"
"        if record.name == \"root\":\n"
"            logger = logging.getLogger()\n"
"        else:\n"
"            logger = logging.getLogger(record.name)\n"
"\n"
"        if logger.isEnabledFor(record.levelno):\n"
"            # El nombre del proceso se transforma sólo para mostrar que es "
"el listener\n"
"            # haciendo el logging a ficheros y consola\n"
"            record.processName = '%s (para %s)' % (current_process().name, "
"record.processName)\n"
"            logger.handle(record)\n"
"\n"
"def listener_process(q, stop_event, config):\n"
"    \"\"\"   Esto podría hacerse en el proceso principal, pero se hace en un "
"proceso\n"
"      separado para fines ilustrativos.\n"
"\n"
"      Esto inicializa el registro según la configuración especificada,\n"
"       inicia la escucha y espera a que el proceso principal señale la "
"finalización\n"
"       a través del evento. A continuación, se detiene la escucha y se "
"cierra el proceso..\n"
"    \"\"\"\n"
"    logging.config.dictConfig(config)\n"
"    listener = logging.handlers.QueueListener(q, MyHandler())\n"
"    listener.start()\n"
"    if os.name == 'posix':\n"
"        # En POSIX, el logger de configuración se habrá configurado en el\n"
"        # proceso padre, pero debería haber sido desactivado después de la\n"
"        # dictConfig call.\n"
"        # En Windows, como no se usa fork, el registrador de              # "
"configuración no existirá en el proceso # hijo, por lo que se desactivará.\n"
"         # existirá en el proceso hijo, por lo que se crearía y aparecería "
"el mensaje\n"
"         # aparecería - de ahí la cláusula \"if posix\".\n"
"        logger = logging.getLogger('setup')\n"
"        logger.critical('Should not appear, because of disabled "
"logger ...')\n"
"    stop_event.wait()\n"
"    listener.stop()\n"
"\n"
"def worker_process(config):\n"
"    \"\"\"\n"
"     A modo de ilustración, se crean varios de estos procesos. \n"
"     En la práctica, podría ser un grupo heterogéneo de procesos en lugar "
"de\n"
"      idénticos entre sí.\n"
"\n"
"    Esto inicializa el registro de acuerdo con la configuración "
"especificada,\n"
"    y registra un centenar de mensajes con niveles aleatorios en "
"registradores\n"
"    seleccionados al azar.\n"
"\n"
"     Se añade un pequeño tiempo de espera para permitir que se ejecuten "
"otros procesos. \n"
"      Esto no es estrictamente necesario, pero mezcla la salida de los "
"diferentes\n"
"      procesos un poco más que si se omite.\n"
"    logging.config.dictConfig(config)\n"
"    levels = [logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR,\n"
"              logging.CRITICAL]\n"
"    loggers = ['foo', 'foo.bar', 'foo.bar.baz',\n"
"               'spam', 'spam.ham', 'spam.ham.eggs']\n"
"    if os.name == 'posix':\n"
"        # En POSIX, el registrador de configuración se habrá configurado en "
"el\n"
"       # proceso padre, pero debería haber sido desactivado tras la llamada "
"a\n"
"       # dictConfig.\n"
"      # En Windows, como no se usa fork, el registrador de # configuración "
"no existirá en el proceso # hijo, por lo que se desactivará.\n"
"       # existirá en el proceso hijo, por lo que se crearía y aparecería el "
"mensaje\n"
"       # aparecería - de ahí la cláusula \"if posix\".\n"
"      logger = logging.getLogger('setup')\n"
"     logger.critical('No debería aparecer, debido a logger "
"deshabilitado ...')\n"
"    for i in range(100):\n"
"        lvl = random.choice(levels)\n"
"        logger = logging.getLogger(random.choice(loggers))\n"
"        logger.log(lvl, 'Message no. %d', i)\n"
"        time.sleep(0.01)\n"
"\n"
"def main():\n"
"    q = Queue()\n"
"    # El proceso principal obtiene una configuración simple que se imprime "
"en la consola..\n"
"    config_initial = {\n"
"        'version': 1,\n"
"        'handlers': {\n"
"            'console': {\n"
"                'class': 'logging.StreamHandler',\n"
"                'level': 'INFO'\n"
"            }\n"
"        },\n"
"        'root': {\n"
"            'handlers': ['console'],\n"
"            'level': 'DEBUG'\n"
"        }\n"
"    }\n"
"     # La configuración del proceso de trabajo es sólo un QueueHandler "
"adjunto al\n"
"     # root logger, que permite enviar todos los mensajes a la cola.\n"
"     # Deshabilitamos los loggers existentes para deshabilitar el logger "
"\"setup\" usado en el\n"
"     # proceso padre. Esto es necesario en POSIX porque el logger\n"
"    # estará en el proceso hijo después de un fork().\n"
"    config_worker = {\n"
"        'version': 1,\n"
"        'disable_existing_loggers': True,\n"
"        'handlers': {\n"
"            'queue': {\n"
"                'class': 'logging.handlers.QueueHandler',\n"
"                'queue': q\n"
"            }\n"
"        },\n"
"        'root': {\n"
"            'handlers': ['queue'],\n"
"            'level': 'DEBUG'\n"
"        }\n"
"    }\n"
"   # La configuración del proceso de escucha muestra que toda la "
"flexibilidad de\n"
"   # la configuración de registro está disponible para enviar eventos a los "
"manejadores como\n"
"   # que quieras.\n"
"   # Deshabilitamos los loggers existentes para deshabilitar el logger "
"\"setup\" usado en el # proceso padre.\n"
"    # proceso padre. Esto es necesario en POSIX porque el logger\n"
"    # estará en el proceso hijo después de un fork().\n"
"    config_listener = {\n"
"        'version': 1,\n"
"        'disable_existing_loggers': True,\n"
"        'formatters': {\n"
"            'detailed': {\n"
"                'class': 'logging.Formatter',\n"
"                'format': '%(asctime)s %(name)-15s %(levelname)-8s "
"%(processName)-10s %(message)s'\n"
"            },\n"
"            'simple': {\n"
"                'class': 'logging.Formatter',\n"
"                'format': '%(name)-15s %(levelname)-8s %(processName)-10s "
"%(message)s'\n"
"            }\n"
"        },\n"
"        'handlers': {\n"
"            'console': {\n"
"                'class': 'logging.StreamHandler',\n"
"                'formatter': 'simple',\n"
"                'level': 'INFO'\n"
"            },\n"
"            'file': {\n"
"                'class': 'logging.FileHandler',\n"
"                'filename': 'mplog.log',\n"
"                'mode': 'w',\n"
"                'formatter': 'detailed'\n"
"            },\n"
"            'foofile': {\n"
"                'class': 'logging.FileHandler',\n"
"                'filename': 'mplog-foo.log',\n"
"                'mode': 'w',\n"
"                'formatter': 'detailed'\n"
"            },\n"
"            'errors': {\n"
"                'class': 'logging.FileHandler',\n"
"                'filename': 'mplog-errors.log',\n"
"                'mode': 'w',\n"
"                'formatter': 'detailed',\n"
"                'level': 'ERROR'\n"
"            }\n"
"        },\n"
"        'loggers': {\n"
"            'foo': {\n"
"                'handlers': ['foofile']\n"
"            }\n"
"        },\n"
"        'root': {\n"
"            'handlers': ['console', 'file', 'errors'],\n"
"            'level': 'DEBUG'\n"
"        }\n"
"    }\n"
"  # Registra algunos sucesos iniciales, sólo para mostrar que el registro "
"padre funciona\n"
"   # normalmente.\n"
"    logging.config.dictConfig(config_initial)\n"
"    logger = logging.getLogger('setup')\n"
"    logger.info('About to create workers ...')\n"
"    workers = []\n"
"    for i in range(5):\n"
"        wp = Process(target=worker_process, name='worker %d' % (i + 1),\n"
"                     args=(config_worker,))\n"
"        workers.append(wp)\n"
"        wp.start()\n"
"        logger.info('Started worker: %s', wp.name)\n"
"    logger.info('About to create listener ...')\n"
"    stop_event = Event()\n"
"    lp = Process(target=listener_process, name='listener',\n"
"                 args=(q, stop_event, config_listener))\n"
"    lp.start()\n"
"    logger.info('Started listener')\n"
"   # Ahora esperamos a que los trabajadores terminen su trabajo.\n"
"    for wp in trabajadores:\n"
"wp.join()\n"
"    # Todos los trabajadores han terminado, ahora se puede parar la "
"escucha.\n"
"     # El registro en el padre sigue funcionando normalmente.\n"
"    logger.info('Diciendo a la escucha que se detenga ...')\n"
"    logger.info('Telling listener to stop ...')\n"
"    stop_event.set()\n"
"    lp.join()\n"
"    logger.info('All done.')\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"

#: ../../howto/logging-cookbook.rst:2448
msgid "Inserting a BOM into messages sent to a SysLogHandler"
msgstr ""
"Inserción de una lista de materiales en los mensajes enviados a un "
"SysLogHandler"

#: ../../howto/logging-cookbook.rst:2450
msgid ""
":rfc:`5424` requires that a Unicode message be sent to a syslog daemon as a "
"set of bytes which have the following structure: an optional pure-ASCII "
"component, followed by a UTF-8 Byte Order Mark (BOM), followed by Unicode "
"encoded using UTF-8. (See the :rfc:`relevant section of the specification "
"<5424#section-6>`.)"
msgstr ""
":rfc:`5424` requiere que se envíe un mensaje Unicode a un demonio syslog "
"como un conjunto de bytes que tengan la siguiente estructura: un componente "
"opcional ASCII puro, seguido de una marca de orden de bytes (BOM) UTF-8, "
"seguido de Unicode codificado utilizando UTF-8. (Ver la sección :rfc:"
"`relevant de la especificación <5424#section-6>`.)"

#: ../../howto/logging-cookbook.rst:2456
msgid ""
"In Python 3.1, code was added to :class:`~logging.handlers.SysLogHandler` to "
"insert a BOM into the message, but unfortunately, it was implemented "
"incorrectly, with the BOM appearing at the beginning of the message and "
"hence not allowing any pure-ASCII component to appear before it."
msgstr ""
"En Python 3.1, se añadió código a :class:`~logging.handlers.SysLogHandler` "
"para insertar una lista de materiales en el mensaje, pero lamentablemente se "
"implementó de forma incorrecta, ya que la lista de materiales aparecía al "
"principio del mensaje y, por tanto, no permitía que ningún componente ASCII "
"puro apareciera antes de ella."

#: ../../howto/logging-cookbook.rst:2462
msgid ""
"As this behaviour is broken, the incorrect BOM insertion code is being "
"removed from Python 3.2.4 and later. However, it is not being replaced, and "
"if you want to produce :rfc:`5424`-compliant messages which include a BOM, "
"an optional pure-ASCII sequence before it and arbitrary Unicode after it, "
"encoded using UTF-8, then you need to do the following:"
msgstr ""
"Como este comportamiento está roto, el código de inserción incorrecta de la "
"lista de materiales se está eliminando de Python 3.2.4 y posteriores. Sin "
"embargo, no se está sustituyendo, y si quieres producir mensajes compatibles "
"con :rfc:`5424` que incluyan una lista de materiales, una secuencia opcional "
"ASCII pura antes de ella y Unicode arbitrario después de ella, codificados "
"utilizando UTF-8, entonces tienes que hacer lo siguiente:"

#: ../../howto/logging-cookbook.rst:2468
msgid ""
"Attach a :class:`~logging.Formatter` instance to your :class:`~logging."
"handlers.SysLogHandler` instance, with a format string such as::"
msgstr ""
"Adjunte una instancia :class:`~logging.Formatter` a su instancia :class:"
"`~logging.handlers.SysLogHandler`, con una cadena de formato como::"

#: ../../howto/logging-cookbook.rst:2472
msgid "'ASCII section\\ufeffUnicode section'"
msgstr "'ASCII section\\ufeffUnicode section'"

#: ../../howto/logging-cookbook.rst:2474
msgid ""
"The Unicode code point U+FEFF, when encoded using UTF-8, will be encoded as "
"a UTF-8 BOM -- the byte-string ``b'\\xef\\xbb\\xbf'``."
msgstr ""
"El punto de código Unicode U+FEFF, cuando se codifica utilizando UTF-8, se "
"codificará como UTF-8 BOM -- la cadena de bytes ``b'\\xef\\xbb\\xbf'``."

#: ../../howto/logging-cookbook.rst:2477
msgid ""
"Replace the ASCII section with whatever placeholders you like, but make sure "
"that the data that appears in there after substitution is always ASCII (that "
"way, it will remain unchanged after UTF-8 encoding)."
msgstr ""
"Sustituir la sección ASCII por los marcadores de posición que se desee, pero "
"asegurarse de que los datos que aparezcan ahí después de la sustitución sean "
"siempre ASCII (de ese modo, permanecerán inalterados después de la "
"codificación UTF-8)."

#: ../../howto/logging-cookbook.rst:2481
msgid ""
"Replace the Unicode section with whatever placeholders you like; if the data "
"which appears there after substitution contains characters outside the ASCII "
"range, that's fine -- it will be encoded using UTF-8."
msgstr ""
"Sustituir la sección Unicode por los marcadores de posición que se desee; si "
"los datos que aparecen allí después de la sustitución contienen caracteres "
"fuera del rango ASCII, no hay problema: se codificarán utilizando UTF-8."

#: ../../howto/logging-cookbook.rst:2485
msgid ""
"The formatted message *will* be encoded using UTF-8 encoding by "
"``SysLogHandler``. If you follow the above rules, you should be able to "
"produce :rfc:`5424`-compliant messages. If you don't, logging may not "
"complain, but your messages will not be RFC 5424-compliant, and your syslog "
"daemon may complain."
msgstr ""
"El mensaje formateado *será* codificado utilizando la codificación UTF-8 por "
"``SysLogHandler``. Si sigue las reglas anteriores, debería ser capaz de "
"producir mensajes compatibles con :rfc:`5424`. Si no lo hace, puede que el "
"registro no se queje, pero sus mensajes no serán compatibles con RFC 5424, y "
"su demonio syslog puede quejarse."

#: ../../howto/logging-cookbook.rst:2492
msgid "Implementing structured logging"
msgstr "Implantación de un registro estructurado"

#: ../../howto/logging-cookbook.rst:2494
msgid ""
"Although most logging messages are intended for reading by humans, and thus "
"not readily machine-parseable, there might be circumstances where you want "
"to output messages in a structured format which *is* capable of being parsed "
"by a program (without needing complex regular expressions to parse the log "
"message). This is straightforward to achieve using the logging package. "
"There are a number of ways in which this could be achieved, but the "
"following is a simple approach which uses JSON to serialise the event in a "
"machine-parseable manner::"
msgstr ""
"Aunque la mayoría de los mensajes de registro están pensados para ser leídos "
"por humanos y, por tanto, no son fácilmente analizables por máquinas, puede "
"haber circunstancias en las que se desee dar salida a mensajes en un formato "
"estructurado que *sea* capaz de ser analizado por un programa (sin necesidad "
"de complejas expresiones regulares para analizar el mensaje de registro). "
"Esto es fácil de conseguir utilizando el paquete logging. Hay varias formas "
"de conseguirlo, pero la siguiente es un enfoque sencillo que utiliza JSON "
"para serializar el evento de forma que pueda ser analizado por una máquina::"

#: ../../howto/logging-cookbook.rst:2502
msgid ""
"import json\n"
"import logging\n"
"\n"
"class StructuredMessage:\n"
"    def __init__(self, message, /, **kwargs):\n"
"        self.message = message\n"
"        self.kwargs = kwargs\n"
"\n"
"    def __str__(self):\n"
"        return '%s >>> %s' % (self.message, json.dumps(self.kwargs))\n"
"\n"
"_ = StructuredMessage   # optional, to improve readability\n"
"\n"
"logging.basicConfig(level=logging.INFO, format='%(message)s')\n"
"logging.info(_('message 1', foo='bar', bar='baz', num=123, fnum=123.456))"
msgstr ""
"import json\n"
"import logging\n"
"\n"
"class StructuredMessage:\n"
"    def __init__(self, message, /, **kwargs):\n"
"        self.message = message\n"
"        self.kwargs = kwargs\n"
"\n"
"    def __str__(self):\n"
"        return '%s >>> %s' % (self.message, json.dumps(self.kwargs))\n"
"\n"
"_ = StructuredMessage   # opcional, para mejorar la legibilidad\n"
"\n"
"logging.basicConfig(level=logging.INFO, format='%(message)s')\n"
"logging.info(_('message 1', foo='bar', bar='baz', num=123, fnum=123.456))"

#: ../../howto/logging-cookbook.rst:2518
msgid "If the above script is run, it prints:"
msgstr "Si se ejecuta el script anterior, se imprime:"

#: ../../howto/logging-cookbook.rst:2520
msgid ""
"message 1 >>> {\"fnum\": 123.456, \"num\": 123, \"bar\": \"baz\", \"foo\": "
"\"bar\"}"
msgstr ""
"mensaje 1 >>> {\"fnum\": 123.456, \"num\": 123, \"bar\": \"baz\", \"foo\": "
"\"bar\"}"

#: ../../howto/logging-cookbook.rst:2524 ../../howto/logging-cookbook.rst:2566
msgid ""
"Note that the order of items might be different according to the version of "
"Python used."
msgstr ""
"Tener en cuenta que el orden de los elementos puede ser diferente según la "
"versión de Python utilizada."

#: ../../howto/logging-cookbook.rst:2527
msgid ""
"If you need more specialised processing, you can use a custom JSON encoder, "
"as in the following complete example::"
msgstr ""
"Si se necesita un procesamiento más especializado, se puede utilizar un "
"codificador JSON personalizado, como en el siguiente ejemplo completo::"

#: ../../howto/logging-cookbook.rst:2530
msgid ""
"import json\n"
"import logging\n"
"\n"
"\n"
"class Encoder(json.JSONEncoder):\n"
"    def default(self, o):\n"
"        if isinstance(o, set):\n"
"            return tuple(o)\n"
"        elif isinstance(o, str):\n"
"            return o.encode('unicode_escape').decode('ascii')\n"
"        return super().default(o)\n"
"\n"
"class StructuredMessage:\n"
"    def __init__(self, message, /, **kwargs):\n"
"        self.message = message\n"
"        self.kwargs = kwargs\n"
"\n"
"    def __str__(self):\n"
"        s = Encoder().encode(self.kwargs)\n"
"        return '%s >>> %s' % (self.message, s)\n"
"\n"
"_ = StructuredMessage   # optional, to improve readability\n"
"\n"
"def main():\n"
"    logging.basicConfig(level=logging.INFO, format='%(message)s')\n"
"    logging.info(_('message 1', set_value={1, 2, 3}, snowman='\\u2603'))\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""
"import json\n"
"import logging\n"
"\n"
"\n"
"class Encoder(json.JSONEncoder):\n"
"    def default(self, o):\n"
"        if isinstance(o, set):\n"
"            return tuple(o)\n"
"        elif isinstance(o, str):\n"
"            return o.encode('unicode_escape').decode('ascii')\n"
"        return super().default(o)\n"
"\n"
"class StructuredMessage:\n"
"    def __init__(self, message, /, **kwargs):\n"
"        self.message = message\n"
"        self.kwargs = kwargs\n"
"\n"
"    def __str__(self):\n"
"        s = Encoder().encode(self.kwargs)\n"
"        return '%s >>> %s' % (self.message, s)\n"
"\n"
"_ = StructuredMessage   # opcional, para mejorar la legibilidad\n"
"\n"
"def main():\n"
"    logging.basicConfig(level=logging.INFO, format='%(message)s')\n"
"    logging.info(_('message 1', set_value={1, 2, 3}, snowman='\\u2603'))\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"

#: ../../howto/logging-cookbook.rst:2560
msgid "When the above script is run, it prints:"
msgstr "Cuando se ejecuta el script anterior, se imprime:"

#: ../../howto/logging-cookbook.rst:2562
msgid "message 1 >>> {\"snowman\": \"\\u2603\", \"set_value\": [1, 2, 3]}"
msgstr "mensaje 1 >>> {\"snowman\": \"\\u2603\", \"set_value\": [1, 2, 3]}"

#: ../../howto/logging-cookbook.rst:2575
msgid "Customizing handlers with :func:`dictConfig`"
msgstr "Personalización de gestores con :func:`dictConfig`"

#: ../../howto/logging-cookbook.rst:2577
msgid ""
"There are times when you want to customize logging handlers in particular "
"ways, and if you use :func:`dictConfig` you may be able to do this without "
"subclassing. As an example, consider that you may want to set the ownership "
"of a log file. On POSIX, this is easily done using :func:`shutil.chown`, but "
"the file handlers in the stdlib don't offer built-in support. You can "
"customize handler creation using a plain function such as::"
msgstr ""
"Hay ocasiones en las que quieres personalizar los manejadores de registro de "
"formas particulares, y si usas :func:`dictConfig` puedes hacerlo sin "
"subclases. Como ejemplo, considere que puede querer establecer la propiedad "
"de un fichero de registro. En POSIX, esto se hace fácilmente usando :func:"
"`shutil.chown`, pero los manejadores de archivos en la stdlib no ofrecen "
"soporte incorporado. Puede personalizar la creación de manejadores usando "
"una función simple como::"

#: ../../howto/logging-cookbook.rst:2584
msgid ""
"def owned_file_handler(filename, mode='a', encoding=None, owner=None):\n"
"    if owner:\n"
"        if not os.path.exists(filename):\n"
"            open(filename, 'a').close()\n"
"        shutil.chown(filename, *owner)\n"
"    return logging.FileHandler(filename, mode, encoding)"
msgstr ""
"def owned_file_handler(filename, mode='a', encoding=None, owner=None):\n"
"    if owner:\n"
"        if not os.path.exists(filename):\n"
"            open(filename, 'a').close()\n"
"        shutil.chown(filename, *owner)\n"
"    return logging.FileHandler(filename, mode, encoding)"

#: ../../howto/logging-cookbook.rst:2591
msgid ""
"You can then specify, in a logging configuration passed to :func:"
"`dictConfig`, that a logging handler be created by calling this function::"
msgstr ""
"A continuación, puede especificar, en una configuración de registro pasada "
"a :func:`dictConfig`, que se cree un gestor de registro llamando a esta "
"función::"

#: ../../howto/logging-cookbook.rst:2594
msgid ""
"LOGGING = {\n"
"    'version': 1,\n"
"    'disable_existing_loggers': False,\n"
"    'formatters': {\n"
"        'default': {\n"
"            'format': '%(asctime)s %(levelname)s %(name)s %(message)s'\n"
"        },\n"
"    },\n"
"    'handlers': {\n"
"        'file':{\n"
"            # The values below are popped from this dictionary and\n"
"            # used to create the handler, set the handler's level and\n"
"            # its formatter.\n"
"            '()': owned_file_handler,\n"
"            'level':'DEBUG',\n"
"            'formatter': 'default',\n"
"            # The values below are passed to the handler creator callable\n"
"            # as keyword arguments.\n"
"            'owner': ['pulse', 'pulse'],\n"
"            'filename': 'chowntest.log',\n"
"            'mode': 'w',\n"
"            'encoding': 'utf-8',\n"
"        },\n"
"    },\n"
"    'root': {\n"
"        'handlers': ['file'],\n"
"        'level': 'DEBUG',\n"
"    },\n"
"}"
msgstr ""
"LOGGING = {\n"
"    versión 1,\n"
"    'disable_existing_loggers': False,\n"
"    formateadores': {\n"
"        'default': {\n"
"            'format': '%(asctime)s %(levelname)s %(name)s %(message)s '\n"
"        },\n"
"    },\n"
"    'handlers': {\n"
"        'file':{\n"
"            # Los valores de abajo se extraen de este diccionario y\n"
"            # se utilizan para crear el manejador, establecer el nivel del "
"manejador y\n"
"            # su formateador.\n"
"            '()': owned_file_handler,\n"
"            'level':'DEBUG',\n"
"            'formatter': 'default',\n"
"            # Los valores de abajo se pasan a la llamada al creador del "
"manejador\n"
"            # como argumentos de palabra clave.\n"
"            'owner': ['pulse', 'pulse'],\n"
"            'filename': 'chowntest.log',\n"
"            'mode': 'w',\n"
"            'encoding': 'utf-8',\n"
"        },\n"
"    },\n"
"    'root': {\n"
"        'handlers': ['file'],\n"
"        'level': 'DEBUG',\n"
"    },\n"
"}"

#: ../../howto/logging-cookbook.rst:2624
msgid ""
"In this example I am setting the ownership using the ``pulse`` user and "
"group, just for the purposes of illustration. Putting it together into a "
"working script, ``chowntest.py``::"
msgstr ""
"En este ejemplo estoy estableciendo la propiedad utilizando el usuario y "
"grupo ``pulse``, sólo con fines ilustrativos. Poniéndolo junto en un script "
"de trabajo, ``chowntest.py``::"

#: ../../howto/logging-cookbook.rst:2628
msgid ""
"import logging, logging.config, os, shutil\n"
"\n"
"def owned_file_handler(filename, mode='a', encoding=None, owner=None):\n"
"    if owner:\n"
"        if not os.path.exists(filename):\n"
"            open(filename, 'a').close()\n"
"        shutil.chown(filename, *owner)\n"
"    return logging.FileHandler(filename, mode, encoding)\n"
"\n"
"LOGGING = {\n"
"    'version': 1,\n"
"    'disable_existing_loggers': False,\n"
"    'formatters': {\n"
"        'default': {\n"
"            'format': '%(asctime)s %(levelname)s %(name)s %(message)s'\n"
"        },\n"
"    },\n"
"    'handlers': {\n"
"        'file':{\n"
"            # The values below are popped from this dictionary and\n"
"            # used to create the handler, set the handler's level and\n"
"            # its formatter.\n"
"            '()': owned_file_handler,\n"
"            'level':'DEBUG',\n"
"            'formatter': 'default',\n"
"            # The values below are passed to the handler creator callable\n"
"            # as keyword arguments.\n"
"            'owner': ['pulse', 'pulse'],\n"
"            'filename': 'chowntest.log',\n"
"            'mode': 'w',\n"
"            'encoding': 'utf-8',\n"
"        },\n"
"    },\n"
"    'root': {\n"
"        'handlers': ['file'],\n"
"        'level': 'DEBUG',\n"
"    },\n"
"}\n"
"\n"
"logging.config.dictConfig(LOGGING)\n"
"logger = logging.getLogger('mylogger')\n"
"logger.debug('A debug message')"
msgstr ""
"import logging, logging.config, os, shutil\n"
"\n"
"def owned_file_handler(filename, mode='a', encoding=None, owner=None):\n"
"        if owner:\n"
"            if not os.path.exists(filename):\n"
"                open(filename, 'a').close()\n"
"             shutil.chown(filename, *owner)\n"
"         return logging.FileHandler(filename, mode, encoding)\n"
"\n"
"LOGGING = {\n"
"    'version': 1,\n"
"    'disable_existing_loggers': False,\n"
"    'formatters': {\n"
"        'default': {\n"
"            'format': '%(asctime)s %(levelname)s %(name)s %(message)s '\n"
"        },\n"
"    },\n"
"    'handlers': {\n"
"        'file':{\n"
"            # Los valores de abajo se extraen de este diccionario y\n"
"            # se utilizan para crear el manejador, establecer el nivel del "
"manejador y\n"
"            # su formateador.\n"
"            '()': owned_file_handler,\n"
"            'level':'DEBUG',\n"
"            'formatter': 'default',\n"
"            # Los valores de abajo se pasan a la llamada al creador del "
"manejador\n"
"            # como argumentos de palabra clave.\n"
"            'owner': ['pulse', 'pulse'],\n"
"            'filename': 'chowntest.log',\n"
"            'mode': 'w',\n"
"            'encoding': 'utf-8',\n"
"        },\n"
"    },\n"
"    'root': {\n"
"        'handlers': ['file'],\n"
"        'level': 'DEBUG',\n"
"    },\n"
"}\n"
"\n"
"logging.config.dictConfig(LOGGING)\n"
"logger = logging.getLogger('mylogger')\n"
"logger.debug('Un mensaje de depuración')"

#: ../../howto/logging-cookbook.rst:2671
msgid "To run this, you will probably need to run as ``root``:"
msgstr "Para ejecutarlo, probablemente tendrás que hacerlo como ``root``:"

#: ../../howto/logging-cookbook.rst:2673
msgid ""
"$ sudo python3.3 chowntest.py\n"
"$ cat chowntest.log\n"
"2013-11-05 09:34:51,128 DEBUG mylogger A debug message\n"
"$ ls -l chowntest.log\n"
"-rw-r--r-- 1 pulse pulse 55 2013-11-05 09:34 chowntest.log"
msgstr ""
"$ sudo python3.3 chowntest.py\n"
"$ cat chowntest.log\n"
"2013-11-05 09:34:51,128 DEBUG mylogger A debug message\n"
"$ ls -l chowntest.log\n"
"-rw-r--r-- 1 pulse pulse 55 2013-11-05 09:34 chowntest.log"

#: ../../howto/logging-cookbook.rst:2681
msgid ""
"Note that this example uses Python 3.3 because that's where :func:`shutil."
"chown` makes an appearance. This approach should work with any Python "
"version that supports :func:`dictConfig` - namely, Python 2.7, 3.2 or later. "
"With pre-3.3 versions, you would need to implement the actual ownership "
"change using e.g. :func:`os.chown`."
msgstr ""
"Tener en cuenta que este ejemplo utiliza Python 3.3 porque es donde :func:"
"`shutil.chown` hace su aparición. Este enfoque debería funcionar con "
"cualquier versión de Python que soporte :func:`dictConfig` - es decir, "
"Python 2.7, 3.2 o posterior. Con versiones anteriores a la -3.3, se "
"necesitaría implementar el cambio de propiedad usando, por ejemplo, :func:"
"`os.chown`."

#: ../../howto/logging-cookbook.rst:2687
msgid ""
"In practice, the handler-creating function may be in a utility module "
"somewhere in your project. Instead of the line in the configuration::"
msgstr ""
"En la práctica, la función de creación del manejador puede estar en un "
"módulo de utilidad en algún lugar de su proyecto. En lugar de la línea en la "
"configuración::"

#: ../../howto/logging-cookbook.rst:2690
msgid "'()': owned_file_handler,"
msgstr "'()': owned_file_handler,"

#: ../../howto/logging-cookbook.rst:2692
msgid "you could use e.g.::"
msgstr "se puede utilizar, por ejemplo::"

#: ../../howto/logging-cookbook.rst:2694
msgid "'()': 'ext://project.util.owned_file_handler',"
msgstr "'()': 'ext://project.util.owned_file_handler',"

#: ../../howto/logging-cookbook.rst:2696
msgid ""
"where ``project.util`` can be replaced with the actual name of the package "
"where the function resides. In the above working script, using ``'ext://"
"__main__.owned_file_handler'`` should work. Here, the actual callable is "
"resolved by :func:`dictConfig` from the ``ext://`` specification."
msgstr ""
"donde ``project.util`` puede sustituirse por el nombre real del paquete "
"donde reside la función. En el script de trabajo anterior, el uso de "
"``'ext://__main__.owned_file_handler'`` debería funcionar. Aquí, la llamada "
"real es resuelta por :func:`dictConfig` desde la especificación ``ext://``."

#: ../../howto/logging-cookbook.rst:2701
msgid ""
"This example hopefully also points the way to how you could implement other "
"types of file change - e.g. setting specific POSIX permission bits - in the "
"same way, using :func:`os.chmod`."
msgstr ""
"Es de esperar que este ejemplo también señale cómo se podrían implementar "
"otros tipos de cambios en los archivos -por ejemplo, establecer bits de "
"permiso POSIX específicos- de la misma manera, utilizando :func:`os.chmod`."

#: ../../howto/logging-cookbook.rst:2705
msgid ""
"Of course, the approach could also be extended to types of handler other "
"than a :class:`~logging.FileHandler` - for example, one of the rotating file "
"handlers, or a different type of handler altogether."
msgstr ""
"Por supuesto, el enfoque también podría ampliarse a otros tipos de gestores "
"distintos de :class:`~logging.FileHandler`, por ejemplo, uno de los gestores "
"de archivos giratorios o un tipo de gestor totalmente distinto."

#: ../../howto/logging-cookbook.rst:2715
msgid "Using particular formatting styles throughout your application"
msgstr "Utilización de determinados estilos de formato en toda la aplicación"

#: ../../howto/logging-cookbook.rst:2717
msgid ""
"In Python 3.2, the :class:`~logging.Formatter` gained a ``style`` keyword "
"parameter which, while defaulting to ``%`` for backward compatibility, "
"allowed the specification of ``{`` or ``$`` to support the formatting "
"approaches supported by :meth:`str.format` and :class:`string.Template`. "
"Note that this governs the formatting of logging messages for final output "
"to logs, and is completely orthogonal to how an individual logging message "
"is constructed."
msgstr ""
"En Python 3.2, :class:`~logging.Formatter` obtuvo un parámetro de palabra "
"clave ``style`` que, aunque por defecto era ``%`` por compatibilidad con "
"versiones anteriores, permitía la especificación de ``{`` o ``$`` para "
"soportar los enfoques de formato soportados por :meth:`str.format` y :class:"
"`string.Template`. Tenga en cuenta que esto rige el formato de los mensajes "
"de registro para la salida final a los registros, y es completamente "
"ortogonal a cómo se construye un mensaje de registro individual."

#: ../../howto/logging-cookbook.rst:2724
msgid ""
"Logging calls (:meth:`~Logger.debug`, :meth:`~Logger.info` etc.) only take "
"positional parameters for the actual logging message itself, with keyword "
"parameters used only for determining options for how to handle the logging "
"call (e.g. the ``exc_info`` keyword parameter to indicate that traceback "
"information should be logged, or the ``extra`` keyword parameter to indicate "
"additional contextual information to be added to the log). So you cannot "
"directly make logging calls using :meth:`str.format` or :class:`string."
"Template` syntax, because internally the logging package uses %-formatting "
"to merge the format string and the variable arguments. There would be no "
"changing this while preserving backward compatibility, since all logging "
"calls which are out there in existing code will be using %-format strings."
msgstr ""
"Las llamadas de registro (:meth:`~Logger.debug`, :meth:`~Logger.info` etc.) "
"sólo toman parámetros posicionales para el propio mensaje de registro, con "
"parámetros de palabra clave utilizados sólo para determinar las opciones de "
"cómo manejar la llamada de registro (por ejemplo, el parámetro de palabra "
"clave ``exc_info`` para indicar que la información de rastreo debe ser "
"registrada, o el parámetro de palabra clave ``extra`` para indicar "
"información contextual adicional que se añadirá al registro). Por lo tanto, "
"no se pueden realizar directamente llamadas de registro utilizando la "
"sintaxis :meth:`str.format` o :class:`string.Template`, porque internamente "
"el paquete de registro utiliza %-fomatting para fusionar la cadena de "
"formato y los argumentos variables. No habría forma de cambiar esto "
"preservando la compatibilidad con versiones anteriores, ya que todas las "
"llamadas de registro que existen en el código actual utilizarán cadenas %-"
"format."

#: ../../howto/logging-cookbook.rst:2736
msgid ""
"There have been suggestions to associate format styles with specific "
"loggers, but that approach also runs into backward compatibility problems "
"because any existing code could be using a given logger name and using %-"
"formatting."
msgstr ""
"Se ha sugerido asociar estilos de formato con registradores específicos, "
"pero ese enfoque también se enfrenta a problemas de compatibilidad con "
"versiones anteriores, ya que cualquier código existente podría estar "
"utilizando un nombre de registrador determinado y utilizar %-formatting."

#: ../../howto/logging-cookbook.rst:2740
msgid ""
"For logging to work interoperably between any third-party libraries and your "
"code, decisions about formatting need to be made at the level of the "
"individual logging call. This opens up a couple of ways in which alternative "
"formatting styles can be accommodated."
msgstr ""
"Para que el registro funcione de forma interoperable entre bibliotecas de "
"terceros y tu código, las decisiones sobre el formato deben tomarse a nivel "
"de cada llamada de registro. Esto abre un par de vías para acomodar estilos "
"de formato alternativos."

#: ../../howto/logging-cookbook.rst:2747
msgid "Using LogRecord factories"
msgstr "Uso de las fábricas LogRecord"

#: ../../howto/logging-cookbook.rst:2749
msgid ""
"In Python 3.2, along with the :class:`~logging.Formatter` changes mentioned "
"above, the logging package gained the ability to allow users to set their "
"own :class:`LogRecord` subclasses, using the :func:`setLogRecordFactory` "
"function. You can use this to set your own subclass of :class:`LogRecord`, "
"which does the Right Thing by overriding the :meth:`~LogRecord.getMessage` "
"method. The base class implementation of this method is where the ``msg % "
"args`` formatting happens, and where you can substitute your alternate "
"formatting; however, you should be careful to support all formatting styles "
"and allow %-formatting as the default, to ensure interoperability with other "
"code. Care should also be taken to call ``str(self.msg)``, just as the base "
"implementation does."
msgstr ""
"En Python 3.2, junto con los cambios en :class:`~logging.Formatter` "
"mencionados anteriormente, el paquete logging adquirió la capacidad de "
"permitir a los usuarios establecer sus propias subclases :class:`LogRecord`, "
"usando la función :func:`setLogRecordFactory`. Puedes usar esto para "
"establecer tu propia subclase de :class:`LogRecord`, que hace lo correcto "
"sobrescribiendo el método :meth:`~LogRecord.getMessage`. La implementación "
"de la clase base de este método es donde ocurre el formateo ``msg % args``, "
"y donde usted puede sustituir su formateo alternativo; sin embargo, debe "
"tener cuidado de soportar todos los estilos de formateo y permitir %-"
"formatting como el predeterminado, para asegurar la interoperabilidad con "
"otro código. También se debe tener cuidado de llamar a ``str(self.msg)``, "
"tal y como hace la implementación base."

#: ../../howto/logging-cookbook.rst:2760
msgid ""
"Refer to the reference documentation on :func:`setLogRecordFactory` and :"
"class:`LogRecord` for more information."
msgstr ""
"Para más información, consulte la documentación de referencia en :func:"
"`setLogRecordFactory` y :class:`LogRecord`."

#: ../../howto/logging-cookbook.rst:2765
msgid "Using custom message objects"
msgstr "Utilización de objetos de mensaje personalizados"

#: ../../howto/logging-cookbook.rst:2767
msgid ""
"There is another, perhaps simpler way that you can use {}- and $- formatting "
"to construct your individual log messages. You may recall (from :ref:"
"`arbitrary-object-messages`) that when logging you can use an arbitrary "
"object as a message format string, and that the logging package will call :"
"func:`str` on that object to get the actual format string. Consider the "
"following two classes::"
msgstr ""
"Hay otra forma, quizás más simple, de utilizar los formatos {}- y $- para "
"construir mensajes de registro individuales. Puede que recuerde (de :ref:"
"`arbitrary-object-messages`) que al registrar puede utilizar un objeto "
"arbitrario como cadena de formato de mensaje, y que el paquete de registro "
"llamará a :func:`str` en ese objeto para obtener la cadena de formato real. "
"Considere las siguientes dos clases::"

#: ../../howto/logging-cookbook.rst:2792
msgid ""
"Either of these can be used in place of a format string, to allow {}- or $-"
"formatting to be used to build the actual \"message\" part which appears in "
"the formatted log output in place of “%(message)s” or “{message}” or "
"“$message”. If you find it a little unwieldy to use the class names whenever "
"you want to log something, you can make it more palatable if you use an "
"alias such as ``M`` or ``_`` for the message (or perhaps ``__``, if you are "
"using ``_`` for localization)."
msgstr ""
"Cualquiera de estos se puede utilizar en lugar de una cadena de formato, "
"para permitir {}- o $-formato que se utilizará para construir la parte real "
"\"mensaje\" que aparece en la salida de registro formateado en lugar de "
"\"%(message)s\" o \"{message}\" o \"$message\". Si le resulta un poco "
"engorroso utilizar los nombres de clase cada vez que quiera registrar algo, "
"puede hacerlo más agradable si utiliza un alias como ``M`` o ``_`` para el "
"mensaje (o quizás ``__``, si utiliza ``_`` para la localización)."

#: ../../howto/logging-cookbook.rst:2800
msgid ""
"Examples of this approach are given below. Firstly, formatting with :meth:"
"`str.format`::"
msgstr ""
"A continuación se ofrecen ejemplos de este enfoque. En primer lugar, el "
"formateo con :meth:`str.format`::"

#: ../../howto/logging-cookbook.rst:2803
msgid ""
">>> __ = BraceMessage\n"
">>> print(__('Message with {0} {1}', 2, 'placeholders'))\n"
"Message with 2 placeholders\n"
">>> class Point: pass\n"
"...\n"
">>> p = Point()\n"
">>> p.x = 0.5\n"
">>> p.y = 0.5\n"
">>> print(__('Message with coordinates: ({point.x:.2f}, {point.y:.2f})', "
"point=p))\n"
"Message with coordinates: (0.50, 0.50)"
msgstr ""
">>> __ = BraceMessage\n"
">>> print(__('Message with {0} {1}', 2, 'placeholders'))\n"
"Message with 2 placeholders\n"
">>> class Point: pass\n"
"...\n"
">>> p = Point()\n"
">>> p.x = 0.5\n"
">>> p.y = 0.5\n"
">>> print(__('Message with coordinates: ({point.x:.2f}, {point.y:.2f})', "
"point=p))\n"
"Message with coordinates: (0.50, 0.50)"

#: ../../howto/logging-cookbook.rst:2814
msgid "Secondly, formatting with :class:`string.Template`::"
msgstr "En segundo lugar, el formato con :class:`string.Template`::"

#: ../../howto/logging-cookbook.rst:2816
msgid ""
">>> __ = DollarMessage\n"
">>> print(__('Message with $num $what', num=2, what='placeholders'))\n"
"Message with 2 placeholders\n"
">>>"
msgstr ""
">>> __ = DollarMessage\n"
">>> print(__('Message with $num $what', num=2, what='placeholders'))\n"
"Message with 2 placeholders\n"
">>>"

#: ../../howto/logging-cookbook.rst:2821
msgid ""
"One thing to note is that you pay no significant performance penalty with "
"this approach: the actual formatting happens not when you make the logging "
"call, but when (and if) the logged message is actually about to be output to "
"a log by a handler. So the only slightly unusual thing which might trip you "
"up is that the parentheses go around the format string and the arguments, "
"not just the format string. That’s because the __ notation is just syntax "
"sugar for a constructor call to one of the :samp:`{XXX}Message` classes "
"shown above."
msgstr ""
"Una cosa a tener en cuenta es que no se paga ninguna penalización de "
"rendimiento significativa con este enfoque: el formateo real no ocurre "
"cuando se hace la llamada de registro, sino cuando (y si) el mensaje "
"registrado está a punto de ser enviado a un registro por un manejador. La "
"única cosa un poco inusual que podría confundir es que los paréntesis rodean "
"la cadena de formato y los argumentos, no sólo la cadena de formato. Esto se "
"debe a que la notación __ es sólo un dulce sintáctico para una llamada al "
"constructor de una de las clases :samp:`{XXX}Message` mostradas "
"anteriormente."

#: ../../howto/logging-cookbook.rst:2835
msgid "Configuring filters with :func:`dictConfig`"
msgstr "Configuración de filtros con :func:`dictConfig`"

#: ../../howto/logging-cookbook.rst:2837
msgid ""
"You *can* configure filters using :func:`~logging.config.dictConfig`, though "
"it might not be obvious at first glance how to do it (hence this recipe). "
"Since :class:`~logging.Filter` is the only filter class included in the "
"standard library, and it is unlikely to cater to many requirements (it's "
"only there as a base class), you will typically need to define your own :"
"class:`~logging.Filter` subclass with an overridden :meth:`~logging.Filter."
"filter` method. To do this, specify the ``()`` key in the configuration "
"dictionary for the filter, specifying a callable which will be used to "
"create the filter (a class is the most obvious, but you can provide any "
"callable which returns a :class:`~logging.Filter` instance). Here is a "
"complete example::"
msgstr ""
"Se *pueden* configurar filtros usando :func:`~logging.config.dictConfig`, "
"aunque no resulte evidente a primera vista cómo hacerlo (de ahí esta "
"receta). Dado que :class:`~logging.Filter` es la única clase de filtro "
"incluida en la biblioteca estándar, y es poco probable que satisfaga muchas "
"necesidades (sólo está ahí como clase base), normalmente se necesitará "
"definir su propia subclase :class:`~logging.Filter` con un método :meth:"
"`~logging.Filter.filter` sobrescrito. Para ello, especifique la clave ``()`` "
"en el diccionario de configuración para el filtro, especificando una llamada "
"que se utilizará para crear el filtro (una clase es la más obvia, pero puede "
"proporcionar cualquier llamada que devuelva una instancia de :class:"
"`~logging.Filter` ). He aquí un ejemplo completo::"

#: ../../howto/logging-cookbook.rst:2848
msgid ""
"import logging\n"
"import logging.config\n"
"import sys\n"
"\n"
"class MyFilter(logging.Filter):\n"
"    def __init__(self, param=None):\n"
"        self.param = param\n"
"\n"
"    def filter(self, record):\n"
"        if self.param is None:\n"
"            allow = True\n"
"        else:\n"
"            allow = self.param not in record.msg\n"
"        if allow:\n"
"            record.msg = 'changed: ' + record.msg\n"
"        return allow\n"
"\n"
"LOGGING = {\n"
"    'version': 1,\n"
"    'filters': {\n"
"        'myfilter': {\n"
"            '()': MyFilter,\n"
"            'param': 'noshow',\n"
"        }\n"
"    },\n"
"    'handlers': {\n"
"        'console': {\n"
"            'class': 'logging.StreamHandler',\n"
"            'filters': ['myfilter']\n"
"        }\n"
"    },\n"
"    'root': {\n"
"        'level': 'DEBUG',\n"
"        'handlers': ['console']\n"
"    },\n"
"}\n"
"\n"
"if __name__ == '__main__':\n"
"    logging.config.dictConfig(LOGGING)\n"
"    logging.debug('hello')\n"
"    logging.debug('hello - noshow')"
msgstr ""
"import logging\n"
"import logging.config\n"
"import sys\n"
"\n"
"class MyFilter(logging.Filter):\n"
"    def __init__(self, param=None):\n"
"        self.param = param\n"
"\n"
"    def filter(self, record):\n"
"        if self.param is None:\n"
"            allow = True\n"
"        else:\n"
"            allow = self.param not in record.msg\n"
"        if allow:\n"
"            record.msg = 'changed: ' + record.msg\n"
"        return allow\n"
"\n"
"LOGGING = {\n"
"    'version': 1,\n"
"    'filters': {\n"
"        'myfilter': {\n"
"            '()': MyFilter,\n"
"            'param': 'noshow',\n"
"        }\n"
"    },\n"
"    'handlers': {\n"
"        'console': {\n"
"            'class': 'logging.StreamHandler',\n"
"            'filters': ['myfilter']\n"
"        }\n"
"    },\n"
"    'root': {\n"
"        'level': 'DEBUG',\n"
"        'handlers': ['console']\n"
"    },\n"
"}\n"
"\n"
"if __name__ == '__main__':\n"
"    logging.config.dictConfig(LOGGING)\n"
"    logging.debug('hello')\n"
"    logging.debug('hello - noshow')"

#: ../../howto/logging-cookbook.rst:2890
msgid ""
"This example shows how you can pass configuration data to the callable which "
"constructs the instance, in the form of keyword parameters. When run, the "
"above script will print:"
msgstr ""
"Este ejemplo muestra cómo puede pasar datos de configuración a la llamada "
"que construye la instancia, en forma de parámetros de palabra clave. Cuando "
"se ejecute, el script anterior imprimirá:"

#: ../../howto/logging-cookbook.rst:2894
msgid "changed: hello"
msgstr "cambiado: hola"

#: ../../howto/logging-cookbook.rst:2898
msgid "which shows that the filter is working as configured."
msgstr "que muestra que el filtro funciona según lo configurado."

#: ../../howto/logging-cookbook.rst:2900
msgid "A couple of extra points to note:"
msgstr "Un par de puntos adicionales a tener en cuenta:"

#: ../../howto/logging-cookbook.rst:2902
msgid ""
"If you can't refer to the callable directly in the configuration (e.g. if it "
"lives in a different module, and you can't import it directly where the "
"configuration dictionary is), you can use the form ``ext://...`` as "
"described in :ref:`logging-config-dict-externalobj`. For example, you could "
"have used the text ``'ext://__main__.MyFilter'`` instead of ``MyFilter`` in "
"the above example."
msgstr ""
"Si no puede hacer referencia a la llamada directamente en la configuración "
"(por ejemplo, si vive en un módulo diferente y no puede importarla "
"directamente donde está el diccionario de configuración), puede utilizar la "
"forma ``ext://...`` como se describe en :ref:`logging-config-dict-"
"externalobj`. Por ejemplo, podrías haber utilizado el texto ``'ext://"
"__main__.MyFilter'`` en lugar de ``MyFilter`` en el ejemplo anterior."

#: ../../howto/logging-cookbook.rst:2909
msgid ""
"As well as for filters, this technique can also be used to configure custom "
"handlers and formatters. See :ref:`logging-config-dict-userdef` for more "
"information on how logging supports using user-defined objects in its "
"configuration, and see the other cookbook recipe :ref:`custom-handlers` "
"above."
msgstr ""
"Además de para filtros, esta técnica también se puede utilizar para "
"configurar manejadores y formateadores personalizados. Ver :ref:`logging-"
"config-dict-userdef` para obtener más información sobre cómo el registro "
"admite el uso de objetos definidos por el usuario en su configuración, y "
"consulte la otra receta del libro de cocina :ref:`custom-handlers` anterior."

#: ../../howto/logging-cookbook.rst:2918
msgid "Customized exception formatting"
msgstr "Formato personalizado de las excepciones"

#: ../../howto/logging-cookbook.rst:2920
msgid ""
"There might be times when you want to do customized exception formatting - "
"for argument's sake, let's say you want exactly one line per logged event, "
"even when exception information is present. You can do this with a custom "
"formatter class, as shown in the following example::"
msgstr ""
"Puede haber ocasiones en las que quieras hacer un formateo de excepciones "
"personalizado - por ejemplo, digamos que quieres exactamente una línea por "
"evento registrado, incluso cuando la información de excepción está presente. "
"Usted puede hacer esto con una clase de formateador personalizado, como se "
"muestra en el siguiente ejemplo::"

#: ../../howto/logging-cookbook.rst:2925
msgid ""
"import logging\n"
"\n"
"class OneLineExceptionFormatter(logging.Formatter):\n"
"    def formatException(self, exc_info):\n"
"        \"\"\"\n"
"        Format an exception so that it prints on a single line.\n"
"        \"\"\"\n"
"        result = super().formatException(exc_info)\n"
"        return repr(result)  # or format into one line however you want to\n"
"\n"
"    def format(self, record):\n"
"        s = super().format(record)\n"
"        if record.exc_text:\n"
"            s = s.replace('\\n', '') + '|'\n"
"        return s\n"
"\n"
"def configure_logging():\n"
"    fh = logging.FileHandler('output.txt', 'w')\n"
"    f = OneLineExceptionFormatter('%(asctime)s|%(levelname)s|%(message)s|',\n"
"                                  '%d/%m/%Y %H:%M:%S')\n"
"    fh.setFormatter(f)\n"
"    root = logging.getLogger()\n"
"    root.setLevel(logging.DEBUG)\n"
"    root.addHandler(fh)\n"
"\n"
"def main():\n"
"    configure_logging()\n"
"    logging.info('Sample message')\n"
"    try:\n"
"        x = 1 / 0\n"
"    except ZeroDivisionError as e:\n"
"        logging.exception('ZeroDivisionError: %s', e)\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""
"import logging\n"
"\n"
"clase OneLineExceptionFormatter(logging.Formatter):\n"
"    def formatException(self, exc_info):\n"
"        \"\"\"\n"
"        Formatea una excepción para que se imprima en una sola línea.\n"
"        \"\"\"\n"
"        result = super().formatException(exc_info)\n"
"        return repr(result) # o formatea en una línea como quieras\n"
"\n"
"    def format(self, record):\n"
"        s = super().format(record)\n"
"        if registro.exc_texto:\n"
"            s = s.replace('\\n', '') + '|'\n"
"        return s\n"
"\n"
"def configurar_logging():\n"
"    fh = logging.FileHandler('salida.txt', 'w')\n"
"    f = OneLineExceptionFormatter('%(asctime)s|%(levelname)s| %(message)s "
"|',\n"
"                                  '%d/%m/%Y %H:%M:%S')\n"
"    fh.setFormatter(f)\n"
"    root = logging.getLogger()\n"
"    root.setLevel(logging.DEBUG)\n"
"    root.addHandler(fh)\n"
"\n"
"def main():\n"
"    configure_logging()\n"
"    logging.info('Mensaje de ejemplo')\n"
"    prueba:\n"
"        x = 1 / 0\n"
"    except DivisiónCeroError as e:\n"
"        logging.exception('ErrorDivisiónCero: %s', e)\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"

#: ../../howto/logging-cookbook.rst:2961
msgid "When run, this produces a file with exactly two lines:"
msgstr "Cuando se ejecuta, produce un archivo con exactamente dos líneas:"

#: ../../howto/logging-cookbook.rst:2963
msgid ""
"28/01/2015 07:21:23|INFO|Sample message|\n"
"28/01/2015 07:21:23|ERROR|ZeroDivisionError: integer division or modulo by "
"zero|'Traceback (most recent call last):\\n  File \"logtest7.py\", line 30, "
"in main\\n    x = 1 / 0\\nZeroDivisionError: integer division or modulo by "
"zero'|"
msgstr ""
"28/01/2015 07:21:23|INFO|Mensaje de ejemplo|\n"
"28/01/2015 07:21:23|ERROR|ZeroDivisionError: integer division or modulo by "
"zero'Traceback (most recent call last):\\n File \"logtest7.py\", line 30, in "
"main\\n x = 1 / 0\\nZeroDivisionError: integer division or modulo by zero'||"

#: ../../howto/logging-cookbook.rst:2968
msgid ""
"While the above treatment is simplistic, it points the way to how exception "
"information can be formatted to your liking. The :mod:`traceback` module may "
"be helpful for more specialized needs."
msgstr ""
"Aunque el tratamiento anterior es simplista, indica cómo puede formatearse a "
"su gusto la información sobre excepciones. El módulo :mod:`traceback` puede "
"ser útil para necesidades más especializadas."

#: ../../howto/logging-cookbook.rst:2975
msgid "Speaking logging messages"
msgstr "Mensajes de registro de voz"

#: ../../howto/logging-cookbook.rst:2977
msgid ""
"There might be situations when it is desirable to have logging messages "
"rendered in an audible rather than a visible format. This is easy to do if "
"you have text-to-speech (TTS) functionality available in your system, even "
"if it doesn't have a Python binding. Most TTS systems have a command line "
"program you can run, and this can be invoked from a handler using :mod:"
"`subprocess`. It's assumed here that TTS command line programs won't expect "
"to interact with users or take a long time to complete, and that the "
"frequency of logged messages will be not so high as to swamp the user with "
"messages, and that it's acceptable to have the messages spoken one at a time "
"rather than concurrently, The example implementation below waits for one "
"message to be spoken before the next is processed, and this might cause "
"other handlers to be kept waiting. Here is a short example showing the "
"approach, which assumes that the ``espeak`` TTS package is available::"
msgstr ""
"Puede haber situaciones en las que sea deseable que los mensajes de registro "
"se muestren en un formato audible en lugar de visible. Esto es fácil de "
"hacer si tienes funcionalidad de texto a voz (TTS) disponible en tu sistema, "
"incluso si no tiene un enlace a Python. La mayoría de los sistemas TTS "
"tienen un programa de línea de comandos que puedes ejecutar, y éste puede "
"ser invocado desde un manejador usando :mod:`subprocess`. Aquí se asume que "
"los programas de línea de comandos TTS no esperan interactuar con los "
"usuarios o tardar mucho tiempo en completarse, y que la frecuencia de los "
"mensajes registrados no será tan alta como para inundar al usuario con "
"mensajes, y que es aceptable que los mensajes se hablen de uno en uno en "
"lugar de concurrentemente, La implementación de ejemplo a continuación "
"espera a que un mensaje sea hablado antes de que el siguiente sea procesado, "
"y esto podría causar que otros manejadores se mantengan a la espera. He aquí "
"un breve ejemplo que muestra el enfoque, que asume que el paquete ``espeak`` "
"TTS está disponible::"

#: ../../howto/logging-cookbook.rst:2990
msgid ""
"import logging\n"
"import subprocess\n"
"import sys\n"
"\n"
"class TTSHandler(logging.Handler):\n"
"    def emit(self, record):\n"
"        msg = self.format(record)\n"
"        # Speak slowly in a female English voice\n"
"        cmd = ['espeak', '-s150', '-ven+f3', msg]\n"
"        p = subprocess.Popen(cmd, stdout=subprocess.PIPE,\n"
"                             stderr=subprocess.STDOUT)\n"
"        # wait for the program to finish\n"
"        p.communicate()\n"
"\n"
"def configure_logging():\n"
"    h = TTSHandler()\n"
"    root = logging.getLogger()\n"
"    root.addHandler(h)\n"
"    # the default formatter just returns the message\n"
"    root.setLevel(logging.DEBUG)\n"
"\n"
"def main():\n"
"    logging.info('Hello')\n"
"    logging.debug('Goodbye')\n"
"\n"
"if __name__ == '__main__':\n"
"    configure_logging()\n"
"    sys.exit(main())"
msgstr ""
"import logging\n"
"import subprocess\n"
"import sys\n"
"\n"
"class TTSHandler(logging.Handler):\n"
"    def emit(self, record):\n"
"        msg = self.format(record)\n"
"        # Habla despacio con voz femenina en inglés\n"
"        cmd = ['espeak', '-s150', '-ven+f3', msg]\n"
"        p = subprocess.Popen(cmd, stdout=subprocess.PIPE,\n"
"                             stderr=subprocess.STDOUT)\n"
"        # espere a que finalice el programa\n"
"        p.communicate()\n"
"\n"
"def configure_logging():\n"
"    h = TTSHandler()\n"
"    root = logging.getLogger()\n"
"    root.addHandler(h)\n"
"    #el formateador predeterminado solo devuelve el mensaje\n"
"    root.setLevel(logging.DEBUG)\n"
"\n"
"def main():\n"
"    logging.info('Hello')\n"
"    logging.debug('Goodbye')\n"
"\n"
"if __name__ == '__main__':\n"
"    configure_logging()\n"
"    sys.exit(main())"

#: ../../howto/logging-cookbook.rst:3019
msgid ""
"When run, this script should say \"Hello\" and then \"Goodbye\" in a female "
"voice."
msgstr ""
"Cuando se ejecuta, este script debe decir \"Hello\" y luego \"Goodbye\" con "
"voz femenina."

#: ../../howto/logging-cookbook.rst:3021
msgid ""
"The above approach can, of course, be adapted to other TTS systems and even "
"other systems altogether which can process messages via external programs "
"run from a command line."
msgstr ""
"El enfoque anterior puede, por supuesto, adaptarse a otros sistemas TTS e "
"incluso a otros sistemas en conjunto que pueden procesar mensajes a través "
"de programas externos que se ejecutan desde una línea de comandos."

#: ../../howto/logging-cookbook.rst:3029
msgid "Buffering logging messages and outputting them conditionally"
msgstr ""
"Almacenar en búfer los mensajes de registro y enviarlos condicionalmente"

#: ../../howto/logging-cookbook.rst:3031
msgid ""
"There might be situations where you want to log messages in a temporary area "
"and only output them if a certain condition occurs. For example, you may "
"want to start logging debug events in a function, and if the function "
"completes without errors, you don't want to clutter the log with the "
"collected debug information, but if there is an error, you want all the "
"debug information to be output as well as the error."
msgstr ""
"Puede haber situaciones en las que desee registrar mensajes en un área "
"temporal y enviarlos solo si se produce una determinada condición. Por "
"ejemplo, es posible que desee comenzar a registrar depuraciones en una "
"función y, si la función se completa sin errores, no desea saturar el "
"registro con la información de depuración recopilada, pero si hay un error, "
"desea que se genere toda la información de depuración.así como el error."

#: ../../howto/logging-cookbook.rst:3038
msgid ""
"Here is an example which shows how you could do this using a decorator for "
"your functions where you want logging to behave this way. It makes use of "
"the :class:`logging.handlers.MemoryHandler`, which allows buffering of "
"logged events until some condition occurs, at which point the buffered "
"events are ``flushed`` - passed to another handler (the ``target`` handler) "
"for processing. By default, the ``MemoryHandler`` flushed when its buffer "
"gets filled up or an event whose level is greater than or equal to a "
"specified threshold is seen. You can use this recipe with a more specialised "
"subclass of ``MemoryHandler`` if you want custom flushing behavior."
msgstr ""
"Aquí tienes un ejemplo que muestra cómo se puede hacer esto usando un "
"decorador para las funciones donde se quiera que el registro se comporte de "
"esta manera. Hacer uso de :class:`logging.handlers.MemoryHandler`, que "
"permite el almacenamiento en búfer de los eventos registrados hasta que se "
"produce alguna condición, momento en el que los eventos almacenados en búfer "
"son ``flushed`` - pasados a otro manejador (el manejador ``target`` ) para "
"su procesamiento. Por defecto, el ``MemoryHandler`` se vacía cuando su "
"buffer se llena o se ve un evento cuyo nivel es mayor o igual a un umbral "
"especificado. Se puede utilizar esta receta con una subclase más "
"especializada de ``MemoryHandler`` si se desea un comportamiento de descarga "
"personalizado."

#: ../../howto/logging-cookbook.rst:3048
msgid ""
"The example script has a simple function, ``foo``, which just cycles through "
"all the logging levels, writing to ``sys.stderr`` to say what level it's "
"about to log at, and then actually logging a message at that level. You can "
"pass a parameter to ``foo`` which, if true, will log at ERROR and CRITICAL "
"levels - otherwise, it only logs at DEBUG, INFO and WARNING levels."
msgstr ""
"El script de ejemplo tiene una función simple, ``foo``, que simplemente hace "
"un ciclo a través de todos los niveles de registro, escribiendo a ``sys."
"stderr`` para decir en qué nivel está a punto de registrar, y luego "
"realmente registra un mensaje en ese nivel. Puede pasar un parámetro a "
"``foo`` que, si es verdadero, registrará en los niveles ERROR y CRÍTICO - de "
"lo contrario, sólo registrará en los niveles DEBUG, INFO y WARNING."

#: ../../howto/logging-cookbook.rst:3054
msgid ""
"The script just arranges to decorate ``foo`` with a decorator which will do "
"the conditional logging that's required. The decorator takes a logger as a "
"parameter and attaches a memory handler for the duration of the call to the "
"decorated function. The decorator can be additionally parameterised using a "
"target handler, a level at which flushing should occur, and a capacity for "
"the buffer (number of records buffered). These default to a :class:`~logging."
"StreamHandler` which writes to ``sys.stderr``, ``logging.ERROR`` and ``100`` "
"respectively."
msgstr ""
"El script simplemente se encarga de decorar ``foo`` con un decorador que "
"hará el registro condicional necesario. El decorador toma un registrador "
"como parámetro y adjunta un manejador de memoria para la duración de la "
"llamada a la función decorada. El decorador puede parametrizarse "
"adicionalmente utilizando un controlador de destino, un nivel en el que debe "
"producirse el vaciado y una capacidad para el búfer (número de registros "
"almacenados en el búfer). Por defecto, :class:`~logging.StreamHandler` "
"escribe en ``sys.stderr``, ``logging.ERROR`` y ``100`` respectivamente."

#: ../../howto/logging-cookbook.rst:3062
msgid "Here's the script::"
msgstr "Aquí está el guión::"

#: ../../howto/logging-cookbook.rst:3064
msgid ""
"import logging\n"
"from logging.handlers import MemoryHandler\n"
"import sys\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"logger.addHandler(logging.NullHandler())\n"
"\n"
"def log_if_errors(logger, target_handler=None, flush_level=None, "
"capacity=None):\n"
"    if target_handler is None:\n"
"        target_handler = logging.StreamHandler()\n"
"    if flush_level is None:\n"
"        flush_level = logging.ERROR\n"
"    if capacity is None:\n"
"        capacity = 100\n"
"    handler = MemoryHandler(capacity, flushLevel=flush_level, "
"target=target_handler)\n"
"\n"
"    def decorator(fn):\n"
"        def wrapper(*args, **kwargs):\n"
"            logger.addHandler(handler)\n"
"            try:\n"
"                return fn(*args, **kwargs)\n"
"            except Exception:\n"
"                logger.exception('call failed')\n"
"                raise\n"
"            finally:\n"
"                super(MemoryHandler, handler).flush()\n"
"                logger.removeHandler(handler)\n"
"        return wrapper\n"
"\n"
"    return decorator\n"
"\n"
"def write_line(s):\n"
"    sys.stderr.write('%s\\n' % s)\n"
"\n"
"def foo(fail=False):\n"
"    write_line('about to log at DEBUG ...')\n"
"    logger.debug('Actually logged at DEBUG')\n"
"    write_line('about to log at INFO ...')\n"
"    logger.info('Actually logged at INFO')\n"
"    write_line('about to log at WARNING ...')\n"
"    logger.warning('Actually logged at WARNING')\n"
"    if fail:\n"
"        write_line('about to log at ERROR ...')\n"
"        logger.error('Actually logged at ERROR')\n"
"        write_line('about to log at CRITICAL ...')\n"
"        logger.critical('Actually logged at CRITICAL')\n"
"    return fail\n"
"\n"
"decorated_foo = log_if_errors(logger)(foo)\n"
"\n"
"if __name__ == '__main__':\n"
"    logger.setLevel(logging.DEBUG)\n"
"    write_line('Calling undecorated foo with False')\n"
"    assert not foo(False)\n"
"    write_line('Calling undecorated foo with True')\n"
"    assert foo(True)\n"
"    write_line('Calling decorated foo with False')\n"
"    assert not decorated_foo(False)\n"
"    write_line('Calling decorated foo with True')\n"
"    assert decorated_foo(True)"
msgstr ""
"import logging\n"
"from logging.handlers import MemoryHandler\n"
"import sys\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"logger.addHandler(logging.NullHandler())\n"
"\n"
"def log_if_errors(logger, target_handler=None, flush_level=None, "
"capacity=None):\n"
"    if target_handler is None:\n"
"        target_handler = logging.StreamHandler()\n"
"    if flush_level is None:\n"
"        flush_level = logging.ERROR\n"
"    if capacity is None:\n"
"        capacity = 100\n"
"    handler = MemoryHandler(capacity, flushLevel=flush_level, "
"target=target_handler)\n"
"\n"
"    def decorator(fn):\n"
"        def wrapper(*args, **kwargs):\n"
"            logger.addHandler(handler)\n"
"            try:\n"
"                return fn(*args, **kwargs)\n"
"            except Exception:\n"
"                logger.exception('call failed')\n"
"                raise\n"
"            finally:\n"
"                super(MemoryHandler, handler).flush()\n"
"                logger.removeHandler(handler)\n"
"        return wrapper\n"
"\n"
"    return decorator\n"
"\n"
"def write_line(s):\n"
"    sys.stderr.write('%s\\n' % s)\n"
"\n"
"def foo(fail=False):\n"
"    write_line('about to log at DEBUG ...')\n"
"    logger.debug('Actually logged at DEBUG')\n"
"    write_line('about to log at INFO ...')\n"
"    logger.info('Actually logged at INFO')\n"
"    write_line('about to log at WARNING ...')\n"
"    logger.warning('Actually logged at WARNING')\n"
"    if fail:\n"
"        write_line('about to log at ERROR ...')\n"
"        logger.error('Actually logged at ERROR')\n"
"        write_line('about to log at CRITICAL ...')\n"
"        logger.critical('Actually logged at CRITICAL')\n"
"    return fail\n"
"\n"
"decorated_foo = log_if_errors(logger)(foo)\n"
"\n"
"if __name__ == '__main__':\n"
"    logger.setLevel(logging.DEBUG)\n"
"    write_line('Calling undecorated foo with False')\n"
"    assert not foo(False)\n"
"    write_line('Calling undecorated foo with True')\n"
"    assert foo(True)\n"
"    write_line('Calling decorated foo with False')\n"
"    assert not decorated_foo(False)\n"
"    write_line('Calling decorated foo with True')\n"
"    assert decorated_foo(True)"

#: ../../howto/logging-cookbook.rst:3125
msgid "When this script is run, the following output should be observed:"
msgstr "Cuando se ejecuta este script, debe observarse la siguiente salida:"

#: ../../howto/logging-cookbook.rst:3127
msgid ""
"Calling undecorated foo with False\n"
"about to log at DEBUG ...\n"
"about to log at INFO ...\n"
"about to log at WARNING ...\n"
"Calling undecorated foo with True\n"
"about to log at DEBUG ...\n"
"about to log at INFO ...\n"
"about to log at WARNING ...\n"
"about to log at ERROR ...\n"
"about to log at CRITICAL ...\n"
"Calling decorated foo with False\n"
"about to log at DEBUG ...\n"
"about to log at INFO ...\n"
"about to log at WARNING ...\n"
"Calling decorated foo with True\n"
"about to log at DEBUG ...\n"
"about to log at INFO ...\n"
"about to log at WARNING ...\n"
"about to log at ERROR ...\n"
"Actually logged at DEBUG\n"
"Actually logged at INFO\n"
"Actually logged at WARNING\n"
"Actually logged at ERROR\n"
"about to log at CRITICAL ...\n"
"Actually logged at CRITICAL"
msgstr ""
"Calling undecorated foo with False\n"
"about to log at DEBUG ...\n"
"about to log at INFO ...\n"
"about to log at WARNING ...\n"
"Calling undecorated foo with True\n"
"about to log at DEBUG ...\n"
"about to log at INFO ...\n"
"about to log at WARNING ...\n"
"about to log at ERROR ...\n"
"about to log at CRITICAL ...\n"
"Calling decorated foo with False\n"
"about to log at DEBUG ...\n"
"about to log at INFO ...\n"
"about to log at WARNING ...\n"
"Calling decorated foo with True\n"
"about to log at DEBUG ...\n"
"about to log at INFO ...\n"
"about to log at WARNING ...\n"
"about to log at ERROR ...\n"
"Actually logged at DEBUG\n"
"Actually logged at INFO\n"
"Actually logged at WARNING\n"
"Actually logged at ERROR\n"
"about to log at CRITICAL ...\n"
"Actually logged at CRITICAL"

#: ../../howto/logging-cookbook.rst:3155
msgid ""
"As you can see, actual logging output only occurs when an event is logged "
"whose severity is ERROR or greater, but in that case, any previous events at "
"lower severities are also logged."
msgstr ""
"Como puede ver, la salida de registro real sólo se produce cuando se "
"registra un evento cuya gravedad es ERROR o superior, pero en ese caso, "
"también se registra cualquier evento anterior de gravedad inferior."

#: ../../howto/logging-cookbook.rst:3159
msgid "You can of course use the conventional means of decoration::"
msgstr ""
"Por supuesto, puedes utilizar los medios convencionales de decoración::"

#: ../../howto/logging-cookbook.rst:3161
msgid ""
"@log_if_errors(logger)\n"
"def foo(fail=False):\n"
"    ..."
msgstr ""
"@log_if_errors(logger)\n"
"def foo(fail=False):\n"
"    ..."

#: ../../howto/logging-cookbook.rst:3169
msgid "Sending logging messages to email, with buffering"
msgstr ""
"Envío de mensajes de registro al correo electrónico, con almacenamiento en "
"búfer"

#: ../../howto/logging-cookbook.rst:3171
msgid ""
"To illustrate how you can send log messages via email, so that a set number "
"of messages are sent per email, you can subclass :class:`~logging.handlers."
"BufferingHandler`. In the following  example, which you can adapt to suit "
"your specific needs, a simple test harness is provided which allows you to "
"run the script with command line arguments specifying what you typically "
"need to send things via SMTP. (Run the downloaded script with the ``-h`` "
"argument to see the required and optional arguments.)"
msgstr ""
"Para ilustrar cómo puede enviar mensajes de registro por correo electrónico, "
"de forma que se envíe un número determinado de mensajes por correo "
"electrónico, puede subclasificar :class:`~logging.handlers."
"BufferingHandler`. En el siguiente ejemplo, que puedes adaptar a tus "
"necesidades específicas, se proporciona un sencillo arnés de pruebas que te "
"permite ejecutar el script con argumentos de línea de comandos que "
"especifican lo que normalmente necesitas para enviar cosas a través de SMTP. "
"(Ejecute el script descargado con el argumento ``-h`` para ver los "
"argumentos obligatorios y opcionales)."

#: ../../howto/logging-cookbook.rst:3179
msgid ""
"import logging\n"
"import logging.handlers\n"
"import smtplib\n"
"\n"
"class BufferingSMTPHandler(logging.handlers.BufferingHandler):\n"
"    def __init__(self, mailhost, port, username, password, fromaddr, "
"toaddrs,\n"
"                 subject, capacity):\n"
"        logging.handlers.BufferingHandler.__init__(self, capacity)\n"
"        self.mailhost = mailhost\n"
"        self.mailport = port\n"
"        self.username = username\n"
"        self.password = password\n"
"        self.fromaddr = fromaddr\n"
"        if isinstance(toaddrs, str):\n"
"            toaddrs = [toaddrs]\n"
"        self.toaddrs = toaddrs\n"
"        self.subject = subject\n"
"        self.setFormatter(logging.Formatter(\"%(asctime)s %(levelname)-5s "
"%(message)s\"))\n"
"\n"
"    def flush(self):\n"
"        if len(self.buffer) > 0:\n"
"            try:\n"
"                smtp = smtplib.SMTP(self.mailhost, self.mailport)\n"
"                smtp.starttls()\n"
"                smtp.login(self.username, self.password)\n"
"                msg = \"From: %s\\r\\nTo: %s\\r\\nSubject: %s\\r\\n\\r\\n\" "
"% (self.fromaddr, ','.join(self.toaddrs), self.subject)\n"
"                for record in self.buffer:\n"
"                    s = self.format(record)\n"
"                    msg = msg + s + \"\\r\\n\"\n"
"                smtp.sendmail(self.fromaddr, self.toaddrs, msg)\n"
"                smtp.quit()\n"
"            except Exception:\n"
"                if logging.raiseExceptions:\n"
"                    raise\n"
"            self.buffer = []\n"
"\n"
"if __name__ == '__main__':\n"
"    import argparse\n"
"\n"
"    ap = argparse.ArgumentParser()\n"
"    aa = ap.add_argument\n"
"    aa('host', metavar='HOST', help='SMTP server')\n"
"    aa('--port', '-p', type=int, default=587, help='SMTP port')\n"
"    aa('user', metavar='USER', help='SMTP username')\n"
"    aa('password', metavar='PASSWORD', help='SMTP password')\n"
"    aa('to', metavar='TO', help='Addressee for emails')\n"
"    aa('sender', metavar='SENDER', help='Sender email address')\n"
"    aa('--subject', '-s',\n"
"       default='Test Logging email from Python logging module (buffering)',\n"
"       help='Subject of email')\n"
"    options = ap.parse_args()\n"
"    logger = logging.getLogger()\n"
"    logger.setLevel(logging.DEBUG)\n"
"    h = BufferingSMTPHandler(options.host, options.port, options.user,\n"
"                             options.password, options.sender,\n"
"                             options.to, options.subject, 10)\n"
"    logger.addHandler(h)\n"
"    for i in range(102):\n"
"        logger.info(\"Info index = %d\", i)\n"
"    h.flush()\n"
"    h.close()"
msgstr ""
"import logging\n"
"import logging.handlers\n"
"import smtplib\n"
"\n"
"class BufferingSMTPHandler(logging.handlers.BufferingHandler):\n"
"    def __init__(self, mailhost, port, username, password, fromaddr, "
"toaddrs,\n"
"                 subject, capacity):\n"
"        logging.handlers.BufferingHandler.__init__(self, capacity)\n"
"        self.mailhost = mailhost\n"
"        self.mailport = port\n"
"        self.username = username\n"
"        self.password = password\n"
"        self.fromaddr = fromaddr\n"
"        if isinstance(toaddrs, str):\n"
"            toaddrs = [toaddrs]\n"
"        self.toaddrs = toaddrs\n"
"        self.subject = subject\n"
"        self.setFormatter(logging.Formatter(\"%(asctime)s %(levelname)-5s "
"%(message)s\"))\n"
"\n"
"    def flush(self):\n"
"        if len(self.buffer) > 0:\n"
"            try:\n"
"                smtp = smtplib.SMTP(self.mailhost, self.mailport)\n"
"                smtp.starttls()\n"
"                smtp.login(self.username, self.password)\n"
"                msg = \"From: %s\\r\\nTo: %s\\r\\nSubject: %s\\r\\n\\r\\n\" "
"% (self.fromaddr, ','.join(self.toaddrs), self.subject)\n"
"                for record in self.buffer:\n"
"                    s = self.format(record)\n"
"                    msg = msg + s + \"\\r\\n\"\n"
"                smtp.sendmail(self.fromaddr, self.toaddrs, msg)\n"
"                smtp.quit()\n"
"            except Exception:\n"
"                if logging.raiseExceptions:\n"
"                    raise\n"
"            self.buffer = []\n"
"\n"
"if __name__ == '__main__':\n"
"    import argparse\n"
"\n"
"    ap = argparse.ArgumentParser()\n"
"    aa = ap.add_argument\n"
"    aa('host', metavar='HOST', help='SMTP server')\n"
"    aa('--port', '-p', type=int, default=587, help='SMTP port')\n"
"    aa('user', metavar='USER', help='SMTP username')\n"
"    aa('password', metavar='PASSWORD', help='SMTP password')\n"
"    aa('to', metavar='TO', help='Addressee for emails')\n"
"    aa('sender', metavar='SENDER', help='Sender email address')\n"
"    aa('--subject', '-s',\n"
"       default='Test Logging email from Python logging module (buffering)',\n"
"       help='Subject of email')\n"
"    options = ap.parse_args()\n"
"    logger = logging.getLogger()\n"
"    logger.setLevel(logging.DEBUG)\n"
"    h = BufferingSMTPHandler(options.host, options.port, options.user,\n"
"                             options.password, options.sender,\n"
"                             options.to, options.subject, 10)\n"
"    logger.addHandler(h)\n"
"    for i in range(102):\n"
"        logger.info(\"Info index = %d\", i)\n"
"    h.flush()\n"
"    h.close()"

#: ../../howto/logging-cookbook.rst:3243
msgid ""
"If you run this script and your SMTP server is correctly set up, you should "
"find that it sends eleven emails to the addressee you specify. The first ten "
"emails will each have ten log messages, and the eleventh will have two "
"messages. That makes up 102 messages as specified in the script."
msgstr ""
"Si ejecuta este script y su servidor SMTP está correctamente configurado, "
"debería ver que envía once correos electrónicos al destinatario que "
"especifique. Cada uno de los diez primeros correos tendrá diez mensajes de "
"registro, y el undécimo tendrá dos mensajes. Eso hace 102 mensajes como se "
"especifica en el script."

#: ../../howto/logging-cookbook.rst:3251
msgid "Formatting times using UTC (GMT) via configuration"
msgstr "Formatear las horas utilizando UTC (GMT) en la configuración"

#: ../../howto/logging-cookbook.rst:3253
msgid ""
"Sometimes you want to format times using UTC, which can be done using a "
"class such as ``UTCFormatter``, shown below::"
msgstr ""
"A veces se desea dar formato a las horas utilizando UTC, lo que puede "
"hacerse utilizando una clase como ``UTCFormatter``, que se muestra a "
"continuación::"

#: ../../howto/logging-cookbook.rst:3256
msgid ""
"import logging\n"
"import time\n"
"\n"
"class UTCFormatter(logging.Formatter):\n"
"    converter = time.gmtime"
msgstr ""
"import logging\n"
"import time\n"
"\n"
"class UTCFormatter(logging.Formatter):\n"
"    converter = time.gmtime"

#: ../../howto/logging-cookbook.rst:3262
msgid ""
"and you can then use the ``UTCFormatter`` in your code instead of :class:"
"`~logging.Formatter`. If you want to do that via configuration, you can use "
"the :func:`~logging.config.dictConfig` API with an approach illustrated by "
"the following complete example::"
msgstr ""
"y entonces podrá utilizar ``UTCFormatter`` en su código en lugar de :class:"
"`~logging.Formatter`. Si desea hacerlo mediante configuración, puede "
"utilizar la API :func:`~logging.config.dictConfig` con un enfoque que se "
"ilustra en el siguiente ejemplo completo::"

#: ../../howto/logging-cookbook.rst:3267
msgid ""
"import logging\n"
"import logging.config\n"
"import time\n"
"\n"
"class UTCFormatter(logging.Formatter):\n"
"    converter = time.gmtime\n"
"\n"
"LOGGING = {\n"
"    'version': 1,\n"
"    'disable_existing_loggers': False,\n"
"    'formatters': {\n"
"        'utc': {\n"
"            '()': UTCFormatter,\n"
"            'format': '%(asctime)s %(message)s',\n"
"        },\n"
"        'local': {\n"
"            'format': '%(asctime)s %(message)s',\n"
"        }\n"
"    },\n"
"    'handlers': {\n"
"        'console1': {\n"
"            'class': 'logging.StreamHandler',\n"
"            'formatter': 'utc',\n"
"        },\n"
"        'console2': {\n"
"            'class': 'logging.StreamHandler',\n"
"            'formatter': 'local',\n"
"        },\n"
"    },\n"
"    'root': {\n"
"        'handlers': ['console1', 'console2'],\n"
"   }\n"
"}\n"
"\n"
"if __name__ == '__main__':\n"
"    logging.config.dictConfig(LOGGING)\n"
"    logging.warning('The local time is %s', time.asctime())"
msgstr ""
"import logging\n"
"import logging.config\n"
"import time\n"
"\n"
"class UTCFormatter(logging.Formatter):\n"
"    converter = time.gmtime\n"
"\n"
"LOGGING = {\n"
"    'version': 1,\n"
"    'disable_existing_loggers': False,\n"
"    'formatters': {\n"
"        'utc': {\n"
"            '()': UTCFormatter,\n"
"            'format': '%(asctime)s %(message)s',\n"
"        },\n"
"        'local': {\n"
"            'format': '%(asctime)s %(message)s',\n"
"        }\n"
"    },\n"
"    'handlers': {\n"
"        'console1': {\n"
"            'class': 'logging.StreamHandler',\n"
"            'formatter': 'utc',\n"
"        },\n"
"        'console2': {\n"
"            'class': 'logging.StreamHandler',\n"
"            'formatter': 'local',\n"
"        },\n"
"    },\n"
"    'root': {\n"
"        'handlers': ['console1', 'console2'],\n"
"   }\n"
"}\n"
"\n"
"if __name__ == '__main__':\n"
"    logging.config.dictConfig(LOGGING)\n"
"    logging.warning('La hora local es %s', time.asctime())"

#: ../../howto/logging-cookbook.rst:3305
msgid "When this script is run, it should print something like:"
msgstr "Cuando se ejecuta este script, debería imprimir algo como:"

#: ../../howto/logging-cookbook.rst:3307
msgid ""
"2015-10-17 12:53:29,501 The local time is Sat Oct 17 13:53:29 2015\n"
"2015-10-17 13:53:29,501 The local time is Sat Oct 17 13:53:29 2015"
msgstr ""
"2015-10-17 12:53:29,501 La hora local es Sat Oct 17 13:53:29 2015\n"
"2015-10-17 13:53:29,501 La hora local es Sat Oct 17 13:53:29 2015"

#: ../../howto/logging-cookbook.rst:3312
msgid ""
"showing how the time is formatted both as local time and UTC, one for each "
"handler."
msgstr ""
"mostrando cómo se formatea la hora tanto en hora local como en UTC, uno para "
"cada manejador."

#: ../../howto/logging-cookbook.rst:3319
msgid "Using a context manager for selective logging"
msgstr "Uso de un gestor de contexto para el registro selectivo"

#: ../../howto/logging-cookbook.rst:3321
msgid ""
"There are times when it would be useful to temporarily change the logging "
"configuration and revert it back after doing something. For this, a context "
"manager is the most obvious way of saving and restoring the logging context. "
"Here is a simple example of such a context manager, which allows you to "
"optionally change the logging level and add a logging handler purely in the "
"scope of the context manager::"
msgstr ""
"Hay ocasiones en las que sería útil cambiar temporalmente la configuración "
"de registro y revertirla después de hacer algo. Para ello, un gestor de "
"contexto es la forma más obvia de guardar y restaurar el contexto de "
"registro. He aquí un ejemplo sencillo de tal gestor de contexto, que le "
"permite cambiar opcionalmente el nivel de registro y añadir un gestor de "
"registro puramente en el ámbito del gestor de contexto::"

#: ../../howto/logging-cookbook.rst:3328
msgid ""
"import logging\n"
"import sys\n"
"\n"
"class LoggingContext:\n"
"    def __init__(self, logger, level=None, handler=None, close=True):\n"
"        self.logger = logger\n"
"        self.level = level\n"
"        self.handler = handler\n"
"        self.close = close\n"
"\n"
"    def __enter__(self):\n"
"        if self.level is not None:\n"
"            self.old_level = self.logger.level\n"
"            self.logger.setLevel(self.level)\n"
"        if self.handler:\n"
"            self.logger.addHandler(self.handler)\n"
"\n"
"    def __exit__(self, et, ev, tb):\n"
"        if self.level is not None:\n"
"            self.logger.setLevel(self.old_level)\n"
"        if self.handler:\n"
"            self.logger.removeHandler(self.handler)\n"
"        if self.handler and self.close:\n"
"            self.handler.close()\n"
"        # implicit return of None => don't swallow exceptions"
msgstr ""
"import logging\n"
"import sys\n"
"\n"
"class LoggingContext:\n"
"    def __init__(self, logger, level=None, handler=None, close=True):\n"
"        self.logger = logger\n"
"        self.level = level\n"
"        self.handler = handler\n"
"        self.close = close\n"
"\n"
"    def __enter__(self):\n"
"        if self.level is not None:\n"
"            self.old_level = self.logger.level\n"
"            self.logger.setLevel(self.level)\n"
"        if self.handler:\n"
"            self.logger.addHandler(self.handler)\n"
"\n"
"    def __exit__(self, et, ev, tb):\n"
"        if self.level is not None:\n"
"            self.logger.setLevel(self.old_level)\n"
"        if self.handler:\n"
"            self.logger.removeHandler(self.handler)\n"
"        if self.handler and self.close:\n"
"            self.handler.close()\n"
"        # retorno implícito de None = > no aceptar excepciones"

#: ../../howto/logging-cookbook.rst:3354
msgid ""
"If you specify a level value, the logger's level is set to that value in the "
"scope of the with block covered by the context manager. If you specify a "
"handler, it is added to the logger on entry to the block and removed on exit "
"from the block. You can also ask the manager to close the handler for you on "
"block exit - you could do this if you don't need the handler any more."
msgstr ""
"Si especifica un valor de nivel, el nivel del registrador se establece en "
"ese valor en el ámbito del bloque with cubierto por el gestor de contexto. "
"Si especifica un manejador, se añade al registrador al entrar en el bloque y "
"se elimina al salir del bloque. También puedes pedir al gestor que cierre el "
"manejador por ti al salir del bloque - podrías hacer esto si ya no necesitas "
"el manejador."

#: ../../howto/logging-cookbook.rst:3360
msgid ""
"To illustrate how it works, we can add the following block of code to the "
"above::"
msgstr ""
"Para ilustrar cómo funciona, podemos añadir el siguiente bloque de código al "
"anterior::"

#: ../../howto/logging-cookbook.rst:3363
msgid ""
"if __name__ == '__main__':\n"
"    logger = logging.getLogger('foo')\n"
"    logger.addHandler(logging.StreamHandler())\n"
"    logger.setLevel(logging.INFO)\n"
"    logger.info('1. This should appear just once on stderr.')\n"
"    logger.debug('2. This should not appear.')\n"
"    with LoggingContext(logger, level=logging.DEBUG):\n"
"        logger.debug('3. This should appear once on stderr.')\n"
"    logger.debug('4. This should not appear.')\n"
"    h = logging.StreamHandler(sys.stdout)\n"
"    with LoggingContext(logger, level=logging.DEBUG, handler=h, "
"close=True):\n"
"        logger.debug('5. This should appear twice - once on stderr and once "
"on stdout.')\n"
"    logger.info('6. This should appear just once on stderr.')\n"
"    logger.debug('7. This should not appear.')"
msgstr ""
"if __name__ == '__main__':\n"
"    logger = logging.getLogger('foo')\n"
"    logger.addHandler(logging.StreamHandler())\n"
"    logger.setLevel(logging.INFO)\n"
"    logger.info('1. This should appear just once on stderr.')\n"
"    logger.debug('2. This should not appear.')\n"
"    with LoggingContext(logger, level=logging.DEBUG):\n"
"        logger.debug('3. This should appear once on stderr.')\n"
"    logger.debug('4. This should not appear.')\n"
"    h = logging.StreamHandler(sys.stdout)\n"
"    with LoggingContext(logger, level=logging.DEBUG, handler=h, "
"close=True):\n"
"        logger.debug('5. This should appear twice - once on stderr and once "
"on stdout.')\n"
"    logger.info('6. This should appear just once on stderr.')\n"
"    logger.debug('7. This should not appear.')"

#: ../../howto/logging-cookbook.rst:3378
msgid ""
"We initially set the logger's level to ``INFO``, so message #1 appears and "
"message #2 doesn't. We then change the level to ``DEBUG`` temporarily in the "
"following ``with`` block, and so message #3 appears. After the block exits, "
"the logger's level is restored to ``INFO`` and so message #4 doesn't appear. "
"In the next ``with`` block, we set the level to ``DEBUG`` again but also add "
"a handler writing to ``sys.stdout``. Thus, message #5 appears twice on the "
"console (once via ``stderr`` and once via ``stdout``). After the ``with`` "
"statement's completion, the status is as it was before so message #6 appears "
"(like message #1) whereas message #7 doesn't (just like message #2)."
msgstr ""
"Inicialmente establecemos el nivel del registrador en ``INFO``, por lo que "
"el mensaje #1 aparece y el #2 no. A continuación, cambiamos temporalmente el "
"nivel a ``DEBUG`` en el siguiente bloque ``with``, por lo que aparece el "
"mensaje nº 3. Después de salir del bloque, el nivel del registrador se "
"restablece a , por lo que no aparece el mensaje nº 4. Tras salir del bloque, "
"el nivel del registrador se restablece a ``INFO``, por lo que el mensaje nº "
"4 no aparece. En el siguiente bloque ``with``, volvemos a establecer el "
"nivel en ``DEBUG`` pero también añadimos un manejador que escribe en ``sys."
"stdout``. Así, el mensaje #5 aparece dos veces en la consola (una a través "
"de ``stderr`` y otra a través de ``stdout``). Tras la finalización de la "
"sentencia ``with``, el estado es el mismo que antes, de modo que el mensaje "
"#6 aparece (como el mensaje #1) mientras que el mensaje #7 no lo hace (igual "
"que el mensaje #2)."

#: ../../howto/logging-cookbook.rst:3388
msgid "If we run the resulting script, the result is as follows:"
msgstr "Si ejecutamos el script resultante, el resultado es el siguiente:"

#: ../../howto/logging-cookbook.rst:3390
msgid ""
"$ python logctx.py\n"
"1. This should appear just once on stderr.\n"
"3. This should appear once on stderr.\n"
"5. This should appear twice - once on stderr and once on stdout.\n"
"5. This should appear twice - once on stderr and once on stdout.\n"
"6. This should appear just once on stderr."
msgstr ""
"$ python logctx.py\n"
"1. Esto debería aparecer sólo una vez en stderr.\n"
"3. Esto debería aparecer una vez en stderr.\n"
"5. Esto debería aparecer dos veces - una en stderr y otra en stdout.\n"
"5. Esto debería aparecer dos veces - una en stderr y otra en stdout.\n"
"6. Esto debería aparecer sólo una vez en stderr."

#: ../../howto/logging-cookbook.rst:3399
msgid ""
"If we run it again, but pipe ``stderr`` to ``/dev/null``, we see the "
"following, which is the only message written to ``stdout``:"
msgstr ""
"Si lo ejecutamos de nuevo, pero canalizando ``stderr`` a ``/dev/null``, "
"veremos lo siguiente, que es el único mensaje escrito en ``stdout``:"

#: ../../howto/logging-cookbook.rst:3402
msgid ""
"$ python logctx.py 2>/dev/null\n"
"5. This should appear twice - once on stderr and once on stdout."
msgstr ""
"$ python logctx.py 2>/dev/null\n"
"5. Esto debería aparecer dos veces - una en stderr y otra en stdout."

#: ../../howto/logging-cookbook.rst:3407
msgid "Once again, but piping ``stdout`` to ``/dev/null``, we get:"
msgstr "Una vez más, pero canalizando ``stdout`` a ``/dev/null``, obtenemos:"

#: ../../howto/logging-cookbook.rst:3409
msgid ""
"$ python logctx.py >/dev/null\n"
"1. This should appear just once on stderr.\n"
"3. This should appear once on stderr.\n"
"5. This should appear twice - once on stderr and once on stdout.\n"
"6. This should appear just once on stderr."
msgstr ""
"$ python logctx.py >/dev/null\n"
"1. Esto debería aparecer sólo una vez en stderr.\n"
"3. Esto debería aparecer una vez en stderr.\n"
"5. Esto debería aparecer dos veces - una en stderr y otra en stdout.\n"
"6. Esto debería aparecer sólo una vez en stderr."

#: ../../howto/logging-cookbook.rst:3417
msgid ""
"In this case, the message #5 printed to ``stdout`` doesn't appear, as "
"expected."
msgstr ""
"En este caso, el mensaje #5 impreso en ``stdout`` no aparece, como era de "
"esperar."

#: ../../howto/logging-cookbook.rst:3419
msgid ""
"Of course, the approach described here can be generalised, for example to "
"attach logging filters temporarily. Note that the above code works in Python "
"2 as well as Python 3."
msgstr ""
"Por supuesto, el enfoque aquí descrito puede generalizarse, por ejemplo para "
"adjuntar filtros de registro temporalmente. Tener en cuenta que el código "
"anterior funciona tanto en Python 2 como en Python 3."

#: ../../howto/logging-cookbook.rst:3427
msgid "A CLI application starter template"
msgstr "Una plantilla de inicio de aplicación CLI"

#: ../../howto/logging-cookbook.rst:3429
msgid "Here's an example which shows how you can:"
msgstr "He aquí un ejemplo que muestra cómo hacerlo:"

#: ../../howto/logging-cookbook.rst:3431
msgid "Use a logging level based on command-line arguments"
msgstr ""
"Utilizar un nivel de registro basado en los argumentos de la línea de "
"comandos"

#: ../../howto/logging-cookbook.rst:3432
msgid ""
"Dispatch to multiple subcommands in separate files, all logging at the same "
"level in a consistent way"
msgstr ""
"Envío a múltiples subcomandos en archivos separados, todos los registros en "
"el mismo nivel de una manera coherente"

#: ../../howto/logging-cookbook.rst:3434
msgid "Make use of simple, minimal configuration"
msgstr "Utilice una configuración sencilla y mínima"

#: ../../howto/logging-cookbook.rst:3436
msgid ""
"Suppose we have a command-line application whose job is to stop, start or "
"restart some services. This could be organised for the purposes of "
"illustration as a file ``app.py`` that is the main script for the "
"application, with individual commands implemented in ``start.py``, ``stop."
"py`` and ``restart.py``. Suppose further that we want to control the "
"verbosity of the application via a command-line argument, defaulting to "
"``logging.INFO``. Here's one way that ``app.py`` could be written::"
msgstr ""
"Supongamos que tenemos una aplicación de línea de comandos cuyo trabajo "
"consiste en detener, iniciar o reiniciar algunos servicios. Esto podría "
"organizarse, a efectos ilustrativos, como un archivo ``app.py`` que es el "
"script principal de la aplicación, con comandos individuales implementados "
"en ``start.py``, ``stop.py`` y ``restart.py``. Supongamos además que "
"queremos controlar la verbosidad de la aplicación a través de un argumento "
"de línea de comandos, por defecto ``logging.INFO``. He aquí una forma en que "
"se podría escribir ``app.py``::"

#: ../../howto/logging-cookbook.rst:3444
msgid ""
"import argparse\n"
"import importlib\n"
"import logging\n"
"import os\n"
"import sys\n"
"\n"
"def main(args=None):\n"
"    scriptname = os.path.basename(__file__)\n"
"    parser = argparse.ArgumentParser(scriptname)\n"
"    levels = ('DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL')\n"
"    parser.add_argument('--log-level', default='INFO', choices=levels)\n"
"    subparsers = parser.add_subparsers(dest='command',\n"
"                                       help='Available commands:')\n"
"    start_cmd = subparsers.add_parser('start', help='Start a service')\n"
"    start_cmd.add_argument('name', metavar='NAME',\n"
"                           help='Name of service to start')\n"
"    stop_cmd = subparsers.add_parser('stop',\n"
"                                     help='Stop one or more services')\n"
"    stop_cmd.add_argument('names', metavar='NAME', nargs='+',\n"
"                          help='Name of service to stop')\n"
"    restart_cmd = subparsers.add_parser('restart',\n"
"                                        help='Restart one or more "
"services')\n"
"    restart_cmd.add_argument('names', metavar='NAME', nargs='+',\n"
"                             help='Name of service to restart')\n"
"    options = parser.parse_args()\n"
"    # the code to dispatch commands could all be in this file. For the "
"purposes\n"
"    # of illustration only, we implement each command in a separate module.\n"
"    try:\n"
"        mod = importlib.import_module(options.command)\n"
"        cmd = getattr(mod, 'command')\n"
"    except (ImportError, AttributeError):\n"
"        print('Unable to find the code for command \\'%s\\'' % options."
"command)\n"
"        return 1\n"
"    # Could get fancy here and load configuration from file or dictionary\n"
"    logging.basicConfig(level=options.log_level,\n"
"                        format='%(levelname)s %(name)s %(message)s')\n"
"    cmd(options)\n"
"\n"
"if __name__ == '__main__':\n"
"    sys.exit(main())"
msgstr ""
"import argparse\n"
"import importlib\n"
"import logging\n"
"import os\n"
"import sys\n"
"\n"
"def main(args=None):\n"
"    scriptname = os.path.basename(__file__)\n"
"    parser = argparse.ArgumentParser(scriptname)\n"
"    levels = ('DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL')\n"
"    parser.add_argument('--log-level', default='INFO', choices=levels)\n"
"    subparsers = parser.add_subparsers(dest='command',\n"
"                                       help='Available commands:')\n"
"    start_cmd = subparsers.add_parser('start', help='Start a service')\n"
"    start_cmd.add_argument('name', metavar='NAME',\n"
"                           help='Name of service to start')\n"
"    stop_cmd = subparsers.add_parser('stop',\n"
"                                     help='Stop one or more services')\n"
"    stop_cmd.add_argument('names', metavar='NAME', nargs='+',\n"
"                          help='Name of service to stop')\n"
"    restart_cmd = subparsers.add_parser('restart',\n"
"                                        help='Restart one or more "
"services')\n"
"    restart_cmd.add_argument('names', metavar='NAME', nargs='+',\n"
"                             help='Name of service to restart')\n"
"    options = parser.parse_args()\n"
"    # el código para enviar comandos podría estar en este archivo. Para los "
"fines\n"
"     # de ilustración solamente, implementamos cada comando en un módulo "
"separado.\n"
"    try:\n"
"        mod = importlib.import_module(options.command)\n"
"        cmd = getattr(mod, 'command')\n"
"    except (ImportError, AttributeError):\n"
"        print('Unable to find the code for command \\'%s\\'' % options."
"command)\n"
"        return 1\n"
"    # Podría ponerse elegante aquí y cargar la configuración desde el "
"archivo o el diccionario\n"
"     logging.basicConfig(level=options.log_level,\n"
"format='%(levelname)s %(name)s %(message)s')\n"
"    cmd(options)\n"
"\n"
"if __name__ == '__main__':\n"
"    sys.exit(main())"

#: ../../howto/logging-cookbook.rst:3485
msgid ""
"And the ``start``, ``stop`` and ``restart`` commands can be implemented in "
"separate modules, like so for starting::"
msgstr ""
"Y los comandos ``start``, ``stop`` y ``restart``se  pueden implementar en "
"módulos separados, así para empezar::"

#: ../../howto/logging-cookbook.rst:3488
msgid ""
"# start.py\n"
"import logging\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"def command(options):\n"
"    logger.debug('About to start %s', options.name)\n"
"    # actually do the command processing here ...\n"
"    logger.info('Started the \\'%s\\' service.', options.name)"
msgstr ""
"# start.py\n"
"importar logging\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"def comando(opciones):\n"
"    logger.debug('A punto de iniciar %s', options.name)\n"
"    # procesa el comando aquí ...\n"
"    logger.info('Iniciado el servicio \\'%s\\'.', options.name)"

#: ../../howto/logging-cookbook.rst:3498
msgid "and thus for stopping::"
msgstr "y por lo tanto para detener::"

#: ../../howto/logging-cookbook.rst:3500
msgid ""
"# stop.py\n"
"import logging\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"def command(options):\n"
"    n = len(options.names)\n"
"    if n == 1:\n"
"        plural = ''\n"
"        services = '\\'%s\\'' % options.names[0]\n"
"    else:\n"
"        plural = 's'\n"
"        services = ', '.join('\\'%s\\'' % name for name in options.names)\n"
"        i = services.rfind(', ')\n"
"        services = services[:i] + ' and ' + services[i + 2:]\n"
"    logger.debug('About to stop %s', services)\n"
"    # actually do the command processing here ...\n"
"    logger.info('Stopped the %s service%s.', services, plural)"
msgstr ""
"# stop.py\n"
"import logging\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"def command(options):\n"
"    n = len(options.names)\n"
"    if n == 1:\n"
"        plural = ''\n"
"        services = '\\'%s\\'' % options.names[0]\n"
"    else:\n"
"        plural = 's'\n"
"        services = ', '.join('\\'%s\\'' % name for name in options.names)\n"
"        i = services.rfind(', ')\n"
"        services = services[:i] + ' and ' + services[i + 2:]\n"
"    logger.debug('About to stop %s', services)\n"
"    # en realidad, haga el procesamiento del comando aquí...\n"
"    logger.info('Stopped the %s service%s.', services, plural)"

#: ../../howto/logging-cookbook.rst:3519
msgid "and similarly for restarting::"
msgstr "y lo mismo para reiniciar::"

#: ../../howto/logging-cookbook.rst:3521
msgid ""
"# restart.py\n"
"import logging\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"def command(options):\n"
"    n = len(options.names)\n"
"    if n == 1:\n"
"        plural = ''\n"
"        services = '\\'%s\\'' % options.names[0]\n"
"    else:\n"
"        plural = 's'\n"
"        services = ', '.join('\\'%s\\'' % name for name in options.names)\n"
"        i = services.rfind(', ')\n"
"        services = services[:i] + ' and ' + services[i + 2:]\n"
"    logger.debug('About to restart %s', services)\n"
"    # actually do the command processing here ...\n"
"    logger.info('Restarted the %s service%s.', services, plural)"
msgstr ""
"# restart.py\n"
"import logging\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"def command(options):\n"
"    n = len(options.names)\n"
"    if n == 1:\n"
"        plural = ''\n"
"        services = '\\'%s\\'' % options.names[0]\n"
"    else:\n"
"        plural = 's'\n"
"        services = ', '.join('\\'%s\\'' % name for name in options.names)\n"
"        i = services.rfind(', ')\n"
"        services = services[:i] + ' and ' + services[i + 2:]\n"
"    logger.debug('About to restart %s', services)\n"
"    # en realidad, haga el procesamiento del comando aquí ...\n"
"    logger.info('Restarted the %s service%s.', services, plural)"

#: ../../howto/logging-cookbook.rst:3540
msgid ""
"If we run this application with the default log level, we get output like "
"this:"
msgstr ""
"Si ejecutamos esta aplicación con el nivel de registro por defecto, "
"obtendremos una salida como esta:"

#: ../../howto/logging-cookbook.rst:3542
msgid ""
"$ python app.py start foo\n"
"INFO start Started the 'foo' service.\n"
"\n"
"$ python app.py stop foo bar\n"
"INFO stop Stopped the 'foo' and 'bar' services.\n"
"\n"
"$ python app.py restart foo bar baz\n"
"INFO restart Restarted the 'foo', 'bar' and 'baz' services."
msgstr ""
"$ python app.py start foo\n"
"INFO start Started the 'foo' service.\n"
"\n"
"$ python app.py stop foo bar\n"
"INFO stop Stopped the 'foo' and 'bar' services.\n"
"\n"
"$ python app.py restart foo bar baz\n"
"INFO restart Restarted the 'foo', 'bar' and 'baz' services."

#: ../../howto/logging-cookbook.rst:3553
msgid ""
"The first word is the logging level, and the second word is the module or "
"package name of the place where the event was logged."
msgstr ""
"La primera palabra es el nivel de registro y la segunda es el nombre del "
"módulo o paquete donde se registró el evento."

#: ../../howto/logging-cookbook.rst:3556
msgid ""
"If we change the logging level, then we can change the information sent to "
"the log. For example, if we want more information:"
msgstr ""
"Si cambiamos el nivel de registro, podemos cambiar la información que se "
"envía al registro. Por ejemplo, si queremos más información:"

#: ../../howto/logging-cookbook.rst:3559
msgid ""
"$ python app.py --log-level DEBUG start foo\n"
"DEBUG start About to start foo\n"
"INFO start Started the 'foo' service.\n"
"\n"
"$ python app.py --log-level DEBUG stop foo bar\n"
"DEBUG stop About to stop 'foo' and 'bar'\n"
"INFO stop Stopped the 'foo' and 'bar' services.\n"
"\n"
"$ python app.py --log-level DEBUG restart foo bar baz\n"
"DEBUG restart About to restart 'foo', 'bar' and 'baz'\n"
"INFO restart Restarted the 'foo', 'bar' and 'baz' services."
msgstr ""
"$ python app.py --log-level DEBUG start foo\n"
"DEBUG start About to start foo\n"
"INFO start Started the 'foo' service.\n"
"\n"
"$ python app.py --log-level DEBUG stop foo bar\n"
"DEBUG stop About to stop 'foo' and 'bar'\n"
"INFO stop Stopped the 'foo' and 'bar' services.\n"
"\n"
"$ python app.py --log-level DEBUG restart foo bar baz\n"
"DEBUG restart About to restart 'foo', 'bar' and 'baz'\n"
"INFO restart Restarted the 'foo', 'bar' and 'baz' services."

#: ../../howto/logging-cookbook.rst:3573
msgid "And if we want less:"
msgstr "Y si queremos menos:"

#: ../../howto/logging-cookbook.rst:3575
msgid ""
"$ python app.py --log-level WARNING start foo\n"
"$ python app.py --log-level WARNING stop foo bar\n"
"$ python app.py --log-level WARNING restart foo bar baz"
msgstr ""
"$ python app.py --log-level WARNING start foo\n"
"$ python app.py --log-level WARNING stop foo bar\n"
"$ python app.py --log-level WARNING restart foo bar baz"

#: ../../howto/logging-cookbook.rst:3581
msgid ""
"In this case, the commands don't print anything to the console, since "
"nothing at ``WARNING`` level or above is logged by them."
msgstr ""
"En este caso, los comandos no imprimen nada en la consola, ya que no "
"registran nada a nivel ``WARNING`` o superior."

#: ../../howto/logging-cookbook.rst:3587
msgid "A Qt GUI for logging"
msgstr "Una interfaz gráfica Qt para el registro"

#: ../../howto/logging-cookbook.rst:3589
msgid ""
"A question that comes up from time to time is about how to log to a GUI "
"application. The `Qt <https://www.qt.io/>`_ framework is a popular cross-"
"platform UI framework with Python bindings using :pypi:`PySide2` or :pypi:"
"`PyQt5` libraries."
msgstr ""
"Una pregunta que surge de vez en cuando es cómo iniciar sesión en una "
"aplicación GUI. El framework `Qt <https://www.qt.io/>`_ es un popular "
"framework de interfaz de usuario multiplataforma con enlaces a Python "
"utilizando las librerías :pypi:`PySide2` o :pypi:`PyQt5`."

#: ../../howto/logging-cookbook.rst:3594
msgid ""
"The following example shows how to log to a Qt GUI. This introduces a simple "
"``QtHandler`` class which takes a callable, which should be a slot in the "
"main thread that does GUI updates. A worker thread is also created to show "
"how you can log to the GUI from both the UI itself (via a button for manual "
"logging) as well as a worker thread doing work in the background (here, just "
"logging messages at random levels with random short delays in between)."
msgstr ""
"El siguiente ejemplo muestra cómo registrar una GUI Qt. Esto introduce una "
"simple clase ``QtHandler`` que toma un callable, que debería ser un slot en "
"el hilo principal que hace las actualizaciones de la GUI. También se crea un "
"subproceso de trabajo para mostrar cómo se puede acceder a la interfaz "
"gráfica de usuario tanto desde la propia interfaz (a través de un botón para "
"el registro manual) como desde un subproceso de trabajo en segundo plano (en "
"este caso, sólo el registro de mensajes en niveles aleatorios con pequeños "
"retrasos aleatorios entre ellos)."

#: ../../howto/logging-cookbook.rst:3601
msgid ""
"The worker thread is implemented using Qt's ``QThread`` class rather than "
"the :mod:`threading` module, as there are circumstances where one has to use "
"``QThread``, which offers better integration with other ``Qt`` components."
msgstr ""
"El hilo trabajador se implementa utilizando la clase ``QThread`` de Qt en "
"lugar del módulo :mod:`threading`, ya que hay circunstancias en las que hay "
"que utilizar ``QThread``, que ofrece una mejor integración con otros "
"componentes de ``Qt``."

#: ../../howto/logging-cookbook.rst:3605
msgid ""
"The code should work with recent releases of any of ``PySide6``, ``PyQt6``, "
"``PySide2`` or ``PyQt5``. You should be able to adapt the approach to "
"earlier versions of Qt. Please refer to the comments in the code snippet for "
"more detailed information."
msgstr ""
"El código debería funcionar con versiones recientes de cualquiera de "
"``PySide6``, ``PyQt6``, ``PySide2`` o ``PyQt5``. Deberías poder adaptar el "
"enfoque a versiones anteriores de Qt. Consulte los comentarios del fragmento "
"de código para obtener información más detallada."

#: ../../howto/logging-cookbook.rst:3610
msgid ""
"import datetime\n"
"import logging\n"
"import random\n"
"import sys\n"
"import time\n"
"\n"
"# Deal with minor differences between different Qt packages\n"
"try:\n"
"    from PySide6 import QtCore, QtGui, QtWidgets\n"
"    Signal = QtCore.Signal\n"
"    Slot = QtCore.Slot\n"
"except ImportError:\n"
"    try:\n"
"        from PyQt6 import QtCore, QtGui, QtWidgets\n"
"        Signal = QtCore.pyqtSignal\n"
"        Slot = QtCore.pyqtSlot\n"
"    except ImportError:\n"
"        try:\n"
"            from PySide2 import QtCore, QtGui, QtWidgets\n"
"            Signal = QtCore.Signal\n"
"            Slot = QtCore.Slot\n"
"        except ImportError:\n"
"            from PyQt5 import QtCore, QtGui, QtWidgets\n"
"            Signal = QtCore.pyqtSignal\n"
"            Slot = QtCore.pyqtSlot\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"\n"
"#\n"
"# Signals need to be contained in a QObject or subclass in order to be "
"correctly\n"
"# initialized.\n"
"#\n"
"class Signaller(QtCore.QObject):\n"
"    signal = Signal(str, logging.LogRecord)\n"
"\n"
"#\n"
"# Output to a Qt GUI is only supposed to happen on the main thread. So, "
"this\n"
"# handler is designed to take a slot function which is set up to run in the "
"main\n"
"# thread. In this example, the function takes a string argument which is a\n"
"# formatted log message, and the log record which generated it. The "
"formatted\n"
"# string is just a convenience - you could format a string for output any "
"way\n"
"# you like in the slot function itself.\n"
"#\n"
"# You specify the slot function to do whatever GUI updates you want. The "
"handler\n"
"# doesn't know or care about specific UI elements.\n"
"#\n"
"class QtHandler(logging.Handler):\n"
"    def __init__(self, slotfunc, *args, **kwargs):\n"
"        super().__init__(*args, **kwargs)\n"
"        self.signaller = Signaller()\n"
"        self.signaller.signal.connect(slotfunc)\n"
"\n"
"    def emit(self, record):\n"
"        s = self.format(record)\n"
"        self.signaller.signal.emit(s, record)\n"
"\n"
"#\n"
"# This example uses QThreads, which means that the threads at the Python "
"level\n"
"# are named something like \"Dummy-1\". The function below gets the Qt name "
"of the\n"
"# current thread.\n"
"#\n"
"def ctname():\n"
"    return QtCore.QThread.currentThread().objectName()\n"
"\n"
"\n"
"#\n"
"# Used to generate random levels for logging.\n"
"#\n"
"LEVELS = (logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR,\n"
"          logging.CRITICAL)\n"
"\n"
"#\n"
"# This worker class represents work that is done in a thread separate to "
"the\n"
"# main thread. The way the thread is kicked off to do work is via a button "
"press\n"
"# that connects to a slot in the worker.\n"
"#\n"
"# Because the default threadName value in the LogRecord isn't much use, we "
"add\n"
"# a qThreadName which contains the QThread name as computed above, and pass "
"that\n"
"# value in an \"extra\" dictionary which is used to update the LogRecord "
"with the\n"
"# QThread name.\n"
"#\n"
"# This example worker just outputs messages sequentially, interspersed with\n"
"# random delays of the order of a few seconds.\n"
"#\n"
"class Worker(QtCore.QObject):\n"
"    @Slot()\n"
"    def start(self):\n"
"        extra = {'qThreadName': ctname() }\n"
"        logger.debug('Started work', extra=extra)\n"
"        i = 1\n"
"        # Let the thread run until interrupted. This allows reasonably "
"clean\n"
"        # thread termination.\n"
"        while not QtCore.QThread.currentThread().isInterruptionRequested():\n"
"            delay = 0.5 + random.random() * 2\n"
"            time.sleep(delay)\n"
"            try:\n"
"                if random.random() < 0.1:\n"
"                    raise ValueError('Exception raised: %d' % i)\n"
"                else:\n"
"                    level = random.choice(LEVELS)\n"
"                    logger.log(level, 'Message after delay of %3.1f: %d', "
"delay, i, extra=extra)\n"
"            except ValueError as e:\n"
"                logger.exception('Failed: %s', e, extra=extra)\n"
"            i += 1\n"
"\n"
"#\n"
"# Implement a simple UI for this cookbook example. This contains:\n"
"#\n"
"# * A read-only text edit window which holds formatted log messages\n"
"# * A button to start work and log stuff in a separate thread\n"
"# * A button to log something from the main thread\n"
"# * A button to clear the log window\n"
"#\n"
"class Window(QtWidgets.QWidget):\n"
"\n"
"    COLORS = {\n"
"        logging.DEBUG: 'black',\n"
"        logging.INFO: 'blue',\n"
"        logging.WARNING: 'orange',\n"
"        logging.ERROR: 'red',\n"
"        logging.CRITICAL: 'purple',\n"
"    }\n"
"\n"
"    def __init__(self, app):\n"
"        super().__init__()\n"
"        self.app = app\n"
"        self.textedit = te = QtWidgets.QPlainTextEdit(self)\n"
"        # Set whatever the default monospace font is for the platform\n"
"        f = QtGui.QFont('nosuchfont')\n"
"        if hasattr(f, 'Monospace'):\n"
"            f.setStyleHint(f.Monospace)\n"
"        else:\n"
"            f.setStyleHint(f.StyleHint.Monospace)  # for Qt6\n"
"        te.setFont(f)\n"
"        te.setReadOnly(True)\n"
"        PB = QtWidgets.QPushButton\n"
"        self.work_button = PB('Start background work', self)\n"
"        self.log_button = PB('Log a message at a random level', self)\n"
"        self.clear_button = PB('Clear log window', self)\n"
"        self.handler = h = QtHandler(self.update_status)\n"
"        # Remember to use qThreadName rather than threadName in the format "
"string.\n"
"        fs = '%(asctime)s %(qThreadName)-12s %(levelname)-8s %(message)s'\n"
"        formatter = logging.Formatter(fs)\n"
"        h.setFormatter(formatter)\n"
"        logger.addHandler(h)\n"
"        # Set up to terminate the QThread when we exit\n"
"        app.aboutToQuit.connect(self.force_quit)\n"
"\n"
"        # Lay out all the widgets\n"
"        layout = QtWidgets.QVBoxLayout(self)\n"
"        layout.addWidget(te)\n"
"        layout.addWidget(self.work_button)\n"
"        layout.addWidget(self.log_button)\n"
"        layout.addWidget(self.clear_button)\n"
"        self.setFixedSize(900, 400)\n"
"\n"
"        # Connect the non-worker slots and signals\n"
"        self.log_button.clicked.connect(self.manual_update)\n"
"        self.clear_button.clicked.connect(self.clear_display)\n"
"\n"
"        # Start a new worker thread and connect the slots for the worker\n"
"        self.start_thread()\n"
"        self.work_button.clicked.connect(self.worker.start)\n"
"        # Once started, the button should be disabled\n"
"        self.work_button.clicked.connect(lambda : self.work_button."
"setEnabled(False))\n"
"\n"
"    def start_thread(self):\n"
"        self.worker = Worker()\n"
"        self.worker_thread = QtCore.QThread()\n"
"        self.worker.setObjectName('Worker')\n"
"        self.worker_thread.setObjectName('WorkerThread')  # for qThreadName\n"
"        self.worker.moveToThread(self.worker_thread)\n"
"        # This will start an event loop in the worker thread\n"
"        self.worker_thread.start()\n"
"\n"
"    def kill_thread(self):\n"
"        # Just tell the worker to stop, then tell it to quit and wait for "
"that\n"
"        # to happen\n"
"        self.worker_thread.requestInterruption()\n"
"        if self.worker_thread.isRunning():\n"
"            self.worker_thread.quit()\n"
"            self.worker_thread.wait()\n"
"        else:\n"
"            print('worker has already exited.')\n"
"\n"
"    def force_quit(self):\n"
"        # For use when the window is closed\n"
"        if self.worker_thread.isRunning():\n"
"            self.kill_thread()\n"
"\n"
"    # The functions below update the UI and run in the main thread because\n"
"    # that's where the slots are set up\n"
"\n"
"    @Slot(str, logging.LogRecord)\n"
"    def update_status(self, status, record):\n"
"        color = self.COLORS.get(record.levelno, 'black')\n"
"        s = '<pre><font color=\"%s\">%s</font></pre>' % (color, status)\n"
"        self.textedit.appendHtml(s)\n"
"\n"
"    @Slot()\n"
"    def manual_update(self):\n"
"        # This function uses the formatted message passed in, but also uses\n"
"        # information from the record to format the message in an "
"appropriate\n"
"        # color according to its severity (level).\n"
"        level = random.choice(LEVELS)\n"
"        extra = {'qThreadName': ctname() }\n"
"        logger.log(level, 'Manually logged!', extra=extra)\n"
"\n"
"    @Slot()\n"
"    def clear_display(self):\n"
"        self.textedit.clear()\n"
"\n"
"\n"
"def main():\n"
"    QtCore.QThread.currentThread().setObjectName('MainThread')\n"
"    logging.getLogger().setLevel(logging.DEBUG)\n"
"    app = QtWidgets.QApplication(sys.argv)\n"
"    example = Window(app)\n"
"    example.show()\n"
"    if hasattr(app, 'exec'):\n"
"        rc = app.exec()\n"
"    else:\n"
"        rc = app.exec_()\n"
"    sys.exit(rc)\n"
"\n"
"if __name__=='__main__':\n"
"    main()"
msgstr ""
"import datetime\n"
"import logging\n"
"import random\n"
"import sys\n"
"import time\n"
"\n"
"# Tratar las pequeñas diferencias entre los distintos paquetes Qt\n"
"try:\n"
"    from PySide6 import QtCore, QtGui, QtWidgets\n"
"    Signal = QtCore.Signal\n"
"    Slot = QtCore.Slot\n"
"except ImportError:\n"
"    try:\n"
"        from PyQt6 import QtCore, QtGui, QtWidgets\n"
"        Signal = QtCore.pyqtSignal\n"
"        Slot = QtCore.pyqtSlot\n"
"    except ImportError:\n"
"        try:\n"
"            from PySide2 import QtCore, QtGui, QtWidgets\n"
"            Signal = QtCore.Signal\n"
"            Slot = QtCore.Slot\n"
"        except ImportError:\n"
"            from PyQt5 import QtCore, QtGui, QtWidgets\n"
"            Signal = QtCore.pyqtSignal\n"
"            Slot = QtCore.pyqtSlot\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"\n"
"#\n"
"#  Las señales necesitan estar contenidas en un QObject o subclase para ser\n"
"# inicializadas correctamente.\n"
"#\n"
"# initialized.\n"
"#\n"
"class Signaller(QtCore.QObject):\n"
"    signal = Signal(str, logging.LogRecord)\n"
"\n"
"#\n"
"# Se supone que la salida a una GUI Qt sólo se produce en el hilo principal. "
"Por lo tanto, este\n"
"# está diseñado para tomar una función de ranura que está configurada para "
"ejecutarse en el hilo # principal.\n"
"# En este ejemplo, la función toma un argumento de cadena que es un\n"
"# mensaje de registro formateado, y el registro de registro que lo generó. "
"La cadena\n"
"# formateada sólo es una conveniencia - usted podría formatear una cadena "
"para la salida de la manera\n"
"# que quieras en la propia función de la ranura..\n"
"#\n"
"# Usted especifica la función de ranura para hacer cualquier actualización # "
"de GUI que desee. El manejador\n"
"# no sabe o se preocupa por elementos específicos de la interfaz de "
"usuario.\n"
"#\n"
"class QtHandler(logging.Handler):\n"
"    def __init__(self, slotfunc, *args, **kwargs):\n"
"        super().__init__(*args, **kwargs)\n"
"        self.signaller = Signaller()\n"
"        self.signaller.signal.connect(slotfunc)\n"
"\n"
"    def emit(self, record):\n"
"        s = self.format(record)\n"
"        self.signaller.signal.emit(s, record)\n"
"\n"
"#\n"
"# Este ejemplo usa QThreads, lo que significa que los hilos a nivel de "
"Python\n"
"# se llaman algo así como \"Dummy-1\". La siguiente función obtiene el "
"nombre Qt del\n"
"# hilo actual.\n"
"#\n"
"def ctname():\n"
"    return QtCore.QThread.currentThread().objectName()\n"
"\n"
"\n"
"#\n"
"# Usado para generar niveles aleatorios para el logging\n"
"#\n"
"LEVELS = (logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR,\n"
"          logging.CRITICAL)\n"
"\n"
"#\n"
"#  Esta clase de trabajo representa el trabajo que se realiza en un hilo "
"separado del hilo\n"
"# principal. La forma en que el hilo se pone en marcha para hacer el trabajo "
"es a través de una pulsación de botón\n"
"# que se conecta a una ranura en el trabajador..\n"
"#\n"
"# Como el valor por defecto de threadName en el LogRecord no es muy útil, "
"añadimos\n"
"# un qThreadName que contenga el nombre del QThread como se ha calculado "
"anteriormente, y pasamos ese\n"
"# valor en un diccionario \"extra\" que se usa para actualizar el LogRecord "
"con el\n"
"# QThread name.\n"
"#\n"
"# Este worker de ejemplo sólo emite mensajes secuencialmente, intercalados "
"con\n"
"# retrasos aleatorios del orden de unos pocos segundos.\n"
"#\n"
"class Worker(QtCore.QObject):\n"
"    @Slot()\n"
"    def start(self):\n"
"        extra = {'qThreadName': ctname() }\n"
"        logger.debug('Started work', extra=extra)\n"
"        i = 1\n"
"        # Deje correr el hilo hasta que se interrumpa. Esto permite una "
"limpieza razonable\n"
"        # de la terminación de hilo.\n"
"        while not QtCore.QThread.currentThread().isInterruptionRequested():\n"
"            delay = 0.5 + random.random() * 2\n"
"            time.sleep(delay)\n"
"            try:\n"
"                if random.random() < 0.1:\n"
"                    raise ValueError('Exception raised: %d' % i)\n"
"                else:\n"
"                    level = random.choice(LEVELS)\n"
"                    logger.log(level, 'Message after delay of %3.1f: %d', "
"delay, i, extra=extra)\n"
"            except ValueError as e:\n"
"                logger.exception('Failed: %s', e, extra=extra)\n"
"            i += 1\n"
"\n"
"#\n"
"# Implementar una interfaz de usuario sencilla para este ejemplo de libro de "
"recetas. Contiene:\n"
"#\n"
"# * Una ventana de edición de texto de sólo lectura que contiene mensajes de "
"registro formateados.\n"
"# * Un botón para empezar a trabajar y registrar cosas en un hilo separado\n"
"# * Un botón para registrar algo desde el hilo principal\n"
"# * Un botón para borrar la ventana de registro\n"
"#\n"
"class Window(QtWidgets.QWidget):\n"
"\n"
"    COLORS = {\n"
"        logging.DEBUG: 'black',\n"
"        logging.INFO: 'blue',\n"
"        logging.WARNING: 'orange',\n"
"        logging.ERROR: 'red',\n"
"        logging.CRITICAL: 'purple',\n"
"    }\n"
"\n"
"    def __init__(self, app):\n"
"        super().__init__()\n"
"        self.app = app\n"
"        self.textedit = te = QtWidgets.QPlainTextEdit(self)\n"
"        # Set whatever the default monospace font is for the platform\n"
"        f = QtGui.QFont('nosuchfont')\n"
"        if hasattr(f, 'Monospace'):\n"
"            f.setStyleHint(f.Monospace)\n"
"        else:\n"
"            f.setStyleHint(f.StyleHint.Monospace)  # for Qt6\n"
"        te.setFont(f)\n"
"        te.setReadOnly(True)\n"
"        PB = QtWidgets.QPushButton\n"
"        self.work_button = PB('Start background work', self)\n"
"        self.log_button = PB('Log a message at a random level', self)\n"
"        self.clear_button = PB('Clear log window', self)\n"
"        self.handler = h = QtHandler(self.update_status)\n"
"         # Recuerda usar qThreadName en lugar de threadName en la cadena de "
"formato.\n"
"        fs = '%(asctime)s %(qThreadName)-12s %(levelname)-8s %(message)s'\n"
"        formatter = logging.Formatter(fs)\n"
"        h.setFormatter(formatter)\n"
"        logger.addHandler(h)\n"
"        # Configurar para terminar el QThread cuando salgamos\n"
"        app.aboutToQuit.connect(self.force_quit)\n"
"\n"
"        # Lay out all the widgets\n"
"        layout = QtWidgets.QVBoxLayout(self)\n"
"        layout.addWidget(te)\n"
"        layout.addWidget(self.work_button)\n"
"        layout.addWidget(self.log_button)\n"
"        layout.addWidget(self.clear_button)\n"
"        self.setFixedSize(900, 400)\n"
"\n"
"         # Conecta las ranuras y señales que no sean de trabajo\n"
"        self.log_button.clicked.connect(self.manual_update)\n"
"        self.clear_button.clicked.connect(self.clear_display)\n"
"\n"
"        # Iniciar un nuevo hilo de trabajo y conectar las ranuras para el "
"trabajador\n"
"        self.start_thread()\n"
"        self.work_button.clicked.connect(self.worker.start)\n"
"        # Once started, the button should be disabled\n"
"        self.work_button.clicked.connect(lambda : self.work_button."
"setEnabled(False))\n"
"\n"
"    def start_thread(self):\n"
"        self.worker = Worker()\n"
"        self.worker_thread = QtCore.QThread()\n"
"        self.worker.setObjectName('Worker')\n"
"        self.worker_thread.setObjectName('WorkerThread')  # for qThreadName\n"
"        self.worker.moveToThread(self.worker_thread)\n"
"        # This will start an event loop in the worker thread\n"
"        self.worker_thread.start()\n"
"\n"
"    def kill_thread(self):\n"
"        # Simplemente dile al trabajador que pare, luego dile que salga y "
"espera a que eso\n"
"        # ocurra\n"
"        self.worker_thread.requestInterruption()\n"
"        if self.worker_thread.isRunning():\n"
"            self.worker_thread.quit()\n"
"            self.worker_thread.wait()\n"
"        else:\n"
"            print('worker has already exited.')\n"
"\n"
"    def force_quit(self):\n"
"        # For use when the window is closed\n"
"        if self.worker_thread.isRunning():\n"
"            self.kill_thread()\n"
"\n"
"     # Las funciones de abajo actualizan la UI y se ejecutan en el hilo "
"principal porque\n"
"     # ahí es donde se configuran las ranuras\n"
"\n"
"    @Slot(str, logging.LogRecord)\n"
"    def update_status(self, status, record):\n"
"        color = self.COLORS.get(record.levelno, 'black')\n"
"        s = '<pre><font color=\"%s\">%s</font></pre>' % (color, status)\n"
"        self.textedit.appendHtml(s)\n"
"\n"
"    @Slot()\n"
"    def manual_update(self):\n"
"        # Esta función usa el mensaje formateado pasado, pero también usa\n"
"        # información del registro para formatear el mensaje en un\n"
"        # color apropiado según su gravedad (nivel).\n"
"        level = random.choice(LEVELS)\n"
"        extra = {'qThreadName': ctname() }\n"
"        logger.log(level, 'Manually logged!', extra=extra)\n"
"\n"
"    @Slot()\n"
"    def clear_display(self):\n"
"        self.textedit.clear()\n"
"\n"
"\n"
"def main():\n"
"    QtCore.QThread.currentThread().setObjectName('MainThread')\n"
"    logging.getLogger().setLevel(logging.DEBUG)\n"
"    app = QtWidgets.QApplication(sys.argv)\n"
"    example = Window(app)\n"
"    example.show()\n"
"    if hasattr(app, 'exec'):\n"
"        rc = app.exec()\n"
"    else:\n"
"        rc = app.exec_()\n"
"    sys.exit(rc)\n"
"\n"
"if __name__=='__main__':\n"
"    main()"

#: ../../howto/logging-cookbook.rst:3842
msgid "Logging to syslog with RFC5424 support"
msgstr "Registro en syslog compatible con RFC5424"

#: ../../howto/logging-cookbook.rst:3844
msgid ""
"Although :rfc:`5424` dates from 2009, most syslog servers are configured by "
"default to use the older :rfc:`3164`, which hails from 2001. When "
"``logging`` was added to Python in 2003, it supported the earlier (and only "
"existing) protocol at the time. Since RFC5424 came out, as there has not "
"been widespread deployment of it in syslog servers, the :class:`~logging."
"handlers.SysLogHandler` functionality has not been updated."
msgstr ""
"Aunque :rfc:`5424` data de 2009, la mayoría de los servidores syslog están "
"configurados por defecto para utilizar el antiguo :rfc:`3164`, que data de "
"2001. Cuando ``logging`` se añadió a Python en 2003, soportaba el protocolo "
"anterior (y el único existente) en ese momento. Desde que salió el RFC5424, "
"como no ha habido un despliegue generalizado del mismo en los servidores "
"syslog, la funcionalidad de :class:`~logging.handlers.SysLogHandler` no se "
"ha actualizado."

#: ../../howto/logging-cookbook.rst:3851
msgid ""
"RFC 5424 contains some useful features such as support for structured data, "
"and if you need to be able to log to a syslog server with support for it, "
"you can do so with a subclassed handler which looks something like this::"
msgstr ""
"RFC 5424 contiene algunas características útiles, como el soporte para datos "
"estructurados, y si usted ha de ser capaz de registrar a un servidor syslog "
"con soporte para ello, puede hacerlo con un controlador subclase que se "
"parece a esto::"

#: ../../howto/logging-cookbook.rst:3855
msgid ""
"import datetime\n"
"import logging.handlers\n"
"import re\n"
"import socket\n"
"import time\n"
"\n"
"class SysLogHandler5424(logging.handlers.SysLogHandler):\n"
"\n"
"    tz_offset = re.compile(r'([+-]\\d{2})(\\d{2})$')\n"
"    escaped = re.compile(r'([\\]\"\\\\])')\n"
"\n"
"    def __init__(self, *args, **kwargs):\n"
"        self.msgid = kwargs.pop('msgid', None)\n"
"        self.appname = kwargs.pop('appname', None)\n"
"        super().__init__(*args, **kwargs)\n"
"\n"
"    def format(self, record):\n"
"        version = 1\n"
"        asctime = datetime.datetime.fromtimestamp(record.created)."
"isoformat()\n"
"        m = self.tz_offset.match(time.strftime('%z'))\n"
"        has_offset = False\n"
"        if m and time.timezone:\n"
"            hrs, mins = m.groups()\n"
"            if int(hrs) or int(mins):\n"
"                has_offset = True\n"
"        if not has_offset:\n"
"            asctime += 'Z'\n"
"        else:\n"
"            asctime += f'{hrs}:{mins}'\n"
"        try:\n"
"            hostname = socket.gethostname()\n"
"        except Exception:\n"
"            hostname = '-'\n"
"        appname = self.appname or '-'\n"
"        procid = record.process\n"
"        msgid = '-'\n"
"        msg = super().format(record)\n"
"        sdata = '-'\n"
"        if hasattr(record, 'structured_data'):\n"
"            sd = record.structured_data\n"
"            # This should be a dict where the keys are SD-ID and the value "
"is a\n"
"            # dict mapping PARAM-NAME to PARAM-VALUE (refer to the RFC for "
"what these\n"
"            # mean)\n"
"            # There's no error checking here - it's purely for illustration, "
"and you\n"
"            # can adapt this code for use in production environments\n"
"            parts = []\n"
"\n"
"            def replacer(m):\n"
"                g = m.groups()\n"
"                return '\\\\' + g[0]\n"
"\n"
"            for sdid, dv in sd.items():\n"
"                part = f'[{sdid}'\n"
"                for k, v in dv.items():\n"
"                    s = str(v)\n"
"                    s = self.escaped.sub(replacer, s)\n"
"                    part += f' {k}=\"{s}\"'\n"
"                part += ']'\n"
"                parts.append(part)\n"
"            sdata = ''.join(parts)\n"
"        return f'{version} {asctime} {hostname} {appname} {procid} {msgid} "
"{sdata} {msg}'"
msgstr ""
"import datetime\n"
"import logging.handlers\n"
"import re\n"
"import socket\n"
"import time\n"
"\n"
"class SysLogHandler5424(logging.handlers.SysLogHandler):\n"
"\n"
"    tz_offset = re.compile(r'([+-]\\d{2})(\\d{2})$')\n"
"    escaped = re.compile(r'([\\]\"\\\\])')\n"
"\n"
"    def __init__(self, *args, **kwargs):\n"
"        self.msgid = kwargs.pop('msgid', None)\n"
"        self.appname = kwargs.pop('appname', None)\n"
"        super().__init__(*args, **kwargs)\n"
"\n"
"    def format(self, record):\n"
"        version = 1\n"
"        asctime = datetime.datetime.fromtimestamp(record.created)."
"isoformat()\n"
"        m = self.tz_offset.match(time.strftime('%z'))\n"
"        has_offset = False\n"
"        if m and time.timezone:\n"
"            hrs, mins = m.groups()\n"
"            if int(hrs) or int(mins):\n"
"                has_offset = True\n"
"        if not has_offset:\n"
"            asctime += 'Z'\n"
"        else:\n"
"            asctime += f'{hrs}:{mins}'\n"
"        try:\n"
"            hostname = socket.gethostname()\n"
"        except Exception:\n"
"            hostname = '-'\n"
"        appname = self.appname or '-'\n"
"        procid = record.process\n"
"        msgid = '-'\n"
"        msg = super().format(record)\n"
"        sdata = '-'\n"
"        if hasattr(record, 'structured_data'):\n"
"            sd = record.structured_data\n"
"            # Este debería ser un dict donde las claves son SD-ID y el valor "
"es un\n"
"            # dict mapeando PARAM-NAME a PARAM-VALUE (consultar el RFC para "
"saber cuáles son estos\n"
"            # significados)\n"
"            # No hay verificación de errores aquí, es puramente ilustrativo, "
"y\n"
"            # puede adaptar este código para usarlo en entornos de "
"producción\n"
"            parts = []\n"
"\n"
"            def replacer(m):\n"
"                g = m.groups()\n"
"                return '\\\\' + g[0]\n"
"\n"
"            for sdid, dv in sd.items():\n"
"                part = f'[{sdid}'\n"
"                for k, v in dv.items():\n"
"                    s = str(v)\n"
"                    s = self.escaped.sub(replacer, s)\n"
"                    part += f' {k}=\"{s}\"'\n"
"                part += ']'\n"
"                parts.append(part)\n"
"            sdata = ''.join(parts)\n"
"        return f'{version} {asctime} {hostname} {appname} {procid} {msgid} "
"{sdata} {msg}'"

#: ../../howto/logging-cookbook.rst:3917
msgid ""
"You'll need to be familiar with RFC 5424 to fully understand the above code, "
"and it may be that you have slightly different needs (e.g. for how you pass "
"structural data to the log). Nevertheless, the above should be adaptable to "
"your speciric needs. With the above handler, you'd pass structured data "
"using something like this::"
msgstr ""
"Tendrá que estar familiarizado con RFC 5424 para entender completamente el "
"código anterior, y puede ser que tenga necesidades ligeramente diferentes "
"(por ejemplo, para cómo pasar datos estructurales al registro). No obstante, "
"lo anterior debería poder adaptarse a sus necesidades específicas. Con el "
"manejador anterior, usted pasaría datos estructurados usando algo como esto::"

#: ../../howto/logging-cookbook.rst:3922
msgid ""
"sd = {\n"
"    'foo@12345': {'bar': 'baz', 'baz': 'bozz', 'fizz': r'buzz'},\n"
"    'foo@54321': {'rab': 'baz', 'zab': 'bozz', 'zzif': r'buzz'}\n"
"}\n"
"extra = {'structured_data': sd}\n"
"i = 1\n"
"logger.debug('Message %d', i, extra=extra)"
msgstr ""
"sd = {\n"
"    'foo@12345': {'bar': 'baz', 'baz': 'bozz', 'fizz': r'buzz'},\n"
"    'foo@54321': {'rab': 'baz', 'zab': 'bozz', 'zzif': r'buzz'}\n"
"}\n"
"extra = {'structured_data': sd}\n"
"i = 1\n"
"logger.debug('Message %d', i, extra=extra)"

#: ../../howto/logging-cookbook.rst:3931
msgid "How to treat a logger like an output stream"
msgstr "Cómo tratar un logger como un flujo de salida"

#: ../../howto/logging-cookbook.rst:3933
msgid ""
"Sometimes, you need to interface to a third-party API which expects a file-"
"like object to write to, but you want to direct the API's output to a "
"logger. You can do this using a class which wraps a logger with a file-like "
"API. Here's a short script illustrating such a class:"
msgstr ""
"A veces, es necesario interactuar con una API de terceros que espera un "
"objeto de tipo archivo para escribir, pero desea dirigir la salida de la API "
"a un registrador. Puedes hacer esto usando una clase que envuelve un logger "
"con una API tipo archivo. Aquí tienes un pequeño script que ilustra una "
"clase de este tipo:"

#: ../../howto/logging-cookbook.rst:3938
msgid ""
"import logging\n"
"\n"
"class LoggerWriter:\n"
"    def __init__(self, logger, level):\n"
"        self.logger = logger\n"
"        self.level = level\n"
"\n"
"    def write(self, message):\n"
"        if message != '\\n':  # avoid printing bare newlines, if you like\n"
"            self.logger.log(self.level, message)\n"
"\n"
"    def flush(self):\n"
"        # doesn't actually do anything, but might be expected of a file-"
"like\n"
"        # object - so optional depending on your situation\n"
"        pass\n"
"\n"
"    def close(self):\n"
"        # doesn't actually do anything, but might be expected of a file-"
"like\n"
"        # object - so optional depending on your situation. You might want\n"
"        # to set a flag so that later calls to write raise an exception\n"
"        pass\n"
"\n"
"def main():\n"
"    logging.basicConfig(level=logging.DEBUG)\n"
"    logger = logging.getLogger('demo')\n"
"    info_fp = LoggerWriter(logger, logging.INFO)\n"
"    debug_fp = LoggerWriter(logger, logging.DEBUG)\n"
"    print('An INFO message', file=info_fp)\n"
"    print('A DEBUG message', file=debug_fp)\n"
"\n"
"if __name__ == \"__main__\":\n"
"    main()"
msgstr ""
"import logging\n"
"\n"
"class LoggerWriter:\n"
"    def __init__(self, logger, level):\n"
"        self.logger = logger\n"
"        self.level = level\n"
"\n"
"    def write(self, message):\n"
"        if message != '\\n':  # evite imprimir nuevas líneas desnudas, si lo "
"desea\n"
"            self.logger.log(self.level, message)\n"
"\n"
"    def flush(self):\n"
"        # en realidad no hace nada, pero podría esperarse de un archivo "
"similar a\n"
"        # objet - tan opcional dependiendo de su situación\n"
"pass\n"
"\n"
"    def close(self):\n"
"        # en realidad no hace nada, pero podría esperarse de un archivo "
"similar a\n"
"        # object - tan opcional dependiendo de tu situación. Tal vez "
"quieras\n"
"        # establecer un indicador para que las llamadas posteriores a write "
"generen una excepción\n"
"        pass\n"
"\n"
"def main():\n"
"    logging.basicConfig(level=logging.DEBUG)\n"
"    logger = logging.getLogger('demo')\n"
"    info_fp = LoggerWriter(logger, logging.INFO)\n"
"    debug_fp = LoggerWriter(logger, logging.DEBUG)\n"
"    print('An INFO message', file=info_fp)\n"
"    print('A DEBUG message', file=debug_fp)\n"
"\n"
"if __name__ == \"__main__\":\n"
"    main()"

#: ../../howto/logging-cookbook.rst:3973
msgid "When this script is run, it prints"
msgstr "Cuando se ejecuta este script, imprime"

#: ../../howto/logging-cookbook.rst:3975
msgid ""
"INFO:demo:An INFO message\n"
"DEBUG:demo:A DEBUG message"
msgstr ""
"INFO:demo:An INFO message\n"
"DEBUG:demo:A DEBUG message"

#: ../../howto/logging-cookbook.rst:3980
msgid ""
"You could also use ``LoggerWriter`` to redirect ``sys.stdout`` and ``sys."
"stderr`` by doing something like this:"
msgstr ""
"También podría utilizar ``LoggerWriter`` para redirigir ``sys.stdout`` y "
"``sys.stderr`` haciendo algo como esto:"

#: ../../howto/logging-cookbook.rst:3983
msgid ""
"import sys\n"
"\n"
"sys.stdout = LoggerWriter(logger, logging.INFO)\n"
"sys.stderr = LoggerWriter(logger, logging.WARNING)"
msgstr ""
"import sys\n"
"\n"
"sys.stdout = LoggerWriter(logger, logging.INFO)\n"
"sys.stderr = LoggerWriter(logger, logging.WARNING)"

#: ../../howto/logging-cookbook.rst:3990
msgid ""
"You should do this *after* configuring logging for your needs. In the above "
"example, the :func:`~logging.basicConfig` call does this (using the ``sys."
"stderr`` value *before* it is overwritten by a ``LoggerWriter`` instance). "
"Then, you'd get this kind of result:"
msgstr ""
"Debería hacer esto *después* de configurar el registro para sus necesidades. "
"En el ejemplo anterior, la llamada a :func:`~logging.basicConfig` hace esto "
"(utilizando el valor de ``sys.stderr`` *antes* de que sea sobrescrito por "
"una instancia de ``LoggerWriter`` ). Entonces, obtendrías este tipo de "
"resultado:"

#: ../../howto/logging-cookbook.rst:3995
msgid ""
">>> print('Foo')\n"
"INFO:demo:Foo\n"
">>> print('Bar', file=sys.stderr)\n"
"WARNING:demo:Bar\n"
">>>"
msgstr ""
">>> print('Foo')\n"
"INFO:demo:Foo\n"
">>> print('Bar', file=sys.stderr)\n"
"WARNING:demo:Bar\n"
">>>"

#: ../../howto/logging-cookbook.rst:4003
msgid ""
"Of course, the examples above show output according to the format used by :"
"func:`~logging.basicConfig`, but you can use a different formatter when you "
"configure logging."
msgstr ""
"Por supuesto, los ejemplos anteriores muestran la salida según el formato "
"utilizado por :func:`~logging.basicConfig`, pero puede utilizar un "
"formateador diferente cuando configure el registro."

#: ../../howto/logging-cookbook.rst:4007
msgid ""
"Note that with the above scheme, you are somewhat at the mercy of buffering "
"and the sequence of write calls which you are intercepting. For example, "
"with the definition of ``LoggerWriter`` above, if you have the snippet"
msgstr ""
"Ten en cuenta que con el esquema anterior, estás un poco a merced del "
"buffering y de la secuencia de llamadas de escritura que estás "
"interceptando. Por ejemplo, con la definición de ``LoggerWriter`` anterior, "
"si tienes el fragmento de código"

#: ../../howto/logging-cookbook.rst:4011
msgid ""
"sys.stderr = LoggerWriter(logger, logging.WARNING)\n"
"1 / 0"
msgstr ""
"sys.stderr = LoggerWriter(logger, logging.WARNING)\n"
"1 / 0"

#: ../../howto/logging-cookbook.rst:4016
msgid "then running the script results in"
msgstr "la ejecución del script da como resultado"

#: ../../howto/logging-cookbook.rst:4018
msgid ""
"WARNING:demo:Traceback (most recent call last):\n"
"\n"
"WARNING:demo:  File \"/home/runner/cookbook-loggerwriter/test.py\", line 53, "
"in <module>\n"
"\n"
"WARNING:demo:\n"
"WARNING:demo:main()\n"
"WARNING:demo:  File \"/home/runner/cookbook-loggerwriter/test.py\", line 49, "
"in main\n"
"\n"
"WARNING:demo:\n"
"WARNING:demo:1 / 0\n"
"WARNING:demo:ZeroDivisionError\n"
"WARNING:demo::\n"
"WARNING:demo:division by zero"
msgstr ""
"WARNING:demo:Traceback (most recent call last):\n"
"\n"
"WARNING:demo:  File \"/home/runner/cookbook-loggerwriter/test.py\", line 53, "
"in <module>\n"
"\n"
"WARNING:demo:\n"
"WARNING:demo:main()\n"
"WARNING:demo:  File \"/home/runner/cookbook-loggerwriter/test.py\", line 49, "
"in main\n"
"\n"
"WARNING:demo:\n"
"WARNING:demo:1 / 0\n"
"WARNING:demo:ZeroDivisionError\n"
"WARNING:demo::\n"
"WARNING:demo:division by zero"

#: ../../howto/logging-cookbook.rst:4034
msgid ""
"As you can see, this output isn't ideal. That's because the underlying code "
"which writes to ``sys.stderr`` makes multiple writes, each of which results "
"in a separate logged line (for example, the last three lines above). To get "
"around this problem, you need to buffer things and only output log lines "
"when newlines are seen. Let's use a slightly better implementation of "
"``LoggerWriter``:"
msgstr ""
"Como puedes ver, esta salida no es ideal. Esto se debe a que el código "
"subyacente que escribe en ``sys.stderr`` realiza múltiples escrituras, cada "
"una de las cuales da lugar a una línea de registro independiente (por "
"ejemplo, las tres últimas líneas anteriores). Para evitar este problema, es "
"necesario almacenar las cosas y sólo mostrar las líneas de registro cuando "
"se ven nuevas líneas. Usemos una implementación ligeramente mejor de "
"``LoggerWriter``:"

#: ../../howto/logging-cookbook.rst:4040
msgid ""
"class BufferingLoggerWriter(LoggerWriter):\n"
"    def __init__(self, logger, level):\n"
"        super().__init__(logger, level)\n"
"        self.buffer = ''\n"
"\n"
"    def write(self, message):\n"
"        if '\\n' not in message:\n"
"            self.buffer += message\n"
"        else:\n"
"            parts = message.split('\\n')\n"
"            if self.buffer:\n"
"                s = self.buffer + parts.pop(0)\n"
"                self.logger.log(self.level, s)\n"
"            self.buffer = parts.pop()\n"
"            for part in parts:\n"
"                self.logger.log(self.level, part)"
msgstr ""
"class BufferingLoggerWriter(LoggerWriter):\n"
"    def __init__(self, logger, level):\n"
"        super().__init__(logger, level)\n"
"        self.buffer = ''\n"
"\n"
"    def write(self, message):\n"
"        if '\\n' not in message:\n"
"            self.buffer += message\n"
"        else:\n"
"            parts = message.split('\\n')\n"
"            if self.buffer:\n"
"                s = self.buffer + parts.pop(0)\n"
"                self.logger.log(self.level, s)\n"
"            self.buffer = parts.pop()\n"
"            for part in parts:\n"
"                self.logger.log(self.level, part)"

#: ../../howto/logging-cookbook.rst:4059
msgid ""
"This just buffers up stuff until a newline is seen, and then logs complete "
"lines. With this approach, you get better output:"
msgstr ""
"Esto sólo almacena cosas hasta que se ve una nueva línea, y luego registra "
"las líneas completas. Con este enfoque, se obtiene una mejor salida:"

#: ../../howto/logging-cookbook.rst:4062
msgid ""
"WARNING:demo:Traceback (most recent call last):\n"
"WARNING:demo:  File \"/home/runner/cookbook-loggerwriter/main.py\", line 55, "
"in <module>\n"
"WARNING:demo:    main()\n"
"WARNING:demo:  File \"/home/runner/cookbook-loggerwriter/main.py\", line 52, "
"in main\n"
"WARNING:demo:    1/0\n"
"WARNING:demo:ZeroDivisionError: division by zero"
msgstr ""
"WARNING:demo:Traceback (most recent call last):\n"
"WARNING:demo:  File \"/home/runner/cookbook-loggerwriter/main.py\", line 55, "
"in <module>\n"
"WARNING:demo:    main()\n"
"WARNING:demo:  File \"/home/runner/cookbook-loggerwriter/main.py\", line 52, "
"in main\n"
"WARNING:demo:    1/0\n"
"WARNING:demo:ZeroDivisionError: division by zero"

#: ../../howto/logging-cookbook.rst:4075
msgid "Patterns to avoid"
msgstr "Patrones a evitar"

#: ../../howto/logging-cookbook.rst:4077
msgid ""
"Although the preceding sections have described ways of doing things you "
"might need to do or deal with, it is worth mentioning some usage patterns "
"which are *unhelpful*, and which should therefore be avoided in most cases. "
"The following sections are in no particular order."
msgstr ""
"Aunque en las secciones anteriores se han descrito formas de hacer cosas que "
"puede que necesite hacer o tratar, merece la pena mencionar algunos patrones "
"de uso que son *inútiles* y que, por tanto, deberían evitarse en la mayoría "
"de los casos. Las siguientes secciones no siguen ningún orden en particular."

#: ../../howto/logging-cookbook.rst:4083
msgid "Opening the same log file multiple times"
msgstr "Abrir varias veces el mismo archivo de registro"

#: ../../howto/logging-cookbook.rst:4085
msgid ""
"On Windows, you will generally not be able to open the same file multiple "
"times as this will lead to a \"file is in use by another process\" error. "
"However, on POSIX platforms you'll not get any errors if you open the same "
"file multiple times. This could be done accidentally, for example by:"
msgstr ""
"En Windows, por lo general, no podrá abrir el mismo archivo varias veces, ya "
"que se producirá un error del tipo \"el archivo está siendo utilizado por "
"otro proceso\". Sin embargo, en plataformas POSIX no obtendrá ningún error "
"si abre el mismo fichero varias veces. Esto podría hacerse accidentalmente, "
"por ejemplo por:"

#: ../../howto/logging-cookbook.rst:4090
msgid ""
"Adding a file handler more than once which references the same file (e.g. by "
"a copy/paste/forget-to-change error)."
msgstr ""
"Añadir más de una vez un manejador de fichero que haga referencia al mismo "
"fichero (por ejemplo, por un error de copiar/pegar/olvidar-cambiar)."

#: ../../howto/logging-cookbook.rst:4093
msgid ""
"Opening two files that look different, as they have different names, but are "
"the same because one is a symbolic link to the other."
msgstr ""
"Abrir dos archivos que parecen diferentes, ya que tienen nombres distintos, "
"pero que son iguales porque uno es un enlace simbólico al otro."

#: ../../howto/logging-cookbook.rst:4096
msgid ""
"Forking a process, following which both parent and child have a reference to "
"the same file. This might be through use of the :mod:`multiprocessing` "
"module, for example."
msgstr ""
"Bifurcación de un proceso, tras lo cual tanto el padre como el hijo tienen "
"una referencia al mismo archivo. Esto puede hacerse, por ejemplo, utilizando "
"el módulo :mod:`multiprocessing`."

#: ../../howto/logging-cookbook.rst:4100
msgid ""
"Opening a file multiple times might *appear* to work most of the time, but "
"can lead to a number of problems in practice:"
msgstr ""
"Abrir un archivo varias veces puede *parecer* que funciona la mayoría de las "
"veces, pero en la práctica puede dar lugar a una serie de problemas:"

#: ../../howto/logging-cookbook.rst:4103
msgid ""
"Logging output can be garbled because multiple threads or processes try to "
"write to the same file. Although logging guards against concurrent use of "
"the same handler instance by multiple threads, there is no such protection "
"if concurrent writes are attempted by two different threads using two "
"different handler instances which happen to point to the same file."
msgstr ""
"La salida del registro puede ser confusa porque varios hilos o procesos "
"intentan escribir en el mismo archivo. Aunque el registro protege contra el "
"uso concurrente de la misma instancia del manejador por múltiples hilos, no "
"hay tal protección si las escrituras concurrentes son intentadas por dos "
"hilos diferentes usando dos instancias diferentes del manejador que apuntan "
"al mismo archivo."

#: ../../howto/logging-cookbook.rst:4109
msgid ""
"An attempt to delete a file (e.g. during file rotation) silently fails, "
"because there is another reference pointing to it. This can lead to "
"confusion and wasted debugging time - log entries end up in unexpected "
"places, or are lost altogether. Or a file that was supposed to be moved "
"remains in place, and grows in size unexpectedly despite size-based rotation "
"being supposedly in place."
msgstr ""
"Un intento de eliminar un archivo (por ejemplo, durante la rotación de "
"archivos) falla silenciosamente, porque hay otra referencia apuntando a él. "
"Esto puede llevar a confusión y a perder tiempo de depuración: las entradas "
"de registro acaban en lugares inesperados o se pierden por completo. O un "
"archivo que se suponía que debía ser movido permanece en su lugar, y crece "
"en tamaño inesperadamente a pesar de que la rotación basada en el tamaño "
"está supuestamente en su lugar."

#: ../../howto/logging-cookbook.rst:4116
msgid ""
"Use the techniques outlined in :ref:`multiple-processes` to circumvent such "
"issues."
msgstr ""
"Utilice las técnicas descritas en :ref:`multiple-processes` para evitar "
"estos problemas."

#: ../../howto/logging-cookbook.rst:4120
msgid "Using loggers as attributes in a class or passing them as parameters"
msgstr ""
"Utilizar registradores como atributos en una clase o pasarlos como parámetros"

#: ../../howto/logging-cookbook.rst:4122
msgid ""
"While there might be unusual cases where you'll need to do this, in general "
"there is no point because loggers are singletons. Code can always access a "
"given logger instance by name using ``logging.getLogger(name)``, so passing "
"instances around and holding them as instance attributes is pointless. Note "
"that in other languages such as Java and C#, loggers are often static class "
"attributes. However, this pattern doesn't make sense in Python, where the "
"module (and not the class) is the unit of software decomposition."
msgstr ""
"Aunque puede haber casos inusuales en los que necesites hacer esto, en "
"general no tiene sentido porque los loggers son singletons. El código "
"siempre puede acceder a una instancia dada del logger por su nombre usando "
"``logging.getLogger(name)``, por lo que pasar instancias y mantenerlas como "
"atributos de instancia no tiene sentido. Ten en cuenta que en otros "
"lenguajes como Java y C#, los loggers son a menudo atributos estáticos de "
"clase. Sin embargo, este patrón no tiene sentido en Python, donde el módulo "
"(y no la clase) es la unidad de descomposición del software."

#: ../../howto/logging-cookbook.rst:4131
msgid ""
"Adding handlers other than :class:`~logging.NullHandler` to a logger in a "
"library"
msgstr ""
"Adición de gestores distintos de :class:`~logging.NullHandler` a un "
"registrador en una biblioteca"

#: ../../howto/logging-cookbook.rst:4133
msgid ""
"Configuring logging by adding handlers, formatters and filters is the "
"responsibility of the application developer, not the library developer. If "
"you are maintaining a library, ensure that you don't add handlers to any of "
"your loggers other than a :class:`~logging.NullHandler` instance."
msgstr ""
"Configurar el registro añadiendo manejadores, formateadores y filtros es "
"responsabilidad del desarrollador de la aplicación, no del desarrollador de "
"la biblioteca. Si mantienes una biblioteca, asegúrate de no añadir "
"manejadores a ninguno de tus registradores que no sea una instancia de :"
"class:`~logging.NullHandler`."

#: ../../howto/logging-cookbook.rst:4139
msgid "Creating a lot of loggers"
msgstr "Crear muchos registradores"

#: ../../howto/logging-cookbook.rst:4141
msgid ""
"Loggers are singletons that are never freed during a script execution, and "
"so creating lots of loggers will use up memory which can't then be freed. "
"Rather than create a logger per e.g. file processed or network connection "
"made, use the :ref:`existing mechanisms <context-info>` for passing "
"contextual information into your logs and restrict the loggers created to "
"those describing areas within your application (generally modules, but "
"occasionally slightly more fine-grained than that)."
msgstr ""
"Los loggers son singletons que nunca se liberan durante la ejecución de un "
"script, por lo que crear muchos loggers consumirá memoria que luego no podrá "
"ser liberada. En lugar de crear un logger por cada archivo procesado o "
"conexión de red realizada, utiliza :ref:`existing mechanisms <context-info>` "
"para pasar información contextual a tus logs y restringe los loggers creados "
"a aquellos que describen áreas dentro de tu aplicación (generalmente "
"módulos, pero ocasionalmente un poco más detallados que eso)."

#: ../../howto/logging-cookbook.rst:4152
msgid "Other resources"
msgstr "Otros recursos"

#: ../../howto/logging-cookbook.rst:4156
msgid "Module :mod:`logging`"
msgstr "Módulo :mod:`logging`"

#: ../../howto/logging-cookbook.rst:4157
msgid "API reference for the logging module."
msgstr "Referencia API para el módulo de registro."

#: ../../howto/logging-cookbook.rst:4159
msgid "Module :mod:`logging.config`"
msgstr "Módulo :mod:`logging.config`"

#: ../../howto/logging-cookbook.rst:4160
msgid "Configuration API for the logging module."
msgstr "API de configuración del módulo de registro."

#: ../../howto/logging-cookbook.rst:4162
msgid "Module :mod:`logging.handlers`"
msgstr "Módulo :mod:`logging.handlers`"

#: ../../howto/logging-cookbook.rst:4163
msgid "Useful handlers included with the logging module."
msgstr "Manejadores útiles incluidos con el módulo de registro."

#: ../../howto/logging-cookbook.rst:4165
msgid ":ref:`Basic Tutorial <logging-basic-tutorial>`"
msgstr ":ref:`Basic Tutorial <logging-basic-tutorial>`"

#: ../../howto/logging-cookbook.rst:4167
msgid ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"
