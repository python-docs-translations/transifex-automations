# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# eulalio barbero espinosa <eulalio@disroot.org>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 14:53+0000\n"
"PO-Revision-Date: 2024-05-11 00:32+0000\n"
"Last-Translator: eulalio barbero espinosa <eulalio@disroot.org>, 2024\n"
"Language-Team: Spanish (Spain) (https://app.transifex.com/python-doc/"
"teams/5390/es_ES/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es_ES\n"
"Plural-Forms: nplurals=3; plural=n == 1 ? 0 : n != 0 && n % 1000000 == 0 ? "
"1 : 2;\n"

#: ../../howto/descriptor.rst:5
msgid "Descriptor Guide"
msgstr "Guía de descriptores"

#: ../../howto/descriptor.rst:0
msgid "Author"
msgstr "Autor"

#: ../../howto/descriptor.rst:7
msgid "Raymond Hettinger"
msgstr "Raymond Hettinger"

#: ../../howto/descriptor.rst:0
msgid "Contact"
msgstr "Contacto"

#: ../../howto/descriptor.rst:8
msgid "<python at rcn dot com>"
msgstr "<python at rcn dot com>"

#: ../../howto/descriptor.rst:11
msgid "Contents"
msgstr "Contenido"

#: ../../howto/descriptor.rst:13
msgid ""
":term:`Descriptors <descriptor>` let objects customize attribute lookup, "
"storage, and deletion."
msgstr ""
":term:`Los descriptores <descriptor>` permiten a los objetos personalizar la "
"búsqueda, el almacenamiento y la eliminación de atributos."

#: ../../howto/descriptor.rst:16
msgid "This guide has four major sections:"
msgstr "Esta guía consta de cuatro secciones principales:"

#: ../../howto/descriptor.rst:18
msgid ""
"The \"primer\" gives a basic overview, moving gently from simple examples, "
"adding one feature at a time.  Start here if you're new to descriptors."
msgstr ""
"El \"manual básico\" ofrece una visión general básica, avanzando suavemente "
"a partir de ejemplos sencillos, añadiendo una característica cada vez.  "
"Empieza por aquí si no conoces los descriptores."

#: ../../howto/descriptor.rst:21
msgid ""
"The second section shows a complete, practical descriptor example.  If you "
"already know the basics, start there."
msgstr ""
"La segunda sección muestra un ejemplo de descriptor completo y práctico.  Si "
"ya conoces los conceptos básicos, empieza por ahí."

#: ../../howto/descriptor.rst:24
msgid ""
"The third section provides a more technical tutorial that goes into the "
"detailed mechanics of how descriptors work.  Most people don't need this "
"level of detail."
msgstr ""
"La tercera sección ofrece un tutorial más técnico que entra en la mecánica "
"detallada del funcionamiento de los descriptores.  La mayoría de la gente no "
"necesita este nivel de detalle."

#: ../../howto/descriptor.rst:28
msgid ""
"The last section has pure Python equivalents for built-in descriptors that "
"are written in C.  Read this if you're curious about how functions turn into "
"bound methods or about the implementation of common tools like :func:"
"`classmethod`, :func:`staticmethod`, :func:`property`, and :term:`__slots__`."
msgstr ""
"La última sección tiene equivalentes en Python puro para los descriptores "
"incorporados que están escritos en C. Lee esto si tienes curiosidad sobre "
"cómo las funciones se convierten en métodos ligados o sobre la "
"implementación de herramientas comunes como :func:`classmethod`, :func:"
"`staticmethod`, :func:`property`, y :term:`__slots__`."

#: ../../howto/descriptor.rst:36
msgid "Primer"
msgstr "Imprimación"

#: ../../howto/descriptor.rst:38
msgid ""
"In this primer, we start with the most basic possible example and then we'll "
"add new capabilities one by one."
msgstr ""
"En este manual, empezaremos con el ejemplo más básico posible y luego iremos "
"añadiendo nuevas funciones una a una."

#: ../../howto/descriptor.rst:43
msgid "Simple example: A descriptor that returns a constant"
msgstr "Ejemplo sencillo: Un descriptor que devuelve una constante"

#: ../../howto/descriptor.rst:45
msgid ""
"The :class:`!Ten` class is a descriptor whose :meth:`~object.__get__` method "
"always returns the constant ``10``:"
msgstr ""
"La clase :class:`!Ten` es un descriptor cuyo método :meth:`~object.__get__` "
"devuelve siempre la constante ``10``:"

#: ../../howto/descriptor.rst:48
msgid ""
"class Ten:\n"
"    def __get__(self, obj, objtype=None):\n"
"        return 10"
msgstr ""
"class Ten:\n"
"    def __get__(self, obj, objtype=None):\n"
"        return 10"

#: ../../howto/descriptor.rst:54
msgid ""
"To use the descriptor, it must be stored as a class variable in another "
"class:"
msgstr ""
"Para utilizar el descriptor, debe almacenarse como una variable de clase en "
"otra clase:"

#: ../../howto/descriptor.rst:56
msgid ""
"class A:\n"
"    x = 5                       # Regular class attribute\n"
"    y = Ten()                   # Descriptor instance"
msgstr ""
"class A:\n"
"    x = 5 # Atributo regular de la clase\n"
"    y = Ten() # Instancia del descriptor"

#: ../../howto/descriptor.rst:62
msgid ""
"An interactive session shows the difference between normal attribute lookup "
"and descriptor lookup:"
msgstr ""
"Una sesión interactiva muestra la diferencia entre la búsqueda normal de "
"atributos y la búsqueda de descriptores:"

#: ../../howto/descriptor.rst:65
msgid ""
">>> a = A()                     # Make an instance of class A\n"
">>> a.x                         # Normal attribute lookup\n"
"5\n"
">>> a.y                         # Descriptor lookup\n"
"10"
msgstr ""
">>> a = A() # Crea una instancia de la clase A\n"
">>> a.x # Búsqueda normal de atributos\n"
"5\n"
">>> a.y # Búsqueda de descriptores\n"
"10"

#: ../../howto/descriptor.rst:73
msgid ""
"In the ``a.x`` attribute lookup, the dot operator finds ``'x': 5`` in the "
"class dictionary.  In the ``a.y`` lookup, the dot operator finds a "
"descriptor instance, recognized by its ``__get__`` method. Calling that "
"method returns ``10``."
msgstr ""
"En la búsqueda de atributos ``a.x``, el operador de punto encuentra ``'x': "
"5`` en el diccionario de clases.  En la búsqueda de ``a.y``, el operador de "
"punto encuentra una instancia de descriptor, reconocida por su método "
"``__get__``. La llamada a ese método devuelve ``10``."

#: ../../howto/descriptor.rst:78
msgid ""
"Note that the value ``10`` is not stored in either the class dictionary or "
"the instance dictionary.  Instead, the value ``10`` is computed on demand."
msgstr ""
"Observe que el valor ``10`` no se almacena ni en el diccionario de clases ni "
"en el diccionario de instancias.  En su lugar, el valor ``10`` se calcula "
"bajo demanda."

#: ../../howto/descriptor.rst:81
msgid ""
"This example shows how a simple descriptor works, but it isn't very useful. "
"For retrieving constants, normal attribute lookup would be better."
msgstr ""
"Este ejemplo muestra cómo funciona un descriptor simple, pero no es muy "
"útil. Para recuperar constantes, sería mejor una búsqueda normal de "
"atributos."

#: ../../howto/descriptor.rst:84
msgid ""
"In the next section, we'll create something more useful, a dynamic lookup."
msgstr ""
"En la siguiente sección, crearemos algo más útil, una búsqueda dinámica."

#: ../../howto/descriptor.rst:88
msgid "Dynamic lookups"
msgstr "Búsquedas dinámicas"

#: ../../howto/descriptor.rst:90
msgid ""
"Interesting descriptors typically run computations instead of returning "
"constants:"
msgstr ""
"Los descriptores interesantes suelen ejecutar cálculos en lugar de devolver "
"constantes:"

#: ../../howto/descriptor.rst:93
msgid ""
"import os\n"
"\n"
"class DirectorySize:\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        return len(os.listdir(obj.dirname))\n"
"\n"
"class Directory:\n"
"\n"
"    size = DirectorySize()              # Descriptor instance\n"
"\n"
"    def __init__(self, dirname):\n"
"        self.dirname = dirname          # Regular instance attribute"
msgstr ""
"import os\n"
"\n"
"class DirectorySize:\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        return len(os.listdir(obj.dirname))\n"
"\n"
"class Directy:\n"
"\n"
"    size = DirectorySize() # Instancia de descriptor\n"
"\n"
"    def __init__(self, dirname):\n"
"        self.dirname = dirname # Atributo de instancia regular"

#: ../../howto/descriptor.rst:109
msgid ""
"An interactive session shows that the lookup is dynamic — it computes "
"different, updated answers each time::"
msgstr ""
"Una sesión interactiva muestra que la búsqueda es dinámica - calcula "
"respuestas diferentes y actualizadas cada vez::"

#: ../../howto/descriptor.rst:112
msgid ""
">>> s = Directory('songs')\n"
">>> g = Directory('games')\n"
">>> s.size                              # The songs directory has twenty "
"files\n"
"20\n"
">>> g.size                              # The games directory has three "
"files\n"
"3\n"
">>> os.remove('games/chess')            # Delete a game\n"
">>> g.size                              # File count is automatically "
"updated\n"
"2"
msgstr ""
">>> s = Directory('songs')\n"
">>> g = Directory('games')\n"
">>> s.size # El directorio songs tiene veinte ficheros\n"
"20\n"
">>> g.size # El directorio games tiene tres archivos\n"
"3\n"
">>> os.remove('games/chess') # Borra un juego\n"
">>> g.size # El recuento de archivos se actualiza automáticamente\n"
"2"

#: ../../howto/descriptor.rst:122
msgid ""
"Besides showing how descriptors can run computations, this example also "
"reveals the purpose of the parameters to :meth:`~object.__get__`.  The "
"*self* parameter is *size*, an instance of *DirectorySize*.  The *obj* "
"parameter is either *g* or *s*, an instance of *Directory*.  It is the *obj* "
"parameter that lets the :meth:`~object.__get__` method learn the target "
"directory.  The *objtype* parameter is the class *Directory*."
msgstr ""
"Además de mostrar cómo los descriptores pueden ejecutar cálculos, este "
"ejemplo también revela el propósito de los parámetros de :meth:`~object."
"__get__`. El parámetro *self* es *size*, una instancia de *DirectorySize*.  "
"El parámetro *obj* es *g* o *s*, una instancia de *Directory*.  Es el "
"parámetro *obj* el que permite al método :meth:`~object.__get__` conocer el "
"directorio de destino.  El parámetro *objtype* es la clase *Directory*."

#: ../../howto/descriptor.rst:131
msgid "Managed attributes"
msgstr "Atributos gestionados"

#: ../../howto/descriptor.rst:133
msgid ""
"A popular use for descriptors is managing access to instance data.  The "
"descriptor is assigned to a public attribute in the class dictionary while "
"the actual data is stored as a private attribute in the instance "
"dictionary.  The descriptor's :meth:`~object.__get__` and :meth:`~object."
"__set__` methods are triggered when the public attribute is accessed."
msgstr ""
"Un uso popular de los descriptores es la gestión del acceso a los datos de "
"instancia.  El descriptor se asigna a un atributo público en el diccionario "
"de la clase, mientras que los datos reales se almacenan como un atributo "
"privado en el diccionario de instancia.  Los métodos :meth:`~object.__get__` "
"y :meth:`~object.__set__` del descriptor se activan cuando se accede al "
"atributo público."

#: ../../howto/descriptor.rst:139
msgid ""
"In the following example, *age* is the public attribute and *_age* is the "
"private attribute.  When the public attribute is accessed, the descriptor "
"logs the lookup or update:"
msgstr ""
"En el siguiente ejemplo, *age* es el atributo público y *_age* es el "
"atributo privado.  Cuando se accede al atributo público, el descriptor "
"registra la búsqueda o actualización:"

#: ../../howto/descriptor.rst:143
msgid ""
"import logging\n"
"\n"
"logging.basicConfig(level=logging.INFO)\n"
"\n"
"class LoggedAgeAccess:\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        value = obj._age\n"
"        logging.info('Accessing %r giving %r', 'age', value)\n"
"        return value\n"
"\n"
"    def __set__(self, obj, value):\n"
"        logging.info('Updating %r to %r', 'age', value)\n"
"        obj._age = value\n"
"\n"
"class Person:\n"
"\n"
"    age = LoggedAgeAccess()             # Descriptor instance\n"
"\n"
"    def __init__(self, name, age):\n"
"        self.name = name                # Regular instance attribute\n"
"        self.age = age                  # Calls __set__()\n"
"\n"
"    def birthday(self):\n"
"        self.age += 1                   # Calls both __get__() and __set__()"
msgstr ""
"import logging\n"
"\n"
"logging.basicConfig(level=logging.INFO)\n"
"\n"
"class LoggedAgeAccess:\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        value = obj._age\n"
"        logging.info('Accessing %r giving %r', 'age', value)\n"
"        return value\n"
"\n"
"    def __set__(self, obj, value):\n"
"        logging.info('Updating %r to %r', 'age', value)\n"
"        obj._age = value\n"
"\n"
"class Person:\n"
"\n"
"    age = LoggedAgeAccess()             # Instancia del descriptor\n"
"\n"
"    def __init__(self, name, age):\n"
"        self.name = name                #Atributo regular de instancia\n"
"        self.age = age                  # Calls __set__()\n"
"\n"
"    def birthday(self):\n"
"        self.age += 1                   # Calls both __get__() and __set__()"

#: ../../howto/descriptor.rst:172
msgid ""
"An interactive session shows that all access to the managed attribute *age* "
"is logged, but that the regular attribute *name* is not logged:"
msgstr ""
"Una sesión interactiva muestra que todos los accesos al atributo gestionado "
"*edad* se registran, pero que el atributo normal *nombre* no se registra:"

#: ../../howto/descriptor.rst:181
msgid ""
">>> mary = Person('Mary M', 30)         # The initial age update is logged\n"
"INFO:root:Updating 'age' to 30\n"
">>> dave = Person('David D', 40)\n"
"INFO:root:Updating 'age' to 40\n"
"\n"
">>> vars(mary)                          # The actual data is in a private "
"attribute\n"
"{'name': 'Mary M', '_age': 30}\n"
">>> vars(dave)\n"
"{'name': 'David D', '_age': 40}\n"
"\n"
">>> mary.age                            # Access the data and log the "
"lookup\n"
"INFO:root:Accessing 'age' giving 30\n"
"30\n"
">>> mary.birthday()                     # Updates are logged as well\n"
"INFO:root:Accessing 'age' giving 30\n"
"INFO:root:Updating 'age' to 31\n"
"\n"
">>> dave.name                           # Regular attribute lookup isn't "
"logged\n"
"'David D'\n"
">>> dave.age                            # Only the managed attribute is "
"logged\n"
"INFO:root:Accessing 'age' giving 40\n"
"40"
msgstr ""
">>> mary = Person('Mary M', 30)         # Se registra la actualización "
"inicial de la edad\n"
"INFO:root:Updating 'age' to 30\n"
">>> dave = Person('David D', 40)\n"
"INFO:root:Updating 'age' to 40\n"
"\n"
">>> vars(mary)                          # Los datos reales están en un "
"atributo privado\n"
"{'name': 'Mary M', '_age': 30}\n"
">>> vars(dave)\n"
"{'name': 'David D', '_age': 40}\n"
"\n"
">>> mary.age                            # Accede a los datos y registra la "
"búsqueda\n"
"INFO:root:Accessing 'age' giving 30\n"
"30\n"
">>> mary.birthday()                     # También se registran las "
"actualizaciones\n"
"INFO:root:Accessing 'age' giving 30\n"
"INFO:root:Updating 'age' to 31\n"
"\n"
">>> dave.name                           # La búsqueda normal de atributos no "
"se registra\n"
"'David D'\n"
">>> dave.age                            # Sólo se registra el atributo "
"gestionado\n"
"INFO:root:Accessing 'age' giving 40\n"
"40"

#: ../../howto/descriptor.rst:206
msgid ""
"One major issue with this example is that the private name *_age* is "
"hardwired in the *LoggedAgeAccess* class.  That means that each instance can "
"only have one logged attribute and that its name is unchangeable.  In the "
"next example, we'll fix that problem."
msgstr ""
"Uno de los principales problemas de este ejemplo es que el nombre privado "
"*_age* está conectado a la clase *LoggedAgeAccess*.  Esto significa que cada "
"instancia sólo puede tener un atributo registrado y que su nombre es "
"inmutable.  En el siguiente ejemplo, arreglaremos ese problema."

#: ../../howto/descriptor.rst:213
msgid "Customized names"
msgstr "Nombres personalizados"

#: ../../howto/descriptor.rst:215
msgid ""
"When a class uses descriptors, it can inform each descriptor about which "
"variable name was used."
msgstr ""
"Cuando una clase utiliza descriptores, puede informar a cada descriptor "
"sobre qué nombre de variable se ha utilizado."

#: ../../howto/descriptor.rst:218
msgid ""
"In this example, the :class:`!Person` class has two descriptor instances, "
"*name* and *age*.  When the :class:`!Person` class is defined, it makes a "
"callback to :meth:`~object.__set_name__` in *LoggedAccess* so that the field "
"names can be recorded, giving each descriptor its own *public_name* and "
"*private_name*:"
msgstr ""
"En este ejemplo, la clase :class:`!Person` tiene dos instancias de "
"descriptor, *nombre* y *edad*.  Cuando se define la clase :class:`!Person`, "
"hace una llamada de retorno a :meth:`~object.__set_name__` en *LoggedAccess* "
"para que se puedan registrar los nombres de los campos, dando a cada "
"descriptor su propio *public_name* y *private_name*:"

#: ../../howto/descriptor.rst:223
msgid ""
"import logging\n"
"\n"
"logging.basicConfig(level=logging.INFO)\n"
"\n"
"class LoggedAccess:\n"
"\n"
"    def __set_name__(self, owner, name):\n"
"        self.public_name = name\n"
"        self.private_name = '_' + name\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        value = getattr(obj, self.private_name)\n"
"        logging.info('Accessing %r giving %r', self.public_name, value)\n"
"        return value\n"
"\n"
"    def __set__(self, obj, value):\n"
"        logging.info('Updating %r to %r', self.public_name, value)\n"
"        setattr(obj, self.private_name, value)\n"
"\n"
"class Person:\n"
"\n"
"    name = LoggedAccess()                # First descriptor instance\n"
"    age = LoggedAccess()                 # Second descriptor instance\n"
"\n"
"    def __init__(self, name, age):\n"
"        self.name = name                 # Calls the first descriptor\n"
"        self.age = age                   # Calls the second descriptor\n"
"\n"
"    def birthday(self):\n"
"        self.age += 1"
msgstr ""
"import logging\n"
"\n"
"logging.basicConfig(level=logging.INFO)\n"
"\n"
"class LoggedAccess:\n"
"\n"
"    def __set_name__(self, owner, name):\n"
"        self.public_name = name\n"
"        self.private_name = '_' + name\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        value = getattr(obj, self.private_name)\n"
"        logging.info('Accessing %r giving %r', self.public_name, value)\n"
"        return value\n"
"\n"
"    def __set__(self, obj, value):\n"
"        logging.info('Updating %r to %r', self.public_name, value)\n"
"        setattr(obj, self.private_name, value)\n"
"\n"
"class Person:\n"
"\n"
"     name = LoggedAccess() # Primera instancia del descriptor\n"
"     edad = LoggedAccess() # Segunda instancia del descriptor\n"
"\n"
"     def __init__(self, nombre, edad):\n"
"         self.name = name # Llama al primer descriptor\n"
"         self.age = age # Llama al segundo descriptor\n"
"\n"
"    def birthday(self):\n"
"        self.age += 1"

#: ../../howto/descriptor.rst:256
msgid ""
"An interactive session shows that the :class:`!Person` class has called :"
"meth:`~object.__set_name__` so that the field names would be recorded.  Here "
"we call :func:`vars` to look up the descriptor without triggering it:"
msgstr ""
"Una sesión interactiva muestra que la clase :class:`!Person` ha llamado a :"
"meth:`~object.__set_name__` para que se registraran los nombres de los "
"campos.  Aquí llamamos a :func:`vars` para buscar el descriptor sin "
"activarlo:"

#: ../../howto/descriptor.rst:260
msgid ""
">>> vars(vars(Person)['name'])\n"
"{'public_name': 'name', 'private_name': '_name'}\n"
">>> vars(vars(Person)['age'])\n"
"{'public_name': 'age', 'private_name': '_age'}"
msgstr ""
">>> vars(vars(Person)['name'])\n"
"{'public_name': 'name', 'private_name': '_name'}\n"
">>> vars(vars(Person)['age'])\n"
"{'public_name': 'age', 'private_name': '_age'}"

#: ../../howto/descriptor.rst:267
msgid "The new class now logs access to both *name* and *age*:"
msgstr "La nueva clase registra ahora el acceso tanto a *name* como a *age*:"

#: ../../howto/descriptor.rst:275
msgid ""
">>> pete = Person('Peter P', 10)\n"
"INFO:root:Updating 'name' to 'Peter P'\n"
"INFO:root:Updating 'age' to 10\n"
">>> kate = Person('Catherine C', 20)\n"
"INFO:root:Updating 'name' to 'Catherine C'\n"
"INFO:root:Updating 'age' to 20"
msgstr ""
">>> pete = Person('Peter P', 10)\n"
"INFO:root:Updating 'name' to 'Peter P'\n"
"INFO:root:Updating 'age' to 10\n"
">>> kate = Person('Catherine C', 20)\n"
"INFO:root:Updating 'name' to 'Catherine C'\n"
"INFO:root:Updating 'age' to 20"

#: ../../howto/descriptor.rst:284
msgid "The two *Person* instances contain only the private names:"
msgstr "Las dos instancias *Person* contienen sólo los nombres privados:"

#: ../../howto/descriptor.rst:286
msgid ""
">>> vars(pete)\n"
"{'_name': 'Peter P', '_age': 10}\n"
">>> vars(kate)\n"
"{'_name': 'Catherine C', '_age': 20}"
msgstr ""
">>> vars(pete)\n"
"{'_name': 'Peter P', '_age': 10}\n"
">>> vars(kate)\n"
"{'_name': 'Catherine C', '_age': 20}"

#: ../../howto/descriptor.rst:295
msgid "Closing thoughts"
msgstr "Reflexiones finales"

#: ../../howto/descriptor.rst:297
msgid ""
"A :term:`descriptor` is what we call any object that defines :meth:`~object."
"__get__`, :meth:`~object.__set__`, or :meth:`~object.__delete__`."
msgstr ""
"Llamamos :term:`descriptor` a cualquier objeto que defina :meth:`~object."
"__get__`, :meth:`~object.__set__`, o :meth:`~object.__delete__`."

#: ../../howto/descriptor.rst:300
msgid ""
"Optionally, descriptors can have a :meth:`~object.__set_name__` method.  "
"This is only used in cases where a descriptor needs to know either the class "
"where it was created or the name of class variable it was assigned to.  "
"(This method, if present, is called even if the class is not a descriptor.)"
msgstr ""
"Opcionalmente, los descriptores pueden tener un método :meth:`~object."
"__set_name__`.  Esto sólo se utiliza en los casos en que un descriptor "
"necesita saber la clase en la que fue creado o el nombre de la variable de "
"clase a la que fue asignado.  (Este método, si está presente, se llama "
"incluso si la clase no es un descriptor)."

#: ../../howto/descriptor.rst:305
msgid ""
"Descriptors get invoked by the dot operator during attribute lookup.  If a "
"descriptor is accessed indirectly with ``vars(some_class)"
"[descriptor_name]``, the descriptor instance is returned without invoking it."
msgstr ""
"Los descriptores son invocados por el operador dot durante la búsqueda de "
"atributos.  Si se accede a un descriptor indirectamente con "
"``vars(some_class)[descriptor_name]``, se devuelve la instancia del "
"descriptor sin invocarlo."

#: ../../howto/descriptor.rst:309
msgid ""
"Descriptors only work when used as class variables.  When put in instances, "
"they have no effect."
msgstr ""
"Los descriptores sólo funcionan cuando se utilizan como variables de clase.  "
"Cuando se ponen en instancias, no tienen ningún efecto."

#: ../../howto/descriptor.rst:312
msgid ""
"The main motivation for descriptors is to provide a hook allowing objects "
"stored in class variables to control what happens during attribute lookup."
msgstr ""
"La principal motivación de los descriptores es proporcionar un gancho que "
"permita a los objetos almacenados en variables de clase controlar lo que "
"ocurre durante la búsqueda de atributos."

#: ../../howto/descriptor.rst:315
msgid ""
"Traditionally, the calling class controls what happens during lookup. "
"Descriptors invert that relationship and allow the data being looked-up to "
"have a say in the matter."
msgstr ""
"Tradicionalmente, la clase que realiza la llamada controla lo que ocurre "
"durante la búsqueda. Los descriptores invierten esa relación y permiten que "
"los datos que se buscan tengan algo que decir al respecto."

#: ../../howto/descriptor.rst:319
msgid ""
"Descriptors are used throughout the language.  It is how functions turn into "
"bound methods.  Common tools like :func:`classmethod`, :func:"
"`staticmethod`, :func:`property`, and :func:`functools.cached_property` are "
"all implemented as descriptors."
msgstr ""
"Los descriptores se utilizan en todo el lenguaje.  Así es como las funciones "
"se convierten en métodos vinculados.  Herramientas comunes como :func:"
"`classmethod`, :func:`staticmethod`, :func:`property`, y :func:`functools."
"cached_property` se implementan como descriptores."

#: ../../howto/descriptor.rst:326
msgid "Complete Practical Example"
msgstr "Ejemplo práctico completo"

#: ../../howto/descriptor.rst:328
msgid ""
"In this example, we create a practical and powerful tool for locating "
"notoriously hard to find data corruption bugs."
msgstr ""
"En este ejemplo, creamos una herramienta práctica y potente para localizar "
"errores de corrupción de datos notoriamente difíciles de encontrar."

#: ../../howto/descriptor.rst:333
msgid "Validator class"
msgstr "Clase de validador"

#: ../../howto/descriptor.rst:335
msgid ""
"A validator is a descriptor for managed attribute access.  Prior to storing "
"any data, it verifies that the new value meets various type and range "
"restrictions.  If those restrictions aren't met, it raises an exception to "
"prevent data corruption at its source."
msgstr ""
"Un validador es un descriptor para el acceso gestionado a atributos.  Antes "
"de almacenar cualquier dato, verifica que el nuevo valor cumple varias "
"restricciones de tipo y rango.  Si no se cumplen esas restricciones, lanza "
"una excepción para evitar la corrupción de datos en su origen."

#: ../../howto/descriptor.rst:340
msgid ""
"This :class:`!Validator` class is both an :term:`abstract base class` and a "
"managed attribute descriptor:"
msgstr ""
"Esta clase :class:`!Validator` es a la vez un :term:`abstract base class` y "
"un descriptor de atributos gestionados:"

#: ../../howto/descriptor.rst:343
msgid ""
"from abc import ABC, abstractmethod\n"
"\n"
"class Validator(ABC):\n"
"\n"
"    def __set_name__(self, owner, name):\n"
"        self.private_name = '_' + name\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        return getattr(obj, self.private_name)\n"
"\n"
"    def __set__(self, obj, value):\n"
"        self.validate(value)\n"
"        setattr(obj, self.private_name, value)\n"
"\n"
"    @abstractmethod\n"
"    def validate(self, value):\n"
"        pass"
msgstr ""
"from abc import ABC, abstractmethod\n"
"\n"
"class Validator(ABC):\n"
"\n"
"    def __set_name__(self, owner, name):\n"
"        self.private_name = '_' + name\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        return getattr(obj, self.private_name)\n"
"\n"
"    def __set__(self, obj, value):\n"
"        self.validate(value)\n"
"        setattr(obj, self.private_name, value)\n"
"\n"
"    @abstractmethod\n"
"    def validate(self, value):\n"
"        pass"

#: ../../howto/descriptor.rst:363
msgid ""
"Custom validators need to inherit from :class:`!Validator` and must supply "
"a :meth:`!validate` method to test various restrictions as needed."
msgstr ""
"Los validadores personalizados deben heredar de :class:`!Validator` y deben "
"proporcionar un método :meth:`!validate` para probar varias restricciones "
"según sea necesario."

#: ../../howto/descriptor.rst:368
msgid "Custom validators"
msgstr "Validadores personalizados"

#: ../../howto/descriptor.rst:370
msgid "Here are three practical data validation utilities:"
msgstr "He aquí tres prácticas utilidades de validación de datos:"

#: ../../howto/descriptor.rst:372
msgid ""
":class:`!OneOf` verifies that a value is one of a restricted set of options."
msgstr ""
":class:`!OneOf` verifica que un valor es uno de un conjunto restringido de "
"opciones."

#: ../../howto/descriptor.rst:374
msgid ""
":class:`!Number` verifies that a value is either an :class:`int` or :class:"
"`float`.  Optionally, it verifies that a value is between a given minimum or "
"maximum."
msgstr ""
":class:`!Number` verifica que un valor es :class:`int` o :class:`float`.  "
"Opcionalmente, verifica que un valor esté entre un mínimo o un máximo dados."

#: ../../howto/descriptor.rst:378
msgid ""
":class:`!String` verifies that a value is a :class:`str`.  Optionally, it "
"validates a given minimum or maximum length.  It can validate a user-defined "
"`predicate <https://en.wikipedia.org/wiki/Predicate_(mathematical_logic)>`_ "
"as well."
msgstr ""
":class:`!String` verifica que un valor es un :class:`str`. Opcionalmente, "
"valida una longitud mínima o máxima dada.  También puede validar un "
"`predicado definido por el usuario <https://en.wikipedia.org/wiki/"
"Predicate_(mathematical_logic)>`_."

#: ../../howto/descriptor.rst:383
msgid ""
"class OneOf(Validator):\n"
"\n"
"    def __init__(self, *options):\n"
"        self.options = set(options)\n"
"\n"
"    def validate(self, value):\n"
"        if value not in self.options:\n"
"            raise ValueError(f'Expected {value!r} to be one of {self.options!"
"r}')\n"
"\n"
"class Number(Validator):\n"
"\n"
"    def __init__(self, minvalue=None, maxvalue=None):\n"
"        self.minvalue = minvalue\n"
"        self.maxvalue = maxvalue\n"
"\n"
"    def validate(self, value):\n"
"        if not isinstance(value, (int, float)):\n"
"            raise TypeError(f'Expected {value!r} to be an int or float')\n"
"        if self.minvalue is not None and value < self.minvalue:\n"
"            raise ValueError(\n"
"                f'Expected {value!r} to be at least {self.minvalue!r}'\n"
"            )\n"
"        if self.maxvalue is not None and value > self.maxvalue:\n"
"            raise ValueError(\n"
"                f'Expected {value!r} to be no more than {self.maxvalue!r}'\n"
"            )\n"
"\n"
"class String(Validator):\n"
"\n"
"    def __init__(self, minsize=None, maxsize=None, predicate=None):\n"
"        self.minsize = minsize\n"
"        self.maxsize = maxsize\n"
"        self.predicate = predicate\n"
"\n"
"    def validate(self, value):\n"
"        if not isinstance(value, str):\n"
"            raise TypeError(f'Expected {value!r} to be an str')\n"
"        if self.minsize is not None and len(value) < self.minsize:\n"
"            raise ValueError(\n"
"                f'Expected {value!r} to be no smaller than {self.minsize!"
"r}'\n"
"            )\n"
"        if self.maxsize is not None and len(value) > self.maxsize:\n"
"            raise ValueError(\n"
"                f'Expected {value!r} to be no bigger than {self.maxsize!r}'\n"
"            )\n"
"        if self.predicate is not None and not self.predicate(value):\n"
"            raise ValueError(\n"
"                f'Expected {self.predicate} to be true for {value!r}'\n"
"            )"
msgstr ""
"class OneOf(Validator):\n"
"\n"
"    def __init__(self, *options):\n"
"        self.options = set(options)\n"
"\n"
"    def validate(self, value):\n"
"        if value not in self.options:\n"
"            raise ValueError(f'Expected {value!r} to be one of {self.options!"
"r}')\n"
"\n"
"class Number(Validator):\n"
"\n"
"    def __init__(self, minvalue=None, maxvalue=None):\n"
"        self.minvalue = minvalue\n"
"        self.maxvalue = maxvalue\n"
"\n"
"    def validate(self, value):\n"
"        if not isinstance(value, (int, float)):\n"
"            raise TypeError(f'Expected {value!r} to be an int or float')\n"
"        if self.minvalue is not None and value < self.minvalue:\n"
"            raise ValueError(\n"
"                f'Expected {value!r} to be at least {self.minvalue!r}'\n"
"            )\n"
"        if self.maxvalue is not None and value > self.maxvalue:\n"
"            raise ValueError(\n"
"                f'Expected {value!r} to be no more than {self.maxvalue!r}'\n"
"            )\n"
"\n"
"class String(Validator):\n"
"\n"
"    def __init__(self, minsize=None, maxsize=None, predicate=None):\n"
"        self.minsize = minsize\n"
"        self.maxsize = maxsize\n"
"        self.predicate = predicate\n"
"\n"
"    def validate(self, value):\n"
"        if not isinstance(value, str):\n"
"            raise TypeError(f'Expected {value!r} to be an str')\n"
"        if self.minsize is not None and len(value) < self.minsize:\n"
"            raise ValueError(\n"
"                f'Expected {value!r} to be no smaller than {self.minsize!"
"r}'\n"
"            )\n"
"        if self.maxsize is not None and len(value) > self.maxsize:\n"
"            raise ValueError(\n"
"                f'Expected {value!r} to be no bigger than {self.maxsize!r}'\n"
"            )\n"
"        if self.predicate is not None and not self.predicate(value):\n"
"            raise ValueError(\n"
"                f'Expected {self.predicate} to be true for {value!r}'\n"
"            )"

#: ../../howto/descriptor.rst:437
msgid "Practical application"
msgstr "Aplicación práctica"

#: ../../howto/descriptor.rst:439
msgid "Here's how the data validators can be used in a real class:"
msgstr ""
"A continuación se muestra cómo se pueden utilizar los validadores de datos "
"en una clase real:"

#: ../../howto/descriptor.rst:441
msgid ""
"class Component:\n"
"\n"
"    name = String(minsize=3, maxsize=10, predicate=str.isupper)\n"
"    kind = OneOf('wood', 'metal', 'plastic')\n"
"    quantity = Number(minvalue=0)\n"
"\n"
"    def __init__(self, name, kind, quantity):\n"
"        self.name = name\n"
"        self.kind = kind\n"
"        self.quantity = quantity"
msgstr ""
"class Component:\n"
"\n"
"    name = String(minsize=3, maxsize=10, predicate=str.isupper)\n"
"    kind = OneOf('wood', 'metal', 'plastic')\n"
"    quantity = Number(minvalue=0)\n"
"\n"
"    def __init__(self, name, kind, quantity):\n"
"        self.name = name\n"
"        self.kind = kind\n"
"        self.quantity = quantity"

#: ../../howto/descriptor.rst:454
msgid "The descriptors prevent invalid instances from being created:"
msgstr "Los descriptores evitan que se creen instancias no válidas:"

#: ../../howto/descriptor.rst:456
msgid ""
">>> Component('Widget', 'metal', 5)      # Blocked: 'Widget' is not all "
"uppercase\n"
"Traceback (most recent call last):\n"
"    ...\n"
"ValueError: Expected <method 'isupper' of 'str' objects> to be true for "
"'Widget'\n"
"\n"
">>> Component('WIDGET', 'metle', 5)      # Blocked: 'metle' is misspelled\n"
"Traceback (most recent call last):\n"
"    ...\n"
"ValueError: Expected 'metle' to be one of {'metal', 'plastic', 'wood'}\n"
"\n"
">>> Component('WIDGET', 'metal', -5)     # Blocked: -5 is negative\n"
"Traceback (most recent call last):\n"
"    ...\n"
"ValueError: Expected -5 to be at least 0\n"
">>> Component('WIDGET', 'metal', 'V')    # Blocked: 'V' isn't a number\n"
"Traceback (most recent call last):\n"
"    ...\n"
"TypeError: Expected 'V' to be an int or float\n"
"\n"
">>> c = Component('WIDGET', 'metal', 5)  # Allowed:  The inputs are valid"
msgstr ""
">>> Component('Widget', 'metal', 5)      # Blocked: 'Widget' no está en "
"mayúsculas\n"
"Traceback (última llamada más reciente):\n"
"    ...\n"
"ValueError: Expected <method 'isupper' of 'str' objects> to be true for "
"'Widget'\n"
"\n"
">>> Component('WIDGET', 'metle', 5)      # Blocked: metle' está mal escrito\n"
"Traceback (última llamada más reciente):\n"
"    ...\n"
"ValueError: Expected 'metle' to be one of {'metal', 'plastic', 'wood'}\n"
"\n"
">>> Component('WIDGET', 'metal', -5)     # Blocked: -5 es negativo\n"
"Traceback (última llamada más reciente):\n"
"    ...\n"
"ValueError: Expected -5 to be at least 0\n"
">>> Component('WIDGET', 'metal', 'V')    # Blocked: 'V' no es un número\n"
"Traceback (última llamada más reciente):\n"
"    ...\n"
"TypeError: Expected 'V' to be an int or float\n"
"\n"
">>> c = Component('WIDGET', 'metal', 5)  # Allowed:  Las entradas son válidas"

#: ../../howto/descriptor.rst:481
msgid "Technical Tutorial"
msgstr "Tutorial técnico"

#: ../../howto/descriptor.rst:483
msgid ""
"What follows is a more technical tutorial for the mechanics and details of "
"how descriptors work."
msgstr ""
"Lo que sigue es un tutorial más técnico sobre la mecánica y los detalles del "
"funcionamiento de los descriptores."

#: ../../howto/descriptor.rst:488
msgid "Abstract"
msgstr "Resumen"

#: ../../howto/descriptor.rst:490
msgid ""
"Defines descriptors, summarizes the protocol, and shows how descriptors are "
"called.  Provides an example showing how object relational mappings work."
msgstr ""
"Define los descriptores, resume el protocolo y muestra cómo se llaman los "
"descriptores.  Proporciona un ejemplo que muestra cómo funcionan las "
"asignaciones relacionales de objetos."

#: ../../howto/descriptor.rst:493
msgid ""
"Learning about descriptors not only provides access to a larger toolset, it "
"creates a deeper understanding of how Python works."
msgstr ""
"Aprender sobre descriptores no sólo proporciona acceso a un conjunto de "
"herramientas más amplio, sino que crea una comprensión más profunda de cómo "
"funciona Python."

#: ../../howto/descriptor.rst:498
msgid "Definition and introduction"
msgstr "Definición e introducción"

#: ../../howto/descriptor.rst:500
msgid ""
"In general, a descriptor is an attribute value that has one of the methods "
"in the descriptor protocol.  Those methods are :meth:`~object.__get__`, :"
"meth:`~object.__set__`, and :meth:`~object.__delete__`.  If any of those "
"methods are defined for an attribute, it is said to be a :term:`descriptor`."
msgstr ""
"En general, un descriptor es un valor de atributo que tiene uno de los "
"métodos del protocolo de descriptores.  Estos métodos son :meth:`~object."
"__get__`, :meth:`~object.__set__` y :meth:`~object.__delete__`. Si alguno de "
"estos métodos está definido para un atributo, se dice que es un :term:"
"`descriptor`."

#: ../../howto/descriptor.rst:505
msgid ""
"The default behavior for attribute access is to get, set, or delete the "
"attribute from an object's dictionary.  For instance, ``a.x`` has a lookup "
"chain starting with ``a.__dict__['x']``, then ``type(a).__dict__['x']``, and "
"continuing through the method resolution order of ``type(a)``. If the looked-"
"up value is an object defining one of the descriptor methods, then Python "
"may override the default behavior and invoke the descriptor method instead. "
"Where this occurs in the precedence chain depends on which descriptor "
"methods were defined."
msgstr ""
"El comportamiento por defecto para el acceso a atributos es obtener, "
"establecer o borrar el atributo desde el diccionario de un objeto.  Por "
"ejemplo, ``a.x`` tiene una cadena de búsqueda que comienza con ``a."
"__dict__['x']``, luego ``type(a).__dict__['x']``, y continúa a través del "
"orden de resolución de métodos de ``type(a)``. Si el valor buscado es un "
"objeto que define uno de los métodos del descriptor, entonces Python puede "
"anular el comportamiento por defecto e invocar el método del descriptor en "
"su lugar. Dónde ocurre esto en la cadena de precedencia depende de qué "
"métodos del descriptor fueron definidos."

#: ../../howto/descriptor.rst:514
msgid ""
"Descriptors are a powerful, general purpose protocol.  They are the "
"mechanism behind properties, methods, static methods, class methods, and :"
"func:`super`.  They are used throughout Python itself.  Descriptors simplify "
"the underlying C code and offer a flexible set of new tools for everyday "
"Python programs."
msgstr ""
"Los descriptores son un potente protocolo de propósito general.  Son el "
"mecanismo detrás de las propiedades, métodos, métodos estáticos, métodos de "
"clase y :func:`super`.  Se utilizan en todo Python.  Los descriptores "
"simplifican el código C subyacente y ofrecen un conjunto flexible de nuevas "
"herramientas para los programas cotidianos de Python."

#: ../../howto/descriptor.rst:522
msgid "Descriptor protocol"
msgstr "Protocolo descriptor"

#: ../../howto/descriptor.rst:524
msgid "``descr.__get__(self, obj, type=None)``"
msgstr "``descr.__get__(self, obj, type=None)``"

#: ../../howto/descriptor.rst:526
msgid "``descr.__set__(self, obj, value)``"
msgstr "``descr.__set__(self, obj, value)``"

#: ../../howto/descriptor.rst:528
msgid "``descr.__delete__(self, obj)``"
msgstr "``descr.__delete__(self, obj)``"

#: ../../howto/descriptor.rst:530
msgid ""
"That is all there is to it.  Define any of these methods and an object is "
"considered a descriptor and can override default behavior upon being looked "
"up as an attribute."
msgstr ""
"Eso es todo.  Defina cualquiera de estos métodos y un objeto se considera un "
"descriptor y puede anular el comportamiento predeterminado al ser buscado "
"como un atributo."

#: ../../howto/descriptor.rst:534
msgid ""
"If an object defines :meth:`~object.__set__` or :meth:`~object.__delete__`, "
"it is considered a data descriptor.  Descriptors that only define :meth:"
"`~object.__get__` are called non-data descriptors (they are often used for "
"methods but other uses are possible)."
msgstr ""
"Si un objeto define :meth:`~object.__set__` o :meth:`~object.__delete__`, se "
"considera un descriptor de datos.  Los descriptores que sólo definen :meth:"
"`~object.__get__` se denominan descriptores que no son de datos (suelen "
"utilizarse para métodos, pero son posibles otros usos)."

#: ../../howto/descriptor.rst:539
msgid ""
"Data and non-data descriptors differ in how overrides are calculated with "
"respect to entries in an instance's dictionary.  If an instance's dictionary "
"has an entry with the same name as a data descriptor, the data descriptor "
"takes precedence.  If an instance's dictionary has an entry with the same "
"name as a non-data descriptor, the dictionary entry takes precedence."
msgstr ""
"Los descriptores de datos y no datos difieren en cómo se calculan las "
"anulaciones con respecto a las entradas del diccionario de una instancia.  "
"Si el diccionario de una instancia tiene una entrada con el mismo nombre que "
"un descriptor de datos, el descriptor de datos tiene prioridad.  Si el "
"diccionario de una instancia tiene una entrada con el mismo nombre que un "
"descriptor que no es de datos, la entrada del diccionario tiene preferencia."

#: ../../howto/descriptor.rst:545
msgid ""
"To make a read-only data descriptor, define both :meth:`~object.__get__` "
"and :meth:`~object.__set__` with the :meth:`~object.__set__` raising an :exc:"
"`AttributeError` when called.  Defining the :meth:`~object.__set__` method "
"with an exception raising placeholder is enough to make it a data descriptor."
msgstr ""
"Para hacer un descriptor de datos de sólo lectura, defina :meth:`~object."
"__get__` y :meth:`~object.__set__` con :meth:`~object.__set__` lanzando :exc:"
"`AttributeError` cuando sea llamado.  Definir el método :meth:`~object."
"__set__` con un marcador de excepción es suficiente para convertirlo en un "
"descriptor de datos."

#: ../../howto/descriptor.rst:552
msgid "Overview of descriptor invocation"
msgstr "Visión general de la invocación de un descriptor"

#: ../../howto/descriptor.rst:554
msgid ""
"A descriptor can be called directly with ``desc.__get__(obj)`` or ``desc."
"__get__(None, cls)``."
msgstr ""
"Un descriptor puede llamarse directamente con ``desc.__get__(obj)`` o ``desc."
"__get__(None, cls)``."

#: ../../howto/descriptor.rst:557
msgid ""
"But it is more common for a descriptor to be invoked automatically from "
"attribute access."
msgstr ""
"Pero es más habitual que un descriptor se invoque automáticamente a partir "
"del acceso a atributos."

#: ../../howto/descriptor.rst:560
msgid ""
"The expression ``obj.x`` looks up the attribute ``x`` in the chain of "
"namespaces for ``obj``.  If the search finds a descriptor outside of the "
"instance :attr:`~object.__dict__`, its :meth:`~object.__get__` method is "
"invoked according to the precedence rules listed below."
msgstr ""
"La expresión ``obj.x`` busca el atributo ``x`` en la cadena de espacios de "
"nombres para ``obj``.  Si la búsqueda encuentra un descriptor fuera de la "
"instancia :attr:`~object.__dict__`, se invoca su método :meth:`~object."
"__get__` según las reglas de precedencia enumeradas a continuación."

#: ../../howto/descriptor.rst:565
msgid ""
"The details of invocation depend on whether ``obj`` is an object, class, or "
"instance of super."
msgstr ""
"Los detalles de la invocación dependen de si ``obj`` es un objeto, una clase "
"o una instancia de super."

#: ../../howto/descriptor.rst:570
msgid "Invocation from an instance"
msgstr "Invocación desde una instancia"

#: ../../howto/descriptor.rst:572
msgid ""
"Instance lookup scans through a chain of namespaces giving data descriptors "
"the highest priority, followed by instance variables, then non-data "
"descriptors, then class variables, and lastly :meth:`~object.__getattr__` if "
"it is provided."
msgstr ""
"La búsqueda de instancias recorre una cadena de espacios de nombres dando la "
"máxima prioridad a los descriptores de datos, seguidos de las variables de "
"instancia, luego los descriptores que no son datos, a continuación las "
"variables de clase y, por último, :meth:`~object.__getattr__` si se "
"proporciona."

#: ../../howto/descriptor.rst:577
msgid ""
"If a descriptor is found for ``a.x``, then it is invoked with: ``desc."
"__get__(a, type(a))``."
msgstr ""
"Si se encuentra un descriptor para ``a.x``, entonces se invoca con: ``desc."
"__get__(a, type(a))``."

#: ../../howto/descriptor.rst:580
msgid ""
"The logic for a dotted lookup is in :meth:`object.__getattribute__`.  Here "
"is a pure Python equivalent:"
msgstr ""
"La lógica de una búsqueda por puntos se encuentra en :meth:`object."
"__getattribute__`. He aquí un equivalente en Python puro:"

#: ../../howto/descriptor.rst:583
msgid ""
"def find_name_in_mro(cls, name, default):\n"
"    \"Emulate _PyType_Lookup() in Objects/typeobject.c\"\n"
"    for base in cls.__mro__:\n"
"        if name in vars(base):\n"
"            return vars(base)[name]\n"
"    return default\n"
"\n"
"def object_getattribute(obj, name):\n"
"    \"Emulate PyObject_GenericGetAttr() in Objects/object.c\"\n"
"    null = object()\n"
"    objtype = type(obj)\n"
"    cls_var = find_name_in_mro(objtype, name, null)\n"
"    descr_get = getattr(type(cls_var), '__get__', null)\n"
"    if descr_get is not null:\n"
"        if (hasattr(type(cls_var), '__set__')\n"
"            or hasattr(type(cls_var), '__delete__')):\n"
"            return descr_get(cls_var, obj, objtype)     # data descriptor\n"
"    if hasattr(obj, '__dict__') and name in vars(obj):\n"
"        return vars(obj)[name]                          # instance variable\n"
"    if descr_get is not null:\n"
"        return descr_get(cls_var, obj, objtype)         # non-data "
"descriptor\n"
"    if cls_var is not null:\n"
"        return cls_var                                  # class variable\n"
"    raise AttributeError(name)"
msgstr ""
"def find_name_in_mro(cls, name, default):\n"
"    \"Emulate _PyType_Lookup() in Objects/typeobject.c\"\n"
"    for base in cls.__mro__:\n"
"        if name in vars(base):\n"
"            return vars(base)[name]\n"
"    return default\n"
"\n"
"def object_getattribute(obj, name):\n"
"    \"Emulate PyObject_GenericGetAttr() in Objects/object.c\"\n"
"    null = object()\n"
"    objtype = type(obj)\n"
"    cls_var = find_name_in_mro(objtype, name, null)\n"
"    descr_get = getattr(type(cls_var), '__get__', null)\n"
"    if descr_get is not null:\n"
"        if (hasattr(type(cls_var), '__set__')\n"
"            or hasattr(type(cls_var), '__delete__')):\n"
"            return descr_get(cls_var, obj, objtype)     # descriptor de "
"datos\n"
"    if hasattr(obj, '__dict__') and name in vars(obj):\n"
"        return vars(obj)[name]                          # variable de "
"instancia\n"
"    if descr_get is not null:\n"
"        return descr_get(cls_var, obj, objtype)         # descriptor sin "
"datos\n"
"    if cls_var is not null:\n"
"        return cls_var                                  # variable de clase\n"
"    raise AttributeError(name)"

#: ../../howto/descriptor.rst:719
msgid ""
"Note, there is no :meth:`~object.__getattr__` hook in the :meth:`~object."
"__getattribute__` code.  That is why calling :meth:`~object."
"__getattribute__` directly or with ``super().__getattribute__`` will bypass :"
"meth:`~object.__getattr__` entirely."
msgstr ""
"Tener en cuenta que no hay ningún gancho :meth:`~object.__getattr__` en el "
"código :meth:`~object.__getattribute__`.  Por eso, si se llama a :meth:"
"`~object.__getattribute__` directamente o con ``super().__getattribute__``, "
"se omitirá :meth:`~object.__getattr__` por completo."

#: ../../howto/descriptor.rst:723
msgid ""
"Instead, it is the dot operator and the :func:`getattr` function that are "
"responsible for invoking :meth:`~object.__getattr__` whenever :meth:`~object."
"__getattribute__` raises an :exc:`AttributeError`.  Their logic is "
"encapsulated in a helper function:"
msgstr ""
"En su lugar, son el operador punto y la función :func:`getattr` los "
"responsables de invocar a :meth:`~object.__getattr__` siempre que :meth:"
"`~object.__getattribute__` genere una :exc:`AttributeError`. Su lógica está "
"encapsulada en una función de ayuda:"

#: ../../howto/descriptor.rst:728
msgid ""
"def getattr_hook(obj, name):\n"
"    \"Emulate slot_tp_getattr_hook() in Objects/typeobject.c\"\n"
"    try:\n"
"        return obj.__getattribute__(name)\n"
"    except AttributeError:\n"
"        if not hasattr(type(obj), '__getattr__'):\n"
"            raise\n"
"    return type(obj).__getattr__(obj, name)             # __getattr__"
msgstr ""
"def getattr_hook(obj, name):\n"
"    \"Emulate slot_tp_getattr_hook() in Objects/typeobject.c\"\n"
"    try:\n"
"        return obj.__getattribute__(name)\n"
"    except AttributeError:\n"
"        if not hasattr(type(obj), '__getattr__'):\n"
"            raise\n"
"    return type(obj).__getattr__(obj, name)             # __getattr__"

#: ../../howto/descriptor.rst:773
msgid "Invocation from a class"
msgstr "Invocación desde una clase"

#: ../../howto/descriptor.rst:775
msgid ""
"The logic for a dotted lookup such as ``A.x`` is in :meth:`!type."
"__getattribute__`.  The steps are similar to those for :meth:`!object."
"__getattribute__` but the instance dictionary lookup is replaced by a search "
"through the class's :term:`method resolution order`."
msgstr ""
"La lógica para una búsqueda por puntos como ``A.x`` se encuentra en :meth:`!"
"type.__getattribute__`.  Los pasos son similares a los de :meth:`!object."
"__getattribute__` pero la búsqueda en el diccionario de instancias se "
"sustituye por una búsqueda en el :term:`method resolution order` de la clase."

#: ../../howto/descriptor.rst:780
msgid "If a descriptor is found, it is invoked with ``desc.__get__(None, A)``."
msgstr ""
"Si se encuentra un descriptor, se invoca con ``desc.__get__(None, A)``."

#: ../../howto/descriptor.rst:782
msgid ""
"The full C implementation can be found in :c:func:`!type_getattro` and :c:"
"func:`!_PyType_Lookup` in :source:`Objects/typeobject.c`."
msgstr ""
"La implementación completa en C puede consultarse en :c:func:`!"
"type_getattro` y :c:func:`!_PyType_Lookup` en :source:`Objects/typeobject.c`."

#: ../../howto/descriptor.rst:787
msgid "Invocation from super"
msgstr "Invocación desde super"

#: ../../howto/descriptor.rst:789
msgid ""
"The logic for super's dotted lookup is in the :meth:`~object."
"__getattribute__` method for object returned by :func:`super`."
msgstr ""
"La lógica para la búsqueda de puntos de super se encuentra en el método :"
"meth:`~object.__getattribute__` para el objeto devuelto por :func:`super`."

#: ../../howto/descriptor.rst:792
msgid ""
"A dotted lookup such as ``super(A, obj).m`` searches ``obj.__class__."
"__mro__`` for the base class ``B`` immediately following ``A`` and then "
"returns ``B.__dict__['m'].__get__(obj, A)``.  If not a descriptor, ``m`` is "
"returned unchanged."
msgstr ""
"Una búsqueda por puntos como ``super(A, obj).m`` busca en ``obj.__class__."
"__mro__`` la clase base ``B`` inmediatamente después de ``A`` y devuelve ``B."
"__dict__['m'].__get__(obj, A)``.  Si no es un descriptor, ``m`` se devuelve "
"sin cambios."

#: ../../howto/descriptor.rst:797
msgid ""
"The full C implementation can be found in :c:func:`!super_getattro` in :"
"source:`Objects/typeobject.c`.  A pure Python equivalent can be found in "
"`Guido's Tutorial <https://www.python.org/download/releases/2.2.3/descrintro/"
"#cooperation>`_."
msgstr ""
"La implementación completa en C puede encontrarse en :c:func:`!"
"super_getattro` en :source:`Objects/typeobject.c`.  Un equivalente en Python "
"puro puede encontrarse en `Guido's Tutorial <https://www.python.org/download/"
"releases/2.2.3/descrintro/#cooperation>`_."

#: ../../howto/descriptor.rst:804
msgid "Summary of invocation logic"
msgstr "Resumen de la lógica de invocación"

#: ../../howto/descriptor.rst:806
msgid ""
"The mechanism for descriptors is embedded in the :meth:`~object."
"__getattribute__` methods for :class:`object`, :class:`type`, and :func:"
"`super`."
msgstr ""
"El mecanismo de los descriptores está integrado en los métodos :meth:"
"`~object.__getattribute__` para :class:`object`, :class:`type` y :func:"
"`super`."

#: ../../howto/descriptor.rst:809
msgid "The important points to remember are:"
msgstr "Los puntos importantes a recordar son:"

#: ../../howto/descriptor.rst:811
msgid "Descriptors are invoked by the :meth:`~object.__getattribute__` method."
msgstr ""
"Los descriptores se invocan mediante el método :meth:`~object."
"__getattribute__`."

#: ../../howto/descriptor.rst:813
msgid ""
"Classes inherit this machinery from :class:`object`, :class:`type`, or :func:"
"`super`."
msgstr ""
"Las clases heredan esta maquinaria de :class:`object`, :class:`type`, o :"
"func:`super`."

#: ../../howto/descriptor.rst:816
msgid ""
"Overriding :meth:`~object.__getattribute__` prevents automatic descriptor "
"calls because all the descriptor logic is in that method."
msgstr ""
"Anulando :meth:`~object.__getattribute__` se evitan las llamadas automáticas "
"al descriptor porque toda la lógica del descriptor está en ese método."

#: ../../howto/descriptor.rst:819
msgid ""
":meth:`!object.__getattribute__` and :meth:`!type.__getattribute__` make "
"different calls to :meth:`~object.__get__`.  The first includes the instance "
"and may include the class.  The second puts in ``None`` for the instance and "
"always includes the class."
msgstr ""
":meth:`!object.__getattribute__` y :meth:`!type.__getattribute__` hacen "
"diferentes llamadas a :meth:`~object.__get__`. La primera incluye la "
"instancia y puede incluir la clase.  La segunda pone ``None`` para la "
"instancia y siempre incluye la clase."

#: ../../howto/descriptor.rst:824
msgid "Data descriptors always override instance dictionaries."
msgstr ""
"Los descriptores de datos siempre anulan los diccionarios de instancias."

#: ../../howto/descriptor.rst:826
msgid "Non-data descriptors may be overridden by instance dictionaries."
msgstr ""
"Los diccionarios de instancias pueden anular los descriptores que no son de "
"datos."

#: ../../howto/descriptor.rst:830
msgid "Automatic name notification"
msgstr "Notificación automática de nombre"

#: ../../howto/descriptor.rst:832
msgid ""
"Sometimes it is desirable for a descriptor to know what class variable name "
"it was assigned to.  When a new class is created, the :class:`type` "
"metaclass scans the dictionary of the new class.  If any of the entries are "
"descriptors and if they define :meth:`~object.__set_name__`, that method is "
"called with two arguments.  The *owner* is the class where the descriptor is "
"used, and the *name* is the class variable the descriptor was assigned to."
msgstr ""
"A veces es deseable que un descriptor sepa a qué nombre de variable de clase "
"fue asignado.  Cuando se crea una nueva clase, la metaclase :class:`type` "
"explora el diccionario de la nueva clase.  Si alguna de las entradas son "
"descriptores y si definen :meth:`~object.__set_name__`, se llama a ese "
"método con dos argumentos.  El *propietario* es la clase en la que se "
"utiliza el descriptor, y el *nombre* es la variable de clase a la que se "
"asignó el descriptor."

#: ../../howto/descriptor.rst:839
msgid ""
"The implementation details are in :c:func:`!type_new` and :c:func:`!"
"set_names` in :source:`Objects/typeobject.c`."
msgstr ""
"Los detalles de implementación están en :c:func:`!type_new` y :c:func:`!"
"set_names` en :source:`Objects/typeobject.c`."

#: ../../howto/descriptor.rst:842
msgid ""
"Since the update logic is in :meth:`!type.__new__`, notifications only take "
"place at the time of class creation.  If descriptors are added to the class "
"afterwards, :meth:`~object.__set_name__` will need to be called manually."
msgstr ""
"Dado que la lógica de actualización se encuentra en :meth:`!type.__new__`, "
"las notificaciones sólo tienen lugar en el momento de la creación de la "
"clase.  Si después se añaden descriptores a la clase, habrá que llamar "
"manualmente a :meth:`~object.__set_name__`."

#: ../../howto/descriptor.rst:848
msgid "ORM example"
msgstr "Ejemplo ORM"

#: ../../howto/descriptor.rst:850
msgid ""
"The following code is a simplified skeleton showing how data descriptors "
"could be used to implement an `object relational mapping <https://en."
"wikipedia.org/wiki/Object%E2%80%93relational_mapping>`_."
msgstr ""
"El siguiente código es un esqueleto simplificado que muestra cómo se pueden "
"usar los descriptores de datos para implementar un 'object relational "
"mapping <https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping>`_."

#: ../../howto/descriptor.rst:854
msgid ""
"The essential idea is that the data is stored in an external database.  The "
"Python instances only hold keys to the database's tables.  Descriptors take "
"care of lookups or updates:"
msgstr ""
"La idea esencial es que los datos se almacenan en una base de datos "
"externa.  Las instancias de Python sólo contienen las claves de las tablas "
"de la base de datos.  Los descriptores se encargan de las búsquedas o "
"actualizaciones:"

#: ../../howto/descriptor.rst:858
msgid ""
"class Field:\n"
"\n"
"    def __set_name__(self, owner, name):\n"
"        self.fetch = f'SELECT {name} FROM {owner.table} WHERE {owner.key}"
"=?;'\n"
"        self.store = f'UPDATE {owner.table} SET {name}=? WHERE {owner.key}"
"=?;'\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        return conn.execute(self.fetch, [obj.key]).fetchone()[0]\n"
"\n"
"    def __set__(self, obj, value):\n"
"        conn.execute(self.store, [value, obj.key])\n"
"        conn.commit()"
msgstr ""
"class Field:\n"
"\n"
"    def __set_name__(self, owner, name):\n"
"        self.fetch = f'SELECT {name} FROM {owner.table} WHERE {owner.key}"
"=?;'\n"
"        self.store = f'UPDATE {owner.table} SET {name}=? WHERE {owner.key}"
"=?;'\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        return conn.execute(self.fetch, [obj.key]).fetchone()[0]\n"
"\n"
"    def __set__(self, obj, value):\n"
"        conn.execute(self.store, [value, obj.key])\n"
"        conn.commit()"

#: ../../howto/descriptor.rst:873
msgid ""
"We can use the :class:`!Field` class to define `models <https://en.wikipedia."
"org/wiki/Database_model>`_ that describe the schema for each table in a "
"database:"
msgstr ""
"Podemos utilizar la clase :class:`!Field` para definir `modelos <https://en."
"wikipedia.org/wiki/Database_model>`_ que describan el esquema de cada tabla "
"de una base de datos:"

#: ../../howto/descriptor.rst:877
msgid ""
"class Movie:\n"
"    table = 'Movies'                    # Table name\n"
"    key = 'title'                       # Primary key\n"
"    director = Field()\n"
"    year = Field()\n"
"\n"
"    def __init__(self, key):\n"
"        self.key = key\n"
"\n"
"class Song:\n"
"    table = 'Music'\n"
"    key = 'title'\n"
"    artist = Field()\n"
"    year = Field()\n"
"    genre = Field()\n"
"\n"
"    def __init__(self, key):\n"
"        self.key = key"
msgstr ""
"class Movie:\n"
"    table = 'Movies'                    # Nombre de la tabla\n"
"    key = 'title'                       # Clave principal\n"
"    director = Field()\n"
"    year = Field()\n"
"\n"
"    def __init__(self, key):\n"
"        self.key = key\n"
"\n"
"class Song:\n"
"    table = 'Music'\n"
"    key = 'title'\n"
"    artist = Field()\n"
"    year = Field()\n"
"    genre = Field()\n"
"\n"
"    def __init__(self, key):\n"
"        self.key = key"

#: ../../howto/descriptor.rst:898
msgid "To use the models, first connect to the database::"
msgstr "Para utilizar los modelos, conéctese primero a la base de datos::"

#: ../../howto/descriptor.rst:900
msgid ""
">>> import sqlite3\n"
">>> conn = sqlite3.connect('entertainment.db')"
msgstr ""
">>> import sqlite3\n"
">>> conn = sqlite3.connect('entertainment.db')"

#: ../../howto/descriptor.rst:903
msgid ""
"An interactive session shows how data is retrieved from the database and how "
"it can be updated:"
msgstr ""
"Una sesión interactiva muestra cómo se recuperan los datos de la base de "
"datos y cómo pueden actualizarse:"

#: ../../howto/descriptor.rst:931
msgid ""
">>> Movie('Star Wars').director\n"
"'George Lucas'\n"
">>> jaws = Movie('Jaws')\n"
">>> f'Released in {jaws.year} by {jaws.director}'\n"
"'Released in 1975 by Steven Spielberg'\n"
"\n"
">>> Song('Country Roads').artist\n"
"'John Denver'\n"
"\n"
">>> Movie('Star Wars').director = 'J.J. Abrams'\n"
">>> Movie('Star Wars').director\n"
"'J.J. Abrams'"
msgstr ""
">>> Movie('Star Wars').director\n"
"'George Lucas'\n"
">>> jaws = Movie('Jaws')\n"
">>> f'Released in {jaws.year} by {jaws.director}'\n"
"'Released in 1975 by Steven Spielberg'\n"
"\n"
">>> Song('Country Roads').artist\n"
"'John Denver'\n"
"\n"
">>> Movie('Star Wars').director = 'J.J. Abrams'\n"
">>> Movie('Star Wars').director\n"
"'J.J. Abrams'"

#: ../../howto/descriptor.rst:952
msgid "Pure Python Equivalents"
msgstr "Equivalentes de Python puro"

#: ../../howto/descriptor.rst:954
msgid ""
"The descriptor protocol is simple and offers exciting possibilities.  "
"Several use cases are so common that they have been prepackaged into built-"
"in tools. Properties, bound methods, static methods, class methods, and "
"\\_\\_slots\\_\\_ are all based on the descriptor protocol."
msgstr ""
"El protocolo de los descriptores es sencillo y ofrece interesantes "
"posibilidades.  Varios casos de uso son tan comunes que han sido "
"preempaquetados en herramientas integradas. Propiedades, métodos vinculados, "
"métodos estáticos, métodos de clase, y \\_\\_slots\\_\\_ todos se basan en "
"el protocolo descriptor."

#: ../../howto/descriptor.rst:961
msgid "Properties"
msgstr "Propiedades"

#: ../../howto/descriptor.rst:963
msgid ""
"Calling :func:`property` is a succinct way of building a data descriptor "
"that triggers a function call upon access to an attribute.  Its signature "
"is::"
msgstr ""
"Calling :func:`property` es una forma sucinta de construir un descriptor de "
"datos que desencadena una llamada a una función al acceder a un atributo.  "
"Su firma es::"

#: ../../howto/descriptor.rst:966
msgid "property(fget=None, fset=None, fdel=None, doc=None) -> property"
msgstr "property(fget=None, fset=None, fdel=None, doc=None) -> property"

#: ../../howto/descriptor.rst:968
msgid ""
"The documentation shows a typical use to define a managed attribute ``x``:"
msgstr ""
"La documentación muestra un uso típico para definir un atributo gestionado "
"``x``:"

#: ../../howto/descriptor.rst:970
msgid ""
"class C:\n"
"    def getx(self): return self.__x\n"
"    def setx(self, value): self.__x = value\n"
"    def delx(self): del self.__x\n"
"    x = property(getx, setx, delx, \"I'm the 'x' property.\")"
msgstr ""
"class C:\n"
"    def getx(self): return self.__x\n"
"    def setx(self, value): self.__x = value\n"
"    def delx(self): del self.__x\n"
"    x = property(getx, setx, delx, \"I'm the 'x' property.\")"

#: ../../howto/descriptor.rst:992
msgid ""
"To see how :func:`property` is implemented in terms of the descriptor "
"protocol, here is a pure Python equivalent:"
msgstr ""
"Para ver cómo se implementa :func:`property` en términos del protocolo "
"descriptor, aquí hay un equivalente en Python puro:"

#: ../../howto/descriptor.rst:995
msgid ""
"class Property:\n"
"    \"Emulate PyProperty_Type() in Objects/descrobject.c\"\n"
"\n"
"    def __init__(self, fget=None, fset=None, fdel=None, doc=None):\n"
"        self.fget = fget\n"
"        self.fset = fset\n"
"        self.fdel = fdel\n"
"        if doc is None and fget is not None:\n"
"            doc = fget.__doc__\n"
"        self.__doc__ = doc\n"
"        self._name = ''\n"
"\n"
"    def __set_name__(self, owner, name):\n"
"        self._name = name\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        if obj is None:\n"
"            return self\n"
"        if self.fget is None:\n"
"            raise AttributeError(\n"
"                f'property {self._name!r} of {type(obj).__name__!r} object "
"has no getter'\n"
"             )\n"
"        return self.fget(obj)\n"
"\n"
"    def __set__(self, obj, value):\n"
"        if self.fset is None:\n"
"            raise AttributeError(\n"
"                f'property {self._name!r} of {type(obj).__name__!r} object "
"has no setter'\n"
"             )\n"
"        self.fset(obj, value)\n"
"\n"
"    def __delete__(self, obj):\n"
"        if self.fdel is None:\n"
"            raise AttributeError(\n"
"                f'property {self._name!r} of {type(obj).__name__!r} object "
"has no deleter'\n"
"             )\n"
"        self.fdel(obj)\n"
"\n"
"    def getter(self, fget):\n"
"        prop = type(self)(fget, self.fset, self.fdel, self.__doc__)\n"
"        prop._name = self._name\n"
"        return prop\n"
"\n"
"    def setter(self, fset):\n"
"        prop = type(self)(self.fget, fset, self.fdel, self.__doc__)\n"
"        prop._name = self._name\n"
"        return prop\n"
"\n"
"    def deleter(self, fdel):\n"
"        prop = type(self)(self.fget, self.fset, fdel, self.__doc__)\n"
"        prop._name = self._name\n"
"        return prop"
msgstr ""
"class Property:\n"
"    \"Emulate PyProperty_Type() in Objects/descrobject.c\"\n"
"\n"
"    def __init__(self, fget=None, fset=None, fdel=None, doc=None):\n"
"        self.fget = fget\n"
"        self.fset = fset\n"
"        self.fdel = fdel\n"
"        if doc is None and fget is not None:\n"
"            doc = fget.__doc__\n"
"        self.__doc__ = doc\n"
"        self._name = ''\n"
"\n"
"    def __set_name__(self, owner, name):\n"
"        self._name = name\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        if obj is None:\n"
"            return self\n"
"        if self.fget is None:\n"
"            raise AttributeError(\n"
"                f'property {self._name!r} of {type(obj).__name__!r} object "
"has no getter'\n"
"             )\n"
"        return self.fget(obj)\n"
"\n"
"    def __set__(self, obj, value):\n"
"        if self.fset is None:\n"
"            raise AttributeError(\n"
"                f'property {self._name!r} of {type(obj).__name__!r} object "
"has no setter'\n"
"             )\n"
"        self.fset(obj, value)\n"
"\n"
"    def __delete__(self, obj):\n"
"        if self.fdel is None:\n"
"            raise AttributeError(\n"
"                f'property {self._name!r} of {type(obj).__name__!r} object "
"has no deleter'\n"
"             )\n"
"        self.fdel(obj)\n"
"\n"
"    def getter(self, fget):\n"
"        prop = type(self)(fget, self.fset, self.fdel, self.__doc__)\n"
"        prop._name = self._name\n"
"        return prop\n"
"\n"
"    def setter(self, fset):\n"
"        prop = type(self)(self.fget, fset, self.fdel, self.__doc__)\n"
"        prop._name = self._name\n"
"        return prop\n"
"\n"
"    def deleter(self, fdel):\n"
"        prop = type(self)(self.fget, self.fset, fdel, self.__doc__)\n"
"        prop._name = self._name\n"
"        return prop"

#: ../../howto/descriptor.rst:1132
msgid ""
"The :func:`property` builtin helps whenever a user interface has granted "
"attribute access and then subsequent changes require the intervention of a "
"method."
msgstr ""
"El builtin :func:`property` ayuda siempre que una interfaz de usuario haya "
"concedido acceso a atributos y luego los cambios posteriores requieran la "
"intervención de un método."

#: ../../howto/descriptor.rst:1136
msgid ""
"For instance, a spreadsheet class may grant access to a cell value through "
"``Cell('b10').value``. Subsequent improvements to the program require the "
"cell to be recalculated on every access; however, the programmer does not "
"want to affect existing client code accessing the attribute directly.  The "
"solution is to wrap access to the value attribute in a property data "
"descriptor:"
msgstr ""
"Por ejemplo, una clase de hoja de cálculo puede permitir el acceso al valor "
"de una celda a través de ``Cell('b10').value``. Las mejoras posteriores del "
"programa requieren que la celda se recalcule en cada acceso; sin embargo, el "
"programador no quiere afectar al código cliente existente que accede "
"directamente al atributo.  La solución es envolver el acceso al atributo de "
"valor en un descriptor de datos de propiedad:"

#: ../../howto/descriptor.rst:1142
msgid ""
"class Cell:\n"
"    ...\n"
"\n"
"    @property\n"
"    def value(self):\n"
"        \"Recalculate the cell before returning value\"\n"
"        self.recalc()\n"
"        return self._value"
msgstr ""
"class Cell:\n"
"    ...\n"
"\n"
"    @property\n"
"    def value(self):\n"
"        \"Recalcular la celda antes de devolver el valor\"\n"
"        self.recalc()\n"
"        return self._value"

#: ../../howto/descriptor.rst:1153
msgid ""
"Either the built-in :func:`property` or our :func:`!Property` equivalent "
"would work in this example."
msgstr ""
"En este ejemplo, puede utilizarse :func:`property` o nuestro equivalente :"
"func:`!Property`."

#: ../../howto/descriptor.rst:1158
msgid "Functions and methods"
msgstr "Funciones y métodos"

#: ../../howto/descriptor.rst:1160
msgid ""
"Python's object oriented features are built upon a function based "
"environment. Using non-data descriptors, the two are merged seamlessly."
msgstr ""
"Las características orientadas a objetos de Python se basan en un entorno "
"basado en funciones. Utilizando descriptores sin datos, ambos se fusionan a "
"la perfección."

#: ../../howto/descriptor.rst:1163
msgid ""
"Functions stored in class dictionaries get turned into methods when invoked. "
"Methods only differ from regular functions in that the object instance is "
"prepended to the other arguments.  By convention, the instance is called "
"*self* but could be called *this* or any other variable name."
msgstr ""
"Las funciones almacenadas en los diccionarios de clase se convierten en "
"métodos cuando se invocan. Los métodos sólo se diferencian de las funciones "
"normales en que la instancia del objeto se antepone a los otros argumentos.  "
"Por convención, la instancia se llama *self* pero podría llamarse *this* o "
"cualquier otro nombre de variable."

#: ../../howto/descriptor.rst:1168
msgid ""
"Methods can be created manually with :class:`types.MethodType` which is "
"roughly equivalent to:"
msgstr ""
"Los métodos pueden crearse manualmente con :class:`types.MethodType`, que "
"equivale aproximadamente a:"

#: ../../howto/descriptor.rst:1171
msgid ""
"class MethodType:\n"
"    \"Emulate PyMethod_Type in Objects/classobject.c\"\n"
"\n"
"    def __init__(self, func, obj):\n"
"        self.__func__ = func\n"
"        self.__self__ = obj\n"
"\n"
"    def __call__(self, *args, **kwargs):\n"
"        func = self.__func__\n"
"        obj = self.__self__\n"
"        return func(obj, *args, **kwargs)"
msgstr ""
"class MethodType:\n"
"    \"Emulate PyMethod_Type in Objects/classobject.c\"\n"
"\n"
"    def __init__(self, func, obj):\n"
"        self.__func__ = func\n"
"        self.__self__ = obj\n"
"\n"
"    def __call__(self, *args, **kwargs):\n"
"        func = self.__func__\n"
"        obj = self.__self__\n"
"        return func(obj, *args, **kwargs)"

#: ../../howto/descriptor.rst:1185
msgid ""
"To support automatic creation of methods, functions include the :meth:"
"`~object.__get__` method for binding methods during attribute access.  This "
"means that functions are non-data descriptors that return bound methods "
"during dotted lookup from an instance.  Here's how it works:"
msgstr ""
"Para soportar la creación automática de métodos, las funciones incluyen el "
"método :meth:`~object.__get__` para enlazar métodos durante el acceso a "
"atributos.  Esto significa que las funciones son descriptores no de datos "
"que devuelven métodos vinculados durante la búsqueda por puntos desde una "
"instancia.  Así es como funciona:"

#: ../../howto/descriptor.rst:1190
msgid ""
"class Function:\n"
"    ...\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        \"Simulate func_descr_get() in Objects/funcobject.c\"\n"
"        if obj is None:\n"
"            return self\n"
"        return MethodType(self, obj)"
msgstr ""
"class Function:\n"
"    ...\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        \"Simula func_descr_get() en Objects/funcobject.c\"\n"
"        if obj is None:\n"
"            return self\n"
"        return MethodType(self, obj)"

#: ../../howto/descriptor.rst:1201
msgid ""
"Running the following class in the interpreter shows how the function "
"descriptor works in practice:"
msgstr ""
"La ejecución de la siguiente clase en el intérprete muestra cómo funciona en "
"la práctica el descriptor de función:"

#: ../../howto/descriptor.rst:1204
msgid ""
"class D:\n"
"    def f(self, x):\n"
"         return x"
msgstr ""
"class D:\n"
"    def f(self, x):\n"
"         return x"

#: ../../howto/descriptor.rst:1210
msgid ""
"The function has a :term:`qualified name` attribute to support introspection:"
msgstr ""
"La función tiene un atributo :term:`qualified name` para soportar la "
"introspección:"

#: ../../howto/descriptor.rst:1212
msgid ""
">>> D.f.__qualname__\n"
"'D.f'"
msgstr ""
">>> D.f.__qualname__\n"
"'D.f'"

#: ../../howto/descriptor.rst:1217
msgid ""
"Accessing the function through the class dictionary does not invoke :meth:"
"`~object.__get__`.  Instead, it just returns the underlying function object::"
msgstr ""
"El acceso a la función a través del diccionario de clases no invoca :meth:"
"`~object.__get__`.  En su lugar, sólo devuelve el objeto de función "
"subyacente::"

#: ../../howto/descriptor.rst:1220
msgid ""
">>> D.__dict__['f']\n"
"<function D.f at 0x00C45070>"
msgstr ""
">>> D.__dict__['f']\n"
"<function D.f at 0x00C45070>"

#: ../../howto/descriptor.rst:1223
msgid ""
"Dotted access from a class calls :meth:`~object.__get__` which just returns "
"the underlying function unchanged::"
msgstr ""
"El acceso punteado desde una clase llama a :meth:`~object.__get__` que "
"simplemente devuelve la función subyacente sin cambios::"

#: ../../howto/descriptor.rst:1226
msgid ""
">>> D.f\n"
"<function D.f at 0x00C45070>"
msgstr ""
">>> D.f\n"
"<function D.f at 0x00C45070>"

#: ../../howto/descriptor.rst:1229
msgid ""
"The interesting behavior occurs during dotted access from an instance.  The "
"dotted lookup calls :meth:`~object.__get__` which returns a bound method "
"object::"
msgstr ""
"El comportamiento interesante se produce durante el acceso punteado desde "
"una instancia.  La búsqueda punteada llama a :meth:`~object.__get__`, que "
"devuelve un objeto de método vinculado::"

#: ../../howto/descriptor.rst:1232
msgid ""
">>> d = D()\n"
">>> d.f\n"
"<bound method D.f of <__main__.D object at 0x00B18C90>>"
msgstr ""
">>> d = D()\n"
">>> d.f\n"
"<bound method D.f of <__main__.D object at 0x00B18C90>>"

#: ../../howto/descriptor.rst:1236
msgid ""
"Internally, the bound method stores the underlying function and the bound "
"instance::"
msgstr ""
"Internamente, el método vinculado almacena la función subyacente y la "
"instancia vinculada::"

#: ../../howto/descriptor.rst:1239
msgid ""
">>> d.f.__func__\n"
"<function D.f at 0x00C45070>\n"
"\n"
">>> d.f.__self__\n"
"<__main__.D object at 0x00B18C90>"
msgstr ""
">>> d.f.__func__\n"
"<function D.f at 0x00C45070>\n"
"\n"
">>> d.f.__self__\n"
"<__main__.D object at 0x00B18C90>"

#: ../../howto/descriptor.rst:1245
msgid ""
"If you have ever wondered where *self* comes from in regular methods or "
"where *cls* comes from in class methods, this is it!"
msgstr ""
"Si alguna vez te has preguntado de dónde viene *self* en los métodos "
"normales o de dónde viene *cls* en los métodos de clase, ¡es aquí!"

#: ../../howto/descriptor.rst:1250
msgid "Kinds of methods"
msgstr "Tipos de métodos"

#: ../../howto/descriptor.rst:1252
msgid ""
"Non-data descriptors provide a simple mechanism for variations on the usual "
"patterns of binding functions into methods."
msgstr ""
"Los descriptores sin datos ofrecen un mecanismo sencillo para variar los "
"patrones habituales de vinculación de funciones a métodos."

#: ../../howto/descriptor.rst:1255
msgid ""
"To recap, functions have a :meth:`~object.__get__` method so that they can "
"be converted to a method when accessed as attributes.  The non-data "
"descriptor transforms an ``obj.f(*args)`` call into ``f(obj, *args)``.  "
"Calling ``cls.f(*args)`` becomes ``f(*args)``."
msgstr ""
"Para recapitular, las funciones tienen un método :meth:`~object.__get__` "
"para que puedan convertirse en un método cuando se accede a ellas como "
"atributos.  El descriptor sin datos transforma una llamada a ``obj."
"f(*args)`` en ``f(obj, *args)``.  Una llamada a ``cls.f(*args)`` se "
"convierte en ``f(*args)``."

#: ../../howto/descriptor.rst:1260
msgid "This chart summarizes the binding and its two most useful variants:"
msgstr "Este cuadro resume la encuadernación y sus dos variantes más útiles:"

#: ../../howto/descriptor.rst:1263
msgid "Transformation"
msgstr "Transformación"

#: ../../howto/descriptor.rst:1263
msgid "Called from an object"
msgstr "Llamada desde un objeto"

#: ../../howto/descriptor.rst:1263
msgid "Called from a class"
msgstr "Llamada desde una clase"

#: ../../howto/descriptor.rst:1266
msgid "function"
msgstr "función"

#: ../../howto/descriptor.rst:1266
msgid "f(obj, \\*args)"
msgstr "f(obj, \\*args)"

#: ../../howto/descriptor.rst:1266 ../../howto/descriptor.rst:1268
msgid "f(\\*args)"
msgstr "f(\\*args)"

#: ../../howto/descriptor.rst:1268
msgid "staticmethod"
msgstr "método estático"

#: ../../howto/descriptor.rst:1270
msgid "classmethod"
msgstr "classmethod"

#: ../../howto/descriptor.rst:1270
msgid "f(type(obj), \\*args)"
msgstr "f(type(obj), \\*args)"

#: ../../howto/descriptor.rst:1270
msgid "f(cls, \\*args)"
msgstr "f(cls, \\*args)"

#: ../../howto/descriptor.rst:1275
msgid "Static methods"
msgstr "Métodos estáticos"

#: ../../howto/descriptor.rst:1277
msgid ""
"Static methods return the underlying function without changes.  Calling "
"either ``c.f`` or ``C.f`` is the equivalent of a direct lookup into ``object."
"__getattribute__(c, \"f\")`` or ``object.__getattribute__(C, \"f\")``. As a "
"result, the function becomes identically accessible from either an object or "
"a class."
msgstr ""
"Los métodos estáticos devuelven la función subyacente sin cambios.  Llamar a "
"``c.f`` o ``C.f`` es equivalente a una búsqueda directa en ``object."
"__getattribute__(c, \"f\")`` o ``object.__getattribute__(C, \"f\")``. Como "
"resultado, la función es idénticamente accesible desde un objeto o una clase."

#: ../../howto/descriptor.rst:1283
msgid ""
"Good candidates for static methods are methods that do not reference the "
"``self`` variable."
msgstr ""
"Los buenos candidatos para los métodos estáticos son los métodos que no "
"hacen referencia a la variable ``self``."

#: ../../howto/descriptor.rst:1286
msgid ""
"For instance, a statistics package may include a container class for "
"experimental data.  The class provides normal methods for computing the "
"average, mean, median, and other descriptive statistics that depend on the "
"data. However, there may be useful functions which are conceptually related "
"but do not depend on the data.  For instance, ``erf(x)`` is handy conversion "
"routine that comes up in statistical work but does not directly depend on a "
"particular dataset. It can be called either from an object or the class:  "
"``s.erf(1.5) --> .9332`` or ``Sample.erf(1.5) --> .9332``."
msgstr ""
"Por ejemplo, un paquete estadístico puede incluir una clase contenedora para "
"datos experimentales.  La clase proporciona métodos normales para calcular "
"la media, el promedio, la mediana y otros estadísticos descriptivos que "
"dependen de los datos. Sin embargo, puede haber funciones útiles que estén "
"conceptualmente relacionadas pero que no dependan de los datos.  Por "
"ejemplo, ``erf(x)`` es una práctica rutina de conversión que aparece en el "
"trabajo estadístico pero que no depende directamente de un conjunto de datos "
"concreto. Se puede llamar desde un objeto o desde la clase: ``s.erf(1.5) --"
"> .9332`` o ``Sample.erf(1.5) --> .9332``."

#: ../../howto/descriptor.rst:1295
msgid ""
"Since static methods return the underlying function with no changes, the "
"example calls are unexciting:"
msgstr ""
"Dado que los métodos estáticos devuelven la función subyacente sin cambios, "
"las llamadas de ejemplo no son emocionantes:"

#: ../../howto/descriptor.rst:1298
msgid ""
"class E:\n"
"    @staticmethod\n"
"    def f(x):\n"
"        return x * 10"
msgstr ""
"class E:\n"
"    @staticmethod\n"
"    def f(x):\n"
"        return x * 10"

#: ../../howto/descriptor.rst:1305
msgid ""
">>> E.f(3)\n"
"30\n"
">>> E().f(3)\n"
"30"
msgstr ""
">>> E.f(3)\n"
"30\n"
">>> E().f(3)\n"
"30"

#: ../../howto/descriptor.rst:1312
msgid ""
"Using the non-data descriptor protocol, a pure Python version of :func:"
"`staticmethod` would look like this:"
msgstr ""
"Utilizando el protocolo sin descriptor de datos, una versión en Python puro "
"de :func:`staticmethod` tendría este aspecto:"

#: ../../howto/descriptor.rst:1315
msgid ""
"import functools\n"
"\n"
"class StaticMethod:\n"
"    \"Emulate PyStaticMethod_Type() in Objects/funcobject.c\"\n"
"\n"
"    def __init__(self, f):\n"
"        self.f = f\n"
"        functools.update_wrapper(self, f)\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        return self.f\n"
"\n"
"    def __call__(self, *args, **kwds):\n"
"        return self.f(*args, **kwds)"
msgstr ""
"import functools\n"
"\n"
"class StaticMethod:\n"
"    \"Emular PyStaticMethod_Type() en Objects/funcobject.c\"\n"
"\n"
"    def __init__(self, f):\n"
"        self.f = f\n"
"        functools.update_wrapper(self, f)\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        return self.f\n"
"\n"
"    def __call__(self, *args, **kwds):\n"
"        return self.f(*args, **kwds)"

#: ../../howto/descriptor.rst:1332
msgid ""
"The :func:`functools.update_wrapper` call adds a ``__wrapped__`` attribute "
"that refers to the underlying function.  Also it carries forward the "
"attributes necessary to make the wrapper look like the wrapped function: :"
"attr:`~function.__name__`, :attr:`~function.__qualname__`, :attr:`~function."
"__doc__`, and :attr:`~function.__annotations__`."
msgstr ""
"La llamada a :func:`functools.update_wrapper` añade un atributo "
"``__wrapped__`` que hace referencia a la función subyacente.  También "
"transporta los atributos necesarios para que la envoltura se parezca a la "
"función envuelta: :attr:`~function.__name__`, :attr:`~function."
"__qualname__`, :attr:`~function.__doc__`, y :attr:`~function."
"__annotations__`."

#: ../../howto/descriptor.rst:1401
msgid "Class methods"
msgstr "Métodos de clase"

#: ../../howto/descriptor.rst:1403
msgid ""
"Unlike static methods, class methods prepend the class reference to the "
"argument list before calling the function.  This format is the same for "
"whether the caller is an object or a class:"
msgstr ""
"A diferencia de los métodos estáticos, los métodos de clase anteponen la "
"referencia de clase a la lista de argumentos antes de llamar a la función.  "
"Este formato es el mismo tanto si el invocador es un objeto como si es una "
"clase:"

#: ../../howto/descriptor.rst:1407
msgid ""
"class F:\n"
"    @classmethod\n"
"    def f(cls, x):\n"
"        return cls.__name__, x"
msgstr ""
"class F:\n"
"    @classmethod\n"
"    def f(cls, x):\n"
"        return cls.__name__, x"

#: ../../howto/descriptor.rst:1414
msgid ""
">>> F.f(3)\n"
"('F', 3)\n"
">>> F().f(3)\n"
"('F', 3)"
msgstr ""
">>> F.f(3)\n"
"('F', 3)\n"
">>> F().f(3)\n"
"('F', 3)"

#: ../../howto/descriptor.rst:1421
msgid ""
"This behavior is useful whenever the method only needs to have a class "
"reference and does not rely on data stored in a specific instance.  One use "
"for class methods is to create alternate class constructors.  For example, "
"the classmethod :func:`dict.fromkeys` creates a new dictionary from a list "
"of keys.  The pure Python equivalent is:"
msgstr ""
"Este comportamiento es útil cuando el método sólo necesita tener una "
"referencia a la clase y no depende de los datos almacenados en una instancia "
"específica.  Un uso de los métodos de clase es crear constructores de clase "
"alternativos.  Por ejemplo, el método de clase :func:`dict.fromkeys` crea un "
"nuevo diccionario a partir de una lista de claves.  El equivalente en Python "
"puro es:"

#: ../../howto/descriptor.rst:1427
msgid ""
"class Dict(dict):\n"
"    @classmethod\n"
"    def fromkeys(cls, iterable, value=None):\n"
"        \"Emulate dict_fromkeys() in Objects/dictobject.c\"\n"
"        d = cls()\n"
"        for key in iterable:\n"
"            d[key] = value\n"
"        return d"
msgstr ""
"class Dict(dict):\n"
"    @classmethod\n"
"    def fromkeys(cls, iterable, value=None):\n"
"        \"Emular dict_fromkeys() en Objects/dictobject.c\"\n"
"        d = cls()\n"
"        for key in iterable:\n"
"            d[key] = value\n"
"        return d"

#: ../../howto/descriptor.rst:1438
msgid "Now a new dictionary of unique keys can be constructed like this:"
msgstr ""
"Ahora se puede construir un nuevo diccionario de claves únicas de la "
"siguiente manera:"

#: ../../howto/descriptor.rst:1440
msgid ""
">>> d = Dict.fromkeys('abracadabra')\n"
">>> type(d) is Dict\n"
"True\n"
">>> d\n"
"{'a': None, 'b': None, 'r': None, 'c': None, 'd': None}"
msgstr ""
">>> d = Dict.fromkeys('abracadabra')\n"
">>> type(d) es Dict\n"
"True\n"
">>> d\n"
"{'a': Ninguno, 'b': Ninguno, 'r': Ninguno, 'c': Ninguno, 'd': Ninguno}"

#: ../../howto/descriptor.rst:1448
msgid ""
"Using the non-data descriptor protocol, a pure Python version of :func:"
"`classmethod` would look like this:"
msgstr ""
"Utilizando el protocolo sin descriptor de datos, una versión en Python puro "
"de :func:`classmethod` tendría este aspecto:"

#: ../../howto/descriptor.rst:1451
msgid ""
"import functools\n"
"\n"
"class ClassMethod:\n"
"    \"Emulate PyClassMethod_Type() in Objects/funcobject.c\"\n"
"\n"
"    def __init__(self, f):\n"
"        self.f = f\n"
"        functools.update_wrapper(self, f)\n"
"\n"
"    def __get__(self, obj, cls=None):\n"
"        if cls is None:\n"
"            cls = type(obj)\n"
"        if hasattr(type(self.f), '__get__'):\n"
"            # This code path was added in Python 3.9\n"
"            # and was deprecated in Python 3.11.\n"
"            return self.f.__get__(cls, cls)\n"
"        return MethodType(self.f, cls)"
msgstr ""
"import functools\n"
"\n"
"class ClassMethod:\n"
"    \"Emulate PyClassMethod_Type() in Objects/funcobject.c\"\n"
"\n"
"    def __init__(self, f):\n"
"        self.f = f\n"
"        functools.update_wrapper(self, f)\n"
"\n"
"    def __get__(self, obj, cls=None):\n"
"        if cls is None:\n"
"            cls = type(obj)\n"
"        if hasattr(type(self.f), '__get__'):\n"
"            # Esta ruta de código se añadió en Python 3.9\n"
"            # y fue obsoleta en Python 3.11.\n"
"            return self.f.__get__(cls, cls)\n"
"        return MethodType(self.f, cls)"

#: ../../howto/descriptor.rst:1526
msgid ""
"The code path for ``hasattr(type(self.f), '__get__')`` was added in Python "
"3.9 and makes it possible for :func:`classmethod` to support chained "
"decorators.  For example, a classmethod and property could be chained "
"together.  In Python 3.11, this functionality was deprecated."
msgstr ""
"La ruta de código para ``hasattr(type(self.f), '__get__')`` se añadió en "
"Python 3.9 y hace posible que :func:`classmethod` soporte decoradores "
"encadenados.  Por ejemplo, un classmethod y una propiedad pueden "
"encadenarse.  En Python 3.11, esta funcionalidad quedó obsoleta."

#: ../../howto/descriptor.rst:1531
msgid ""
"class G:\n"
"    @classmethod\n"
"    @property\n"
"    def __doc__(cls):\n"
"        return f'A doc for {cls.__name__!r}'"
msgstr ""
"class G:\n"
"    @classmethod\n"
"    @property\n"
"    def __doc__(cls):\n"
"        return f'A doc for {cls.__name__!r}'"

#: ../../howto/descriptor.rst:1539
msgid ""
">>> G.__doc__\n"
"\"A doc for 'G'\""
msgstr ""
">>> G.__doc__\n"
"\"Un doc para 'G'\""

#: ../../howto/descriptor.rst:1544
msgid ""
"The :func:`functools.update_wrapper` call in ``ClassMethod`` adds a "
"``__wrapped__`` attribute that refers to the underlying function.  Also it "
"carries forward the attributes necessary to make the wrapper look like the "
"wrapped function: :attr:`~function.__name__`, :attr:`~function."
"__qualname__`, :attr:`~function.__doc__`, and :attr:`~function."
"__annotations__`."
msgstr ""
"La llamada a :func:`functools.update_wrapper` en ``ClassMethod`` añade un "
"atributo ``__wrapped__`` que hace referencia a la función subyacente.  "
"También transporta los atributos necesarios para que la envoltura se parezca "
"a la función envuelta: :attr:`~function.__name__`, :attr:`~function."
"__qualname__`, :attr:`~function.__doc__`, y :attr:`~function."
"__annotations__`."

#: ../../howto/descriptor.rst:1553
msgid "Member objects and __slots__"
msgstr "Objetos miembros y __slots__"

#: ../../howto/descriptor.rst:1555
msgid ""
"When a class defines ``__slots__``, it replaces instance dictionaries with a "
"fixed-length array of slot values.  From a user point of view that has "
"several effects:"
msgstr ""
"Cuando una clase define ``__slots__``, sustituye los diccionarios de "
"instancia por una matriz de longitud fija de valores de ranura.  Desde el "
"punto de vista del usuario, esto tiene varios efectos:"

#: ../../howto/descriptor.rst:1559
msgid ""
"1. Provides immediate detection of bugs due to misspelled attribute "
"assignments.  Only attribute names specified in ``__slots__`` are allowed:"
msgstr ""
"1. Permite la detección inmediata de errores debidos a asignaciones de "
"atributos mal escritas.  Sólo se permiten los nombres de atributos "
"especificados en ``__slots__``:"

#: ../../howto/descriptor.rst:1562
msgid ""
"class Vehicle:\n"
"    __slots__ = ('id_number', 'make', 'model')"
msgstr ""
"class Vehicle:\n"
"    __slots__ = ('id_number', 'make', 'model')"

#: ../../howto/descriptor.rst:1567
msgid ""
">>> auto = Vehicle()\n"
">>> auto.id_nubmer = 'VYE483814LQEX'\n"
"Traceback (most recent call last):\n"
"    ...\n"
"AttributeError: 'Vehicle' object has no attribute 'id_nubmer'"
msgstr ""
">>> auto = Vehicle()\n"
">>> auto.id_nubmer = 'VYE483814LQEX'\n"
"Traceback (most recent call last):\n"
"    ...\n"
"AttributeError: 'Vehicle' object has no attribute 'id_nubmer'"

#: ../../howto/descriptor.rst:1575
msgid ""
"2. Helps create immutable objects where descriptors manage access to private "
"attributes stored in ``__slots__``:"
msgstr ""
"2. Ayuda a crear objetos inmutables en los que los descriptores gestionan el "
"acceso a los atributos privados almacenados en ``__slots__``:"

#: ../../howto/descriptor.rst:1578
msgid ""
"class Immutable:\n"
"\n"
"    __slots__ = ('_dept', '_name')          # Replace the instance "
"dictionary\n"
"\n"
"    def __init__(self, dept, name):\n"
"        self._dept = dept                   # Store to private attribute\n"
"        self._name = name                   # Store to private attribute\n"
"\n"
"    @property                               # Read-only descriptor\n"
"    def dept(self):\n"
"        return self._dept\n"
"\n"
"    @property\n"
"    def name(self):                         # Read-only descriptor\n"
"        return self._name"
msgstr ""
"clase Inmutable:\n"
"\n"
"    __slots__ = ('_dept', '_name') # Reemplazar el diccionario de instancia\n"
"\n"
"    def __init__(self, dept, name):\n"
"        self._dept = dept # Almacenar en atributo privado\n"
"        self._name = name # Almacenar en atributo privado\n"
"\n"
"    @property # Descriptor de sólo lectura\n"
"    def dept(self):\n"
"        return self._dept\n"
"\n"
"    @propiedad\n"
"    def nombre(self):                         # Descriptor de sólo lectura\n"
"        return self._name"

#: ../../howto/descriptor.rst:1596
msgid ""
">>> mark = Immutable('Botany', 'Mark Watney')\n"
">>> mark.dept\n"
"'Botany'\n"
">>> mark.dept = 'Space Pirate'\n"
"Traceback (most recent call last):\n"
"    ...\n"
"AttributeError: property 'dept' of 'Immutable' object has no setter\n"
">>> mark.location = 'Mars'\n"
"Traceback (most recent call last):\n"
"    ...\n"
"AttributeError: 'Immutable' object has no attribute 'location'"
msgstr ""
">>> mark = Immutable('Botany', 'Mark Watney')\n"
">>> mark.dept\n"
"'Botany'\n"
">>> mark.dept = 'Space Pirate'\n"
"Traceback (most recent call last):\n"
"    ...\n"
"AttributeError: property 'dept' of 'Immutable' object has no setter\n"
">>> mark.location = 'Mars'\n"
"Traceback (most recent call last):\n"
"    ...\n"
"AttributeError: 'Immutable' object has no attribute 'location'"

#: ../../howto/descriptor.rst:1610
msgid ""
"3. Saves memory.  On a 64-bit Linux build, an instance with two attributes "
"takes 48 bytes with ``__slots__`` and 152 bytes without.  This `flyweight "
"design pattern <https://en.wikipedia.org/wiki/Flyweight_pattern>`_ likely "
"only matters when a large number of instances are going to be created."
msgstr ""
"3. Ahorra memoria.  En una versión Linux de 64 bits, una instancia con dos "
"atributos ocupa 48 bytes con ``__slots__`` y 152 bytes sin .  Este `patrón "
"de diseño de peso ligero <https://en.wikipedia.org/wiki/Flyweight_pattern>`_ "
"probablemente sólo importa cuando se va a crear un gran número de instancias."

#: ../../howto/descriptor.rst:1615
msgid ""
"4. Improves speed.  Reading instance variables is 35% faster with "
"``__slots__`` (as measured with Python 3.10 on an Apple M1 processor)."
msgstr ""
"4. Mejora la velocidad.  La lectura de variables de instancia es un 35% más "
"rápida con ``__slots__`` (medido con Python 3.10 en un procesador Apple M1)."

#: ../../howto/descriptor.rst:1618
msgid ""
"5. Blocks tools like :func:`functools.cached_property` which require an "
"instance dictionary to function correctly:"
msgstr ""
"5. Bloquea herramientas como :func:`functools.cached_property`, que "
"requieren un diccionario de instancias para funcionar correctamente:"

#: ../../howto/descriptor.rst:1621
msgid ""
"from functools import cached_property\n"
"\n"
"class CP:\n"
"    __slots__ = ()                          # Eliminates the instance dict\n"
"\n"
"    @cached_property                        # Requires an instance dict\n"
"    def pi(self):\n"
"        return 4 * sum((-1.0)**n / (2.0*n + 1.0)\n"
"                       for n in reversed(range(100_000)))"
msgstr ""
"from functools import cached_property\n"
"\n"
"clase CP:\n"
"    __slots__ = () # Elimina el dictado de instancia\n"
"\n"
"    @cached_property # Requiere un dict de instancia\n"
"    def pi(self):\n"
"        return 4 * sum((-1.0)**n / (2.0*n + 1.0)\n"
"                       for n in reversed(range(100_000)))"

#: ../../howto/descriptor.rst:1633
msgid ""
">>> CP().pi\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: No '__dict__' attribute on 'CP' instance to cache 'pi' property."
msgstr ""
">>> CP().pi\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: No '__dict__' attribute on 'CP' instance to cache 'pi' property."

#: ../../howto/descriptor.rst:1640
msgid ""
"It is not possible to create an exact drop-in pure Python version of "
"``__slots__`` because it requires direct access to C structures and control "
"over object memory allocation.  However, we can build a mostly faithful "
"simulation where the actual C structure for slots is emulated by a private "
"``_slotvalues`` list.  Reads and writes to that private structure are "
"managed by member descriptors:"
msgstr ""
"No es posible crear una versión exacta en Python puro de ``__slots__`` "
"porque requiere acceso directo a estructuras C y control sobre la asignación "
"de memoria a objetos.  Sin embargo, podemos construir una simulación "
"bastante fiel en la que la estructura C real para las ranuras se emula "
"mediante una lista privada ``_slotvalues``.  Las lecturas y escrituras en "
"esa estructura privada se gestionan mediante descriptores de miembros:"

#: ../../howto/descriptor.rst:1647
msgid ""
"null = object()\n"
"\n"
"class Member:\n"
"\n"
"    def __init__(self, name, clsname, offset):\n"
"        'Emulate PyMemberDef in Include/structmember.h'\n"
"        # Also see descr_new() in Objects/descrobject.c\n"
"        self.name = name\n"
"        self.clsname = clsname\n"
"        self.offset = offset\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        'Emulate member_get() in Objects/descrobject.c'\n"
"        # Also see PyMember_GetOne() in Python/structmember.c\n"
"        if obj is None:\n"
"            return self\n"
"        value = obj._slotvalues[self.offset]\n"
"        if value is null:\n"
"            raise AttributeError(self.name)\n"
"        return value\n"
"\n"
"    def __set__(self, obj, value):\n"
"        'Emulate member_set() in Objects/descrobject.c'\n"
"        obj._slotvalues[self.offset] = value\n"
"\n"
"    def __delete__(self, obj):\n"
"        'Emulate member_delete() in Objects/descrobject.c'\n"
"        value = obj._slotvalues[self.offset]\n"
"        if value is null:\n"
"            raise AttributeError(self.name)\n"
"        obj._slotvalues[self.offset] = null\n"
"\n"
"    def __repr__(self):\n"
"        'Emulate member_repr() in Objects/descrobject.c'\n"
"        return f'<Member {self.name!r} of {self.clsname!r}>'"
msgstr ""
"null = object()\n"
"\n"
"class Member:\n"
"\n"
"    def __init__(self, name, clsname, offset):\n"
"        'Emulate PyMemberDef in Include/structmember.h'\n"
"        # Ver también descr_new() en Objects/descrobject.c\n"
"        self.name = name\n"
"        self.clsname = clsname\n"
"        self.offset = offset\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        'Emulate member_get() in Objects/descrobject.c'\n"
"        # Ver también PyMember_GetOne() en Python/structmember.c\n"
"        if obj is None:\n"
"            return self\n"
"        value = obj._slotvalues[self.offset]\n"
"        if value is null:\n"
"            raise AttributeError(self.name)\n"
"        return value\n"
"\n"
"    def __set__(self, obj, value):\n"
"        'Emulate member_set() in Objects/descrobject.c'\n"
"        obj._slotvalues[self.offset] = value\n"
"\n"
"    def __delete__(self, obj):\n"
"        'Emulate member_delete() in Objects/descrobject.c'\n"
"        value = obj._slotvalues[self.offset]\n"
"        if value is null:\n"
"            raise AttributeError(self.name)\n"
"        obj._slotvalues[self.offset] = null\n"
"\n"
"    def __repr__(self):\n"
"        'Emulate member_repr() in Objects/descrobject.c'\n"
"        return f'<Member {self.name!r} of {self.clsname!r}>'"

#: ../../howto/descriptor.rst:1685
msgid ""
"The :meth:`!type.__new__` method takes care of adding member objects to "
"class variables:"
msgstr ""
"El método :meth:`!type.__new__` se encarga de añadir objetos miembros a las "
"variables de clase:"

#: ../../howto/descriptor.rst:1688
msgid ""
"class Type(type):\n"
"    'Simulate how the type metaclass adds member objects for slots'\n"
"\n"
"    def __new__(mcls, clsname, bases, mapping, **kwargs):\n"
"        'Emulate type_new() in Objects/typeobject.c'\n"
"        # type_new() calls PyTypeReady() which calls add_methods()\n"
"        slot_names = mapping.get('slot_names', [])\n"
"        for offset, name in enumerate(slot_names):\n"
"            mapping[name] = Member(name, clsname, offset)\n"
"        return type.__new__(mcls, clsname, bases, mapping, **kwargs)"
msgstr ""
"class Type(type):\n"
"    'Simulate how the type metaclass adds member objects for slots'\n"
"\n"
"    def __new__(mcls, clsname, bases, mapping, **kwargs):\n"
"        'Emulate type_new() in Objects/typeobject.c'\n"
"        # type_new() llama a PyTypeReady() que llama a add_methods()\n"
"        slot_names = mapping.get('slot_names', [])\n"
"        for offset, name in enumerate(slot_names):\n"
"            mapping[name] = Member(name, clsname, offset)\n"
"        return type.__new__(mcls, clsname, bases, mapping, **kwargs)"

#: ../../howto/descriptor.rst:1701
msgid ""
"The :meth:`object.__new__` method takes care of creating instances that have "
"slots instead of an instance dictionary.  Here is a rough simulation in pure "
"Python:"
msgstr ""
"El método :meth:`object.__new__` se encarga de crear instancias que tienen "
"ranuras en lugar de un diccionario de instancias.  He aquí una simulación "
"aproximada en Python puro:"

#: ../../howto/descriptor.rst:1705
msgid ""
"class Object:\n"
"    'Simulate how object.__new__() allocates memory for __slots__'\n"
"\n"
"    def __new__(cls, *args, **kwargs):\n"
"        'Emulate object_new() in Objects/typeobject.c'\n"
"        inst = super().__new__(cls)\n"
"        if hasattr(cls, 'slot_names'):\n"
"            empty_slots = [null] * len(cls.slot_names)\n"
"            object.__setattr__(inst, '_slotvalues', empty_slots)\n"
"        return inst\n"
"\n"
"    def __setattr__(self, name, value):\n"
"        'Emulate _PyObject_GenericSetAttrWithDict() Objects/object.c'\n"
"        cls = type(self)\n"
"        if hasattr(cls, 'slot_names') and name not in cls.slot_names:\n"
"            raise AttributeError(\n"
"                f'{cls.__name__!r} object has no attribute {name!r}'\n"
"            )\n"
"        super().__setattr__(name, value)\n"
"\n"
"    def __delattr__(self, name):\n"
"        'Emulate _PyObject_GenericSetAttrWithDict() Objects/object.c'\n"
"        cls = type(self)\n"
"        if hasattr(cls, 'slot_names') and name not in cls.slot_names:\n"
"            raise AttributeError(\n"
"                f'{cls.__name__!r} object has no attribute {name!r}'\n"
"            )\n"
"        super().__delattr__(name)"
msgstr ""
"class Object:\n"
"    'Simulate how object.__new__() allocates memory for __slots__'\n"
"\n"
"    def __new__(cls, *args, **kwargs):\n"
"        'Emulate object_new() in Objects/typeobject.c'\n"
"        inst = super().__new__(cls)\n"
"        if hasattr(cls, 'slot_names'):\n"
"            empty_slots = [null] * len(cls.slot_names)\n"
"            object.__setattr__(inst, '_slotvalues', empty_slots)\n"
"        return inst\n"
"\n"
"    def __setattr__(self, name, value):\n"
"        'Emulate _PyObject_GenericSetAttrWithDict() Objects/object.c'\n"
"        cls = type(self)\n"
"        if hasattr(cls, 'slot_names') and name not in cls.slot_names:\n"
"            raise AttributeError(\n"
"                f'{cls.__name__!r} object has no attribute {name!r}'\n"
"            )\n"
"        super().__setattr__(name, value)\n"
"\n"
"    def __delattr__(self, name):\n"
"        'Emulate _PyObject_GenericSetAttrWithDict() Objects/object.c'\n"
"        cls = type(self)\n"
"        if hasattr(cls, 'slot_names') and name not in cls.slot_names:\n"
"            raise AttributeError(\n"
"                f'{cls.__name__!r} object has no attribute {name!r}'\n"
"            )\n"
"        super().__delattr__(name)"

#: ../../howto/descriptor.rst:1736
msgid ""
"To use the simulation in a real class, just inherit from :class:`!Object` "
"and set the :term:`metaclass` to :class:`Type`:"
msgstr ""
"Para utilizar la simulación en una clase real, basta con heredar de :class:`!"
"Object` y establecer :term:`metaclass` en :class:`Type`:"

#: ../../howto/descriptor.rst:1739
msgid ""
"class H(Object, metaclass=Type):\n"
"    'Instance variables stored in slots'\n"
"\n"
"    slot_names = ['x', 'y']\n"
"\n"
"    def __init__(self, x, y):\n"
"        self.x = x\n"
"        self.y = y"
msgstr ""
"clase H(Objeto, metaclase=Tipo):\n"
"    'Variables de instancia almacenadas en ranuras'\n"
"\n"
"     slot_names = ['x', 'y']\n"
"\n"
"    def __init__(self, x, y):\n"
"        self.x = x\n"
"        self.y = y"

#: ../../howto/descriptor.rst:1750
msgid ""
"At this point, the metaclass has loaded member objects for *x* and *y*::"
msgstr ""
"En este punto, la metaclase ha cargado objetos miembro para *x* y *y*::"

#: ../../howto/descriptor.rst:1752
msgid ""
">>> from pprint import pp\n"
">>> pp(dict(vars(H)))\n"
"{'__module__': '__main__',\n"
" '__doc__': 'Instance variables stored in slots',\n"
" 'slot_names': ['x', 'y'],\n"
" '__init__': <function H.__init__ at 0x7fb5d302f9d0>,\n"
" 'x': <Member 'x' of 'H'>,\n"
" 'y': <Member 'y' of 'H'>}"
msgstr ""
">>> from pprint import pp\n"
">>> pp(dict(vars(H)))\n"
"{'__module__': '__main__',\n"
" '__doc__': 'Instance variables stored in slots',\n"
" 'slot_names': ['x', 'y'],\n"
" '__init__': <function H.__init__ at 0x7fb5d302f9d0>,\n"
" 'x': <Member 'x' of 'H'>,\n"
" 'y': <Member 'y' of 'H'>}"

#: ../../howto/descriptor.rst:1771
msgid ""
"When instances are created, they have a ``slot_values`` list where the "
"attributes are stored:"
msgstr ""
"Cuando se crean las instancias, tienen una lista ``slot_values`` donde se "
"almacenan los atributos:"

#: ../../howto/descriptor.rst:1774
msgid ""
">>> h = H(10, 20)\n"
">>> vars(h)\n"
"{'_slotvalues': [10, 20]}\n"
">>> h.x = 55\n"
">>> vars(h)\n"
"{'_slotvalues': [55, 20]}"
msgstr ""
">>> h = H(10, 20)\n"
">>> vars(h)\n"
"{'_slotvalues': [10, 20]}\n"
">>> h.x = 55\n"
">>> vars(h)\n"
"{'_slotvalues': [55, 20]}"

#: ../../howto/descriptor.rst:1783
msgid "Misspelled or unassigned attributes will raise an exception:"
msgstr "Los atributos mal escritos o no asignados provocarán una excepción:"

#: ../../howto/descriptor.rst:1785
msgid ""
">>> h.xz\n"
"Traceback (most recent call last):\n"
"    ...\n"
"AttributeError: 'H' object has no attribute 'xz'"
msgstr ""
">>> h.xz\n"
"Traceback (última llamada más reciente):\n"
"    ...\n"
"AttributeError: El objeto 'H' no tiene el atributo 'xz'."
