# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 15:28+0000\n"
"PO-Revision-Date: 2023-05-24 02:11+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Spanish (Spain) (https://app.transifex.com/python-doc/"
"teams/5390/es_ES/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es_ES\n"
"Plural-Forms: nplurals=3; plural=n == 1 ? 0 : n != 0 && n % 1000000 == 0 ? "
"1 : 2;\n"

#: ../../howto/enum.rst:3
msgid "Enum HOWTO"
msgstr "Enum HOWTO"

#: ../../howto/enum.rst:9
msgid ""
"An :class:`Enum` is a set of symbolic names bound to unique values.  They "
"are similar to global variables, but they offer a more useful :func:"
"`repr()`, grouping, type-safety, and a few other features."
msgstr ""

#: ../../howto/enum.rst:13
msgid ""
"They are most useful when you have a variable that can take one of a limited "
"selection of values.  For example, the days of the week::"
msgstr ""
"Son más útiles cuando se tiene una variable que puede tomar uno de una "
"selección limitada de valores.  Por ejemplo, los días de la semana::"

#: ../../howto/enum.rst:26
msgid "Or perhaps the RGB primary colors::"
msgstr "O quizás los colores primarios RGB::"

#: ../../howto/enum.rst:34
msgid ""
"As you can see, creating an :class:`Enum` is as simple as writing a class "
"that inherits from :class:`Enum` itself."
msgstr ""
"Como puede ver, crear un :class:`Enum` es tan sencillo como escribir una "
"clase que herede del propio :class:`Enum`."

#: ../../howto/enum.rst:37
msgid "Case of Enum Members"
msgstr "Caso de los miembros Enum"

#: ../../howto/enum.rst:39
msgid ""
"Because Enums are used to represent constants we recommend using UPPER_CASE "
"names for members, and will be using that style in our examples."
msgstr ""

#: ../../howto/enum.rst:42
msgid ""
"Depending on the nature of the enum a member's value may or may not be "
"important, but either way that value can be used to get the corresponding "
"member::"
msgstr ""
"Dependiendo de la naturaleza del enum el valor de un miembro puede o no ser "
"importante, pero en cualquier caso ese valor se puede utilizar para obtener "
"el miembro correspondiente::"

#: ../../howto/enum.rst:49
msgid ""
"As you can see, the ``repr()`` of a member shows the enum name, the member "
"name, and the value.  The ``str()`` of a member shows only the enum name and "
"member name::"
msgstr ""
"Como puede ver, el ``repr()`` de un miembro muestra el nombre del enum, el "
"nombre del miembro y el valor.  El ``str()`` de un miembro sólo muestra el "
"nombre del enum y el nombre del miembro::"

#: ../../howto/enum.rst:56
msgid "The *type* of an enumeration member is the enum it belongs to::"
msgstr "El *tipo* de un miembro de enumeración es el enum al que pertenece::"

#: ../../howto/enum.rst:63
msgid "Enum members have an attribute that contains just their :attr:`name`::"
msgstr ""
"Los miembros de Enum tienen un atributo que contiene sólo su :attr:`name`::"

#: ../../howto/enum.rst:68
msgid "Likewise, they have an attribute for their :attr:`value`::"
msgstr "Asimismo, disponen de un atributo para su :attr:`value`::"

#: ../../howto/enum.rst:74
msgid ""
"Unlike many languages that treat enumerations solely as name/value pairs, "
"Python Enums can have behavior added.  For example, :class:`datetime.date` "
"has two methods for returning the weekday: :meth:`weekday` and :meth:"
"`isoweekday`. The difference is that one of them counts from 0-6 and the "
"other from 1-7. Rather than keep track of that ourselves we can add a method "
"to the :class:`Weekday` enum to extract the day from the :class:`date` "
"instance and return the matching enum member::"
msgstr ""
"A diferencia de muchos lenguajes que tratan las enumeraciones únicamente "
"como pares nombre/valor, a los Enums de Python se les puede añadir "
"comportamiento.  Por ejemplo, :class:`datetime.date` tiene dos métodos para "
"devolver el día de la semana: :meth:`weekday` y :meth:`isoweekday`. La "
"diferencia es que uno de ellos cuenta de 0-6 y el otro de 1-7. En lugar de "
"llevar la cuenta nosotros mismos, podemos añadir un método al enum :class:"
"`Weekday` para extraer el día de la instancia :class:`date` y devolver el "
"miembro del enum que corresponda::"

#: ../../howto/enum.rst:86
msgid "The complete :class:`Weekday` enum now looks like this::"
msgstr "El enum :class:`Weekday` completo tiene ahora este aspecto::"

#: ../../howto/enum.rst:101
msgid "Now we can find out what today is!  Observe::"
msgstr "¡Ahora podemos averiguar qué día es hoy!  Observa::"

#: ../../howto/enum.rst:107
msgid ""
"Of course, if you're reading this on some other day, you'll see that day "
"instead."
msgstr ""
"Por supuesto, si estás leyendo esto otro día, verás ese día en su lugar."

#: ../../howto/enum.rst:109
msgid ""
"This :class:`Weekday` enum is great if our variable only needs one day, but "
"what if we need several?  Maybe we're writing a function to plot chores "
"during a week, and don't want to use a :class:`list` -- we could use a "
"different type of :class:`Enum`::"
msgstr ""
"Este enum :class:`Weekday` está muy bien si nuestra variable sólo necesita "
"un día, pero ¿y si necesitamos varios?  Tal vez estamos escribiendo una "
"función para trazar las tareas durante una semana, y no queremos utilizar "
"un :class:`list` -- podríamos utilizar un tipo diferente de :class:`Enum`::"

#: ../../howto/enum.rst:124
msgid ""
"We've changed two things: we're inherited from :class:`Flag`, and the values "
"are all powers of 2."
msgstr ""
"Hemos cambiado dos cosas: heredamos de :class:`Flag`, y los valores son "
"todos potencias de 2."

#: ../../howto/enum.rst:127
msgid ""
"Just like the original :class:`Weekday` enum above, we can have a single "
"selection::"
msgstr ""
"Al igual que el original :class:`Weekday` enum anterior, podemos tener una "
"sola selección::"

#: ../../howto/enum.rst:133
msgid ""
"But :class:`Flag` also allows us to combine several members into a single "
"variable::"
msgstr ""
"Pero :class:`Flag` también nos permite combinar varios miembros en una sola "
"variable::"

#: ../../howto/enum.rst:140
msgid "You can even iterate over a :class:`Flag` variable::"
msgstr "Incluso puede iterar sobre una variable :class:`Flag`::"

#: ../../howto/enum.rst:147
msgid "Okay, let's get some chores set up::"
msgstr "Bueno, vamos a hacer algunas tareas::"

#: ../../howto/enum.rst:155
msgid "And a function to display the chores for a given day::"
msgstr "Y una función para mostrar las tareas de un día determinado::"

#: ../../howto/enum.rst:164
msgid ""
"In cases where the actual values of the members do not matter, you can save "
"yourself some work and use :func:`auto()` for the values::"
msgstr ""

#: ../../howto/enum.rst:183
msgid "Programmatic access to enumeration members and their attributes"
msgstr "Acceso programático a los miembros de la enumeración y sus atributos"

#: ../../howto/enum.rst:185
msgid ""
"Sometimes it's useful to access members in enumerations programmatically (i."
"e. situations where ``Color.RED`` won't do because the exact color is not "
"known at program-writing time).  ``Enum`` allows such access::"
msgstr ""
"A veces es útil acceder a los miembros de las enumeraciones mediante "
"programación (es decir, en situaciones en las que ``Color.RED`` no sirve "
"porque no se conoce el color exacto en el momento de escribir el programa). "
"``Enum`` permite este tipo de acceso::"

#: ../../howto/enum.rst:194
msgid "If you want to access enum members by *name*, use item access::"
msgstr ""
"Si desea acceder a los miembros del enum por *nombre*, utilice item access::"

#: ../../howto/enum.rst:201
msgid "If you have an enum member and need its :attr:`name` or :attr:`value`::"
msgstr ""
"Si tienes un miembro enum y necesitas su :attr:`name` o :attr:`value`::"

#: ../../howto/enum.rst:211
msgid "Duplicating enum members and values"
msgstr "Duplicación de miembros y valores de enum"

#: ../../howto/enum.rst:213
msgid "Having two enum members with the same name is invalid::"
msgstr "Tener dos miembros de enum con el mismo nombre no es válido::"

#: ../../howto/enum.rst:223
msgid ""
"However, an enum member can have other names associated with it.  Given two "
"entries ``A`` and ``B`` with the same value (and ``A`` defined first), ``B`` "
"is an alias for the member ``A``.  By-value lookup of the value of ``A`` "
"will return the member ``A``.  By-name lookup of ``A`` will return the "
"member ``A``. By-name lookup of ``B`` will also return the member ``A``::"
msgstr ""
"Sin embargo, un miembro de un enum puede tener asociados otros nombres.  "
"Dadas dos entradas ``A`` y ``B`` con el mismo valor (y ``A`` definido en "
"primer lugar), ``B`` es un alias para el miembro ``A``.  La búsqueda por "
"valor del valor de ``A`` devolverá el miembro ``A``.  La búsqueda por nombre "
"de ``A`` devolverá el miembro ``A``. La búsqueda por nombre de ``B`` también "
"devolverá el miembro ``A``::"

#: ../../howto/enum.rst:244
msgid ""
"Attempting to create a member with the same name as an already defined "
"attribute (another member, a method, etc.) or attempting to create an "
"attribute with the same name as a member is not allowed."
msgstr ""
"No está permitido intentar crear un miembro con el mismo nombre que un "
"atributo ya definido (otro miembro, un método, etc.) ni intentar crear un "
"atributo con el mismo nombre que un miembro."

#: ../../howto/enum.rst:250
msgid "Ensuring unique enumeration values"
msgstr "Garantizar valores de enumeración únicos"

#: ../../howto/enum.rst:252
msgid ""
"By default, enumerations allow multiple names as aliases for the same value. "
"When this behavior isn't desired, you can use the :func:`unique` decorator::"
msgstr ""
"Por defecto, las enumeraciones permiten múltiples nombres como alias para el "
"mismo valor. Cuando no se desea este comportamiento, se puede utilizar el "
"decorador :func:`unique`::"

#: ../../howto/enum.rst:269
msgid "Using automatic values"
msgstr "Utilización de valores automáticos"

#: ../../howto/enum.rst:271
msgid "If the exact value is unimportant you can use :class:`auto`::"
msgstr "Si el valor exacto no es importante, puede utilizar :class:`auto`::"

#: ../../howto/enum.rst:282
msgid ""
"The values are chosen by :func:`_generate_next_value_`, which can be "
"overridden::"
msgstr ""
"Los valores son elegidos por :func:`_generate_next_value_`, que puede ser "
"anulado::"

#: ../../howto/enum.rst:300
msgid ""
"The :meth:`_generate_next_value_` method must be defined before any members."
msgstr ""
"El método :meth:`_generate_next_value_` debe definirse antes que cualquier "
"miembro."

#: ../../howto/enum.rst:303
msgid "Iteration"
msgstr "Iteración"

#: ../../howto/enum.rst:305
msgid "Iterating over the members of an enum does not provide the aliases::"
msgstr "Iterar sobre los miembros de un enum no proporciona los alias::"

#: ../../howto/enum.rst:312
msgid ""
"Note that the aliases ``Shape.ALIAS_FOR_SQUARE`` and ``Weekday.WEEKEND`` "
"aren't shown."
msgstr ""
"Tenga en cuenta que los alias ``Shape.ALIAS_FOR_SQUARE`` y ``Weekday."
"WEEKEND`` no se muestran."

#: ../../howto/enum.rst:314
msgid ""
"The special attribute ``__members__`` is a read-only ordered mapping of "
"names to members.  It includes all names defined in the enumeration, "
"including the aliases::"
msgstr ""
"El atributo especial ``__members__`` es una asignación ordenada de sólo "
"lectura de nombres a miembros.  Incluye todos los nombres definidos en la "
"enumeración, incluidos los alias::"

#: ../../howto/enum.rst:326
msgid ""
"The ``__members__`` attribute can be used for detailed programmatic access "
"to the enumeration members.  For example, finding all the aliases::"
msgstr ""
"El atributo ``__members__`` puede utilizarse para un acceso programático "
"detallado a los miembros de la enumeración.  Por ejemplo, para encontrar "
"todos los alias::"

#: ../../howto/enum.rst:334
msgid ""
"Aliases for flags include values with multiple flags set, such as ``3``, and "
"no flags set, i.e. ``0``."
msgstr ""
"Los alias de las banderas incluyen valores con múltiples banderas "
"establecidas, como ``3``, y sin banderas establecidas, es decir, ``0``."

#: ../../howto/enum.rst:339
msgid "Comparisons"
msgstr "Comparaciones"

#: ../../howto/enum.rst:341
msgid "Enumeration members are compared by identity::"
msgstr "Los miembros de la enumeración se comparan por identidad::"

#: ../../howto/enum.rst:350
msgid ""
"Ordered comparisons between enumeration values are *not* supported.  Enum "
"members are not integers (but see `IntEnum`_ below)::"
msgstr ""
"Las comparaciones ordenadas entre valores de enumeración *no* están "
"soportadas.  Los miembros de la enumeración no son enteros (pero véase "
"`IntEnum`_ más abajo)::"

#: ../../howto/enum.rst:358
msgid "Equality comparisons are defined though::"
msgstr "Las comparaciones de igualdad se definen mediante::"

#: ../../howto/enum.rst:367
msgid ""
"Comparisons against non-enumeration values will always compare not equal "
"(again, :class:`IntEnum` was explicitly designed to behave differently, see "
"below)::"
msgstr ""
"Las comparaciones contra valores no enumerativos siempre compararán no "
"iguales (de nuevo, :class:`IntEnum` se diseñó explícitamente para "
"comportarse de forma diferente, ver más abajo)::"

#: ../../howto/enum.rst:376
msgid ""
"It is possible to reload modules -- if a reloaded module contains enums, "
"they will be recreated, and the new members may not compare identical/equal "
"to the original members."
msgstr ""
"Es posible recargar módulos -- si un módulo recargado contiene enums, éstos "
"serán recreados, y los nuevos miembros pueden no comparar idénticos/iguales "
"a los miembros originales."

#: ../../howto/enum.rst:381
msgid "Allowed members and attributes of enumerations"
msgstr "Miembros y atributos permitidos de las enumeraciones"

#: ../../howto/enum.rst:383
msgid ""
"Most of the examples above use integers for enumeration values.  Using "
"integers is short and handy (and provided by default by the `Functional "
"API`_), but not strictly enforced.  In the vast majority of use-cases, one "
"doesn't care what the actual value of an enumeration is.  But if the value "
"*is* important, enumerations can have arbitrary values."
msgstr ""
"La mayoría de los ejemplos anteriores utilizan números enteros para los "
"valores de enumeración.  El uso de números enteros es breve y práctico (y la "
"`API funcional`_ lo proporciona por defecto), pero no es estrictamente "
"obligatorio.  En la gran mayoría de los casos de uso, a uno no le importa "
"cuál es el valor real de una enumeración.  Pero si el valor *es* importante, "
"las enumeraciones pueden tener valores arbitrarios."

#: ../../howto/enum.rst:389
msgid ""
"Enumerations are Python classes, and can have methods and special methods as "
"usual.  If we have this enumeration::"
msgstr ""
"Las enumeraciones son clases de Python, y pueden tener métodos y métodos "
"especiales como es habitual.  Si tenemos esta enumeración::"

#: ../../howto/enum.rst:409
msgid "Then::"
msgstr "Entonces::"

#: ../../howto/enum.rst:418
msgid ""
"The rules for what is allowed are as follows: names that start and end with "
"a single underscore are reserved by enum and cannot be used; all other "
"attributes defined within an enumeration will become members of this "
"enumeration, with the exception of special methods (:meth:`__str__`, :meth:"
"`__add__`, etc.), descriptors (methods are also descriptors), and variable "
"names listed in :attr:`_ignore_`."
msgstr ""
"Las reglas para lo que está permitido son las siguientes: los nombres que "
"empiezan y terminan con un solo guión bajo están reservados por enum y no se "
"pueden utilizar; todos los demás atributos definidos dentro de una "
"enumeración se convertirán en miembros de esta enumeración, a excepción de "
"los métodos especiales (:meth:`__str__`, :meth:`__add__`, etc.), los "
"descriptores (los métodos también son descriptores) y los nombres de "
"variables enumerados en :attr:`_ignore_`."

#: ../../howto/enum.rst:425
msgid ""
"Note:  if your enumeration defines :meth:`__new__` and/or :meth:`__init__`, "
"any value(s) given to the enum member will be passed into those methods. See "
"`Planet`_ for an example."
msgstr ""
"Nota: si su enumeración define :meth:`__new__` y/o :meth:`__init__`, "
"cualquier valor(es) dado al miembro de la enumeración se pasará a esos "
"métodos. Ver `Planet`_ para un ejemplo."

#: ../../howto/enum.rst:431
msgid ""
"The :meth:`__new__` method, if defined, is used during creation of the Enum "
"members; it is then replaced by Enum's :meth:`__new__` which is used after "
"class creation for lookup of existing members.  See :ref:`new-vs-init` for "
"more details."
msgstr ""
"El método :meth:`__new__`, si está definido, se utiliza durante la creación "
"de los miembros de Enum; después se sustituye por :meth:`__new__` de Enum "
"que se utiliza después de la creación de la clase para buscar los miembros "
"existentes.  Véase :ref:`new-vs-init` para más detalles."

#: ../../howto/enum.rst:438
msgid "Restricted Enum subclassing"
msgstr "Subclasificación restringida de Enum"

#: ../../howto/enum.rst:440
msgid ""
"A new :class:`Enum` class must have one base enum class, up to one concrete "
"data type, and as many :class:`object`-based mixin classes as needed.  The "
"order of these base classes is::"
msgstr ""
"Una nueva clase :class:`Enum` debe tener una clase enum base, hasta un tipo "
"de datos concreto y tantas clases mixtas basadas en :class:`object` como "
"sean necesarias.  El orden de estas clases base es::"

#: ../../howto/enum.rst:447
msgid ""
"Also, subclassing an enumeration is allowed only if the enumeration does not "
"define any members.  So this is forbidden::"
msgstr ""
"Además, subclasificar una enumeración sólo está permitido si la enumeración "
"no define ningún miembro.  Así que esto está prohibido::"

#: ../../howto/enum.rst:457
msgid "But this is allowed::"
msgstr "Pero esto está permitido::"

#: ../../howto/enum.rst:468
msgid ""
"Allowing subclassing of enums that define members would lead to a violation "
"of some important invariants of types and instances.  On the other hand, it "
"makes sense to allow sharing some common behavior between a group of "
"enumerations. (See `OrderedEnum`_ for an example.)"
msgstr ""
"Permitir la subclasificación de enumeraciones que definen miembros llevaría "
"a una violación de algunas invariantes importantes de tipos e instancias.  "
"Por otro lado, tiene sentido permitir compartir algún comportamiento común "
"entre un grupo de enumeraciones. (Ver un ejemplo en `OrderedEnum`_ )."

#: ../../howto/enum.rst:475
msgid "Pickling"
msgstr "Decapado"

#: ../../howto/enum.rst:477
msgid "Enumerations can be pickled and unpickled::"
msgstr "Las enumeraciones pueden plantear problemas o no::"

#: ../../howto/enum.rst:484
msgid ""
"The usual restrictions for pickling apply: picklable enums must be defined "
"in the top level of a module, since unpickling requires them to be "
"importable from that module."
msgstr ""
"Se aplican las restricciones habituales para el pickling: los enums "
"picklable deben definirse en el nivel superior de un módulo, ya que el "
"unpickling requiere que sean importables desde ese módulo."

#: ../../howto/enum.rst:490
msgid ""
"With pickle protocol version 4 it is possible to easily pickle enums nested "
"in other classes."
msgstr ""
"Con la versión 4 del protocolo pickle es posible recoger fácilmente enums "
"anidados en otras clases."

#: ../../howto/enum.rst:493
msgid ""
"It is possible to modify how enum members are pickled/unpickled by defining :"
"meth:`__reduce_ex__` in the enumeration class.  The default method is by-"
"value, but enums with complicated values may want to use by-name::"
msgstr ""
"Es posible modificar la forma en que los miembros de la enumeración se "
"seleccionan/deseleccionan definiendo :meth:`__reduce_ex__` en la clase de "
"enumeración.  El método por defecto es by-value, pero los enum con valores "
"complicados pueden utilizar by-name::"

#: ../../howto/enum.rst:503
msgid ""
"Using by-name for flags is not recommended, as unnamed aliases will not "
"unpickle."
msgstr ""
"No se recomienda utilizar by-name para las banderas, ya que los alias sin "
"nombre no se despicarán."

#: ../../howto/enum.rst:508
msgid "Functional API"
msgstr "API funcional"

#: ../../howto/enum.rst:510
msgid ""
"The :class:`Enum` class is callable, providing the following functional API::"
msgstr ""
"Se puede invocar la clase :class:`Enum`, proporcionando la siguiente API "
"funcional::"

#: ../../howto/enum.rst:520
msgid ""
"The semantics of this API resemble :class:`~collections.namedtuple`. The "
"first argument of the call to :class:`Enum` is the name of the enumeration."
msgstr ""
"La semántica de esta API es similar a la de :class:`~collections."
"namedtuple`. El primer argumento de la llamada a :class:`Enum` es el nombre "
"de la enumeración."

#: ../../howto/enum.rst:523
msgid ""
"The second argument is the *source* of enumeration member names.  It can be "
"a whitespace-separated string of names, a sequence of names, a sequence of 2-"
"tuples with key/value pairs, or a mapping (e.g. dictionary) of names to "
"values.  The last two options enable assigning arbitrary values to "
"enumerations; the others auto-assign increasing integers starting with 1 "
"(use the ``start`` parameter to specify a different starting value).  A new "
"class derived from :class:`Enum` is returned.  In other words, the above "
"assignment to :class:`Animal` is equivalent to::"
msgstr ""
"El segundo argumento es la *fuente* de los nombres de los miembros de la "
"enumeración.  Puede ser una cadena de nombres separada por espacios en "
"blanco, una secuencia de nombres, una secuencia de 2-tuplas con pares clave/"
"valor o un mapeo (por ejemplo, un diccionario) de nombres a valores.  Las "
"dos últimas opciones permiten asignar valores arbitrarios a las "
"enumeraciones; las demás autoasignan enteros crecientes empezando por 1 "
"(utilice el parámetro ``start`` para especificar un valor inicial "
"distinto).  Se devuelve una nueva clase derivada de :class:`Enum`.  En otras "
"palabras, la asignación anterior a :class:`Animal` es equivalente a::"

#: ../../howto/enum.rst:539
msgid ""
"The reason for defaulting to ``1`` as the starting number and not ``0`` is "
"that ``0`` is ``False`` in a boolean sense, but by default enum members all "
"evaluate to ``True``."
msgstr ""
"La razón por la que ``1`` es el número de inicio y no ``0`` es que ``0`` es "
"``False`` en un sentido booleano, pero por defecto todos los miembros del "
"enum se evalúan a ``True``."

#: ../../howto/enum.rst:543
msgid ""
"Pickling enums created with the functional API can be tricky as frame stack "
"implementation details are used to try and figure out which module the "
"enumeration is being created in (e.g. it will fail if you use a utility "
"function in a separate module, and also may not work on IronPython or "
"Jython). The solution is to specify the module name explicitly as follows::"
msgstr ""
"La recolección de enumeraciones creadas con la API funcional puede ser "
"complicada, ya que los detalles de implementación de la pila de marcos se "
"utilizan para tratar de averiguar en qué módulo se está creando la "
"enumeración (por ejemplo, fallará si se utiliza una función de utilidad en "
"un módulo separado, y también puede no funcionar en IronPython o Jython). La "
"solución es especificar el nombre del módulo explícitamente de la siguiente "
"manera::"

#: ../../howto/enum.rst:553
msgid ""
"If ``module`` is not supplied, and Enum cannot determine what it is, the new "
"Enum members will not be unpicklable; to keep errors closer to the source, "
"pickling will be disabled."
msgstr ""
"Si no se proporciona ``module``, y Enum no puede determinar qué es, los "
"nuevos miembros de Enum no serán unpicklable; para mantener los errores más "
"cerca de la fuente, se desactivará el pickling."

#: ../../howto/enum.rst:557
msgid ""
"The new pickle protocol 4 also, in some circumstances, relies on :attr:"
"`~definition.__qualname__` being set to the location where pickle will be "
"able to find the class.  For example, if the class was made available in "
"class SomeData in the global scope::"
msgstr ""
"El nuevo protocolo pickle 4 también, en algunas circunstancias, depende de "
"que :attr:`~definition.__qualname__` se establezca en la ubicación donde "
"pickle podrá encontrar la clase.  Por ejemplo, si la clase se puso a "
"disposición en la clase SomeData en el ámbito global::"

#: ../../howto/enum.rst:564
msgid "The complete signature is::"
msgstr "La firma completa es::"

#: ../../howto/enum.rst:576
msgid "*value*: What the new enum class will record as its name."
msgstr "*value*: Lo que la nueva clase enum registrará como nombre."

#: ../../howto/enum.rst:578
msgid ""
"*names*: The enum members.  This can be a whitespace- or comma-separated "
"string (values will start at 1 unless otherwise specified)::"
msgstr ""
"*names*: Los miembros del enum.  Puede ser una cadena separada por comas o "
"por espacios en blanco (los valores empezarán en 1 a menos que se "
"especifique lo contrario)::"

#: ../../howto/enum.rst:583
msgid "or an iterator of names::"
msgstr "o un iterador de nombres::"

#: ../../howto/enum.rst:587
msgid "or an iterator of (name, value) pairs::"
msgstr "o un iterador de pares (nombre, valor)::"

#: ../../howto/enum.rst:591
msgid "or a mapping::"
msgstr "o un mapeo::"

#: ../../howto/enum.rst:595
msgid "*module*: name of module where new enum class can be found."
msgstr "*module*: nombre del módulo donde se encuentra la nueva clase enum."

#: ../../howto/enum.rst:597
msgid "*qualname*: where in module new enum class can be found."
msgstr "*qualname*: dónde en el módulo se puede encontrar la nueva clase enum."

#: ../../howto/enum.rst:599
msgid "*type*: type to mix in to new enum class."
msgstr "*type*: tipo para mezclar en la nueva clase enum."

#: ../../howto/enum.rst:601
msgid "*start*: number to start counting at if only names are passed in."
msgstr "*start*: número para empezar a contar si sólo se pasan nombres."

#: ../../howto/enum.rst:603
msgid "The *start* parameter was added."
msgstr "Se ha añadido el parámetro *start*."

#: ../../howto/enum.rst:608
msgid "Derived Enumerations"
msgstr "Enumeraciones derivadas"

#: ../../howto/enum.rst:611
msgid "IntEnum"
msgstr "IntEnum"

#: ../../howto/enum.rst:613
msgid ""
"The first variation of :class:`Enum` that is provided is also a subclass of :"
"class:`int`.  Members of an :class:`IntEnum` can be compared to integers; by "
"extension, integer enumerations of different types can also be compared to "
"each other::"
msgstr ""
"La primera variación de :class:`Enum` que se proporciona es también una "
"subclase de :class:`int`. Los miembros de un :class:`IntEnum` pueden "
"compararse con enteros; por extensión, las enumeraciones de enteros de "
"diferentes tipos también pueden compararse entre sí::"

#: ../../howto/enum.rst:634
msgid ""
"However, they still can't be compared to standard :class:`Enum` "
"enumerations::"
msgstr ""
"Sin embargo, siguen sin poder compararse con las enumeraciones estándar de :"
"class:`Enum`::"

#: ../../howto/enum.rst:647
msgid ""
":class:`IntEnum` values behave like integers in other ways you'd expect::"
msgstr ""
":class:`IntEnum` se comportan como enteros en otros aspectos que cabría "
"esperar::"

#: ../../howto/enum.rst:658
msgid "StrEnum"
msgstr "StrEnum"

#: ../../howto/enum.rst:660
msgid ""
"The second variation of :class:`Enum` that is provided is also a subclass "
"of :class:`str`.  Members of a :class:`StrEnum` can be compared to strings; "
"by extension, string enumerations of different types can also be compared to "
"each other."
msgstr ""
"La segunda variación de :class:`Enum` que se proporciona también es una "
"subclase de :class:`str`. Los miembros de un :class:`StrEnum` pueden "
"compararse con cadenas; por extensión, las enumeraciones de cadenas de "
"diferentes tipos también pueden compararse entre sí."

#: ../../howto/enum.rst:669
msgid "IntFlag"
msgstr "IntFlag"

#: ../../howto/enum.rst:671
msgid ""
"The next variation of :class:`Enum` provided, :class:`IntFlag`, is also "
"based on :class:`int`.  The difference being :class:`IntFlag` members can be "
"combined using the bitwise operators (&, \\|, ^, ~) and the result is still "
"an :class:`IntFlag` member, if possible.  Like :class:`IntEnum`, :class:"
"`IntFlag` members are also integers and can be used wherever an :class:`int` "
"is used."
msgstr ""
"La siguiente variación de :class:`Enum` proporcionada, :class:`IntFlag`, "
"también se basa en :class:`int`.  La diferencia es que los miembros de :"
"class:`IntFlag` pueden combinarse utilizando los operadores bit a bit (&, "
"||, ^, ~) y el resultado sigue siendo un miembro de :class:`IntFlag`, si es "
"posible.  Al igual que :class:`IntEnum`, los miembros de :class:`IntFlag` "
"también son enteros y pueden utilizarse siempre que se utilice :class:`int`."

#: ../../howto/enum.rst:679
msgid ""
"Any operation on an :class:`IntFlag` member besides the bit-wise operations "
"will lose the :class:`IntFlag` membership."
msgstr ""
"Cualquier operación sobre un miembro de :class:`IntFlag` además de las "
"operaciones bit a bit perderá la pertenencia a :class:`IntFlag`."

#: ../../howto/enum.rst:682
msgid ""
"Bit-wise operations that result in invalid :class:`IntFlag` values will lose "
"the :class:`IntFlag` membership.  See :class:`FlagBoundary` for details."
msgstr ""
"Las operaciones bit a bit que resulten en valores no válidos de :class:"
"`IntFlag` perderán la pertenencia a :class:`IntFlag`.  Ver :class:"
"`FlagBoundary` para más detalles."

#: ../../howto/enum.rst:689
msgid "Sample :class:`IntFlag` class::"
msgstr "Clase de muestra :class:`IntFlag`::"

#: ../../howto/enum.rst:705
msgid "It is also possible to name the combinations::"
msgstr "También es posible nombrar las combinaciones::"

#: ../../howto/enum.rst:721
msgid ""
"Named combinations are considered aliases.  Aliases do not show up during "
"iteration, but can be returned from by-value lookups."
msgstr ""
"Las combinaciones con nombre se consideran alias.  Los alias no se muestran "
"durante la iteración, pero pueden devolverse desde búsquedas por valor."

#: ../../howto/enum.rst:726
msgid ""
"Another important difference between :class:`IntFlag` and :class:`Enum` is "
"that if no flags are set (the value is 0), its boolean evaluation is :data:"
"`False`::"
msgstr ""
"Otra diferencia importante entre :class:`IntFlag` y :class:`Enum` es que si "
"no hay banderas (el valor es 0), su evaluación booleana es :data:`False`::"

#: ../../howto/enum.rst:734
msgid ""
"Because :class:`IntFlag` members are also subclasses of :class:`int` they "
"can be combined with them (but may lose :class:`IntFlag` membership::"
msgstr ""
"Dado que los miembros de :class:`IntFlag` también son subclases de :class:"
"`int`, pueden combinarse con ellos (pero pueden perder la pertenencia a :"
"class:`IntFlag`::"

#: ../../howto/enum.rst:745
msgid ""
"The negation operator, ``~``, always returns an :class:`IntFlag` member with "
"a positive value::"
msgstr ""
"El operador de negación, ``~``, siempre devuelve un miembro de :class:"
"`IntFlag` con valor positivo::"

#: ../../howto/enum.rst:751
msgid ":class:`IntFlag` members can also be iterated over::"
msgstr ":class:`IntFlag` también se puede iterar sobre::"

#: ../../howto/enum.rst:760
msgid "Flag"
msgstr "Bandera"

#: ../../howto/enum.rst:762
msgid ""
"The last variation is :class:`Flag`.  Like :class:`IntFlag`, :class:`Flag` "
"members can be combined using the bitwise operators (&, \\|, ^, ~).  Unlike :"
"class:`IntFlag`, they cannot be combined with, nor compared against, any "
"other :class:`Flag` enumeration, nor :class:`int`.  While it is possible to "
"specify the values directly it is recommended to use :class:`auto` as the "
"value and let :class:`Flag` select an appropriate value."
msgstr ""
"La última variante es :class:`Flag`.  Al igual que :class:`IntFlag`, los "
"miembros de :class:`Flag` pueden combinarse utilizando los operadores bit a "
"bit (&, ||, ^, ~).  A diferencia de :class:`IntFlag`, no pueden combinarse "
"ni compararse con ninguna otra enumeración de :class:`Flag`, ni con :class:"
"`int`.  Aunque es posible especificar los valores directamente, se "
"recomienda utilizar :class:`auto` como valor y dejar que :class:`Flag` "
"seleccione un valor apropiado."

#: ../../howto/enum.rst:771
msgid ""
"Like :class:`IntFlag`, if a combination of :class:`Flag` members results in "
"no flags being set, the boolean evaluation is :data:`False`::"
msgstr ""
"Al igual que :class:`IntFlag`, si una combinación de los miembros de :class:"
"`Flag` da como resultado que no se activa ningún indicador, la evaluación "
"booleana es :data:`False`::"

#: ../../howto/enum.rst:785
msgid ""
"Individual flags should have values that are powers of two (1, 2, 4, "
"8, ...), while combinations of flags will not::"
msgstr ""
"Las banderas individuales deben tener valores que sean potencias de dos (1, "
"2, 4, 8, ...), mientras que las combinaciones de banderas no::"

#: ../../howto/enum.rst:797
msgid ""
"Giving a name to the \"no flags set\" condition does not change its boolean "
"value::"
msgstr ""
"Dar un nombre a la condición\"no flags set\" no cambia su valor booleano::"

#: ../../howto/enum.rst:811
msgid ":class:`Flag` members can also be iterated over::"
msgstr ":class:`Flag` también se puede iterar sobre::"

#: ../../howto/enum.rst:821
msgid ""
"For the majority of new code, :class:`Enum` and :class:`Flag` are strongly "
"recommended, since :class:`IntEnum` and :class:`IntFlag` break some semantic "
"promises of an enumeration (by being comparable to integers, and thus by "
"transitivity to other unrelated enumerations).  :class:`IntEnum` and :class:"
"`IntFlag` should be used only in cases where :class:`Enum` and :class:`Flag` "
"will not do; for example, when integer constants are replaced with "
"enumerations, or for interoperability with other systems."
msgstr ""
"Para la mayoría del código nuevo, se recomiendan encarecidamente :class:"
"`Enum` y :class:`Flag`, ya que :class:`IntEnum` y :class:`IntFlag` rompen "
"algunas promesas semánticas de una enumeración (al ser comparables a números "
"enteros y, por tanto, por transitividad a otras enumeraciones no "
"relacionadas). :class:`IntEnum` y :class:`IntFlag` deben utilizarse sólo en "
"los casos en que :class:`Enum` y :class:`Flag` no sirvan; por ejemplo, "
"cuando las constantes enteras se sustituyan por enumeraciones, o por "
"interoperabilidad con otros sistemas."

#: ../../howto/enum.rst:831
msgid "Others"
msgstr "Otros"

#: ../../howto/enum.rst:833
msgid ""
"While :class:`IntEnum` is part of the :mod:`enum` module, it would be very "
"simple to implement independently::"
msgstr ""
"Aunque :class:`IntEnum` forma parte del módulo :mod:`enum`, sería muy "
"sencillo implementarlo de forma independiente::"

#: ../../howto/enum.rst:839
msgid ""
"This demonstrates how similar derived enumerations can be defined; for "
"example a :class:`FloatEnum` that mixes in :class:`float` instead of :class:"
"`int`."
msgstr ""
"Esto demuestra cómo se pueden definir enumeraciones derivadas similares; por "
"ejemplo, una :class:`FloatEnum` que mezcla en :class:`float` en lugar de :"
"class:`int`."

#: ../../howto/enum.rst:842
msgid "Some rules:"
msgstr "Algunas reglas:"

#: ../../howto/enum.rst:844
msgid ""
"When subclassing :class:`Enum`, mix-in types must appear before :class:"
"`Enum` itself in the sequence of bases, as in the :class:`IntEnum` example "
"above."
msgstr ""
"Al subclasificar :class:`Enum`, los tipos mixtos deben aparecer antes que el "
"propio :class:`Enum` en la secuencia de bases, como en el ejemplo anterior "
"de :class:`IntEnum`."

#: ../../howto/enum.rst:847
msgid ""
"Mix-in types must be subclassable. For example, :class:`bool` and :class:"
"`range` are not subclassable and will throw an error during Enum creation if "
"used as the mix-in type."
msgstr ""
"Los tipos mix-in deben ser subclasificables. Por ejemplo, :class:`bool` y :"
"class:`range` no son subclasificables y arrojarán un error durante la "
"creación de Enum si se utilizan como tipo mix-in."

#: ../../howto/enum.rst:850
msgid ""
"While :class:`Enum` can have members of any type, once you mix in an "
"additional type, all the members must have values of that type, e.g. :class:"
"`int` above.  This restriction does not apply to mix-ins which only add "
"methods and don't specify another type."
msgstr ""
"Mientras que :class:`Enum` puede tener miembros de cualquier tipo, una vez "
"que se mezcla en un tipo adicional, todos los miembros deben tener valores "
"de ese tipo, por ejemplo, :class:`int` arriba.  Esta restricción no se "
"aplica a las mezclas que sólo añaden métodos y no especifican otro tipo."

#: ../../howto/enum.rst:854
msgid ""
"When another data type is mixed in, the :attr:`value` attribute is *not the "
"same* as the enum member itself, although it is equivalent and will compare "
"equal."
msgstr ""
"Cuando se mezcla otro tipo de datos, el atributo :attr:`value` *not the "
"same* que el propio miembro del enum, aunque es equivalente y se comparará "
"igual."

#: ../../howto/enum.rst:857
msgid "A ``data type`` is a mixin that defines :meth:`__new__`."
msgstr ""

#: ../../howto/enum.rst:858
msgid ""
"%-style formatting:  ``%s`` and ``%r`` call the :class:`Enum` class's :meth:"
"`__str__` and :meth:`__repr__` respectively; other codes (such as ``%i`` or "
"``%h`` for IntEnum) treat the enum member as its mixed-in type."
msgstr ""
"%-sformateo del tipo: ``%s`` y ``%r`` llaman a los :meth:`__str__` y :meth:"
"`__repr__` de la clase :class:`Enum` respectivamente; otros códigos (como "
"``%i`` o ``%h`` para IntEnum) tratan al miembro del enum como su tipo mixto."

#: ../../howto/enum.rst:861
msgid ""
":ref:`Formatted string literals <f-strings>`, :meth:`str.format`, and :func:"
"`format` will use the enum's :meth:`__str__` method."
msgstr ""
":ref:`Formatted string literals <f-strings>`, :meth:`str.format`, y :func:"
"`format` utilizarán el método :meth:`__str__` del enum."

#: ../../howto/enum.rst:866
msgid ""
"Because :class:`IntEnum`, :class:`IntFlag`, and :class:`StrEnum` are "
"designed to be drop-in replacements for existing constants, their :meth:"
"`__str__` method has been reset to their data types' :meth:`__str__` method."
msgstr ""
"Dado que :class:`IntEnum`, :class:`IntFlag`, y :class:`StrEnum` se han "
"diseñado para sustituir a las constantes existentes, su método :meth:"
"`__str__` se ha reajustado al método :meth:`__str__` de sus tipos de datos."

#: ../../howto/enum.rst:874
msgid "When to use :meth:`__new__` vs. :meth:`__init__`"
msgstr "Cuándo utilizar :meth:`__new__` vs. :meth:`__init__`"

#: ../../howto/enum.rst:876
msgid ""
":meth:`__new__` must be used whenever you want to customize the actual value "
"of the :class:`Enum` member.  Any other modifications may go in either :meth:"
"`__new__` or :meth:`__init__`, with :meth:`__init__` being preferred."
msgstr ""
":meth:`__new__` debe utilizarse siempre que se desee personalizar el valor "
"real del miembro :class:`Enum`.  Cualquier otra modificación puede ir en :"
"meth:`__new__` o :meth:`__init__`, siendo preferible :meth:`__init__`."

#: ../../howto/enum.rst:880
msgid ""
"For example, if you want to pass several items to the constructor, but only "
"want one of them to be the value::"
msgstr ""
"Por ejemplo, si quieres pasar varios elementos al constructor, pero sólo "
"quieres que uno de ellos sea el valor::"

#: ../../howto/enum.rst:907
msgid ""
"*Do not* call ``super().__new__()``, as the lookup-only ``__new__`` is the "
"one that is found; instead, use the data type directly."
msgstr ""
"*No* llame a ``super().__new__()``, ya que la búsqueda ``__new__`` es la que "
"se encuentra; en su lugar, utilice el tipo de datos directamente."

#: ../../howto/enum.rst:912
msgid "Finer Points"
msgstr "Puntos más delicados"

#: ../../howto/enum.rst:915
msgid "Supported ``__dunder__`` names"
msgstr "Nombres compatibles ``__dunder__`` "

#: ../../howto/enum.rst:917
msgid ""
":attr:`__members__` is a read-only ordered mapping of ``member_name``:"
"``member`` items.  It is only available on the class."
msgstr ""
":attr:`__members__` es una asignación ordenada de sólo lectura de "
"``member_name``:``member`` elementos.  Sólo está disponible en la clase"

#: ../../howto/enum.rst:920
msgid ""
":meth:`__new__`, if specified, must create and return the enum members; it "
"is also a very good idea to set the member's :attr:`_value_` appropriately.  "
"Once all the members are created it is no longer used."
msgstr ""
":meth:`__new__`, si se especifica, debe crear y devolver los miembros del "
"enum; también es una muy buena idea establecer el :attr:`_value_` del "
"miembro apropiadamente.  Una vez creados todos los miembros ya no se utiliza."

#: ../../howto/enum.rst:926
msgid "Supported ``_sunder_`` names"
msgstr "Nombres compatibles ``_sunder_`` "

#: ../../howto/enum.rst:928
msgid "``_name_`` -- name of the member"
msgstr "``_name_`` -- nombre del miembro"

#: ../../howto/enum.rst:929
msgid ""
"``_value_`` -- value of the member; can be set / modified in ``__new__``"
msgstr ""
"``_value_`` -- valor del miembro; puede establecerse / modificarse en "
"``__new__``"

#: ../../howto/enum.rst:931
msgid ""
"``_missing_`` -- a lookup function used when a value is not found; may be "
"overridden"
msgstr ""
"``_missing_`` -- una función de búsqueda que se utiliza cuando no se "
"encuentra un valor; puede sobrescribirse"

#: ../../howto/enum.rst:933
msgid ""
"``_ignore_`` -- a list of names, either as a :class:`list` or a :class:"
"`str`, that will not be transformed into members, and will be removed from "
"the final class"
msgstr ""
"``_ignore_`` -- una lista de nombres, ya sea como :class:`list` o :class:"
"`str`, que no serán transformados en miembros, y serán eliminados de la "
"clase final."

#: ../../howto/enum.rst:936
msgid ""
"``_order_`` -- used in Python 2/3 code to ensure member order is consistent "
"(class attribute, removed during class creation)"
msgstr ""
"``_order_`` -- usado en código Python 2/3 para asegurar que el orden de los "
"miembros es consistente (atributo de clase, eliminado durante la creación de "
"la clase)"

#: ../../howto/enum.rst:938
msgid ""
"``_generate_next_value_`` -- used by the `Functional API`_ and by :class:"
"`auto` to get an appropriate value for an enum member; may be overridden"
msgstr ""
"``_generate_next_value_`` -- utilizado por la `Functional API`_ y por :class:"
"`auto` para obtener un valor apropiado para un miembro de enum; puede ser "
"sobreescrito"

#: ../../howto/enum.rst:944
msgid ""
"For standard :class:`Enum` classes the next value chosen is the last value "
"seen incremented by one."
msgstr ""
"Para las clases estándar :class:`Enum` el siguiente valor elegido es el "
"último valor visto incrementado en uno."

#: ../../howto/enum.rst:947
msgid ""
"For :class:`Flag` classes the next value chosen will be the next highest "
"power-of-two, regardless of the last value seen."
msgstr ""
"Para las clases :class:`Flag` el siguiente valor elegido será la siguiente "
"potencia de dos más alta, independientemente del último valor visto."

#: ../../howto/enum.rst:950
msgid "``_missing_``, ``_order_``, ``_generate_next_value_``"
msgstr "``_missing_``, ``_order_``, ``_generate_next_value_``"

#: ../../howto/enum.rst:951
msgid "``_ignore_``"
msgstr "``_ignore_``"

#: ../../howto/enum.rst:953
msgid ""
"To help keep Python 2 / Python 3 code in sync an :attr:`_order_` attribute "
"can be provided.  It will be checked against the actual order of the "
"enumeration and raise an error if the two do not match::"
msgstr ""
"Para ayudar a mantener el código Python 2 / Python 3 en sincronía se puede "
"proporcionar un atributo :attr:`_order_`.  Se cotejará con el orden real de "
"la enumeración y generará un error si ambos no coinciden::"

#: ../../howto/enum.rst:971
msgid ""
"In Python 2 code the :attr:`_order_` attribute is necessary as definition "
"order is lost before it can be recorded."
msgstr ""
"En el código Python 2 el atributo :attr:`_order_` es necesario ya que la "
"orden de definición se pierde antes de poder ser registrada."

#: ../../howto/enum.rst:976
msgid "_Private__names"
msgstr "_Private__names"

#: ../../howto/enum.rst:978
msgid ""
":ref:`Private names <private-name-mangling>` are not converted to enum "
"members, but remain normal attributes."
msgstr ""
":ref:`Private names <private-name-mangling>` no se convierten en miembros de "
"enum, sino que siguen siendo atributos normales."

#: ../../howto/enum.rst:985
msgid "``Enum`` member type"
msgstr "``Enum`` tipo de miembro"

#: ../../howto/enum.rst:987
msgid ""
"Enum members are instances of their enum class, and are normally accessed as "
"``EnumClass.member``.  In certain situations, such as writing custom enum "
"behavior, being able to access one member directly from another is useful, "
"and is supported."
msgstr ""

#: ../../howto/enum.rst:996
msgid "Creating members that are mixed with other data types"
msgstr "Creación de miembros mezclados con otros tipos de datos"

#: ../../howto/enum.rst:998
msgid ""
"When subclassing other data types, such as :class:`int` or :class:`str`, "
"with an :class:`Enum`, all values after the ``=`` are passed to that data "
"type's constructor.  For example::"
msgstr ""
"Al subclasificar otros tipos de datos, como :class:`int` o :class:`str`, con "
"un :class:`Enum`, todos los valores posteriores a ``=`` se pasan al "
"constructor de ese tipo de datos.  Por ejemplo::"

#: ../../howto/enum.rst:1010
msgid "Boolean value of ``Enum`` classes and members"
msgstr "Valor booleano de las clases y miembros de ``Enum`` "

#: ../../howto/enum.rst:1012
msgid ""
"Enum classes that are mixed with non-:class:`Enum` types (such as :class:"
"`int`, :class:`str`, etc.) are evaluated according to the mixed-in type's "
"rules; otherwise, all members evaluate as :data:`True`.  To make your own "
"enum's boolean evaluation depend on the member's value add the following to "
"your class::"
msgstr ""
"Las clases Enum que se mezclan con tipos que no son:class:`Enum` (como :"
"class:`int`, :class:`str`, etc.) se evalúan según las reglas del tipo "
"mezclado; de lo contrario, todos los miembros se evalúan como :data:`True`.  "
"Para hacer que la evaluación booleana de su propio enum dependa del valor "
"del miembro, añada lo siguiente a su clase::"

#: ../../howto/enum.rst:1021
msgid "Plain :class:`Enum` classes always evaluate as :data:`True`."
msgstr ""
"Las clases simples de :class:`Enum` siempre se evalúan como :data:`True`."

#: ../../howto/enum.rst:1025
msgid "``Enum`` classes with methods"
msgstr "``Enum`` clases con métodos"

#: ../../howto/enum.rst:1027
msgid ""
"If you give your enum subclass extra methods, like the `Planet`_ class "
"below, those methods will show up in a :func:`dir` of the member, but not of "
"the class::"
msgstr ""
"Si le das a tu subclase enum métodos extra, como la clase `Planet`_ de "
"abajo, esos métodos aparecerán en un :func:`dir` del miembro, pero no de la "
"clase::"

#: ../../howto/enum.rst:1038
msgid "Combining members of ``Flag``"
msgstr "Combinación de miembros de ``Flag``"

#: ../../howto/enum.rst:1040
msgid ""
"Iterating over a combination of :class:`Flag` members will only return the "
"members that are comprised of a single bit::"
msgstr ""
"Al iterar sobre una combinación de miembros de :class:`Flag` sólo se "
"devolverán los miembros que estén formados por un único bit::"

#: ../../howto/enum.rst:1058
msgid "``Flag`` and ``IntFlag`` minutia"
msgstr "``Flag`` y ``IntFlag`` minucias"

#: ../../howto/enum.rst:1060
msgid "Using the following snippet for our examples::"
msgstr "Utilizando el siguiente fragmento para nuestros ejemplos::"

#: ../../howto/enum.rst:1071
msgid "the following are true:"
msgstr "lo siguiente es cierto:"

#: ../../howto/enum.rst:1073
msgid "single-bit flags are canonical"
msgstr "las banderas de un solo bit son canónicas"

#: ../../howto/enum.rst:1074
msgid "multi-bit and zero-bit flags are aliases"
msgstr "las banderas de varios bits y de cero bits son alias"

#: ../../howto/enum.rst:1075
msgid "only canonical flags are returned during iteration::"
msgstr "sólo se devuelven las banderas canónicas durante la iteración::"

#: ../../howto/enum.rst:1080
msgid ""
"negating a flag or flag set returns a new flag/flag set with the "
"corresponding positive integer value::"
msgstr ""
"la negación de una bandera o conjunto de banderas devuelve una nueva bandera/"
"conjunto de banderas con el correspondiente valor entero positivo::"

#: ../../howto/enum.rst:1089
msgid "names of pseudo-flags are constructed from their members' names::"
msgstr ""
"los nombres de las pseudobanderas se construyen a partir de los nombres de "
"sus miembros::"

#: ../../howto/enum.rst:1094
msgid "multi-bit flags, aka aliases, can be returned from operations::"
msgstr ""
"las banderas multibit, alias, pueden ser devueltas por las operaciones::"

#: ../../howto/enum.rst:1105
msgid ""
"membership / containment checking: zero-valued flags are always considered "
"to be contained::"
msgstr ""
"comprobación de pertenencia/contención: las banderas de valor cero siempre "
"se consideran contenidas::"

#: ../../howto/enum.rst:1111
msgid ""
"otherwise, only if all bits of one flag are in the other flag will True be "
"returned::"
msgstr ""
"de lo contrario, sólo si todos los bits de una bandera están en la otra "
"bandera se devolverá True::"

#: ../../howto/enum.rst:1120
msgid ""
"There is a new boundary mechanism that controls how out-of-range / invalid "
"bits are handled: ``STRICT``, ``CONFORM``, ``EJECT``, and ``KEEP``:"
msgstr ""
"Existe un nuevo mecanismo de límites que controla cómo se gestionan los bits "
"fuera de rango / no válidos: ``STRICT``, ``CONFORM``, ``EJECT``, y ``KEEP``:"

#: ../../howto/enum.rst:1123
msgid "STRICT --> raises an exception when presented with invalid values"
msgstr "STRICT --> lanza una excepción cuando se presentan valores no válidos"

#: ../../howto/enum.rst:1124
msgid "CONFORM --> discards any invalid bits"
msgstr "CONFORM --> descarta los bits no válidos"

#: ../../howto/enum.rst:1125
msgid "EJECT --> lose Flag status and become a normal int with the given value"
msgstr ""
"EJECT --> pierde el estado Flag y se convierte en un int normal con el valor "
"dado"

#: ../../howto/enum.rst:1126
msgid "KEEP --> keep the extra bits"
msgstr "KEEP --> mantener los bits adicionales"

#: ../../howto/enum.rst:1128
msgid "keeps Flag status and extra bits"
msgstr "mantiene el estado del indicador y los bits adicionales"

#: ../../howto/enum.rst:1129
msgid "extra bits do not show up in iteration"
msgstr "los bits adicionales no aparecen en la iteración"

#: ../../howto/enum.rst:1130
msgid "extra bits do show up in repr() and str()"
msgstr "los bits adicionales aparecen en repr() y str()"

#: ../../howto/enum.rst:1132
msgid ""
"The default for Flag is ``STRICT``, the default for ``IntFlag`` is "
"``EJECT``, and the default for ``_convert_`` is ``KEEP`` (see ``ssl."
"Options`` for an example of when ``KEEP`` is needed)."
msgstr ""
"El valor predeterminado para Flag es ``STRICT``, el valor predeterminado "
"para ``IntFlag`` es ``EJECT``, y el valor predeterminado para ``_convert_`` "
"es ``KEEP`` (consulte ``ssl.Options`` para ver un ejemplo de cuándo se "
"necesita ``KEEP`` )."

#: ../../howto/enum.rst:1140
msgid "How are Enums and Flags different?"
msgstr "¿En qué se diferencian los Enums y los Flags?"

#: ../../howto/enum.rst:1142
msgid ""
"Enums have a custom metaclass that affects many aspects of both derived :"
"class:`Enum` classes and their instances (members)."
msgstr ""
"Los Enums tienen una metaclase personalizada que afecta a muchos aspectos "
"tanto de las clases derivadas :class:`Enum` como de sus instancias "
"(miembros)."

#: ../../howto/enum.rst:1147
msgid "Enum Classes"
msgstr "Clases Enum"

#: ../../howto/enum.rst:1149
msgid ""
"The :class:`EnumType` metaclass is responsible for providing the :meth:"
"`__contains__`, :meth:`__dir__`, :meth:`__iter__` and other methods that "
"allow one to do things with an :class:`Enum` class that fail on a typical "
"class, such as ``list(Color)`` or ``some_enum_var in Color``.  :class:"
"`EnumType` is responsible for ensuring that various other methods on the "
"final :class:`Enum` class are correct (such as :meth:`__new__`, :meth:"
"`__getnewargs__`, :meth:`__str__` and :meth:`__repr__`)."
msgstr ""
"La metaclase :class:`EnumType` es responsable de proporcionar los métodos :"
"meth:`__contains__`, :meth:`__dir__`, :meth:`__iter__` y otros que permiten "
"hacer cosas con una clase :class:`Enum` que fallan en una clase típica, como "
"``list(Color)`` o ``some_enum_var in Color``. :class:`EnumType` es "
"responsable de asegurar que varios otros métodos en la clase final :class:"
"`Enum` sean correctos (como :meth:`__new__`, :meth:`__getnewargs__`, :meth:"
"`__str__` y :meth:`__repr__`)."

#: ../../howto/enum.rst:1158
msgid "Flag Classes"
msgstr "Clases de banderas"

#: ../../howto/enum.rst:1160
msgid ""
"Flags have an expanded view of aliasing: to be canonical, the value of a "
"flag needs to be a power-of-two value, and not a duplicate name.  So, in "
"addition to the :class:`Enum` definition of alias, a flag with no value (a.k."
"a. ``0``) or with more than one power-of-two value (e.g. ``3``) is "
"considered an alias."
msgstr ""
"Las banderas tienen una visión ampliada de los alias: para ser canónica, el "
"valor de una bandera debe ser un valor de potencia de dos, y no un nombre "
"duplicado.  Así, además de la definición de alias de :class:`Enum`, una "
"bandera sin valor (también conocida como ``0``) o con más de un valor de "
"potencia de dos (por ejemplo, ``3``) se considera un alias."

#: ../../howto/enum.rst:1166
msgid "Enum Members (aka instances)"
msgstr "Miembros de Enum (también conocidos como instancias)"

#: ../../howto/enum.rst:1168
msgid ""
"The most interesting thing about enum members is that they are singletons. :"
"class:`EnumType` creates them all while it is creating the enum class "
"itself, and then puts a custom :meth:`__new__` in place to ensure that no "
"new ones are ever instantiated by returning only the existing member "
"instances."
msgstr ""
"Lo más interesante de los miembros de enum es que son singletons. :class:"
"`EnumType` los crea todos mientras crea la propia clase enum y, a "
"continuación, coloca un :meth:`__new__` personalizado para garantizar que "
"nunca se instancien nuevos miembros devolviendo sólo las instancias de los "
"miembros existentes."

#: ../../howto/enum.rst:1174
msgid "Flag Members"
msgstr "Abanderados"

#: ../../howto/enum.rst:1176
msgid ""
"Flag members can be iterated over just like the :class:`Flag` class, and "
"only the canonical members will be returned.  For example::"
msgstr ""
"Se puede iterar sobre los miembros de la bandera igual que en la clase :"
"class:`Flag`, y sólo se devolverán los miembros canónicos.  Por ejemplo::"

#: ../../howto/enum.rst:1182
msgid "(Note that ``BLACK``, ``PURPLE``, and ``WHITE`` do not show up.)"
msgstr "(Observe que ``BLACK``, ``PURPLE`` y ``WHITE`` no aparecen)."

#: ../../howto/enum.rst:1184
msgid ""
"Inverting a flag member returns the corresponding positive value, rather "
"than a negative value --- for example::"
msgstr ""
"Invertir un miembro de la bandera devuelve el valor positivo "
"correspondiente, en lugar de un valor negativo --- por ejemplo::"

#: ../../howto/enum.rst:1190
msgid ""
"Flag members have a length corresponding to the number of power-of-two "
"values they contain.  For example::"
msgstr ""
"Los indicadores tienen una longitud correspondiente al número de potencias "
"de dos que contienen.  Por ejemplo::"

#: ../../howto/enum.rst:1200
msgid "Enum Cookbook"
msgstr "Enum Cookbook"

#: ../../howto/enum.rst:1203
msgid ""
"While :class:`Enum`, :class:`IntEnum`, :class:`StrEnum`, :class:`Flag`, and :"
"class:`IntFlag` are expected to cover the majority of use-cases, they cannot "
"cover them all.  Here are recipes for some different types of enumerations "
"that can be used directly, or as examples for creating one's own."
msgstr ""
"Aunque se espera que :class:`Enum`, :class:`IntEnum`, :class:`StrEnum`, :"
"class:`Flag`, y :class:`IntFlag` cubran la mayoría de los casos de uso, no "
"pueden abarcarlos todos.  A continuación se presentan recetas para algunos "
"tipos diferentes de enumeraciones que pueden utilizarse directamente, o como "
"ejemplos para crear las propias."

#: ../../howto/enum.rst:1210
msgid "Omitting values"
msgstr "Omisión de valores"

#: ../../howto/enum.rst:1212
msgid ""
"In many use-cases, one doesn't care what the actual value of an enumeration "
"is. There are several ways to define this type of simple enumeration:"
msgstr ""
"En muchos casos de uso, a uno no le importa cuál es el valor real de una "
"enumeración. Hay varias formas de definir este tipo de enumeración simple:"

#: ../../howto/enum.rst:1215
msgid "use instances of :class:`auto` for the value"
msgstr "utilizar instancias de :class:`auto` para el valor"

#: ../../howto/enum.rst:1216
msgid "use instances of :class:`object` as the value"
msgstr "utilizar instancias de :class:`object` como valor"

#: ../../howto/enum.rst:1217
msgid "use a descriptive string as the value"
msgstr "utilizar una cadena descriptiva como valor"

#: ../../howto/enum.rst:1218
msgid ""
"use a tuple as the value and a custom :meth:`__new__` to replace the tuple "
"with an :class:`int` value"
msgstr ""
"utilizar una tupla como valor y un :meth:`__new__` personalizado para "
"sustituir la tupla por un valor :class:`int` "

#: ../../howto/enum.rst:1221
msgid ""
"Using any of these methods signifies to the user that these values are not "
"important, and also enables one to add, remove, or reorder members without "
"having to renumber the remaining members."
msgstr ""
"El uso de cualquiera de estos métodos indica al usuario que estos valores no "
"son importantes, y también permite añadir, eliminar o reordenar miembros sin "
"tener que renumerar el resto de miembros."

#: ../../howto/enum.rst:1227
msgid "Using :class:`auto`"
msgstr "Utilizando :class:`auto`"

#: ../../howto/enum.rst:1229
msgid "Using :class:`auto` would look like::"
msgstr "Utilizando :class:`auto` quedaría así::"

#: ../../howto/enum.rst:1241
msgid "Using :class:`object`"
msgstr "Utilizando :class:`object`"

#: ../../howto/enum.rst:1243
msgid "Using :class:`object` would look like::"
msgstr "Utilizando :class:`object` quedaría así::"

#: ../../howto/enum.rst:1253
msgid ""
"This is also a good example of why you might want to write your own :meth:"
"`__repr__`::"
msgstr ""
"Este es también un buen ejemplo de por qué le conviene escribir su propia :"
"meth:`__repr__`::"

#: ../../howto/enum.rst:1269
msgid "Using a descriptive string"
msgstr "Utilizar una cadena descriptiva"

#: ../../howto/enum.rst:1271
msgid "Using a string as the value would look like::"
msgstr "Utilizando una cadena como valor quedaría así::"

#: ../../howto/enum.rst:1283
msgid "Using a custom :meth:`__new__`"
msgstr "Utilizar un :meth:`__new__`"

#: ../../howto/enum.rst:1285
msgid "Using an auto-numbering :meth:`__new__` would look like::"
msgstr "Utilizando una numeración automática :meth:`__new__` quedaría así::"

#: ../../howto/enum.rst:1302
msgid ""
"To make a more general purpose ``AutoNumber``, add ``*args`` to the "
"signature::"
msgstr ""
"Para hacer un uso más general de ``AutoNumber``, añada ``*args`` a la firma::"

#: ../../howto/enum.rst:1312
msgid ""
"Then when you inherit from ``AutoNumber`` you can write your own "
"``__init__`` to handle any extra arguments::"
msgstr ""
"Entonces cuando heredes de ``AutoNumber`` puedes escribir tu propio "
"``__init__`` para manejar cualquier argumento extra::"

#: ../../howto/enum.rst:1331
msgid ""
"The :meth:`__new__` method, if defined, is used during creation of the Enum "
"members; it is then replaced by Enum's :meth:`__new__` which is used after "
"class creation for lookup of existing members."
msgstr ""
"El método :meth:`__new__`, si está definido, se utiliza durante la creación "
"de los miembros de Enum; después se sustituye por :meth:`__new__` de Enum, "
"que se utiliza tras la creación de la clase para buscar los miembros "
"existentes."

#: ../../howto/enum.rst:1337
msgid ""
"*Do not* call ``super().__new__()``, as the lookup-only ``__new__`` is the "
"one that is found; instead, use the data type directly -- e.g.::"
msgstr ""
"*No* llame a ``super().__new__()``, ya que la búsqueda sólo ``__new__`` es "
"la que se encuentra; en su lugar, utilice el tipo de datos directamente -- "
"por ejemplo::"

#: ../../howto/enum.rst:1344
msgid "OrderedEnum"
msgstr "OrderedEnum"

#: ../../howto/enum.rst:1346
msgid ""
"An ordered enumeration that is not based on :class:`IntEnum` and so "
"maintains the normal :class:`Enum` invariants (such as not being comparable "
"to other enumerations)::"
msgstr ""
"Una enumeración ordenada que no se basa en :class:`IntEnum` y, por tanto, "
"mantiene las invariantes normales de :class:`Enum` (como no ser comparable "
"con otras enumeraciones)::"

#: ../../howto/enum.rst:1380
msgid "DuplicateFreeEnum"
msgstr "DuplicateFreeEnum"

#: ../../howto/enum.rst:1382
msgid ""
"Raises an error if a duplicate member value is found instead of creating an "
"alias::"
msgstr ""
"Genera un error si se encuentra un valor de miembro duplicado en lugar de "
"crear un alias::"

#: ../../howto/enum.rst:1407
msgid ""
"This is a useful example for subclassing Enum to add or change other "
"behaviors as well as disallowing aliases.  If the only desired change is "
"disallowing aliases, the :func:`unique` decorator can be used instead."
msgstr ""
"Este es un ejemplo útil para subclasificar Enum para añadir o cambiar otros "
"comportamientos, así como para no permitir alias.  Si el único cambio "
"deseado es no permitir alias, se puede utilizar el decorador :func:`unique`."

#: ../../howto/enum.rst:1413
msgid "Planet"
msgstr "Planeta"

#: ../../howto/enum.rst:1415
msgid ""
"If :meth:`__new__` or :meth:`__init__` is defined, the value of the enum "
"member will be passed to those methods::"
msgstr ""
"Si se define :meth:`__new__` o :meth:`__init__`, el valor del miembro del "
"enum se pasará a esos métodos::"

#: ../../howto/enum.rst:1444
msgid "TimePeriod"
msgstr "TimePeriod"

#: ../../howto/enum.rst:1446
msgid "An example to show the :attr:`_ignore_` attribute in use::"
msgstr "Un ejemplo para mostrar el atributo :attr:`_ignore_` en uso::"

#: ../../howto/enum.rst:1465
msgid "Subclassing EnumType"
msgstr "Subclasificación de EnumType"

#: ../../howto/enum.rst:1467
msgid ""
"While most enum needs can be met by customizing :class:`Enum` subclasses, "
"either with class decorators or custom functions, :class:`EnumType` can be "
"subclassed to provide a different Enum experience."
msgstr ""
"Mientras que la mayoría de las necesidades de enum se pueden satisfacer "
"personalizando las subclases de :class:`Enum`, ya sea con decoradores de "
"clase o funciones personalizadas, :class:`EnumType` se puede subclasificar "
"para proporcionar una experiencia Enum diferente."
