# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# eulalio barbero espinosa <eulalio@disroot.org>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-17 14:51+0000\n"
"PO-Revision-Date: 2024-05-11 00:32+0000\n"
"Last-Translator: eulalio barbero espinosa <eulalio@disroot.org>, 2024\n"
"Language-Team: Spanish (Spain) (https://app.transifex.com/python-doc/"
"teams/5390/es_ES/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es_ES\n"
"Plural-Forms: nplurals=3; plural=n == 1 ? 0 : n != 0 && n % 1000000 == 0 ? "
"1 : 2;\n"

#: ../../howto/annotations.rst:5
msgid "Annotations Best Practices"
msgstr "Buenas prácticas en materia de anotaciones"

#: ../../howto/annotations.rst:0
msgid "author"
msgstr "autor"

#: ../../howto/annotations.rst:7
msgid "Larry Hastings"
msgstr "Larry Hastings"

#: ../../howto/annotations.rst-1
msgid "Abstract"
msgstr "Resumen"

#: ../../howto/annotations.rst:11
msgid ""
"This document is designed to encapsulate the best practices for working with "
"annotations dicts.  If you write Python code that examines "
"``__annotations__`` on Python objects, we encourage you to follow the "
"guidelines described below."
msgstr ""
"Este documento está diseñado para encapsular las mejores prácticas para "
"trabajar con dicts de anotaciones.  Si escribes código Python que examina "
"``__annotations__`` en objetos Python, te animamos a seguir las directrices "
"descritas a continuación."

#: ../../howto/annotations.rst:16
msgid ""
"The document is organized into four sections: best practices for accessing "
"the annotations of an object in Python versions 3.10 and newer, best "
"practices for accessing the annotations of an object in Python versions 3.9 "
"and older, other best practices for ``__annotations__`` that apply to any "
"Python version, and quirks of ``__annotations__``."
msgstr ""
"El documento está organizado en cuatro secciones: mejores prácticas para "
"acceder a las anotaciones de un objeto en las versiones de Python 3.10 y "
"posteriores, mejores prácticas para acceder a las anotaciones de un objeto "
"en las versiones de Python 3.9 y anteriores, otras mejores prácticas para "
"``__annotations__`` que se aplican a cualquier versión de Python y "
"peculiaridades de ``__annotations__``."

#: ../../howto/annotations.rst:26
msgid ""
"Note that this document is specifically about working with "
"``__annotations__``, not uses *for* annotations. If you're looking for "
"information on how to use \"type hints\" in your code, please see the :mod:"
"`typing` module."
msgstr ""
"Tenga en cuenta que este documento trata específicamente del trabajo con "
"``__annotations__``, no de los usos *for* las anotaciones. Si busca "
"información sobre cómo utilizar \"type hints\" en su código, consulte el "
"módulo :mod:`typing`."

#: ../../howto/annotations.rst:33
msgid "Accessing The Annotations Dict Of An Object In Python 3.10 And Newer"
msgstr ""
"Acceso al Dict de Anotaciones de un Objeto en Python 3.10 y posteriores"

#: ../../howto/annotations.rst:35
msgid ""
"Python 3.10 adds a new function to the standard library: :func:`inspect."
"get_annotations`.  In Python versions 3.10 and newer, calling this function "
"is the best practice for accessing the annotations dict of any object that "
"supports annotations.  This function can also \"un-stringize\" stringized "
"annotations for you."
msgstr ""
"Python 3.10 añade una nueva función a la biblioteca estándar: :func:`inspect."
"get_annotations`.  En las versiones de Python 3.10 y posteriores, llamar a "
"esta función es la mejor práctica para acceder al dictado de anotaciones de "
"cualquier objeto que soporte anotaciones.  Esta función también puede \"des-"
"cadenar\" anotaciones encadenadas."

#: ../../howto/annotations.rst:42
msgid ""
"If for some reason :func:`inspect.get_annotations` isn't viable for your use "
"case, you may access the ``__annotations__`` data member manually.  Best "
"practice for this changed in Python 3.10 as well: as of Python 3.10, ``o."
"__annotations__`` is guaranteed to *always* work on Python functions, "
"classes, and modules.  If you're certain the object you're examining is one "
"of these three *specific* objects, you may simply use ``o.__annotations__`` "
"to get at the object's annotations dict."
msgstr ""
"Si por alguna razón :func:`inspect.get_annotations` no es viable para tu "
"caso de uso, puedes acceder al miembro de datos ``__annotations__`` "
"manualmente.  La mejor práctica para esto también cambió en Python 3.10: a "
"partir de Python 3.10, ``o.__annotations__`` está garantizado para *siempre* "
"trabajar en funciones, clases y módulos de Python.  Si estás seguro de que "
"el objeto que estás examinando es uno de estos tres objetos *específicos*, "
"puedes simplemente usar ``o.__annotations__`` para acceder al dictado de "
"anotaciones del objeto."

#: ../../howto/annotations.rst:52
msgid ""
"However, other types of callables--for example, callables created by :func:"
"`functools.partial`--may not have an ``__annotations__`` attribute defined.  "
"When accessing the ``__annotations__`` of a possibly unknown object,  best "
"practice in Python versions 3.10 and newer is to call :func:`getattr` with "
"three arguments, for example ``getattr(o, '__annotations__', None)``."
msgstr ""
"Sin embargo, otros tipos de callables--por ejemplo, callables creados por :"
"func:`functools.partial`--pueden no tener un atributo ``__annotations__`` "
"definido.  Cuando se accede a ``__annotations__`` de un objeto posiblemente "
"desconocido, la mejor práctica en las versiones de Python 3.10 y posteriores "
"es llamar a :func:`getattr` con tres argumentos, por ejemplo ``getattr(o, "
"'__annotations__', None)``."

#: ../../howto/annotations.rst:60
msgid ""
"Before Python 3.10, accessing ``__annotations__`` on a class that defines no "
"annotations but that has a parent class with annotations would return the "
"parent's ``__annotations__``. In Python 3.10 and newer, the child class's "
"annotations will be an empty dict instead."
msgstr ""
"Antes de Python 3.10, el acceso a ``__annotations__`` en una clase que no "
"define anotaciones pero que tiene una clase padre con anotaciones devolvería "
"el ``__annotations__`` de la clase padre. En Python 3.10 y posteriores, las "
"anotaciones de la clase hija serán un dict vacío."

#: ../../howto/annotations.rst:68
msgid "Accessing The Annotations Dict Of An Object In Python 3.9 And Older"
msgstr "Acceso al Dict de Anotaciones de un Objeto en Python 3.9 y anteriores"

#: ../../howto/annotations.rst:70
msgid ""
"In Python 3.9 and older, accessing the annotations dict of an object is much "
"more complicated than in newer versions. The problem is a design flaw in "
"these older versions of Python, specifically to do with class annotations."
msgstr ""
"En Python 3.9 y versiones anteriores, acceder al dictado de anotaciones de "
"un objeto es mucho más complicado que en versiones más recientes. El "
"problema es un defecto de diseño en estas versiones antiguas de Python, "
"específicamente en lo que respecta a las anotaciones de clase."

#: ../../howto/annotations.rst:75
msgid ""
"Best practice for accessing the annotations dict of other objects--"
"functions, other callables, and modules--is the same as best practice for "
"3.10, assuming you aren't calling :func:`inspect.get_annotations`: you "
"should use three-argument :func:`getattr` to access the object's "
"``__annotations__`` attribute."
msgstr ""
"La mejor práctica para acceder al dictado de anotaciones de otros objetos -"
"funciones, otros callables y módulos- es la misma que la mejor práctica para "
"3.10, asumiendo que no se está llamando a :func:`inspect.get_annotations`: "
"se debe utilizar :func:`getattr` de tres argumentos para acceder al atributo "
"``__annotations__`` del objeto."

#: ../../howto/annotations.rst:82
msgid ""
"Unfortunately, this isn't best practice for classes.  The problem is that, "
"since ``__annotations__`` is optional on classes, and because classes can "
"inherit attributes from their base classes, accessing the "
"``__annotations__`` attribute of a class may inadvertently return the "
"annotations dict of a *base class.* As an example::"
msgstr ""
"Desafortunadamente, esta no es la mejor práctica para las clases.  El "
"problema es que, dado que ``__annotations__`` es opcional en las clases, y "
"dado que las clases pueden heredar atributos de sus clases base, acceder al "
"atributo ``__annotations__`` de una clase puede devolver inadvertidamente el "
"dictado de anotaciones de una *clase base.* Como ejemplo::"

#: ../../howto/annotations.rst:89
msgid ""
"class Base:\n"
"    a: int = 3\n"
"    b: str = 'abc'\n"
"\n"
"class Derived(Base):\n"
"    pass\n"
"\n"
"print(Derived.__annotations__)"
msgstr ""
"class Base:\n"
"    a: int = 3\n"
"    b: str = 'abc'\n"
"\n"
"class Derived(Base):\n"
"    pass\n"
"\n"
"print(Derived.__annotations__)"

#: ../../howto/annotations.rst:98
msgid "This will print the annotations dict from ``Base``, not ``Derived``."
msgstr ""
"Esto imprimirá las anotaciones dictadas desde ``Base``, no desde ``Derived``."

#: ../../howto/annotations.rst:101
msgid ""
"Your code will have to have a separate code path if the object you're "
"examining is a class (``isinstance(o, type)``). In that case, best practice "
"relies on an implementation detail of Python 3.9 and before: if a class has "
"annotations defined, they are stored in the class's :attr:`~type.__dict__` "
"dictionary.  Since the class may or may not have annotations defined, best "
"practice is to call the :meth:`~dict.get` method on the class dict."
msgstr ""
"Tu código tendrá que tener una ruta de código separada si el objeto que "
"estás examinando es una clase (``isinstance(o, type)``). En ese caso, la "
"mejor práctica se basa en un detalle de implementación de Python 3.9 y "
"anteriores: si una clase tiene anotaciones definidas, se almacenan en el "
"diccionario :attr:`~type.__dict__` de la clase.  Dado que la clase puede o "
"no tener anotaciones definidas, la mejor práctica es llamar al método :meth:"
"`~dict.get` en el diccionario de la clase."

#: ../../howto/annotations.rst:109
msgid ""
"To put it all together, here is some sample code that safely accesses the "
"``__annotations__`` attribute on an arbitrary object in Python 3.9 and "
"before::"
msgstr ""
"Para ponerlo todo junto, aquí hay un ejemplo de código que accede de forma "
"segura al atributo ``__annotations__`` en un objeto arbitrario en Python 3.9 "
"y anteriores::"

#: ../../howto/annotations.rst:113
msgid ""
"if isinstance(o, type):\n"
"    ann = o.__dict__.get('__annotations__', None)\n"
"else:\n"
"    ann = getattr(o, '__annotations__', None)"
msgstr ""
"if isinstance(o, type):\n"
"    ann = o.__dict__.get('__annotations__', None)\n"
"else:\n"
"    ann = getattr(o, '__annotations__', None)"

#: ../../howto/annotations.rst:118
msgid ""
"After running this code, ``ann`` should be either a dictionary or ``None``.  "
"You're encouraged to double-check the type of ``ann`` using :func:"
"`isinstance` before further examination."
msgstr ""
"Después de ejecutar este código, ``ann`` debería ser un diccionario o "
"``None``. Le recomendamos que compruebe el tipo de ``ann`` utilizando :func:"
"`isinstance` antes de continuar."

#: ../../howto/annotations.rst:123
msgid ""
"Note that some exotic or malformed type objects may not have a :attr:`~type."
"__dict__` attribute, so for extra safety you may also wish to use :func:"
"`getattr` to access :attr:`!__dict__`."
msgstr ""
"Tenga en cuenta que algunos objetos de tipo exótico o malformado pueden no "
"tener un atributo :attr:`~type.__dict__`, por lo que, para mayor seguridad, "
"es posible que también desee utilizar :func:`getattr` para acceder a :attr:`!"
"__dict__`."

#: ../../howto/annotations.rst:129
msgid "Manually Un-Stringizing Stringized Annotations"
msgstr "Desencadenar manualmente anotaciones encadenadas"

#: ../../howto/annotations.rst:131
msgid ""
"In situations where some annotations may be \"stringized\", and you wish to "
"evaluate those strings to produce the Python values they represent, it "
"really is best to call :func:`inspect.get_annotations` to do this work for "
"you."
msgstr ""
"En situaciones donde algunas anotaciones pueden ser \"stringized\", y desea "
"evaluar esas cadenas para producir los valores Python que representan, "
"realmente es mejor llamar a :func:`inspect.get_annotations` para hacer este "
"trabajo por usted."

#: ../../howto/annotations.rst:137
msgid ""
"If you're using Python 3.9 or older, or if for some reason you can't use :"
"func:`inspect.get_annotations`, you'll need to duplicate its logic.  You're "
"encouraged to examine the implementation of :func:`inspect.get_annotations` "
"in the current Python version and follow a similar approach."
msgstr ""
"Si estás usando Python 3.9 o anterior, o si por alguna razón no puedes usar :"
"func:`inspect.get_annotations`, necesitarás duplicar su lógica.  Te animamos "
"a que examines la implementación de :func:`inspect.get_annotations` en la "
"versión actual de Python y sigas un enfoque similar."

#: ../../howto/annotations.rst:143
msgid ""
"In a nutshell, if you wish to evaluate a stringized annotation on an "
"arbitrary object ``o``:"
msgstr ""
"En pocas palabras, si desea evaluar una anotación de cadena en un objeto "
"arbitrario ``o``:"

#: ../../howto/annotations.rst:146
msgid ""
"If ``o`` is a module, use ``o.__dict__`` as the ``globals`` when calling :"
"func:`eval`."
msgstr ""
"Si ``o`` es un módulo, utilice ``o.__dict__`` como ``globals`` al llamar a :"
"func:`eval`."

#: ../../howto/annotations.rst:148
msgid ""
"If ``o`` is a class, use ``sys.modules[o.__module__].__dict__`` as the "
"``globals``, and ``dict(vars(o))`` as the ``locals``, when calling :func:"
"`eval`."
msgstr ""
"Si ``o`` es una clase, utilice ``sys.modules[o.__module__].__dict__`` como "
"``globals``, y ``dict(vars(o))`` como ``locals``, cuando llame a :func:"
"`eval`."

#: ../../howto/annotations.rst:151
msgid ""
"If ``o`` is a wrapped callable using :func:`functools.update_wrapper`, :func:"
"`functools.wraps`, or :func:`functools.partial`, iteratively unwrap it by "
"accessing either ``o.__wrapped__`` or ``o.func`` as appropriate, until you "
"have found the root unwrapped function."
msgstr ""
"Si ``o`` es un callable envuelto usando :func:`functools.update_wrapper`, :"
"func:`functools.wraps`, o :func:`functools.partial`, desenvuélvalo "
"iterativamente accediendo a ``o.__wrapped__`` o ``o.func`` según "
"corresponda, hasta que haya encontrado la función raíz desenvuelta."

#: ../../howto/annotations.rst:155
msgid ""
"If ``o`` is a callable (but not a class), use :attr:`o.__globals__ <function."
"__globals__>` as the globals when calling :func:`eval`."
msgstr ""
"Si ``o`` es un callable (pero no una clase), utilice :attr:`o.__globals__ "
"<function.__globals__>` como los globals al llamar a :func:`eval`."

#: ../../howto/annotations.rst:159
msgid ""
"However, not all string values used as annotations can be successfully "
"turned into Python values by :func:`eval`. String values could theoretically "
"contain any valid string, and in practice there are valid use cases for type "
"hints that require annotating with string values that specifically *can't* "
"be evaluated.  For example:"
msgstr ""
"Sin embargo, no todos los valores de cadena utilizados como anotaciones "
"pueden convertirse con éxito en valores Python mediante :func:`eval`. Los "
"valores de cadena podrían contener teóricamente cualquier cadena válida, y "
"en la práctica hay casos de uso válidos para sugerencias de tipo que "
"requieren anotar con valores de cadena que específicamente *no* pueden ser "
"evaluados.  Por ejemplo:"

#: ../../howto/annotations.rst:166
msgid ""
":pep:`604` union types using ``|``, before support for this was added to "
"Python 3.10."
msgstr ""
":pep:`604` tipos de unión utilizando ``|``, antes de que se añadiera soporte "
"para ello en Python 3.10."

#: ../../howto/annotations.rst:168
msgid ""
"Definitions that aren't needed at runtime, only imported when :const:`typing."
"TYPE_CHECKING` is true."
msgstr ""
"Definiciones que no se necesitan en tiempo de ejecución, sólo se importan "
"cuando :const:`typing.TYPE_CHECKING` es verdadero."

#: ../../howto/annotations.rst:171
msgid ""
"If :func:`eval` attempts to evaluate such values, it will fail and raise an "
"exception.  So, when designing a library API that works with annotations, "
"it's recommended to only attempt to evaluate string values when explicitly "
"requested to by the caller."
msgstr ""
"Si :func:`eval` intenta evaluar tales valores, fallará y lanzará una "
"excepción.  Por lo tanto, al diseñar una API de biblioteca que funcione con "
"anotaciones, se recomienda intentar evaluar valores de cadena sólo cuando el "
"autor de la llamada lo solicite explícitamente."

#: ../../howto/annotations.rst:179
msgid "Best Practices For ``__annotations__`` In Any Python Version"
msgstr ""
"Buenas prácticas para ``__annotations__`` en cualquier versión de Python"

#: ../../howto/annotations.rst:181
msgid ""
"You should avoid assigning to the ``__annotations__`` member of objects "
"directly.  Let Python manage setting ``__annotations__``."
msgstr ""
"Debe evitar asignar directamente al miembro ``__annotations__`` de los "
"objetos.  Deja que Python gestione la configuración ``__annotations__``."

#: ../../howto/annotations.rst:184
msgid ""
"If you do assign directly to the ``__annotations__`` member of an object, "
"you should always set it to a ``dict`` object."
msgstr ""
"Si asigna directamente al miembro ``__annotations__`` de un objeto, siempre "
"debe establecerlo en un objeto ``dict``."

#: ../../howto/annotations.rst:187
msgid ""
"If you directly access the ``__annotations__`` member of an object, you "
"should ensure that it's a dictionary before attempting to examine its "
"contents."
msgstr ""
"Si accede directamente al miembro ``__annotations__`` de un objeto, debe "
"asegurarse de que se trata de un diccionario antes de intentar examinar su "
"contenido."

#: ../../howto/annotations.rst:191
msgid "You should avoid modifying ``__annotations__`` dicts."
msgstr "Debe evitar modificar los dicts de ``__annotations__``."

#: ../../howto/annotations.rst:193
msgid ""
"You should avoid deleting the ``__annotations__`` attribute of an object."
msgstr "Debe evitar borrar el atributo ``__annotations__`` de un objeto."

#: ../../howto/annotations.rst:198
msgid "``__annotations__`` Quirks"
msgstr "``__annotations__`` Curiosidades"

#: ../../howto/annotations.rst:200
msgid ""
"In all versions of Python 3, function objects lazy-create an annotations "
"dict if no annotations are defined on that object.  You can delete the "
"``__annotations__`` attribute using ``del fn.__annotations__``, but if you "
"then access ``fn.__annotations__`` the object will create a new empty dict "
"that it will store and return as its annotations.  Deleting the annotations "
"on a function before it has lazily created its annotations dict will throw "
"an ``AttributeError``; using ``del fn.__annotations__`` twice in a row is "
"guaranteed to always throw an ``AttributeError``."
msgstr ""
"En todas las versiones de Python 3, los objetos función crean perezosamente "
"un dict de anotaciones si no hay anotaciones definidas en ese objeto.  "
"Puedes borrar el atributo ``__annotations__`` usando ``del fn."
"__annotations__``, pero si luego accedes a ``fn.__annotations__`` el objeto "
"creará un nuevo dict vacío que almacenará y devolverá como sus anotaciones.  "
"Borrar las anotaciones de una función antes de que haya creado perezosamente "
"su dict de anotaciones lanzará un ``AttributeError``; usar ``del fn."
"__annotations__`` dos veces seguidas está garantizado que siempre lanzará un "
"``AttributeError``."

#: ../../howto/annotations.rst:210
msgid ""
"Everything in the above paragraph also applies to class and module objects "
"in Python 3.10 and newer."
msgstr ""
"Todo lo dicho en el párrafo anterior se aplica también a los objetos clase y "
"módulo en Python 3.10 y versiones posteriores."

#: ../../howto/annotations.rst:213
msgid ""
"In all versions of Python 3, you can set ``__annotations__`` on a function "
"object to ``None``.  However, subsequently accessing the annotations on that "
"object using ``fn.__annotations__`` will lazy-create an empty dictionary as "
"per the first paragraph of this section.  This is *not* true of modules and "
"classes, in any Python version; those objects permit setting "
"``__annotations__`` to any Python value, and will retain whatever value is "
"set."
msgstr ""
"En todas las versiones de Python 3, puedes establecer ``__annotations__`` en "
"un objeto función a ``None``. Sin embargo, acceder posteriormente a las "
"anotaciones de ese objeto usando ``fn.__annotations__`` creará perezosamente "
"un diccionario vacío según el primer párrafo de esta sección.  Esto *no* es "
"cierto para módulos y clases, en cualquier versión de Python; esos objetos "
"permiten establecer ``__annotations__`` a cualquier valor de Python, y "
"retendrán cualquier valor que se establezca."

#: ../../howto/annotations.rst:221
msgid ""
"If Python stringizes your annotations for you (using ``from __future__ "
"import annotations``), and you specify a string as an annotation, the string "
"will itself be quoted.  In effect the annotation is quoted *twice.*  For "
"example::"
msgstr ""
"Si Python encadena sus anotaciones por usted (usando ``from __future__ "
"import annotations``), y usted especifica una cadena como anotación, la "
"propia cadena será entrecomillada.  En efecto, la anotación se entrecomilla "
"*dos veces.* Por ejemplo::"

#: ../../howto/annotations.rst:227
msgid ""
"from __future__ import annotations\n"
"def foo(a: \"str\"): pass\n"
"\n"
"print(foo.__annotations__)"
msgstr ""
"from __future__ import annotations\n"
"def foo(a: \"str\"): pass\n"
"\n"
"print(foo.__annotations__)"

#: ../../howto/annotations.rst:232
msgid ""
"This prints ``{'a': \"'str'\"}``.  This shouldn't really be considered a "
"\"quirk\"; it's mentioned here simply because it might be surprising."
msgstr ""
"Esto imprime ``{'a': \"'str'\"}``.  Esto no debería considerarse realmente "
"una \"peculiaridad\"; se menciona aquí simplemente porque puede resultar "
"sorprendente."
