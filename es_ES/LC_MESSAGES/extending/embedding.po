# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# eulalio barbero espinosa <eulalio@disroot.org>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-03-14 14:53+0000\n"
"PO-Revision-Date: 2024-05-11 00:32+0000\n"
"Last-Translator: eulalio barbero espinosa <eulalio@disroot.org>, 2025\n"
"Language-Team: Spanish (Spain) (https://app.transifex.com/python-doc/"
"teams/5390/es_ES/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es_ES\n"
"Plural-Forms: nplurals=3; plural=n == 1 ? 0 : n != 0 && n % 1000000 == 0 ? "
"1 : 2;\n"

#: ../../extending/embedding.rst:8
msgid "Embedding Python in Another Application"
msgstr "Integrar Python en otra aplicación"

#: ../../extending/embedding.rst:10
msgid ""
"The previous chapters discussed how to extend Python, that is, how to extend "
"the functionality of Python by attaching a library of C functions to it.  It "
"is also possible to do it the other way around: enrich your C/C++ "
"application by embedding Python in it.  Embedding provides your application "
"with the ability to implement some of the functionality of your application "
"in Python rather than C or C++. This can be used for many purposes; one "
"example would be to allow users to tailor the application to their needs by "
"writing some scripts in Python.  You can also use it yourself if some of the "
"functionality can be written in Python more easily."
msgstr ""
"Los capítulos anteriores han tratado de cómo extender Python, es decir, cómo "
"ampliar la funcionalidad de Python adjuntando una biblioteca de funciones en "
"C. También es posible hacerlo al revés: enriquecer tu aplicación en C/C++ "
"incrustando Python en ella. La incrustación proporciona a tu aplicación la "
"capacidad de implementar parte de la funcionalidad en Python en lugar de en "
"C o C++. Esto se puede utilizar para muchos propósitos; un ejemplo sería "
"permitir a los usuarios adaptar la aplicación a sus necesidades escribiendo "
"scripts en Python. También puedes utilizarlo tú mismo si parte de la "
"funcionalidad se puede escribir más fácilmente en Python."

#: ../../extending/embedding.rst:20
msgid ""
"Embedding Python is similar to extending it, but not quite.  The difference "
"is that when you extend Python, the main program of the application is still "
"the Python interpreter, while if you embed Python, the main program may have "
"nothing to do with Python --- instead, some parts of the application "
"occasionally call the Python interpreter to run some Python code."
msgstr ""
"Incrustar Python es similar a extenderlo, pero no del todo.  La diferencia "
"es que cuando extiendes Python, el programa principal de la aplicación sigue "
"siendo el intérprete de Python, mientras que si incrustas Python, el "
"programa principal puede no tener nada que ver con Python --- en su lugar, "
"algunas partes de la aplicación llaman ocasionalmente al intérprete de "
"Python para ejecutar algún código Python."

#: ../../extending/embedding.rst:26
msgid ""
"So if you are embedding Python, you are providing your own main program.  "
"One of the things this main program has to do is initialize the Python "
"interpreter.  At the very least, you have to call the function :c:func:"
"`Py_Initialize`.  There are optional calls to pass command line arguments to "
"Python.  Then later you can call the interpreter from any part of the "
"application."
msgstr ""
"Así que si estás incrustando Python, estás proporcionando tu propio programa "
"principal.  Una de las cosas que este programa principal tiene que hacer es "
"inicializar el intérprete de Python.  Como mínimo, tiene que llamar a la "
"función :c:func:`Py_Initialize`.  Hay llamadas opcionales para pasar "
"argumentos de línea de comandos a Python.  Luego, más tarde, puedes llamar "
"al intérprete desde cualquier parte de la aplicación."

#: ../../extending/embedding.rst:32
msgid ""
"There are several different ways to call the interpreter: you can pass a "
"string containing Python statements to :c:func:`PyRun_SimpleString`, or you "
"can pass a stdio file pointer and a file name (for identification in error "
"messages only) to :c:func:`PyRun_SimpleFile`.  You can also call the lower-"
"level operations described in the previous chapters to construct and use "
"Python objects."
msgstr ""
"Hay varias formas diferentes de llamar al intérprete: puede pasar una cadena "
"que contenga sentencias Python a :c:func:`PyRun_SimpleString`, o puede pasar "
"un puntero de archivo stdio y un nombre de archivo (sólo para identificación "
"en mensajes de error) a :c:func:`PyRun_SimpleFile`. También puede llamar a "
"las operaciones de nivel inferior descritas en los capítulos anteriores para "
"construir y utilizar objetos Python."

#: ../../extending/embedding.rst:41
msgid ":ref:`c-api-index`"
msgstr ":ref:`c-api-index`"

#: ../../extending/embedding.rst:42
msgid ""
"The details of Python's C interface are given in this manual. A great deal "
"of necessary information can be found here."
msgstr ""
"Los detalles de la interfaz C de Python se encuentran en este manual. Aquí "
"se puede encontrar una gran cantidad de información necesaria."

#: ../../extending/embedding.rst:49
msgid "Very High Level Embedding"
msgstr "Nivel de incrustación muy alto"

#: ../../extending/embedding.rst:51
msgid ""
"The simplest form of embedding Python is the use of the very high level "
"interface. This interface is intended to execute a Python script without "
"needing to interact with the application directly. This can for example be "
"used to perform some operation on a file. ::"
msgstr ""
"La forma más sencilla de incrustar Python es mediante el uso de la interfaz "
"de nivel muy alto. Esta interfaz está diseñada para ejecutar un script de "
"Python sin necesidad de interactuar directamente con la aplicación. Esto se "
"puede utilizar, por ejemplo, para realizar alguna operación en un archivo. ::"

#: ../../extending/embedding.rst:56
msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"\n"
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    wchar_t *program = Py_DecodeLocale(argv[0], NULL);\n"
"    if (program == NULL) {\n"
"        fprintf(stderr, \"Fatal error: cannot decode argv[0]\\n\");\n"
"        exit(1);\n"
"    }\n"
"    Py_SetProgramName(program);  /* optional but recommended */\n"
"    Py_Initialize();\n"
"    PyRun_SimpleString(\"from time import time,ctime\\n\"\n"
"                       \"print('Today is', ctime(time()))\\n\");\n"
"    if (Py_FinalizeEx() < 0) {\n"
"        exit(120);\n"
"    }\n"
"    PyMem_RawFree(program);\n"
"    return 0;\n"
"}"
msgstr ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"\n"
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    wchar_t *programa = Py_DecodeLocale(argv[0], NULL);\n"
"    if (programa == NULL) {\n"
"        fprintf(stderr, \"Error fatal: no se puede decodificar "
"argv[0]\\n\");\n"
"        exit(1);\n"
"    }\n"
"    Py_SetProgramName(programa); /* opcional pero recomendado */\n"
"    Py_Initialize();\n"
"    PyRun_SimpleString(\"from tiempo import tiempo,ctiempo\\n\"\n"
"                       \"print('Hoy es', ctime(tiempo()))\\n\");\n"
"    if (Py_FinalizeEx() < 0) {\n"
"        exit(120);\n"
"    }\n"
"    PyMem_RawFree(programa);\n"
"    return 0;\n"
"}"

#: ../../extending/embedding.rst:78
msgid ""
"The :c:func:`Py_SetProgramName` function should be called before :c:func:"
"`Py_Initialize` to inform the interpreter about paths to Python run-time "
"libraries.  Next, the Python interpreter is initialized with :c:func:"
"`Py_Initialize`, followed by the execution of a hard-coded Python script "
"that prints the date and time.  Afterwards, the :c:func:`Py_FinalizeEx` call "
"shuts the interpreter down, followed by the end of the program.  In a real "
"program, you may want to get the Python script from another source, perhaps "
"a text-editor routine, a file, or a database.  Getting the Python code from "
"a file can better be done by using the :c:func:`PyRun_SimpleFile` function, "
"which saves you the trouble of allocating memory space and loading the file "
"contents."
msgstr ""
"La función :c:func:`Py_SetProgramName` debe invocarse antes de :c:func:"
"`Py_Initialize` para informar al intérprete sobre las rutas a las "
"bibliotecas en tiempo de ejecución de Python.  A continuación, el intérprete "
"de Python se inicializa con :c:func:`Py_Initialize`, seguido de la ejecución "
"de un script de Python que imprime la fecha y la hora.  Después, la llamada :"
"c:func:`Py_FinalizeEx` cierra el intérprete, seguido por el final del "
"programa.  En un programa real, es posible que desee obtener el script "
"Python de otra fuente, tal vez una rutina de editor de texto, un archivo o "
"una base de datos.  Obtener el código Python de un archivo puede hacerse "
"mejor usando la función :c:func:`PyRun_SimpleFile`, que te ahorra la "
"molestia de asignar espacio de memoria y cargar el contenido del archivo."

#: ../../extending/embedding.rst:93
msgid "Beyond Very High Level Embedding: An overview"
msgstr "Más allá de la incrustación de muy alto nivel: Panorama general"

#: ../../extending/embedding.rst:95
msgid ""
"The high level interface gives you the ability to execute arbitrary pieces "
"of Python code from your application, but exchanging data values is quite "
"cumbersome to say the least. If you want that, you should use lower level "
"calls. At the cost of having to write more C code, you can achieve almost "
"anything."
msgstr ""
"La interfaz de alto nivel te permite ejecutar piezas arbitrarias de código "
"Python desde tu aplicación, pero intercambiar valores de datos es bastante "
"engorroso, por decir lo menos. Si deseas eso, deberías usar llamadas de "
"nivel inferior. A costa de tener que escribir más código en C, puedes lograr "
"casi cualquier cosa."

#: ../../extending/embedding.rst:100
msgid ""
"It should be noted that extending Python and embedding Python is quite the "
"same activity, despite the different intent. Most topics discussed in the "
"previous chapters are still valid. To show this, consider what the extension "
"code from Python to C really does:"
msgstr ""
"Debe tenerse en cuenta que extender Python e incrustar Python son "
"actividades bastante similares, a pesar de la intención diferente. La "
"mayoría de los temas discutidos en los capítulos anteriores siguen siendo "
"válidos. Para demostrar esto, considera lo que realmente hace el código de "
"extensión de Python a C."

#: ../../extending/embedding.rst:105
msgid "Convert data values from Python to C,"
msgstr "Convertir valores de datos de Python a C,"

#: ../../extending/embedding.rst:107
msgid "Perform a function call to a C routine using the converted values, and"
msgstr ""
"Realizar una llamada a una rutina C utilizando los valores convertidos, y"

#: ../../extending/embedding.rst:109
msgid "Convert the data values from the call from C to Python."
msgstr "Convertir los valores de datos de la llamada de C a Python."

#: ../../extending/embedding.rst:111
msgid "When embedding Python, the interface code does:"
msgstr "Cuando se incrusta Python, el código de interfaz hace:"

#: ../../extending/embedding.rst:113
msgid "Convert data values from C to Python,"
msgstr "Convertir valores de datos de C a Python,"

#: ../../extending/embedding.rst:115
msgid ""
"Perform a function call to a Python interface routine using the converted "
"values, and"
msgstr ""
"Realizar una llamada a una rutina de interfaz de Python utilizando los "
"valores convertidos, y"

#: ../../extending/embedding.rst:118
msgid "Convert the data values from the call from Python to C."
msgstr "Convertir los valores de datos de la llamada de Python a C."

#: ../../extending/embedding.rst:120
msgid ""
"As you can see, the data conversion steps are simply swapped to accommodate "
"the different direction of the cross-language transfer. The only difference "
"is the routine that you call between both data conversions. When extending, "
"you call a C routine, when embedding, you call a Python routine."
msgstr ""
"Como puedes ver, los pasos de conversión de datos se intercambian "
"simplemente para adaptarse a la dirección diferente de la transferencia "
"entre lenguajes. La única diferencia es la rutina que llamas entre ambas "
"conversiones de datos. Al extender, llamas a una rutina en C, al incrustar, "
"llamas a una rutina en Python."

#: ../../extending/embedding.rst:125
msgid ""
"This chapter will not discuss how to convert data from Python to C and vice "
"versa.  Also, proper use of references and dealing with errors is assumed to "
"be understood.  Since these aspects do not differ from extending the "
"interpreter, you can refer to earlier chapters for the required information."
msgstr ""
"Este capítulo no discutirá cómo convertir datos de Python a C y viceversa. "
"Además, se asume que se entiende el uso adecuado de referencias y cómo "
"manejar errores. Dado que estos aspectos no difieren de la extensión del "
"intérprete, puedes consultar los capítulos anteriores para obtener la "
"información requerida."

#: ../../extending/embedding.rst:134
msgid "Pure Embedding"
msgstr "Incrustación pura"

#: ../../extending/embedding.rst:136
msgid ""
"The first program aims to execute a function in a Python script. Like in the "
"section about the very high level interface, the Python interpreter does not "
"directly interact with the application (but that will change in the next "
"section)."
msgstr ""
"El primer programa tiene como objetivo ejecutar una función en un script de "
"Python. Al igual que en la sección sobre la interfaz de nivel muy alto, el "
"intérprete de Python no interactúa directamente con la aplicación (pero eso "
"cambiará en la próxima sección)."

#: ../../extending/embedding.rst:141
msgid "The code to run a function defined in a Python script is:"
msgstr ""
"El código para ejecutar una función definida en un script de Python es:"

#: ../../extending/embedding.rst:143
msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"\n"
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    PyObject *pName, *pModule, *pFunc;\n"
"    PyObject *pArgs, *pValue;\n"
"    int i;\n"
"\n"
"    if (argc < 3) {\n"
"        fprintf(stderr,\"Usage: call pythonfile funcname [args]\\n\");\n"
"        return 1;\n"
"    }\n"
"\n"
"    Py_Initialize();\n"
"    pName = PyUnicode_DecodeFSDefault(argv[1]);\n"
"    /* Error checking of pName left out */\n"
"\n"
"    pModule = PyImport_Import(pName);\n"
"    Py_DECREF(pName);\n"
"\n"
"    if (pModule != NULL) {\n"
"        pFunc = PyObject_GetAttrString(pModule, argv[2]);\n"
"        /* pFunc is a new reference */\n"
"\n"
"        if (pFunc && PyCallable_Check(pFunc)) {\n"
"            pArgs = PyTuple_New(argc - 3);\n"
"            for (i = 0; i < argc - 3; ++i) {\n"
"                pValue = PyLong_FromLong(atoi(argv[i + 3]));\n"
"                if (!pValue) {\n"
"                    Py_DECREF(pArgs);\n"
"                    Py_DECREF(pModule);\n"
"                    fprintf(stderr, \"Cannot convert argument\\n\");\n"
"                    return 1;\n"
"                }\n"
"                /* pValue reference stolen here: */\n"
"                PyTuple_SetItem(pArgs, i, pValue);\n"
"            }\n"
"            pValue = PyObject_CallObject(pFunc, pArgs);\n"
"            Py_DECREF(pArgs);\n"
"            if (pValue != NULL) {\n"
"                printf(\"Result of call: %ld\\n\", PyLong_AsLong(pValue));\n"
"                Py_DECREF(pValue);\n"
"            }\n"
"            else {\n"
"                Py_DECREF(pFunc);\n"
"                Py_DECREF(pModule);\n"
"                PyErr_Print();\n"
"                fprintf(stderr,\"Call failed\\n\");\n"
"                return 1;\n"
"            }\n"
"        }\n"
"        else {\n"
"            if (PyErr_Occurred())\n"
"                PyErr_Print();\n"
"            fprintf(stderr, \"Cannot find function \\\"%s\\\"\\n\", "
"argv[2]);\n"
"        }\n"
"        Py_XDECREF(pFunc);\n"
"        Py_DECREF(pModule);\n"
"    }\n"
"    else {\n"
"        PyErr_Print();\n"
"        fprintf(stderr, \"Failed to load \\\"%s\\\"\\n\", argv[1]);\n"
"        return 1;\n"
"    }\n"
"    if (Py_FinalizeEx() < 0) {\n"
"        return 120;\n"
"    }\n"
"    return 0;\n"
"}\n"
msgstr ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"\n"
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    PyObject *pNombre, *pMódulo, *pFunción;\n"
"    PyObject *pArgs, *pValor;\n"
"    int i;\n"
"\n"
"    if (argc < 3) {\n"
"        fprintf(stderr, \"Usage: call pythonfile funcname [args]\\n\");\n"
"        return 1;\n"
"    }\n"
"\n"
"    Py_Initialize();\n"
"    pNombre = PyUnicode_DecodeFSDefault(argv[1]);\n"
"    /* Se omite la comprobación de errores de pName */\n"
"\n"
"    pModule = PyImport_Import(pName);\n"
"    Py_DECREF(pNombre);\n"
"\n"
"    if (pModule != NULL) {\n"
"        pFunc = PyObject_GetAttrString(pModule, argv[2]);\n"
"        /* pFunc es una nueva referencia */\n"
"\n"
"        if (pFunc && PyCallable_Check(pFunc)) {\n"
"            pArgs = PyTuple_New(argc - 3);\n"
"            for (i = 0; i < argc - 3; ++i) {\n"
"                pValue = PyLong_FromLong(atoi(argv[i + 3]));\n"
"                if (!pValue) {\n"
"                    Py_DECREF(pArgs);\n"
"                    Py_DECREF(pModulo);\n"
"                    fprintf(stderr, \"No se puede convertir "
"argumento\\n\");\n"
"                    return 1;\n"
"                }\n"
"                /* Referencia pValue robada aquí: */\n"
"                PyTuple_SetItem(pArgs, i, pValue);\n"
"            }\n"
"            pValue = PyObject_CallObject(pFunc, pArgs);\n"
"            Py_DECREF(pArgs);\n"
"            if (pValue != NULL) {\n"
"                printf(\"Resultado de la llamada: %ld\\n\", "
"PyLong_AsLong(pValue));\n"
"                Py_DECREF(pValor);\n"
"            }\n"
"            else {\n"
"                Py_DECREF(pFunc);\n"
"                Py_DECREF(pModulo);\n"
"                PyErr_Print();\n"
"                fprintf(stderr, \"Llamada fallida\\n\");\n"
"                return 1;\n"
"            }\n"
"        }\n"
"        else {\n"
"            if (PyErr_Occurred())\n"
"                PyErr_Print();\n"
"            fprintf(stderr, \"Cannot find function \\\"%s\"\\n\", argv[2]);\n"
"        }\n"
"        Py_XDECREF(pFunc);\n"
"        Py_DECREF(pModule);\n"
"    }\n"
"    else {\n"
"        PyErr_Print();\n"
"        fprintf(stderr, \"Failed to load \\\"%s\"\\n\", argv[1]);\n"
"        return 1;\n"
"    }\n"
"    if (Py_FinalizeEx() < 0) {\n"
"        return 120;\n"
"    }\n"
"    return 0;\n"
"}\n"

#: ../../extending/embedding.rst:146
msgid ""
"This code loads a Python script using ``argv[1]``, and calls the function "
"named in ``argv[2]``.  Its integer arguments are the other values of the "
"``argv`` array.  If you :ref:`compile and link <compiling>` this program "
"(let's call the finished executable :program:`call`), and use it to execute "
"a Python script, such as:"
msgstr ""
"Este código carga un script de Python usando ``argv[1]`` y llama a la "
"función nombrada en ``argv[2]``. Sus argumentos enteros son los otros "
"valores del array ``argv``. Si :ref:`compilas y enlazas <compiling>` este "
"programa (llamémoslo ejecutable terminado :program:`call`) y lo usas para "
"ejecutar un script de Python, como:"

#: ../../extending/embedding.rst:152
msgid ""
"def multiply(a,b):\n"
"    print(\"Will compute\", a, \"times\", b)\n"
"    c = 0\n"
"    for i in range(0, a):\n"
"        c = c + b\n"
"    return c"
msgstr ""
"def multiply(a,b):\n"
"    print(\"Will compute\", a, \"times\", b)\n"
"    c = 0\n"
"    for i in range(0, a):\n"
"        c = c + b\n"
"    return c"

#: ../../extending/embedding.rst:161
msgid "then the result should be:"
msgstr "entonces el resultado debería ser:"

#: ../../extending/embedding.rst:163
msgid ""
"$ call multiply multiply 3 2\n"
"Will compute 3 times 2\n"
"Result of call: 6"
msgstr ""
"$ call multiplicar multiplicar 3 2\n"
"Calculará 3 veces 2\n"
"Resultado de la llamada: 6"

#: ../../extending/embedding.rst:169
msgid ""
"Although the program is quite large for its functionality, most of the code "
"is for data conversion between Python and C, and for error reporting.  The "
"interesting part with respect to embedding Python starts with ::"
msgstr ""
"Aunque el programa es bastante grande para su funcionalidad, la mayor parte "
"del código es para la conversión de datos entre Python y C, y para la "
"notificación de errores. La parte interesante con respecto a la "
"incorporación de Python comienza con ::"

#: ../../extending/embedding.rst:173
msgid ""
"Py_Initialize();\n"
"pName = PyUnicode_DecodeFSDefault(argv[1]);\n"
"/* Error checking of pName left out */\n"
"pModule = PyImport_Import(pName);"
msgstr ""
"Py_Initialize();\n"
"pName = PyUnicode_DecodeFSDefault(argv[1]);\n"
"/* Comprobación de error de pName omitida */\n"
"pModule = PyImport_Import(pName);"

#: ../../extending/embedding.rst:178
msgid ""
"After initializing the interpreter, the script is loaded using :c:func:"
"`PyImport_Import`.  This routine needs a Python string as its argument, "
"which is constructed using the :c:func:`PyUnicode_DecodeFSDefault` data "
"conversion routine. ::"
msgstr ""
"Tras inicializar el intérprete, el script se carga utilizando :c:func:"
"`PyImport_Import`.  Esta rutina necesita una cadena Python como argumento, "
"que se construye utilizando la rutina de conversión de datos :c:func:"
"`PyUnicode_DecodeFSDefault`. ::"

#: ../../extending/embedding.rst:183
msgid ""
"pFunc = PyObject_GetAttrString(pModule, argv[2]);\n"
"/* pFunc is a new reference */\n"
"\n"
"if (pFunc && PyCallable_Check(pFunc)) {\n"
"    ...\n"
"}\n"
"Py_XDECREF(pFunc);"
msgstr ""
"pFunc = PyObject_GetAttrString(pModule, argv[2]);\n"
"/* pFunc es una nueva referencia */\n"
"\n"
"if (pFunc && PyCallable_Check(pFunc)) {\n"
"    ...\n"
"}\n"
"Py_XDECREF(pFunc);"

#: ../../extending/embedding.rst:191
msgid ""
"Once the script is loaded, the name we're looking for is retrieved using :c:"
"func:`PyObject_GetAttrString`.  If the name exists, and the object returned "
"is callable, you can safely assume that it is a function.  The program then "
"proceeds by constructing a tuple of arguments as normal.  The call to the "
"Python function is then made with::"
msgstr ""
"Una vez que se carga el script, se recupera el nombre que estamos buscando "
"utilizando :c:func:`PyObject_GetAttrString`. Si el nombre existe y el objeto "
"devuelto es callable, puedes asumir de forma segura que es una función. El "
"programa luego procede construyendo una tupla de argumentos como de "
"costumbre. La llamada a la función de Python se realiza con::"

#: ../../extending/embedding.rst:197
msgid "pValue = PyObject_CallObject(pFunc, pArgs);"
msgstr "pValue = PyObject_CallObject(pFunc, pArgs);"

#: ../../extending/embedding.rst:199
msgid ""
"Upon return of the function, ``pValue`` is either ``NULL`` or it contains a "
"reference to the return value of the function.  Be sure to release the "
"reference after examining the value."
msgstr ""
"Tras el retorno de la función, ``pValue`` es ``NULL`` o contiene una "
"referencia al valor de retorno de la función.  Asegúrese de liberar la "
"referencia después de examinar el valor."

#: ../../extending/embedding.rst:207
msgid "Extending Embedded Python"
msgstr "Extendiendo Python Incrustado"

#: ../../extending/embedding.rst:209
msgid ""
"Until now, the embedded Python interpreter had no access to functionality "
"from the application itself.  The Python API allows this by extending the "
"embedded interpreter.  That is, the embedded interpreter gets extended with "
"routines provided by the application. While it sounds complex, it is not so "
"bad.  Simply forget for a while that the application starts the Python "
"interpreter.  Instead, consider the application to be a set of subroutines, "
"and write some glue code that gives Python access to those routines, just "
"like you would write a normal Python extension.  For example::"
msgstr ""
"Hasta ahora, el intérprete de Python integrado no tenía acceso a la "
"funcionalidad de la propia aplicación. La API de Python permite esto al "
"extender el intérprete integrado. Es decir, el intérprete integrado se "
"amplía con rutinas proporcionadas por la aplicación. Aunque suene complejo, "
"no es tan malo. Simplemente olvídate por un momento de que la aplicación "
"inicia el intérprete de Python. En su lugar, considera que la aplicación es "
"un conjunto de subrutinas y escribe un código de enlace que brinde acceso a "
"Python a esas rutinas, tal como escribirías una extensión normal de Python. "
"Por ejemplo:"

#: ../../extending/embedding.rst:218
msgid ""
"static int numargs=0;\n"
"\n"
"/* Return the number of arguments of the application command line */\n"
"static PyObject*\n"
"emb_numargs(PyObject *self, PyObject *args)\n"
"{\n"
"    if(!PyArg_ParseTuple(args, \":numargs\"))\n"
"        return NULL;\n"
"    return PyLong_FromLong(numargs);\n"
"}\n"
"\n"
"static PyMethodDef EmbMethods[] = {\n"
"    {\"numargs\", emb_numargs, METH_VARARGS,\n"
"     \"Return the number of arguments received by the process.\"},\n"
"    {NULL, NULL, 0, NULL}\n"
"};\n"
"\n"
"static PyModuleDef EmbModule = {\n"
"    PyModuleDef_HEAD_INIT, \"emb\", NULL, -1, EmbMethods,\n"
"    NULL, NULL, NULL, NULL\n"
"};\n"
"\n"
"static PyObject*\n"
"PyInit_emb(void)\n"
"{\n"
"    return PyModule_Create(&EmbModule);\n"
"}"
msgstr ""
"static int numargs=0;\n"
"\n"
"/* Devuelve el número de argumentos de la línea de comandos de la aplicación "
"*/\n"
"static PyObject*\n"
"emb_numargs(PyObject *self, PyObject *args)\n"
"{\n"
"    if(!PyArg_ParseTuple(args, \":numargs\"))\n"
"        return NULL;\n"
"    return PyLong_FromLong(numargs);\n"
"}\n"
"\n"
"static PyMethodDef EmbMethods[] = {\n"
"    {\"numargs\", emb_numargs, METH_VARARGS,\n"
"     \"Devuelve el número de argumentos recibidos por el proceso.\"},\n"
"    {NULL, NULL, 0, NULL}\n"
"};\n"
"\n"
"static PyModuleDef EmbModule = {\n"
"    PyModuleDef_HEAD_INIT, \"emb\", NULL, -1, EmbMethods,\n"
"    NULL, NULL, NULL, NULL\n"
"};\n"
"\n"
"static PyObject*\n"
"PyInit_emb(void)\n"
"{\n"
"    return PyModule_Create(&EmbModule);\n"
"}"

#: ../../extending/embedding.rst:246
msgid ""
"Insert the above code just above the :c:func:`main` function. Also, insert "
"the following two statements before the call to :c:func:`Py_Initialize`::"
msgstr ""
"Inserte el código anterior justo encima de la función :c:func:`main`. "
"Además, inserte las siguientes dos declaraciones antes de la llamada a :c:"
"func:`Py_Initialize`::"

#: ../../extending/embedding.rst:249
msgid ""
"numargs = argc;\n"
"PyImport_AppendInittab(\"emb\", &PyInit_emb);"
msgstr ""
"numargs = argc;\n"
"PyImport_AppendInittab(\"emb\", &PyInit_emb);"

#: ../../extending/embedding.rst:252
msgid ""
"These two lines initialize the ``numargs`` variable, and make the :func:`!"
"emb.numargs` function accessible to the embedded Python interpreter. With "
"these extensions, the Python script can do things like"
msgstr ""
"Estas dos líneas inicializan la variable ``numargs``, y hacen que la "
"función :func:`!emb.numargs` sea accesible al intérprete de Python embebido. "
"Con estas extensiones, el script de Python puede hacer cosas como"

#: ../../extending/embedding.rst:256
msgid ""
"import emb\n"
"print(\"Number of arguments\", emb.numargs())"
msgstr ""
"importar emb\n"
"print(\"Número de argumentos\", emb.numargs())"

#: ../../extending/embedding.rst:261
msgid ""
"In a real application, the methods will expose an API of the application to "
"Python."
msgstr ""
"En una aplicación real, los métodos expondrán una API de la aplicación a "
"Python."

#: ../../extending/embedding.rst:271
msgid "Embedding Python in C++"
msgstr "Incrustación de Python en C++"

#: ../../extending/embedding.rst:273
msgid ""
"It is also possible to embed Python in a C++ program; precisely how this is "
"done will depend on the details of the C++ system used; in general you will "
"need to write the main program in C++, and use the C++ compiler to compile "
"and link your program.  There is no need to recompile Python itself using C+"
"+."
msgstr ""
"También es posible incrustar Python en un programa C++; precisamente cómo se "
"hace dependerá de los detalles del sistema C++ utilizado; en general, "
"necesitarás escribir el programa principal en C++ y usar el compilador C++ "
"para compilar y enlazar tu programa. No es necesario volver a compilar "
"Python en sí mismo usando C++."

#: ../../extending/embedding.rst:282
msgid "Compiling and Linking under Unix-like systems"
msgstr "Compilando y enlazando en sistemas tipo Unix"

#: ../../extending/embedding.rst:284
msgid ""
"It is not necessarily trivial to find the right flags to pass to your "
"compiler (and linker) in order to embed the Python interpreter into your "
"application, particularly because Python needs to load library modules "
"implemented as C dynamic extensions (:file:`.so` files) linked against it."
msgstr ""
"No siempre es trivial encontrar las banderas correctas para pasarle a tu "
"compilador (y enlazador) con el fin de incrustar el intérprete de Python en "
"tu aplicación, especialmente porque Python necesita cargar módulos de "
"biblioteca implementados como extensiones dinámicas en C (:file:`.so`) "
"enlazados con él."

#: ../../extending/embedding.rst:290
msgid ""
"To find out the required compiler and linker flags, you can execute the :"
"file:`python{X.Y}-config` script which is generated as part of the "
"installation process (a :file:`python3-config` script may also be "
"available).  This script has several options, of which the following will be "
"directly useful to you:"
msgstr ""
"Para averiguar las banderas de compilador y enlazador requeridas, puedes "
"ejecutar el script :file:`python{X.Y}-config` que se genera como parte del "
"proceso de instalación (también puede estar disponible un script :file:"
"`python3-config`). Este script tiene varias opciones, de las cuales las "
"siguientes te serán útiles directamente."

#: ../../extending/embedding.rst:296
msgid ""
"``pythonX.Y-config --cflags`` will give you the recommended flags when "
"compiling:"
msgstr ""
"``pythonX.Y-config --cflags`` te dará las banderas recomendadas al compilar:"

#: ../../extending/embedding.rst:299
msgid ""
"$ /opt/bin/python3.11-config --cflags\n"
"-I/opt/include/python3.11 -I/opt/include/python3.11 -Wsign-compare  -DNDEBUG "
"-g -fwrapv -O3 -Wall"
msgstr ""
"$ /opt/bin/python3.11-config --cflags\n"
"-I/opt/include/python3.11 -I/opt/include/python3.11 -Wsign-compare  -DNDEBUG "
"-g -fwrapv -O3 -Wall"

#: ../../extending/embedding.rst:304
msgid ""
"``pythonX.Y-config --ldflags --embed`` will give you the recommended flags "
"when linking:"
msgstr ""
"``pythonX.Y-config --ldflags --embed`` le dará las banderas recomendadas al "
"enlazar:"

#: ../../extending/embedding.rst:307
msgid ""
"$ /opt/bin/python3.11-config --ldflags --embed\n"
"-L/opt/lib/python3.11/config-3.11-x86_64-linux-gnu -L/opt/lib -lpython3.11 -"
"lpthread -ldl  -lutil -lm"
msgstr ""
"$ /opt/bin/python3.11-config --ldflags --embed\n"
"-L/opt/lib/python3.11/config-3.11-x86_64-linux-gnu -L/opt/lib -lpython3.11 -"
"lpthread -ldl  -lutil -lm"

#: ../../extending/embedding.rst:313
msgid ""
"To avoid confusion between several Python installations (and especially "
"between the system Python and your own compiled Python), it is recommended "
"that you use the absolute path to :file:`python{X.Y}-config`, as in the "
"above example."
msgstr ""
"Para evitar confusiones entre varias instalaciones de Python (y "
"especialmente entre el Python del sistema y tu propio Python compilado), se "
"recomienda que utilices la ruta absoluta a :file:`python{X.Y}-config`, como "
"en el ejemplo anterior."

#: ../../extending/embedding.rst:318
msgid ""
"If this procedure doesn't work for you (it is not guaranteed to work for all "
"Unix-like platforms; however, we welcome :ref:`bug reports <reporting-"
"bugs>`) you will have to read your system's documentation about dynamic "
"linking and/or examine Python's :file:`Makefile` (use :func:`sysconfig."
"get_makefile_filename` to find its location) and compilation options.  In "
"this case, the :mod:`sysconfig` module is a useful tool to programmatically "
"extract the configuration values that you will want to combine together.  "
"For example:"
msgstr ""
"Si este procedimiento no funciona para ti (no se garantiza que funcione en "
"todas las plataformas similares a Unix; sin embargo, agradecemos los "
"informes de errores) tendrás que leer la documentación de tu sistema sobre "
"la vinculación dinámica y/o examinar el :file:`Makefile` de Python (usa :"
"func:`sysconfig.get_makefile_filename` para encontrar su ubicación) y las "
"opciones de compilación. En este caso, el módulo :mod:`sysconfig` es una "
"herramienta útil para extraer programáticamente los valores de configuración "
"que desees combinar. Por ejemplo:"

#: ../../extending/embedding.rst:327
msgid ""
">>> import sysconfig\n"
">>> sysconfig.get_config_var('LIBS')\n"
"'-lpthread -ldl  -lutil'\n"
">>> sysconfig.get_config_var('LINKFORSHARED')\n"
"'-Xlinker -export-dynamic'"
msgstr ""
">>> import sysconfig\n"
">>> sysconfig.get_config_var('LIBS')\n"
"'-lpthread -ldl  -lutil'\n"
">>> sysconfig.get_config_var('LINKFORSHARED')\n"
"'-Xlinker -export-dynamic'"
