# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# eulalio barbero espinosa <eulalio@disroot.org>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-17 14:51+0000\n"
"PO-Revision-Date: 2024-05-11 00:32+0000\n"
"Last-Translator: eulalio barbero espinosa <eulalio@disroot.org>, 2024\n"
"Language-Team: Spanish (Spain) (https://app.transifex.com/python-doc/"
"teams/5390/es_ES/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es_ES\n"
"Plural-Forms: nplurals=3; plural=n == 1 ? 0 : n != 0 && n % 1000000 == 0 ? "
"1 : 2;\n"

#: ../../extending/extending.rst:8
msgid "Extending Python with C or C++"
msgstr "Extender Python con C o C++"

#: ../../extending/extending.rst:10
msgid ""
"It is quite easy to add new built-in modules to Python, if you know how to "
"program in C.  Such :dfn:`extension modules` can do two things that can't be "
"done directly in Python: they can implement new built-in object types, and "
"they can call C library functions and system calls."
msgstr ""
"Es bastante fácil añadir nuevos módulos integrados a Python, si sabes cómo "
"programar en C. Tales :dfn:`módulos de extensión` pueden hacer dos cosas que "
"no se pueden hacer directamente en Python: pueden implementar nuevos tipos "
"de objetos integrados y pueden llamar a funciones de biblioteca C y llamadas "
"al sistema."

#: ../../extending/extending.rst:15
msgid ""
"To support extensions, the Python API (Application Programmers Interface) "
"defines a set of functions, macros and variables that provide access to most "
"aspects of the Python run-time system.  The Python API is incorporated in a "
"C source file by including the header ``\"Python.h\"``."
msgstr ""
"Para dar soporte a las extensiones, la API de Python (Application "
"Programmers Interface) define un conjunto de funciones, macros y variables "
"que proporcionan acceso a la mayoría de los aspectos del sistema de tiempo "
"de ejecución de Python.  La API de Python se incorpora en un archivo fuente "
"C incluyendo la cabecera ``\"Python.h\"``."

#: ../../extending/extending.rst:20
msgid ""
"The compilation of an extension module depends on its intended use as well "
"as on your system setup; details are given in later chapters."
msgstr ""
"La compilación de un módulo de ampliación depende del uso que se le vaya a "
"dar y de la configuración del sistema."

#: ../../extending/extending.rst:25
msgid ""
"The C extension interface is specific to CPython, and extension modules do "
"not work on other Python implementations.  In many cases, it is possible to "
"avoid writing C extensions and preserve portability to other "
"implementations. For example, if your use case is calling C library "
"functions or system calls, you should consider using the :mod:`ctypes` "
"module or the `cffi <https://cffi.readthedocs.io/>`_ library rather than "
"writing custom C code. These modules let you write Python code to interface "
"with C code and are more portable between implementations of Python than "
"writing and compiling a C extension module."
msgstr ""
"La interfaz de extensión C es específica de CPython, y los módulos de "
"extensión no funcionan en otras implementaciones de Python. En muchos casos, "
"es posible evitar escribir extensiones C y preservar la portabilidad a otras "
"implementaciones. Por ejemplo, si tu caso de uso es llamar a funciones de "
"librerías C o llamadas al sistema, deberías considerar usar el módulo :mod:"
"`ctypes` o la librería `cffi <https://cffi.readthedocs.io/>`_ en lugar de "
"escribir código C personalizado. Estos módulos te permiten escribir código "
"Python para interactuar con código C y son más portables entre "
"implementaciones de Python que escribir y compilar un módulo de extensión C."

#: ../../extending/extending.rst:40
msgid "A Simple Example"
msgstr "Un ejemplo sencillo"

#: ../../extending/extending.rst:42
msgid ""
"Let's create an extension module called ``spam`` (the favorite food of Monty "
"Python fans...) and let's say we want to create a Python interface to the C "
"library function :c:func:`system` [#]_. This function takes a null-"
"terminated character string as argument and returns an integer.  We want "
"this function to be callable from Python as follows:"
msgstr ""
"Vamos a crear un módulo de extensión llamado ``spam`` (la comida favorita de "
"los fans de Monty Python...) y digamos que queremos crear una interfaz "
"Python para la función de la biblioteca C :c:func:`system` [#]_. Esta "
"función toma una cadena de caracteres terminada en cero como argumento y "
"devuelve un entero.  Queremos que esta función sea invocable desde Python de "
"la siguiente manera:"

#: ../../extending/extending.rst:48
msgid ""
">>> import spam\n"
">>> status = spam.system(\"ls -l\")"
msgstr ""
">>> import spam\n"
">>> status = spam.system(\"ls -l\")"

#: ../../extending/extending.rst:53
msgid ""
"Begin by creating a file :file:`spammodule.c`.  (Historically, if a module "
"is called ``spam``, the C file containing its implementation is called :file:"
"`spammodule.c`; if the module name is very long, like ``spammify``, the "
"module name can be just :file:`spammify.c`.)"
msgstr ""
"Comience por crear un archivo :file:`spammodule.c`.  (Históricamente, si un "
"módulo se llama ``spam``, el archivo C que contiene su implementación se "
"llama :file:`spammodule.c`; si el nombre del módulo es muy largo, como "
"``spammify``, el nombre del módulo puede ser simplemente :file:`spammify.c`)."

#: ../../extending/extending.rst:58
msgid "The first two lines of our file can be::"
msgstr "Las primeras dos líneas de nuestro archivo pueden ser::"

#: ../../extending/extending.rst:60
msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>"
msgstr ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>"

#: ../../extending/extending.rst:63
msgid ""
"which pulls in the Python API (you can add a comment describing the purpose "
"of the module and a copyright notice if you like)."
msgstr ""
"que importa la API de Python (puedes agregar un comentario describiendo el "
"propósito del módulo y un aviso de derechos de autor si lo deseas)."

#: ../../extending/extending.rst:68
msgid ""
"Since Python may define some pre-processor definitions which affect the "
"standard headers on some systems, you *must* include :file:`Python.h` before "
"any standard headers are included."
msgstr ""
"Dado que Python puede definir algunas definiciones de preprocesador que "
"afectan a las cabeceras estándar en algunos sistemas, *debes* incluir :file:"
"`Python.h` antes de incluir cualquier cabecera estándar."

#: ../../extending/extending.rst:72
msgid ""
"It is recommended to always define ``PY_SSIZE_T_CLEAN`` before including "
"``Python.h``.  See :ref:`parsetuple` for a description of this macro."
msgstr ""
"Se recomienda definir siempre ``PY_SSIZE_T_CLEAN`` antes de incluir ``Python."
"h``. Ver :ref:`parsetuple` para una descripción de esta macro."

#: ../../extending/extending.rst:75
msgid ""
"All user-visible symbols defined by :file:`Python.h` have a prefix of ``Py`` "
"or ``PY``, except those defined in standard header files. For convenience, "
"and since they are used extensively by the Python interpreter, ``\"Python."
"h\"`` includes a few standard header files: ``<stdio.h>``, ``<string.h>``, "
"``<errno.h>``, and ``<stdlib.h>``.  If the latter header file does not exist "
"on your system, it declares the functions :c:func:`malloc`, :c:func:`free` "
"and :c:func:`realloc` directly."
msgstr ""
"Todos los símbolos visibles para el usuario definidos por :file:`Python.h` "
"tienen un prefijo de ``Py`` o ``PY``, excepto aquellos definidos en archivos "
"de encabezado estándar. Por conveniencia, y dado que son utilizados "
"extensivamente por el intérprete de Python, ``\"Python.h\"`` incluye algunos "
"archivos de encabezado estándar: ``<stdio.h>``, ``<string.h>``, ``<errno."
"h>`` y ``<stdlib.h>``. Si el último archivo de encabezado no existe en su "
"sistema, declara las funciones :c:func:`malloc`, :c:func:`free` y :c:func:"
"`realloc` directamente."

#: ../../extending/extending.rst:83
msgid ""
"The next thing we add to our module file is the C function that will be "
"called when the Python expression ``spam.system(string)`` is evaluated "
"(we'll see shortly how it ends up being called)::"
msgstr ""
"Lo siguiente que añadimos a nuestro fichero de módulo es la función C que "
"será llamada cuando se evalúe la expresión Python ``spam.system(string)`` "
"(veremos en breve cómo acaba siendo llamada)::"

#: ../../extending/extending.rst:87
msgid ""
"static PyObject *\n"
"spam_system(PyObject *self, PyObject *args)\n"
"{\n"
"    const char *command;\n"
"    int sts;\n"
"\n"
"    if (!PyArg_ParseTuple(args, \"s\", &command))\n"
"        return NULL;\n"
"    sts = system(command);\n"
"    return PyLong_FromLong(sts);\n"
"}"
msgstr ""
"static PyObject *\n"
"spam_system(PyObject *self, PyObject *args)\n"
"{\n"
"    const char *command;\n"
"    int sts;\n"
"\n"
"    if (!PyArg_ParseTuple(args, \"s\", &command))\n"
"        return NULL;\n"
"    sts = system(command);\n"
"    return PyLong_FromLong(sts);\n"
"}"

#: ../../extending/extending.rst:99
msgid ""
"There is a straightforward translation from the argument list in Python (for "
"example, the single expression ``\"ls -l\"``) to the arguments passed to the "
"C function.  The C function always has two arguments, conventionally named "
"*self* and *args*."
msgstr ""
"Existe una traducción directa de la lista de argumentos en Python (por "
"ejemplo, la expresión única ``\"ls -l\"``) a los argumentos pasados a la "
"función C.  La función C siempre tiene dos argumentos, convencionalmente "
"llamados *self* y *args*."

#: ../../extending/extending.rst:104
msgid ""
"The *self* argument points to the module object for module-level functions; "
"for a method it would point to the object instance."
msgstr ""
"El argumento *self* apunta al objeto del módulo para funciones a nivel de "
"módulo; para un método apuntaría a la instancia del objeto."

#: ../../extending/extending.rst:107
msgid ""
"The *args* argument will be a pointer to a Python tuple object containing "
"the arguments.  Each item of the tuple corresponds to an argument in the "
"call's argument list.  The arguments are Python objects --- in order to do "
"anything with them in our C function we have to convert them to C values.  "
"The function :c:func:`PyArg_ParseTuple` in the Python API checks the "
"argument types and converts them to C values.  It uses a template string to "
"determine the required types of the arguments as well as the types of the C "
"variables into which to store the converted values.  More about this later."
msgstr ""
"El argumento *args* será un puntero a un objeto tupla de Python que contiene "
"los argumentos.  Cada elemento de la tupla corresponde a un argumento de la "
"lista de argumentos de la llamada.  Los argumentos son objetos Python --- "
"para poder hacer algo con ellos en nuestra función C tenemos que "
"convertirlos a valores C.  La función :c:func:`PyArg_ParseTuple` de la API "
"de Python comprueba los tipos de argumentos y los convierte en valores C.  "
"Utiliza una cadena de plantilla para determinar los tipos requeridos de los "
"argumentos, así como los tipos de las variables C en las que almacenar los "
"valores convertidos.  Más sobre esto más adelante."

#: ../../extending/extending.rst:116
msgid ""
":c:func:`PyArg_ParseTuple` returns true (nonzero) if all arguments have the "
"right type and its components have been stored in the variables whose "
"addresses are passed.  It returns false (zero) if an invalid argument list "
"was passed.  In the latter case it also raises an appropriate exception so "
"the calling function can return ``NULL`` immediately (as we saw in the "
"example)."
msgstr ""
":c:func:`PyArg_ParseTuple` devuelve verdadero (distinto de cero) si todos "
"los argumentos tienen el tipo correcto y sus componentes se han almacenado "
"en las variables cuyas direcciones se han pasado.  Devuelve false (cero) si "
"se ha pasado una lista de argumentos no válida.  En este último caso también "
"lanza una excepción apropiada para que la función que llama pueda devolver "
"``NULL`` inmediatamente (como vimos en el ejemplo)."

#: ../../extending/extending.rst:126
msgid "Intermezzo: Errors and Exceptions"
msgstr "Intermezzo: Errores y excepciones"

#: ../../extending/extending.rst:128
msgid ""
"An important convention throughout the Python interpreter is the following: "
"when a function fails, it should set an exception condition and return an "
"error value (usually ``-1`` or a ``NULL`` pointer).  Exception information "
"is stored in three members of the interpreter's thread state.  These are "
"``NULL`` if there is no exception.  Otherwise they are the C equivalents of "
"the members of the Python tuple returned by :meth:`sys.exc_info`.  These are "
"the exception type, exception instance, and a traceback object.  It is "
"important to know about them to understand how errors are passed around."
msgstr ""
"Una convención importante en todo el intérprete de Python es la siguiente: "
"cuando una función falla, debe establecer una condición de excepción y "
"devolver un valor de error (normalmente ``-1`` o un puntero ``NULL``).  La "
"información de excepción se almacena en tres miembros del estado del hilo "
"del intérprete. Estos son``NULL`` si no hay excepción. Si no, son los "
"equivalentes en C de los miembros de la tupla Python devuelta por :meth:`sys."
"exc_info`.  Estos son el tipo de excepción, la instancia de excepción, y un "
"objeto traceback. Es importante conocerlos para entender cómo se transmiten "
"los errores."

#: ../../extending/extending.rst:137
msgid ""
"The Python API defines a number of functions to set various types of "
"exceptions."
msgstr ""
"La API de Python define una serie de funciones para establecer varios tipos "
"de excepciones."

#: ../../extending/extending.rst:139
msgid ""
"The most common one is :c:func:`PyErr_SetString`.  Its arguments are an "
"exception object and a C string.  The exception object is usually a "
"predefined object like :c:data:`PyExc_ZeroDivisionError`.  The C string "
"indicates the cause of the error and is converted to a Python string object "
"and stored as the \"associated value\" of the exception."
msgstr ""
"El más común es :c:func:`PyErr_SetString`. Sus argumentos son un objeto de "
"excepción y una cadena C.  El objeto de excepción suele ser un objeto "
"predefinido como :c:data:`PyExc_ZeroDivisionError`.  La cadena C indica la "
"causa del error y se convierte en un objeto de cadena Python y se almacena "
"como el \"valor asociado\" de la excepción."

#: ../../extending/extending.rst:145
msgid ""
"Another useful function is :c:func:`PyErr_SetFromErrno`, which only takes an "
"exception argument and constructs the associated value by inspection of the "
"global variable :c:data:`errno`.  The most general function is :c:func:"
"`PyErr_SetObject`, which takes two object arguments, the exception and its "
"associated value.  You don't need to :c:func:`Py_INCREF` the objects passed "
"to any of these functions."
msgstr ""
"Otra función útil es :c:func:`PyErr_SetFromErrno`, que sólo toma un "
"argumento de excepción y construye el valor asociado mediante inspección de "
"la variable global :c:data:`errno`.  La función más general es :c:func:"
"`PyErr_SetObject`, que toma dos argumentos de objeto, la excepción y su "
"valor asociado.  No es necesario que :c:func:`Py_INCREF` los objetos pasados "
"a cualquiera de estas funciones."

#: ../../extending/extending.rst:152
msgid ""
"You can test non-destructively whether an exception has been set with :c:"
"func:`PyErr_Occurred`.  This returns the current exception object, or "
"``NULL`` if no exception has occurred.  You normally don't need to call :c:"
"func:`PyErr_Occurred` to see whether an error occurred in a function call, "
"since you should be able to tell from the return value."
msgstr ""
"Puede comprobar de forma no destructiva si se ha producido una excepción "
"con :c:func:`PyErr_Occurred`.  Esto devuelve el objeto de excepción actual, "
"o ``NULL`` si no se ha producido ninguna excepción.  Normalmente no es "
"necesario llamar a :c:func:`PyErr_Occurred` para ver si se ha producido un "
"error en una llamada a una función, ya que debería ser capaz de saberlo por "
"el valor de retorno."

#: ../../extending/extending.rst:158
msgid ""
"When a function *f* that calls another function *g* detects that the latter "
"fails, *f* should itself return an error value (usually ``NULL`` or "
"``-1``).  It should *not* call one of the ``PyErr_*`` functions --- one has "
"already been called by *g*. *f*'s caller is then supposed to also return an "
"error indication to *its* caller, again *without* calling ``PyErr_*``, and "
"so on --- the most detailed cause of the error was already reported by the "
"function that first detected it.  Once the error reaches the Python "
"interpreter's main loop, this aborts the currently executing Python code and "
"tries to find an exception handler specified by the Python programmer."
msgstr ""
"Cuando una función *f* que llama a otra función *g* detecta que esta última "
"falla, *f* debería devolver un valor de error (normalmente ``NULL`` o "
"``-1``).  No debería *llamar* a una de las funciones ``PyErr_*`` --- una ya "
"ha sido llamada por *g*. Se supone que el llamador de *f* debe entonces "
"devolver también una indicación de error a *su* llamador, de nuevo *sin* "
"llamar a ``PyErr_*``, y así sucesivamente --- la causa más detallada del "
"error ya fue informada por la función que lo detectó primero.  Una vez que "
"el error alcanza el bucle principal del intérprete Python, éste aborta el "
"código Python actualmente en ejecución e intenta encontrar un manejador de "
"excepciones especificado por el programador Python."

#: ../../extending/extending.rst:168
msgid ""
"(There are situations where a module can actually give a more detailed error "
"message by calling another ``PyErr_*`` function, and in such cases it is "
"fine to do so.  As a general rule, however, this is not necessary, and can "
"cause information about the cause of the error to be lost: most operations "
"can fail for a variety of reasons.)"
msgstr ""
"(Hay situaciones en las que un módulo puede dar un mensaje de error más "
"detallado llamando a otra función de ``PyErr_*``, y en esos casos está bien "
"hacerlo.  Como regla general, sin embargo, esto no es necesario, y puede "
"hacer que se pierda información sobre la causa del error: la mayoría de las "
"operaciones pueden fallar por diversas razones)."

#: ../../extending/extending.rst:174
msgid ""
"To ignore an exception set by a function call that failed, the exception "
"condition must be cleared explicitly by calling :c:func:`PyErr_Clear`.  The "
"only time C code should call :c:func:`PyErr_Clear` is if it doesn't want to "
"pass the error on to the interpreter but wants to handle it completely by "
"itself (possibly by trying something else, or pretending nothing went wrong)."
msgstr ""
"Para ignorar una excepción establecida por una llamada a una función que "
"falló, la condición de excepción debe ser limpiada explícitamente llamando "
"a :c:func:`PyErr_Clear`.  La única vez que el código C debería llamar a :c:"
"func:`PyErr_Clear` es si no quiere pasar el error al intérprete sino que "
"quiere manejarlo completamente por sí mismo (posiblemente intentando algo "
"más, o pretendiendo que nada ha ido mal)."

#: ../../extending/extending.rst:180
msgid ""
"Every failing :c:func:`malloc` call must be turned into an exception --- the "
"direct caller of :c:func:`malloc` (or :c:func:`realloc`) must call :c:func:"
"`PyErr_NoMemory` and return a failure indicator itself.  All the object-"
"creating functions (for example, :c:func:`PyLong_FromLong`) already do this, "
"so this note is only relevant to those who call :c:func:`malloc` directly."
msgstr ""
"Cada llamada fallida a :c:func:`malloc` debe convertirse en una excepción "
"--- el llamador directo de :c:func:`malloc` (o :c:func:`realloc`) debe "
"llamar a :c:func:`PyErr_NoMemory` y devolver él mismo un indicador de "
"fallo.  Todas las funciones de creación de objetos (por ejemplo, :c:func:"
"`PyLong_FromLong`) ya hacen esto, por lo que esta nota sólo es relevante "
"para aquellos que llaman directamente a :c:func:`malloc`."

#: ../../extending/extending.rst:186
msgid ""
"Also note that, with the important exception of :c:func:`PyArg_ParseTuple` "
"and friends, functions that return an integer status usually return a "
"positive value or zero for success and ``-1`` for failure, like Unix system "
"calls."
msgstr ""
"También tenga en cuenta que, con la importante excepción de :c:func:"
"`PyArg_ParseTuple` y amigos, las funciones que devuelven un estado entero "
"generalmente devuelven un valor positivo o cero para el éxito y ``-1`` para "
"el fallo, al igual que las llamadas al sistema Unix."

#: ../../extending/extending.rst:190
msgid ""
"Finally, be careful to clean up garbage (by making :c:func:`Py_XDECREF` or :"
"c:func:`Py_DECREF` calls for objects you have already created) when you "
"return an error indicator!"
msgstr ""
"Finalmente, ¡ten cuidado de limpiar la basura (haciendo llamadas a :c:func:"
"`Py_XDECREF` o :c:func:`Py_DECREF` para los objetos que ya has creado) "
"cuando devuelvas un indicador de error!"

#: ../../extending/extending.rst:194
msgid ""
"The choice of which exception to raise is entirely yours.  There are "
"predeclared C objects corresponding to all built-in Python exceptions, such "
"as :c:data:`PyExc_ZeroDivisionError`, which you can use directly. Of course, "
"you should choose exceptions wisely --- don't use :c:data:`PyExc_TypeError` "
"to mean that a file couldn't be opened (that should probably be :c:data:"
"`PyExc_OSError`). If something's wrong with the argument list, the :c:func:"
"`PyArg_ParseTuple` function usually raises :c:data:`PyExc_TypeError`.  If "
"you have an argument whose value must be in a particular range or must "
"satisfy other conditions, :c:data:`PyExc_ValueError` is appropriate."
msgstr ""
"La elección de qué excepción lanzar es completamente tuya.  Hay objetos C "
"predeclarados que corresponden a todas las excepciones incorporadas en "
"Python, como :c:data:`PyExc_ZeroDivisionError`, que puedes usar "
"directamente. Por supuesto, debes elegir las excepciones sabiamente --- no "
"uses :c:data:`PyExc_TypeError` para significar que un archivo no pudo ser "
"abierto (eso probablemente debería ser :c:data:`PyExc_OSError`). Si algo "
"está mal en la lista de argumentos, la función :c:func:`PyArg_ParseTuple` "
"normalmente lanza :c:data:`PyExc_TypeError`.  Si tienes un argumento cuyo "
"valor debe estar en un rango particular o debe satisfacer otras "
"condiciones, :c:data:`PyExc_ValueError` es apropiado."

#: ../../extending/extending.rst:204
msgid ""
"You can also define a new exception that is unique to your module. For this, "
"you usually declare a static object variable at the beginning of your file::"
msgstr ""
"También puedes definir una nueva excepción que sea única para tu módulo. "
"Para esto, generalmente declaras una variable de objeto estático al "
"principio de tu archivo::"

#: ../../extending/extending.rst:207
msgid "static PyObject *SpamError;"
msgstr "static PyObject *SpamError;"

#: ../../extending/extending.rst:209
msgid ""
"and initialize it in your module's initialization function (:c:func:`!"
"PyInit_spam`) with an exception object::"
msgstr ""
"e inicialízalo en la función de inicialización de tu módulo (:c:func:`!"
"PyInit_spam`) con un objeto de excepción::"

#: ../../extending/extending.rst:212
msgid ""
"PyMODINIT_FUNC\n"
"PyInit_spam(void)\n"
"{\n"
"    PyObject *m;\n"
"\n"
"    m = PyModule_Create(&spammodule);\n"
"    if (m == NULL)\n"
"        return NULL;\n"
"\n"
"    SpamError = PyErr_NewException(\"spam.error\", NULL, NULL);\n"
"    Py_XINCREF(SpamError);\n"
"    if (PyModule_AddObject(m, \"error\", SpamError) < 0) {\n"
"        Py_XDECREF(SpamError);\n"
"        Py_CLEAR(SpamError);\n"
"        Py_DECREF(m);\n"
"        return NULL;\n"
"    }\n"
"\n"
"    return m;\n"
"}"
msgstr ""
"PyMODINIT_FUNC\n"
"PyInit_spam(void)\n"
"{\n"
"    PyObject *m;\n"
"\n"
"    m = PyModule_Create(&spammodule);\n"
"    if (m == NULL)\n"
"        devuelve NULL;\n"
"\n"
"    SpamError = PyErr_NewException(\"spam.error\", NULL, NULL);\n"
"    Py_XINCREF(SpamError);\n"
"    if (PyModule_AddObject(m, \"error\", SpamError) < 0) {\n"
"        Py_XDECREF(SpamError);\n"
"        Py_CLEAR(SpamError);\n"
"        Py_DECREF(m);\n"
"        return NULL;\n"
"    }\n"
"\n"
"    return m;\n"
"}"

#: ../../extending/extending.rst:233
msgid ""
"Note that the Python name for the exception object is :exc:`!spam.error`.  "
"The :c:func:`PyErr_NewException` function may create a class with the base "
"class being :exc:`Exception` (unless another class is passed in instead of "
"``NULL``), described in :ref:`bltin-exceptions`."
msgstr ""
"Observe que el nombre en Python del objeto de excepción es :exc:`!spam."
"error`.  La función :c:func:`PyErr_NewException` puede crear una clase cuya "
"clase base sea :exc:`Exception` (a menos que se pase otra clase en lugar de "
"``NULL``), descrita en :ref:`bltin-exceptions`."

#: ../../extending/extending.rst:238
msgid ""
"Note also that the :c:data:`!SpamError` variable retains a reference to the "
"newly created exception class; this is intentional!  Since the exception "
"could be removed from the module by external code, an owned reference to the "
"class is needed to ensure that it will not be discarded, causing :c:data:`!"
"SpamError` to become a dangling pointer. Should it become a dangling "
"pointer, C code which raises the exception could cause a core dump or other "
"unintended side effects."
msgstr ""
"Observa también que la variable :c:data:`!SpamError` retiene una referencia "
"a la clase de excepción recién creada; ¡esto es intencionado!  Dado que la "
"excepción podría ser eliminada del módulo por código externo, se necesita "
"una referencia propia a la clase para asegurar que no será descartada, "
"causando que :c:data:`!SpamError` se convierta en un puntero colgante. Si se "
"convirtiera en un puntero colgante, el código C que lanza la excepción "
"podría causar un volcado del núcleo u otros efectos secundarios no deseados."

#: ../../extending/extending.rst:245
msgid ""
"We discuss the use of :c:macro:`PyMODINIT_FUNC` as a function return type "
"later in this sample."
msgstr ""
"Discutiremos el uso de :c:macro:`PyMODINIT_FUNC` como tipo de retorno de "
"función más adelante en este ejemplo."

#: ../../extending/extending.rst:248
msgid ""
"The :exc:`!spam.error` exception can be raised in your extension module "
"using a call to :c:func:`PyErr_SetString` as shown below::"
msgstr ""
"La excepción :exc:`!spam.error` puede ser lanzada en su módulo de extensión "
"usando una llamada a :c:func:`PyErr_SetString` como se muestra a "
"continuación::"

#: ../../extending/extending.rst:251
msgid ""
"static PyObject *\n"
"spam_system(PyObject *self, PyObject *args)\n"
"{\n"
"    const char *command;\n"
"    int sts;\n"
"\n"
"    if (!PyArg_ParseTuple(args, \"s\", &command))\n"
"        return NULL;\n"
"    sts = system(command);\n"
"    if (sts < 0) {\n"
"        PyErr_SetString(SpamError, \"System command failed\");\n"
"        return NULL;\n"
"    }\n"
"    return PyLong_FromLong(sts);\n"
"}"
msgstr ""
"static PyObject *\n"
"spam_system(PyObject *self, PyObject *args)\n"
"{\n"
"    const char *command;\n"
"    int sts;\n"
"\n"
"    if (!PyArg_ParseTuple(args, \"s\", &command))\n"
"        devuelve NULL;\n"
"    sts = system(comando);\n"
"    if (sts < 0) {\n"
"        PyErr_SetString(SpamError, \"Comando de sistema fallido\");\n"
"        return NULL;\n"
"    }\n"
"    return PyLong_FromLong(sts);\n"
"}"

#: ../../extending/extending.rst:271
msgid "Back to the Example"
msgstr "Volver al ejemplo"

#: ../../extending/extending.rst:273
msgid ""
"Going back to our example function, you should now be able to understand "
"this statement::"
msgstr ""
"Volviendo a nuestra función de ejemplo, ahora deberías ser capaz de entender "
"esta afirmación::"

#: ../../extending/extending.rst:276
msgid ""
"if (!PyArg_ParseTuple(args, \"s\", &command))\n"
"    return NULL;"
msgstr ""
"if (!PyArg_ParseTuple(args, \"s\", &command))\n"
"    return NULL;"

#: ../../extending/extending.rst:279
msgid ""
"It returns ``NULL`` (the error indicator for functions returning object "
"pointers) if an error is detected in the argument list, relying on the "
"exception set by :c:func:`PyArg_ParseTuple`.  Otherwise the string value of "
"the argument has been copied to the local variable :c:data:`!command`.  This "
"is a pointer assignment and you are not supposed to modify the string to "
"which it points (so in Standard C, the variable :c:data:`!command` should "
"properly be declared as ``const char *command``)."
msgstr ""
"Devuelve ``NULL`` (el indicador de error para funciones que devuelven "
"punteros a objetos) si se detecta un error en la lista de argumentos, "
"basándose en la excepción establecida por :c:func:`PyArg_ParseTuple`.  En "
"caso contrario, el valor de la cadena del argumento se ha copiado en la "
"variable local :c:data:`!command`.  Se trata de una asignación de puntero y "
"se supone que no se debe modificar la cadena a la que apunta (por lo que en "
"C estándar, la variable :c:data:`!command` debería declararse correctamente "
"como ``const char *command``)."

#: ../../extending/extending.rst:287
msgid ""
"The next statement is a call to the Unix function :c:func:`system`, passing "
"it the string we just got from :c:func:`PyArg_ParseTuple`::"
msgstr ""
"La siguiente sentencia es una llamada a la función Unix :c:func:`system`, "
"pasándole la cadena que acabamos de obtener de :c:func:`PyArg_ParseTuple`::"

#: ../../extending/extending.rst:290
msgid "sts = system(command);"
msgstr "sts = system(command);"

#: ../../extending/extending.rst:292
msgid ""
"Our :func:`!spam.system` function must return the value of :c:data:`!sts` as "
"a Python object.  This is done using the function :c:func:"
"`PyLong_FromLong`. ::"
msgstr ""
"Nuestra función :func:`!spam.system` debe devolver el valor de :c:data:`!"
"sts` como un objeto Python.  Esto se hace utilizando la función :c:func:"
"`PyLong_FromLong`. ::"

#: ../../extending/extending.rst:295
msgid "return PyLong_FromLong(sts);"
msgstr "return PyLong_FromLong(sts);"

#: ../../extending/extending.rst:297
msgid ""
"In this case, it will return an integer object.  (Yes, even integers are "
"objects on the heap in Python!)"
msgstr ""
"En este caso, devolverá un objeto entero.  (¡Sí, incluso los enteros son "
"objetos en el montón en Python!)"

#: ../../extending/extending.rst:300
msgid ""
"If you have a C function that returns no useful argument (a function "
"returning :c:expr:`void`), the corresponding Python function must return "
"``None``.   You need this idiom to do so (which is implemented by the :c:"
"macro:`Py_RETURN_NONE` macro)::"
msgstr ""
"Si tienes una función C que no devuelve ningún argumento útil (una función "
"que devuelve :c:expr:`void`), la función Python correspondiente debe "
"devolver ``None``.   Para ello necesita esta expresión (implementada por la "
"macro :c:macro:`Py_RETURN_NONE` )::"

#: ../../extending/extending.rst:305
msgid ""
"Py_INCREF(Py_None);\n"
"return Py_None;"
msgstr ""
"Py_INCREF(Py_None);\n"
"return Py_None;"

#: ../../extending/extending.rst:308
msgid ""
":c:data:`Py_None` is the C name for the special Python object ``None``.  It "
"is a genuine Python object rather than a ``NULL`` pointer, which means "
"\"error\" in most contexts, as we have seen."
msgstr ""
":c:data:`Py_None` es el nombre en C del objeto especial de Python ``None``.  "
"Es un objeto Python genuino en lugar de un puntero ``NULL``, que significa "
"\"error\" en la mayoría de los contextos, como hemos visto."

#: ../../extending/extending.rst:316
msgid "The Module's Method Table and Initialization Function"
msgstr "Tabla de métodos del módulo y función de inicialización"

#: ../../extending/extending.rst:318
msgid ""
"I promised to show how :c:func:`!spam_system` is called from Python "
"programs. First, we need to list its name and address in a \"method table\"::"
msgstr ""
"Prometí mostrar cómo se llama a :c:func:`!spam_system` desde los programas "
"Python. Primero, necesitamos listar su nombre y dirección en una \"tabla de "
"métodos\"::"

#: ../../extending/extending.rst:321
msgid ""
"static PyMethodDef SpamMethods[] = {\n"
"    ...\n"
"    {\"system\",  spam_system, METH_VARARGS,\n"
"     \"Execute a shell command.\"},\n"
"    ...\n"
"    {NULL, NULL, 0, NULL}        /* Sentinel */\n"
"};"
msgstr ""
"static PyMethodDef SpamMethods[] = {\n"
"    ...\n"
"    {\"sistema\", spam_sistema, METH_VARARGS,\n"
"     \"Ejecutar un comando shell\"},\n"
"    ...\n"
"    {NULL, NULL, 0, NULL}        /* Centinela */\n"
"};"

#: ../../extending/extending.rst:329
msgid ""
"Note the third entry (``METH_VARARGS``).  This is a flag telling the "
"interpreter the calling convention to be used for the C function.  It should "
"normally always be ``METH_VARARGS`` or ``METH_VARARGS | METH_KEYWORDS``; a "
"value of ``0`` means that an obsolete variant of :c:func:`PyArg_ParseTuple` "
"is used."
msgstr ""
"Observe la tercera entrada (``METH_VARARGS``).  Se trata de una bandera que "
"indica al intérprete la convención de llamada a utilizar para la función C. "
"Normalmente debería ser siempre  o  .  Normalmente debería ser siempre "
"``METH_VARARGS`` o ``METH_VARARGS | METH_KEYWORDS``; un valor de ``0`` "
"significa que se usa una variante obsoleta de :c:func:`PyArg_ParseTuple`."

#: ../../extending/extending.rst:334
msgid ""
"When using only ``METH_VARARGS``, the function should expect the Python-"
"level parameters to be passed in as a tuple acceptable for parsing via :c:"
"func:`PyArg_ParseTuple`; more information on this function is provided below."
msgstr ""
"Cuando sólo se utiliza ``METH_VARARGS``, la función debe esperar que los "
"parámetros de nivel Python se pasen como una tupla aceptable para el "
"análisis sintáctico a través de :c:func:`PyArg_ParseTuple`; más adelante se "
"proporciona más información sobre esta función."

#: ../../extending/extending.rst:338
msgid ""
"The :c:macro:`METH_KEYWORDS` bit may be set in the third field if keyword "
"arguments should be passed to the function.  In this case, the C function "
"should accept a third ``PyObject *`` parameter which will be a dictionary of "
"keywords. Use :c:func:`PyArg_ParseTupleAndKeywords` to parse the arguments "
"to such a function."
msgstr ""
"El bit :c:macro:`METH_KEYWORDS` puede establecerse en el tercer campo si "
"deben pasarse argumentos de palabras clave a la función.  En este caso, la "
"función C debe aceptar un tercer parámetro ``PyObject *`` que será un "
"diccionario de palabras clave. Utilice :c:func:`PyArg_ParseTupleAndKeywords` "
"para analizar los argumentos de dicha función."

#: ../../extending/extending.rst:344
msgid ""
"The method table must be referenced in the module definition structure::"
msgstr ""
"La tabla de métodos debe estar referenciada en la estructura de definición "
"del módulo::"

#: ../../extending/extending.rst:346
msgid ""
"static struct PyModuleDef spammodule = {\n"
"    PyModuleDef_HEAD_INIT,\n"
"    \"spam\",   /* name of module */\n"
"    spam_doc, /* module documentation, may be NULL */\n"
"    -1,       /* size of per-interpreter state of the module,\n"
"                 or -1 if the module keeps state in global variables. */\n"
"    SpamMethods\n"
"};"
msgstr ""
"static struct PyModuleDef spammodule = {\n"
"    PyModuleDef_HEAD_INIT,\n"
"    \"spam\", /* nombre del módulo */\n"
"    spam_doc, /* documentación del módulo, puede ser NULL */\n"
"    -1, /* tamaño del estado por intérprete del módulo,\n"
"                 o -1 si el módulo mantiene el estado en variables globales. "
"*/\n"
"    SpamMethods\n"
"};"

#: ../../extending/extending.rst:355
msgid ""
"This structure, in turn, must be passed to the interpreter in the module's "
"initialization function.  The initialization function must be named :c:func:"
"`!PyInit_name`, where *name* is the name of the module, and should be the "
"only non-\\ ``static`` item defined in the module file::"
msgstr ""
"Esta estructura, a su vez, debe pasarse al intérprete en la función de "
"inicialización del módulo.  La función de inicialización debe llamarse :c:"
"func:`!PyInit_name`, donde *name* es el nombre del módulo, y debe ser el "
"único elemento no ``static`` definido en el archivo del módulo::"

#: ../../extending/extending.rst:360
msgid ""
"PyMODINIT_FUNC\n"
"PyInit_spam(void)\n"
"{\n"
"    return PyModule_Create(&spammodule);\n"
"}"
msgstr ""
"PyMODINIT_FUNC\n"
"PyInit_spam(void)\n"
"{\n"
"    return PyModule_Create(&spammodule);\n"
"}"

#: ../../extending/extending.rst:366
msgid ""
"Note that :c:macro:`PyMODINIT_FUNC` declares the function as ``PyObject *`` "
"return type, declares any special linkage declarations required by the "
"platform, and for C++ declares the function as ``extern \"C\"``."
msgstr ""
"Observe que :c:macro:`PyMODINIT_FUNC` declara la función como ``PyObject *`` "
"tipo de retorno, declara cualquier declaración especial de vinculación "
"requerida por la plataforma, y para C++ declara la función como ``extern "
"\"C\"``."

#: ../../extending/extending.rst:370
msgid ""
"When the Python program imports module :mod:`!spam` for the first time, :c:"
"func:`!PyInit_spam` is called. (See below for comments about embedding "
"Python.) It calls :c:func:`PyModule_Create`, which returns a module object, "
"and inserts built-in function objects into the newly created module based "
"upon the table (an array of :c:type:`PyMethodDef` structures) found in the "
"module definition. :c:func:`PyModule_Create` returns a pointer to the module "
"object that it creates.  It may abort with a fatal error for certain errors, "
"or return ``NULL`` if the module could not be initialized satisfactorily. "
"The init function must return the module object to its caller, so that it "
"then gets inserted into ``sys.modules``."
msgstr ""
"Cuando el programa Python importa el módulo :mod:`!spam` por primera vez, se "
"llama a :c:func:`!PyInit_spam`.  (Consulte a continuación los comentarios "
"sobre la incrustación de Python.) Llama a :c:func:`PyModule_Create`, que "
"devuelve un objeto de módulo, e inserta objetos de función incorporados en "
"el módulo recién creado basándose en la tabla (una matriz de estructuras :c:"
"type:`PyMethodDef` ) que se encuentra en la definición del módulo. :c:func:"
"`PyModule_Create` devuelve un puntero al objeto de módulo que crea.  Puede "
"abortar con un error fatal para ciertos errores, o devolver ``NULL`` si el "
"módulo no pudo ser inicializado satisfactoriamente. La función init debe "
"devolver el objeto del módulo a su invocador, para que luego se inserte en "
"``sys.modules``."

#: ../../extending/extending.rst:381
msgid ""
"When embedding Python, the :c:func:`!PyInit_spam` function is not called "
"automatically unless there's an entry in the :c:data:`PyImport_Inittab` "
"table. To add the module to the initialization table, use :c:func:"
"`PyImport_AppendInittab`, optionally followed by an import of the module::"
msgstr ""
"Al incrustar Python, la función :c:func:`!PyInit_spam` no se llama "
"automáticamente a menos que haya una entrada en la tabla :c:data:"
"`PyImport_Inittab`. Para añadir el módulo a la tabla de inicialización, "
"utilice :c:func:`PyImport_AppendInittab`, opcionalmente seguido de una "
"importación del módulo::"

#: ../../extending/extending.rst:386
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    wchar_t *program = Py_DecodeLocale(argv[0], NULL);\n"
"    if (program == NULL) {\n"
"        fprintf(stderr, \"Fatal error: cannot decode argv[0]\\n\");\n"
"        exit(1);\n"
"    }\n"
"\n"
"    /* Add a built-in module, before Py_Initialize */\n"
"    if (PyImport_AppendInittab(\"spam\", PyInit_spam) == -1) {\n"
"        fprintf(stderr, \"Error: could not extend in-built modules "
"table\\n\");\n"
"        exit(1);\n"
"    }\n"
"\n"
"    /* Pass argv[0] to the Python interpreter */\n"
"    Py_SetProgramName(program);\n"
"\n"
"    /* Initialize the Python interpreter.  Required.\n"
"       If this step fails, it will be a fatal error. */\n"
"    Py_Initialize();\n"
"\n"
"    /* Optionally import the module; alternatively,\n"
"       import can be deferred until the embedded script\n"
"       imports it. */\n"
"    PyObject *pmodule = PyImport_ImportModule(\"spam\");\n"
"    if (!pmodule) {\n"
"        PyErr_Print();\n"
"        fprintf(stderr, \"Error: could not import module 'spam'\\n\");\n"
"    }\n"
"\n"
"    ...\n"
"\n"
"    PyMem_RawFree(program);\n"
"    return 0;\n"
"}"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    wchar_t *program = Py_DecodeLocale(argv[0], NULL);\n"
"    if (programa == NULL) {\n"
"        fprintf(stderr, \"Error fatal: no se puede decodificar "
"argv[0]\\n\");\n"
"        exit(1);\n"
"    }\n"
"\n"
"    /* Añadir un módulo incorporado, antes de Py_Initialize */\n"
"    if (PyImport_AppendInittab(\"spam\", PyInit_spam) == -1) {\n"
"        fprintf(stderr, \"Error: no se pudieron extender los módulos "
"integradostable\\n\");\n"
"        exit(1);\n"
"    }\n"
"\n"
"    /* Pasar argv[0] al intérprete de Python */\n"
"    Py_SetProgramName(programa);\n"
"\n"
"    /* Inicializar el intérprete de Python.  Requerido.\n"
"       Si este paso falla, será un error fatal. */\n"
"    Py_Initialize();\n"
"\n"
"    /* Opcionalmente importar el módulo; alternativamente,\n"
"       la importación puede ser diferida hasta que el script embebido\n"
"       lo importe. */\n"
"    PyObject *pmodule = PyImport_ImportModule(\"spam\");\n"
"    if (!pmodule) {\n"
"        PyErr_Print();\n"
"        fprintf(stderr, \"Error: could not import module 'spam'\\n\");\n"
"    }\n"
"\n"
"    ...\n"
"\n"
"    PyMem_RawFree(programa);\n"
"    return 0;\n"
"}"

#: ../../extending/extending.rst:425
msgid ""
"Removing entries from ``sys.modules`` or importing compiled modules into "
"multiple interpreters within a process (or following a :c:func:`fork` "
"without an intervening :c:func:`exec`) can create problems for some "
"extension modules. Extension module authors should exercise caution when "
"initializing internal data structures."
msgstr ""
"La eliminación de entradas de ``sys.modules`` o la importación de módulos "
"compilados en múltiples intérpretes dentro de un proceso (o después de un :c:"
"func:`fork` sin un :c:func:`exec` intermedio) puede crear problemas para "
"algunos módulos de extensión. Los autores de módulos de ampliación deben "
"tener cuidado al inicializar estructuras de datos internas."

#: ../../extending/extending.rst:431
msgid ""
"A more substantial example module is included in the Python source "
"distribution as :file:`Modules/xxmodule.c`.  This file may be used as a  "
"template or simply read as an example."
msgstr ""
"En la distribución del código fuente de Python se incluye un módulo de "
"ejemplo más sustancial como :file:`Modules/xxmodule.c`.  Este archivo puede "
"utilizarse como plantilla o simplemente leerse como ejemplo."

#: ../../extending/extending.rst:437
msgid ""
"Unlike our ``spam`` example, ``xxmodule`` uses *multi-phase initialization* "
"(new in Python 3.5), where a PyModuleDef structure is returned from "
"``PyInit_spam``, and creation of the module is left to the import machinery. "
"For details on multi-phase initialization, see :PEP:`489`."
msgstr ""
"A diferencia de nuestro ejemplo ``spam``, ``xxmodule`` usa *inicialización "
"multifase* (nueva en Python 3.5), donde una estructura PyModuleDef es "
"devuelta desde ``PyInit_spam``, y la creación del módulo se deja a la "
"maquinaria de importación. Para más detalles sobre la inicialización "
"multifase, vea :PEP:`489`."

#: ../../extending/extending.rst:446
msgid "Compilation and Linkage"
msgstr "Recopilación y enlace"

#: ../../extending/extending.rst:448
msgid ""
"There are two more things to do before you can use your new extension: "
"compiling and linking it with the Python system.  If you use dynamic "
"loading, the details may depend on the style of dynamic loading your system "
"uses; see the chapters about building extension modules (chapter :ref:"
"`building`) and additional information that pertains only to building on "
"Windows (chapter :ref:`building-on-windows`) for more information about this."
msgstr ""
"Hay dos cosas más que hacer antes de que puedas usar tu nueva extensión: "
"compilarla y enlazarla con el sistema Python.  Si usas carga dinámica, los "
"detalles pueden depender del estilo de carga dinámica que use tu sistema; "
"mira los capítulos sobre construcción de módulos de extensión (capítulo :ref:"
"`building`) e información adicional que pertenece sólo a la construcción en "
"Windows (capítulo :ref:`building-on-windows`) para más información sobre "
"esto."

#: ../../extending/extending.rst:455
msgid ""
"If you can't use dynamic loading, or if you want to make your module a "
"permanent part of the Python interpreter, you will have to change the "
"configuration setup and rebuild the interpreter.  Luckily, this is very "
"simple on Unix: just place your file (:file:`spammodule.c` for example) in "
"the :file:`Modules/` directory of an unpacked source distribution, add a "
"line to the file :file:`Modules/Setup.local` describing your file:"
msgstr ""
"Si no puedes usar la carga dinámica, o si quieres hacer de tu módulo una "
"parte permanente del intérprete de Python, tendrás que cambiar la "
"configuración y reconstruir el intérprete.  Afortunadamente, esto es muy "
"simple en Unix: simplemente coloque su archivo (:file:`spammodule.c` por "
"ejemplo) en el directorio :file:`Modules/` de una distribución fuente "
"desempaquetada, añada una línea al archivo :file:`Modules/Setup.local` "
"describiendo su archivo:"

#: ../../extending/extending.rst:462
msgid "spam spammodule.o"
msgstr "spam spammodule.o"

#: ../../extending/extending.rst:466
msgid ""
"and rebuild the interpreter by running :program:`make` in the toplevel "
"directory.  You can also run :program:`make` in the :file:`Modules/` "
"subdirectory, but then you must first rebuild :file:`Makefile` there by "
"running ':program:`make` Makefile'.  (This is necessary each time you change "
"the :file:`Setup` file.)"
msgstr ""
"y reconstruya el intérprete ejecutando :program:`make` en el directorio "
"toplevel.  También puede ejecutar :program:`make` en el subdirectorio :file:"
"`Modules/`, pero entonces primero debe reconstruir :file:`Makefile` allí "
"ejecutando ':program:`make` Makefile'.  (Esto es necesario cada vez que "
"cambie el archivo :file:`Setup` )."

#: ../../extending/extending.rst:472
msgid ""
"If your module requires additional libraries to link with, these can be "
"listed on the line in the configuration file as well, for instance:"
msgstr ""
"Si su módulo requiere bibliotecas adicionales para enlazar, estas también se "
"pueden listar en la línea del archivo de configuración, por ejemplo:"

#: ../../extending/extending.rst:475
msgid "spam spammodule.o -lX11"
msgstr "spam spammodule.o -lX11"

#: ../../extending/extending.rst:483
msgid "Calling Python Functions from C"
msgstr "Llamando a funciones de Python desde C"

#: ../../extending/extending.rst:485
msgid ""
"So far we have concentrated on making C functions callable from Python.  The "
"reverse is also useful: calling Python functions from C. This is especially "
"the case for libraries that support so-called \"callback\" functions.  If a "
"C interface makes use of callbacks, the equivalent Python often needs to "
"provide a callback mechanism to the Python programmer; the implementation "
"will require calling the Python callback functions from a C callback.  Other "
"uses are also imaginable."
msgstr ""
"Hasta ahora nos hemos centrado en hacer que las funciones C se puedan llamar "
"desde Python.  Lo contrario también es útil: llamar a funciones Python desde "
"C. Este es especialmente el caso de las bibliotecas que soportan las "
"llamadas funciones \"callback\".  Si una interfaz C hace uso de callbacks, "
"el equivalente Python a menudo necesita proporcionar un mecanismo de "
"callback al programador Python; la implementación requerirá llamar a las "
"funciones de callback Python desde un callback C.  También son imaginables "
"otros usos."

#: ../../extending/extending.rst:493
msgid ""
"Fortunately, the Python interpreter is easily called recursively, and there "
"is a standard interface to call a Python function.  (I won't dwell on how to "
"call the Python parser with a particular string as input --- if you're "
"interested, have a look at the implementation of the :option:`-c` command "
"line option in :file:`Modules/main.c` from the Python source code.)"
msgstr ""
"Afortunadamente, el intérprete de Python se llama fácilmente de forma "
"recursiva, y existe una interfaz estándar para llamar a una función de "
"Python.  (No me detendré en cómo llamar al analizador sintáctico de Python "
"con una cadena concreta como entrada --- si te interesa, echa un vistazo a "
"la implementación de la opción de línea de comandos :option:`-c` en :file:"
"`Modules/main.c` desde el código fuente de Python)."

#: ../../extending/extending.rst:499
msgid ""
"Calling a Python function is easy.  First, the Python program must somehow "
"pass you the Python function object.  You should provide a function (or some "
"other interface) to do this.  When this function is called, save a pointer "
"to the Python function object (be careful to :c:func:`Py_INCREF` it!) in a "
"global variable --- or wherever you see fit. For example, the following "
"function might be part of a module definition::"
msgstr ""
"Llamar a una función Python es fácil.  Primero, el programa Python debe "
"pasarte de alguna manera el objeto función Python.  Debes proporcionar una "
"función (o alguna otra interfaz) para hacer esto.  Cuando se llame a esta "
"función, guarda un puntero al objeto de la función Python (¡cuidado con :c:"
"func:`Py_INCREF`!) en una variable global --- o donde creas conveniente. Por "
"ejemplo, la siguiente función podría ser parte de la definición de un "
"módulo::"

#: ../../extending/extending.rst:506
msgid ""
"static PyObject *my_callback = NULL;\n"
"\n"
"static PyObject *\n"
"my_set_callback(PyObject *dummy, PyObject *args)\n"
"{\n"
"    PyObject *result = NULL;\n"
"    PyObject *temp;\n"
"\n"
"    if (PyArg_ParseTuple(args, \"O:set_callback\", &temp)) {\n"
"        if (!PyCallable_Check(temp)) {\n"
"            PyErr_SetString(PyExc_TypeError, \"parameter must be "
"callable\");\n"
"            return NULL;\n"
"        }\n"
"        Py_XINCREF(temp);         /* Add a reference to new callback */\n"
"        Py_XDECREF(my_callback);  /* Dispose of previous callback */\n"
"        my_callback = temp;       /* Remember new callback */\n"
"        /* Boilerplate to return \"None\" */\n"
"        Py_INCREF(Py_None);\n"
"        result = Py_None;\n"
"    }\n"
"    return result;\n"
"}"
msgstr ""
"static PyObject *my_callback = NULL;\n"
"\n"
"static PyObject *\n"
"my_set_callback(PyObject *dummy, PyObject *args)\n"
"{\n"
"    PyObject *result = NULL;\n"
"    PyObject *temp;\n"
"\n"
"    if (PyArg_ParseTuple(args, \"O:set_callback\", &temp)) {\n"
"        if (!PyCallable_Check(temp)) {\n"
"            PyErr_SetString(PyExc_TypeError, \"el parámetro debe ser "
"invocable\");\n"
"            return NULL;\n"
"        }\n"
"        Py_XINCREF(temp); /* Añade una referencia al nuevo callback */\n"
"        Py_XDECREF(mi_callback); /* Desechar callback anterior */\n"
"        mi_callback = temp; /* Recordar el nuevo callback */\n"
"        /* Boilerplate para devolver \"None\" */\n"
"        Py_INCREF(Py_None);\n"
"        result = Py_None;\n"
"    }\n"
"    return result;\n"
"}"

#: ../../extending/extending.rst:529
msgid ""
"This function must be registered with the interpreter using the :c:macro:"
"`METH_VARARGS` flag; this is described in section :ref:`methodtable`.  The :"
"c:func:`PyArg_ParseTuple` function and its arguments are documented in "
"section :ref:`parsetuple`."
msgstr ""
"Esta función debe registrarse con el intérprete utilizando la bandera :c:"
"macro:`METH_VARARGS`; esto se describe en la sección :ref:`methodtable`.  La "
"función :c:func:`PyArg_ParseTuple` y sus argumentos se documentan en la "
"sección :ref:`parsetuple`."

#: ../../extending/extending.rst:534
msgid ""
"The macros :c:func:`Py_XINCREF` and :c:func:`Py_XDECREF` increment/decrement "
"the reference count of an object and are safe in the presence of ``NULL`` "
"pointers (but note that *temp* will not be  ``NULL`` in this context).  More "
"info on them in section :ref:`refcounts`."
msgstr ""
"Las macros :c:func:`Py_XINCREF` y :c:func:`Py_XDECREF` incrementan/"
"decrementan la cuenta de referencias de un objeto y son seguras en presencia "
"de punteros ``NULL`` (pero tenga en cuenta que *temp* no será ``NULL`` en "
"este contexto).  Más información sobre ellas en la sección :ref:`refcounts`."

#: ../../extending/extending.rst:541
msgid ""
"Later, when it is time to call the function, you call the C function :c:func:"
"`PyObject_CallObject`.  This function has two arguments, both pointers to "
"arbitrary Python objects: the Python function, and the argument list.  The "
"argument list must always be a tuple object, whose length is the number of "
"arguments.  To call the Python function with no arguments, pass in ``NULL``, "
"or an empty tuple; to call it with one argument, pass a singleton tuple. :c:"
"func:`Py_BuildValue` returns a tuple when its format string consists of zero "
"or more format codes between parentheses.  For example::"
msgstr ""
"Más tarde, cuando llega el momento de llamar a la función, se llama a la "
"función C :c:func:`PyObject_CallObject`.  Esta función tiene dos argumentos, "
"ambos punteros a objetos arbitrarios de Python: la función de Python y la "
"lista de argumentos.  La lista de argumentos debe ser siempre un objeto "
"tupla, cuya longitud es el número de argumentos.  Para llamar a la función "
"Python sin argumentos, pase ``NULL``, o una tupla vacía; para llamarla con "
"un argumento, pase una tupla singleton. :c:func:`Py_BuildValue` devuelve una "
"tupla cuando su cadena de formato consta de cero o más códigos de formato "
"entre paréntesis.  Por ejemplo::"

#: ../../extending/extending.rst:550
msgid ""
"int arg;\n"
"PyObject *arglist;\n"
"PyObject *result;\n"
"...\n"
"arg = 123;\n"
"...\n"
"/* Time to call the callback */\n"
"arglist = Py_BuildValue(\"(i)\", arg);\n"
"result = PyObject_CallObject(my_callback, arglist);\n"
"Py_DECREF(arglist);"
msgstr ""
"int arg;\n"
"PyObject *arglist;\n"
"PyObject *result;\n"
"...\n"
"arg = 123;\n"
"...\n"
"/* Hora de llamar a callback */\n"
"arglist = Py_BuildValue(\"(i)\", arg);\n"
"result = PyObject_CallObject(my_callback, arglist);\n"
"Py_DECREF(arglist);"

#: ../../extending/extending.rst:561
msgid ""
":c:func:`PyObject_CallObject` returns a Python object pointer: this is the "
"return value of the Python function.  :c:func:`PyObject_CallObject` is "
"\"reference-count-neutral\" with respect to its arguments.  In the example a "
"new tuple was created to serve as the argument list, which is :c:func:"
"`Py_DECREF`\\ -ed immediately after the :c:func:`PyObject_CallObject` call."
msgstr ""
":c:func:`PyObject_CallObject` devuelve un puntero a un objeto Python: este "
"es el valor de retorno de la función Python. :c:func:`PyObject_CallObject` "
"es \"reference-count-neutral\" con respecto a sus argumentos.  En el ejemplo "
"se ha creado una nueva tupla como lista de argumentos, que se :c:func:"
"`Py_DECREF`-ed inmediatamente después de la llamada a :c:func:"
"`PyObject_CallObject`."

#: ../../extending/extending.rst:568
msgid ""
"The return value of :c:func:`PyObject_CallObject` is \"new\": either it is a "
"brand new object, or it is an existing object whose reference count has been "
"incremented.  So, unless you want to save it in a global variable, you "
"should somehow :c:func:`Py_DECREF` the result, even (especially!) if you are "
"not interested in its value."
msgstr ""
"El valor de retorno de :c:func:`PyObject_CallObject` es \"nuevo\": o bien es "
"un objeto completamente nuevo, o bien es un objeto existente cuyo recuento "
"de referencias se ha incrementado.  Por lo tanto, a menos que quieras "
"guardarlo en una variable global, deberías de alguna manera :c:func:"
"`Py_DECREF` el resultado, incluso (¡especialmente!) si no estás interesado "
"en su valor."

#: ../../extending/extending.rst:574
msgid ""
"Before you do this, however, it is important to check that the return value "
"isn't ``NULL``.  If it is, the Python function terminated by raising an "
"exception. If the C code that called :c:func:`PyObject_CallObject` is called "
"from Python, it should now return an error indication to its Python caller, "
"so the interpreter can print a stack trace, or the calling Python code can "
"handle the exception. If this is not possible or desirable, the exception "
"should be cleared by calling :c:func:`PyErr_Clear`.  For example::"
msgstr ""
"Antes de hacer esto, sin embargo, es importante comprobar que el valor de "
"retorno no es ``NULL``.  Si lo es, la función Python termina lanzando una "
"excepción. Si el código C que llamó a :c:func:`PyObject_CallObject` es "
"llamado desde Python, ahora debería devolver una indicación de error a su "
"llamador Python, para que el intérprete pueda imprimir una traza de la pila, "
"o el código Python llamador pueda manejar la excepción. Si esto no es "
"posible o deseable, la excepción debe ser borrada llamando a :c:func:"
"`PyErr_Clear`.  Por ejemplo::"

#: ../../extending/extending.rst:582
msgid ""
"if (result == NULL)\n"
"    return NULL; /* Pass error back */\n"
"...use result...\n"
"Py_DECREF(result);"
msgstr ""
"if (result == NULL)\n"
"    return NULL; /* Devuelve el error */\n"
"...usar resultado...\n"
"Py_DECREF(result);"

#: ../../extending/extending.rst:587
msgid ""
"Depending on the desired interface to the Python callback function, you may "
"also have to provide an argument list to :c:func:`PyObject_CallObject`.  In "
"some cases the argument list is also provided by the Python program, through "
"the same interface that specified the callback function.  It can then be "
"saved and used in the same manner as the function object.  In other cases, "
"you may have to construct a new tuple to pass as the argument list.  The "
"simplest way to do this is to call :c:func:`Py_BuildValue`.  For example, if "
"you want to pass an integral event code, you might use the following code::"
msgstr ""
"Dependiendo de la interfaz deseada para la función callback de Python, puede "
"que también tengas que proporcionar una lista de argumentos a :c:func:"
"`PyObject_CallObject`. En algunos casos la lista de argumentos también es "
"proporcionada por el programa Python, a través de la misma interfaz que "
"especificó la función callback.  Se puede guardar y utilizar de la misma "
"manera que el objeto de la función.  En otros casos, puede que tengas que "
"construir una nueva tupla para pasarla como lista de argumentos.  La forma "
"más sencilla de hacerlo es llamar a :c:func:`Py_BuildValue`.  Por ejemplo, "
"si desea pasar un código de evento integral, puede utilizar el siguiente "
"código::"

#: ../../extending/extending.rst:596
msgid ""
"PyObject *arglist;\n"
"...\n"
"arglist = Py_BuildValue(\"(l)\", eventcode);\n"
"result = PyObject_CallObject(my_callback, arglist);\n"
"Py_DECREF(arglist);\n"
"if (result == NULL)\n"
"    return NULL; /* Pass error back */\n"
"/* Here maybe use the result */\n"
"Py_DECREF(result);"
msgstr ""
"PyObject *arglist;\n"
"...\n"
"arglist = Py_BuildValue(\"(l)\", eventcode);\n"
"result = PyObject_CallObject(mi_callback, arglist);\n"
"Py_DECREF(arglist);\n"
"if (result == NULL)\n"
"    return NULL; /* Devuelve el error */\n"
"/* Aquí quizás usar el resultado */\n"
"Py_DECREF(result);"

#: ../../extending/extending.rst:606
msgid ""
"Note the placement of ``Py_DECREF(arglist)`` immediately after the call, "
"before the error check!  Also note that strictly speaking this code is not "
"complete: :c:func:`Py_BuildValue` may run out of memory, and this should be "
"checked."
msgstr ""
"Observe la colocación de ``Py_DECREF(arglist)`` inmediatamente después de la "
"llamada, ¡antes de la comprobación de errores!  Observe también que, "
"estrictamente hablando, este código no está completo: :c:func:"
"`Py_BuildValue` puede quedarse sin memoria, y esto debe comprobarse."

#: ../../extending/extending.rst:610
msgid ""
"You may also call a function with keyword arguments by using :c:func:"
"`PyObject_Call`, which supports arguments and keyword arguments.  As in the "
"above example, we use :c:func:`Py_BuildValue` to construct the dictionary. ::"
msgstr ""
"También puede llamar a una función con argumentos de palabra clave "
"utilizando :c:func:`PyObject_Call`, que admite argumentos y argumentos de "
"palabra clave.  Como en el ejemplo anterior, utilizamos :c:func:"
"`Py_BuildValue` para construir el diccionario. ::"

#: ../../extending/extending.rst:614
msgid ""
"PyObject *dict;\n"
"...\n"
"dict = Py_BuildValue(\"{s:i}\", \"name\", val);\n"
"result = PyObject_Call(my_callback, NULL, dict);\n"
"Py_DECREF(dict);\n"
"if (result == NULL)\n"
"    return NULL; /* Pass error back */\n"
"/* Here maybe use the result */\n"
"Py_DECREF(result);"
msgstr ""
"PyObject *dict;\n"
"...\n"
"dict = Py_BuildValue(\"{s:i}\", \"nombre\", val);\n"
"result = PyObject_Call(my_callback, NULL, dict);\n"
"Py_DECREF(dict);\n"
"if (result == NULL)\n"
"    return NULL; /* Devuelve el error */\n"
"/* Aquí quizás usar el resultado */\n"
"Py_DECREF(result);"

#: ../../extending/extending.rst:628
msgid "Extracting Parameters in Extension Functions"
msgstr "Extracción de parámetros en funciones de ampliación"

#: ../../extending/extending.rst:632
msgid "The :c:func:`PyArg_ParseTuple` function is declared as follows::"
msgstr "La función :c:func:`PyArg_ParseTuple` se declara como sigue::"

#: ../../extending/extending.rst:634
msgid "int PyArg_ParseTuple(PyObject *arg, const char *format, ...);"
msgstr "int PyArg_ParseTuple(PyObject *arg, const char *format, ...);"

#: ../../extending/extending.rst:636
msgid ""
"The *arg* argument must be a tuple object containing an argument list passed "
"from Python to a C function.  The *format* argument must be a format string, "
"whose syntax is explained in :ref:`arg-parsing` in the Python/C API "
"Reference Manual.  The remaining arguments must be addresses of variables "
"whose type is determined by the format string."
msgstr ""
"El argumento *arg* debe ser un objeto tupla que contenga una lista de "
"argumentos pasada desde Python a una función C.  El argumento *format* debe "
"ser una cadena de formato, cuya sintaxis se explica en :ref:`arg-parsing` en "
"el Manual de Referencia de la API de Python/C.  El resto de argumentos deben "
"ser direcciones de variables cuyo tipo viene determinado por la cadena de "
"formato."

#: ../../extending/extending.rst:642
msgid ""
"Note that while :c:func:`PyArg_ParseTuple` checks that the Python arguments "
"have the required types, it cannot check the validity of the addresses of C "
"variables passed to the call: if you make mistakes there, your code will "
"probably crash or at least overwrite random bits in memory.  So be careful!"
msgstr ""
"Ten en cuenta que mientras :c:func:`PyArg_ParseTuple` comprueba que los "
"argumentos de Python tienen los tipos requeridos, no puede comprobar la "
"validez de las direcciones de las variables C pasadas a la llamada: si "
"cometes errores ahí, tu código probablemente se bloqueará o al menos "
"sobrescribirá bits aleatorios en memoria.  Así que ¡Cuidado!"

#: ../../extending/extending.rst:647
msgid ""
"Note that any Python object references which are provided to the caller are "
"*borrowed* references; do not decrement their reference count!"
msgstr ""
"Tenga en cuenta que todas las referencias de objetos de Python que se "
"proporcionan al solicitante son referencias *prestadas*; ¡no reduzca su "
"número de referencia!"

#: ../../extending/extending.rst:650
msgid "Some example calls::"
msgstr "Algunas llamadas de ejemplo::"

#: ../../extending/extending.rst:652
msgid ""
"#define PY_SSIZE_T_CLEAN  /* Make \"s#\" use Py_ssize_t rather than int. */\n"
"#include <Python.h>"
msgstr ""
"#define PY_SSIZE_T_CLEAN  /* Make \"s#\" use Py_ssize_t rather than int. */\n"
"#include <Python.h>"

#: ../../extending/extending.rst:657
msgid ""
"int ok;\n"
"int i, j;\n"
"long k, l;\n"
"const char *s;\n"
"Py_ssize_t size;\n"
"\n"
"ok = PyArg_ParseTuple(args, \"\"); /* No arguments */\n"
"    /* Python call: f() */"
msgstr ""
"int ok;\n"
"int i, j;\n"
"long k, l;\n"
"const char *s;\n"
"Py_ssize_t size;\n"
"\n"
"ok = PyArg_ParseTuple(args, \"\"); /* Sin argumentos */\n"
"    /* Llamada Python: f() */"

#: ../../extending/extending.rst:668
msgid ""
"ok = PyArg_ParseTuple(args, \"s\", &s); /* A string */\n"
"    /* Possible Python call: f('whoops!') */"
msgstr ""
"ok = PyArg_ParseTuple(args, \"s\", &s); /* Una cadena */\n"
"    /* Posible llamada Python: f('¡vaya!') */"

#: ../../extending/extending.rst:673
msgid ""
"ok = PyArg_ParseTuple(args, \"lls\", &k, &l, &s); /* Two longs and a string "
"*/\n"
"    /* Possible Python call: f(1, 2, 'three') */"
msgstr ""
"ok = PyArg_ParseTuple(args, \"lls\", &k, &l, &s); /* Dos longs y una cadena "
"*/\n"
"    /* Posible llamada Python: f(1, 2, 'tres') */"

#: ../../extending/extending.rst:678
msgid ""
"ok = PyArg_ParseTuple(args, \"(ii)s#\", &i, &j, &s, &size);\n"
"    /* A pair of ints and a string, whose size is also returned */\n"
"    /* Possible Python call: f((1, 2), 'three') */"
msgstr ""
"ok = PyArg_ParseTuple(args, \"(ii)s#\", &i, &j, &s, &size);\n"
"    /* Un par de ints y una cadena, cuyo tamaño también se devuelve */\n"
"    /* Posible llamada Python: f((1, 2), 'three') */"

#: ../../extending/extending.rst:684
msgid ""
"{\n"
"    const char *file;\n"
"    const char *mode = \"r\";\n"
"    int bufsize = 0;\n"
"    ok = PyArg_ParseTuple(args, \"s|si\", &file, &mode, &bufsize);\n"
"    /* A string, and optionally another string and an integer */\n"
"    /* Possible Python calls:\n"
"       f('spam')\n"
"       f('spam', 'w')\n"
"       f('spam', 'wb', 100000) */\n"
"}"
msgstr ""
"{\n"
"    const char *archivo;\n"
"    const char *mode = \"r\";\n"
"    int bufsize = 0;\n"
"    ok = PyArg_ParseTuple(args, \"s|si\", &file, &mode, &bufsize);\n"
"    /* Una cadena, y opcionalmente otra cadena y un entero */\n"
"    /* Posibles llamadas en Python:\n"
"       f('spam')\n"
"       f('spam', 'w')\n"
"       f('spam', 'wb', 100000) */\n"
"}"

#: ../../extending/extending.rst:698
msgid ""
"{\n"
"    int left, top, right, bottom, h, v;\n"
"    ok = PyArg_ParseTuple(args, \"((ii)(ii))(ii)\",\n"
"             &left, &top, &right, &bottom, &h, &v);\n"
"    /* A rectangle and a point */\n"
"    /* Possible Python call:\n"
"       f(((0, 0), (400, 300)), (10, 10)) */\n"
"}"
msgstr ""
"{\n"
"    int left, top, right, bottom, h, v;\n"
"    ok = PyArg_ParseTuple(args, \"((ii)(ii))(ii)\",\n"
"             &left, &top, &right, &bottom, &h, &v);\n"
"    /* Un rectángulo y un punto */\n"
"    /* Posible llamada Python:\n"
"       f(((0, 0), (400, 300)), (10, 10)) */\n"
"}"

#: ../../extending/extending.rst:709
msgid ""
"{\n"
"    Py_complex c;\n"
"    ok = PyArg_ParseTuple(args, \"D:myfunction\", &c);\n"
"    /* a complex, also providing a function name for errors */\n"
"    /* Possible Python call: myfunction(1+2j) */\n"
"}"
msgstr ""
"{\n"
"    Py_complejo c;\n"
"    ok = PyArg_ParseTuple(args, \"D:mifunción\", &c);\n"
"    /* un complejo, proporcionando también un nombre de función para errores "
"*/\n"
"    /* Posible llamada Python: mifunción(1+2j) */\n"
"}"

#: ../../extending/extending.rst:720
msgid "Keyword Parameters for Extension Functions"
msgstr "Parámetros de palabras clave para funciones de ampliación"

#: ../../extending/extending.rst:724
msgid ""
"The :c:func:`PyArg_ParseTupleAndKeywords` function is declared as follows::"
msgstr ""
"La función :c:func:`PyArg_ParseTupleAndKeywords` se declara como sigue::"

#: ../../extending/extending.rst:726
msgid ""
"int PyArg_ParseTupleAndKeywords(PyObject *arg, PyObject *kwdict,\n"
"                                const char *format, char *kwlist[], ...);"
msgstr ""
"int PyArg_ParseTupleAndKeywords(PyObject *arg, PyObject *kwdict,\n"
"                                const char *format, char *kwlist[], ...);"

#: ../../extending/extending.rst:729
msgid ""
"The *arg* and *format* parameters are identical to those of the :c:func:"
"`PyArg_ParseTuple` function.  The *kwdict* parameter is the dictionary of "
"keywords received as the third parameter from the Python runtime.  The "
"*kwlist* parameter is a ``NULL``-terminated list of strings which identify "
"the parameters; the names are matched with the type information from "
"*format* from left to right.  On success, :c:func:"
"`PyArg_ParseTupleAndKeywords` returns true, otherwise it returns false and "
"raises an appropriate exception."
msgstr ""
"Los parámetros *arg* y *format* son idénticos a los de la función :c:func:"
"`PyArg_ParseTuple`.  El parámetro *kwdict* es el diccionario de palabras "
"clave recibido como tercer parámetro del tiempo de ejecución de Python.  El "
"parámetro *kwlist* es una lista terminada en ``NULL`` de cadenas que "
"identifican los parámetros; los nombres coinciden con la información de tipo "
"de *format* de izquierda a derecha.  En caso de éxito, :c:func:"
"`PyArg_ParseTupleAndKeywords` devuelve true, en caso contrario devuelve "
"false y lanza una excepción apropiada."

#: ../../extending/extending.rst:739
msgid ""
"Nested tuples cannot be parsed when using keyword arguments!  Keyword "
"parameters passed in which are not present in the *kwlist* will cause :exc:"
"`TypeError` to be raised."
msgstr ""
"Las tuplas anidadas no pueden analizarse cuando se utilizan argumentos de "
"palabras clave.  Los parámetros de palabra clave introducidos que no estén "
"presentes en la *kwlist* provocarán la aparición de :exc:`TypeError`."

#: ../../extending/extending.rst:745
msgid ""
"Here is an example module which uses keywords, based on an example by Geoff "
"Philbrick (philbrick@hks.com)::"
msgstr ""
"Aquí hay un módulo de ejemplo que utiliza palabras clave, basado en un "
"ejemplo de Geoff Philbrick (philbrick@hks.com)::"

#: ../../extending/extending.rst:748
msgid ""
"#define PY_SSIZE_T_CLEAN  /* Make \"s#\" use Py_ssize_t rather than int. */\n"
"#include <Python.h>\n"
"\n"
"static PyObject *\n"
"keywdarg_parrot(PyObject *self, PyObject *args, PyObject *keywds)\n"
"{\n"
"    int voltage;\n"
"    const char *state = \"a stiff\";\n"
"    const char *action = \"voom\";\n"
"    const char *type = \"Norwegian Blue\";\n"
"\n"
"    static char *kwlist[] = {\"voltage\", \"state\", \"action\", \"type\", "
"NULL};\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, keywds, \"i|sss\", kwlist,\n"
"                                     &voltage, &state, &action, &type))\n"
"        return NULL;\n"
"\n"
"    printf(\"-- This parrot wouldn't %s if you put %i Volts through it."
"\\n\",\n"
"           action, voltage);\n"
"    printf(\"-- Lovely plumage, the %s -- It's %s!\\n\", type, state);\n"
"\n"
"    Py_RETURN_NONE;\n"
"}\n"
"\n"
"static PyMethodDef keywdarg_methods[] = {\n"
"    /* The cast of the function is necessary since PyCFunction values\n"
"     * only take two PyObject* parameters, and keywdarg_parrot() takes\n"
"     * three.\n"
"     */\n"
"    {\"parrot\", (PyCFunction)(void(*)(void))keywdarg_parrot, METH_VARARGS | "
"METH_KEYWORDS,\n"
"     \"Print a lovely skit to standard output.\"},\n"
"    {NULL, NULL, 0, NULL}   /* sentinel */\n"
"};\n"
"\n"
"static struct PyModuleDef keywdargmodule = {\n"
"    PyModuleDef_HEAD_INIT,\n"
"    \"keywdarg\",\n"
"    NULL,\n"
"    -1,\n"
"    keywdarg_methods\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_keywdarg(void)\n"
"{\n"
"    return PyModule_Create(&keywdargmodule);\n"
"}"
msgstr ""
"#define PY_SSIZE_T_CLEAN /* Haz que \"s#\" use Py_ssize_t en lugar de int. "
"*/\n"
"#include <Python.h>\n"
"\n"
"static PyObject *\n"
"keywdarg_parrot(PyObject *self, PyObject *args, PyObject *keywds)\n"
"{\n"
"    int tensión;\n"
"    const char *state = \"a tieso\";\n"
"    const char *action = \"voom\";\n"
"    const char *type = \"azul noruego\";\n"
"\n"
"    static char *kwlist[] = {\"voltaje\", \"estado\", \"acción\", \"tipo\", "
"NULL};\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, keywds, \"i|sss\", kwlist,\n"
"                                     &voltage, &state, &action, &type))\n"
"        return NULL;\n"
"\n"
"    printf(\"-- Este loro no %s si le pones %i Voltios.\\n\",\n"
"           action, voltage);\n"
"    printf(\"-- Precioso plumaje, el %s -- Es %s!\\n\", type, state);\n"
"\n"
"    Py_RETURN_NONE;\n"
"}\n"
"\n"
"static PyMethodDef keywdarg_methods[] = {\n"
"    /* El cast de la función es necesario ya que PyCFunction values\n"
"     * sólo toman dos parámetros PyObject*, y keywdarg_parrot() toma\n"
"     * tres.\n"
"     */\n"
"    {\"parrot\", (PyCFunction)(void(*)(void))keywdarg_parrot, METH_VARARGS | "
"METH_KEYWORDS,\n"
"     \"Imprime una sátira adorable en la salida estándar.\"},\n"
"    {NULL, NULL, 0, NULL}   /* centinela */\n"
"};\n"
"\n"
"static struct PyModuleDef keywdargmodule = {\n"
"    PyModuleDef_HEAD_INIT,\n"
"    \"keywdarg\n"
"    NULL\n"
"    -1,\n"
"    keywdarg_methods\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_keywdarg(void)\n"
"{\n"
"    return PyModule_Create(&keywdargmodule);\n"
"}"

#: ../../extending/extending.rst:800
msgid "Building Arbitrary Values"
msgstr "Construyendo valores arbitrarios"

#: ../../extending/extending.rst:802
msgid ""
"This function is the counterpart to :c:func:`PyArg_ParseTuple`.  It is "
"declared as follows::"
msgstr ""
"Esta función es el contraparte de :c:func:`PyArg_ParseTuple`. Se declara de "
"la siguiente manera:"

#: ../../extending/extending.rst:805
msgid "PyObject *Py_BuildValue(const char *format, ...);"
msgstr "PyObject *Py_BuildValue(const char *format, ...);"

#: ../../extending/extending.rst:807
msgid ""
"It recognizes a set of format units similar to the ones recognized by :c:"
"func:`PyArg_ParseTuple`, but the arguments (which are input to the function, "
"not output) must not be pointers, just values.  It returns a new Python "
"object, suitable for returning from a C function called from Python."
msgstr ""
"Reconoce un conjunto de unidades de formato similares a las reconocidas por :"
"c:func:`PyArg_ParseTuple`, pero los argumentos (que son de entrada a la "
"función, no de salida) no deben ser punteros, solo valores. Devuelve un "
"nuevo objeto de Python, adecuado para ser devuelto desde una función C "
"llamada desde Python."

#: ../../extending/extending.rst:812
msgid ""
"One difference with :c:func:`PyArg_ParseTuple`: while the latter requires "
"its first argument to be a tuple (since Python argument lists are always "
"represented as tuples internally), :c:func:`Py_BuildValue` does not always "
"build a tuple.  It builds a tuple only if its format string contains two or "
"more format units. If the format string is empty, it returns ``None``; if it "
"contains exactly one format unit, it returns whatever object is described by "
"that format unit.  To force it to return a tuple of size 0 or one, "
"parenthesize the format string."
msgstr ""
"Una diferencia con :c:func:`PyArg_ParseTuple`: mientras que este último "
"requiere que su primer argumento sea una tupla (ya que las listas de "
"argumentos de Python siempre se representan internamente como tuplas), :c:"
"func:`Py_BuildValue` no siempre construye una tupla.  Sólo construye una "
"tupla si su cadena de formato contiene dos o más unidades de formato. Si la "
"cadena de formato está vacía, devuelve ``None``; si contiene exactamente una "
"unidad de formato, devuelve cualquier objeto descrito por esa unidad de "
"formato.  Para forzarla a devolver una tupla de tamaño 0 o uno, ponga entre "
"paréntesis la cadena de formato."

#: ../../extending/extending.rst:820
msgid ""
"Examples (to the left the call, to the right the resulting Python value):"
msgstr ""
"Ejemplos (a la izquierda la llamada, a la derecha el valor resultante en "
"Python):"

#: ../../extending/extending.rst:822
msgid ""
"Py_BuildValue(\"\")                        None\n"
"Py_BuildValue(\"i\", 123)                  123\n"
"Py_BuildValue(\"iii\", 123, 456, 789)      (123, 456, 789)\n"
"Py_BuildValue(\"s\", \"hello\")              'hello'\n"
"Py_BuildValue(\"y\", \"hello\")              b'hello'\n"
"Py_BuildValue(\"ss\", \"hello\", \"world\")    ('hello', 'world')\n"
"Py_BuildValue(\"s#\", \"hello\", 4)          'hell'\n"
"Py_BuildValue(\"y#\", \"hello\", 4)          b'hell'\n"
"Py_BuildValue(\"()\")                      ()\n"
"Py_BuildValue(\"(i)\", 123)                (123,)\n"
"Py_BuildValue(\"(ii)\", 123, 456)          (123, 456)\n"
"Py_BuildValue(\"(i,i)\", 123, 456)         (123, 456)\n"
"Py_BuildValue(\"[i,i]\", 123, 456)         [123, 456]\n"
"Py_BuildValue(\"{s:i,s:i}\",\n"
"              \"abc\", 123, \"def\", 456)    {'abc': 123, 'def': 456}\n"
"Py_BuildValue(\"((ii)(ii)) (ii)\",\n"
"              1, 2, 3, 4, 5, 6)          (((1, 2), (3, 4)), (5, 6))"
msgstr ""
"Py_BuildValue(\"\")                        None\n"
"Py_BuildValue(\"i\", 123)                  123\n"
"Py_BuildValue(\"iii\", 123, 456, 789)      (123, 456, 789)\n"
"Py_BuildValue(\"s\", \"hello\")              'hello'\n"
"Py_BuildValue(\"y\", \"hello\")              b'hello'\n"
"Py_BuildValue(\"ss\", \"hello\", \"world\")    ('hello', 'world')\n"
"Py_BuildValue(\"s#\", \"hello\", 4)          'hell'\n"
"Py_BuildValue(\"y#\", \"hello\", 4)          b'hell'\n"
"Py_BuildValue(\"()\")                      ()\n"
"Py_BuildValue(\"(i)\", 123)                (123,)\n"
"Py_BuildValue(\"(ii)\", 123, 456)          (123, 456)\n"
"Py_BuildValue(\"(i,i)\", 123, 456)         (123, 456)\n"
"Py_BuildValue(\"[i,i]\", 123, 456)         [123, 456]\n"
"Py_BuildValue(\"{s:i,s:i}\",\n"
"              \"abc\", 123, \"def\", 456)    {'abc': 123, 'def': 456}\n"
"Py_BuildValue(\"((ii)(ii)) (ii)\",\n"
"              1, 2, 3, 4, 5, 6)          (((1, 2), (3, 4)), (5, 6))"

#: ../../extending/extending.rst:846
msgid "Reference Counts"
msgstr "Recuentos de referencia"

#: ../../extending/extending.rst:848
msgid ""
"In languages like C or C++, the programmer is responsible for dynamic "
"allocation and deallocation of memory on the heap.  In C, this is done using "
"the functions :c:func:`malloc` and :c:func:`free`.  In C++, the operators "
"``new`` and ``delete`` are used with essentially the same meaning and we'll "
"restrict the following discussion to the C case."
msgstr ""
"En lenguajes como C o C++, el programador es responsable de la asignación y "
"liberación dinámica de memoria en el montón. En C, esto se hace utilizando "
"las funciones :c:func:`malloc` y :c:func:`free`. En C++, los operadores "
"``new`` y ``delete`` se utilizan con un significado esencialmente igual y "
"limitaremos la siguiente discusión al caso de C."

#: ../../extending/extending.rst:854
msgid ""
"Every block of memory allocated with :c:func:`malloc` should eventually be "
"returned to the pool of available memory by exactly one call to :c:func:"
"`free`. It is important to call :c:func:`free` at the right time.  If a "
"block's address is forgotten but :c:func:`free` is not called for it, the "
"memory it occupies cannot be reused until the program terminates.  This is "
"called a :dfn:`memory leak`.  On the other hand, if a program calls :c:func:"
"`free` for a block and then continues to use the block, it creates a "
"conflict with reuse of the block through another :c:func:`malloc` call.  "
"This is called :dfn:`using freed memory`. It has the same bad consequences "
"as referencing uninitialized data --- core dumps, wrong results, mysterious "
"crashes."
msgstr ""
"Cada bloque de memoria asignado con :c:func:`malloc` debe ser devuelto "
"eventualmente al pool de memoria disponible mediante exactamente una llamada "
"a :c:func:`free`. Es importante llamar a :c:func:`free` en el momento "
"adecuado.  Si se olvida la dirección de un bloque pero no se llama a :c:func:"
"`free`, la memoria que ocupa no podrá reutilizarse hasta que el programa "
"termine.  Esto se denomina una fuga de memoria.  Por otro lado, si un "
"programa llama a :c:func:`free` para un bloque y luego continúa utilizando "
"el bloque, se crea un conflicto con la reutilización del bloque a través de "
"otra llamada a :c:func:`malloc`.  Esto se denomina :dfn:`utilización de "
"memoria liberada`. Tiene las mismas consecuencias negativas que referenciar "
"datos no inicializados: volcados del núcleo, resultados erróneos, fallos "
"misteriosos."

#: ../../extending/extending.rst:865
msgid ""
"Common causes of memory leaks are unusual paths through the code.  For "
"instance, a function may allocate a block of memory, do some calculation, "
"and then free the block again.  Now a change in the requirements for the "
"function may add a test to the calculation that detects an error condition "
"and can return prematurely from the function.  It's easy to forget to free "
"the allocated memory block when taking this premature exit, especially when "
"it is added later to the code.  Such leaks, once introduced, often go "
"undetected for a long time: the error exit is taken only in a small fraction "
"of all calls, and most modern machines have plenty of virtual memory, so the "
"leak only becomes apparent in a long-running process that uses the leaking "
"function frequently.  Therefore, it's important to prevent leaks from "
"happening by having a coding convention or strategy that minimizes this kind "
"of errors."
msgstr ""
"Las causas comunes de las fugas de memoria son los caminos inusuales a "
"través del código. Por ejemplo, una función puede asignar un bloque de "
"memoria, hacer algunos cálculos y luego liberar el bloque nuevamente. Ahora, "
"un cambio en los requisitos de la función puede agregar una prueba al "
"cálculo que detecta una condición de error y puede retornar prematuramente "
"de la función. Es fácil olvidar liberar el bloque de memoria asignado al "
"tomar esta salida prematura, especialmente cuando se agrega más tarde al "
"código. Tales fugas, una vez introducidas, a menudo pasan desapercibidas "
"durante mucho tiempo: la salida de error solo se produce en una pequeña "
"fracción de todas las llamadas, y la mayoría de las máquinas modernas tienen "
"mucha memoria virtual, por lo que la fuga solo se hace evidente en un "
"proceso de larga duración que utiliza la función con fugas con frecuencia. "
"Por lo tanto, es importante prevenir las fugas evitando que ocurran mediante "
"una convención de codificación o estrategia que minimice este tipo de "
"errores."

#: ../../extending/extending.rst:878
msgid ""
"Since Python makes heavy use of :c:func:`malloc` and :c:func:`free`, it "
"needs a strategy to avoid memory leaks as well as the use of freed memory.  "
"The chosen method is called :dfn:`reference counting`.  The principle is "
"simple: every object contains a counter, which is incremented when a "
"reference to the object is stored somewhere, and which is decremented when a "
"reference to it is deleted. When the counter reaches zero, the last "
"reference to the object has been deleted and the object is freed."
msgstr ""
"Dado que Python hace un uso intensivo de :c:func:`malloc` y :c:func:`free`, "
"necesita una estrategia para evitar fugas de memoria, así como el uso de "
"memoria liberada. El método elegido se llama :dfn:`reference counting`. El "
"principio es simple: cada objeto contiene un contador, que se incrementa "
"cuando se almacena una referencia al objeto en algún lugar, y que se "
"decrementa cuando se elimina una referencia a él. Cuando el contador llega a "
"cero, se ha eliminado la última referencia al objeto y se libera el objeto."

#: ../../extending/extending.rst:886
msgid ""
"An alternative strategy is called :dfn:`automatic garbage collection`. "
"(Sometimes, reference counting is also referred to as a garbage collection "
"strategy, hence my use of \"automatic\" to distinguish the two.)  The big "
"advantage of automatic garbage collection is that the user doesn't need to "
"call :c:func:`free` explicitly.  (Another claimed advantage is an "
"improvement in speed or memory usage --- this is no hard fact however.)  The "
"disadvantage is that for C, there is no truly portable automatic garbage "
"collector, while reference counting can be implemented portably (as long as "
"the functions :c:func:`malloc` and :c:func:`free` are available --- which "
"the C Standard guarantees). Maybe some day a sufficiently portable automatic "
"garbage collector will be available for C. Until then, we'll have to live "
"with reference counts."
msgstr ""
"Una estrategia alternativa se llama :dfn:`recolección automática de basura`. "
"(A veces, el recuento de referencias también se denomina estrategia de "
"recolección de basura, de ahí mi uso de \"automático\" para distinguir los "
"dos). La gran ventaja de la recolección automática de basura es que el "
"usuario no necesita llamar explícitamente a :c:func:`free`. (Otra ventaja "
"afirmada es una mejora en la velocidad o el uso de memoria, aunque esto no "
"es un hecho comprobado). La desventaja es que para C, no hay un recolector "
"de basura automático verdaderamente portátil, mientras que el recuento de "
"referencias se puede implementar de forma portátil (siempre que las "
"funciones :c:func:`malloc` y :c:func:`free` estén disponibles, lo cual "
"garantiza el estándar de C). Tal vez algún día esté disponible un recolector "
"de basura automático suficientemente portátil para C. Hasta entonces, "
"tendremos que conformarnos con los recuentos de referencias."

#: ../../extending/extending.rst:898
msgid ""
"While Python uses the traditional reference counting implementation, it also "
"offers a cycle detector that works to detect reference cycles.  This allows "
"applications to not worry about creating direct or indirect circular "
"references; these are the weakness of garbage collection implemented using "
"only reference counting.  Reference cycles consist of objects which contain "
"(possibly indirect) references to themselves, so that each object in the "
"cycle has a reference count which is non-zero.  Typical reference counting "
"implementations are not able to reclaim the memory belonging to any objects "
"in a reference cycle, or referenced from the objects in the cycle, even "
"though there are no further references to the cycle itself."
msgstr ""
"Mientras Python utiliza la implementación tradicional de conteo de "
"referencias, también ofrece un detector de ciclos que funciona para detectar "
"ciclos de referencias. Esto permite que las aplicaciones no se preocupen por "
"crear referencias circulares directas o indirectas; estas son la debilidad "
"de la recolección de basura implementada solo con conteo de referencias. Los "
"ciclos de referencia consisten en objetos que contienen referencias "
"(posiblemente indirectas) a sí mismos, de modo que cada objeto en el ciclo "
"tiene un recuento de referencias que no es cero. Las implementaciones "
"típicas de conteo de referencias no pueden recuperar la memoria "
"perteneciente a ningún objeto en un ciclo de referencia, o referenciada "
"desde los objetos en el ciclo, aunque no haya más referencias al ciclo en sí."

#: ../../extending/extending.rst:909
msgid ""
"The cycle detector is able to detect garbage cycles and can reclaim them. "
"The :mod:`gc` module exposes a way to run the detector (the :func:`~gc."
"collect` function), as well as configuration interfaces and the ability to "
"disable the detector at runtime."
msgstr ""
"El detector de ciclos es capaz de detectar ciclos basura y recuperarlos. El "
"módulo :mod:`gc` expone una forma de ejecutar el detector (la función :func:"
"`~gc.collect` ), así como interfaces de configuración y la posibilidad de "
"desactivar el detector en tiempo de ejecución."

#: ../../extending/extending.rst:918
msgid "Reference Counting in Python"
msgstr "Recuento de referencias en Python"

#: ../../extending/extending.rst:920
msgid ""
"There are two macros, ``Py_INCREF(x)`` and ``Py_DECREF(x)``, which handle "
"the incrementing and decrementing of the reference count. :c:func:"
"`Py_DECREF` also frees the object when the count reaches zero. For "
"flexibility, it doesn't call :c:func:`free` directly --- rather, it makes a "
"call through a function pointer in the object's :dfn:`type object`.  For "
"this purpose (and others), every object also contains a pointer to its type "
"object."
msgstr ""
"Hay dos macros, ``Py_INCREF(x)`` y ``Py_DECREF(x)``, que manejan el "
"incremento y decremento de la cuenta de referencias. :c:func:`Py_DECREF` "
"también libera el objeto cuando la cuenta llega a cero. Para mayor "
"flexibilidad, no llama directamente a :c:func:`free`, sino que lo hace a "
"través de un puntero de función en el :dfn:`type object` del objeto.  Para "
"este propósito (y otros), cada objeto también contiene un puntero a su "
"objeto de tipo."

#: ../../extending/extending.rst:927
msgid ""
"The big question now remains: when to use ``Py_INCREF(x)`` and "
"``Py_DECREF(x)``? Let's first introduce some terms.  Nobody \"owns\" an "
"object; however, you can :dfn:`own a reference` to an object.  An object's "
"reference count is now defined as the number of owned references to it.  The "
"owner of a reference is responsible for calling :c:func:`Py_DECREF` when the "
"reference is no longer needed.  Ownership of a reference can be "
"transferred.  There are three ways to dispose of an owned reference: pass it "
"on, store it, or call :c:func:`Py_DECREF`. Forgetting to dispose of an owned "
"reference creates a memory leak."
msgstr ""
"La gran pregunta sigue siendo: ¿cuándo utilizar ``Py_INCREF(x)`` y "
"``Py_DECREF(x)``? Introduzcamos primero algunos términos.  Nadie \"posee\" "
"un objeto; sin embargo, puedes :dfn:`poseer una referencia` a un objeto.  El "
"recuento de referencias de un objeto se define ahora como el número de "
"referencias propias a él.  El propietario de una referencia es responsable "
"de llamar a :c:func:`Py_DECREF` cuando la referencia ya no sea necesaria.  "
"La propiedad de una referencia puede transferirse.  Hay tres formas de "
"deshacerse de una referencia propia: transferirla, almacenarla o llamar a :c:"
"func:`Py_DECREF`. Olvidar deshacerse de una referencia propia crea una fuga "
"de memoria."

#: ../../extending/extending.rst:936
msgid ""
"It is also possible to :dfn:`borrow` [#]_ a reference to an object.  The "
"borrower of a reference should not call :c:func:`Py_DECREF`.  The borrower "
"must not hold on to the object longer than the owner from which it was "
"borrowed. Using a borrowed reference after the owner has disposed of it "
"risks using freed memory and should be avoided completely [#]_."
msgstr ""
"También es posible :dfn:`prestar` [#]_ una referencia a un objeto.  El "
"prestatario de una referencia no debe llamar a :c:func:`Py_DECREF`.  El "
"prestatario no debe retener el objeto más tiempo que el propietario del que "
"lo tomó prestado. Usar una referencia prestada después de que el propietario "
"se haya deshecho de ella conlleva el riesgo de usar memoria liberada y debe "
"evitarse completamente [#]_."

#: ../../extending/extending.rst:942
msgid ""
"The advantage of borrowing over owning a reference is that you don't need to "
"take care of disposing of the reference on all possible paths through the "
"code --- in other words, with a borrowed reference you don't run the risk of "
"leaking when a premature exit is taken.  The disadvantage of borrowing over "
"owning is that there are some subtle situations where in seemingly correct "
"code a borrowed reference can be used after the owner from which it was "
"borrowed has in fact disposed of it."
msgstr ""
"La ventaja de tomar prestada una referencia frente a poseerla es que no es "
"necesario ocuparse de deshacerse de la referencia en todos los caminos "
"posibles a través del código --- en otras palabras, con una referencia "
"prestada no se corre el riesgo de fugas cuando se toma una salida "
"prematura.  La desventaja de pedir prestado sobre poseer es que hay algunas "
"situaciones sutiles en las que en código aparentemente correcto una "
"referencia prestada puede ser usada después de que el propietario del que "
"fue prestada se haya deshecho de ella."

#: ../../extending/extending.rst:950
msgid ""
"A borrowed reference can be changed into an owned reference by calling :c:"
"func:`Py_INCREF`.  This does not affect the status of the owner from which "
"the reference was borrowed --- it creates a new owned reference, and gives "
"full owner responsibilities (the new owner must dispose of the reference "
"properly, as well as the previous owner)."
msgstr ""
"Una referencia prestada puede convertirse en una referencia propia llamando "
"a :c:func:`Py_INCREF`.  Esto no afecta al estado del propietario del que se "
"tomó prestada la referencia, sino que crea una nueva referencia propia y le "
"otorga plenas responsabilidades (el nuevo propietario debe deshacerse de la "
"referencia correctamente, al igual que el propietario anterior)."

#: ../../extending/extending.rst:960
msgid "Ownership Rules"
msgstr "Normas de propiedad"

#: ../../extending/extending.rst:962
msgid ""
"Whenever an object reference is passed into or out of a function, it is part "
"of the function's interface specification whether ownership is transferred "
"with the reference or not."
msgstr ""
"Siempre que se pase una referencia de objeto dentro o fuera de una función, "
"forma parte de la especificación de la interfaz de la función si la "
"propiedad se transfiere con la referencia o no."

#: ../../extending/extending.rst:966
msgid ""
"Most functions that return a reference to an object pass on ownership with "
"the reference.  In particular, all functions whose function it is to create "
"a new object, such as :c:func:`PyLong_FromLong` and :c:func:`Py_BuildValue`, "
"pass ownership to the receiver.  Even if the object is not actually new, you "
"still receive ownership of a new reference to that object.  For instance, :c:"
"func:`PyLong_FromLong` maintains a cache of popular values and can return a "
"reference to a cached item."
msgstr ""
"La mayoría de las funciones que devuelven una referencia a un objeto pasan "
"la propiedad con la referencia.  En particular, todas las funciones cuya "
"función es crear un nuevo objeto, como :c:func:`PyLong_FromLong` y :c:func:"
"`Py_BuildValue`, pasan la propiedad al receptor.  Incluso si el objeto no es "
"realmente nuevo, sigues recibiendo la propiedad de una nueva referencia a "
"ese objeto.  Por ejemplo, :c:func:`PyLong_FromLong` mantiene una caché de "
"valores populares y puede devolver una referencia a un elemento almacenado "
"en caché."

#: ../../extending/extending.rst:974
msgid ""
"Many functions that extract objects from other objects also transfer "
"ownership with the reference, for instance :c:func:"
"`PyObject_GetAttrString`.  The picture is less clear, here, however, since a "
"few common routines are exceptions: :c:func:`PyTuple_GetItem`, :c:func:"
"`PyList_GetItem`, :c:func:`PyDict_GetItem`, and :c:func:"
"`PyDict_GetItemString` all return references that you borrow from the tuple, "
"list or dictionary."
msgstr ""
"Muchas funciones que extraen objetos de otros objetos también transfieren la "
"propiedad con la referencia, por ejemplo :c:func:`PyObject_GetAttrString`.  "
"Sin embargo, aquí el panorama es menos claro, ya que algunas rutinas comunes "
"son excepciones: :c:func:`PyTuple_GetItem`, :c:func:`PyList_GetItem`, :c:"
"func:`PyDict_GetItem`, y :c:func:`PyDict_GetItemString` todas devuelven "
"referencias que se toman prestadas de la tupla, lista o diccionario."

#: ../../extending/extending.rst:981
msgid ""
"The function :c:func:`PyImport_AddModule` also returns a borrowed reference, "
"even though it may actually create the object it returns: this is possible "
"because an owned reference to the object is stored in ``sys.modules``."
msgstr ""
"La función :c:func:`PyImport_AddModule` también devuelve una referencia "
"prestada, aunque en realidad puede crear el objeto que devuelve: esto es "
"posible porque en ``sys.modules`` se almacena una referencia propia al "
"objeto."

#: ../../extending/extending.rst:985
msgid ""
"When you pass an object reference into another function, in general, the "
"function borrows the reference from you --- if it needs to store it, it will "
"use :c:func:`Py_INCREF` to become an independent owner.  There are exactly "
"two important exceptions to this rule: :c:func:`PyTuple_SetItem` and :c:func:"
"`PyList_SetItem`.  These functions take over ownership of the item passed to "
"them --- even if they fail!  (Note that :c:func:`PyDict_SetItem` and friends "
"don't take over ownership --- they are \"normal.\")"
msgstr ""
"Cuando pasas una referencia de objeto a otra función, en general, la función "
"toma prestada la referencia de ti --- si necesita almacenarla, utilizará :c:"
"func:`Py_INCREF` para convertirse en propietario independiente.  Hay "
"exactamente dos excepciones importantes a esta regla: :c:func:"
"`PyTuple_SetItem` y :c:func:`PyList_SetItem`.  Estas funciones asumen la "
"propiedad del elemento que se les pasa, ¡incluso si fallan!  (Tenga en "
"cuenta que :c:func:`PyDict_SetItem` y sus amigos no asumen la propiedad --- "
"son \"normales\")."

#: ../../extending/extending.rst:993
msgid ""
"When a C function is called from Python, it borrows references to its "
"arguments from the caller.  The caller owns a reference to the object, so "
"the borrowed reference's lifetime is guaranteed until the function returns.  "
"Only when such a borrowed reference must be stored or passed on, it must be "
"turned into an owned reference by calling :c:func:`Py_INCREF`."
msgstr ""
"Cuando se llama a una función C desde Python, ésta toma prestadas del "
"llamante las referencias a sus argumentos.  El invocador posee una "
"referencia al objeto, por lo que el tiempo de vida de la referencia prestada "
"está garantizado hasta que la función retorna.  Sólo cuando una referencia "
"prestada se deba almacenar o transferir, se debe convertir en una referencia "
"propia llamando a :c:func:`Py_INCREF`."

#: ../../extending/extending.rst:999
msgid ""
"The object reference returned from a C function that is called from Python "
"must be an owned reference --- ownership is transferred from the function to "
"its caller."
msgstr ""
"La referencia al objeto devuelta desde una función C que es llamada desde "
"Python debe ser una referencia de propiedad: la propiedad se transfiere "
"desde la función a su llamador."

#: ../../extending/extending.rst:1007
msgid "Thin Ice"
msgstr "Hielo fino"

#: ../../extending/extending.rst:1009
msgid ""
"There are a few situations where seemingly harmless use of a borrowed "
"reference can lead to problems.  These all have to do with implicit "
"invocations of the interpreter, which can cause the owner of a reference to "
"dispose of it."
msgstr ""
"Hay algunas situaciones en las que el uso aparentemente inofensivo de una "
"referencia prestada puede llevar a problemas. Todas estas tienen que ver con "
"invocaciones implícitas del intérprete, que pueden hacer que el propietario "
"de una referencia la deseche."

#: ../../extending/extending.rst:1013
msgid ""
"The first and most important case to know about is using :c:func:`Py_DECREF` "
"on an unrelated object while borrowing a reference to a list item.  For "
"instance::"
msgstr ""
"El primer caso, y el más importante, es utilizar :c:func:`Py_DECREF` en un "
"objeto no relacionado mientras se toma prestada una referencia a un elemento "
"de la lista.  Por ejemplo::"

#: ../../extending/extending.rst:1016
msgid ""
"void\n"
"bug(PyObject *list)\n"
"{\n"
"    PyObject *item = PyList_GetItem(list, 0);\n"
"\n"
"    PyList_SetItem(list, 1, PyLong_FromLong(0L));\n"
"    PyObject_Print(item, stdout, 0); /* BUG! */\n"
"}"
msgstr ""
"void\n"
"bug(PyObject *list)\n"
"{\n"
"    PyObject *item = PyList_GetItem(lista, 0);\n"
"\n"
"    PyList_SetItem(lista, 1, PyLong_FromLong(0L));\n"
"    PyObject_Print(item, stdout, 0); /* ¡BUG! */\n"
"}"

#: ../../extending/extending.rst:1025
msgid ""
"This function first borrows a reference to ``list[0]``, then replaces "
"``list[1]`` with the value ``0``, and finally prints the borrowed reference. "
"Looks harmless, right?  But it's not!"
msgstr ""
"Esta función primero toma prestada una referencia a ``list[0]``, luego "
"reemplaza ``list[1]`` con el valor ``0``, y finalmente imprime la referencia "
"prestada. ¿Parece inofensivo, verdad? ¡Pero no lo es!"

#: ../../extending/extending.rst:1029
msgid ""
"Let's follow the control flow into :c:func:`PyList_SetItem`.  The list owns "
"references to all its items, so when item 1 is replaced, it has to dispose "
"of the original item 1.  Now let's suppose the original item 1 was an "
"instance of a user-defined class, and let's further suppose that the class "
"defined a :meth:`!__del__` method.  If this class instance has a reference "
"count of 1, disposing of it will call its :meth:`!__del__` method."
msgstr ""
"Sigamos el flujo de control en :c:func:`PyList_SetItem`.  La lista posee "
"referencias a todos sus elementos, así que cuando el elemento 1 es "
"reemplazado, tiene que deshacerse del elemento 1 original.  Ahora supongamos "
"que el elemento original 1 era una instancia de una clase definida por el "
"usuario, y supongamos además que la clase definió un método :meth:`!"
"__del__`.  Si esta instancia de clase tiene un número de referencia de 1, al "
"eliminarla se llamará a su método :meth:`!__del__`."

#: ../../extending/extending.rst:1036
msgid ""
"Since it is written in Python, the :meth:`!__del__` method can execute "
"arbitrary Python code.  Could it perhaps do something to invalidate the "
"reference to ``item`` in :c:func:`!bug`?  You bet!  Assuming that the list "
"passed into :c:func:`!bug` is accessible to the :meth:`!__del__` method, it "
"could execute a statement to the effect of ``del list[0]``, and assuming "
"this was the last reference to that object, it would free the memory "
"associated with it, thereby invalidating ``item``."
msgstr ""
"Dado que está escrito en Python, el método :meth:`!__del__` puede ejecutar "
"código Python arbitrario.  ¿Podría quizás hacer algo para invalidar la "
"referencia a ``item`` en :c:func:`!bug`?  Por supuesto.  Asumiendo que la "
"lista pasada a :c:func:`!bug` es accesible al método :meth:`!__del__`, éste "
"podría ejecutar una sentencia con el efecto de ``del list[0]``, y asumiendo "
"que ésta fuera la última referencia a ese objeto, liberaría la memoria "
"asociada a él, invalidando así ``item``."

#: ../../extending/extending.rst:1044
msgid ""
"The solution, once you know the source of the problem, is easy: temporarily "
"increment the reference count.  The correct version of the function reads::"
msgstr ""
"La solución, una vez conocido el origen del problema, es fácil: incrementar "
"temporalmente el recuento de referencias.  La versión correcta de la función "
"es::"

#: ../../extending/extending.rst:1047
msgid ""
"void\n"
"no_bug(PyObject *list)\n"
"{\n"
"    PyObject *item = PyList_GetItem(list, 0);\n"
"\n"
"    Py_INCREF(item);\n"
"    PyList_SetItem(list, 1, PyLong_FromLong(0L));\n"
"    PyObject_Print(item, stdout, 0);\n"
"    Py_DECREF(item);\n"
"}"
msgstr ""
"void\n"
"no_bug(PyObject *list)\n"
"{\n"
"    PyObject *item = PyList_GetItem(lista, 0);\n"
"\n"
"    Py_INCREF(item);\n"
"    PyList_SetItem(lista, 1, PyLong_FromLong(0L));\n"
"    PyObject_Print(item, stdout, 0);\n"
"    Py_DECREF(item);\n"
"}"

#: ../../extending/extending.rst:1058
msgid ""
"This is a true story.  An older version of Python contained variants of this "
"bug and someone spent a considerable amount of time in a C debugger to "
"figure out why his :meth:`!__del__` methods would fail..."
msgstr ""
"Esta es una historia real.  Una versión anterior de Python contenía "
"variantes de este error y alguien pasó una cantidad considerable de tiempo "
"en un depurador de C para averiguar por qué sus métodos :meth:`!__del__` "
"fallaban...."

#: ../../extending/extending.rst:1062
msgid ""
"The second case of problems with a borrowed reference is a variant involving "
"threads.  Normally, multiple threads in the Python interpreter can't get in "
"each other's way, because there is a global lock protecting Python's entire "
"object space.  However, it is possible to temporarily release this lock "
"using the macro :c:macro:`Py_BEGIN_ALLOW_THREADS`, and to re-acquire it "
"using :c:macro:`Py_END_ALLOW_THREADS`.  This is common around blocking I/O "
"calls, to let other threads use the processor while waiting for the I/O to "
"complete. Obviously, the following function has the same problem as the "
"previous one::"
msgstr ""
"El segundo caso de problemas con una referencia prestada es una variante que "
"involucra hilos.  Normalmente, múltiples hilos en el intérprete de Python no "
"pueden interponerse unos en el camino de otros, porque hay un bloqueo global "
"que protege todo el espacio de objetos de Python.  Sin embargo, es posible "
"liberar temporalmente este bloqueo usando la macro :c:macro:"
"`Py_BEGIN_ALLOW_THREADS`, y recuperarlo usando :c:macro:"
"`Py_END_ALLOW_THREADS`.  Esto es común en llamadas de E/S bloqueantes, para "
"permitir que otros hilos utilicen el procesador mientras esperan a que la E/"
"S se complete. Obviamente, la siguiente función tiene el mismo problema que "
"la anterior::"

#: ../../extending/extending.rst:1071
msgid ""
"void\n"
"bug(PyObject *list)\n"
"{\n"
"    PyObject *item = PyList_GetItem(list, 0);\n"
"    Py_BEGIN_ALLOW_THREADS\n"
"    ...some blocking I/O call...\n"
"    Py_END_ALLOW_THREADS\n"
"    PyObject_Print(item, stdout, 0); /* BUG! */\n"
"}"
msgstr ""
"void\n"
"bug(PyObject *list)\n"
"{\n"
"    PyObject *item = PyList_GetItem(lista, 0);\n"
"    Py_BEGIN_ALLOW_THREADS\n"
"    ...alguna llamada de E/S bloqueante...\n"
"    Py_END_ALLOW_THREADS\n"
"    PyObject_Print(item, stdout, 0); /* ¡BUG! */\n"
"}"

#: ../../extending/extending.rst:1085
msgid "NULL Pointers"
msgstr "Punteros NULL"

#: ../../extending/extending.rst:1087
msgid ""
"In general, functions that take object references as arguments do not expect "
"you to pass them ``NULL`` pointers, and will dump core (or cause later core "
"dumps) if you do so.  Functions that return object references generally "
"return ``NULL`` only to indicate that an exception occurred.  The reason for "
"not testing for ``NULL`` arguments is that functions often pass the objects "
"they receive on to other function --- if each function were to test for "
"``NULL``, there would be a lot of redundant tests and the code would run "
"more slowly."
msgstr ""
"En general, las funciones que toman referencias a objetos como argumentos no "
"esperan que les pases punteros ``NULL``, y volcarán el núcleo (o provocarán "
"volcados posteriores del núcleo) si lo haces.  Las funciones que devuelven "
"referencias a objetos generalmente devuelven ``NULL`` sólo para indicar que "
"se ha producido una excepción.  La razón para no comprobar los argumentos "
"``NULL`` es que las funciones a menudo pasan los objetos que reciben a otras "
"funciones --- si cada función tuviera que comprobar ``NULL``, habría muchas "
"pruebas redundantes y el código se ejecutaría más lentamente."

#: ../../extending/extending.rst:1095
msgid ""
"It is better to test for ``NULL`` only at the \"source:\" when a pointer "
"that may be ``NULL`` is received, for example, from :c:func:`malloc` or from "
"a function that may raise an exception."
msgstr ""
"Es mejor probar ``NULL`` solo en el \"source:\" cuando se recibe un puntero "
"que puede ser ``NULL``, por ejemplo, desde :c:func:`malloc` o desde una "
"función que puede generar una excepción."

#: ../../extending/extending.rst:1099
msgid ""
"The macros :c:func:`Py_INCREF` and :c:func:`Py_DECREF` do not check for "
"``NULL`` pointers --- however, their variants :c:func:`Py_XINCREF` and :c:"
"func:`Py_XDECREF` do."
msgstr ""
"Los macros :c:func:`Py_INCREF` y :c:func:`Py_DECREF` no comprueban los "
"punteros ``NULL`` --- sin embargo, sus variantes :c:func:`Py_XINCREF` y :c:"
"func:`Py_XDECREF` sí lo hacen."

#: ../../extending/extending.rst:1103
msgid ""
"The macros for checking for a particular object type (``Pytype_Check()``) "
"don't check for ``NULL`` pointers --- again, there is much code that calls "
"several of these in a row to test an object against various different "
"expected types, and this would generate redundant tests.  There are no "
"variants with ``NULL`` checking."
msgstr ""
"Los macros para comprobar un tipo de objeto en particular "
"(``Pytype_Check()``) no comprueban los punteros ``NULL`` --- de nuevo, hay "
"mucho código que llama a varios de estos macros seguidos para probar un "
"objeto contra varios tipos esperados diferentes, y esto generaría pruebas "
"redundantes. No hay variantes con comprobación de ``NULL``."

#: ../../extending/extending.rst:1109
msgid ""
"The C function calling mechanism guarantees that the argument list passed to "
"C functions (``args`` in the examples) is never ``NULL`` --- in fact it "
"guarantees that it is always a tuple [#]_."
msgstr ""
"El mecanismo de llamada de funciones en C garantiza que la lista de "
"argumentos pasada a las funciones de C (``args`` en los ejemplos) nunca es "
"``NULL`` --- de hecho, garantiza que siempre es una tupla [#]_."

#: ../../extending/extending.rst:1113
msgid ""
"It is a severe error to ever let a ``NULL`` pointer \"escape\" to the Python "
"user."
msgstr ""
"Es un grave error dejar que un puntero ``NULL`` \"escape\" al usuario de "
"Python."

#: ../../extending/extending.rst:1124
msgid "Writing Extensions in C++"
msgstr "Extensiones en C"

#: ../../extending/extending.rst:1126
msgid ""
"It is possible to write extension modules in C++.  Some restrictions apply.  "
"If the main program (the Python interpreter) is compiled and linked by the C "
"compiler, global or static objects with constructors cannot be used.  This "
"is not a problem if the main program is linked by the C++ compiler.  "
"Functions that will be called by the Python interpreter (in particular, "
"module initialization functions) have to be declared using ``extern \"C\"``. "
"It is unnecessary to enclose the Python header files in ``extern \"C\" {...}"
"`` --- they use this form already if the symbol ``__cplusplus`` is defined "
"(all recent C++ compilers define this symbol)."
msgstr ""
"Es posible escribir módulos de ampliación en C++.  Se aplican algunas "
"restricciones.  Si el programa principal (el intérprete de Python) está "
"compilado y enlazado por el compilador de C, no se pueden usar objetos "
"globales o estáticos con constructores.  Esto no es un problema si el "
"programa principal está enlazado por el compilador de C++.  Las funciones "
"que serán llamadas por el intérprete de Python (en particular, las funciones "
"de inicialización de módulos) tienen que ser declaradas usando ``extern "
"\"C\"``. No es necesario encerrar los ficheros de cabecera de Python en "
"``extern \"C\" {...}`` --- ya utilizan esta forma si el símbolo "
"``__cplusplus`` está definido (todos los compiladores C++ recientes definen "
"este símbolo)."

#: ../../extending/extending.rst:1140
msgid "Providing a C API for an Extension Module"
msgstr "Proporcionar una API en C para un módulo de ampliación"

#: ../../extending/extending.rst:1145
msgid ""
"Many extension modules just provide new functions and types to be used from "
"Python, but sometimes the code in an extension module can be useful for "
"other extension modules. For example, an extension module could implement a "
"type \"collection\" which works like lists without order. Just like the "
"standard Python list type has a C API which permits extension modules to "
"create and manipulate lists, this new collection type should have a set of C "
"functions for direct manipulation from other extension modules."
msgstr ""
"Muchos módulos de extensión simplemente proporcionan nuevas funciones y "
"tipos que se pueden utilizar desde Python, pero a veces el código en un "
"módulo de extensión puede ser útil para otros módulos de extensión. Por "
"ejemplo, un módulo de extensión podría implementar un tipo \"colección\" que "
"funcione como listas sin orden. Al igual que el tipo de lista estándar de "
"Python tiene una API en C que permite a los módulos de extensión crear y "
"manipular listas, este nuevo tipo de colección debería tener un conjunto de "
"funciones en C para la manipulación directa desde otros módulos de extensión."

#: ../../extending/extending.rst:1153
msgid ""
"At first sight this seems easy: just write the functions (without declaring "
"them ``static``, of course), provide an appropriate header file, and "
"document the C API. And in fact this would work if all extension modules "
"were always linked statically with the Python interpreter. When modules are "
"used as shared libraries, however, the symbols defined in one module may not "
"be visible to another module. The details of visibility depend on the "
"operating system; some systems use one global namespace for the Python "
"interpreter and all extension modules (Windows, for example), whereas others "
"require an explicit list of imported symbols at module link time (AIX is one "
"example), or offer a choice of different strategies (most Unices). And even "
"if symbols are globally visible, the module whose functions one wishes to "
"call might not have been loaded yet!"
msgstr ""
"A primera vista esto parece fácil: basta con escribir las funciones (sin "
"declararlas ``static``, por supuesto), proporcionar un fichero de cabecera "
"apropiado, y documentar la API C. Y de hecho esto funcionaría si todos los "
"módulos de extensión estuvieran siempre enlazados estáticamente con el "
"intérprete de Python. Sin embargo, cuando los módulos se usan como "
"bibliotecas compartidas, los símbolos definidos en un módulo pueden no ser "
"visibles para otro módulo. Los detalles de la visibilidad dependen del "
"sistema operativo; algunos sistemas usan un espacio de nombres global para "
"el intérprete de Python y todos los módulos de extensión (Windows, por "
"ejemplo), mientras que otros requieren una lista explícita de símbolos "
"importados en el momento de enlazar el módulo (AIX es un ejemplo), u ofrecen "
"una selección de diferentes estrategias (la mayoría de los Unices). E "
"incluso si los símbolos son visibles globalmente, el módulo cuyas funciones "
"uno desea llamar puede no haber sido cargado todavía."

#: ../../extending/extending.rst:1165
msgid ""
"Portability therefore requires not to make any assumptions about symbol "
"visibility. This means that all symbols in extension modules should be "
"declared ``static``, except for the module's initialization function, in "
"order to avoid name clashes with other extension modules (as discussed in "
"section :ref:`methodtable`). And it means that symbols that *should* be "
"accessible from other extension modules must be exported in a different way."
msgstr ""
"Por lo tanto, la portabilidad requiere no hacer ninguna suposición sobre la "
"visibilidad de los símbolos. Esto significa que todos los símbolos en los "
"módulos de extensión deben ser declarados ``static``, excepto la función de "
"inicialización del módulo, para evitar conflictos de nombres con otros "
"módulos de extensión (como se discute en la sección :ref:`methodtable`). Y "
"significa que los símbolos que *deberían* ser accesibles desde otros módulos "
"de extensión deben ser exportados de una manera diferente."

#: ../../extending/extending.rst:1172
msgid ""
"Python provides a special mechanism to pass C-level information (pointers) "
"from one extension module to another one: Capsules. A Capsule is a Python "
"data type which stores a pointer (:c:expr:`void \\*`).  Capsules can only be "
"created and accessed via their C API, but they can be passed around like any "
"other Python object. In particular,  they can be assigned to a name in an "
"extension module's namespace. Other extension modules can then import this "
"module, retrieve the value of this name, and then retrieve the pointer from "
"the Capsule."
msgstr ""
"Python proporciona un mecanismo especial para pasar información de nivel C "
"(punteros) de un módulo de extensión a otro: Cápsulas. Una Cápsula es un "
"tipo de datos de Python que almacena un puntero (:c:expr:`void \\*`).  Las "
"cápsulas sólo pueden crearse y accederse a través de su API en C, pero "
"pueden pasarse como cualquier otro objeto de Python. En particular, se les "
"puede asignar un nombre en el espacio de nombres de un módulo de extensión. "
"Otros módulos de extensión pueden entonces importar este módulo, recuperar "
"el valor de este nombre, y luego recuperar el puntero de la Cápsula."

#: ../../extending/extending.rst:1180
msgid ""
"There are many ways in which Capsules can be used to export the C API of an "
"extension module. Each function could get its own Capsule, or all C API "
"pointers could be stored in an array whose address is published in a "
"Capsule. And the various tasks of storing and retrieving the pointers can be "
"distributed in different ways between the module providing the code and the "
"client modules."
msgstr ""
"Hay muchas formas en las que las Cápsulas se pueden utilizar para exportar "
"la API C de un módulo de extensión. Cada función podría tener su propia "
"Cápsula, o todos los punteros de la API C podrían ser almacenados en un "
"array cuya dirección se publica en una Cápsula. Y las diversas tareas de "
"almacenar y recuperar los punteros pueden ser distribuidas de diferentes "
"formas entre el módulo que proporciona el código y los módulos del cliente."

#: ../../extending/extending.rst:1186
msgid ""
"Whichever method you choose, it's important to name your Capsules properly. "
"The function :c:func:`PyCapsule_New` takes a name parameter (:c:expr:`const "
"char \\*`); you're permitted to pass in a ``NULL`` name, but we strongly "
"encourage you to specify a name.  Properly named Capsules provide a degree "
"of runtime type-safety; there is no feasible way to tell one unnamed Capsule "
"from another."
msgstr ""
"Sea cual sea el método que elija, es importante que asigne un nombre "
"adecuado a sus cápsulas. La función :c:func:`PyCapsule_New` recibe un "
"parámetro de nombre (:c:expr:`const char \\*`); puede pasar un nombre de "
"``NULL``, pero le recomendamos encarecidamente que especifique un nombre.  "
"Las Cápsulas correctamente nombradas proporcionan un grado de seguridad de "
"tipo en tiempo de ejecución; no hay forma factible de distinguir una Cápsula "
"sin nombre de otra."

#: ../../extending/extending.rst:1193
msgid ""
"In particular, Capsules used to expose C APIs should be given a name "
"following this convention::"
msgstr ""
"En particular, las cápsulas utilizadas para exponer APIs C deben recibir un "
"nombre siguiendo esta convención:"

#: ../../extending/extending.rst:1196
msgid "modulename.attributename"
msgstr "modulename.attributename"

#: ../../extending/extending.rst:1198
msgid ""
"The convenience function :c:func:`PyCapsule_Import` makes it easy to load a "
"C API provided via a Capsule, but only if the Capsule's name matches this "
"convention.  This behavior gives C API users a high degree of certainty that "
"the Capsule they load contains the correct C API."
msgstr ""
"La función :c:func:`PyCapsule_Import` facilita la carga de una API de C "
"proporcionada a través de una cápsula, pero sólo si el nombre de la cápsula "
"coincide con esta convención.  Este comportamiento ofrece a los usuarios de "
"la API de C un alto grado de certeza de que la Cápsula que cargan contiene "
"la API de C correcta."

#: ../../extending/extending.rst:1203
msgid ""
"The following example demonstrates an approach that puts most of the burden "
"on the writer of the exporting module, which is appropriate for commonly "
"used library modules. It stores all C API pointers (just one in the "
"example!) in an array of :c:expr:`void` pointers which becomes the value of "
"a Capsule. The header file corresponding to the module provides a macro that "
"takes care of importing the module and retrieving its C API pointers; client "
"modules only have to call this macro before accessing the C API."
msgstr ""
"El siguiente ejemplo demuestra un enfoque que pone la mayor parte de la "
"carga en el escritor del módulo exportador, lo cual es apropiado para "
"módulos de biblioteca de uso común. Almacena todos los punteros de la API de "
"C (¡sólo uno en el ejemplo!) en una matriz de punteros :c:expr:`void` que se "
"convierte en el valor de una Cápsula. El fichero de cabecera correspondiente "
"al módulo proporciona una macro que se encarga de importar el módulo y "
"recuperar sus punteros a la API en C; los módulos cliente sólo tienen que "
"llamar a esta macro antes de acceder a la API en C."

#: ../../extending/extending.rst:1211
msgid ""
"The exporting module is a modification of the :mod:`!spam` module from "
"section :ref:`extending-simpleexample`. The function :func:`!spam.system` "
"does not call the C library function :c:func:`system` directly, but a "
"function :c:func:`!PySpam_System`, which would of course do something more "
"complicated in reality (such as adding \"spam\" to every command). This "
"function :c:func:`!PySpam_System` is also exported to other extension "
"modules."
msgstr ""
"El módulo exportador es una modificación del módulo :mod:`!spam` de la "
"sección :ref:`extending-simpleexample`. La función :func:`!spam.system` no "
"llama directamente a la función de la biblioteca C :c:func:`system`, sino a "
"una función :c:func:`!PySpam_System`, que por supuesto haría algo más "
"complicado en realidad (como añadir \"spam\" a cada comando). Esta función :"
"c:func:`!PySpam_System` también se exporta a otros módulos de extensión."

#: ../../extending/extending.rst:1218
msgid ""
"The function :c:func:`!PySpam_System` is a plain C function, declared "
"``static`` like everything else::"
msgstr ""
"La función :c:func:`!PySpam_System` es una función C simple, declarada "
"``static`` como todo lo demás::"

#: ../../extending/extending.rst:1221
msgid ""
"static int\n"
"PySpam_System(const char *command)\n"
"{\n"
"    return system(command);\n"
"}"
msgstr ""
"static int\n"
"PySpam_System(const char *command)\n"
"{\n"
"    return system(command);\n"
"}"

#: ../../extending/extending.rst:1227
msgid "The function :c:func:`!spam_system` is modified in a trivial way::"
msgstr "La función :c:func:`!spam_system` se modifica de forma trivial::"

#: ../../extending/extending.rst:1229
msgid ""
"static PyObject *\n"
"spam_system(PyObject *self, PyObject *args)\n"
"{\n"
"    const char *command;\n"
"    int sts;\n"
"\n"
"    if (!PyArg_ParseTuple(args, \"s\", &command))\n"
"        return NULL;\n"
"    sts = PySpam_System(command);\n"
"    return PyLong_FromLong(sts);\n"
"}"
msgstr ""
"static PyObject *\n"
"spam_system(PyObject *self, PyObject *args)\n"
"{\n"
"    const char *command;\n"
"    int sts;\n"
"\n"
"    if (!PyArg_ParseTuple(args, \"s\", &command))\n"
"        return NULL;\n"
"    sts = PySpam_System(command);\n"
"    return PyLong_FromLong(sts);\n"
"}"

#: ../../extending/extending.rst:1241
msgid "In the beginning of the module, right after the line ::"
msgstr "Al principio del módulo, justo después de la línea ::"

#: ../../extending/extending.rst:1243
msgid "#include <Python.h>"
msgstr "#include <Python.h>"

#: ../../extending/extending.rst:1245
msgid "two more lines must be added::"
msgstr "hay que añadir dos líneas más::"

#: ../../extending/extending.rst:1247
msgid ""
"#define SPAM_MODULE\n"
"#include \"spammodule.h\""
msgstr ""
"#define SPAM_MODULE\n"
"#include \"spammodule.h\""

#: ../../extending/extending.rst:1250
msgid ""
"The ``#define`` is used to tell the header file that it is being included in "
"the exporting module, not a client module. Finally, the module's "
"initialization function must take care of initializing the C API pointer "
"array::"
msgstr ""
"El ``#define`` se utiliza para indicar al archivo de cabecera que se está "
"incluyendo en el módulo exportador, no en un módulo cliente. Por último, la "
"función de inicialización del módulo debe encargarse de inicializar la "
"matriz de punteros de la API de C::"

#: ../../extending/extending.rst:1254
msgid ""
"PyMODINIT_FUNC\n"
"PyInit_spam(void)\n"
"{\n"
"    PyObject *m;\n"
"    static void *PySpam_API[PySpam_API_pointers];\n"
"    PyObject *c_api_object;\n"
"\n"
"    m = PyModule_Create(&spammodule);\n"
"    if (m == NULL)\n"
"        return NULL;\n"
"\n"
"    /* Initialize the C API pointer array */\n"
"    PySpam_API[PySpam_System_NUM] = (void *)PySpam_System;\n"
"\n"
"    /* Create a Capsule containing the API pointer array's address */\n"
"    c_api_object = PyCapsule_New((void *)PySpam_API, \"spam._C_API\", "
"NULL);\n"
"\n"
"    if (PyModule_AddObject(m, \"_C_API\", c_api_object) < 0) {\n"
"        Py_XDECREF(c_api_object);\n"
"        Py_DECREF(m);\n"
"        return NULL;\n"
"    }\n"
"\n"
"    return m;\n"
"}"
msgstr ""
"PyMODINIT_FUNC\n"
"PyInit_spam(void)\n"
"{\n"
"    PyObject *m;\n"
"    static void *PySpam_API[PySpam_API_pointers];\n"
"    PyObject *c_api_object;\n"
"\n"
"    m = PyModule_Create(&spammodule);\n"
"    if (m == NULL)\n"
"        return NULL;\n"
"\n"
"    /* Initialize the C API pointer array */\n"
"    PySpam_API[PySpam_System_NUM] = (void *)PySpam_System;\n"
"\n"
"    /* Create a Capsule containing the API pointer array's address */\n"
"    c_api_object = PyCapsule_New((void *)PySpam_API, \"spam._C_API\", "
"NULL);\n"
"\n"
"    if (PyModule_AddObject(m, \"_C_API\", c_api_object) < 0) {\n"
"        Py_XDECREF(c_api_object);\n"
"        Py_DECREF(m);\n"
"        return NULL;\n"
"    }\n"
"\n"
"    return m;\n"
"}"

#: ../../extending/extending.rst:1280
msgid ""
"Note that ``PySpam_API`` is declared ``static``; otherwise the pointer array "
"would disappear when :c:func:`!PyInit_spam` terminates!"
msgstr ""
"Tenga en cuenta que ``PySpam_API`` se declara ``static``; ¡de lo contrario "
"la matriz de punteros desaparecería cuando :c:func:`!PyInit_spam` terminara!"

#: ../../extending/extending.rst:1283
msgid ""
"The bulk of the work is in the header file :file:`spammodule.h`, which looks "
"like this::"
msgstr ""
"La mayor parte del trabajo se encuentra en el archivo de cabecera :file:"
"`spammodule.h`, que tiene el siguiente aspecto::"

#: ../../extending/extending.rst:1286
msgid ""
"#ifndef Py_SPAMMODULE_H\n"
"#define Py_SPAMMODULE_H\n"
"#ifdef __cplusplus\n"
"extern \"C\" {\n"
"#endif\n"
"\n"
"/* Header file for spammodule */\n"
"\n"
"/* C API functions */\n"
"#define PySpam_System_NUM 0\n"
"#define PySpam_System_RETURN int\n"
"#define PySpam_System_PROTO (const char *command)\n"
"\n"
"/* Total number of C API pointers */\n"
"#define PySpam_API_pointers 1\n"
"\n"
"\n"
"#ifdef SPAM_MODULE\n"
"/* This section is used when compiling spammodule.c */\n"
"\n"
"static PySpam_System_RETURN PySpam_System PySpam_System_PROTO;\n"
"\n"
"#else\n"
"/* This section is used in modules that use spammodule's API */\n"
"\n"
"static void **PySpam_API;\n"
"\n"
"#define PySpam_System \\\n"
" (*(PySpam_System_RETURN (*)PySpam_System_PROTO) "
"PySpam_API[PySpam_System_NUM])\n"
"\n"
"/* Return -1 on error, 0 on success.\n"
" * PyCapsule_Import will set an exception if there's an error.\n"
" */\n"
"static int\n"
"import_spam(void)\n"
"{\n"
"    PySpam_API = (void **)PyCapsule_Import(\"spam._C_API\", 0);\n"
"    return (PySpam_API != NULL) ? 0 : -1;\n"
"}\n"
"\n"
"#endif\n"
"\n"
"#ifdef __cplusplus\n"
"}\n"
"#endif\n"
"\n"
"#endif /* !defined(Py_SPAMMODULE_H) */"
msgstr ""
"#ifndef Py_SPAMMODULE_H\n"
"#define Py_SPAMMODULE_H\n"
"#ifdef __cplusplus\n"
"extern \"C\" {\n"
"#endif\n"
"\n"
"/* Fichero de cabecera para spammodule */\n"
"\n"
"/* Funciones API en C */\n"
"#define PySpam_System_NUM 0\n"
"#define PySpam_System_RETURN int\n"
"#define PySpam_System_PROTO (const char *command)\n"
"\n"
"/* Número total de punteros API C */\n"
"#define PySpam_API_pointers 1\n"
"\n"
"\n"
"#ifdef SPAM_MODULE\n"
"/* Esta sección se usa al compilar spammodule.c */\n"
"\n"
"static PySpam_System_RETURN PySpam_System PySpam_System_PROTO;\n"
"\n"
"#else\n"
"/* Esta sección se usa en módulos que usan la API de spammodule */\n"
"\n"
"static void **PySpam_API;\n"
"\n"
"#define PySpam_System \\\n"
" (*(PySpam_System_RETURN (*)PySpam_System_PROTO) "
"PySpam_API[PySpam_System_NUM])\n"
"\n"
"/* Devuelve -1 en caso de error, 0 en caso de éxito.\n"
" * PyCapsule_Import lanzará una excepción si hay un error.\n"
" */\n"
"static int\n"
"import_spam(void)\n"
"{\n"
"    PySpam_API = (void **)PyCapsule_Import(\"spam._C_API\", 0);\n"
"    return (PySpam_API != NULL) ? 0 : -1;\n"
"}\n"
"\n"
"#endif\n"
"\n"
"#ifdef __cplusplus\n"
"}\n"
"#endif\n"
"\n"
"#endif /* !defined(Py_SPAMMODULE_H) */"

#: ../../extending/extending.rst:1334
msgid ""
"All that a client module must do in order to have access to the function :c:"
"func:`!PySpam_System` is to call the function (or rather macro) :c:func:`!"
"import_spam` in its initialization function::"
msgstr ""
"Todo lo que un módulo cliente debe hacer para tener acceso a la función :c:"
"func:`!PySpam_System` es llamar a la función (o más bien macro) :c:func:`!"
"import_spam` en su función de inicialización::"

#: ../../extending/extending.rst:1338
msgid ""
"PyMODINIT_FUNC\n"
"PyInit_client(void)\n"
"{\n"
"    PyObject *m;\n"
"\n"
"    m = PyModule_Create(&clientmodule);\n"
"    if (m == NULL)\n"
"        return NULL;\n"
"    if (import_spam() < 0)\n"
"        return NULL;\n"
"    /* additional initialization can happen here */\n"
"    return m;\n"
"}"
msgstr ""
"PyMODINIT_FUNC\n"
"PyInit_client(void)\n"
"{\n"
"    PyObject *m;\n"
"\n"
"    m = PyModule_Create(&clientmodule);\n"
"    if (m == NULL)\n"
"        devuelve NULL;\n"
"    if (import_spam() < 0)\n"
"        return NULL;\n"
"    /* inicialización adicional puede ocurrir aquí */\n"
"    return m;\n"
"}"

#: ../../extending/extending.rst:1352
msgid ""
"The main disadvantage of this approach is that the file :file:`spammodule.h` "
"is rather complicated. However, the basic structure is the same for each "
"function that is exported, so it has to be learned only once."
msgstr ""
"La principal desventaja de este enfoque es que el archivo :file:`spammodule."
"h` es bastante complicado. Sin embargo, la estructura básica es la misma "
"para cada función que se exporta, por lo que sólo hay que aprenderla una vez."

#: ../../extending/extending.rst:1356
msgid ""
"Finally it should be mentioned that Capsules offer additional functionality, "
"which is especially useful for memory allocation and deallocation of the "
"pointer stored in a Capsule. The details are described in the Python/C API "
"Reference Manual in the section :ref:`capsules` and in the implementation of "
"Capsules (files :file:`Include/pycapsule.h` and :file:`Objects/pycapsule.c` "
"in the Python source code distribution)."
msgstr ""
"Por último, cabe mencionar que las Cápsulas ofrecen una funcionalidad "
"adicional, especialmente útil para la asignación y desasignación de memoria "
"del puntero almacenado en una Cápsula. Los detalles se describen en el "
"Manual de Referencia de la API de Python/C en la sección :ref:`capsules` y "
"en la implementación de Cápsulas (archivos :file:`Include/pycapsule.h` y :"
"file:`Objects/pycapsule.c` en la distribución del código fuente de Python)."

#: ../../extending/extending.rst:1364
msgid "Footnotes"
msgstr "Notas a pie de página"

#: ../../extending/extending.rst:1365
msgid ""
"An interface for this function already exists in the standard module :mod:"
"`os` --- it was chosen as a simple and straightforward example."
msgstr ""
"Ya existe una interfaz para esta función en el módulo estándar :mod:`os` --- "
"se eligió como ejemplo simple y directo."

#: ../../extending/extending.rst:1368
msgid ""
"The metaphor of \"borrowing\" a reference is not completely correct: the "
"owner still has a copy of the reference."
msgstr ""
"La metáfora de \"tomar prestada\" una referencia no es del todo correcta: el "
"propietario sigue teniendo una copia de la referencia."

#: ../../extending/extending.rst:1371
msgid ""
"Checking that the reference count is at least 1 **does not work** --- the "
"reference count itself could be in freed memory and may thus be reused for "
"another object!"
msgstr ""
"Comprobando que el recuento de referencias sea al menos 1 **no funciona** "
"--- ¡el recuento de referencias en sí podría estar en memoria liberada y, "
"por lo tanto, podría reutilizarse para otro objeto!"

#: ../../extending/extending.rst:1375
msgid ""
"These guarantees don't hold when you use the \"old\" style calling "
"convention --- this is still found in much existing code."
msgstr ""
"Estas garantías no se mantienen cuando se utiliza la convención de llamada "
"\"antigua\" --- esto todavía se encuentra en gran parte del código existente."

#: ../../extending/extending.rst:539
msgid "PyObject_CallObject (C function)"
msgstr "PyObject_CallObject (función C)"

#: ../../extending/extending.rst:630
msgid "PyArg_ParseTuple (C function)"
msgstr "PyArg_ParseTuple (función C)"

#: ../../extending/extending.rst:722
msgid "PyArg_ParseTupleAndKeywords (C function)"
msgstr "PyArg_ParseTupleAndKeywords (función C)"

#: ../../extending/extending.rst:743
msgid "Philbrick, Geoff"
msgstr "Philbrick, Geoff"
