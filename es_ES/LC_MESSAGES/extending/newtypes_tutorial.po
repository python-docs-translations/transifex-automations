# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# eulalio barbero espinosa <eulalio@disroot.org>, 2024
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-10 16:06+0000\n"
"PO-Revision-Date: 2022-11-05 17:21+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Spanish (Spain) (https://app.transifex.com/python-doc/"
"teams/5390/es_ES/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es_ES\n"
"Plural-Forms: nplurals=3; plural=n == 1 ? 0 : n != 0 && n % 1000000 == 0 ? "
"1 : 2;\n"

#: ../../extending/newtypes_tutorial.rst:7
msgid "Defining Extension Types: Tutorial"
msgstr "Definición de tipos de extensión: Tutorial"

#: ../../extending/newtypes_tutorial.rst:14
msgid ""
"Python allows the writer of a C extension module to define new types that "
"can be manipulated from Python code, much like the built-in :class:`str` "
"and :class:`list` types.  The code for all extension types follows a "
"pattern, but there are some details that you need to understand before you "
"can get started.  This document is a gentle introduction to the topic."
msgstr ""
"Python permite al escritor de un módulo de extensión C definir nuevos tipos "
"que pueden ser manipulados desde el código Python, de forma similar a los "
"tipos incorporados :class:`str` y :class:`list`.  El código para todos los "
"tipos de extensión sigue un patrón, pero hay algunos detalles que necesitas "
"entender antes de empezar.  Este documento es una ligera introducción al "
"tema."

#: ../../extending/newtypes_tutorial.rst:24
msgid "The Basics"
msgstr "Los fundamentos"

#: ../../extending/newtypes_tutorial.rst:26
msgid ""
"The :term:`CPython` runtime sees all Python objects as variables of type :c:"
"expr:`PyObject*`, which serves as a \"base type\" for all Python objects. "
"The :c:type:`PyObject` structure itself only contains the object's :term:"
"`reference count` and a pointer to the object's \"type object\". This is "
"where the action is; the type object determines which (C) functions get "
"called by the interpreter when, for instance, an attribute gets looked up on "
"an object, a method called, or it is multiplied by another object.  These C "
"functions are called \"type methods\"."
msgstr ""
"El tiempo de ejecución :term:`CPython` ve todos los objetos Python como "
"variables de tipo :c:expr:`PyObject*`, que sirve como \"base type\" para "
"todos los objetos Python. La propia estructura :c:type:`PyObject` sólo "
"contiene el :term:`reference count` del objeto y un puntero al \"type "
"object\" del objeto. Aquí es donde está la acción; el objeto de tipo "
"determina qué funciones (C) son llamadas por el intérprete cuando, por "
"ejemplo, se busca un atributo en un objeto, se llama a un método, o se "
"multiplica por otro objeto.  Estas funciones C se denominan \"type methods\"."

#: ../../extending/newtypes_tutorial.rst:35
msgid ""
"So, if you want to define a new extension type, you need to create a new "
"type object."
msgstr ""
"Entonces, si quieres definir un nuevo tipo de extensión, necesitas crear un "
"nuevo objeto de tipo."

#: ../../extending/newtypes_tutorial.rst:38
msgid ""
"This sort of thing can only be explained by example, so here's a minimal, "
"but complete, module that defines a new type named :class:`Custom` inside a "
"C extension module :mod:`custom`:"
msgstr ""
"Este tipo de cosas sólo se pueden explicar con ejemplos, así que aquí tienes "
"un módulo mínimo, pero completo, que define un nuevo tipo llamado :class:"
"`Custom` dentro de un módulo de extensión C :mod:`custom`:"

#: ../../extending/newtypes_tutorial.rst:43
msgid ""
"What we're showing here is the traditional way of defining *static* "
"extension types.  It should be adequate for most uses.  The C API also "
"allows defining heap-allocated extension types using the :c:func:"
"`PyType_FromSpec` function, which isn't covered in this tutorial."
msgstr ""
"Lo que estamos mostrando aquí es la forma tradicional de definir tipos de "
"extensión *estáticos*. Debería ser adecuado para la mayoría de los usos. La "
"API de C también permite definir tipos de extensión asignados en el montón "
"utilizando la función :c:func:`PyType_FromSpec`, que no se cubre en este "
"tutorial."

#: ../../extending/newtypes_tutorial.rst:50
msgid ""
"Now that's quite a bit to take in at once, but hopefully bits will seem "
"familiar from the previous chapter.  This file defines three things:"
msgstr ""
"Ahora eso es bastante para asimilar de una vez, pero esperemos que algunas "
"partes te resulten familiares del capítulo anterior. Este archivo define "
"tres cosas:"

#: ../../extending/newtypes_tutorial.rst:53
msgid ""
"What a :class:`Custom` **object** contains: this is the ``CustomObject`` "
"struct, which is allocated once for each :class:`Custom` instance."
msgstr ""
"Qué contiene un **object** :class:`Custom`: esto es la estructura "
"``CustomObject``, que se asigna una vez para cada instancia de :class:"
"`Custom`."

#: ../../extending/newtypes_tutorial.rst:55
msgid ""
"How the :class:`Custom` **type** behaves: this is the ``CustomType`` struct, "
"which defines a set of flags and function pointers that the interpreter "
"inspects when specific operations are requested."
msgstr ""
"Cómo se comporta el **type** :class:`Custom`: se trata de la estructura "
"``CustomType``, que define un conjunto de banderas y punteros de función que "
"el intérprete inspecciona cuando se solicitan operaciones específicas."

#: ../../extending/newtypes_tutorial.rst:58
msgid ""
"How to initialize the :mod:`custom` module: this is the ``PyInit_custom`` "
"function and the associated ``custommodule`` struct."
msgstr ""
"Cómo inicializar el módulo :mod:`custom`: se trata de la función "
"``PyInit_custom`` y la estructura asociada ``custommodule``."

#: ../../extending/newtypes_tutorial.rst:61
msgid "The first bit is::"
msgstr "La primera parte es::"

#: ../../extending/newtypes_tutorial.rst:67
msgid ""
"This is what a Custom object will contain.  ``PyObject_HEAD`` is mandatory "
"at the start of each object struct and defines a field called ``ob_base`` of "
"type :c:type:`PyObject`, containing a pointer to a type object and a "
"reference count (these can be accessed using the macros :c:macro:`Py_TYPE` "
"and :c:macro:`Py_REFCNT` respectively).  The reason for the macro is to "
"abstract away the layout and to enable additional fields in :ref:`debug "
"builds <debug-build>`."
msgstr ""
"Esto es lo que contendrá un objeto personalizado. ``PyObject_HEAD`` es "
"obligatorio al principio de cada estructura de objeto y define un campo "
"llamado ``ob_base`` de tipo :c:type:`PyObject`, que contiene un puntero a un "
"objeto de tipo y un recuento de referencias (se puede acceder a ellos "
"utilizando las macros :c:macro:`Py_TYPE` y :c:macro:`Py_REFCNT` "
"respectivamente).  La razón de la macro es abstraer el diseño y habilitar "
"campos adicionales en :ref:`debug builds <debug-build>`."

#: ../../extending/newtypes_tutorial.rst:76
msgid ""
"There is no semicolon above after the :c:macro:`PyObject_HEAD` macro. Be "
"wary of adding one by accident: some compilers will complain."
msgstr ""
"No hay punto y coma encima después de la macro :c:macro:`PyObject_HEAD`. Ten "
"cuidado de añadir uno por accidente: algunos compiladores se quejarán."

#: ../../extending/newtypes_tutorial.rst:79
msgid ""
"Of course, objects generally store additional data besides the standard "
"``PyObject_HEAD`` boilerplate; for example, here is the definition for "
"standard Python floats::"
msgstr ""
"Por supuesto, los objetos generalmente almacenan datos adicionales además "
"del estándar ``PyObject_HEAD`` boilerplate; por ejemplo, aquí está la "
"definición para los flotadores estándar de Python::"

#: ../../extending/newtypes_tutorial.rst:88
msgid "The second bit is the definition of the type object. ::"
msgstr "El segundo bit es la definición del tipo objeto. ::"

#: ../../extending/newtypes_tutorial.rst:101
msgid ""
"We recommend using C99-style designated initializers as above, to avoid "
"listing all the :c:type:`PyTypeObject` fields that you don't care about and "
"also to avoid caring about the fields' declaration order."
msgstr ""
"Recomendamos utilizar inicializadores designados al estilo de C99, para "
"evitar listar todos los campos de :c:type:`PyTypeObject` que no le interesan "
"y también para evitar preocuparse por el orden de declaración de los campos."

#: ../../extending/newtypes_tutorial.rst:105
msgid ""
"The actual definition of :c:type:`PyTypeObject` in :file:`object.h` has many "
"more :ref:`fields <type-structs>` than the definition above.  The remaining "
"fields will be filled with zeros by the C compiler, and it's common practice "
"to not specify them explicitly unless you need them."
msgstr ""
"La definición real de :c:type:`PyTypeObject` en :file:`object.h` tiene "
"muchos más campos :ref:` <type-structs>` que la definición anterior.  Los "
"campos restantes serán rellenados con ceros por el compilador de C, y es una "
"práctica común no especificarlos explícitamente a menos que los necesite."

#: ../../extending/newtypes_tutorial.rst:110
msgid "We're going to pick it apart, one field at a time::"
msgstr "Vamos a desmontarlo, campo por campo::"

#: ../../extending/newtypes_tutorial.rst:114
msgid ""
"This line is mandatory boilerplate to initialize the ``ob_base`` field "
"mentioned above. ::"
msgstr ""
"Esta línea es obligatoria para inicializar el campo ``ob_base`` mencionado "
"anteriormente. ::"

#: ../../extending/newtypes_tutorial.rst:119
msgid ""
"The name of our type.  This will appear in the default textual "
"representation of our objects and in some error messages, for example:"
msgstr ""
"El nombre de nuestro tipo.  Aparecerá en la representación textual por "
"defecto de nuestros objetos y en algunos mensajes de error, por ejemplo:"

#: ../../extending/newtypes_tutorial.rst:129
msgid ""
"Note that the name is a dotted name that includes both the module name and "
"the name of the type within the module. The module in this case is :mod:"
"`custom` and the type is :class:`Custom`, so we set the type name to :class:"
"`custom.Custom`. Using the real dotted import path is important to make your "
"type compatible with the :mod:`pydoc` and :mod:`pickle` modules. ::"
msgstr ""
"Tenga en cuenta que el nombre es un nombre con puntos que incluye tanto el "
"nombre del módulo como el nombre del tipo dentro del módulo. En este caso, "
"el módulo es :mod:`custom` y el tipo es :class:`Custom`, por lo que el "
"nombre del tipo es :class:`custom.Custom`. Es importante utilizar la ruta de "
"importación real con puntos para que el tipo sea compatible con los módulos :"
"mod:`pydoc` y :mod:`pickle`. ::"

#: ../../extending/newtypes_tutorial.rst:138
msgid ""
"This is so that Python knows how much memory to allocate when creating new :"
"class:`Custom` instances.  :c:member:`~PyTypeObject.tp_itemsize` is only "
"used for variable-sized objects and should otherwise be zero."
msgstr ""
"Esto es para que Python sepa cuánta memoria debe asignar al crear nuevas "
"instancias de :class:`Custom`. :c:member:`~PyTypeObject.tp_itemsize` sólo se "
"utiliza para objetos de tamaño variable y, en caso contrario, debe ser cero."

#: ../../extending/newtypes_tutorial.rst:144
msgid ""
"If you want your type to be subclassable from Python, and your type has the "
"same :c:member:`~PyTypeObject.tp_basicsize` as its base type, you may have "
"problems with multiple inheritance.  A Python subclass of your type will "
"have to list your type first in its :attr:`~class.__bases__`, or else it "
"will not be able to call your type's :meth:`__new__` method without getting "
"an error.  You can avoid this problem by ensuring that your type has a "
"larger value for :c:member:`~PyTypeObject.tp_basicsize` than its base type "
"does.  Most of the time, this will be true anyway, because either your base "
"type will be :class:`object`, or else you will be adding data members to "
"your base type, and therefore increasing its size."
msgstr ""
"Si quieres que tu tipo sea subclasificable desde Python, y tu tipo tiene el "
"mismo :c:member:`~PyTypeObject.tp_basicsize` que su tipo base, puedes tener "
"problemas con la herencia múltiple.  Una subclase Python de tu tipo tendrá "
"que listar tu tipo primero en su :attr:`~class.__bases__`, o de lo contrario "
"no podrá llamar al método :meth:`__new__` de tu tipo sin obtener un error.  "
"Puede evitar este problema asegurándose de que su tipo tiene un valor mayor "
"para :c:member:`~PyTypeObject.tp_basicsize` que su tipo base.  La mayoría de "
"las veces, esto será cierto de todas formas, porque o bien tu tipo base "
"será :class:`object`, o bien estarás añadiendo miembros de datos a tu tipo "
"base, y por lo tanto incrementando su tamaño."

#: ../../extending/newtypes_tutorial.rst:154
msgid "We set the class flags to :const:`Py_TPFLAGS_DEFAULT`. ::"
msgstr "Establecemos las banderas de clase en :const:`Py_TPFLAGS_DEFAULT`. ::"

#: ../../extending/newtypes_tutorial.rst:158
msgid ""
"All types should include this constant in their flags.  It enables all of "
"the members defined until at least Python 3.3.  If you need further members, "
"you will need to OR the corresponding flags."
msgstr ""
"Todos los tipos deben incluir esta constante en sus banderas.  Habilita "
"todos los miembros definidos hasta al menos Python 3.3.  Si necesita más "
"miembros, necesitará O las banderas correspondientes."

#: ../../extending/newtypes_tutorial.rst:162
msgid ""
"We provide a doc string for the type in :c:member:`~PyTypeObject.tp_doc`. ::"
msgstr ""
"Proporcionamos una cadena doc para el tipo en :c:member:`~PyTypeObject."
"tp_doc`. ::"

#: ../../extending/newtypes_tutorial.rst:166
msgid ""
"To enable object creation, we have to provide a :c:member:`~PyTypeObject."
"tp_new` handler.  This is the equivalent of the Python method :meth:"
"`__new__`, but has to be specified explicitly.  In this case, we can just "
"use the default implementation provided by the API function :c:func:"
"`PyType_GenericNew`. ::"
msgstr ""
"Para permitir la creación de objetos, tenemos que proporcionar un manejador :"
"c:member:`~PyTypeObject.tp_new`.  Es el equivalente al método de Python :"
"meth:`__new__`, pero debe especificarse explícitamente.  En este caso, "
"podemos utilizar la implementación por defecto proporcionada por la función "
"de la API :c:func:`PyType_GenericNew`. ::"

#: ../../extending/newtypes_tutorial.rst:173
msgid ""
"Everything else in the file should be familiar, except for some code in :c:"
"func:`PyInit_custom`::"
msgstr ""
"Todo lo demás en el archivo debe ser familiar, a excepción de un poco de "
"código en :c:func:`PyInit_custom`::"

#: ../../extending/newtypes_tutorial.rst:179
msgid ""
"This initializes the :class:`Custom` type, filling in a number of members to "
"the appropriate default values, including :attr:`ob_type` that we initially "
"set to ``NULL``. ::"
msgstr ""
"Esto inicializa el tipo :class:`Custom`, rellenando una serie de miembros "
"con los valores predeterminados apropiados, incluyendo :attr:`ob_type` que "
"inicialmente establecimos en ``NULL``. ::"

#: ../../extending/newtypes_tutorial.rst:190
msgid ""
"This adds the type to the module dictionary.  This allows us to create :"
"class:`Custom` instances by calling the :class:`Custom` class:"
msgstr ""
"Esto añade el tipo al diccionario del módulo.  Esto nos permite crear "
"instancias de :class:`Custom` llamando a la clase :class:`Custom`:"

#: ../../extending/newtypes_tutorial.rst:198
msgid ""
"That's it!  All that remains is to build it; put the above code in a file "
"called :file:`custom.c` and:"
msgstr ""
"Ya está.  Todo lo que queda es construirlo; poner el código anterior en un "
"archivo llamado :file:`custom.c` y:"

#: ../../extending/newtypes_tutorial.rst:207
msgid "in a file called :file:`setup.py`; then typing"
msgstr "en un archivo llamado :file:`setup.py`; luego escribiendo"

#: ../../extending/newtypes_tutorial.rst:213
msgid ""
"at a shell should produce a file :file:`custom.so` in a subdirectory; move "
"to that directory and fire up Python --- you should be able to ``import "
"custom`` and play around with Custom objects."
msgstr ""
"en un intérprete de comandos debería producir un archivo :file:`custom.so` "
"en un subdirectorio; vaya a ese directorio y encienda Python --- debería "
"poder ``import custom`` y jugar con objetos personalizados."

#: ../../extending/newtypes_tutorial.rst:217
msgid "That wasn't so hard, was it?"
msgstr "Eso no fue tan difícil, ¿verdad?"

#: ../../extending/newtypes_tutorial.rst:219
msgid ""
"Of course, the current Custom type is pretty uninteresting. It has no data "
"and doesn't do anything. It can't even be subclassed."
msgstr ""
"Por supuesto, el tipo de encargo actual es bastante aburrido. No tiene datos "
"y no hace nada. Ni siquiera se puede subclasificar."

#: ../../extending/newtypes_tutorial.rst:223
msgid ""
"While this documentation showcases the standard :mod:`distutils` module for "
"building C extensions, it is recommended in real-world use cases to use the "
"newer and better-maintained ``setuptools`` library.  Documentation on how to "
"do this is out of scope for this document and can be found in the `Python "
"Packaging User's Guide <https://packaging.python.org/tutorials/distributing-"
"packages/>`_."
msgstr ""
"Aunque esta documentación muestra el módulo estándar :mod:`distutils` para "
"construir extensiones C, se recomienda en casos de uso en el mundo real "
"utilizar la biblioteca ``setuptools``, más nueva y mejor mantenida.  La "
"documentación sobre cómo hacerlo está fuera del alcance de este documento y "
"se puede encontrar en la `Guía del usuario de empaquetado de Python <https://"
"packaging.python.org/tutorials/distributing-packages/>`_."

#: ../../extending/newtypes_tutorial.rst:231
msgid "Adding data and methods to the Basic example"
msgstr "Añadiendo datos y métodos al ejemplo Básico"

#: ../../extending/newtypes_tutorial.rst:233
msgid ""
"Let's extend the basic example to add some data and methods.  Let's also "
"make the type usable as a base class. We'll create a new module, :mod:"
"`custom2` that adds these capabilities:"
msgstr ""
"Vamos a ampliar el ejemplo básico para añadir algunos datos y métodos. "
"También haremos que el tipo sea utilizable como una clase base. Crearemos un "
"nuevo módulo, :mod:`custom2`, que añade estas capacidades."

#: ../../extending/newtypes_tutorial.rst:240
msgid "This version of the module has a number of changes."
msgstr "Esta versión del módulo tiene varios cambios."

#: ../../extending/newtypes_tutorial.rst:242
msgid "We've added an extra include::"
msgstr "Hemos añadido un include extra::"

#: ../../extending/newtypes_tutorial.rst:246
msgid ""
"This include provides declarations that we use to handle attributes, as "
"described a bit later."
msgstr ""
"Este include proporciona declaraciones que usamos para manejar atributos, "
"como se describe un poco más adelante."

#: ../../extending/newtypes_tutorial.rst:249
msgid ""
"The  :class:`Custom` type now has three data attributes in its C struct, "
"*first*, *last*, and *number*.  The *first* and *last* variables are Python "
"strings containing first and last names.  The *number* attribute is a C "
"integer."
msgstr ""
"El tipo :class:`Custom` ahora tiene tres atributos de datos en su estructura "
"C, *first*, *last* y *number*. Las variables *first* y *last* son cadenas de "
"texto en Python que contienen nombres y apellidos. El atributo *number* es "
"un entero en C."

#: ../../extending/newtypes_tutorial.rst:253
msgid "The object structure is updated accordingly::"
msgstr "La estructura del objeto se actualiza en consecuencia::"

#: ../../extending/newtypes_tutorial.rst:262
msgid ""
"Because we now have data to manage, we have to be more careful about object "
"allocation and deallocation.  At a minimum, we need a deallocation method::"
msgstr ""
"Porque ahora tenemos datos para gestionar, tenemos que ser más cuidadosos "
"con la asignación y desasignación de objetos. Como mínimo, necesitamos un "
"método de desasignación::"

#: ../../extending/newtypes_tutorial.rst:273
msgid "which is assigned to the :c:member:`~PyTypeObject.tp_dealloc` member::"
msgstr "que se asigna al miembro :c:member:`~PyTypeObject.tp_dealloc`::"

#: ../../extending/newtypes_tutorial.rst:277
msgid ""
"This method first clears the reference counts of the two Python attributes. :"
"c:func:`Py_XDECREF` correctly handles the case where its argument is "
"``NULL`` (which might happen here if ``tp_new`` failed midway).  It then "
"calls the :c:member:`~PyTypeObject.tp_free` member of the object's type "
"(computed by ``Py_TYPE(self)``) to free the object's memory.  Note that the "
"object's type might not be :class:`CustomType`, because the object may be an "
"instance of a subclass."
msgstr ""
"Este método primero borra los recuentos de referencia de los dos atributos "
"de Python. :c:func:`Py_XDECREF` maneja correctamente el caso en el que su "
"argumento es ``NULL`` (lo cual podría ocurrir aquí si ``tp_new`` falló a "
"mitad de camino). Luego llama al miembro :c:member:`~PyTypeObject.tp_free` "
"del tipo del objeto (calculado por ``Py_TYPE(self)``) para liberar la "
"memoria del objeto. Tenga en cuenta que el tipo del objeto podría no ser :"
"class:`CustomType`, porque el objeto puede ser una instancia de una subclase."

#: ../../extending/newtypes_tutorial.rst:286
msgid ""
"The explicit cast to ``destructor`` above is needed because we defined "
"``Custom_dealloc`` to take a ``CustomObject *`` argument, but the "
"``tp_dealloc`` function pointer expects to receive a ``PyObject *`` "
"argument.  Otherwise, the compiler will emit a warning.  This is object-"
"oriented polymorphism, in C!"
msgstr ""
"La conversión explícita a ``destructor`` es necesaria porque definimos "
"``Custom_dealloc`` para recibir un argumento ``CustomObject *``, pero el "
"puntero de función ``tp_dealloc`` espera recibir un argumento ``PyObject "
"*``. De lo contrario, el compilador emitirá una advertencia.  De lo "
"contrario, el compilador emitirá una advertencia.  Esto es polimorfismo "
"orientado a objetos, ¡en C!"

#: ../../extending/newtypes_tutorial.rst:292
msgid ""
"We want to make sure that the first and last names are initialized to empty "
"strings, so we provide a ``tp_new`` implementation::"
msgstr ""
"Queremos asegurarnos de que el nombre y los apellidos se inicializan con "
"cadenas vacías, por lo que proporcionamos una implementación ``tp_new``::"

#: ../../extending/newtypes_tutorial.rst:316
msgid "and install it in the :c:member:`~PyTypeObject.tp_new` member::"
msgstr "e instalarlo en el miembro :c:member:`~PyTypeObject.tp_new`::"

#: ../../extending/newtypes_tutorial.rst:320
msgid ""
"The ``tp_new`` handler is responsible for creating (as opposed to "
"initializing) objects of the type.  It is exposed in Python as the :meth:"
"`__new__` method. It is not required to define a ``tp_new`` member, and "
"indeed many extension types will simply reuse :c:func:`PyType_GenericNew` as "
"done in the first version of the ``Custom`` type above.  In this case, we "
"use the ``tp_new`` handler to initialize the ``first`` and ``last`` "
"attributes to non-``NULL`` default values."
msgstr ""
"El manejador ``tp_new`` es responsable de crear (en lugar de inicializar) "
"objetos del tipo.  Está expuesto en Python como el método :meth:`__new__`. "
"No es necesario definir un miembro ``tp_new``, y de hecho muchos tipos de "
"extensión simplemente reutilizarán :c:func:`PyType_GenericNew` como se hizo "
"en la primera versión del tipo ``Custom`` anteriormente.  En este caso, "
"usamos el manejador ``tp_new`` para inicializar los atributos ``first`` y "
"``last`` a valores por defecto no``NULL``."

#: ../../extending/newtypes_tutorial.rst:328
msgid ""
"``tp_new`` is passed the type being instantiated (not necessarily "
"``CustomType``, if a subclass is instantiated) and any arguments passed when "
"the type was called, and is expected to return the instance created.  "
"``tp_new`` handlers always accept positional and keyword arguments, but they "
"often ignore the arguments, leaving the argument handling to initializer (a."
"k.a. ``tp_init`` in C or ``__init__`` in Python) methods."
msgstr ""
"``tp_new`` se le pasa el tipo que se está instanciando (no necesariamente "
"``CustomType``, si se instancia una subclase) y cualquier argumento pasado "
"cuando se llamó al tipo, y se espera que devuelva la instancia creada. Los "
"manejadores ``tp_new`` siempre aceptan argumentos posicionales y de palabra "
"clave, pero a menudo ignoran los argumentos, dejando el manejo de los "
"argumentos a los métodos inicializadores (también conocidos como ``tp_init`` "
"en C o ``__init__`` en Python)."

#: ../../extending/newtypes_tutorial.rst:336
msgid ""
"``tp_new`` shouldn't call ``tp_init`` explicitly, as the interpreter will do "
"it itself."
msgstr ""
"``tp_new`` no debería llamar explícitamente a ``tp_init``, ya que el "
"intérprete lo hará por sí mismo."

#: ../../extending/newtypes_tutorial.rst:339
msgid ""
"The ``tp_new`` implementation calls the :c:member:`~PyTypeObject.tp_alloc` "
"slot to allocate memory::"
msgstr ""
"La implementación de ``tp_new`` llama a la ranura :c:member:`~PyTypeObject."
"tp_alloc` para asignar memoria::"

#: ../../extending/newtypes_tutorial.rst:344
msgid ""
"Since memory allocation may fail, we must check the :c:member:`~PyTypeObject."
"tp_alloc` result against ``NULL`` before proceeding."
msgstr ""
"Dado que la asignación de memoria puede fallar, debemos comprobar el "
"resultado de :c:member:`~PyTypeObject.tp_alloc` con ``NULL`` antes de "
"continuar."

#: ../../extending/newtypes_tutorial.rst:348
msgid ""
"We didn't fill the :c:member:`~PyTypeObject.tp_alloc` slot ourselves. "
"Rather :c:func:`PyType_Ready` fills it for us by inheriting it from our base "
"class, which is :class:`object` by default.  Most types use the default "
"allocation strategy."
msgstr ""
"No llenamos la ranura :c:member:`~PyTypeObject.tp_alloc` nosotros mismos. "
"Más bien :c:func:`PyType_Ready` lo llena por nosotros heredándolo de nuestra "
"clase base, que es :class:`object` por defecto.  La mayoría de los tipos "
"utilizan la estrategia de asignación por defecto."

#: ../../extending/newtypes_tutorial.rst:354
msgid ""
"If you are creating a co-operative :c:member:`~PyTypeObject.tp_new` (one "
"that calls a base type's :c:member:`~PyTypeObject.tp_new` or :meth:"
"`__new__`), you must *not* try to determine what method to call using method "
"resolution order at runtime.  Always statically determine what type you are "
"going to call, and call its :c:member:`~PyTypeObject.tp_new` directly, or "
"via ``type->tp_base->tp_new``.  If you do not do this, Python subclasses of "
"your type that also inherit from other Python-defined classes may not work "
"correctly. (Specifically, you may not be able to create instances of such "
"subclasses without getting a :exc:`TypeError`.)"
msgstr ""
"Si está creando un :c:member:`~PyTypeObject.tp_new` cooperativo (uno que "
"llama a :c:member:`~PyTypeObject.tp_new` o :meth:`__new__` de un tipo base), "
"no debe *intentar* determinar a qué método llamar utilizando el orden de "
"resolución de métodos en tiempo de ejecución.  Determina siempre "
"estáticamente qué tipo vas a llamar, y llama a su :c:member:`~PyTypeObject."
"tp_new` directamente, o a través de ``type->tp_base->tp_new``.  Si no haces "
"esto, las subclases Python de tu tipo que también heredan de otras clases "
"definidas por Python pueden no funcionar correctamente. (Específicamente, "
"puede que no seas capaz de crear instancias de tales subclases sin obtener "
"un :exc:`TypeError`.)"

#: ../../extending/newtypes_tutorial.rst:364
msgid ""
"We also define an initialization function which accepts arguments to provide "
"initial values for our instance::"
msgstr ""
"También definimos una función de inicialización que acepta argumentos para "
"proporcionar valores iniciales a nuestra instancia::"

#: ../../extending/newtypes_tutorial.rst:393
msgid "by filling the :c:member:`~PyTypeObject.tp_init` slot. ::"
msgstr "llenando la ranura :c:member:`~PyTypeObject.tp_init`. ::"

#: ../../extending/newtypes_tutorial.rst:397
msgid ""
"The :c:member:`~PyTypeObject.tp_init` slot is exposed in Python as the :meth:"
"`__init__` method.  It is used to initialize an object after it's created.  "
"Initializers always accept positional and keyword arguments, and they should "
"return either ``0`` on success or ``-1`` on error."
msgstr ""
"La ranura :c:member:`~PyTypeObject.tp_init` está expuesta en Python como el "
"método :meth:`__init__`.  Se utiliza para inicializar un objeto después de "
"crearlo.  Los inicializadores siempre aceptan argumentos posicionales y de "
"palabra clave, y deben devolver ``0`` en caso de éxito o ``-1`` en caso de "
"error."

#: ../../extending/newtypes_tutorial.rst:402
msgid ""
"Unlike the ``tp_new`` handler, there is no guarantee that ``tp_init`` is "
"called at all (for example, the :mod:`pickle` module by default doesn't "
"call :meth:`__init__` on unpickled instances).  It can also be called "
"multiple times.  Anyone can call the :meth:`__init__` method on our "
"objects.  For this reason, we have to be extra careful when assigning the "
"new attribute values.  We might be tempted, for example to assign the "
"``first`` member like this::"
msgstr ""
"A diferencia del manejador ``tp_new``, no hay garantía de que ``tp_init`` "
"sea llamado en absoluto (por ejemplo, el módulo :mod:`pickle` por defecto no "
"llama a :meth:`__init__` en instancias no bloqueadas).  También puede ser "
"llamado varias veces.  Cualquiera puede llamar al método :meth:`__init__` en "
"nuestros objetos.  Por esta razón, tenemos que tener mucho cuidado al "
"asignar los nuevos valores de los atributos.  Podríamos caer en la "
"tentación, por ejemplo, de asignar el miembro ``first`` así::"

#: ../../extending/newtypes_tutorial.rst:416
msgid ""
"But this would be risky.  Our type doesn't restrict the type of the "
"``first`` member, so it could be any kind of object.  It could have a "
"destructor that causes code to be executed that tries to access the "
"``first`` member; or that destructor could release the :term:`Global "
"interpreter Lock <GIL>` and let arbitrary code run in other threads that "
"accesses and modifies our object."
msgstr ""
"Pero esto sería arriesgado.  Nuestro tipo no restringe el tipo del miembro "
"``first``, por lo que podría ser cualquier tipo de objeto.  Podría tener un "
"destructor que hiciera que se ejecutara código que intentara acceder al "
"miembro ``first``; o ese destructor podría liberar el :term:`Global "
"interpreter Lock <GIL>` y dejar que se ejecutara código arbitrario en otros "
"hilos que accediera y modificara nuestro objeto."

#: ../../extending/newtypes_tutorial.rst:423
msgid ""
"To be paranoid and protect ourselves against this possibility, we almost "
"always reassign members before decrementing their reference counts.  When "
"don't we have to do this?"
msgstr ""
"Ser paranoico y protegernos contra esta posibilidad, casi siempre "
"reasignamos miembros antes de decrementar sus recuentos de referencia. "
"¿Cuándo no tenemos que hacer esto?"

#: ../../extending/newtypes_tutorial.rst:427
msgid "when we absolutely know that the reference count is greater than 1;"
msgstr ""
"cuando absolutamente sabemos que el recuento de referencias es mayor que 1;"

#: ../../extending/newtypes_tutorial.rst:429
msgid ""
"when we know that deallocation of the object [#]_ will neither release the :"
"term:`GIL` nor cause any calls back into our type's code;"
msgstr ""
"cuando sabemos que la desasignación del objeto [#]_ no liberará el :term:"
"`GIL` ni causará ninguna llamada de vuelta al código de nuestro tipo;"

#: ../../extending/newtypes_tutorial.rst:432
msgid ""
"when decrementing a reference count in a :c:member:`~PyTypeObject."
"tp_dealloc` handler on a type which doesn't support cyclic garbage "
"collection [#]_."
msgstr ""
"cuando se decrementa un contador de referencias en un manejador :c:member:"
"`~PyTypeObject.tp_dealloc` en un tipo que no soporta la recolección cíclica "
"de basura [#]_."

#: ../../extending/newtypes_tutorial.rst:435
msgid ""
"We want to expose our instance variables as attributes. There are a number "
"of ways to do that. The simplest way is to define member definitions::"
msgstr ""
"Queremos exponer nuestras variables de instancia como atributos. Hay varias "
"formas de hacerlo. La forma más sencilla es definir las definiciones de "
"miembros::"

#: ../../extending/newtypes_tutorial.rst:448
msgid ""
"and put the definitions in the :c:member:`~PyTypeObject.tp_members` slot::"
msgstr ""
"y poner las definiciones en la ranura :c:member:`~PyTypeObject.tp_members`::"

#: ../../extending/newtypes_tutorial.rst:452
msgid ""
"Each member definition has a member name, type, offset, access flags and "
"documentation string.  See the :ref:`Generic-Attribute-Management` section "
"below for details."
msgstr ""
"Cada definición de miembro tiene un nombre de miembro, tipo, desplazamiento, "
"indicadores de acceso y cadena de documentación.  Para más información, ver "
"la sección :ref:`Generic-Attribute-Management`."

#: ../../extending/newtypes_tutorial.rst:456
msgid ""
"A disadvantage of this approach is that it doesn't provide a way to restrict "
"the types of objects that can be assigned to the Python attributes.  We "
"expect the first and last names to be strings, but any Python objects can be "
"assigned. Further, the attributes can be deleted, setting the C pointers to "
"``NULL``.  Even though we can make sure the members are initialized to non-"
"``NULL`` values, the members can be set to ``NULL`` if the attributes are "
"deleted."
msgstr ""
"Una desventaja de este enfoque es que no proporciona una forma de restringir "
"los tipos de objetos que se pueden asignar a los atributos Python.  "
"Esperamos que el nombre y el apellido sean cadenas, pero se puede asignar "
"cualquier objeto Python. Además, los atributos se pueden borrar, "
"estableciendo los punteros C a ``NULL``. Aunque podemos asegurarnos de que "
"los miembros se inicializan a valores no``NULL``, los miembros se pueden "
"establecer ``NULL`` si los atributos son borrados."

#: ../../extending/newtypes_tutorial.rst:463
msgid ""
"We define a single method, :meth:`Custom.name()`, that outputs the objects "
"name as the concatenation of the first and last names. ::"
msgstr ""
"Definimos un único método, :meth:`Custom.name()`, que devuelve el nombre del "
"objeto como la concatenación del nombre y el apellido. ::"

#: ../../extending/newtypes_tutorial.rst:480
msgid ""
"The method is implemented as a C function that takes a :class:`Custom` (or :"
"class:`Custom` subclass) instance as the first argument.  Methods always "
"take an instance as the first argument. Methods often take positional and "
"keyword arguments as well, but in this case we don't take any and don't need "
"to accept a positional argument tuple or keyword argument dictionary. This "
"method is equivalent to the Python method:"
msgstr ""
"El método se implementa como una función C que toma una instancia de :class:"
"`Custom` (o subclase de :class:`Custom` ) como primer argumento.  Los "
"métodos siempre toman una instancia como primer argumento. Los métodos a "
"menudo toman también argumentos posicionales y de palabra clave, pero en "
"este caso no tomamos ninguno y no necesitamos aceptar una tupla de "
"argumentos posicionales o un diccionario de argumentos de palabra clave. "
"Este método es equivalente al método de Python:"

#: ../../extending/newtypes_tutorial.rst:492
msgid ""
"Note that we have to check for the possibility that our :attr:`first` and :"
"attr:`last` members are ``NULL``.  This is because they can be deleted, in "
"which case they are set to ``NULL``.  It would be better to prevent deletion "
"of these attributes and to restrict the attribute values to be strings.  "
"We'll see how to do that in the next section."
msgstr ""
"Tener en cuenta que debemos comprobar la posibilidad de que nuestros "
"miembros :attr:`first` y :attr:`last` sean ``NULL``. Esto se debe a que se "
"pueden eliminar, en cuyo caso se establecen como ``NULL``. Sería mejor "
"evitar la eliminación de estos atributos y restringir los valores de los "
"atributos a ser cadenas de texto. Veremos cómo hacerlo en la próxima sección."

#: ../../extending/newtypes_tutorial.rst:498
msgid ""
"Now that we've defined the method, we need to create an array of method "
"definitions::"
msgstr ""
"Ahora que hemos definido el método, tenemos que crear una matriz de "
"definiciones de método::"

#: ../../extending/newtypes_tutorial.rst:508
msgid ""
"(note that we used the :const:`METH_NOARGS` flag to indicate that the method "
"is expecting no arguments other than *self*)"
msgstr ""
"(nótese que hemos utilizado la bandera :const:`METH_NOARGS` para indicar que "
"el método no espera más argumentos que *self*)"

#: ../../extending/newtypes_tutorial.rst:511
msgid "and assign it to the :c:member:`~PyTypeObject.tp_methods` slot::"
msgstr "y asignarlo a la ranura :c:member:`~PyTypeObject.tp_methods`::"

#: ../../extending/newtypes_tutorial.rst:515
msgid ""
"Finally, we'll make our type usable as a base class for subclassing.  We've "
"written our methods carefully so far so that they don't make any assumptions "
"about the type of the object being created or used, so all we need to do is "
"to add the :const:`Py_TPFLAGS_BASETYPE` to our class flag definition::"
msgstr ""
"Por último, haremos que nuestro tipo sea utilizable como clase base para "
"subclases.  Hemos escrito nuestros métodos cuidadosamente hasta ahora para "
"que no hagan ninguna suposición sobre el tipo del objeto que se está creando "
"o utilizando, por lo que todo lo que tenemos que hacer es añadir el :const:"
"`Py_TPFLAGS_BASETYPE` a nuestra definición de la bandera de la clase::"

#: ../../extending/newtypes_tutorial.rst:522
msgid ""
"We rename :c:func:`PyInit_custom` to :c:func:`PyInit_custom2`, update the "
"module name in the :c:type:`PyModuleDef` struct, and update the full class "
"name in the :c:type:`PyTypeObject` struct."
msgstr ""
"Cambiamos el nombre de :c:func:`PyInit_custom` a :c:func:`PyInit_custom2`, "
"actualizamos el nombre del módulo en la estructura :c:type:`PyModuleDef` y "
"actualizamos el nombre completo de la clase en la estructura :c:type:"
"`PyTypeObject`."

#: ../../extending/newtypes_tutorial.rst:526
msgid "Finally, we update our :file:`setup.py` file to build the new module:"
msgstr ""
"Finalmente, actualizamos nuestro archivo :file:`setup.py` para construir el "
"nuevo módulo."

#: ../../extending/newtypes_tutorial.rst:539
msgid "Providing finer control over data attributes"
msgstr "Proporcionando un control más preciso sobre los atributos de datos"

#: ../../extending/newtypes_tutorial.rst:541
msgid ""
"In this section, we'll provide finer control over how the :attr:`first` and :"
"attr:`last` attributes are set in the :class:`Custom` example. In the "
"previous version of our module, the instance variables :attr:`first` and :"
"attr:`last` could be set to non-string values or even deleted. We want to "
"make sure that these attributes always contain strings."
msgstr ""
"En esta sección, proporcionaremos un control más preciso sobre cómo se "
"establecen los atributos :attr:`first` y :attr:`last` en el ejemplo :class:"
"`Custom`. En la versión anterior de nuestro módulo, las variables de "
"instancia :attr:`first` y :attr:`last` podían establecerse con valores que "
"no fueran cadenas o incluso eliminarse. Queremos asegurarnos de que estos "
"atributos siempre contengan cadenas."

#: ../../extending/newtypes_tutorial.rst:550
msgid ""
"To provide greater control, over the :attr:`first` and :attr:`last` "
"attributes, we'll use custom getter and setter functions.  Here are the "
"functions for getting and setting the :attr:`first` attribute::"
msgstr ""
"Para proporcionar un mayor control sobre los atributos :attr:`first` y :attr:"
"`last`, utilizaremos funciones getter y setter personalizadas.  Estas son "
"las funciones para obtener y establecer el atributo :attr:`first`::"

#: ../../extending/newtypes_tutorial.rst:581
msgid ""
"The getter function is passed a :class:`Custom` object and a \"closure\", "
"which is a void pointer.  In this case, the closure is ignored.  (The "
"closure supports an advanced usage in which definition data is passed to the "
"getter and setter. This could, for example, be used to allow a single set of "
"getter and setter functions that decide the attribute to get or set based on "
"data in the closure.)"
msgstr ""
"La función getter recibe un objeto :class:`Custom` y un \"closure\", que es "
"un puntero nulo. En este caso, se ignora el closure. (El closure admite un "
"uso avanzado en el que se pasa información de definición al getter y al "
"setter. Esto podría, por ejemplo, permitir un único conjunto de funciones "
"getter y setter que decidan el atributo a obtener o establecer en función de "
"los datos en el closure.)"

#: ../../extending/newtypes_tutorial.rst:587
msgid ""
"The setter function is passed the :class:`Custom` object, the new value, and "
"the closure.  The new value may be ``NULL``, in which case the attribute is "
"being deleted.  In our setter, we raise an error if the attribute is deleted "
"or if its new value is not a string."
msgstr ""
"A la función setter se le pasa el objeto :class:`Custom`, el nuevo valor y "
"el cierre.  El nuevo valor puede ser ``NULL``, en cuyo caso se elimina el "
"atributo.  En nuestro setter, lanzamos un error si el atributo se borra o si "
"su nuevo valor no es una cadena."

#: ../../extending/newtypes_tutorial.rst:592
msgid "We create an array of :c:type:`PyGetSetDef` structures::"
msgstr "Creamos una serie de estructuras :c:type:`PyGetSetDef`::"

#: ../../extending/newtypes_tutorial.rst:602
msgid "and register it in the :c:member:`~PyTypeObject.tp_getset` slot::"
msgstr "y regístrelo en la ranura :c:member:`~PyTypeObject.tp_getset`::"

#: ../../extending/newtypes_tutorial.rst:606
msgid ""
"The last item in a :c:type:`PyGetSetDef` structure is the \"closure\" "
"mentioned above.  In this case, we aren't using a closure, so we just pass "
"``NULL``."
msgstr ""
"El último elemento de una estructura :c:type:`PyGetSetDef` es el \"closure\" "
"ya mencionado.  En este caso, no estamos utilizando un cierre, por lo que "
"sólo pasamos ``NULL``."

#: ../../extending/newtypes_tutorial.rst:609
msgid "We also remove the member definitions for these attributes::"
msgstr "También eliminamos las definiciones de miembros para estos atributos:"

#: ../../extending/newtypes_tutorial.rst:617
msgid ""
"We also need to update the :c:member:`~PyTypeObject.tp_init` handler to only "
"allow strings [#]_ to be passed::"
msgstr ""
"También necesitamos actualizar el controlador :c:member:`~PyTypeObject."
"tp_init` para permitir solo cadenas [#]_ que se pasen::"

#: ../../extending/newtypes_tutorial.rst:646
msgid ""
"With these changes, we can assure that the ``first`` and ``last`` members "
"are never ``NULL`` so we can remove checks for ``NULL`` values in almost all "
"cases. This means that most of the :c:func:`Py_XDECREF` calls can be "
"converted to :c:func:`Py_DECREF` calls.  The only place we can't change "
"these calls is in the ``tp_dealloc`` implementation, where there is the "
"possibility that the initialization of these members failed in ``tp_new``."
msgstr ""
"Con estos cambios, podemos asegurar que los miembros ``first`` y ``last`` "
"nunca son ``NULL`` por lo que podemos eliminar las comprobaciones de los "
"valores ``NULL`` en casi todos los casos. Esto significa que la mayoría de "
"las llamadas a :c:func:`Py_XDECREF` pueden convertirse en llamadas a :c:func:"
"`Py_DECREF`.  El único lugar donde no podemos cambiar estas llamadas es en "
"la implementación de ``tp_dealloc``, donde existe la posibilidad de que la "
"inicialización de estos miembros haya fallado en ``tp_new``."

#: ../../extending/newtypes_tutorial.rst:653
msgid ""
"We also rename the module initialization function and module name in the "
"initialization function, as we did before, and we add an extra definition to "
"the :file:`setup.py` file."
msgstr ""
"También renombramos la función de inicialización del módulo y el nombre del "
"módulo en la función de inicialización, como hicimos antes, y añadimos una "
"definición extra al archivo :file:`setup.py`."

#: ../../extending/newtypes_tutorial.rst:659
msgid "Supporting cyclic garbage collection"
msgstr "Recogida de basura cíclica"

#: ../../extending/newtypes_tutorial.rst:661
msgid ""
"Python has a :term:`cyclic garbage collector (GC) <garbage collection>` that "
"can identify unneeded objects even when their reference counts are not zero. "
"This can happen when objects are involved in cycles.  For example, consider:"
msgstr ""
"Python tiene un :term:`cyclic garbage collector (GC) <garbage collection>` "
"que puede identificar objetos innecesarios incluso cuando sus recuentos de "
"referencia no son cero. Esto puede ocurrir cuando los objetos están "
"involucrados en ciclos.  Por ejemplo, considere:"

#: ../../extending/newtypes_tutorial.rst:671
msgid ""
"In this example, we create a list that contains itself. When we delete it, "
"it still has a reference from itself. Its reference count doesn't drop to "
"zero. Fortunately, Python's cyclic garbage collector will eventually figure "
"out that the list is garbage and free it."
msgstr ""
"En este ejemplo, creamos una lista que se contiene a sí misma. Cuando la "
"borramos, sigue teniendo una referencia a sí misma. Su número de referencias "
"no cae a cero. Afortunadamente, el recolector de basura cíclico de Python se "
"dará cuenta de que la lista es basura y la liberará."

#: ../../extending/newtypes_tutorial.rst:676
msgid ""
"In the second version of the :class:`Custom` example, we allowed any kind of "
"object to be stored in the :attr:`first` or :attr:`last` attributes [#]_. "
"Besides, in the second and third versions, we allowed subclassing :class:"
"`Custom`, and subclasses may add arbitrary attributes.  For any of those two "
"reasons, :class:`Custom` objects can participate in cycles:"
msgstr ""
"En la segunda versión del ejemplo :class:`Custom`, permitimos almacenar "
"cualquier tipo de objeto en los atributos :attr:`first` o :attr:`last` [#]_. "
"Además, en la segunda y tercera versiones, permitimos subclasificar :class:"
"`Custom`, y las subclases pueden añadir atributos arbitrarios.  Por "
"cualquiera de esas dos razones, los objetos :class:`Custom` pueden "
"participar en ciclos:"

#: ../../extending/newtypes_tutorial.rst:690
msgid ""
"To allow a :class:`Custom` instance participating in a reference cycle to be "
"properly detected and collected by the cyclic GC, our :class:`Custom` type "
"needs to fill two additional slots and to enable a flag that enables these "
"slots:"
msgstr ""
"Para permitir que una instancia de :class:`Custom` que participa en un ciclo "
"de referencia sea correctamente detectada y recogida por la GC cíclica, "
"nuestro tipo :class:`Custom` necesita llenar dos ranuras adicionales y "
"habilitar una bandera que habilite estas ranuras:"

#: ../../extending/newtypes_tutorial.rst:697
msgid ""
"First, the traversal method lets the cyclic GC know about subobjects that "
"could participate in cycles::"
msgstr ""
"En primer lugar, el método transversal permite a la GC cíclica conocer los "
"subobjetos que podrían participar en ciclos::"

#: ../../extending/newtypes_tutorial.rst:717
msgid ""
"For each subobject that can participate in cycles, we need to call the :c:"
"func:`visit` function, which is passed to the traversal method. The :c:func:"
"`visit` function takes as arguments the subobject and the extra argument "
"*arg* passed to the traversal method.  It returns an integer value that must "
"be returned if it is non-zero."
msgstr ""
"Para cada subobjeto que pueda participar en ciclos, necesitamos llamar a la "
"función :c:func:`visit`, que se pasa al método traversal. La función :c:func:"
"`visit` toma como argumentos el subobjeto y el argumento extra *arg* pasado "
"al método transversal.  Devuelve un valor entero que debe ser devuelto si es "
"distinto de cero."

#: ../../extending/newtypes_tutorial.rst:723
msgid ""
"Python provides a :c:func:`Py_VISIT` macro that automates calling visit "
"functions.  With :c:func:`Py_VISIT`, we can minimize the amount of "
"boilerplate in ``Custom_traverse``::"
msgstr ""
"Python proporciona una macro :c:func:`Py_VISIT` que automatiza la llamada a "
"funciones de visita.  Con :c:func:`Py_VISIT`, podemos minimizar la cantidad "
"de repetición en ``Custom_traverse``::"

#: ../../extending/newtypes_tutorial.rst:736
msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` implementation must name its "
"arguments exactly *visit* and *arg* in order to use :c:func:`Py_VISIT`."
msgstr ""
"La implementación de :c:member:`~PyTypeObject.tp_traverse` debe nombrar sus "
"argumentos exactamente *visit* y *arg* para poder utilizar :c:func:"
"`Py_VISIT`."

#: ../../extending/newtypes_tutorial.rst:739
msgid ""
"Second, we need to provide a method for clearing any subobjects that can "
"participate in cycles::"
msgstr ""
"En segundo lugar, necesitamos proporcionar un método para borrar cualquier "
"subobjeto que pueda participar en ciclos::"

#: ../../extending/newtypes_tutorial.rst:750
msgid ""
"Notice the use of the :c:func:`Py_CLEAR` macro.  It is the recommended and "
"safe way to clear data attributes of arbitrary types while decrementing "
"their reference counts.  If you were to call :c:func:`Py_XDECREF` instead on "
"the attribute before setting it to ``NULL``, there is a possibility that the "
"attribute's destructor would call back into code that reads the attribute "
"again (*especially* if there is a reference cycle)."
msgstr ""
"Observe el uso de la macro :c:func:`Py_CLEAR`.  Es la forma recomendada y "
"segura de borrar atributos de datos de tipos arbitrarios mientras se "
"decrementa su número de referencias.  Si en su lugar llamara a :c:func:"
"`Py_XDECREF` en el atributo antes de establecerlo en ``NULL``, existe la "
"posibilidad de que el destructor del atributo volviera a llamar al código "
"que lee el atributo de nuevo (*especialmente* si hay un ciclo de referencia)."

#: ../../extending/newtypes_tutorial.rst:758
msgid "You could emulate :c:func:`Py_CLEAR` by writing::"
msgstr "Podrías emular :c:func:`Py_CLEAR` escribiendo::"

#: ../../extending/newtypes_tutorial.rst:765
msgid ""
"Nevertheless, it is much easier and less error-prone to always use :c:func:"
"`Py_CLEAR` when deleting an attribute.  Don't try to micro-optimize at the "
"expense of robustness!"
msgstr ""
"Sin embargo, es mucho más fácil y menos propenso a errores utilizar siempre :"
"c:func:`Py_CLEAR` al eliminar un atributo.  No intentes microoptimizar a "
"costa de la robustez."

#: ../../extending/newtypes_tutorial.rst:769
msgid ""
"The deallocator ``Custom_dealloc`` may call arbitrary code when clearing "
"attributes.  It means the circular GC can be triggered inside the function. "
"Since the GC assumes reference count is not zero, we need to untrack the "
"object from the GC by calling :c:func:`PyObject_GC_UnTrack` before clearing "
"members. Here is our reimplemented deallocator using :c:func:"
"`PyObject_GC_UnTrack` and ``Custom_clear``::"
msgstr ""
"El deallocator ``Custom_dealloc`` puede llamar a código arbitrario al borrar "
"atributos.  Esto significa que la GC circular puede activarse dentro de la "
"función. Dado que la GC asume que el número de referencias no es cero, "
"necesitamos eliminar el objeto de la GC llamando a :c:func:"
"`PyObject_GC_UnTrack` antes de borrar los miembros. Aquí está nuestro "
"reimplementado deallocator usando :c:func:`PyObject_GC_UnTrack` y "
"``Custom_clear``::"

#: ../../extending/newtypes_tutorial.rst:784
msgid ""
"Finally, we add the :const:`Py_TPFLAGS_HAVE_GC` flag to the class flags::"
msgstr ""
"Por último, añadimos la bandera :const:`Py_TPFLAGS_HAVE_GC` a la clase "
"flags::"

#: ../../extending/newtypes_tutorial.rst:788
msgid ""
"That's pretty much it.  If we had written custom :c:member:`~PyTypeObject."
"tp_alloc` or :c:member:`~PyTypeObject.tp_free` handlers, we'd need to modify "
"them for cyclic garbage collection.  Most extensions will use the versions "
"automatically provided."
msgstr ""
"Eso es todo.  Si hubiéramos escrito gestores personalizados para :c:member:"
"`~PyTypeObject.tp_alloc` o :c:member:`~PyTypeObject.tp_free`, tendríamos que "
"modificarlos para la recogida cíclica de basura.  La mayoría de las "
"extensiones utilizarán las versiones proporcionadas automáticamente."

#: ../../extending/newtypes_tutorial.rst:794
msgid "Subclassing other types"
msgstr "Subclases de otros tipos"

#: ../../extending/newtypes_tutorial.rst:796
msgid ""
"It is possible to create new extension types that are derived from existing "
"types. It is easiest to inherit from the built in types, since an extension "
"can easily use the :c:type:`PyTypeObject` it needs. It can be difficult to "
"share these :c:type:`PyTypeObject` structures between extension modules."
msgstr ""
"Es posible crear nuevos tipos de extensiones que se derivan de tipos "
"existentes. Es más fácil heredar de los tipos incorporados, ya que una "
"extensión puede usar fácilmente el :c:type:`PyTypeObject` que necesita. "
"Puede ser difícil compartir estas estructuras :c:type:`PyTypeObject` entre "
"módulos de extensión."

#: ../../extending/newtypes_tutorial.rst:801
msgid ""
"In this example we will create a :class:`SubList` type that inherits from "
"the built-in :class:`list` type. The new type will be completely compatible "
"with regular lists, but will have an additional :meth:`increment` method "
"that increases an internal counter:"
msgstr ""
"En este ejemplo crearemos un tipo :class:`SubList` que hereda del tipo "
"incorporado :class:`list`. El nuevo tipo será completamente compatible con "
"las listas regulares, pero tendrá un método adicional :meth:`increment` que "
"aumenta un contador interno:"

#: ../../extending/newtypes_tutorial.rst:821
msgid ""
"As you can see, the source code closely resembles the :class:`Custom` "
"examples in previous sections. We will break down the main differences "
"between them. ::"
msgstr ""
"Como puedes ver, el código fuente se asemeja estrechamente a los ejemplos "
"de :class:`Custom` en las secciones anteriores. Desglosaremos las "
"principales diferencias entre ellos. ::"

#: ../../extending/newtypes_tutorial.rst:829
msgid ""
"The primary difference for derived type objects is that the base type's "
"object structure must be the first value.  The base type will already "
"include the :c:func:`PyObject_HEAD` at the beginning of its structure."
msgstr ""
"La diferencia principal para los objetos de tipo derivado es que la "
"estructura del objeto del tipo base debe ser el primer valor. El tipo base "
"ya incluirá :c:func:`PyObject_HEAD` al principio de su estructura."

#: ../../extending/newtypes_tutorial.rst:833
msgid ""
"When a Python object is a :class:`SubList` instance, its ``PyObject *`` "
"pointer can be safely cast to both ``PyListObject *`` and ``SubListObject "
"*``::"
msgstr ""
"Cuando un objeto de Python es una instancia de :class:`SubList`, su puntero "
"``PyObject *`` se puede convertir de forma segura tanto a ``PyListObject *`` "
"como a ``SubListObject *``::"

#: ../../extending/newtypes_tutorial.rst:845
msgid ""
"We see above how to call through to the :attr:`__init__` method of the base "
"type."
msgstr "Vemos arriba cómo llamar al método :attr:`__init__` del tipo base."

#: ../../extending/newtypes_tutorial.rst:848
msgid ""
"This pattern is important when writing a type with custom :c:member:"
"`~PyTypeObject.tp_new` and :c:member:`~PyTypeObject.tp_dealloc` members.  "
"The :c:member:`~PyTypeObject.tp_new` handler should not actually create the "
"memory for the object with its :c:member:`~PyTypeObject.tp_alloc`, but let "
"the base class handle it by calling its own :c:member:`~PyTypeObject.tp_new`."
msgstr ""
"Este patrón es importante al escribir un tipo con miembros personalizados :c:"
"member:`~PyTypeObject.tp_new` y :c:member:`~PyTypeObject.tp_dealloc`. El "
"controlador :c:member:`~PyTypeObject.tp_new` no debe crear realmente la "
"memoria para el objeto con su :c:member:`~PyTypeObject.tp_alloc`, sino dejar "
"que la clase base lo maneje llamando a su propio :c:member:`~PyTypeObject."
"tp_new`."

#: ../../extending/newtypes_tutorial.rst:854
msgid ""
"The :c:type:`PyTypeObject` struct supports a :c:member:`~PyTypeObject."
"tp_base` specifying the type's concrete base class.  Due to cross-platform "
"compiler issues, you can't fill that field directly with a reference to :c:"
"type:`PyList_Type`; it should be done later in the module initialization "
"function::"
msgstr ""
"La estructura :c:type:`PyTypeObject` admite un :c:member:`~PyTypeObject."
"tp_base` que especifica la clase base concreta del tipo. Debido a problemas "
"de compilador multiplataforma, no se puede llenar ese campo directamente con "
"una referencia a :c:type:`PyList_Type`; debe hacerse más tarde en la función "
"de inicialización del módulo::"

#: ../../extending/newtypes_tutorial.rst:882
msgid ""
"Before calling :c:func:`PyType_Ready`, the type structure must have the :c:"
"member:`~PyTypeObject.tp_base` slot filled in.  When we are deriving an "
"existing type, it is not necessary to fill out the :c:member:`~PyTypeObject."
"tp_alloc` slot with :c:func:`PyType_GenericNew` -- the allocation function "
"from the base type will be inherited."
msgstr ""
"Antes de llamar a :c:func:`PyType_Ready`, la estructura del tipo debe tener "
"el espacio :c:member:`~PyTypeObject.tp_base` lleno. Cuando estamos derivando "
"un tipo existente, no es necesario completar el espacio :c:member:"
"`~PyTypeObject.tp_alloc` con :c:func:`PyType_GenericNew` -- la función de "
"asignación del tipo base será heredada."

#: ../../extending/newtypes_tutorial.rst:888
msgid ""
"After that, calling :c:func:`PyType_Ready` and adding the type object to the "
"module is the same as with the basic :class:`Custom` examples."
msgstr ""
"Después de eso, llamar a :c:func:`PyType_Ready` y agregar el objeto de tipo "
"al módulo es lo mismo que con los ejemplos básicos de :class:`Custom`."

#: ../../extending/newtypes_tutorial.rst:893
msgid "Footnotes"
msgstr "Notas a pie de página"

#: ../../extending/newtypes_tutorial.rst:894
msgid ""
"This is true when we know that the object is a basic type, like a string or "
"a float."
msgstr ""
"Esto es cierto cuando sabemos que el objeto es un tipo básico, como una "
"cadena o un número decimal."

#: ../../extending/newtypes_tutorial.rst:897
msgid ""
"We relied on this in the :c:member:`~PyTypeObject.tp_dealloc` handler in "
"this example, because our type doesn't support garbage collection."
msgstr ""
"Dependimos de esto en el controlador :c:member:`~PyTypeObject.tp_dealloc` en "
"este ejemplo, porque nuestro tipo no admite la recolección de basura."

#: ../../extending/newtypes_tutorial.rst:900
msgid ""
"We now know that the first and last members are strings, so perhaps we could "
"be less careful about decrementing their reference counts, however, we "
"accept instances of string subclasses.  Even though deallocating normal "
"strings won't call back into our objects, we can't guarantee that "
"deallocating an instance of a string subclass won't call back into our "
"objects."
msgstr ""
"Ahora sabemos que los primeros y últimos miembros son cadenas de texto, por "
"lo que tal vez podríamos ser menos cuidadosos al decrementar sus recuentos "
"de referencia, sin embargo, aceptamos instancias de subclases de cadenas de "
"texto. Aunque desasignar cadenas normales no llamará de vuelta a nuestros "
"objetos, no podemos garantizar que desasignar una instancia de una subclase "
"de cadena de texto no llamará de vuelta a nuestros objetos."

#: ../../extending/newtypes_tutorial.rst:906
msgid ""
"Also, even with our attributes restricted to strings instances, the user "
"could pass arbitrary :class:`str` subclasses and therefore still create "
"reference cycles."
msgstr ""
"Además, incluso con nuestros atributos restringidos a instancias de cadenas, "
"el usuario podría pasar subclases arbitrarias de :class:`str` y, por lo "
"tanto, seguir creando ciclos de referencia."
