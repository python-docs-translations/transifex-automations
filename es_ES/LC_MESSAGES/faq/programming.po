# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# eulalio barbero espinosa <eulalio@disroot.org>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-18 14:52+0000\n"
"PO-Revision-Date: 2024-05-11 00:32+0000\n"
"Last-Translator: eulalio barbero espinosa <eulalio@disroot.org>, 2025\n"
"Language-Team: Spanish (Spain) (https://app.transifex.com/python-doc/"
"teams/5390/es_ES/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es_ES\n"
"Plural-Forms: nplurals=3; plural=n == 1 ? 0 : n != 0 && n % 1000000 == 0 ? "
"1 : 2;\n"

#: ../../faq/programming.rst:5
msgid "Programming FAQ"
msgstr "Programación FAQ"

#: ../../faq/programming.rst:8
msgid "Contents"
msgstr "Contenido"

#: ../../faq/programming.rst:12
msgid "General Questions"
msgstr "Cuestiones generales"

#: ../../faq/programming.rst:15
msgid ""
"Is there a source code level debugger with breakpoints, single-stepping, "
"etc.?"
msgstr ""
"¿Existe un depurador a nivel de código fuente con puntos de interrupción, "
"paso a paso, etc.?"

#: ../../faq/programming.rst:17 ../../faq/programming.rst:58
msgid "Yes."
msgstr "Sí."

#: ../../faq/programming.rst:19
msgid ""
"Several debuggers for Python are described below, and the built-in function :"
"func:`breakpoint` allows you to drop into any of them."
msgstr ""
"A continuación se describen varios depuradores para Python, y la función "
"incorporada :func:`breakpoint` permite pasar a cualquiera de ellos."

#: ../../faq/programming.rst:22
msgid ""
"The pdb module is a simple but adequate console-mode debugger for Python. It "
"is part of the standard Python library, and is :mod:`documented in the "
"Library Reference Manual <pdb>`. You can also write your own debugger by "
"using the code for pdb as an example."
msgstr ""
"El módulo pdb es un depurador en modo consola simple pero adecuado para "
"Python. Forma parte de la biblioteca estándar de Python, y está :mod:"
"`documentado en el Manual de Referencia de la Biblioteca <pdb>`. También "
"puedes escribir tu propio depurador usando el código de pdb como ejemplo."

#: ../../faq/programming.rst:27
msgid ""
"The IDLE interactive development environment, which is part of the standard "
"Python distribution (normally available as `Tools/scripts/idle3 <https://"
"github.com/python/cpython/blob/main/Tools/scripts/idle3>`_), includes a "
"graphical debugger."
msgstr ""
"El entorno de desarrollo interactivo IDLE, que forma parte de la "
"distribución estándar de Python (normalmente disponible como `Tools/scripts/"
"idle3 <https://github.com/python/cpython/blob/main/Tools/scripts/idle3>`_), "
"incluye un depurador gráfico."

#: ../../faq/programming.rst:32
msgid ""
"PythonWin is a Python IDE that includes a GUI debugger based on pdb.  The "
"PythonWin debugger colors breakpoints and has quite a few cool features such "
"as debugging non-PythonWin programs.  PythonWin is available as part of "
"`pywin32 <https://github.com/mhammond/pywin32>`_ project and as a part of "
"the `ActivePython <https://www.activestate.com/products/python/>`_ "
"distribution."
msgstr ""
"PythonWin es un IDE de Python que incluye un depurador GUI basado en pdb.  "
"El depurador de PythonWin colorea los puntos de interrupción y tiene algunas "
"características interesantes como la depuración de programas que no son "
"PythonWin.  PythonWin está disponible como parte del proyecto `pywin32 "
"<https://github.com/mhammond/pywin32>`_ y como parte de la distribución "
"`ActivePython <https://www.activestate.com/products/python/>`_."

#: ../../faq/programming.rst:39
msgid ""
"`Eric <https://eric-ide.python-projects.org/>`_ is an IDE built on PyQt and "
"the Scintilla editing component."
msgstr ""
"`Eric <https://eric-ide.python-projects.org/>`_ es un IDE construido sobre "
"PyQt y el componente de edición Scintilla."

#: ../../faq/programming.rst:42
msgid ""
"`trepan3k <https://github.com/rocky/python3-trepan/>`_ is a gdb-like "
"debugger."
msgstr ""
"`trepan3k <https://github.com/rocky/python3-trepan/>`_ es un depurador "
"similar a gdb."

#: ../../faq/programming.rst:44
msgid ""
"`Visual Studio Code <https://code.visualstudio.com/>`_ is an IDE with "
"debugging tools that integrates with version-control software."
msgstr ""
"Visual Studio Code <https://code.visualstudio.com/>`_ es un IDE con "
"herramientas de depuración que se integra con software de control de "
"versiones."

#: ../../faq/programming.rst:47
msgid ""
"There are a number of commercial Python IDEs that include graphical "
"debuggers. They include:"
msgstr ""
"Existen varios IDE comerciales de Python que incluyen depuradores gráficos. "
"Estos incluyen:"

#: ../../faq/programming.rst:50
msgid "`Wing IDE <https://wingware.com/>`_"
msgstr "`Wing IDE <https://wingware.com/>`_"

#: ../../faq/programming.rst:51
msgid "`Komodo IDE <https://www.activestate.com/products/komodo-ide/>`_"
msgstr "`Komodo IDE <https://www.activestate.com/products/komodo-ide/>`_"

#: ../../faq/programming.rst:52
msgid "`PyCharm <https://www.jetbrains.com/pycharm/>`_"
msgstr "`PyCharm <https://www.jetbrains.com/pycharm/>`_"

#: ../../faq/programming.rst:56
msgid "Are there tools to help find bugs or perform static analysis?"
msgstr ""
"¿Existen herramientas que ayuden a encontrar errores o a realizar análisis "
"estáticos?"

#: ../../faq/programming.rst:60
msgid ""
"`Pylint <https://pylint.pycqa.org/en/latest/index.html>`_ and `Pyflakes "
"<https://github.com/PyCQA/pyflakes>`_ do basic checking that will help you "
"catch bugs sooner."
msgstr ""
"`Pylint <https://pylint.pycqa.org/en/latest/index.html>`_ y `Pyflakes "
"<https://github.com/PyCQA/pyflakes>`_ realizan comprobaciones básicas que te "
"ayudarán a detectar fallos antes."

#: ../../faq/programming.rst:64
msgid ""
"Static type checkers such as `Mypy <https://mypy-lang.org/>`_, `Pyre "
"<https://pyre-check.org/>`_, and `Pytype <https://github.com/google/"
"pytype>`_ can check type hints in Python source code."
msgstr ""
"Los comprobadores de tipos estáticos como `Mypy <https://mypy-lang.org/>`_, "
"`Pyre <https://pyre-check.org/>`_, y `Pytype <https://github.com/google/"
"pytype>`_ pueden comprobar sugerencias de tipos en el código fuente de "
"Python."

#: ../../faq/programming.rst:73
msgid "How can I create a stand-alone binary from a Python script?"
msgstr ""
"¿Cómo puedo crear un binario independiente a partir de un script de Python?"

#: ../../faq/programming.rst:75
msgid ""
"You don't need the ability to compile Python to C code if all you want is a "
"stand-alone program that users can download and run without having to "
"install the Python distribution first.  There are a number of tools that "
"determine the set of modules required by a program and bind these modules "
"together with a Python binary to produce a single executable."
msgstr ""
"No necesitas la capacidad de compilar Python a código C si todo lo que "
"quieres es un programa independiente que los usuarios puedan descargar y "
"ejecutar sin tener que instalar primero la distribución de Python.  Hay una "
"serie de herramientas que determinan el conjunto de módulos necesarios para "
"un programa y los unen a un binario de Python para producir un único "
"ejecutable."

#: ../../faq/programming.rst:81
msgid ""
"One is to use the freeze tool, which is included in the Python source tree "
"as `Tools/freeze <https://github.com/python/cpython/tree/main/Tools/"
"freeze>`_. It converts Python byte code to C arrays; with a C compiler you "
"can embed all your modules into a new program, which is then linked with the "
"standard Python modules."
msgstr ""
"Una es utilizar la herramienta freeze, que se incluye en el árbol de código "
"fuente de Python como `Tools/freeze <https://github.com/python/cpython/tree/"
"main/Tools/freeze>`_. Convierte el código de bytes de Python en matrices de "
"C; con un compilador de C puedes incrustar todos tus módulos en un nuevo "
"programa, que luego se enlaza con los módulos estándar de Python."

#: ../../faq/programming.rst:87
msgid ""
"It works by scanning your source recursively for import statements (in both "
"forms) and looking for the modules in the standard Python path as well as in "
"the source directory (for built-in modules).  It then turns the bytecode for "
"modules written in Python into C code (array initializers that can be turned "
"into code objects using the marshal module) and creates a custom-made config "
"file that only contains those built-in modules which are actually used in "
"the program.  It then compiles the generated C code and links it with the "
"rest of the Python interpreter to form a self-contained binary which acts "
"exactly like your script."
msgstr ""
"Funciona escaneando tu código fuente recursivamente en busca de "
"declaraciones import (en ambas formas) y buscando los módulos en la ruta "
"estándar de Python así como en el directorio fuente (para los módulos "
"incorporados).  A continuación, convierte el código de bytes de los módulos "
"escritos en Python en código C (inicializadores de matrices que pueden "
"convertirse en objetos de código utilizando el módulo marshal) y crea un "
"archivo de configuración personalizado que sólo contiene los módulos "
"incorporados que se utilizan realmente en el programa.  Luego compila el "
"código C generado y lo enlaza con el resto del intérprete de Python para "
"formar un binario autocontenido que actúa exactamente como tu script."

#: ../../faq/programming.rst:96
msgid ""
"The following packages can help with the creation of console and GUI "
"executables:"
msgstr ""
"Los siguientes paquetes pueden ayudar a crear ejecutables de consola y GUI:"

#: ../../faq/programming.rst:99
msgid "`Nuitka <https://nuitka.net/>`_ (Cross-platform)"
msgstr "`Nuitka <https://nuitka.net/>`_ (Multiplataforma)"

#: ../../faq/programming.rst:100
msgid "`PyInstaller <https://pyinstaller.org/>`_ (Cross-platform)"
msgstr "`PyInstaller <https://pyinstaller.org/>`_ (Multiplataforma)"

#: ../../faq/programming.rst:101
msgid ""
"`PyOxidizer <https://pyoxidizer.readthedocs.io/en/stable/>`_ (Cross-platform)"
msgstr ""
"`PyOxidizer <https://pyoxidizer.readthedocs.io/en/stable/>`_ "
"(Multiplataforma)"

#: ../../faq/programming.rst:102
msgid ""
"`cx_Freeze <https://marcelotduarte.github.io/cx_Freeze/>`_ (Cross-platform)"
msgstr ""
"`cx_Freeze <https://marcelotduarte.github.io/cx_Freeze/>`_ (Multiplataforma)"

#: ../../faq/programming.rst:103
msgid "`py2app <https://github.com/ronaldoussoren/py2app>`_ (macOS only)"
msgstr "`py2app <https://github.com/ronaldoussoren/py2app>`_ (sólo para macOS)"

#: ../../faq/programming.rst:104
msgid "`py2exe <https://www.py2exe.org/>`_ (Windows only)"
msgstr "`py2exe <https://www.py2exe.org/>`_ (sólo Windows)"

#: ../../faq/programming.rst:107
msgid "Are there coding standards or a style guide for Python programs?"
msgstr ""
"¿Existen normas de codificación o una guía de estilo para los programas en "
"Python?"

#: ../../faq/programming.rst:109
msgid ""
"Yes.  The coding style required for standard library modules is documented "
"as :pep:`8`."
msgstr ""
"Sí. El estilo de codificación requerido para los módulos de la biblioteca "
"estándar está documentado como :pep:`8`."

#: ../../faq/programming.rst:114
msgid "Core Language"
msgstr "Lengua básica"

#: ../../faq/programming.rst:119
msgid "Why am I getting an UnboundLocalError when the variable has a value?"
msgstr ""
"¿Por qué recibo un UnboundLocalError cuando la variable tiene un valor?"

#: ../../faq/programming.rst:121
msgid ""
"It can be a surprise to get the :exc:`UnboundLocalError` in previously "
"working code when it is modified by adding an assignment statement somewhere "
"in the body of a function."
msgstr ""
"Puede ser una sorpresa obtener el :exc:`UnboundLocalError` en código que "
"funcionaba previamente cuando se modifica añadiendo una sentencia de "
"asignación en algún lugar del cuerpo de una función."

#: ../../faq/programming.rst:125
msgid "This code:"
msgstr "Este código:"

#: ../../faq/programming.rst:134
msgid "works, but this code:"
msgstr "funciona, pero este código:"

#: ../../faq/programming.rst:141
msgid "results in an :exc:`!UnboundLocalError`:"
msgstr "resulta en un :exc:`!UnboundLocalError`:"

#: ../../faq/programming.rst:148
msgid ""
"This is because when you make an assignment to a variable in a scope, that "
"variable becomes local to that scope and shadows any similarly named "
"variable in the outer scope.  Since the last statement in foo assigns a new "
"value to ``x``, the compiler recognizes it as a local variable.  "
"Consequently when the earlier ``print(x)`` attempts to print the "
"uninitialized local variable and an error results."
msgstr ""
"Esto es porque cuando haces una asignación a una variable en un ámbito, esa "
"variable se convierte en local para ese ámbito y hace sombra a cualquier "
"variable de nombre similar en el ámbito externo.  Como la última sentencia "
"de foo asigna un nuevo valor a ``x``, el compilador la reconoce como una "
"variable local.  En consecuencia, cuando el anterior ``print(x)`` intenta "
"imprimir la variable local no inicializada y se produce un error."

#: ../../faq/programming.rst:155
msgid ""
"In the example above you can access the outer scope variable by declaring it "
"global:"
msgstr ""
"En el ejemplo anterior puedes acceder a la variable de ámbito externo "
"declarándola global:"

#: ../../faq/programming.rst:167
msgid ""
"This explicit declaration is required in order to remind you that (unlike "
"the superficially analogous situation with class and instance variables) you "
"are actually modifying the value of the variable in the outer scope:"
msgstr ""
"Esta declaración explícita es necesaria para recordarle que (a diferencia de "
"la situación superficialmente análoga con las variables de clase y de "
"instancia) en realidad está modificando el valor de la variable en el ámbito "
"externo:"

#: ../../faq/programming.rst:174
msgid ""
"You can do a similar thing in a nested scope using the :keyword:`nonlocal` "
"keyword:"
msgstr ""
"Puede hacer algo similar en un ámbito anidado utilizando la palabra clave :"
"keyword:`nonlocal`:"

#: ../../faq/programming.rst:192
msgid "What are the rules for local and global variables in Python?"
msgstr ""
"¿Cuáles son las reglas para las variables locales y globales en Python?"

#: ../../faq/programming.rst:194
msgid ""
"In Python, variables that are only referenced inside a function are "
"implicitly global.  If a variable is assigned a value anywhere within the "
"function's body, it's assumed to be a local unless explicitly declared as "
"global."
msgstr ""
"En Python, las variables a las que sólo se hace referencia dentro de una "
"función son implícitamente globales.  Si a una variable se le asigna un "
"valor en cualquier lugar dentro del cuerpo de la función, se asume que es "
"local a menos que se declare explícitamente como global."

#: ../../faq/programming.rst:198
msgid ""
"Though a bit surprising at first, a moment's consideration explains this.  "
"On one hand, requiring :keyword:`global` for assigned variables provides a "
"bar against unintended side-effects.  On the other hand, if ``global`` was "
"required for all global references, you'd be using ``global`` all the time.  "
"You'd have to declare as global every reference to a built-in function or to "
"a component of an imported module.  This clutter would defeat the usefulness "
"of the ``global`` declaration for identifying side-effects."
msgstr ""
"Aunque a primera vista resulte un poco sorprendente, un momento de reflexión "
"lo explica.  Por un lado, requerir :keyword:`global` para las variables "
"asignadas proporciona una barrera contra efectos secundarios no deseados.  "
"Por otro lado, si se exigiera ``global`` para todas las referencias "
"globales, se estaría utilizando ``global`` todo el tiempo.  Tendrías que "
"declarar como global cada referencia a una función incorporada o a un "
"componente de un módulo importado.  Este desorden anularía la utilidad de la "
"declaración ``global`` para identificar efectos secundarios."

#: ../../faq/programming.rst:208
msgid ""
"Why do lambdas defined in a loop with different values all return the same "
"result?"
msgstr ""
"¿Por qué las lambdas definidas en un bucle con valores diferentes devuelven "
"todas el mismo resultado?"

#: ../../faq/programming.rst:210
msgid ""
"Assume you use a for loop to define a few different lambdas (or even plain "
"functions), e.g.::"
msgstr ""
"Supongamos que utiliza un bucle for para definir varias lambdas diferentes "
"(o incluso funciones simples), por ejemplo::"

#: ../../faq/programming.rst:213
msgid ""
">>> squares = []\n"
">>> for x in range(5):\n"
"...     squares.append(lambda: x**2)"
msgstr ""
">>> squares = []\n"
">>> for x in range(5):\n"
"...     squares.append(lambda: x**2)"

#: ../../faq/programming.rst:217
msgid ""
"This gives you a list that contains 5 lambdas that calculate ``x**2``.  You "
"might expect that, when called, they would return, respectively, ``0``, "
"``1``, ``4``, ``9``, and ``16``.  However, when you actually try you will "
"see that they all return ``16``::"
msgstr ""
"Esto le da una lista que contiene 5 lambdas que calculan ``x**2``.  Podrías "
"esperar que, al llamarlas, devolvieran, respectivamente, ``0``, ``1``, "
"``4``, ``9``, y ``16``. Sin embargo, cuando lo intentes verás que todas "
"devuelven ``16``::"

#: ../../faq/programming.rst:222
msgid ""
">>> squares[2]()\n"
"16\n"
">>> squares[4]()\n"
"16"
msgstr ""
">>> squares[2]()\n"
"16\n"
">>> squares[4]()\n"
"16"

#: ../../faq/programming.rst:227
msgid ""
"This happens because ``x`` is not local to the lambdas, but is defined in "
"the outer scope, and it is accessed when the lambda is called --- not when "
"it is defined.  At the end of the loop, the value of ``x`` is ``4``, so all "
"the functions now return ``4**2``, i.e. ``16``.  You can also verify this by "
"changing the value of ``x`` and see how the results of the lambdas change::"
msgstr ""
"Esto ocurre porque ``x`` no es local a las lambdas, sino que está definido "
"en el ámbito externo, y se accede a él cuando se llama a la lambda --- no "
"cuando se define.  Al final del bucle, el valor de ``x`` es ``4``, por lo "
"que ahora todas las funciones devuelven ``4**2``, es decir ``16``.  También "
"puedes comprobarlo cambiando el valor de ``x`` y ver cómo cambian los "
"resultados de las lambdas::"

#: ../../faq/programming.rst:233
msgid ""
">>> x = 8\n"
">>> squares[2]()\n"
"64"
msgstr ""
">>> x = 8\n"
">>> squares[2]()\n"
"64"

#: ../../faq/programming.rst:237
msgid ""
"In order to avoid this, you need to save the values in variables local to "
"the lambdas, so that they don't rely on the value of the global ``x``::"
msgstr ""
"Para evitar esto, es necesario guardar los valores en variables locales a "
"las lambdas, para que no dependan del valor de la global ``x``::"

#: ../../faq/programming.rst:240
msgid ""
">>> squares = []\n"
">>> for x in range(5):\n"
"...     squares.append(lambda n=x: n**2)"
msgstr ""
">>> squares = []\n"
">>> for x in range(5):\n"
"...     squares.append(lambda n=x: n**2)"

#: ../../faq/programming.rst:244
msgid ""
"Here, ``n=x`` creates a new variable ``n`` local to the lambda and computed "
"when the lambda is defined so that it has the same value that ``x`` had at "
"that point in the loop.  This means that the value of ``n`` will be ``0`` in "
"the first lambda, ``1`` in the second, ``2`` in the third, and so on. "
"Therefore each lambda will now return the correct result::"
msgstr ""
"Aquí, ``n=x`` crea una nueva variable ``n`` local a la lambda y computada "
"cuando se define la lambda para que tenga el mismo valor que ``x`` tenía en "
"ese punto del bucle.  Esto significa que el valor de ``n`` será ``0`` en la "
"primera lambda, ``1`` en la segunda, ``2`` en la tercera, y así "
"sucesivamente. Por lo tanto cada lambda devolverá ahora el resultado "
"correcto::"

#: ../../faq/programming.rst:250
msgid ""
">>> squares[2]()\n"
"4\n"
">>> squares[4]()\n"
"16"
msgstr ""
">>> squares[2]()\n"
"4\n"
">>> squares[4]()\n"
"16"

#: ../../faq/programming.rst:255
msgid ""
"Note that this behaviour is not peculiar to lambdas, but applies to regular "
"functions too."
msgstr ""
"Tenga en cuenta que este comportamiento no es propio de las lambdas, sino "
"que también se aplica a las funciones normales."

#: ../../faq/programming.rst:260
msgid "How do I share global variables across modules?"
msgstr "¿Cómo comparto variables globales entre módulos?"

#: ../../faq/programming.rst:262
msgid ""
"The canonical way to share information across modules within a single "
"program is to create a special module (often called config or cfg).  Just "
"import the config module in all modules of your application; the module then "
"becomes available as a global name.  Because there is only one instance of "
"each module, any changes made to the module object get reflected "
"everywhere.  For example:"
msgstr ""
"La forma canónica de compartir información entre módulos dentro de un mismo "
"programa es crear un módulo especial (a menudo llamado config o cfg).  Sólo "
"tienes que importar el módulo config en todos los módulos de tu aplicación; "
"el módulo pasa entonces a estar disponible como nombre global.  Dado que "
"sólo hay una instancia de cada módulo, cualquier cambio realizado en el "
"objeto del módulo se refleja en todas partes.  Por ejemplo:"

#: ../../faq/programming.rst:268
msgid "config.py::"
msgstr "config.py::"

#: ../../faq/programming.rst:270
msgid "x = 0   # Default value of the 'x' configuration setting"
msgstr "x = 0 # Valor por defecto del ajuste de configuración 'x'"

#: ../../faq/programming.rst:272
msgid "mod.py::"
msgstr "mod.py::"

#: ../../faq/programming.rst:274
msgid ""
"import config\n"
"config.x = 1"
msgstr ""
"import config\n"
"config.x = 1"

#: ../../faq/programming.rst:277
msgid "main.py::"
msgstr "main.py::"

#: ../../faq/programming.rst:279
msgid ""
"import config\n"
"import mod\n"
"print(config.x)"
msgstr ""
"import config\n"
"import mod\n"
"print(config.x)"

#: ../../faq/programming.rst:283
msgid ""
"Note that using a module is also the basis for implementing the singleton "
"design pattern, for the same reason."
msgstr ""
"Tenga en cuenta que el uso de un módulo es también la base para implementar "
"el patrón de diseño singleton, por la misma razón."

#: ../../faq/programming.rst:288
msgid "What are the \"best practices\" for using import in a module?"
msgstr ""
"¿Cuáles son las \"mejores prácticas\" para utilizar la importación en un "
"módulo?"

#: ../../faq/programming.rst:290
msgid ""
"In general, don't use ``from modulename import *``.  Doing so clutters the "
"importer's namespace, and makes it much harder for linters to detect "
"undefined names."
msgstr ""
"En general, no utilice ``from modulename import *``.  Si lo haces, el "
"espacio de nombres del importador se verá saturado y será mucho más difícil "
"para los analizadores detectar nombres indefinidos."

#: ../../faq/programming.rst:294
msgid ""
"Import modules at the top of a file.  Doing so makes it clear what other "
"modules your code requires and avoids questions of whether the module name "
"is in scope. Using one import per line makes it easy to add and delete "
"module imports, but using multiple imports per line uses less screen space."
msgstr ""
"Importe módulos al principio de un archivo.  De este modo, queda claro qué "
"otros módulos necesita el código y se evitan las dudas sobre si el nombre "
"del módulo está dentro del ámbito. Utilizar una importación por línea "
"facilita añadir y eliminar importaciones de módulos, pero utilizar varias "
"importaciones por línea ocupa menos espacio en pantalla."

#: ../../faq/programming.rst:299
msgid "It's good practice if you import modules in the following order:"
msgstr "Es una buena práctica importar los módulos en el siguiente orden:"

#: ../../faq/programming.rst:301
msgid ""
"standard library modules -- e.g. :mod:`sys`, :mod:`os`, :mod:`argparse`, :"
"mod:`re`"
msgstr ""
"módulos de biblioteca estándar -- por ejemplo :mod:`sys`, :mod:`os`, :mod:"
"`argparse`, :mod:`re`"

#: ../../faq/programming.rst:302
msgid ""
"third-party library modules (anything installed in Python's site-packages "
"directory) -- e.g. :mod:`!dateutil`, :mod:`!requests`, :mod:`!PIL.Image`"
msgstr ""
"módulos de bibliotecas de terceros (cualquier cosa instalada en el "
"directorio site-packages de Python) -- por ejemplo :mod:`!dateutil`, :mod:`!"
"requests`, :mod:`!PIL.Image`"

#: ../../faq/programming.rst:304
msgid "locally developed modules"
msgstr "módulos desarrollados localmente"

#: ../../faq/programming.rst:306
msgid ""
"It is sometimes necessary to move imports to a function or class to avoid "
"problems with circular imports.  Gordon McMillan says:"
msgstr ""
"A veces es necesario mover las importaciones a una función o clase para "
"evitar problemas con las importaciones circulares.  Gordon McMillan dice:"

#: ../../faq/programming.rst:309
msgid ""
"Circular imports are fine where both modules use the \"import <module>\" "
"form of import.  They fail when the 2nd module wants to grab a name out of "
"the first (\"from module import name\") and the import is at the top level.  "
"That's because names in the 1st are not yet available, because the first "
"module is busy importing the 2nd."
msgstr ""
"Las importaciones circulares están bien cuando ambos módulos utilizan la "
"forma de importación \"import <module>\".  Fallan cuando el 2º módulo quiere "
"coger un nombre del primero (\"from module import name\") y la importación "
"está en el nivel superior.  Esto se debe a que los nombres en el 1er módulo "
"aún no están disponibles, porque el primer módulo está ocupado importando el "
"segundo."

#: ../../faq/programming.rst:315
msgid ""
"In this case, if the second module is only used in one function, then the "
"import can easily be moved into that function.  By the time the import is "
"called, the first module will have finished initializing, and the second "
"module can do its import."
msgstr ""
"En este caso, si el segundo módulo sólo se utiliza en una función, entonces "
"la importación se puede mover fácilmente a esa función.  En el momento en "
"que se llama a la importación, el primer módulo habrá terminado de "
"inicializarse, y el segundo módulo puede hacer su importación."

#: ../../faq/programming.rst:320
msgid ""
"It may also be necessary to move imports out of the top level of code if "
"some of the modules are platform-specific.  In that case, it may not even be "
"possible to import all of the modules at the top of the file.  In this case, "
"importing the correct modules in the corresponding platform-specific code is "
"a good option."
msgstr ""
"También puede ser necesario mover las importaciones fuera del nivel superior "
"de código si algunos de los módulos son específicos de la plataforma.  En "
"ese caso, puede que ni siquiera sea posible importar todos los módulos en la "
"parte superior del archivo.  En este caso, importar los módulos correctos en "
"el código específico de la plataforma correspondiente es una buena opción."

#: ../../faq/programming.rst:325
msgid ""
"Only move imports into a local scope, such as inside a function definition, "
"if it's necessary to solve a problem such as avoiding a circular import or "
"are trying to reduce the initialization time of a module.  This technique is "
"especially helpful if many of the imports are unnecessary depending on how "
"the program executes.  You may also want to move imports into a function if "
"the modules are only ever used in that function.  Note that loading a module "
"the first time may be expensive because of the one time initialization of "
"the module, but loading a module multiple times is virtually free, costing "
"only a couple of dictionary lookups.  Even if the module name has gone out "
"of scope, the module is probably available in :data:`sys.modules`."
msgstr ""
"Sólo mueva las importaciones a un ámbito local, como dentro de una "
"definición de función, si es necesario para resolver un problema como evitar "
"una importación circular o si está intentando reducir el tiempo de "
"inicialización de un módulo.  Esta técnica es especialmente útil si muchas "
"de las importaciones son innecesarias dependiendo de cómo se ejecute el "
"programa.  También es posible que desee mover las importaciones a una "
"función si los módulos sólo se utilizan en esa función.  Tenga en cuenta que "
"cargar un módulo la primera vez puede ser costoso debido a la inicialización "
"única del módulo, pero cargar un módulo varias veces es prácticamente "
"gratis, costando sólo un par de búsquedas en el diccionario.  Incluso si el "
"nombre del módulo ha salido del ámbito, el módulo está probablemente "
"disponible en :data:`sys.modules`."

#: ../../faq/programming.rst:338
msgid "Why are default values shared between objects?"
msgstr "¿Por qué se comparten valores por defecto entre objetos?"

#: ../../faq/programming.rst:340
msgid ""
"This type of bug commonly bites neophyte programmers.  Consider this "
"function::"
msgstr ""
"Este tipo de error suele afectar a los programadores neófitos.  Considere "
"esta función::"

#: ../../faq/programming.rst:342
msgid ""
"def foo(mydict={}):  # Danger: shared reference to one dict for all calls\n"
"    ... compute something ...\n"
"    mydict[key] = value\n"
"    return mydict"
msgstr ""
"def foo(mydict={}):  # Peligro: referencia compartida a un dict para todas "
"las llamadas\n"
"    ... calcula algo ...\n"
"    mydict[key] = value\n"
"    return mydict"

#: ../../faq/programming.rst:347
msgid ""
"The first time you call this function, ``mydict`` contains a single item.  "
"The second time, ``mydict`` contains two items because when ``foo()`` begins "
"executing, ``mydict`` starts out with an item already in it."
msgstr ""
"La primera vez que se llama a esta función, ``mydict`` contiene un único "
"elemento.  La segunda vez, ``mydict`` contiene dos elementos porque cuando "
"``foo()`` comienza a ejecutarse, ``mydict`` comienza con un elemento ya en "
"él."

#: ../../faq/programming.rst:351
msgid ""
"It is often expected that a function call creates new objects for default "
"values. This is not what happens. Default values are created exactly once, "
"when the function is defined.  If that object is changed, like the "
"dictionary in this example, subsequent calls to the function will refer to "
"this changed object."
msgstr ""
"A menudo se espera que una llamada a una función cree nuevos objetos para "
"los valores por defecto. Esto no es lo que ocurre. Los valores por defecto "
"se crean exactamente una vez, cuando se define la función.  Si ese objeto se "
"modifica, como el diccionario en este ejemplo, las llamadas posteriores a la "
"función harán referencia a este objeto modificado."

#: ../../faq/programming.rst:356
msgid ""
"By definition, immutable objects such as numbers, strings, tuples, and "
"``None``, are safe from change. Changes to mutable objects such as "
"dictionaries, lists, and class instances can lead to confusion."
msgstr ""
"Por definición, los objetos inmutables, como números, cadenas, tuplas y "
"``None``, están a salvo de cambios. Los cambios en objetos mutables, como "
"diccionarios, listas e instancias de clases, pueden dar lugar a confusión."

#: ../../faq/programming.rst:360
msgid ""
"Because of this feature, it is good programming practice to not use mutable "
"objects as default values.  Instead, use ``None`` as the default value and "
"inside the function, check if the parameter is ``None`` and create a new "
"list/dictionary/whatever if it is.  For example, don't write::"
msgstr ""
"Debido a esta característica, es una buena práctica de programación no "
"utilizar objetos mutables como valores por defecto.  En su lugar, utilice "
"``None`` como valor por defecto y dentro de la función, compruebe si el "
"parámetro es ``None`` y cree una nueva lista/diccionario/lo que sea si lo "
"es.  Por ejemplo, no escriba::"

#: ../../faq/programming.rst:365
msgid ""
"def foo(mydict={}):\n"
"    ..."
msgstr ""
"def foo(mydict={}):\n"
"    ..."

#: ../../faq/programming.rst:368
msgid "but::"
msgstr "pero::"

#: ../../faq/programming.rst:370
msgid ""
"def foo(mydict=None):\n"
"    if mydict is None:\n"
"        mydict = {}  # create a new dict for local namespace"
msgstr ""
"def foo(mydict=None):\n"
"    if mydict is None:\n"
"        mydict = {}  # crear un nuevo dict para el espacio de nombres local"

#: ../../faq/programming.rst:374
msgid ""
"This feature can be useful.  When you have a function that's time-consuming "
"to compute, a common technique is to cache the parameters and the resulting "
"value of each call to the function, and return the cached value if the same "
"value is requested again.  This is called \"memoizing\", and can be "
"implemented like this::"
msgstr ""
"Esta función puede ser útil.  Cuando se tiene una función que lleva mucho "
"tiempo calcular, una técnica común es almacenar en caché los parámetros y el "
"valor resultante de cada llamada a la función, y devolver el valor "
"almacenado en caché si se vuelve a solicitar el mismo valor.  Esto se llama "
"\"memoizing\", y se puede implementar de la siguiente manera::"

#: ../../faq/programming.rst:379
msgid ""
"# Callers can only provide two parameters and optionally pass _cache by "
"keyword\n"
"def expensive(arg1, arg2, *, _cache={}):\n"
"    if (arg1, arg2) in _cache:\n"
"        return _cache[(arg1, arg2)]\n"
"\n"
"    # Calculate the value\n"
"    result = ... expensive computation ...\n"
"    _cache[(arg1, arg2)] = result           # Store result in the cache\n"
"    return result"
msgstr ""
"# Callers sólo pueden proporcionar dos parámetros y opcionalmente pass "
"_cache por palabra clave\n"
"def expensive(arg1, arg2, *, _cache={}):\n"
"    if (arg1, arg2) in _cache:\n"
"        return _cache[(arg1, arg2)]\n"
"\n"
"    # Calcular el valor\n"
"    result = ... expensive computation ...\n"
"    _cache[(arg1, arg2)] = result # Almacenar el resultado en la caché\n"
"   return result"

#: ../../faq/programming.rst:389
msgid ""
"You could use a global variable containing a dictionary instead of the "
"default value; it's a matter of taste."
msgstr ""
"Puedes utilizar una variable global que contenga un diccionario en lugar del "
"valor por defecto; es cuestión de gustos."

#: ../../faq/programming.rst:394
msgid ""
"How can I pass optional or keyword parameters from one function to another?"
msgstr ""
"¿Cómo puedo pasar parámetros opcionales o de palabra clave de una función a "
"otra?"

#: ../../faq/programming.rst:396
msgid ""
"Collect the arguments using the ``*`` and ``**`` specifiers in the "
"function's parameter list; this gives you the positional arguments as a "
"tuple and the keyword arguments as a dictionary.  You can then pass these "
"arguments when calling another function by using ``*`` and ``**``::"
msgstr ""
"Recopile los argumentos utilizando los especificadores ``*`` y ``**`` en la "
"lista de parámetros de la función; esto le proporciona los argumentos "
"posicionales como una tupla y los argumentos de palabra clave como un "
"diccionario.  A continuación, puede pasar estos argumentos al llamar a otra "
"función utilizando ``*`` y ``**``::"

#: ../../faq/programming.rst:401
msgid ""
"def f(x, *args, **kwargs):\n"
"    ...\n"
"    kwargs['width'] = '14.3c'\n"
"    ...\n"
"    g(x, *args, **kwargs)"
msgstr ""
"def f(x, *args, **kwargs):\n"
"    ...\n"
"    kwargs['anchura'] = '14.3c'\n"
"    ...\n"
"    g(x, *args, **kwargs)"

#: ../../faq/programming.rst:415
msgid "What is the difference between arguments and parameters?"
msgstr "¿Cuál es la diferencia entre argumentos y parámetros?"

#: ../../faq/programming.rst:417
msgid ""
":term:`Parameters <parameter>` are defined by the names that appear in a "
"function definition, whereas :term:`arguments <argument>` are the values "
"actually passed to a function when calling it.  Parameters define what :term:"
"`kind of arguments <parameter>` a function can accept.  For example, given "
"the function definition::"
msgstr ""
":term:`Parameters <parameter>` se definen por los nombres que aparecen en la "
"definición de una función, mientras que :term:`arguments <argument>` son los "
"valores que se pasan realmente a una función al llamarla.  Los parámetros "
"definen qué :term:`kind of arguments <parameter>` puede aceptar una "
"función.  Por ejemplo, dada la definición de función::"

#: ../../faq/programming.rst:423
msgid ""
"def func(foo, bar=None, **kwargs):\n"
"    pass"
msgstr ""
"def func(foo, bar=None, **kwargs):\n"
"    pass"

#: ../../faq/programming.rst:426
msgid ""
"*foo*, *bar* and *kwargs* are parameters of ``func``.  However, when calling "
"``func``, for example::"
msgstr ""
"*foo*, *bar* y *kwargs* son parámetros de ``func``. Sin embargo, al llamar a "
"``func``, por ejemplo::"

#: ../../faq/programming.rst:429
msgid "func(42, bar=314, extra=somevar)"
msgstr "func(42, bar=314, extra=somevar)"

#: ../../faq/programming.rst:431
msgid "the values ``42``, ``314``, and ``somevar`` are arguments."
msgstr "los valores ``42``, ``314``, y ``somevar`` son argumentos."

#: ../../faq/programming.rst:435
msgid "Why did changing list 'y' also change list 'x'?"
msgstr "¿Por qué al cambiar la lista \"y\" también ha cambiado la lista \"x\"?"

#: ../../faq/programming.rst:437
msgid "If you wrote code like::"
msgstr "Si escribieras código como::"

#: ../../faq/programming.rst:439
msgid ""
">>> x = []\n"
">>> y = x\n"
">>> y.append(10)\n"
">>> y\n"
"[10]\n"
">>> x\n"
"[10]"
msgstr ""
">>> x = []\n"
">>> y = x\n"
">>> y.append(10)\n"
">>> y\n"
"[10]\n"
">>> x\n"
"[10]"

#: ../../faq/programming.rst:447
msgid ""
"you might be wondering why appending an element to ``y`` changed ``x`` too."
msgstr ""
"quizá se pregunte por qué al añadir un elemento a ``y`` también ha cambiado "
"``x``."

#: ../../faq/programming.rst:449
msgid "There are two factors that produce this result:"
msgstr "Hay dos factores que producen este resultado:"

#: ../../faq/programming.rst:451
msgid ""
"Variables are simply names that refer to objects.  Doing ``y = x`` doesn't "
"create a copy of the list -- it creates a new variable ``y`` that refers to "
"the same object ``x`` refers to.  This means that there is only one object "
"(the list), and both ``x`` and ``y`` refer to it."
msgstr ""
"Las variables son simplemente nombres que se refieren a objetos.  Hacer ``y "
"= x`` no crea una copia de la lista -- crea una nueva variable ``y`` que se "
"refiere al mismo objeto al que se refiere ``x``.  Esto significa que sólo "
"hay un objeto (la lista), y tanto ``x`` como ``y`` se refieren a él."

#: ../../faq/programming.rst:455
msgid ""
"Lists are :term:`mutable`, which means that you can change their content."
msgstr ""
"Las listas son :term:`mutable`, lo que significa que puedes cambiar su "
"contenido."

#: ../../faq/programming.rst:457
msgid ""
"After the call to :meth:`!append`, the content of the mutable object has "
"changed from ``[]`` to ``[10]``.  Since both the variables refer to the same "
"object, using either name accesses the modified value ``[10]``."
msgstr ""
"Tras la llamada a :meth:`!append`, el contenido del objeto mutable ha "
"cambiado de ``[]`` a ``[10]``. Dado que ambas variables hacen referencia al "
"mismo objeto, al utilizar cualquiera de los dos nombres se accede al valor "
"modificado ``[10]``."

#: ../../faq/programming.rst:461
msgid "If we instead assign an immutable object to ``x``::"
msgstr "Si en su lugar asignamos un objeto inmutable a ``x``::"

#: ../../faq/programming.rst:463
msgid ""
">>> x = 5  # ints are immutable\n"
">>> y = x\n"
">>> x = x + 1  # 5 can't be mutated, we are creating a new object here\n"
">>> x\n"
"6\n"
">>> y\n"
"5"
msgstr ""
">>> x = 5 # los ints son inmutables\n"
">>> y = x\n"
">>> x = x + 1 # 5 no se puede mutar, estamos creando un nuevo objeto aquí\n"
">>> x\n"
"6\n"
">>> y\n"
"5"

#: ../../faq/programming.rst:471
msgid ""
"we can see that in this case ``x`` and ``y`` are not equal anymore.  This is "
"because integers are :term:`immutable`, and when we do ``x = x + 1`` we are "
"not mutating the int ``5`` by incrementing its value; instead, we are "
"creating a new object (the int ``6``) and assigning it to ``x`` (that is, "
"changing which object ``x`` refers to).  After this assignment we have two "
"objects (the ints ``6`` and ``5``) and two variables that refer to them "
"(``x`` now refers to ``6`` but ``y`` still refers to ``5``)."
msgstr ""
"podemos ver que en este caso ``x`` y ``y`` ya no son iguales.  Esto se debe "
"a que los enteros son :term:`inmutables`, y cuando hacemos ``x = x + 1`` no "
"estamos mutando el int ``5`` incrementando su valor, sino que estamos "
"creando un nuevo objeto (el int ``6``) y asignándolo a ``x`` (es decir, "
"cambiando a qué objeto se refiere ``x`` ).  Después de esta asignación "
"tenemos dos objetos (los int ``6`` y ``5``) y dos variables que hacen "
"referencia a ellos (``x`` ahora hace referencia a ``6`` pero ``y`` sigue "
"haciendo referencia a ``5``)."

#: ../../faq/programming.rst:479
msgid ""
"Some operations (for example ``y.append(10)`` and ``y.sort()``) mutate the "
"object, whereas superficially similar operations (for example ``y = y + "
"[10]`` and :func:`sorted(y) <sorted>`) create a new object.  In general in "
"Python (and in all cases in the standard library) a method that mutates an "
"object will return ``None`` to help avoid getting the two types of "
"operations confused.  So if you mistakenly write ``y.sort()`` thinking it "
"will give you a sorted copy of ``y``, you'll instead end up with ``None``, "
"which will likely cause your program to generate an easily diagnosed error."
msgstr ""
"Algunas operaciones (por ejemplo ``y.append(10)`` y ``y.sort()``) mutan el "
"objeto, mientras que operaciones superficialmente similares (por ejemplo ``y "
"= y + [10]`` y :func:`sorted(y) <sorted>`) crean un nuevo objeto.  En "
"general en Python (y en todos los casos en la biblioteca estándar) un método "
"que muta un objeto devolverá ``None`` para ayudar a evitar confundir los dos "
"tipos de operaciones.  Así que si escribes erróneamente ``y.sort()`` "
"pensando que te dará una copia ordenada de ``y``, en su lugar acabarás con "
"``None``, lo que probablemente hará que tu programa genere un error "
"fácilmente diagnosticable."

#: ../../faq/programming.rst:488
msgid ""
"However, there is one class of operations where the same operation sometimes "
"has different behaviors with different types:  the augmented assignment "
"operators.  For example, ``+=`` mutates lists but not tuples or ints "
"(``a_list += [1, 2, 3]`` is equivalent to ``a_list.extend([1, 2, 3])`` and "
"mutates ``a_list``, whereas ``some_tuple += (1, 2, 3)`` and ``some_int += "
"1`` create new objects)."
msgstr ""
"Sin embargo, hay una clase de operaciones en las que la misma operación "
"tiene a veces comportamientos diferentes con tipos diferentes: los "
"operadores de asignación aumentada.  Por ejemplo, ``+=`` muta listas pero no "
"tuplas o ints (``a_list += [1, 2, 3]`` es equivalente a ``a_list.extend([1, "
"2, 3])`` y muta ``a_list``, mientras que ``some_tuple += (1, 2, 3)`` y "
"``some_int += 1`` crean nuevos objetos)."

#: ../../faq/programming.rst:495
msgid "In other words:"
msgstr "En otras palabras:"

#: ../../faq/programming.rst:497
msgid ""
"If we have a mutable object (:class:`list`, :class:`dict`, :class:`set`, "
"etc.), we can use some specific operations to mutate it and all the "
"variables that refer to it will see the change."
msgstr ""
"Si tenemos un objeto mutable (:class:`list`, :class:`dict`, :class:`set`, "
"etc.), podemos utilizar algunas operaciones específicas para mutarlo y todas "
"las variables que hagan referencia a él verán el cambio."

#: ../../faq/programming.rst:500
msgid ""
"If we have an immutable object (:class:`str`, :class:`int`, :class:`tuple`, "
"etc.), all the variables that refer to it will always see the same value, "
"but operations that transform that value into a new value always return a "
"new object."
msgstr ""
"Si tenemos un objeto inmutable (:class:`str`, :class:`int`, :class:`tuple`, "
"etc.), todas las variables que hagan referencia a él verán siempre el mismo "
"valor, pero las operaciones que transforman ese valor en un nuevo valor "
"siempre devuelven un nuevo objeto."

#: ../../faq/programming.rst:505
msgid ""
"If you want to know if two variables refer to the same object or not, you "
"can use the :keyword:`is` operator, or the built-in function :func:`id`."
msgstr ""
"Si desea saber si dos variables se refieren al mismo objeto o no, puede "
"utilizar el operador :keyword:`is`, o la función incorporada :func:`id`."

#: ../../faq/programming.rst:510
msgid "How do I write a function with output parameters (call by reference)?"
msgstr ""
"¿Cómo escribo una función con parámetros de salida (llamada por referencia)?"

#: ../../faq/programming.rst:512
msgid ""
"Remember that arguments are passed by assignment in Python.  Since "
"assignment just creates references to objects, there's no alias between an "
"argument name in the caller and callee, and so no call-by-reference per se.  "
"You can achieve the desired effect in a number of ways."
msgstr ""
"Recuerda que en Python los argumentos se pasan por asignación.  Dado que la "
"asignación sólo crea referencias a objetos, no hay alias entre un nombre de "
"argumento en el llamante y el llamado, y por lo tanto no hay llamada por "
"referencia per se.  Puedes conseguir el efecto deseado de varias maneras."

#: ../../faq/programming.rst:517
msgid "By returning a tuple of the results::"
msgstr "Devolviendo una tupla de los resultados::"

#: ../../faq/programming.rst:519
msgid ""
">>> def func1(a, b):\n"
"...     a = 'new-value'        # a and b are local names\n"
"...     b = b + 1              # assigned to new objects\n"
"...     return a, b            # return new values\n"
"...\n"
">>> x, y = 'old-value', 99\n"
">>> func1(x, y)\n"
"('new-value', 100)"
msgstr ""
">>> def func1(a, b):\n"
"... a = new-value' # a y b son nombres locales\n"
"... b = b + 1 # asignados a nuevos objetos\n"
"... return a, b # devuelve nuevos valores\n"
"...\n"
">>> x, y =`old-value', 99\n"
">>> func1(x, y)\n"
"('new-value', 100)"

#: ../../faq/programming.rst:528
msgid "This is almost always the clearest solution."
msgstr "Esta es casi siempre la solución más clara."

#: ../../faq/programming.rst:530
msgid ""
"By using global variables.  This isn't thread-safe, and is not recommended."
msgstr ""
"Utilizando variables globales.  Esto no es thread-safe, y no se recomienda."

#: ../../faq/programming.rst:532
msgid "By passing a mutable (changeable in-place) object::"
msgstr "Pasando un objeto mutable (cambiable in situ)::"

#: ../../faq/programming.rst:534
msgid ""
">>> def func2(a):\n"
"...     a[0] = 'new-value'     # 'a' references a mutable list\n"
"...     a[1] = a[1] + 1        # changes a shared object\n"
"...\n"
">>> args = ['old-value', 99]\n"
">>> func2(args)\n"
">>> args\n"
"['new-value', 100]"
msgstr ""
">>> def func2(a):\n"
"... a[0] = 'nuevo-valor' # 'a' hace referencia a una lista mutable\n"
"... a[1] = a[1] + 1 # cambia un objeto compartido\n"
"...\n"
">>> args = ['old-value', 99]\n"
">>> func2(args)\n"
">>> args\n"
"['new-value', 100]"

#: ../../faq/programming.rst:543
msgid "By passing in a dictionary that gets mutated::"
msgstr "Pasando un diccionario que se muta::"

#: ../../faq/programming.rst:545
msgid ""
">>> def func3(args):\n"
"...     args['a'] = 'new-value'     # args is a mutable dictionary\n"
"...     args['b'] = args['b'] + 1   # change it in-place\n"
"...\n"
">>> args = {'a': 'old-value', 'b': 99}\n"
">>> func3(args)\n"
">>> args\n"
"{'a': 'new-value', 'b': 100}"
msgstr ""
">>> def func3(args):\n"
"... args['a'] = 'new-value' # args es un diccionario mutable\n"
"... args['b'] = args['b'] + 1 # cámbialo in situ\n"
"...\n"
">>> args = {'a': 'valor-antiguo', 'b': 99}\n"
">>> func3(args)\n"
">>> args\n"
"{'a': 'new-value', 'b': 100}"

#: ../../faq/programming.rst:554
msgid "Or bundle up values in a class instance::"
msgstr "O agrupar valores en una instancia de clase::"

#: ../../faq/programming.rst:556
msgid ""
">>> class Namespace:\n"
"...     def __init__(self, /, **args):\n"
"...         for key, value in args.items():\n"
"...             setattr(self, key, value)\n"
"...\n"
">>> def func4(args):\n"
"...     args.a = 'new-value'        # args is a mutable Namespace\n"
"...     args.b = args.b + 1         # change object in-place\n"
"...\n"
">>> args = Namespace(a='old-value', b=99)\n"
">>> func4(args)\n"
">>> vars(args)\n"
"{'a': 'new-value', 'b': 100}"
msgstr ""
">>> class Namespace:\n"
"... def __init__(self, /, **args):\n"
"... for key, value in args.items():\n"
"... setattr(self, key, value)\n"
"...\n"
">>> def func4(args):\n"
"... args.a = 'nuevo-valor' # args es un Namespace mutable\n"
"... args.b = args.b + 1 # cambia el objeto in situ\n"
"...\n"
">>> args = Namespace(a='valor-antiguo', b=99)\n"
">>> func4(args)\n"
">>> vars(args)\n"
"{'a': 'new-value, 'b': 100}"

#: ../../faq/programming.rst:571
msgid "There's almost never a good reason to get this complicated."
msgstr "Casi nunca hay una buena razón para complicarse tanto."

#: ../../faq/programming.rst:573
msgid "Your best choice is to return a tuple containing the multiple results."
msgstr ""
"Su mejor opción es devolver una tupla que contenga los resultados múltiples."

#: ../../faq/programming.rst:577
msgid "How do you make a higher order function in Python?"
msgstr "¿Cómo se crea una función de orden superior en Python?"

#: ../../faq/programming.rst:579
msgid ""
"You have two choices: you can use nested scopes or you can use callable "
"objects. For example, suppose you wanted to define ``linear(a,b)`` which "
"returns a function ``f(x)`` that computes the value ``a*x+b``.  Using nested "
"scopes::"
msgstr ""
"Tiene dos opciones: puede utilizar ámbitos anidados o puede utilizar objetos "
"invocables. Por ejemplo, supongamos que desea definir ``linear(a,b)`` que "
"devuelve una función ``f(x)`` que calcula el valor ``a*x+b``.  Usando "
"ámbitos anidados::"

#: ../../faq/programming.rst:583
msgid ""
"def linear(a, b):\n"
"    def result(x):\n"
"        return a * x + b\n"
"    return result"
msgstr ""
"def linear(a, b):\n"
"    def result(x):\n"
"        return a * x + b\n"
"    return result"

#: ../../faq/programming.rst:588
msgid "Or using a callable object::"
msgstr "O utilizando un objeto invocable::"

#: ../../faq/programming.rst:590
msgid ""
"class linear:\n"
"\n"
"    def __init__(self, a, b):\n"
"        self.a, self.b = a, b\n"
"\n"
"    def __call__(self, x):\n"
"        return self.a * x + self.b"
msgstr ""
"class linear:\n"
"\n"
"    def __init__(self, a, b):\n"
"        self.a, self.b = a, b\n"
"\n"
"    def __call__(self, x):\n"
"        return self.a * x + self.b"

#: ../../faq/programming.rst:598
msgid "In both cases, ::"
msgstr "En ambos casos, ::"

#: ../../faq/programming.rst:600
msgid "taxes = linear(0.3, 2)"
msgstr "taxes = linear(0.3, 2)"

#: ../../faq/programming.rst:602
msgid "gives a callable object where ``taxes(10e6) == 0.3 * 10e6 + 2``."
msgstr "da un objeto invocable donde ``taxes(10e6) == 0.3 * 10e6 + 2``."

#: ../../faq/programming.rst:604
msgid ""
"The callable object approach has the disadvantage that it is a bit slower "
"and results in slightly longer code.  However, note that a collection of "
"callables can share their signature via inheritance::"
msgstr ""
"El enfoque de objetos invocables tiene la desventaja de que es un poco más "
"lento y resulta en un código ligeramente más largo.  Sin embargo, ten en "
"cuenta que una colección de objetos invocables puede compartir su firma a "
"través de la herencia::"

#: ../../faq/programming.rst:608
msgid ""
"class exponential(linear):\n"
"    # __init__ inherited\n"
"    def __call__(self, x):\n"
"        return self.a * (x ** self.b)"
msgstr ""
"class exponential(linear):\n"
"    # __init__ inherited\n"
"    def __call__(self, x):\n"
"        return self.a * (x ** self.b)"

#: ../../faq/programming.rst:613
msgid "Object can encapsulate state for several methods::"
msgstr "Objeto puede encapsular el estado de varios métodos::"

#: ../../faq/programming.rst:615
msgid ""
"class counter:\n"
"\n"
"    value = 0\n"
"\n"
"    def set(self, x):\n"
"        self.value = x\n"
"\n"
"    def up(self):\n"
"        self.value = self.value + 1\n"
"\n"
"    def down(self):\n"
"        self.value = self.value - 1\n"
"\n"
"count = counter()\n"
"inc, dec, reset = count.up, count.down, count.set"
msgstr ""
"class counter:\n"
"\n"
"    value = 0\n"
"\n"
"    def set(self, x):\n"
"        self.value = x\n"
"\n"
"    def up(self):\n"
"        self.value = self.value + 1\n"
"\n"
"    def down(self):\n"
"        self.value = self.value - 1\n"
"\n"
"count = counter()\n"
"inc, dec, reset = count.up, count.down, count.set"

#: ../../faq/programming.rst:631
msgid ""
"Here ``inc()``, ``dec()`` and ``reset()`` act like functions which share the "
"same counting variable."
msgstr ""
"Aquí ``inc()``, ``dec()`` y ``reset()`` actúan como funciones que comparten "
"la misma variable de recuento."

#: ../../faq/programming.rst:636
msgid "How do I copy an object in Python?"
msgstr "¿Cómo se copia un objeto en Python?"

#: ../../faq/programming.rst:638
msgid ""
"In general, try :func:`copy.copy` or :func:`copy.deepcopy` for the general "
"case. Not all objects can be copied, but most can."
msgstr ""
"En general, pruebe :func:`copy.copy` o :func:`copy.deepcopy` para el caso "
"general. No todos los objetos pueden copiarse, pero sí la mayoría."

#: ../../faq/programming.rst:641
msgid ""
"Some objects can be copied more easily.  Dictionaries have a :meth:`~dict."
"copy` method::"
msgstr ""
"Algunos objetos se pueden copiar más fácilmente.  Los diccionarios tienen un "
"método :meth:`~dict.copy`::"

#: ../../faq/programming.rst:644
msgid "newdict = olddict.copy()"
msgstr "newdict = olddict.copy()"

#: ../../faq/programming.rst:646
msgid "Sequences can be copied by slicing::"
msgstr "Las secuencias se pueden copiar mediante cortes::"

#: ../../faq/programming.rst:648
msgid "new_l = l[:]"
msgstr "new_l = l[:]"

#: ../../faq/programming.rst:652
msgid "How can I find the methods or attributes of an object?"
msgstr "¿Cómo puedo encontrar los métodos o atributos de un objeto?"

#: ../../faq/programming.rst:654
msgid ""
"For an instance ``x`` of a user-defined class, :func:`dir(x) <dir>` returns "
"an alphabetized list of the names containing the instance attributes and "
"methods and attributes defined by its class."
msgstr ""
"Para una instancia ``x`` de una clase definida por el usuario, :func:`dir(x) "
"<dir>` devuelve una lista alfabetizada de los nombres que contienen los "
"atributos de instancia y los métodos y atributos definidos por su clase."

#: ../../faq/programming.rst:660
msgid "How can my code discover the name of an object?"
msgstr "¿Cómo puede mi código descubrir el nombre de un objeto?"

#: ../../faq/programming.rst:662
msgid ""
"Generally speaking, it can't, because objects don't really have names. "
"Essentially, assignment always binds a name to a value; the same is true of "
"``def`` and ``class`` statements, but in that case the value is a callable. "
"Consider the following code::"
msgstr ""
"En general, no puede, porque los objetos no tienen nombres. Esencialmente, "
"la asignación siempre vincula un nombre a un valor; lo mismo ocurre con las "
"sentencias ``def`` y ``class``, pero en ese caso el valor es un callable. "
"Considere el siguiente código::"

#: ../../faq/programming.rst:667
msgid ""
">>> class A:\n"
"...     pass\n"
"...\n"
">>> B = A\n"
">>> a = B()\n"
">>> b = a\n"
">>> print(b)\n"
"<__main__.A object at 0x16D07CC>\n"
">>> print(a)\n"
"<__main__.A object at 0x16D07CC>"
msgstr ""
">>> class A:\n"
"...     pass\n"
"...\n"
">>> B = A\n"
">>> a = B()\n"
">>> b = a\n"
">>> print(b)\n"
"<__main__.A object at 0x16D07CC>\n"
">>> print(a)\n"
"<__main__.A object at 0x16D07CC>"

#: ../../faq/programming.rst:678
msgid ""
"Arguably the class has a name: even though it is bound to two names and "
"invoked through the name ``B`` the created instance is still reported as an "
"instance of class ``A``.  However, it is impossible to say whether the "
"instance's name is ``a`` or ``b``, since both names are bound to the same "
"value."
msgstr ""
"Podría decirse que la clase tiene un nombre: aunque esté vinculada a dos "
"nombres y se invoque a través del nombre ``B``, la instancia creada se sigue "
"reportando como una instancia de la clase ``A``.  Sin embargo, es imposible "
"decir si el nombre de la instancia es ``a`` o ``b``, ya que ambos nombres "
"están vinculados al mismo valor."

#: ../../faq/programming.rst:683
msgid ""
"Generally speaking it should not be necessary for your code to \"know the "
"names\" of particular values. Unless you are deliberately writing "
"introspective programs, this is usually an indication that a change of "
"approach might be beneficial."
msgstr ""
"En general, no debería ser necesario que tu código \"conozca los nombres\" "
"de determinados valores. A menos que esté escribiendo deliberadamente "
"programas introspectivos, esto suele ser una indicación de que un cambio de "
"enfoque podría ser beneficioso."

#: ../../faq/programming.rst:688
msgid ""
"In comp.lang.python, Fredrik Lundh once gave an excellent analogy in answer "
"to this question:"
msgstr ""
"En comp.lang.python, Fredrik Lundh dio una vez una excelente analogía en "
"respuesta a esta pregunta:"

#: ../../faq/programming.rst:691
msgid ""
"The same way as you get the name of that cat you found on your porch: the "
"cat (object) itself cannot tell you its name, and it doesn't really care -- "
"so the only way to find out what it's called is to ask all your neighbours "
"(namespaces) if it's their cat (object)..."
msgstr ""
"De la misma forma que obtienes el nombre de ese gato que encontraste en tu "
"porche: el gato (objeto) en sí no puede decirte su nombre, y realmente no le "
"importa -- así que la única forma de averiguar cómo se llama es preguntar a "
"todos tus vecinos (namespaces) si es su gato (objeto)..."

#: ../../faq/programming.rst:696
msgid ""
"....and don't be surprised if you'll find that it's known by many names, or "
"no name at all!"
msgstr ""
"....y no se sorprenda si descubre que recibe muchos nombres, ¡o ninguno!"

#: ../../faq/programming.rst:701
msgid "What's up with the comma operator's precedence?"
msgstr "¿Qué pasa con la precedencia del operador coma?"

#: ../../faq/programming.rst:703
msgid "Comma is not an operator in Python.  Consider this session::"
msgstr "La coma no es un operador en Python.  Considere esta sesión::"

#: ../../faq/programming.rst:705
msgid ""
">>> \"a\" in \"b\", \"a\"\n"
"(False, 'a')"
msgstr ""
">>> \"a\" in \"b\", \"a\"\n"
"(False, 'a')"

#: ../../faq/programming.rst:708
msgid ""
"Since the comma is not an operator, but a separator between expressions the "
"above is evaluated as if you had entered::"
msgstr ""
"Dado que la coma no es un operador, sino un separador entre expresiones, lo "
"anterior se evalúa como si hubiera introducido::"

#: ../../faq/programming.rst:711
msgid "(\"a\" in \"b\"), \"a\""
msgstr "(\"a\" en \"b\"), \"a\""

#: ../../faq/programming.rst:713
msgid "not::"
msgstr "no::"

#: ../../faq/programming.rst:715
msgid "\"a\" in (\"b\", \"a\")"
msgstr "\"a\" en (\"b\", \"a\")"

#: ../../faq/programming.rst:717
msgid ""
"The same is true of the various assignment operators (``=``, ``+=`` etc).  "
"They are not truly operators but syntactic delimiters in assignment "
"statements."
msgstr ""
"Lo mismo ocurre con los distintos operadores de asignación (``=``, ``+=`` "
"etc).  No son realmente operadores, sino delimitadores sintácticos en las "
"sentencias de asignación."

#: ../../faq/programming.rst:722
msgid "Is there an equivalent of C's \"?:\" ternary operator?"
msgstr "¿Existe un equivalente del operador ternario \"?:\" de C?"

#: ../../faq/programming.rst:724
msgid "Yes, there is. The syntax is as follows::"
msgstr "Sí, existe. La sintaxis es la siguiente::"

#: ../../faq/programming.rst:726
msgid ""
"[on_true] if [expression] else [on_false]\n"
"\n"
"x, y = 50, 25\n"
"small = x if x < y else y"
msgstr ""
"[on_true] if [expresión] else [on_false]\n"
"\n"
"x, y = 50, 25\n"
"small = x if x < y else y"

#: ../../faq/programming.rst:731
msgid ""
"Before this syntax was introduced in Python 2.5, a common idiom was to use "
"logical operators::"
msgstr ""
"Antes de que se introdujera esta sintaxis en Python 2.5, era habitual "
"utilizar los operadores lógicos::"

#: ../../faq/programming.rst:734
msgid "[expression] and [on_true] or [on_false]"
msgstr "[expression] y [on_true] o [on_false]"

#: ../../faq/programming.rst:736
msgid ""
"However, this idiom is unsafe, as it can give wrong results when *on_true* "
"has a false boolean value.  Therefore, it is always better to use the ``... "
"if ... else ...`` form."
msgstr ""
"Sin embargo, este modismo no es seguro, ya que puede dar resultados erróneos "
"cuando *on_true* tiene un valor booleano falso.  Por lo tanto, siempre es "
"mejor utilizar la forma ``... if ... else ...``."

#: ../../faq/programming.rst:742
msgid "Is it possible to write obfuscated one-liners in Python?"
msgstr "¿Es posible escribir frases de una sola línea ofuscadas en Python?"

#: ../../faq/programming.rst:744
msgid ""
"Yes.  Usually this is done by nesting :keyword:`lambda` within :keyword:`!"
"lambda`.  See the following three examples, slightly adapted from Ulf "
"Bartelt::"
msgstr ""
"Sí.  Normalmente, esto se hace anidando :keyword:`lambda` dentro de :keyword:"
"`!lambda`. Ver los tres ejemplos siguientes, ligeramente adaptados de Ulf "
"Bartelt::"

#: ../../faq/programming.rst:747
msgid ""
"from functools import reduce\n"
"\n"
"# Primes < 1000\n"
"print(list(filter(None,map(lambda y:y*reduce(lambda x,y:x*y!=0,\n"
"map(lambda x,y=y:y%x,range(2,int(pow(y,0.5)+1))),1),range(2,1000)))))\n"
"\n"
"# First 10 Fibonacci numbers\n"
"print(list(map(lambda x,f=lambda x,f:(f(x-1,f)+f(x-2,f)) if x>1 else 1:\n"
"f(x,f), range(10))))\n"
"\n"
"# Mandelbrot set\n"
"print((lambda Ru,Ro,Iu,Io,IM,Sx,Sy:reduce(lambda x,y:x+'\\n'+y,map(lambda "
"y,\n"
"Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,Sy=Sy,L=lambda yc,Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,i=IM,\n"
"Sx=Sx,Sy=Sy:reduce(lambda x,y:x+y,map(lambda x,xc=Ru,yc=yc,Ru=Ru,Ro=Ro,\n"
"i=i,Sx=Sx,F=lambda xc,yc,x,y,k,f=lambda xc,yc,x,y,k,f:(k<=0)or (x*x+y*y\n"
">=4.0) or 1+f(xc,yc,x*x-y*y+xc,2.0*x*y+yc,k-1,f):f(xc,yc,x,y,k,f):chr(\n"
"64+F(Ru+x*(Ro-Ru)/Sx,yc,0,0,i)),range(Sx))):L(Iu+y*(Io-Iu)/Sy),range(Sy\n"
"))))(-2.1, 0.7, -1.2, 1.2, 30, 80, 24))\n"
"#    \\___ ___/  \\___ ___/  |   |   |__ lines on screen\n"
"#        V          V      |   |______ columns on screen\n"
"#        |          |      |__________ maximum of \"iterations\"\n"
"#        |          |_________________ range on y axis\n"
"#        |____________________________ range on x axis"
msgstr ""
"from functools import reduce\n"
"\n"
"# Primes < 1000\n"
"print(list(filter(None,map(lambda y:y*reduce(lambda x,y:x*y!=0,\n"
"map(lambda x,y=y:y%x,range(2,int(pow(y,0.5)+1))),1),range(2,1000)))))\n"
"\n"
"# First 10 Fibonacci numbers\n"
"print(list(map(lambda x,f=lambda x,f:(f(x-1,f)+f(x-2,f)) if x>1 else 1:\n"
"f(x,f), range(10))))\n"
"\n"
"# Mandelbrot set\n"
"print((lambda Ru,Ro,Iu,Io,IM,Sx,Sy:reduce(lambda x,y:x+'\\n'+y,map(lambda "
"y,\n"
"Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,Sy=Sy,L=lambda yc,Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,i=IM,\n"
"Sx=Sx,Sy=Sy:reduce(lambda x,y:x+y,map(lambda x,xc=Ru,yc=yc,Ru=Ru,Ro=Ro,\n"
"i=i,Sx=Sx,F=lambda xc,yc,x,y,k,f=lambda xc,yc,x,y,k,f:(k<=0)or (x*x+y*y\n"
">=4.0) or 1+f(xc,yc,x*x-y*y+xc,2.0*x*y+yc,k-1,f):f(xc,yc,x,y,k,f):chr(\n"
"64+F(Ru+x*(Ro-Ru)/Sx,yc,0,0,i)),range(Sx))):L(Iu+y*(Io-Iu)/Sy),range(Sy\n"
"))))(-2.1, 0.7, -1.2, 1.2, 30, 80, 24))\n"
"#    \\___ ___/  \\___ ___/  |   |   |__ lines on screen\n"
"#        V          V      |   |______ columns on screen\n"
"#        |          |      |__________ maximum of \"iterations\"\n"
"#        |          |_________________ range on y axis\n"
"#        |____________________________ range on x axis"

#: ../../faq/programming.rst:771
msgid "Don't try this at home, kids!"
msgstr "¡No intenten esto en casa, niños!"

#: ../../faq/programming.rst:777
msgid "What does the slash(/) in the parameter list of a function mean?"
msgstr ""
"¿Qué significa la barra oblicua (/) en la lista de parámetros de una función?"

#: ../../faq/programming.rst:779
msgid ""
"A slash in the argument list of a function denotes that the parameters prior "
"to it are positional-only.  Positional-only parameters are the ones without "
"an externally usable name.  Upon calling a function that accepts positional-"
"only parameters, arguments are mapped to parameters based solely on their "
"position. For example, :func:`divmod` is a function that accepts positional-"
"only parameters. Its documentation looks like this::"
msgstr ""
"Una barra oblicua en la lista de argumentos de una función indica que los "
"parámetros que la preceden son sólo posicionales.  Los parámetros sólo "
"posicionales son los que no tienen un nombre utilizable externamente.  Al "
"llamar a una función que acepta parámetros sólo posicionales, los argumentos "
"se asignan a los parámetros basándose únicamente en su posición. Por "
"ejemplo, :func:`divmod` es una función que acepta parámetros sólo "
"posicionales. Su documentación tiene el siguiente aspecto::"

#: ../../faq/programming.rst:786
msgid ""
">>> help(divmod)\n"
"Help on built-in function divmod in module builtins:\n"
"\n"
"divmod(x, y, /)\n"
"    Return the tuple (x//y, x%y).  Invariant: div*y + mod == x."
msgstr ""
">>> help(divmod)\n"
"Ayuda sobre la función incorporada divmod en el módulo builtins:\n"
"\n"
"divmod(x, y, /)\n"
"    Devuelve la tupla (x//y, x%y).  Invariante: div*y + mod == x."

#: ../../faq/programming.rst:792
msgid ""
"The slash at the end of the parameter list means that both parameters are "
"positional-only. Thus, calling :func:`divmod` with keyword arguments would "
"lead to an error::"
msgstr ""
"La barra al final de la lista de parámetros significa que ambos parámetros "
"son sólo posicionales. Por lo tanto, llamar a :func:`divmod` con argumentos "
"de palabra clave daría lugar a un error::"

#: ../../faq/programming.rst:796
msgid ""
">>> divmod(x=3, y=4)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: divmod() takes no keyword arguments"
msgstr ""
">>> divmod(x=3, y=4)\n"
"Traceback (última llamada más reciente):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: divmod() no toma argumentos de palabra clave"

#: ../../faq/programming.rst:803
msgid "Numbers and strings"
msgstr "Números y cadenas"

#: ../../faq/programming.rst:806
msgid "How do I specify hexadecimal and octal integers?"
msgstr "¿Cómo se especifican los números enteros hexadecimales y octales?"

#: ../../faq/programming.rst:808
msgid ""
"To specify an octal digit, precede the octal value with a zero, and then a "
"lower or uppercase \"o\".  For example, to set the variable \"a\" to the "
"octal value \"10\" (8 in decimal), type::"
msgstr ""
"Para especificar un dígito octal, preceda el valor octal con un cero y, a "
"continuación, una \"o\" minúscula o mayúscula.  Por ejemplo, para asignar a "
"la variable \"a\" el valor octal \"10\" (8 en decimal), escriba::"

#: ../../faq/programming.rst:812
msgid ""
">>> a = 0o10\n"
">>> a\n"
"8"
msgstr ""
">>> a = 0o10\n"
">>> a\n"
"8"

#: ../../faq/programming.rst:816
msgid ""
"Hexadecimal is just as easy.  Simply precede the hexadecimal number with a "
"zero, and then a lower or uppercase \"x\".  Hexadecimal digits can be "
"specified in lower or uppercase.  For example, in the Python interpreter::"
msgstr ""
"El hexadecimal es igual de fácil.  Basta con anteponer un cero al número "
"hexadecimal y, a continuación, una \"x\" minúscula o mayúscula.  Los dígitos "
"hexadecimales pueden especificarse en minúsculas o mayúsculas.  Por ejemplo, "
"en el intérprete de Python::"

#: ../../faq/programming.rst:820
msgid ""
">>> a = 0xa5\n"
">>> a\n"
"165\n"
">>> b = 0XB2\n"
">>> b\n"
"178"
msgstr ""
">>> a = 0xa5\n"
">>> a\n"
"165\n"
">>> b = 0XB2\n"
">>> b\n"
"178"

#: ../../faq/programming.rst:829
msgid "Why does -22 // 10 return -3?"
msgstr "¿Por qué -22 // 10 devuelve -3?"

#: ../../faq/programming.rst:831
msgid ""
"It's primarily driven by the desire that ``i % j`` have the same sign as "
"``j``. If you want that, and also want::"
msgstr ""
"Está impulsado principalmente por el deseo de que ``i % j`` tenga el mismo "
"signo que ``j``. Si quiere eso, y también quiere::"

#: ../../faq/programming.rst:834
msgid "i == (i // j) * j + (i % j)"
msgstr "i == (i // j) * j + (i % j)"

#: ../../faq/programming.rst:836
msgid ""
"then integer division has to return the floor.  C also requires that "
"identity to hold, and then compilers that truncate ``i // j`` need to make "
"``i % j`` have the same sign as ``i``."
msgstr ""
"entonces la división entera tiene que devolver el piso.  C también requiere "
"que la identidad se mantenga, y entonces los compiladores que truncan ``i // "
"j`` necesitan hacer que ``i % j`` tenga el mismo signo que ``i``."

#: ../../faq/programming.rst:840
msgid ""
"There are few real use cases for ``i % j`` when ``j`` is negative.  When "
"``j`` is positive, there are many, and in virtually all of them it's more "
"useful for ``i % j`` to be ``>= 0``.  If the clock says 10 now, what did it "
"say 200 hours ago?  ``-190 % 12 == 2`` is useful; ``-190 % 12 == -10`` is a "
"bug waiting to bite."
msgstr ""
"Hay pocos casos reales de uso de ``i % j`` cuando ``j`` es negativo. Cuando "
"``j`` es positivo, hay muchos, y en prácticamente todos ellos es más útil "
"que ``i % j`` sea``>= 0``.  Si el reloj marca las 10 ahora, ¿qué marcaba "
"hace 200 horas? ``-190 % 12 == 2`` es útil; ``-190 % 12 == -10`` es un bug a "
"punto de picar."

#: ../../faq/programming.rst:848
msgid "How do I get int literal attribute instead of SyntaxError?"
msgstr "¿Cómo puedo obtener el atributo int literal en lugar de SyntaxError?"

#: ../../faq/programming.rst:850
msgid ""
"Trying to lookup an ``int`` literal attribute in the normal manner gives a :"
"exc:`SyntaxError` because the period is seen as a decimal point::"
msgstr ""
"Si se intenta buscar un atributo literal ``int`` de la forma habitual, se "
"obtiene :exc:`SyntaxError` porque el punto se considera un punto decimal::"

#: ../../faq/programming.rst:853
msgid ""
">>> 1.__class__\n"
"  File \"<stdin>\", line 1\n"
"  1.__class__\n"
"   ^\n"
"SyntaxError: invalid decimal literal"
msgstr ""
">>> 1.__class__\n"
"  File \"<stdin>\", line 1\n"
"  1.__class__\n"
"   ^\n"
"SyntaxError: invalid decimal literal"

#: ../../faq/programming.rst:859
msgid ""
"The solution is to separate the literal from the period with either a space "
"or parentheses."
msgstr ""
"La solución es separar el literal del punto con un espacio o un paréntesis."

#: ../../faq/programming.rst:869
msgid "How do I convert a string to a number?"
msgstr "¿Cómo convierto una cadena en un número?"

#: ../../faq/programming.rst:871
msgid ""
"For integers, use the built-in :func:`int` type constructor, e.g. "
"``int('144') == 144``.  Similarly, :func:`float` converts to a floating-"
"point number, e.g. ``float('144') == 144.0``."
msgstr ""
"Para números enteros, utilice el constructor de tipo incorporado :func:"
"`int`, por ejemplo ``int('144') == 144``.  Del mismo modo, :func:`float` "
"convierte a un número de punto flotante, por ejemplo ``float('144') == "
"144.0``."

#: ../../faq/programming.rst:875
msgid ""
"By default, these interpret the number as decimal, so that ``int('0144') == "
"144`` holds true, and ``int('0x144')`` raises :exc:`ValueError`. "
"``int(string, base)`` takes the base to convert from as a second optional "
"argument, so ``int( '0x144', 16) == 324``.  If the base is specified as 0, "
"the number is interpreted using Python's rules: a leading '0o' indicates "
"octal, and '0x' indicates a hex number."
msgstr ""
"Por defecto, estos interpretan el número como decimal, por lo que "
"``int('0144') == 144`` es verdadero, y ``int('0x144')`` eleva :exc:"
"`ValueError`. ``int(string, base)`` toma la base de la que convertir como un "
"segundo argumento opcional, por lo que ``int( '0x144', 16) == 324``.  Si la "
"base se especifica como 0, el número se interpreta utilizando las reglas de "
"Python: un '0o' inicial indica octal, y '0x' indica un número hexadecimal."

#: ../../faq/programming.rst:882
msgid ""
"Do not use the built-in function :func:`eval` if all you need is to convert "
"strings to numbers.  :func:`eval` will be significantly slower and it "
"presents a security risk: someone could pass you a Python expression that "
"might have unwanted side effects.  For example, someone could pass "
"``__import__('os').system(\"rm -rf $HOME\")`` which would erase your home "
"directory."
msgstr ""
"No utilice la función incorporada :func:`eval` si todo lo que necesita es "
"convertir cadenas a números. :func:`eval` será significativamente más lenta "
"y presenta un riesgo de seguridad: alguien podría pasarle una expresión "
"Python que podría tener efectos secundarios no deseados.  Por ejemplo, "
"alguien podría pasar ``__import__('os').system(\"rm -rf $HOME\")`` que "
"borraría tu directorio personal."

#: ../../faq/programming.rst:889
msgid ""
":func:`eval` also has the effect of interpreting numbers as Python "
"expressions, so that e.g. ``eval('09')`` gives a syntax error because Python "
"does not allow leading '0' in a decimal number (except '0')."
msgstr ""
":func:`eval` también tiene el efecto de interpretar los números como "
"expresiones de Python, de modo que, por ejemplo, ``eval('09')`` da un error "
"de sintaxis porque Python no permite el '0' inicial en un número decimal "
"(excepto '0')."

#: ../../faq/programming.rst:895
msgid "How do I convert a number to a string?"
msgstr "¿Cómo convierto un número en una cadena?"

#: ../../faq/programming.rst:897
msgid ""
"To convert, e.g., the number ``144`` to the string ``'144'``, use the built-"
"in type constructor :func:`str`.  If you want a hexadecimal or octal "
"representation, use the built-in functions :func:`hex` or :func:`oct`.  For "
"fancy formatting, see the :ref:`f-strings` and :ref:`formatstrings` "
"sections, e.g. ``\"{:04d}\".format(144)`` yields ``'0144'`` and ``\"{:.3f}\"."
"format(1.0/3.0)`` yields ``'0.333'``."
msgstr ""
"Para convertir, por ejemplo, el número ``144`` en la cadena ``'144'``, "
"utilice el constructor de tipos incorporado :func:`str`.  Si desea una "
"representación hexadecimal u octal, utilice las funciones integradas :func:"
"`hex` o :func:`oct`.  Para obtener un formato de fantasía, consulte las "
"secciones :ref:`f-strings` y :ref:`formatstrings`; por ejemplo, ``\"{:04d}\"."
"format(144)`` produce ``'0144'`` y ``\"{:.3f}\".format(1.0/3.0)`` produce "
"``'0.333'``."

#: ../../faq/programming.rst:906
msgid "How do I modify a string in place?"
msgstr "¿Cómo se modifica una cadena in situ?"

#: ../../faq/programming.rst:908
msgid ""
"You can't, because strings are immutable.  In most situations, you should "
"simply construct a new string from the various parts you want to assemble it "
"from.  However, if you need an object with the ability to modify in-place "
"unicode data, try using an :class:`io.StringIO` object or the :mod:`array` "
"module::"
msgstr ""
"No puede, porque las cadenas son inmutables.  En la mayoría de las "
"situaciones, simplemente debe construir una nueva cadena a partir de las "
"distintas partes con las que desea ensamblarla.  Sin embargo, si necesitas "
"un objeto con la capacidad de modificar datos unicode in situ, prueba a "
"utilizar un objeto :class:`io.StringIO` o el módulo :mod:`array`::"

#: ../../faq/programming.rst:914
msgid ""
">>> import io\n"
">>> s = \"Hello, world\"\n"
">>> sio = io.StringIO(s)\n"
">>> sio.getvalue()\n"
"'Hello, world'\n"
">>> sio.seek(7)\n"
"7\n"
">>> sio.write(\"there!\")\n"
"6\n"
">>> sio.getvalue()\n"
"'Hello, there!'\n"
"\n"
">>> import array\n"
">>> a = array.array('u', s)\n"
">>> print(a)\n"
"array('u', 'Hello, world')\n"
">>> a[0] = 'y'\n"
">>> print(a)\n"
"array('u', 'yello, world')\n"
">>> a.tounicode()\n"
"'yello, world'"
msgstr ""
">>> import io\n"
">>> s = \"Hello, world\"\n"
">>> sio = io.StringIO(s)\n"
">>> sio.getvalue()\n"
"'Hello, world'\n"
">>> sio.seek(7)\n"
"7\n"
">>> sio.write(\"there!\")\n"
"6\n"
">>> sio.getvalue()\n"
"'Hello, there!'\n"
"\n"
">>> import array\n"
">>> a = array.array('u', s)\n"
">>> print(a)\n"
"array('u', 'Hello, world')\n"
">>> a[0] = 'y'\n"
">>> print(a)\n"
"array('u', 'yello, world')\n"
">>> a.tounicode()\n"
"'yello, world'"

#: ../../faq/programming.rst:938
msgid "How do I use strings to call functions/methods?"
msgstr "¿Cómo puedo utilizar cadenas para llamar a funciones/métodos?"

#: ../../faq/programming.rst:940
msgid "There are various techniques."
msgstr "Existen varias técnicas."

#: ../../faq/programming.rst:942
msgid ""
"The best is to use a dictionary that maps strings to functions.  The primary "
"advantage of this technique is that the strings do not need to match the "
"names of the functions.  This is also the primary technique used to emulate "
"a case construct::"
msgstr ""
"Lo mejor es utilizar un diccionario que asigne cadenas a funciones.  La "
"principal ventaja de esta técnica es que no es necesario que las cadenas "
"coincidan con los nombres de las funciones.  Esta es también la principal "
"técnica utilizada para emular una construcción case::"

#: ../../faq/programming.rst:947
msgid ""
"def a():\n"
"    pass\n"
"\n"
"def b():\n"
"    pass\n"
"\n"
"dispatch = {'go': a, 'stop': b}  # Note lack of parens for funcs\n"
"\n"
"dispatch[get_input()]()  # Note trailing parens to call function"
msgstr ""
"def a():\n"
"    pass\n"
"\n"
"def b():\n"
"    pass\n"
"\n"
"dispatch = {'go': a, 'stop': b} # Nótese la falta de paréntesis para funcs\n"
"\n"
"dispatch[get_input()]() # Observa los paréntesis finales para llamar a la "
"función"

#: ../../faq/programming.rst:957
msgid "Use the built-in function :func:`getattr`::"
msgstr "Utilice la función integrada :func:`getattr`::"

#: ../../faq/programming.rst:959
msgid ""
"import foo\n"
"getattr(foo, 'bar')()"
msgstr ""
"import foo\n"
"getattr(foo, 'bar')()"

#: ../../faq/programming.rst:962
msgid ""
"Note that :func:`getattr` works on any object, including classes, class "
"instances, modules, and so on."
msgstr ""
"Tenga en cuenta que :func:`getattr` funciona con cualquier objeto, incluidas "
"clases, instancias de clases, módulos, etc."

#: ../../faq/programming.rst:965
msgid "This is used in several places in the standard library, like this::"
msgstr "Esto se utiliza en varios lugares en la biblioteca estándar, así::"

#: ../../faq/programming.rst:967
msgid ""
"class Foo:\n"
"    def do_foo(self):\n"
"        ...\n"
"\n"
"    def do_bar(self):\n"
"        ...\n"
"\n"
"f = getattr(foo_instance, 'do_' + opname)\n"
"f()"
msgstr ""
"class Foo:\n"
"    def do_foo(self):\n"
"        ...\n"
"\n"
"    def do_bar(self):\n"
"        ...\n"
"\n"
"f = getattr(foo_instance, 'do_' + opname)\n"
"f()"

#: ../../faq/programming.rst:978
msgid "Use :func:`locals` to resolve the function name::"
msgstr "Utilice :func:`locals` para resolver el nombre de la función::"

#: ../../faq/programming.rst:980
msgid ""
"def myFunc():\n"
"    print(\"hello\")\n"
"\n"
"fname = \"myFunc\"\n"
"\n"
"f = locals()[fname]\n"
"f()"
msgstr ""
"def myFunc():\n"
"    print(\"hello\")\n"
"\n"
"fname = \"myFunc\"\n"
"\n"
"f = locals()[fname]\n"
"f()"

#: ../../faq/programming.rst:990
msgid ""
"Is there an equivalent to Perl's ``chomp()`` for removing trailing newlines "
"from strings?"
msgstr ""
"¿Existe un equivalente a ``chomp()`` de Perl para eliminar las nuevas líneas "
"finales de las cadenas?"

#: ../../faq/programming.rst:992
msgid ""
"You can use ``S.rstrip(\"\\r\\n\")`` to remove all occurrences of any line "
"terminator from the end of the string ``S`` without removing other trailing "
"whitespace.  If the string ``S`` represents more than one line, with several "
"empty lines at the end, the line terminators for all the blank lines will be "
"removed::"
msgstr ""
"Puede utilizar ``S.rstrip(\"\\r\\n\")`` para eliminar todas las apariciones "
"de cualquier terminador de línea del final de la cadena ``S`` sin eliminar "
"otros espacios en blanco finales.  Si la cadena ``S`` representa más de una "
"línea, con varias líneas vacías al final, se eliminarán los terminadores de "
"línea de todas las líneas vacías::"

#: ../../faq/programming.rst:998
msgid ""
">>> lines = (\"line 1 \\r\\n\"\n"
"...          \"\\r\\n\"\n"
"...          \"\\r\\n\")\n"
">>> lines.rstrip(\"\\n\\r\")\n"
"'line 1 '"
msgstr ""
">>> lines = (\"line 1 \\r\\n\"\n"
"...          \"\\r\\n\"\n"
"...          \"\\r\\n\")\n"
">>> lines.rstrip(\"\\n\\r\")\n"
"'line 1 '"

#: ../../faq/programming.rst:1004
msgid ""
"Since this is typically only desired when reading text one line at a time, "
"using ``S.rstrip()`` this way works well."
msgstr ""
"Dado que esto sólo suele ser deseable cuando se lee el texto línea por "
"línea, el uso de ``S.rstrip()`` de esta forma funciona bien."

#: ../../faq/programming.rst:1009
msgid "Is there a ``scanf()`` or ``sscanf()`` equivalent?"
msgstr "¿Existe un equivalente en ``scanf()`` o ``sscanf()``?"

#: ../../faq/programming.rst:1011
msgid "Not as such."
msgstr "No como tal."

#: ../../faq/programming.rst:1013
msgid ""
"For simple input parsing, the easiest approach is usually to split the line "
"into whitespace-delimited words using the :meth:`~str.split` method of "
"string objects and then convert decimal strings to numeric values using :"
"func:`int` or :func:`float`.  :meth:`!split` supports an optional \"sep\" "
"parameter which is useful if the line uses something other than whitespace "
"as a separator."
msgstr ""
"Para el análisis sintáctico simple de la entrada, lo más sencillo suele ser "
"dividir la línea en palabras delimitadas por espacios en blanco mediante el "
"método :meth:`~str.split` de objetos de cadena y, a continuación, convertir "
"las cadenas decimales en valores numéricos mediante :func:`int` o :func:"
"`float`. :meth:`!split` admite un parámetro \"sep\" opcional que resulta "
"útil si la línea utiliza algo distinto de espacios en blanco como separador."

#: ../../faq/programming.rst:1019
msgid ""
"For more complicated input parsing, regular expressions are more powerful "
"than C's ``sscanf`` and better suited for the task."
msgstr ""
"Para el análisis sintáctico de entradas más complejas, las expresiones "
"regulares son más potentes que ``sscanf`` de C y más adecuadas para esta "
"tarea."

#: ../../faq/programming.rst:1024
msgid "What does ``UnicodeDecodeError`` or ``UnicodeEncodeError`` error mean?"
msgstr "¿Qué significa ``UnicodeDecodeError`` o ``UnicodeEncodeError`` error?"

#: ../../faq/programming.rst:1026
msgid "See the :ref:`unicode-howto`."
msgstr "Ver la página :ref:`unicode-howto`."

#: ../../faq/programming.rst:1032
msgid "Can I end a raw string with an odd number of backslashes?"
msgstr ""
"¿Puedo terminar una cadena sin formato con un número impar de barras "
"invertidas?"

#: ../../faq/programming.rst:1034
msgid ""
"A raw string ending with an odd number of backslashes will escape the "
"string's quote::"
msgstr ""
"Una cadena sin procesar que termine con un número impar de barras invertidas "
"escapará de las comillas de la cadena::"

#: ../../faq/programming.rst:1036
msgid ""
">>> r'C:\\this\\will\\not\\work\\'\n"
"  File \"<stdin>\", line 1\n"
"    r'C:\\this\\will\\not\\work\\'\n"
"    ^\n"
"SyntaxError: unterminated string literal (detected at line 1)"
msgstr ""
">>> r'C:\\this\\will\\not\\work\\'\n"
"  File \"<stdin>\", line 1\n"
"    r'C:\\this\\will\\not\\work\\'\n"
"    ^\n"
"SyntaxError: unterminated string literal (detected at line 1)"

#: ../../faq/programming.rst:1042
msgid ""
"There are several workarounds for this. One is to use regular strings and "
"double the backslashes::"
msgstr ""
"Existen varias soluciones. Una es utilizar cadenas normales y duplicar las "
"barras invertidas::"

#: ../../faq/programming.rst:1045
msgid ""
">>> 'C:\\\\this\\\\will\\\\work\\\\'\n"
"'C:\\\\this\\\\will\\\\work\\\\'"
msgstr ""
">>> 'C:\\\\this\\\\will\\\\work\\\\'\n"
"'C:\\\\this\\\\will\\\\work\\\\'"

#: ../../faq/programming.rst:1048
msgid ""
"Another is to concatenate a regular string containing an escaped backslash "
"to the raw string::"
msgstr ""
"Otra es concatenar una cadena regular que contenga una barra invertida "
"escapada a la cadena sin procesar::"

#: ../../faq/programming.rst:1051
msgid ""
">>> r'C:\\this\\will\\work' '\\\\'\n"
"'C:\\\\this\\\\will\\\\work\\\\'"
msgstr ""
">>> r'C:\\this\\will\\work' '\\\\'\n"
"'C:\\\\this\\\\will\\\\work\\\\'"

#: ../../faq/programming.rst:1054
msgid ""
"It is also possible to use :func:`os.path.join` to append a backslash on "
"Windows::"
msgstr ""
"También es posible utilizar :func:`os.path.join` para añadir una barra "
"invertida en Windows::"

#: ../../faq/programming.rst:1056
msgid ""
">>> os.path.join(r'C:\\this\\will\\work', '')\n"
"'C:\\\\this\\\\will\\\\work\\\\'"
msgstr ""
">>> os.path.join(r'C:\\this\\will\\work', '')\n"
"'C:\\\\this\\\\will\\\\work\\\\'"

#: ../../faq/programming.rst:1059
msgid ""
"Note that while a backslash will \"escape\" a quote for the purposes of "
"determining where the raw string ends, no escaping occurs when interpreting "
"the value of the raw string. That is, the backslash remains present in the "
"value of the raw string::"
msgstr ""
"Tenga en cuenta que aunque una barra invertida \"escape\" de una comilla "
"para determinar dónde termina la cadena sin procesar, no se produce ningún "
"escape al interpretar el valor de la cadena sin procesar. Es decir, la barra "
"invertida sigue presente en el valor de la cadena sin procesar::"

#: ../../faq/programming.rst:1064
msgid ""
">>> r'backslash\\'preserved'\n"
"\"backslash\\\\'preserved\""
msgstr ""
">>> r'backslash\\'preserved'\n"
"\"backslash\\\\'preserved\""

#: ../../faq/programming.rst:1067
msgid "Also see the specification in the :ref:`language reference <strings>`."
msgstr ""
"Consulte también la especificación en  :ref:`language reference <strings>`."

#: ../../faq/programming.rst:1070
msgid "Performance"
msgstr "Rendimiento"

#: ../../faq/programming.rst:1073
msgid "My program is too slow. How do I speed it up?"
msgstr "Mi programa es demasiado lento. ¿Cómo puedo acelerarlo?"

#: ../../faq/programming.rst:1075
msgid ""
"That's a tough one, in general.  First, here are a list of things to "
"remember before diving further:"
msgstr ""
"Es difícil, en general.  En primer lugar, he aquí una lista de cosas que hay "
"que recordar antes de seguir buceando:"

#: ../../faq/programming.rst:1078
msgid ""
"Performance characteristics vary across Python implementations.  This FAQ "
"focuses on :term:`CPython`."
msgstr ""
"Las características de rendimiento varían según las implementaciones de "
"Python.  Esta FAQ se centra en :term:`CPython`."

#: ../../faq/programming.rst:1080
msgid ""
"Behaviour can vary across operating systems, especially when talking about I/"
"O or multi-threading."
msgstr ""
"El comportamiento puede variar de un sistema operativo a otro, especialmente "
"cuando hablamos de E/S o multihilo."

#: ../../faq/programming.rst:1082
msgid ""
"You should always find the hot spots in your program *before* attempting to "
"optimize any code (see the :mod:`profile` module)."
msgstr ""
"Siempre debe encontrar los puntos calientes de su programa *antes* de "
"intentar optimizar cualquier código (consulte el módulo :mod:`profile` )."

#: ../../faq/programming.rst:1084
msgid ""
"Writing benchmark scripts will allow you to iterate quickly when searching "
"for improvements (see the :mod:`timeit` module)."
msgstr ""
"Escribir scripts de benchmark le permitirá iterar rápidamente en la búsqueda "
"de mejoras (consulte el módulo :mod:`timeit` )."

#: ../../faq/programming.rst:1086
msgid ""
"It is highly recommended to have good code coverage (through unit testing or "
"any other technique) before potentially introducing regressions hidden in "
"sophisticated optimizations."
msgstr ""
"Es muy recomendable tener una buena cobertura de código (mediante pruebas "
"unitarias o cualquier otra técnica) antes de introducir potencialmente "
"regresiones ocultas en optimizaciones sofisticadas."

#: ../../faq/programming.rst:1090
msgid ""
"That being said, there are many tricks to speed up Python code.  Here are "
"some general principles which go a long way towards reaching acceptable "
"performance levels:"
msgstr ""
"Dicho esto, existen muchos trucos para acelerar el código Python.  He aquí "
"algunos principios generales que contribuyen en gran medida a alcanzar "
"niveles de rendimiento aceptables:"

#: ../../faq/programming.rst:1094
msgid ""
"Making your algorithms faster (or changing to faster ones) can yield much "
"larger benefits than trying to sprinkle micro-optimization tricks all over "
"your code."
msgstr ""
"Hacer que sus algoritmos sean más rápidos (o cambiar a otros más rápidos) "
"puede reportar beneficios mucho mayores que intentar espolvorear trucos de "
"microoptimización por todo su código."

#: ../../faq/programming.rst:1098
msgid ""
"Use the right data structures.  Study documentation for the :ref:`bltin-"
"types` and the :mod:`collections` module."
msgstr ""
"Utilizar las estructuras de datos adecuadas.  Estudia la documentación de "
"los módulos :ref:`bltin-types` y :mod:`collections`."

#: ../../faq/programming.rst:1101
msgid ""
"When the standard library provides a primitive for doing something, it is "
"likely (although not guaranteed) to be faster than any alternative you may "
"come up with.  This is doubly true for primitives written in C, such as "
"builtins and some extension types.  For example, be sure to use either the :"
"meth:`list.sort` built-in method or the related :func:`sorted` function to "
"do sorting (and see the :ref:`sortinghowto` for examples of moderately "
"advanced usage)."
msgstr ""
"Cuando la biblioteca estándar proporciona una primitiva para hacer algo, es "
"probable (aunque no está garantizado) que sea más rápida que cualquier "
"alternativa que se te ocurra.  Esto es doblemente cierto para las primitivas "
"escritas en C, como los builtins y algunos tipos de extensión.  Por ejemplo, "
"asegúrese de utilizar el método incorporado :meth:`list.sort` o la función "
"relacionada :func:`sorted` para realizar la ordenación (y consulte :ref:"
"`sortinghowto` para ver ejemplos de uso moderadamente avanzado)."

#: ../../faq/programming.rst:1109
msgid ""
"Abstractions tend to create indirections and force the interpreter to work "
"more.  If the levels of indirection outweigh the amount of useful work done, "
"your program will be slower.  You should avoid excessive abstraction, "
"especially under the form of tiny functions or methods (which are also often "
"detrimental to readability)."
msgstr ""
"Las abstracciones tienden a crear indirecciones y obligan al intérprete a "
"trabajar más.  Si los niveles de indirección superan la cantidad de trabajo "
"útil realizado, tu programa será más lento.  Debes evitar la abstracción "
"excesiva, especialmente bajo la forma de funciones o métodos diminutos (que "
"también suelen ser perjudiciales para la legibilidad)."

#: ../../faq/programming.rst:1115
msgid ""
"If you have reached the limit of what pure Python can allow, there are tools "
"to take you further away.  For example, `Cython <https://cython.org>`_ can "
"compile a slightly modified version of Python code into a C extension, and "
"can be used on many different platforms.  Cython can take advantage of "
"compilation (and optional type annotations) to make your code significantly "
"faster than when interpreted.  If you are confident in your C programming "
"skills, you can also :ref:`write a C extension module <extending-index>` "
"yourself."
msgstr ""
"Si has llegado al límite de lo que Python puro puede permitirte, existen "
"herramientas para llevarte más lejos.  Por ejemplo, `Cython <https://cython."
"org>`_ puede compilar una versión ligeramente modificada del código Python "
"en una extensión C, y puede utilizarse en muchas plataformas diferentes.  "
"Cython puede aprovechar la compilación (y las anotaciones de tipo "
"opcionales) para hacer que tu código sea significativamente más rápido que "
"cuando se interpreta.  Si tiene confianza en sus habilidades de programación "
"en C, también puede :ref:`write a C extension module <extending-index>` "
"usted mismo."

#: ../../faq/programming.rst:1125
msgid ""
"The wiki page devoted to `performance tips <https://wiki.python.org/moin/"
"PythonSpeed/PerformanceTips>`_."
msgstr ""
"La página wiki dedicada a los `consejos de rendimiento <https://wiki.python."
"org/moin/PythonSpeed/PerformanceTips>`_."

#: ../../faq/programming.rst:1131
msgid "What is the most efficient way to concatenate many strings together?"
msgstr "¿Cuál es la forma más eficaz de concatenar varias cadenas?"

#: ../../faq/programming.rst:1133
msgid ""
":class:`str` and :class:`bytes` objects are immutable, therefore "
"concatenating many strings together is inefficient as each concatenation "
"creates a new object.  In the general case, the total runtime cost is "
"quadratic in the total string length."
msgstr ""
":class:`str` y :class:`bytes` son inmutables, por lo que concatenar muchas "
"cadenas es ineficiente, ya que cada concatenación crea un nuevo objeto.  En "
"el caso general, el coste total del tiempo de ejecución es cuadrático en la "
"longitud total de la cadena."

#: ../../faq/programming.rst:1138
msgid ""
"To accumulate many :class:`str` objects, the recommended idiom is to place "
"them into a list and call :meth:`str.join` at the end::"
msgstr ""
"Para acumular muchos objetos :class:`str`, lo recomendable es colocarlos en "
"una lista y llamar a :meth:`str.join` al final::"

#: ../../faq/programming.rst:1141
msgid ""
"chunks = []\n"
"for s in my_strings:\n"
"    chunks.append(s)\n"
"result = ''.join(chunks)"
msgstr ""
"chunks = []\n"
"for s in my_strings:\n"
"    chunks.append(s)\n"
"result = ''.join(chunks)"

#: ../../faq/programming.rst:1146
msgid "(another reasonably efficient idiom is to use :class:`io.StringIO`)"
msgstr "(otro modismo razonablemente eficaz es utilizar :class:`io.StringIO`)"

#: ../../faq/programming.rst:1148
msgid ""
"To accumulate many :class:`bytes` objects, the recommended idiom is to "
"extend a :class:`bytearray` object using in-place concatenation (the ``+=`` "
"operator)::"
msgstr ""
"Para acumular muchos objetos :class:`bytes`, el lenguaje recomendado es "
"ampliar un objeto :class:`bytearray` utilizando la concatenación en el lugar "
"(el operador ``+=`` )::"

#: ../../faq/programming.rst:1151
msgid ""
"result = bytearray()\n"
"for b in my_bytes_objects:\n"
"    result += b"
msgstr ""
"result = bytearray()\n"
"for b in my_bytes_objects:\n"
"    result += b"

#: ../../faq/programming.rst:1157
msgid "Sequences (Tuples/Lists)"
msgstr "Secuencias (tuplas/listas)"

#: ../../faq/programming.rst:1160
msgid "How do I convert between tuples and lists?"
msgstr "¿Cómo convierto entre tuplas y listas?"

#: ../../faq/programming.rst:1162
msgid ""
"The type constructor ``tuple(seq)`` converts any sequence (actually, any "
"iterable) into a tuple with the same items in the same order."
msgstr ""
"El constructor de tipo ``tuple(seq)`` convierte cualquier secuencia (en "
"realidad, cualquier iterable) en una tupla con los mismos elementos en el "
"mismo orden."

#: ../../faq/programming.rst:1165
msgid ""
"For example, ``tuple([1, 2, 3])`` yields ``(1, 2, 3)`` and ``tuple('abc')`` "
"yields ``('a', 'b', 'c')``.  If the argument is a tuple, it does not make a "
"copy but returns the same object, so it is cheap to call :func:`tuple` when "
"you aren't sure that an object is already a tuple."
msgstr ""
"Por ejemplo, ``tuple([1, 2, 3])`` devuelve ``(1, 2, 3)`` y ``tuple('abc')`` "
"devuelve ``('a', 'b', 'c')``.  Si el argumento es una tupla, no hace una "
"copia sino que devuelve el mismo objeto, por lo que es barato llamar a :func:"
"`tuple` cuando no se está seguro de que un objeto sea ya una tupla."

#: ../../faq/programming.rst:1170
msgid ""
"The type constructor ``list(seq)`` converts any sequence or iterable into a "
"list with the same items in the same order.  For example, ``list((1, 2, "
"3))`` yields ``[1, 2, 3]`` and ``list('abc')`` yields ``['a', 'b', 'c']``.  "
"If the argument is a list, it makes a copy just like ``seq[:]`` would."
msgstr ""
"El constructor de tipo ``list(seq)`` convierte cualquier secuencia o "
"iterable en una lista con los mismos elementos en el mismo orden.  Por "
"ejemplo, ``list((1, 2, 3))`` produce ``[1, 2, 3]`` y ``list('abc')`` produce "
"``['a', 'b', 'c']``.  Si el argumento es una lista, hace una copia igual que "
"``seq[:]``."

#: ../../faq/programming.rst:1177
msgid "What's a negative index?"
msgstr "¿Qué es un índice negativo?"

#: ../../faq/programming.rst:1179
msgid ""
"Python sequences are indexed with positive numbers and negative numbers.  "
"For positive numbers 0 is the first index 1 is the second index and so "
"forth.  For negative indices -1 is the last index and -2 is the penultimate "
"(next to last) index and so forth.  Think of ``seq[-n]`` as the same as "
"``seq[len(seq)-n]``."
msgstr ""
"Las secuencias de Python se indexan con números positivos y negativos.  Para "
"números positivos 0 es el primer índice 1 es el segundo índice y así "
"sucesivamente.  Para índices negativos -1 es el último índice y -2 es el "
"penúltimo (penúltimo) índice y así sucesivamente.  Piense que ``seq[-n]`` es "
"lo mismo que ``seq[len(seq)-n]``."

#: ../../faq/programming.rst:1184
msgid ""
"Using negative indices can be very convenient.  For example ``S[:-1]`` is "
"all of the string except for its last character, which is useful for "
"removing the trailing newline from a string."
msgstr ""
"El uso de índices negativos puede resultar muy práctico.  Por ejemplo, "
"``S[:-1]`` es toda la cadena excepto su último carácter, lo que resulta útil "
"para eliminar la última línea de una cadena."

#: ../../faq/programming.rst:1190
msgid "How do I iterate over a sequence in reverse order?"
msgstr "¿Cómo itero sobre una secuencia en orden inverso?"

#: ../../faq/programming.rst:1192
msgid "Use the :func:`reversed` built-in function::"
msgstr "Utilice la función integrada :func:`reversed`::"

#: ../../faq/programming.rst:1194
msgid ""
"for x in reversed(sequence):\n"
"    ...  # do something with x ..."
msgstr ""
"for x in reversed(sequence):\n"
"    ...  # hacer algo con x ..."

#: ../../faq/programming.rst:1197
msgid ""
"This won't touch your original sequence, but build a new copy with reversed "
"order to iterate over."
msgstr ""
"Esto no tocará tu secuencia original, sino que construirá una nueva copia "
"con el orden invertido para iterar sobre ella."

#: ../../faq/programming.rst:1202
msgid "How do you remove duplicates from a list?"
msgstr "¿Cómo se eliminan los duplicados de una lista?"

#: ../../faq/programming.rst:1204
msgid "See the Python Cookbook for a long discussion of many ways to do this:"
msgstr ""
"Consulte el Python Cookbook para una larga discusión de muchas maneras de "
"hacer esto:"

#: ../../faq/programming.rst:1206
msgid "https://code.activestate.com/recipes/52560/"
msgstr "https://code.activestate.com/recipes/52560/"

#: ../../faq/programming.rst:1208
msgid ""
"If you don't mind reordering the list, sort it and then scan from the end of "
"the list, deleting duplicates as you go::"
msgstr ""
"Si no te importa reordenar la lista, ordénala y luego escanea desde el final "
"de la lista, eliminando los duplicados a medida que avanzas::"

#: ../../faq/programming.rst:1211
msgid ""
"if mylist:\n"
"    mylist.sort()\n"
"    last = mylist[-1]\n"
"    for i in range(len(mylist)-2, -1, -1):\n"
"        if last == mylist[i]:\n"
"            del mylist[i]\n"
"        else:\n"
"            last = mylist[i]"
msgstr ""
"if mylist:\n"
"    mylist.sort()\n"
"    last = mylist[-1]\n"
"    for i in range(len(mylist)-2, -1, -1):\n"
"        if last == mylist[i]:\n"
"            del mylist[i]\n"
"        else:\n"
"            last = mylist[i]"

#: ../../faq/programming.rst:1220
msgid ""
"If all elements of the list may be used as set keys (i.e. they are all :term:"
"`hashable`) this is often faster ::"
msgstr ""
"Si todos los elementos de la lista pueden utilizarse como claves del "
"conjunto (es decir, si todos son :term:`hashable`) esto suele ser más "
"rápido ::"

#: ../../faq/programming.rst:1223
msgid "mylist = list(set(mylist))"
msgstr "mylist = list(set(mylist))"

#: ../../faq/programming.rst:1225
msgid ""
"This converts the list into a set, thereby removing duplicates, and then "
"back into a list."
msgstr ""
"Esto convierte la lista en un conjunto, eliminando así los duplicados, y "
"luego de nuevo en una lista."

#: ../../faq/programming.rst:1230
msgid "How do you remove multiple items from a list"
msgstr "Cómo eliminar varios elementos de una lista"

#: ../../faq/programming.rst:1232
msgid ""
"As with removing duplicates, explicitly iterating in reverse with a delete "
"condition is one possibility.  However, it is easier and faster to use slice "
"replacement with an implicit or explicit forward iteration. Here are three "
"variations.::"
msgstr ""
"Al igual que con la eliminación de duplicados, una posibilidad es iterar "
"explícitamente en sentido inverso con una condición de borrado.  Sin "
"embargo, es más fácil y rápido utilizar el reemplazo de trozos con una "
"iteración hacia delante implícita o explícita. He aquí tres variaciones::"

#: ../../faq/programming.rst:1237
msgid ""
"mylist[:] = filter(keep_function, mylist)\n"
"mylist[:] = (x for x in mylist if keep_condition)\n"
"mylist[:] = [x for x in mylist if keep_condition]"
msgstr ""
"mylist[:] = filter(keep_function, mylist)\n"
"mylist[:] = (x for x in mylist if keep_condition)\n"
"mylist[:] = [x for x in mylist if keep_condition]"

#: ../../faq/programming.rst:1241
msgid "The list comprehension may be fastest."
msgstr "La comprensión de la lista puede ser más rápida."

#: ../../faq/programming.rst:1245
msgid "How do you make an array in Python?"
msgstr "¿Cómo se forma un array en Python?"

#: ../../faq/programming.rst:1247
msgid "Use a list::"
msgstr "Utiliza una lista::"

#: ../../faq/programming.rst:1249
msgid "[\"this\", 1, \"is\", \"an\", \"array\"]"
msgstr "[\"this\", 1, \"is\", \"an\", \"array\"]"

#: ../../faq/programming.rst:1251
msgid ""
"Lists are equivalent to C or Pascal arrays in their time complexity; the "
"primary difference is that a Python list can contain objects of many "
"different types."
msgstr ""
"Las listas son equivalentes a las matrices de C o Pascal en su complejidad "
"temporal; la principal diferencia es que una lista de Python puede contener "
"objetos de muchos tipos diferentes."

#: ../../faq/programming.rst:1254
msgid ""
"The ``array`` module also provides methods for creating arrays of fixed "
"types with compact representations, but they are slower to index than "
"lists.  Also note that `NumPy <https://numpy.org/>`_ and other third party "
"packages define array-like structures with various characteristics as well."
msgstr ""
"El módulo ``array`` también proporciona métodos para crear arrays de tipos "
"fijos con representaciones compactas, pero son más lentos de indexar que las "
"listas.  También hay que tener en cuenta que `NumPy <https://numpy.org/>`_ y "
"otros paquetes de terceros definen también estructuras tipo array con "
"diversas características."

#: ../../faq/programming.rst:1260
msgid ""
"To get Lisp-style linked lists, you can emulate *cons cells* using tuples::"
msgstr ""
"Para obtener listas enlazadas al estilo Lisp, puedes emular *cons cells* "
"utilizando tuplas::"

#: ../../faq/programming.rst:1262
msgid "lisp_list = (\"like\",  (\"this\",  (\"example\", None) ) )"
msgstr "lisp_list = (\"like\",  (\"this\",  (\"example\", None) ) )"

#: ../../faq/programming.rst:1264
msgid ""
"If mutability is desired, you could use lists instead of tuples.  Here the "
"analogue of a Lisp *car* is ``lisp_list[0]`` and the analogue of *cdr* is "
"``lisp_list[1]``.  Only do this if you're sure you really need to, because "
"it's usually a lot slower than using Python lists."
msgstr ""
"Si se desea mutabilidad, se pueden utilizar listas en lugar de tuplas.  Aquí "
"el análogo de *car* en Lisp es ``lisp_list[0]`` y el análogo de *cdr* es "
"``lisp_list[1]``.  Haz esto sólo si estás seguro de que realmente lo "
"necesitas, porque suele ser mucho más lento que usar listas en Python."

#: ../../faq/programming.rst:1273
msgid "How do I create a multidimensional list?"
msgstr "¿Cómo crear una lista multidimensional?"

#: ../../faq/programming.rst:1275
msgid "You probably tried to make a multidimensional array like this::"
msgstr "Probablemente intentaste hacer un array multidimensional como este::"

#: ../../faq/programming.rst:1277
msgid ">>> A = [[None] * 2] * 3"
msgstr ">>> A = [[None] * 2] * 3"

#: ../../faq/programming.rst:1279
msgid "This looks correct if you print it:"
msgstr "Esto parece correcto si lo imprimes:"

#: ../../faq/programming.rst:1285
msgid ""
">>> A\n"
"[[None, None], [None, None], [None, None]]"
msgstr ""
">>> A\n"
"[[None, None], [None, None], [None, None]]"

#: ../../faq/programming.rst:1290
msgid "But when you assign a value, it shows up in multiple places:"
msgstr "Pero cuando asignas un valor, aparece en varios lugares:"

#: ../../faq/programming.rst:1296
msgid ""
">>> A[0][0] = 5\n"
">>> A\n"
"[[5, None], [5, None], [5, None]]"
msgstr ""
">>> A[0][0] = 5\n"
">>> A\n"
"[[5, None], [5, None], [5, None]]"

#: ../../faq/programming.rst:1302
msgid ""
"The reason is that replicating a list with ``*`` doesn't create copies, it "
"only creates references to the existing objects.  The ``*3`` creates a list "
"containing 3 references to the same list of length two.  Changes to one row "
"will show in all rows, which is almost certainly not what you want."
msgstr ""
"La razón es que replicar una lista con ``*`` no crea copias, sólo crea "
"referencias a los objetos existentes.  El ``*3`` crea una lista que contiene "
"3 referencias a la misma lista de longitud dos.  Los cambios en una fila se "
"mostrarán en todas las filas, que casi seguro no es lo que quieres."

#: ../../faq/programming.rst:1307
msgid ""
"The suggested approach is to create a list of the desired length first and "
"then fill in each element with a newly created list::"
msgstr ""
"El enfoque sugerido es crear primero una lista de la longitud deseada y "
"luego rellenar cada elemento con una lista recién creada::"

#: ../../faq/programming.rst:1310
msgid ""
"A = [None] * 3\n"
"for i in range(3):\n"
"    A[i] = [None] * 2"
msgstr ""
"A = [None] * 3\n"
"for i in range(3):\n"
"    A[i] = [None] * 2"

#: ../../faq/programming.rst:1314
msgid ""
"This generates a list containing 3 different lists of length two.  You can "
"also use a list comprehension::"
msgstr ""
"Esto genera una lista que contiene 3 listas diferentes de longitud dos.  "
"También puede utilizar una comprensión de lista::"

#: ../../faq/programming.rst:1317
msgid ""
"w, h = 2, 3\n"
"A = [[None] * w for i in range(h)]"
msgstr ""
"w, h = 2, 3\n"
"A = [[None] * w for i in range(h)]"

#: ../../faq/programming.rst:1320
msgid ""
"Or, you can use an extension that provides a matrix datatype; `NumPy "
"<https://numpy.org/>`_ is the best known."
msgstr ""
"O bien, puede utilizar una extensión que proporcione un tipo de datos de "
"matriz; `NumPy <https://numpy.org/>`_ es la más conocida."

#: ../../faq/programming.rst:1325
msgid "How do I apply a method or function to a sequence of objects?"
msgstr "¿Cómo aplicar un método o una función a una secuencia de objetos?"

#: ../../faq/programming.rst:1327
msgid ""
"To call a method or function and accumulate the return values is a list, a :"
"term:`list comprehension` is an elegant solution::"
msgstr ""
"Para llamar a un método o función y acumular los valores de retorno es una "
"lista, un :término:`comprensión de lista` es una solución elegante::"

#: ../../faq/programming.rst:1330
msgid ""
"result = [obj.method() for obj in mylist]\n"
"\n"
"result = [function(obj) for obj in mylist]"
msgstr ""
"result = [obj.method() for obj in mylist]\n"
"\n"
"result = [function(obj) for obj in mylist]"

#: ../../faq/programming.rst:1334
msgid ""
"To just run the method or function without saving the return values, a "
"plain :keyword:`for` loop will suffice::"
msgstr ""
"Para ejecutar el método o la función sin guardar los valores de retorno, "
"basta con un simple bucle :keyword:`for`::"

#: ../../faq/programming.rst:1337
msgid ""
"for obj in mylist:\n"
"    obj.method()\n"
"\n"
"for obj in mylist:\n"
"    function(obj)"
msgstr ""
"for obj in mylist:\n"
"    obj.method()\n"
"\n"
"for obj in mylist:\n"
"    function(obj)"

#: ../../faq/programming.rst:1346
msgid ""
"Why does a_tuple[i] += ['item'] raise an exception when the addition works?"
msgstr ""
"¿Por qué a_tuple[i] += ['item'] lanza una excepción cuando la suma funciona?"

#: ../../faq/programming.rst:1348
msgid ""
"This is because of a combination of the fact that augmented assignment "
"operators are *assignment* operators, and the difference between mutable and "
"immutable objects in Python."
msgstr ""
"Esto se debe a una combinación del hecho de que los operadores de asignación "
"aumentada son operadores de *asignación*, y a la diferencia entre objetos "
"mutables e inmutables en Python."

#: ../../faq/programming.rst:1352
msgid ""
"This discussion applies in general when augmented assignment operators are "
"applied to elements of a tuple that point to mutable objects, but we'll use "
"a ``list`` and ``+=`` as our exemplar."
msgstr ""
"Esta discusión se aplica en general cuando los operadores de asignación "
"aumentada se aplican a elementos de una tupla que apuntan a objetos "
"mutables, pero utilizaremos ``list`` y ``+=`` como ejemplo."

#: ../../faq/programming.rst:1356
msgid "If you wrote::"
msgstr "Si usted escribió::"

#: ../../faq/programming.rst:1358
msgid ""
">>> a_tuple = (1, 2)\n"
">>> a_tuple[0] += 1\n"
"Traceback (most recent call last):\n"
"   ...\n"
"TypeError: 'tuple' object does not support item assignment"
msgstr ""
">>> a_tupla = (1, 2)\n"
">>> a_tupla[0] += 1\n"
"Traceback (última llamada más reciente):\n"
"   ...\n"
"TypeError: 'tuple' object does not support item assignment"

#: ../../faq/programming.rst:1364
msgid ""
"The reason for the exception should be immediately clear: ``1`` is added to "
"the object ``a_tuple[0]`` points to (``1``), producing the result object, "
"``2``, but when we attempt to assign the result of the computation, ``2``, "
"to element ``0`` of the tuple, we get an error because we can't change what "
"an element of a tuple points to."
msgstr ""
"La razón de la excepción debería ser inmediatamente clara: ``1`` se añade al "
"objeto al que apunta ``a_tuple[0]`` (``1``), produciendo el objeto "
"resultado, ``2``, pero cuando intentamos asignar el resultado del cálculo, "
"``2``, al elemento ``0`` de la tupla, obtenemos un error porque no podemos "
"cambiar a qué apunta un elemento de una tupla."

#: ../../faq/programming.rst:1370
msgid ""
"Under the covers, what this augmented assignment statement is doing is "
"approximately this::"
msgstr ""
"Bajo las sábanas, lo que esta declaración de asignación aumentada está "
"haciendo es aproximadamente esto::"

#: ../../faq/programming.rst:1373
msgid ""
">>> result = a_tuple[0] + 1\n"
">>> a_tuple[0] = result\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: 'tuple' object does not support item assignment"
msgstr ""
">>> result = a_tupla[0] + 1\n"
">>> a_tupla[0] = result\n"
"Traceback (última llamada más reciente):\n"
"  ...\n"
"TypeError: 'tuple' object does not support item assignment"

#: ../../faq/programming.rst:1379
msgid ""
"It is the assignment part of the operation that produces the error, since a "
"tuple is immutable."
msgstr ""
"Es la parte de asignación de la operación la que produce el error, ya que "
"una tupla es inmutable."

#: ../../faq/programming.rst:1382
msgid "When you write something like::"
msgstr "Cuando escribes algo como::"

#: ../../faq/programming.rst:1384
msgid ""
">>> a_tuple = (['foo'], 'bar')\n"
">>> a_tuple[0] += ['item']\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: 'tuple' object does not support item assignment"
msgstr ""
">>> a_tupla = (['foo'], 'bar')\n"
">>> a_tupla[0] += ['item']\n"
"Traceback (última llamada más reciente):\n"
"  ...\n"
"TypeError: 'tuple' object does not support item assignment"

#: ../../faq/programming.rst:1390
msgid ""
"The exception is a bit more surprising, and even more surprising is the fact "
"that even though there was an error, the append worked::"
msgstr ""
"La excepción es un poco más sorprendente, y aún más sorprendente es el hecho "
"de que a pesar de que hubo un error, el append funcionó::"

#: ../../faq/programming.rst:1393
msgid ""
">>> a_tuple[0]\n"
"['foo', 'item']"
msgstr ""
">>> a_tuple[0]\n"
"['foo', 'item']"

#: ../../faq/programming.rst:1396
msgid ""
"To see why this happens, you need to know that (a) if an object implements "
"an :meth:`~object.__iadd__` magic method, it gets called when the ``+=`` "
"augmented assignment is executed, and its return value is what gets used in "
"the assignment statement; and (b) for lists, :meth:`!__iadd__` is equivalent "
"to calling :meth:`!extend` on the list and returning the list.  That's why "
"we say that for lists, ``+=`` is a \"shorthand\" for :meth:`!list.extend`::"
msgstr ""
"Para ver por qué ocurre esto, necesita saber que (a) si un objeto implementa "
"un método mágico :meth:`~object.__iadd__`, éste es llamado cuando se ejecuta "
"la asignación aumentada ``+=``, y su valor de retorno es lo que se utiliza "
"en la sentencia de asignación; y (b) para listas, :meth:`!__iadd__` es "
"equivalente a llamar a :meth:`!extend` en la lista y devolver la lista.  Por "
"eso decimos que para las listas, ``+=`` es una \"abreviatura\" de :meth:`!"
"list.extend`::"

#: ../../faq/programming.rst:1404
msgid ""
">>> a_list = []\n"
">>> a_list += [1]\n"
">>> a_list\n"
"[1]"
msgstr ""
">>> a_list = []\n"
">>> a_list += [1]\n"
">>> a_list\n"
"[1]"

#: ../../faq/programming.rst:1409
msgid "This is equivalent to::"
msgstr "Esto equivale a::"

#: ../../faq/programming.rst:1411
msgid ""
">>> result = a_list.__iadd__([1])\n"
">>> a_list = result"
msgstr ""
">>> result = a_list.__iadd__([1])\n"
">>> a_list = result"

#: ../../faq/programming.rst:1414
msgid ""
"The object pointed to by a_list has been mutated, and the pointer to the "
"mutated object is assigned back to ``a_list``.  The end result of the "
"assignment is a no-op, since it is a pointer to the same object that "
"``a_list`` was previously pointing to, but the assignment still happens."
msgstr ""
"El objeto apuntado por a_list ha sido mutado, y el puntero al objeto mutado "
"se asigna de nuevo a ``a_list``. El resultado final de la asignación es un "
"no-op, ya que es un puntero al mismo objeto que ``a_list`` estaba apuntando "
"previamente, pero la asignación sigue ocurriendo."

#: ../../faq/programming.rst:1419
msgid "Thus, in our tuple example what is happening is equivalent to::"
msgstr "Así, en nuestro ejemplo de tupla lo que ocurre es equivalente a::"

#: ../../faq/programming.rst:1421
msgid ""
">>> result = a_tuple[0].__iadd__(['item'])\n"
">>> a_tuple[0] = result\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: 'tuple' object does not support item assignment"
msgstr ""
">>> result = a_tupla[0].__iadd__(['elemento'])\n"
">>> a_tupla[0] = result\n"
"Traceback (última llamada más reciente):\n"
"  ...\n"
"TypeError: 'tuple' object does not support item assignment"

#: ../../faq/programming.rst:1427
msgid ""
"The :meth:`!__iadd__` succeeds, and thus the list is extended, but even "
"though ``result`` points to the same object that ``a_tuple[0]`` already "
"points to, that final assignment still results in an error, because tuples "
"are immutable."
msgstr ""
"El :meth:`!__iadd__` tiene éxito, y por lo tanto la lista se extiende, pero "
"a pesar de que ``result`` apunta al mismo objeto que ``a_tuple[0]`` ya "
"apunta, esa asignación final sigue dando lugar a un error, porque las tuplas "
"son inmutables."

#: ../../faq/programming.rst:1433
msgid ""
"I want to do a complicated sort: can you do a Schwartzian Transform in "
"Python?"
msgstr ""
"Quiero hacer una ordenación complicada: ¿se puede hacer una Transformada "
"Schwartziana en Python?"

#: ../../faq/programming.rst:1435
msgid ""
"The technique, attributed to Randal Schwartz of the Perl community, sorts "
"the elements of a list by a metric which maps each element to its \"sort "
"value\". In Python, use the ``key`` argument for the :meth:`list.sort` "
"method::"
msgstr ""
"La técnica, atribuida a Randal Schwartz de la comunidad Perl, ordena los "
"elementos de una lista mediante una métrica que asigna a cada elemento su "
"\"valor de ordenación\". En Python, utilice el argumento ``key`` para el "
"método :meth:`list.sort`::"

#: ../../faq/programming.rst:1439
msgid ""
"Isorted = L[:]\n"
"Isorted.sort(key=lambda s: int(s[10:15]))"
msgstr ""
"Isorted = L[:]\n"
"Isorted.sort(key=lambda s: int(s[10:15]))"

#: ../../faq/programming.rst:1444
msgid "How can I sort one list by values from another list?"
msgstr "¿Cómo puedo ordenar una lista por los valores de otra lista?"

#: ../../faq/programming.rst:1446
msgid ""
"Merge them into an iterator of tuples, sort the resulting list, and then "
"pick out the element you want. ::"
msgstr ""
"Fúndalos en un iterador de tuplas, ordena la lista resultante y luego elige "
"el elemento que quieras. ::"

#: ../../faq/programming.rst:1449
msgid ""
">>> list1 = [\"what\", \"I'm\", \"sorting\", \"by\"]\n"
">>> list2 = [\"something\", \"else\", \"to\", \"sort\"]\n"
">>> pairs = zip(list1, list2)\n"
">>> pairs = sorted(pairs)\n"
">>> pairs\n"
"[(\"I'm\", 'else'), ('by', 'sort'), ('sorting', 'to'), ('what', "
"'something')]\n"
">>> result = [x[1] for x in pairs]\n"
">>> result\n"
"['else', 'sort', 'to', 'something']"
msgstr ""
">>> list1 = [\"what\", \"I'm\", \"sorting\", \"by\"]\n"
">>> list2 = [\"something\", \"else\", \"to\", \"sort\"]\n"
">>> pairs = zip(list1, list2)\n"
">>> pairs = sorted(pairs)\n"
">>> pairs\n"
"[(\"I'm\", 'else'), ('by', 'sort'), ('sorting', 'to'), ('what', "
"'something')]\n"
">>> result = [x[1] for x in pairs]\n"
">>> result\n"
"['else', 'sort', 'to', 'something']"

#: ../../faq/programming.rst:1461
msgid "Objects"
msgstr "Objetos"

#: ../../faq/programming.rst:1464
msgid "What is a class?"
msgstr "¿Qué es una clase?"

#: ../../faq/programming.rst:1466
msgid ""
"A class is the particular object type created by executing a class "
"statement. Class objects are used as templates to create instance objects, "
"which embody both the data (attributes) and code (methods) specific to a "
"datatype."
msgstr ""
"Una clase es el tipo de objeto concreto que se crea al ejecutar una "
"sentencia class. Los objetos de clase se utilizan como plantillas para crear "
"objetos de instancia, que incorporan tanto los datos (atributos) como el "
"código (métodos) específicos de un tipo de datos."

#: ../../faq/programming.rst:1470
msgid ""
"A class can be based on one or more other classes, called its base "
"class(es). It then inherits the attributes and methods of its base classes. "
"This allows an object model to be successively refined by inheritance.  You "
"might have a generic ``Mailbox`` class that provides basic accessor methods "
"for a mailbox, and subclasses such as ``MboxMailbox``, ``MaildirMailbox``, "
"``OutlookMailbox`` that handle various specific mailbox formats."
msgstr ""
"Una clase puede basarse en otra u otras clases, denominadas clase(s) base. "
"Entonces hereda los atributos y métodos de sus clases base. Esto permite "
"refinar sucesivamente un modelo de objetos mediante la herencia.  Puede "
"tener una clase genérica ``Mailbox`` que proporcione métodos de acceso "
"básicos para un buzón de correo, y subclases como ``MboxMailbox``, "
"``MaildirMailbox``, ``OutlookMailbox`` que manejen varios formatos de buzón "
"específicos."

#: ../../faq/programming.rst:1479
msgid "What is a method?"
msgstr "¿Qué es un método?"

#: ../../faq/programming.rst:1481
msgid ""
"A method is a function on some object ``x`` that you normally call as ``x."
"name(arguments...)``.  Methods are defined as functions inside the class "
"definition::"
msgstr ""
"Un método es una función sobre algún objeto ``x`` que normalmente se llama "
"como ``x.name(arguments...)``.  Los métodos se definen como funciones dentro "
"de la definición de la clase::"

#: ../../faq/programming.rst:1485
msgid ""
"class C:\n"
"    def meth(self, arg):\n"
"        return arg * 2 + self.attribute"
msgstr ""
"clase C:\n"
"    def meth(self, arg):\n"
"        return arg * 2 + self.attribute"

#: ../../faq/programming.rst:1491
msgid "What is self?"
msgstr "¿Qué es el yo?"

#: ../../faq/programming.rst:1493
msgid ""
"Self is merely a conventional name for the first argument of a method.  A "
"method defined as ``meth(self, a, b, c)`` should be called as ``x.meth(a, b, "
"c)`` for some instance ``x`` of the class in which the definition occurs; "
"the called method will think it is called as ``meth(x, a, b, c)``."
msgstr ""
"Self es simplemente un nombre convencional para el primer argumento de un "
"método.  Un método definido como ``meth(self, a, b, c)`` debe ser llamado "
"como ``x.meth(a, b, c)`` para alguna instancia ``x`` de la clase en la que "
"se produce la definición; el método llamado pensará que es llamado como "
"``meth(x, a, b, c)``."

#: ../../faq/programming.rst:1498
msgid "See also :ref:`why-self`."
msgstr "Ver también :ref:`why-self`."

#: ../../faq/programming.rst:1502
msgid ""
"How do I check if an object is an instance of a given class or of a subclass "
"of it?"
msgstr ""
"¿Cómo puedo comprobar si un objeto es una instancia de una clase determinada "
"o de una subclase de la misma?"

#: ../../faq/programming.rst:1504
msgid ""
"Use the built-in function :func:`isinstance(obj, cls) <isinstance>`.  You "
"can check if an object is an instance of any of a number of classes by "
"providing a tuple instead of a single class, e.g. ``isinstance(obj, (class1, "
"class2, ...))``, and can also check whether an object is one of Python's "
"built-in types, e.g. ``isinstance(obj, str)`` or ``isinstance(obj, (int, "
"float, complex))``."
msgstr ""
"Utilice la función incorporada :func:`isinstance(obj, cls) <isinstance>`.  "
"Puede comprobar si un objeto es una instancia de cualquiera de un número de "
"clases proporcionando una tupla en lugar de una sola clase, por ejemplo "
"``isinstance(obj, (class1, class2, ...))``, y también puede comprobar si un "
"objeto es uno de los tipos incorporados de Python, por ejemplo "
"``isinstance(obj, str)`` o ``isinstance(obj, (int, float, complex))``."

#: ../../faq/programming.rst:1511
msgid ""
"Note that :func:`isinstance` also checks for virtual inheritance from an :"
"term:`abstract base class`.  So, the test will return ``True`` for a "
"registered class even if hasn't directly or indirectly inherited from it.  "
"To test for \"true inheritance\", scan the :term:`MRO` of the class:"
msgstr ""
"Tenga en cuenta que :func:`isinstance` también comprueba la herencia virtual "
"de una clase base :term:`abstract`.  Por lo tanto, la prueba devolverá "
"``True`` para una clase registrada aunque no haya heredado directa o "
"indirectamente de ella.  Para comprobar la \"herencia verdadera\", explore "
"el :term:`MRO` de la clase:"

#: ../../faq/programming.rst:1516
msgid ""
"from collections.abc import Mapping\n"
"\n"
"class P:\n"
"     pass\n"
"\n"
"class C(P):\n"
"    pass\n"
"\n"
"Mapping.register(P)"
msgstr ""
"from collections.abc import Mapping\n"
"\n"
"class P:\n"
"     pass\n"
"\n"
"class C(P):\n"
"    pass\n"
"\n"
"Mapping.register(P)"

#: ../../faq/programming.rst:1528
msgid ""
">>> c = C()\n"
">>> isinstance(c, C)        # direct\n"
"True\n"
">>> isinstance(c, P)        # indirect\n"
"True\n"
">>> isinstance(c, Mapping)  # virtual\n"
"True\n"
"\n"
"# Actual inheritance chain\n"
">>> type(c).__mro__\n"
"(<class 'C'>, <class 'P'>, <class 'object'>)\n"
"\n"
"# Test for \"true inheritance\"\n"
">>> Mapping in type(c).__mro__\n"
"False"
msgstr ""
">>> c = C()\n"
">>> isinstance(c, C) # directo\n"
"Verdadero\n"
">>> isinstance(c, P) # indirecto\n"
"Verdadero\n"
">>> isinstance(c, Mapping) # virtual\n"
"Verdadero\n"
"\n"
"# Cadena de herencia real\n"
">>> tipo(c).__mro__\n"
"(<class 'C'>, <class 'P'>, <class 'object'>)\n"
"\n"
"# Prueba de \"herencia verdadera\"\n"
">>> Mapeo en type(c).__mro__\n"
"Falso"

#: ../../faq/programming.rst:1546
msgid ""
"Note that most programs do not use :func:`isinstance` on user-defined "
"classes very often.  If you are developing the classes yourself, a more "
"proper object-oriented style is to define methods on the classes that "
"encapsulate a particular behaviour, instead of checking the object's class "
"and doing a different thing based on what class it is.  For example, if you "
"have a function that does something::"
msgstr ""
"Tenga en cuenta que la mayoría de los programas no utilizan :func:"
"`isinstance` en clases definidas por el usuario muy a menudo.  Si estás "
"desarrollando las clases tú mismo, un estilo orientado a objetos más "
"apropiado es definir métodos en las clases que encapsulen un comportamiento "
"particular, en lugar de comprobar la clase del objeto y hacer una cosa "
"diferente basándose en qué clase es.  Por ejemplo, si tienes una función que "
"hace algo::"

#: ../../faq/programming.rst:1553
msgid ""
"def search(obj):\n"
"    if isinstance(obj, Mailbox):\n"
"        ...  # code to search a mailbox\n"
"    elif isinstance(obj, Document):\n"
"        ...  # code to search a document\n"
"    elif ..."
msgstr ""
"def search(obj):\n"
"    if isinstance(obj, Mailbox):\n"
"        ...  # código para buscar en un buzón\n"
"    elif isinstance(obj, Document):\n"
"        ...  # código para buscar un documento\n"
"    elif ..."

#: ../../faq/programming.rst:1560
msgid ""
"A better approach is to define a ``search()`` method on all the classes and "
"just call it::"
msgstr ""
"Un enfoque mejor es definir un método ``search()`` en todas las clases y "
"simplemente llamarlo::"

#: ../../faq/programming.rst:1563
msgid ""
"class Mailbox:\n"
"    def search(self):\n"
"        ...  # code to search a mailbox\n"
"\n"
"class Document:\n"
"    def search(self):\n"
"        ...  # code to search a document\n"
"\n"
"obj.search()"
msgstr ""
"class Mailbox:\n"
"    def search(self):\n"
"        ...  # código para buscar en un buzón\n"
"\n"
"class Document:\n"
"    def search(self):\n"
"        ...  # código para buscar en un documento\n"
"\n"
"obj.search()"

#: ../../faq/programming.rst:1575
msgid "What is delegation?"
msgstr "¿Qué es la delegación?"

#: ../../faq/programming.rst:1577
msgid ""
"Delegation is an object oriented technique (also called a design pattern). "
"Let's say you have an object ``x`` and want to change the behaviour of just "
"one of its methods.  You can create a new class that provides a new "
"implementation of the method you're interested in changing and delegates all "
"other methods to the corresponding method of ``x``."
msgstr ""
"La delegación es una técnica orientada a objetos (también llamada patrón de "
"diseño). Supongamos que tienes un objeto ``x`` y quieres cambiar el "
"comportamiento de uno solo de sus métodos.  Puedes crear una nueva clase que "
"proporcione una nueva implementación del método que te interesa cambiar y "
"delegar todos los demás métodos en el método correspondiente de ``x``."

#: ../../faq/programming.rst:1583
msgid ""
"Python programmers can easily implement delegation.  For example, the "
"following class implements a class that behaves like a file but converts all "
"written data to uppercase::"
msgstr ""
"Los programadores de Python pueden implementar fácilmente la delegación.  "
"Por ejemplo, la siguiente clase implementa una clase que se comporta como un "
"archivo pero convierte todos los datos escritos a mayúsculas::"

#: ../../faq/programming.rst:1587
msgid ""
"class UpperOut:\n"
"\n"
"    def __init__(self, outfile):\n"
"        self._outfile = outfile\n"
"\n"
"    def write(self, s):\n"
"        self._outfile.write(s.upper())\n"
"\n"
"    def __getattr__(self, name):\n"
"        return getattr(self._outfile, name)"
msgstr ""
"class UpperOut:\n"
"\n"
"    def __init__(self, outfile):\n"
"        self._outfile = outfile\n"
"\n"
"    def write(self, s):\n"
"        self._outfile.write(s.upper())\n"
"\n"
"    def __getattr__(self, name):\n"
"        return getattr(self._outfile, name)"

#: ../../faq/programming.rst:1598
msgid ""
"Here the ``UpperOut`` class redefines the ``write()`` method to convert the "
"argument string to uppercase before calling the underlying ``self._outfile."
"write()`` method.  All other methods are delegated to the underlying ``self."
"_outfile`` object.  The delegation is accomplished via the :meth:`~object."
"__getattr__` method; consult :ref:`the language reference <attribute-"
"access>` for more information about controlling attribute access."
msgstr ""
"Aquí la clase ``UpperOut`` redefine el método ``write()`` para convertir la "
"cadena del argumento a mayúsculas antes de llamar al método subyacente "
"``self._outfile.write()``.  Todos los demás métodos se delegan en el objeto "
"``self._outfile`` subyacente.  La delegación se realiza a través del método :"
"meth:`~object.__getattr__`; consulte :ref:`the language reference <attribute-"
"access>` para más información sobre el control de acceso a atributos."

#: ../../faq/programming.rst:1605
msgid ""
"Note that for more general cases delegation can get trickier. When "
"attributes must be set as well as retrieved, the class must define a :meth:"
"`~object.__setattr__` method too, and it must do so carefully.  The basic "
"implementation of :meth:`!__setattr__` is roughly equivalent to the "
"following::"
msgstr ""
"Ten en cuenta que, en casos más generales, la delegación puede resultar más "
"complicada. Cuando los atributos deben establecerse además de recuperarse, "
"la clase debe definir también un método :meth:`~object.__setattr__`, y debe "
"hacerlo con cuidado.  La implementación básica de :meth:`!__setattr__` es "
"aproximadamente equivalente a la siguiente::"

#: ../../faq/programming.rst:1610
msgid ""
"class X:\n"
"    ...\n"
"    def __setattr__(self, name, value):\n"
"        self.__dict__[name] = value\n"
"    ..."
msgstr ""
"class X:\n"
"    ...\n"
"    def __setattr__(self, name, value):\n"
"        self.__dict__[name] = value\n"
"    ..."

#: ../../faq/programming.rst:1616
msgid ""
"Many :meth:`~object.__setattr__` implementations call :meth:`!object."
"__setattr__` to set an attribute on self without causing infinite recursion::"
msgstr ""
"Muchas implementaciones de :meth:`~object.__setattr__` llaman a :meth:`!"
"object.__setattr__` para establecer un atributo en self sin causar una "
"recursión infinita::"

#: ../../faq/programming.rst:1619
msgid ""
"class X:\n"
"    def __setattr__(self, name, value):\n"
"        # Custom logic here...\n"
"        object.__setattr__(self, name, value)"
msgstr ""
"clase X:\n"
"    def __setattr__(self, name, value):\n"
"        # Lógica personalizada aquí...\n"
"        object.__setattr__(self, name, value)"

#: ../../faq/programming.rst:1624
msgid ""
"Alternatively, it is possible to set attributes by inserting entries into :"
"attr:`self.__dict__ <object.__dict__>` directly."
msgstr ""
"Alternativamente, es posible establecer atributos insertando entradas en :"
"attr:`self.__dict__ <object.__dict__>` directamente."

#: ../../faq/programming.rst:1629
msgid ""
"How do I call a method defined in a base class from a derived class that "
"extends it?"
msgstr ""
"¿Cómo se llama a un método definido en una clase base desde una clase "
"derivada que la extiende?"

#: ../../faq/programming.rst:1631
msgid "Use the built-in :func:`super` function::"
msgstr "Utilice la función incorporada :func:`super`::"

#: ../../faq/programming.rst:1633
msgid ""
"class Derived(Base):\n"
"    def meth(self):\n"
"        super().meth()  # calls Base.meth"
msgstr ""
"class Derived(Base):\n"
"    def meth(self):\n"
"        super().meth()  # llama a Base.meth"

#: ../../faq/programming.rst:1637
msgid ""
"In the example, :func:`super` will automatically determine the instance from "
"which it was called (the ``self`` value), look up the :term:`method "
"resolution order` (MRO) with ``type(self).__mro__``, and return the next in "
"line after ``Derived`` in the MRO: ``Base``."
msgstr ""
"En el ejemplo, :func:`super` determinará automáticamente la instancia desde "
"la que se llamó (el valor ``self`` ), buscará el :term:`method resolution "
"order` (MRO) con ``type(self).__mro__``, y devolverá el siguiente en la "
"línea después de ``Derived`` en el MRO: ``Base``."

#: ../../faq/programming.rst:1644
msgid "How can I organize my code to make it easier to change the base class?"
msgstr ""
"¿Cómo puedo organizar mi código para que sea más fácil cambiar la clase base?"

#: ../../faq/programming.rst:1646
msgid ""
"You could assign the base class to an alias and derive from the alias.  Then "
"all you have to change is the value assigned to the alias.  Incidentally, "
"this trick is also handy if you want to decide dynamically (e.g. depending "
"on availability of resources) which base class to use.  Example::"
msgstr ""
"Podría asignar la clase base a un alias y derivar del alias.  Entonces todo "
"lo que tienes que cambiar es el valor asignado al alias.  Por cierto, este "
"truco también es útil si desea decidir dinámicamente (por ejemplo, en "
"función de la disponibilidad de recursos) qué clase base utilizar.  Ejemplo::"

#: ../../faq/programming.rst:1651
msgid ""
"class Base:\n"
"    ...\n"
"\n"
"BaseAlias = Base\n"
"\n"
"class Derived(BaseAlias):\n"
"    ..."
msgstr ""
"class Base:\n"
"    ...\n"
"\n"
"BaseAlias = Base\n"
"\n"
"class Derived(BaseAlias):\n"
"    ..."

#: ../../faq/programming.rst:1661
msgid "How do I create static class data and static class methods?"
msgstr ""
"¿Cómo puedo crear datos de clase estáticos y métodos de clase estáticos?"

#: ../../faq/programming.rst:1663
msgid ""
"Both static data and static methods (in the sense of C++ or Java) are "
"supported in Python."
msgstr ""
"Tanto los datos estáticos como los métodos estáticos (en el sentido de C++ o "
"Java) están soportados en Python."

#: ../../faq/programming.rst:1666
msgid ""
"For static data, simply define a class attribute.  To assign a new value to "
"the attribute, you have to explicitly use the class name in the assignment::"
msgstr ""
"Para los datos estáticos, basta con definir un atributo de clase.  Para "
"asignar un nuevo valor al atributo, debe utilizar explícitamente el nombre "
"de la clase en la asignación::"

#: ../../faq/programming.rst:1669
msgid ""
"class C:\n"
"    count = 0   # number of times C.__init__ called\n"
"\n"
"    def __init__(self):\n"
"        C.count = C.count + 1\n"
"\n"
"    def getcount(self):\n"
"        return C.count  # or return self.count"
msgstr ""
"class C:\n"
"    count = 0 # número de veces que se llama a C.__init__\n"
"\n"
"    def __init__(self):\n"
"        C.count = C.count + 1\n"
"\n"
"    def getcount(self):\n"
"        return C.count # o devuelve self.count"

#: ../../faq/programming.rst:1678
msgid ""
"``c.count`` also refers to ``C.count`` for any ``c`` such that "
"``isinstance(c, C)`` holds, unless overridden by ``c`` itself or by some "
"class on the base-class search path from ``c.__class__`` back to ``C``."
msgstr ""
"``c.count`` también se refiere a ``C.count`` para cualquier ``c`` tal que "
"``isinstance(c, C)`` se mantenga, a menos que sea anulado por el propio "
"``c`` o por alguna clase en la ruta de búsqueda de la clase base desde ``c."
"__class__`` de vuelta a ``C``."

#: ../../faq/programming.rst:1682
msgid ""
"Caution: within a method of C, an assignment like ``self.count = 42`` "
"creates a new and unrelated instance named \"count\" in ``self``'s own "
"dict.  Rebinding of a class-static data name must always specify the class "
"whether inside a method or not::"
msgstr ""
"Precaución: dentro de un método de C, una asignación como ``self.count = "
"42`` crea una instancia nueva y no relacionada llamada \"count\" en ``self`` "
"el propio diccionario.  El reenlazado de un nombre de dato estático de clase "
"siempre debe especificar la clase, ya sea dentro de un método o no::"

#: ../../faq/programming.rst:1687
msgid "C.count = 314"
msgstr "C.count = 314"

#: ../../faq/programming.rst:1689
msgid "Static methods are possible::"
msgstr "Los métodos estáticos son posibles::"

#: ../../faq/programming.rst:1691
msgid ""
"class C:\n"
"    @staticmethod\n"
"    def static(arg1, arg2, arg3):\n"
"        # No 'self' parameter!\n"
"        ..."
msgstr ""
"class C:\n"
"    @métodoestático\n"
"    def static(arg1, arg2, arg3):\n"
"        # ¡No hay parámetro 'self'!\n"
"        ..."

#: ../../faq/programming.rst:1697
msgid ""
"However, a far more straightforward way to get the effect of a static method "
"is via a simple module-level function::"
msgstr ""
"Sin embargo, una forma mucho más directa de obtener el efecto de un método "
"estático es mediante una simple función a nivel de módulo::"

#: ../../faq/programming.rst:1700
msgid ""
"def getcount():\n"
"    return C.count"
msgstr ""
"def getcount():\n"
"    return C.count"

#: ../../faq/programming.rst:1703
msgid ""
"If your code is structured so as to define one class (or tightly related "
"class hierarchy) per module, this supplies the desired encapsulation."
msgstr ""
"Si su código está estructurado para definir una clase (o una jerarquía de "
"clases estrechamente relacionada) por módulo, esto proporciona la "
"encapsulación deseada."

#: ../../faq/programming.rst:1708
msgid "How can I overload constructors (or methods) in Python?"
msgstr "¿Cómo puedo sobrecargar constructores (o métodos) en Python?"

#: ../../faq/programming.rst:1710
msgid ""
"This answer actually applies to all methods, but the question usually comes "
"up first in the context of constructors."
msgstr ""
"En realidad, esta respuesta se aplica a todos los métodos, pero la pregunta "
"suele plantearse primero en el contexto de los constructores."

#: ../../faq/programming.rst:1713
msgid "In C++ you'd write"
msgstr "En C++ se escribiría"

#: ../../faq/programming.rst:1715
msgid ""
"class C {\n"
"    C() { cout << \"No arguments\\n\"; }\n"
"    C(int i) { cout << \"Argument is \" << i << \"\\n\"; }\n"
"}"
msgstr ""
"class C {\n"
"    C() { cout << \"No arguments\\n\"; }\n"
"    C(int i) { cout << \"Argument is \" << i << \"\\n\"; }\n"
"}"

#: ../../faq/programming.rst:1722
msgid ""
"In Python you have to write a single constructor that catches all cases "
"using default arguments.  For example::"
msgstr ""
"En Python tienes que escribir un único constructor que atrape todos los "
"casos usando argumentos por defecto.  Por ejemplo::"

#: ../../faq/programming.rst:1725
msgid ""
"class C:\n"
"    def __init__(self, i=None):\n"
"        if i is None:\n"
"            print(\"No arguments\")\n"
"        else:\n"
"            print(\"Argument is\", i)"
msgstr ""
"class C:\n"
"    def __init__(self, i=None):\n"
"        if i is None:\n"
"            print(\"No arguments\")\n"
"        else:\n"
"            print(\"Argument is\", i)"

#: ../../faq/programming.rst:1732
msgid "This is not entirely equivalent, but close enough in practice."
msgstr ""
"No es totalmente equivalente, pero en la práctica se aproxima bastante."

#: ../../faq/programming.rst:1734
msgid "You could also try a variable-length argument list, e.g. ::"
msgstr ""
"También puedes probar con una lista de argumentos de longitud variable, por "
"ejemplo ::"

#: ../../faq/programming.rst:1736
msgid ""
"def __init__(self, *args):\n"
"    ..."
msgstr ""
"def __init__(self, *args):\n"
"    ..."

#: ../../faq/programming.rst:1739
msgid "The same approach works for all method definitions."
msgstr "El mismo enfoque funciona para todas las definiciones de métodos."

#: ../../faq/programming.rst:1743
msgid "I try to use __spam and I get an error about _SomeClassName__spam."
msgstr ""
"Intento utilizar __spam y me aparece un error sobre _SomeClassName__spam."

#: ../../faq/programming.rst:1745
msgid ""
"Variable names with double leading underscores are \"mangled\" to provide a "
"simple but effective way to define class private variables.  Any identifier "
"of the form ``__spam`` (at least two leading underscores, at most one "
"trailing underscore) is textually replaced with ``_classname__spam``, where "
"``classname`` is the current class name with any leading underscores "
"stripped."
msgstr ""
"Los nombres de variables con doble guión bajo inicial se \"manipulan\" para "
"proporcionar una forma simple pero eficaz de definir variables privadas de "
"clase.  Cualquier identificador de la forma ``__spam`` (al menos dos guiones "
"bajos iniciales, como máximo un guión bajo final) se sustituye textualmente "
"por ``_classname__spam``, donde ``classname`` es el nombre de la clase "
"actual sin los guiones bajos iniciales."

#: ../../faq/programming.rst:1751
msgid ""
"The identifier can be used unchanged within the class, but to access it "
"outside the class, the mangled name must be used:"
msgstr ""
"El identificador se puede utilizar sin cambios dentro de la clase, pero para "
"acceder a él fuera de la clase, se debe utilizar el nombre modificado:"

#: ../../faq/programming.rst:1754
msgid ""
"class A:\n"
"    def __one(self):\n"
"        return 1\n"
"    def two(self):\n"
"        return 2 * self.__one()\n"
"\n"
"class B(A):\n"
"    def three(self):\n"
"        return 3 * self._A__one()\n"
"\n"
"four = 4 * A()._A__one()"
msgstr ""
"class A:\n"
"    def __one(self):\n"
"        return 1\n"
"    def two(self):\n"
"        return 2 * self.__one()\n"
"\n"
"class B(A):\n"
"    def three(self):\n"
"        return 3 * self._A__one()\n"
"\n"
"four = 4 * A()._A__one()"

#: ../../faq/programming.rst:1768
msgid ""
"In particular, this does not guarantee privacy since an outside user can "
"still deliberately access the private attribute; many Python programmers "
"never bother to use private variable names at all."
msgstr ""
"En particular, esto no garantiza la privacidad, ya que un usuario externo "
"todavía puede acceder deliberadamente al atributo privado; muchos "
"programadores de Python nunca se molestan en utilizar nombres de variables "
"privadas en absoluto."

#: ../../faq/programming.rst:1774
msgid ""
"The :ref:`private name mangling specifications <private-name-mangling>` for "
"details and special cases."
msgstr ""
"Para más detalles y casos especiales, consulte :ref:`private name mangling "
"specifications <private-name-mangling>`."

#: ../../faq/programming.rst:1778
msgid "My class defines __del__ but it is not called when I delete the object."
msgstr "Mi clase define __del__ pero no se llama cuando borro el objeto."

#: ../../faq/programming.rst:1780
msgid "There are several possible reasons for this."
msgstr "Hay varias razones posibles para ello."

#: ../../faq/programming.rst:1782
msgid ""
"The :keyword:`del` statement does not necessarily call :meth:`~object."
"__del__` -- it simply decrements the object's reference count, and if this "
"reaches zero :meth:`!__del__` is called."
msgstr ""
"La sentencia :keyword:`del` no llama necesariamente a :meth:`~object."
"__del__` -- simplemente decrementa la cuenta de referencias del objeto, y si "
"ésta llega a cero se llama a :meth:`!__del__`."

#: ../../faq/programming.rst:1786
msgid ""
"If your data structures contain circular links (e.g. a tree where each child "
"has a parent reference and each parent has a list of children) the reference "
"counts will never go back to zero.  Once in a while Python runs an algorithm "
"to detect such cycles, but the garbage collector might run some time after "
"the last reference to your data structure vanishes, so your :meth:`!__del__` "
"method may be called at an inconvenient and random time. This is "
"inconvenient if you're trying to reproduce a problem. Worse, the order in "
"which object's :meth:`!__del__` methods are executed is arbitrary.  You can "
"run :func:`gc.collect` to force a collection, but there *are* pathological "
"cases where objects will never be collected."
msgstr ""
"Si tus estructuras de datos contienen enlaces circulares (por ejemplo, un "
"árbol donde cada hijo tiene una referencia padre y cada padre tiene una "
"lista de hijos) los recuentos de referencias nunca volverán a cero.  De vez "
"en cuando Python ejecuta un algoritmo para detectar tales ciclos, pero el "
"recolector de basura puede ejecutarse algún tiempo después de que la última "
"referencia a tu estructura de datos desaparezca, por lo que tu método :meth:"
"`!__del__` puede ser llamado en un momento inconveniente y aleatorio. Esto "
"es inconveniente si estás intentando reproducir un problema. Peor aún, el "
"orden en que se ejecutan los métodos :meth:`!__del__` del objeto es "
"arbitrario.  Puedes ejecutar :func:`gc.collect` para forzar una recolección, "
"pero *hay* casos patológicos en los que los objetos nunca serán recolectados."

#: ../../faq/programming.rst:1797
msgid ""
"Despite the cycle collector, it's still a good idea to define an explicit "
"``close()`` method on objects to be called whenever you're done with them.  "
"The ``close()`` method can then remove attributes that refer to subobjects.  "
"Don't call :meth:`!__del__` directly -- :meth:`!__del__` should call "
"``close()`` and ``close()`` should make sure that it can be called more than "
"once for the same object."
msgstr ""
"A pesar del colector de ciclos, sigue siendo una buena idea definir un "
"método ``close()`` explícito en los objetos para que se llame a él siempre "
"que se haya terminado con ellos.  El método ``close()`` puede entonces "
"eliminar atributos que hagan referencia a subobjetos.  No llames a :meth:`!"
"__del__` directamente -- :meth:`!__del__` debe llamar a ``close()`` y "
"``close()`` debe asegurarse de que puede ser llamado más de una vez para el "
"mismo objeto."

#: ../../faq/programming.rst:1804
msgid ""
"Another way to avoid cyclical references is to use the :mod:`weakref` "
"module, which allows you to point to objects without incrementing their "
"reference count. Tree data structures, for instance, should use weak "
"references for their parent and sibling references (if they need them!)."
msgstr ""
"Otra forma de evitar las referencias cíclicas es utilizar el módulo :mod:"
"`weakref`, que permite apuntar a objetos sin incrementar su número de "
"referencias. Las estructuras de datos en árbol, por ejemplo, deberían "
"utilizar referencias débiles para sus referencias a padres y hermanos (¡si "
"las necesitan!)."

#: ../../faq/programming.rst:1817
msgid ""
"Finally, if your :meth:`!__del__` method raises an exception, a warning "
"message is printed to :data:`sys.stderr`."
msgstr ""
"Por último, si el método :meth:`!__del__` genera una excepción, se imprime "
"un mensaje de advertencia en :data:`sys.stderr`."

#: ../../faq/programming.rst:1822
msgid "How do I get a list of all instances of a given class?"
msgstr ""
"¿Cómo puedo obtener una lista de todas las instancias de una clase "
"determinada?"

#: ../../faq/programming.rst:1824
msgid ""
"Python does not keep track of all instances of a class (or of a built-in "
"type). You can program the class's constructor to keep track of all "
"instances by keeping a list of weak references to each instance."
msgstr ""
"Python no mantiene un registro de todas las instancias de una clase (o de un "
"tipo incorporado). Puedes programar el constructor de la clase para que "
"lleve la cuenta de todas las instancias manteniendo una lista de referencias "
"débiles a cada instancia."

#: ../../faq/programming.rst:1830
msgid "Why does the result of ``id()`` appear to be not unique?"
msgstr "¿Por qué parece que el resultado de ``id()`` no es único?"

#: ../../faq/programming.rst:1832
msgid ""
"The :func:`id` builtin returns an integer that is guaranteed to be unique "
"during the lifetime of the object.  Since in CPython, this is the object's "
"memory address, it happens frequently that after an object is deleted from "
"memory, the next freshly created object is allocated at the same position in "
"memory.  This is illustrated by this example:"
msgstr ""
"El builtin :func:`id` devuelve un entero que se garantiza que es único "
"durante la vida del objeto.  Como en CPython, esta es la dirección de "
"memoria del objeto, ocurre frecuentemente que después de que un objeto es "
"borrado de la memoria, el siguiente objeto recién creado es asignado en la "
"misma posición en la memoria.  Esto se ilustra con este ejemplo:"

#: ../../faq/programming.rst:1843
msgid ""
"The two ids belong to different integer objects that are created before, and "
"deleted immediately after execution of the ``id()`` call.  To be sure that "
"objects whose id you want to examine are still alive, create another "
"reference to the object:"
msgstr ""
"Los dos ids pertenecen a objetos enteros diferentes que se crean antes, y se "
"borran inmediatamente después de la ejecución de la llamada a ``id()``.  "
"Para asegurarse de que los objetos cuyo id desea examinar siguen vivos, cree "
"otra referencia al objeto:"

#: ../../faq/programming.rst:1856
msgid "When can I rely on identity tests with the *is* operator?"
msgstr ""
"¿Cuándo puedo confiar en las pruebas de identidad con el operador *is*?"

#: ../../faq/programming.rst:1858
msgid ""
"The ``is`` operator tests for object identity.  The test ``a is b`` is "
"equivalent to ``id(a) == id(b)``."
msgstr ""
"El operador ``is`` comprueba la identidad del objeto.  La prueba ``a is b`` "
"es equivalente a ``id(a) == id(b)``."

#: ../../faq/programming.rst:1861
msgid ""
"The most important property of an identity test is that an object is always "
"identical to itself, ``a is a`` always returns ``True``.  Identity tests are "
"usually faster than equality tests.  And unlike equality tests, identity "
"tests are guaranteed to return a boolean ``True`` or ``False``."
msgstr ""
"La propiedad más importante de una prueba de identidad es que un objeto "
"siempre es idéntico a sí mismo, ``a is a`` siempre devuelve ``True``.  Las "
"pruebas de identidad suelen ser más rápidas que las pruebas de igualdad.  Y "
"a diferencia de las pruebas de igualdad, las pruebas de identidad tienen "
"garantizado el retorno de un booleano ``True`` o ``False``."

#: ../../faq/programming.rst:1866
msgid ""
"However, identity tests can *only* be substituted for equality tests when "
"object identity is assured.  Generally, there are three circumstances where "
"identity is guaranteed:"
msgstr ""
"Sin embargo, las pruebas de identidad *sólo* pueden sustituir a las pruebas "
"de igualdad cuando la identidad del objeto está garantizada.  En general, "
"hay tres circunstancias en las que la identidad está garantizada:"

#: ../../faq/programming.rst:1870
msgid ""
"Assignments create new names but do not change object identity.  After the "
"assignment ``new = old``, it is guaranteed that ``new is old``."
msgstr ""
"Las asignaciones crean nuevos nombres pero no cambian la identidad de los "
"objetos.  Tras la asignación ``new = old``, se garantiza que ``new is old``."

#: ../../faq/programming.rst:1873
msgid ""
"Putting an object in a container that stores object references does not "
"change object identity.  After the list assignment ``s[0] = x``, it is "
"guaranteed that ``s[0] is x``."
msgstr ""
"Colocar un objeto en un contenedor que almacena referencias a objetos no "
"cambia la identidad del objeto.  Tras la asignación de la lista ``s[0] = "
"x``, se garantiza que ``s[0] is x``."

#: ../../faq/programming.rst:1877
msgid ""
"If an object is a singleton, it means that only one instance of that object "
"can exist.  After the assignments ``a = None`` and ``b = None``, it is "
"guaranteed that ``a is b`` because ``None`` is a singleton."
msgstr ""
"Si un objeto es un singleton, significa que sólo puede existir una instancia "
"de ese objeto.  Después de las asignaciones ``a = None`` y ``b = None``, se "
"garantiza que ``a is b`` porque ``None`` es un singleton."

#: ../../faq/programming.rst:1881
msgid ""
"In most other circumstances, identity tests are inadvisable and equality "
"tests are preferred.  In particular, identity tests should not be used to "
"check constants such as :class:`int` and :class:`str` which aren't "
"guaranteed to be singletons::"
msgstr ""
"En la mayoría de las demás circunstancias, las pruebas de identidad son "
"desaconsejables y se prefieren las pruebas de igualdad.  En particular, las "
"pruebas de identidad no deben utilizarse para comprobar constantes como :"
"class:`int` y :class:`str`, que no se garantiza que sean unívocas::"

#: ../../faq/programming.rst:1886
msgid ""
">>> a = 1000\n"
">>> b = 500\n"
">>> c = b + 500\n"
">>> a is c\n"
"False\n"
"\n"
">>> a = 'Python'\n"
">>> b = 'Py'\n"
">>> c = b + 'thon'\n"
">>> a is c\n"
"False"
msgstr ""
">>> a = 1000\n"
">>> b = 500\n"
">>> c = b + 500\n"
">>> a is c\n"
"False\n"
"\n"
">>> a = 'Python'\n"
">>> b = 'Py'\n"
">>> c = b + 'thon'\n"
">>> a is c\n"
"False"

#: ../../faq/programming.rst:1898
msgid "Likewise, new instances of mutable containers are never identical::"
msgstr ""
"Del mismo modo, las nuevas instancias de contenedores mutables nunca son "
"idénticas::"

#: ../../faq/programming.rst:1900
msgid ""
">>> a = []\n"
">>> b = []\n"
">>> a is b\n"
"False"
msgstr ""
">>> a = []\n"
">>> b = []\n"
">>> a is b\n"
"False"

#: ../../faq/programming.rst:1905
msgid ""
"In the standard library code, you will see several common patterns for "
"correctly using identity tests:"
msgstr ""
"En el código de la biblioteca estándar, verá varios patrones comunes para "
"utilizar correctamente las pruebas de identidad:"

#: ../../faq/programming.rst:1908
msgid ""
"As recommended by :pep:`8`, an identity test is the preferred way to check "
"for ``None``.  This reads like plain English in code and avoids confusion "
"with other objects that may have boolean values that evaluate to false."
msgstr ""
"Tal y como recomienda :pep:`8`, una prueba de identidad es la forma "
"preferida de comprobar ``None``.  Esto se lee como inglés sencillo en el "
"código y evita la confusión con otros objetos que pueden tener valores "
"booleanos que se evalúan como falso."

#: ../../faq/programming.rst:1912
msgid ""
"Detecting optional arguments can be tricky when ``None`` is a valid input "
"value.  In those situations, you can create a singleton sentinel object "
"guaranteed to be distinct from other objects.  For example, here is how to "
"implement a method that behaves like :meth:`dict.pop`:"
msgstr ""
"Detectar argumentos opcionales puede ser complicado cuando ``None`` es un "
"valor de entrada válido.  En esas situaciones, puede crear un objeto "
"centinela singleton que garantice que es distinto de otros objetos.  Por "
"ejemplo, así es como se implementa un método que se comporta como :meth:"
"`dict.pop`:"

#: ../../faq/programming.rst:1917
msgid ""
"_sentinel = object()\n"
"\n"
"def pop(self, key, default=_sentinel):\n"
"    if key in self:\n"
"        value = self[key]\n"
"        del self[key]\n"
"        return value\n"
"    if default is _sentinel:\n"
"        raise KeyError(key)\n"
"    return default"
msgstr ""
"_sentinel = object()\n"
"\n"
"def pop(self, key, default=_sentinel):\n"
"    if key in self:\n"
"        value = self[key]\n"
"        del self[key]\n"
"        return value\n"
"    if default is _sentinel:\n"
"        raise KeyError(key)\n"
"    return default"

#: ../../faq/programming.rst:1930
msgid ""
"Container implementations sometimes need to augment equality tests with "
"identity tests.  This prevents the code from being confused by objects such "
"as ``float('NaN')`` that are not equal to themselves."
msgstr ""
"Las implementaciones de contenedores a veces necesitan aumentar las pruebas "
"de igualdad con pruebas de identidad.  Esto evita que el código se confunda "
"con objetos como ``float('NaN')`` que no son iguales a sí mismos."

#: ../../faq/programming.rst:1934
msgid ""
"For example, here is the implementation of :meth:`!collections.abc.Sequence."
"__contains__`::"
msgstr ""
"Por ejemplo, aquí está la implementación de :meth:`!collections.abc.Sequence."
"__contains__`::"

#: ../../faq/programming.rst:1937
msgid ""
"def __contains__(self, value):\n"
"    for v in self:\n"
"        if v is value or v == value:\n"
"            return True\n"
"    return False"
msgstr ""
"def __contains__(self, value):\n"
"    for v in self:\n"
"        if v is value or v == value:\n"
"            return True\n"
"    return False"

#: ../../faq/programming.rst:1945
msgid ""
"How can a subclass control what data is stored in an immutable instance?"
msgstr ""
"¿Cómo puede una subclase controlar qué datos se almacenan en una instancia "
"inmutable?"

#: ../../faq/programming.rst:1947
msgid ""
"When subclassing an immutable type, override the :meth:`~object.__new__` "
"method instead of the :meth:`~object.__init__` method.  The latter only runs "
"*after* an instance is created, which is too late to alter data in an "
"immutable instance."
msgstr ""
"Al subclasificar un tipo inmutable, anule el método :meth:`~object.__new__` "
"en lugar del método :meth:`~object.__init__`.  Este último sólo se ejecuta "
"*después* de que se crea una instancia, que es demasiado tarde para alterar "
"los datos en una instancia inmutable."

#: ../../faq/programming.rst:1952
msgid ""
"All of these immutable classes have a different signature than their parent "
"class:"
msgstr ""
"Todas estas clases inmutables tienen una firma diferente a la de su clase "
"padre:"

#: ../../faq/programming.rst:1955
msgid ""
"from datetime import date\n"
"\n"
"class FirstOfMonthDate(date):\n"
"    \"Always choose the first day of the month\"\n"
"    def __new__(cls, year, month, day):\n"
"        return super().__new__(cls, year, month, 1)\n"
"\n"
"class NamedInt(int):\n"
"    \"Allow text names for some numbers\"\n"
"    xlat = {'zero': 0, 'one': 1, 'ten': 10}\n"
"    def __new__(cls, value):\n"
"        value = cls.xlat.get(value, value)\n"
"        return super().__new__(cls, value)\n"
"\n"
"class TitleStr(str):\n"
"    \"Convert str to name suitable for a URL path\"\n"
"    def __new__(cls, s):\n"
"        s = s.lower().replace(' ', '-')\n"
"        s = ''.join([c for c in s if c.isalnum() or c == '-'])\n"
"        return super().__new__(cls, s)"
msgstr ""
"from datetime import date\n"
"\n"
"class FirstOfMonthDate(date):\n"
"    \"Elige siempre el primer día del mes\"\n"
"    def __new__(cls, year, month, day):\n"
"        return super().__new__(cls, year, month, 1)\n"
"\n"
"class NamedInt(int):\n"
"    \"Permitir nombres de texto para algunos números\"\n"
"    xlat = {'zero': 0, 'one': 1, 'ten': 10}\n"
"    def __new__(cls, value):\n"
"        valor = cls.xlat.get(value, value)\n"
"        return super().__new__(cls, value)\n"
"\n"
"clase TítuloStr(str):\n"
"    \"Convierte str en un nombre adecuado para una ruta URL\"\n"
"    def __new__(cls, s):\n"
"        s = s.lower().replace(' ', '-')\n"
"        s = ''.join([c for c in s if c.isalnum() or c == '-'])\n"
"        return super().__new__(cls, s)"

#: ../../faq/programming.rst:1978
msgid "The classes can be used like this:"
msgstr "Las clases pueden utilizarse así:"

#: ../../faq/programming.rst:1980
msgid ""
">>> FirstOfMonthDate(2012, 2, 14)\n"
"FirstOfMonthDate(2012, 2, 1)\n"
">>> NamedInt('ten')\n"
"10\n"
">>> NamedInt(20)\n"
"20\n"
">>> TitleStr('Blog: Why Python Rocks')\n"
"'blog-why-python-rocks'"
msgstr ""
">>> FirstOfMonthDate(2012, 2, 14)\n"
"FirstOfMonthDate(2012, 2, 1)\n"
">>> NamedInt('ten')\n"
"10\n"
">>> NamedInt(20)\n"
"20\n"
">>> TitleStr('Blog: Why Python Rocks')\n"
"'blog-why-python-rocks'"

#: ../../faq/programming.rst:1995
msgid "How do I cache method calls?"
msgstr "¿Cómo se almacenan en caché las llamadas a métodos?"

#: ../../faq/programming.rst:1997
msgid ""
"The two principal tools for caching methods are :func:`functools."
"cached_property` and :func:`functools.lru_cache`.  The former stores results "
"at the instance level and the latter at the class level."
msgstr ""
"Las dos herramientas principales para almacenar métodos en caché son :func:"
"`functools.cached_property` y :func:`functools.lru_cache`.  La primera "
"almacena los resultados a nivel de instancia y la segunda a nivel de clase."

#: ../../faq/programming.rst:2002
msgid ""
"The *cached_property* approach only works with methods that do not take any "
"arguments.  It does not create a reference to the instance.  The cached "
"method result will be kept only as long as the instance is alive."
msgstr ""
"El método *cached_property* sólo funciona con métodos que no reciben "
"argumentos.  No crea una referencia a la instancia.  El resultado del método "
"almacenado en caché sólo se mantendrá mientras la instancia esté viva."

#: ../../faq/programming.rst:2006
msgid ""
"The advantage is that when an instance is no longer used, the cached method "
"result will be released right away.  The disadvantage is that if instances "
"accumulate, so too will the accumulated method results.  They can grow "
"without bound."
msgstr ""
"La ventaja es que cuando una instancia deja de utilizarse, el resultado del "
"método almacenado en caché se libera de inmediato.  La desventaja es que si "
"las instancias se acumulan, también lo harán los resultados de método "
"acumulados.  Pueden crecer sin límite."

#: ../../faq/programming.rst:2011
msgid ""
"The *lru_cache* approach works with methods that have :term:`hashable` "
"arguments.  It creates a reference to the instance unless special efforts "
"are made to pass in weak references."
msgstr ""
"El enfoque *lru_cache* funciona con métodos que tienen argumentos :term:"
"`hashable`.  Crea una referencia a la instancia a menos que se hagan "
"esfuerzos especiales para pasar referencias débiles."

#: ../../faq/programming.rst:2015
msgid ""
"The advantage of the least recently used algorithm is that the cache is "
"bounded by the specified *maxsize*.  The disadvantage is that instances are "
"kept alive until they age out of the cache or until the cache is cleared."
msgstr ""
"La ventaja del algoritmo de uso menos reciente es que la caché está limitada "
"por el *maxsize* especificado.  La desventaja es que las instancias se "
"mantienen vivas hasta que envejecen fuera de la caché o hasta que se borra "
"la caché."

#: ../../faq/programming.rst:2020
msgid "This example shows the various techniques::"
msgstr "Este ejemplo muestra las distintas técnicas::"

#: ../../faq/programming.rst:2022
msgid ""
"class Weather:\n"
"    \"Lookup weather information on a government website\"\n"
"\n"
"    def __init__(self, station_id):\n"
"        self._station_id = station_id\n"
"        # The _station_id is private and immutable\n"
"\n"
"    def current_temperature(self):\n"
"        \"Latest hourly observation\"\n"
"        # Do not cache this because old results\n"
"        # can be out of date.\n"
"\n"
"    @cached_property\n"
"    def location(self):\n"
"        \"Return the longitude/latitude coordinates of the station\"\n"
"        # Result only depends on the station_id\n"
"\n"
"    @lru_cache(maxsize=20)\n"
"    def historic_rainfall(self, date, units='mm'):\n"
"        \"Rainfall on a given date\"\n"
"        # Depends on the station_id, date, and units."
msgstr ""
"clase Tiempo:\n"
"    \"Busca información meteorológica en una página web gubernamental\"\n"
"\n"
"    def __init__(self, station_id):\n"
"        self._station_id = station_id\n"
"        # El _station_id es privado e inmutable\n"
"\n"
"    def current_temperature(self):\n"
"        \"Latest hourly observation\"\n"
"        # No guardes esto en caché porque los resultados antiguos\n"
"       # pueden estar desactualizados.\n"
"    @cached_property\n"
"    def location(self):\n"
"        \"Devuelve las coordenadas de longitud/latitud de la estación\"\n"
"       # El resultado sólo depende del station_id\n"
"    @lru_cache(maxsize=20)\n"
"    def historic_rainfall(self, date, units='mm'):\n"
"        \"Precipitación en una fecha dada\"\n"
"      # Depende del station_id, fecha y unidades."

#: ../../faq/programming.rst:2044
msgid ""
"The above example assumes that the *station_id* never changes.  If the "
"relevant instance attributes are mutable, the *cached_property* approach "
"can't be made to work because it cannot detect changes to the attributes."
msgstr ""
"El ejemplo anterior asume que *station_id* nunca cambia.  Si los atributos "
"de instancia relevantes son mutables, el enfoque *cached_property* no puede "
"funcionar porque no puede detectar cambios en los atributos."

#: ../../faq/programming.rst:2049
msgid ""
"To make the *lru_cache* approach work when the *station_id* is mutable, the "
"class needs to define the :meth:`~object.__eq__` and :meth:`~object."
"__hash__` methods so that the cache can detect relevant attribute updates::"
msgstr ""
"Para que el enfoque *lru_cache* funcione cuando el *station_id* es mutable, "
"la clase necesita definir los métodos :meth:`~object.__eq__` y :meth:"
"`~object.__hash__` para que la caché pueda detectar las actualizaciones de "
"atributos relevantes::"

#: ../../faq/programming.rst:2053
msgid ""
"class Weather:\n"
"    \"Example with a mutable station identifier\"\n"
"\n"
"    def __init__(self, station_id):\n"
"        self.station_id = station_id\n"
"\n"
"    def change_station(self, station_id):\n"
"        self.station_id = station_id\n"
"\n"
"    def __eq__(self, other):\n"
"        return self.station_id == other.station_id\n"
"\n"
"    def __hash__(self):\n"
"        return hash(self.station_id)\n"
"\n"
"    @lru_cache(maxsize=20)\n"
"    def historic_rainfall(self, date, units='cm'):\n"
"        'Rainfall on a given date'\n"
"        # Depends on the station_id, date, and units."
msgstr ""
"clase Tiempo:\n"
"    \"Ejemplo con un identificador de estación mutable\"\n"
"    def __init__(self, station_id):\n"
"        self.station_id = station_id\n"
"\n"
"    def change_station(self, station_id):\n"
"        self.station_id = station_id\n"
"\n"
"    def __eq__(self, other):\n"
"        return self.station_id == other.station_id\n"
"\n"
"    def __hash__(self):\n"
"        return hash(self.station_id)\n"
"\n"
"    @lru_cache(maxsize=20)\n"
"    def historic_rainfall(self, date, units='cm'):\n"
"        'Precipitación en una fecha dada'\n"
"       # Depende de station_id, fecha y unidades."

#: ../../faq/programming.rst:2075
msgid "Modules"
msgstr "Módulos"

#: ../../faq/programming.rst:2078
msgid "How do I create a .pyc file?"
msgstr "¿Cómo se crea un archivo .pyc?"

#: ../../faq/programming.rst:2080
msgid ""
"When a module is imported for the first time (or when the source file has "
"changed since the current compiled file was created) a ``.pyc`` file "
"containing the compiled code should be created in a ``__pycache__`` "
"subdirectory of the directory containing the ``.py`` file.  The ``.pyc`` "
"file will have a filename that starts with the same name as the ``.py`` "
"file, and ends with ``.pyc``, with a middle component that depends on the "
"particular ``python`` binary that created it.  (See :pep:`3147` for details.)"
msgstr ""
"Cuando se importa un módulo por primera vez (o cuando el archivo fuente ha "
"cambiado desde que se creó el archivo compilado actual) debe crearse un "
"archivo ``.pyc`` que contenga el código compilado en un subdirectorio "
"``__pycache__`` del directorio que contiene el archivo ``.py``.  El archivo "
"``.pyc`` tendrá un nombre de archivo que comienza con el mismo nombre que el "
"archivo ``.py``, y termina con ``.pyc``, con un componente intermedio que "
"depende del binario ``python`` particular que lo creó.  (Para más detalles, "
"ver :pep:`3147`)."

#: ../../faq/programming.rst:2088
msgid ""
"One reason that a ``.pyc`` file may not be created is a permissions problem "
"with the directory containing the source file, meaning that the "
"``__pycache__`` subdirectory cannot be created. This can happen, for "
"example, if you develop as one user but run as another, such as if you are "
"testing with a web server."
msgstr ""
"Una de las razones por las que puede no crearse un archivo ``.pyc`` es un "
"problema de permisos en el directorio que contiene el archivo fuente, lo que "
"significa que no puede crearse el subdirectorio ``__pycache__``. Esto puede "
"ocurrir, por ejemplo, si desarrollas como un usuario pero ejecutas como "
"otro, como si estuvieras probando con un servidor web."

#: ../../faq/programming.rst:2093
msgid ""
"Unless the :envvar:`PYTHONDONTWRITEBYTECODE` environment variable is set, "
"creation of a .pyc file is automatic if you're importing a module and Python "
"has the ability (permissions, free space, etc...) to create a "
"``__pycache__`` subdirectory and write the compiled module to that "
"subdirectory."
msgstr ""
"A menos que se establezca la variable de entorno :envvar:"
"`PYTHONDONTWRITEBYTECODE`, la creación de un archivo .pyc es automática si "
"estás importando un módulo y Python tiene la capacidad (permisos, espacio "
"libre, etc...) de crear un subdirectorio ``__pycache__`` y escribir el "
"módulo compilado en ese subdirectorio."

#: ../../faq/programming.rst:2098
msgid ""
"Running Python on a top level script is not considered an import and no ``."
"pyc`` will be created.  For example, if you have a top-level module ``foo."
"py`` that imports another module ``xyz.py``, when you run ``foo`` (by typing "
"``python foo.py`` as a shell command), a ``.pyc`` will be created for "
"``xyz`` because ``xyz`` is imported, but no ``.pyc`` file will be created "
"for ``foo`` since ``foo.py`` isn't being imported."
msgstr ""
"Ejecutar Python en un script de nivel superior no se considera una "
"importación y no se creará ningún ``.pyc``.  Por ejemplo, si tiene un módulo "
"de nivel superior ``foo.py`` que importa otro módulo ``xyz.py``, cuando "
"ejecute ``foo`` (escribiendo ``python foo.py`` como comando del shell), se "
"creará un archivo ``.pyc`` para ``xyz`` porque se importa ``xyz``, pero no "
"se creará ningún archivo ``.pyc`` para ``foo`` porque no se importa ``foo."
"py``."

#: ../../faq/programming.rst:2105
msgid ""
"If you need to create a ``.pyc`` file for ``foo`` -- that is, to create a ``."
"pyc`` file for a module that is not imported -- you can, using the :mod:"
"`py_compile` and :mod:`compileall` modules."
msgstr ""
"Si necesita crear un archivo ``.pyc`` para ``foo`` -- es decir, crear un "
"archivo ``.pyc`` para un módulo que no se importa -- puede hacerlo, "
"utilizando los módulos :mod:`py_compile` y :mod:`compileall`."

#: ../../faq/programming.rst:2109
msgid ""
"The :mod:`py_compile` module can manually compile any module.  One way is to "
"use the ``compile()`` function in that module interactively::"
msgstr ""
"El módulo :mod:`py_compile` puede compilar manualmente cualquier módulo.  "
"Una forma es utilizar la función ``compile()`` en ese módulo de forma "
"interactiva::"

#: ../../faq/programming.rst:2112
msgid ""
">>> import py_compile\n"
">>> py_compile.compile('foo.py')"
msgstr ""
">>> import py_compile\n"
">>> py_compile.compile('foo.py')"

#: ../../faq/programming.rst:2115
msgid ""
"This will write the ``.pyc`` to a ``__pycache__`` subdirectory in the same "
"location as ``foo.py`` (or you can override that with the optional parameter "
"``cfile``)."
msgstr ""
"Esto escribirá ``.pyc`` en un subdirectorio ``__pycache__`` en la misma "
"ubicación que ``foo.py`` (o puede anularlo con el parámetro opcional "
"``cfile``)."

#: ../../faq/programming.rst:2119
msgid ""
"You can also automatically compile all files in a directory or directories "
"using the :mod:`compileall` module.  You can do it from the shell prompt by "
"running ``compileall.py`` and providing the path of a directory containing "
"Python files to compile::"
msgstr ""
"También puedes compilar automáticamente todos los archivos de un directorio "
"o directorios utilizando el módulo :mod:`compileall`.  Puede hacerlo desde "
"el intérprete de comandos ejecutando ``compileall.py`` y proporcionando la "
"ruta de un directorio que contenga archivos Python para compilar::"

#: ../../faq/programming.rst:2124
msgid "python -m compileall ."
msgstr "python -m compileall ."

#: ../../faq/programming.rst:2128
msgid "How do I find the current module name?"
msgstr "¿Cómo encuentro el nombre del módulo actual?"

#: ../../faq/programming.rst:2130
msgid ""
"A module can find out its own module name by looking at the predefined "
"global variable ``__name__``.  If this has the value ``'__main__'``, the "
"program is running as a script.  Many modules that are usually used by "
"importing them also provide a command-line interface or a self-test, and "
"only execute this code after checking ``__name__``::"
msgstr ""
"Un módulo puede averiguar su propio nombre de módulo consultando la variable "
"global predefinida ``__name__``.  Si ésta tiene el valor ``'__main__'``, el "
"programa se está ejecutando como un script.  Muchos módulos que se suelen "
"utilizar importándolos también proporcionan una interfaz de línea de "
"comandos o una autocomprobación, y sólo ejecutan este código después de "
"comprobar ``__name__``::"

#: ../../faq/programming.rst:2136
msgid ""
"def main():\n"
"    print('Running test...')\n"
"    ...\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""
"def main():\n"
"    print('Running test...')\n"
"    ...\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"

#: ../../faq/programming.rst:2145
msgid "How can I have modules that mutually import each other?"
msgstr "¿Cómo puedo tener módulos que se importen mutuamente?"

#: ../../faq/programming.rst:2147
msgid "Suppose you have the following modules:"
msgstr "Supongamos que tiene los siguientes módulos:"

#: ../../faq/programming.rst:2149
msgid ":file:`foo.py`::"
msgstr ":file:`foo.py`::"

#: ../../faq/programming.rst:2151
msgid ""
"from bar import bar_var\n"
"foo_var = 1"
msgstr ""
"from bar import bar_var\n"
"foo_var = 1"

#: ../../faq/programming.rst:2154
msgid ":file:`bar.py`::"
msgstr ":file:`bar.py`::"

#: ../../faq/programming.rst:2156
msgid ""
"from foo import foo_var\n"
"bar_var = 2"
msgstr ""
"from foo import foo_var\n"
"bar_var = 2"

#: ../../faq/programming.rst:2159
msgid "The problem is that the interpreter will perform the following steps:"
msgstr "El problema es que el intérprete realizará los siguientes pasos:"

#: ../../faq/programming.rst:2161
msgid "main imports ``foo``"
msgstr "principales importaciones ``foo``"

#: ../../faq/programming.rst:2162
msgid "Empty globals for ``foo`` are created"
msgstr "Se crean globales vacíos para ``foo`` "

#: ../../faq/programming.rst:2163
msgid "``foo`` is compiled and starts executing"
msgstr "``foo`` se compila y comienza a ejecutarse"

#: ../../faq/programming.rst:2164
msgid "``foo`` imports ``bar``"
msgstr "``foo`` importaciones ``bar``"

#: ../../faq/programming.rst:2165
msgid "Empty globals for ``bar`` are created"
msgstr "Se crean globales vacíos para ``bar`` "

#: ../../faq/programming.rst:2166
msgid "``bar`` is compiled and starts executing"
msgstr "``bar`` se compila y comienza a ejecutarse"

#: ../../faq/programming.rst:2167
msgid ""
"``bar`` imports ``foo`` (which is a no-op since there already is a module "
"named ``foo``)"
msgstr ""
"``bar`` importa ``foo`` (que es un no-op puesto que ya existe un módulo "
"llamado ``foo``)"

#: ../../faq/programming.rst:2168
msgid ""
"The import mechanism tries to read ``foo_var`` from ``foo`` globals, to set "
"``bar.foo_var = foo.foo_var``"
msgstr ""
"El mecanismo de importación intenta leer ``foo_var`` desde ``foo`` globals, "
"para establecer ``bar.foo_var = foo.foo_var``"

#: ../../faq/programming.rst:2170
msgid ""
"The last step fails, because Python isn't done with interpreting ``foo`` yet "
"and the global symbol dictionary for ``foo`` is still empty."
msgstr ""
"El último paso falla, porque Python aún no ha terminado de interpretar "
"``foo`` y el diccionario global de símbolos para ``foo`` aún está vacío."

#: ../../faq/programming.rst:2173
msgid ""
"The same thing happens when you use ``import foo``, and then try to access "
"``foo.foo_var`` in global code."
msgstr ""
"Lo mismo ocurre cuando se utiliza ``import foo``, y luego se intenta acceder "
"a ``foo.foo_var`` en código global."

#: ../../faq/programming.rst:2176
msgid "There are (at least) three possible workarounds for this problem."
msgstr "Existen (al menos) tres posibles soluciones a este problema."

#: ../../faq/programming.rst:2178
msgid ""
"Guido van Rossum recommends avoiding all uses of ``from <module> import ..."
"``, and placing all code inside functions.  Initializations of global "
"variables and class variables should use constants or built-in functions "
"only.  This means everything from an imported module is referenced as "
"``<module>.<name>``."
msgstr ""
"Guido van Rossum recomienda evitar todo uso de ``from <module> import ...``, "
"y colocar todo el código dentro de funciones.  Las inicializaciones de "
"variables globales y variables de clase deben usar sólo constantes o "
"funciones integradas.  Esto significa que todo lo que provenga de un módulo "
"importado se referenciará como ``<module>.<name>``."

#: ../../faq/programming.rst:2183
msgid ""
"Jim Roskind suggests performing steps in the following order in each module:"
msgstr ""
"Jim Roskind sugiere realizar los pasos en el siguiente orden en cada módulo:"

#: ../../faq/programming.rst:2185
msgid ""
"exports (globals, functions, and classes that don't need imported base "
"classes)"
msgstr ""
"exportaciones (globales, funciones y clases que no necesitan clases base "
"importadas)"

#: ../../faq/programming.rst:2187
msgid "``import`` statements"
msgstr "``import`` declaraciones"

#: ../../faq/programming.rst:2188
msgid ""
"active code (including globals that are initialized from imported values)."
msgstr ""
"código activo (incluidos los globales que se inicializan a partir de valores "
"importados)."

#: ../../faq/programming.rst:2190
msgid ""
"Van Rossum doesn't like this approach much because the imports appear in a "
"strange place, but it does work."
msgstr ""
"A Van Rossum no le gusta mucho este enfoque porque las importaciones "
"aparecen en un lugar extraño, pero funciona."

#: ../../faq/programming.rst:2193
msgid ""
"Matthias Urlichs recommends restructuring your code so that the recursive "
"import is not necessary in the first place."
msgstr ""
"Matthias Urlichs recomienda reestructurar el código para que la importación "
"recursiva no sea necesaria en primer lugar."

#: ../../faq/programming.rst:2196
msgid "These solutions are not mutually exclusive."
msgstr "Estas soluciones no se excluyen mutuamente."

#: ../../faq/programming.rst:2200
msgid "__import__('x.y.z') returns <module 'x'>; how do I get z?"
msgstr "__import__('x.y.z') devuelve <module 'x'>; ¿cómo obtengo z?"

#: ../../faq/programming.rst:2202
msgid ""
"Consider using the convenience function :func:`~importlib.import_module` "
"from :mod:`importlib` instead::"
msgstr ""
"Considere la posibilidad de utilizar la función :func:`~importlib."
"import_module` de :mod:`importlib` en su lugar::"

#: ../../faq/programming.rst:2205
msgid "z = importlib.import_module('x.y.z')"
msgstr "z = importlib.import_module('x.y.z')"

#: ../../faq/programming.rst:2209
msgid ""
"When I edit an imported module and reimport it, the changes don't show up.  "
"Why does this happen?"
msgstr ""
"Cuando edito un módulo importado y lo reimporto, los cambios no aparecen.  "
"¿Por qué ocurre esto?"

#: ../../faq/programming.rst:2211
msgid ""
"For reasons of efficiency as well as consistency, Python only reads the "
"module file on the first time a module is imported.  If it didn't, in a "
"program consisting of many modules where each one imports the same basic "
"module, the basic module would be parsed and re-parsed many times.  To force "
"re-reading of a changed module, do this::"
msgstr ""
"Por razones de eficiencia y coherencia, Python sólo lee el archivo del "
"módulo la primera vez que se importa un módulo.  Si no lo hiciera, en un "
"programa consistente en muchos módulos donde cada uno importa el mismo "
"módulo básico, el módulo básico sería analizado y re-analizado muchas "
"veces.  Para forzar la relectura de un módulo modificado, haga lo siguiente::"

#: ../../faq/programming.rst:2217
msgid ""
"import importlib\n"
"import modname\n"
"importlib.reload(modname)"
msgstr ""
"import importlib\n"
"import modname\n"
"importlib.reload(modname)"

#: ../../faq/programming.rst:2221
msgid ""
"Warning: this technique is not 100% fool-proof.  In particular, modules "
"containing statements like ::"
msgstr ""
"Atención: esta técnica no es 100% infalible.  En particular, los módulos que "
"contienen declaraciones como ::"

#: ../../faq/programming.rst:2224
msgid "from modname import some_objects"
msgstr "from modname import some_objects"

#: ../../faq/programming.rst:2226
msgid ""
"will continue to work with the old version of the imported objects.  If the "
"module contains class definitions, existing class instances will *not* be "
"updated to use the new class definition.  This can result in the following "
"paradoxical behaviour::"
msgstr ""
"seguirá funcionando con la versión antigua de los objetos importados.  Si el "
"módulo contiene definiciones de clase, las instancias de clase existentes "
"*no* se actualizarán para utilizar la nueva definición de clase.  Esto puede "
"dar lugar al siguiente comportamiento paradójico::"

#: ../../faq/programming.rst:2231
msgid ""
">>> import importlib\n"
">>> import cls\n"
">>> c = cls.C()                # Create an instance of C\n"
">>> importlib.reload(cls)\n"
"<module 'cls' from 'cls.py'>\n"
">>> isinstance(c, cls.C)       # isinstance is false?!?\n"
"False"
msgstr ""
">>> import importlib\n"
">>> import cls\n"
">>> c = cls.C() # Crea una instancia de C\n"
">>> importlib.reload(cls)\n"
"<module 'cls' from 'cls.py'>\n"
">>> isinstance(c, cls.C) # ¿¡isinstance es falso!?\n"
"False"

#: ../../faq/programming.rst:2239
msgid ""
"The nature of the problem is made clear if you print out the \"identity\" of "
"the class objects::"
msgstr ""
"La naturaleza del problema queda clara si se imprime la \"identidad\" de los "
"objetos de clase::"

#: ../../faq/programming.rst:2242
msgid ""
">>> hex(id(c.__class__))\n"
"'0x7352a0'\n"
">>> hex(id(cls.C))\n"
"'0x4198d0'"
msgstr ""
">>> hex(id(c.__class__))\n"
"'0x7352a0'\n"
">>> hex(id(cls.C))\n"
"'0x4198d0'"

#: ../../faq/programming.rst:408
msgid "argument"
msgstr "argumento"

#: ../../faq/programming.rst:408
msgid "difference from parameter"
msgstr "diferencia del parámetro"

#: ../../faq/programming.rst:408
msgid "parameter"
msgstr "parámetro"

#: ../../faq/programming.rst:408
msgid "difference from argument"
msgstr "diferencia con el argumento"
