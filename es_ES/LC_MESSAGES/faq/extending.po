# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-09 14:15+0000\n"
"PO-Revision-Date: 2025-08-15 19:00+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Spanish (Spain) (https://app.transifex.com/python-doc/"
"teams/5390/es_ES/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es_ES\n"
"Plural-Forms: nplurals=3; plural=n == 1 ? 0 : n != 0 && n % 1000000 == 0 ? "
"1 : 2;\n"

#: ../../faq/extending.rst:3
msgid "Extending/Embedding FAQ"
msgstr "Preguntas frecuentes Extensión/Incrustación "

#: ../../faq/extending.rst:6
msgid "Contents"
msgstr "Contenido"

#: ../../faq/extending.rst:16
msgid "Can I create my own functions in C?"
msgstr "¿Puedo crear mis propias funciones en C?"

#: ../../faq/extending.rst:18
msgid ""
"Yes, you can create built-in modules containing functions, variables, "
"exceptions and even new types in C.  This is explained in the document :ref:"
"`extending-index`."
msgstr ""
"Sí, puedes crear módulos integrados que contengan funciones, variables, "
"excepciones e incluso nuevos tipos en C. Esto se explica en el documento :"
"ref:`extending-index`."

#: ../../faq/extending.rst:22
msgid "Most intermediate or advanced Python books will also cover this topic."
msgstr ""
"La mayoría de los libros de Python intermedios o avanzados también tratarán "
"este tema."

#: ../../faq/extending.rst:26
msgid "Can I create my own functions in C++?"
msgstr "¿Puedo crear mis propias funciones en C++?"

#: ../../faq/extending.rst:28
msgid ""
"Yes, using the C compatibility features found in C++.  Place ``extern "
"\"C\" { ... }`` around the Python include files and put ``extern \"C\"`` "
"before each function that is going to be called by the Python interpreter.  "
"Global or static C++ objects with constructors are probably not a good idea."
msgstr ""
"Sí, utilizando las características de compatibilidad con C que se encuentran "
"en C++.  Coloca ``extern \"C\" { ... }`` alrededor de los archivos de "
"inclusión de Python y pon ``extern \"C\"`` antes de cada función que vaya a "
"ser llamada por el intérprete de Python.  Los objetos C++ globales o "
"estáticos con constructores no son probablemente una buena idea."

#: ../../faq/extending.rst:37
msgid "Writing C is hard; are there any alternatives?"
msgstr "Escribir en C es difícil; ¿existen alternativas?"

#: ../../faq/extending.rst:39
msgid ""
"There are a number of alternatives to writing your own C extensions, "
"depending on what you're trying to do. :ref:`Recommended third party tools "
"<c-api-tools>` offer both simpler and more sophisticated approaches to "
"creating C and C++ extensions for Python."
msgstr ""

#: ../../faq/extending.rst:46
msgid "How can I execute arbitrary Python statements from C?"
msgstr "¿Cómo puedo ejecutar declaraciones arbitrarias de Python desde C?"

#: ../../faq/extending.rst:48
msgid ""
"The highest-level function to do this is :c:func:`PyRun_SimpleString` which "
"takes a single string argument to be executed in the context of the module "
"``__main__`` and returns ``0`` for success and ``-1`` when an exception "
"occurred (including :exc:`SyntaxError`).  If you want more control, use :c:"
"func:`PyRun_String`; see the source for :c:func:`PyRun_SimpleString` in "
"``Python/pythonrun.c``."
msgstr ""
"La función de más alto nivel para hacer esto es :c:func:`PyRun_SimpleString` "
"que toma un único argumento de cadena para ejecutarse en el contexto del "
"módulo ``__main__`` y devuelve ``0`` en caso de éxito y ``-1`` cuando se "
"produce una excepción (incluyendo :exc:`SyntaxError`).  Si desea un mayor "
"control, use :c:func:`PyRun_String`; ver el código fuente de :c:func:"
"`PyRun_SimpleString` en ``Python/pythonrun.c``."

#: ../../faq/extending.rst:57
msgid "How can I evaluate an arbitrary Python expression from C?"
msgstr "¿Cómo puedo evaluar una expresión arbitraria de Python desde C?"

#: ../../faq/extending.rst:59
msgid ""
"Call the function :c:func:`PyRun_String` from the previous question with the "
"start symbol :c:data:`Py_eval_input`; it parses an expression, evaluates it "
"and returns its value."
msgstr ""
"Llama a la función :c:func:`PyRun_String` de la pregunta anterior con el "
"símbolo de inicio :c:data:`Py_eval_input`; analiza una expresión, la evalúa "
"y devuelve su valor."

#: ../../faq/extending.rst:65
msgid "How do I extract C values from a Python object?"
msgstr "¿Cómo extraigo los valores C de un objeto Python?"

#: ../../faq/extending.rst:67
msgid ""
"That depends on the object's type.  If it's a tuple, :c:func:`PyTuple_Size` "
"returns its length and :c:func:`PyTuple_GetItem` returns the item at a "
"specified index.  Lists have similar functions, :c:func:`PyList_Size` and :c:"
"func:`PyList_GetItem`."
msgstr ""

#: ../../faq/extending.rst:72
msgid ""
"For bytes, :c:func:`PyBytes_Size` returns its length and :c:func:"
"`PyBytes_AsStringAndSize` provides a pointer to its value and its length.  "
"Note that Python bytes objects may contain null bytes so C's :c:func:`!"
"strlen` should not be used."
msgstr ""

#: ../../faq/extending.rst:77
msgid ""
"To test the type of an object, first make sure it isn't ``NULL``, and then "
"use :c:func:`PyBytes_Check`, :c:func:`PyTuple_Check`, :c:func:"
"`PyList_Check`, etc."
msgstr ""
"Para probar el tipo de un objeto, primero asegúrese de que no sea ``NULL``, "
"y luego use :c:func:`PyBytes_Check`, :c:func:`PyTuple_Check`, :c:func:"
"`PyList_Check`, etc."

#: ../../faq/extending.rst:80
msgid ""
"There is also a high-level API to Python objects which is provided by the so-"
"called 'abstract' interface -- read ``Include/abstract.h`` for further "
"details.  It allows interfacing with any kind of Python sequence using calls "
"like :c:func:`PySequence_Length`, :c:func:`PySequence_GetItem`, etc. as well "
"as many other useful protocols such as numbers (:c:func:`PyNumber_Index` et "
"al.) and mappings in the PyMapping APIs."
msgstr ""
"También hay una API de alto nivel para objetos de Python que es "
"proporcionada por la llamada interfaz 'abstracta' -- leer ``Include/abstract."
"h`` para más detalles. Permite la interfaz con cualquier tipo de secuencia "
"de Python utilizando llamadas como :c:func:`PySequence_Length`, :c:func:"
"`PySequence_GetItem`, etc. así como muchos otros protocolos útiles como "
"números (:c:func:`PyNumber_Index` et al.) y mapeos en las APIs de PyMapping."

#: ../../faq/extending.rst:89
msgid "How do I use Py_BuildValue() to create a tuple of arbitrary length?"
msgstr "¿Cómo uso Py_BuildValue() para crear una tupla de longitud arbitraria?"

#: ../../faq/extending.rst:91
msgid "You can't.  Use :c:func:`PyTuple_Pack` instead."
msgstr "No puedes. Usa :c:func:`PyTuple_Pack` en su lugar."

#: ../../faq/extending.rst:95
msgid "How do I call an object's method from C?"
msgstr "¿Cómo llamo al método de un objeto desde C?"

#: ../../faq/extending.rst:97
msgid ""
"The :c:func:`PyObject_CallMethod` function can be used to call an arbitrary "
"method of an object.  The parameters are the object, the name of the method "
"to call, a format string like that used with :c:func:`Py_BuildValue`, and "
"the argument values::"
msgstr ""
"La función :c:func:`PyObject_CallMethod` se puede utilizar para llamar a un "
"método arbitrario de un objeto. Los parámetros son el objeto, el nombre del "
"método a llamar, una cadena de formato similar a la utilizada con :c:func:"
"`Py_BuildValue`, y los valores de los argumentos::"

#: ../../faq/extending.rst:102
msgid ""
"PyObject *\n"
"PyObject_CallMethod(PyObject *object, const char *method_name,\n"
"                    const char *arg_format, ...);"
msgstr ""

#: ../../faq/extending.rst:106
msgid ""
"This works for any object that has methods -- whether built-in or user-"
"defined. You are responsible for eventually :c:func:`Py_DECREF`\\ 'ing the "
"return value."
msgstr ""
"Esto funciona para cualquier objeto que tenga métodos, ya sean incorporados "
"o definidos por el usuario. Eres responsable de eventualmente :c:func:"
"`Py_DECREF`\\ 'ing el valor de retorno."

#: ../../faq/extending.rst:109
msgid ""
"To call, e.g., a file object's \"seek\" method with arguments 10, 0 "
"(assuming the file object pointer is \"f\")::"
msgstr ""
"Para llamar, por ejemplo, el método \"seek\" de un objeto de archivo con los "
"argumentos 10, 0 (suponiendo que el puntero del objeto de archivo es \"f\")::"

#: ../../faq/extending.rst:112
msgid ""
"res = PyObject_CallMethod(f, \"seek\", \"(ii)\", 10, 0);\n"
"if (res == NULL) {\n"
"        ... an exception occurred ...\n"
"}\n"
"else {\n"
"        Py_DECREF(res);\n"
"}"
msgstr ""

#: ../../faq/extending.rst:120
msgid ""
"Note that since :c:func:`PyObject_CallObject` *always* wants a tuple for the "
"argument list, to call a function without arguments, pass \"()\" for the "
"format, and to call a function with one argument, surround the argument in "
"parentheses, e.g. \"(i)\"."
msgstr ""
"Tenga en cuenta que, dado que :c:func:`PyObject_CallObject` *siempre* "
"requiere una tupla para la lista de argumentos, para llamar a una función "
"sin argumentos, pase \"()\" para el formato, y para llamar a una función con "
"un argumento, rodee el argumento entre paréntesis, por ejemplo, \"(i)\"."

#: ../../faq/extending.rst:127
msgid ""
"How do I catch the output from PyErr_Print() (or anything that prints to "
"stdout/stderr)?"
msgstr ""
"¿Cómo puedo capturar la salida de PyErr_Print() (o cualquier cosa que "
"imprima en stdout/stderr)?"

#: ../../faq/extending.rst:129
msgid ""
"In Python code, define an object that supports the ``write()`` method.  "
"Assign this object to :data:`sys.stdout` and :data:`sys.stderr`.  Call "
"print_error, or just allow the standard traceback mechanism to work. Then, "
"the output will go wherever your ``write()`` method sends it."
msgstr ""
"En el código de Python, define un objeto que admita el método ``write()``. "
"Asigna este objeto a :data:`sys.stdout` y :data:`sys.stderr`. Llama a "
"print_error, o simplemente permite que el mecanismo de seguimiento estándar "
"funcione. Luego, la salida irá donde tu método ``write()`` la envíe."

#: ../../faq/extending.rst:134
msgid "The easiest way to do this is to use the :class:`io.StringIO` class:"
msgstr ""
"La forma más fácil de hacer esto es usar la clase :class:`io.StringIO`."

#: ../../faq/extending.rst:136
msgid ""
">>> import io, sys\n"
">>> sys.stdout = io.StringIO()\n"
">>> print('foo')\n"
">>> print('hello world!')\n"
">>> sys.stderr.write(sys.stdout.getvalue())\n"
"foo\n"
"hello world!"
msgstr ""

#: ../../faq/extending.rst:146
msgid "A custom object to do the same would look like this:"
msgstr "Un objeto personalizado para hacer lo mismo se vería así:"

#: ../../faq/extending.rst:148
msgid ""
">>> import io, sys\n"
">>> class StdoutCatcher(io.TextIOBase):\n"
"...     def __init__(self):\n"
"...         self.data = []\n"
"...     def write(self, stuff):\n"
"...         self.data.append(stuff)\n"
"...\n"
">>> import sys\n"
">>> sys.stdout = StdoutCatcher()\n"
">>> print('foo')\n"
">>> print('hello world!')\n"
">>> sys.stderr.write(''.join(sys.stdout.data))\n"
"foo\n"
"hello world!"
msgstr ""

#: ../../faq/extending.rst:167
msgid "How do I access a module written in Python from C?"
msgstr "¿Cómo accedo a un módulo escrito en Python desde C?"

#: ../../faq/extending.rst:169
msgid "You can get a pointer to the module object as follows::"
msgstr "Puede obtener un puntero al objeto del módulo de la siguiente manera:"

#: ../../faq/extending.rst:171
msgid "module = PyImport_ImportModule(\"<modulename>\");"
msgstr ""

#: ../../faq/extending.rst:173
msgid ""
"If the module hasn't been imported yet (i.e. it is not yet present in :data:"
"`sys.modules`), this initializes the module; otherwise it simply returns the "
"value of ``sys.modules[\"<modulename>\"]``.  Note that it doesn't enter the "
"module into any namespace -- it only ensures it has been initialized and is "
"stored in :data:`sys.modules`."
msgstr ""
"Si el módulo aún no ha sido importado (es decir, no está presente en :data:"
"`sys.modules`), esto inicializa el módulo; de lo contrario, simplemente "
"devuelve el valor de ``sys.modules[\"<modulename>\"]``. Tenga en cuenta que "
"no ingresa el módulo en ningún espacio de nombres, solo se asegura de que se "
"haya inicializado y se almacene en :data:`sys.modules`."

#: ../../faq/extending.rst:179
msgid ""
"You can then access the module's attributes (i.e. any name defined in the "
"module) as follows::"
msgstr ""
"Puede acceder a los atributos del módulo (es decir, cualquier nombre "
"definido en el módulo) de la siguiente manera:"

#: ../../faq/extending.rst:182
msgid "attr = PyObject_GetAttrString(module, \"<attrname>\");"
msgstr ""

#: ../../faq/extending.rst:184
msgid ""
"Calling :c:func:`PyObject_SetAttrString` to assign to variables in the "
"module also works."
msgstr ""
"Llamando a :c:func:`PyObject_SetAttrString` para asignar a variables en el "
"módulo también funciona."

#: ../../faq/extending.rst:189
msgid "How do I interface to C++ objects from Python?"
msgstr "¿Cómo interactúo con objetos C++ desde Python?"

#: ../../faq/extending.rst:191
msgid ""
"Depending on your requirements, there are many approaches.  To do this "
"manually, begin by reading :ref:`the \"Extending and Embedding\" document "
"<extending-index>`.  Realize that for the Python run-time system, there "
"isn't a whole lot of difference between C and C++ -- so the strategy of "
"building a new Python type around a C structure (pointer) type will also "
"work for C++ objects."
msgstr ""
"Dependiendo de tus requisitos, hay muchos enfoques. Para hacer esto "
"manualmente, comienza leyendo el documento :ref:`the \"Extending and "
"Embedding\" document `. Date cuenta de que para el sistema de tiempo de "
"ejecución de Python, no hay mucha diferencia entre C y C++ -- por lo que la "
"estrategia de construir un nuevo tipo de Python alrededor de un tipo de "
"estructura C (puntero) también funcionará para objetos de C++."

#: ../../faq/extending.rst:197
msgid "For C++ libraries, see :ref:`c-wrapper-software`."
msgstr "Para bibliotecas de C++, ver :ref:`c-wrapper-software`."

#: ../../faq/extending.rst:201
msgid "I added a module using the Setup file and the make fails; why?"
msgstr ""
"He añadido un módulo utilizando el archivo Setup y make falla; ¿por qué?"

#: ../../faq/extending.rst:203
msgid ""
"Setup must end in a newline, if there is no newline there, the build process "
"fails.  (Fixing this requires some ugly shell script hackery, and this bug "
"is so minor that it doesn't seem worth the effort.)"
msgstr ""
"La configuración debe terminar en una nueva línea, si no hay una nueva "
"línea, el proceso de construcción falla. (Arreglar esto requiere un poco de "
"trucos feos de script de shell, y este error es tan menor que no parece "
"valer la pena el esfuerzo.)"

#: ../../faq/extending.rst:209
msgid "How do I debug an extension?"
msgstr "¿Cómo depuro una extensión?"

#: ../../faq/extending.rst:211
msgid ""
"When using GDB with dynamically loaded extensions, you can't set a "
"breakpoint in your extension until your extension is loaded."
msgstr ""
"Cuando se utiliza GDB con extensiones cargadas dinámicamente, no se puede "
"establecer un punto de interrupción en la extensión hasta que la extensión "
"esté cargada."

#: ../../faq/extending.rst:214
msgid "In your ``.gdbinit`` file (or interactively), add the command:"
msgstr "En su archivo ``.gdbinit`` (o interactivamente), añada el comando:"

#: ../../faq/extending.rst:216
msgid "br _PyImport_LoadDynamicModule"
msgstr ""

#: ../../faq/extending.rst:220
msgid "Then, when you run GDB:"
msgstr "Entonces, cuando ejecutes GDB:"

#: ../../faq/extending.rst:222
msgid ""
"$ gdb /local/bin/python\n"
"gdb) run myscript.py\n"
"gdb) continue # repeat until your extension is loaded\n"
"gdb) finish   # so that your extension is loaded\n"
"gdb) br myfunction.c:50\n"
"gdb) continue"
msgstr ""

#: ../../faq/extending.rst:232
msgid ""
"I want to compile a Python module on my Linux system, but some files are "
"missing. Why?"
msgstr ""
"Quiero compilar un módulo de Python en mi sistema Linux, pero faltan algunos "
"archivos. ¿Por qué?"

#: ../../faq/extending.rst:234
msgid ""
"Most packaged versions of Python omit some files required for compiling "
"Python extensions."
msgstr ""

#: ../../faq/extending.rst:237
msgid "For Red Hat, install the python3-devel RPM to get the necessary files."
msgstr ""

#: ../../faq/extending.rst:239
msgid "For Debian, run ``apt-get install python3-dev``."
msgstr ""

#: ../../faq/extending.rst:242
msgid "How do I tell \"incomplete input\" from \"invalid input\"?"
msgstr "¿Cómo diferencio \"entrada incompleta\" de \"entrada no válida\"?"

#: ../../faq/extending.rst:244
msgid ""
"Sometimes you want to emulate the Python interactive interpreter's behavior, "
"where it gives you a continuation prompt when the input is incomplete (e.g. "
"you typed the start of an \"if\" statement or you didn't close your "
"parentheses or triple string quotes), but it gives you a syntax error "
"message immediately when the input is invalid."
msgstr ""
"A veces quieres emular el comportamiento del intérprete interactivo de "
"Python, que te da un mensaje de continuación cuando la entrada está "
"incompleta (por ejemplo, has escrito el principio de una sentencia \"if\" o "
"no has cerrado los paréntesis o las comillas triples), pero te da un mensaje "
"de error sintáctico inmediatamente cuando la entrada no es válida."

#: ../../faq/extending.rst:250
msgid ""
"In Python you can use the :mod:`codeop` module, which approximates the "
"parser's behavior sufficiently.  IDLE uses this, for example."
msgstr ""
"En Python se puede utilizar el módulo :mod:`codeop`, que aproxima "
"suficientemente el comportamiento del analizador sintáctico.  IDLE lo "
"utiliza, por ejemplo."

#: ../../faq/extending.rst:253
msgid ""
"The easiest way to do it in C is to call :c:func:`PyRun_InteractiveLoop` "
"(perhaps in a separate thread) and let the Python interpreter handle the "
"input for you. You can also set the :c:func:`PyOS_ReadlineFunctionPointer` "
"to point at your custom input function. See ``Modules/readline.c`` and "
"``Parser/myreadline.c`` for more hints."
msgstr ""
"La forma más fácil de hacerlo en C es llamar a :c:func:"
"`PyRun_InteractiveLoop` (quizás en un hilo separado) y dejar que el "
"intérprete de Python maneje la entrada por ti. También puedes configurar :c:"
"func:`PyOS_ReadlineFunctionPointer` para que apunte a tu función de entrada "
"personalizada. Vea ``Modules/readline.c`` y ``Parser/myreadline.c`` para más "
"consejos."

#: ../../faq/extending.rst:260
msgid "How do I find undefined g++ symbols __builtin_new or __pure_virtual?"
msgstr ""
"¿Cómo encuentro los símbolos indefinidos de g++ __builtin_new o "
"__pure_virtual?"

#: ../../faq/extending.rst:262
msgid ""
"To dynamically load g++ extension modules, you must recompile Python, relink "
"it using g++ (change LINKCC in the Python Modules Makefile), and link your "
"extension module using g++ (e.g., ``g++ -shared -o mymodule.so mymodule.o``)."
msgstr ""
"Para cargar dinámicamente módulos de extensión de g++, debe recompilar "
"Python, volver a enlazarlo usando g++ (cambie LINKCC en el Makefile de "
"Módulos de Python), y enlazar su módulo de extensión usando g++ (por "
"ejemplo, ``g++ -shared -o mymodule.so mymodule.o``)."

#: ../../faq/extending.rst:268
msgid ""
"Can I create an object class with some methods implemented in C and others "
"in Python (e.g. through inheritance)?"
msgstr ""
"¿Puedo crear una clase de objeto con algunos métodos implementados en C y "
"otros en Python (por ejemplo, a través de la herencia)?"

#: ../../faq/extending.rst:270
msgid ""
"Yes, you can inherit from built-in classes such as :class:`int`, :class:"
"`list`, :class:`dict`, etc."
msgstr ""
"Sí, puede heredar de clases incorporadas como :class:`int`, :class:`list`, :"
"class:`dict`, etc."

#: ../../faq/extending.rst:273
msgid ""
"The Boost Python Library (BPL, https://www.boost.org/libs/python/doc/index."
"html) provides a way of doing this from C++ (i.e. you can inherit from an "
"extension class written in C++ using the BPL)."
msgstr ""
