# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 16:03+0000\n"
"PO-Revision-Date: 2025-07-18 19:57+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Spanish (Spain) (https://app.transifex.com/python-doc/"
"teams/5390/es_ES/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es_ES\n"
"Plural-Forms: nplurals=3; plural=n == 1 ? 0 : n != 0 && n % 1000000 == 0 ? "
"1 : 2;\n"

#: ../../library/asyncio-task.rst:6
msgid "Coroutines and Tasks"
msgstr "Corrutinas y tareas"

#: ../../library/asyncio-task.rst:8
msgid ""
"This section outlines high-level asyncio APIs to work with coroutines and "
"Tasks."
msgstr ""
"Esta sección describe las APIs asyncio de alto nivel para trabajar con "
"corrutinas y Tasks."

#: ../../library/asyncio-task.rst:19 ../../library/asyncio-task.rst:148
msgid "Coroutines"
msgstr "Corrutinas"

#: ../../library/asyncio-task.rst:21
msgid "**Source code:** :source:`Lib/asyncio/coroutines.py`"
msgstr "**Código fuente:** :source:`Lib/asyncio/coroutines.py`"

#: ../../library/asyncio-task.rst:25
msgid ""
":term:`Coroutines <coroutine>` declared with the async/await syntax is the "
"preferred way of writing asyncio applications.  For example, the following "
"snippet of code prints \"hello\", waits 1 second, and then prints \"world\"::"
msgstr ""
":term:`Coroutines <coroutine>` declaradas con la sintaxis async/await es la "
"forma preferida de escribir aplicaciones asyncio.  Por ejemplo, el siguiente "
"fragmento de código imprime \"hola\", espera 1 segundo y luego imprime "
"\"mundo\"::"

#: ../../library/asyncio-task.rst:30
msgid ""
">>> import asyncio\n"
"\n"
">>> async def main():\n"
"...     print('hello')\n"
"...     await asyncio.sleep(1)\n"
"...     print('world')\n"
"\n"
">>> asyncio.run(main())\n"
"hello\n"
"world"
msgstr ""
">>> import asyncio\n"
"\n"
">>> async def main():\n"
"...     print('hello')\n"
"...     await asyncio.sleep(1)\n"
"...     print('world')\n"
"\n"
">>> asyncio.run(main())\n"
"hello\n"
"world"

#: ../../library/asyncio-task.rst:41
msgid ""
"Note that simply calling a coroutine will not schedule it to be executed::"
msgstr ""
"Tener en cuenta que la simple llamada a una corrutina no programará su "
"ejecución::"

#: ../../library/asyncio-task.rst:44
msgid ""
">>> main()\n"
"<coroutine object main at 0x1053bb7c8>"
msgstr ""
">>> main()\n"
"<coroutine object main at 0x1053bb7c8>"

#: ../../library/asyncio-task.rst:47
msgid "To actually run a coroutine, asyncio provides the following mechanisms:"
msgstr ""
"Para ejecutar realmente una corrutina, asyncio proporciona los siguientes "
"mecanismos:"

#: ../../library/asyncio-task.rst:49
msgid ""
"The :func:`asyncio.run` function to run the top-level entry point \"main()\" "
"function (see the above example.)"
msgstr ""
"La función :func:`asyncio.run` para ejecutar la función \"main()\" del punto "
"de entrada de nivel superior (ver el ejemplo anterior)."

#: ../../library/asyncio-task.rst:52
msgid ""
"Awaiting on a coroutine.  The following snippet of code will print \"hello\" "
"after waiting for 1 second, and then print \"world\" after waiting for "
"*another* 2 seconds::"
msgstr ""
"Esperando en una corrutina.  El siguiente fragmento de código imprimirá "
"\"hola\" después de esperar 1 segundo, y luego imprimirá \"mundo\" después "
"de esperar *otros* 2 segundos::"

#: ../../library/asyncio-task.rst:56
msgid ""
"import asyncio\n"
"import time\n"
"\n"
"async def say_after(delay, what):\n"
"    await asyncio.sleep(delay)\n"
"    print(what)\n"
"\n"
"async def main():\n"
"    print(f\"started at {time.strftime('%X')}\")\n"
"\n"
"    await say_after(1, 'hello')\n"
"    await say_after(2, 'world')\n"
"\n"
"    print(f\"finished at {time.strftime('%X')}\")\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"import time\n"
"\n"
"async def say_after(delay, what):\n"
"    await asyncio.sleep(delay)\n"
"    print(what)\n"
"\n"
"async def main():\n"
"    print(f\"started at {time.strftime('%X')}\")\n"
"\n"
"    await say_after(1, 'hello')\n"
"    await say_after(2, 'world')\n"
"\n"
"    print(f\"finished at {time.strftime('%X')}\")\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-task.rst:73
msgid "Expected output::"
msgstr "Resultado esperado::"

#: ../../library/asyncio-task.rst:75
msgid ""
"started at 17:13:52\n"
"hello\n"
"world\n"
"finished at 17:13:55"
msgstr ""
"started at 17:13:52\n"
"hello\n"
"world\n"
"finished at 17:13:55"

#: ../../library/asyncio-task.rst:80
msgid ""
"The :func:`asyncio.create_task` function to run coroutines concurrently as "
"asyncio :class:`Tasks <Task>`."
msgstr ""
"La función :func:`asyncio.create_task` para ejecutar corrutinas de forma "
"concurrente como asyncio :class:`Tasks <Task>`."

#: ../../library/asyncio-task.rst:83
msgid ""
"Let's modify the above example and run two ``say_after`` coroutines "
"*concurrently*::"
msgstr ""
"Modifiquemos el ejemplo anterior y ejecutemos dos corrutinas ``say_after`` "
"*concurrently*::"

#: ../../library/asyncio-task.rst:86
msgid ""
"async def main():\n"
"    task1 = asyncio.create_task(\n"
"        say_after(1, 'hello'))\n"
"\n"
"    task2 = asyncio.create_task(\n"
"        say_after(2, 'world'))\n"
"\n"
"    print(f\"started at {time.strftime('%X')}\")\n"
"\n"
"    # Wait until both tasks are completed (should take\n"
"    # around 2 seconds.)\n"
"    await task1\n"
"    await task2\n"
"\n"
"    print(f\"finished at {time.strftime('%X')}\")"
msgstr ""
"async def main():\n"
"    task1 = asyncio.create_task(\n"
"        say_after(1, 'hello'))\n"
"\n"
"    task2 = asyncio.create_task(\n"
"        say_after(2, 'world'))\n"
"\n"
"    print(f\"started at {time.strftime('%X')}\")\n"
"\n"
"    # Espere hasta que se completen ambas tareas (debería tomar\n"
"    # unos 2 segundos.)\n"
"    await task1\n"
"    await task2\n"
"\n"
"    print(f\"finished at {time.strftime('%X')}\")"

#: ../../library/asyncio-task.rst:102
msgid ""
"Note that expected output now shows that the snippet runs 1 second faster "
"than before::"
msgstr ""
"Observar que la salida esperada muestra ahora que el fragmento se ejecuta 1 "
"segundo más rápido que antes::"

#: ../../library/asyncio-task.rst:105
msgid ""
"started at 17:14:32\n"
"hello\n"
"world\n"
"finished at 17:14:34"
msgstr ""
"iniciado a las 17:14:32\n"
"hola\n"
"mundo\n"
"terminado a las 17:14:34"

#: ../../library/asyncio-task.rst:110
msgid ""
"The :class:`asyncio.TaskGroup` class provides a more modern alternative to :"
"func:`create_task`. Using this API, the last example becomes::"
msgstr ""
"La clase :class:`asyncio.TaskGroup` proporciona una alternativa más moderna "
"a :func:`create_task`. Utilizando esta API, el último ejemplo se convierte "
"en::"

#: ../../library/asyncio-task.rst:114
msgid ""
"async def main():\n"
"    async with asyncio.TaskGroup() as tg:\n"
"        task1 = tg.create_task(\n"
"            say_after(1, 'hello'))\n"
"\n"
"        task2 = tg.create_task(\n"
"            say_after(2, 'world'))\n"
"\n"
"        print(f\"started at {time.strftime('%X')}\")\n"
"\n"
"    # The await is implicit when the context manager exits.\n"
"\n"
"    print(f\"finished at {time.strftime('%X')}\")"
msgstr ""
"async def main():\n"
"    async with asyncio.TaskGroup() as tg:\n"
"        task1 = tg.create_task(\n"
"            say_after(1, 'hello'))\n"
"\n"
"        task2 = tg.create_task(\n"
"            say_after(2, 'world'))\n"
"\n"
"        print(f\"started at {time.strftime('%X')}\")\n"
"\n"
"    # La espera está implícita cuando el administrador de contexto sale.\n"
"\n"
"    print(f\"finished at {time.strftime('%X')}\")"

#: ../../library/asyncio-task.rst:128
msgid "The timing and output should be the same as for the previous version."
msgstr ""
"El tiempo y la salida deben ser los mismos que para la versión anterior."

#: ../../library/asyncio-task.rst:130
msgid ":class:`asyncio.TaskGroup`."
msgstr ":class:`asyncio.TaskGroup`."

#: ../../library/asyncio-task.rst:137
msgid "Awaitables"
msgstr "Esperables"

#: ../../library/asyncio-task.rst:139
msgid ""
"We say that an object is an **awaitable** object if it can be used in an :"
"keyword:`await` expression.  Many asyncio APIs are designed to accept "
"awaitables."
msgstr ""
"Decimos que un objeto es un objeto **awaitable** si se puede utilizar en una "
"expresión :keyword:`await`.  Muchas APIs asyncio están diseñadas para "
"aceptar awaitables."

#: ../../library/asyncio-task.rst:143
msgid ""
"There are three main types of *awaitable* objects: **coroutines**, "
"**Tasks**, and **Futures**."
msgstr ""
"Hay tres tipos principales de objetos *awaitable*: **Coroutines**, **Tasks** "
"y **Futures**."

#: ../../library/asyncio-task.rst:149
msgid ""
"Python coroutines are *awaitables* and therefore can be awaited from other "
"coroutines::"
msgstr ""
"Las corrutinas de Python son *awaitables* y por tanto se pueden esperar "
"desde otras corrutinas::"

#: ../../library/asyncio-task.rst:152
msgid ""
"import asyncio\n"
"\n"
"async def nested():\n"
"    return 42\n"
"\n"
"async def main():\n"
"    # Nothing happens if we just call \"nested()\".\n"
"    # A coroutine object is created but not awaited,\n"
"    # so it *won't run at all*.\n"
"    nested()  # will raise a \"RuntimeWarning\".\n"
"\n"
"    # Let's do it differently now and await it:\n"
"    print(await nested())  # will print \"42\".\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"async def nested():\n"
"    return 42\n"
"\n"
"async def main():\n"
"    # No pasa nada si solo llamamos a \" nested()\".\n"
"    # Se crea un objeto corrutina pero no se espera,\n"
"    # entonces *no se ejecutará en absoluto*.\n"
"    nested() # generará un\"RuntimeWarning\".\n"
"\n"
"    # Hagámoslo de manera diferente ahora y esperemos:\n"
"    print(await nested()) # se imprimirá \"42\".\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-task.rst:170
msgid ""
"In this documentation the term \"coroutine\" can be used for two closely "
"related concepts:"
msgstr ""
"En esta documentación, el término \"coroutine\" se puede utilizar para dos "
"conceptos estrechamente relacionados:"

#: ../../library/asyncio-task.rst:173
msgid "a *coroutine function*: an :keyword:`async def` function;"
msgstr "una *coroutine function*: una función :keyword:`async def`;"

#: ../../library/asyncio-task.rst:175
msgid ""
"a *coroutine object*: an object returned by calling a *coroutine function*."
msgstr ""
"a *coroutine object*: objeto devuelto al llamar a una *coroutine function*."

#: ../../library/asyncio-task.rst:180
msgid "Tasks"
msgstr "Tareas"

#: ../../library/asyncio-task.rst:181
msgid "*Tasks* are used to schedule coroutines *concurrently*."
msgstr "Las *Tasks* se utilizan para programar corrutinas *concurrently*."

#: ../../library/asyncio-task.rst:183
msgid ""
"When a coroutine is wrapped into a *Task* with functions like :func:`asyncio."
"create_task` the coroutine is automatically scheduled to run soon::"
msgstr ""
"Cuando una corrutina se envuelve en una *Task* con funciones como :func:"
"`asyncio.create_task` la corrutina se programa automáticamente para "
"ejecutarse pronto::"

#: ../../library/asyncio-task.rst:187
msgid ""
"import asyncio\n"
"\n"
"async def nested():\n"
"    return 42\n"
"\n"
"async def main():\n"
"    # Schedule nested() to run soon concurrently\n"
"    # with \"main()\".\n"
"    task = asyncio.create_task(nested())\n"
"\n"
"    # \"task\" can now be used to cancel \"nested()\", or\n"
"    # can simply be awaited to wait until it is complete:\n"
"    await task\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"async def nested():\n"
"    return 42\n"
"\n"
"async def main():\n"
"    # Programar nested() para que se ejecute pronto concurrentemente\n"
"    # con \"main()\n"
"    task = asyncio.create_task(nested())\n"
"\n"
"    # \"task\" puede usarse ahora para cancelar \"nested()\", o\n"
"    # puede simplemente esperar hasta que se complete:\n"
"    await task\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-task.rst:205
msgid "Futures"
msgstr "Futuros"

#: ../../library/asyncio-task.rst:206
msgid ""
"A :class:`Future` is a special **low-level** awaitable object that "
"represents an **eventual result** of an asynchronous operation."
msgstr ""
"Un :class:`Future` es un objeto especial **low-level** aguardable que "
"representa un **eventual result** de una operación asíncrona."

#: ../../library/asyncio-task.rst:209
msgid ""
"When a Future object is *awaited* it means that the coroutine will wait "
"until the Future is resolved in some other place."
msgstr ""
"Cuando un objeto Future es *awaited* significa que la corrutina esperará "
"hasta que el Future se resuelva en algún otro lugar."

#: ../../library/asyncio-task.rst:212
msgid ""
"Future objects in asyncio are needed to allow callback-based code to be used "
"with async/await."
msgstr ""
"Los objetos futuros en asyncio son necesarios para permitir que el código "
"basado en callback se utilice con async/await."

#: ../../library/asyncio-task.rst:215
msgid ""
"Normally **there is no need** to create Future objects at the application "
"level code."
msgstr ""
"Normalmente **no es necesario** crear objetos Future en el código a nivel de "
"aplicación."

#: ../../library/asyncio-task.rst:218
msgid ""
"Future objects, sometimes exposed by libraries and some asyncio APIs, can be "
"awaited::"
msgstr ""
"Futuros objetos, a veces expuestos por bibliotecas y algunas APIs de "
"asyncio, pueden ser esperados::"

#: ../../library/asyncio-task.rst:221
msgid ""
"async def main():\n"
"    await function_that_returns_a_future_object()\n"
"\n"
"    # this is also valid:\n"
"    await asyncio.gather(\n"
"        function_that_returns_a_future_object(),\n"
"        some_python_coroutine()\n"
"    )"
msgstr ""
"async def main():\n"
"    await function_that_returns_a_future_object()\n"
"\n"
"    # esto también es válido\n"
"    await asyncio.gather(\n"
"        function_that_returns_a_future_object(),\n"
"       some_python_coroutine()\n"
"    )"

#: ../../library/asyncio-task.rst:230
msgid ""
"A good example of a low-level function that returns a Future object is :meth:"
"`loop.run_in_executor`."
msgstr ""
"Un buen ejemplo de función de bajo nivel que devuelve un objeto Future es :"
"meth:`loop.run_in_executor`."

#: ../../library/asyncio-task.rst:235
msgid "Creating Tasks"
msgstr "Creación de Tasks"

#: ../../library/asyncio-task.rst:237
msgid "**Source code:** :source:`Lib/asyncio/tasks.py`"
msgstr "**Código fuente:** :source:`Lib/asyncio/tasks.py`"

#: ../../library/asyncio-task.rst:243
msgid ""
"Wrap the *coro* :ref:`coroutine <coroutine>` into a :class:`Task` and "
"schedule its execution.  Return the Task object."
msgstr ""
"Envuelve la *coro* :ref:`coroutine <coroutine>` en un :class:`Task` y "
"programa su ejecución.  Devuelve el objeto Tarea."

#: ../../library/asyncio-task.rst:246
msgid ""
"If *name* is not ``None``, it is set as the name of the task using :meth:"
"`Task.set_name`."
msgstr ""
"Si *name* no es ``None``, se establece como el nombre de la tarea "
"utilizando :meth:`Task.set_name`."

#: ../../library/asyncio-task.rst:249
msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the *coro* to run in. The current context "
"copy is created when no *context* is provided."
msgstr ""
"Un argumento opcional *context* de sólo palabra clave permite especificar "
"un :class:`contextvars.Context` personalizado para que se ejecute el *coro*. "
"La copia del contexto actual se crea cuando no se proporciona *context*."

#: ../../library/asyncio-task.rst:253
msgid ""
"The task is executed in the loop returned by :func:`get_running_loop`, :exc:"
"`RuntimeError` is raised if there is no running loop in current thread."
msgstr ""
"La tarea se ejecuta en el bucle devuelto por :func:`get_running_loop`, :exc:"
"`RuntimeError` se levanta si no hay ningún bucle en ejecución en el hilo "
"actual."

#: ../../library/asyncio-task.rst:259
msgid ""
":meth:`asyncio.TaskGroup.create_task` is a new alternative leveraging "
"structural concurrency; it allows for waiting for a group of related tasks "
"with strong safety guarantees."
msgstr ""
":meth:`asyncio.TaskGroup.create_task` es una nueva alternativa que aprovecha "
"la concurrencia estructural; permite esperar a un grupo de tareas "
"relacionadas con fuertes garantías de seguridad."

#: ../../library/asyncio-task.rst:265
msgid ""
"Save a reference to the result of this function, to avoid a task "
"disappearing mid-execution. The event loop only keeps weak references to "
"tasks. A task that isn't referenced elsewhere may get garbage collected at "
"any time, even before it's done. For reliable \"fire-and-forget\" background "
"tasks, gather them in a collection::"
msgstr ""
"Guarda una referencia al resultado de esta función, para evitar que una "
"tarea desaparezca a mitad de ejecución. El bucle de eventos sólo guarda "
"referencias débiles a las tareas. Una tarea que no esté referenciada en "
"ningún otro lugar puede ser recolectada en cualquier momento, incluso antes "
"de que haya terminado. Para que las tareas en segundo plano sean fiables, "
"reúnelas en una colección::"

#: ../../library/asyncio-task.rst:272
msgid ""
"background_tasks = set()\n"
"\n"
"for i in range(10):\n"
"    task = asyncio.create_task(some_coro(param=i))\n"
"\n"
"    # Add task to the set. This creates a strong reference.\n"
"    background_tasks.add(task)\n"
"\n"
"    # To prevent keeping references to finished tasks forever,\n"
"    # make each task remove its own reference from the set after\n"
"    # completion:\n"
"    task.add_done_callback(background_tasks.discard)"
msgstr ""
"background_tasks = set()\n"
"\n"
"for i in range(10):\n"
"    task = asyncio.create_task(some_coro(param=i))\n"
"\n"
"    # Añade la tarea al conjunto. Esto crea una referencia fuerte.\n"
"    background_tasks.add(tarea)\n"
"\n"
"    # Para evitar mantener referencias a tareas terminadas para siempre,\n"
"    # haz que cada tarea elimine su propia referencia del conjunto tras\n"
"    # la finalización:\n"
"    task.add_done_callback(background_tasks.discard)"

#: ../../library/asyncio-task.rst:287 ../../library/asyncio-task.rst:1126
msgid "Added the *name* parameter."
msgstr "Añadido el parámetro *name*."

#: ../../library/asyncio-task.rst:290 ../../library/asyncio-task.rst:1133
msgid "Added the *context* parameter."
msgstr "Añadido el parámetro *context*."

#: ../../library/asyncio-task.rst:295
msgid "Task Cancellation"
msgstr "Cancelación de Task"

#: ../../library/asyncio-task.rst:297
msgid ""
"Tasks can easily and safely be cancelled. When a task is cancelled, :exc:"
"`asyncio.CancelledError` will be raised in the task at the next opportunity."
msgstr ""
"Las tareas pueden cancelarse de forma fácil y segura. Cuando se cancela una "
"tarea, :exc:`asyncio.CancelledError` se planteará en la tarea en la próxima "
"oportunidad."

#: ../../library/asyncio-task.rst:301
msgid ""
"It is recommended that coroutines use ``try/finally`` blocks to robustly "
"perform clean-up logic. In case :exc:`asyncio.CancelledError` is explicitly "
"caught, it should generally be propagated when clean-up is complete. :exc:"
"`asyncio.CancelledError` directly subclasses :exc:`BaseException` so most "
"code will not need to be aware of it."
msgstr ""
"Se recomienda que las corrutinas utilicen bloques ``try/finally`` para "
"realizar de forma robusta la lógica de limpieza. En caso de que :exc:"
"`asyncio.CancelledError` sea capturado explícitamente, por lo general "
"debería propagarse cuando se complete la limpieza. :exc:`asyncio."
"CancelledError` subclasea directamente a :exc:`BaseException`, por lo que la "
"mayor parte del código no necesitará tenerlo en cuenta."

#: ../../library/asyncio-task.rst:307
msgid ""
"The asyncio components that enable structured concurrency, like :class:"
"`asyncio.TaskGroup` and :func:`asyncio.timeout`, are implemented using "
"cancellation internally and might misbehave if a coroutine swallows :exc:"
"`asyncio.CancelledError`. Similarly, user code should not generally call :"
"meth:`uncancel <asyncio.Task.uncancel>`. However, in cases when suppressing :"
"exc:`asyncio.CancelledError` is truly desired, it is necessary to also call "
"``uncancel()`` to completely remove the cancellation state."
msgstr ""
"Los componentes de asyncio que permiten la concurrencia estructurada, como :"
"class:`asyncio.TaskGroup` y :func:`asyncio.timeout`, se implementan usando "
"la cancelación internamente y podrían comportarse mal si una corrutina se "
"traga :exc:`asyncio.CancelledError`. Del mismo modo, el código de usuario no "
"debería llamar generalmente a :meth:`uncancel <asyncio.Task.uncancel>`. Sin "
"embargo, en los casos en los que realmente se desee suprimir :exc:`asyncio."
"CancelledError`, es necesario llamar también a ``uncancel()`` para eliminar "
"completamente el estado de cancelación."

#: ../../library/asyncio-task.rst:319
msgid "Task Groups"
msgstr "Grupos de trabajo"

#: ../../library/asyncio-task.rst:321
msgid ""
"Task groups combine a task creation API with a convenient and reliable way "
"to wait for all tasks in the group to finish."
msgstr ""
"Los grupos de tareas combinan una API de creación de tareas con una forma "
"cómoda y fiable de esperar a que finalicen todas las tareas del grupo."

#: ../../library/asyncio-task.rst:326
msgid ""
"An :ref:`asynchronous context manager <async-context-managers>` holding a "
"group of tasks. Tasks can be added to the group using :meth:`create_task`. "
"All tasks are awaited when the context manager exits."
msgstr ""
"Un :ref:`asynchronous context manage <async-context-managers>` que contiene "
"un grupo de tareas. Se pueden añadir tareas al grupo utilizando :meth:"
"`create_task`. Todas las tareas son esperadas cuando el gestor de contexto "
"sale."

#: ../../library/asyncio-task.rst:335
msgid ""
"Create a task in this task group. The signature matches that of :func:"
"`asyncio.create_task`."
msgstr ""
"Cree una tarea en este grupo de tareas. La firma coincide con la de :func:"
"`asyncio.create_task`."

#: ../../library/asyncio-task.rst:338 ../../library/asyncio-task.rst:520
#: ../../library/asyncio-task.rst:693 ../../library/asyncio-task.rst:751
#: ../../library/asyncio-task.rst:777 ../../library/asyncio-task.rst:818
#: ../../library/asyncio-task.rst:918
msgid "Example::"
msgstr "Ejemplo::"

#: ../../library/asyncio-task.rst:340
msgid ""
"async def main():\n"
"    async with asyncio.TaskGroup() as tg:\n"
"        task1 = tg.create_task(some_coro(...))\n"
"        task2 = tg.create_task(another_coro(...))\n"
"    print(f\"Both tasks have completed now: {task1.result()}, {task2."
"result()}\")"
msgstr ""
"async def main():\n"
"    async with asyncio.TaskGroup() as tg:\n"
"        task1 = tg.create_task(some_coro(...))\n"
"        task2 = tg.create_task(another_coro(...))\n"
"    print(f\"Ambas tareas se han completado ahora: {task1.result()}, {task2."
"result()}\")"

#: ../../library/asyncio-task.rst:346
msgid ""
"The ``async with`` statement will wait for all tasks in the group to finish. "
"While waiting, new tasks may still be added to the group (for example, by "
"passing ``tg`` into one of the coroutines and calling ``tg.create_task()`` "
"in that coroutine). Once the last task has finished and the ``async with`` "
"block is exited, no new tasks may be added to the group."
msgstr ""
"La sentencia ``async with`` esperará a que finalicen todas las tareas del "
"grupo. Mientras se espera, se pueden añadir nuevas tareas al grupo (por "
"ejemplo, pasando ``tg`` a una de las corrutinas y llamando a ``tg."
"create_task()`` en esa corrutina). Una vez que la última tarea haya "
"finalizado y se salga del bloque ``async with``, no se podrán añadir nuevas "
"tareas al grupo."

#: ../../library/asyncio-task.rst:353
msgid ""
"The first time any of the tasks belonging to the group fails with an "
"exception other than :exc:`asyncio.CancelledError`, the remaining tasks in "
"the group are cancelled. No further tasks can then be added to the group. At "
"this point, if the body of the ``async with`` statement is still active (i."
"e., :meth:`~object.__aexit__` hasn't been called yet), the task directly "
"containing the ``async with`` statement is also cancelled. The resulting :"
"exc:`asyncio.CancelledError` will interrupt an ``await``, but it will not "
"bubble out of the containing ``async with`` statement."
msgstr ""
"La primera vez que alguna de las tareas pertenecientes al grupo falla con "
"una excepción distinta de :exc:`asyncio.CancelledError`, se cancelan las "
"tareas restantes del grupo. No se pueden añadir más tareas al grupo. En ese "
"momento, si el cuerpo de la sentencia ``async with`` sigue activo (es decir, "
"aún no se ha llamado a :meth:`~object.__aexit__` ), la tarea que contiene "
"directamente la sentencia ``async with`` también se cancela. La sentencia :"
"exc:`asyncio.CancelledError` resultante interrumpirá una sentencia "
"``await``, pero no saldrá de la sentencia ``async with`` que la contiene."

#: ../../library/asyncio-task.rst:363
msgid ""
"Once all tasks have finished, if any tasks have failed with an exception "
"other than :exc:`asyncio.CancelledError`, those exceptions are combined in "
"an :exc:`ExceptionGroup` or :exc:`BaseExceptionGroup` (as appropriate; see "
"their documentation) which is then raised."
msgstr ""
"Una vez que todas las tareas han finalizado, si alguna de ellas ha fallado "
"con una excepción distinta de :exc:`asyncio.CancelledError`, esas "
"excepciones se combinan en un :exc:`ExceptionGroup` o :exc:"
"`BaseExceptionGroup` (según corresponda; consulte su documentación) que se "
"lanza a continuación."

#: ../../library/asyncio-task.rst:370
msgid ""
"Two base exceptions are treated specially: If any task fails with :exc:"
"`KeyboardInterrupt` or :exc:`SystemExit`, the task group still cancels the "
"remaining tasks and waits for them, but then the initial :exc:"
"`KeyboardInterrupt` or :exc:`SystemExit` is re-raised instead of :exc:"
"`ExceptionGroup` or :exc:`BaseExceptionGroup`."
msgstr ""
"Hay dos excepciones básicas que se tratan de forma especial: Si alguna tarea "
"falla con :exc:`KeyboardInterrupt` o :exc:`SystemExit`, el grupo de tareas "
"sigue cancelando las tareas restantes y las espera, pero entonces se vuelve "
"a plantear la tarea inicial :exc:`KeyboardInterrupt` o :exc:`SystemExit` en "
"lugar de :exc:`ExceptionGroup` o :exc:`BaseExceptionGroup`."

#: ../../library/asyncio-task.rst:376
msgid ""
"If the body of the ``async with`` statement exits with an exception (so :"
"meth:`~object.__aexit__` is called with an exception set), this is treated "
"the same as if one of the tasks failed: the remaining tasks are cancelled "
"and then waited for, and non-cancellation exceptions are grouped into an "
"exception group and raised. The exception passed into :meth:`~object."
"__aexit__`, unless it is :exc:`asyncio.CancelledError`, is also included in "
"the exception group. The same special case is made for :exc:"
"`KeyboardInterrupt` and :exc:`SystemExit` as in the previous paragraph."
msgstr ""
"Si el cuerpo de la sentencia ``async with`` sale con una excepción (por lo "
"que :meth:`~object.__aexit__` se llama con una excepción establecida), esto "
"se trata igual que si una de las tareas fallara: las tareas restantes se "
"cancelan y luego se espera, y las excepciones no canceladas se agrupan en un "
"grupo de excepciones y se lanzan. La excepción pasada a :meth:`~object."
"__aexit__`, a menos que sea :exc:`asyncio.CancelledError`, también se "
"incluye en el grupo de excepciones. Para :exc:`KeyboardInterrupt` y :exc:"
"`SystemExit` se da el mismo caso especial que en el párrafo anterior."

#: ../../library/asyncio-task.rst:390
msgid "Terminating a Task Group"
msgstr "Terminación de un grupo de tareas"

#: ../../library/asyncio-task.rst:392
msgid ""
"While terminating a task group is not natively supported by the standard "
"library, termination can be achieved by adding an exception-raising task to "
"the task group and ignoring the raised exception:"
msgstr ""
"Aunque la terminación de un grupo de tareas no está soportada de forma "
"nativa por la biblioteca estándar, la terminación se puede conseguir "
"añadiendo una tarea que genere una excepción al grupo de tareas e ignorando "
"la excepción generada:"

#: ../../library/asyncio-task.rst:396
msgid ""
"import asyncio\n"
"from asyncio import TaskGroup\n"
"\n"
"class TerminateTaskGroup(Exception):\n"
"    \"\"\"Exception raised to terminate a task group.\"\"\"\n"
"\n"
"async def force_terminate_task_group():\n"
"    \"\"\"Used to force termination of a task group.\"\"\"\n"
"    raise TerminateTaskGroup()\n"
"\n"
"async def job(task_id, sleep_time):\n"
"    print(f'Task {task_id}: start')\n"
"    await asyncio.sleep(sleep_time)\n"
"    print(f'Task {task_id}: done')\n"
"\n"
"async def main():\n"
"    try:\n"
"        async with TaskGroup() as group:\n"
"            # spawn some tasks\n"
"            group.create_task(job(1, 0.5))\n"
"            group.create_task(job(2, 1.5))\n"
"            # sleep for 1 second\n"
"            await asyncio.sleep(1)\n"
"            # add an exception-raising task to force the group to terminate\n"
"            group.create_task(force_terminate_task_group())\n"
"    except* TerminateTaskGroup:\n"
"        pass\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"from asyncio import TaskGroup\n"
"\n"
"class TerminateTaskGroup(Exception):\n"
"    \"\"\"Excepción planteada para terminar un grupo de tarea.\"\"\"\n"
"\n"
"async def force_terminate_task_group():\n"
"    \"\"\"Se utiliza para forzar la terminación de un grupo de tareas."
"\"\"\"\n"
"    raise TerminateTaskGroup()\n"
"\n"
"async def job(task_id, sleep_time):\n"
"    print(f'Task {task_id}: start')\n"
"    await asyncio.sleep(sleep_time)\n"
"    print(f'Task {task_id}: done')\n"
"\n"
"async def main():\n"
"    try:\n"
"        async with TaskGroup() as group:\n"
"            # crea algunas tareas\n"
"            group.create_task(job(1, 0.5))\n"
"            group.create_task(job(2, 1.5))\n"
"            # dormir 1 segundo\n"
"            await asyncio.sleep(1)\n"
"            # añade una tarea que lance una excepción para forzar al grupo a "
"terminar\n"
"            group.create_task(force_terminate_task_group())\n"
"    except* TerminateTaskGroup:\n"
"        pass\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-task.rst:428
msgid "Expected output:"
msgstr "Resultado esperado:"

#: ../../library/asyncio-task.rst:430
msgid ""
"Task 1: start\n"
"Task 2: start\n"
"Task 1: done"
msgstr ""
"Task 1: start\n"
"Task 2: start\n"
"Task 1: done"

#: ../../library/asyncio-task.rst:437
msgid "Sleeping"
msgstr "Durmiendo"

#: ../../library/asyncio-task.rst:442
msgid "Block for *delay* seconds."
msgstr "Bloqueo durante segundos *delay\"."

#: ../../library/asyncio-task.rst:444
msgid ""
"If *result* is provided, it is returned to the caller when the coroutine "
"completes."
msgstr ""
"Si se proporciona *result*, se devuelve a caller cuando finaliza la "
"corrutina."

#: ../../library/asyncio-task.rst:447
msgid ""
"``sleep()`` always suspends the current task, allowing other tasks to run."
msgstr ""
"``sleep()`` siempre suspende la tarea actual, permitiendo que se ejecuten "
"otras tareas."

#: ../../library/asyncio-task.rst:450
msgid ""
"Setting the delay to 0 provides an optimized path to allow other tasks to "
"run. This can be used by long-running functions to avoid blocking the event "
"loop for the full duration of the function call."
msgstr ""
"Establecer el retardo a 0 proporciona una ruta optimizada para permitir que "
"otras tareas se ejecuten. Esto puede utilizarse por funciones de larga "
"ejecución para evitar el bloqueo del bucle de eventos durante toda la "
"duración de la llamada a la función."

#: ../../library/asyncio-task.rst:456
msgid ""
"Example of coroutine displaying the current date every second for 5 seconds::"
msgstr ""
"Ejemplo de corrutina mostrando la fecha actual cada segundo durante 5 "
"segundos::"

#: ../../library/asyncio-task.rst:459
msgid ""
"import asyncio\n"
"import datetime\n"
"\n"
"async def display_date():\n"
"    loop = asyncio.get_running_loop()\n"
"    end_time = loop.time() + 5.0\n"
"    while True:\n"
"        print(datetime.datetime.now())\n"
"        if (loop.time() + 1.0) >= end_time:\n"
"            break\n"
"        await asyncio.sleep(1)\n"
"\n"
"asyncio.run(display_date())"
msgstr ""
"import asyncio\n"
"import datetime\n"
"\n"
"async def display_date():\n"
"    loop = asyncio.get_running_loop()\n"
"    end_time = loop.time() + 5.0\n"
"    while True:\n"
"        print(datetime.datetime.now())\n"
"        if (loop.time() + 1.0) >= end_time:\n"
"            break\n"
"        await asyncio.sleep(1)\n"
"\n"
"asyncio.run(display_date())"

#: ../../library/asyncio-task.rst:474 ../../library/asyncio-task.rst:569
#: ../../library/asyncio-task.rst:668 ../../library/asyncio-task.rst:843
#: ../../library/asyncio-task.rst:898 ../../library/asyncio-task.rst:924
msgid "Removed the *loop* parameter."
msgstr "Eliminado el parámetro *loop*."

#: ../../library/asyncio-task.rst:479
msgid "Running Tasks Concurrently"
msgstr "Ejecución simultánea de tareas"

#: ../../library/asyncio-task.rst:483
msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* sequence "
"*concurrently*."
msgstr ""
"Ejecuta :ref:`awaitable objects <asyncio-awaitables>` en la *aws* secuencia "
"*concurrently*."

#: ../../library/asyncio-task.rst:486
msgid ""
"If any awaitable in *aws* is a coroutine, it is automatically scheduled as a "
"Task."
msgstr ""
"Si cualquier awaitable en *aws* es una corrutina, se programa "
"automáticamente como una Tarea."

#: ../../library/asyncio-task.rst:489
msgid ""
"If all awaitables are completed successfully, the result is an aggregate "
"list of returned values.  The order of result values corresponds to the "
"order of awaitables in *aws*."
msgstr ""
"Si todos los awaitables se completan con éxito, el resultado es una lista "
"agregada de valores devueltos.  El orden de los valores resultantes "
"corresponde al orden de los aguardables en *aws*."

#: ../../library/asyncio-task.rst:493
msgid ""
"If *return_exceptions* is ``False`` (default), the first raised exception is "
"immediately propagated to the task that awaits on ``gather()``.  Other "
"awaitables in the *aws* sequence **won't be cancelled** and will continue to "
"run."
msgstr ""
"Si *return_exceptions* es ``False`` (por defecto), la primera excepción "
"levantada se propaga inmediatamente a la tarea que espera en ``gather()``.  "
"Otros awaitables en la secuencia *aws* **won't be cancelled** y continuarán "
"ejecutándose."

#: ../../library/asyncio-task.rst:498
msgid ""
"If *return_exceptions* is ``True``, exceptions are treated the same as "
"successful results, and aggregated in the result list."
msgstr ""
"Si *return_exceptions* es ``True``, las excepciones se tratan igual que los "
"resultados correctos y se agregan a la lista de resultados."

#: ../../library/asyncio-task.rst:501
msgid ""
"If ``gather()`` is *cancelled*, all submitted awaitables (that have not "
"completed yet) are also *cancelled*."
msgstr ""
"Si ``gather()`` es *cancelled*, todos los awaitables enviados (que aún no se "
"han completado) también son *cancelled*."

#: ../../library/asyncio-task.rst:504
msgid ""
"If any Task or Future from the *aws* sequence is *cancelled*, it is treated "
"as if it raised :exc:`CancelledError` -- the ``gather()`` call is **not** "
"cancelled in this case.  This is to prevent the cancellation of one "
"submitted Task/Future to cause other Tasks/Futures to be cancelled."
msgstr ""
"Si cualquier Tarea o Futuro de la secuencia *aws* es *cancelled*, se trata "
"como si hubiera planteado :exc:`CancelledError` -- la llamada a ``gather()`` "
"**no** se cancela en este caso.  Esto es para prevenir que la cancelación de "
"una Tarea/Futuro enviada para que se cancelen otras Tareas/Futuros.."

#: ../../library/asyncio-task.rst:511
msgid ""
"A new alternative to create and run tasks concurrently and wait for their "
"completion is :class:`asyncio.TaskGroup`. *TaskGroup* provides stronger "
"safety guarantees than *gather* for scheduling a nesting of subtasks: if a "
"task (or a subtask, a task scheduled by a task) raises an exception, "
"*TaskGroup* will, while *gather* will not, cancel the remaining scheduled "
"tasks)."
msgstr ""
"Una nueva alternativa para crear y ejecutar tareas concurrentemente y "
"esperar a su finalización es :class:`asyncio.TaskGroup`. *TaskGroup* "
"proporciona mayores garantías de seguridad que *gather* para programar un "
"anidamiento de subtareas: si una tarea (o una subtarea, una tarea programada "
"por una tarea) lanza una excepción, *TaskGroup* lo hará, mientras que "
"*gather* no, cancelando el resto de tareas programadas)."

#: ../../library/asyncio-task.rst:522
msgid ""
"import asyncio\n"
"\n"
"async def factorial(name, number):\n"
"    f = 1\n"
"    for i in range(2, number + 1):\n"
"        print(f\"Task {name}: Compute factorial({number}), currently i={i}..."
"\")\n"
"        await asyncio.sleep(1)\n"
"        f *= i\n"
"    print(f\"Task {name}: factorial({number}) = {f}\")\n"
"    return f\n"
"\n"
"async def main():\n"
"    # Schedule three calls *concurrently*:\n"
"    L = await asyncio.gather(\n"
"        factorial(\"A\", 2),\n"
"        factorial(\"B\", 3),\n"
"        factorial(\"C\", 4),\n"
"    )\n"
"    print(L)\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Expected output:\n"
"#\n"
"#     Task A: Compute factorial(2), currently i=2...\n"
"#     Task B: Compute factorial(3), currently i=2...\n"
"#     Task C: Compute factorial(4), currently i=2...\n"
"#     Task A: factorial(2) = 2\n"
"#     Task B: Compute factorial(3), currently i=3...\n"
"#     Task C: Compute factorial(4), currently i=3...\n"
"#     Task B: factorial(3) = 6\n"
"#     Task C: Compute factorial(4), currently i=4...\n"
"#     Task C: factorial(4) = 24\n"
"#     [2, 6, 24]"
msgstr ""
"import asyncio\n"
"\n"
"async def factorial(name, number):\n"
"    f = 1\n"
"    for i in range(2, number + 1):\n"
"        print(f\"Task {name}: Compute factorial({number}), currently i={i}..."
"\")\n"
"        await asyncio.sleep(1)\n"
"        f *= i\n"
"    print(f\"Task {name}: factorial({number}) = {f}\")\n"
"    return f\n"
"\n"
"async def main():\n"
"    # Schedule three calls *concurrently*:\n"
"    L = await asyncio.gather(\n"
"        factorial(\"A\", 2),\n"
"        factorial(\"B\", 3),\n"
"        factorial(\"C\", 4),\n"
"    )\n"
"    print(L)\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Salida esperada:\n"
"#\n"
"# Tarea A: Calcular factorial(2), actualmente i=2...\n"
"# Tarea B: Calcular factorial(3), actualmente i=2...\n"
"# Tarea C: Calcula factorial(4), actualmente i=2...\n"
"# Tarea A: factorial(2) = 2\n"
"# Tarea B: Calcular factorial(3), actualmente i=3...\n"
"# Tarea C: Calcula factorial(4), actualmente i=3...\n"
"# Tarea B: factorial(3) = 6\n"
"# Tarea C: Calcula factorial(4), actualmente i=4...\n"
"# Tarea C: factorial(4) = 24\n"
"#     [2, 6, 24]"

#: ../../library/asyncio-task.rst:558
msgid ""
"If *return_exceptions* is false, cancelling gather() after it has been "
"marked done won't cancel any submitted awaitables. For instance, gather can "
"be marked done after propagating an exception to the caller, therefore, "
"calling ``gather.cancel()`` after catching an exception (raised by one of "
"the awaitables) from gather won't cancel any other awaitables."
msgstr ""
"Si *return_exceptions* es falso, cancelar gather() después de que se haya "
"marcado como hecho no cancelará ningún awaitable enviado. Por ejemplo, "
"gather puede ser marcada como realizada después de propagar una excepción al "
"llamador, por lo tanto, llamar a ``gather.cancel()`` después de capturar una "
"excepción (lanzada por uno de los awaitables) desde gather no cancelará "
"ningún otro awaitable."

#: ../../library/asyncio-task.rst:565
msgid ""
"If the *gather* itself is cancelled, the cancellation is propagated "
"regardless of *return_exceptions*."
msgstr ""
"Si se cancela la *gather* en sí, la cancelación se propaga "
"independientemente de *return_exceptions*."

#: ../../library/asyncio-task.rst:572
msgid ""
"Deprecation warning is emitted if no positional arguments are provided or "
"not all positional arguments are Future-like objects and there is no running "
"event loop."
msgstr ""
"Se emite una advertencia de desaprobación si no se proporcionan argumentos "
"posicionales o si no todos los argumentos posicionales son objetos tipo "
"Future y no hay un bucle de eventos en ejecución."

#: ../../library/asyncio-task.rst:581
msgid "Eager Task Factory"
msgstr "Fábrica de tareas"

#: ../../library/asyncio-task.rst:585
msgid "A task factory for eager task execution."
msgstr "Una fábrica de tareas para la impaciente  ejecución de tareas."

#: ../../library/asyncio-task.rst:587
msgid ""
"When using this factory (via :meth:`loop.set_task_factory(asyncio."
"eager_task_factory) <loop.set_task_factory>`), coroutines begin execution "
"synchronously during :class:`Task` construction. Tasks are only scheduled on "
"the event loop if they block. This can be a performance improvement as the "
"overhead of loop scheduling is avoided for coroutines that complete "
"synchronously."
msgstr ""
"Cuando se utiliza esta fábrica (mediante :meth:`loop."
"set_task_factory(asyncio.eager_task_factory) <loop.set_task_factory>`), las "
"corrutinas comienzan su ejecución de forma sincrónica durante la "
"construcción de :class:`Task`. Las tareas sólo se programan en el bucle de "
"eventos si se bloquean. Esto puede suponer una mejora del rendimiento, ya "
"que se evita la sobrecarga de la programación del bucle para las corrutinas "
"que se completan de forma sincrónica."

#: ../../library/asyncio-task.rst:593
msgid ""
"A common example where this is beneficial is coroutines which employ caching "
"or memoization to avoid actual I/O when possible."
msgstr ""
"Un ejemplo común donde esto es beneficioso son las corrutinas que emplean "
"caché o memorización para evitar la E/S real cuando sea posible."

#: ../../library/asyncio-task.rst:598
msgid ""
"Immediate execution of the coroutine is a semantic change. If the coroutine "
"returns or raises, the task is never scheduled to the event loop. If the "
"coroutine execution blocks, the task is scheduled to the event loop. This "
"change may introduce behavior changes to existing applications. For example, "
"the application's task execution order is likely to change."
msgstr ""
"La ejecución inmediata de la corrutina es un cambio semántico. Si la "
"corrutina devuelve o levanta, la tarea nunca se programa para el bucle de "
"eventos. Si la ejecución de la corrutina se bloquea, la tarea se programa en "
"el bucle de eventos. Este cambio puede introducir cambios de comportamiento "
"en las aplicaciones existentes. Por ejemplo, es probable que cambie el orden "
"de ejecución de las tareas de la aplicación."

#: ../../library/asyncio-task.rst:609
msgid ""
"Create an eager task factory, similar to :func:`eager_task_factory`, using "
"the provided *custom_task_constructor* when creating a new task instead of "
"the default :class:`Task`."
msgstr ""
"Crear una fábrica de tareas impacientes, similar a :func:"
"`eager_task_factory`, utilizando el *custom_task_constructor* proporcionado "
"al crear una nueva tarea en lugar del predeterminado :class:`Task`."

#: ../../library/asyncio-task.rst:613
msgid ""
"*custom_task_constructor* must be a *callable* with the signature matching "
"the signature of :class:`Task.__init__ <Task>`. The callable must return a :"
"class:`asyncio.Task`-compatible object."
msgstr ""
"El *custom_task_constructor* debe ser un *callable* cuya firma coincida con "
"la firma de :class:`Task.__init__ <Task>`. La llamada debe devolver un "
"objeto compatible con :class:`asyncio.Task`."

#: ../../library/asyncio-task.rst:617
msgid ""
"This function returns a *callable* intended to be used as a task factory of "
"an event loop via :meth:`loop.set_task_factory(factory) <loop."
"set_task_factory>`)."
msgstr ""
"Esta función devuelve un *callable* destinado a utilizarse como fábrica de "
"tareas de un bucle de eventos mediante :meth:`loop.set_task_factory(factory) "
"<loop.set_task_factory>`)."

#: ../../library/asyncio-task.rst:624
msgid "Shielding From Cancellation"
msgstr "Blindaje contra la anulación"

#: ../../library/asyncio-task.rst:628
msgid ""
"Protect an :ref:`awaitable object <asyncio-awaitables>` from being :meth:"
"`cancelled <Task.cancel>`."
msgstr ""
"Protege un :ref:`awaitable object <asyncio-awaitables>` de ser :meth:"
"`cancelled <Task.cancel>`."

#: ../../library/asyncio-task.rst:631 ../../library/asyncio-task.rst:798
msgid "If *aw* is a coroutine it is automatically scheduled as a Task."
msgstr "Si *aw* es una corrutina se programa automáticamente como una Tarea."

#: ../../library/asyncio-task.rst:633
msgid "The statement::"
msgstr "La declaración::"

#: ../../library/asyncio-task.rst:635
msgid ""
"task = asyncio.create_task(something())\n"
"res = await shield(task)"
msgstr ""
"task = asyncio.create_task(something())\n"
"res = await shield(task)"

#: ../../library/asyncio-task.rst:638
msgid "is equivalent to::"
msgstr "es equivalente a::"

#: ../../library/asyncio-task.rst:640
msgid "res = await something()"
msgstr "res = await something()"

#: ../../library/asyncio-task.rst:642
msgid ""
"*except* that if the coroutine containing it is cancelled, the Task running "
"in ``something()`` is not cancelled.  From the point of view of "
"``something()``, the cancellation did not happen. Although its caller is "
"still cancelled, so the \"await\" expression still raises a :exc:"
"`CancelledError`."
msgstr ""
"*except* que si la corrutina que la contiene se cancela, la Tarea que se "
"ejecuta en ``something()`` no se cancela.  Desde el punto de vista de "
"``something()``, la cancelación no se ha producido. Aunque su invocador "
"sigue siendo cancelado, por lo que la expresión \"await\" sigue planteando "
"un :exc:`CancelledError`."

#: ../../library/asyncio-task.rst:648
msgid ""
"If ``something()`` is cancelled by other means (i.e. from within itself) "
"that would also cancel ``shield()``."
msgstr ""
"Si ``something()`` se anula por otros medios (es decir, desde dentro de sí "
"mismo) eso también anularía ``shield()``."

#: ../../library/asyncio-task.rst:651
msgid ""
"If it is desired to completely ignore cancellation (not recommended) the "
"``shield()`` function should be combined with a try/except clause, as "
"follows::"
msgstr ""
"Si se desea ignorar completamente la cancelación (no se recomienda), la "
"función ``shield()`` debe combinarse con una cláusula try/except, de la "
"siguiente manera::"

#: ../../library/asyncio-task.rst:655
msgid ""
"task = asyncio.create_task(something())\n"
"try:\n"
"    res = await shield(task)\n"
"except CancelledError:\n"
"    res = None"
msgstr ""
"task = asyncio.create_task(algo())\n"
"try:\n"
"    res = await shield(task)\n"
"except CancelledError:\n"
"    res = None"

#: ../../library/asyncio-task.rst:663
msgid ""
"Save a reference to tasks passed to this function, to avoid a task "
"disappearing mid-execution. The event loop only keeps weak references to "
"tasks. A task that isn't referenced elsewhere may get garbage collected at "
"any time, even before it's done."
msgstr ""
"Guarda una referencia a las tareas pasadas a esta función, para evitar que "
"una tarea desaparezca a mitad de ejecución. El bucle de eventos sólo guarda "
"referencias débiles a las tareas. Una tarea a la que no se hace referencia "
"en ningún otro lugar puede ser recolectada en cualquier momento, incluso "
"antes de que termine."

#: ../../library/asyncio-task.rst:671
msgid ""
"Deprecation warning is emitted if *aw* is not Future-like object and there "
"is no running event loop."
msgstr ""
"Se emite una advertencia de desaprobación si *aw* no es un objeto tipo "
"Future y no hay un bucle de eventos en ejecución."

#: ../../library/asyncio-task.rst:677
msgid "Timeouts"
msgstr "Tiempos muertos"

#: ../../library/asyncio-task.rst:681
msgid ""
"Return an :ref:`asynchronous context manager <async-context-managers>` that "
"can be used to limit the amount of time spent waiting on something."
msgstr ""
"Devuelve un :ref:`asynchronous context manager <async-context-managers>` que "
"puede utilizarse para limitar el tiempo de espera de algo."

#: ../../library/asyncio-task.rst:685
msgid ""
"*delay* can either be ``None``, or a float/int number of seconds to wait. If "
"*delay* is ``None``, no time limit will be applied; this can be useful if "
"the delay is unknown when the context manager is created."
msgstr ""
"*delay* puede ser ``None``, o un número float/int de segundos a esperar. Si "
"*delay* es ``None``, no se aplicará ningún límite de tiempo; esto puede ser "
"útil si el retraso es desconocido cuando se crea el gestor de contexto."

#: ../../library/asyncio-task.rst:690
msgid ""
"In either case, the context manager can be rescheduled after creation using :"
"meth:`Timeout.reschedule`."
msgstr ""
"En ambos casos, el gestor de contexto puede reprogramarse tras su creación "
"mediante :meth:`Timeout.reschedule`."

#: ../../library/asyncio-task.rst:695
msgid ""
"async def main():\n"
"    async with asyncio.timeout(10):\n"
"        await long_running_task()"
msgstr ""
"async def main():\n"
"    async con asyncio.timeout(10):\n"
"        await tarea_larga()"

#: ../../library/asyncio-task.rst:699
msgid ""
"If ``long_running_task`` takes more than 10 seconds to complete, the context "
"manager will cancel the current task and handle the resulting :exc:`asyncio."
"CancelledError` internally, transforming it into a :exc:`TimeoutError` which "
"can be caught and handled."
msgstr ""
"Si ``long_running_task`` tarda más de 10 segundos en completarse, el gestor "
"de contexto cancelará la tarea actual y gestionará internamente la :exc:"
"`asyncio.CancelledError` resultante, transformándola en una :exc:"
"`TimeoutError` que puede ser capturada y gestionada."

#: ../../library/asyncio-task.rst:706
msgid ""
"The :func:`asyncio.timeout` context manager is what transforms the :exc:"
"`asyncio.CancelledError` into a :exc:`TimeoutError`, which means the :exc:"
"`TimeoutError` can only be caught *outside* of the context manager."
msgstr ""
"El gestor de contexto :func:`asyncio.timeout` es lo que transforma el :exc:"
"`asyncio.CancelledError` en un :exc:`TimeoutError`, lo que significa que el :"
"exc:`TimeoutError` sólo puede ser capturado *outside* del gestor de contexto."

#: ../../library/asyncio-task.rst:711
msgid "Example of catching :exc:`TimeoutError`::"
msgstr "Ejemplo de captura :exc:`TimeoutError`::"

#: ../../library/asyncio-task.rst:713
msgid ""
"async def main():\n"
"    try:\n"
"        async with asyncio.timeout(10):\n"
"            await long_running_task()\n"
"    except TimeoutError:\n"
"        print(\"The long operation timed out, but we've handled it.\")\n"
"\n"
"    print(\"This statement will run regardless.\")"
msgstr ""
"async def main():\n"
"    try:\n"
"        async con asyncio.timeout(10):\n"
"            await long_running_task()\n"
"    except TimeoutError:\n"
"        print(\"La operación larga agotó el tiempo de espera, pero la hemos "
"solucionado.\")\n"
"\n"
"    print(\"Esta sentencia se ejecutará a pesar de todo.\")"

#: ../../library/asyncio-task.rst:722
msgid ""
"The context manager produced by :func:`asyncio.timeout` can be rescheduled "
"to a different deadline and inspected."
msgstr ""
"El gestor de contexto producido por :func:`asyncio.timeout` puede "
"reprogramarse a una fecha límite diferente e inspeccionarse."

#: ../../library/asyncio-task.rst:727
msgid ""
"An :ref:`asynchronous context manager <async-context-managers>` for "
"cancelling overdue coroutines."
msgstr ""
"Un :ref:`asynchronous context manager <async-context-managers>` para "
"cancelar coroutines atrasadas."

#: ../../library/asyncio-task.rst:730
msgid ""
"``when`` should be an absolute time at which the context should time out, as "
"measured by the event loop's clock:"
msgstr ""
"``when`` debe ser un tiempo absoluto en el que el contexto debe expirar, "
"medido por el reloj del bucle de eventos:"

#: ../../library/asyncio-task.rst:733
msgid "If ``when`` is ``None``, the timeout will never trigger."
msgstr "Si ``when`` es ``None``, el tiempo de espera nunca se activará."

#: ../../library/asyncio-task.rst:734
msgid ""
"If ``when < loop.time()``, the timeout will trigger on the next iteration of "
"the event loop."
msgstr ""
"Si ``when < loop.time()``, el tiempo de espera se activará en la siguiente "
"iteración del bucle de eventos."

#: ../../library/asyncio-task.rst:739
msgid ""
"Return the current deadline, or ``None`` if the current deadline is not set."
msgstr ""
"Devuelve la fecha límite actual, o ``None`` si la fecha límite actual no "
"está establecida."

#: ../../library/asyncio-task.rst:744
msgid "Reschedule the timeout."
msgstr "Reprogramar el tiempo de espera."

#: ../../library/asyncio-task.rst:748
msgid "Return whether the context manager has exceeded its deadline (expired)."
msgstr ""
"Devuelve si el administrador de contexto ha excedido su fecha límite "
"(expirado)."

#: ../../library/asyncio-task.rst:753
msgid ""
"async def main():\n"
"    try:\n"
"        # We do not know the timeout when starting, so we pass ``None``.\n"
"        async with asyncio.timeout(None) as cm:\n"
"            # We know the timeout now, so we reschedule it.\n"
"            new_deadline = get_running_loop().time() + 10\n"
"            cm.reschedule(new_deadline)\n"
"\n"
"            await long_running_task()\n"
"    except TimeoutError:\n"
"        pass\n"
"\n"
"    if cm.expired():\n"
"        print(\"Looks like we haven't finished on time.\")"
msgstr ""
"async def main():\n"
"    try:\n"
"        # No sabemos el tiempo de espera al arrancar, así que pasamos "
"``None``.\n"
"        async con asyncio.timeout(None) como cm:\n"
"            # Ahora sabemos el tiempo de espera, así que lo reprogramamos.\n"
"            new_deadline = get_running_loop().time() + 10\n"
"            cm.reschedule(nueva_fecha_final)\n"
"\n"
"              await long_running_task()\n"
"       except TimeoutError:\n"
"            pass\n"
"\n"
"if cm.expired():\n"
"        print(\"Parece que no hemos terminado a tiempo.\")"

#: ../../library/asyncio-task.rst:768
msgid "Timeout context managers can be safely nested."
msgstr ""
"Los gestores de contexto de tiempo de espera pueden anidarse de forma segura."

#: ../../library/asyncio-task.rst:774
msgid ""
"Similar to :func:`asyncio.timeout`, except *when* is the absolute time to "
"stop waiting, or ``None``."
msgstr ""
"Similar a :func:`asyncio.timeout`, excepto que *when* es el momento absoluto "
"de dejar de esperar, o ``None``."

#: ../../library/asyncio-task.rst:779
msgid ""
"async def main():\n"
"    loop = get_running_loop()\n"
"    deadline = loop.time() + 20\n"
"    try:\n"
"        async with asyncio.timeout_at(deadline):\n"
"            await long_running_task()\n"
"    except TimeoutError:\n"
"        print(\"The long operation timed out, but we've handled it.\")\n"
"\n"
"    print(\"This statement will run regardless.\")"
msgstr ""
"async def main():\n"
"    loop = get_running_loop()\n"
"    deadline =loop.time() + 20\n"
"    try:\n"
"        async with asyncio.timeout_at(deadline):\n"
"            await long_running_task()\n"
"    except TimeoutError:\n"
"        print(\"La operación larga ha expirado, pero la hemos solucionado."
"\")\n"
"\n"
"    print(\"Esta sentencia se ejecutará a pesar de todo.\")"

#: ../../library/asyncio-task.rst:795
msgid ""
"Wait for the *aw* :ref:`awaitable <asyncio-awaitables>` to complete with a "
"timeout."
msgstr ""
"Espera a que se complete la *aw* :ref:`awaitable <asyncio-awaitables>` con "
"un tiempo de espera."

#: ../../library/asyncio-task.rst:800
msgid ""
"*timeout* can either be ``None`` or a float or int number of seconds to wait "
"for.  If *timeout* is ``None``, block until the future completes."
msgstr ""
"*timeout* puede ser ``None`` o un número flotante o int de segundos a "
"esperar.  Si *timeout* es ``None``, bloquea hasta que el futuro se complete."

#: ../../library/asyncio-task.rst:804
msgid ""
"If a timeout occurs, it cancels the task and raises :exc:`TimeoutError`."
msgstr ""
"Si se produce un timeout, cancela la tarea y lanza :exc:`TimeoutError`."

#: ../../library/asyncio-task.rst:807
msgid ""
"To avoid the task :meth:`cancellation <Task.cancel>`, wrap it in :func:"
"`shield`."
msgstr ""
"Para evitar la tarea :meth:`cancellation <Task.cancel>`, envuélvala en :func:"
"`shield`."

#: ../../library/asyncio-task.rst:810
msgid ""
"The function will wait until the future is actually cancelled, so the total "
"wait time may exceed the *timeout*. If an exception happens during "
"cancellation, it is propagated."
msgstr ""
"La función esperará hasta que el futuro sea realmente cancelado, por lo que "
"el tiempo total de espera puede exceder el *timeout*. Si se produce una "
"excepción durante la cancelación, se propaga."

#: ../../library/asyncio-task.rst:814
msgid "If the wait is cancelled, the future *aw* is also cancelled."
msgstr "Si se cancela la espera, también se cancela el futuro *aw*."

#: ../../library/asyncio-task.rst:820
msgid ""
"async def eternity():\n"
"    # Sleep for one hour\n"
"    await asyncio.sleep(3600)\n"
"    print('yay!')\n"
"\n"
"async def main():\n"
"    # Wait for at most 1 second\n"
"    try:\n"
"        await asyncio.wait_for(eternity(), timeout=1.0)\n"
"    except TimeoutError:\n"
"        print('timeout!')\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Expected output:\n"
"#\n"
"#     timeout!"
msgstr ""
"async def eternity():\n"
"    # Duerme una hora\n"
"    await asyncio.sleep(3600)\n"
"    print('yay!')\n"
"\n"
"async def main():\n"
"    # Espere como máximo 1 segundo\n"
"    try:\n"
"        await asyncio.wait_for(eternity(), timeout=1.0)\n"
"    except TimeoutError:\n"
"        print('timeout!')\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Expected output:\n"
"#\n"
"#     timeout!"

#: ../../library/asyncio-task.rst:838
msgid ""
"When *aw* is cancelled due to a timeout, ``wait_for`` waits for *aw* to be "
"cancelled.  Previously, it raised :exc:`TimeoutError` immediately."
msgstr ""
"Cuando *aw* se cancela debido a un timeout, ``wait_for`` espera a que *aw* "
"se cancele.  Anteriormente, lanzaba :exc:`TimeoutError` inmediatamente."

#: ../../library/asyncio-task.rst:846
msgid "Raises :exc:`TimeoutError` instead of :exc:`asyncio.TimeoutError`."
msgstr "Eleva :exc:`TimeoutError` en lugar de :exc:`asyncio.TimeoutError`."

#: ../../library/asyncio-task.rst:851
msgid "Waiting Primitives"
msgstr "Primitivas de espera"

#: ../../library/asyncio-task.rst:856
msgid ""
"Run :class:`~asyncio.Future` and :class:`~asyncio.Task` instances in the "
"*aws* iterable concurrently and block until the condition specified by "
"*return_when*."
msgstr ""
"Ejecuta :class:`~asyncio.Future` y :class:`~asyncio.Task` instancias en el "
"iterable *aws* concurrentemente y bloquea hasta la condición especificada "
"por *return_when*."

#: ../../library/asyncio-task.rst:860
msgid "The *aws* iterable must not be empty."
msgstr "El iterable *aws* no debe estar vacío."

#: ../../library/asyncio-task.rst:862
msgid "Returns two sets of Tasks/Futures: ``(done, pending)``."
msgstr "Devuelve dos conjuntos de Tasks/Futures: ``(done, pending)``."

#: ../../library/asyncio-task.rst:864
msgid "Usage::"
msgstr "Uso::"

#: ../../library/asyncio-task.rst:866
msgid "done, pending = await asyncio.wait(aws)"
msgstr "done, pending = await asyncio.wait(aws)"

#: ../../library/asyncio-task.rst:868
msgid ""
"*timeout* (a float or int), if specified, can be used to control the maximum "
"number of seconds to wait before returning."
msgstr ""
"*timeout* (un float o int), si se especifica, se puede utilizar para "
"controlar el número máximo de segundos que se debe esperar antes de volver."

#: ../../library/asyncio-task.rst:871
msgid ""
"Note that this function does not raise :exc:`TimeoutError`. Futures or Tasks "
"that aren't done when the timeout occurs are simply returned in the second "
"set."
msgstr ""
"Tenga en cuenta que esta función no plantea :exc:`TimeoutError`. Los Futuros "
"o Tareas que no se han realizado cuando se produce el tiempo de espera "
"simplemente se devuelven en el segundo conjunto."

#: ../../library/asyncio-task.rst:875
msgid ""
"*return_when* indicates when this function should return.  It must be one of "
"the following constants:"
msgstr ""
"*return_when* indica cuándo debe retornar esta función.  Debe ser una de las "
"siguientes constantes:"

#: ../../library/asyncio-task.rst:881
msgid "Constant"
msgstr "Constante"

#: ../../library/asyncio-task.rst:882
msgid "Description"
msgstr "Description"

#: ../../library/asyncio-task.rst:885
msgid "The function will return when any future finishes or is cancelled."
msgstr "La función volverá cuando cualquier futuro termine o se cancele."

#: ../../library/asyncio-task.rst:888
msgid ""
"The function will return when any future finishes by raising an exception. "
"If no future raises an exception then it is equivalent to :const:"
"`ALL_COMPLETED`."
msgstr ""
"La función regresará cuando cualquier futuro termine lanzando una excepción. "
"Si ningún futuro lanza una excepción entonces es equivalente a :const:"
"`ALL_COMPLETED`."

#: ../../library/asyncio-task.rst:893
msgid "The function will return when all futures finish or are cancelled."
msgstr "La función regresará cuando todos los futuros finalicen o se cancelen."

#: ../../library/asyncio-task.rst:895
msgid ""
"Unlike :func:`~asyncio.wait_for`, ``wait()`` does not cancel the futures "
"when a timeout occurs."
msgstr ""
"A diferencia de :func:`~asyncio.wait_for`, ``wait()`` no cancela los futuros "
"cuando se produce un timeout."

#: ../../library/asyncio-task.rst:901
msgid "Passing coroutine objects to ``wait()`` directly is forbidden."
msgstr "Está prohibido pasar objetos corrutina a ``wait()`` directamente."

#: ../../library/asyncio-task.rst:904 ../../library/asyncio-task.rst:931
msgid "Added support for generators yielding tasks."
msgstr "Añadido soporte para generadores que producen tareas."

#: ../../library/asyncio-task.rst:910
msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* iterable "
"concurrently.  Return an iterator of coroutines. Each coroutine returned can "
"be awaited to get the earliest next result from the iterable of the "
"remaining awaitables."
msgstr ""
"Ejecuta :ref:`awaitable objects <asyncio-awaitables>` en el iterable *aws* "
"concurrentemente.  Devuelve un iterador de corrutinas. Se puede esperar cada "
"corrutina devuelta para obtener el siguiente resultado más temprano del "
"iterable de los awaitables restantes."

#: ../../library/asyncio-task.rst:915
msgid ""
"Raises :exc:`TimeoutError` if the timeout occurs before all Futures are done."
msgstr ""
"Lanza :exc:`TimeoutError` si el tiempo de espera se produce antes de que "
"todos los Futures hayan terminado."

#: ../../library/asyncio-task.rst:920
msgid ""
"for coro in as_completed(aws):\n"
"    earliest_result = await coro\n"
"    # ..."
msgstr ""
"for coro in as_completed(aws):\n"
"    earliest_result = await coro\n"
"    # ..."

#: ../../library/asyncio-task.rst:927
msgid ""
"Deprecation warning is emitted if not all awaitable objects in the *aws* "
"iterable are Future-like objects and there is no running event loop."
msgstr ""
"Se emite una advertencia de desaprobación si no todos los objetos awaitable "
"en el iterable *aws* son objetos tipo Future y no hay un bucle de eventos en "
"ejecución."

#: ../../library/asyncio-task.rst:936
msgid "Running in Threads"
msgstr "Correr en hilos"

#: ../../library/asyncio-task.rst:941
msgid "Asynchronously run function *func* in a separate thread."
msgstr "Ejecuta asíncronamente la función *func* en un hilo separado."

#: ../../library/asyncio-task.rst:943
msgid ""
"Any \\*args and \\*\\*kwargs supplied for this function are directly passed "
"to *func*. Also, the current :class:`contextvars.Context` is propagated, "
"allowing context variables from the event loop thread to be accessed in the "
"separate thread."
msgstr ""
"Todos los \\*args y \\*\\*kwargs suministrados para esta función se pasan "
"directamente a *func*. Además, se propaga la dirección :class:`contextvars."
"Context` actual, lo que permite acceder a las variables de contexto del "
"bucle de eventos en el bucle independiente."

#: ../../library/asyncio-task.rst:948
msgid ""
"Return a coroutine that can be awaited to get the eventual result of *func*."
msgstr ""
"Devuelve una corrutina que se puede esperar para obtener el resultado final "
"de *func*."

#: ../../library/asyncio-task.rst:950
msgid ""
"This coroutine function is primarily intended to be used for executing IO-"
"bound functions/methods that would otherwise block the event loop if they "
"were run in the main thread. For example::"
msgstr ""
"Esta función corrutina se utiliza principalmente para ejecutar funciones/"
"métodos IO-bound que bloquearían el bucle de eventos si se ejecutaran en el "
"hilo principal. Por ejemplo::"

#: ../../library/asyncio-task.rst:954
msgid ""
"def blocking_io():\n"
"    print(f\"start blocking_io at {time.strftime('%X')}\")\n"
"    # Note that time.sleep() can be replaced with any blocking\n"
"    # IO-bound operation, such as file operations.\n"
"    time.sleep(1)\n"
"    print(f\"blocking_io complete at {time.strftime('%X')}\")\n"
"\n"
"async def main():\n"
"    print(f\"started main at {time.strftime('%X')}\")\n"
"\n"
"    await asyncio.gather(\n"
"        asyncio.to_thread(blocking_io),\n"
"        asyncio.sleep(1))\n"
"\n"
"    print(f\"finished main at {time.strftime('%X')}\")\n"
"\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Expected output:\n"
"#\n"
"# started main at 19:50:53\n"
"# start blocking_io at 19:50:53\n"
"# blocking_io complete at 19:50:54\n"
"# finished main at 19:50:54"
msgstr ""
"def blocking_io():\n"
"    print(f \"start blocking_io at {time.strftime('%X')}\")\n"
"    # Nótese que time.sleep() se puede reemplazar por cualquier bloqueo\n"
"    # bloqueo IO-bound, como por ejemplo operaciones con ficheros.\n"
"    time.sleep(1)\n"
"    print(f\"blocking_io complete at {time.strftime('%X')}\")\n"
"\n"
"async def main():\n"
"    print(f \"iniciado main a las {time.strftime('%X')}\")\n"
"\n"
"    await asyncio.gather(\n"
"        asyncio.to_thread(blocking_io),\n"
"        asyncio.sleep(1))\n"
"\n"
"    print(f \"finished main at {time.strftime('%X')}\")\n"
"\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Salida esperada:\n"
"#\n"
"# iniciado main a las 19:50:53\n"
"# inicio blocking_io a las 19:50:53\n"
"# blocking_io completo a las 19:50:54\n"
"# finished main at 19:50:54"

#: ../../library/asyncio-task.rst:980
msgid ""
"Directly calling ``blocking_io()`` in any coroutine would block the event "
"loop for its duration, resulting in an additional 1 second of run time. "
"Instead, by using ``asyncio.to_thread()``, we can run it in a separate "
"thread without blocking the event loop."
msgstr ""
"Llamar directamente a ``blocking_io()`` en cualquier corrutina bloquearía el "
"bucle de eventos durante su duración, resultando en 1 segundo adicional de "
"tiempo de ejecución. En su lugar, utilizando ``asyncio.to_thread()``, "
"podemos ejecutarlo en un hilo separado sin bloquear el bucle de eventos."

#: ../../library/asyncio-task.rst:987
msgid ""
"Due to the :term:`GIL`, ``asyncio.to_thread()`` can typically only be used "
"to make IO-bound functions non-blocking. However, for extension modules that "
"release the GIL or alternative Python implementations that don't have one, "
"``asyncio.to_thread()`` can also be used for CPU-bound functions."
msgstr ""
"Debido al :term:`GIL`, ``asyncio.to_thread()`` sólo se puede usar "
"típicamente para hacer no bloqueantes las funciones enlazadas a E/S. Sin "
"embargo, para módulos de extensión que liberen el GIL o implementaciones "
"alternativas de Python que no tengan uno, ``asyncio.to_thread()`` también "
"puede usarse para funciones ligadas a la CPU."

#: ../../library/asyncio-task.rst:996
msgid "Scheduling From Other Threads"
msgstr "Programación desde otros hilos"

#: ../../library/asyncio-task.rst:1000
msgid "Submit a coroutine to the given event loop.  Thread-safe."
msgstr "Envía una corrutina al bucle de eventos dado.  A prueba de hilos."

#: ../../library/asyncio-task.rst:1002
msgid ""
"Return a :class:`concurrent.futures.Future` to wait for the result from "
"another OS thread."
msgstr ""
"Devuelve un :class:`concurrent.futures.Future` para esperar el resultado de "
"otro hilo OS."

#: ../../library/asyncio-task.rst:1005
msgid ""
"This function is meant to be called from a different OS thread than the one "
"where the event loop is running.  Example::"
msgstr ""
"Esta función está pensada para ser llamada desde un hilo del sistema "
"operativo distinto de aquel en el que se está ejecutando el bucle de "
"eventos.  Ejemplo::"

#: ../../library/asyncio-task.rst:1008
msgid ""
"# Create a coroutine\n"
"coro = asyncio.sleep(1, result=3)\n"
"\n"
"# Submit the coroutine to a given loop\n"
"future = asyncio.run_coroutine_threadsafe(coro, loop)\n"
"\n"
"# Wait for the result with an optional timeout argument\n"
"assert future.result(timeout) == 3"
msgstr ""
"# Crear una corrutina\n"
"coro = asyncio.sleep(1, result=3)\n"
"\n"
"# Enviar la corrutina a un bucle dado\n"
"future = asyncio.run_coroutine_threadsafe(coro, loop)\n"
"\n"
"# Esperar el resultado con un argumento opcional de tiempo de espera\n"
"assert future.result(timeout) == 3"

#: ../../library/asyncio-task.rst:1017
msgid ""
"If an exception is raised in the coroutine, the returned Future will be "
"notified.  It can also be used to cancel the task in the event loop::"
msgstr ""
"Si se produce una excepción en la corrutina, se notificará al Future "
"devuelto.  También se puede utilizar para cancelar la tarea en el bucle de "
"eventos::"

#: ../../library/asyncio-task.rst:1021
msgid ""
"try:\n"
"    result = future.result(timeout)\n"
"except TimeoutError:\n"
"    print('The coroutine took too long, cancelling the task...')\n"
"    future.cancel()\n"
"except Exception as exc:\n"
"    print(f'The coroutine raised an exception: {exc!r}')\n"
"else:\n"
"    print(f'The coroutine returned: {result!r}')"
msgstr ""
"try:\n"
"    result = future.result(timeout)\n"
"except TimeoutError:\n"
"    print('La rutina tardó demasiado, cancelando la tarea...')\n"
"    future.cancel()\n"
"except Exception as exc:\n"
"    print(f'La rutina generó una excepción: {exc!r}')\n"
"else:\n"
"    print(f'La rutina regresó: {result!r}')"

#: ../../library/asyncio-task.rst:1031
msgid ""
"See the :ref:`concurrency and multithreading <asyncio-multithreading>` "
"section of the documentation."
msgstr ""
"Ver la sección :ref:`concurrency and multithreading <asyncio-"
"multithreading>` de la documentación."

#: ../../library/asyncio-task.rst:1034
msgid ""
"Unlike other asyncio functions this function requires the *loop* argument to "
"be passed explicitly."
msgstr ""
"A diferencia de otras funciones asyncio esta función requiere que el "
"argumento *loop* se pase explícitamente."

#: ../../library/asyncio-task.rst:1041
msgid "Introspection"
msgstr "Introspección"

#: ../../library/asyncio-task.rst:1046
msgid ""
"Return the currently running :class:`Task` instance, or ``None`` if no task "
"is running."
msgstr ""
"Devuelve la instancia de :class:`Task` que se está ejecutando actualmente, o "
"``None`` si no hay ninguna tarea en ejecución."

#: ../../library/asyncio-task.rst:1049
msgid ""
"If *loop* is ``None`` :func:`get_running_loop` is used to get the current "
"loop."
msgstr ""
"Si *loop* es ``None`` :func:`get_running_loop` se utiliza para obtener el "
"bucle actual."

#: ../../library/asyncio-task.rst:1057
msgid "Return a set of not yet finished :class:`Task` objects run by the loop."
msgstr ""
"Devuelve un conjunto de objetos :class:`Task` aún no finalizados ejecutados "
"por el bucle."

#: ../../library/asyncio-task.rst:1060
msgid ""
"If *loop* is ``None``, :func:`get_running_loop` is used for getting current "
"loop."
msgstr ""
"Si *loop* es ``None``, se utiliza :func:`get_running_loop` para obtener el "
"bucle actual."

#: ../../library/asyncio-task.rst:1068
msgid "Return ``True`` if *obj* is a coroutine object."
msgstr "Devuelve ``True`` si *obj* es un objeto de corrutina.."

#: ../../library/asyncio-task.rst:1074
msgid "Task Object"
msgstr "Objeto de la tarea"

#: ../../library/asyncio-task.rst:1078
msgid ""
"A :class:`Future-like <Future>` object that runs a Python :ref:`coroutine "
"<coroutine>`.  Not thread-safe."
msgstr ""
"Un objeto :class:`Future-like <Future>` que ejecuta una :ref:`coroutine "
"<coroutine>` de Python.  No es seguro para hilos."

#: ../../library/asyncio-task.rst:1081
msgid ""
"Tasks are used to run coroutines in event loops. If a coroutine awaits on a "
"Future, the Task suspends the execution of the coroutine and waits for the "
"completion of the Future.  When the Future is *done*, the execution of the "
"wrapped coroutine resumes."
msgstr ""
"Las Tareas se utilizan para ejecutar corrutinas en bucles de eventos. Si una "
"corrutina espera en un Future, la Tarea suspende la ejecución de la "
"corrutina y espera la finalización de Future.  Cuando Futurse está *done*, "
"se reanuda la ejecución de la corrutina empaquetada."

#: ../../library/asyncio-task.rst:1087
msgid ""
"Event loops use cooperative scheduling: an event loop runs one Task at a "
"time.  While a Task awaits for the completion of a Future, the event loop "
"runs other Tasks, callbacks, or performs IO operations."
msgstr ""
"Los bucles de eventos utilizan programación cooperativa: un bucle de eventos "
"ejecuta una tarea a la vez.  Mientras una Tarea espera la finalización de un "
"Future, el bucle de eventos ejecuta otras Tareas, devoluciones de llamada o "
"realiza operaciones IO."

#: ../../library/asyncio-task.rst:1092
msgid ""
"Use the high-level :func:`asyncio.create_task` function to create Tasks, or "
"the low-level :meth:`loop.create_task` or :func:`ensure_future` functions.  "
"Manual instantiation of Tasks is discouraged."
msgstr ""
"Utilice la función de alto nivel :func:`asyncio.create_task` para crear "
"tareas, o las funciones de bajo nivel :meth:`loop.create_task` o :func:"
"`ensure_future`.  Se desaconseja la creación manual de tareas."

#: ../../library/asyncio-task.rst:1097
msgid ""
"To cancel a running Task use the :meth:`cancel` method.  Calling it will "
"cause the Task to throw a :exc:`CancelledError` exception into the wrapped "
"coroutine.  If a coroutine is awaiting on a Future object during "
"cancellation, the Future object will be cancelled."
msgstr ""
"Para cancelar una tarea en ejecución, utilice el método :meth:`cancel`.  Al "
"llamarlo, la tarea lanzará una excepción :exc:`CancelledError` en la "
"corrutina empaquetada.  Si una corrutina está esperando en un objeto Future "
"durante la cancelación, este se cancelará."

#: ../../library/asyncio-task.rst:1102
msgid ""
":meth:`cancelled` can be used to check if the Task was cancelled. The method "
"returns ``True`` if the wrapped coroutine did not suppress the :exc:"
"`CancelledError` exception and was actually cancelled."
msgstr ""
":meth:`cancelled` se puede utilizar para comprobar si la tarea fue "
"cancelada. El método devuelve ``True`` si la corrutina empaquetada no "
"suprimió la excepción :exc:`CancelledError` y se canceló realmente."

#: ../../library/asyncio-task.rst:1107
msgid ""
":class:`asyncio.Task` inherits from :class:`Future` all of its APIs except :"
"meth:`Future.set_result` and :meth:`Future.set_exception`."
msgstr ""
":class:`asyncio.Task` hereda de :class:`Future` todas sus API, excepto :meth:"
"`Future.set_result` y :meth:`Future.set_exception`."

#: ../../library/asyncio-task.rst:1111
msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the *coro* to run in. If no *context* is "
"provided, the Task copies the current context and later runs its coroutine "
"in the copied context."
msgstr ""
"Un argumento opcional *context* de sólo palabra clave permite especificar "
"un :class:`contextvars.Context` personalizado para que el *coro* se ejecute "
"en él. Si no se proporciona *context*, la Tarea copia el contexto actual y "
"posteriormente ejecuta su corrutina en el contexto copiado."

#: ../../library/asyncio-task.rst:1116
msgid ""
"An optional keyword-only *eager_start* argument allows eagerly starting the "
"execution of the :class:`asyncio.Task` at task creation time. If set to "
"``True`` and the event loop is running, the task will start executing the "
"coroutine immediately, until the first time the coroutine blocks. If the "
"coroutine returns or raises without blocking, the task will be finished "
"eagerly and will skip scheduling to the event loop."
msgstr ""
"Un argumento opcional *eager_start* permite iniciar la ejecución de :class:"
"`asyncio.Task` en el momento de creación de la tarea. Si se establece a "
"``True`` y el bucle de eventos se está ejecutando, la tarea comenzará a "
"ejecutar la coroutina inmediatamente, hasta la primera vez que la coroutina "
"se bloquee. Si la coroutina retorna o se levanta sin bloquearse, la tarea "
"terminará ansiosamente y saltará la programación al bucle de eventos."

#: ../../library/asyncio-task.rst:1123
msgid "Added support for the :mod:`contextvars` module."
msgstr "Se ha añadido compatibilidad con el módulo :mod:`contextvars`."

#: ../../library/asyncio-task.rst:1129
msgid ""
"Deprecation warning is emitted if *loop* is not specified and there is no "
"running event loop."
msgstr ""
"Se emite una advertencia de desaprobación si no se especifica *loop* y no "
"hay ningún bucle de eventos en ejecución."

#: ../../library/asyncio-task.rst:1136
msgid "Added the *eager_start* parameter."
msgstr "Añadido el parámetro *eager_start*."

#: ../../library/asyncio-task.rst:1141
msgid "Return ``True`` if the Task is *done*."
msgstr "Devuelve ``True`` si la tarea está *done*."

#: ../../library/asyncio-task.rst:1143
msgid ""
"A Task is *done* when the wrapped coroutine either returned a value, raised "
"an exception, or the Task was cancelled."
msgstr ""
"Una tarea está *done* cuando la corrutina envuelta devuelve un valor, lanza "
"una excepción o la tarea se cancela."

#: ../../library/asyncio-task.rst:1148
msgid "Return the result of the Task."
msgstr "Devuelve el resultado de la Tarea."

#: ../../library/asyncio-task.rst:1150
msgid ""
"If the Task is *done*, the result of the wrapped coroutine is returned (or "
"if the coroutine raised an exception, that exception is re-raised.)"
msgstr ""
"Si la tarea está *done*, se devuelve el resultado de la corrutina "
"empaquetada (o si la corrutina lanzó una excepción, esa excepción se vuelve "
"a lanzar)."

#: ../../library/asyncio-task.rst:1154 ../../library/asyncio-task.rst:1168
msgid ""
"If the Task has been *cancelled*, this method raises a :exc:`CancelledError` "
"exception."
msgstr ""
"Si se ha *cancelled*, Task este método lanza una excepción :exc:"
"`CancelledError`."

#: ../../library/asyncio-task.rst:1157
msgid ""
"If the Task's result isn't yet available, this method raises an :exc:"
"`InvalidStateError` exception."
msgstr ""
"Si el resultado de la tarea aún no está disponible, este método lanza una "
"excepción :exc:`InvalidStateError`."

#: ../../library/asyncio-task.rst:1162
msgid "Return the exception of the Task."
msgstr "Devuelve la excepción de la Tarea."

#: ../../library/asyncio-task.rst:1164
msgid ""
"If the wrapped coroutine raised an exception that exception is returned.  If "
"the wrapped coroutine returned normally this method returns ``None``."
msgstr ""
"Si la corrutina envuelta lanza una excepción, esta excepción es devuelta.  "
"Si la corrutina envuelta regresa normalmente este método devuelve ``None``."

#: ../../library/asyncio-task.rst:1171
msgid ""
"If the Task isn't *done* yet, this method raises an :exc:`InvalidStateError` "
"exception."
msgstr ""
"Si la tarea aún no está *hecha*, este método lanza una excepción :exc:"
"`InvalidStateError`."

#: ../../library/asyncio-task.rst:1176
msgid "Add a callback to be run when the Task is *done*."
msgstr ""
"Añade una llamada de retorno que se ejecutará cuando la tarea esté *done*."

#: ../../library/asyncio-task.rst:1178 ../../library/asyncio-task.rst:1187
msgid "This method should only be used in low-level callback-based code."
msgstr ""
"Este método sólo debe utilizarse en código de bajo nivel basado en llamadas "
"de retorno."

#: ../../library/asyncio-task.rst:1180
msgid ""
"See the documentation of :meth:`Future.add_done_callback` for more details."
msgstr ""
"Ver la documentación de :meth:`Future.add_done_callback` para más detalles."

#: ../../library/asyncio-task.rst:1185
msgid "Remove *callback* from the callbacks list."
msgstr "Elimina *callback* de la lista de callbacks."

#: ../../library/asyncio-task.rst:1189
msgid ""
"See the documentation of :meth:`Future.remove_done_callback` for more "
"details."
msgstr ""
"Para más detalles ver  la documentación de :meth:`Future."
"remove_done_callback`."

#: ../../library/asyncio-task.rst:1194
msgid "Return the list of stack frames for this Task."
msgstr "Devuelve la lista de marcos de pila de esta tarea."

#: ../../library/asyncio-task.rst:1196
msgid ""
"If the wrapped coroutine is not done, this returns the stack where it is "
"suspended.  If the coroutine has completed successfully or was cancelled, "
"this returns an empty list. If the coroutine was terminated by an exception, "
"this returns the list of traceback frames."
msgstr ""
"Si la corrutina envuelta no ha terminado, esto devuelve la pila donde está "
"suspendida.  Si la corrutina ha finalizado con éxito o se ha cancelado, esto "
"devuelve una lista vacía. Si la corrutina se terminó por una excepción, esto "
"devuelve la lista de marcos de rastreo."

#: ../../library/asyncio-task.rst:1202
msgid "The frames are always ordered from oldest to newest."
msgstr "Los marcos se ordenan siempre de más antiguo a más reciente."

#: ../../library/asyncio-task.rst:1204
msgid "Only one stack frame is returned for a suspended coroutine."
msgstr "Sólo se devuelve un marco de pila para una corrutina suspendida."

#: ../../library/asyncio-task.rst:1206
msgid ""
"The optional *limit* argument sets the maximum number of frames to return; "
"by default all available frames are returned. The ordering of the returned "
"list differs depending on whether a stack or a traceback is returned: the "
"newest frames of a stack are returned, but the oldest frames of a traceback "
"are returned.  (This matches the behavior of the traceback module.)"
msgstr ""
"El argumento opcional *limit* establece el número máximo de tramas a "
"devolver; por defecto se devuelven todas las tramas disponibles. El orden de "
"la lista devuelta difiere dependiendo de si se devuelve una pila o un "
"rastreo: se devuelven los fotogramas más nuevos de una pila, pero se "
"devuelven los fotogramas más antiguos de un rastreo.  (Esto coincide con el "
"comportamiento del módulo traceback)."

#: ../../library/asyncio-task.rst:1215
msgid "Print the stack or traceback for this Task."
msgstr "Imprime la pila o el seguimiento de esta tarea."

#: ../../library/asyncio-task.rst:1217
msgid ""
"This produces output similar to that of the traceback module for the frames "
"retrieved by :meth:`get_stack`."
msgstr ""
"Esto produce una salida similar a la del módulo traceback para las tramas "
"recuperadas por :meth:`get_stack`."

#: ../../library/asyncio-task.rst:1220
msgid "The *limit* argument is passed to :meth:`get_stack` directly."
msgstr "El argumento *limit* se pasa directamente a :meth:`get_stack`."

#: ../../library/asyncio-task.rst:1222
msgid ""
"The *file* argument is an I/O stream to which the output is written; by "
"default output is written to :data:`sys.stdout`."
msgstr ""
"El argumento *file* es un flujo de E/S en el que se escribe la salida; por "
"defecto, la salida se escribe en :data:`sys.stdout`."

#: ../../library/asyncio-task.rst:1227
msgid "Return the coroutine object wrapped by the :class:`Task`."
msgstr "Devuelve el objeto corrutina envuelta por el :class:`Task`."

#: ../../library/asyncio-task.rst:1231
msgid ""
"This will return ``None`` for Tasks which have already completed eagerly. "
"See the :ref:`Eager Task Factory <eager-task-factory>`."
msgstr ""
"Esto devolverá ``None`` para las tareas que ya se han completado "
"ansiosamente. Ver la :ref:`Eager Task Factory <eager-task-factory>`."

#: ../../library/asyncio-task.rst:1238
msgid "Newly added eager task execution means result may be ``None``."
msgstr ""
"La nueva ejecución eager task significa que el resultado puede ser ``None``."

#: ../../library/asyncio-task.rst:1242
msgid ""
"Return the :class:`contextvars.Context` object associated with the task."
msgstr "Devuelve el objeto :class:`contextvars.Context` asociado a la tarea."

#: ../../library/asyncio-task.rst:1249
msgid "Return the name of the Task."
msgstr "Devuelve el nombre de la Tarea."

#: ../../library/asyncio-task.rst:1251
msgid ""
"If no name has been explicitly assigned to the Task, the default asyncio "
"Task implementation generates a default name during instantiation."
msgstr ""
"Si no se ha asignado explícitamente un nombre a la tarea, la implementación "
"por defecto de asyncio Task genera un nombre por defecto durante la "
"instanciación."

#: ../../library/asyncio-task.rst:1259
msgid "Set the name of the Task."
msgstr "Establezca el nombre de la Tarea."

#: ../../library/asyncio-task.rst:1261
msgid ""
"The *value* argument can be any object, which is then converted to a string."
msgstr ""
"El argumento *valor* puede ser cualquier objeto, que luego se convierte en "
"una cadena."

#: ../../library/asyncio-task.rst:1264
msgid ""
"In the default Task implementation, the name will be visible in the :func:"
"`repr` output of a task object."
msgstr ""
"En la implementación por defecto de Task, el nombre será visible en la "
"salida :func:`repr` de un objeto task."

#: ../../library/asyncio-task.rst:1271
msgid "Request the Task to be cancelled."
msgstr "Solicitar la anulación de la Tarea."

#: ../../library/asyncio-task.rst:1273
msgid ""
"This arranges for a :exc:`CancelledError` exception to be thrown into the "
"wrapped coroutine on the next cycle of the event loop."
msgstr ""
"Esto hace que se lance una excepción :exc:`CancelledError` en la coroutine "
"envuelta en el siguiente ciclo del bucle de eventos."

#: ../../library/asyncio-task.rst:1276
msgid ""
"The coroutine then has a chance to clean up or even deny the request by "
"suppressing the exception with a :keyword:`try` ... ... ``except "
"CancelledError`` ... :keyword:`finally` block. Therefore, unlike :meth:"
"`Future.cancel`, :meth:`Task.cancel` does not guarantee that the Task will "
"be cancelled, although suppressing cancellation completely is not common and "
"is actively discouraged.  Should the coroutine nevertheless decide to "
"suppress the cancellation, it needs to call :meth:`Task.uncancel` in "
"addition to catching the exception."
msgstr ""
"La corrutina tiene entonces la oportunidad de limpiar o incluso denegar la "
"petición suprimiendo la excepción con un bloque :keyword:`try`... ... "
"``except CancelledError``... :keyword:`finally`. Por lo tanto, a diferencia "
"de :meth:`Future.cancel`, :meth:`Task.cancel` no garantiza que la Tarea se "
"cancele, aunque suprimir la cancelación completamente no es común y se "
"desaconseja activamente.  Si, a pesar de todo, la corrutina decide suprimir "
"la cancelación, deberá llamar a :meth:`Task.uncancel` además de capturar la "
"excepción."

#: ../../library/asyncio-task.rst:1286
msgid "Added the *msg* parameter."
msgstr "Se ha añadido el parámetro *msg*."

#: ../../library/asyncio-task.rst:1289
msgid "The ``msg`` parameter is propagated from cancelled task to its awaiter."
msgstr "El parámetro ``msg`` se propaga de la tarea cancelada a su awaiter."

#: ../../library/asyncio-task.rst:1294
msgid ""
"The following example illustrates how coroutines can intercept the "
"cancellation request::"
msgstr ""
"El siguiente ejemplo ilustra cómo las corrutinas pueden interceptar la "
"solicitud de cancelación::"

#: ../../library/asyncio-task.rst:1297
msgid ""
"async def cancel_me():\n"
"    print('cancel_me(): before sleep')\n"
"\n"
"    try:\n"
"        # Wait for 1 hour\n"
"        await asyncio.sleep(3600)\n"
"    except asyncio.CancelledError:\n"
"        print('cancel_me(): cancel sleep')\n"
"        raise\n"
"    finally:\n"
"        print('cancel_me(): after sleep')\n"
"\n"
"async def main():\n"
"    # Create a \"cancel_me\" Task\n"
"    task = asyncio.create_task(cancel_me())\n"
"\n"
"    # Wait for 1 second\n"
"    await asyncio.sleep(1)\n"
"\n"
"    task.cancel()\n"
"    try:\n"
"        await task\n"
"    except asyncio.CancelledError:\n"
"        print(\"main(): cancel_me is cancelled now\")\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Expected output:\n"
"#\n"
"#     cancel_me(): before sleep\n"
"#     cancel_me(): cancel sleep\n"
"#     cancel_me(): after sleep\n"
"#     main(): cancel_me is cancelled now"
msgstr ""
"async def cancel_me():\n"
"        print('cancel_me(): before sleep')\n"
"\n"
"        try:\n"
"        # Esperar 1 hora\n"
"        await asyncio.sleep(3600)\n"
"    except asyncio.CancelledError:\n"
"        print('cancel_me(): cancel sleep')\n"
"        raise\n"
"    finally:\n"
"        print('cancel_me(): after sleep')\n"
"\n"
"async def main():\n"
"    # Crear una tarea \"cancel_me\n"
"    task = asyncio.create_task(cancel_me())\n"
"\n"
"    # Espera 1 segundo\n"
"    await asyncio.sleep(1)\n"
"\n"
"    task.cancel()\n"
"    tryr:\n"
"        await tarea\n"
"    except asyncio.CancelledError:\n"
"        print(\"main(): cancel_me se cancela ahora\")\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Salida esperada:\n"
"#\n"
"# cancel_me(): antes de dormir\n"
"# cancel_me(): cancelar dormir\n"
"# cancel_me(): después de dormir\n"
"# main(): cancel_me se cancela ahora"

#: ../../library/asyncio-task.rst:1333
msgid "Return ``True`` if the Task is *cancelled*."
msgstr "Devuelve ``True`` si se ha *cancelled* la tarea."

#: ../../library/asyncio-task.rst:1335
msgid ""
"The Task is *cancelled* when the cancellation was requested with :meth:"
"`cancel` and the wrapped coroutine propagated the :exc:`CancelledError` "
"exception thrown into it."
msgstr ""
"La Tarea se *cancelled* cuando la cancelación se solicitó con :meth:`cancel` "
"y la corrutina envuelta propagó la excepción :exc:`CancelledError` lanzada "
"en ella."

#: ../../library/asyncio-task.rst:1341
msgid "Decrement the count of cancellation requests to this Task."
msgstr "Disminuye el recuento de solicitudes de cancelación a esta Tarea."

#: ../../library/asyncio-task.rst:1343
msgid "Returns the remaining number of cancellation requests."
msgstr "Devuelve el número restante de solicitudes de cancelación."

#: ../../library/asyncio-task.rst:1345
msgid ""
"Note that once execution of a cancelled task completed, further calls to :"
"meth:`uncancel` are ineffective."
msgstr ""
"Tenga en cuenta que, una vez finalizada la ejecución de una tarea cancelada, "
"las llamadas posteriores a :meth:`uncancel` son ineficaces."

#: ../../library/asyncio-task.rst:1350
msgid ""
"This method is used by asyncio's internals and isn't expected to be used by "
"end-user code.  In particular, if a Task gets successfully uncancelled, this "
"allows for elements of structured concurrency like :ref:`taskgroups` and :"
"func:`asyncio.timeout` to continue running, isolating cancellation to the "
"respective structured block. For example::"
msgstr ""
"Este método es utilizado por los componentes internos de asyncio y no se "
"espera que sea utilizado por el código del usuario final.  En particular, si "
"una tarea se cancela con éxito, esto permite que los elementos de "
"concurrencia estructurada como :ref:`taskgroups` y :func:`asyncio.timeout` "
"continúen ejecutándose, aislando la cancelación al bloque estructurado "
"respectivo. Por ejemplo::"

#: ../../library/asyncio-task.rst:1357
msgid ""
"async def make_request_with_timeout():\n"
"    try:\n"
"        async with asyncio.timeout(1):\n"
"            # Structured block affected by the timeout:\n"
"            await make_request()\n"
"            await make_another_request()\n"
"    except TimeoutError:\n"
"        log(\"There was a timeout\")\n"
"    # Outer code not affected by the timeout:\n"
"    await unrelated_code()"
msgstr ""
"async def make_request_with_timeout():\n"
"    try:\n"
"        async with asyncio.timeout(1):\n"
"            # Bloque estructurado afectado por el timeout:\n"
"            await make_request()\n"
"            await make_another_request()\n"
"    except TimeoutError:\n"
"        log(\"Hubo un timeout\")\n"
"    # Código externo no afectado por el timeout:\n"
"    await unrelated_code()"

#: ../../library/asyncio-task.rst:1368
msgid ""
"While the block with ``make_request()`` and ``make_another_request()`` might "
"get cancelled due to the timeout, ``unrelated_code()`` should continue "
"running even in case of the timeout.  This is implemented with :meth:"
"`uncancel`.  :class:`TaskGroup` context managers use :func:`uncancel` in a "
"similar fashion."
msgstr ""
"Mientras que el bloque con ``make_request()`` y ``make_another_request()`` "
"podría cancelarse debido al tiempo de espera, ``unrelated_code()`` debería "
"continuar ejecutándose incluso en caso de tiempo de espera.  Esto se "
"implementa con :meth:`uncancel`. Los gestores de contexto :class:`TaskGroup` "
"utilizan :func:`uncancel` de forma similar."

#: ../../library/asyncio-task.rst:1374
msgid ""
"If end-user code is, for some reason, suppressing cancellation by catching :"
"exc:`CancelledError`, it needs to call this method to remove the "
"cancellation state."
msgstr ""
"Si el código del usuario final está, por alguna razón, suprimiendo la "
"cancelación mediante la captura de :exc:`CancelledError`, necesita llamar a "
"este método para eliminar el estado de cancelación."

#: ../../library/asyncio-task.rst:1380
msgid ""
"Return the number of pending cancellation requests to this Task, i.e., the "
"number of calls to :meth:`cancel` less the number of :meth:`uncancel` calls."
msgstr ""
"Devuelve el número de solicitudes de cancelación pendientes a esta Tarea, es "
"decir, el número de llamadas a :meth:`cancel` menos el número de llamadas a :"
"meth:`uncancel`."

#: ../../library/asyncio-task.rst:1384
msgid ""
"Note that if this number is greater than zero but the Task is still "
"executing, :meth:`cancelled` will still return ``False``. This is because "
"this number can be lowered by calling :meth:`uncancel`, which can lead to "
"the task not being cancelled after all if the cancellation requests go down "
"to zero."
msgstr ""
"Tenga en cuenta que si este número es mayor que cero pero la tarea sigue "
"ejecutándose, :meth:`cancelled` devolverá ``False``. Esto se debe a que este "
"número puede reducirse llamando a :meth:`uncancel`, lo que puede llevar a "
"que la tarea no se cancele después de todo si las peticiones de cancelación "
"bajan a cero."

#: ../../library/asyncio-task.rst:1390
msgid ""
"This method is used by asyncio's internals and isn't expected to be used by "
"end-user code.  See :meth:`uncancel` for more details."
msgstr ""
"Usan este método las funciones internas de asyncio y no se espera que sea "
"utilizado por el código del usuario final.  Para más detalles ver :meth:"
"`uncancel`."
