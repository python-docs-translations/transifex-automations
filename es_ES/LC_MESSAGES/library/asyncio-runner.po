# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# eulalio barbero espinosa <eulalio@disroot.org>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-23 15:30+0000\n"
"PO-Revision-Date: 2024-05-11 00:33+0000\n"
"Last-Translator: eulalio barbero espinosa <eulalio@disroot.org>, 2025\n"
"Language-Team: Spanish (Spain) (https://app.transifex.com/python-doc/"
"teams/5390/es_ES/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es_ES\n"
"Plural-Forms: nplurals=3; plural=n == 1 ? 0 : n != 0 && n % 1000000 == 0 ? "
"1 : 2;\n"

#: ../../library/asyncio-runner.rst:6
msgid "Runners"
msgstr "Corredores"

#: ../../library/asyncio-runner.rst:8
msgid "**Source code:** :source:`Lib/asyncio/runners.py`"
msgstr "**Código fuente:** :source:`Lib/asyncio/runners.py`"

#: ../../library/asyncio-runner.rst:11
msgid ""
"This section outlines high-level asyncio primitives to run asyncio code."
msgstr ""
"Esta sección describe las primitivas asyncio de alto nivel para ejecutar "
"código asyncio."

#: ../../library/asyncio-runner.rst:13
msgid ""
"They are built on top of an :ref:`event loop <asyncio-event-loop>` with the "
"aim to simplify async code usage for common wide-spread scenarios."
msgstr ""
"Están construidos sobre un :ref:`event loop <asyncio-event-loop>` con el "
"objetivo de simplificar el uso de código asíncrono para escenarios comunes "
"de gran difusión."

#: ../../library/asyncio-runner.rst:23
msgid "Running an asyncio Program"
msgstr "Ejecutar un programa asyncio"

#: ../../library/asyncio-runner.rst:27
msgid "Execute the :term:`coroutine` *coro* and return the result."
msgstr "Ejecuta la :term:`coroutine` *coro* y devuelve el resultado."

#: ../../library/asyncio-runner.rst:29
msgid ""
"This function runs the passed coroutine, taking care of managing the asyncio "
"event loop, *finalizing asynchronous generators*, and closing the executor."
msgstr ""
"Esta función ejecuta la corrutina pasada, encargándose de gestionar el bucle "
"de eventos asíncronos, *finalizing asynchronous generators*, y cierra el "
"ejecutor."

#: ../../library/asyncio-runner.rst:33 ../../library/asyncio-runner.rst:113
msgid ""
"This function cannot be called when another asyncio event loop is running in "
"the same thread."
msgstr ""
"Esta función no se puede llamar cuando se está ejecutando otro bucle de "
"eventos asyncio en el mismo hilo."

#: ../../library/asyncio-runner.rst:36 ../../library/asyncio-runner.rst:83
msgid ""
"If *debug* is ``True``, the event loop will be run in debug mode. ``False`` "
"disables debug mode explicitly. ``None`` is used to respect the global :ref:"
"`asyncio-debug-mode` settings."
msgstr ""
"Si *debug* es ``True``, el bucle de eventos se ejecutará en modo debug. "
"``False`` desactiva el modo debug explícitamente. ``None`` se utiliza para "
"respetar la configuración global de :ref:`asyncio-debug-mode`."

#: ../../library/asyncio-runner.rst:40
msgid ""
"If *loop_factory* is not ``None``, it is used to create a new event loop; "
"otherwise :func:`asyncio.new_event_loop` is used. The loop is closed at the "
"end. This function should be used as a main entry point for asyncio "
"programs, and should ideally only be called once. It is recommended to use "
"*loop_factory* to configure the event loop instead of policies."
msgstr ""
"Si *loop_factory* no es ``None``, se utiliza para crear un nuevo bucle de "
"eventos; en caso contrario, se utiliza :func:`asyncio.new_event_loop`. El "
"bucle se cierra al final. Esta función debería usarse como punto de entrada "
"principal para programas asyncio, e idealmente sólo debería llamarse una "
"vez. Se recomienda usar *loop_factory* para configurar el bucle de eventos "
"en lugar de policies."

#: ../../library/asyncio-runner.rst:46
msgid ""
"The executor is given a timeout duration of 5 minutes to shutdown. If the "
"executor hasn't finished within that duration, a warning is emitted and the "
"executor is closed."
msgstr ""
"Al ejecutor se le da un tiempo de espera de 5 minutos para apagarse. Si el "
"ejecutor no ha terminado en ese tiempo, se emite una advertencia y se cierra "
"el ejecutor."

#: ../../library/asyncio-runner.rst:50
msgid "Example::"
msgstr "Ejemplo::"

#: ../../library/asyncio-runner.rst:52
msgid ""
"async def main():\n"
"    await asyncio.sleep(1)\n"
"    print('hello')\n"
"\n"
"asyncio.run(main())"
msgstr ""
"async def main():\n"
"    await asyncio.sleep(1)\n"
"    print('hello')\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-runner.rst:60
msgid "Updated to use :meth:`loop.shutdown_default_executor`."
msgstr "Actualizado para utilizar :meth:`loop.shutdown_default_executor`."

#: ../../library/asyncio-runner.rst:65
msgid ""
"*debug* is ``None`` by default to respect the global debug mode settings."
msgstr ""
"*debug* es ``None`` por defecto para respetar la configuración del modo de "
"depuración global."

#: ../../library/asyncio-runner.rst:69
msgid "Added *loop_factory* parameter."
msgstr "Añadido el parámetro *loop_factory*."

#: ../../library/asyncio-runner.rst:73
msgid "Runner context manager"
msgstr "Gestor de contexto del corredor"

#: ../../library/asyncio-runner.rst:77
msgid ""
"A context manager that simplifies *multiple* async function calls in the "
"same context."
msgstr ""
"Un gestor de contexto que simplifica *multiple* llamadas a funciones "
"asíncronas en el mismo contexto."

#: ../../library/asyncio-runner.rst:80
msgid ""
"Sometimes several top-level async functions should be called in the same :"
"ref:`event loop <asyncio-event-loop>` and :class:`contextvars.Context`."
msgstr ""
"A veces es necesario llamar a varias funciones asíncronas de nivel superior "
"en el mismo bucle :ref:`event <asyncio-event-loop>` y :class:`contextvars."
"Context`."

#: ../../library/asyncio-runner.rst:87
msgid ""
"*loop_factory* could be used for overriding the loop creation. It is the "
"responsibility of the *loop_factory* to set the created loop as the current "
"one. By default :func:`asyncio.new_event_loop` is used and set as current "
"event loop with :func:`asyncio.set_event_loop` if *loop_factory* is ``None``."
msgstr ""
"*loop_factory* puede utilizarse para anular la creación del bucle. Es "
"responsabilidad de *loop_factory* establecer el bucle creado como actual. "
"Por defecto se utiliza :func:`asyncio.new_event_loop` y se establece como "
"bucle de eventos actual con :func:`asyncio.set_event_loop` si *loop_factory* "
"es ``None``."

#: ../../library/asyncio-runner.rst:92
msgid ""
"Basically, :func:`asyncio.run` example can be rewritten with the runner "
"usage::"
msgstr ""
"Básicamente, el ejemplo :func:`asyncio.run` se puede reescribir con el uso "
"del corredor::"

#: ../../library/asyncio-runner.rst:94
msgid ""
"async def main():\n"
"    await asyncio.sleep(1)\n"
"    print('hello')\n"
"\n"
"with asyncio.Runner() as runner:\n"
"    runner.run(main())"
msgstr ""
"async def main():\n"
"    await asyncio.sleep(1)\n"
"    print('hello')\n"
"\n"
"with asyncio.Runner() as runner:\n"
"    runner.run(main())"

#: ../../library/asyncio-runner.rst:105
msgid "Run a :term:`coroutine <coroutine>` *coro* in the embedded loop."
msgstr ""
"Ejecuta una :term:`coroutine <coroutine>` *coro* en el bucle incrustado."

#: ../../library/asyncio-runner.rst:107
msgid "Return the coroutine's result or raise its exception."
msgstr "Devuelve el resultado de la corrutina o lanza su excepción."

#: ../../library/asyncio-runner.rst:109
msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the *coro* to run in. The runner's default "
"context is used if ``None``."
msgstr ""
"Un argumento opcional *context* de sólo palabra clave permite especificar "
"un :class:`contextvars.Context` personalizado para que se ejecute el *coro*. "
"El contexto por defecto del corredor se utiliza si ``None``."

#: ../../library/asyncio-runner.rst:118
msgid "Close the runner."
msgstr "Cierra el corredor."

#: ../../library/asyncio-runner.rst:120
msgid ""
"Finalize asynchronous generators, shutdown default executor, close the event "
"loop and release embedded :class:`contextvars.Context`."
msgstr ""
"Finaliza los generadores asíncronos, apaga el ejecutor por defecto, cierra "
"el bucle de eventos y libera :class:`contextvars.Context`."

#: ../../library/asyncio-runner.rst:125
msgid "Return the event loop associated with the runner instance."
msgstr "Devuelve el bucle de eventos asociado a la instancia del corredor."

#: ../../library/asyncio-runner.rst:129
msgid ""
":class:`Runner` uses the lazy initialization strategy, its constructor "
"doesn't initialize underlying low-level structures."
msgstr ""
":class:`Runner` utiliza la estrategia de inicialización perezosa, su "
"constructor no inicializa las estructuras de bajo nivel subyacentes."

#: ../../library/asyncio-runner.rst:132
msgid ""
"Embedded *loop* and *context* are created at the :keyword:`with` body "
"entering or the first call of :meth:`run` or :meth:`get_loop`."
msgstr ""
"El *loop* y el *context* incrustados se crean al entrar en el cuerpo de :"
"keyword:`with` o en la primera llamada de :meth:`run` o :meth:`get_loop`."

#: ../../library/asyncio-runner.rst:137
msgid "Handling Keyboard Interruption"
msgstr "Interrupción del teclado"

#: ../../library/asyncio-runner.rst:141
msgid ""
"When :const:`signal.SIGINT` is raised by :kbd:`Ctrl-C`, :exc:"
"`KeyboardInterrupt` exception is raised in the main thread by default. "
"However this doesn't work with :mod:`asyncio` because it can interrupt "
"asyncio internals and can hang the program from exiting."
msgstr ""
"Cuando :const:`signal.SIGINT` es lanzado por :kbd:`Ctrl-C`, se lanza la "
"excepción :exc:`KeyboardInterrupt` en el hilo principal por defecto. Sin "
"embargo, esto no funciona con :mod:`asyncio` porque puede interrumpir las "
"funciones internas de asyncio y puede bloquear la salida del programa."

#: ../../library/asyncio-runner.rst:146
msgid ""
"To mitigate this issue, :mod:`asyncio` handles :const:`signal.SIGINT` as "
"follows:"
msgstr ""
"Para mitigar este problema, :mod:`asyncio` gestiona :const:`signal.SIGINT` "
"del siguiente modo:"

#: ../../library/asyncio-runner.rst:148
msgid ""
":meth:`asyncio.Runner.run` installs a custom :const:`signal.SIGINT` handler "
"before any user code is executed and removes it when exiting from the "
"function."
msgstr ""
":meth:`asyncio.Runner.run` instala un manejador personalizado :const:`signal."
"SIGINT` antes de que se ejecute cualquier código de usuario y lo elimina al "
"salir de la función."

#: ../../library/asyncio-runner.rst:150
msgid ""
"The :class:`~asyncio.Runner` creates the main task for the passed coroutine "
"for its execution."
msgstr ""
"El :class:`~asyncio.Runner` crea la tarea principal para la corrutina pasada "
"para su ejecución."

#: ../../library/asyncio-runner.rst:152
msgid ""
"When :const:`signal.SIGINT` is raised by :kbd:`Ctrl-C`, the custom signal "
"handler cancels the main task by calling :meth:`asyncio.Task.cancel` which "
"raises :exc:`asyncio.CancelledError` inside the main task.  This causes the "
"Python stack to unwind, ``try/except`` and ``try/finally`` blocks can be "
"used for resource cleanup.  After the main task is cancelled, :meth:`asyncio."
"Runner.run` raises :exc:`KeyboardInterrupt`."
msgstr ""
"Cuando :const:`signal.SIGINT` es levantado por :kbd:`Ctrl-C`, el manejador "
"de señales personalizado cancela la tarea principal llamando a :meth:"
"`asyncio.Task.cancel` que levanta :exc:`asyncio.CancelledError` dentro de la "
"tarea principal.  Esto hace que la pila de Python se desenrolle, los bloques "
"``try/except`` y ``try/finally`` pueden ser utilizados para la limpieza de "
"recursos.  Una vez cancelada la tarea principal, :meth:`asyncio.Runner.run` "
"llama a :exc:`KeyboardInterrupt`."

#: ../../library/asyncio-runner.rst:158
msgid ""
"A user could write a tight loop which cannot be interrupted by :meth:"
"`asyncio.Task.cancel`, in which case the second following :kbd:`Ctrl-C` "
"immediately raises the :exc:`KeyboardInterrupt` without cancelling the main "
"task."
msgstr ""
"Un usuario podría escribir un bucle cerrado que no se pueda interrumpir por :"
"meth:`asyncio.Task.cancel`, en cuyo caso el segundo que sigue a :kbd:`Ctrl-"
"C` lanza inmediatamente :exc:`KeyboardInterrupt` sin cancelar la tarea "
"principal."
