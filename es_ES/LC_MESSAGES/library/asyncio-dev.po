# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-25 14:15+0000\n"
"PO-Revision-Date: 2025-09-16 00:00+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Spanish (Spain) (https://app.transifex.com/python-doc/"
"teams/5390/es_ES/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es_ES\n"
"Plural-Forms: nplurals=3; plural=n == 1 ? 0 : n != 0 && n % 1000000 == 0 ? "
"1 : 2;\n"

#: ../../library/asyncio-dev.rst:7
msgid "Developing with asyncio"
msgstr "Desarrollo con asyncio"

#: ../../library/asyncio-dev.rst:9
msgid ""
"Asynchronous programming is different from classic \"sequential\" "
"programming."
msgstr ""
"La programación asíncrona es diferente de la programación \"secuencial\" "
"clásica."

#: ../../library/asyncio-dev.rst:12
msgid ""
"This page lists common mistakes and traps and explains how to avoid them."
msgstr ""
"Esta página enumera los errores y trampas más comunes y explica cómo "
"evitarlos."

#: ../../library/asyncio-dev.rst:19
msgid "Debug Mode"
msgstr "Modo depuración"

#: ../../library/asyncio-dev.rst:21
msgid ""
"By default asyncio runs in production mode.  In order to ease the "
"development asyncio has a *debug mode*."
msgstr ""
"Por defecto, asyncio se ejecuta en modo de producción.  Para facilitar el "
"desarrollo asyncio tiene un *modo depuración*."

#: ../../library/asyncio-dev.rst:24
msgid "There are several ways to enable asyncio debug mode:"
msgstr "Hay varias maneras de activar el modo de depuración asyncio:"

#: ../../library/asyncio-dev.rst:26
msgid "Setting the :envvar:`PYTHONASYNCIODEBUG` environment variable to ``1``."
msgstr ""
"Establecer la variable de entorno :envvar:`PYTHONASYNCIODEBUG` en ``1``."

#: ../../library/asyncio-dev.rst:28
msgid "Using the :ref:`Python Development Mode <devmode>`."
msgstr "Usar el :ref:`Python Development Mode <devmode>`."

#: ../../library/asyncio-dev.rst:30
msgid "Passing ``debug=True`` to :func:`asyncio.run`."
msgstr "Pasando ``debug=True`` a :func:`asyncio.run`."

#: ../../library/asyncio-dev.rst:32
msgid "Calling :meth:`loop.set_debug`."
msgstr "Llamando a :meth:`loop.set_debug`."

#: ../../library/asyncio-dev.rst:34
msgid "In addition to enabling the debug mode, consider also:"
msgstr "Además de activar el modo de depuración, considere también:"

#: ../../library/asyncio-dev.rst:36
msgid ""
"setting the log level of the :ref:`asyncio logger <asyncio-logger>` to :py:"
"const:`logging.DEBUG`, for example the following snippet of code can be run "
"at startup of the application::"
msgstr ""
"estableciendo el nivel de registro del :ref:`asyncio logger <asyncio-"
"logger>` a :py:const:`logging.DEBUG`, por ejemplo el siguiente fragmento de "
"código se puede ejecutar al inicio de la aplicación::"

#: ../../library/asyncio-dev.rst:40
msgid "logging.basicConfig(level=logging.DEBUG)"
msgstr "logging.basicConfig(level=logging.DEBUG)"

#: ../../library/asyncio-dev.rst:42
msgid ""
"configuring the :mod:`warnings` module to display :exc:`ResourceWarning` "
"warnings.  One way of doing that is by using the :option:`-W` ``default`` "
"command line option."
msgstr ""
"configurar el módulo :mod:`warnings` para que muestre las advertencias de :"
"exc:`ResourceWarning`.  Una forma de hacerlo es utilizando la opción de "
"línea de comandos :option:`-W` ``default`` ."

#: ../../library/asyncio-dev.rst:47
msgid "When the debug mode is enabled:"
msgstr "Cuando el modo depuración está habilitado:"

#: ../../library/asyncio-dev.rst:49
msgid ""
"Many non-threadsafe asyncio APIs (such as :meth:`loop.call_soon` and :meth:"
"`loop.call_at` methods) raise an exception if they are called from a wrong "
"thread."
msgstr ""
"Muchas API asyncio no seguras para subprocesos (como :meth:`loop.call_soon` "
"y los métodos :meth:`loop.call_at` ) generan una excepción si se llaman "
"desde un hilo incorrecto."

#: ../../library/asyncio-dev.rst:53
msgid ""
"The execution time of the I/O selector is logged if it takes too long to "
"perform an I/O operation."
msgstr ""
"El tiempo de ejecución del selector de E/S se registra si lleva demasiado "
"tiempo realizar una operación de E/S."

#: ../../library/asyncio-dev.rst:56
msgid ""
"Callbacks taking longer than 100 milliseconds are logged.  The :attr:`loop."
"slow_callback_duration` attribute can be used to set the minimum execution "
"duration in seconds that is considered \"slow\"."
msgstr ""
"Se registran las devoluciones de llamada que tardan más de 100 milisegundos. "
"El atributo  :attr:`loop.slow_callback_duration` se puede usar para "
"establecer la duración mínima de ejecución en segundos que se considera "
"\"lenta\"."

#: ../../library/asyncio-dev.rst:64
msgid "Concurrency and Multithreading"
msgstr "Concurrencia y Subprocesos Múltiples"

#: ../../library/asyncio-dev.rst:66
msgid ""
"An event loop runs in a thread (typically the main thread) and executes all "
"callbacks and Tasks in its thread.  While a Task is running in the event "
"loop, no other Tasks can run in the same thread.  When a Task executes an "
"``await`` expression, the running Task gets suspended, and the event loop "
"executes the next Task."
msgstr ""
"Un bucle de actos se ejecuta en un subproceso (normalmente el subproceso "
"principal) y ejecuta todas las devoluciones de llamada y tareas en su "
"subproceso. Mientras una tarea se ejecuta en el bucle de actos, no se pueden "
"ejecutar otras tareas en el mismo subproceso. Cuando una Tarea ejecuta una "
"expresión ``await`` , la Tarea en ejecución se suspende y el bucle de actos "
"ejecuta la siguiente Tarea."

#: ../../library/asyncio-dev.rst:72
msgid ""
"To schedule a :term:`callback` from another OS thread, the :meth:`loop."
"call_soon_threadsafe` method should be used. Example::"
msgstr ""
"Para programar un :term:`callback` desde otro subproceso del sistema "
"operativo, se debe usar el método :meth:`loop.call_soon_threadsafe` . "
"Ejemplo::"

#: ../../library/asyncio-dev.rst:75
msgid "loop.call_soon_threadsafe(callback, *args)"
msgstr "loop.call_soon_threadsafe(callback, *args)"

#: ../../library/asyncio-dev.rst:77
msgid ""
"Almost all asyncio objects are not thread safe, which is typically not a "
"problem unless there is code that works with them from outside of a Task or "
"a callback.  If there's a need for such code to call a low-level asyncio "
"API, the :meth:`loop.call_soon_threadsafe` method should be used, e.g.::"
msgstr ""
"Casi todos los objetos asyncio no son subprocesos seguros, lo cual no suele "
"ser un problema a menos que haya código que trabaje con ellos desde fuera de "
"una Tarea o una devolución de llamada. Si existe la necesidad de que dicho "
"código llame a una API asyncio de bajo nivel, se debe utilizar el método:"
"meth:`loop.call_soon_threadsafe`, por ejemplo::"

#: ../../library/asyncio-dev.rst:83
msgid "loop.call_soon_threadsafe(fut.cancel)"
msgstr "loop.call_soon_threadsafe(fut.cancel)"

#: ../../library/asyncio-dev.rst:85
msgid ""
"To schedule a coroutine object from a different OS thread, the :func:"
"`run_coroutine_threadsafe` function should be used. It returns a :class:"
"`concurrent.futures.Future` to access the result::"
msgstr ""
"Para programar un objeto de rutina desde un subproceso de SO diferente, se "
"debe usar la función :func:`run_coroutine_threadsafe` . Devuelve una :class:"
"`concurrent.futures.Future` para acceder al resultado::"

#: ../../library/asyncio-dev.rst:89
msgid ""
"async def coro_func():\n"
"     return await asyncio.sleep(1, 42)\n"
"\n"
"# Later in another OS thread:\n"
"\n"
"future = asyncio.run_coroutine_threadsafe(coro_func(), loop)\n"
"# Wait for the result:\n"
"result = future.result()"
msgstr ""
"async def coro_func():\n"
"     return await asyncio.sleep(1, 42)\n"
"\n"
"# Más tarde en otro hilo del sistema operativo:\n"
"\n"
"future = asyncio.run_coroutine_threadsafe(coro_func(), loop)\n"
"# Esperar resultado:\n"
"result = future.result()"

#: ../../library/asyncio-dev.rst:98
msgid "To handle signals the event loop must be run in the main thread."
msgstr ""
"Para manejar señales, el bucle de sucesos debe ejecutarse en el hilo "
"principal."

#: ../../library/asyncio-dev.rst:101
msgid ""
"The :meth:`loop.run_in_executor` method can be used with a :class:"
"`concurrent.futures.ThreadPoolExecutor` or :class:`~concurrent.futures."
"InterpreterPoolExecutor` to execute blocking code in a different OS thread "
"without blocking the OS thread that the event loop runs in."
msgstr ""

#: ../../library/asyncio-dev.rst:107
msgid ""
"There is currently no way to schedule coroutines or callbacks directly from "
"a different process (such as one started with :mod:`multiprocessing`). The :"
"ref:`asyncio-event-loop-methods` section lists APIs that can read from pipes "
"and watch file descriptors without blocking the event loop. In addition, "
"asyncio's :ref:`Subprocess <asyncio-subprocess>` APIs provide a way to start "
"a process and communicate with it from the event loop. Lastly, the "
"aforementioned :meth:`loop.run_in_executor` method can also be used with a :"
"class:`concurrent.futures.ProcessPoolExecutor` to execute code in a "
"different process."
msgstr ""
"Actualmente no hay forma de programar coroutines o callbacks directamente "
"desde un proceso diferente (como uno iniciado con :mod:`multiprocessing`). "
"La sección :ref:`asyncio-event-loop-methods` enumera APIs que pueden leer "
"desde tuberías y ver descriptores de fichero sin bloquear el bucle de "
"eventos. Además, las APIs :ref:`Subprocess <asyncio-subprocess>` de asyncio "
"proporcionan una forma de iniciar un proceso y comunicarse con él desde el "
"bucle de eventos. Por último, el método :meth:`loop.run_in_executor` "
"mencionado anteriormente también se puede utilizar con un :class:`concurrent."
"futures.ProcessPoolExecutor` para ejecutar código en un proceso diferente."

#: ../../library/asyncio-dev.rst:121
msgid "Running Blocking Code"
msgstr "Ejecutar código de bloqueo"

#: ../../library/asyncio-dev.rst:123
msgid ""
"Blocking (CPU-bound) code should not be called directly.  For example, if a "
"function performs a CPU-intensive calculation for 1 second, all concurrent "
"asyncio Tasks and IO operations would be delayed by 1 second."
msgstr ""
"El código bloqueante (limitado por la CPU) no debe llamarse directamente.  "
"Por ejemplo, si una función realiza un cálculo intensivo de CPU durante 1 "
"segundo, todas las Tareas asyncio concurrentes y las operaciones IO se "
"retrasarían 1 segundo."

#: ../../library/asyncio-dev.rst:128
msgid ""
"An executor can be used to run a task in a different thread, including in a "
"different interpreter, or even in a different process to avoid blocking the "
"OS thread with the event loop.  See the :meth:`loop.run_in_executor` method "
"for more details."
msgstr ""

#: ../../library/asyncio-dev.rst:138
msgid "Logging"
msgstr "Registro"

#: ../../library/asyncio-dev.rst:140
msgid ""
"asyncio uses the :mod:`logging` module and all logging is performed via the "
"``\"asyncio\"`` logger."
msgstr ""
"asyncio utiliza el módulo :mod:`logging` y todo el registro se realiza a "
"través del registrador ``\"asyncio\"``."

#: ../../library/asyncio-dev.rst:143
msgid ""
"The default log level is :py:const:`logging.INFO`, which can be easily "
"adjusted::"
msgstr ""
"El nivel de registro por defecto es :py:const:`logging.INFO`, que puede "
"ajustarse fácilmente::"

#: ../../library/asyncio-dev.rst:146
msgid "logging.getLogger(\"asyncio\").setLevel(logging.WARNING)"
msgstr "logging.getLogger(\"asyncio\").setLevel(logging.WARNING)"

#: ../../library/asyncio-dev.rst:149
msgid ""
"Network logging can block the event loop. It is recommended to use a "
"separate thread for handling logs or use non-blocking IO. For example, see :"
"ref:`blocking-handlers`."
msgstr ""
"El registro en red puede bloquear el bucle de actos. Se recomienda utilizar "
"un hilo separado para manejar los registros o utilizar IO no bloqueante. Por "
"ejemplo, consultar :ref:`blocking-handlers`."

#: ../../library/asyncio-dev.rst:157
msgid "Detect never-awaited coroutines"
msgstr "Detectar corrutinas nunca esperadas"

#: ../../library/asyncio-dev.rst:159
msgid ""
"When a coroutine function is called, but not awaited (e.g. ``coro()`` "
"instead of ``await coro()``) or the coroutine is not scheduled with :meth:"
"`asyncio.create_task`, asyncio will emit a :exc:`RuntimeWarning`::"
msgstr ""
"Cuando se llama a una función de corrutina, pero no se espera (por ejemplo, "
"``coro()`` en lugar de ``await coro()``) o la corrutina no está programada "
"con :meth:`asyncio.create_task`, asyncio emitirá un :exc:`RuntimeWarning`::"

#: ../../library/asyncio-dev.rst:164
msgid ""
"import asyncio\n"
"\n"
"async def test():\n"
"    print(\"never scheduled\")\n"
"\n"
"async def main():\n"
"    test()\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"async def test():\n"
"    print(\"never scheduled\")\n"
"\n"
"async def main():\n"
"    test()\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-dev.rst:174 ../../library/asyncio-dev.rst:219
msgid "Output::"
msgstr "Salida::"

#: ../../library/asyncio-dev.rst:176
msgid ""
"test.py:7: RuntimeWarning: coroutine 'test' was never awaited\n"
"  test()"
msgstr ""
"test.py:7: RuntimeWarning: coroutine 'test' was never awaited\n"
"  test()"

#: ../../library/asyncio-dev.rst:179 ../../library/asyncio-dev.rst:235
msgid "Output in debug mode::"
msgstr "Salida en modo depuración::"

#: ../../library/asyncio-dev.rst:181
msgid ""
"test.py:7: RuntimeWarning: coroutine 'test' was never awaited\n"
"Coroutine created at (most recent call last)\n"
"  File \"../t.py\", line 9, in <module>\n"
"    asyncio.run(main(), debug=True)\n"
"\n"
"  < .. >\n"
"\n"
"  File \"../t.py\", line 7, in main\n"
"    test()\n"
"  test()"
msgstr ""
"test.py:7: RuntimeWarning: coroutine 'test' was never awaited\n"
"Coroutine created at (most recent call last)\n"
"  File \"../t.py\", line 9, in <module>\n"
"    asyncio.run(main(), debug=True)\n"
"\n"
"  < .. >\n"
"\n"
"  File \"../t.py\", line 7, in main\n"
"    test()\n"
"  test()"

#: ../../library/asyncio-dev.rst:192
msgid ""
"The usual fix is to either await the coroutine or call the :meth:`asyncio."
"create_task` function::"
msgstr ""
"La solución habitual es esperar a la corrutina o llamar a la función :meth:"
"`asyncio.create_task`::"

#: ../../library/asyncio-dev.rst:195
msgid ""
"async def main():\n"
"    await test()"
msgstr ""
"async def main():\n"
"    await test()"

#: ../../library/asyncio-dev.rst:200
msgid "Detect never-retrieved exceptions"
msgstr "Detectar excepciones nunca recuperadas"

#: ../../library/asyncio-dev.rst:202
msgid ""
"If a :meth:`Future.set_exception` is called but the Future object is never "
"awaited on, the exception would never be propagated to the user code.  In "
"this case, asyncio would emit a log message when the Future object is "
"garbage collected."
msgstr ""
"Si se llama a :meth:`Future.set_exception` pero nunca se espera al objeto "
"Future, la excepción nunca se propagaría al código de usuario.  En este "
"caso, asyncio emitiría un mensaje de registro cuando se recogiera el objeto "
"Future."

#: ../../library/asyncio-dev.rst:207
msgid "Example of an unhandled exception::"
msgstr "Ejemplo de excepción no controlada::"

#: ../../library/asyncio-dev.rst:209
msgid ""
"import asyncio\n"
"\n"
"async def bug():\n"
"    raise Exception(\"not consumed\")\n"
"\n"
"async def main():\n"
"    asyncio.create_task(bug())\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"async def bug():\n"
"    raise Exception(\"not consumed\")\n"
"\n"
"async def main():\n"
"    asyncio.create_task(bug())\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-dev.rst:221
msgid ""
"Task exception was never retrieved\n"
"future: <Task finished coro=<bug() done, defined at test.py:3>\n"
"  exception=Exception('not consumed')>\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"test.py\", line 4, in bug\n"
"    raise Exception(\"not consumed\")\n"
"Exception: not consumed"
msgstr ""
"Task exception was never retrieved\n"
"future: <Task finished coro=<bug() done, defined at test.py:3>\n"
"  exception=Exception('not consumed')>\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"test.py\", line 4, in bug\n"
"    raise Exception(\"not consumed\")\n"
"Exception: not consumed"

#: ../../library/asyncio-dev.rst:230
msgid ""
":ref:`Enable the debug mode <asyncio-debug-mode>` to get the traceback where "
"the task was created::"
msgstr ""
":ref:`Enable the debug mode  <asyncio-debug-mode>` para obtener el rastreo "
"donde se creó la tarea::"

#: ../../library/asyncio-dev.rst:233
msgid "asyncio.run(main(), debug=True)"
msgstr "asyncio.run(main(), debug=True)"

#: ../../library/asyncio-dev.rst:237
msgid ""
"Task exception was never retrieved\n"
"future: <Task finished coro=<bug() done, defined at test.py:3>\n"
"    exception=Exception('not consumed') created at asyncio/tasks.py:321>\n"
"\n"
"source_traceback: Object created at (most recent call last):\n"
"  File \"../t.py\", line 9, in <module>\n"
"    asyncio.run(main(), debug=True)\n"
"\n"
"< .. >\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"../t.py\", line 4, in bug\n"
"    raise Exception(\"not consumed\")\n"
"Exception: not consumed"
msgstr ""
"Task exception was never retrieved\n"
"future: <Task finished coro=<bug() done, defined at test.py:3>\n"
"    exception=Exception('not consumed') created at asyncio/tasks.py:321>\n"
"\n"
"source_traceback: Object created at (most recent call last):\n"
"  File \"../t.py\", line 9, in <module>\n"
"    asyncio.run(main(), debug=True)\n"
"\n"
"< .. >\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"../t.py\", line 4, in bug\n"
"    raise Exception(\"not consumed\")\n"
"Exception: not consumed"
