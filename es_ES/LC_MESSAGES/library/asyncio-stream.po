# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-23 14:56+0000\n"
"PO-Revision-Date: 2025-09-15 01:03+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Spanish (Spain) (https://app.transifex.com/python-doc/"
"teams/5390/es_ES/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es_ES\n"
"Plural-Forms: nplurals=3; plural=n == 1 ? 0 : n != 0 && n % 1000000 == 0 ? "
"1 : 2;\n"

#: ../../library/asyncio-stream.rst:7
msgid "Streams"
msgstr "Transmisiones"

#: ../../library/asyncio-stream.rst:9
msgid "**Source code:** :source:`Lib/asyncio/streams.py`"
msgstr "**Código fuente:** :source:`Lib/asyncio/streams.py`"

#: ../../library/asyncio-stream.rst:13
msgid ""
"Streams are high-level async/await-ready primitives to work with network "
"connections.  Streams allow sending and receiving data without using "
"callbacks or low-level protocols and transports."
msgstr ""
"Los streams son primitivas async/await-ready de alto nivel para trabajar con "
"conexiones de red.  Las secuencias permiten enviar y recibir datos sin "
"utilizar retrollamadas ni protocolos y transportes de bajo nivel."

#: ../../library/asyncio-stream.rst:19
msgid "Here is an example of a TCP echo client written using asyncio streams::"
msgstr ""
"Aquí hay un ejemplo de un cliente de eco TCP escrito usando streams asyncio::"

#: ../../library/asyncio-stream.rst:22 ../../library/asyncio-stream.rst:440
msgid ""
"import asyncio\n"
"\n"
"async def tcp_echo_client(message):\n"
"    reader, writer = await asyncio.open_connection(\n"
"        '127.0.0.1', 8888)\n"
"\n"
"    print(f'Send: {message!r}')\n"
"    writer.write(message.encode())\n"
"    await writer.drain()\n"
"\n"
"    data = await reader.read(100)\n"
"    print(f'Received: {data.decode()!r}')\n"
"\n"
"    print('Close the connection')\n"
"    writer.close()\n"
"    await writer.wait_closed()\n"
"\n"
"asyncio.run(tcp_echo_client('Hello World!'))"
msgstr ""

#: ../../library/asyncio-stream.rst:42
msgid "See also the `Examples`_ section below."
msgstr "Ver también, más abajo, la sección `Examples`_."

#: ../../library/asyncio-stream.rst:46
msgid "Stream Functions"
msgstr "Funciones de flujo"

#: ../../library/asyncio-stream.rst:47
msgid ""
"The following top-level asyncio functions can be used to create and work "
"with streams:"
msgstr ""
"Las siguientes funciones asyncio de nivel superior se pueden utilizar para "
"crear y trabajar con flujos:"

#: ../../library/asyncio-stream.rst:59
msgid ""
"Establish a network connection and return a pair of ``(reader, writer)`` "
"objects."
msgstr ""
"Establece una conexión de red y devuelve un par de objetos ``(reader, "
"writer)``."

#: ../../library/asyncio-stream.rst:62
msgid ""
"The returned *reader* and *writer* objects are instances of :class:"
"`StreamReader` and :class:`StreamWriter` classes."
msgstr ""
"Los objetos *reader* y *writer* devueltos son instancias de las clases :"
"class:`StreamReader` y :class:`StreamWriter`."

#: ../../library/asyncio-stream.rst:65 ../../library/asyncio-stream.rst:112
msgid ""
"*limit* determines the buffer size limit used by the returned :class:"
"`StreamReader` instance.  By default the *limit* is set to 64 KiB."
msgstr ""
"*limit* determina el límite del tamaño del búfer utilizado por la instancia :"
"class:`StreamReader` devuelta.  Por defecto, *limit* está fijado en 64 KiB."

#: ../../library/asyncio-stream.rst:69
msgid ""
"The rest of the arguments are passed directly to :meth:`loop."
"create_connection`."
msgstr ""
"El resto de los argumentos se pasan directamente a :meth:`loop."
"create_connection`."

#: ../../library/asyncio-stream.rst:74 ../../library/asyncio-stream.rst:154
msgid ""
"The *sock* argument transfers ownership of the socket to the :class:"
"`StreamWriter` created. To close the socket, call its :meth:`~asyncio."
"StreamWriter.close` method."
msgstr ""
"El argumento *sock* transfiere la propiedad del socket al :class:"
"`StreamWriter` creado. Para cerrar el socket, llama a su método :meth:"
"`~asyncio.StreamWriter.close`."

#: ../../library/asyncio-stream.rst:78
msgid "Added the *ssl_handshake_timeout* parameter."
msgstr "Añadido el parámetro *ssl_handshake_timeout*."

#: ../../library/asyncio-stream.rst:81
msgid "Added the *happy_eyeballs_delay* and *interleave* parameters."
msgstr "Añadidos los parámetros *happy_eyeballs_delay* e *interleave*."

#: ../../library/asyncio-stream.rst:84 ../../library/asyncio-stream.rst:128
#: ../../library/asyncio-stream.rst:164 ../../library/asyncio-stream.rst:199
msgid "Removed the *loop* parameter."
msgstr "Eliminado el parámetro *loop*."

#: ../../library/asyncio-stream.rst:87 ../../library/asyncio-stream.rst:131
#: ../../library/asyncio-stream.rst:167 ../../library/asyncio-stream.rst:202
#: ../../library/asyncio-stream.rst:407
msgid "Added the *ssl_shutdown_timeout* parameter."
msgstr ""

#: ../../library/asyncio-stream.rst:101
msgid "Start a socket server."
msgstr "Iniciar un servidor de sockets."

#: ../../library/asyncio-stream.rst:103
msgid ""
"The *client_connected_cb* callback is called whenever a new client "
"connection is established.  It receives a ``(reader, writer)`` pair as two "
"arguments, instances of the :class:`StreamReader` and :class:`StreamWriter` "
"classes."
msgstr ""
"La llamada de retorno *client_connected_cb* se ejecuta cada vez que se "
"establece una nueva conexión con un cliente.  Recibe un par ``(reader, "
"writer)`` como dos argumentos, instancias de las clases :class:"
"`StreamReader` y :class:`StreamWriter`."

#: ../../library/asyncio-stream.rst:108
msgid ""
"*client_connected_cb* can be a plain callable or a :ref:`coroutine function "
"<coroutine>`; if it is a coroutine function, it will be automatically "
"scheduled as a :class:`Task`."
msgstr ""
"*client_connected_cb* puede ser un callable plano o una función :ref:"
"`coroutine <coroutine>`; si es una función corrutina, se programará "
"automáticamente como :class:`Task`."

#: ../../library/asyncio-stream.rst:116
msgid ""
"The rest of the arguments are passed directly to :meth:`loop.create_server`."
msgstr ""
"El resto de los argumentos se pasan directamente a :meth:`loop."
"create_server`."

#: ../../library/asyncio-stream.rst:121 ../../library/asyncio-stream.rst:189
msgid ""
"The *sock* argument transfers ownership of the socket to the server created. "
"To close the socket, call the server's :meth:`~asyncio.Server.close` method."
msgstr ""
"El argumento *sock* transfiere la propiedad del socket al servidor creado. "
"Para cerrar el socket, llame al método :meth:`~asyncio.Server.close` del "
"servidor."

#: ../../library/asyncio-stream.rst:125
msgid "Added the *ssl_handshake_timeout* and *start_serving* parameters."
msgstr "Añadidos los parámetros *ssl_handshake_timeout* y *start_serving*."

#: ../../library/asyncio-stream.rst:134
msgid "Added the *keep_alive* parameter."
msgstr ""

#: ../../library/asyncio-stream.rst:139
msgid "Unix Sockets"
msgstr "Conexiones Unix"

#: ../../library/asyncio-stream.rst:145
msgid ""
"Establish a Unix socket connection and return a pair of ``(reader, writer)``."
msgstr ""
"Establece una conexión de socket Unix y devuelve un par de ``(reader, "
"writer)``."

#: ../../library/asyncio-stream.rst:148
msgid "Similar to :func:`open_connection` but operates on Unix sockets."
msgstr "Similar a :func:`open_connection` pero opera en sockets Unix."

#: ../../library/asyncio-stream.rst:150
msgid "See also the documentation of :meth:`loop.create_unix_connection`."
msgstr "Ver también la documentación de :meth:`loop.create_unix_connection`."

#: ../../library/asyncio-stream.rst:158 ../../library/asyncio-stream.rst:193
msgid "Availability"
msgstr ""

#: ../../library/asyncio-stream.rst:160
msgid ""
"Added the *ssl_handshake_timeout* parameter. The *path* parameter can now be "
"a :term:`path-like object`"
msgstr ""
"Añadido el parámetro *ssl_handshake_timeout*. El parámetro *path* ahora "
"puede ser un :term:`path-like object`."

#: ../../library/asyncio-stream.rst:177
msgid "Start a Unix socket server."
msgstr "Iniciar un servidor de sockets Unix."

#: ../../library/asyncio-stream.rst:179
msgid "Similar to :func:`start_server` but works with Unix sockets."
msgstr "Similar a :func:`start_server` pero funciona con sockets Unix."

#: ../../library/asyncio-stream.rst:181
msgid ""
"If *cleanup_socket* is true then the Unix socket will automatically be "
"removed from the filesystem when the server is closed, unless the socket has "
"been replaced after the server has been created."
msgstr ""

#: ../../library/asyncio-stream.rst:185
msgid "See also the documentation of :meth:`loop.create_unix_server`."
msgstr "Consulte también la documentación de :meth:`loop.create_unix_server`."

#: ../../library/asyncio-stream.rst:195
msgid ""
"Added the *ssl_handshake_timeout* and *start_serving* parameters. The *path* "
"parameter can now be a :term:`path-like object`."
msgstr ""
"Añadidos los parámetros *ssl_handshake_timeout* y *start_serving*. El "
"parámetro *path* ahora puede ser un objeto :term:`path-like object`."

#: ../../library/asyncio-stream.rst:205
msgid "Added the *cleanup_socket* parameter."
msgstr ""

#: ../../library/asyncio-stream.rst:210
msgid "StreamReader"
msgstr "StreamReader"

#: ../../library/asyncio-stream.rst:214
msgid ""
"Represents a reader object that provides APIs to read data from the IO "
"stream. As an :term:`asynchronous iterable`, the object supports the :"
"keyword:`async for` statement."
msgstr ""
"Representa un objeto lector que proporciona APIs para leer datos del flujo "
"IO. Como :term:`asynchronous iterable`, el objeto soporta la sentencia :"
"keyword:`async for`."

#: ../../library/asyncio-stream.rst:218
msgid ""
"It is not recommended to instantiate *StreamReader* objects directly; use :"
"func:`open_connection` and :func:`start_server` instead."
msgstr ""
"No se recomienda instanciar objetos *StreamReader* directamente; en su "
"lugar, usar :func:`open_connection` y :func:`start_server`."

#: ../../library/asyncio-stream.rst:224
msgid "Acknowledge the EOF."
msgstr ""

#: ../../library/asyncio-stream.rst:229
msgid "Read up to *n* bytes from the stream."
msgstr "Leer hasta *n* bytes del flujo."

#: ../../library/asyncio-stream.rst:231
msgid ""
"If *n* is not provided or set to ``-1``, read until EOF, then return all "
"read :class:`bytes`. If EOF was received and the internal buffer is empty, "
"return an empty ``bytes`` object."
msgstr ""
"Si *n* no se proporciona o se establece en ``-1``, lee hasta EOF, luego "
"devuelve todo lo leído :class:`bytes`. Si se recibió EOF y el buffer interno "
"está vacío, devuelve un objeto ``bytes`` vacío."

#: ../../library/asyncio-stream.rst:236
msgid "If *n* is ``0``, return an empty ``bytes`` object immediately."
msgstr "Si *n* es ``0``, devuelve inmediatamente un objeto ``bytes`` vacío."

#: ../../library/asyncio-stream.rst:238
msgid ""
"If *n* is positive, return at most *n* available ``bytes`` as soon as at "
"least 1 byte is available in the internal buffer. If EOF is received before "
"any byte is read, return an empty ``bytes`` object."
msgstr ""
"Si *n* es positivo, devuelve como máximo *n* ``bytes`` disponible tan pronto "
"como haya al menos 1 byte disponible en el buffer interno. Si se recibe EOF "
"antes de que se lea ningún byte, devuelve un objeto ``bytes`` vacío."

#: ../../library/asyncio-stream.rst:246
msgid ""
"Read one line, where \"line\" is a sequence of bytes ending with ``\\n``."
msgstr ""
"Leer una línea, donde \"line\" es una secuencia de bytes que termina en "
"``\\n``."

#: ../../library/asyncio-stream.rst:249
msgid ""
"If EOF is received and ``\\n`` was not found, the method returns partially "
"read data."
msgstr ""
"Si se recibe EOF y no se ha encontrado ``\\n``, el método devuelve datos "
"leídos parcialmente."

#: ../../library/asyncio-stream.rst:252
msgid ""
"If EOF is received and the internal buffer is empty, return an empty "
"``bytes`` object."
msgstr ""
"Si se recibe EOF y el búfer interno está vacío, devuelve un objeto ``bytes`` "
"vacío."

#: ../../library/asyncio-stream.rst:258
msgid "Read exactly *n* bytes."
msgstr "Leer exactamente *n* bytes."

#: ../../library/asyncio-stream.rst:260
msgid ""
"Raise an :exc:`IncompleteReadError` if EOF is reached before *n* can be "
"read.  Use the :attr:`IncompleteReadError.partial` attribute to get the "
"partially read data."
msgstr ""
"Lanza un :exc:`IncompleteReadError` si se alcanza EOF antes de que *n* pueda "
"ser leído.  Utilice el atributo :attr:`IncompleteReadError.partial` para "
"obtener los datos leídos parcialmente."

#: ../../library/asyncio-stream.rst:267
msgid "Read data from the stream until *separator* is found."
msgstr "Lee datos del flujo hasta que encuentra el *separador*."

#: ../../library/asyncio-stream.rst:269
msgid ""
"On success, the data and separator will be removed from the internal buffer "
"(consumed). Returned data will include the separator at the end."
msgstr ""
"En caso de éxito, los datos y el separador se eliminarán del búfer interno "
"(consumido). Los datos devueltos incluirán el separador al final."

#: ../../library/asyncio-stream.rst:273
msgid ""
"If the amount of data read exceeds the configured stream limit, a :exc:"
"`LimitOverrunError` exception is raised, and the data is left in the "
"internal buffer and can be read again."
msgstr ""
"Si la cantidad de datos leídos supera el límite de flujo configurado, se "
"lanza una excepción :exc:`LimitOverrunError`, y los datos se dejan en el "
"búfer interno y pueden volver a leerse."

#: ../../library/asyncio-stream.rst:277
msgid ""
"If EOF is reached before the complete separator is found, an :exc:"
"`IncompleteReadError` exception is raised, and the internal buffer is "
"reset.  The :attr:`IncompleteReadError.partial` attribute may contain a "
"portion of the separator."
msgstr ""
"Si se alcanza EOF antes de encontrar el separador completo, se lanza una "
"excepción :exc:`IncompleteReadError` y se reinicia el búfer interno.  El "
"atributo :attr:`IncompleteReadError.partial` puede contener una parte del "
"separador."

#: ../../library/asyncio-stream.rst:282
msgid ""
"The *separator* may also be a tuple of separators. In this case the return "
"value will be the shortest possible that has any separator as the suffix. "
"For the purposes of :exc:`LimitOverrunError`, the shortest possible "
"separator is considered to be the one that matched."
msgstr ""

#: ../../library/asyncio-stream.rst:292
msgid "The *separator* parameter may now be a :class:`tuple` of separators."
msgstr ""

#: ../../library/asyncio-stream.rst:297
msgid "Return ``True`` if the buffer is empty and :meth:`feed_eof` was called."
msgstr ""
"Devuelve ``True`` si el búfer está vacío y se ha llamado a :meth:`feed_eof`."

#: ../../library/asyncio-stream.rst:302
msgid "StreamWriter"
msgstr "StreamWriter"

#: ../../library/asyncio-stream.rst:306
msgid ""
"Represents a writer object that provides APIs to write data to the IO stream."
msgstr ""
"Representa un objeto escritor que proporciona APIs para escribir datos en el "
"flujo IO."

#: ../../library/asyncio-stream.rst:309
msgid ""
"It is not recommended to instantiate *StreamWriter* objects directly; use :"
"func:`open_connection` and :func:`start_server` instead."
msgstr ""
"No se recomienda instanciar objetos *StreamWriter* directamente; en su "
"lugar, usar :func:`open_connection` y :func:`start_server`."

#: ../../library/asyncio-stream.rst:315
msgid ""
"The method attempts to write the *data* to the underlying socket "
"immediately. If that fails, the data is queued in an internal write buffer "
"until it can be sent."
msgstr ""
"El método intenta escribir los *datos* en el socket subyacente "
"inmediatamente. Si falla, los datos se ponen en cola en un búfer de "
"escritura interno hasta que puedan enviarse."

#: ../../library/asyncio-stream.rst:319 ../../library/asyncio-stream.rst:334
msgid "The method should be used along with the ``drain()`` method::"
msgstr "El método debe utilizarse junto con el método ``drain()``::"

#: ../../library/asyncio-stream.rst:321
msgid ""
"stream.write(data)\n"
"await stream.drain()"
msgstr ""

#: ../../library/asyncio-stream.rst:325
msgid ""
"The *data* buffer should be a C contiguous one-dimensional :term:`bytes-like "
"object <bytes-like object>`."
msgstr ""

#: ../../library/asyncio-stream.rst:329
msgid ""
"The method writes a list (or any iterable) of bytes to the underlying socket "
"immediately. If that fails, the data is queued in an internal write buffer "
"until it can be sent."
msgstr ""
"El método escribe una lista (o cualquier iterable) de bytes al socket "
"subyacente inmediatamente. Si falla, los datos se ponen en cola en un búfer "
"de escritura interno hasta que se puedan enviar."

#: ../../library/asyncio-stream.rst:336
msgid ""
"stream.writelines(lines)\n"
"await stream.drain()"
msgstr ""

#: ../../library/asyncio-stream.rst:341
msgid "The method closes the stream and the underlying socket."
msgstr "El método cierra el flujo y el socket subyacente."

#: ../../library/asyncio-stream.rst:343
msgid ""
"The method should be used, though not mandatory, along with the "
"``wait_closed()`` method::"
msgstr ""
"El método debe utilizarse, aunque no es obligatorio, junto con el método "
"``wait_closed()``::"

#: ../../library/asyncio-stream.rst:346
msgid ""
"stream.close()\n"
"await stream.wait_closed()"
msgstr ""

#: ../../library/asyncio-stream.rst:351
msgid ""
"Return ``True`` if the underlying transport supports the :meth:`write_eof` "
"method, ``False`` otherwise."
msgstr ""
"Devuelve ``True`` si el transporte subyacente admite el método :meth:"
"`write_eof`, ``False`` en caso contrario."

#: ../../library/asyncio-stream.rst:356
msgid ""
"Close the write end of the stream after the buffered write data is flushed."
msgstr ""
"Cierra el extremo de escritura del flujo después de que se vacíen los datos "
"de escritura almacenados en el búfer."

#: ../../library/asyncio-stream.rst:361
msgid "Return the underlying asyncio transport."
msgstr "Devuelve el transporte asyncio subyacente."

#: ../../library/asyncio-stream.rst:365
msgid ""
"Access optional transport information; see :meth:`BaseTransport."
"get_extra_info` for details."
msgstr ""
"Acceda a la información de transporte opcional; ver para más detalles :meth:"
"`BaseTransport.get_extra_info`."

#: ../../library/asyncio-stream.rst:371
msgid "Wait until it is appropriate to resume writing to the stream. Example::"
msgstr ""
"Espere hasta que sea apropiado para reanudar la escritura en el flujo. "
"Ejemplo::"

#: ../../library/asyncio-stream.rst:374
msgid ""
"writer.write(data)\n"
"await writer.drain()"
msgstr ""

#: ../../library/asyncio-stream.rst:377
msgid ""
"This is a flow control method that interacts with the underlying IO write "
"buffer.  When the size of the buffer reaches the high watermark, *drain()* "
"blocks until the size of the buffer is drained down to the low watermark and "
"writing can be resumed.  When there is nothing to wait for, the :meth:"
"`drain` returns immediately."
msgstr ""
"Este es un método de control de flujo que interactúa con el búfer de "
"escritura IO subyacente.  Cuando el tamaño del buffer alcanza la señal alta, "
"*drain()* se bloquea hasta que el tamaño del buffer se vacía hasta la señal "
"baja y se puede reanudar la escritura.  Cuando no hay nada que esperar, :"
"meth:`drain` retorna inmediatamente."

#: ../../library/asyncio-stream.rst:388
msgid "Upgrade an existing stream-based connection to TLS."
msgstr ""

#: ../../library/asyncio-stream.rst:390
msgid "Parameters:"
msgstr "Parámetros:"

#: ../../library/asyncio-stream.rst:392
msgid "*sslcontext*: a configured instance of :class:`~ssl.SSLContext`."
msgstr "*sslcontext*: una instancia configurada de :class:`~ssl.SSLContext`."

#: ../../library/asyncio-stream.rst:394
msgid ""
"*server_hostname*: sets or overrides the host name that the target server's "
"certificate will be matched against."
msgstr ""
"*server_hostname*: establece o anula el nombre de host con el que se "
"comparará el certificado del servidor de destino."

#: ../../library/asyncio-stream.rst:397
msgid ""
"*ssl_handshake_timeout* is the time in seconds to wait for the TLS handshake "
"to complete before aborting the connection.  ``60.0`` seconds if ``None`` "
"(default)."
msgstr ""

#: ../../library/asyncio-stream.rst:401
msgid ""
"*ssl_shutdown_timeout* is the time in seconds to wait for the SSL shutdown "
"to complete before aborting the connection. ``30.0`` seconds if ``None`` "
"(default)."
msgstr ""

#: ../../library/asyncio-stream.rst:413
msgid ""
"Return ``True`` if the stream is closed or in the process of being closed."
msgstr "Devuelve ``True`` si el flujo está cerrado o en proceso de cierre."

#: ../../library/asyncio-stream.rst:421
msgid "Wait until the stream is closed."
msgstr "Espere a que se cierre el flujo."

#: ../../library/asyncio-stream.rst:423
msgid ""
"Should be called after :meth:`close` to wait until the underlying connection "
"is closed, ensuring that all data has been flushed before e.g. exiting the "
"program."
msgstr ""
"Debería llamarse después de :meth:`close` para esperar hasta que se cierre "
"la conexión subyacente, asegurando que todos los datos se han vaciado antes "
"de, por ejemplo, salir del programa."

#: ../../library/asyncio-stream.rst:431
msgid "Examples"
msgstr "Ejemplos"

#: ../../library/asyncio-stream.rst:436
msgid "TCP echo client using streams"
msgstr "Cliente de eco TCP mediante secuencias"

#: ../../library/asyncio-stream.rst:438
msgid "TCP echo client using the :func:`asyncio.open_connection` function::"
msgstr ""
"Cliente eco TCP utilizando la función :func:`asyncio.open_connection`::"

#: ../../library/asyncio-stream.rst:462
msgid ""
"The :ref:`TCP echo client protocol "
"<asyncio_example_tcp_echo_client_protocol>` example uses the low-level :meth:"
"`loop.create_connection` method."
msgstr ""
"El ejemplo :ref:`TCP echo client protocol "
"<asyncio_example_tcp_echo_client_protocol>` utiliza el método de bajo nivel :"
"meth:`loop.create_connection`."

#: ../../library/asyncio-stream.rst:469
msgid "TCP echo server using streams"
msgstr "Servidor de eco TCP mediante secuencias"

#: ../../library/asyncio-stream.rst:471
msgid "TCP echo server using the :func:`asyncio.start_server` function::"
msgstr "Servidor eco TCP utilizando la función :func:`asyncio.start_server`::"

#: ../../library/asyncio-stream.rst:473
msgid ""
"import asyncio\n"
"\n"
"async def handle_echo(reader, writer):\n"
"    data = await reader.read(100)\n"
"    message = data.decode()\n"
"    addr = writer.get_extra_info('peername')\n"
"\n"
"    print(f\"Received {message!r} from {addr!r}\")\n"
"\n"
"    print(f\"Send: {message!r}\")\n"
"    writer.write(data)\n"
"    await writer.drain()\n"
"\n"
"    print(\"Close the connection\")\n"
"    writer.close()\n"
"    await writer.wait_closed()\n"
"\n"
"async def main():\n"
"    server = await asyncio.start_server(\n"
"        handle_echo, '127.0.0.1', 8888)\n"
"\n"
"    addrs = ', '.join(str(sock.getsockname()) for sock in server.sockets)\n"
"    print(f'Serving on {addrs}')\n"
"\n"
"    async with server:\n"
"        await server.serve_forever()\n"
"\n"
"asyncio.run(main())"
msgstr ""

#: ../../library/asyncio-stream.rst:505
msgid ""
"The :ref:`TCP echo server protocol "
"<asyncio_example_tcp_echo_server_protocol>` example uses the :meth:`loop."
"create_server` method."
msgstr ""
"El ejemplo :ref:`TCP echo server protocol "
"<asyncio_example_tcp_echo_server_protocol>` utiliza el método :meth:`loop."
"create_server`."

#: ../../library/asyncio-stream.rst:510
msgid "Get HTTP headers"
msgstr "Obtener cabeceras HTTP"

#: ../../library/asyncio-stream.rst:512
msgid ""
"Simple example querying HTTP headers of the URL passed on the command line::"
msgstr ""
"Ejemplo sencillo de consulta de las cabeceras HTTP de la URL introducida en "
"la línea de comandos::"

#: ../../library/asyncio-stream.rst:514
msgid ""
"import asyncio\n"
"import urllib.parse\n"
"import sys\n"
"\n"
"async def print_http_headers(url):\n"
"    url = urllib.parse.urlsplit(url)\n"
"    if url.scheme == 'https':\n"
"        reader, writer = await asyncio.open_connection(\n"
"            url.hostname, 443, ssl=True)\n"
"    else:\n"
"        reader, writer = await asyncio.open_connection(\n"
"            url.hostname, 80)\n"
"\n"
"    query = (\n"
"        f\"HEAD {url.path or '/'} HTTP/1.0\\r\\n\"\n"
"        f\"Host: {url.hostname}\\r\\n\"\n"
"        f\"\\r\\n\"\n"
"    )\n"
"\n"
"    writer.write(query.encode('latin-1'))\n"
"    while True:\n"
"        line = await reader.readline()\n"
"        if not line:\n"
"            break\n"
"\n"
"        line = line.decode('latin1').rstrip()\n"
"        if line:\n"
"            print(f'HTTP header> {line}')\n"
"\n"
"    # Ignore the body, close the socket\n"
"    writer.close()\n"
"    await writer.wait_closed()\n"
"\n"
"url = sys.argv[1]\n"
"asyncio.run(print_http_headers(url))"
msgstr ""

#: ../../library/asyncio-stream.rst:551
msgid "Usage::"
msgstr "Uso::"

#: ../../library/asyncio-stream.rst:553
msgid "python example.py http://example.com/path/page.html"
msgstr ""

#: ../../library/asyncio-stream.rst:555
msgid "or with HTTPS::"
msgstr "o con HTTPS::"

#: ../../library/asyncio-stream.rst:557
msgid "python example.py https://example.com/path/page.html"
msgstr ""

#: ../../library/asyncio-stream.rst:563
msgid "Register an open socket to wait for data using streams"
msgstr "Registrar un socket abierto para esperar datos mediante streams"

#: ../../library/asyncio-stream.rst:565
msgid ""
"Coroutine waiting until a socket receives data using the :func:"
"`open_connection` function::"
msgstr ""
"Corrutina esperando hasta que un socket reciba datos usando la función :func:"
"`open_connection`::"

#: ../../library/asyncio-stream.rst:568
msgid ""
"import asyncio\n"
"import socket\n"
"\n"
"async def wait_for_data():\n"
"    # Get a reference to the current event loop because\n"
"    # we want to access low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    # Create a pair of connected sockets.\n"
"    rsock, wsock = socket.socketpair()\n"
"\n"
"    # Register the open socket to wait for data.\n"
"    reader, writer = await asyncio.open_connection(sock=rsock)\n"
"\n"
"    # Simulate the reception of data from the network\n"
"    loop.call_soon(wsock.send, 'abc'.encode())\n"
"\n"
"    # Wait for data\n"
"    data = await reader.read(100)\n"
"\n"
"    # Got data, we are done: close the socket\n"
"    print(\"Received:\", data.decode())\n"
"    writer.close()\n"
"    await writer.wait_closed()\n"
"\n"
"    # Close the second socket\n"
"    wsock.close()\n"
"\n"
"asyncio.run(wait_for_data())"
msgstr ""

#: ../../library/asyncio-stream.rst:600
msgid ""
"The :ref:`register an open socket to wait for data using a protocol "
"<asyncio_example_create_connection>` example uses a low-level protocol and "
"the :meth:`loop.create_connection` method."
msgstr ""
"El ejemplo :ref:`register an open socket to wait for data using a protocol "
"<asyncio_example_create_connection>` utiliza un protocolo de bajo nivel y el "
"método :meth:`loop.create_connection`."

#: ../../library/asyncio-stream.rst:604
msgid ""
"The :ref:`watch a file descriptor for read events "
"<asyncio_example_watch_fd>` example uses the low-level :meth:`loop."
"add_reader` method to watch a file descriptor."
msgstr ""
"El ejemplo :ref:`watch a file descriptor for read events "
"<asyncio_example_watch_fd>` utiliza el método de bajo nivel :meth:`loop."
"add_reader` para vigilar un descriptor de archivo."
