# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-23 17:40+0000\n"
"PO-Revision-Date: 2025-09-22 17:54+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Spanish (Spain) (https://app.transifex.com/python-doc/"
"teams/5390/es_ES/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es_ES\n"
"Plural-Forms: nplurals=3; plural=n == 1 ? 0 : n != 0 && n % 1000000 == 0 ? "
"1 : 2;\n"

#: ../../library/asyncio-stream.rst:7
msgid "Streams"
msgstr "Transmisiones"

#: ../../library/asyncio-stream.rst:9
msgid "**Source code:** :source:`Lib/asyncio/streams.py`"
msgstr "**Código fuente:** :source:`Lib/asyncio/streams.py`"

#: ../../library/asyncio-stream.rst:13
msgid ""
"Streams are high-level async/await-ready primitives to work with network "
"connections.  Streams allow sending and receiving data without using "
"callbacks or low-level protocols and transports."
msgstr ""
"Los streams son primitivas async/await-ready de alto nivel para trabajar con "
"conexiones de red.  Las secuencias permiten enviar y recibir datos sin "
"utilizar retrollamadas ni protocolos y transportes de bajo nivel."

#: ../../library/asyncio-stream.rst:19
msgid "Here is an example of a TCP echo client written using asyncio streams::"
msgstr ""
"Aquí hay un ejemplo de un cliente de eco TCP escrito usando streams asyncio::"

#: ../../library/asyncio-stream.rst:42
msgid "See also the `Examples`_ section below."
msgstr "Ver también, más abajo, la sección `Examples`_."

#: ../../library/asyncio-stream.rst:46
msgid "Stream Functions"
msgstr "Funciones de flujo"

#: ../../library/asyncio-stream.rst:47
msgid ""
"The following top-level asyncio functions can be used to create and work "
"with streams:"
msgstr ""
"Las siguientes funciones asyncio de nivel superior se pueden utilizar para "
"crear y trabajar con flujos:"

#: ../../library/asyncio-stream.rst:57
msgid ""
"Establish a network connection and return a pair of ``(reader, writer)`` "
"objects."
msgstr ""
"Establece una conexión de red y devuelve un par de objetos ``(reader, "
"writer)``."

#: ../../library/asyncio-stream.rst:60
msgid ""
"The returned *reader* and *writer* objects are instances of :class:"
"`StreamReader` and :class:`StreamWriter` classes."
msgstr ""
"Los objetos *reader* y *writer* devueltos son instancias de las clases :"
"class:`StreamReader` y :class:`StreamWriter`."

#: ../../library/asyncio-stream.rst:63
msgid ""
"The *loop* argument is optional and can always be determined automatically "
"when this function is awaited from a coroutine."
msgstr ""

#: ../../library/asyncio-stream.rst:66 ../../library/asyncio-stream.rst:103
msgid ""
"*limit* determines the buffer size limit used by the returned :class:"
"`StreamReader` instance.  By default the *limit* is set to 64 KiB."
msgstr ""
"*limit* determina el límite del tamaño del búfer utilizado por la instancia :"
"class:`StreamReader` devuelta.  Por defecto, *limit* está fijado en 64 KiB."

#: ../../library/asyncio-stream.rst:70
msgid ""
"The rest of the arguments are passed directly to :meth:`loop."
"create_connection`."
msgstr ""
"El resto de los argumentos se pasan directamente a :meth:`loop."
"create_connection`."

#: ../../library/asyncio-stream.rst:75 ../../library/asyncio-stream.rst:132
msgid "The *ssl_handshake_timeout* parameter."
msgstr ""

#: ../../library/asyncio-stream.rst:79
msgid "Added *happy_eyeballs_delay* and *interleave* parameters."
msgstr ""

#: ../../library/asyncio-stream.rst:89
msgid "Start a socket server."
msgstr "Iniciar un servidor de sockets."

#: ../../library/asyncio-stream.rst:91
msgid ""
"The *client_connected_cb* callback is called whenever a new client "
"connection is established.  It receives a ``(reader, writer)`` pair as two "
"arguments, instances of the :class:`StreamReader` and :class:`StreamWriter` "
"classes."
msgstr ""
"La llamada de retorno *client_connected_cb* se ejecuta cada vez que se "
"establece una nueva conexión con un cliente.  Recibe un par ``(reader, "
"writer)`` como dos argumentos, instancias de las clases :class:"
"`StreamReader` y :class:`StreamWriter`."

#: ../../library/asyncio-stream.rst:96
msgid ""
"*client_connected_cb* can be a plain callable or a :ref:`coroutine function "
"<coroutine>`; if it is a coroutine function, it will be automatically "
"scheduled as a :class:`Task`."
msgstr ""
"*client_connected_cb* puede ser un callable plano o una función :ref:"
"`coroutine <coroutine>`; si es una función corrutina, se programará "
"automáticamente como :class:`Task`."

#: ../../library/asyncio-stream.rst:100
msgid ""
"The *loop* argument is optional and can always be determined automatically "
"when this method is awaited from a coroutine."
msgstr ""

#: ../../library/asyncio-stream.rst:107
msgid ""
"The rest of the arguments are passed directly to :meth:`loop.create_server`."
msgstr ""
"El resto de los argumentos se pasan directamente a :meth:`loop."
"create_server`."

#: ../../library/asyncio-stream.rst:112 ../../library/asyncio-stream.rst:154
msgid "The *ssl_handshake_timeout* and *start_serving* parameters."
msgstr ""

#: ../../library/asyncio-stream.rst:116
msgid "Unix Sockets"
msgstr "Conexiones Unix"

#: ../../library/asyncio-stream.rst:121
msgid ""
"Establish a Unix socket connection and return a pair of ``(reader, writer)``."
msgstr ""
"Establece una conexión de socket Unix y devuelve un par de ``(reader, "
"writer)``."

#: ../../library/asyncio-stream.rst:124
msgid "Similar to :func:`open_connection` but operates on Unix sockets."
msgstr "Similar a :func:`open_connection` pero opera en sockets Unix."

#: ../../library/asyncio-stream.rst:126
msgid "See also the documentation of :meth:`loop.create_unix_connection`."
msgstr "Ver también la documentación de :meth:`loop.create_unix_connection`."

#: ../../library/asyncio-stream.rst:129 ../../library/asyncio-stream.rst:151
msgid ":ref:`Availability <availability>`: Unix."
msgstr ""

#: ../../library/asyncio-stream.rst:136
msgid "The *path* parameter can now be a :term:`path-like object`"
msgstr ""

#: ../../library/asyncio-stream.rst:144
msgid "Start a Unix socket server."
msgstr "Iniciar un servidor de sockets Unix."

#: ../../library/asyncio-stream.rst:146
msgid "Similar to :func:`start_server` but works with Unix sockets."
msgstr "Similar a :func:`start_server` pero funciona con sockets Unix."

#: ../../library/asyncio-stream.rst:148
msgid "See also the documentation of :meth:`loop.create_unix_server`."
msgstr "Consulte también la documentación de :meth:`loop.create_unix_server`."

#: ../../library/asyncio-stream.rst:158
msgid "The *path* parameter can now be a :term:`path-like object`."
msgstr ""

#: ../../library/asyncio-stream.rst:162
msgid "StreamReader"
msgstr "StreamReader"

#: ../../library/asyncio-stream.rst:166
msgid ""
"Represents a reader object that provides APIs to read data from the IO "
"stream."
msgstr ""

#: ../../library/asyncio-stream.rst:169
msgid ""
"It is not recommended to instantiate *StreamReader* objects directly; use :"
"func:`open_connection` and :func:`start_server` instead."
msgstr ""
"No se recomienda instanciar objetos *StreamReader* directamente; en su "
"lugar, usar :func:`open_connection` y :func:`start_server`."

#: ../../library/asyncio-stream.rst:175
msgid ""
"Read up to *n* bytes.  If *n* is not provided, or set to ``-1``, read until "
"EOF and return all read bytes."
msgstr ""

#: ../../library/asyncio-stream.rst:178
msgid ""
"If EOF was received and the internal buffer is empty, return an empty "
"``bytes`` object."
msgstr ""

#: ../../library/asyncio-stream.rst:183
msgid ""
"Read one line, where \"line\" is a sequence of bytes ending with ``\\n``."
msgstr ""
"Leer una línea, donde \"line\" es una secuencia de bytes que termina en "
"``\\n``."

#: ../../library/asyncio-stream.rst:186
msgid ""
"If EOF is received and ``\\n`` was not found, the method returns partially "
"read data."
msgstr ""
"Si se recibe EOF y no se ha encontrado ``\\n``, el método devuelve datos "
"leídos parcialmente."

#: ../../library/asyncio-stream.rst:189
msgid ""
"If EOF is received and the internal buffer is empty, return an empty "
"``bytes`` object."
msgstr ""
"Si se recibe EOF y el búfer interno está vacío, devuelve un objeto ``bytes`` "
"vacío."

#: ../../library/asyncio-stream.rst:194
msgid "Read exactly *n* bytes."
msgstr "Leer exactamente *n* bytes."

#: ../../library/asyncio-stream.rst:196
msgid ""
"Raise an :exc:`IncompleteReadError` if EOF is reached before *n* can be "
"read.  Use the :attr:`IncompleteReadError.partial` attribute to get the "
"partially read data."
msgstr ""
"Lanza un :exc:`IncompleteReadError` si se alcanza EOF antes de que *n* pueda "
"ser leído.  Utilice el atributo :attr:`IncompleteReadError.partial` para "
"obtener los datos leídos parcialmente."

#: ../../library/asyncio-stream.rst:202
msgid "Read data from the stream until *separator* is found."
msgstr "Lee datos del flujo hasta que encuentra el *separador*."

#: ../../library/asyncio-stream.rst:204
msgid ""
"On success, the data and separator will be removed from the internal buffer "
"(consumed). Returned data will include the separator at the end."
msgstr ""
"En caso de éxito, los datos y el separador se eliminarán del búfer interno "
"(consumido). Los datos devueltos incluirán el separador al final."

#: ../../library/asyncio-stream.rst:208
msgid ""
"If the amount of data read exceeds the configured stream limit, a :exc:"
"`LimitOverrunError` exception is raised, and the data is left in the "
"internal buffer and can be read again."
msgstr ""
"Si la cantidad de datos leídos supera el límite de flujo configurado, se "
"lanza una excepción :exc:`LimitOverrunError`, y los datos se dejan en el "
"búfer interno y pueden volver a leerse."

#: ../../library/asyncio-stream.rst:212
msgid ""
"If EOF is reached before the complete separator is found, an :exc:"
"`IncompleteReadError` exception is raised, and the internal buffer is "
"reset.  The :attr:`IncompleteReadError.partial` attribute may contain a "
"portion of the separator."
msgstr ""
"Si se alcanza EOF antes de encontrar el separador completo, se lanza una "
"excepción :exc:`IncompleteReadError` y se reinicia el búfer interno.  El "
"atributo :attr:`IncompleteReadError.partial` puede contener una parte del "
"separador."

#: ../../library/asyncio-stream.rst:221
msgid "Return ``True`` if the buffer is empty and :meth:`feed_eof` was called."
msgstr ""
"Devuelve ``True`` si el búfer está vacío y se ha llamado a :meth:`feed_eof`."

#: ../../library/asyncio-stream.rst:226
msgid "StreamWriter"
msgstr "StreamWriter"

#: ../../library/asyncio-stream.rst:230
msgid ""
"Represents a writer object that provides APIs to write data to the IO stream."
msgstr ""
"Representa un objeto escritor que proporciona APIs para escribir datos en el "
"flujo IO."

#: ../../library/asyncio-stream.rst:233
msgid ""
"It is not recommended to instantiate *StreamWriter* objects directly; use :"
"func:`open_connection` and :func:`start_server` instead."
msgstr ""
"No se recomienda instanciar objetos *StreamWriter* directamente; en su "
"lugar, usar :func:`open_connection` y :func:`start_server`."

#: ../../library/asyncio-stream.rst:239
msgid ""
"The method attempts to write the *data* to the underlying socket "
"immediately. If that fails, the data is queued in an internal write buffer "
"until it can be sent."
msgstr ""
"El método intenta escribir los *datos* en el socket subyacente "
"inmediatamente. Si falla, los datos se ponen en cola en un búfer de "
"escritura interno hasta que puedan enviarse."

#: ../../library/asyncio-stream.rst:243 ../../library/asyncio-stream.rst:255
msgid "The method should be used along with the ``drain()`` method::"
msgstr "El método debe utilizarse junto con el método ``drain()``::"

#: ../../library/asyncio-stream.rst:250
msgid ""
"The method writes a list (or any iterable) of bytes to the underlying socket "
"immediately. If that fails, the data is queued in an internal write buffer "
"until it can be sent."
msgstr ""
"El método escribe una lista (o cualquier iterable) de bytes al socket "
"subyacente inmediatamente. Si falla, los datos se ponen en cola en un búfer "
"de escritura interno hasta que se puedan enviar."

#: ../../library/asyncio-stream.rst:262
msgid "The method closes the stream and the underlying socket."
msgstr "El método cierra el flujo y el socket subyacente."

#: ../../library/asyncio-stream.rst:264
msgid "The method should be used along with the ``wait_closed()`` method::"
msgstr ""

#: ../../library/asyncio-stream.rst:271
msgid ""
"Return ``True`` if the underlying transport supports the :meth:`write_eof` "
"method, ``False`` otherwise."
msgstr ""
"Devuelve ``True`` si el transporte subyacente admite el método :meth:"
"`write_eof`, ``False`` en caso contrario."

#: ../../library/asyncio-stream.rst:276
msgid ""
"Close the write end of the stream after the buffered write data is flushed."
msgstr ""
"Cierra el extremo de escritura del flujo después de que se vacíen los datos "
"de escritura almacenados en el búfer."

#: ../../library/asyncio-stream.rst:281
msgid "Return the underlying asyncio transport."
msgstr "Devuelve el transporte asyncio subyacente."

#: ../../library/asyncio-stream.rst:285
msgid ""
"Access optional transport information; see :meth:`BaseTransport."
"get_extra_info` for details."
msgstr ""
"Acceda a la información de transporte opcional; ver para más detalles :meth:"
"`BaseTransport.get_extra_info`."

#: ../../library/asyncio-stream.rst:290
msgid "Wait until it is appropriate to resume writing to the stream. Example::"
msgstr ""
"Espere hasta que sea apropiado para reanudar la escritura en el flujo. "
"Ejemplo::"

#: ../../library/asyncio-stream.rst:296
msgid ""
"This is a flow control method that interacts with the underlying IO write "
"buffer.  When the size of the buffer reaches the high watermark, *drain()* "
"blocks until the size of the buffer is drained down to the low watermark and "
"writing can be resumed.  When there is nothing to wait for, the :meth:"
"`drain` returns immediately."
msgstr ""
"Este es un método de control de flujo que interactúa con el búfer de "
"escritura IO subyacente.  Cuando el tamaño del buffer alcanza la señal alta, "
"*drain()* se bloquea hasta que el tamaño del buffer se vacía hasta la señal "
"baja y se puede reanudar la escritura.  Cuando no hay nada que esperar, :"
"meth:`drain` retorna inmediatamente."

#: ../../library/asyncio-stream.rst:305
msgid ""
"Return ``True`` if the stream is closed or in the process of being closed."
msgstr "Devuelve ``True`` si el flujo está cerrado o en proceso de cierre."

#: ../../library/asyncio-stream.rst:312
msgid "Wait until the stream is closed."
msgstr "Espere a que se cierre el flujo."

#: ../../library/asyncio-stream.rst:314
msgid ""
"Should be called after :meth:`close` to wait until the underlying connection "
"is closed."
msgstr ""

#: ../../library/asyncio-stream.rst:321
msgid "Examples"
msgstr "Ejemplos"

#: ../../library/asyncio-stream.rst:326
msgid "TCP echo client using streams"
msgstr "Cliente de eco TCP mediante secuencias"

#: ../../library/asyncio-stream.rst:328
msgid "TCP echo client using the :func:`asyncio.open_connection` function::"
msgstr ""
"Cliente eco TCP utilizando la función :func:`asyncio.open_connection`::"

#: ../../library/asyncio-stream.rst:350
msgid ""
"The :ref:`TCP echo client protocol "
"<asyncio_example_tcp_echo_client_protocol>` example uses the low-level :meth:"
"`loop.create_connection` method."
msgstr ""
"El ejemplo :ref:`TCP echo client protocol "
"<asyncio_example_tcp_echo_client_protocol>` utiliza el método de bajo nivel :"
"meth:`loop.create_connection`."

#: ../../library/asyncio-stream.rst:357
msgid "TCP echo server using streams"
msgstr "Servidor de eco TCP mediante secuencias"

#: ../../library/asyncio-stream.rst:359
msgid "TCP echo server using the :func:`asyncio.start_server` function::"
msgstr "Servidor eco TCP utilizando la función :func:`asyncio.start_server`::"

#: ../../library/asyncio-stream.rst:392
msgid ""
"The :ref:`TCP echo server protocol "
"<asyncio_example_tcp_echo_server_protocol>` example uses the :meth:`loop."
"create_server` method."
msgstr ""
"El ejemplo :ref:`TCP echo server protocol "
"<asyncio_example_tcp_echo_server_protocol>` utiliza el método :meth:`loop."
"create_server`."

#: ../../library/asyncio-stream.rst:397
msgid "Get HTTP headers"
msgstr "Obtener cabeceras HTTP"

#: ../../library/asyncio-stream.rst:399
msgid ""
"Simple example querying HTTP headers of the URL passed on the command line::"
msgstr ""
"Ejemplo sencillo de consulta de las cabeceras HTTP de la URL introducida en "
"la línea de comandos::"

#: ../../library/asyncio-stream.rst:437
msgid "Usage::"
msgstr "Uso::"

#: ../../library/asyncio-stream.rst:441
msgid "or with HTTPS::"
msgstr "o con HTTPS::"

#: ../../library/asyncio-stream.rst:449
msgid "Register an open socket to wait for data using streams"
msgstr "Registrar un socket abierto para esperar datos mediante streams"

#: ../../library/asyncio-stream.rst:451
msgid ""
"Coroutine waiting until a socket receives data using the :func:"
"`open_connection` function::"
msgstr ""
"Corrutina esperando hasta que un socket reciba datos usando la función :func:"
"`open_connection`::"

#: ../../library/asyncio-stream.rst:485
msgid ""
"The :ref:`register an open socket to wait for data using a protocol "
"<asyncio_example_create_connection>` example uses a low-level protocol and "
"the :meth:`loop.create_connection` method."
msgstr ""
"El ejemplo :ref:`register an open socket to wait for data using a protocol "
"<asyncio_example_create_connection>` utiliza un protocolo de bajo nivel y el "
"método :meth:`loop.create_connection`."

#: ../../library/asyncio-stream.rst:489
msgid ""
"The :ref:`watch a file descriptor for read events "
"<asyncio_example_watch_fd>` example uses the low-level :meth:`loop."
"add_reader` method to watch a file descriptor."
msgstr ""
"El ejemplo :ref:`watch a file descriptor for read events "
"<asyncio_example_watch_fd>` utiliza el método de bajo nivel :meth:`loop."
"add_reader` para vigilar un descriptor de archivo."
