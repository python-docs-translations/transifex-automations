# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2026, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# eulalio barbero espinosa <eulalio@disroot.org>, 2026
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-07 15:16+0000\n"
"PO-Revision-Date: 2025-07-18 19:57+0000\n"
"Last-Translator: eulalio barbero espinosa <eulalio@disroot.org>, 2026\n"
"Language-Team: Spanish (Spain) (https://app.transifex.com/python-doc/"
"teams/5390/es_ES/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es_ES\n"
"Plural-Forms: nplurals=3; plural=n == 1 ? 0 : n != 0 && n % 1000000 == 0 ? "
"1 : 2;\n"

#: ../../library/csv.rst:2
msgid ":mod:`!csv` --- CSV File Reading and Writing"
msgstr ":mod:`!csv` --- Lectura y escritura de archivos CSV"

#: ../../library/csv.rst:9
msgid "**Source code:** :source:`Lib/csv.py`"
msgstr "**Código fuente:** :source:`Lib/csv.py`"

#: ../../library/csv.rst:17
msgid ""
"The so-called CSV (Comma Separated Values) format is the most common import "
"and export format for spreadsheets and databases.  CSV format was used for "
"many years prior to attempts to describe the format in a standardized way "
"in :rfc:`4180`.  The lack of a well-defined standard means that subtle "
"differences often exist in the data produced and consumed by different "
"applications.  These differences can make it annoying to process CSV files "
"from multiple sources. Still, while the delimiters and quoting characters "
"vary, the overall format is similar enough that it is possible to write a "
"single module which can efficiently manipulate such data, hiding the details "
"of reading and writing the data from the programmer."
msgstr ""
"El llamado formato CSV (Comma Separated Values) es el más común para "
"importar y exportar hojas de cálculo y bases de datos.  El formato CSV se "
"utilizó durante muchos años antes de que se intentara describir el formato "
"de forma estandarizada en :rfc:`4180`.  La falta de una norma bien definida "
"hace que a menudo existan sutiles diferencias en los datos producidos y "
"consumidos por distintas aplicaciones.  Estas diferencias pueden hacer que "
"resulte molesto procesar archivos CSV de múltiples fuentes. Aun así, aunque "
"los delimitadores y caracteres de entrecomillado varían, el formato general "
"es lo suficientemente similar como para que sea posible escribir un único "
"módulo que pueda manipular eficientemente dichos datos, ocultando al "
"programador los detalles de la lectura y escritura de los datos."

#: ../../library/csv.rst:28
msgid ""
"The :mod:`csv` module implements classes to read and write tabular data in "
"CSV format.  It allows programmers to say, \"write this data in the format "
"preferred by Excel,\" or \"read data from this file which was generated by "
"Excel,\" without knowing the precise details of the CSV format used by "
"Excel.  Programmers can also describe the CSV formats understood by other "
"applications or define their own special-purpose CSV formats."
msgstr ""
"El módulo :mod:`csv` implementa clases para leer y escribir datos tabulares "
"en formato CSV.  Permite a los programadores decir \"escriba estos datos en "
"el formato preferido por Excel\" o \"lea los datos de este archivo generado "
"por Excel\" sin conocer los detalles precisos del formato CSV utilizado por "
"Excel.  Los programadores también pueden describir los formatos CSV que "
"entienden otras aplicaciones o definir sus propios formatos CSV especiales."

#: ../../library/csv.rst:35
msgid ""
"The :mod:`csv` module's :class:`reader` and :class:`writer` objects read and "
"write sequences.  Programmers can also read and write data in dictionary "
"form using the :class:`DictReader` and :class:`DictWriter` classes."
msgstr ""
"Los objetos :class:`reader` y :class:`writer` del módulo :mod:`csv` leen y "
"escriben secuencias.  Los programadores también pueden leer y escribir datos "
"en forma de diccionario utilizando las clases :class:`DictReader` y :class:"
"`DictWriter`."

#: ../../library/csv.rst:41
msgid ":pep:`305` - CSV File API"
msgstr ":pep:`305` - API de archivos CSV"

#: ../../library/csv.rst:42
msgid "The Python Enhancement Proposal which proposed this addition to Python."
msgstr "La propuesta de mejora de Python que proponía esta adición a Python."

#: ../../library/csv.rst:48
msgid "Module Contents"
msgstr "Contenidos del módulo"

#: ../../library/csv.rst:50
msgid "The :mod:`csv` module defines the following functions:"
msgstr "El módulo :mod:`csv` define las siguientes funciones:"

#: ../../library/csv.rst:58
msgid ""
"Return a :ref:`reader object <reader-objects>` that will process lines from "
"the given *csvfile*.  A csvfile must be an iterable of strings, each in the "
"reader's defined csv format. A csvfile is most commonly a file-like object "
"or list. If *csvfile* is a file object, it should be opened with "
"``newline=''``. [1]_  An optional *dialect* parameter can be given which is "
"used to define a set of parameters specific to a particular CSV dialect.  It "
"may be an instance of a subclass of the :class:`Dialect` class or one of the "
"strings returned by the :func:`list_dialects` function.  The other optional "
"*fmtparams* keyword arguments can be given to override individual formatting "
"parameters in the current dialect.  For full details about the dialect and "
"formatting parameters, see section :ref:`csv-fmt-params`."
msgstr ""
"Devuelve un :ref:`reader object <reader-objects>` que procesará las líneas "
"del *fichero csv* dado.  Un archivo csv debe ser un iterable de cadenas, "
"cada una en el formato csv definido por el lector. Un fichero csv es "
"normalmente un objeto o lista similar a un fichero. Si *csvfile* es un "
"objeto archivo, debe abrirse con ``newline=''``. [1]_  Se puede dar un "
"parámetro opcional *dialect* que se utiliza para definir un conjunto de "
"parámetros específicos para un dialecto CSV en particular.  Puede ser una "
"instancia de una subclase de la clase :class:`Dialect` o una de las cadenas "
"devueltas por la función :func:`list_dialects`.  Los otros argumentos "
"opcionales de la palabra clave *fmtparams* se pueden dar para anular "
"parámetros de formato individuales en el dialecto actual.  Para más "
"información sobre el dialecto y los parámetros de formato, consulte la "
"sección :ref:`csv-fmt-params`."

#: ../../library/csv.rst:72
msgid ""
"Each row read from the csv file is returned as a list of strings.  No "
"automatic data type conversion is performed unless the ``QUOTE_NONNUMERIC`` "
"format option is specified (in which case unquoted fields are transformed "
"into floats)."
msgstr ""
"Cada fila leída del archivo csv se devuelve como una lista de cadenas.  No "
"se realiza ninguna conversión automática del tipo de datos a menos que se "
"especifique la opción de formato ``QUOTE_NONNUMERIC`` (en cuyo caso los "
"campos no entrecomillados se transforman en flotantes)."

#: ../../library/csv.rst:76 ../../library/csv.rst:106 ../../library/csv.rst:181
#: ../../library/csv.rst:219
msgid "A short usage example::"
msgstr "Un breve ejemplo de uso::"

#: ../../library/csv.rst:78
msgid ""
">>> import csv\n"
">>> with open('eggs.csv', newline='') as csvfile:\n"
"...     spamreader = csv.reader(csvfile, delimiter=' ', quotechar='|')\n"
"...     for row in spamreader:\n"
"...         print(', '.join(row))\n"
"Spam, Spam, Spam, Spam, Spam, Baked Beans\n"
"Spam, Lovely Spam, Wonderful Spam"
msgstr ""
">>> import csv>>> with open('eggs.csv', newline='') as csvfile:...     "
"spamreader = csv.reader(csvfile, delimiter=' ', quotechar='|')...     for "
"row in spamreader:...         print(', '.join(row))Spam, Spam, Spam, Spam, "
"Spam, Baked BeansSpam, Lovely Spam, Wonderful Spam"

#: ../../library/csv.rst:89
msgid ""
"Return a writer object responsible for converting the user's data into "
"delimited strings on the given file-like object.  *csvfile* can be any "
"object with a :meth:`~io.TextIOBase.write` method.  If *csvfile* is a file "
"object, it should be opened with ``newline=''`` [1]_.  An optional *dialect* "
"parameter can be given which is used to define a set of parameters specific "
"to a particular CSV dialect.  It may be an instance of a subclass of the :"
"class:`Dialect` class or one of the strings returned by the :func:"
"`list_dialects` function.  The other optional *fmtparams* keyword arguments "
"can be given to override individual formatting parameters in the current "
"dialect.  For full details about dialects and formatting parameters, see "
"the :ref:`csv-fmt-params` section. To make it as easy as possible to "
"interface with modules which implement the DB API, the value :const:`None` "
"is written as the empty string.  While this isn't a reversible "
"transformation, it makes it easier to dump SQL NULL data values to CSV files "
"without preprocessing the data returned from a ``cursor.fetch*`` call. All "
"other non-string data are stringified with :func:`str` before being written."
msgstr ""
"Devuelve un objeto escritor responsable de convertir los datos del usuario "
"en cadenas delimitadas en el objeto tipo fichero dado.  *csvfile* puede ser "
"cualquier objeto con un método :meth:`~io.TextIOBase.write`.  Si *csvfile* "
"es un objeto tipo fichero, debe abrirse con ``newline=''`` [1]_ .  Se puede "
"dar un parámetro opcional *dialect* que se utiliza para definir un conjunto "
"de parámetros específicos para un dialecto CSV en particular.  Puede ser una "
"instancia de una subclase de la clase :class:`Dialect` o una de las cadenas "
"devueltas por la función :func:`list_dialects`.  Los otros argumentos "
"opcionales de la palabra clave *fmtparams* se pueden dar para anular "
"parámetros de formato individuales en el dialecto actual.  Para más "
"información sobre dialectos y parámetros de formato, consulte la sección :"
"ref:`csv-fmt-params`. Para facilitar al máximo la interfaz con los módulos "
"que implementan la DB API, el valor :const:`None` se escribe como una cadena "
"vacía.  Aunque no se trata de una transformación reversible, facilita el "
"volcado de valores de datos SQL NULL a archivos CSV sin necesidad de "
"preprocesar los datos devueltos por una llamada a ``cursor.fetch*``. Todos "
"los demás datos que no sean cadenas se convierten en cadenas con :func:`str` "
"antes de escribirse."

#: ../../library/csv.rst:108
msgid ""
"import csv\n"
"with open('eggs.csv', 'w', newline='') as csvfile:\n"
"    spamwriter = csv.writer(csvfile, delimiter=' ',\n"
"                            quotechar='|', quoting=csv.QUOTE_MINIMAL)\n"
"    spamwriter.writerow(['Spam'] * 5 + ['Baked Beans'])\n"
"    spamwriter.writerow(['Spam', 'Lovely Spam', 'Wonderful Spam'])"
msgstr ""
"import csvwith open('eggs.csv', 'w', newline='') as csvfile:    spamwriter = "
"csv.writer(csvfile, delimiter=' ',                            quotechar='|', "
"quoting=csv.QUOTE_MINIMAL)    spamwriter.writerow(['Spam'] * 5 + ['Baked "
"Beans'])    spamwriter.writerow(['Spam', 'Lovely Spam', 'Wonderful Spam'])"

#: ../../library/csv.rst:118
msgid ""
"Associate *dialect* with *name*.  *name* must be a string. The dialect can "
"be specified either by passing a sub-class of :class:`Dialect`, or by "
"*fmtparams* keyword arguments, or both, with keyword arguments overriding "
"parameters of the dialect. For full details about dialects and formatting "
"parameters, see section :ref:`csv-fmt-params`."
msgstr ""
"Asociar *dialect* con *name*.  *name* ha de ser una cadena. El dialecto "
"puede especificarse pasando una subclase de :class:`Dialect`, o mediante "
"argumentos de palabra clave *fmtparams*, o ambos, con argumentos de palabra "
"clave que anulan los parámetros del dialecto. Para más información sobre "
"dialectos y parámetros de formato, consulte la sección :ref:`csv-fmt-params`."

#: ../../library/csv.rst:127
msgid ""
"Delete the dialect associated with *name* from the dialect registry.  An :"
"exc:`Error` is raised if *name* is not a registered dialect name."
msgstr ""
"Elimina el dialecto asociado a *name* del registro de dialectos.  Se genera "
"un mensaje :exc:`Error` si *name* no es un nombre de dialecto registrado."

#: ../../library/csv.rst:133
msgid ""
"Return the dialect associated with *name*.  An :exc:`Error` is raised if "
"*name* is not a registered dialect name.  This function returns an "
"immutable :class:`Dialect`."
msgstr ""
"Devuelve el dialecto asociado a *name*.  Se genera un :exc:`Error` si *name* "
"no es un nombre de dialecto registrado.  Esta función devuelve un :class:"
"`Dialect` inmutable."

#: ../../library/csv.rst:139
msgid "Return the names of all registered dialects."
msgstr "Devuelve los nombres de todos los dialectos registrados."

#: ../../library/csv.rst:144
msgid ""
"Returns the current maximum field size allowed by the parser. If *new_limit* "
"is given, this becomes the new limit."
msgstr ""
"Devuelve el tamaño máximo de campo permitido por el analizador sintáctico. "
"Si se indica *new_limit*, se convierte en el nuevo límite."

#: ../../library/csv.rst:148
msgid "The :mod:`csv` module defines the following classes:"
msgstr "El módulo :mod:`csv` define las siguientes clases:"

#: ../../library/csv.rst:153
msgid ""
"Create an object that operates like a regular reader but maps the "
"information in each row to a :class:`dict` whose keys are given by the "
"optional *fieldnames* parameter."
msgstr ""
"Crea un objeto que funciona como un lector normal pero que asigna la "
"información de cada fila a un :class:`dict` cuyas claves vienen dadas por el "
"parámetro opcional *fieldnames*."

#: ../../library/csv.rst:157
msgid ""
"The *fieldnames* parameter is a :term:`sequence`.  If *fieldnames* is "
"omitted, the values in the first row of file *f* will be used as the "
"fieldnames and will be omitted from the results. If *fieldnames* is "
"provided, they will be used and the first row will be included in the "
"results.  Regardless of how the fieldnames are determined, the dictionary "
"preserves their original ordering."
msgstr ""
"El parámetro *fieldnames* es un  :term:`sequence`..  Si se omite "
"*fieldnames*, los valores de la primera fila del archivo *f* se utilizarán "
"como nombres de campo y se omitirán en los resultados. Si se proporciona "
"*fieldnames*, se utilizarán y se incluirá la primera fila en los "
"resultados.  Independientemente de cómo se determinen los nombres de campo, "
"el diccionario conserva su orden original."

#: ../../library/csv.rst:164
msgid ""
"If a row has more fields than fieldnames, the remaining data is put in a "
"list and stored with the fieldname specified by *restkey* (which defaults to "
"``None``).  If a non-blank row has fewer fields than fieldnames, the missing "
"values are filled-in with the value of *restval* (which defaults to "
"``None``)."
msgstr ""
"Si una fila tiene más campos que nombres de campo, los datos restantes se "
"ponen en una lista y se almacenan con el nombre de campo especificado por "
"*restkey* (que por defecto es ``None``).  Si una fila que no está en blanco "
"tiene menos campos que nombres de campo, los valores que faltan se rellenan "
"con el valor de *restval* (cuyo valor por defecto es ``None``)."

#: ../../library/csv.rst:170
msgid ""
"All other optional or keyword arguments are passed to the underlying :class:"
"`reader` instance."
msgstr ""
"Todos los demás argumentos opcionales o de palabra clave se pasan a la "
"instancia :class:`reader` subyacente."

#: ../../library/csv.rst:173 ../../library/csv.rst:217
msgid ""
"If the argument passed to *fieldnames* is an iterator, it will be coerced to "
"a :class:`list`."
msgstr ""
"Si el argumento pasado a *fieldnames* es un iterador, será coaccionado a un :"
"class:`list`."

#: ../../library/csv.rst:175
msgid "Returned rows are now of type :class:`OrderedDict`."
msgstr "Las filas devueltas son ahora del tipo :class:`OrderedDict`."

#: ../../library/csv.rst:178
msgid "Returned rows are now of type :class:`dict`."
msgstr "Las filas devueltas son ahora del tipo :class:`dict`."

#: ../../library/csv.rst:183
msgid ""
">>> import csv\n"
">>> with open('names.csv', newline='') as csvfile:\n"
"...     reader = csv.DictReader(csvfile)\n"
"...     for row in reader:\n"
"...         print(row['first_name'], row['last_name'])\n"
"...\n"
"Eric Idle\n"
"John Cleese\n"
"\n"
">>> print(row)\n"
"{'first_name': 'John', 'last_name': 'Cleese'}"
msgstr ""
">>> import csv>>> with open('names.csv', newline='') as csvfile:...     "
"reader = csv.DictReader(csvfile)...     for row in reader:...         "
"print(row['first_name'], row['last_name'])...Eric IdleJohn Cleese>>> "
"print(row){'first_name': 'John', 'last_name': 'Cleese'}"

#: ../../library/csv.rst:199
msgid ""
"Create an object which operates like a regular writer but maps dictionaries "
"onto output rows.  The *fieldnames* parameter is a :mod:`sequence "
"<collections.abc>` of keys that identify the order in which values in the "
"dictionary passed to the :meth:`~csvwriter.writerow` method are written to "
"file *f*.  The optional *restval* parameter specifies the value to be "
"written if the dictionary is missing a key in *fieldnames*.  If the "
"dictionary passed to the :meth:`~csvwriter.writerow` method contains a key "
"not found in *fieldnames*, the optional *extrasaction* parameter indicates "
"what action to take. If it is set to ``'raise'``, the default value, a :exc:"
"`ValueError` is raised. If it is set to ``'ignore'``, extra values in the "
"dictionary are ignored. Any other optional or keyword arguments are passed "
"to the underlying :class:`writer` instance."
msgstr ""
"Crea un objeto que funciona como un escritor normal pero asigna diccionarios "
"a las filas de salida.  El parámetro *fieldnames* es una :mod:`sequence "
"<collections.abc>` de claves que identifican el orden en que los valores del "
"diccionario pasado al método :meth:`~csvwriter.writerow` se escriben en el "
"fichero *f*.  El parámetro opcional *restval* especifica el valor que se "
"escribirá si al diccionario le falta una clave en *fieldnames*.  Si el "
"diccionario pasado al método :meth:`~csvwriter.writerow` contiene una clave "
"no encontrada en *fieldnames*, el parámetro opcional *extrasaction* indica "
"qué acción tomar. Si se establece en ``'raise'``, el valor por defecto, se "
"genera un :exc:`ValueError`. Si se establece en ``'ignore'``, se ignoran los "
"valores extra del diccionario. Cualquier otro argumento opcional o de "
"palabra clave se pasa a la instancia :class:`writer` subyacente."

#: ../../library/csv.rst:214
msgid ""
"Note that unlike the :class:`DictReader` class, the *fieldnames* parameter "
"of the :class:`DictWriter` class is not optional."
msgstr ""
"Tener en cuenta que, a diferencia de la clase :class:`DictReader`, el "
"parámetro *fieldnames* de la clase :class:`DictWriter` no es opcional."

#: ../../library/csv.rst:221
msgid ""
"import csv\n"
"\n"
"with open('names.csv', 'w', newline='') as csvfile:\n"
"    fieldnames = ['first_name', 'last_name']\n"
"    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)\n"
"\n"
"    writer.writeheader()\n"
"    writer.writerow({'first_name': 'Baked', 'last_name': 'Beans'})\n"
"    writer.writerow({'first_name': 'Lovely', 'last_name': 'Spam'})\n"
"    writer.writerow({'first_name': 'Wonderful', 'last_name': 'Spam'})"
msgstr ""
"import csvwith open('names.csv', 'w', newline='') as csvfile:    fieldnames "
"= ['first_name', 'last_name']    writer = csv.DictWriter(csvfile, "
"fieldnames=fieldnames)    writer.writeheader()    writer."
"writerow({'first_name': 'Baked', 'last_name': 'Beans'})    writer."
"writerow({'first_name': 'Lovely', 'last_name': 'Spam'})    writer."
"writerow({'first_name': 'Wonderful', 'last_name': 'Spam'})"

#: ../../library/csv.rst:235
msgid ""
"The :class:`Dialect` class is a container class whose attributes contain "
"information for how to handle doublequotes, whitespace, delimiters, etc. Due "
"to the lack of a strict CSV specification, different applications produce "
"subtly different CSV data.  :class:`Dialect` instances define how :class:"
"`reader` and :class:`writer` instances behave."
msgstr ""
"La clase :class:`Dialect` es una clase contenedora cuyos atributos contienen "
"información sobre cómo manejar las comillas dobles, los espacios en blanco, "
"los delimitadores, etc. Debido a la falta de una especificación CSV "
"estricta, las distintas aplicaciones producen datos CSV sutilmente "
"diferentes. Las instancias :class:`Dialect` definen cómo se comportan las "
"instancias :class:`reader` y :class:`writer`."

#: ../../library/csv.rst:241
msgid ""
"All available :class:`Dialect` names are returned by :func:`list_dialects`, "
"and they can be registered with specific :class:`reader` and :class:`writer` "
"classes through their initializer (``__init__``) functions like this::"
msgstr ""
"Todos los nombres disponibles de :class:`Dialect` son devueltos por :func:"
"`list_dialects`, y pueden registrarse con clases específicas de :class:"
"`reader` y :class:`writer` a través de sus funciones inicializadoras "
"(``__init__``) de la siguiente manera::"

#: ../../library/csv.rst:245
msgid ""
"import csv\n"
"\n"
"with open('students.csv', 'w', newline='') as csvfile:\n"
"    writer = csv.writer(csvfile, dialect='unix')"
msgstr ""
"import csvwith open('students.csv', 'w', newline='') as csvfile:    writer = "
"csv.writer(csvfile, dialect='unix')"

#: ../../library/csv.rst:253
msgid ""
"The :class:`excel` class defines the usual properties of an Excel-generated "
"CSV file.  It is registered with the dialect name ``'excel'``."
msgstr ""
"La clase :class:`excel` define las propiedades habituales de un archivo CSV "
"generado por Excel.  Se registra con el nombre dialectal ``'excel'``."

#: ../../library/csv.rst:259
msgid ""
"The :class:`excel_tab` class defines the usual properties of an Excel-"
"generated TAB-delimited file.  It is registered with the dialect name "
"``'excel-tab'``."
msgstr ""
"La clase :class:`excel_tab` define las propiedades habituales de un archivo "
"delimitado por TAB generado por Excel.  Se registra con el nombre dialectal "
"``'excel-tab'``."

#: ../../library/csv.rst:265
msgid ""
"The :class:`unix_dialect` class defines the usual properties of a CSV file "
"generated on UNIX systems, i.e. using ``'\\n'`` as line terminator and "
"quoting all fields.  It is registered with the dialect name ``'unix'``."
msgstr ""
"La clase :class:`unix_dialect` define las propiedades habituales de un "
"fichero CSV generado en sistemas UNIX, es decir, el uso de ``'\\n'`` como "
"terminador de línea y el entrecomillado de todos los campos.  Se registra "
"con el nombre dialectal ``'unix'``."

#: ../../library/csv.rst:274
msgid "The :class:`Sniffer` class is used to deduce the format of a CSV file."
msgstr ""
"La clase :class:`Sniffer` se utiliza para deducir el formato de un fichero "
"CSV."

#: ../../library/csv.rst:276
msgid "The :class:`Sniffer` class provides two methods:"
msgstr "La clase :class:`Sniffer` proporciona dos métodos:"

#: ../../library/csv.rst:280
msgid ""
"Analyze the given *sample* and return a :class:`Dialect` subclass reflecting "
"the parameters found.  If the optional *delimiters* parameter is given, it "
"is interpreted as a string containing possible valid delimiter characters."
msgstr ""
"Analiza la *sample* dada y devuelve una subclase :class:`Dialect` que "
"refleja los parámetros encontrados.  Si se da el parámetro opcional "
"*delimiters*, se interpreta como una cadena que contiene posibles caracteres "
"delimitadores válidos."

#: ../../library/csv.rst:288
msgid ""
"Analyze the sample text (presumed to be in CSV format) and return :const:"
"`True` if the first row appears to be a series of column headers. Inspecting "
"each column, one of two key criteria will be considered to estimate if the "
"sample contains a header:"
msgstr ""
"Analiza el texto de la muestra (se supone que está en formato CSV) y "
"devuelve :const:`True` si la primera fila parece ser una serie de cabeceras "
"de columna. Inspeccionando cada columna, se tendrá en cuenta uno de los dos "
"criterios clave para estimar si la muestra contiene una cabecera:"

#: ../../library/csv.rst:293
msgid "the second through n-th rows contain numeric values"
msgstr "las filas segunda a n contienen valores numéricos"

#: ../../library/csv.rst:294
msgid ""
"the second through n-th rows contain strings where at least one value's "
"length differs from that of the putative header of that column."
msgstr ""
"las filas de la segunda a la n-ésima contienen cadenas en las que la "
"longitud de al menos un valor difiere de la de la cabecera putativa de esa "
"columna."

#: ../../library/csv.rst:297
msgid ""
"Twenty rows after the first row are sampled; if more than half of columns + "
"rows meet the criteria, :const:`True` is returned."
msgstr ""
"Se muestrean 20 filas después de la primera; si más de la mitad de columnas "
"+ filas cumplen los criterios, se devuelve :const:`True`."

#: ../../library/csv.rst:302
msgid ""
"This method is a rough heuristic and may produce both false positives and "
"negatives."
msgstr ""
"Este método es una heurística aproximada y puede producir tanto falsos "
"positivos como negativos."

#: ../../library/csv.rst:305
msgid "An example for :class:`Sniffer` use::"
msgstr "Un ejemplo para :class:`Sniffer`::"

#: ../../library/csv.rst:307
msgid ""
"with open('example.csv', newline='') as csvfile:\n"
"    dialect = csv.Sniffer().sniff(csvfile.read(1024))\n"
"    csvfile.seek(0)\n"
"    reader = csv.reader(csvfile, dialect)\n"
"    # ... process CSV file contents here ..."
msgstr ""
"with open('example.csv', newline='') as csvfile:    dialect = csv.Sniffer()."
"sniff(csvfile.read(1024))    csvfile.seek(0)    reader = csv.reader(csvfile, "
"dialect)    # ... process CSV file contents here ..."

#: ../../library/csv.rst:316
msgid "The :mod:`csv` module defines the following constants:"
msgstr "El módulo :mod:`csv` define las siguientes constantes:"

#: ../../library/csv.rst:320
msgid "Instructs :class:`writer` objects to quote all fields."
msgstr "Ordena a los objetos :class:`writer` que citen todos los campos."

#: ../../library/csv.rst:325
msgid ""
"Instructs :class:`writer` objects to only quote those fields which contain "
"special characters such as *delimiter*, *quotechar* or any of the characters "
"in *lineterminator*."
msgstr ""
"Indica a los objetos :class:`writer` que sólo citen los campos que contengan "
"caracteres especiales como *delimiter*, *quotechar* o cualquiera de los "
"caracteres de *lineterminator*."

#: ../../library/csv.rst:332
msgid "Instructs :class:`writer` objects to quote all non-numeric fields."
msgstr ""
"Indica a los objetos :class:`writer` que citen todos los campos no numéricos."

#: ../../library/csv.rst:334
msgid ""
"Instructs :class:`reader` objects to convert all non-quoted fields to type "
"*float*."
msgstr ""
"Indica a los objetos :class:`reader` que conviertan todos los campos no "
"entrecomillados al tipo *float*."

#: ../../library/csv.rst:339
msgid ""
"Instructs :class:`writer` objects to never quote fields.  When the current "
"*delimiter* occurs in output data it is preceded by the current *escapechar* "
"character.  If *escapechar* is not set, the writer will raise :exc:`Error` "
"if any characters that require escaping are encountered."
msgstr ""
"Indica a los objetos :class:`writer` que nunca entrecomillen los campos.  "
"Cuando el *delimiter* actual aparece en los datos de salida, es precedido "
"por el carácter *escapechar* actual.  Si *escapechar* no está definido, el "
"escritor mostrará :exc:`Error` si se encuentra algún carácter que requiera "
"escape."

#: ../../library/csv.rst:344
msgid ""
"Instructs :class:`reader` objects to perform no special processing of quote "
"characters."
msgstr ""
"Indica a los objetos :class:`reader` que no realicen ningún procesamiento "
"especial de los caracteres entrecomillados."

#: ../../library/csv.rst:348
msgid ""
"Instructs :class:`writer` objects to quote all fields which are not "
"``None``.  This is similar to :data:`QUOTE_ALL`, except that if a field "
"value is ``None`` an empty (unquoted) string is written."
msgstr ""
"Ordena a los objetos :class:`writer` que entrecomillen todos los campos que "
"no sean ``None``.  Esto es similar a :data:`QUOTE_ALL`, excepto que si el "
"valor de un campo es ``None`` se escribe una cadena vacía (sin "
"entrecomillar)."

#: ../../library/csv.rst:352
msgid ""
"Instructs :class:`reader` objects to interpret an empty (unquoted) field as "
"``None`` and to otherwise behave as :data:`QUOTE_ALL`."
msgstr ""
"Indica a los objetos :class:`reader` que interpreten un campo vacío (sin "
"comillas) como ``None`` y que, por lo demás, se comporten como :data:"
"`QUOTE_ALL`."

#: ../../library/csv.rst:359
msgid ""
"Instructs :class:`writer` objects to always place quotes around fields which "
"are strings.  This is similar to :data:`QUOTE_NONNUMERIC`, except that if a "
"field value is ``None`` an empty (unquoted) string is written."
msgstr ""
"Indica a los objetos :class:`writer` que coloquen siempre comillas alrededor "
"de los campos que son cadenas.  Esto es similar a :data:`QUOTE_NONNUMERIC`, "
"excepto que si un valor de campo es ``None`` se escribe una cadena vacía "
"(sin comillas)."

#: ../../library/csv.rst:363
msgid ""
"Instructs :class:`reader` objects to interpret an empty (unquoted) string as "
"``None`` and to otherwise behave as :data:`QUOTE_NONNUMERIC`."
msgstr ""
"Indica a los objetos :class:`reader` que interpreten una cadena vacía (sin "
"comillas) como ``None`` y que se comporten como :data:`QUOTE_NONNUMERIC`."

#: ../../library/csv.rst:370
msgid ""
"Due to a bug, constants :data:`QUOTE_NOTNULL` and :data:`QUOTE_STRINGS` do "
"not affect behaviour of :class:`reader` objects. This bug is fixed in Python "
"3.13."
msgstr ""
"Debido a un error, las constantes :data:`QUOTE_NOTNULL` y :data:"
"`QUOTE_STRINGS` no afectan al comportamiento de los objetos :class:`reader`. "
"Este error se ha corregido en Python 3.13."

#: ../../library/csv.rst:374
msgid "The :mod:`csv` module defines the following exception:"
msgstr "El módulo :mod:`csv` define la siguiente excepción:"

#: ../../library/csv.rst:379
msgid "Raised by any of the functions when an error is detected."
msgstr "Activado por cualquiera de las funciones cuando se detecta un error."

#: ../../library/csv.rst:384
msgid "Dialects and Formatting Parameters"
msgstr "Dialectos y parámetros de formato"

#: ../../library/csv.rst:386
msgid ""
"To make it easier to specify the format of input and output records, "
"specific formatting parameters are grouped together into dialects.  A "
"dialect is a subclass of the :class:`Dialect` class containing various "
"attributes describing the format of the CSV file.  When creating :class:"
"`reader` or :class:`writer` objects, the programmer can specify a string or "
"a subclass of the :class:`Dialect` class as the dialect parameter.  In "
"addition to, or instead of, the *dialect* parameter, the programmer can also "
"specify individual formatting parameters, which have the same names as the "
"attributes defined below for the :class:`Dialect` class."
msgstr ""
"Para facilitar la especificación del formato de los registros de entrada y "
"salida, los parámetros de formato específicos se agrupan en dialectos.  Un "
"dialecto es una subclase de la clase :class:`Dialect` que contiene varios "
"atributos que describen el formato del archivo CSV.  Al crear objetos :class:"
"`reader` o :class:`writer`, el programador puede especificar una cadena o "
"una subclase de la clase :class:`Dialect` como parámetro de dialecto.  "
"Además del parámetro *dialect*, o en lugar de él, el programador también "
"puede especificar parámetros de formato individuales, que tienen los mismos "
"nombres que los atributos definidos a continuación para la clase :class:"
"`Dialect`."

#: ../../library/csv.rst:396
msgid "Dialects support the following attributes:"
msgstr "Los dialectos admiten los siguientes atributos:"

#: ../../library/csv.rst:401
msgid ""
"A one-character string used to separate fields.  It defaults to ``','``."
msgstr ""
"Cadena de un carácter utilizada para separar campos.  Por defecto es ``','``."

#: ../../library/csv.rst:406
msgid ""
"Controls how instances of *quotechar* appearing inside a field should "
"themselves be quoted.  When :const:`True`, the character is doubled. When :"
"const:`False`, the *escapechar* is used as a prefix to the *quotechar*.  It "
"defaults to :const:`True`."
msgstr ""
"Controla cómo deben entrecomillarse las instancias de *quotechar* que "
"aparecen dentro de un campo.  En :const:`True`, el carácter se duplica. En :"
"const:`False`, la *escapechar* se utiliza como prefijo de la *quotechar*.  "
"Por defecto es :const:`True`."

#: ../../library/csv.rst:411
msgid ""
"On output, if *doublequote* is :const:`False` and no *escapechar* is set, :"
"exc:`Error` is raised if a *quotechar* is found in a field."
msgstr ""
"En la salida, si *doublequote* es :const:`False` y no se establece "
"*escapechar*, :exc:`Error` aparece si se encuentra una *quotechar* en un "
"campo."

#: ../../library/csv.rst:417
msgid ""
"A one-character string used by the writer to escape the *delimiter* if "
"*quoting* is set to :const:`QUOTE_NONE` and the *quotechar* if *doublequote* "
"is :const:`False`. On reading, the *escapechar* removes any special meaning "
"from the following character. It defaults to :const:`None`, which disables "
"escaping."
msgstr ""
"Cadena de un carácter utilizada por el escritor para escapar del *delimiter* "
"si *quoting* está en :const:`QUOTE_NONE` y de la *quotechar* si "
"*doublequote* está en :const:`False`. Al leer, *escapechar* elimina "
"cualquier significado especial del carácter siguiente. Su valor por defecto "
"es :const:`None`, que desactiva el escape."

#: ../../library/csv.rst:422
msgid "An empty *escapechar* is not allowed."
msgstr "No se permite una *escapechar* vacía."

#: ../../library/csv.rst:427
msgid ""
"The string used to terminate lines produced by the :class:`writer`. It "
"defaults to ``'\\r\\n'``."
msgstr ""
"La cadena utilizada para terminar las líneas producidas por :class:`writer`. "
"Por defecto es ``'\\r\\n'``."

#: ../../library/csv.rst:432
msgid ""
"The :class:`reader` is hard-coded to recognise either ``'\\r'`` or ``'\\n'`` "
"as end-of-line, and ignores *lineterminator*. This behavior may change in "
"the future."
msgstr ""
"El código de :class:`reader` reconoce ``'\\r'`` o ``'\\n'`` como final de "
"línea e ignora *lineterminator*. Este comportamiento puede cambiar en el "
"futuro."

#: ../../library/csv.rst:439
msgid ""
"A one-character string used to quote fields containing special characters, "
"such as the *delimiter* or *quotechar*, or which contain new-line "
"characters.  It defaults to ``'\"'``."
msgstr ""
"Cadena de un carácter utilizada para citar campos que contienen caracteres "
"especiales, como el *delimiter* o *quotechar*, o que contienen caracteres de "
"nueva línea.  Por defecto es ``'\"'``."

#: ../../library/csv.rst:443
msgid "An empty *quotechar* is not allowed."
msgstr "No se permite una *quotechar* vacía."

#: ../../library/csv.rst:448
msgid ""
"Controls when quotes should be generated by the writer and recognised by the "
"reader.  It can take on any of the :ref:`QUOTE_\\* constants <csv-"
"constants>` and defaults to :const:`QUOTE_MINIMAL`."
msgstr ""
"Controla cuándo las comillas deben ser generadas por el escritor y "
"reconocidas por el lector.  Puede tomar cualquiera de las :ref:`QUOTE_\\* "
"constants <csv-constants>` y por defecto es :const:`QUOTE_MINIMAL`."

#: ../../library/csv.rst:455
msgid ""
"When :const:`True`, spaces immediately following the *delimiter* are "
"ignored. The default is :const:`False`."
msgstr ""
"En :const:`True`, se ignoran los espacios inmediatamente posteriores al "
"*delimiter*. El valor por defecto es :const:`False`."

#: ../../library/csv.rst:461
msgid ""
"When ``True``, raise exception :exc:`Error` on bad CSV input. The default is "
"``False``."
msgstr ""
"Cuando ``True``, lanza la excepción :exc:`Error` en caso de entrada CSV "
"errónea. El valor por defecto es ``False``."

#: ../../library/csv.rst:467
msgid "Reader Objects"
msgstr "Objetos de lectura"

#: ../../library/csv.rst:469
msgid ""
"Reader objects (:class:`DictReader` instances and objects returned by the :"
"func:`reader` function) have the following public methods:"
msgstr ""
"Los objetos de lectura (instancias de:class:`DictReader` y objetos devueltos "
"por la función :func:`reader` ) tienen los siguientes métodos públicos:"

#: ../../library/csv.rst:474
msgid ""
"Return the next row of the reader's iterable object as a list (if the object "
"was returned from :func:`reader`) or a dict (if it is a :class:`DictReader` "
"instance), parsed according to the current :class:`Dialect`.  Usually you "
"should call this as ``next(reader)``."
msgstr ""
"Devuelve la siguiente fila del objeto iterable del lector como una lista (si "
"el objeto fue devuelto desde :func:`reader`) o un dict (si se trata de una "
"instancia de :class:`DictReader` ), analizado de acuerdo con la actual :"
"class:`Dialect`.  Normalmente se debería llamar a esto como ``next(reader)``."

#: ../../library/csv.rst:480
msgid "Reader objects have the following public attributes:"
msgstr "Los objetos lectores tienen los siguientes atributos públicos:"

#: ../../library/csv.rst:484
msgid "A read-only description of the dialect in use by the parser."
msgstr ""
"Descripción de sólo lectura del dialecto utilizado por el analizador "
"sintáctico."

#: ../../library/csv.rst:489
msgid ""
"The number of lines read from the source iterator. This is not the same as "
"the number of records returned, as records can span multiple lines."
msgstr ""
"El número de líneas leídas del iterador fuente. No es lo mismo que el número "
"de registros devueltos, ya que los registros pueden abarcar varias líneas."

#: ../../library/csv.rst:493
msgid "DictReader objects have the following public attribute:"
msgstr "Los objetos DictReader tienen el siguiente atributo público:"

#: ../../library/csv.rst:497
msgid ""
"If not passed as a parameter when creating the object, this attribute is "
"initialized upon first access or when the first record is read from the file."
msgstr ""
"Si no se pasa como parámetro al crear el objeto, este atributo se inicializa "
"en el primer acceso o cuando se lee el primer registro del archivo."

#: ../../library/csv.rst:504
msgid "Writer Objects"
msgstr "Objetos del escritor"

#: ../../library/csv.rst:506
msgid ""
":class:`writer` objects (:class:`DictWriter` instances and objects returned "
"by the :func:`writer` function) have the following public methods.  A *row* "
"must be an iterable of strings or numbers for :class:`writer` objects and a "
"dictionary mapping fieldnames to strings or numbers (by passing them "
"through :func:`str` first) for :class:`DictWriter` objects.  Note that "
"complex numbers are written out surrounded by parens. This may cause some "
"problems for other programs which read CSV files (assuming they support "
"complex numbers at all)."
msgstr ""
":class:`writer` (instancias de:class:`DictWriter` y objetos devueltos por la "
"función :func:`writer` ) tienen los siguientes métodos públicos.  Una *fila* "
"debe ser un iterable de cadenas o números para los objetos :class:`writer` y "
"un diccionario que asigne nombres de campo a cadenas o números (pasándolos "
"primero por :func:`str` ) para los objetos :class:`DictWriter`.  Tenga en "
"cuenta que los números complejos se escriben rodeados de paréntesis. Esto "
"puede causar algunos problemas a otros programas que lean archivos CSV "
"(suponiendo que admitan números complejos)."

#: ../../library/csv.rst:517
msgid ""
"Write the *row* parameter to the writer's file object, formatted according "
"to the current :class:`Dialect`. Return the return value of the call to the "
"*write* method of the underlying file object."
msgstr ""
"Escribe el parámetro *row* en el objeto de archivo del escritor, formateado "
"según el :class:`Dialect` actual. Devuelve el valor de retorno de la llamada "
"al método *write* del objeto archivo subyacente."

#: ../../library/csv.rst:521
msgid "Added support of arbitrary iterables."
msgstr "Añadido soporte de iterables arbitrarios."

#: ../../library/csv.rst:526
msgid ""
"Write all elements in *rows* (an iterable of *row* objects as described "
"above) to the writer's file object, formatted according to the current "
"dialect."
msgstr ""
"Escribe todos los elementos de *rows* (un iterable de objetos *row* como se "
"ha descrito anteriormente) en el objeto file del escritor, formateado según "
"el dialecto actual."

#: ../../library/csv.rst:530
msgid "Writer objects have the following public attribute:"
msgstr "Los objetos Writer tienen el siguiente atributo público:"

#: ../../library/csv.rst:535
msgid "A read-only description of the dialect in use by the writer."
msgstr "Descripción de sólo lectura del dialecto utilizado por el escritor."

#: ../../library/csv.rst:538
msgid "DictWriter objects have the following public method:"
msgstr "Los objetos DictWriter tienen el siguiente método público:"

#: ../../library/csv.rst:543
msgid ""
"Write a row with the field names (as specified in the constructor) to the "
"writer's file object, formatted according to the current dialect. Return the "
"return value of the :meth:`csvwriter.writerow` call used internally."
msgstr ""
"Escribe una fila con los nombres de campo (como se especifica en el "
"constructor) en el objeto archivo del escritor, formateado según el dialecto "
"actual. Devuelve el valor de retorno de la llamada :meth:`csvwriter."
"writerow` utilizada internamente."

#: ../../library/csv.rst:548
msgid ""
":meth:`writeheader` now also returns the value returned by the :meth:"
"`csvwriter.writerow` method it uses internally."
msgstr ""
":meth:`writeheader` ahora también devuelve el valor devuelto por el método :"
"meth:`csvwriter.writerow` que utiliza internamente."

#: ../../library/csv.rst:556
msgid "Examples"
msgstr "Ejemplos"

#: ../../library/csv.rst:558
msgid "The simplest example of reading a CSV file::"
msgstr "El ejemplo más sencillo de lectura de un archivo CSV::"

#: ../../library/csv.rst:560
msgid ""
"import csv\n"
"with open('some.csv', newline='') as f:\n"
"    reader = csv.reader(f)\n"
"    for row in reader:\n"
"        print(row)"
msgstr ""
"import csvwith open('some.csv', newline='') as f:    reader = csv."
"reader(f)    for row in reader:        print(row)"

#: ../../library/csv.rst:566
msgid "Reading a file with an alternate format::"
msgstr "Lectura de un fichero con un formato alternativo::"

#: ../../library/csv.rst:568
msgid ""
"import csv\n"
"with open('passwd', newline='') as f:\n"
"    reader = csv.reader(f, delimiter=':', quoting=csv.QUOTE_NONE)\n"
"    for row in reader:\n"
"        print(row)"
msgstr ""
"import csvwith open('passwd', newline='') as f:    reader = csv.reader(f, "
"delimiter=':', quoting=csv.QUOTE_NONE)    for row in reader:        "
"print(row)"

#: ../../library/csv.rst:574
msgid "The corresponding simplest possible writing example is::"
msgstr "El ejemplo de escritura más sencillo posible es::"

#: ../../library/csv.rst:576
msgid ""
"import csv\n"
"with open('some.csv', 'w', newline='') as f:\n"
"    writer = csv.writer(f)\n"
"    writer.writerows(someiterable)"
msgstr ""
"import csvwith open('some.csv', 'w', newline='') as f:    writer = csv."
"writer(f)    writer.writerows(someiterable)"

#: ../../library/csv.rst:581
msgid ""
"Since :func:`open` is used to open a CSV file for reading, the file will by "
"default be decoded into unicode using the system default encoding (see :func:"
"`locale.getencoding`).  To decode a file using a different encoding, use the "
"``encoding`` argument of open::"
msgstr ""
"Dado que :func:`open` se utiliza para abrir un archivo CSV para su lectura, "
"el archivo se descodificará por defecto en unicode utilizando la "
"codificación por defecto del sistema (véase :func:`locale.getencoding`).  "
"Para decodificar un archivo utilizando una codificación diferente, utilice "
"el argumento ``encoding`` de open::"

#: ../../library/csv.rst:586
msgid ""
"import csv\n"
"with open('some.csv', newline='', encoding='utf-8') as f:\n"
"    reader = csv.reader(f)\n"
"    for row in reader:\n"
"        print(row)"
msgstr ""
"import csvwith open('some.csv', newline='', encoding='utf-8') as f:    "
"reader = csv.reader(f)    for row in reader:        print(row)"

#: ../../library/csv.rst:592
msgid ""
"The same applies to writing in something other than the system default "
"encoding: specify the encoding argument when opening the output file."
msgstr ""
"Lo mismo se aplica para escribir en una codificación distinta de la "
"predeterminada del sistema: especifique el argumento de codificación al "
"abrir el archivo de salida."

#: ../../library/csv.rst:595
msgid "Registering a new dialect::"
msgstr "Registrar un nuevo dialecto::"

#: ../../library/csv.rst:597
msgid ""
"import csv\n"
"csv.register_dialect('unixpwd', delimiter=':', quoting=csv.QUOTE_NONE)\n"
"with open('passwd', newline='') as f:\n"
"    reader = csv.reader(f, 'unixpwd')"
msgstr ""
"import csvcsv.register_dialect('unixpwd', delimiter=':', quoting=csv."
"QUOTE_NONE)with open('passwd', newline='') as f:    reader = csv.reader(f, "
"'unixpwd')"

#: ../../library/csv.rst:602
msgid ""
"A slightly more advanced use of the reader --- catching and reporting "
"errors::"
msgstr ""
"Un uso un poco más avanzado del lector --- la captura y notificación de "
"errores::"

#: ../../library/csv.rst:604
msgid ""
"import csv, sys\n"
"filename = 'some.csv'\n"
"with open(filename, newline='') as f:\n"
"    reader = csv.reader(f)\n"
"    try:\n"
"        for row in reader:\n"
"            print(row)\n"
"    except csv.Error as e:\n"
"        sys.exit('file {}, line {}: {}'.format(filename, reader.line_num, e))"
msgstr ""
"import csv, sysfilename = 'some.csv'with open(filename, newline='') as f:    "
"reader = csv.reader(f)    try:        for row in reader:            "
"print(row)    except csv.Error as e:        sys.exit('file {}, line {}: {}'."
"format(filename, reader.line_num, e))"

#: ../../library/csv.rst:614
msgid ""
"And while the module doesn't directly support parsing strings, it can easily "
"be done::"
msgstr ""
"Y aunque el módulo no soporta directamente el análisis sintáctico de "
"cadenas, se puede hacer fácilmente::"

#: ../../library/csv.rst:617
msgid ""
"import csv\n"
"for row in csv.reader(['one,two,three']):\n"
"    print(row)"
msgstr "import csvfor row in csv.reader(['one,two,three']):    print(row)"

#: ../../library/csv.rst:623
msgid "Footnotes"
msgstr "Notas a pie de página"

#: ../../library/csv.rst:624
msgid ""
"If ``newline=''`` is not specified, newlines embedded inside quoted fields "
"will not be interpreted correctly, and on platforms that use ``\\r\\n`` "
"linendings on write an extra ``\\r`` will be added.  It should always be "
"safe to specify ``newline=''``, since the csv module does its own (:term:"
"`universal <universal newlines>`) newline handling."
msgstr ""
"Si no se especifica ``newline=''``, las nuevas líneas incrustadas dentro de "
"campos entrecomillados no se interpretarán correctamente, y en plataformas "
"que utilicen ``\\r\\n`` se añadirá una ``\\r`` extra.  Siempre debería ser "
"seguro especificar ``newline=''``, ya que el módulo csv hace su propio (:"
"term:`universal <universal newlines>`) manejo de nuevas líneas."

#: ../../library/csv.rst:11
msgid "csv"
msgstr "csv"

#: ../../library/csv.rst:11
msgid "data"
msgstr "data"

#: ../../library/csv.rst:11
msgid "tabular"
msgstr "tabular"

#: ../../library/csv.rst:53
msgid "universal newlines"
msgstr "nuevas líneas universales"

#: ../../library/csv.rst:53
msgid "csv.reader function"
msgstr "Función csv.reader"
