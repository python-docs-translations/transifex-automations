# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# eulalio barbero espinosa <eulalio@disroot.org>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-23 18:28+0000\n"
"PO-Revision-Date: 2025-09-22 17:54+0000\n"
"Last-Translator: eulalio barbero espinosa <eulalio@disroot.org>, 2025\n"
"Language-Team: Spanish (Spain) (https://app.transifex.com/python-doc/"
"teams/5390/es_ES/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es_ES\n"
"Plural-Forms: nplurals=3; plural=n == 1 ? 0 : n != 0 && n % 1000000 == 0 ? "
"1 : 2;\n"

#: ../../library/configparser.rst:2
msgid ":mod:`configparser` --- Configuration file parser"
msgstr ""

#: ../../library/configparser.rst:14
msgid "**Source code:** :source:`Lib/configparser.py`"
msgstr "**Código fuente:** :source:`Lib/configparser.py`"

#: ../../library/configparser.rst:24
msgid ""
"This module provides the :class:`ConfigParser` class which implements a "
"basic configuration language which provides a structure similar to what's "
"found in Microsoft Windows INI files.  You can use this to write Python "
"programs which can be customized by end users easily."
msgstr ""
"Este módulo proporciona la clase :class:`ConfigParser` que implementa un "
"lenguaje de configuración básico que proporciona una estructura similar a la "
"que se encuentra en los archivos INI de Microsoft Windows.  Puedes usar esto "
"para escribir programas Python que pueden ser personalizados por usuarios "
"finales fácilmente."

#: ../../library/configparser.rst:31
msgid ""
"This library does *not* interpret or write the value-type prefixes used in "
"the Windows Registry extended version of INI syntax."
msgstr ""
"Esta biblioteca *no* interpreta ni escribe los prefijos de tipo valor "
"utilizados en la versión extendida del Registro de Windows de la sintaxis "
"INI."

#: ../../library/configparser.rst:38
msgid "Module :mod:`shlex`"
msgstr "Módulo :mod:`shlex`"

#: ../../library/configparser.rst:37
msgid ""
"Support for creating Unix shell-like mini-languages which can be used as an "
"alternate format for application configuration files."
msgstr ""

#: ../../library/configparser.rst:41
msgid "Module :mod:`json`"
msgstr "Módulo :mod:`json`"

#: ../../library/configparser.rst:41
msgid ""
"The json module implements a subset of JavaScript syntax which can also be "
"used for this purpose."
msgstr ""

#: ../../library/configparser.rst:56
msgid "Quick Start"
msgstr "Inicio rápido"

#: ../../library/configparser.rst:58
msgid "Let's take a very basic configuration file that looks like this:"
msgstr ""
"Tomemos un fichero de configuración muy básico con el siguiente aspecto:"

#: ../../library/configparser.rst:75
msgid ""
"The structure of INI files is described `in the following section "
"<#supported-ini-file-structure>`_.  Essentially, the file consists of "
"sections, each of which contains keys with values. :mod:`configparser` "
"classes can read and write such files.  Let's start by creating the above "
"configuration file programmatically."
msgstr ""
"La estructura de los ficheros INI se describe `en la siguiente sección "
"<#supported-ini-file-structure>`_.  Esencialmente, el fichero consiste en "
"secciones, cada una de las cuales contiene claves con valores. Las clases :"
"mod:`configparser` pueden leer y escribir tales ficheros.  Empecemos creando "
"el fichero de configuración anterior mediante programación."

#: ../../library/configparser.rst:99
msgid ""
"As you can see, we can treat a config parser much like a dictionary. There "
"are differences, `outlined later <#mapping-protocol-access>`_, but the "
"behavior is very close to what you would expect from a dictionary."
msgstr ""
"Como puedes ver, podemos tratar un analizador de configuración como un "
"diccionario. Hay diferencias, `resumidas más adelante <#mapping-protocol-"
"access>`_, pero el comportamiento es muy parecido a lo que cabría esperar de "
"un diccionario."

#: ../../library/configparser.rst:103
msgid ""
"Now that we have created and saved a configuration file, let's read it back "
"and explore the data it holds."
msgstr ""
"Ahora que hemos creado y guardado un archivo de configuración, vamos a "
"leerlo y explorar los datos que contiene."

#: ../../library/configparser.rst:138
msgid ""
"As we can see above, the API is pretty straightforward.  The only bit of "
"magic involves the ``DEFAULT`` section which provides default values for all "
"other sections [1]_.  Note also that keys in sections are case-insensitive "
"and stored in lowercase [1]_."
msgstr ""
"Como vemos, la API es bastante sencilla.  La única parte mágica tiene que "
"ver con la sección ``DEFAULT``, que proporciona valores por defecto para "
"todas las demás secciones [1]_.  Ten en cuenta también que las claves de las "
"secciones no distinguen entre mayúsculas y minúsculas y se almacenan en "
"minúsculas [1]_."

#: ../../library/configparser.rst:145
msgid "Supported Datatypes"
msgstr "Tipos de datos admitidos"

#: ../../library/configparser.rst:147
msgid ""
"Config parsers do not guess datatypes of values in configuration files, "
"always storing them internally as strings.  This means that if you need "
"other datatypes, you should convert on your own:"
msgstr ""
"Los analizadores sintácticos de configuración no adivinan los tipos de datos "
"de los valores en los archivos de configuración, almacenándolos siempre "
"internamente como cadenas.  Esto significa que si necesitas otros tipos de "
"datos, debes convertirlos por tu cuenta:"

#: ../../library/configparser.rst:158
msgid ""
"Since this task is so common, config parsers provide a range of handy getter "
"methods to handle integers, floats and booleans.  The last one is the most "
"interesting because simply passing the value to ``bool()`` would do no good "
"since ``bool('False')`` is still ``True``.  This is why config parsers also "
"provide :meth:`~ConfigParser.getboolean`.  This method is case-insensitive "
"and recognizes Boolean values from ``'yes'``/``'no'``, ``'on'``/``'off'``, "
"``'true'``/``'false'`` and ``'1'``/``'0'`` [1]_.  For example:"
msgstr ""
"Dado que esta tarea es tan común, los analizadores de configuraciones "
"proporcionan una serie de prácticos métodos de obtención para manejar "
"enteros, flotantes y booleanos.  Este último es el más interesante, porque "
"pasar el valor a ``bool()`` no serviría de nada, ya que ``bool('False')`` "
"sigue siendo ``True``.  Esta es la razón por la que los analizadores de "
"configuración también proporcionan :meth:`~ConfigParser.getboolean`.  Este "
"método no distingue entre mayúsculas y minúsculas y reconoce los valores "
"booleanos de ``'yes'``/``'no'``, ``'on'``/``'off'``, ``'true'``/``'false'`` "
"y ``'1'``/``'0'`` [1]_ .  Por ejemplo:"

#: ../../library/configparser.rst:175
msgid ""
"Apart from :meth:`~ConfigParser.getboolean`, config parsers also provide "
"equivalent :meth:`~ConfigParser.getint` and :meth:`~ConfigParser.getfloat` "
"methods.  You can register your own converters and customize the provided "
"ones. [1]_"
msgstr ""
"Aparte de :meth:`~ConfigParser.getboolean`, los analizadores sintácticos "
"config también proporcionan métodos equivalentes :meth:`~ConfigParser."
"getint` y :meth:`~ConfigParser.getfloat`.  Puedes registrar tus propios "
"conversores y personalizar los proporcionados. [1]_"

#: ../../library/configparser.rst:181
msgid "Fallback Values"
msgstr "Valores de reserva"

#: ../../library/configparser.rst:183
msgid ""
"As with a dictionary, you can use a section's :meth:`get` method to provide "
"fallback values:"
msgstr ""

#: ../../library/configparser.rst:196
msgid ""
"Please note that default values have precedence over fallback values. For "
"instance, in our example the ``'CompressionLevel'`` key was specified only "
"in the ``'DEFAULT'`` section.  If we try to get it from the section "
"``'topsecret.server.com'``, we will always get the default, even if we "
"specify a fallback:"
msgstr ""

#: ../../library/configparser.rst:207
msgid ""
"One more thing to be aware of is that the parser-level :meth:`get` method "
"provides a custom, more complex interface, maintained for backwards "
"compatibility.  When using this method, a fallback value can be provided via "
"the ``fallback`` keyword-only argument:"
msgstr ""

#: ../../library/configparser.rst:218
msgid ""
"The same ``fallback`` argument can be used with the :meth:`~ConfigParser."
"getint`, :meth:`~ConfigParser.getfloat` and :meth:`~ConfigParser.getboolean` "
"methods, for example:"
msgstr ""
"El mismo argumento ``fallback`` puede utilizarse con los métodos :meth:"
"`~ConfigParser.getint`, :meth:`~ConfigParser.getfloat` y :meth:"
"`~ConfigParser.getboolean`, por ejemplo:"

#: ../../library/configparser.rst:234
msgid "Supported INI File Structure"
msgstr "Estructura de archivos INI compatibles"

#: ../../library/configparser.rst:236
msgid ""
"A configuration file consists of sections, each led by a ``[section]`` "
"header, followed by key/value entries separated by a specific string (``=`` "
"or ``:`` by default [1]_).  By default, section names are case sensitive but "
"keys are not [1]_.  Leading and trailing whitespace is removed from keys and "
"values. Values can be omitted if the parser is configured to allow it [1]_, "
"in which case the key/value delimiter may also be left out.  Values can also "
"span multiple lines, as long as they are indented deeper than the first line "
"of the value.  Depending on the parser's mode, blank lines may be treated as "
"parts of multiline values or ignored."
msgstr ""
"Un archivo de configuración consta de secciones, cada una encabezada por una "
"cabecera ``[section]``, seguida de entradas clave/valor separadas por una "
"cadena específica (``=`` o ``:`` por defecto [1]_).  Por defecto, los "
"nombres de las secciones distinguen entre mayúsculas y minúsculas, pero las "
"claves no [1]_.  Los espacios en blanco iniciales y finales se eliminan de "
"las claves y los valores. Los valores pueden omitirse si el analizador "
"sintáctico está configurado para permitirlo [1]_, en cuyo caso también puede "
"omitirse el delimitador clave/valor.  Los valores también pueden abarcar "
"varias líneas, siempre que tengan una sangría más profunda que la primera "
"línea del valor.  Dependiendo del modo del analizador sintáctico, las líneas "
"en blanco pueden tratarse como partes de valores multilínea o ignorarse."

#: ../../library/configparser.rst:246
msgid ""
"By default,  a valid section name can be any string that does not contain '\\"
"\\n' or ']'. To change this, see :attr:`ConfigParser.SECTCRE`."
msgstr ""

#: ../../library/configparser.rst:249
msgid ""
"Configuration files may include comments, prefixed by specific characters "
"(``#`` and ``;`` by default [1]_).  Comments may appear on their own on an "
"otherwise empty line, possibly indented. [1]_"
msgstr ""
"Los archivos de configuración pueden incluir comentarios, precedidos por "
"caracteres específicos (``#`` y ``;`` por defecto [1]_).  Los comentarios "
"pueden aparecer solos en una línea vacía, posiblemente con sangría. [1]_"

#: ../../library/configparser.rst:253 ../../library/configparser.rst:316
msgid "For example:"
msgstr "Por ejemplo:"

#: ../../library/configparser.rst:301
msgid "Interpolation of values"
msgstr "Interpolación de valores"

#: ../../library/configparser.rst:303
msgid ""
"On top of the core functionality, :class:`ConfigParser` supports "
"interpolation.  This means values can be preprocessed before returning them "
"from ``get()`` calls."
msgstr ""
"Además de la funcionalidad básica, :class:`ConfigParser` admite "
"interpolación.  Esto significa que los valores pueden preprocesarse antes de "
"ser devueltos por las llamadas a ``get()``."

#: ../../library/configparser.rst:311
msgid ""
"The default implementation used by :class:`ConfigParser`.  It enables values "
"to contain format strings which refer to other values in the same section, "
"or values in the special default section [1]_.  Additional default values "
"can be provided on initialization."
msgstr ""
"La implementación por defecto utilizada por :class:`ConfigParser`.  Permite "
"que los valores contengan cadenas de formato que hagan referencia a otros "
"valores de la misma sección o a valores de la sección especial por defecto "
"[1]_.  Se pueden proporcionar valores por defecto adicionales en la "
"inicialización."

#: ../../library/configparser.rst:329
msgid ""
"In the example above, :class:`ConfigParser` with *interpolation* set to "
"``BasicInterpolation()`` would resolve ``%(home_dir)s`` to the value of "
"``home_dir`` (``/Users`` in this case).  ``%(my_dir)s`` in effect would "
"resolve to ``/Users/lumberjack``.  All interpolations are done on demand so "
"keys used in the chain of references do not have to be specified in any "
"specific order in the configuration file."
msgstr ""
"En el ejemplo anterior, :class:`ConfigParser` con *interpolación* "
"establecida en ``BasicInterpolation()`` resolvería ``%(home_dir)s`` al valor "
"de ``home_dir`` (``/Users`` en este caso). ``%(my_dir)s`` en efecto "
"resolvería a ``/Users/lumberjack``.  Todas las interpolaciones se realizan "
"bajo demanda, por lo que las claves utilizadas en la cadena de referencias "
"no tienen que especificarse en ningún orden concreto en el archivo de "
"configuración."

#: ../../library/configparser.rst:336
msgid ""
"With ``interpolation`` set to ``None``, the parser would simply return "
"``%(my_dir)s/Pictures`` as the value of ``my_pictures`` and ``%(home_dir)s/"
"lumberjack`` as the value of ``my_dir``."
msgstr ""
"Con ``interpolation`` establecido en ``None``, el analizador sintáctico "
"simplemente devolvería ``%(my_dir)s/Pictures`` como valor de ``my_pictures`` "
"y ``%(home_dir)s/lumberjack`` como valor de ``my_dir``."

#: ../../library/configparser.rst:344
msgid ""
"An alternative handler for interpolation which implements a more advanced "
"syntax, used for instance in ``zc.buildout``.  Extended interpolation is "
"using ``${section:option}`` to denote a value from a foreign section. "
"Interpolation can span multiple levels.  For convenience, if the ``section:"
"`` part is omitted, interpolation defaults to the current section (and "
"possibly the default values from the special section)."
msgstr ""
"Un manejador alternativo para la interpolación que implementa una sintaxis "
"más avanzada, utilizada por ejemplo en ``zc.buildout``.  La interpolación "
"ampliada consiste en utilizar ``${section:option}`` para denotar un valor de "
"una sección ajena. La interpolación puede abarcar varios niveles.  Por "
"comodidad, si se omite la parte ``section:``, la interpolación se realiza "
"por defecto en la sección actual (y posiblemente en los valores por defecto "
"de la sección especial)."

#: ../../library/configparser.rst:351
msgid ""
"For example, the configuration specified above with basic interpolation, "
"would look like this with extended interpolation:"
msgstr ""
"Por ejemplo, la configuración especificada anteriormente con interpolación "
"básica, tendría este aspecto con interpolación ampliada:"

#: ../../library/configparser.rst:365
msgid "Values from other sections can be fetched as well:"
msgstr "También se pueden obtener valores de otras secciones:"

#: ../../library/configparser.rst:387
msgid "Mapping Protocol Access"
msgstr "Asignación de protocolos de acceso"

#: ../../library/configparser.rst:391
msgid ""
"Mapping protocol access is a generic name for functionality that enables "
"using custom objects as if they were dictionaries.  In case of :mod:"
"`configparser`, the mapping interface implementation is using the "
"``parser['section']['option']`` notation."
msgstr ""
"El acceso al protocolo de mapeo es un nombre genérico para la funcionalidad "
"que permite utilizar objetos personalizados como si fueran diccionarios.  En "
"el caso de :mod:`configparser`, la implementación de la interfaz de mapeo "
"utiliza la notación ``parser['section']['option']``."

#: ../../library/configparser.rst:396
msgid ""
"``parser['section']`` in particular returns a proxy for the section's data "
"in the parser.  This means that the values are not copied but they are taken "
"from the original parser on demand.  What's even more important is that when "
"values are changed on a section proxy, they are actually mutated in the "
"original parser."
msgstr ""
"``parser['section']`` en particular, devuelve un proxy para los datos de la "
"sección en el analizador sintáctico.  Esto significa que los valores no se "
"copian, sino que se toman del analizador sintáctico original bajo demanda.  "
"Lo que es aún más importante es que cuando los valores se cambian en un "
"proxy de sección, en realidad se mutan en el analizador sintáctico original."

#: ../../library/configparser.rst:402
msgid ""
":mod:`configparser` objects behave as close to actual dictionaries as "
"possible. The mapping interface is complete and adheres to the :class:"
"`~collections.abc.MutableMapping` ABC. However, there are a few differences "
"that should be taken into account:"
msgstr ""
":mod:`configparser` se comportan de la forma más parecida posible a los "
"diccionarios reales. La interfaz de mapeo es completa y se ciñe al ABC de :"
"class:`~collections.abc.MutableMapping`. Sin embargo, hay algunas "
"diferencias que deben tenerse en cuenta:"

#: ../../library/configparser.rst:407
msgid ""
"By default, all keys in sections are accessible in a case-insensitive manner "
"[1]_.  E.g. ``for option in parser[\"section\"]`` yields only "
"``optionxform``'ed option key names.  This means lowercased keys by "
"default.  At the same time, for a section that holds the key ``'a'``, both "
"expressions return ``True``::"
msgstr ""
"Por defecto, todas las claves de las secciones son accesibles sin distinción "
"entre mayúsculas y minúsculas [1]_.  Por ejemplo, ``for option in "
"parser[\"section\"]`` sólo muestra los nombres de las claves de opción de "
"``optionxform``.  Esto significa que, por defecto, las claves se escriben en "
"minúsculas.  Al mismo tiempo, para una sección que contiene la clave "
"``'a'``, ambas expresiones devuelven ``True``::"

#: ../../library/configparser.rst:415
msgid ""
"All sections include ``DEFAULTSECT`` values as well which means that ``."
"clear()`` on a section may not leave the section visibly empty.  This is "
"because default values cannot be deleted from the section (because "
"technically they are not there).  If they are overridden in the section, "
"deleting causes the default value to be visible again.  Trying to delete a "
"default value causes a :exc:`KeyError`."
msgstr ""
"Todas las secciones incluyen también valores ``DEFAULTSECT``, lo que "
"significa que ``.clear()`` en una sección no puede dejar la sección "
"visiblemente vacía.  Esto se debe a que los valores por defecto no pueden "
"borrarse de la sección (porque técnicamente no están ahí).  Si se anulan en "
"la sección, al borrarlos el valor por defecto vuelve a ser visible.  Si se "
"intenta eliminar un valor por defecto, se produce un error en :exc:"
"`KeyError`."

#: ../../library/configparser.rst:422
msgid "``DEFAULTSECT`` cannot be removed from the parser:"
msgstr "``DEFAULTSECT`` no puede eliminarse del analizador sintáctico:"

#: ../../library/configparser.rst:424
msgid "trying to delete it raises :exc:`ValueError`,"
msgstr "al intentar borrarlo aparece :exc:`ValueError`,"

#: ../../library/configparser.rst:426
msgid "``parser.clear()`` leaves it intact,"
msgstr "``parser.clear()`` lo deja intacto,"

#: ../../library/configparser.rst:428
msgid "``parser.popitem()`` never returns it."
msgstr "``parser.popitem()`` nunca lo devuelve."

#: ../../library/configparser.rst:430
msgid ""
"``parser.get(section, option, **kwargs)`` - the second argument is **not** a "
"fallback value.  Note however that the section-level ``get()`` methods are "
"compatible both with the mapping protocol and the classic configparser API."
msgstr ""
"``parser.get(section, option, **kwargs)`` - el segundo argumento **no** es "
"un valor fallback.  Tenga en cuenta, no obstante, que los métodos ``get()`` "
"a nivel de sección son compatibles tanto con el protocolo de mapeo como con "
"la API configparser clásica."

#: ../../library/configparser.rst:434
msgid ""
"``parser.items()`` is compatible with the mapping protocol (returns a list "
"of *section_name*, *section_proxy* pairs including the DEFAULTSECT).  "
"However, this method can also be invoked with arguments: ``parser."
"items(section, raw, vars)``.  The latter call returns a list of *option*, "
"*value* pairs for a specified ``section``, with all interpolations expanded "
"(unless ``raw=True`` is provided)."
msgstr ""
"``parser.items()`` es compatible con el protocolo de mapeo (devuelve una "
"lista de pares *section_name*, *section_proxy* incluyendo el DEFAULTSECT).  "
"Sin embargo, este método también puede invocarse con argumentos: ``parser."
"items(section, raw, vars)``.  Esta última llamada devuelve una lista de "
"pares *option*, *value* para un ``section`` especificado, con todas las "
"interpolaciones expandidas (a menos que se proporcione ``raw=True`` )."

#: ../../library/configparser.rst:441
msgid ""
"The mapping protocol is implemented on top of the existing legacy API so "
"that subclasses overriding the original interface still should have mappings "
"working as expected."
msgstr ""
"El protocolo de mapeo se implementa sobre la API heredada existente, de modo "
"que las subclases que sobrescriben la interfaz original deberían seguir "
"utilizando los mapeos de la forma esperada."

#: ../../library/configparser.rst:447
msgid "Customizing Parser Behaviour"
msgstr "Personalización del comportamiento del analizador sintáctico"

#: ../../library/configparser.rst:449
msgid ""
"There are nearly as many INI format variants as there are applications using "
"it. :mod:`configparser` goes a long way to provide support for the largest "
"sensible set of INI styles available.  The default functionality is mainly "
"dictated by historical background and it's very likely that you will want to "
"customize some of the features."
msgstr ""
"Existen casi tantas variantes de formato INI como aplicaciones que lo "
"utilizan. :mod:`configparser` hace todo lo posible por ofrecer "
"compatibilidad con el mayor conjunto razonable de estilos INI disponible.  "
"La funcionalidad por defecto está dictada principalmente por antecedentes "
"históricos y es muy probable que quieras personalizar algunas de las "
"características."

#: ../../library/configparser.rst:455
msgid ""
"The most common way to change the way a specific config parser works is to "
"use the :meth:`__init__` options:"
msgstr ""

#: ../../library/configparser.rst:458
msgid "*defaults*, default value: ``None``"
msgstr "*defaults*, valor por defecto: ``None``"

#: ../../library/configparser.rst:460
msgid ""
"This option accepts a dictionary of key-value pairs which will be initially "
"put in the ``DEFAULT`` section.  This makes for an elegant way to support "
"concise configuration files that don't specify values which are the same as "
"the documented default."
msgstr ""
"Esta opción acepta un diccionario de pares clave-valor que se colocarán "
"inicialmente en la sección ``DEFAULT``.  Es una forma elegante de admitir "
"archivos de configuración concisos que no especifiquen valores iguales a los "
"predeterminados documentados."

#: ../../library/configparser.rst:465
msgid ""
"Hint: if you want to specify default values for a specific section, use :"
"meth:`read_dict` before you read the actual file."
msgstr ""

#: ../../library/configparser.rst:468
msgid "*dict_type*, default value: :class:`dict`"
msgstr "*dict_type*, valor por defecto: :class:`dict`"

#: ../../library/configparser.rst:470
msgid ""
"This option has a major impact on how the mapping protocol will behave and "
"how the written configuration files look.  With the standard dictionary, "
"every section is stored in the order they were added to the parser.  Same "
"goes for options within sections."
msgstr ""
"Esta opción tiene un gran impacto en el comportamiento del protocolo de "
"mapeo y en el aspecto de los archivos de configuración escritos.  Con el "
"diccionario estándar, cada sección se almacena en el orden en que se "
"añadieron al analizador sintáctico.  Lo mismo ocurre con las opciones dentro "
"de las secciones."

#: ../../library/configparser.rst:475
msgid ""
"An alternative dictionary type can be used for example to sort sections and "
"options on write-back."
msgstr ""
"Se puede utilizar un tipo de diccionario alternativo, por ejemplo, para "
"clasificar secciones y opciones en la reescritura."

#: ../../library/configparser.rst:478
msgid ""
"Please note: there are ways to add a set of key-value pairs in a single "
"operation.  When you use a regular dictionary in those operations, the order "
"of the keys will be ordered.  For example:"
msgstr ""
"Atención: hay formas de añadir un conjunto de pares clave-valor en una sola "
"operación.  Cuando utilice un diccionario normal en esas operaciones, el "
"orden de las claves será ordenado.  Por ejemplo:"

#: ../../library/configparser.rst:500
msgid "*allow_no_value*, default value: ``False``"
msgstr "*allow_no_value*, valor por defecto: ``False``"

#: ../../library/configparser.rst:502
msgid ""
"Some configuration files are known to include settings without values, but "
"which otherwise conform to the syntax supported by :mod:`configparser`.  The "
"*allow_no_value* parameter to the constructor can be used to indicate that "
"such values should be accepted:"
msgstr ""
"Se sabe que algunos archivos de configuración incluyen opciones sin valores, "
"pero que por lo demás se ajustan a la sintaxis admitida por :mod:"
"`configparser`.  El parámetro *allow_no_value* del constructor puede "
"utilizarse para indicar que se deben aceptar dichos valores:"

#: ../../library/configparser.rst:537
msgid "*delimiters*, default value: ``('=', ':')``"
msgstr "*delimiters*, valor por defecto: ``('=', ':')``"

#: ../../library/configparser.rst:539
msgid ""
"Delimiters are substrings that delimit keys from values within a section. "
"The first occurrence of a delimiting substring on a line is considered a "
"delimiter.  This means values (but not keys) can contain the delimiters."
msgstr ""
"Los delimitadores son subcadenas que delimitan las claves de los valores "
"dentro de una sección. La primera aparición de una subcadena delimitadora en "
"una línea se considera un delimitador.  Esto significa que los valores (pero "
"no las claves) pueden contener delimitadores."

#: ../../library/configparser.rst:543
msgid ""
"See also the *space_around_delimiters* argument to :meth:`ConfigParser."
"write`."
msgstr ""
"Véase también el argumento *space_around_delimiters* de :meth:`ConfigParser."
"write`."

#: ../../library/configparser.rst:546
msgid "*comment_prefixes*, default value: ``('#', ';')``"
msgstr "*comment_prefixes*, valor por defecto: ``('#', ';')``"

#: ../../library/configparser.rst:548
msgid "*inline_comment_prefixes*, default value: ``None``"
msgstr "*inline_comment_prefixes*, valor por defecto: ``None``"

#: ../../library/configparser.rst:550
msgid ""
"Comment prefixes are strings that indicate the start of a valid comment "
"within a config file. *comment_prefixes* are used only on otherwise empty "
"lines (optionally indented) whereas *inline_comment_prefixes* can be used "
"after every valid value (e.g. section names, options and empty lines as "
"well).  By default inline comments are disabled and ``'#'`` and ``';'`` are "
"used as prefixes for whole line comments."
msgstr ""
"Los prefijos de comentario son cadenas que indican el inicio de un "
"comentario válido dentro de un archivo de configuración. Los prefijos "
"*comment_prefixes* se utilizan sólo en líneas vacías (opcionalmente con "
"sangría), mientras que los prefijos *inline_comment_prefixes* pueden "
"utilizarse después de cualquier valor válido (por ejemplo, nombres de "
"sección, opciones y también líneas vacías).  Por defecto, los comentarios en "
"línea están desactivados y se utilizan ``'#'`` y ``';'`` como prefijos para "
"los comentarios de línea completa."

#: ../../library/configparser.rst:557
msgid ""
"In previous versions of :mod:`configparser` behaviour matched "
"``comment_prefixes=('#',';')`` and ``inline_comment_prefixes=(';',)``."
msgstr ""
"En versiones anteriores de :mod:`configparser` el comportamiento coincidía "
"con ``comment_prefixes=('#',';')`` y ``inline_comment_prefixes=(';',)``."

#: ../../library/configparser.rst:561
msgid ""
"Please note that config parsers don't support escaping of comment prefixes "
"so using *inline_comment_prefixes* may prevent users from specifying option "
"values with characters used as comment prefixes.  When in doubt, avoid "
"setting *inline_comment_prefixes*.  In any circumstances, the only way of "
"storing comment prefix characters at the beginning of a line in multiline "
"values is to interpolate the prefix, for example::"
msgstr ""
"Tenga en cuenta que los analizadores de configuración no admiten el escape "
"de prefijos de comentarios, por lo que el uso de *inline_comment_prefixes* "
"puede impedir que los usuarios especifiquen valores de opción con caracteres "
"utilizados como prefijos de comentarios.  En caso de duda, evite configurar "
"*inline_comment_prefixes*.  En cualquier circunstancia, la única forma de "
"almacenar caracteres de prefijo de comentario al principio de una línea en "
"valores multilínea es interpolar el prefijo, por ejemplo::"

#: ../../library/configparser.rst:607
msgid "*strict*, default value: ``True``"
msgstr "*estricto*, valor por defecto: ``True``"

#: ../../library/configparser.rst:609
msgid ""
"When set to ``True``, the parser will not allow for any section or option "
"duplicates while reading from a single source (using :meth:`read_file`, :"
"meth:`read_string` or :meth:`read_dict`).  It is recommended to use strict "
"parsers in new applications."
msgstr ""

#: ../../library/configparser.rst:614
msgid ""
"In previous versions of :mod:`configparser` behaviour matched "
"``strict=False``."
msgstr ""
"En versiones anteriores de :mod:`configparser` el comportamiento coincidía "
"con ``strict=False``."

#: ../../library/configparser.rst:618
msgid "*empty_lines_in_values*, default value: ``True``"
msgstr "*empty_lines_in_values*, valor por defecto: ``True``"

#: ../../library/configparser.rst:620
msgid ""
"In config parsers, values can span multiple lines as long as they are "
"indented more than the key that holds them.  By default parsers also let "
"empty lines to be parts of values.  At the same time, keys can be "
"arbitrarily indented themselves to improve readability.  In consequence, "
"when configuration files get big and complex, it is easy for the user to "
"lose track of the file structure.  Take for instance:"
msgstr ""
"En los analizadores sintácticos de configuración, los valores pueden abarcar "
"varias líneas siempre que tengan una sangría superior a la de la tecla que "
"los contiene.  Por defecto, los analizadores también permiten que las líneas "
"vacías formen parte de los valores.  Al mismo tiempo, las claves pueden "
"tener una sangría arbitraria para mejorar la legibilidad.  En consecuencia, "
"cuando los archivos de configuración se hacen grandes y complejos, es fácil "
"para el usuario perder la pista de la estructura del archivo.  Por ejemplo:"

#: ../../library/configparser.rst:635
msgid ""
"This can be especially problematic for the user to see if she's using a "
"proportional font to edit the file.  That is why when your application does "
"not need values with empty lines, you should consider disallowing them.  "
"This will make empty lines split keys every time.  In the example above, it "
"would produce two keys, ``key`` and ``this``."
msgstr ""
"Esto puede ser especialmente problemático para el usuario si está utilizando "
"una fuente proporcional para editar el archivo.  Por eso, cuando su "
"aplicación no necesite valores con líneas vacías, debería considerar "
"desautorizarlos.  Esto hará que las líneas vacías dividan las teclas cada "
"vez.  En el ejemplo anterior, produciría dos claves, ``key`` y ``this``."

#: ../../library/configparser.rst:641
msgid ""
"*default_section*, default value: ``configparser.DEFAULTSECT`` (that is: "
"``\"DEFAULT\"``)"
msgstr ""
"*default_section*, valor por defecto: ``configparser.DEFAULTSECT`` (es "
"decir: ``\"DEFAULT\"``)"

#: ../../library/configparser.rst:644
msgid ""
"The convention of allowing a special section of default values for other "
"sections or interpolation purposes is a powerful concept of this library, "
"letting users create complex declarative configurations.  This section is "
"normally called ``\"DEFAULT\"`` but this can be customized to point to any "
"other valid section name.  Some typical values include: ``\"general\"`` or "
"``\"common\"``.  The name provided is used for recognizing default sections "
"when reading from any source and is used when writing configuration back to "
"a file.  Its current value can be retrieved using the ``parser_instance."
"default_section`` attribute and may be modified at runtime (i.e. to convert "
"files from one format to another)."
msgstr ""
"La convención de permitir una sección especial de valores por defecto para "
"otras secciones o propósitos de interpolación es un concepto poderoso de "
"esta biblioteca, permitiendo a los usuarios crear configuraciones "
"declarativas complejas.  Esta sección se llama normalmente ``\"DEFAULT\"`` "
"pero puede personalizarse para que apunte a cualquier otro nombre de sección "
"válido.  Algunos valores típicos incluyen: ``\"general\"`` o ``\"common\"``. "
"El nombre proporcionado se utiliza para reconocer las secciones por defecto "
"cuando se lee desde cualquier fuente y se utiliza cuando se escribe la "
"configuración de nuevo a un archivo.  Su valor actual puede recuperarse "
"utilizando el atributo ``parser_instance.default_section`` y puede "
"modificarse en tiempo de ejecución (por ejemplo, para convertir archivos de "
"un formato a otro)."

#: ../../library/configparser.rst:655
msgid "*interpolation*, default value: ``configparser.BasicInterpolation``"
msgstr ""
"*interpolation*, valor por defecto: ``configparser.BasicInterpolation``"

#: ../../library/configparser.rst:657
msgid ""
"Interpolation behaviour may be customized by providing a custom handler "
"through the *interpolation* argument. ``None`` can be used to turn off "
"interpolation completely, ``ExtendedInterpolation()`` provides a more "
"advanced variant inspired by ``zc.buildout``.  More on the subject in the "
"`dedicated documentation section <#interpolation-of-values>`_. :class:"
"`RawConfigParser` has a default value of ``None``."
msgstr ""
"El comportamiento de interpolación puede personalizarse proporcionando un "
"manejador personalizado a través del argumento *interpolation*. ``None`` "
"puede utilizarse para desactivar completamente la interpolación, "
"``ExtendedInterpolation()`` proporciona una variante más avanzada inspirada "
"en ``zc.buildout``.  Más información sobre el tema en la sección `dedicada a "
"la documentación <#interpolation-of-values>`_. :class:`RawConfigParser` "
"tiene un valor por defecto de ``None``."

#: ../../library/configparser.rst:664
msgid "*converters*, default value: not set"
msgstr "*converters*, valor por defecto: no establecido"

#: ../../library/configparser.rst:666
msgid ""
"Config parsers provide option value getters that perform type conversion.  "
"By default :meth:`~ConfigParser.getint`, :meth:`~ConfigParser.getfloat`, "
"and :meth:`~ConfigParser.getboolean` are implemented.  Should other getters "
"be desirable, users may define them in a subclass or pass a dictionary where "
"each key is a name of the converter and each value is a callable "
"implementing said conversion.  For instance, passing ``{'decimal': decimal."
"Decimal}`` would add :meth:`getdecimal` on both the parser object and all "
"section proxies.  In other words, it will be possible to write both "
"``parser_instance.getdecimal('section', 'key', fallback=0)`` and "
"``parser_instance['section'].getdecimal('key', 0)``."
msgstr ""

#: ../../library/configparser.rst:677
msgid ""
"If the converter needs to access the state of the parser, it can be "
"implemented as a method on a config parser subclass.  If the name of this "
"method starts with ``get``, it will be available on all section proxies, in "
"the dict-compatible form (see the ``getdecimal()`` example above)."
msgstr ""
"Si el conversor necesita acceder al estado del analizador sintáctico, puede "
"implementarse como un método en una subclase del analizador sintáctico "
"config.  Si el nombre de este método empieza por ``get``, estará disponible "
"en todos los proxies de sección, en la forma compatible con dict (véase el "
"ejemplo anterior de ``getdecimal()`` )."

#: ../../library/configparser.rst:682
msgid ""
"More advanced customization may be achieved by overriding default values of "
"these parser attributes.  The defaults are defined on the classes, so they "
"may be overridden by subclasses or by attribute assignment."
msgstr ""
"Se puede lograr una personalización más avanzada anulando los valores por "
"defecto de estos atributos del analizador sintáctico.  Los valores por "
"defecto se definen en las clases, por lo que pueden ser anulados por "
"subclases o por asignación de atributos."

#: ../../library/configparser.rst:688
msgid ""
"By default when using :meth:`~ConfigParser.getboolean`, config parsers "
"consider the following values ``True``: ``'1'``, ``'yes'``, ``'true'``, "
"``'on'`` and the following values ``False``: ``'0'``, ``'no'``, ``'false'``, "
"``'off'``.  You can override this by specifying a custom dictionary of "
"strings and their Boolean outcomes. For example:"
msgstr ""
"Por defecto, cuando se utiliza :meth:`~ConfigParser.getboolean`, los "
"analizadores sintácticos de configuración consideran los siguientes valores "
"``True``: ``'1'``, ``'yes'``, ``'true'``, ``'on'`` y los siguientes valores "
"``False``: ``'0'``, ``'no'``, ``'false'``, ``'off'``.  Puede anular esto "
"especificando un diccionario personalizado de cadenas y sus resultados "
"booleanos. Por ejemplo"

#: ../../library/configparser.rst:706
msgid ""
"Other typical Boolean pairs include ``accept``/``reject`` or ``enabled``/"
"``disabled``."
msgstr ""
"Otros pares booleanos típicos son ``accept``/``reject`` o ``enabled``/"
"``disabled``."

#: ../../library/configparser.rst:712
msgid ""
"This method transforms option names on every read, get, or set operation.  "
"The default converts the name to lowercase.  This also means that when a "
"configuration file gets written, all keys will be lowercase.  Override this "
"method if that's unsuitable. For example:"
msgstr ""
"Este método transforma los nombres de las opciones en cada operación de "
"lectura, obtención o establecimiento.  Por defecto convierte el nombre a "
"minúsculas.  Esto también significa que cuando se escribe un fichero de "
"configuración, todas las claves estarán en minúsculas.  Anula este método si "
"no es adecuado. Por ejemplo:"

#: ../../library/configparser.rst:742
msgid ""
"The optionxform function transforms option names to a canonical form. This "
"should be an idempotent function: if the name is already in canonical form, "
"it should be returned unchanged."
msgstr ""
"La función optionxform transforma los nombres de las opciones a una forma "
"canónica. Debería ser una función idempotente: si el nombre ya está en forma "
"canónica, debería devolverse sin cambios."

#: ../../library/configparser.rst:749
msgid ""
"A compiled regular expression used to parse section headers.  The default "
"matches ``[section]`` to the name ``\"section\"``.  Whitespace is considered "
"part of the section name, thus ``[  larch  ]`` will be read as a section of "
"name ``\"  larch  \"``.  Override this attribute if that's unsuitable.  For "
"example:"
msgstr ""
"Expresión regular compilada que se utiliza para analizar los encabezados de "
"sección.  Por defecto, ``[section]`` coincide con el nombre "
"``\"section\"``.  Los espacios en blanco se consideran parte del nombre de "
"la sección, por lo que ``[  larch  ]`` se leerá como una sección de nombre "
"``\"  larch  \"``.  Anule este atributo si no es adecuado.  Por ejemplo:"

#: ../../library/configparser.rst:777
msgid ""
"While ConfigParser objects also use an ``OPTCRE`` attribute for recognizing "
"option lines, it's not recommended to override it because that would "
"interfere with constructor options *allow_no_value* and *delimiters*."
msgstr ""
"Aunque los objetos ConfigParser también utilizan un atributo ``OPTCRE`` para "
"reconocer las líneas de opción, no se recomienda anularlo porque "
"interferiría con las opciones del constructor *allow_no_value* y "
"*delimiters*."

#: ../../library/configparser.rst:783
msgid "Legacy API Examples"
msgstr "Ejemplos de API heredadas"

#: ../../library/configparser.rst:785
msgid ""
"Mainly because of backwards compatibility concerns, :mod:`configparser` "
"provides also a legacy API with explicit ``get``/``set`` methods.  While "
"there are valid use cases for the methods outlined below, mapping protocol "
"access is preferred for new projects.  The legacy API is at times more "
"advanced, low-level and downright counterintuitive."
msgstr ""
"Principalmente por cuestiones de compatibilidad con versiones anteriores, :"
"mod:`configparser` proporciona también una API heredada con métodos "
"explícitos ``get``/``set``.  Aunque existen casos de uso válidos para los "
"métodos descritos a continuación, se prefiere el acceso al protocolo de "
"mapeo para los nuevos proyectos.  La API heredada es a veces más avanzada, "
"de bajo nivel y francamente contraintuitiva."

#: ../../library/configparser.rst:791
msgid "An example of writing to a configuration file::"
msgstr "Un ejemplo de escritura en un archivo de configuración::"

#: ../../library/configparser.rst:814
msgid "An example of reading the configuration file again::"
msgstr "Un ejemplo de volver a leer el archivo de configuración::"

#: ../../library/configparser.rst:832
msgid "To get interpolation, use :class:`ConfigParser`::"
msgstr "Para obtener la interpolación, utilice :class:`ConfigParser`::"

#: ../../library/configparser.rst:865
msgid ""
"Default values are available in both types of ConfigParsers.  They are used "
"in interpolation if an option used is not defined elsewhere. ::"
msgstr ""
"Los valores por defecto están disponibles en ambos tipos de ConfigParsers.  "
"Se utilizan en la interpolación si una opción utilizada no está definida en "
"otra parte. ::"

#: ../../library/configparser.rst:883
msgid "ConfigParser Objects"
msgstr "Objetos ConfigParser"

#: ../../library/configparser.rst:887
msgid ""
"The main configuration parser.  When *defaults* is given, it is initialized "
"into the dictionary of intrinsic defaults.  When *dict_type* is given, it "
"will be used to create the dictionary objects for the list of sections, for "
"the options within a section, and for the default values."
msgstr ""
"El principal analizador de configuración.  Cuando se da *defaults*, se "
"inicializa en el diccionario de valores por defecto intrínsecos.  Cuando se "
"da *dict_type*, se usará para crear los objetos diccionario para la lista de "
"secciones, para las opciones dentro de una sección, y para los valores por "
"defecto."

#: ../../library/configparser.rst:892
msgid ""
"When *delimiters* is given, it is used as the set of substrings that divide "
"keys from values.  When *comment_prefixes* is given, it will be used as the "
"set of substrings that prefix comments in otherwise empty lines. Comments "
"can be indented.  When *inline_comment_prefixes* is given, it will be used "
"as the set of substrings that prefix comments in non-empty lines."
msgstr ""
"Cuando se proporciona *comment_prefixes*, se usará como el conjunto de "
"subcadenas que prefijan comentarios en líneas que de otro modo estarían "
"vacías. Los comentarios se pueden sangrar. Cuando se proporciona "
"*inline_comment_prefixes*, se usará como el conjunto de subcadenas que "
"prefijan comentarios en líneas no vacías."

#: ../../library/configparser.rst:898
msgid ""
"When *strict* is ``True`` (the default), the parser won't allow for any "
"section or option duplicates while reading from a single source (file, "
"string or dictionary), raising :exc:`DuplicateSectionError` or :exc:"
"`DuplicateOptionError`.  When *empty_lines_in_values* is ``False`` (default: "
"``True``), each empty line marks the end of an option.  Otherwise, internal "
"empty lines of a multiline option are kept as part of the value. When "
"*allow_no_value* is ``True`` (default: ``False``), options without values "
"are accepted; the value held for these is ``None`` and they are serialized "
"without the trailing delimiter."
msgstr ""
"Cuando *strict* es ``True`` (el valor por defecto), el analizador sintáctico "
"no permitirá ninguna sección u opción duplicada mientras se lee de una única "
"fuente (archivo, cadena o diccionario), elevando :exc:"
"`DuplicateSectionError` o :exc:`DuplicateOptionError`. Cuando "
"*empty_lines_in_values* es ``False`` (valor por defecto: ``True``), cada "
"línea vacía marca el final de una opción.  En caso contrario, las líneas "
"vacías internas de una opción multilínea se mantienen como parte del valor. "
"Cuando *allow_no_value* es ``True`` (por defecto: ``False``), se aceptan "
"opciones sin valores; el valor que se mantiene para éstas es ``None`` y se "
"serializan sin el delimitador final."

#: ../../library/configparser.rst:908
msgid ""
"When *default_section* is given, it specifies the name for the special "
"section holding default values for other sections and interpolation purposes "
"(normally named ``\"DEFAULT\"``).  This value can be retrieved and changed "
"on runtime using the ``default_section`` instance attribute."
msgstr ""

#: ../../library/configparser.rst:913
msgid ""
"Interpolation behaviour may be customized by providing a custom handler "
"through the *interpolation* argument. ``None`` can be used to turn off "
"interpolation completely, ``ExtendedInterpolation()`` provides a more "
"advanced variant inspired by ``zc.buildout``.  More on the subject in the "
"`dedicated documentation section <#interpolation-of-values>`_."
msgstr ""
"El comportamiento de interpolación puede personalizarse proporcionando un "
"manejador personalizado a través del argumento *interpolation*. ``None`` "
"puede utilizarse para desactivar completamente la interpolación, "
"``ExtendedInterpolation()`` proporciona una variante más avanzada inspirada "
"en ``zc.buildout``.  Más información sobre el tema en la sección `dedicada a "
"la documentación <#interpolation-of-values>`_."

#: ../../library/configparser.rst:919
msgid ""
"All option names used in interpolation will be passed through the :meth:"
"`optionxform` method just like any other option name reference.  For "
"example, using the default implementation of :meth:`optionxform` (which "
"converts option names to lower case), the values ``foo %(bar)s`` and ``foo "
"%(BAR)s`` are equivalent."
msgstr ""
"Todos los nombres de opción utilizados en la interpolación se pasarán a "
"través del método :meth:`optionxform` como cualquier otra referencia de "
"nombre de opción.  Por ejemplo, utilizando la implementación por defecto de :"
"meth:`optionxform` (que convierte los nombres de opción a minúsculas), los "
"valores ``foo %(bar)s`` y ``foo %(BAR)s`` son equivalentes."

#: ../../library/configparser.rst:925
msgid ""
"When *converters* is given, it should be a dictionary where each key "
"represents the name of a type converter and each value is a callable "
"implementing the conversion from string to the desired datatype.  Every "
"converter gets its own corresponding :meth:`get*()` method on the parser "
"object and section proxies."
msgstr ""

#: ../../library/configparser.rst:931
msgid "The default *dict_type* is :class:`collections.OrderedDict`."
msgstr "El *dict_type* por defecto es :class:`collections.OrderedDict`."

#: ../../library/configparser.rst:934
msgid ""
"*allow_no_value*, *delimiters*, *comment_prefixes*, *strict*, "
"*empty_lines_in_values*, *default_section* and *interpolation* were added."
msgstr ""
"Se han añadido *allow_no_value*, *delimiters*, *comment_prefixes*, *strict*, "
"*empty_lines_in_values*, *default_section* e *interpolation*."

#: ../../library/configparser.rst:939
msgid "The *converters* argument was added."
msgstr "Se ha añadido el argumento *converters*."

#: ../../library/configparser.rst:942
msgid ""
"The *defaults* argument is read with :meth:`read_dict()`, providing "
"consistent behavior across the parser: non-string keys and values are "
"implicitly converted to strings."
msgstr ""

#: ../../library/configparser.rst:947 ../../library/configparser.rst:1232
msgid ""
"The default *dict_type* is :class:`dict`, since it now preserves insertion "
"order."
msgstr ""
"El *dict_type* por defecto es :class:`dict`, ya que ahora preserva el orden "
"de inserción."

#: ../../library/configparser.rst:953
msgid "Return a dictionary containing the instance-wide defaults."
msgstr ""
"Devuelve un diccionario que contiene los valores predeterminados para toda "
"la instancia."

#: ../../library/configparser.rst:958
msgid ""
"Return a list of the sections available; the *default section* is not "
"included in the list."
msgstr ""
"Devuelve una lista de las secciones disponibles; la *sección predeterminada* "
"no se incluye en la lista."

#: ../../library/configparser.rst:964
msgid ""
"Add a section named *section* to the instance.  If a section by the given "
"name already exists, :exc:`DuplicateSectionError` is raised.  If the "
"*default section* name is passed, :exc:`ValueError` is raised.  The name of "
"the section must be a string; if not, :exc:`TypeError` is raised."
msgstr ""
"Añade una sección llamada *section* a la instancia.  Si ya existe una "
"sección con el nombre indicado, aparece :exc:`DuplicateSectionError`.  Si se "
"pasa el nombre de *sección* por defecto, aparece :exc:`ValueError`.  El "
"nombre de la sección debe ser una cadena; en caso contrario, aparece :exc:"
"`TypeError`."

#: ../../library/configparser.rst:969
msgid "Non-string section names raise :exc:`TypeError`."
msgstr "Los nombres de sección que no son de cadena generan :exc:`TypeError`."

#: ../../library/configparser.rst:975
msgid ""
"Indicates whether the named *section* is present in the configuration. The "
"*default section* is not acknowledged."
msgstr ""
"Indica si la *sección* nombrada está presente en la configuración. No se "
"reconoce la *sección por defecto*."

#: ../../library/configparser.rst:981
msgid "Return a list of options available in the specified *section*."
msgstr ""
"Devuelve una lista de opciones disponibles en la *sección* especificada."

#: ../../library/configparser.rst:986
msgid ""
"If the given *section* exists, and contains the given *option*, return :"
"const:`True`; otherwise return :const:`False`.  If the specified *section* "
"is :const:`None` or an empty string, DEFAULT is assumed."
msgstr ""
"Si la *sección* dada existe, y contiene la *opción* dada, devuelve :const:"
"`True`; en caso contrario devuelve :const:`False`.  Si la *sección* "
"especificada es :const:`None` o una cadena vacía, se asume DEFAULT."

#: ../../library/configparser.rst:993
msgid ""
"Attempt to read and parse an iterable of filenames, returning a list of "
"filenames which were successfully parsed."
msgstr ""
"Intenta leer y analizar un iterable de nombres de archivo, devolviendo una "
"lista de nombres de archivo que se han analizado correctamente."

#: ../../library/configparser.rst:996
msgid ""
"If *filenames* is a string, a :class:`bytes` object or a :term:`path-like "
"object`, it is treated as a single filename.  If a file named in *filenames* "
"cannot be opened, that file will be ignored.  This is designed so that you "
"can specify an iterable of potential configuration file locations (for "
"example, the current directory, the user's home directory, and some system-"
"wide directory), and all existing configuration files in the iterable will "
"be read."
msgstr ""
"Si *filenames* es una cadena, un objeto :class:`bytes` o un objeto :term:"
"`path-like object`, se tratará como un único nombre de archivo.  Si un "
"fichero nombrado en *filenames* no se puede abrir, se ignorará ese fichero.  "
"Esto está diseñado para que pueda especificar una iterable de posibles "
"ubicaciones de ficheros de configuración (por ejemplo, el directorio actual, "
"el directorio personal del usuario y algún directorio de todo el sistema), y "
"se leerán todos los ficheros de configuración existentes en la iterable."

#: ../../library/configparser.rst:1005
msgid ""
"If none of the named files exist, the :class:`ConfigParser` instance will "
"contain an empty dataset.  An application which requires initial values to "
"be loaded from a file should load the required file or files using :meth:"
"`read_file` before calling :meth:`read` for any optional files::"
msgstr ""
"Si no existe ninguno de los archivos mencionados, la instancia :class:"
"`ConfigParser` contendrá un conjunto de datos vacío.  Una aplicación que "
"requiera que los valores iniciales se carguen desde un archivo debe cargar "
"el archivo o archivos requeridos utilizando :meth:`read_file` antes de "
"llamar a :meth:`read` para cualquier archivo opcional::"

#: ../../library/configparser.rst:1018
msgid ""
"The *encoding* parameter.  Previously, all files were read using the default "
"encoding for :func:`open`."
msgstr ""

#: ../../library/configparser.rst:1022
msgid "The *filenames* parameter accepts a :term:`path-like object`."
msgstr "El parámetro *filenames* acepta un :term:`path-like object`."

#: ../../library/configparser.rst:1025
msgid "The *filenames* parameter accepts a :class:`bytes` object."
msgstr "El parámetro *filenames* acepta un objeto :class:`bytes`."

#: ../../library/configparser.rst:1031
msgid ""
"Read and parse configuration data from *f* which must be an iterable "
"yielding Unicode strings (for example files opened in text mode)."
msgstr ""
"Lee y analiza los datos de configuración de *f*, que debe ser un iterable "
"que produzca cadenas Unicode (por ejemplo, archivos abiertos en modo texto)."

#: ../../library/configparser.rst:1034
msgid ""
"Optional argument *source* specifies the name of the file being read.  If "
"not given and *f* has a :attr:`name` attribute, that is used for *source*; "
"the default is ``'<???>'``."
msgstr ""

#: ../../library/configparser.rst:1038
msgid "Replaces :meth:`readfp`."
msgstr ""

#: ../../library/configparser.rst:1043
msgid "Parse configuration data from a string."
msgstr "Analiza los datos de configuración de una cadena."

#: ../../library/configparser.rst:1045
msgid ""
"Optional argument *source* specifies a context-specific name of the string "
"passed.  If not given, ``'<string>'`` is used.  This should commonly be a "
"filesystem path or a URL."
msgstr ""
"El argumento opcional *source* especifica un nombre específico del contexto "
"de la cadena pasada.  Si no se indica, se utiliza ``'<string>'``.  "
"Normalmente debería ser una ruta del sistema de archivos o una URL."

#: ../../library/configparser.rst:1054
msgid ""
"Load configuration from any object that provides a dict-like ``items()`` "
"method.  Keys are section names, values are dictionaries with keys and "
"values that should be present in the section.  If the used dictionary type "
"preserves order, sections and their keys will be added in order. Values are "
"automatically converted to strings."
msgstr ""
"Carga la configuración desde cualquier objeto que proporcione un método tipo "
"dict ``items()``.  Las claves son nombres de secciones, los valores son "
"diccionarios con claves y valores que deben estar presentes en la sección.  "
"Si el tipo de diccionario utilizado preserva el orden, las secciones y sus "
"claves se añadirán en orden. Los valores se convierten automáticamente en "
"cadenas."

#: ../../library/configparser.rst:1060
msgid ""
"Optional argument *source* specifies a context-specific name of the "
"dictionary passed.  If not given, ``<dict>`` is used."
msgstr ""
"El argumento opcional *source* especifica un nombre específico del contexto "
"del diccionario pasado.  Si no se indica, se utiliza ``<dict>``."

#: ../../library/configparser.rst:1063
msgid "This method can be used to copy state between parsers."
msgstr ""
"Este método puede utilizarse para copiar el estado entre analizadores "
"sintácticos."

#: ../../library/configparser.rst:1070
msgid ""
"Get an *option* value for the named *section*.  If *vars* is provided, it "
"must be a dictionary.  The *option* is looked up in *vars* (if provided), "
"*section*, and in *DEFAULTSECT* in that order.  If the key is not found and "
"*fallback* is provided, it is used as a fallback value.  ``None`` can be "
"provided as a *fallback* value."
msgstr ""
"Obtiene un valor de *option* para la *sección* indicada.  Si se proporciona "
"*vars*, debe ser un diccionario.  La *option* se busca en *vars* (si se "
"proporciona), *section*, y en *DEFAULTSECT* en ese orden.  Si no se "
"encuentra la clave y se proporciona *fallback*, se utiliza como valor de "
"reserva. ``None`` puede proporcionarse como valor de *fallback*."

#: ../../library/configparser.rst:1076
msgid ""
"All the ``'%'`` interpolations are expanded in the return values, unless the "
"*raw* argument is true.  Values for interpolation keys are looked up in the "
"same manner as the option."
msgstr ""
"Todas las interpolaciones de ``'%'`` se expanden en los valores de retorno, "
"a menos que el argumento *raw* sea verdad.  Los valores de las claves de "
"interpolación se buscan del mismo modo que la opción."

#: ../../library/configparser.rst:1080
msgid ""
"Arguments *raw*, *vars* and *fallback* are keyword only to protect users "
"from trying to use the third argument as the *fallback* fallback (especially "
"when using the mapping protocol)."
msgstr ""
"Los argumentos *raw*, *vars* y *fallback* son sólo palabras clave para "
"proteger a los usuarios de intentar utilizar el tercer argumento como el "
"*fallback* fallback (especialmente cuando se utiliza el protocolo de mapeo)."

#: ../../library/configparser.rst:1088
msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to an integer.  See :meth:`get` for explanation of *raw*, *vars* and "
"*fallback*."
msgstr ""
"Método práctico que convierte la *opción* de la *sección* especificada en un "
"número entero.  Véase :meth:`get` para la explicación de *raw*, *vars* y "
"*fallback*."

#: ../../library/configparser.rst:1095
msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to a floating point number.  See :meth:`get` for explanation of *raw*, "
"*vars* and *fallback*."
msgstr ""

#: ../../library/configparser.rst:1102
msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to a Boolean value.  Note that the accepted values for the option are "
"``'1'``, ``'yes'``, ``'true'``, and ``'on'``, which cause this method to "
"return ``True``, and ``'0'``, ``'no'``, ``'false'``, and ``'off'``, which "
"cause it to return ``False``.  These string values are checked in a case-"
"insensitive manner.  Any other value will cause it to raise :exc:"
"`ValueError`.  See :meth:`get` for explanation of *raw*, *vars* and "
"*fallback*."
msgstr ""
"Método práctico que convierte la *opción* de la *sección* especificada en un "
"valor booleano.  Tenga en cuenta que los valores aceptados para la opción "
"son ``'1'``, ``'yes'``, ``'true'``, y ``'on'``, que hacen que este método "
"devuelva ``True``, y ``'0'``, ``'no'``, ``'false'``, y ``'off'``, que hacen "
"que devuelva ``False``.  Estos valores de cadena se comprueban sin "
"distinguir entre mayúsculas y minúsculas.  Cualquier otro valor hará que se "
"muestre :exc:`ValueError`.  Véase :meth:`get` para la explicación de *raw*, "
"*vars* y *fallback*."

#: ../../library/configparser.rst:1115
msgid ""
"When *section* is not given, return a list of *section_name*, "
"*section_proxy* pairs, including DEFAULTSECT."
msgstr ""
"Si no se indica *section*, devuelve una lista de pares *section_name*, "
"*section_proxy*, incluido DEFAULTSECT."

#: ../../library/configparser.rst:1118
msgid ""
"Otherwise, return a list of *name*, *value* pairs for the options in the "
"given *section*.  Optional arguments have the same meaning as for the :meth:"
"`get` method."
msgstr ""
"En caso contrario, devuelve una lista de pares *nombre*, *valor* para las "
"opciones de la *sección* dada.  Los argumentos opcionales tienen el mismo "
"significado que para el método :meth:`get`."

#: ../../library/configparser.rst:1122
msgid ""
"Items present in *vars* no longer appear in the result.  The previous "
"behaviour mixed actual parser options with variables provided for "
"interpolation."
msgstr ""
"Los elementos presentes en *vars* ya no aparecen en el resultado.  El "
"comportamiento anterior mezclaba opciones reales del analizador sintáctico "
"con variables proporcionadas para la interpolación."

#: ../../library/configparser.rst:1130
msgid ""
"If the given section exists, set the given option to the specified value; "
"otherwise raise :exc:`NoSectionError`.  *option* and *value* must be "
"strings; if not, :exc:`TypeError` is raised."
msgstr ""
"Si la sección dada existe, establece la opción dada en el valor "
"especificado; en caso contrario, lanza :exc:`NoSectionError`.  *option** y "
"*value* deben ser cadenas; en caso contrario, aparece :exc:`TypeError`."

#: ../../library/configparser.rst:1137
msgid ""
"Write a representation of the configuration to the specified :term:`file "
"object`, which must be opened in text mode (accepting strings).  This "
"representation can be parsed by a future :meth:`read` call.  If "
"*space_around_delimiters* is true, delimiters between keys and values are "
"surrounded by spaces."
msgstr ""
"Escribe una representación de la configuración en el objeto :term:`file "
"object` especificado, que debe abrirse en modo texto (aceptando cadenas).  "
"Esta representación puede ser analizada por una futura llamada a :meth:"
"`read`.  Si *space_around_delimiters* es verdadero, los delimitadores entre "
"claves y valores se rodean de espacios."

#: ../../library/configparser.rst:1145
msgid ""
"Comments in the original configuration file are not preserved when writing "
"the configuration back. What is considered a comment, depends on the given "
"values for *comment_prefix* and *inline_comment_prefix*."
msgstr ""
"Los comentarios en el fichero de configuración original no se conservan al "
"volver a escribir la configuración. Lo que se considera un comentario, "
"depende de los valores dados para *comment_prefix* y *inline_comment_prefix*."

#: ../../library/configparser.rst:1153
msgid ""
"Remove the specified *option* from the specified *section*.  If the section "
"does not exist, raise :exc:`NoSectionError`.  If the option existed to be "
"removed, return :const:`True`; otherwise return :const:`False`."
msgstr ""
"Elimina la *option* especificada de la *section* especificada.  Si la "
"sección no existe, devuelve :exc:`NoSectionError`.  Si la opción existía "
"para ser eliminada, devuelve :const:`True`; en caso contrario devuelve :"
"const:`False`."

#: ../../library/configparser.rst:1161
msgid ""
"Remove the specified *section* from the configuration.  If the section in "
"fact existed, return ``True``.  Otherwise return ``False``."
msgstr ""
"Elimina la *section* especificada de la configuración.  Si la sección "
"existía, devuelve ``True``.  Si no, devuelve ``False``."

#: ../../library/configparser.rst:1167
msgid ""
"Transforms the option name *option* as found in an input file or as passed "
"in by client code to the form that should be used in the internal "
"structures.  The default implementation returns a lower-case version of "
"*option*; subclasses may override this or client code can set an attribute "
"of this name on instances to affect this behavior."
msgstr ""
"Transforma el nombre de la opción *option* tal y como se encuentra en un "
"archivo de entrada o tal y como lo pasa el código del cliente a la forma que "
"debería utilizarse en las estructuras internas.  La implementación "
"predeterminada devuelve una versión en minúsculas de *option*; las subclases "
"pueden anular esto o el código cliente puede establecer un atributo de este "
"nombre en las instancias para afectar a este comportamiento."

#: ../../library/configparser.rst:1173
msgid ""
"You don't need to subclass the parser to use this method, you can also set "
"it on an instance, to a function that takes a string argument and returns a "
"string.  Setting it to ``str``, for example, would make option names case "
"sensitive::"
msgstr ""
"No es necesario subclasificar el analizador para utilizar este método, "
"también se puede establecer en una instancia, a una función que toma un "
"argumento de cadena y devuelve una cadena.  Establecerlo a ``str``, por "
"ejemplo, haría que los nombres de las opciones distingan entre mayúsculas y "
"minúsculas::"

#: ../../library/configparser.rst:1181
msgid ""
"Note that when reading configuration files, whitespace around the option "
"names is stripped before :meth:`optionxform` is called."
msgstr ""
"Tenga en cuenta que cuando se leen archivos de configuración, los espacios "
"en blanco alrededor de los nombres de las opciones se eliminan antes de "
"llamar a :meth:`optionxform`."

#: ../../library/configparser.rst:1187
msgid "Use :meth:`read_file` instead."
msgstr ""

#: ../../library/configparser.rst:1190
msgid ""
":meth:`readfp` now iterates on *fp* instead of calling ``fp.readline()``."
msgstr ""

#: ../../library/configparser.rst:1193
msgid ""
"For existing code calling :meth:`readfp` with arguments which don't support "
"iteration, the following generator may be used as a wrapper around the file-"
"like object::"
msgstr ""

#: ../../library/configparser.rst:1203
msgid ""
"Instead of ``parser.readfp(fp)`` use ``parser."
"read_file(readline_generator(fp))``."
msgstr ""

#: ../../library/configparser.rst:1209
msgid ""
"The maximum depth for recursive interpolation for :meth:`get` when the *raw* "
"parameter is false.  This is relevant only when the default *interpolation* "
"is used."
msgstr ""

#: ../../library/configparser.rst:1217
msgid "RawConfigParser Objects"
msgstr "Objetos RawConfigParser"

#: ../../library/configparser.rst:1227
msgid ""
"Legacy variant of the :class:`ConfigParser`.  It has interpolation disabled "
"by default and allows for non-string section names, option names, and values "
"via its unsafe ``add_section`` and ``set`` methods, as well as the legacy "
"``defaults=`` keyword argument handling."
msgstr ""
"Variante heredada de :class:`ConfigParser`. Tiene la interpolación "
"desactivada por defecto y permite nombres de sección, nombres de opción y "
"valores que no son cadenas a través de sus métodos inseguros ``add_section`` "
"y ``set``, así como el manejo de argumentos de palabras clave heredado "
"``defaults=``."

#: ../../library/configparser.rst:1237
msgid ""
"Consider using :class:`ConfigParser` instead which checks types of the "
"values to be stored internally.  If you don't want interpolation, you can "
"use ``ConfigParser(interpolation=None)``."
msgstr ""
"Considere el uso de :class:`ConfigParser` en su lugar, que comprueba los "
"tipos de los valores que se almacenarán internamente.  Si no desea "
"interpolación, puede utilizar ``ConfigParser(interpolation=None)``."

#: ../../library/configparser.rst:1244
msgid ""
"Add a section named *section* to the instance.  If a section by the given "
"name already exists, :exc:`DuplicateSectionError` is raised.  If the "
"*default section* name is passed, :exc:`ValueError` is raised."
msgstr ""
"Añade una sección llamada *section* a la instancia.  Si ya existe una "
"sección con el nombre indicado, aparece :exc:`DuplicateSectionError`.  Si se "
"pasa el nombre *default section*, aparece :exc:`ValueError`."

#: ../../library/configparser.rst:1248
msgid ""
"Type of *section* is not checked which lets users create non-string named "
"sections.  This behaviour is unsupported and may cause internal errors."
msgstr ""
"El tipo de *section* no se comprueba, lo que permite a los usuarios crear "
"secciones sin nombre de cadena.  Este comportamiento no está soportado y "
"puede causar errores internos."

#: ../../library/configparser.rst:1254
msgid ""
"If the given section exists, set the given option to the specified value; "
"otherwise raise :exc:`NoSectionError`.  While it is possible to use :class:"
"`RawConfigParser` (or :class:`ConfigParser` with *raw* parameters set to "
"true) for *internal* storage of non-string values, full functionality "
"(including interpolation and output to files) can only be achieved using "
"string values."
msgstr ""
"Si la sección dada existe, establece la opción dada al valor especificado; "
"en caso contrario, lanza :exc:`NoSectionError`.  Aunque es posible utilizar :"
"class:`RawConfigParser` (o :class:`ConfigParser` con los parámetros *raw* "
"establecidos en true) para el almacenamiento *interno* de valores que no "
"sean cadenas, la funcionalidad completa (incluida la interpolación y la "
"salida a archivos) sólo puede lograrse utilizando valores de cadenas."

#: ../../library/configparser.rst:1261
msgid ""
"This method lets users assign non-string values to keys internally.  This "
"behaviour is unsupported and will cause errors when attempting to write to a "
"file or get it in non-raw mode.  **Use the mapping protocol API** which does "
"not allow such assignments to take place."
msgstr ""
"Este método permite a los usuarios asignar valores no string a las claves "
"internamente.  Este comportamiento no está soportado y provocará errores al "
"intentar escribir en un fichero u obtenerlo en modo no raw.  **Utiliza la "
"API del protocolo de mapeo**, que no permite este tipo de asignaciones."

#: ../../library/configparser.rst:1268
msgid "Exceptions"
msgstr "Excepciones"

#: ../../library/configparser.rst:1272
msgid "Base class for all other :mod:`configparser` exceptions."
msgstr "Clase base para todas las demás excepciones de :mod:`configparser`."

#: ../../library/configparser.rst:1277
msgid "Exception raised when a specified section is not found."
msgstr "Excepción planteada cuando no se encuentra una sección especificada."

#: ../../library/configparser.rst:1282
msgid ""
"Exception raised if :meth:`add_section` is called with the name of a section "
"that is already present or in strict parsers when a section if found more "
"than once in a single input file, string or dictionary."
msgstr ""

#: ../../library/configparser.rst:1286
msgid ""
"Optional ``source`` and ``lineno`` attributes and arguments to :meth:"
"`__init__` were added."
msgstr ""

#: ../../library/configparser.rst:1293
msgid ""
"Exception raised by strict parsers if a single option appears twice during "
"reading from a single file, string or dictionary. This catches misspellings "
"and case sensitivity-related errors, e.g. a dictionary may have two keys "
"representing the same case-insensitive configuration key."
msgstr ""
"Excepción lanzada por los analizadores sintácticos estrictos si una única "
"opción aparece dos veces durante la lectura de un único archivo, cadena o "
"diccionario. Esto detecta errores ortográficos y errores relacionados con la "
"distinción entre mayúsculas y minúsculas, por ejemplo, un diccionario puede "
"tener dos claves que representan la misma clave de configuración sin "
"distinción entre mayúsculas y minúsculas."

#: ../../library/configparser.rst:1301
msgid ""
"Exception raised when a specified option is not found in the specified "
"section."
msgstr ""
"Excepción planteada cuando una opción especificada no se encuentra en la "
"sección especificada."

#: ../../library/configparser.rst:1307
msgid ""
"Base class for exceptions raised when problems occur performing string "
"interpolation."
msgstr ""
"Clase base para las excepciones que surgen cuando se producen problemas al "
"realizar la interpolación de cadenas."

#: ../../library/configparser.rst:1313
msgid ""
"Exception raised when string interpolation cannot be completed because the "
"number of iterations exceeds :const:`MAX_INTERPOLATION_DEPTH`.  Subclass of :"
"exc:`InterpolationError`."
msgstr ""
"Excepción planteada cuando la interpolación de cadenas no puede completarse "
"porque el número de iteraciones excede :const:`MAX_INTERPOLATION_DEPTH`.  "
"Subclase de :exc:`InterpolationError`."

#: ../../library/configparser.rst:1320
msgid ""
"Exception raised when an option referenced from a value does not exist. "
"Subclass of :exc:`InterpolationError`."
msgstr ""
"Excepción lanzada cuando una opción referenciada desde un valor no existe. "
"Subclase de :exc:`InterpolationError`."

#: ../../library/configparser.rst:1326
msgid ""
"Exception raised when the source text into which substitutions are made does "
"not conform to the required syntax.  Subclass of :exc:`InterpolationError`."
msgstr ""
"Excepción planteada cuando el texto fuente en el que se realizan las "
"sustituciones no se ajusta a la sintaxis requerida.  Subclase de :exc:"
"`InterpolationError`."

#: ../../library/configparser.rst:1332
msgid ""
"Exception raised when attempting to parse a file which has no section "
"headers."
msgstr ""
"Excepción planteada al intentar analizar un archivo que no tiene cabeceras "
"de sección."

#: ../../library/configparser.rst:1338
msgid "Exception raised when errors occur attempting to parse a file."
msgstr ""
"Excepción planteada cuando se producen errores al intentar analizar un "
"archivo."

#: ../../library/configparser.rst:1340
msgid ""
"The ``filename`` attribute and :meth:`__init__` argument were renamed to "
"``source`` for consistency."
msgstr ""

#: ../../library/configparser.rst:1346
msgid "Footnotes"
msgstr "Notas a pie de página"

#: ../../library/configparser.rst:1347
msgid ""
"Config parsers allow for heavy customization.  If you are interested in "
"changing the behaviour outlined by the footnote reference, consult the "
"`Customizing Parser Behaviour`_ section."
msgstr ""
"Los analizadores sintácticos Config permiten una gran personalización.  Si "
"está interesado en cambiar el comportamiento descrito en la nota de "
"referencia, consulte la sección `Customizing Parser Behaviour`_."
