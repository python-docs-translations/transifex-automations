# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2026, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# eulalio barbero espinosa <eulalio@disroot.org>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-03 15:39+0000\n"
"PO-Revision-Date: 2025-07-18 19:57+0000\n"
"Last-Translator: eulalio barbero espinosa <eulalio@disroot.org>, 2025\n"
"Language-Team: Spanish (Spain) (https://app.transifex.com/python-doc/"
"teams/5390/es_ES/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es_ES\n"
"Plural-Forms: nplurals=3; plural=n == 1 ? 0 : n != 0 && n % 1000000 == 0 ? "
"1 : 2;\n"

#: ../../library/cmd.rst:2
msgid ":mod:`!cmd` --- Support for line-oriented command interpreters"
msgstr ""
":mod:`!cmd` --- Soporte para intérpretes de comandos orientados a líneas"

#: ../../library/cmd.rst:9
msgid "**Source code:** :source:`Lib/cmd.py`"
msgstr "**Código fuente:** :source:`Lib/cmd.py`"

#: ../../library/cmd.rst:13
msgid ""
"The :class:`Cmd` class provides a simple framework for writing line-oriented "
"command interpreters.  These are often useful for test harnesses, "
"administrative tools, and prototypes that will later be wrapped in a more "
"sophisticated interface."
msgstr ""
"La clase :class:`Cmd` proporciona un marco simple para escribir intérpretes "
"de comandos orientados a la línea.  Suelen ser útiles para arneses de "
"prueba, herramientas administrativas y prototipos que más tarde se "
"envolverán en una interfaz más sofisticada."

#: ../../library/cmd.rst:20
msgid ""
"A :class:`Cmd` instance or subclass instance is a line-oriented interpreter "
"framework.  There is no good reason to instantiate :class:`Cmd` itself; "
"rather, it's useful as a superclass of an interpreter class you define "
"yourself in order to inherit :class:`Cmd`'s methods and encapsulate action "
"methods."
msgstr ""
"Una instancia o subclase de :class:`Cmd` es un marco de intérprete orientado "
"a la línea.  No hay ninguna buena razón para instanciar :class:`Cmd` en sí; "
"más bien, es útil como superclase de una clase de intérprete que defina "
"usted mismo para heredar los métodos de :class:`Cmd` y encapsular los "
"métodos de acción."

#: ../../library/cmd.rst:25
msgid ""
"The optional argument *completekey* is the :mod:`readline` name of a "
"completion key; it defaults to :kbd:`Tab`. If *completekey* is not :const:"
"`None` and :mod:`readline` is available, command completion is done "
"automatically."
msgstr ""
"El argumento opcional *completekey* es el nombre :mod:`readline` de una "
"clave de finalización; por defecto es :kbd:`Tab`. Si *completekey* no es :"
"const:`None` y :mod:`readline` está disponible, la finalización del comando "
"se realiza automáticamente."

#: ../../library/cmd.rst:29
msgid ""
"The optional arguments *stdin* and *stdout* specify the  input and output "
"file objects that the Cmd instance or subclass  instance will use for input "
"and output. If not specified, they will default to :data:`sys.stdin` and :"
"data:`sys.stdout`."
msgstr ""
"Los argumentos opcionales *stdin* y *stdout* especifican los objetos de "
"archivo de entrada y salida que la instancia o subclase de Cmd utilizará "
"para la entrada y la salida. Si no se especifican, se utilizarán por "
"defecto :data:`sys.stdin` y :data:`sys.stdout`."

#: ../../library/cmd.rst:34
msgid ""
"If you want a given *stdin* to be used, make sure to set the instance's :"
"attr:`use_rawinput` attribute to ``False``, otherwise *stdin* will be "
"ignored."
msgstr ""
"Si desea que se utilice un *stdin* determinado, asegúrese de establecer el "
"atributo :attr:`use_rawinput` de la instancia en ``False``, de lo contrario "
"se ignorará *stdin*."

#: ../../library/cmd.rst:42
msgid "Cmd Objects"
msgstr "Objetos Cmd"

#: ../../library/cmd.rst:44
msgid "A :class:`Cmd` instance has the following methods:"
msgstr "Una instancia de :class:`Cmd` tiene los siguientes métodos:"

#: ../../library/cmd.rst:49
msgid ""
"Repeatedly issue a prompt, accept input, parse an initial prefix off the "
"received input, and dispatch to action methods, passing them the remainder "
"of the line as argument."
msgstr ""
"Emitir repetidamente un prompt, aceptar la entrada, analizar un prefijo "
"inicial de la entrada recibida, y enviar a los métodos de acción, pasándoles "
"el resto de la línea como argumento."

#: ../../library/cmd.rst:53
msgid ""
"The optional argument is a banner or intro string to be issued before the "
"first prompt (this overrides the :attr:`intro` class attribute)."
msgstr ""
"El argumento opcional es un banner o cadena de introducción que se emitirá "
"antes del primer aviso (esto anula el atributo de clase :attr:`intro` )."

#: ../../library/cmd.rst:56
msgid ""
"If the :mod:`readline` module is loaded, input will automatically inherit :"
"program:`bash`\\ -like history-list editing (e.g. :kbd:`Control-P` scrolls "
"back to the last command, :kbd:`Control-N` forward to the next one, :kbd:"
"`Control-F` moves the cursor to the right non-destructively, :kbd:`Control-"
"B` moves the cursor to the left non-destructively, etc.)."
msgstr ""
"Si se carga el módulo :mod:`readline`, la entrada heredará automáticamente "
"la edición de listas históricas similar a :program:`bash`(por ejemplo, :kbd:"
"`Control-P` retrocede hasta el último comando, :kbd:`Control-N` avanza hasta "
"el siguiente, :kbd:`Control-F` mueve el cursor a la derecha de forma no "
"destructiva, :kbd:`Control-B` mueve el cursor a la izquierda de forma no "
"destructiva, etc.)."

#: ../../library/cmd.rst:62
msgid "An end-of-file on input is passed back as the string ``'EOF'``."
msgstr ""
"Un final de archivo en la entrada se devuelve como la cadena ``'EOF'``."

#: ../../library/cmd.rst:68
msgid ""
"An interpreter instance will recognize a command name ``foo`` if and only if "
"it has a method :meth:`!do_foo`.  As a special case, a line beginning with "
"the character ``'?'`` is dispatched to the method :meth:`do_help`.  As "
"another special case, a line beginning with the character ``'!'`` is "
"dispatched to the method :meth:`!do_shell` (if such a method is defined)."
msgstr ""
"Una instancia de intérprete reconocerá un nombre de comando ``foo`` si y "
"sólo si tiene un método :meth:`!do_foo`.  Como caso especial, una línea que "
"comienza con el carácter ``'?'`` se envía al método :meth:`do_help`.  Como "
"otro caso especial, una línea que comience con el carácter ``'!'`` se "
"enviará al método :meth:`!do_shell` (si tal método está definido)."

#: ../../library/cmd.rst:74
msgid ""
"This method will return when the :meth:`postcmd` method returns a true "
"value. The *stop* argument to :meth:`postcmd` is the return value from the "
"command's corresponding :meth:`!do_\\*` method."
msgstr ""
"Este método retornará cuando el método :meth:`postcmd` devuelva un valor "
"verdadero. El argumento *stop* de :meth:`postcmd` es el valor de retorno del "
"método :meth:`!do_\\*` correspondiente al comando."

#: ../../library/cmd.rst:78
msgid ""
"If completion is enabled, completing commands will be done automatically, "
"and completing of commands args is done by calling :meth:`!complete_foo` "
"with arguments *text*, *line*, *begidx*, and *endidx*.  *text* is the string "
"prefix we are attempting to match: all returned matches must begin with it. "
"*line* is the current input line with leading whitespace removed, *begidx* "
"and *endidx* are the beginning and ending indexes of the prefix text, which "
"could be used to provide different completion depending upon which position "
"the argument is in."
msgstr ""
"Si la finalización está activada, los comandos se completarán "
"automáticamente, y la finalización de los comandos args se realiza llamando "
"a :meth:`!complete_foo` con los argumentos *text*, *line*, *begidx* y "
"*endidx*.  *text* es el prefijo de la cadena con la que intentamos "
"coincidir: todas las coincidencias devueltas deben empezar por él. *line* es "
"la línea de entrada actual con los espacios en blanco eliminados, *begidx* y "
"*endidx* son los índices inicial y final del prefijo de texto, que pueden "
"usarse para proporcionar una terminación diferente dependiendo de la "
"posición en la que se encuentre el argumento."

#: ../../library/cmd.rst:89
msgid ""
"All subclasses of :class:`Cmd` inherit a predefined :meth:`!do_help`.  This "
"method, called with an argument ``'bar'``, invokes the corresponding method :"
"meth:`!help_bar`, and if that is not present, prints the docstring of :meth:"
"`!do_bar`, if available.  With no argument, :meth:`!do_help` lists all "
"available help topics (that is, all commands with corresponding :meth:`!"
"help_\\*` methods or commands that have docstrings), and also lists any "
"undocumented commands."
msgstr ""
"Todas las subclases de :class:`Cmd` heredan un método predefinido :meth:`!"
"do_help`.  Este método, llamado con un argumento ``'bar'``, invoca al método "
"correspondiente :meth:`!help_bar`, y si éste no está presente, imprime el "
"docstring de :meth:`!do_bar`, si está disponible.  Sin argumento, :meth:`!"
"do_help` lista todos los temas de ayuda disponibles (es decir, todos los "
"comandos con métodos :meth:`!help_\\*` correspondientes o comandos que "
"tienen docstrings), y también lista cualquier comando no documentado."

#: ../../library/cmd.rst:100
msgid ""
"Interpret the argument as though it had been typed in response to the "
"prompt. This may be overridden, but should not normally need to be; see the :"
"meth:`precmd` and :meth:`postcmd` methods for useful execution hooks.  The "
"return value is a flag indicating whether interpretation of commands by the "
"interpreter should stop.  If there is a :meth:`!do_\\*` method for the "
"command *str*, the return value of that method is returned, otherwise the "
"return value from the :meth:`default` method is returned."
msgstr ""
"Interpreta el argumento como si hubiera sido escrito en respuesta al prompt. "
"Esto puede ser sobreescrito, pero normalmente no debería ser necesario; ver "
"los métodos :meth:`precmd` y :meth:`postcmd` para ganchos de ejecución "
"útiles.  El valor de retorno es una bandera que indica si la interpretación "
"de comandos por el intérprete debe detenerse.  Si existe un método :meth:`!"
"do_\\*` para el comando *str*, se devuelve el valor de retorno de ese "
"método, en caso contrario se devuelve el valor de retorno del método :meth:"
"`default`."

#: ../../library/cmd.rst:111
msgid ""
"Method called when an empty line is entered in response to the prompt. If "
"this method is not overridden, it repeats the last nonempty command entered."
msgstr ""
"Método llamado cuando se introduce una línea vacía en respuesta al prompt. "
"Si no se anula este método, se repite el último comando no vacío introducido."

#: ../../library/cmd.rst:117
msgid ""
"Method called on an input line when the command prefix is not recognized. If "
"this method is not overridden, it prints an error message and returns."
msgstr ""
"Método llamado en una línea de entrada cuando no se reconoce el prefijo del "
"comando. Si este método no se sobrescribe, imprime un mensaje de error y "
"devuelve."

#: ../../library/cmd.rst:123
msgid ""
"Method called to complete an input line when no command-specific :meth:`!"
"complete_\\*` method is available.  By default, it returns an empty list."
msgstr ""
"Método llamado para completar una línea de entrada cuando no hay disponible "
"ningún método :meth:`!complete_\\*` específico del comando.  Por defecto, "
"devuelve una lista vacía."

#: ../../library/cmd.rst:129
msgid ""
"Method called to display a list of strings as a compact set of columns. Each "
"column is only as wide as necessary. Columns are separated by two spaces for "
"readability."
msgstr ""
"Método llamado para mostrar una lista de cadenas como un conjunto compacto "
"de columnas. Cada columna es tan ancha como sea necesario. Las columnas "
"están separadas por dos espacios para facilitar la lectura."

#: ../../library/cmd.rst:136
msgid ""
"Hook method executed just before the command line *line* is interpreted, but "
"after the input prompt is generated and issued.  This method is a stub in :"
"class:`Cmd`; it exists to be overridden by subclasses.  The return value is "
"used as the command which will be executed by the :meth:`onecmd` method; "
"the :meth:`precmd` implementation may re-write the command or simply return "
"*line* unchanged."
msgstr ""
"Método gancho ejecutado justo antes de que se interprete la línea *line* de "
"comandos, pero después de que se genere y emita el prompt de entrada.  Este "
"método es un stub en :class:`Cmd`; existe para sobreescribirse por "
"subclases.  El valor devuelto se utiliza como la orden que se ejecutará por "
"el método :meth:`onecmd`; la implementación de :meth:`precmd` puede "
"reescribir la orden o simplemente devolver *línea* sin cambios."

#: ../../library/cmd.rst:146
msgid ""
"Hook method executed just after a command dispatch is finished.  This method "
"is a stub in :class:`Cmd`; it exists to be overridden by subclasses.  *line* "
"is the command line which was executed, and *stop* is a flag which indicates "
"whether execution will be terminated after the call to :meth:`postcmd`; this "
"will be the return value of the :meth:`onecmd` method.  The return value of "
"this method will be used as the new value for the internal flag which "
"corresponds to *stop*; returning false will cause interpretation to continue."
msgstr ""
"Método gancho que se ejecuta justo después de finalizar el envío de un "
"comando.  Este método es un stub en :class:`Cmd`; existe para ser "
"sobreescrito por subclases.  *line* es la línea de comando que fue "
"ejecutada, y *stop* es una bandera que indica si la ejecución será terminada "
"después de la llamada a :meth:`postcmd`; este será el valor de retorno del "
"método :meth:`onecmd`.  El valor de retorno de este método se utilizará como "
"el nuevo valor para la bandera interna que corresponde a *stop*; devolver "
"false hará que la interpretación continúe."

#: ../../library/cmd.rst:157
msgid ""
"Hook method executed once when :meth:`cmdloop` is called.  This method is a "
"stub in :class:`Cmd`; it exists to be overridden by subclasses."
msgstr ""
"Método gancho que se ejecuta una vez cuando se llama a :meth:`cmdloop`.  "
"Este método es un stub en :class:`Cmd`; existe para ser sobrescrito por "
"subclases."

#: ../../library/cmd.rst:163
msgid ""
"Hook method executed once when :meth:`cmdloop` is about to return. This "
"method is a stub in :class:`Cmd`; it exists to be overridden by subclasses."
msgstr ""
"Método gancho que se ejecuta una vez cuando :meth:`cmdloop` está a punto de "
"regresar. Este método es un stub en :class:`Cmd`; existe para ser "
"sobrescrito por subclases."

#: ../../library/cmd.rst:167
msgid ""
"Instances of :class:`Cmd` subclasses have some public instance variables:"
msgstr ""
"Las instancias de las subclases de :class:`Cmd` tienen algunas variables de "
"instancia públicas:"

#: ../../library/cmd.rst:171
msgid "The prompt issued to solicit input."
msgstr "El mensaje emitido para solicitar entradas."

#: ../../library/cmd.rst:176
msgid "The string of characters accepted for the command prefix."
msgstr "La cadena de caracteres aceptada para el prefijo del comando."

#: ../../library/cmd.rst:181
msgid "The last nonempty command prefix seen."
msgstr "El último prefijo de comando no vacío visto."

#: ../../library/cmd.rst:186
msgid ""
"A list of queued input lines.  The cmdqueue list is checked in :meth:"
"`cmdloop` when new input is needed; if it is nonempty, its elements will be "
"processed in order, as if entered at the prompt."
msgstr ""
"Una lista de líneas de entrada en cola.  La lista cmdqueue se comprueba en :"
"meth:`cmdloop` cuando se necesita una nueva entrada; si no está vacía, sus "
"elementos se procesarán en orden, como si se hubieran introducido en el "
"prompt."

#: ../../library/cmd.rst:193
msgid ""
"A string to issue as an intro or banner.  May be overridden by giving the :"
"meth:`cmdloop` method an argument."
msgstr ""
"Una cadena para usar como intro o banner.  Puede anularse dando un argumento "
"al método :meth:`cmdloop`."

#: ../../library/cmd.rst:199
msgid ""
"The header to issue if the help output has a section for documented commands."
msgstr ""
"La cabecera a emitir si la salida de ayuda tiene una sección para comandos "
"documentados."

#: ../../library/cmd.rst:204
msgid ""
"The header to issue if the help output has a section for miscellaneous  help "
"topics (that is, there are :meth:`!help_\\*` methods without corresponding :"
"meth:`!do_\\*` methods)."
msgstr ""
"La cabecera a emitir si la salida de ayuda tiene una sección para temas de "
"ayuda varios (es decir, hay métodos :meth:`!help_\\*` sin los "
"correspondientes métodos :meth:`!do_\\*` )."

#: ../../library/cmd.rst:211
msgid ""
"The header to issue if the help output has a section for undocumented  "
"commands (that is, there are :meth:`!do_\\*` methods without corresponding :"
"meth:`!help_\\*` methods)."
msgstr ""
"El encabezado a emitir si la salida de ayuda tiene una sección para comandos "
"no documentados (es decir, hay métodos :meth:`!do_\\*` sin los "
"correspondientes métodos :meth:`!help_\\*` )."

#: ../../library/cmd.rst:218
msgid ""
"The character used to draw separator lines under the help-message headers.  "
"If empty, no ruler line is drawn.  It defaults to ``'='``."
msgstr ""
"Carácter utilizado para dibujar líneas de separación bajo las cabeceras de "
"los mensajes de ayuda.  Si está vacío, no se dibuja ninguna línea de "
"separación.  Por defecto es ``'='``."

#: ../../library/cmd.rst:224
msgid ""
"A flag, defaulting to true.  If true, :meth:`cmdloop` uses :func:`input` to "
"display a prompt and read the next command; if false, :data:`sys.stdout."
"write() <sys.stdout>` and :data:`sys.stdin.readline() <sys.stdin>` are used. "
"(This means that by importing :mod:`readline`, on systems that support it, "
"the interpreter will automatically support :program:`Emacs`\\ -like line "
"editing  and command-history keystrokes.)"
msgstr ""
"Un indicador, por defecto verdadero.  Si es verdadero, :meth:`cmdloop` usa :"
"func:`input` para mostrar un prompt y leer el siguiente comando; si es "
"falso, se usa :data:`sys.stdout.write() <sys.stdout>` y :data:`sys.stdin."
"readline() <sys.stdin>`. (Esto significa que al importar :mod:`readline`, en "
"los sistemas que lo soporten, el intérprete soportará automáticamente :"
"program:`Emacs`\\ -como la edición de líneas y las pulsaciones de teclas de "
"historial de comandos)."

#: ../../library/cmd.rst:234
msgid "Cmd Example"
msgstr "Cmd Ejemplo"

#: ../../library/cmd.rst:238
msgid ""
"The :mod:`cmd` module is mainly useful for building custom shells that let a "
"user work with a program interactively."
msgstr ""
"El módulo :mod:`cmd` es útil principalmente para construir shells "
"personalizados que permitan al usuario trabajar con un programa de forma "
"interactiva."

#: ../../library/cmd.rst:241
msgid ""
"This section presents a simple example of how to build a shell around a few "
"of the commands in the :mod:`turtle` module."
msgstr ""
"Esta sección presenta un ejemplo sencillo de cómo construir un intérprete de "
"comandos en torno a algunos de los comandos del módulo :mod:`turtle`."

#: ../../library/cmd.rst:244
msgid ""
"Basic turtle commands such as :meth:`~turtle.forward` are added to a :class:"
"`Cmd` subclass with method named :meth:`!do_forward`.  The argument is "
"converted to a number and dispatched to the turtle module.  The docstring is "
"used in the help utility provided by the shell."
msgstr ""
"Los comandos básicos de turtle como :meth:`~turtle.forward` se añaden a una "
"subclase de :class:`Cmd` con un método llamado :meth:`!do_forward`.  El "
"argumento se convierte en un número y se envía al módulo turtle.  El "
"docstring se utiliza en la utilidad de ayuda proporcionada por el shell."

#: ../../library/cmd.rst:249
msgid ""
"The example also includes a basic record and playback facility implemented "
"with the :meth:`~Cmd.precmd` method which is responsible for converting the "
"input to lowercase and writing the commands to a file.  The :meth:`!"
"do_playback` method reads the file and adds the recorded commands to the :"
"attr:`~Cmd.cmdqueue` for immediate playback::"
msgstr ""
"El ejemplo también incluye una función básica de grabación y reproducción "
"implementada con el método :meth:`~Cmd.precmd`, que se encarga de convertir "
"la entrada a minúsculas y escribir los comandos en un archivo.  El método :"
"meth:`!do_playback` lee el archivo y añade los comandos grabados a :attr:"
"`~Cmd.cmdqueue` para su reproducción inmediata::"

#: ../../library/cmd.rst:255
msgid ""
"import cmd, sys\n"
"from turtle import *\n"
"\n"
"class TurtleShell(cmd.Cmd):\n"
"    intro = 'Welcome to the turtle shell.   Type help or ? to list commands."
"\\n'\n"
"    prompt = '(turtle) '\n"
"    file = None\n"
"\n"
"    # ----- basic turtle commands -----\n"
"    def do_forward(self, arg):\n"
"        'Move the turtle forward by the specified distance:  FORWARD 10'\n"
"        forward(*parse(arg))\n"
"    def do_right(self, arg):\n"
"        'Turn turtle right by given number of degrees:  RIGHT 20'\n"
"        right(*parse(arg))\n"
"    def do_left(self, arg):\n"
"        'Turn turtle left by given number of degrees:  LEFT 90'\n"
"        left(*parse(arg))\n"
"    def do_goto(self, arg):\n"
"        'Move turtle to an absolute position with changing orientation.  "
"GOTO 100 200'\n"
"        goto(*parse(arg))\n"
"    def do_home(self, arg):\n"
"        'Return turtle to the home position:  HOME'\n"
"        home()\n"
"    def do_circle(self, arg):\n"
"        'Draw circle with given radius an options extent and steps:  CIRCLE "
"50'\n"
"        circle(*parse(arg))\n"
"    def do_position(self, arg):\n"
"        'Print the current turtle position:  POSITION'\n"
"        print('Current position is %d %d\\n' % position())\n"
"    def do_heading(self, arg):\n"
"        'Print the current turtle heading in degrees:  HEADING'\n"
"        print('Current heading is %d\\n' % (heading(),))\n"
"    def do_color(self, arg):\n"
"        'Set the color:  COLOR BLUE'\n"
"        color(arg.lower())\n"
"    def do_undo(self, arg):\n"
"        'Undo (repeatedly) the last turtle action(s):  UNDO'\n"
"    def do_reset(self, arg):\n"
"        'Clear the screen and return turtle to center:  RESET'\n"
"        reset()\n"
"    def do_bye(self, arg):\n"
"        'Stop recording, close the turtle window, and exit:  BYE'\n"
"        print('Thank you for using Turtle')\n"
"        self.close()\n"
"        bye()\n"
"        return True\n"
"\n"
"    # ----- record and playback -----\n"
"    def do_record(self, arg):\n"
"        'Save future commands to filename:  RECORD rose.cmd'\n"
"        self.file = open(arg, 'w')\n"
"    def do_playback(self, arg):\n"
"        'Playback commands from a file:  PLAYBACK rose.cmd'\n"
"        self.close()\n"
"        with open(arg) as f:\n"
"            self.cmdqueue.extend(f.read().splitlines())\n"
"    def precmd(self, line):\n"
"        line = line.lower()\n"
"        if self.file and 'playback' not in line:\n"
"            print(line, file=self.file)\n"
"        return line\n"
"    def close(self):\n"
"        if self.file:\n"
"            self.file.close()\n"
"            self.file = None\n"
"\n"
"def parse(arg):\n"
"    'Convert a series of zero or more numbers to an argument tuple'\n"
"    return tuple(map(int, arg.split()))\n"
"\n"
"if __name__ == '__main__':\n"
"    TurtleShell().cmdloop()"
msgstr ""
"import cmd, sys\n"
"from turtle import *\n"
"\n"
"class TurtleShell(cmd.Cmd):\n"
"    intro = 'Bienvenido al shell de turtle. Escribe help o ? para ver la "
"lista de comandos.\\n'\n"
"    prompt = '(turtle) '\n"
"    file = None\n"
"\n"
"    # ----- comandos básicos de turtle -----\n"
"    def do_forward(self, arg):\n"
"        'Mueve turtle adelante a la distancia especificada: FORWARD 10'\n"
"        forward(*parse(arg))\n"
"    def do_right(self, arg):\n"
"        'Gira turtle a la derecha el número de grados dado: RIGHT 20'\n"
"        right(*parse(arg))\n"
"    def do_left(self, arg):\n"
"        'Gira turtle a la izquierda el número de grados dado:  LEFT 90'\n"
"        left(*parse(arg))\n"
"    def do_goto(self, arg):\n"
"        'Mueve turtle a una posición absoluta con cambio de orientación.  "
"GOTO 100 200'\n"
"        goto(*parse(arg))\n"
"    def do_home(self, arg):\n"
"        'Devuelve turtle a la posición inicial:  HOME'\n"
"        home()\n"
"    def do_circle(self, arg):\n"
"        'Dibuja un circulo con un radio dado y opciones de extensión y "
"pasos:  CIRCLE 50'\n"
"        circle(*parse(arg))\n"
"    def do_position(self, arg):\n"
"        'Imprime la posición actual de turtle:  POSITION'\n"
"        print('El rumbo actual es %d %d\\n' % position())\n"
"    def do_heading(self, arg):\n"
"        'Imprime el rumbo actual de turtle en grados:  HEADING'\n"
"        print('El rumbo actual es %d\\n' % (heading(),))\n"
"    def do_color(self, arg):\n"
"        'Establece el color:  COLOR BLUE'\n"
"        color(arg.lower())\n"
"    def do_undo(self, arg):\n"
"        'Deshacer (repetidamente) la-s última(s) acción-es de turtle:  "
"UNDO'\n"
"    def do_reset(self, arg):\n"
"        'Limpia la pantalla y devuelve turtle al centro:  RESET'\n"
"        reset()\n"
"    def do_bye(self, arg):\n"
"        'Deja de grabar, cierra la ventana de turtle y sal:  BYE'\n"
"        print('Thank you for using Turtle')\n"
"        self.close()\n"
"        bye()\n"
"        return True\n"
"\n"
"    # ----- grabar y reproducir -----\n"
"    def do_record(self, arg):\n"
"        'Guarda los futuros comandos en un archivo:  RECORD rose.cmd'\n"
"        self.file = open(arg, 'w')\n"
"    def do_playback(self, arg):\n"
"        'Reproducir comandos desde un archivo:  PLAYBACK rose.cmd'\n"
"        self.close()\n"
"        with open(arg) as f:\n"
"            self.cmdqueue.extend(f.read().splitlines())\n"
"    def precmd(self, line):\n"
"        line = line.lower()\n"
"        if self.file and 'playback' not in line:\n"
"            print(line, file=self.file)\n"
"        return line\n"
"    def close(self):\n"
"        if self.file:\n"
"            self.file.close()\n"
"            self.file = None\n"
"\n"
"def parse(arg):\n"
"    'Convierte una serie de cero o más números en una tupla de argumentos'\n"
"    return tuple(map(int, arg.split()))\n"
"\n"
"if __name__ == '__main__':\n"
"    TurtleShell().cmdloop()"

#: ../../library/cmd.rst:330
msgid ""
"Here is a sample session with the turtle shell showing the help functions, "
"using blank lines to repeat commands, and the simple record and playback "
"facility:"
msgstr ""
"Aquí tienes un ejemplo de sesión con el caparazón de tortuga que muestra las "
"funciones de ayuda, el uso de líneas en blanco para repetir comandos y la "
"sencilla función de grabación y reproducción:"

#: ../../library/cmd.rst:333
msgid ""
"Welcome to the turtle shell.   Type help or ? to list commands.\n"
"\n"
"(turtle) ?\n"
"\n"
"Documented commands (type help <topic>):\n"
"========================================\n"
"bye     color    goto     home  playback  record  right\n"
"circle  forward  heading  left  position  reset   undo\n"
"\n"
"(turtle) help forward\n"
"Move the turtle forward by the specified distance:  FORWARD 10\n"
"(turtle) record spiral.cmd\n"
"(turtle) position\n"
"Current position is 0 0\n"
"\n"
"(turtle) heading\n"
"Current heading is 0\n"
"\n"
"(turtle) reset\n"
"(turtle) circle 20\n"
"(turtle) right 30\n"
"(turtle) circle 40\n"
"(turtle) right 30\n"
"(turtle) circle 60\n"
"(turtle) right 30\n"
"(turtle) circle 80\n"
"(turtle) right 30\n"
"(turtle) circle 100\n"
"(turtle) right 30\n"
"(turtle) circle 120\n"
"(turtle) right 30\n"
"(turtle) circle 120\n"
"(turtle) heading\n"
"Current heading is 180\n"
"\n"
"(turtle) forward 100\n"
"(turtle)\n"
"(turtle) right 90\n"
"(turtle) forward 100\n"
"(turtle)\n"
"(turtle) right 90\n"
"(turtle) forward 400\n"
"(turtle) right 90\n"
"(turtle) forward 500\n"
"(turtle) right 90\n"
"(turtle) forward 400\n"
"(turtle) right 90\n"
"(turtle) forward 300\n"
"(turtle) playback spiral.cmd\n"
"Current position is 0 0\n"
"\n"
"Current heading is 0\n"
"\n"
"Current heading is 180\n"
"\n"
"(turtle) bye\n"
"Thank you for using Turtle"
msgstr ""
"Bienvenido al caparazón de turtle.   Escribe help o ? para ver la lista de "
"comandos.\n"
"\n"
"(turtle) ?\n"
"\n"
"Comandos documentados (escribe help <topic>):\n"
"========================================\n"
"bye color goto home reproducción grabar derecha\n"
"círculo adelante dirección izquierda posición reset deshacer\n"
"\n"
"(turtle) ayuda adelante\n"
"Mueve turtle hacia delante la distancia especificada:  ADELANTE 10\n"
"(turtle) grabar espiral.cmd\n"
"(turtle) posición\n"
"La posición actual es 0 0\n"
"\n"
"(turtle) rumbo\n"
"El rumbo actual es 0\n"
"\n"
"(turtle) reinicio\n"
"(turtle) círculo 20\n"
"(turtle) derecha 30\n"
"(turtle) círculo 40\n"
"(turtle) derecha 30\n"
"(turtle) círculo 60\n"
"(turtle) derecha 30\n"
"(turtle) círculo 80\n"
"(turtle) derecha 30\n"
"(turtle) círculo 100\n"
"(turtle) derecha 30\n"
"(turtle) círculo 120\n"
"(turtle) derecha 30\n"
"(turtle) círculo 120\n"
"(turtle) rumbo\n"
"El rumbo actual es 180\n"
"\n"
"(turtle) adelante 100\n"
"(turtle)\n"
"(turtle) derecha 90\n"
"(turtle) adelante 100\n"
"(turtle)\n"
"(turtle) derecha 90\n"
"(turtle) adelante 400\n"
"(turtle) derecha 90\n"
"(turtle) adelante 500\n"
"(turtle) derecha 90\n"
"(turtle) adelante 400\n"
"(turtle) derecha 90\n"
"(turtle) adelante 300\n"
"(turtle) reproducción espiral.cmd\n"
"La posición actual es 0 0\n"
"\n"
"Rumbo actual es 0\n"
"\n"
"El rumbo actual es 180\n"
"\n"
"(turtle) adiós\n"
"Gracias por usar Turtle"

#: ../../library/cmd.rst:64
msgid "? (question mark)"
msgstr "? (signo de interrogación)"

#: ../../library/cmd.rst:64
msgid "in a command interpreter"
msgstr "en un intérprete de comandos"

#: ../../library/cmd.rst:64
msgid "! (exclamation)"
msgstr "¡! (exclamación)"
