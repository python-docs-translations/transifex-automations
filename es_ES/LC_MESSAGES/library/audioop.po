# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-23 16:19+0000\n"
"PO-Revision-Date: 2025-09-22 16:49+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Spanish (Spain) (https://app.transifex.com/python-doc/"
"teams/5390/es_ES/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es_ES\n"
"Plural-Forms: nplurals=3; plural=n == 1 ? 0 : n != 0 && n % 1000000 == 0 ? "
"1 : 2;\n"

#: ../../library/audioop.rst:2
msgid ":mod:`audioop` --- Manipulate raw audio data"
msgstr ":mod:`audioop` --- Manipular datos de audio sin procesar"

#: ../../library/audioop.rst:11
msgid ""
"The :mod:`audioop` module is deprecated (see :pep:`PEP 594 <594#audioop>` "
"for details)."
msgstr ""
"El módulo :mod:`audioop` está obsoleto (ver :pep:`PEP 594 <594#audioop>` "
"para más detalles)."

#: ../../library/audioop.rst:14
msgid ""
"The :mod:`audioop` module contains some useful operations on sound "
"fragments. It operates on sound fragments consisting of signed integer "
"samples 8, 16, 24 or 32 bits wide, stored in :term:`bytes-like objects "
"<bytes-like object>`.  All scalar items are integers, unless specified "
"otherwise."
msgstr ""
"El módulo :mod:`audioop` contiene algunas operaciones útiles sobre "
"fragmentos de sonido. Opera sobre fragmentos de sonido consistentes en "
"muestras enteras con signo de 8, 16, 24 o 32 bits de ancho, almacenadas en :"
"term:`bytes-like objects <bytes-like object>`.  Todos los elementos "
"escalares son enteros, a menos que se especifique lo contrario."

#: ../../library/audioop.rst:19
msgid ""
"Support for 24-bit samples was added. All functions now accept any :term:"
"`bytes-like object`. String input now results in an immediate error."
msgstr ""
"Se ha añadido soporte para muestras de 24 bits. Todas las funciones aceptan "
"ahora cualquier :term:`bytes-like object`. La entrada de cadenas ahora "
"produce un error inmediato."

#: ../../library/audioop.rst:30
msgid ""
"This module provides support for a-LAW, u-LAW and Intel/DVI ADPCM encodings."
msgstr ""
"Este módulo es compatible con las codificaciones a-LAW, u-LAW e Intel/DVI "
"ADPCM."

#: ../../library/audioop.rst:34
msgid ""
"A few of the more complicated operations only take 16-bit samples, otherwise "
"the sample size (in bytes) is always a parameter of the operation."
msgstr ""
"Algunas de las operaciones más complicadas sólo toman muestras de 16 bits; "
"por lo demás, el tamaño de la muestra (en bytes) es siempre un parámetro de "
"la operación."

#: ../../library/audioop.rst:37
msgid "The module defines the following variables and functions:"
msgstr "El módulo define las siguientes variables y funciones:"

#: ../../library/audioop.rst:42
msgid ""
"This exception is raised on all errors, such as unknown number of bytes per "
"sample, etc."
msgstr ""
"Esta excepción se lanza en todos los errores, como número desconocido de "
"bytes por muestra, etc."

#: ../../library/audioop.rst:48
msgid ""
"Return a fragment which is the addition of the two samples passed as "
"parameters. *width* is the sample width in bytes, either ``1``, ``2``, ``3`` "
"or ``4``.  Both fragments should have the same length.  Samples are "
"truncated in case of overflow."
msgstr ""
"Devuelve un fragmento que es la suma de las dos muestras pasadas como "
"parámetros. *width* es la anchura de la muestra en bytes, ya sea ``1``, "
"``2``, ``3`` o ``4``. Ambos fragmentos deben tener la misma longitud.  Las "
"muestras se truncan en caso de desbordamiento."

#: ../../library/audioop.rst:55
msgid ""
"Decode an Intel/DVI ADPCM coded fragment to a linear fragment.  See the "
"description of :func:`lin2adpcm` for details on ADPCM coding. Return a tuple "
"``(sample, newstate)`` where the sample has the width specified in *width*."
msgstr ""
"Decodifica un fragmento codificado Intel/DVI ADPCM a un fragmento lineal.  "
"Consulte la descripción de :func:`lin2adpcm` para más detalles sobre la "
"codificación ADPCM. Devuelve una tupla ``(sample, newstate)`` donde la "
"muestra tiene la anchura especificada en *width*."

#: ../../library/audioop.rst:62
msgid ""
"Convert sound fragments in a-LAW encoding to linearly encoded sound "
"fragments. a-LAW encoding always uses 8 bits samples, so *width* refers only "
"to the sample width of the output fragment here."
msgstr ""
"Convierte fragmentos de sonido en codificación a-LAW a fragmentos de sonido "
"codificados linealmente. La codificación a-LAW utiliza siempre muestras de 8 "
"bits, por lo que *ancho* se refiere aquí sólo al ancho de muestra del "
"fragmento de salida."

#: ../../library/audioop.rst:69
msgid "Return the average over all samples in the fragment."
msgstr "Devuelve la media de todas las muestras del fragmento."

#: ../../library/audioop.rst:74
msgid ""
"Return the average peak-peak value over all samples in the fragment. No "
"filtering is done, so the usefulness of this routine is questionable."
msgstr ""
"Devuelve el valor pico-pico medio de todas las muestras del fragmento. No se "
"realiza ningún filtrado, por lo que la utilidad de esta rutina es "
"cuestionable."

#: ../../library/audioop.rst:80
msgid ""
"Return a fragment that is the original fragment with a bias added to each "
"sample.  Samples wrap around in case of overflow."
msgstr ""
"Devuelve un fragmento que es el fragmento original con un sesgo añadido a "
"cada muestra.  Las muestras se envuelven en caso de desbordamiento."

#: ../../library/audioop.rst:86
msgid ""
"\"Byteswap\" all samples in a fragment and returns the modified fragment. "
"Converts big-endian samples to little-endian and vice versa."
msgstr ""
"\"Byteswap\" todas las muestras de un fragmento y devuelve el fragmento "
"modificado. Convierte muestras big-endian a little-endian y viceversa."

#: ../../library/audioop.rst:94
msgid ""
"Return the number of zero crossings in the fragment passed as an argument."
msgstr ""
"Devuelve el número de cruces por cero en el fragmento pasado como argumento."

#: ../../library/audioop.rst:99
msgid ""
"Return a factor *F* such that ``rms(add(fragment, mul(reference, -F)))`` is "
"minimal, i.e., return the factor with which you should multiply *reference* "
"to make it match as well as possible to *fragment*.  The fragments should "
"both contain 2-byte samples."
msgstr ""
"Devuelve un factor *F* tal que ``rms(add(fragment, mul(reference, -F)))`` "
"sea mínimo, es decir, devuelve el factor con el que se debe multiplicar "
"*referencia* para que coincida lo mejor posible con *fragmento*.  Ambos "
"fragmentos deben contener muestras de 2 bytes."

#: ../../library/audioop.rst:104
msgid "The time taken by this routine is proportional to ``len(fragment)``."
msgstr "El tiempo que tarda esta rutina es proporcional a ``len(fragment)``."

#: ../../library/audioop.rst:109
msgid ""
"Try to match *reference* as well as possible to a portion of *fragment* "
"(which should be the longer fragment).  This is (conceptually) done by "
"taking slices out of *fragment*, using :func:`findfactor` to compute the "
"best match, and minimizing the result.  The fragments should both contain 2-"
"byte samples. Return a tuple ``(offset, factor)`` where *offset* is the "
"(integer) offset into *fragment* where the optimal match started and "
"*factor* is the (floating-point) factor as per :func:`findfactor`."
msgstr ""
"Intentar que *reference* coincida lo mejor posible con una porción de "
"*fragment* (que debería ser el fragmento más largo).  Esto se hace "
"(conceptualmente) tomando trozos de *fragment*, usando :func:`findfactor` "
"para calcular la mejor coincidencia, y minimizando el resultado.  Ambos "
"fragmentos deben contener muestras de 2 bytes. Devuelve una tupla ``(offset, "
"factor)`` donde *offset* es el desplazamiento (entero) en *fragment* donde "
"empezó la coincidencia óptima y *factor* es el factor (coma flotante) según :"
"func:`findfactor`."

#: ../../library/audioop.rst:120
msgid ""
"Search *fragment* for a slice of length *length* samples (not bytes!) with "
"maximum energy, i.e., return *i* for which ``rms(fragment[i*2:"
"(i+length)*2])`` is maximal.  The fragments should both contain 2-byte "
"samples."
msgstr ""
"Busca en *fragment* un fragmento de muestras de *length* (¡no bytes!) con la "
"máxima energía, es decir, devuelve *i* para el que ``rms(fragment[i*2:"
"(i+length)*2])`` es máximo.  Ambos fragmentos deben contener muestras de 2 "
"bytes."

#: ../../library/audioop.rst:124
msgid "The routine takes time proportional to ``len(fragment)``."
msgstr "La rutina tarda un tiempo proporcional a ``len(fragment)``."

#: ../../library/audioop.rst:129
msgid "Return the value of sample *index* from the fragment."
msgstr "Devuelve el valor de la muestra *index* del fragmento."

#: ../../library/audioop.rst:134
msgid ""
"Convert samples to 4 bit Intel/DVI ADPCM encoding.  ADPCM coding is an "
"adaptive coding scheme, whereby each 4 bit number is the difference between "
"one sample and the next, divided by a (varying) step.  The Intel/DVI ADPCM "
"algorithm has been selected for use by the IMA, so it may well become a "
"standard."
msgstr ""
"Convierte las muestras a codificación Intel/DVI ADPCM de 4 bits.  La "
"codificación ADPCM es un esquema de codificación adaptativa, según el cual "
"cada número de 4 bits es la diferencia entre una muestra y la siguiente, "
"dividida por un paso (variable).  El algoritmo Intel/DVI ADPCM ha sido "
"seleccionado para su uso por la IMA, por lo que es muy posible que se "
"convierta en un estándar."

#: ../../library/audioop.rst:139
msgid ""
"*state* is a tuple containing the state of the coder.  The coder returns a "
"tuple ``(adpcmfrag, newstate)``, and the *newstate* should be passed to the "
"next call of :func:`lin2adpcm`.  In the initial call, ``None`` can be passed "
"as the state. *adpcmfrag* is the ADPCM coded fragment packed 2 4-bit values "
"per byte."
msgstr ""
"*state* es una tupla que contiene el estado del codificador.  El codificador "
"devuelve una tupla ``(adpcmfrag, newstate)``, y el *newstate* debe pasarse a "
"la siguiente llamada de :func:`lin2adpcm`. En la llamada inicial, ``None`` "
"puede pasarse como estado. *adpcmfrag* es el fragmento codificado ADPCM "
"empaquetado en 2 valores de 4 bits por byte."

#: ../../library/audioop.rst:147
msgid ""
"Convert samples in the audio fragment to a-LAW encoding and return this as a "
"bytes object.  a-LAW is an audio encoding format whereby you get a dynamic "
"range of about 13 bits using only 8 bit samples.  It is used by the Sun "
"audio hardware, among others."
msgstr ""
"Convertir muestras en el fragmento de audio a codificación a-LAW y "
"devolverlo como un objeto bytes. a-LAW es un formato de codificación de "
"audio mediante el cual obtienes un rango dinámico de aproximadamente 13 bits "
"usando solo muestras de 8 bits. Es utilizado por el hardware de audio Sun, "
"entre otros."

#: ../../library/audioop.rst:155
msgid "Convert samples between 1-, 2-, 3- and 4-byte formats."
msgstr "Convierte muestras entre formatos de 1, 2, 3 y 4 bytes."

#: ../../library/audioop.rst:159
msgid ""
"In some audio formats, such as .WAV files, 16, 24 and 32 bit samples are "
"signed, but 8 bit samples are unsigned.  So when converting to 8 bit wide "
"samples for these formats, you need to also add 128 to the result::"
msgstr ""
"En algunos formatos de audio, como los archivos .WAV, las muestras de 16, 24 "
"y 32 bits tienen signo, pero las de 8 bits no lo tienen.  Por tanto, al "
"convertir a muestras de 8 bits de ancho para estos formatos, también hay que "
"sumar 128 al resultado::"

#: ../../library/audioop.rst:166
msgid ""
"The same, in reverse, has to be applied when converting from 8 to 16, 24 or "
"32 bit width samples."
msgstr ""
"Lo mismo, a la inversa, hay que aplicar cuando se convierten muestras de 8 a "
"16, 24 o 32 bits de ancho."

#: ../../library/audioop.rst:172
msgid ""
"Convert samples in the audio fragment to u-LAW encoding and return this as a "
"bytes object.  u-LAW is an audio encoding format whereby you get a dynamic "
"range of about 14 bits using only 8 bit samples.  It is used by the Sun "
"audio hardware, among others."
msgstr ""
"Convierte las muestras del fragmento de audio a codificación u-LAW y lo "
"devuelve como un objeto bytes. u-LAW es un formato de codificación de audio "
"con el que se obtiene un rango dinámico de unos 14 bits utilizando sólo "
"muestras de 8 bits.  Lo utiliza, entre otros, el hardware de audio de Sun."

#: ../../library/audioop.rst:180
msgid ""
"Return the maximum of the *absolute value* of all samples in a fragment."
msgstr ""
"Devuelve el máximo del *valor absoluto* de todas las muestras de un "
"fragmento."

#: ../../library/audioop.rst:185
msgid "Return the maximum peak-peak value in the sound fragment."
msgstr "Devuelve el valor pico-pico máximo del fragmento de sonido."

#: ../../library/audioop.rst:190
msgid ""
"Return a tuple consisting of the minimum and maximum values of all samples "
"in the sound fragment."
msgstr ""
"Devuelve una tupla formada por los valores mínimo y máximo de todas las "
"muestras del fragmento de sonido."

#: ../../library/audioop.rst:196
msgid ""
"Return a fragment that has all samples in the original fragment multiplied "
"by the floating-point value *factor*.  Samples are truncated in case of "
"overflow."
msgstr ""
"Devuelve un fragmento que tiene todas las muestras del fragmento original "
"multiplicadas por el valor de coma flotante *factor*.  Las muestras se "
"truncan en caso de desbordamiento."

#: ../../library/audioop.rst:202
msgid "Convert the frame rate of the input fragment."
msgstr "Convierte la frecuencia de imagen del fragmento de entrada."

#: ../../library/audioop.rst:204
msgid ""
"*state* is a tuple containing the state of the converter.  The converter "
"returns a tuple ``(newfragment, newstate)``, and *newstate* should be passed "
"to the next call of :func:`ratecv`.  The initial call should pass ``None`` "
"as the state."
msgstr ""
"*state* es una tupla que contiene el estado del conversor.  El convertidor "
"devuelve una tupla ``(newfragment, newstate)``, y *newstate* debe pasarse a "
"la siguiente llamada de :func:`ratecv`. La llamada inicial debe pasar "
"``None`` como estado."

#: ../../library/audioop.rst:208
msgid ""
"The *weightA* and *weightB* arguments are parameters for a simple digital "
"filter and default to ``1`` and ``0`` respectively."
msgstr ""
"Los argumentos *weightA* y *weightB* son parámetros para un filtro digital "
"simple y por defecto son ``1`` y ``0`` respectivamente."

#: ../../library/audioop.rst:214
msgid "Reverse the samples in a fragment and returns the modified fragment."
msgstr ""
"Invierte las muestras de un fragmento y devuelve el fragmento modificado."

#: ../../library/audioop.rst:219
msgid ""
"Return the root-mean-square of the fragment, i.e. ``sqrt(sum(S_i^2)/n)``."
msgstr ""
"Devuelve la raíz cuadrada media del fragmento, es decir, ``sqrt(sum(S_i^2)/"
"n)``."

#: ../../library/audioop.rst:221
msgid "This is a measure of the power in an audio signal."
msgstr "Es una medida de la potencia de una señal de audio."

#: ../../library/audioop.rst:226
msgid ""
"Convert a stereo fragment to a mono fragment.  The left channel is "
"multiplied by *lfactor* and the right channel by *rfactor* before adding the "
"two channels to give a mono signal."
msgstr ""
"Convierte un fragmento estéreo en un fragmento mono.  El canal izquierdo se "
"multiplica por *lfactor* y el canal derecho por *rfactor* antes de sumar los "
"dos canales para obtener una señal mono."

#: ../../library/audioop.rst:233
msgid ""
"Generate a stereo fragment from a mono fragment.  Each pair of samples in "
"the stereo fragment are computed from the mono sample, whereby left channel "
"samples are multiplied by *lfactor* and right channel samples by *rfactor*."
msgstr ""
"Genera un fragmento estéreo a partir de un fragmento mono.  Cada par de "
"muestras del fragmento estéreo se calcula a partir de la muestra mono, "
"multiplicando las muestras del canal izquierdo por *lfactor* y las del canal "
"derecho por *rfactor*."

#: ../../library/audioop.rst:240
msgid ""
"Convert sound fragments in u-LAW encoding to linearly encoded sound "
"fragments. u-LAW encoding always uses 8 bits samples, so *width* refers only "
"to the sample width of the output fragment here."
msgstr ""
"Convierte fragmentos de sonido en codificación u-LAW a fragmentos de sonido "
"codificados linealmente. La codificación u-LAW utiliza siempre muestras de 8 "
"bits, por lo que *ancho* se refiere aquí sólo al ancho de muestra del "
"fragmento de salida."

#: ../../library/audioop.rst:244
msgid ""
"Note that operations such as :func:`.mul` or :func:`.max` make no "
"distinction between mono and stereo fragments, i.e. all samples are treated "
"equal.  If this is a problem the stereo fragment should be split into two "
"mono fragments first and recombined later.  Here is an example of how to do "
"that::"
msgstr ""
"Tenga en cuenta que operaciones como :func:`.mul` o :func:`.max` no "
"distinguen entre fragmentos mono y estéreo, es decir, todas las muestras se "
"tratan igual.  Si esto supone un problema, el fragmento estéreo debe "
"dividirse primero en dos fragmentos mono y recombinarse después.  He aquí un "
"ejemplo de cómo hacerlo::"

#: ../../library/audioop.rst:258
msgid ""
"If you use the ADPCM coder to build network packets and you want your "
"protocol to be stateless (i.e. to be able to tolerate packet loss) you "
"should not only transmit the data but also the state.  Note that you should "
"send the *initial* state (the one you passed to :func:`lin2adpcm`) along to "
"the decoder, not the final state (as returned by the coder).  If you want to "
"use :class:`struct.Struct` to store the state in binary you can code the "
"first element (the predicted value) in 16 bits and the second (the delta "
"index) in 8."
msgstr ""
"Si usas el codificador ADPCM para construir paquetes de red y quieres que tu "
"protocolo no tenga estado (es decir, que sea capaz de tolerar la pérdida de "
"paquetes) no sólo debes transmitir los datos sino también el estado.  Ten en "
"cuenta que debes enviar el estado *inicial* (el que pasaste a :func:"
"`lin2adpcm`) al decodificador, no el estado final (el devuelto por el "
"codificador).  Si quieres utilizar :class:`struct.Struct` para almacenar el "
"estado en binario puedes codificar el primer elemento (el valor predicho) en "
"16 bits y el segundo (el índice delta) en 8."

#: ../../library/audioop.rst:266
msgid ""
"The ADPCM coders have never been tried against other ADPCM coders, only "
"against themselves.  It could well be that I misinterpreted the standards in "
"which case they will not be interoperable with the respective standards."
msgstr ""
"Los codificadores ADPCM nunca se han probado contra otros codificadores "
"ADPCM, sólo contra sí mismos.  Es muy posible que haya malinterpretado las "
"normas, en cuyo caso no serán interoperables con las normas respectivas."

#: ../../library/audioop.rst:270
msgid ""
"The :func:`find\\*` routines might look a bit funny at first sight. They are "
"primarily meant to do echo cancellation.  A reasonably fast way to do this "
"is to pick the most energetic piece of the output sample, locate that in the "
"input sample and subtract the whole output sample from the input sample::"
msgstr ""
"Las rutinas de :func:`find\\*` pueden parecer un poco raras a primera vista. "
"Su función principal es cancelar el eco.  Una forma razonablemente rápida de "
"hacerlo es elegir el trozo más energético de la muestra de salida, "
"localizarlo en la muestra de entrada y restar toda la muestra de salida de "
"la muestra de entrada::"

#: ../../library/audioop.rst:24
msgid "Intel/DVI ADPCM"
msgstr "Intel/DVI ADPCM"

#: ../../library/audioop.rst:24
msgid "ADPCM, Intel/DVI"
msgstr "ADPCM, Intel/DVI"

#: ../../library/audioop.rst:24
msgid "a-LAW"
msgstr "a-LAW"

#: ../../library/audioop.rst:24
msgid "u-LAW"
msgstr "u-LAW"
