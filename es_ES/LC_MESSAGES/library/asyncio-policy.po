# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 16:03+0000\n"
"PO-Revision-Date: 2025-07-18 19:57+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Spanish (Spain) (https://app.transifex.com/python-doc/"
"teams/5390/es_ES/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es_ES\n"
"Plural-Forms: nplurals=3; plural=n == 1 ? 0 : n != 0 && n % 1000000 == 0 ? "
"1 : 2;\n"

#: ../../library/asyncio-policy.rst:8
msgid "Policies"
msgstr "Políticas"

#: ../../library/asyncio-policy.rst:10
msgid ""
"An event loop policy is a global object used to get and set the current :ref:"
"`event loop <asyncio-event-loop>`, as well as create new event loops. The "
"default policy can be :ref:`replaced <asyncio-policy-get-set>` with :ref:"
"`built-in alternatives <asyncio-policy-builtin>` to use different event loop "
"implementations, or substituted by a :ref:`custom policy <asyncio-custom-"
"policies>` that can override these behaviors."
msgstr ""
"Una política de bucle de eventos es un objeto global utilizado para obtener "
"y establecer el actual :ref:`event loop <asyncio-event-loop>`, así como para "
"crear nuevos bucles de eventos. La política por defecto puede ser :ref:"
"`replaced <asyncio-policy-get-set>` con :ref:`built-in alternatives <asyncio-"
"policy-builtin>` para usar diferentes implementaciones de bucles de eventos, "
"o sustituida por una :ref:`custom policy <asyncio-custom-policies>` que "
"puede anular estos comportamientos."

#: ../../library/asyncio-policy.rst:19
msgid ""
"The :ref:`policy object <asyncio-policy-objects>` gets and sets a separate "
"event loop per *context*. This is per-thread by default, though custom "
"policies could define *context* differently."
msgstr ""
"El objeto ref:`policy object <asyncio-policy-objects>` obtiene y establece "
"un bucle de eventos separado por *contexto*. Esto es por hilo por defecto, "
"aunque las políticas personalizadas pueden definir el *contexto* de forma "
"diferente."

#: ../../library/asyncio-policy.rst:24
msgid ""
"Custom event loop policies can control the behavior of :func:"
"`get_event_loop`, :func:`set_event_loop`, and :func:`new_event_loop`."
msgstr ""
"Las políticas de bucle de eventos personalizadas pueden controlar el "
"comportamiento de :func:`get_event_loop`, :func:`set_event_loop`, y :func:"
"`new_event_loop`."

#: ../../library/asyncio-policy.rst:27
msgid ""
"Policy objects should implement the APIs defined in the :class:"
"`AbstractEventLoopPolicy` abstract base class."
msgstr ""
"Los objetos de política deben implementar las API definidas en la clase base "
"abstracta :class:`AbstractEventLoopPolicy`."

#: ../../library/asyncio-policy.rst:34
msgid "Getting and Setting the Policy"
msgstr "Obtención y establecimiento de la política"

#: ../../library/asyncio-policy.rst:36
msgid ""
"The following functions can be used to get and set the policy for the "
"current process:"
msgstr ""
"Las siguientes funciones se pueden utilizar para obtener y establecer la "
"política para el proceso actual:"

#: ../../library/asyncio-policy.rst:41
msgid "Return the current process-wide policy."
msgstr "Devuelve la política actual para todo el proceso."

#: ../../library/asyncio-policy.rst:45
msgid "Set the current process-wide policy to *policy*."
msgstr "Establece la política actual del proceso en *política*."

#: ../../library/asyncio-policy.rst:47
msgid "If *policy* is set to ``None``, the default policy is restored."
msgstr ""
"Si *policy* se establece en ``None``, se restaura la política por defecto."

#: ../../library/asyncio-policy.rst:53
msgid "Policy Objects"
msgstr "Objetos políticos"

#: ../../library/asyncio-policy.rst:55
msgid "The abstract event loop policy base class is defined as follows:"
msgstr ""
"La clase base de la política abstracta de bucle de eventos se define como "
"sigue:"

#: ../../library/asyncio-policy.rst:59
msgid "An abstract base class for asyncio policies."
msgstr "Una clase base abstracta para políticas asyncio."

#: ../../library/asyncio-policy.rst:63
msgid "Get the event loop for the current context."
msgstr "Obtener el bucle de eventos para el contexto actual."

#: ../../library/asyncio-policy.rst:65
msgid ""
"Return an event loop object implementing the :class:`AbstractEventLoop` "
"interface."
msgstr ""
"Devuelve un objeto de bucle de eventos que implementa la interfaz :class:"
"`AbstractEventLoop`."

#: ../../library/asyncio-policy.rst:68 ../../library/asyncio-policy.rst:80
msgid "This method should never return ``None``."
msgstr "Este método nunca debe devolver ``None``."

#: ../../library/asyncio-policy.rst:74
msgid "Set the event loop for the current context to *loop*."
msgstr "Establece el bucle de eventos para el contexto actual en *loop*."

#: ../../library/asyncio-policy.rst:78
msgid "Create and return a new event loop object."
msgstr "Crea y devuelve un nuevo objeto de bucle de eventos."

#: ../../library/asyncio-policy.rst:84
msgid "Get a child process watcher object."
msgstr "Obtener un objeto observador de procesos hijo."

#: ../../library/asyncio-policy.rst:86
msgid ""
"Return a watcher object implementing the :class:`AbstractChildWatcher` "
"interface."
msgstr ""
"Devuelve un objeto observador que implementa la interfaz :class:"
"`AbstractChildWatcher`."

#: ../../library/asyncio-policy.rst:89 ../../library/asyncio-policy.rst:97
msgid "This function is Unix specific."
msgstr "Esta función es específica de Unix."

#: ../../library/asyncio-policy.rst:95
msgid "Set the current child process watcher to *watcher*."
msgstr "Establece el observador del proceso hijo actual a *watcher*."

#: ../../library/asyncio-policy.rst:104
msgid "asyncio ships with the following built-in policies:"
msgstr "asyncio incluye las siguientes políticas integradas:"

#: ../../library/asyncio-policy.rst:109
msgid ""
"The default asyncio policy.  Uses :class:`SelectorEventLoop` on Unix and :"
"class:`ProactorEventLoop` on Windows."
msgstr ""
"La política asyncio por defecto.  Utiliza :class:`SelectorEventLoop` en Unix "
"y :class:`ProactorEventLoop` en Windows."

#: ../../library/asyncio-policy.rst:112
msgid ""
"There is no need to install the default policy manually. asyncio is "
"configured to use the default policy automatically."
msgstr ""
"No es necesario instalar la política por defecto manualmente. asyncio está "
"configurado para utilizar la política por defecto automáticamente."

#: ../../library/asyncio-policy.rst:117
msgid "On Windows, :class:`ProactorEventLoop` is now used by default."
msgstr "En Windows, :class:`ProactorEventLoop` se utiliza ahora por defecto."

#: ../../library/asyncio-policy.rst:119
msgid ""
"The :meth:`get_event_loop` method of the default asyncio policy now emits a :"
"exc:`DeprecationWarning` if there is no current event loop set and it "
"decides to create one. In some future Python release this will become an "
"error."
msgstr ""
"El método :meth:`get_event_loop` de la política por defecto de asyncio ahora "
"emite un :exc:`DeprecationWarning` si no hay un bucle de eventos actual "
"establecido y decide crear uno. En alguna versión futura de Python esto se "
"convertirá en un error."

#: ../../library/asyncio-policy.rst:128
msgid ""
"An alternative event loop policy that uses the :class:`SelectorEventLoop` "
"event loop implementation."
msgstr ""
"Una política de bucle de eventos alternativa que utiliza la implementación "
"de bucle de eventos de :class:`SelectorEventLoop`."

#: ../../library/asyncio-policy.rst:131 ../../library/asyncio-policy.rst:139
msgid "Availability"
msgstr "Disponibilidad"

#: ../../library/asyncio-policy.rst:136
msgid ""
"An alternative event loop policy that uses the :class:`ProactorEventLoop` "
"event loop implementation."
msgstr ""
"Una política de bucle de eventos alternativa que utiliza la implementación "
"de bucle de eventos de :class:`ProactorEventLoop`."

#: ../../library/asyncio-policy.rst:145
msgid "Process Watchers"
msgstr "Observadores de procesos"

#: ../../library/asyncio-policy.rst:147
msgid ""
"A process watcher allows customization of how an event loop monitors child "
"processes on Unix. Specifically, the event loop needs to know when a child "
"process has exited."
msgstr ""
"Un observador de procesos permite personalizar la forma en que un bucle de "
"eventos monitoriza los procesos hijo en Unix. Específicamente, el bucle de "
"eventos necesita saber cuando un proceso hijo ha salido."

#: ../../library/asyncio-policy.rst:151
msgid ""
"In asyncio, child processes are created with :func:`create_subprocess_exec` "
"and :meth:`loop.subprocess_exec` functions."
msgstr ""
"En asyncio, los procesos hijo se crean con las funciones :func:"
"`create_subprocess_exec` y :meth:`loop.subprocess_exec`."

#: ../../library/asyncio-policy.rst:155
msgid ""
"asyncio defines the :class:`AbstractChildWatcher` abstract base class, which "
"child watchers should implement, and has four different implementations: :"
"class:`ThreadedChildWatcher` (configured to be used by default), :class:"
"`MultiLoopChildWatcher`, :class:`SafeChildWatcher`, and :class:"
"`FastChildWatcher`."
msgstr ""
"asyncio define la clase base abstracta :class:`AbstractChildWatcher`, que "
"deben implementar los vigilantes hijos, y tiene cuatro implementaciones "
"diferentes: :class:`ThreadedChildWatcher` (configurada para utilizarse por "
"defecto), :class:`MultiLoopChildWatcher`, :class:`SafeChildWatcher`, y :"
"class:`FastChildWatcher`."

#: ../../library/asyncio-policy.rst:161
msgid ""
"See also the :ref:`Subprocess and Threads <asyncio-subprocess-threads>` "
"section."
msgstr ""
"Ver también la sección :ref:`Subprocess and Threads  <asyncio-subprocess-"
"threads>`."

#: ../../library/asyncio-policy.rst:164
msgid ""
"The following two functions can be used to customize the child process "
"watcher implementation used by the asyncio event loop:"
msgstr ""
"Las siguientes dos funciones se pueden utilizar para personalizar la "
"implementación del observador de procesos hijo utilizado por el bucle de "
"eventos asyncio:"

#: ../../library/asyncio-policy.rst:169
msgid "Return the current child watcher for the current policy."
msgstr "Devuelve el observador hijo para la política actual."

#: ../../library/asyncio-policy.rst:175
msgid ""
"Set the current child watcher to *watcher* for the current policy.  "
"*watcher* must implement methods defined in the :class:"
"`AbstractChildWatcher` base class."
msgstr ""
"Establece el observador hijo actual en *watcher* para la política actual.  "
"*watcher* debe implementar los métodos definidos en la clase base :class:"
"`AbstractChildWatcher`."

#: ../../library/asyncio-policy.rst:182
msgid ""
"Third-party event loops implementations might not support custom child "
"watchers.  For such event loops, using :func:`set_child_watcher` might be "
"prohibited or have no effect."
msgstr ""
"Es posible que las implementaciones de bucles de eventos de terceros no "
"admitan observadores hijos personalizados.  Para estos bucles de eventos, el "
"uso de :func:`set_child_watcher` puede estar prohibido o no tener ningún "
"efecto."

#: ../../library/asyncio-policy.rst:190
msgid "Register a new child handler."
msgstr "Registrar un nuevo controlador hijo."

#: ../../library/asyncio-policy.rst:192
msgid ""
"Arrange for ``callback(pid, returncode, *args)`` to be called when a process "
"with PID equal to *pid* terminates.  Specifying another callback for the "
"same process replaces the previous handler."
msgstr ""
"Dispone que se llame ``callback(pid, returncode, *args)`` cuando un proceso "
"con PID igual a *pid* termine.  Especificar otra llamada de retorno para el "
"mismo proceso reemplaza al controlador anterior."

#: ../../library/asyncio-policy.rst:197
msgid "The *callback* callable must be thread-safe."
msgstr "El callable *callback* debe ser thread-safe."

#: ../../library/asyncio-policy.rst:201
msgid "Removes the handler for process with PID equal to *pid*."
msgstr "Elimina el manejador para el proceso con PID igual a *pid*."

#: ../../library/asyncio-policy.rst:203
msgid ""
"The function returns ``True`` if the handler was successfully removed, "
"``False`` if there was nothing to remove."
msgstr ""
"La función devuelve ``True`` si el manejador se eliminó con éxito, ``False`` "
"si no había nada que eliminar."

#: ../../library/asyncio-policy.rst:208
msgid "Attach the watcher to an event loop."
msgstr "Adjunta el observador a un bucle de eventos."

#: ../../library/asyncio-policy.rst:210
msgid ""
"If the watcher was previously attached to an event loop, then it is first "
"detached before attaching to the new loop."
msgstr ""
"Si el observador estaba previamente conectado a un bucle de eventos, primero "
"se desconecta antes de conectarse al nuevo bucle."

#: ../../library/asyncio-policy.rst:213
msgid "Note: loop may be ``None``."
msgstr "Nota: el bucle puede ser ``None``."

#: ../../library/asyncio-policy.rst:217
msgid "Return ``True`` if the watcher is ready to use."
msgstr "Devuelve ``True`` si el observador está listo para su uso."

#: ../../library/asyncio-policy.rst:219
msgid ""
"Spawning a subprocess with *inactive* current child watcher raises :exc:"
"`RuntimeError`."
msgstr ""
"La creación de un subproceso con un vigilante hijo actual *inactivo* "
"plantea :exc:`RuntimeError`."

#: ../../library/asyncio-policy.rst:226
msgid "Close the watcher."
msgstr "Cierra el observador."

#: ../../library/asyncio-policy.rst:228
msgid ""
"This method has to be called to ensure that underlying resources are cleaned-"
"up."
msgstr ""
"Este método debe llamarse para garantizar que se limpian los recursos "
"subyacentes."

#: ../../library/asyncio-policy.rst:236
msgid ""
"This implementation starts a new waiting thread for every subprocess spawn."
msgstr ""
"Esta implementación inicia un nuevo hilo de espera por cada subproceso "
"generado."

#: ../../library/asyncio-policy.rst:238
msgid ""
"It works reliably even when the asyncio event loop is run in a non-main OS "
"thread."
msgstr ""
"Funciona de forma fiable incluso cuando el bucle de eventos asyncio se "
"ejecuta en un hilo no principal del sistema operativo."

#: ../../library/asyncio-policy.rst:240
msgid ""
"There is no noticeable overhead when handling a big number of children "
"(*O*\\ (1) each time a child terminates), but starting a thread per process "
"requires extra memory."
msgstr ""
"No hay sobrecarga notable cuando se maneja un gran número de hijos (*O* (1) "
"cada vez que un hijo termina), pero iniciar un hilo por proceso requiere "
"memoria extra."

#: ../../library/asyncio-policy.rst:243
msgid "This watcher is used by default."
msgstr "Este observador se utiliza por defecto."

#: ../../library/asyncio-policy.rst:249
msgid ""
"This implementation registers a :py:data:`SIGCHLD` signal handler on "
"instantiation. That can break third-party code that installs a custom "
"handler for :py:data:`SIGCHLD` signal."
msgstr ""
"Esta implementación registra un manejador de señal :py:data:`SIGCHLD` en la "
"instanciación. Eso puede romper el código de terceros que instala un "
"controlador personalizado para la señal :py:data:`SIGCHLD`."

#: ../../library/asyncio-policy.rst:253 ../../library/asyncio-policy.rst:273
msgid ""
"The watcher avoids disrupting other code spawning processes by polling every "
"process explicitly on a :py:data:`SIGCHLD` signal."
msgstr ""
"El observador evita interrumpir otros procesos de generación de código "
"sondeando cada proceso explícitamente en una señal :py:data:`SIGCHLD`."

#: ../../library/asyncio-policy.rst:256
msgid ""
"There is no limitation for running subprocesses from different threads once "
"the watcher is installed."
msgstr ""
"No existe ninguna limitación para ejecutar subprocesos desde diferentes "
"hilos una vez instalado el observador."

#: ../../library/asyncio-policy.rst:259
msgid ""
"The solution is safe but it has a significant overhead when handling a big "
"number of processes (*O*\\ (*n*) each time a :py:data:`SIGCHLD` is received)."
msgstr ""
"La solución es segura, pero tiene una sobrecarga significativa cuando se "
"maneja un gran número de procesos (*O*\\ (*n*) cada vez que se recibe un :py:"
"data:`SIGCHLD` )."

#: ../../library/asyncio-policy.rst:269
msgid ""
"This implementation uses active event loop from the main thread to handle :"
"py:data:`SIGCHLD` signal. If the main thread has no running event loop "
"another thread cannot spawn a subprocess (:exc:`RuntimeError` is raised)."
msgstr ""
"Esta implementación utiliza un bucle de eventos activo del subproceso "
"principal para gestionar la señal :py:data:`SIGCHLD`. Si el subproceso "
"principal no tiene un bucle de eventos en ejecución, otro subproceso no "
"puede generar un subproceso (se activa:exc:`RuntimeError` )."

#: ../../library/asyncio-policy.rst:276
msgid ""
"This solution is as safe as :class:`MultiLoopChildWatcher` and has the same "
"*O*\\ (*n*) complexity but requires a running event loop in the main thread "
"to work."
msgstr ""
"Esta solución es tan segura como :class:`MultiLoopChildWatcher` y tiene la "
"misma complejidad *O* (*n*) pero requiere un bucle de eventos en ejecución "
"en el hilo principal para funcionar."

#: ../../library/asyncio-policy.rst:283
msgid ""
"This implementation reaps every terminated processes by calling ``os."
"waitpid(-1)`` directly, possibly breaking other code spawning processes and "
"waiting for their termination."
msgstr ""
"Esta implementación recoge todos los procesos terminados llamando "
"directamente a ``os.waitpid(-1)``, posiblemente rompiendo otro código que "
"genera procesos y espera su terminación."

#: ../../library/asyncio-policy.rst:287
msgid ""
"There is no noticeable overhead when handling a big number of children "
"(*O*\\ (1) each time a child terminates)."
msgstr ""
"No hay sobrecarga perceptible cuando se maneja un gran número de hijos "
"(*O*\\ (1) cada vez que un hijo termina)."

#: ../../library/asyncio-policy.rst:290
msgid ""
"This solution requires a running event loop in the main thread to work, as :"
"class:`SafeChildWatcher`."
msgstr ""
"Esta solución requiere un bucle de eventos en ejecución en el hilo principal "
"para funcionar, como :class:`SafeChildWatcher`."

#: ../../library/asyncio-policy.rst:297
msgid ""
"This implementation polls process file descriptors (pidfds) to await child "
"process termination. In some respects, :class:`PidfdChildWatcher` is a "
"\"Goldilocks\" child watcher implementation. It doesn't require signals or "
"threads, doesn't interfere with any processes launched outside the event "
"loop, and scales linearly with the number of subprocesses launched by the "
"event loop. The main disadvantage is that pidfds are specific to Linux, and "
"only work on recent (5.3+) kernels."
msgstr ""
"Esta implementación sondea los descriptores de archivos de proceso (pidfds) "
"para esperar la terminación del proceso hijo. En algunos aspectos, :class:"
"`PidfdChildWatcher` es una implementación \"Ricitos de Oro\" de vigilante de "
"procesos hijo. No requiere señales o hilos, no interfiere con ningún proceso "
"lanzado fuera del bucle de eventos, y escala linealmente con el número de "
"subprocesos lanzados por el bucle de eventos. La principal desventaja es que "
"pidfds es específico de Linux, y sólo funciona en kernels recientes (5.3+)."

#: ../../library/asyncio-policy.rst:311
msgid "Custom Policies"
msgstr "Políticas personalizadas"

#: ../../library/asyncio-policy.rst:313
msgid ""
"To implement a new event loop policy, it is recommended to subclass :class:"
"`DefaultEventLoopPolicy` and override the methods for which custom behavior "
"is wanted, e.g.::"
msgstr ""
"Para implementar una nueva política de bucle de eventos, se recomienda "
"subclase :class:`DefaultEventLoopPolicy` y anular los métodos para los que "
"se desea un comportamiento personalizado, por ejemplo::"

#: ../../library/asyncio-policy.rst:317
msgid ""
"class MyEventLoopPolicy(asyncio.DefaultEventLoopPolicy):\n"
"\n"
"    def get_event_loop(self):\n"
"        \"\"\"Get the event loop.\n"
"\n"
"        This may be None or an instance of EventLoop.\n"
"        \"\"\"\n"
"        loop = super().get_event_loop()\n"
"        # Do something with loop ...\n"
"        return loop\n"
"\n"
"asyncio.set_event_loop_policy(MyEventLoopPolicy())"
msgstr ""
"class MyEventLoopPolicy(asyncio.DefaultEventLoopPolicy):\n"
"\n"
"    def get_event_loop(self):\n"
"        \"\"\"Obtener el bucle de eventos..\n"
"\n"
"        Puede ser None o una instancia de EventLoop.\n"
"        \"\"\"\n"
"        loop = super().get_event_loop()\n"
"        # Haz algo con loop ...\n"
"        return loop\n"
"\n"
"asyncio.set_event_loop_policy(MyEventLoopPolicy())"
