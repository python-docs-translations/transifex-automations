# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# eulalio barbero espinosa <eulalio@disroot.org>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-25 14:54+0000\n"
"PO-Revision-Date: 2024-05-11 00:33+0000\n"
"Last-Translator: eulalio barbero espinosa <eulalio@disroot.org>, 2025\n"
"Language-Team: Spanish (Spain) (https://app.transifex.com/python-doc/"
"teams/5390/es_ES/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es_ES\n"
"Plural-Forms: nplurals=3; plural=n == 1 ? 0 : n != 0 && n % 1000000 == 0 ? "
"1 : 2;\n"

#: ../../library/asyncio-future.rst:8
msgid "Futures"
msgstr "Futuros"

#: ../../library/asyncio-future.rst:10
msgid ""
"**Source code:** :source:`Lib/asyncio/futures.py`, :source:`Lib/asyncio/"
"base_futures.py`"
msgstr ""
"**Código fuente:** :source:`Lib/asyncio/futures.py`, :source:`Lib/asyncio/"
"base_futures.py`"

#: ../../library/asyncio-future.rst:15
msgid ""
"*Future* objects are used to bridge **low-level callback-based code** with "
"high-level async/await code."
msgstr ""
"Los objetos *Future* se utilizan para unir **código de bajo nivel basado en "
"callback** con código de alto nivel async/await."

#: ../../library/asyncio-future.rst:20
msgid "Future Functions"
msgstr "Funciones futuras"

#: ../../library/asyncio-future.rst:24
msgid "Return ``True`` if *obj* is either of:"
msgstr "Devuelve ``True`` si *obj* es cualquiera de los dos:"

#: ../../library/asyncio-future.rst:26
msgid "an instance of :class:`asyncio.Future`,"
msgstr "una instancia de :class:`asyncio.Future`,"

#: ../../library/asyncio-future.rst:27
msgid "an instance of :class:`asyncio.Task`,"
msgstr "una instancia de :class:`asyncio.Task`,"

#: ../../library/asyncio-future.rst:28
msgid "a Future-like object with a ``_asyncio_future_blocking`` attribute."
msgstr "un objeto de tipo Futuro con un atributo ``_asyncio_future_blocking``."

#: ../../library/asyncio-future.rst:36
msgid "Return:"
msgstr "Vuelve:"

#: ../../library/asyncio-future.rst:38
msgid ""
"*obj* argument as is, if *obj* is a :class:`Future`, a :class:`Task`, or a "
"Future-like object (:func:`isfuture` is used for the test.)"
msgstr ""
"*obj* argumento tal cual, si *obj* es un :class:`Future`, un :class:`Task`, "
"o un objeto tipo Future (:func:`isfuture` se utiliza para la prueba.)"

#: ../../library/asyncio-future.rst:42
msgid ""
"a :class:`Task` object wrapping *obj*, if *obj* is a coroutine (:func:"
"`iscoroutine` is used for the test); in this case the coroutine will be "
"scheduled by ``ensure_future()``."
msgstr ""
"un objeto :class:`Task` que envuelve *obj*, si *obj* es una corrutina (:func:"
"`iscoroutine` se utiliza para la prueba); en este caso la corrutina la "
"programará ``ensure_future()``."

#: ../../library/asyncio-future.rst:47
msgid ""
"a :class:`Task` object that would await on *obj*, if *obj* is an awaitable (:"
"func:`inspect.isawaitable` is used for the test.)"
msgstr ""
"un objeto :class:`Task` que esperaría en *obj*, si *obj* es un awaitable (:"
"func:`inspect.isawaitable` se utiliza para la prueba.)"

#: ../../library/asyncio-future.rst:50
msgid "If *obj* is neither of the above a :exc:`TypeError` is raised."
msgstr "Si *obj* no es ninguno de los anteriores, aparece :exc:`TypeError`."

#: ../../library/asyncio-future.rst:54
msgid ""
"See also the :func:`create_task` function which is the preferred way for "
"creating new Tasks."
msgstr ""
"Ver también la función :func:`create_task`, que es la preferida para crear "
"nuevas Tareas."

#: ../../library/asyncio-future.rst:57
msgid ""
"Save a reference to the result of this function, to avoid a task "
"disappearing mid-execution."
msgstr ""
"Guarda una referencia al resultado de esta función, para evitar que una "
"tarea desaparezca a mitad de ejecución."

#: ../../library/asyncio-future.rst:60
msgid "The function accepts any :term:`awaitable` object."
msgstr "La función acepta cualquier objeto :term:`awaitable`."

#: ../../library/asyncio-future.rst:63
msgid ""
"Deprecation warning is emitted if *obj* is not a Future-like object and "
"*loop* is not specified and there is no running event loop."
msgstr ""
"Se emite una advertencia de desaprobación si *obj* no es un objeto tipo "
"Future y *loop* no se especifica y no hay ningún bucle de eventos en "
"ejecución."

#: ../../library/asyncio-future.rst:70
msgid ""
"Wrap a :class:`concurrent.futures.Future` object in a :class:`asyncio."
"Future` object."
msgstr ""
"Envuelve un objeto :class:`concurrent.futures.Future` en un objeto :class:"
"`asyncio.Future`."

#: ../../library/asyncio-future.rst:73
msgid ""
"Deprecation warning is emitted if *future* is not a Future-like object and "
"*loop* is not specified and there is no running event loop."
msgstr ""
"Se emite una advertencia de desaprobación si *future* no es un objeto de "
"tipo Future y *loop* no se especifica y no hay ningún bucle de eventos en "
"ejecución."

#: ../../library/asyncio-future.rst:79
msgid "Future Object"
msgstr "Objeto futuro"

#: ../../library/asyncio-future.rst:83
msgid ""
"A Future represents an eventual result of an asynchronous operation.  Not "
"thread-safe."
msgstr ""
"Un futuro representa el resultado final de una operación asíncrona.  No es "
"seguro para subprocesos."

#: ../../library/asyncio-future.rst:86
msgid ""
"Future is an :term:`awaitable` object.  Coroutines can await on Future "
"objects until they either have a result or an exception set, or until they "
"are cancelled. A Future can be awaited multiple times and the result is same."
msgstr ""
"Future es un objeto :term:`awaitable`.  Las Coroutines pueden esperar en "
"objetos Future hasta que tengan un resultado o una excepción, o hasta que se "
"cancelen. Un futuro puede ser esperado varias veces y el resultado es el "
"mismo."

#: ../../library/asyncio-future.rst:91
msgid ""
"Typically Futures are used to enable low-level callback-based code (e.g. in "
"protocols implemented using asyncio :ref:`transports <asyncio-transports-"
"protocols>`) to interoperate with high-level async/await code."
msgstr ""
"Normalmente, los Futuros se utilizan para permitir que el código de bajo "
"nivel basado en callbacks (por ejemplo, en protocolos implementados "
"utilizando asyncio :ref:`transports <asyncio-transports-protocols>`) "
"interopere con código async/await de alto nivel."

#: ../../library/asyncio-future.rst:96
msgid ""
"The rule of thumb is to never expose Future objects in user-facing APIs, and "
"the recommended way to create a Future object is to call :meth:`loop."
"create_future`.  This way alternative event loop implementations can inject "
"their own optimized implementations of a Future object."
msgstr ""
"La regla general es no exponer nunca objetos Futuro en APIs orientadas al "
"usuario, y la forma recomendada de crear un objeto Futuro es llamar a :meth:"
"`loop.create_future`.  De esta forma, las implementaciones alternativas de "
"bucles de eventos pueden inyectar sus propias implementaciones optimizadas "
"de un objeto Future."

#: ../../library/asyncio-future.rst:102
msgid "Added support for the :mod:`contextvars` module."
msgstr "Se ha añadido compatibilidad con el módulo :mod:`contextvars`."

#: ../../library/asyncio-future.rst:105
msgid ""
"Deprecation warning is emitted if *loop* is not specified and there is no "
"running event loop."
msgstr ""
"Se emite una advertencia de desaprobación si no se especifica *loop* y no "
"hay ningún bucle de eventos en ejecución."

#: ../../library/asyncio-future.rst:111
msgid "Return the result of the Future."
msgstr "Devuelve el resultado de Future."

#: ../../library/asyncio-future.rst:113
msgid ""
"If the Future is *done* and has a result set by the :meth:`set_result` "
"method, the result value is returned."
msgstr ""
"Si Future está *done* y tiene un resultado establecido por el método :meth:"
"`set_result`, se devuelve el valor del resultado."

#: ../../library/asyncio-future.rst:116
msgid ""
"If the Future is *done* and has an exception set by the :meth:"
"`set_exception` method, this method raises the exception."
msgstr ""
"Si Future está *done* y tiene una excepción establecida por el método :meth:"
"`set_exception`, este método lanza la excepción."

#: ../../library/asyncio-future.rst:119 ../../library/asyncio-future.rst:207
msgid ""
"If the Future has been *cancelled*, this method raises a :exc:"
"`CancelledError` exception."
msgstr ""
"Si Future se ha *cancelled*, este método lanza una excepción :exc:"
"`CancelledError`."

#: ../../library/asyncio-future.rst:122
msgid ""
"If the Future's result isn't yet available, this method raises an :exc:"
"`InvalidStateError` exception."
msgstr ""
"Si el resultado de Future aún no está disponible, este método lanza una "
"excepción :exc:`InvalidStateError`."

#: ../../library/asyncio-future.rst:127
msgid "Mark the Future as *done* and set its result."
msgstr "Marca Future como *done* y establece su resultado."

#: ../../library/asyncio-future.rst:129 ../../library/asyncio-future.rst:136
msgid ""
"Raises an :exc:`InvalidStateError` error if the Future is already *done*."
msgstr "Genera un error :exc:`InvalidStateError` si Future ya está *done*."

#: ../../library/asyncio-future.rst:134
msgid "Mark the Future as *done* and set an exception."
msgstr "Marca Future como *done* y establece una excepción."

#: ../../library/asyncio-future.rst:141
msgid "Return ``True`` if the Future is *done*."
msgstr "Devuelve ``True`` si Future está *done*."

#: ../../library/asyncio-future.rst:143
msgid ""
"A Future is *done* if it was *cancelled* or if it has a result or an "
"exception set with :meth:`set_result` or :meth:`set_exception` calls."
msgstr ""
"Un Future está *done* si se *cancelled* o si tiene un resultado o una "
"excepción establecida con las llamadas :meth:`set_result` o :meth:"
"`set_exception`."

#: ../../library/asyncio-future.rst:149
msgid "Return ``True`` if the Future was *cancelled*."
msgstr "Devuelve ``True`` si Future fue *cancelled*."

#: ../../library/asyncio-future.rst:151
msgid ""
"The method is usually used to check if a Future is not *cancelled* before "
"setting a result or an exception for it::"
msgstr ""
"El método se utiliza normalmente para comprobar si un Future no está "
"*cancelled* antes de establecer un resultado o una excepción para él::"

#: ../../library/asyncio-future.rst:154
msgid ""
"if not fut.cancelled():\n"
"    fut.set_result(42)"
msgstr ""
"if not fut.cancelled():\n"
"    fut.set_result(42)"

#: ../../library/asyncio-future.rst:159
msgid "Add a callback to be run when the Future is *done*."
msgstr "Añade un callback que se ejecutará cuando Future esté *done*."

#: ../../library/asyncio-future.rst:161
msgid "The *callback* is called with the Future object as its only argument."
msgstr "Se llama *callback* con el objeto Future como único argumento."

#: ../../library/asyncio-future.rst:164
msgid ""
"If the Future is already *done* when this method is called, the callback is "
"scheduled with :meth:`loop.call_soon`."
msgstr ""
"Si Future ya está *done* cuando se llama a este método, la devolución de "
"llamada se programa con :meth:`loop.call_soon`."

#: ../../library/asyncio-future.rst:167
msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the *callback* to run in. The current "
"context is used when no *context* is provided."
msgstr ""
"Un argumento opcional *context* permite especificar un :class:`contextvars."
"Context` personalizado para que se ejecute la *callback*. El contexto actual "
"se utiliza cuando no se proporciona *context*."

#: ../../library/asyncio-future.rst:171
msgid ""
":func:`functools.partial` can be used to pass parameters to the callback, e."
"g.::"
msgstr ""
":func:`functools.partial` puede utilizarse para pasar parámetros a la "
"llamada de retorno, por ejemplo::"

#: ../../library/asyncio-future.rst:174
msgid ""
"# Call 'print(\"Future:\", fut)' when \"fut\" is done.\n"
"fut.add_done_callback(\n"
"    functools.partial(print, \"Future:\"))"
msgstr ""
"# Llama a 'print(\"Future:\", fut)' cuando \"fut\" haya terminado.\n"
"fut.add_done_callback(\n"
"    functools.partial(print, \"Futuro:\"))"

#: ../../library/asyncio-future.rst:178
msgid ""
"The *context* keyword-only parameter was added. See :pep:`567` for more "
"details."
msgstr ""
"Se ha añadido el parámetro *context* de sólo palabra clave. Consultar :pep:"
"`567` para obtener más detalles."

#: ../../library/asyncio-future.rst:184
msgid "Remove *callback* from the callbacks list."
msgstr "Elimina *callback* de la lista de callbacks."

#: ../../library/asyncio-future.rst:186
msgid ""
"Returns the number of callbacks removed, which is typically 1, unless a "
"callback was added more than once."
msgstr ""
"Devuelve el número de retrollamadas eliminadas, que suele ser 1, a menos que "
"se haya añadido una retrollamada más de una vez."

#: ../../library/asyncio-future.rst:191
msgid "Cancel the Future and schedule callbacks."
msgstr "Cancelar Future y programar las devoluciones de llamada."

#: ../../library/asyncio-future.rst:193
msgid ""
"If the Future is already *done* or *cancelled*, return ``False``. Otherwise, "
"change the Future's state to *cancelled*, schedule the callbacks, and return "
"``True``."
msgstr ""
"Si Future ya está *done* o *cancelled*, devuelve ``False``. En caso "
"contrario, cambia el estado de Future a *cancelled*, programa las llamadas "
"de retorno y devuelve ``True``."

#: ../../library/asyncio-future.rst:197
msgid "Added the *msg* parameter."
msgstr "Se ha añadido el parámetro *msg*."

#: ../../library/asyncio-future.rst:202
msgid "Return the exception that was set on this Future."
msgstr "Devuelve la excepción que se estableció en este Future."

#: ../../library/asyncio-future.rst:204
msgid ""
"The exception (or ``None`` if no exception was set) is returned only if the "
"Future is *done*."
msgstr ""
"La excepción (o ``None`` si no se ha establecido ninguna excepción) sólo se "
"devuelve si Future está *done*."

#: ../../library/asyncio-future.rst:210
msgid ""
"If the Future isn't *done* yet, this method raises an :exc:"
"`InvalidStateError` exception."
msgstr ""
"Si Future aún no está *done*, este método lanza una excepción :exc:"
"`InvalidStateError`."

#: ../../library/asyncio-future.rst:215
msgid "Return the event loop the Future object is bound to."
msgstr "Devuelve el bucle de eventos al que está vinculado el objeto Future."

#: ../../library/asyncio-future.rst:222
msgid ""
"This example creates a Future object, creates and schedules an asynchronous "
"Task to set result for the Future, and waits until the Future has a result::"
msgstr ""
"Este ejemplo crea un objeto Future, crea y programa una Tarea asíncrona para "
"establecer el resultado para Future, y espera hasta que Future tenga un "
"resultado::"

#: ../../library/asyncio-future.rst:226
msgid ""
"async def set_after(fut, delay, value):\n"
"    # Sleep for *delay* seconds.\n"
"    await asyncio.sleep(delay)\n"
"\n"
"    # Set *value* as a result of *fut* Future.\n"
"    fut.set_result(value)\n"
"\n"
"async def main():\n"
"    # Get the current event loop.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    # Create a new Future object.\n"
"    fut = loop.create_future()\n"
"\n"
"    # Run \"set_after()\" coroutine in a parallel Task.\n"
"    # We are using the low-level \"loop.create_task()\" API here because\n"
"    # we already have a reference to the event loop at hand.\n"
"    # Otherwise we could have just used \"asyncio.create_task()\".\n"
"    loop.create_task(\n"
"        set_after(fut, 1, '... world'))\n"
"\n"
"    print('hello ...')\n"
"\n"
"    # Wait until *fut* has a result (1 second) and print it.\n"
"    print(await fut)\n"
"\n"
"asyncio.run(main())"
msgstr ""
"async def set_after(fut, delay, value):\n"
"    # Duerme durante *delay* segundos.\n"
"    await asyncio.sleep(delay)\n"
"\n"
"    # Establece *value* como resultado de *fut* Future.\n"
"    fut.set_result(valor)\n"
"\n"
"async def main():\n"
"    # Obtener el bucle de eventos actual.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    # Crea un nuevo objeto Futuro.\n"
"    fut = loop.create_future()\n"
"\n"
"    # Ejecutar la corrutina \"set_after()\" en una Tarea paralela.\n"
"    # Estamos usando el API de bajo nivel \"loop.create_task()\" aquí "
"porque\n"
"    # ya tenemos a mano una referencia al bucle de eventos.\n"
"    # De lo contrario podríamos haber usado simplemente \"asyncio."
"create_task()\".\n"
"    loop.create_task(\n"
"        set_after(fut, 1, '... mundo'))\n"
"\n"
"    print('hola ...')\n"
"\n"
"    # Esperar hasta que *fut* tenga un resultado (1 segundo) e imprimirlo.\n"
"    print(await fut)\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-future.rst:257
msgid ""
"The Future object was designed to mimic :class:`concurrent.futures.Future`.  "
"Key differences include:"
msgstr ""
"El objeto Future se diseñó para imitar :class:`concurrent.futures.Future`.  "
"Las principales diferencias son:"

#: ../../library/asyncio-future.rst:260
msgid ""
"unlike asyncio Futures, :class:`concurrent.futures.Future` instances cannot "
"be awaited."
msgstr ""
"A diferencia de Futures asyncio, las instancias :class:`concurrent.futures."
"Future` no se pueden esperar."

#: ../../library/asyncio-future.rst:263
msgid ""
":meth:`asyncio.Future.result` and :meth:`asyncio.Future.exception` do not "
"accept the *timeout* argument."
msgstr ""
":meth:`asyncio.Future.result` y :meth:`asyncio.Future.exception` no aceptan "
"el argumento *timeout*."

#: ../../library/asyncio-future.rst:266
msgid ""
":meth:`asyncio.Future.result` and :meth:`asyncio.Future.exception` raise an :"
"exc:`InvalidStateError` exception when the Future is not *done*."
msgstr ""
":meth:`asyncio.Future.result` y :meth:`asyncio.Future.exception` lanzan una "
"excepción :exc:`InvalidStateError` cuando Future no está *done*."

#: ../../library/asyncio-future.rst:270
msgid ""
"Callbacks registered with :meth:`asyncio.Future.add_done_callback` are not "
"called immediately.  They are scheduled with :meth:`loop.call_soon` instead."
msgstr ""
"Las devoluciones de llamada registradas con :meth:`asyncio.Future."
"add_done_callback` no se llaman inmediatamente.  En su lugar, se programan "
"con :meth:`loop.call_soon`."

#: ../../library/asyncio-future.rst:274
msgid ""
"asyncio Future is not compatible with the :func:`concurrent.futures.wait` "
"and :func:`concurrent.futures.as_completed` functions."
msgstr ""
"asyncio Future no es compatible con las funciones :func:`concurrent.futures."
"wait` y :func:`concurrent.futures.as_completed`."

#: ../../library/asyncio-future.rst:278
msgid ""
":meth:`asyncio.Future.cancel` accepts an optional ``msg`` argument, but :"
"meth:`concurrent.futures.Future.cancel` does not."
msgstr ""
":meth:`asyncio.Future.cancel` acepta un argumento opcional ``msg``, pero :"
"meth:`concurrent.futures.Future.cancel` no."
