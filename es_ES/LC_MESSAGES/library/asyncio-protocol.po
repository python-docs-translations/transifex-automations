# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-25 15:05+0000\n"
"PO-Revision-Date: 2025-09-15 01:03+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Spanish (Spain) (https://app.transifex.com/python-doc/"
"teams/5390/es_ES/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es_ES\n"
"Plural-Forms: nplurals=3; plural=n == 1 ? 0 : n != 0 && n % 1000000 == 0 ? "
"1 : 2;\n"

#: ../../library/asyncio-protocol.rst:9
msgid "Transports and Protocols"
msgstr "Transportes y protocolos"

#: ../../library/asyncio-protocol.rst:12
msgid "Preface"
msgstr "Prefacio"

#: ../../library/asyncio-protocol.rst:13
msgid ""
"Transports and Protocols are used by the **low-level** event loop APIs such "
"as :meth:`loop.create_connection`.  They use callback-based programming "
"style and enable high-performance implementations of network or IPC "
"protocols (e.g. HTTP)."
msgstr ""
"Los transportes y protocolos son utilizados por las API de bucle de eventos "
"de **bajo nivel** como :meth:`loop.create_connection`.  Utilizan un estilo "
"de programación basado en llamadas de retorno y permiten implementaciones de "
"alto rendimiento de protocolos de red o IPC (por ejemplo, HTTP)."

#: ../../library/asyncio-protocol.rst:18
msgid ""
"Essentially, transports and protocols should only be used in libraries and "
"frameworks and never in high-level asyncio applications."
msgstr ""
"Esencialmente, los transportes y protocolos sólo deberían utilizarse en "
"bibliotecas y frameworks y nunca en aplicaciones asyncio de alto nivel."

#: ../../library/asyncio-protocol.rst:22
msgid "This documentation page covers both `Transports`_ and `Protocols`_."
msgstr ""
"Esta página de documentación abarca tanto `Transports`_ como `Protocols`_."

#: ../../library/asyncio-protocol.rst:25
msgid "Introduction"
msgstr "Introducción"

#: ../../library/asyncio-protocol.rst:26
msgid ""
"At the highest level, the transport is concerned with *how* bytes are "
"transmitted, while the protocol determines *which* bytes to transmit (and to "
"some extent when)."
msgstr ""
"Al más alto nivel, el transporte se ocupa de *how* se transmiten los bytes, "
"mientras que el protocolo determina *which* bytes transmitir (y hasta cierto "
"punto cuándo)."

#: ../../library/asyncio-protocol.rst:30
msgid ""
"A different way of saying the same thing: a transport is an abstraction for "
"a socket (or similar I/O endpoint) while a protocol is an abstraction for an "
"application, from the transport's point of view."
msgstr ""
"Una forma diferente de decir lo mismo: un transporte es una abstracción para "
"un socket (o punto final de E/S similar) mientras que un protocolo es una "
"abstracción para una aplicación, desde el punto de vista del transporte."

#: ../../library/asyncio-protocol.rst:35
msgid ""
"Yet another view is the transport and protocol interfaces together define an "
"abstract interface for using network I/O and interprocess I/O."
msgstr ""
"Otro punto de vista es que las interfaces de transporte y protocolo definen "
"conjuntamente una interfaz abstracta para utilizar la E/S de red y la E/S "
"entre procesos."

#: ../../library/asyncio-protocol.rst:39
msgid ""
"There is always a 1:1 relationship between transport and protocol objects: "
"the protocol calls transport methods to send data, while the transport calls "
"protocol methods to pass it data that has been received."
msgstr ""
"Siempre existe una relación 1:1 entre los objetos de transporte y protocolo: "
"el protocolo llama a los métodos de transporte para enviar datos, mientras "
"que el transporte llama a los métodos de protocolo para pasarle los datos "
"que ha recibido."

#: ../../library/asyncio-protocol.rst:44
msgid ""
"Most of connection oriented event loop methods (such as :meth:`loop."
"create_connection`) usually accept a *protocol_factory* argument used to "
"create a *Protocol* object for an accepted connection, represented by a "
"*Transport* object. Such methods usually return a tuple of ``(transport, "
"protocol)``."
msgstr ""
"La mayoría de los métodos de bucle de eventos orientados a conexión (como :"
"meth:`loop.create_connection`) suelen aceptar un argumento "
"*protocol_factory* utilizado para crear un objeto *Protocol* para una "
"conexión aceptada, representada por un objeto *Transport*. Tales métodos "
"normalmente devuelven una tupla de ``(transport, protocol)``."

#: ../../library/asyncio-protocol.rst:51
msgid "Contents"
msgstr "Contenido"

#: ../../library/asyncio-protocol.rst:52
msgid "This documentation page contains the following sections:"
msgstr "Esta página de documentación contiene las siguientes secciones:"

#: ../../library/asyncio-protocol.rst:54
msgid ""
"The `Transports`_ section documents asyncio :class:`BaseTransport`, :class:"
"`ReadTransport`, :class:`WriteTransport`, :class:`Transport`, :class:"
"`DatagramTransport`, and :class:`SubprocessTransport` classes."
msgstr ""
"La sección `Transports`_ documenta las clases asyncio :class:"
"`BaseTransport`, :class:`ReadTransport`, :class:`WriteTransport`, :class:"
"`Transport`, :class:`DatagramTransport`, y :class:`SubprocessTransport`."

#: ../../library/asyncio-protocol.rst:59
msgid ""
"The `Protocols`_ section documents asyncio :class:`BaseProtocol`, :class:"
"`Protocol`, :class:`BufferedProtocol`, :class:`DatagramProtocol`, and :class:"
"`SubprocessProtocol` classes."
msgstr ""
"La sección `Protocols`_ documenta las clases asyncio :class:`BaseProtocol`, :"
"class:`Protocol`, :class:`BufferedProtocol`, :class:`DatagramProtocol`, y :"
"class:`SubprocessProtocol`."

#: ../../library/asyncio-protocol.rst:63
msgid ""
"The `Examples`_ section showcases how to work with transports, protocols, "
"and low-level event loop APIs."
msgstr ""
"La sección `Examples`_ muestra cómo trabajar con transportes, protocolos y "
"APIs de bucle de eventos de bajo nivel."

#: ../../library/asyncio-protocol.rst:70
msgid "Transports"
msgstr "Transportes"

#: ../../library/asyncio-protocol.rst:72
msgid "**Source code:** :source:`Lib/asyncio/transports.py`"
msgstr "**Source code:** :source:`Lib/asyncio/transports.py`"

#: ../../library/asyncio-protocol.rst:76
msgid ""
"Transports are classes provided by :mod:`asyncio` in order to abstract "
"various kinds of communication channels."
msgstr ""
"Los transportes son clases proporcionadas por :mod:`asyncio` para abstraer "
"varios tipos de canales de comunicación."

#: ../../library/asyncio-protocol.rst:79
msgid ""
"Transport objects are always instantiated by an :ref:`asyncio event loop "
"<asyncio-event-loop>`."
msgstr ""
"Los objetos de transporte siempre se ejemplifican mediante :ref:`asyncio "
"event loop <asyncio-event-loop>`."

#: ../../library/asyncio-protocol.rst:82
msgid ""
"asyncio implements transports for TCP, UDP, SSL, and subprocess pipes. The "
"methods available on a transport depend on the transport's kind."
msgstr ""
"asyncio implementa transportes para TCP, UDP, SSL y tuberías de subprocesos. "
"Los métodos disponibles en un transporte dependen del tipo de transporte."

#: ../../library/asyncio-protocol.rst:85
msgid ""
"The transport classes are :ref:`not thread safe <asyncio-multithreading>`."
msgstr ""
"Las clases de transporte son :ref:`no thread safe <asyncio-multithreading>`."

#: ../../library/asyncio-protocol.rst:89
msgid "Transports Hierarchy"
msgstr "Jerarquía de transportes"

#: ../../library/asyncio-protocol.rst:93
msgid ""
"Base class for all transports.  Contains methods that all asyncio transports "
"share."
msgstr ""
"Clase base para todos los transportes.  Contiene métodos que comparten todos "
"los transportes asyncio."

#: ../../library/asyncio-protocol.rst:98
msgid "A base transport for write-only connections."
msgstr "Un transporte base para conexiones de sólo escritura."

#: ../../library/asyncio-protocol.rst:100
msgid ""
"Instances of the *WriteTransport* class are returned from the :meth:`loop."
"connect_write_pipe` event loop method and are also used by subprocess-"
"related methods like :meth:`loop.subprocess_exec`."
msgstr ""
"Las instancias de la clase *WriteTransport* son devueltas por el método de "
"bucle de eventos :meth:`loop.connect_write_pipe` y también son utilizadas "
"por métodos relacionados con subprocesos como :meth:`loop.subprocess_exec`."

#: ../../library/asyncio-protocol.rst:107
msgid "A base transport for read-only connections."
msgstr "Un transporte base para conexiones de sólo lectura."

#: ../../library/asyncio-protocol.rst:109
msgid ""
"Instances of the *ReadTransport* class are returned from the :meth:`loop."
"connect_read_pipe` event loop method and are also used by subprocess-related "
"methods like :meth:`loop.subprocess_exec`."
msgstr ""
"Las instancias de la clase *ReadTransport* se devuelven por el método de "
"bucle de eventos :meth:`loop.connect_read_pipe` y también se utilizan por "
"métodos relacionados con subprocesos como :meth:`loop.subprocess_exec`."

#: ../../library/asyncio-protocol.rst:116
msgid ""
"Interface representing a bidirectional transport, such as a TCP connection."
msgstr ""
"Interfaz que representa un transporte bidireccional, como una conexión TCP."

#: ../../library/asyncio-protocol.rst:119
msgid ""
"The user does not instantiate a transport directly; they call a utility "
"function, passing it a protocol factory and other information necessary to "
"create the transport and protocol."
msgstr ""
"El usuario no instanciará un transporte directamente, sino que llamará a una "
"función de utilidad, pasándole una fábrica de protocolos y otra información "
"necesaria para crear el transporte y el protocolo."

#: ../../library/asyncio-protocol.rst:123
msgid ""
"Instances of the *Transport* class are returned from or used by event loop "
"methods like :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.create_server`, :meth:`loop.sendfile`, "
"etc."
msgstr ""
"Las instancias de la clase *Transport* son devueltas o utilizadas por "
"métodos de bucle de eventos como :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.create_server`, :meth:`loop.sendfile`, "
"etc."

#: ../../library/asyncio-protocol.rst:131
msgid "A transport for datagram (UDP) connections."
msgstr "Un transporte para conexiones de datagramas (UDP)."

#: ../../library/asyncio-protocol.rst:133
msgid ""
"Instances of the *DatagramTransport* class are returned from the :meth:`loop."
"create_datagram_endpoint` event loop method."
msgstr ""
"Las instancias de la clase *DatagramTransport* se devuelven desde el método "
"de bucle de eventos :meth:`loop.create_datagram_endpoint`."

#: ../../library/asyncio-protocol.rst:139
msgid ""
"An abstraction to represent a connection between a parent and its child OS "
"process."
msgstr ""
"Una abstracción para representar una conexión entre un proceso OS padre y su "
"proceso OS hijo."

#: ../../library/asyncio-protocol.rst:142
msgid ""
"Instances of the *SubprocessTransport* class are returned from event loop "
"methods :meth:`loop.subprocess_shell` and :meth:`loop.subprocess_exec`."
msgstr ""
"Las instancias de la clase *SubprocessTransport* se devuelven desde los "
"métodos de bucle de eventos :meth:`loop.subprocess_shell` y :meth:`loop."
"subprocess_exec`."

#: ../../library/asyncio-protocol.rst:148
msgid "Base Transport"
msgstr "Transporte base"

#: ../../library/asyncio-protocol.rst:152
msgid "Close the transport."
msgstr "Cierra el transporte."

#: ../../library/asyncio-protocol.rst:154
msgid ""
"If the transport has a buffer for outgoing data, buffered data will be "
"flushed asynchronously.  No more data will be received.  After all buffered "
"data is flushed, the protocol's :meth:`protocol.connection_lost() "
"<BaseProtocol.connection_lost>` method will be called with :const:`None` as "
"its argument. The transport should not be used once it is closed."
msgstr ""
"Si el transporte tiene un búfer para los datos salientes, los datos "
"almacenados en el búfer se vaciarán de forma asíncrona.  No se recibirán más "
"datos.  Después de que todos los datos almacenados en el buffer se hayan "
"vaciado, se llamará el método :meth:`protocol.connection_lost() "
"<BaseProtocol.connection_lost>` del protocolo con :const:`None` como "
"argumento. El transporte no debe utilizarse una vez cerrado."

#: ../../library/asyncio-protocol.rst:164
msgid "Return ``True`` if the transport is closing or is closed."
msgstr "Devuelve ``True`` si el transporte se está cerrando o está cerrado."

#: ../../library/asyncio-protocol.rst:168
msgid "Return information about the transport or underlying resources it uses."
msgstr ""
"Devuelve información sobre el transporte o los recursos subyacentes que "
"utiliza."

#: ../../library/asyncio-protocol.rst:171
msgid ""
"*name* is a string representing the piece of transport-specific information "
"to get."
msgstr ""
"*name* es una cadena que representa la información específica del transporte "
"que se desea obtener."

#: ../../library/asyncio-protocol.rst:174
msgid ""
"*default* is the value to return if the information is not available, or if "
"the transport does not support querying it with the given third-party event "
"loop implementation or on the current platform."
msgstr ""
"*default* es el valor a devolver si la información no está disponible, o si "
"el transporte no admite su consulta con la implementación de bucle de "
"eventos de terceros dada o en la plataforma actual."

#: ../../library/asyncio-protocol.rst:179
msgid ""
"For example, the following code attempts to get the underlying socket object "
"of the transport::"
msgstr ""
"Por ejemplo, el siguiente código intenta obtener el objeto socket subyacente "
"del transporte::"

#: ../../library/asyncio-protocol.rst:182
msgid ""
"sock = transport.get_extra_info('socket')\n"
"if sock is not None:\n"
"    print(sock.getsockopt(...))"
msgstr ""
"sock = transport.get_extra_info('socket')\n"
"if sock is not None:\n"
"    print(sock.getsockopt(...))"

#: ../../library/asyncio-protocol.rst:186
msgid "Categories of information that can be queried on some transports:"
msgstr ""
"Categorías de información que pueden consultarse en algunos transportes:"

#: ../../library/asyncio-protocol.rst:188
msgid "socket:"
msgstr "socket:"

#: ../../library/asyncio-protocol.rst:190
msgid ""
"``'peername'``: the remote address to which the socket is connected, result "
"of :meth:`socket.socket.getpeername` (``None`` on error)"
msgstr ""
"``'peername'``: la dirección remota a la que está conectado el socket, "
"resultado de :meth:`socket.socket.getpeername` (``None`` en caso de error)"

#: ../../library/asyncio-protocol.rst:194
msgid "``'socket'``: :class:`socket.socket` instance"
msgstr "``'socket'``: :class:`socket.socket` instancia"

#: ../../library/asyncio-protocol.rst:196
msgid ""
"``'sockname'``: the socket's own address, result of :meth:`socket.socket."
"getsockname`"
msgstr ""
"``'sockname'``: la propia dirección del socket, resultado de :meth:`socket."
"socket.getsockname`"

#: ../../library/asyncio-protocol.rst:199
msgid "SSL socket:"
msgstr "Socket SSL:"

#: ../../library/asyncio-protocol.rst:201
msgid ""
"``'compression'``: the compression algorithm being used as a string, or "
"``None`` if the connection isn't compressed; result of :meth:`ssl.SSLSocket."
"compression`"
msgstr ""
"``'compression'``: el algoritmo de compresión utilizado en forma de cadena, "
"o ``None`` si la conexión no está comprimida; resultado de :meth:`ssl."
"SSLSocket.compression`"

#: ../../library/asyncio-protocol.rst:205
msgid ""
"``'cipher'``: a three-value tuple containing the name of the cipher being "
"used, the version of the SSL protocol that defines its use, and the number "
"of secret bits being used; result of :meth:`ssl.SSLSocket.cipher`"
msgstr ""
"``'cipher'``: una tupla de tres valores que contiene el nombre del cifrado "
"que se está utilizando, la versión del protocolo SSL que define su uso y el "
"número de bits secretos que se están utilizando; resultado de :meth:`ssl."
"SSLSocket.cipher`"

#: ../../library/asyncio-protocol.rst:210
msgid ""
"``'peercert'``: peer certificate; result of :meth:`ssl.SSLSocket.getpeercert`"
msgstr ""
"``'peercert'``: certificado paritario; resultado de :meth:`ssl.SSLSocket."
"getpeercert`"

#: ../../library/asyncio-protocol.rst:213
msgid "``'sslcontext'``: :class:`ssl.SSLContext` instance"
msgstr "``'sslcontext'``: :class:`ssl.SSLContext` instancia"

#: ../../library/asyncio-protocol.rst:215
msgid ""
"``'ssl_object'``: :class:`ssl.SSLObject` or :class:`ssl.SSLSocket` instance"
msgstr ""
"``'ssl_object'``: :class:`ssl.SSLObject` o :class:`ssl.SSLSocket` instancia"

#: ../../library/asyncio-protocol.rst:218
msgid "pipe:"
msgstr "tubería:"

#: ../../library/asyncio-protocol.rst:220
msgid "``'pipe'``: pipe object"
msgstr "``'pipe'``: objeto tubería"

#: ../../library/asyncio-protocol.rst:222
msgid "subprocess:"
msgstr "subproceso:"

#: ../../library/asyncio-protocol.rst:224
msgid "``'subprocess'``: :class:`subprocess.Popen` instance"
msgstr "``'subprocess'``: :class:`subprocess.Popen` instancia"

#: ../../library/asyncio-protocol.rst:228
msgid "Set a new protocol."
msgstr "Establece un nuevo protocolo."

#: ../../library/asyncio-protocol.rst:230
msgid ""
"Switching protocol should only be done when both protocols are documented to "
"support the switch."
msgstr ""
"El cambio de protocolo sólo debe hacerse cuando ambos protocolos estén "
"documentados para soportar el cambio."

#: ../../library/asyncio-protocol.rst:235
msgid "Return the current protocol."
msgstr "Devuelve el protocolo actual."

#: ../../library/asyncio-protocol.rst:239
msgid "Read-only Transports"
msgstr "Transportes de sólo lectura"

#: ../../library/asyncio-protocol.rst:243
msgid "Return ``True`` if the transport is receiving new data."
msgstr "Devuelve ``True`` si el transporte está recibiendo nuevos datos."

#: ../../library/asyncio-protocol.rst:249
msgid ""
"Pause the receiving end of the transport.  No data will be passed to the "
"protocol's :meth:`protocol.data_received() <Protocol.data_received>` method "
"until :meth:`resume_reading` is called."
msgstr ""
"Pone en pausa el extremo receptor del transporte.  No se pasarán datos al "
"método :meth:`protocol.data_received() <Protocol.data_received>` del "
"protocolo hasta que se llame a :meth:`resume_reading`."

#: ../../library/asyncio-protocol.rst:253
msgid ""
"The method is idempotent, i.e. it can be called when the transport is "
"already paused or closed."
msgstr ""
"El método es idempotente, es decir, se puede llamar cuando el transporte ya "
"está en pausa o cerrado."

#: ../../library/asyncio-protocol.rst:259
msgid ""
"Resume the receiving end.  The protocol's :meth:`protocol.data_received() "
"<Protocol.data_received>` method will be called once again if some data is "
"available for reading."
msgstr ""
"Reanudar el extremo receptor.  Se volverá a llamar al método :meth:`protocol."
"data_received() <Protocol.data_received>` del protocolo si hay algún dato "
"disponible para leer."

#: ../../library/asyncio-protocol.rst:263
msgid ""
"The method is idempotent, i.e. it can be called when the transport is "
"already reading."
msgstr ""
"El método es idempotente, es decir, se puede llamar cuando transport ya está "
"leyendo."

#: ../../library/asyncio-protocol.rst:269
msgid "Write-only Transports"
msgstr "Transports de sólo escritura"

#: ../../library/asyncio-protocol.rst:273
msgid ""
"Close the transport immediately, without waiting for pending operations to "
"complete.  Buffered data will be lost.  No more data will be received. The "
"protocol's :meth:`protocol.connection_lost() <BaseProtocol.connection_lost>` "
"method will eventually be called with :const:`None` as its argument."
msgstr ""
"Cierre transport inmediatamente, sin esperar a que finalicen las operaciones "
"pendientes.  Se perderán los datos almacenados en el búfer.  No se recibirán "
"más datos. El método :meth:`protocol.connection_lost() <BaseProtocol."
"connection_lost>` del protocolo se llamará finalmente con :const:`None` como "
"argumento."

#: ../../library/asyncio-protocol.rst:281
msgid ""
"Return :const:`True` if the transport supports :meth:`~WriteTransport."
"write_eof`, :const:`False` if not."
msgstr ""
"Devuelve :const:`True` si transport admite :meth:`~WriteTransport."
"write_eof`, :const:`False` en caso contrario."

#: ../../library/asyncio-protocol.rst:286
msgid "Return the current size of the output buffer used by the transport."
msgstr "Devuelve el tamaño actual del búfer de salida utilizado por transport."

#: ../../library/asyncio-protocol.rst:290
msgid ""
"Get the *high* and *low* watermarks for write flow control. Return a tuple "
"``(low, high)`` where *low* and *high* are positive number of bytes."
msgstr ""
"Obtiene las marcas de agua *high* y *low* para el control de flujo de "
"escritura. Devuelve una tupla ``(low, high)`` donde *low* y *high* son "
"números positivos de bytes."

#: ../../library/asyncio-protocol.rst:294
msgid "Use :meth:`set_write_buffer_limits` to set the limits."
msgstr "Utilice :meth:`set_write_buffer_limits` para fijar los límites."

#: ../../library/asyncio-protocol.rst:300
msgid "Set the *high* and *low* watermarks for write flow control."
msgstr ""
"Establezca las marcas de agua *high* y *low* para el control del flujo de "
"escritura."

#: ../../library/asyncio-protocol.rst:302
msgid ""
"These two values (measured in number of bytes) control when the protocol's :"
"meth:`protocol.pause_writing() <BaseProtocol.pause_writing>` and :meth:"
"`protocol.resume_writing() <BaseProtocol.resume_writing>` methods are "
"called. If specified, the low watermark must be less than or equal to the "
"high watermark.  Neither *high* nor *low* can be negative."
msgstr ""
"Estos dos valores (medidos en número de bytes) controlan cuándo se llama a "
"los métodos :meth:`protocol.pause_writing() <BaseProtocol.pause_writing>` y :"
"meth:`protocol.resume_writing() <BaseProtocol.resume_writing>` del "
"protocolo. Si se especifica, la marca de agua low debe ser menor o igual que "
"la marca de agua high.  Ni *high* ni *low* pueden ser negativas."

#: ../../library/asyncio-protocol.rst:310
msgid ""
":meth:`~BaseProtocol.pause_writing` is called when the buffer size becomes "
"greater than or equal to the *high* value. If writing has been paused, :meth:"
"`~BaseProtocol.resume_writing` is called when the buffer size becomes less "
"than or equal to the *low* value."
msgstr ""
":meth:`~BaseProtocol.pause_writing` cuando el tamaño del búfer es mayor o "
"igual que el valor *high*. Si se ha detenido la escritura, se llama a :meth:"
"`~BaseProtocol.resume_writing` cuando el tamaño del búfer es menor o igual "
"que el valor *low*."

#: ../../library/asyncio-protocol.rst:315
msgid ""
"The defaults are implementation-specific.  If only the high watermark is "
"given, the low watermark defaults to an implementation-specific value less "
"than or equal to the high watermark.  Setting *high* to zero forces *low* to "
"zero as well, and causes :meth:`~BaseProtocol.pause_writing` to be called "
"whenever the buffer becomes non-empty.  Setting *low* to zero causes :meth:"
"`~BaseProtocol.resume_writing` to be called only once the buffer is empty. "
"Use of zero for either limit is generally sub-optimal as it reduces "
"opportunities for doing I/O and computation concurrently."
msgstr ""
"Los valores por defecto son específicos de cada aplicación.  Si sólo se "
"especifica la marca de agua high, la marca de agua low será por defecto un "
"valor específico de la implementación menor o igual que la marca de agua "
"high.  Establecer *high* a cero fuerza *low* a cero también, y hace que se "
"llame a :meth:`~BaseProtocol.pause_writing` siempre que el buffer no esté "
"vacío.  Establecer *low* a cero hace que :meth:`~BaseProtocol."
"resume_writing` se llame sólo una vez a que el buffer esté vacío. El uso de "
"cero para cualquiera de los límites es generalmente sub-óptimo ya que reduce "
"las oportunidades de hacer E/S y computación concurrentemente."

#: ../../library/asyncio-protocol.rst:326
msgid "Use :meth:`~WriteTransport.get_write_buffer_limits` to get the limits."
msgstr ""
"Usar :meth:`~WriteTransport.get_write_buffer_limits` para obtener los "
"límites."

#: ../../library/asyncio-protocol.rst:331
msgid "Write some *data* bytes to the transport."
msgstr "Escribir algunos bytes de *datos* en transport."

#: ../../library/asyncio-protocol.rst:333
#: ../../library/asyncio-protocol.rst:362
msgid ""
"This method does not block; it buffers the data and arranges for it to be "
"sent out asynchronously."
msgstr ""
"Este método no se bloquea; almacena los datos en la memoria intermedia y se "
"encarga de que se envíen de forma asíncrona."

#: ../../library/asyncio-protocol.rst:338
msgid ""
"Write a list (or any iterable) of data bytes to the transport. This is "
"functionally equivalent to calling :meth:`write` on each element yielded by "
"the iterable, but may be implemented more efficiently."
msgstr ""
"Escribe una lista (o cualquier iterable) de bytes de datos en transport. "
"Esto es funcionalmente equivalente a llamar a :meth:`write` en cada elemento "
"producido por el iterable, pero se puede implementar de manera más eficiente."

#: ../../library/asyncio-protocol.rst:345
msgid ""
"Close the write end of the transport after flushing all buffered data. Data "
"may still be received."
msgstr ""
"Cierra el extremo de escritura del transporte después de vaciar todos los "
"datos almacenados en el búfer. Es posible que se sigan recibiendo datos."

#: ../../library/asyncio-protocol.rst:348
msgid ""
"This method can raise :exc:`NotImplementedError` if the transport (e.g. SSL) "
"doesn't support half-closed connections."
msgstr ""
"Este método puede generar :exc:`NotImplementedError` si el transporte (por "
"ejemplo, SSL) no admite conexiones semicerradas."

#: ../../library/asyncio-protocol.rst:353
msgid "Datagram Transports"
msgstr "Transports de datagramas"

#: ../../library/asyncio-protocol.rst:357
msgid ""
"Send the *data* bytes to the remote peer given by *addr* (a transport-"
"dependent target address).  If *addr* is :const:`None`, the data is sent to "
"the target address given on transport creation."
msgstr ""
"Envía los bytes *data* al par remoto indicado por *addr* (una dirección de "
"destino dependiente del transporte).  Si *addr* es :const:`None`, los datos "
"se envían a la dirección de destino dada en la creación del transporte."

#: ../../library/asyncio-protocol.rst:365
msgid ""
"This method can be called with an empty bytes object to send a zero-length "
"datagram. The buffer size calculation used for flow control is also updated "
"to account for the datagram header."
msgstr ""

#: ../../library/asyncio-protocol.rst:372
msgid ""
"Close the transport immediately, without waiting for pending operations to "
"complete.  Buffered data will be lost. No more data will be received.  The "
"protocol's :meth:`protocol.connection_lost() <BaseProtocol.connection_lost>` "
"method will eventually be called with :const:`None` as its argument."
msgstr ""
"Cierre transport inmediatamente, sin esperar a que finalicen las operaciones "
"pendientes.  Se perderán los datos almacenados en el búfer. No se recibirán "
"más datos.  El :meth:`protocol.connection_lost()  <BaseProtocol."
"connection_lost>` del protocolo se llamará finalmente con :const:`None` como "
"argumento."

#: ../../library/asyncio-protocol.rst:382
msgid "Subprocess Transports"
msgstr "Subproceso Transports"

#: ../../library/asyncio-protocol.rst:386
msgid "Return the subprocess process id as an integer."
msgstr "Devuelve el id de proceso del subproceso como un entero."

#: ../../library/asyncio-protocol.rst:390
msgid ""
"Return the transport for the communication pipe corresponding to the integer "
"file descriptor *fd*:"
msgstr ""
"Devuelve el transporte de la tubería de comunicación correspondiente al "
"descriptor de fichero entero *fd*:"

#: ../../library/asyncio-protocol.rst:393
msgid ""
"``0``: writable streaming transport of the standard input (*stdin*), or :"
"const:`None` if the subprocess was not created with ``stdin=PIPE``"
msgstr ""

#: ../../library/asyncio-protocol.rst:395
msgid ""
"``1``: readable streaming transport of the standard output (*stdout*), or :"
"const:`None` if the subprocess was not created with ``stdout=PIPE``"
msgstr ""

#: ../../library/asyncio-protocol.rst:397
msgid ""
"``2``: readable streaming transport of the standard error (*stderr*), or :"
"const:`None` if the subprocess was not created with ``stderr=PIPE``"
msgstr ""

#: ../../library/asyncio-protocol.rst:399
msgid "other *fd*: :const:`None`"
msgstr "otros *fd*: :const:`None`"

#: ../../library/asyncio-protocol.rst:403
msgid ""
"Return the subprocess return code as an integer or :const:`None` if it "
"hasn't returned, which is similar to the :attr:`subprocess.Popen.returncode` "
"attribute."
msgstr ""
"Devuelve el código de retorno del subproceso como un entero o :const:`None` "
"si no ha vuelto, que es similar al atributo :attr:`subprocess.Popen."
"returncode`."

#: ../../library/asyncio-protocol.rst:409
msgid "Kill the subprocess."
msgstr "Mata el subproceso."

#: ../../library/asyncio-protocol.rst:411
msgid ""
"On POSIX systems, the function sends SIGKILL to the subprocess. On Windows, "
"this method is an alias for :meth:`terminate`."
msgstr ""
"En sistemas POSIX, la función envía SIGKILL al subproceso. En Windows, este "
"método es un alias de :meth:`terminate`."

#: ../../library/asyncio-protocol.rst:414
msgid "See also :meth:`subprocess.Popen.kill`."
msgstr "Ver también :meth:`subprocess.Popen.kill`."

#: ../../library/asyncio-protocol.rst:418
msgid ""
"Send the *signal* number to the subprocess, as in :meth:`subprocess.Popen."
"send_signal`."
msgstr ""
"Envía el número de *señal* al subproceso, como en :meth:`subprocess.Popen."
"send_signal`."

#: ../../library/asyncio-protocol.rst:423
msgid "Stop the subprocess."
msgstr "Detener el subproceso."

#: ../../library/asyncio-protocol.rst:425
msgid ""
"On POSIX systems, this method sends :py:const:`~signal.SIGTERM` to the "
"subprocess. On Windows, the Windows API function :c:func:`!TerminateProcess` "
"is called to stop the subprocess."
msgstr ""
"En sistemas POSIX, este método envía :py:const:`~signal.SIGTERM` al "
"subproceso. En Windows, se llama a la función de la API de Windows :c:func:`!"
"TerminateProcess` para detener el subproceso."

#: ../../library/asyncio-protocol.rst:429
msgid "See also :meth:`subprocess.Popen.terminate`."
msgstr "Ver también :meth:`subprocess.Popen.terminate`."

#: ../../library/asyncio-protocol.rst:433
msgid "Kill the subprocess by calling the :meth:`kill` method."
msgstr "Mata el subproceso llamando al método :meth:`kill`."

#: ../../library/asyncio-protocol.rst:435
msgid ""
"If the subprocess hasn't returned yet, and close transports of *stdin*, "
"*stdout*, and *stderr* pipes."
msgstr ""
"Si el subproceso aún no ha regresado, y cerrar los transportes de tuberías "
"*stdin*, *stdout* y *stderr*."

#: ../../library/asyncio-protocol.rst:442
msgid "Protocols"
msgstr "Protocolos"

#: ../../library/asyncio-protocol.rst:444
msgid "**Source code:** :source:`Lib/asyncio/protocols.py`"
msgstr "**Código fuente:** :source:`Lib/asyncio/protocols.py`"

#: ../../library/asyncio-protocol.rst:448
msgid ""
"asyncio provides a set of abstract base classes that should be used to "
"implement network protocols.  Those classes are meant to be used together "
"with :ref:`transports <asyncio-transport>`."
msgstr ""
"asyncio proporciona un conjunto de clases base abstractas que deben "
"utilizarse para implementar protocolos de red.  Esas clases están pensadas "
"para ser utilizadas junto con :ref:`transports <asyncio-transport>`."

#: ../../library/asyncio-protocol.rst:452
msgid ""
"Subclasses of abstract base protocol classes may implement some or all "
"methods.  All these methods are callbacks: they are called by transports on "
"certain events, for example when some data is received. A base protocol "
"method should be called by the corresponding transport."
msgstr ""
"Las subclases de las clases de protocolo base abstractas pueden implementar "
"algunos o todos los métodos.  Todos estos métodos son retrollamadas: son "
"llamados por los transportes en determinados eventos, por ejemplo, cuando se "
"recibe algún dato. Un método de protocolo base debe ser llamado por el "
"transporte correspondiente."

#: ../../library/asyncio-protocol.rst:459
msgid "Base Protocols"
msgstr "Protocolos base"

#: ../../library/asyncio-protocol.rst:463
msgid "Base protocol with methods that all protocols share."
msgstr "Protocolo base con métodos que comparten todos los protocolos."

#: ../../library/asyncio-protocol.rst:467
msgid ""
"The base class for implementing streaming protocols (TCP, Unix sockets, etc)."
msgstr ""
"La clase base para implementar protocolos de streaming (TCP, sockets Unix, "
"etc)."

#: ../../library/asyncio-protocol.rst:472
msgid ""
"A base class for implementing streaming protocols with manual control of the "
"receive buffer."
msgstr ""
"Una clase base para implementar protocolos de streaming con control manual "
"del buffer de recepción."

#: ../../library/asyncio-protocol.rst:477
msgid "The base class for implementing datagram (UDP) protocols."
msgstr "La clase base para implementar protocolos de datagramas (UDP)."

#: ../../library/asyncio-protocol.rst:481
msgid ""
"The base class for implementing protocols communicating with child processes "
"(unidirectional pipes)."
msgstr ""
"La clase base para implementar protocolos que se comunican con procesos "
"hijos (tuberías unidireccionales)."

#: ../../library/asyncio-protocol.rst:486
msgid "Base Protocol"
msgstr "Protocolo base"

#: ../../library/asyncio-protocol.rst:488
msgid "All asyncio protocols can implement Base Protocol callbacks."
msgstr ""
"Todos los protocolos asyncio pueden implementar llamadas de retorno del "
"Protocolo Base."

#: ../../library/asyncio-protocol.rst:491
msgid "Connection Callbacks"
msgstr "Devoluciones de llamada de conexión"

#: ../../library/asyncio-protocol.rst:492
msgid ""
"Connection callbacks are called on all protocols, exactly once per a "
"successful connection.  All other protocol callbacks can only be called "
"between those two methods."
msgstr ""
"Las retrollamadas de conexión son llamadas en todos los protocolos, "
"exactamente una vez por cada conexión exitosa.  Todas las demás "
"retrollamadas de protocolo sólo pueden invocarse entre esos dos métodos."

#: ../../library/asyncio-protocol.rst:498
msgid "Called when a connection is made."
msgstr "Se activa cuando se establece una conexión."

#: ../../library/asyncio-protocol.rst:500
msgid ""
"The *transport* argument is the transport representing the connection.  The "
"protocol is responsible for storing the reference to its transport."
msgstr ""
"El argumento *transport* es el transporte que representa la conexión.  El "
"protocolo es responsable de almacenar la referencia a su transporte."

#: ../../library/asyncio-protocol.rst:506
msgid "Called when the connection is lost or closed."
msgstr "Llamada cuando la conexión se pierde o se cierra."

#: ../../library/asyncio-protocol.rst:508
msgid ""
"The argument is either an exception object or :const:`None`. The latter "
"means a regular EOF is received, or the connection was aborted or closed by "
"this side of the connection."
msgstr ""
"El argumento es un objeto de excepción o :const:`None`. Este último "
"significa que se ha recibido un EOF normal, o que la conexión ha sido "
"abortada o cerrada por este lado de la conexión."

#: ../../library/asyncio-protocol.rst:514
msgid "Flow Control Callbacks"
msgstr "Llamadas de retorno de control de flujo"

#: ../../library/asyncio-protocol.rst:515
msgid ""
"Flow control callbacks can be called by transports to pause or resume "
"writing performed by the protocol."
msgstr ""
"Las retrollamadas de control de flujo se pueden invocar por los transportes "
"para pausar o reanudar la escritura realizada por el protocolo."

#: ../../library/asyncio-protocol.rst:518
msgid ""
"See the documentation of the :meth:`~WriteTransport.set_write_buffer_limits` "
"method for more details."
msgstr ""
"Para más detalles, ver la documentación del método :meth:`~WriteTransport."
"set_write_buffer_limits`."

#: ../../library/asyncio-protocol.rst:523
msgid "Called when the transport's buffer goes over the high watermark."
msgstr ""
"Llamada cuando el buffer del transporte sobrepasa la marca de agua alta."

#: ../../library/asyncio-protocol.rst:527
msgid "Called when the transport's buffer drains below the low watermark."
msgstr ""
"Llamada cuando el buffer del transporte se vacía por debajo de la marca de "
"agua baja."

#: ../../library/asyncio-protocol.rst:529
msgid ""
"If the buffer size equals the high watermark, :meth:`~BaseProtocol."
"pause_writing` is not called: the buffer size must go strictly over."
msgstr ""
"Si el tamaño del búfer es igual a la filigrana digital alta, no se llama a :"
"meth:`~BaseProtocol.pause_writing`: el tamaño del búfer debe superarse "
"estrictamente."

#: ../../library/asyncio-protocol.rst:533
msgid ""
"Conversely, :meth:`~BaseProtocol.resume_writing` is called when the buffer "
"size is equal or lower than the low watermark.  These end conditions are "
"important to ensure that things go as expected when either mark is zero."
msgstr ""
"A la inversa, se llama a :meth:`~BaseProtocol.resume_writing` cuando el "
"tamaño del búfer es igual o inferior a la filigrana digital baja.  Estas "
"condiciones finales son importantes para asegurar que las cosas van como se "
"espera cuando cualquiera de las marcas es cero."

#: ../../library/asyncio-protocol.rst:540
msgid "Streaming Protocols"
msgstr "Protocolos de streaming"

#: ../../library/asyncio-protocol.rst:542
msgid ""
"Event methods, such as :meth:`loop.create_server`, :meth:`loop."
"create_unix_server`, :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.connect_accepted_socket`, :meth:`loop."
"connect_read_pipe`, and :meth:`loop.connect_write_pipe` accept factories "
"that return streaming protocols."
msgstr ""
"Los métodos de eventos, como :meth:`loop.create_server`, :meth:`loop."
"create_unix_server`, :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.connect_accepted_socket`, :meth:`loop."
"connect_read_pipe`, y :meth:`loop.connect_write_pipe` aceptan fábricas que "
"devuelven protocolos de streaming."

#: ../../library/asyncio-protocol.rst:550
msgid ""
"Called when some data is received.  *data* is a non-empty bytes object "
"containing the incoming data."
msgstr ""
"Se ejecuta cuando se reciben datos.  *data* es un objeto bytes no vacío que "
"contiene los datos recibidos."

#: ../../library/asyncio-protocol.rst:553
msgid ""
"Whether the data is buffered, chunked or reassembled depends on the "
"transport.  In general, you shouldn't rely on specific semantics and instead "
"make your parsing generic and flexible. However, data is always received in "
"the correct order."
msgstr ""
"Que los datos se almacenen en búfer, en trozos o se reensamblen depende del "
"transporte.  En general, no se debe depender de una semántica específica y, "
"en su lugar, hacer que el análisis sintáctico sea genérico y flexible. Sin "
"embargo, los datos siempre se reciben en el orden correcto."

#: ../../library/asyncio-protocol.rst:558
msgid ""
"The method can be called an arbitrary number of times while a connection is "
"open."
msgstr ""
"El método se puede llamar un número arbitrario de veces mientras una "
"conexión está abierta."

#: ../../library/asyncio-protocol.rst:561
msgid ""
"However, :meth:`protocol.eof_received() <Protocol.eof_received>` is called "
"at most once.  Once ``eof_received()`` is called, ``data_received()`` is not "
"called anymore."
msgstr ""
"Sin embargo, :meth:`protocol.eof_received() <Protocol.eof_received>` se "
"llama como máximo una vez.  Una vez que se llama a ``eof_received()``, no se "
"vuelve a llamar a ``data_received()``."

#: ../../library/asyncio-protocol.rst:567
msgid ""
"Called when the other end signals it won't send any more data (for example "
"by calling :meth:`transport.write_eof() <WriteTransport.write_eof>`, if the "
"other end also uses asyncio)."
msgstr ""
"Llamada cuando el otro extremo señala que no enviará más datos (por ejemplo "
"llamando a :meth:`transport.write_eof() <WriteTransport.write_eof>`, si el "
"otro extremo también utiliza asyncio)."

#: ../../library/asyncio-protocol.rst:572
msgid ""
"This method may return a false value (including ``None``), in which case the "
"transport will close itself.  Conversely, if this method returns a true "
"value, the protocol used determines whether to close the transport. Since "
"the default implementation returns ``None``, it implicitly closes the "
"connection."
msgstr ""
"Este método puede devolver un valor falso (incluyendo ``None``), en cuyo "
"caso el transporte se cerrará por sí mismo.  Por el contrario, si este "
"método devuelve un valor verdadero, el protocolo utilizado determina si se "
"cierra el transporte. Dado que la implementación por defecto devuelve "
"``None``, implícitamente cierra la conexión."

#: ../../library/asyncio-protocol.rst:578
msgid ""
"Some transports, including SSL, don't support half-closed connections, in "
"which case returning true from this method will result in the connection "
"being closed."
msgstr ""
"Algunos transportes, incluyendo SSL, no soportan conexiones semicerradas, en "
"cuyo caso devolver true desde este método resultará en el cierre de la "
"conexión."

#: ../../library/asyncio-protocol.rst:583
#: ../../library/asyncio-protocol.rst:641
msgid "State machine:"
msgstr "Máquina de estados:"

#: ../../library/asyncio-protocol.rst:585
msgid ""
"start -> connection_made\n"
"    [-> data_received]*\n"
"    [-> eof_received]?\n"
"-> connection_lost -> end"
msgstr ""
"start -> connection_made\n"
"    [-> data_received]*\n"
"    [-> eof_received]?\n"
"-> connection_lost -> end"

#: ../../library/asyncio-protocol.rst:594
msgid "Buffered Streaming Protocols"
msgstr "Protocolos de transmisión en búfer"

#: ../../library/asyncio-protocol.rst:598
msgid ""
"Buffered Protocols can be used with any event loop method that supports "
"`Streaming Protocols`_."
msgstr ""
"Los protocolos en búfer pueden utilizarse con cualquier método de bucle de "
"eventos que admita `Streaming Protocols`_."

#: ../../library/asyncio-protocol.rst:601
msgid ""
"``BufferedProtocol`` implementations allow explicit manual allocation and "
"control of the receive buffer.  Event loops can then use the buffer provided "
"by the protocol to avoid unnecessary data copies.  This can result in "
"noticeable performance improvement for protocols that receive big amounts of "
"data.  Sophisticated protocol implementations can significantly reduce the "
"number of buffer allocations."
msgstr ""
"``BufferedProtocol`` permiten la asignación manual explícita y el control "
"del búfer de recepción.  Los bucles de eventos pueden entonces utilizar el "
"búfer proporcionado por el protocolo para evitar copias innecesarias de "
"datos.  Esto puede mejorar notablemente el rendimiento de los protocolos que "
"reciben grandes cantidades de datos.  Las implementaciones sofisticadas de "
"protocolos pueden reducir significativamente el número de asignaciones de "
"búfer."

#: ../../library/asyncio-protocol.rst:608
msgid ""
"The following callbacks are called on :class:`BufferedProtocol` instances:"
msgstr ""
"Las siguientes llamadas de retorno se ejecutan en las instancias de :class:"
"`BufferedProtocol`:"

#: ../../library/asyncio-protocol.rst:613
msgid "Called to allocate a new receive buffer."
msgstr "Llamada para asignar un nuevo búfer de recepción."

#: ../../library/asyncio-protocol.rst:615
msgid ""
"*sizehint* is the recommended minimum size for the returned buffer.  It is "
"acceptable to return smaller or larger buffers than what *sizehint* "
"suggests.  When set to -1, the buffer size can be arbitrary. It is an error "
"to return a buffer with a zero size."
msgstr ""
"*sizehint* es el tamaño mínimo recomendado para el búfer devuelto.  Es "
"aceptable devolver búferes más pequeños o más grandes que lo que *sizehint* "
"sugiere.  Cuando se establece a -1, el tamaño del búfer puede ser "
"arbitrario. Es un error devolver un buffer con tamaño cero."

#: ../../library/asyncio-protocol.rst:620
msgid ""
"``get_buffer()`` must return an object implementing the :ref:`buffer "
"protocol <bufferobjects>`."
msgstr ""
"``get_buffer()`` debe devolver un objeto que implemente :ref:`buffer "
"protocol <bufferobjects>`."

#: ../../library/asyncio-protocol.rst:625
msgid "Called when the buffer was updated with the received data."
msgstr "Llamada cuando se actualizó el buffer con los datos recibidos."

#: ../../library/asyncio-protocol.rst:627
msgid "*nbytes* is the total number of bytes that were written to the buffer."
msgstr "*nbytes* es el número total de bytes que se han escrito en el búfer."

#: ../../library/asyncio-protocol.rst:631
msgid ""
"See the documentation of the :meth:`protocol.eof_received() <Protocol."
"eof_received>` method."
msgstr ""
"Ver la documentación del método :meth:`protocol.eof_received() <Protocol."
"eof_received>`."

#: ../../library/asyncio-protocol.rst:635
msgid ""
":meth:`~BufferedProtocol.get_buffer` can be called an arbitrary number of "
"times during a connection.  However, :meth:`protocol.eof_received() "
"<Protocol.eof_received>` is called at most once and, if called, :meth:"
"`~BufferedProtocol.get_buffer` and :meth:`~BufferedProtocol.buffer_updated` "
"won't be called after it."
msgstr ""
":meth:`~BufferedProtocol.get_buffer` puede ser llamado un número arbitrario "
"de veces durante una conexión.  Sin embargo, :meth:`protocol.eof_received() "
"<Protocol.eof_received>` se llama como máximo una vez y, si se llama, :meth:"
"`~BufferedProtocol.get_buffer` y :meth:`~BufferedProtocol.buffer_updated` no "
"se llamarán después."

#: ../../library/asyncio-protocol.rst:643
msgid ""
"start -> connection_made\n"
"    [-> get_buffer\n"
"        [-> buffer_updated]?\n"
"    ]*\n"
"    [-> eof_received]?\n"
"-> connection_lost -> end"
msgstr ""
"start -> connection_made\n"
"    [-> get_buffer\n"
"        [-> buffer_updated]?\n"
"    ]*\n"
"    [-> eof_received]?\n"
"-> connection_lost -> end"

#: ../../library/asyncio-protocol.rst:654
msgid "Datagram Protocols"
msgstr "Protocolos de datagramas"

#: ../../library/asyncio-protocol.rst:656
msgid ""
"Datagram Protocol instances should be constructed by protocol factories "
"passed to the :meth:`loop.create_datagram_endpoint` method."
msgstr ""
"Las instancias del Protocolo de Datagramas deben ser construidas por "
"fábricas de protocolo pasadas al método :meth:`loop."
"create_datagram_endpoint`."

#: ../../library/asyncio-protocol.rst:661
msgid ""
"Called when a datagram is received.  *data* is a bytes object containing the "
"incoming data.  *addr* is the address of the peer sending the data; the "
"exact format depends on the transport."
msgstr ""
"Se ejecuta cuando se recibe un datagrama.  *data* es un objeto bytes que "
"contiene los datos entrantes.  *addr* es la dirección del par que envía los "
"datos; el formato exacto depende del transporte."

#: ../../library/asyncio-protocol.rst:667
msgid ""
"Called when a previous send or receive operation raises an :class:"
"`OSError`.  *exc* is the :class:`OSError` instance."
msgstr ""
"Llamada cuando una operación previa de envío o recepción genera un :class:"
"`OSError`.  *exc* es la instancia de :class:`OSError`."

#: ../../library/asyncio-protocol.rst:670
msgid ""
"This method is called in rare conditions, when the transport (e.g. UDP) "
"detects that a datagram could not be delivered to its recipient. In many "
"conditions though, undeliverable datagrams will be silently dropped."
msgstr ""
"Este método se ejecuta en raras ocasiones, cuando el transporte (por "
"ejemplo, UDP) detecta que un datagrama no ha podido entregarse a su "
"destinatario. Sin embargo, en muchos casos, los datagramas que no se pueden "
"entregar se descartan silenciosamente."

#: ../../library/asyncio-protocol.rst:677
msgid ""
"On BSD systems (macOS, FreeBSD, etc.) flow control is not supported for "
"datagram protocols, because there is no reliable way to detect send failures "
"caused by writing too many packets."
msgstr ""
"En sistemas BSD (macOS, FreeBSD, etc.) el control de flujo no está soportado "
"para protocolos de datagramas, porque no hay una forma fiable de detectar "
"fallos de envío causados por la escritura de demasiados paquetes."

#: ../../library/asyncio-protocol.rst:681
msgid ""
"The socket always appears 'ready' and excess packets are dropped. An :class:"
"`OSError` with ``errno`` set to :const:`errno.ENOBUFS` may or may not be "
"raised; if it is raised, it will be reported to :meth:`DatagramProtocol."
"error_received` but otherwise ignored."
msgstr ""
"El socket siempre aparece 'ready' y los paquetes sobrantes se descartan. Un :"
"class:`OSError` con ``errno`` ajustado a :const:`errno.ENOBUFS` puede o no "
"ser levantado; si es levantado, será reportado a :meth:`DatagramProtocol."
"error_received` pero de lo contrario será ignorado."

#: ../../library/asyncio-protocol.rst:690
msgid "Subprocess Protocols"
msgstr "Protocolos de subprocesos"

#: ../../library/asyncio-protocol.rst:692
msgid ""
"Subprocess Protocol instances should be constructed by protocol factories "
"passed to the :meth:`loop.subprocess_exec` and :meth:`loop.subprocess_shell` "
"methods."
msgstr ""
"Las instancias de Protocolo de Subproceso deben construirse por la "
"automatización de protocolos pasadas a los métodos :meth:`loop."
"subprocess_exec` y :meth:`loop.subprocess_shell`."

#: ../../library/asyncio-protocol.rst:698
msgid ""
"Called when the child process writes data into its stdout or stderr pipe."
msgstr ""
"Llamada cuando el proceso hijo escribe datos en su tubería stdout o stderr."

#: ../../library/asyncio-protocol.rst:701
msgid "*fd* is the integer file descriptor of the pipe."
msgstr "*fd* es el descriptor de fichero entero de la tubería."

#: ../../library/asyncio-protocol.rst:703
msgid "*data* is a non-empty bytes object containing the received data."
msgstr "*data* es un objeto bytes no vacío que contiene los datos recibidos."

#: ../../library/asyncio-protocol.rst:707
msgid ""
"Called when one of the pipes communicating with the child process is closed."
msgstr ""
"Llamada cuando se cierra una de las tuberías que comunica con el proceso "
"hijo."

#: ../../library/asyncio-protocol.rst:710
msgid "*fd* is the integer file descriptor that was closed."
msgstr "*fd* es el descriptor de archivo entero que se cerró."

#: ../../library/asyncio-protocol.rst:714
msgid "Called when the child process has exited."
msgstr "Llamada cuando el proceso hijo ha salido."

#: ../../library/asyncio-protocol.rst:716
msgid ""
"It can be called before :meth:`~SubprocessProtocol.pipe_data_received` and :"
"meth:`~SubprocessProtocol.pipe_connection_lost` methods."
msgstr ""
"Puede invocarse antes de los métodos :meth:`~SubprocessProtocol."
"pipe_data_received` y :meth:`~SubprocessProtocol.pipe_connection_lost`."

#: ../../library/asyncio-protocol.rst:721
msgid "Examples"
msgstr "Ejemplos"

#: ../../library/asyncio-protocol.rst:726
msgid "TCP Echo Server"
msgstr "Servidor Eco TCP"

#: ../../library/asyncio-protocol.rst:728
msgid ""
"Create a TCP echo server using the :meth:`loop.create_server` method, send "
"back received data, and close the connection::"
msgstr ""
"Crear un servidor eco TCP utilizando el método :meth:`loop.create_server`, "
"devolver los datos recibidos y cerrar la conexión::"

#: ../../library/asyncio-protocol.rst:731
msgid ""
"import asyncio\n"
"\n"
"\n"
"class EchoServerProtocol(asyncio.Protocol):\n"
"    def connection_made(self, transport):\n"
"        peername = transport.get_extra_info('peername')\n"
"        print('Connection from {}'.format(peername))\n"
"        self.transport = transport\n"
"\n"
"    def data_received(self, data):\n"
"        message = data.decode()\n"
"        print('Data received: {!r}'.format(message))\n"
"\n"
"        print('Send: {!r}'.format(message))\n"
"        self.transport.write(data)\n"
"\n"
"        print('Close the client socket')\n"
"        self.transport.close()\n"
"\n"
"\n"
"async def main():\n"
"    # Get a reference to the event loop as we plan to use\n"
"    # low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    server = await loop.create_server(\n"
"        EchoServerProtocol,\n"
"        '127.0.0.1', 8888)\n"
"\n"
"    async with server:\n"
"        await server.serve_forever()\n"
"\n"
"\n"
"asyncio.run(main())"
msgstr ""

#: ../../library/asyncio-protocol.rst:769
msgid ""
"The :ref:`TCP echo server using streams <asyncio-tcp-echo-server-streams>` "
"example uses the high-level :func:`asyncio.start_server` function."
msgstr ""
"El ejemplo :ref:`TCP echo server using streams <asyncio-tcp-echo-server-"
"streams>` utiliza la función de alto nivel :func:`asyncio.start_server`."

#: ../../library/asyncio-protocol.rst:775
msgid "TCP Echo Client"
msgstr "Cliente Eco TCP"

#: ../../library/asyncio-protocol.rst:777
msgid ""
"A TCP echo client using the :meth:`loop.create_connection` method, sends "
"data, and waits until the connection is closed::"
msgstr ""
"Un cliente eco TCP que utiliza el método :meth:`loop.create_connection`, "
"envía datos y espera a que se cierre la conexión::"

#: ../../library/asyncio-protocol.rst:780
msgid ""
"import asyncio\n"
"\n"
"\n"
"class EchoClientProtocol(asyncio.Protocol):\n"
"    def __init__(self, message, on_con_lost):\n"
"        self.message = message\n"
"        self.on_con_lost = on_con_lost\n"
"\n"
"    def connection_made(self, transport):\n"
"        transport.write(self.message.encode())\n"
"        print('Data sent: {!r}'.format(self.message))\n"
"\n"
"    def data_received(self, data):\n"
"        print('Data received: {!r}'.format(data.decode()))\n"
"\n"
"    def connection_lost(self, exc):\n"
"        print('The server closed the connection')\n"
"        self.on_con_lost.set_result(True)\n"
"\n"
"\n"
"async def main():\n"
"    # Get a reference to the event loop as we plan to use\n"
"    # low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    on_con_lost = loop.create_future()\n"
"    message = 'Hello World!'\n"
"\n"
"    transport, protocol = await loop.create_connection(\n"
"        lambda: EchoClientProtocol(message, on_con_lost),\n"
"        '127.0.0.1', 8888)\n"
"\n"
"    # Wait until the protocol signals that the connection\n"
"    # is lost and close the transport.\n"
"    try:\n"
"        await on_con_lost\n"
"    finally:\n"
"        transport.close()\n"
"\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"\n"
"class EchoClientProtocol(asyncio.Protocol):\n"
"    def __init__(self, message, on_con_lost):\n"
"        self.message = message\n"
"        self.on_con_lost = on_con_lost\n"
"\n"
"    def connection_made(self, transport):\n"
"        transport.write(self.message.encode())\n"
"        print('Data sent: {!r}'.format(self.message))\n"
"\n"
"    def data_received(self, data):\n"
"        print('Data received: {!r}'.format(data.decode()))\n"
"\n"
"    def connection_lost(self, exc):\n"
"        print('The server closed the connection')\n"
"        self.on_con_lost.set_result(True)\n"
"\n"
"\n"
"async def main():\n"
"    # Obtener una referencia al bucle de eventos que planeamos usar\n"
"    # API de bajo nivel.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    on_con_lost = loop.create_future()\n"
"    message = '¡Hola Mundo!'\n"
"\n"
"    transport, protocol = await loop.create_connection(\n"
"        lambda: EchoClientProtocol(message, on_con_lost),\n"
"        '127.0.0.1', 8888)\n"
"\n"
"    # Esperar hasta que el protocolo indique que la conexión\n"
"    # se pierde y cierra el transporte.\n"
"    probar:\n"
"        await on_con_lost\n"
"    por último:\n"
"        transport.close()\n"
"\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-protocol.rst:825
msgid ""
"The :ref:`TCP echo client using streams <asyncio-tcp-echo-client-streams>` "
"example uses the high-level :func:`asyncio.open_connection` function."
msgstr ""
"El ejemplo :ref:`TCP echo client using streams <asyncio-tcp-echo-client-"
"streams>` utiliza la función de alto nivel :func:`asyncio.open_connection`."

#: ../../library/asyncio-protocol.rst:832
msgid "UDP Echo Server"
msgstr "Servidor Eco UDP"

#: ../../library/asyncio-protocol.rst:834
msgid ""
"A UDP echo server, using the :meth:`loop.create_datagram_endpoint` method, "
"sends back received data::"
msgstr ""
"Un servidor eco UDP, utilizando el método :meth:`loop."
"create_datagram_endpoint`, devuelve los datos recibidos::"

#: ../../library/asyncio-protocol.rst:837
msgid ""
"import asyncio\n"
"\n"
"\n"
"class EchoServerProtocol:\n"
"    def connection_made(self, transport):\n"
"        self.transport = transport\n"
"\n"
"    def datagram_received(self, data, addr):\n"
"        message = data.decode()\n"
"        print('Received %r from %s' % (message, addr))\n"
"        print('Send %r to %s' % (message, addr))\n"
"        self.transport.sendto(data, addr)\n"
"\n"
"\n"
"async def main():\n"
"    print(\"Starting UDP server\")\n"
"\n"
"    # Get a reference to the event loop as we plan to use\n"
"    # low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    # One protocol instance will be created to serve all\n"
"    # client requests.\n"
"    transport, protocol = await loop.create_datagram_endpoint(\n"
"        EchoServerProtocol,\n"
"        local_addr=('127.0.0.1', 9999))\n"
"\n"
"    try:\n"
"        await asyncio.sleep(3600)  # Serve for 1 hour.\n"
"    finally:\n"
"        transport.close()\n"
"\n"
"\n"
"asyncio.run(main())"
msgstr ""

#: ../../library/asyncio-protocol.rst:876
msgid "UDP Echo Client"
msgstr "Cliente Eco UDP"

#: ../../library/asyncio-protocol.rst:878
msgid ""
"A UDP echo client, using the :meth:`loop.create_datagram_endpoint` method, "
"sends data and closes the transport when it receives the answer::"
msgstr ""
"Un cliente eco UDP, utilizando el método :meth:`loop."
"create_datagram_endpoint`, envía datos y cierra el transporte cuando recibe "
"la respuesta::"

#: ../../library/asyncio-protocol.rst:881
msgid ""
"import asyncio\n"
"\n"
"\n"
"class EchoClientProtocol:\n"
"    def __init__(self, message, on_con_lost):\n"
"        self.message = message\n"
"        self.on_con_lost = on_con_lost\n"
"        self.transport = None\n"
"\n"
"    def connection_made(self, transport):\n"
"        self.transport = transport\n"
"        print('Send:', self.message)\n"
"        self.transport.sendto(self.message.encode())\n"
"\n"
"    def datagram_received(self, data, addr):\n"
"        print(\"Received:\", data.decode())\n"
"\n"
"        print(\"Close the socket\")\n"
"        self.transport.close()\n"
"\n"
"    def error_received(self, exc):\n"
"        print('Error received:', exc)\n"
"\n"
"    def connection_lost(self, exc):\n"
"        print(\"Connection closed\")\n"
"        self.on_con_lost.set_result(True)\n"
"\n"
"\n"
"async def main():\n"
"    # Get a reference to the event loop as we plan to use\n"
"    # low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    on_con_lost = loop.create_future()\n"
"    message = \"Hello World!\"\n"
"\n"
"    transport, protocol = await loop.create_datagram_endpoint(\n"
"        lambda: EchoClientProtocol(message, on_con_lost),\n"
"        remote_addr=('127.0.0.1', 9999))\n"
"\n"
"    try:\n"
"        await on_con_lost\n"
"    finally:\n"
"        transport.close()\n"
"\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"\n"
"class EchoClientProtocol:\n"
"    def __init__(self, message, on_con_lost):\n"
"        self.message = message\n"
"        self.on_con_lost = on_con_lost\n"
"        self.transport = None\n"
"\n"
"    def connection_made(self, transport):\n"
"        self.transport = transport\n"
"        print('Send:', self.message)\n"
"        self.transport.sendto(self.message.encode())\n"
"\n"
"    def datagram_received(self, data, addr):\n"
"        print(\"Received:\", data.decode())\n"
"\n"
"        print(\"Close the socket\")\n"
"        self.transport.close()\n"
"\n"
"    def error_received(self, exc):\n"
"        print('Error received:', exc)\n"
"\n"
"    def connection_lost(self, exc):\n"
"        print(\"Connection closed\")\n"
"        self.on_con_lost.set_result(True)\n"
"\n"
"\n"
"async def main():\n"
"    # Obtener una referencia al bucle de eventos que planeamos usar\n"
"    # API de bajo nivel.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    on_con_lost = loop.create_future()\n"
"    message = \"Hello World!\"\n"
"\n"
"    transport, protocol = await loop.create_datagram_endpoint(\n"
"        lambda: EchoClientProtocol(message, on_con_lost),\n"
"        remote_addr=('127.0.0.1', 9999))\n"
"\n"
"    try:\n"
"        await on_con_lost\n"
"    finally:\n"
"        transport.close()\n"
"\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-protocol.rst:933
msgid "Connecting Existing Sockets"
msgstr "Conexión de tomas existentes"

#: ../../library/asyncio-protocol.rst:935
msgid ""
"Wait until a socket receives data using the :meth:`loop.create_connection` "
"method with a protocol::"
msgstr ""
"Esperar hasta que un socket recibe datos utilizando el método :meth:`loop."
"create_connection` con un protocolo::"

#: ../../library/asyncio-protocol.rst:938
msgid ""
"import asyncio\n"
"import socket\n"
"\n"
"\n"
"class MyProtocol(asyncio.Protocol):\n"
"\n"
"    def __init__(self, on_con_lost):\n"
"        self.transport = None\n"
"        self.on_con_lost = on_con_lost\n"
"\n"
"    def connection_made(self, transport):\n"
"        self.transport = transport\n"
"\n"
"    def data_received(self, data):\n"
"        print(\"Received:\", data.decode())\n"
"\n"
"        # We are done: close the transport;\n"
"        # connection_lost() will be called automatically.\n"
"        self.transport.close()\n"
"\n"
"    def connection_lost(self, exc):\n"
"        # The socket has been closed\n"
"        self.on_con_lost.set_result(True)\n"
"\n"
"\n"
"async def main():\n"
"    # Get a reference to the event loop as we plan to use\n"
"    # low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"    on_con_lost = loop.create_future()\n"
"\n"
"    # Create a pair of connected sockets\n"
"    rsock, wsock = socket.socketpair()\n"
"\n"
"    # Register the socket to wait for data.\n"
"    transport, protocol = await loop.create_connection(\n"
"        lambda: MyProtocol(on_con_lost), sock=rsock)\n"
"\n"
"    # Simulate the reception of data from the network.\n"
"    loop.call_soon(wsock.send, 'abc'.encode())\n"
"\n"
"    try:\n"
"        await protocol.on_con_lost\n"
"    finally:\n"
"        transport.close()\n"
"        wsock.close()\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"import socket\n"
"\n"
"\n"
"class MyProtocol(asyncio.Protocol):\n"
"\n"
"    def __init__(self, on_con_lost):\n"
"        self.transport = None\n"
"        self.on_con_lost = on_con_lost\n"
"\n"
"    def connection_made(self, transport):\n"
"        self.transport = transport\n"
"\n"
"    def data_received(self, data):\n"
"        print(\"Received:\", data.decode())\n"
"\n"
"        # Hemos terminado: cerrar el transporte;\n"
"        # connection_lost () se llamará automáticamente.\n"
"        self.transport.close()\n"
"\n"
"    def connection_lost(self, exc):\n"
"        # The socket has been closed\n"
"        self.on_con_lost.set_result(True)\n"
"\n"
"\n"
"async def main():\n"
"    # Obtener una referencia al bucle de eventos que planeamos usar\n"
"    # API de bajo nivel.\n"
"    loop = asyncio.get_running_loop()\n"
"    on_con_lost = loop.create_future()\n"
"\n"
"    # Create a pair of connected sockets\n"
"    rsock, wsock = socket.socketpair()\n"
"\n"
"    # Registrar el socket para esperar datos.\n"
"    transport, protocol = await loop.create_connection(\n"
"        lambda: MyProtocol(on_con_lost), sock=rsock)\n"
"\n"
"    # Simular la recepción de datos de la red.\n"
"    loop.call_soon(wsock.send, 'abc'.encode())\n"
"\n"
"    try:\n"
"        await protocol.on_con_lost\n"
"    finally:\n"
"        transport.close()\n"
"        wsock.close()\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-protocol.rst:989
msgid ""
"The :ref:`watch a file descriptor for read events "
"<asyncio_example_watch_fd>` example uses the low-level :meth:`loop."
"add_reader` method to register an FD."
msgstr ""
"El ejemplo :ref:`watch a file descriptor for read events "
"<asyncio_example_watch_fd>` utiliza el método de bajo nivel :meth:`loop."
"add_reader` para registrar un FD."

#: ../../library/asyncio-protocol.rst:993
msgid ""
"The :ref:`register an open socket to wait for data using streams "
"<asyncio_example_create_connection-streams>` example uses high-level streams "
"created by the :func:`open_connection` function in a coroutine."
msgstr ""
"El ejemplo :ref:`register an open socket to wait for data using streams "
"<asyncio_example_create_connection-streams>` utiliza flujos de alto nivel "
"creados por la función :func:`open_connection` en una corrutina."

#: ../../library/asyncio-protocol.rst:1000
msgid "loop.subprocess_exec() and SubprocessProtocol"
msgstr "loop.subprocess_exec() y SubprocessProtocol"

#: ../../library/asyncio-protocol.rst:1002
msgid ""
"An example of a subprocess protocol used to get the output of a subprocess "
"and to wait for the subprocess exit."
msgstr ""
"Un ejemplo de protocolo de subproceso utilizado para obtener la salida de un "
"subproceso y esperar la salida del subproceso."

#: ../../library/asyncio-protocol.rst:1005
msgid "The subprocess is created by the :meth:`loop.subprocess_exec` method::"
msgstr ""
"Se crea el subproceso mediante el método :meth:`loop.subprocess_exec`::"

#: ../../library/asyncio-protocol.rst:1007
msgid ""
"import asyncio\n"
"import sys\n"
"\n"
"class DateProtocol(asyncio.SubprocessProtocol):\n"
"    def __init__(self, exit_future):\n"
"        self.exit_future = exit_future\n"
"        self.output = bytearray()\n"
"        self.pipe_closed = False\n"
"        self.exited = False\n"
"\n"
"    def pipe_connection_lost(self, fd, exc):\n"
"        self.pipe_closed = True\n"
"        self.check_for_exit()\n"
"\n"
"    def pipe_data_received(self, fd, data):\n"
"        self.output.extend(data)\n"
"\n"
"    def process_exited(self):\n"
"        self.exited = True\n"
"        # process_exited() method can be called before\n"
"        # pipe_connection_lost() method: wait until both methods are\n"
"        # called.\n"
"        self.check_for_exit()\n"
"\n"
"    def check_for_exit(self):\n"
"        if self.pipe_closed and self.exited:\n"
"            self.exit_future.set_result(True)\n"
"\n"
"async def get_date():\n"
"    # Get a reference to the event loop as we plan to use\n"
"    # low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    code = 'import datetime; print(datetime.datetime.now())'\n"
"    exit_future = asyncio.Future(loop=loop)\n"
"\n"
"    # Create the subprocess controlled by DateProtocol;\n"
"    # redirect the standard output into a pipe.\n"
"    transport, protocol = await loop.subprocess_exec(\n"
"        lambda: DateProtocol(exit_future),\n"
"        sys.executable, '-c', code,\n"
"        stdin=None, stderr=None)\n"
"\n"
"    # Wait for the subprocess exit using the process_exited()\n"
"    # method of the protocol.\n"
"    await exit_future\n"
"\n"
"    # Close the stdout pipe.\n"
"    transport.close()\n"
"\n"
"    # Read the output which was collected by the\n"
"    # pipe_data_received() method of the protocol.\n"
"    data = bytes(protocol.output)\n"
"    return data.decode('ascii').rstrip()\n"
"\n"
"date = asyncio.run(get_date())\n"
"print(f\"Current date: {date}\")"
msgstr ""
"import asyncio\n"
"import sys\n"
"\n"
"class DateProtocol(asyncio.SubprocessProtocol):\n"
"    def __init__(self, exit_future):\n"
"        self.exit_future = exit_future\n"
"        self.output = bytearray()\n"
"        self.pipe_closed = False\n"
"        self.exited = False\n"
"\n"
"    def pipe_connection_lost(self, fd, exc):\n"
"        self.pipe_closed = True\n"
"        self.check_for_exit()\n"
"\n"
"    def pipe_data_received(self, fd, data):\n"
"        self.output.extend(data)\n"
"\n"
"    def process_exited(self):\n"
"        self.exited = True\n"
"        # el método process_exited() se puede llamar antes\n"
"       # pipe_connection_lost (): espere hasta que ambos se llamen ambos\n"
"        # métodos.\n"
"        self.check_for_exit()\n"
"\n"
"    def check_for_exit(self):\n"
"        if self.pipe_closed and self.exited:\n"
"            self.exit_future.set_result(True)\n"
"\n"
"async def get_date():\n"
"    # Obtener una referencia al bucle de eventos que planeamos usar\n"
"     # API de bajo nivel.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    code = 'import datetime; print(datetime.datetime.now())'\n"
"    exit_future = asyncio.Future(loop=loop)\n"
"\n"
"    # Crear el subproceso controlado por protocolo de datos;\n"
"    # redirigir la salida estándar a una tubería. transporte, protocolo = "
"await loop.subprocess_exec(\n"
"        lambda: DateProtocol(exit_future),\n"
"        sys.executable, '-c', code,\n"
"        stdin=None, stderr=None)\n"
"\n"
"    # Esperar a que el subproceso salga usando \n"
"    # el método del protocolo process_exited()\n"
"    esperar exit_future\n"
"\n"
"    # Cerrar la tubería  de salida stdout.\n"
"    transport.close()\n"
"\n"
"    # Leer la salida recopilada por el\n"
"    # método pipe_data_received() del protocolo.\n"
"    data = bytes(protocol.output)\n"
"    return data.decode('ascii').rstrip()\n"
"\n"
"date = asyncio.run(get_date())\n"
"print(f\"Current date: {date}\")"

#: ../../library/asyncio-protocol.rst:1065
msgid ""
"See also the :ref:`same example <asyncio_example_create_subprocess_exec>` "
"written using high-level APIs."
msgstr ""
"Ver también el :ref:`same example <asyncio_example_create_subprocess_exec>`  "
"escrito con API de alto nivel."
