# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-23 17:40+0000\n"
"PO-Revision-Date: 2025-09-22 17:54+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Spanish (Spain) (https://app.transifex.com/python-doc/"
"teams/5390/es_ES/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es_ES\n"
"Plural-Forms: nplurals=3; plural=n == 1 ? 0 : n != 0 && n % 1000000 == 0 ? "
"1 : 2;\n"

#: ../../library/asyncio-protocol.rst:9
msgid "Transports and Protocols"
msgstr "Transportes y protocolos"

#: ../../library/asyncio-protocol.rst:12
msgid "Preface"
msgstr "Prefacio"

#: ../../library/asyncio-protocol.rst:13
msgid ""
"Transports and Protocols are used by the **low-level** event loop APIs such "
"as :meth:`loop.create_connection`.  They use callback-based programming "
"style and enable high-performance implementations of network or IPC "
"protocols (e.g. HTTP)."
msgstr ""
"Los transportes y protocolos son utilizados por las API de bucle de eventos "
"de **bajo nivel** como :meth:`loop.create_connection`.  Utilizan un estilo "
"de programación basado en llamadas de retorno y permiten implementaciones de "
"alto rendimiento de protocolos de red o IPC (por ejemplo, HTTP)."

#: ../../library/asyncio-protocol.rst:18
msgid ""
"Essentially, transports and protocols should only be used in libraries and "
"frameworks and never in high-level asyncio applications."
msgstr ""
"Esencialmente, los transportes y protocolos sólo deberían utilizarse en "
"bibliotecas y frameworks y nunca en aplicaciones asyncio de alto nivel."

#: ../../library/asyncio-protocol.rst:22
msgid "This documentation page covers both `Transports`_ and `Protocols`_."
msgstr ""
"Esta página de documentación abarca tanto `Transports`_ como `Protocols`_."

#: ../../library/asyncio-protocol.rst:25
msgid "Introduction"
msgstr "Introducción"

#: ../../library/asyncio-protocol.rst:26
msgid ""
"At the highest level, the transport is concerned with *how* bytes are "
"transmitted, while the protocol determines *which* bytes to transmit (and to "
"some extent when)."
msgstr ""
"Al más alto nivel, el transporte se ocupa de *how* se transmiten los bytes, "
"mientras que el protocolo determina *which* bytes transmitir (y hasta cierto "
"punto cuándo)."

#: ../../library/asyncio-protocol.rst:30
msgid ""
"A different way of saying the same thing: a transport is an abstraction for "
"a socket (or similar I/O endpoint) while a protocol is an abstraction for an "
"application, from the transport's point of view."
msgstr ""
"Una forma diferente de decir lo mismo: un transporte es una abstracción para "
"un socket (o punto final de E/S similar) mientras que un protocolo es una "
"abstracción para una aplicación, desde el punto de vista del transporte."

#: ../../library/asyncio-protocol.rst:35
msgid ""
"Yet another view is the transport and protocol interfaces together define an "
"abstract interface for using network I/O and interprocess I/O."
msgstr ""
"Otro punto de vista es que las interfaces de transporte y protocolo definen "
"conjuntamente una interfaz abstracta para utilizar la E/S de red y la E/S "
"entre procesos."

#: ../../library/asyncio-protocol.rst:39
msgid ""
"There is always a 1:1 relationship between transport and protocol objects: "
"the protocol calls transport methods to send data, while the transport calls "
"protocol methods to pass it data that has been received."
msgstr ""
"Siempre existe una relación 1:1 entre los objetos de transporte y protocolo: "
"el protocolo llama a los métodos de transporte para enviar datos, mientras "
"que el transporte llama a los métodos de protocolo para pasarle los datos "
"que ha recibido."

#: ../../library/asyncio-protocol.rst:44
msgid ""
"Most of connection oriented event loop methods (such as :meth:`loop."
"create_connection`) usually accept a *protocol_factory* argument used to "
"create a *Protocol* object for an accepted connection, represented by a "
"*Transport* object. Such methods usually return a tuple of ``(transport, "
"protocol)``."
msgstr ""
"La mayoría de los métodos de bucle de eventos orientados a conexión (como :"
"meth:`loop.create_connection`) suelen aceptar un argumento "
"*protocol_factory* utilizado para crear un objeto *Protocol* para una "
"conexión aceptada, representada por un objeto *Transport*. Tales métodos "
"normalmente devuelven una tupla de ``(transport, protocol)``."

#: ../../library/asyncio-protocol.rst:51
msgid "Contents"
msgstr "Contenido"

#: ../../library/asyncio-protocol.rst:52
msgid "This documentation page contains the following sections:"
msgstr "Esta página de documentación contiene las siguientes secciones:"

#: ../../library/asyncio-protocol.rst:54
msgid ""
"The `Transports`_ section documents asyncio :class:`BaseTransport`, :class:"
"`ReadTransport`, :class:`WriteTransport`, :class:`Transport`, :class:"
"`DatagramTransport`, and :class:`SubprocessTransport` classes."
msgstr ""
"La sección `Transports`_ documenta las clases asyncio :class:"
"`BaseTransport`, :class:`ReadTransport`, :class:`WriteTransport`, :class:"
"`Transport`, :class:`DatagramTransport`, y :class:`SubprocessTransport`."

#: ../../library/asyncio-protocol.rst:59
msgid ""
"The `Protocols`_ section documents asyncio :class:`BaseProtocol`, :class:"
"`Protocol`, :class:`BufferedProtocol`, :class:`DatagramProtocol`, and :class:"
"`SubprocessProtocol` classes."
msgstr ""
"La sección `Protocols`_ documenta las clases asyncio :class:`BaseProtocol`, :"
"class:`Protocol`, :class:`BufferedProtocol`, :class:`DatagramProtocol`, y :"
"class:`SubprocessProtocol`."

#: ../../library/asyncio-protocol.rst:63
msgid ""
"The `Examples`_ section showcases how to work with transports, protocols, "
"and low-level event loop APIs."
msgstr ""
"La sección `Examples`_ muestra cómo trabajar con transportes, protocolos y "
"APIs de bucle de eventos de bajo nivel."

#: ../../library/asyncio-protocol.rst:70
msgid "Transports"
msgstr "Transportes"

#: ../../library/asyncio-protocol.rst:72
msgid "**Source code:** :source:`Lib/asyncio/transports.py`"
msgstr "**Source code:** :source:`Lib/asyncio/transports.py`"

#: ../../library/asyncio-protocol.rst:76
msgid ""
"Transports are classes provided by :mod:`asyncio` in order to abstract "
"various kinds of communication channels."
msgstr ""
"Los transportes son clases proporcionadas por :mod:`asyncio` para abstraer "
"varios tipos de canales de comunicación."

#: ../../library/asyncio-protocol.rst:79
msgid ""
"Transport objects are always instantiated by an :ref:`asyncio event loop "
"<asyncio-event-loop>`."
msgstr ""
"Los objetos de transporte siempre se ejemplifican mediante :ref:`asyncio "
"event loop <asyncio-event-loop>`."

#: ../../library/asyncio-protocol.rst:82
msgid ""
"asyncio implements transports for TCP, UDP, SSL, and subprocess pipes. The "
"methods available on a transport depend on the transport's kind."
msgstr ""
"asyncio implementa transportes para TCP, UDP, SSL y tuberías de subprocesos. "
"Los métodos disponibles en un transporte dependen del tipo de transporte."

#: ../../library/asyncio-protocol.rst:85
msgid ""
"The transport classes are :ref:`not thread safe <asyncio-multithreading>`."
msgstr ""
"Las clases de transporte son :ref:`no thread safe <asyncio-multithreading>`."

#: ../../library/asyncio-protocol.rst:89
msgid "Transports Hierarchy"
msgstr "Jerarquía de transportes"

#: ../../library/asyncio-protocol.rst:93
msgid ""
"Base class for all transports.  Contains methods that all asyncio transports "
"share."
msgstr ""
"Clase base para todos los transportes.  Contiene métodos que comparten todos "
"los transportes asyncio."

#: ../../library/asyncio-protocol.rst:98
msgid "A base transport for write-only connections."
msgstr "Un transporte base para conexiones de sólo escritura."

#: ../../library/asyncio-protocol.rst:100
msgid ""
"Instances of the *WriteTransport* class are returned from the :meth:`loop."
"connect_write_pipe` event loop method and are also used by subprocess-"
"related methods like :meth:`loop.subprocess_exec`."
msgstr ""
"Las instancias de la clase *WriteTransport* son devueltas por el método de "
"bucle de eventos :meth:`loop.connect_write_pipe` y también son utilizadas "
"por métodos relacionados con subprocesos como :meth:`loop.subprocess_exec`."

#: ../../library/asyncio-protocol.rst:107
msgid "A base transport for read-only connections."
msgstr "Un transporte base para conexiones de sólo lectura."

#: ../../library/asyncio-protocol.rst:109
msgid ""
"Instances of the *ReadTransport* class are returned from the :meth:`loop."
"connect_read_pipe` event loop method and are also used by subprocess-related "
"methods like :meth:`loop.subprocess_exec`."
msgstr ""
"Las instancias de la clase *ReadTransport* se devuelven por el método de "
"bucle de eventos :meth:`loop.connect_read_pipe` y también se utilizan por "
"métodos relacionados con subprocesos como :meth:`loop.subprocess_exec`."

#: ../../library/asyncio-protocol.rst:116
msgid ""
"Interface representing a bidirectional transport, such as a TCP connection."
msgstr ""
"Interfaz que representa un transporte bidireccional, como una conexión TCP."

#: ../../library/asyncio-protocol.rst:119
msgid ""
"The user does not instantiate a transport directly; they call a utility "
"function, passing it a protocol factory and other information necessary to "
"create the transport and protocol."
msgstr ""
"El usuario no instanciará un transporte directamente, sino que llamará a una "
"función de utilidad, pasándole una fábrica de protocolos y otra información "
"necesaria para crear el transporte y el protocolo."

#: ../../library/asyncio-protocol.rst:123
msgid ""
"Instances of the *Transport* class are returned from or used by event loop "
"methods like :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.create_server`, :meth:`loop.sendfile`, "
"etc."
msgstr ""
"Las instancias de la clase *Transport* son devueltas o utilizadas por "
"métodos de bucle de eventos como :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.create_server`, :meth:`loop.sendfile`, "
"etc."

#: ../../library/asyncio-protocol.rst:131
msgid "A transport for datagram (UDP) connections."
msgstr "Un transporte para conexiones de datagramas (UDP)."

#: ../../library/asyncio-protocol.rst:133
msgid ""
"Instances of the *DatagramTransport* class are returned from the :meth:`loop."
"create_datagram_endpoint` event loop method."
msgstr ""
"Las instancias de la clase *DatagramTransport* se devuelven desde el método "
"de bucle de eventos :meth:`loop.create_datagram_endpoint`."

#: ../../library/asyncio-protocol.rst:139
msgid ""
"An abstraction to represent a connection between a parent and its child OS "
"process."
msgstr ""
"Una abstracción para representar una conexión entre un proceso OS padre y su "
"proceso OS hijo."

#: ../../library/asyncio-protocol.rst:142
msgid ""
"Instances of the *SubprocessTransport* class are returned from event loop "
"methods :meth:`loop.subprocess_shell` and :meth:`loop.subprocess_exec`."
msgstr ""
"Las instancias de la clase *SubprocessTransport* se devuelven desde los "
"métodos de bucle de eventos :meth:`loop.subprocess_shell` y :meth:`loop."
"subprocess_exec`."

#: ../../library/asyncio-protocol.rst:148
msgid "Base Transport"
msgstr "Transporte base"

#: ../../library/asyncio-protocol.rst:152
msgid "Close the transport."
msgstr "Cierra el transporte."

#: ../../library/asyncio-protocol.rst:154
msgid ""
"If the transport has a buffer for outgoing data, buffered data will be "
"flushed asynchronously.  No more data will be received.  After all buffered "
"data is flushed, the protocol's :meth:`protocol.connection_lost() "
"<BaseProtocol.connection_lost>` method will be called with :const:`None` as "
"its argument."
msgstr ""

#: ../../library/asyncio-protocol.rst:163
msgid "Return ``True`` if the transport is closing or is closed."
msgstr "Devuelve ``True`` si el transporte se está cerrando o está cerrado."

#: ../../library/asyncio-protocol.rst:167
msgid "Return information about the transport or underlying resources it uses."
msgstr ""
"Devuelve información sobre el transporte o los recursos subyacentes que "
"utiliza."

#: ../../library/asyncio-protocol.rst:170
msgid ""
"*name* is a string representing the piece of transport-specific information "
"to get."
msgstr ""
"*name* es una cadena que representa la información específica del transporte "
"que se desea obtener."

#: ../../library/asyncio-protocol.rst:173
msgid ""
"*default* is the value to return if the information is not available, or if "
"the transport does not support querying it with the given third-party event "
"loop implementation or on the current platform."
msgstr ""
"*default* es el valor a devolver si la información no está disponible, o si "
"el transporte no admite su consulta con la implementación de bucle de "
"eventos de terceros dada o en la plataforma actual."

#: ../../library/asyncio-protocol.rst:178
msgid ""
"For example, the following code attempts to get the underlying socket object "
"of the transport::"
msgstr ""
"Por ejemplo, el siguiente código intenta obtener el objeto socket subyacente "
"del transporte::"

#: ../../library/asyncio-protocol.rst:185
msgid "Categories of information that can be queried on some transports:"
msgstr ""
"Categorías de información que pueden consultarse en algunos transportes:"

#: ../../library/asyncio-protocol.rst:187
msgid "socket:"
msgstr "socket:"

#: ../../library/asyncio-protocol.rst:189
msgid ""
"``'peername'``: the remote address to which the socket is connected, result "
"of :meth:`socket.socket.getpeername` (``None`` on error)"
msgstr ""
"``'peername'``: la dirección remota a la que está conectado el socket, "
"resultado de :meth:`socket.socket.getpeername` (``None`` en caso de error)"

#: ../../library/asyncio-protocol.rst:193
msgid "``'socket'``: :class:`socket.socket` instance"
msgstr "``'socket'``: :class:`socket.socket` instancia"

#: ../../library/asyncio-protocol.rst:195
msgid ""
"``'sockname'``: the socket's own address, result of :meth:`socket.socket."
"getsockname`"
msgstr ""
"``'sockname'``: la propia dirección del socket, resultado de :meth:`socket."
"socket.getsockname`"

#: ../../library/asyncio-protocol.rst:198
msgid "SSL socket:"
msgstr "Socket SSL:"

#: ../../library/asyncio-protocol.rst:200
msgid ""
"``'compression'``: the compression algorithm being used as a string, or "
"``None`` if the connection isn't compressed; result of :meth:`ssl.SSLSocket."
"compression`"
msgstr ""
"``'compression'``: el algoritmo de compresión utilizado en forma de cadena, "
"o ``None`` si la conexión no está comprimida; resultado de :meth:`ssl."
"SSLSocket.compression`"

#: ../../library/asyncio-protocol.rst:204
msgid ""
"``'cipher'``: a three-value tuple containing the name of the cipher being "
"used, the version of the SSL protocol that defines its use, and the number "
"of secret bits being used; result of :meth:`ssl.SSLSocket.cipher`"
msgstr ""
"``'cipher'``: una tupla de tres valores que contiene el nombre del cifrado "
"que se está utilizando, la versión del protocolo SSL que define su uso y el "
"número de bits secretos que se están utilizando; resultado de :meth:`ssl."
"SSLSocket.cipher`"

#: ../../library/asyncio-protocol.rst:209
msgid ""
"``'peercert'``: peer certificate; result of :meth:`ssl.SSLSocket.getpeercert`"
msgstr ""
"``'peercert'``: certificado paritario; resultado de :meth:`ssl.SSLSocket."
"getpeercert`"

#: ../../library/asyncio-protocol.rst:212
msgid "``'sslcontext'``: :class:`ssl.SSLContext` instance"
msgstr "``'sslcontext'``: :class:`ssl.SSLContext` instancia"

#: ../../library/asyncio-protocol.rst:214
msgid ""
"``'ssl_object'``: :class:`ssl.SSLObject` or :class:`ssl.SSLSocket` instance"
msgstr ""
"``'ssl_object'``: :class:`ssl.SSLObject` o :class:`ssl.SSLSocket` instancia"

#: ../../library/asyncio-protocol.rst:217
msgid "pipe:"
msgstr "tubería:"

#: ../../library/asyncio-protocol.rst:219
msgid "``'pipe'``: pipe object"
msgstr "``'pipe'``: objeto tubería"

#: ../../library/asyncio-protocol.rst:221
msgid "subprocess:"
msgstr "subproceso:"

#: ../../library/asyncio-protocol.rst:223
msgid "``'subprocess'``: :class:`subprocess.Popen` instance"
msgstr "``'subprocess'``: :class:`subprocess.Popen` instancia"

#: ../../library/asyncio-protocol.rst:227
msgid "Set a new protocol."
msgstr "Establece un nuevo protocolo."

#: ../../library/asyncio-protocol.rst:229
msgid ""
"Switching protocol should only be done when both protocols are documented to "
"support the switch."
msgstr ""
"El cambio de protocolo sólo debe hacerse cuando ambos protocolos estén "
"documentados para soportar el cambio."

#: ../../library/asyncio-protocol.rst:234
msgid "Return the current protocol."
msgstr "Devuelve el protocolo actual."

#: ../../library/asyncio-protocol.rst:238
msgid "Read-only Transports"
msgstr "Transportes de sólo lectura"

#: ../../library/asyncio-protocol.rst:242
msgid "Return ``True`` if the transport is receiving new data."
msgstr "Devuelve ``True`` si el transporte está recibiendo nuevos datos."

#: ../../library/asyncio-protocol.rst:248
msgid ""
"Pause the receiving end of the transport.  No data will be passed to the "
"protocol's :meth:`protocol.data_received() <Protocol.data_received>` method "
"until :meth:`resume_reading` is called."
msgstr ""
"Pone en pausa el extremo receptor del transporte.  No se pasarán datos al "
"método :meth:`protocol.data_received() <Protocol.data_received>` del "
"protocolo hasta que se llame a :meth:`resume_reading`."

#: ../../library/asyncio-protocol.rst:252
msgid ""
"The method is idempotent, i.e. it can be called when the transport is "
"already paused or closed."
msgstr ""
"El método es idempotente, es decir, se puede llamar cuando el transporte ya "
"está en pausa o cerrado."

#: ../../library/asyncio-protocol.rst:258
msgid ""
"Resume the receiving end.  The protocol's :meth:`protocol.data_received() "
"<Protocol.data_received>` method will be called once again if some data is "
"available for reading."
msgstr ""
"Reanudar el extremo receptor.  Se volverá a llamar al método :meth:`protocol."
"data_received() <Protocol.data_received>` del protocolo si hay algún dato "
"disponible para leer."

#: ../../library/asyncio-protocol.rst:262
msgid ""
"The method is idempotent, i.e. it can be called when the transport is "
"already reading."
msgstr ""
"El método es idempotente, es decir, se puede llamar cuando transport ya está "
"leyendo."

#: ../../library/asyncio-protocol.rst:268
msgid "Write-only Transports"
msgstr "Transports de sólo escritura"

#: ../../library/asyncio-protocol.rst:272
msgid ""
"Close the transport immediately, without waiting for pending operations to "
"complete.  Buffered data will be lost.  No more data will be received. The "
"protocol's :meth:`protocol.connection_lost() <BaseProtocol.connection_lost>` "
"method will eventually be called with :const:`None` as its argument."
msgstr ""
"Cierre transport inmediatamente, sin esperar a que finalicen las operaciones "
"pendientes.  Se perderán los datos almacenados en el búfer.  No se recibirán "
"más datos. El método :meth:`protocol.connection_lost() <BaseProtocol."
"connection_lost>` del protocolo se llamará finalmente con :const:`None` como "
"argumento."

#: ../../library/asyncio-protocol.rst:280
msgid ""
"Return :const:`True` if the transport supports :meth:`~WriteTransport."
"write_eof`, :const:`False` if not."
msgstr ""
"Devuelve :const:`True` si transport admite :meth:`~WriteTransport."
"write_eof`, :const:`False` en caso contrario."

#: ../../library/asyncio-protocol.rst:285
msgid "Return the current size of the output buffer used by the transport."
msgstr "Devuelve el tamaño actual del búfer de salida utilizado por transport."

#: ../../library/asyncio-protocol.rst:289
msgid ""
"Get the *high* and *low* watermarks for write flow control. Return a tuple "
"``(low, high)`` where *low* and *high* are positive number of bytes."
msgstr ""
"Obtiene las marcas de agua *high* y *low* para el control de flujo de "
"escritura. Devuelve una tupla ``(low, high)`` donde *low* y *high* son "
"números positivos de bytes."

#: ../../library/asyncio-protocol.rst:293
msgid "Use :meth:`set_write_buffer_limits` to set the limits."
msgstr "Utilice :meth:`set_write_buffer_limits` para fijar los límites."

#: ../../library/asyncio-protocol.rst:299
msgid "Set the *high* and *low* watermarks for write flow control."
msgstr ""
"Establezca las marcas de agua *high* y *low* para el control del flujo de "
"escritura."

#: ../../library/asyncio-protocol.rst:301
msgid ""
"These two values (measured in number of bytes) control when the protocol's :"
"meth:`protocol.pause_writing() <BaseProtocol.pause_writing>` and :meth:"
"`protocol.resume_writing() <BaseProtocol.resume_writing>` methods are "
"called. If specified, the low watermark must be less than or equal to the "
"high watermark.  Neither *high* nor *low* can be negative."
msgstr ""
"Estos dos valores (medidos en número de bytes) controlan cuándo se llama a "
"los métodos :meth:`protocol.pause_writing() <BaseProtocol.pause_writing>` y :"
"meth:`protocol.resume_writing() <BaseProtocol.resume_writing>` del "
"protocolo. Si se especifica, la marca de agua low debe ser menor o igual que "
"la marca de agua high.  Ni *high* ni *low* pueden ser negativas."

#: ../../library/asyncio-protocol.rst:309
msgid ""
":meth:`~BaseProtocol.pause_writing` is called when the buffer size becomes "
"greater than or equal to the *high* value. If writing has been paused, :meth:"
"`~BaseProtocol.resume_writing` is called when the buffer size becomes less "
"than or equal to the *low* value."
msgstr ""
":meth:`~BaseProtocol.pause_writing` cuando el tamaño del búfer es mayor o "
"igual que el valor *high*. Si se ha detenido la escritura, se llama a :meth:"
"`~BaseProtocol.resume_writing` cuando el tamaño del búfer es menor o igual "
"que el valor *low*."

#: ../../library/asyncio-protocol.rst:314
msgid ""
"The defaults are implementation-specific.  If only the high watermark is "
"given, the low watermark defaults to an implementation-specific value less "
"than or equal to the high watermark.  Setting *high* to zero forces *low* to "
"zero as well, and causes :meth:`~BaseProtocol.pause_writing` to be called "
"whenever the buffer becomes non-empty.  Setting *low* to zero causes :meth:"
"`~BaseProtocol.resume_writing` to be called only once the buffer is empty. "
"Use of zero for either limit is generally sub-optimal as it reduces "
"opportunities for doing I/O and computation concurrently."
msgstr ""
"Los valores por defecto son específicos de cada aplicación.  Si sólo se "
"especifica la marca de agua high, la marca de agua low será por defecto un "
"valor específico de la implementación menor o igual que la marca de agua "
"high.  Establecer *high* a cero fuerza *low* a cero también, y hace que se "
"llame a :meth:`~BaseProtocol.pause_writing` siempre que el buffer no esté "
"vacío.  Establecer *low* a cero hace que :meth:`~BaseProtocol."
"resume_writing` se llame sólo una vez a que el buffer esté vacío. El uso de "
"cero para cualquiera de los límites es generalmente sub-óptimo ya que reduce "
"las oportunidades de hacer E/S y computación concurrentemente."

#: ../../library/asyncio-protocol.rst:325
msgid "Use :meth:`~WriteTransport.get_write_buffer_limits` to get the limits."
msgstr ""
"Usar :meth:`~WriteTransport.get_write_buffer_limits` para obtener los "
"límites."

#: ../../library/asyncio-protocol.rst:330
msgid "Write some *data* bytes to the transport."
msgstr "Escribir algunos bytes de *datos* en transport."

#: ../../library/asyncio-protocol.rst:332
#: ../../library/asyncio-protocol.rst:361
msgid ""
"This method does not block; it buffers the data and arranges for it to be "
"sent out asynchronously."
msgstr ""
"Este método no se bloquea; almacena los datos en la memoria intermedia y se "
"encarga de que se envíen de forma asíncrona."

#: ../../library/asyncio-protocol.rst:337
msgid ""
"Write a list (or any iterable) of data bytes to the transport. This is "
"functionally equivalent to calling :meth:`write` on each element yielded by "
"the iterable, but may be implemented more efficiently."
msgstr ""
"Escribe una lista (o cualquier iterable) de bytes de datos en transport. "
"Esto es funcionalmente equivalente a llamar a :meth:`write` en cada elemento "
"producido por el iterable, pero se puede implementar de manera más eficiente."

#: ../../library/asyncio-protocol.rst:344
msgid ""
"Close the write end of the transport after flushing all buffered data. Data "
"may still be received."
msgstr ""
"Cierra el extremo de escritura del transporte después de vaciar todos los "
"datos almacenados en el búfer. Es posible que se sigan recibiendo datos."

#: ../../library/asyncio-protocol.rst:347
msgid ""
"This method can raise :exc:`NotImplementedError` if the transport (e.g. SSL) "
"doesn't support half-closed connections."
msgstr ""
"Este método puede generar :exc:`NotImplementedError` si el transporte (por "
"ejemplo, SSL) no admite conexiones semicerradas."

#: ../../library/asyncio-protocol.rst:352
msgid "Datagram Transports"
msgstr "Transports de datagramas"

#: ../../library/asyncio-protocol.rst:356
msgid ""
"Send the *data* bytes to the remote peer given by *addr* (a transport-"
"dependent target address).  If *addr* is :const:`None`, the data is sent to "
"the target address given on transport creation."
msgstr ""
"Envía los bytes *data* al par remoto indicado por *addr* (una dirección de "
"destino dependiente del transporte).  Si *addr* es :const:`None`, los datos "
"se envían a la dirección de destino dada en la creación del transporte."

#: ../../library/asyncio-protocol.rst:366
msgid ""
"Close the transport immediately, without waiting for pending operations to "
"complete.  Buffered data will be lost. No more data will be received.  The "
"protocol's :meth:`protocol.connection_lost() <BaseProtocol.connection_lost>` "
"method will eventually be called with :const:`None` as its argument."
msgstr ""
"Cierre transport inmediatamente, sin esperar a que finalicen las operaciones "
"pendientes.  Se perderán los datos almacenados en el búfer. No se recibirán "
"más datos.  El :meth:`protocol.connection_lost()  <BaseProtocol."
"connection_lost>` del protocolo se llamará finalmente con :const:`None` como "
"argumento."

#: ../../library/asyncio-protocol.rst:376
msgid "Subprocess Transports"
msgstr "Subproceso Transports"

#: ../../library/asyncio-protocol.rst:380
msgid "Return the subprocess process id as an integer."
msgstr "Devuelve el id de proceso del subproceso como un entero."

#: ../../library/asyncio-protocol.rst:384
msgid ""
"Return the transport for the communication pipe corresponding to the integer "
"file descriptor *fd*:"
msgstr ""
"Devuelve el transporte de la tubería de comunicación correspondiente al "
"descriptor de fichero entero *fd*:"

#: ../../library/asyncio-protocol.rst:387
msgid ""
"``0``: readable streaming transport of the standard input (*stdin*), or :"
"const:`None` if the subprocess was not created with ``stdin=PIPE``"
msgstr ""
"``0``: transporte de flujo legible de la entrada estándar (*stdin*), o :"
"const:`None` si el subproceso no se creó con ``stdin=PIPE``"

#: ../../library/asyncio-protocol.rst:389
msgid ""
"``1``: writable streaming transport of the standard output (*stdout*), or :"
"const:`None` if the subprocess was not created with ``stdout=PIPE``"
msgstr ""
"``1``: transporte de flujo escribible de la salida estándar (*stdout*), o :"
"const:`None` si el subproceso no se creó con ``stdout=PIPE``"

#: ../../library/asyncio-protocol.rst:391
msgid ""
"``2``: writable streaming transport of the standard error (*stderr*), or :"
"const:`None` if the subprocess was not created with ``stderr=PIPE``"
msgstr ""
"``2``: transporte de flujo escribible del error estándar (*stderr*), o :"
"const:`None` si el subproceso no se creó con ``stderr=PIPE``"

#: ../../library/asyncio-protocol.rst:393
msgid "other *fd*: :const:`None`"
msgstr "otros *fd*: :const:`None`"

#: ../../library/asyncio-protocol.rst:397
msgid ""
"Return the subprocess return code as an integer or :const:`None` if it "
"hasn't returned, which is similar to the :attr:`subprocess.Popen.returncode` "
"attribute."
msgstr ""
"Devuelve el código de retorno del subproceso como un entero o :const:`None` "
"si no ha vuelto, que es similar al atributo :attr:`subprocess.Popen."
"returncode`."

#: ../../library/asyncio-protocol.rst:403
msgid "Kill the subprocess."
msgstr "Mata el subproceso."

#: ../../library/asyncio-protocol.rst:405
msgid ""
"On POSIX systems, the function sends SIGKILL to the subprocess. On Windows, "
"this method is an alias for :meth:`terminate`."
msgstr ""
"En sistemas POSIX, la función envía SIGKILL al subproceso. En Windows, este "
"método es un alias de :meth:`terminate`."

#: ../../library/asyncio-protocol.rst:408
msgid "See also :meth:`subprocess.Popen.kill`."
msgstr "Ver también :meth:`subprocess.Popen.kill`."

#: ../../library/asyncio-protocol.rst:412
msgid ""
"Send the *signal* number to the subprocess, as in :meth:`subprocess.Popen."
"send_signal`."
msgstr ""
"Envía el número de *señal* al subproceso, como en :meth:`subprocess.Popen."
"send_signal`."

#: ../../library/asyncio-protocol.rst:417
msgid "Stop the subprocess."
msgstr "Detener el subproceso."

#: ../../library/asyncio-protocol.rst:419
msgid ""
"On POSIX systems, this method sends SIGTERM to the subprocess. On Windows, "
"the Windows API function TerminateProcess() is called to stop the subprocess."
msgstr ""

#: ../../library/asyncio-protocol.rst:423
msgid "See also :meth:`subprocess.Popen.terminate`."
msgstr "Ver también :meth:`subprocess.Popen.terminate`."

#: ../../library/asyncio-protocol.rst:427
msgid "Kill the subprocess by calling the :meth:`kill` method."
msgstr "Mata el subproceso llamando al método :meth:`kill`."

#: ../../library/asyncio-protocol.rst:429
msgid ""
"If the subprocess hasn't returned yet, and close transports of *stdin*, "
"*stdout*, and *stderr* pipes."
msgstr ""
"Si el subproceso aún no ha regresado, y cerrar los transportes de tuberías "
"*stdin*, *stdout* y *stderr*."

#: ../../library/asyncio-protocol.rst:436
msgid "Protocols"
msgstr "Protocolos"

#: ../../library/asyncio-protocol.rst:438
msgid "**Source code:** :source:`Lib/asyncio/protocols.py`"
msgstr "**Código fuente:** :source:`Lib/asyncio/protocols.py`"

#: ../../library/asyncio-protocol.rst:442
msgid ""
"asyncio provides a set of abstract base classes that should be used to "
"implement network protocols.  Those classes are meant to be used together "
"with :ref:`transports <asyncio-transport>`."
msgstr ""
"asyncio proporciona un conjunto de clases base abstractas que deben "
"utilizarse para implementar protocolos de red.  Esas clases están pensadas "
"para ser utilizadas junto con :ref:`transports <asyncio-transport>`."

#: ../../library/asyncio-protocol.rst:446
msgid ""
"Subclasses of abstract base protocol classes may implement some or all "
"methods.  All these methods are callbacks: they are called by transports on "
"certain events, for example when some data is received. A base protocol "
"method should be called by the corresponding transport."
msgstr ""
"Las subclases de las clases de protocolo base abstractas pueden implementar "
"algunos o todos los métodos.  Todos estos métodos son retrollamadas: son "
"llamados por los transportes en determinados eventos, por ejemplo, cuando se "
"recibe algún dato. Un método de protocolo base debe ser llamado por el "
"transporte correspondiente."

#: ../../library/asyncio-protocol.rst:453
msgid "Base Protocols"
msgstr "Protocolos base"

#: ../../library/asyncio-protocol.rst:457
msgid "Base protocol with methods that all protocols share."
msgstr "Protocolo base con métodos que comparten todos los protocolos."

#: ../../library/asyncio-protocol.rst:461
msgid ""
"The base class for implementing streaming protocols (TCP, Unix sockets, etc)."
msgstr ""
"La clase base para implementar protocolos de streaming (TCP, sockets Unix, "
"etc)."

#: ../../library/asyncio-protocol.rst:466
msgid ""
"A base class for implementing streaming protocols with manual control of the "
"receive buffer."
msgstr ""
"Una clase base para implementar protocolos de streaming con control manual "
"del buffer de recepción."

#: ../../library/asyncio-protocol.rst:471
msgid "The base class for implementing datagram (UDP) protocols."
msgstr "La clase base para implementar protocolos de datagramas (UDP)."

#: ../../library/asyncio-protocol.rst:475
msgid ""
"The base class for implementing protocols communicating with child processes "
"(unidirectional pipes)."
msgstr ""
"La clase base para implementar protocolos que se comunican con procesos "
"hijos (tuberías unidireccionales)."

#: ../../library/asyncio-protocol.rst:480
msgid "Base Protocol"
msgstr "Protocolo base"

#: ../../library/asyncio-protocol.rst:482
msgid "All asyncio protocols can implement Base Protocol callbacks."
msgstr ""
"Todos los protocolos asyncio pueden implementar llamadas de retorno del "
"Protocolo Base."

#: ../../library/asyncio-protocol.rst:485
msgid "Connection Callbacks"
msgstr "Devoluciones de llamada de conexión"

#: ../../library/asyncio-protocol.rst:486
msgid ""
"Connection callbacks are called on all protocols, exactly once per a "
"successful connection.  All other protocol callbacks can only be called "
"between those two methods."
msgstr ""
"Las retrollamadas de conexión son llamadas en todos los protocolos, "
"exactamente una vez por cada conexión exitosa.  Todas las demás "
"retrollamadas de protocolo sólo pueden invocarse entre esos dos métodos."

#: ../../library/asyncio-protocol.rst:492
msgid "Called when a connection is made."
msgstr "Se activa cuando se establece una conexión."

#: ../../library/asyncio-protocol.rst:494
msgid ""
"The *transport* argument is the transport representing the connection.  The "
"protocol is responsible for storing the reference to its transport."
msgstr ""
"El argumento *transport* es el transporte que representa la conexión.  El "
"protocolo es responsable de almacenar la referencia a su transporte."

#: ../../library/asyncio-protocol.rst:500
msgid "Called when the connection is lost or closed."
msgstr "Llamada cuando la conexión se pierde o se cierra."

#: ../../library/asyncio-protocol.rst:502
msgid ""
"The argument is either an exception object or :const:`None`. The latter "
"means a regular EOF is received, or the connection was aborted or closed by "
"this side of the connection."
msgstr ""
"El argumento es un objeto de excepción o :const:`None`. Este último "
"significa que se ha recibido un EOF normal, o que la conexión ha sido "
"abortada o cerrada por este lado de la conexión."

#: ../../library/asyncio-protocol.rst:508
msgid "Flow Control Callbacks"
msgstr "Llamadas de retorno de control de flujo"

#: ../../library/asyncio-protocol.rst:509
msgid ""
"Flow control callbacks can be called by transports to pause or resume "
"writing performed by the protocol."
msgstr ""
"Las retrollamadas de control de flujo se pueden invocar por los transportes "
"para pausar o reanudar la escritura realizada por el protocolo."

#: ../../library/asyncio-protocol.rst:512
msgid ""
"See the documentation of the :meth:`~WriteTransport.set_write_buffer_limits` "
"method for more details."
msgstr ""
"Para más detalles, ver la documentación del método :meth:`~WriteTransport."
"set_write_buffer_limits`."

#: ../../library/asyncio-protocol.rst:517
msgid "Called when the transport's buffer goes over the high watermark."
msgstr ""
"Llamada cuando el buffer del transporte sobrepasa la marca de agua alta."

#: ../../library/asyncio-protocol.rst:521
msgid "Called when the transport's buffer drains below the low watermark."
msgstr ""
"Llamada cuando el buffer del transporte se vacía por debajo de la marca de "
"agua baja."

#: ../../library/asyncio-protocol.rst:523
msgid ""
"If the buffer size equals the high watermark, :meth:`~BaseProtocol."
"pause_writing` is not called: the buffer size must go strictly over."
msgstr ""
"Si el tamaño del búfer es igual a la filigrana digital alta, no se llama a :"
"meth:`~BaseProtocol.pause_writing`: el tamaño del búfer debe superarse "
"estrictamente."

#: ../../library/asyncio-protocol.rst:527
msgid ""
"Conversely, :meth:`~BaseProtocol.resume_writing` is called when the buffer "
"size is equal or lower than the low watermark.  These end conditions are "
"important to ensure that things go as expected when either mark is zero."
msgstr ""
"A la inversa, se llama a :meth:`~BaseProtocol.resume_writing` cuando el "
"tamaño del búfer es igual o inferior a la filigrana digital baja.  Estas "
"condiciones finales son importantes para asegurar que las cosas van como se "
"espera cuando cualquiera de las marcas es cero."

#: ../../library/asyncio-protocol.rst:534
msgid "Streaming Protocols"
msgstr "Protocolos de streaming"

#: ../../library/asyncio-protocol.rst:536
msgid ""
"Event methods, such as :meth:`loop.create_server`, :meth:`loop."
"create_unix_server`, :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.connect_accepted_socket`, :meth:`loop."
"connect_read_pipe`, and :meth:`loop.connect_write_pipe` accept factories "
"that return streaming protocols."
msgstr ""
"Los métodos de eventos, como :meth:`loop.create_server`, :meth:`loop."
"create_unix_server`, :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.connect_accepted_socket`, :meth:`loop."
"connect_read_pipe`, y :meth:`loop.connect_write_pipe` aceptan fábricas que "
"devuelven protocolos de streaming."

#: ../../library/asyncio-protocol.rst:544
msgid ""
"Called when some data is received.  *data* is a non-empty bytes object "
"containing the incoming data."
msgstr ""
"Se ejecuta cuando se reciben datos.  *data* es un objeto bytes no vacío que "
"contiene los datos recibidos."

#: ../../library/asyncio-protocol.rst:547
msgid ""
"Whether the data is buffered, chunked or reassembled depends on the "
"transport.  In general, you shouldn't rely on specific semantics and instead "
"make your parsing generic and flexible. However, data is always received in "
"the correct order."
msgstr ""
"Que los datos se almacenen en búfer, en trozos o se reensamblen depende del "
"transporte.  En general, no se debe depender de una semántica específica y, "
"en su lugar, hacer que el análisis sintáctico sea genérico y flexible. Sin "
"embargo, los datos siempre se reciben en el orden correcto."

#: ../../library/asyncio-protocol.rst:552
msgid ""
"The method can be called an arbitrary number of times while a connection is "
"open."
msgstr ""
"El método se puede llamar un número arbitrario de veces mientras una "
"conexión está abierta."

#: ../../library/asyncio-protocol.rst:555
msgid ""
"However, :meth:`protocol.eof_received() <Protocol.eof_received>` is called "
"at most once.  Once `eof_received()` is called, ``data_received()`` is not "
"called anymore."
msgstr ""

#: ../../library/asyncio-protocol.rst:561
msgid ""
"Called when the other end signals it won't send any more data (for example "
"by calling :meth:`transport.write_eof() <WriteTransport.write_eof>`, if the "
"other end also uses asyncio)."
msgstr ""
"Llamada cuando el otro extremo señala que no enviará más datos (por ejemplo "
"llamando a :meth:`transport.write_eof() <WriteTransport.write_eof>`, si el "
"otro extremo también utiliza asyncio)."

#: ../../library/asyncio-protocol.rst:566
msgid ""
"This method may return a false value (including ``None``), in which case the "
"transport will close itself.  Conversely, if this method returns a true "
"value, the protocol used determines whether to close the transport. Since "
"the default implementation returns ``None``, it implicitly closes the "
"connection."
msgstr ""
"Este método puede devolver un valor falso (incluyendo ``None``), en cuyo "
"caso el transporte se cerrará por sí mismo.  Por el contrario, si este "
"método devuelve un valor verdadero, el protocolo utilizado determina si se "
"cierra el transporte. Dado que la implementación por defecto devuelve "
"``None``, implícitamente cierra la conexión."

#: ../../library/asyncio-protocol.rst:572
msgid ""
"Some transports, including SSL, don't support half-closed connections, in "
"which case returning true from this method will result in the connection "
"being closed."
msgstr ""
"Algunos transportes, incluyendo SSL, no soportan conexiones semicerradas, en "
"cuyo caso devolver true desde este método resultará en el cierre de la "
"conexión."

#: ../../library/asyncio-protocol.rst:577
#: ../../library/asyncio-protocol.rst:635
msgid "State machine:"
msgstr "Máquina de estados:"

#: ../../library/asyncio-protocol.rst:588
msgid "Buffered Streaming Protocols"
msgstr "Protocolos de transmisión en búfer"

#: ../../library/asyncio-protocol.rst:592
msgid ""
"Buffered Protocols can be used with any event loop method that supports "
"`Streaming Protocols`_."
msgstr ""
"Los protocolos en búfer pueden utilizarse con cualquier método de bucle de "
"eventos que admita `Streaming Protocols`_."

#: ../../library/asyncio-protocol.rst:595
msgid ""
"``BufferedProtocol`` implementations allow explicit manual allocation and "
"control of the receive buffer.  Event loops can then use the buffer provided "
"by the protocol to avoid unnecessary data copies.  This can result in "
"noticeable performance improvement for protocols that receive big amounts of "
"data.  Sophisticated protocol implementations can significantly reduce the "
"number of buffer allocations."
msgstr ""
"``BufferedProtocol`` permiten la asignación manual explícita y el control "
"del búfer de recepción.  Los bucles de eventos pueden entonces utilizar el "
"búfer proporcionado por el protocolo para evitar copias innecesarias de "
"datos.  Esto puede mejorar notablemente el rendimiento de los protocolos que "
"reciben grandes cantidades de datos.  Las implementaciones sofisticadas de "
"protocolos pueden reducir significativamente el número de asignaciones de "
"búfer."

#: ../../library/asyncio-protocol.rst:602
msgid ""
"The following callbacks are called on :class:`BufferedProtocol` instances:"
msgstr ""
"Las siguientes llamadas de retorno se ejecutan en las instancias de :class:"
"`BufferedProtocol`:"

#: ../../library/asyncio-protocol.rst:607
msgid "Called to allocate a new receive buffer."
msgstr "Llamada para asignar un nuevo búfer de recepción."

#: ../../library/asyncio-protocol.rst:609
msgid ""
"*sizehint* is the recommended minimum size for the returned buffer.  It is "
"acceptable to return smaller or larger buffers than what *sizehint* "
"suggests.  When set to -1, the buffer size can be arbitrary. It is an error "
"to return a buffer with a zero size."
msgstr ""
"*sizehint* es el tamaño mínimo recomendado para el búfer devuelto.  Es "
"aceptable devolver búferes más pequeños o más grandes que lo que *sizehint* "
"sugiere.  Cuando se establece a -1, el tamaño del búfer puede ser "
"arbitrario. Es un error devolver un buffer con tamaño cero."

#: ../../library/asyncio-protocol.rst:614
msgid ""
"``get_buffer()`` must return an object implementing the :ref:`buffer "
"protocol <bufferobjects>`."
msgstr ""
"``get_buffer()`` debe devolver un objeto que implemente :ref:`buffer "
"protocol <bufferobjects>`."

#: ../../library/asyncio-protocol.rst:619
msgid "Called when the buffer was updated with the received data."
msgstr "Llamada cuando se actualizó el buffer con los datos recibidos."

#: ../../library/asyncio-protocol.rst:621
msgid "*nbytes* is the total number of bytes that were written to the buffer."
msgstr "*nbytes* es el número total de bytes que se han escrito en el búfer."

#: ../../library/asyncio-protocol.rst:625
msgid ""
"See the documentation of the :meth:`protocol.eof_received() <Protocol."
"eof_received>` method."
msgstr ""
"Ver la documentación del método :meth:`protocol.eof_received() <Protocol."
"eof_received>`."

#: ../../library/asyncio-protocol.rst:629
msgid ""
":meth:`~BufferedProtocol.get_buffer` can be called an arbitrary number of "
"times during a connection.  However, :meth:`protocol.eof_received() "
"<Protocol.eof_received>` is called at most once and, if called, :meth:"
"`~BufferedProtocol.get_buffer` and :meth:`~BufferedProtocol.buffer_updated` "
"won't be called after it."
msgstr ""
":meth:`~BufferedProtocol.get_buffer` puede ser llamado un número arbitrario "
"de veces durante una conexión.  Sin embargo, :meth:`protocol.eof_received() "
"<Protocol.eof_received>` se llama como máximo una vez y, si se llama, :meth:"
"`~BufferedProtocol.get_buffer` y :meth:`~BufferedProtocol.buffer_updated` no "
"se llamarán después."

#: ../../library/asyncio-protocol.rst:648
msgid "Datagram Protocols"
msgstr "Protocolos de datagramas"

#: ../../library/asyncio-protocol.rst:650
msgid ""
"Datagram Protocol instances should be constructed by protocol factories "
"passed to the :meth:`loop.create_datagram_endpoint` method."
msgstr ""
"Las instancias del Protocolo de Datagramas deben ser construidas por "
"fábricas de protocolo pasadas al método :meth:`loop."
"create_datagram_endpoint`."

#: ../../library/asyncio-protocol.rst:655
msgid ""
"Called when a datagram is received.  *data* is a bytes object containing the "
"incoming data.  *addr* is the address of the peer sending the data; the "
"exact format depends on the transport."
msgstr ""
"Se ejecuta cuando se recibe un datagrama.  *data* es un objeto bytes que "
"contiene los datos entrantes.  *addr* es la dirección del par que envía los "
"datos; el formato exacto depende del transporte."

#: ../../library/asyncio-protocol.rst:661
msgid ""
"Called when a previous send or receive operation raises an :class:"
"`OSError`.  *exc* is the :class:`OSError` instance."
msgstr ""
"Llamada cuando una operación previa de envío o recepción genera un :class:"
"`OSError`.  *exc* es la instancia de :class:`OSError`."

#: ../../library/asyncio-protocol.rst:664
msgid ""
"This method is called in rare conditions, when the transport (e.g. UDP) "
"detects that a datagram could not be delivered to its recipient. In many "
"conditions though, undeliverable datagrams will be silently dropped."
msgstr ""
"Este método se ejecuta en raras ocasiones, cuando el transporte (por "
"ejemplo, UDP) detecta que un datagrama no ha podido entregarse a su "
"destinatario. Sin embargo, en muchos casos, los datagramas que no se pueden "
"entregar se descartan silenciosamente."

#: ../../library/asyncio-protocol.rst:671
msgid ""
"On BSD systems (macOS, FreeBSD, etc.) flow control is not supported for "
"datagram protocols, because there is no reliable way to detect send failures "
"caused by writing too many packets."
msgstr ""
"En sistemas BSD (macOS, FreeBSD, etc.) el control de flujo no está soportado "
"para protocolos de datagramas, porque no hay una forma fiable de detectar "
"fallos de envío causados por la escritura de demasiados paquetes."

#: ../../library/asyncio-protocol.rst:675
msgid ""
"The socket always appears 'ready' and excess packets are dropped. An :class:"
"`OSError` with ``errno`` set to :const:`errno.ENOBUFS` may or may not be "
"raised; if it is raised, it will be reported to :meth:`DatagramProtocol."
"error_received` but otherwise ignored."
msgstr ""
"El socket siempre aparece 'ready' y los paquetes sobrantes se descartan. Un :"
"class:`OSError` con ``errno`` ajustado a :const:`errno.ENOBUFS` puede o no "
"ser levantado; si es levantado, será reportado a :meth:`DatagramProtocol."
"error_received` pero de lo contrario será ignorado."

#: ../../library/asyncio-protocol.rst:684
msgid "Subprocess Protocols"
msgstr "Protocolos de subprocesos"

#: ../../library/asyncio-protocol.rst:686
msgid ""
"Subprocess Protocol instances should be constructed by protocol factories "
"passed to the :meth:`loop.subprocess_exec` and :meth:`loop.subprocess_shell` "
"methods."
msgstr ""
"Las instancias de Protocolo de Subproceso deben construirse por la "
"automatización de protocolos pasadas a los métodos :meth:`loop."
"subprocess_exec` y :meth:`loop.subprocess_shell`."

#: ../../library/asyncio-protocol.rst:692
msgid ""
"Called when the child process writes data into its stdout or stderr pipe."
msgstr ""
"Llamada cuando el proceso hijo escribe datos en su tubería stdout o stderr."

#: ../../library/asyncio-protocol.rst:695
msgid "*fd* is the integer file descriptor of the pipe."
msgstr "*fd* es el descriptor de fichero entero de la tubería."

#: ../../library/asyncio-protocol.rst:697
msgid "*data* is a non-empty bytes object containing the received data."
msgstr "*data* es un objeto bytes no vacío que contiene los datos recibidos."

#: ../../library/asyncio-protocol.rst:701
msgid ""
"Called when one of the pipes communicating with the child process is closed."
msgstr ""
"Llamada cuando se cierra una de las tuberías que comunica con el proceso "
"hijo."

#: ../../library/asyncio-protocol.rst:704
msgid "*fd* is the integer file descriptor that was closed."
msgstr "*fd* es el descriptor de archivo entero que se cerró."

#: ../../library/asyncio-protocol.rst:708
msgid "Called when the child process has exited."
msgstr "Llamada cuando el proceso hijo ha salido."

#: ../../library/asyncio-protocol.rst:712
msgid "Examples"
msgstr "Ejemplos"

#: ../../library/asyncio-protocol.rst:717
msgid "TCP Echo Server"
msgstr "Servidor Eco TCP"

#: ../../library/asyncio-protocol.rst:719
msgid ""
"Create a TCP echo server using the :meth:`loop.create_server` method, send "
"back received data, and close the connection::"
msgstr ""
"Crear un servidor eco TCP utilizando el método :meth:`loop.create_server`, "
"devolver los datos recibidos y cerrar la conexión::"

#: ../../library/asyncio-protocol.rst:760
msgid ""
"The :ref:`TCP echo server using streams <asyncio-tcp-echo-server-streams>` "
"example uses the high-level :func:`asyncio.start_server` function."
msgstr ""
"El ejemplo :ref:`TCP echo server using streams <asyncio-tcp-echo-server-"
"streams>` utiliza la función de alto nivel :func:`asyncio.start_server`."

#: ../../library/asyncio-protocol.rst:766
msgid "TCP Echo Client"
msgstr "Cliente Eco TCP"

#: ../../library/asyncio-protocol.rst:768
msgid ""
"A TCP echo client using the :meth:`loop.create_connection` method, sends "
"data, and waits until the connection is closed::"
msgstr ""
"Un cliente eco TCP que utiliza el método :meth:`loop.create_connection`, "
"envía datos y espera a que se cierre la conexión::"

#: ../../library/asyncio-protocol.rst:816
msgid ""
"The :ref:`TCP echo client using streams <asyncio-tcp-echo-client-streams>` "
"example uses the high-level :func:`asyncio.open_connection` function."
msgstr ""
"El ejemplo :ref:`TCP echo client using streams <asyncio-tcp-echo-client-"
"streams>` utiliza la función de alto nivel :func:`asyncio.open_connection`."

#: ../../library/asyncio-protocol.rst:823
msgid "UDP Echo Server"
msgstr "Servidor Eco UDP"

#: ../../library/asyncio-protocol.rst:825
msgid ""
"A UDP echo server, using the :meth:`loop.create_datagram_endpoint` method, "
"sends back received data::"
msgstr ""
"Un servidor eco UDP, utilizando el método :meth:`loop."
"create_datagram_endpoint`, devuelve los datos recibidos::"

#: ../../library/asyncio-protocol.rst:867
msgid "UDP Echo Client"
msgstr "Cliente Eco UDP"

#: ../../library/asyncio-protocol.rst:869
msgid ""
"A UDP echo client, using the :meth:`loop.create_datagram_endpoint` method, "
"sends data and closes the transport when it receives the answer::"
msgstr ""
"Un cliente eco UDP, utilizando el método :meth:`loop."
"create_datagram_endpoint`, envía datos y cierra el transporte cuando recibe "
"la respuesta::"

#: ../../library/asyncio-protocol.rst:924
msgid "Connecting Existing Sockets"
msgstr "Conexión de tomas existentes"

#: ../../library/asyncio-protocol.rst:926
msgid ""
"Wait until a socket receives data using the :meth:`loop.create_connection` "
"method with a protocol::"
msgstr ""
"Esperar hasta que un socket recibe datos utilizando el método :meth:`loop."
"create_connection` con un protocolo::"

#: ../../library/asyncio-protocol.rst:980
msgid ""
"The :ref:`watch a file descriptor for read events "
"<asyncio_example_watch_fd>` example uses the low-level :meth:`loop."
"add_reader` method to register an FD."
msgstr ""
"El ejemplo :ref:`watch a file descriptor for read events "
"<asyncio_example_watch_fd>` utiliza el método de bajo nivel :meth:`loop."
"add_reader` para registrar un FD."

#: ../../library/asyncio-protocol.rst:984
msgid ""
"The :ref:`register an open socket to wait for data using streams "
"<asyncio_example_create_connection-streams>` example uses high-level streams "
"created by the :func:`open_connection` function in a coroutine."
msgstr ""
"El ejemplo :ref:`register an open socket to wait for data using streams "
"<asyncio_example_create_connection-streams>` utiliza flujos de alto nivel "
"creados por la función :func:`open_connection` en una corrutina."

#: ../../library/asyncio-protocol.rst:991
msgid "loop.subprocess_exec() and SubprocessProtocol"
msgstr "loop.subprocess_exec() y SubprocessProtocol"

#: ../../library/asyncio-protocol.rst:993
msgid ""
"An example of a subprocess protocol used to get the output of a subprocess "
"and to wait for the subprocess exit."
msgstr ""
"Un ejemplo de protocolo de subproceso utilizado para obtener la salida de un "
"subproceso y esperar la salida del subproceso."

#: ../../library/asyncio-protocol.rst:996
msgid "The subprocess is created by the :meth:`loop.subprocess_exec` method::"
msgstr ""
"Se crea el subproceso mediante el método :meth:`loop.subprocess_exec`::"

#: ../../library/asyncio-protocol.rst:1042
msgid ""
"See also the :ref:`same example <asyncio_example_create_subprocess_exec>` "
"written using high-level APIs."
msgstr ""
"Ver también el :ref:`same example <asyncio_example_create_subprocess_exec>`  "
"escrito con API de alto nivel."
