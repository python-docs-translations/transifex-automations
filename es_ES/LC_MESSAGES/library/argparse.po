# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# eulalio barbero espinosa <eulalio@disroot.org>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-03-14 14:53+0000\n"
"PO-Revision-Date: 2024-05-11 00:33+0000\n"
"Last-Translator: eulalio barbero espinosa <eulalio@disroot.org>, 2025\n"
"Language-Team: Spanish (Spain) (https://app.transifex.com/python-doc/"
"teams/5390/es_ES/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es_ES\n"
"Plural-Forms: nplurals=3; plural=n == 1 ? 0 : n != 0 && n % 1000000 == 0 ? "
"1 : 2;\n"

#: ../../library/argparse.rst:2
msgid ""
":mod:`!argparse` --- Parser for command-line options, arguments and "
"subcommands"
msgstr ""
":mod:`!argparse` --- Analizador sintáctico de opciones, argumentos y "
"subcomandos de línea de comandos"

#: ../../library/argparse.rst:12
msgid "**Source code:** :source:`Lib/argparse.py`"
msgstr "**Código fuente:** :source:`Lib/argparse.py`"

#: ../../library/argparse.rst-1
msgid "Tutorial"
msgstr "Tutorial"

#: ../../library/argparse.rst:18
msgid ""
"This page contains the API reference information. For a more gentle "
"introduction to Python command-line parsing, have a look at the :ref:"
"`argparse tutorial <argparse-tutorial>`."
msgstr ""
"Esta página contiene la información de referencia de la API. Para una "
"introducción más suave al análisis sintáctico de la línea de comandos de "
"Python, eche un vistazo al tutorial :ref:`argparse <argparse-tutorial>`."

#: ../../library/argparse.rst:22
msgid ""
"The :mod:`!argparse` module makes it easy to write user-friendly command-"
"line interfaces. The program defines what arguments it requires, and :mod:`!"
"argparse` will figure out how to parse those out of :data:`sys.argv`.  The :"
"mod:`!argparse` module also automatically generates help and usage "
"messages.  The module will also issue errors when users give the program "
"invalid arguments."
msgstr ""
"El módulo :mod:`!argparse` facilita la escritura de interfaces de línea de "
"comandos fáciles de usar. El programa define los argumentos que necesita y :"
"mod:`!argparse` los extrae de :data:`sys.argv`. El módulo :mod:`!argparse` "
"también genera automáticamente mensajes de ayuda y de uso.  El módulo "
"también emitirá errores cuando los usuarios den al programa argumentos no "
"válidos."

#: ../../library/argparse.rst:28
msgid ""
"The :mod:`!argparse` module's support for command-line interfaces is built "
"around an instance of :class:`argparse.ArgumentParser`.  It is a container "
"for argument specifications and has options that apply to the parser as "
"whole::"
msgstr ""
"El soporte del módulo :mod:`!argparse` para interfaces de línea de comandos "
"se construye alrededor de una instancia de :class:`argparse.ArgumentParser`. "
"Es un contenedor para especificaciones de argumentos y tiene opciones que se "
"aplican al analizador sintáctico en su conjunto::"

#: ../../library/argparse.rst:32
msgid ""
"parser = argparse.ArgumentParser(\n"
"                    prog='ProgramName',\n"
"                    description='What the program does',\n"
"                    epilog='Text at the bottom of help')"
msgstr ""
"parser = argparse.ArgumentParser(\n"
"                    prog='ProgramName',\n"
"                    description='What the program does',\n"
"                    epilog='Text at the bottom of help')"

#: ../../library/argparse.rst:37
msgid ""
"The :meth:`ArgumentParser.add_argument` method attaches individual argument "
"specifications to the parser.  It supports positional arguments, options "
"that accept values, and on/off flags::"
msgstr ""
"El método :meth:`ArgumentParser.add_argument` adjunta especificaciones de "
"argumentos individuales al analizador sintáctico.  Admite argumentos "
"posicionales, opciones que aceptan valores y banderas on/off::"

#: ../../library/argparse.rst:41
msgid ""
"parser.add_argument('filename')           # positional argument\n"
"parser.add_argument('-c', '--count')      # option that takes a value\n"
"parser.add_argument('-v', '--verbose',\n"
"                    action='store_true')  # on/off flag"
msgstr ""
"parser.add_argument('filename') # argumento posicional\n"
"parser.add_argument('-c', '--count') # opción que toma un valor\n"
"parser.add_argument('-v', '--verbose',\n"
"                    action='store_true') # bandera on/off"

#: ../../library/argparse.rst:46
msgid ""
"The :meth:`ArgumentParser.parse_args` method runs the parser and places the "
"extracted data in a :class:`argparse.Namespace` object::"
msgstr ""
"El método :meth:`ArgumentParser.parse_args` ejecuta el analizador sintáctico "
"y coloca los datos extraídos en un objeto :class:`argparse.Namespace`::"

#: ../../library/argparse.rst:49
msgid ""
"args = parser.parse_args()\n"
"print(args.filename, args.count, args.verbose)"
msgstr ""
"args = parser.parse_args()\n"
"print(args.filename, args.count, args.verbose)"

#: ../../library/argparse.rst:53
msgid ""
"If you're looking for a guide about how to upgrade :mod:`optparse` code to :"
"mod:`!argparse`, see :ref:`Upgrading Optparse Code <upgrading-optparse-"
"code>`."
msgstr ""
"Si busca una guía sobre cómo actualizar el código :mod:`optparse` a :mod:`!"
"argparse`, consulte :ref:`Upgrading Optparse Code <upgrading-optparse-code>`."

#: ../../library/argparse.rst:57
msgid "ArgumentParser objects"
msgstr "Objetos ArgumentParser"

#: ../../library/argparse.rst:66
msgid ""
"Create a new :class:`ArgumentParser` object. All parameters should be passed "
"as keyword arguments. Each parameter has its own more detailed description "
"below, but in short they are:"
msgstr ""
"Crea un nuevo objeto :class:`ArgumentParser`. Todos los parámetros deben "
"pasarse como argumentos de palabra clave. Cada parámetro tiene su propia "
"descripción más detallada a continuación, pero en resumen son:"

#: ../../library/argparse.rst:70
msgid ""
"prog_ - The name of the program (default: ``os.path.basename(sys.argv[0])``)"
msgstr ""
"prog_ - El nombre del programa (por defecto: ``os.path.basename(sys."
"argv[0])``)"

#: ../../library/argparse.rst:73
msgid ""
"usage_ - The string describing the program usage (default: generated from "
"arguments added to parser)"
msgstr ""
"usage_ - La cadena que describe el uso del programa (por defecto: generada a "
"partir de los argumentos añadidos al analizador sintáctico)"

#: ../../library/argparse.rst:76
msgid ""
"description_ - Text to display before the argument help (by default, no text)"
msgstr ""
"description_ - Texto a mostrar antes del argumento help (por defecto, sin "
"texto)"

#: ../../library/argparse.rst:79
msgid "epilog_ - Text to display after the argument help (by default, no text)"
msgstr ""
"epilog_ - Texto a mostrar después del argumento help (por defecto, sin texto)"

#: ../../library/argparse.rst:81
msgid ""
"parents_ - A list of :class:`ArgumentParser` objects whose arguments should "
"also be included"
msgstr ""
"parents_ - Una lista de objetos :class:`ArgumentParser` cuyos argumentos "
"también deben incluirse"

#: ../../library/argparse.rst:84
msgid "formatter_class_ - A class for customizing the help output"
msgstr "formatter_class_ - Una clase para personalizar la salida de ayuda"

#: ../../library/argparse.rst:86
msgid ""
"prefix_chars_ - The set of characters that prefix optional arguments "
"(default: '-')"
msgstr ""
"prefix_chars_ - Conjunto de caracteres que preceden a los argumentos "
"opcionales (por defecto: '-')"

#: ../../library/argparse.rst:89
msgid ""
"fromfile_prefix_chars_ - The set of characters that prefix files from which "
"additional arguments should be read (default: ``None``)"
msgstr ""
"fromfile_prefix_chars_ - El conjunto de caracteres que prefijan los archivos "
"de los que deben leerse argumentos adicionales (por defecto: ``None``)"

#: ../../library/argparse.rst:92
msgid ""
"argument_default_ - The global default value for arguments (default: "
"``None``)"
msgstr ""
"argument_default_ - El valor global por defecto para los argumentos (por "
"defecto: ``None``)"

#: ../../library/argparse.rst:95
msgid ""
"conflict_handler_ - The strategy for resolving conflicting optionals "
"(usually unnecessary)"
msgstr ""
"conflict_handler_ - La estrategia para resolver opcionales en conflicto "
"(normalmente innecesaria)"

#: ../../library/argparse.rst:98
msgid ""
"add_help_ - Add a ``-h/--help`` option to the parser (default: ``True``)"
msgstr ""
"add_help_ - Añadir una opción ``-h/--help`` al analizador sintáctico (por "
"defecto: ``True``)"

#: ../../library/argparse.rst:100
msgid ""
"allow_abbrev_ - Allows long options to be abbreviated if the abbreviation is "
"unambiguous. (default: ``True``)"
msgstr ""
"allow_abbrev_ - Permite abreviar opciones largas si la abreviatura no es "
"ambigua. (por defecto: ``True``)"

#: ../../library/argparse.rst:103
msgid ""
"exit_on_error_ - Determines whether or not :class:`!ArgumentParser` exits "
"with error info when an error occurs. (default: ``True``)"
msgstr ""
"exit_on_error_ - Determina si :class:`!ArgumentParser` sale o no con "
"información de error cuando se produce un error. (por defecto: ``True``)"

#: ../../library/argparse.rst:106
msgid "*allow_abbrev* parameter was added."
msgstr "Se ha añadido el parámetro *allow_abbrev*."

#: ../../library/argparse.rst:109
msgid ""
"In previous versions, *allow_abbrev* also disabled grouping of short flags "
"such as ``-vv`` to mean ``-v -v``."
msgstr ""
"En versiones anteriores, *allow_abbrev* también desactivaba la agrupación de "
"banderas cortas como ``-vv`` para significar ``-v -v``."

#: ../../library/argparse.rst:113
msgid "*exit_on_error* parameter was added."
msgstr "Se ha añadido el parámetro *exit_on_error*."

#: ../../library/argparse.rst:116 ../../library/argparse.rst:596
msgid "The following sections describe how each of these are used."
msgstr ""
"En los siguientes apartados se describe cómo se utiliza cada uno de ellos."

#: ../../library/argparse.rst:122
msgid "prog"
msgstr "prog"

#: ../../library/argparse.rst:125
msgid ""
"By default, :class:`ArgumentParser` calculates the name of the program to "
"display in help messages depending on the way the Python interpreter was run:"
msgstr ""
"Por defecto, :class:`ArgumentParser` calcula el nombre del programa que se "
"mostrará en los mensajes de ayuda en función de cómo se haya ejecutado el "
"intérprete de Python:"

#: ../../library/argparse.rst:128
msgid ""
"The :func:`base name <os.path.basename>` of ``sys.argv[0]`` if a file was "
"passed as argument."
msgstr ""
"La :func:`base name <os.path.basename>` de ``sys.argv[0]`` si se pasó un "
"archivo como argumento."

#: ../../library/argparse.rst:130
msgid ""
"The Python interpreter name followed by ``sys.argv[0]`` if a directory or a "
"zipfile was passed as argument."
msgstr ""
"El nombre del intérprete de Python seguido de ``sys.argv[0]`` si se ha "
"pasado un directorio o un archivo zip como argumento."

#: ../../library/argparse.rst:132
msgid ""
"The Python interpreter name followed by ``-m`` followed by the module or "
"package name if the :option:`-m` option was used."
msgstr ""
"El nombre del intérprete de Python seguido de ``-m`` seguido del nombre del "
"módulo o paquete si se ha utilizado la opción :option:`-m`."

#: ../../library/argparse.rst:135
msgid ""
"This default is almost always desirable because it will make the help "
"messages match the string that was used to invoke the program on the command "
"line. However, to change this default behavior, another value can be "
"supplied using the ``prog=`` argument to :class:`ArgumentParser`::"
msgstr ""
"Este valor por defecto es casi siempre deseable porque hará que los mensajes "
"de ayuda coincidan con la cadena que se utilizó para invocar el programa en "
"la línea de comandos. Sin embargo, para cambiar este comportamiento por "
"defecto, se puede proporcionar otro valor utilizando el argumento ``prog=`` "
"a :class:`ArgumentParser`::"

#: ../../library/argparse.rst:140
msgid ""
">>> parser = argparse.ArgumentParser(prog='myprogram')\n"
">>> parser.print_help()\n"
"usage: myprogram [-h]\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='myprogram')\n"
">>> parser.print_help()\n"
"usage: myprogram [-h]\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit"

#: ../../library/argparse.rst:147
msgid ""
"Note that the program name, whether determined from ``sys.argv[0]`` or from "
"the ``prog=`` argument, is available to help messages using the ``%(prog)s`` "
"format specifier."
msgstr ""
"Tenga en cuenta que el nombre del programa, ya sea determinado a partir de "
"``sys.argv[0]`` o del argumento ``prog=``, está disponible para los mensajes "
"de ayuda que utilizan el especificador de formato ``%(prog)s``."

#: ../../library/argparse.rst:153
msgid ""
">>> parser = argparse.ArgumentParser(prog='myprogram')\n"
">>> parser.add_argument('--foo', help='foo of the %(prog)s program')\n"
">>> parser.print_help()\n"
"usage: myprogram [-h] [--foo FOO]\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" --foo FOO   foo of the myprogram program"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='myprogram')\n"
">>> parser.add_argument('--foo', help='foo of the %(prog)s program')\n"
">>> parser.print_help()\n"
"usage: myprogram [-h] [--foo FOO]\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" --foo FOO   foo of the myprogram program"

#: ../../library/argparse.rst:164
msgid "usage"
msgstr "uso"

#: ../../library/argparse.rst:166
msgid ""
"By default, :class:`ArgumentParser` calculates the usage message from the "
"arguments it contains. The default message can be overridden with the "
"``usage=`` keyword argument::"
msgstr ""
"Por defecto, :class:`ArgumentParser` calcula el mensaje de uso a partir de "
"los argumentos que contiene. El mensaje predeterminado se puede anular con "
"el argumento de palabra clave ``usage=``::"

#: ../../library/argparse.rst:170
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', usage='%(prog)s "
"[options]')\n"
">>> parser.add_argument('--foo', nargs='?', help='foo help')\n"
">>> parser.add_argument('bar', nargs='+', help='bar help')\n"
">>> parser.print_help()\n"
"usage: PROG [options]\n"
"\n"
"positional arguments:\n"
" bar          bar help\n"
"\n"
"options:\n"
" -h, --help   show this help message and exit\n"
" --foo [FOO]  foo help"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG', usage='%(prog)s "
"[options]')\n"
">>> parser.add_argument('--foo', nargs='?', help='foo help')\n"
">>> parser.add_argument('bar', nargs='+', help='bar help')\n"
">>> parser.print_help()\n"
"usage: PROG [options]\n"
"\n"
"positional arguments:\n"
" bar          bar help\n"
"\n"
"options:\n"
" -h, --help   show this help message and exit\n"
" --foo [FOO]  foo help"

#: ../../library/argparse.rst:183
msgid ""
"The ``%(prog)s`` format specifier is available to fill in the program name "
"in your usage messages."
msgstr ""
"El especificador de formato ``%(prog)s`` está disponible para rellenar el "
"nombre del programa en sus mensajes de uso."

#: ../../library/argparse.rst:190
msgid "description"
msgstr "descripción"

#: ../../library/argparse.rst:192
msgid ""
"Most calls to the :class:`ArgumentParser` constructor will use the "
"``description=`` keyword argument.  This argument gives a brief description "
"of what the program does and how it works.  In help messages, the "
"description is displayed between the command-line usage string and the help "
"messages for the various arguments."
msgstr ""
"La mayoría de las llamadas al constructor :class:`ArgumentParser` utilizarán "
"el argumento de la palabra clave ``description=``.  Este argumento ofrece "
"una breve descripción de lo que hace el programa y cómo funciona.  En los "
"mensajes de ayuda, la descripción se muestra entre la cadena de uso de la "
"línea de comandos y los mensajes de ayuda de los distintos argumentos."

#: ../../library/argparse.rst:198
msgid ""
"By default, the description will be line-wrapped so that it fits within the "
"given space.  To change this behavior, see the formatter_class_ argument."
msgstr ""
"Por defecto, la descripción se ajustará para que quepa en el espacio dado.  "
"Para cambiar este comportamiento, consultar el argumento formatter_class_."

#: ../../library/argparse.rst:203
msgid "epilog"
msgstr "epílogo"

#: ../../library/argparse.rst:205
msgid ""
"Some programs like to display additional description of the program after "
"the description of the arguments.  Such text can be specified using the "
"``epilog=`` argument to :class:`ArgumentParser`::"
msgstr ""
"Algunos programas prefieren mostrar una descripción adicional del programa "
"después de la descripción de los argumentos.  Dicho texto puede "
"especificarse utilizando el argumento ``epilog=`` de :class:"
"`ArgumentParser`::"

#: ../../library/argparse.rst:209
msgid ""
">>> parser = argparse.ArgumentParser(\n"
"...     description='A foo that bars',\n"
"...     epilog=\"And that's how you'd foo a bar\")\n"
">>> parser.print_help()\n"
"usage: argparse.py [-h]\n"
"\n"
"A foo that bars\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
"\n"
"And that's how you'd foo a bar"
msgstr ""
">>> parser = argparse.ArgumentParser(\n"
"...     description='A foo that bars',\n"
"...     epilog=\"And that's how you'd foo a bar\")\n"
">>> parser.print_help()\n"
"usage: argparse.py [-h]\n"
"\n"
"A foo that bars\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
"\n"
"And that's how you'd foo a bar"

#: ../../library/argparse.rst:222
msgid ""
"As with the description_ argument, the ``epilog=`` text is by default line-"
"wrapped, but this behavior can be adjusted with the formatter_class_ "
"argument to :class:`ArgumentParser`."
msgstr ""
"Al igual que ocurre con el argumento description_, el texto de ``epilog=`` "
"se ajusta por defecto a las líneas, pero este comportamiento puede ajustarse "
"con el formatter_class_ argument to :class:`ArgumentParser`."

#: ../../library/argparse.rst:228
msgid "parents"
msgstr "padres"

#: ../../library/argparse.rst:230
msgid ""
"Sometimes, several parsers share a common set of arguments. Rather than "
"repeating the definitions of these arguments, a single parser with all the "
"shared arguments and passed to ``parents=`` argument to :class:"
"`ArgumentParser` can be used.  The ``parents=`` argument takes a list of :"
"class:`ArgumentParser` objects, collects all the positional and optional "
"actions from them, and adds these actions to the :class:`ArgumentParser` "
"object being constructed::"
msgstr ""
"A veces, varios analizadores sintácticos comparten un conjunto común de "
"argumentos. En lugar de repetir las definiciones de estos argumentos, se "
"puede utilizar un único analizador sintáctico con todos los argumentos "
"compartidos y pasar el argumento ``parents=`` a :class:`ArgumentParser`.  El "
"argumento ``parents=`` toma una lista de objetos :class:`ArgumentParser`, "
"recoge todas las acciones posicionales y opcionales de ellos, y añade estas "
"acciones al objeto :class:`ArgumentParser` que se está construyendo::"

#: ../../library/argparse.rst:237
msgid ""
">>> parent_parser = argparse.ArgumentParser(add_help=False)\n"
">>> parent_parser.add_argument('--parent', type=int)\n"
"\n"
">>> foo_parser = argparse.ArgumentParser(parents=[parent_parser])\n"
">>> foo_parser.add_argument('foo')\n"
">>> foo_parser.parse_args(['--parent', '2', 'XXX'])\n"
"Namespace(foo='XXX', parent=2)\n"
"\n"
">>> bar_parser = argparse.ArgumentParser(parents=[parent_parser])\n"
">>> bar_parser.add_argument('--bar')\n"
">>> bar_parser.parse_args(['--bar', 'YYY'])\n"
"Namespace(bar='YYY', parent=None)"
msgstr ""
">>> parent_parser = argparse.ArgumentParser(add_help=False)\n"
">>> parent_parser.add_argument('--parent', type=int)\n"
"\n"
">>> foo_parser = argparse.ArgumentParser(parents=[parent_parser])\n"
">>> foo_parser.add_argument('foo')\n"
">>> foo_parser.parse_args(['--parent', '2', 'XXX'])\n"
"Namespace(foo='XXX', parent=2)\n"
"\n"
">>> bar_parser = argparse.ArgumentParser(parents=[parent_parser])\n"
">>> bar_parser.add_argument('--bar')\n"
">>> bar_parser.parse_args(['--bar', 'YYY'])\n"
"Namespace(bar='YYY', parent=None)"

#: ../../library/argparse.rst:250
msgid ""
"Note that most parent parsers will specify ``add_help=False``.  Otherwise, "
"the :class:`ArgumentParser` will see two ``-h/--help`` options (one in the "
"parent and one in the child) and raise an error."
msgstr ""
"Tener en cuenta que la mayoría de los analizadores padre especificarán "
"``add_help=False``.  De lo contrario, :class:`ArgumentParser` verá dos "
"opciones ``-h/--help`` (una en el padre y otra en el hijo) y generará un "
"error."

#: ../../library/argparse.rst:255
msgid ""
"You must fully initialize the parsers before passing them via ``parents=``. "
"If you change the parent parsers after the child parser, those changes will "
"not be reflected in the child."
msgstr ""
"Debe inicializar completamente los analizadores sintácticos antes de "
"pasarlos a través de ``parents=``. Si cambias los analizadores padre después "
"del analizador hijo, esos cambios no se reflejarán en el hijo."

#: ../../library/argparse.rst:263
msgid "formatter_class"
msgstr "formatter_class"

#: ../../library/argparse.rst:265
msgid ""
":class:`ArgumentParser` objects allow the help formatting to be customized "
"by specifying an alternate formatting class.  Currently, there are four such "
"classes:"
msgstr ""
":class:`ArgumentParser` permiten personalizar el formato de la ayuda "
"especificando una clase de formato alternativa.  Actualmente, existen cuatro "
"clases de este tipo:"

#: ../../library/argparse.rst:274
msgid ""
":class:`RawDescriptionHelpFormatter` and :class:`RawTextHelpFormatter` give "
"more control over how textual descriptions are displayed. By default, :class:"
"`ArgumentParser` objects line-wrap the description_ and epilog_ texts in "
"command-line help messages::"
msgstr ""
":class:`RawDescriptionHelpFormatter` y :class:`RawTextHelpFormatter` ofrecen "
"más control sobre cómo se muestran las descripciones textuales. Por defecto, "
"los objetos :class:`ArgumentParser` envuelven con líneas los textos "
"description_ y epilog_ de los mensajes de ayuda de línea de comandos::"

#: ../../library/argparse.rst:279
msgid ""
">>> parser = argparse.ArgumentParser(\n"
"...     prog='PROG',\n"
"...     description='''this description\n"
"...         was indented weird\n"
"...             but that is okay''',\n"
"...     epilog='''\n"
"...             likewise for this epilog whose whitespace will\n"
"...         be cleaned up and whose words will be wrapped\n"
"...         across a couple lines''')\n"
">>> parser.print_help()\n"
"usage: PROG [-h]\n"
"\n"
"this description was indented weird but that is okay\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
"\n"
"likewise for this epilog whose whitespace will be cleaned up and whose "
"words\n"
"will be wrapped across a couple lines"
msgstr ""
">>> parser = argparse.ArgumentParser(\n"
"... prog='PROG',\n"
"... description='''esta descripción\n"
"... tiene una sangría rara\n"
"... pero está bien''',\n"
"... epilog='''\n"
"... lo mismo para este epílogo cuyos espacios en blanco serán\n"
"... será limpiado y cuyas palabras serán envueltas\n"
"... en un par de líneas''')\n"
">>> parser.print_help()\n"
"uso: PROG [-h]\n"
"\n"
"esta descripcion tiene un sangrado raro pero esta bien\n"
"\n"
"opciones:\n"
" -h, --help mostrar este mensaje de ayuda y salir\n"
"\n"
"lo mismo para este epílogo cuyos espacios en blanco serán limpiados y cuyas "
"palabras\n"
"serán envueltas en un par de líneas"

#: ../../library/argparse.rst:299
msgid ""
"Passing :class:`RawDescriptionHelpFormatter` as ``formatter_class=`` "
"indicates that description_ and epilog_ are already correctly formatted and "
"should not be line-wrapped::"
msgstr ""
"Pasando :class:`RawDescriptionHelpFormatter` como ``formatter_class=`` "
"indica que description_ y epilog_ ya están correctamente formateados y no "
"deben ser line-wrapped::"

#: ../../library/argparse.rst:303
msgid ""
">>> parser = argparse.ArgumentParser(\n"
"...     prog='PROG',\n"
"...     formatter_class=argparse.RawDescriptionHelpFormatter,\n"
"...     description=textwrap.dedent('''\\\n"
"...         Please do not mess up this text!\n"
"...         --------------------------------\n"
"...             I have indented it\n"
"...             exactly the way\n"
"...             I want it\n"
"...         '''))\n"
">>> parser.print_help()\n"
"usage: PROG [-h]\n"
"\n"
"Please do not mess up this text!\n"
"--------------------------------\n"
"   I have indented it\n"
"   exactly the way\n"
"   I want it\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit"
msgstr ""
">>> parser = argparse.ArgumentParser(\n"
"... prog='PROG',\n"
"... formatter_class=argparse.RawDescriptionHelpFormatter,\n"
"... description=textwrap.dedent('''\\\n"
"...         Por favor, ¡no estropees este texto!\n"
"...         --------------------------------\n"
"...             Lo he sangrado\n"
"... exactamente de la manera\n"
"...             Quiero que\n"
"...         '''))\n"
">>> parser.print_help()\n"
"uso: PROG [-h]\n"
"\n"
"Por favor, ¡no estropees este texto!\n"
"--------------------------------\n"
"   Lo he sangrado\n"
"   exactamente como\n"
"   quiero\n"
"\n"
"opciones:\n"
" -h, --help mostrar este mensaje de ayuda y salir"

#: ../../library/argparse.rst:325
msgid ""
":class:`RawTextHelpFormatter` maintains whitespace for all sorts of help "
"text, including argument descriptions. However, multiple newlines are "
"replaced with one. If you wish to preserve multiple blank lines, add spaces "
"between the newlines."
msgstr ""
":class:`RawTextHelpFormatter` mantiene los espacios en blanco para todo tipo "
"de texto de ayuda, incluidas las descripciones de los argumentos. Sin "
"embargo, las nuevas líneas múltiples se sustituyen por una. Si desea "
"conservar varias líneas en blanco, añada espacios entre las nuevas líneas."

#: ../../library/argparse.rst:330
msgid ""
":class:`ArgumentDefaultsHelpFormatter` automatically adds information about "
"default values to each of the argument help messages::"
msgstr ""
":class:`ArgumentDefaultsHelpFormatter` añade automáticamente información "
"sobre los valores por defecto a cada uno de los mensajes de ayuda de los "
"argumentos::"

#: ../../library/argparse.rst:333
msgid ""
">>> parser = argparse.ArgumentParser(\n"
"...     prog='PROG',\n"
"...     formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n"
">>> parser.add_argument('--foo', type=int, default=42, help='FOO!')\n"
">>> parser.add_argument('bar', nargs='*', default=[1, 2, 3], help='BAR!')\n"
">>> parser.print_help()\n"
"usage: PROG [-h] [--foo FOO] [bar ...]\n"
"\n"
"positional arguments:\n"
" bar         BAR! (default: [1, 2, 3])\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" --foo FOO   FOO! (default: 42)"
msgstr ""
">>> parser = argparse.ArgumentParser(\n"
"...     prog='PROG',\n"
"...     formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n"
">>> parser.add_argument('--foo', type=int, default=42, help='FOO!')\n"
">>> parser.add_argument('bar', nargs='*', default=[1, 2, 3], help='BAR!')\n"
">>> parser.print_help()\n"
"usage: PROG [-h] [--foo FOO] [bar ...]\n"
"\n"
"positional arguments:\n"
" bar         BAR! (default: [1, 2, 3])\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" --foo FOO   FOO! (default: 42)"

#: ../../library/argparse.rst:348
msgid ""
":class:`MetavarTypeHelpFormatter` uses the name of the type_ argument for "
"each argument as the display name for its values (rather than using the "
"dest_ as the regular formatter does)::"
msgstr ""
":class:`MetavarTypeHelpFormatter` utiliza el nombre del argumento type_ para "
"cada argumento como nombre de visualización para sus valores (en lugar de "
"utilizar el dest_ como hace el formateador normal)::"

#: ../../library/argparse.rst:352
msgid ""
">>> parser = argparse.ArgumentParser(\n"
"...     prog='PROG',\n"
"...     formatter_class=argparse.MetavarTypeHelpFormatter)\n"
">>> parser.add_argument('--foo', type=int)\n"
">>> parser.add_argument('bar', type=float)\n"
">>> parser.print_help()\n"
"usage: PROG [-h] [--foo int] float\n"
"\n"
"positional arguments:\n"
"  float\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"  --foo int"
msgstr ""
">>> parser = argparse.ArgumentParser(\n"
"...     prog='PROG',\n"
"...     formatter_class=argparse.MetavarTypeHelpFormatter)\n"
">>> parser.add_argument('--foo', type=int)\n"
">>> parser.add_argument('bar', type=float)\n"
">>> parser.print_help()\n"
"usage: PROG [-h] [--foo int] float\n"
"\n"
"positional arguments:\n"
"  float\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"  --foo int"

#: ../../library/argparse.rst:369
msgid "prefix_chars"
msgstr "prefix_chars"

#: ../../library/argparse.rst:371
msgid ""
"Most command-line options will use ``-`` as the prefix, e.g. ``-f/--foo``. "
"Parsers that need to support different or additional prefix characters, e.g. "
"for options like ``+f`` or ``/foo``, may specify them using the "
"``prefix_chars=`` argument to the :class:`ArgumentParser` constructor::"
msgstr ""
"La mayoría de las opciones de línea de comandos utilizarán ``-`` como "
"prefijo, por ejemplo ``-f/--foo``. Los analizadores sintácticos que "
"necesiten admitir caracteres de prefijo diferentes o adicionales, por "
"ejemplo, para opciones como ``+f`` o ``/foo``, pueden especificarlos "
"utilizando el argumento ``prefix_chars=`` para el constructor :class:"
"`ArgumentParser`::"

#: ../../library/argparse.rst:377
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', prefix_chars='-+')\n"
">>> parser.add_argument('+f')\n"
">>> parser.add_argument('++bar')\n"
">>> parser.parse_args('+f X ++bar Y'.split())\n"
"Namespace(bar='Y', f='X')"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG', prefix_chars='-+')\n"
">>> parser.add_argument('+f')\n"
">>> parser.add_argument('++bar')\n"
">>> parser.parse_args('+f X ++bar Y'.split())\n"
"Namespace(bar='Y', f='X')"

#: ../../library/argparse.rst:383
msgid ""
"The ``prefix_chars=`` argument defaults to ``'-'``. Supplying a set of "
"characters that does not include ``-`` will cause ``-f/--foo`` options to be "
"disallowed."
msgstr ""
"El argumento ``prefix_chars=`` es por defecto ``'-'``. Si se proporciona un "
"conjunto de caracteres que no incluya ``-``, no se permitirán las opciones "
"de ``-f/--foo``."

#: ../../library/argparse.rst:389
msgid "fromfile_prefix_chars"
msgstr "fromfile_prefix_chars"

#: ../../library/argparse.rst:391
msgid ""
"Sometimes, when dealing with a particularly long argument list, it may make "
"sense to keep the list of arguments in a file rather than typing it out at "
"the command line.  If the ``fromfile_prefix_chars=`` argument is given to "
"the :class:`ArgumentParser` constructor, then arguments that start with any "
"of the specified characters will be treated as files, and will be replaced "
"by the arguments they contain.  For example::"
msgstr ""
"A veces, cuando se trata de una lista de argumentos particularmente larga, "
"puede tener sentido mantener la lista de argumentos en un archivo en lugar "
"de escribirla en la línea de comandos.  Si se proporciona el argumento "
"``fromfile_prefix_chars=`` al constructor :class:`ArgumentParser`, los "
"argumentos que empiecen por cualquiera de los caracteres especificados se "
"tratarán como archivos y se sustituirán por los argumentos que contengan.  "
"Por ejemplo::"

#: ../../library/argparse.rst:398
msgid ""
">>> with open('args.txt', 'w', encoding=sys.getfilesystemencoding()) as fp:\n"
"...     fp.write('-f\\nbar')\n"
"...\n"
">>> parser = argparse.ArgumentParser(fromfile_prefix_chars='@')\n"
">>> parser.add_argument('-f')\n"
">>> parser.parse_args(['-f', 'foo', '@args.txt'])\n"
"Namespace(f='bar')"
msgstr ""
">>> with open('args.txt', 'w', encoding=sys.getfilesystemencoding()) as fp:\n"
"... fp.write('-f\\nbar')\n"
"...\n"
">>> parser = argparse.ArgumentParser(fromfile_prefix_chars='@')\n"
">>> parser.add_argument('-f')\n"
">>> parser.parse_args(['-f', 'foo', '@args.txt'])\n"
"Namespace(f='bar')"

#: ../../library/argparse.rst:406
msgid ""
"Arguments read from a file must by default be one per line (but see also :"
"meth:`~ArgumentParser.convert_arg_line_to_args`) and are treated as if they "
"were in the same place as the original file referencing argument on the "
"command line.  So in the example above, the expression ``['-f', 'foo', "
"'@args.txt']`` is considered equivalent to the expression ``['-f', 'foo', '-"
"f', 'bar']``."
msgstr ""
"Los argumentos leídos de un fichero deben ser por defecto uno por línea "
"(pero véase también :meth:`~ArgumentParser.convert_arg_line_to_args`) y se "
"tratan como si estuvieran en el mismo lugar que el argumento original de "
"referencia al fichero en la línea de órdenes.  Así, en el ejemplo anterior, "
"la expresión ``['-f', 'foo', '@args.txt']`` se considera equivalente a la "
"expresión ``['-f', 'foo', '-f', 'bar']``."

#: ../../library/argparse.rst:412
msgid ""
":class:`ArgumentParser` uses :term:`filesystem encoding and error handler` "
"to read the file containing arguments."
msgstr ""
":class:`ArgumentParser` utiliza :term:`filesystem encoding and error "
"handler` para leer el fichero que contiene los argumentos."

#: ../../library/argparse.rst:415
msgid ""
"The ``fromfile_prefix_chars=`` argument defaults to ``None``, meaning that "
"arguments will never be treated as file references."
msgstr ""
"El argumento ``fromfile_prefix_chars=`` por defecto es ``None``, lo que "
"significa que los argumentos nunca serán tratados como referencias a "
"archivos."

#: ../../library/argparse.rst:418
msgid ""
":class:`ArgumentParser` changed encoding and errors to read arguments files "
"from default (e.g. :func:`locale.getpreferredencoding(False) <locale."
"getpreferredencoding>` and ``\"strict\"``) to the :term:`filesystem encoding "
"and error handler`. Arguments file should be encoded in UTF-8 instead of "
"ANSI Codepage on Windows."
msgstr ""
":class:`ArgumentParser` cambiado la codificación y los errores para leer los "
"archivos de argumentos por defecto (por ejemplo, :func:`locale."
"getpreferredencoding(False) <locale.getpreferredencoding>` y ``\"strict\"``) "
"al :term:`filesystem encoding and error handler`. El archivo de argumentos "
"debe codificarse en UTF-8 en lugar de ANSI Codepage en Windows."

#: ../../library/argparse.rst:426
msgid "argument_default"
msgstr "argument_default"

#: ../../library/argparse.rst:428
msgid ""
"Generally, argument defaults are specified either by passing a default to :"
"meth:`~ArgumentParser.add_argument` or by calling the :meth:`~ArgumentParser."
"set_defaults` methods with a specific set of name-value pairs.  Sometimes "
"however, it may be useful to specify a single parser-wide default for "
"arguments.  This can be accomplished by passing the ``argument_default=`` "
"keyword argument to :class:`ArgumentParser`.  For example, to globally "
"suppress attribute creation on :meth:`~ArgumentParser.parse_args` calls, we "
"supply ``argument_default=SUPPRESS``::"
msgstr ""
"Generalmente, los argumentos por defecto se especifican pasando un valor por "
"defecto a :meth:`~ArgumentParser.add_argument` o llamando a los métodos de :"
"meth:`~ArgumentParser.set_defaults` con un conjunto específico de pares "
"nombre-valor.  Sin embargo, a veces puede resultar útil especificar un único "
"valor por defecto para los argumentos en todo el analizador sintáctico.  "
"Esto se puede conseguir pasando el argumento de palabra clave "
"``argument_default=`` a :class:`ArgumentParser`.  Por ejemplo, para suprimir "
"globalmente la creación de atributos en las llamadas a :meth:"
"`~ArgumentParser.parse_args`, proporcionamos ``argument_default=SUPPRESS``::"

#: ../../library/argparse.rst:437
msgid ""
">>> parser = argparse.ArgumentParser(argument_default=argparse.SUPPRESS)\n"
">>> parser.add_argument('--foo')\n"
">>> parser.add_argument('bar', nargs='?')\n"
">>> parser.parse_args(['--foo', '1', 'BAR'])\n"
"Namespace(bar='BAR', foo='1')\n"
">>> parser.parse_args([])\n"
"Namespace()"
msgstr ""
">>> parser = argparse.ArgumentParser(argument_default=argparse.SUPPRESS)\n"
">>> parser.add_argument('--foo')\n"
">>> parser.add_argument('bar', nargs='?')\n"
">>> parser.parse_args(['--foo', '1', 'BAR'])\n"
"Namespace(bar='BAR', foo='1')\n"
">>> parser.parse_args([])\n"
"Namespace()"

#: ../../library/argparse.rst:448
msgid "allow_abbrev"
msgstr "allow_abbrev"

#: ../../library/argparse.rst:450
msgid ""
"Normally, when you pass an argument list to the :meth:`~ArgumentParser."
"parse_args` method of an :class:`ArgumentParser`, it :ref:`recognizes "
"abbreviations <prefix-matching>` of long options."
msgstr ""
"Normalmente, cuando se pasa una lista de argumentos al método :meth:"
"`~ArgumentParser.parse_args` de un :class:`ArgumentParser`, éste :ref:"
"`recognizes abbreviations <prefix-matching>` de opciones largas."

#: ../../library/argparse.rst:454
msgid "This feature can be disabled by setting ``allow_abbrev`` to ``False``::"
msgstr ""
"Esta función puede desactivarse configurando ``allow_abbrev`` en ``False``::"

#: ../../library/argparse.rst:456
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', allow_abbrev=False)\n"
">>> parser.add_argument('--foobar', action='store_true')\n"
">>> parser.add_argument('--foonley', action='store_false')\n"
">>> parser.parse_args(['--foon'])\n"
"usage: PROG [-h] [--foobar] [--foonley]\n"
"PROG: error: unrecognized arguments: --foon"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG', allow_abbrev=False)\n"
">>> parser.add_argument('--foobar', action='store_true')\n"
">>> parser.add_argument('--foonley', action='store_false')\n"
">>> parser.parse_args(['--foon'])\n"
"usage: PROG [-h] [--foobar] [--foonley]\n"
"PROG: error: unrecognized arguments: --foon"

#: ../../library/argparse.rst:467
msgid "conflict_handler"
msgstr "conflict_handler"

#: ../../library/argparse.rst:469
msgid ""
":class:`ArgumentParser` objects do not allow two actions with the same "
"option string.  By default, :class:`ArgumentParser` objects raise an "
"exception if an attempt is made to create an argument with an option string "
"that is already in use::"
msgstr ""
":class:`ArgumentParser` no permiten dos acciones con la misma cadena de "
"opción.  Por defecto, los objetos :class:`ArgumentParser` lanzan una "
"excepción si se intenta crear un argumento con una cadena de opción que ya "
"está en uso::"

#: ../../library/argparse.rst:474
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-f', '--foo', help='old foo help')\n"
">>> parser.add_argument('--foo', help='new foo help')\n"
"Traceback (most recent call last):\n"
" ..\n"
"ArgumentError: argument --foo: conflicting option string(s): --foo"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-f', '--foo', help='old foo help')\n"
">>> parser.add_argument('--foo', help='new foo help')\n"
"Traceback (most recent call last):\n"
" ..\n"
"ArgumentError: argument --foo: conflicting option string(s): --foo"

#: ../../library/argparse.rst:481
msgid ""
"Sometimes (e.g. when using parents_) it may be useful to simply override any "
"older arguments with the same option string.  To get this behavior, the "
"value ``'resolve'`` can be supplied to the ``conflict_handler=`` argument "
"of :class:`ArgumentParser`::"
msgstr ""
"A veces (por ejemplo, cuando se utiliza parents_) puede ser útil simplemente "
"anular cualquier argumento anterior con la misma cadena de opciones.  Para "
"obtener este comportamiento, se puede suministrar el valor ``'resolve'`` al "
"argumento ``conflict_handler=`` de :class:`ArgumentParser`::"

#: ../../library/argparse.rst:486
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', "
"conflict_handler='resolve')\n"
">>> parser.add_argument('-f', '--foo', help='old foo help')\n"
">>> parser.add_argument('--foo', help='new foo help')\n"
">>> parser.print_help()\n"
"usage: PROG [-h] [-f FOO] [--foo FOO]\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" -f FOO      old foo help\n"
" --foo FOO   new foo help"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG', "
"conflict_handler='resolve')\n"
">>> parser.add_argument('-f', '--foo', help='old foo help')\n"
">>> parser.add_argument('--foo', help='new foo help')\n"
">>> parser.print_help()\n"
"usage: PROG [-h] [-f FOO] [--foo FOO]\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" -f FOO      old foo help\n"
" --foo FOO   new foo help"

#: ../../library/argparse.rst:497
msgid ""
"Note that :class:`ArgumentParser` objects only remove an action if all of "
"its option strings are overridden.  So, in the example above, the old ``-f/--"
"foo`` action is retained as the ``-f`` action, because only the ``--foo`` "
"option string was overridden."
msgstr ""
"Tenga en cuenta que los objetos :class:`ArgumentParser` sólo eliminan una "
"acción si se anulan todas sus cadenas de opciones.  Así, en el ejemplo "
"anterior, la antigua acción ``-f/--foo`` se conserva como la acción ``-f``, "
"porque sólo se ha anulado la cadena de opciones ``--foo``."

#: ../../library/argparse.rst:504
msgid "add_help"
msgstr "add_help"

#: ../../library/argparse.rst:506
msgid ""
"By default, :class:`ArgumentParser` objects add an option which simply "
"displays the parser's help message. If ``-h`` or ``--help`` is supplied at "
"the command line, the :class:`!ArgumentParser` help will be printed."
msgstr ""
"Por defecto, los objetos :class:`ArgumentParser` añaden una opción que "
"simplemente muestra el mensaje de ayuda del analizador sintáctico. Si se "
"suministra ``-h`` o ``--help`` en la línea de comandos, se imprimirá la "
"ayuda :class:`!ArgumentParser`."

#: ../../library/argparse.rst:510
msgid ""
"Occasionally, it may be useful to disable the addition of this help option. "
"This can be achieved by passing ``False`` as the ``add_help=`` argument to :"
"class:`ArgumentParser`::"
msgstr ""
"Ocasionalmente, puede ser útil desactivar la adición de esta opción de "
"ayuda. Esto se puede conseguir pasando ``False`` como argumento "
"``add_help=`` a :class:`ArgumentParser`::"

#: ../../library/argparse.rst:514
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)\n"
">>> parser.add_argument('--foo', help='foo help')\n"
">>> parser.print_help()\n"
"usage: PROG [--foo FOO]\n"
"\n"
"options:\n"
" --foo FOO  foo help"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)\n"
">>> parser.add_argument('--foo', help='foo help')\n"
">>> parser.print_help()\n"
"usage: PROG [--foo FOO]\n"
"\n"
"options:\n"
" --foo FOO  foo help"

#: ../../library/argparse.rst:522
msgid ""
"The help option is typically ``-h/--help``. The exception to this is if the "
"``prefix_chars=`` is specified and does not include ``-``, in which case ``-"
"h`` and ``--help`` are not valid options.  In this case, the first character "
"in ``prefix_chars`` is used to prefix the help options::"
msgstr ""
"La opción de ayuda suele ser ``-h/--help``. La excepción a esto es si se "
"especifica ``prefix_chars=`` y no incluye ``-``, en cuyo caso ``-h`` y ``--"
"help`` no son opciones válidas.  En este caso, el primer carácter de "
"``prefix_chars`` se utiliza como prefijo de las opciones de ayuda::"

#: ../../library/argparse.rst:528
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', prefix_chars='+/')\n"
">>> parser.print_help()\n"
"usage: PROG [+h]\n"
"\n"
"options:\n"
"  +h, ++help  show this help message and exit"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG', prefix_chars='+/')\n"
">>> parser.print_help()\n"
"usage: PROG [+h]\n"
"\n"
"options:\n"
"  +h, ++help  show this help message and exit"

#: ../../library/argparse.rst:537
msgid "exit_on_error"
msgstr "exit_on_error"

#: ../../library/argparse.rst:539
msgid ""
"Normally, when you pass an invalid argument list to the :meth:"
"`~ArgumentParser.parse_args` method of an :class:`ArgumentParser`, it will "
"print a *message* to :data:`sys.stderr` and exit with a status code of 2."
msgstr ""
"Normalmente, cuando pasas una lista de argumentos inválida al método :meth:"
"`~ArgumentParser.parse_args` de un :class:`ArgumentParser`, éste imprimirá "
"un *mensaje* a :data:`sys.stderr` y saldrá con un código de estado 2."

#: ../../library/argparse.rst:543
msgid ""
"If the user would like to catch errors manually, the feature can be enabled "
"by setting ``exit_on_error`` to ``False``::"
msgstr ""
"Si el usuario desea detectar los errores manualmente, puede activar esta "
"función configurando ``exit_on_error`` en ``False``::"

#: ../../library/argparse.rst:546
msgid ""
">>> parser = argparse.ArgumentParser(exit_on_error=False)\n"
">>> parser.add_argument('--integers', type=int)\n"
"_StoreAction(option_strings=['--integers'], dest='integers', nargs=None, "
"const=None, default=None, type=<class 'int'>, choices=None, help=None, "
"metavar=None)\n"
">>> try:\n"
"...     parser.parse_args('--integers a'.split())\n"
"... except argparse.ArgumentError:\n"
"...     print('Catching an argumentError')\n"
"...\n"
"Catching an argumentError"
msgstr ""
">>> parser = argparse.ArgumentParser(exit_on_error=False)\n"
">>> parser.add_argument('--integers', type=int)\n"
"_StoreAction(option_strings=['--integers'], dest='integers', nargs=None, "
"const=None, default=None, type=<class 'int'>, choices=None, help=None, "
"metavar=None)\n"
">>> try:\n"
"...     parser.parse_args('--integers a'.split())\n"
"... except argparse.ArgumentError:\n"
"...     print('Catching an argumentError')\n"
"...\n"
"Catching an argumentError"

#: ../../library/argparse.rst:560
msgid "The add_argument() method"
msgstr "El método add_argument()"

#: ../../library/argparse.rst:566
msgid ""
"Define how a single command-line argument should be parsed.  Each parameter "
"has its own more detailed description below, but in short they are:"
msgstr ""
"Define cómo debe analizarse un único argumento de la línea de comandos.  "
"Cada parámetro tiene su propia descripción más detallada a continuación, "
"pero en resumen son:"

#: ../../library/argparse.rst:569
msgid ""
"`name or flags`_ - Either a name or a list of option strings, e.g. ``'foo'`` "
"or ``'-f', '--foo'``."
msgstr ""
"`name or flags`_ - Un nombre o una lista de cadenas de opciones, por ejemplo "
"``'foo'`` o ``'-f', '--foo'``."

#: ../../library/argparse.rst:572
msgid ""
"action_ - The basic type of action to be taken when this argument is "
"encountered at the command line."
msgstr ""
"action_ - El tipo básico de acción que se llevará a cabo cuando se encuentre "
"este argumento en la línea de comandos."

#: ../../library/argparse.rst:575
msgid "nargs_ - The number of command-line arguments that should be consumed."
msgstr ""
"nargs_ - El número de argumentos de la línea de comandos que deben "
"consumirse."

#: ../../library/argparse.rst:577
msgid ""
"const_ - A constant value required by some action_ and nargs_ selections."
msgstr ""
"const_ - Un valor constante requerido por algunas selecciones action_ y "
"nargs_."

#: ../../library/argparse.rst:579
msgid ""
"default_ - The value produced if the argument is absent from the command "
"line and if it is absent from the namespace object."
msgstr ""
"default_ - El valor producido si el argumento está ausente de la línea de "
"comandos y si está ausente del objeto namespace."

#: ../../library/argparse.rst:582
msgid ""
"type_ - The type to which the command-line argument should be converted."
msgstr ""
"type_ - Tipo al que debe convertirse el argumento de la línea de comandos."

#: ../../library/argparse.rst:584
msgid "choices_ - A sequence of the allowable values for the argument."
msgstr "choices_ - Una secuencia de los valores permitidos para el argumento."

#: ../../library/argparse.rst:586
msgid ""
"required_ - Whether or not the command-line option may be omitted (optionals "
"only)."
msgstr ""
"required_ - Si la opción de línea de comandos puede omitirse (sólo "
"opcionales)."

#: ../../library/argparse.rst:589
msgid "help_ - A brief description of what the argument does."
msgstr "help_ - Una breve descripción de lo que hace el argumento."

#: ../../library/argparse.rst:591
msgid "metavar_ - A name for the argument in usage messages."
msgstr "metavar_ - Un nombre para el argumento en los mensajes de uso."

#: ../../library/argparse.rst:593
msgid ""
"dest_ - The name of the attribute to be added to the object returned by :"
"meth:`parse_args`."
msgstr ""
"dest_ - El nombre del atributo que se añadirá al objeto devuelto por :meth:"
"`parse_args`."

#: ../../library/argparse.rst:602
msgid "name or flags"
msgstr "nombre o banderas"

#: ../../library/argparse.rst:604
msgid ""
"The :meth:`~ArgumentParser.add_argument` method must know whether an "
"optional argument, like ``-f`` or ``--foo``, or a positional argument, like "
"a list of filenames, is expected.  The first arguments passed to :meth:"
"`~ArgumentParser.add_argument` must therefore be either a series of flags, "
"or a simple argument name."
msgstr ""
"El método :meth:`~ArgumentParser.add_argument` debe saber si se espera un "
"argumento opcional, como ``-f`` o ``--foo``, o un argumento posicional, como "
"una lista de nombres de archivo.  Por lo tanto, los primeros argumentos que "
"se pasan a :meth:`~ArgumentParser.add_argument` deben ser una serie de "
"banderas o un simple nombre de argumento."

#: ../../library/argparse.rst:610
msgid "For example, an optional argument could be created like::"
msgstr "Por ejemplo, se podría crear un argumento opcional como::"

#: ../../library/argparse.rst:612
msgid ">>> parser.add_argument('-f', '--foo')"
msgstr ">>> parser.add_argument('-f', '--foo')"

#: ../../library/argparse.rst:614
msgid "while a positional argument could be created like::"
msgstr "mientras que un argumento posicional podría crearse como::"

#: ../../library/argparse.rst:616
msgid ">>> parser.add_argument('bar')"
msgstr ">>> parser.add_argument('bar')"

#: ../../library/argparse.rst:618
msgid ""
"When :meth:`~ArgumentParser.parse_args` is called, optional arguments will "
"be identified by the ``-`` prefix, and the remaining arguments will be "
"assumed to be positional::"
msgstr ""
"Cuando se llama a :meth:`~ArgumentParser.parse_args`, los argumentos "
"opcionales se identificarán mediante el prefijo ``-``, y se asumirá que los "
"argumentos restantes son posicionales::"

#: ../../library/argparse.rst:622
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-f', '--foo')\n"
">>> parser.add_argument('bar')\n"
">>> parser.parse_args(['BAR'])\n"
"Namespace(bar='BAR', foo=None)\n"
">>> parser.parse_args(['BAR', '--foo', 'FOO'])\n"
"Namespace(bar='BAR', foo='FOO')\n"
">>> parser.parse_args(['--foo', 'FOO'])\n"
"usage: PROG [-h] [-f FOO] bar\n"
"PROG: error: the following arguments are required: bar"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-f', '--foo')\n"
">>> parser.add_argument('bar')\n"
">>> parser.parse_args(['BAR'])\n"
"Namespace(bar='BAR', foo=None)\n"
">>> parser.parse_args(['BAR', '--foo', 'FOO'])\n"
"Namespace(bar='BAR', foo='FOO')\n"
">>> parser.parse_args(['--foo', 'FOO'])\n"
"usage: PROG [-h] [-f FOO] bar\n"
"PROG: error: the following arguments are required: bar"

#: ../../library/argparse.rst:637
msgid "action"
msgstr "acción"

#: ../../library/argparse.rst:639
msgid ""
":class:`ArgumentParser` objects associate command-line arguments with "
"actions.  These actions can do just about anything with the command-line "
"arguments associated with them, though most actions simply add an attribute "
"to the object returned by :meth:`~ArgumentParser.parse_args`.  The "
"``action`` keyword argument specifies how the command-line arguments should "
"be handled. The supplied actions are:"
msgstr ""
":class:`ArgumentParser` asocian argumentos de línea de comandos con "
"acciones.  Estas acciones pueden hacer prácticamente cualquier cosa con los "
"argumentos de línea de comandos asociados a ellas, aunque la mayoría de las "
"acciones simplemente añaden un atributo al objeto devuelto por :meth:"
"`~ArgumentParser.parse_args`.  El argumento de la palabra clave ``action`` "
"especifica cómo deben tratarse los argumentos de la línea de comandos. Las "
"acciones suministradas son:"

#: ../../library/argparse.rst:645
msgid ""
"``'store'`` - This just stores the argument's value.  This is the default "
"action."
msgstr ""
"``'store'`` - Esto sólo almacena el valor del argumento.  Esta es la acción "
"por defecto."

#: ../../library/argparse.rst:648
msgid ""
"``'store_const'`` - This stores the value specified by the const_ keyword "
"argument; note that the const_ keyword argument defaults to ``None``.  The "
"``'store_const'`` action is most commonly used with optional arguments that "
"specify some sort of flag.  For example::"
msgstr ""
"``'store_const'`` - Esto almacena el valor especificado por el argumento de "
"la palabra clave const_; tenga en cuenta que el argumento de la palabra "
"clave const_ por defecto es ``None``. La acción ``'store_const'`` se utiliza "
"más comúnmente con argumentos opcionales que especifican algún tipo de "
"bandera.  Por ejemplo::"

#: ../../library/argparse.rst:653
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action='store_const', const=42)\n"
">>> parser.parse_args(['--foo'])\n"
"Namespace(foo=42)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action='store_const', const=42)\n"
">>> parser.parse_args(['--foo'])\n"
"Namespace(foo=42)"

#: ../../library/argparse.rst:658
msgid ""
"``'store_true'`` and ``'store_false'`` - These are special cases of "
"``'store_const'`` used for storing the values ``True`` and ``False`` "
"respectively.  In addition, they create default values of ``False`` and "
"``True`` respectively::"
msgstr ""
"``'store_true'`` y ``'store_false'`` - Son casos especiales de "
"``'store_const'`` utilizados para almacenar los valores ``True`` y ``False`` "
"respectivamente.  Además, crean valores por defecto de ``False`` y ``True`` "
"respectivamente::"

#: ../../library/argparse.rst:663
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action='store_true')\n"
">>> parser.add_argument('--bar', action='store_false')\n"
">>> parser.add_argument('--baz', action='store_false')\n"
">>> parser.parse_args('--foo --bar'.split())\n"
"Namespace(foo=True, bar=False, baz=True)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action='store_true')\n"
">>> parser.add_argument('--bar', action='store_false')\n"
">>> parser.add_argument('--baz', action='store_false')\n"
">>> parser.parse_args('--foo --bar'.split())\n"
"Namespace(foo=True, bar=False, baz=True)"

#: ../../library/argparse.rst:670
msgid ""
"``'append'`` - This stores a list, and appends each argument value to the "
"list. It is useful to allow an option to be specified multiple times. If the "
"default value is non-empty, the default elements will be present in the "
"parsed value for the option, with any values from the command line appended "
"after those default values. Example usage::"
msgstr ""
"``'append'`` - Almacena una lista y añade el valor de cada argumento a la "
"lista. Es útil para permitir que una opción se especifique varias veces. Si "
"el valor por defecto no está vacío, los elementos por defecto estarán "
"presentes en el valor analizado de la opción, con cualquier valor de la "
"línea de órdenes añadido después de los valores por defecto. Ejemplo de uso::"

#: ../../library/argparse.rst:676
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action='append')\n"
">>> parser.parse_args('--foo 1 --foo 2'.split())\n"
"Namespace(foo=['1', '2'])"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action='append')\n"
">>> parser.parse_args('--foo 1 --foo 2'.split())\n"
"Namespace(foo=['1', '2'])"

#: ../../library/argparse.rst:681
msgid ""
"``'append_const'`` - This stores a list, and appends the value specified by "
"the const_ keyword argument to the list; note that the const_ keyword "
"argument defaults to ``None``. The ``'append_const'`` action is typically "
"useful when multiple arguments need to store constants to the same list. For "
"example::"
msgstr ""
"``'append_const'`` - Almacena una lista y añade el valor especificado por el "
"argumento const_ a la lista; tenga en cuenta que el argumento const_ por "
"defecto es ``None``. La acción ``'append_const'`` suele ser útil cuando "
"varios argumentos necesitan almacenar constantes en la misma lista. Por "
"ejemplo::"

#: ../../library/argparse.rst:687
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--str', dest='types', action='append_const', "
"const=str)\n"
">>> parser.add_argument('--int', dest='types', action='append_const', "
"const=int)\n"
">>> parser.parse_args('--str --int'.split())\n"
"Namespace(types=[<class 'str'>, <class 'int'>])"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--str', dest='types', action='append_const', "
"const=str)\n"
">>> parser.add_argument('--int', dest='types', action='append_const', "
"const=int)\n"
">>> parser.parse_args('--str --int'.split())\n"
"Namespace(types=[<class 'str'>, <class 'int'>])"

#: ../../library/argparse.rst:693
msgid ""
"``'extend'`` - This stores a list and appends each item from the multi-value "
"argument list to it. The ``'extend'`` action is typically used with the "
"nargs_ keyword argument value ``'+'`` or ``'*'``. Note that when nargs_ is "
"``None`` (the default) or ``'?'``, each character of the argument string "
"will be appended to the list. Example usage::"
msgstr ""
"``'extend'`` - Almacena una lista y le añade cada elemento de la lista de "
"argumentos multivalor. La acción ``'extend'`` se utiliza normalmente con el "
"valor de argumento de la palabra clave nargs_ ``'+'`` o ``'*'``. Tenga en "
"cuenta que cuando nargs_ es ``None`` (el valor predeterminado) o ``'?'``, "
"cada carácter de la cadena de argumentos se añadirá a la lista. Ejemplo de "
"uso::"

#: ../../library/argparse.rst:701
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument(\"--foo\", action=\"extend\", nargs=\"+\", "
"type=str)\n"
">>> parser.parse_args([\"--foo\", \"f1\", \"--foo\", \"f2\", \"f3\", "
"\"f4\"])\n"
"Namespace(foo=['f1', 'f2', 'f3', 'f4'])"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument(\"--foo\", action=\"extend\", nargs=\"+\", "
"type=str)\n"
">>> parser.parse_args([\"--foo\", \"f1\", \"--foo\", \"f2\", \"f3\", "
"\"f4\"])\n"
"Namespace(foo=['f1', 'f2', 'f3', 'f4'])"

#: ../../library/argparse.rst:708
msgid ""
"``'count'`` - This counts the number of times a keyword argument occurs. For "
"example, this is useful for increasing verbosity levels::"
msgstr ""
"``'count'`` - Cuenta el número de veces que aparece una palabra clave. Por "
"ejemplo, esto es útil para aumentar los niveles de verbosidad::"

#: ../../library/argparse.rst:711
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--verbose', '-v', action='count', default=0)\n"
">>> parser.parse_args(['-vvv'])\n"
"Namespace(verbose=3)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--verbose', '-v', action='count', default=0)\n"
">>> parser.parse_args(['-vvv'])\n"
"Namespace(verbose=3)"

#: ../../library/argparse.rst:716
msgid "Note, the *default* will be ``None`` unless explicitly set to *0*."
msgstr ""
"Nota, el *por defecto* será ``None`` a menos que se establezca "
"explícitamente en *0*."

#: ../../library/argparse.rst:718
msgid ""
"``'help'`` - This prints a complete help message for all the options in the "
"current parser and then exits. By default a help action is automatically "
"added to the parser. See :class:`ArgumentParser` for details of how the "
"output is created."
msgstr ""
"``'help'`` - Imprime un mensaje de ayuda completo para todas las opciones "
"del analizador sintáctico actual y, a continuación, sale. Por defecto, se "
"añade automáticamente una acción de ayuda al analizador sintáctico. "
"Consulte :class:`ArgumentParser` para obtener más información sobre cómo se "
"crea la salida."

#: ../../library/argparse.rst:723
msgid ""
"``'version'`` - This expects a ``version=`` keyword argument in the :meth:"
"`~ArgumentParser.add_argument` call, and prints version information and "
"exits when invoked::"
msgstr ""
"``'version'`` - Esto espera un argumento de palabra clave ``version=`` en la "
"llamada a :meth:`~ArgumentParser.add_argument`, e imprime la información de "
"la versión y sale cuando se invoca::"

#: ../../library/argparse.rst:727
msgid ""
">>> import argparse\n"
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('--version', action='version', version='%(prog)s "
"2.0')\n"
">>> parser.parse_args(['--version'])\n"
"PROG 2.0"
msgstr ""
">>> import argparse\n"
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('--version', action='version', version='%(prog)s "
"2.0')\n"
">>> parser.parse_args(['--version'])\n"
"PROG 2.0"

#: ../../library/argparse.rst:733
msgid ""
"Only actions that consume command-line arguments (e.g. ``'store'``, "
"``'append'`` or ``'extend'``) can be used with positional arguments."
msgstr ""
"Sólo las acciones que consumen argumentos de línea de comandos (por ejemplo, "
"``'store'``, ``'append'`` o ``'extend'``) pueden utilizarse con argumentos "
"posicionales."

#: ../../library/argparse.rst:738
msgid ""
"You may also specify an arbitrary action by passing an :class:`Action` "
"subclass or other object that implements the same interface. The :class:`!"
"BooleanOptionalAction` is available in :mod:`!argparse` and adds support for "
"boolean actions such as ``--foo`` and ``--no-foo``::"
msgstr ""
"También puede especificar una acción arbitraria pasando una subclase de :"
"class:`Action` u otro objeto que implemente la misma interfaz. :class:`!"
"BooleanOptionalAction` está disponible en :mod:`!argparse` y añade soporte "
"para acciones booleanas como ``--foo`` y ``--no-foo``::"

#: ../../library/argparse.rst:743
msgid ""
">>> import argparse\n"
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action=argparse.BooleanOptionalAction)\n"
">>> parser.parse_args(['--no-foo'])\n"
"Namespace(foo=False)"
msgstr ""
">>> import argparse\n"
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action=argparse.BooleanOptionalAction)\n"
">>> parser.parse_args(['--no-foo'])\n"
"Namespace(foo=False)"

#: ../../library/argparse.rst:751
msgid ""
"The recommended way to create a custom action is to extend :class:`Action`, "
"overriding the :meth:`!__call__` method and optionally the :meth:`!__init__` "
"and :meth:`!format_usage` methods. You can also register custom actions "
"using the :meth:`~ArgumentParser.register` method and reference them by "
"their registered name."
msgstr ""
"La forma recomendada de crear una acción personalizada es extender :class:"
"`Action`, sobrescribiendo el método :meth:`!__call__` y opcionalmente los "
"métodos :meth:`!__init__` y :meth:`!format_usage`. También puede registrar "
"acciones personalizadas utilizando el método :meth:`~ArgumentParser."
"register` y hacer referencia a ellas por su nombre registrado."

#: ../../library/argparse.rst:756
msgid "An example of a custom action::"
msgstr "Un ejemplo de acción personalizada::"

#: ../../library/argparse.rst:758
msgid ""
">>> class FooAction(argparse.Action):\n"
"...     def __init__(self, option_strings, dest, nargs=None, **kwargs):\n"
"...         if nargs is not None:\n"
"...             raise ValueError(\"nargs not allowed\")\n"
"...         super().__init__(option_strings, dest, **kwargs)\n"
"...     def __call__(self, parser, namespace, values, option_string=None):\n"
"...         print('%r %r %r' % (namespace, values, option_string))\n"
"...         setattr(namespace, self.dest, values)\n"
"...\n"
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action=FooAction)\n"
">>> parser.add_argument('bar', action=FooAction)\n"
">>> args = parser.parse_args('1 --foo 2'.split())\n"
"Namespace(bar=None, foo=None) '1' None\n"
"Namespace(bar='1', foo=None) '2' '--foo'\n"
">>> args\n"
"Namespace(bar='1', foo='2')"
msgstr ""
">>> class FooAction(argparse.Action):\n"
"...     def __init__(self, option_strings, dest, nargs=None, **kwargs):\n"
"...         if nargs is not None:\n"
"...             raise ValueError(\"nargs not allowed\")\n"
"...         super().__init__(option_strings, dest, **kwargs)\n"
"...     def __call__(self, parser, namespace, values, option_string=None):\n"
"...         print('%r %r %r' % (namespace, values, option_string))\n"
"...         setattr(namespace, self.dest, values)\n"
"...\n"
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action=FooAction)\n"
">>> parser.add_argument('bar', action=FooAction)\n"
">>> args = parser.parse_args('1 --foo 2'.split())\n"
"Namespace(bar=None, foo=None) '1' None\n"
"Namespace(bar='1', foo=None) '2' '--foo'\n"
">>> args\n"
"Namespace(bar='1', foo='2')"

#: ../../library/argparse.rst:776
msgid "For more details, see :class:`Action`."
msgstr "Para más detalles, ver :class:`Action`."

#: ../../library/argparse.rst:782
msgid "nargs"
msgstr "nargs"

#: ../../library/argparse.rst:784
msgid ""
":class:`ArgumentParser` objects usually associate a single command-line "
"argument with a single action to be taken.  The ``nargs`` keyword argument "
"associates a different number of command-line arguments with a single "
"action. See also :ref:`specifying-ambiguous-arguments`. The supported values "
"are:"
msgstr ""
":class:`ArgumentParser` suelen asociar un único argumento de línea de "
"comandos con una única acción a realizar.  El argumento de palabra clave "
"``nargs`` asocia un número diferente de argumentos de línea de comandos con "
"una única acción. Véase también :ref:`specifying-ambiguous-arguments`. Los "
"valores admitidos son:"

#: ../../library/argparse.rst:789
msgid ""
"``N`` (an integer).  ``N`` arguments from the command line will be gathered "
"together into a list.  For example::"
msgstr ""
"``N`` (un número entero). ``N`` argumentos de la línea de comandos se "
"reunirán en una lista.  Por ejemplo::"

#: ../../library/argparse.rst:792
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', nargs=2)\n"
">>> parser.add_argument('bar', nargs=1)\n"
">>> parser.parse_args('c --foo a b'.split())\n"
"Namespace(bar=['c'], foo=['a', 'b'])"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', nargs=2)\n"
">>> parser.add_argument('bar', nargs=1)\n"
">>> parser.parse_args('c --foo a b'.split())\n"
"Namespace(bar=['c'], foo=['a', 'b'])"

#: ../../library/argparse.rst:798
msgid ""
"Note that ``nargs=1`` produces a list of one item.  This is different from "
"the default, in which the item is produced by itself."
msgstr ""
"Tenga en cuenta que ``nargs=1`` produce una lista de un elemento.  Esto es "
"diferente del valor por defecto, en el que el elemento se produce por sí "
"mismo."

#: ../../library/argparse.rst:803
msgid ""
"``'?'``. One argument will be consumed from the command line if possible, "
"and produced as a single item.  If no command-line argument is present, the "
"value from default_ will be produced.  Note that for optional arguments, "
"there is an additional case - the option string is present but not followed "
"by a command-line argument.  In this case the value from const_ will be "
"produced.  Some examples to illustrate this::"
msgstr ""
"``'?'``. Se consumirá un argumento de la línea de comandos si es posible, y "
"se producirá como un único elemento.  Si no hay ningún argumento en la línea "
"de órdenes, se producirá el valor de default_.  Tenga en cuenta que para los "
"argumentos opcionales, hay un caso adicional - la cadena de opción está "
"presente, pero no seguida de un argumento de línea de comandos.  En este "
"caso, se producirá el valor de const_.  Algunos ejemplos para ilustrar esto::"

#: ../../library/argparse.rst:810
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', nargs='?', const='c', default='d')\n"
">>> parser.add_argument('bar', nargs='?', default='d')\n"
">>> parser.parse_args(['XX', '--foo', 'YY'])\n"
"Namespace(bar='XX', foo='YY')\n"
">>> parser.parse_args(['XX', '--foo'])\n"
"Namespace(bar='XX', foo='c')\n"
">>> parser.parse_args([])\n"
"Namespace(bar='d', foo='d')"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', nargs='?', const='c', default='d')\n"
">>> parser.add_argument('bar', nargs='?', default='d')\n"
">>> parser.parse_args(['XX', '--foo', 'YY'])\n"
"Namespace(bar='XX', foo='YY')\n"
">>> parser.parse_args(['XX', '--foo'])\n"
"Namespace(bar='XX', foo='c')\n"
">>> parser.parse_args([])\n"
"Namespace(bar='d', foo='d')"

#: ../../library/argparse.rst:820
msgid ""
"One of the more common uses of ``nargs='?'`` is to allow optional input and "
"output files::"
msgstr ""
"Uno de los usos más comunes de ``nargs='?'`` es permitir archivos de entrada "
"y salida opcionales::"

#: ../../library/argparse.rst:823
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('infile', nargs='?', type=argparse.FileType('r'),\n"
"...                     default=sys.stdin)\n"
">>> parser.add_argument('outfile', nargs='?', type=argparse.FileType('w'),\n"
"...                     default=sys.stdout)\n"
">>> parser.parse_args(['input.txt', 'output.txt'])\n"
"Namespace(infile=<_io.TextIOWrapper name='input.txt' encoding='UTF-8'>,\n"
"          outfile=<_io.TextIOWrapper name='output.txt' encoding='UTF-8'>)\n"
">>> parser.parse_args([])\n"
"Namespace(infile=<_io.TextIOWrapper name='<stdin>' encoding='UTF-8'>,\n"
"          outfile=<_io.TextIOWrapper name='<stdout>' encoding='UTF-8'>)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('infile', nargs='?', type=argparse.FileType('r'),\n"
"...                     default=sys.stdin)\n"
">>> parser.add_argument('outfile', nargs='?', type=argparse.FileType('w'),\n"
"...                     default=sys.stdout)\n"
">>> parser.parse_args(['input.txt', 'output.txt'])\n"
"Namespace(infile=<_io.TextIOWrapper name='input.txt' encoding='UTF-8'>,\n"
"          outfile=<_io.TextIOWrapper name='output.txt' encoding='UTF-8'>)\n"
">>> parser.parse_args([])\n"
"Namespace(infile=<_io.TextIOWrapper name='<stdin>' encoding='UTF-8'>,\n"
"          outfile=<_io.TextIOWrapper name='<stdout>' encoding='UTF-8'>)"

#: ../../library/argparse.rst:837
msgid ""
"``'*'``.  All command-line arguments present are gathered into a list.  Note "
"that it generally doesn't make much sense to have more than one positional "
"argument with ``nargs='*'``, but multiple optional arguments with "
"``nargs='*'`` is possible.  For example::"
msgstr ""
"``'*'``.  Todos los argumentos de línea de comandos presentes se reúnen en "
"una lista.  Tenga en cuenta que generalmente no tiene mucho sentido tener "
"más de un argumento posicional con ``nargs='*'``, pero es posible tener "
"múltiples argumentos opcionales con ``nargs='*'``.  Por ejemplo::"

#: ../../library/argparse.rst:842
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', nargs='*')\n"
">>> parser.add_argument('--bar', nargs='*')\n"
">>> parser.add_argument('baz', nargs='*')\n"
">>> parser.parse_args('a b --foo x y --bar 1 2'.split())\n"
"Namespace(bar=['1', '2'], baz=['a', 'b'], foo=['x', 'y'])"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', nargs='*')\n"
">>> parser.add_argument('--bar', nargs='*')\n"
">>> parser.add_argument('baz', nargs='*')\n"
">>> parser.parse_args('a b --foo x y --bar 1 2'.split())\n"
"Namespace(bar=['1', '2'], baz=['a', 'b'], foo=['x', 'y'])"

#: ../../library/argparse.rst:851
msgid ""
"``'+'``. Just like ``'*'``, all command-line args present are gathered into "
"a list.  Additionally, an error message will be generated if there wasn't at "
"least one command-line argument present.  For example::"
msgstr ""
"``'+'``. Al igual que en ``'*'``, todos los argumentos de línea de comandos "
"presentes se recopilan en una lista.  Además, se generará un mensaje de "
"error si no hay al menos un argumento de línea de comandos presente.  Por "
"ejemplo::"

#: ../../library/argparse.rst:855
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('foo', nargs='+')\n"
">>> parser.parse_args(['a', 'b'])\n"
"Namespace(foo=['a', 'b'])\n"
">>> parser.parse_args([])\n"
"usage: PROG [-h] foo [foo ...]\n"
"PROG: error: the following arguments are required: foo"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('foo', nargs='+')\n"
">>> parser.parse_args(['a', 'b'])\n"
"Namespace(foo=['a', 'b'])\n"
">>> parser.parse_args([])\n"
"usage: PROG [-h] foo [foo ...]\n"
"PROG: error: the following arguments are required: foo"

#: ../../library/argparse.rst:863
msgid ""
"If the ``nargs`` keyword argument is not provided, the number of arguments "
"consumed is determined by the action_.  Generally this means a single "
"command-line argument will be consumed and a single item (not a list) will "
"be produced. Actions that do not consume command-line arguments (e.g. "
"``'store_const'``) set ``nargs=0``."
msgstr ""
"Si no se proporciona el argumento de la palabra clave ``nargs``, el número "
"de argumentos consumidos viene determinado por la acción_.  Por lo general, "
"esto significa que se consumirá un único argumento de línea de comandos y se "
"producirá un único elemento (no una lista). Las acciones que no consumen "
"argumentos de la línea de comandos (por ejemplo, ``'store_const'``) "
"establecen ``nargs=0``."

#: ../../library/argparse.rst:873
msgid "const"
msgstr "const"

#: ../../library/argparse.rst:875
msgid ""
"The ``const`` argument of :meth:`~ArgumentParser.add_argument` is used to "
"hold constant values that are not read from the command line but are "
"required for the various :class:`ArgumentParser` actions.  The two most "
"common uses of it are:"
msgstr ""
"El argumento ``const`` de :meth:`~ArgumentParser.add_argument` se utiliza "
"para mantener valores constantes que no se leen desde la línea de comandos "
"pero que son necesarios para las distintas acciones de :class:"
"`ArgumentParser`.  Los dos usos más comunes son:"

#: ../../library/argparse.rst:879
msgid ""
"When :meth:`~ArgumentParser.add_argument` is called with "
"``action='store_const'`` or ``action='append_const'``.  These actions add "
"the ``const`` value to one of the attributes of the object returned by :meth:"
"`~ArgumentParser.parse_args`. See the action_ description for examples. If "
"``const`` is not provided to :meth:`~ArgumentParser.add_argument`, it will "
"receive a default value of ``None``."
msgstr ""
"Cuando se llama a :meth:`~ArgumentParser.add_argument` con "
"``action='store_const'`` o ``action='append_const'``. Estas acciones añaden "
"el valor ``const`` a uno de los atributos del objeto devuelto por :meth:"
"`~ArgumentParser.parse_args`. Consulte la descripción de action_ para ver "
"ejemplos. Si no se proporciona ``const`` a :meth:`~ArgumentParser."
"add_argument`, recibirá un valor por defecto de ``None``."

#: ../../library/argparse.rst:887
msgid ""
"When :meth:`~ArgumentParser.add_argument` is called with option strings "
"(like ``-f`` or ``--foo``) and ``nargs='?'``.  This creates an optional "
"argument that can be followed by zero or one command-line arguments. When "
"parsing the command line, if the option string is encountered with no "
"command-line argument following it, the value of ``const`` will be assumed "
"to be ``None`` instead.  See the nargs_ description for examples."
msgstr ""
"Cuando se llama a :meth:`~ArgumentParser.add_argument` con cadenas de "
"opciones (como ``-f`` o ``--foo``) y ``nargs='?'``.  Esto crea un argumento "
"opcional que puede ir seguido de cero o un argumento de línea de comandos. "
"Al analizar la línea de comandos, si se encuentra la cadena de opciones sin "
"ningún argumento de línea de comandos a continuación, se asumirá que el "
"valor de ``const`` es ``None``.  Véanse ejemplos en la descripción de nargs_."

#: ../../library/argparse.rst:894
msgid ""
"``const=None`` by default, including when ``action='append_const'`` or "
"``action='store_const'``."
msgstr ""
"``const=None`` por defecto, incluso en ``action='append_const'`` o "
"``action='store_const'``."

#: ../../library/argparse.rst:901
msgid "default"
msgstr "por defecto"

#: ../../library/argparse.rst:903
msgid ""
"All optional arguments and some positional arguments may be omitted at the "
"command line.  The ``default`` keyword argument of :meth:`~ArgumentParser."
"add_argument`, whose value defaults to ``None``, specifies what value should "
"be used if the command-line argument is not present. For optional arguments, "
"the ``default`` value is used when the option string was not present at the "
"command line::"
msgstr ""
"Todos los argumentos opcionales y algunos argumentos posicionales pueden "
"omitirse en la línea de comandos.  El argumento de palabra clave ``default`` "
"de :meth:`~ArgumentParser.add_argument`, cuyo valor por defecto es ``None``, "
"especifica qué valor debe utilizarse si el argumento de la línea de comandos "
"no está presente. Para los argumentos opcionales, se utiliza el valor "
"``default`` cuando la cadena de opciones no estaba presente en la línea de "
"comandos::"

#: ../../library/argparse.rst:910
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default=42)\n"
">>> parser.parse_args(['--foo', '2'])\n"
"Namespace(foo='2')\n"
">>> parser.parse_args([])\n"
"Namespace(foo=42)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default=42)\n"
">>> parser.parse_args(['--foo', '2'])\n"
"Namespace(foo='2')\n"
">>> parser.parse_args([])\n"
"Namespace(foo=42)"

#: ../../library/argparse.rst:917
msgid ""
"If the target namespace already has an attribute set, the action *default* "
"will not overwrite it::"
msgstr ""
"Si el espacio de nombres de destino ya tiene un atributo establecido, la "
"acción *default* no lo sobrescribirá::"

#: ../../library/argparse.rst:920
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default=42)\n"
">>> parser.parse_args([], namespace=argparse.Namespace(foo=101))\n"
"Namespace(foo=101)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default=42)\n"
">>> parser.parse_args([], namespace=argparse.Namespace(foo=101))\n"
"Namespace(foo=101)"

#: ../../library/argparse.rst:925
msgid ""
"If the ``default`` value is a string, the parser parses the value as if it "
"were a command-line argument.  In particular, the parser applies any type_ "
"conversion argument, if provided, before setting the attribute on the :class:"
"`Namespace` return value.  Otherwise, the parser uses the value as is::"
msgstr ""
"Si el valor de ``default`` es una cadena, el analizador sintáctico analiza "
"el valor como si fuera un argumento de línea de comandos.  En particular, el "
"analizador aplica cualquier argumento de conversión type_, si se "
"proporciona, antes de establecer el atributo en el valor de retorno de :"
"class:`Namespace`.  De lo contrario, el analizador utiliza el valor tal "
"cual::"

#: ../../library/argparse.rst:930
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--length', default='10', type=int)\n"
">>> parser.add_argument('--width', default=10.5, type=int)\n"
">>> parser.parse_args()\n"
"Namespace(length=10, width=10.5)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--length', default='10', type=int)\n"
">>> parser.add_argument('--width', default=10.5, type=int)\n"
">>> parser.parse_args()\n"
"Namespace(length=10, width=10.5)"

#: ../../library/argparse.rst:936
msgid ""
"For positional arguments with nargs_ equal to ``?`` or ``*``, the "
"``default`` value is used when no command-line argument was present::"
msgstr ""
"Para argumentos posicionales con nargs_ igual a ``?`` o ``*``, se utiliza el "
"valor ``default`` cuando no había ningún argumento en la línea de comandos::"

#: ../../library/argparse.rst:939
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('foo', nargs='?', default=42)\n"
">>> parser.parse_args(['a'])\n"
"Namespace(foo='a')\n"
">>> parser.parse_args([])\n"
"Namespace(foo=42)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('foo', nargs='?', default=42)\n"
">>> parser.parse_args(['a'])\n"
"Namespace(foo='a')\n"
">>> parser.parse_args([])\n"
"Namespace(foo=42)"

#: ../../library/argparse.rst:946
msgid ""
"For required_ arguments, the ``default`` value is ignored. For example, this "
"applies to positional arguments with nargs_ values other than ``?`` or "
"``*``, or optional arguments marked as ``required=True``."
msgstr ""
"En el caso de los argumentos requeridos, se ignora el valor ``default``. Por "
"ejemplo, esto se aplica a argumentos posicionales con valores nargs_ "
"distintos de ``?`` o ``*``, o argumentos opcionales marcados como "
"``required=True``."

#: ../../library/argparse.rst:950
msgid ""
"Providing ``default=argparse.SUPPRESS`` causes no attribute to be added if "
"the command-line argument was not present::"
msgstr ""
"Si se proporciona ``default=argparse.SUPPRESS``, no se añadirá ningún "
"atributo si el argumento de la línea de comandos no estaba presente::"

#: ../../library/argparse.rst:953
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default=argparse.SUPPRESS)\n"
">>> parser.parse_args([])\n"
"Namespace()\n"
">>> parser.parse_args(['--foo', '1'])\n"
"Namespace(foo='1')"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default=argparse.SUPPRESS)\n"
">>> parser.parse_args([])\n"
"Namespace()\n"
">>> parser.parse_args(['--foo', '1'])\n"
"Namespace(foo='1')"

#: ../../library/argparse.rst:964
msgid "type"
msgstr "tipo"

#: ../../library/argparse.rst:966
msgid ""
"By default, the parser reads command-line arguments in as simple strings. "
"However, quite often the command-line string should instead be interpreted "
"as another type, such as a :class:`float` or :class:`int`.  The ``type`` "
"keyword for :meth:`~ArgumentParser.add_argument` allows any necessary type-"
"checking and type conversions to be performed."
msgstr ""
"Por defecto, el analizador lee los argumentos de la línea de comandos como "
"cadenas simples. Sin embargo, a menudo la cadena de la línea de comandos "
"debe interpretarse como otro tipo, como :class:`float` o :class:`int`. La "
"palabra clave ``type`` para :meth:`~ArgumentParser.add_argument` permite "
"realizar cualquier comprobación de tipo y conversión necesaria."

#: ../../library/argparse.rst:972
msgid ""
"If the type_ keyword is used with the default_ keyword, the type converter "
"is only applied if the default is a string."
msgstr ""
"Si se utiliza type_ keyword con default_ keyword, el conversor de tipo sólo "
"se aplica si el valor por defecto es una cadena."

#: ../../library/argparse.rst:975
msgid ""
"The argument to ``type`` can be a callable that accepts a single string or "
"the name of a registered type (see :meth:`~ArgumentParser.register`) If the "
"function raises :exc:`ArgumentTypeError`, :exc:`TypeError`, or :exc:"
"`ValueError`, the exception is caught and a nicely formatted error message "
"is displayed. Other exception types are not handled."
msgstr ""
"El argumento de ``type`` puede ser un callable que acepte una única cadena o "
"el nombre de un tipo registrado (véase :meth:`~ArgumentParser.register`) Si "
"la función lanza :exc:`ArgumentTypeError`, :exc:`TypeError`, o :exc:"
"`ValueError`, se captura la excepción y se muestra un mensaje de error con "
"un formato agradable. No se tratan otros tipos de excepción."

#: ../../library/argparse.rst:981
msgid "Common built-in types and functions can be used as type converters:"
msgstr ""
"Los tipos y funciones comunes incorporados pueden utilizarse como "
"convertidores de tipos:"

#: ../../library/argparse.rst:983
msgid ""
"import argparse\n"
"import pathlib\n"
"\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument('count', type=int)\n"
"parser.add_argument('distance', type=float)\n"
"parser.add_argument('street', type=ascii)\n"
"parser.add_argument('code_point', type=ord)\n"
"parser.add_argument('dest_file', type=argparse.FileType('w', "
"encoding='latin-1'))\n"
"parser.add_argument('datapath', type=pathlib.Path)"
msgstr ""
"import argparse\n"
"import pathlib\n"
"\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument('count', type=int)\n"
"parser.add_argument('distance', type=float)\n"
"parser.add_argument('street', type=ascii)\n"
"parser.add_argument('code_point', type=ord)\n"
"parser.add_argument('dest_file', type=argparse.FileType('w', "
"encoding='latin-1'))\n"
"parser.add_argument('datapath', type=pathlib.Path)"

#: ../../library/argparse.rst:996
msgid "User defined functions can be used as well:"
msgstr "También pueden utilizarse funciones definidas por el usuario:"

#: ../../library/argparse.rst:998
msgid ""
">>> def hyphenated(string):\n"
"...     return '-'.join([word[:4] for word in string.casefold().split()])\n"
"...\n"
">>> parser = argparse.ArgumentParser()\n"
">>> _ = parser.add_argument('short_title', type=hyphenated)\n"
">>> parser.parse_args(['\"The Tale of Two Cities\"'])\n"
"Namespace(short_title='\"the-tale-of-two-citi')"
msgstr ""
">>> def hyphenated(string):\n"
"...     return '-'.join([word[:4] for word in string.casefold().split()])\n"
"...\n"
">>> parser = argparse.ArgumentParser()\n"
">>> _ = parser.add_argument('short_title', type=hyphenated)\n"
">>> parser.parse_args(['\"The Tale of Two Cities\"'])\n"
"Namespace(short_title='\"the-tale-of-two-citi')"

#: ../../library/argparse.rst:1008
msgid ""
"The :func:`bool` function is not recommended as a type converter.  All it "
"does is convert empty strings to ``False`` and non-empty strings to "
"``True``. This is usually not what is desired."
msgstr ""
"La función :func:`bool` no se recomienda como conversor de tipos.  Lo único "
"que hace es convertir cadenas vacías a ``False`` y cadenas no vacías a "
"``True``. Esto no suele ser lo que se desea."

#: ../../library/argparse.rst:1012
msgid ""
"In general, the ``type`` keyword is a convenience that should only be used "
"for simple conversions that can only raise one of the three supported "
"exceptions. Anything with more interesting error-handling or resource "
"management should be done downstream after the arguments are parsed."
msgstr ""
"En general, la palabra clave ``type`` es una conveniencia que sólo debe "
"utilizarse para conversiones simples que sólo pueden lanzar una de las tres "
"excepciones soportadas. Todo lo que implique una gestión de errores o de "
"recursos más interesante debe hacerse después de analizar los argumentos."

#: ../../library/argparse.rst:1017
msgid ""
"For example, JSON or YAML conversions have complex error cases that require "
"better reporting than can be given by the ``type`` keyword.  A :exc:`~json."
"JSONDecodeError` would not be well formatted and a :exc:`FileNotFoundError` "
"exception would not be handled at all."
msgstr ""
"Por ejemplo, las conversiones JSON o YAML tienen casos de error complejos "
"que requieren una mejor información que la que puede dar la palabra clave "
"``type``.  Un :exc:`~json.JSONDecodeError` no estaría bien formateado y una "
"excepción :exc:`FileNotFoundError` no se gestionaría en absoluto."

#: ../../library/argparse.rst:1022
msgid ""
"Even :class:`~argparse.FileType` has its limitations for use with the "
"``type`` keyword.  If one argument uses :class:`~argparse.FileType` and then "
"a subsequent argument fails, an error is reported but the file is not "
"automatically closed.  In this case, it would be better to wait until after "
"the parser has run and then use the :keyword:`with`-statement to manage the "
"files."
msgstr ""
"Incluso :class:`~argparse.FileType` tiene sus limitaciones para su uso con "
"la palabra clave ``type``.  Si un argumento utiliza :class:`~argparse."
"FileType` y luego falla un argumento posterior, se informa de un error pero "
"el fichero no se cierra automáticamente.  En este caso, sería mejor esperar "
"hasta que el analizador sintáctico se haya ejecutado y luego utilizar la "
"sentencia :keyword:`with` para gestionar los archivos."

#: ../../library/argparse.rst:1029
msgid ""
"For type checkers that simply check against a fixed set of values, consider "
"using the choices_ keyword instead."
msgstr ""
"Para los verificadores de tipos que simplemente comparan con un conjunto "
"fijo de valores, considere usar la palabra choices_ keyword en su lugar."

#: ../../library/argparse.rst:1036
msgid "choices"
msgstr "opciones"

#: ../../library/argparse.rst:1038
msgid ""
"Some command-line arguments should be selected from a restricted set of "
"values. These can be handled by passing a sequence object as the *choices* "
"keyword argument to :meth:`~ArgumentParser.add_argument`.  When the command "
"line is parsed, argument values will be checked, and an error message will "
"be displayed if the argument was not one of the acceptable values::"
msgstr ""
"Algunos argumentos de la línea de órdenes deben seleccionarse a partir de un "
"conjunto restringido de valores. Esto puede hacerse pasando un objeto de "
"secuencia como argumento de la palabra clave *choices* a :meth:"
"`~ArgumentParser.add_argument`. Cuando se analiza la línea de órdenes, se "
"comprueban los valores de los argumentos y se muestra un mensaje de error si "
"el argumento no es uno de los valores aceptables::"

#: ../../library/argparse.rst:1044
msgid ""
">>> parser = argparse.ArgumentParser(prog='game.py')\n"
">>> parser.add_argument('move', choices=['rock', 'paper', 'scissors'])\n"
">>> parser.parse_args(['rock'])\n"
"Namespace(move='rock')\n"
">>> parser.parse_args(['fire'])\n"
"usage: game.py [-h] {rock,paper,scissors}\n"
"game.py: error: argument move: invalid choice: 'fire' (choose from 'rock',\n"
"'paper', 'scissors')"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='game.py')\n"
">>> parser.add_argument('move', choices=['rock', 'paper', 'scissors'])\n"
">>> parser.parse_args(['rock'])\n"
"Namespace(move='rock')\n"
">>> parser.parse_args(['fire'])\n"
"usage: game.py [-h] {rock,paper,scissors}\n"
"game.py: error: argument move: invalid choice: 'fire' (choose from 'rock',\n"
"'paper', 'scissors')"

#: ../../library/argparse.rst:1053
msgid ""
"Note that inclusion in the *choices* sequence is checked after any type_ "
"conversions have been performed, so the type of the objects in the *choices* "
"sequence should match the type_ specified."
msgstr ""
"Tenga en cuenta que la inclusión en la secuencia *choices* se comprueba "
"después de haber realizado cualquier trype_ conversions, por lo que el tipo "
"de los objetos de la secuencia *choices* debe coincidir con el type_ "
"especificado."

#: ../../library/argparse.rst:1057
msgid ""
"Any sequence can be passed as the *choices* value, so :class:`list` "
"objects, :class:`tuple` objects, and custom sequences are all supported."
msgstr ""
"Se puede pasar cualquier secuencia como valor de *choices*, por lo que se "
"admiten objetos de :class:`list`, objetos de :class:`tuple` y secuencias "
"personalizadas."

#: ../../library/argparse.rst:1060
msgid ""
"Use of :class:`enum.Enum` is not recommended because it is difficult to "
"control its appearance in usage, help, and error messages."
msgstr ""
"No se recomienda el uso de :class:`enum.Enum` porque es difícil controlar su "
"aparición en los mensajes de uso, ayuda y error."

#: ../../library/argparse.rst:1063
msgid ""
"Formatted choices override the default *metavar* which is normally derived "
"from *dest*.  This is usually what you want because the user never sees the "
"*dest* parameter.  If this display isn't desirable (perhaps because there "
"are many choices), just specify an explicit metavar_."
msgstr ""
"Las opciones formateadas anulan el *metavar* por defecto, que normalmente se "
"deriva de *dest*.  Esto es normalmente lo que usted quiere porque el usuario "
"nunca ve el parámetro *dest*.  Si esta visualización no es deseable (quizás "
"porque hay muchas opciones), simplemente especifique un metavar_ explícito."

#: ../../library/argparse.rst:1072
msgid "required"
msgstr "obligatorio"

#: ../../library/argparse.rst:1074
msgid ""
"In general, the :mod:`!argparse` module assumes that flags like ``-f`` and "
"``--bar`` indicate *optional* arguments, which can always be omitted at the "
"command line. To make an option *required*, ``True`` can be specified for "
"the ``required=`` keyword argument to :meth:`~ArgumentParser.add_argument`::"
msgstr ""
"En general, el módulo :mod:`!argparse` asume que banderas como ``-f`` y ``--"
"bar`` indican argumentos *opcionales*, que siempre pueden omitirse en la "
"línea de órdenes. Para que una opción sea *requerida*, se puede especificar "
"``True`` para el argumento de palabra clave ``required=`` a :meth:"
"`~ArgumentParser.add_argument`::"

#: ../../library/argparse.rst:1079
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', required=True)\n"
">>> parser.parse_args(['--foo', 'BAR'])\n"
"Namespace(foo='BAR')\n"
">>> parser.parse_args([])\n"
"usage: [-h] --foo FOO\n"
": error: the following arguments are required: --foo"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', required=True)\n"
">>> parser.parse_args(['--foo', 'BAR'])\n"
"Namespace(foo='BAR')\n"
">>> parser.parse_args([])\n"
"usage: [-h] --foo FOO\n"
": error: the following arguments are required: --foo"

#: ../../library/argparse.rst:1087
msgid ""
"As the example shows, if an option is marked as ``required``, :meth:"
"`~ArgumentParser.parse_args` will report an error if that option is not "
"present at the command line."
msgstr ""
"Como muestra el ejemplo, si una opción está marcada como ``required``, :meth:"
"`~ArgumentParser.parse_args` informará de un error si esa opción no está "
"presente en la línea de comandos."

#: ../../library/argparse.rst:1093
msgid ""
"Required options are generally considered bad form because users expect "
"*options* to be *optional*, and thus they should be avoided when possible."
msgstr ""
"Las opciones obligatorias suelen considerarse de mala calidad porque los "
"usuarios esperan que las *opciones* sean *opcionales*, por lo que deben "
"evitarse siempre que sea posible."

#: ../../library/argparse.rst:1100
msgid "help"
msgstr "ayuda"

#: ../../library/argparse.rst:1102
msgid ""
"The ``help`` value is a string containing a brief description of the "
"argument. When a user requests help (usually by using ``-h`` or ``--help`` "
"at the command line), these ``help`` descriptions will be displayed with "
"each argument."
msgstr ""
"El valor ``help`` es una cadena que contiene una breve descripción del "
"argumento. Cuando un usuario solicita ayuda (normalmente utilizando ``-h`` o "
"``--help`` en la línea de comandos), estas descripciones ``help`` se "
"mostrarán con cada argumento."

#: ../../library/argparse.rst:1107
msgid ""
"The ``help`` strings can include various format specifiers to avoid "
"repetition of things like the program name or the argument default_.  The "
"available specifiers include the program name, ``%(prog)s`` and most keyword "
"arguments to :meth:`~ArgumentParser.add_argument`, e.g. ``%(default)s``, "
"``%(type)s``, etc.::"
msgstr ""
"Las cadenas ``help`` pueden incluir varios especificadores de formato para "
"evitar la repetición de cosas como el nombre del programa o el argumento "
"default_.  Los especificadores disponibles incluyen el nombre del programa, "
"``%(prog)s`` y la mayoría de los argumentos de palabras clave de :meth:"
"`~ArgumentParser.add_argument`, por ejemplo ``%(default)s``, ``%(type)s``, "
"etc.::"

#: ../../library/argparse.rst:1112
msgid ""
">>> parser = argparse.ArgumentParser(prog='frobble')\n"
">>> parser.add_argument('bar', nargs='?', type=int, default=42,\n"
"...                     help='the bar to %(prog)s (default: %(default)s)')\n"
">>> parser.print_help()\n"
"usage: frobble [-h] [bar]\n"
"\n"
"positional arguments:\n"
" bar     the bar to frobble (default: 42)\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='frobble')\n"
">>> parser.add_argument('bar', nargs='?', type=int, default=42,\n"
"...                     help='the bar to %(prog)s (default: %(default)s)')\n"
">>> parser.print_help()\n"
"usage: frobble [-h] [bar]\n"
"\n"
"positional arguments:\n"
" bar     the bar to frobble (default: 42)\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit"

#: ../../library/argparse.rst:1124
msgid ""
"As the help string supports %-formatting, if you want a literal ``%`` to "
"appear in the help string, you must escape it as ``%%``."
msgstr ""
"Como la cadena de ayuda admite %-formatting, si desea que aparezca un "
"literal ``%`` en la cadena de ayuda, debe eludir como ``%%``."

#: ../../library/argparse.rst:1127
msgid ""
":mod:`!argparse` supports silencing the help entry for certain options, by "
"setting the ``help`` value to ``argparse.SUPPRESS``::"
msgstr ""
":mod:`!argparse` permite silenciar la entrada de ayuda para determinadas "
"opciones, estableciendo el valor ``help`` en ``argparse.SUPPRESS``::"

#: ../../library/argparse.rst:1130
msgid ""
">>> parser = argparse.ArgumentParser(prog='frobble')\n"
">>> parser.add_argument('--foo', help=argparse.SUPPRESS)\n"
">>> parser.print_help()\n"
"usage: frobble [-h]\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='frobble')\n"
">>> parser.add_argument('--foo', help=argparse.SUPPRESS)\n"
">>> parser.print_help()\n"
"usage: frobble [-h]\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit"

#: ../../library/argparse.rst:1142
msgid "metavar"
msgstr "metavar"

#: ../../library/argparse.rst:1144
msgid ""
"When :class:`ArgumentParser` generates help messages, it needs some way to "
"refer to each expected argument.  By default, :class:`!ArgumentParser` "
"objects use the dest_ value as the \"name\" of each object.  By default, for "
"positional argument actions, the dest_ value is used directly, and for "
"optional argument actions, the dest_ value is uppercased.  So, a single "
"positional argument with ``dest='bar'`` will be referred to as ``bar``. A "
"single optional argument ``--foo`` that should be followed by a single "
"command-line argument will be referred to as ``FOO``.  An example::"
msgstr ""
"Cuando :class:`ArgumentParser` genera mensajes de ayuda, necesita alguna "
"forma de referirse a cada argumento esperado.  Por defecto, los objetos de :"
"class:`!ArgumentParser` utilizan el valor dest_ como \"nombre\" de cada "
"objeto.  Por defecto, para las acciones con argumentos posicionales, el "
"valor dest_ se utiliza directamente, y para las acciones con argumentos "
"opcionales, el valor dest_ se escribe en mayúsculas.  Así, un único "
"argumento posicional con ``dest='bar'`` se denominará ``bar``. Un único "
"argumento opcional ``--foo`` que vaya seguido de un único argumento de línea "
"de comandos se denominará ``FOO``.  Un ejemplo::"

#: ../../library/argparse.rst:1153
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo')\n"
">>> parser.add_argument('bar')\n"
">>> parser.parse_args('X --foo Y'.split())\n"
"Namespace(bar='X', foo='Y')\n"
">>> parser.print_help()\n"
"usage:  [-h] [--foo FOO] bar\n"
"\n"
"positional arguments:\n"
" bar\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" --foo FOO"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo')\n"
">>> parser.add_argument('bar')\n"
">>> parser.parse_args('X --foo Y'.split())\n"
"Namespace(bar='X', foo='Y')\n"
">>> parser.print_help()\n"
"usage:  [-h] [--foo FOO] bar\n"
"\n"
"positional arguments:\n"
" bar\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" --foo FOO"

#: ../../library/argparse.rst:1168
msgid "An alternative name can be specified with ``metavar``::"
msgstr "Se puede especificar un nombre alternativo con ``metavar``::"

#: ../../library/argparse.rst:1170
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', metavar='YYY')\n"
">>> parser.add_argument('bar', metavar='XXX')\n"
">>> parser.parse_args('X --foo Y'.split())\n"
"Namespace(bar='X', foo='Y')\n"
">>> parser.print_help()\n"
"usage:  [-h] [--foo YYY] XXX\n"
"\n"
"positional arguments:\n"
" XXX\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" --foo YYY"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', metavar='YYY')\n"
">>> parser.add_argument('bar', metavar='XXX')\n"
">>> parser.parse_args('X --foo Y'.split())\n"
"Namespace(bar='X', foo='Y')\n"
">>> parser.print_help()\n"
"usage:  [-h] [--foo YYY] XXX\n"
"\n"
"positional arguments:\n"
" XXX\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" --foo YYY"

#: ../../library/argparse.rst:1185
msgid ""
"Note that ``metavar`` only changes the *displayed* name - the name of the "
"attribute on the :meth:`~ArgumentParser.parse_args` object is still "
"determined by the dest_ value."
msgstr ""
"Tenga en cuenta que ``metavar`` sólo cambia el nombre *visualizado* - el "
"nombre del atributo en el objeto :meth:`~ArgumentParser.parse_args` sigue "
"estando determinado por el dest_ value."

#: ../../library/argparse.rst:1189
msgid ""
"Different values of ``nargs`` may cause the metavar to be used multiple "
"times. Providing a tuple to ``metavar`` specifies a different display for "
"each of the arguments::"
msgstr ""
"Diferentes valores de ``nargs`` pueden hacer que la metavar se utilice "
"varias veces. Proporcionar una tupla a ``metavar`` especifica una "
"visualización diferente para cada uno de los argumentos::"

#: ../../library/argparse.rst:1193
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-x', nargs=2)\n"
">>> parser.add_argument('--foo', nargs=2, metavar=('bar', 'baz'))\n"
">>> parser.print_help()\n"
"usage: PROG [-h] [-x X X] [--foo bar baz]\n"
"\n"
"options:\n"
" -h, --help     show this help message and exit\n"
" -x X X\n"
" --foo bar baz"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-x', nargs=2)\n"
">>> parser.add_argument('--foo', nargs=2, metavar=('bar', 'baz'))\n"
">>> parser.print_help()\n"
"usage: PROG [-h] [-x X X] [--foo bar baz]\n"
"\n"
"options:\n"
" -h, --help     show this help message and exit\n"
" -x X X\n"
" --foo bar baz"

#: ../../library/argparse.rst:1208
msgid "dest"
msgstr "dest"

#: ../../library/argparse.rst:1210
msgid ""
"Most :class:`ArgumentParser` actions add some value as an attribute of the "
"object returned by :meth:`~ArgumentParser.parse_args`.  The name of this "
"attribute is determined by the ``dest`` keyword argument of :meth:"
"`~ArgumentParser.add_argument`.  For positional argument actions, ``dest`` "
"is normally supplied as the first argument to :meth:`~ArgumentParser."
"add_argument`::"
msgstr ""
"La mayoría de las acciones :class:`ArgumentParser` añaden algún valor como "
"atributo del objeto devuelto por :meth:`~ArgumentParser.parse_args`.  El "
"nombre de este atributo viene determinado por el argumento de palabra clave "
"``dest`` de :meth:`~ArgumentParser.add_argument`. Para las acciones de "
"argumento posicional, ``dest`` se suministra normalmente como primer "
"argumento de :meth:`~ArgumentParser.add_argument`::"

#: ../../library/argparse.rst:1217
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('bar')\n"
">>> parser.parse_args(['XXX'])\n"
"Namespace(bar='XXX')"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('bar')\n"
">>> parser.parse_args(['XXX'])\n"
"Namespace(bar='XXX')"

#: ../../library/argparse.rst:1222
msgid ""
"For optional argument actions, the value of ``dest`` is normally inferred "
"from the option strings.  :class:`ArgumentParser` generates the value of "
"``dest`` by taking the first long option string and stripping away the "
"initial ``--`` string.  If no long option strings were supplied, ``dest`` "
"will be derived from the first short option string by stripping the initial "
"``-`` character.  Any internal ``-`` characters will be converted to ``_`` "
"characters to make sure the string is a valid attribute name.  The examples "
"below illustrate this behavior::"
msgstr ""
"Para las acciones con argumentos opcionales, el valor de ``dest`` se deduce "
"normalmente de las cadenas de opciones. :class:`ArgumentParser` genera el "
"valor de ``dest`` tomando la primera cadena de opciones larga y eliminando "
"la cadena inicial ``--``.  Si no se han proporcionado cadenas de opciones "
"largas, ``dest`` se obtendrá a partir de la primera cadena de opciones corta "
"eliminando el carácter ``-`` inicial.  Cualquier carácter interno de ``-`` "
"se convertirá en ``_`` para asegurarse de que la cadena es un nombre de "
"atributo válido.  Los siguientes ejemplos ilustran este comportamiento::"

#: ../../library/argparse.rst:1231
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('-f', '--foo-bar', '--foo')\n"
">>> parser.add_argument('-x', '-y')\n"
">>> parser.parse_args('-f 1 -x 2'.split())\n"
"Namespace(foo_bar='1', x='2')\n"
">>> parser.parse_args('--foo 1 -y 2'.split())\n"
"Namespace(foo_bar='1', x='2')"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('-f', '--foo-bar', '--foo')\n"
">>> parser.add_argument('-x', '-y')\n"
">>> parser.parse_args('-f 1 -x 2'.split())\n"
"Namespace(foo_bar='1', x='2')\n"
">>> parser.parse_args('--foo 1 -y 2'.split())\n"
"Namespace(foo_bar='1', x='2')"

#: ../../library/argparse.rst:1239
msgid "``dest`` allows a custom attribute name to be provided::"
msgstr "``dest`` permite proporcionar un nombre de atributo personalizado::"

#: ../../library/argparse.rst:1241
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', dest='bar')\n"
">>> parser.parse_args('--foo XXX'.split())\n"
"Namespace(bar='XXX')"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', dest='bar')\n"
">>> parser.parse_args('--foo XXX'.split())\n"
"Namespace(bar='XXX')"

#: ../../library/argparse.rst:1247
msgid "Action classes"
msgstr "Clases de acción"

#: ../../library/argparse.rst:1249
msgid ""
":class:`!Action` classes implement the Action API, a callable which returns "
"a callable which processes arguments from the command-line. Any object which "
"follows this API may be passed as the ``action`` parameter to :meth:"
"`~ArgumentParser.add_argument`."
msgstr ""
":class:`!Action` implementan la API de acción, una llamada que devuelve una "
"llamada que procesa argumentos de la línea de comandos. Cualquier objeto que "
"siga esta API puede pasarse como parámetro ``action`` a :meth:"
"`~ArgumentParser.add_argument`."

#: ../../library/argparse.rst:1258
msgid ""
":class:`!Action` objects are used by an :class:`ArgumentParser` to represent "
"the information needed to parse a single argument from one or more strings "
"from the command line. The :class:`!Action` class must accept the two "
"positional arguments plus any keyword arguments passed to :meth:"
"`ArgumentParser.add_argument` except for the ``action`` itself."
msgstr ""
":class:`!Action` son utilizados por :class:`ArgumentParser` para representar "
"la información necesaria para analizar un único argumento a partir de una o "
"más cadenas de la línea de comandos. La clase :class:`!Action` debe aceptar "
"los dos argumentos posicionales más cualquier argumento de palabra clave "
"pasado a :meth:`ArgumentParser.add_argument` excepto el propio ``action``."

#: ../../library/argparse.rst:1264
msgid ""
"Instances of :class:`!Action` (or return value of any callable to the "
"``action`` parameter) should have attributes :attr:`!dest`, :attr:`!"
"option_strings`, :attr:`!default`, :attr:`!type`, :attr:`!required`, :attr:`!"
"help`, etc. defined. The easiest way to ensure these attributes are defined "
"is to call :meth:`!Action.__init__`."
msgstr ""
"Las instancias de :class:`!Action` (o el valor de retorno de cualquier "
"llamada al parámetro ``action`` ) deben tener definidos los atributos :attr:"
"`!dest`, :attr:`!option_strings`, :attr:`!default`, :attr:`!type`, :attr:`!"
"required`, :attr:`!help`, etc. La forma más sencilla de asegurarse de que "
"estos atributos están definidos es llamar a :meth:`!Action.__init__`."

#: ../../library/argparse.rst:1272
msgid ""
":class:`!Action` instances should be callable, so subclasses must override "
"the :meth:`!__call__` method, which should accept four parameters:"
msgstr ""
":class:`!Action` deben ser invocables, por lo que las subclases deben anular "
"el método :meth:`!__call__`, que debe aceptar cuatro parámetros:"

#: ../../library/argparse.rst:1275
msgid ""
"*parser* - The :class:`ArgumentParser` object which contains this action."
msgstr "*parser* - El objeto :class:`ArgumentParser` que contiene esta acción."

#: ../../library/argparse.rst:1277
msgid ""
"*namespace* - The :class:`Namespace` object that will be returned by :meth:"
"`~ArgumentParser.parse_args`.  Most actions add an attribute to this object "
"using :func:`setattr`."
msgstr ""
"*namespace* - El objeto :class:`Namespace` que será devuelto por :meth:"
"`~ArgumentParser.parse_args`.  La mayoría de las acciones añaden un atributo "
"a este objeto utilizando :func:`setattr`."

#: ../../library/argparse.rst:1281
msgid ""
"*values* - The associated command-line arguments, with any type conversions "
"applied.  Type conversions are specified with the type_ keyword argument to :"
"meth:`~ArgumentParser.add_argument`."
msgstr ""
"*values* - Los argumentos asociados a la línea de comandos, con las "
"conversiones de tipo aplicadas.  Las conversiones de tipo se especifican con "
"el argumento type_ keyword de :meth:`~ArgumentParser.add_argument`."

#: ../../library/argparse.rst:1285
msgid ""
"*option_string* - The option string that was used to invoke this action. The "
"``option_string`` argument is optional, and will be absent if the action is "
"associated with a positional argument."
msgstr ""
"*option_string* - La cadena de opciones que se utilizó para invocar esta "
"acción. El argumento ``option_string`` es opcional, y estará ausente si la "
"acción está asociada a un argumento posicional."

#: ../../library/argparse.rst:1289
msgid ""
"The :meth:`!__call__` method may perform arbitrary actions, but will "
"typically set attributes on the ``namespace`` based on ``dest`` and "
"``values``."
msgstr ""
"El método :meth:`!__call__` puede realizar acciones arbitrarias, pero "
"normalmente fijará atributos en el ``namespace`` basándose en ``dest`` y "
"``values``."

#: ../../library/argparse.rst:1294
msgid ""
":class:`!Action` subclasses can define a :meth:`!format_usage` method that "
"takes no argument and return a string which will be used when printing the "
"usage of the program. If such method is not provided, a sensible default "
"will be used."
msgstr ""
":class:`!Action` las subclases pueden definir un método :meth:`!"
"format_usage` que no tome ningún argumento y devuelva una cadena que se "
"utilizará al imprimir el uso del programa. Si no se proporciona dicho "
"método, se utilizará un valor por defecto razonable."

#: ../../library/argparse.rst:1300
msgid "The parse_args() method"
msgstr "El método parse_args()"

#: ../../library/argparse.rst:1304
msgid ""
"Convert argument strings to objects and assign them as attributes of the "
"namespace.  Return the populated namespace."
msgstr ""
"Convierte las cadenas de los argumentos en objetos y los asigna como "
"atributos del espacio de nombres.  Devuelve el espacio de nombres rellenado."

#: ../../library/argparse.rst:1307
msgid ""
"Previous calls to :meth:`add_argument` determine exactly what objects are "
"created and how they are assigned. See the documentation for :meth:`!"
"add_argument` for details."
msgstr ""
"Las llamadas previas a :meth:`add_argument` determinan exactamente qué "
"objetos se crean y cómo se asignan. Consultar la documentación de :meth:`!"
"add_argument` para obtener más detalles."

#: ../../library/argparse.rst:1311
msgid ""
"args_ - List of strings to parse.  The default is taken from :data:`sys."
"argv`."
msgstr ""
"args_ - Lista de cadenas a analizar.  Por defecto se toma de :data:`sys."
"argv`."

#: ../../library/argparse.rst:1314
msgid ""
"namespace_ - An object to take the attributes.  The default is a new empty :"
"class:`Namespace` object."
msgstr ""
"namespace_ - Un objeto para tomar los atributos.  El valor predeterminado es "
"un nuevo objeto vacío :class:`Namespace`."

#: ../../library/argparse.rst:1319
msgid "Option value syntax"
msgstr "Sintaxis del valor de la opción"

#: ../../library/argparse.rst:1321
msgid ""
"The :meth:`~ArgumentParser.parse_args` method supports several ways of "
"specifying the value of an option (if it takes one).  In the simplest case, "
"the option and its value are passed as two separate arguments::"
msgstr ""
"El método :meth:`~ArgumentParser.parse_args` admite varias formas de "
"especificar el valor de una opción (si toma una).  En el caso más sencillo, "
"la opción y su valor se pasan como dos argumentos separados::"

#: ../../library/argparse.rst:1325
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-x')\n"
">>> parser.add_argument('--foo')\n"
">>> parser.parse_args(['-x', 'X'])\n"
"Namespace(foo=None, x='X')\n"
">>> parser.parse_args(['--foo', 'FOO'])\n"
"Namespace(foo='FOO', x=None)"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-x')\n"
">>> parser.add_argument('--foo')\n"
">>> parser.parse_args(['-x', 'X'])\n"
"Namespace(foo=None, x='X')\n"
">>> parser.parse_args(['--foo', 'FOO'])\n"
"Namespace(foo='FOO', x=None)"

#: ../../library/argparse.rst:1333
msgid ""
"For long options (options with names longer than a single character), the "
"option and value can also be passed as a single command-line argument, using "
"``=`` to separate them::"
msgstr ""
"Para opciones largas (opciones con nombres de más de un carácter), la opción "
"y el valor también pueden pasarse como un único argumento de línea de "
"comandos, utilizando ``=`` para separarlos::"

#: ../../library/argparse.rst:1337
msgid ""
">>> parser.parse_args(['--foo=FOO'])\n"
"Namespace(foo='FOO', x=None)"
msgstr ""
">>> parser.parse_args(['--foo=FOO'])\n"
"Namespace(foo='FOO', x=None)"

#: ../../library/argparse.rst:1340
msgid ""
"For short options (options only one character long), the option and its "
"value can be concatenated::"
msgstr ""
"Para opciones cortas (opciones de sólo un carácter de longitud), la opción y "
"su valor pueden concatenarse::"

#: ../../library/argparse.rst:1343
msgid ""
">>> parser.parse_args(['-xX'])\n"
"Namespace(foo=None, x='X')"
msgstr ""
">>> parser.parse_args(['-xX'])\n"
"Namespace(foo=None, x='X')"

#: ../../library/argparse.rst:1346
msgid ""
"Several short options can be joined together, using only a single ``-`` "
"prefix, as long as only the last option (or none of them) requires a value::"
msgstr ""
"Se pueden unir varias opciones cortas, utilizando un único prefijo ``-``, "
"siempre que sólo la última opción (o ninguna de ellas) requiera un valor::"

#: ../../library/argparse.rst:1349
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-x', action='store_true')\n"
">>> parser.add_argument('-y', action='store_true')\n"
">>> parser.add_argument('-z')\n"
">>> parser.parse_args(['-xyzZ'])\n"
"Namespace(x=True, y=True, z='Z')"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-x', action='store_true')\n"
">>> parser.add_argument('-y', action='store_true')\n"
">>> parser.add_argument('-z')\n"
">>> parser.parse_args(['-xyzZ'])\n"
"Namespace(x=True, y=True, z='Z')"

#: ../../library/argparse.rst:1358
msgid "Invalid arguments"
msgstr "Argumentos no válidos"

#: ../../library/argparse.rst:1360
msgid ""
"While parsing the command line, :meth:`~ArgumentParser.parse_args` checks "
"for a variety of errors, including ambiguous options, invalid types, invalid "
"options, wrong number of positional arguments, etc.  When it encounters such "
"an error, it exits and prints the error along with a usage message::"
msgstr ""
"Mientras analiza la línea de comandos, :meth:`~ArgumentParser.parse_args` "
"comprueba si hay una serie de errores, como opciones ambiguas, tipos no "
"válidos, opciones no válidas, número incorrecto de argumentos posicionales, "
"etc.  Cuando encuentra un error de este tipo, sale e imprime el error junto "
"con un mensaje de uso::"

#: ../../library/argparse.rst:1365
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('--foo', type=int)\n"
">>> parser.add_argument('bar', nargs='?')\n"
"\n"
">>> # invalid type\n"
">>> parser.parse_args(['--foo', 'spam'])\n"
"usage: PROG [-h] [--foo FOO] [bar]\n"
"PROG: error: argument --foo: invalid int value: 'spam'\n"
"\n"
">>> # invalid option\n"
">>> parser.parse_args(['--bar'])\n"
"usage: PROG [-h] [--foo FOO] [bar]\n"
"PROG: error: no such option: --bar\n"
"\n"
">>> # wrong number of arguments\n"
">>> parser.parse_args(['spam', 'badger'])\n"
"usage: PROG [-h] [--foo FOO] [bar]\n"
"PROG: error: extra arguments found: badger"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('--foo', type=int)\n"
">>> parser.add_argument('bar', nargs='?')\n"
"\n"
">>> # invalid type\n"
">>> parser.parse_args(['--foo', 'spam'])\n"
"usage: PROG [-h] [--foo FOO] [bar]\n"
"PROG: error: argument --foo: invalid int value: 'spam'\n"
"\n"
">>> # invalid option\n"
">>> parser.parse_args(['--bar'])\n"
"usage: PROG [-h] [--foo FOO] [bar]\n"
"PROG: error: no such option: --bar\n"
"\n"
">>> # wrong number of arguments\n"
">>> parser.parse_args(['spam', 'badger'])\n"
"usage: PROG [-h] [--foo FOO] [bar]\n"
"PROG: error: extra arguments found: badger"

#: ../../library/argparse.rst:1386
msgid "Arguments containing ``-``"
msgstr "Argumentos que contienen ``-``"

#: ../../library/argparse.rst:1388
msgid ""
"The :meth:`~ArgumentParser.parse_args` method attempts to give errors "
"whenever the user has clearly made a mistake, but some situations are "
"inherently ambiguous.  For example, the command-line argument ``-1`` could "
"either be an attempt to specify an option or an attempt to provide a "
"positional argument. The :meth:`~ArgumentParser.parse_args` method is "
"cautious here: positional arguments may only begin with ``-`` if they look "
"like negative numbers and there are no options in the parser that look like "
"negative numbers::"
msgstr ""
"El método :meth:`~ArgumentParser.parse_args` intenta dar errores siempre que "
"el usuario haya cometido claramente un error, pero algunas situaciones son "
"intrínsecamente ambiguas.  Por ejemplo, el argumento de línea de comandos "
"``-1`` podría ser un intento de especificar una opción o un intento de "
"proporcionar un argumento posicional. El método :meth:`~ArgumentParser."
"parse_args` es cauteloso en este caso: los argumentos posicionales sólo "
"pueden empezar por ``-`` si parecen números negativos y no hay opciones en "
"el analizador sintáctico que parezcan números negativos::"

#: ../../library/argparse.rst:1396
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-x')\n"
">>> parser.add_argument('foo', nargs='?')\n"
"\n"
">>> # no negative number options, so -1 is a positional argument\n"
">>> parser.parse_args(['-x', '-1'])\n"
"Namespace(foo=None, x='-1')\n"
"\n"
">>> # no negative number options, so -1 and -5 are positional arguments\n"
">>> parser.parse_args(['-x', '-1', '-5'])\n"
"Namespace(foo='-5', x='-1')\n"
"\n"
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-1', dest='one')\n"
">>> parser.add_argument('foo', nargs='?')\n"
"\n"
">>> # negative number options present, so -1 is an option\n"
">>> parser.parse_args(['-1', 'X'])\n"
"Namespace(foo=None, one='X')\n"
"\n"
">>> # negative number options present, so -2 is an option\n"
">>> parser.parse_args(['-2'])\n"
"usage: PROG [-h] [-1 ONE] [foo]\n"
"PROG: error: no such option: -2\n"
"\n"
">>> # negative number options present, so both -1s are options\n"
">>> parser.parse_args(['-1', '-1'])\n"
"usage: PROG [-h] [-1 ONE] [foo]\n"
"PROG: error: argument -1: expected one argument"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-x')\n"
">>> parser.add_argument('foo', nargs='?')\n"
"\n"
">>> # no negative number options, so -1 is a positional argument\n"
">>> parser.parse_args(['-x', '-1'])\n"
"Namespace(foo=None, x='-1')\n"
"\n"
">>> # no negative number options, so -1 and -5 are positional arguments\n"
">>> parser.parse_args(['-x', '-1', '-5'])\n"
"Namespace(foo='-5', x='-1')\n"
"\n"
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-1', dest='one')\n"
">>> parser.add_argument('foo', nargs='?')\n"
"\n"
">>> # opciones de números negativos presentes, entonces -1 es una opción\n"
">>> parser.parse_args(['-1', 'X'])\n"
"Namespace(foo=None, one='X')\n"
"\n"
">>> # opciones de números negativos presentes, entonces -2 es una opción\n"
">>> parser.parse_args(['-2'])\n"
"usage: PROG [-h] [-1 ONE] [foo]\n"
"PROG: error: no such option: -2\n"
"\n"
">>> # opciones de números negativos presentes, entonces -1s es una opción\n"
">>> parser.parse_args(['-1', '-1'])\n"
"usage: PROG [-h] [-1 ONE] [foo]\n"
"PROG: error: argument -1: expected one argument"

#: ../../library/argparse.rst:1426
msgid ""
"If you have positional arguments that must begin with ``-`` and don't look "
"like negative numbers, you can insert the pseudo-argument ``'--'`` which "
"tells :meth:`~ArgumentParser.parse_args` that everything after that is a "
"positional argument::"
msgstr ""
"Si tiene argumentos posicionales que deben empezar por ``-`` y no parecen "
"números negativos, puede insertar el pseudoargumento ``'--'`` que indica a :"
"meth:`~ArgumentParser.parse_args` que todo lo que viene después es un "
"argumento posicional::"

#: ../../library/argparse.rst:1431
msgid ""
">>> parser.parse_args(['--', '-f'])\n"
"Namespace(foo='-f', one=None)"
msgstr ""
">>> parser.parse_args(['--', '-f'])\n"
"Namespace(foo='-f', one=None)"

#: ../../library/argparse.rst:1434
msgid ""
"See also :ref:`the argparse howto on ambiguous arguments <specifying-"
"ambiguous-arguments>` for more details."
msgstr ""
"Ver también :ref:`the argparse howto on ambiguous arguments <specifying-"
"ambiguous-arguments>` para más detalles."

#: ../../library/argparse.rst:1440
msgid "Argument abbreviations (prefix matching)"
msgstr "Abreviaturas de los argumentos (coincidencia de prefijos)"

#: ../../library/argparse.rst:1442
msgid ""
"The :meth:`~ArgumentParser.parse_args` method :ref:`by default "
"<allow_abbrev>` allows long options to be abbreviated to a prefix, if the "
"abbreviation is unambiguous (the prefix matches a unique option)::"
msgstr ""
"El método :meth:`~ArgumentParser.parse_args`:ref:`by default  "
"<allow_abbrev>` permite abreviar opciones largas a un prefijo, si la "
"abreviatura no es ambigua (el prefijo coincide con una opción única)::"

#: ../../library/argparse.rst:1446
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-bacon')\n"
">>> parser.add_argument('-badger')\n"
">>> parser.parse_args('-bac MMM'.split())\n"
"Namespace(bacon='MMM', badger=None)\n"
">>> parser.parse_args('-bad WOOD'.split())\n"
"Namespace(bacon=None, badger='WOOD')\n"
">>> parser.parse_args('-ba BA'.split())\n"
"usage: PROG [-h] [-bacon BACON] [-badger BADGER]\n"
"PROG: error: ambiguous option: -ba could match -badger, -bacon"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-bacon')\n"
">>> parser.add_argument('-badger')\n"
">>> parser.parse_args('-bac MMM'.split())\n"
"Namespace(bacon='MMM', badger=None)\n"
">>> parser.parse_args('-bad WOOD'.split())\n"
"Namespace(bacon=None, badger='WOOD')\n"
">>> parser.parse_args('-ba BA'.split())\n"
"usage: PROG [-h] [-bacon BACON] [-badger BADGER]\n"
"PROG: error: ambiguous option: -ba could match -badger, -bacon"

#: ../../library/argparse.rst:1457
msgid ""
"An error is produced for arguments that could produce more than one options. "
"This feature can be disabled by setting :ref:`allow_abbrev` to ``False``."
msgstr ""
"Se produce un error para los argumentos que podrían producir más de una "
"opción. Esta función puede desactivarse configurando :ref:`allow_abbrev` "
"como ``False``."

#: ../../library/argparse.rst:1463
msgid "Beyond ``sys.argv``"
msgstr "Más allá de ``sys.argv``"

#: ../../library/argparse.rst:1465
msgid ""
"Sometimes it may be useful to have an :class:`ArgumentParser` parse "
"arguments other than those of :data:`sys.argv`.  This can be accomplished by "
"passing a list of strings to :meth:`~ArgumentParser.parse_args`.  This is "
"useful for testing at the interactive prompt::"
msgstr ""
"A veces puede ser útil hacer que :class:`ArgumentParser` analice argumentos "
"distintos de los de :data:`sys.argv`. Esto puede lograrse pasando una lista "
"de cadenas a :meth:`~ArgumentParser.parse_args`. Esto es útil para realizar "
"pruebas en el indicador interactivo::"

#: ../../library/argparse.rst:1470
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument(\n"
"...     'integers', metavar='int', type=int, choices=range(10),\n"
"...     nargs='+', help='an integer in the range 0..9')\n"
">>> parser.add_argument(\n"
"...     '--sum', dest='accumulate', action='store_const', const=sum,\n"
"...     default=max, help='sum the integers (default: find the max)')\n"
">>> parser.parse_args(['1', '2', '3', '4'])\n"
"Namespace(accumulate=<built-in function max>, integers=[1, 2, 3, 4])\n"
">>> parser.parse_args(['1', '2', '3', '4', '--sum'])\n"
"Namespace(accumulate=<built-in function sum>, integers=[1, 2, 3, 4])"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument(\n"
"...     'integers', metavar='int', type=int, choices=range(10),\n"
"...     nargs='+', help='an integer in the range 0..9')\n"
">>> parser.add_argument(\n"
"...     '--sum', dest='accumulate', action='store_const', const=sum,\n"
"...     default=max, help='sum the integers (default: find the max)')\n"
">>> parser.parse_args(['1', '2', '3', '4'])\n"
"Namespace(accumulate=<built-in function max>, integers=[1, 2, 3, 4])\n"
">>> parser.parse_args(['1', '2', '3', '4', '--sum'])\n"
"Namespace(accumulate=<built-in function sum>, integers=[1, 2, 3, 4])"

#: ../../library/argparse.rst:1485
msgid "The Namespace object"
msgstr "El objeto Namespace"

#: ../../library/argparse.rst:1489
msgid ""
"Simple class used by default by :meth:`~ArgumentParser.parse_args` to create "
"an object holding attributes and return it."
msgstr ""
"Clase simple utilizada por defecto por :meth:`~ArgumentParser.parse_args` "
"para crear un objeto con atributos y devolverlo."

#: ../../library/argparse.rst:1492
msgid ""
"This class is deliberately simple, just an :class:`object` subclass with a "
"readable string representation. If you prefer to have dict-like view of the "
"attributes, you can use the standard Python idiom, :func:`vars`::"
msgstr ""
"Esta clase es deliberadamente simple, sólo una subclase de :class:`object` "
"con una representación de cadena legible. Si prefieres tener una vista tipo "
"dict de los atributos, puedes usar el lenguaje estándar de Python, :func:"
"`vars`::"

#: ../../library/argparse.rst:1496
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo')\n"
">>> args = parser.parse_args(['--foo', 'BAR'])\n"
">>> vars(args)\n"
"{'foo': 'BAR'}"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo')\n"
">>> args = parser.parse_args(['--foo', 'BAR'])\n"
">>> vars(args)\n"
"{'foo': 'BAR'}"

#: ../../library/argparse.rst:1502
msgid ""
"It may also be useful to have an :class:`ArgumentParser` assign attributes "
"to an already existing object, rather than a new :class:`Namespace` object.  "
"This can be achieved by specifying the ``namespace=`` keyword argument::"
msgstr ""
"También puede resultar útil que :class:`ArgumentParser` asigne atributos a "
"un objeto ya existente, en lugar de a un nuevo objeto :class:`Namespace`.  "
"Esto puede lograrse especificando el argumento ``namespace=`` palabra clave::"

#: ../../library/argparse.rst:1506
msgid ""
">>> class C:\n"
"...     pass\n"
"...\n"
">>> c = C()\n"
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo')\n"
">>> parser.parse_args(args=['--foo', 'BAR'], namespace=c)\n"
">>> c.foo\n"
"'BAR'"
msgstr ""
">>> class C:\n"
"...     pass\n"
"...\n"
">>> c = C()\n"
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo')\n"
">>> parser.parse_args(args=['--foo', 'BAR'], namespace=c)\n"
">>> c.foo\n"
"'BAR'"

#: ../../library/argparse.rst:1518
msgid "Other utilities"
msgstr "Otros servicios"

#: ../../library/argparse.rst:1521
msgid "Sub-commands"
msgstr "Sub-commands"

#: ../../library/argparse.rst:1528
msgid ""
"Many programs split up their functionality into a number of subcommands, for "
"example, the ``svn`` program can invoke subcommands like ``svn checkout``, "
"``svn update``, and ``svn commit``.  Splitting up functionality this way can "
"be a particularly good idea when a program performs several different "
"functions which require different kinds of command-line arguments. :class:"
"`ArgumentParser` supports the creation of such subcommands with the :meth:`!"
"add_subparsers` method.  The :meth:`!add_subparsers` method is normally "
"called with no arguments and returns a special action object.  This object "
"has a single method, :meth:`~_SubParsersAction.add_parser`, which takes a "
"command name and any :class:`!ArgumentParser` constructor arguments, and "
"returns an :class:`!ArgumentParser` object that can be modified as usual."
msgstr ""
"Muchos programas dividen su funcionalidad en un número de subcomandos, por "
"ejemplo, el programa ``svn`` puede invocar subcomandos como ``svn "
"checkout``, ``svn update``, y ``svn commit``.  Dividir la funcionalidad de "
"esta manera puede ser una idea particularmente buena cuando un programa "
"realiza varias funciones diferentes que requieren diferentes tipos de "
"argumentos de línea de comandos. :class:`ArgumentParser` soporta la creación "
"de tales subcomandos con el método :meth:`!add_subparsers`.  El método :meth:"
"`!add_subparsers` se ejecuta normalmente sin argumentos y devuelve un objeto "
"de acción especial.  Este objeto tiene un único método, :meth:"
"`~_SubParsersAction.add_parser`, que toma un nombre de comando y cualquier "
"argumento del constructor :class:`!ArgumentParser`, y devuelve un objeto :"
"class:`!ArgumentParser` que puede modificarse como de costumbre."

#: ../../library/argparse.rst:1540
msgid "Description of parameters:"
msgstr "Descripción de los parámetros:"

#: ../../library/argparse.rst:1542
msgid ""
"*title* - title for the sub-parser group in help output; by default "
"\"subcommands\" if description is provided, otherwise uses title for "
"positional arguments"
msgstr ""
"*title* - título del subgrupo de analizadores en la ayuda; por defecto "
"\"subcommands\" si se proporciona la descripción, de lo contrario utiliza el "
"título para los argumentos posicionales."

#: ../../library/argparse.rst:1546
msgid ""
"*description* - description for the sub-parser group in help output, by "
"default ``None``"
msgstr ""
"*description* - descripción del subgrupo de analizadores en la ayuda, por "
"defecto ``None``"

#: ../../library/argparse.rst:1549
msgid ""
"*prog* - usage information that will be displayed with sub-command help, by "
"default the name of the program and any positional arguments before the "
"subparser argument"
msgstr ""
"*prog* - información de uso que se mostrará con la ayuda del subcomando, por "
"defecto el nombre del programa y cualquier argumento posicional antes del "
"argumento del subcomando."

#: ../../library/argparse.rst:1553
msgid ""
"*parser_class* - class which will be used to create sub-parser instances, by "
"default the class of the current parser (e.g. :class:`ArgumentParser`)"
msgstr ""
"*parser_class* - clase que se utilizará para crear instancias de sub-parser, "
"por defecto la clase del parser actual (ej. :class:`ArgumentParser`)"

#: ../../library/argparse.rst:1556
msgid ""
"action_ - the basic type of action to be taken when this argument is "
"encountered at the command line"
msgstr ""
"action_ - el tipo básico de acción que se llevará a cabo cuando se encuentre "
"este argumento en la línea de comandos"

#: ../../library/argparse.rst:1559
msgid ""
"dest_ - name of the attribute under which sub-command name will be stored; "
"by default ``None`` and no value is stored"
msgstr ""
"dest_ - nombre del atributo bajo el que se almacenará el nombre del "
"subcomando; por defecto ``None`` y no se almacena ningún valor."

#: ../../library/argparse.rst:1562
msgid ""
"required_ - Whether or not a subcommand must be provided, by default "
"``False`` (added in 3.7)"
msgstr ""
"required_ - Debe o no proporcionarse un subcomando, por defecto ``False`` "
"(añadido en 3.7)"

#: ../../library/argparse.rst:1565
msgid "help_ - help for sub-parser group in help output, by default ``None``"
msgstr ""
"help_ - ayuda para el grupo sub-parser en la salida de ayuda, por defecto "
"``None``"

#: ../../library/argparse.rst:1567
msgid ""
"metavar_ - string presenting available subcommands in help; by default it is "
"``None`` and presents subcommands in form {cmd1, cmd2, ..}"
msgstr ""
"metavar_ - cadena que presenta los subcomandos disponibles en la ayuda; por "
"defecto es ``None`` y presenta los subcomandos de la forma {cmd1, cmd2, ..}"

#: ../../library/argparse.rst:1570
msgid "Some example usage::"
msgstr "Algunos ejemplos de uso::"

#: ../../library/argparse.rst:1572
msgid ""
">>> # create the top-level parser\n"
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('--foo', action='store_true', help='foo help')\n"
">>> subparsers = parser.add_subparsers(help='subcommand help')\n"
">>>\n"
">>> # create the parser for the \"a\" command\n"
">>> parser_a = subparsers.add_parser('a', help='a help')\n"
">>> parser_a.add_argument('bar', type=int, help='bar help')\n"
">>>\n"
">>> # create the parser for the \"b\" command\n"
">>> parser_b = subparsers.add_parser('b', help='b help')\n"
">>> parser_b.add_argument('--baz', choices=('X', 'Y', 'Z'), help='baz "
"help')\n"
">>>\n"
">>> # parse some argument lists\n"
">>> parser.parse_args(['a', '12'])\n"
"Namespace(bar=12, foo=False)\n"
">>> parser.parse_args(['--foo', 'b', '--baz', 'Z'])\n"
"Namespace(baz='Z', foo=True)"
msgstr ""
">>> # crea el analizador de nivel superior\n"
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('--foo', action='store_true', help='foo help')\n"
">>> subparsers = parser.add_subparsers(help='ayuda subcomando')\n"
">>>\n"
">>> # crea el parser para el comando \"a\n"
">>> parser_a = subparsers.add_parser('a', help='ayuda a')\n"
">>> parser_a.add_argument('bar', type=int, help='ayuda bar')\n"
">>>\n"
">>> # crea el parser para el comando \"b\n"
">>> parser_b = subparsers.add_parser('b', help='ayuda b')\n"
">>> parser_b.add_argument('--baz', choices=('X', 'Y', 'Z'), help='baz "
"help')\n"
">>>\n"
">>> # analiza algunas listas de argumentos\n"
">>> parser.parse_args(['a', '12'])\n"
"Namespace(bar=12, foo=False)\n"
">>> parser.parse_args(['--foo', 'b', '--baz', 'Z'])\n"
"Namespace(baz='Z', foo=True)"

#: ../../library/argparse.rst:1591
msgid ""
"Note that the object returned by :meth:`parse_args` will only contain "
"attributes for the main parser and the subparser that was selected by the "
"command line (and not any other subparsers).  So in the example above, when "
"the ``a`` command is specified, only the ``foo`` and ``bar`` attributes are "
"present, and when the ``b`` command is specified, only the ``foo`` and "
"``baz`` attributes are present."
msgstr ""
"Tenga en cuenta que el objeto devuelto por :meth:`parse_args` sólo contendrá "
"atributos para el analizador sintáctico principal y el analizador sintáctico "
"secundario seleccionado por la línea de comandos (y no otros analizadores "
"sintácticos secundarios).  Así, en el ejemplo anterior, cuando se especifica "
"el comando ``a``, sólo están presentes los atributos ``foo`` y ``bar``, y "
"cuando se especifica el comando ``b``, sólo están presentes los atributos "
"``foo`` y ``baz``."

#: ../../library/argparse.rst:1598
msgid ""
"Similarly, when a help message is requested from a subparser, only the help "
"for that particular parser will be printed.  The help message will not "
"include parent parser or sibling parser messages.  (A help message for each "
"subparser command, however, can be given by supplying the ``help=`` argument "
"to :meth:`~_SubParsersAction.add_parser` as above.)"
msgstr ""
"Del mismo modo, cuando se solicita un mensaje de ayuda a un subanalizador, "
"sólo se imprimirá la ayuda de ese analizador en particular.  El mensaje de "
"ayuda no incluirá mensajes del analizador padre o de los analizadores "
"hermanos.  (Sin embargo, se puede dar un mensaje de ayuda para cada comando "
"de subanalizador proporcionando el argumento ``help=`` a :meth:"
"`~_SubParsersAction.add_parser` como se ha indicado anteriormente)."

#: ../../library/argparse.rst:1606
msgid ""
">>> parser.parse_args(['--help'])\n"
"usage: PROG [-h] [--foo] {a,b} ...\n"
"\n"
"positional arguments:\n"
"  {a,b}   subcommand help\n"
"    a     a help\n"
"    b     b help\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"  --foo   foo help\n"
"\n"
">>> parser.parse_args(['a', '--help'])\n"
"usage: PROG a [-h] bar\n"
"\n"
"positional arguments:\n"
"  bar     bar help\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"\n"
">>> parser.parse_args(['b', '--help'])\n"
"usage: PROG b [-h] [--baz {X,Y,Z}]\n"
"\n"
"options:\n"
"  -h, --help     show this help message and exit\n"
"  --baz {X,Y,Z}  baz help"
msgstr ""
">>> parser.parse_args(['--help'])\n"
"usage: PROG [-h] [--foo] {a,b} ...\n"
"\n"
"positional arguments:\n"
"  {a,b}   subcommand help\n"
"    a     a help\n"
"    b     b help\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"  --foo   foo help\n"
"\n"
">>> parser.parse_args(['a', '--help'])\n"
"usage: PROG a [-h] bar\n"
"\n"
"positional arguments:\n"
"  bar     bar help\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"\n"
">>> parser.parse_args(['b', '--help'])\n"
"usage: PROG b [-h] [--baz {X,Y,Z}]\n"
"\n"
"options:\n"
"  -h, --help     show this help message and exit\n"
"  --baz {X,Y,Z}  baz help"

#: ../../library/argparse.rst:1634
msgid ""
"The :meth:`add_subparsers` method also supports ``title`` and "
"``description`` keyword arguments.  When either is present, the subparser's "
"commands will appear in their own group in the help output.  For example::"
msgstr ""
"El método :meth:`add_subparsers` también admite los argumentos de palabra "
"clave ``title`` y ``description``.  Cuando cualquiera de ellos está "
"presente, los comandos del subcompletador aparecerán en su propio grupo en "
"la salida de ayuda.  Por ejemplo::"

#: ../../library/argparse.rst:1638
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers(title='subcommands',\n"
"...                                    description='valid subcommands',\n"
"...                                    help='additional help')\n"
">>> subparsers.add_parser('foo')\n"
">>> subparsers.add_parser('bar')\n"
">>> parser.parse_args(['-h'])\n"
"usage:  [-h] {foo,bar} ...\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"\n"
"subcommands:\n"
"  valid subcommands\n"
"\n"
"  {foo,bar}   additional help"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers(title='subcommands',\n"
"...                                    description='valid subcommands',\n"
"...                                    help='additional help')\n"
">>> subparsers.add_parser('foo')\n"
">>> subparsers.add_parser('bar')\n"
">>> parser.parse_args(['-h'])\n"
"usage:  [-h] {foo,bar} ...\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"\n"
"subcommands:\n"
"  valid subcommands\n"
"\n"
"  {foo,bar}   additional help"

#: ../../library/argparse.rst:1655
msgid ""
"Furthermore, ``add_parser`` supports an additional ``aliases`` argument, "
"which allows multiple strings to refer to the same subparser. This example, "
"like ``svn``, aliases ``co`` as a shorthand for ``checkout``::"
msgstr ""
"Además, ``add_parser`` admite un argumento adicional ``aliases``, que "
"permite que varias cadenas se refieran al mismo subcompletador. Este "
"ejemplo, al igual que ``svn``, utiliza el alias ``co`` como abreviatura de "
"``checkout``::"

#: ../../library/argparse.rst:1659
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers()\n"
">>> checkout = subparsers.add_parser('checkout', aliases=['co'])\n"
">>> checkout.add_argument('foo')\n"
">>> parser.parse_args(['co', 'bar'])\n"
"Namespace(foo='bar')"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers()\n"
">>> checkout = subparsers.add_parser('checkout', aliases=['co'])\n"
">>> checkout.add_argument('foo')\n"
">>> parser.parse_args(['co', 'bar'])\n"
"Namespace(foo='bar')"

#: ../../library/argparse.rst:1666
msgid ""
"One particularly effective way of handling sub-commands is to combine the "
"use of the :meth:`add_subparsers` method with calls to :meth:`set_defaults` "
"so that each subparser knows which Python function it should execute.  For "
"example::"
msgstr ""
"Una forma particularmente efectiva de manejar subcomandos es combinar el uso "
"del método :meth:`add_subparsers` con llamadas a :meth:`set_defaults` para "
"que cada subcompletador sepa qué función de Python debe ejecutar.  Por "
"ejemplo::"

#: ../../library/argparse.rst:1671
msgid ""
">>> # subcommand functions\n"
">>> def foo(args):\n"
"...     print(args.x * args.y)\n"
"...\n"
">>> def bar(args):\n"
"...     print('((%s))' % args.z)\n"
"...\n"
">>> # create the top-level parser\n"
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers(required=True)\n"
">>>\n"
">>> # create the parser for the \"foo\" command\n"
">>> parser_foo = subparsers.add_parser('foo')\n"
">>> parser_foo.add_argument('-x', type=int, default=1)\n"
">>> parser_foo.add_argument('y', type=float)\n"
">>> parser_foo.set_defaults(func=foo)\n"
">>>\n"
">>> # create the parser for the \"bar\" command\n"
">>> parser_bar = subparsers.add_parser('bar')\n"
">>> parser_bar.add_argument('z')\n"
">>> parser_bar.set_defaults(func=bar)\n"
">>>\n"
">>> # parse the args and call whatever function was selected\n"
">>> args = parser.parse_args('foo 1 -x 2'.split())\n"
">>> args.func(args)\n"
"2.0\n"
">>>\n"
">>> # parse the args and call whatever function was selected\n"
">>> args = parser.parse_args('bar XYZYX'.split())\n"
">>> args.func(args)\n"
"((XYZYX))"
msgstr ""
">>> # funciones de subcomando\n"
">>> def foo(args):\n"
"... print(args.x * args.y)\n"
"...\n"
">>> def bar(args):\n"
"... print('((%s))' % args.z)\n"
"...\n"
">>> # crea el analizador de nivel superior\n"
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers(required=True)\n"
">>>\n"
">>> # crea el parser para el comando \"foo\n"
">>> parser_foo = subparsers.add_parser('foo')\n"
">>> parser_foo.add_argument('-x', type=int, default=1)\n"
">>> parser_foo.add_argument('y', type=float)\n"
">>> parser_foo.set_defaults(func=foo)\n"
">>>\n"
">>> # crea el parser para el comando \"bar\n"
">>> parser_bar = subparsers.add_parser('bar')\n"
">>> parser_bar.add_argument('z')\n"
">>> parser_bar.set_defaults(func=bar)\n"
">>>\n"
">>> # analiza los argumentos y llama a la función seleccionada\n"
">>> args = parser.parse_args('foo 1 -x 2'.split())\n"
">>> args.func(args)\n"
"2.0\n"
">>>\n"
">>> # analiza los argumentos y llama a la función seleccionada\n"
">>> args = parser.parse_args('bar XYZYX'.split())\n"
">>> args.func(args)\n"
"((XYZYX))"

#: ../../library/argparse.rst:1703
msgid ""
"This way, you can let :meth:`parse_args` do the job of calling the "
"appropriate function after argument parsing is complete.  Associating "
"functions with actions like this is typically the easiest way to handle the "
"different actions for each of your subparsers.  However, if it is necessary "
"to check the name of the subparser that was invoked, the ``dest`` keyword "
"argument to the :meth:`add_subparsers` call will work::"
msgstr ""
"De esta forma, puedes dejar que :meth:`parse_args` se encargue de llamar a "
"la función apropiada una vez finalizado el análisis sintáctico de los "
"argumentos.  Asociar funciones con acciones de este tipo suele ser la forma "
"más sencilla de gestionar las distintas acciones para cada uno de los "
"subanalizadores.  Sin embargo, si es necesario comprobar el nombre del "
"subcompletador que se invocó, el argumento de palabra clave ``dest`` a la "
"llamada :meth:`add_subparsers` funcionará::"

#: ../../library/argparse.rst:1710
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers(dest='subparser_name')\n"
">>> subparser1 = subparsers.add_parser('1')\n"
">>> subparser1.add_argument('-x')\n"
">>> subparser2 = subparsers.add_parser('2')\n"
">>> subparser2.add_argument('y')\n"
">>> parser.parse_args(['2', 'frobble'])\n"
"Namespace(subparser_name='2', y='frobble')"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers(dest='nombre_subparser')\n"
">>> subparser1 = subparsers.add_parser('1')\n"
">>> subparser1.add_argument('-x')\n"
">>> subparser2 = subparsers.add_parser('2')\n"
">>> subparser2.add_argument('y')\n"
">>> parser.parse_args(['2', 'frobble'])\n"
"Namespace(nombre_parser='2', y='frobble')"

#: ../../library/argparse.rst:1719
msgid "New *required* keyword-only parameter."
msgstr "Nuevo parámetro *requerido* de sólo palabra clave."

#: ../../library/argparse.rst:1724
msgid "FileType objects"
msgstr "Objetos FileType"

#: ../../library/argparse.rst:1728
msgid ""
"The :class:`FileType` factory creates objects that can be passed to the type "
"argument of :meth:`ArgumentParser.add_argument`.  Arguments that have :class:"
"`FileType` objects as their type will open command-line arguments as files "
"with the requested modes, buffer sizes, encodings and error handling (see "
"the :func:`open` function for more details)::"
msgstr ""
"La fábrica :class:`FileType` crea objetos que pueden pasarse al argumento de "
"tipo de :meth:`ArgumentParser.add_argument`. Los argumentos que tengan como "
"tipo objetos :class:`FileType` abrirán los argumentos de la línea de "
"comandos como archivos con los modos, tamaños de búfer, codificaciones y "
"gestión de errores solicitados (véase la función :func:`open` para más "
"detalles)::"

#: ../../library/argparse.rst:1734
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--raw', type=argparse.FileType('wb', 0))\n"
">>> parser.add_argument('out', type=argparse.FileType('w', "
"encoding='UTF-8'))\n"
">>> parser.parse_args(['--raw', 'raw.dat', 'file.txt'])\n"
"Namespace(out=<_io.TextIOWrapper name='file.txt' mode='w' encoding='UTF-8'>, "
"raw=<_io.FileIO name='raw.dat' mode='wb'>)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--raw', type=argparse.FileType('wb', 0))\n"
">>> parser.add_argument('out', type=argparse.FileType('w', "
"encoding='UTF-8'))\n"
">>> parser.parse_args(['--raw', 'raw.dat', 'file.txt'])\n"
"Namespace(out=<_io.TextIOWrapper name='file.txt' mode='w' encoding='UTF-8'>, "
"raw=<_io.FileIO name='raw.dat' mode='wb'>)"

#: ../../library/argparse.rst:1740
msgid ""
"FileType objects understand the pseudo-argument ``'-'`` and automatically "
"convert this into :data:`sys.stdin` for readable :class:`FileType` objects "
"and :data:`sys.stdout` for writable :class:`FileType` objects::"
msgstr ""
"Los objetos FileType comprenden el pseudoargumento ``'-'`` y lo convierten "
"automáticamente en :data:`sys.stdin` para los objetos legibles :class:"
"`FileType` y en :data:`sys.stdout` para los objetos escribibles :class:"
"`FileType`::"

#: ../../library/argparse.rst:1744
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('infile', type=argparse.FileType('r'))\n"
">>> parser.parse_args(['-'])\n"
"Namespace(infile=<_io.TextIOWrapper name='<stdin>' encoding='UTF-8'>)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('infile', type=argparse.FileType('r'))\n"
">>> parser.parse_args(['-'])\n"
"Namespace(infile=<_io.TextIOWrapper name='<stdin>' encoding='UTF-8'>)"

#: ../../library/argparse.rst:1749
msgid "Added the *encodings* and *errors* parameters."
msgstr "Añadidos los parámetros *encodings* y *errors*."

#: ../../library/argparse.rst:1754
msgid "Argument groups"
msgstr "Grupos de argumentos"

#: ../../library/argparse.rst:1759
msgid ""
"By default, :class:`ArgumentParser` groups command-line arguments into "
"\"positional arguments\" and \"options\" when displaying help messages. When "
"there is a better conceptual grouping of arguments than this default one, "
"appropriate groups can be created using the :meth:`!add_argument_group` "
"method::"
msgstr ""
"Por defecto, :class:`ArgumentParser` agrupa los argumentos de la línea de "
"comandos en \"argumentos posicionales\" y \"opciones\" cuando muestra "
"mensajes de ayuda. Cuando exista una agrupación conceptual de argumentos "
"mejor que esta por defecto, se pueden crear grupos apropiados utilizando el "
"método :meth:`!add_argument_group`::"

#: ../../library/argparse.rst:1765
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)\n"
">>> group = parser.add_argument_group('group')\n"
">>> group.add_argument('--foo', help='foo help')\n"
">>> group.add_argument('bar', help='bar help')\n"
">>> parser.print_help()\n"
"usage: PROG [--foo FOO] bar\n"
"\n"
"group:\n"
"  bar    bar help\n"
"  --foo FOO  foo help"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)\n"
">>> group = parser.add_argument_group('group')\n"
">>> group.add_argument('--foo', help='foo help')\n"
">>> group.add_argument('bar', help='bar help')\n"
">>> parser.print_help()\n"
"usage: PROG [--foo FOO] bar\n"
"\n"
"group:\n"
"  bar    bar help\n"
"  --foo FOO  foo help"

#: ../../library/argparse.rst:1776
msgid ""
"The :meth:`add_argument_group` method returns an argument group object which "
"has an :meth:`~ArgumentParser.add_argument` method just like a regular :"
"class:`ArgumentParser`.  When an argument is added to the group, the parser "
"treats it just like a normal argument, but displays the argument in a "
"separate group for help messages.  The :meth:`!add_argument_group` method "
"accepts *title* and *description* arguments which can be used to customize "
"this display::"
msgstr ""
"El método :meth:`add_argument_group` devuelve un objeto de grupo de "
"argumentos que tiene un método :meth:`~ArgumentParser.add_argument` igual "
"que un :class:`ArgumentParser` normal.  Cuando se añade un argumento al "
"grupo, el analizador sintáctico lo trata como un argumento normal, pero "
"muestra el argumento en un grupo separado para los mensajes de ayuda.  El "
"método :meth:`!add_argument_group` acepta los argumentos *title* y "
"*description* que se pueden utilizar para personalizar esta visualización::"

#: ../../library/argparse.rst:1784
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)\n"
">>> group1 = parser.add_argument_group('group1', 'group1 description')\n"
">>> group1.add_argument('foo', help='foo help')\n"
">>> group2 = parser.add_argument_group('group2', 'group2 description')\n"
">>> group2.add_argument('--bar', help='bar help')\n"
">>> parser.print_help()\n"
"usage: PROG [--bar BAR] foo\n"
"\n"
"group1:\n"
"  group1 description\n"
"\n"
"  foo    foo help\n"
"\n"
"group2:\n"
"  group2 description\n"
"\n"
"  --bar BAR  bar help"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)\n"
">>> group1 = parser.add_argument_group('group1', 'group1 description')\n"
">>> group1.add_argument('foo', help='foo help')\n"
">>> group2 = parser.add_argument_group('group2', 'group2 description')\n"
">>> group2.add_argument('--bar', help='bar help')\n"
">>> parser.print_help()\n"
"usage: PROG [--bar BAR] foo\n"
"\n"
"group1:\n"
"  group1 description\n"
"\n"
"  foo    foo help\n"
"\n"
"group2:\n"
"  group2 description\n"
"\n"
"  --bar BAR  bar help"

#: ../../library/argparse.rst:1802
msgid ""
"The optional, keyword-only parameters argument_default_ and "
"conflict_handler_ allow for finer-grained control of the behavior of the "
"argument group. These parameters have the same meaning as in the :class:"
"`ArgumentParser` constructor, but apply specifically to the argument group "
"rather than the entire parser."
msgstr ""
"Los parámetros opcionales de palabra clave argument_default_ y "
"conflict_handler_ permiten un control más preciso del comportamiento del "
"grupo de argumentos. Estos parámetros tienen el mismo significado que en el "
"constructor :class:`ArgumentParser`, pero se aplican específicamente al "
"grupo de argumentos en lugar de a todo el analizador sintáctico."

#: ../../library/argparse.rst:1807
msgid ""
"Note that any arguments not in your user-defined groups will end up back in "
"the usual \"positional arguments\" and \"optional arguments\" sections."
msgstr ""
"Tenga en cuenta que cualquier argumento que no esté en sus grupos definidos "
"por el usuario acabará de nuevo en las secciones habituales de \"argumentos "
"posicionales\" y \"argumentos opcionales\"."

#: ../../library/argparse.rst:1810
msgid ""
"Calling :meth:`add_argument_group` on an argument group is deprecated. This "
"feature was never supported and does not always work correctly. The function "
"exists on the API by accident through inheritance and will be removed in the "
"future."
msgstr ""
"La llamada a :meth:`add_argument_group` en un grupo de argumentos está "
"obsoleta. Esta función nunca fue soportada y no siempre funciona "
"correctamente. La función existe en la API por accidente a través de la "
"herencia y se eliminará en el futuro."

#: ../../library/argparse.rst:1818
msgid "Mutual exclusion"
msgstr "Exclusión mutua"

#: ../../library/argparse.rst:1822
msgid ""
"Create a mutually exclusive group. :mod:`!argparse` will make sure that only "
"one of the arguments in the mutually exclusive group was present on the "
"command line::"
msgstr ""
"Crear un grupo mutuamente excluyente. :mod:`!argparse` se asegurará de que "
"sólo uno de los argumentos en el grupo mutuamente excluyente estaba presente "
"en la línea de comandos::"

#: ../../library/argparse.rst:1826
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> group = parser.add_mutually_exclusive_group()\n"
">>> group.add_argument('--foo', action='store_true')\n"
">>> group.add_argument('--bar', action='store_false')\n"
">>> parser.parse_args(['--foo'])\n"
"Namespace(bar=True, foo=True)\n"
">>> parser.parse_args(['--bar'])\n"
"Namespace(bar=False, foo=False)\n"
">>> parser.parse_args(['--foo', '--bar'])\n"
"usage: PROG [-h] [--foo | --bar]\n"
"PROG: error: argument --bar: not allowed with argument --foo"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> group = parser.add_mutually_exclusive_group()\n"
">>> group.add_argument('--foo', action='store_true')\n"
">>> group.add_argument('--bar', action='store_false')\n"
">>> parser.parse_args(['--foo'])\n"
"Namespace(bar=True, foo=True)\n"
">>> parser.parse_args(['--bar'])\n"
"Namespace(bar=False, foo=False)\n"
">>> parser.parse_args(['--foo', '--bar'])\n"
"usage: PROG [-h] [--foo | --bar]\n"
"PROG: error: argument --bar: not allowed with argument --foo"

#: ../../library/argparse.rst:1838
msgid ""
"The :meth:`add_mutually_exclusive_group` method also accepts a *required* "
"argument, to indicate that at least one of the mutually exclusive arguments "
"is required::"
msgstr ""
"El método :meth:`add_mutually_exclusive_group` también acepta un argumento "
"*required*, para indicar que al menos uno de los argumentos mutuamente "
"excluyentes es necesario::"

#: ../../library/argparse.rst:1842
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> group = parser.add_mutually_exclusive_group(required=True)\n"
">>> group.add_argument('--foo', action='store_true')\n"
">>> group.add_argument('--bar', action='store_false')\n"
">>> parser.parse_args([])\n"
"usage: PROG [-h] (--foo | --bar)\n"
"PROG: error: one of the arguments --foo --bar is required"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> group = parser.add_mutually_exclusive_group(required=True)\n"
">>> group.add_argument('--foo', action='store_true')\n"
">>> group.add_argument('--bar', action='store_false')\n"
">>> parser.parse_args([])\n"
"usage: PROG [-h] (--foo | --bar)\n"
"PROG: error: one of the arguments --foo --bar is required"

#: ../../library/argparse.rst:1850
msgid ""
"Note that currently mutually exclusive argument groups do not support the "
"*title* and *description* arguments of :meth:`~ArgumentParser."
"add_argument_group`. However, a mutually exclusive group can be added to an "
"argument group that has a title and description. For example::"
msgstr ""
"Tenga en cuenta que actualmente los grupos de argumentos mutuamente "
"excluyentes no admiten los argumentos *title* y *description* de :meth:"
"`~ArgumentParser.add_argument_group`. Sin embargo, se puede añadir un grupo "
"mutuamente excluyente a un grupo de argumentos que tenga un título y una "
"descripción. Por ejemplo::"

#: ../../library/argparse.rst:1856
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> group = parser.add_argument_group('Group title', 'Group description')\n"
">>> exclusive_group = group.add_mutually_exclusive_group(required=True)\n"
">>> exclusive_group.add_argument('--foo', help='foo help')\n"
">>> exclusive_group.add_argument('--bar', help='bar help')\n"
">>> parser.print_help()\n"
"usage: PROG [-h] (--foo FOO | --bar BAR)\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"\n"
"Group title:\n"
"  Group description\n"
"\n"
"  --foo FOO   foo help\n"
"  --bar BAR   bar help"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> group = parser.add_argument_group('Group title', 'Group description')\n"
">>> exclusive_group = group.add_mutually_exclusive_group(required=True)\n"
">>> exclusive_group.add_argument('--foo', help='foo help')\n"
">>> exclusive_group.add_argument('--bar', help='bar help')\n"
">>> parser.print_help()\n"
"usage: PROG [-h] (--foo FOO | --bar BAR)\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"\n"
"Group title:\n"
"  Group description\n"
"\n"
"  --foo FOO   foo help\n"
"  --bar BAR   bar help"

#: ../../library/argparse.rst:1873
msgid ""
"Calling :meth:`add_argument_group` or :meth:`add_mutually_exclusive_group` "
"on a mutually exclusive group is deprecated. These features were never "
"supported and do not always work correctly. The functions exist on the API "
"by accident through inheritance and will be removed in the future."
msgstr ""
"Llamar a :meth:`add_argument_group` o :meth:`add_mutually_exclusive_group` "
"en un grupo mutuamente excluyente está obsoleto. Estas funciones nunca "
"fueron soportadas y no siempre funcionan correctamente. Las funciones "
"existen en la API por accidente a través de la herencia y se eliminarán en "
"el futuro."

#: ../../library/argparse.rst:1881
msgid "Parser defaults"
msgstr "Parser por defecto"

#: ../../library/argparse.rst:1885
msgid ""
"Most of the time, the attributes of the object returned by :meth:"
"`parse_args` will be fully determined by inspecting the command-line "
"arguments and the argument actions.  :meth:`set_defaults` allows some "
"additional attributes that are determined without any inspection of the "
"command line to be added::"
msgstr ""
"La mayoría de las veces, los atributos del objeto devuelto por :meth:"
"`parse_args` se determinarán completamente inspeccionando los argumentos de "
"la línea de comandos y las acciones de los argumentos. :meth:`set_defaults` "
"permite añadir algunos atributos adicionales que se determinan sin ninguna "
"inspección de la línea de comandos::"

#: ../../library/argparse.rst:1891
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('foo', type=int)\n"
">>> parser.set_defaults(bar=42, baz='badger')\n"
">>> parser.parse_args(['736'])\n"
"Namespace(bar=42, baz='badger', foo=736)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('foo', type=int)\n"
">>> parser.set_defaults(bar=42, baz='badger')\n"
">>> parser.parse_args(['736'])\n"
"Namespace(bar=42, baz='badger', foo=736)"

#: ../../library/argparse.rst:1897
msgid ""
"Note that parser-level defaults always override argument-level defaults::"
msgstr ""
"Tener en cuenta que los valores por defecto a nivel de analizador siempre "
"anulan los valores por defecto a nivel de argumento::"

#: ../../library/argparse.rst:1899
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default='bar')\n"
">>> parser.set_defaults(foo='spam')\n"
">>> parser.parse_args([])\n"
"Namespace(foo='spam')"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default='bar')\n"
">>> parser.set_defaults(foo='spam')\n"
">>> parser.parse_args([])\n"
"Namespace(foo='spam')"

#: ../../library/argparse.rst:1905
msgid ""
"Parser-level defaults can be particularly useful when working with multiple "
"parsers.  See the :meth:`~ArgumentParser.add_subparsers` method for an "
"example of this type."
msgstr ""
"Los valores por defecto a nivel de analizador sintáctico pueden ser "
"especialmente útiles cuando se trabaja con varios analizadores sintácticos.  "
"Consultar el método :meth:`~ArgumentParser.add_subparsers` para ver un "
"ejemplo de este tipo."

#: ../../library/argparse.rst:1911
msgid ""
"Get the default value for a namespace attribute, as set by either :meth:"
"`~ArgumentParser.add_argument` or by :meth:`~ArgumentParser.set_defaults`::"
msgstr ""
"Obtiene el valor predeterminado de un atributo de espacio de nombres, "
"establecido por :meth:`~ArgumentParser.add_argument` o por :meth:"
"`~ArgumentParser.set_defaults`::"

#: ../../library/argparse.rst:1915
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default='badger')\n"
">>> parser.get_default('foo')\n"
"'badger'"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default='badger')\n"
">>> parser.get_default('foo')\n"
"'badger'"

#: ../../library/argparse.rst:1922
msgid "Printing help"
msgstr "Ayuda para la impresión"

#: ../../library/argparse.rst:1924
msgid ""
"In most typical applications, :meth:`~ArgumentParser.parse_args` will take "
"care of formatting and printing any usage or error messages.  However, "
"several formatting methods are available:"
msgstr ""
"En la mayoría de las aplicaciones típicas, :meth:`~ArgumentParser."
"parse_args` se encargará de formatear e imprimir cualquier mensaje de uso o "
"error.  Sin embargo, existen varios métodos de formateo:"

#: ../../library/argparse.rst:1930
msgid ""
"Print a brief description of how the :class:`ArgumentParser` should be "
"invoked on the command line.  If *file* is ``None``, :data:`sys.stdout` is "
"assumed."
msgstr ""
"Imprime una breve descripción de cómo debe invocarse :class:`ArgumentParser` "
"en la línea de comandos.  Si *file* es ``None``, se asume :data:`sys.stdout`."

#: ../../library/argparse.rst:1936
msgid ""
"Print a help message, including the program usage and information about the "
"arguments registered with the :class:`ArgumentParser`.  If *file* is "
"``None``, :data:`sys.stdout` is assumed."
msgstr ""
"Imprime un mensaje de ayuda, incluyendo el uso del programa e información "
"sobre los argumentos registrados en :class:`ArgumentParser`. Si *file* es "
"``None``, se asume :data:`sys.stdout`."

#: ../../library/argparse.rst:1940
msgid ""
"There are also variants of these methods that simply return a string instead "
"of printing it:"
msgstr ""
"También existen variantes de estos métodos que simplemente devuelven una "
"cadena en lugar de imprimirla:"

#: ../../library/argparse.rst:1945
msgid ""
"Return a string containing a brief description of how the :class:"
"`ArgumentParser` should be invoked on the command line."
msgstr ""
"Devuelve una cadena que contiene una breve descripción de cómo debe "
"invocarse :class:`ArgumentParser` en la línea de comandos."

#: ../../library/argparse.rst:1950
msgid ""
"Return a string containing a help message, including the program usage and "
"information about the arguments registered with the :class:`ArgumentParser`."
msgstr ""
"Devuelve una cadena con un mensaje de ayuda, que incluye el uso del programa "
"e información sobre los argumentos registrados en :class:`ArgumentParser`."

#: ../../library/argparse.rst:1955
msgid "Partial parsing"
msgstr "Análisis sintáctico parcial"

#: ../../library/argparse.rst:1959
msgid ""
"Sometimes a script may only parse a few of the command-line arguments, "
"passing the remaining arguments on to another script or program. In these "
"cases, the :meth:`~ArgumentParser.parse_known_args` method can be useful.  "
"It works much like :meth:`~ArgumentParser.parse_args` except that it does "
"not produce an error when extra arguments are present.  Instead, it returns "
"a two item tuple containing the populated namespace and the list of "
"remaining argument strings."
msgstr ""
"A veces, es posible que un script sólo analice algunos de los argumentos de "
"la línea de comandos y pase el resto a otro script o programa. En estos "
"casos, el método :meth:`~ArgumentParser.parse_known_args` puede ser útil.  "
"Funciona de forma muy parecida a :meth:`~ArgumentParser.parse_args`, salvo "
"que no produce un error cuando hay argumentos adicionales.  En su lugar, "
"devuelve una tupla de dos elementos que contiene el espacio de nombres "
"rellenado y la lista de cadenas de argumentos restantes."

#: ../../library/argparse.rst:1968
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action='store_true')\n"
">>> parser.add_argument('bar')\n"
">>> parser.parse_known_args(['--foo', '--badger', 'BAR', 'spam'])\n"
"(Namespace(bar='BAR', foo=True), ['--badger', 'spam'])"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action='store_true')\n"
">>> parser.add_argument('bar')\n"
">>> parser.parse_known_args(['--foo', '--badger', 'BAR', 'spam'])\n"
"(Namespace(bar='BAR', foo=True), ['--badger', 'spam'])"

#: ../../library/argparse.rst:1975
msgid ""
":ref:`Prefix matching <prefix-matching>` rules apply to :meth:"
"`~ArgumentParser.parse_known_args`. The parser may consume an option even if "
"it's just a prefix of one of its known options, instead of leaving it in the "
"remaining arguments list."
msgstr ""
"Las reglas :ref:`Prefix matching <prefix-matching>` se aplican a :meth:"
"`~ArgumentParser.parse_known_args`. El analizador sintáctico puede consumir "
"una opción aunque sólo sea un prefijo de una de sus opciones conocidas, en "
"lugar de dejarla en la lista de argumentos restantes."

#: ../../library/argparse.rst:1982
msgid "Customizing file parsing"
msgstr "Personalización del análisis sintáctico de archivos"

#: ../../library/argparse.rst:1986
msgid ""
"Arguments that are read from a file (see the *fromfile_prefix_chars* keyword "
"argument to the :class:`ArgumentParser` constructor) are read one argument "
"per line. :meth:`convert_arg_line_to_args` can be overridden for fancier "
"reading."
msgstr ""
"Los argumentos que se leen de un archivo (véase el argumento de palabra "
"clave *fromfile_prefix_chars* del constructor :class:`ArgumentParser` ) se "
"leen un argumento por línea. :meth:`convert_arg_line_to_args` puede "
"sobrescribirse para una lectura más sofisticada."

#: ../../library/argparse.rst:1991
msgid ""
"This method takes a single argument *arg_line* which is a string read from "
"the argument file.  It returns a list of arguments parsed from this string. "
"The method is called once per line read from the argument file, in order."
msgstr ""
"Este método toma un único argumento *arg_line* que es una cadena leída del "
"fichero de argumentos.  Devuelve una lista de argumentos analizados a partir "
"de esta cadena. El método se ejecuta una vez por cada línea leída del "
"archivo de argumentos, en orden."

#: ../../library/argparse.rst:1995
msgid ""
"A useful override of this method is one that treats each space-separated "
"word as an argument.  The following example demonstrates how to do this::"
msgstr ""
"Un método útil es el que trata cada palabra separada por espacios como un "
"argumento.  El siguiente ejemplo muestra cómo hacerlo::"

#: ../../library/argparse.rst:1998
msgid ""
"class MyArgumentParser(argparse.ArgumentParser):\n"
"    def convert_arg_line_to_args(self, arg_line):\n"
"        return arg_line.split()"
msgstr ""
"class MyArgumentParser(argparse.ArgumentParser):\n"
"    def convert_arg_line_to_args(self, arg_line):\n"
"        return arg_line.split()"

#: ../../library/argparse.rst:2004
msgid "Exiting methods"
msgstr "Métodos de salida"

#: ../../library/argparse.rst:2008
msgid ""
"This method terminates the program, exiting with the specified *status* and, "
"if given, it prints a *message* to :data:`sys.stderr` before that. The user "
"can override this method to handle these steps differently::"
msgstr ""
"Este método termina el programa, saliendo con el *estado* especificado y, si "
"se le da, imprime antes un *mensaje* a :data:`sys.stderr`. El usuario puede "
"anular este método para manejar estos pasos de manera diferente::"

#: ../../library/argparse.rst:2012
msgid ""
"class ErrorCatchingArgumentParser(argparse.ArgumentParser):\n"
"    def exit(self, status=0, message=None):\n"
"        if status:\n"
"            raise Exception(f'Exiting because of an error: {message}')\n"
"        exit(status)"
msgstr ""
"class ErrorCatchingArgumentParser(argparse.ArgumentParser):\n"
"    def exit(self, status=0, message=None):\n"
"        if status:\n"
"            raise Exception(f'Exiting because of an error: {message}')\n"
"        exit(status)"

#: ../../library/argparse.rst:2020
msgid ""
"This method prints a usage message, including the *message*, to :data:`sys."
"stderr` and terminates the program with a status code of 2."
msgstr ""
"Este método imprime un mensaje de uso, incluyendo el *mensaje*, en :data:"
"`sys.stderr` y termina el programa con un código de estado 2."

#: ../../library/argparse.rst:2025
msgid "Intermixed parsing"
msgstr "Análisis mixto"

#: ../../library/argparse.rst:2030
msgid ""
"A number of Unix commands allow the user to intermix optional arguments with "
"positional arguments.  The :meth:`~ArgumentParser.parse_intermixed_args` "
"and :meth:`~ArgumentParser.parse_known_intermixed_args` methods support this "
"parsing style."
msgstr ""
"Algunos comandos Unix permiten al usuario entremezclar argumentos opcionales "
"con argumentos posicionales.  Los métodos :meth:`~ArgumentParser."
"parse_intermixed_args` y :meth:`~ArgumentParser.parse_known_intermixed_args` "
"admiten este estilo de análisis sintáctico."

#: ../../library/argparse.rst:2035
msgid ""
"These parsers do not support all the :mod:`!argparse` features, and will "
"raise exceptions if unsupported features are used.  In particular, "
"subparsers, and mutually exclusive groups that include both optionals and "
"positionals are not supported."
msgstr ""
"Estos analizadores sintácticos no son compatibles con todas las funciones "
"de :mod:`!argparse` y provocarán excepciones si se utilizan funciones no "
"compatibles.  En particular, no admiten subanalizadores ni grupos mutuamente "
"excluyentes que incluyan tanto opcionales como posicionales."

#: ../../library/argparse.rst:2040
msgid ""
"The following example shows the difference between :meth:`~ArgumentParser."
"parse_known_args` and :meth:`~ArgumentParser.parse_intermixed_args`: the "
"former returns ``['2', '3']`` as unparsed arguments, while the latter "
"collects all the positionals into ``rest``.  ::"
msgstr ""
"El siguiente ejemplo muestra la diferencia entre :meth:`~ArgumentParser."
"parse_known_args` y :meth:`~ArgumentParser.parse_intermixed_args`: el "
"primero devuelve ``['2', '3']`` como argumentos sin analizar, mientras que "
"el segundo recoge todos los posicionales en ``rest``. ::"

#: ../../library/argparse.rst:2046
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo')\n"
">>> parser.add_argument('cmd')\n"
">>> parser.add_argument('rest', nargs='*', type=int)\n"
">>> parser.parse_known_args('doit 1 --foo bar 2 3'.split())\n"
"(Namespace(cmd='doit', foo='bar', rest=[1]), ['2', '3'])\n"
">>> parser.parse_intermixed_args('doit 1 --foo bar 2 3'.split())\n"
"Namespace(cmd='doit', foo='bar', rest=[1, 2, 3])"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo')\n"
">>> parser.add_argument('cmd')\n"
">>> parser.add_argument('rest', nargs='*', type=int)\n"
">>> parser.parse_known_args('doit 1 --foo bar 2 3'.split())\n"
"(Namespace(cmd='doit', foo='bar', rest=[1]), ['2', '3'])\n"
">>> parser.parse_intermixed_args('doit 1 --foo bar 2 3'.split())\n"
"Namespace(cmd='doit', foo='bar', rest=[1, 2, 3])"

#: ../../library/argparse.rst:2055
msgid ""
":meth:`~ArgumentParser.parse_known_intermixed_args` returns a two item tuple "
"containing the populated namespace and the list of remaining argument "
"strings. :meth:`~ArgumentParser.parse_intermixed_args` raises an error if "
"there are any remaining unparsed argument strings."
msgstr ""
":meth:`~ArgumentParser.parse_known_intermixed_args` devuelve una tupla de "
"dos elementos que contiene el espacio de nombres rellenado y la lista de "
"cadenas de argumentos restantes. :meth:`~ArgumentParser."
"parse_intermixed_args` genera un error si quedan cadenas de argumentos sin "
"analizar."

#: ../../library/argparse.rst:2064
msgid "Registering custom types or actions"
msgstr "Registro de tipos o acciones personalizados"

#: ../../library/argparse.rst:2068
msgid ""
"Sometimes it's desirable to use a custom string in error messages to provide "
"more user-friendly output. In these cases, :meth:`!register` can be used to "
"register custom actions or types with a parser and allow you to reference "
"the type by their registered name instead of their callable name."
msgstr ""
"A veces es deseable utilizar una cadena personalizada en los mensajes de "
"error para proporcionar una salida más fácil de usar. En estos casos, se "
"puede utilizar :meth:`!register` para registrar acciones o tipos "
"personalizados con un analizador sintáctico y permitir hacer referencia al "
"tipo por su nombre registrado en lugar de por su nombre invocable."

#: ../../library/argparse.rst:2073
msgid ""
"The :meth:`!register` method accepts three arguments - a *registry_name*, "
"specifying the internal registry where the object will be stored (e.g., "
"``action``, ``type``), *value*, which is the key under which the object will "
"be registered, and object, the callable to be registered."
msgstr ""
"El método :meth:`!register` acepta tres argumentos: *nombre_registro*, que "
"especifica el registro interno en el que se almacenará el objeto (por "
"ejemplo, ``action``, ``type``), *valor*, que es la clave bajo la que se "
"registrará el objeto, y objeto, la llamada que se registrará."

#: ../../library/argparse.rst:2078
msgid ""
"The following example shows how to register a custom type with a parser::"
msgstr ""
"El siguiente ejemplo muestra cómo registrar un tipo personalizado con un "
"analizador sintáctico::"

#: ../../library/argparse.rst:2080
msgid ""
">>> import argparse\n"
">>> parser = argparse.ArgumentParser()\n"
">>> parser.register('type', 'hexadecimal integer', lambda s: int(s, 16))\n"
">>> parser.add_argument('--foo', type='hexadecimal integer')\n"
"_StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, "
"default=None, type='hexadecimal integer', choices=None, required=False, "
"help=None, metavar=None, deprecated=False)\n"
">>> parser.parse_args(['--foo', '0xFA'])\n"
"Namespace(foo=250)\n"
">>> parser.parse_args(['--foo', '1.2'])\n"
"usage: PROG [-h] [--foo FOO]\n"
"PROG: error: argument --foo: invalid 'hexadecimal integer' value: '1.2'"
msgstr ""
">>> import argparse\n"
">>> parser = argparse.ArgumentParser()\n"
">>> parser.register('type', 'hexadecimal integer', lambda s: int(s, 16))\n"
">>> parser.add_argument('--foo', type='hexadecimal integer')\n"
"_StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, "
"default=None, type='hexadecimal integer', choices=None, required=False, "
"help=None, metavar=None, deprecated=False)\n"
">>> parser.parse_args(['--foo', '0xFA'])\n"
"Namespace(foo=250)\n"
">>> parser.parse_args(['--foo', '1.2'])\n"
"usage: PROG [-h] [--foo FOO]\n"
"PROG: error: argument --foo: invalid 'hexadecimal integer' value: '1.2'"

#: ../../library/argparse.rst:2092
msgid "Exceptions"
msgstr "Excepciones"

#: ../../library/argparse.rst:2096
msgid "An error from creating or using an argument (optional or positional)."
msgstr "Un error al crear o utilizar un argumento (opcional o posicional)."

#: ../../library/argparse.rst:2098
msgid ""
"The string value of this exception is the message, augmented with "
"information about the argument that caused it."
msgstr ""
"El valor de cadena de esta excepción es el mensaje, ampliado con información "
"sobre el argumento que la ha provocado."

#: ../../library/argparse.rst:2103
msgid ""
"Raised when something goes wrong converting a command line string to a type."
msgstr ""
"Aparece cuando algo va mal al convertir una cadena de línea de comandos a un "
"tipo."

#: ../../library/argparse.rst:2107
msgid "Guides and Tutorials"
msgstr "Guías y tutoriales"

#: ../../library/argparse.rst:801
msgid "? (question mark)"
msgstr "? (signo de interrogación)"

#: ../../library/argparse.rst:801 ../../library/argparse.rst:835
#: ../../library/argparse.rst:849
msgid "in argparse module"
msgstr "en el módulo argparse"

#: ../../library/argparse.rst:835
msgid "* (asterisk)"
msgstr "* (asterisco)"

#: ../../library/argparse.rst:849
msgid "+ (plus)"
msgstr "+ (más)"
