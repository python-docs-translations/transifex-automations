# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 15:00+0000\n"
"PO-Revision-Date: 2025-07-18 19:20+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (Taiwan) (https://app.transifex.com/python-doc/"
"teams/5390/zh_TW/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_TW\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../c-api/exceptions.rst:8
msgid "Exception Handling"
msgstr "例外處理"

#: ../../c-api/exceptions.rst:10
msgid ""
"The functions described in this chapter will let you handle and raise Python "
"exceptions.  It is important to understand some of the basics of Python "
"exception handling.  It works somewhat like the POSIX :c:data:`errno` "
"variable: there is a global indicator (per thread) of the last error that "
"occurred.  Most C API functions don't clear this on success, but will set it "
"to indicate the cause of the error on failure.  Most C API functions also "
"return an error indicator, usually ``NULL`` if they are supposed to return a "
"pointer, or ``-1`` if they return an integer (exception: the ``PyArg_*`` "
"functions return ``1`` for success and ``0`` for failure)."
msgstr ""
"Функции, описанные в этой главе, позволят вам обрабатывать и вызывать "
"исключения Python. Важно понимать некоторые основы обработки исключений "
"Python. Это работает примерно так же, как переменная POSIX :c:data:`errno`: "
"существует глобальный индикатор (для каждого потока) последней возникшей "
"ошибки. Большинство функций C API не очищают это значение при успешном "
"выполнении, но устанавливают его для указания причины ошибки при сбое. "
"Большинство функций C API также возвращают индикатор ошибки, обычно "
"``NULL``, если предполагается, что они возвращают указатель, или ``-1`` , "
"если они возвращают целое число (исключение: функции ``PyArg_*`` возвращают "
"``1`` для успешного выполнения и ``0`` для ошибки)."

#: ../../c-api/exceptions.rst:20
msgid ""
"Concretely, the error indicator consists of three object pointers: the "
"exception's type, the exception's value, and the traceback object.  Any of "
"those pointers can be ``NULL`` if non-set (although some combinations are "
"forbidden, for example you can't have a non-``NULL`` traceback if the "
"exception type is ``NULL``)."
msgstr ""
"Зокрема, індикатор помилки складається з трьох покажчиків на об’єкти: тип "
"винятку, значення винятку та об’єкт трасування. Будь-який із цих покажчиків "
"може бути ``NULL``, якщо не встановлено (хоча деякі комбінації заборонені, "
"наприклад, ви не можете мати не ``NULL`` трасування, якщо тип винятку "
"``NULL``)."

#: ../../c-api/exceptions.rst:26
msgid ""
"When a function must fail because some function it called failed, it "
"generally doesn't set the error indicator; the function it called already "
"set it.  It is responsible for either handling the error and clearing the "
"exception or returning after cleaning up any resources it holds (such as "
"object references or memory allocations); it should *not* continue normally "
"if it is not prepared to handle the error.  If returning due to an error, it "
"is important to indicate to the caller that an error has been set.  If the "
"error is not handled or carefully propagated, additional calls into the "
"Python/C API may not behave as intended and may fail in mysterious ways."
msgstr ""
"Gdy zadanie musi zawieźć z powodu błędu zadania które wywołało, ogólnie nie "
"ustawia ona wskaźnika błędu; podzadanie które zostało wywołane już go "
"ustawiła. Jest on odpowiedzialny albo za obsługę błędu i wyczyszczenie "
"wskaźnika sytuacji wyjątkowej lub powrót po sprzątnięciu jakichkolwiek "
"zasobów które utrzymuje (takich jak odwołania do przedmiotów lub zajęte "
"pamięci); *nie* powinien kontynuować zwyczajnie jeśli nie jest przygotowany "
"do obsługi błędu. Jeśli kończy z powodu błędu, istotne jest zwrócenie uwagi "
"wołającego że został zgłoszony błąd. Jeśli błąd nie jest obsługiwany lub "
"propagowany właściwie, dodatkowe odwołania do sprzęgu języka pytonowskiego/C "
"mogą nie zachowywać się tak, jak planowano i mogą zawieźć w nieoczekiwane "
"sposoby."

#: ../../c-api/exceptions.rst:37
msgid ""
"The error indicator is **not** the result of :func:`sys.exc_info`. The "
"former corresponds to an exception that is not yet caught (and is therefore "
"still propagating), while the latter returns an exception after it is caught "
"(and has therefore stopped propagating)."
msgstr ""
"Индикатор ошибки **не** является результатом :func:`sys.exc_info`. Первое "
"соответствует исключению, которое еще не перехвачено (и, следовательно, все "
"еще распространяется), тогда как второе возвращает исключение после того, "
"как оно было перехвачено (и, следовательно, прекратило распространение)."

#: ../../c-api/exceptions.rst:44
msgid "Printing and clearing"
msgstr "Mencetak dan membersihkan"

#: ../../c-api/exceptions.rst:49
msgid ""
"Clear the error indicator.  If the error indicator is not set, there is no "
"effect."
msgstr ""
"Очистіть індикатор помилки. Якщо індикатор помилки не встановлено, ефекту "
"немає."

#: ../../c-api/exceptions.rst:55
msgid ""
"Print a standard traceback to ``sys.stderr`` and clear the error indicator. "
"**Unless** the error is a ``SystemExit``, in that case no traceback is "
"printed and the Python process will exit with the error code specified by "
"the ``SystemExit`` instance."
msgstr ""
"Надрукуйте стандартне відстеження до ``sys.stderr`` і очистіть індикатор "
"помилки. **Якщо** помилка не є ``SystemExit``, у такому випадку трасування "
"не друкується, і процес Python завершить роботу з кодом помилки, указаним "
"екземпляром ``SystemExit``."

#: ../../c-api/exceptions.rst:60
msgid ""
"Call this function **only** when the error indicator is set.  Otherwise it "
"will cause a fatal error!"
msgstr ""
"Викликайте цю функцію **лише**, коли встановлено індикатор помилки. Інакше "
"це призведе до фатальної помилки!"

#: ../../c-api/exceptions.rst:63
msgid ""
"If *set_sys_last_vars* is nonzero, the variable :data:`sys.last_exc` is set "
"to the printed exception. For backwards compatibility, the deprecated "
"variables :data:`sys.last_type`, :data:`sys.last_value` and :data:`sys."
"last_traceback` are also set to the type, value and traceback of this "
"exception, respectively."
msgstr ""
"Если *set_sys_last_vars* не равно нулю, переменной :data:`sys.last_exc` "
"присваивается значение напечатанного исключения. Для обратной совместимости "
"устаревшим переменным :data:`sys.last_type`, :data:`sys.last_value` и :data:"
"`sys.last_traceback` также присваиваются тип, значение и обратная "
"трассировка этого исключения соответственно."

#: ../../c-api/exceptions.rst:69
msgid "The setting of :data:`sys.last_exc` was added."
msgstr "Была добавлена настройка :data:`sys.last_exc`."

#: ../../c-api/exceptions.rst:75
msgid "Alias for ``PyErr_PrintEx(1)``."
msgstr "Alias dari ``PyErr_PrintEx(1)``."

#: ../../c-api/exceptions.rst:80
msgid ""
"Call :func:`sys.unraisablehook` using the current exception and *obj* "
"argument."
msgstr ""
"Викликайте :func:`sys.unraisablehook`, використовуючи поточний виняток і "
"аргумент *obj*."

#: ../../c-api/exceptions.rst:83
msgid ""
"This utility function prints a warning message to ``sys.stderr`` when an "
"exception has been set but it is impossible for the interpreter to actually "
"raise the exception.  It is used, for example, when an exception occurs in "
"an :meth:`~object.__del__` method."
msgstr ""
"Эта служебная функция выводит предупреждающее сообщение в ``sys.stderr``, "
"когда установлено исключение, но интерпретатор не может фактически вызвать "
"исключение. Он используется, например, когда возникает исключение в методе :"
"meth:`~object.__del__`."

#: ../../c-api/exceptions.rst:88
msgid ""
"The function is called with a single argument *obj* that identifies the "
"context in which the unraisable exception occurred. If possible, the repr of "
"*obj* will be printed in the warning message. If *obj* is ``NULL``, only the "
"traceback is printed."
msgstr ""
"Функция вызывается с единственным аргументом *obj*, который идентифицирует "
"контекст, в котором возникло недопустимое исключение. Если возможно, в "
"предупреждающем сообщении будет напечатано повторение *obj*. Если *obj* "
"равно ``NULL``, печатается только обратная трассировка."

#: ../../c-api/exceptions.rst:93
msgid "An exception must be set when calling this function."
msgstr "При виклику цієї функції необхідно встановити виняток."

#: ../../c-api/exceptions.rst:95
msgid "Print a traceback. Print only traceback if *obj* is ``NULL``."
msgstr ""
"Выводит обратную трассировку. Выводит обратную трассировку только в том "
"случае, если *obj* имеет значение ``NULL``."

#: ../../c-api/exceptions.rst:98
msgid "Use :func:`sys.unraisablehook`."
msgstr "Используйте :func:`sys.unraisablehook`."

#: ../../c-api/exceptions.rst:104
msgid ""
"Similar to :c:func:`PyErr_WriteUnraisable`, but the *format* and subsequent "
"parameters help format the warning message; they have the same meaning and "
"values as in :c:func:`PyUnicode_FromFormat`. ``PyErr_WriteUnraisable(obj)`` "
"is roughly equivalent to ``PyErr_FormatUnraisable(\"Exception ignored in: "
"%R\", obj)``. If *format* is ``NULL``, only the traceback is printed."
msgstr ""
"Аналогично :c:func:`PyErr_WriteUnraisable`, но *format* и последующие "
"параметры помогают форматировать предупреждающее сообщение; они имеют то же "
"значение и значения, что и в :c:func:`PyUnicode_FromFormat`. "
"``PyErr_WriteUnraisable(obj)`` примерно эквивалентен "
"``PyErr_FormatUnraisable(\"Исключение игнорируется в: %R\", obj)``. Если "
"*format* равен ``NULL``, печатается только обратная трассировка."

#: ../../c-api/exceptions.rst:116
msgid ""
"Print the standard traceback display of ``exc`` to ``sys.stderr``, including "
"chained exceptions and notes."
msgstr ""
"Выводит стандартное отображение обратной трассировки от ``exc`` до ``sys."
"stderr``, включая связанные исключения и примечания."

#: ../../c-api/exceptions.rst:123
msgid "Raising exceptions"
msgstr "Menghasilkan pengecualian"

#: ../../c-api/exceptions.rst:125
msgid ""
"These functions help you set the current thread's error indicator. For "
"convenience, some of these functions will always return a ``NULL`` pointer "
"for use in a ``return`` statement."
msgstr ""
"Ці функції допомагають встановити індикатор помилки поточного потоку. Для "
"зручності деякі з цих функцій завжди повертатимуть покажчик ``NULL`` для "
"використання в операторі ``return``."

#: ../../c-api/exceptions.rst:132
msgid ""
"This is the most common way to set the error indicator.  The first argument "
"specifies the exception type; it is normally one of the standard exceptions, "
"e.g. :c:data:`PyExc_RuntimeError`.  You need not create a new :term:`strong "
"reference` to it (e.g. with :c:func:`Py_INCREF`). The second argument is an "
"error message; it is decoded from ``'utf-8'``."
msgstr ""
"Это наиболее распространенный способ установки индикатора ошибки. Первый "
"аргумент указывает тип исключения; обычно это одно из стандартных "
"исключений, например :c:data:`PyExc_RuntimeError`. Вам не нужно создавать "
"новый :term:`strong reference` на него (например, с помощью :c:func:"
"`Py_INCREF`). Второй аргумент - это сообщение об ошибке; оно декодируется из "
"``'utf-8'``."

#: ../../c-api/exceptions.rst:141
msgid ""
"This function is similar to :c:func:`PyErr_SetString` but lets you specify "
"an arbitrary Python object for the \"value\" of the exception."
msgstr ""
"Ця функція схожа на :c:func:`PyErr_SetString`, але дозволяє вказати "
"довільний об’єкт Python для \"значення\" винятку."

#: ../../c-api/exceptions.rst:147
msgid ""
"This function sets the error indicator and returns ``NULL``.  *exception* "
"should be a Python exception class.  The *format* and subsequent parameters "
"help format the error message; they have the same meaning and values as in :"
"c:func:`PyUnicode_FromFormat`. *format* is an ASCII-encoded string."
msgstr ""
"Ця функція встановлює індикатор помилки та повертає ``NULL``. *exception* "
"має бути класом винятків Python. *format* і наступні параметри допомагають "
"відформатувати повідомлення про помилку; вони мають те саме значення та "
"значення, що й у :c:func:`PyUnicode_FromFormat`. *format* — це рядок у "
"кодуванні ASCII."

#: ../../c-api/exceptions.rst:156
msgid ""
"Same as :c:func:`PyErr_Format`, but taking a :c:type:`va_list` argument "
"rather than a variable number of arguments."
msgstr ""
"Те саме, що :c:func:`PyErr_Format`, але приймає аргумент :c:type:`va_list`, "
"а не змінну кількість аргументів."

#: ../../c-api/exceptions.rst:164
msgid "This is a shorthand for ``PyErr_SetObject(type, Py_None)``."
msgstr "Це скорочення для ``PyErr_SetObject(type, Py_None)``."

#: ../../c-api/exceptions.rst:169
msgid ""
"This is a shorthand for ``PyErr_SetString(PyExc_TypeError, message)``, where "
"*message* indicates that a built-in operation was invoked with an illegal "
"argument.  It is mostly for internal use."
msgstr ""
"Це скорочення для ``PyErr_SetString(PyExc_TypeError, повідомлення)``, де "
"*повідомлення* вказує на те, що вбудовану операцію було викликано з "
"недопустимим аргументом. В основному він призначений для внутрішнього "
"використання."

#: ../../c-api/exceptions.rst:176
msgid ""
"This is a shorthand for ``PyErr_SetNone(PyExc_MemoryError)``; it returns "
"``NULL`` so an object allocation function can write ``return "
"PyErr_NoMemory();`` when it runs out of memory."
msgstr ""
"Це скорочення для ``PyErr_SetNone(PyExc_MemoryError)``; він повертає "
"``NULL``, тому функція розподілу об’єктів може написати ``return "
"PyErr_NoMemory();``, коли їй вичерпується пам’ять."

#: ../../c-api/exceptions.rst:185
msgid ""
"This is a convenience function to raise an exception when a C library "
"function has returned an error and set the C variable :c:data:`errno`.  It "
"constructs a tuple object whose first item is the integer :c:data:`errno` "
"value and whose second item is the corresponding error message (gotten from :"
"c:func:`!strerror`), and then calls ``PyErr_SetObject(type, object)``.  On "
"Unix, when the :c:data:`errno` value is :c:macro:`!EINTR`, indicating an "
"interrupted system call, this calls :c:func:`PyErr_CheckSignals`, and if "
"that set the error indicator, leaves it set to that.  The function always "
"returns ``NULL``, so a wrapper function around a system call can write "
"``return PyErr_SetFromErrno(type);`` when the system call returns an error."
msgstr ""
"Это удобная функция для создания исключения, когда функция библиотеки C "
"вернула ошибку и установила переменную C :c:data:`errno`. Он создает объект "
"кортежа, первым элементом которого является целочисленное значение :c:data:"
"`errno`, а вторым элементом которого является соответствующее сообщение об "
"ошибке (полученное из :c:func:`!strerror`), а затем вызывает "
"``PyErr_SetObject(type, object)``. В Unix, когда значение :c:data:`errno` "
"равно :c:macro:`!EINTR`, указывающее на прерванный системный вызов, это "
"вызывает :c:func:`PyErr_CheckSignals`, и если она устанавливает индикатор "
"ошибки, оставляет его равным этому. Функция всегда возвращает ``NULL``, "
"поэтому функция-оболочка для системного вызова может написать ``return "
"PyErr_SetFromErrno(type);``, когда системный вызов возвращает ошибку."

#: ../../c-api/exceptions.rst:199
msgid ""
"Similar to :c:func:`PyErr_SetFromErrno`, with the additional behavior that "
"if *filenameObject* is not ``NULL``, it is passed to the constructor of "
"*type* as a third parameter.  In the case of :exc:`OSError` exception, this "
"is used to define the :attr:`!filename` attribute of the exception instance."
msgstr ""
"Аналогично :c:func:`PyErr_SetFromErrno`, с дополнительным поведением, "
"заключающимся в том, что если *filenameObject* не является ``NULL``, оно "
"передается конструктору *type* в качестве третьего параметра. В случае "
"исключения :exc:`OSError` это используется для определения атрибута :attr:`!"
"filename` экземпляра исключения."

#: ../../c-api/exceptions.rst:208
msgid ""
"Similar to :c:func:`PyErr_SetFromErrnoWithFilenameObject`, but takes a "
"second filename object, for raising errors when a function that takes two "
"filenames fails."
msgstr ""
"Подібно до :c:func:`PyErr_SetFromErrnoWithFilenameObject`, але приймає "
"другий об’єкт імені файлу, щоб викликати помилки, коли функція, яка приймає "
"два імені файлу, виходить з ладу."

#: ../../c-api/exceptions.rst:217
msgid ""
"Similar to :c:func:`PyErr_SetFromErrnoWithFilenameObject`, but the filename "
"is given as a C string.  *filename* is decoded from the :term:`filesystem "
"encoding and error handler`."
msgstr ""
"Подібно до :c:func:`PyErr_SetFromErrnoWithFilenameObject`, але ім’я файлу "
"подається як рядок C. *ім’я файлу* розшифровується з :term:`filesystem "
"encoding and error handler`."

#: ../../c-api/exceptions.rst:224
msgid ""
"This is a convenience function to raise :exc:`OSError`. If called with "
"*ierr* of ``0``, the error code returned by a call to :c:func:`!"
"GetLastError` is used instead.  It calls the Win32 function :c:func:`!"
"FormatMessage` to retrieve the Windows description of error code given by "
"*ierr* or :c:func:`!GetLastError`, then it constructs a :exc:`OSError` "
"object with the :attr:`~OSError.winerror` attribute set to the error code, "
"the :attr:`~OSError.strerror` attribute set to the corresponding error "
"message (gotten from :c:func:`!FormatMessage`), and then calls "
"``PyErr_SetObject(PyExc_OSError, object)``. This function always returns "
"``NULL``."
msgstr ""
"Это удобная функция для вызова :exc:`OSError`. Если вызывается с *ierr* из "
"``0``, вместо этого используется код ошибки, возвращаемый вызовом :c:func:`!"
"GetLastError`. Он вызывает функцию Win32 :c:func:`!FormatMessage` для "
"получения описания кода ошибки Windows, заданного *ierr* или :c:func:`!"
"GetLastError`, затем он создает объект :exc:`OSError` с атрибуту :attr:"
"`~OSError.winerror` присвоен код ошибки, атрибуту :attr:`~OSError.strerror` "
"присвоено соответствующее сообщение об ошибке (полученное из :c:func:`!"
"FormatMessage`), а затем вызывает ``PyErr_SetObject(PyExc_OSError, "
"object)``. Эта функция всегда возвращает NULL."

#: ../../c-api/exceptions.rst:234 ../../c-api/exceptions.rst:242
#: ../../c-api/exceptions.rst:253 ../../c-api/exceptions.rst:263
#: ../../c-api/exceptions.rst:271 ../../c-api/exceptions.rst:281
msgid "Availability"
msgstr "Dostępność"

#: ../../c-api/exceptions.rst:239
msgid ""
"Similar to :c:func:`PyErr_SetFromWindowsErr`, with an additional parameter "
"specifying the exception type to be raised."
msgstr ""
"Подібно до :c:func:`PyErr_SetFromWindowsErr`, з додатковим параметром, що "
"визначає тип винятку, який буде створено."

#: ../../c-api/exceptions.rst:247
msgid ""
"Similar to :c:func:`PyErr_SetFromWindowsErr`, with the additional behavior "
"that if *filename* is not ``NULL``, it is decoded from the filesystem "
"encoding (:func:`os.fsdecode`) and passed to the constructor of :exc:"
"`OSError` as a third parameter to be used to define the :attr:`!filename` "
"attribute of the exception instance."
msgstr ""
"Аналогично :c:func:`PyErr_SetFromWindowsErr`, с дополнительным поведением, "
"заключающимся в том, что если *filename* не равно ``NULL``, оно декодируется "
"из кодировки файловой системы (:func:`os.fsdecode`) и передается "
"конструктору :exc:`OSError` в качестве третьего параметра, который будет "
"использоваться для определения атрибута :attr:`!filename` экземпляра "
"исключения."

#: ../../c-api/exceptions.rst:258
msgid ""
"Similar to :c:func:`PyErr_SetExcFromWindowsErr`, with the additional "
"behavior that if *filename* is not ``NULL``, it is passed to the constructor "
"of :exc:`OSError` as a third parameter to be used to define the :attr:`!"
"filename` attribute of the exception instance."
msgstr ""
"Аналогично :c:func:`PyErr_SetExcFromWindowsErr`, с дополнительным "
"поведением, заключающимся в том, что если *filename* не равно ``NULL``, оно "
"передается конструктору :exc:`OSError` в качестве третьего параметра, "
"который будет использоваться для определения :attr:`!filename` атрибута "
"экземпляра исключения."

#: ../../c-api/exceptions.rst:268
msgid ""
"Similar to :c:func:`PyErr_SetExcFromWindowsErrWithFilenameObject`, but "
"accepts a second filename object."
msgstr ""
"Подібно до :c:func:`PyErr_SetExcFromWindowsErrWithFilenameObject`, але "
"приймає другий об’єкт імені файлу."

#: ../../c-api/exceptions.rst:278
msgid ""
"Similar to :c:func:`PyErr_SetFromWindowsErrWithFilename`, with an additional "
"parameter specifying the exception type to be raised."
msgstr ""
"Подібно до :c:func:`PyErr_SetFromWindowsErrWithFilename`, з додатковим "
"параметром, що визначає тип винятку, який буде створено."

#: ../../c-api/exceptions.rst:286
msgid ""
"This is a convenience function to raise :exc:`ImportError`. *msg* will be "
"set as the exception's message string. *name* and *path*, both of which can "
"be ``NULL``, will be set as the :exc:`ImportError`'s respective ``name`` and "
"``path`` attributes."
msgstr ""
"Це зручна функція для виклику :exc:`ImportError`. *msg* буде встановлено як "
"рядок повідомлення винятку. *name* і *path*, обидва з яких можуть мати "
"значення ``NULL``, буде встановлено як відповідні атрибути ``name`` і "
"``path`` :exc:`ImportError`."

#: ../../c-api/exceptions.rst:296
msgid ""
"Much like :c:func:`PyErr_SetImportError` but this function allows for "
"specifying a subclass of :exc:`ImportError` to raise."
msgstr ""
"Дуже схоже на :c:func:`PyErr_SetImportError`, але ця функція дозволяє "
"вказати підклас :exc:`ImportError` для підвищення."

#: ../../c-api/exceptions.rst:304
msgid ""
"Set file, line, and offset information for the current exception.  If the "
"current exception is not a :exc:`SyntaxError`, then it sets additional "
"attributes, which make the exception printing subsystem think the exception "
"is a :exc:`SyntaxError`."
msgstr ""
"Установіть інформацію про файл, рядок і зсув для поточного винятку. Якщо "
"поточний виняток не є :exc:`SyntaxError`, тоді він встановлює додаткові "
"атрибути, які змушують підсистему друку виключення вважати, що виняток є :"
"exc:`SyntaxError`."

#: ../../c-api/exceptions.rst:314
msgid ""
"Like :c:func:`PyErr_SyntaxLocationObject`, but *filename* is a byte string "
"decoded from the :term:`filesystem encoding and error handler`."
msgstr ""
"Подібно до :c:func:`PyErr_SyntaxLocationObject`, але *filename* — це рядок "
"байтів, декодований з :term:`filesystem encoding and error handler`."

#: ../../c-api/exceptions.rst:322
msgid ""
"Like :c:func:`PyErr_SyntaxLocationEx`, but the *col_offset* parameter is "
"omitted."
msgstr ""
"Як :c:func:`PyErr_SyntaxLocationEx`, але параметр *col_offset* опущено."

#: ../../c-api/exceptions.rst:328
msgid ""
"This is a shorthand for ``PyErr_SetString(PyExc_SystemError, message)``, "
"where *message* indicates that an internal operation (e.g. a Python/C API "
"function) was invoked with an illegal argument.  It is mostly for internal "
"use."
msgstr ""
"Це скорочення для ``PyErr_SetString(PyExc_SystemError, повідомлення)``, де "
"*повідомлення* вказує на те, що внутрішня операція (наприклад, функція "
"Python/C API) була викликана з недопустимим аргументом. В основному він "
"призначений для внутрішнього використання."

#: ../../c-api/exceptions.rst:335
msgid "Issuing warnings"
msgstr "Menerbitkan peringatan"

#: ../../c-api/exceptions.rst:337
msgid ""
"Use these functions to issue warnings from C code.  They mirror similar "
"functions exported by the Python :mod:`warnings` module.  They normally "
"print a warning message to *sys.stderr*; however, it is also possible that "
"the user has specified that warnings are to be turned into errors, and in "
"that case they will raise an exception.  It is also possible that the "
"functions raise an exception because of a problem with the warning "
"machinery. The return value is ``0`` if no exception is raised, or ``-1`` if "
"an exception is raised.  (It is not possible to determine whether a warning "
"message is actually printed, nor what the reason is for the exception; this "
"is intentional.)  If an exception is raised, the caller should do its normal "
"exception handling (for example, :c:func:`Py_DECREF` owned references and "
"return an error value)."
msgstr ""
"Використовуйте ці функції, щоб видавати попередження з коду C. Вони "
"відображають аналогічні функції, експортовані модулем Python :mod:"
"`warnings`. Зазвичай вони друкують попередження на *sys.stderr*; однак також "
"можливо, що користувач вказав, що попередження потрібно перетворити на "
"помилки, і в такому випадку вони викличуть виняток. Також можливо, що "
"функції викликають виняток через проблему з механізмом попередження. "
"Повертається значення ``0``, якщо не викликається виняткова ситуація, або "
"``-1``, якщо виникає виняток. (Неможливо визначити, чи справді друкується "
"попереджувальне повідомлення, а також причину винятку; це навмисно.) Якщо "
"виникає виняток, абонент, що викликає, має виконати звичайну обробку "
"винятків (наприклад, :c:func:`Py_DECREF` належать посилання та повертають "
"значення помилки)."

#: ../../c-api/exceptions.rst:352
msgid ""
"Issue a warning message.  The *category* argument is a warning category (see "
"below) or ``NULL``; the *message* argument is a UTF-8 encoded string.  "
"*stack_level* is a positive number giving a number of stack frames; the "
"warning will be issued from the  currently executing line of code in that "
"stack frame.  A *stack_level* of 1 is the function calling :c:func:"
"`PyErr_WarnEx`, 2 is  the function above that, and so forth."
msgstr ""
"Видавати попереджувальне повідомлення. Аргумент *category* є категорією "
"попередження (див. нижче) або ``NULL``; аргумент *message* — це рядок у "
"кодуванні UTF-8. *stack_level* — додатне число, яке дає кількість кадрів "
"стека; попередження буде видано з поточного рядка коду в цьому фреймі стека. "
"*Stack_level* 1 — це функція, яка викликає :c:func:`PyErr_WarnEx`, 2 — це "
"функція, яка стоїть вище, і так далі."

#: ../../c-api/exceptions.rst:359
msgid ""
"Warning categories must be subclasses of :c:data:`PyExc_Warning`; :c:data:"
"`PyExc_Warning` is a subclass of :c:data:`PyExc_Exception`; the default "
"warning category is :c:data:`PyExc_RuntimeWarning`. The standard Python "
"warning categories are available as global variables whose names are "
"enumerated at :ref:`standardwarningcategories`."
msgstr ""
"Категорії попереджень мають бути підкласами :c:data:`PyExc_Warning`; :c:data:"
"`PyExc_Warning` є підкласом :c:data:`PyExc_Exception`; стандартна категорія "
"попередження: :c:data:`PyExc_RuntimeWarning`. Стандартні категорії "
"попереджень Python доступні як глобальні змінні, імена яких пронумеровані в :"
"ref:`standardwarningcategories`."

#: ../../c-api/exceptions.rst:365
msgid ""
"For information about warning control, see the documentation for the :mod:"
"`warnings` module and the :option:`-W` option in the command line "
"documentation.  There is no C API for warning control."
msgstr ""
"Щоб отримати інформацію про керування попередженнями, перегляньте "
"документацію до модуля :mod:`warnings` і опції :option:`-W` у документації "
"командного рядка. Немає C API для керування попередженнями."

#: ../../c-api/exceptions.rst:372
msgid ""
"Issue a warning message with explicit control over all warning attributes.  "
"This is a straightforward wrapper around the Python function :func:`warnings."
"warn_explicit`; see there for more information.  The *module* and *registry* "
"arguments may be set to ``NULL`` to get the default effect described there."
msgstr ""
"Видавати попереджувальне повідомлення з явним керуванням усіма атрибутами "
"попередження. Це проста обгортка функції Python :func:`warnings."
"warn_explicit`; дивіться там для отримання додаткової інформації. Для "
"аргументів *module* і *registry* можна встановити значення ``NULL``, щоб "
"отримати описаний там ефект за замовчуванням."

#: ../../c-api/exceptions.rst:383
msgid ""
"Similar to :c:func:`PyErr_WarnExplicitObject` except that *message* and "
"*module* are UTF-8 encoded strings, and *filename* is decoded from the :term:"
"`filesystem encoding and error handler`."
msgstr ""
"Подібно до :c:func:`PyErr_WarnExplicitObject`, за винятком того, що "
"*message* і *module* є рядками в кодуванні UTF-8, а *filename* декодується "
"з :term:`filesystem encoding and error handler`."

#: ../../c-api/exceptions.rst:390
msgid ""
"Function similar to :c:func:`PyErr_WarnEx`, but use :c:func:"
"`PyUnicode_FromFormat` to format the warning message.  *format* is an ASCII-"
"encoded string."
msgstr ""
"Функція схожа на :c:func:`PyErr_WarnEx`, але використовуйте :c:func:"
"`PyUnicode_FromFormat` для форматування повідомлення попередження. *format* "
"— це рядок у кодуванні ASCII."

#: ../../c-api/exceptions.rst:399
msgid ""
"Function similar to :c:func:`PyErr_WarnFormat`, but *category* is :exc:"
"`ResourceWarning` and it passes *source* to :class:`!warnings."
"WarningMessage`."
msgstr ""
"Функция аналогична :c:func:`PyErr_WarnFormat`, но *category* - это :exc:"
"`ResourceWarning`, и она передает *source* в :class:`!warnings."
"WarningMessage`."

#: ../../c-api/exceptions.rst:406
msgid "Querying the error indicator"
msgstr "Meminta indikator kesalahan"

#: ../../c-api/exceptions.rst:410
msgid ""
"Test whether the error indicator is set.  If set, return the exception "
"*type* (the first argument to the last call to one of the ``PyErr_Set*`` "
"functions or to :c:func:`PyErr_Restore`).  If not set, return ``NULL``.  You "
"do not own a reference to the return value, so you do not need to :c:func:"
"`Py_DECREF` it."
msgstr ""
"Проверяет, установлен ли индикатор ошибки. Если установлен, возвращает "
"исключение *type* (первый аргумент последнего вызова одной из функций "
"``PyErr_Set*`` или :c:func:`PyErr_Restore`). Если не задано, возвращает "
"``NULL``. У вас нет ссылки на возвращаемое значение, поэтому вам не нужно "
"её :c:func:`Py_DECREF`."

#: ../../c-api/exceptions.rst:416
msgid "The caller must hold the GIL."
msgstr ""

#: ../../c-api/exceptions.rst:420
msgid ""
"Do not compare the return value to a specific exception; use :c:func:"
"`PyErr_ExceptionMatches` instead, shown below.  (The comparison could easily "
"fail since the exception may be an instance instead of a class, in the case "
"of a class exception, or it may be a subclass of the expected exception.)"
msgstr ""
"Не порівнюйте повернуте значення з певним винятком; замість цього "
"використовуйте :c:func:`PyErr_ExceptionMatches`, як показано нижче. "
"(Порівняння може бути легко невдалим, оскільки виняток може бути екземпляром "
"замість класу, у випадку винятку класу, або він може бути підкласом "
"очікуваного винятку.)"

#: ../../c-api/exceptions.rst:428
msgid ""
"Equivalent to ``PyErr_GivenExceptionMatches(PyErr_Occurred(), exc)``.  This "
"should only be called when an exception is actually set; a memory access "
"violation will occur if no exception has been raised."
msgstr ""
"Еквівалент ``PyErr_GivenExceptionMatches(PyErr_Occurred(), exc)``. Це слід "
"викликати лише тоді, коли фактично встановлено виняток; порушення доступу до "
"пам'яті відбудеться, якщо не було викликано жодного винятку."

#: ../../c-api/exceptions.rst:435
msgid ""
"Return true if the *given* exception matches the exception type in *exc*.  "
"If *exc* is a class object, this also returns true when *given* is an "
"instance of a subclass.  If *exc* is a tuple, all exception types in the "
"tuple (and recursively in subtuples) are searched for a match."
msgstr ""
"Повертає true, якщо *given* виняток відповідає типу винятку в *exc*. Якщо "
"*exc* є об’єктом класу, це також повертає true, коли *given* є екземпляром "
"підкласу. Якщо *exc* є кортежем, усі типи винятків у кортежі (і рекурсивно в "
"підкортежах) шукаються на відповідність."

#: ../../c-api/exceptions.rst:443
msgid ""
"Return the exception currently being raised, clearing the error indicator at "
"the same time. Return ``NULL`` if the error indicator is not set."
msgstr ""
"Возвращает вызываемое в данный момент исключение, одновременно очищая "
"индикатор ошибки. Возвращает ``NULL``, если индикатор ошибки не установлен."

#: ../../c-api/exceptions.rst:446
msgid ""
"This function is used by code that needs to catch exceptions, or code that "
"needs to save and restore the error indicator temporarily."
msgstr ""
"Эта функция используется кодом, которому необходимо перехватывать "
"исключения, или кодом, которому необходимо временно сохранять и "
"восстанавливать индикатор ошибки."

#: ../../c-api/exceptions.rst:449 ../../c-api/exceptions.rst:493
msgid "For example::"
msgstr "Na przykład::"

#: ../../c-api/exceptions.rst:451
msgid ""
"{\n"
"   PyObject *exc = PyErr_GetRaisedException();\n"
"\n"
"   /* ... code that might produce other errors ... */\n"
"\n"
"   PyErr_SetRaisedException(exc);\n"
"}"
msgstr ""
"{\n"
"   PyObject *exc = PyErr_GetRaisedException();\n"
"\n"
"   /* ... code that might produce other errors ... */\n"
"\n"
"   PyErr_SetRaisedException(exc);\n"
"}"

#: ../../c-api/exceptions.rst:459
msgid ""
":c:func:`PyErr_GetHandledException`, to save the exception currently being "
"handled."
msgstr ""
":c:func:`PyErr_GetHandledException`, для сохранения обрабатываемого в данный "
"момент исключения."

#: ../../c-api/exceptions.rst:467
msgid ""
"Set *exc* as the exception currently being raised, clearing the existing "
"exception if one is set."
msgstr ""
"Устанавливает *exc* в качестве вызываемого в данный момент исключения, "
"очистив существующее исключение, если оно установлено."

#: ../../c-api/exceptions.rst:472
msgid "This call steals a reference to *exc*, which must be a valid exception."
msgstr ""
"Этот вызов забирает ссылку на *exc*, которая должна быть допустимым "
"исключением."

#: ../../c-api/exceptions.rst:481
msgid "Use :c:func:`PyErr_GetRaisedException` instead."
msgstr "Вместо этого используется :c:func:`PyErr_GetRaisedException`."

#: ../../c-api/exceptions.rst:483
msgid ""
"Retrieve the error indicator into three variables whose addresses are "
"passed. If the error indicator is not set, set all three variables to "
"``NULL``.  If it is set, it will be cleared and you own a reference to each "
"object retrieved.  The value and traceback object may be ``NULL`` even when "
"the type object is not."
msgstr ""
"Отримати індикатор помилки в трьох змінних, адреси яких передано. Якщо "
"індикатор помилки не встановлено, установіть для всіх трьох змінних значення "
"``NULL``. Якщо його встановлено, його буде очищено, і ви матимете посилання "
"на кожен отриманий об’єкт. Значення та об’єкт трасування можуть бути "
"``NULL``, навіть якщо об’єкт типу не є таким."

#: ../../c-api/exceptions.rst:490
msgid ""
"This function is normally only used by legacy code that needs to catch "
"exceptions or save and restore the error indicator temporarily."
msgstr ""
"Эта функция обычно используется только устаревшим кодом, которому необходимо "
"перехватывать исключения или временно сохранять и восстанавливать индикатор "
"ошибки."

#: ../../c-api/exceptions.rst:495
msgid ""
"{\n"
"   PyObject *type, *value, *traceback;\n"
"   PyErr_Fetch(&type, &value, &traceback);\n"
"\n"
"   /* ... code that might produce other errors ... */\n"
"\n"
"   PyErr_Restore(type, value, traceback);\n"
"}"
msgstr ""
"{\n"
"   PyObject *type, *value, *traceback;\n"
"   PyErr_Fetch(&type, &value, &traceback);\n"
"\n"
"   /* ... code that might produce other errors ... */\n"
"\n"
"   PyErr_Restore(type, value, traceback);\n"
"}"

#: ../../c-api/exceptions.rst:509
msgid "Use :c:func:`PyErr_SetRaisedException` instead."
msgstr "Вместо этого используйте :c:func:`PyErr_SetRaisedException`."

#: ../../c-api/exceptions.rst:511
msgid ""
"Set the error indicator from the three objects, *type*, *value*, and "
"*traceback*, clearing the existing exception if one is set. If the objects "
"are ``NULL``, the error indicator is cleared.  Do not pass a ``NULL`` type "
"and non-``NULL`` value or traceback.  The exception type should be a class.  "
"Do not pass an invalid exception type or value. (Violating these rules will "
"cause subtle problems later.)  This call takes away a reference to each "
"object: you must own a reference to each object before the call and after "
"the call you no longer own these references.  (If you don't understand this, "
"don't use this function.  I warned you.)"
msgstr ""
"Устанавливает индикатор ошибки для трех объектов: *type*, *value* и "
"*traceback*, удалив существующее исключение, если оно установлено. Если "
"объекты имеют значение ``NULL``, индикатор ошибки будет удален. Не передает "
"тип ``NULL`` и значение, отличное от ``NULL``, или данные обратной "
"трассировки. Типом исключения должен быть класс. Не передает недопустимый "
"тип исключения или значение. (Нарушение этих правил приведет к возникновению "
"незначительных проблем в дальнейшем). Этот вызов удаляет ссылку на каждый "
"объект: перед вызовом у вас должна быть ссылка на каждый объект, а после "
"вызова вы больше не будете владеть этими ссылками. (Если вы этого не "
"понимаете, не используйте эту функцию. Я вас предупреждал.)"

#: ../../c-api/exceptions.rst:525
msgid ""
"This function is normally only used by legacy code that needs to save and "
"restore the error indicator temporarily. Use :c:func:`PyErr_Fetch` to save "
"the current error indicator."
msgstr ""
"Эта функция обычно используется только в устаревшем коде, которому "
"необходимо временно сохранить и восстановить индикатор ошибки. Используйте :"
"c:func:`PyErr_Fetch` для сохранения текущего индикатора ошибки."

#: ../../c-api/exceptions.rst:534
msgid ""
"Use :c:func:`PyErr_GetRaisedException` instead, to avoid any possible de-"
"normalization."
msgstr ""
"Вместо этого используйте :c:func:`PyErr_GetRaisedException`, чтобы избежать "
"любой возможной нормализации."

#: ../../c-api/exceptions.rst:537
msgid ""
"Under certain circumstances, the values returned by :c:func:`PyErr_Fetch` "
"below can be \"unnormalized\", meaning that ``*exc`` is a class object but "
"``*val`` is not an instance of the  same class.  This function can be used "
"to instantiate the class in that case.  If the values are already "
"normalized, nothing happens. The delayed normalization is implemented to "
"improve performance."
msgstr ""
"За певних обставин значення, які повертає :c:func:`PyErr_Fetch` нижче, "
"можуть бути \"ненормалізованими\", тобто ``*exc`` є об’єктом класу, але "
"``*val`` не є екземпляром того самого класу . У цьому випадку цю функцію "
"можна використовувати для створення екземпляра класу. Якщо значення вже "
"нормалізовані, нічого не відбувається. Відкладену нормалізацію реалізовано "
"для покращення продуктивності."

#: ../../c-api/exceptions.rst:545
msgid ""
"This function *does not* implicitly set the :attr:`~BaseException."
"__traceback__` attribute on the exception value. If setting the traceback "
"appropriately is desired, the following additional snippet is needed::"
msgstr ""
"Эта функция *не устанавливает* неявно атрибут :attr:`~BaseException."
"__traceback__` для значения исключения. Если требуется соответствующая "
"настройка трассировки, необходим следующий дополнительный фрагмент кода::"

#: ../../c-api/exceptions.rst:550
msgid ""
"if (tb != NULL) {\n"
"  PyException_SetTraceback(val, tb);\n"
"}"
msgstr ""
"if (tb != NULL) {\n"
"  PyException_SetTraceback(val, tb);\n"
"}"

#: ../../c-api/exceptions.rst:557
msgid ""
"Retrieve the active exception instance, as would be returned by :func:`sys."
"exception`. This refers to an exception that was *already caught*, not to an "
"exception that was freshly raised. Returns a new reference to the exception "
"or ``NULL``. Does not modify the interpreter's exception state."
msgstr ""
"Извлекает активный экземпляр исключения, как это было бы возвращено с "
"помощью :func:`sys.exception`. Это относится к исключению, которое было *уже "
"перехвачено*, а не к исключению, которое было недавно создано. Возвращает "
"новую ссылку на исключение или ``NULL``. Не изменяет состояние исключения "
"интерпретатора."

#: ../../c-api/exceptions.rst:564
msgid ""
"This function is not normally used by code that wants to handle exceptions. "
"Rather, it can be used when code needs to save and restore the exception "
"state temporarily.  Use :c:func:`PyErr_SetHandledException` to restore or "
"clear the exception state."
msgstr ""
"Эта функция обычно не используется кодом, который хочет обрабатывать "
"исключения. Скорее, ее можно использовать, когда коду необходимо временно "
"сохранить и восстановить состояние исключения. Используйте :c:func:"
"`PyErr_SetHandledException` для восстановления или очистки состояния "
"исключения."

#: ../../c-api/exceptions.rst:573
msgid ""
"Set the active exception, as known from ``sys.exception()``.  This refers to "
"an exception that was *already caught*, not to an exception that was freshly "
"raised. To clear the exception state, pass ``NULL``."
msgstr ""
"Устанавливает активное исключение, как известно из ``sys.exception()``. Это "
"относится к исключению, которое было *уже перехвачено*, а не к исключению, "
"которое было вызвано недавно. Чтобы очистить состояние исключения, введите "
"``NULL``."

#: ../../c-api/exceptions.rst:580
msgid ""
"This function is not normally used by code that wants to handle exceptions. "
"Rather, it can be used when code needs to save and restore the exception "
"state temporarily.  Use :c:func:`PyErr_GetHandledException` to get the "
"exception state."
msgstr ""
"Эта функция обычно не используется кодом, который хочет обрабатывать "
"исключения. Скорее, ее можно использовать, когда коду необходимо временно "
"сохранить и восстановить состояние исключения. Используйте :c:func:"
"`PyErr_GetHandledException`, чтобы получить состояние исключения."

#: ../../c-api/exceptions.rst:589
msgid ""
"Retrieve the old-style representation of the exception info, as known from :"
"func:`sys.exc_info`.  This refers to an exception that was *already caught*, "
"not to an exception that was freshly raised.  Returns new references for the "
"three objects, any of which may be ``NULL``.  Does not modify the exception "
"info state.  This function is kept for backwards compatibility. Prefer "
"using :c:func:`PyErr_GetHandledException`."
msgstr ""
"Извлекает информацию об исключении в старом формате, известную из :func:`sys."
"exc_info`. Это относится к исключению, которое было *уже перехвачено*, а не "
"к исключению, которое было вызвано недавно. Возвращает новые ссылки для трех "
"объектов, любой из которых может быть ``NULL``. Не изменяет состояние "
"информации об исключении. Эта функция сохранена для обеспечения обратной "
"совместимости. Предпочтительно использовать :c:func:"
"`PyErr_GetHandledException`."

#: ../../c-api/exceptions.rst:598
msgid ""
"This function is not normally used by code that wants to handle exceptions. "
"Rather, it can be used when code needs to save and restore the exception "
"state temporarily.  Use :c:func:`PyErr_SetExcInfo` to restore or clear the "
"exception state."
msgstr ""
"Ця функція зазвичай не використовується кодом, який хоче обробляти винятки. "
"Натомість його можна використовувати, коли коду потрібно тимчасово зберегти "
"та відновити винятковий стан. Використовуйте :c:func:`PyErr_SetExcInfo`, щоб "
"відновити або видалити винятковий стан."

#: ../../c-api/exceptions.rst:608
msgid ""
"Set the exception info, as known from ``sys.exc_info()``.  This refers to an "
"exception that was *already caught*, not to an exception that was freshly "
"raised.  This function steals the references of the arguments. To clear the "
"exception state, pass ``NULL`` for all three arguments. This function is "
"kept for backwards compatibility. Prefer using :c:func:"
"`PyErr_SetHandledException`."
msgstr ""
"Задает информацию об исключении, как это известно из ``sys.exc_info()``. Это "
"относится к исключению, которое было *уже перехвачено*, а не к исключению, "
"которое было вызвано недавно. Эта функция крадет ссылки на аргументы. Чтобы "
"очистить состояние исключения, передайте ``NULL`` для всех трех аргументов. "
"Эта функция сохранена для обеспечения обратной совместимости. "
"Предпочтительно использовать :c:func:`PyErr_SetHandledException`."

#: ../../c-api/exceptions.rst:617
msgid ""
"This function is not normally used by code that wants to handle exceptions. "
"Rather, it can be used when code needs to save and restore the exception "
"state temporarily.  Use :c:func:`PyErr_GetExcInfo` to read the exception "
"state."
msgstr ""
"Ця функція зазвичай не використовується кодом, який хоче обробляти винятки. "
"Натомість його можна використовувати, коли коду потрібно тимчасово зберегти "
"та відновити винятковий стан. Використовуйте :c:func:`PyErr_GetExcInfo`, щоб "
"прочитати винятковий стан."

#: ../../c-api/exceptions.rst:624
msgid ""
"The ``type`` and ``traceback`` arguments are no longer used and can be NULL. "
"The interpreter now derives them from the exception instance (the ``value`` "
"argument). The function still steals references of all three arguments."
msgstr ""
"Аргументы ``type`` и ``traceback`` больше не используются и могут иметь "
"значение NULL. Интерпретатор теперь извлекает их из экземпляра исключения "
"(аргумент ``value``). Функция по-прежнему перехватывает ссылки на все три "
"аргумента."

#: ../../c-api/exceptions.rst:632
msgid "Signal Handling"
msgstr "Penanganan Sinyal *Signal*"

#: ../../c-api/exceptions.rst:642
msgid "This function interacts with Python's signal handling."
msgstr "Ця функція взаємодіє з обробкою сигналів Python."

#: ../../c-api/exceptions.rst:644
msgid ""
"If the function is called from the main thread and under the main Python "
"interpreter, it checks whether a signal has been sent to the processes and "
"if so, invokes the corresponding signal handler.  If the :mod:`signal` "
"module is supported, this can invoke a signal handler written in Python."
msgstr ""
"Якщо функція викликається з головного потоку та під основним інтерпретатором "
"Python, вона перевіряє, чи було надіслано сигнал до процесів, і якщо так, "
"викликає відповідний обробник сигналу. Якщо модуль :mod:`signal` "
"підтримується, це може викликати обробник сигналів, написаний на Python."

#: ../../c-api/exceptions.rst:649
msgid ""
"The function attempts to handle all pending signals, and then returns ``0``. "
"However, if a Python signal handler raises an exception, the error indicator "
"is set and the function returns ``-1`` immediately (such that other pending "
"signals may not have been handled yet: they will be on the next :c:func:"
"`PyErr_CheckSignals()` invocation)."
msgstr ""
"Функція намагається обробити всі незавершені сигнали, а потім повертає "
"``0``. Однак, якщо обробник сигналів Python викликає виняток, індикатор "
"помилки встановлюється, і функція негайно повертає ``-1`` (наприклад, інші "
"сигнали, що очікують на розгляд, ще не були оброблені: вони будуть на "
"наступному :c:func:`PyErr_CheckSignals()` виклик)."

#: ../../c-api/exceptions.rst:655
msgid ""
"If the function is called from a non-main thread, or under a non-main Python "
"interpreter, it does nothing and returns ``0``."
msgstr ""
"Якщо функція викликається з неосновного потоку або під неосновним "
"інтерпретатором Python, вона нічого не робить і повертає ``0``."

#: ../../c-api/exceptions.rst:658
msgid ""
"This function can be called by long-running C code that wants to be "
"interruptible by user requests (such as by pressing Ctrl-C)."
msgstr ""
"Ця функція може бути викликана довгостроковим кодом C, який хоче бути "
"перерваним запитами користувача (наприклад, натисканням Ctrl-C)."

#: ../../c-api/exceptions.rst:662
msgid ""
"The default Python signal handler for :c:macro:`!SIGINT` raises the :exc:"
"`KeyboardInterrupt` exception."
msgstr ""
"Обработчик сигналов Python по умолчанию для :c:macro:`!SIGINT` вызывает "
"исключение :exc:`KeyboardInterrupt`."

#: ../../c-api/exceptions.rst:673
msgid ""
"Simulate the effect of a :c:macro:`!SIGINT` signal arriving. This is "
"equivalent to ``PyErr_SetInterruptEx(SIGINT)``."
msgstr ""
"Имитирует эффект поступления сигнала :c:macro:`!SIGINT`. Это эквивалентно "
"``PyErr_SetInterruptEx(SIGINT)``."

#: ../../c-api/exceptions.rst:677 ../../c-api/exceptions.rst:704
msgid ""
"This function is async-signal-safe.  It can be called without the :term:"
"`GIL` and from a C signal handler."
msgstr ""

#: ../../c-api/exceptions.rst:687
msgid ""
"Simulate the effect of a signal arriving. The next time :c:func:"
"`PyErr_CheckSignals` is called,  the Python signal handler for the given "
"signal number will be called."
msgstr ""
"Імітація ефекту надходження сигналу. Під час наступного виклику :c:func:"
"`PyErr_CheckSignals` буде викликано обробник сигналу Python для заданого "
"номера сигналу."

#: ../../c-api/exceptions.rst:691
msgid ""
"This function can be called by C code that sets up its own signal handling "
"and wants Python signal handlers to be invoked as expected when an "
"interruption is requested (for example when the user presses Ctrl-C to "
"interrupt an operation)."
msgstr ""
"Цю функцію можна викликати за допомогою коду C, який налаштовує власну "
"обробку сигналів і хоче, щоб обробники сигналів Python викликалися належним "
"чином, коли надходить запит на переривання (наприклад, коли користувач "
"натискає Ctrl-C, щоб перервати операцію)."

#: ../../c-api/exceptions.rst:696
msgid ""
"If the given signal isn't handled by Python (it was set to :py:const:`signal."
"SIG_DFL` or :py:const:`signal.SIG_IGN`), it will be ignored."
msgstr ""
"Если данный сигнал не обрабатывается Python (для него было задано значение :"
"const:`signal.SIG_DFL` или :const:`signal.SIG_IGN`), он будет проигнорирован."

#: ../../c-api/exceptions.rst:699
msgid ""
"If *signum* is outside of the allowed range of signal numbers, ``-1`` is "
"returned.  Otherwise, ``0`` is returned.  The error indicator is never "
"changed by this function."
msgstr ""
"Якщо *signum* знаходиться за межами дозволеного діапазону чисел сигналу, "
"повертається ``-1``. В іншому випадку повертається ``0``. Ця функція ніколи "
"не змінює індикатор помилки."

#: ../../c-api/exceptions.rst:712
msgid ""
"This utility function specifies a file descriptor to which the signal number "
"is written as a single byte whenever a signal is received. *fd* must be non-"
"blocking. It returns the previous such file descriptor."
msgstr ""
"Ця допоміжна функція вказує дескриптор файлу, до якого номер сигналу "
"записується як один байт кожного разу, коли надходить сигнал. *fd* має бути "
"неблокуючим. Він повертає попередній такий файловий дескриптор."

#: ../../c-api/exceptions.rst:716
msgid ""
"The value ``-1`` disables the feature; this is the initial state. This is "
"equivalent to :func:`signal.set_wakeup_fd` in Python, but without any error "
"checking.  *fd* should be a valid file descriptor.  The function should only "
"be called from the main thread."
msgstr ""
"Значення ``-1`` вимикає функцію; це початковий стан. Це еквівалентно :func:"
"`signal.set_wakeup_fd` у Python, але без перевірки помилок. *fd* має бути "
"дійсним дескриптором файлу. Функцію слід викликати лише з основного потоку."

#: ../../c-api/exceptions.rst:721
msgid "On Windows, the function now also supports socket handles."
msgstr "У Windows функція тепер також підтримує ручки сокетів."

#: ../../c-api/exceptions.rst:726
msgid "Exception Classes"
msgstr "Kelas Pengecualian"

#: ../../c-api/exceptions.rst:730
msgid ""
"This utility function creates and returns a new exception class. The *name* "
"argument must be the name of the new exception, a C string of the form "
"``module.classname``.  The *base* and *dict* arguments are normally "
"``NULL``. This creates a class object derived from :exc:`Exception` "
"(accessible in C as :c:data:`PyExc_Exception`)."
msgstr ""
"Ця службова функція створює та повертає новий клас винятків. Аргумент *name* "
"має бути назвою нового винятку, рядком C у формі ``module.classname``. "
"Аргументи *base* і *dict* зазвичай мають значення ``NULL``. Це створює "
"об’єкт класу, похідний від :exc:`Exception` (доступний у C як :c:data:"
"`PyExc_Exception`)."

#: ../../c-api/exceptions.rst:736
msgid ""
"The :attr:`~type.__module__` attribute of the new class is set to the first "
"part (up to the last dot) of the *name* argument, and the class name is set "
"to the last part (after the last dot).  The *base* argument can be used to "
"specify alternate base classes; it can either be only one class or a tuple "
"of classes. The *dict* argument can be used to specify a dictionary of class "
"variables and methods."
msgstr ""
"Атрибут :attr:`~type.__module__` нового класса устанавливается в первую "
"часть (до последней точки) аргумента *name*, а имя класса устанавливается в "
"последнюю часть (после последней точки). ). Аргумент *base* можно "
"использовать для указания альтернативных базовых классов; это может быть "
"либо только один класс, либо кортеж классов. Аргумент *dict* можно "
"использовать для указания словаря переменных и методов класса."

#: ../../c-api/exceptions.rst:745
msgid ""
"Same as :c:func:`PyErr_NewException`, except that the new exception class "
"can easily be given a docstring: If *doc* is non-``NULL``, it will be used "
"as the docstring for the exception class."
msgstr ""
"Те саме, що :c:func:`PyErr_NewException`, за винятком того, що новому класу "
"винятків можна легко надати рядок документації: якщо *doc* не є ``NULL``, "
"він використовуватиметься як рядок документації для класу винятків."

#: ../../c-api/exceptions.rst:754
msgid ""
"Return non-zero if *ob* is an exception class, zero otherwise. This function "
"always succeeds."
msgstr "如果 *ob* 是异常类则返回非零，否则返回零。此函数总是会成功执行。"

#: ../../c-api/exceptions.rst:759
msgid "Return :c:member:`~PyTypeObject.tp_name` of the exception class *ob*."
msgstr "返回异常类 *ob* 的 :c:member:`~PyTypeObject.tp_name`。"

#: ../../c-api/exceptions.rst:763
msgid "Exception Objects"
msgstr "Przedmioty Sytuacji Wyjątkowych"

#: ../../c-api/exceptions.rst:767
msgid ""
"Return the traceback associated with the exception as a new reference, as "
"accessible from Python through the :attr:`~BaseException.__traceback__` "
"attribute. If there is no traceback associated, this returns ``NULL``."
msgstr ""
"Возвращает обратную трассировку, связанную с исключением, в виде новой "
"ссылки, доступной из Python через атрибут :attr:`~BaseException."
"__traceback__`. Если обратная трассировка не связана, возвращается значение "
"``NULL``."

#: ../../c-api/exceptions.rst:775
msgid ""
"Set the traceback associated with the exception to *tb*.  Use ``Py_None`` to "
"clear it."
msgstr ""
"Установіть для трасування, пов’язаного з винятком, значення *tb*. "
"Використовуйте ``Py_None``, щоб очистити його."

#: ../../c-api/exceptions.rst:781
msgid ""
"Return the context (another exception instance during whose handling *ex* "
"was raised) associated with the exception as a new reference, as accessible "
"from Python through the :attr:`~BaseException.__context__` attribute. If "
"there is no context associated, this returns ``NULL``."
msgstr ""
"Возвращает контекст (другой экземпляр исключения, во время обработки "
"которого был запущен *ex*), связанный с исключением, в качестве новой "
"ссылки, доступной из Python через атрибут :attr:`~BaseException."
"__context__`. Если контекст не связан, то возвращается значение ``NULL``."

#: ../../c-api/exceptions.rst:789
msgid ""
"Set the context associated with the exception to *ctx*.  Use ``NULL`` to "
"clear it.  There is no type check to make sure that *ctx* is an exception "
"instance. This steals a reference to *ctx*."
msgstr ""
"Установіть для контексту, пов’язаного з винятком, значення *ctx*. Щоб "
"очистити його, використовуйте ``NULL``. Немає перевірки типу, щоб "
"переконатися, що *ctx* є винятком. Це краде посилання на *ctx*."

#: ../../c-api/exceptions.rst:796
msgid ""
"Return the cause (either an exception instance, or ``None``, set by "
"``raise ... from ...``) associated with the exception as a new reference, as "
"accessible from Python through the :attr:`~BaseException.__cause__` "
"attribute."
msgstr ""
"Возвращает причину (либо экземпляр исключения, либо ``None``, заданный "
"параметром ``raise ... from ...``), связанную с исключением в качестве новой "
"ссылки, доступной из Python через атрибут :attr:`~BaseException.__cause__`."

#: ../../c-api/exceptions.rst:804
msgid ""
"Set the cause associated with the exception to *cause*.  Use ``NULL`` to "
"clear it.  There is no type check to make sure that *cause* is either an "
"exception instance or ``None``.  This steals a reference to *cause*."
msgstr ""
"Задает для причины, связанной с исключением, значение *cause*. Используйте "
"``NULL``, чтобы очистить его. Нет проверки типа, чтобы убедиться, что "
"*cause* является либо экземпляром исключения, либо ``None``. Это приведет к "
"краже ссылки на *cause*."

#: ../../c-api/exceptions.rst:808
msgid ""
"The :attr:`~BaseException.__suppress_context__` attribute is implicitly set "
"to ``True`` by this function."
msgstr ""
"Атрибуту :attr:`~BaseException.__suppress_context__` этой функцией неявно "
"присваивается значение ``True``."

#: ../../c-api/exceptions.rst:814
msgid "Return :attr:`~BaseException.args` of exception *ex*."
msgstr "Возвращает :attr:`~BaseException.args` из исключения *ex*."

#: ../../c-api/exceptions.rst:819
msgid "Set :attr:`~BaseException.args` of exception *ex* to *args*."
msgstr ""
"Устанавливает :attr:`~BaseException.args` для исключения *ex* в *args*."

#: ../../c-api/exceptions.rst:823
msgid ""
"Implement part of the interpreter's implementation of :keyword:`!except*`. "
"*orig* is the original exception that was caught, and *excs* is the list of "
"the exceptions that need to be raised. This list contains the unhandled part "
"of *orig*, if any, as well as the exceptions that were raised from the :"
"keyword:`!except*` clauses (so they have a different traceback from *orig*) "
"and those that were reraised (and have the same traceback as *orig*). Return "
"the :exc:`ExceptionGroup` that needs to be reraised in the end, or ``None`` "
"if there is nothing to reraise."
msgstr ""
"Реализует часть реализации интерпретатора :keyword:`!except*`. *orig* - это "
"исходное исключение, которое было перехвачено, а *excs* - это список "
"исключений, которые необходимо вызвать. Этот список содержит необработанную "
"часть *orig*, если таковая имеется, а также исключения, которые были вызваны "
"предложениями :keyword:`!except*` (поэтому они имеют обратную трассировку, "
"отличную от *orig*), и те, которые были повторно запущены (и имеют ту же "
"обратную трассировку, что и *orig*). Возвращает :exc:`ExceptionGroup`, "
"который в конце должен быть повторно вызван, или ``None``, если повторно "
"вызывать нечего."

#: ../../c-api/exceptions.rst:837
msgid "Unicode Exception Objects"
msgstr "Objek Pengecualian Unicode"

#: ../../c-api/exceptions.rst:839
msgid ""
"The following functions are used to create and modify Unicode exceptions "
"from C."
msgstr ""
"Наступні функції використовуються для створення та зміни винятків Unicode з "
"C."

#: ../../c-api/exceptions.rst:843
msgid ""
"Create a :class:`UnicodeDecodeError` object with the attributes *encoding*, "
"*object*, *length*, *start*, *end* and *reason*. *encoding* and *reason* are "
"UTF-8 encoded strings."
msgstr ""
"Створіть об’єкт :class:`UnicodeDecodeError` з атрибутами *encoding*, "
"*object*, *length*, *start*, *end* і *reason*. *encoding* і *reason* є "
"рядками в кодуванні UTF-8."

#: ../../c-api/exceptions.rst:850
msgid "Return the *encoding* attribute of the given exception object."
msgstr "Повертає атрибут *encoding* даного об’єкта винятку."

#: ../../c-api/exceptions.rst:856
msgid "Return the *object* attribute of the given exception object."
msgstr "Повертає атрибут *object* даного об’єкта винятку."

#: ../../c-api/exceptions.rst:862
msgid ""
"Get the *start* attribute of the given exception object and place it into "
"*\\*start*.  *start* must not be ``NULL``.  Return ``0`` on success, ``-1`` "
"on failure."
msgstr ""
"Отримайте атрибут *start* даного об’єкта винятку та помістіть його в "
"*\\*start*. *початок* не має бути ``NULL``. Повертає ``0`` в разі успіху, "
"``-1`` у випадку невдачі."

#: ../../c-api/exceptions.rst:870
msgid ""
"Set the *start* attribute of the given exception object to *start*.  Return "
"``0`` on success, ``-1`` on failure."
msgstr ""

#: ../../c-api/exceptions.rst:877
msgid ""
"Get the *end* attribute of the given exception object and place it into "
"*\\*end*.  *end* must not be ``NULL``.  Return ``0`` on success, ``-1`` on "
"failure."
msgstr ""
"Отримайте атрибут *end* даного об’єкта винятку та помістіть його в *\\*end*. "
"*end* не має бути ``NULL``. Повертає ``0`` в разі успіху, ``-1`` у випадку "
"невдачі."

#: ../../c-api/exceptions.rst:885
msgid ""
"Set the *end* attribute of the given exception object to *end*.  Return "
"``0`` on success, ``-1`` on failure."
msgstr ""
"Установіть для атрибута *end* даного об’єкта винятку значення *end*. "
"Повертає ``0`` в разі успіху, ``-1`` у випадку невдачі."

#: ../../c-api/exceptions.rst:892
msgid "Return the *reason* attribute of the given exception object."
msgstr "Повертає атрибут *reason* даного об’єкта винятку."

#: ../../c-api/exceptions.rst:898
msgid ""
"Set the *reason* attribute of the given exception object to *reason*.  "
"Return ``0`` on success, ``-1`` on failure."
msgstr ""
"Установіть для атрибута *reason* даного об’єкта винятку значення *reason*. "
"Повертає ``0`` в разі успіху, ``-1`` у випадку невдачі."

#: ../../c-api/exceptions.rst:905
msgid "Recursion Control"
msgstr "Kontrola Rekursji"

#: ../../c-api/exceptions.rst:907
msgid ""
"These two functions provide a way to perform safe recursive calls at the C "
"level, both in the core and in extension modules.  They are needed if the "
"recursive code does not necessarily invoke Python code (which tracks its "
"recursion depth automatically). They are also not needed for *tp_call* "
"implementations because the :ref:`call protocol <call>` takes care of "
"recursion handling."
msgstr ""
"Ці дві функції забезпечують спосіб виконання безпечних рекурсивних викликів "
"на рівні C, як в ядрі, так і в модулях розширення. Вони потрібні, якщо "
"рекурсивний код не обов’язково викликає код Python (який автоматично "
"відстежує глибину рекурсії). Вони також не потрібні для реалізації "
"*tp_call*, оскільки :ref:`протокол виклику <call>` піклується про обробку "
"рекурсії."

#: ../../c-api/exceptions.rst:916
msgid "Marks a point where a recursive C-level call is about to be performed."
msgstr "Позначає точку, де має бути виконано рекурсивний виклик C-рівня."

#: ../../c-api/exceptions.rst:918
msgid ""
"If :c:macro:`!USE_STACKCHECK` is defined, this function checks if the OS "
"stack overflowed using :c:func:`PyOS_CheckStack`.  If this is the case, it "
"sets a :exc:`MemoryError` and returns a nonzero value."
msgstr ""

#: ../../c-api/exceptions.rst:922
msgid ""
"The function then checks if the recursion limit is reached.  If this is the "
"case, a :exc:`RecursionError` is set and a nonzero value is returned. "
"Otherwise, zero is returned."
msgstr ""

#: ../../c-api/exceptions.rst:926
msgid ""
"*where* should be a UTF-8 encoded string such as ``\" in instance check\"`` "
"to be concatenated to the :exc:`RecursionError` message caused by the "
"recursion depth limit."
msgstr ""
"*де* має бути рядок у кодуванні UTF-8, такий як ``\" у перевірці "
"екземпляра\"``, який об’єднується з повідомленням :exc:`RecursionError`, "
"спричиненим обмеженням глибини рекурсії."

#: ../../c-api/exceptions.rst:930 ../../c-api/exceptions.rst:938
msgid ""
"This function is now also available in the :ref:`limited API <limited-c-"
"api>`."
msgstr ""
"Эта функция теперь также доступна в :ref:`limited API <limited-c-api>`."

#: ../../c-api/exceptions.rst:935
msgid ""
"Ends a :c:func:`Py_EnterRecursiveCall`.  Must be called once for each "
"*successful* invocation of :c:func:`Py_EnterRecursiveCall`."
msgstr ""
"Завершує :c:func:`Py_EnterRecursiveCall`. Потрібно викликати один раз для "
"кожного *успішного* виклику :c:func:`Py_EnterRecursiveCall`."

#: ../../c-api/exceptions.rst:941
msgid ""
"Properly implementing :c:member:`~PyTypeObject.tp_repr` for container types "
"requires special recursion handling.  In addition to protecting the stack, :"
"c:member:`~PyTypeObject.tp_repr` also needs to track objects to prevent "
"cycles.  The following two functions facilitate this functionality.  "
"Effectively, these are the C equivalent to :func:`reprlib.recursive_repr`."
msgstr ""
"Правильна реалізація :c:member:`~PyTypeObject.tp_repr` для типів контейнерів "
"вимагає спеціальної обробки рекурсії. Окрім захисту стека, :c:member:"
"`~PyTypeObject.tp_repr` також має відстежувати об’єкти, щоб запобігти "
"циклам. Наступні дві функції полегшують цю функцію. По суті, це C "
"еквівалент :func:`reprlib.recursive_repr`."

#: ../../c-api/exceptions.rst:949
msgid ""
"Called at the beginning of the :c:member:`~PyTypeObject.tp_repr` "
"implementation to detect cycles."
msgstr ""
"Викликається на початку реалізації :c:member:`~PyTypeObject.tp_repr` для "
"виявлення циклів."

#: ../../c-api/exceptions.rst:952
msgid ""
"If the object has already been processed, the function returns a positive "
"integer.  In that case the :c:member:`~PyTypeObject.tp_repr` implementation "
"should return a string object indicating a cycle.  As examples, :class:"
"`dict` objects return ``{...}`` and :class:`list` objects return ``[...]``."
msgstr ""
"Якщо об’єкт уже оброблено, функція повертає додатне ціле число. У цьому "
"випадку реалізація :c:member:`~PyTypeObject.tp_repr` має повертати рядковий "
"об’єкт, що вказує на цикл. Як приклад, об’єкти :class:`dict` повертають "
"``{...}``, а об’єкти :class:`list` повертають ``[...]``."

#: ../../c-api/exceptions.rst:958
msgid ""
"The function will return a negative integer if the recursion limit is "
"reached.  In that case the :c:member:`~PyTypeObject.tp_repr` implementation "
"should typically return ``NULL``."
msgstr ""
"Функція поверне від’ємне ціле число, якщо досягнуто обмеження рекурсії. У "
"цьому випадку реалізація :c:member:`~PyTypeObject.tp_repr` зазвичай повинна "
"повертати ``NULL``."

#: ../../c-api/exceptions.rst:962
msgid ""
"Otherwise, the function returns zero and the :c:member:`~PyTypeObject."
"tp_repr` implementation can continue normally."
msgstr ""
"В іншому випадку функція повертає нуль, і реалізація :c:member:"
"`~PyTypeObject.tp_repr` може продовжуватися нормально."

#: ../../c-api/exceptions.rst:967
msgid ""
"Ends a :c:func:`Py_ReprEnter`.  Must be called once for each invocation of :"
"c:func:`Py_ReprEnter` that returns zero."
msgstr ""
"Завершує :c:func:`Py_ReprEnter`. Потрібно викликати один раз для кожного "
"виклику :c:func:`Py_ReprEnter`, який повертає нуль."

#: ../../c-api/exceptions.rst:974
msgid "Exception and warning types"
msgstr ""

#: ../../c-api/exceptions.rst:976
msgid ""
"All standard Python exceptions and warning categories are available as "
"global variables whose names are ``PyExc_`` followed by the Python exception "
"name. These have the type :c:expr:`PyObject*`; they are all class objects."
msgstr ""

#: ../../c-api/exceptions.rst:980
msgid "For completeness, here are all the variables:"
msgstr ""

#: ../../c-api/exceptions.rst:983
msgid "Exception types"
msgstr ""

#: ../../c-api/exceptions.rst:990 ../../c-api/exceptions.rst:1136
#: ../../c-api/exceptions.rst:1166
msgid "C name"
msgstr ""

#: ../../c-api/exceptions.rst:991 ../../c-api/exceptions.rst:1137
#: ../../c-api/exceptions.rst:1167
msgid "Python name"
msgstr ""

#: ../../c-api/exceptions.rst:993
msgid ":exc:`BaseException`"
msgstr ":exc:`BaseException`"

#: ../../c-api/exceptions.rst:995
msgid ":exc:`BaseExceptionGroup`"
msgstr ":exc:`BaseExceptionGroup`"

#: ../../c-api/exceptions.rst:997
msgid ":exc:`Exception`"
msgstr ":exc:`Exception`"

#: ../../c-api/exceptions.rst:999
msgid ":exc:`ArithmeticError`"
msgstr ":exc:`ArithmeticError`"

#: ../../c-api/exceptions.rst:1001
msgid ":exc:`AssertionError`"
msgstr ":exc:`AssertionError`"

#: ../../c-api/exceptions.rst:1003
msgid ":exc:`AttributeError`"
msgstr ":exc:`AttributeError`"

#: ../../c-api/exceptions.rst:1005
msgid ":exc:`BlockingIOError`"
msgstr ":exc:`BlockingIOError`"

#: ../../c-api/exceptions.rst:1007
msgid ":exc:`BrokenPipeError`"
msgstr ":exc:`BrokenPipeError`"

#: ../../c-api/exceptions.rst:1009
msgid ":exc:`BufferError`"
msgstr ":exc:`BufferError`"

#: ../../c-api/exceptions.rst:1011
msgid ":exc:`ChildProcessError`"
msgstr ":exc:`ChildProcessError`"

#: ../../c-api/exceptions.rst:1013
msgid ":exc:`ConnectionAbortedError`"
msgstr ":exc:`ConnectionAbortedError`"

#: ../../c-api/exceptions.rst:1015
msgid ":exc:`ConnectionError`"
msgstr ":exc:`ConnectionError`"

#: ../../c-api/exceptions.rst:1017
msgid ":exc:`ConnectionRefusedError`"
msgstr ":exc:`ConnectionRefusedError`"

#: ../../c-api/exceptions.rst:1019
msgid ":exc:`ConnectionResetError`"
msgstr ":exc:`ConnectionResetError`"

#: ../../c-api/exceptions.rst:1021
msgid ":exc:`EOFError`"
msgstr ":exc:`EOFError`"

#: ../../c-api/exceptions.rst:1023
msgid ":exc:`FileExistsError`"
msgstr ":exc:`FileExistsError`"

#: ../../c-api/exceptions.rst:1025
msgid ":exc:`FileNotFoundError`"
msgstr ":exc:`FileNotFoundError`"

#: ../../c-api/exceptions.rst:1027
msgid ":exc:`FloatingPointError`"
msgstr ":exc:`FloatingPointError`"

#: ../../c-api/exceptions.rst:1029
msgid ":exc:`GeneratorExit`"
msgstr ":exc:`GeneratorExit`"

#: ../../c-api/exceptions.rst:1031
msgid ":exc:`ImportError`"
msgstr ":exc:`ImportError`"

#: ../../c-api/exceptions.rst:1033
msgid ":exc:`IndentationError`"
msgstr ":exc:`IndentationError`"

#: ../../c-api/exceptions.rst:1035
msgid ":exc:`IndexError`"
msgstr ":exc:`IndexError`"

#: ../../c-api/exceptions.rst:1037
msgid ":exc:`InterruptedError`"
msgstr ":exc:`InterruptedError`"

#: ../../c-api/exceptions.rst:1039
msgid ":exc:`IsADirectoryError`"
msgstr ":exc:`IsADirectoryError`"

#: ../../c-api/exceptions.rst:1041
msgid ":exc:`KeyError`"
msgstr ":exc:`KeyError`"

#: ../../c-api/exceptions.rst:1043
msgid ":exc:`KeyboardInterrupt`"
msgstr ":exc:`KeyboardInterrupt`"

#: ../../c-api/exceptions.rst:1045
msgid ":exc:`LookupError`"
msgstr ":exc:`LookupError`"

#: ../../c-api/exceptions.rst:1047
msgid ":exc:`MemoryError`"
msgstr ":exc:`MemoryError`"

#: ../../c-api/exceptions.rst:1049
msgid ":exc:`ModuleNotFoundError`"
msgstr ":exc:`ModuleNotFoundError`"

#: ../../c-api/exceptions.rst:1051
msgid ":exc:`NameError`"
msgstr ":exc:`NameError`"

#: ../../c-api/exceptions.rst:1053
msgid ":exc:`NotADirectoryError`"
msgstr ":exc:`NotADirectoryError`"

#: ../../c-api/exceptions.rst:1055
msgid ":exc:`NotImplementedError`"
msgstr ":exc:`NotImplementedError`"

#: ../../c-api/exceptions.rst:1057 ../../c-api/exceptions.rst:1140
#: ../../c-api/exceptions.rst:1143 ../../c-api/exceptions.rst:1146
msgid ":exc:`OSError`"
msgstr ":exc:`OSError`"

#: ../../c-api/exceptions.rst:1059
msgid ":exc:`OverflowError`"
msgstr ":exc:`OverflowError`"

#: ../../c-api/exceptions.rst:1061
msgid ":exc:`PermissionError`"
msgstr ":exc:`PermissionError`"

#: ../../c-api/exceptions.rst:1063
msgid ":exc:`ProcessLookupError`"
msgstr ":exc:`ProcessLookupError`"

#: ../../c-api/exceptions.rst:1065
msgid ":exc:`PythonFinalizationError`"
msgstr ":exc:`PythonFinalizationError`"

#: ../../c-api/exceptions.rst:1067
msgid ":exc:`RecursionError`"
msgstr ":exc:`RecursionError`"

#: ../../c-api/exceptions.rst:1069
msgid ":exc:`ReferenceError`"
msgstr ":exc:`ReferenceError`"

#: ../../c-api/exceptions.rst:1071
msgid ":exc:`RuntimeError`"
msgstr ":exc:`RuntimeError`"

#: ../../c-api/exceptions.rst:1073
msgid ":exc:`StopAsyncIteration`"
msgstr ":exc:`StopAsyncIteration`"

#: ../../c-api/exceptions.rst:1075
msgid ":exc:`StopIteration`"
msgstr ":exc:`StopIteration`"

#: ../../c-api/exceptions.rst:1077
msgid ":exc:`SyntaxError`"
msgstr ":exc:`SyntaxError`"

#: ../../c-api/exceptions.rst:1079
msgid ":exc:`SystemError`"
msgstr ":exc:`SystemError`"

#: ../../c-api/exceptions.rst:1081
msgid ":exc:`SystemExit`"
msgstr ":exc:`SystemExit`"

#: ../../c-api/exceptions.rst:1083
msgid ":exc:`TabError`"
msgstr ":exc:`TabError`"

#: ../../c-api/exceptions.rst:1085
msgid ":exc:`TimeoutError`"
msgstr ":exc:`TimeoutError`"

#: ../../c-api/exceptions.rst:1087
msgid ":exc:`TypeError`"
msgstr ":exc:`TypeError`"

#: ../../c-api/exceptions.rst:1089
msgid ":exc:`UnboundLocalError`"
msgstr ":exc:`UnboundLocalError`"

#: ../../c-api/exceptions.rst:1091
msgid ":exc:`UnicodeDecodeError`"
msgstr ":exc:`UnicodeDecodeError`"

#: ../../c-api/exceptions.rst:1093
msgid ":exc:`UnicodeEncodeError`"
msgstr ":exc:`UnicodeEncodeError`"

#: ../../c-api/exceptions.rst:1095
msgid ":exc:`UnicodeError`"
msgstr ":exc:`UnicodeError`"

#: ../../c-api/exceptions.rst:1097
msgid ":exc:`UnicodeTranslateError`"
msgstr ":exc:`UnicodeTranslateError`"

#: ../../c-api/exceptions.rst:1099
msgid ":exc:`ValueError`"
msgstr ":exc:`ValueError`"

#: ../../c-api/exceptions.rst:1101
msgid ":exc:`ZeroDivisionError`"
msgstr ":exc:`ZeroDivisionError`"

#: ../../c-api/exceptions.rst:1103
msgid ""
":c:data:`PyExc_BlockingIOError`, :c:data:`PyExc_BrokenPipeError`, :c:data:"
"`PyExc_ChildProcessError`, :c:data:`PyExc_ConnectionError`, :c:data:"
"`PyExc_ConnectionAbortedError`, :c:data:`PyExc_ConnectionRefusedError`, :c:"
"data:`PyExc_ConnectionResetError`, :c:data:`PyExc_FileExistsError`, :c:data:"
"`PyExc_FileNotFoundError`, :c:data:`PyExc_InterruptedError`, :c:data:"
"`PyExc_IsADirectoryError`, :c:data:`PyExc_NotADirectoryError`, :c:data:"
"`PyExc_PermissionError`, :c:data:`PyExc_ProcessLookupError` and :c:data:"
"`PyExc_TimeoutError` were introduced following :pep:`3151`."
msgstr ""
":c:data:`PyExc_BlockingIOError`, :c:data:`PyExc_BrokenPipeError`, :c:data:"
"`PyExc_ChildProcessError`, :c:data:`PyExc_ConnectionError`, :c:data:"
"`PyExc_ConnectionAbortedError`, :c:data:`PyExc_ConnectionRefusedError`, :c:"
"data:`PyExc_ConnectionResetError`, :c:data:`PyExc_FileExistsError`, :c:data:"
"`PyExc_FileNotFoundError`, :c:data:`PyExc_InterruptedError`, :c:data:"
"`PyExc_IsADirectoryError`, :c:data:`PyExc_NotADirectoryError`, :c:data:"
"`PyExc_PermissionError`, :c:data:`PyExc_ProcessLookupError` dan :c:data:"
"`PyExc_TimeoutError` diperkenalkan berikut :pep:`3151`."

#: ../../c-api/exceptions.rst:1113
msgid ":c:data:`PyExc_StopAsyncIteration` and :c:data:`PyExc_RecursionError`."
msgstr ":c:data:`PyExc_StopAsyncIteration` dan :c:data:`PyExc_RecursionError`."

#: ../../c-api/exceptions.rst:1116
msgid ":c:data:`PyExc_ModuleNotFoundError`."
msgstr ":c:data:`PyExc_ModuleNotFoundError`."

#: ../../c-api/exceptions.rst:1119
msgid ":c:data:`PyExc_BaseExceptionGroup`."
msgstr ":c:data:`PyExc_BaseExceptionGroup`."

#: ../../c-api/exceptions.rst:1124
msgid "OSError aliases"
msgstr ""

#: ../../c-api/exceptions.rst:1126
msgid "The following are a compatibility aliases to :c:data:`PyExc_OSError`."
msgstr ""

#: ../../c-api/exceptions.rst:1128
msgid "These aliases used to be separate exception types."
msgstr "Раніше ці псевдоніми були окремими типами винятків."

#: ../../c-api/exceptions.rst:1138
msgid "Notes"
msgstr "註解"

#: ../../c-api/exceptions.rst:1147
msgid "[win]_"
msgstr ""

#: ../../c-api/exceptions.rst:1149
msgid "Notes:"
msgstr "註解："

#: ../../c-api/exceptions.rst:1152
msgid ""
":c:var:`!PyExc_WindowsError` is only defined on Windows; protect code that "
"uses this by testing that the preprocessor macro ``MS_WINDOWS`` is defined."
msgstr ""

#: ../../c-api/exceptions.rst:1159
msgid "Warning types"
msgstr ""

#: ../../c-api/exceptions.rst:1169
msgid ":exc:`Warning`"
msgstr ":exc:`Warning`"

#: ../../c-api/exceptions.rst:1171
msgid ":exc:`BytesWarning`"
msgstr ":exc:`BytesWarning`"

#: ../../c-api/exceptions.rst:1173
msgid ":exc:`DeprecationWarning`"
msgstr ":exc:`DeprecationWarning`"

#: ../../c-api/exceptions.rst:1175
msgid ":exc:`EncodingWarning`"
msgstr ":exc:`EncodingWarning`"

#: ../../c-api/exceptions.rst:1177
msgid ":exc:`FutureWarning`"
msgstr ":exc:`FutureWarning`"

#: ../../c-api/exceptions.rst:1179
msgid ":exc:`ImportWarning`"
msgstr ":exc:`ImportWarning`"

#: ../../c-api/exceptions.rst:1181
msgid ":exc:`PendingDeprecationWarning`"
msgstr ":exc:`PendingDeprecationWarning`"

#: ../../c-api/exceptions.rst:1183
msgid ":exc:`ResourceWarning`"
msgstr ":exc:`ResourceWarning`"

#: ../../c-api/exceptions.rst:1185
msgid ":exc:`RuntimeWarning`"
msgstr ":exc:`RuntimeWarning`"

#: ../../c-api/exceptions.rst:1187
msgid ":exc:`SyntaxWarning`"
msgstr ":exc:`SyntaxWarning`"

#: ../../c-api/exceptions.rst:1189
msgid ":exc:`UnicodeWarning`"
msgstr ":exc:`UnicodeWarning`"

#: ../../c-api/exceptions.rst:1191
msgid ":exc:`UserWarning`"
msgstr ":exc:`UserWarning`"

#: ../../c-api/exceptions.rst:1193
msgid ":c:data:`PyExc_ResourceWarning`."
msgstr ":c:data:`PyExc_ResourceWarning`."

#: ../../c-api/exceptions.rst:1196
msgid ":c:data:`PyExc_EncodingWarning`."
msgstr ":c:data:`PyExc_EncodingWarning`."

#: ../../c-api/exceptions.rst:183
msgid "strerror (C function)"
msgstr "strerror (C функция)"

#: ../../c-api/exceptions.rst:637 ../../c-api/exceptions.rst:668
#: ../../c-api/exceptions.rst:683
msgid "module"
msgstr "moduł"

#: ../../c-api/exceptions.rst:637 ../../c-api/exceptions.rst:668
#: ../../c-api/exceptions.rst:683
msgid "signal"
msgstr "signal"

#: ../../c-api/exceptions.rst:637 ../../c-api/exceptions.rst:668
msgid "SIGINT (C macro)"
msgstr "SIGINT (C макрос)"

#: ../../c-api/exceptions.rst:637 ../../c-api/exceptions.rst:668
#: ../../c-api/exceptions.rst:683
msgid "KeyboardInterrupt (built-in exception)"
msgstr "KeyboardInterrupt (встроенное исключение)"
