# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 16:35+0000\n"
"PO-Revision-Date: 2025-09-22 17:54+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/"
"teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/bisect.rst:2
msgid ":mod:`bisect` --- Array bisection algorithm"
msgstr ":mod:`bisect` --- 数组二分查找算法"

#: ../../library/bisect.rst:10
msgid "**Source code:** :source:`Lib/bisect.py`"
msgstr "**源代码：** :source:`Lib/bisect.py`"

#: ../../library/bisect.rst:14
msgid ""
"This module provides support for maintaining a list in sorted order without "
"having to sort the list after each insertion.  For long lists of items with "
"expensive comparison operations, this can be an improvement over the more "
"common approach.  The module is called :mod:`bisect` because it uses a basic "
"bisection algorithm to do its work.  The source code may be most useful as a "
"working example of the algorithm (the boundary conditions are already "
"right!)."
msgstr ""
"这个模块对有序列表提供了支持，使得他们可以在插入新数据仍然保持有序。对于长列"
"表，如果其包含元素的比较操作十分昂贵的话，这可以是对更常见方法的改进。这个模"
"块叫做 :mod:`bisect` 因为其使用了基本的二分（bisection）算法。源代码也可以作"
"为很棒的算法示例（边界判断也做好啦！）"

#: ../../library/bisect.rst:21
msgid "The following functions are provided:"
msgstr "定义了以下函数："

#: ../../library/bisect.rst:26
msgid ""
"Locate the insertion point for *x* in *a* to maintain sorted order. The "
"parameters *lo* and *hi* may be used to specify a subset of the list which "
"should be considered; by default the entire list is used.  If *x* is already "
"present in *a*, the insertion point will be before (to the left of) any "
"existing entries.  The return value is suitable for use as the first "
"parameter to ``list.insert()`` assuming that *a* is already sorted."
msgstr ""
"在 *a* 中找到 *x* 合适的插入点以维持有序。参数 *lo* 和 *hi* 可以被用于确定需"
"要考虑的子集；默认情况下整个列表都会被使用。如果 *x* 已经在 *a* 里存在，那么"
"插入点会在已存在元素之前（也就是左边）。如果 *a* 是列表（list）的话，返回值是"
"可以被放在 ``list.insert()`` 的第一个参数的。"

#: ../../library/bisect.rst:33
msgid ""
"The returned insertion point *i* partitions the array *a* into two halves so "
"that ``all(val < x for val in a[lo:i])`` for the left side and ``all(val >= "
"x for val in a[i:hi])`` for the right side."
msgstr ""
"返回的插入点 *i* 可以将数组 *a* 分成两部分。左侧是 ``all(val < x for val in "
"a[lo:i])`` ，右侧是 ``all(val >= x for val in a[i:hi])`` 。"

#: ../../library/bisect.rst:40
msgid ""
"Similar to :func:`bisect_left`, but returns an insertion point which comes "
"after (to the right of) any existing entries of *x* in *a*."
msgstr ""
"类似于 :func:`bisect_left`，但是返回的插入点是 *a* 中已存在元素 *x* 的右侧。"

#: ../../library/bisect.rst:43
msgid ""
"The returned insertion point *i* partitions the array *a* into two halves so "
"that ``all(val <= x for val in a[lo:i])`` for the left side and ``all(val > "
"x for val in a[i:hi])`` for the right side."
msgstr ""
"返回的插入点 *i* 可以将数组 *a* 分成两部分。左侧是 ``all(val <= x for val in "
"a[lo:i])``，右侧是 ``all(val > x for val in a[i:hi])`` for the right side。"

#: ../../library/bisect.rst:49
msgid ""
"Insert *x* in *a* in sorted order.  This is equivalent to ``a.insert(bisect."
"bisect_left(a, x, lo, hi), x)`` assuming that *a* is already sorted.  Keep "
"in mind that the O(log n) search is dominated by the slow O(n) insertion "
"step."
msgstr ""
"将 *x* 插入到一个有序序列 *a* 里，并维持其有序。如果 *a* 有序的话，这相当于 "
"``a.insert(bisect.bisect_left(a, x, lo, hi), x)``。要注意搜索是 O(log n) 的，"
"插入却是 O(n) 的。"

#: ../../library/bisect.rst:57
msgid ""
"Similar to :func:`insort_left`, but inserting *x* in *a* after any existing "
"entries of *x*."
msgstr ""
"类似于 :func:`insort_left`，但是把 *x* 插入到 *a* 中已存在元素 *x* 的右侧。"

#: ../../library/bisect.rst:62
msgid ""
"`SortedCollection recipe <https://code.activestate.com/recipes/577197-"
"sortedcollection/>`_ that uses bisect to build a full-featured collection "
"class with straight-forward search methods and support for a key-function.  "
"The keys are precomputed to save unnecessary calls to the key function "
"during searches."
msgstr ""
"`SortedCollection recipe <https://code.activestate.com/recipes/577197-"
"sortedcollection/>`_ 使用 bisect 构造了一个功能完整的集合类，提供了直接的搜索"
"方法和对用于搜索的 key 方法的支持。所有用于搜索的键都是预先计算的，以避免在搜"
"索时对 key 方法的不必要调用。"

#: ../../library/bisect.rst:70
msgid "Searching Sorted Lists"
msgstr "搜索有序列表"

#: ../../library/bisect.rst:72
msgid ""
"The above :func:`bisect` functions are useful for finding insertion points "
"but can be tricky or awkward to use for common searching tasks. The "
"following five functions show how to transform them into the standard "
"lookups for sorted lists::"
msgstr ""
"上面的 :func:`bisect` 函数对于找到插入点是有用的，但在一般的搜索任务中可能会"
"有点尴尬。下面 5 个函数展示了如何将其转变成有序列表中的标准查找函数 ::"

#: ../../library/bisect.rst:114
msgid "Other Examples"
msgstr "其他示例"

#: ../../library/bisect.rst:118
msgid ""
"The :func:`bisect` function can be useful for numeric table lookups. This "
"example uses :func:`bisect` to look up a letter grade for an exam score "
"(say) based on a set of ordered numeric breakpoints: 90 and up is an 'A', 80 "
"to 89 is a 'B', and so on::"
msgstr ""
"函数 :func:`bisect` 还可以用于数字表查询。这个例子是使用 :func:`bisect` 从一"
"个给定的考试成绩集合里，通过一个有序数字表，查出其对应的字母等级：90 分及以上"
"是 'A'，80 到 89 是 'B'，以此类推 ::"

#: ../../library/bisect.rst:130
msgid ""
"Unlike the :func:`sorted` function, it does not make sense for the :func:"
"`bisect` functions to have *key* or *reversed* arguments because that would "
"lead to an inefficient design (successive calls to bisect functions would "
"not \"remember\" all of the previous key lookups)."
msgstr ""
"与 :func:`sorted` 函数不同，对于 :func:`bisect` 函数来说，*key* 或者 "
"*reversed* 参数并没有什么意义。因为这会导致设计效率低下（连续调用 bisect 函数"
"时，是不会 \"记住\" 过去查找过的键的）。"

#: ../../library/bisect.rst:135
msgid ""
"Instead, it is better to search a list of precomputed keys to find the index "
"of the record in question::"
msgstr "正相反，最好去搜索预先计算好的键列表，来查找相关记录的索引。"
