# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 16:35+0000\n"
"PO-Revision-Date: 2025-09-22 17:55+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/"
"teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/py_compile.rst:2
msgid ":mod:`py_compile` --- Compile Python source files"
msgstr ":mod:`py_compile` --- 编译 Python 源文件"

#: ../../library/py_compile.rst:10
msgid "**Source code:** :source:`Lib/py_compile.py`"
msgstr "**源代码:** :source:`Lib/py_compile.py`"

#: ../../library/py_compile.rst:16
msgid ""
"The :mod:`py_compile` module provides a function to generate a byte-code "
"file from a source file, and another function used when the module source "
"file is invoked as a script."
msgstr ""
":mod:`py_compile` 模块提供了用来从源文件生成字节码的函数和另一个用于当模块源"
"文件作为脚本被调用时的函数。"

#: ../../library/py_compile.rst:20
msgid ""
"Though not often needed, this function can be useful when installing modules "
"for shared use, especially if some of the users may not have permission to "
"write the byte-code cache files in the directory containing the source code."
msgstr ""
"虽然不太常用，但这个函数在安装共享模块时还是很有用的，特别是当一些用户可能没"
"有权限在包含源代码的目录中写字节码缓存文件时。"

#: ../../library/py_compile.rst:27
msgid ""
"Exception raised when an error occurs while attempting to compile the file."
msgstr "当编译文件过程中发生错误时，抛出的异常。"

#: ../../library/py_compile.rst:32
msgid ""
"Compile a source file to byte-code and write out the byte-code cache file. "
"The source code is loaded from the file named *file*.  The byte-code is "
"written to *cfile*, which defaults to the :pep:`3147`/:pep:`488` path, "
"ending in ``.pyc``. For example, if *file* is ``/foo/bar/baz.py`` *cfile* "
"will default to ``/foo/bar/__pycache__/baz.cpython-32.pyc`` for Python 3.2.  "
"If *dfile* is specified, it is used as the name of the source file in error "
"messages instead of *file*.  If *doraise* is true, a :exc:`PyCompileError` "
"is raised when an error is encountered while compiling *file*. If *doraise* "
"is false (the default), an error string is written to ``sys.stderr``, but no "
"exception is raised.  This function returns the path to byte-compiled file, "
"i.e. whatever *cfile* value was used."
msgstr ""
"将源文件编译成字节码并写出字节码缓存文件。 源代码从名为 *file* 的文件中加"
"载。 字节码会写入到 *cfile*，默认为 :pep:`3147`/:pep:`488` 路径，以 ``.pyc`` "
"结尾。 例如，如果 *file* 是 ``/foo/bar/baz.py`` 则对于 Python 3.2 *cfile* 将"
"默认为 ``/foo/bar/__pycache__/baz.cpython-32.pyc``。 如果指定了 *dfile*，则在"
"错误信息中它将代替 *file* 作为源文件的名称。 如果 *doraise* 为真值，则当编译 "
"*file* 遇到错误时将会引发 :exc:`PyCompileError`。 如果 *doraise* 为假值（默"
"认），则将错误信息写入到 ``sys.stderr``，但不会引发异常。 此函数返回编译后字"
"节码文件的路径，即 *cfile* 所使用的值。"

#: ../../library/py_compile.rst:45
msgid ""
"The *doraise* and *quiet* arguments determine how errors are handled while "
"compiling file. If *quiet* is 0 or 1, and *doraise* is false, the default "
"behaviour is enabled: an error string is written to ``sys.stderr``, and the "
"function returns ``None`` instead of a path. If *doraise* is true, a :exc:"
"`PyCompileError` is raised instead. However if *quiet* is 2, no message is "
"written, and *doraise* has no effect."
msgstr ""
"*doraise* 和 *quiet* 参数确定在编译文件时如何处理错误。 如果 *quiet* 为 0 或 "
"1，并且 *doraise* 为假值，则会启用默认行为：写入错误信息到 ``sys.stderr``，并"
"且函数将返回 ``None`` 而非一个路径。 如果 *doraise* 为真值，则将改为引发 :"
"exc:`PyCompileError`。 但是如果 *quiet* 为 2，则不会写入消息，并且 *doraise* "
"也不会有效果。"

#: ../../library/py_compile.rst:52
msgid ""
"If the path that *cfile* becomes (either explicitly specified or computed) "
"is a symlink or non-regular file, :exc:`FileExistsError` will be raised. "
"This is to act as a warning that import will turn those paths into regular "
"files if it is allowed to write byte-compiled files to those paths. This is "
"a side-effect of import using file renaming to place the final byte-compiled "
"file into place to prevent concurrent file writing issues."
msgstr ""
"如果 *cfile* 所表示（显式指定或计算得出）的路径为符号链接或非常规文件，则将引"
"发 :exc:`FileExistsError`。 此行为是用来警告如果允许写入编译后字节码文件到这"
"些路径则导入操作将会把它们转为常规文件。 这是使用文件重命名来将最终编译后字节"
"码文件放置到位以防止并发文件写入问题的导入操作的附带效果。"

#: ../../library/py_compile.rst:59
msgid ""
"*optimize* controls the optimization level and is passed to the built-in :"
"func:`compile` function.  The default of ``-1`` selects the optimization "
"level of the current interpreter."
msgstr ""
"*optimize* 控制优化级别并会被传给内置的 :func:`compile` 函数。 默认值 ``-1`` "
"表示选择当前解释器的优化级别。"

#: ../../library/py_compile.rst:63
msgid ""
"*invalidation_mode* should be a member of the :class:`PycInvalidationMode` "
"enum and controls how the generated bytecode cache is invalidated at "
"runtime.  The default is :attr:`PycInvalidationMode.CHECKED_HASH` if the :"
"envvar:`SOURCE_DATE_EPOCH` environment variable is set, otherwise the "
"default is :attr:`PycInvalidationMode.TIMESTAMP`."
msgstr ""
"*invalidation_mode* 应当是 :class:`PycInvalidationMode` 枚举的成员，它控制在"
"运行时如何让已生成的字节码缓存失效。 如果设置了 :envvar:`SOURCE_DATE_EPOCH` "
"环境变量则默认值为 :attr:`PycInvalidationMode.CHECKED_HASH`，否则默认值为 :"
"attr:`PycInvalidationMode.TIMESTAMP`。"

#: ../../library/py_compile.rst:69
msgid ""
"Changed default value of *cfile* to be :PEP:`3147`-compliant.  Previous "
"default was *file* + ``'c'`` (``'o'`` if optimization was enabled). Also "
"added the *optimize* parameter."
msgstr ""
"将 *cfile* 的默认值改成与 :PEP:`3147` 兼容。 之前的默认值是 *file* + ``'c'`` "
"(如果启用优化则为 ``'o'``)。 同时也添加了 *optimize* 形参。"

#: ../../library/py_compile.rst:74
msgid ""
"Changed code to use :mod:`importlib` for the byte-code cache file writing. "
"This means file creation/writing semantics now match what :mod:`importlib` "
"does, e.g. permissions, write-and-move semantics, etc. Also added the caveat "
"that :exc:`FileExistsError` is raised if *cfile* is a symlink or non-regular "
"file."
msgstr ""
"将代码更改为使用 :mod:`importlib` 执行字节码缓存文件写入。 这意味着文件创建/"
"写入的语义现在与 :mod:`importlib` 所做的相匹配，例如权限、写入和移动语义等"
"等。 同时也添加了当 *cfile* 为符号链接或非常规文件时引发 :exc:"
"`FileExistsError` 的预警设置。"

#: ../../library/py_compile.rst:81
msgid ""
"The *invalidation_mode* parameter was added as specified in :pep:`552`. If "
"the :envvar:`SOURCE_DATE_EPOCH` environment variable is set, "
"*invalidation_mode* will be forced to :attr:`PycInvalidationMode."
"CHECKED_HASH`."
msgstr ""
"*invalidation_mode* 形参是根据 :pep:`552` 的描述添加的。 如果设置了 :envvar:"
"`SOURCE_DATE_EPOCH` 环境变量，*invalidation_mode* 将被强制设为 :attr:"
"`PycInvalidationMode.CHECKED_HASH`。"

#: ../../library/py_compile.rst:87
msgid ""
"The :envvar:`SOURCE_DATE_EPOCH` environment variable no longer overrides the "
"value of the *invalidation_mode* argument, and determines its default value "
"instead."
msgstr ""
":envvar:`SOURCE_DATE_EPOCH` 环境变量不会再覆盖 *invalidation_mode* 参数的值，"
"而改为确定其默认值。"

#: ../../library/py_compile.rst:92
msgid "The *quiet* parameter was added."
msgstr "增加了 *quiet* 形参。"

#: ../../library/py_compile.rst:98
msgid ""
"A enumeration of possible methods the interpreter can use to determine "
"whether a bytecode file is up to date with a source file. The ``.pyc`` file "
"indicates the desired invalidation mode in its header. See :ref:`pyc-"
"invalidation` for more information on how Python invalidates ``.pyc`` files "
"at runtime."
msgstr ""
"一个由可用方法组成的枚举，解释器可以用来确定字节码文件是否与源文件保持一致。 "
"``.pyc`` 文件在其标头中指明了所需的失效模式。 请参阅 :ref:`pyc-invalidation` "
"了解有关 Python 在运行时如何让 ``.pyc`` 文件失效的更多信息。"

#: ../../library/py_compile.rst:108
msgid ""
"The ``.pyc`` file includes the timestamp and size of the source file, which "
"Python will compare against the metadata of the source file at runtime to "
"determine if the ``.pyc`` file needs to be regenerated."
msgstr ""
"``.pyc`` 文件包括时间戳和源文件的大小，Python 将在运行时将其与源文件的元数据"
"进行比较以确定 ``.pyc`` 文件是否需要重新生成。"

#: ../../library/py_compile.rst:114
msgid ""
"The ``.pyc`` file includes a hash of the source file content, which Python "
"will compare against the source at runtime to determine if the ``.pyc`` file "
"needs to be regenerated."
msgstr ""
"``.pyc`` 文件包括源文件内容的哈希值，Python 将在运行时将其与源文件内容进行比"
"较以确定 ``.pyc`` 文件是否需要重新生成。"

#: ../../library/py_compile.rst:120
msgid ""
"Like :attr:`CHECKED_HASH`, the ``.pyc`` file includes a hash of the source "
"file content. However, Python will at runtime assume the ``.pyc`` file is up "
"to date and not validate the ``.pyc`` against the source file at all."
msgstr ""
"类似于 :attr:`CHECKED_HASH`，``.pyc`` 文件包括源文件内容的哈希值。 但是，"
"Python 将在运行时假定 ``.pyc`` 文件是最新的而完全不会将 ``.pyc`` 与源文件进行"
"验证。"

#: ../../library/py_compile.rst:124
msgid ""
"This option is useful when the ``.pycs`` are kept up to date by some system "
"external to Python like a build system."
msgstr ""
"此选项适用于 ``.pycs`` 由 Python 以外的某个系统例如构建系统来确保最新的情况。"

#: ../../library/py_compile.rst:130
msgid ""
"Compile several source files.  The files named in *args* (or on the command "
"line, if *args* is ``None``) are compiled and the resulting byte-code is "
"cached in the normal manner.  This function does not search a directory "
"structure to locate source files; it only compiles files named explicitly. "
"If ``'-'`` is the only parameter in args, the list of files is taken from "
"standard input."
msgstr ""
"编译多个源文件。 在 *args* 中（或者当 *args* 为 ``None`` 时则是在命令行中）指"
"定的文件会被编译并将结果字节码以正常方式来缓存。 此函数不会搜索目录结构来定位"
"源文件；它只编译显式指定的文件。 如果 ``'-'`` 是 args 中唯一的值，则会从标准"
"输入获取文件列表。"

#: ../../library/py_compile.rst:137
msgid "Added support for ``'-'``."
msgstr "添加了对 ``'-'`` 的支持。"

#: ../../library/py_compile.rst:140
msgid ""
"When this module is run as a script, the :func:`main` is used to compile all "
"the files named on the command line.  The exit status is nonzero if one of "
"the files could not be compiled."
msgstr ""
"当此模块作为脚本运行时，会使用 :func:`main` 来编译命令行中指定的所有文件。 如"
"果某个文件无法被编译则退出状态将为非零值。"

#: ../../library/py_compile.rst:147
msgid "Module :mod:`compileall`"
msgstr "模块 :mod:`compileall`"

#: ../../library/py_compile.rst:148
msgid "Utilities to compile all Python source files in a directory tree."
msgstr "编译一个目录树中所有 Python 源文件的工具。"
