# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-13 17:35+0000\n"
"PO-Revision-Date: 2025-07-18 19:18+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/"
"teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../reference/compound_stmts.rst:5
msgid "Compound statements"
msgstr "复合语句"

#: ../../reference/compound_stmts.rst:9
msgid ""
"Compound statements contain (groups of) other statements; they affect or "
"control the execution of those other statements in some way.  In general, "
"compound statements span multiple lines, although in simple incarnations a "
"whole compound statement may be contained in one line."
msgstr ""
"复合语句是包含其它语句（语句组）的语句；它们会以某种方式影响或控制所包含其它"
"语句的执行。 通常，复合语句会跨越多行，虽然在某些简单形式下整个复合语句也可能"
"包含于一行之内。"

#: ../../reference/compound_stmts.rst:14
msgid ""
"The :keyword:`if`, :keyword:`while` and :keyword:`for` statements implement "
"traditional control flow constructs.  :keyword:`try` specifies exception "
"handlers and/or cleanup code for a group of statements, while the :keyword:"
"`with` statement allows the execution of initialization and finalization "
"code around a block of code.  Function and class definitions are also "
"syntactically compound statements."
msgstr ""
":keyword:`if`, :keyword:`while` 和 :keyword:`for` 语句用来实现传统的控制流程"
"构造。 :keyword:`try` 语句为一组语句指定异常处理和/和清理代码，而 :keyword:"
"`with` 语句允许在一个代码块周围执行初始化和终结化代码。 函数和类定义在语法上"
"也属于复合语句。"

#: ../../reference/compound_stmts.rst:26
msgid ""
"A compound statement consists of one or more 'clauses.'  A clause consists "
"of a header and a 'suite.'  The clause headers of a particular compound "
"statement are all at the same indentation level. Each clause header begins "
"with a uniquely identifying keyword and ends with a colon.  A suite is a "
"group of statements controlled by a clause.  A suite can be one or more "
"semicolon-separated simple statements on the same line as the header, "
"following the header's colon, or it can be one or more indented statements "
"on subsequent lines.  Only the latter form of a suite can contain nested "
"compound statements; the following is illegal, mostly because it wouldn't be "
"clear to which :keyword:`if` clause a following :keyword:`else` clause would "
"belong::"
msgstr ""
"一条复合语句由一个或多个‘子句’组成。 一个子句则包含一个句头和一个‘句体’。 特"
"定复合语句的子句头都处于相同的缩进层级。 每个子句头以一个作为唯一标识的关键字"
"开始并以一个冒号结束。 子句体是由一个子句控制的一组语句。 子句体可以是在子句"
"头的冒号之后与其同处一行的一条或由分号分隔的多条简单语句，或者也可以是在其之"
"后缩进的一行或多行语句。 只有后一种形式的子句体才能包含嵌套的复合语句；以下形"
"式是不合法的，这主要是因为无法分清某个后续的 :keyword:`else` 子句应该属于哪"
"个 :keyword:`if` 子句::"

#: ../../reference/compound_stmts.rst:39
msgid ""
"Also note that the semicolon binds tighter than the colon in this context, "
"so that in the following example, either all or none of the :func:`print` "
"calls are executed::"
msgstr ""
"还要注意的是在这种情形下分号的绑定比冒号更紧密，因此在以下示例中，所有 :func:"
"`print` 调用或者都不执行，或者都执行::"

#: ../../reference/compound_stmts.rst:45
msgid "Summarizing:"
msgstr "总结:"

#: ../../reference/compound_stmts.rst:68
msgid ""
"Note that statements always end in a ``NEWLINE`` possibly followed by a "
"``DEDENT``.  Also note that optional continuation clauses always begin with "
"a keyword that cannot start a statement, thus there are no ambiguities (the "
"'dangling :keyword:`else`' problem is solved in Python by requiring nested :"
"keyword:`if` statements to be indented)."
msgstr ""
"请注意语句总是以 ``NEWLINE`` 结束，之后可能跟随一个 ``DEDENT``。 还要注意可选"
"的后续子句总是以一个不能作为语句开头的关键字作为开头，因此不会产生歧义（‘悬空"
"的 :keyword:`else`’问题在 Python 中是通过要求嵌套的 :keyword:`if` 语句必须缩"
"进来解决的)。"

#: ../../reference/compound_stmts.rst:74
msgid ""
"The formatting of the grammar rules in the following sections places each "
"clause on a separate line for clarity."
msgstr "为了保证清晰，以下各节中语法规则采用将每个子句都放在单独行中的格式。"

#: ../../reference/compound_stmts.rst:83
msgid "The :keyword:`!if` statement"
msgstr ":keyword:`!if` 语句"

#: ../../reference/compound_stmts.rst:91
msgid "The :keyword:`if` statement is used for conditional execution:"
msgstr ":keyword:`if` 语句用于有条件的执行:"

#: ../../reference/compound_stmts.rst:98
msgid ""
"It selects exactly one of the suites by evaluating the expressions one by "
"one until one is found to be true (see section :ref:`booleans` for the "
"definition of true and false); then that suite is executed (and no other "
"part of the :keyword:`if` statement is executed or evaluated).  If all "
"expressions are false, the suite of the :keyword:`else` clause, if present, "
"is executed."
msgstr ""
"它通过对表达式逐个求值直至找到一个真值（请参阅 :ref:`booleans` 了解真值与假值"
"的定义）在子句体中选择唯一匹配的一个；然后执行该子句体（而且 :keyword:`if` 语"
"句的其他部分不会被执行或求值）。 如果所有表达式均为假值，则如果 :keyword:"
"`else` 子句体如果存在就会被执行。"

#: ../../reference/compound_stmts.rst:108
msgid "The :keyword:`!while` statement"
msgstr ":keyword:`!while` 语句"

#: ../../reference/compound_stmts.rst:116
msgid ""
"The :keyword:`while` statement is used for repeated execution as long as an "
"expression is true:"
msgstr ":keyword:`while` 语句用于在表达式保持为真的情况下重复地执行:"

#: ../../reference/compound_stmts.rst:123
msgid ""
"This repeatedly tests the expression and, if it is true, executes the first "
"suite; if the expression is false (which may be the first time it is tested) "
"the suite of the :keyword:`!else` clause, if present, is executed and the "
"loop terminates."
msgstr ""
"这将重复地检验表达式，并且如果其值为真就执行第一个子句体；如果表达式值为假"
"（这可能在第一次检验时就发生）则如果 :keyword:`!else` 子句体存在就会被执行并"
"终止循环。"

#: ../../reference/compound_stmts.rst:132
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop "
"without executing the :keyword:`!else` clause's suite.  A :keyword:"
"`continue` statement executed in the first suite skips the rest of the suite "
"and goes back to testing the expression."
msgstr ""
"第一个子句体中的 :keyword:`break` 语句在执行时将终止循环且不执行 :keyword:`!"
"else` 子句体。 第一个子句体中的 :keyword:`continue` 语句在执行时将跳过子句体"
"中的剩余部分并返回检验表达式。"

#: ../../reference/compound_stmts.rst:141
msgid "The :keyword:`!for` statement"
msgstr ":keyword:`!for` 语句"

#: ../../reference/compound_stmts.rst:152
msgid ""
"The :keyword:`for` statement is used to iterate over the elements of a "
"sequence (such as a string, tuple or list) or other iterable object:"
msgstr ""
":keyword:`for` 语句用于对序列（例如字符串、元组或列表）或其他可迭代对象中的元"
"素进行迭代:"

#: ../../reference/compound_stmts.rst:159
msgid ""
"The expression list is evaluated once; it should yield an iterable object.  "
"An iterator is created for the result of the ``expression_list``.  The suite "
"is then executed once for each item provided by the iterator, in the order "
"returned by the iterator.  Each item in turn is assigned to the target list "
"using the standard rules for assignments (see :ref:`assignment`), and then "
"the suite is executed.  When the items are exhausted (which is immediately "
"when the sequence is empty or an iterator raises a :exc:`StopIteration` "
"exception), the suite in the :keyword:`!else` clause, if present, is "
"executed, and the loop terminates."
msgstr ""
"表达式列表会被求值一次；它应该产生一个可迭代对象。 系统将为 "
"``expression_list`` 的结果创建一个迭代器，然后将为迭代器所提供的每一项执行一"
"次子句体，具体次序与迭代器的返回顺序一致。 每一项会按标准赋值规则 (参见 :ref:"
"`assignment`) 被依次赋值给目标列表，然后子句体将被执行。 当所有项被耗尽时 (这"
"会在序列为空或迭代器引发 :exc:`StopIteration` 异常时立刻发生)，:keyword:`!"
"else` 子句的子句体如果存在将会被执行，并终止循环。"

#: ../../reference/compound_stmts.rst:172
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop "
"without executing the :keyword:`!else` clause's suite.  A :keyword:"
"`continue` statement executed in the first suite skips the rest of the suite "
"and continues with the next item, or with the :keyword:`!else` clause if "
"there is no next item."
msgstr ""
"第一个子句体中的 :keyword:`break` 语句在执行时将终止循环且不执行 :keyword:`!"
"else` 子句体。 第一个子句体中的 :keyword:`continue` 语句在执行时将跳过子句体"
"中的剩余部分并转往下一项继续执行，或者在没有下一项时转往 :keyword:`!else` 子"
"句执行。"

#: ../../reference/compound_stmts.rst:178
msgid ""
"The for-loop makes assignments to the variables in the target list. This "
"overwrites all previous assignments to those variables including those made "
"in the suite of the for-loop::"
msgstr ""
"for 循环会对目标列表中的变量进行赋值。 这将覆盖之前对这些变量的所有赋值，包括"
"在 for 循环体中的赋值::"

#: ../../reference/compound_stmts.rst:192
msgid ""
"Names in the target list are not deleted when the loop is finished, but if "
"the sequence is empty, they will not have been assigned to at all by the "
"loop.  Hint: the built-in function :func:`range` returns an iterator of "
"integers suitable to emulate the effect of Pascal's ``for i := a to b do``; "
"e.g., ``list(range(3))`` returns the list ``[0, 1, 2]``."
msgstr ""
"目标列表中的名称在循环结束时不会被删除，但如果序列为空，则它们根本不会被循环"
"所赋值。 提示：内置函数 :func:`range` 会返回一个可迭代的整数序列，适用于模拟 "
"Pascal 中的 ``for i := a to b do`` 这种效果；例如 ``list(range(3))`` 会返回列"
"表 ``[0, 1, 2]``。"

#: ../../reference/compound_stmts.rst:204
msgid ""
"There is a subtlety when the sequence is being modified by the loop (this "
"can only occur for mutable sequences, e.g. lists).  An internal counter is "
"used to keep track of which item is used next, and this is incremented on "
"each iteration.  When this counter has reached the length of the sequence "
"the loop terminates.  This means that if the suite deletes the current (or a "
"previous) item from the sequence, the next item will be skipped (since it "
"gets the index of the current item which has already been treated).  "
"Likewise, if the suite inserts an item in the sequence before the current "
"item, the current item will be treated again the next time through the loop. "
"This can lead to nasty bugs that can be avoided by making a temporary copy "
"using a slice of the whole sequence, e.g., ::"
msgstr ""
"当序列在循环中被修改时会有一个微妙的问题（这只可能发生于可变序列例如列表"
"中）。 会有一个内部计数器被用来跟踪下一个要使用的项，每次迭代都会使计数器递"
"增。 当计数器值达到序列长度时循环就会终止。 这意味着如果语句体从序列中删除了"
"当前（或之前）的一项，下一项就会被跳过（因为其标号将变成已被处理的当前项的标"
"号）。 类似地，如果语句体在序列当前项的前面插入一个新项，当前项会在循环的下一"
"轮中再次被处理。 这会导致麻烦的程序错误，避免此问题的办法是对整个序列使用切片"
"来创建一个临时副本，例如 ::"

#: ../../reference/compound_stmts.rst:225
msgid "The :keyword:`!try` statement"
msgstr ":keyword:`!try` 语句"

#: ../../reference/compound_stmts.rst:235
msgid ""
"The :keyword:`try` statement specifies exception handlers and/or cleanup "
"code for a group of statements:"
msgstr ":keyword:`try` 语句可为一组语句指定异常处理器和/或清理代码:"

#: ../../reference/compound_stmts.rst:248
msgid ""
"The :keyword:`except` clause(s) specify one or more exception handlers. When "
"no exception occurs in the :keyword:`try` clause, no exception handler is "
"executed. When an exception occurs in the :keyword:`!try` suite, a search "
"for an exception handler is started.  This search inspects the except "
"clauses in turn until one is found that matches the exception.  An "
"expression-less except clause, if present, must be last; it matches any "
"exception.  For an except clause with an expression, that expression is "
"evaluated, and the clause matches the exception if the resulting object is "
"\"compatible\" with the exception.  An object is compatible with an "
"exception if the object is the class or a :term:`non-virtual base class "
"<abstract base class>` of the exception object, or a tuple containing an "
"item that is the class or a non-virtual base class of the exception object."
msgstr ""
":keyword:`except` 子句指定一个或多个异常处理程序。 当 :keyword:`try` 子句中无"
"异常发生时，也不会有任何异常处理程序被执行。 当 :keyword:`!try` 子句中发生异"
"常时，将启动对异常处理程序的搜索。 此搜索会逐一检查 except 子句直至找到与该异"
"常相匹配的子句。 如果存在无表达式的 except 子句，它必须是最后一个；它将匹配任"
"何异常。 对于带有表达式的 except 子句，该表达式会被未付，如果结果对象与发生的"
"异常“兼容”，则该子句将匹配当前异常。 如果一个对象是异常对象所属的类或是其 :"
"term:`非虚基类 <abstract base class>`，或者是包含异常对象的类的非虚基类的元"
"组，则此对象与异常是兼容的。"

#: ../../reference/compound_stmts.rst:261
msgid ""
"If no except clause matches the exception, the search for an exception "
"handler continues in the surrounding code and on the invocation stack.  [#]_"
msgstr ""
"如果没有 except 子句与异常相匹配，则会在周边代码和发起调用栈上继续搜索异常处"
"理器。 [#]_"

#: ../../reference/compound_stmts.rst:264
msgid ""
"If the evaluation of an expression in the header of an except clause raises "
"an exception, the original search for a handler is canceled and a search "
"starts for the new exception in the surrounding code and on the call stack "
"(it is treated as if the entire :keyword:`try` statement raised the "
"exception)."
msgstr ""
"如果在对 except 子句头中的表达式求值时引发了异常，则原来对处理器的搜索会被取"
"消，并在周边代码和调用栈上启动对新异常的搜索（它会被视作是整个 :keyword:"
"`try` 语句所引发的异常）。"

#: ../../reference/compound_stmts.rst:271
msgid ""
"When a matching except clause is found, the exception is assigned to the "
"target specified after the :keyword:`!as` keyword in that except clause, if "
"present, and the except clause's suite is executed.  All except clauses must "
"have an executable block.  When the end of this block is reached, execution "
"continues normally after the entire try statement.  (This means that if two "
"nested handlers exist for the same exception, and the exception occurs in "
"the try clause of the inner handler, the outer handler will not handle the "
"exception.)"
msgstr ""
"当找到一个匹配的 except 子句时，该异常将被赋值给该 except 子句在 :keyword:`!"
"as` 关键字之后指定的目标，如果存在此关键字的话，并且该 except 子句体将被执"
"行。 所有 except 子句都必须有可执行的子句体。 当到达子句体的末尾时，通常会转"
"向整个 try 语句之后继续执行。 （这意味着如果对于同一异常存在有嵌套的两个处理"
"器，而异常发生于内层处理器的 try 子句中，则外层处理器将不会处理该异常。）"

#: ../../reference/compound_stmts.rst:279
msgid ""
"When an exception has been assigned using ``as target``, it is cleared at "
"the end of the except clause.  This is as if ::"
msgstr ""
"当使用 ``as`` 将目标赋值为一个异常时，它将在 except 子句结束时被清除。 这就相"
"当于 ::"

#: ../../reference/compound_stmts.rst:285
msgid "was translated to ::"
msgstr "被转写为 ::"

#: ../../reference/compound_stmts.rst:293
msgid ""
"This means the exception must be assigned to a different name to be able to "
"refer to it after the except clause.  Exceptions are cleared because with "
"the traceback attached to them, they form a reference cycle with the stack "
"frame, keeping all locals in that frame alive until the next garbage "
"collection occurs."
msgstr ""
"这意味着异常必须赋值给一个不同的名称才能在 except 子句之后引用它。 异常会被清"
"除是因为在附加了回溯信息的情况下，它们会形成堆栈帧的循环引用，使得所有局部变"
"量保持存活直到发生下一次垃圾回收。"

#: ../../reference/compound_stmts.rst:302
msgid ""
"Before an except clause's suite is executed, details about the exception are "
"stored in the :mod:`sys` module and can be accessed via :func:`sys."
"exc_info`. :func:`sys.exc_info` returns a 3-tuple consisting of the "
"exception class, the exception instance and a traceback object (see section :"
"ref:`types`) identifying the point in the program where the exception "
"occurred.  :func:`sys.exc_info` values are restored to their previous values "
"(before the call) when returning from a function that handled an exception."
msgstr ""
"在一个 except 子句体被执行之前，有关异常的详细信息存放在 :mod:`sys` 模块中，"
"可通过 :func:`sys.exc_info` 来访问。 :func:`sys.exc_info` 返回一个 3 元组，由"
"异常类、异常实例和回溯对象组成（参见 :ref:`types` 一节），用于在程序中标识异"
"常发生点。 当从处理异常的函数返回时 :func:`sys.exc_info` 的值会恢复为（调用前"
"的）原值。"

#: ../../reference/compound_stmts.rst:316
msgid ""
"The optional :keyword:`!else` clause is executed if the control flow leaves "
"the :keyword:`try` suite, no exception was raised, and no :keyword:"
"`return`, :keyword:`continue`, or :keyword:`break` statement was executed.  "
"Exceptions in the :keyword:`!else` clause are not handled by the preceding :"
"keyword:`except` clauses."
msgstr ""
"如果控制流离开 :keyword:`try` 子句体时没有引发异常，并且没有执行 :keyword:"
"`return`, :keyword:`continue` 或 :keyword:`break` 语句，可选的 :keyword:`!"
"else` 子句将被执行。  :keyword:`!else` 语句中的异常不会由之前的 :keyword:"
"`except` 子句处理。"

#: ../../reference/compound_stmts.rst:324
msgid ""
"If :keyword:`finally` is present, it specifies a 'cleanup' handler.  The :"
"keyword:`try` clause is executed, including any :keyword:`except` and :"
"keyword:`!else` clauses.  If an exception occurs in any of the clauses and "
"is not handled, the exception is temporarily saved. The :keyword:`!finally` "
"clause is executed.  If there is a saved exception it is re-raised at the "
"end of the :keyword:`!finally` clause.  If the :keyword:`!finally` clause "
"raises another exception, the saved exception is set as the context of the "
"new exception. If the :keyword:`!finally` clause executes a :keyword:"
"`return`, :keyword:`break` or :keyword:`continue` statement, the saved "
"exception is discarded::"
msgstr ""
"如果存在 :keyword:`finally`，它将指定一个‘清理’处理程序。 :keyword:`try` 子句"
"会被执行，包括任何 :keyword:`except` 和 :keyword:`!else` 子句。 如果在这些子"
"句中发生任何未处理的异常，该异常会被临时保存。 :keyword:`!finally` 子句将被执"
"行。 如果存在被保存的异常，它会在 :keyword:`!finally` 子句的末尾被重新引发。 "
"如果 :keyword:`!finally` 子句引发了另一个异常，被保存的异常会被设为新异常的上"
"下文。 如果 :keyword:`!finally` 子句执行了 :keyword:`return`, :keyword:"
"`break` 或 :keyword:`continue` 语句，则被保存的异常会被丢弃::"

#: ../../reference/compound_stmts.rst:343
msgid ""
"The exception information is not available to the program during execution "
"of the :keyword:`finally` clause."
msgstr "在 :keyword:`finally` 子句执行期间，程序不能获取异常信息。"

#: ../../reference/compound_stmts.rst:351
msgid ""
"When a :keyword:`return`, :keyword:`break` or :keyword:`continue` statement "
"is executed in the :keyword:`try` suite of a :keyword:`!try`...\\ :keyword:`!"
"finally` statement, the :keyword:`finally` clause is also executed 'on the "
"way out.'"
msgstr ""
"当 :keyword:`return`, :keyword:`break` 或 :keyword:`continue` 语句在一个 :"
"keyword:`!try`...\\ :keyword:`!finally` 语句的 :keyword:`try` 子语句体中被执"
"行时，:keyword:`finally` 子语句也会‘在离开时’被执行。"

#: ../../reference/compound_stmts.rst:355
msgid ""
"The return value of a function is determined by the last :keyword:`return` "
"statement executed.  Since the :keyword:`finally` clause always executes, a :"
"keyword:`!return` statement executed in the :keyword:`!finally` clause will "
"always be the last one executed::"
msgstr ""
"函数的返回值是由最后被执行的 :keyword:`return` 语句所决定的。 由于 :keyword:"
"`finally` 子句总是被执行，因此在 :keyword:`!finally` 子句中被执行的 :keyword:"
"`!return` 语句总是最后被执行的::"

#: ../../reference/compound_stmts.rst:369
msgid ""
"Additional information on exceptions can be found in section :ref:"
"`exceptions`, and information on using the :keyword:`raise` statement to "
"generate exceptions may be found in section :ref:`raise`."
msgstr ""
"有关异常的更多信息可以在 :ref:`exceptions` 一节找到，有关使用 :keyword:"
"`raise` 语句生成异常的信息可以在 :ref:`raise` 一节找到。"

#: ../../reference/compound_stmts.rst:373
msgid ""
"Prior to Python 3.8, a :keyword:`continue` statement was illegal in the :"
"keyword:`finally` clause due to a problem with the implementation."
msgstr ""
"在 Python 3.8 之前，:keyword:`continue` 语句不允许在 :keyword:`finally` 子句"
"中使用，这是因为具体实现存在一个问题。"

#: ../../reference/compound_stmts.rst:382
msgid "The :keyword:`!with` statement"
msgstr ":keyword:`!with` 语句"

#: ../../reference/compound_stmts.rst:391
msgid ""
"The :keyword:`with` statement is used to wrap the execution of a block with "
"methods defined by a context manager (see section :ref:`context-managers`). "
"This allows common :keyword:`try`...\\ :keyword:`except`...\\ :keyword:"
"`finally` usage patterns to be encapsulated for convenient reuse."
msgstr ""
":keyword:`with` 语句用于包装带有使用上下文管理器 (参见 :ref:`context-"
"managers` 一节) 定义的方法的代码块的执行。 这允许对普通的 :keyword:`try`..."
"\\ :keyword:`except`...\\ :keyword:`finally` 使用模式进行封装以方便地重用。"

#: ../../reference/compound_stmts.rst:400
msgid ""
"The execution of the :keyword:`with` statement with one \"item\" proceeds as "
"follows:"
msgstr "带有一个“项目”的 :keyword:`with` 语句的执行过程如下:"

#: ../../reference/compound_stmts.rst:402
msgid ""
"The context expression (the expression given in the :token:`with_item`) is "
"evaluated to obtain a context manager."
msgstr ""
"对上下文表达式 (在 :token:`with_item` 中给出的表达式) 求值以获得一个上下文管"
"理器。"

#: ../../reference/compound_stmts.rst:405
msgid "The context manager's :meth:`__enter__` is loaded for later use."
msgstr "载入上下文管理器的 :meth:`__enter__` 以便后续使用。"

#: ../../reference/compound_stmts.rst:407
msgid "The context manager's :meth:`__exit__` is loaded for later use."
msgstr "载入上下文管理器的 :meth:`__exit__` 以便后续使用。"

#: ../../reference/compound_stmts.rst:409
msgid "The context manager's :meth:`__enter__` method is invoked."
msgstr "发起调用上下文管理器的 :meth:`__enter__` 方法。"

#: ../../reference/compound_stmts.rst:411
msgid ""
"If a target was included in the :keyword:`with` statement, the return value "
"from :meth:`__enter__` is assigned to it."
msgstr ""
"如果 :keyword:`with` 语句中包含一个目标，来自 :meth:`__enter__` 的返回值将被"
"赋值给它。"

#: ../../reference/compound_stmts.rst:416
msgid ""
"The :keyword:`with` statement guarantees that if the :meth:`__enter__` "
"method returns without an error, then :meth:`__exit__` will always be "
"called. Thus, if an error occurs during the assignment to the target list, "
"it will be treated the same as an error occurring within the suite would be. "
"See step 6 below."
msgstr ""
":keyword:`with` 语句会保证如果 :meth:`__enter__` 方法返回时未发生错误，则 :"
"meth:`__exit__` 将总是被调用。 因此，如果在对目标列表赋值期间发生错误，则会将"
"其视为在语句体内部发生的错误。 参见下面的第 6 步。"

#: ../../reference/compound_stmts.rst:422
msgid "The suite is executed."
msgstr "执行语句体。"

#: ../../reference/compound_stmts.rst:424
msgid ""
"The context manager's :meth:`__exit__` method is invoked.  If an exception "
"caused the suite to be exited, its type, value, and traceback are passed as "
"arguments to :meth:`__exit__`. Otherwise, three :const:`None` arguments are "
"supplied."
msgstr ""
"发起调用上下文管理器的 :meth:`__exit__` 方法。 如果语句体的退出是由异常导致"
"的，则其类型、值和回溯信息将被作为参数传递给 :meth:`__exit__`。 否则的话，将"
"提供三个 :const:`None` 参数。"

#: ../../reference/compound_stmts.rst:429
msgid ""
"If the suite was exited due to an exception, and the return value from the :"
"meth:`__exit__` method was false, the exception is reraised.  If the return "
"value was true, the exception is suppressed, and execution continues with "
"the statement following the :keyword:`with` statement."
msgstr ""
"如果语句体的退出是由异常导致的，并且来自 :meth:`__exit__` 方法的返回值为假，"
"则该异常会被重新引发。 如果返回值为真，则该异常会被抑制，并会继续执行 :"
"keyword:`with` 语句之后的语句。"

#: ../../reference/compound_stmts.rst:434
msgid ""
"If the suite was exited for any reason other than an exception, the return "
"value from :meth:`__exit__` is ignored, and execution proceeds at the normal "
"location for the kind of exit that was taken."
msgstr ""
"如果语句体由于异常以外的任何原因退出，则来自 :meth:`__exit__` 的返回值会被忽"
"略，并会在该类退出正常的发生位置继续执行。"

#: ../../reference/compound_stmts.rst:438
#: ../../reference/compound_stmts.rst:815
#: ../../reference/compound_stmts.rst:856
msgid "The following code::"
msgstr "以下代码::"

#: ../../reference/compound_stmts.rst:443
#: ../../reference/compound_stmts.rst:468
#: ../../reference/compound_stmts.rst:861
msgid "is semantically equivalent to::"
msgstr "在语义上等价于::"

#: ../../reference/compound_stmts.rst:462
msgid ""
"With more than one item, the context managers are processed as if multiple :"
"keyword:`with` statements were nested::"
msgstr ""
"如果有多个项目，则会视作存在多个 :keyword:`with` 语句嵌套来处理多个上下文管理"
"器::"

#: ../../reference/compound_stmts.rst:474
msgid "Support for multiple context expressions."
msgstr "支持多个上下文表达式。"

#: ../../reference/compound_stmts.rst:480
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - \"with\" 语句"

#: ../../reference/compound_stmts.rst:480
msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr "Python :keyword:`with` 语句的规范描述、背景和示例。"

#: ../../reference/compound_stmts.rst:490
msgid "Function definitions"
msgstr "函数定义"

#: ../../reference/compound_stmts.rst:505
msgid ""
"A function definition defines a user-defined function object (see section :"
"ref:`types`):"
msgstr "函数定义就是对用户自定义函数的定义（参见 :ref:`types` 一节）:"

#: ../../reference/compound_stmts.rst:524
msgid ""
"A function definition is an executable statement.  Its execution binds the "
"function name in the current local namespace to a function object (a wrapper "
"around the executable code for the function).  This function object contains "
"a reference to the current global namespace as the global namespace to be "
"used when the function is called."
msgstr ""
"函数定义是一条可执行语句。 它执行时会在当前局部命名空间中将函数名称绑定到一个"
"函数对象（函数可执行代码的包装器）。 这个函数对象包含对当前全局命名空间的引"
"用，作为函数被调用时所使用的全局命名空间。"

#: ../../reference/compound_stmts.rst:530
msgid ""
"The function definition does not execute the function body; this gets "
"executed only when the function is called. [#]_"
msgstr "函数定义并不会执行函数体；只有当函数被调用时才会执行此操作。 [#]_"

#: ../../reference/compound_stmts.rst:536
msgid ""
"A function definition may be wrapped by one or more :term:`decorator` "
"expressions. Decorator expressions are evaluated when the function is "
"defined, in the scope that contains the function definition.  The result "
"must be a callable, which is invoked with the function object as the only "
"argument. The returned value is bound to the function name instead of the "
"function object.  Multiple decorators are applied in nested fashion. For "
"example, the following code ::"
msgstr ""
"一个函数定义可以被一个或多个 :term:`decorator` 表达式所包装。 当函数被定义时"
"将在包含该函数定义的作用域中对装饰器表达式求值。 求值结果必须是一个可调用对"
"象，它会以该函数对象作为唯一参数被唤起。 其返回值将被绑定到函数名称而非函数对"
"象。 多个装饰器会以嵌套方式被应用。 例如以下代码 ::"

#: ../../reference/compound_stmts.rst:547
#: ../../reference/compound_stmts.rst:724
msgid "is roughly equivalent to ::"
msgstr "大致等价于 ::"

#: ../../reference/compound_stmts.rst:552
msgid ""
"except that the original function is not temporarily bound to the name "
"``func``."
msgstr "不同之处在于原始函数并不会被临时绑定到名称 ``func``。"

#: ../../reference/compound_stmts.rst:554
msgid ""
"Functions may be decorated with any valid :token:`assignment_expression`. "
"Previously, the grammar was much more restrictive; see :pep:`614` for "
"details."
msgstr ""
"函数可使用任何有效的 :token:`assignment_expression` 来装饰。 在之前版本中，此"
"语法则更为受限，详情参见 :pep:`614`。"

#: ../../reference/compound_stmts.rst:564
msgid ""
"When one or more :term:`parameters <parameter>` have the form *parameter* "
"``=`` *expression*, the function is said to have \"default parameter values."
"\"  For a parameter with a default value, the corresponding :term:`argument` "
"may be omitted from a call, in which case the parameter's default value is "
"substituted.  If a parameter has a default value, all following parameters "
"up until the \"``*``\" must also have a default value --- this is a "
"syntactic restriction that is not expressed by the grammar."
msgstr ""
"当一个或多个 :term:`形参 <parameter>` 具有 *形参* ``=`` *表达式* 这样的形式"
"时，该函数就被称为具有“默认形参值”。 对于一个具有默认值的形参，其对应的 :"
"term:`argument` 可以在调用中被省略，在此情况下会用形参的默认值来替代。 如果一"
"个形参具有默认值，后续所有在 \"``*``\" 之前的形参也必须具有默认值 --- 这个句"
"法限制并未在语法中明确表达。"

#: ../../reference/compound_stmts.rst:572
msgid ""
"**Default parameter values are evaluated from left to right when the "
"function definition is executed.** This means that the expression is "
"evaluated once, when the function is defined, and that the same \"pre-"
"computed\" value is used for each call.  This is especially important to "
"understand when a default parameter is a mutable object, such as a list or a "
"dictionary: if the function modifies the object (e.g. by appending an item "
"to a list), the default value is in effect modified.  This is generally not "
"what was intended.  A way around this is to use ``None`` as the default, and "
"explicitly test for it in the body of the function, e.g.::"
msgstr ""
"**默认形参值会在执行函数定义时按从左至右的顺序被求值。** 这意味着当函数被定义"
"时将对表达式求值一次，相同的“预计算”值将在每次调用时被使用。 这一点在默认形参"
"为可变对象，例如列表或字典的时候尤其需要重点理解：如果函数修改了该对象（例如"
"向列表添加了一项），则实际上默认值也会被修改。 这通常不是人们所预期的。 绕过"
"此问题的一个方法是使用 ``None`` 作为默认值，并在函数体中显式地对其进行测试，"
"例如::"

#: ../../reference/compound_stmts.rst:593
msgid ""
"Function call semantics are described in more detail in section :ref:"
"`calls`. A function call always assigns values to all parameters mentioned "
"in the parameter list, either from positional arguments, from keyword "
"arguments, or from default values.  If the form \"``*identifier``\" is "
"present, it is initialized to a tuple receiving any excess positional "
"parameters, defaulting to the empty tuple. If the form \"``**identifier``\" "
"is present, it is initialized to a new ordered mapping receiving any excess "
"keyword arguments, defaulting to a new empty mapping of the same type.  "
"Parameters after \"``*``\" or \"``*identifier``\" are keyword-only "
"parameters and may only be passed by keyword arguments.  Parameters before "
"\"``/``\" are positional-only parameters and may only be passed by "
"positional arguments."
msgstr ""
"函数调用的语义在 :ref:`calls` 一节中有更详细的描述。 函数调用总是会给形参列表"
"中列出的所有形参赋值，或是用位置参数，或是用关键字参数，或是用默认值。 如果存"
"在 \"``*identifier``\" 这样的形式，它会被初始化为一个元组来接收任何额外的位置"
"参数，默认为一个空元组。 如果存在 \"``**identifier``\" 这样的形式，它会被初始"
"化为一个新的有序映射来接收任何额外的关键字参数，默认为一个相同类型的空映射。 "
"在 \"``*``\" 或 \"``*identifier``\" 之后的形参都是仅限关键字形参因而只能通过"
"关键字参数传入。 在 \"``/``\" 之前的形参都是仅限位置形参因而只能通过位置参数"
"传入。"

#: ../../reference/compound_stmts.rst:605
msgid ""
"The ``/`` function parameter syntax may be used to indicate positional-only "
"parameters. See :pep:`570` for details."
msgstr ""
"可以使用 ``/`` 函数形参语法来标示仅限位置形参。 请参阅 :pep:`570` 了解详情。"

#: ../../reference/compound_stmts.rst:614
msgid ""
"Parameters may have an :term:`annotation <function annotation>` of the form "
"\"``: expression``\" following the parameter name.  Any parameter may have "
"an annotation, even those of the form ``*identifier`` or ``**identifier``.  "
"Functions may have \"return\" annotation of the form \"``-> expression``\" "
"after the parameter list.  These annotations can be any valid Python "
"expression.  The presence of annotations does not change the semantics of a "
"function.  The annotation values are available as values of a dictionary "
"keyed by the parameters' names in the :attr:`__annotations__` attribute of "
"the function object.  If the ``annotations`` import from :mod:`__future__` "
"is used, annotations are preserved as strings at runtime which enables "
"postponed evaluation.  Otherwise, they are evaluated when the function "
"definition is executed.  In this case annotations may be evaluated in a "
"different order than they appear in the source code."
msgstr ""
"形参可以带有 :term:`标注 <function annotation>`，其形式为在形参名称后加上 "
"\"``: expression``\"。 任何形参都可以带有标注，甚至 ``*identifier`` 或 "
"``**identifier`` 这样的形参也可以。 函数可以带有“返回”标注，其形式为在形参列"
"表后加上 \"``-> expression``\"。 这些标注可以是任何有效的 Python 表达式。 标"
"注的存在不会改变函数的语义。 标注值可以作为函数对象的 :attr:"
"`__annotations__` 属性中以对应形参名称为键的字典值被访问。 如果使用了 "
"``annotations`` import from :mod:`__future__` 的方式，则标注会在运行时保存为"
"字符串以启用延迟求值特性。 否则，它们会在执行函数定义时被求值。 在这种情况"
"下，标注的求值顺序可能与它们在源代码中出现的顺序不同。"

#: ../../reference/compound_stmts.rst:629
msgid ""
"It is also possible to create anonymous functions (functions not bound to a "
"name), for immediate use in expressions.  This uses lambda expressions, "
"described in section :ref:`lambda`.  Note that the lambda expression is "
"merely a shorthand for a simplified function definition; a function defined "
"in a \":keyword:`def`\" statement can be passed around or assigned to "
"another name just like a function defined by a lambda expression.  The \":"
"keyword:`!def`\" form is actually more powerful since it allows the "
"execution of multiple statements and annotations."
msgstr ""
"创建匿名函数（未绑定到一个名称的函数）以便立即在表达式中使用也是可能的。 这需"
"要使用 lambda 表达式，具体描述见 :ref:`lambda` 一节。 请注意 lambda 只是简单"
"函数定义的一种简化写法；在 \":keyword:`def`\" 语句中定义的函数也可以像用 "
"lambda 表达式定义的函数一样被传递或赋值给其他名称。 \":keyword:`!def`\" 形式"
"实际上更为强大，因为它允许执行多条语句和使用标注。"

#: ../../reference/compound_stmts.rst:637
msgid ""
"**Programmer's note:** Functions are first-class objects.  A \"``def``\" "
"statement executed inside a function definition defines a local function "
"that can be returned or passed around.  Free variables used in the nested "
"function can access the local variables of the function containing the def.  "
"See section :ref:`naming` for details."
msgstr ""
"**程序员注意事项:** 函数属于一类对象。 在一个函数内部执行的 \"``def``\" 语句"
"会定义一个局部函数并可被返回或传递。 在嵌套函数中使用的自由变量可以访问包含"
"该 def 语句的函数的局部变量。 详情参见 :ref:`naming` 一节。"

#: ../../reference/compound_stmts.rst:646
msgid ":pep:`3107` - Function Annotations"
msgstr ":pep:`3107` - 函数标注"

#: ../../reference/compound_stmts.rst:646
msgid "The original specification for function annotations."
msgstr "最初的函数标注规范说明。"

#: ../../reference/compound_stmts.rst:649
msgid ":pep:`484` - Type Hints"
msgstr ":pep:`484` —— 类型注解"

#: ../../reference/compound_stmts.rst:649
msgid "Definition of a standard meaning for annotations: type hints."
msgstr "标注的标准含意定义：类型提示。"

#: ../../reference/compound_stmts.rst:653
msgid ":pep:`526` - Syntax for Variable Annotations"
msgstr ":pep:`526` - 变量标注的语法"

#: ../../reference/compound_stmts.rst:652
msgid ""
"Ability to type hint variable declarations, including class variables and "
"instance variables"
msgstr "变量声明的类型提示功能，包括类变量和实例变量"

#: ../../reference/compound_stmts.rst:656
msgid ":pep:`563` - Postponed Evaluation of Annotations"
msgstr ":pep:`563` - 延迟的标注求值"

#: ../../reference/compound_stmts.rst:656
msgid ""
"Support for forward references within annotations by preserving annotations "
"in a string form at runtime instead of eager evaluation."
msgstr ""
"支持在运行时通过以字符串形式保存标注而非不是即求值来实现标注内部的向前引用。"

#: ../../reference/compound_stmts.rst:663
msgid "Class definitions"
msgstr "类定义"

#: ../../reference/compound_stmts.rst:678
msgid "A class definition defines a class object (see section :ref:`types`):"
msgstr "类定义就是对类对象的定义 (参见 :ref:`types` 一节):"

#: ../../reference/compound_stmts.rst:685
msgid ""
"A class definition is an executable statement.  The inheritance list usually "
"gives a list of base classes (see :ref:`metaclasses` for more advanced "
"uses), so each item in the list should evaluate to a class object which "
"allows subclassing.  Classes without an inheritance list inherit, by "
"default, from the base class :class:`object`; hence, ::"
msgstr ""
"类定义是一条可执行语句。 其中继承列表通常给出基类的列表 (进阶用法请参见 :ref:"
"`metaclasses`)，列表中的每一项都应当被求值为一个允许子类的类对象。 没有继承列"
"表的类默认继承自基类 :class:`object`；因此，::"

#: ../../reference/compound_stmts.rst:694
msgid "is equivalent to ::"
msgstr "等价于 ::"

#: ../../reference/compound_stmts.rst:699
msgid ""
"The class's suite is then executed in a new execution frame (see :ref:"
"`naming`), using a newly created local namespace and the original global "
"namespace. (Usually, the suite contains mostly function definitions.)  When "
"the class's suite finishes execution, its execution frame is discarded but "
"its local namespace is saved. [#]_ A class object is then created using the "
"inheritance list for the base classes and the saved local namespace for the "
"attribute dictionary.  The class name is bound to this class object in the "
"original local namespace."
msgstr ""
"随后类体将在一个新的执行帧 (参见 :ref:`naming`) 中被执行，使用新创建的局部命"
"名空间和原有的全局命名空间。 （通常，类体主要包含函数定义。） 当类体结束执行"
"时，其执行帧将被丢弃而其局部命名空间会被保存。 [#]_ 一个类对象随后会被创建，"
"其基类使用给定的继承列表，属性字典使用保存的局部命名空间。 类名称将在原有的全"
"局命名空间中绑定到该类对象。"

#: ../../reference/compound_stmts.rst:708
msgid ""
"The order in which attributes are defined in the class body is preserved in "
"the new class's ``__dict__``.  Note that this is reliable only right after "
"the class is created and only for classes that were defined using the "
"definition syntax."
msgstr ""
"在类体内定义的属性的顺序保存在新类的 ``__dict__`` 中。 请注意此顺序的可靠性只"
"限于类刚被创建时，并且只适用于使用定义语法所定义的类。"

#: ../../reference/compound_stmts.rst:713
msgid ""
"Class creation can be customized heavily using :ref:`metaclasses "
"<metaclasses>`."
msgstr "类的创建可使用 :ref:`元类 <metaclasses>` 进行重度定制。"

#: ../../reference/compound_stmts.rst:718
msgid "Classes can also be decorated: just like when decorating functions, ::"
msgstr "类也可以被装饰：就像装饰函数一样，::"

#: ../../reference/compound_stmts.rst:729
msgid ""
"The evaluation rules for the decorator expressions are the same as for "
"function decorators.  The result is then bound to the class name."
msgstr "装饰器表达式的求值规则与函数装饰器相同。 结果随后会被绑定到类名称。"

#: ../../reference/compound_stmts.rst:732
msgid ""
"Classes may be decorated with any valid :token:`assignment_expression`. "
"Previously, the grammar was much more restrictive; see :pep:`614` for "
"details."
msgstr ""
"类可使用任何有效的 :token:`assignment_expression` 来装饰。 在之前版本中，此语"
"法则更为受限，详情参见 :pep:`614`。"

#: ../../reference/compound_stmts.rst:737
msgid ""
"**Programmer's note:** Variables defined in the class definition are class "
"attributes; they are shared by instances.  Instance attributes can be set in "
"a method with ``self.name = value``.  Both class and instance attributes are "
"accessible through the notation \"``self.name``\", and an instance attribute "
"hides a class attribute with the same name when accessed in this way.  Class "
"attributes can be used as defaults for instance attributes, but using "
"mutable values there can lead to unexpected results.  :ref:`Descriptors "
"<descriptors>` can be used to create instance variables with different "
"implementation details."
msgstr ""
"**程序员注意事项:** 在类定义内定义的变量是类属性；它们将被类实例所共享。 实例"
"属性可通过 ``self.name = value`` 在方法中设定。 类和实例属性均可通过 "
"\"``self.name``\" 表示法来访问，当通过此方式访问时实例属性会隐藏同名的类属"
"性。 类属性可被用作实例属性的默认值，但在此场景下使用可变值可能导致未预期的结"
"果。 可以使用 :ref:`描述器 <descriptors>` 来创建具有不同实现细节的实例变量。"

#: ../../reference/compound_stmts.rst:752
msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ":pep:`3115` - Python 3000 中的元类"

#: ../../reference/compound_stmts.rst:750
msgid ""
"The proposal that changed the declaration of metaclasses to the current "
"syntax, and the semantics for how classes with metaclasses are constructed."
msgstr ""
"将元类声明修改为当前语法的提议，以及关于如何构建带有元类的类的语义描述。"

#: ../../reference/compound_stmts.rst:755
msgid ":pep:`3129` - Class Decorators"
msgstr ":pep:`3129` - 类装饰器"

#: ../../reference/compound_stmts.rst:755
msgid ""
"The proposal that added class decorators.  Function and method decorators "
"were introduced in :pep:`318`."
msgstr "增加类装饰器的提议。 函数和方法装饰器是在 :pep:`318` 中被引入的。"

#: ../../reference/compound_stmts.rst:762
msgid "Coroutines"
msgstr "协程"

#: ../../reference/compound_stmts.rst:770
msgid "Coroutine function definition"
msgstr "协程函数定义"

#: ../../reference/compound_stmts.rst:780
msgid ""
"Execution of Python coroutines can be suspended and resumed at many points "
"(see :term:`coroutine`).  Inside the body of a coroutine function, ``await`` "
"and ``async`` identifiers become reserved keywords; :keyword:`await` "
"expressions, :keyword:`async for` and :keyword:`async with` can only be used "
"in coroutine function bodies."
msgstr ""
"Python 协程可以在多个位置上挂起和恢复执行 (参见 :term:`coroutine`)。 在协程函"
"数体内部，``await`` 和 ``async`` 标识符已成为保留关键字；:keyword:`await` 表"
"达式，:keyword:`async for` 以及 :keyword:`async with` 只能在协程函数体中使"
"用。"

#: ../../reference/compound_stmts.rst:786
msgid ""
"Functions defined with ``async def`` syntax are always coroutine functions, "
"even if they do not contain ``await`` or ``async`` keywords."
msgstr ""
"使用 ``async def`` 语法定义的函数总是为协程函数，即使它们不包含 ``await`` 或 "
"``async`` 关键字。"

#: ../../reference/compound_stmts.rst:789
msgid ""
"It is a :exc:`SyntaxError` to use a ``yield from`` expression inside the "
"body of a coroutine function."
msgstr "在协程函数体中使用 ``yield from`` 表达式将引发 :exc:`SyntaxError`。"

#: ../../reference/compound_stmts.rst:792
msgid "An example of a coroutine function::"
msgstr "协程函数的例子::"

#: ../../reference/compound_stmts.rst:803
msgid "The :keyword:`!async for` statement"
msgstr ":keyword:`!async for` 语句"

#: ../../reference/compound_stmts.rst:808
msgid ""
"An :term:`asynchronous iterable` provides an ``__aiter__`` method that "
"directly returns an :term:`asynchronous iterator`, which can call "
"asynchronous code in its ``__anext__`` method."
msgstr ""
":term:`asynchronous iterable` 提供了 ``__aiter__`` 方法，该方法会直接返回 :"
"term:`asynchronous iterator`，它可以在其 ``__anext__`` 方法中调用异步代码。"

#: ../../reference/compound_stmts.rst:812
msgid ""
"The ``async for`` statement allows convenient iteration over asynchronous "
"iterables."
msgstr "``async for`` 语句允许方便地对异步可迭代对象进行迭代。"

#: ../../reference/compound_stmts.rst:822
msgid "Is semantically equivalent to::"
msgstr "在语义上等价于::"

#: ../../reference/compound_stmts.rst:838
msgid "See also :meth:`__aiter__` and :meth:`__anext__` for details."
msgstr "另请参阅 :meth:`__aiter__` 和 :meth:`__anext__` 了解详情。"

#: ../../reference/compound_stmts.rst:840
msgid ""
"It is a :exc:`SyntaxError` to use an ``async for`` statement outside the "
"body of a coroutine function."
msgstr "在协程函数体之外使用 ``async for`` 语句将引发 :exc:`SyntaxError`。"

#: ../../reference/compound_stmts.rst:848
msgid "The :keyword:`!async with` statement"
msgstr ":keyword:`!async with` 语句"

#: ../../reference/compound_stmts.rst:853
msgid ""
"An :term:`asynchronous context manager` is a :term:`context manager` that is "
"able to suspend execution in its *enter* and *exit* methods."
msgstr ""
":term:`asynchronous context manager` 是一种 :term:`context manager`，能够在"
"其 *enter* 和 *exit* 方法中暂停执行。"

#: ../../reference/compound_stmts.rst:880
msgid "See also :meth:`__aenter__` and :meth:`__aexit__` for details."
msgstr "另请参阅 :meth:`__aenter__` 和 :meth:`__aexit__` 了解详情。"

#: ../../reference/compound_stmts.rst:882
msgid ""
"It is a :exc:`SyntaxError` to use an ``async with`` statement outside the "
"body of a coroutine function."
msgstr "在协程函数体之外使用 ``async with`` 语句将引发 :exc:`SyntaxError`。"

#: ../../reference/compound_stmts.rst:888
msgid ":pep:`492` - Coroutines with async and await syntax"
msgstr ":pep:`492` - 使用 async 和 await 语法实现协程"

#: ../../reference/compound_stmts.rst:888
msgid ""
"The proposal that made coroutines a proper standalone concept in Python, and "
"added supporting syntax."
msgstr "将协程作为 Python 中的一个正式的单独概念，并增加相应的支持语法。"

#: ../../reference/compound_stmts.rst:893
msgid "Footnotes"
msgstr "备注"

#: ../../reference/compound_stmts.rst:894
msgid ""
"The exception is propagated to the invocation stack unless there is a :"
"keyword:`finally` clause which happens to raise another exception. That new "
"exception causes the old one to be lost."
msgstr ""
"异常会被传播给唤起栈，除非存在一个 :keyword:`finally` 子句正好引发了另一个异"
"常。 新引发的异常将导致旧异常的丢失。"

#: ../../reference/compound_stmts.rst:898
msgid ""
"A string literal appearing as the first statement in the function body is "
"transformed into the function's ``__doc__`` attribute and therefore the "
"function's :term:`docstring`."
msgstr ""
"作为函数体的第一条语句出现的字符串字面值会被转换为函数的 ``__doc__`` 属性，也"
"就是该函数的 :term:`docstring`。"

#: ../../reference/compound_stmts.rst:902
msgid ""
"A string literal appearing as the first statement in the class body is "
"transformed into the namespace's ``__doc__`` item and therefore the class's :"
"term:`docstring`."
msgstr ""
"作为类体的第一条语句出现的字符串字面值会被转换为命名空间的 ``__doc__`` 条目，"
"也就是该类的 :term:`docstring`。"
