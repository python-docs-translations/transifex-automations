# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-18 17:29+0000\n"
"PO-Revision-Date: 2023-05-24 02:10+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Japanese (https://app.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../faq/design.rst:3
msgid "Design and History FAQ"
msgstr "Projekt i Historia FAQ"

#: ../../faq/design.rst:6
msgid "Contents"
msgstr "Zawartość"

#: ../../faq/design.rst:11
msgid "Why does Python use indentation for grouping of statements?"
msgstr "Dlaczego Python używa akapitów do grupowania instrukcji?"

#: ../../faq/design.rst:13
msgid ""
"Guido van Rossum believes that using indentation for grouping is extremely "
"elegant and contributes a lot to the clarity of the average Python program. "
"Most people learn to love this feature after a while."
msgstr ""
"Guido van Rossum uważa, że używanie akapitów do grupowania jest niezwykle "
"eleganckie i przyczynia się bardzo do przejrzystości przeciętnego programu w "
"Pythonie.\n"
"Wśród większości ludzi właściwość ta z czasem zyskuje sobie sympatyków."

#: ../../faq/design.rst:17
msgid ""
"Since there are no begin/end brackets there cannot be a disagreement between "
"grouping perceived by the parser and the human reader.  Occasionally C "
"programmers will encounter a fragment of code like this::"
msgstr ""
"Ze względu na brak początkowych/końcowych nawiasów nie może dojść do "
"rozbieżności pomiędzy grupowaniem odbieranym  przez analizator składni a tym "
"odbieranym przez człowieka. Sporadycznie programiści języka C napotykać będą "
"taki fragment kodu:"

#: ../../faq/design.rst:26
msgid ""
"Only the ``x++`` statement is executed if the condition is true, but the "
"indentation leads many to believe otherwise.  Even experienced C programmers "
"will sometimes stare at it a long time wondering as to why ``y`` is being "
"decremented even for ``x > y``."
msgstr ""
"Tylko polecenie ``x++`` jest wykonywane, jeśli warunek jest prawdziwy, ale "
"akapit prowadzi wielu do innego przekonania. Nawet doświadczony programista "
"języka C będzie czasem dłużej się temu przyglądał, zastanawiając się "
"dlaczego ``y`` jest zdekrementowane nawet do ``x > y``."

#: ../../faq/design.rst:31
msgid ""
"Because there are no begin/end brackets, Python is much less prone to coding-"
"style conflicts.  In C there are many different ways to place the braces. "
"After becoming used to reading and writing code using a particular style, it "
"is normal to feel somewhat uneasy when reading (or being required to write) "
"in a different one."
msgstr ""
"Z powodu braku otwierających/zamykających nawiasów, Python jest o wiele "
"mniej podatny na konflikty wynikające ze stylu kodowania. W języku C jest "
"wiele różnych sposobów wstawiania nawiasów. Przyzwyczaiwszy się do czytania "
"i pisania kodu w określonym stylu, normalną rzeczą jest, że czujemy się "
"trochę nieswojo, gdy czytamy (albo wymaga się od nas pisania)  w innym stylu."

#: ../../faq/design.rst:38
msgid ""
"Many coding styles place begin/end brackets on a line by themselves.  This "
"makes programs considerably longer and wastes valuable screen space, making "
"it harder to get a good overview of a program.  Ideally, a function should "
"fit on one screen (say, 20--30 lines).  20 lines of Python can do a lot more "
"work than 20 lines of C.  This is not solely due to the lack of begin/end "
"brackets -- the lack of declarations and the high-level data types are also "
"responsible -- but the indentation-based syntax certainly helps."
msgstr ""
"Wiele stylów programowania umieszcza otwierające/zamykające nawiasy w linii "
"automatycznie. To czyni programy znaczniej dłuższymi i marnuje cenną "
"przestrzeń ekranu. W ten sposób trudniej jest otrzymać dobry przegląd "
"programu. Idealnie funkcja powinna zmieścić się na jednym ekranie (powiedzmy "
"20-30 linii). 20 linii w Pythonie może więcej zdziałać niż 20 linii w języku "
"C. Nie jest to wyłącznie wynikiem  braku nawiasów otwierających/zamykających "
"-- za to odpowiedzialny jest również brak deklaracji oraz wysokopoziomowe "
"typy danych -- jednakże składnia oparta o akapity z pewnością pomaga."

#: ../../faq/design.rst:48
msgid "Why am I getting strange results with simple arithmetic operations?"
msgstr ""
"Dlaczego otrzymuję dziwne wyniki w odpowiedzi na proste działania "
"arytmetyczne?"

#: ../../faq/design.rst:50
msgid "See the next question."
msgstr "Spójrz na następne pytanie."

#: ../../faq/design.rst:54
msgid "Why are floating-point calculations so inaccurate?"
msgstr "Dlaczego obliczenia zmiennoprzecinkowe są tak niedokładne?"

#: ../../faq/design.rst:56
msgid "Users are often surprised by results like this::"
msgstr "Użytkownicy są często zaskoczeni następującymi wynikami::"

#: ../../faq/design.rst:61
msgid ""
"and think it is a bug in Python.  It's not.  This has little to do with "
"Python, and much more to do with how the underlying platform handles "
"floating-point numbers."
msgstr ""
"i sądzą, że to błąd w Pythonie. To jednak nie błąd. To ma niewiele wspólnego "
"z Pythonem. To wynika bardziej z tego jak bazowa platforma radzi sobie z "
"liczbami zmiennoprzecinkowymi."

#: ../../faq/design.rst:65
msgid ""
"The :class:`float` type in CPython uses a C ``double`` for storage.  A :"
"class:`float` object's value is stored in binary floating-point with a fixed "
"precision (typically 53 bits) and Python uses C operations, which in turn "
"rely on the hardware implementation in the processor, to perform floating-"
"point operations. This means that as far as floating-point operations are "
"concerned, Python behaves like many popular languages including C and Java."
msgstr ""
"Typ :class:`float` w CPython używa ``double`` z C do przechowywania. Wartość "
"obiektu :class:`float` jest przechowywana w binarnej liczbie "
"zmiennoprzecinkowej z niezmienną precyzją (typowo 53 bity) a Python używa "
"operacji C, które z kolei bazują na implementacji sprzętu w procesorze, żeby "
"wykonywać działania na liczbach zmiennoprzecinkowych. To oznacza, że jeśli "
"chodzi o działania na liczbach zmiennoprzecinkowych, to Python zachowuje się "
"jak wiele popularnych języków, między innymi C i Java."

#: ../../faq/design.rst:72
msgid ""
"Many numbers that can be written easily in decimal notation cannot be "
"expressed exactly in binary floating-point.  For example, after::"
msgstr ""
"10 進数で簡単に書ける多くの数が、2 進浮動小数点数では正確に表すことができませ"
"ん。例えばこうすると::"

#: ../../faq/design.rst:77
msgid ""
"the value stored for ``x`` is a (very good) approximation to the decimal "
"value ``1.2``, but is not exactly equal to it.  On a typical machine, the "
"actual stored value is::"
msgstr ""
"wartość przechowywana dla ``x`` jest (bardzo dobrym) przybliżeniem do "
"dziesiętnej wartości ``1.2``, ale nie jest dokładnie jej równa. Na typowym "
"urządzeniu, faktycznie przechowywana wartość wynosi::"

#: ../../faq/design.rst:83
msgid "which is exactly::"
msgstr "która dokładnie równa się::"

#: ../../faq/design.rst:87
msgid ""
"The typical precision of 53 bits provides Python floats with 15--16 decimal "
"digits of accuracy."
msgstr ""
"Typowa precyzja 53-bitowa zapewnia Pythonowi liczby zmiennoprzecinkowe z "
"dokładnością do 15--16 cyfr dziesiętnych."

#: ../../faq/design.rst:90
msgid ""
"For a fuller explanation, please see the :ref:`floating point arithmetic "
"<tut-fp-issues>` chapter in the Python tutorial."
msgstr ""
"詳しくは、Python チュートリアルの :ref:`floating point arithmetic <tut-fp-"
"issues>` の章を参照してください。"

#: ../../faq/design.rst:95
msgid "Why are Python strings immutable?"
msgstr "Dlaczego stringi w Pythonie są niezmienne?"

#: ../../faq/design.rst:97
msgid "There are several advantages."
msgstr "Jest parę zalet."

#: ../../faq/design.rst:99
msgid ""
"One is performance: knowing that a string is immutable means we can allocate "
"space for it at creation time, and the storage requirements are fixed and "
"unchanging.  This is also one of the reasons for the distinction between "
"tuples and lists."
msgstr ""
"Jedną z nich jest wydajność: wiedząc, że string jest niezmienny, możemy dla "
"niego przypisać miejsce w trakcie tworzenia a wymagania dotyczące "
"przechowywania są stałe i nie ulegają zmianie. To jest również jeden z "
"powodów rozróżniania między krotkami a listami."

#: ../../faq/design.rst:104
msgid ""
"Another advantage is that strings in Python are considered as \"elemental\" "
"as numbers.  No amount of activity will change the value 8 to anything else, "
"and in Python, no amount of activity will change the string \"eight\" to "
"anything else."
msgstr ""
"Inną zaletą jest to, że w Pythonie stringi są uważane za równie "
"\"elementarne\" co liczby. Żadna ilość czynności nie zmieni wartości 8  na "
"cokolwiek innego, a w Pythonie żadna ilość czynności nie zmieni stringu "
"\"osiem\" na cokolwiek innego."

#: ../../faq/design.rst:112
msgid "Why must 'self' be used explicitly in method definitions and calls?"
msgstr ""
"Dlaczego 'self' musi być wyraźnie używane w definicjach metod i wywołaniach?"

#: ../../faq/design.rst:114
msgid ""
"The idea was borrowed from Modula-3.  It turns out to be very useful, for a "
"variety of reasons."
msgstr ""
"Ідея була запозичена з Modula-3. Це виявляється дуже корисним з різних "
"причин."

#: ../../faq/design.rst:117
msgid ""
"First, it's more obvious that you are using a method or instance attribute "
"instead of a local variable.  Reading ``self.x`` or ``self.meth()`` makes it "
"absolutely clear that an instance variable or method is used even if you "
"don't know the class definition by heart.  In C++, you can sort of tell by "
"the lack of a local variable declaration (assuming globals are rare or "
"easily recognizable) -- but in Python, there are no local variable "
"declarations, so you'd have to look up the class definition to be sure.  "
"Some C++ and Java coding standards call for instance attributes to have an "
"``m_`` prefix, so this explicitness is still useful in those languages, too."
msgstr ""
"По-перше, більш очевидно, що ви використовуєте метод або атрибут екземпляра "
"замість локальної змінної. Читання ``self.x`` або ``self.meth()`` робить "
"абсолютно зрозумілим, що використовується змінна екземпляра або метод, "
"навіть якщо ви не знаєте визначення класу напам'ять. У C++ це можна "
"визначити за відсутністю оголошення локальної змінної (якщо глобальні "
"значення рідкісні або легко впізнавані), але в Python немає оголошення "
"локальної змінної, тому вам доведеться шукати визначення класу, щоб бути "
"впевненим. Деякі стандарти кодування C++ і Java вимагають, щоб атрибути "
"екземплярів мали префікс ``m_``, тому ця чіткість все ще корисна в цих мовах."

#: ../../faq/design.rst:127
msgid ""
"Second, it means that no special syntax is necessary if you want to "
"explicitly reference or call the method from a particular class.  In C++, if "
"you want to use a method from a base class which is overridden in a derived "
"class, you have to use the ``::`` operator -- in Python you can write "
"``baseclass.methodname(self, <argument list>)``.  This is particularly "
"useful for :meth:`__init__` methods, and in general in cases where a derived "
"class method wants to extend the base class method of the same name and thus "
"has to call the base class method somehow."
msgstr ""
"第二に、特定のクラスからメソッドを明示的に参照または呼び出ししたい時に、特別"
"な構文が必要なくなります。C++ では、派生クラスでオーバーライドされた基底クラ"
"スからメソッドを使うには、 ``::`` 演算子を使わなければなりません。 -- Python "
"では、 ``baseclass.methodname(self, <argument list>)`` と書けます。これは特"
"に、 :meth:`__init__` メソッドに便利ですし、派生クラスのメソッドが、基底クラ"
"スにある同じ名前のメソッドを拡張するために、基底クラスのメソッドをどうにかし"
"て呼び出したい時にも便利です。"

#: ../../faq/design.rst:136
msgid ""
"Finally, for instance variables it solves a syntactic problem with "
"assignment: since local variables in Python are (by definition!) those "
"variables to which a value is assigned in a function body (and that aren't "
"explicitly declared global), there has to be some way to tell the "
"interpreter that an assignment was meant to assign to an instance variable "
"instead of to a local variable, and it should preferably be syntactic (for "
"efficiency reasons).  C++ does this through declarations, but Python doesn't "
"have declarations and it would be a pity having to introduce them just for "
"this purpose.  Using the explicit ``self.var`` solves this nicely.  "
"Similarly, for using instance variables, having to write ``self.var`` means "
"that references to unqualified names inside a method don't have to search "
"the instance's directories.  To put it another way, local variables and "
"instance variables live in two different namespaces, and you need to tell "
"Python which namespace to use."
msgstr ""
"Нарешті, для  змінних екземпляра, такий підхід вирішує синтаксичну проблему "
"з призначенням: оскільки локальні змінні в Python — це (за визначенням!) ті "
"змінні, яким присвоєно значення в тілі функції (і які явно не оголошені "
"глобальними), необхідно бути якимось способом повідомити інтерпретатору, що "
"це призначено для встановленния значення змінній екземпляра, а не локальній "
"змінній, і бажано, щоб воно було синтаксичним (з причин ефективності). C++ "
"робить це за допомогою декларацій, але Python не має декларацій, і було б "
"шкода вводити їх лише для цієї мети. Використання явного ``self.var`` добре "
"вирішує цю проблему. Подібним чином, для використання змінних екземпляра "
"необхідність запису ``self.var`` означає, що посилання на некваліфіковані "
"імена всередині методу не потребують пошуку в каталогах екземпляра. Іншими "
"словами, локальні змінні та змінні екземплярів живуть у двох різних "
"просторах імен, і вам потрібно сказати інтерпритатору Python, який простір "
"імен використовувати."

#: ../../faq/design.rst:154
msgid "Why can't I use an assignment in an expression?"
msgstr "Dlaczego nie mogę użyć przypisania w wyrażeniu?"

#: ../../faq/design.rst:156
msgid "Starting in Python 3.8, you can!"
msgstr "Począwszy od Pythona 3.8 możesz!"

#: ../../faq/design.rst:158
msgid ""
"Assignment expressions using the walrus operator ``:=`` assign a variable in "
"an expression::"
msgstr ""
"Выражения присваивания с использованием оператора моржа ``:=`` присваивают "
"переменную в выражении::"

#: ../../faq/design.rst:164
msgid "See :pep:`572` for more information."
msgstr "Zobacz :pep:`572` aby uzyskać więcej informacji."

#: ../../faq/design.rst:169
msgid ""
"Why does Python use methods for some functionality (e.g. list.index()) but "
"functions for other (e.g. len(list))?"
msgstr ""
"Чому Python використовує методи для одних функцій (наприклад, list.index()), "
"а функції для інших (наприклад, len(list))?"

#: ../../faq/design.rst:171
msgid "As Guido said:"
msgstr "Seperti yang Guido katakan:"

#: ../../faq/design.rst:173
msgid ""
"(a) For some operations, prefix notation just reads better than postfix -- "
"prefix (and infix!) operations have a long tradition in mathematics which "
"likes notations where the visuals help the mathematician thinking about a "
"problem. Compare the easy with which we rewrite a formula like x*(a+b) into "
"x*a + x*b to the clumsiness of doing the same thing using a raw OO notation."
msgstr ""
"(a) Для деяких операцій префіксна нотація просто читається краще, ніж "
"постфіксна — префіксні (та інфіксні!) операції мають давню традицію в "
"математиці, яка любить нотації, де візуальні елементи допомагають математику "
"думати про проблему. Порівняйте легкість, за допомогою якої ми переписуємо "
"формулу на кшталт x*(a+b) на x*a + x*b, із незграбністю виконання того ж "
"самого, використовуючи чисту нотацію OO."

#: ../../faq/design.rst:180
msgid ""
"(b) When I read code that says len(x) I *know* that it is asking for the "
"length of something. This tells me two things: the result is an integer, and "
"the argument is some kind of container. To the contrary, when I read x."
"len(), I have to already know that x is some kind of container implementing "
"an interface or inheriting from a class that has a standard len(). Witness "
"the confusion we occasionally have when a class that is not implementing a "
"mapping has a get() or keys() method, or something that isn't a file has a "
"write() method."
msgstr ""
"(b) Коли я читаю код, який каже len(x), я *знаю*, що він запитує довжину "
"чогось. Це говорить мені про дві речі: результат є цілим числом, а аргумент "
"є певним контейнером. Навпаки, коли я читаю x.len(), я вже маю знати, що x — "
"це якийсь контейнер, який реалізує інтерфейс або успадковує від класу, який "
"має стандартний len(). Подивіться, яка плутанина у нас іноді виникає, коли "
"клас, який не реалізує відображення, має метод get() або keys(), або щось, "
"що не є файлом, має метод write()."

#: ../../faq/design.rst:189
msgid "https://mail.python.org/pipermail/python-3000/2006-November/004643.html"
msgstr ""
"https://mail.python.org/pipermail/python-3000/2006-November/004643.html"

#: ../../faq/design.rst:193
msgid "Why is join() a string method instead of a list or tuple method?"
msgstr "Чому метод join() є методом рядків, а не методом списку чи кортежу?"

#: ../../faq/design.rst:195
msgid ""
"Strings became much more like other standard types starting in Python 1.6, "
"when methods were added which give the same functionality that has always "
"been available using the functions of the string module.  Most of these new "
"methods have been widely accepted, but the one which appears to make some "
"programmers feel uncomfortable is::"
msgstr ""
"Рядки стали набагато більше схожими на інші стандартні типи, починаючи з "
"Python 1.6, коли були додані методи, які надають ту саму функціональність, "
"яка завжди була доступна за допомогою функцій модуля string. Більшість цих "
"нових методів були широко прийняті, але один, який, здається, змушує деяких "
"програмістів почуватися некомфортно:"

#: ../../faq/design.rst:203
msgid "which gives the result::"
msgstr "що дає результат::"

#: ../../faq/design.rst:207
msgid "There are two common arguments against this usage."
msgstr "Існує два загальні аргументи проти такого використання."

#: ../../faq/design.rst:209
msgid ""
"The first runs along the lines of: \"It looks really ugly using a method of "
"a string literal (string constant)\", to which the answer is that it might, "
"but a string literal is just a fixed value. If the methods are to be allowed "
"on names bound to strings there is no logical reason to make them "
"unavailable on literals."
msgstr ""
"Перше звучить так: \"Це виглядає дуже потворно, використовуючи метод "
"рядкового літералу (рядкова константа)\", на що є відповідь, що це може "
"бути, навіть якщо рядковий літерал це лише фіксоване значення. Якщо методи "
"мають бути дозволені для імен, прив’язаних до рядків, немає логічної причини "
"робити їх недоступними для літералів."

#: ../../faq/design.rst:215
msgid ""
"The second objection is typically cast as: \"I am really telling a sequence "
"to join its members together with a string constant\".  Sadly, you aren't.  "
"For some reason there seems to be much less difficulty with having :meth:"
"`~str.split` as a string method, since in that case it is easy to see that ::"
msgstr ""
"Друге заперечення, як правило, формулюється так: \"Я справді кажу "
"послідовності об’єднати її члени за допомогою рядкової константи\". На жаль, "
"ні. З певних причин здається, що з використанням :meth:`~str.split` як "
"рядкового методу набагато менше труднощів, оскільки в цьому випадку легко "
"побачити, що:"

#: ../../faq/design.rst:222
msgid ""
"is an instruction to a string literal to return the substrings delimited by "
"the given separator (or, by default, arbitrary runs of white space)."
msgstr ""
"це вказівка для рядкового літералу повертати підрядки, розділені заданим "
"роздільником (або, за замовчуванням, пробілом)."

#: ../../faq/design.rst:225
msgid ""
":meth:`~str.join` is a string method because in using it you are telling the "
"separator string to iterate over a sequence of strings and insert itself "
"between adjacent elements.  This method can be used with any argument which "
"obeys the rules for sequence objects, including any new classes you might "
"define yourself. Similar methods exist for bytes and bytearray objects."
msgstr ""
":meth:`~str.join` — це рядковий метод, оскільки, використовуючи його, ви "
"вказуєте рядку-роздільнику перебирати послідовність рядків і вставляти себе "
"між суміжними елементами. Цей метод можна використовувати з будь-яким "
"аргументом, який підкоряється правилам для об’єктів послідовності, включаючи "
"будь-які нові класи, які ви можете визначити самостійно. Подібні методи "
"існують для об’єктів bytes і bytearray."

#: ../../faq/design.rst:233
msgid "How fast are exceptions?"
msgstr "Як швидко працюють винятки?"

#: ../../faq/design.rst:235
msgid ""
"A try/except block is extremely efficient if no exceptions are raised.  "
"Actually catching an exception is expensive.  In versions of Python prior to "
"2.0 it was common to use this idiom::"
msgstr ""
"try/except ブロックは例外が送出されなければ極端に効率的です。実際に例外を捕捉"
"するのは高価です。Python 2.0 より前のバージョンでは、このイディオムを使うのが"
"一般的でした::"

#: ../../faq/design.rst:245
msgid ""
"This only made sense when you expected the dict to have the key almost all "
"the time.  If that wasn't the case, you coded it like this::"
msgstr ""
"Це мало сенс лише тоді, коли ви очікували, що dict матиме ключ майже весь "
"час. Якщо це не так, ви закодували це так::"

#: ../../faq/design.rst:253
msgid ""
"For this specific case, you could also use ``value = dict.setdefault(key, "
"getvalue(key))``, but only if the ``getvalue()`` call is cheap enough "
"because it is evaluated in all cases."
msgstr ""
"Для цього конкретного випадку ви також можете використати ``value = dict."
"setdefault(key, getvalue(key))``, але лише якщо виклик ``getvalue()`` досить "
"дешевий, оскільки він оцінюється в усіх випадках."

#: ../../faq/design.rst:259
msgid "Why isn't there a switch or case statement in Python?"
msgstr "Чому в Python немає оператора switch або case?"

#: ../../faq/design.rst:261
msgid ""
"In general, structured switch statements execute one block of code when an "
"expression has a particular value or set of values. Since Python 3.10 one "
"can easily match literal values, or constants within a namespace, with a "
"``match ... case`` statement. An older alternative is a sequence of ``if... "
"elif... elif... else``."
msgstr ""
"Как правило, структурированные операторы переключения выполняют один блок "
"кода, когда выражение имеет определенное значение или набор значений. "
"Начиная с Python 3.10, можно легко сопоставить литеральные значения или "
"константы в пространстве имен с помощью оператора match...case. Более старая "
"альтернатива — это последовательность ``if... elif... elif... else``."

#: ../../faq/design.rst:267
msgid ""
"For cases where you need to choose from a very large number of "
"possibilities, you can create a dictionary mapping case values to functions "
"to call.  For example::"
msgstr ""
"У випадках, коли вам потрібно вибрати з дуже великої кількості можливостей, "
"ви можете створити словник, який зіставлятиме значення регістру з функціями "
"для виклику. Наприклад::"

#: ../../faq/design.rst:278
msgid ""
"For calling methods on objects, you can simplify yet further by using the :"
"func:`getattr` built-in to retrieve methods with a particular name::"
msgstr ""
"Для виклику методів об’єктів ви можете ще більше спростити, використовуючи "
"вбудований :func:`getattr` для отримання методів із певним іменем::"

#: ../../faq/design.rst:290
msgid ""
"It's suggested that you use a prefix for the method names, such as "
"``visit_`` in this example.  Without such a prefix, if values are coming "
"from an untrusted source, an attacker would be able to call any method on "
"your object."
msgstr ""
"Рекомендується використовувати префікс для імен методів, наприклад "
"``visit_`` у цьому прикладі. Без такого префікса, якщо значення надходять із "
"ненадійного джерела, зловмисник зможе викликати будь-який метод вашого "
"об’єкта."

#: ../../faq/design.rst:294
msgid ""
"Imitating switch with fallthrough, as with C's switch-case-default, is "
"possible, much harder, and less needed."
msgstr ""
"Имитация переключения с провалом, как в случае с switch-case-default в C, "
"возможна, гораздо сложнее и менее необходима."

#: ../../faq/design.rst:299
msgid ""
"Can't you emulate threads in the interpreter instead of relying on an OS-"
"specific thread implementation?"
msgstr ""
"Чи не можна емулювати потоки в інтерпретаторі замість того, щоб покладатися "
"на реалізацію потоку, специфічного для ОС?"

#: ../../faq/design.rst:301
msgid ""
"Answer 1: Unfortunately, the interpreter pushes at least one C stack frame "
"for each Python stack frame.  Also, extensions can call back into Python at "
"almost random moments.  Therefore, a complete threads implementation "
"requires thread support for C."
msgstr ""
"Відповідь 1: На жаль, інтерпретатор надсилає принаймні один кадр стека C для "
"кожного кадру стека Python. Крім того, розширення можуть повертатися до "
"Python у майже випадкові моменти. Таким чином, повна реалізація потоків "
"вимагає підтримки потоків для C."

#: ../../faq/design.rst:306
msgid ""
"Answer 2: Fortunately, there is `Stackless Python <https://github.com/"
"stackless-dev/stackless/wiki>`_, which has a completely redesigned "
"interpreter loop that avoids the C stack."
msgstr ""
"Відповідь 2: На щастя, є `Stackless Python <https://github.com/stackless-dev/"
"stackless/wiki>`_, який має повністю перероблений цикл інтерпретатора, який "
"уникає стека C."

#: ../../faq/design.rst:311
msgid "Why can't lambda expressions contain statements?"
msgstr "Чому лямбда-вирази не можуть містити оператори?"

#: ../../faq/design.rst:313
msgid ""
"Python lambda expressions cannot contain statements because Python's "
"syntactic framework can't handle statements nested inside expressions.  "
"However, in Python, this is not a serious problem.  Unlike lambda forms in "
"other languages, where they add functionality, Python lambdas are only a "
"shorthand notation if you're too lazy to define a function."
msgstr ""
"Лямбда-вирази Python не можуть містити оператори, оскільки синтаксична "
"структура Python не може обробляти оператори, вкладені у вирази. Однак у "
"Python це не є серйозною проблемою. На відміну від лямбда-форм в інших "
"мовах, де вони додають функціональність, лямбда-вирази Python є лише "
"скороченою нотацією, якщо вам ліньки визначати функцію."

#: ../../faq/design.rst:319
msgid ""
"Functions are already first class objects in Python, and can be declared in "
"a local scope.  Therefore the only advantage of using a lambda instead of a "
"locally defined function is that you don't need to invent a name for the "
"function -- but that's just a local variable to which the function object "
"(which is exactly the same type of object that a lambda expression yields) "
"is assigned!"
msgstr ""
"Функции уже являются объектами первого класса в Python и могут быть "
"объявлены в локальной области. Поэтому единственное преимущество "
"использования лямбды вместо локально определенной функции заключается в том, "
"что вам не нужно придумывать имя для функции, а это просто локальная "
"переменная, к которой относится объект функции (который представляет собой "
"объект точно такого же типа). что дает лямбда-выражение) присваивается!"

#: ../../faq/design.rst:327
msgid "Can Python be compiled to machine code, C or some other language?"
msgstr "Чи можна Python скомпілювати до машинного коду, мови C чи іншої?"

#: ../../faq/design.rst:329
msgid ""
"`Cython <https://cython.org/>`_ compiles a modified version of Python with "
"optional annotations into C extensions.  `Nuitka <https://www.nuitka.net/>`_ "
"is an up-and-coming compiler of Python into C++ code, aiming to support the "
"full Python language."
msgstr ""
"`Cython <https://cython.org/>`_ は オプションのアノテーション付きのPythonの修"
"正版を C拡張へ変換します。`Nuitka <https://www.nuitka.net/>`_ はPythonをC+"
"+コードへ変換する将来有望なPythonコンパイラで、完全なPython言語をサポートする"
"ことを目的としています。"

#: ../../faq/design.rst:336
msgid "How does Python manage memory?"
msgstr "Як Python керує пам'яттю?"

#: ../../faq/design.rst:338
msgid ""
"The details of Python memory management depend on the implementation.  The "
"standard implementation of Python, :term:`CPython`, uses reference counting "
"to detect inaccessible objects, and another mechanism to collect reference "
"cycles, periodically executing a cycle detection algorithm which looks for "
"inaccessible cycles and deletes the objects involved. The :mod:`gc` module "
"provides functions to perform a garbage collection, obtain debugging "
"statistics, and tune the collector's parameters."
msgstr ""
"Деталі керування пам’яттю Python залежать від реалізації. Стандартна "
"реалізація Python, :term:`CPython`, використовує підрахунок посилань для "
"виявлення недоступних об’єктів та інший механізм для збору посилальних "
"циклів, періодично виконуючи алгоритм виявлення циклів, який шукає "
"недоступні цикли та видаляє залучені об’єкти. Модуль :mod:`gc` надає функції "
"для збирання сміття, отримання статистики налагодження та налаштування "
"параметрів збирача."

#: ../../faq/design.rst:346
msgid ""
"Other implementations (such as `Jython <https://www.jython.org>`_ or `PyPy "
"<https://www.pypy.org>`_), however, can rely on a different mechanism such "
"as a full-blown garbage collector.  This difference can cause some subtle "
"porting problems if your Python code depends on the behavior of the "
"reference counting implementation."
msgstr ""
"ただし、他の実装 (例えば `Jython <https://www.jython.org>`_ や `PyPy "
"<https://www.pypy.org>`_) は本格的 (full-blown) なガベージコレクタのような別"
"のメカニズムに依存するかもしれません。あなたの Python コードが参照カウントの"
"実装の振る舞いに依存する場合、この違いが微妙な移植上の問題を引き起こすでしょ"
"う。"

#: ../../faq/design.rst:352
msgid ""
"In some Python implementations, the following code (which is fine in "
"CPython) will probably run out of file descriptors::"
msgstr ""
"У деяких реалізаціях Python наступний код (який добре процює у CPython), "
"ймовірно, не матиме файлових дескрипторів::"

#: ../../faq/design.rst:359
msgid ""
"Indeed, using CPython's reference counting and destructor scheme, each new "
"assignment to *f* closes the previous file.  With a traditional GC, however, "
"those file objects will only get collected (and closed) at varying and "
"possibly long intervals."
msgstr ""
"実際、CPython の参照カウントとデストラクタのスキームを使えば *f* への新しい代"
"入ごとにファイルは閉じられます。しかし、伝統的な GC を使うと、これらのファイ"
"ルオブジェクトが回収され (て閉じられる) までに不定な、場合によっては長い、間"
"隔が空くことがあります。"

#: ../../faq/design.rst:364
msgid ""
"If you want to write code that will work with any Python implementation, you "
"should explicitly close the file or use the :keyword:`with` statement; this "
"will work regardless of memory management scheme::"
msgstr ""
"Якщо ви хочете написати код, який працюватиме з будь-якою реалізацією "
"Python, вам слід явно закрити файл або використати оператор :keyword:`with`; "
"це працюватиме незалежно від схеми керування пам'яттю:"

#: ../../faq/design.rst:374
msgid "Why doesn't CPython use a more traditional garbage collection scheme?"
msgstr "Чому CPython не використовує більш традиційну схему збирання сміття?"

#: ../../faq/design.rst:376
msgid ""
"For one thing, this is not a C standard feature and hence it's not portable. "
"(Yes, we know about the Boehm GC library.  It has bits of assembler code for "
"*most* common platforms, not for all of them, and although it is mostly "
"transparent, it isn't completely transparent; patches are required to get "
"Python to work with it.)"
msgstr ""
"По-перше, це не є стандартною функцією C, а отже, вона не переносна. (Так, "
"ми знаємо про бібліотеку Boehm GC. Вона містить фрагменти коду асемблера для "
"*найбільш* поширених платформ, не для всіх, і хоча вона здебільшого прозора, "
"але  всеж таки не зовсім прозора; для Python потрібні патчи щоб  працювати з "
"нею.)"

#: ../../faq/design.rst:382
msgid ""
"Traditional GC also becomes a problem when Python is embedded into other "
"applications.  While in a standalone Python it's fine to replace the "
"standard malloc() and free() with versions provided by the GC library, an "
"application embedding Python may want to have its *own* substitute for "
"malloc() and free(), and may not want Python's.  Right now, CPython works "
"with anything that implements malloc() and free() properly."
msgstr ""
"伝統的な GC は Python が他のアプリケーションに組み込まれるときにも問題となり"
"ます。スタンドアロンの Python で動く限りでは、標準の malloc() と free() を "
"GC ライブラリから提供されるものに置き換えても問題ありませんが、Python を実装"
"したアプリケーションは Python のものではない *独自の* 代替品を使おうとするか"
"もしれません。現在のようにすることで、CPython は malloc() と free() が適切に"
"実装されている限りどんなものにも対応させられます。"

#: ../../faq/design.rst:391
msgid "Why isn't all memory freed when CPython exits?"
msgstr "Чому не вся пам'ять звільняється, коли CPython завершує роботу?"

#: ../../faq/design.rst:393
msgid ""
"Objects referenced from the global namespaces of Python modules are not "
"always deallocated when Python exits.  This may happen if there are circular "
"references.  There are also certain bits of memory that are allocated by the "
"C library that are impossible to free (e.g. a tool like Purify will complain "
"about these).  Python is, however, aggressive about cleaning up memory on "
"exit and does try to destroy every single object."
msgstr ""
"Об’єкти, на які посилаються глобальні простори імен модулів Python, не "
"завжди звільняються, коли Python завершує роботу. Це може статися, якщо є "
"циклічні посилання. Є також певні частини пам’яті, виділені бібліотекою C, "
"які неможливо звільнити (наприклад, такий інструмент, як Purify, буде "
"скаржитися на це). Однак Python агресивно очищає пам’ять під час виходу та "
"намагається знищити кожен окремий об’єкт."

#: ../../faq/design.rst:400
msgid ""
"If you want to force Python to delete certain things on deallocation use "
"the :mod:`atexit` module to run a function that will force those deletions."
msgstr ""
"Якщо ви хочете змусити Python видалити певні речі під час звільнення, "
"скористайтеся модулем :mod:`atexit`, щоб запустити функцію, яка примусово "
"прискорить ці видалення."

#: ../../faq/design.rst:405
msgid "Why are there separate tuple and list data types?"
msgstr "Чому існують окремі типи даних кортежу та списку?"

#: ../../faq/design.rst:407
msgid ""
"Lists and tuples, while similar in many respects, are generally used in "
"fundamentally different ways.  Tuples can be thought of as being similar to "
"Pascal records or C structs; they're small collections of related data which "
"may be of different types which are operated on as a group.  For example, a "
"Cartesian coordinate is appropriately represented as a tuple of two or three "
"numbers."
msgstr ""
"リストとタプルは、多くの点で似ていますが、一般には本質的に異なる方法で使われ"
"ます。タプルは、Pascal のレコードや C の構造体と同様なものと考えられます。型"
"が異なっても良い関連するデータの小さな集合で、グループとして演算されます。例"
"えば、デカルト座標は 2 つや 3 つの数のタプルとして適切に表せます。"

#: ../../faq/design.rst:414
msgid ""
"Lists, on the other hand, are more like arrays in other languages.  They "
"tend to hold a varying number of objects all of which have the same type and "
"which are operated on one-by-one.  For example, ``os.listdir('.')`` returns "
"a list of strings representing the files in the current directory.  "
"Functions which operate on this output would generally not break if you "
"added another file or two to the directory."
msgstr ""
"一方、リストは、もっと他の言語の配列に近いものです。全て同じ型の可変数のオブ"
"ジェクトを持ち、それらが一つ一つ演算される傾向にあります。例えば、 ``os."
"listdir('.')`` はカレントディレクトリ内にあるファイルの文字列表現のリストを返"
"します。この出力を演算する関数は一般に、ディレクトリに一つや二つの別のファイ"
"ルを加えても壊れません。"

#: ../../faq/design.rst:421
msgid ""
"Tuples are immutable, meaning that once a tuple has been created, you can't "
"replace any of its elements with a new value.  Lists are mutable, meaning "
"that you can always change a list's elements.  Only immutable elements can "
"be used as dictionary keys, and hence only tuples and not lists can be used "
"as keys."
msgstr ""
"Кортежі є незмінними, тобто після створення кортежу ви не можете замінити "
"жоден із його елементів новим значенням. Списки є змінними, тобто ви завжди "
"можете змінити елементи списку. Тільки незмінні елементи можна "
"використовувати як ключі словника, а отже, лише кортежі можна "
"використовувати як ключі, а списки не можна."

#: ../../faq/design.rst:428
msgid "How are lists implemented in CPython?"
msgstr "Як списки реалізовані в CPython?"

#: ../../faq/design.rst:430
msgid ""
"CPython's lists are really variable-length arrays, not Lisp-style linked "
"lists. The implementation uses a contiguous array of references to other "
"objects, and keeps a pointer to this array and the array's length in a list "
"head structure."
msgstr ""
"Списки CPython насправді є масивами змінної довжини, а не пов’язаними "
"списками як у стилі Lisp. Реалізація використовує безперервний масив "
"посилань на інші об’єкти та зберігає вказівник на цей масив і довжину масиву "
"в структурі заголовка списку."

#: ../../faq/design.rst:434
msgid ""
"This makes indexing a list ``a[i]`` an operation whose cost is independent "
"of the size of the list or the value of the index."
msgstr ""
"Це робить індексацію списку ``a[i]`` операцією, вартість якої не залежить "
"від розміру списку або значення індексу."

#: ../../faq/design.rst:437
msgid ""
"When items are appended or inserted, the array of references is resized.  "
"Some cleverness is applied to improve the performance of appending items "
"repeatedly; when the array must be grown, some extra space is allocated so "
"the next few times don't require an actual resize."
msgstr ""
"Коли елементи додаються або вставляються, розмір масиву посилань змінюється. "
"Деяка кмітливість застосована для покращення продуктивності багаторазового "
"додавання елементів; коли масив потрібно збільшити, виділяється додатковий "
"простір, тому наступні кілька разів не вимагають фактичної зміни розміру."

#: ../../faq/design.rst:444
msgid "How are dictionaries implemented in CPython?"
msgstr "Як реалізовані словники в CPython?"

#: ../../faq/design.rst:446
msgid ""
"CPython's dictionaries are implemented as resizable hash tables.  Compared "
"to B-trees, this gives better performance for lookup (the most common "
"operation by far) under most circumstances, and the implementation is "
"simpler."
msgstr ""
"Словники CPython реалізовані як хеш-таблиці зі змінним розміром. Порівняно з "
"B-деревами, це дає кращу продуктивність для пошуку (найпоширеніша операція "
"на сьогоднішній день) у більшості випадків, а реалізація є простішою."

#: ../../faq/design.rst:450
msgid ""
"Dictionaries work by computing a hash code for each key stored in the "
"dictionary using the :func:`hash` built-in function.  The hash code varies "
"widely depending on the key and a per-process seed; for example, \"Python\" "
"could hash to -539294296 while \"python\", a string that differs by a single "
"bit, could hash to 1142331976.  The hash code is then used to calculate a "
"location in an internal array where the value will be stored.  Assuming that "
"you're storing keys that all have different hash values, this means that "
"dictionaries take constant time -- *O*\\ (1), in Big-O notation -- to "
"retrieve a key."
msgstr ""

#: ../../faq/design.rst:461
msgid "Why must dictionary keys be immutable?"
msgstr "Чому ключі словника повинні бути незмінними?"

#: ../../faq/design.rst:463
msgid ""
"The hash table implementation of dictionaries uses a hash value calculated "
"from the key value to find the key.  If the key were a mutable object, its "
"value could change, and thus its hash could also change.  But since whoever "
"changes the key object can't tell that it was being used as a dictionary "
"key, it can't move the entry around in the dictionary.  Then, when you try "
"to look up the same object in the dictionary it won't be found because its "
"hash value is different. If you tried to look up the old value it wouldn't "
"be found either, because the value of the object found in that hash bin "
"would be different."
msgstr ""
"Реалізація хеш-таблиці словників використовує хеш-значення, обчислене зі "
"значення ключа, щоб знайти ключ. Якби ключ був змінним об’єктом, його "
"значення могло б змінитися, а отже, і його хеш також міг би змінитися. Але "
"оскільки той, хто змінює об’єкт ключа, не може сказати, що він "
"використовувався як ключ словника, він не може переміщувати запис у "
"словнику. Тоді, коли ви спробуєте знайти той самий об’єкт у словнику, він не "
"буде знайдений, оскільки його хеш-значення інше. Якщо ви спробуєте знайти "
"старе значення, його також не буде знайдено, оскільки значення об’єкта, "
"знайденого в цьому хеш-біні, буде іншим."

#: ../../faq/design.rst:472
msgid ""
"If you want a dictionary indexed with a list, simply convert the list to a "
"tuple first; the function ``tuple(L)`` creates a tuple with the same entries "
"as the list ``L``.  Tuples are immutable and can therefore be used as "
"dictionary keys."
msgstr ""
"Якщо ви хочете, щоб словник був індексований списком, просто спочатку "
"перетворіть список на кортеж; функція ``tuple(L)`` створює кортеж з тими "
"самими записами, що і список ``L``. Кортежі є незмінними, тому їх можна "
"використовувати як ключі словника."

#: ../../faq/design.rst:476
msgid "Some unacceptable solutions that have been proposed:"
msgstr "Деякі неприйнятні рішення, які були запропоновані:"

#: ../../faq/design.rst:478
msgid ""
"Hash lists by their address (object ID).  This doesn't work because if you "
"construct a new list with the same value it won't be found; e.g.::"
msgstr ""
"Хешувати списки за їхньою адресою (ID об'єкта). Це не працює, тому що якщо "
"ви створите новий список із тим самим значенням, його не буде знайдено; "
"наприклад::"

#: ../../faq/design.rst:484
msgid ""
"would raise a :exc:`KeyError` exception because the id of the ``[1, 2]`` "
"used in the second line differs from that in the first line.  In other "
"words, dictionary keys should be compared using ``==``, not using :keyword:"
"`is`."
msgstr ""
"викличе виняток :exc:`KeyError`, оскільки ідентифікатор ``[1, 2]``, який "
"використовується у другому рядку, відрізняється від ідентифікатора в першому "
"рядку. Іншими словами, ключі словника слід порівнювати за допомогою ``==``, "
"а не за допомогою :keyword:`is`."

#: ../../faq/design.rst:488
msgid ""
"Make a copy when using a list as a key.  This doesn't work because the list, "
"being a mutable object, could contain a reference to itself, and then the "
"copying code would run into an infinite loop."
msgstr ""
"Зробити копію, якщо використовуєте список як ключ. Це не працює, тому що "
"список, будучи змінним об’єктом, може містити посилання на себе, і тоді код "
"копіювання запускатиметься в нескінченний цикл."

#: ../../faq/design.rst:492
msgid ""
"Allow lists as keys but tell the user not to modify them.  This would allow "
"a class of hard-to-track bugs in programs when you forgot or modified a list "
"by accident. It also invalidates an important invariant of dictionaries: "
"every value in ``d.keys()`` is usable as a key of the dictionary."
msgstr ""
"Дозволити списки як ключі, але сказати користувачеві не змінювати їх. Це "
"дозволило б створити клас помилок, які важко відстежити в програмах, коли ви "
"випадково забули або змінили список. Це також робить недійсним важливий "
"інваріант словників: кожне значення в ``d.keys()`` можна використовувати як "
"ключ словника."

#: ../../faq/design.rst:497
msgid ""
"Mark lists as read-only once they are used as a dictionary key.  The problem "
"is that it's not just the top-level object that could change its value; you "
"could use a tuple containing a list as a key.  Entering anything as a key "
"into a dictionary would require marking all objects reachable from there as "
"read-only -- and again, self-referential objects could cause an infinite "
"loop."
msgstr ""
"Позначайте списки як доступні лише для читання, коли вони використовуються "
"як ключ словника. Проблема полягає в тому, що не лише об’єкт верхнього рівня "
"може змінити своє значення; ви можете використовувати кортеж, що містить "
"список, як ключ. Введення будь-чого як ключа до словника вимагало б "
"позначити всі доступні звідти об’єкти як доступні лише для читання – і знову "
"ж таки самопосилання на об’єкти могло б спричинити нескінченний цикл."

#: ../../faq/design.rst:503
msgid ""
"There is a trick to get around this if you need to, but use it at your own "
"risk: You can wrap a mutable structure inside a class instance which has "
"both a :meth:`__eq__` and a :meth:`__hash__` method.  You must then make "
"sure that the hash value for all such wrapper objects that reside in a "
"dictionary (or other hash based structure), remain fixed while the object is "
"in the dictionary (or other structure). ::"
msgstr ""
"必要ならばこれを回避する方法がありますが、自己責任のもとで行ってください。"
"ミュータブルな構造を、 :meth:`__eq__` と :meth:`__hash__` メソッドの両方を持"
"つクラスインスタンスに含めることができます。その時、辞書 (またはハッシュに基"
"づく別の構造体) に属するような全てのラッパーオブジェクトのハッシュ値が、その"
"オブジェクトが辞書 (その他の構造体) 中にある間固定され続けることを確実にして"
"ください。 ::"

#: ../../faq/design.rst:527
msgid ""
"Note that the hash computation is complicated by the possibility that some "
"members of the list may be unhashable and also by the possibility of "
"arithmetic overflow."
msgstr ""
"Зверніть увагу, що обчислення хешу ускладнюється можливістю того, що деякі "
"члени списку можуть бути нехешованими, а також можливістю арифметичного "
"переповнення."

#: ../../faq/design.rst:531
msgid ""
"Furthermore it must always be the case that if ``o1 == o2`` (ie ``o1."
"__eq__(o2) is True``) then ``hash(o1) == hash(o2)`` (ie, ``o1.__hash__() == "
"o2.__hash__()``), regardless of whether the object is in a dictionary or "
"not.  If you fail to meet these restrictions dictionaries and other hash "
"based structures will misbehave."
msgstr ""
"Крім того, завжди має бути так, що якщо ``o1 == o2`` (тобто ``o1.__eq__(o2) "
"має значення True``), тоді ``hash(o1) == hash(o2)`` (тобто, ``o1.__hash__() "
"== o2.__hash__()``), незалежно від того, чи є об’єкт у словнику чи ні. Якщо "
"ви не впораєтеся з цими обмеженнями, словники та інші хеш-структури "
"працюватимуть неправильно."

#: ../../faq/design.rst:536
msgid ""
"In the case of ListWrapper, whenever the wrapper object is in a dictionary "
"the wrapped list must not change to avoid anomalies.  Don't do this unless "
"you are prepared to think hard about the requirements and the consequences "
"of not meeting them correctly.  Consider yourself warned."
msgstr ""
"この ListWrapper の例では、異常を避けるため、ラッパオブジェクトが辞書内にある"
"限りラップされたリストが変更されてはなりません。この条件と満たせなかった時の"
"結果について知恵を絞る覚悟がない限り、これをしてはいけません。よく考えてくだ"
"さい。"

#: ../../faq/design.rst:543
msgid "Why doesn't list.sort() return the sorted list?"
msgstr "Чому list.sort() не повертає відсортований список?"

#: ../../faq/design.rst:545
msgid ""
"In situations where performance matters, making a copy of the list just to "
"sort it would be wasteful. Therefore, :meth:`list.sort` sorts the list in "
"place. In order to remind you of that fact, it does not return the sorted "
"list.  This way, you won't be fooled into accidentally overwriting a list "
"when you need a sorted copy but also need to keep the unsorted version "
"around."
msgstr ""
"У ситуаціях, коли продуктивність має значення, створення копії списку лише "
"для його сортування було б марним. Тому :meth:`list.sort` сортує список за "
"місцем. Щоб нагадати вам про цей факт, він не повертає відсортований список. "
"Таким чином, вас не введуть в оману випадковим перезаписом списку, коли вам "
"потрібна відсортована копія, але також потрібно зберегти невідсортовану "
"версію."

#: ../../faq/design.rst:551
msgid ""
"If you want to return a new list, use the built-in :func:`sorted` function "
"instead.  This function creates a new list from a provided iterable, sorts "
"it and returns it.  For example, here's how to iterate over the keys of a "
"dictionary in sorted order::"
msgstr ""
"Якщо ви хочете повернути новий список, скористайтеся вбудованою функцією :"
"func:`sorted`. Ця функція створює новий список із наданого ітератора, сортує "
"його та повертає. Наприклад, ось як виконати ітерацію по ключах словника у "
"відсортованому порядку:"

#: ../../faq/design.rst:561
msgid "How do you specify and enforce an interface spec in Python?"
msgstr "Як визначити та застосувати специфікацію інтерфейсу в Python?"

#: ../../faq/design.rst:563
msgid ""
"An interface specification for a module as provided by languages such as C++ "
"and Java describes the prototypes for the methods and functions of the "
"module.  Many feel that compile-time enforcement of interface specifications "
"helps in the construction of large programs."
msgstr ""
"Специфікація інтерфейсу для модуля, яка надається такими мовами, як C++ і "
"Java, описує прототипи методів і функцій модуля. Багато хто вважає, що "
"примусове виконання специфікацій інтерфейсу під час компіляції допомагає "
"створювати великі програми."

#: ../../faq/design.rst:568
msgid ""
"Python 2.6 adds an :mod:`abc` module that lets you define Abstract Base "
"Classes (ABCs).  You can then use :func:`isinstance` and :func:`issubclass` "
"to check whether an instance or a class implements a particular ABC.  The :"
"mod:`collections.abc` module defines a set of useful ABCs such as :class:"
"`~collections.abc.Iterable`, :class:`~collections.abc.Container`, and :class:"
"`~collections.abc.MutableMapping`."
msgstr ""
"Python 2.6 додає модуль :mod:`abc`, який дозволяє визначати абстрактні "
"базові класи (ABC - Abstract Base Classes ). Потім ви можете "
"використовувати :func:`isinstance` і :func:`issubclass`, щоб перевірити, чи "
"екземпляр або клас певного ABC їх реалізує. Модуль :mod:`collections.abc` "
"визначає набір корисних ABC, таких як :class:`~collections.abc.Iterable`, :"
"class:`~collections.abc.Container` і :class:`~collections. abc."
"MutableMapping`."

#: ../../faq/design.rst:575
msgid ""
"For Python, many of the advantages of interface specifications can be "
"obtained by an appropriate test discipline for components."
msgstr ""
"Для Python багато переваг специфікацій інтерфейсу можна отримати за "
"допомогою відповідного порядку тестування компонентів."

#: ../../faq/design.rst:578
msgid ""
"A good test suite for a module can both provide a regression test and serve "
"as a module interface specification and a set of examples.  Many Python "
"modules can be run as a script to provide a simple \"self test.\"  Even "
"modules which use complex external interfaces can often be tested in "
"isolation using trivial \"stub\" emulations of the external interface.  The :"
"mod:`doctest` and :mod:`unittest` modules or third-party test frameworks can "
"be used to construct exhaustive test suites that exercise every line of code "
"in a module."
msgstr ""
"Хороший набір тестів для модуля може як забезпечити регресійний тест, так і "
"служити специфікацією інтерфейсу модуля та набором прикладів. Багато модулів "
"Python можна запускати як сценарій для забезпечення простого "
"\"самотестування\". Навіть модулі, які використовують складні зовнішні "
"інтерфейси, часто можуть бути протестовані ізольовано за допомогою "
"тривіальних \"заглушок\" емуляції зовнішнього інтерфейсу. Модулі :mod:"
"`doctest` і :mod:`unittest` або сторонні фреймворки тестування можна "
"використовувати для створення вичерпних наборів тестів, які перевіряють "
"кожен рядок коду в модулі."

#: ../../faq/design.rst:586
msgid ""
"An appropriate testing discipline can help build large complex applications "
"in Python as well as having interface specifications would.  In fact, it can "
"be better because an interface specification cannot test certain properties "
"of a program.  For example, the :meth:`!list.append` method is expected to "
"add new elements to the end of some internal list; an interface "
"specification cannot test that your :meth:`!list.append` implementation will "
"actually do this correctly, but it's trivial to check this property in a "
"test suite."
msgstr ""
"Соответствующая дисциплина тестирования может помочь создавать большие "
"сложные приложения на Python, а также иметь спецификации интерфейса. На "
"самом деле, это может быть лучше, поскольку спецификация интерфейса не может "
"проверять определенные свойства программы. Например, ожидается, что метод :"
"meth:`!list.append` добавит новые элементы в конец некоторого внутреннего "
"списка; спецификация интерфейса не может проверить, что ваша реализация :"
"meth:`!list.append` действительно сделает это правильно, но проверить это "
"свойство в наборе тестов очень просто."

#: ../../faq/design.rst:594
msgid ""
"Writing test suites is very helpful, and you might want to design your code "
"to make it easily tested. One increasingly popular technique, test-driven "
"development, calls for writing parts of the test suite first, before you "
"write any of the actual code.  Of course Python allows you to be sloppy and "
"not write test cases at all."
msgstr ""
"Написання наборів тестів дуже корисно, і ви можете розробити свій код, щоб "
"його було легко перевірити. Одна з технік, що стає все більш популярною, — "
"розробка на основі тестування (TDD - test-driven development)— вимагає "
"спочатку написати частини набору тестів, перш ніж писати будь-який фактичний "
"код. Звичайно, Python дозволяє вам бути неохайними і взагалі не писати тести."

#: ../../faq/design.rst:602
msgid "Why is there no goto?"
msgstr "Чому немає goto?"

#: ../../faq/design.rst:604
msgid ""
"In the 1970s people realized that unrestricted goto could lead to messy "
"\"spaghetti\" code that was hard to understand and revise. In a high-level "
"language, it is also unneeded as long as there are ways to branch (in "
"Python, with ``if`` statements and ``or``, ``and``, and ``if-else`` "
"expressions) and loop (with ``while`` and ``for`` statements, possibly "
"containing ``continue`` and ``break``)."
msgstr ""
"1970年代、人々は気付きました。秩序なき goto は、理解するのも手直しするのも困"
"難という厄介な\"スパゲッティ\"コードに陥りがちであると。\n"
"高水準言語では、分岐とループの手段があれば goto は不要です。\n"
"(Pythonだと、分岐には ``if`` 節及び ``or`` ・ ``and`` ・ ``if-else`` 式を使い"
"ます。ループには ``while`` 節と ``for`` 節を使い、 ループ内に ``continue`` "
"・ ``break`` を含むことがあります)"

#: ../../faq/design.rst:611
msgid ""
"One can also use exceptions to provide a \"structured goto\" that works even "
"across function calls.  Many feel that exceptions can conveniently emulate "
"all reasonable uses of the \"go\" or \"goto\" constructs of C, Fortran, and "
"other languages.  For example::"
msgstr ""
"関数の呼び出しをまたいでも動作する \"構造化された goto\" をまかなうものとして"
"例外を使えます。C、Fortran、その他の言語での \"go\" あるいは \"goto\" 構造の"
"適切な用途は全て、例外で同じようなことをすれば便利であると、広く感じられてい"
"ます。例えば::"

#: ../../faq/design.rst:627
msgid ""
"This doesn't allow you to jump into the middle of a loop, but that's usually "
"considered an abuse of goto anyway.  Use sparingly."
msgstr ""
"例外ではループ内へ跳ぶことはできませんが、どちらにしてもそれは goto の乱用と"
"見なされるものです。使うのは控えてください。"

#: ../../faq/design.rst:632
msgid "Why can't raw strings (r-strings) end with a backslash?"
msgstr ""
"Чому необроблені рядки (r-рядки) не можуть закінчуватися зворотною косою "
"рискою?"

#: ../../faq/design.rst:634
msgid ""
"More precisely, they can't end with an odd number of backslashes: the "
"unpaired backslash at the end escapes the closing quote character, leaving "
"an unterminated string."
msgstr ""
"Точніше, вони не можуть закінчуватися непарною кількістю зворотних скісних "
"рисок: непарна зворотна коса риска в кінці виходить із символу закриваючої "
"лапки, залишаючи незакінчений рядок."

#: ../../faq/design.rst:638
msgid ""
"Raw strings were designed to ease creating input for processors (chiefly "
"regular expression engines) that want to do their own backslash escape "
"processing. Such processors consider an unmatched trailing backslash to be "
"an error anyway, so raw strings disallow that.  In return, they allow you to "
"pass on the string quote character by escaping it with a backslash.  These "
"rules work well when r-strings are used for their intended purpose."
msgstr ""
"Необроблені рядки були розроблені, щоб полегшити створення вхідних даних для "
"процесорів (головним чином механізмів регулярних виразів), які хочуть "
"виконувати власну обробку зворотного слеша. Такі процесори в будь-якому "
"випадку вважають невідповідну зворотну косу риску в кінці помилкою, тому "
"необроблені рядки це забороняють. Натомість вони дозволяють вам передати "
"символ лапки рядка, екрануючи його зворотною косою рискою. Ці правила добре "
"працюють, коли r-рядки використовуються за призначенням."

#: ../../faq/design.rst:645
msgid ""
"If you're trying to build Windows pathnames, note that all Windows system "
"calls accept forward slashes too::"
msgstr ""
"Якщо ви намагаєтеся створити імена шляхів Windows, зверніть увагу, що всі "
"системні виклики Windows також приймають косу риску::"

#: ../../faq/design.rst:650
msgid ""
"If you're trying to build a pathname for a DOS command, try e.g. one of ::"
msgstr ""
"Якщо ви намагаєтеся створити шлях для команди DOS, спробуйте, наприклад. "
"один з ::"

#: ../../faq/design.rst:658
msgid "Why doesn't Python have a \"with\" statement for attribute assignments?"
msgstr "Чому в Python немає оператора \"with\" для призначення атрибутів?"

#: ../../faq/design.rst:660
msgid ""
"Python has a 'with' statement that wraps the execution of a block, calling "
"code on the entrance and exit from the block.  Some languages have a "
"construct that looks like this::"
msgstr ""
"Python には、ブロックの実行を包む 'with' 文があり、ブロックに入るときとブロッ"
"クから出るときに、コードを呼び出します。以下のような構造を持つ言語がありま"
"す::"

#: ../../faq/design.rst:668
msgid "In Python, such a construct would be ambiguous."
msgstr "У Python така конструкція була б неоднозначною."

#: ../../faq/design.rst:670
msgid ""
"Other languages, such as Object Pascal, Delphi, and C++, use static types, "
"so it's possible to know, in an unambiguous way, what member is being "
"assigned to. This is the main point of static typing -- the compiler "
"*always* knows the scope of every variable at compile time."
msgstr ""
"Інші мови, такі як Object Pascal, Delphi та C++, використовують статичні "
"типи, тому можна однозначно знати, якому члену призначено. Це головний "
"момент статичної типізації -- компілятор *завжди* знає область кожної "
"змінної під час компіляції."

#: ../../faq/design.rst:675
msgid ""
"Python uses dynamic types. It is impossible to know in advance which "
"attribute will be referenced at runtime. Member attributes may be added or "
"removed from objects on the fly. This makes it impossible to know, from a "
"simple reading, what attribute is being referenced: a local one, a global "
"one, or a member attribute?"
msgstr ""
"Python використовує динамічні типи. Неможливо знати заздалегідь, на який "
"атрибут буде посилатися під час виконання. Атрибути учасників можна додавати "
"або видаляти з об’єктів на льоту. Це робить неможливим з простого читання "
"дізнатися, на який атрибут посилається: локальний, глобальний чи атрибут-"
"член?"

#: ../../faq/design.rst:681
msgid "For instance, take the following incomplete snippet::"
msgstr "Наприклад, візьмемо наступний неповний фрагмент:"

#: ../../faq/design.rst:687
msgid ""
"The snippet assumes that \"a\" must have a member attribute called \"x\".  "
"However, there is nothing in Python that tells the interpreter this. What "
"should happen if \"a\" is, let us say, an integer?  If there is a global "
"variable named \"x\", will it be used inside the with block?  As you see, "
"the dynamic nature of Python makes such choices much harder."
msgstr ""
"このコード片では、\"a\" は \"x\" というメンバ属性を持っていると仮定されていま"
"す。しかし、Python ではインタプリタにはこの仮定を伝えられる仕組みはありませ"
"ん。 \"a\" が、例えば整数だったら、どうなってしまうでしょうか。 \"x\" という"
"名前のグローバル変数があったら、それが with ブロックの中で使われるのでしょう"
"か。この通り、Python の動的な特質から、このような選択はとても難しい物になって"
"います。"

#: ../../faq/design.rst:693
msgid ""
"The primary benefit of \"with\" and similar language features (reduction of "
"code volume) can, however, easily be achieved in Python by assignment.  "
"Instead of::"
msgstr ""
"しかし、\"with\" やそれに類する言語の機能の一番の利点 (コード量の削減) は、 "
"Python では代入により簡単に手に入れられます::"

#: ../../faq/design.rst:700
msgid "write this::"
msgstr "напиши це::"

#: ../../faq/design.rst:707
msgid ""
"This also has the side-effect of increasing execution speed because name "
"bindings are resolved at run-time in Python, and the second version only "
"needs to perform the resolution once."
msgstr ""
"Це також має побічний ефект збільшення швидкості виконання, оскільки "
"прив’язки імен вирішуються під час виконання в Python, а другій версії "
"потрібно виконати розв’язання лише один раз."

#: ../../faq/design.rst:713
msgid "Why don't generators support the with statement?"
msgstr "Чому генератори не підтримують оператор with?"

#: ../../faq/design.rst:715
msgid ""
"For technical reasons, a generator used directly as a context manager would "
"not work correctly.  When, as is most common, a generator is used as an "
"iterator run to completion, no closing is needed.  When it is, wrap it as "
"\"contextlib.closing(generator)\" in the 'with' statement."
msgstr ""

#: ../../faq/design.rst:722
msgid "Why are colons required for the if/while/def/class statements?"
msgstr "Чому в операторах if/while/def/class потрібні двокрапки?"

#: ../../faq/design.rst:724
msgid ""
"The colon is required primarily to enhance readability (one of the results "
"of the experimental ABC language).  Consider this::"
msgstr ""
"Двокрапка потрібна насамперед для покращення читабельності (один із "
"результатів експериментальної мови ABC). Розглянемо це::"

#: ../../faq/design.rst:730
msgid "versus ::"
msgstr "проти ::"

#: ../../faq/design.rst:735
msgid ""
"Notice how the second one is slightly easier to read.  Notice further how a "
"colon sets off the example in this FAQ answer; it's a standard usage in "
"English."
msgstr ""
"Зверніть увагу, що другий читається трохи легше. Зверніть увагу на те, як "
"двокрапка виділяє приклад у цій відповіді на поширені запитання; це "
"стандартне використання в англійській мові."

#: ../../faq/design.rst:738
msgid ""
"Another minor reason is that the colon makes it easier for editors with "
"syntax highlighting; they can look for colons to decide when indentation "
"needs to be increased instead of having to do a more elaborate parsing of "
"the program text."
msgstr ""
"Інша незначна причина полягає в тому, що двокрапка полегшує роботу "
"редакторів із підсвічуванням синтаксису; вони можуть шукати двокрапки, щоб "
"вирішити, коли потрібно збільшити відступ, замість того, щоб виконувати "
"більш детальний розбір тексту програми."

#: ../../faq/design.rst:744
msgid "Why does Python allow commas at the end of lists and tuples?"
msgstr "Чому Python допускає коми в кінці списків і кортежів?"

#: ../../faq/design.rst:746
msgid ""
"Python lets you add a trailing comma at the end of lists, tuples, and "
"dictionaries::"
msgstr ""
"Python дозволяє додавати кінцеву кому в кінці списків, кортежів і словників:"

#: ../../faq/design.rst:757
msgid "There are several reasons to allow this."
msgstr "Es gint mehrere Gründe dies zu erlauben."

#: ../../faq/design.rst:759
msgid ""
"When you have a literal value for a list, tuple, or dictionary spread across "
"multiple lines, it's easier to add more elements because you don't have to "
"remember to add a comma to the previous line.  The lines can also be "
"reordered without creating a syntax error."
msgstr ""
"Коли у вас є літеральне значення для списку, кортежу чи словника, "
"розкиданого на кілька рядків, легше додати більше елементів, оскільки вам не "
"потрібно пам’ятати про додавання коми в попередній рядок. Рядки також можна "
"змінити, не створюючи синтаксичних помилок."

#: ../../faq/design.rst:764
msgid ""
"Accidentally omitting the comma can lead to errors that are hard to "
"diagnose. For example::"
msgstr ""
"Випадковий пропуск коми може призвести до помилок, які важко діагностувати. "
"Наприклад::"

#: ../../faq/design.rst:774
msgid ""
"This list looks like it has four elements, but it actually contains three: "
"\"fee\", \"fiefoo\" and \"fum\".  Always adding the comma avoids this source "
"of error."
msgstr ""
"Цей список виглядає так, ніби він складається з чотирьох елементів, але "
"насправді він містить три: \"fee\", \"fiefoo\" і \"fum\". Постійне додавання "
"коми дозволяє уникнути цього джерела помилки."

#: ../../faq/design.rst:777
msgid ""
"Allowing the trailing comma may also make programmatic code generation "
"easier."
msgstr "Дозвіл кінцевої коми також може полегшити генерацію програмного коду."
