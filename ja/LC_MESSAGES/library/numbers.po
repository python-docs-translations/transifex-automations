# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-18 17:29+0000\n"
"PO-Revision-Date: 2023-05-24 02:18+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Japanese (https://app.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/numbers.rst:2
msgid ":mod:`numbers` --- Numeric abstract base classes"
msgstr ":mod:`numbers` --- 数の抽象基底クラス"

#: ../../library/numbers.rst:7
msgid "**Source code:** :source:`Lib/numbers.py`"
msgstr "**Вихідний код:** :source:`Lib/numbers.py`"

#: ../../library/numbers.rst:11
msgid ""
"The :mod:`!numbers` module (:pep:`3141`) defines a hierarchy of numeric :"
"term:`abstract base classes <abstract base class>` which progressively "
"define more operations.  None of the types defined in this module are "
"intended to be instantiated."
msgstr ""
"Модуль :mod:`!numbers` (:pep:`3141`) определяет иерархию числовых :term:"
"`абстрактных базовых классов <абстрактный базовый класс>`, которые "
"постепенно определяют больше операций. Ни один из типов, определенных в этом "
"модуле, не предназначен для создания экземпляров."

#: ../../library/numbers.rst:18
msgid ""
"The root of the numeric hierarchy. If you just want to check if an argument "
"*x* is a number, without caring what kind, use ``isinstance(x, Number)``."
msgstr ""
"Корінь числової ієрархії. Якщо ви просто хочете перевірити, чи є аргумент "
"*x* числом, не звертаючи уваги на те, якого типу, використовуйте "
"``isinstance(x, Number)``."

#: ../../library/numbers.rst:23
msgid "The numeric tower"
msgstr "Числова вежа"

#: ../../library/numbers.rst:27
msgid ""
"Subclasses of this type describe complex numbers and include the operations "
"that work on the built-in :class:`complex` type. These are: conversions to :"
"class:`complex` and :class:`bool`, :attr:`.real`, :attr:`.imag`, ``+``, ``-"
"``, ``*``, ``/``, ``**``, :func:`abs`, :meth:`conjugate`, ``==``, and ``!"
"=``. All except ``-`` and ``!=`` are abstract."
msgstr ""
"Підкласи цього типу описують комплексні числа та включають операції, які "
"працюють із вбудованим типом :class:`complex`. Це: перетворення на :class:"
"`complex` і :class:`bool`, :attr:`.real`, :attr:`.imag`, ``+``, ``-``, "
"``*``, ``/``, ``**``, :func:`abs`, :meth:`conjugate`, ``==`` і ``!=``. Усі, "
"крім ``-`` і ``!=``, є абстрактними."

#: ../../library/numbers.rst:35
msgid "Abstract. Retrieves the real component of this number."
msgstr "Анотація. Отримує дійсний компонент цього числа."

#: ../../library/numbers.rst:39
msgid "Abstract. Retrieves the imaginary component of this number."
msgstr "Анотація. Отримує уявний компонент цього числа."

#: ../../library/numbers.rst:43
msgid ""
"Abstract. Returns the complex conjugate. For example, ``(1+3j).conjugate() "
"== (1-3j)``."
msgstr ""
"Анотація. Повертає комплексне сполучення. Наприклад, ``(1+3j).conjugate() == "
"(1-3j)``."

#: ../../library/numbers.rst:48
msgid ""
"To :class:`Complex`, :class:`!Real` adds the operations that work on real "
"numbers."
msgstr ""
"К :class:`Complex`, :class:`!Real` добавляются операции, которые работают с "
"действительными числами."

#: ../../library/numbers.rst:51
msgid ""
"In short, those are: a conversion to :class:`float`, :func:`math.trunc`, :"
"func:`round`, :func:`math.floor`, :func:`math.ceil`, :func:`divmod`, ``//``, "
"``%``, ``<``, ``<=``, ``>``, and ``>=``."
msgstr ""
"Якщо коротко, це: перетворення на :class:`float`, :func:`math.trunc`, :func:"
"`round`, :func:`math.floor`, :func:`math.ceil`, :func:`divmod`, ``//``, "
"``%``, ``<``, ``<=``, ``>`` і ``>=``."

#: ../../library/numbers.rst:55
msgid ""
"Real also provides defaults for :func:`complex`, :attr:`~Complex.real`, :"
"attr:`~Complex.imag`, and :meth:`~Complex.conjugate`."
msgstr ""
"Real також надає значення за замовчуванням для :func:`complex`, :attr:"
"`~Complex.real`, :attr:`~Complex.imag` і :meth:`~Complex.conjugate`."

#: ../../library/numbers.rst:61
msgid ""
"Subtypes :class:`Real` and adds :attr:`~Rational.numerator` and :attr:"
"`~Rational.denominator` properties. It also provides a default for :func:"
"`float`."
msgstr ""
"Подтипы :class:`Real` и добавляют свойства :attr:`~Rational.numerator` и :"
"attr:`~Rational.denominator`. Он также предоставляет значение по умолчанию "
"для :func:`float`."

#: ../../library/numbers.rst:65
msgid ""
"The :attr:`~Rational.numerator` and :attr:`~Rational.denominator` values "
"should be instances of :class:`Integral` and should be in lowest terms with :"
"attr:`~Rational.denominator` positive."
msgstr ""
"Значения :attr:`~Rational.numerator` и :attr:`~Rational.denominator` должны "
"быть экземплярами :class:`Integral` и в наименьших терминах должны быть "
"положительными."

#: ../../library/numbers.rst:71 ../../library/numbers.rst:75
msgid "Abstract."
msgstr "Анотація."

#: ../../library/numbers.rst:80
msgid ""
"Subtypes :class:`Rational` and adds a conversion to :class:`int`.  Provides "
"defaults for :func:`float`, :attr:`~Rational.numerator`, and :attr:"
"`~Rational.denominator`.  Adds abstract methods for :func:`pow` with modulus "
"and bit-string operations: ``<<``, ``>>``, ``&``, ``^``, ``|``, ``~``."
msgstr ""
"Підтипує :class:`Rational` і додає перетворення до :class:`int`. Надає "
"значення за замовчуванням для :func:`float`, :attr:`~Rational.numerator` і :"
"attr:`~Rational.denominator`. Додає абстрактні методи для :func:`pow` з "
"операціями модуля та бітового рядка: ``<<``, ``>>``, ``&``, ``^``, ``|``, "
"``~``."

#: ../../library/numbers.rst:88
msgid "Notes for type implementors"
msgstr "型実装者のための注意事項"

#: ../../library/numbers.rst:90
msgid ""
"Implementors should be careful to make equal numbers equal and hash them to "
"the same values. This may be subtle if there are two different extensions of "
"the real numbers. For example, :class:`fractions.Fraction` implements :func:"
"`hash` as follows::"
msgstr ""
"実装する人は等しい数が等しく扱われるように同じハッシュを与えるように気を付け"
"ねばなりません。これは二つの異なった実数の拡張があるような場合にはややこしい"
"ことになるかもしれません。たとえば、 :class:`fractions.Fraction` は :func:"
"`hash` を以下のように実装しています::"

#: ../../library/numbers.rst:109
msgid "Adding More Numeric ABCs"
msgstr "Додавання додаткових числових букв"

#: ../../library/numbers.rst:111
msgid ""
"There are, of course, more possible ABCs for numbers, and this would be a "
"poor hierarchy if it precluded the possibility of adding those. You can add "
"``MyFoo`` between :class:`Complex` and :class:`Real` with::"
msgstr ""
"Звичайно, існує більше можливих азбуки для чисел, і це була б погана "
"ієрархія, якби вона виключала можливість їх додавання. Ви можете додати "
"``MyFoo`` між :class:`Complex` і :class:`Real` за допомогою::"

#: ../../library/numbers.rst:123
msgid "Implementing the arithmetic operations"
msgstr "Реалізація арифметичних дій"

#: ../../library/numbers.rst:125
msgid ""
"We want to implement the arithmetic operations so that mixed-mode operations "
"either call an implementation whose author knew about the types of both "
"arguments, or convert both to the nearest built in type and do the operation "
"there. For subtypes of :class:`Integral`, this means that :meth:`~object."
"__add__` and :meth:`~object.__radd__` should be defined as::"
msgstr ""
"Мы хотим реализовать арифметические операции так, чтобы операции смешанного "
"режима либо вызывали реализацию, автор которой знал о типах обоих "
"аргументов, либо конвертировали оба типа в ближайший встроенный тип и "
"выполняли операцию там. Для подтипов :class:`Integral` это означает, что :"
"meth:`~object.__add__` и :meth:`~object.__radd__` должны быть определены "
"как::"

#: ../../library/numbers.rst:157
msgid ""
"There are 5 different cases for a mixed-type operation on subclasses of :"
"class:`Complex`. I'll refer to all of the above code that doesn't refer to "
"``MyIntegral`` and ``OtherTypeIKnowAbout`` as \"boilerplate\". ``a`` will be "
"an instance of ``A``, which is a subtype of :class:`Complex` (``a : A <: "
"Complex``), and ``b : B <: Complex``. I'll consider ``a + b``:"
msgstr ""
"Є 5 різних випадків для операції змішаного типу над підкласами :class:"
"`Complex`. Я буду називати весь наведений вище код, який не посилається на "
"``MyIntegral`` і ``OtherTypeIKnowAbout``, як \"шаблонний\". ``a`` буде "
"екземпляром ``A``, який є підтипом :class:`Complex` (``a : A <: Complex``), "
"і ``b : B <: Complex``. Я розглядаю ``a + b``:"

#: ../../library/numbers.rst:164
msgid ""
"If ``A`` defines an :meth:`~object.__add__` which accepts ``b``, all is well."
msgstr ""
"Если ``A`` определяет :meth:`~object.__add__`, который принимает ``b``, все "
"в порядке."

#: ../../library/numbers.rst:166
msgid ""
"If ``A`` falls back to the boilerplate code, and it were to return a value "
"from :meth:`~object.__add__`, we'd miss the possibility that ``B`` defines a "
"more intelligent :meth:`~object.__radd__`, so the boilerplate should return :"
"data:`NotImplemented` from :meth:`!__add__`. (Or ``A`` may not implement :"
"meth:`!__add__` at all.)"
msgstr ""
"Если ``A`` вернется к шаблонному коду и будет возвращать значение из :meth:"
"`~object.__add__`, мы упустим возможность того, что ``B`` определяет более "
"интеллектуальный :meth: `~object.__radd__`, поэтому шаблон должен "
"возвращать :data:`NotImplemented` из :meth:`!__add__`. (Или ``A`` может "
"вообще не реализовывать :meth:`!__add__`.)"

#: ../../library/numbers.rst:172
msgid ""
"Then ``B``'s :meth:`~object.__radd__` gets a chance. If it accepts ``a``, "
"all is well."
msgstr ""
"Тогда :meth:`~object.__radd__` ``B`` получает шанс. Если он принимает ``a``, "
"все в порядке."

#: ../../library/numbers.rst:174
msgid ""
"If it falls back to the boilerplate, there are no more possible methods to "
"try, so this is where the default implementation should live."
msgstr ""
"Якщо він повернеться до шаблону, більше не буде можливих методів, які можна "
"спробувати, тому тут має бути реалізація за замовчуванням."

#: ../../library/numbers.rst:177
msgid ""
"If ``B <: A``, Python tries ``B.__radd__`` before ``A.__add__``. This is ok, "
"because it was implemented with knowledge of ``A``, so it can handle those "
"instances before delegating to :class:`Complex`."
msgstr ""
"Якщо ``B <: A``, Python намагається ``B.__radd__`` перед ``A.__add__``. Це "
"нормально, тому що його було реалізовано зі знанням ``A``, тому він може "
"обробити ці випадки перед делегуванням :class:`Complex`."

#: ../../library/numbers.rst:182
msgid ""
"If ``A <: Complex`` and ``B <: Real`` without sharing any other knowledge, "
"then the appropriate shared operation is the one involving the built in :"
"class:`complex`, and both :meth:`~object.__radd__` s land there, so ``a+b == "
"b+a``."
msgstr ""
"Если ``A <: Complex`` и ``B <: Real`` без совместного использования каких-"
"либо других знаний, то подходящей общей операцией является та, которая "
"включает встроенный :class:`complex`, и обе :meth:`~ object.__radd__` "
"приземляется там, поэтому ``a+b == b+a``."

#: ../../library/numbers.rst:187
msgid ""
"Because most of the operations on any given type will be very similar, it "
"can be useful to define a helper function which generates the forward and "
"reverse instances of any given operator. For example, :class:`fractions."
"Fraction` uses::"
msgstr ""
"Оскільки більшість операцій над будь-яким заданим типом будуть дуже схожими, "
"може бути корисним визначити допоміжну функцію, яка генерує прямі та "
"зворотні екземпляри будь-якого даного оператора. Наприклад, :class:"
"`fractions.Fraction` використовує::"
