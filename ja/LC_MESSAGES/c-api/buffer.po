# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2026, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-05 16:37+0000\n"
"PO-Revision-Date: 2025-09-22 16:49+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Japanese (https://app.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../c-api/buffer.rst:11
msgid "Buffer Protocol"
msgstr "バッファ プロトコル"

#: ../../c-api/buffer.rst:18
msgid ""
"Certain objects available in Python wrap access to an underlying memory "
"array or *buffer*.  Such objects include the built-in :class:`bytes` and :"
"class:`bytearray`, and some extension types like :class:`array.array`. Third-"
"party libraries may define their own types for special purposes, such as "
"image processing or numeric analysis."
msgstr ""
"Pythonで利用可能な特定のオブジェクトは、アクセスをラップしています ～へ 根底 "
"メモリ配列または*バッファ* 。このようなオブジェクトには、組み込みの :class:"
"`bytes` そして :class:`bytearray`, および一部の拡張子タイプのような :class:"
"`array.array`. サードパーティ ライブラリ 特別な目的 例えば画像処理や数値解析"
"など のために、独自の型を定義することができます。"

#: ../../c-api/buffer.rst:24
msgid ""
"While each of these types have their own semantics, they share the common "
"characteristic of being backed by a possibly large memory buffer.  It is "
"then desirable, in some situations, to access that buffer directly and "
"without intermediate copying."
msgstr ""
"これらの各タイプにはそれぞれ独自のセマンティクスがありますが、共通の特性とし"
"て、大規模なメモリバッファによってサポートされている点が挙げられます。 した"
"がって、一部の状況では、そのバッファを直接アクセスし、中間的なコピーを省略す"
"ることが望ましい場合があります。"

#: ../../c-api/buffer.rst:29
msgid ""
"Python provides such a facility at the C level in the form of the :ref:"
"`buffer protocol <bufferobjects>`.  This protocol has two sides:"
msgstr ""
"PythonはCレベルでこのような機能を提供しており、:ref:`バッファ プロトコル "
"<bufferobjects>`. このプロトコルには2つの側面があります："

#: ../../c-api/buffer.rst:34
msgid ""
"on the producer side, a type can export a \"buffer interface\" which allows "
"objects of that type to expose information about their underlying buffer. "
"This interface is described in the section :ref:`buffer-structs`;"
msgstr ""
"プロデューサー側では、型は「バッファインターフェース」をエクスポートすること"
"ができ、その型のオブジェクトが情報を公開できるようにします 彼らの 根底 バッ"
"ファ。このインターフェースは、セクションで説明されています :ref:`buffer-"
"structs`;"

#: ../../c-api/buffer.rst:38
msgid ""
"on the consumer side, several means are available to obtain a pointer to the "
"raw underlying data of an object (for example a method parameter)."
msgstr ""
"消費者側では、ポインターを取得するためのいくつかの方法が利用可能です 生の状態"
"に 根底 オブジェクトのデータ（例えばメソッドのパラメーター）。"

#: ../../c-api/buffer.rst:41
msgid ""
"Simple objects such as :class:`bytes` and :class:`bytearray` expose their "
"underlying buffer in byte-oriented form.  Other forms are possible; for "
"example, the elements exposed by an :class:`array.array` can be multi-byte "
"values."
msgstr ""
"単純な物体など :class:`bytes` そして :class:`bytearray` 彼らの 根底 バッファ "
"バイト単位の形式で。 他の形式も可能です。例えば、ある要素が露出する形式など :"
"class:`array.array` マルチバイト値である可能性があります。"

#: ../../c-api/buffer.rst:45
msgid ""
"An example consumer of the buffer interface is the :meth:`~io.BufferedIOBase."
"write` method of file objects: any object that can export a series of bytes "
"through the buffer interface can be written to a file.  While :meth:`!write` "
"only needs read-only access to the internal contents of the object passed to "
"it, other methods such as :meth:`~io.BufferedIOBase.readinto` need write "
"access to the contents of their argument.  The buffer interface allows "
"objects to selectively allow or reject exporting of read-write and read-only "
"buffers."
msgstr ""
"バッファインターフェースの例として、消費者は :meth:`~io.BufferedIOBase."
"write` ファイルオブジェクトのメソッド: バッファインターフェースを通じてバイト"
"列をエクスポートできる任意のオブジェクトは、ファイルに書き込むことができま"
"す。 一方 :meth:`!write`必要なのは 読み出し専用 渡されたオブジェクトの内部コ"
"ンテンツへのアクセス、その他のメソッドなど :meth:`~io.BufferedIOBase."
"readinto`  引数の内容への書き込みアクセス権限が必要です。 バッファインター"
"フェースは、オブジェクトが読み書きのエクスポートを選択的に許可または拒否でき"
"るようにします そして 読み出し専用 バッファ。"

#: ../../c-api/buffer.rst:53
msgid ""
"There are two ways for a consumer of the buffer interface to acquire a "
"buffer over a target object:"
msgstr ""
"バッファインターフェースの消費者がターゲットオブジェクトに対してバッファを取"
"得する方法は2つあります："

#: ../../c-api/buffer.rst:56
msgid "call :c:func:`PyObject_GetBuffer` with the right parameters;"
msgstr "呼び出す :c:func:`PyObject_GetBuffer` 適切なパラメーターで；"

#: ../../c-api/buffer.rst:58
msgid ""
"call :c:func:`PyArg_ParseTuple` (or one of its siblings) with one of the "
"``y*``, ``w*`` or ``s*`` :ref:`format codes <arg-parsing>`."
msgstr ""
"呼び出し :c:func:`PyArg_ParseTuple` （またはその兄弟姉妹の1つ）と、そのうちの"
"1つと ``y*``, ``w*`` or ``s*``  :ref:`フォーマットコード <arg-parsing>`."

#: ../../c-api/buffer.rst:61
msgid ""
"In both cases, :c:func:`PyBuffer_Release` must be called when the buffer "
"isn't needed anymore.  Failure to do so could lead to various issues such as "
"resource leaks."
msgstr ""
"いずれの場合も、:c:func:`PyBuffer_Release` バッファが不要になった際に必ず呼び"
"出す必要があります。 これを怠ると、リソースリークなどのさまざまな問題が発生す"
"る可能性があります。"

#: ../../c-api/buffer.rst:69
msgid "Buffer structure"
msgstr "バッファ構造"

#: ../../c-api/buffer.rst:71
msgid ""
"Buffer structures (or simply \"buffers\") are useful as a way to expose the "
"binary data from another object to the Python programmer.  They can also be "
"used as a zero-copy slicing mechanism.  Using their ability to reference a "
"block of memory, it is possible to expose any data to the Python programmer "
"quite easily.  The memory could be a large, constant array in a C extension, "
"it could be a raw block of memory for manipulation before passing to an "
"operating system library, or it could be used to pass around structured data "
"in its native, in-memory format."
msgstr ""
"バッファ構造体（または単に「バッファ」）は、別のオブジェクトからバイナリデー"
"タをPythonプログラマーに公開する手段として有用です。また、ゼロコピースライシ"
"ングメカニズムとしても使用できます。 メモリのブロックを参照する機能を活用する"
"ことで、Pythonプログラマーに任意のデータを非常に簡単に公開することが可能で"
"す。 そのメモリは、C拡張モジュール内の大規模な定数配列である可能性もあります"
"し、オペレーティングシステムライブラリに渡す前の操作対象となる生のメモリブ"
"ロックである可能性もあります。また、ネイティブのメモリ内形式で構造化された"
"データをやり取りするためにも使用できます。"

#: ../../c-api/buffer.rst:80
msgid ""
"Contrary to most data types exposed by the Python interpreter, buffers are "
"not :c:type:`PyObject` pointers but rather simple C structures.  This allows "
"them to be created and copied very simply.  When a generic wrapper around a "
"buffer is needed, a :ref:`memoryview <memoryview-objects>` object can be "
"created."
msgstr ""
"ほとんどのデータ型とは異なり によって Python インタープリタ、バッファは :c:"
"type:`PyObject` ポインタ むしろシンプルなC構造体です。これにより、それらを非"
"常に簡単に作成し、コピーすることができます。バッファの汎用ラッパーが必要に"
"なった場合、a :ref:`memoryview <memoryview-objects>` オブジェクトを作成できま"
"す。"

#: ../../c-api/buffer.rst:86
msgid ""
"For short instructions how to write an exporting object, see :ref:`Buffer "
"Object Structures <buffer-structs>`. For obtaining a buffer, see :c:func:"
"`PyObject_GetBuffer`."
msgstr ""
"略して 命令 エクスポート対象のオブジェクトの書き方については :ref:`バッファ "
"オブジェクト構造体`を参照してください <buffer-structs>`. バッファを取得するに"
"は、以下の手順を参照してください :c:func:`PyObject_GetBuffer`."

#: ../../c-api/buffer.rst:94
msgid ""
"A pointer to the start of the logical structure described by the buffer "
"fields. This can be any location within the underlying physical memory block "
"of the exporter. For example, with negative :c:member:`~Py_buffer.strides` "
"the value may point to the end of the memory block."
msgstr ""
"バッファフィールドで記述される論理構造の開始位置へのポインター。これは任意の"
"場所です その中に 根底 エクスポーターの物理メモリブロック 。例えば、負の値の"
"場合 :c:member:`~Py_buffer.strides` その値はメモリブロックの末尾を指す可能性"
"があります。"

#: ../../c-api/buffer.rst:99
msgid ""
"For :term:`contiguous` arrays, the value points to the beginning of the "
"memory block."
msgstr ":term:`連続した arrays、その値はメモリブロックの先頭を指します。"

#: ../../c-api/buffer.rst:104
msgid ""
"A new reference to the exporting object. The reference is owned by the "
"consumer and automatically released (i.e. reference count decremented) and "
"set to ``NULL`` by :c:func:`PyBuffer_Release`. The field is the equivalent "
"of the return value of any standard C-API function."
msgstr ""
"エクスポート対象オブジェクトへの新しい参照。この参照は消費者によって所有さ"
"れ、自動的に解放されます（つまり、参照カウントが減少します）し、設定されます "
"``NULL`` by :c:func:`PyBuffer_Release`. このフィールドは、標準のC-API関数の戻"
"り値に相当します。"

#: ../../c-api/buffer.rst:111
msgid ""
"As a special case, for *temporary* buffers that are wrapped by :c:func:"
"`PyMemoryView_FromBuffer` or :c:func:`PyBuffer_FillInfo` this field is "
"``NULL``. In general, exporting objects MUST NOT use this scheme."
msgstr ""
"特別なケースとして、*一時的な*バッファで、次のようにラップされているものにつ"
"いては :c:func:`PyMemoryView_FromBuffer` or :c:func:`PyBuffer_FillInfo` この"
"フィールドは ``NULL``. 一般に、オブジェクトのエクスポートにはこの方式を使用し"
"てはなりません。"

#: ../../c-api/buffer.rst:118
msgid ""
"``product(shape) * itemsize``. For contiguous arrays, this is the length of "
"the underlying memory block. For non-contiguous arrays, it is the length "
"that the logical structure would have if it were copied to a contiguous "
"representation."
msgstr ""
"``product(shape) * itemsize``. for 連続した arrays 、これが長さですの 根底 メ"
"モリブロック 。非 連続した arrays、論理構造がコピーされた場合、その長さは以下"
"のようになります ～へ 連続した 表現。"

#: ../../c-api/buffer.rst:123
msgid ""
"Accessing ``((char *)buf)[0] up to ((char *)buf)[len-1]`` is only valid if "
"the buffer has been obtained by a request that guarantees contiguity. In "
"most cases such a request will be :c:macro:`PyBUF_SIMPLE` or :c:macro:"
"`PyBUF_WRITABLE`."
msgstr ""
"アクセスする ``((char *)buf)[0] up to ((char *)buf)[len-1]``  バッファが連続"
"性を保証するリクエストによって取得された場合のみ有効です。ほとんどのケースで"
"は、そのようなリクエストは :c:macro:`PyBUF_SIMPLE` or :c:macro:"
"`PyBUF_WRITABLE`."

#: ../../c-api/buffer.rst:129
msgid ""
"An indicator of whether the buffer is read-only. This field is controlled by "
"the :c:macro:`PyBUF_WRITABLE` flag."
msgstr ""
"バッファが機能しているかどうかを示す指標 は 読み出し専用。このフィールドは :"
"c:macro:`PyBUF_WRITABLE`フラグ."

#: ../../c-api/buffer.rst:134
msgid ""
"Item size in bytes of a single element. Same as the value of :func:`struct."
"calcsize` called on non-``NULL`` :c:member:`~Py_buffer.format` values."
msgstr ""
"単一要素のバイト単位のサイズ。値と同じです :func:`struct.calcsize` 非～を呼び"
"かけた``NULL`` :c:member:`~Py_buffer.format` 価値観。"

#: ../../c-api/buffer.rst:137
msgid ""
"Important exception: If a consumer requests a buffer without the :c:macro:"
"`PyBUF_FORMAT` flag, :c:member:`~Py_buffer.format` will be set to  "
"``NULL``,  but :c:member:`~Py_buffer.itemsize` still has the value for the "
"original format."
msgstr ""
"重要な例外：消費者がバッファを要求する場合、そのバッファに :c:macro:"
"`PyBUF_FORMAT` フラグ, :c:member:`~Py_buffer.format` に設定されます "
"``NULL``,  しかし :c:member:`~Py_buffer.itemsize` 元の形式の値を保持していま"
"す。"

#: ../../c-api/buffer.rst:142
msgid ""
"If :c:member:`~Py_buffer.shape` is present, the equality ``product(shape) * "
"itemsize == len`` still holds and the consumer can use :c:member:`~Py_buffer."
"itemsize` to navigate the buffer."
msgstr ""
":c:member:`~Py_buffer.shape` が存在する場合、 ``product(shape) * itemsize == "
"len`` の等式が守られ、利用者は :c:member:`~Py_buffer.itemsize` を buffer を読"
"むために利用できます。"

#: ../../c-api/buffer.rst:146
msgid ""
"If :c:member:`~Py_buffer.shape` is ``NULL`` as a result of a :c:macro:"
"`PyBUF_SIMPLE` or a :c:macro:`PyBUF_WRITABLE` request, the consumer must "
"disregard :c:member:`~Py_buffer.itemsize` and assume ``itemsize == 1``."
msgstr ""
":c:macro:`PyBUF_SIMPLE` または :c:macro:`PyBUF_WRITABLE` で要求した結果、 :c:"
"member:`~Py_buffer.shape` が ``NULL`` であれば、消費者は :c:member:"
"`~Py_buffer.itemsize` を無視して ``itemsize == 1`` と見なさなければなりませ"
"ん。"

#: ../../c-api/buffer.rst:152
msgid ""
"A *NUL* terminated string in :mod:`struct` module style syntax describing "
"the contents of a single item. If this is ``NULL``, ``\"B\"`` (unsigned "
"bytes) is assumed."
msgstr ""
"要素一つ分の内容を指定する、 :mod:`struct` モジュールスタイル文法の、 *NUL* "
"終端文字列。 このポインタの値が ``NULL`` なら、 ``\"B\"`` (符号無しバイト) と"
"して扱われます。"

#: ../../c-api/buffer.rst:156
msgid "This field is controlled by the :c:macro:`PyBUF_FORMAT` flag."
msgstr "このフィールドは :c:macro:`PyBUF_FORMAT` フラグによって制御されます。"

#: ../../c-api/buffer.rst:160
msgid ""
"The number of dimensions the memory represents as an n-dimensional array. If "
"it is ``0``, :c:member:`~Py_buffer.buf` points to a single item representing "
"a scalar. In this case, :c:member:`~Py_buffer.shape`, :c:member:`~Py_buffer."
"strides` and :c:member:`~Py_buffer.suboffsets` MUST be ``NULL``. The maximum "
"number of dimensions is given by :c:macro:`PyBUF_MAX_NDIM`."
msgstr ""

#: ../../c-api/buffer.rst:168
msgid ""
"An array of :c:type:`Py_ssize_t` of length :c:member:`~Py_buffer.ndim` "
"indicating the shape of the memory as an n-dimensional array. Note that "
"``shape[0] * ... * shape[ndim-1] * itemsize`` MUST be equal to :c:member:"
"`~Py_buffer.len`."
msgstr ""
"メモリ上のN次元配列の形を示す、長さが :c:member:`~Py_buffer.ndim` である :c:"
"type:`Py_ssize_t` の配列です。\n"
"``shape[0] * ... * shape[ndim-1] * itemsize`` は :c:member:`~Py_buffer.len` "
"と等しくなければなりません。"

#: ../../c-api/buffer.rst:173
msgid ""
"Shape values are restricted to ``shape[n] >= 0``. The case ``shape[n] == 0`` "
"requires special attention. See `complex arrays`_ for further information."
msgstr ""
"shape の値は ``shape[n] >= 0`` に制限されます。 ``shape[n] == 0`` の場合に特"
"に注意が必要です。\n"
"詳細は `complex arrays`_ を参照してください。"

#: ../../c-api/buffer.rst:177
msgid "The shape array is read-only for the consumer."
msgstr "shepe (形状) 配列は利用者からは読み出し専用です。"

#: ../../c-api/buffer.rst:181
msgid ""
"An array of :c:type:`Py_ssize_t` of length :c:member:`~Py_buffer.ndim` "
"giving the number of bytes to skip to get to a new element in each dimension."
msgstr ""
"各次元において新しい値を得るためにスキップするバイト数を示す、長さ :c:member:"
"`~Py_buffer.ndim` の :c:type:`Py_ssize_t` の配列。"

#: ../../c-api/buffer.rst:185
msgid ""
"Stride values can be any integer. For regular arrays, strides are usually "
"positive, but a consumer MUST be able to handle the case ``strides[n] <= "
"0``. See `complex arrays`_ for further information."
msgstr ""
"ストライド値は、任意の整数を指定できます。規定の配列では、ストライドは通常で"
"いけば有効です。しかし利用者は、``strides[n] <= 0`` のケースを処理することが"
"できる必要があります。詳細については `complex arrays`_ を参照してください。"

#: ../../c-api/buffer.rst:189
msgid "The strides array is read-only for the consumer."
msgstr "消費者にとって、この strides 配列は読み出し専用です。"

#: ../../c-api/buffer.rst:193
msgid ""
"An array of :c:type:`Py_ssize_t` of length :c:member:`~Py_buffer.ndim`. If "
"``suboffsets[n] >= 0``, the values stored along the nth dimension are "
"pointers and the suboffset value dictates how many bytes to add to each "
"pointer after de-referencing. A suboffset value that is negative indicates "
"that no de-referencing should occur (striding in a contiguous memory block)."
msgstr ""
":c:type:`Py_ssize_t` 型の要素を持つ長さ :c:member:`~Py_buffer.ndim` の配"
"列。\n"
"``suboffsets[n] >= 0`` の場合は、 n 番目の次元に沿って保存されている値はポイ"
"ンタで、 suboffset 値は各ポインタの参照を解決した後に何バイト加えればいいかを"
"示しています。\n"
"suboffset の値が負の数の場合は、ポインタの参照解決は不要 (連続したメモリブ"
"ロック内に直接配置されいる) ということになります。"

#: ../../c-api/buffer.rst:200
msgid ""
"If all suboffsets are negative (i.e. no de-referencing is needed), then this "
"field must be ``NULL`` (the default value)."
msgstr ""
"全ての suboffset が負数の場合 (つまり参照解決が不要) な場合、このフィールド"
"は ``NULL`` (デフォルト値) でなければなりません。"

#: ../../c-api/buffer.rst:203
msgid ""
"This type of array representation is used by the Python Imaging Library "
"(PIL). See `complex arrays`_ for further information how to access elements "
"of such an array."
msgstr ""
"この種の配列表現は Python Imaging Library (PIL) で使われています。\n"
"このような配列で要素にアクセスする方法についてさらに詳しことは `complex "
"arrays`_ を参照してください。"

#: ../../c-api/buffer.rst:207
msgid "The suboffsets array is read-only for the consumer."
msgstr "消費者にとって、suboffsets 配列は読み出し専用です。"

#: ../../c-api/buffer.rst:211
msgid ""
"This is for use internally by the exporting object. For example, this might "
"be re-cast as an integer by the exporter and used to store flags about "
"whether or not the shape, strides, and suboffsets arrays must be freed when "
"the buffer is released. The consumer MUST NOT alter this value."
msgstr ""
"バッファを提供する側のオブジェクトが内部的に利用するための変数です。例えば、"
"提供側はこの変数に整数型をキャストして、shape, strides, suboffsets といった配"
"列をバッファを開放するときに同時に解放するべきかどうかを管理するフラグに使う"
"ことができるでしょう。バッファを受け取る側は、この値を決して変更してはなりま"
"せん。"

#: ../../c-api/buffer.rst:218
msgid "Constants:"
msgstr ""

#: ../../c-api/buffer.rst:222
msgid ""
"The maximum number of dimensions the memory represents. Exporters MUST "
"respect this limit, consumers of multi-dimensional buffers SHOULD be able to "
"handle up to :c:macro:`!PyBUF_MAX_NDIM` dimensions. Currently set to 64."
msgstr ""

#: ../../c-api/buffer.rst:231
msgid "Buffer request types"
msgstr "バッファリクエストのタイプ"

#: ../../c-api/buffer.rst:233
msgid ""
"Buffers are usually obtained by sending a buffer request to an exporting "
"object via :c:func:`PyObject_GetBuffer`. Since the complexity of the logical "
"structure of the memory can vary drastically, the consumer uses the *flags* "
"argument to specify the exact buffer type it can handle."
msgstr ""
"バッファは通常、 :c:func:`PyObject_GetBuffer` を使うことで、エクスポートする"
"オブジェクトにバッファリクエストを送ることで得られます。メモリの論理的な構造"
"の複雑性は多岐にわたるため、消費者は *flags* 引数を使って、自身が扱えるバッ"
"ファの種類を指定します。"

#: ../../c-api/buffer.rst:238
msgid ""
"All :c:type:`Py_buffer` fields are unambiguously defined by the request type."
msgstr ""
":c:type:`Py_buffer` の全フィールドは、リクエストの種類によって曖昧さを残さず"
"に定義されます。"

#: ../../c-api/buffer.rst:242
msgid "request-independent fields"
msgstr "リクエストに依存しないフィールド"

#: ../../c-api/buffer.rst:243
msgid ""
"The following fields are not influenced by *flags* and must always be filled "
"in with the correct values: :c:member:`~Py_buffer.obj`, :c:member:"
"`~Py_buffer.buf`, :c:member:`~Py_buffer.len`, :c:member:`~Py_buffer."
"itemsize`, :c:member:`~Py_buffer.ndim`."
msgstr ""
"下記のフィールドは *flags* の影響を受けずに、常に正しい値で設定されます。: :"
"c:member:`~Py_buffer.obj`, :c:member:`~Py_buffer.buf`, :c:member:`~Py_buffer."
"len`, :c:member:`~Py_buffer.itemsize`, :c:member:`~Py_buffer.ndim`."

#: ../../c-api/buffer.rst:249
msgid "readonly, format"
msgstr "readonly, format"

#: ../../c-api/buffer.rst:253
msgid ""
"Controls the :c:member:`~Py_buffer.readonly` field. If set, the exporter "
"MUST provide a writable buffer or else report failure. Otherwise, the "
"exporter MAY provide either a read-only or writable buffer, but the choice "
"MUST be consistent for all consumers."
msgstr ""
":c:member:`~Py_buffer.readonly` フィールドを制御します。もしこのフラグが設定"
"されている場合、exporter は、書き込み可能なバッファを提供するか、さもなければ"
"失敗を報告しなければなりません。フラグが設定されていない場合、exporterは、読"
"み出し専用と書き込み可能なバッファのどちらを提供しても構いませんが、どちらで"
"提供するかどうかは全ての消費者に対して一貫性がなければなりません。"

#: ../../c-api/buffer.rst:260
msgid ""
"Controls the :c:member:`~Py_buffer.format` field. If set, this field MUST be "
"filled in correctly. Otherwise, this field MUST be ``NULL``."
msgstr ""
":c:member:`~Py_buffer.format` フィールドを制御します。もしフラグが設定されて"
"いれば、このフィールドを正しく埋めなければなりません。フラグが設定されていな"
"ければ、このフィールドを ``NULL`` に設定しなければなりません。"

#: ../../c-api/buffer.rst:264
msgid ""
":c:macro:`PyBUF_WRITABLE` can be \\|'d to any of the flags in the next "
"section. Since :c:macro:`PyBUF_SIMPLE` is defined as 0, :c:macro:"
"`PyBUF_WRITABLE` can be used as a stand-alone flag to request a simple "
"writable buffer."
msgstr ""
":c:macro:`PyBUF_WRITABLE` は、次の節に出てくるどのフラグとも \\| を取ってかま"
"いません。\n"
":c:macro:`PyBUF_SIMPLE` は 0 と定義されているので、 :c:macro:"
"`PyBUF_WRITABLE` は単純な書き込み可能なバッファを要求する単独のフラグとして使"
"えます。"

#: ../../c-api/buffer.rst:268
msgid ""
":c:macro:`PyBUF_FORMAT` can be \\|'d to any of the flags except :c:macro:"
"`PyBUF_SIMPLE`. The latter already implies format ``B`` (unsigned bytes)."
msgstr ""
":c:macro:`PyBUF_FORMAT` は、:c:macro:`PyBUF_SIMPLE` 以外のどのフラグとも \\| "
"を取ってかまいません。\n"
"後者のフラグは ``B`` (符号なしバイト) フォーマットを既に指示しています。"

#: ../../c-api/buffer.rst:273
msgid "shape, strides, suboffsets"
msgstr "shape, strides, suboffsets"

#: ../../c-api/buffer.rst:275
msgid ""
"The flags that control the logical structure of the memory are listed in "
"decreasing order of complexity. Note that each flag contains all bits of the "
"flags below it."
msgstr ""
"このフラグは、以下で複雑性が大きい順に並べたメモリの論理的な構造を制御しま"
"す。個々のフラグは、それより下に記載されたフラグのすべてのビットを含むことに"
"注意してください。"

#: ../../c-api/buffer.rst:282 ../../c-api/buffer.rst:306
#: ../../c-api/buffer.rst:331
msgid "Request"
msgstr "リクエスト"

#: ../../c-api/buffer.rst:282 ../../c-api/buffer.rst:306
#: ../../c-api/buffer.rst:331
msgid "shape"
msgstr "shape"

#: ../../c-api/buffer.rst:282 ../../c-api/buffer.rst:306
#: ../../c-api/buffer.rst:331
msgid "strides"
msgstr "strides"

#: ../../c-api/buffer.rst:282 ../../c-api/buffer.rst:306
#: ../../c-api/buffer.rst:331
msgid "suboffsets"
msgstr "suboffsets"

#: ../../c-api/buffer.rst:284 ../../c-api/buffer.rst:286
#: ../../c-api/buffer.rst:288 ../../c-api/buffer.rst:308
#: ../../c-api/buffer.rst:310 ../../c-api/buffer.rst:312
#: ../../c-api/buffer.rst:314 ../../c-api/buffer.rst:333
#: ../../c-api/buffer.rst:335 ../../c-api/buffer.rst:337
#: ../../c-api/buffer.rst:339 ../../c-api/buffer.rst:341
#: ../../c-api/buffer.rst:343 ../../c-api/buffer.rst:345
#: ../../c-api/buffer.rst:347
msgid "yes"
msgstr "yes"

#: ../../c-api/buffer.rst:284 ../../c-api/buffer.rst:333
#: ../../c-api/buffer.rst:335
msgid "if needed"
msgstr "必要な場合"

#: ../../c-api/buffer.rst:286 ../../c-api/buffer.rst:288
#: ../../c-api/buffer.rst:290 ../../c-api/buffer.rst:308
#: ../../c-api/buffer.rst:310 ../../c-api/buffer.rst:312
#: ../../c-api/buffer.rst:314 ../../c-api/buffer.rst:337
#: ../../c-api/buffer.rst:339 ../../c-api/buffer.rst:341
#: ../../c-api/buffer.rst:343 ../../c-api/buffer.rst:345
#: ../../c-api/buffer.rst:347
msgid "NULL"
msgstr "NULL"

#: ../../c-api/buffer.rst:297
msgid "contiguity requests"
msgstr "隣接性のリクエスト"

#: ../../c-api/buffer.rst:299
msgid ""
"C or Fortran :term:`contiguity <contiguous>` can be explicitly requested, "
"with and without stride information. Without stride information, the buffer "
"must be C-contiguous."
msgstr ""
"ストライドの情報があってもなくても、C または Fortran の :term:`連続性 "
"<contiguous>` が明確に要求される可能性があります。\n"
"ストライド情報なしに、バッファーは C と隣接している必要があります。"

#: ../../c-api/buffer.rst:306 ../../c-api/buffer.rst:331
msgid "contig"
msgstr "contig"

#: ../../c-api/buffer.rst:308 ../../c-api/buffer.rst:314
#: ../../c-api/buffer.rst:345 ../../c-api/buffer.rst:347
msgid "C"
msgstr "C"

#: ../../c-api/buffer.rst:310
msgid "F"
msgstr "F"

#: ../../c-api/buffer.rst:312
msgid "C or F"
msgstr "C か F"

#: ../../c-api/buffer.rst:314
msgid ":c:macro:`PyBUF_ND`"
msgstr ":c:macro:`PyBUF_ND`"

#: ../../c-api/buffer.rst:319
msgid "compound requests"
msgstr "複合リクエスト"

#: ../../c-api/buffer.rst:321
msgid ""
"All possible requests are fully defined by some combination of the flags in "
"the previous section. For convenience, the buffer protocol provides "
"frequently used combinations as single flags."
msgstr ""
"有り得る全てのリクエストの値は、前の節でのフラグの組み合わせで網羅的に定義さ"
"れています。\n"
"便利なように、バッファープロトコルでは頻繁に使用される組み合わせを単一のフラ"
"グとして提供してます。"

#: ../../c-api/buffer.rst:325
msgid ""
"In the following table *U* stands for undefined contiguity. The consumer "
"would have to call :c:func:`PyBuffer_IsContiguous` to determine contiguity."
msgstr ""
"次のテーブルの *U* は連続性が未定義であることを表します。\n"
"利用者は :c:func:`PyBuffer_IsContiguous` を呼び出して連続性を判定する必要があ"
"るでしょう。"

#: ../../c-api/buffer.rst:331
msgid "readonly"
msgstr "readonly"

#: ../../c-api/buffer.rst:331
msgid "format"
msgstr "format"

#: ../../c-api/buffer.rst:333 ../../c-api/buffer.rst:335
#: ../../c-api/buffer.rst:337 ../../c-api/buffer.rst:339
#: ../../c-api/buffer.rst:341 ../../c-api/buffer.rst:343
msgid "U"
msgstr "U"

#: ../../c-api/buffer.rst:333 ../../c-api/buffer.rst:337
#: ../../c-api/buffer.rst:341 ../../c-api/buffer.rst:345
msgid "0"
msgstr "0"

#: ../../c-api/buffer.rst:335 ../../c-api/buffer.rst:339
#: ../../c-api/buffer.rst:343 ../../c-api/buffer.rst:347
msgid "1 or 0"
msgstr "1 か 0"

#: ../../c-api/buffer.rst:352
msgid "Complex arrays"
msgstr "複雑な配列"

#: ../../c-api/buffer.rst:355
msgid "NumPy-style: shape and strides"
msgstr "NumPy スタイル: shape, strides"

#: ../../c-api/buffer.rst:357
msgid ""
"The logical structure of NumPy-style arrays is defined by :c:member:"
"`~Py_buffer.itemsize`, :c:member:`~Py_buffer.ndim`, :c:member:`~Py_buffer."
"shape` and :c:member:`~Py_buffer.strides`."
msgstr ""
"NumPy スタイルの配列の論理的構造は :c:member:`~Py_buffer.itemsize`, :c:"
"member:`~Py_buffer.ndim`, :c:member:`~Py_buffer.shape`, :c:member:"
"`~Py_buffer.strides` で定義されます。"

#: ../../c-api/buffer.rst:360
msgid ""
"If ``ndim == 0``, the memory location pointed to by :c:member:`~Py_buffer."
"buf` is interpreted as a scalar of size :c:member:`~Py_buffer.itemsize`. In "
"that case, both :c:member:`~Py_buffer.shape` and :c:member:`~Py_buffer."
"strides` are ``NULL``."
msgstr ""
"``ndim == 0`` の場合は、 :c:member:`~Py_buffer.buf` が指すメモリの場所は、サ"
"イズが :c:member:`~Py_buffer.itemsize` のスカラ値として解釈されます。\n"
"この場合、 :c:member:`~Py_buffer.shape` と :c:member:`~Py_buffer.strides` の"
"両方とも ``NULL`` です。"

#: ../../c-api/buffer.rst:364
msgid ""
"If :c:member:`~Py_buffer.strides` is ``NULL``, the array is interpreted as a "
"standard n-dimensional C-array. Otherwise, the consumer must access an n-"
"dimensional array as follows:"
msgstr ""
":c:member:`~Py_buffer.strides` が ``NULL`` の場合は、配列は標準の n 次元 C 配"
"列として解釈されます。\n"
"そうでない場合は、利用者は次のように n 次元配列にアクセスしなければなりませ"
"ん:"

#: ../../c-api/buffer.rst:374
msgid ""
"As noted above, :c:member:`~Py_buffer.buf` can point to any location within "
"the actual memory block. An exporter can check the validity of a buffer with "
"this function:"
msgstr ""
"上記のように、 :c:member:`~Py_buffer.buf` はメモリブロック内のどの場所でも指"
"すことが可能です。エクスポーターはこの関数を使用することによってバッファの妥"
"当性を確認出来ます。"

#: ../../c-api/buffer.rst:408
msgid "PIL-style: shape, strides and suboffsets"
msgstr "PIL スタイル: shape, strides, suboffsets"

#: ../../c-api/buffer.rst:410
msgid ""
"In addition to the regular items, PIL-style arrays can contain pointers that "
"must be followed in order to get to the next element in a dimension. For "
"example, the regular three-dimensional C-array ``char v[2][2][3]`` can also "
"be viewed as an array of 2 pointers to 2 two-dimensional arrays: ``char "
"(*v[2])[2][3]``. In suboffsets representation, those two pointers can be "
"embedded at the start of :c:member:`~Py_buffer.buf`, pointing to two ``char "
"x[2][3]`` arrays that can be located anywhere in memory."
msgstr ""
"PIL スタイルの配列では通常の要素の他に、ある次元の上で次の要素を取得するため"
"に辿るポインタを持てます。\n"
"例えば、通常の3次元 C 配列 ``char v[2][2][3]`` は、2次元配列への 2 つのポイン"
"タからなる配列 ``char (*v[2])[2][3]`` と見ることもできます。\n"
"suboffset 表現では、これらの 2 つのポインタは :c:member:`~Py_buffer.buf` の先"
"頭に埋め込め、メモリのどこにでも配置できる 2 つの ``char x[2][3]`` 配列を指し"
"ます。"

#: ../../c-api/buffer.rst:419
msgid ""
"Here is a function that returns a pointer to the element in an N-D array "
"pointed to by an N-dimensional index when there are both non-``NULL`` "
"strides and suboffsets::"
msgstr ""
"次の例は、 strides も suboffsets も ``NULL`` でない場合の、N 次元インデックス"
"によって指されている N 次元配列内の要素へのポインタを返す関数です::"

#: ../../c-api/buffer.rst:438
msgid "Buffer-related functions"
msgstr "バッファ関連の関数"

#: ../../c-api/buffer.rst:442
msgid ""
"Return ``1`` if *obj* supports the buffer interface otherwise ``0``.  When "
"``1`` is returned, it doesn't guarantee that :c:func:`PyObject_GetBuffer` "
"will succeed.  This function always succeeds."
msgstr ""
"*obj* がbuffer インターフェースをサポートしている場合は ``1`` を返し、そうで"
"ない場合は ``0`` を返します。\n"
"``1`` を返したとしても、 :c:func:`PyObject_GetBuffer` が成功することは保証さ"
"れません。\n"
"この関数は常に成功します。"

#: ../../c-api/buffer.rst:449
msgid ""
"Send a request to *exporter* to fill in *view* as specified by  *flags*. If "
"the exporter cannot provide a buffer of the exact type, it MUST raise :exc:"
"`BufferError`, set ``view->obj`` to ``NULL`` and return ``-1``."
msgstr ""
"*exporter* に *flags* で指定された方法で *view* を埋めるように要求します。も"
"し exporter が指定されたとおりにバッファを提供できない場合、 :exc:"
"`BufferError` を送出し、 ``view->obj`` を ``NULL`` に設定した上で、 ``-1`` を"
"返さなければなりません。"

#: ../../c-api/buffer.rst:454
msgid ""
"On success, fill in *view*, set ``view->obj`` to a new reference to "
"*exporter* and return 0. In the case of chained buffer providers that "
"redirect requests to a single object, ``view->obj`` MAY refer to this object "
"instead of *exporter* (See :ref:`Buffer Object Structures <buffer-structs>`)."
msgstr ""
"成功したときは、 *view* を埋め、 ``view->obj`` に *exporter* への新しい参照を"
"設定し、0を返します。チェイン状のバッファプロバイダがリクエストを単一のオブ"
"ジェクトにリダイレクトするケースでは、 ``view->obj`` は *exporter* の代わりに"
"このオブジェクトを参照します (:ref:`バッファオブジェクト構造体 <buffer-"
"structs>` を参照してください)。"

#: ../../c-api/buffer.rst:459
msgid ""
"Successful calls to :c:func:`PyObject_GetBuffer` must be paired with calls "
"to :c:func:`PyBuffer_Release`, similar to :c:func:`malloc` and :c:func:"
"`free`. Thus, after the consumer is done with the buffer, :c:func:"
"`PyBuffer_Release` must be called exactly once."
msgstr ""
":c:func:`malloc` と :c:func:`free` のように、呼び出しに成功した :c:func:"
"`PyObject_GetBuffer` と対になる :c:func:`PyBuffer_Release` の呼び出しがなけれ"
"なればなりません。\n"
"従って、バッファの利用が済んだら :c:func:`PyBuffer_Release` が厳密に1回だけ呼"
"び出されなければなりません。"

#: ../../c-api/buffer.rst:467
msgid ""
"Release the buffer *view* and release the :term:`strong reference` (i.e. "
"decrement the reference count) to the view's supporting object, ``view-"
">obj``. This function MUST be called when the buffer is no longer being "
"used, otherwise reference leaks may occur."
msgstr ""

#: ../../c-api/buffer.rst:472
msgid ""
"It is an error to call this function on a buffer that was not obtained via :"
"c:func:`PyObject_GetBuffer`."
msgstr ""
":c:func:`PyObject_GetBuffer` を通して取得していないバッファに対してこの関数を"
"呼び出すのは間違いです。"

#: ../../c-api/buffer.rst:478
msgid ""
"Return the implied :c:member:`~Py_buffer.itemsize` from :c:member:"
"`~Py_buffer.format`. On error, raise an exception and return -1."
msgstr ""

#: ../../c-api/buffer.rst:486
msgid ""
"Return ``1`` if the memory defined by the *view* is C-style (*order* is "
"``'C'``) or Fortran-style (*order* is ``'F'``) :term:`contiguous` or either "
"one (*order* is ``'A'``).  Return ``0`` otherwise.  This function always "
"succeeds."
msgstr ""
"*view* で定義されているメモリが、 C スタイル (*order* == ``'C'``) のときか、 "
"Fortran スタイル (*order* == ``'F'``) :term:`連続 <contiguous>` のときか、そ"
"のいずれか (*order* == ``'A'``) であれば ``1`` を返します。\n"
"それ以外の場合は ``0`` を返します。\n"
"この関数は常に成功します。"

#: ../../c-api/buffer.rst:493
msgid ""
"Get the memory area pointed to by the *indices* inside the given *view*. "
"*indices* must point to an array of ``view->ndim`` indices."
msgstr ""
"与えられた *view* 内にある *indices* が指すメモリ領域を取得します。\n"
"*indices* は ``view->ndim`` 個のインデックスからなる配列を指していなければな"
"りません。"

#: ../../c-api/buffer.rst:499
msgid ""
"Copy contiguous *len* bytes from *buf* to *view*. *fort* can be ``'C'`` or "
"``'F'`` (for C-style or Fortran-style ordering). ``0`` is returned on "
"success, ``-1`` on error."
msgstr ""
"連続する *len* バイトを *buf* から *view* にコピーします。*fort* には "
"``'C'`` か ``'F'`` を指定できます（それぞれC言語スタイルとFortranスタイルの順"
"序を表します)。成功時には ``0``、エラー時には ``-1`` を返します。"

#: ../../c-api/buffer.rst:506
msgid ""
"Copy *len* bytes from *src* to its contiguous representation in *buf*. "
"*order* can be ``'C'`` or ``'F'`` or ``'A'`` (for C-style or Fortran-style "
"ordering or either one). ``0`` is returned on success, ``-1`` on error."
msgstr ""
"*src* から *len* バイトを連続表現で *buf* 上にコピーします。\n"
"*order* は ``'C'`` または ``'F'`` または ``'A'`` (C スタイル順序または "
"Fortran スタイル順序またはそれ以外) が指定できます。\n"
"成功したら ``0`` が返り、エラーなら ``-1`` が返ります。"

#: ../../c-api/buffer.rst:510
msgid "This function fails if *len* != *src->len*."
msgstr "*len* != *src->len* の場合、この関数は失敗します。"

#: ../../c-api/buffer.rst:515
msgid ""
"Copy data from *src* to *dest* buffer. Can convert between C-style and or "
"Fortran-style buffers."
msgstr ""

#: ../../c-api/buffer.rst:518
msgid "``0`` is returned on success, ``-1`` on error."
msgstr "成功したら ``0`` が、エラー時には ``-1`` が返されます。"

#: ../../c-api/buffer.rst:522
msgid ""
"Fill the *strides* array with byte-strides of a :term:`contiguous` (C-style "
"if *order* is ``'C'`` or Fortran-style if *order* is ``'F'``) array of the "
"given shape with the given number of bytes per element."
msgstr ""
"*strides* 配列を、 *itemsize* の大きさの要素がバイト単位の、 *shape* の形をし"
"た :term:`連続な <contiguous>` (*order* が ``'C'`` なら C-style 、 ``'F'`` な"
"ら Fortran-style の) 多次元配列として埋める。"

#: ../../c-api/buffer.rst:529
msgid ""
"Handle buffer requests for an exporter that wants to expose *buf* of size "
"*len* with writability set according to *readonly*. *buf* is interpreted as "
"a sequence of unsigned bytes."
msgstr ""
"サイズが *len* の *buf* を *readonly* に従った書き込み可/不可の設定で公開する"
"バッファリクエストを処理します。\n"
"*buf* は符号無しバイトの列として解釈されます。"

#: ../../c-api/buffer.rst:533
msgid ""
"The *flags* argument indicates the request type. This function always fills "
"in *view* as specified by flags, unless *buf* has been designated as read-"
"only and :c:macro:`PyBUF_WRITABLE` is set in *flags*."
msgstr ""
"*flags* 引数はリクエストのタイプを示します。\n"
"この関数は、 *buf* が読み出し専用と指定されていて、 *flags* に :c:macro:"
"`PyBUF_WRITABLE` が設定されていない限り、常にフラグに指定された通りに *view* "
"を埋めます。"

#: ../../c-api/buffer.rst:537
msgid ""
"On success, set ``view->obj`` to a new reference to *exporter* and return 0. "
"Otherwise, raise :exc:`BufferError`, set ``view->obj`` to ``NULL`` and "
"return ``-1``;"
msgstr ""

#: ../../c-api/buffer.rst:541
msgid ""
"If this function is used as part of a :ref:`getbufferproc <buffer-structs>`, "
"*exporter* MUST be set to the exporting object and *flags* must be passed "
"unmodified. Otherwise, *exporter* MUST be ``NULL``."
msgstr ""
"この関数を :ref:`getbufferproc <buffer-structs>` の一部として使う場合には、 "
"*exporter* はエクスポートするオブジェクトに設定しなければならず、さらに "
"*flags* は変更せずに渡さなければなりません。\n"
"そうでない場合は、 *exporter* は ``NULL`` でなければなりません。"

#: ../../c-api/buffer.rst:3
msgid "buffer protocol"
msgstr "buffer protocol"

#: ../../c-api/buffer.rst:3
msgid "buffer interface"
msgstr ""

#: ../../c-api/buffer.rst:3
msgid "(see buffer protocol)"
msgstr ""

#: ../../c-api/buffer.rst:3
msgid "buffer object"
msgstr ""

#: ../../c-api/buffer.rst:32
msgid "PyBufferProcs (C type)"
msgstr ""

#: ../../c-api/buffer.rst:294
msgid "contiguous"
msgstr "contiguous"

#: ../../c-api/buffer.rst:294
msgid "C-contiguous"
msgstr ""

#: ../../c-api/buffer.rst:294
msgid "Fortran contiguous"
msgstr ""
