# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Hui Ping, 2025
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 15:00+0000\n"
"PO-Revision-Date: 2025-07-18 19:20+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Malay (https://app.transifex.com/python-doc/teams/5390/ms/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ms\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../c-api/dict.rst:6
msgid "Dictionary Objects"
msgstr "Objek Kamus"

#: ../../c-api/dict.rst:13
msgid ""
"This subtype of :c:type:`PyObject` represents a Python dictionary object."
msgstr "Subjenis :c:type:`PyObject` ini mewakili objek kamus Python."

#: ../../c-api/dict.rst:18
msgid ""
"This instance of :c:type:`PyTypeObject` represents the Python dictionary "
"type.  This is the same object as :class:`dict` in the Python layer."
msgstr ""
"Tika :c:type:`PyTypeObject` ini mewakili jenis kamus Python.  Tika ini ialah "
"objek sama seperti :class:`dict` dalam lapisan Python."

#: ../../c-api/dict.rst:24
msgid ""
"Return true if *p* is a dict object or an instance of a subtype of the dict "
"type.  This function always succeeds."
msgstr ""
"Kembalikan benar jika *p* ialah objek dict atau tika subjenis bagi jenis "
"dict.  Fungsi ini sentiasa berjaya."

#: ../../c-api/dict.rst:30
msgid ""
"Return true if *p* is a dict object, but not an instance of a subtype of the "
"dict type.  This function always succeeds."
msgstr ""
"Kembalikan benar jika *p* ialah objek dict, tetapi bukan tika subjenis bagi "
"jenis dict.  Fungsi ini sentiasa berjaya."

#: ../../c-api/dict.rst:36
msgid "Return a new empty dictionary, or ``NULL`` on failure."
msgstr "Kembalikan kamus kosong baharu atau ``NULL`` apabila gagal."

#: ../../c-api/dict.rst:41
msgid ""
"Return a :class:`types.MappingProxyType` object for a mapping which enforces "
"read-only behavior.  This is normally used to create a view to prevent "
"modification of the dictionary for non-dynamic class types."
msgstr ""
"Kembalikan objek :class:`types.MappingProxyType` untuk pemetaan yang "
"menguatkuasakan kelakuan baca sahaja.  Ini biasanya digunakan untuk mencipta "
"pandangan bagi menghalang pengubahsuaian kamus untuk jenis kelas bukan "
"dinamik."

#: ../../c-api/dict.rst:48
msgid "Empty an existing dictionary of all key-value pairs."
msgstr "Kosongkan kamus yang sedia ada bagi semua pasangan kunci dengan nilai."

#: ../../c-api/dict.rst:53
msgid ""
"Determine if dictionary *p* contains *key*.  If an item in *p* is matches "
"*key*, return ``1``, otherwise return ``0``.  On error, return ``-1``. This "
"is equivalent to the Python expression ``key in p``."
msgstr ""
"Tentukan sama ada *p* kamus mengandungi *key* atau tidak.  Jika item dalam "
"*p* sepadan dengan *key*, kembalikan ``1``, jika tidak kembalikan ``0``.  "
"Jika ralat, kembalikan ``-1``. Ini adalah bersamaan dengan ungkapan Python "
"``key in p``."

#: ../../c-api/dict.rst:60
msgid ""
"This is the same as :c:func:`PyDict_Contains`, but *key* is specified as a :"
"c:expr:`const char*` UTF-8 encoded bytes string, rather than a :c:expr:"
"`PyObject*`."
msgstr ""
"Ini adalah sama dengan :c:func:`PyDict_Contains`, tetapi *key* ditetapkan "
"sebagai :c:expr:`const char*` rentetan bait terkod UTF-8 dan bukannya :c:"
"expr:`PyObject*`."

#: ../../c-api/dict.rst:69
msgid "Return a new dictionary that contains the same key-value pairs as *p*."
msgstr ""
"Kembalikan kamus baharu yang mengandungi pasangan kunci dengan nilai yang "
"sama dengan *p*."

#: ../../c-api/dict.rst:74
msgid ""
"Insert *val* into the dictionary *p* with a key of *key*.  *key* must be :"
"term:`hashable`; if it isn't, :exc:`TypeError` will be raised. Return ``0`` "
"on success or ``-1`` on failure.  This function *does not* steal a reference "
"to *val*."
msgstr ""
"Masukkan *val* dalam *p* kamus dengan kunci *key*.  *key* mestilah :term:"
"`hashable`; jika tidak, :exc:`TypeError` akan dikemukakan. Kembalikan ``0`` "
"apabila berjaya atau``-1`` apabila gagal.  Fungsi ini *tidak* mengambil alih "
"rujukan kepada *val*."

#: ../../c-api/dict.rst:82
msgid ""
"This is the same as :c:func:`PyDict_SetItem`, but *key* is specified as a :c:"
"expr:`const char*` UTF-8 encoded bytes string, rather than a :c:expr:"
"`PyObject*`."
msgstr ""
"Ini adalah sama dengan :c:func:`PyDict_SetItem`, tetapi *key* ditetapkan "
"sebagai :c:expr:`const char*` rentetan bait terkod UTF-8 dan bukannya :c:"
"expr:`PyObject*`."

#: ../../c-api/dict.rst:89
msgid ""
"Remove the entry in dictionary *p* with key *key*. *key* must be :term:"
"`hashable`; if it isn't, :exc:`TypeError` is raised. If *key* is not in the "
"dictionary, :exc:`KeyError` is raised. Return ``0`` on success or ``-1`` on "
"failure."
msgstr ""
"Keluarkan entri dalam *p* kamus dengan kunci *key*. *key* mestilah :term:"
"`hashable`; jika tidak, :exc:`TypeError` akan dikemukakan. Jika *key* tiada "
"dalam kamus, :exc:`KeyError` akan dikemukakan. Kembalikan ``0`` apabila "
"berjaya atau ``-1`` apabila gagal."

#: ../../c-api/dict.rst:97
msgid ""
"This is the same as :c:func:`PyDict_DelItem`, but *key* is specified as a :c:"
"expr:`const char*` UTF-8 encoded bytes string, rather than a :c:expr:"
"`PyObject*`."
msgstr ""
"Ini adalah sama dengan :c:func:`PyDict_DelItem`, tetapi *key* ditetapkan "
"sebagai :c:expr:`const char*` rentetan bait terkod UTF-8 dan bukannya :c:"
"expr:`PyObject*`."

#: ../../c-api/dict.rst:104
msgid ""
"Return a new :term:`strong reference` to the object from dictionary *p* "
"which has a key *key*:"
msgstr ""
"Kembalikan :term:`strong reference` baharu kepada objek daripada *p* kamus "
"yang mempunyai kunci *key*:"

#: ../../c-api/dict.rst:107
msgid ""
"If the key is present, set *\\*result* to a new :term:`strong reference` to "
"the value and return ``1``."
msgstr ""
"Jika kunci wujud, tetapkan *\\*result* kepada :term:`strong reference` "
"baharu pada nilai dan kembalikan ``1``."

#: ../../c-api/dict.rst:109
msgid "If the key is missing, set *\\*result* to ``NULL`` and return ``0``."
msgstr ""
"Jika tiada kunci, tetapkan *\\*result* kepada ``NULL`` dan kembalikan ``0``."

#: ../../c-api/dict.rst:110 ../../c-api/dict.rst:207
msgid "On error, raise an exception and return ``-1``."
msgstr "Jika ralat, kemukakan pengecualian dan kembalikan ``-1``."

#: ../../c-api/dict.rst:114
msgid "See also the :c:func:`PyObject_GetItem` function."
msgstr "Lihat juga fungsi :c:func:`PyObject_GetItem`."

#: ../../c-api/dict.rst:119
msgid ""
"Return a :term:`borrowed reference` to the object from dictionary *p* which "
"has a key *key*.  Return ``NULL`` if the key *key* is missing *without* "
"setting an exception."
msgstr ""
"Kembalikan :term:`borrowed reference` kepada objek daripada *p* kamus yang "
"mempunyai kunci *key*.  Kembalikan ``NULL`` jika tiada kunci *key* *tanpa* "
"menetapkan pengecualian."

#: ../../c-api/dict.rst:125
msgid ""
"Exceptions that occur while this calls :meth:`~object.__hash__` and :meth:"
"`~object.__eq__` methods are silently ignored. Prefer the :c:func:"
"`PyDict_GetItemWithError` function instead."
msgstr ""
"Pengecualian yang berlaku semasa kaedah panggilan ini :meth:`~object."
"__hash__` dan :meth:`~object.__eq__` diabaikan secara senyap. Sebaliknya, "
"utamakan fungsi :c:func:`PyDict_GetItemWithError`."

#: ../../c-api/dict.rst:129
msgid ""
"Calling this API without :term:`GIL` held had been allowed for historical "
"reason. It is no longer allowed."
msgstr ""
"Memanggil API ini tanpa memperoleh :term:`GIL` dibenarkan atas sebab "
"terdahulu. Tindakan ini tidak lagi dibenarkan."

#: ../../c-api/dict.rst:136
msgid ""
"Variant of :c:func:`PyDict_GetItem` that does not suppress exceptions. "
"Return ``NULL`` **with** an exception set if an exception occurred.  Return "
"``NULL`` **without** an exception set if the key wasn't present."
msgstr ""
"Varian :c:func:`PyDict_GetItem` tidak menyekat pengecualian. Kembalikan "
"``NULL`` **dengan** set pengecualian jika pengecualian berlaku.  Kembalikan "
"``NULL`` **tanpa** set pengecualian jika tiada kunci tersebut."

#: ../../c-api/dict.rst:144
msgid ""
"This is the same as :c:func:`PyDict_GetItem`, but *key* is specified as a :c:"
"expr:`const char*` UTF-8 encoded bytes string, rather than a :c:expr:"
"`PyObject*`."
msgstr ""
"Ini adalah sama dengan :c:func:`PyDict_GetItem`, tetapi *key* ditetapkan "
"sebagai :c:expr:`const char*` rentetan bait terkod UTF-8 dan bukannya :c:"
"expr:`PyObject*`."

#: ../../c-api/dict.rst:150
msgid ""
"Exceptions that occur while this calls :meth:`~object.__hash__` and :meth:"
"`~object.__eq__` methods or while creating the temporary :class:`str` object "
"are silently ignored. Prefer using the :c:func:`PyDict_GetItemWithError` "
"function with your own :c:func:`PyUnicode_FromString` *key* instead."
msgstr ""
"Pengecualian yang berlaku semasa memanggil kaedah :meth:`~object.__hash__` "
"dan :meth:`~object.__eq__` atau mencipta objek :class:`str` sementara akan "
"diabaikan secara senyap. Sebaliknya. utamakan penggunaan fungsi :c:func:"
"`PyDict_GetItemWithError` dengan :c:func:`PyUnicode_FromString` *key*."

#: ../../c-api/dict.rst:159
msgid ""
"Similar to :c:func:`PyDict_GetItemRef`, but *key* is specified as a :c:expr:"
"`const char*` UTF-8 encoded bytes string, rather than a :c:expr:`PyObject*`."
msgstr ""
"Serupa dengan ::c:func:`PyDict_GetItemRef`, tetapi *key* ditetapkan sebagai :"
"c:expr:`const char*` rentetan bait terkod UTF-8 dan bukannya :c:expr:"
"`PyObject*`."

#: ../../c-api/dict.rst:168
msgid ""
"This is the same as the Python-level :meth:`dict.setdefault`.  If present, "
"it returns the value corresponding to *key* from the dictionary *p*.  If the "
"key is not in the dict, it is inserted with value *defaultobj* and "
"*defaultobj* is returned.  This function evaluates the hash function of "
"*key* only once, instead of evaluating it independently for the lookup and "
"the insertion."
msgstr ""
"Ini adalah sama dengan :meth:`dict.setdefault` tahap Python.  Jika wujud, "
"nilai sepadan akan dikembalikan kepada *key* daripada *p* kamus.  Jika kunci "
"tiada dalam dict, kunci akan dimasukkan dengan nilai *defaultobj* dan "
"*defaultobj* akan dikembalikan.  Fungsi ini menilai fungsi hash *key* sekali "
"sahaja, dan bukannya menilai kunci secara bebas untuk carian dan pemasukan."

#: ../../c-api/dict.rst:179
msgid ""
"Inserts *default_value* into the dictionary *p* with a key of *key* if the "
"key is not already present in the dictionary. If *result* is not ``NULL``, "
"then *\\*result* is set to a :term:`strong reference` to either "
"*default_value*, if the key was not present, or the existing value, if *key* "
"was already present in the dictionary. Returns ``1`` if the key was present "
"and *default_value* was not inserted, or ``0`` if the key was not present "
"and *default_value* was inserted. On failure, returns ``-1``, sets an "
"exception, and sets ``*result`` to ``NULL``."
msgstr ""
"Masukkan *default_value* dalam *p* kamus dengan kunci *key* jika kunci belum "
"wujud dalam kamus. Jika *result* bukan ``NULL``, maka *\\*result* ditetapkan "
"kepada :term:`strong reference` kepada mana-mana *default_value*, jika kunci "
"tiada, atau nilai sedia ada, jika *key* sudah wujud dalam kamus. ``1`` akan "
"dikembalikan jika kunci sudah wujud dan *default_value* tidak dimasukkan, "
"atau ``0`` jika kunci tidak wujud dan *default_value* telah dimasukkan. Jika "
"gagal, ``-1`` akan dikembalikan dan ``*result`` ditetapkan kepada ``NULL``."

#: ../../c-api/dict.rst:189
msgid ""
"For clarity: if you have a strong reference to *default_value* before "
"calling this function, then after it returns, you hold a strong reference to "
"both *default_value* and *\\*result* (if it's not ``NULL``). These may refer "
"to the same object: in that case you hold two separate references to it."
msgstr ""
"Untuk kejelasan: jika anda mempunyai rujukan kukuh kepada *default_value* "
"sebelum memanggil fungsi ini, kemudian selepas dikembalikan, anda mempunyai "
"rujukan kukuh kepada kedua-dua *default_value* dan *\\*result* (jika bukan "
"``NULL``). Rujukan ini boleh merujuk kepada objek yang sama: dalam keadaan "
"sedemikian, anda mempunyai dua rujukan berasingan kepada objek."

#: ../../c-api/dict.rst:200
msgid ""
"Remove *key* from dictionary *p* and optionally return the removed value. Do "
"not raise :exc:`KeyError` if the key missing."
msgstr ""
"Singkirkan *key* daripada *p* kamus dan mengembalikan nilai yang "
"disingkirkan secara pilihan. Jangan kemukakan :exc:`KeyError` jika kunci "
"tiada."

#: ../../c-api/dict.rst:203
msgid ""
"If the key is present, set *\\*result* to a new reference to the removed "
"value if *result* is not ``NULL``, and return ``1``."
msgstr ""
"Jika kunci wujud, tetapkan *\\*result* kepada rujukan baharu kepada nilai "
"yang disingkirkan jika *result* bukan ``NULL`` dan kembalikan ``1``."

#: ../../c-api/dict.rst:205
msgid ""
"If the key is missing, set *\\*result* to ``NULL`` if *result* is not "
"``NULL``, and return ``0``."
msgstr ""
"Jika tiada kunci, tetapkan *\\*result* kepada ``NULL``, jika *result* bukan "
"``NULL``, dan kembalikan ``0``."

#: ../../c-api/dict.rst:209
msgid ""
"Similar to :meth:`dict.pop`, but without the default value and not raising :"
"exc:`KeyError` if the key missing."
msgstr ""
"Serupa dengan :meth:`dict.pop`, tetapi tanpa nilai lalai dan tidak "
"mengemukakan :exc:`KeyError` jika tiada kunci."

#: ../../c-api/dict.rst:217
msgid ""
"Similar to :c:func:`PyDict_Pop`, but *key* is specified as a :c:expr:`const "
"char*` UTF-8 encoded bytes string, rather than a :c:expr:`PyObject*`."
msgstr ""
"Serupa dengan :c:func:`PyDict_Pop`, tetapi *key* ditetapkan sebagai :c:expr:"
"`const char*` rentetan bait terkod UTF-8 dan bukannya :c:expr:`PyObject*`."

#: ../../c-api/dict.rst:226
msgid ""
"Return a :c:type:`PyListObject` containing all the items from the dictionary."
msgstr ""
"Kembalikan :c:type:`PyListObject` yang mengandungi semua item daripada kamus."

#: ../../c-api/dict.rst:231
msgid ""
"Return a :c:type:`PyListObject` containing all the keys from the dictionary."
msgstr ""
"Kembalikan :c:type:`PyListObject` yang mengandungi semua kunci daripada "
"kamus."

#: ../../c-api/dict.rst:236
msgid ""
"Return a :c:type:`PyListObject` containing all the values from the "
"dictionary *p*."
msgstr ""
"Kembalikan :c:type:`PyListObject` yang mengandungi semua nilai daripada *p* "
"kamus."

#: ../../c-api/dict.rst:244
msgid ""
"Return the number of items in the dictionary.  This is equivalent to "
"``len(p)`` on a dictionary."
msgstr ""
"Kembalikan bilangan item dalam kamus.  Ini adalah bersamaan dengan "
"``len(p)`` pada kamus."

#: ../../c-api/dict.rst:250
msgid ""
"Iterate over all key-value pairs in the dictionary *p*.  The :c:type:"
"`Py_ssize_t` referred to by *ppos* must be initialized to ``0`` prior to the "
"first call to this function to start the iteration; the function returns "
"true for each pair in the dictionary, and false once all pairs have been "
"reported.  The parameters *pkey* and *pvalue* should either point to :c:expr:"
"`PyObject*` variables that will be filled in with each key and value, "
"respectively, or may be ``NULL``.  Any references returned through them are "
"borrowed.  *ppos* should not be altered during iteration. Its value "
"represents offsets within the internal dictionary structure, and since the "
"structure is sparse, the offsets are not consecutive."
msgstr ""
"Ulangi pada semua pasangan kunci dengan nilai dalam *p* kamus.  :c:type:"
"`Py_ssize_t` yang dirujuk melalui *ppos* mesti dimulakan kepada ``0`` "
"sebelum panggilan pertama kepada fungsi ini untuk memulakan perulangan, "
"fungsi mengembalikan benar bagi setiap pasangan dalam kamus dan palsu sebaik "
"sahaja semua pasangan telah dilaporkan.  Parameter *pkey* dan *pvalue* harus "
"sama ada menghala kepada pembolehubah :c:expr:`PyObject*` yang akan diisikan "
"dengan setiap kunci dan nilai masing-masing atau mungkin ``NULL``.  Sebarang "
"rujukan yang dikembalikan melalui ini adalah dipinjam.  *ppos* tidak boleh "
"diubah suai semasa perulangan. Nilai ini mewakili ofset dalam struktur kamus "
"dalaman dan oleh sebab struktur adalah jarang, ofset tidak berturutan."

#: ../../c-api/dict.rst:261
msgid "For example::"
msgstr "Contohnya::"

#: ../../c-api/dict.rst:263
msgid ""
"PyObject *key, *value;\n"
"Py_ssize_t pos = 0;\n"
"\n"
"while (PyDict_Next(self->dict, &pos, &key, &value)) {\n"
"    /* do something interesting with the values... */\n"
"    ...\n"
"}"
msgstr ""
"PyObject *key, *value;\n"
"Py_ssize_t pos = 0;\n"
"\n"
"while (PyDict_Next(self->dict, &pos, &key, &value)) {\n"
"    /* do something interesting with the values... */\n"
"    ...\n"
"}"

#: ../../c-api/dict.rst:271
msgid ""
"The dictionary *p* should not be mutated during iteration.  It is safe to "
"modify the values of the keys as you iterate over the dictionary, but only "
"so long as the set of keys does not change.  For example::"
msgstr ""
"*p* kamus tidak seharusnya dimutasikan semasa perulangan.  Nilai kunci boleh "
"diubah suai secara selamat apabila anda membuat perulangan melalui kamus, "
"tetapi hanya selagi set kunci tidak berubah.  Contohnya::"

#: ../../c-api/dict.rst:275
msgid ""
"PyObject *key, *value;\n"
"Py_ssize_t pos = 0;\n"
"\n"
"while (PyDict_Next(self->dict, &pos, &key, &value)) {\n"
"    long i = PyLong_AsLong(value);\n"
"    if (i == -1 && PyErr_Occurred()) {\n"
"        return -1;\n"
"    }\n"
"    PyObject *o = PyLong_FromLong(i + 1);\n"
"    if (o == NULL)\n"
"        return -1;\n"
"    if (PyDict_SetItem(self->dict, key, o) < 0) {\n"
"        Py_DECREF(o);\n"
"        return -1;\n"
"    }\n"
"    Py_DECREF(o);\n"
"}"
msgstr ""
"PyObject *key, *value;\n"
"Py_ssize_t pos = 0;\n"
"\n"
"while (PyDict_Next(self->dict, &pos, &key, &value)) {\n"
"    long i = PyLong_AsLong(value);\n"
"    if (i == -1 && PyErr_Occurred()) {\n"
"        return -1;\n"
"    }\n"
"    PyObject *o = PyLong_FromLong(i + 1);\n"
"    if (o == NULL)\n"
"        return -1;\n"
"    if (PyDict_SetItem(self->dict, key, o) < 0) {\n"
"        Py_DECREF(o);\n"
"        return -1;\n"
"    }\n"
"    Py_DECREF(o);\n"
"}"

#: ../../c-api/dict.rst:293
msgid ""
"The function is not thread-safe in the :term:`free-threaded <free "
"threading>` build without external synchronization.  You can use :c:macro:"
"`Py_BEGIN_CRITICAL_SECTION` to lock the dictionary while iterating over it::"
msgstr ""
"Fungsi tidak selamat untuk bebenang dalam binaan :term:`free-threaded <free "
"threading>` tanpa penyegerakan luaran.  Anda boleh menggunakan :c:macro:"
"`Py_BEGIN_CRITICAL_SECTION` untuk mengunci kamus semasa melakukan perulangan "
"pada kamus::"

#: ../../c-api/dict.rst:298
msgid ""
"Py_BEGIN_CRITICAL_SECTION(self->dict);\n"
"while (PyDict_Next(self->dict, &pos, &key, &value)) {\n"
"    ...\n"
"}\n"
"Py_END_CRITICAL_SECTION();"
msgstr ""
"Py_BEGIN_CRITICAL_SECTION(self->dict);\n"
"while (PyDict_Next(self->dict, &pos, &key, &value)) {\n"
"    ...\n"
"}\n"
"Py_END_CRITICAL_SECTION();"

#: ../../c-api/dict.rst:307
msgid ""
"Iterate over mapping object *b* adding key-value pairs to dictionary *a*. "
"*b* may be a dictionary, or any object supporting :c:func:`PyMapping_Keys` "
"and :c:func:`PyObject_GetItem`. If *override* is true, existing pairs in *a* "
"will be replaced if a matching key is found in *b*, otherwise pairs will "
"only be added if there is not a matching key in *a*. Return ``0`` on success "
"or ``-1`` if an exception was raised."
msgstr ""
"Ulangi pada pemetaan objek *b*, menambahkan pasangan kunci dengan nilai *a* "
"kamus. *b* mungkin ialah kamus atau sebarang objek yang menyokong :c:func:"
"`PyMapping_Keys` dan :c:func:`PyObject_GetItem`. Jika *override* adalah "
"benar, pasangan sedia ada dalam *a* akan digantikan jika kunci sepadan "
"ditemukan dalam *b*, jika tidak, pasangan hanya akan ditambahkan jika tiada "
"kunci sepadan dalam *a*. Kembalikan ``0`` jika berjaya atau ``-1`` jika "
"pengecualian dikemukakan."

#: ../../c-api/dict.rst:317
msgid ""
"This is the same as ``PyDict_Merge(a, b, 1)`` in C, and is similar to ``a."
"update(b)`` in Python except that :c:func:`PyDict_Update` doesn't fall back "
"to the iterating over a sequence of key value pairs if the second argument "
"has no \"keys\" attribute.  Return ``0`` on success or ``-1`` if an "
"exception was raised."
msgstr ""
"Ini adalah sama dengan ``PyDict_Merge(a, b, 1)`` dalam C dan serupa dengan "
"``a.update(b)`` dalam Python kecuali :c:func:`PyDict_Update` tidak kembali "
"kepada perulangan pada jujukan pasangan kunci dengan nilai jika argumen "
"kedua tiada atribut \"keys\".  Kembalikan ``0`` jika berjaya atau ``-1`` "
"jika pengecualian telah dikemukakan."

#: ../../c-api/dict.rst:326
msgid ""
"Update or merge into dictionary *a*, from the key-value pairs in *seq2*. "
"*seq2* must be an iterable object producing iterable objects of length 2, "
"viewed as key-value pairs.  In case of duplicate keys, the last wins if "
"*override* is true, else the first wins. Return ``0`` on success or ``-1`` "
"if an exception was raised. Equivalent Python (except for the return value)::"
msgstr ""
"Kemaskinikan atau gabungkan kepada *a* kamus, daripada pasangan kunci dengan "
"nilai dalam *seq2*. *seq2* mestilah objek boleh diulang yang menghasilkan "
"objek boleh diulang dengan panjang 2, dilihat sebagai pasangan kunci dengan "
"nilai.  Jika terdapat pendua pada kunci, kunci terakhir akan menang jika "
"*override* adalah benar, jika tidak kunci pertama akan menang. Kembalikan "
"``0`` jika berjaya atau ``-1`` jika pengecualian dikemukakan. Python setara "
"(kecuali untuk nilai kembali)::"

#: ../../c-api/dict.rst:333
msgid ""
"def PyDict_MergeFromSeq2(a, seq2, override):\n"
"    for key, value in seq2:\n"
"        if override or key not in a:\n"
"            a[key] = value"
msgstr ""
"def PyDict_MergeFromSeq2(a, seq2, override):\n"
"    for key, value in seq2:\n"
"        if override or key not in a:\n"
"            a[key] = value"

#: ../../c-api/dict.rst:340
msgid ""
"Register *callback* as a dictionary watcher. Return a non-negative integer "
"id which must be passed to future calls to :c:func:`PyDict_Watch`. In case "
"of error (e.g. no more watcher IDs available), return ``-1`` and set an "
"exception."
msgstr ""
"Daftar *callback* sebagai pemerhati kamus. Kembalikan id integer bukan "
"negatif yang mesti digunakan dengan panggilan masa hadapan kepada :c:func:"
"`PyDict_Watch`. Jika ralat berlaku (contohnya, tiada lagi ID pemerhati yang "
"tersedia), kembalikan ``-1`` dan tetapkan pengecualian."

#: ../../c-api/dict.rst:349
msgid ""
"Clear watcher identified by *watcher_id* previously returned from :c:func:"
"`PyDict_AddWatcher`. Return ``0`` on success, ``-1`` on error (e.g. if the "
"given *watcher_id* was never registered.)"
msgstr ""
"Kosongkan pemerhati yang dikenal pasti oleh *watcher_id* yang sebelum ini "
"dikembalikan daripada :c:func:`PyDict_AddWatcher`. Return ``0`` jika "
"berjaya, ``-1`` jika ralat (contohnya, jika *watcher_id* yang diberikan "
"tidak berdaftar.)"

#: ../../c-api/dict.rst:357
msgid ""
"Mark dictionary *dict* as watched. The callback granted *watcher_id* by :c:"
"func:`PyDict_AddWatcher` will be called when *dict* is modified or "
"deallocated. Return ``0`` on success or ``-1`` on error."
msgstr ""
"Tandakan *dict* kamus sebagai diperhatikan. Panggilan balik yang diberikan "
"kepada *watcher_id* oleh :c:func:`PyDict_AddWatcher` akan dipanggil apabila "
"*dict* diubah suai atau dinyahuntuk. Kembalikan ``0`` jika berjaya "
"atau``-1`` jika ralat."

#: ../../c-api/dict.rst:365
msgid ""
"Mark dictionary *dict* as no longer watched. The callback granted "
"*watcher_id* by :c:func:`PyDict_AddWatcher` will no longer be called when "
"*dict* is modified or deallocated. The dict must previously have been "
"watched by this watcher. Return ``0`` on success or ``-1`` on error."
msgstr ""
"Tandakan *dict* kamus sebagai tidak lagi diperhatikan. Panggilan balik yang "
"diberikan kepada *watcher_id* oleh :c:func:`PyDict_AddWatcher` tidak lagi "
"akan dipanggil apabila *dict* diubah suai atau dinyahuntuk. dict mesti "
"diperhatikan oleh pemerhati ini sebelum ini. Kembalikan ``0`` jika berjaya "
"atau``-1`` jika ralat."

#: ../../c-api/dict.rst:374
msgid ""
"Enumeration of possible dictionary watcher events: ``PyDict_EVENT_ADDED``, "
"``PyDict_EVENT_MODIFIED``, ``PyDict_EVENT_DELETED``, "
"``PyDict_EVENT_CLONED``, ``PyDict_EVENT_CLEARED``, or "
"``PyDict_EVENT_DEALLOCATED``."
msgstr ""
"Penghitungan kemungkinan peristiwa pemerhati kamus: ``PyDict_EVENT_ADDED``, "
"``PyDict_EVENT_MODIFIED``, ``PyDict_EVENT_DELETED``, "
"``PyDict_EVENT_CLONED``, ``PyDict_EVENT_CLEARED`` atau "
"``PyDict_EVENT_DEALLOCATED``."

#: ../../c-api/dict.rst:382
msgid "Type of a dict watcher callback function."
msgstr "Jenis fungsi panggilan balik pemerhati dict."

#: ../../c-api/dict.rst:384
msgid ""
"If *event* is ``PyDict_EVENT_CLEARED`` or ``PyDict_EVENT_DEALLOCATED``, both "
"*key* and *new_value* will be ``NULL``. If *event* is ``PyDict_EVENT_ADDED`` "
"or ``PyDict_EVENT_MODIFIED``, *new_value* will be the new value for *key*. "
"If *event* is ``PyDict_EVENT_DELETED``, *key* is being deleted from the "
"dictionary and *new_value* will be ``NULL``."
msgstr ""
"Jika *event* ``PyDict_EVENT_CLEARED`` atau ``PyDict_EVENT_DEALLOCATED``, "
"kedua-dua *key* dan *new_value* adalah ``NULL``. Jika *event* adalah "
"``PyDict_EVENT_ADDED`` adalah ``PyDict_EVENT_MODIFIED``, *new_value* akan "
"menjadi nilai baharu untuk *key*. Jika *event* adalah "
"``PyDict_EVENT_DELETED``, *key* sedang dipadamkan daripada kamus dan "
"*new_value* adalah ``NULL``."

#: ../../c-api/dict.rst:390
msgid ""
"``PyDict_EVENT_CLONED`` occurs when *dict* was previously empty and another "
"dict is merged into it. To maintain efficiency of this operation, per-key "
"``PyDict_EVENT_ADDED`` events are not issued in this case; instead a single "
"``PyDict_EVENT_CLONED`` is issued, and *key* will be the source dictionary."
msgstr ""
"``PyDict_EVENT_CLONED`` berlaku apabila *dict* yang kosong sebelum ini dan "
"dict yang lain digabungkan. Untuk mengekalkan keberkesanan operasi ini, "
"peristiwa ``PyDict_EVENT_ADDED`` bagi setiap kunci tidak diterbitkan dalam "
"keadaan ini, sebaliknya ``PyDict_EVENT_CLONED`` tunggal akan diterbitkan dan "
"*key* akan menjadi kamus sumber."

#: ../../c-api/dict.rst:396
msgid ""
"The callback may inspect but must not modify *dict*; doing so could have "
"unpredictable effects, including infinite recursion. Do not trigger Python "
"code execution in the callback, as it could modify the dict as a side effect."
msgstr ""
"Panggilan balik boleh membuat pemeriksaan tetapi tidak boleh mengubah suai "
"*dict*; tindakan ini boleh menyebabkan kesan yang tidak dapat dijangka, "
"termasuk rekursi infinit. Jangan cetuskan pelaksanaan kod Python dalam "
"panggilan balik kerana tindakan ini boleh mengubah suai dict sebagai kesan "
"sampingan."

#: ../../c-api/dict.rst:400
msgid ""
"If *event* is ``PyDict_EVENT_DEALLOCATED``, taking a new reference in the "
"callback to the about-to-be-destroyed dictionary will resurrect it and "
"prevent it from being freed at this time. When the resurrected object is "
"destroyed later, any watcher callbacks active at that time will be called "
"again."
msgstr ""
"Jika *event* ialah ``PyDict_EVENT_DEALLOCATED``, penerimaan rujukan baharu "
"dalam panggilan balik kepada kamus yang akan dihapuskan akan menghidupkan "
"semula kamus dan menghalang kamus daripada dibebaskan pada masa ini. Apabila "
"objek yang dihidupkan semula dihapuskan kemudian, sebarang panggilan balik "
"pemerhati yang aktif pada masa itu akan dipanggil semula."

#: ../../c-api/dict.rst:406
msgid ""
"Callbacks occur before the notified modification to *dict* takes place, so "
"the prior state of *dict* can be inspected."
msgstr ""
"Panggilan balik berlaku sebelum pengubahsuaian kepada *dict* yang telah "
"dimaklumi berlaku, jadi keadaan *dict* yang sebelumnya boleh diperiksa."

#: ../../c-api/dict.rst:409
msgid ""
"If the callback sets an exception, it must return ``-1``; this exception "
"will be printed as an unraisable exception using :c:func:"
"`PyErr_WriteUnraisable`. Otherwise it should return ``0``."
msgstr ""
"Jika panggilan balik menetapkan pengecualian, panggilan balik mesti "
"mengembalikan ``-1``; pengecualian ini akan dicetak sebagai pengecualian "
"yang tidak dapat dikemukakan menggunakan :c:func:`PyErr_WriteUnraisable`. "
"Jika tidak, panggilan balik harus mengembalikan ``0``."

#: ../../c-api/dict.rst:413
msgid ""
"There may already be a pending exception set on entry to the callback. In "
"this case, the callback should return ``0`` with the same exception still "
"set. This means the callback may not call any other API that can set an "
"exception unless it saves and clears the exception state first, and restores "
"it before returning."
msgstr ""
"Terdapat kemungkinan sudah terdapat set pengecualian yang belum selesai pada "
"entri kepada panggilan balik. Dalam keadaan ini, panggilan balik harus "
"mengembalikan ``0`` dengan penetapan set pengecualian yang sama. Hal ini "
"bermakna panggilan balik mungkin tidak akan memanggil API lain yang boleh "
"menetapkan pengecualian melainkan panggilan balik menyimpan dan mengosongkan "
"keadaan pengecualian terlebih dahulu serta memulihkan pengecualian sebelum "
"pengembalian."

#: ../../c-api/dict.rst:8
msgid "object"
msgstr "objek"

#: ../../c-api/dict.rst:8
msgid "dictionary"
msgstr "kamus"

#: ../../c-api/dict.rst:242
msgid "built-in function"
msgstr "fungsi terbina dalam"

#: ../../c-api/dict.rst:242
msgid "len"
msgstr "len"
