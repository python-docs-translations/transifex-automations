# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-07 15:08+0000\n"
"PO-Revision-Date: 2025-07-18 19:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (https://app.transifex.com/python-doc/teams/5390/"
"zh/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../whatsnew/2.0.rst:3
msgid "What's New in Python 2.0"
msgstr "Co nowego w Python 2.0"

#: ../../whatsnew/2.0.rst:0
msgid "Author"
msgstr "作者"

#: ../../whatsnew/2.0.rst:5
msgid "A.M. Kuchling and Moshe Zadka"
msgstr "A.M. Kuchling i Moshe Zadka"

#: ../../whatsnew/2.0.rst:13
msgid "Introduction"
msgstr "Wprowadzenie"

#: ../../whatsnew/2.0.rst:15
msgid ""
"A new release of Python, version 2.0, was released on October 16, 2000. This "
"article covers the exciting new features in 2.0, highlights some other "
"useful changes, and points out a few incompatible changes that may require "
"rewriting code."
msgstr ""
"Nowa wersja Pythona, wersja 2.0, została wydana 16 października 2000 r. W "
"tym artykule omówiono ekscytujące nowe funkcje wersji 2.0, zwrócono uwagę na "
"kilka innych przydatnych zmian i wskazano kilka niekompatybilnych zmian, "
"które mogą wymagać przepisania kodu od nowa."

#: ../../whatsnew/2.0.rst:20
msgid ""
"Python's development never completely stops between releases, and a steady "
"flow of bug fixes and improvements are always being submitted. A host of "
"minor fixes, a few optimizations, additional docstrings, and better error "
"messages went into 2.0; to list them all would be impossible, but they're "
"certainly significant. Consult the publicly available CVS logs if you want "
"to see the full list.  This progress is due to the five developers working "
"for  PythonLabs are now getting paid to spend their days fixing bugs, and "
"also due to the improved communication resulting  from moving to SourceForge."
msgstr ""
"Разработка Python никогда полностью не прекращается между выпусками, и "
"всегда поступает постоянный поток исправлений ошибок и улучшений. В версию "
"2.0 вошло множество мелких исправлений, несколько оптимизаций, "
"дополнительные строки документации и улучшенные сообщения об ошибках; "
"перечислить их все было бы невозможно, но они, безусловно, значительны. Если "
"вы хотите увидеть полный список, обратитесь к общедоступным журналам CVS. "
"Этот прогресс обусловлен тем, что пятерым разработчикам, работающим в "
"PythonLabs, теперь платят за то, что они тратят свое время на исправление "
"ошибок, а также благодаря улучшению взаимодействия в результате перехода на "
"SourceForge."

#: ../../whatsnew/2.0.rst:33
msgid "What About Python 1.6?"
msgstr "Co z Pythonem 1.6?"

#: ../../whatsnew/2.0.rst:35
msgid ""
"Python 1.6 can be thought of as the Contractual Obligations Python release. "
"After the core development team left CNRI in May 2000, CNRI requested that a "
"1.6 release be created, containing all the work on Python that had been "
"performed at CNRI.  Python 1.6 therefore represents the state of the CVS "
"tree as of May 2000, with the most significant new feature being Unicode "
"support.  Development continued after May, of course, so the 1.6 tree "
"received a few fixes to ensure that it's forward-compatible with Python "
"2.0.  1.6 is therefore part of Python's evolution, and not a side branch."
msgstr ""
"Python 1.6 można traktować jako wydanie Pythona zobowiązań umownych. Po tym, "
"jak główny zespół programistów opuścił CNRI w maju 2000 roku, CNRI poprosiło "
"o stworzenie wydania 1.6, zawierającego wszystkie prace nad Pythonem, które "
"zostały wykonane w CNRI. Python 1.6 reprezentuje zatem stan drzewa CVS w "
"maju 2000 roku, a najważniejszą nową funkcją jest obsługa Unicode. Rozwój "
"kontynuowano oczywiście po maju, więc drzewo 1.6 otrzymało kilka poprawek, "
"aby zapewnić jego zgodność z Pythonem 2.0. 1.6 jest zatem częścią ewolucji "
"Pythona, a nie poboczną gałęzią."

#: ../../whatsnew/2.0.rst:44
msgid ""
"So, should you take much interest in Python 1.6?  Probably not.  The "
"1.6final and 2.0beta1 releases were made on the same day (September 5, "
"2000), the plan being to finalize Python 2.0 within a month or so.  If you "
"have applications to maintain, there seems little point in breaking things "
"by moving to 1.6, fixing them, and then having another round of breakage "
"within a month by moving to 2.0; you're better off just going straight to "
"2.0.  Most of the really interesting features described in this document are "
"only in 2.0, because a lot of work was done between May and September."
msgstr ""
"Отже, чи варто сильно цікавитися Python 1.6? Напевно ні. Релізи 1.6final і "
"2.0beta1 були зроблені в один і той же день (5 вересня 2000 р.), планом було "
"завершити Python 2.0 протягом місяця або близько того. Якщо у вас є додатки, "
"які потрібно підтримувати, здається, немає сенсу ламати роботу, переходячи "
"до 1.6, виправляючи їх, а потім мати ще один цикл поломок протягом місяця, "
"переходячи до 2.0; вам краще просто перейти до 2.0. Більшість справді "
"цікавих функцій, описаних у цьому документі, є лише у версії 2.0, оскільки з "
"травня по вересень було виконано багато роботи."

#: ../../whatsnew/2.0.rst:57
msgid "New Development Process"
msgstr "Nowy proces rozwoju"

#: ../../whatsnew/2.0.rst:59
msgid ""
"The most important change in Python 2.0 may not be to the code at all, but "
"to how Python is developed: in May 2000 the Python developers began using "
"the tools made available by SourceForge for storing  source code, tracking "
"bug reports, and managing the queue of patch submissions.  To report bugs or "
"submit patches for Python 2.0, use the bug tracking and patch manager tools "
"available from Python's project page, located at https://sourceforge.net/"
"projects/python/."
msgstr ""
"Найважливіша зміна в Python 2.0 може стосуватися зовсім не коду, а способу "
"розробки Python: у травні 2000 року розробники Python почали використовувати "
"інструменти, надані SourceForge для зберігання вихідного коду, відстеження "
"звітів про помилки та керування чергою. подання патчів. Щоб повідомити про "
"помилки або надіслати виправлення для Python 2.0, використовуйте інструменти "
"відстеження помилок і керування виправленнями, доступні на сторінці проекту "
"Python, розташованій за адресою https://sourceforge.net/projects/python/."

#: ../../whatsnew/2.0.rst:66
msgid ""
"The most important of the services now hosted at SourceForge is the Python "
"CVS tree, the version-controlled repository containing the source code for "
"Python. Previously, there were roughly 7 or so people who had write access "
"to the CVS tree, and all patches had to be inspected and checked in by one "
"of the people on this short list. Obviously, this wasn't very scalable.  By "
"moving the CVS tree to SourceForge, it became possible to grant write access "
"to more people; as of September 2000 there were 27 people able to check in "
"changes, a fourfold increase.  This makes possible large-scale changes that "
"wouldn't be attempted if they'd have to be filtered through the small group "
"of core developers.  For example, one day Peter Schneider-Kamp took it into "
"his head to drop K&R C compatibility and convert the C source for Python to "
"ANSI C. After getting approval on the python-dev mailing list, he launched "
"into a flurry of checkins that lasted about a week, other developers joined "
"in to help, and the job was done.  If there were only 5 people with write "
"access, probably that task would have been viewed as \"nice, but not worth "
"the time and effort needed\" and it would never have gotten done."
msgstr ""
"Найважливішою з послуг, які зараз розміщені на SourceForge, є дерево Python "
"CVS, репозиторій з контрольованими версіями, що містить вихідний код для "
"Python. Раніше було приблизно 7 або близько того людей, які мали доступ для "
"запису до дерева CVS, і всі латки повинні були бути перевірені та "
"зареєстровані одним із людей у цьому короткому списку. Очевидно, що це було "
"не дуже масштабовано. Завдяки переміщенню дерева CVS до SourceForge стало "
"можливим надати доступ для запису більшій кількості людей; станом на "
"вересень 2000 року було 27 осіб, які могли перевірити зміни, тобто "
"чотириразове збільшення. Це робить можливими масштабні зміни, які б не були "
"зроблені, якби їх довелося фільтрувати через невелику групу основних "
"розробників. Наприклад, одного разу Пітер Шнайдер-Камп спав на думку "
"відмовитися від сумісності з K&R C і перетворити вихідний код C для Python "
"на ANSI C. Отримавши схвалення в списку розсилки python-dev, він розпочав "
"шквал перевірок, які тривали близько тижня інші розробники приєдналися, щоб "
"допомогти, і роботу було виконано. Якби було лише 5 осіб із доступом для "
"запису, ймовірно, це завдання було б сприйняте як \"гарне, але не варте "
"потрібного часу та зусиль\", і воно ніколи не було б виконане."

#: ../../whatsnew/2.0.rst:83
msgid ""
"The shift to using SourceForge's services has resulted in a remarkable "
"increase in the speed of development.  Patches now get submitted, commented "
"on, revised by people other than the original submitter, and bounced back "
"and forth between people until the patch is deemed worth checking in.  Bugs "
"are tracked in one central location and can be assigned to a specific person "
"for fixing, and we can count the number of open bugs to measure progress.  "
"This didn't come without a cost: developers now have more e-mail to deal "
"with, more mailing lists to follow, and special tools had to be written for "
"the new environment. For example, SourceForge sends default patch and bug "
"notification e-mail messages that are completely unhelpful, so Ka-Ping Yee "
"wrote an HTML screen-scraper that sends more useful messages."
msgstr ""
"Перехід до використання послуг SourceForge призвів до значного збільшення "
"швидкості розробки. Патчі тепер надсилаються, коментуються, переглядаються "
"людьми, які не були початковим відправником, і обмінюються між людьми, доки "
"виправлення не буде визнано вартим перевірки. Помилки відстежуються в одному "
"центральному місці та можуть бути призначені конкретній особі для "
"виправлення , і ми можемо підрахувати кількість відкритих помилок для "
"вимірювання прогресу. Це не обійшлося без витрат: розробники тепер мають "
"більше електронної пошти, щоб мати справу з більшою кількістю списків "
"розсилки, і для нового середовища потрібно було написати спеціальні "
"інструменти. Наприклад, SourceForge надсилає повідомлення електронною поштою "
"про стандартні виправлення та сповіщення про помилки, які абсолютно марні, "
"тому Ka-Ping Yee написав HTML-скрейпер, який надсилає більш корисні "
"повідомлення."

#: ../../whatsnew/2.0.rst:95
msgid ""
"The ease of adding code caused a few initial growing pains, such as code was "
"checked in before it was ready or without getting clear agreement from the "
"developer group.  The approval process that has emerged is somewhat similar "
"to that used by the Apache group. Developers can vote +1, +0, -0, or -1 on a "
"patch; +1 and -1 denote acceptance or rejection, while +0 and -0 mean the "
"developer is mostly indifferent to the change, though with a slight positive "
"or negative slant.  The most significant change from the Apache model is "
"that the voting is essentially advisory, letting Guido van Rossum, who has "
"Benevolent Dictator For Life status, know what the general opinion is. He "
"can still ignore the result of a vote, and approve or reject a change even "
"if the community disagrees with him."
msgstr ""
"Легкість додавання коду спричинила кілька початкових труднощів, наприклад "
"код перевірявся до того, як він був готовий, або без отримання чіткої згоди "
"від групи розробників. Процес затвердження, який з’явився, дещо схожий на "
"той, який використовується групою Apache. Розробники можуть голосувати за "
"патч +1, +0, -0 або -1; +1 і -1 означають прийняття або відхилення, тоді як "
"+0 і -0 означають, що розробник здебільшого байдужий до змін, хоча з "
"невеликим позитивним або негативним ухилом. Найсуттєвішою зміною в "
"порівнянні з моделлю Apache є те, що голосування є, по суті, дорадчим, "
"дозволяючи Гвідо ван Россуму, який має статус доброзичливого довічного "
"диктатора, знати, якою є загальна думка. Він все ще може ігнорувати "
"результати голосування та схвалити або відхилити зміни, навіть якщо "
"спільнота з ним не погоджується."

#: ../../whatsnew/2.0.rst:106
msgid ""
"Producing an actual patch is the last step in adding a new feature, and is "
"usually easy compared to the earlier task of coming up with a good design. "
"Discussions of new features can often explode into lengthy mailing list "
"threads, making the discussion hard to follow, and no one can read every "
"posting to python-dev.  Therefore, a relatively formal process has been set "
"up to write Python Enhancement Proposals (PEPs), modelled on the internet "
"RFC process.  PEPs are draft documents that describe a proposed new feature, "
"and are continually revised until the community reaches a consensus, either "
"accepting or rejecting the proposal.  Quoting from the introduction to :pep:"
"`1`, \"PEP Purpose and Guidelines\":"
msgstr ""
"Створення фактичного патча є останнім кроком у додаванні нової функції, і "
"зазвичай це легко порівняно з попереднім завданням створення гарного "
"дизайну. Обговорення нових функцій часто може вибухнути в довгі ланцюжки "
"списків розсилки, що ускладнює стеження за обговоренням, і ніхто не може "
"прочитати кожну публікацію на python-dev. Тому було створено відносно "
"формальний процес для написання пропозицій щодо покращення Python (PEP), "
"змодельований на основі процесу RFC в Інтернеті. PEPs — це проекти "
"документів, які описують запропоновану нову функцію, і постійно "
"переглядаються, доки спільнота не досягне консенсусу, прийняти або відхилити "
"пропозицію. Цитата зі вступу до :pep:`1`, \"Мета PEP і рекомендації\":"

#: ../../whatsnew/2.0.rst:120
msgid ""
"PEP stands for Python Enhancement Proposal.  A PEP is a design document "
"providing information to the Python community, or describing a new feature "
"for Python.  The PEP should provide a concise technical specification of the "
"feature and a rationale for the feature."
msgstr ""
"PEP розшифровується як Python Enhancement Proposal. PEP — це проектний "
"документ, який надає інформацію спільноті Python або описує нову функцію для "
"Python. PEP має надавати стислу технічну специфікацію функції та "
"обґрунтування цієї функції."

#: ../../whatsnew/2.0.rst:125
msgid ""
"We intend PEPs to be the primary mechanisms for proposing new features, for "
"collecting community input on an issue, and for documenting the design "
"decisions that have gone into Python.  The PEP author is responsible for "
"building consensus within the community and documenting dissenting opinions."
msgstr ""
"Ми плануємо, щоб PEP були основними механізмами для пропонування нових "
"функцій, для збору внесків спільноти щодо проблеми та для документування "
"дизайнерських рішень, які увійшли до Python. Автор PEP відповідає за "
"формування консенсусу в спільноті та документування особливих думок."

#: ../../whatsnew/2.0.rst:130
msgid ""
"Read the rest of :pep:`1` for the details of the PEP editorial process, "
"style, and format.  PEPs are kept in the Python CVS tree on SourceForge, "
"though they're not part of the Python 2.0 distribution, and are also "
"available in HTML form from https://peps.python.org/.  As of September 2000, "
"there are 25 PEPs, ranging from :pep:`201`, \"Lockstep Iteration\", to PEP "
"225, \"Elementwise/Objectwise Operators\"."
msgstr ""
"Прочтите остальную часть :pep:`1` для получения подробной информации о "
"редакционном процессе, стиле и формате PEP. PEP хранятся в дереве Python CVS "
"на SourceForge, хотя они не являются частью дистрибутива Python 2.0, а также "
"доступны в форме HTML на https://peps.python.org/. По состоянию на сентябрь "
"2000 года существует 25 PEP, от :pep:`201`, «Локпоинтовая итерация», до PEP "
"225, «Элементные/объектные операторы»."

#: ../../whatsnew/2.0.rst:141
msgid "Unicode"
msgstr "Unicode"

#: ../../whatsnew/2.0.rst:143
msgid ""
"The largest new feature in Python 2.0 is a new fundamental data type: "
"Unicode strings.  Unicode uses 16-bit numbers to represent characters "
"instead of the 8-bit number used by ASCII, meaning that 65,536 distinct "
"characters can be supported."
msgstr ""
"Найбільшою новою функцією Python 2.0 є новий фундаментальний тип даних: "
"рядки Unicode. Юнікод використовує 16-розрядні числа для представлення "
"символів замість 8-розрядних чисел, які використовуються в ASCII, тобто "
"підтримується 65 536 різних символів."

#: ../../whatsnew/2.0.rst:148
msgid ""
"The final interface for Unicode support was arrived at through countless "
"often-stormy discussions on the python-dev mailing list, and mostly "
"implemented by Marc-André Lemburg, based on a Unicode string type "
"implementation by Fredrik Lundh.  A detailed explanation of the interface "
"was written up as :pep:`100`, \"Python Unicode Integration\". This article "
"will simply cover the most significant points about the Unicode interfaces."
msgstr ""
"Остаточний інтерфейс для підтримки Unicode був досягнутий під час "
"незліченних, часто бурхливих дискусій у списку розсилки python-dev, і "
"здебільшого реалізований Марком-Андре Лембургом на основі реалізації "
"рядкового типу Unicode Фредріком Лундом. Детальне пояснення інтерфейсу було "
"написано як :pep:`100`, \"Інтеграція Python Unicode\". Ця стаття лише "
"охопить найважливіші моменти щодо інтерфейсів Unicode."

#: ../../whatsnew/2.0.rst:155
msgid ""
"In Python source code, Unicode strings are written as ``u\"string\"``.  "
"Arbitrary Unicode characters can be written using a new escape sequence, :"
"samp:`\\\\u{HHHH}`, where *HHHH* is a 4-digit hexadecimal number from 0000 "
"to FFFF.  The existing :samp:`\\\\x{HH}` escape sequence can also be used, "
"and octal escapes can be used for characters up to U+01FF, which is "
"represented by ``\\777``."
msgstr ""
"В исходном коде Python строки Unicode записываются как ``u\"string\"``. "
"Произвольные символы Юникода можно записывать с использованием новой escape-"
"последовательности: :samp:`\\\\u{HHHH}`, где *HHHH* — 4-значное "
"шестнадцатеричное число от 0000 до FFFF. Также можно использовать "
"существующую escape-последовательность :samp:`\\\\x{HH}`, а восьмеричные "
"escape-последовательности можно использовать для символов до U+01FF, что "
"представлено ``\\777``."

#: ../../whatsnew/2.0.rst:161
msgid ""
"Unicode strings, just like regular strings, are an immutable sequence type. "
"They can be indexed and sliced, but not modified in place. Unicode strings "
"have an ``encode( [encoding] )`` method that returns an 8-bit string in the "
"desired encoding.  Encodings are named by strings, such as ``'ascii'``, "
"``'utf-8'``, ``'iso-8859-1'``, or whatever.  A codec API is defined for "
"implementing and registering new encodings that are then available "
"throughout a Python program. If an encoding isn't specified, the default "
"encoding is usually 7-bit ASCII, though it can be changed for your Python "
"installation by calling the ``sys.setdefaultencoding(encoding)`` function in "
"a customized version of :file:`site.py`."
msgstr ""
"Рядки Unicode, як і звичайні рядки, є незмінним типом послідовності. Їх "
"можна індексувати та нарізати, але не змінювати на місці. Рядки Unicode "
"мають метод ``encode( [encoding] )``, який повертає 8-бітовий рядок у "
"потрібному кодуванні. Кодування називаються рядками, наприклад ``'ascii'``, "
"``'utf-8''``, ``'iso-8859-1''`` або будь-яким іншим. Кодек API визначено для "
"реалізації та реєстрації нових кодувань, які потім доступні в усій програмі "
"Python. Якщо кодування не вказано, кодуванням за замовчуванням зазвичай є 7-"
"бітний ASCII, хоча його можна змінити для інсталяції Python, викликавши "
"функцію ``sys.setdefaultencoding(encoding)`` у налаштованій версії :file:"
"`site.py`."

#: ../../whatsnew/2.0.rst:172
msgid ""
"Combining 8-bit and Unicode strings always coerces to Unicode, using the "
"default ASCII encoding; the result of ``'a' + u'bc'`` is ``u'abc'``."
msgstr ""
"Комбінування 8-бітових рядків і рядків Unicode завжди приводить до Unicode, "
"використовуючи стандартне кодування ASCII; результатом ``'a' + u'bc'`` є "
"``u'abc``."

#: ../../whatsnew/2.0.rst:175
msgid ""
"New built-in functions have been added, and existing built-ins modified to "
"support Unicode:"
msgstr ""
"Додано нові вбудовані функції, а наявні вбудовані модифіковано для підтримки "
"Unicode:"

#: ../../whatsnew/2.0.rst:178
msgid ""
"``unichr(ch)`` returns a Unicode string 1 character long, containing the "
"character *ch*."
msgstr ""
"``unichr(ch)`` повертає рядок Unicode довжиною 1 символ, що містить символ "
"*ch*."

#: ../../whatsnew/2.0.rst:181
msgid ""
"``ord(u)``, where *u* is a 1-character regular or Unicode string, returns "
"the number of the character as an integer."
msgstr ""
"``ord(u)``, де *u* — звичайний рядок із 1 символу або Unicode, повертає "
"номер символу як ціле число."

#: ../../whatsnew/2.0.rst:184
msgid ""
"``unicode(string [, encoding]  [, errors] )`` creates a Unicode string from "
"an 8-bit string.  ``encoding`` is a string naming the encoding to use. The "
"``errors`` parameter specifies the treatment of characters that are invalid "
"for the current encoding; passing ``'strict'`` as the value causes an "
"exception to be raised on any encoding error, while ``'ignore'`` causes "
"errors to be silently ignored and ``'replace'`` uses U+FFFD, the official "
"replacement character, in case of any problems."
msgstr ""
"``unicode(string [, encoding] [, errors] )`` створює рядок Unicode з 8-"
"бітного рядка. ``encoding`` - це рядок із назвою кодування для використання. "
"Параметр ``errors`` визначає обробку символів, недійсних для поточного "
"кодування; передача ``'strict'`` як значення спричиняє виникнення винятку "
"при будь-якій помилці кодування, тоді ``'ignore'`` спричиняє мовчазне "
"ігнорування помилок, а ``'replace'`` використовує U+FFFD, офіційний замінний "
"характер, у разі будь-яких проблем."

#: ../../whatsnew/2.0.rst:192
msgid ""
"The ``exec`` statement, and various built-ins such as ``eval()``, "
"``getattr()``, and ``setattr()`` will also accept Unicode strings as well as "
"regular strings.  (It's possible that the process of fixing this missed some "
"built-ins; if you find a built-in function that accepts strings but doesn't "
"accept Unicode strings at all, please report it as a bug.)"
msgstr ""
"Оператор ``exec`` і різні вбудовані функції, такі як ``eval()``, "
"``getattr()`` і ``setattr()`` також прийматимуть рядки Unicode, а також "
"звичайні рядки. (Цілком можливо, що під час виправлення цього не вистачало "
"деяких вбудованих функцій; якщо ви знайдете вбудовану функцію, яка приймає "
"рядки, але взагалі не приймає рядки Unicode, повідомте про це як про "
"помилку.)"

#: ../../whatsnew/2.0.rst:198
msgid ""
"A new module, :mod:`unicodedata`, provides an interface to Unicode character "
"properties.  For example, ``unicodedata.category(u'A')`` returns the 2-"
"character string 'Lu', the 'L' denoting it's a letter, and 'u' meaning that "
"it's uppercase. ``unicodedata.bidirectional(u'\\u0660')`` returns 'AN', "
"meaning that U+0660 is an Arabic number."
msgstr ""
"Новий модуль, :mod:`unicodedata`, надає інтерфейс для властивостей символів "
"Unicode. Наприклад, ``unicodedata.category(u'A')`` повертає 2-символьний "
"рядок 'Lu', 'L' означає, що це літера, і 'u' означає, що це великий регістр. "
"``unicodedata.bidirectional(u'\\u0660')`` повертає 'AN', що означає, що "
"U+0660 є арабським числом."

#: ../../whatsnew/2.0.rst:204
msgid ""
"The :mod:`codecs` module contains functions to look up existing encodings "
"and register new ones.  Unless you want to implement a new encoding, you'll "
"most often use the ``codecs.lookup(encoding)`` function, which returns a 4-"
"element tuple: ``(encode_func, decode_func, stream_reader, stream_writer)``."
msgstr ""
"Модуль :mod:`codecs` містить функції для пошуку існуючих кодувань і "
"реєстрації нових. Якщо ви не хочете застосувати нове кодування, ви "
"найчастіше використовуватимете функцію ``codecs.lookup(encoding)``, яка "
"повертає 4-елементний кортеж: ``(encode_func, decode_func, stream_reader, "
"stream_writer)``."

#: ../../whatsnew/2.0.rst:209
msgid ""
"*encode_func* is a function that takes a Unicode string, and returns a 2-"
"tuple ``(string, length)``.  *string* is an 8-bit string containing a "
"portion (perhaps all) of the Unicode string converted into the given "
"encoding, and *length* tells you how much of the Unicode string was "
"converted."
msgstr ""
"*encode_func* — це функція, яка приймає рядок Unicode і повертає 2-кортеж "
"``(рядок, довжина)``. *рядок* — це 8-бітовий рядок, що містить частину "
"(можливо, весь) рядка Юнікод, перетвореного в дане кодування, а *довжина* "
"вказує вам, яку частину рядка Юнікод було перетворено."

#: ../../whatsnew/2.0.rst:214
msgid ""
"*decode_func* is the opposite of *encode_func*, taking an 8-bit string and "
"returning a 2-tuple ``(ustring, length)``, consisting of the resulting "
"Unicode string *ustring* and the integer *length* telling how much of the 8-"
"bit string was consumed."
msgstr ""
"*decode_func* є протилежністю *encode_func*, беручи 8-бітний рядок і "
"повертаючи 2-кортеж ``(ustring, length)``, що складається з результуючого "
"рядка Unicode *ustring* і цілого числа *length*, що повідомляє, як велика "
"частина 8-бітного рядка була спожита."

#: ../../whatsnew/2.0.rst:219
msgid ""
"*stream_reader* is a class that supports decoding input from a stream. "
"*stream_reader(file_obj)* returns an object that supports the :meth:`!"
"read`, :meth:`!readline`, and :meth:`!readlines` methods.  These methods "
"will all translate from the given encoding and return Unicode strings."
msgstr ""
"*stream_reader* — это класс, который поддерживает декодирование входных "
"данных из потока. *stream_reader(file_obj)* возвращает объект, который "
"поддерживает методы :meth:`!read`, :meth:`!readline` и :meth:`!readlines`. "
"Все эти методы будут переводить данные из заданной кодировки и возвращать "
"строки Юникода."

#: ../../whatsnew/2.0.rst:224
msgid ""
"*stream_writer*, similarly, is a class that supports encoding output to a "
"stream.  *stream_writer(file_obj)* returns an object that supports the :meth:"
"`!write` and :meth:`!writelines` methods.  These methods expect Unicode "
"strings, translating them to the given encoding on output."
msgstr ""
"*stream_writer* аналогично является классом, который поддерживает "
"кодирование вывода в поток. *stream_writer(file_obj)* возвращает объект, "
"который поддерживает методы :meth:`!write` и :meth:`!writelines`. Эти методы "
"ожидают строки Unicode, переводя их в заданную кодировку на выходе."

#: ../../whatsnew/2.0.rst:229
msgid ""
"For example, the following code writes a Unicode string into a file,  "
"encoding it as UTF-8::"
msgstr ""
"Наприклад, наступний код записує рядок Unicode у файл, кодуючи його як "
"UTF-8::"

#: ../../whatsnew/2.0.rst:232
msgid ""
"import codecs\n"
"\n"
"unistr = u'\\u0660\\u2000ab ...'\n"
"\n"
"(UTF8_encode, UTF8_decode,\n"
" UTF8_streamreader, UTF8_streamwriter) = codecs.lookup('UTF-8')\n"
"\n"
"output = UTF8_streamwriter( open( '/tmp/output', 'wb') )\n"
"output.write( unistr )\n"
"output.close()"
msgstr ""

#: ../../whatsnew/2.0.rst:243
msgid "The following code would then read UTF-8 input from the file::"
msgstr "Poniższy kod odczytałby wtedy wejście UTF-8 z pliku::"

#: ../../whatsnew/2.0.rst:245
msgid ""
"input = UTF8_streamreader( open( '/tmp/output', 'rb') )\n"
"print repr(input.read())\n"
"input.close()"
msgstr ""

#: ../../whatsnew/2.0.rst:249
msgid ""
"Unicode-aware regular expressions are available through the :mod:`re` "
"module, which has a new underlying implementation called SRE written by "
"Fredrik Lundh of Secret Labs AB."
msgstr ""
"Регулярні вирази з підтримкою Unicode доступні через модуль :mod:`re`, який "
"має нову реалізацію під назвою SRE, написану Фредріком Лундом з Secret Labs "
"AB."

#: ../../whatsnew/2.0.rst:253
msgid ""
"A ``-U`` command line option was added which causes the Python compiler to "
"interpret all string literals as Unicode string literals. This is intended "
"to be used in testing and future-proofing your Python code, since some "
"future version of Python may drop support for 8-bit strings and provide only "
"Unicode strings."
msgstr ""
"Додано параметр командного рядка ``-U``, який змушує компілятор Python "
"інтерпретувати всі рядкові літерали як рядкові літерали Unicode. Це "
"призначено для тестування та перевірки вашого коду Python на майбутнє, "
"оскільки деякі майбутні версії Python можуть відмовитися від підтримки 8-"
"бітних рядків і надавати лише рядки Unicode."

#: ../../whatsnew/2.0.rst:262
msgid "List Comprehensions"
msgstr "Wyrażenia listowe"

#: ../../whatsnew/2.0.rst:264
msgid ""
"Lists are a workhorse data type in Python, and many programs manipulate a "
"list at some point.  Two common operations on lists are to loop over them, "
"and either pick out the elements that meet a certain criterion, or apply "
"some function to each element.  For example, given a list of strings, you "
"might want to pull out all the strings containing a given substring, or "
"strip off trailing whitespace from each line."
msgstr ""
"Списки є основним типом даних у Python, і багато програм маніпулюють списком "
"у певний момент. Дві поширені операції зі списками полягають у проходженні "
"по ним і або виборі елементів, які відповідають певному критерію, або "
"застосуванні певної функції до кожного елемента. Наприклад, маючи список "
"рядків, ви можете вилучити всі рядки, що містять даний підрядок, або "
"видалити кінцеві пробіли з кожного рядка."

#: ../../whatsnew/2.0.rst:271
msgid ""
"The existing :func:`map` and :func:`filter` functions can be used for this "
"purpose, but they require a function as one of their arguments.  This is "
"fine if there's an existing built-in function that can be passed directly, "
"but if there isn't, you have to create a little function to do the required "
"work, and Python's scoping rules make the result ugly if the little function "
"needs additional information.  Take the first example in the previous "
"paragraph, finding all the strings in the list containing a given "
"substring.  You could write the following to do it::"
msgstr ""
"Існуючі функції :func:`map` і :func:`filter` можна використовувати для цієї "
"мети, але вони потребують функції як один із своїх аргументів. Це добре, "
"якщо існує вбудована функція, яку можна передати напряму, але якщо її немає, "
"вам доведеться створити невелику функцію для виконання необхідної роботи, а "
"правила визначення області Python роблять результат негарним, якщо маленька "
"функція потребує Додаткова інформація. Розглянемо перший приклад із "
"попереднього абзацу, знайшовши всі рядки у списку, що містить заданий "
"підрядок. Щоб це зробити, ви можете написати наступне:"

#: ../../whatsnew/2.0.rst:280
msgid ""
"# Given the list L, make a list of all strings\n"
"# containing the substring S.\n"
"sublist = filter( lambda s, substring=S:\n"
"                     string.find(s, substring) != -1,\n"
"                  L)"
msgstr ""

#: ../../whatsnew/2.0.rst:286
msgid ""
"Because of Python's scoping rules, a default argument is used so that the "
"anonymous function created by the :keyword:`lambda` expression knows what "
"substring is being searched for.  List comprehensions make this cleaner::"
msgstr ""
"Через правила визначення області Python використовується аргумент за "
"замовчуванням, щоб анонімна функція, створена виразом :keyword:`lambda`, "
"знала, який підрядок шукається. Розуміння списків робить це чистішим::"

#: ../../whatsnew/2.0.rst:290
msgid "sublist = [ s for s in L if string.find(s, S) != -1 ]"
msgstr ""

#: ../../whatsnew/2.0.rst:292
msgid "List comprehensions have the form::"
msgstr "Listy składane mają postać::"

#: ../../whatsnew/2.0.rst:294
msgid ""
"[ expression for expr in sequence1\n"
"             for expr2 in sequence2 ...\n"
"             for exprN in sequenceN\n"
"             if condition ]"
msgstr ""

#: ../../whatsnew/2.0.rst:299
msgid ""
"The :keyword:`!for`...\\ :keyword:`!in` clauses contain the sequences to be "
"iterated over.  The sequences do not have to be the same length, because "
"they are *not* iterated over in parallel, but from left to right; this is "
"explained more clearly in the following paragraphs.  The elements of the "
"generated list will be the successive values of *expression*.  The final :"
"keyword:`!if` clause is optional; if present, *expression* is only evaluated "
"and added to the result if *condition* is true."
msgstr ""
"Речення :keyword:`!for`...\\ :keyword:`!in` містять послідовності, які "
"потрібно повторити. Послідовності не обов’язково мають бути однакової "
"довжини, тому що вони *не* повторюються паралельно, а зліва направо; це "
"більш чітко пояснюється в наступних параграфах. Елементи згенерованого "
"списку будуть послідовними значеннями *виразу*. Останній пункт :keyword:`!"
"if` необов’язковий; якщо присутнє, *вираз* обчислюється та додається до "
"результату, лише якщо *умова* істинна."

#: ../../whatsnew/2.0.rst:307
msgid ""
"To make the semantics very clear, a list comprehension is equivalent to the "
"following Python code::"
msgstr ""
"Щоб зробити семантику дуже зрозумілою, розуміння списку еквівалентно "
"наступному коду Python:"

#: ../../whatsnew/2.0.rst:310
msgid ""
"for expr1 in sequence1:\n"
"    for expr2 in sequence2:\n"
"    ...\n"
"        for exprN in sequenceN:\n"
"             if (condition):\n"
"                  # Append the value of\n"
"                  # the expression to the\n"
"                  # resulting list."
msgstr ""

#: ../../whatsnew/2.0.rst:319
msgid ""
"This means that when there are multiple :keyword:`!for`...\\ :keyword:`!in` "
"clauses, the resulting list will be equal to the product of the lengths of "
"all the sequences.  If you have two lists of length 3, the output list is 9 "
"elements long::"
msgstr ""
"Це означає, що коли є кілька пропозицій :keyword:`!for`...\\ :keyword:`!in`, "
"результуючий список дорівнюватиме добутку довжин усіх послідовностей. Якщо у "
"вас є два списки довжиною 3, вихідний список складається з 9 елементів:"

#: ../../whatsnew/2.0.rst:324
msgid ""
"seq1 = 'abc'\n"
"seq2 = (1,2,3)\n"
">>> [ (x,y) for x in seq1 for y in seq2]\n"
"[('a', 1), ('a', 2), ('a', 3), ('b', 1), ('b', 2), ('b', 3), ('c', 1),\n"
"('c', 2), ('c', 3)]"
msgstr ""

#: ../../whatsnew/2.0.rst:330
msgid ""
"To avoid introducing an ambiguity into Python's grammar, if *expression* is "
"creating a tuple, it must be surrounded with parentheses.  The first list "
"comprehension below is a syntax error, while the second one is correct::"
msgstr ""
"Щоб уникнути неоднозначності в граматиці Python, якщо *вираз* створює "
"кортеж, його потрібно взяти в дужки. Перше розуміння списку нижче є "
"синтаксичною помилкою, тоді як друге є правильним:"

#: ../../whatsnew/2.0.rst:334
msgid ""
"# Syntax error\n"
"[ x,y for x in seq1 for y in seq2]\n"
"# Correct\n"
"[ (x,y) for x in seq1 for y in seq2]"
msgstr ""

#: ../../whatsnew/2.0.rst:339
msgid ""
"The idea of list comprehensions originally comes from the functional "
"programming language Haskell (https://www.haskell.org).  Greg Ewing argued "
"most effectively for adding them to Python and wrote the initial list "
"comprehension patch, which was then discussed for a seemingly endless time "
"on the python-dev mailing list and kept up-to-date by Skip Montanaro."
msgstr ""
"Ідея розуміння списків спочатку походить від функціональної мови "
"програмування Haskell (https://www.haskell.org). Ґреґ Юінг найбільш "
"ефективно доводив доцільність додавання їх до Python і написав початковий "
"патч для розуміння списку, який потім, здавалося, нескінченний час "
"обговорювався в списку розсилки python-dev і постійно оновлювався Скіпом "
"Монтанаро."

#: ../../whatsnew/2.0.rst:349
msgid "Augmented Assignment"
msgstr "Доповнене завдання"

#: ../../whatsnew/2.0.rst:351
msgid ""
"Augmented assignment operators, another long-requested feature, have been "
"added to Python 2.0.  Augmented assignment operators include ``+=``, ``-=``, "
"``*=``, and so forth.  For example, the statement ``a += 2`` increments the "
"value of the variable  ``a`` by 2, equivalent to the slightly lengthier ``a "
"= a + 2``."
msgstr ""
"До Python 2.0 додано розширені оператори присвоєння, ще одну давно "
"запитувану функцію. Розширені оператори присвоєння включають ``+=``, ``-=``, "
"``*=`` і так далі. Наприклад, оператор ``a += 2`` збільшує значення змінної "
"``a`` на 2, еквівалентно трохи довшому ``a = a + 2``."

#: ../../whatsnew/2.0.rst:356
msgid ""
"The full list of supported assignment operators is ``+=``, ``-=``, ``*=``, "
"``/=``, ``%=``, ``**=``, ``&=``, ``|=``, ``^=``, ``>>=``, and ``<<=``.  "
"Python classes can override the augmented assignment operators by defining "
"methods named :meth:`!__iadd__`, :meth:`!__isub__`, etc.  For example, the "
"following :class:`!Number` class stores a number and supports using += to "
"create a new instance with an incremented value."
msgstr ""
"Полный список поддерживаемых операторов присваивания: ``+=``, ``-=``, "
"``*=``, ``/=``, ``%=``, ``**=`` , ``&=``, ``|=``, ``^=``, ``>>=`` и ``<<=``. "
"Классы Python могут переопределять расширенные операторы присваивания, "
"определяя методы с именами :meth:`!__iadd__`, :meth:`!__isub__` и т. д. "
"Например, следующий класс :class:`!Number` хранит число и поддерживает "
"использование + = для создания нового экземпляра с увеличенным значением."

#: ../../whatsnew/2.0.rst:367
msgid ""
"class Number:\n"
"    def __init__(self, value):\n"
"        self.value = value\n"
"    def __iadd__(self, increment):\n"
"        return Number( self.value + increment)\n"
"\n"
"n = Number(5)\n"
"n += 3\n"
"print n.value"
msgstr ""

#: ../../whatsnew/2.0.rst:377
msgid ""
"The :meth:`!__iadd__` special method is called with the value of the "
"increment, and should return a new instance with an appropriately modified "
"value; this return value is bound as the new value of the variable on the "
"left-hand side."
msgstr ""
"Специальный метод :meth:`!__iadd__` вызывается со значением приращения и "
"должен возвращать новый экземпляр с соответствующим образом измененным "
"значением; это возвращаемое значение привязано как новое значение переменной "
"в левой части."

#: ../../whatsnew/2.0.rst:381
msgid ""
"Augmented assignment operators were first introduced in the C programming "
"language, and most C-derived languages, such as :program:`awk`, C++, Java, "
"Perl, and PHP also support them.  The augmented assignment patch was "
"implemented by Thomas Wouters."
msgstr ""
"Розширені оператори присвоєння вперше були представлені в мові програмування "
"C, і більшість похідних від C мов, таких як :program:`awk`, C++, Java, Perl "
"і PHP, також їх підтримують. Патч доповненого призначення реалізував Томас "
"Воутерс."

#: ../../whatsnew/2.0.rst:390
msgid "String Methods"
msgstr "Metody ciągów"

#: ../../whatsnew/2.0.rst:392
msgid ""
"Until now string-manipulation functionality was in the :mod:`string` module, "
"which was usually a front-end for the :mod:`!strop` module written in C.  "
"The addition of Unicode posed a difficulty for the :mod:`!strop` module, "
"because the functions would all need to be rewritten in order to accept "
"either 8-bit or Unicode strings.  For functions such as :func:`!string."
"replace`, which takes 3 string arguments, that means eight possible "
"permutations, and correspondingly complicated code."
msgstr ""
"До сих пор функциональность манипуляций со строками находилась в модуле :mod:"
"`string`, который обычно был интерфейсом для модуля :mod:`!strop`, "
"написанного на C. Добавление Unicode создавало трудности для :mod: `!strop`, "
"потому что все функции придется переписать, чтобы они могли принимать 8-"
"битные строки или строки в Юникоде. Для таких функций, как :func:`!string."
"replace`, которые принимают 3 строковых аргумента, это означает восемь "
"возможных перестановок и, соответственно, сложный код."

#: ../../whatsnew/2.0.rst:400
msgid ""
"Instead, Python 2.0 pushes the problem onto the string type, making string "
"manipulation functionality available through methods on both 8-bit strings "
"and Unicode strings.   ::"
msgstr ""
"Натомість Python 2.0 переносить проблему на рядковий тип, роблячи "
"функціональні можливості маніпулювання рядками доступними через методи як "
"для 8-бітних рядків, так і для рядків Unicode. ::"

#: ../../whatsnew/2.0.rst:404
msgid ""
">>> 'andrew'.capitalize()\n"
"'Andrew'\n"
">>> 'hostname'.replace('os', 'linux')\n"
"'hlinuxtname'\n"
">>> 'moshe'.find('sh')\n"
"2"
msgstr ""

#: ../../whatsnew/2.0.rst:411
msgid ""
"One thing that hasn't changed, a noteworthy April Fools' joke "
"notwithstanding, is that Python strings are immutable. Thus, the string "
"methods return new strings, and do not modify the string on which they "
"operate."
msgstr ""
"Одне, незважаючи на першоквітневий жарт, не змінилося, це те, що рядки "
"Python є незмінними. Таким чином, рядкові методи повертають нові рядки і не "
"змінюють рядок, з яким вони працюють."

#: ../../whatsnew/2.0.rst:415
msgid ""
"The old :mod:`string` module is still around for backwards compatibility, "
"but it mostly acts as a front-end to the new string methods."
msgstr ""
"Старий модуль :mod:`string` все ще доступний для зворотної сумісності, але "
"він здебільшого діє як інтерфейс для нових методів рядків."

#: ../../whatsnew/2.0.rst:418
msgid ""
"Two methods which have no parallel in pre-2.0 versions, although they did "
"exist in JPython for quite some time, are :meth:`!startswith` and :meth:`!"
"endswith`. ``s.startswith(t)`` is equivalent to ``s[:len(t)] == t``, while "
"``s.endswith(t)`` is equivalent to ``s[-len(t):] == t``."
msgstr ""
"Два метода, которые не имеют аналогов в версиях до 2.0, хотя они "
"существовали в JPython довольно долгое время, это :meth:`!startswith` и :"
"meth:`!endswith`. ``s.startswith(t)`` эквивалентен ``s[:len(t)] == t``, а "
"``s.endswith(t)`` эквивалентен ``s[-len( т):] == т``."

#: ../../whatsnew/2.0.rst:423
msgid ""
"One other method which deserves special mention is :meth:`!join`.  The :meth:"
"`!join` method of a string receives one parameter, a sequence of strings, "
"and is equivalent to the :func:`!string.join` function from the old :mod:"
"`string` module, with the arguments reversed. In other words, ``s."
"join(seq)`` is equivalent to the old ``string.join(seq, s)``."
msgstr ""
"Еще один метод, заслуживающий особого упоминания, — это :meth:`!join`. Метод "
"строки :meth:`!join` получает один параметр, последовательность строк, и "
"эквивалентен функции :func:`!string.join` из старого модуля :mod:`string` с "
"аргументами перевернутый. Другими словами, s.join(seq) эквивалентен старому "
"string.join(seq, s)."

#: ../../whatsnew/2.0.rst:433
msgid "Garbage Collection of Cycles"
msgstr "Збирання сміття циклів"

#: ../../whatsnew/2.0.rst:435
msgid ""
"The C implementation of Python uses reference counting to implement garbage "
"collection.  Every Python object maintains a count of the number of "
"references pointing to itself, and adjusts the count as references are "
"created or destroyed.  Once the reference count reaches zero, the object is "
"no longer accessible, since you need to have a reference to an object to "
"access it, and if the count is zero, no references exist any longer."
msgstr ""
"Реалізація Python на C використовує підрахунок посилань для реалізації "
"збирання сміття. Кожен об’єкт Python підтримує підрахунок кількості "
"посилань, що вказують на нього самого, і коригує кількість у міру створення "
"чи знищення посилань. Коли кількість посилань досягає нуля, об’єкт більше не "
"доступний, оскільки для доступу до нього потрібно мати посилання на об’єкт, "
"і якщо кількість посилань дорівнює нулю, посилань більше не існує."

#: ../../whatsnew/2.0.rst:442
msgid ""
"Reference counting has some pleasant properties: it's easy to understand and "
"implement, and the resulting implementation is portable, fairly fast, and "
"reacts well with other libraries that implement their own memory handling "
"schemes.  The major problem with reference counting is that it sometimes "
"doesn't realise that objects are no longer accessible, resulting in a memory "
"leak.  This happens when there are cycles of references."
msgstr ""
"Підрахунок посилань має деякі приємні властивості: його легко зрозуміти та "
"реалізувати, а результуюча реалізація є портативною, досить швидкою та добре "
"реагує на інші бібліотеки, які реалізують власні схеми обробки пам’яті. "
"Основна проблема з підрахунком посилань полягає в тому, що він іноді не "
"усвідомлює, що об’єкти більше не доступні, що призводить до витоку пам’яті. "
"Це відбувається, коли є цикли посилань."

#: ../../whatsnew/2.0.rst:449
msgid ""
"Consider the simplest possible cycle,  a class instance which has a "
"reference to itself::"
msgstr ""
"Розглянемо найпростіший можливий цикл, екземпляр класу, який має посилання "
"на самого себе::"

#: ../../whatsnew/2.0.rst:452
msgid ""
"instance = SomeClass()\n"
"instance.myself = instance"
msgstr ""

#: ../../whatsnew/2.0.rst:455
msgid ""
"After the above two lines of code have been executed, the reference count of "
"``instance`` is 2; one reference is from the variable named ``'instance'``, "
"and the other is from the ``myself`` attribute of the instance."
msgstr ""
"Після виконання двох вищезазначених рядків коду кількість посилань "
"``примірника`` дорівнює 2; одне посилання походить від змінної з назвою "
"``'instance'``, а інше — від атрибута ``mysel`` екземпляра."

#: ../../whatsnew/2.0.rst:459
msgid ""
"If the next line of code is ``del instance``, what happens?  The reference "
"count of ``instance`` is decreased by 1, so it has a reference count of 1; "
"the reference in the ``myself`` attribute still exists.  Yet the instance is "
"no longer accessible through Python code, and it could be deleted.  Several "
"objects can participate in a cycle if they have references to each other, "
"causing all of the objects to be leaked."
msgstr ""
"Що станеться, якщо наступним рядком коду є ``del instance``? Кількість "
"посилань ``примірника`` зменшено на 1, тому він має кількість посилань 1; "
"посилання в атрибуті ``mysel`` все ще існує. Проте екземпляр більше не "
"доступний через код Python, і його можна видалити. Кілька об’єктів можуть "
"брати участь у циклі, якщо вони мають посилання один на одного, що спричиняє "
"витік усіх об’єктів."

#: ../../whatsnew/2.0.rst:466
msgid ""
"Python 2.0 fixes this problem by periodically executing a cycle detection "
"algorithm which looks for inaccessible cycles and deletes the objects "
"involved. A new :mod:`gc` module provides functions to perform a garbage "
"collection, obtain debugging statistics, and tuning the collector's "
"parameters."
msgstr ""
"Python 2.0 вирішує цю проблему, періодично виконуючи алгоритм виявлення "
"циклу, який шукає недоступні цикли та видаляє залучені об’єкти. Новий "
"модуль :mod:`gc` надає функції для збирання сміття, отримання статистики "
"налагодження та налаштування параметрів збирача."

#: ../../whatsnew/2.0.rst:471
msgid ""
"Running the cycle detection algorithm takes some time, and therefore will "
"result in some additional overhead.  It is hoped that after we've gotten "
"experience with the cycle collection from using 2.0, Python 2.1 will be able "
"to minimize the overhead with careful tuning.  It's not yet obvious how much "
"performance is lost, because benchmarking this is tricky and depends "
"crucially on how often the program creates and destroys objects.  The "
"detection of cycles can be disabled when Python is compiled, if you can't "
"afford even a tiny speed penalty or suspect that the cycle collection is "
"buggy, by specifying the :option:`!--without-cycle-gc` switch when running "
"the :program:`configure` script."
msgstr ""
"Виконання алгоритму виявлення циклу займає деякий час, а тому призведе до "
"додаткових витрат. Сподіваємося, що після того, як ми отримаємо досвід "
"роботи зі збором циклів від використання 2.0, Python 2.1 зможе мінімізувати "
"накладні витрати завдяки ретельному налаштуванню. Поки що неочевидно, "
"скільки продуктивності втрачається, тому що це порівняльний аналіз є "
"складним і дуже залежить від того, як часто програма створює та знищує "
"об’єкти. Виявлення циклів можна вимкнути під час компіляції Python, якщо ви "
"не можете дозволити собі навіть незначне зниження швидкості або підозрюєте, "
"що збирання циклів є помилковим, вказавши перемикач :option:`!--without-"
"cycle-gc`, коли виконання сценарію :program:`configure`."

#: ../../whatsnew/2.0.rst:482
msgid ""
"Several people tackled this problem and contributed to a solution.  An early "
"implementation of the cycle detection approach was written by Toby Kelsey.  "
"The current algorithm was suggested by Eric Tiedemann during a visit to "
"CNRI, and Guido van Rossum and Neil Schemenauer wrote two different "
"implementations, which were later integrated by Neil.  Lots of other people "
"offered suggestions along the way; the March 2000 archives of the python-dev "
"mailing list contain most of the relevant discussion, especially in the "
"threads titled \"Reference cycle collection for Python\" and \"Finalization "
"again\"."
msgstr ""
"Кілька людей взялися за цю проблему та зробили свій внесок у її вирішення. "
"Рання реалізація підходу виявлення циклу була написана Тобі Келсі. Поточний "
"алгоритм був запропонований Еріком Тідеманном під час візиту до CNRI, а "
"Гвідо ван Россум і Ніл Шеменауер написали дві різні реалізації, які пізніше "
"були інтегровані Нілом. Багато інших людей пропонували пропозиції на цьому "
"шляху; архіви списку розсилки python-dev за березень 2000 року містять "
"більшість відповідних обговорень, особливо в темах під назвою \"Колекція "
"довідкового циклу для Python\" і \"Знову завершення\"."

#: ../../whatsnew/2.0.rst:495
msgid "Other Core Changes"
msgstr "Inne podstawowe zmiany"

#: ../../whatsnew/2.0.rst:497
msgid ""
"Various minor changes have been made to Python's syntax and built-in "
"functions. None of the changes are very far-reaching, but they're handy "
"conveniences."
msgstr ""
"У синтаксис і вбудовані функції Python внесено різні незначні зміни. Жодна "
"зі змін не є дуже далекосяжною, але це зручні зручності."

#: ../../whatsnew/2.0.rst:502
msgid "Minor Language Changes"
msgstr "Drobne zmiany językowe"

#: ../../whatsnew/2.0.rst:504
msgid ""
"A new syntax makes it more convenient to call a given function with a tuple "
"of arguments and/or a dictionary of keyword arguments. In Python 1.5 and "
"earlier, you'd use the :func:`!apply` built-in function: ``apply(f, args, "
"kw)`` calls the function :func:`!f` with the argument tuple *args* and the "
"keyword arguments in the dictionary *kw*.  :func:`!apply`  is the same in "
"2.0, but thanks to a patch from Greg Ewing, ``f(*args, **kw)`` is a shorter "
"and clearer way to achieve the same effect.  This syntax is symmetrical with "
"the syntax for defining functions::"
msgstr ""
"Новый синтаксис делает более удобным вызов заданной функции с кортежем "
"аргументов и/или словарем аргументов ключевых слов. В Python 1.5 и более "
"ранних версиях вы должны использовать встроенную функцию :func:`!apply`: "
"``apply(f, args, kw)`` вызывает функцию :func:`!f` с кортежем аргументов * "
"args* и аргументы ключевого слова в словаре *kw*. :func:`!apply` в версии "
"2.0 такой же, но благодаря патчу от Грега Юинга ``f(*args, **kw)`` стал "
"более коротким и понятным способом достижения того же эффекта. Этот "
"синтаксис симметричен синтаксису определения функций::"

#: ../../whatsnew/2.0.rst:513
msgid ""
"def f(*args, **kw):\n"
"    # args is a tuple of positional args,\n"
"    # kw is a dictionary of keyword args\n"
"    ..."
msgstr ""

#: ../../whatsnew/2.0.rst:518
msgid ""
"The ``print`` statement can now have its output directed to a file-like "
"object by following the ``print`` with  ``>> file``, similar to the "
"redirection operator in Unix shells. Previously you'd either have to use "
"the :meth:`!write` method of the file-like object, which lacks the "
"convenience and simplicity of ``print``, or you could assign a new value to "
"``sys.stdout`` and then restore the old value.  For sending output to "
"standard error, it's much easier to write this::"
msgstr ""
"Вывод оператора ``print`` теперь может быть направлен на файлоподобный "
"объект, если после ``print`` следовать ``>> file``, аналогично оператору "
"перенаправления в оболочках Unix. Раньше вам приходилось либо использовать "
"метод :meth:`!write` файлового объекта, которому не хватает удобства и "
"простоты ``print``, либо вы могли присвоить новое значение ``sys.stdout``. "
"`` а затем восстановите старое значение. Для отправки вывода в стандартную "
"ошибку гораздо проще написать следующее:"

#: ../../whatsnew/2.0.rst:526
msgid "print >> sys.stderr, \"Warning: action field not supplied\""
msgstr ""

#: ../../whatsnew/2.0.rst:528
msgid ""
"Modules can now be renamed on importing them, using the syntax ``import "
"module as name`` or ``from module import name as othername``.  The patch was "
"submitted by Thomas Wouters."
msgstr ""
"Модулі тепер можна перейменовувати під час їх імпорту, використовуючи "
"синтаксис ``імпортувати модуль як ім’я`` або ``з імені імпорту модуля як "
"інше ім’я``. Патч надіслав Томас Воутерс."

#: ../../whatsnew/2.0.rst:532
msgid ""
"A new format style is available when using the ``%`` operator; '%r' will "
"insert the :func:`repr` of its argument.  This was also added from symmetry "
"considerations, this time for symmetry with the existing '%s' format style, "
"which inserts the :func:`str` of its argument.  For example, ``'%r %s' % "
"('abc', 'abc')`` returns a string containing ``'abc' abc``."
msgstr ""
"Новий стиль формату доступний при використанні оператора ``%``; '%r' "
"вставить :func:`repr` свого аргументу. Це також було додано з міркувань "
"симетрії, цього разу для симетрії з існуючим стилем формату '%s', який "
"вставляє :func:`str` свого аргументу. Наприклад, ``'%r %s' % ('abc', "
"'abc')`` повертає рядок, що містить ``'abc' abc``."

#: ../../whatsnew/2.0.rst:538
msgid ""
"Previously there was no way to implement a class that overrode Python's "
"built-in :keyword:`in` operator and implemented a custom version.  ``obj in "
"seq`` returns true if *obj* is present in the sequence *seq*; Python "
"computes this by simply trying every index of the sequence until either "
"*obj* is found or an :exc:`IndexError` is encountered.  Moshe Zadka "
"contributed a patch which adds a :meth:`!__contains__` magic method for "
"providing a custom implementation for :keyword:`!in`. Additionally, new "
"built-in objects written in C can define what :keyword:`!in` means for them "
"via a new slot in the sequence protocol."
msgstr ""
"Раньше не было возможности реализовать класс, который переопределил бы "
"встроенный в Python оператор :keyword:`in` и реализовал собственную версию. "
"``obj in seq`` возвращает true, если *obj* присутствует в последовательности "
"*seq*; Python вычисляет это, просто перебирая каждый индекс "
"последовательности, пока не будет найден либо *obj*, либо пока не "
"встретится :exc:`IndexError`. Моше Задка предоставил патч, который добавляет "
"магический метод :meth:`!__contains__` для обеспечения пользовательской "
"реализации :keyword:`!in`. Кроме того, новые встроенные объекты, написанные "
"на C, могут определять, что для них означает :keyword:`!in`, через новый "
"слот в протоколе последовательности."

#: ../../whatsnew/2.0.rst:547
msgid ""
"Earlier versions of Python used a recursive algorithm for deleting objects. "
"Deeply nested data structures could cause the interpreter to fill up the C "
"stack and crash; Christian Tismer rewrote the deletion logic to fix this "
"problem.  On a related note, comparing recursive objects recursed infinitely "
"and crashed; Jeremy Hylton rewrote the code to no longer crash, producing a "
"useful result instead.  For example, after this code::"
msgstr ""
"Попередні версії Python використовували рекурсивний алгоритм для видалення "
"об’єктів. Глибоко вкладені структури даних можуть спричинити заповнення "
"стека C і збій інтерпретатора; Крістіан Тісмер переписав логіку видалення, "
"щоб вирішити цю проблему. У зв’язку з цим, порівняння рекурсивних об’єктів "
"нескінченно рекурсувало і вийшло з ладу; Джеремі Гілтон переписав код, щоб "
"він більше не виходив з ладу, натомість створюючи корисний результат. "
"Наприклад, після цього коду::"

#: ../../whatsnew/2.0.rst:554
msgid ""
"a = []\n"
"b = []\n"
"a.append(a)\n"
"b.append(b)"
msgstr ""

#: ../../whatsnew/2.0.rst:559
msgid ""
"The comparison ``a==b`` returns true, because the two recursive data "
"structures are isomorphic. See the thread \"trashcan and PR#7\" in the April "
"2000 archives of the python-dev mailing list for the discussion leading up "
"to this implementation, and some useful relevant links.    Note that "
"comparisons can now also raise exceptions. In earlier versions of Python, a "
"comparison operation such as ``cmp(a,b)`` would always produce an answer, "
"even if a user-defined :meth:`!__cmp__` method encountered an error, since "
"the resulting exception would simply be silently swallowed."
msgstr ""
"Сравнение ``a==b`` возвращает true, поскольку две рекурсивные структуры "
"данных изоморфны. См. ветку «мусорная корзина и PR#7» в архивах списка "
"рассылки python-dev за апрель 2000 г., где представлено обсуждение, "
"приведшее к этой реализации, а также некоторые полезные ссылки. Обратите "
"внимание, что сравнения теперь также могут вызывать исключения. В более "
"ранних версиях Python операция сравнения, такая как ``cmp(a,b)``, всегда "
"давала ответ, даже если пользовательский метод :meth:`!__cmp__` обнаруживал "
"ошибку, поскольку результирующее исключение просто молча проглотить."

#: ../../whatsnew/2.0.rst:571
msgid ""
"Work has been done on porting Python to 64-bit Windows on the Itanium "
"processor, mostly by Trent Mick of ActiveState.  (Confusingly, ``sys."
"platform`` is still ``'win32'`` on Win64 because it seems that for ease of "
"porting, MS Visual C++ treats code as 32 bit on Itanium.) PythonWin also "
"supports Windows CE; see the Python CE page at https://pythonce.sourceforge."
"net/ for more information."
msgstr ""
"Работа по портированию Python на 64-разрядную версию Windows на процессоре "
"Itanium была проделана в основном Трентом Миком из ActiveState. (Как ни "
"странно, ``sys.platform`` по-прежнему является ``'win32'`` на Win64, потому "
"что кажется, что для простоты портирования MS Visual C++ рассматривает код "
"на Itanium как 32-битный.) PythonWin также поддерживает Windows CE; "
"дополнительную информацию см. на странице Python CE по адресу https://"
"pythonce.sourceforge.net/."

#: ../../whatsnew/2.0.rst:577
msgid ""
"Another new platform is Darwin/MacOS X; initial support for it is in Python "
"2.0. Dynamic loading works, if you specify \"configure --with-dyld --with-"
"suffix=.x\". Consult the README in the Python source distribution for more "
"instructions."
msgstr ""
"Ще одна нова платформа — Darwin/MacOS X; початкова підтримка для нього в "
"Python 2.0. Динамічне завантаження працює, якщо ви вкажете \"configure --"
"with-dyld --with-suffix=.x\". Щоб отримати додаткові вказівки, зверніться до "
"файлу README у вихідному коді Python."

#: ../../whatsnew/2.0.rst:581
msgid ""
"An attempt has been made to alleviate one of Python's warts, the often-"
"confusing :exc:`NameError` exception when code refers to a local variable "
"before the variable has been assigned a value.  For example, the following "
"code raises an exception on the ``print`` statement in both 1.5.2 and 2.0; "
"in 1.5.2 a :exc:`NameError` exception is raised, while 2.0 raises a new :exc:"
"`UnboundLocalError` exception. :exc:`UnboundLocalError` is a subclass of :"
"exc:`NameError`, so any existing code that expects :exc:`NameError` to be "
"raised should still work. ::"
msgstr ""
"Була зроблена спроба пом’якшити одну з недоліків Python, виняток :exc:"
"`NameError`, який часто викликає плутанину, коли код посилається на локальну "
"змінну до того, як їй було присвоєно значення. Наприклад, наступний код "
"викликає виняток у операторі ``print`` як у 1.5.2, так і 2.0; у 1.5.2 "
"виникає виняток :exc:`NameError`, тоді як у 2.0 виникає новий виняток :exc:"
"`UnboundLocalError`. :exc:`UnboundLocalError` є підкласом :exc:`NameError`, "
"тому будь-який існуючий код, який очікує виклику :exc:`NameError`, має "
"працювати. ::"

#: ../../whatsnew/2.0.rst:590
msgid ""
"def f():\n"
"    print \"i=\",i\n"
"    i = i + 1\n"
"f()"
msgstr ""

#: ../../whatsnew/2.0.rst:595
msgid ""
"Two new exceptions, :exc:`TabError` and :exc:`IndentationError`, have been "
"introduced.  They're both subclasses of :exc:`SyntaxError`, and are raised "
"when Python code is found to be improperly indented."
msgstr ""
"Додано два нові винятки, :exc:`TabError` і :exc:`IndentationError`. Обидва "
"вони є підкласами :exc:`SyntaxError` і викликаються, коли виявляється, що "
"код Python має неправильний відступ."

#: ../../whatsnew/2.0.rst:601
msgid "Changes to Built-in Functions"
msgstr "Zmiany w funkcjach wbudowanych"

#: ../../whatsnew/2.0.rst:603
msgid ""
"A new built-in, ``zip(seq1, seq2, ...)``, has been added.  :func:`zip` "
"returns a list of tuples where each tuple contains the i-th element from "
"each of the argument sequences.  The difference between :func:`zip` and "
"``map(None, seq1, seq2)`` is that :func:`map` pads the sequences with "
"``None`` if the sequences aren't all of the same length, while :func:`zip` "
"truncates the returned list to the length of the shortest argument sequence."
msgstr ""
"Додано нову вбудовану функцію ``zip(seq1, seq2, ...)``. :func:`zip` повертає "
"список кортежів, де кожен кортеж містить i-й елемент із кожної послідовності "
"аргументів. Різниця між :func:`zip` і ``map(None, seq1, seq2)`` полягає в "
"тому, що :func:`map` доповнює послідовності ``None``, якщо послідовності не "
"мають однакову довжину , а :func:`zip` скорочує повернутий список до довжини "
"найкоротшої послідовності аргументів."

#: ../../whatsnew/2.0.rst:610
msgid ""
"The :func:`int` and :func:`!long` functions now accept an optional \"base\" "
"parameter when the first argument is a string. ``int('123', 10)`` returns "
"123, while ``int('123', 16)`` returns 291.  ``int(123, 16)`` raises a :exc:"
"`TypeError` exception with the message \"can't convert non-string with "
"explicit base\"."
msgstr ""
"Функции :func:`int` и :func:`!long` теперь принимают необязательный "
"«базовый» параметр, если первым аргументом является строка. ``int('123', "
"10)`` возвращает 123, а ``int('123', 16)`` возвращает 291. ``int(123, 16)`` "
"вызывает исключение :exc:`TypeError` с сообщением «невозможно преобразовать "
"нестроку с явной базой»."

#: ../../whatsnew/2.0.rst:616
msgid ""
"A new variable holding more detailed version information has been added to "
"the :mod:`sys` module.  ``sys.version_info`` is a tuple ``(major, minor, "
"micro, level, serial)`` For example, in a hypothetical 2.0.1beta1, ``sys."
"version_info`` would be ``(2, 0, 1, 'beta', 1)``. *level* is a string such "
"as ``\"alpha\"``, ``\"beta\"``, or ``\"final\"`` for a final release."
msgstr ""
"До модуля :mod:`sys` додано нову змінну, що містить більш детальну "
"інформацію про версію. ``sys.version_info`` — це кортеж ``(major, minor, "
"micro, level, serial)``. Наприклад, у гіпотетичній версії 2.0.1beta1, ``sys."
"version_info`` буде ``(2, 0 , 1, 'бета', 1)``. *level* — це рядок, наприклад "
"``\"alpha\"``, ``\"beta\"`` або ``\"final\"`` для остаточного випуску."

#: ../../whatsnew/2.0.rst:622
msgid ""
"Dictionaries have an odd new method, ``setdefault(key, default)``, which "
"behaves similarly to the existing :meth:`!get` method.  However, if the key "
"is missing, :meth:`!setdefault` both returns the value of *default* as :meth:"
"`!get` would do, and also inserts it into the dictionary as the value for "
"*key*.  Thus, the following lines of code::"
msgstr ""
"В словарях появился новый необычный метод ``setdefault(key, default)``, "
"который ведет себя аналогично существующему методу :meth:`!get`. Однако, "
"если ключ отсутствует, :meth:`!setdefault` возвращает значение *default*, "
"как это сделал бы :meth:`!get`, а также вставляет его в словарь как значение "
"для *key*. Таким образом, следующие строки кода:"

#: ../../whatsnew/2.0.rst:628
msgid ""
"if dict.has_key( key ): return dict[key]\n"
"else:\n"
"    dict[key] = []\n"
"    return dict[key]"
msgstr ""

#: ../../whatsnew/2.0.rst:633
msgid ""
"can be reduced to a single ``return dict.setdefault(key, [])`` statement."
msgstr "можна звести до одного оператора ``return dict.setdefault(key, [])``."

#: ../../whatsnew/2.0.rst:635
msgid ""
"The interpreter sets a maximum recursion depth in order to catch runaway "
"recursion before filling the C stack and causing a core dump or GPF.. "
"Previously this limit was fixed when you compiled Python, but in 2.0 the "
"maximum recursion depth can be read and modified using :func:`sys."
"getrecursionlimit` and :func:`sys.setrecursionlimit`. The default value is "
"1000, and a rough maximum value for a given platform can be found by running "
"a new script, :file:`Misc/find_recursionlimit.py`."
msgstr ""
"Інтерпретатор встановлює максимальну глибину рекурсії, щоб уловити "
"невимушену рекурсію перед заповненням стека C і створенням дампа ядра або "
"GPF. Раніше це обмеження було виправлено під час компіляції Python, але у "
"2.0 максимальну глибину рекурсії можна прочитати та змінити за допомогою :"
"func:`sys.getrecursionlimit` і :func:`sys.setrecursionlimit`. Стандартним "
"значенням є 1000, а приблизне максимальне значення для даної платформи можна "
"знайти, запустивши новий сценарій :file:`Misc/find_recursionlimit.py`."

#: ../../whatsnew/2.0.rst:647
msgid "Porting to 2.0"
msgstr "Przenoszenie do 2.0"

#: ../../whatsnew/2.0.rst:649
msgid ""
"New Python releases try hard to be compatible with previous releases, and "
"the record has been pretty good.  However, some changes are considered "
"useful enough, usually because they fix initial design decisions that turned "
"out to be actively mistaken, that breaking backward compatibility can't "
"always be avoided. This section lists the changes in Python 2.0 that may "
"cause old Python code to break."
msgstr ""
"Нові випуски Python намагаються бути сумісними з попередніми випусками, і "
"результати були досить хорошими. Однак деякі зміни вважаються досить "
"корисними, зазвичай тому, що вони виправляють початкові дизайнерські "
"рішення, які виявилися активно помилковими, тому порушення зворотної "
"сумісності не завжди можна уникнути. У цьому розділі перераховано зміни в "
"Python 2.0, які можуть призвести до поломки старого коду Python."

#: ../../whatsnew/2.0.rst:656
msgid ""
"The change which will probably break the most code is tightening up the "
"arguments accepted by some methods.  Some methods would take multiple "
"arguments and treat them as a tuple, particularly various list methods such "
"as :meth:`~list.append` and :meth:`~list.insert`. In earlier versions of "
"Python, if ``L`` is a list, ``L.append( 1,2 )`` appends the tuple ``(1,2)`` "
"to the list.  In Python 2.0 this causes a :exc:`TypeError` exception to be "
"raised, with the message: 'append requires exactly 1 argument; 2 given'.  "
"The fix is to simply add an extra set of parentheses to pass both values as "
"a tuple:  ``L.append( (1,2) )``."
msgstr ""

#: ../../whatsnew/2.0.rst:666
msgid ""
"The earlier versions of these methods were more forgiving because they used "
"an old function in Python's C interface to parse their arguments; 2.0 "
"modernizes them to use :c:func:`PyArg_ParseTuple`, the current argument "
"parsing function, which provides more helpful error messages and treats "
"multi-argument calls as errors.  If you absolutely must use 2.0 but can't "
"fix your code, you can edit :file:`Objects/listobject.c` and define the "
"preprocessor symbol ``NO_STRICT_LIST_APPEND`` to preserve the old behaviour; "
"this isn't recommended."
msgstr ""
"Более ранние версии этих методов были более щадящими, поскольку для анализа "
"аргументов они использовали старую функцию из интерфейса Python C; Версия "
"2.0 модернизирует их для использования :c:func:`PyArg_ParseTuple`, текущей "
"функции анализа аргументов, которая выдает более полезные сообщения об "
"ошибках и обрабатывает вызовы с несколькими аргументами как ошибки. Если вам "
"абсолютно необходимо использовать версию 2.0, но вы не можете исправить свой "
"код, вы можете отредактировать :file:`Objects/listobject.c` и определить "
"символ препроцессора ``NO_STRICT_LIST_APPEND``, чтобы сохранить старое "
"поведение; это не рекомендуется."

#: ../../whatsnew/2.0.rst:674
msgid ""
"Some of the functions in the :mod:`socket` module are still forgiving in "
"this way.  For example, ``socket.connect( ('hostname', 25) )`` is the "
"correct form, passing a tuple representing an IP address, but ``socket."
"connect('hostname', 25)`` also works. :meth:`socket.connect_ex <socket."
"socket.connect_ex>` and :meth:`socket.bind <socket.socket.bind>` are "
"similarly easy-going.  2.0alpha1 tightened these functions up, but because "
"the documentation actually used the erroneous multiple argument form, many "
"people wrote code which would break with the stricter checking.  GvR backed "
"out the changes in the face of public reaction, so for the :mod:`socket` "
"module, the documentation was fixed and the multiple argument form is simply "
"marked as deprecated; it *will* be tightened up again in a future Python "
"version."
msgstr ""
"Некоторые функции модуля :mod:`socket` по-прежнему прощают ошибки. Например, "
"``socket.connect(('hostname', 25))`` является правильной формой, передавая "
"кортеж, представляющий IP-адрес, но ``socket.connect('hostname', 25)`` также "
"работает. :meth:`socket.connect_ex <socket.socket.connect_ex>` и :meth:"
"`socket.bind <socket.socket.bind>` одинаково просты в использовании. Версия "
"2.0alpha1 ужесточила эти функции, но поскольку в документации фактически "
"использовалась ошибочная форма с несколькими аргументами, многие люди писали "
"код, который не выдержал бы более строгой проверки. GvR отклонил изменения, "
"несмотря на общественную реакцию, поэтому для модуля :mod:`socket` "
"документация была исправлена, а форма с несколькими аргументами просто "
"помечена как устаревшая; оно *будет* снова исправлено в будущей версии "
"Python."

#: ../../whatsnew/2.0.rst:685
msgid ""
"The ``\\x`` escape in string literals now takes exactly 2 hex digits.  "
"Previously it would consume all the hex digits following the 'x' and take "
"the lowest 8 bits of the result, so ``\\x123456`` was equivalent to "
"``\\x56``."
msgstr ""
"Екранування ``\\x`` у рядкових літералах тепер займає рівно 2 шістнадцяткові "
"цифри. Раніше він використовував усі шістнадцяткові цифри після 'x' і брав "
"молодші 8 бітів результату, тому ``\\x123456`` був еквівалентним ``\\x56``."

#: ../../whatsnew/2.0.rst:689
msgid ""
"The :exc:`AttributeError` and :exc:`NameError` exceptions have a more "
"friendly error message, whose text will be something like ``'Spam' instance "
"has no attribute 'eggs'`` or ``name 'eggs' is not defined``.  Previously the "
"error message was just the missing attribute name ``eggs``, and code written "
"to take advantage of this fact will break in 2.0."
msgstr ""
"Винятки :exc:`AttributeError` і :exc:`NameError` мають більш зрозуміле "
"повідомлення про помилку, текст якого буде приблизно таким, як \"Екземпляр "
"спаму\" не має атрибута \"яйця\" або \"назва \"яйця\" є не визначено. Раніше "
"повідомленням про помилку було лише відсутнє ім’я атрибута ``яйця``, і код, "
"написаний для використання цього факту, зламається у 2.0."

#: ../../whatsnew/2.0.rst:695
msgid ""
"Some work has been done to make integers and long integers a bit more "
"interchangeable.  In 1.5.2, large-file support was added for Solaris, to "
"allow reading files larger than 2 GiB; this made the :meth:`!tell` method of "
"file objects return a long integer instead of a regular integer.  Some code "
"would subtract two file offsets and attempt to use the result to multiply a "
"sequence or slice a string, but this raised a :exc:`TypeError`.  In 2.0, "
"long integers can be used to multiply or slice a sequence, and it'll behave "
"as you'd intuitively expect it to; ``3L * 'abc'`` produces 'abcabcabc', and "
"``(0,1,2,3)[2L:4L]`` produces (2,3). Long integers can also be used in "
"various contexts where previously only integers were accepted, such as in "
"the :meth:`!seek` method of file objects, and in the formats supported by "
"the ``%`` operator (``%d``, ``%i``, ``%x``, etc.).  For example, ``\"%d\" % "
"2L**64`` will produce the string ``18446744073709551616``."
msgstr ""
"Была проделана некоторая работа, чтобы сделать целые и длинные целые числа "
"более взаимозаменяемыми. В версии 1.5.2 для Solaris была добавлена ​​поддержка "
"больших файлов, позволяющая читать файлы размером более 2 ГиБ; это заставило "
"метод :meth:`!tell` файловых объектов возвращать длинное целое число вместо "
"обычного целого числа. Некоторый код вычитал два смещения файла и пытался "
"использовать результат для умножения последовательности или разрезания "
"строки, но это вызывало ошибку :exc:`TypeError`. В версии 2.0 длинные целые "
"числа можно использовать для умножения или разрезания последовательности, и "
"они будут вести себя так, как вы интуитивно ожидаете; ``3L * 'abc'`` создает "
"'abcabcabc', а ``(0,1,2,3)[2L:4L]`` создает (2,3). Длинные целые числа также "
"можно использовать в различных контекстах, где раньше принимались только "
"целые числа, например, в методе :meth:`!seek` файловых объектов, а также в "
"форматах, поддерживаемых оператором ``%`` (`` %д ``, `` %я ``, `` %х `` и "
"др.). Например, ``\" %д \" % 2L**64`` создаст строку "
"``18446744073709551616``."

#: ../../whatsnew/2.0.rst:709
msgid ""
"The subtlest long integer change of all is that the :func:`str` of a long "
"integer no longer has a trailing 'L' character, though :func:`repr` still "
"includes it.  The 'L' annoyed many people who wanted to print long integers "
"that looked just like regular integers, since they had to go out of their "
"way to chop off the character.  This is no longer a problem in 2.0, but code "
"which does ``str(longval)[:-1]`` and assumes the 'L' is there, will now lose "
"the final digit."
msgstr ""
"Найтонша зміна довгого цілого числа полягає в тому, що :func:`str` довгого "
"цілого більше не має кінцевого символу 'L', хоча :func:`repr` все ще містить "
"його. \"L\" дратувала багатьох людей, які хотіли надрукувати довгі цілі "
"числа, які виглядали так само, як звичайні цілі числа, оскільки їм "
"доводилося докладати всіх зусиль, щоб відрізати символ. Це більше не є "
"проблемою у 2.0, але код, який виконує ``str(longval)[:-1]`` і припускає, що "
"є 'L', тепер втратить останню цифру."

#: ../../whatsnew/2.0.rst:717
msgid ""
"Taking the :func:`repr` of a float now uses a different formatting precision "
"than :func:`str`.  :func:`repr` uses ``%.17g`` format string for C's :func:`!"
"sprintf`, while :func:`str` uses ``%.12g`` as before.  The effect is that :"
"func:`repr` may occasionally show more decimal places than  :func:`str`, for "
"certain numbers.  For example, the number 8.1 can't be represented exactly "
"in binary, so ``repr(8.1)`` is ``'8.0999999999999996'``, while str(8.1) is "
"``'8.1'``."
msgstr ""
"При получении :func:`repr` числа с плавающей запятой теперь используется "
"другая точность форматирования, чем :func:`str`. :func:`repr` использует `` "
"%.17г `` строка формата для C :func:`!sprintf`, тогда как :func:`str` "
"использует `` %.12г `` как и прежде. В результате :func:`repr` может иногда "
"отображать больше десятичных знаков, чем :func:`str`, для определенных "
"чисел. Например, число 8.1 не может быть точно представлено в двоичном виде, "
"поэтому repr(8.1) — это 8.0999999999999996, а str(8.1) — 8.1."

#: ../../whatsnew/2.0.rst:725
msgid ""
"The ``-X`` command-line option, which turned all standard exceptions into "
"strings instead of classes, has been removed; the standard exceptions will "
"now always be classes.  The :mod:`!exceptions` module containing the "
"standard exceptions was translated from Python to a built-in C module, "
"written by Barry Warsaw and Fredrik Lundh."
msgstr ""
"Опция командной строки ``-X``, которая превращала все стандартные исключения "
"в строки вместо классов, была удалена; стандартными исключениями теперь "
"всегда будут классы. Модуль :mod:`!Exceptions`, содержащий стандартные "
"исключения, был переведен с Python во встроенный модуль C, написанный Барри "
"Варшавой и Фредриком Лундом."

#: ../../whatsnew/2.0.rst:741
msgid "Extending/Embedding Changes"
msgstr "Zmiany rozszerzające/osadzające"

#: ../../whatsnew/2.0.rst:743
msgid ""
"Some of the changes are under the covers, and will only be apparent to "
"people writing C extension modules or embedding a Python interpreter in a "
"larger application.  If you aren't dealing with Python's C API, you can "
"safely skip this section."
msgstr ""
"Деякі зміни знаходяться під обкладинками, і вони будуть очевидні лише для "
"людей, які пишуть модулі розширення C або вбудовують інтерпретатор Python у "
"більшу програму. Якщо ви не маєте справу з API C Python, можете сміливо "
"пропустити цей розділ."

#: ../../whatsnew/2.0.rst:748
msgid ""
"The version number of the Python C API was incremented, so C extensions "
"compiled for 1.5.2 must be recompiled in order to work with 2.0.  On "
"Windows, it's not possible for Python 2.0 to import a third party extension "
"built for Python 1.5.x due to how Windows DLLs work, so Python will raise an "
"exception and the import will fail."
msgstr ""
"Номер версії Python C API було збільшено, тому розширення C, скомпільовані "
"для 1.5.2, потрібно перекомпілювати, щоб працювати з 2.0. У Windows Python "
"2.0 не може імпортувати стороннє розширення, створене для Python 1.5.x, "
"через те, як працюють бібліотеки DLL Windows, тому Python викличе виняток, і "
"імпорт не вдасться."

#: ../../whatsnew/2.0.rst:754
msgid ""
"Users of Jim Fulton's ExtensionClass module will be pleased to find out that "
"hooks have been added so that ExtensionClasses are now supported by :func:"
"`isinstance` and :func:`issubclass`. This means you no longer have to "
"remember to write code such as ``if type(obj) == myExtensionClass``, but can "
"use the more natural ``if isinstance(obj, myExtensionClass)``."
msgstr ""
"Користувачі модуля ExtensionClass Джима Фултона будуть раді дізнатися, що "
"були додані хуки, завдяки чому ExtensionClasses тепер підтримуються :func:"
"`isinstance` і :func:`issubclass`. Це означає, що вам більше не потрібно "
"пам’ятати про написання такого коду, як ``if type(obj) == "
"myExtensionClass``, а можна використовувати більш природний ``if "
"isinstance(obj, myExtensionClass)``."

#: ../../whatsnew/2.0.rst:760
msgid ""
"The :file:`Python/importdl.c` file, which was a mass of #ifdefs to support "
"dynamic loading on many different platforms, was cleaned up and reorganised "
"by Greg Stein.  :file:`importdl.c` is now quite small, and platform-specific "
"code has been moved into a bunch of :file:`Python/dynload_\\*.c` files.  "
"Another cleanup: there were also a number of :file:`my\\*.h` files in the "
"Include/ directory that held various portability hacks; they've been merged "
"into a single file, :file:`Include/pyport.h`."
msgstr ""
"Файл :file:`Python/importdl.c`, який являв собою масу #ifdefs для підтримки "
"динамічного завантаження на багатьох різних платформах, був очищений і "
"реорганізований Грегом Стайном. :file:`importdl.c` тепер досить малий, і "
"специфічний для платформи код було переміщено до групи файлів :file:`Python/"
"dynload_\\*.c`. Ще одне очищення: у каталозі Include/ також було кілька "
"файлів :file:`my\\*.h`, які містили різноманітні хаки для перенесення; їх "
"об’єднано в один файл :file:`Include/pyport.h`."

#: ../../whatsnew/2.0.rst:768
msgid ""
"Vladimir Marangozov's long-awaited malloc restructuring was completed, to "
"make it easy to have the Python interpreter use a custom allocator instead "
"of C's standard :c:func:`malloc`.  For documentation, read the comments in :"
"file:`Include/pymem.h` and :file:`Include/objimpl.h`.  For the lengthy "
"discussions during which the interface was hammered out, see the web "
"archives of the 'patches' and 'python-dev' lists at python.org."
msgstr ""
"Долгожданная реструктуризация malloc Владимира Марангозова была завершена, "
"чтобы интерпретатор Python мог легко использовать собственный распределитель "
"вместо стандартного C :c:func:`malloc`. Документацию можно найти в "
"комментариях в :file:`Include/pymem.h` и :file:`Include/objimpl.h`. "
"Подробности о длительных обсуждениях, в ходе которых создавался интерфейс, "
"см. в веб-архивах списков «патчей» и «python-dev» на сайте python.org."

#: ../../whatsnew/2.0.rst:775
msgid ""
"Recent versions of the GUSI development environment for MacOS support POSIX "
"threads.  Therefore, Python's POSIX threading support now works on the "
"Macintosh.  Threading support using the user-space GNU ``pth`` library was "
"also contributed."
msgstr ""
"Останні версії середовища розробки GUSI для MacOS підтримують потоки POSIX. "
"Таким чином, підтримка потоків Python POSIX тепер працює на Macintosh. Також "
"була надана підтримка потоків за допомогою бібліотеки GNU ``pth`` у просторі "
"користувача."

#: ../../whatsnew/2.0.rst:780
msgid ""
"Threading support on Windows was enhanced, too.  Windows supports thread "
"locks that use kernel objects only in case of contention; in the common case "
"when there's no contention, they use simpler functions which are an order of "
"magnitude faster.  A threaded version of Python 1.5.2 on NT is twice as slow "
"as an unthreaded version; with the 2.0 changes, the difference is only 10%.  "
"These improvements were contributed by Yakov Markovitch."
msgstr ""
"Також покращено підтримку потоків у Windows. Windows підтримує блокування "
"потоків, які використовують об’єкти ядра лише у випадку конфлікту; у "
"звичайному випадку, коли немає суперечок, вони використовують простіші "
"функції, які на порядок швидші. Потокова версія Python 1.5.2 на NT вдвічі "
"повільніша за безпотокову версію; зі змінами 2.0 різниця становить лише 10%. "
"Ці вдосконалення вніс Яків Маркович."

#: ../../whatsnew/2.0.rst:787
msgid ""
"Python 2.0's source now uses only ANSI C prototypes, so compiling Python now "
"requires an ANSI C compiler, and can no longer be done using a compiler that "
"only supports K&R C."
msgstr ""
"Вихідні коди Python 2.0 тепер використовують лише прототипи ANSI C, тому для "
"компіляції Python тепер потрібен компілятор ANSI C, і його більше неможливо "
"виконати за допомогою компілятора, який підтримує лише K&R C."

#: ../../whatsnew/2.0.rst:791
msgid ""
"Previously the Python virtual machine used 16-bit numbers in its bytecode, "
"limiting the size of source files.  In particular, this affected the maximum "
"size of literal lists and dictionaries in Python source; occasionally people "
"who are generating Python code would run into this limit.  A patch by "
"Charles G. Waldman raises the limit from ``2**16`` to ``2**32``."
msgstr ""
"Раніше віртуальна машина Python використовувала 16-бітні числа у своєму байт-"
"коді, обмежуючи розмір вихідних файлів. Зокрема, це вплинуло на максимальний "
"розмір списків літералів і словників у вихідних кодах Python; час від часу "
"люди, які генерують код Python, стикаються з цим обмеженням. Патч від "
"Charles G. Waldman підвищує ліміт з ``2**16`` до ``2**32``."

#: ../../whatsnew/2.0.rst:797
msgid ""
"Three new convenience functions intended for adding constants to a module's "
"dictionary at module initialization time were added: :c:func:"
"`PyModule_AddObject`, :c:func:`PyModule_AddIntConstant`, and :c:func:"
"`PyModule_AddStringConstant`.  Each of these functions takes a module "
"object, a null-terminated C string containing the name to be added, and a "
"third argument for the value to be assigned to the name.  This third "
"argument is, respectively, a Python object, a C long, or a C string."
msgstr ""
"Были добавлены три новые удобные функции, предназначенные для добавления "
"констант в словарь модуля во время инициализации модуля: :c:func:"
"`PyModule_AddObject`, :c:func:`PyModule_AddIntConstant` и :c:func:"
"`PyModule_AddStringConstant`. Каждая из этих функций принимает объект "
"модуля, строку C с нулевым завершением, содержащую добавляемое имя, и третий "
"аргумент для значения, которое должно быть присвоено имени. Этот третий "
"аргумент является соответственно объектом Python, длиной C или строкой C."

#: ../../whatsnew/2.0.rst:805
msgid ""
"A wrapper API was added for Unix-style signal handlers. :c:func:"
"`PyOS_getsig` gets a signal handler and :c:func:`PyOS_setsig` will set a new "
"handler."
msgstr ""
"Для обработчиков сигналов в стиле Unix был добавлен API-оболочка. :c:func:"
"`PyOS_getsig` получает обработчик сигнала, а :c:func:`PyOS_setsig` "
"устанавливает новый обработчик."

#: ../../whatsnew/2.0.rst:812
msgid "Distutils: Making Modules Easy to Install"
msgstr "Distutils: Łatwe do zainstalowania moduły"

#: ../../whatsnew/2.0.rst:814
msgid ""
"Before Python 2.0, installing modules was a tedious affair -- there was no "
"way to figure out automatically where Python is installed, or what compiler "
"options to use for extension modules.  Software authors had to go through an "
"arduous ritual of editing Makefiles and configuration files, which only "
"really work on Unix and leave Windows and MacOS unsupported.  Python users "
"faced wildly differing installation instructions which varied between "
"different extension packages, which made administering a Python installation "
"something of  a chore."
msgstr ""
"До Python 2.0 встановлення модулів було нудною справою — не було можливості "
"автоматично визначити, де встановлено Python, або які параметри компілятора "
"використовувати для модулів розширення. Авторам програмного забезпечення "
"довелося пройти через важкий ритуал редагування файлів Makefile та "
"конфігураційних файлів, які справді працюють лише в Unix, а Windows і MacOS "
"не підтримуються. Користувачі Python зіткнулися з надзвичайно різними "
"інструкціями встановлення, які відрізнялися між різними пакетами розширень, "
"що робило адміністрування встановлення Python чимось на зразок клопітку."

#: ../../whatsnew/2.0.rst:822
msgid ""
"The SIG for distribution utilities, shepherded by Greg Ward, has created the "
"Distutils, a system to make package installation much easier.  They form the "
"``distutils`` package, a new part of Python's standard library. In the best "
"case, installing a Python module from source will require the same steps: "
"first you simply mean unpack the tarball or zip archive, and the run "
"\"``python setup.py install``\".  The platform will be automatically "
"detected, the compiler will be recognized, C extension modules will be "
"compiled, and the distribution installed into the proper directory.  "
"Optional command-line arguments provide more control over the installation "
"process, the distutils package offers many places to override defaults -- "
"separating the build from the install, building or installing in non-default "
"directories, and more."
msgstr ""
"Группа SIG по распространению утилит под руководством Грега Уорда создала "
"Distutils, систему, значительно упрощающую установку пакетов. Они образуют "
"пакет distutils, новую часть стандартной библиотеки Python. В лучшем случае "
"установка модуля Python из исходного кода потребует тех же шагов: сначала вы "
"просто распаковываете tarball или zip-архив и запускаете «``python setup.py "
"install``». Платформа будет автоматически обнаружена, компилятор будет "
"распознан, модули расширения C будут скомпилированы, а дистрибутив "
"установлен в соответствующий каталог. Необязательные аргументы командной "
"строки обеспечивают больший контроль над процессом установки, пакет "
"distutils предлагает множество мест для переопределения значений по "
"умолчанию — разделение сборки от установки, сборка или установка в "
"каталогах, отличных от стандартных, и многое другое."

#: ../../whatsnew/2.0.rst:834
msgid ""
"In order to use the Distutils, you need to write a :file:`setup.py` script.  "
"For the simple case, when the software contains only .py files, a minimal :"
"file:`setup.py` can be just a few lines long::"
msgstr ""
"Щоб використовувати Distutils, вам потрібно написати сценарій :file:`setup."
"py`. У простому випадку, коли програмне забезпечення містить лише файли .py, "
"мінімальний файл :file:`setup.py` може складатися лише з кількох рядків::"

#: ../../whatsnew/2.0.rst:838
msgid ""
"from distutils.core import setup\n"
"setup (name = \"foo\", version = \"1.0\",\n"
"       py_modules = [\"module1\", \"module2\"])"
msgstr ""

#: ../../whatsnew/2.0.rst:842
msgid ""
"The :file:`setup.py` file isn't much more complicated if the software "
"consists of a few packages::"
msgstr ""
"Файл :file:`setup.py` не є набагато складнішим, якщо програмне забезпечення "
"складається з кількох пакетів::"

#: ../../whatsnew/2.0.rst:845
msgid ""
"from distutils.core import setup\n"
"setup (name = \"foo\", version = \"1.0\",\n"
"       packages = [\"package\", \"package.subpackage\"])"
msgstr ""

#: ../../whatsnew/2.0.rst:849
msgid ""
"A C extension can be the most complicated case; here's an example taken from "
"the PyXML package::"
msgstr ""
"Розширення C може бути найскладнішим випадком; ось приклад, взятий з пакета "
"PyXML::"

#: ../../whatsnew/2.0.rst:852
msgid ""
"from distutils.core import setup, Extension\n"
"\n"
"expat_extension = Extension('xml.parsers.pyexpat',\n"
"     define_macros = [('XML_NS', None)],\n"
"     include_dirs = [ 'extensions/expat/xmltok',\n"
"                      'extensions/expat/xmlparse' ],\n"
"     sources = [ 'extensions/pyexpat.c',\n"
"                 'extensions/expat/xmltok/xmltok.c',\n"
"                 'extensions/expat/xmltok/xmlrole.c', ]\n"
"       )\n"
"setup (name = \"PyXML\", version = \"0.5.4\",\n"
"       ext_modules =[ expat_extension ] )"
msgstr ""

#: ../../whatsnew/2.0.rst:865
msgid ""
"The Distutils can also take care of creating source and binary "
"distributions. The \"sdist\" command, run by \"``python setup.py sdist``', "
"builds a source distribution such as :file:`foo-1.0.tar.gz`. Adding new "
"commands isn't difficult, \"bdist_rpm\" and \"bdist_wininst\" commands have "
"already been contributed to create an RPM distribution and a Windows "
"installer for the software, respectively.  Commands to create other "
"distribution formats such as Debian packages and Solaris :file:`.pkg` files "
"are in various stages of development."
msgstr ""
"Distutils також може подбати про створення вихідних і двійкових "
"дистрибутивів. Команда \"sdist\", яку запускає \"``python setup.py "
"sdist``\", створює вихідний дистрибутив, такий як :file:`foo-1.0.tar.gz`. "
"Додавати нові команди не складно, \"bdist_rpm\" Команди \"bdist_wininst\" і "
"\"bdist_wininst\" вже були використані для створення дистрибутива RPM і "
"інсталятора Windows для програмного забезпечення відповідно."

#: ../../whatsnew/2.0.rst:874
msgid ""
"All this is documented in a new manual, *Distributing Python Modules*, that "
"joins the basic set of Python documentation."
msgstr ""
"Усе це задокументовано в новому посібнику *Розповсюдження модулів Python*, "
"який доповнює базовий набір документації Python."

#: ../../whatsnew/2.0.rst:881
msgid "XML Modules"
msgstr "Moduły XML"

#: ../../whatsnew/2.0.rst:883
msgid ""
"Python 1.5.2 included a simple XML parser in the form of the :mod:`!xmllib` "
"module, contributed by Sjoerd Mullender.  Since 1.5.2's release, two "
"different interfaces for processing XML have become common: SAX2 (version 2 "
"of the Simple API for XML) provides an event-driven interface with some "
"similarities to :mod:`!xmllib`, and the DOM (Document Object Model) provides "
"a tree-based interface, transforming an XML document into a tree of nodes "
"that can be traversed and modified.  Python 2.0 includes a SAX2 interface "
"and a stripped-down DOM interface as part of the :mod:`xml` package. Here we "
"will give a brief overview of these new interfaces; consult the Python "
"documentation or the source code for complete details. The Python XML SIG is "
"also working on improved documentation."
msgstr ""
"Python 1.5.2 включал простой синтаксический анализатор XML в виде модуля :"
"mod:`!xmllib`, созданного Сьёрдом Мюллендером. С момента выпуска 1.5.2 стали "
"распространены два разных интерфейса для обработки XML: SAX2 (версия 2 "
"Simple API для XML) предоставляет управляемый событиями интерфейс, имеющий "
"некоторое сходство с :mod:`!xmllib` и DOM (Document Object Model) "
"предоставляет древовидный интерфейс, преобразующий XML-документ в дерево "
"узлов, которое можно просматривать и изменять. Python 2.0 включает интерфейс "
"SAX2 и урезанный интерфейс DOM как часть пакета :mod:`xml`. Здесь мы дадим "
"краткий обзор этих новых интерфейсов; для получения полной информации "
"обратитесь к документации Python или исходному коду. Python XML SIG также "
"работает над улучшением документации."

#: ../../whatsnew/2.0.rst:897
msgid "SAX2 Support"
msgstr "Obsługa SAX2"

#: ../../whatsnew/2.0.rst:899
msgid ""
"SAX defines an event-driven interface for parsing XML.  To use SAX, you must "
"write a SAX handler class.  Handler classes inherit from various classes "
"provided by SAX, and override various methods that will then be called by "
"the XML parser.  For example, the :meth:`~xml.sax.handler.ContentHandler."
"startElement` and :meth:`~xml.sax.handler.ContentHandler.endElement` methods "
"are called for every starting and end tag encountered by the parser, the :"
"meth:`~xml.sax.handler.ContentHandler.characters` method is called for every "
"chunk of character data, and so forth."
msgstr ""
"SAX определяет управляемый событиями интерфейс для анализа XML. Чтобы "
"использовать SAX, вы должны написать класс-обработчик SAX. Классы-"
"обработчики наследуют различные классы, предоставляемые SAX, и "
"переопределяют различные методы, которые затем будут вызываться анализатором "
"XML. Например, методы :meth:`~xml.sax.handler.ContentHandler.startElement` "
"и :meth:`~xml.sax.handler.ContentHandler.endElement` вызываются для каждого "
"начального и конечного тега, обнаруженного анализатором, Метод :meth:`~xml."
"sax.handler.ContentHandler.characters` вызывается для каждого фрагмента "
"символьных данных и так далее."

#: ../../whatsnew/2.0.rst:907
msgid ""
"The advantage of the event-driven approach is that the whole document "
"doesn't have to be resident in memory at any one time, which matters if you "
"are processing really huge documents.  However, writing the SAX handler "
"class can get very complicated if you're trying to modify the document "
"structure in some elaborate way."
msgstr ""
"Перевага керованого подіями підходу полягає в тому, що весь документ не "
"повинен постійно зберігатися в пам’яті в будь-який момент часу, що має "
"значення, якщо ви обробляєте дійсно великі документи. Однак написання класу "
"обробника SAX може стати дуже складним, якщо ви намагаєтесь модифікувати "
"структуру документа якимось складним чином."

#: ../../whatsnew/2.0.rst:913
msgid ""
"For example, this little example program defines a handler that prints a "
"message for every starting and ending tag, and then parses the file :file:"
"`hamlet.xml` using it::"
msgstr ""
"Наприклад, цей маленький приклад програми визначає обробник, який друкує "
"повідомлення для кожного початкового та кінцевого тегу, а потім аналізує "
"файл :file:`hamlet.xml`, використовуючи його:"

#: ../../whatsnew/2.0.rst:917
msgid ""
"from xml import sax\n"
"\n"
"class SimpleHandler(sax.ContentHandler):\n"
"    def startElement(self, name, attrs):\n"
"        print 'Start of element:', name, attrs.keys()\n"
"\n"
"    def endElement(self, name):\n"
"        print 'End of element:', name\n"
"\n"
"# Create a parser object\n"
"parser = sax.make_parser()\n"
"\n"
"# Tell it what handler to use\n"
"handler = SimpleHandler()\n"
"parser.setContentHandler( handler )\n"
"\n"
"# Parse a file!\n"
"parser.parse( 'hamlet.xml' )"
msgstr ""

#: ../../whatsnew/2.0.rst:936
msgid ""
"For more information, consult the Python documentation, or the XML HOWTO at "
"https://pyxml.sourceforge.net/topics/howto/xml-howto.html."
msgstr ""
"Для получения дополнительной информации обратитесь к документации Python или "
"XML HOWTO по адресу https://pyxml.sourceforge.net/topics/howto/xml-howto."
"html."

#: ../../whatsnew/2.0.rst:941
msgid "DOM Support"
msgstr "Підтримка DOM"

#: ../../whatsnew/2.0.rst:943
msgid ""
"The Document Object Model is a tree-based representation for an XML "
"document.  A top-level :class:`!Document` instance is the root of the tree, "
"and has a single child which is the top-level :class:`!Element` instance. "
"This :class:`!Element` has children nodes representing character data and "
"any sub-elements, which may have further children of their own, and so "
"forth.  Using the DOM you can traverse the resulting tree any way you like, "
"access element and attribute values, insert and delete nodes, and convert "
"the tree back into XML."
msgstr ""
"Объектная модель документа — это древовидное представление XML-документа. "
"Экземпляр :class:`!Document` верхнего уровня является корнем дерева и имеет "
"единственного дочернего элемента, который является экземпляром :class:`!"
"Element` верхнего уровня. Этот :class:`!Element` имеет дочерние узлы, "
"представляющие символьные данные и любые подэлементы, которые могут иметь "
"собственные дочерние элементы и т.д. Используя DOM, вы можете перемещаться "
"по результирующему дереву любым удобным для вас способом, получать доступ к "
"значениям элементов и атрибутов, вставлять и удалять узлы и преобразовывать "
"дерево обратно в XML."

#: ../../whatsnew/2.0.rst:951
msgid ""
"The DOM is useful for modifying XML documents, because you can create a DOM "
"tree, modify it by adding new nodes or rearranging subtrees, and then "
"produce a new XML document as output.  You can also construct a DOM tree "
"manually and convert it to XML, which can be a more flexible way of "
"producing XML output than simply writing ``<tag1>``...\\ ``</tag1>`` to a "
"file."
msgstr ""
"DOM корисний для модифікації XML-документів, оскільки ви можете створити "
"дерево DOM, змінити його, додавши нові вузли або перевпорядкувавши "
"піддерева, а потім створити новий XML-документ як результат. Ви також можете "
"побудувати дерево DOM вручну та перетворити його на XML, що може бути більш "
"гнучким способом створення виводу XML, ніж просто запис ``<tag1>``...\\ ``</"
"tag1>`` у файл."

#: ../../whatsnew/2.0.rst:957
msgid ""
"The DOM implementation included with Python lives in the :mod:`xml.dom."
"minidom` module.  It's a lightweight implementation of the Level 1 DOM with "
"support for XML namespaces.  The  :func:`!parse` and :func:`!parseString` "
"convenience functions are provided for generating a DOM tree::"
msgstr ""
"Реализация DOM, включенная в Python, находится в модуле :mod:`xml.dom."
"minidom`. Это облегченная реализация DOM уровня 1 с поддержкой пространств "
"имен XML. Для создания дерева DOM предусмотрены удобные функции :func:`!"
"parse` и :func:`!parseString`:"

#: ../../whatsnew/2.0.rst:962
msgid ""
"from xml.dom import minidom\n"
"doc = minidom.parse('hamlet.xml')"
msgstr ""

#: ../../whatsnew/2.0.rst:965
msgid ""
"``doc`` is a :class:`!Document` instance.  :class:`!Document`, like all the "
"other DOM classes such as :class:`!Element` and :class:`Text`, is a subclass "
"of the :class:`!Node` base class.  All the nodes in a DOM tree therefore "
"support certain common methods, such as :meth:`!toxml` which returns a "
"string containing the XML representation of the node and its children.  Each "
"class also has special methods of its own; for example, :class:`!Element` "
"and :class:`!Document` instances have a method to find all child elements "
"with a given tag name. Continuing from the previous 2-line example::"
msgstr ""
"``doc`` — это экземпляр :class:`!Document`. :class:`!Document`, как и все "
"другие классы DOM, такие как :class:`!Element` и :class:`Text`, является "
"подклассом базового класса :class:`!Node`. Таким образом, все узлы в дереве "
"DOM поддерживают определенные общие методы, такие как :meth:`!toxml`, "
"который возвращает строку, содержащую XML-представление узла и его дочерних "
"элементов. Каждый класс также имеет свои собственные методы; например, "
"экземпляры :class:`!Element` и :class:`!Document` имеют метод для поиска "
"всех дочерних элементов с заданным именем тега. Продолжая предыдущий "
"двухстрочный пример:"

#: ../../whatsnew/2.0.rst:974
msgid ""
"perslist = doc.getElementsByTagName( 'PERSONA' )\n"
"print perslist[0].toxml()\n"
"print perslist[1].toxml()"
msgstr ""

#: ../../whatsnew/2.0.rst:978
msgid "For the *Hamlet* XML file, the above few lines output::"
msgstr "Dla pliku *Hamlet* XML, powyższe kilka wierszy daje wynik::"

#: ../../whatsnew/2.0.rst:980
msgid ""
"<PERSONA>CLAUDIUS, king of Denmark. </PERSONA>\n"
"<PERSONA>HAMLET, son to the late, and nephew to the present king.</PERSONA>"
msgstr ""

#: ../../whatsnew/2.0.rst:983
msgid ""
"The root element of the document is available as ``doc.documentElement``, "
"and its children can be easily modified by deleting, adding, or removing "
"nodes::"
msgstr ""
"Кореневий елемент документа доступний як ``doc.documentElement``, і його "
"дочірні елементи можна легко змінити шляхом видалення, додавання або "
"вилучення вузлів:"

#: ../../whatsnew/2.0.rst:986
msgid ""
"root = doc.documentElement\n"
"\n"
"# Remove the first child\n"
"root.removeChild( root.childNodes[0] )\n"
"\n"
"# Move the new first child to the end\n"
"root.appendChild( root.childNodes[0] )\n"
"\n"
"# Insert the new first child (originally,\n"
"# the third child) before the 20th child.\n"
"root.insertBefore( root.childNodes[0], root.childNodes[20] )"
msgstr ""

#: ../../whatsnew/2.0.rst:998
msgid ""
"Again, I will refer you to the Python documentation for a complete listing "
"of the different :class:`!Node` classes and their various methods."
msgstr ""
"Опять же, я отсылаю вас к документации Python для получения полного списка "
"различных классов :class:`!Node` и их различных методов."

#: ../../whatsnew/2.0.rst:1003
msgid "Relationship to PyXML"
msgstr "Związek z PyXML"

#: ../../whatsnew/2.0.rst:1005
msgid ""
"The XML Special Interest Group has been working on XML-related Python code "
"for a while.  Its code distribution, called PyXML, is available from the "
"SIG's web pages at https://www.python.org/community/sigs/current/xml-sig. "
"The PyXML distribution also used the package name ``xml``.  If you've "
"written programs that used PyXML, you're probably wondering about its "
"compatibility with the 2.0 :mod:`xml` package."
msgstr ""
"Група спеціальних інтересів XML деякий час працювала над кодом Python, "
"пов’язаним із XML. Його розповсюдження коду під назвою PyXML доступне на веб-"
"сторінках SIG за адресою https://www.python.org/community/sigs/current/xml-"
"sig. Дистрибутив PyXML також використовував назву пакета ``xml``. Якщо ви "
"писали програми, які використовували PyXML, ви, ймовірно, цікавитеся його "
"сумісністю з пакетом 2.0 :mod:`xml`."

#: ../../whatsnew/2.0.rst:1011
msgid ""
"The answer is that Python 2.0's :mod:`xml` package isn't compatible with "
"PyXML, but can be made compatible by installing a recent version PyXML.  "
"Many applications can get by with the XML support that is included with "
"Python 2.0, but more complicated applications will require that the full "
"PyXML package will be installed.  When installed, PyXML versions 0.6.0 or "
"greater will replace the :mod:`xml` package shipped with Python, and will be "
"a strict superset of the standard package, adding a bunch of additional "
"features.  Some of the additional features in PyXML include:"
msgstr ""
"Відповідь полягає в тому, що пакет :mod:`xml` Python 2.0 несумісний з PyXML, "
"але його можна зробити сумісним, встановивши останню версію PyXML. Багато "
"програм можуть обійтися підтримкою XML, яка включена в Python 2.0, але "
"складніші програми вимагають інсталяції повного пакета PyXML. Після "
"встановлення PyXML версії 0.6.0 або новішої замінить пакет :mod:`xml`, який "
"постачається разом із Python, і стане строгим доповненням до стандартного "
"пакета, додаючи купу додаткових функцій. Деякі з додаткових функцій у PyXML "
"включають:"

#: ../../whatsnew/2.0.rst:1020
msgid "4DOM, a full DOM implementation from FourThought, Inc."
msgstr "4DOM, повна реалізація DOM від FourThought, Inc."

#: ../../whatsnew/2.0.rst:1022
msgid "The xmlproc validating parser, written by Lars Marius Garshol."
msgstr "Парсер перевірки xmlproc, написаний Ларсом Маріусом Гаршолом."

#: ../../whatsnew/2.0.rst:1024
msgid "The :mod:`!sgmlop` parser accelerator module, written by Fredrik Lundh."
msgstr "Модуль ускорения парсера :mod:`!sgmlop`, написанный Фредриком Лундом."

#: ../../whatsnew/2.0.rst:1030
msgid "Module changes"
msgstr "Zmiany modułów"

#: ../../whatsnew/2.0.rst:1032
msgid ""
"Lots of improvements and bugfixes were made to Python's extensive standard "
"library; some of the affected modules include :mod:`readline`, :mod:"
"`ConfigParser <configparser>`, :mod:`!cgi`, :mod:`calendar`, :mod:`posix`, :"
"mod:`readline`, :mod:`!xmllib`, :mod:`!aifc`, :mod:`!chunk`, :mod:`wave`, :"
"mod:`random`, :mod:`shelve`, and :mod:`!nntplib`.  Consult the CVS logs for "
"the exact patch-by-patch details."
msgstr ""
"В обширную стандартную библиотеку Python было внесено множество улучшений и "
"исправлений; некоторые из затронутых модулей включают :mod:`readline`, :mod:"
"`ConfigParser <configparser>`, :mod:`!cgi`, :mod:`calendar`, :mod:`posix`, :"
"mod:`readline `, :mod:`!xmllib`, :mod:`!aifc`, :mod:`!chunk`, :mod:`wave`, :"
"mod:`random`, :mod:`shelve` и :mod :`!nntplib`. Обратитесь к журналам CVS "
"для получения точных деталей каждого патча."

#: ../../whatsnew/2.0.rst:1038
msgid ""
"Brian Gallew contributed OpenSSL support for the :mod:`socket` module.  "
"OpenSSL is an implementation of the Secure Socket Layer, which encrypts the "
"data being sent over a socket.  When compiling Python, you can edit :file:"
"`Modules/Setup` to include SSL support, which adds an additional function to "
"the :mod:`socket` module: ``socket.ssl(socket, keyfile, certfile)``, which "
"takes a socket object and returns an SSL socket.  The :mod:`httplib <http>` "
"and :mod:`urllib` modules were also changed to support ``https://`` URLs, "
"though no one has implemented FTP or SMTP over SSL."
msgstr ""
"Брайан Гэллью предоставил поддержку OpenSSL для модуля :mod:`socket`. "
"OpenSSL — это реализация Secure Socket Layer, которая шифрует данные, "
"отправляемые через сокет. При компиляции Python вы можете отредактировать :"
"file:`Modules/Setup`, чтобы включить поддержку SSL, что добавляет "
"дополнительную функцию к модулю :mod:`socket`: ``socket.ssl(socket, keyfile, "
"certfile)``, который принимает объект сокета и возвращает сокет SSL. Модули :"
"mod:`httplib <http>` и :mod:`urllib` также были изменены для поддержки URL-"
"адресов ``https://``, хотя никто не реализовал FTP или SMTP через SSL."

#: ../../whatsnew/2.0.rst:1047
msgid ""
"The :mod:`httplib <http>` module has been rewritten by Greg Stein to support "
"HTTP/1.1."
msgstr ""
"Модуль :mod:`httplib <http>` был переписан Грегом Стейном для поддержки "
"HTTP/1.1."

#: ../../whatsnew/2.0.rst:1049
msgid ""
"Backward compatibility with the 1.5 version of :mod:`!httplib` is provided, "
"though using HTTP/1.1 features such as pipelining will require rewriting "
"code to use a different set of interfaces."
msgstr ""
"Обеспечена обратная совместимость с версией :mod:`!httplib` 1.5, однако "
"использование функций HTTP/1.1, таких как конвейерная обработка, потребует "
"переписывания кода для использования другого набора интерфейсов."

#: ../../whatsnew/2.0.rst:1053
msgid ""
"The :mod:`!Tkinter` module now supports Tcl/Tk version 8.1, 8.2, or 8.3, and "
"support for the older 7.x versions has been dropped.  The Tkinter module now "
"supports displaying Unicode strings in Tk widgets. Also, Fredrik Lundh "
"contributed an optimization which makes operations like ``create_line`` and "
"``create_polygon`` much faster, especially when using lots of coordinates."
msgstr ""
"Модуль :mod:`!Tkinter` теперь поддерживает Tcl/Tk версии 8.1, 8.2 или 8.3, а "
"поддержка более старых версий 7.x прекращена. Модуль Tkinter теперь "
"поддерживает отображение строк Unicode в виджетах Tk. Кроме того, Фредрик "
"Лунд внес оптимизацию, которая делает такие операции, как create_line и "
"create_polygon, намного быстрее, особенно при использовании большого "
"количества координат."

#: ../../whatsnew/2.0.rst:1059
msgid ""
"The :mod:`curses` module has been greatly extended, starting from Oliver "
"Andrich's enhanced version, to provide many additional functions from "
"ncurses and SYSV curses, such as colour, alternative character set support, "
"pads, and mouse support.  This means the module is no longer compatible with "
"operating systems that only have BSD curses, but there don't seem to be any "
"currently maintained OSes that fall into this category."
msgstr ""
"Модуль :mod:`curses` було значно розширено, починаючи з розширеної версії "
"Олівера Андріча, щоб забезпечити багато додаткових функцій від ncurses і "
"проклять SYSV, таких як колір, підтримка альтернативного набору символів, "
"підтримка панелей і миші. Це означає, що модуль більше не сумісний з "
"операційними системами, які мають лише прокляття BSD, але, здається, на "
"даний момент немає жодної ОС, яка підпадає під цю категорію."

#: ../../whatsnew/2.0.rst:1066
msgid ""
"As mentioned in the earlier discussion of 2.0's Unicode support, the "
"underlying implementation of the regular expressions provided by the :mod:"
"`re` module has been changed.  SRE, a new regular expression engine written "
"by Fredrik Lundh and partially funded by Hewlett Packard, supports matching "
"against both 8-bit strings and Unicode strings."
msgstr ""
"Як згадувалося в попередньому обговоренні підтримки Unicode 2.0, базову "
"реалізацію регулярних виразів, які надає модуль :mod:`re`, було змінено. "
"SRE, нова система регулярних виразів, написана Фредріком Лундом і частково "
"фінансована Hewlett Packard, підтримує зіставлення як з 8-бітними рядками, "
"так і з рядками Unicode."

#: ../../whatsnew/2.0.rst:1076
msgid "New modules"
msgstr "Nowe moduły"

#: ../../whatsnew/2.0.rst:1078
msgid ""
"A number of new modules were added.  We'll simply list them with brief "
"descriptions; consult the 2.0 documentation for the details of a particular "
"module."
msgstr ""
"Додано ряд нових модулів. Ми просто перерахуємо їх із короткими описами; "
"зверніться до документації 2.0, щоб дізнатися більше про конкретний модуль."

#: ../../whatsnew/2.0.rst:1082
msgid ""
":mod:`atexit`:  For registering functions to be called before the Python "
"interpreter exits. Code that currently sets ``sys.exitfunc`` directly should "
"be changed to  use the :mod:`atexit` module instead, importing :mod:`atexit` "
"and calling :func:`atexit.register` with  the function to be called on exit. "
"(Contributed by Skip Montanaro.)"
msgstr ""
":mod:`atexit`: для реєстрації функцій, які будуть викликані до завершення "
"роботи інтерпретатора Python. Код, який наразі безпосередньо встановлює "
"``sys.exitfunc``, слід змінити, щоб замість нього використовувати модуль :"
"mod:`atexit`, імпортуючи :mod:`atexit` і викликаючи :func:`atexit.register` "
"із функцією, яку потрібно викликати на виході. (Надав Скіп Монтанаро.)"

#: ../../whatsnew/2.0.rst:1088
msgid ""
":mod:`codecs`, :mod:`!encodings`, :mod:`unicodedata`:  Added as part of the "
"new Unicode support."
msgstr ""
":mod:`codecs`, :mod:`!encodings`, :mod:`unicodedata`: Добавлено как часть "
"новой поддержки Unicode."

#: ../../whatsnew/2.0.rst:1091
msgid ""
":mod:`filecmp`: Supersedes the old :mod:`!cmp`, :mod:`!cmpcache` and :mod:`!"
"dircmp` modules, which have now become deprecated. (Contributed by Gordon "
"MacMillan and Moshe Zadka.)"
msgstr ""
":mod:`filecmp`: Заменяет старые модули :mod:`!cmp`, :mod:`!cmpcache` и :mod:"
"`!dircmp`, которые теперь устарели. (Сообщили Гордон Макмиллан и Моше Задка.)"

#: ../../whatsnew/2.0.rst:1095
msgid ""
":mod:`gettext`: This module provides internationalization (I18N) and "
"localization (L10N) support for Python programs by providing an interface to "
"the GNU gettext message catalog library. (Integrated by Barry Warsaw, from "
"separate contributions by Martin  von Löwis, Peter Funk, and James "
"Henstridge.)"
msgstr ""
":mod:`gettext`: Цей модуль забезпечує підтримку інтернаціоналізації (I18N) і "
"локалізації (L10N) для програм Python, надаючи інтерфейс до бібліотеки "
"каталогу повідомлень GNU gettext. (Інтегровано Баррі Варшау, з окремих "
"внесків Мартіна фон Льовіса, Пітера Функа та Джеймса Генстріджа.)"

#: ../../whatsnew/2.0.rst:1100
msgid ""
":mod:`!linuxaudiodev`: Support for the :file:`/dev/audio` device on Linux, a "
"twin to the existing :mod:`!sunaudiodev` module. (Contributed by Peter "
"Bosch, with fixes by Jeremy Hylton.)"
msgstr ""
":mod:`!linuxaudiodev`: Поддержка устройства :file:`/dev/audio` в Linux, "
"двойника существующего модуля :mod:`!sunaudiodev`. (Представлено Питером "
"Бошем, исправления Джереми Хилтона.)"

#: ../../whatsnew/2.0.rst:1104
msgid ""
":mod:`mmap`: An interface to memory-mapped files on both Windows and Unix.  "
"A file's contents can be mapped directly into memory, at which point it "
"behaves like a mutable string, so its contents can be read and modified.  "
"They can even be passed to functions that expect ordinary strings, such as "
"the :mod:`re` module. (Contributed by Sam Rushing, with some extensions by A."
"M. Kuchling.)"
msgstr ""
":mod:`mmap`: Інтерфейс для файлів із відображенням пам’яті як у Windows, так "
"і в Unix. Вміст файлу можна відобразити безпосередньо в пам’яті, після чого "
"він поводиться як змінний рядок, тому його вміст можна читати та змінювати. "
"Їх можна навіть передати функціям, які очікують звичайних рядків, наприклад, "
"модулю :mod:`re`. (Надано Семом Рашингом, з деякими розширеннями А. М. "
"Кухлінгом.)"

#: ../../whatsnew/2.0.rst:1110
msgid ""
":mod:`!pyexpat`: An interface to the Expat XML parser. (Contributed by Paul "
"Prescod.)"
msgstr ""
":mod:`!pyexpat`: Интерфейс для парсера Expat XML. (Предоставлено Полом "
"Прескодом.)"

#: ../../whatsnew/2.0.rst:1113
msgid ""
":mod:`robotparser <urllib.robotparser>`: Parse a :file:`robots.txt` file, "
"which is used for writing web spiders that politely avoid certain areas of a "
"web site.  The parser accepts the contents of a :file:`robots.txt` file, "
"builds a set of rules from it, and can then answer questions about the "
"fetchability of a given URL.  (Contributed by Skip Montanaro.)"
msgstr ""
":mod:`robotparser <urllib.robotparser>`: анализирует файл :file:`robots."
"txt`, который используется для написания веб-пауков, которые вежливо "
"избегают определенных областей веб-сайта. Анализатор принимает содержимое "
"файла :file:`robots.txt`, строит из него набор правил и затем может отвечать "
"на вопросы о возможности выборки данного URL-адреса. (Предоставлено Скипом "
"Монтанаро.)"

#: ../../whatsnew/2.0.rst:1119
msgid ""
":mod:`tabnanny`: A module/script to  check Python source code for ambiguous "
"indentation. (Contributed by Tim Peters.)"
msgstr ""
":mod:`tabnanny`: Модуль/скрипт для перевірки вихідного коду Python на "
"неоднозначні відступи. (Надав Тім Пітерс.)"

#: ../../whatsnew/2.0.rst:1122
msgid ""
":mod:`!UserString`: A base class useful for deriving objects that behave "
"like strings."
msgstr ""
":mod:`!UserString`: Базовый класс, полезный для создания объектов, которые "
"ведут себя как строки."

#: ../../whatsnew/2.0.rst:1125
msgid ""
":mod:`webbrowser`: A module that provides a platform independent way to "
"launch a web browser on a specific URL. For each platform, various browsers "
"are tried in a specific order. The user can alter which browser is launched "
"by setting the *BROWSER* environment variable.  (Originally inspired by Eric "
"S. Raymond's patch to :mod:`urllib` which added similar functionality, but "
"the final module comes from code originally  implemented by Fred Drake as :"
"file:`Tools/idle/BrowserControl.py`, and adapted for the standard library by "
"Fred.)"
msgstr ""
":mod:`webbrowser`: модуль, який забезпечує незалежний від платформи спосіб "
"запуску веб-браузера за певною URL-адресою. Для кожної платформи різні "
"браузери пробуються в певному порядку. Користувач може змінити браузер, який "
"запускається, встановивши змінну середовища *BROWSER*. (Спочатку натхненний "
"патчем Еріка С. Реймонда до :mod:`urllib`, який додав подібну "
"функціональність, але остаточний модуль походить від коду, спочатку "
"реалізованого Фредом Дрейком як :file:`Tools/idle/BrowserControl.py`, і "
"адаптованого для стандартна бібліотека Фреда.)"

#: ../../whatsnew/2.0.rst:1134
msgid ""
":mod:`_winreg <winreg>`: An interface to the Windows registry.  :mod:`!"
"_winreg` is an adaptation of functions that have been part of PythonWin "
"since 1995, but has now been added to the core  distribution, and enhanced "
"to support Unicode. :mod:`!_winreg` was written by Bill Tutt and Mark "
"Hammond."
msgstr ""
":mod:`_winreg <winreg>`: интерфейс к реестру Windows. :mod:`!_winreg` — это "
"адаптация функций, которые были частью PythonWin с 1995 года, но теперь "
"добавлены в основной дистрибутив и улучшены для поддержки Unicode. :mod:`!"
"_winreg` был написан Биллом Таттом и Марком Хаммондом."

#: ../../whatsnew/2.0.rst:1139
msgid ""
":mod:`zipfile`: A module for reading and writing ZIP-format archives.  These "
"are archives produced by :program:`PKZIP` on DOS/Windows or :program:`zip` "
"on Unix, not to be confused with :program:`gzip`\\ -format files (which are "
"supported by the :mod:`gzip` module) (Contributed by James C. Ahlstrom.)"
msgstr ""
":mod:`zipfile`: Модуль для читання та запису архівів ZIP-формату. Це архіви, "
"створені :program:`PKZIP` у DOS/Windows або :program:`zip` в Unix, не "
"плутати з файлами у форматі :program:`gzip`\\ (які підтримуються модулем :"
"mod:`gzip`) (надано Джеймсом К. Алстромом.)"

#: ../../whatsnew/2.0.rst:1144
msgid ""
":mod:`!imputil`: A module that provides a simpler way for writing customized "
"import hooks, in comparison to the existing :mod:`!ihooks` module.  "
"(Implemented by Greg Stein, with much discussion on python-dev along the "
"way.)"
msgstr ""
":mod:`!imputil`: Модуль, который обеспечивает более простой способ написания "
"настраиваемых перехватчиков импорта по сравнению с существующим модулем :mod:"
"`!ihooks`. (Реализован Грегом Стейном, попутно много обсуждая python-dev.)"

#: ../../whatsnew/2.0.rst:1152
msgid "IDLE Improvements"
msgstr "Ulepszenia IDLE"

#: ../../whatsnew/2.0.rst:1154
msgid ""
"IDLE is the official Python cross-platform IDE, written using Tkinter. "
"Python 2.0 includes IDLE 0.6, which adds a number of new features and "
"improvements.  A partial list:"
msgstr ""
"IDLE — це офіційна кросплатформна IDE Python, написана за допомогою Tkinter. "
"Python 2.0 містить IDLE 0.6, який додає низку нових функцій і покращень. "
"Неповний список:"

#: ../../whatsnew/2.0.rst:1158
msgid ""
"UI improvements and optimizations, especially in the area of syntax "
"highlighting and auto-indentation."
msgstr ""
"Покращення та оптимізація інтерфейсу користувача, особливо в області "
"підсвічування синтаксису та автоматичного відступу."

#: ../../whatsnew/2.0.rst:1161
msgid ""
"The class browser now shows more information, such as the top level "
"functions in a module."
msgstr ""
"Переглядач класів тепер показує більше інформації, наприклад функції "
"верхнього рівня в модулі."

#: ../../whatsnew/2.0.rst:1164
msgid ""
"Tab width is now a user settable option. When opening an existing Python "
"file, IDLE automatically detects the indentation conventions, and adapts."
msgstr ""
"Ширина вкладки тепер доступна користувачеві. Під час відкриття існуючого "
"файлу Python IDLE автоматично визначає правила відступів і адаптує їх."

#: ../../whatsnew/2.0.rst:1167
msgid ""
"There is now support for calling browsers on various platforms, used to open "
"the Python documentation in a browser."
msgstr ""
"Тепер існує підтримка виклику браузерів на різних платформах, які "
"використовуються для відкриття документації Python у браузері."

#: ../../whatsnew/2.0.rst:1170
msgid ""
"IDLE now has a command line, which is largely similar to  the vanilla Python "
"interpreter."
msgstr ""
"У IDLE тепер є командний рядок, який багато в чому схожий на ванільний "
"інтерпретатор Python."

#: ../../whatsnew/2.0.rst:1173
msgid "Call tips were added in many places."
msgstr "W wielu miejscach dodano wskazówki dotyczące połączeń."

#: ../../whatsnew/2.0.rst:1175
msgid "IDLE can now be installed as a package."
msgstr "IDLE można teraz zainstalować jako pakiet."

#: ../../whatsnew/2.0.rst:1177
msgid "In the editor window, there is now a line/column bar at the bottom."
msgstr "Тепер у вікні редактора внизу є рядок/стовпець."

#: ../../whatsnew/2.0.rst:1179
msgid ""
"Three new keystroke commands: Check module (:kbd:`Alt-F5`), Import module (:"
"kbd:`F5`) and Run script (:kbd:`Ctrl-F5`)."
msgstr ""
"Три нові команди натискання клавіш: перевірити модуль (:kbd:`Alt-F5`), "
"імпортувати модуль (:kbd:`F5`) і запустити сценарій (:kbd:`Ctrl-F5`)."

#: ../../whatsnew/2.0.rst:1186
msgid "Deleted and Deprecated Modules"
msgstr "Usunięte i przestarzałe moduły"

#: ../../whatsnew/2.0.rst:1188
msgid ""
"A few modules have been dropped because they're obsolete, or because there "
"are now better ways to do the same thing.  The :mod:`!stdwin` module is "
"gone; it was for a platform-independent windowing toolkit that's no longer "
"developed."
msgstr ""
"Несколько модулей были исключены, потому что они устарели или потому, что "
"теперь есть лучшие способы сделать то же самое. Модуль :mod:`!stdwin` исчез; "
"это был независимый от платформы набор оконных инструментов, который больше "
"не разрабатывается."

#: ../../whatsnew/2.0.rst:1192
msgid ""
"A number of modules have been moved to the :file:`lib-old` subdirectory: :"
"mod:`!cmp`, :mod:`!cmpcache`, :mod:`!dircmp`, :mod:`!dump`,  :mod:`!find`, :"
"mod:`!grep`, :mod:`!packmail`,  :mod:`!poly`, :mod:`!util`, :mod:`!"
"whatsound`, :mod:`!zmod`.  If you have code which relies on a module  that's "
"been moved to :file:`lib-old`, you can simply add that directory to ``sys."
"path``   to get them back, but you're encouraged to update any code that "
"uses these modules."
msgstr ""
"Ряд модулей были перенесены в подкаталог :file:`lib-old`: :mod:`!cmp`, :mod:"
"`!cmpcache`, :mod:`!dircmp`, :mod:`!dump` , :mod:`!find`, :mod:`!grep`, :mod:"
"`!packmail`, :mod:`!poly`, :mod:`!util`, :mod:`!whatsound`, : мод:`!zmod`. "
"Если у вас есть код, основанный на модуле, который был перемещен в :file:"
"`lib-old`, вы можете просто добавить этот каталог в ``sys.path``, чтобы "
"вернуть их, но вам рекомендуется обновить любой код. который использует эти "
"модули."

#: ../../whatsnew/2.0.rst:1201
msgid "Acknowledgements"
msgstr "Ucapan Terima Kasih"

#: ../../whatsnew/2.0.rst:1203
msgid ""
"The authors would like to thank the following people for offering "
"suggestions on various drafts of this article: David Bolen, Mark Hammond, "
"Gregg Hauser, Jeremy Hylton, Fredrik Lundh, Detlef Lannert, Aahz Maruch, "
"Skip Montanaro, Vladimir Marangozov, Tobias Polzin, Guido van Rossum, Neil "
"Schemenauer, and Russ Schmidt."
msgstr ""
"Автори хотіли б подякувати наступним людям за пропозиції щодо різних "
"чернеток цієї статті: Девід Болен, Марк Хаммонд, Грег Хаузер, Джеремі "
"Гілтон, Фредрік Лунд, Детлеф Ланнерт, Ааз Марух, Скіп Монтанаро, Володимир "
"Марангозов, Тобіас Ползін, Гвідо ван Россум, Ніл Шеменауер і Расс Шмідт."
