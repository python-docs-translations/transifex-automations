# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-21 22:20+0000\n"
"PO-Revision-Date: 2023-05-24 02:10+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../faq/extending.rst:3
msgid "Extending/Embedding FAQ"
msgstr "ЧаВО по расширению/встраиванию"

#: ../../faq/extending.rst:6
msgid "Contents"
msgstr " Содержание"

#: ../../faq/extending.rst:16
msgid "Can I create my own functions in C?"
msgstr "Могу ли я создавать свои собственные функции на C?"

#: ../../faq/extending.rst:18
msgid ""
"Yes, you can create built-in modules containing functions, variables, "
"exceptions and even new types in C.  This is explained in the document :ref:"
"`extending-index`."
msgstr ""
"Да, вы можете создавать встроенные модули, содержащие функции, переменные, "
"исключения и даже новые типы в C. Это объясняется в документе :ref:"
"`extending-index`."

#: ../../faq/extending.rst:22
msgid "Most intermediate or advanced Python books will also cover this topic."
msgstr ""
"Большинство книг по Python среднего или продвинутого уровня также охватывают "
"эту тему."

#: ../../faq/extending.rst:26
msgid "Can I create my own functions in C++?"
msgstr "Могу ли я создавать свои собственные функции на C++?"

#: ../../faq/extending.rst:28
msgid ""
"Yes, using the C compatibility features found in C++.  Place ``extern "
"\"C\" { ... }`` around the Python include files and put ``extern \"C\"`` "
"before each function that is going to be called by the Python interpreter.  "
"Global or static C++ objects with constructors are probably not a good idea."
msgstr ""
"Да, используя функции совместимости C, имеющиеся в C++. Поместите ``extern "
"\"C\" { ... }`` вокруг включаемых файлов Python и поместите ``extern \"C\"`` "
"перед каждой функцией, которая будет вызываться интерпретатором Python. "
"Глобальные или статические объекты C++ с конструкторами, вероятно, не "
"являются хорошей идеей."

#: ../../faq/extending.rst:37
msgid "Writing C is hard; are there any alternatives?"
msgstr "Писать на C сложно - есть ли какие-нибудь альтернативы?"

#: ../../faq/extending.rst:39
msgid ""
"There are a number of alternatives to writing your own C extensions, "
"depending on what you're trying to do."
msgstr ""
"Существует множество альтернатив написанию собственных расширений C, в "
"зависимости от того, что вы пытаетесь сделать."

#: ../../faq/extending.rst:44
msgid ""
"`Cython <https://cython.org>`_ and its relative `Pyrex <https://www.csse."
"canterbury.ac.nz/greg.ewing/python/Pyrex/>`_ are compilers that accept a "
"slightly modified form of Python and generate the corresponding C code.  "
"Cython and Pyrex make it possible to write an extension without having to "
"learn Python's C API."
msgstr ""
"`Cython <https://cython.org>`_ и его родственник `Pyrex <https://www.csse."
"canterbury.ac.nz/greg.ewing/python/Pyrex/>`_ являются компиляторами, которые "
"принимают слегка модифицированную форму Python и сгенерировать "
"соответствующий код C. Cython и Pyrex позволяют писать расширения без "
"необходимости изучения C API Python."

#: ../../faq/extending.rst:50
msgid ""
"If you need to interface to some C or C++ library for which no Python "
"extension currently exists, you can try wrapping the library's data types "
"and functions with a tool such as `SWIG <https://www.swig.org>`_.  `SIP "
"<https://github.com/Python-SIP/sip>`__, `CXX <https://cxx.sourceforge.net/"
">`_ `Boost <https://www.boost.org/libs/python/doc/index.html>`_, or `Weave "
"<https://github.com/scipy/weave>`_ are also alternatives for wrapping C++ "
"libraries."
msgstr ""
"Если вам нужно взаимодействовать с какой-либо библиотекой C или C++, для "
"которой в настоящее время не существует расширения Python, вы можете "
"попробовать обернуть типы данных и функции библиотеки с помощью такого "
"инструмента, как `SWIG <https://www.swig.org>`_. `SIP <https://github.com/"
"Python-SIP/sip>`__, `CXX <https://cxx.sourceforge.net/>`_ `Boost <https://"
"www.boost.org/libs /python/doc/index.html>`_ или `Weave <https://github.com/"
"scipy/weave>`_ также являются альтернативами для упаковки библиотек C++."

#: ../../faq/extending.rst:61
msgid "How can I execute arbitrary Python statements from C?"
msgstr "Как я могу выполнить произвольные инструкции Python из C?"

#: ../../faq/extending.rst:63
msgid ""
"The highest-level function to do this is :c:func:`PyRun_SimpleString` which "
"takes a single string argument to be executed in the context of the module "
"``__main__`` and returns ``0`` for success and ``-1`` when an exception "
"occurred (including :exc:`SyntaxError`).  If you want more control, use :c:"
"func:`PyRun_String`; see the source for :c:func:`PyRun_SimpleString` in "
"``Python/pythonrun.c``."
msgstr ""
"Функция самого высокого уровня для этого — :c:func:`PyRun_SimpleString`, "
"которая принимает один строковый аргумент для выполнения в контексте модуля "
"``__main__`` и возвращает ``0`` в случае успеха и ``- 1`` при возникновении "
"исключения (включая :exc:`SyntaxError`). Если вам нужен больший контроль, "
"используйте :c:func:`PyRun_String`; см. исходный код :c:func:"
"`PyRun_SimpleString` в ``Python/pythonrun.c``."

#: ../../faq/extending.rst:72
msgid "How can I evaluate an arbitrary Python expression from C?"
msgstr "Как я могу вычислить произвольное выражение Python из C?"

#: ../../faq/extending.rst:74
msgid ""
"Call the function :c:func:`PyRun_String` from the previous question with the "
"start symbol :c:data:`Py_eval_input`; it parses an expression, evaluates it "
"and returns its value."
msgstr ""
"Вызовите функцию :c:func:`PyRun_String` из предыдущего вопроса со стартовым "
"символом :c:data:`Py_eval_input`; он анализирует выражение, оценивает его и "
"возвращает его значение."

#: ../../faq/extending.rst:80
msgid "How do I extract C values from a Python object?"
msgstr "Как мне извлечь значения C из объекта Python?"

#: ../../faq/extending.rst:82
msgid ""
"That depends on the object's type.  If it's a tuple, :c:func:`PyTuple_Size` "
"returns its length and :c:func:`PyTuple_GetItem` returns the item at a "
"specified index.  Lists have similar functions, :c:func:`PyList_Size` and :c:"
"func:`PyList_GetItem`."
msgstr ""
"Это зависит от типа объекта. Если это кортеж, :c:func:`PyTuple_Size` "
"возвращает его длину, а :c:func:`PyTuple_GetItem` возвращает элемент по "
"указанному индексу. Списки имеют схожие функции: :c:func:`PyList_Size` и :c:"
"func:`PyList_GetItem`."

#: ../../faq/extending.rst:87
msgid ""
"For bytes, :c:func:`PyBytes_Size` returns its length and :c:func:"
"`PyBytes_AsStringAndSize` provides a pointer to its value and its length.  "
"Note that Python bytes objects may contain null bytes so C's :c:func:`!"
"strlen` should not be used."
msgstr ""
"Для байтов :c:func:`PyBytes_Size` возвращает их длину, а :c:func:"
"`PyBytes_AsStringAndSize` предоставляет указатель на их значение и длину. "
"Обратите внимание, что байтовые объекты Python могут содержать нулевые "
"байты, поэтому не следует использовать C :c:func:`!strlen`."

#: ../../faq/extending.rst:92
msgid ""
"To test the type of an object, first make sure it isn't ``NULL``, and then "
"use :c:func:`PyBytes_Check`, :c:func:`PyTuple_Check`, :c:func:"
"`PyList_Check`, etc."
msgstr ""
"Чтобы проверить тип объекта, сначала убедитесь, что он не NULL, а затем "
"используйте :c:func:`PyBytes_Check`, :c:func:`PyTuple_Check`, :c:func:"
"`PyList_Check` , и т. д."

#: ../../faq/extending.rst:95
msgid ""
"There is also a high-level API to Python objects which is provided by the so-"
"called 'abstract' interface -- read ``Include/abstract.h`` for further "
"details.  It allows interfacing with any kind of Python sequence using calls "
"like :c:func:`PySequence_Length`, :c:func:`PySequence_GetItem`, etc. as well "
"as many other useful protocols such as numbers (:c:func:`PyNumber_Index` et "
"al.) and mappings in the PyMapping APIs."
msgstr ""
"Существует также высокоуровневый API для объектов Python, который "
"предоставляется так называемым «абстрактным» интерфейсом — для получения "
"более подробной информации прочитайте ``Include/abstract.h``. Он позволяет "
"взаимодействовать с любым типом последовательности Python, используя такие "
"вызовы, как :c:func:`PySequence_Length`, :c:func:`PySequence_GetItem` и "
"т. д., а также многие другие полезные протоколы, такие как числа (:c:func:"
"`PyNumber_Index). ` и др.) и сопоставления в API PyMapping."

#: ../../faq/extending.rst:104
msgid "How do I use Py_BuildValue() to create a tuple of arbitrary length?"
msgstr ""
"Как использовать Py_BuildValue() для создания кортежа произвольной длины?"

#: ../../faq/extending.rst:106
msgid "You can't.  Use :c:func:`PyTuple_Pack` instead."
msgstr "Ты не можешь. Вместо этого используй :c:func:`PyTuple_Pack`."

#: ../../faq/extending.rst:110
msgid "How do I call an object's method from C?"
msgstr "Как мне вызвать метод объекта из C?"

#: ../../faq/extending.rst:112
msgid ""
"The :c:func:`PyObject_CallMethod` function can be used to call an arbitrary "
"method of an object.  The parameters are the object, the name of the method "
"to call, a format string like that used with :c:func:`Py_BuildValue`, and "
"the argument values::"
msgstr ""
"Функцию :c:func:`PyObject_CallMethod` можно использовать для вызова "
"произвольного метода объекта. Параметры — это объект, имя вызываемого "
"метода, строка формата, подобная той, которая используется с :c:func:"
"`Py_BuildValue`, и значения аргументов::"

#: ../../faq/extending.rst:121
msgid ""
"This works for any object that has methods -- whether built-in or user-"
"defined. You are responsible for eventually :c:func:`Py_DECREF`\\ 'ing the "
"return value."
msgstr ""
"Это работает для любого объекта, у которого есть методы — встроенные или "
"определяемые пользователем. Вы несете ответственность за окончательную "
"обработку возвращаемого значения."

#: ../../faq/extending.rst:124
msgid ""
"To call, e.g., a file object's \"seek\" method with arguments 10, 0 "
"(assuming the file object pointer is \"f\")::"
msgstr ""
"Чтобы вызвать, например, метод \"seek\" файлового объекта с аргументами 10, "
"0 (при условии, что указатель файлового объекта равен \"f\"):"

#: ../../faq/extending.rst:135
msgid ""
"Note that since :c:func:`PyObject_CallObject` *always* wants a tuple for the "
"argument list, to call a function without arguments, pass \"()\" for the "
"format, and to call a function with one argument, surround the argument in "
"parentheses, e.g. \"(i)\"."
msgstr ""
"Обратите внимание: поскольку :c:func:`PyObject_CallObject` *всегда* требует "
"кортеж для списка аргументов, для вызова функции без аргументов передайте "
"\"()\" в качестве формата, а для вызова функции с одним аргументом окружите "
"аргумент в скобках, например «(i)»."

#: ../../faq/extending.rst:142
msgid ""
"How do I catch the output from PyErr_Print() (or anything that prints to "
"stdout/stderr)?"
msgstr ""
"Как мне перехватить вывод PyErr_Print() (или чего-либо, что печатает на "
"стандартный вывод/stderr)?"

#: ../../faq/extending.rst:144
msgid ""
"In Python code, define an object that supports the ``write()`` method.  "
"Assign this object to :data:`sys.stdout` and :data:`sys.stderr`.  Call "
"print_error, or just allow the standard traceback mechanism to work. Then, "
"the output will go wherever your ``write()`` method sends it."
msgstr ""
"В коде Python определите объект, поддерживающий метод write(). Назначьте "
"этот объект :data:`sys.stdout` и :data:`sys.stderr`. Вызовите print_error "
"или просто разрешите работу стандартному механизму трассировки. Затем "
"выходные данные будут отправлены туда, куда их отправит ваш метод write()."

#: ../../faq/extending.rst:149
msgid "The easiest way to do this is to use the :class:`io.StringIO` class:"
msgstr ""
"Самый простой способ сделать это — использовать класс :class:`io.StringIO`:"

#: ../../faq/extending.rst:161
msgid "A custom object to do the same would look like this:"
msgstr "Пользовательский объект, делающий то же самое, будет выглядеть так:"

#: ../../faq/extending.rst:182
msgid "How do I access a module written in Python from C?"
msgstr "Как мне получить доступ к модулю, написанному на Python, из C?"

#: ../../faq/extending.rst:184
msgid "You can get a pointer to the module object as follows::"
msgstr "Вы можете получить указатель на объект модуля следующим образом:"

#: ../../faq/extending.rst:188
msgid ""
"If the module hasn't been imported yet (i.e. it is not yet present in :data:"
"`sys.modules`), this initializes the module; otherwise it simply returns the "
"value of ``sys.modules[\"<modulename>\"]``.  Note that it doesn't enter the "
"module into any namespace -- it only ensures it has been initialized and is "
"stored in :data:`sys.modules`."
msgstr ""
"Если модуль еще не импортирован (т.е. он еще не присутствует в :data:`sys."
"modules`), это инициализирует модуль; в противном случае он просто "
"возвращает значение ``sys.modules[\"<имя_модуля>\"]``. Обратите внимание, "
"что он не помещает модуль в какое-либо пространство имен — он лишь "
"гарантирует, что он был инициализирован и сохранен в :data:`sys.modules`."

#: ../../faq/extending.rst:194
msgid ""
"You can then access the module's attributes (i.e. any name defined in the "
"module) as follows::"
msgstr ""
"Затем вы можете получить доступ к атрибутам модуля (т. е. к любому имени, "
"определенному в модуле) следующим образом:"

#: ../../faq/extending.rst:199
msgid ""
"Calling :c:func:`PyObject_SetAttrString` to assign to variables in the "
"module also works."
msgstr ""
"Вызов :c:func:`PyObject_SetAttrString` для присвоения переменных в модуле "
"также работает."

#: ../../faq/extending.rst:204
msgid "How do I interface to C++ objects from Python?"
msgstr "Как мне взаимодействовать с объектами C++ из Python?"

#: ../../faq/extending.rst:206
msgid ""
"Depending on your requirements, there are many approaches.  To do this "
"manually, begin by reading :ref:`the \"Extending and Embedding\" document "
"<extending-index>`.  Realize that for the Python run-time system, there "
"isn't a whole lot of difference between C and C++ -- so the strategy of "
"building a new Python type around a C structure (pointer) type will also "
"work for C++ objects."
msgstr ""
"В зависимости от ваших требований существует множество подходов. Чтобы "
"сделать это вручную, начните с чтения :ref:`документа «Расширение и "
"встраивание» <extending-index>`. Помните, что для системы времени выполнения "
"Python нет большой разницы между C и C++, поэтому стратегия создания нового "
"типа Python на основе типа структуры (указателя) C также будет работать для "
"объектов C++."

#: ../../faq/extending.rst:212
msgid "For C++ libraries, see :ref:`c-wrapper-software`."
msgstr "О библиотеках C++ см. :ref:`c-wrapper-software`."

#: ../../faq/extending.rst:216
msgid "I added a module using the Setup file and the make fails; why?"
msgstr ""
"Я добавил модуль, используя файл установки, и сборка завершилась неудачно; "
"почему?"

#: ../../faq/extending.rst:218
msgid ""
"Setup must end in a newline, if there is no newline there, the build process "
"fails.  (Fixing this requires some ugly shell script hackery, and this bug "
"is so minor that it doesn't seem worth the effort.)"
msgstr ""
"Установка должна заканчиваться новой строкой; если новой строки нет, процесс "
"сборки завершится неудачей. (Чтобы это исправить, требуется какой-то "
"уродливый хакерский сценарий оболочки, и эта ошибка настолько незначительна, "
"что, похоже, не стоит затрачиваемых усилий.)"

#: ../../faq/extending.rst:224
msgid "How do I debug an extension?"
msgstr "Как отладить расширение?"

#: ../../faq/extending.rst:226
msgid ""
"When using GDB with dynamically loaded extensions, you can't set a "
"breakpoint in your extension until your extension is loaded."
msgstr ""
"При использовании GDB с динамически загружаемыми расширениями вы не можете "
"установить точку останова в своем расширении, пока ваше расширение не будет "
"загружено."

#: ../../faq/extending.rst:229
msgid "In your ``.gdbinit`` file (or interactively), add the command:"
msgstr "В файл ``.gdbinit`` (или в интерактивном режиме) добавьте команду:"

#: ../../faq/extending.rst:235
msgid "Then, when you run GDB:"
msgstr "Затем, когда вы запустите GDB:"

#: ../../faq/extending.rst:247
msgid ""
"I want to compile a Python module on my Linux system, but some files are "
"missing. Why?"
msgstr ""
"Я хочу скомпилировать модуль Python в своей системе Linux, но некоторые "
"файлы отсутствуют. Почему?"

#: ../../faq/extending.rst:249
msgid ""
"Most packaged versions of Python don't include the :file:`/usr/lib/python2."
"{x}/config/` directory, which contains various files required for compiling "
"Python extensions."
msgstr ""

#: ../../faq/extending.rst:253
msgid "For Red Hat, install the python-devel RPM to get the necessary files."
msgstr ""

#: ../../faq/extending.rst:255
msgid "For Debian, run ``apt-get install python-dev``."
msgstr ""

#: ../../faq/extending.rst:258
msgid "How do I tell \"incomplete input\" from \"invalid input\"?"
msgstr "Как отличить «неполный ввод» от «неверного ввода»?"

#: ../../faq/extending.rst:260
msgid ""
"Sometimes you want to emulate the Python interactive interpreter's behavior, "
"where it gives you a continuation prompt when the input is incomplete (e.g. "
"you typed the start of an \"if\" statement or you didn't close your "
"parentheses or triple string quotes), but it gives you a syntax error "
"message immediately when the input is invalid."
msgstr ""
"Иногда вам нужно имитировать поведение интерактивного интерпретатора Python, "
"когда он выдает приглашение на продолжение, если ввод неполный (например, вы "
"ввели начало оператора «if» или не закрыли круглые скобки или тройные "
"строковые кавычки), но он сразу же выдает сообщение о синтаксической ошибке, "
"когда ввод недействителен."

#: ../../faq/extending.rst:266
msgid ""
"In Python you can use the :mod:`codeop` module, which approximates the "
"parser's behavior sufficiently.  IDLE uses this, for example."
msgstr ""
"В Python вы можете использовать модуль :mod:`codeop`, который в достаточной "
"степени аппроксимирует поведение парсера. IDLE использует это, например."

#: ../../faq/extending.rst:269
msgid ""
"The easiest way to do it in C is to call :c:func:`PyRun_InteractiveLoop` "
"(perhaps in a separate thread) and let the Python interpreter handle the "
"input for you. You can also set the :c:func:`PyOS_ReadlineFunctionPointer` "
"to point at your custom input function. See ``Modules/readline.c`` and "
"``Parser/myreadline.c`` for more hints."
msgstr ""
"Самый простой способ сделать это в C — вызвать :c:func:"
"`PyRun_InteractiveLoop` (возможно, в отдельном потоке) и позволить "
"интерпретатору Python обработать ввод за вас. Вы также можете установить :c:"
"func:`PyOS_ReadlineFunctionPointer` так, чтобы он указывал на вашу "
"пользовательскую функцию ввода. Дополнительные подсказки смотрите в "
"``Modules/readline.c`` и ``Parser/myreadline.c``."

#: ../../faq/extending.rst:276
msgid "How do I find undefined g++ symbols __builtin_new or __pure_virtual?"
msgstr "Как найти неопределенные символы g++ __builtin_new или __pure_virtual?"

#: ../../faq/extending.rst:278
msgid ""
"To dynamically load g++ extension modules, you must recompile Python, relink "
"it using g++ (change LINKCC in the Python Modules Makefile), and link your "
"extension module using g++ (e.g., ``g++ -shared -o mymodule.so mymodule.o``)."
msgstr ""
"Чтобы динамически загружать модули расширения g++, вы должны "
"перекомпилировать Python, повторно связать его с помощью g++ (изменить "
"LINKCC в Makefile модулей Python) и связать свой модуль расширения с помощью "
"g++ (например, ``g++ -shared -o mymodule.so mymodule.o` `)."

#: ../../faq/extending.rst:284
msgid ""
"Can I create an object class with some methods implemented in C and others "
"in Python (e.g. through inheritance)?"
msgstr ""
"Могу ли я создать класс объекта, в котором некоторые методы реализованы на "
"C, а другие — на Python (например, посредством наследования)?"

#: ../../faq/extending.rst:286
msgid ""
"Yes, you can inherit from built-in classes such as :class:`int`, :class:"
"`list`, :class:`dict`, etc."
msgstr ""
"Да, вы можете наследовать от встроенных классов, таких как :class:`int`, :"
"class:`list`, :class:`dict` и т. д."

#: ../../faq/extending.rst:289
msgid ""
"The Boost Python Library (BPL, https://www.boost.org/libs/python/doc/index."
"html) provides a way of doing this from C++ (i.e. you can inherit from an "
"extension class written in C++ using the BPL)."
msgstr ""
"Библиотека Boost Python (BPL, https://www.boost.org/libs/python/doc/index."
"html) предоставляет способ сделать это из C++ (т. е. вы можете наследовать "
"класс расширения, написанный на C++, используя BPL )."
