# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-21 22:20+0000\n"
"PO-Revision-Date: 2023-05-24 02:11+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../faq/programming.rst:5
msgid "Programming FAQ"
msgstr "ЧаВо по программированию"

#: ../../faq/programming.rst:8
msgid "Contents"
msgstr " Содержание"

#: ../../faq/programming.rst:12
msgid "General Questions"
msgstr "Общие вопросы"

#: ../../faq/programming.rst:15
msgid ""
"Is there a source code level debugger with breakpoints, single-stepping, "
"etc.?"
msgstr ""
"Существует ли отладчик на уровне исходного кода с точками останова, "
"пошаговым выполнением и т. д.?"

#: ../../faq/programming.rst:17 ../../faq/programming.rst:58
msgid "Yes."
msgstr "Да."

#: ../../faq/programming.rst:19
msgid ""
"Several debuggers for Python are described below, and the built-in function :"
"func:`breakpoint` allows you to drop into any of them."
msgstr ""
"Ниже описано несколько отладчиков для Python, а встроенная функция :func:"
"`breakpoint` позволяет перейти в любой из них."

#: ../../faq/programming.rst:22
msgid ""
"The pdb module is a simple but adequate console-mode debugger for Python. It "
"is part of the standard Python library, and is :mod:`documented in the "
"Library Reference Manual <pdb>`. You can also write your own debugger by "
"using the code for pdb as an example."
msgstr ""
"Модуль pdb — это простой, но адекватный отладчик консольного режима для "
"Python. Он является частью стандартной библиотеки Python и :mod:"
"`документирован в Library Reference Manual <pdb>`. Вы также можете написать "
"свой собственный отладчик, используя код для pdb в качестве примера."

#: ../../faq/programming.rst:27
msgid ""
"The IDLE interactive development environment, which is part of the standard "
"Python distribution (normally available as `Tools/scripts/idle3 <https://"
"github.com/python/cpython/blob/main/Tools/scripts/idle3>`_), includes a "
"graphical debugger."
msgstr ""
"Интерактивная среда разработки IDLE, которая является частью стандартного "
"дистрибутива Python (обычно доступна как `Tools/scripts/idle3 <https://"
"github.com/python/cpython/blob/main/Tools/scripts/idle3>`_), включает в себя "
"графический отладчик."

#: ../../faq/programming.rst:32
msgid ""
"PythonWin is a Python IDE that includes a GUI debugger based on pdb.  The "
"PythonWin debugger colors breakpoints and has quite a few cool features such "
"as debugging non-PythonWin programs.  PythonWin is available as part of "
"`pywin32 <https://github.com/mhammond/pywin32>`_ project and as a part of "
"the `ActivePython <https://www.activestate.com/products/python/>`_ "
"distribution."
msgstr ""
"PythonWin — это среда разработки Python, включающая отладчик с графическим "
"интерфейсом на основе pdb. Отладчик PythonWin окрашивает точки останова и "
"имеет немало интересных функций, таких как отладка программ, отличных от "
"Python. PythonWin доступен как часть проекта `pywin32 <https://github.com/"
"mhammond/pywin32>`_ и как часть `ActivePython <https://www.activestate.com/"
"products/python/>`_. распределение."

#: ../../faq/programming.rst:39
msgid ""
"`Eric <https://eric-ide.python-projects.org/>`_ is an IDE built on PyQt and "
"the Scintilla editing component."
msgstr ""
"`Eric <https://eric-ide.python-projects.org/>`_ — это IDE, построенная на "
"PyQt и компоненте редактирования Scintilla."

#: ../../faq/programming.rst:42
msgid ""
"`trepan3k <https://github.com/rocky/python3-trepan/>`_ is a gdb-like "
"debugger."
msgstr ""
"`trepan3k <https://github.com/rocky/python3-trepan/>`_ — это отладчик, "
"похожий на GDB."

#: ../../faq/programming.rst:44
msgid ""
"`Visual Studio Code <https://code.visualstudio.com/>`_ is an IDE with "
"debugging tools that integrates with version-control software."
msgstr ""
"`Visual Studio Code <https://code.visualstudio.com/>`_ — это интегрированная "
"среда разработки со средствами отладки, которая интегрируется с программным "
"обеспечением для контроля версий."

#: ../../faq/programming.rst:47
msgid ""
"There are a number of commercial Python IDEs that include graphical "
"debuggers. They include:"
msgstr ""
"Существует ряд коммерческих IDE Python, включающих графические отладчики. "
"Они включают в себя:"

#: ../../faq/programming.rst:50
msgid "`Wing IDE <https://wingware.com/>`_"
msgstr "`Wing IDE <https://wingware.com/>`_"

#: ../../faq/programming.rst:51
msgid "`Komodo IDE <https://www.activestate.com/products/komodo-ide/>`_"
msgstr "`Komodo IDE <https://www.activestate.com/products/komodo-ide/>`_"

#: ../../faq/programming.rst:52
msgid "`PyCharm <https://www.jetbrains.com/pycharm/>`_"
msgstr "`PyCharm <https://www.jetbrains.com/pycharm/>`_"

#: ../../faq/programming.rst:56
msgid "Are there tools to help find bugs or perform static analysis?"
msgstr ""
"Существуют ли инструменты, помогающие найти ошибки или выполнить статический "
"анализ?"

#: ../../faq/programming.rst:60
msgid ""
"`Pylint <https://pylint.pycqa.org/en/latest/index.html>`_ and `Pyflakes "
"<https://github.com/PyCQA/pyflakes>`_ do basic checking that will help you "
"catch bugs sooner."
msgstr ""
"`Pylint <https://pylint.pycqa.org/en/latest/index.html>`_ и `Pyflakes "
"<https://github.com/PyCQA/pyflakes>`_ выполняют базовую проверку, которая "
"поможет вам обнаружить ошибки. раньше."

#: ../../faq/programming.rst:64
msgid ""
"Static type checkers such as `Mypy <https://mypy-lang.org/>`_, `Pyre "
"<https://pyre-check.org/>`_, and `Pytype <https://github.com/google/"
"pytype>`_ can check type hints in Python source code."
msgstr ""
"Средства проверки статических типов, такие как `Mypy <https://mypy-lang.org/"
">`_, `Pyre <https://pyre-check.org/>`_ и `Pytype <https://github.com /google/"
"pytype>`_ может проверять подсказки типов в исходном коде Python."

#: ../../faq/programming.rst:73
msgid "How can I create a stand-alone binary from a Python script?"
msgstr "Как я могу создать автономный двоичный файл из сценария Python?"

#: ../../faq/programming.rst:75
msgid ""
"You don't need the ability to compile Python to C code if all you want is a "
"stand-alone program that users can download and run without having to "
"install the Python distribution first.  There are a number of tools that "
"determine the set of modules required by a program and bind these modules "
"together with a Python binary to produce a single executable."
msgstr ""
"Вам не нужна возможность компилировать код Python в C, если все, что вам "
"нужно, — это отдельная программа, которую пользователи могут загрузить и "
"запустить без предварительной установки дистрибутива Python. Существует ряд "
"инструментов, которые определяют набор модулей, необходимых программе, и "
"связывают эти модули вместе с двоичным файлом Python для создания единого "
"исполняемого файла."

#: ../../faq/programming.rst:81
msgid ""
"One is to use the freeze tool, which is included in the Python source tree "
"as `Tools/freeze <https://github.com/python/cpython/tree/main/Tools/"
"freeze>`_. It converts Python byte code to C arrays; with a C compiler you "
"can embed all your modules into a new program, which is then linked with the "
"standard Python modules."
msgstr ""
"Один из них — использовать инструмент заморозки, который включен в дерево "
"исходного кода Python как «Tools/freeze <https://github.com/python/cpython/"
"tree/main/Tools/freeze>»_. Он преобразует байт-код Python в массивы C; с "
"помощью компилятора C вы можете встроить все свои модули в новую программу, "
"которая затем будет связана со стандартными модулями Python."

#: ../../faq/programming.rst:87
msgid ""
"It works by scanning your source recursively for import statements (in both "
"forms) and looking for the modules in the standard Python path as well as in "
"the source directory (for built-in modules).  It then turns the bytecode for "
"modules written in Python into C code (array initializers that can be turned "
"into code objects using the marshal module) and creates a custom-made config "
"file that only contains those built-in modules which are actually used in "
"the program.  It then compiles the generated C code and links it with the "
"rest of the Python interpreter to form a self-contained binary which acts "
"exactly like your script."
msgstr ""
"Он работает путем рекурсивного сканирования вашего источника на наличие "
"операторов импорта (в обеих формах) и поиска модулей в стандартном пути "
"Python, а также в исходном каталоге (для встроенных модулей). Затем он "
"преобразует байт-код модулей, написанных на Python, в код C (инициализаторы "
"массивов, которые можно превратить в объекты кода с помощью модуля маршала) "
"и создает специальный файл конфигурации, который содержит только те "
"встроенные модули, которые фактически используются в программа. Затем он "
"компилирует сгенерированный код C и связывает его с остальной частью "
"интерпретатора Python, чтобы сформировать автономный двоичный файл, который "
"действует точно так же, как ваш скрипт."

#: ../../faq/programming.rst:96
msgid ""
"The following packages can help with the creation of console and GUI "
"executables:"
msgstr ""
"Следующие пакеты могут помочь в создании исполняемых файлов консоли и "
"графического интерфейса:"

#: ../../faq/programming.rst:99
msgid "`Nuitka <https://nuitka.net/>`_ (Cross-platform)"
msgstr "`Nuitka <https://nuitka.net/>`_ (Кроссплатформенный)"

#: ../../faq/programming.rst:100
msgid "`PyInstaller <https://pyinstaller.org/>`_ (Cross-platform)"
msgstr "`PyInstaller <https://pyinstaller.org/>`_ (Кроссплатформенный)"

#: ../../faq/programming.rst:101
msgid ""
"`PyOxidizer <https://pyoxidizer.readthedocs.io/en/stable/>`_ (Cross-platform)"
msgstr ""
"`PyOxidizer <https://pyoxidizer.readthedocs.io/en/stable/>`_ "
"(кроссплатформенный)"

#: ../../faq/programming.rst:102
msgid ""
"`cx_Freeze <https://marcelotduarte.github.io/cx_Freeze/>`_ (Cross-platform)"
msgstr ""
"`cx_Freeze <https://marcelotduarte.github.io/cx_Freeze/>`_ "
"(Кроссплатформенный)"

#: ../../faq/programming.rst:103
msgid "`py2app <https://github.com/ronaldoussoren/py2app>`_ (macOS only)"
msgstr ""
"`py2app <https://github.com/ronaldoussoren/py2app>`_ (только для macOS)"

#: ../../faq/programming.rst:104
msgid "`py2exe <https://www.py2exe.org/>`_ (Windows only)"
msgstr "`py2exe <https://www.py2exe.org/>`_ (только для Windows)"

#: ../../faq/programming.rst:107
msgid "Are there coding standards or a style guide for Python programs?"
msgstr ""
"Существуют ли стандарты кодирования или руководство по стилю для программ "
"Python?"

#: ../../faq/programming.rst:109
msgid ""
"Yes.  The coding style required for standard library modules is documented "
"as :pep:`8`."
msgstr ""
"Да. Стиль кодирования, необходимый для модулей стандартной библиотеки, "
"документирован как :pep:`8`."

#: ../../faq/programming.rst:114
msgid "Core Language"
msgstr "Основной язык"

#: ../../faq/programming.rst:119
msgid "Why am I getting an UnboundLocalError when the variable has a value?"
msgstr "Почему я получаю UnboundLocalError, когда переменная имеет значение?"

#: ../../faq/programming.rst:121
msgid ""
"It can be a surprise to get the :exc:`UnboundLocalError` in previously "
"working code when it is modified by adding an assignment statement somewhere "
"in the body of a function."
msgstr ""
"Может быть неожиданностью получить :exc:`UnboundLocalError` в ранее "
"работавшем коде, когда он был изменен путем добавления оператора "
"присваивания где-то в теле функции."

#: ../../faq/programming.rst:125
msgid "This code:"
msgstr "Этот код:"

#: ../../faq/programming.rst:134
msgid "works, but this code:"
msgstr "работает, но этот код:"

#: ../../faq/programming.rst:141
msgid "results in an :exc:`!UnboundLocalError`:"
msgstr "приводит к :exc:`!UnboundLocalError`:"

#: ../../faq/programming.rst:148
msgid ""
"This is because when you make an assignment to a variable in a scope, that "
"variable becomes local to that scope and shadows any similarly named "
"variable in the outer scope.  Since the last statement in foo assigns a new "
"value to ``x``, the compiler recognizes it as a local variable.  "
"Consequently when the earlier ``print(x)`` attempts to print the "
"uninitialized local variable and an error results."
msgstr ""
"Это связано с тем, что когда вы назначаете переменную в области видимости, "
"эта переменная становится локальной для этой области и затеняет любую "
"переменную с таким же именем во внешней области. Поскольку последний "
"оператор в foo присваивает новое значение переменной x, компилятор "
"распознает ее как локальную переменную. Следовательно, когда более ранняя "
"команда print(x) пытается напечатать неинициализированную локальную "
"переменную, возникает ошибка."

#: ../../faq/programming.rst:155
msgid ""
"In the example above you can access the outer scope variable by declaring it "
"global:"
msgstr ""
"В приведенном выше примере вы можете получить доступ к переменной внешней "
"области, объявив ее глобальной:"

#: ../../faq/programming.rst:167
msgid ""
"This explicit declaration is required in order to remind you that (unlike "
"the superficially analogous situation with class and instance variables) you "
"are actually modifying the value of the variable in the outer scope:"
msgstr ""
"Это явное объявление необходимо для того, чтобы напомнить вам, что (в "
"отличие от внешне аналогичной ситуации с переменными класса и экземпляра) вы "
"фактически изменяете значение переменной во внешней области видимости:"

#: ../../faq/programming.rst:174
msgid ""
"You can do a similar thing in a nested scope using the :keyword:`nonlocal` "
"keyword:"
msgstr ""
"Вы можете сделать то же самое во вложенной области, используя ключевое "
"слово :keyword:`nonlocal`:"

#: ../../faq/programming.rst:192
msgid "What are the rules for local and global variables in Python?"
msgstr "Каковы правила для локальных и глобальных переменных в Python?"

#: ../../faq/programming.rst:194
msgid ""
"In Python, variables that are only referenced inside a function are "
"implicitly global.  If a variable is assigned a value anywhere within the "
"function's body, it's assumed to be a local unless explicitly declared as "
"global."
msgstr ""
"В Python переменные, на которые ссылаются только внутри функции, неявно "
"являются глобальными. Если переменной присвоено значение в любом месте тела "
"функции, она считается локальной, если она явно не объявлена ​​как глобальная."

#: ../../faq/programming.rst:198
msgid ""
"Though a bit surprising at first, a moment's consideration explains this.  "
"On one hand, requiring :keyword:`global` for assigned variables provides a "
"bar against unintended side-effects.  On the other hand, if ``global`` was "
"required for all global references, you'd be using ``global`` all the time.  "
"You'd have to declare as global every reference to a built-in function or to "
"a component of an imported module.  This clutter would defeat the usefulness "
"of the ``global`` declaration for identifying side-effects."
msgstr ""
"Хотя на первый взгляд это немного удивительно, но некоторое размышление "
"объясняет это. С одной стороны, требование :keyword:`global` для назначенных "
"переменных обеспечивает защиту от непредвиденных побочных эффектов. С другой "
"стороны, если бы для всех глобальных ссылок требовалось ``global``, вы бы "
"использовали ``global`` все время. Вам придется объявить глобальной каждую "
"ссылку на встроенную функцию или на компонент импортированного модуля. Этот "
"беспорядок сведет на нет полезность «глобальной» декларации для выявления "
"побочных эффектов."

#: ../../faq/programming.rst:208
msgid ""
"Why do lambdas defined in a loop with different values all return the same "
"result?"
msgstr ""
"Почему лямбды, определенные в цикле с разными значениями, возвращают один и "
"тот же результат?"

#: ../../faq/programming.rst:210
msgid ""
"Assume you use a for loop to define a few different lambdas (or even plain "
"functions), e.g.::"
msgstr ""
"Предположим, вы используете цикл for для определения нескольких различных "
"лямбда-выражений (или даже простых функций), например::"

#: ../../faq/programming.rst:217
msgid ""
"This gives you a list that contains 5 lambdas that calculate ``x**2``.  You "
"might expect that, when called, they would return, respectively, ``0``, "
"``1``, ``4``, ``9``, and ``16``.  However, when you actually try you will "
"see that they all return ``16``::"
msgstr ""
"Это дает вам список, содержащий 5 лямбда-выражений, которые вычисляют "
"``x**2``. Вы могли бы ожидать, что при вызове они вернут соответственно "
"``0``, ``1``, ``4``, ``9`` и ``16``. Однако, когда вы действительно "
"попробуете, вы увидите, что все они возвращают ``16``::"

#: ../../faq/programming.rst:227
msgid ""
"This happens because ``x`` is not local to the lambdas, but is defined in "
"the outer scope, and it is accessed when the lambda is called --- not when "
"it is defined.  At the end of the loop, the value of ``x`` is ``4``, so all "
"the functions now return ``4**2``, i.e. ``16``.  You can also verify this by "
"changing the value of ``x`` and see how the results of the lambdas change::"
msgstr ""
"Это происходит потому, что ``x`` не является локальным для лямбда-выражений, "
"а определен во внешней области видимости, и доступ к нему осуществляется при "
"вызове лямбды, а не при ее определении. В конце цикла значение ``x`` равно "
"``4``, поэтому все функции теперь возвращают ``4**2``, то есть ``16``. Вы "
"также можете убедиться в этом, изменив значение ``x`` и посмотреть, как "
"изменяются результаты лямбда-выражений:"

#: ../../faq/programming.rst:237
msgid ""
"In order to avoid this, you need to save the values in variables local to "
"the lambdas, so that they don't rely on the value of the global ``x``::"
msgstr ""
"Чтобы этого избежать, вам необходимо сохранять значения в переменных, "
"локальных для лямбда-выражений, чтобы они не зависели от значения "
"глобального ``x``::"

#: ../../faq/programming.rst:244
msgid ""
"Here, ``n=x`` creates a new variable ``n`` local to the lambda and computed "
"when the lambda is defined so that it has the same value that ``x`` had at "
"that point in the loop.  This means that the value of ``n`` will be ``0`` in "
"the first lambda, ``1`` in the second, ``2`` in the third, and so on. "
"Therefore each lambda will now return the correct result::"
msgstr ""
"Здесь ``n=x`` создает новую переменную ``n``, локальную для лямбды, и "
"вычисляется, когда лямбда определена, так что она имеет то же значение, что "
"и ``x`` в этой точке цикла. Это означает, что значение n будет равно 0 в "
"первой лямбде, 1 во второй, 2 в третьей и так далее. Поэтому каждая лямбда "
"теперь будет возвращать правильный результат:"

#: ../../faq/programming.rst:255
msgid ""
"Note that this behaviour is not peculiar to lambdas, but applies to regular "
"functions too."
msgstr ""
"Обратите внимание, что такое поведение не свойственно лямбда-выражениям, но "
"применимо и к обычным функциям."

#: ../../faq/programming.rst:260
msgid "How do I share global variables across modules?"
msgstr "Как мне использовать глобальные переменные в разных модулях?"

#: ../../faq/programming.rst:262
msgid ""
"The canonical way to share information across modules within a single "
"program is to create a special module (often called config or cfg).  Just "
"import the config module in all modules of your application; the module then "
"becomes available as a global name.  Because there is only one instance of "
"each module, any changes made to the module object get reflected "
"everywhere.  For example:"
msgstr ""
"Канонический способ обмена информацией между модулями в одной программе — "
"создание специального модуля (часто называемого config или cfg). Просто "
"импортируйте модуль конфигурации во все модули вашего приложения; тогда "
"модуль станет доступен под глобальным именем. Поскольку существует только "
"один экземпляр каждого модуля, любые изменения, внесенные в объект модуля, "
"отражаются повсюду. Например:"

#: ../../faq/programming.rst:268
msgid "config.py::"
msgstr "config.py::"

#: ../../faq/programming.rst:272
msgid "mod.py::"
msgstr "mod.py::"

#: ../../faq/programming.rst:277
msgid "main.py::"
msgstr "main.py::"

#: ../../faq/programming.rst:283
msgid ""
"Note that using a module is also the basis for implementing the singleton "
"design pattern, for the same reason."
msgstr ""
"Обратите внимание, что по той же причине использование модуля также является "
"основой для реализации шаблона проектирования Singleton."

#: ../../faq/programming.rst:288
msgid "What are the \"best practices\" for using import in a module?"
msgstr "Каковы «оптимальные методы» использования импорта в модуле?"

#: ../../faq/programming.rst:290
msgid ""
"In general, don't use ``from modulename import *``.  Doing so clutters the "
"importer's namespace, and makes it much harder for linters to detect "
"undefined names."
msgstr ""
"В общем, не используйте ``из импорта имени модуля *``. Это загромождает "
"пространство имен импортера и затрудняет обнаружение неопределенных имен "
"линтерами."

#: ../../faq/programming.rst:294
msgid ""
"Import modules at the top of a file.  Doing so makes it clear what other "
"modules your code requires and avoids questions of whether the module name "
"is in scope. Using one import per line makes it easy to add and delete "
"module imports, but using multiple imports per line uses less screen space."
msgstr ""
"Импортируйте модули в начало файла. Это позволит понять, какие еще модули "
"требуются вашему коду, и позволит избежать вопросов о том, находится ли имя "
"модуля в области видимости. Использование одного импорта в каждой строке "
"упрощает добавление и удаление импорта модулей, но использование нескольких "
"импортов в каждой строке требует меньше места на экране."

#: ../../faq/programming.rst:299
msgid "It's good practice if you import modules in the following order:"
msgstr "Рекомендуется импортировать модули в следующем порядке:"

#: ../../faq/programming.rst:301
msgid ""
"standard library modules -- e.g. :mod:`sys`, :mod:`os`, :mod:`argparse`, :"
"mod:`re`"
msgstr ""
"модули стандартной библиотеки — например, :mod:`sys`, :mod:`os`, :mod:"
"`argparse`, :mod:`re`"

#: ../../faq/programming.rst:302
msgid ""
"third-party library modules (anything installed in Python's site-packages "
"directory) -- e.g. :mod:`!dateutil`, :mod:`!requests`, :mod:`!PIL.Image`"
msgstr ""
"модули сторонних библиотек (все, что установлено в каталоге site-packages "
"Python) — например, :mod:`!dateutil`, :mod:`!requests`, :mod:`!PIL.Image`"

#: ../../faq/programming.rst:304
msgid "locally developed modules"
msgstr "локально разработанные модули"

#: ../../faq/programming.rst:306
msgid ""
"It is sometimes necessary to move imports to a function or class to avoid "
"problems with circular imports.  Gordon McMillan says:"
msgstr ""
"Иногда необходимо переместить импорт в функцию или класс, чтобы избежать "
"проблем с циклическим импортом. Гордон Макмиллан говорит:"

#: ../../faq/programming.rst:309
msgid ""
"Circular imports are fine where both modules use the \"import <module>\" "
"form of import.  They fail when the 2nd module wants to grab a name out of "
"the first (\"from module import name\") and the import is at the top level.  "
"That's because names in the 1st are not yet available, because the first "
"module is busy importing the 2nd."
msgstr ""
"Циклический импорт возможен, если оба модуля используют форму импорта "
"«import <module>». Они терпят неудачу, когда второй модуль хочет получить "
"имя из первого («из имени импорта модуля»), а импорт находится на верхнем "
"уровне. Это потому, что имена в 1-м еще недоступны, потому что первый модуль "
"занят импортом 2-го."

#: ../../faq/programming.rst:315
msgid ""
"In this case, if the second module is only used in one function, then the "
"import can easily be moved into that function.  By the time the import is "
"called, the first module will have finished initializing, and the second "
"module can do its import."
msgstr ""
"В этом случае, если второй модуль используется только в одной функции, "
"импорт можно легко перенести в эту функцию. К моменту вызова импорта первый "
"модуль завершит инициализацию, и второй модуль сможет выполнить импорт."

#: ../../faq/programming.rst:320
msgid ""
"It may also be necessary to move imports out of the top level of code if "
"some of the modules are platform-specific.  In that case, it may not even be "
"possible to import all of the modules at the top of the file.  In this case, "
"importing the correct modules in the corresponding platform-specific code is "
"a good option."
msgstr ""
"Также может потребоваться переместить импорт из верхнего уровня кода, если "
"некоторые модули зависят от платформы. В этом случае может быть даже "
"невозможно импортировать все модули в верхней части файла. В этом случае "
"хорошим вариантом будет импорт правильных модулей в соответствующий код, "
"специфичный для платформы."

#: ../../faq/programming.rst:325
msgid ""
"Only move imports into a local scope, such as inside a function definition, "
"if it's necessary to solve a problem such as avoiding a circular import or "
"are trying to reduce the initialization time of a module.  This technique is "
"especially helpful if many of the imports are unnecessary depending on how "
"the program executes.  You may also want to move imports into a function if "
"the modules are only ever used in that function.  Note that loading a module "
"the first time may be expensive because of the one time initialization of "
"the module, but loading a module multiple times is virtually free, costing "
"only a couple of dictionary lookups.  Even if the module name has gone out "
"of scope, the module is probably available in :data:`sys.modules`."
msgstr ""
"Перемещайте импорт в локальную область, например, внутри определения "
"функции, только в том случае, если необходимо решить проблему, например "
"избежать циклического импорта, или попытаться сократить время инициализации "
"модуля. Этот метод особенно полезен, если многие импорты не нужны в "
"зависимости от того, как выполняется программа. Вы также можете переместить "
"импорт в функцию, если модули когда-либо используются только в этой функции. "
"Обратите внимание, что загрузка модуля в первый раз может оказаться "
"дорогостоящей из-за однократной инициализации модуля, но загрузка модуля "
"несколько раз практически бесплатна и требует всего лишь пары поисков по "
"словарю. Даже если имя модуля вышло за пределы области видимости, модуль, "
"вероятно, доступен в :data:`sys.modules`."

#: ../../faq/programming.rst:338
msgid "Why are default values shared between objects?"
msgstr "Почему значения по умолчанию являются общими для всех объектов?"

#: ../../faq/programming.rst:340
msgid ""
"This type of bug commonly bites neophyte programmers.  Consider this "
"function::"
msgstr ""
"Этот тип ошибок обычно поражает программистов-новичков. Рассмотрим эту "
"функцию::"

#: ../../faq/programming.rst:347
msgid ""
"The first time you call this function, ``mydict`` contains a single item.  "
"The second time, ``mydict`` contains two items because when ``foo()`` begins "
"executing, ``mydict`` starts out with an item already in it."
msgstr ""
"При первом вызове этой функции mydict содержит один элемент. Во второй раз "
"mydict содержит два элемента, потому что, когда foo() начинает выполняться, "
"mydict запускается с уже содержащимся в нем элементом."

#: ../../faq/programming.rst:351
msgid ""
"It is often expected that a function call creates new objects for default "
"values. This is not what happens. Default values are created exactly once, "
"when the function is defined.  If that object is changed, like the "
"dictionary in this example, subsequent calls to the function will refer to "
"this changed object."
msgstr ""
"Часто ожидается, что вызов функции создаст новые объекты для значений по "
"умолчанию. Это не то, что происходит. Значения по умолчанию создаются ровно "
"один раз при определении функции. Если этот объект изменен, как словарь в "
"этом примере, последующие вызовы функции будут ссылаться на этот измененный "
"объект."

#: ../../faq/programming.rst:356
msgid ""
"By definition, immutable objects such as numbers, strings, tuples, and "
"``None``, are safe from change. Changes to mutable objects such as "
"dictionaries, lists, and class instances can lead to confusion."
msgstr ""
"По определению, неизменяемые объекты, такие как числа, строки, кортежи и "
"None, защищены от изменений. Изменения изменяемых объектов, таких как "
"словари, списки и экземпляры классов, могут привести к путанице."

#: ../../faq/programming.rst:360
msgid ""
"Because of this feature, it is good programming practice to not use mutable "
"objects as default values.  Instead, use ``None`` as the default value and "
"inside the function, check if the parameter is ``None`` and create a new "
"list/dictionary/whatever if it is.  For example, don't write::"
msgstr ""
"Из-за этой особенности хорошей практикой программирования является не "
"использовать изменяемые объекты в качестве значений по умолчанию. Вместо "
"этого используйте None в качестве значения по умолчанию и внутри функции "
"проверьте, равен ли параметр None, и создайте новый список/словарь/что "
"угодно, если это так. Например, не пишите::"

#: ../../faq/programming.rst:368
msgid "but::"
msgstr "но::"

#: ../../faq/programming.rst:374
msgid ""
"This feature can be useful.  When you have a function that's time-consuming "
"to compute, a common technique is to cache the parameters and the resulting "
"value of each call to the function, and return the cached value if the same "
"value is requested again.  This is called \"memoizing\", and can be "
"implemented like this::"
msgstr ""
"Эта функция может быть полезна. Если у вас есть функция, вычисление которой "
"требует много времени, общий метод заключается в кэшировании параметров и "
"результирующего значения каждого вызова функции и возврате кэшированного "
"значения, если то же значение запрашивается снова. Это называется "
"«запоминанием» и может быть реализовано следующим образом:"

#: ../../faq/programming.rst:389
msgid ""
"You could use a global variable containing a dictionary instead of the "
"default value; it's a matter of taste."
msgstr ""
"Вместо значения по умолчанию вы можете использовать глобальную переменную, "
"содержащую словарь; это дело вкуса."

#: ../../faq/programming.rst:394
msgid ""
"How can I pass optional or keyword parameters from one function to another?"
msgstr ""
"Как передать необязательные параметры или параметры ключевых слов из одной "
"функции в другую?"

#: ../../faq/programming.rst:396
msgid ""
"Collect the arguments using the ``*`` and ``**`` specifiers in the "
"function's parameter list; this gives you the positional arguments as a "
"tuple and the keyword arguments as a dictionary.  You can then pass these "
"arguments when calling another function by using ``*`` and ``**``::"
msgstr ""
"Соберите аргументы, используя спецификаторы ``*`` и ``**`` в списке "
"параметров функции; это дает вам позиционные аргументы в виде кортежа и "
"аргументы ключевых слов в виде словаря. Затем вы можете передать эти "
"аргументы при вызове другой функции, используя ``*`` и ``**``::"

#: ../../faq/programming.rst:415
msgid "What is the difference between arguments and parameters?"
msgstr "В чем разница между аргументами и параметрами?"

#: ../../faq/programming.rst:417
msgid ""
":term:`Parameters <parameter>` are defined by the names that appear in a "
"function definition, whereas :term:`arguments <argument>` are the values "
"actually passed to a function when calling it.  Parameters define what :term:"
"`kind of arguments <parameter>` a function can accept.  For example, given "
"the function definition::"
msgstr ""
":term:`Parameters <parameter>` определяются именами, которые появляются в "
"определении функции, тогда как :term:`arguments <argument>` — это значения, "
"фактически передаваемые функции при ее вызове. Параметры определяют, какие "
"аргументы <параметр>` может принимать функция. Например, учитывая "
"определение функции::"

#: ../../faq/programming.rst:426
msgid ""
"*foo*, *bar* and *kwargs* are parameters of ``func``.  However, when calling "
"``func``, for example::"
msgstr ""
"*foo*, *bar* и *kwargs* являются параметрами функции func. Однако при вызове "
"func, например:"

#: ../../faq/programming.rst:431
msgid "the values ``42``, ``314``, and ``somevar`` are arguments."
msgstr "значения ``42``, ``314`` и ``somevar`` являются аргументами."

#: ../../faq/programming.rst:435
msgid "Why did changing list 'y' also change list 'x'?"
msgstr "Почему изменение списка «y» также изменило список «x»?"

#: ../../faq/programming.rst:437
msgid "If you wrote code like::"
msgstr "Если вы написали код типа::"

#: ../../faq/programming.rst:447
msgid ""
"you might be wondering why appending an element to ``y`` changed ``x`` too."
msgstr ""
"вам может быть интересно, почему добавление элемента к ``y`` также изменило "
"``x``."

#: ../../faq/programming.rst:449
msgid "There are two factors that produce this result:"
msgstr "Есть два фактора, которые приводят к такому результату:"

#: ../../faq/programming.rst:451
msgid ""
"Variables are simply names that refer to objects.  Doing ``y = x`` doesn't "
"create a copy of the list -- it creates a new variable ``y`` that refers to "
"the same object ``x`` refers to.  This means that there is only one object "
"(the list), and both ``x`` and ``y`` refer to it."
msgstr ""
"Переменные — это просто имена, ссылающиеся на объекты. Выполнение ``y = x`` "
"не создает копию списка — оно создает новую переменную ``y``, которая "
"ссылается на тот же объект, на который ссылается ``x``. Это означает, что "
"существует только один объект (список), и на него ссылаются как ``x``, так и "
"``y``."

#: ../../faq/programming.rst:455
msgid ""
"Lists are :term:`mutable`, which means that you can change their content."
msgstr ""
"Списки являются :term:`mutable`, что означает, что вы можете изменять их "
"содержимое."

#: ../../faq/programming.rst:457
msgid ""
"After the call to :meth:`!append`, the content of the mutable object has "
"changed from ``[]`` to ``[10]``.  Since both the variables refer to the same "
"object, using either name accesses the modified value ``[10]``."
msgstr ""
"После вызова :meth:`!append` содержимое изменяемого объекта изменилось с "
"``[]`` на ``[10]``. Поскольку обе переменные относятся к одному и тому же "
"объекту, использование любого имени дает доступ к измененному значению "
"``[10]``."

#: ../../faq/programming.rst:461
msgid "If we instead assign an immutable object to ``x``::"
msgstr "Если вместо этого мы назначим неизменяемый объект ``x``::"

#: ../../faq/programming.rst:471
msgid ""
"we can see that in this case ``x`` and ``y`` are not equal anymore.  This is "
"because integers are :term:`immutable`, and when we do ``x = x + 1`` we are "
"not mutating the int ``5`` by incrementing its value; instead, we are "
"creating a new object (the int ``6``) and assigning it to ``x`` (that is, "
"changing which object ``x`` refers to).  After this assignment we have two "
"objects (the ints ``6`` and ``5``) and two variables that refer to them "
"(``x`` now refers to ``6`` but ``y`` still refers to ``5``)."
msgstr ""
"мы видим, что в этом случае ``x`` и ``y`` больше не равны. Это связано с "
"тем, что целые числа являются :term:`неизменяемыми`, и когда мы делаем ``x = "
"x + 1``, ​​мы не изменяем int ``5``, увеличивая его значение; вместо этого мы "
"создаем новый объект (int ``6``) и присваиваем его ``x`` (то есть меняем, на "
"какой объект ссылается ``x``). После этого присваивания у нас есть два "
"объекта (целые числа ``6`` и ``5``) и две переменные, которые ссылаются на "
"них (``x`` теперь ссылается на ``6``, но ``y`` по-прежнему относится к "
"``5``)."

#: ../../faq/programming.rst:479
msgid ""
"Some operations (for example ``y.append(10)`` and ``y.sort()``) mutate the "
"object, whereas superficially similar operations (for example ``y = y + "
"[10]`` and :func:`sorted(y) <sorted>`) create a new object.  In general in "
"Python (and in all cases in the standard library) a method that mutates an "
"object will return ``None`` to help avoid getting the two types of "
"operations confused.  So if you mistakenly write ``y.sort()`` thinking it "
"will give you a sorted copy of ``y``, you'll instead end up with ``None``, "
"which will likely cause your program to generate an easily diagnosed error."
msgstr ""
"Некоторые операции (например, y.append(10) и y.sort()) изменяют объект, "
"тогда как внешне похожие операции (например, y = y + [10]`` и : func:"
"`sorted(y) <sorted>`) создаёт новый объект. Обычно в Python (и во всех "
"случаях в стандартной библиотеке) метод, изменяющий объект, возвращает None, "
"чтобы избежать путаницы между двумя типами операций. Поэтому, если вы по "
"ошибке напишете ``y.sort()``, думая, что это даст вам отсортированную копию "
"``y``, вместо этого вы получите ``None``, что, скорее всего, приведет к "
"тому, что ваша программа сгенерирует легко диагностируемая ошибка."

#: ../../faq/programming.rst:488
msgid ""
"However, there is one class of operations where the same operation sometimes "
"has different behaviors with different types:  the augmented assignment "
"operators.  For example, ``+=`` mutates lists but not tuples or ints "
"(``a_list += [1, 2, 3]`` is equivalent to ``a_list.extend([1, 2, 3])`` and "
"mutates ``a_list``, whereas ``some_tuple += (1, 2, 3)`` and ``some_int += "
"1`` create new objects)."
msgstr ""
"Однако существует один класс операций, в которых одна и та же операция "
"иногда ведет себя по-разному с разными типами: расширенные операторы "
"присваивания. Например, ``+=`` изменяет списки, но не кортежи или целые "
"числа (``a_list += [1, 2, 3]`` эквивалентно ``a_list.extend([1, 2, 3])`` и "
"изменяет ``a_list``, тогда как ``some_tuple += (1, 2, 3)`` и ``some_int += "
"1`` создают новые объекты)."

#: ../../faq/programming.rst:495
msgid "In other words:"
msgstr "Другими словами:"

#: ../../faq/programming.rst:497
msgid ""
"If we have a mutable object (:class:`list`, :class:`dict`, :class:`set`, "
"etc.), we can use some specific operations to mutate it and all the "
"variables that refer to it will see the change."
msgstr ""
"Если у нас есть изменяемый объект (:class:`list`, :class:`dict`, :class:"
"`set` и т. д.), мы можем использовать некоторые конкретные операции для его "
"изменения, и все переменные, которые ссылаются на него, будут изменены. "
"увидеть изменение."

#: ../../faq/programming.rst:500
msgid ""
"If we have an immutable object (:class:`str`, :class:`int`, :class:`tuple`, "
"etc.), all the variables that refer to it will always see the same value, "
"but operations that transform that value into a new value always return a "
"new object."
msgstr ""
"Если у нас есть неизменяемый объект (:class:`str`, :class:`int`, :class:"
"`tuple` и т. д.), все переменные, которые ссылаются на него, всегда будут "
"видеть одно и то же значение, но операции, которые преобразуют это значение "
"в новое значение всегда возвращает новый объект."

#: ../../faq/programming.rst:505
msgid ""
"If you want to know if two variables refer to the same object or not, you "
"can use the :keyword:`is` operator, or the built-in function :func:`id`."
msgstr ""
"Если вы хотите узнать, относятся ли две переменные к одному и тому же "
"объекту или нет, вы можете использовать оператор :keyword:`is` или "
"встроенную функцию :func:`id`."

#: ../../faq/programming.rst:510
msgid "How do I write a function with output parameters (call by reference)?"
msgstr "Как написать функцию с выходными параметрами (вызов по ссылке)?"

#: ../../faq/programming.rst:512
msgid ""
"Remember that arguments are passed by assignment in Python.  Since "
"assignment just creates references to objects, there's no alias between an "
"argument name in the caller and callee, and so no call-by-reference per se.  "
"You can achieve the desired effect in a number of ways."
msgstr ""
"Помните, что аргументы в Python передаются путем присваивания. Поскольку "
"присваивание просто создает ссылки на объекты, между именем аргумента в "
"вызывающем и вызываемом объектах нет псевдонима, и, следовательно, нет "
"вызова по ссылке как такового. Добиться желаемого эффекта можно несколькими "
"способами."

#: ../../faq/programming.rst:517
msgid "By returning a tuple of the results::"
msgstr "Возвращая кортеж результатов::"

#: ../../faq/programming.rst:528
msgid "This is almost always the clearest solution."
msgstr "Это почти всегда самое очевидное решение."

#: ../../faq/programming.rst:530
msgid ""
"By using global variables.  This isn't thread-safe, and is not recommended."
msgstr ""
"С помощью глобальных переменных. Это не является потокобезопасным и не "
"рекомендуется."

#: ../../faq/programming.rst:532
msgid "By passing a mutable (changeable in-place) object::"
msgstr "Передавая изменяемый (изменяемый на месте) объект::"

#: ../../faq/programming.rst:543
msgid "By passing in a dictionary that gets mutated::"
msgstr "Передавая словарь, который мутирует::"

#: ../../faq/programming.rst:554
msgid "Or bundle up values in a class instance::"
msgstr "Или объедините значения в экземпляр класса::"

#: ../../faq/programming.rst:571
msgid "There's almost never a good reason to get this complicated."
msgstr "Почти никогда не бывает веской причины все усложнять."

#: ../../faq/programming.rst:573
msgid "Your best choice is to return a tuple containing the multiple results."
msgstr "Лучше всего вернуть кортеж, содержащий несколько результатов."

#: ../../faq/programming.rst:577
msgid "How do you make a higher order function in Python?"
msgstr "Как создать функцию более высокого порядка в Python?"

#: ../../faq/programming.rst:579
msgid ""
"You have two choices: you can use nested scopes or you can use callable "
"objects. For example, suppose you wanted to define ``linear(a,b)`` which "
"returns a function ``f(x)`` that computes the value ``a*x+b``.  Using nested "
"scopes::"
msgstr ""
"У вас есть два варианта: вы можете использовать вложенные области или "
"использовать вызываемые объекты. Например, предположим, что вы хотите "
"определить ``linear(a,b)``, которая возвращает функцию ``f(x)``, вычисляющую "
"значение ``a*x+b``. Использование вложенных областей::"

#: ../../faq/programming.rst:588
msgid "Or using a callable object::"
msgstr "Или используя вызываемый объект::"

#: ../../faq/programming.rst:598
msgid "In both cases, ::"
msgstr "В обоих случаях::"

#: ../../faq/programming.rst:602
msgid "gives a callable object where ``taxes(10e6) == 0.3 * 10e6 + 2``."
msgstr "дает вызываемый объект, где ``taxes(10e6) == 0,3 * 10e6 + 2``."

#: ../../faq/programming.rst:604
msgid ""
"The callable object approach has the disadvantage that it is a bit slower "
"and results in slightly longer code.  However, note that a collection of "
"callables can share their signature via inheritance::"
msgstr ""
"Подход с вызываемыми объектами имеет тот недостаток, что он немного "
"медленнее и приводит к немного более длинному коду. Однако обратите "
"внимание, что коллекция вызываемых объектов может совместно использовать "
"свою подпись посредством наследования:"

#: ../../faq/programming.rst:613
msgid "Object can encapsulate state for several methods::"
msgstr "Объект может инкапсулировать состояние нескольких методов:"

#: ../../faq/programming.rst:631
msgid ""
"Here ``inc()``, ``dec()`` and ``reset()`` act like functions which share the "
"same counting variable."
msgstr ""
"Здесь ``inc()``, ``dec()`` и ``reset()`` действуют как функции, которые "
"используют одну и ту же счетную переменную."

#: ../../faq/programming.rst:636
msgid "How do I copy an object in Python?"
msgstr "Как скопировать объект в Python?"

#: ../../faq/programming.rst:638
msgid ""
"In general, try :func:`copy.copy` or :func:`copy.deepcopy` for the general "
"case. Not all objects can be copied, but most can."
msgstr ""
"В общем, попробуйте :func:`copy.copy` или :func:`copy.deepcopy` для общего "
"случая. Не все объекты можно скопировать, но большинство — можно."

#: ../../faq/programming.rst:641
msgid ""
"Some objects can be copied more easily.  Dictionaries have a :meth:`~dict."
"copy` method::"
msgstr ""
"Некоторые объекты копировать легче. В словарях есть метод :meth:`~dict."
"copy`::"

#: ../../faq/programming.rst:646
msgid "Sequences can be copied by slicing::"
msgstr "Последовательности можно скопировать путем нарезки::"

#: ../../faq/programming.rst:652
msgid "How can I find the methods or attributes of an object?"
msgstr "Как я могу найти методы или атрибуты объекта?"

#: ../../faq/programming.rst:654
msgid ""
"For an instance ``x`` of a user-defined class, :func:`dir(x) <dir>` returns "
"an alphabetized list of the names containing the instance attributes and "
"methods and attributes defined by its class."
msgstr ""
"Для экземпляра ``x`` определяемого пользователем класса :func:`dir(x) <dir>` "
"возвращает алфавитный список имен, содержащих атрибуты экземпляра, а также "
"методы и атрибуты, определенные его классом."

#: ../../faq/programming.rst:660
msgid "How can my code discover the name of an object?"
msgstr "Как мой код может узнать имя объекта?"

#: ../../faq/programming.rst:662
msgid ""
"Generally speaking, it can't, because objects don't really have names. "
"Essentially, assignment always binds a name to a value; the same is true of "
"``def`` and ``class`` statements, but in that case the value is a callable. "
"Consider the following code::"
msgstr ""
"Вообще говоря, это невозможно, потому что у объектов на самом деле нет имен. "
"По сути, присвоение всегда связывает имя со значением; то же самое относится "
"и к операторам ``def`` и ``class``, но в этом случае значение является "
"вызываемым. Рассмотрим следующий код:"

#: ../../faq/programming.rst:678
msgid ""
"Arguably the class has a name: even though it is bound to two names and "
"invoked through the name ``B`` the created instance is still reported as an "
"instance of class ``A``.  However, it is impossible to say whether the "
"instance's name is ``a`` or ``b``, since both names are bound to the same "
"value."
msgstr ""
"Возможно, у класса есть имя: хотя он привязан к двум именам и вызывается "
"через имя «B», о созданном экземпляре все равно сообщается как об экземпляре "
"класса «A». Однако невозможно сказать, является ли имя экземпляра ``a`` или "
"``b``, поскольку оба имени привязаны к одному и тому же значению."

#: ../../faq/programming.rst:683
msgid ""
"Generally speaking it should not be necessary for your code to \"know the "
"names\" of particular values. Unless you are deliberately writing "
"introspective programs, this is usually an indication that a change of "
"approach might be beneficial."
msgstr ""
"Вообще говоря, вашему коду не обязательно «знать имена» конкретных значений. "
"Если вы намеренно не пишете интроспективные программы, обычно это указывает "
"на то, что изменение подхода может быть полезным."

#: ../../faq/programming.rst:688
msgid ""
"In comp.lang.python, Fredrik Lundh once gave an excellent analogy in answer "
"to this question:"
msgstr ""
"В comp.lang.python Фредрик Лунд однажды привел отличную аналогию в ответ на "
"этот вопрос:"

#: ../../faq/programming.rst:691
msgid ""
"The same way as you get the name of that cat you found on your porch: the "
"cat (object) itself cannot tell you its name, and it doesn't really care -- "
"so the only way to find out what it's called is to ask all your neighbours "
"(namespaces) if it's their cat (object)..."
msgstr ""
"Точно так же, как вы узнали имя того кота, которого нашли у себя на крыльце: "
"сам кот (предмет) не может назвать вам свое имя, и его это не особо заботит, "
"поэтому единственный способ узнать, как его зовут, — это спросите всех своих "
"соседей (пространства имен), их ли это кот (объект)..."

#: ../../faq/programming.rst:696
msgid ""
"....and don't be surprised if you'll find that it's known by many names, or "
"no name at all!"
msgstr ""
"....и не удивляйтесь, если обнаружите, что оно известно под многими именами "
"или вообще не имеет имени!"

#: ../../faq/programming.rst:701
msgid "What's up with the comma operator's precedence?"
msgstr "Что случилось с приоритетом оператора запятой?"

#: ../../faq/programming.rst:703
msgid "Comma is not an operator in Python.  Consider this session::"
msgstr "Запятая не является оператором в Python. Рассмотрим эту сессию::"

#: ../../faq/programming.rst:708
msgid ""
"Since the comma is not an operator, but a separator between expressions the "
"above is evaluated as if you had entered::"
msgstr ""
"Поскольку запятая является не оператором, а разделителем между выражениями, "
"приведенное выше оценивается так, как если бы вы ввели::"

#: ../../faq/programming.rst:713
msgid "not::"
msgstr "не::"

#: ../../faq/programming.rst:717
msgid ""
"The same is true of the various assignment operators (``=``, ``+=`` etc).  "
"They are not truly operators but syntactic delimiters in assignment "
"statements."
msgstr ""
"То же самое относится и к различным операторам присваивания (``=``, ``+=`` и "
"т. д.). На самом деле это не операторы, а синтаксические разделители в "
"операторах присваивания."

#: ../../faq/programming.rst:722
msgid "Is there an equivalent of C's \"?:\" ternary operator?"
msgstr "Существует ли эквивалент тернарного оператора C \"?:\"?"

#: ../../faq/programming.rst:724
msgid "Yes, there is. The syntax is as follows::"
msgstr "Да, есть. Синтаксис следующий:"

#: ../../faq/programming.rst:731
msgid ""
"Before this syntax was introduced in Python 2.5, a common idiom was to use "
"logical operators::"
msgstr ""
"До того, как этот синтаксис был представлен в Python 2.5, общепринятой "
"идиомой было использование логических операторов:"

#: ../../faq/programming.rst:736
msgid ""
"However, this idiom is unsafe, as it can give wrong results when *on_true* "
"has a false boolean value.  Therefore, it is always better to use the ``... "
"if ... else ...`` form."
msgstr ""
"Однако эта идиома небезопасна, поскольку она может дать неверные результаты, "
"если *on_true* имеет ложное логическое значение. Поэтому всегда лучше "
"использовать форму ``... if... else...``."

#: ../../faq/programming.rst:742
msgid "Is it possible to write obfuscated one-liners in Python?"
msgstr "Можно ли писать запутанные однострочники на Python?"

#: ../../faq/programming.rst:744
msgid ""
"Yes.  Usually this is done by nesting :keyword:`lambda` within :keyword:`!"
"lambda`.  See the following three examples, slightly adapted from Ulf "
"Bartelt::"
msgstr ""
"Да. Обычно это делается путем вложения :keyword:`lambda` в :keyword:`!"
"lambda`. См. следующие три примера, слегка адаптированные из Ульфа Бартельта:"

#: ../../faq/programming.rst:771
msgid "Don't try this at home, kids!"
msgstr "Не пытайтесь повторить это дома, дети!"

#: ../../faq/programming.rst:777
msgid "What does the slash(/) in the parameter list of a function mean?"
msgstr "Что означает косая черта (/) в списке параметров функции?"

#: ../../faq/programming.rst:779
msgid ""
"A slash in the argument list of a function denotes that the parameters prior "
"to it are positional-only.  Positional-only parameters are the ones without "
"an externally usable name.  Upon calling a function that accepts positional-"
"only parameters, arguments are mapped to parameters based solely on their "
"position. For example, :func:`divmod` is a function that accepts positional-"
"only parameters. Its documentation looks like this::"
msgstr ""
"Косая черта в списке аргументов функции означает, что параметры перед ней "
"являются только позиционными. Параметры, предназначенные только для "
"позиционирования, — это параметры без имени, пригодного для внешнего "
"использования. При вызове функции, которая принимает только позиционные "
"параметры, аргументы сопоставляются с параметрами исключительно на основе их "
"позиции. Например, :func:`divmod` — это функция, которая принимает только "
"позиционные параметры. Его документация выглядит следующим образом:"

#: ../../faq/programming.rst:792
msgid ""
"The slash at the end of the parameter list means that both parameters are "
"positional-only. Thus, calling :func:`divmod` with keyword arguments would "
"lead to an error::"
msgstr ""
"Косая черта в конце списка параметров означает, что оба параметра являются "
"только позиционными. Таким образом, вызов :func:`divmod` с аргументами "
"ключевого слова приведет к ошибке::"

#: ../../faq/programming.rst:803
msgid "Numbers and strings"
msgstr "Числа и строки"

#: ../../faq/programming.rst:806
msgid "How do I specify hexadecimal and octal integers?"
msgstr "Как указать шестнадцатеричные и восьмеричные целые числа?"

#: ../../faq/programming.rst:808
msgid ""
"To specify an octal digit, precede the octal value with a zero, and then a "
"lower or uppercase \"o\".  For example, to set the variable \"a\" to the "
"octal value \"10\" (8 in decimal), type::"
msgstr ""
"Чтобы указать восьмеричную цифру, перед восьмеричным значением поставьте "
"ноль, а затем строчную или прописную букву «о». Например, чтобы присвоить "
"переменной «a» восьмеричное значение «10» (8 в десятичном формате), введите::"

#: ../../faq/programming.rst:816
msgid ""
"Hexadecimal is just as easy.  Simply precede the hexadecimal number with a "
"zero, and then a lower or uppercase \"x\".  Hexadecimal digits can be "
"specified in lower or uppercase.  For example, in the Python interpreter::"
msgstr ""
"Шестнадцатеричный формат так же прост. Просто предшествуйте "
"шестнадцатеричному числу нулем, а затем буквой «x» в нижнем или верхнем "
"регистре. Шестнадцатеричные цифры можно указывать в нижнем или верхнем "
"регистре. Например, в интерпретаторе Python::"

#: ../../faq/programming.rst:829
msgid "Why does -22 // 10 return -3?"
msgstr "Почему -22 // 10 возвращает -3?"

#: ../../faq/programming.rst:831
msgid ""
"It's primarily driven by the desire that ``i % j`` have the same sign as "
"``j``. If you want that, and also want::"
msgstr ""
"В первую очередь это обусловлено желанием, чтобы ``i % j`` имел тот же знак, "
"что и ``j``. Если вы этого хотите, а также хотите::"

#: ../../faq/programming.rst:836
msgid ""
"then integer division has to return the floor.  C also requires that "
"identity to hold, and then compilers that truncate ``i // j`` need to make "
"``i % j`` have the same sign as ``i``."
msgstr ""
"тогда целочисленное деление должно вернуть слово. C также требует, чтобы эта "
"идентичность сохранялась, а затем компиляторы, которые усекают ``i // j``, "
"должны сделать ``i % j`` имеющим тот же знак, что и ``i``."

#: ../../faq/programming.rst:840
msgid ""
"There are few real use cases for ``i % j`` when ``j`` is negative.  When "
"``j`` is positive, there are many, and in virtually all of them it's more "
"useful for ``i % j`` to be ``>= 0``.  If the clock says 10 now, what did it "
"say 200 hours ago?  ``-190 % 12 == 2`` is useful; ``-190 % 12 == -10`` is a "
"bug waiting to bite."
msgstr ""
"Существует несколько реальных случаев использования ``i % j``, когда ``j`` "
"имеет отрицательное значение. Когда ``j`` положителен, их много, и "
"практически во всех из них полезнее, чтобы ``i % j`` был ``>= 0``. Если "
"сейчас часы показывают 10, что они показывали 200 часов назад? ``-190 % 12 "
"== 2`` полезен; ``-190 % 12 == -10`` — это ошибка, ожидающая своего укуса."

#: ../../faq/programming.rst:848
msgid "How do I get int literal attribute instead of SyntaxError?"
msgstr "Как мне получить литеральный атрибут int вместо SyntaxError?"

#: ../../faq/programming.rst:850
msgid ""
"Trying to lookup an ``int`` literal attribute in the normal manner gives a :"
"exc:`SyntaxError` because the period is seen as a decimal point::"
msgstr ""
"Попытка найти литеральный атрибут ``int`` обычным способом выдает ошибку :"
"exc:`SyntaxError`, поскольку точка рассматривается как десятичная точка::"

#: ../../faq/programming.rst:859
msgid ""
"The solution is to separate the literal from the period with either a space "
"or parentheses."
msgstr ""
"Решение состоит в том, чтобы отделить литерал от точки пробелом или круглыми "
"скобками."

#: ../../faq/programming.rst:869
msgid "How do I convert a string to a number?"
msgstr "Как преобразовать строку в число?"

#: ../../faq/programming.rst:871
msgid ""
"For integers, use the built-in :func:`int` type constructor, e.g. "
"``int('144') == 144``.  Similarly, :func:`float` converts to floating-point, "
"e.g. ``float('144') == 144.0``."
msgstr ""

#: ../../faq/programming.rst:875
msgid ""
"By default, these interpret the number as decimal, so that ``int('0144') == "
"144`` holds true, and ``int('0x144')`` raises :exc:`ValueError`. "
"``int(string, base)`` takes the base to convert from as a second optional "
"argument, so ``int( '0x144', 16) == 324``.  If the base is specified as 0, "
"the number is interpreted using Python's rules: a leading '0o' indicates "
"octal, and '0x' indicates a hex number."
msgstr ""
"По умолчанию они интерпретируют число как десятичное, так что ``int('0144') "
"== 144`` остается истинным, а ``int('0x144')`` вызывает :exc:`ValueError`. "
"``int(string, base)`` принимает базу для преобразования в качестве второго "
"необязательного аргумента, поэтому ``int( '0x144', 16) == 324``. Если "
"основание указано как 0, число интерпретируется с использованием правил "
"Python: ведущий «0o» указывает на восьмеричное число, а «0x» указывает на "
"шестнадцатеричное число."

#: ../../faq/programming.rst:882
msgid ""
"Do not use the built-in function :func:`eval` if all you need is to convert "
"strings to numbers.  :func:`eval` will be significantly slower and it "
"presents a security risk: someone could pass you a Python expression that "
"might have unwanted side effects.  For example, someone could pass "
"``__import__('os').system(\"rm -rf $HOME\")`` which would erase your home "
"directory."
msgstr ""
"Не используйте встроенную функцию :func:`eval`, если все, что вам нужно, это "
"преобразовать строки в числа. :func:`eval` будет работать значительно "
"медленнее и представляет угрозу безопасности: кто-то может передать вам "
"выражение Python, которое может иметь нежелательные побочные эффекты. "
"Например, кто-то может передать ``__import__('os').system(\"rm -rf "
"$HOME\")`, что удалит ваш домашний каталог."

#: ../../faq/programming.rst:889
msgid ""
":func:`eval` also has the effect of interpreting numbers as Python "
"expressions, so that e.g. ``eval('09')`` gives a syntax error because Python "
"does not allow leading '0' in a decimal number (except '0')."
msgstr ""
":func:`eval` также интерпретирует числа как выражения Python, так что, "
"например, ``eval('09')`` выдает синтаксическую ошибку, поскольку Python не "
"позволяет начинать 0 в десятичном числе (за исключением ' 0')."

#: ../../faq/programming.rst:895
msgid "How do I convert a number to a string?"
msgstr "Как преобразовать число в строку?"

#: ../../faq/programming.rst:897
msgid ""
"To convert, e.g., the number ``144`` to the string ``'144'``, use the built-"
"in type constructor :func:`str`.  If you want a hexadecimal or octal "
"representation, use the built-in functions :func:`hex` or :func:`oct`.  For "
"fancy formatting, see the :ref:`f-strings` and :ref:`formatstrings` "
"sections, e.g. ``\"{:04d}\".format(144)`` yields ``'0144'`` and ``\"{:.3f}\"."
"format(1.0/3.0)`` yields ``'0.333'``."
msgstr ""
"Чтобы преобразовать, например, число ``144`` в строку ``'144'``, используйте "
"встроенный конструктор типа :func:`str`. Если вам нужно шестнадцатеричное "
"или восьмеричное представление, используйте встроенные функции :func:`hex` "
"или :func:`oct`. О необычном форматировании см. разделы :ref:`f-strings` и :"
"ref:`formatstrings`, например, ``\"{:04d}\".format(144)`` дает ``'0144'`` и "
"`` \"{:.3f}\".format(1.0/3.0)`` дает ``'0,333'``."

#: ../../faq/programming.rst:906
msgid "How do I modify a string in place?"
msgstr "Как изменить строку на месте?"

#: ../../faq/programming.rst:908
msgid ""
"You can't, because strings are immutable.  In most situations, you should "
"simply construct a new string from the various parts you want to assemble it "
"from.  However, if you need an object with the ability to modify in-place "
"unicode data, try using an :class:`io.StringIO` object or the :mod:`array` "
"module::"
msgstr ""
"Вы не можете, потому что строки неизменяемы. В большинстве ситуаций вам "
"следует просто построить новую строку из различных частей, из которых вы "
"хотите ее собрать. Однако, если вам нужен объект с возможностью изменения "
"данных Юникода на месте, попробуйте использовать объект :class:`io.StringIO` "
"или модуль :mod:`array`::"

#: ../../faq/programming.rst:938
msgid "How do I use strings to call functions/methods?"
msgstr "Как использовать строки для вызова функций/методов?"

#: ../../faq/programming.rst:940
msgid "There are various techniques."
msgstr "Существуют различные техники."

#: ../../faq/programming.rst:942
msgid ""
"The best is to use a dictionary that maps strings to functions.  The primary "
"advantage of this technique is that the strings do not need to match the "
"names of the functions.  This is also the primary technique used to emulate "
"a case construct::"
msgstr ""
"Лучше всего использовать словарь, который сопоставляет строки с функциями. "
"Основное преимущество этого метода заключается в том, что строки не "
"обязательно должны совпадать с именами функций. Это также основной метод, "
"используемый для эмуляции конструкции Case:"

#: ../../faq/programming.rst:957
msgid "Use the built-in function :func:`getattr`::"
msgstr "Используйте встроенную функцию :func:`getattr`::"

#: ../../faq/programming.rst:962
msgid ""
"Note that :func:`getattr` works on any object, including classes, class "
"instances, modules, and so on."
msgstr ""
"Обратите внимание, что :func:`getattr` работает с любым объектом, включая "
"классы, экземпляры классов, модули и т. д."

#: ../../faq/programming.rst:965
msgid "This is used in several places in the standard library, like this::"
msgstr "Это используется в нескольких местах стандартной библиотеки, например:"

#: ../../faq/programming.rst:978
msgid "Use :func:`locals` to resolve the function name::"
msgstr "Используйте :func:`locals` для разрешения имени функции::"

#: ../../faq/programming.rst:990
msgid ""
"Is there an equivalent to Perl's chomp() for removing trailing newlines from "
"strings?"
msgstr ""
"Существует ли эквивалент Perl chomp() для удаления завершающих символов "
"новой строки из строк?"

#: ../../faq/programming.rst:992
msgid ""
"You can use ``S.rstrip(\"\\r\\n\")`` to remove all occurrences of any line "
"terminator from the end of the string ``S`` without removing other trailing "
"whitespace.  If the string ``S`` represents more than one line, with several "
"empty lines at the end, the line terminators for all the blank lines will be "
"removed::"
msgstr ""
"Вы можете использовать ``S.rstrip(\"\\r\\n\")`` для удаления всех вхождений "
"любого признака конца строки из конца строки ``S`` без удаления других "
"конечных пробелов. Если строка ``S`` представляет более одной строки с "
"несколькими пустыми строками в конце, ограничители строк для всех пустых "
"строк будут удалены::"

#: ../../faq/programming.rst:1004
msgid ""
"Since this is typically only desired when reading text one line at a time, "
"using ``S.rstrip()`` this way works well."
msgstr ""
"Поскольку обычно это требуется только при чтении текста по одной строке, "
"использование S.rstrip() работает хорошо."

#: ../../faq/programming.rst:1009
msgid "Is there a scanf() or sscanf() equivalent?"
msgstr "Есть ли эквивалент scanf() или sscanf()?"

#: ../../faq/programming.rst:1011
msgid "Not as such."
msgstr "Не как таковой."

#: ../../faq/programming.rst:1013
msgid ""
"For simple input parsing, the easiest approach is usually to split the line "
"into whitespace-delimited words using the :meth:`~str.split` method of "
"string objects and then convert decimal strings to numeric values using :"
"func:`int` or :func:`float`.  :meth:`!split()` supports an optional \"sep\" "
"parameter which is useful if the line uses something other than whitespace "
"as a separator."
msgstr ""

#: ../../faq/programming.rst:1019
msgid ""
"For more complicated input parsing, regular expressions are more powerful "
"than C's ``sscanf`` and better suited for the task."
msgstr ""
"Для более сложного анализа входных данных регулярные выражения более "
"эффективны, чем sscanf в C, и лучше подходят для этой задачи."

#: ../../faq/programming.rst:1024
msgid "What does 'UnicodeDecodeError' or 'UnicodeEncodeError' error  mean?"
msgstr "Что означает ошибка «UnicodeDecodeError» или «UnicodeEncodeError»?"

#: ../../faq/programming.rst:1026
msgid "See the :ref:`unicode-howto`."
msgstr "Смотри :ref:`unicode-howto`."

#: ../../faq/programming.rst:1032
msgid "Can I end a raw string with an odd number of backslashes?"
msgstr ""
"Могу ли я закончить необработанную строку нечетным количеством обратных "
"косых черт?"

#: ../../faq/programming.rst:1034
msgid ""
"A raw string ending with an odd number of backslashes will escape the "
"string's quote::"
msgstr ""
"Необработанная строка, заканчивающаяся нечетным количеством обратных косых "
"черт, будет экранирована кавычкой строки::"

#: ../../faq/programming.rst:1042
msgid ""
"There are several workarounds for this. One is to use regular strings and "
"double the backslashes::"
msgstr ""
"Для этого есть несколько обходных путей. Один из них — использовать обычные "
"строки и удвоить обратную косую черту::"

#: ../../faq/programming.rst:1048
msgid ""
"Another is to concatenate a regular string containing an escaped backslash "
"to the raw string::"
msgstr ""
"Другой способ — объединить обычную строку, содержащую экранированную "
"обратную косую черту, с необработанной строкой::"

#: ../../faq/programming.rst:1054
msgid ""
"It is also possible to use :func:`os.path.join` to append a backslash on "
"Windows::"
msgstr ""
"Также можно использовать :func:`os.path.join` для добавления обратной косой "
"черты в Windows::"

#: ../../faq/programming.rst:1059
msgid ""
"Note that while a backslash will \"escape\" a quote for the purposes of "
"determining where the raw string ends, no escaping occurs when interpreting "
"the value of the raw string. That is, the backslash remains present in the "
"value of the raw string::"
msgstr ""
"Обратите внимание: хотя обратная косая черта «экранирует» кавычку с целью "
"определения, где заканчивается необработанная строка, при интерпретации "
"значения необработанной строки экранирование не происходит. То есть обратная "
"косая черта остается в значении необработанной строки::"

#: ../../faq/programming.rst:1067
msgid "Also see the specification in the :ref:`language reference <strings>`."
msgstr "Также смотрите спецификацию в :ref:`справке по языку <strings>`."

#: ../../faq/programming.rst:1070
msgid "Performance"
msgstr "Производительность"

#: ../../faq/programming.rst:1073
msgid "My program is too slow. How do I speed it up?"
msgstr "Моя программа слишком медленная. Как мне ускорить это?"

#: ../../faq/programming.rst:1075
msgid ""
"That's a tough one, in general.  First, here are a list of things to "
"remember before diving further:"
msgstr ""
"Это вообще сложный вопрос. Во-первых, вот список вещей, которые следует "
"запомнить, прежде чем погружаться дальше:"

#: ../../faq/programming.rst:1078
msgid ""
"Performance characteristics vary across Python implementations.  This FAQ "
"focuses on :term:`CPython`."
msgstr ""
"Характеристики производительности различаются в зависимости от реализации "
"Python. Этот FAQ посвящен :term:`CPython`."

#: ../../faq/programming.rst:1080
msgid ""
"Behaviour can vary across operating systems, especially when talking about I/"
"O or multi-threading."
msgstr ""
"Поведение может различаться в разных операционных системах, особенно когда "
"речь идет о вводе-выводе или многопоточности."

#: ../../faq/programming.rst:1082
msgid ""
"You should always find the hot spots in your program *before* attempting to "
"optimize any code (see the :mod:`profile` module)."
msgstr ""
"Вы всегда должны находить «горячие точки» в своей программе *прежде* "
"пытаться оптимизировать какой-либо код (см. модуль :mod:`profile`)."

#: ../../faq/programming.rst:1084
msgid ""
"Writing benchmark scripts will allow you to iterate quickly when searching "
"for improvements (see the :mod:`timeit` module)."
msgstr ""
"Написание сценариев тестирования позволит вам быстро выполнять итерации при "
"поиске улучшений (см. модуль :mod:`timeit`)."

#: ../../faq/programming.rst:1086
msgid ""
"It is highly recommended to have good code coverage (through unit testing or "
"any other technique) before potentially introducing regressions hidden in "
"sophisticated optimizations."
msgstr ""
"Настоятельно рекомендуется обеспечить хорошее покрытие кода (посредством "
"модульного тестирования или любого другого метода), прежде чем потенциально "
"вводить регрессии, скрытые в сложных оптимизациях."

#: ../../faq/programming.rst:1090
msgid ""
"That being said, there are many tricks to speed up Python code.  Here are "
"some general principles which go a long way towards reaching acceptable "
"performance levels:"
msgstr ""
"При этом существует множество приемов для ускорения кода Python. Вот "
"некоторые общие принципы, которые имеют большое значение для достижения "
"приемлемого уровня производительности:"

#: ../../faq/programming.rst:1094
msgid ""
"Making your algorithms faster (or changing to faster ones) can yield much "
"larger benefits than trying to sprinkle micro-optimization tricks all over "
"your code."
msgstr ""
"Ускорение алгоритмов (или переход на более быстрые) может принести гораздо "
"большую выгоду, чем попытки разбросать трюки по микрооптимизации по всему "
"коду."

#: ../../faq/programming.rst:1098
msgid ""
"Use the right data structures.  Study documentation for the :ref:`bltin-"
"types` and the :mod:`collections` module."
msgstr ""
"Используйте правильные структуры данных. Изучите документацию для модуля :"
"ref:`bltin-types` и :mod:`collections`."

#: ../../faq/programming.rst:1101
msgid ""
"When the standard library provides a primitive for doing something, it is "
"likely (although not guaranteed) to be faster than any alternative you may "
"come up with.  This is doubly true for primitives written in C, such as "
"builtins and some extension types.  For example, be sure to use either the :"
"meth:`list.sort` built-in method or the related :func:`sorted` function to "
"do sorting (and see the :ref:`sortinghowto` for examples of moderately "
"advanced usage)."
msgstr ""
"Когда стандартная библиотека предоставляет примитив для выполнения чего-"
"либо, он, скорее всего (хотя и не гарантированно), будет быстрее, чем любой "
"альтернативный вариант, который вы можете придумать. Это вдвойне верно для "
"примитивов, написанных на C, таких как встроенные функции и некоторые типы "
"расширений. Например, обязательно используйте либо встроенный метод :meth:"
"`list.sort`, либо связанную с ним функцию :func:`sorted` для выполнения "
"сортировки (см. :ref:`sortinghowto` для примеров умеренно продвинутого "
"использования. )."

#: ../../faq/programming.rst:1109
msgid ""
"Abstractions tend to create indirections and force the interpreter to work "
"more.  If the levels of indirection outweigh the amount of useful work done, "
"your program will be slower.  You should avoid excessive abstraction, "
"especially under the form of tiny functions or methods (which are also often "
"detrimental to readability)."
msgstr ""
"Абстракции имеют тенденцию создавать косвенные направления и заставлять "
"интерпретатора работать больше. Если уровень косвенности перевешивает объем "
"проделанной полезной работы, ваша программа будет работать медленнее. Вам "
"следует избегать чрезмерной абстракции, особенно в виде крошечных функций "
"или методов (которые также часто вредны для читабельности)."

#: ../../faq/programming.rst:1115
msgid ""
"If you have reached the limit of what pure Python can allow, there are tools "
"to take you further away.  For example, `Cython <https://cython.org>`_ can "
"compile a slightly modified version of Python code into a C extension, and "
"can be used on many different platforms.  Cython can take advantage of "
"compilation (and optional type annotations) to make your code significantly "
"faster than when interpreted.  If you are confident in your C programming "
"skills, you can also :ref:`write a C extension module <extending-index>` "
"yourself."
msgstr ""
"Если вы достигли предела возможностей чистого Python, есть инструменты, "
"которые помогут вам продвинуться еще дальше. Например, `Cython <https://"
"cython.org>`_ может скомпилировать слегка измененную версию кода Python в "
"расширение C и может использоваться на многих различных платформах. Cython "
"может использовать преимущества компиляции (и необязательных аннотаций "
"типов), чтобы сделать ваш код значительно быстрее, чем при интерпретации. "
"Если вы уверены в своих навыках программирования на C, вы также можете :ref:"
"`написать модуль расширения C <extending-index>` самостоятельно."

#: ../../faq/programming.rst:1125
msgid ""
"The wiki page devoted to `performance tips <https://wiki.python.org/moin/"
"PythonSpeed/PerformanceTips>`_."
msgstr ""
"Вики-страница, посвященная `советам по производительности <https://wiki."
"python.org/moin/PythonSpeed/PerformanceTips>`_."

#: ../../faq/programming.rst:1131
msgid "What is the most efficient way to concatenate many strings together?"
msgstr ""
"Вики-страница, посвященная `советам по производительности <https://wiki."
"python.org/moin/PythonSpeed/PerformanceTips>`_."

#: ../../faq/programming.rst:1133
msgid ""
":class:`str` and :class:`bytes` objects are immutable, therefore "
"concatenating many strings together is inefficient as each concatenation "
"creates a new object.  In the general case, the total runtime cost is "
"quadratic in the total string length."
msgstr ""
"Объекты :class:`str` и :class:`bytes` являются неизменяемыми, поэтому "
"объединение множества строк неэффективно, поскольку каждое объединение "
"создает новый объект. В общем случае общие затраты времени выполнения "
"квадратичны по отношению к общей длине строки."

#: ../../faq/programming.rst:1138
msgid ""
"To accumulate many :class:`str` objects, the recommended idiom is to place "
"them into a list and call :meth:`str.join` at the end::"
msgstr ""
"Чтобы накопить множество объектов :class:`str`, рекомендуется поместить их в "
"список и вызвать :meth:`str.join` в конце::"

#: ../../faq/programming.rst:1146
msgid "(another reasonably efficient idiom is to use :class:`io.StringIO`)"
msgstr ""
"(еще одна достаточно эффективная идиома — использовать :class:`io.StringIO`)"

#: ../../faq/programming.rst:1148
msgid ""
"To accumulate many :class:`bytes` objects, the recommended idiom is to "
"extend a :class:`bytearray` object using in-place concatenation (the ``+=`` "
"operator)::"
msgstr ""
"Для накопления большого количества объектов :class:`bytes` рекомендуется "
"расширить объект :class:`bytearray` с помощью конкатенации на месте "
"(оператор ``+=``)::"

#: ../../faq/programming.rst:1157
msgid "Sequences (Tuples/Lists)"
msgstr "Последовательности (кортежи/списки)"

#: ../../faq/programming.rst:1160
msgid "How do I convert between tuples and lists?"
msgstr "Как мне преобразовать кортежи и списки?"

#: ../../faq/programming.rst:1162
msgid ""
"The type constructor ``tuple(seq)`` converts any sequence (actually, any "
"iterable) into a tuple with the same items in the same order."
msgstr ""
"Конструктор типа tuple(seq) преобразует любую последовательность (фактически "
"любую итерацию) в кортеж с одинаковыми элементами в том же порядке."

#: ../../faq/programming.rst:1165
msgid ""
"For example, ``tuple([1, 2, 3])`` yields ``(1, 2, 3)`` and ``tuple('abc')`` "
"yields ``('a', 'b', 'c')``.  If the argument is a tuple, it does not make a "
"copy but returns the same object, so it is cheap to call :func:`tuple` when "
"you aren't sure that an object is already a tuple."
msgstr ""
"Например, ``tuple([1, 2, 3])`` дает ``(1, 2, 3)``, а ``tuple('abc')`` дает "
"``('a', 'b ', 'c')``. Если аргументом является кортеж, он не копирует "
"объект, а возвращает тот же объект, поэтому проще вызвать :func:`tuple`, "
"когда вы не уверены, что объект уже является кортежем."

#: ../../faq/programming.rst:1170
msgid ""
"The type constructor ``list(seq)`` converts any sequence or iterable into a "
"list with the same items in the same order.  For example, ``list((1, 2, "
"3))`` yields ``[1, 2, 3]`` and ``list('abc')`` yields ``['a', 'b', 'c']``.  "
"If the argument is a list, it makes a copy just like ``seq[:]`` would."
msgstr ""
"Конструктор типа list(seq) преобразует любую последовательность или итерацию "
"в список с одинаковыми элементами в том же порядке. Например, ``list((1, 2, "
"3))`` дает ``[1, 2, 3]``, а ``list('abc')`` дает ``['a', 'b ', 'c']``. Если "
"аргументом является список, он создает копию точно так же, как это сделал бы "
"``seq[:]``."

#: ../../faq/programming.rst:1177
msgid "What's a negative index?"
msgstr "Что такое отрицательный индекс?"

#: ../../faq/programming.rst:1179
msgid ""
"Python sequences are indexed with positive numbers and negative numbers.  "
"For positive numbers 0 is the first index 1 is the second index and so "
"forth.  For negative indices -1 is the last index and -2 is the penultimate "
"(next to last) index and so forth.  Think of ``seq[-n]`` as the same as "
"``seq[len(seq)-n]``."
msgstr ""
"Последовательности Python индексируются положительными и отрицательными "
"числами. Для положительных чисел 0 — это первый индекс, 1 — это второй "
"индекс и так далее. Для отрицательных индексов -1 — это последний индекс, -2 "
"— предпоследний (предпоследний) индекс и так далее. Думайте о ``seq[-n]`` "
"как о ``seq[len(seq)-n]``."

#: ../../faq/programming.rst:1184
msgid ""
"Using negative indices can be very convenient.  For example ``S[:-1]`` is "
"all of the string except for its last character, which is useful for "
"removing the trailing newline from a string."
msgstr ""
"Использование отрицательных индексов может быть очень удобным. Например, "
"``S[:-1]`` — это вся строка, за исключением ее последнего символа, который "
"полезен для удаления завершающего символа новой строки из строки."

#: ../../faq/programming.rst:1190
msgid "How do I iterate over a sequence in reverse order?"
msgstr "Как перебрать последовательность в обратном порядке?"

#: ../../faq/programming.rst:1192
msgid "Use the :func:`reversed` built-in function::"
msgstr "Используйте встроенную функцию :func:`reversed`::"

#: ../../faq/programming.rst:1197
msgid ""
"This won't touch your original sequence, but build a new copy with reversed "
"order to iterate over."
msgstr ""
"Это не затронет исходную последовательность, а создаст новую копию с "
"обратным порядком для повторения."

#: ../../faq/programming.rst:1202
msgid "How do you remove duplicates from a list?"
msgstr "Как удалить дубликаты из списка?"

#: ../../faq/programming.rst:1204
msgid "See the Python Cookbook for a long discussion of many ways to do this:"
msgstr ""
"См. «Поваренную книгу Python» для подробного обсуждения многих способов "
"сделать это:"

#: ../../faq/programming.rst:1206
msgid "https://code.activestate.com/recipes/52560/"
msgstr "https://code.activestate.com/recipes/52560/"

#: ../../faq/programming.rst:1208
msgid ""
"If you don't mind reordering the list, sort it and then scan from the end of "
"the list, deleting duplicates as you go::"
msgstr ""
"Если вы не против изменить порядок списка, отсортируйте его, а затем "
"просканируйте с конца списка, удаляя дубликаты по ходу::"

#: ../../faq/programming.rst:1220
msgid ""
"If all elements of the list may be used as set keys (i.e. they are all :term:"
"`hashable`) this is often faster ::"
msgstr ""
"Если все элементы списка могут использоваться как заданные ключи (т.е. все "
"они :term:`hashable`), это часто происходит быстрее::"

#: ../../faq/programming.rst:1225
msgid ""
"This converts the list into a set, thereby removing duplicates, and then "
"back into a list."
msgstr ""
"Если все элементы списка могут использоваться как заданные ключи (т.е. все "
"они :term:`hashable`), это часто происходит быстрее::"

#: ../../faq/programming.rst:1230
msgid "How do you remove multiple items from a list"
msgstr "Как удалить несколько элементов из списка"

#: ../../faq/programming.rst:1232
msgid ""
"As with removing duplicates, explicitly iterating in reverse with a delete "
"condition is one possibility.  However, it is easier and faster to use slice "
"replacement with an implicit or explicit forward iteration. Here are three "
"variations.::"
msgstr ""
"Как и при удалении дубликатов, одной из возможностей является явная обратная "
"итерация с условием удаления. Однако проще и быстрее использовать замену "
"среза с неявной или явной прямой итерацией. Вот три варианта.::"

#: ../../faq/programming.rst:1241
msgid "The list comprehension may be fastest."
msgstr "Понимание списка может быть самым быстрым."

#: ../../faq/programming.rst:1245
msgid "How do you make an array in Python?"
msgstr "Как создать массив в Python?"

#: ../../faq/programming.rst:1247
msgid "Use a list::"
msgstr "Используйте список::"

#: ../../faq/programming.rst:1251
msgid ""
"Lists are equivalent to C or Pascal arrays in their time complexity; the "
"primary difference is that a Python list can contain objects of many "
"different types."
msgstr ""
"Списки эквивалентны массивам C или Pascal по своей временной сложности; "
"Основное отличие состоит в том, что список Python может содержать объекты "
"самых разных типов."

#: ../../faq/programming.rst:1254
msgid ""
"The ``array`` module also provides methods for creating arrays of fixed "
"types with compact representations, but they are slower to index than "
"lists.  Also note that `NumPy <https://numpy.org/>`_ and other third party "
"packages define array-like structures with various characteristics as well."
msgstr ""
"Модуль Array также предоставляет методы для создания массивов фиксированных "
"типов с компактными представлениями, но они индексируются медленнее, чем "
"списки. Также обратите внимание, что `NumPy <https://numpy.org/>`_ и другие "
"сторонние пакеты также определяют структуры, подобные массивам, с различными "
"характеристиками."

#: ../../faq/programming.rst:1260
msgid ""
"To get Lisp-style linked lists, you can emulate *cons cells* using tuples::"
msgstr ""
"Чтобы получить связанные списки в стиле Lisp, вы можете эмулировать *cons-"
"ячейки*, используя кортежи::"

#: ../../faq/programming.rst:1264
msgid ""
"If mutability is desired, you could use lists instead of tuples.  Here the "
"analogue of a Lisp *car* is ``lisp_list[0]`` and the analogue of *cdr* is "
"``lisp_list[1]``.  Only do this if you're sure you really need to, because "
"it's usually a lot slower than using Python lists."
msgstr ""
"Если требуется изменчивость, вы можете использовать списки вместо кортежей. "
"Здесь аналогом *car* в Лиспе является ``lisp_list[0]``, а аналогом *cdr* — "
"``lisp_list[1]``. Делайте это только в том случае, если вы уверены, что это "
"действительно необходимо, потому что обычно это намного медленнее, чем "
"использование списков Python."

#: ../../faq/programming.rst:1273
msgid "How do I create a multidimensional list?"
msgstr "Как создать многомерный список?"

#: ../../faq/programming.rst:1275
msgid "You probably tried to make a multidimensional array like this::"
msgstr "Вероятно, вы пытались создать такой многомерный массив:"

#: ../../faq/programming.rst:1279
msgid "This looks correct if you print it:"
msgstr "Это выглядит правильно, если вы распечатаете это:"

#: ../../faq/programming.rst:1290
msgid "But when you assign a value, it shows up in multiple places:"
msgstr ""
"Но когда вы присваиваете значение, оно отображается в нескольких местах:"

#: ../../faq/programming.rst:1302
msgid ""
"The reason is that replicating a list with ``*`` doesn't create copies, it "
"only creates references to the existing objects.  The ``*3`` creates a list "
"containing 3 references to the same list of length two.  Changes to one row "
"will show in all rows, which is almost certainly not what you want."
msgstr ""
"Причина в том, что репликация списка с помощью ``*`` не создает копий, а "
"только создает ссылки на существующие объекты. ``*3`` создает список, "
"содержащий три ссылки на один и тот же список длиной два. Изменения в одной "
"строке будут отображаться во всех строках, что почти наверняка не то, что "
"вам нужно."

#: ../../faq/programming.rst:1307
msgid ""
"The suggested approach is to create a list of the desired length first and "
"then fill in each element with a newly created list::"
msgstr ""
"Предлагаемый подход заключается в том, чтобы сначала создать список желаемой "
"длины, а затем заполнить каждый элемент вновь созданным списком:"

#: ../../faq/programming.rst:1314
msgid ""
"This generates a list containing 3 different lists of length two.  You can "
"also use a list comprehension::"
msgstr ""
"Это генерирует список, содержащий 3 разных списка длиной два. Вы также "
"можете использовать понимание списка::"

#: ../../faq/programming.rst:1320
msgid ""
"Or, you can use an extension that provides a matrix datatype; `NumPy "
"<https://numpy.org/>`_ is the best known."
msgstr ""
"Или вы можете использовать расширение, предоставляющее матричный тип данных; "
"`NumPy <https://numpy.org/>`_ является самым известным."

#: ../../faq/programming.rst:1325
msgid "How do I apply a method or function to a sequence of objects?"
msgstr "Как применить метод или функцию к последовательности объектов?"

#: ../../faq/programming.rst:1327
msgid ""
"To call a method or function and accumulate the return values is a list, a :"
"term:`list comprehension` is an elegant solution::"
msgstr ""
"Чтобы вызвать метод или функцию и накопить возвращаемые значения, "
"представляет собой список, элегантным решением является :term:`list "
"comprehension`::"

#: ../../faq/programming.rst:1334
msgid ""
"To just run the method or function without saving the return values, a "
"plain :keyword:`for` loop will suffice::"
msgstr ""
"Чтобы просто запустить метод или функцию без сохранения возвращаемых "
"значений, достаточно простого цикла :keyword:`for`::"

#: ../../faq/programming.rst:1346
msgid ""
"Why does a_tuple[i] += ['item'] raise an exception when the addition works?"
msgstr ""
"Почему a_tuple[i] += ['item'] вызывает исключение, когда сложение работает?"

#: ../../faq/programming.rst:1348
msgid ""
"This is because of a combination of the fact that augmented assignment "
"operators are *assignment* operators, and the difference between mutable and "
"immutable objects in Python."
msgstr ""
"Это происходит из-за сочетания того факта, что расширенные операторы "
"присваивания являются операторами *присваивания*, а также разницы между "
"изменяемыми и неизменяемыми объектами в Python."

#: ../../faq/programming.rst:1352
msgid ""
"This discussion applies in general when augmented assignment operators are "
"applied to elements of a tuple that point to mutable objects, but we'll use "
"a ``list`` and ``+=`` as our exemplar."
msgstr ""
"Это обсуждение в целом применимо, когда расширенные операторы присваивания "
"применяются к элементам кортежа, указывающим на изменяемые объекты, но в "
"качестве примера мы будем использовать ``list`` и ``+=``."

#: ../../faq/programming.rst:1356
msgid "If you wrote::"
msgstr "Если вы написали::"

#: ../../faq/programming.rst:1364
msgid ""
"The reason for the exception should be immediately clear: ``1`` is added to "
"the object ``a_tuple[0]`` points to (``1``), producing the result object, "
"``2``, but when we attempt to assign the result of the computation, ``2``, "
"to element ``0`` of the tuple, we get an error because we can't change what "
"an element of a tuple points to."
msgstr ""
"Причина исключения должна быть сразу ясна: ``1`` добавляется к объекту "
"``a_tuple[0]``, указывающему на (``1``), создавая объект результата ``2``, "
"но когда мы пытаемся присвоить результат вычисления ``2`` элементу ``0`` "
"кортежа, мы получаем ошибку, поскольку не можем изменить то, на что "
"указывает элемент кортежа."

#: ../../faq/programming.rst:1370
msgid ""
"Under the covers, what this augmented assignment statement is doing is "
"approximately this::"
msgstr ""
"На самом деле этот оператор расширенного присваивания делает примерно "
"следующее:"

#: ../../faq/programming.rst:1379
msgid ""
"It is the assignment part of the operation that produces the error, since a "
"tuple is immutable."
msgstr ""
"Ошибку вызывает часть операции присваивания, поскольку кортеж является "
"неизменяемым."

#: ../../faq/programming.rst:1382
msgid "When you write something like::"
msgstr "Когда вы пишете что-то вроде::"

#: ../../faq/programming.rst:1390
msgid ""
"The exception is a bit more surprising, and even more surprising is the fact "
"that even though there was an error, the append worked::"
msgstr ""
"Исключение немного более удивительно, и еще более удивительным является тот "
"факт, что, несмотря на ошибку, добавление сработало::"

#: ../../faq/programming.rst:1396
msgid ""
"To see why this happens, you need to know that (a) if an object implements "
"an :meth:`~object.__iadd__` magic method, it gets called when the ``+=`` "
"augmented assignment is executed, and its return value is what gets used in "
"the assignment statement; and (b) for lists, :meth:`!__iadd__` is equivalent "
"to calling :meth:`!extend` on the list and returning the list.  That's why "
"we say that for lists, ``+=`` is a \"shorthand\" for :meth:`!list.extend`::"
msgstr ""
"Чтобы понять, почему это происходит, вам нужно знать, что (а) если объект "
"реализует магический метод :meth:`~object.__iadd__`, он вызывается, когда "
"выполняется расширенное присваивание ``+=``, и его возврат значение — это "
"то, что используется в операторе присваивания; и (b) для списков :meth:`!"
"__iadd__` эквивалентен вызову :meth:`!extend` для списка и возврату списка. "
"Вот почему мы говорим, что для списков ``+=`` является \"сокращением\" для :"
"meth:`!list.extend`::"

#: ../../faq/programming.rst:1409
msgid "This is equivalent to::"
msgstr "Это эквивалентно::"

#: ../../faq/programming.rst:1414
msgid ""
"The object pointed to by a_list has been mutated, and the pointer to the "
"mutated object is assigned back to ``a_list``.  The end result of the "
"assignment is a no-op, since it is a pointer to the same object that "
"``a_list`` was previously pointing to, but the assignment still happens."
msgstr ""
"Объект, на который указывает a_list, был изменен, и указатель на "
"мутировавший объект присваивается обратно a_list. Конечным результатом "
"присваивания является отсутствие операции, поскольку это указатель на тот же "
"объект, на который ранее указывал ``a_list``, но присваивание все равно "
"происходит."

#: ../../faq/programming.rst:1419
msgid "Thus, in our tuple example what is happening is equivalent to::"
msgstr "Таким образом, в нашем примере с кортежем происходящее эквивалентно:"

#: ../../faq/programming.rst:1427
msgid ""
"The :meth:`!__iadd__` succeeds, and thus the list is extended, but even "
"though ``result`` points to the same object that ``a_tuple[0]`` already "
"points to, that final assignment still results in an error, because tuples "
"are immutable."
msgstr ""
":meth:`!__iadd__` завершается успешно, и, таким образом, список расширяется, "
"но даже если ``result`` указывает на тот же объект, на который уже указывает "
"``a_tuple[0]``, это окончательное присвоение все равно приводит к ошибка, "
"поскольку кортежи неизменяемы."

#: ../../faq/programming.rst:1433
msgid ""
"I want to do a complicated sort: can you do a Schwartzian Transform in "
"Python?"
msgstr ""
"Я хочу сделать сложный вопрос: можете ли вы выполнить преобразование Шварца "
"в Python?"

#: ../../faq/programming.rst:1435
msgid ""
"The technique, attributed to Randal Schwartz of the Perl community, sorts "
"the elements of a list by a metric which maps each element to its \"sort "
"value\". In Python, use the ``key`` argument for the :meth:`list.sort` "
"method::"
msgstr ""
"Этот метод, приписываемый Рэндалу Шварцу из сообщества Perl, сортирует "
"элементы списка по метрике, которая сопоставляет каждый элемент с его "
"«значением сортировки». В Python используйте аргумент ``key`` для метода :"
"meth:`list.sort`::"

#: ../../faq/programming.rst:1444
msgid "How can I sort one list by values from another list?"
msgstr "Как я могу отсортировать один список по значениям из другого списка?"

#: ../../faq/programming.rst:1446
msgid ""
"Merge them into an iterator of tuples, sort the resulting list, and then "
"pick out the element you want. ::"
msgstr ""
"Объедините их в итератор кортежей, отсортируйте полученный список, а затем "
"выберите нужный элемент. ::"

#: ../../faq/programming.rst:1461
msgid "Objects"
msgstr "Объекты"

#: ../../faq/programming.rst:1464
msgid "What is a class?"
msgstr "Что такое класс?"

#: ../../faq/programming.rst:1466
msgid ""
"A class is the particular object type created by executing a class "
"statement. Class objects are used as templates to create instance objects, "
"which embody both the data (attributes) and code (methods) specific to a "
"datatype."
msgstr ""
"Класс — это конкретный тип объекта, созданный путем выполнения оператора "
"класса. Объекты классов используются в качестве шаблонов для создания "
"объектов экземпляров, которые воплощают в себе как данные (атрибуты), так и "
"код (методы), специфичные для типа данных."

#: ../../faq/programming.rst:1470
msgid ""
"A class can be based on one or more other classes, called its base "
"class(es). It then inherits the attributes and methods of its base classes. "
"This allows an object model to be successively refined by inheritance.  You "
"might have a generic ``Mailbox`` class that provides basic accessor methods "
"for a mailbox, and subclasses such as ``MboxMailbox``, ``MaildirMailbox``, "
"``OutlookMailbox`` that handle various specific mailbox formats."
msgstr ""
"Класс может быть основан на одном или нескольких других классах, называемых "
"базовыми классами. Затем он наследует атрибуты и методы своих базовых "
"классов. Это позволяет последовательно уточнять объектную модель путем "
"наследования. У вас может быть общий класс Mailbox, который предоставляет "
"базовые методы доступа к почтовому ящику, а также подклассы, такие как "
"MboxMailbox, MaildirMailbox, OutlookMailbox, которые обрабатывают различные "
"конкретные форматы почтовых ящиков."

#: ../../faq/programming.rst:1479
msgid "What is a method?"
msgstr "Что такое метод?"

#: ../../faq/programming.rst:1481
msgid ""
"A method is a function on some object ``x`` that you normally call as ``x."
"name(arguments...)``.  Methods are defined as functions inside the class "
"definition::"
msgstr ""
"Метод — это функция некоторого объекта ``x``, который вы обычно вызываете "
"как ``x.name(arguments...)``. Методы определяются как функции внутри "
"определения класса::"

#: ../../faq/programming.rst:1491
msgid "What is self?"
msgstr "Что такое сам?"

#: ../../faq/programming.rst:1493
msgid ""
"Self is merely a conventional name for the first argument of a method.  A "
"method defined as ``meth(self, a, b, c)`` should be called as ``x.meth(a, b, "
"c)`` for some instance ``x`` of the class in which the definition occurs; "
"the called method will think it is called as ``meth(x, a, b, c)``."
msgstr ""
"Self — это просто условное имя для первого аргумента метода. Метод, "
"определенный как ``meth(self, a, b, c)``, должен вызываться как ``x.meth(a, "
"b, c)`` для некоторого экземпляра ``x`` класса, в котором происходит "
"определение; вызываемый метод будет думать, что он вызван как ``meth(x, a, "
"b, c)``."

#: ../../faq/programming.rst:1498
msgid "See also :ref:`why-self`."
msgstr "См. также :ref:`why-self`."

#: ../../faq/programming.rst:1502
msgid ""
"How do I check if an object is an instance of a given class or of a subclass "
"of it?"
msgstr ""
"Как проверить, является ли объект экземпляром данного класса или его "
"подкласса?"

#: ../../faq/programming.rst:1504
msgid ""
"Use the built-in function :func:`isinstance(obj, cls) <isinstance>`.  You "
"can check if an object is an instance of any of a number of classes by "
"providing a tuple instead of a single class, e.g. ``isinstance(obj, (class1, "
"class2, ...))``, and can also check whether an object is one of Python's "
"built-in types, e.g. ``isinstance(obj, str)`` or ``isinstance(obj, (int, "
"float, complex))``."
msgstr ""
"Используйте встроенную функцию :func:`isinstance(obj, cls) <isinstance>`. Вы "
"можете проверить, является ли объект экземпляром любого из нескольких "
"классов, предоставив кортеж вместо одного класса, например, "
"``isinstance(obj, (class1, class2, ...))``, а также можете проверить "
"является ли объект одним из встроенных типов Python, например "
"``isinstance(obj, str)`` или ``isinstance(obj, (int, float, complex))``."

#: ../../faq/programming.rst:1511
msgid ""
"Note that :func:`isinstance` also checks for virtual inheritance from an :"
"term:`abstract base class`.  So, the test will return ``True`` for a "
"registered class even if hasn't directly or indirectly inherited from it.  "
"To test for \"true inheritance\", scan the :term:`MRO` of the class:"
msgstr ""
"Обратите внимание, что :func:`isinstance` также проверяет виртуальное "
"наследование от :term:`абстрактного базового класса`. Таким образом, тест "
"вернет «True» для зарегистрированного класса, даже если он прямо или "
"косвенно не унаследован от него. Чтобы проверить «истинное наследование», "
"отсканируйте :term:`MRO` класса:"

#: ../../faq/programming.rst:1546
msgid ""
"Note that most programs do not use :func:`isinstance` on user-defined "
"classes very often.  If you are developing the classes yourself, a more "
"proper object-oriented style is to define methods on the classes that "
"encapsulate a particular behaviour, instead of checking the object's class "
"and doing a different thing based on what class it is.  For example, if you "
"have a function that does something::"
msgstr ""
"Обратите внимание, что большинство программ не очень часто используют :func:"
"`isinstance` для пользовательских классов. Если вы разрабатываете классы "
"самостоятельно, более подходящим объектно-ориентированным стилем будет "
"определение в классах методов, которые инкапсулируют определенное поведение, "
"вместо того, чтобы проверять класс объекта и делать что-то другое в "
"зависимости от того, какой это класс. Например, если у вас есть функция, "
"которая что-то делает::"

#: ../../faq/programming.rst:1560
msgid ""
"A better approach is to define a ``search()`` method on all the classes and "
"just call it::"
msgstr ""
"Лучшим подходом будет определить метод search() для всех классов и просто "
"вызывать его:"

#: ../../faq/programming.rst:1575
msgid "What is delegation?"
msgstr "Что такое делегирование?"

#: ../../faq/programming.rst:1577
msgid ""
"Delegation is an object oriented technique (also called a design pattern). "
"Let's say you have an object ``x`` and want to change the behaviour of just "
"one of its methods.  You can create a new class that provides a new "
"implementation of the method you're interested in changing and delegates all "
"other methods to the corresponding method of ``x``."
msgstr ""
"Делегирование — это объектно-ориентированный метод (также называемый "
"шаблоном проектирования). Допустим, у вас есть объект «x» и вы хотите "
"изменить поведение только одного из его методов. Вы можете создать новый "
"класс, который предоставляет новую реализацию метода, который вы хотите "
"изменить, и делегирует все остальные методы соответствующему методу ``x``."

#: ../../faq/programming.rst:1583
msgid ""
"Python programmers can easily implement delegation.  For example, the "
"following class implements a class that behaves like a file but converts all "
"written data to uppercase::"
msgstr ""
"Программисты Python могут легко реализовать делегирование. Например, "
"следующий класс реализует класс, который ведет себя как файл, но преобразует "
"все записанные данные в верхний регистр:"

#: ../../faq/programming.rst:1598
msgid ""
"Here the ``UpperOut`` class redefines the ``write()`` method to convert the "
"argument string to uppercase before calling the underlying ``self._outfile."
"write()`` method.  All other methods are delegated to the underlying ``self."
"_outfile`` object.  The delegation is accomplished via the :meth:`~object."
"__getattr__` method; consult :ref:`the language reference <attribute-"
"access>` for more information about controlling attribute access."
msgstr ""
"Здесь класс UpperOut переопределяет метод write() для преобразования строки "
"аргумента в верхний регистр перед вызовом базового метода self._outfile."
"write(). Все остальные методы делегируются базовому объекту self._outfile. "
"Делегирование осуществляется с помощью метода :meth:`~object.__getattr__`; "
"обратитесь к :ref:`справочнику по языку <attribute-access>` для получения "
"дополнительной информации об управлении доступом к атрибутам."

#: ../../faq/programming.rst:1605
msgid ""
"Note that for more general cases delegation can get trickier. When "
"attributes must be set as well as retrieved, the class must define a :meth:"
"`~object.__setattr__` method too, and it must do so carefully.  The basic "
"implementation of :meth:`!__setattr__` is roughly equivalent to the "
"following::"
msgstr ""
"Обратите внимание, что в более общих случаях делегирование может оказаться "
"сложнее. Когда атрибуты должны быть установлены и получены, класс также "
"должен определить метод :meth:`~object.__setattr__`, и делать это следует "
"осторожно. Базовая реализация :meth:`!__setattr__` примерно эквивалентна "
"следующему:"

#: ../../faq/programming.rst:1616
msgid ""
"Most :meth:`!__setattr__` implementations must modify :meth:`self.__dict__ "
"<object.__dict__>` to store local state for self without causing an infinite "
"recursion."
msgstr ""

#: ../../faq/programming.rst:1622
msgid ""
"How do I call a method defined in a base class from a derived class that "
"extends it?"
msgstr ""
"Как вызвать метод, определенный в базовом классе, из производного класса, "
"который его расширяет?"

#: ../../faq/programming.rst:1624
msgid "Use the built-in :func:`super` function::"
msgstr "Используйте встроенную функцию :func:`super`::"

#: ../../faq/programming.rst:1630
msgid ""
"In the example, :func:`super` will automatically determine the instance from "
"which it was called (the ``self`` value), look up the :term:`method "
"resolution order` (MRO) with ``type(self).__mro__``, and return the next in "
"line after ``Derived`` in the MRO: ``Base``."
msgstr ""
"В примере :func:`super` автоматически определит экземпляр, из которого он "
"был вызван (значение ``self``), найдите :term:`порядок разрешения метода` "
"(MRO) с ``type(self`` ).__mro__`` и верните следующую строку после "
"``Derived`` в MRO: ``Base``."

#: ../../faq/programming.rst:1637
msgid "How can I organize my code to make it easier to change the base class?"
msgstr ""
"Как мне организовать свой код, чтобы упростить изменение базового класса?"

#: ../../faq/programming.rst:1639
msgid ""
"You could assign the base class to an alias and derive from the alias.  Then "
"all you have to change is the value assigned to the alias.  Incidentally, "
"this trick is also handy if you want to decide dynamically (e.g. depending "
"on availability of resources) which base class to use.  Example::"
msgstr ""
"Вы можете присвоить базовый класс псевдониму и получить производный класс от "
"этого псевдонима. Тогда все, что вам нужно изменить, — это значение, "
"присвоенное псевдониму. Кстати, этот трюк также удобен, если вы хотите "
"динамически (например, в зависимости от доступности ресурсов) решать, какой "
"базовый класс использовать. Пример::"

#: ../../faq/programming.rst:1654
msgid "How do I create static class data and static class methods?"
msgstr "Как создать данные статического класса и методы статического класса?"

#: ../../faq/programming.rst:1656
msgid ""
"Both static data and static methods (in the sense of C++ or Java) are "
"supported in Python."
msgstr ""
"В Python поддерживаются как статические данные, так и статические методы (в "
"смысле C++ или Java)."

#: ../../faq/programming.rst:1659
msgid ""
"For static data, simply define a class attribute.  To assign a new value to "
"the attribute, you have to explicitly use the class name in the assignment::"
msgstr ""
"Для статических данных просто определите атрибут класса. Чтобы присвоить "
"атрибуту новое значение, вам необходимо явно использовать имя класса в "
"присвоении::"

#: ../../faq/programming.rst:1671
msgid ""
"``c.count`` also refers to ``C.count`` for any ``c`` such that "
"``isinstance(c, C)`` holds, unless overridden by ``c`` itself or by some "
"class on the base-class search path from ``c.__class__`` back to ``C``."
msgstr ""
"``c.count`` также относится к ``C.count`` для любого ``c``, такого как "
"``isinstance(c, C)``, если только это не переопределено самим ``c`` или "
"каким-либо другим class на пути поиска базового класса от ``c.__class__`` "
"обратно к ``C``."

#: ../../faq/programming.rst:1675
msgid ""
"Caution: within a method of C, an assignment like ``self.count = 42`` "
"creates a new and unrelated instance named \"count\" in ``self``'s own "
"dict.  Rebinding of a class-static data name must always specify the class "
"whether inside a method or not::"
msgstr ""
"Внимание: внутри метода C присвоение типа self.count = 42 создает новый и "
"несвязанный экземпляр с именем «count» в собственном словаре self.count. При "
"повторной привязке статического имени данных класса всегда должен "
"указываться класс, независимо от того, находится ли он внутри метода или "
"нет::"

#: ../../faq/programming.rst:1682
msgid "Static methods are possible::"
msgstr "Возможны статические методы::"

#: ../../faq/programming.rst:1690
msgid ""
"However, a far more straightforward way to get the effect of a static method "
"is via a simple module-level function::"
msgstr ""
"Однако гораздо более простой способ получить эффект статического метода — "
"использовать простую функцию уровня модуля:"

#: ../../faq/programming.rst:1696
msgid ""
"If your code is structured so as to define one class (or tightly related "
"class hierarchy) per module, this supplies the desired encapsulation."
msgstr ""
"Если ваш код структурирован так, что для каждого модуля определяется один "
"класс (или тесно связанная иерархия классов), это обеспечивает желаемую "
"инкапсуляцию."

#: ../../faq/programming.rst:1701
msgid "How can I overload constructors (or methods) in Python?"
msgstr "Как я могу перегрузить конструкторы (или методы) в Python?"

#: ../../faq/programming.rst:1703
msgid ""
"This answer actually applies to all methods, but the question usually comes "
"up first in the context of constructors."
msgstr ""
"Этот ответ на самом деле применим ко всем методам, но этот вопрос обычно "
"возникает первым в контексте конструкторов."

#: ../../faq/programming.rst:1706
msgid "In C++ you'd write"
msgstr "На C++ вы бы написали"

#: ../../faq/programming.rst:1715
msgid ""
"In Python you have to write a single constructor that catches all cases "
"using default arguments.  For example::"
msgstr ""
"В Python вам нужно написать один конструктор, который перехватывает все "
"случаи, используя аргументы по умолчанию. Например::"

#: ../../faq/programming.rst:1725
msgid "This is not entirely equivalent, but close enough in practice."
msgstr "Это не совсем эквивалентно, но достаточно близко на практике."

#: ../../faq/programming.rst:1727
msgid "You could also try a variable-length argument list, e.g. ::"
msgstr ""
"Вы также можете попробовать список аргументов переменной длины, например:::"

#: ../../faq/programming.rst:1732
msgid "The same approach works for all method definitions."
msgstr "Тот же подход работает для всех определений методов."

#: ../../faq/programming.rst:1736
msgid "I try to use __spam and I get an error about _SomeClassName__spam."
msgstr ""
"Я пытаюсь использовать __spam и получаю сообщение об ошибке "
"_SomeClassName__spam."

#: ../../faq/programming.rst:1738
msgid ""
"Variable names with double leading underscores are \"mangled\" to provide a "
"simple but effective way to define class private variables.  Any identifier "
"of the form ``__spam`` (at least two leading underscores, at most one "
"trailing underscore) is textually replaced with ``_classname__spam``, where "
"``classname`` is the current class name with any leading underscores "
"stripped."
msgstr ""
"Имена переменных с двойным подчеркиванием «искажаются», чтобы обеспечить "
"простой, но эффективный способ определения частных переменных класса. Любой "
"идентификатор в форме ``__spam`` (минимум два начальных подчеркивания, "
"максимум одно завершающее подчеркивание) текстуально заменяется на "
"``_classname__spam``, где ``classname`` — это текущее имя класса с "
"удаленными ведущими подчеркиваниями."

#: ../../faq/programming.rst:1744
msgid ""
"This doesn't guarantee privacy: an outside user can still deliberately "
"access the \"_classname__spam\" attribute, and private values are visible in "
"the object's ``__dict__``.  Many Python programmers never bother to use "
"private variable names at all."
msgstr ""

#: ../../faq/programming.rst:1751
msgid "My class defines __del__ but it is not called when I delete the object."
msgstr ""
"My class defines __del__ but it is not called when I delete the object."

#: ../../faq/programming.rst:1753
msgid "There are several possible reasons for this."
msgstr "Для этого есть несколько возможных причин."

#: ../../faq/programming.rst:1755
msgid ""
"The :keyword:`del` statement does not necessarily call :meth:`~object."
"__del__` -- it simply decrements the object's reference count, and if this "
"reaches zero :meth:`!__del__` is called."
msgstr ""
"Оператор :keyword:`del` не обязательно вызывает :meth:`~object.__del__` — он "
"просто уменьшает счетчик ссылок на объект, и если он достигает нуля, "
"вызывается :meth:`!__del__`."

#: ../../faq/programming.rst:1759
msgid ""
"If your data structures contain circular links (e.g. a tree where each child "
"has a parent reference and each parent has a list of children) the reference "
"counts will never go back to zero.  Once in a while Python runs an algorithm "
"to detect such cycles, but the garbage collector might run some time after "
"the last reference to your data structure vanishes, so your :meth:`!__del__` "
"method may be called at an inconvenient and random time. This is "
"inconvenient if you're trying to reproduce a problem. Worse, the order in "
"which object's :meth:`!__del__` methods are executed is arbitrary.  You can "
"run :func:`gc.collect` to force a collection, but there *are* pathological "
"cases where objects will never be collected."
msgstr ""
"Если ваши структуры данных содержат циклические ссылки (например, дерево, "
"где каждый дочерний элемент имеет родительскую ссылку, а каждый родительский "
"элемент имеет список дочерних элементов), счетчик ссылок никогда не вернется "
"к нулю. Время от времени Python запускает алгоритм для обнаружения таких "
"циклов, но сборщик мусора может запуститься через некоторое время после "
"исчезновения последней ссылки на вашу структуру данных, поэтому ваш метод :"
"meth:`!__del__` может быть вызван в неудобное и случайное время. . Это "
"неудобно, если вы пытаетесь воспроизвести проблему. Хуже того, порядок "
"выполнения методов объекта :meth:`!__del__` является произвольным. Вы можете "
"запустить :func:`gc.collect` для принудительной сборки, но *существуют* "
"патологические случаи, когда объекты никогда не будут собраны."

#: ../../faq/programming.rst:1770
msgid ""
"Despite the cycle collector, it's still a good idea to define an explicit "
"``close()`` method on objects to be called whenever you're done with them.  "
"The ``close()`` method can then remove attributes that refer to subobjects.  "
"Don't call :meth:`!__del__` directly -- :meth:`!__del__` should call "
"``close()`` and ``close()`` should make sure that it can be called more than "
"once for the same object."
msgstr ""
"Несмотря на сборщик циклов, по-прежнему хорошей идеей будет определить явный "
"метод close() для объектов, который будет вызываться всякий раз, когда вы с "
"ними закончите. Затем метод close() может удалить атрибуты, которые "
"ссылаются на подобъекты. Не вызывайте :meth:`!__del__` напрямую - :meth:`!"
"__del__` должен вызывать `` close()``, а `` close()`` должен быть уверен, "
"что его можно вызвать более одного раза для тот же объект."

#: ../../faq/programming.rst:1777
msgid ""
"Another way to avoid cyclical references is to use the :mod:`weakref` "
"module, which allows you to point to objects without incrementing their "
"reference count. Tree data structures, for instance, should use weak "
"references for their parent and sibling references (if they need them!)."
msgstr ""
"Другой способ избежать циклических ссылок — использовать модуль :mod:"
"`weakref`, который позволяет вам указывать на объекты, не увеличивая их "
"счетчик ссылок. Например, древовидные структуры данных должны использовать "
"слабые ссылки для своих родительских и одноуровневых ссылок (если они им "
"нужны!)."

#: ../../faq/programming.rst:1790
msgid ""
"Finally, if your :meth:`!__del__` method raises an exception, a warning "
"message is printed to :data:`sys.stderr`."
msgstr ""
"Наконец, если ваш метод :meth:`!__del__` вызывает исключение, в :data:`sys."
"stderr` выводится предупреждающее сообщение."

#: ../../faq/programming.rst:1795
msgid "How do I get a list of all instances of a given class?"
msgstr "Как получить список всех экземпляров данного класса?"

#: ../../faq/programming.rst:1797
msgid ""
"Python does not keep track of all instances of a class (or of a built-in "
"type). You can program the class's constructor to keep track of all "
"instances by keeping a list of weak references to each instance."
msgstr ""
"Python не отслеживает все экземпляры класса (или встроенного типа). Вы "
"можете запрограммировать конструктор класса так, чтобы он отслеживал все "
"экземпляры, сохраняя список слабых ссылок на каждый экземпляр."

#: ../../faq/programming.rst:1803
msgid "Why does the result of ``id()`` appear to be not unique?"
msgstr "Почему результат ``id()`` не уникален?"

#: ../../faq/programming.rst:1805
msgid ""
"The :func:`id` builtin returns an integer that is guaranteed to be unique "
"during the lifetime of the object.  Since in CPython, this is the object's "
"memory address, it happens frequently that after an object is deleted from "
"memory, the next freshly created object is allocated at the same position in "
"memory.  This is illustrated by this example:"
msgstr ""
"Встроенная функция :func:`id` возвращает целое число, которое гарантированно "
"будет уникальным в течение всего времени существования объекта. Поскольку в "
"CPython это адрес памяти объекта, часто случается, что после удаления "
"объекта из памяти следующий вновь созданный объект выделяется в той же "
"позиции в памяти. Это иллюстрируется этим примером:"

#: ../../faq/programming.rst:1816
msgid ""
"The two ids belong to different integer objects that are created before, and "
"deleted immediately after execution of the ``id()`` call.  To be sure that "
"objects whose id you want to examine are still alive, create another "
"reference to the object:"
msgstr ""
"Два идентификатора принадлежат разным целочисленным объектам, которые были "
"созданы ранее и удалены сразу после выполнения вызова id(). Чтобы быть "
"уверенным, что объекты, идентификаторы которых вы хотите проверить, все еще "
"живы, создайте еще одну ссылку на объект:"

#: ../../faq/programming.rst:1829
msgid "When can I rely on identity tests with the *is* operator?"
msgstr "Когда я могу полагаться на проверку идентичности с оператором *is*?"

#: ../../faq/programming.rst:1831
msgid ""
"The ``is`` operator tests for object identity.  The test ``a is b`` is "
"equivalent to ``id(a) == id(b)``."
msgstr ""
"Оператор ``is`` проверяет идентичность объекта. Тест ``a is b`` эквивалентен "
"``id(a) == id(b)``."

#: ../../faq/programming.rst:1834
msgid ""
"The most important property of an identity test is that an object is always "
"identical to itself, ``a is a`` always returns ``True``.  Identity tests are "
"usually faster than equality tests.  And unlike equality tests, identity "
"tests are guaranteed to return a boolean ``True`` or ``False``."
msgstr ""
"Самым важным свойством проверки идентичности является то, что объект всегда "
"идентичен самому себе, ``a is a`` всегда возвращает ``True``. Тесты на "
"идентичность обычно выполняются быстрее, чем тесты на равенство. И в отличие "
"от тестов на равенство, тесты на идентичность гарантированно возвращают "
"логическое значение «True» или «False»."

#: ../../faq/programming.rst:1839
msgid ""
"However, identity tests can *only* be substituted for equality tests when "
"object identity is assured.  Generally, there are three circumstances where "
"identity is guaranteed:"
msgstr ""
"Однако тесты на идентичность могут *только* быть заменены тестами на "
"равенство, если идентичность объекта гарантирована. Как правило, существуют "
"три обстоятельства, при которых идентичность гарантируется:"

#: ../../faq/programming.rst:1843
msgid ""
"1) Assignments create new names but do not change object identity.  After "
"the assignment ``new = old``, it is guaranteed that ``new is old``."
msgstr ""
"1) Присвоения создают новые имена, но не меняют идентичность объекта. После "
"присваивания ``new = old`` гарантируется, что ``новое есть старое``."

#: ../../faq/programming.rst:1846
msgid ""
"2) Putting an object in a container that stores object references does not "
"change object identity.  After the list assignment ``s[0] = x``, it is "
"guaranteed that ``s[0] is x``."
msgstr ""
"2) Помещение объекта в контейнер, в котором хранятся ссылки на объекты, не "
"меняет идентичность объекта. После присвоения списка ``s[0] = x`` "
"гарантируется, что ``s[0] равен x``."

#: ../../faq/programming.rst:1850
msgid ""
"3) If an object is a singleton, it means that only one instance of that "
"object can exist.  After the assignments ``a = None`` and ``b = None``, it "
"is guaranteed that ``a is b`` because ``None`` is a singleton."
msgstr ""
"3) Если объект является синглтоном, это означает, что может существовать "
"только один экземпляр этого объекта. После присвоений ``a = None`` и ``b = "
"None`` гарантируется, что ``a равно b``, поскольку ``None`` является "
"одноэлементным."

#: ../../faq/programming.rst:1854
msgid ""
"In most other circumstances, identity tests are inadvisable and equality "
"tests are preferred.  In particular, identity tests should not be used to "
"check constants such as :class:`int` and :class:`str` which aren't "
"guaranteed to be singletons::"
msgstr ""
"В большинстве других случаев тесты на идентичность нежелательны, а тесты на "
"равенство предпочтительнее. В частности, тесты идентичности не следует "
"использовать для проверки таких констант, как :class:`int` и :class:`str`, "
"которые не обязательно являются одиночными::"

#: ../../faq/programming.rst:1871
msgid "Likewise, new instances of mutable containers are never identical::"
msgstr ""
"Аналогично, новые экземпляры изменяемых контейнеров никогда не бывают "
"идентичными:"

#: ../../faq/programming.rst:1878
msgid ""
"In the standard library code, you will see several common patterns for "
"correctly using identity tests:"
msgstr ""
"В коде стандартной библиотеки вы увидите несколько распространенных шаблонов "
"правильного использования тестов идентичности:"

#: ../../faq/programming.rst:1881
msgid ""
"1) As recommended by :pep:`8`, an identity test is the preferred way to "
"check for ``None``.  This reads like plain English in code and avoids "
"confusion with other objects that may have boolean values that evaluate to "
"false."
msgstr ""
"1) Как рекомендует :pep:`8`, проверка личности является предпочтительным "
"способом проверки отсутствия ``Нет``. В коде это читается как обычный "
"английский и позволяет избежать путаницы с другими объектами, которые могут "
"иметь логические значения, которые оцениваются как ложные."

#: ../../faq/programming.rst:1885
msgid ""
"2) Detecting optional arguments can be tricky when ``None`` is a valid input "
"value.  In those situations, you can create a singleton sentinel object "
"guaranteed to be distinct from other objects.  For example, here is how to "
"implement a method that behaves like :meth:`dict.pop`::"
msgstr ""
"2) Обнаружение необязательных аргументов может оказаться затруднительным, "
"если None является допустимым входным значением. В таких ситуациях вы можете "
"создать одноэлементный сторожевой объект, который гарантированно будет "
"отличаться от других объектов. Например, вот как реализовать метод, который "
"ведет себя как :meth:`dict.pop`::"

#: ../../faq/programming.rst:1901
msgid ""
"3) Container implementations sometimes need to augment equality tests with "
"identity tests.  This prevents the code from being confused by objects such "
"as ``float('NaN')`` that are not equal to themselves."
msgstr ""
"3) Реализации контейнеров иногда требуют дополнения тестов на равенство "
"тестами на идентичность. Это предотвращает путаницу в коде из-за объектов, "
"таких как ``float('NaN')``, которые не равны сами себе."

#: ../../faq/programming.rst:1905
msgid ""
"For example, here is the implementation of :meth:`!collections.abc.Sequence."
"__contains__`::"
msgstr ""
"Например, вот реализация :meth:`!collections.abc.Sequence.__contains__`::"

#: ../../faq/programming.rst:1916
msgid ""
"How can a subclass control what data is stored in an immutable instance?"
msgstr ""
"Как подкласс может контролировать, какие данные хранятся в неизменяемом "
"экземпляре?"

#: ../../faq/programming.rst:1918
msgid ""
"When subclassing an immutable type, override the :meth:`~object.__new__` "
"method instead of the :meth:`~object.__init__` method.  The latter only runs "
"*after* an instance is created, which is too late to alter data in an "
"immutable instance."
msgstr ""
"При создании подкласса неизменяемого типа переопределите метод :meth:"
"`~object.__new__` вместо метода :meth:`~object.__init__`. Последний "
"запускается только *после* создания экземпляра, что уже слишком поздно для "
"изменения данных в неизменяемом экземпляре."

#: ../../faq/programming.rst:1923
msgid ""
"All of these immutable classes have a different signature than their parent "
"class:"
msgstr ""
"Все эти неизменяемые классы имеют подпись, отличную от их родительского "
"класса:"

#: ../../faq/programming.rst:1949
msgid "The classes can be used like this:"
msgstr "Классы можно использовать следующим образом:"

#: ../../faq/programming.rst:1966
msgid "How do I cache method calls?"
msgstr "Как кэшировать вызовы методов?"

#: ../../faq/programming.rst:1968
msgid ""
"The two principal tools for caching methods are :func:`functools."
"cached_property` and :func:`functools.lru_cache`.  The former stores results "
"at the instance level and the latter at the class level."
msgstr ""
"Двумя основными инструментами для кэширования методов являются :func:"
"`functools.cached_property` и :func:`functools.lru_cache`. Первый хранит "
"результаты на уровне экземпляра, а второй — на уровне класса."

#: ../../faq/programming.rst:1973
msgid ""
"The *cached_property* approach only works with methods that do not take any "
"arguments.  It does not create a reference to the instance.  The cached "
"method result will be kept only as long as the instance is alive."
msgstr ""
"Подход *cached_property* работает только с методами, которые не принимают "
"никаких аргументов. Он не создает ссылку на экземпляр. Результат "
"кэшированного метода будет храниться только до тех пор, пока экземпляр жив."

#: ../../faq/programming.rst:1977
msgid ""
"The advantage is that when an instance is no longer used, the cached method "
"result will be released right away.  The disadvantage is that if instances "
"accumulate, so too will the accumulated method results.  They can grow "
"without bound."
msgstr ""
"Преимущество состоит в том, что, когда экземпляр больше не используется, "
"результат кэшированного метода будет немедленно выпущен. Недостаток "
"заключается в том, что если экземпляры накапливаются, то же самое происходит "
"и с накопленными результатами метода. Они могут расти без ограничений."

#: ../../faq/programming.rst:1982
msgid ""
"The *lru_cache* approach works with methods that have :term:`hashable` "
"arguments.  It creates a reference to the instance unless special efforts "
"are made to pass in weak references."
msgstr ""
"Подход *lru_cache* работает с методами, имеющими :term:`hashable` аргументы. "
"Он создает ссылку на экземпляр, если не прилагаются особые усилия для "
"передачи слабых ссылок."

#: ../../faq/programming.rst:1986
msgid ""
"The advantage of the least recently used algorithm is that the cache is "
"bounded by the specified *maxsize*.  The disadvantage is that instances are "
"kept alive until they age out of the cache or until the cache is cleared."
msgstr ""
"Преимущество наименее используемого алгоритма заключается в том, что кэш "
"ограничен указанным *maxsize*. Недостаток заключается в том, что экземпляры "
"сохраняются до тех пор, пока они не устареют из кеша или пока кеш не будет "
"очищен."

#: ../../faq/programming.rst:1991
msgid "This example shows the various techniques::"
msgstr "В этом примере показаны различные методы:"

#: ../../faq/programming.rst:2015
msgid ""
"The above example assumes that the *station_id* never changes.  If the "
"relevant instance attributes are mutable, the *cached_property* approach "
"can't be made to work because it cannot detect changes to the attributes."
msgstr ""
"В приведенном выше примере предполагается, что *station_id* никогда не "
"меняется. Если соответствующие атрибуты экземпляра изменяемы, подход "
"*cached_property* не может работать, поскольку он не может обнаружить "
"изменения в атрибутах."

#: ../../faq/programming.rst:2020
msgid ""
"To make the *lru_cache* approach work when the *station_id* is mutable, the "
"class needs to define the :meth:`~object.__eq__` and :meth:`~object."
"__hash__` methods so that the cache can detect relevant attribute updates::"
msgstr ""
"Чтобы подход *lru_cache* работал, когда *station_id* является изменяемым, "
"классу необходимо определить методы :meth:`~object.__eq__` и :meth:`~object."
"__hash__`, чтобы кеш мог обнаруживать соответствующий атрибут. обновления::"

#: ../../faq/programming.rst:2046
msgid "Modules"
msgstr "Модули"

#: ../../faq/programming.rst:2049
msgid "How do I create a .pyc file?"
msgstr "Как создать файл .pyc?"

#: ../../faq/programming.rst:2051
msgid ""
"When a module is imported for the first time (or when the source file has "
"changed since the current compiled file was created) a ``.pyc`` file "
"containing the compiled code should be created in a ``__pycache__`` "
"subdirectory of the directory containing the ``.py`` file.  The ``.pyc`` "
"file will have a filename that starts with the same name as the ``.py`` "
"file, and ends with ``.pyc``, with a middle component that depends on the "
"particular ``python`` binary that created it.  (See :pep:`3147` for details.)"
msgstr ""
"Когда модуль импортируется в первый раз (или когда исходный файл изменился с "
"момента создания текущего скомпилированного файла), файл ``.pyc``, "
"содержащий скомпилированный код, должен быть создан в подкаталоге "
"``__pycache__`` каталог, содержащий файл ``.py``. Файл ``.pyc`` будет иметь "
"имя, которое начинается с того же имени, что и файл ``.py``, и заканчивается "
"на ``.pyc``, со средним компонентом, который зависит от конкретного "
"``python``. `` Бинарный файл, который его создал. (Подробности см. в :pep:"
"`3147`.)"

#: ../../faq/programming.rst:2059
msgid ""
"One reason that a ``.pyc`` file may not be created is a permissions problem "
"with the directory containing the source file, meaning that the "
"``__pycache__`` subdirectory cannot be created. This can happen, for "
"example, if you develop as one user but run as another, such as if you are "
"testing with a web server."
msgstr ""
"Одной из причин того, что файл ``.pyc`` не может быть создан, является "
"проблема с правами доступа к каталогу, содержащему исходный файл, что "
"означает, что подкаталог ``__pycache__`` не может быть создан. Это может "
"произойти, например, если вы разрабатываете как один пользователь, а "
"работаете как другой, например, если вы тестируете с помощью веб-сервера."

#: ../../faq/programming.rst:2064
msgid ""
"Unless the :envvar:`PYTHONDONTWRITEBYTECODE` environment variable is set, "
"creation of a .pyc file is automatic if you're importing a module and Python "
"has the ability (permissions, free space, etc...) to create a "
"``__pycache__`` subdirectory and write the compiled module to that "
"subdirectory."
msgstr ""
"Если не установлена ​​переменная среды :envvar:`PYTHONDONTWRITEBYTECODE`, "
"создание файла .pyc происходит автоматически, если вы импортируете модуль и "
"Python имеет возможность (разрешения, свободное пространство и т. д.) "
"создать ``__pycache__ `` подкаталог и запишите скомпилированный модуль в "
"этот подкаталог."

#: ../../faq/programming.rst:2069
msgid ""
"Running Python on a top level script is not considered an import and no ``."
"pyc`` will be created.  For example, if you have a top-level module ``foo."
"py`` that imports another module ``xyz.py``, when you run ``foo`` (by typing "
"``python foo.py`` as a shell command), a ``.pyc`` will be created for "
"``xyz`` because ``xyz`` is imported, but no ``.pyc`` file will be created "
"for ``foo`` since ``foo.py`` isn't being imported."
msgstr ""
"Запуск Python в сценарии верхнего уровня не считается импортом, и никакой ``."
"pyc`` не будет создан. Например, если у вас есть модуль верхнего уровня "
"``foo.py``, который импортирует другой модуль ``xyz.py``, когда вы "
"запускаете ``foo`` (набрав ``python foo.py`` как команду оболочки), файл ``."
"pyc`` будет создан для ``xyz``, поскольку ``xyz`` импортирован, но файл ``."
"pyc`` не будет создан для ``foo``, поскольку `` `foo.py`` не импортируется."

#: ../../faq/programming.rst:2076
msgid ""
"If you need to create a ``.pyc`` file for ``foo`` -- that is, to create a ``."
"pyc`` file for a module that is not imported -- you can, using the :mod:"
"`py_compile` and :mod:`compileall` modules."
msgstr ""
"Если вам нужно создать файл ``.pyc`` для ``foo``, то есть создать файл ``."
"pyc`` для модуля, который не импортируется, вы можете это сделать, "
"используя :mod Модули :`py_compile` и :mod:`compileall`."

#: ../../faq/programming.rst:2080
msgid ""
"The :mod:`py_compile` module can manually compile any module.  One way is to "
"use the ``compile()`` function in that module interactively::"
msgstr ""
"Модуль :mod:`py_compile` может вручную скомпилировать любой модуль. Один из "
"способов — интерактивное использование функции ``compile()`` в этом модуле:"

#: ../../faq/programming.rst:2086
msgid ""
"This will write the ``.pyc`` to a ``__pycache__`` subdirectory in the same "
"location as ``foo.py`` (or you can override that with the optional parameter "
"``cfile``)."
msgstr ""
"Это запишет ``.pyc`` в подкаталог ``__pycache__`` в том же месте, что и "
"``foo.py`` (или вы можете переопределить это с помощью необязательного "
"параметра ``cfile``)."

#: ../../faq/programming.rst:2090
msgid ""
"You can also automatically compile all files in a directory or directories "
"using the :mod:`compileall` module.  You can do it from the shell prompt by "
"running ``compileall.py`` and providing the path of a directory containing "
"Python files to compile::"
msgstr ""
"Вы также можете автоматически скомпилировать все файлы в каталоге или "
"каталогах, используя модуль :mod:`compileall`. Вы можете сделать это из "
"командной строки, запустив ``compileall.py`` и указав путь к каталогу, "
"содержащему файлы Python для компиляции:"

#: ../../faq/programming.rst:2099
msgid "How do I find the current module name?"
msgstr "Как узнать текущее имя модуля?"

#: ../../faq/programming.rst:2101
msgid ""
"A module can find out its own module name by looking at the predefined "
"global variable ``__name__``.  If this has the value ``'__main__'``, the "
"program is running as a script.  Many modules that are usually used by "
"importing them also provide a command-line interface or a self-test, and "
"only execute this code after checking ``__name__``::"
msgstr ""
"Модуль может узнать свое собственное имя, просмотрев предопределенную "
"глобальную переменную ``__name__``. Если здесь указано значение "
"``'__main__'``, программа запускается как сценарий. Многие модули, которые "
"обычно используются путем импорта, также предоставляют интерфейс командной "
"строки или функцию самотестирования и выполняют этот код только после "
"проверки ``__name__``::"

#: ../../faq/programming.rst:2116
msgid "How can I have modules that mutually import each other?"
msgstr "Как я могу иметь модули, которые взаимно импортируют друг друга?"

#: ../../faq/programming.rst:2118
msgid "Suppose you have the following modules:"
msgstr "Предположим, у вас есть следующие модули:"

#: ../../faq/programming.rst:2120
msgid ":file:`foo.py`::"
msgstr ":file:`foo.py`::"

#: ../../faq/programming.rst:2125
msgid ":file:`bar.py`::"
msgstr ":file:`bar.py`::"

#: ../../faq/programming.rst:2130
msgid "The problem is that the interpreter will perform the following steps:"
msgstr "Проблема в том, что интерпретатор выполнит следующие шаги:"

#: ../../faq/programming.rst:2132
msgid "main imports ``foo``"
msgstr "основной импорт ``foo``"

#: ../../faq/programming.rst:2133
msgid "Empty globals for ``foo`` are created"
msgstr "Создаются пустые глобальные переменные для ``foo``."

#: ../../faq/programming.rst:2134
msgid "``foo`` is compiled and starts executing"
msgstr "``foo`` компилируется и начинает выполняться"

#: ../../faq/programming.rst:2135
msgid "``foo`` imports ``bar``"
msgstr "``foo`` импортирует ``bar``"

#: ../../faq/programming.rst:2136
msgid "Empty globals for ``bar`` are created"
msgstr "Создаются пустые глобальные переменные для ``bar``."

#: ../../faq/programming.rst:2137
msgid "``bar`` is compiled and starts executing"
msgstr "``bar`` компилируется и начинает выполняться"

#: ../../faq/programming.rst:2138
msgid ""
"``bar`` imports ``foo`` (which is a no-op since there already is a module "
"named ``foo``)"
msgstr ""
"``bar`` импортирует ``foo`` (что не является операцией, поскольку уже "
"существует модуль с именем ``foo``)"

#: ../../faq/programming.rst:2139
msgid ""
"The import mechanism tries to read ``foo_var`` from ``foo`` globals, to set "
"``bar.foo_var = foo.foo_var``"
msgstr ""
"Механизм импорта пытается прочитать ``foo_var`` из глобальных переменных "
"``foo``, чтобы установить ``bar.foo_var = foo.foo_var``"

#: ../../faq/programming.rst:2141
msgid ""
"The last step fails, because Python isn't done with interpreting ``foo`` yet "
"and the global symbol dictionary for ``foo`` is still empty."
msgstr ""
"Последний шаг не удался, поскольку Python еще не завершил интерпретацию "
"``foo``, а глобальный словарь символов для ``foo`` все еще пуст."

#: ../../faq/programming.rst:2144
msgid ""
"The same thing happens when you use ``import foo``, and then try to access "
"``foo.foo_var`` in global code."
msgstr ""
"То же самое происходит, когда вы используете import foo, а затем пытаетесь "
"получить доступ к foo.foo_var в глобальном коде."

#: ../../faq/programming.rst:2147
msgid "There are (at least) three possible workarounds for this problem."
msgstr "Есть (по крайней мере) три возможных решения этой проблемы."

#: ../../faq/programming.rst:2149
msgid ""
"Guido van Rossum recommends avoiding all uses of ``from <module> import ..."
"``, and placing all code inside functions.  Initializations of global "
"variables and class variables should use constants or built-in functions "
"only.  This means everything from an imported module is referenced as "
"``<module>.<name>``."
msgstr ""
"Гвидо ван Россум рекомендует избегать любого использования ``from <module> "
"import...`` и размещать весь код внутри функций. При инициализации "
"глобальных переменных и переменных класса следует использовать только "
"константы или встроенные функции. Это означает, что все из импортированного "
"модуля упоминается как ``<модуль>.<имя>``."

#: ../../faq/programming.rst:2154
msgid ""
"Jim Roskind suggests performing steps in the following order in each module:"
msgstr ""
"Джим Роскинд предлагает выполнять шаги в следующем порядке в каждом модуле:"

#: ../../faq/programming.rst:2156
msgid ""
"exports (globals, functions, and classes that don't need imported base "
"classes)"
msgstr ""
"экспорт (глобальные переменные, функции и классы, которым не нужны "
"импортированные базовые классы)"

#: ../../faq/programming.rst:2158
msgid "``import`` statements"
msgstr "Инструкции по ``import``"

#: ../../faq/programming.rst:2159
msgid ""
"active code (including globals that are initialized from imported values)."
msgstr ""
"активный код (включая глобальные переменные, инициализируемые из "
"импортированных значений)."

#: ../../faq/programming.rst:2161
msgid ""
"Van Rossum doesn't like this approach much because the imports appear in a "
"strange place, but it does work."
msgstr ""
"Ван Россуму такой подход не очень нравится, потому что импорт появляется в "
"странном месте, но он работает."

#: ../../faq/programming.rst:2164
msgid ""
"Matthias Urlichs recommends restructuring your code so that the recursive "
"import is not necessary in the first place."
msgstr ""
"Маттиас Урлихс рекомендует реструктурировать ваш код так, чтобы в "
"рекурсивном импорте вообще не было необходимости."

#: ../../faq/programming.rst:2167
msgid "These solutions are not mutually exclusive."
msgstr "Эти решения не являются взаимоисключающими."

#: ../../faq/programming.rst:2171
msgid "__import__('x.y.z') returns <module 'x'>; how do I get z?"
msgstr "__import__('x.y.z') returns <module 'x'>; how do I get z?"

#: ../../faq/programming.rst:2173
msgid ""
"Consider using the convenience function :func:`~importlib.import_module` "
"from :mod:`importlib` instead::"
msgstr ""
"Рассмотрите возможность использования вместо этого удобной функции :func:"
"`~importlib.import_module` из :mod:`importlib`::"

#: ../../faq/programming.rst:2180
msgid ""
"When I edit an imported module and reimport it, the changes don't show up.  "
"Why does this happen?"
msgstr ""
"Когда я редактирую импортированный модуль и повторно импортирую его, "
"изменения не отображаются. Почему это происходит?"

#: ../../faq/programming.rst:2182
msgid ""
"For reasons of efficiency as well as consistency, Python only reads the "
"module file on the first time a module is imported.  If it didn't, in a "
"program consisting of many modules where each one imports the same basic "
"module, the basic module would be parsed and re-parsed many times.  To force "
"re-reading of a changed module, do this::"
msgstr ""
"По соображениям эффективности и согласованности Python читает файл модуля "
"только при первом импорте модуля. В противном случае в программе, состоящей "
"из множества модулей, каждый из которых импортирует один и тот же базовый "
"модуль, базовый модуль анализировался бы и анализировался повторно много "
"раз. Чтобы принудительно перечитать измененный модуль, сделайте следующее:"

#: ../../faq/programming.rst:2192
msgid ""
"Warning: this technique is not 100% fool-proof.  In particular, modules "
"containing statements like ::"
msgstr ""
"Предупреждение: этот метод не является на 100% надежным. В частности, "
"модули, содержащие такие операторы, как ::"

#: ../../faq/programming.rst:2197
msgid ""
"will continue to work with the old version of the imported objects.  If the "
"module contains class definitions, existing class instances will *not* be "
"updated to use the new class definition.  This can result in the following "
"paradoxical behaviour::"
msgstr ""
"продолжит работать со старой версией импортированных объектов. Если модуль "
"содержит определения классов, существующие экземпляры классов *не* будут "
"обновляться для использования нового определения класса. Это может привести "
"к следующему парадоксальному поведению:"

#: ../../faq/programming.rst:2210
msgid ""
"The nature of the problem is made clear if you print out the \"identity\" of "
"the class objects::"
msgstr ""
"Природа проблемы становится ясна, если вы распечатаете «идентичность» "
"объектов класса::"

#: ../../faq/programming.rst:408
msgid "argument"
msgstr "аргумент"

#: ../../faq/programming.rst:408
msgid "difference from parameter"
msgstr "отличие от параметра"

#: ../../faq/programming.rst:408
msgid "parameter"
msgstr "параметр"

#: ../../faq/programming.rst:408
msgid "difference from argument"
msgstr "отличие от аргумента"
