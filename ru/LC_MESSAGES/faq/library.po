# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-10 16:06+0000\n"
"PO-Revision-Date: 2022-11-05 17:21+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../faq/library.rst:5
msgid "Library and Extension FAQ"
msgstr "Часто задаваемые вопросы по библиотекам и расширениям"

#: ../../faq/library.rst:8
msgid "Contents"
msgstr " Содержание"

#: ../../faq/library.rst:12
msgid "General Library Questions"
msgstr "Общие вопросы по библиотеке"

#: ../../faq/library.rst:15
msgid "How do I find a module or application to perform task X?"
msgstr "Как мне найти модуль или приложение для выполнения задачи X?"

#: ../../faq/library.rst:17
msgid ""
"Check :ref:`the Library Reference <library-index>` to see if there's a "
"relevant standard library module.  (Eventually you'll learn what's in the "
"standard library and will be able to skip this step.)"
msgstr ""
"Проверьте :ref:`Справочник по библиотеке <library-index>`, чтобы узнать, "
"существует ли соответствующий стандартный библиотечный модуль. (Со временем "
"вы узнаете, что находится в стандартной библиотеке, и сможете пропустить "
"этот шаг.)"

#: ../../faq/library.rst:21
msgid ""
"For third-party packages, search the `Python Package Index <https://pypi."
"org>`_ or try `Google <https://www.google.com>`_ or another web search "
"engine.  Searching for \"Python\" plus a keyword or two for your topic of "
"interest will usually find something helpful."
msgstr ""
"Для пакетов сторонних производителей выполните поиск в `Python Package Index "
"<https://pypi.org>`_ или попробуйте `Google <https://www.google.com>`_ или "
"другую поисковую систему в Интернете. Поиск по слову «Python» плюс одно-два "
"ключевых слова по интересующей вас теме обычно оказываются полезными."

#: ../../faq/library.rst:28
msgid "Where is the math.py (socket.py, regex.py, etc.) source file?"
msgstr "Где находится исходный файл math.py (socket.py, regex.py и т. д.)?"

#: ../../faq/library.rst:30
msgid ""
"If you can't find a source file for a module it may be a built-in or "
"dynamically loaded module implemented in C, C++ or other compiled language. "
"In this case you may not have the source file or it may be something like :"
"file:`mathmodule.c`, somewhere in a C source directory (not on the Python "
"Path)."
msgstr ""
"Если вы не можете найти исходный файл модуля, возможно, это встроенный или "
"динамически загружаемый модуль, реализованный на C, C++ или другом "
"компилируемом языке. В этом случае у вас может не быть исходного файла или "
"это может быть что-то вроде :file:`mathmodule.c`, где-то в исходном каталоге "
"C (не в пути Python)."

#: ../../faq/library.rst:35
msgid "There are (at least) three kinds of modules in Python:"
msgstr "В Python есть (как минимум) три типа модулей:"

#: ../../faq/library.rst:37
msgid "modules written in Python (.py);"
msgstr "модули, написанные на Python (.py);"

#: ../../faq/library.rst:38
msgid ""
"modules written in C and dynamically loaded (.dll, .pyd, .so, .sl, etc);"
msgstr ""
"модули, написанные на C и динамически загружаемые (.dll, .pyd, .so, .sl и т. "
"д.);"

#: ../../faq/library.rst:39
msgid ""
"modules written in C and linked with the interpreter; to get a list of "
"these, type::"
msgstr ""
"модули, написанные на C и связанные с интерпретатором; чтобы получить их "
"список, введите::"

#: ../../faq/library.rst:47
msgid "How do I make a Python script executable on Unix?"
msgstr "Как сделать скрипт Python исполняемым в Unix?"

#: ../../faq/library.rst:49
msgid ""
"You need to do two things: the script file's mode must be executable and the "
"first line must begin with ``#!`` followed by the path of the Python "
"interpreter."
msgstr ""
"Вам нужно сделать две вещи: режим файла сценария должен быть исполняемым, а "
"первая строка должна начинаться с ``#!``, за которым следует путь "
"интерпретатора Python."

#: ../../faq/library.rst:53
msgid ""
"The first is done by executing ``chmod +x scriptfile`` or perhaps ``chmod "
"755 scriptfile``."
msgstr ""
"Первый выполняется путем выполнения ``chmod +x scriptfile`` или, возможно, "
"``chmod 755 scriptfile``."

#: ../../faq/library.rst:56
msgid ""
"The second can be done in a number of ways.  The most straightforward way is "
"to write ::"
msgstr ""
"Второе можно сделать несколькими способами. Самый простой способ — написать::"

#: ../../faq/library.rst:61
msgid ""
"as the very first line of your file, using the pathname for where the Python "
"interpreter is installed on your platform."
msgstr ""
"в качестве самой первой строки вашего файла, используя путь к тому месту, "
"где на вашей платформе установлен интерпретатор Python."

#: ../../faq/library.rst:64
msgid ""
"If you would like the script to be independent of where the Python "
"interpreter lives, you can use the :program:`env` program.  Almost all Unix "
"variants support the following, assuming the Python interpreter is in a "
"directory on the user's :envvar:`PATH`::"
msgstr ""
"Если вы хотите, чтобы сценарий не зависел от того, где находится "
"интерпретатор Python, вы можете использовать программу :program:`env`. Почти "
"все варианты Unix поддерживают следующее, при условии, что интерпретатор "
"Python находится в каталоге пользовательского :envvar:`PATH`::"

#: ../../faq/library.rst:71
msgid ""
"*Don't* do this for CGI scripts.  The :envvar:`PATH` variable for CGI "
"scripts is often very minimal, so you need to use the actual absolute "
"pathname of the interpreter."
msgstr ""
"*Не* делайте это для сценариев CGI. Переменная :envvar:`PATH` для CGI-"
"скриптов часто очень минимальна, поэтому вам нужно использовать фактический "
"абсолютный путь интерпретатора."

#: ../../faq/library.rst:75
msgid ""
"Occasionally, a user's environment is so full that the :program:`/usr/bin/"
"env` program fails; or there's no env program at all.  In that case, you can "
"try the following hack (due to Alex Rezinsky):"
msgstr ""
"Иногда среда пользователя настолько заполнена, что программа :program:`/usr/"
"bin/env` дает сбой; или программы env вообще нет. В этом случае вы можете "
"попробовать следующий хак (автор: Алекс Резинский):"

#: ../../faq/library.rst:86
msgid ""
"The minor disadvantage is that this defines the script's __doc__ string. "
"However, you can fix that by adding ::"
msgstr ""
"Незначительным недостатком является то, что здесь определяется строка "
"__doc__ сценария. Однако вы можете это исправить, добавив ::"

#: ../../faq/library.rst:94
msgid "Is there a curses/termcap package for Python?"
msgstr "Есть ли пакет curses/termcap для Python?"

#: ../../faq/library.rst:98
msgid ""
"For Unix variants: The standard Python source distribution comes with a "
"curses module in the :source:`Modules` subdirectory, though it's not "
"compiled by default. (Note that this is not available in the Windows "
"distribution -- there is no curses module for Windows.)"
msgstr ""
"Для вариантов Unix: стандартный дистрибутив исходного кода Python включает "
"модуль проклятий в подкаталоге :source:`Modules`, хотя по умолчанию он не "
"компилируется. (Обратите внимание, что он недоступен в дистрибутиве Windows "
"— для Windows нет модуля проклятий.)"

#: ../../faq/library.rst:103
msgid ""
"The :mod:`curses` module supports basic curses features as well as many "
"additional functions from ncurses and SYSV curses such as colour, "
"alternative character set support, pads, and mouse support. This means the "
"module isn't compatible with operating systems that only have BSD curses, "
"but there don't seem to be any currently maintained OSes that fall into this "
"category."
msgstr ""
"Модуль :mod:`curses` поддерживает базовые функции Curses, а также множество "
"дополнительных функций из ncurses и SYSV Curses, таких как цвет, поддержка "
"альтернативного набора символов, клавиатура и поддержка мыши. Это означает, "
"что модуль несовместим с операционными системами, в которых есть только "
"проклятия BSD, но, похоже, в настоящее время не существует ни одной "
"поддерживаемой ОС, подпадающей под эту категорию."

#: ../../faq/library.rst:111
msgid "Is there an equivalent to C's onexit() in Python?"
msgstr "Есть ли эквивалент onexit() языка C в Python?"

#: ../../faq/library.rst:113
msgid ""
"The :mod:`atexit` module provides a register function that is similar to "
"C's :c:func:`onexit`."
msgstr ""

#: ../../faq/library.rst:118
msgid "Why don't my signal handlers work?"
msgstr "Почему мои обработчики сигналов не работают?"

#: ../../faq/library.rst:120
msgid ""
"The most common problem is that the signal handler is declared with the "
"wrong argument list.  It is called as ::"
msgstr ""
"Самая распространенная проблема заключается в том, что обработчик сигнала "
"объявлен с неверным списком аргументов. Это называется:::"

#: ../../faq/library.rst:125
msgid "so it should be declared with two parameters::"
msgstr "поэтому его следует объявить с двумя параметрами::"

#: ../../faq/library.rst:132
msgid "Common tasks"
msgstr "Общие задачи"

#: ../../faq/library.rst:135
msgid "How do I test a Python program or component?"
msgstr "Как протестировать программу или компонент Python?"

#: ../../faq/library.rst:137
msgid ""
"Python comes with two testing frameworks.  The :mod:`doctest` module finds "
"examples in the docstrings for a module and runs them, comparing the output "
"with the expected output given in the docstring."
msgstr ""
"Python поставляется с двумя средами тестирования. Модуль :mod:`doctest` "
"находит примеры в строках документации модуля и запускает их, сравнивая "
"выходные данные с ожидаемыми результатами, указанными в строке документации."

#: ../../faq/library.rst:141
msgid ""
"The :mod:`unittest` module is a fancier testing framework modelled on Java "
"and Smalltalk testing frameworks."
msgstr ""
"Модуль :mod:`unittest` — это более продвинутая среда тестирования, созданная "
"по образцу сред тестирования Java и Smalltalk."

#: ../../faq/library.rst:144
msgid ""
"To make testing easier, you should use good modular design in your program. "
"Your program should have almost all functionality encapsulated in either "
"functions or class methods -- and this sometimes has the surprising and "
"delightful effect of making the program run faster (because local variable "
"accesses are faster than global accesses).  Furthermore the program should "
"avoid depending on mutating global variables, since this makes testing much "
"more difficult to do."
msgstr ""
"Чтобы упростить тестирование, вам следует использовать в своей программе "
"хороший модульный дизайн. Ваша программа должна иметь почти всю "
"функциональность, инкапсулированную либо в функциях, либо в методах класса - "
"и это иногда имеет удивительный и восхитительный эффект, ускоряя работу "
"программы (поскольку доступ к локальным переменным происходит быстрее, чем "
"доступ к глобальным). Кроме того, программе следует избегать зависимости от "
"изменения глобальных переменных, поскольку это значительно усложняет "
"тестирование."

#: ../../faq/library.rst:152
msgid "The \"global main logic\" of your program may be as simple as ::"
msgstr ""
"«Глобальная основная логика» вашей программы может быть такой же простой, "
"как::"

#: ../../faq/library.rst:157
msgid "at the bottom of the main module of your program."
msgstr "внизу основного модуля вашей программы."

#: ../../faq/library.rst:159
msgid ""
"Once your program is organized as a tractable collection of function and "
"class behaviours, you should write test functions that exercise the "
"behaviours.  A test suite that automates a sequence of tests can be "
"associated with each module. This sounds like a lot of work, but since "
"Python is so terse and flexible it's surprisingly easy.  You can make coding "
"much more pleasant and fun by writing your test functions in parallel with "
"the \"production code\", since this makes it easy to find bugs and even "
"design flaws earlier."
msgstr ""
"После того как ваша программа организована в виде удобного набора функций и "
"поведений классов, вам следует написать тестовые функции, которые реализуют "
"это поведение. С каждым модулем можно связать набор тестов, автоматизирующий "
"последовательность тестов. Это звучит как большая работа, но, поскольку "
"Python настолько краток и гибок, это на удивление просто. Вы можете сделать "
"кодирование намного приятнее и увлекательнее, написав свои тестовые функции "
"параллельно с «производственным кодом», поскольку это позволяет легко "
"находить ошибки и даже недостатки дизайна раньше."

#: ../../faq/library.rst:167
msgid ""
"\"Support modules\" that are not intended to be the main module of a program "
"may include a self-test of the module. ::"
msgstr ""
"«Модули поддержки», которые не предназначены для использования в качестве "
"основного модуля программы, могут включать в себя самотестирование модуля. ::"

#: ../../faq/library.rst:173
msgid ""
"Even programs that interact with complex external interfaces may be tested "
"when the external interfaces are unavailable by using \"fake\" interfaces "
"implemented in Python."
msgstr ""
"Даже программы, которые взаимодействуют со сложными внешними интерфейсами, "
"можно тестировать, когда внешние интерфейсы недоступны, с использованием "
"«поддельных» интерфейсов, реализованных на Python."

#: ../../faq/library.rst:179
msgid "How do I create documentation from doc strings?"
msgstr "Как создать документацию из строк документа?"

#: ../../faq/library.rst:181
msgid ""
"The :mod:`pydoc` module can create HTML from the doc strings in your Python "
"source code.  An alternative for creating API documentation purely from "
"docstrings is `epydoc <https://epydoc.sourceforge.net/>`_.  `Sphinx <https://"
"www.sphinx-doc.org>`_ can also include docstring content."
msgstr ""
"Модуль :mod:`pydoc` может создавать HTML из строк документа в исходном коде "
"Python. Альтернативой созданию документации API исключительно на основе "
"строк документации является `epydoc <https://epydoc.sourceforge.net/>`_. "
"`Sphinx <https://www.sphinx-doc.org>`_ также может включать содержимое "
"строки документации."

#: ../../faq/library.rst:188
msgid "How do I get a single keypress at a time?"
msgstr "Как мне получить одно нажатие клавиши за раз?"

#: ../../faq/library.rst:190
msgid ""
"For Unix variants there are several solutions.  It's straightforward to do "
"this using curses, but curses is a fairly large module to learn."
msgstr ""
"Для вариантов Unix существует несколько решений. Сделать это с помощью "
"проклятий несложно, но проклятия — это довольно большой модуль для изучения."

#: ../../faq/library.rst:234
msgid "Threads"
msgstr "Потоки"

#: ../../faq/library.rst:237
msgid "How do I program using threads?"
msgstr "Как программировать с использованием потоков?"

#: ../../faq/library.rst:239
msgid ""
"Be sure to use the :mod:`threading` module and not the :mod:`_thread` "
"module. The :mod:`threading` module builds convenient abstractions on top of "
"the low-level primitives provided by the :mod:`_thread` module."
msgstr ""
"Обязательно используйте модуль :mod:`threading`, а не модуль :mod:`_thread`. "
"Модуль :mod:`threading` создает удобные абстракции поверх низкоуровневых "
"примитивов, предоставляемых модулем :mod:`_thread`."

#: ../../faq/library.rst:245
msgid "None of my threads seem to run: why?"
msgstr "Кажется, ни одна из моих тем не запускается: почему?"

#: ../../faq/library.rst:247
msgid ""
"As soon as the main thread exits, all threads are killed.  Your main thread "
"is running too quickly, giving the threads no time to do any work."
msgstr ""
"Как только основной поток завершается, все потоки уничтожаются. Ваш основной "
"поток работает слишком быстро, не давая потокам времени выполнить какую-либо "
"работу."

#: ../../faq/library.rst:250
msgid ""
"A simple fix is to add a sleep to the end of the program that's long enough "
"for all the threads to finish::"
msgstr ""
"Простое решение — добавить в конец программы спящий режим, достаточно "
"длинный для завершения всех потоков:"

#: ../../faq/library.rst:265
msgid ""
"But now (on many platforms) the threads don't run in parallel, but appear to "
"run sequentially, one at a time!  The reason is that the OS thread scheduler "
"doesn't start a new thread until the previous thread is blocked."
msgstr ""
"Но теперь (на многих платформах) потоки выполняются не параллельно, а "
"последовательно, один за другим! Причина в том, что планировщик потоков ОС "
"не запускает новый поток, пока предыдущий поток не будет заблокирован."

#: ../../faq/library.rst:269
msgid "A simple fix is to add a tiny sleep to the start of the run function::"
msgstr "Простое решение — добавить крошечный сон в начало функции запуска:"

#: ../../faq/library.rst:282
msgid ""
"Instead of trying to guess a good delay value for :func:`time.sleep`, it's "
"better to use some kind of semaphore mechanism.  One idea is to use the :mod:"
"`queue` module to create a queue object, let each thread append a token to "
"the queue when it finishes, and let the main thread read as many tokens from "
"the queue as there are threads."
msgstr ""
"Вместо того, чтобы пытаться угадать хорошее значение задержки для :func:"
"`time.sleep`, лучше использовать какой-нибудь механизм семафоров. Одна из "
"идей состоит в том, чтобы использовать модуль :mod:`queue` для создания "
"объекта очереди, позволить каждому потоку добавлять токен в очередь после ее "
"завершения и позволить основному потоку считывать из очереди столько "
"токенов, сколько существует потоков."

#: ../../faq/library.rst:290
msgid "How do I parcel out work among a bunch of worker threads?"
msgstr "Как распределить работу между несколькими рабочими потоками?"

#: ../../faq/library.rst:292
msgid ""
"The easiest way is to use the :mod:`concurrent.futures` module, especially "
"the :mod:`~concurrent.futures.ThreadPoolExecutor` class."
msgstr ""
"Самый простой способ — использовать модуль :mod:`concurrent.futures`, "
"особенно класс :mod:`~concurrent.futures.ThreadPoolExecutor`."

#: ../../faq/library.rst:295
msgid ""
"Or, if you want fine control over the dispatching algorithm, you can write "
"your own logic manually.  Use the :mod:`queue` module to create a queue "
"containing a list of jobs.  The :class:`~queue.Queue` class maintains a list "
"of objects and has a ``.put(obj)`` method that adds items to the queue and a "
"``.get()`` method to return them.  The class will take care of the locking "
"necessary to ensure that each job is handed out exactly once."
msgstr ""
"Или, если вам нужен точный контроль над алгоритмом диспетчеризации, вы "
"можете написать свою собственную логику вручную. Используйте модуль :mod:"
"`queue` для создания очереди, содержащей список заданий. Класс :class:"
"`~queue.Queue` поддерживает список объектов и имеет метод ``.put(obj)``, "
"который добавляет элементы в очередь, и метод ``.get()`` для их возврата. "
"Класс позаботится о блокировке, необходимой для того, чтобы каждое задание "
"было выдано ровно один раз."

#: ../../faq/library.rst:302
msgid "Here's a trivial example::"
msgstr "Вот тривиальный пример:"

#: ../../faq/library.rst:340
msgid "When run, this will produce the following output:"
msgstr "При запуске это выдаст следующий результат:"

#: ../../faq/library.rst:358
msgid ""
"Consult the module's documentation for more details; the :class:`~queue."
"Queue` class provides a featureful interface."
msgstr ""
"Для получения более подробной информации обратитесь к документации модуля; "
"Класс :class:`~queue.Queue` предоставляет функциональный интерфейс."

#: ../../faq/library.rst:363
msgid "What kinds of global value mutation are thread-safe?"
msgstr "Какие виды мутаций глобальных значений являются потокобезопасными?"

#: ../../faq/library.rst:365
msgid ""
"A :term:`global interpreter lock` (GIL) is used internally to ensure that "
"only one thread runs in the Python VM at a time.  In general, Python offers "
"to switch among threads only between bytecode instructions; how frequently "
"it switches can be set via :func:`sys.setswitchinterval`.  Each bytecode "
"instruction and therefore all the C implementation code reached from each "
"instruction is therefore atomic from the point of view of a Python program."
msgstr ""
":term:`глобальная блокировка интерпретатора` (GIL) используется внутри, "
"чтобы гарантировать, что в виртуальной машине Python одновременно "
"выполняется только один поток. В общем, Python предлагает переключаться "
"между потоками только между инструкциями байт-кода; как часто он "
"переключается, можно установить с помощью :func:`sys.setswitchinterval`. "
"Таким образом, каждая инструкция байт-кода и, следовательно, весь код "
"реализации C, полученный из каждой инструкции, являются атомарными с точки "
"зрения программы Python."

#: ../../faq/library.rst:372
msgid ""
"In theory, this means an exact accounting requires an exact understanding of "
"the PVM bytecode implementation.  In practice, it means that operations on "
"shared variables of built-in data types (ints, lists, dicts, etc) that "
"\"look atomic\" really are."
msgstr ""
"Теоретически это означает, что точный учет требует точного понимания "
"реализации байт-кода PVM. На практике это означает, что операции с общими "
"переменными встроенных типов данных (int, lists, dict и т. д.), которые "
"«выглядят атомарными», действительно таковы."

#: ../../faq/library.rst:377
msgid ""
"For example, the following operations are all atomic (L, L1, L2 are lists, "
"D, D1, D2 are dicts, x, y are objects, i, j are ints)::"
msgstr ""
"Например, все следующие операции являются атомарными (L, L1, L2 — списки, D, "
"D1, D2 — словари, x, y — объекты, i, j — целые числа)::"

#: ../../faq/library.rst:392
msgid "These aren't::"
msgstr "Это не::"

#: ../../faq/library.rst:399
msgid ""
"Operations that replace other objects may invoke those other objects' :meth:"
"`__del__` method when their reference count reaches zero, and that can "
"affect things.  This is especially true for the mass updates to dictionaries "
"and lists.  When in doubt, use a mutex!"
msgstr ""

#: ../../faq/library.rst:406
msgid "Can't we get rid of the Global Interpreter Lock?"
msgstr "Разве мы не можем избавиться от глобальной блокировки переводчика?"

#: ../../faq/library.rst:410
msgid ""
"The :term:`global interpreter lock` (GIL) is often seen as a hindrance to "
"Python's deployment on high-end multiprocessor server machines, because a "
"multi-threaded Python program effectively only uses one CPU, due to the "
"insistence that (almost) all Python code can only run while the GIL is held."
msgstr ""
":term:`глобальная блокировка интерпретатора` (GIL) часто рассматривается как "
"препятствие для развертывания Python на высокопроизводительных "
"многопроцессорных серверных машинах, поскольку многопоточная программа "
"Python фактически использует только один процессор из-за того, что (почти) "
"весь код Python может выполняться только при сохранении GIL."

#: ../../faq/library.rst:415
msgid ""
"Back in the days of Python 1.5, Greg Stein actually implemented a "
"comprehensive patch set (the \"free threading\" patches) that removed the "
"GIL and replaced it with fine-grained locking.  Adam Olsen recently did a "
"similar experiment in his `python-safethread <https://code.google.com/"
"archive/p/python-safethread>`_ project.  Unfortunately, both experiments "
"exhibited a sharp drop in single-thread performance (at least 30% slower), "
"due to the amount of fine-grained locking necessary to compensate for the "
"removal of the GIL."
msgstr ""
"Еще во времена Python 1.5 Грег Стейн фактически реализовал комплексный набор "
"патчей (патчи «свободной многопоточности»), которые удалили GIL и заменили "
"его детальной блокировкой. Адам Олсен недавно проделал аналогичный "
"эксперимент в своем проекте `python-safethread <https://code.google.com/"
"archive/p/python-safethread>`_. К сожалению, оба эксперимента показали "
"резкое падение однопоточной производительности (медленнее как минимум на "
"30%) из-за количества мелкозернистых блокировок, необходимых для компенсации "
"удаления GIL."

#: ../../faq/library.rst:423
msgid ""
"This doesn't mean that you can't make good use of Python on multi-CPU "
"machines! You just have to be creative with dividing the work up between "
"multiple *processes* rather than multiple *threads*.  The :class:"
"`~concurrent.futures.ProcessPoolExecutor` class in the new :mod:`concurrent."
"futures` module provides an easy way of doing so; the :mod:`multiprocessing` "
"module provides a lower-level API in case you want more control over "
"dispatching of tasks."
msgstr ""
"Это не означает, что вы не можете эффективно использовать Python на "
"многопроцессорных машинах! Вам просто нужно проявить творческий подход к "
"разделению работы между несколькими *процессами*, а не несколькими "
"*потоками*. Класс :class:`~concurrent.futures.ProcessPoolExecutor` в новом "
"модуле :mod:`concurrent.futures` предоставляет простой способ сделать это; "
"Модуль :mod:`multiprocessing` предоставляет API более низкого уровня на тот "
"случай, если вам нужен больший контроль над диспетчеризацией задач."

#: ../../faq/library.rst:431
msgid ""
"Judicious use of C extensions will also help; if you use a C extension to "
"perform a time-consuming task, the extension can release the GIL while the "
"thread of execution is in the C code and allow other threads to get some "
"work done.  Some standard library modules such as :mod:`zlib` and :mod:"
"`hashlib` already do this."
msgstr ""
"Разумное использование расширений C также поможет; если вы используете "
"расширение C для выполнения трудоемкой задачи, расширение может освободить "
"GIL, пока поток выполнения находится в коде C, и позволить другим потокам "
"выполнить некоторую работу. Некоторые стандартные библиотечные модули, такие "
"как :mod:`zlib` и :mod:`hashlib`, уже делают это."

#: ../../faq/library.rst:437
msgid ""
"It has been suggested that the GIL should be a per-interpreter-state lock "
"rather than truly global; interpreters then wouldn't be able to share "
"objects. Unfortunately, this isn't likely to happen either.  It would be a "
"tremendous amount of work, because many object implementations currently "
"have global state. For example, small integers and short strings are cached; "
"these caches would have to be moved to the interpreter state.  Other object "
"types have their own free list; these free lists would have to be moved to "
"the interpreter state. And so on."
msgstr ""
"Было высказано предположение, что GIL должен быть блокировкой для каждого "
"состояния интерпретатора, а не действительно глобальным; тогда "
"интерпретаторы не смогут совместно использовать объекты. К сожалению, это "
"тоже вряд ли произойдет. Это будет огромный объем работы, поскольку многие "
"реализации объектов в настоящее время имеют глобальное состояние. Например, "
"кэшируются небольшие целые числа и короткие строки; эти кеши придется "
"перевести в состояние интерпретатора. Другие типы объектов имеют свой "
"собственный свободный список; эти свободные списки необходимо будет "
"переместить в состояние интерпретатора. И так далее."

#: ../../faq/library.rst:446
msgid ""
"And I doubt that it can even be done in finite time, because the same "
"problem exists for 3rd party extensions.  It is likely that 3rd party "
"extensions are being written at a faster rate than you can convert them to "
"store all their global state in the interpreter state."
msgstr ""
"И я сомневаюсь, что это можно сделать за конечное время, потому что та же "
"проблема существует и для сторонних расширений. Вполне вероятно, что "
"сторонние расширения пишутся быстрее, чем вы можете преобразовать их для "
"сохранения всего их глобального состояния в состоянии интерпретатора."

#: ../../faq/library.rst:451
msgid ""
"And finally, once you have multiple interpreters not sharing any state, what "
"have you gained over running each interpreter in a separate process?"
msgstr ""
"И, наконец, если у вас есть несколько интерпретаторов, не имеющих общего "
"состояния, что вы получите от запуска каждого интерпретатора в отдельном "
"процессе?"

#: ../../faq/library.rst:456
msgid "Input and Output"
msgstr "Ввод и вывод"

#: ../../faq/library.rst:459
msgid "How do I delete a file? (And other file questions...)"
msgstr "Как удалить файл? (И другие вопросы по файлам...)"

#: ../../faq/library.rst:461
msgid ""
"Use ``os.remove(filename)`` or ``os.unlink(filename)``; for documentation, "
"see the :mod:`os` module.  The two functions are identical; :func:`~os."
"unlink` is simply the name of the Unix system call for this function."
msgstr ""
"Используйте ``os.remove(filename)`` или ``os.unlink(filename)``; "
"документацию смотрите в модуле :mod:`os`. Эти две функции идентичны; :func:"
"`~os.unlink` — это просто имя системного вызова Unix для этой функции."

#: ../../faq/library.rst:465
msgid ""
"To remove a directory, use :func:`os.rmdir`; use :func:`os.mkdir` to create "
"one. ``os.makedirs(path)`` will create any intermediate directories in "
"``path`` that don't exist. ``os.removedirs(path)`` will remove intermediate "
"directories as long as they're empty; if you want to delete an entire "
"directory tree and its contents, use :func:`shutil.rmtree`."
msgstr ""
"Чтобы удалить каталог, используйте :func:`os.rmdir`; используйте :func:`os."
"mkdir` для его создания. ``os.madeirs(path)`` создаст любые промежуточные "
"каталоги в ``path``, которые не существуют. ``os.removedirs(path)`` удалит "
"промежуточные каталоги, пока они пусты; если вы хотите удалить все дерево "
"каталогов и его содержимое, используйте :func:`shutil.rmtree`."

#: ../../faq/library.rst:471
msgid "To rename a file, use ``os.rename(old_path, new_path)``."
msgstr ""
"Чтобы переименовать файл, используйте ``os.rename(old_path, new_path)``."

#: ../../faq/library.rst:473
msgid ""
"To truncate a file, open it using ``f = open(filename, \"rb+\")``, and use "
"``f.truncate(offset)``; offset defaults to the current seek position.  "
"There's also ``os.ftruncate(fd, offset)`` for files opened with :func:`os."
"open`, where *fd* is the file descriptor (a small integer)."
msgstr ""
"Чтобы обрезать файл, откройте его с помощью ``f = open(filename, \"rb+\")`` "
"и используйте ``f.truncate(offset)``; offset по умолчанию соответствует "
"текущей позиции поиска. Также существует ``os.ftruncate(fd, offset)`` для "
"файлов, открытых с помощью :func:`os.open`, где *fd* — дескриптор файла "
"(маленькое целое число)."

#: ../../faq/library.rst:478
msgid ""
"The :mod:`shutil` module also contains a number of functions to work on "
"files including :func:`~shutil.copyfile`, :func:`~shutil.copytree`, and :"
"func:`~shutil.rmtree`."
msgstr ""
"Модуль :mod:`shutil` также содержит ряд функций для работы с файлами, "
"включая :func:`~shutil.copyfile`, :func:`~shutil.copytree` и :func:`~shutil."
"rmtree`."

#: ../../faq/library.rst:484
msgid "How do I copy a file?"
msgstr "Как скопировать файл?"

#: ../../faq/library.rst:486
msgid ""
"The :mod:`shutil` module contains a :func:`~shutil.copyfile` function. Note "
"that on Windows NTFS volumes, it does not copy `alternate data streams "
"<https://en.wikipedia.org/wiki/NTFS#Alternate_data_stream_(ADS)>`_ nor "
"`resource forks <https://en.wikipedia.org/wiki/Resource_fork>`__ on macOS "
"HFS+ volumes, though both are now rarely used. It also doesn't copy file "
"permissions and metadata, though using :func:`shutil.copy2` instead will "
"preserve most (though not all) of it."
msgstr ""
"Модуль :mod:`shutil` содержит функцию :func:`~shutil.copyfile`. Обратите "
"внимание, что на томах Windows NTFS он не копирует ни `альтернативные потоки "
"данных <https://en.wikipedia.org/wiki/NTFS#Alternate_data_stream_(ADS)>`_, "
"ни `разветвления ресурсов <https://en.wikipedia. org/wiki/Resource_fork>`__ "
"на томах macOS HFS+, хотя оба сейчас используются редко. Он также не "
"копирует права доступа к файлам и метаданные, хотя использование :func:"
"`shutil.copy2` вместо этого сохранит большую часть (хотя и не все) из них."

#: ../../faq/library.rst:497
msgid "How do I read (or write) binary data?"
msgstr "Как читать (или записывать) двоичные данные?"

#: ../../faq/library.rst:499
msgid ""
"To read or write complex binary data formats, it's best to use the :mod:"
"`struct` module.  It allows you to take a string containing binary data "
"(usually numbers) and convert it to Python objects; and vice versa."
msgstr ""
"Для чтения или записи сложных форматов двоичных данных лучше всего "
"использовать модуль :mod:`struct`. Он позволяет вам взять строку, содержащую "
"двоичные данные (обычно числа), и преобразовать ее в объекты Python; и "
"наоборот."

#: ../../faq/library.rst:503
msgid ""
"For example, the following code reads two 2-byte integers and one 4-byte "
"integer in big-endian format from a file::"
msgstr ""
"Например, следующий код считывает из файла два 2-байтовых целых числа и одно "
"4-байтовое целое число в формате с обратным порядком байтов:"

#: ../../faq/library.rst:512
msgid ""
"The '>' in the format string forces big-endian data; the letter 'h' reads "
"one \"short integer\" (2 bytes), and 'l' reads one \"long integer\" (4 "
"bytes) from the string."
msgstr ""
"Символ «>» в ​​строке формата приводит к использованию данных с прямым "
"порядком байтов; буква «h» читает одно «короткое целое число» (2 байта), а "
"буква «l» читает одно «длинное целое число» (4 байта) из строки."

#: ../../faq/library.rst:516
msgid ""
"For data that is more regular (e.g. a homogeneous list of ints or floats), "
"you can also use the :mod:`array` module."
msgstr ""
"Для более регулярных данных (например, однородный список целых чисел или "
"чисел с плавающей запятой) вы также можете использовать модуль :mod:`array`."

#: ../../faq/library.rst:521
msgid ""
"To read and write binary data, it is mandatory to open the file in binary "
"mode (here, passing ``\"rb\"`` to :func:`open`).  If you use ``\"r\"`` "
"instead (the default), the file will be open in text mode and ``f.read()`` "
"will return :class:`str` objects rather than :class:`bytes` objects."
msgstr ""
"Для чтения и записи двоичных данных необходимо открыть файл в двоичном "
"режиме (здесь передавая ``\"rb\"`` в :func:`open`). Если вместо этого вы "
"используете ``\"r\"`` (по умолчанию), файл будет открыт в текстовом режиме, "
"а ``f.read()`` будет возвращать объекты :class:`str`, а не :class:`bytes. "
"`объекты."

#: ../../faq/library.rst:529
msgid "I can't seem to use os.read() on a pipe created with os.popen(); why?"
msgstr ""
"Кажется, я не могу использовать os.read() в канале, созданном с помощью os."
"popen(); почему?"

#: ../../faq/library.rst:531
msgid ""
":func:`os.read` is a low-level function which takes a file descriptor, a "
"small integer representing the opened file.  :func:`os.popen` creates a high-"
"level file object, the same type returned by the built-in :func:`open` "
"function. Thus, to read *n* bytes from a pipe *p* created with :func:`os."
"popen`, you need to use ``p.read(n)``."
msgstr ""
":func:`os.read` — это функция низкого уровня, которая принимает дескриптор "
"файла, небольшое целое число, представляющее открытый файл. :func:`os.popen` "
"создает файловый объект высокого уровня того же типа, который возвращается "
"встроенной функцией :func:`open`. Таким образом, чтобы прочитать *n* байт из "
"канала *p*, созданного с помощью :func:`os.popen`, вам нужно использовать "
"``p.read(n)``."

#: ../../faq/library.rst:618
msgid "How do I access the serial (RS232) port?"
msgstr "Как получить доступ к последовательному порту (RS232)?"

#: ../../faq/library.rst:620
msgid "For Win32, OSX, Linux, BSD, Jython, IronPython:"
msgstr "Для Win32, OSX, Linux, BSD, Jython, IronPython:"

#: ../../faq/library.rst:622
msgid "https://pypi.org/project/pyserial/"
msgstr ""

#: ../../faq/library.rst:624
msgid "For Unix, see a Usenet post by Mitch Chapman:"
msgstr "Для Unix см. сообщение Usenet Митча Чепмена:"

#: ../../faq/library.rst:626
msgid "https://groups.google.com/groups?selm=34A04430.CF9@ohioee.com"
msgstr "https://groups.google.com/groups?selm=34A04430.CF9@ohioee.com"

#: ../../faq/library.rst:630
msgid "Why doesn't closing sys.stdout (stdin, stderr) really close it?"
msgstr ""
"Почему закрытие sys.stdout (stdin, stderr) на самом деле не закрывает его?"

#: ../../faq/library.rst:632
msgid ""
"Python :term:`file objects <file object>` are a high-level layer of "
"abstraction on low-level C file descriptors."
msgstr ""
"Python :term:`файловые объекты <файловый объект>` представляют собой "
"высокоуровневый уровень абстракции низкоуровневых файловых дескрипторов C."

#: ../../faq/library.rst:635
msgid ""
"For most file objects you create in Python via the built-in :func:`open` "
"function, ``f.close()`` marks the Python file object as being closed from "
"Python's point of view, and also arranges to close the underlying C file "
"descriptor.  This also happens automatically in ``f``'s destructor, when "
"``f`` becomes garbage."
msgstr ""
"Для большинства файловых объектов, которые вы создаете в Python с помощью "
"встроенной функции :func:`open`, ``f.close()`` помечает файловый объект "
"Python как закрытый с точки зрения Python, а также организует закрытие "
"базовый дескриптор файла C. Это также происходит автоматически в деструкторе "
"``f``, когда ``f`` становится мусором."

#: ../../faq/library.rst:641
msgid ""
"But stdin, stdout and stderr are treated specially by Python, because of the "
"special status also given to them by C.  Running ``sys.stdout.close()`` "
"marks the Python-level file object as being closed, but does *not* close the "
"associated C file descriptor."
msgstr ""
"Но Python, stdout и stderr обрабатываются особым образом из-за особого "
"статуса, присвоенного им C. Выполнение ``sys.stdout.close()`` помечает "
"файловый объект уровня Python как закрытый, но * not* закрывать связанный "
"дескриптор файла C."

#: ../../faq/library.rst:646
msgid ""
"To close the underlying C file descriptor for one of these three, you should "
"first be sure that's what you really want to do (e.g., you may confuse "
"extension modules trying to do I/O).  If it is, use :func:`os.close`::"
msgstr ""
"Чтобы закрыть базовый дескриптор файла C для одного из этих трех, вы должны "
"сначала убедиться, что это именно то, что вы действительно хотите сделать "
"(например, вы можете сбить с толку модули расширения, пытающиеся выполнять "
"ввод-вывод). Если это так, используйте :func:`os.close`::"

#: ../../faq/library.rst:654
msgid "Or you can use the numeric constants 0, 1 and 2, respectively."
msgstr "Или вы можете использовать числовые константы 0, 1 и 2 соответственно."

#: ../../faq/library.rst:658
msgid "Network/Internet Programming"
msgstr "Сетевое/интернет программирование"

#: ../../faq/library.rst:661
msgid "What WWW tools are there for Python?"
msgstr "Какие WWW-инструменты существуют для Python?"

#: ../../faq/library.rst:663
msgid ""
"See the chapters titled :ref:`internet` and :ref:`netdata` in the Library "
"Reference Manual.  Python has many modules that will help you build server-"
"side and client-side web systems."
msgstr ""
"См. главы :ref:`internet` и :ref:`netdata` в Справочном руководстве "
"библиотеки. Python имеет множество модулей, которые помогут вам создавать "
"веб-системы на стороне сервера и клиента."

#: ../../faq/library.rst:669
msgid ""
"A summary of available frameworks is maintained by Paul Boddie at https://"
"wiki.python.org/moin/WebProgramming\\ ."
msgstr ""
"Краткое описание доступных фреймворков поддерживается Полом Бодди по адресу "
"https://wiki.python.org/moin/WebProgramming\\."

#: ../../faq/library.rst:672
msgid ""
"Cameron Laird maintains a useful set of pages about Python web technologies "
"at https://web.archive.org/web/20210224183619/http://phaseit.net/claird/comp."
"lang.python/web_python."
msgstr ""
"Кэмерон Лэрд поддерживает полезный набор страниц о веб-технологиях Python по "
"адресу https://web.archive.org/web/20210224183619/http://phaseit.net/claird/"
"comp.lang.python/web_python."

#: ../../faq/library.rst:677
msgid "How can I mimic CGI form submission (METHOD=POST)?"
msgstr "Как я могу имитировать отправку формы CGI (МЕТОД = POST)?"

#: ../../faq/library.rst:679
msgid ""
"I would like to retrieve web pages that are the result of POSTing a form. Is "
"there existing code that would let me do this easily?"
msgstr ""
"Я хотел бы получить веб-страницы, являющиеся результатом отправки формы. "
"Существует ли существующий код, который позволил бы мне легко это сделать?"

#: ../../faq/library.rst:682
msgid "Yes. Here's a simple example that uses :mod:`urllib.request`::"
msgstr "Да. Вот простой пример использования :mod:`urllib.request`::"

#: ../../faq/library.rst:697
msgid ""
"Note that in general for percent-encoded POST operations, query strings must "
"be quoted using :func:`urllib.parse.urlencode`.  For example, to send "
"``name=Guy Steele, Jr.``::"
msgstr ""
"Обратите внимание, что, как правило, для операций POST с процентным "
"кодированием строки запроса должны быть заключены в кавычки с "
"использованием :func:`urllib.parse.urlencode`. Например, чтобы отправить "
"``name=Guy Steele, Jr.``::"

#: ../../faq/library.rst:705
msgid ":ref:`urllib-howto` for extensive examples."
msgstr ":ref:`urllib-howto` для подробных примеров."

#: ../../faq/library.rst:709
msgid "What module should I use to help with generating HTML?"
msgstr "Какой модуль мне следует использовать для создания HTML?"

#: ../../faq/library.rst:713
msgid ""
"You can find a collection of useful links on the `Web Programming wiki page "
"<https://wiki.python.org/moin/WebProgramming>`_."
msgstr ""
"Коллекцию полезных ссылок можно найти на `вики-странице веб-программирования "
"<https://wiki.python.org/moin/WebProgramming>`_."

#: ../../faq/library.rst:718
msgid "How do I send mail from a Python script?"
msgstr "Как отправить почту из скрипта Python?"

#: ../../faq/library.rst:720
msgid "Use the standard library module :mod:`smtplib`."
msgstr "Используйте стандартный библиотечный модуль :mod:`smtplib`."

#: ../../faq/library.rst:722
msgid ""
"Here's a very simple interactive mail sender that uses it.  This method will "
"work on any host that supports an SMTP listener. ::"
msgstr ""
"Вот очень простой интерактивный отправитель почты, который его использует. "
"Этот метод будет работать на любом хосте, поддерживающем прослушиватель "
"SMTP. ::"

#: ../../faq/library.rst:742
msgid ""
"A Unix-only alternative uses sendmail.  The location of the sendmail program "
"varies between systems; sometimes it is ``/usr/lib/sendmail``, sometimes ``/"
"usr/sbin/sendmail``.  The sendmail manual page will help you out.  Here's "
"some sample code::"
msgstr ""
"Альтернатива только для Unix использует sendmail. Местоположение программы "
"sendmail варьируется в зависимости от системы; иногда это ``/usr/lib/"
"sendmail``, иногда ``/usr/sbin/sendmail``. Страница руководства sendmail "
"поможет вам. Вот пример кода::"

#: ../../faq/library.rst:762
msgid "How do I avoid blocking in the connect() method of a socket?"
msgstr "Как избежать блокировки метода подключения() сокета?"

#: ../../faq/library.rst:764
msgid ""
"The :mod:`select` module is commonly used to help with asynchronous I/O on "
"sockets."
msgstr ""
"Модуль :mod:`select` обычно используется для облегчения асинхронного ввода-"
"вывода в сокетах."

#: ../../faq/library.rst:767
msgid ""
"To prevent the TCP connect from blocking, you can set the socket to non-"
"blocking mode.  Then when you do the :meth:`socket.connect`, you will either "
"connect immediately (unlikely) or get an exception that contains the error "
"number as ``.errno``. ``errno.EINPROGRESS`` indicates that the connection is "
"in progress, but hasn't finished yet.  Different OSes will return different "
"values, so you're going to have to check what's returned on your system."
msgstr ""

#: ../../faq/library.rst:774
msgid ""
"You can use the :meth:`socket.connect_ex` method to avoid creating an "
"exception.  It will just return the errno value.  To poll, you can call :"
"meth:`socket.connect_ex` again later -- ``0`` or ``errno.EISCONN`` indicate "
"that you're connected -- or you can pass this socket to :meth:`select."
"select` to check if it's writable."
msgstr ""

#: ../../faq/library.rst:780
msgid ""
"The :mod:`asyncio` module provides a general purpose single-threaded and "
"concurrent asynchronous library, which can be used for writing non-blocking "
"network code. The third-party `Twisted <https://twistedmatrix.com/trac/>`_ "
"library is a popular and feature-rich alternative."
msgstr ""

#: ../../faq/library.rst:788
msgid "Databases"
msgstr "Базы данных"

#: ../../faq/library.rst:791
msgid "Are there any interfaces to database packages in Python?"
msgstr "Существуют ли какие-либо интерфейсы для пакетов баз данных в Python?"

#: ../../faq/library.rst:793
msgid "Yes."
msgstr "Да."

#: ../../faq/library.rst:795
msgid ""
"Interfaces to disk-based hashes such as :mod:`DBM <dbm.ndbm>` and :mod:`GDBM "
"<dbm.gnu>` are also included with standard Python.  There is also the :mod:"
"`sqlite3` module, which provides a lightweight disk-based relational "
"database."
msgstr ""
"Интерфейсы для дисковых хэшей, такие как :mod:`DBM <dbm.ndbm>` и :mod:`GDBM "
"<dbm.gnu>`, также включены в стандартный Python. Существует также модуль :"
"mod:`sqlite3`, который предоставляет облегченную дисковую реляционную базу "
"данных."

#: ../../faq/library.rst:800
msgid ""
"Support for most relational databases is available.  See the "
"`DatabaseProgramming wiki page <https://wiki.python.org/moin/"
"DatabaseProgramming>`_ for details."
msgstr ""
"Доступна поддержка большинства реляционных баз данных. Подробности смотрите "
"на вики-странице DatabaseProgramming <https://wiki.python.org/moin/"
"DatabaseProgramming>`_."

#: ../../faq/library.rst:806
msgid "How do you implement persistent objects in Python?"
msgstr "Как реализовать постоянные объекты в Python?"

#: ../../faq/library.rst:808
msgid ""
"The :mod:`pickle` library module solves this in a very general way (though "
"you still can't store things like open files, sockets or windows), and the :"
"mod:`shelve` library module uses pickle and (g)dbm to create persistent "
"mappings containing arbitrary Python objects."
msgstr ""
"Библиотечный модуль :mod:`pickle` решает эту проблему очень общим способом "
"(хотя вы по-прежнему не можете хранить такие вещи, как открытые файлы, "
"сокеты или окна), а библиотечный модуль :mod:`shelve` использует Pickle и "
"(g) dbm для создания постоянных сопоставлений, содержащих произвольные "
"объекты Python."

#: ../../faq/library.rst:815
msgid "Mathematics and Numerics"
msgstr "Математика и числа"

#: ../../faq/library.rst:818
msgid "How do I generate random numbers in Python?"
msgstr "Как генерировать случайные числа в Python?"

#: ../../faq/library.rst:820
msgid ""
"The standard module :mod:`random` implements a random number generator.  "
"Usage is simple::"
msgstr ""
"Стандартный модуль :mod:`random` реализует генератор случайных чисел. "
"Использование простое::"

#: ../../faq/library.rst:826
msgid "This returns a random floating point number in the range [0, 1)."
msgstr ""

#: ../../faq/library.rst:828
msgid ""
"There are also many other specialized generators in this module, such as:"
msgstr ""
"В этом модуле также есть множество других специализированных генераторов, "
"таких как:"

#: ../../faq/library.rst:830
msgid "``randrange(a, b)`` chooses an integer in the range [a, b)."
msgstr "``randrange(a, b)`` выбирает целое число в диапазоне [a, b)."

#: ../../faq/library.rst:831
msgid "``uniform(a, b)`` chooses a floating point number in the range [a, b)."
msgstr ""

#: ../../faq/library.rst:832
msgid ""
"``normalvariate(mean, sdev)`` samples the normal (Gaussian) distribution."
msgstr ""
"``normalvariate(mean, sdev)`` выбирает нормальное (гауссово) распределение."

#: ../../faq/library.rst:834
msgid "Some higher-level functions operate on sequences directly, such as:"
msgstr ""
"Некоторые функции более высокого уровня работают с последовательностями "
"напрямую, например:"

#: ../../faq/library.rst:836
msgid "``choice(S)`` chooses a random element from a given sequence."
msgstr ""
"``choice(S)`` выбирает случайный элемент из заданной последовательности."

#: ../../faq/library.rst:837
msgid "``shuffle(L)`` shuffles a list in-place, i.e. permutes it randomly."
msgstr ""
"``shuffle(L)`` перемешивает список на месте, т.е. переставляет его случайным "
"образом."

#: ../../faq/library.rst:839
msgid ""
"There's also a ``Random`` class you can instantiate to create independent "
"multiple random number generators."
msgstr ""
"Существует также класс ``Random``, который вы можете создать для создания "
"нескольких независимых генераторов случайных чисел."
