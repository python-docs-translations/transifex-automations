# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Dmitry Luschan, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-21 14:13+0000\n"
"PO-Revision-Date: 2025-09-16 00:02+0000\n"
"Last-Translator: Dmitry Luschan, 2025\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../tutorial/classes.rst:5
msgid "Classes"
msgstr "Классы"

#: ../../tutorial/classes.rst:7
msgid ""
"Classes provide a means of bundling data and functionality together.  "
"Creating a new class creates a new *type* of object, allowing new "
"*instances* of that type to be made.  Each class instance can have "
"attributes attached to it for maintaining its state.  Class instances can "
"also have methods (defined by its class) for modifying its state."
msgstr ""
"Классы предоставляют средства для объединения данных с функциональностью. "
"При создании нового класса создается новый *тип* объекта, что позволяет "
"создавать новые *экземпляры* этого типа. Каждый экземпляр класса может иметь "
"связанные с ним атрибуты, сохраняющие его состояние. Экземпляры класса также "
"могут иметь методы (объявленные в классе), изменяющие его состояние."

#: ../../tutorial/classes.rst:13
msgid ""
"Compared with other programming languages, Python's class mechanism adds "
"classes with a minimum of new syntax and semantics.  It is a mixture of the "
"class mechanisms found in C++ and Modula-3.  Python classes provide all the "
"standard features of Object Oriented Programming: the class inheritance "
"mechanism allows multiple base classes, a derived class can override any "
"methods of its base class or classes, and a method can call the method of a "
"base class with the same name.  Objects can contain arbitrary amounts and "
"kinds of data.  As is true for modules, classes partake of the dynamic "
"nature of Python: they are created at runtime, and can be modified further "
"after creation."
msgstr ""
"По сравнению с другими языками программирования, механизм классов в Python "
"добавляет классы с минимумом нового синтаксиса и семантики. Это смесь "
"механизмов классов из C++ и Modula-3. Классы в Python предоставляют полный "
"набор стандартных возможностей Объектно-Ориентированного Программирования: "
"механизм наследования  поддерживает множественные базовые классы, "
"производные классы могут переопределять любые методы своего базового класса "
"или классов, и методы могут вызывать методы базовых классов с такими же "
"именами. Объекты могут содержать данные произвольного объема и вида. Как и "
"модули, классы обладают динамической природой Python: они создаются во время "
"выполнения и могут быть изменены позже после создания."

#: ../../tutorial/classes.rst:23
msgid ""
"In C++ terminology, normally class members (including the data members) are "
"*public* (except see below :ref:`tut-private`), and all member functions are "
"*virtual*.  As in Modula-3, there are no shorthands for referencing the "
"object's members from its methods: the method function is declared with an "
"explicit first argument representing the object, which is provided "
"implicitly by the call.  As in Smalltalk, classes themselves are objects.  "
"This provides semantics for importing and renaming.  Unlike C++ and "
"Modula-3, built-in types can be used as base classes for extension by the "
"user.  Also, like in C++, most built-in operators with special syntax "
"(arithmetic operators, subscripting etc.) can be redefined for class "
"instances."
msgstr ""
"В терминологии C++, обычно члены класса (включая данные) являются "
"*публичными* (об исключениях читайте ниже :ref:`tut-private`), а все функции-"
"члены — *виртуальными*. Как и в Modula-3, здесь нет сокращений для доступа к "
"элементам объекта из его методов: функция-метод объявляется с явным первым "
"аргументом, представляющим объект, который неявно подставляется при вызове. "
"Как и в Smalltalk, сами классы являются объектами. Это обеспечивает "
"семантику импорта и переименования. В отличие от C++ и Modula-3, встроенные "
"типы могут использоваться как базовые классы для расширения пользователем. "
"Так же, как и в C++, большинство встроенных операторов со специальным "
"синтаксисом (арифметические операторы, индексирование и т. д.) могут быть "
"переопределены для экземпляров класса."

#: ../../tutorial/classes.rst:34
msgid ""
"(Lacking universally accepted terminology to talk about classes, I will make "
"occasional use of Smalltalk and C++ terms.  I would use Modula-3 terms, "
"since its object-oriented semantics are closer to those of Python than C++, "
"but I expect that few readers have heard of it.)"
msgstr ""
"(Не имея общепринятой терминологии, чтобы говорить о классах, я буду время "
"от времени использовать термины Smalltalk и C++. Я бы использовал "
"терминологию Modula-3, поскольку его объектно-ориентированная семантика "
"ближе к Python, чем C++, но я думаю, что мало читателей знакомы с этим "
"языком.)"

#: ../../tutorial/classes.rst:43
msgid "A Word About Names and Objects"
msgstr "Несколько слов об именах и объектах"

#: ../../tutorial/classes.rst:45
msgid ""
"Objects have individuality, and multiple names (in multiple scopes) can be "
"bound to the same object.  This is known as aliasing in other languages.  "
"This is usually not appreciated on a first glance at Python, and can be "
"safely ignored when dealing with immutable basic types (numbers, strings, "
"tuples).  However, aliasing has a possibly surprising effect on the "
"semantics of Python code involving mutable objects such as lists, "
"dictionaries, and most other types. This is usually used to the benefit of "
"the program, since aliases behave like pointers in some respects.  For "
"example, passing an object is cheap since only a pointer is passed by the "
"implementation; and if a function modifies an object passed as an argument, "
"the caller will see the change --- this eliminates the need for two "
"different argument passing mechanisms as in Pascal."
msgstr ""
"Объекты имеют индивидуальность, и множество имен (в разных областях "
"видимости) могут быть связаны с одним объектом. В других языках это "
"называется псевдонимами. Обычно это не принимается во внимание при первом "
"знакомстве с Python, и это можно спокойно игнорировать при работе с "
"неизменяемыми основными типами (числами, строками, кортежами). Однако "
"псевдонимы могут иметь неожиданный эффект на семантику кода Python, "
"включающего изменяемые объекты, такие как списки, словари и большинство "
"других типов. Обычно это используется на пользу программы, поскольку "
"псевдонимы в некоторых отношениях ведут себя как указатели. Например, "
"передача объекта в функцию дешёвая, поскольку реализация передаёт только "
"указатель на него. Если функция изменяет объект, переданный ей в качестве "
"аргумента, вызывающий код увидит это изменение — это устраняет необходимость "
"в двух различных механизмах передачи аргументов, как в Pascal."

#: ../../tutorial/classes.rst:61
msgid "Python Scopes and Namespaces"
msgstr "Области видимости и пространства имён в Python"

#: ../../tutorial/classes.rst:63
msgid ""
"Before introducing classes, I first have to tell you something about "
"Python's scope rules.  Class definitions play some neat tricks with "
"namespaces, and you need to know how scopes and namespaces work to fully "
"understand what's going on. Incidentally, knowledge about this subject is "
"useful for any advanced Python programmer."
msgstr ""
"Прежде чем представить классы, я должен сначала рассказать кое-что о "
"правилах области видимости в Python. Определения классов проделывают "
"некоторые хитрые трюки с пространством имён, и вы должны знать, как работают "
"области видимости и пространства имён, чтобы полностью понимать, что "
"происходит. Кстати, эти знания полезны для любого продвинутого программиста "
"на Python."

#: ../../tutorial/classes.rst:69
msgid "Let's begin with some definitions."
msgstr "Давайте начнём с некоторых определений."

#: ../../tutorial/classes.rst:71
msgid ""
"A *namespace* is a mapping from names to objects.  Most namespaces are "
"currently implemented as Python dictionaries, but that's normally not "
"noticeable in any way (except for performance), and it may change in the "
"future.  Examples of namespaces are: the set of built-in names (containing "
"functions such as :func:`abs`, and built-in exception names); the global "
"names in a module; and the local names in a function invocation.  In a sense "
"the set of attributes of an object also form a namespace.  The important "
"thing to know about namespaces is that there is absolutely no relation "
"between names in different namespaces; for instance, two different modules "
"may both define a function ``maximize`` without confusion --- users of the "
"modules must prefix it with the module name."
msgstr ""
"*Пространство имен* — это отображение имён на объекты. Большинство "
"пространств имён в настоящее время реализованы как словари Python, но обычно "
"это незаметно (за исключением производительности) и может измениться в "
"будущем. Примерами пространств имён являются: набор встроенных имён (включая "
"функции, такие как :func:`abs`, и встроенные имена исключений); глобальные "
"имена в модуле; локальные имена в вызове функции. В некотором смысле, набор "
"атрибутов объекта тоже образует пространство имён. Важная деталь, которую "
"нужно знать о пространствах имён — это то, что нет совершенно никакой связи "
"между именами из разных пространств имён; например, в двух разных модулях "
"может быть определена функция ``maximize`` без какой-либо путаницы — "
"пользователи модуля должны использовать  имя модуля в качестве префикса при "
"вызове функции."

#: ../../tutorial/classes.rst:82
msgid ""
"By the way, I use the word *attribute* for any name following a dot --- for "
"example, in the expression ``z.real``, ``real`` is an attribute of the "
"object ``z``.  Strictly speaking, references to names in modules are "
"attribute references: in the expression ``modname.funcname``, ``modname`` is "
"a module object and ``funcname`` is an attribute of it.  In this case there "
"happens to be a straightforward mapping between the module's attributes and "
"the global names defined in the module: they share the same namespace!  [#]_"
msgstr ""
"Кстати, я использую слово *атрибут* для любого имени, следующего после точки "
"— например, в выражении ``z.real``, ``real`` — это атрибут объекта ``z``. "
"Строго говоря, обращения к именам в модулях являются обращением к атрибутам: "
"в выражении ``modname.funcname``, ``modname`` является объектом модуля, и "
"``funcname`` является его атрибутом. В этом случае есть прямое соответствие "
"между атрибутами модуля и глобальными именами, объявленными в модуле: они "
"используют одно и то же пространство имён! [#]_"

#: ../../tutorial/classes.rst:90
msgid ""
"Attributes may be read-only or writable.  In the latter case, assignment to "
"attributes is possible.  Module attributes are writable: you can write "
"``modname.the_answer = 42``.  Writable attributes may also be deleted with "
"the :keyword:`del` statement.  For example, ``del modname.the_answer`` will "
"remove the attribute :attr:`!the_answer` from the object named by "
"``modname``."
msgstr ""
"Атрибуты могут быть доступными только для чтения или изменяемыми. В "
"последнем случае возможно присваивание атрибутам. Атрибуты модуля изменяемы: "
"вы можете записать ``modname.the_answer = 42``. Изменяемые атрибуты также "
"могут быть удалены с помощью инструкции :keyword:`del`. Например, ``del "
"modname.the_answer`` удалит атрибут :attr:`!the_answer` у объекта, "
"названного ``modname``."

#: ../../tutorial/classes.rst:96
msgid ""
"Namespaces are created at different moments and have different lifetimes.  "
"The namespace containing the built-in names is created when the Python "
"interpreter starts up, and is never deleted.  The global namespace for a "
"module is created when the module definition is read in; normally, module "
"namespaces also last until the interpreter quits.  The statements executed "
"by the top-level invocation of the interpreter, either read from a script "
"file or interactively, are considered part of a module called :mod:"
"`__main__`, so they have their own global namespace.  (The built-in names "
"actually also live in a module; this is called :mod:`builtins`.)"
msgstr ""
"Пространства имён создаются в разное время и имеют разные времена жизни. "
"Пространство имён, содержащее встроенные имена, создаётся при запуске "
"интерпретатора Python и никогда не удаляется. Глобальное пространство имён "
"модуля создаётся при чтении определения модуля; обычно оно существует до "
"завершения работы интерпретатора. Инструкции, исполняемые на верхнем уровне "
"работы интерпретатора, считываемые из файла скрипта или интерактивно, "
"считаются частью модуля :mod:`__main__`, поэтому относятся к собственному "
"глобальному пространству имён. (Встроенные имена также существуют в модуле; "
"он называется :mod:`builtins`.)"

#: ../../tutorial/classes.rst:106
msgid ""
"The local namespace for a function is created when the function is called, "
"and deleted when the function returns or raises an exception that is not "
"handled within the function.  (Actually, forgetting would be a better way to "
"describe what actually happens.)  Of course, recursive invocations each have "
"their own local namespace."
msgstr ""
"Локальное пространство имён функции создаётся в момент вызова функции и "
"удаляется, когда функция возвращает значение или выбрасывает не "
"обрабатываемое внутри неё исключение. (На самом деле, забывание было бы "
"лучшим способом описать то, что происходит.) Разумеется, каждый рекурсивный "
"вызов имеет своё собственное пространство имён."

#: ../../tutorial/classes.rst:112
msgid ""
"A *scope* is a textual region of a Python program where a namespace is "
"directly accessible.  \"Directly accessible\" here means that an unqualified "
"reference to a name attempts to find the name in the namespace."
msgstr ""
"*Область видимости* — это текстовая область программы Python, в которой "
"пространство имён доступно напрямую. \"Доступно напрямую\" здесь означает, "
"что обращение к имени без префикса пытается найти его в этом пространстве "
"имён."

#: ../../tutorial/classes.rst:116
msgid ""
"Although scopes are determined statically, they are used dynamically. At any "
"time during execution, there are 3 or 4 nested scopes whose namespaces are "
"directly accessible:"
msgstr ""
"Хотя области видимости определяются статически, но используются они "
"динамически. В любой момент исполнения программы у неё есть 3 или 4 "
"вложенные области видимости, чьи пространства имён доступны напрямую:"

#: ../../tutorial/classes.rst:120
msgid "the innermost scope, which is searched first, contains the local names"
msgstr ""
"самая внутренняя область видимости, которая просматривается в первую "
"очередь, содержит локальные имена"

#: ../../tutorial/classes.rst:121
msgid ""
"the scopes of any enclosing functions, which are searched starting with the "
"nearest enclosing scope, contain non-local, but also non-global names"
msgstr ""
"области видимости любых внешних функций, которые просматриваются, начиная с "
"ближайшей, содержат не локальные, но и не глобальные имена"

#: ../../tutorial/classes.rst:123
msgid "the next-to-last scope contains the current module's global names"
msgstr ""
"предпоследняя область видимости включает глобальные имена текущего модуля"

#: ../../tutorial/classes.rst:124
msgid ""
"the outermost scope (searched last) is the namespace containing built-in "
"names"
msgstr ""
"самая внешняя областью видимости (просматривается последней) является "
"пространством имён, содержащим встроенные имена"

#: ../../tutorial/classes.rst:126
msgid ""
"If a name is declared global, then all references and assignments go "
"directly to the next-to-last scope containing the module's global names.  To "
"rebind variables found outside of the innermost scope, the :keyword:"
"`nonlocal` statement can be used; if not declared nonlocal, those variables "
"are read-only (an attempt to write to such a variable will simply create a "
"*new* local variable in the innermost scope, leaving the identically named "
"outer variable unchanged)."
msgstr ""
"Если имя объявлено глобальным, то все обращения и присваивания к нему "
"передаются непосредственно в предпоследнюю область видимости, содержащую "
"глобальные имена модуля. Для переназначения переменных из внешних областей "
"видимости, можно использовать инструкцию :keyword:`nonlocal`. Без такого "
"объявления, эти переменные доступны только для чтения (попытка записи в "
"такую ​​переменную просто создаст *новую* локальную переменную во внутренней "
"области видимости, оставив внешнюю переменную с таким же именем неизменной)."

#: ../../tutorial/classes.rst:133
msgid ""
"Usually, the local scope references the local names of the (textually) "
"current function.  Outside functions, the local scope references the same "
"namespace as the global scope: the module's namespace. Class definitions "
"place yet another namespace in the local scope."
msgstr ""
"Как правило, локальная область видимости ссылается на локальные имена "
"(буквально) текущей функции. За пределами функции локальная область "
"видимости ссылается на то же пространство имён, что и глобальная область "
"видимости: пространство имён модуля. Определение класса помещает ещё одно "
"пространство имён в локальную область видимости."

#: ../../tutorial/classes.rst:138
msgid ""
"It is important to realize that scopes are determined textually: the global "
"scope of a function defined in a module is that module's namespace, no "
"matter from where or by what alias the function is called.  On the other "
"hand, the actual search for names is done dynamically, at run time --- "
"however, the language definition is evolving towards static name resolution, "
"at \"compile\" time, so don't rely on dynamic name resolution!  (In fact, "
"local variables are already determined statically.)"
msgstr ""
"Важно понимать, что области видимости определяются буквально: глобальная "
"область видимости функции определяется модулем, в котором эта функция "
"определена, независимо от того, откуда или под каким именем она вызывается. "
"С другой стороны, фактический поиск имён выполняется динамически, во время "
"выполнения кода. Однако язык постепенно движется в сторону статического "
"разрешения имён на «этапе компиляции», поэтому не стоит полагаться на "
"динамическое разрешение! (На самом деле локальные переменные уже "
"определяются статически.)"

#: ../../tutorial/classes.rst:146
msgid ""
"A special quirk of Python is that -- if no :keyword:`global` or :keyword:"
"`nonlocal` statement is in effect -- assignments to names always go into the "
"innermost scope. Assignments do not copy data --- they just bind names to "
"objects.  The same is true for deletions: the statement ``del x`` removes "
"the binding of ``x`` from the namespace referenced by the local scope.  In "
"fact, all operations that introduce new names use the local scope: in "
"particular, :keyword:`import` statements and function definitions bind the "
"module or function name in the local scope."
msgstr ""
"Особой причудой Python является то, что если не задействованы инструкции :"
"keyword:`global` или :keyword:`nonlocal`, то присваивание имён направлены в "
"самую глубокую область видимости. Присваивание не копирует данные — оно лишь "
"связывает имена с объектами. То же верно и для удаления: инструкция ``del "
"x`` удаляет привязку ``x`` из пространства имён локальной области видимости. "
"Фактически, все операции, которые вводят новые имена, используют локальную "
"область видимости: в частности, инструкция :keyword:`import` и определение "
"функций связывают имя модуля или функции в локальной области видимости."

#: ../../tutorial/classes.rst:154
msgid ""
"The :keyword:`global` statement can be used to indicate that particular "
"variables live in the global scope and should be rebound there; the :keyword:"
"`nonlocal` statement indicates that particular variables live in an "
"enclosing scope and should be rebound there."
msgstr ""
"Инструкция :keyword:`global` указывает, что конкретные переменные находятся "
"в глобальной области видимости и должны переназначаться там. Аналогично, "
"инструкция :keyword:`nonlocal` объявляет, что конкретные переменные "
"находятся во внешней области видимости и должны переназначаться в ней."

#: ../../tutorial/classes.rst:162
msgid "Scopes and Namespaces Example"
msgstr "Пример областей видимости и пространств имён"

#: ../../tutorial/classes.rst:164
msgid ""
"This is an example demonstrating how to reference the different scopes and "
"namespaces, and how :keyword:`global` and :keyword:`nonlocal` affect "
"variable binding::"
msgstr ""
"Вот демонстрация того, как обращаться к разным областям видимости и "
"пространствам имён, и как :keyword:`global` и :keyword:`nonlocal` влияют на "
"привязку переменных::"

#: ../../tutorial/classes.rst:168
msgid ""
"def scope_test():\n"
"    def do_local():\n"
"        spam = \"local spam\"\n"
"\n"
"    def do_nonlocal():\n"
"        nonlocal spam\n"
"        spam = \"nonlocal spam\"\n"
"\n"
"    def do_global():\n"
"        global spam\n"
"        spam = \"global spam\"\n"
"\n"
"    spam = \"test spam\"\n"
"    do_local()\n"
"    print(\"After local assignment:\", spam)\n"
"    do_nonlocal()\n"
"    print(\"After nonlocal assignment:\", spam)\n"
"    do_global()\n"
"    print(\"After global assignment:\", spam)\n"
"\n"
"scope_test()\n"
"print(\"In global scope:\", spam)"
msgstr ""
"def scope_test():\n"
"    def do_local():\n"
"        spam = \"локальный спам\"\n"
"\n"
"    def do_nonlocal():\n"
"        nonlocal spam\n"
"        spam = \"нелокальный спам\"\n"
"\n"
"    def do_global():\n"
"        global spam\n"
"        spam = \"глобальный спам\"\n"
"\n"
"    spam = \"тестовый спам\"\n"
"    do_local()\n"
"    print(\"После локального присваивания:\", spam)\n"
"    do_nonlocal()\n"
"    print(\"После нелокального присваивания:\", spam)\n"
"    do_global()\n"
"    print(\"После глобального присваивания:\", spam)\n"
"\n"
"scope_test()\n"
"print(\"В глобальной области видимости:\", spam)"

#: ../../tutorial/classes.rst:191
msgid "The output of the example code is:"
msgstr "При выполнении кода будет выведено следующее:"

#: ../../tutorial/classes.rst:193
msgid ""
"After local assignment: test spam\n"
"After nonlocal assignment: nonlocal spam\n"
"After global assignment: nonlocal spam\n"
"In global scope: global spam"
msgstr ""
"После локального присваивания: тестовый спам\n"
"После нелокального присваивания: нелокальный спам\n"
"После глобального присваивания: нелокальный спам\n"
"В глобальной области видимости: глобальный спам"

#: ../../tutorial/classes.rst:200
msgid ""
"Note how the *local* assignment (which is default) didn't change "
"*scope_test*\\'s binding of *spam*.  The :keyword:`nonlocal` assignment "
"changed *scope_test*\\'s binding of *spam*, and the :keyword:`global` "
"assignment changed the module-level binding."
msgstr ""
"Заметьте, как *локальное* присваивание (используемое по умолчанию) не "
"изменяет значение переменной *spam* в *scope_test*. С другой стороны, "
"присваивание с использованием ключевого слова :keyword:`nonlocal` изменило "
"значение *spam* в *scope test*, и присваивание с использованием :keyword:"
"`global` изменяет переменные на уровне модуля."

#: ../../tutorial/classes.rst:205
msgid ""
"You can also see that there was no previous binding for *spam* before the :"
"keyword:`global` assignment."
msgstr ""
"Также можно увидеть, что до присваивания *spam* с использованием :keyword:"
"`global` не существовало привязки этого имени в области видимости модуля."

#: ../../tutorial/classes.rst:212
msgid "A First Look at Classes"
msgstr "Первый взгляд на классы"

#: ../../tutorial/classes.rst:214
msgid ""
"Classes introduce a little bit of new syntax, three new object types, and "
"some new semantics."
msgstr ""
"Классы привносят немного нового синтаксиса, три новых типа объектов и новую "
"семантику."

#: ../../tutorial/classes.rst:221
msgid "Class Definition Syntax"
msgstr "Синтаксис определения класса"

#: ../../tutorial/classes.rst:223
msgid "The simplest form of class definition looks like this::"
msgstr "Самая простая форма определения класса выглядит так::"

#: ../../tutorial/classes.rst:225
msgid ""
"class ClassName:\n"
"    <statement-1>\n"
"    .\n"
"    .\n"
"    .\n"
"    <statement-N>"
msgstr ""
"class ClassName:\n"
"    <statement-1>\n"
"    .\n"
"    .\n"
"    .\n"
"    <statement-N>"

#: ../../tutorial/classes.rst:232
msgid ""
"Class definitions, like function definitions (:keyword:`def` statements) "
"must be executed before they have any effect.  (You could conceivably place "
"a class definition in a branch of an :keyword:`if` statement, or inside a "
"function.)"
msgstr ""
"Определение класса, как и определение функции (инструкция :keyword:`def`), "
"должно быть выполнено перед тем, как оно будет иметь эффект. (Можно "
"поместить определение класса в ветку инструкции :keyword:`if` или внутри "
"функции.)"

#: ../../tutorial/classes.rst:236
msgid ""
"In practice, the statements inside a class definition will usually be "
"function definitions, but other statements are allowed, and sometimes useful "
"--- we'll come back to this later.  The function definitions inside a class "
"normally have a peculiar form of argument list, dictated by the calling "
"conventions for methods --- again, this is explained later."
msgstr ""
"На практике, чаще всего, инструкции внутри определения класса — это "
"определения функций, но другие инструкции там тоже возможны и бывают полезны "
"— мы вернёмся к этому позже. Определения функций внутри класса имеют "
"своеобразную форму списка аргументов, продиктованную соглашениями о вызовах "
"методов — опять же, это будет объяснено позже."

#: ../../tutorial/classes.rst:242
msgid ""
"When a class definition is entered, a new namespace is created, and used as "
"the local scope --- thus, all assignments to local variables go into this "
"new namespace.  In particular, function definitions bind the name of the new "
"function here."
msgstr ""
"При входе в определение класса создаётся новое пространство имён, и оно "
"используется в качестве локальной области видимости. Поэтому все операции "
"присваивания к локальным переменнам будут направлены в это новое "
"пространство имён. В частности, определения функций привяжут функции к их "
"именам именно в этом пространстве имён."

#: ../../tutorial/classes.rst:247
msgid ""
"When a class definition is left normally (via the end), a *class object* is "
"created.  This is basically a wrapper around the contents of the namespace "
"created by the class definition; we'll learn more about class objects in the "
"next section.  The original local scope (the one in effect just before the "
"class definition was entered) is reinstated, and the class object is bound "
"here to the class name given in the class definition header (:class:`!"
"ClassName` in the example)."
msgstr ""
"Когда определение класса заканчивается (обычным завершением блока), "
"создается *объект класса*. По сути, это обёртка вокруг содержимого "
"пространства имён, созданного определением класса. Мы узнаем больше об "
"объектах классов в следующем разделе. Исходная локальная область видимости "
"(которая действовала непосредственно перед входом в определение класса) "
"восстанавливается, и объект класса привязывается здесь к имени, указанному в "
"заголовке определения класса (:class:`!ClassName` в примере)."

#: ../../tutorial/classes.rst:259
msgid "Class Objects"
msgstr "Объекты классов"

#: ../../tutorial/classes.rst:261
msgid ""
"Class objects support two kinds of operations: attribute references and "
"instantiation."
msgstr ""
"Объекты классов поддерживают два вида операций: обращение к атрибутам и "
"создание экземпляров."

#: ../../tutorial/classes.rst:264
msgid ""
"*Attribute references* use the standard syntax used for all attribute "
"references in Python: ``obj.name``.  Valid attribute names are all the names "
"that were in the class's namespace when the class object was created.  So, "
"if the class definition looked like this::"
msgstr ""
"*Обращение к атрибуту* использует стандартный в Python синтаксис для "
"получения доступа к любым атрибутам: ``obj.name``. Допустимыми именами "
"атрибутов считаются те имена, которые находились в пространстве имён класса "
"во время его создания. Таким образом, если определение класса выглядит так::"

#: ../../tutorial/classes.rst:269
msgid ""
"class MyClass:\n"
"    \"\"\"A simple example class\"\"\"\n"
"    i = 12345\n"
"\n"
"    def f(self):\n"
"        return 'hello world'"
msgstr ""
"class MyClass:\n"
"    \"\"\"A simple example class\"\"\"\n"
"    i = 12345\n"
"\n"
"    def f(self):\n"
"        return 'hello world'"

#: ../../tutorial/classes.rst:276
msgid ""
"then ``MyClass.i`` and ``MyClass.f`` are valid attribute references, "
"returning an integer and a function object, respectively. Class attributes "
"can also be assigned to, so you can change the value of ``MyClass.i`` by "
"assignment. :attr:`~type.__doc__` is also a valid attribute, returning the "
"docstring belonging to the class: ``\"A simple example class\"``."
msgstr ""
"то ``MyClass.i`` и ``MyClass.f`` являются корректными обращениями к "
"атрибутам, возвращающими соответственно целое число и объект функции. "
"Атрибутам класса также можно присваивать, поэтому вы можете изменить "
"значение ``MyClass.i``. Также существует атрибут :attr:`~type.__doc__`, "
"возвращающий строку документации, принадлежащую классу: ``\"A simple example "
"class\"``."

#: ../../tutorial/classes.rst:282
msgid ""
"Class *instantiation* uses function notation.  Just pretend that the class "
"object is a parameterless function that returns a new instance of the class. "
"For example (assuming the above class)::"
msgstr ""
"*Создание экземпляра* класса использует синтаксис вызова функции. Достаточно "
"представить, что объект класса — это функция без параметров, которая "
"возвращает новый экземпляр этого класса. Например (используя определённый "
"выше класс)::"

#: ../../tutorial/classes.rst:286 ../../tutorial/classes.rst:303
msgid "x = MyClass()"
msgstr "x = MyClass()"

#: ../../tutorial/classes.rst:288
msgid ""
"creates a new *instance* of the class and assigns this object to the local "
"variable ``x``."
msgstr ""
"создаёт новый *экземпляр* класса и сохраняет этот объект в локальную "
"переменную ``x``."

#: ../../tutorial/classes.rst:291
msgid ""
"The instantiation operation (\"calling\" a class object) creates an empty "
"object. Many classes like to create objects with instances customized to a "
"specific initial state. Therefore a class may define a special method named :"
"meth:`~object.__init__`, like this::"
msgstr ""
"Операция создания экземпляра («вызов» объекта класса) создаёт пустой объект. "
"Многим классам нравится создавать объекты, инициализированные определённым "
"начальным состоянием. Поэтому класс может определить специальный метод с "
"именем :meth:`~object.__init__`, например:"

#: ../../tutorial/classes.rst:296
msgid ""
"def __init__(self):\n"
"    self.data = []"
msgstr ""
"def __init__(self):\n"
"    self.data = []"

#: ../../tutorial/classes.rst:299
msgid ""
"When a class defines an :meth:`~object.__init__` method, class instantiation "
"automatically invokes :meth:`!__init__` for the newly created class "
"instance.  So in this example, a new, initialized instance can be obtained "
"by::"
msgstr ""
"Когда класс определяет метод :meth:`~object.__init__`, создание экземпляра "
"класса автоматически вызывает :meth:`!__init__` для вновь созданного "
"экземпляра класса. Итак, в этом примере новый инициализированный экземпляр "
"можно получить следующим образом:"

#: ../../tutorial/classes.rst:305
msgid ""
"Of course, the :meth:`~object.__init__` method may have arguments for "
"greater flexibility.  In that case, arguments given to the class "
"instantiation operator are passed on to :meth:`!__init__`.  For example, ::"
msgstr ""
"Конечно, метод :meth:`~object.__init__` может иметь аргументы для большей "
"гибкости. В этом случае аргументы, переданные оператору создания экземпляра "
"класса, передаются в :meth:`!__init__`. Например, ::"

#: ../../tutorial/classes.rst:309
msgid ""
">>> class Complex:\n"
"...     def __init__(self, realpart, imagpart):\n"
"...         self.r = realpart\n"
"...         self.i = imagpart\n"
"...\n"
">>> x = Complex(3.0, -4.5)\n"
">>> x.r, x.i\n"
"(3.0, -4.5)"
msgstr ""
">>> class Complex:\n"
"...     def __init__(self, realpart, imagpart):\n"
"...         self.r = realpart\n"
"...         self.i = imagpart\n"
"...\n"
">>> x = Complex(3.0, -4.5)\n"
">>> x.r, x.i\n"
"(3.0, -4.5)"

#: ../../tutorial/classes.rst:322
msgid "Instance Objects"
msgstr "Объекты экземпляров"

#: ../../tutorial/classes.rst:324
msgid ""
"Now what can we do with instance objects?  The only operations understood by "
"instance objects are attribute references.  There are two kinds of valid "
"attribute names: data attributes and methods."
msgstr ""
"Что мы можем делать с объектами-экземплярами? Единственная операция, которую "
"понимают экземпляры — обращение к атрибутам. Есть два вида допустимых имён "
"атрибутов: данные и методы."

#: ../../tutorial/classes.rst:328
msgid ""
"*Data attributes* correspond to \"instance variables\" in Smalltalk, and to "
"\"data members\" in C++.  Data attributes need not be declared; like local "
"variables, they spring into existence when they are first assigned to.  For "
"example, if ``x`` is the instance of :class:`!MyClass` created above, the "
"following piece of code will print the value ``16``, without leaving a "
"trace::"
msgstr ""
"*Атрибуты-данные* соответствуют «переменным экземпляра» в Smalltalk и "
"«членам данных» в C++. Атрибуты данных не нужно объявлять; как и локальные "
"переменные, они возникают, когда им впервые присваиваются значения. "
"Например, если ``x`` является экземпляром :class:`!MyClass`, созданным выше, "
"следующий фрагмент кода напечатает значение ``16``, не оставив после себя "
"никаких следов::"

#: ../../tutorial/classes.rst:334
msgid ""
"x.counter = 1\n"
"while x.counter < 10:\n"
"    x.counter = x.counter * 2\n"
"print(x.counter)\n"
"del x.counter"
msgstr ""
"x.counter = 1\n"
"while x.counter < 10:\n"
"    x.counter = x.counter * 2\n"
"print(x.counter)\n"
"del x.counter"

#: ../../tutorial/classes.rst:340
msgid ""
"The other kind of instance attribute reference is a *method*. A method is a "
"function that \"belongs to\" an object."
msgstr ""
"Другой вид атрибута экземпляра — *метод*. Метод — это функция, которая "
"«принадлежит» объекту."

#: ../../tutorial/classes.rst:345
msgid ""
"Valid method names of an instance object depend on its class.  By "
"definition, all attributes of a class that are function  objects define "
"corresponding methods of its instances.  So in our example, ``x.f`` is a "
"valid method reference, since ``MyClass.f`` is a function, but ``x.i`` is "
"not, since ``MyClass.i`` is not.  But ``x.f`` is not the same thing as "
"``MyClass.f`` --- it is a *method object*, not a function object."
msgstr ""
"Методы, доступные у объекту-экземпляру, зависят от его класса. По "
"определению, все атрибуты класса, которые являются функциями, создают "
"соответствующие методы у его экземпляров. В нашем примере ``x.f`` — ссылка "
"на метод, потому что ``MyClass.f`` — это функция; в отличие от ``x.i``, "
"потому что ``MyClass.i`` не является функцией. Но ``x.f`` — не то же самое, "
"что ``MyClass.f`` — это *объект метода*, а не объект функции."

#: ../../tutorial/classes.rst:356
msgid "Method Objects"
msgstr "Объекта методов"

#: ../../tutorial/classes.rst:358
msgid "Usually, a method is called right after it is bound::"
msgstr "Обычно метод вызывается сразу после обращения к нему::"

#: ../../tutorial/classes.rst:360
msgid "x.f()"
msgstr "x.f()"

#: ../../tutorial/classes.rst:362
msgid ""
"If ``x = MyClass()``, as above, this will return the string ``'hello "
"world'``. However, it is not necessary to call a method right away: ``x.f`` "
"is a method object, and can be stored away and called at a later time.  For "
"example::"
msgstr ""
"Если ``x = MyClass()``, как указано выше, этот вызов вернёт строку ``'hello "
"world'``. Однако вызывать метод сразу необязательно: ``x.f`` — это объект-"
"метод, его можно сохранить и вызвать позже. Например::"

#: ../../tutorial/classes.rst:366
msgid ""
"xf = x.f\n"
"while True:\n"
"    print(xf())"
msgstr ""
"xf = x.f\n"
"while True:\n"
"    print(xf())"

#: ../../tutorial/classes.rst:370
msgid "will continue to print ``hello world`` until the end of time."
msgstr "будет продолжать печатать ``hello world`` до конца времён."

#: ../../tutorial/classes.rst:372
msgid ""
"What exactly happens when a method is called?  You may have noticed that ``x."
"f()`` was called without an argument above, even though the function "
"definition for :meth:`!f` specified an argument.  What happened to the "
"argument? Surely Python raises an exception when a function that requires an "
"argument is called without any --- even if the argument isn't actually "
"used..."
msgstr ""
"Что же именно происходит при вызове метода? Вы могли заметить, что ``x.f()`` "
"был вызван без аргумента, хотя в определении функции :meth:`!f` указан "
"аргумент. Куда же он подевался? Разумеется, Python должен выбросить "
"исключение, если вызвать функцию, которой нужен аргумент, без него — даже "
"если аргумент на самом деле не используется…"

#: ../../tutorial/classes.rst:378
msgid ""
"Actually, you may have guessed the answer: the special thing about methods "
"is that the instance object is passed as the first argument of the "
"function.  In our example, the call ``x.f()`` is exactly equivalent to "
"``MyClass.f(x)``.  In general, calling a method with a list of *n* arguments "
"is equivalent to calling the corresponding function with an argument list "
"that is created by inserting the method's instance object before the first "
"argument."
msgstr ""
"На самом деле, вы, вероятно, уже догадались: особенность методов в том, что "
"объект-экземпляр передаётся в функцию как первый аргумент. В нашем примере "
"вызов ``x.f()`` полностью совпадает с ``MyClass.f(x)``. Вообще, вызов метода "
"со списком из *n* аргументов эквивалентен вызову соответствующей функции со "
"списком аргументов, полученным вставкой объекта-экземпляра метода перед "
"первым аргументом."

#: ../../tutorial/classes.rst:385
msgid ""
"In general, methods work as follows.  When a non-data attribute of an "
"instance is referenced, the instance's class is searched. If the name "
"denotes a valid class attribute that is a function object, references to "
"both the instance object and the function object are packed into a method "
"object.  When the method object is called with an argument list, a new "
"argument list is constructed from the instance object and the argument list, "
"and the function object is called with this new argument list."
msgstr ""
"В целом методы работают следующим образом. Когда у экземпляра запрашивается "
"атрибут, который не является данными, происходит поиск в классе экземпляра. "
"Если найденный атрибут является функцией, то ссылка на объект-экземпляр и "
"функция упаковываются в объект-метод. Когда объект-метод вызывается с "
"некоторым списком аргументов, создаётся новый список из объекта-экземпляра и "
"этих аргументов, и затем функция вызывается с этим новым списком аргументов."

#: ../../tutorial/classes.rst:398
msgid "Class and Instance Variables"
msgstr "Переменные класса и экземпляра"

#: ../../tutorial/classes.rst:400
msgid ""
"Generally speaking, instance variables are for data unique to each instance "
"and class variables are for attributes and methods shared by all instances "
"of the class::"
msgstr ""
"Вообще говоря, переменные экземпляра предназначены для данных, уникальных "
"для каждого экземпляра, а переменные класса — для атрибутов и методов, общих "
"для всех экземпляров класса::"

#: ../../tutorial/classes.rst:404
msgid ""
"class Dog:\n"
"\n"
"    kind = 'canine'         # class variable shared by all instances\n"
"\n"
"    def __init__(self, name):\n"
"        self.name = name    # instance variable unique to each instance\n"
"\n"
">>> d = Dog('Fido')\n"
">>> e = Dog('Buddy')\n"
">>> d.kind                  # shared by all dogs\n"
"'canine'\n"
">>> e.kind                  # shared by all dogs\n"
"'canine'\n"
">>> d.name                  # unique to d\n"
"'Fido'\n"
">>> e.name                  # unique to e\n"
"'Buddy'"
msgstr ""
"class Dog:\n"
"\n"
"    kind = 'собачий'         # переменная класса, общая для всех "
"экземпляров\n"
"\n"
"    def __init__(self, name):\n"
"        self.name = name    # переменная экземпляра, уникальная для каждого "
"объекта\n"
"\n"
">>> d = Dog('Фидо')\n"
">>> e = Dog('Бадди')\n"
">>> d.kind                  # общее для всех собак\n"
"'собачий'\n"
">>> e.kind                  # общее для всех собак\n"
"'собачий'\n"
">>> d.name                  # уникально для d\n"
"'Фидо'\n"
">>> e.name                  # уникально для e\n"
"'Бадди'"

#: ../../tutorial/classes.rst:422
msgid ""
"As discussed in :ref:`tut-object`, shared data can have possibly surprising "
"effects with involving :term:`mutable` objects such as lists and "
"dictionaries. For example, the *tricks* list in the following code should "
"not be used as a class variable because just a single list would be shared "
"by all *Dog* instances::"
msgstr ""
"Как обсуждалось в :ref:`tut-object`, разделяемые данные могут привести к "
"неожиданным последствиям, если они являются :term:`изменяемыми` объектами, "
"как списки и словари. Например, список *tricks* в следующем коде не следует "
"использовать как переменную класса, так как в противном случае один и тот же "
"список будет разделяться всеми экземплярами *Dog*::"

#: ../../tutorial/classes.rst:428
msgid ""
"class Dog:\n"
"\n"
"    tricks = []             # mistaken use of a class variable\n"
"\n"
"    def __init__(self, name):\n"
"        self.name = name\n"
"\n"
"    def add_trick(self, trick):\n"
"        self.tricks.append(trick)\n"
"\n"
">>> d = Dog('Fido')\n"
">>> e = Dog('Buddy')\n"
">>> d.add_trick('roll over')\n"
">>> e.add_trick('play dead')\n"
">>> d.tricks                # unexpectedly shared by all dogs\n"
"['roll over', 'play dead']"
msgstr ""
"class Dog:\n"
"\n"
"    tricks = []             # ошибочное использование переменной класса\n"
"\n"
"    def __init__(self, name):\n"
"        self.name = name\n"
"\n"
"    def add_trick(self, trick):\n"
"        self.tricks.append(trick)\n"
"\n"
">>> d = Dog('Фидо')\n"
">>> e = Dog('Бадди')\n"
">>> d.add_trick('сделать переворот')\n"
">>> e.add_trick('прикинуться мёртвым')\n"
">>> d.tricks                # неожиданно общие данные для всех собак\n"
"['сделать переворот', 'прикинуться мёртвым']"

#: ../../tutorial/classes.rst:445
msgid "Correct design of the class should use an instance variable instead::"
msgstr ""
"Правильно спроектированный класс должен использовать вместо этого переменную "
"экземпляра::"

#: ../../tutorial/classes.rst:447
msgid ""
"class Dog:\n"
"\n"
"    def __init__(self, name):\n"
"        self.name = name\n"
"        self.tricks = []    # creates a new empty list for each dog\n"
"\n"
"    def add_trick(self, trick):\n"
"        self.tricks.append(trick)\n"
"\n"
">>> d = Dog('Fido')\n"
">>> e = Dog('Buddy')\n"
">>> d.add_trick('roll over')\n"
">>> e.add_trick('play dead')\n"
">>> d.tricks\n"
"['roll over']\n"
">>> e.tricks\n"
"['play dead']"
msgstr ""
"class Dog:\n"
"\n"
"    def __init__(self, name):\n"
"        self.name = name\n"
"        self.tricks = []    # создаётся новый пустой список для каждой "
"собаки\n"
"\n"
"    def add_trick(self, trick):\n"
"        self.tricks.append(trick)\n"
"\n"
">>> d = Dog('Фидо')\n"
">>> e = Dog('Бадди')\n"
">>> d.add_trick('сделать переворот')\n"
">>> e.add_trick('прикинуться мёртвым')\n"
">>> d.tricks\n"
"['сделать переворот']\n"
">>> e.tricks\n"
"['прикинуться мёртвым']"

#: ../../tutorial/classes.rst:469
msgid "Random Remarks"
msgstr "Полезные замечания"

#: ../../tutorial/classes.rst:473
msgid ""
"If the same attribute name occurs in both an instance and in a class, then "
"attribute lookup prioritizes the instance::"
msgstr ""
"Если в классе и в экземпляре встречаются атрибуты с одинаковыми именем, "
"используется атрибут экземпляра::"

#: ../../tutorial/classes.rst:476
msgid ""
">>> class Warehouse:\n"
"...    purpose = 'storage'\n"
"...    region = 'west'\n"
"...\n"
">>> w1 = Warehouse()\n"
">>> print(w1.purpose, w1.region)\n"
"storage west\n"
">>> w2 = Warehouse()\n"
">>> w2.region = 'east'\n"
">>> print(w2.purpose, w2.region)\n"
"storage east"
msgstr ""
">>> class Warehouse:\n"
"...    purpose = 'хранение'\n"
"...    region = 'запад'\n"
"...\n"
">>> w1 = Warehouse()\n"
">>> print(w1.purpose, w1.region)\n"
"хранение запад\n"
">>> w2 = Warehouse()\n"
">>> w2.region = 'восток'\n"
">>> print(w2.purpose, w2.region)\n"
"хранение восток"

#: ../../tutorial/classes.rst:488
msgid ""
"Data attributes may be referenced by methods as well as by ordinary users "
"(\"clients\") of an object.  In other words, classes are not usable to "
"implement pure abstract data types.  In fact, nothing in Python makes it "
"possible to enforce data hiding --- it is all based upon convention.  (On "
"the other hand, the Python implementation, written in C, can completely hide "
"implementation details and control access to an object if necessary; this "
"can be used by extensions to Python written in C.)"
msgstr ""
"К атрибутам данных можно обращаться как через методы, так и через обычных "
"пользователей (\"клиентов\") объекта. Другими словами, классы не позволяют "
"реализовать чисто абстрактные типы данных. На практике, ничего в Python не "
"позволяет полностью скрыть данные — всё основано на соглашениях. (С другой "
"стороны, реализация Python на C может полностью скрыть детали реализации и "
"контролировать доступ к объекту, если это необходимо; это может "
"использоваться расширениями на C.)"

#: ../../tutorial/classes.rst:496
msgid ""
"Clients should use data attributes with care --- clients may mess up "
"invariants maintained by the methods by stamping on their data attributes.  "
"Note that clients may add data attributes of their own to an instance object "
"without affecting the validity of the methods, as long as name conflicts are "
"avoided --- again, a naming convention can save a lot of headaches here."
msgstr ""
"Клиенты должны использовать атрибуты данных осторожно — они могут нарушить "
"инварианты, поддерживаемые методами, изменяя их напрямую. Обратите внимание, "
"что клиенты могут добавлять свои собственные атрибуты к экземпляру объекта, "
"не нарушая работу методов, если избегают конфликтов имён — опять же, "
"соглашения об именах могут уберечь от множества проблем."

#: ../../tutorial/classes.rst:502
msgid ""
"There is no shorthand for referencing data attributes (or other methods!) "
"from within methods.  I find that this actually increases the readability of "
"methods: there is no chance of confusing local variables and instance "
"variables when glancing through a method."
msgstr ""
"Внутри методов нет никакой сокращённой формы для обращения к атрибутам "
"данных (или другим методам!). На самом деле, это повышает читаемость кода: "
"нет риска перепутать локальные переменные и переменные экземпляра при беглом "
"просмотре метода."

#: ../../tutorial/classes.rst:507
msgid ""
"Often, the first argument of a method is called ``self``.  This is nothing "
"more than a convention: the name ``self`` has absolutely no special meaning "
"to Python.  Note, however, that by not following the convention your code "
"may be less readable to other Python programmers, and it is also conceivable "
"that a *class browser* program might be written that relies upon such a "
"convention."
msgstr ""
"Первый аргумент метода часто называют ``self``. Это всего лишь общепринятая "
"договорённость: имя ``self`` не имеет никакого особого значения в Python. "
"Однако если не придерживаться этой практики, ваш код может стать менее "
"читабельным для других программистов, а некоторые инструменты анализа кода, "
"вроде *обозревателей классов*, могут полагаться на такое соглашение."

#: ../../tutorial/classes.rst:513
msgid ""
"Any function object that is a class attribute defines a method for instances "
"of that class.  It is not necessary that the function definition is "
"textually enclosed in the class definition: assigning a function object to a "
"local variable in the class is also ok.  For example::"
msgstr ""
"Любой объект функции, являющийся атрибутом класса, определяет метод для "
"экземпляров этого класса. Не обязательно, чтобы определение функции явно "
"находилось внутри определения класса: можно присвоить объект функции "
"локальной переменной в классе. Например::"

#: ../../tutorial/classes.rst:518
msgid ""
"# Function defined outside the class\n"
"def f1(self, x, y):\n"
"    return min(x, x+y)\n"
"\n"
"class C:\n"
"    f = f1\n"
"\n"
"    def g(self):\n"
"        return 'hello world'\n"
"\n"
"    h = g"
msgstr ""
"# Функция определена вне класса\n"
"def f1(self, x, y):\n"
"    return min(x, x+y)\n"
"\n"
"class C:\n"
"    f = f1\n"
"\n"
"    def g(self):\n"
"        return 'привет мир'\n"
"\n"
"    h = g"

#: ../../tutorial/classes.rst:530
msgid ""
"Now ``f``, ``g`` and ``h`` are all attributes of class :class:`!C` that "
"refer to function objects, and consequently they are all methods of "
"instances of :class:`!C` --- ``h`` being exactly equivalent to ``g``.  Note "
"that this practice usually only serves to confuse the reader of a program."
msgstr ""
"Теперь ``f``, ``g`` и ``h`` являются атрибутами класса :class:`!C`, которые "
"ссылаются на объекты функций, и, следовательно, все они являются методами "
"экземпляров класса :class:`!C` — ``h`` в точности эквивалентен ``g``. "
"Обратите внимание, что такая практика обычно только сбивает с толку читателя "
"программы."

#: ../../tutorial/classes.rst:535
msgid ""
"Methods may call other methods by using method attributes of the ``self`` "
"argument::"
msgstr "Методы могут вызывать другие методы с помощью аргумента ``self``::"

#: ../../tutorial/classes.rst:538
msgid ""
"class Bag:\n"
"    def __init__(self):\n"
"        self.data = []\n"
"\n"
"    def add(self, x):\n"
"        self.data.append(x)\n"
"\n"
"    def addtwice(self, x):\n"
"        self.add(x)\n"
"        self.add(x)"
msgstr ""
"class Bag:\n"
"    def __init__(self):\n"
"        self.data = []\n"
"\n"
"    def add(self, x):\n"
"        self.data.append(x)\n"
"\n"
"    def addtwice(self, x):\n"
"        self.add(x)\n"
"        self.add(x)"

#: ../../tutorial/classes.rst:549
msgid ""
"Methods may reference global names in the same way as ordinary functions.  "
"The global scope associated with a method is the module containing its "
"definition.  (A class is never used as a global scope.)  While one rarely "
"encounters a good reason for using global data in a method, there are many "
"legitimate uses of the global scope: for one thing, functions and modules "
"imported into the global scope can be used by methods, as well as functions "
"and classes defined in it.  Usually, the class containing the method is "
"itself defined in this global scope, and in the next section we'll find some "
"good reasons why a method would want to reference its own class."
msgstr ""
"Методы могут ссылаться на глобальные имена так же, как обычные функции. "
"Глобальная область видимости метода — это модуль, в котором он определён. "
"(Класс никогда не используется как глобальная область видимости.) Хотя "
"поводы использовать глобальные данные внутри метода встречаются редко, сама "
"глобальная область видимости нередко бывает полезна. Например, методы могут "
"обращаться к функциям и модулям, импортированным на уровне модуля, а также к "
"функциям и классам, определённым в нём. Обычно класс, содержащий метод, сам "
"определяется в глобальной области видимости, и в следующем разделе мы "
"рассмотрим причины, по которым метод может захотеть ссылаться на свой класс."

#: ../../tutorial/classes.rst:559
msgid ""
"Each value is an object, and therefore has a *class* (also called its "
"*type*). It is stored as ``object.__class__``."
msgstr ""
"Любое значение в Python --- это объект, а значит относится к какому-то "
"*классу* (который также называется его *типом*). Он хранится как ``object."
"__class__``."

#: ../../tutorial/classes.rst:566
msgid "Inheritance"
msgstr "Наследование"

#: ../../tutorial/classes.rst:568
msgid ""
"Of course, a language feature would not be worthy of the name \"class\" "
"without supporting inheritance.  The syntax for a derived class definition "
"looks like this::"
msgstr ""
"Разумеется, механизм языка программирования не достоин называться "
"«классами», без поддержки наследования. Синтаксис определения производного "
"класса выглядит так:"

#: ../../tutorial/classes.rst:572
msgid ""
"class DerivedClassName(BaseClassName):\n"
"    <statement-1>\n"
"    .\n"
"    .\n"
"    .\n"
"    <statement-N>"
msgstr ""
"class DerivedClassName(BaseClassName):\n"
"    <statement-1>\n"
"    .\n"
"    .\n"
"    .\n"
"    <statement-N>"

#: ../../tutorial/classes.rst:579
msgid ""
"The name :class:`!BaseClassName` must be defined in a namespace accessible "
"from the scope containing the derived class definition.  In place of a base "
"class name, other arbitrary expressions are also allowed.  This can be "
"useful, for example, when the base class is defined in another module::"
msgstr ""
"Имя :class:`!BaseClassName` должно быть определено в пространстве имён, "
"доступном из области, содержащей определение производного класса. Вместо "
"имени базового класса допускаются также другие произвольные выражения. Это "
"может быть полезно, например, когда базовый класс определён в другом модуле:"

#: ../../tutorial/classes.rst:585
msgid "class DerivedClassName(modname.BaseClassName):"
msgstr "class DerivedClassName(modname.BaseClassName):"

#: ../../tutorial/classes.rst:587
msgid ""
"Execution of a derived class definition proceeds the same as for a base "
"class. When the class object is constructed, the base class is remembered.  "
"This is used for resolving attribute references: if a requested attribute is "
"not found in the class, the search proceeds to look in the base class.  This "
"rule is applied recursively if the base class itself is derived from some "
"other class."
msgstr ""
"Определение дочернего класса выполняется так же, как и определение класса "
"без родителей. Когда объект класса создаётся, он запоминает своего родителя. "
"Это будет использоваться для разрешения ссылок на атрибуты: если "
"запрашиваемый атрибут не найден в классе, его поиск продолжится у родителя. "
"Это правило применяется рекурсивно, если базовый класс сам является "
"производным."

#: ../../tutorial/classes.rst:593
msgid ""
"There's nothing special about instantiation of derived classes: "
"``DerivedClassName()`` creates a new instance of the class.  Method "
"references are resolved as follows: the corresponding class attribute is "
"searched, descending down the chain of base classes if necessary, and the "
"method reference is valid if this yields a function object."
msgstr ""
"В создании экземпляров производных классов нет ничего особенного: "
"``DerivedClassName()`` создаёт новый экземпляр класса. Ссылки на методы "
"разрешаются следующим образом: выполняется поиск соответствующего атрибута "
"класса, при необходимости спускаясь вниз по цепочке базовых классов. Ссылка "
"считается корректной, если найденный атрибут оказывается функцией."

#: ../../tutorial/classes.rst:599
msgid ""
"Derived classes may override methods of their base classes.  Because methods "
"have no special privileges when calling other methods of the same object, a "
"method of a base class that calls another method defined in the same base "
"class may end up calling a method of a derived class that overrides it.  "
"(For C++ programmers: all methods in Python are effectively ``virtual``.)"
msgstr ""
"Производные классы могут переопределять методы своих базовых классов. "
"Поскольку методы не имеют специальных привилегий при вызове других методов "
"того же объекта, метод базового класса, который вызывает другой метод, "
"определённый в том же базовом классе, может в конечном итоге вызвать метод "
"производного класса, который переопределяет его. (Для программистов C++: все "
"методы Python фактически являются ``virtual``.)"

#: ../../tutorial/classes.rst:605
msgid ""
"An overriding method in a derived class may in fact want to extend rather "
"than simply replace the base class method of the same name. There is a "
"simple way to call the base class method directly: just call ``BaseClassName."
"methodname(self, arguments)``.  This is occasionally useful to clients as "
"well.  (Note that this only works if the base class is accessible as "
"``BaseClassName`` in the global scope.)"
msgstr ""
"На самом деле переопределённый метод в производном классе может расширять, а "
"не просто заменять одноименный метод базового класса. Есть простой способ "
"вызвать метод базового класса напрямую: просто вызовите ``BaseClassName."
"methodname(self, arguments)``. Иногда это бывает полезно и для клиентов. "
"(Обратите внимание, что это работает только в том случае, если базовый класс "
"доступен как ``BaseClassName`` в глобальной области видимости.)"

#: ../../tutorial/classes.rst:612
msgid "Python has two built-in functions that work with inheritance:"
msgstr "Python имеет две встроенные функции, которые работают с наследованием:"

#: ../../tutorial/classes.rst:614
msgid ""
"Use :func:`isinstance` to check an instance's type: ``isinstance(obj, int)`` "
"will be ``True`` only if ``obj.__class__`` is :class:`int` or some class "
"derived from :class:`int`."
msgstr ""
"Используйте :func:`isinstance` для проверки типа экземпляра: "
"``isinstance(obj, int)`` будет ``True``, только если ``obj.__class__`` имеет "
"значение :class:`int` или какой-либо производный от :class:`int` класс."

#: ../../tutorial/classes.rst:618
msgid ""
"Use :func:`issubclass` to check class inheritance: ``issubclass(bool, int)`` "
"is ``True`` since :class:`bool` is a subclass of :class:`int`.  However, "
"``issubclass(float, int)`` is ``False`` since :class:`float` is not a "
"subclass of :class:`int`."
msgstr ""
"Используйте :func:`issubclass` для проверки наследования классов: "
"``issubclass(bool, int)`` имеет значение ``True``, поскольку :class:`bool` "
"является подклассом :class:`int`. Однако ``issubclass(float, int)`` имеет "
"значение ``False``, поскольку :class:`float` не является подклассом :class:"
"`int`."

#: ../../tutorial/classes.rst:628
msgid "Multiple Inheritance"
msgstr "Множественное наследование"

#: ../../tutorial/classes.rst:630
msgid ""
"Python supports a form of multiple inheritance as well.  A class definition "
"with multiple base classes looks like this::"
msgstr ""
"Python также поддерживает форму множественного наследования. Определение "
"класса с несколькими базовыми классами выглядит следующим образом:"

#: ../../tutorial/classes.rst:633
msgid ""
"class DerivedClassName(Base1, Base2, Base3):\n"
"    <statement-1>\n"
"    .\n"
"    .\n"
"    .\n"
"    <statement-N>"
msgstr ""
"class DerivedClassName(Base1, Base2, Base3):\n"
"    <statement-1>\n"
"    .\n"
"    .\n"
"    .\n"
"    <statement-N>"

#: ../../tutorial/classes.rst:640
msgid ""
"For most purposes, in the simplest cases, you can think of the search for "
"attributes inherited from a parent class as depth-first, left-to-right, not "
"searching twice in the same class where there is an overlap in the "
"hierarchy. Thus, if an attribute is not found in :class:`!DerivedClassName`, "
"it is searched for in :class:`!Base1`, then (recursively) in the base "
"classes of :class:`!Base1`, and if it was not found there, it was searched "
"for in :class:`!Base2`, and so on."
msgstr ""
"В большинстве случаев, в простых примерах, можно считать, что поиск "
"атрибутов, унаследованных от родительских классов, выполняется в глубину "
"слева направо, при этом один и тот же класс не проверяется дважды, если есть "
"перекрытие в иерархии. Таким образом, если атрибут не найден в :class:`!"
"DerivedClassName`, он ищется в :class:`!Base1`, затем (рекурсивно) в базовых "
"классах :class:`!Base1`, и если он там не был найден, поиск продолжается в :"
"class:`!Base2` и так далее."

#: ../../tutorial/classes.rst:647
msgid ""
"In fact, it is slightly more complex than that; the method resolution order "
"changes dynamically to support cooperative calls to :func:`super`.  This "
"approach is known in some other multiple-inheritance languages as call-next-"
"method and is more powerful than the super call found in single-inheritance "
"languages."
msgstr ""
"На самом деле всё немного сложнее; порядок разрешения методов изменяется "
"динамически для поддержки совместных вызовов :func:`super`. Этот подход "
"известен в некоторых других языках с множественным наследованием как вызов "
"следующего метода и является более мощным, чем вызов метода базового класса, "
"встречающийся в языках с одиночным наследованием."

#: ../../tutorial/classes.rst:653
msgid ""
"Dynamic ordering is necessary because all cases of multiple inheritance "
"exhibit one or more diamond relationships (where at least one of the parent "
"classes can be accessed through multiple paths from the bottommost class).  "
"For example, all classes inherit from :class:`object`, so any case of "
"multiple inheritance provides more than one path to reach :class:`object`.  "
"To keep the base classes from being accessed more than once, the dynamic "
"algorithm linearizes the search order in a way that preserves the left-to-"
"right ordering specified in each class, that calls each parent only once, "
"and that is monotonic (meaning that a class can be subclassed without "
"affecting the precedence order of its parents). Taken together, these "
"properties make it possible to design reliable and extensible classes with "
"multiple inheritance.  For more detail, see :ref:`python_2.3_mro`."
msgstr ""
"Динамическое упорядочивание необходимо, поскольку во всех случаях "
"множественного наследования присутствует одно или несколько ромбовидных "
"отношений (где хотя бы к одному из родительских классов можно получить "
"доступ через несколько путей из самого нижнего класса). Например, все классы "
"наследуются от :class:`object`, поэтому в любом случае множественного "
"наследования существует более одного пути для достижения :class:`object`. "
"Чтобы предотвратить многократное обращение к базовым классам, динамический "
"алгоритм линеаризует порядок поиска таким образом, чтобы сохранить порядок "
"слева направо, указанный в каждом классе, посетить каждого родителя только "
"один раз и обеспечить монотонность (это означает, что класс может быть "
"подклассом, не затрагивая порядок обхода его родителей). В совокупности эти "
"свойства позволяют проектировать надежные и расширяемые классы с "
"множественным наследованием. Более подробную информацию см. в :ref:"
"`python_2.3_mro`."

#: ../../tutorial/classes.rst:670
msgid "Private Variables"
msgstr "Закрытые переменные"

#: ../../tutorial/classes.rst:672
msgid ""
"\"Private\" instance variables that cannot be accessed except from inside an "
"object don't exist in Python.  However, there is a convention that is "
"followed by most Python code: a name prefixed with an underscore (e.g. "
"``_spam``) should be treated as a non-public part of the API (whether it is "
"a function, a method or a data member).  It should be considered an "
"implementation detail and subject to change without notice."
msgstr ""
"В Python не существует «закрытых» переменные экземпляра, доступ к которым "
"был бы возможен только изнутри объекта. Однако существует соглашение, "
"которому следует большая часть кода Python: начинающееся с подчеркивания имя "
"(например, ``_spam``) должно рассматриваться как непубличная часть API (будь "
"то функция, метод или элемент данных). Такое имя следует рассматривать как "
"деталь реализации, которая может измениться без уведомления."

#: ../../tutorial/classes.rst:682
msgid ""
"Since there is a valid use-case for class-private members (namely to avoid "
"name clashes of names with names defined by subclasses), there is limited "
"support for such a mechanism, called :dfn:`name mangling`.  Any identifier "
"of the form ``__spam`` (at least two leading underscores, at most one "
"trailing underscore) is textually replaced with ``_classname__spam``, where "
"``classname`` is the current class name with leading underscore(s) "
"stripped.  This mangling is done without regard to the syntactic position of "
"the identifier, as long as it occurs within the definition of a class."
msgstr ""
"Поскольку существует допустимый вариант использования закрытых членов класса "
"(а именно, чтобы избежать конфликтов имён с именами, определенными "
"подклассами), существует ограниченная поддержка такого механизма, "
"называемого :dfn:`искажением имён`. Любой идентификатор вида ``__spam`` (как "
"минимум два ведущих подчёркивания и не более одного завершающего) заменяется "
"на уровне исходного текста на ``_classname__spam``, где ``classname``—  это "
"имя текущего класса без ведущих подчёркиваний. Это искажение выполняется без "
"учета синтаксической позиции идентификатора, если только он встречается "
"внутри определения класса."

#: ../../tutorial/classes.rst:693
msgid ""
"The :ref:`private name mangling specifications <private-name-mangling>` for "
"details and special cases."
msgstr ""
":ref:`Спецификации искажения закрытых имён <private-name-mangling>` для "
"получения подробной информации и особых случаев."

#: ../../tutorial/classes.rst:696
msgid ""
"Name mangling is helpful for letting subclasses override methods without "
"breaking intraclass method calls.  For example::"
msgstr ""
"Изменение имён полезно для того, чтобы позволить подклассам переопределять "
"методы, не нарушая вызовы методов внутри самого класса. Например::"

#: ../../tutorial/classes.rst:699
msgid ""
"class Mapping:\n"
"    def __init__(self, iterable):\n"
"        self.items_list = []\n"
"        self.__update(iterable)\n"
"\n"
"    def update(self, iterable):\n"
"        for item in iterable:\n"
"            self.items_list.append(item)\n"
"\n"
"    __update = update   # private copy of original update() method\n"
"\n"
"class MappingSubclass(Mapping):\n"
"\n"
"    def update(self, keys, values):\n"
"        # provides new signature for update()\n"
"        # but does not break __init__()\n"
"        for item in zip(keys, values):\n"
"            self.items_list.append(item)"
msgstr ""
"class Mapping:\n"
"    def __init__(self, iterable):\n"
"        self.items_list = []\n"
"        self.__update(iterable)\n"
"\n"
"    def update(self, iterable):\n"
"        for item in iterable:\n"
"            self.items_list.append(item)\n"
"\n"
"    __update = update   # закрытая копия исходного метода update()\n"
"\n"
"class MappingSubclass(Mapping):\n"
"\n"
"    def update(self, keys, values):\n"
"        # новая сигнатура метода update()\n"
"        # но __init__() при этом остаётся работоспособным\n"
"        for item in zip(keys, values):\n"
"            self.items_list.append(item)"

#: ../../tutorial/classes.rst:718
msgid ""
"The above example would work even if ``MappingSubclass`` were to introduce a "
"``__update`` identifier since it is replaced with ``_Mapping__update`` in "
"the ``Mapping`` class  and ``_MappingSubclass__update`` in the "
"``MappingSubclass`` class respectively."
msgstr ""
"Приведённый выше пример будет работать, даже если ``MappingSubclass`` введёт "
"идентификатор ``__update``, поскольку он заменяется на ``_Mapping__update`` "
"в классе ``Mapping`` и на ``_MappingSubclass__update`` в классе "
"``MappingSubclass`` соответственно."

#: ../../tutorial/classes.rst:723
msgid ""
"Note that the mangling rules are designed mostly to avoid accidents; it "
"still is possible to access or modify a variable that is considered "
"private.  This can even be useful in special circumstances, such as in the "
"debugger."
msgstr ""
"Обратите внимание, что правила искажения имён созданы главным образом для "
"предотвращения случайных ошибок. При желании всё ещё можно получить доступ к "
"переменной, которая считается закрытой, или изменить её. Это может быть даже "
"полезно в особых случаях, например, при отладке."

#: ../../tutorial/classes.rst:727
msgid ""
"Notice that code passed to ``exec()`` or ``eval()`` does not consider the "
"classname of the invoking class to be the current class; this is similar to "
"the effect of the ``global`` statement, the effect of which is likewise "
"restricted to code that is byte-compiled together.  The same restriction "
"applies to ``getattr()``, ``setattr()`` and ``delattr()``, as well as when "
"referencing ``__dict__`` directly."
msgstr ""
"Обратите внимание, что код, переданный в ``exec()`` или ``eval()``, не "
"считает имя класса вызывающего кода текущим классом. Это похоже на эффект "
"инструкции ``global``, действие которой также ограничено кодом, "
"скомпилированным вместе. Такое же ограничение применяется к функциям "
"``getattr()``, ``setattr()`` и ``delattr()``, а также при прямом обращении к "
"``__dict__``."

#: ../../tutorial/classes.rst:738
msgid "Odds and Ends"
msgstr "Разное и полезное"

#: ../../tutorial/classes.rst:740
msgid ""
"Sometimes it is useful to have a data type similar to the Pascal \"record\" "
"or C \"struct\", bundling together a few named data items. The idiomatic "
"approach is to use :mod:`dataclasses` for this purpose::"
msgstr ""
"Иногда бывает полезно иметь тип данных, похожий на «запись» в Pascal или "
"«структуру» в C, объединяющий несколько именованных элементов данных. "
"Идиоматический подход заключается в использовании для этой цели :mod:"
"`dataclasses`::"

#: ../../tutorial/classes.rst:744
msgid ""
"from dataclasses import dataclass\n"
"\n"
"@dataclass\n"
"class Employee:\n"
"    name: str\n"
"    dept: str\n"
"    salary: int"
msgstr ""
"from dataclasses import dataclass\n"
"\n"
"@dataclass\n"
"class Employee:\n"
"    name: str\n"
"    dept: str\n"
"    salary: int"

#: ../../tutorial/classes.rst:754
msgid ""
">>> john = Employee('john', 'computer lab', 1000)\n"
">>> john.dept\n"
"'computer lab'\n"
">>> john.salary\n"
"1000"
msgstr ""
">>> john = Employee('Джон', 'компьютерная лаборатория', 1000)\n"
">>> john.dept\n"
"'компьютерная лаборатория'\n"
">>> john.salary\n"
"1000"

#: ../../tutorial/classes.rst:760
msgid ""
"A piece of Python code that expects a particular abstract data type can "
"often be passed a class that emulates the methods of that data type "
"instead.  For instance, if you have a function that formats some data from a "
"file object, you can define a class with methods :meth:`~io.TextIOBase.read` "
"and :meth:`~io.TextIOBase.readline` that get the data from a string buffer "
"instead, and pass it as an argument."
msgstr ""
"Фрагмент кода Python, который ожидает определённый абстрактный тип данных, "
"часто может вместо этого принимать класс, который эмулирует методы этого "
"типа данных. Например, если у вас есть функция, которая форматирует "
"некоторые данные из файлового объекта, вы можете определить класс с "
"методами :meth:`~io.TextIOBase.read` и :meth:`~io.TextIOBase.readline`, "
"которые получают вместо этого данные из строкового буфера и передать его в "
"качестве аргумента."

#: ../../tutorial/classes.rst:772
msgid ""
":ref:`Instance method objects <instance-methods>` have attributes, too: :"
"attr:`m.__self__ <method.__self__>` is the instance object with the method :"
"meth:`!m`, and :attr:`m.__func__ <method.__func__>` is the :ref:`function "
"object <user-defined-funcs>` corresponding to the method."
msgstr ""
":ref:`Объекты метода экземпляра <instance-methods>` также имеют атрибуты: :"
"attr:`m.__self__ <method.__self__>` — это объект экземпляра с методом :meth:"
"`!m`, а :attr: `m.__func__ <method.__func__>` — это :ref:`объект функции "
"<user-defined-funcs>`, соответствующий методу."

#: ../../tutorial/classes.rst:782
msgid "Iterators"
msgstr "Итераторы"

#: ../../tutorial/classes.rst:784
msgid ""
"By now you have probably noticed that most container objects can be looped "
"over using a :keyword:`for` statement::"
msgstr ""
"К этому моменту вы, вероятно, заметили, что большинство объектов-контейнеров "
"можно перебрать с помощью инструкции :keyword:`for`::"

#: ../../tutorial/classes.rst:787
msgid ""
"for element in [1, 2, 3]:\n"
"    print(element)\n"
"for element in (1, 2, 3):\n"
"    print(element)\n"
"for key in {'one':1, 'two':2}:\n"
"    print(key)\n"
"for char in \"123\":\n"
"    print(char)\n"
"for line in open(\"myfile.txt\"):\n"
"    print(line, end='')"
msgstr ""
"for element in [1, 2, 3]:\n"
"    print(element)\n"
"for element in (1, 2, 3):\n"
"    print(element)\n"
"for key in {'один':1, 'два':2}:\n"
"    print(key)\n"
"for char in \"123\":\n"
"    print(char)\n"
"for line in open(\"myfile.txt\"):\n"
"    print(line, end='')"

#: ../../tutorial/classes.rst:798
msgid ""
"This style of access is clear, concise, and convenient.  The use of "
"iterators pervades and unifies Python.  Behind the scenes, the :keyword:"
"`for` statement calls :func:`iter` on the container object.  The function "
"returns an iterator object that defines the method :meth:`~iterator."
"__next__` which accesses elements in the container one at a time.  When "
"there are no more elements, :meth:`~iterator.__next__` raises a :exc:"
"`StopIteration` exception which tells the :keyword:`!for` loop to "
"terminate.  You can call the :meth:`~iterator.__next__` method using the :"
"func:`next` built-in function; this example shows how it all works::"
msgstr ""
"Этот стиль доступа ясен, краток и удобен. Использование итераторов "
"пронизывает и унифицирует Python. За кулисами инструкция :keyword:`for` "
"вызывает :func:`iter` для объекта-контейнера. Функция возвращает объект "
"итератора, который определяет метод :meth:`~iterator.__next__`, получающий "
"элементы контейнера по одному за раз. Когда элементов больше нет, :meth:"
"`~iterator.__next__` вызывает исключение :exc:`StopIteration`, которое "
"сообщает циклу :keyword:`!for` завершить выполнение. Вы можете вызвать "
"метод :meth:`~iterator.__next__`, используя встроенную функцию :func:`next`. "
"Этот пример показывает, как всё это работает::"

#: ../../tutorial/classes.rst:807
msgid ""
">>> s = 'abc'\n"
">>> it = iter(s)\n"
">>> it\n"
"<str_iterator object at 0x10c90e650>\n"
">>> next(it)\n"
"'a'\n"
">>> next(it)\n"
"'b'\n"
">>> next(it)\n"
"'c'\n"
">>> next(it)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"    next(it)\n"
"StopIteration"
msgstr ""
">>> s = 'абв'\n"
">>> it = iter(s)\n"
">>> it\n"
"<str_iterator object at 0x10c90e650>\n"
">>> next(it)\n"
"'а'\n"
">>> next(it)\n"
"'б'\n"
">>> next(it)\n"
"'в'\n"
">>> next(it)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"    next(it)\n"
"StopIteration"

#: ../../tutorial/classes.rst:823
msgid ""
"Having seen the mechanics behind the iterator protocol, it is easy to add "
"iterator behavior to your classes.  Define an :meth:`~container.__iter__` "
"method which returns an object with a :meth:`~iterator.__next__` method.  If "
"the class defines :meth:`!__next__`, then :meth:`!__iter__` can just return "
"``self``::"
msgstr ""
"Познакомившись с механизмом протокола итерации, легко добавить поведение "
"итератора в свои классы. Определите метод :meth:`~container.__iter__`, "
"который возвращает объект с методом :meth:`~iterator.__next__`. Если класс "
"определяет :meth:`!__next__`, то :meth:`!__iter__` может просто вернуть "
"``self``::"

#: ../../tutorial/classes.rst:828
msgid ""
"class Reverse:\n"
"    \"\"\"Iterator for looping over a sequence backwards.\"\"\"\n"
"    def __init__(self, data):\n"
"        self.data = data\n"
"        self.index = len(data)\n"
"\n"
"    def __iter__(self):\n"
"        return self\n"
"\n"
"    def __next__(self):\n"
"        if self.index == 0:\n"
"            raise StopIteration\n"
"        self.index = self.index - 1\n"
"        return self.data[self.index]"
msgstr ""
"class Reverse:\n"
"    \"\"\"Итератор для прохода по последовательности в обратном порядке."
"\"\"\"\n"
"    def __init__(self, data):\n"
"        self.data = data\n"
"        self.index = len(data)\n"
"\n"
"    def __iter__(self):\n"
"        return self\n"
"\n"
"    def __next__(self):\n"
"        if self.index == 0:\n"
"            raise StopIteration\n"
"        self.index = self.index - 1\n"
"        return self.data[self.index]"

#: ../../tutorial/classes.rst:845
msgid ""
">>> rev = Reverse('spam')\n"
">>> iter(rev)\n"
"<__main__.Reverse object at 0x00A1DB50>\n"
">>> for char in rev:\n"
"...     print(char)\n"
"...\n"
"m\n"
"a\n"
"p\n"
"s"
msgstr ""
">>> rev = Reverse('спам')\n"
">>> iter(rev)\n"
"<__main__.Reverse object at 0x00A1DB50>\n"
">>> for char in rev:\n"
"...     print(char)\n"
"...\n"
"м\n"
"а\n"
"п\n"
"с"

#: ../../tutorial/classes.rst:860
msgid "Generators"
msgstr "Генераторы"

#: ../../tutorial/classes.rst:862
msgid ""
":term:`Generators <generator>` are a simple and powerful tool for creating "
"iterators.  They are written like regular functions but use the :keyword:"
"`yield` statement whenever they want to return data.  Each time :func:`next` "
"is called on it, the generator resumes where it left off (it remembers all "
"the data values and which statement was last executed).  An example shows "
"that generators can be trivially easy to create::"
msgstr ""
":term:`Генераторы <generator>` — это простой и мощный инструмент для "
"создания итераторов. Они пишутся как обычные функции, но используют "
"инструкцию :keyword:`yield` всякий раз, когда хотят вернуть данные. Каждый "
"раз, когда на нём вызывается :func:`next`, генератор возобновляет работу с "
"того места, где остановился (он запоминает все значения данных и последнюю "
"выполненную инструкцию). Пример показывает, что генераторы можно создать "
"очень легко:"

#: ../../tutorial/classes.rst:869
msgid ""
"def reverse(data):\n"
"    for index in range(len(data)-1, -1, -1):\n"
"        yield data[index]"
msgstr ""
"def reverse(data):\n"
"    for index in range(len(data)-1, -1, -1):\n"
"        yield data[index]"

#: ../../tutorial/classes.rst:875
msgid ""
">>> for char in reverse('golf'):\n"
"...     print(char)\n"
"...\n"
"f\n"
"l\n"
"o\n"
"g"
msgstr ""
">>> for char in reverse('гольф'):\n"
"...     print(char)\n"
"...\n"
"ф\n"
"ь\n"
"л\n"
"о\n"
"г"

#: ../../tutorial/classes.rst:883
msgid ""
"Anything that can be done with generators can also be done with class-based "
"iterators as described in the previous section.  What makes generators so "
"compact is that the :meth:`~iterator.__iter__` and :meth:`~generator."
"__next__` methods are created automatically."
msgstr ""
"Всё, что можно сделать с помощью генераторов, можно сделать и с помощью "
"итераторов на основе классов, как описано в предыдущем разделе. Что делает "
"генераторы такими компактными, так это то, что методы :meth:`~iterator."
"__iter__` и :meth:`~generator.__next__` создаются автоматически."

#: ../../tutorial/classes.rst:888
msgid ""
"Another key feature is that the local variables and execution state are "
"automatically saved between calls.  This made the function easier to write "
"and much more clear than an approach using instance variables like ``self."
"index`` and ``self.data``."
msgstr ""
"Ещё одной ключевой особенностью является то, что локальные переменные и "
"состояние выполнения автоматически сохраняются между вызовами. Это сделало "
"функцию более простой в написании и более понятной, чем подход с "
"использованием переменных экземпляра, таких как ``self.index`` и ``self."
"data``."

#: ../../tutorial/classes.rst:893
msgid ""
"In addition to automatic method creation and saving program state, when "
"generators terminate, they automatically raise :exc:`StopIteration`. In "
"combination, these features make it easy to create iterators with no more "
"effort than writing a regular function."
msgstr ""
"В дополнение к автоматическому созданию методов и сохранению состояния "
"программы, когда генераторы завершают работу, они автоматически выбрасывают :"
"exc:`StopIteration`. В совокупности эти возможности позволяют легко "
"создавать итераторы, не прилагая больше усилий, чем при написании обычной "
"функции."

#: ../../tutorial/classes.rst:902
msgid "Generator Expressions"
msgstr "Генераторные выражения"

#: ../../tutorial/classes.rst:904
msgid ""
"Some simple generators can be coded succinctly as expressions using a syntax "
"similar to list comprehensions but with parentheses instead of square "
"brackets. These expressions are designed for situations where the generator "
"is used right away by an enclosing function.  Generator expressions are more "
"compact but less versatile than full generator definitions and tend to be "
"more memory friendly than equivalent list comprehensions."
msgstr ""
"Некоторые простые генераторы можно лаконично закодировать как выражения, "
"используя синтаксис, аналогичный списковым включениям, но с круглыми "
"скобками вместо квадратных. Эти выражения предназначены для ситуаций, когда "
"генератор сразу же используется внешней функцией. Выражения-генераторы более "
"компактны, но менее универсальны, чем полноценные определения генераторов, "
"и, как правило, расходуют память более экономно, чем эквивалентные списковые "
"включения."

#: ../../tutorial/classes.rst:911
msgid "Examples::"
msgstr "Примеры::"

#: ../../tutorial/classes.rst:913
msgid ""
">>> sum(i*i for i in range(10))                 # sum of squares\n"
"285\n"
"\n"
">>> xvec = [10, 20, 30]\n"
">>> yvec = [7, 5, 3]\n"
">>> sum(x*y for x,y in zip(xvec, yvec))         # dot product\n"
"260\n"
"\n"
">>> unique_words = set(word for line in page  for word in line.split())\n"
"\n"
">>> valedictorian = max((student.gpa, student.name) for student in "
"graduates)\n"
"\n"
">>> data = 'golf'\n"
">>> list(data[i] for i in range(len(data)-1, -1, -1))\n"
"['f', 'l', 'o', 'g']"
msgstr ""
">>> sum(i*i for i in range(10))                 # сумма квадратов\n"
"285\n"
"\n"
">>> xvec = [10, 20, 30]\n"
">>> yvec = [7, 5, 3]\n"
">>> sum(x*y for x,y in zip(xvec, yvec))         # скалярное произведение\n"
"260\n"
"\n"
">>> unique_words = set(word for line in page  for word in line.split())\n"
"\n"
">>> valedictorian = max((student.gpa, student.name) for student in "
"graduates)\n"
"\n"
">>> data = 'гольф'\n"
">>> list(data[i] for i in range(len(data)-1, -1, -1))\n"
"['ф', 'ь', 'л', 'о', 'г']"

#: ../../tutorial/classes.rst:932
msgid "Footnotes"
msgstr "Примечания"

#: ../../tutorial/classes.rst:933
msgid ""
"Except for one thing.  Module objects have a secret read-only attribute "
"called :attr:`~object.__dict__` which returns the dictionary used to "
"implement the module's namespace; the name ``__dict__`` is an attribute but "
"not a global name. Obviously, using this violates the abstraction of "
"namespace implementation, and should be restricted to things like post-"
"mortem debuggers."
msgstr ""
"За исключением одного момента. Объекты модуля имеют секретный атрибут только "
"для чтения, называемый :attr:`~object.__dict__`, который возвращает словарь, "
"используемый для реализации пространства имён модуля; имя ``__dict__`` "
"является атрибутом, а не глобальным именем. Очевидно, что использование "
"этого нарушает абстракцию реализации пространства имён и должно "
"ограничиваться такими случаями, как отладка после сбоя программы."

#: ../../tutorial/classes.rst:343
msgid "object"
msgstr "объект"

#: ../../tutorial/classes.rst:343
msgid "method"
msgstr "метод"

#: ../../tutorial/classes.rst:679
msgid "name"
msgstr "имя"

#: ../../tutorial/classes.rst:679
msgid "mangling"
msgstr "искажение"
