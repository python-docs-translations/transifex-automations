# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Dmitry Luschan, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-23 14:12+0000\n"
"PO-Revision-Date: 2025-09-16 00:02+0000\n"
"Last-Translator: Dmitry Luschan, 2025\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../tutorial/datastructures.rst:5
msgid "Data Structures"
msgstr "Структуры данных"

#: ../../tutorial/datastructures.rst:7
msgid ""
"This chapter describes some things you've learned about already in more "
"detail, and adds some new things as well."
msgstr ""
"Данная глава описывает некоторые вещи, которые вы уже изучили, более "
"детально, и добавляет кое-что новое."

#: ../../tutorial/datastructures.rst:13
msgid "More on Lists"
msgstr "Подробнее о списках"

#: ../../tutorial/datastructures.rst:15
msgid ""
"The :ref:`list <typesseq-list>` data type has some more methods. Here are "
"all of the methods of list objects:"
msgstr ""
"Тип данных :ref:`list <typesseq-list>` имеет ещё несколько методов. Здесь "
"перечислены все методы списков:"

#: ../../tutorial/datastructures.rst:21
msgid "Add an item to the end of the list.  Similar to ``a[len(a):] = [x]``."
msgstr "Добавить элемент в конец списка. Аналогично ``a[len(a):] = [x]``."

#: ../../tutorial/datastructures.rst:27
msgid ""
"Extend the list by appending all the items from the iterable.  Similar to "
"``a[len(a):] = iterable``."
msgstr ""
"Расширить список, добавив все элементы из итерируемого объекта. Аналогично "
"``a[len(a):] = iterable``."

#: ../../tutorial/datastructures.rst:34
msgid ""
"Insert an item at a given position.  The first argument is the index of the "
"element before which to insert, so ``a.insert(0, x)`` inserts at the front "
"of the list, and ``a.insert(len(a), x)`` is equivalent to ``a.append(x)``."
msgstr ""
"Вставить элемент на определенную позицию. Первый аргумент — это индекс "
"элемента, перед которым происходит вставка, таким образом ``a.insert(0, x)`` "
"поместит элемент в начало списка, а ``a.insert(len(a), x)`` эквивалентно  "
"``a.append(x)``."

#: ../../tutorial/datastructures.rst:42
msgid ""
"Remove the first item from the list whose value is equal to *x*.  It raises "
"a :exc:`ValueError` if there is no such item."
msgstr ""
"Удалить первый элемент из списка, чьё значение равно *x*.  Возбуждает :exc:"
"`ValueError` если такого элемента нет."

#: ../../tutorial/datastructures.rst:49
msgid ""
"Remove the item at the given position in the list, and return it.  If no "
"index is specified, ``a.pop()`` removes and returns the last item in the "
"list. It raises an :exc:`IndexError` if the list is empty or the index is "
"outside the list range."
msgstr ""
"Удалить элемент в заданной позиции списка и вернуть его. Если индекс не "
"указан, ``a.pop()`` удаляет и возвращает последний элемент списка. "
"Возбуждает :exc:`IndexError`, если список пуст или индекс находится за "
"пределами допустимого диапазона."

#: ../../tutorial/datastructures.rst:58
msgid "Remove all items from the list.  Similar to ``del a[:]``."
msgstr "Удалить все элементы из списка. Аналогично ``del a[:]``."

#: ../../tutorial/datastructures.rst:64
msgid ""
"Return zero-based index of the first occurrence of *x* in the list. Raises "
"a :exc:`ValueError` if there is no such item."
msgstr ""
"Вернуть индекс (при нумерации с нуля) первого вхождения *x* в список. "
"Возбуждает :exc:`ValueError`, если такого элемента в списке нет."

#: ../../tutorial/datastructures.rst:67
msgid ""
"The optional arguments *start* and *end* are interpreted as in the slice "
"notation and are used to limit the search to a particular subsequence of the "
"list.  The returned index is computed relative to the beginning of the full "
"sequence rather than the *start* argument."
msgstr ""
"Необязательные аргументы *start* и *end* интерпретируются так же, как в "
"срезах, и используются чтобы ограничить поиск конкретной "
"подпоследовательностью списка. Возвращаемый индекс рассчитывается "
"относительно начала полной последовательности, а не аргумента *start*."

#: ../../tutorial/datastructures.rst:76
msgid "Return the number of times *x* appears in the list."
msgstr "Вернуть количество раз, которое *x* появляется в списке."

#: ../../tutorial/datastructures.rst:82
msgid ""
"Sort the items of the list in place (the arguments can be used for sort "
"customization, see :func:`sorted` for their explanation)."
msgstr ""
"Отсортировать элементы списка на месте (аргументы можно использовать для "
"настройки сортировки, смотри :func:`sorted` для их пояснения)."

#: ../../tutorial/datastructures.rst:89
msgid "Reverse the elements of the list in place."
msgstr "Развернуть элементы списка на месте."

#: ../../tutorial/datastructures.rst:95
msgid "Return a shallow copy of the list.  Similar to ``a[:]``."
msgstr "Вернуть неглубокую копию списка. Аналогично ``a[:]``."

#: ../../tutorial/datastructures.rst:98
msgid "An example that uses most of the list methods::"
msgstr "Пример, который использует большинство методов списка::"

#: ../../tutorial/datastructures.rst:100
msgid ""
">>> fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', "
"'banana']\n"
">>> fruits.count('apple')\n"
"2\n"
">>> fruits.count('tangerine')\n"
"0\n"
">>> fruits.index('banana')\n"
"3\n"
">>> fruits.index('banana', 4)  # Find next banana starting at position 4\n"
"6\n"
">>> fruits.reverse()\n"
">>> fruits\n"
"['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange']\n"
">>> fruits.append('grape')\n"
">>> fruits\n"
"['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange', 'grape']\n"
">>> fruits.sort()\n"
">>> fruits\n"
"['apple', 'apple', 'banana', 'banana', 'grape', 'kiwi', 'orange', 'pear']\n"
">>> fruits.pop()\n"
"'pear'"
msgstr ""
">>> fruits = ['апельсин', 'яблоко', 'груша', 'банан', 'киви', 'яблоко', "
"'банан']\n"
">>> fruits.count('яблоко')\n"
"2\n"
">>> fruits.count('мандарин')\n"
"0\n"
">>> fruits.index('банан')\n"
"3\n"
">>> fruits.index('банан', 4)  # Найти следующий 'банан', начиная с позиции "
"4\n"
"6\n"
">>> fruits.reverse()\n"
">>> fruits\n"
"['банан', 'яблоко', 'киви', 'банан', 'груша', 'яблоко', 'апельсин']\n"
">>> fruits.append('виноград')\n"
">>> fruits\n"
"['банан', 'яблоко', 'киви', 'банан', 'груша', 'яблоко', 'апельсин', "
"'виноград']\n"
">>> fruits.sort()\n"
">>> fruits\n"
"['апельсин', 'банан', 'банан', 'виноград', 'груша', 'киви', 'яблоко', "
"'яблоко']\n"
">>> fruits.pop()\n"
"'яблоко'"

#: ../../tutorial/datastructures.rst:121
msgid ""
"You might have noticed that methods like ``insert``, ``remove`` or ``sort`` "
"that only modify the list have no return value printed -- they return the "
"default ``None``. [#]_  This is a design principle for all mutable data "
"structures in Python."
msgstr ""
"Вы могли заметить, что методы вроде ``insert``, ``remove`` или ``sort``, "
"которые изменяют список, не выводят возвращаемого значения — они возвращают "
"значение по умолчанию ``None``. [#]_ Такой принцип использовался при "
"проектировании всех изменяемых структур данных в Python."

#: ../../tutorial/datastructures.rst:126
msgid ""
"Another thing you might notice is that not all data can be sorted or "
"compared.  For instance, ``[None, 'hello', 10]`` doesn't sort because "
"integers can't be compared to strings and ``None`` can't be compared to "
"other types.  Also, there are some types that don't have a defined ordering "
"relation.  For example, ``3+4j < 5+7j`` isn't a valid comparison."
msgstr ""
"Еще одна вещь, на которую стоит обратить внимание — не все данные можно "
"отсортировать или сравнить. Например, ``[None, 'hello', 10]`` невозможно "
"отсортировать, поскольку целые числа нельзя сравнивать со строками, а "
"``None`` нельзя сравнивать с другими типами. Кроме того, существуют типы "
"данных, которые не имеют определённого отношения порядка. Например, ``3+4j < "
"5+7j`` не является допустимым сравнением."

#: ../../tutorial/datastructures.rst:137
msgid "Using Lists as Stacks"
msgstr "Использование списка в качестве стека"

#: ../../tutorial/datastructures.rst:142
msgid ""
"The list methods make it very easy to use a list as a stack, where the last "
"element added is the first element retrieved (\"last-in, first-out\").  To "
"add an item to the top of the stack, use :meth:`~list.append`.  To retrieve "
"an item from the top of the stack, use :meth:`~list.pop` without an explicit "
"index.  For example::"
msgstr ""
"Методы списка позволяют очень легко использовать список как стек, где "
"последний добавленный элемент является первым извлекаемым («последним пришёл "
"— первым ушёл»). Чтобы добавить элемент на вершину стека, используйте :meth:"
"`~list.append`, а для извлечения элемента с вершины стека — :meth:`~list."
"pop` без индекса. Например::"

#: ../../tutorial/datastructures.rst:147
msgid ""
">>> stack = [3, 4, 5]\n"
">>> stack.append(6)\n"
">>> stack.append(7)\n"
">>> stack\n"
"[3, 4, 5, 6, 7]\n"
">>> stack.pop()\n"
"7\n"
">>> stack\n"
"[3, 4, 5, 6]\n"
">>> stack.pop()\n"
"6\n"
">>> stack.pop()\n"
"5\n"
">>> stack\n"
"[3, 4]"
msgstr ""
">>> stack = [3, 4, 5]\n"
">>> stack.append(6)\n"
">>> stack.append(7)\n"
">>> stack\n"
"[3, 4, 5, 6, 7]\n"
">>> stack.pop()\n"
"7\n"
">>> stack\n"
"[3, 4, 5, 6]\n"
">>> stack.pop()\n"
"6\n"
">>> stack.pop()\n"
"5\n"
">>> stack\n"
"[3, 4]"

#: ../../tutorial/datastructures.rst:167
msgid "Using Lists as Queues"
msgstr "Использование списка в качестве очереди"

#: ../../tutorial/datastructures.rst:171
msgid ""
"It is also possible to use a list as a queue, where the first element added "
"is the first element retrieved (\"first-in, first-out\"); however, lists are "
"not efficient for this purpose.  While appends and pops from the end of list "
"are fast, doing inserts or pops from the beginning of a list is slow "
"(because all of the other elements have to be shifted by one)."
msgstr ""
"Список также можно использовать как очередь, где первый добавленный элемент "
"— первый извлекаемый («первым пришёл — первым ушёл»); однако списки "
"неэффективны для этой цели. Быстрыми являются добавления и извлечения "
"элементов с конца списка, но вставки или извлечения из начала списка — "
"медленные (так как все остальные элементы нужно сдвигать на одну позицию)."

#: ../../tutorial/datastructures.rst:177
msgid ""
"To implement a queue, use :class:`collections.deque` which was designed to "
"have fast appends and pops from both ends.  For example::"
msgstr ""
"Для реализации очереди, используйте :class:`collections.deque`, который "
"создан для быстрого добавления и извлечения элементов с обоих концов. "
"Например::"

#: ../../tutorial/datastructures.rst:180
msgid ""
">>> from collections import deque\n"
">>> queue = deque([\"Eric\", \"John\", \"Michael\"])\n"
">>> queue.append(\"Terry\")           # Terry arrives\n"
">>> queue.append(\"Graham\")          # Graham arrives\n"
">>> queue.popleft()                 # The first to arrive now leaves\n"
"'Eric'\n"
">>> queue.popleft()                 # The second to arrive now leaves\n"
"'John'\n"
">>> queue                           # Remaining queue in order of arrival\n"
"deque(['Michael', 'Terry', 'Graham'])"
msgstr ""
">>> from collections import deque\n"
">>> queue = deque([\"Эрик\", \"Джон\", \"Майкл\"])\n"
">>> queue.append(\"Терри\")           # Терри пришёл\n"
">>> queue.append(\"Грэм\")            # Грэм пришёл\n"
">>> queue.popleft()                 # Первый пришедший теперь уходит\n"
"'Эрик'\n"
">>> queue.popleft()                 # Второй пришедший теперь уходит\n"
"'Джон'\n"
">>> queue                           # Оставшаяся очередь в порядке прибытия\n"
"deque(['Майкл', 'Терри', 'Грэм'])"

#: ../../tutorial/datastructures.rst:195
msgid "List Comprehensions"
msgstr "Списковые включения"

#: ../../tutorial/datastructures.rst:197
msgid ""
"List comprehensions provide a concise way to create lists. Common "
"applications are to make new lists where each element is the result of some "
"operations applied to each member of another sequence or iterable, or to "
"create a subsequence of those elements that satisfy a certain condition."
msgstr ""
"Включения списков позволяют кратко создавать списки. Обычно их используют "
"для формирования нового списка, в котором каждый элемент — это результат "
"некоторой операции, применённой к каждому элементу другой последовательности "
"или итерируемого объекта, либо для выбора подпоследовательности элементов, "
"удовлетворяющих определённому условию."

#: ../../tutorial/datastructures.rst:202
msgid "For example, assume we want to create a list of squares, like::"
msgstr "Например, предположим, что мы хотим создать список квадратов::"

#: ../../tutorial/datastructures.rst:204
msgid ""
">>> squares = []\n"
">>> for x in range(10):\n"
"...     squares.append(x**2)\n"
"...\n"
">>> squares\n"
"[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]"
msgstr ""
">>> squares = []\n"
">>> for x in range(10):\n"
"...     squares.append(x**2)\n"
"...\n"
">>> squares\n"
"[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]"

#: ../../tutorial/datastructures.rst:211
msgid ""
"Note that this creates (or overwrites) a variable named ``x`` that still "
"exists after the loop completes.  We can calculate the list of squares "
"without any side effects using::"
msgstr ""
"Обратите внимание, что это создаёт (или перезаписывает) переменную ``x``, "
"которая останется существовать после завершения цикла. Мы можем создать "
"список квадратов без побочных эффектов, используя::"

#: ../../tutorial/datastructures.rst:215
msgid "squares = list(map(lambda x: x**2, range(10)))"
msgstr "squares = list(map(lambda x: x**2, range(10)))"

#: ../../tutorial/datastructures.rst:217
msgid "or, equivalently::"
msgstr "или, эквивалентно::"

#: ../../tutorial/datastructures.rst:219
msgid "squares = [x**2 for x in range(10)]"
msgstr "squares = [x**2 for x in range(10)]"

#: ../../tutorial/datastructures.rst:221
msgid "which is more concise and readable."
msgstr "что короче и читабельнее."

#: ../../tutorial/datastructures.rst:223
msgid ""
"A list comprehension consists of brackets containing an expression followed "
"by a :keyword:`!for` clause, then zero or more :keyword:`!for` or :keyword:`!"
"if` clauses.  The result will be a new list resulting from evaluating the "
"expression in the context of the :keyword:`!for` and :keyword:`!if` clauses "
"which follow it. For example, this listcomp combines the elements of two "
"lists if they are not equal::"
msgstr ""
"Списковое включение состоит из квадратных скобок, содержащих выражение, за "
"которым следует ветвь :keyword:`!for`, затем ноль или более ветвей :keyword:"
"`!for` или :keyword:`!if`. Результатом будет новый список, полученный "
"вычислением выражения в контексте следующих за ним ветвей :keyword:`!for` и :"
"keyword:`!if`. Например, это включение объединяет элементы двух списков, "
"если они не равны::"

#: ../../tutorial/datastructures.rst:230
msgid ""
">>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]\n"
"[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]"
msgstr ""
">>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]\n"
"[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]"

#: ../../tutorial/datastructures.rst:233
msgid "and it's equivalent to::"
msgstr "и эквивалентно следующему коду::"

#: ../../tutorial/datastructures.rst:235
msgid ""
">>> combs = []\n"
">>> for x in [1,2,3]:\n"
"...     for y in [3,1,4]:\n"
"...         if x != y:\n"
"...             combs.append((x, y))\n"
"...\n"
">>> combs\n"
"[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]"
msgstr ""
">>> combs = []\n"
">>> for x in [1,2,3]:\n"
"...     for y in [3,1,4]:\n"
"...         if x != y:\n"
"...             combs.append((x, y))\n"
"...\n"
">>> combs\n"
"[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]"

#: ../../tutorial/datastructures.rst:244
msgid ""
"Note how the order of the :keyword:`for` and :keyword:`if` statements is the "
"same in both these snippets."
msgstr ""
"Обратите внимание, что порядок инструкций :keyword:`for` и :keyword:`if` "
"одинаков в обоих фрагментах."

#: ../../tutorial/datastructures.rst:247
msgid ""
"If the expression is a tuple (e.g. the ``(x, y)`` in the previous example), "
"it must be parenthesized. ::"
msgstr ""
"Если выражение является кортежем (например, ``(x, y)`` в предыдущем "
"примере), его нужно заключать в скобки. ::"

#: ../../tutorial/datastructures.rst:250
msgid ""
">>> vec = [-4, -2, 0, 2, 4]\n"
">>> # create a new list with the values doubled\n"
">>> [x*2 for x in vec]\n"
"[-8, -4, 0, 4, 8]\n"
">>> # filter the list to exclude negative numbers\n"
">>> [x for x in vec if x >= 0]\n"
"[0, 2, 4]\n"
">>> # apply a function to all the elements\n"
">>> [abs(x) for x in vec]\n"
"[4, 2, 0, 2, 4]\n"
">>> # call a method on each element\n"
">>> freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']\n"
">>> [weapon.strip() for weapon in freshfruit]\n"
"['banana', 'loganberry', 'passion fruit']\n"
">>> # create a list of 2-tuples like (number, square)\n"
">>> [(x, x**2) for x in range(6)]\n"
"[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]\n"
">>> # the tuple must be parenthesized, otherwise an error is raised\n"
">>> [x, x**2 for x in range(6)]\n"
"  File \"<stdin>\", line 1\n"
"    [x, x**2 for x in range(6)]\n"
"     ^^^^^^^\n"
"SyntaxError: did you forget parentheses around the comprehension target?\n"
">>> # flatten a list using a listcomp with two 'for'\n"
">>> vec = [[1,2,3], [4,5,6], [7,8,9]]\n"
">>> [num for elem in vec for num in elem]\n"
"[1, 2, 3, 4, 5, 6, 7, 8, 9]"
msgstr ""
">>> vec = [-4, -2, 0, 2, 4]\n"
">>> # создать новый список с удвоенными значениями\n"
">>> [x*2 for x in vec]\n"
"[-8, -4, 0, 4, 8]\n"
">>> # отфильтровать список, исключив отрицательные числа\n"
">>> [x for x in vec if x >= 0]\n"
"[0, 2, 4]\n"
">>> # применить функцию ко всем элементам\n"
">>> [abs(x) for x in vec]\n"
"[4, 2, 0, 2, 4]\n"
">>> # вызвать метод для каждого элемента\n"
">>> freshfruit = ['  банан', '   логанова ягода ', ' маракуйя  ']\n"
">>> [weapon.strip() for weapon in freshfruit]\n"
"['банан', 'логанова ягода', 'маракуйя']\n"
">>> # создать список кортежей их пар вроде (число, квадрат)\n"
">>> [(x, x**2) for x in range(6)]\n"
"[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]\n"
">>> # кортеж должен быть в скобках, иначе будет ошибка\n"
">>> [x, x**2 for x in range(6)]\n"
"  File \"<stdin>\", line 1\n"
"    [x, x**2 for x in range(6)]\n"
"     ^^^^^^^\n"
"SyntaxError: did you forget parentheses around the comprehension target?\n"
">>> # развернуть список в плоскую структуру, используя включение с двумя "
"'for'\n"
">>> vec = [[1,2,3], [4,5,6], [7,8,9]]\n"
">>> [num for elem in vec for num in elem]\n"
"[1, 2, 3, 4, 5, 6, 7, 8, 9]"

#: ../../tutorial/datastructures.rst:278
msgid ""
"List comprehensions can contain complex expressions and nested functions::"
msgstr ""
"Включения списков могут содержать сложные выражения и вложенные функции::"

#: ../../tutorial/datastructures.rst:280
msgid ""
">>> from math import pi\n"
">>> [str(round(pi, i)) for i in range(1, 6)]\n"
"['3.1', '3.14', '3.142', '3.1416', '3.14159']"
msgstr ""
">>> from math import pi\n"
">>> [str(round(pi, i)) for i in range(1, 6)]\n"
"['3.1', '3.14', '3.142', '3.1416', '3.14159']"

#: ../../tutorial/datastructures.rst:285
msgid "Nested List Comprehensions"
msgstr "Вложенные списковые включения"

#: ../../tutorial/datastructures.rst:287
msgid ""
"The initial expression in a list comprehension can be any arbitrary "
"expression, including another list comprehension."
msgstr ""
"Начальное выражение в списковом включении может быть произвольным "
"выражением, включая другое списковое включение."

#: ../../tutorial/datastructures.rst:290
msgid ""
"Consider the following example of a 3x4 matrix implemented as a list of 3 "
"lists of length 4::"
msgstr ""
"Рассмотрим следующий пример матрицы 3x4, реализованной в виде списка из 3 "
"списков длины 4::"

#: ../../tutorial/datastructures.rst:293
msgid ""
">>> matrix = [\n"
"...     [1, 2, 3, 4],\n"
"...     [5, 6, 7, 8],\n"
"...     [9, 10, 11, 12],\n"
"... ]"
msgstr ""
">>> matrix = [\n"
"...     [1, 2, 3, 4],\n"
"...     [5, 6, 7, 8],\n"
"...     [9, 10, 11, 12],\n"
"... ]"

#: ../../tutorial/datastructures.rst:299
msgid "The following list comprehension will transpose rows and columns::"
msgstr "Следующее включение списка транспонирует строки и столбцы::"

#: ../../tutorial/datastructures.rst:301
msgid ""
">>> [[row[i] for row in matrix] for i in range(4)]\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"
msgstr ""
">>> [[row[i] for row in matrix] for i in range(4)]\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"

#: ../../tutorial/datastructures.rst:304
msgid ""
"As we saw in the previous section, the inner list comprehension is evaluated "
"in the context of the :keyword:`for` that follows it, so this example is "
"equivalent to::"
msgstr ""
"Как мы видели в предыдущей секции, вложенное списковое включение вычисляется "
"в контексте внешней ветви:keyword:`for`, которая за ним следует, поэтому "
"этот пример эквивалентен::"

#: ../../tutorial/datastructures.rst:308
msgid ""
">>> transposed = []\n"
">>> for i in range(4):\n"
"...     transposed.append([row[i] for row in matrix])\n"
"...\n"
">>> transposed\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"
msgstr ""
">>> transposed = []\n"
">>> for i in range(4):\n"
"...     transposed.append([row[i] for row in matrix])\n"
"...\n"
">>> transposed\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"

#: ../../tutorial/datastructures.rst:315
msgid "which, in turn, is the same as::"
msgstr "что, в свою очередь, тоже самое, что::"

#: ../../tutorial/datastructures.rst:317
msgid ""
">>> transposed = []\n"
">>> for i in range(4):\n"
"...     # the following 3 lines implement the nested listcomp\n"
"...     transposed_row = []\n"
"...     for row in matrix:\n"
"...         transposed_row.append(row[i])\n"
"...     transposed.append(transposed_row)\n"
"...\n"
">>> transposed\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"
msgstr ""
">>> transposed = []\n"
">>> for i in range(4):\n"
"...     # следующие 3 строки реализуют вложенное списковое включение\n"
"...     transposed_row = []\n"
"...     for row in matrix:\n"
"...         transposed_row.append(row[i])\n"
"...     transposed.append(transposed_row)\n"
"...\n"
">>> transposed\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"

#: ../../tutorial/datastructures.rst:328
msgid ""
"In the real world, you should prefer built-in functions to complex flow "
"statements. The :func:`zip` function would do a great job for this use case::"
msgstr ""
"На практике лучше отдавать предпочтение встроенным функциям, а не сложным "
"управляющим конструкциям. Функция :func:`zip` отлично подходит для этой "
"задачи::"

#: ../../tutorial/datastructures.rst:331
msgid ""
">>> list(zip(*matrix))\n"
"[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]"
msgstr ""
">>> list(zip(*matrix))\n"
"[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]"

#: ../../tutorial/datastructures.rst:334
msgid ""
"See :ref:`tut-unpacking-arguments` for details on the asterisk in this line."
msgstr ""
"См. :ref:`tut-unpacking-arguments` для подробностей о том, как работает "
"звёздочка в этом выражении."

#: ../../tutorial/datastructures.rst:339
msgid "The :keyword:`!del` statement"
msgstr "Инструкция :keyword:`!del`"

#: ../../tutorial/datastructures.rst:341
msgid ""
"There is a way to remove an item from a list given its index instead of its "
"value: the :keyword:`del` statement.  This differs from the :meth:`~list."
"pop` method which returns a value.  The :keyword:`!del` statement can also "
"be used to remove slices from a list or clear the entire list (which we did "
"earlier by assignment of an empty list to the slice).  For example::"
msgstr ""
"Есть способ удалить элемент из списка по его индексу, а не по значению: "
"инструкция :keyword:`del`. Это отличается от метода :meth:`~list.pop`, "
"который возвращает значение. Инструкция :keyword:`!del` также может "
"использоваться для удаления срезов или очистки всего списка (что мы уже "
"делали, присваивая пустой список срезу). Например::"

#: ../../tutorial/datastructures.rst:347
msgid ""
">>> a = [-1, 1, 66.25, 333, 333, 1234.5]\n"
">>> del a[0]\n"
">>> a\n"
"[1, 66.25, 333, 333, 1234.5]\n"
">>> del a[2:4]\n"
">>> a\n"
"[1, 66.25, 1234.5]\n"
">>> del a[:]\n"
">>> a\n"
"[]"
msgstr ""
">>> a = [-1, 1, 66.25, 333, 333, 1234.5]\n"
">>> del a[0]\n"
">>> a\n"
"[1, 66.25, 333, 333, 1234.5]\n"
">>> del a[2:4]\n"
">>> a\n"
"[1, 66.25, 1234.5]\n"
">>> del a[:]\n"
">>> a\n"
"[]"

#: ../../tutorial/datastructures.rst:358
msgid ":keyword:`del` can also be used to delete entire variables::"
msgstr ""
":keyword:`del` может также быть использовано для удаления переменных "
"целиком::"

#: ../../tutorial/datastructures.rst:360
msgid ">>> del a"
msgstr ">>> del a"

#: ../../tutorial/datastructures.rst:362
msgid ""
"Referencing the name ``a`` hereafter is an error (at least until another "
"value is assigned to it).  We'll find other uses for :keyword:`del` later."
msgstr ""
"Теперь обращение к имени ``a`` приведёт к ошибке (по крайней мере до тех "
"пор, пока ему снова не будет присвоено значение). Далее мы увидим и другие "
"применения инструкции :keyword:`del`."

#: ../../tutorial/datastructures.rst:369
msgid "Tuples and Sequences"
msgstr "Кортежи и последовательности"

#: ../../tutorial/datastructures.rst:371
msgid ""
"We saw that lists and strings have many common properties, such as indexing "
"and slicing operations.  They are two examples of *sequence* data types "
"(see :ref:`typesseq`).  Since Python is an evolving language, other sequence "
"data types may be added.  There is also another standard sequence data type: "
"the *tuple*."
msgstr ""
"Мы видели, что списки и строки имеют много общих свойств, таких как "
"индексация и операции со срезами. Они представляют собой 2 примера типов "
"данных *последовательностей* (смотри :ref:`typesseq`). Поскольку Python "
"развивается, могут появляться новые типы последовательностей. Существует "
"также ещё один стандартный тип данных последовательности: *кортеж*."

#: ../../tutorial/datastructures.rst:377
msgid ""
"A tuple consists of a number of values separated by commas, for instance::"
msgstr "Кортеж состоит из ряда значений, разделенных запятыми, например::"

#: ../../tutorial/datastructures.rst:379
msgid ""
">>> t = 12345, 54321, 'hello!'\n"
">>> t[0]\n"
"12345\n"
">>> t\n"
"(12345, 54321, 'hello!')\n"
">>> # Tuples may be nested:\n"
">>> u = t, (1, 2, 3, 4, 5)\n"
">>> u\n"
"((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))\n"
">>> # Tuples are immutable:\n"
">>> t[0] = 88888\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: 'tuple' object does not support item assignment\n"
">>> # but they can contain mutable objects:\n"
">>> v = ([1, 2, 3], [3, 2, 1])\n"
">>> v\n"
"([1, 2, 3], [3, 2, 1])"
msgstr ""
">>> t = 12345, 54321, 'привет!'\n"
">>> t[0]\n"
"12345\n"
">>> t\n"
"(12345, 54321, 'привет!')\n"
">>> # Кортежи могут быть вложенными:\n"
">>> u = t, (1, 2, 3, 4, 5)\n"
">>> u\n"
"((12345, 54321, 'привет!'), (1, 2, 3, 4, 5))\n"
">>> # Кортежи неизменяемы:\n"
">>> t[0] = 88888\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: 'tuple' object does not support item assignment\n"
">>> # но они могут содержать изменяемые объекты:\n"
">>> v = ([1, 2, 3], [3, 2, 1])\n"
">>> v\n"
"([1, 2, 3], [3, 2, 1])"

#: ../../tutorial/datastructures.rst:399
msgid ""
"As you see, on output tuples are always enclosed in parentheses, so that "
"nested tuples are interpreted correctly; they may be input with or without "
"surrounding parentheses, although often parentheses are necessary anyway (if "
"the tuple is part of a larger expression).  It is not possible to assign to "
"the individual items of a tuple, however it is possible to create tuples "
"which contain mutable objects, such as lists."
msgstr ""
"Как видно, при выводе кортежи всегда заключаются в круглые скобки, чтобы "
"вложенные кортежи интерпретировались правильно. Вводить их можно как со "
"скобками, так и без, хотя во многих случаях скобки всё равно необходимы "
"(если кортеж — часть большего выражения). Невозможно присваивать отдельным "
"элементам кортежа, однако можно создавать кортежи, содержащие изменяемые "
"объекты, такие как списки."

#: ../../tutorial/datastructures.rst:406
msgid ""
"Though tuples may seem similar to lists, they are often used in different "
"situations and for different purposes. Tuples are :term:`immutable`, and "
"usually contain a heterogeneous sequence of elements that are accessed via "
"unpacking (see later in this section) or indexing (or even by attribute in "
"the case of :func:`namedtuples <collections.namedtuple>`). Lists are :term:"
"`mutable`, and their elements are usually homogeneous and are accessed by "
"iterating over the list."
msgstr ""
"Хотя кортежи могут выглядеть похожими на списки, они часто используются в "
"разных ситуациях и для разных целей. Кортежи :term:`immutable` и обычно "
"содержат гетерогенную последовательность элементов, которая доступна через "
"распаковку (см. далее в этом разделе) или через индексацию (или даже через "
"атрибут, если это :func:`namedtuples <collections.namedtuple>`). Списки :"
"term:`mutable`, и их элементы обычно однородны и доступны при итерации по "
"ним."

#: ../../tutorial/datastructures.rst:414
msgid ""
"A special problem is the construction of tuples containing 0 or 1 items: the "
"syntax has some extra quirks to accommodate these.  Empty tuples are "
"constructed by an empty pair of parentheses; a tuple with one item is "
"constructed by following a value with a comma (it is not sufficient to "
"enclose a single value in parentheses). Ugly, but effective.  For example::"
msgstr ""
"Отдельная сложность заключается в построении кортежей, содержащих 0 или 1 "
"элемент: синтаксис имеет некоторые дополнительные особенности, к которым "
"нужно привыкнуть. Пустой кортеж создаётся пустой парой скобок; кортеж с "
"одним элементом — добавлением запятой после значения (недостаточно заключить "
"это значение в скобки). Некрасиво, но работает. Например::"

#: ../../tutorial/datastructures.rst:420
msgid ""
">>> empty = ()\n"
">>> singleton = 'hello',    # <-- note trailing comma\n"
">>> len(empty)\n"
"0\n"
">>> len(singleton)\n"
"1\n"
">>> singleton\n"
"('hello',)"
msgstr ""
">>> empty = ()\n"
">>> singleton = 'привет',    # <-- note trailing comma\n"
">>> len(empty)\n"
"0\n"
">>> len(singleton)\n"
"1\n"
">>> singleton\n"
"('привет',)"

#: ../../tutorial/datastructures.rst:429
msgid ""
"The statement ``t = 12345, 54321, 'hello!'`` is an example of *tuple "
"packing*: the values ``12345``, ``54321`` and ``'hello!'`` are packed "
"together in a tuple. The reverse operation is also possible::"
msgstr ""
"Инструкция ``t = 12345, 54321, 'hello!'`` — это пример  *упаковки кортежа*: "
"значения ``12345``, ``54321`` and ``'hello!'`` упакованы вместе в один "
"кортеж. Также возможна обратная операция::"

#: ../../tutorial/datastructures.rst:433
msgid ">>> x, y, z = t"
msgstr ">>> x, y, z = t"

#: ../../tutorial/datastructures.rst:435
msgid ""
"This is called, appropriately enough, *sequence unpacking* and works for any "
"sequence on the right-hand side.  Sequence unpacking requires that there are "
"as many variables on the left side of the equals sign as there are elements "
"in the sequence.  Note that multiple assignment is really just a combination "
"of tuple packing and sequence unpacking."
msgstr ""
"Это называется, соответственно,  *распаковкой последовательности* и работает "
"для любой последовательности с правой стороны. Распаковка последовательности "
"требует, чтобы слева от знака равенства было столько переменных, сколько "
"элементов в последовательности. Обратите внимание, что множественное "
"присваивание — это просто комбинация упаковки кортежа и распаковки "
"последовательности."

#: ../../tutorial/datastructures.rst:445
msgid "Sets"
msgstr "Множества"

#: ../../tutorial/datastructures.rst:447
msgid ""
"Python also includes a data type for :ref:`sets <types-set>`.  A set is an "
"unordered collection with no duplicate elements.  Basic uses include "
"membership testing and eliminating duplicate entries.  Set objects also "
"support mathematical operations like union, intersection, difference, and "
"symmetric difference."
msgstr ""
"Python также включает тип данных для :ref:`множеств <types-set>`. Множество "
"— это неупорядоченная коллекция без повторяющихся элементов. Множества в "
"основном используют для проверки принадлежности элементов и для устранения "
"дубликатов. Множества также поддерживают математические операции, такие как "
"объединение, пересечение, разность и симметричная разность."

#: ../../tutorial/datastructures.rst:453
msgid ""
"Curly braces or the :func:`set` function can be used to create sets.  Note: "
"to create an empty set you have to use ``set()``, not ``{}``; the latter "
"creates an empty dictionary, a data structure that we discuss in the next "
"section."
msgstr ""
"Множества можно создавать с помощью фигурных скобок или функции :func:`set`. "
"Примечание: чтобы создать пустое множество, нужно использовать ``set()``, а "
"не ``{}``; потому что последнее выражение создаёт пустой словарь — структуру "
"данных, которую мы обсудим в следующем разделе."

#: ../../tutorial/datastructures.rst:457
msgid "Here is a brief demonstration::"
msgstr "Вот краткая демонстрация::"

#: ../../tutorial/datastructures.rst:459
msgid ""
">>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}\n"
">>> print(basket)                      # show that duplicates have been "
"removed\n"
"{'orange', 'banana', 'pear', 'apple'}\n"
">>> 'orange' in basket                 # fast membership testing\n"
"True\n"
">>> 'crabgrass' in basket\n"
"False\n"
"\n"
">>> # Demonstrate set operations on unique letters from two words\n"
">>>\n"
">>> a = set('abracadabra')\n"
">>> b = set('alacazam')\n"
">>> a                                  # unique letters in a\n"
"{'a', 'r', 'b', 'c', 'd'}\n"
">>> a - b                              # letters in a but not in b\n"
"{'r', 'd', 'b'}\n"
">>> a | b                              # letters in a or b or both\n"
"{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}\n"
">>> a & b                              # letters in both a and b\n"
"{'a', 'c'}\n"
">>> a ^ b                              # letters in a or b but not both\n"
"{'r', 'd', 'b', 'm', 'z', 'l'}"
msgstr ""
">>> basket = {'яблоко', 'апельсин', 'яблоко', 'груша', 'апельсин', 'банан'}\n"
">>> print(basket)                      # показать, что дубликаты удалены\n"
"{'апельсин', 'банан', 'груша', 'яблоко'}\n"
">>> 'апельсин' in basket               # быстрая проверка принадлежности\n"
"True\n"
">>> 'пырей' in basket\n"
"False\n"
"\n"
">>> # Демонстрация операций над множествами уникальных букв двух слов\n"
">>>\n"
">>> a = set('абракадабра')\n"
">>> b = set('алакозам')\n"
">>> a                                  # уникальные буквы в a\n"
"{'б', 'а', 'р', 'к', 'д'}\n"
">>> a - b                              # буквы в a, но не в b\n"
"{'р', 'д', 'б'}\n"
">>> a | b                              # буквы в a или b, или в обоих\n"
"{'з', 'б', 'а', 'р', 'о', 'к', 'м', 'л', 'д'}\n"
">>> a & b                              # буквы в a или b, или в обоих\n"
"{'к', 'а'}\n"
">>> a ^ b                              # буквы в одном, но не в обоих\n"
"{'з', 'б', 'о', 'р', 'м', 'л', 'д'}"

#: ../../tutorial/datastructures.rst:482
msgid ""
"Similarly to :ref:`list comprehensions <tut-listcomps>`, set comprehensions "
"are also supported::"
msgstr ""
"Аналогично :ref:`включениям списков <tut-listcomps>` поддерживаются и "
"включения множеств::"

#: ../../tutorial/datastructures.rst:485
msgid ""
">>> a = {x for x in 'abracadabra' if x not in 'abc'}\n"
">>> a\n"
"{'r', 'd'}"
msgstr ""
">>> a = {x for x in 'абракадабра' if x not in 'абк'}\n"
">>> a\n"
"{'р', 'д'}"

#: ../../tutorial/datastructures.rst:493
msgid "Dictionaries"
msgstr "Словари"

#: ../../tutorial/datastructures.rst:495
msgid ""
"Another useful data type built into Python is the *dictionary* (see :ref:"
"`typesmapping`). Dictionaries are sometimes found in other languages as "
"\"associative memories\" or \"associative arrays\".  Unlike sequences, which "
"are indexed by a range of numbers, dictionaries are indexed by *keys*, which "
"can be any immutable type; strings and numbers can always be keys.  Tuples "
"can be used as keys if they contain only strings, numbers, or tuples; if a "
"tuple contains any mutable object either directly or indirectly, it cannot "
"be used as a key. You can't use lists as keys, since lists can be modified "
"in place using index assignments, slice assignments, or methods like :meth:"
"`~list.append` and :meth:`~list.extend`."
msgstr ""
"Ещё один полезный тип данных, встроенный в Python, — это *словарь* (см. :ref:"
"`typesmapping`). В других языках словари иногда называют *ассоциативной "
"памятью* или *ассоциативными массивами*. В отличие от последовательностей, "
"индексируемых диапазоном чисел, словари индексируются *ключами*, которыми "
"может быть любой неизменяемый тип; строки и числа всегда могут быть ключами. "
"Кортежи тоже могут быть ключами, если они содержат только строки, числа или "
"кортежи; если же кортеж содержит любой изменяемый объект напрямую или "
"косвенно, его нельзя использовать как ключ. Нельзя использовать списки как "
"ключи, поскольку списки можно изменять на месте с помощью присваивания "
"элементам, присваивания срезам или методов типа :meth:`~list.append` и :meth:"
"`~list.extend`."

#: ../../tutorial/datastructures.rst:506
msgid ""
"It is best to think of a dictionary as a set of *key: value* pairs, with the "
"requirement that the keys are unique (within one dictionary). A pair of "
"braces creates an empty dictionary: ``{}``. Placing a comma-separated list "
"of key:value pairs within the braces adds initial key:value pairs to the "
"dictionary; this is also the way dictionaries are written on output."
msgstr ""
"Удобнее всего думать о словаре как о множестве пар *ключ: значение* с "
"уникальными ключами (в пределах одного словаря). Пара фигурных скобок "
"создаёт пустой словарь: ``{}``. Размещение внутри скобок списка пар ключ:"
"значение, разделённых запятыми, добавляет эти пары в словарь. Этот же формат "
"используется при выводе словарей."

#: ../../tutorial/datastructures.rst:512
msgid ""
"The main operations on a dictionary are storing a value with some key and "
"extracting the value given the key.  It is also possible to delete a key:"
"value pair with ``del``. If you store using a key that is already in use, "
"the old value associated with that key is forgotten."
msgstr ""
"Основные операции со словарём — это сохранение и извлечение значения по "
"ключу. Также можно удалить пару ключ:значение с помощью ``del``. Если "
"сохранить значение по ключу, который уже используется, предыдущее значение, "
"связанное с ним, будет забыто."

#: ../../tutorial/datastructures.rst:517
msgid ""
"Extracting a value for a non-existent key by subscripting (``d[key]``) "
"raises a :exc:`KeyError`. To avoid getting this error when trying to access "
"a possibly non-existent key, use the :meth:`~dict.get` method instead, which "
"returns ``None`` (or a specified default value) if the key is not in the "
"dictionary."
msgstr ""
"Попытка извлечь значение по несуществующему ключу с помощью обращения "
"(``d[key]``) приводит к возбуждению исключения :exc:`KeyError`. Чтобы "
"избежать этого при обращении к потенциально отсутствующему ключу, "
"используйте метод :meth:`~dict.get`, который возвращает ``None`` (или "
"указанное значение по умолчанию), если ключа нет в словаре."

#: ../../tutorial/datastructures.rst:522
msgid ""
"Performing ``list(d)`` on a dictionary returns a list of all the keys used "
"in the dictionary, in insertion order (if you want it sorted, just use "
"``sorted(d)`` instead). To check whether a single key is in the dictionary, "
"use the :keyword:`in` keyword."
msgstr ""
"Выполнение ``list(d)`` для словаря возвращает список всех ключей в словаре, "
"в порядке их добавления (если они должны быть отсортированы — просто "
"вызовите ``sorted(d)``). Чтобы проверить наличие ключа в словаре, "
"используйте ключевое слово :keyword:`in`."

#: ../../tutorial/datastructures.rst:527
msgid "Here is a small example using a dictionary::"
msgstr "Вот небольшой пример использования словаря::"

#: ../../tutorial/datastructures.rst:529
msgid ""
">>> tel = {'jack': 4098, 'sape': 4139}\n"
">>> tel['guido'] = 4127\n"
">>> tel\n"
"{'jack': 4098, 'sape': 4139, 'guido': 4127}\n"
">>> tel['jack']\n"
"4098\n"
">>> tel['irv']\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"KeyError: 'irv'\n"
">>> print(tel.get('irv'))\n"
"None\n"
">>> del tel['sape']\n"
">>> tel['irv'] = 4127\n"
">>> tel\n"
"{'jack': 4098, 'guido': 4127, 'irv': 4127}\n"
">>> list(tel)\n"
"['jack', 'guido', 'irv']\n"
">>> sorted(tel)\n"
"['guido', 'irv', 'jack']\n"
">>> 'guido' in tel\n"
"True\n"
">>> 'jack' not in tel\n"
"False"
msgstr ""
">>> tel = {'jack': 4098, 'sape': 4139}\n"
">>> tel['guido'] = 4127\n"
">>> tel\n"
"{'jack': 4098, 'sape': 4139, 'guido': 4127}\n"
">>> tel['jack']\n"
"4098\n"
">>> tel['irv']\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"KeyError: 'irv'\n"
">>> print(tel.get('irv'))\n"
"None\n"
">>> del tel['sape']\n"
">>> tel['irv'] = 4127\n"
">>> tel\n"
"{'jack': 4098, 'guido': 4127, 'irv': 4127}\n"
">>> list(tel)\n"
"['jack', 'guido', 'irv']\n"
">>> sorted(tel)\n"
"['guido', 'irv', 'jack']\n"
">>> 'guido' in tel\n"
"True\n"
">>> 'jack' not in tel\n"
"False"

#: ../../tutorial/datastructures.rst:554
msgid ""
"The :func:`dict` constructor builds dictionaries directly from sequences of "
"key-value pairs::"
msgstr ""
"Конструктор :func:`dict` строит словарь напрямую из последовательности пар "
"ключ-значение::"

#: ../../tutorial/datastructures.rst:557
msgid ""
">>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])\n"
"{'sape': 4139, 'guido': 4127, 'jack': 4098}"
msgstr ""
">>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])\n"
"{'sape': 4139, 'guido': 4127, 'jack': 4098}"

#: ../../tutorial/datastructures.rst:560
msgid ""
"In addition, dict comprehensions can be used to create dictionaries from "
"arbitrary key and value expressions::"
msgstr ""
"Кроме того, включения словарей можно использовать для их создания с помощью "
"произвольных выражений для ключей и значений::"

#: ../../tutorial/datastructures.rst:563
msgid ""
">>> {x: x**2 for x in (2, 4, 6)}\n"
"{2: 4, 4: 16, 6: 36}"
msgstr ""
">>> {x: x**2 for x in (2, 4, 6)}\n"
"{2: 4, 4: 16, 6: 36}"

#: ../../tutorial/datastructures.rst:566
msgid ""
"When the keys are simple strings, it is sometimes easier to specify pairs "
"using keyword arguments::"
msgstr ""
"Когда ключи — простые строки, иногда проще указывать пары через именованные "
"аргументы::"

#: ../../tutorial/datastructures.rst:569
msgid ""
">>> dict(sape=4139, guido=4127, jack=4098)\n"
"{'sape': 4139, 'guido': 4127, 'jack': 4098}"
msgstr ""
">>> dict(sape=4139, guido=4127, jack=4098)\n"
"{'sape': 4139, 'guido': 4127, 'jack': 4098}"

#: ../../tutorial/datastructures.rst:576
msgid "Looping Techniques"
msgstr "Техники перебора"

#: ../../tutorial/datastructures.rst:578
msgid ""
"When looping through dictionaries, the key and corresponding value can be "
"retrieved at the same time using the :meth:`~dict.items` method. ::"
msgstr ""
"При переборе словаря можно одновременно получать ключ и соответствующее "
"значение с помощью метода :meth:`~dict.items`. ::"

#: ../../tutorial/datastructures.rst:581
msgid ""
">>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}\n"
">>> for k, v in knights.items():\n"
"...     print(k, v)\n"
"...\n"
"gallahad the pure\n"
"robin the brave"
msgstr ""
">>> knights = {'галахад': 'чистый', 'робин': 'храбрый'}\n"
">>> for k, v in knights.items():\n"
"...     print(k, v)\n"
"...\n"
"галахад чистый\n"
"робин храбрый"

#: ../../tutorial/datastructures.rst:588
msgid ""
"When looping through a sequence, the position index and corresponding value "
"can be retrieved at the same time using the :func:`enumerate` function. ::"
msgstr ""
"При переборе последовательности индекс позиции и соответствующее значение "
"могут быть получены одновременно с помощью функции :func:`enumerate`. ::"

#: ../../tutorial/datastructures.rst:591
msgid ""
">>> for i, v in enumerate(['tic', 'tac', 'toe']):\n"
"...     print(i, v)\n"
"...\n"
"0 tic\n"
"1 tac\n"
"2 toe"
msgstr ""
">>> for i, v in enumerate(['tic', 'tac', 'toe']):\n"
"...     print(i, v)\n"
"...\n"
"0 tic\n"
"1 tac\n"
"2 toe"

#: ../../tutorial/datastructures.rst:598
msgid ""
"To loop over two or more sequences at the same time, the entries can be "
"paired with the :func:`zip` function. ::"
msgstr ""
"Чтобы перебирать две или более последовательности одновременно, их элементы "
"можно объединить в пары с помощью функции :func:`zip`. ::"

#: ../../tutorial/datastructures.rst:601
msgid ""
">>> questions = ['name', 'quest', 'favorite color']\n"
">>> answers = ['lancelot', 'the holy grail', 'blue']\n"
">>> for q, a in zip(questions, answers):\n"
"...     print('What is your {0}?  It is {1}.'.format(q, a))\n"
"...\n"
"What is your name?  It is lancelot.\n"
"What is your quest?  It is the holy grail.\n"
"What is your favorite color?  It is blue."
msgstr ""
">>> questions = ['имя', 'замысел', 'любимый цвет']\n"
">>> answers = ['ланселот', 'святой грааль', 'синий']\n"
">>> for q, a in zip(questions, answers):\n"
"...     print('Какой у тебя {0}?  Это {1}.'.format(q, a))\n"
"...\n"
"Какой у тебя имя? Это ланселот.\n"
"Какой у тебя замысел? Это святой грааль.\n"
"Какой у тебя любимый цвет? Это синий."

#: ../../tutorial/datastructures.rst:610
msgid ""
"To loop over a sequence in reverse, first specify the sequence in a forward "
"direction and then call the :func:`reversed` function. ::"
msgstr ""
"Для перебора последовательности в обратном порядке, можно воспользоваться "
"функцией :func:`reversed`. ::"

#: ../../tutorial/datastructures.rst:613
msgid ""
">>> for i in reversed(range(1, 10, 2)):\n"
"...     print(i)\n"
"...\n"
"9\n"
"7\n"
"5\n"
"3\n"
"1"
msgstr ""
">>> for i in reversed(range(1, 10, 2)):\n"
"...     print(i)\n"
"...\n"
"9\n"
"7\n"
"5\n"
"3\n"
"1"

#: ../../tutorial/datastructures.rst:622
msgid ""
"To loop over a sequence in sorted order, use the :func:`sorted` function "
"which returns a new sorted list while leaving the source unaltered. ::"
msgstr ""
"Для перебора последовательности в отсортированном порядке используйте "
"функцию :func:`sorted`, которая возвращает новый отсортированный список, "
"оставляя исходную последовательность неизменной. ::"

#: ../../tutorial/datastructures.rst:625
msgid ""
">>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n"
">>> for i in sorted(basket):\n"
"...     print(i)\n"
"...\n"
"apple\n"
"apple\n"
"banana\n"
"orange\n"
"orange\n"
"pear"
msgstr ""
">>> basket = ['яблоко', 'апельсин', 'яблоко', 'груша', 'апельсин', 'банан']\n"
">>> for i in sorted(basket):\n"
"...     print(i)\n"
"...\n"
"апельсин\n"
"апельсин\n"
"банан\n"
"груша\n"
"яблоко\n"
"яблоко"

#: ../../tutorial/datastructures.rst:636
msgid ""
"Using :func:`set` on a sequence eliminates duplicate elements. The use of :"
"func:`sorted` in combination with :func:`set` over a sequence is an "
"idiomatic way to loop over unique elements of the sequence in sorted "
"order. ::"
msgstr ""
"Использование :func:`set` в последовательности удаляет повторяющиеся "
"элементы. Использование :func:`sorted` в сочетании с :func:`set` над "
"последовательностью является идиоматическим способом обхода уникальных "
"элементов последовательности в отсортированном порядке. ::"

#: ../../tutorial/datastructures.rst:640
msgid ""
">>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n"
">>> for f in sorted(set(basket)):\n"
"...     print(f)\n"
"...\n"
"apple\n"
"banana\n"
"orange\n"
"pear"
msgstr ""
">>> basket = ['яблоко', 'апельсин', 'яблоко', 'груша', 'апельсин', 'банан']\n"
">>> for f in sorted(set(basket)):\n"
"...     print(f)\n"
"...\n"
"апельсин\n"
"банан\n"
"груша\n"
"яблоко"

#: ../../tutorial/datastructures.rst:649
msgid ""
"It is sometimes tempting to change a list while you are looping over it; "
"however, it is often simpler and safer to create a new list instead. ::"
msgstr ""
"Иногда возникает соблазн изменить список во время его обхода; однако часто "
"проще и безопаснее вместо этого создать новый список. ::"

#: ../../tutorial/datastructures.rst:652
msgid ""
">>> import math\n"
">>> raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]\n"
">>> filtered_data = []\n"
">>> for value in raw_data:\n"
"...     if not math.isnan(value):\n"
"...         filtered_data.append(value)\n"
"...\n"
">>> filtered_data\n"
"[56.2, 51.7, 55.3, 52.5, 47.8]"
msgstr ""
">>> import math\n"
">>> raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]\n"
">>> filtered_data = []\n"
">>> for value in raw_data:\n"
"...     if not math.isnan(value):\n"
"...         filtered_data.append(value)\n"
"...\n"
">>> filtered_data\n"
"[56.2, 51.7, 55.3, 52.5, 47.8]"

#: ../../tutorial/datastructures.rst:666
msgid "More on Conditions"
msgstr "Больше о условиях"

#: ../../tutorial/datastructures.rst:668
msgid ""
"The conditions used in ``while`` and ``if`` statements can contain any "
"operators, not just comparisons."
msgstr ""
"Условия, используемые в инструкциях ``while`` и ``if``, могут содержать "
"любые операторы, а не только сравнения."

#: ../../tutorial/datastructures.rst:672
msgid ""
"The comparison operators ``in`` and ``not in`` are membership tests that "
"determine whether a value is in (or not in) a container.  The operators "
"``is`` and ``is not`` compare whether two objects are really the same "
"object.  All comparison operators have the same priority, which is lower "
"than that of all numerical operators."
msgstr ""
"Операторы сравнения ``in`` и ``not in`` проверяют принадлежность, то есть "
"определяют, находится ли значение в контейнере (или нет). Операторы ``is`` и "
"``is not`` сравнивают, являются ли два объекта действительно одним и тем же "
"объектом. Все операторы сравнения имеют одинаковый приоритет, который ниже, "
"чем у всех числовых операторов."

#: ../../tutorial/datastructures.rst:678
msgid ""
"Comparisons can be chained.  For example, ``a < b == c`` tests whether ``a`` "
"is less than ``b`` and moreover ``b`` equals ``c``."
msgstr ""
"Сравнения можно объединять в цепочки. Например, ``a < b == c`` проверяет, "
"является ли ``a`` меньше значения ``b`` и, кроме того, равно ли ``b`` "
"значению ``c``."

#: ../../tutorial/datastructures.rst:681
msgid ""
"Comparisons may be combined using the Boolean operators ``and`` and ``or``, "
"and the outcome of a comparison (or of any other Boolean expression) may be "
"negated with ``not``.  These have lower priorities than comparison "
"operators; between them, ``not`` has the highest priority and ``or`` the "
"lowest, so that ``A and not B or C`` is equivalent to ``(A and (not B)) or "
"C``. As always, parentheses can be used to express the desired composition."
msgstr ""
"Сравнения можно объединять с использованием логических операторов ``and`` и "
"``or``, и результат сравнения (или любого другого логического выражения) "
"можно отрицать с помощью ``not``. Они имеют более низкий приоритет, чем "
"операторы сравнения; среди них ``not`` имеет наивысший приоритет, а ``or`` — "
"наименьший, так что ``A and not B or C`` эквивалентно ``(A and (not B)) or "
"C``. Как всегда, скобки могут быть использованы для выражения нужной "
"структуры."

#: ../../tutorial/datastructures.rst:688
msgid ""
"The Boolean operators ``and`` and ``or`` are so-called *short-circuit* "
"operators: their arguments are evaluated from left to right, and evaluation "
"stops as soon as the outcome is determined.  For example, if ``A`` and ``C`` "
"are true but ``B`` is false, ``A and B and C`` does not evaluate the "
"expression ``C``.  When used as a general value and not as a Boolean, the "
"return value of a short-circuit operator is the last evaluated argument."
msgstr ""
"Логические операторы ``and`` и ``or`` вычисляются по так называемой "
"*короткой схеме*: их аргументы вычисляются слева направо, и вычисление "
"прекращается, как только определён результат. Например, если ``A`` и ``C`` "
"истинны, но ``B`` ложно, ``A and B and C`` не вычисляет выражение ``C``. При "
"использовании таких выражений в качестве обычных значений, а не логических, "
"возвращаемым значением оператора, вычисляемого по короткой схеме, является "
"последний вычисленный аргумент."

#: ../../tutorial/datastructures.rst:695
msgid ""
"It is possible to assign the result of a comparison or other Boolean "
"expression to a variable.  For example, ::"
msgstr ""
"Переменной можно присвоить результат сравнения или другое логическое "
"выражение. Например, ::"

#: ../../tutorial/datastructures.rst:698
msgid ""
">>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'\n"
">>> non_null = string1 or string2 or string3\n"
">>> non_null\n"
"'Trondheim'"
msgstr ""
">>> string1, string2, string3 = '', ' Тронхейм', 'Танец Хаммера'\n"
">>> non_null = string1 or string2 or string3\n"
">>> non_null\n"
"' Тронхейм'"

#: ../../tutorial/datastructures.rst:703
msgid ""
"Note that in Python, unlike C, assignment inside expressions must be done "
"explicitly with the :ref:`walrus operator <why-can-t-i-use-an-assignment-in-"
"an-expression>` ``:=``. This avoids a common class of problems encountered "
"in C programs: typing ``=`` in an expression when ``==`` was intended."
msgstr ""
"Обратите внимание, что в Python, в отличие от C, присваивание внутри "
"выражений должно выполняться явно с помощью :ref:`моржового оператора <why-"
"can-t-i-use-an-assignment-in-an-expression>` ``:=``. Это позволяет избежать "
"общего класса проблем, встречающихся в программах на C: использование ``=`` "
"в выражении, когда предполагалось ``==``."

#: ../../tutorial/datastructures.rst:713
msgid "Comparing Sequences and Other Types"
msgstr "Сравнение последовательностей и других типов"

#: ../../tutorial/datastructures.rst:714
msgid ""
"Sequence objects typically may be compared to other objects with the same "
"sequence type. The comparison uses *lexicographical* ordering: first the "
"first two items are compared, and if they differ this determines the outcome "
"of the comparison; if they are equal, the next two items are compared, and "
"so on, until either sequence is exhausted. If two items to be compared are "
"themselves sequences of the same type, the lexicographical comparison is "
"carried out recursively.  If all items of two sequences compare equal, the "
"sequences are considered equal. If one sequence is an initial sub-sequence "
"of the other, the shorter sequence is the smaller (lesser) one.  "
"Lexicographical ordering for strings uses the Unicode code point number to "
"order individual characters. Some examples of comparisons between sequences "
"of the same type::"
msgstr ""
"Объекты-последовательности обычно можно сравнивать с другими объектами того "
"же типа последовательности. При сравнении используется *лексикографический* "
"порядок: сначала сравниваются первые два элемента, и если они отличаются, "
"это определяет результат сравнения; если они равны, сравниваются следующие "
"два элемента, и так далее, пока одна из последовательностей не закончится. "
"Если два сравниваемых элемента сами по себе являются последовательностями "
"одного типа, лексикографическое сравнение выполняется рекурсивно. Если все "
"элементы двух последовательностей оказываются равными, последовательности "
"считаются равными. Если одна последовательность является начальной "
"подпоследовательностью другой, то более короткая последовательность является "
"меньшей. Лексикографический порядок строк использует номер кодовой точки "
"Unicode для упорядочивания отдельных символов. Некоторые примеры сравнений "
"между последовательностями одного типа::"

#: ../../tutorial/datastructures.rst:726
msgid ""
"(1, 2, 3)              < (1, 2, 4)\n"
"[1, 2, 3]              < [1, 2, 4]\n"
"'ABC' < 'C' < 'Pascal' < 'Python'\n"
"(1, 2, 3, 4)           < (1, 2, 4)\n"
"(1, 2)                 < (1, 2, -1)\n"
"(1, 2, 3)             == (1.0, 2.0, 3.0)\n"
"(1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)"
msgstr ""
"(1, 2, 3)              < (1, 2, 4)\n"
"[1, 2, 3]              < [1, 2, 4]\n"
"'ABC' < 'C' < 'Pascal' < 'Python'\n"
"(1, 2, 3, 4)           < (1, 2, 4)\n"
"(1, 2)                 < (1, 2, -1)\n"
"(1, 2, 3)             == (1.0, 2.0, 3.0)\n"
"(1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)"

#: ../../tutorial/datastructures.rst:734
msgid ""
"Note that comparing objects of different types with ``<`` or ``>`` is legal "
"provided that the objects have appropriate comparison methods.  For example, "
"mixed numeric types are compared according to their numeric value, so 0 "
"equals 0.0, etc.  Otherwise, rather than providing an arbitrary ordering, "
"the interpreter will raise a :exc:`TypeError` exception."
msgstr ""
"Обратите внимание, что сравнение объектов разных типов с помощью ``<`` или "
"``>`` допустимо при условии, что объекты имеют соответствующие методы "
"сравнения. Например, смешанные числовые типы сравниваются по их числовому "
"значению, поэтому 0 равно 0.0 и т.д. В противном случае, вместо того чтобы "
"вводить какой-либо произвольный порядок сравнения, интерпретатор выбросит "
"исключение :exc:`TypeError`."

#: ../../tutorial/datastructures.rst:742
msgid "Footnotes"
msgstr "Сноски"

#: ../../tutorial/datastructures.rst:743
msgid ""
"Other languages may return the mutated object, which allows method chaining, "
"such as ``d->insert(\"a\")->remove(\"b\")->sort();``."
msgstr ""
"Другие языки могут возвращать изменённый объект, что позволяет вызывать "
"методы цепочкой, например ``d->insert(\"a\")->remove(\"b\")->sort();``."
