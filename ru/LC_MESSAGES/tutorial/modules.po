# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-10 15:26+0000\n"
"PO-Revision-Date: 2023-05-24 02:23+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../tutorial/modules.rst:5
msgid "Modules"
msgstr "Модули"

#: ../../tutorial/modules.rst:7
msgid ""
"If you quit from the Python interpreter and enter it again, the definitions "
"you have made (functions and variables) are lost. Therefore, if you want to "
"write a somewhat longer program, you are better off using a text editor to "
"prepare the input for the interpreter and running it with that file as input "
"instead.  This is known as creating a *script*.  As your program gets "
"longer, you may want to split it into several files for easier maintenance.  "
"You may also want to use a handy function that you've written in several "
"programs without copying its definition into each program."
msgstr ""
"Если вы выйдете из интерпретатора Python и войдёте в него снова, сделанные "
"вами определения (функции и переменные) будут потеряны. Поэтому, если вы "
"хотите написать более длинную программу, вам лучше использовать текстовый "
"редактор, чтобы подготовить ввод для интерпретатора, и запустить его с этим "
"файлом в качестве входных данных. Это называется созданием *скрипта*. По "
"мере того, как ваша программа становится длиннее, вы можете разделить ее на "
"несколько файлов для упрощения обслуживания. Вы также можете использовать "
"удобную функцию, которую вы написали в нескольких программах, не копируя ее "
"определение в каждую программу."

#: ../../tutorial/modules.rst:16
msgid ""
"To support this, Python has a way to put definitions in a file and use them "
"in a script or in an interactive instance of the interpreter. Such a file is "
"called a *module*; definitions from a module can be *imported* into other "
"modules or into the *main* module (the collection of variables that you have "
"access to in a script executed at the top level and in calculator mode)."
msgstr ""
"Чтобы поддержать это, в Python есть способ поместить определения в файл и "
"использовать их в сценарии или в интерактивном экземпляре интерпретатора. "
"Такой файл называется *модулем*; определения из модуля могут быть "
"*импортированы* в другие модули или в *основной* модуль (набор переменных, к "
"которым у вас есть доступ в скрипте, выполняемом на верхнем уровне и в "
"режиме калькулятора)."

#: ../../tutorial/modules.rst:22
msgid ""
"A module is a file containing Python definitions and statements.  The file "
"name is the module name with the suffix :file:`.py` appended.  Within a "
"module, the module's name (as a string) is available as the value of the "
"global variable ``__name__``.  For instance, use your favorite text editor "
"to create a file called :file:`fibo.py` in the current directory with the "
"following contents::"
msgstr ""
"Модуль — это файл, содержащий определения и операторы Python. Имя файла — "
"это имя модуля с добавленным суффиксом :file:`.py`. Внутри модуля имя модуля "
"(в виде строки) доступно как значение глобальной переменной ``__name__``. "
"Например, используйте ваш любимый текстовый редактор, чтобы создать файл с "
"именем :file:`fibo.py` в текущем каталоге со следующим содержимым:"

#: ../../tutorial/modules.rst:45
msgid ""
"Now enter the Python interpreter and import this module with the following "
"command::"
msgstr ""
"Теперь войдите в интерпретатор Python и импортируйте этот модуль с помощью "
"следующей команды:"

#: ../../tutorial/modules.rst:50
msgid ""
"This does not add the names of the functions defined in ``fibo``  directly "
"to the current :term:`namespace` (see :ref:`tut-scopes` for more details); "
"it only adds the module name ``fibo`` there. Using the module name you can "
"access the functions::"
msgstr ""
"Это не добавляет имена функций, определенных в ``fibo``, непосредственно в "
"текущее :term:`namespace` (подробнее см. :ref:`tut-scopes`); он только "
"добавляет туда имя модуля ``fibo``. Используя имя модуля, вы можете получить "
"доступ к функциям::"

#: ../../tutorial/modules.rst:62
msgid ""
"If you intend to use a function often you can assign it to a local name::"
msgstr ""
"Если вы собираетесь часто использовать функцию, вы можете присвоить ей "
"локальное имя:"

#: ../../tutorial/modules.rst:72
msgid "More on Modules"
msgstr "Подробнее о модулях"

#: ../../tutorial/modules.rst:74
msgid ""
"A module can contain executable statements as well as function definitions. "
"These statements are intended to initialize the module. They are executed "
"only the *first* time the module name is encountered in an import statement. "
"[#]_ (They are also run if the file is executed as a script.)"
msgstr ""
"Модуль может содержать исполняемые инструкции, а также определения функций. "
"Эти операторы предназначены для инициализации модуля. Они выполняются только "
"в *первый* раз, когда имя модуля встречается в операторе импорта. [#]_ (Они "
"также запускаются, если файл выполняется как сценарий.)"

#: ../../tutorial/modules.rst:79
msgid ""
"Each module has its own private namespace, which is used as the global "
"namespace by all functions defined in the module. Thus, the author of a "
"module can use global variables in the module without worrying about "
"accidental clashes with a user's global variables. On the other hand, if you "
"know what you are doing you can touch a module's global variables with the "
"same notation used to refer to its functions, ``modname.itemname``."
msgstr ""
"Каждый модуль имеет свое собственное частное пространство имен, которое "
"используется в качестве глобального пространства имен всеми функциями, "
"определенными в модуле. Таким образом, автор модуля может использовать "
"глобальные переменные в модуле, не беспокоясь о случайных конфликтах с "
"глобальными переменными пользователя. С другой стороны, если вы знаете, что "
"делаете, вы можете использовать глобальные переменные модуля с той же "
"нотацией, которая используется для обозначения его функций: ``имя_модуля."
"имя_элемента``."

#: ../../tutorial/modules.rst:86
msgid ""
"Modules can import other modules.  It is customary but not required to place "
"all :keyword:`import` statements at the beginning of a module (or script, "
"for that matter).  The imported module names, if placed at the top level of "
"a module (outside any functions or classes), are added to the module's "
"global namespace."
msgstr ""
"Модули могут импортировать другие модули. Обычно, но не обязательно, "
"размещать все операторы :keyword:`import` в начале модуля (или сценария, "
"если на то пошло). Имена импортированных модулей, если они размещены на "
"верхнем уровне модуля (вне каких-либо функций или классов), добавляются в "
"глобальное пространство имен модуля."

#: ../../tutorial/modules.rst:91
msgid ""
"There is a variant of the :keyword:`import` statement that imports names "
"from a module directly into the importing module's namespace.  For example::"
msgstr ""
"Существует вариант оператора :keyword:`import`, который импортирует имена из "
"модуля непосредственно в пространство имен импортирующего модуля. Например::"

#: ../../tutorial/modules.rst:98
msgid ""
"This does not introduce the module name from which the imports are taken in "
"the local namespace (so in the example, ``fibo`` is not defined)."
msgstr ""
"Это не вводит имя модуля, из которого осуществляется импорт, в локальном "
"пространстве имен (поэтому в примере ``fibo`` не определено)."

#: ../../tutorial/modules.rst:101
msgid "There is even a variant to import all names that a module defines::"
msgstr "Есть даже вариант импортировать все имена, которые определяет модуль:"

#: ../../tutorial/modules.rst:107
msgid ""
"This imports all names except those beginning with an underscore (``_``). In "
"most cases Python programmers do not use this facility since it introduces "
"an unknown set of names into the interpreter, possibly hiding some things "
"you have already defined."
msgstr ""
"При этом будут импортированы все имена, кроме тех, которые начинаются с "
"подчеркивания (``_``). В большинстве случаев программисты Python не "
"используют эту возможность, поскольку она вводит в интерпретатор неизвестный "
"набор имен, возможно, скрывая некоторые вещи, которые вы уже определили."

#: ../../tutorial/modules.rst:112
msgid ""
"Note that in general the practice of importing ``*`` from a module or "
"package is frowned upon, since it often causes poorly readable code. "
"However, it is okay to use it to save typing in interactive sessions."
msgstr ""
"Обратите внимание, что в целом практика импорта ``*`` из модуля или пакета "
"не одобряется, поскольку это часто приводит к плохо читаемому коду. Однако "
"его можно использовать, чтобы не печатать в интерактивных сеансах."

#: ../../tutorial/modules.rst:116
msgid ""
"If the module name is followed by :keyword:`!as`, then the name following :"
"keyword:`!as` is bound directly to the imported module."
msgstr ""
"Если за именем модуля следует :keyword:`!as`, то имя, следующее за :keyword:"
"`!as`, привязывается непосредственно к импортированному модулю."

#: ../../tutorial/modules.rst:125
msgid ""
"This is effectively importing the module in the same way that ``import "
"fibo`` will do, with the only difference of it being available as ``fib``."
msgstr ""
"Это фактически импортирует модуль так же, как и import fibo, с той лишь "
"разницей, что он доступен как fib."

#: ../../tutorial/modules.rst:128
msgid ""
"It can also be used when utilising :keyword:`from` with similar effects::"
msgstr ""
"Его также можно использовать при использовании :keyword:`from` с "
"аналогичными эффектами::"

#: ../../tutorial/modules.rst:137
msgid ""
"For efficiency reasons, each module is only imported once per interpreter "
"session.  Therefore, if you change your modules, you must restart the "
"interpreter -- or, if it's just one module you want to test interactively, "
"use :func:`importlib.reload`, e.g. ``import importlib; importlib."
"reload(modulename)``."
msgstr ""
"По соображениям эффективности каждый модуль импортируется только один раз за "
"сеанс интерпретатора. Поэтому, если вы меняете свои модули, вы должны "
"перезапустить интерпретатор - или, если вы хотите протестировать в "
"интерактивном режиме только один модуль, используйте :func:`importlib."
"reload`, например ``import importlib; importlib.reload(имя модуля)``."

#: ../../tutorial/modules.rst:147
msgid "Executing modules as scripts"
msgstr "Выполнение модулей как скриптов"

#: ../../tutorial/modules.rst:149
msgid "When you run a Python module with ::"
msgstr "Когда вы запускаете модуль Python с помощью ::"

#: ../../tutorial/modules.rst:153
msgid ""
"the code in the module will be executed, just as if you imported it, but "
"with the ``__name__`` set to ``\"__main__\"``.  That means that by adding "
"this code at the end of your module::"
msgstr ""
"код в модуле будет выполнен так же, как если бы вы его импортировали, но с "
"параметром ``__name__``, установленным в ``\"__main__\"``. Это означает, что "
"добавив этот код в конец вашего модуля:"

#: ../../tutorial/modules.rst:161
msgid ""
"you can make the file usable as a script as well as an importable module, "
"because the code that parses the command line only runs if the module is "
"executed as the \"main\" file:"
msgstr ""
"вы можете сделать файл пригодным для использования как в качестве сценария, "
"так и в качестве импортируемого модуля, поскольку код, анализирующий "
"командную строку, запускается только в том случае, если модуль выполняется "
"как «основной» файл:"

#: ../../tutorial/modules.rst:170
msgid "If the module is imported, the code is not run::"
msgstr "Если модуль импортирован, код не запускается::"

#: ../../tutorial/modules.rst:175
msgid ""
"This is often used either to provide a convenient user interface to a "
"module, or for testing purposes (running the module as a script executes a "
"test suite)."
msgstr ""
"Это часто используется либо для предоставления удобного пользовательского "
"интерфейса к модулю, либо для целей тестирования (запуск модуля как сценария "
"запускает набор тестов)."

#: ../../tutorial/modules.rst:182
msgid "The Module Search Path"
msgstr "Путь поиска модуля"

#: ../../tutorial/modules.rst:186
msgid ""
"When a module named :mod:`!spam` is imported, the interpreter first searches "
"for a built-in module with that name. These module names are listed in :data:"
"`sys.builtin_module_names`. If not found, it then searches for a file named :"
"file:`spam.py` in a list of directories given by the variable :data:`sys."
"path`.  :data:`sys.path` is initialized from these locations:"
msgstr ""
"Когда импортируется модуль с именем :mod:`!spam`, интерпретатор сначала ищет "
"встроенный модуль с таким именем. Имена этих модулей перечислены в :data:"
"`sys.builtin_module_names`. Если он не найден, он ищет файл с именем :file:"
"`spam.py` в списке каталогов, заданном переменной :data:`sys.path`. :data:"
"`sys.path` инициализируется из следующих мест:"

#: ../../tutorial/modules.rst:192
msgid ""
"The directory containing the input script (or the current directory when no "
"file is specified)."
msgstr ""
"Каталог, содержащий входной скрипт (или текущий каталог, если файл не "
"указан)."

#: ../../tutorial/modules.rst:194
msgid ""
":envvar:`PYTHONPATH` (a list of directory names, with the same syntax as the "
"shell variable :envvar:`PATH`)."
msgstr ""
":envvar:`PYTHONPATH` (список имен каталогов с тем же синтаксисом, что и "
"переменная оболочки :envvar:`PATH`)."

#: ../../tutorial/modules.rst:196
msgid ""
"The installation-dependent default (by convention including a ``site-"
"packages`` directory, handled by the :mod:`site` module)."
msgstr ""
"Зависит от установки по умолчанию (по соглашению включает каталог ``site-"
"packages``, обрабатываемый модулем :mod:`site`)."

#: ../../tutorial/modules.rst:199
msgid "More details are at :ref:`sys-path-init`."
msgstr "Более подробную информацию можно найти по адресу :ref:`sys-path-init`."

#: ../../tutorial/modules.rst:202
msgid ""
"On file systems which support symlinks, the directory containing the input "
"script is calculated after the symlink is followed. In other words the "
"directory containing the symlink is **not** added to the module search path."
msgstr ""
"В файловых системах, поддерживающих символические ссылки, каталог, "
"содержащий входной сценарий, рассчитывается после перехода по символической "
"ссылке. Другими словами, каталог, содержащий символическую ссылку, **не** "
"добавляется в путь поиска модуля."

#: ../../tutorial/modules.rst:206
msgid ""
"After initialization, Python programs can modify :data:`sys.path`.  The "
"directory containing the script being run is placed at the beginning of the "
"search path, ahead of the standard library path. This means that scripts in "
"that directory will be loaded instead of modules of the same name in the "
"library directory. This is an error unless the replacement is intended.  See "
"section :ref:`tut-standardmodules` for more information."
msgstr ""
"После инициализации программы Python могут изменять :data:`sys.path`. "
"Каталог, содержащий запускаемый сценарий, размещается в начале пути поиска "
"перед стандартным путем к библиотеке. Это означает, что скрипты в этом "
"каталоге будут загружены вместо одноименных модулей в каталоге библиотеки. "
"Это ошибка, если замена не предусмотрена. Дополнительную информацию смотрите "
"в разделе :ref:`tut-standardmodules`."

#: ../../tutorial/modules.rst:219
msgid "\"Compiled\" Python files"
msgstr "«Скомпилированные» файлы Python"

#: ../../tutorial/modules.rst:221
msgid ""
"To speed up loading modules, Python caches the compiled version of each "
"module in the ``__pycache__`` directory under the name :file:`module."
"{version}.pyc`, where the version encodes the format of the compiled file; "
"it generally contains the Python version number.  For example, in CPython "
"release 3.3 the compiled version of spam.py would be cached as ``__pycache__/"
"spam.cpython-33.pyc``.  This naming convention allows compiled modules from "
"different releases and different versions of Python to coexist."
msgstr ""
"Чтобы ускорить загрузку модулей, Python кэширует скомпилированную версию "
"каждого модуля в каталоге ``__pycache__`` под именем :file:`module.{version}."
"pyc`, где версия кодирует формат скомпилированного файла; обычно он содержит "
"номер версии Python. Например, в CPython версии 3.3 скомпилированная версия "
"spam.py будет кэшироваться как ``__pycache__/spam.cpython-33.pyc``. Такое "
"соглашение об именах позволяет сосуществовать скомпилированным модулям из "
"разных выпусков и разных версий Python."

#: ../../tutorial/modules.rst:229
msgid ""
"Python checks the modification date of the source against the compiled "
"version to see if it's out of date and needs to be recompiled.  This is a "
"completely automatic process.  Also, the compiled modules are platform-"
"independent, so the same library can be shared among systems with different "
"architectures."
msgstr ""
"Python сверяет дату изменения исходного кода с скомпилированной версией, "
"чтобы убедиться, что она не устарела и не требует перекомпиляции. Это "
"полностью автоматический процесс. Кроме того, скомпилированные модули не "
"зависят от платформы, поэтому одну и ту же библиотеку можно использовать в "
"системах с разной архитектурой."

#: ../../tutorial/modules.rst:234
msgid ""
"Python does not check the cache in two circumstances.  First, it always "
"recompiles and does not store the result for the module that's loaded "
"directly from the command line.  Second, it does not check the cache if "
"there is no source module.  To support a non-source (compiled only) "
"distribution, the compiled module must be in the source directory, and there "
"must not be a source module."
msgstr ""
"Python не проверяет кеш в двух случаях. Во-первых, он всегда перекомпилирует "
"и не сохраняет результат для модуля, загруженного непосредственно из "
"командной строки. Во-вторых, он не проверяет кеш, если нет исходного модуля. "
"Для поддержки дистрибутива без исходного кода (только скомпилированного) "
"скомпилированный модуль должен находиться в каталоге с исходным кодом и не "
"должно быть исходного модуля."

#: ../../tutorial/modules.rst:241
msgid "Some tips for experts:"
msgstr "Несколько советов для экспертов:"

#: ../../tutorial/modules.rst:243
msgid ""
"You can use the :option:`-O` or :option:`-OO` switches on the Python command "
"to reduce the size of a compiled module.  The ``-O`` switch removes assert "
"statements, the ``-OO`` switch removes both assert statements and __doc__ "
"strings.  Since some programs may rely on having these available, you should "
"only use this option if you know what you're doing.  \"Optimized\" modules "
"have an ``opt-`` tag and are usually smaller.  Future releases may change "
"the effects of optimization."
msgstr ""
"Вы можете использовать переключатели :option:`-O` или :option:`-OO` в "
"команде Python, чтобы уменьшить размер скомпилированного модуля. "
"Переключатель ``-O`` удаляет утверждения утверждения, переключатель ``-OO`` "
"удаляет как утверждения утверждения, так и строки __doc__. Поскольку "
"некоторые программы могут полагаться на их наличие, вам следует использовать "
"эту опцию только в том случае, если вы знаете, что делаете. "
"«Оптимизированные» модули имеют тег ``opt-`` и обычно имеют меньший размер. "
"В будущих выпусках результаты оптимизации могут измениться."

#: ../../tutorial/modules.rst:251
msgid ""
"A program doesn't run any faster when it is read from a ``.pyc`` file than "
"when it is read from a ``.py`` file; the only thing that's faster about ``."
"pyc`` files is the speed with which they are loaded."
msgstr ""
"Программа не работает быстрее, когда она читается из файла ``.pyc``, чем "
"когда она читается из файла ``.py``; единственное, что быстрее в файлах ``."
"pyc``, это скорость их загрузки."

#: ../../tutorial/modules.rst:255
msgid ""
"The module :mod:`compileall` can create .pyc files for all modules in a "
"directory."
msgstr ""
"Модуль :mod:`compileall` может создавать файлы .pyc для всех модулей в "
"каталоге."

#: ../../tutorial/modules.rst:258
msgid ""
"There is more detail on this process, including a flow chart of the "
"decisions, in :pep:`3147`."
msgstr ""
"Более подробная информация об этом процессе, включая блок-схему принятия "
"решений, содержится в :pep:`3147`."

#: ../../tutorial/modules.rst:265
msgid "Standard Modules"
msgstr "Стандартные модули"

#: ../../tutorial/modules.rst:269
msgid ""
"Python comes with a library of standard modules, described in a separate "
"document, the Python Library Reference (\"Library Reference\" hereafter).  "
"Some modules are built into the interpreter; these provide access to "
"operations that are not part of the core of the language but are "
"nevertheless built in, either for efficiency or to provide access to "
"operating system primitives such as system calls.  The set of such modules "
"is a configuration option which also depends on the underlying platform.  "
"For example, the :mod:`winreg` module is only provided on Windows systems. "
"One particular module deserves some attention: :mod:`sys`, which is built "
"into every Python interpreter.  The variables ``sys.ps1`` and ``sys.ps2`` "
"define the strings used as primary and secondary prompts::"
msgstr ""
"Python поставляется с библиотекой стандартных модулей, описанной в отдельном "
"документе «Справочник по библиотеке Python» («Справочник по библиотеке» "
"далее). Некоторые модули встроены в интерпретатор; они обеспечивают доступ к "
"операциям, которые не являются частью ядра языка, но, тем не менее, встроены "
"либо для повышения эффективности, либо для обеспечения доступа к примитивам "
"операционной системы, таким как системные вызовы. Набор таких модулей "
"является опцией конфигурации, которая также зависит от базовой платформы. "
"Например, модуль :mod:`winreg` предоставляется только в системах Windows. "
"Некоторого внимания заслуживает один модуль: :mod:`sys`, который встроен в "
"каждый интерпретатор Python. Переменные ``sys.ps1`` и ``sys.ps2`` определяют "
"строки, используемые в качестве основного и вторичного приглашения:"

#: ../../tutorial/modules.rst:292
msgid ""
"These two variables are only defined if the interpreter is in interactive "
"mode."
msgstr ""
"Эти две переменные определяются только в том случае, если интерпретатор "
"находится в интерактивном режиме."

#: ../../tutorial/modules.rst:294
msgid ""
"The variable ``sys.path`` is a list of strings that determines the "
"interpreter's search path for modules. It is initialized to a default path "
"taken from the environment variable :envvar:`PYTHONPATH`, or from a built-in "
"default if :envvar:`PYTHONPATH` is not set.  You can modify it using "
"standard list operations::"
msgstr ""
"Переменная ``sys.path`` представляет собой список строк, определяющих путь "
"поиска модулей интерпретатором. Он инициализируется путем по умолчанию, "
"взятым из переменной среды :envvar:`PYTHONPATH` или из встроенного значения "
"по умолчанию, если :envvar:`PYTHONPATH` не установлен. Вы можете изменить "
"его, используя стандартные операции со списком::"

#: ../../tutorial/modules.rst:307
msgid "The :func:`dir` Function"
msgstr "Функция :func:`dir`"

#: ../../tutorial/modules.rst:309
msgid ""
"The built-in function :func:`dir` is used to find out which names a module "
"defines.  It returns a sorted list of strings::"
msgstr ""
"Встроенная функция :func:`dir` используется, чтобы узнать, какие имена "
"определяет модуль. Он возвращает отсортированный список строк::"

#: ../../tutorial/modules.rst:338
msgid ""
"Without arguments, :func:`dir` lists the names you have defined currently::"
msgstr ""
"Без аргументов :func:`dir` перечисляет имена, которые вы определили на "
"данный момент::"

#: ../../tutorial/modules.rst:346
msgid ""
"Note that it lists all types of names: variables, modules, functions, etc."
msgstr ""
"Обратите внимание, что здесь перечислены все типы имен: переменные, модули, "
"функции и т. д."

#: ../../tutorial/modules.rst:350
msgid ""
":func:`dir` does not list the names of built-in functions and variables.  If "
"you want a list of those, they are defined in the standard module :mod:"
"`builtins`::"
msgstr ""
":func:`dir` не перечисляет имена встроенных функций и переменных. Если вам "
"нужен их список, они определены в стандартном модуле :mod:`builtins`::"

#: ../../tutorial/modules.rst:389
msgid "Packages"
msgstr "Пакеты"

#: ../../tutorial/modules.rst:391
msgid ""
"Packages are a way of structuring Python's module namespace by using "
"\"dotted module names\".  For example, the module name :mod:`!A.B` "
"designates a submodule named ``B`` in a package named ``A``.  Just like the "
"use of modules saves the authors of different modules from having to worry "
"about each other's global variable names, the use of dotted module names "
"saves the authors of multi-module packages like NumPy or Pillow from having "
"to worry about each other's module names."
msgstr ""
"Пакеты — это способ структурирования пространства имен модулей Python с "
"помощью «имен модулей, разделенных точками». Например, имя модуля :mod:`!AB` "
"обозначает подмодуль с именем ``B`` в пакете с именем ``A``. Точно так же, "
"как использование модулей избавляет авторов различных модулей от "
"необходимости беспокоиться об именах глобальных переменных друг друга, "
"использование имен модулей, разделенных точками, избавляет авторов "
"многомодульных пакетов, таких как NumPy или Pillow, от необходимости "
"беспокоиться об именах модулей друг друга. ."

#: ../../tutorial/modules.rst:399
msgid ""
"Suppose you want to design a collection of modules (a \"package\") for the "
"uniform handling of sound files and sound data.  There are many different "
"sound file formats (usually recognized by their extension, for example: :"
"file:`.wav`, :file:`.aiff`, :file:`.au`), so you may need to create and "
"maintain a growing collection of modules for the conversion between the "
"various file formats. There are also many different operations you might "
"want to perform on sound data (such as mixing, adding echo, applying an "
"equalizer function, creating an artificial stereo effect), so in addition "
"you will be writing a never-ending stream of modules to perform these "
"operations.  Here's a possible structure for your package (expressed in "
"terms of a hierarchical filesystem):"
msgstr ""
"Предположим, вы хотите разработать набор модулей («пакет») для единообразной "
"обработки звуковых файлов и звуковых данных. Существует множество различных "
"форматов звуковых файлов (обычно распознаваемых по расширению, например: :"
"file:`.wav`, :file:`.aiff`, :file:`.au`), поэтому вам может потребоваться "
"создать и поддерживать растущая коллекция модулей для преобразования между "
"различными форматами файлов. Существует также множество различных операций, "
"которые вы, возможно, захотите выполнить со звуковыми данными (например, "
"микширование, добавление эха, применение функции эквалайзера, создание "
"искусственного стереоэффекта), поэтому, кроме того, вы будете писать "
"бесконечный поток модулей для выполнения эти операции. Вот возможная "
"структура вашего пакета (выраженная в виде иерархической файловой системы):"

#: ../../tutorial/modules.rst:436
msgid ""
"When importing the package, Python searches through the directories on ``sys."
"path`` looking for the package subdirectory."
msgstr ""
"При импорте пакета Python выполняет поиск в каталогах ``sys.path`` в поисках "
"подкаталога пакета."

#: ../../tutorial/modules.rst:439
msgid ""
"The :file:`__init__.py` files are required to make Python treat directories "
"containing the file as packages (unless using a :term:`namespace package`, a "
"relatively advanced feature). This prevents directories with a common name, "
"such as ``string``, from unintentionally hiding valid modules that occur "
"later on the module search path. In the simplest case, :file:`__init__.py` "
"can just be an empty file, but it can also execute initialization code for "
"the package or set the ``__all__`` variable, described later."
msgstr ""
"Файлы :file:`__init__.py` необходимы для того, чтобы Python рассматривал "
"каталоги, содержащие файл, как пакеты (если не используется :term:`namespace "
"package`, относительно продвинутая функция). Это предотвращает "
"непреднамеренное сокрытие допустимых модулей, которые встречаются позже в "
"пути поиска модулей, в каталогах с общим именем, например «строка». В "
"простейшем случае :file:`__init__.py` может быть просто пустым файлом, но он "
"также может выполнять код инициализации пакета или устанавливать переменную "
"``__all__``, описанную ниже."

#: ../../tutorial/modules.rst:447
msgid ""
"Users of the package can import individual modules from the package, for "
"example::"
msgstr ""
"Пользователи пакета могут импортировать отдельные модули из пакета, например:"

#: ../../tutorial/modules.rst:452
msgid ""
"This loads the submodule :mod:`!sound.effects.echo`.  It must be referenced "
"with its full name. ::"
msgstr ""
"Это загружает подмодуль :mod:`!sound.effects.echo`. На него необходимо "
"ссылаться с полным именем. ::"

#: ../../tutorial/modules.rst:457
msgid "An alternative way of importing the submodule is::"
msgstr "Альтернативный способ импорта подмодуля:"

#: ../../tutorial/modules.rst:461
msgid ""
"This also loads the submodule :mod:`!echo`, and makes it available without "
"its package prefix, so it can be used as follows::"
msgstr ""
"Это также загружает подмодуль :mod:`!echo` и делает его доступным без "
"префикса пакета, поэтому его можно использовать следующим образом:"

#: ../../tutorial/modules.rst:466
msgid ""
"Yet another variation is to import the desired function or variable "
"directly::"
msgstr ""
"Еще один вариант — напрямую импортировать нужную функцию или переменную:"

#: ../../tutorial/modules.rst:470
msgid ""
"Again, this loads the submodule :mod:`!echo`, but this makes its function :"
"func:`!echofilter` directly available::"
msgstr ""
"Опять же, это загружает подмодуль :mod:`!echo`, но делает его функцию :func:"
"`!echofilter` доступной напрямую::"

#: ../../tutorial/modules.rst:475
msgid ""
"Note that when using ``from package import item``, the item can be either a "
"submodule (or subpackage) of the package, or some  other name defined in the "
"package, like a function, class or variable.  The ``import`` statement first "
"tests whether the item is defined in the package; if not, it assumes it is a "
"module and attempts to load it.  If it fails to find it, an :exc:"
"`ImportError` exception is raised."
msgstr ""
"Обратите внимание, что при использовании ``из элемента импорта пакета`` этот "
"элемент может быть либо подмодулем (или подпакетом) пакета, либо каким-либо "
"другим именем, определенным в пакете, например, функцией, классом или "
"переменной. Оператор import сначала проверяет, определен ли элемент в "
"пакете; в противном случае он предполагает, что это модуль, и пытается его "
"загрузить. Если его не удается найти, возникает исключение :exc:"
"`ImportError`."

#: ../../tutorial/modules.rst:482
msgid ""
"Contrarily, when using syntax like ``import item.subitem.subsubitem``, each "
"item except for the last must be a package; the last item can be a module or "
"a package but can't be a class or function or variable defined in the "
"previous item."
msgstr ""
"И наоборот, при использовании синтаксиса типа «import item.subitem."
"subsubitem», каждый элемент, кроме последнего, должен быть пакетом; "
"последний элемент может быть модулем или пакетом, но не может быть классом, "
"функцией или переменной, определенной в предыдущем элементе."

#: ../../tutorial/modules.rst:491
msgid "Importing \\* From a Package"
msgstr "Importing \\* From a Package"

#: ../../tutorial/modules.rst:495
msgid ""
"Now what happens when the user writes ``from sound.effects import *``?  "
"Ideally, one would hope that this somehow goes out to the filesystem, finds "
"which submodules are present in the package, and imports them all.  This "
"could take a long time and importing sub-modules might have unwanted side-"
"effects that should only happen when the sub-module is explicitly imported."
msgstr ""
"Что же происходит, когда пользователь пишет ``from sound.effects import *``? "
"В идеале можно было бы надеяться, что это каким-то образом попадет в "
"файловую систему, найдет, какие подмодули присутствуют в пакете, и "
"импортирует их все. Это может занять много времени, а импорт подмодулей "
"может иметь нежелательные побочные эффекты, которые должны произойти только "
"в том случае, если подмодуль импортируется явно."

#: ../../tutorial/modules.rst:501
msgid ""
"The only solution is for the package author to provide an explicit index of "
"the package.  The :keyword:`import` statement uses the following convention: "
"if a package's :file:`__init__.py` code defines a list named ``__all__``, it "
"is taken to be the list of module names that should be imported when ``from "
"package import *`` is encountered.  It is up to the package author to keep "
"this list up-to-date when a new version of the package is released.  Package "
"authors may also decide not to support it, if they don't see a use for "
"importing \\* from their package.  For example, the file :file:`sound/"
"effects/__init__.py` could contain the following code::"
msgstr ""
"Единственное решение — предоставить автору пакета явный индекс пакета. В "
"операторе :keyword:`import` используется следующее соглашение: если код :"
"file:`__init__.py` пакета определяет список с именем ``__all__``, он "
"считается списком имен модулей, которые должны быть импортированы при ``из "
"импорта пакета *`` встречается. Автор пакета должен поддерживать этот список "
"в актуальном состоянии при выпуске новой версии пакета. Авторы пакетов также "
"могут решить не поддерживать его, если они не видят смысла в импорте \\* из "
"своего пакета. Например, файл :file:`sound/effects/__init__.py` может "
"содержать следующий код:"

#: ../../tutorial/modules.rst:513
msgid ""
"This would mean that ``from sound.effects import *`` would import the three "
"named submodules of the :mod:`!sound.effects` package."
msgstr ""
"Это будет означать, что ``from sound.effects import *`` будет импортировать "
"три именованных подмодуля пакета :mod:`!sound.effects`."

#: ../../tutorial/modules.rst:516
msgid ""
"Be aware that submodules might become shadowed by locally defined names. For "
"example, if you added a ``reverse`` function to the :file:`sound/effects/"
"__init__.py` file, the ``from sound.effects import *`` would only import the "
"two submodules ``echo`` and ``surround``, but *not* the ``reverse`` "
"submodule, because it is shadowed by the locally defined ``reverse`` "
"function::"
msgstr ""
"Имейте в виду, что подмодули могут быть затенены локально определенными "
"именами. Например, если вы добавили функцию ``reverse`` в файл :file:`sound/"
"effects/__init__.py`, ``from sound.effects import *`` будет импортировать "
"только два подмодуля ``echo` ` и ``surround``, но *не* подмодуль "
"``reverse``, поскольку он затеняется локально определенной функцией "
"``reverse``::"

#: ../../tutorial/modules.rst:532
msgid ""
"If ``__all__`` is not defined, the statement ``from sound.effects import *`` "
"does *not* import all submodules from the package :mod:`!sound.effects` into "
"the current namespace; it only ensures that the package :mod:`!sound."
"effects` has been imported (possibly running any initialization code in :"
"file:`__init__.py`) and then imports whatever names are defined in the "
"package.  This includes any names defined (and submodules explicitly loaded) "
"by :file:`__init__.py`.  It also includes any submodules of the package that "
"were explicitly loaded by previous :keyword:`import` statements.  Consider "
"this code::"
msgstr ""
"Если ``__all__`` не определен, оператор ``from sound.effects import *`` *не* "
"импортирует все подмодули из пакета :mod:`!sound.effects` в текущее "
"пространство имен; он только гарантирует, что пакет :mod:`!sound.effects` "
"был импортирован (возможно, запуская любой код инициализации в :file:"
"`__init__.py`), а затем импортирует любые имена, определенные в пакете. Сюда "
"входят любые имена, определенные (и явно загруженные подмодули) с помощью :"
"file:`__init__.py`. Он также включает в себя любые подмодули пакета, которые "
"были явно загружены предыдущими операторами :keyword:`import`. Рассмотрим "
"этот код::"

#: ../../tutorial/modules.rst:545
msgid ""
"In this example, the :mod:`!echo` and :mod:`!surround` modules are imported "
"in the current namespace because they are defined in the :mod:`!sound."
"effects` package when the ``from...import`` statement is executed.  (This "
"also works when ``__all__`` is defined.)"
msgstr ""
"В этом примере модули :mod:`!echo` и :mod:`!surround` импортируются в "
"текущее пространство имен, поскольку они определены в пакете :mod:`!sound."
"effects`, когда ``from.. Оператор .import`` выполняется. (Это также "
"работает, когда определен ``__all__``.)"

#: ../../tutorial/modules.rst:550
msgid ""
"Although certain modules are designed to export only names that follow "
"certain patterns when you use ``import *``, it is still considered bad "
"practice in production code."
msgstr ""
"Хотя некоторые модули предназначены для экспорта только имен, которые "
"соответствуют определенным шаблонам, когда вы используете import *, в "
"рабочем коде это по-прежнему считается плохой практикой."

#: ../../tutorial/modules.rst:554
msgid ""
"Remember, there is nothing wrong with using ``from package import "
"specific_submodule``!  In fact, this is the recommended notation unless the "
"importing module needs to use submodules with the same name from different "
"packages."
msgstr ""
"Помните, нет ничего плохого в использовании ``from package import "
"specific_submodule``! Фактически, это рекомендуемая нотация, если только "
"импортирующему модулю не требуется использовать подмодули с одинаковыми "
"именами из разных пакетов."

#: ../../tutorial/modules.rst:563
msgid "Intra-package References"
msgstr "Внутрипакетные ссылки"

#: ../../tutorial/modules.rst:565
msgid ""
"When packages are structured into subpackages (as with the :mod:`!sound` "
"package in the example), you can use absolute imports to refer to submodules "
"of siblings packages.  For example, if the module :mod:`!sound.filters."
"vocoder` needs to use the :mod:`!echo` module in the :mod:`!sound.effects` "
"package, it can use ``from sound.effects import echo``."
msgstr ""
"Когда пакеты структурированы в подпакеты (как в примере с пакетом :mod:`!"
"sound`), вы можете использовать абсолютный импорт для ссылки на подмодули "
"родственных пакетов. Например, если модулю :mod:`!sound.filters.vocoder` "
"необходимо использовать модуль :mod:`!echo` в пакете :mod:`!sound.effects`, "
"он может использовать ``from sound. эффекты импорта echo``."

#: ../../tutorial/modules.rst:571
msgid ""
"You can also write relative imports, with the ``from module import name`` "
"form of import statement.  These imports use leading dots to indicate the "
"current and parent packages involved in the relative import.  From the :mod:"
"`!surround` module for example, you might use::"
msgstr ""
"Вы также можете написать относительный импорт, используя форму оператора "
"импорта «из имени импорта модуля». При этом импорте используются ведущие "
"точки для обозначения текущего и родительского пакетов, участвующих в "
"относительном импорте. Например, из модуля :mod:`!surround` вы можете "
"использовать::"

#: ../../tutorial/modules.rst:580
msgid ""
"Note that relative imports are based on the name of the current module.  "
"Since the name of the main module is always ``\"__main__\"``, modules "
"intended for use as the main module of a Python application must always use "
"absolute imports."
msgstr ""
"Обратите внимание, что относительный импорт основан на имени текущего "
"модуля. Поскольку имя основного модуля всегда ``\"__main__\"``, модули, "
"предназначенные для использования в качестве основного модуля приложения "
"Python, всегда должны использовать абсолютный импорт."

#: ../../tutorial/modules.rst:586
msgid "Packages in Multiple Directories"
msgstr "Пакеты в нескольких каталогах"

#: ../../tutorial/modules.rst:588
msgid ""
"Packages support one more special attribute, :attr:`__path__`.  This is "
"initialized to be a list containing the name of the directory holding the "
"package's :file:`__init__.py` before the code in that file is executed.  "
"This variable can be modified; doing so affects future searches for modules "
"and subpackages contained in the package."
msgstr ""

#: ../../tutorial/modules.rst:594
msgid ""
"While this feature is not often needed, it can be used to extend the set of "
"modules found in a package."
msgstr ""
"Хотя эта функция требуется нечасто, ее можно использовать для расширения "
"набора модулей, имеющихся в пакете."

#: ../../tutorial/modules.rst:599
msgid "Footnotes"
msgstr "Сноски"

#: ../../tutorial/modules.rst:600
msgid ""
"In fact function definitions are also 'statements' that are 'executed'; the "
"execution of a module-level function definition adds the function name to "
"the module's global namespace."
msgstr ""
"Фактически определения функций также являются «операторами», которые "
"«исполняются»; выполнение определения функции на уровне модуля добавляет имя "
"функции в глобальное пространство имен модуля."

#: ../../tutorial/modules.rst:184 ../../tutorial/modules.rst:267
#: ../../tutorial/modules.rst:348
msgid "module"
msgstr "модуль"

#: ../../tutorial/modules.rst:184
msgid "search"
msgstr "поиск"

#: ../../tutorial/modules.rst:184
msgid "path"
msgstr "путь"

#: ../../tutorial/modules.rst:267
msgid "sys"
msgstr "sys"

#: ../../tutorial/modules.rst:348
msgid "builtins"
msgstr "встроенные"

#: ../../tutorial/modules.rst:493
msgid "__all__"
msgstr "__all__"
