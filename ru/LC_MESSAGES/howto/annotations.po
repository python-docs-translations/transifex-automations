# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-10 16:06+0000\n"
"PO-Revision-Date: 2022-11-05 17:21+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../howto/annotations.rst:5
msgid "Annotations Best Practices"
msgstr "Рекомендации по аннотациям"

#: ../../howto/annotations.rst:0
msgid "author"
msgstr "автор"

#: ../../howto/annotations.rst:7
msgid "Larry Hastings"
msgstr "Larry Hastings"

#: ../../howto/annotations.rstNone
msgid "Abstract"
msgstr "Абстракция"

#: ../../howto/annotations.rst:11
msgid ""
"This document is designed to encapsulate the best practices for working with "
"annotations dicts.  If you write Python code that examines "
"``__annotations__`` on Python objects, we encourage you to follow the "
"guidelines described below."
msgstr ""
"Этот документ разработан для обобщения лучших практик работы со словарями "
"аннотаций.  Если вы пишете код на Python, который анализирует "
"``__annotations__`` на объектах Python, мы рекомендуем вам следовать "
"указанным ниже рекомендациям."

#: ../../howto/annotations.rst:16
msgid ""
"The document is organized into four sections: best practices for accessing "
"the annotations of an object in Python versions 3.10 and newer, best "
"practices for accessing the annotations of an object in Python versions 3.9 "
"and older, other best practices for ``__annotations__`` that apply to any "
"Python version, and quirks of ``__annotations__``."
msgstr ""
"Документ разделен на четыре раздела: рекомендации по доступу к аннотациям "
"объекта в версиях Python 3.10 и новее, рекомендации по доступу к аннотациям "
"объекта в версиях Python 3.9 и старше, другие рекомендации для "
"``__annotations__``, которые применимы к любой версии Python и особенностям "
"``__annotations__``."

#: ../../howto/annotations.rst:26
msgid ""
"Note that this document is specifically about working with "
"``__annotations__``, not uses *for* annotations. If you're looking for "
"information on how to use \"type hints\" in your code, please see the :mod:"
"`typing` module."
msgstr ""
"Обратите внимание, что этот документ посвящен именно работе с "
"``__annotations__``, а не аннотациями *for*. Если вы ищете информацию о том, "
"как использовать «подсказки типов» в своем коде, обратитесь к модулю :mod:"
"`typing`."

#: ../../howto/annotations.rst:33
msgid "Accessing The Annotations Dict Of An Object In Python 3.10 And Newer"
msgstr "Доступ к аннотациям объекта в Python 3.10 и новее"

#: ../../howto/annotations.rst:35
msgid ""
"Python 3.10 adds a new function to the standard library: :func:`inspect."
"get_annotations`.  In Python versions 3.10 and newer, calling this function "
"is the best practice for accessing the annotations dict of any object that "
"supports annotations.  This function can also \"un-stringize\" stringized "
"annotations for you."
msgstr ""
"Python 3.10 добавляет в стандартную библиотеку новую функцию: :func:`inspect."
"get_annotations`. В версиях Python 3.10 и новее вызов этой функции — лучший "
"способ получить доступ к словарю аннотаций любого объекта, поддерживающего "
"аннотации. Эта функция также может «демонтировать» строковые аннотации."

#: ../../howto/annotations.rst:42
msgid ""
"If for some reason :func:`inspect.get_annotations` isn't viable for your use "
"case, you may access the ``__annotations__`` data member manually.  Best "
"practice for this changed in Python 3.10 as well: as of Python 3.10, ``o."
"__annotations__`` is guaranteed to *always* work on Python functions, "
"classes, and modules.  If you're certain the object you're examining is one "
"of these three *specific* objects, you may simply use ``o.__annotations__`` "
"to get at the object's annotations dict."
msgstr ""
"Если по какой-то причине :func:`inspect.get_annotations` не подходит для "
"вашего варианта использования, вы можете получить доступ к элементу данных "
"__annotations__`` вручную. Лучшая практика для этого также изменилась в "
"Python 3.10: начиная с Python 3.10, ``o.__annotations__`` гарантированно "
"*всегда* работает с функциями, классами и модулями Python. Если вы уверены, "
"что объект, который вы исследуете, является одним из этих трех *конкретных* "
"объектов, вы можете просто использовать ``o.__annotations__``, чтобы "
"получить словарь аннотаций объекта."

#: ../../howto/annotations.rst:52
msgid ""
"However, other types of callables--for example, callables created by :func:"
"`functools.partial`--may not have an ``__annotations__`` attribute defined.  "
"When accessing the ``__annotations__`` of a possibly unknown object,  best "
"practice in Python versions 3.10 and newer is to call :func:`getattr` with "
"three arguments, for example ``getattr(o, '__annotations__', None)``."
msgstr ""
"Однако другие типы вызываемых объектов, например вызываемые объекты, "
"созданные :func:`functools.partial`, могут не иметь определенного атрибута "
"``__annotations__``. При доступе к ``__annotations__`` возможно неизвестному "
"объекту в Python версии 3.10 и новее рекомендуется вызывать :func:`getattr` "
"с тремя аргументами, например ``getattr(o, '__annotations__', None)` `."

#: ../../howto/annotations.rst:60
msgid ""
"Before Python 3.10, accessing ``__annotations__`` on a class that defines no "
"annotations but that has a parent class with annotations would return the "
"parent's ``__annotations__``. In Python 3.10 and newer, the child class's "
"annotations will be an empty dict instead."
msgstr ""
"До Python 3.10 доступ к ``__annotations__`` в классе, который не определяет "
"аннотаций, но имеет родительский класс с аннотациями, возвращал бы "
"родительский ``__annotations__``. В Python 3.10 и новее аннотации дочернего "
"класса вместо этого будут пустым словарем."

#: ../../howto/annotations.rst:68
msgid "Accessing The Annotations Dict Of An Object In Python 3.9 And Older"
msgstr "Доступ к аннотациям объекта в Python 3.9 и старше"

#: ../../howto/annotations.rst:70
msgid ""
"In Python 3.9 and older, accessing the annotations dict of an object is much "
"more complicated than in newer versions. The problem is a design flaw in "
"these older versions of Python, specifically to do with class annotations."
msgstr ""
"В Python 3.9 и более ранних версиях доступ к аннотациям объекта намного "
"сложнее, чем в более новых версиях. Проблема заключается в недостатке "
"дизайна этих старых версий Python, особенно связанном с аннотациями классов."

#: ../../howto/annotations.rst:75
msgid ""
"Best practice for accessing the annotations dict of other objects--"
"functions, other callables, and modules--is the same as best practice for "
"3.10, assuming you aren't calling :func:`inspect.get_annotations`: you "
"should use three-argument :func:`getattr` to access the object's "
"``__annotations__`` attribute."
msgstr ""
"Лучшая практика для доступа к аннотациям других объектов — функций, других "
"вызываемых объектов и модулей — такая же, как и лучшая практика для версии "
"3.10, при условии, что вы не вызываете :func:`inspect.get_annotations`: вам "
"следует использовать три- аргумент :func:`getattr` для доступа к атрибуту "
"``__annotations__`` объекта."

#: ../../howto/annotations.rst:82
msgid ""
"Unfortunately, this isn't best practice for classes.  The problem is that, "
"since ``__annotations__`` is optional on classes, and because classes can "
"inherit attributes from their base classes, accessing the "
"``__annotations__`` attribute of a class may inadvertently return the "
"annotations dict of a *base class.* As an example::"
msgstr ""
"К сожалению, это не лучшая практика для занятий. Проблема в том, что, "
"поскольку ``__annotations__`` не является обязательным для классов и "
"поскольку классы могут наследовать атрибуты своих базовых классов, доступ к "
"атрибуту ``__annotations__`` класса может непреднамеренно вернуть аннотации "
"*base class. * В качестве примера::"

#: ../../howto/annotations.rst:98
msgid "This will print the annotations dict from ``Base``, not ``Derived``."
msgstr "Это будет печатать аннотации из ``Base``, а не ``Derived``."

#: ../../howto/annotations.rst:101
msgid ""
"Your code will have to have a separate code path if the object you're "
"examining is a class (``isinstance(o, type)``). In that case, best practice "
"relies on an implementation detail of Python 3.9 and before: if a class has "
"annotations defined, they are stored in the class's ``__dict__`` "
"dictionary.  Since the class may or may not have annotations defined, best "
"practice is to call the ``get`` method on the class dict."
msgstr ""

#: ../../howto/annotations.rst:109
msgid ""
"To put it all together, here is some sample code that safely accesses the "
"``__annotations__`` attribute on an arbitrary object in Python 3.9 and "
"before::"
msgstr ""
"Чтобы собрать все воедино, вот пример кода, который безопасно обращается к "
"атрибуту ``__annotations__`` произвольного объекта в Python 3.9 и более "
"ранних версиях:"

#: ../../howto/annotations.rst:118
msgid ""
"After running this code, ``ann`` should be either a dictionary or ``None``.  "
"You're encouraged to double-check the type of ``ann`` using :func:"
"`isinstance` before further examination."
msgstr ""
"После запуска этого кода ``ann`` должен быть либо словарем, либо ``None``. "
"Перед дальнейшим изучением рекомендуется дважды проверить тип ``ann``, "
"используя :func:`isinstance`."

#: ../../howto/annotations.rst:123
msgid ""
"Note that some exotic or malformed type objects may not have a ``__dict__`` "
"attribute, so for extra safety you may also wish to use :func:`getattr` to "
"access ``__dict__``."
msgstr ""

#: ../../howto/annotations.rst:129
msgid "Manually Un-Stringizing Stringized Annotations"
msgstr "Растягивание строковых аннотаций вручную"

#: ../../howto/annotations.rst:131
msgid ""
"In situations where some annotations may be \"stringized\", and you wish to "
"evaluate those strings to produce the Python values they represent, it "
"really is best to call :func:`inspect.get_annotations` to do this work for "
"you."
msgstr ""
"В ситуациях, когда некоторые аннотации могут быть «строковыми», и вы хотите "
"оценить эти строки, чтобы получить значения Python, которые они "
"представляют, лучше всего вызвать :func:`inspect.get_annotations`, чтобы "
"сделать эту работу за вас."

#: ../../howto/annotations.rst:137
msgid ""
"If you're using Python 3.9 or older, or if for some reason you can't use :"
"func:`inspect.get_annotations`, you'll need to duplicate its logic.  You're "
"encouraged to examine the implementation of :func:`inspect.get_annotations` "
"in the current Python version and follow a similar approach."
msgstr ""
"Если вы используете Python 3.9 или более раннюю версию или по какой-то "
"причине вы не можете использовать :func:`inspect.get_annotations`, вам "
"необходимо продублировать его логику. Вам рекомендуется изучить реализацию :"
"func:`inspect.get_annotations` в текущей версии Python и следовать "
"аналогичному подходу."

#: ../../howto/annotations.rst:143
msgid ""
"In a nutshell, if you wish to evaluate a stringized annotation on an "
"arbitrary object ``o``:"
msgstr ""
"Вкратце, если вы хотите оценить строковую аннотацию для произвольного "
"объекта ``o``:"

#: ../../howto/annotations.rst:146
msgid ""
"If ``o`` is a module, use ``o.__dict__`` as the ``globals`` when calling :"
"func:`eval`."
msgstr ""
"Если ``o`` является модулем, используйте ``o.__dict__`` в качестве "
"``глобальных переменных`` при вызове :func:`eval`."

#: ../../howto/annotations.rst:148
msgid ""
"If ``o`` is a class, use ``sys.modules[o.__module__].__dict__`` as the "
"``globals``, and ``dict(vars(o))`` as the ``locals``, when calling :func:"
"`eval`."
msgstr ""
"Если ``o`` является классом, используйте ``sys.modules[o.__module__]."
"__dict__`` в качестве ``глобальных`` и ``dict(vars(o))`` в качестве "
"``локальных значений\". ``, при вызове :func:`eval`."

#: ../../howto/annotations.rst:151
msgid ""
"If ``o`` is a wrapped callable using :func:`functools.update_wrapper`, :func:"
"`functools.wraps`, or :func:`functools.partial`, iteratively unwrap it by "
"accessing either ``o.__wrapped__`` or ``o.func`` as appropriate, until you "
"have found the root unwrapped function."
msgstr ""
"Если ``o`` является обернутым вызываемым объектом с использованием :func:"
"`functools.update_wrapper`, :func:`functools.wraps` или :func:`functools."
"partial`, итеративно разверните его, обратившись к ``o.__wrapped__ `` или "
"``o.func`` в зависимости от обстоятельств, пока не найдете корневую "
"развернутую функцию."

#: ../../howto/annotations.rst:155
msgid ""
"If ``o`` is a callable (but not a class), use ``o.__globals__`` as the "
"globals when calling :func:`eval`."
msgstr ""

#: ../../howto/annotations.rst:158
msgid ""
"However, not all string values used as annotations can be successfully "
"turned into Python values by :func:`eval`. String values could theoretically "
"contain any valid string, and in practice there are valid use cases for type "
"hints that require annotating with string values that specifically *can't* "
"be evaluated.  For example:"
msgstr ""
"Однако не все строковые значения, используемые в качестве аннотаций, можно "
"успешно преобразовать в значения Python с помощью :func:`eval`. Строковые "
"значения теоретически могут содержать любую допустимую строку, и на практике "
"существуют допустимые варианты использования подсказок типа, которые требуют "
"аннотирования строковыми значениями, которые *не* могут быть вычислены. "
"Например:"

#: ../../howto/annotations.rst:165
msgid ""
":pep:`604` union types using ``|``, before support for this was added to "
"Python 3.10."
msgstr ""
":pep:`604` объединяет типы с использованием ``|``, до того, как поддержка "
"этого была добавлена ​​в Python 3.10."

#: ../../howto/annotations.rst:167
msgid ""
"Definitions that aren't needed at runtime, only imported when :const:`typing."
"TYPE_CHECKING` is true."
msgstr ""
"Определения, которые не нужны во время выполнения, импортируются только "
"тогда, когда :const:`typing.TYPE_CHECKING` имеет значение true."

#: ../../howto/annotations.rst:170
msgid ""
"If :func:`eval` attempts to evaluate such values, it will fail and raise an "
"exception.  So, when designing a library API that works with annotations, "
"it's recommended to only attempt to evaluate string values when explicitly "
"requested to by the caller."
msgstr ""
"Если :func:`eval` попытается оценить такие значения, она потерпит неудачу и "
"вызовет исключение. Поэтому при разработке библиотечного API, который "
"работает с аннотациями, рекомендуется пытаться оценивать строковые значения "
"только тогда, когда это явным образом запрашивается вызывающей стороной."

#: ../../howto/annotations.rst:178
msgid "Best Practices For ``__annotations__`` In Any Python Version"
msgstr "Лучшие практики для ``__annotations__`` в любой версии Python"

#: ../../howto/annotations.rst:180
msgid ""
"You should avoid assigning to the ``__annotations__`` member of objects "
"directly.  Let Python manage setting ``__annotations__``."
msgstr ""
"Вам следует избегать прямого присвоения члену объекта ``__annotations__``. "
"Позвольте Python управлять настройкой ``__annotations__``."

#: ../../howto/annotations.rst:183
msgid ""
"If you do assign directly to the ``__annotations__`` member of an object, "
"you should always set it to a ``dict`` object."
msgstr ""
"Если вы присваиваете значение непосредственно члену ``__annotations__`` "
"объекта, вам всегда следует устанавливать его как объект ``dict``."

#: ../../howto/annotations.rst:186
msgid ""
"If you directly access the ``__annotations__`` member of an object, you "
"should ensure that it's a dictionary before attempting to examine its "
"contents."
msgstr ""
"Если вы напрямую обращаетесь к члену объекта ``__annotations__``, вам "
"следует убедиться, что это словарь, прежде чем пытаться изучить его "
"содержимое."

#: ../../howto/annotations.rst:190
msgid "You should avoid modifying ``__annotations__`` dicts."
msgstr "Вам следует избегать изменения диктовок ``__annotations__``."

#: ../../howto/annotations.rst:192
msgid ""
"You should avoid deleting the ``__annotations__`` attribute of an object."
msgstr "Вам следует избегать удаления атрибута ``__annotations__`` объекта."

#: ../../howto/annotations.rst:197
msgid "``__annotations__`` Quirks"
msgstr "``__annotations__`` Особенности"

#: ../../howto/annotations.rst:199
msgid ""
"In all versions of Python 3, function objects lazy-create an annotations "
"dict if no annotations are defined on that object.  You can delete the "
"``__annotations__`` attribute using ``del fn.__annotations__``, but if you "
"then access ``fn.__annotations__`` the object will create a new empty dict "
"that it will store and return as its annotations.  Deleting the annotations "
"on a function before it has lazily created its annotations dict will throw "
"an ``AttributeError``; using ``del fn.__annotations__`` twice in a row is "
"guaranteed to always throw an ``AttributeError``."
msgstr ""
"Во всех версиях Python 3 функциональные объекты лениво создают словарь "
"аннотаций, если для этого объекта не определены аннотации. Вы можете удалить "
"атрибут ``__annotations__``, используя ``del fn.__annotations__``, но если "
"вы затем получите доступ к ``fn.__annotations__``, объект создаст новый "
"пустой словарь, который он сохранит и вернет в качестве своих аннотаций. "
"Удаление аннотаций функции до того, как она лениво создаст свой словарь "
"аннотаций, приведет к выдаче ``AttributeError``; использование ``del fn."
"__annotations__`` дважды подряд гарантированно всегда выдаст "
"``AttributeError``."

#: ../../howto/annotations.rst:209
msgid ""
"Everything in the above paragraph also applies to class and module objects "
"in Python 3.10 and newer."
msgstr ""
"Все, что сказано в приведенном выше абзаце, также применимо к объектам "
"классов и модулей в Python 3.10 и новее."

#: ../../howto/annotations.rst:212
msgid ""
"In all versions of Python 3, you can set ``__annotations__`` on a function "
"object to ``None``.  However, subsequently accessing the annotations on that "
"object using ``fn.__annotations__`` will lazy-create an empty dictionary as "
"per the first paragraph of this section.  This is *not* true of modules and "
"classes, in any Python version; those objects permit setting "
"``__annotations__`` to any Python value, and will retain whatever value is "
"set."
msgstr ""
"Во всех версиях Python 3 вы можете установить для объекта функции "
"``__annotations__`` в значение ``None``. Однако последующий доступ к "
"аннотациям этого объекта с помощью ``fn.__annotations__`` приведет к "
"ленивому созданию пустого словаря, как указано в первом абзаце этого "
"раздела. Это *не* верно для модулей и классов в любой версии Python; эти "
"объекты позволяют устанавливать ``__annotations__`` в любое значение Python "
"и сохраняют любое установленное значение."

#: ../../howto/annotations.rst:220
msgid ""
"If Python stringizes your annotations for you (using ``from __future__ "
"import annotations``), and you specify a string as an annotation, the string "
"will itself be quoted.  In effect the annotation is quoted *twice.*  For "
"example::"
msgstr ""
"Если Python преобразует ваши аннотации в строку (используя ``from __future__ "
"import annotations``), и вы указываете строку в качестве аннотации, она сама "
"будет заключена в кавычки. Фактически аннотация цитируется *дважды*. "
"Например::"

#: ../../howto/annotations.rst:231
msgid ""
"This prints ``{'a': \"'str'\"}``.  This shouldn't really be considered a "
"\"quirk\"; it's mentioned here simply because it might be surprising."
msgstr ""
"Это напечатает ``{'a': \"'str'\"}``. На самом деле это не следует считать "
"«причудой»; это упомянуто здесь просто потому, что это может удивить."
