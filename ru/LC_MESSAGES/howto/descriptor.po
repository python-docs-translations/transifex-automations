# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-10 16:06+0000\n"
"PO-Revision-Date: 2022-11-05 17:21+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../howto/descriptor.rst:5
msgid "Descriptor HowTo Guide"
msgstr ""

#: ../../howto/descriptor.rst:0
msgid "Author"
msgstr "Автор"

#: ../../howto/descriptor.rst:7
msgid "Raymond Hettinger"
msgstr "Raymond Hettinger"

#: ../../howto/descriptor.rst:0
msgid "Contact"
msgstr "Контакт"

#: ../../howto/descriptor.rst:8
msgid "<python at rcn dot com>"
msgstr "<python at rcn dot com>"

#: ../../howto/descriptor.rst:11
msgid "Contents"
msgstr " Содержание"

#: ../../howto/descriptor.rst:13
msgid ""
":term:`Descriptors <descriptor>` let objects customize attribute lookup, "
"storage, and deletion."
msgstr ""
":term:`Дескрипторы <дескриптор>` позволяют объектам настраивать поиск, "
"хранение и удаление атрибутов."

#: ../../howto/descriptor.rst:16
msgid "This guide has four major sections:"
msgstr "Данное руководство состоит из четырех основных разделов:"

#: ../../howto/descriptor.rst:18
msgid ""
"The \"primer\" gives a basic overview, moving gently from simple examples, "
"adding one feature at a time.  Start here if you're new to descriptors."
msgstr ""
"В «Букваре» дается базовый обзор, плавно переходя от простых примеров к "
"добавлению одной функции за раз. Если вы новичок в дескрипторах, начните "
"здесь."

#: ../../howto/descriptor.rst:21
msgid ""
"The second section shows a complete, practical descriptor example.  If you "
"already know the basics, start there."
msgstr ""
"Во втором разделе показан полный практический пример дескриптора. Если вы "
"уже знаете основы, начните с них."

#: ../../howto/descriptor.rst:24
msgid ""
"The third section provides a more technical tutorial that goes into the "
"detailed mechanics of how descriptors work.  Most people don't need this "
"level of detail."
msgstr ""
"Третий раздел представляет собой более техническое руководство, в котором "
"подробно описывается механизм работы дескрипторов. Большинству людей не "
"нужен такой уровень детализации."

#: ../../howto/descriptor.rst:28
msgid ""
"The last section has pure Python equivalents for built-in descriptors that "
"are written in C.  Read this if you're curious about how functions turn into "
"bound methods or about the implementation of common tools like :func:"
"`classmethod`, :func:`staticmethod`, :func:`property`, and :term:`__slots__`."
msgstr ""
"В последнем разделе приведены эквиваленты встроенных дескрипторов, "
"написанных на C, на чистом Python. Прочтите это, если вам интересно, как "
"функции превращаются в связанные методы или о реализации общих инструментов, "
"таких как :func:`classmethod`, :func: `staticmethod`, :func:`property` и :"
"term:`__slots__`."

#: ../../howto/descriptor.rst:36
msgid "Primer"
msgstr "Первый"

#: ../../howto/descriptor.rst:38
msgid ""
"In this primer, we start with the most basic possible example and then we'll "
"add new capabilities one by one."
msgstr ""
"В этом руководстве мы начнем с самого простого примера, а затем будем "
"добавлять новые возможности одну за другой."

#: ../../howto/descriptor.rst:43
msgid "Simple example: A descriptor that returns a constant"
msgstr "Простой пример: дескриптор, возвращающий константу."

#: ../../howto/descriptor.rst:45
msgid ""
"The :class:`Ten` class is a descriptor whose :meth:`__get__` method always "
"returns the constant ``10``:"
msgstr ""
"Класс :class:`Ten` — это дескриптор, метод :meth:`__get__` всегда возвращает "
"константу ``10``:"

#: ../../howto/descriptor.rst:54
msgid ""
"To use the descriptor, it must be stored as a class variable in another "
"class:"
msgstr ""
"Чтобы использовать дескриптор, его необходимо сохранить как переменную "
"класса в другом классе:"

#: ../../howto/descriptor.rst:62
msgid ""
"An interactive session shows the difference between normal attribute lookup "
"and descriptor lookup:"
msgstr ""
"Интерактивный сеанс показывает разницу между обычным поиском по атрибуту и ​​"
"поиском по дескриптору:"

#: ../../howto/descriptor.rst:73
msgid ""
"In the ``a.x`` attribute lookup, the dot operator finds ``'x': 5`` in the "
"class dictionary.  In the ``a.y`` lookup, the dot operator finds a "
"descriptor instance, recognized by its ``__get__`` method. Calling that "
"method returns ``10``."
msgstr ""
"При поиске атрибута ``ax`` оператор точки находит ``'x': 5`` в словаре "
"класса. При поиске ``ay`` оператор точки находит экземпляр дескриптора, "
"распознаваемый его методом ``__get__``. Вызов этого метода возвращает ``10``."

#: ../../howto/descriptor.rst:78
msgid ""
"Note that the value ``10`` is not stored in either the class dictionary or "
"the instance dictionary.  Instead, the value ``10`` is computed on demand."
msgstr ""
"Обратите внимание, что значение «10» не сохраняется ни в словаре класса, ни "
"в словаре экземпляра. Вместо этого значение «10» вычисляется по требованию."

#: ../../howto/descriptor.rst:81
msgid ""
"This example shows how a simple descriptor works, but it isn't very useful. "
"For retrieving constants, normal attribute lookup would be better."
msgstr ""
"Этот пример показывает, как работает простой дескриптор, но он бесполезен. "
"Для получения констант лучше использовать обычный поиск по атрибутам."

#: ../../howto/descriptor.rst:84
msgid ""
"In the next section, we'll create something more useful, a dynamic lookup."
msgstr ""
"В следующем разделе мы создадим нечто более полезное — динамический поиск."

#: ../../howto/descriptor.rst:88
msgid "Dynamic lookups"
msgstr "Динамические поиски"

#: ../../howto/descriptor.rst:90
msgid ""
"Interesting descriptors typically run computations instead of returning "
"constants:"
msgstr ""
"Интересные дескрипторы обычно выполняют вычисления вместо возврата констант:"

#: ../../howto/descriptor.rst:109
msgid ""
"An interactive session shows that the lookup is dynamic — it computes "
"different, updated answers each time::"
msgstr ""
"Интерактивный сеанс показывает, что поиск является динамическим — каждый раз "
"вычисляет разные, обновленные ответы:"

#: ../../howto/descriptor.rst:122
msgid ""
"Besides showing how descriptors can run computations, this example also "
"reveals the purpose of the parameters to :meth:`__get__`.  The *self* "
"parameter is *size*, an instance of *DirectorySize*.  The *obj* parameter is "
"either *g* or *s*, an instance of *Directory*.  It is the *obj* parameter "
"that lets the :meth:`__get__` method learn the target directory.  The "
"*objtype* parameter is the class *Directory*."
msgstr ""
"Помимо демонстрации того, как дескрипторы могут выполнять вычисления, этот "
"пример также раскрывает назначение параметров :meth:`__get__`. Параметр "
"*self* — это *size*, экземпляр *DirectorySize*. Параметр *obj* — это либо "
"*g*, либо *s*, экземпляр *Directory*. Это параметр *obj*, который позволяет "
"методу :meth:`__get__` узнать целевой каталог. Параметр *objtype* — это "
"класс *Directory*."

#: ../../howto/descriptor.rst:131
msgid "Managed attributes"
msgstr "Управляемые атрибуты"

#: ../../howto/descriptor.rst:133
msgid ""
"A popular use for descriptors is managing access to instance data.  The "
"descriptor is assigned to a public attribute in the class dictionary while "
"the actual data is stored as a private attribute in the instance "
"dictionary.  The descriptor's :meth:`__get__` and :meth:`__set__` methods "
"are triggered when the public attribute is accessed."
msgstr ""
"Популярное использование дескрипторов — управление доступом к данным "
"экземпляра. Дескриптор присваивается общедоступному атрибуту в словаре "
"класса, а фактические данные сохраняются как частный атрибут в словаре "
"экземпляра. Методы :meth:`__get__` и :meth:`__set__` дескриптора срабатывают "
"при доступе к общедоступному атрибуту."

#: ../../howto/descriptor.rst:139
msgid ""
"In the following example, *age* is the public attribute and *_age* is the "
"private attribute.  When the public attribute is accessed, the descriptor "
"logs the lookup or update:"
msgstr ""
"В следующем примере *age* является общедоступным атрибутом, а *_age* — "
"закрытым атрибутом. При доступе к общедоступному атрибуту дескриптор "
"регистрирует поиск или обновление:"

#: ../../howto/descriptor.rst:172
msgid ""
"An interactive session shows that all access to the managed attribute *age* "
"is logged, but that the regular attribute *name* is not logged:"
msgstr ""
"Интерактивный сеанс показывает, что весь доступ к управляемому атрибуту "
"*age* протоколируется, но обычный атрибут *name* не регистрируется:"

#: ../../howto/descriptor.rst:206
msgid ""
"One major issue with this example is that the private name *_age* is "
"hardwired in the *LoggedAgeAccess* class.  That means that each instance can "
"only have one logged attribute and that its name is unchangeable.  In the "
"next example, we'll fix that problem."
msgstr ""
"Одна из основных проблем этого примера заключается в том, что частное имя "
"*_age* жестко закреплено в классе *LoggedAgeAccess*. Это означает, что "
"каждый экземпляр может иметь только один регистрируемый атрибут и его имя "
"невозможно изменить. В следующем примере мы исправим эту проблему."

#: ../../howto/descriptor.rst:213
msgid "Customized names"
msgstr "Индивидуальные имена"

#: ../../howto/descriptor.rst:215
msgid ""
"When a class uses descriptors, it can inform each descriptor about which "
"variable name was used."
msgstr ""
"Когда класс использует дескрипторы, он может сообщить каждому дескриптору, "
"какое имя переменной было использовано."

#: ../../howto/descriptor.rst:218
msgid ""
"In this example, the :class:`Person` class has two descriptor instances, "
"*name* and *age*.  When the :class:`Person` class is defined, it makes a "
"callback to :meth:`__set_name__` in *LoggedAccess* so that the field names "
"can be recorded, giving each descriptor its own *public_name* and "
"*private_name*:"
msgstr ""
"В этом примере класс :class:`Person` имеет два экземпляра дескриптора: "
"*name* и *age*. Когда класс :class:`Person` определен, он выполняет обратный "
"вызов :meth:`__set_name__` в *LoggedAccess*, чтобы можно было записать имена "
"полей, присваивая каждому дескриптору собственное *public_name* и "
"*private_name*:"

#: ../../howto/descriptor.rst:256
msgid ""
"An interactive session shows that the :class:`Person` class has called :meth:"
"`__set_name__` so that the field names would be recorded.  Here we call :"
"func:`vars` to look up the descriptor without triggering it:"
msgstr ""
"Интерактивный сеанс показывает, что класс :class:`Person` вызвал :meth:"
"`__set_name__`, чтобы были записаны имена полей. Здесь мы вызываем :func:"
"`vars` для поиска дескриптора без его запуска:"

#: ../../howto/descriptor.rst:267
msgid "The new class now logs access to both *name* and *age*:"
msgstr "Новый класс теперь регистрирует доступ как к *name*, так и к *age*:"

#: ../../howto/descriptor.rst:284
msgid "The two *Person* instances contain only the private names:"
msgstr "Два экземпляра *Person* содержат только частные имена:"

#: ../../howto/descriptor.rst:295
msgid "Closing thoughts"
msgstr "Заключительные мысли"

#: ../../howto/descriptor.rst:297
msgid ""
"A :term:`descriptor` is what we call any object that defines :meth:"
"`__get__`, :meth:`__set__`, or :meth:`__delete__`."
msgstr ""
":term:`дескриптор` — это то, что мы называем любым объектом, который "
"определяет :meth:`__get__`, :meth:`__set__` или :meth:`__delete__`."

#: ../../howto/descriptor.rst:300
msgid ""
"Optionally, descriptors can have a :meth:`__set_name__` method.  This is "
"only used in cases where a descriptor needs to know either the class where "
"it was created or the name of class variable it was assigned to.  (This "
"method, if present, is called even if the class is not a descriptor.)"
msgstr ""
"Опционально дескрипторы могут иметь метод :meth:`__set_name__`. Это "
"используется только в тех случаях, когда дескриптору необходимо знать либо "
"класс, в котором он был создан, либо имя переменной класса, которой он был "
"присвоен. (Этот метод, если он присутствует, вызывается, даже если класс не "
"является дескриптором.)"

#: ../../howto/descriptor.rst:305
msgid ""
"Descriptors get invoked by the dot operator during attribute lookup.  If a "
"descriptor is accessed indirectly with ``vars(some_class)"
"[descriptor_name]``, the descriptor instance is returned without invoking it."
msgstr ""
"Дескрипторы вызываются оператором точки во время поиска атрибута. Если "
"доступ к дескриптору осуществляется косвенно с помощью ``vars(some_class)"
"[descriptor_name]``, экземпляр дескриптора возвращается без его вызова."

#: ../../howto/descriptor.rst:309
msgid ""
"Descriptors only work when used as class variables.  When put in instances, "
"they have no effect."
msgstr ""
"Дескрипторы работают только при использовании в качестве переменных класса. "
"Когда они помещены в экземпляры, они не имеют никакого эффекта."

#: ../../howto/descriptor.rst:312
msgid ""
"The main motivation for descriptors is to provide a hook allowing objects "
"stored in class variables to control what happens during attribute lookup."
msgstr ""
"Основная мотивация использования дескрипторов — предоставить возможность "
"объектам, хранящимся в переменных класса, контролировать то, что происходит "
"во время поиска атрибутов."

#: ../../howto/descriptor.rst:315
msgid ""
"Traditionally, the calling class controls what happens during lookup. "
"Descriptors invert that relationship and allow the data being looked-up to "
"have a say in the matter."
msgstr ""
"Традиционно вызывающий класс управляет тем, что происходит во время поиска. "
"Дескрипторы инвертируют эту связь и позволяют искомым данным иметь право "
"голоса в этом вопросе."

#: ../../howto/descriptor.rst:319
msgid ""
"Descriptors are used throughout the language.  It is how functions turn into "
"bound methods.  Common tools like :func:`classmethod`, :func:"
"`staticmethod`, :func:`property`, and :func:`functools.cached_property` are "
"all implemented as descriptors."
msgstr ""
"Дескрипторы используются во всем языке. Именно так функции превращаются в "
"связанные методы. Общие инструменты, такие как :func:`classmethod`, :func:"
"`staticmethod`, :func:`property` и :func:`functools.cached_property`, "
"реализованы как дескрипторы."

#: ../../howto/descriptor.rst:326
msgid "Complete Practical Example"
msgstr "Полный практический пример"

#: ../../howto/descriptor.rst:328
msgid ""
"In this example, we create a practical and powerful tool for locating "
"notoriously hard to find data corruption bugs."
msgstr ""
"В этом примере мы создаем практичный и мощный инструмент для обнаружения "
"заведомо трудно обнаруживаемых ошибок, повреждающих данные."

#: ../../howto/descriptor.rst:333
msgid "Validator class"
msgstr "Класс валидатора"

#: ../../howto/descriptor.rst:335
msgid ""
"A validator is a descriptor for managed attribute access.  Prior to storing "
"any data, it verifies that the new value meets various type and range "
"restrictions.  If those restrictions aren't met, it raises an exception to "
"prevent data corruption at its source."
msgstr ""
"Валидатор — это дескриптор для доступа к управляемым атрибутам. Прежде чем "
"сохранять какие-либо данные, он проверяет, соответствует ли новое значение "
"различным ограничениям типа и диапазона. Если эти ограничения не "
"соблюдаются, создается исключение, чтобы предотвратить повреждение данных в "
"их источнике."

#: ../../howto/descriptor.rst:340
msgid ""
"This :class:`Validator` class is both an :term:`abstract base class` and a "
"managed attribute descriptor:"
msgstr ""
"Этот класс :class:`Validator` является одновременно :term:`абстрактным "
"базовым классом` и дескриптором управляемого атрибута:"

#: ../../howto/descriptor.rst:363
msgid ""
"Custom validators need to inherit from :class:`Validator` and must supply a :"
"meth:`validate` method to test various restrictions as needed."
msgstr ""
"Пользовательские валидаторы должны наследовать от :class:`Validator` и "
"должны предоставлять метод :meth:`validate` для проверки различных "
"ограничений по мере необходимости."

#: ../../howto/descriptor.rst:368
msgid "Custom validators"
msgstr "Пользовательские валидаторы"

#: ../../howto/descriptor.rst:370
msgid "Here are three practical data validation utilities:"
msgstr "Вот три практические утилиты проверки данных:"

#: ../../howto/descriptor.rst:372
msgid ""
":class:`OneOf` verifies that a value is one of a restricted set of options."
msgstr ""
":class:`OneOf` проверяет, что значение является одним из ограниченного "
"набора параметров."

#: ../../howto/descriptor.rst:374
msgid ""
":class:`Number` verifies that a value is either an :class:`int` or :class:"
"`float`.  Optionally, it verifies that a value is between a given minimum or "
"maximum."
msgstr ""
":class:`Number` проверяет, что значение является либо :class:`int`, либо :"
"class:`float`. При необходимости он проверяет, находится ли значение между "
"заданным минимумом или максимумом."

#: ../../howto/descriptor.rst:378
msgid ""
":class:`String` verifies that a value is a :class:`str`.  Optionally, it "
"validates a given minimum or maximum length.  It can validate a user-defined "
"`predicate <https://en.wikipedia.org/wiki/Predicate_(mathematical_logic)>`_ "
"as well."
msgstr ""
":class:`String` проверяет, что значение является :class:`str`. При "
"необходимости он проверяет заданную минимальную или максимальную длину. Он "
"также может проверять определенный пользователем `предикат <https://en."
"wikipedia.org/wiki/Predicate_(mathematical_logic)>`_."

#: ../../howto/descriptor.rst:437
msgid "Practical application"
msgstr "Практическое применение"

#: ../../howto/descriptor.rst:439
msgid "Here's how the data validators can be used in a real class:"
msgstr "Вот как валидаторы данных можно использовать в реальном классе:"

#: ../../howto/descriptor.rst:454
msgid "The descriptors prevent invalid instances from being created:"
msgstr "Дескрипторы предотвращают создание недопустимых экземпляров:"

#: ../../howto/descriptor.rst:481
msgid "Technical Tutorial"
msgstr "Техническое руководство"

#: ../../howto/descriptor.rst:483
msgid ""
"What follows is a more technical tutorial for the mechanics and details of "
"how descriptors work."
msgstr ""
"Далее следует более техническое руководство по механике и подробностям "
"работы дескрипторов."

#: ../../howto/descriptor.rst:488
msgid "Abstract"
msgstr "Абстракция"

#: ../../howto/descriptor.rst:490
msgid ""
"Defines descriptors, summarizes the protocol, and shows how descriptors are "
"called.  Provides an example showing how object relational mappings work."
msgstr ""
"Определяет дескрипторы, обобщает протокол и показывает, как вызываются "
"дескрипторы. Содержит пример, показывающий, как работают реляционные "
"сопоставления объектов."

#: ../../howto/descriptor.rst:493
msgid ""
"Learning about descriptors not only provides access to a larger toolset, it "
"creates a deeper understanding of how Python works."
msgstr ""
"Изучение дескрипторов не только обеспечивает доступ к более широкому набору "
"инструментов, но и дает более глубокое понимание того, как работает Python."

#: ../../howto/descriptor.rst:498
msgid "Definition and introduction"
msgstr "Определение и введение"

#: ../../howto/descriptor.rst:500
msgid ""
"In general, a descriptor is an attribute value that has one of the methods "
"in the descriptor protocol.  Those methods are :meth:`__get__`, :meth:"
"`__set__`, and :meth:`__delete__`.  If any of those methods are defined for "
"an attribute, it is said to be a :term:`descriptor`."
msgstr ""
"В общем, дескриптор — это значение атрибута, которое имеет один из методов "
"протокола дескриптора. Это методы :meth:`__get__`, :meth:`__set__` и :meth:"
"`__delete__`. Если для атрибута определен какой-либо из этих методов, он "
"называется :term:`дескриптором`."

#: ../../howto/descriptor.rst:505
msgid ""
"The default behavior for attribute access is to get, set, or delete the "
"attribute from an object's dictionary.  For instance, ``a.x`` has a lookup "
"chain starting with ``a.__dict__['x']``, then ``type(a).__dict__['x']``, and "
"continuing through the method resolution order of ``type(a)``. If the looked-"
"up value is an object defining one of the descriptor methods, then Python "
"may override the default behavior and invoke the descriptor method instead. "
"Where this occurs in the precedence chain depends on which descriptor "
"methods were defined."
msgstr ""
"Поведение по умолчанию для доступа к атрибуту — получение, установка или "
"удаление атрибута из словаря объекта. Например, ``ax`` имеет цепочку поиска, "
"начинающуюся с ``a.__dict__['x']``, затем ``type(a).__dict__['x']`` и "
"продолжающуюся до разрешения метода. порядок ``type(a)``. Если искомое "
"значение является объектом, определяющим один из методов дескриптора, то "
"Python может переопределить поведение по умолчанию и вместо этого вызвать "
"метод дескриптора. Где это происходит в цепочке приоритетов, зависит от "
"того, какие методы дескриптора были определены."

#: ../../howto/descriptor.rst:514
msgid ""
"Descriptors are a powerful, general purpose protocol.  They are the "
"mechanism behind properties, methods, static methods, class methods, and :"
"func:`super()`.  They are used throughout Python itself.  Descriptors "
"simplify the underlying C code and offer a flexible set of new tools for "
"everyday Python programs."
msgstr ""

#: ../../howto/descriptor.rst:522
msgid "Descriptor protocol"
msgstr "Протокол дескриптора"

#: ../../howto/descriptor.rst:524
msgid "``descr.__get__(self, obj, type=None) -> value``"
msgstr ""

#: ../../howto/descriptor.rst:526
msgid "``descr.__set__(self, obj, value) -> None``"
msgstr ""

#: ../../howto/descriptor.rst:528
msgid "``descr.__delete__(self, obj) -> None``"
msgstr ""

#: ../../howto/descriptor.rst:530
msgid ""
"That is all there is to it.  Define any of these methods and an object is "
"considered a descriptor and can override default behavior upon being looked "
"up as an attribute."
msgstr ""
"Вот и все. Определите любой из этих методов, и объект будет считаться "
"дескриптором и может переопределить поведение по умолчанию при поиске в "
"качестве атрибута."

#: ../../howto/descriptor.rst:534
msgid ""
"If an object defines :meth:`__set__` or :meth:`__delete__`, it is considered "
"a data descriptor.  Descriptors that only define :meth:`__get__` are called "
"non-data descriptors (they are often used for methods but other uses are "
"possible)."
msgstr ""
"Если объект определяет :meth:`__set__` или :meth:`__delete__`, он считается "
"дескриптором данных. Дескрипторы, которые определяют только :meth:`__get__`, "
"называются дескрипторами, не относящимися к данным (они часто используются "
"для методов, но возможны и другие варианты использования)."

#: ../../howto/descriptor.rst:539
msgid ""
"Data and non-data descriptors differ in how overrides are calculated with "
"respect to entries in an instance's dictionary.  If an instance's dictionary "
"has an entry with the same name as a data descriptor, the data descriptor "
"takes precedence.  If an instance's dictionary has an entry with the same "
"name as a non-data descriptor, the dictionary entry takes precedence."
msgstr ""
"Дескрипторы данных и не данных различаются тем, как переопределения "
"вычисляются по отношению к записям в словаре экземпляра. Если в словаре "
"экземпляра есть запись с тем же именем, что и у дескриптора данных, "
"дескриптор данных имеет приоритет. Если в словаре экземпляра есть запись с "
"тем же именем, что и у дескриптора, не являющегося данными, запись словаря "
"имеет приоритет."

#: ../../howto/descriptor.rst:545
msgid ""
"To make a read-only data descriptor, define both :meth:`__get__` and :meth:"
"`__set__` with the :meth:`__set__` raising an :exc:`AttributeError` when "
"called.  Defining the :meth:`__set__` method with an exception raising "
"placeholder is enough to make it a data descriptor."
msgstr ""
"Чтобы создать дескриптор данных, доступный только для чтения, определите :"
"meth:`__get__` и :meth:`__set__` с :meth:`__set__`, вызывающим :exc:"
"`AttributeError` при вызове. Определить метод :meth:`__set__` с "
"заполнителем, вызывающим исключение, достаточно, чтобы сделать его "
"дескриптором данных."

#: ../../howto/descriptor.rst:552
msgid "Overview of descriptor invocation"
msgstr "Обзор вызова дескриптора"

#: ../../howto/descriptor.rst:554
msgid ""
"A descriptor can be called directly with ``desc.__get__(obj)`` or ``desc."
"__get__(None, cls)``."
msgstr ""
"Дескриптор можно вызвать напрямую с помощью ``desc.__get__(obj)`` или ``desc."
"__get__(None, cls)``."

#: ../../howto/descriptor.rst:557
msgid ""
"But it is more common for a descriptor to be invoked automatically from "
"attribute access."
msgstr ""
"Но чаще всего дескриптор вызывается автоматически при доступе к атрибуту."

#: ../../howto/descriptor.rst:560
msgid ""
"The expression ``obj.x`` looks up the attribute ``x`` in the chain of "
"namespaces for ``obj``.  If the search finds a descriptor outside of the "
"instance ``__dict__``, its :meth:`__get__` method is invoked according to "
"the precedence rules listed below."
msgstr ""

#: ../../howto/descriptor.rst:565
msgid ""
"The details of invocation depend on whether ``obj`` is an object, class, or "
"instance of super."
msgstr ""
"Детали вызова зависят от того, является ли obj объектом, классом или "
"экземпляром super."

#: ../../howto/descriptor.rst:570
msgid "Invocation from an instance"
msgstr "Вызов из экземпляра"

#: ../../howto/descriptor.rst:572
msgid ""
"Instance lookup scans through a chain of namespaces giving data descriptors "
"the highest priority, followed by instance variables, then non-data "
"descriptors, then class variables, and lastly :meth:`__getattr__` if it is "
"provided."
msgstr ""
"Поиск экземпляра сканирует цепочку пространств имен, отдавая наивысший "
"приоритет дескрипторам данных, за которыми следуют переменные экземпляра, "
"затем дескрипторы, не относящиеся к данным, затем переменные класса и, "
"наконец, :meth:`__getattr__`, если он предусмотрен."

#: ../../howto/descriptor.rst:577
msgid ""
"If a descriptor is found for ``a.x``, then it is invoked with: ``desc."
"__get__(a, type(a))``."
msgstr ""
"Если для ``ax`` найден дескриптор, он вызывается с помощью: ``desc."
"__get__(a, type(a))``."

#: ../../howto/descriptor.rst:580
msgid ""
"The logic for a dotted lookup is in :meth:`object.__getattribute__`.  Here "
"is a pure Python equivalent:"
msgstr ""
"Логика точечного поиска находится в :meth:`object.__getattribute__`. Вот "
"чистый эквивалент Python:"

#: ../../howto/descriptor.rst:719
msgid ""
"Note, there is no :meth:`__getattr__` hook in the :meth:`__getattribute__` "
"code.  That is why calling :meth:`__getattribute__` directly or with "
"``super().__getattribute__`` will bypass :meth:`__getattr__` entirely."
msgstr ""
"Обратите внимание: в коде :meth:`__getattribute__` нет крючка :meth:"
"`__getattr__`. Вот почему вызов :meth:`__getattribute__` напрямую или с "
"помощью ``super().__getattribute__`` полностью обойдет :meth:`__getattr__`."

#: ../../howto/descriptor.rst:723
msgid ""
"Instead, it is the dot operator and the :func:`getattr` function that are "
"responsible for invoking :meth:`__getattr__` whenever :meth:"
"`__getattribute__` raises an :exc:`AttributeError`.  Their logic is "
"encapsulated in a helper function:"
msgstr ""
"Вместо этого именно оператор точки и функция :func:`getattr` отвечают за "
"вызов :meth:`__getattr__` всякий раз, когда :meth:`__getattribute__` "
"вызывает :exc:`AttributeError`. Их логика инкапсулирована во вспомогательной "
"функции:"

#: ../../howto/descriptor.rst:773
msgid "Invocation from a class"
msgstr "Вызов из класса"

#: ../../howto/descriptor.rst:775
msgid ""
"The logic for a dotted lookup such as ``A.x`` is in :meth:`type."
"__getattribute__`.  The steps are similar to those for :meth:`object."
"__getattribute__` but the instance dictionary lookup is replaced by a search "
"through the class's :term:`method resolution order`."
msgstr ""
"Логика точечного поиска, такого как ``Ax``, находится в :meth:`type."
"__getattribute__`. Шаги аналогичны шагам для :meth:`object."
"__getattribute__`, но поиск в словаре экземпляра заменяется поиском по :term:"
"`порядку разрешения методов` класса."

#: ../../howto/descriptor.rst:780
msgid "If a descriptor is found, it is invoked with ``desc.__get__(None, A)``."
msgstr ""
"Если дескриптор найден, он вызывается с помощью ``desc.__get__(None, A)``."

#: ../../howto/descriptor.rst:782
msgid ""
"The full C implementation can be found in :c:func:`type_getattro()` and :c:"
"func:`_PyType_Lookup()` in :source:`Objects/typeobject.c`."
msgstr ""

#: ../../howto/descriptor.rst:787
msgid "Invocation from super"
msgstr "Призыв от супер"

#: ../../howto/descriptor.rst:789
msgid ""
"The logic for super's dotted lookup is in the :meth:`__getattribute__` "
"method for object returned by :class:`super()`."
msgstr ""

#: ../../howto/descriptor.rst:792
msgid ""
"A dotted lookup such as ``super(A, obj).m`` searches ``obj.__class__."
"__mro__`` for the base class ``B`` immediately following ``A`` and then "
"returns ``B.__dict__['m'].__get__(obj, A)``.  If not a descriptor, ``m`` is "
"returned unchanged."
msgstr ""
"Поиск с точкой, такой как ``super(A, obj).m``, ищет в ``obj.__class__."
"__mro__`` базовый класс ``B`` сразу после ``A`` и затем возвращает ``B. "
"__dict__['m'].__get__(obj, A)``. Если это не дескриптор, ``m`` возвращается "
"без изменений."

#: ../../howto/descriptor.rst:797
msgid ""
"The full C implementation can be found in :c:func:`super_getattro()` in :"
"source:`Objects/typeobject.c`.  A pure Python equivalent can be found in "
"`Guido's Tutorial <https://www.python.org/download/releases/2.2.3/descrintro/"
"#cooperation>`_."
msgstr ""

#: ../../howto/descriptor.rst:804
msgid "Summary of invocation logic"
msgstr "Краткое описание логики вызова"

#: ../../howto/descriptor.rst:806
msgid ""
"The mechanism for descriptors is embedded in the :meth:`__getattribute__()` "
"methods for :class:`object`, :class:`type`, and :func:`super`."
msgstr ""

#: ../../howto/descriptor.rst:809
msgid "The important points to remember are:"
msgstr "Важные моменты, которые следует запомнить:"

#: ../../howto/descriptor.rst:811
msgid "Descriptors are invoked by the :meth:`__getattribute__` method."
msgstr "Дескрипторы вызываются методом :meth:`__getattribute__`."

#: ../../howto/descriptor.rst:813
msgid ""
"Classes inherit this machinery from :class:`object`, :class:`type`, or :func:"
"`super`."
msgstr ""
"Классы наследуют этот механизм от :class:`object`, :class:`type` или :func:"
"`super`."

#: ../../howto/descriptor.rst:816
msgid ""
"Overriding :meth:`__getattribute__` prevents automatic descriptor calls "
"because all the descriptor logic is in that method."
msgstr ""
"Переопределение :meth:`__getattribute__` предотвращает автоматический вызов "
"дескриптора, поскольку вся логика дескриптора находится в этом методе."

#: ../../howto/descriptor.rst:819
msgid ""
":meth:`object.__getattribute__` and :meth:`type.__getattribute__` make "
"different calls to :meth:`__get__`.  The first includes the instance and may "
"include the class.  The second puts in ``None`` for the instance and always "
"includes the class."
msgstr ""
":meth:`object.__getattribute__` и :meth:`type.__getattribute__` выполняют "
"разные вызовы :meth:`__get__`. Первый включает экземпляр и может включать "
"класс. Второй устанавливает значение None для экземпляра и всегда включает "
"класс."

#: ../../howto/descriptor.rst:824
msgid "Data descriptors always override instance dictionaries."
msgstr "Дескрипторы данных всегда переопределяют словари экземпляров."

#: ../../howto/descriptor.rst:826
msgid "Non-data descriptors may be overridden by instance dictionaries."
msgstr ""
"Дескрипторы, не являющиеся данными, могут быть переопределены словарями "
"экземпляров."

#: ../../howto/descriptor.rst:830
msgid "Automatic name notification"
msgstr "Автоматическое уведомление об имени"

#: ../../howto/descriptor.rst:832
msgid ""
"Sometimes it is desirable for a descriptor to know what class variable name "
"it was assigned to.  When a new class is created, the :class:`type` "
"metaclass scans the dictionary of the new class.  If any of the entries are "
"descriptors and if they define :meth:`__set_name__`, that method is called "
"with two arguments.  The *owner* is the class where the descriptor is used, "
"and the *name* is the class variable the descriptor was assigned to."
msgstr ""
"Иногда желательно, чтобы дескриптор знал, какое имя переменной класса ему "
"присвоено. Когда создается новый класс, метакласс :class:`type` сканирует "
"словарь нового класса. Если какие-либо записи являются дескрипторами и "
"определяют :meth:`__set_name__`, этот метод вызывается с двумя аргументами. "
"*владелец* — это класс, в котором используется дескриптор, а *имя* — это "
"переменная класса, которой был назначен дескриптор."

#: ../../howto/descriptor.rst:839
msgid ""
"The implementation details are in :c:func:`type_new()` and :c:func:"
"`set_names()` in :source:`Objects/typeobject.c`."
msgstr ""

#: ../../howto/descriptor.rst:842
msgid ""
"Since the update logic is in :meth:`type.__new__`, notifications only take "
"place at the time of class creation.  If descriptors are added to the class "
"afterwards, :meth:`__set_name__` will need to be called manually."
msgstr ""
"Поскольку логика обновления находится в :meth:`type.__new__`, уведомления "
"происходят только во время создания класса. Если впоследствии к классу будут "
"добавлены дескрипторы, :meth:`__set_name__` нужно будет вызывать вручную."

#: ../../howto/descriptor.rst:848
msgid "ORM example"
msgstr "Пример ORM"

#: ../../howto/descriptor.rst:850
msgid ""
"The following code is a simplified skeleton showing how data descriptors "
"could be used to implement an `object relational mapping <https://en."
"wikipedia.org/wiki/Object%E2%80%93relational_mapping>`_."
msgstr ""
"Следующий код представляет собой упрощенный скелет, показывающий, как можно "
"использовать дескрипторы данных для реализации реляционного сопоставления "
"объектов <https://en.wikipedia.org/wiki/Object. %И "
"2%80%93реляционное_отображение>`_."

#: ../../howto/descriptor.rst:854
msgid ""
"The essential idea is that the data is stored in an external database.  The "
"Python instances only hold keys to the database's tables.  Descriptors take "
"care of lookups or updates:"
msgstr ""
"Основная идея заключается в том, что данные хранятся во внешней базе данных. "
"Экземпляры Python содержат только ключи к таблицам базы данных. Дескрипторы "
"заботятся о поиске или обновлении:"

#: ../../howto/descriptor.rst:873
msgid ""
"We can use the :class:`Field` class to define `models <https://en.wikipedia."
"org/wiki/Database_model>`_ that describe the schema for each table in a "
"database:"
msgstr ""
"Мы можем использовать класс :class:`Field` для определения `моделей <https://"
"en.wikipedia.org/wiki/Database_model>`_, которые описывают схему для каждой "
"таблицы в базе данных:"

#: ../../howto/descriptor.rst:898
msgid "To use the models, first connect to the database::"
msgstr "Чтобы использовать модели, сначала подключитесь к базе данных:"

#: ../../howto/descriptor.rst:903
msgid ""
"An interactive session shows how data is retrieved from the database and how "
"it can be updated:"
msgstr ""
"Интерактивный сеанс показывает, как данные извлекаются из базы данных и как "
"их можно обновить:"

#: ../../howto/descriptor.rst:948
msgid "Pure Python Equivalents"
msgstr "Эквиваленты чистого Python"

#: ../../howto/descriptor.rst:950
msgid ""
"The descriptor protocol is simple and offers exciting possibilities.  "
"Several use cases are so common that they have been prepackaged into built-"
"in tools. Properties, bound methods, static methods, class methods, and "
"\\_\\_slots\\_\\_ are all based on the descriptor protocol."
msgstr ""
"Протокол дескриптора прост и предлагает потрясающие возможности. Некоторые "
"варианты использования настолько распространены, что они были встроены во "
"встроенные инструменты. Свойства, связанные методы, статические методы, "
"методы класса и \\_\\_slots\\_\\_ — все они основаны на протоколе "
"дескрипторов."

#: ../../howto/descriptor.rst:957
msgid "Properties"
msgstr "Свойства"

#: ../../howto/descriptor.rst:959
msgid ""
"Calling :func:`property` is a succinct way of building a data descriptor "
"that triggers a function call upon access to an attribute.  Its signature "
"is::"
msgstr ""
"Вызов :func:`property` — это краткий способ создания дескриптора данных, "
"который запускает вызов функции при доступе к атрибуту. Его подпись::"

#: ../../howto/descriptor.rst:964
msgid ""
"The documentation shows a typical use to define a managed attribute ``x``:"
msgstr ""
"В документации показано типичное использование для определения управляемого "
"атрибута «x»:"

#: ../../howto/descriptor.rst:988
msgid ""
"To see how :func:`property` is implemented in terms of the descriptor "
"protocol, here is a pure Python equivalent:"
msgstr ""
"Чтобы увидеть, как :func:`property` реализуется с точки зрения протокола "
"дескриптора, вот эквивалент на чистом Python:"

#: ../../howto/descriptor.rst:1091
msgid ""
"The :func:`property` builtin helps whenever a user interface has granted "
"attribute access and then subsequent changes require the intervention of a "
"method."
msgstr ""
"Встроенная функция :func:`property` помогает, когда пользовательский "
"интерфейс предоставил доступ к атрибуту, а затем последующие изменения "
"требуют вмешательства метода."

#: ../../howto/descriptor.rst:1095
msgid ""
"For instance, a spreadsheet class may grant access to a cell value through "
"``Cell('b10').value``. Subsequent improvements to the program require the "
"cell to be recalculated on every access; however, the programmer does not "
"want to affect existing client code accessing the attribute directly.  The "
"solution is to wrap access to the value attribute in a property data "
"descriptor:"
msgstr ""
"Например, класс электронной таблицы может предоставить доступ к значению "
"ячейки через ``Cell('b10').value``. Последующие улучшения программы требуют "
"перерасчета ячейки при каждом доступе; однако программист не хочет влиять на "
"существующий клиентский код, обращаясь к атрибуту напрямую. Решение состоит "
"в том, чтобы обернуть доступ к атрибуту значения в дескриптор данных "
"свойства:"

#: ../../howto/descriptor.rst:1112
msgid ""
"Either the built-in :func:`property` or our :func:`Property` equivalent "
"would work in this example."
msgstr ""
"В этом примере будет работать либо встроенный :func:`property`, либо наш "
"эквивалент :func:`Property`."

#: ../../howto/descriptor.rst:1117
msgid "Functions and methods"
msgstr "Функции и методы"

#: ../../howto/descriptor.rst:1119
msgid ""
"Python's object oriented features are built upon a function based "
"environment. Using non-data descriptors, the two are merged seamlessly."
msgstr ""
"Объектно-ориентированные функции Python построены на среде, основанной на "
"функциях. Используя дескрипторы, не являющиеся данными, они легко "
"объединяются."

#: ../../howto/descriptor.rst:1122
msgid ""
"Functions stored in class dictionaries get turned into methods when invoked. "
"Methods only differ from regular functions in that the object instance is "
"prepended to the other arguments.  By convention, the instance is called "
"*self* but could be called *this* or any other variable name."
msgstr ""
"Функции, хранящиеся в словарях классов, при вызове превращаются в методы. "
"Методы отличаются от обычных функций только тем, что экземпляр объекта "
"добавляется к другим аргументам. По соглашению экземпляр называется *self*, "
"но может называться *this* или любым другим именем переменной."

#: ../../howto/descriptor.rst:1127
msgid ""
"Methods can be created manually with :class:`types.MethodType` which is "
"roughly equivalent to:"
msgstr ""
"Методы можно создавать вручную с помощью :class:`types.MethodType`, что "
"примерно эквивалентно:"

#: ../../howto/descriptor.rst:1144
msgid ""
"To support automatic creation of methods, functions include the :meth:"
"`__get__` method for binding methods during attribute access.  This means "
"that functions are non-data descriptors that return bound methods during "
"dotted lookup from an instance.  Here's how it works:"
msgstr ""
"Для поддержки автоматического создания методов функции включают метод :meth:"
"`__get__` для привязки методов во время доступа к атрибутам. Это означает, "
"что функции не являются дескрипторами данных, которые возвращают связанные "
"методы во время точечного поиска из экземпляра. Вот как это работает:"

#: ../../howto/descriptor.rst:1160
msgid ""
"Running the following class in the interpreter shows how the function "
"descriptor works in practice:"
msgstr ""
"Запуск следующего класса в интерпретаторе показывает, как на практике "
"работает дескриптор функции:"

#: ../../howto/descriptor.rst:1169
msgid ""
"The function has a :term:`qualified name` attribute to support introspection:"
msgstr ""
"Функция имеет атрибут :term:`qualified name` для поддержки самоанализа:"

#: ../../howto/descriptor.rst:1176
msgid ""
"Accessing the function through the class dictionary does not invoke :meth:"
"`__get__`.  Instead, it just returns the underlying function object::"
msgstr ""
"Доступ к функции через словарь классов не вызывает :meth:`__get__`. Вместо "
"этого он просто возвращает базовый объект функции::"

#: ../../howto/descriptor.rst:1182
msgid ""
"Dotted access from a class calls :meth:`__get__` which just returns the "
"underlying function unchanged::"
msgstr ""
"Точечный доступ из класса вызывает :meth:`__get__`, который просто "
"возвращает базовую функцию без изменений::"

#: ../../howto/descriptor.rst:1188
msgid ""
"The interesting behavior occurs during dotted access from an instance.  The "
"dotted lookup calls :meth:`__get__` which returns a bound method object::"
msgstr ""
"Интересное поведение происходит во время точечного доступа из экземпляра. "
"Точечный поиск вызывает :meth:`__get__`, который возвращает связанный объект "
"метода::"

#: ../../howto/descriptor.rst:1195
msgid ""
"Internally, the bound method stores the underlying function and the bound "
"instance::"
msgstr "Внутри связанный метод хранит базовую функцию и связанный экземпляр::"

#: ../../howto/descriptor.rst:1204
msgid ""
"If you have ever wondered where *self* comes from in regular methods or "
"where *cls* comes from in class methods, this is it!"
msgstr ""
"Если вы когда-нибудь задавались вопросом, откуда берется *self* в обычных "
"методах или откуда берется *cls* в методах класса, то вот оно!"

#: ../../howto/descriptor.rst:1209
msgid "Kinds of methods"
msgstr "Виды методов"

#: ../../howto/descriptor.rst:1211
msgid ""
"Non-data descriptors provide a simple mechanism for variations on the usual "
"patterns of binding functions into methods."
msgstr ""
"Дескрипторы, не являющиеся данными, предоставляют простой механизм для "
"вариаций обычных шаблонов привязки функций к методам."

#: ../../howto/descriptor.rst:1214
msgid ""
"To recap, functions have a :meth:`__get__` method so that they can be "
"converted to a method when accessed as attributes.  The non-data descriptor "
"transforms an ``obj.f(*args)`` call into ``f(obj, *args)``.  Calling ``cls."
"f(*args)`` becomes ``f(*args)``."
msgstr ""
"Напомним, что у функций есть метод :meth:`__get__`, поэтому их можно "
"преобразовать в метод при доступе в качестве атрибутов. Дескриптор, не "
"являющийся данными, преобразует вызов ``obj.f(*args)`` в ``f(obj, *args)``. "
"Вызов ``cls.f(*args)`` становится ``f(*args)``."

#: ../../howto/descriptor.rst:1219
msgid "This chart summarizes the binding and its two most useful variants:"
msgstr "Эта диаграмма суммирует привязку и два ее наиболее полезных варианта:"

#: ../../howto/descriptor.rst:1222
msgid "Transformation"
msgstr "Трансформация"

#: ../../howto/descriptor.rst:1222
msgid "Called from an object"
msgstr "Вызывается из объекта"

#: ../../howto/descriptor.rst:1222
msgid "Called from a class"
msgstr "Звонок из класса"

#: ../../howto/descriptor.rst:1225
msgid "function"
msgstr "функция"

#: ../../howto/descriptor.rst:1225
msgid "f(obj, \\*args)"
msgstr "f(obj, \\*args)"

#: ../../howto/descriptor.rst:1225 ../../howto/descriptor.rst:1227
msgid "f(\\*args)"
msgstr "f(\\*args)"

#: ../../howto/descriptor.rst:1227
msgid "staticmethod"
msgstr "staticmethod"

#: ../../howto/descriptor.rst:1229
msgid "classmethod"
msgstr "classmethod"

#: ../../howto/descriptor.rst:1229
msgid "f(type(obj), \\*args)"
msgstr "f(type(obj), \\*args)"

#: ../../howto/descriptor.rst:1229
msgid "f(cls, \\*args)"
msgstr "f(cls, \\*args)"

#: ../../howto/descriptor.rst:1234
msgid "Static methods"
msgstr "Статические методы"

#: ../../howto/descriptor.rst:1236
msgid ""
"Static methods return the underlying function without changes.  Calling "
"either ``c.f`` or ``C.f`` is the equivalent of a direct lookup into ``object."
"__getattribute__(c, \"f\")`` or ``object.__getattribute__(C, \"f\")``. As a "
"result, the function becomes identically accessible from either an object or "
"a class."
msgstr ""
"Статические методы возвращают базовую функцию без изменений. Вызов ``cf`` "
"или ``Cf`` эквивалентен прямому поиску в ``object.__getattribute__(c, "
"\"f\")`` или ``object.__getattribute__(C, \"f\")`` . В результате функция "
"становится одинаково доступной как из объекта, так и из класса."

#: ../../howto/descriptor.rst:1242
msgid ""
"Good candidates for static methods are methods that do not reference the "
"``self`` variable."
msgstr ""
"Хорошими кандидатами для статических методов являются методы, которые не "
"ссылаются на переменную self."

#: ../../howto/descriptor.rst:1245
msgid ""
"For instance, a statistics package may include a container class for "
"experimental data.  The class provides normal methods for computing the "
"average, mean, median, and other descriptive statistics that depend on the "
"data. However, there may be useful functions which are conceptually related "
"but do not depend on the data.  For instance, ``erf(x)`` is handy conversion "
"routine that comes up in statistical work but does not directly depend on a "
"particular dataset. It can be called either from an object or the class:  "
"``s.erf(1.5) --> .9332`` or ``Sample.erf(1.5) --> .9332``."
msgstr ""
"Например, пакет статистики может включать класс-контейнер для "
"экспериментальных данных. Класс предоставляет обычные методы для вычисления "
"среднего, среднего, медианного и других описательных статистических данных, "
"которые зависят от данных. Однако могут существовать полезные функции, "
"которые концептуально связаны, но не зависят от данных. Например, erf(x) — "
"это удобная процедура преобразования, которая используется в статистических "
"работах, но не зависит напрямую от конкретного набора данных. Его можно "
"вызвать либо из объекта, либо из класса: ``s.erf(1.5) --> .9332`` или "
"``Sample.erf(1.5) --> .9332``."

#: ../../howto/descriptor.rst:1254
msgid ""
"Since static methods return the underlying function with no changes, the "
"example calls are unexciting:"
msgstr ""
"Поскольку статические методы возвращают базовую функцию без изменений, "
"примеры вызовов неинтересны:"

#: ../../howto/descriptor.rst:1271
msgid ""
"Using the non-data descriptor protocol, a pure Python version of :func:"
"`staticmethod` would look like this:"
msgstr ""
"Используя протокол дескриптора без данных, версия :func:`staticmethod` на "
"чистом Python будет выглядеть так:"

#: ../../howto/descriptor.rst:1310
msgid "Class methods"
msgstr "Методы класса"

#: ../../howto/descriptor.rst:1312
msgid ""
"Unlike static methods, class methods prepend the class reference to the "
"argument list before calling the function.  This format is the same for "
"whether the caller is an object or a class:"
msgstr ""
"В отличие от статических методов, методы класса добавляют ссылку на класс в "
"список аргументов перед вызовом функции. Этот формат одинаков для того, "
"является ли вызывающий объект объектом или классом:"

#: ../../howto/descriptor.rst:1330
msgid ""
"This behavior is useful whenever the method only needs to have a class "
"reference and does not rely on data stored in a specific instance.  One use "
"for class methods is to create alternate class constructors.  For example, "
"the classmethod :func:`dict.fromkeys` creates a new dictionary from a list "
"of keys.  The pure Python equivalent is:"
msgstr ""
"Такое поведение полезно, когда методу требуется только ссылка на класс и он "
"не полагается на данные, хранящиеся в конкретном экземпляре. Одним из "
"применений методов класса является создание альтернативных конструкторов "
"классов. Например, метод класса :func:`dict.fromkeys` создает новый словарь "
"из списка ключей. Чистый эквивалент Python:"

#: ../../howto/descriptor.rst:1347
msgid "Now a new dictionary of unique keys can be constructed like this:"
msgstr ""
"Теперь новый словарь уникальных ключей можно создать следующим образом:"

#: ../../howto/descriptor.rst:1357
msgid ""
"Using the non-data descriptor protocol, a pure Python version of :func:"
"`classmethod` would look like this:"
msgstr ""
"Используя протокол дескриптора без данных, версия :func:`classmethod` на "
"чистом Python будет выглядеть так:"

#: ../../howto/descriptor.rst:1406
msgid ""
"The code path for ``hasattr(type(self.f), '__get__')`` was added in Python "
"3.9 and makes it possible for :func:`classmethod` to support chained "
"decorators.  For example, a classmethod and property could be chained "
"together:"
msgstr ""

#: ../../howto/descriptor.rst:1426
msgid "Member objects and __slots__"
msgstr "Объекты-члены и __slots__"

#: ../../howto/descriptor.rst:1428
msgid ""
"When a class defines ``__slots__``, it replaces instance dictionaries with a "
"fixed-length array of slot values.  From a user point of view that has "
"several effects:"
msgstr ""
"Когда класс определяет ``__slots__``, он заменяет словари экземпляров "
"массивом значений слотов фиксированной длины. С точки зрения пользователя "
"это имеет несколько эффектов:"

#: ../../howto/descriptor.rst:1432
msgid ""
"1. Provides immediate detection of bugs due to misspelled attribute "
"assignments.  Only attribute names specified in ``__slots__`` are allowed:"
msgstr ""
"1. Обеспечивает немедленное обнаружение ошибок из-за неправильного "
"назначения атрибутов. Разрешены только имена атрибутов, указанные в "
"``__slots__``:"

#: ../../howto/descriptor.rst:1448
msgid ""
"2. Helps create immutable objects where descriptors manage access to private "
"attributes stored in ``__slots__``:"
msgstr ""
"2. Помогает создавать неизменяемые объекты, в которых дескрипторы управляют "
"доступом к частным атрибутам, хранящимся в ``__slots__``:"

#: ../../howto/descriptor.rst:1483
msgid ""
"3. Saves memory.  On a 64-bit Linux build, an instance with two attributes "
"takes 48 bytes with ``__slots__`` and 152 bytes without.  This `flyweight "
"design pattern <https://en.wikipedia.org/wiki/Flyweight_pattern>`_ likely "
"only matters when a large number of instances are going to be created."
msgstr ""
"3. Экономит память. В 64-битной сборке Linux экземпляр с двумя атрибутами "
"занимает 48 байт с ``__slots__`` и 152 байта без него. Этот `шаблон "
"проектирования легковеса <https://en.wikipedia.org/wiki/"
"Flyweight_pattern>`_, вероятно, имеет значение только тогда, когда будет "
"создано большое количество экземпляров."

#: ../../howto/descriptor.rst:1488
msgid ""
"4. Improves speed.  Reading instance variables is 35% faster with "
"``__slots__`` (as measured with Python 3.10 on an Apple M1 processor)."
msgstr ""
"4. Улучшает скорость. Чтение переменных экземпляра происходит на 35 % "
"быстрее с помощью ``__slots__`` (по измерениям с помощью Python 3.10 на "
"процессоре Apple M1)."

#: ../../howto/descriptor.rst:1491
msgid ""
"5. Blocks tools like :func:`functools.cached_property` which require an "
"instance dictionary to function correctly:"
msgstr ""
"5. Блокирует такие инструменты, как :func:`functools.cached_property`, для "
"правильной работы которых требуется словарь экземпляра:"

#: ../../howto/descriptor.rst:1513
msgid ""
"It is not possible to create an exact drop-in pure Python version of "
"``__slots__`` because it requires direct access to C structures and control "
"over object memory allocation.  However, we can build a mostly faithful "
"simulation where the actual C structure for slots is emulated by a private "
"``_slotvalues`` list.  Reads and writes to that private structure are "
"managed by member descriptors:"
msgstr ""
"Невозможно создать точную версию ``__slots__`` на чистом Python, поскольку "
"для этого требуется прямой доступ к структурам C и контроль над "
"распределением памяти объекта. Тем не менее, мы можем построить наиболее "
"точную симуляцию, в которой фактическая структура C для слотов эмулируется "
"частным списком ``_slotvalues``. Чтение и запись в эту частную структуру "
"управляются дескрипторами членов:"

#: ../../howto/descriptor.rst:1558
msgid ""
"The :meth:`type.__new__` method takes care of adding member objects to class "
"variables:"
msgstr ""
"Метод :meth:`type.__new__` заботится о добавлении объектов-членов в "
"переменные класса:"

#: ../../howto/descriptor.rst:1574
msgid ""
"The :meth:`object.__new__` method takes care of creating instances that have "
"slots instead of an instance dictionary.  Here is a rough simulation in pure "
"Python:"
msgstr ""
"Метод :meth:`object.__new__` заботится о создании экземпляров, имеющих слоты "
"вместо словаря экземпляров. Вот грубое моделирование на чистом Python:"

#: ../../howto/descriptor.rst:1609
msgid ""
"To use the simulation in a real class, just inherit from :class:`Object` and "
"set the :term:`metaclass` to :class:`Type`:"
msgstr ""
"Чтобы использовать симуляцию в реальном классе, просто наследуйте :class:"
"`Object` и установите для :term:`metaclass` значение :class:`Type`:"

#: ../../howto/descriptor.rst:1623
msgid ""
"At this point, the metaclass has loaded member objects for *x* and *y*::"
msgstr "На этом этапе метакласс загрузил объекты-члены для *x* и *y*::"

#: ../../howto/descriptor.rst:1644
msgid ""
"When instances are created, they have a ``slot_values`` list where the "
"attributes are stored:"
msgstr ""
"Когда экземпляры создаются, у них есть список ``slot_values``, в котором "
"хранятся атрибуты:"

#: ../../howto/descriptor.rst:1656
msgid "Misspelled or unassigned attributes will raise an exception:"
msgstr "Неправильно написанные или неназначенные атрибуты вызовут исключение:"
