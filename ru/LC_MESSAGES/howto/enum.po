# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Roustam Khamidoulline, 2024
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-03-21 14:55+0000\n"
"PO-Revision-Date: 2024-05-11 00:32+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../howto/enum.rst:5
msgid "Enum HOWTO"
msgstr "Перечисление HOWTO"

#: ../../howto/enum.rst:11
msgid ""
"An :class:`Enum` is a set of symbolic names bound to unique values.  They "
"are similar to global variables, but they offer a more useful :func:`repr`, "
"grouping, type-safety, and a few other features."
msgstr ""
":class:`Enum` — это набор символических имен, привязанных к уникальным "
"значениям. Они похожи на глобальные переменные, но предлагают более полезные "
"функции repr, группировку, безопасность типов и некоторые другие функции."

#: ../../howto/enum.rst:15
msgid ""
"They are most useful when you have a variable that can take one of a limited "
"selection of values.  For example, the days of the week::"
msgstr ""
"Они наиболее полезны, когда у вас есть переменная, которая может принимать "
"одно из ограниченного набора значений. Например, дни недели:"

#: ../../howto/enum.rst:18
msgid ""
">>> from enum import Enum\n"
">>> class Weekday(Enum):\n"
"...     MONDAY = 1\n"
"...     TUESDAY = 2\n"
"...     WEDNESDAY = 3\n"
"...     THURSDAY = 4\n"
"...     FRIDAY = 5\n"
"...     SATURDAY = 6\n"
"...     SUNDAY = 7"
msgstr ""
">>> from enum import Enum\n"
">>> class Weekday(Enum):\n"
"...     MONDAY = 1\n"
"...     TUESDAY = 2\n"
"...     WEDNESDAY = 3\n"
"...     THURSDAY = 4\n"
"...     FRIDAY = 5\n"
"...     SATURDAY = 6\n"
"...     SUNDAY = 7"

#: ../../howto/enum.rst:28
msgid "Or perhaps the RGB primary colors::"
msgstr "Или, возможно, основные цвета RGB::"

#: ../../howto/enum.rst:30
msgid ""
">>> from enum import Enum\n"
">>> class Color(Enum):\n"
"...     RED = 1\n"
"...     GREEN = 2\n"
"...     BLUE = 3"
msgstr ""
">>> from enum import Enum\n"
">>> class Color(Enum):\n"
"...     RED = 1\n"
"...     GREEN = 2\n"
"...     BLUE = 3"

#: ../../howto/enum.rst:36
msgid ""
"As you can see, creating an :class:`Enum` is as simple as writing a class "
"that inherits from :class:`Enum` itself."
msgstr ""
"Как видите, создать :class:`Enum` так же просто, как написать класс, который "
"наследуется от самого :class:`Enum`."

#: ../../howto/enum.rst:39
msgid "Case of Enum Members"
msgstr "Регистр членов перечисления"

#: ../../howto/enum.rst:41
msgid ""
"Because Enums are used to represent constants, and to help avoid issues with "
"name clashes between mixin-class methods/attributes and enum names, we "
"strongly recommend using UPPER_CASE names for members, and will be using "
"that style in our examples."
msgstr ""
"Поскольку перечисления используются для представления констант и во "
"избежание проблем с конфликтами имен между методами/атрибутами класса-"
"миксина и именами перечислений, мы настоятельно рекомендуем использовать "
"имена в верхнем регистре для членов и будем использовать этот стиль в наших "
"примерах."

#: ../../howto/enum.rst:46
msgid ""
"Depending on the nature of the enum a member's value may or may not be "
"important, but either way that value can be used to get the corresponding "
"member::"
msgstr ""
"В зависимости от характера перечисления значение члена может быть важным, а "
"может и не быть важным, но в любом случае это значение можно использовать "
"для получения соответствующего члена:"

#: ../../howto/enum.rst:50
msgid ""
">>> Weekday(3)\n"
"<Weekday.WEDNESDAY: 3>"
msgstr ""
">>> Weekday(3)\n"
"<Weekday.WEDNESDAY: 3>"

#: ../../howto/enum.rst:53
msgid ""
"As you can see, the ``repr()`` of a member shows the enum name, the member "
"name, and the value.  The ``str()`` of a member shows only the enum name and "
"member name::"
msgstr ""
"Как вы можете видеть, ``repr()`` члена показывает имя перечисления, имя "
"члена и значение. ``str()`` члена показывает только имя перечисления и имя "
"члена::"

#: ../../howto/enum.rst:57
msgid ""
">>> print(Weekday.THURSDAY)\n"
"Weekday.THURSDAY"
msgstr ""
">>> print(Weekday.THURSDAY)\n"
"Weekday.THURSDAY"

#: ../../howto/enum.rst:60
msgid "The *type* of an enumeration member is the enum it belongs to::"
msgstr "*Тип* члена перечисления — это перечисление, которому он принадлежит::"

#: ../../howto/enum.rst:62
msgid ""
">>> type(Weekday.MONDAY)\n"
"<enum 'Weekday'>\n"
">>> isinstance(Weekday.FRIDAY, Weekday)\n"
"True"
msgstr ""
">>> type(Weekday.MONDAY)\n"
"<enum 'Weekday'>\n"
">>> isinstance(Weekday.FRIDAY, Weekday)\n"
"True"

#: ../../howto/enum.rst:67
msgid "Enum members have an attribute that contains just their :attr:`!name`::"
msgstr ""
"Члены перечисления имеют атрибут, который содержит только их :attr:`!name`::"

#: ../../howto/enum.rst:69
msgid ""
">>> print(Weekday.TUESDAY.name)\n"
"TUESDAY"
msgstr ""
">>> print(Weekday.TUESDAY.name)\n"
"TUESDAY"

#: ../../howto/enum.rst:72
msgid "Likewise, they have an attribute for their :attr:`!value`::"
msgstr "Аналогично, у них есть атрибут для их :attr:`!value`::"

#: ../../howto/enum.rst:75
msgid ""
">>> Weekday.WEDNESDAY.value\n"
"3"
msgstr ""
">>> Weekday.WEDNESDAY.value\n"
"3"

#: ../../howto/enum.rst:78
msgid ""
"Unlike many languages that treat enumerations solely as name/value pairs, "
"Python Enums can have behavior added.  For example, :class:`datetime.date` "
"has two methods for returning the weekday: :meth:`~datetime.date.weekday` "
"and :meth:`~datetime.date.isoweekday`. The difference is that one of them "
"counts from 0-6 and the other from 1-7. Rather than keep track of that "
"ourselves we can add a method to the :class:`!Weekday` enum to extract the "
"day from the :class:`~datetime.date` instance and return the matching enum "
"member::"
msgstr ""
"В отличие от многих языков, которые рассматривают перечисления исключительно "
"как пары имя/значение, в Python Enums можно добавлять поведение. Например, :"
"class:`datetime.date` имеет два метода для возврата дня недели: :meth:"
"`~datetime.date.weekday` и :meth:`~datetime.date.isoweekday`. Разница в том, "
"что один из них считает от 0 до 6, а другой от 1 до 7. Вместо того, чтобы "
"отслеживать это самостоятельно, мы можем добавить метод в перечисление :"
"class:`!Weekday` для извлечения дня из экземпляра :class:`~datetime.date` и "
"возврата соответствующего члена перечисления::"

#: ../../howto/enum.rst:87
msgid ""
"@classmethod\n"
"def from_date(cls, date):\n"
"    return cls(date.isoweekday())"
msgstr ""
"@classmethod\n"
"def from_date(cls, date):\n"
"    return cls(date.isoweekday())"

#: ../../howto/enum.rst:91
msgid "The complete :class:`!Weekday` enum now looks like this::"
msgstr "Полное перечисление :class:`!Weekday` теперь выглядит так::"

#: ../../howto/enum.rst:93
msgid ""
">>> class Weekday(Enum):\n"
"...     MONDAY = 1\n"
"...     TUESDAY = 2\n"
"...     WEDNESDAY = 3\n"
"...     THURSDAY = 4\n"
"...     FRIDAY = 5\n"
"...     SATURDAY = 6\n"
"...     SUNDAY = 7\n"
"...     #\n"
"...     @classmethod\n"
"...     def from_date(cls, date):\n"
"...         return cls(date.isoweekday())"
msgstr ""
">>> class Weekday(Enum):\n"
"...     MONDAY = 1\n"
"...     TUESDAY = 2\n"
"...     WEDNESDAY = 3\n"
"...     THURSDAY = 4\n"
"...     FRIDAY = 5\n"
"...     SATURDAY = 6\n"
"...     SUNDAY = 7\n"
"...     #\n"
"...     @classmethod\n"
"...     def from_date(cls, date):\n"
"...         return cls(date.isoweekday())"

#: ../../howto/enum.rst:106
msgid "Now we can find out what today is!  Observe::"
msgstr "Теперь мы можем узнать, что сегодня! Наблюдать::"

#: ../../howto/enum.rst:108
msgid ""
">>> from datetime import date\n"
">>> Weekday.from_date(date.today())\n"
"<Weekday.TUESDAY: 2>"
msgstr ""
">>> from datetime import date\n"
">>> Weekday.from_date(date.today())\n"
"<Weekday.TUESDAY: 2>"

#: ../../howto/enum.rst:112
msgid ""
"Of course, if you're reading this on some other day, you'll see that day "
"instead."
msgstr ""
"Конечно, если вы читаете это в какой-то другой день, вместо этого вы увидите "
"тот день."

#: ../../howto/enum.rst:114
msgid ""
"This :class:`!Weekday` enum is great if our variable only needs one day, but "
"what if we need several?  Maybe we're writing a function to plot chores "
"during a week, and don't want to use a :class:`list` -- we could use a "
"different type of :class:`Enum`::"
msgstr ""
"Это перечисление :class:`!Weekday` отлично подходит, если нашей переменной "
"нужен только один день, но что, если нам нужно несколько? Возможно, мы пишем "
"функцию для построения графика работы по дому в течение недели и не хотим "
"использовать :class:`list` — мы могли бы использовать другой тип :class:"
"`Enum`::"

#: ../../howto/enum.rst:119
msgid ""
">>> from enum import Flag\n"
">>> class Weekday(Flag):\n"
"...     MONDAY = 1\n"
"...     TUESDAY = 2\n"
"...     WEDNESDAY = 4\n"
"...     THURSDAY = 8\n"
"...     FRIDAY = 16\n"
"...     SATURDAY = 32\n"
"...     SUNDAY = 64"
msgstr ""
">>> from enum import Flag\n"
">>> class Weekday(Flag):\n"
"...     MONDAY = 1\n"
"...     TUESDAY = 2\n"
"...     WEDNESDAY = 4\n"
"...     THURSDAY = 8\n"
"...     FRIDAY = 16\n"
"...     SATURDAY = 32\n"
"...     SUNDAY = 64"

#: ../../howto/enum.rst:129
msgid ""
"We've changed two things: we're inherited from :class:`Flag`, and the values "
"are all powers of 2."
msgstr ""
"Мы изменили две вещи: мы унаследованы от :class:`Flag`, и все значения "
"являются степенями 2."

#: ../../howto/enum.rst:132
msgid ""
"Just like the original :class:`!Weekday` enum above, we can have a single "
"selection::"
msgstr ""
"Как и в исходном перечислении :class:`!Weekday` выше, мы можем иметь один "
"выбор::"

#: ../../howto/enum.rst:134
msgid ""
">>> first_week_day = Weekday.MONDAY\n"
">>> first_week_day\n"
"<Weekday.MONDAY: 1>"
msgstr ""
">>> first_week_day = Weekday.MONDAY\n"
">>> first_week_day\n"
"<Weekday.MONDAY: 1>"

#: ../../howto/enum.rst:138
msgid ""
"But :class:`Flag` also allows us to combine several members into a single "
"variable::"
msgstr ""
"Но :class:`Flag` также позволяет нам объединять несколько членов в одну "
"переменную::"

#: ../../howto/enum.rst:141
msgid ""
">>> weekend = Weekday.SATURDAY | Weekday.SUNDAY\n"
">>> weekend\n"
"<Weekday.SATURDAY|SUNDAY: 96>"
msgstr ""
">>> weekend = Weekday.SATURDAY | Weekday.SUNDAY\n"
">>> weekend\n"
"<Weekday.SATURDAY|SUNDAY: 96>"

#: ../../howto/enum.rst:145
msgid "You can even iterate over a :class:`Flag` variable::"
msgstr "Вы даже можете перебирать переменную :class:`Flag`::"

#: ../../howto/enum.rst:147
msgid ""
">>> for day in weekend:\n"
"...     print(day)\n"
"Weekday.SATURDAY\n"
"Weekday.SUNDAY"
msgstr ""
">>> for day in weekend:\n"
"...     print(day)\n"
"Weekday.SATURDAY\n"
"Weekday.SUNDAY"

#: ../../howto/enum.rst:152
msgid "Okay, let's get some chores set up::"
msgstr "Ладно, давайте настроим кое-какие дела::"

#: ../../howto/enum.rst:154
msgid ""
">>> chores_for_ethan = {\n"
"...     'feed the cat': Weekday.MONDAY | Weekday.WEDNESDAY | Weekday."
"FRIDAY,\n"
"...     'do the dishes': Weekday.TUESDAY | Weekday.THURSDAY,\n"
"...     'answer SO questions': Weekday.SATURDAY,\n"
"...     }"
msgstr ""
">>> chores_for_ethan = {\n"
"...     'feed the cat': Weekday.MONDAY | Weekday.WEDNESDAY | Weekday."
"FRIDAY,\n"
"...     'do the dishes': Weekday.TUESDAY | Weekday.THURSDAY,\n"
"...     'answer SO questions': Weekday.SATURDAY,\n"
"...     }"

#: ../../howto/enum.rst:160
msgid "And a function to display the chores for a given day::"
msgstr "И функция для отображения дел на данный день:"

#: ../../howto/enum.rst:162
msgid ""
">>> def show_chores(chores, day):\n"
"...     for chore, days in chores.items():\n"
"...         if day in days:\n"
"...             print(chore)\n"
"...\n"
">>> show_chores(chores_for_ethan, Weekday.SATURDAY)\n"
"answer SO questions"
msgstr ""
">>> def show_chores(chores, day):\n"
"...     for chore, days in chores.items():\n"
"...         if day in days:\n"
"...             print(chore)\n"
"...\n"
">>> show_chores(chores_for_ethan, Weekday.SATURDAY)\n"
"answer SO questions"

#: ../../howto/enum.rst:170
msgid ""
"In cases where the actual values of the members do not matter, you can save "
"yourself some work and use :func:`auto` for the values::"
msgstr ""
"В случаях, когда фактические значения членов не имеют значения, вы можете "
"сэкономить немного времени и использовать :func:`auto` для значений::"

#: ../../howto/enum.rst:173
msgid ""
">>> from enum import auto\n"
">>> class Weekday(Flag):\n"
"...     MONDAY = auto()\n"
"...     TUESDAY = auto()\n"
"...     WEDNESDAY = auto()\n"
"...     THURSDAY = auto()\n"
"...     FRIDAY = auto()\n"
"...     SATURDAY = auto()\n"
"...     SUNDAY = auto()\n"
"...     WEEKEND = SATURDAY | SUNDAY"
msgstr ""
">>> from enum import auto\n"
">>> class Weekday(Flag):\n"
"...     MONDAY = auto()\n"
"...     TUESDAY = auto()\n"
"...     WEDNESDAY = auto()\n"
"...     THURSDAY = auto()\n"
"...     FRIDAY = auto()\n"
"...     SATURDAY = auto()\n"
"...     SUNDAY = auto()\n"
"...     WEEKEND = SATURDAY | SUNDAY"

#: ../../howto/enum.rst:189
msgid "Programmatic access to enumeration members and their attributes"
msgstr "Программный доступ к членам перечисления и их атрибутам"

#: ../../howto/enum.rst:191
msgid ""
"Sometimes it's useful to access members in enumerations programmatically (i."
"e. situations where ``Color.RED`` won't do because the exact color is not "
"known at program-writing time).  ``Enum`` allows such access::"
msgstr ""
"Иногда полезно программно обращаться к членам перечислений (например, в "
"ситуациях, когда ``Color.RED`` не подойдет, поскольку точный цвет неизвестен "
"во время написания программы). ``Enum`` разрешает такой доступ::"

#: ../../howto/enum.rst:195
msgid ""
">>> Color(1)\n"
"<Color.RED: 1>\n"
">>> Color(3)\n"
"<Color.BLUE: 3>"
msgstr ""
">>> Color(1)\n"
"<Color.RED: 1>\n"
">>> Color(3)\n"
"<Color.BLUE: 3>"

#: ../../howto/enum.rst:200
msgid "If you want to access enum members by *name*, use item access::"
msgstr ""
"Если вы хотите получить доступ к членам перечисления по *имени*, используйте "
"доступ к элементу::"

#: ../../howto/enum.rst:202
msgid ""
">>> Color['RED']\n"
"<Color.RED: 1>\n"
">>> Color['GREEN']\n"
"<Color.GREEN: 2>"
msgstr ""
">>> Color['RED']\n"
"<Color.RED: 1>\n"
">>> Color['GREEN']\n"
"<Color.GREEN: 2>"

#: ../../howto/enum.rst:207
msgid ""
"If you have an enum member and need its :attr:`!name` or :attr:`!value`::"
msgstr ""
"Если у вас есть член перечисления и вам нужен его :attr:`!name` или :attr:`!"
"value`::"

#: ../../howto/enum.rst:209
msgid ""
">>> member = Color.RED\n"
">>> member.name\n"
"'RED'\n"
">>> member.value\n"
"1"
msgstr ""
">>> member = Color.RED\n"
">>> member.name\n"
"'RED'\n"
">>> member.value\n"
"1"

#: ../../howto/enum.rst:217
msgid "Duplicating enum members and values"
msgstr "Дублирование членов и значений перечисления"

#: ../../howto/enum.rst:219
msgid "Having two enum members with the same name is invalid::"
msgstr "Наличие двух членов перечисления с одинаковым именем недействительно::"

#: ../../howto/enum.rst:221
msgid ""
">>> class Shape(Enum):\n"
"...     SQUARE = 2\n"
"...     SQUARE = 3\n"
"...\n"
"Traceback (most recent call last):\n"
"...\n"
"TypeError: 'SQUARE' already defined as 2"
msgstr ""
">>> class Shape(Enum):\n"
"...     SQUARE = 2\n"
"...     SQUARE = 3\n"
"...\n"
"Traceback (most recent call last):\n"
"...\n"
"TypeError: 'SQUARE' already defined as 2"

#: ../../howto/enum.rst:229
msgid ""
"However, an enum member can have other names associated with it.  Given two "
"entries ``A`` and ``B`` with the same value (and ``A`` defined first), ``B`` "
"is an alias for the member ``A``.  By-value lookup of the value of ``A`` "
"will return the member ``A``.  By-name lookup of ``A`` will return the "
"member ``A``. By-name lookup of ``B`` will also return the member ``A``::"
msgstr ""
"Однако член перечисления может иметь другие имена, связанные с ним. Учитывая "
"две записи ``A`` и ``B`` с одинаковым значением (и ``A`` определено первым), "
"``B`` является псевдонимом для элемента ``A``. Поиск по значению значения "
"``A`` вернет элемент ``A``. Поиск по имени ``A`` вернет член ``A``. Поиск по "
"имени ``B`` также вернет член ``A``::"

#: ../../howto/enum.rst:235
msgid ""
">>> class Shape(Enum):\n"
"...     SQUARE = 2\n"
"...     DIAMOND = 1\n"
"...     CIRCLE = 3\n"
"...     ALIAS_FOR_SQUARE = 2\n"
"...\n"
">>> Shape.SQUARE\n"
"<Shape.SQUARE: 2>\n"
">>> Shape.ALIAS_FOR_SQUARE\n"
"<Shape.SQUARE: 2>\n"
">>> Shape(2)\n"
"<Shape.SQUARE: 2>"
msgstr ""
">>> class Shape(Enum):\n"
"...     SQUARE = 2\n"
"...     DIAMOND = 1\n"
"...     CIRCLE = 3\n"
"...     ALIAS_FOR_SQUARE = 2\n"
"...\n"
">>> Shape.SQUARE\n"
"<Shape.SQUARE: 2>\n"
">>> Shape.ALIAS_FOR_SQUARE\n"
"<Shape.SQUARE: 2>\n"
">>> Shape(2)\n"
"<Shape.SQUARE: 2>"

#: ../../howto/enum.rst:250
msgid ""
"Attempting to create a member with the same name as an already defined "
"attribute (another member, a method, etc.) or attempting to create an "
"attribute with the same name as a member is not allowed."
msgstr ""
"Попытка создать член с тем же именем, что и уже определенный атрибут (другой "
"член, метод и т. д.), или попытка создать атрибут с тем же именем, что и "
"член, не допускается."

#: ../../howto/enum.rst:256
msgid "Ensuring unique enumeration values"
msgstr "Обеспечение уникальных значений перечисления"

#: ../../howto/enum.rst:258
msgid ""
"By default, enumerations allow multiple names as aliases for the same value. "
"When this behavior isn't desired, you can use the :func:`unique` decorator::"
msgstr ""
"По умолчанию перечисления допускают использование нескольких имен в качестве "
"псевдонимов для одного и того же значения. Если такое поведение "
"нежелательно, вы можете использовать декоратор :func:`unique`::"

#: ../../howto/enum.rst:261
msgid ""
">>> from enum import Enum, unique\n"
">>> @unique\n"
"... class Mistake(Enum):\n"
"...     ONE = 1\n"
"...     TWO = 2\n"
"...     THREE = 3\n"
"...     FOUR = 3\n"
"...\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: duplicate values found in <enum 'Mistake'>: FOUR -> THREE"
msgstr ""
">>> from enum import Enum, unique\n"
">>> @unique\n"
"... class Mistake(Enum):\n"
"...     ONE = 1\n"
"...     TWO = 2\n"
"...     THREE = 3\n"
"...     FOUR = 3\n"
"...\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: duplicate values found in <enum 'Mistake'>: FOUR -> THREE"

#: ../../howto/enum.rst:275
msgid "Using automatic values"
msgstr "Использование автоматических значений"

#: ../../howto/enum.rst:277
msgid "If the exact value is unimportant you can use :class:`auto`::"
msgstr ""
"Если точное значение не имеет значения, вы можете использовать :class:"
"`auto`::"

#: ../../howto/enum.rst:279
msgid ""
">>> from enum import Enum, auto\n"
">>> class Color(Enum):\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...\n"
">>> [member.value for member in Color]\n"
"[1, 2, 3]"
msgstr ""
">>> from enum import Enum, auto\n"
">>> class Color(Enum):\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...\n"
">>> [member.value for member in Color]\n"
"[1, 2, 3]"

#: ../../howto/enum.rst:288
msgid ""
"The values are chosen by :func:`~Enum._generate_next_value_`, which can be "
"overridden::"
msgstr ""
"Значения выбираются с помощью :func:`~Enum._generate_next_value_`, который "
"можно переопределить::"

#: ../../howto/enum.rst:291
msgid ""
">>> class AutoName(Enum):\n"
"...     @staticmethod\n"
"...     def _generate_next_value_(name, start, count, last_values):\n"
"...         return name\n"
"...\n"
">>> class Ordinal(AutoName):\n"
"...     NORTH = auto()\n"
"...     SOUTH = auto()\n"
"...     EAST = auto()\n"
"...     WEST = auto()\n"
"...\n"
">>> [member.value for member in Ordinal]\n"
"['NORTH', 'SOUTH', 'EAST', 'WEST']"
msgstr ""
">>> class AutoName(Enum):\n"
"...     @staticmethod\n"
"...     def _generate_next_value_(name, start, count, last_values):\n"
"...         return name\n"
"...\n"
">>> class Ordinal(AutoName):\n"
"...     NORTH = auto()\n"
"...     SOUTH = auto()\n"
"...     EAST = auto()\n"
"...     WEST = auto()\n"
"...\n"
">>> [member.value for member in Ordinal]\n"
"['NORTH', 'SOUTH', 'EAST', 'WEST']"

#: ../../howto/enum.rst:307
msgid ""
"The :meth:`~Enum._generate_next_value_` method must be defined before any "
"members."
msgstr ""
"Метод :meth:`~Enum._generate_next_value_` должен быть определен перед любыми "
"членами."

#: ../../howto/enum.rst:310
msgid "Iteration"
msgstr "Итерация"

#: ../../howto/enum.rst:312
msgid "Iterating over the members of an enum does not provide the aliases::"
msgstr "Перебор членов перечисления не предоставляет псевдонимы::"

#: ../../howto/enum.rst:314
msgid ""
">>> list(Shape)\n"
"[<Shape.SQUARE: 2>, <Shape.DIAMOND: 1>, <Shape.CIRCLE: 3>]\n"
">>> list(Weekday)\n"
"[<Weekday.MONDAY: 1>, <Weekday.TUESDAY: 2>, <Weekday.WEDNESDAY: 4>, <Weekday."
"THURSDAY: 8>, <Weekday.FRIDAY: 16>, <Weekday.SATURDAY: 32>, <Weekday.SUNDAY: "
"64>]"
msgstr ""
">>> list(Shape)\n"
"[<Shape.SQUARE: 2>, <Shape.DIAMOND: 1>, <Shape.CIRCLE: 3>]\n"
">>> list(Weekday)\n"
"[<Weekday.MONDAY: 1>, <Weekday.TUESDAY: 2>, <Weekday.WEDNESDAY: 4>, <Weekday."
"THURSDAY: 8>, <Weekday.FRIDAY: 16>, <Weekday.SATURDAY: 32>, <Weekday.SUNDAY: "
"64>]"

#: ../../howto/enum.rst:319
msgid ""
"Note that the aliases ``Shape.ALIAS_FOR_SQUARE`` and ``Weekday.WEEKEND`` "
"aren't shown."
msgstr ""
"Обратите внимание, что псевдонимы Shape.ALIAS_FOR_SQUARE и Weekday.WEEKEND "
"не отображаются."

#: ../../howto/enum.rst:321
msgid ""
"The special attribute ``__members__`` is a read-only ordered mapping of "
"names to members.  It includes all names defined in the enumeration, "
"including the aliases::"
msgstr ""
"Специальный атрибут ``__members__`` представляет собой упорядоченное "
"сопоставление имен с членами, доступное только для чтения. Он включает в "
"себя все имена, определенные в перечислении, включая псевдонимы::"

#: ../../howto/enum.rst:325
msgid ""
">>> for name, member in Shape.__members__.items():\n"
"...     name, member\n"
"...\n"
"('SQUARE', <Shape.SQUARE: 2>)\n"
"('DIAMOND', <Shape.DIAMOND: 1>)\n"
"('CIRCLE', <Shape.CIRCLE: 3>)\n"
"('ALIAS_FOR_SQUARE', <Shape.SQUARE: 2>)"
msgstr ""
">>> for name, member in Shape.__members__.items():\n"
"...     name, member\n"
"...\n"
"('SQUARE', <Shape.SQUARE: 2>)\n"
"('DIAMOND', <Shape.DIAMOND: 1>)\n"
"('CIRCLE', <Shape.CIRCLE: 3>)\n"
"('ALIAS_FOR_SQUARE', <Shape.SQUARE: 2>)"

#: ../../howto/enum.rst:333
msgid ""
"The ``__members__`` attribute can be used for detailed programmatic access "
"to the enumeration members.  For example, finding all the aliases::"
msgstr ""
"Атрибут ``__members__`` может использоваться для подробного программного "
"доступа к членам перечисления. Например, поиск всех псевдонимов::"

#: ../../howto/enum.rst:336
msgid ""
">>> [name for name, member in Shape.__members__.items() if member.name != "
"name]\n"
"['ALIAS_FOR_SQUARE']"
msgstr ""
">>> [name for name, member in Shape.__members__.items() if member.name != "
"name]\n"
"['ALIAS_FOR_SQUARE']"

#: ../../howto/enum.rst:341
msgid ""
"Aliases for flags include values with multiple flags set, such as ``3``, and "
"no flags set, i.e. ``0``."
msgstr ""
"Псевдонимы для флагов включают значения с несколькими установленными "
"флагами, например «3», и без установленных флагов, то есть «0»."

#: ../../howto/enum.rst:346
msgid "Comparisons"
msgstr "Сравнения"

#: ../../howto/enum.rst:348
msgid "Enumeration members are compared by identity::"
msgstr "Члены перечисления сравниваются по идентичности::"

#: ../../howto/enum.rst:350
msgid ""
">>> Color.RED is Color.RED\n"
"True\n"
">>> Color.RED is Color.BLUE\n"
"False\n"
">>> Color.RED is not Color.BLUE\n"
"True"
msgstr ""
">>> Color.RED is Color.RED\n"
"True\n"
">>> Color.RED is Color.BLUE\n"
"False\n"
">>> Color.RED is not Color.BLUE\n"
"True"

#: ../../howto/enum.rst:357
msgid ""
"Ordered comparisons between enumeration values are *not* supported.  Enum "
"members are not integers (but see `IntEnum`_ below)::"
msgstr ""
"Упорядоченные сравнения между значениями перечисления *не* поддерживаются. "
"Члены перечисления не являются целыми числами (но см. `IntEnum`_ ниже)::"

#: ../../howto/enum.rst:360
msgid ""
">>> Color.RED < Color.BLUE\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: '<' not supported between instances of 'Color' and 'Color'"
msgstr ""
">>> Color.RED < Color.BLUE\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: '<' not supported between instances of 'Color' and 'Color'"

#: ../../howto/enum.rst:365
msgid "Equality comparisons are defined though::"
msgstr "Однако сравнения равенства определены::"

#: ../../howto/enum.rst:367
msgid ""
">>> Color.BLUE == Color.RED\n"
"False\n"
">>> Color.BLUE != Color.RED\n"
"True\n"
">>> Color.BLUE == Color.BLUE\n"
"True"
msgstr ""
">>> Color.BLUE == Color.RED\n"
"False\n"
">>> Color.BLUE != Color.RED\n"
"True\n"
">>> Color.BLUE == Color.BLUE\n"
"True"

#: ../../howto/enum.rst:374
msgid ""
"Comparisons against non-enumeration values will always compare not equal "
"(again, :class:`IntEnum` was explicitly designed to behave differently, see "
"below)::"
msgstr "Однако сравнения равенства определены::"

#: ../../howto/enum.rst:378
msgid ""
">>> Color.BLUE == 2\n"
"False"
msgstr ""
">>> Color.BLUE == 2\n"
"False"

#: ../../howto/enum.rst:383
msgid ""
"It is possible to reload modules -- if a reloaded module contains enums, "
"they will be recreated, and the new members may not compare identical/equal "
"to the original members."
msgstr ""
"Модули можно перезагрузить — если перезагружаемый модуль содержит "
"перечисления, они будут созданы заново, и новые члены не смогут сравниваться "
"идентичными/равными исходным элементам."

#: ../../howto/enum.rst:388
msgid "Allowed members and attributes of enumerations"
msgstr "Разрешенные члены и атрибуты перечислений"

#: ../../howto/enum.rst:390
msgid ""
"Most of the examples above use integers for enumeration values.  Using "
"integers is short and handy (and provided by default by the `Functional "
"API`_), but not strictly enforced.  In the vast majority of use-cases, one "
"doesn't care what the actual value of an enumeration is.  But if the value "
"*is* important, enumerations can have arbitrary values."
msgstr ""
"В большинстве приведенных выше примеров в качестве значений перечисления "
"используются целые числа. Использование целых чисел коротко и удобно (и "
"предоставляется по умолчанию в `Functional API`_), но не является строго "
"обязательным. В подавляющем большинстве случаев использования неважно, "
"каково фактическое значение перечисления. Но если значение *важно*, "
"перечисления могут иметь произвольные значения."

#: ../../howto/enum.rst:396
msgid ""
"Enumerations are Python classes, and can have methods and special methods as "
"usual.  If we have this enumeration::"
msgstr ""
"Перечисления представляют собой классы Python и, как обычно, могут иметь "
"методы и специальные методы. Если у нас есть это перечисление::"

#: ../../howto/enum.rst:399
msgid ""
">>> class Mood(Enum):\n"
"...     FUNKY = 1\n"
"...     HAPPY = 3\n"
"...\n"
"...     def describe(self):\n"
"...         # self is the member here\n"
"...         return self.name, self.value\n"
"...\n"
"...     def __str__(self):\n"
"...         return 'my custom str! {0}'.format(self.value)\n"
"...\n"
"...     @classmethod\n"
"...     def favorite_mood(cls):\n"
"...         # cls here is the enumeration\n"
"...         return cls.HAPPY\n"
"..."
msgstr ""
">>> class Mood(Enum):\n"
"...     FUNKY = 1\n"
"...     HAPPY = 3\n"
"...\n"
"...     def describe(self):\n"
"...         # self is the member here\n"
"...         return self.name, self.value\n"
"...\n"
"...     def __str__(self):\n"
"...         return 'my custom str! {0}'.format(self.value)\n"
"...\n"
"...     @classmethod\n"
"...     def favorite_mood(cls):\n"
"...         # cls here is the enumeration\n"
"...         return cls.HAPPY\n"
"..."

#: ../../howto/enum.rst:416
msgid "Then::"
msgstr "Затем::"

#: ../../howto/enum.rst:418
msgid ""
">>> Mood.favorite_mood()\n"
"<Mood.HAPPY: 3>\n"
">>> Mood.HAPPY.describe()\n"
"('HAPPY', 3)\n"
">>> str(Mood.FUNKY)\n"
"'my custom str! 1'"
msgstr ""
">>> Mood.favorite_mood()\n"
"<Mood.HAPPY: 3>\n"
">>> Mood.HAPPY.describe()\n"
"('HAPPY', 3)\n"
">>> str(Mood.FUNKY)\n"
"'my custom str! 1'"

#: ../../howto/enum.rst:425
msgid ""
"The rules for what is allowed are as follows: names that start and end with "
"a single underscore are reserved by enum and cannot be used; all other "
"attributes defined within an enumeration will become members of this "
"enumeration, with the exception of special methods (:meth:`~object."
"__str__`, :meth:`~object.__add__`, etc.), descriptors (methods are also "
"descriptors), and variable names listed in :attr:`~Enum._ignore_`."
msgstr ""
"Правила разрешенного использования следующие: имена, которые начинаются и "
"заканчиваются одним подчеркиванием, зарезервированы перечислением и не могут "
"использоваться; все остальные атрибуты, определенные в перечислении, станут "
"членами этого перечисления, за исключением специальных методов (:meth:"
"`~object.__str__`, :meth:`~object.__add__` и т. д.), дескрипторов (методы "
"также дескрипторы) и имена переменных, перечисленные в :attr:`~Enum."
"_ignore_`."

#: ../../howto/enum.rst:432
msgid ""
"Note:  if your enumeration defines :meth:`~object.__new__` and/or :meth:"
"`~object.__init__`, any value(s) given to the enum member will be passed "
"into those methods. See `Planet`_ for an example."
msgstr ""
"Примечание. Если ваше перечисление определяет :meth:`~object.__new__` и/или :"
"meth:`~object.__init__`, любые значения, переданные члену перечисления, "
"будут переданы в эти методы. См. пример в `Planet`_."

#: ../../howto/enum.rst:438
msgid ""
"The :meth:`~object.__new__` method, if defined, is used during creation of "
"the Enum members; it is then replaced by Enum's :meth:`~object.__new__` "
"which is used after class creation for lookup of existing members.  See :ref:"
"`new-vs-init` for more details."
msgstr ""
"Метод :meth:`~object.__new__`, если он определен, используется во время "
"создания членов Enum; затем он заменяется :meth:`~object.__new__` из Enum, "
"который используется после создания класса для поиска существующих членов. "
"Дополнительную информацию см. в :ref:`new-vs-init`."

#: ../../howto/enum.rst:445
msgid "Restricted Enum subclassing"
msgstr "Ограниченное подклассирование Enum"

#: ../../howto/enum.rst:447
msgid ""
"A new :class:`Enum` class must have one base enum class, up to one concrete "
"data type, and as many :class:`object`-based mixin classes as needed.  The "
"order of these base classes is::"
msgstr ""
"Новый класс :class:`Enum` должен иметь один базовый класс перечисления, до "
"одного конкретного типа данных и столько примесей на основе :class:`object`, "
"сколько необходимо. Порядок этих базовых классов следующий:"

#: ../../howto/enum.rst:451
msgid ""
"class EnumName([mix-in, ...,] [data-type,] base-enum):\n"
"    pass"
msgstr ""
"class EnumName([примесь, ...,] [тип-данных,] базовое-перечисление): проходить"

#: ../../howto/enum.rst:454
msgid ""
"Also, subclassing an enumeration is allowed only if the enumeration does not "
"define any members.  So this is forbidden::"
msgstr ""
"Кроме того, создание подкласса перечисления разрешено только в том случае, "
"если перечисление не определяет никаких членов. Так это запрещено::"

#: ../../howto/enum.rst:457
msgid ""
">>> class MoreColor(Color):\n"
"...     PINK = 17\n"
"...\n"
"Traceback (most recent call last):\n"
"...\n"
"TypeError: <enum 'MoreColor'> cannot extend <enum 'Color'>"
msgstr ""
">>> class MoreColor(Color):\n"
"...     PINK = 17\n"
"...\n"
"Traceback (most recent call last):\n"
"...\n"
"TypeError: <enum 'MoreColor'> cannot extend <enum 'Color'>"

#: ../../howto/enum.rst:464
msgid "But this is allowed::"
msgstr "Но это разрешено::"

#: ../../howto/enum.rst:466
msgid ""
">>> class Foo(Enum):\n"
"...     def some_behavior(self):\n"
"...         pass\n"
"...\n"
">>> class Bar(Foo):\n"
"...     HAPPY = 1\n"
"...     SAD = 2\n"
"..."
msgstr ""
">>> class Foo(Enum):\n"
"...     def some_behavior(self):\n"
"...         pass\n"
"...\n"
">>> class Bar(Foo):\n"
"...     HAPPY = 1\n"
"...     SAD = 2\n"
"..."

#: ../../howto/enum.rst:475
msgid ""
"Allowing subclassing of enums that define members would lead to a violation "
"of some important invariants of types and instances.  On the other hand, it "
"makes sense to allow sharing some common behavior between a group of "
"enumerations. (See `OrderedEnum`_ for an example.)"
msgstr ""
"Разрешение подклассификации перечислений, определяющих элементы, приведет к "
"нарушению некоторых важных инвариантов типов и экземпляров. С другой "
"стороны, имеет смысл разрешить совместное использование некоторого общего "
"поведения для группы перечислений. (Пример смотрите в `OrderedEnum`_)."

#: ../../howto/enum.rst:484
msgid "Dataclass support"
msgstr "Поддержка классов данных"

#: ../../howto/enum.rst:486
msgid ""
"When inheriting from a :class:`~dataclasses.dataclass`, the :meth:`~Enum."
"__repr__` omits the inherited class' name.  For example::"
msgstr ""
"При наследовании от :class:`~dataclasses.dataclass` :meth:`~Enum.__repr__` "
"опускает имя унаследованного класса. Например::"

#: ../../howto/enum.rst:489
msgid ""
">>> from dataclasses import dataclass, field\n"
">>> @dataclass\n"
"... class CreatureDataMixin:\n"
"...     size: str\n"
"...     legs: int\n"
"...     tail: bool = field(repr=False, default=True)\n"
"...\n"
">>> class Creature(CreatureDataMixin, Enum):\n"
"...     BEETLE = 'small', 6\n"
"...     DOG = 'medium', 4\n"
"...\n"
">>> Creature.DOG\n"
"<Creature.DOG: size='medium', legs=4>"
msgstr ""
">>> from dataclasses import dataclass, field\n"
">>> @dataclass\n"
"... class CreatureDataMixin:\n"
"...     size: str\n"
"...     legs: int\n"
"...     tail: bool = field(repr=False, default=True)\n"
"...\n"
">>> class Creature(CreatureDataMixin, Enum):\n"
"...     BEETLE = 'small', 6\n"
"...     DOG = 'medium', 4\n"
"...\n"
">>> Creature.DOG\n"
"<Creature.DOG: size='medium', legs=4>"

#: ../../howto/enum.rst:503
msgid ""
"Use the :func:`!dataclass` argument ``repr=False`` to use the standard :func:"
"`repr`."
msgstr ""
"Используйте аргумент :func:`!dataclass` ``repr=False``, чтобы использовать "
"стандартный :func:`repr`."

#: ../../howto/enum.rst:506
msgid ""
"Only the dataclass fields are shown in the value area, not the dataclass' "
"name."
msgstr ""
"В области значений отображаются только поля класса данных, а не имя класса "
"данных."

#: ../../howto/enum.rst:512
msgid "Pickling"
msgstr "Сериализация"

#: ../../howto/enum.rst:514
msgid "Enumerations can be pickled and unpickled::"
msgstr "Перечисления могут быть сериализованными и десериализованными::"

#: ../../howto/enum.rst:516
msgid ""
">>> from test.test_enum import Fruit\n"
">>> from pickle import dumps, loads\n"
">>> Fruit.TOMATO is loads(dumps(Fruit.TOMATO))\n"
"True"
msgstr ""
">>> from test.test_enum import Fruit\n"
">>> from pickle import dumps, loads\n"
">>> Fruit.TOMATO is loads(dumps(Fruit.TOMATO))\n"
"True"

#: ../../howto/enum.rst:521
msgid ""
"The usual restrictions for pickling apply: picklable enums must be defined "
"in the top level of a module, since unpickling requires them to be "
"importable from that module."
msgstr ""
"Применяются обычные ограничения на травление: пикируемые перечисления должны "
"быть определены на верхнем уровне модуля, поскольку для распаковки "
"требуется, чтобы их можно было импортировать из этого модуля."

#: ../../howto/enum.rst:527
msgid ""
"With pickle protocol version 4 it is possible to easily pickle enums nested "
"in other classes."
msgstr ""
"С протоколом Pickle версии 4 можно легко выбирать перечисления, вложенные в "
"другие классы."

#: ../../howto/enum.rst:530
msgid ""
"It is possible to modify how enum members are pickled/unpickled by defining :"
"meth:`~object.__reduce_ex__` in the enumeration class.  The default method "
"is by-value, but enums with complicated values may want to use by-name::"
msgstr ""
"Можно изменить способ консервирования/расконсервации членов перечисления, "
"определив :meth:`~object.__reduce_ex__` в классе перечисления. По умолчанию "
"используется метод по значению, но перечисления со сложными значениями могут "
"использовать метод по имени::"

#: ../../howto/enum.rst:534
msgid ""
">>> import enum\n"
">>> class MyEnum(enum.Enum):\n"
"...     __reduce_ex__ = enum.pickle_by_enum_name"
msgstr ""
">>> import enum\n"
">>> class MyEnum(enum.Enum):\n"
"...     __reduce_ex__ = enum.pickle_by_enum_name"

#: ../../howto/enum.rst:540
msgid ""
"Using by-name for flags is not recommended, as unnamed aliases will not "
"unpickle."
msgstr ""
"Использование для флагов по имени не рекомендуется, так как безымянные "
"псевдонимы не будут распакованы."

#: ../../howto/enum.rst:545
msgid "Functional API"
msgstr "функциональный API"

#: ../../howto/enum.rst:547
msgid ""
"The :class:`Enum` class is callable, providing the following functional API::"
msgstr ""
"Класс :class:`Enum` является вызываемым и предоставляет следующий "
"функциональный API:"

#: ../../howto/enum.rst:549
msgid ""
">>> Animal = Enum('Animal', 'ANT BEE CAT DOG')\n"
">>> Animal\n"
"<enum 'Animal'>\n"
">>> Animal.ANT\n"
"<Animal.ANT: 1>\n"
">>> list(Animal)\n"
"[<Animal.ANT: 1>, <Animal.BEE: 2>, <Animal.CAT: 3>, <Animal.DOG: 4>]"
msgstr ""
">>> Animal = Enum('Animal', 'ANT BEE CAT DOG')\n"
">>> Animal\n"
"<enum 'Animal'>\n"
">>> Animal.ANT\n"
"<Animal.ANT: 1>\n"
">>> list(Animal)\n"
"[<Animal.ANT: 1>, <Animal.BEE: 2>, <Animal.CAT: 3>, <Animal.DOG: 4>]"

#: ../../howto/enum.rst:557
msgid ""
"The semantics of this API resemble :class:`~collections.namedtuple`. The "
"first argument of the call to :class:`Enum` is the name of the enumeration."
msgstr ""
"Семантика этого API напоминает :class:`~collections.namedtuple`. Первый "
"аргумент вызова :class:`Enum` — это имя перечисления."

#: ../../howto/enum.rst:560
msgid ""
"The second argument is the *source* of enumeration member names.  It can be "
"a whitespace-separated string of names, a sequence of names, a sequence of 2-"
"tuples with key/value pairs, or a mapping (e.g. dictionary) of names to "
"values.  The last two options enable assigning arbitrary values to "
"enumerations; the others auto-assign increasing integers starting with 1 "
"(use the ``start`` parameter to specify a different starting value).  A new "
"class derived from :class:`Enum` is returned.  In other words, the above "
"assignment to :class:`!Animal` is equivalent to::"
msgstr ""
"Второй аргумент — это *источник* имен членов перечисления. Это может быть "
"строка имен, разделенных пробелами, последовательность имен, "
"последовательность двух кортежей с парами ключ/значение или сопоставление "
"(например, словарь) имен со значениями. Последние две опции позволяют "
"присваивать перечислениям произвольные значения; остальные автоматически "
"назначают возрастающие целые числа, начиная с 1 (используйте параметр start, "
"чтобы указать другое начальное значение). Возвращается новый класс, "
"производный от :class:`Enum`. Другими словами, приведенное выше присвоение :"
"class:`!Animal` эквивалентно::"

#: ../../howto/enum.rst:569
msgid ""
">>> class Animal(Enum):\n"
"...     ANT = 1\n"
"...     BEE = 2\n"
"...     CAT = 3\n"
"...     DOG = 4\n"
"..."
msgstr ""
">>> class Animal(Enum):\n"
"...     ANT = 1\n"
"...     BEE = 2\n"
"...     CAT = 3\n"
"...     DOG = 4\n"
"..."

#: ../../howto/enum.rst:576
msgid ""
"The reason for defaulting to ``1`` as the starting number and not ``0`` is "
"that ``0`` is ``False`` in a boolean sense, but by default enum members all "
"evaluate to ``True``."
msgstr ""
"Причина установки по умолчанию «1» в качестве начального числа, а не «0», "
"заключается в том, что «0» является «False» в логическом смысле, но по "
"умолчанию все члены перечисления оцениваются как «True». ``."

#: ../../howto/enum.rst:580
msgid ""
"Pickling enums created with the functional API can be tricky as frame stack "
"implementation details are used to try and figure out which module the "
"enumeration is being created in (e.g. it will fail if you use a utility "
"function in a separate module, and also may not work on IronPython or "
"Jython). The solution is to specify the module name explicitly as follows::"
msgstr ""
"Выборка перечислений, созданных с помощью функционального API, может быть "
"сложной задачей, поскольку детали реализации стека кадров используются для "
"того, чтобы попытаться выяснить, в каком модуле создается перечисление "
"(например, оно завершится неудачей, если вы используете служебную функцию в "
"отдельном модуле, а также может не получиться). работать на IronPython или "
"Jython). Решение состоит в том, чтобы явно указать имя модуля следующим "
"образом:"

#: ../../howto/enum.rst:586
msgid ">>> Animal = Enum('Animal', 'ANT BEE CAT DOG', module=__name__)"
msgstr ">>> Animal = Enum('Animal', 'ANT BEE CAT DOG', module=__name__)"

#: ../../howto/enum.rst:590
msgid ""
"If ``module`` is not supplied, and Enum cannot determine what it is, the new "
"Enum members will not be unpicklable; to keep errors closer to the source, "
"pickling will be disabled."
msgstr ""
"Если ``module`` не указан и Enum не может определить, что это такое, новые "
"члены Enum не будут недоступны для выбора; чтобы ошибки оставались ближе к "
"источнику, травление будет отключено."

#: ../../howto/enum.rst:594
msgid ""
"The new pickle protocol 4 also, in some circumstances, relies on :attr:"
"`~type.__qualname__` being set to the location where pickle will be able to "
"find the class.  For example, if the class was made available in class "
"SomeData in the global scope::"
msgstr ""
"Новый протокол Pickle 4 также в некоторых случаях опирается на то, что :attr:"
"`~type.__qualname__` устанавливается в место, где Pickle сможет найти класс. "
"Например, если класс был доступен в классе SomeData в глобальной области "
"видимости:"

#: ../../howto/enum.rst:599
msgid ""
">>> Animal = Enum('Animal', 'ANT BEE CAT DOG', qualname='SomeData.Animal')"
msgstr ""
">>> Animal = Enum('Animal', 'ANT BEE CAT DOG', qualname='SomeData.Animal')"

#: ../../howto/enum.rst:601
msgid "The complete signature is::"
msgstr "Полная подпись выглядит следующим образом::"

#: ../../howto/enum.rst:603
msgid ""
"Enum(\n"
"    value='NewEnumName',\n"
"    names=<...>,\n"
"    *,\n"
"    module='...',\n"
"    qualname='...',\n"
"    type=<mixed-in class>,\n"
"    start=1,\n"
"    )"
msgstr ""
"Enum(\n"
"    value='NewEnumName',\n"
"    names=<...>,\n"
"    *,\n"
"    module='...',\n"
"    qualname='...',\n"
"    type=<mixed-in class>,\n"
"    start=1,\n"
"    )"

#: ../../howto/enum.rst:613
msgid "*value*: What the new enum class will record as its name."
msgstr ""
"*значение*: то, что новый класс перечисления запишет в качестве своего имени."

#: ../../howto/enum.rst:615
msgid ""
"*names*: The enum members.  This can be a whitespace- or comma-separated "
"string (values will start at 1 unless otherwise specified)::"
msgstr ""
"*имена*: члены перечисления. Это может быть строка, разделенная пробелами "
"или запятыми (значения начинаются с 1, если не указано иное)::"

#: ../../howto/enum.rst:618
msgid "'RED GREEN BLUE' | 'RED,GREEN,BLUE' | 'RED, GREEN, BLUE'"
msgstr "'RED GREEN BLUE' | 'RED,GREEN,BLUE' | 'RED, GREEN, BLUE'"

#: ../../howto/enum.rst:620
msgid "or an iterator of names::"
msgstr "или итератор имен::"

#: ../../howto/enum.rst:622
msgid "['RED', 'GREEN', 'BLUE']"
msgstr "['RED', 'GREEN', 'BLUE']"

#: ../../howto/enum.rst:624
msgid "or an iterator of (name, value) pairs::"
msgstr "или итератор пар (имя, значение)::"

#: ../../howto/enum.rst:626
msgid "[('CYAN', 4), ('MAGENTA', 5), ('YELLOW', 6)]"
msgstr "[('CYAN', 4), ('MAGENTA', 5), ('YELLOW', 6)]"

#: ../../howto/enum.rst:628
msgid "or a mapping::"
msgstr "или отображение::"

#: ../../howto/enum.rst:630
msgid "{'CHARTREUSE': 7, 'SEA_GREEN': 11, 'ROSEMARY': 42}"
msgstr "{'CHARTREUSE': 7, 'SEA_GREEN': 11, 'ROSEMARY': 42}"

#: ../../howto/enum.rst:632
msgid "*module*: name of module where new enum class can be found."
msgstr "*модуль*: имя модуля, в котором можно найти новый класс перечисления."

#: ../../howto/enum.rst:634
msgid "*qualname*: where in module new enum class can be found."
msgstr "*qualname*: где в модуле можно найти новый класс перечисления."

#: ../../howto/enum.rst:636
msgid "*type*: type to mix in to new enum class."
msgstr "*type*: тип для добавления в новый класс перечисления."

#: ../../howto/enum.rst:638
msgid "*start*: number to start counting at if only names are passed in."
msgstr ""
"*start*: номер, с которого начинается отсчет, если переданы только имена."

#: ../../howto/enum.rst:640
msgid "The *start* parameter was added."
msgstr "Добавлен параметр *start*."

#: ../../howto/enum.rst:645
msgid "Derived Enumerations"
msgstr "Производные перечисления"

#: ../../howto/enum.rst:648
msgid "IntEnum"
msgstr "IntEnum"

#: ../../howto/enum.rst:650
msgid ""
"The first variation of :class:`Enum` that is provided is also a subclass of :"
"class:`int`.  Members of an :class:`IntEnum` can be compared to integers; by "
"extension, integer enumerations of different types can also be compared to "
"each other::"
msgstr ""
"Первый предоставленный вариант :class:`Enum` также является подклассом :"
"class:`int`. Члены :class:`IntEnum` можно сравнивать с целыми числами; в "
"более широком смысле, целочисленные перечисления разных типов также можно "
"сравнивать друг с другом:"

#: ../../howto/enum.rst:655
msgid ""
">>> from enum import IntEnum\n"
">>> class Shape(IntEnum):\n"
"...     CIRCLE = 1\n"
"...     SQUARE = 2\n"
"...\n"
">>> class Request(IntEnum):\n"
"...     POST = 1\n"
"...     GET = 2\n"
"...\n"
">>> Shape == 1\n"
"False\n"
">>> Shape.CIRCLE == 1\n"
"True\n"
">>> Shape.CIRCLE == Request.POST\n"
"True"
msgstr ""
">>> from enum import IntEnum\n"
">>> class Shape(IntEnum):\n"
"...     CIRCLE = 1\n"
"...     SQUARE = 2\n"
"...\n"
">>> class Request(IntEnum):\n"
"...     POST = 1\n"
"...     GET = 2\n"
"...\n"
">>> Shape == 1\n"
"False\n"
">>> Shape.CIRCLE == 1\n"
"True\n"
">>> Shape.CIRCLE == Request.POST\n"
"True"

#: ../../howto/enum.rst:671
msgid ""
"However, they still can't be compared to standard :class:`Enum` "
"enumerations::"
msgstr ""
"Однако их по-прежнему нельзя сравнивать со стандартными перечислениями :"
"class:`Enum`::"

#: ../../howto/enum.rst:673
msgid ""
">>> class Shape(IntEnum):\n"
"...     CIRCLE = 1\n"
"...     SQUARE = 2\n"
"...\n"
">>> class Color(Enum):\n"
"...     RED = 1\n"
"...     GREEN = 2\n"
"...\n"
">>> Shape.CIRCLE == Color.RED\n"
"False"
msgstr ""
">>> class Shape(IntEnum):\n"
"...     CIRCLE = 1\n"
"...     SQUARE = 2\n"
"...\n"
">>> class Color(Enum):\n"
"...     RED = 1\n"
"...     GREEN = 2\n"
"...\n"
">>> Shape.CIRCLE == Color.RED\n"
"False"

#: ../../howto/enum.rst:684
msgid ""
":class:`IntEnum` values behave like integers in other ways you'd expect::"
msgstr ""
"Значения :class:`IntEnum` ведут себя как целые числа другими способами, "
"которые вы ожидаете::"

#: ../../howto/enum.rst:686
msgid ""
">>> int(Shape.CIRCLE)\n"
"1\n"
">>> ['a', 'b', 'c'][Shape.CIRCLE]\n"
"'b'\n"
">>> [i for i in range(Shape.SQUARE)]\n"
"[0, 1]"
msgstr ""
">>> int(Shape.CIRCLE)\n"
"1\n"
">>> ['a', 'b', 'c'][Shape.CIRCLE]\n"
"'b'\n"
">>> [i for i in range(Shape.SQUARE)]\n"
"[0, 1]"

#: ../../howto/enum.rst:695
msgid "StrEnum"
msgstr "StrEnum"

#: ../../howto/enum.rst:697
msgid ""
"The second variation of :class:`Enum` that is provided is also a subclass "
"of :class:`str`.  Members of a :class:`StrEnum` can be compared to strings; "
"by extension, string enumerations of different types can also be compared to "
"each other."
msgstr ""
"Второй предоставленный вариант :class:`Enum` также является подклассом :"
"class:`str`. Члены :class:`StrEnum` можно сравнивать со строками; в более "
"широком смысле, перечисления строк разных типов также можно сравнивать друг "
"с другом."

#: ../../howto/enum.rst:706
msgid "IntFlag"
msgstr "IntFlag"

#: ../../howto/enum.rst:708
msgid ""
"The next variation of :class:`Enum` provided, :class:`IntFlag`, is also "
"based on :class:`int`.  The difference being :class:`IntFlag` members can be "
"combined using the bitwise operators (&, \\|, ^, ~) and the result is still "
"an :class:`IntFlag` member, if possible.  Like :class:`IntEnum`, :class:"
"`IntFlag` members are also integers and can be used wherever an :class:`int` "
"is used."
msgstr ""
"Следующий вариант :class:`Enum`, :class:`IntFlag`, также основан на :class:"
"`int`. Разница в том, что члены :class:`IntFlag` можно комбинировать с "
"помощью побитовых операторов (&, \\|, ^, ~), и результатом по-прежнему будет "
"член :class:`IntFlag`, если это возможно. Как и :class:`IntEnum`, члены :"
"class:`IntFlag` также являются целыми числами и могут использоваться везде, "
"где используется :class:`int`."

#: ../../howto/enum.rst:716
msgid ""
"Any operation on an :class:`IntFlag` member besides the bit-wise operations "
"will lose the :class:`IntFlag` membership."
msgstr ""
"Любая операция над элементом :class:`IntFlag`, кроме побитовых операций, "
"потеряет членство в :class:`IntFlag`."

#: ../../howto/enum.rst:719
msgid ""
"Bit-wise operations that result in invalid :class:`IntFlag` values will lose "
"the :class:`IntFlag` membership.  See :class:`FlagBoundary` for details."
msgstr ""
"Побитовые операции, которые приводят к недопустимым значениям :class:"
"`IntFlag`, теряют членство в :class:`IntFlag`. Подробности смотрите в :class:"
"`FlagBoundary`."

#: ../../howto/enum.rst:726
msgid "Sample :class:`IntFlag` class::"
msgstr "Образец класса :class:`IntFlag`::"

#: ../../howto/enum.rst:728
msgid ""
">>> from enum import IntFlag\n"
">>> class Perm(IntFlag):\n"
"...     R = 4\n"
"...     W = 2\n"
"...     X = 1\n"
"...\n"
">>> Perm.R | Perm.W\n"
"<Perm.R|W: 6>\n"
">>> Perm.R + Perm.W\n"
"6\n"
">>> RW = Perm.R | Perm.W\n"
">>> Perm.R in RW\n"
"True"
msgstr ""
">>> from enum import IntFlag\n"
">>> class Perm(IntFlag):\n"
"...     R = 4\n"
"...     W = 2\n"
"...     X = 1\n"
"...\n"
">>> Perm.R | Perm.W\n"
"<Perm.R|W: 6>\n"
">>> Perm.R + Perm.W\n"
"6\n"
">>> RW = Perm.R | Perm.W\n"
">>> Perm.R in RW\n"
"True"

#: ../../howto/enum.rst:742
msgid "It is also possible to name the combinations::"
msgstr "Также можно назвать комбинации:"

#: ../../howto/enum.rst:744
msgid ""
">>> class Perm(IntFlag):\n"
"...     R = 4\n"
"...     W = 2\n"
"...     X = 1\n"
"...     RWX = 7\n"
"...\n"
">>> Perm.RWX\n"
"<Perm.RWX: 7>\n"
">>> ~Perm.RWX\n"
"<Perm: 0>\n"
">>> Perm(7)\n"
"<Perm.RWX: 7>"
msgstr ""
">>> class Perm(IntFlag):\n"
"...     R = 4\n"
"...     W = 2\n"
"...     X = 1\n"
"...     RWX = 7\n"
"...\n"
">>> Perm.RWX\n"
"<Perm.RWX: 7>\n"
">>> ~Perm.RWX\n"
"<Perm: 0>\n"
">>> Perm(7)\n"
"<Perm.RWX: 7>"

#: ../../howto/enum.rst:759
msgid ""
"Named combinations are considered aliases.  Aliases do not show up during "
"iteration, but can be returned from by-value lookups."
msgstr ""
"Именованные комбинации считаются псевдонимами. Псевдонимы не отображаются во "
"время итерации, но могут быть возвращены при поиске по значению."

#: ../../howto/enum.rst:764
msgid ""
"Another important difference between :class:`IntFlag` and :class:`Enum` is "
"that if no flags are set (the value is 0), its boolean evaluation is :data:"
"`False`::"
msgstr ""
"Еще одно важное различие между :class:`IntFlag` и :class:`Enum` заключается "
"в том, что если флаги не установлены (значение равно 0), его логическое "
"значение равно :data:`False`::"

#: ../../howto/enum.rst:767
msgid ""
">>> Perm.R & Perm.X\n"
"<Perm: 0>\n"
">>> bool(Perm.R & Perm.X)\n"
"False"
msgstr ""
">>> Perm.R & Perm.X\n"
"<Perm: 0>\n"
">>> bool(Perm.R & Perm.X)\n"
"False"

#: ../../howto/enum.rst:772
msgid ""
"Because :class:`IntFlag` members are also subclasses of :class:`int` they "
"can be combined with them (but may lose :class:`IntFlag` membership::"
msgstr ""
"Поскольку члены :class:`IntFlag` также являются подклассами :class:`int`, их "
"можно комбинировать с ними (но они могут потерять членство в :class:"
"`IntFlag`::"

#: ../../howto/enum.rst:775
msgid ""
">>> Perm.X | 4\n"
"<Perm.R|X: 5>\n"
"\n"
">>> Perm.X + 8\n"
"9"
msgstr ""
">>> Perm.X | 4\n"
"<Perm.R|X: 5>\n"
"\n"
">>> Perm.X + 8\n"
"9"

#: ../../howto/enum.rst:783
msgid ""
"The negation operator, ``~``, always returns an :class:`IntFlag` member with "
"a positive value::"
msgstr ""
"Оператор отрицания ``~`` всегда возвращает член :class:`IntFlag` с "
"положительным значением::"

#: ../../howto/enum.rst:786
msgid ""
">>> (~Perm.X).value == (Perm.R|Perm.W).value == 6\n"
"True"
msgstr ""
">>> (~Perm.X).value == (Perm.R|Perm.W).value == 6\n"
"True"

#: ../../howto/enum.rst:789
msgid ":class:`IntFlag` members can also be iterated over::"
msgstr "Члены :class:`IntFlag` также можно перебирать::"

#: ../../howto/enum.rst:791
msgid ""
">>> list(RW)\n"
"[<Perm.R: 4>, <Perm.W: 2>]"
msgstr ""
">>> list(RW)\n"
"[<Perm.R: 4>, <Perm.W: 2>]"

#: ../../howto/enum.rst:798
msgid "Flag"
msgstr "Флаг"

#: ../../howto/enum.rst:800
msgid ""
"The last variation is :class:`Flag`.  Like :class:`IntFlag`, :class:`Flag` "
"members can be combined using the bitwise operators (&, \\|, ^, ~).  Unlike :"
"class:`IntFlag`, they cannot be combined with, nor compared against, any "
"other :class:`Flag` enumeration, nor :class:`int`.  While it is possible to "
"specify the values directly it is recommended to use :class:`auto` as the "
"value and let :class:`Flag` select an appropriate value."
msgstr ""
"Последний вариант — :class:`Flag`. Как и :class:`IntFlag`, члены :class:"
"`Flag` можно комбинировать с помощью побитовых операторов (&, \\|, ^, ~). В "
"отличие от :class:`IntFlag`, их нельзя комбинировать или сравнивать с любым "
"другим перечислением :class:`Flag` или :class:`int`. Хотя можно указать "
"значения напрямую, рекомендуется использовать :class:`auto` в качестве "
"значения и позволить :class:`Flag` выбрать подходящее значение."

#: ../../howto/enum.rst:809
msgid ""
"Like :class:`IntFlag`, if a combination of :class:`Flag` members results in "
"no flags being set, the boolean evaluation is :data:`False`::"
msgstr ""
"Как и :class:`IntFlag`, если комбинация членов :class:`Flag` приводит к "
"тому, что флаги не устанавливаются, логическая оценка будет :data:`False`::"

#: ../../howto/enum.rst:812
msgid ""
">>> from enum import Flag, auto\n"
">>> class Color(Flag):\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...\n"
">>> Color.RED & Color.GREEN\n"
"<Color: 0>\n"
">>> bool(Color.RED & Color.GREEN)\n"
"False"
msgstr ""
">>> from enum import Flag, auto\n"
">>> class Color(Flag):\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...\n"
">>> Color.RED & Color.GREEN\n"
"<Color: 0>\n"
">>> bool(Color.RED & Color.GREEN)\n"
"False"

#: ../../howto/enum.rst:823
msgid ""
"Individual flags should have values that are powers of two (1, 2, 4, "
"8, ...), while combinations of flags will not::"
msgstr ""
"Отдельные флаги должны иметь значения, являющиеся степенью двойки (1, 2, 4, "
"8, ...), тогда как комбинации флагов не будут:"

#: ../../howto/enum.rst:826
msgid ""
">>> class Color(Flag):\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...     WHITE = RED | BLUE | GREEN\n"
"...\n"
">>> Color.WHITE\n"
"<Color.WHITE: 7>"
msgstr ""
">>> class Color(Flag):\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...     WHITE = RED | BLUE | GREEN\n"
"...\n"
">>> Color.WHITE\n"
"<Color.WHITE: 7>"

#: ../../howto/enum.rst:835
msgid ""
"Giving a name to the \"no flags set\" condition does not change its boolean "
"value::"
msgstr ""
"Присвоение имени условию «флаги не установлены» не меняет его логическое "
"значение::"

#: ../../howto/enum.rst:838
msgid ""
">>> class Color(Flag):\n"
"...     BLACK = 0\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...\n"
">>> Color.BLACK\n"
"<Color.BLACK: 0>\n"
">>> bool(Color.BLACK)\n"
"False"
msgstr ""
">>> class Color(Flag):\n"
"...     BLACK = 0\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...\n"
">>> Color.BLACK\n"
"<Color.BLACK: 0>\n"
">>> bool(Color.BLACK)\n"
"False"

#: ../../howto/enum.rst:849
msgid ":class:`Flag` members can also be iterated over::"
msgstr "Члены :class:`Flag` также можно перебирать::"

#: ../../howto/enum.rst:851
msgid ""
">>> purple = Color.RED | Color.BLUE\n"
">>> list(purple)\n"
"[<Color.RED: 1>, <Color.BLUE: 2>]"
msgstr ""
">>> purple = Color.RED | Color.BLUE\n"
">>> list(purple)\n"
"[<Color.RED: 1>, <Color.BLUE: 2>]"

#: ../../howto/enum.rst:859
msgid ""
"For the majority of new code, :class:`Enum` and :class:`Flag` are strongly "
"recommended, since :class:`IntEnum` and :class:`IntFlag` break some semantic "
"promises of an enumeration (by being comparable to integers, and thus by "
"transitivity to other unrelated enumerations).  :class:`IntEnum` and :class:"
"`IntFlag` should be used only in cases where :class:`Enum` and :class:`Flag` "
"will not do; for example, when integer constants are replaced with "
"enumerations, or for interoperability with other systems."
msgstr ""
"Для большинства нового кода настоятельно рекомендуется использовать :class:"
"`Enum` и :class:`Flag`, поскольку :class:`IntEnum` и :class:`IntFlag` "
"нарушают некоторые семантические обещания перечисления (поскольку они "
"сравнимы с целые числа и, следовательно, транзитивностью к другим "
"несвязанным перечислениям). :class:`IntEnum` и :class:`IntFlag` следует "
"использовать только в тех случаях, когда :class:`Enum` и :class:`Flag` не "
"подходят; например, когда целочисленные константы заменяются перечислениями "
"или для совместимости с другими системами."

#: ../../howto/enum.rst:869
msgid "Others"
msgstr "Другие"

#: ../../howto/enum.rst:871
msgid ""
"While :class:`IntEnum` is part of the :mod:`enum` module, it would be very "
"simple to implement independently::"
msgstr ""
"Хотя :class:`IntEnum` является частью модуля :mod:`enum`, его было бы очень "
"просто реализовать независимо::"

#: ../../howto/enum.rst:874
msgid ""
"class IntEnum(int, Enum):\n"
"    pass"
msgstr ""
"class IntEnum(int, Enum):\n"
"    pass"

#: ../../howto/enum.rst:877
msgid ""
"This demonstrates how similar derived enumerations can be defined; for "
"example a :class:`!FloatEnum` that mixes in :class:`float` instead of :class:"
"`int`."
msgstr ""
"Это демонстрирует, как могут быть определены похожие производные "
"перечисления; например :class:`!FloatEnum`, который смешивается с :class:"
"`float` вместо :class:`int`."

#: ../../howto/enum.rst:880
msgid "Some rules:"
msgstr "Некоторые правила:"

#: ../../howto/enum.rst:882
msgid ""
"When subclassing :class:`Enum`, mix-in types must appear before :class:"
"`Enum` itself in the sequence of bases, as in the :class:`IntEnum` example "
"above."
msgstr ""
"При создании подкласса :class:`Enum` смешанные типы должны появляться перед "
"самим :class:`Enum` в последовательности оснований, как в примере :class:"
"`IntEnum` выше."

#: ../../howto/enum.rst:885
msgid ""
"Mix-in types must be subclassable. For example, :class:`bool` and :class:"
"`range` are not subclassable and will throw an error during Enum creation if "
"used as the mix-in type."
msgstr ""
"Типы примесей должны быть подклассами. Например, :class:`bool` и :class:"
"`range` не являются подклассами и выдадут ошибку во время создания Enum, "
"если они используются в качестве подкласса."

#: ../../howto/enum.rst:888
msgid ""
"While :class:`Enum` can have members of any type, once you mix in an "
"additional type, all the members must have values of that type, e.g. :class:"
"`int` above.  This restriction does not apply to mix-ins which only add "
"methods and don't specify another type."
msgstr ""
"Хотя :class:`Enum` может иметь члены любого типа, после добавления "
"дополнительного типа все члены должны иметь значения этого типа, например :"
"class:`int` выше. Это ограничение не распространяется на примеси, которые "
"только добавляют методы и не указывают другой тип."

#: ../../howto/enum.rst:892
msgid ""
"When another data type is mixed in, the :attr:`~Enum.value` attribute is "
"*not the same* as the enum member itself, although it is equivalent and will "
"compare equal."
msgstr ""
"Когда добавляется другой тип данных, атрибут :attr:`~Enum.value` *не "
"совпадает* с самим элементом перечисления, хотя он эквивалентен и будет "
"сравниваться равным."

#: ../../howto/enum.rst:895
msgid ""
"A ``data type`` is a mixin that defines :meth:`~object.__new__`, or a :class:"
"`~dataclasses.dataclass`"
msgstr ""
"``Тип данных`` — это примесь, определяющая :meth:`~object.__new__` или :"
"class:`~dataclasses.dataclass`"

#: ../../howto/enum.rst:897
msgid ""
"%-style formatting:  ``%s`` and ``%r`` call the :class:`Enum` class's :meth:"
"`~object.__str__` and :meth:`~object.__repr__` respectively; other codes "
"(such as ``%i`` or ``%h`` for IntEnum) treat the enum member as its mixed-in "
"type."
msgstr ""
"%-s столько форматирования: `` %s `` и ``%r`` вызывают классы :class:`Enum` :"
"meth:`~object.__str__` и :meth:`~object.__repr__` соответственно; другие "
"коды (например, `` %я `` или ``%h`` для IntEnum) рассматривают член "
"перечисления как смешанный тип."

#: ../../howto/enum.rst:900
msgid ""
":ref:`Formatted string literals <f-strings>`, :meth:`str.format`, and :func:"
"`format` will use the enum's :meth:`~object.__str__` method."
msgstr ""
":ref:`Форматированные строковые литералы <f-strings>`, :meth:`str.format` и :"
"func:`format` будут использовать метод :meth:`~object.__str__` перечисления."

#: ../../howto/enum.rst:905
msgid ""
"Because :class:`IntEnum`, :class:`IntFlag`, and :class:`StrEnum` are "
"designed to be drop-in replacements for existing constants, their :meth:"
"`~object.__str__` method has been reset to their data types' :meth:`~object."
"__str__` method."
msgstr ""
"Поскольку :class:`IntEnum`, :class:`IntFlag` и :class:`StrEnum` "
"предназначены для замены существующих констант, их метод :meth:`~object."
"__str__` был сброшен до их значения. типы данных' :meth:`~object.__str__`."

#: ../../howto/enum.rst:913
msgid "When to use :meth:`~object.__new__` vs. :meth:`~object.__init__`"
msgstr ""
"Когда использовать :meth:`~object.__new__` вместо :meth:`~object.__init__`"

#: ../../howto/enum.rst:915
msgid ""
":meth:`~object.__new__` must be used whenever you want to customize the "
"actual value of the :class:`Enum` member.  Any other modifications may go in "
"either :meth:`~object.__new__` or :meth:`~object.__init__`, with :meth:"
"`~object.__init__` being preferred."
msgstr ""
":meth:`~object.__new__` необходимо использовать всякий раз, когда вы хотите "
"настроить фактическое значение члена :class:`Enum`. Любые другие модификации "
"могут входить либо в :meth:`~object.__new__`, либо в :meth:`~object."
"__init__`, причем предпочтительным является :meth:`~object.__init__`."

#: ../../howto/enum.rst:919
msgid ""
"For example, if you want to pass several items to the constructor, but only "
"want one of them to be the value::"
msgstr ""
"Например, если вы хотите передать в конструктор несколько элементов, но "
"хотите, чтобы только один из них был значением:"

#: ../../howto/enum.rst:922
msgid ""
">>> class Coordinate(bytes, Enum):\n"
"...     \"\"\"\n"
"...     Coordinate with binary codes that can be indexed by the int code.\n"
"...     \"\"\"\n"
"...     def __new__(cls, value, label, unit):\n"
"...         obj = bytes.__new__(cls, [value])\n"
"...         obj._value_ = value\n"
"...         obj.label = label\n"
"...         obj.unit = unit\n"
"...         return obj\n"
"...     PX = (0, 'P.X', 'km')\n"
"...     PY = (1, 'P.Y', 'km')\n"
"...     VX = (2, 'V.X', 'km/s')\n"
"...     VY = (3, 'V.Y', 'km/s')\n"
"...\n"
"\n"
">>> print(Coordinate['PY'])\n"
"Coordinate.PY\n"
"\n"
">>> print(Coordinate(3))\n"
"Coordinate.VY"
msgstr ""
">>> class Coordinate(bytes, Enum):\n"
"...     \"\"\"\n"
"...     Coordinate with binary codes that can be indexed by the int code.\n"
"...     \"\"\"\n"
"...     def __new__(cls, value, label, unit):\n"
"...         obj = bytes.__new__(cls, [value])\n"
"...         obj._value_ = value\n"
"...         obj.label = label\n"
"...         obj.unit = unit\n"
"...         return obj\n"
"...     PX = (0, 'P.X', 'km')\n"
"...     PY = (1, 'P.Y', 'km')\n"
"...     VX = (2, 'V.X', 'km/s')\n"
"...     VY = (3, 'V.Y', 'km/s')\n"
"...\n"
"\n"
">>> print(Coordinate['PY'])\n"
"Coordinate.PY\n"
"\n"
">>> print(Coordinate(3))\n"
"Coordinate.VY"

#: ../../howto/enum.rst:946
msgid ""
"*Do not* call ``super().__new__()``, as the lookup-only ``__new__`` is the "
"one that is found; instead, use the data type directly."
msgstr ""
"*Не* вызывайте ``super().__new__()``, так как найден только ``__new__``, "
"предназначенный только для поиска; вместо этого используйте тип данных "
"напрямую."

#: ../../howto/enum.rst:951
msgid "Finer Points"
msgstr "Тонкости"

#: ../../howto/enum.rst:954
msgid "Supported ``__dunder__`` names"
msgstr "Поддерживаемые имена ``__dunder__`` "

#: ../../howto/enum.rst:956
msgid ""
":attr:`~enum.EnumType.__members__` is a read-only ordered mapping of "
"``member_name``:``member`` items.  It is only available on the class."
msgstr ""
":attr:`~enum.EnumType.__members__` — это упорядоченное сопоставление "
"элементов ``member_name``:``member``, доступное только для чтения. Это "
"доступно только в классе."

#: ../../howto/enum.rst:959
msgid ""
":meth:`~object.__new__`, if specified, must create and return the enum "
"members; it is also a very good idea to set the member's :attr:`~Enum."
"_value_` appropriately.  Once all the members are created it is no longer "
"used."
msgstr ""
":meth:`~object.__new__`, если он указан, должен создавать и возвращать члены "
"перечисления; Также очень хорошей идеей будет правильно установить :attr:"
"`~Enum._value_` члена. После создания всех членов он больше не используется."

#: ../../howto/enum.rst:965
msgid "Supported ``_sunder_`` names"
msgstr "Поддерживаемые имена ``_sunder_`` "

#: ../../howto/enum.rst:967
msgid ":attr:`~Enum._name_` -- name of the member"
msgstr ":attr:`~Enum._name_` -- имя члена"

#: ../../howto/enum.rst:968
msgid ""
":attr:`~Enum._value_` -- value of the member; can be set / modified in "
"``__new__``"
msgstr ""
":attr:`~Enum._value_` -- значение члена; можно установить/изменить в "
"``__new__``"

#: ../../howto/enum.rst:970
msgid ""
":meth:`~Enum._missing_` -- a lookup function used when a value is not found; "
"may be overridden"
msgstr ""
":meth:`~Enum._missing_` -- функция поиска, используемая, когда значение не "
"найдено; может быть переопределено"

#: ../../howto/enum.rst:972
msgid ""
":attr:`~Enum._ignore_` -- a list of names, either as a :class:`list` or a :"
"class:`str`, that will not be transformed into members, and will be removed "
"from the final class"
msgstr ""
":attr:`~Enum._ignore_` -- список имен в виде :class:`list` или :class:`str`, "
"который не будет преобразован в члены и будет удален из конечного класса."

#: ../../howto/enum.rst:975
msgid ""
":attr:`~Enum._order_` -- used in Python 2/3 code to ensure member order is "
"consistent (class attribute, removed during class creation)"
msgstr ""
":attr:`~Enum._order_` — используется в коде Python 2/3 для обеспечения "
"единообразия порядка членов (атрибут класса, удаленный во время создания "
"класса)"

#: ../../howto/enum.rst:977
msgid ""
":meth:`~Enum._generate_next_value_` -- used by the `Functional API`_ and by :"
"class:`auto` to get an appropriate value for an enum member; may be "
"overridden"
msgstr ""
":meth:`~Enum._generate_next_value_` -- используется `Functional API`_ и :"
"class:`auto` для получения соответствующего значения для члена перечисления; "
"может быть переопределено"

#: ../../howto/enum.rst:983
msgid ""
"For standard :class:`Enum` classes the next value chosen is the last value "
"seen incremented by one."
msgstr ""
"Для стандартных классов :class:`Enum` следующим выбранным значением является "
"последнее замеченное значение, увеличенное на единицу."

#: ../../howto/enum.rst:986
msgid ""
"For :class:`Flag` classes the next value chosen will be the next highest "
"power-of-two, regardless of the last value seen."
msgstr ""
"Для классов :class:`Flag` следующее выбранное значение будет следующей по "
"величине степенью двойки, независимо от последнего увиденного значения."

#: ../../howto/enum.rst:989
msgid "``_missing_``, ``_order_``, ``_generate_next_value_``"
msgstr "``_missing_``, ``_order_``, ``_generate_next_value_``"

#: ../../howto/enum.rst:990
msgid "``_ignore_``"
msgstr "``_ignore_``"

#: ../../howto/enum.rst:992
msgid ""
"To help keep Python 2 / Python 3 code in sync an :attr:`~Enum._order_` "
"attribute can be provided.  It will be checked against the actual order of "
"the enumeration and raise an error if the two do not match::"
msgstr ""
"Чтобы синхронизировать код Python 2/Python 3, можно предоставить атрибут :"
"attr:`~Enum._order_`. Он будет проверен на соответствие фактическому порядку "
"перечисления и выдаст ошибку, если они не совпадают:"

#: ../../howto/enum.rst:996
msgid ""
">>> class Color(Enum):\n"
"...     _order_ = 'RED GREEN BLUE'\n"
"...     RED = 1\n"
"...     BLUE = 3\n"
"...     GREEN = 2\n"
"...\n"
"Traceback (most recent call last):\n"
"...\n"
"TypeError: member order does not match _order_:\n"
"  ['RED', 'BLUE', 'GREEN']\n"
"  ['RED', 'GREEN', 'BLUE']"
msgstr ""
">>> class Color(Enum):\n"
"...     _order_ = 'RED GREEN BLUE'\n"
"...     RED = 1\n"
"...     BLUE = 3\n"
"...     GREEN = 2\n"
"...\n"
"Traceback (most recent call last):\n"
"...\n"
"TypeError: member order does not match _order_:\n"
"  ['RED', 'BLUE', 'GREEN']\n"
"  ['RED', 'GREEN', 'BLUE']"

#: ../../howto/enum.rst:1010
msgid ""
"In Python 2 code the :attr:`~Enum._order_` attribute is necessary as "
"definition order is lost before it can be recorded."
msgstr ""
"В коде Python 2 атрибут :attr:`~Enum._order_` необходим, поскольку порядок "
"определения теряется до того, как его можно будет записать."

#: ../../howto/enum.rst:1015
msgid "_Private__names"
msgstr "_Private__names"

#: ../../howto/enum.rst:1017
msgid ""
":ref:`Private names <private-name-mangling>` are not converted to enum "
"members, but remain normal attributes."
msgstr ""
":ref:`Частные имена <private-name-mangling>` не преобразуются в члены "
"перечисления, а остаются обычными атрибутами."

#: ../../howto/enum.rst:1024
msgid "``Enum`` member type"
msgstr "Тип элемента ``Enum``"

#: ../../howto/enum.rst:1026
msgid ""
"Enum members are instances of their enum class, and are normally accessed as "
"``EnumClass.member``.  In certain situations, such as writing custom enum "
"behavior, being able to access one member directly from another is useful, "
"and is supported; however, in order to avoid name clashes between member "
"names and attributes/methods from mixed-in classes, upper-case names are "
"strongly recommended."
msgstr ""
"Члены перечисления являются экземплярами своего класса перечисления и обычно "
"доступны как EnumClass.member. В определенных ситуациях, например при "
"написании пользовательского поведения перечисления, возможность доступа к "
"одному члену напрямую из другого полезна и поддерживается; однако, чтобы "
"избежать конфликтов имен между именами членов и атрибутами/методами из "
"смешанных классов, настоятельно рекомендуется использовать имена в верхнем "
"регистре."

#: ../../howto/enum.rst:1037
msgid "Creating members that are mixed with other data types"
msgstr "Создание членов, смешанных с другими типами данных"

#: ../../howto/enum.rst:1039
msgid ""
"When subclassing other data types, such as :class:`int` or :class:`str`, "
"with an :class:`Enum`, all values after the ``=`` are passed to that data "
"type's constructor.  For example::"
msgstr ""
"При создании подклассов других типов данных, таких как :class:`int` или :"
"class:`str`, с помощью :class:`Enum`, все значения после ``=`` передаются "
"конструктору этого типа данных. Например::"

#: ../../howto/enum.rst:1043
msgid ""
">>> class MyEnum(IntEnum):      # help(int) -> int(x, base=10) -> integer\n"
"...     example = '11', 16      # so x='11' and base=16\n"
"...\n"
">>> MyEnum.example.value        # and hex(11) is...\n"
"17"
msgstr ""
">>> class MyEnum(IntEnum):      # help(int) -> int(x, base=10) -> integer\n"
"...     example = '11', 16      # so x='11' and base=16\n"
"...\n"
">>> MyEnum.example.value        # and hex(11) is...\n"
"17"

#: ../../howto/enum.rst:1051
msgid "Boolean value of ``Enum`` classes and members"
msgstr "Логическое значение классов и членов Enum"

#: ../../howto/enum.rst:1053
msgid ""
"Enum classes that are mixed with non-:class:`Enum` types (such as :class:"
"`int`, :class:`str`, etc.) are evaluated according to the mixed-in type's "
"rules; otherwise, all members evaluate as :data:`True`.  To make your own "
"enum's boolean evaluation depend on the member's value add the following to "
"your class::"
msgstr ""
"Классы перечислений, смешанные с типами, отличными от :class:`Enum` (такими "
"как :class:`int`, :class:`str` и т. д.), оцениваются в соответствии с "
"правилами смешанного типа; в противном случае все члены оцениваются как :"
"data:`True`. Чтобы логическая оценка вашего собственного перечисления "
"зависела от значения члена, добавьте в свой класс следующее:"

#: ../../howto/enum.rst:1059
msgid ""
"def __bool__(self):\n"
"    return bool(self.value)"
msgstr ""
"def __bool__(self):\n"
"    return bool(self.value)"

#: ../../howto/enum.rst:1062
msgid "Plain :class:`Enum` classes always evaluate as :data:`True`."
msgstr "Обычные классы :class:`Enum` всегда оцениваются как :data:`True`."

#: ../../howto/enum.rst:1066
msgid "``Enum`` classes with methods"
msgstr "Классы ``Enum`` с методами"

#: ../../howto/enum.rst:1068
msgid ""
"If you give your enum subclass extra methods, like the `Planet`_ class "
"below, those methods will show up in a :func:`dir` of the member, but not of "
"the class::"
msgstr ""
"Если вы дадите своему подклассу перечисления дополнительные методы, такие "
"как класс `Planet`_ ниже, эти методы будут отображаться в :func:`dir` члена, "
"но не в классе::"

#: ../../howto/enum.rst:1072
msgid ""
">>> dir(Planet)\n"
"['EARTH', 'JUPITER', 'MARS', 'MERCURY', 'NEPTUNE', 'SATURN', 'URANUS', "
"'VENUS', '__class__', '__doc__', '__members__', '__module__']\n"
">>> dir(Planet.EARTH)\n"
"['__class__', '__doc__', '__module__', 'mass', 'name', 'radius', "
"'surface_gravity', 'value']"
msgstr ""
">>> dir(Planet)\n"
"['EARTH', 'JUPITER', 'MARS', 'MERCURY', 'NEPTUNE', 'SATURN', 'URANUS', "
"'VENUS', '__class__', '__doc__', '__members__', '__module__']\n"
">>> dir(Planet.EARTH)\n"
"['__class__', '__doc__', '__module__', 'mass', 'name', 'radius', "
"'surface_gravity', 'value']"

#: ../../howto/enum.rst:1079
msgid "Combining members of ``Flag``"
msgstr "Объединение членов ``Flag``"

#: ../../howto/enum.rst:1081
msgid ""
"Iterating over a combination of :class:`Flag` members will only return the "
"members that are comprised of a single bit::"
msgstr ""
"Перебор комбинации членов :class:`Flag` вернет только те члены, которые "
"состоят из одного бита::"

#: ../../howto/enum.rst:1084
msgid ""
">>> class Color(Flag):\n"
"...     RED = auto()\n"
"...     GREEN = auto()\n"
"...     BLUE = auto()\n"
"...     MAGENTA = RED | BLUE\n"
"...     YELLOW = RED | GREEN\n"
"...     CYAN = GREEN | BLUE\n"
"...\n"
">>> Color(3)  # named combination\n"
"<Color.YELLOW: 3>\n"
">>> Color(7)      # not named combination\n"
"<Color.RED|GREEN|BLUE: 7>"
msgstr ""
">>> class Color(Flag):\n"
"...     RED = auto()\n"
"...     GREEN = auto()\n"
"...     BLUE = auto()\n"
"...     MAGENTA = RED | BLUE\n"
"...     YELLOW = RED | GREEN\n"
"...     CYAN = GREEN | BLUE\n"
"...\n"
">>> Color(3)  # named combination\n"
"<Color.YELLOW: 3>\n"
">>> Color(7)      # not named combination\n"
"<Color.RED|GREEN|BLUE: 7>"

#: ../../howto/enum.rst:1099
msgid "``Flag`` and ``IntFlag`` minutia"
msgstr "``Flag`` и ``IntFlag`` мелочи"

#: ../../howto/enum.rst:1101
msgid "Using the following snippet for our examples::"
msgstr "Используя следующий фрагмент для наших примеров:"

#: ../../howto/enum.rst:1103
msgid ""
">>> class Color(IntFlag):\n"
"...     BLACK = 0\n"
"...     RED = 1\n"
"...     GREEN = 2\n"
"...     BLUE = 4\n"
"...     PURPLE = RED | BLUE\n"
"...     WHITE = RED | GREEN | BLUE\n"
"..."
msgstr ""
">>> class Color(IntFlag):\n"
"...     BLACK = 0\n"
"...     RED = 1\n"
"...     GREEN = 2\n"
"...     BLUE = 4\n"
"...     PURPLE = RED | BLUE\n"
"...     WHITE = RED | GREEN | BLUE\n"
"..."

#: ../../howto/enum.rst:1112
msgid "the following are true:"
msgstr "верно следующее:"

#: ../../howto/enum.rst:1114
msgid "single-bit flags are canonical"
msgstr "однобитовые флаги являются каноническими"

#: ../../howto/enum.rst:1115
msgid "multi-bit and zero-bit flags are aliases"
msgstr "многобитные и нуль-битные флаги являются псевдонимами"

#: ../../howto/enum.rst:1116
msgid "only canonical flags are returned during iteration::"
msgstr "во время итерации возвращаются только канонические флаги::"

#: ../../howto/enum.rst:1118
msgid ""
">>> list(Color.WHITE)\n"
"[<Color.RED: 1>, <Color.GREEN: 2>, <Color.BLUE: 4>]"
msgstr ""
">>> список(Цвет.БЕЛЫЙ) [<Цвет.КРАСНЫЙ: 1>, <Цвет.ЗЕЛЕНЫЙ: 2>, <Цвет.СИНИЙ: "
"4>]"

#: ../../howto/enum.rst:1121
msgid ""
"negating a flag or flag set returns a new flag/flag set with the "
"corresponding positive integer value::"
msgstr ""
"отрицание флага или набора флагов возвращает новый флаг/набор флагов с "
"соответствующим положительным целочисленным значением::"

#: ../../howto/enum.rst:1124
msgid ""
">>> Color.BLUE\n"
"<Color.BLUE: 4>\n"
"\n"
">>> ~Color.BLUE\n"
"<Color.RED|GREEN: 3>"
msgstr ""
">>> Цвет.СИНИЙ <Цвет.СИНИЙ: 4> >>> ~Цвет.СИНИЙ <Цвет.КРАСНЫЙ|ЗЕЛЕНЫЙ: 3>"

#: ../../howto/enum.rst:1130
msgid "names of pseudo-flags are constructed from their members' names::"
msgstr "имена псевдофлагов создаются из имен их членов::"

#: ../../howto/enum.rst:1132
msgid ""
">>> (Color.RED | Color.GREEN).name\n"
"'RED|GREEN'\n"
"\n"
">>> class Perm(IntFlag):\n"
"...     R = 4\n"
"...     W = 2\n"
"...     X = 1\n"
"...\n"
">>> (Perm.R & Perm.W).name is None  # effectively Perm(0)\n"
"True"
msgstr ""
">>> (Цвет.КРАСНЫЙ | Цвет.ЗЕЛЕНЫЙ).имя 'КРАСНЫЙ|ЗЕЛЕНЫЙ' >>> класс "
"Пермь(IntFlag): ... Р = 4 ... Вт = 2 ... Х = 1 ... >>> (Perm.R и Perm.W)."
"name — None # эффективно Perm(0) Истинный"

#: ../../howto/enum.rst:1143
msgid "multi-bit flags, aka aliases, can be returned from operations::"
msgstr ""
"многобитовые флаги, также известные как псевдонимы, могут быть возвращены "
"операциями::"

#: ../../howto/enum.rst:1145
msgid ""
">>> Color.RED | Color.BLUE\n"
"<Color.PURPLE: 5>\n"
"\n"
">>> Color(7)  # or Color(-1)\n"
"<Color.WHITE: 7>\n"
"\n"
">>> Color(0)\n"
"<Color.BLACK: 0>"
msgstr ""
">>> Color.RED | Color.BLUE\n"
"<Color.PURPLE: 5>\n"
"\n"
">>> Color(7)  # or Color(-1)\n"
"<Color.WHITE: 7>\n"
"\n"
">>> Color(0)\n"
"<Color.BLACK: 0>"

#: ../../howto/enum.rst:1154
msgid ""
"membership / containment checking: zero-valued flags are always considered "
"to be contained::"
msgstr ""
"Проверка членства/включения: флаги с нулевым значением всегда считаются "
"содержащимися::"

#: ../../howto/enum.rst:1157
msgid ""
">>> Color.BLACK in Color.WHITE\n"
"True"
msgstr ">>> Цвет.ЧЕРНЫЙ в цвете.БЕЛЫЙ Истинный"

#: ../../howto/enum.rst:1160
msgid ""
"otherwise, only if all bits of one flag are in the other flag will True be "
"returned::"
msgstr ""
"в противном случае, только если все биты одного флага находятся в другом "
"флаге, будет возвращено значение True::"

#: ../../howto/enum.rst:1163
msgid ""
">>> Color.PURPLE in Color.WHITE\n"
"True\n"
"\n"
">>> Color.GREEN in Color.PURPLE\n"
"False"
msgstr ""
">>> Color.PURPLE in Color.WHITE\n"
"True\n"
"\n"
">>> Color.GREEN in Color.PURPLE\n"
"False"

#: ../../howto/enum.rst:1169
msgid ""
"There is a new boundary mechanism that controls how out-of-range / invalid "
"bits are handled: ``STRICT``, ``CONFORM``, ``EJECT``, and ``KEEP``:"
msgstr ""
"Существует новый механизм границ, который контролирует, как обрабатываются "
"биты, выходящие за пределы диапазона/недопустимые: STRICT, CONFORM, EJECT и "
"KEEP:"

#: ../../howto/enum.rst:1172
msgid "STRICT --> raises an exception when presented with invalid values"
msgstr ""
"STRICT --> вызывает исключение при представлении недопустимых значений."

#: ../../howto/enum.rst:1173
msgid "CONFORM --> discards any invalid bits"
msgstr "CONFORM --> отбрасывает все недопустимые биты."

#: ../../howto/enum.rst:1174
msgid "EJECT --> lose Flag status and become a normal int with the given value"
msgstr ""
"EJECT -> потерять статус флага и стать обычным целым числом с заданным "
"значением"

#: ../../howto/enum.rst:1175
msgid "KEEP --> keep the extra bits"
msgstr "KEEP --> сохранить лишние биты"

#: ../../howto/enum.rst:1177
msgid "keeps Flag status and extra bits"
msgstr "сохраняет статус флага и дополнительные биты"

#: ../../howto/enum.rst:1178
msgid "extra bits do not show up in iteration"
msgstr "дополнительные биты не отображаются в итерации"

#: ../../howto/enum.rst:1179
msgid "extra bits do show up in repr() and str()"
msgstr "дополнительные биты появляются в repr() и str()"

#: ../../howto/enum.rst:1181
msgid ""
"The default for Flag is ``STRICT``, the default for ``IntFlag`` is "
"``EJECT``, and the default for ``_convert_`` is ``KEEP`` (see ``ssl."
"Options`` for an example of when ``KEEP`` is needed)."
msgstr ""
"Значением по умолчанию для флага является STRICT, для IntFlag по умолчанию — "
"EJECT, а для _convert_ по умолчанию — KEEP (см. ssl.Options). для примера, "
"когда требуется ``KEEP``)."

#: ../../howto/enum.rst:1189
msgid "How are Enums and Flags different?"
msgstr "Чем отличаются перечисления и флаги?"

#: ../../howto/enum.rst:1191
msgid ""
"Enums have a custom metaclass that affects many aspects of both derived :"
"class:`Enum` classes and their instances (members)."
msgstr ""
"Перечисления имеют собственный метакласс, который влияет на многие аспекты "
"как производных классов :class:`Enum`, так и их экземпляров (членов)."

#: ../../howto/enum.rst:1196
msgid "Enum Classes"
msgstr "Классы перечисления"

#: ../../howto/enum.rst:1198
msgid ""
"The :class:`EnumType` metaclass is responsible for providing the :meth:"
"`~object.__contains__`, :meth:`~object.__dir__`, :meth:`~object.__iter__` "
"and other methods that allow one to do things with an :class:`Enum` class "
"that fail on a typical class, such as ``list(Color)`` or ``some_enum_var in "
"Color``.  :class:`EnumType` is responsible for ensuring that various other "
"methods on the final :class:`Enum` class are correct (such as :meth:`~object."
"__new__`, :meth:`~object.__getnewargs__`, :meth:`~object.__str__` and :meth:"
"`~object.__repr__`)."
msgstr ""
"Метакласс :class:`EnumType` отвечает за предоставление :meth:`~object."
"__contains__`, :meth:`~object.__dir__`, :meth:`~object.__iter__` и других "
"методов, которые позволяют делать вещи с классом :class:`Enum`, которые "
"терпят неудачу в типичном классе, таком как ``list(Color)`` "
"или``some_enum_var in Color``. :class:`EnumType` отвечает за корректность "
"различных других методов конечного класса :class:`Enum` (например, :meth:"
"`~object.__new__`, :meth:`~object.__getnewargs__`, : meth:`~object.__str__` "
"и :meth:`~object.__repr__`)."

#: ../../howto/enum.rst:1207
msgid "Flag Classes"
msgstr "Классы флагов"

#: ../../howto/enum.rst:1209
msgid ""
"Flags have an expanded view of aliasing: to be canonical, the value of a "
"flag needs to be a power-of-two value, and not a duplicate name.  So, in "
"addition to the :class:`Enum` definition of alias, a flag with no value (a.k."
"a. ``0``) or with more than one power-of-two value (e.g. ``3``) is "
"considered an alias."
msgstr ""
"Флаги имеют расширенное представление о псевдонимах: чтобы быть "
"каноническим, значение флага должно быть значением степени двойки, а не "
"повторяющимся именем. Таким образом, в дополнение к определению псевдонима "
"в :class:`Enum`, рассматривается флаг без значения (он же ``0``) или с более "
"чем одним значением степени двойки (например, ``3``). псевдоним."

#: ../../howto/enum.rst:1215
msgid "Enum Members (aka instances)"
msgstr "Члены перечисления (также известные как экземпляры)"

#: ../../howto/enum.rst:1217
msgid ""
"The most interesting thing about enum members is that they are singletons. :"
"class:`EnumType` creates them all while it is creating the enum class "
"itself, and then puts a custom :meth:`~object.__new__` in place to ensure "
"that no new ones are ever instantiated by returning only the existing member "
"instances."
msgstr ""
"Самое интересное в членах перечисления то, что они являются одиночками. :"
"class:`EnumType` создает их все во время создания самого класса "
"перечисления, а затем помещает собственный :meth:`~object.__new__`, чтобы "
"гарантировать, что никакие новые экземпляры никогда не будут созданы, "
"возвращая только существующие экземпляры членов. ."

#: ../../howto/enum.rst:1223
msgid "Flag Members"
msgstr "Пометить участников"

#: ../../howto/enum.rst:1225
msgid ""
"Flag members can be iterated over just like the :class:`Flag` class, and "
"only the canonical members will be returned.  For example::"
msgstr ""
"Члены флага можно перебирать так же, как и класс :class:`Flag`, и будут "
"возвращены только канонические члены. Например::"

#: ../../howto/enum.rst:1228
msgid ""
">>> list(Color)\n"
"[<Color.RED: 1>, <Color.GREEN: 2>, <Color.BLUE: 4>]"
msgstr ""
">>> list(Color)\n"
"[<Color.RED: 1>, <Color.GREEN: 2>, <Color.BLUE: 4>]"

#: ../../howto/enum.rst:1231
msgid "(Note that ``BLACK``, ``PURPLE``, and ``WHITE`` do not show up.)"
msgstr ""
"(Обратите внимание, что ``ЧЕРНЫЙ``, ``ФИОЛЕТОВЫЙ`` и ``БЕЛЫЙ`` не "
"отображаются.)"

#: ../../howto/enum.rst:1233
msgid ""
"Inverting a flag member returns the corresponding positive value, rather "
"than a negative value --- for example::"
msgstr ""
"Инвертирование члена-флага возвращает соответствующее положительное "
"значение, а не отрицательное, например::"

#: ../../howto/enum.rst:1236
msgid ""
">>> ~Color.RED\n"
"<Color.GREEN|BLUE: 6>"
msgstr ""
">>> ~Color.RED\n"
"<Color.GREEN|BLUE: 6>"

#: ../../howto/enum.rst:1239
msgid ""
"Flag members have a length corresponding to the number of power-of-two "
"values they contain.  For example::"
msgstr ""
"Члены флага имеют длину, соответствующую количеству содержащихся в них "
"значений степени двойки. Например::"

#: ../../howto/enum.rst:1242
msgid ""
">>> len(Color.PURPLE)\n"
"2"
msgstr ""
">>> len(Color.PURPLE)\n"
"2"

#: ../../howto/enum.rst:1249
msgid "Enum Cookbook"
msgstr "Поваренная книга перечисления"

#: ../../howto/enum.rst:1252
msgid ""
"While :class:`Enum`, :class:`IntEnum`, :class:`StrEnum`, :class:`Flag`, and :"
"class:`IntFlag` are expected to cover the majority of use-cases, they cannot "
"cover them all.  Here are recipes for some different types of enumerations "
"that can be used directly, or as examples for creating one's own."
msgstr ""
"Хотя ожидается, что :class:`Enum`, :class:`IntEnum`, :class:`StrEnum`, :"
"class:`Flag` и :class:`IntFlag` охватывают большинство случаев "
"использования, они не могут охватить торговый центр. Ниже приведены рецепты "
"некоторых различных типов перечислений, которые можно использовать напрямую "
"или в качестве примеров для создания собственных."

#: ../../howto/enum.rst:1259
msgid "Omitting values"
msgstr "Пропуск значений"

#: ../../howto/enum.rst:1261
msgid ""
"In many use-cases, one doesn't care what the actual value of an enumeration "
"is. There are several ways to define this type of simple enumeration:"
msgstr ""
"Во многих случаях использования неважно, каково фактическое значение "
"перечисления. Существует несколько способов определения этого типа простого "
"перечисления:"

#: ../../howto/enum.rst:1264
msgid "use instances of :class:`auto` for the value"
msgstr "используйте экземпляры :class:`auto` для значения"

#: ../../howto/enum.rst:1265
msgid "use instances of :class:`object` as the value"
msgstr "используйте экземпляры :class:`object` в качестве значения"

#: ../../howto/enum.rst:1266
msgid "use a descriptive string as the value"
msgstr "используйте описательную строку в качестве значения"

#: ../../howto/enum.rst:1267
msgid ""
"use a tuple as the value and a custom :meth:`~object.__new__` to replace the "
"tuple with an :class:`int` value"
msgstr ""
"используйте кортеж в качестве значения и собственный :meth:`~object."
"__new__`, чтобы заменить кортеж значением :class:`int`"

#: ../../howto/enum.rst:1270
msgid ""
"Using any of these methods signifies to the user that these values are not "
"important, and also enables one to add, remove, or reorder members without "
"having to renumber the remaining members."
msgstr ""
"Использование любого из этих методов означает для пользователя, что эти "
"значения не важны, а также позволяет добавлять, удалять или изменять порядок "
"элементов без необходимости перенумерации остальных элементов."

#: ../../howto/enum.rst:1276
msgid "Using :class:`auto`"
msgstr "Использование :class:`auto`"

#: ../../howto/enum.rst:1278
msgid "Using :class:`auto` would look like::"
msgstr "Использование :class:`auto` выглядит следующим образом::"

#: ../../howto/enum.rst:1280
msgid ""
">>> class Color(Enum):\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN: 3>"
msgstr ""
">>> class Color(Enum):\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN: 3>"

#: ../../howto/enum.rst:1290
msgid "Using :class:`object`"
msgstr "Использование :class:`object`"

#: ../../howto/enum.rst:1292
msgid "Using :class:`object` would look like::"
msgstr "Использование :class:`object` выглядит следующим образом::"

#: ../../howto/enum.rst:1294
msgid ""
">>> class Color(Enum):\n"
"...     RED = object()\n"
"...     GREEN = object()\n"
"...     BLUE = object()\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN: <object object at 0x...>>"
msgstr ""
">>> class Color(Enum):\n"
"...     RED = object()\n"
"...     GREEN = object()\n"
"...     BLUE = object()\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN: <object object at 0x...>>"

#: ../../howto/enum.rst:1302
msgid ""
"This is also a good example of why you might want to write your own :meth:"
"`~object.__repr__`::"
msgstr ""
"Это также хороший пример того, почему вам может понадобиться написать свой "
"собственный :meth:`~object.__repr__`::"

#: ../../howto/enum.rst:1305
msgid ""
">>> class Color(Enum):\n"
"...     RED = object()\n"
"...     GREEN = object()\n"
"...     BLUE = object()\n"
"...     def __repr__(self):\n"
"...         return \"<%s.%s>\" % (self.__class__.__name__, self._name_)\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN>"
msgstr ""
">>> class Color(Enum):\n"
"...     RED = object()\n"
"...     GREEN = object()\n"
"...     BLUE = object()\n"
"...     def __repr__(self):\n"
"...         return \"<%s.%s>\" % (self.__class__.__name__, self._name_)\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN>"

#: ../../howto/enum.rst:1318
msgid "Using a descriptive string"
msgstr "Использование описательной строки"

#: ../../howto/enum.rst:1320
msgid "Using a string as the value would look like::"
msgstr ""
"Использование строки в качестве значения будет выглядеть следующим образом::"

#: ../../howto/enum.rst:1322
msgid ""
">>> class Color(Enum):\n"
"...     RED = 'stop'\n"
"...     GREEN = 'go'\n"
"...     BLUE = 'too fast!'\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN: 'go'>"
msgstr ""
">>> class Color(Enum):\n"
"...     RED = 'stop'\n"
"...     GREEN = 'go'\n"
"...     BLUE = 'too fast!'\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN: 'go'>"

#: ../../howto/enum.rst:1332
msgid "Using a custom :meth:`~object.__new__`"
msgstr "Использование специального :meth:`~object.__new__`"

#: ../../howto/enum.rst:1334
msgid "Using an auto-numbering :meth:`~object.__new__` would look like::"
msgstr ""
"Использование автоматической нумерации :meth:`~object.__new__` будет "
"выглядеть так::"

#: ../../howto/enum.rst:1336
msgid ""
">>> class AutoNumber(Enum):\n"
"...     def __new__(cls):\n"
"...         value = len(cls.__members__) + 1\n"
"...         obj = object.__new__(cls)\n"
"...         obj._value_ = value\n"
"...         return obj\n"
"...\n"
">>> class Color(AutoNumber):\n"
"...     RED = ()\n"
"...     GREEN = ()\n"
"...     BLUE = ()\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN: 2>"
msgstr ""
">>> class AutoNumber(Enum):\n"
"...     def __new__(cls):\n"
"...         value = len(cls.__members__) + 1\n"
"...         obj = object.__new__(cls)\n"
"...         obj._value_ = value\n"
"...         return obj\n"
"...\n"
">>> class Color(AutoNumber):\n"
"...     RED = ()\n"
"...     GREEN = ()\n"
"...     BLUE = ()\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN: 2>"

#: ../../howto/enum.rst:1351
msgid ""
"To make a more general purpose ``AutoNumber``, add ``*args`` to the "
"signature::"
msgstr ""
"Чтобы сделать ``AutoNumber`` более общим назначением, добавьте к подписи "
"``*args``::"

#: ../../howto/enum.rst:1353
msgid ""
">>> class AutoNumber(Enum):\n"
"...     def __new__(cls, *args):      # this is the only change from above\n"
"...         value = len(cls.__members__) + 1\n"
"...         obj = object.__new__(cls)\n"
"...         obj._value_ = value\n"
"...         return obj\n"
"..."
msgstr ""
">>> class AutoNumber(Enum):\n"
"...     def __new__(cls, *args):      # this is the only change from above\n"
"...         value = len(cls.__members__) + 1\n"
"...         obj = object.__new__(cls)\n"
"...         obj._value_ = value\n"
"...         return obj\n"
"..."

#: ../../howto/enum.rst:1361
msgid ""
"Then when you inherit from ``AutoNumber`` you can write your own "
"``__init__`` to handle any extra arguments::"
msgstr ""
"Затем, когда вы наследуете от ``AutoNumber``, вы можете написать свой "
"собственный ``__init__`` для обработки любых дополнительных аргументов::"

#: ../../howto/enum.rst:1364
msgid ""
">>> class Swatch(AutoNumber):\n"
"...     def __init__(self, pantone='unknown'):\n"
"...         self.pantone = pantone\n"
"...     AUBURN = '3497'\n"
"...     SEA_GREEN = '1246'\n"
"...     BLEACHED_CORAL = () # New color, no Pantone code yet!\n"
"...\n"
">>> Swatch.SEA_GREEN\n"
"<Swatch.SEA_GREEN: 2>\n"
">>> Swatch.SEA_GREEN.pantone\n"
"'1246'\n"
">>> Swatch.BLEACHED_CORAL.pantone\n"
"'unknown'"
msgstr ""
">>> class Swatch(AutoNumber):\n"
"...     def __init__(self, pantone='unknown'):\n"
"...         self.pantone = pantone\n"
"...     AUBURN = '3497'\n"
"...     SEA_GREEN = '1246'\n"
"...     BLEACHED_CORAL = () # New color, no Pantone code yet!\n"
"...\n"
">>> Swatch.SEA_GREEN\n"
"<Swatch.SEA_GREEN: 2>\n"
">>> Swatch.SEA_GREEN.pantone\n"
"'1246'\n"
">>> Swatch.BLEACHED_CORAL.pantone\n"
"'unknown'"

#: ../../howto/enum.rst:1380
msgid ""
"The :meth:`~object.__new__` method, if defined, is used during creation of "
"the Enum members; it is then replaced by Enum's :meth:`~object.__new__` "
"which is used after class creation for lookup of existing members."
msgstr ""
"Метод :meth:`~object.__new__`, если он определен, используется во время "
"создания членов Enum; затем он заменяется :meth:`~object.__new__` из Enum, "
"который используется после создания класса для поиска существующих членов."

#: ../../howto/enum.rst:1386
msgid ""
"*Do not* call ``super().__new__()``, as the lookup-only ``__new__`` is the "
"one that is found; instead, use the data type directly -- e.g.::"
msgstr ""
"*Не* вызывайте ``super().__new__()``, так как найден только ``__new__``, "
"предназначенный только для поиска; вместо этого используйте тип данных "
"напрямую, например::"

#: ../../howto/enum.rst:1389
msgid "obj = int.__new__(cls, value)"
msgstr "obj = int.__new__(cls, value)"

#: ../../howto/enum.rst:1393
msgid "OrderedEnum"
msgstr "OrderedEnum"

#: ../../howto/enum.rst:1395
msgid ""
"An ordered enumeration that is not based on :class:`IntEnum` and so "
"maintains the normal :class:`Enum` invariants (such as not being comparable "
"to other enumerations)::"
msgstr ""
"Упорядоченное перечисление, не основанное на :class:`IntEnum` и поэтому "
"поддерживающее обычные инварианты :class:`Enum` (например, не сравнимое с "
"другими перечислениями)::"

#: ../../howto/enum.rst:1399
msgid ""
">>> class OrderedEnum(Enum):\n"
"...     def __ge__(self, other):\n"
"...         if self.__class__ is other.__class__:\n"
"...             return self.value >= other.value\n"
"...         return NotImplemented\n"
"...     def __gt__(self, other):\n"
"...         if self.__class__ is other.__class__:\n"
"...             return self.value > other.value\n"
"...         return NotImplemented\n"
"...     def __le__(self, other):\n"
"...         if self.__class__ is other.__class__:\n"
"...             return self.value <= other.value\n"
"...         return NotImplemented\n"
"...     def __lt__(self, other):\n"
"...         if self.__class__ is other.__class__:\n"
"...             return self.value < other.value\n"
"...         return NotImplemented\n"
"...\n"
">>> class Grade(OrderedEnum):\n"
"...     A = 5\n"
"...     B = 4\n"
"...     C = 3\n"
"...     D = 2\n"
"...     F = 1\n"
"...\n"
">>> Grade.C < Grade.A\n"
"True"
msgstr ""
">>> class OrderedEnum(Enum):\n"
"...     def __ge__(self, other):\n"
"...         if self.__class__ is other.__class__:\n"
"...             return self.value >= other.value\n"
"...         return NotImplemented\n"
"...     def __gt__(self, other):\n"
"...         if self.__class__ is other.__class__:\n"
"...             return self.value > other.value\n"
"...         return NotImplemented\n"
"...     def __le__(self, other):\n"
"...         if self.__class__ is other.__class__:\n"
"...             return self.value <= other.value\n"
"...         return NotImplemented\n"
"...     def __lt__(self, other):\n"
"...         if self.__class__ is other.__class__:\n"
"...             return self.value < other.value\n"
"...         return NotImplemented\n"
"...\n"
">>> class Grade(OrderedEnum):\n"
"...     A = 5\n"
"...     B = 4\n"
"...     C = 3\n"
"...     D = 2\n"
"...     F = 1\n"
"...\n"
">>> Grade.C < Grade.A\n"
"True"

#: ../../howto/enum.rst:1429
msgid "DuplicateFreeEnum"
msgstr "DuplicateFreeEnum"

#: ../../howto/enum.rst:1431
msgid ""
"Raises an error if a duplicate member value is found instead of creating an "
"alias::"
msgstr ""
"Упорядоченное перечисление, не основанное на :class:`IntEnum` и поэтому "
"поддерживающее обычные инварианты :class:`Enum` (например, не сравнимое с "
"другими перечислениями)::"

#: ../../howto/enum.rst:1434
msgid ""
">>> class DuplicateFreeEnum(Enum):\n"
"...     def __init__(self, *args):\n"
"...         cls = self.__class__\n"
"...         if any(self.value == e.value for e in cls):\n"
"...             a = self.name\n"
"...             e = cls(self.value).name\n"
"...             raise ValueError(\n"
"...                 \"aliases not allowed in DuplicateFreeEnum:  %r --> "
"%r\"\n"
"...                 % (a, e))\n"
"...\n"
">>> class Color(DuplicateFreeEnum):\n"
"...     RED = 1\n"
"...     GREEN = 2\n"
"...     BLUE = 3\n"
"...     GRENE = 2\n"
"...\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ValueError: aliases not allowed in DuplicateFreeEnum:  'GRENE' --> 'GREEN'"
msgstr ""
">>> class DuplicateFreeEnum(Enum):\n"
"...     def __init__(self, *args):\n"
"...         cls = self.__class__\n"
"...         if any(self.value == e.value for e in cls):\n"
"...             a = self.name\n"
"...             e = cls(self.value).name\n"
"...             raise ValueError(\n"
"...                 \"aliases not allowed in DuplicateFreeEnum:  %r --> "
"%r\"\n"
"...                 % (a, e))\n"
"...\n"
">>> class Color(DuplicateFreeEnum):\n"
"...     RED = 1\n"
"...     GREEN = 2\n"
"...     BLUE = 3\n"
"...     GRENE = 2\n"
"...\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ValueError: aliases not allowed in DuplicateFreeEnum:  'GRENE' --> 'GREEN'"

#: ../../howto/enum.rst:1456
msgid ""
"This is a useful example for subclassing Enum to add or change other "
"behaviors as well as disallowing aliases.  If the only desired change is "
"disallowing aliases, the :func:`unique` decorator can be used instead."
msgstr ""
"Это полезный пример создания подкласса Enum для добавления или изменения "
"другого поведения, а также запрета псевдонимов. Если единственным желаемым "
"изменением является запрет псевдонимов, вместо этого можно использовать "
"декоратор :func:`unique`."

#: ../../howto/enum.rst:1462
msgid "Planet"
msgstr "Планета"

#: ../../howto/enum.rst:1464
msgid ""
"If :meth:`~object.__new__` or :meth:`~object.__init__` is defined, the value "
"of the enum member will be passed to those methods::"
msgstr ""
"Если :meth:`~object.__new__` или :meth:`~object.__init__` определен, "
"значение члена перечисления будет передано этим методам:"

#: ../../howto/enum.rst:1467
msgid ""
">>> class Planet(Enum):\n"
"...     MERCURY = (3.303e+23, 2.4397e6)\n"
"...     VENUS   = (4.869e+24, 6.0518e6)\n"
"...     EARTH   = (5.976e+24, 6.37814e6)\n"
"...     MARS    = (6.421e+23, 3.3972e6)\n"
"...     JUPITER = (1.9e+27,   7.1492e7)\n"
"...     SATURN  = (5.688e+26, 6.0268e7)\n"
"...     URANUS  = (8.686e+25, 2.5559e7)\n"
"...     NEPTUNE = (1.024e+26, 2.4746e7)\n"
"...     def __init__(self, mass, radius):\n"
"...         self.mass = mass       # in kilograms\n"
"...         self.radius = radius   # in meters\n"
"...     @property\n"
"...     def surface_gravity(self):\n"
"...         # universal gravitational constant  (m3 kg-1 s-2)\n"
"...         G = 6.67300E-11\n"
"...         return G * self.mass / (self.radius * self.radius)\n"
"...\n"
">>> Planet.EARTH.value\n"
"(5.976e+24, 6378140.0)\n"
">>> Planet.EARTH.surface_gravity\n"
"9.802652743337129"
msgstr ""
">>> class Planet(Enum):\n"
"...     MERCURY = (3.303e+23, 2.4397e6)\n"
"...     VENUS   = (4.869e+24, 6.0518e6)\n"
"...     EARTH   = (5.976e+24, 6.37814e6)\n"
"...     MARS    = (6.421e+23, 3.3972e6)\n"
"...     JUPITER = (1.9e+27,   7.1492e7)\n"
"...     SATURN  = (5.688e+26, 6.0268e7)\n"
"...     URANUS  = (8.686e+25, 2.5559e7)\n"
"...     NEPTUNE = (1.024e+26, 2.4746e7)\n"
"...     def __init__(self, mass, radius):\n"
"...         self.mass = mass       # in kilograms\n"
"...         self.radius = radius   # in meters\n"
"...     @property\n"
"...     def surface_gravity(self):\n"
"...         # universal gravitational constant  (m3 kg-1 s-2)\n"
"...         G = 6.67300E-11\n"
"...         return G * self.mass / (self.radius * self.radius)\n"
"...\n"
">>> Planet.EARTH.value\n"
"(5.976e+24, 6378140.0)\n"
">>> Planet.EARTH.surface_gravity\n"
"9.802652743337129"

#: ../../howto/enum.rst:1493
msgid "TimePeriod"
msgstr "TimePeriod"

#: ../../howto/enum.rst:1495
msgid "An example to show the :attr:`~Enum._ignore_` attribute in use::"
msgstr "Пример использования атрибута :attr:`~Enum._ignore_`::"

#: ../../howto/enum.rst:1497
msgid ""
">>> from datetime import timedelta\n"
">>> class Period(timedelta, Enum):\n"
"...     \"different lengths of time\"\n"
"...     _ignore_ = 'Period i'\n"
"...     Period = vars()\n"
"...     for i in range(367):\n"
"...         Period['day_%d' % i] = i\n"
"...\n"
">>> list(Period)[:2]\n"
"[<Period.day_0: datetime.timedelta(0)>, <Period.day_1: datetime."
"timedelta(days=1)>]\n"
">>> list(Period)[-2:]\n"
"[<Period.day_365: datetime.timedelta(days=365)>, <Period.day_366: datetime."
"timedelta(days=366)>]"
msgstr ""
">>> from datetime import timedelta\n"
">>> class Period(timedelta, Enum):\n"
"...     \"different lengths of time\"\n"
"...     _ignore_ = 'Period i'\n"
"...     Period = vars()\n"
"...     for i in range(367):\n"
"...         Period['day_%d' % i] = i\n"
"...\n"
">>> list(Period)[:2]\n"
"[<Period.day_0: datetime.timedelta(0)>, <Period.day_1: datetime."
"timedelta(days=1)>]\n"
">>> list(Period)[-2:]\n"
"[<Period.day_365: datetime.timedelta(days=365)>, <Period.day_366: datetime."
"timedelta(days=366)>]"

#: ../../howto/enum.rst:1514
msgid "Subclassing EnumType"
msgstr "Создание подкласса EnumType"

#: ../../howto/enum.rst:1516
msgid ""
"While most enum needs can be met by customizing :class:`Enum` subclasses, "
"either with class decorators or custom functions, :class:`EnumType` can be "
"subclassed to provide a different Enum experience."
msgstr ""
"Хотя большинство потребностей перечислений можно удовлетворить путем "
"настройки подклассов :class:`Enum` либо с помощью декораторов классов, либо "
"с помощью пользовательских функций, :class:`EnumType` может быть подклассом, "
"чтобы обеспечить другое взаимодействие с Enum."
