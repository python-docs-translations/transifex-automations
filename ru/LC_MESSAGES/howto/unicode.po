# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-21 22:20+0000\n"
"PO-Revision-Date: 2023-05-24 02:11+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../howto/unicode.rst:5
msgid "Unicode HOWTO"
msgstr "Руководство по Юникоду"

#: ../../howto/unicode.rst:0
msgid "Release"
msgstr "Релиз"

#: ../../howto/unicode.rst:7
msgid "1.12"
msgstr "1.12"

#: ../../howto/unicode.rst:9
msgid ""
"This HOWTO discusses Python's support for the Unicode specification for "
"representing textual data, and explains various problems that people "
"commonly encounter when trying to work with Unicode."
msgstr ""
"В этом HOWTO обсуждается поддержка Python спецификации Unicode для "
"представления текстовых данных и объясняются различные проблемы, с которыми "
"люди обычно сталкиваются при попытке работать с Unicode."

#: ../../howto/unicode.rst:15
msgid "Introduction to Unicode"
msgstr "Введение в Юникод"

#: ../../howto/unicode.rst:18
msgid "Definitions"
msgstr "Определения"

#: ../../howto/unicode.rst:20
msgid ""
"Today's programs need to be able to handle a wide variety of characters.  "
"Applications are often internationalized to display messages and output in a "
"variety of user-selectable languages; the same program might need to output "
"an error message in English, French, Japanese, Hebrew, or Russian.  Web "
"content can be written in any of these languages and can also include a "
"variety of emoji symbols. Python's string type uses the Unicode Standard for "
"representing characters, which lets Python programs work with all these "
"different possible characters."
msgstr ""
"Сегодняшние программы должны иметь возможность обрабатывать самые "
"разнообразные символы. Приложения часто интернационализируются для "
"отображения сообщений и вывода на различных языках, выбираемых "
"пользователем; одной и той же программе может потребоваться вывести "
"сообщение об ошибке на английском, французском, японском, иврите или русском "
"языке. Веб-контент может быть написан на любом из этих языков, а также может "
"включать в себя различные символы эмодзи. Строковый тип Python использует "
"стандарт Unicode для представления символов, что позволяет программам Python "
"работать со всеми этими различными возможными символами."

#: ../../howto/unicode.rst:30
msgid ""
"Unicode (https://www.unicode.org/) is a specification that aims to list "
"every character used by human languages and give each character its own "
"unique code.  The Unicode specifications are continually revised and updated "
"to add new languages and symbols."
msgstr ""
"Unicode (https://www.unicode.org/) — это спецификация, целью которой "
"является перечисление всех символов, используемых человеческими языками, и "
"присвоение каждому символу собственного уникального кода. Спецификации "
"Unicode постоянно пересматриваются и обновляются с добавлением новых языков "
"и символов."

#: ../../howto/unicode.rst:35
msgid ""
"A **character** is the smallest possible component of a text.  'A', 'B', "
"'C', etc., are all different characters.  So are 'È' and 'Í'.  Characters "
"vary depending on the language or context you're talking about.  For "
"example, there's a character for \"Roman Numeral One\", 'Ⅰ', that's separate "
"from the uppercase letter 'I'.  They'll usually look the same, but these are "
"two different characters that have different meanings."
msgstr ""
"**Символ** – это наименьший возможный компонент текста. «А», «Б», «С» и т. "
"д. — это разные символы. То же самое относится и к «È» и «Í». Символы "
"различаются в зависимости от языка или контекста, о котором вы говорите. "
"Например, есть символ «римской цифры один», «Ⅰ», который отделен от "
"заглавной буквы «I». Обычно они выглядят одинаково, но это два разных "
"символа, имеющих разное значение."

#: ../../howto/unicode.rst:42
msgid ""
"The Unicode standard describes how characters are represented by **code "
"points**.  A code point value is an integer in the range 0 to 0x10FFFF "
"(about 1.1 million values, the `actual number assigned <https://www.unicode."
"org/versions/latest/#Summary>`_ is less than that). In the standard and in "
"this document, a code point is written using the notation ``U+265E`` to mean "
"the character with value ``0x265e`` (9,822 in decimal)."
msgstr ""
"Стандарт Unicode описывает, как символы представляются **кодовыми точками**. "
"Значение кодовой точки представляет собой целое число в диапазоне от 0 до "
"0x10FFFF (около 1,1 миллиона значений, `фактическое назначенное число "
"<https://www.unicode.org/versions/latest/#Summary>`_ меньше этого). В "
"стандарте и в этом документе кодовая точка записывается с использованием "
"обозначения U+265E, обозначая символ со значением 0x265e (9822 в десятичном "
"формате)."

#: ../../howto/unicode.rst:50
msgid ""
"The Unicode standard contains a lot of tables listing characters and their "
"corresponding code points:"
msgstr ""
"Стандарт Unicode содержит множество таблиц, в которых перечислены символы и "
"соответствующие им кодовые точки:"

#: ../../howto/unicode.rst:71
msgid ""
"Strictly, these definitions imply that it's meaningless to say 'this is "
"character ``U+265E``'.  ``U+265E`` is a code point, which represents some "
"particular character; in this case, it represents the character 'BLACK CHESS "
"KNIGHT', '♞'.  In informal contexts, this distinction between code points "
"and characters will sometimes be forgotten."
msgstr ""
"Строго говоря, эти определения подразумевают, что бессмысленно говорить: "
"«Это символ ``U+265E``'. ``U+265E`` — это кодовая точка, которая "
"представляет определенный символ; в данном случае он представляет собой "
"символ «ЧЕРНЫЙ ШАХМАТНЫЙ РЫЦАРЬ», «♞». В неформальном контексте это различие "
"между кодовыми точками и символами иногда забывается."

#: ../../howto/unicode.rst:78
msgid ""
"A character is represented on a screen or on paper by a set of graphical "
"elements that's called a **glyph**.  The glyph for an uppercase A, for "
"example, is two diagonal strokes and a horizontal stroke, though the exact "
"details will depend on the font being used.  Most Python code doesn't need "
"to worry about glyphs; figuring out the correct glyph to display is "
"generally the job of a GUI toolkit or a terminal's font renderer."
msgstr ""
"Символ представлен на экране или на бумаге набором графических элементов, "
"называемых **глифами**. Например, глиф для заглавной буквы A состоит из двух "
"диагональных штрихов и горизонтального штриха, хотя точные детали будут "
"зависеть от используемого шрифта. Большинству кода Python не нужно "
"беспокоиться о глифах; Определение правильного глифа для отображения обычно "
"является задачей набора инструментов графического интерфейса или средства "
"визуализации шрифтов терминала."

#: ../../howto/unicode.rst:87
msgid "Encodings"
msgstr "Кодирование"

#: ../../howto/unicode.rst:89
msgid ""
"To summarize the previous section: a Unicode string is a sequence of code "
"points, which are numbers from 0 through ``0x10FFFF`` (1,114,111 decimal).  "
"This sequence of code points needs to be represented in memory as a set of "
"**code units**, and **code units** are then mapped to 8-bit bytes.  The "
"rules for translating a Unicode string into a sequence of bytes are called a "
"**character encoding**, or just an **encoding**."
msgstr ""
"Подводя итог предыдущему разделу: строка Unicode представляет собой "
"последовательность кодовых точек, представляющих собой числа от 0 до "
"0x10FFFF (1 114 111 десятичных чисел). Эта последовательность кодовых точек "
"должна быть представлена ​​в памяти как набор **кодовых единиц**, а **кодовые "
"единицы** затем отображаются в 8-битные байты. Правила преобразования строки "
"Юникода в последовательность байтов называются **кодировкой символов** или "
"просто **кодировкой**."

#: ../../howto/unicode.rst:97
msgid ""
"The first encoding you might think of is using 32-bit integers as the code "
"unit, and then using the CPU's representation of 32-bit integers. In this "
"representation, the string \"Python\" might look like this:"
msgstr ""
"Первая кодировка, о которой вы можете подумать, — это использование 32-"
"битных целых чисел в качестве единицы кода, а затем использование "
"представления 32-битных целых чисел процессором. В этом представлении строка "
"«Python» может выглядеть так:"

#: ../../howto/unicode.rst:107
msgid ""
"This representation is straightforward but using it presents a number of "
"problems."
msgstr ""
"Это представление простое, но его использование сопряжено с рядом проблем."

#: ../../howto/unicode.rst:110
msgid "It's not portable; different processors order the bytes differently."
msgstr "Это не портативно; разные процессоры упорядочивают байты по-разному."

#: ../../howto/unicode.rst:112
msgid ""
"It's very wasteful of space.  In most texts, the majority of the code points "
"are less than 127, or less than 255, so a lot of space is occupied by "
"``0x00`` bytes.  The above string takes 24 bytes compared to the 6 bytes "
"needed for an ASCII representation.  Increased RAM usage doesn't matter too "
"much (desktop computers have gigabytes of RAM, and strings aren't usually "
"that large), but expanding our usage of disk and network bandwidth by a "
"factor of 4 is intolerable."
msgstr ""
"Это очень расточительно занимает пространство. В большинстве текстов "
"большинство кодовых точек меньше 127 или меньше 255, поэтому много места "
"занимают байты ``0x00``. Приведенная выше строка занимает 24 байта по "
"сравнению с 6 байтами, необходимыми для представления ASCII. Увеличение "
"использования оперативной памяти не имеет большого значения (настольные "
"компьютеры имеют гигабайты оперативной памяти, а строки обычно не такие "
"большие), но увеличение использования нами дисковой и сетевой пропускной "
"способности в 4 раза невыносимо."

#: ../../howto/unicode.rst:120
msgid ""
"It's not compatible with existing C functions such as ``strlen()``, so a new "
"family of wide string functions would need to be used."
msgstr ""
"Он несовместим с существующими функциями C, такими как strlen(), поэтому "
"необходимо использовать новое семейство функций для работы с широкими "
"строками."

#: ../../howto/unicode.rst:123
msgid ""
"Therefore this encoding isn't used very much, and people instead choose "
"other encodings that are more efficient and convenient, such as UTF-8."
msgstr ""
"Поэтому эта кодировка используется не очень часто, и вместо этого люди "
"выбирают другие, более эффективные и удобные кодировки, например UTF-8."

#: ../../howto/unicode.rst:126
msgid ""
"UTF-8 is one of the most commonly used encodings, and Python often defaults "
"to using it.  UTF stands for \"Unicode Transformation Format\", and the '8' "
"means that 8-bit values are used in the encoding.  (There are also UTF-16 "
"and UTF-32 encodings, but they are less frequently used than UTF-8.)  UTF-8 "
"uses the following rules:"
msgstr ""
"UTF-8 — одна из наиболее часто используемых кодировок, и Python часто "
"использует ее по умолчанию. UTF означает «Формат преобразования Unicode», а "
"«8» означает, что в кодировке используются 8-битные значения. (Существуют "
"также кодировки UTF-16 и UTF-32, но они используются реже, чем UTF-8.) В "
"UTF-8 используются следующие правила:"

#: ../../howto/unicode.rst:132
msgid ""
"If the code point is < 128, it's represented by the corresponding byte value."
msgstr ""
"Если кодовая точка < 128, она представлена ​​соответствующим значением байта."

#: ../../howto/unicode.rst:133
msgid ""
"If the code point is >= 128, it's turned into a sequence of two, three, or "
"four bytes, where each byte of the sequence is between 128 and 255."
msgstr ""
"Если кодовая точка >= 128, она преобразуется в последовательность из двух, "
"трех или четырех байтов, где каждый байт последовательности находится между "
"128 и 255."

#: ../../howto/unicode.rst:136
msgid "UTF-8 has several convenient properties:"
msgstr "UTF-8 имеет несколько удобных свойств:"

#: ../../howto/unicode.rst:138
msgid "It can handle any Unicode code point."
msgstr "Он может обрабатывать любую кодовую точку Unicode."

#: ../../howto/unicode.rst:139
msgid ""
"A Unicode string is turned into a sequence of bytes that contains embedded "
"zero bytes only where they represent the null character (U+0000). This means "
"that UTF-8 strings can be processed by C functions such as ``strcpy()`` and "
"sent through protocols that can't handle zero bytes for anything other than "
"end-of-string markers."
msgstr ""
"Строка Юникода преобразуется в последовательность байтов, содержащую "
"внедренные нулевые байты только там, где они представляют нулевой символ "
"(U+0000). Это означает, что строки UTF-8 могут обрабатываться функциями C, "
"такими как strcpy(), и отправляться через протоколы, которые не могут "
"обрабатывать нулевые байты для чего-либо, кроме маркеров конца строки."

#: ../../howto/unicode.rst:144
msgid "A string of ASCII text is also valid UTF-8 text."
msgstr "Строка текста ASCII также является допустимым текстом UTF-8."

#: ../../howto/unicode.rst:145
msgid ""
"UTF-8 is fairly compact; the majority of commonly used characters can be "
"represented with one or two bytes."
msgstr ""
"UTF-8 довольно компактен; большинство часто используемых символов могут быть "
"представлены одним или двумя байтами."

#: ../../howto/unicode.rst:147
msgid ""
"If bytes are corrupted or lost, it's possible to determine the start of the "
"next UTF-8-encoded code point and resynchronize.  It's also unlikely that "
"random 8-bit data will look like valid UTF-8."
msgstr ""
"Если байты повреждены или потеряны, можно определить начало следующей "
"кодовой точки в кодировке UTF-8 и выполнить повторную синхронизацию. Также "
"маловероятно, что случайные 8-битные данные будут выглядеть как "
"действительный UTF-8."

#: ../../howto/unicode.rst:150
msgid ""
"UTF-8 is a byte oriented encoding. The encoding specifies that each "
"character is represented by a specific sequence of one or more bytes. This "
"avoids the byte-ordering issues that can occur with integer and word "
"oriented encodings, like UTF-16 and UTF-32, where the sequence of bytes "
"varies depending on the hardware on which the string was encoded."
msgstr ""
"UTF-8 — это байтовая кодировка. Кодировка определяет, что каждый символ "
"представлен определенной последовательностью из одного или нескольких "
"байтов. Это позволяет избежать проблем с порядком байтов, которые могут "
"возникнуть при целочисленных и словесных кодировках, таких как UTF-16 и "
"UTF-32, где последовательность байтов варьируется в зависимости от "
"оборудования, на котором была закодирована строка."

#: ../../howto/unicode.rst:158 ../../howto/unicode.rst:514
#: ../../howto/unicode.rst:735
msgid "References"
msgstr "References"

#: ../../howto/unicode.rst:160
msgid ""
"The `Unicode Consortium site <https://www.unicode.org>`_ has character "
"charts, a glossary, and PDF versions of the Unicode specification.  Be "
"prepared for some difficult reading.  `A chronology <https://www.unicode.org/"
"history/>`_ of the origin and development of Unicode is also available on "
"the site."
msgstr ""
"На сайте Консорциума Unicode <https://www.unicode.org> имеются таблицы "
"символов, глоссарий и PDF-версии спецификации Unicode. Будьте готовы к "
"трудному чтению. `_ Хронология <https://www.unicode.org/history/>`_ "
"происхождения и развития Unicode также доступна на сайте."

#: ../../howto/unicode.rst:165
msgid ""
"On the Computerphile Youtube channel, Tom Scott briefly `discusses the "
"history of Unicode and UTF-8 <https://www.youtube.com/watch?v=MijmeoH9LT4>`_ "
"(9 minutes 36 seconds)."
msgstr ""
"На канале Computerphile Youtube Том Скотт кратко `обсуждает историю Unicode "
"и UTF-8 <https://www.youtube.com/watch?v=MijmeoH9LT4>`_ (9 минут 36 секунд)."

#: ../../howto/unicode.rst:169
msgid ""
"To help understand the standard, Jukka Korpela has written `an introductory "
"guide <https://jkorpela.fi/unicode/guide.html>`_ to reading the Unicode "
"character tables."
msgstr ""
"Чтобы помочь понять стандарт, Юкка Корпела написал `вводное руководство "
"<https://jkorpela.fi/unicode/guide.html>`_ по чтению таблиц символов Юникода."

#: ../../howto/unicode.rst:173
msgid ""
"Another `good introductory article <https://www.joelonsoftware."
"com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-"
"positively-must-know-about-unicode-and-character-sets-no-excuses/>`_ was "
"written by Joel Spolsky. If this introduction didn't make things clear to "
"you, you should try reading this alternate article before continuing."
msgstr ""
"Еще одна «хорошая вводная статья» set-no-excuses/>`_ был написан Джоэлом "
"Спольски. Если это введение не прояснило вам ситуацию, попробуйте прочитать "
"альтернативную статью, прежде чем продолжить."

#: ../../howto/unicode.rst:178
msgid ""
"Wikipedia entries are often helpful; see the entries for \"`character "
"encoding <https://en.wikipedia.org/wiki/Character_encoding>`_\" and `UTF-8 "
"<https://en.wikipedia.org/wiki/UTF-8>`_, for example."
msgstr ""
"Записи в Википедии часто бывают полезны; см. записи для «`кодировки символов "
"<https://en.wikipedia.org/wiki/Character_encoding>`_» и `UTF-8 <https://en."
"wikipedia.org/wiki/UTF-8>`_ , например."

#: ../../howto/unicode.rst:184
msgid "Python's Unicode Support"
msgstr "Поддержка Юникода в Python"

#: ../../howto/unicode.rst:186
msgid ""
"Now that you've learned the rudiments of Unicode, we can look at Python's "
"Unicode features."
msgstr ""
"Теперь, когда вы изучили основы Unicode, мы можем рассмотреть возможности "
"Unicode в Python."

#: ../../howto/unicode.rst:190
msgid "The String Type"
msgstr "Строковый тип"

#: ../../howto/unicode.rst:192
msgid ""
"Since Python 3.0, the language's :class:`str` type contains Unicode "
"characters, meaning any string created using ``\"unicode rocks!\"``, "
"``'unicode rocks!'``, or the triple-quoted string syntax is stored as "
"Unicode."
msgstr ""
"Начиная с Python 3.0, тип языка :class:`str` содержит символы Юникода, что "
"означает, что любая строка, созданная с использованием ``\"Unicode Rocks!"
"\"``, ``'Unicode Rocks!'`` или синтаксиса строки в тройных кавычках, имеет "
"вид хранится как Юникод."

#: ../../howto/unicode.rst:196
msgid ""
"The default encoding for Python source code is UTF-8, so you can simply "
"include a Unicode character in a string literal::"
msgstr ""
"Кодировкой исходного кода Python по умолчанию является UTF-8, поэтому вы "
"можете просто включить символ Юникода в строковый литерал:"

#: ../../howto/unicode.rst:206
msgid ""
"Side note: Python 3 also supports using Unicode characters in identifiers::"
msgstr ""
"Примечание: Python 3 также поддерживает использование символов Юникода в "
"идентификаторах:"

#: ../../howto/unicode.rst:212
msgid ""
"If you can't enter a particular character in your editor or want to keep the "
"source code ASCII-only for some reason, you can also use escape sequences in "
"string literals. (Depending on your system, you may see the actual capital-"
"delta glyph instead of a \\u escape.) ::"
msgstr ""
"Если вы не можете ввести определенный символ в своем редакторе или по какой-"
"то причине хотите сохранить исходный код только в формате ASCII, вы также "
"можете использовать escape-последовательности в строковых литералах. (В "
"зависимости от вашей системы вы можете увидеть фактический символ заглавной "
"дельты вместо escape-символа \\u.) ::"

#: ../../howto/unicode.rst:224
msgid ""
"In addition, one can create a string using the :func:`~bytes.decode` method "
"of :class:`bytes`.  This method takes an *encoding* argument, such as "
"``UTF-8``, and optionally an *errors* argument."
msgstr ""
"Кроме того, можно создать строку, используя метод :func:`~bytes.decode` :"
"class:`bytes`. Этот метод принимает аргумент *кодирование*, например "
"``UTF-8``, и, возможно, аргумент *errors*."

#: ../../howto/unicode.rst:228
msgid ""
"The *errors* argument specifies the response when the input string can't be "
"converted according to the encoding's rules.  Legal values for this argument "
"are ``'strict'`` (raise a :exc:`UnicodeDecodeError` exception), "
"``'replace'`` (use ``U+FFFD``, ``REPLACEMENT CHARACTER``), ``'ignore'`` "
"(just leave the character out of the Unicode result), or "
"``'backslashreplace'`` (inserts a ``\\xNN`` escape sequence). The following "
"examples show the differences::"
msgstr ""
"Аргумент *errors* определяет ответ, когда входная строка не может быть "
"преобразована в соответствии с правилами кодирования. Допустимые значения "
"для этого аргумента: ``'strict'`` (вызывает исключение :exc:"
"`UnicodeDecodeError`), ``'replace'`` (используйте ``U+FFFD``, ``REPLACEMENT "
"CHARACTER``), ``'игнорировать'`` (просто оставьте символ вне результата "
"Unicode) или ``'обратная косая черта'`` (вставляет escape-последовательность "
"``\\xNN``). Следующие примеры показывают различия:"

#: ../../howto/unicode.rst:248
msgid ""
"Encodings are specified as strings containing the encoding's name.  Python "
"comes with roughly 100 different encodings; see the Python Library Reference "
"at :ref:`standard-encodings` for a list.  Some encodings have multiple "
"names; for example, ``'latin-1'``, ``'iso_8859_1'`` and ``'8859``' are all "
"synonyms for the same encoding."
msgstr ""
"Кодировки указываются в виде строк, содержащих имя кодировки. Python "
"поставляется примерно со 100 различными кодировками; список см. в "
"Справочнике библиотеки Python по адресу :ref:`standard-encodings`. Некоторые "
"кодировки имеют несколько названий; например, ``'latin-1'``, "
"``'iso_8859_1'`` и ``'8859``' являются синонимами одной и той же кодировки."

#: ../../howto/unicode.rst:254
msgid ""
"One-character Unicode strings can also be created with the :func:`chr` built-"
"in function, which takes integers and returns a Unicode string of length 1 "
"that contains the corresponding code point.  The reverse operation is the "
"built-in :func:`ord` function that takes a one-character Unicode string and "
"returns the code point value::"
msgstr ""
"Односимвольные строки Юникода также можно создавать с помощью встроенной "
"функции :func:`chr`, которая принимает целые числа и возвращает строку "
"Юникода длиной 1, содержащую соответствующую кодовую точку. Обратная "
"операция — это встроенная функция :func:`ord`, которая принимает "
"односимвольную строку Юникода и возвращает значение кодовой точки::"

#: ../../howto/unicode.rst:266
msgid "Converting to Bytes"
msgstr "Преобразование в байты"

#: ../../howto/unicode.rst:268
msgid ""
"The opposite method of :meth:`bytes.decode` is :meth:`str.encode`, which "
"returns a :class:`bytes` representation of the Unicode string, encoded in "
"the requested *encoding*."
msgstr ""
"Противоположным методом :meth:`bytes.decode` является :meth:`str.encode`, "
"который возвращает :class:`bytes` представление строки Unicode, "
"закодированной в запрошенной *кодировке*."

#: ../../howto/unicode.rst:272
msgid ""
"The *errors* parameter is the same as the parameter of the :meth:`~bytes."
"decode` method but supports a few more possible handlers. As well as "
"``'strict'``, ``'ignore'``, and ``'replace'`` (which in this case inserts a "
"question mark instead of the unencodable character), there is also "
"``'xmlcharrefreplace'`` (inserts an XML character reference), "
"``backslashreplace`` (inserts a ``\\uNNNN`` escape sequence) and "
"``namereplace`` (inserts a ``\\N{...}`` escape sequence)."
msgstr ""
"Параметр *errors* аналогичен параметру метода :meth:`~bytes.decode`, но "
"поддерживает еще несколько возможных обработчиков. Помимо ``'strict'``, "
"``'ignore'`` и ``'replace'`` (которые в данном случае вставляют "
"вопросительный знак вместо некодируемого символа), существует также "
"``'xmlcharrefreplace '`` (вставляет ссылку на символ XML), ``обратная косая "
"черта`` (вставляет escape-последовательность ``\\uNNNN``) и ``namereplace`` "
"(вставляет escape-последовательность ``\\N{...}`` )."

#: ../../howto/unicode.rst:280
msgid "The following example shows the different results::"
msgstr "В следующем примере показаны разные результаты:"

#: ../../howto/unicode.rst:301
msgid ""
"The low-level routines for registering and accessing the available encodings "
"are found in the :mod:`codecs` module.  Implementing new encodings also "
"requires understanding the :mod:`codecs` module. However, the encoding and "
"decoding functions returned by this module are usually more low-level than "
"is comfortable, and writing new encodings is a specialized task, so the "
"module won't be covered in this HOWTO."
msgstr ""
"Низкоуровневые процедуры регистрации и доступа к доступным кодировкам "
"находятся в модуле :mod:`codecs`. Реализация новых кодировок также требует "
"понимания модуля :mod:`codecs`. Однако функции кодирования и декодирования, "
"возвращаемые этим модулем, обычно являются более низкоуровневыми, чем это "
"удобно, а написание новых кодировок является специализированной задачей, "
"поэтому этот модуль не будет рассматриваться в этом HOWTO."

#: ../../howto/unicode.rst:310
msgid "Unicode Literals in Python Source Code"
msgstr "Литералы Юникода в исходном коде Python"

#: ../../howto/unicode.rst:312
msgid ""
"In Python source code, specific Unicode code points can be written using the "
"``\\u`` escape sequence, which is followed by four hex digits giving the "
"code point.  The ``\\U`` escape sequence is similar, but expects eight hex "
"digits, not four::"
msgstr ""
"В исходном коде Python определенные кодовые точки Unicode могут быть "
"записаны с использованием escape-последовательности ``\\u``, за которой "
"следуют четыре шестнадцатеричные цифры, обозначающие кодовую точку. Escape-"
"последовательность ``\\U`` аналогична, но предполагает восемь "
"шестнадцатеричных цифр, а не четыре:"

#: ../../howto/unicode.rst:324
msgid ""
"Using escape sequences for code points greater than 127 is fine in small "
"doses, but becomes an annoyance if you're using many accented characters, as "
"you would in a program with messages in French or some other accent-using "
"language.  You can also assemble strings using the :func:`chr` built-in "
"function, but this is even more tedious."
msgstr ""
"Использование escape-последовательностей для кодовых точек больше 127 "
"допустимо в небольших дозах, но становится раздражающим, если вы используете "
"много символов с диакритическими знаками, как это было бы в программе с "
"сообщениями на французском или каком-либо другом языке, использующем "
"диакритические знаки. Вы также можете собирать строки, используя встроенную "
"функцию :func:`chr`, но это еще более утомительно."

#: ../../howto/unicode.rst:330
msgid ""
"Ideally, you'd want to be able to write literals in your language's natural "
"encoding.  You could then edit Python source code with your favorite editor "
"which would display the accented characters naturally, and have the right "
"characters used at runtime."
msgstr ""
"В идеале вы хотели бы иметь возможность писать литералы в естественной "
"кодировке вашего языка. Затем вы можете редактировать исходный код Python в "
"своем любимом редакторе, который будет естественным образом отображать "
"символы с диакритическими знаками и использовать правильные символы во время "
"выполнения."

#: ../../howto/unicode.rst:335
msgid ""
"Python supports writing source code in UTF-8 by default, but you can use "
"almost any encoding if you declare the encoding being used.  This is done by "
"including a special comment as either the first or second line of the source "
"file::"
msgstr ""
"Python по умолчанию поддерживает запись исходного кода в UTF-8, но вы можете "
"использовать практически любую кодировку, если объявите используемую "
"кодировку. Это делается путем включения специального комментария в первую "
"или вторую строку исходного файла:"

#: ../../howto/unicode.rst:345
msgid ""
"The syntax is inspired by Emacs's notation for specifying variables local to "
"a file.  Emacs supports many different variables, but Python only supports "
"'coding'.  The ``-*-`` symbols indicate to Emacs that the comment is "
"special; they have no significance to Python but are a convention.  Python "
"looks for ``coding: name`` or ``coding=name`` in the comment."
msgstr ""
"Синтаксис основан на нотации Emacs для указания переменных, локальных для "
"файла. Emacs поддерживает множество различных переменных, но Python "
"поддерживает только «кодирование». Символы ``-*-`` указывают Emacs, что "
"комментарий является особенным; они не имеют никакого значения для Python, "
"но являются соглашением. Python ищет в комментарии ``coding: name`` или "
"``coding=name``."

#: ../../howto/unicode.rst:351
msgid ""
"If you don't include such a comment, the default encoding used will be UTF-8 "
"as already mentioned.  See also :pep:`263` for more information."
msgstr ""
"Если вы не включите такой комментарий, по умолчанию будет использоваться "
"кодировка UTF-8, как уже упоминалось. См. также :pep:`263` для получения "
"дополнительной информации."

#: ../../howto/unicode.rst:356
msgid "Unicode Properties"
msgstr "Свойства Юникода"

#: ../../howto/unicode.rst:358
msgid ""
"The Unicode specification includes a database of information about code "
"points.  For each defined code point, the information includes the "
"character's name, its category, the numeric value if applicable (for "
"characters representing numeric concepts such as the Roman numerals, "
"fractions such as one-third and four-fifths, etc.).  There are also display-"
"related properties, such as how to use the code point in bidirectional text."
msgstr ""
"Спецификация Unicode включает базу данных с информацией о кодовых точках. "
"Для каждой определенной кодовой точки информация включает имя символа, его "
"категорию, числовое значение, если применимо (для символов, представляющих "
"числовые понятия, такие как римские цифры, дроби, такие как одна треть и "
"четыре пятых и т. д.). Существуют также свойства, связанные с отображением, "
"например, как использовать кодовую точку в двунаправленном тексте."

#: ../../howto/unicode.rst:366
msgid ""
"The following program displays some information about several characters, "
"and prints the numeric value of one particular character::"
msgstr ""
"Следующая программа отображает некоторую информацию о нескольких символах и "
"печатает числовое значение одного конкретного символа:"

#: ../../howto/unicode.rst:380
msgid "When run, this prints:"
msgstr "При запуске это печатает:"

#: ../../howto/unicode.rst:391
msgid ""
"The category codes are abbreviations describing the nature of the character. "
"These are grouped into categories such as \"Letter\", \"Number\", "
"\"Punctuation\", or \"Symbol\", which in turn are broken up into "
"subcategories.  To take the codes from the above output, ``'Ll'`` means "
"'Letter, lowercase', ``'No'`` means \"Number, other\", ``'Mn'`` is \"Mark, "
"nonspacing\", and ``'So'`` is \"Symbol, other\".  See `the General Category "
"Values section of the Unicode Character Database documentation <https://www."
"unicode.org/reports/tr44/#General_Category_Values>`_ for a list of category "
"codes."
msgstr ""
"Коды категорий представляют собой аббревиатуры, описывающие характер "
"персонажа. Они сгруппированы в такие категории, как «Буква», «Цифра», "
"«Пунктуация» или «Символ», которые, в свою очередь, разбиты на подкатегории. "
"Если взять коды из приведенного выше вывода, ``'Ll'`` означает \"Буква, "
"строчная\", ``'Нет'`` означает \"Число, другое\", ``'Mn'`` означает \"Знак, "
"без пробелов\". , а ``'So'`` — это «Символ, другое». Список кодов категорий "
"см. в разделе «Общие значения категорий» документации по базе данных "
"символов Юникода <https://www.unicode.org/reports/tr44/"
"#General_Category_Values>."

#: ../../howto/unicode.rst:402
msgid "Comparing Strings"
msgstr "Сравнение строк"

#: ../../howto/unicode.rst:404
msgid ""
"Unicode adds some complication to comparing strings, because the same set of "
"characters can be represented by different sequences of code points.  For "
"example, a letter like 'ê' can be represented as a single code point U+00EA, "
"or as U+0065 U+0302, which is the code point for 'e' followed by a code "
"point for 'COMBINING CIRCUMFLEX ACCENT'.  These will produce the same output "
"when printed, but one is a string of length 1 and the other is of length 2."
msgstr ""
"Юникод усложняет сравнение строк, поскольку один и тот же набор символов "
"может быть представлен разными последовательностями кодовых точек. Например, "
"буква типа «ê» может быть представлена ​​как одна кодовая точка U+00EA или как "
"U+0065 U+0302, которая является кодовой точкой для «e», за которой следует "
"кодовая точка для «COMBINING CIRCUMFLEX ACCENT». . При печати они будут "
"выдавать один и тот же результат, но один из них представляет собой строку "
"длины 1, а другой — длины 2."

#: ../../howto/unicode.rst:412
msgid ""
"One tool for a case-insensitive comparison is the :meth:`~str.casefold` "
"string method that converts a string to a case-insensitive form following an "
"algorithm described by the Unicode Standard.  This algorithm has special "
"handling for characters such as the German letter 'ß' (code point U+00DF), "
"which becomes the pair of lowercase letters 'ss'."
msgstr ""
"Одним из инструментов сравнения без учета регистра является строковый метод :"
"meth:`~str.casefold`, который преобразует строку в форму без учета регистра "
"в соответствии с алгоритмом, описанным стандартом Unicode. В этом алгоритме "
"предусмотрена специальная обработка таких символов, как немецкая буква "
"«ß» (кодовая точка U+00DF), которая становится парой строчных букв «ss»."

#: ../../howto/unicode.rst:425
msgid ""
"A second tool is the :mod:`unicodedata` module's :func:`~unicodedata."
"normalize` function that converts strings to one of several normal forms, "
"where letters followed by a combining character are replaced with single "
"characters.  :func:`~unicodedata.normalize` can be used to perform string "
"comparisons that won't falsely report inequality if two strings use "
"combining characters differently:"
msgstr ""
"Второй инструмент — это функция :func:`~unicodedata.normalize` модуля :mod:"
"`unicodedata`, которая преобразует строки в одну из нескольких нормальных "
"форм, где буквы, за которыми следует объединяющий символ, заменяются "
"одиночными символами. :func:`~unicodedata.normalize` можно использовать для "
"сравнения строк, которое не будет выдавать ложное сообщение о неравенстве, "
"если две строки по-разному используют объединение символов:"

#: ../../howto/unicode.rst:448
msgid "When run, this outputs:"
msgstr "При запуске это выводит:"

#: ../../howto/unicode.rst:457
msgid ""
"The first argument to the :func:`~unicodedata.normalize` function is a "
"string giving the desired normalization form, which can be one of 'NFC', "
"'NFKC', 'NFD', and 'NFKD'."
msgstr ""
"Первый аргумент функции :func:`~unicodedata.normalize` — это строка, "
"задающая желаемую форму нормализации, которая может быть одной из следующих: "
"«NFC», «NFKC», «NFD» и «NFKD»."

#: ../../howto/unicode.rst:461
msgid "The Unicode Standard also specifies how to do caseless comparisons::"
msgstr ""
"Стандарт Unicode также определяет, как выполнять сравнения без регистра:"

#: ../../howto/unicode.rst:477
msgid ""
"This will print ``True``.  (Why is :func:`!NFD` invoked twice?  Because "
"there are a few characters that make :meth:`~str.casefold` return a non-"
"normalized string, so the result needs to be normalized again. See section "
"3.13 of the Unicode Standard for a discussion and an example.)"
msgstr ""
"Это напечатает ``True``. (Почему :func:`!NFD` вызывается дважды? Потому что "
"есть несколько символов, которые заставляют :meth:`~str.casefold` возвращать "
"ненормализованную строку, поэтому результат необходимо нормализовать снова. "
"См. раздел 3.13 стандарт Unicode для обсуждения и примера.)"

#: ../../howto/unicode.rst:484
msgid "Unicode Regular Expressions"
msgstr "Регулярные выражения Юникода"

#: ../../howto/unicode.rst:486
msgid ""
"The regular expressions supported by the :mod:`re` module can be provided "
"either as bytes or strings.  Some of the special character sequences such as "
"``\\d`` and ``\\w`` have different meanings depending on whether the pattern "
"is supplied as bytes or a string.  For example, ``\\d`` will match the "
"characters ``[0-9]`` in bytes but in strings will match any character that's "
"in the ``'Nd'`` category."
msgstr ""
"Регулярные выражения, поддерживаемые модулем :mod:`re`, могут быть "
"предоставлены в виде байтов или строк. Некоторые последовательности "
"специальных символов, такие как ``\\d`` и ``\\w``, имеют разные значения в "
"зависимости от того, представлен ли шаблон в виде байтов или строки. "
"Например, ``\\d`` будет соответствовать символам ``[0-9]`` в байтах, но в "
"строках будет соответствовать любому символу из категории ``'Nd'``."

#: ../../howto/unicode.rst:493
msgid ""
"The string in this example has the number 57 written in both Thai and Arabic "
"numerals::"
msgstr ""
"Строка в этом примере имеет номер 57, записанный как тайскими, так и "
"арабскими цифрами::"

#: ../../howto/unicode.rst:503
msgid ""
"When executed, ``\\d+`` will match the Thai numerals and print them out.  If "
"you supply the :const:`re.ASCII` flag to :func:`~re.compile`, ``\\d+`` will "
"match the substring \"57\" instead."
msgstr ""
"При выполнении ``\\d+`` будет соответствовать тайским цифрам и распечатывать "
"их. Если вы укажете флаг :const:`re.ASCII` в :func:`~re.compile`, ``\\d+`` "
"вместо этого будет соответствовать подстроке \"57\"."

#: ../../howto/unicode.rst:507
msgid ""
"Similarly, ``\\w`` matches a wide variety of Unicode characters but only "
"``[a-zA-Z0-9_]`` in bytes or if :const:`re.ASCII` is supplied, and ``\\s`` "
"will match either Unicode whitespace characters or ``[ \\t\\n\\r\\f\\v]``."
msgstr ""
"Аналогично, ``\\w`` соответствует широкому спектру символов Юникода, но "
"только ``[a-zA-Z0-9_]`` в байтах или если указан :const:`re.ASCII`, и ``\\s "
"`` будет соответствовать либо пробельным символам Юникода, либо "
"``[ \\t\\n\\r\\f\\v]``."

#: ../../howto/unicode.rst:518
msgid "Some good alternative discussions of Python's Unicode support are:"
msgstr ""
"Некоторые хорошие альтернативные обсуждения поддержки Unicode в Python:"

#: ../../howto/unicode.rst:520
msgid ""
"`Processing Text Files in Python 3 <https://python-notes.curiousefficiency."
"org/en/latest/python3/text_file_processing.html>`_, by Nick Coghlan."
msgstr ""
"`Обработка текстовых файлов в Python 3 <https://python-notes."
"curiousefficiency.org/en/latest/python3/text_file_processing.html>`_, Ник "
"Коглан."

#: ../../howto/unicode.rst:521
msgid ""
"`Pragmatic Unicode <https://nedbatchelder.com/text/unipain.html>`_, a PyCon "
"2012 presentation by Ned Batchelder."
msgstr ""
"`Pragmatic Unicode <https://nedbatchelder.com/text/unipain.html>`_, "
"презентация Неда Батчелдера на PyCon 2012."

#: ../../howto/unicode.rst:523
msgid ""
"The :class:`str` type is described in the Python library reference at :ref:"
"`textseq`."
msgstr ""
"Тип :class:`str` описан в справочнике по библиотеке Python по адресу :ref:"
"`textseq`."

#: ../../howto/unicode.rst:526
msgid "The documentation for the :mod:`unicodedata` module."
msgstr "Документация для модуля :mod:`unicodedata`."

#: ../../howto/unicode.rst:528
msgid "The documentation for the :mod:`codecs` module."
msgstr "Документация для модуля :mod:`codecs`."

#: ../../howto/unicode.rst:530
msgid ""
"Marc-André Lemburg gave `a presentation titled \"Python and Unicode\" (PDF "
"slides) <https://downloads.egenix.com/python/Unicode-EPC2002-Talk.pdf>`_ at "
"EuroPython 2002.  The slides are an excellent overview of the design of "
"Python 2's Unicode features (where the Unicode string type is called "
"``unicode`` and literals start with ``u``)."
msgstr ""
"Марк-Андре Лембург сделал `презентацию под названием «Python и "
"Unicode» (слайды в формате PDF) <https://downloads.egenix.com/python/Unicode-"
"EPC2002-Talk.pdf>`_ на выставке EuroPython 2002. Эти слайды представляют "
"собой превосходное обзор функций Unicode в Python 2 (где строковый тип "
"Unicode называется ``unicode``, а литералы начинаются с ``u``)."

#: ../../howto/unicode.rst:538
msgid "Reading and Writing Unicode Data"
msgstr "Чтение и запись данных Unicode"

#: ../../howto/unicode.rst:540
msgid ""
"Once you've written some code that works with Unicode data, the next problem "
"is input/output.  How do you get Unicode strings into your program, and how "
"do you convert Unicode into a form suitable for storage or transmission?"
msgstr ""
"После того, как вы написали код, работающий с данными Unicode, следующей "
"проблемой является ввод/вывод. Как добавить строки Unicode в вашу программу "
"и как преобразовать Unicode в форму, пригодную для хранения или передачи?"

#: ../../howto/unicode.rst:544
msgid ""
"It's possible that you may not need to do anything depending on your input "
"sources and output destinations; you should check whether the libraries used "
"in your application support Unicode natively.  XML parsers often return "
"Unicode data, for example.  Many relational databases also support Unicode-"
"valued columns and can return Unicode values from an SQL query."
msgstr ""
"Возможно, вам не придется ничего делать в зависимости от ваших источников "
"ввода и назначения вывода; вам следует проверить, поддерживают ли "
"библиотеки, используемые в вашем приложении, Unicode изначально. Например, "
"анализаторы XML часто возвращают данные Unicode. Многие реляционные базы "
"данных также поддерживают столбцы со значениями в Юникоде и могут возвращать "
"значения в Юникоде из запроса SQL."

#: ../../howto/unicode.rst:550
msgid ""
"Unicode data is usually converted to a particular encoding before it gets "
"written to disk or sent over a socket.  It's possible to do all the work "
"yourself: open a file, read an 8-bit bytes object from it, and convert the "
"bytes with ``bytes.decode(encoding)``.  However, the manual approach is not "
"recommended."
msgstr ""
"Данные Unicode обычно преобразуются в определенную кодировку перед записью "
"на диск или отправкой через сокет. Всю работу можно сделать самостоятельно: "
"открыть файл, прочитать из него 8-битный байтовый объект и преобразовать "
"байты с помощью ``bytes.decode(encoding)``. Однако ручной подход не "
"рекомендуется."

#: ../../howto/unicode.rst:555
msgid ""
"One problem is the multi-byte nature of encodings; one Unicode character can "
"be represented by several bytes.  If you want to read the file in arbitrary-"
"sized chunks (say, 1024 or 4096 bytes), you need to write error-handling "
"code to catch the case where only part of the bytes encoding a single "
"Unicode character are read at the end of a chunk.  One solution would be to "
"read the entire file into memory and then perform the decoding, but that "
"prevents you from working with files that are extremely large; if you need "
"to read a 2 GiB file, you need 2 GiB of RAM. (More, really, since for at "
"least a moment you'd need to have both the encoded string and its Unicode "
"version in memory.)"
msgstr ""
"Одна из проблем — многобайтовая природа кодировок; один символ Юникода может "
"быть представлен несколькими байтами. Если вы хотите прочитать файл порциями "
"произвольного размера (скажем, 1024 или 4096 байт), вам необходимо написать "
"код обработки ошибок, чтобы отловить случай, когда в конце считывается "
"только часть байтов, кодирующих один символ Юникода. кусок. Одним из решений "
"было бы прочитать весь файл в памяти, а затем выполнить декодирование, но "
"это не позволяет работать с файлами очень большого размера; если вам нужно "
"прочитать файл размером 2 ГБ, вам понадобится 2 ГБ ОЗУ. (На самом деле даже "
"больше, поскольку хотя бы на мгновение вам понадобится иметь в памяти и "
"закодированную строку, и ее версию в Юникоде.)"

#: ../../howto/unicode.rst:565
msgid ""
"The solution would be to use the low-level decoding interface to catch the "
"case of partial coding sequences.  The work of implementing this has already "
"been done for you: the built-in :func:`open` function can return a file-like "
"object that assumes the file's contents are in a specified encoding and "
"accepts Unicode parameters for methods such as :meth:`~io.TextIOBase.read` "
"and :meth:`~io.TextIOBase.write`.  This works through :func:`open`\\'s "
"*encoding* and *errors* parameters which are interpreted just like those in :"
"meth:`str.encode` and :meth:`bytes.decode`."
msgstr ""
"Решением могло бы стать использование низкоуровневого интерфейса "
"декодирования для выявления случаев частичных последовательностей "
"кодирования. Работа по реализации этого уже сделана за вас: встроенная "
"функция :func:`open` может возвращать файлоподобный объект, который "
"предполагает, что содержимое файла находится в указанной кодировке, и "
"принимает параметры Unicode для таких методов, как :meth. :`~io.TextIOBase."
"read` и :meth:`~io.TextIOBase.write`. Это работает через параметры "
"*encoding* и *errors* :func:`open`\\, которые интерпретируются так же, как и "
"в :meth:`str.encode` и :meth:`bytes.decode`."

#: ../../howto/unicode.rst:574
msgid "Reading Unicode from a file is therefore simple::"
msgstr "Таким образом, чтение Unicode из файла является простым:"

#: ../../howto/unicode.rst:580
msgid ""
"It's also possible to open files in update mode, allowing both reading and "
"writing::"
msgstr ""
"Также возможно открывать файлы в режиме обновления, допуская как чтение, так "
"и запись::"

#: ../../howto/unicode.rst:588
msgid ""
"The Unicode character ``U+FEFF`` is used as a byte-order mark (BOM), and is "
"often written as the first character of a file in order to assist with "
"autodetection of the file's byte ordering.  Some encodings, such as UTF-16, "
"expect a BOM to be present at the start of a file; when such an encoding is "
"used, the BOM will be automatically written as the first character and will "
"be silently dropped when the file is read.  There are variants of these "
"encodings, such as 'utf-16-le' and 'utf-16-be' for little-endian and big-"
"endian encodings, that specify one particular byte ordering and don't skip "
"the BOM."
msgstr ""
"Символ Юникода ``U+FEFF`` используется в качестве метки порядка байтов (BOM) "
"и часто записывается как первый символ файла, чтобы облегчить автоматическое "
"определение порядка байтов в файле. Некоторые кодировки, такие как UTF-16, "
"предполагают наличие спецификации в начале файла; при использовании такой "
"кодировки спецификация будет автоматически записана как первый символ и "
"будет автоматически удалена при чтении файла. Существуют варианты этих "
"кодировок, такие как «utf-16-le» и «utf-16-be» для кодировок с прямым и "
"прямым порядком байтов, которые определяют один конкретный порядок байтов и "
"не пропускают спецификацию."

#: ../../howto/unicode.rst:597
msgid ""
"In some areas, it is also convention to use a \"BOM\" at the start of UTF-8 "
"encoded files; the name is misleading since UTF-8 is not byte-order "
"dependent. The mark simply announces that the file is encoded in UTF-8.  For "
"reading such files, use the 'utf-8-sig' codec to automatically skip the mark "
"if present."
msgstr ""
"В некоторых областях также принято использовать «BOM» в начале файлов в "
"кодировке UTF-8; имя вводит в заблуждение, поскольку UTF-8 не зависит от "
"порядка байтов. Знак просто сообщает, что файл имеет кодировку UTF-8. Для "
"чтения таких файлов используйте кодек «utf-8-sig», чтобы автоматически "
"пропустить метку, если она есть."

#: ../../howto/unicode.rst:604
msgid "Unicode filenames"
msgstr "Имена файлов в Юникоде"

#: ../../howto/unicode.rst:606
msgid ""
"Most of the operating systems in common use today support filenames that "
"contain arbitrary Unicode characters.  Usually this is implemented by "
"converting the Unicode string into some encoding that varies depending on "
"the system.  Today Python is converging on using UTF-8: Python on MacOS has "
"used UTF-8 for several versions, and Python 3.6 switched to using UTF-8 on "
"Windows as well.  On Unix systems, there will only be a :term:`filesystem "
"encoding <filesystem encoding and error handler>`. if you've set the "
"``LANG`` or ``LC_CTYPE`` environment variables; if you haven't, the default "
"encoding is again UTF-8."
msgstr ""
"Большинство широко используемых сегодня операционных систем поддерживают "
"имена файлов, содержащие произвольные символы Юникода. Обычно это "
"реализуется путем преобразования строки Unicode в некоторую кодировку, "
"которая зависит от системы. Сегодня Python переходит на использование UTF-8: "
"Python в MacOS использует UTF-8 в нескольких версиях, а Python 3.6 также "
"перешел на использование UTF-8 в Windows. В системах Unix будет только :term:"
"`кодировка файловой системы <кодировка файловой системы и обработчик "
"ошибок>`. если вы установили переменные среды ``LANG`` или ``LC_CTYPE``; "
"если вы этого не сделали, кодировка по умолчанию снова будет UTF-8."

#: ../../howto/unicode.rst:616
msgid ""
"The :func:`sys.getfilesystemencoding` function returns the encoding to use "
"on your current system, in case you want to do the encoding manually, but "
"there's not much reason to bother.  When opening a file for reading or "
"writing, you can usually just provide the Unicode string as the filename, "
"and it will be automatically converted to the right encoding for you::"
msgstr ""
"Функция :func:`sys.getfilesystemencoding` возвращает кодировку, которая "
"будет использоваться в вашей текущей системе, на случай, если вы хотите "
"выполнить кодировку вручную, но нет особых причин для беспокойства. При "
"открытии файла для чтения или записи вы обычно можете просто указать строку "
"Unicode в качестве имени файла, и она будет автоматически преобразована в "
"нужную вам кодировку:"

#: ../../howto/unicode.rst:626
msgid ""
"Functions in the :mod:`os` module such as :func:`os.stat` will also accept "
"Unicode filenames."
msgstr ""
"Функции в модуле :mod:`os`, такие как :func:`os.stat`, также принимают имена "
"файлов в Юникоде."

#: ../../howto/unicode.rst:629
msgid ""
"The :func:`os.listdir` function returns filenames, which raises an issue: "
"should it return the Unicode version of filenames, or should it return bytes "
"containing the encoded versions?  :func:`os.listdir` can do both, depending "
"on whether you provided the directory path as bytes or a Unicode string.  If "
"you pass a Unicode string as the path, filenames will be decoded using the "
"filesystem's encoding and a list of Unicode strings will be returned, while "
"passing a byte path will return the filenames as bytes.  For example, "
"assuming the default :term:`filesystem encoding <filesystem encoding and "
"error handler>` is UTF-8, running the following program::"
msgstr ""
"Функция :func:`os.listdir` возвращает имена файлов, что вызывает проблему: "
"должна ли она возвращать версию имен файлов в Юникоде или она должна "
"возвращать байты, содержащие закодированные версии? :func:`os.listdir` может "
"делать и то, и другое, в зависимости от того, указали ли вы путь к каталогу "
"в виде байтов или строки Unicode. Если вы передадите строку Unicode в "
"качестве пути, имена файлов будут декодированы с использованием кодировки "
"файловой системы и будет возвращен список строк Unicode, а при передаче "
"байтового пути имена файлов будут возвращены в виде байтов. Например, если "
"предположить, что :term:`кодировка файловой системы <кодировка файловой "
"системы и обработчик ошибок>` — UTF-8, запустите следующую программу:"

#: ../../howto/unicode.rst:647
msgid "will produce the following output:"
msgstr "выдаст следующий результат:"

#: ../../howto/unicode.rst:655
msgid ""
"The first list contains UTF-8-encoded filenames, and the second list "
"contains the Unicode versions."
msgstr ""
"Первый список содержит имена файлов в кодировке UTF-8, а второй список "
"содержит версии Unicode."

#: ../../howto/unicode.rst:658
msgid ""
"Note that on most occasions, you should can just stick with using Unicode "
"with these APIs.  The bytes APIs should only be used on systems where "
"undecodable file names can be present; that's pretty much only Unix systems "
"now."
msgstr ""
"Обратите внимание, что в большинстве случаев вам следует просто использовать "
"Unicode с этими API. API-интерфейсы bytes следует использовать только в "
"системах, где могут присутствовать нерасшифрованные имена файлов; сейчас это "
"практически только системы Unix."

#: ../../howto/unicode.rst:665
msgid "Tips for Writing Unicode-aware Programs"
msgstr "Советы по написанию программ, поддерживающих Unicode"

#: ../../howto/unicode.rst:667
msgid ""
"This section provides some suggestions on writing software that deals with "
"Unicode."
msgstr ""
"В этом разделе представлены некоторые предложения по написанию программного "
"обеспечения, работающего с Unicode."

#: ../../howto/unicode.rst:670
msgid "The most important tip is:"
msgstr "Самый важный совет:"

#: ../../howto/unicode.rst:672
msgid ""
"Software should only work with Unicode strings internally, decoding the "
"input data as soon as possible and encoding the output only at the end."
msgstr ""
"Программное обеспечение должно работать только со строками Unicode внутри, "
"декодируя входные данные как можно скорее и кодируя выходные данные только в "
"конце."

#: ../../howto/unicode.rst:675
msgid ""
"If you attempt to write processing functions that accept both Unicode and "
"byte strings, you will find your program vulnerable to bugs wherever you "
"combine the two different kinds of strings.  There is no automatic encoding "
"or decoding: if you do e.g. ``str + bytes``, a :exc:`TypeError` will be "
"raised."
msgstr ""
"Если вы попытаетесь написать функции обработки, которые принимают как строки "
"Юникода, так и байтовые строки, вы обнаружите, что ваша программа уязвима "
"для ошибок везде, где вы комбинируете два разных типа строк. Автоматического "
"кодирования или декодирования не существует: если вы выполните, например, "
"``str + bytes``, будет выдано :exc:`TypeError`."

#: ../../howto/unicode.rst:680
msgid ""
"When using data coming from a web browser or some other untrusted source, a "
"common technique is to check for illegal characters in a string before using "
"the string in a generated command line or storing it in a database.  If "
"you're doing this, be careful to check the decoded string, not the encoded "
"bytes data; some encodings may have interesting properties, such as not "
"being bijective or not being fully ASCII-compatible.  This is especially "
"true if the input data also specifies the encoding, since the attacker can "
"then choose a clever way to hide malicious text in the encoded bytestream."
msgstr ""
"При использовании данных, поступающих из веб-браузера или другого "
"ненадежного источника, обычным методом является проверка на наличие "
"недопустимых символов в строке перед использованием строки в сгенерированной "
"командной строке или сохранением ее в базе данных. Если вы это делаете, "
"будьте осторожны и проверяйте декодированную строку, а не закодированные "
"байты данных; некоторые кодировки могут иметь интересные свойства, например, "
"не быть биективными или не полностью ASCII-совместимыми. Это особенно верно, "
"если во входных данных также указана кодировка, поскольку тогда "
"злоумышленник может выбрать хитрый способ скрыть вредоносный текст в "
"закодированном потоке байтов."

#: ../../howto/unicode.rst:691
msgid "Converting Between File Encodings"
msgstr "Преобразование между кодировками файлов"

#: ../../howto/unicode.rst:693
msgid ""
"The :class:`~codecs.StreamRecoder` class can transparently convert between "
"encodings, taking a stream that returns data in encoding #1 and behaving "
"like a stream returning data in encoding #2."
msgstr ""
"Класс :class:`~codecs.StreamRecoder` может прозрачно преобразовывать данные "
"между кодировками, принимая поток, возвращающий данные в кодировке №1, и "
"ведя себя как поток, возвращающий данные в кодировке №2."

#: ../../howto/unicode.rst:697
msgid ""
"For example, if you have an input file *f* that's in Latin-1, you can wrap "
"it with a :class:`~codecs.StreamRecoder` to return bytes encoded in UTF-8::"
msgstr ""
"Например, если у вас есть входной файл *f* в формате Latin-1, вы можете "
"обернуть его :class:`~codecs.StreamRecoder`, чтобы возвращать байты, "
"закодированные в UTF-8::"

#: ../../howto/unicode.rst:711
msgid "Files in an Unknown Encoding"
msgstr "Файлы в неизвестной кодировке"

#: ../../howto/unicode.rst:713
msgid ""
"What can you do if you need to make a change to a file, but don't know the "
"file's encoding?  If you know the encoding is ASCII-compatible and only want "
"to examine or modify the ASCII parts, you can open the file with the "
"``surrogateescape`` error handler::"
msgstr ""
"Что делать, если вам нужно внести изменения в файл, но вы не знаете его "
"кодировку? Если вы знаете, что кодировка совместима с ASCII, и хотите "
"просмотреть или изменить только части ASCII, вы можете открыть файл с "
"помощью обработчика ошибок surrogateescape::"

#: ../../howto/unicode.rst:727
msgid ""
"The ``surrogateescape`` error handler will decode any non-ASCII bytes as "
"code points in a special range running from U+DC80 to U+DCFF.  These code "
"points will then turn back into the same bytes when the ``surrogateescape`` "
"error handler is used to encode the data and write it back out."
msgstr ""
"Обработчик ошибок surrogateescape декодирует любые байты, отличные от ASCII, "
"как кодовые точки в специальном диапазоне от U+DC80 до U+DCFF. Эти кодовые "
"точки затем снова превратятся в те же байты, когда обработчик ошибок "
"surrogateescape используется для кодирования данных и их обратной записи."

#: ../../howto/unicode.rst:737
msgid ""
"One section of `Mastering Python 3 Input/Output <https://pyvideo.org/"
"video/289/pycon-2010--mastering-python-3-i-o>`_, a PyCon 2010 talk by David "
"Beazley, discusses text processing and binary data handling."
msgstr ""
"В одном разделе «Освоение ввода/вывода Python 3 <https://pyvideo.org/"
"video/289/pycon-2010--mastering-python-3-io>», доклада Дэвида Бизли на PyCon "
"2010, обсуждается обработка текста. и обработка двоичных данных."

#: ../../howto/unicode.rst:741
msgid ""
"The `PDF slides for Marc-André Lemburg's presentation \"Writing Unicode-"
"aware Applications in Python\" <https://downloads.egenix.com/python/LSM2005-"
"Developing-Unicode-aware-applications-in-Python.pdf>`_ discuss questions of "
"character encodings as well as how to internationalize and localize an "
"application.  These slides cover Python 2.x only."
msgstr ""
"`Слайды в формате PDF к презентации Марка-Андре Лембурга «Написание "
"приложений с поддержкой Unicode на Python» <https://downloads.egenix.com/"
"python/LSM2005-Developing-Unicode-aware-applications-in-Python.pdf>`_ "
"обсудить вопросы кодировок символов, а также способы интернационализации и "
"локализации приложения. Эти слайды посвящены только Python 2.x."

#: ../../howto/unicode.rst:747
msgid ""
"`The Guts of Unicode in Python <https://pyvideo.org/video/1768/the-guts-of-"
"unicode-in-python>`_ is a PyCon 2013 talk by Benjamin Peterson that "
"discusses the internal Unicode representation in Python 3.3."
msgstr ""
"`The Guts of Unicode в Python <https://pyvideo.org/video/1768/the-guts-of-"
"unicode-in-python>`_ — это доклад Бенджамина Петерсона на PyCon 2013, в "
"котором обсуждается внутреннее представление Unicode в Python. 3.3."

#: ../../howto/unicode.rst:754
msgid "Acknowledgements"
msgstr "Подтверждение"

#: ../../howto/unicode.rst:756
msgid ""
"The initial draft of this document was written by Andrew Kuchling. It has "
"since been revised further by Alexander Belopolsky, Georg Brandl, Andrew "
"Kuchling, and Ezio Melotti."
msgstr ""
"Первоначальный проект этого документа был написан Эндрю Кучлингом. С тех пор "
"он был доработан Александром Белопольским, Георгом Брандлом, Эндрю Кучлингом "
"и Эцио Мелотти."

#: ../../howto/unicode.rst:760
msgid ""
"Thanks to the following people who have noted errors or offered suggestions "
"on this article: Éric Araujo, Nicholas Bastin, Nick Coghlan, Marius "
"Gedminas, Kent Johnson, Ken Krugler, Marc-André Lemburg, Martin von Löwis, "
"Terry J. Reedy, Serhiy Storchaka, Eryk Sun, Chad Whitacre, Graham Wideman."
msgstr ""
"Спасибо следующим людям, которые заметили ошибки или предложили предложения "
"по этой статье: Эрик Араужо, Николас Бастин, Ник Коглан, Мариус Гедминас, "
"Кент Джонсон, Кен Круглер, Марк-Андре Лембург, Мартин фон Лёвис, Терри Дж. "
"Риди, Сергей Сторчака , Эрик Сан, Чад Уитакр, Грэм Уайдман."
