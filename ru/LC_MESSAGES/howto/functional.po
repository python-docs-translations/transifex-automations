# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-03-07 14:53+0000\n"
"PO-Revision-Date: 2024-05-11 00:32+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../howto/functional.rst:5
msgid "Functional Programming HOWTO"
msgstr "Руководство по функциональному программированию"

#: ../../howto/functional.rst:0
msgid "Author"
msgstr "Автор"

#: ../../howto/functional.rst:7
msgid "A. M. Kuchling"
msgstr "A. M. Kuchling"

#: ../../howto/functional.rst:0
msgid "Release"
msgstr "Релиз"

#: ../../howto/functional.rst:8
msgid "0.32"
msgstr "0.32"

#: ../../howto/functional.rst:10
msgid ""
"In this document, we'll take a tour of Python's features suitable for "
"implementing programs in a functional style.  After an introduction to the "
"concepts of functional programming, we'll look at language features such as :"
"term:`iterator`\\s and :term:`generator`\\s and relevant library modules "
"such as :mod:`itertools` and :mod:`functools`."
msgstr ""
"В этом документе мы рассмотрим возможности Python, подходящие для реализации "
"программ в функциональном стиле. После знакомства с концепциями "
"функционального программирования мы рассмотрим такие возможности языка, как :"
"term:`iterator`\\s и :term:`generator`\\s, а также соответствующие "
"библиотечные модули, такие как :mod:`itertools` и : мод: `functools`."

#: ../../howto/functional.rst:18
msgid "Introduction"
msgstr "Введение"

#: ../../howto/functional.rst:20
msgid ""
"This section explains the basic concept of functional programming; if you're "
"just interested in learning about Python language features, skip to the next "
"section on :ref:`functional-howto-iterators`."
msgstr ""
"В этом разделе объясняются основные понятия функционального "
"программирования; Если вам просто интересно узнать о возможностях языка "
"Python, перейдите к следующему разделу: :ref:`functional-howto-iterators`."

#: ../../howto/functional.rst:24
msgid ""
"Programming languages support decomposing problems in several different ways:"
msgstr ""
"Языки программирования поддерживают декомпозицию задач несколькими "
"различными способами:"

#: ../../howto/functional.rst:26
msgid ""
"Most programming languages are **procedural**: programs are lists of "
"instructions that tell the computer what to do with the program's input.  C, "
"Pascal, and even Unix shells are procedural languages."
msgstr ""
"Большинство языков программирования являются **процедурными**: программы "
"представляют собой списки инструкций, которые сообщают компьютеру, что "
"делать с входными данными программы. C, Pascal и даже оболочки Unix являются "
"процедурными языками."

#: ../../howto/functional.rst:30
msgid ""
"In **declarative** languages, you write a specification that describes the "
"problem to be solved, and the language implementation figures out how to "
"perform the computation efficiently.  SQL is the declarative language you're "
"most likely to be familiar with; a SQL query describes the data set you want "
"to retrieve, and the SQL engine decides whether to scan tables or use "
"indexes, which subclauses should be performed first, etc."
msgstr ""
"В **декларативных** языках вы пишете спецификацию, описывающую решаемую "
"проблему, а реализация языка определяет, как эффективно выполнить "
"вычисления. SQL — это декларативный язык, с которым вы, скорее всего, "
"знакомы; SQL-запрос описывает набор данных, который вы хотите получить, а "
"механизм SQL решает, сканировать ли таблицы или использовать индексы, какие "
"подпункты следует выполнить в первую очередь и т. д."

#: ../../howto/functional.rst:37
msgid ""
"**Object-oriented** programs manipulate collections of objects.  Objects "
"have internal state and support methods that query or modify this internal "
"state in some way. Smalltalk and Java are object-oriented languages.  C++ "
"and Python are languages that support object-oriented programming, but don't "
"force the use of object-oriented features."
msgstr ""
"**Объектно-ориентированные** программы манипулируют коллекциями объектов. "
"Объекты имеют внутреннее состояние и поддерживают методы, которые каким-либо "
"образом запрашивают или изменяют это внутреннее состояние. Smalltalk и Java "
"— объектно-ориентированные языки. C++ и Python — это языки, которые "
"поддерживают объектно-ориентированное программирование, но не требуют "
"принудительного использования объектно-ориентированных функций."

#: ../../howto/functional.rst:43
msgid ""
"**Functional** programming decomposes a problem into a set of functions. "
"Ideally, functions only take inputs and produce outputs, and don't have any "
"internal state that affects the output produced for a given input.  Well-"
"known functional languages include the ML family (Standard ML, OCaml, and "
"other variants) and Haskell."
msgstr ""
"**Функциональное** программирование разлагает задачу на набор функций. В "
"идеале функции только принимают входные данные и производят выходные данные "
"и не имеют какого-либо внутреннего состояния, которое влияет на выходные "
"данные, создаваемые для данного ввода. К хорошо известным функциональным "
"языкам относятся семейство ML (Standard ML, OCaml и другие варианты) и "
"Haskell."

#: ../../howto/functional.rst:49
msgid ""
"The designers of some computer languages choose to emphasize one particular "
"approach to programming.  This often makes it difficult to write programs "
"that use a different approach.  Other languages are multi-paradigm languages "
"that support several different approaches. Lisp, C++, and Python are multi-"
"paradigm; you can write programs or libraries that are largely procedural, "
"object-oriented, or functional in all of these languages.  In a large "
"program, different sections might be written using different approaches; the "
"GUI might be object-oriented while the processing logic is procedural or "
"functional, for example."
msgstr ""
"Разработчики некоторых компьютерных языков предпочитают подчеркивать один "
"конкретный подход к программированию. Это часто затрудняет написание "
"программ, использующих другой подход. Другие языки являются "
"мультипарадигмальными языками, поддерживающими несколько различных подходов. "
"Lisp, C++ и Python являются мультипарадигмальными; на всех этих языках вы "
"можете писать программы или библиотеки, которые в основном являются "
"процедурными, объектно-ориентированными или функциональными. В большой "
"программе разные разделы могут быть написаны с использованием разных "
"подходов; Например, графический интерфейс пользователя может быть объектно-"
"ориентированным, тогда как логика обработки является процедурной или "
"функциональной."

#: ../../howto/functional.rst:60
msgid ""
"In a functional program, input flows through a set of functions. Each "
"function operates on its input and produces some output.  Functional style "
"discourages functions with side effects that modify internal state or make "
"other changes that aren't visible in the function's return value.  Functions "
"that have no side effects at all are called **purely functional**.  Avoiding "
"side effects means not using data structures that get updated as a program "
"runs; every function's output must only depend on its input."
msgstr ""
"В функциональной программе ввод осуществляется через набор функций. Каждая "
"функция оперирует своим входом и выдает некоторый результат. Функциональный "
"стиль не поощряет функции с побочными эффектами, которые изменяют внутреннее "
"состояние или вносят другие изменения, которые не видны в возвращаемом "
"значении функции. Функции, которые вообще не имеют побочных эффектов, "
"называются **чисто функциональными**. Избегать побочных эффектов означает не "
"использовать структуры данных, которые обновляются по мере запуска "
"программы; вывод каждой функции должен зависеть только от ее ввода."

#: ../../howto/functional.rst:68
msgid ""
"Some languages are very strict about purity and don't even have assignment "
"statements such as ``a=3`` or ``c = a + b``, but it's difficult to avoid all "
"side effects, such as printing to the screen or writing to a disk file. "
"Another example is a call to the :func:`print` or :func:`time.sleep` "
"function, neither of which returns a useful value. Both are called only for "
"their side effects of sending some text to the screen or pausing execution "
"for a second."
msgstr ""
"Некоторые языки очень строги в отношении чистоты и даже не имеют операторов "
"присваивания, таких как ``a=3`` или ``c = a + b``, но трудно избежать всех "
"побочных эффектов, таких как вывод на экран. или запись в файл на диске. "
"Другой пример — вызов функции :func:`print` или :func:`time.sleep`, ни одна "
"из которых не возвращает полезное значение. Оба вызываются только из-за "
"побочных эффектов отправки некоторого текста на экран или приостановки "
"выполнения на секунду."

#: ../../howto/functional.rst:75
msgid ""
"Python programs written in functional style usually won't go to the extreme "
"of avoiding all I/O or all assignments; instead, they'll provide a "
"functional-appearing interface but will use non-functional features "
"internally. For example, the implementation of a function will still use "
"assignments to local variables, but won't modify global variables or have "
"other side effects."
msgstr ""
"Программы Python, написанные в функциональном стиле, обычно не доходят до "
"крайности, избегая всех операций ввода-вывода или всех присваиваний; вместо "
"этого они будут предоставлять функциональный интерфейс, но будут "
"использовать нефункциональные функции внутри. Например, реализация функции "
"по-прежнему будет использовать присвоения локальным переменным, но не будет "
"изменять глобальные переменные и не будет иметь других побочных эффектов."

#: ../../howto/functional.rst:81
msgid ""
"Functional programming can be considered the opposite of object-oriented "
"programming.  Objects are little capsules containing some internal state "
"along with a collection of method calls that let you modify this state, and "
"programs consist of making the right set of state changes.  Functional "
"programming wants to avoid state changes as much as possible and works with "
"data flowing between functions.  In Python you might combine the two "
"approaches by writing functions that take and return instances representing "
"objects in your application (e-mail messages, transactions, etc.)."
msgstr ""
"Функциональное программирование можно считать противоположностью объектно-"
"ориентированного программирования. Объекты — это маленькие капсулы, "
"содержащие некоторое внутреннее состояние вместе с набором вызовов методов, "
"которые позволяют вам изменять это состояние, а программы состоят из "
"внесения правильного набора изменений состояния. Функциональное "
"программирование стремится максимально избежать изменений состояния и "
"работает с данными, передаваемыми между функциями. В Python вы можете "
"объединить два подхода, написав функции, которые принимают и возвращают "
"экземпляры, представляющие объекты вашего приложения (сообщения электронной "
"почты, транзакции и т. д.)."

#: ../../howto/functional.rst:90
msgid ""
"Functional design may seem like an odd constraint to work under.  Why should "
"you avoid objects and side effects?  There are theoretical and practical "
"advantages to the functional style:"
msgstr ""
"Функциональный дизайн может показаться странным ограничением для работы. "
"Почему вам следует избегать объектов и побочных эффектов? Функциональный "
"стиль имеет теоретические и практические преимущества:"

#: ../../howto/functional.rst:94
msgid "Formal provability."
msgstr "Формальная доказуемость."

#: ../../howto/functional.rst:95
msgid "Modularity."
msgstr "Модульность."

#: ../../howto/functional.rst:96
msgid "Composability."
msgstr "Компонуемость."

#: ../../howto/functional.rst:97
msgid "Ease of debugging and testing."
msgstr "Простота отладки и тестирования."

#: ../../howto/functional.rst:101
msgid "Formal provability"
msgstr "Формальная доказуемость"

#: ../../howto/functional.rst:103
msgid ""
"A theoretical benefit is that it's easier to construct a mathematical proof "
"that a functional program is correct."
msgstr ""
"Теоретическое преимущество состоит в том, что легче построить математическое "
"доказательство правильности функциональной программы."

#: ../../howto/functional.rst:106
msgid ""
"For a long time researchers have been interested in finding ways to "
"mathematically prove programs correct.  This is different from testing a "
"program on numerous inputs and concluding that its output is usually "
"correct, or reading a program's source code and concluding that the code "
"looks right; the goal is instead a rigorous proof that a program produces "
"the right result for all possible inputs."
msgstr ""
"В течение долгого времени исследователи были заинтересованы в поиске "
"способов математически доказать правильность программ. Это отличается от "
"тестирования программы на множестве входных данных и вывода о том, что ее "
"выходные данные обычно верны, или от чтения исходного кода программы и "
"заключения, что код выглядит правильно; вместо этого целью является строгое "
"доказательство того, что программа выдает правильный результат для всех "
"возможных входных данных."

#: ../../howto/functional.rst:113
msgid ""
"The technique used to prove programs correct is to write down "
"**invariants**, properties of the input data and of the program's variables "
"that are always true.  For each line of code, you then show that if "
"invariants X and Y are true **before** the line is executed, the slightly "
"different invariants X' and Y' are true **after** the line is executed.  "
"This continues until you reach the end of the program, at which point the "
"invariants should match the desired conditions on the program's output."
msgstr ""
"Техника, используемая для доказательства правильности программы, заключается "
"в записи **инвариантов**, свойств входных данных и переменных программы, "
"которые всегда верны. Затем для каждой строки кода вы показываете, что если "
"инварианты X и Y истинны **до** выполнения строки, то слегка отличающиеся "
"инварианты X' и Y' являются истинными **после** выполнения строки. Это "
"продолжается до тех пор, пока вы не достигнете конца программы, после чего "
"инварианты должны соответствовать желаемым условиям на выходе программы."

#: ../../howto/functional.rst:121
msgid ""
"Functional programming's avoidance of assignments arose because assignments "
"are difficult to handle with this technique; assignments can break "
"invariants that were true before the assignment without producing any new "
"invariants that can be propagated onward."
msgstr ""
"Избегание присваиваний в функциональном программировании возникло потому, "
"что с помощью этого метода трудно справиться с заданиями; Присваивания могут "
"нарушать инварианты, которые были истинными до присваивания, не создавая при "
"этом новых инвариантов, которые можно было бы распространять дальше."

#: ../../howto/functional.rst:126
msgid ""
"Unfortunately, proving programs correct is largely impractical and not "
"relevant to Python software. Even trivial programs require proofs that are "
"several pages long; the proof of correctness for a moderately complicated "
"program would be enormous, and few or none of the programs you use daily "
"(the Python interpreter, your XML parser, your web browser) could be proven "
"correct.  Even if you wrote down or generated a proof, there would then be "
"the question of verifying the proof; maybe there's an error in it, and you "
"wrongly believe you've proved the program correct."
msgstr ""
"К сожалению, проверка правильности программ во многом непрактична и не имеет "
"отношения к программному обеспечению Python. Даже тривиальные программы "
"требуют доказательств длиной в несколько страниц; доказательство "
"правильности программы средней сложности будет огромным, и лишь немногие или "
"ни одна из программ, которые вы используете ежедневно (интерпретатор Python, "
"ваш анализатор XML, ваш веб-браузер), не может быть доказана корректной. "
"Даже если вы записали или создали доказательство, тогда встанет вопрос о "
"проверке доказательства; возможно, в ней есть ошибка, и вы ошибочно "
"полагаете, что доказали правильность программы."

#: ../../howto/functional.rst:137
msgid "Modularity"
msgstr "Модульность"

#: ../../howto/functional.rst:139
msgid ""
"A more practical benefit of functional programming is that it forces you to "
"break apart your problem into small pieces.  Programs are more modular as a "
"result.  It's easier to specify and write a small function that does one "
"thing than a large function that performs a complicated transformation.  "
"Small functions are also easier to read and to check for errors."
msgstr ""
"Более практическое преимущество функционального программирования состоит в "
"том, что оно заставляет вас разбивать проблему на мелкие части. В результате "
"программы становятся более модульными. Легче определить и написать небольшую "
"функцию, выполняющую одно действие, чем большую функцию, выполняющую сложное "
"преобразование. Маленькие функции также легче читать и проверять на наличие "
"ошибок."

#: ../../howto/functional.rst:147
msgid "Ease of debugging and testing"
msgstr "Простота отладки и тестирования"

#: ../../howto/functional.rst:149
msgid "Testing and debugging a functional-style program is easier."
msgstr "Тестировать и отлаживать программу функционального стиля проще."

#: ../../howto/functional.rst:151
msgid ""
"Debugging is simplified because functions are generally small and clearly "
"specified.  When a program doesn't work, each function is an interface point "
"where you can check that the data are correct.  You can look at the "
"intermediate inputs and outputs to quickly isolate the function that's "
"responsible for a bug."
msgstr ""
"Отладка упрощается, поскольку функции обычно небольшие и четко определены. "
"Когда программа не работает, каждая функция является точкой интерфейса, где "
"вы можете проверить правильность данных. Вы можете просмотреть промежуточные "
"входы и выходы, чтобы быстро определить функцию, ответственную за ошибку."

#: ../../howto/functional.rst:156
msgid ""
"Testing is easier because each function is a potential subject for a unit "
"test. Functions don't depend on system state that needs to be replicated "
"before running a test; instead you only have to synthesize the right input "
"and then check that the output matches expectations."
msgstr ""
"Тестирование проще, поскольку каждая функция является потенциальным объектом "
"модульного теста. Функции не зависят от состояния системы, которое "
"необходимо воспроизвести перед запуском теста; вместо этого вам нужно всего "
"лишь синтезировать правильные входные данные, а затем проверить, "
"соответствуют ли выходные данные ожиданиям."

#: ../../howto/functional.rst:163
msgid "Composability"
msgstr "Компонуемость"

#: ../../howto/functional.rst:165
msgid ""
"As you work on a functional-style program, you'll write a number of "
"functions with varying inputs and outputs.  Some of these functions will be "
"unavoidably specialized to a particular application, but others will be "
"useful in a wide variety of programs.  For example, a function that takes a "
"directory path and returns all the XML files in the directory, or a function "
"that takes a filename and returns its contents, can be applied to many "
"different situations."
msgstr ""
"Работая над программой функционального стиля, вы будете писать ряд функций с "
"разными входными и выходными данными. Некоторые из этих функций неизбежно "
"будут специализированы для конкретного приложения, но другие будут полезны в "
"самых разных программах. Например, функция, которая принимает путь к "
"каталогу и возвращает все XML-файлы в каталоге, или функция, которая "
"принимает имя файла и возвращает его содержимое, может применяться во многих "
"различных ситуациях."

#: ../../howto/functional.rst:172
msgid ""
"Over time you'll form a personal library of utilities.  Often you'll "
"assemble new programs by arranging existing functions in a new configuration "
"and writing a few functions specialized for the current task."
msgstr ""
"Со временем у вас сформируется личная библиотека утилит. Часто вы собираете "
"новые программы, компонуя существующие функции в новой конфигурации и "
"записывая несколько функций, специально предназначенных для текущей задачи."

#: ../../howto/functional.rst:180
msgid "Iterators"
msgstr "Итераторы"

#: ../../howto/functional.rst:182
msgid ""
"I'll start by looking at a Python language feature that's an important "
"foundation for writing functional-style programs: iterators."
msgstr ""
"Я начну с рассмотрения возможности языка Python, которая является важной "
"основой для написания программ функционального стиля: итераторов."

#: ../../howto/functional.rst:185
msgid ""
"An iterator is an object representing a stream of data; this object returns "
"the data one element at a time.  A Python iterator must support a method "
"called :meth:`~iterator.__next__` that takes no arguments and always returns "
"the next element of the stream.  If there are no more elements in the "
"stream, :meth:`~iterator.__next__` must raise the :exc:`StopIteration` "
"exception. Iterators don't have to be finite, though; it's perfectly "
"reasonable to write an iterator that produces an infinite stream of data."
msgstr ""
"Итератор — это объект, представляющий поток данных; этот объект возвращает "
"данные по одному элементу за раз. Итератор Python должен поддерживать метод :"
"meth:`~iterator.__next__`, который не принимает аргументов и всегда "
"возвращает следующий элемент потока. Если в потоке больше нет элементов, :"
"meth:`~iterator.__next__` должен вызвать исключение :exc:`StopIteration`. "
"Однако итераторы не обязательно должны быть конечными; вполне разумно "
"написать итератор, создающий бесконечный поток данных."

#: ../../howto/functional.rst:193
msgid ""
"The built-in :func:`iter` function takes an arbitrary object and tries to "
"return an iterator that will return the object's contents or elements, "
"raising :exc:`TypeError` if the object doesn't support iteration.  Several "
"of Python's built-in data types support iteration, the most common being "
"lists and dictionaries.  An object is called :term:`iterable` if you can get "
"an iterator for it."
msgstr ""
"Встроенная функция :func:`iter` принимает произвольный объект и пытается "
"вернуть итератор, который вернет содержимое или элементы объекта, вызывая :"
"exc:`TypeError`, если объект не поддерживает итерацию. Некоторые встроенные "
"типы данных Python поддерживают итерацию, наиболее распространенными из "
"которых являются списки и словари. Объект называется :term:`iterable`, если "
"вы можете получить для него итератор."

#: ../../howto/functional.rst:200
msgid "You can experiment with the iteration interface manually:"
msgstr "Вы можете поэкспериментировать с интерфейсом итерации вручную:"

#: ../../howto/functional.rst:218
msgid ""
"Python expects iterable objects in several different contexts, the most "
"important being the :keyword:`for` statement.  In the statement ``for X in "
"Y``, Y must be an iterator or some object for which :func:`iter` can create "
"an iterator.  These two statements are equivalent::"
msgstr ""
"Python ожидает итерации объектов в нескольких различных контекстах, наиболее "
"важным из которых является оператор :keyword:`for`. В утверждении ``for X in "
"Y`` Y должен быть итератором или каким-либо объектом, для которого :func:"
"`iter` может создать итератор. Эти два утверждения эквивалентны:"

#: ../../howto/functional.rst:224
msgid ""
"for i in iter(obj):\n"
"    print(i)\n"
"\n"
"for i in obj:\n"
"    print(i)"
msgstr ""
"for i in iter(obj):\n"
"    print(i)\n"
"\n"
"for i in obj:\n"
"    print(i)"

#: ../../howto/functional.rst:230
msgid ""
"Iterators can be materialized as lists or tuples by using the :func:`list` "
"or :func:`tuple` constructor functions:"
msgstr ""
"Итераторы можно материализовать в виде списков или кортежей с помощью "
"функций-конструкторов :func:`list` или :func:`tuple`:"

#: ../../howto/functional.rst:239
msgid ""
"Sequence unpacking also supports iterators: if you know an iterator will "
"return N elements, you can unpack them into an N-tuple:"
msgstr ""
"Распаковка последовательностей также поддерживает итераторы: если вы знаете, "
"что итератор вернет N элементов, вы можете распаковать их в N-кортеж:"

#: ../../howto/functional.rst:248
msgid ""
"Built-in functions such as :func:`max` and :func:`min` can take a single "
"iterator argument and will return the largest or smallest element.  The "
"``\"in\"`` and ``\"not in\"`` operators also support iterators: ``X in "
"iterator`` is true if X is found in the stream returned by the iterator.  "
"You'll run into obvious problems if the iterator is infinite; :func:`max`, :"
"func:`min` will never return, and if the element X never appears in the "
"stream, the ``\"in\"`` and ``\"not in\"`` operators won't return either."
msgstr ""
"Встроенные функции, такие как :func:`max` и :func:`min`, могут принимать "
"один аргумент итератора и возвращать самый большой или наименьший элемент. "
"Операторы «in» и «not in» также поддерживают итераторы: «X в итераторе» "
"имеет значение true, если X найден в потоке, возвращаемом итератором. Вы "
"столкнетесь с очевидными проблемами, если итератор бесконечен; :func:`max`, :"
"func:`min` никогда не вернется, и если элемент X никогда не появляется в "
"потоке, операторы ``\"in\"`` и ``\"not in\"`` не вернут результат. или."

#: ../../howto/functional.rst:256
msgid ""
"Note that you can only go forward in an iterator; there's no way to get the "
"previous element, reset the iterator, or make a copy of it.  Iterator "
"objects can optionally provide these additional capabilities, but the "
"iterator protocol only specifies the :meth:`~iterator.__next__` method.  "
"Functions may therefore consume all of the iterator's output, and if you "
"need to do something different with the same stream, you'll have to create a "
"new iterator."
msgstr ""
"Обратите внимание, что вы можете двигаться вперед только в итераторе; нет "
"возможности получить предыдущий элемент, сбросить итератор или сделать его "
"копию. Объекты итератора могут дополнительно предоставлять эти "
"дополнительные возможности, но протокол итератора определяет только метод :"
"meth:`~iterator.__next__`. Таким образом, функции могут использовать весь "
"вывод итератора, и если вам нужно сделать что-то другое с тем же потоком, "
"вам придется создать новый итератор."

#: ../../howto/functional.rst:266
msgid "Data Types That Support Iterators"
msgstr "Типы данных, поддерживающие итераторы"

#: ../../howto/functional.rst:268
msgid ""
"We've already seen how lists and tuples support iterators.  In fact, any "
"Python sequence type, such as strings, will automatically support creation "
"of an iterator."
msgstr ""
"Мы уже видели, как списки и кортежи поддерживают итераторы. Фактически, "
"любой тип последовательности Python, например строки, автоматически "
"поддерживает создание итератора."

#: ../../howto/functional.rst:272
msgid ""
"Calling :func:`iter` on a dictionary returns an iterator that will loop over "
"the dictionary's keys::"
msgstr ""
"Вызов :func:`iter` для словаря возвращает итератор, который будет перебирать "
"ключи словаря::"

#: ../../howto/functional.rst:275
msgid ""
">>> m = {'Jan': 1, 'Feb': 2, 'Mar': 3, 'Apr': 4, 'May': 5, 'Jun': 6,\n"
"...      'Jul': 7, 'Aug': 8, 'Sep': 9, 'Oct': 10, 'Nov': 11, 'Dec': 12}\n"
">>> for key in m:\n"
"...     print(key, m[key])\n"
"Jan 1\n"
"Feb 2\n"
"Mar 3\n"
"Apr 4\n"
"May 5\n"
"Jun 6\n"
"Jul 7\n"
"Aug 8\n"
"Sep 9\n"
"Oct 10\n"
"Nov 11\n"
"Dec 12"
msgstr ""
">>> m = {'Jan': 1, 'Feb': 2, 'Mar': 3, 'Apr': 4, 'May': 5, 'Jun': 6,\n"
"...      'Jul': 7, 'Aug': 8, 'Sep': 9, 'Oct': 10, 'Nov': 11, 'Dec': 12}\n"
">>> for key in m:\n"
"...     print(key, m[key])\n"
"Jan 1\n"
"Feb 2\n"
"Mar 3\n"
"Apr 4\n"
"May 5\n"
"Jun 6\n"
"Jul 7\n"
"Aug 8\n"
"Sep 9\n"
"Oct 10\n"
"Nov 11\n"
"Dec 12"

#: ../../howto/functional.rst:292
msgid ""
"Note that starting with Python 3.7, dictionary iteration order is guaranteed "
"to be the same as the insertion order. In earlier versions, the behaviour "
"was unspecified and could vary between implementations."
msgstr ""
"Обратите внимание, что начиная с Python 3.7 порядок итерации словаря "
"гарантированно совпадает с порядком вставки. В более ранних версиях "
"поведение не было указано и могло различаться в зависимости от реализации."

#: ../../howto/functional.rst:296
msgid ""
"Applying :func:`iter` to a dictionary always loops over the keys, but "
"dictionaries have methods that return other iterators.  If you want to "
"iterate over values or key/value pairs, you can explicitly call the :meth:"
"`~dict.values` or :meth:`~dict.items` methods to get an appropriate iterator."
msgstr ""
"Применение :func:`iter` к словарю всегда циклически перебирает ключи, но "
"словари имеют методы, которые возвращают другие итераторы. Если вы хотите "
"перебирать значения или пары ключ/значение, вы можете явно вызвать методы :"
"meth:`~dict.values` или :meth:`~dict.items`, чтобы получить соответствующий "
"итератор."

#: ../../howto/functional.rst:302
msgid ""
"The :func:`dict` constructor can accept an iterator that returns a finite "
"stream of ``(key, value)`` tuples:"
msgstr ""
"Конструктор :func:`dict` может принимать итератор, который возвращает "
"конечный поток кортежей ``(ключ, значение)``:"

#: ../../howto/functional.rst:309
msgid ""
"Files also support iteration by calling the :meth:`~io.TextIOBase.readline` "
"method until there are no more lines in the file.  This means you can read "
"each line of a file like this::"
msgstr ""
"Файлы также поддерживают итерацию, вызывая метод :meth:`~io.TextIOBase."
"readline` до тех пор, пока в файле не останется строк. Это означает, что вы "
"можете прочитать каждую строку файла следующим образом:"

#: ../../howto/functional.rst:313
msgid ""
"for line in file:\n"
"    # do something for each line\n"
"    ..."
msgstr ""
"for line in file:\n"
"    # do something for each line\n"
"    ..."

#: ../../howto/functional.rst:317
msgid ""
"Sets can take their contents from an iterable and let you iterate over the "
"set's elements::"
msgstr ""
"Наборы могут брать свое содержимое из итерируемого объекта и позволять вам "
"перебирать элементы набора:"

#: ../../howto/functional.rst:320
msgid ""
">>> S = {2, 3, 5, 7, 11, 13}\n"
">>> for i in S:\n"
"...     print(i)\n"
"2\n"
"3\n"
"5\n"
"7\n"
"11\n"
"13"
msgstr ""
">>> S = {2, 3, 5, 7, 11, 13}\n"
">>> for i in S:\n"
"...     print(i)\n"
"2\n"
"3\n"
"5\n"
"7\n"
"11\n"
"13"

#: ../../howto/functional.rst:333
msgid "Generator expressions and list comprehensions"
msgstr "Выражения-генераторы и понимание списков"

#: ../../howto/functional.rst:335
msgid ""
"Two common operations on an iterator's output are 1) performing some "
"operation for every element, 2) selecting a subset of elements that meet "
"some condition. For example, given a list of strings, you might want to "
"strip off trailing whitespace from each line or extract all the strings "
"containing a given substring."
msgstr ""
"Две распространенные операции над выходными данными итератора: 1) выполнение "
"некоторой операции для каждого элемента, 2) выбор подмножества элементов, "
"соответствующих некоторому условию. Например, если у вас есть список строк, "
"вы можете захотеть удалить конечные пробелы из каждой строки или извлечь все "
"строки, содержащие данную подстроку."

#: ../../howto/functional.rst:341
msgid ""
"List comprehensions and generator expressions (short form: \"listcomps\" and "
"\"genexps\") are a concise notation for such operations, borrowed from the "
"functional programming language Haskell (https://www.haskell.org/).  You can "
"strip all the whitespace from a stream of strings with the following code::"
msgstr ""
"Понимание списков и выражения-генераторы (краткая форма: «listcomps» и "
"«genexps») представляют собой краткую запись таких операций, заимствованную "
"из функционального языка программирования Haskell (https://www.haskell."
"org/). Вы можете удалить все пробелы из потока строк с помощью следующего "
"кода:"

#: ../../howto/functional.rst:346
msgid ""
">>> line_list = ['  line 1\\n', 'line 2  \\n', ' \\n', '']\n"
"\n"
">>> # Generator expression -- returns iterator\n"
">>> stripped_iter = (line.strip() for line in line_list)\n"
"\n"
">>> # List comprehension -- returns list\n"
">>> stripped_list = [line.strip() for line in line_list]"
msgstr ""
">>> line_list = ['  line 1\\n', 'line 2  \\n', ' \\n', '']\n"
"\n"
">>> # Generator expression -- returns iterator\n"
">>> stripped_iter = (line.strip() for line in line_list)\n"
"\n"
">>> # List comprehension -- returns list\n"
">>> stripped_list = [line.strip() for line in line_list]"

#: ../../howto/functional.rst:354
msgid ""
"You can select only certain elements by adding an ``\"if\"`` condition::"
msgstr ""
"Вы можете выбрать только определенные элементы, добавив условие ``if'``:"

#: ../../howto/functional.rst:356
msgid ""
">>> stripped_list = [line.strip() for line in line_list\n"
"...                  if line != \"\"]"
msgstr ""
">>> stripped_list = [line.strip() for line in line_list\n"
"...                  if line != \"\"]"

#: ../../howto/functional.rst:359
msgid ""
"With a list comprehension, you get back a Python list; ``stripped_list`` is "
"a list containing the resulting lines, not an iterator.  Generator "
"expressions return an iterator that computes the values as necessary, not "
"needing to materialize all the values at once.  This means that list "
"comprehensions aren't useful if you're working with iterators that return an "
"infinite stream or a very large amount of data.  Generator expressions are "
"preferable in these situations."
msgstr ""
"Благодаря пониманию списка вы получаете список Python; ``striped_list`` — "
"это список, содержащий результирующие строки, а не итератор. Выражения-"
"генераторы возвращают итератор, который вычисляет значения по мере "
"необходимости, без необходимости материализовать все значения одновременно. "
"Это означает, что понимание списков бесполезно, если вы работаете с "
"итераторами, которые возвращают бесконечный поток или очень большой объем "
"данных. В таких ситуациях предпочтительнее использовать выражения-генераторы."

#: ../../howto/functional.rst:366
msgid ""
"Generator expressions are surrounded by parentheses (\"()\") and list "
"comprehensions are surrounded by square brackets (\"[]\").  Generator "
"expressions have the form::"
msgstr ""
"Выражения генератора заключаются в круглые скобки («()»), а выражения "
"списков заключаются в квадратные скобки («[]»). Выражения генератора имеют "
"вид::"

#: ../../howto/functional.rst:370
msgid ""
"( expression for expr in sequence1\n"
"             if condition1\n"
"             for expr2 in sequence2\n"
"             if condition2\n"
"             for expr3 in sequence3\n"
"             ...\n"
"             if condition3\n"
"             for exprN in sequenceN\n"
"             if conditionN )"
msgstr ""
"( expression for expr in sequence1\n"
"             if condition1\n"
"             for expr2 in sequence2\n"
"             if condition2\n"
"             for expr3 in sequence3\n"
"             ...\n"
"             if condition3\n"
"             for exprN in sequenceN\n"
"             if conditionN )"

#: ../../howto/functional.rst:380
msgid ""
"Again, for a list comprehension only the outside brackets are different "
"(square brackets instead of parentheses)."
msgstr ""
"Опять же, для понимания списка различаются только внешние скобки (квадратные "
"скобки вместо круглых)."

#: ../../howto/functional.rst:383
msgid ""
"The elements of the generated output will be the successive values of "
"``expression``.  The ``if`` clauses are all optional; if present, "
"``expression`` is only evaluated and added to the result when ``condition`` "
"is true."
msgstr ""
"Элементами сгенерированного вывода будут последовательные значения "
"выражения. Все предложения ``if`` не являются обязательными; если оно "
"присутствует, выражение оценивается и добавляется к результату только тогда, "
"когда условие истинно."

#: ../../howto/functional.rst:387
msgid ""
"Generator expressions always have to be written inside parentheses, but the "
"parentheses signalling a function call also count.  If you want to create an "
"iterator that will be immediately passed to a function you can write::"
msgstr ""
"Выражения-генераторы всегда должны быть записаны в круглых скобках, но "
"скобки, сигнализирующие о вызове функции, также учитываются. Если вы хотите "
"создать итератор, который будет немедленно передан в функцию, вы можете "
"написать::"

#: ../../howto/functional.rst:391
msgid "obj_total = sum(obj.count for obj in list_all_objects())"
msgstr "obj_total = sum(obj.count for obj in list_all_objects())"

#: ../../howto/functional.rst:393
msgid ""
"The ``for...in`` clauses contain the sequences to be iterated over.  The "
"sequences do not have to be the same length, because they are iterated over "
"from left to right, **not** in parallel.  For each element in ``sequence1``, "
"``sequence2`` is looped over from the beginning.  ``sequence3`` is then "
"looped over for each resulting pair of elements from ``sequence1`` and "
"``sequence2``."
msgstr ""
"Предложения ``for...in`` содержат последовательности, которые необходимо "
"перебрать. Последовательности не обязательно должны быть одинаковой длины, "
"поскольку они повторяются слева направо, а не **параллельно**. Для каждого "
"элемента в ``sequence1`` ``sequence2`` выполняется циклически с самого "
"начала. Затем ``sequence3`` обрабатывается в цикле для каждой результирующей "
"пары элементов из ``sequence1`` и ``sequence2``."

#: ../../howto/functional.rst:399
msgid ""
"To put it another way, a list comprehension or generator expression is "
"equivalent to the following Python code::"
msgstr ""
"Другими словами, выражение списка или выражение-генератор эквивалентно "
"следующему коду Python:"

#: ../../howto/functional.rst:402
msgid ""
"for expr1 in sequence1:\n"
"    if not (condition1):\n"
"        continue   # Skip this element\n"
"    for expr2 in sequence2:\n"
"        if not (condition2):\n"
"            continue   # Skip this element\n"
"        ...\n"
"        for exprN in sequenceN:\n"
"            if not (conditionN):\n"
"                continue   # Skip this element\n"
"\n"
"            # Output the value of\n"
"            # the expression."
msgstr ""
"for expr1 in sequence1:\n"
"    if not (condition1):\n"
"        continue   # Skip this element\n"
"    for expr2 in sequence2:\n"
"        if not (condition2):\n"
"            continue   # Skip this element\n"
"        ...\n"
"        for exprN in sequenceN:\n"
"            if not (conditionN):\n"
"                continue   # Skip this element\n"
"\n"
"            # Output the value of\n"
"            # the expression."

#: ../../howto/functional.rst:416
msgid ""
"This means that when there are multiple ``for...in`` clauses but no ``if`` "
"clauses, the length of the resulting output will be equal to the product of "
"the lengths of all the sequences.  If you have two lists of length 3, the "
"output list is 9 elements long:"
msgstr ""
"Это означает, что если имеется несколько предложений for...in, но нет "
"предложений if, длина результирующего вывода будет равна произведению длин "
"всех последовательностей. Если у вас есть два списка длиной 3, выходной "
"список будет состоять из 9 элементов:"

#: ../../howto/functional.rst:428
msgid ""
"To avoid introducing an ambiguity into Python's grammar, if ``expression`` "
"is creating a tuple, it must be surrounded with parentheses.  The first list "
"comprehension below is a syntax error, while the second one is correct::"
msgstr ""
"Чтобы избежать двусмысленности в грамматике Python, если «выражение» создает "
"кортеж, оно должно быть заключено в круглые скобки. Первое понимание списка "
"ниже является синтаксической ошибкой, а второе правильно::"

#: ../../howto/functional.rst:432
msgid ""
"# Syntax error\n"
"[x, y for x in seq1 for y in seq2]\n"
"# Correct\n"
"[(x, y) for x in seq1 for y in seq2]"
msgstr ""
"# Syntax error\n"
"[x, y for x in seq1 for y in seq2]\n"
"# Correct\n"
"[(x, y) for x in seq1 for y in seq2]"

#: ../../howto/functional.rst:439
msgid "Generators"
msgstr "Генераторы"

#: ../../howto/functional.rst:441
msgid ""
"Generators are a special class of functions that simplify the task of "
"writing iterators.  Regular functions compute a value and return it, but "
"generators return an iterator that returns a stream of values."
msgstr ""
"Генераторы — это особый класс функций, упрощающий задачу написания "
"итераторов. Обычные функции вычисляют значение и возвращают его, но "
"генераторы возвращают итератор, возвращающий поток значений."

#: ../../howto/functional.rst:445
msgid ""
"You're doubtless familiar with how regular function calls work in Python or "
"C. When you call a function, it gets a private namespace where its local "
"variables are created.  When the function reaches a ``return`` statement, "
"the local variables are destroyed and the value is returned to the caller.  "
"A later call to the same function creates a new private namespace and a "
"fresh set of local variables. But, what if the local variables weren't "
"thrown away on exiting a function?  What if you could later resume the "
"function where it left off?  This is what generators provide; they can be "
"thought of as resumable functions."
msgstr ""
"Вы, несомненно, знакомы с тем, как работают обычные вызовы функций в Python "
"или C. Когда вы вызываете функцию, она получает частное пространство имен, в "
"котором создаются ее локальные переменные. Когда функция достигает оператора "
"return, локальные переменные уничтожаются и значение возвращается вызывающей "
"стороне. Более поздний вызов той же функции создает новое частное "
"пространство имен и новый набор локальных переменных. Но что, если бы "
"локальные переменные не удалялись при выходе из функции? Что, если бы вы "
"могли позже возобновить выполнение функции с того места, где она "
"остановилась? Это то, что обеспечивают генераторы; их можно рассматривать "
"как возобновляемые функции."

#: ../../howto/functional.rst:454
msgid "Here's the simplest example of a generator function:"
msgstr "Вот простейший пример функции-генератора:"

#: ../../howto/functional.rst:460
msgid ""
"Any function containing a :keyword:`yield` keyword is a generator function; "
"this is detected by Python's :term:`bytecode` compiler which compiles the "
"function specially as a result."
msgstr ""
"Любая функция, содержащая ключевое слово :keyword:`yield`, является функцией-"
"генератором; это обнаруживается компилятором :term:`bytecode` Python, "
"который в результате специально компилирует функцию."

#: ../../howto/functional.rst:464
msgid ""
"When you call a generator function, it doesn't return a single value; "
"instead it returns a generator object that supports the iterator protocol.  "
"On executing the ``yield`` expression, the generator outputs the value of "
"``i``, similar to a ``return`` statement.  The big difference between "
"``yield`` and a ``return`` statement is that on reaching a ``yield`` the "
"generator's state of execution is suspended and local variables are "
"preserved.  On the next call to the generator's :meth:`~generator.__next__` "
"method, the function will resume executing."
msgstr ""
"Когда вы вызываете функцию-генератор, она не возвращает ни одного значения; "
"вместо этого он возвращает объект-генератор, поддерживающий протокол "
"итератора. При выполнении выражения «yield» генератор выводит значение «i», "
"аналогично оператору «return». Большая разница между оператором \"yield\" и "
"оператором \"return\" состоит в том, что при достижении \"yield\" состояние "
"выполнения генератора приостанавливается, а локальные переменные "
"сохраняются. При следующем вызове метода генератора :meth:`~generator."
"__next__` функция возобновит выполнение."

#: ../../howto/functional.rst:473
msgid "Here's a sample usage of the ``generate_ints()`` generator:"
msgstr "Вот пример использования генератора ``generate_ints()``:"

#: ../../howto/functional.rst:490
msgid ""
"You could equally write ``for i in generate_ints(5)``, or ``a, b, c = "
"generate_ints(3)``."
msgstr ""
"Вы также можете написать ``for i ingenerate_ints(5)`` или ``a,b,c "
"=generate_ints(3)``."

#: ../../howto/functional.rst:493
msgid ""
"Inside a generator function, ``return value`` causes "
"``StopIteration(value)`` to be raised from the :meth:`~generator.__next__` "
"method.  Once this happens, or the bottom of the function is reached, the "
"procession of values ends and the generator cannot yield any further values."
msgstr ""
"Внутри функции-генератора ``возвращаемое значение`` вызывает вызов "
"``StopIteration(value)`` из метода :meth:`~generator.__next__`. Как только "
"это произойдет или будет достигнута нижняя часть функции, обработка значений "
"закончится, и генератор не сможет выдавать дальнейшие значения."

#: ../../howto/functional.rst:498
msgid ""
"You could achieve the effect of generators manually by writing your own "
"class and storing all the local variables of the generator as instance "
"variables.  For example, returning a list of integers could be done by "
"setting ``self.count`` to 0, and having the :meth:`~iterator.__next__` "
"method increment ``self.count`` and return it. However, for a moderately "
"complicated generator, writing a corresponding class can be much messier."
msgstr ""
"Эффекта генераторов можно добиться вручную, написав собственный класс и "
"сохранив все локальные переменные генератора как переменные экземпляра. "
"Например, возврат списка целых чисел можно выполнить, установив для ``self."
"count`` значение 0, а метод :meth:`~iterator.__next__` увеличит ``self."
"count`` и вернет его. Однако для генератора средней сложности написание "
"соответствующего класса может оказаться гораздо более запутанным."

#: ../../howto/functional.rst:506
msgid ""
"The test suite included with Python's library, :source:`Lib/test/"
"test_generators.py`, contains a number of more interesting examples.  Here's "
"one generator that implements an in-order traversal of a tree using "
"generators recursively. ::"
msgstr ""
"Набор тестов, включенный в библиотеку Python, :source:`Lib/test/"
"test_generators.py`, содержит ряд более интересных примеров. Вот один "
"генератор, который реализует обход дерева по порядку, используя рекурсивные "
"генераторы. ::"

#: ../../howto/functional.rst:511
msgid ""
"# A recursive generator that generates Tree leaves in in-order.\n"
"def inorder(t):\n"
"    if t:\n"
"        for x in inorder(t.left):\n"
"            yield x\n"
"\n"
"        yield t.label\n"
"\n"
"        for x in inorder(t.right):\n"
"            yield x"
msgstr ""
"# A recursive generator that generates Tree leaves in in-order.\n"
"def inorder(t):\n"
"    if t:\n"
"        for x in inorder(t.left):\n"
"            yield x\n"
"\n"
"        yield t.label\n"
"\n"
"        for x in inorder(t.right):\n"
"            yield x"

#: ../../howto/functional.rst:522
msgid ""
"Two other examples in ``test_generators.py`` produce solutions for the N-"
"Queens problem (placing N queens on an NxN chess board so that no queen "
"threatens another) and the Knight's Tour (finding a route that takes a "
"knight to every square of an NxN chessboard without visiting any square "
"twice)."
msgstr ""
"Два других примера в ``test_generators.py`` дают решения проблемы N-ферзей "
"(размещение N ферзей на шахматной доске NxN так, чтобы ни один ферзь не "
"угрожал другому) и тура коня (поиск маршрута, который приведет коня на "
"каждое поле). шахматной доски NxN, не посещая ни одну клетку дважды)."

#: ../../howto/functional.rst:530
msgid "Passing values into a generator"
msgstr "Передача значений в генератор"

#: ../../howto/functional.rst:532
msgid ""
"In Python 2.4 and earlier, generators only produced output.  Once a "
"generator's code was invoked to create an iterator, there was no way to pass "
"any new information into the function when its execution is resumed.  You "
"could hack together this ability by making the generator look at a global "
"variable or by passing in some mutable object that callers then modify, but "
"these approaches are messy."
msgstr ""
"В Python 2.4 и более ранних версиях генераторы производили только выходные "
"данные. После того, как код генератора был вызван для создания итератора, не "
"было возможности передать какую-либо новую информацию в функцию при "
"возобновлении ее выполнения. Вы могли бы взломать эту возможность, заставив "
"генератор просматривать глобальную переменную или передав некоторый "
"изменяемый объект, который затем модифицируют вызывающие объекты, но эти "
"подходы являются грязными."

#: ../../howto/functional.rst:539
msgid ""
"In Python 2.5 there's a simple way to pass values into a generator. :keyword:"
"`yield` became an expression, returning a value that can be assigned to a "
"variable or otherwise operated on::"
msgstr ""
"В Python 2.5 есть простой способ передачи значений в генератор. :keyword:"
"`yield` стал выражением, возвращающим значение, которое можно присвоить "
"переменной или иным образом обработать::"

#: ../../howto/functional.rst:543
msgid "val = (yield i)"
msgstr "val = (yield i)"

#: ../../howto/functional.rst:545
msgid ""
"I recommend that you **always** put parentheses around a ``yield`` "
"expression when you're doing something with the returned value, as in the "
"above example. The parentheses aren't always necessary, but it's easier to "
"always add them instead of having to remember when they're needed."
msgstr ""
"Я рекомендую вам **всегда** заключать в скобки выражение ``yield``, когда вы "
"что-то делаете с возвращаемым значением, как в приведенном выше примере. "
"Круглые скобки не всегда необходимы, но их проще всегда добавлять, чем "
"запоминать, когда они потребуются."

#: ../../howto/functional.rst:550
msgid ""
"(:pep:`342` explains the exact rules, which are that a ``yield``-expression "
"must always be parenthesized except when it occurs at the top-level "
"expression on the right-hand side of an assignment.  This means you can "
"write ``val = yield i`` but have to use parentheses when there's an "
"operation, as in ``val = (yield i) + 12``.)"
msgstr ""
"(:pep:`342` объясняет точные правила, которые заключаются в том, что "
"выражение ``yield`` всегда должно быть заключено в круглые скобки, за "
"исключением случаев, когда оно встречается в выражении верхнего уровня в "
"правой части присваивания. Это означает, что вы можно написать ``val = yield "
"i``, но при выполнении операции придется использовать круглые скобки, как в "
"``val = (yield i) + 12``.)"

#: ../../howto/functional.rst:556
msgid ""
"Values are sent into a generator by calling its :meth:`send(value) "
"<generator.send>` method.  This method resumes the generator's code and the "
"``yield`` expression returns the specified value.  If the regular :meth:"
"`~generator.__next__` method is called, the ``yield`` returns ``None``."
msgstr ""
"Значения отправляются в генератор путем вызова его метода :meth:`send(value) "
"<generator.send>`. Этот метод возобновляет выполнение кода генератора, и "
"выражение доходности возвращает указанное значение. Если вызывается обычный "
"метод :meth:`~generator.__next__`, ``yield`` возвращает ``None``."

#: ../../howto/functional.rst:561
msgid ""
"Here's a simple counter that increments by 1 and allows changing the value "
"of the internal counter."
msgstr ""
"Вот простой счетчик, который увеличивается на 1 и позволяет изменять "
"значение внутреннего счетчика."

#: ../../howto/functional.rst:564
msgid ""
"def counter(maximum):\n"
"    i = 0\n"
"    while i < maximum:\n"
"        val = (yield i)\n"
"        # If value provided, change counter\n"
"        if val is not None:\n"
"            i = val\n"
"        else:\n"
"            i += 1"
msgstr ""
"def counter(maximum):\n"
"    i = 0\n"
"    while i < maximum:\n"
"        val = (yield i)\n"
"        # If value provided, change counter\n"
"        if val is not None:\n"
"            i = val\n"
"        else:\n"
"            i += 1"

#: ../../howto/functional.rst:576
msgid "And here's an example of changing the counter:"
msgstr "А вот пример изменения счетчика:"

#: ../../howto/functional.rst:593
msgid ""
"Because ``yield`` will often be returning ``None``, you should always check "
"for this case.  Don't just use its value in expressions unless you're sure "
"that the :meth:`~generator.send` method will be the only method used to "
"resume your generator function."
msgstr ""
"Поскольку «yield» часто возвращает «None», вам всегда следует проверять этот "
"случай. Не используйте его значение в выражениях, если вы не уверены, что "
"метод :meth:`~generator.send` будет единственным методом, используемым для "
"возобновления функции генератора."

#: ../../howto/functional.rst:598
msgid ""
"In addition to :meth:`~generator.send`, there are two other methods on "
"generators:"
msgstr "Помимо :meth:`~generator.send`, в генераторах есть еще два метода:"

#: ../../howto/functional.rst:601
msgid ""
":meth:`throw(value) <generator.throw>` is used to raise an exception inside "
"the generator; the exception is raised by the ``yield`` expression where the "
"generator's execution is paused."
msgstr ""
":meth:`throw(value) <generator.throw>` используется для вызова исключения "
"внутри генератора; исключение вызывается выражением «yield», где выполнение "
"генератора приостанавливается."

#: ../../howto/functional.rst:605
msgid ""
":meth:`~generator.close` raises a :exc:`GeneratorExit` exception inside the "
"generator to terminate the iteration.  On receiving this exception, the "
"generator's code must either raise :exc:`GeneratorExit` or :exc:"
"`StopIteration`; catching the exception and doing anything else is illegal "
"and will trigger a :exc:`RuntimeError`.  :meth:`~generator.close` will also "
"be called by Python's garbage collector when the generator is garbage-"
"collected."
msgstr ""
":meth:`~generator.close` вызывает исключение :exc:`GeneratorExit` внутри "
"генератора для завершения итерации. При получении этого исключения код "
"генератора должен либо вызвать :exc:`GeneratorExit`, либо :exc:"
"`StopIteration`; перехват исключения и выполнение чего-либо еще является "
"незаконным и вызовет ошибку :exc:`RuntimeError`. :meth:`~generator.close` "
"также будет вызываться сборщиком мусора Python, когда генератор выполняет "
"сбор мусора."

#: ../../howto/functional.rst:613
msgid ""
"If you need to run cleanup code when a :exc:`GeneratorExit` occurs, I "
"suggest using a ``try: ... finally:`` suite instead of catching :exc:"
"`GeneratorExit`."
msgstr ""
"Если вам нужно запустить код очистки при возникновении :exc:`GeneratorExit`, "
"я предлагаю использовать ``try: ...finally:`` вместо перехвата :exc:"
"`GeneratorExit`."

#: ../../howto/functional.rst:616
msgid ""
"The cumulative effect of these changes is to turn generators from one-way "
"producers of information into both producers and consumers."
msgstr ""
"Совокупный эффект этих изменений состоит в том, чтобы превратить генераторов "
"из односторонних производителей информации в производителей и потребителей."

#: ../../howto/functional.rst:619
msgid ""
"Generators also become **coroutines**, a more generalized form of "
"subroutines. Subroutines are entered at one point and exited at another "
"point (the top of the function, and a ``return`` statement), but coroutines "
"can be entered, exited, and resumed at many different points (the ``yield`` "
"statements)."
msgstr ""
"Генераторы также становятся **сопрограммами**, более обобщенной формой "
"подпрограмм. Вход в подпрограммы осуществляется в одной точке, а выход из "
"них — в другой (верхняя часть функции и оператор return), но вход в "
"сопрограммы, выход из них и возобновление могут осуществляться во многих "
"разных точках (операторы return )."

#: ../../howto/functional.rst:626
msgid "Built-in functions"
msgstr "Встроенные функции"

#: ../../howto/functional.rst:628
msgid ""
"Let's look in more detail at built-in functions often used with iterators."
msgstr ""
"Давайте более подробно рассмотрим встроенные функции, часто используемые с "
"итераторами."

#: ../../howto/functional.rst:630
msgid ""
"Two of Python's built-in functions, :func:`map` and :func:`filter` duplicate "
"the features of generator expressions:"
msgstr ""
"Две встроенные функции Python, :func:`map` и :func:`filter`, дублируют "
"функции выражений-генераторов:"

#: ../../howto/functional.rst:633
msgid ""
":func:`map(f, iterA, iterB, ...) <map>` returns an iterator over the sequence"
msgstr ""
":func:`map(f, iterA, iterB, ...) <map>` возвращает итератор по "
"последовательности"

#: ../../howto/functional.rst:634
msgid ""
"``f(iterA[0], iterB[0]), f(iterA[1], iterB[1]), f(iterA[2], iterB[2]), ...``."
msgstr ""
"``f(iterA[0], iterB[0]), f(iterA[1], iterB[1]), f(iterA[2], iterB[2]), ...``."

#: ../../howto/functional.rst:644
msgid "You can of course achieve the same effect with a list comprehension."
msgstr ""
"Конечно, вы можете добиться того же эффекта, используя понимание списка."

#: ../../howto/functional.rst:646
msgid ""
":func:`filter(predicate, iter) <filter>` returns an iterator over all the "
"sequence elements that meet a certain condition, and is similarly duplicated "
"by list comprehensions.  A **predicate** is a function that returns the "
"truth value of some condition; for use with :func:`filter`, the predicate "
"must take a single value."
msgstr ""
":func:`filter(predicate, iter) <filter>` возвращает итератор по всем "
"элементам последовательности, которые соответствуют определенному условию, и "
"аналогичным образом дублируется при понимании списка. **Предикат** — это "
"функция, возвращающая истинное значение некоторого условия; для "
"использования с :func:`filter` предикат должен принимать одно значение."

#: ../../howto/functional.rst:659
msgid "This can also be written as a list comprehension:"
msgstr "Это также можно записать как понимание списка:"

#: ../../howto/functional.rst:665
msgid ""
":func:`enumerate(iter, start=0) <enumerate>` counts off the elements in the "
"iterable returning 2-tuples containing the count (from *start*) and each "
"element. ::"
msgstr ""
":func:`enumerate(iter, start=0) <enumerate>` подсчитывает элементы в "
"итерации, возвращая 2-кортежи, содержащие счетчик (из *start*) и каждый "
"элемент. ::"

#: ../../howto/functional.rst:669
msgid ""
">>> for item in enumerate(['subject', 'verb', 'object']):\n"
"...     print(item)\n"
"(0, 'subject')\n"
"(1, 'verb')\n"
"(2, 'object')"
msgstr ""
">>> for item in enumerate(['subject', 'verb', 'object']):\n"
"...     print(item)\n"
"(0, 'subject')\n"
"(1, 'verb')\n"
"(2, 'object')"

#: ../../howto/functional.rst:675
msgid ""
":func:`enumerate` is often used when looping through a list and recording "
"the indexes at which certain conditions are met::"
msgstr ""
":func:`enumerate` часто используется при циклическом просмотре списка и "
"записи индексов, при которых выполняются определенные условия::"

#: ../../howto/functional.rst:678
msgid ""
"f = open('data.txt', 'r')\n"
"for i, line in enumerate(f):\n"
"    if line.strip() == '':\n"
"        print('Blank line at line #%i' % i)"
msgstr ""
"f = open('data.txt', 'r')\n"
"for i, line in enumerate(f):\n"
"    if line.strip() == '':\n"
"        print('Blank line at line #%i' % i)"

#: ../../howto/functional.rst:683
msgid ""
":func:`sorted(iterable, key=None, reverse=False) <sorted>` collects all the "
"elements of the iterable into a list, sorts the list, and returns the sorted "
"result.  The *key* and *reverse* arguments are passed through to the "
"constructed list's :meth:`~list.sort` method. ::"
msgstr ""
":func:`sorted(iterable, key=None,verse=False) <sorted>` собирает все "
"элементы итерируемого объекта в список, сортирует его и возвращает "
"отсортированный результат. Аргументы *key* и *reverse* передаются в метод :"
"meth:`~list.sort` созданного списка. ::"

#: ../../howto/functional.rst:688
msgid ""
">>> import random\n"
">>> # Generate 8 random numbers between [0, 10000)\n"
">>> rand_list = random.sample(range(10000), 8)\n"
">>> rand_list\n"
"[769, 7953, 9828, 6431, 8442, 9878, 6213, 2207]\n"
">>> sorted(rand_list)\n"
"[769, 2207, 6213, 6431, 7953, 8442, 9828, 9878]\n"
">>> sorted(rand_list, reverse=True)\n"
"[9878, 9828, 8442, 7953, 6431, 6213, 2207, 769]"
msgstr ""
">>> import random\n"
">>> # Generate 8 random numbers between [0, 10000)\n"
">>> rand_list = random.sample(range(10000), 8)\n"
">>> rand_list\n"
"[769, 7953, 9828, 6431, 8442, 9878, 6213, 2207]\n"
">>> sorted(rand_list)\n"
"[769, 2207, 6213, 6431, 7953, 8442, 9828, 9878]\n"
">>> sorted(rand_list, reverse=True)\n"
"[9878, 9828, 8442, 7953, 6431, 6213, 2207, 769]"

#: ../../howto/functional.rst:698
msgid ""
"(For a more detailed discussion of sorting, see the :ref:`sortinghowto`.)"
msgstr ""
"(Более подробное обсуждение сортировки см. в разделе :ref:`sortinghowto`.)"

#: ../../howto/functional.rst:701
msgid ""
"The :func:`any(iter) <any>` and :func:`all(iter) <all>` built-ins look at "
"the truth values of an iterable's contents.  :func:`any` returns ``True`` if "
"any element in the iterable is a true value, and :func:`all` returns "
"``True`` if all of the elements are true values:"
msgstr ""
"Встроенные функции :func:`any(iter) <any>` и :func:`all(iter) <all>` "
"проверяют истинностные значения содержимого итерируемого объекта. :func:"
"`any` возвращает ``True``, если какой-либо элемент в итерируемом объекте "
"является истинным значением, а :func:`all` возвращает ``True``, если все "
"элементы являются истинными значениями:"

#: ../../howto/functional.rst:720
msgid ""
":func:`zip(iterA, iterB, ...) <zip>` takes one element from each iterable "
"and returns them in a tuple::"
msgstr ""
":func:`zip(iterA, iterB, ...) <zip>` берет по одному элементу из каждой "
"итерации и возвращает их в кортеже::"

#: ../../howto/functional.rst:723
msgid ""
"zip(['a', 'b', 'c'], (1, 2, 3)) =>\n"
"  ('a', 1), ('b', 2), ('c', 3)"
msgstr ""
"zip(['a', 'b', 'c'], (1, 2, 3)) =>\n"
"  ('a', 1), ('b', 2), ('c', 3)"

#: ../../howto/functional.rst:726
msgid ""
"It doesn't construct an in-memory list and exhaust all the input iterators "
"before returning; instead tuples are constructed and returned only if "
"they're requested.  (The technical term for this behaviour is `lazy "
"evaluation <https://en.wikipedia.org/wiki/Lazy_evaluation>`__.)"
msgstr ""
"Он не создает список в памяти и не исчерпывает все входные итераторы перед "
"возвратом; вместо этого кортежи создаются и возвращаются только в том "
"случае, если они запрошены. (Технический термин для такого поведения — "
"`ленивая оценка <https://en.wikipedia.org/wiki/Lazy_evaluation>`__.)"

#: ../../howto/functional.rst:731
msgid ""
"This iterator is intended to be used with iterables that are all of the same "
"length.  If the iterables are of different lengths, the resulting stream "
"will be the same length as the shortest iterable. ::"
msgstr ""
"Этот итератор предназначен для использования с итерациями одинаковой длины. "
"Если итерации имеют разную длину, результирующий поток будет той же длины, "
"что и самая короткая итерация. ::"

#: ../../howto/functional.rst:735
msgid ""
"zip(['a', 'b'], (1, 2, 3)) =>\n"
"  ('a', 1), ('b', 2)"
msgstr ""
"zip(['a', 'b'], (1, 2, 3)) =>\n"
"  ('a', 1), ('b', 2)"

#: ../../howto/functional.rst:738
msgid ""
"You should avoid doing this, though, because an element may be taken from "
"the longer iterators and discarded.  This means you can't go on to use the "
"iterators further because you risk skipping a discarded element."
msgstr ""
"Однако вам следует избегать этого, поскольку элемент может быть взят из "
"более длинных итераторов и отброшен. Это означает, что вы не можете "
"использовать итераторы дальше, потому что рискуете пропустить отброшенный "
"элемент."

#: ../../howto/functional.rst:744
msgid "The itertools module"
msgstr "Модуль itertools"

#: ../../howto/functional.rst:746
msgid ""
"The :mod:`itertools` module contains a number of commonly used iterators as "
"well as functions for combining several iterators.  This section will "
"introduce the module's contents by showing small examples."
msgstr ""
"Модуль :mod:`itertools` содержит ряд часто используемых итераторов, а также "
"функции для объединения нескольких итераторов. В этом разделе будет "
"представлено содержимое модуля на небольших примерах."

#: ../../howto/functional.rst:750
msgid "The module's functions fall into a few broad classes:"
msgstr "Функции модуля делятся на несколько широких классов:"

#: ../../howto/functional.rst:752
msgid "Functions that create a new iterator based on an existing iterator."
msgstr "Функции, создающие новый итератор на основе существующего итератора."

#: ../../howto/functional.rst:753
msgid "Functions for treating an iterator's elements as function arguments."
msgstr "Функции для обработки элементов итератора как аргументов функции."

#: ../../howto/functional.rst:754
msgid "Functions for selecting portions of an iterator's output."
msgstr "Функции для выбора частей вывода итератора."

#: ../../howto/functional.rst:755
msgid "A function for grouping an iterator's output."
msgstr "Функция для группировки вывода итератора."

#: ../../howto/functional.rst:758
msgid "Creating new iterators"
msgstr "Создание новых итераторов"

#: ../../howto/functional.rst:760
msgid ""
":func:`itertools.count(start, step) <itertools.count>` returns an infinite "
"stream of evenly spaced values.  You can optionally supply the starting "
"number, which defaults to 0, and the interval between numbers, which "
"defaults to 1::"
msgstr ""
":func:`itertools.count(start, Step) <itertools.count>` возвращает "
"бесконечный поток равномерно распределенных значений. При желании вы можете "
"указать начальный номер, который по умолчанию равен 0, и интервал между "
"числами, который по умолчанию равен 1::"

#: ../../howto/functional.rst:764
msgid ""
"itertools.count() =>\n"
"  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ...\n"
"itertools.count(10) =>\n"
"  10, 11, 12, 13, 14, 15, 16, 17, 18, 19, ...\n"
"itertools.count(10, 5) =>\n"
"  10, 15, 20, 25, 30, 35, 40, 45, 50, 55, ..."
msgstr ""
"itertools.count() =>\n"
"  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ...\n"
"itertools.count(10) =>\n"
"  10, 11, 12, 13, 14, 15, 16, 17, 18, 19, ...\n"
"itertools.count(10, 5) =>\n"
"  10, 15, 20, 25, 30, 35, 40, 45, 50, 55, ..."

#: ../../howto/functional.rst:771
msgid ""
":func:`itertools.cycle(iter) <itertools.cycle>` saves a copy of the contents "
"of a provided iterable and returns a new iterator that returns its elements "
"from first to last.  The new iterator will repeat these elements "
"infinitely. ::"
msgstr ""
":func:`itertools.cycle(iter) <itertools.cycle>` сохраняет копию содержимого "
"предоставленной итерации и возвращает новый итератор, который возвращает его "
"элементы от первого до последнего. Новый итератор будет повторять эти "
"элементы бесконечно. ::"

#: ../../howto/functional.rst:775
msgid ""
"itertools.cycle([1, 2, 3, 4, 5]) =>\n"
"  1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ..."
msgstr ""
"itertools.cycle([1, 2, 3, 4, 5]) =>\n"
"  1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ..."

#: ../../howto/functional.rst:778
msgid ""
":func:`itertools.repeat(elem, [n]) <itertools.repeat>` returns the provided "
"element *n* times, or returns the element endlessly if *n* is not "
"provided. ::"
msgstr ""
":func:`itertools.repeat(elem, [n]) <itertools.repeat>` возвращает "
"предоставленный элемент *n* раз или возвращает элемент бесконечно, если *n* "
"не указано. ::"

#: ../../howto/functional.rst:781
msgid ""
"itertools.repeat('abc') =>\n"
"  abc, abc, abc, abc, abc, abc, abc, abc, abc, abc, ...\n"
"itertools.repeat('abc', 5) =>\n"
"  abc, abc, abc, abc, abc"
msgstr ""
"itertools.repeat('abc') =>\n"
"  abc, abc, abc, abc, abc, abc, abc, abc, abc, abc, ...\n"
"itertools.repeat('abc', 5) =>\n"
"  abc, abc, abc, abc, abc"

#: ../../howto/functional.rst:786
msgid ""
":func:`itertools.chain(iterA, iterB, ...) <itertools.chain>` takes an "
"arbitrary number of iterables as input, and returns all the elements of the "
"first iterator, then all the elements of the second, and so on, until all of "
"the iterables have been exhausted. ::"
msgstr ""
":func:`itertools.chain(iterA, iterB, ...) <itertools.chain>` принимает на "
"вход произвольное количество итераций и возвращает все элементы первого "
"итератора, затем все элементы второго и и так далее, пока все итерации не "
"будут исчерпаны. ::"

#: ../../howto/functional.rst:791
msgid ""
"itertools.chain(['a', 'b', 'c'], (1, 2, 3)) =>\n"
"  a, b, c, 1, 2, 3"
msgstr ""
"itertools.chain(['a', 'b', 'c'], (1, 2, 3)) =>\n"
"  a, b, c, 1, 2, 3"

#: ../../howto/functional.rst:794
msgid ""
":func:`itertools.islice(iter, [start], stop, [step]) <itertools.islice>` "
"returns a stream that's a slice of the iterator.  With a single *stop* "
"argument, it will return the first *stop* elements.  If you supply a "
"starting index, you'll get *stop-start* elements, and if you supply a value "
"for *step*, elements will be skipped accordingly.  Unlike Python's string "
"and list slicing, you can't use negative values for *start*, *stop*, or "
"*step*. ::"
msgstr ""
":func:`itertools.islice(iter, [start], stop, [step]) <itertools.islice>` "
"возвращает поток, который является частью итератора. С единственным "
"аргументом *stop* он вернет первые элементы *stop*. Если вы укажете "
"начальный индекс, вы получите элементы *stop-start*, а если вы укажете "
"значение для *step*, элементы будут соответственно пропущены. В отличие от "
"разделения строк и списков в Python, вы не можете использовать отрицательные "
"значения для *start*, *stop* или *step*. ::"

#: ../../howto/functional.rst:801
msgid ""
"itertools.islice(range(10), 8) =>\n"
"  0, 1, 2, 3, 4, 5, 6, 7\n"
"itertools.islice(range(10), 2, 8) =>\n"
"  2, 3, 4, 5, 6, 7\n"
"itertools.islice(range(10), 2, 8, 2) =>\n"
"  2, 4, 6"
msgstr ""
"itertools.islice(диапазон(10), 8) => 0, 1, 2, 3, 4, 5, 6, 7 itertools."
"islice(диапазон(10), 2, 8) => 2, 3, 4, 5, 6, 7 itertools."
"islice(диапазон(10), 2, 8, 2) => 2, 4, 6"

#: ../../howto/functional.rst:808
msgid ""
":func:`itertools.tee(iter, [n]) <itertools.tee>` replicates an iterator; it "
"returns *n* independent iterators that will all return the contents of the "
"source iterator. If you don't supply a value for *n*, the default is 2.  "
"Replicating iterators requires saving some of the contents of the source "
"iterator, so this can consume significant memory if the iterator is large "
"and one of the new iterators is consumed more than the others. ::"
msgstr ""
":func:`itertools.tee(iter, [n]) <itertools.tee>` копирует итератор; он "
"возвращает *n* независимых итераторов, которые возвращают содержимое "
"исходного итератора. Если вы не указали значение для *n*, значением по "
"умолчанию будет 2. Репликация итераторов требует сохранения части "
"содержимого исходного итератора, поэтому это может занять значительный объем "
"памяти, если итератор большой и используется один из новых итераторов. "
"больше, чем другие. ::"

#: ../../howto/functional.rst:816
msgid ""
"itertools.tee( itertools.count() ) =>\n"
"   iterA, iterB\n"
"\n"
"where iterA ->\n"
"   0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ...\n"
"\n"
"and   iterB ->\n"
"   0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ..."
msgstr ""
"itertools.tee( itertools.count() ) =>\n"
"   iterA, iterB\n"
"\n"
"where iterA ->\n"
"   0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ...\n"
"\n"
"and   iterB ->\n"
"   0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ..."

#: ../../howto/functional.rst:827
msgid "Calling functions on elements"
msgstr "Вызов функций для элементов"

#: ../../howto/functional.rst:829
msgid ""
"The :mod:`operator` module contains a set of functions corresponding to "
"Python's operators.  Some examples are :func:`operator.add(a, b) <operator."
"add>` (adds two values), :func:`operator.ne(a, b)  <operator.ne>` (same as "
"``a != b``), and :func:`operator.attrgetter('id') <operator.attrgetter>` "
"(returns a callable that fetches the ``.id`` attribute)."
msgstr ""
"Модуль :mod:`operator` содержит набор функций, соответствующих операторам "
"Python. Некоторые примеры: :func:`operator.add(a, b) <operator.add>` "
"(добавляет два значения), :func:`operator.ne(a, b) <operator.ne>` (то же "
"самое, что `` a != b``) и :func:`operator.attrgetter('id') <operator."
"attrgetter>` (возвращает вызываемый объект, который извлекает атрибут ``."
"id``)."

#: ../../howto/functional.rst:835
msgid ""
":func:`itertools.starmap(func, iter) <itertools.starmap>` assumes that the "
"iterable will return a stream of tuples, and calls *func* using these tuples "
"as the arguments::"
msgstr ""
":func:`itertools.starmap(func, iter) <itertools.starmap>` предполагает, что "
"итерируемый объект вернет поток кортежей, и вызывает *func*, используя эти "
"кортежи в качестве аргументов::"

#: ../../howto/functional.rst:839
msgid ""
"itertools.starmap(os.path.join,\n"
"                  [('/bin', 'python'), ('/usr', 'bin', 'java'),\n"
"                   ('/usr', 'bin', 'perl'), ('/usr', 'bin', 'ruby')])\n"
"=>\n"
"  /bin/python, /usr/bin/java, /usr/bin/perl, /usr/bin/ruby"
msgstr ""
"itertools.starmap(os.path.join,\n"
"                  [('/bin', 'python'), ('/usr', 'bin', 'java'),\n"
"                   ('/usr', 'bin', 'perl'), ('/usr', 'bin', 'ruby')])\n"
"=>\n"
"  /bin/python, /usr/bin/java, /usr/bin/perl, /usr/bin/ruby"

#: ../../howto/functional.rst:847
msgid "Selecting elements"
msgstr "Выбор элементов"

#: ../../howto/functional.rst:849
msgid ""
"Another group of functions chooses a subset of an iterator's elements based "
"on a predicate."
msgstr ""
"Другая группа функций выбирает подмножество элементов итератора на основе "
"предиката."

#: ../../howto/functional.rst:852
msgid ""
":func:`itertools.filterfalse(predicate, iter) <itertools.filterfalse>` is "
"the opposite of :func:`filter`, returning all elements for which the "
"predicate returns false::"
msgstr ""
":func:`itertools.filterfalse(predicate, iter) <itertools.filterfalse>` "
"является противоположностью :func:`filter`, возвращая все элементы, для "
"которых предикат возвращает false::"

#: ../../howto/functional.rst:856
msgid ""
"itertools.filterfalse(is_even, itertools.count()) =>\n"
"  1, 3, 5, 7, 9, 11, 13, 15, ..."
msgstr ""
"itertools.filterfalse(is_even, itertools.count()) =>\n"
"  1, 3, 5, 7, 9, 11, 13, 15, ..."

#: ../../howto/functional.rst:859
msgid ""
":func:`itertools.takewhile(predicate, iter) <itertools.takewhile>` returns "
"elements for as long as the predicate returns true.  Once the predicate "
"returns false, the iterator will signal the end of its results. ::"
msgstr ""
":func:`itertools.take while(predicate, iter) <itertools.take while>` "
"возвращает элементы до тех пор, пока предикат возвращает true. Как только "
"предикат вернет false, итератор сообщит об окончании своих результатов. ::"

#: ../../howto/functional.rst:863
msgid ""
"def less_than_10(x):\n"
"    return x < 10\n"
"\n"
"itertools.takewhile(less_than_10, itertools.count()) =>\n"
"  0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n"
"\n"
"itertools.takewhile(is_even, itertools.count()) =>\n"
"  0"
msgstr ""
"def less_than_10(x):\n"
"    return x < 10\n"
"\n"
"itertools.takewhile(less_than_10, itertools.count()) =>\n"
"  0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n"
"\n"
"itertools.takewhile(is_even, itertools.count()) =>\n"
"  0"

#: ../../howto/functional.rst:872
msgid ""
":func:`itertools.dropwhile(predicate, iter) <itertools.dropwhile>` discards "
"elements while the predicate returns true, and then returns the rest of the "
"iterable's results. ::"
msgstr ""
":func:`itertools.drop while(predicate, iter) <itertools.drop while>` "
"отбрасывает элементы, пока предикат возвращает true, а затем возвращает "
"остальные результаты итерации. ::"

#: ../../howto/functional.rst:876
msgid ""
"itertools.dropwhile(less_than_10, itertools.count()) =>\n"
"  10, 11, 12, 13, 14, 15, 16, 17, 18, 19, ...\n"
"\n"
"itertools.dropwhile(is_even, itertools.count()) =>\n"
"  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ..."
msgstr ""
"itertools.dropwhile(less_than_10, itertools.count()) =>\n"
"  10, 11, 12, 13, 14, 15, 16, 17, 18, 19, ...\n"
"\n"
"itertools.dropwhile(is_even, itertools.count()) =>\n"
"  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ..."

#: ../../howto/functional.rst:882
msgid ""
":func:`itertools.compress(data, selectors) <itertools.compress>` takes two "
"iterators and returns only those elements of *data* for which the "
"corresponding element of *selectors* is true, stopping whenever either one "
"is exhausted::"
msgstr ""
":func:`itertools.compress(data, selectors) <itertools.compress>` принимает "
"два итератора и возвращает только те элементы *data*, для которых "
"соответствующий элемент *selectors* является истинным, останавливаясь всякий "
"раз, когда любой из них исчерпан::"

#: ../../howto/functional.rst:886
msgid ""
"itertools.compress([1, 2, 3, 4, 5], [True, True, False, False, True]) =>\n"
"   1, 2, 5"
msgstr ""
"itertools.compress([1, 2, 3, 4, 5], [True, True, False, False, True]) =>\n"
"   1, 2, 5"

#: ../../howto/functional.rst:891
msgid "Combinatoric functions"
msgstr "Комбинаторные функции"

#: ../../howto/functional.rst:893
msgid ""
"The :func:`itertools.combinations(iterable, r) <itertools.combinations>` "
"returns an iterator giving all possible *r*-tuple combinations of the "
"elements contained in *iterable*.  ::"
msgstr ""
":func:`itertools.combinations(iterable, r) <itertools.combinations>` "
"возвращает итератор, дающий все возможные комбинации *r*-кортежей элементов, "
"содержащихся в *iterable*. ::"

#: ../../howto/functional.rst:897
msgid ""
"itertools.combinations([1, 2, 3, 4, 5], 2) =>\n"
"  (1, 2), (1, 3), (1, 4), (1, 5),\n"
"  (2, 3), (2, 4), (2, 5),\n"
"  (3, 4), (3, 5),\n"
"  (4, 5)\n"
"\n"
"itertools.combinations([1, 2, 3, 4, 5], 3) =>\n"
"  (1, 2, 3), (1, 2, 4), (1, 2, 5), (1, 3, 4), (1, 3, 5), (1, 4, 5),\n"
"  (2, 3, 4), (2, 3, 5), (2, 4, 5),\n"
"  (3, 4, 5)"
msgstr ""
"itertools.combinations([1, 2, 3, 4, 5], 2) =>\n"
"  (1, 2), (1, 3), (1, 4), (1, 5),\n"
"  (2, 3), (2, 4), (2, 5),\n"
"  (3, 4), (3, 5),\n"
"  (4, 5)\n"
"\n"
"itertools.combinations([1, 2, 3, 4, 5], 3) =>\n"
"  (1, 2, 3), (1, 2, 4), (1, 2, 5), (1, 3, 4), (1, 3, 5), (1, 4, 5),\n"
"  (2, 3, 4), (2, 3, 5), (2, 4, 5),\n"
"  (3, 4, 5)"

#: ../../howto/functional.rst:908
msgid ""
"The elements within each tuple remain in the same order as *iterable* "
"returned them.  For example, the number 1 is always before 2, 3, 4, or 5 in "
"the examples above.  A similar function, :func:`itertools."
"permutations(iterable, r=None) <itertools.permutations>`, removes this "
"constraint on the order, returning all possible arrangements of length *r*::"
msgstr ""
"Элементы внутри каждого кортежа остаются в том же порядке, в котором их "
"вернул *iterable*. Например, в приведенных выше примерах число 1 всегда "
"предшествует 2, 3, 4 или 5. Аналогичная функция, :func:`itertools."
"permutations(iterable, r=None) <itertools.permutations>`, удаляет это "
"ограничение на порядок, возвращая все возможные варианты длины *r*::"

#: ../../howto/functional.rst:915
msgid ""
"itertools.permutations([1, 2, 3, 4, 5], 2) =>\n"
"  (1, 2), (1, 3), (1, 4), (1, 5),\n"
"  (2, 1), (2, 3), (2, 4), (2, 5),\n"
"  (3, 1), (3, 2), (3, 4), (3, 5),\n"
"  (4, 1), (4, 2), (4, 3), (4, 5),\n"
"  (5, 1), (5, 2), (5, 3), (5, 4)\n"
"\n"
"itertools.permutations([1, 2, 3, 4, 5]) =>\n"
"  (1, 2, 3, 4, 5), (1, 2, 3, 5, 4), (1, 2, 4, 3, 5),\n"
"  ...\n"
"  (5, 4, 3, 2, 1)"
msgstr ""
"itertools.permutations([1, 2, 3, 4, 5], 2) =>\n"
"  (1, 2), (1, 3), (1, 4), (1, 5),\n"
"  (2, 1), (2, 3), (2, 4), (2, 5),\n"
"  (3, 1), (3, 2), (3, 4), (3, 5),\n"
"  (4, 1), (4, 2), (4, 3), (4, 5),\n"
"  (5, 1), (5, 2), (5, 3), (5, 4)\n"
"\n"
"itertools.permutations([1, 2, 3, 4, 5]) =>\n"
"  (1, 2, 3, 4, 5), (1, 2, 3, 5, 4), (1, 2, 4, 3, 5),\n"
"  ...\n"
"  (5, 4, 3, 2, 1)"

#: ../../howto/functional.rst:927
msgid ""
"If you don't supply a value for *r* the length of the iterable is used, "
"meaning that all the elements are permuted."
msgstr ""
"Если вы не указали значение для *r*, используется длина итерации, что "
"означает, что все элементы переставляются."

#: ../../howto/functional.rst:930
msgid ""
"Note that these functions produce all of the possible combinations by "
"position and don't require that the contents of *iterable* are unique::"
msgstr ""
"Обратите внимание, что эти функции создают все возможные комбинации по "
"позиции и не требуют, чтобы содержимое *iterable* было уникальным::"

#: ../../howto/functional.rst:933
msgid ""
"itertools.permutations('aba', 3) =>\n"
"  ('a', 'b', 'a'), ('a', 'a', 'b'), ('b', 'a', 'a'),\n"
"  ('b', 'a', 'a'), ('a', 'a', 'b'), ('a', 'b', 'a')"
msgstr ""
"itertools.permutations('aba', 3) =>\n"
"  ('a', 'b', 'a'), ('a', 'a', 'b'), ('b', 'a', 'a'),\n"
"  ('b', 'a', 'a'), ('a', 'a', 'b'), ('a', 'b', 'a')"

#: ../../howto/functional.rst:937
msgid ""
"The identical tuple ``('a', 'a', 'b')`` occurs twice, but the two 'a' "
"strings came from different positions."
msgstr ""
"Идентичный кортеж ``('a', 'a', 'b')`` встречается дважды, но две строки 'a' "
"находятся в разных позициях."

#: ../../howto/functional.rst:940
msgid ""
"The :func:`itertools.combinations_with_replacement(iterable, r) <itertools."
"combinations_with_replacement>` function relaxes a different constraint: "
"elements can be repeated within a single tuple.  Conceptually an element is "
"selected for the first position of each tuple and then is replaced before "
"the second element is selected.  ::"
msgstr ""
"Функция :func:`itertools.combinations_with_replacement(iterable, r) "
"<itertools.combinations_with_replacement>` ослабляет другое ограничение: "
"элементы могут повторяться в пределах одного кортежа. Концептуально элемент "
"выбирается для первой позиции каждого кортежа, а затем заменяется перед "
"выбором второго элемента. ::"

#: ../../howto/functional.rst:946
msgid ""
"itertools.combinations_with_replacement([1, 2, 3, 4, 5], 2) =>\n"
"  (1, 1), (1, 2), (1, 3), (1, 4), (1, 5),\n"
"  (2, 2), (2, 3), (2, 4), (2, 5),\n"
"  (3, 3), (3, 4), (3, 5),\n"
"  (4, 4), (4, 5),\n"
"  (5, 5)"
msgstr ""
"itertools.combinations_with_replacement([1, 2, 3, 4, 5], 2) =>\n"
"  (1, 1), (1, 2), (1, 3), (1, 4), (1, 5),\n"
"  (2, 2), (2, 3), (2, 4), (2, 5),\n"
"  (3, 3), (3, 4), (3, 5),\n"
"  (4, 4), (4, 5),\n"
"  (5, 5)"

#: ../../howto/functional.rst:955
msgid "Grouping elements"
msgstr "Группировка элементов"

#: ../../howto/functional.rst:957
msgid ""
"The last function I'll discuss, :func:`itertools.groupby(iter, "
"key_func=None) <itertools.groupby>`, is the most complicated.  "
"``key_func(elem)`` is a function that can compute a key value for each "
"element returned by the iterable.  If you don't supply a key function, the "
"key is simply each element itself."
msgstr ""
"Последняя функция, которую я обсужу, :func:`itertools.groupby(iter, "
"key_func=None) <itertools.groupby>`, является самой сложной. "
"``key_func(elem)`` — это функция, которая может вычислять значение ключа для "
"каждого элемента, возвращаемого итерацией. Если вы не указали ключевую "
"функцию, то ключом будет просто каждый элемент."

#: ../../howto/functional.rst:962
msgid ""
":func:`~itertools.groupby` collects all the consecutive elements from the "
"underlying iterable that have the same key value, and returns a stream of 2-"
"tuples containing a key value and an iterator for the elements with that key."
msgstr ""
":func:`~itertools.groupby` собирает все последовательные элементы базовой "
"итерации, имеющие одинаковое значение ключа, и возвращает поток из двух "
"кортежей, содержащих значение ключа и итератор для элементов с этим ключом."

#: ../../howto/functional.rst:968
msgid ""
"city_list = [('Decatur', 'AL'), ('Huntsville', 'AL'), ('Selma', 'AL'),\n"
"             ('Anchorage', 'AK'), ('Nome', 'AK'),\n"
"             ('Flagstaff', 'AZ'), ('Phoenix', 'AZ'), ('Tucson', 'AZ'),\n"
"             ...\n"
"            ]\n"
"\n"
"def get_state(city_state):\n"
"    return city_state[1]\n"
"\n"
"itertools.groupby(city_list, get_state) =>\n"
"  ('AL', iterator-1),\n"
"  ('AK', iterator-2),\n"
"  ('AZ', iterator-3), ...\n"
"\n"
"where\n"
"iterator-1 =>\n"
"  ('Decatur', 'AL'), ('Huntsville', 'AL'), ('Selma', 'AL')\n"
"iterator-2 =>\n"
"  ('Anchorage', 'AK'), ('Nome', 'AK')\n"
"iterator-3 =>\n"
"  ('Flagstaff', 'AZ'), ('Phoenix', 'AZ'), ('Tucson', 'AZ')"
msgstr ""
"city_list = [('Decatur', 'AL'), ('Huntsville', 'AL'), ('Selma', 'AL'),\n"
"             ('Anchorage', 'AK'), ('Nome', 'AK'),\n"
"             ('Flagstaff', 'AZ'), ('Phoenix', 'AZ'), ('Tucson', 'AZ'),\n"
"             ...\n"
"            ]\n"
"\n"
"def get_state(city_state):\n"
"    return city_state[1]\n"
"\n"
"itertools.groupby(city_list, get_state) =>\n"
"  ('AL', iterator-1),\n"
"  ('AK', iterator-2),\n"
"  ('AZ', iterator-3), ...\n"
"\n"
"where\n"
"iterator-1 =>\n"
"  ('Decatur', 'AL'), ('Huntsville', 'AL'), ('Selma', 'AL')\n"
"iterator-2 =>\n"
"  ('Anchorage', 'AK'), ('Nome', 'AK')\n"
"iterator-3 =>\n"
"  ('Flagstaff', 'AZ'), ('Phoenix', 'AZ'), ('Tucson', 'AZ')"

#: ../../howto/functional.rst:990
msgid ""
":func:`~itertools.groupby` assumes that the underlying iterable's contents "
"will already be sorted based on the key.  Note that the returned iterators "
"also use the underlying iterable, so you have to consume the results of "
"iterator-1 before requesting iterator-2 and its corresponding key."
msgstr ""
":func:`~itertools.groupby` предполагает, что содержимое базовой итерации уже "
"отсортировано на основе ключа. Обратите внимание, что возвращаемые итераторы "
"также используют базовый итератор, поэтому вам необходимо использовать "
"результаты итератора-1 перед запросом итератора-2 и соответствующего ему "
"ключа."

#: ../../howto/functional.rst:997
msgid "The functools module"
msgstr "Модуль functools"

#: ../../howto/functional.rst:999
msgid ""
"The :mod:`functools` module contains some higher-order functions. A **higher-"
"order function** takes one or more functions as input and returns a new "
"function.  The most useful tool in this module is the :func:`functools."
"partial` function."
msgstr ""
"Модуль :mod:`functools` содержит некоторые функции высшего порядка. "
"**Функция высшего порядка** принимает на вход одну или несколько функций и "
"возвращает новую функцию. Самый полезный инструмент в этом модуле — функция :"
"func:`functools.partial`."

#: ../../howto/functional.rst:1004
msgid ""
"For programs written in a functional style, you'll sometimes want to "
"construct variants of existing functions that have some of the parameters "
"filled in. Consider a Python function ``f(a, b, c)``; you may wish to create "
"a new function ``g(b, c)`` that's equivalent to ``f(1, b, c)``; you're "
"filling in a value for one of ``f()``'s parameters.  This is called "
"\"partial function application\"."
msgstr ""
"Для программ, написанных в функциональном стиле, вам иногда потребуется "
"создать варианты существующих функций, в которых некоторые параметры будут "
"заполнены. Рассмотрим функцию Python ``f(a, b, c)``; вы можете создать новую "
"функцию ``g(b, c)``, эквивалентную ``f(1, b, c)``; вы вводите значение для "
"одного из параметров ``f()``. Это называется «приложение частичной функции»."

#: ../../howto/functional.rst:1010
msgid ""
"The constructor for :func:`~functools.partial` takes the arguments "
"``(function, arg1, arg2, ..., kwarg1=value1, kwarg2=value2)``.  The "
"resulting object is callable, so you can just call it to invoke ``function`` "
"with the filled-in arguments."
msgstr ""
"Конструктор :func:`~functools.partial` принимает аргументы ``(function, "
"arg1, arg2, ..., kwarg1=value1, kwarg2=value2)``. Полученный объект является "
"вызываемым, поэтому вы можете просто вызвать его для вызова ``функции`` с "
"заполненными аргументами."

#: ../../howto/functional.rst:1015
msgid "Here's a small but realistic example::"
msgstr "Вот небольшой, но реалистичный пример:"

#: ../../howto/functional.rst:1017
msgid ""
"import functools\n"
"\n"
"def log(message, subsystem):\n"
"    \"\"\"Write the contents of 'message' to the specified subsystem.\"\"\"\n"
"    print('%s: %s' % (subsystem, message))\n"
"    ...\n"
"\n"
"server_log = functools.partial(log, subsystem='server')\n"
"server_log('Unable to open socket')"
msgstr ""
"import functools\n"
"\n"
"def log(message, subsystem):\n"
"    \"\"\"Write the contents of 'message' to the specified subsystem.\"\"\"\n"
"    print('%s: %s' % (subsystem, message))\n"
"    ...\n"
"\n"
"server_log = functools.partial(log, subsystem='server')\n"
"server_log('Unable to open socket')"

#: ../../howto/functional.rst:1027
msgid ""
":func:`functools.reduce(func, iter, [initial_value]) <functools.reduce>` "
"cumulatively performs an operation on all the iterable's elements and, "
"therefore, can't be applied to infinite iterables. *func* must be a function "
"that takes two elements and returns a single value.  :func:`functools."
"reduce` takes the first two elements A and B returned by the iterator and "
"calculates ``func(A, B)``.  It then requests the third element, C, "
"calculates ``func(func(A, B), C)``, combines this result with the fourth "
"element returned, and continues until the iterable is exhausted.  If the "
"iterable returns no values at all, a :exc:`TypeError` exception is raised.  "
"If the initial value is supplied, it's used as a starting point and "
"``func(initial_value, A)`` is the first calculation. ::"
msgstr ""
":func:`functools.reduce(func, iter, [initial_value]) <functools.reduce>` "
"кумулятивно выполняет операцию над всеми элементами итерируемого объекта и, "
"следовательно, не может применяться к бесконечным итерируемым объектам. "
"*func* должна быть функцией, которая принимает два элемента и возвращает "
"одно значение. :func:`functools.reduce` принимает первые два элемента A и B, "
"возвращенные итератором, и вычисляет ``func(A, B)``. Затем он запрашивает "
"третий элемент C, вычисляет ``func(func(A, B), C)``, объединяет этот "
"результат с возвращенным четвертым элементом и продолжает до тех пор, пока "
"итерация не будет исчерпана. Если итерируемый объект вообще не возвращает "
"никаких значений, возникает исключение :exc:`TypeError`. Если указано "
"начальное значение, оно используется в качестве отправной точки, а "
"func(initial_value, A) — это первый расчет. ::"

#: ../../howto/functional.rst:1039
msgid ""
">>> import operator, functools\n"
">>> functools.reduce(operator.concat, ['A', 'BB', 'C'])\n"
"'ABBC'\n"
">>> functools.reduce(operator.concat, [])\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: reduce() of empty sequence with no initial value\n"
">>> functools.reduce(operator.mul, [1, 2, 3], 1)\n"
"6\n"
">>> functools.reduce(operator.mul, [], 1)\n"
"1"
msgstr ""
">>> import operator, functools\n"
">>> functools.reduce(operator.concat, ['A', 'BB', 'C'])\n"
"'ABBC'\n"
">>> functools.reduce(operator.concat, [])\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: reduce() of empty sequence with no initial value\n"
">>> functools.reduce(operator.mul, [1, 2, 3], 1)\n"
"6\n"
">>> functools.reduce(operator.mul, [], 1)\n"
"1"

#: ../../howto/functional.rst:1051
msgid ""
"If you use :func:`operator.add` with :func:`functools.reduce`, you'll add up "
"all the elements of the iterable.  This case is so common that there's a "
"special built-in called :func:`sum` to compute it:"
msgstr ""
"Если вы используете :func:`operator.add` с :func:`functools.reduce`, вы "
"добавите все элементы итерируемого объекта. Этот случай настолько "
"распространен, что для его вычисления существует специальная встроенная "
"функция :func:`sum`:"

#: ../../howto/functional.rst:1063
msgid ""
"For many uses of :func:`functools.reduce`, though, it can be clearer to just "
"write the obvious :keyword:`for` loop::"
msgstr ""
"Однако во многих случаях использования :func:`functools.reduce` может быть "
"проще написать очевидный цикл :keyword:`for`::"

#: ../../howto/functional.rst:1066
msgid ""
"import functools\n"
"# Instead of:\n"
"product = functools.reduce(operator.mul, [1, 2, 3], 1)\n"
"\n"
"# You can write:\n"
"product = 1\n"
"for i in [1, 2, 3]:\n"
"    product *= i"
msgstr ""
"import functools\n"
"# Instead of:\n"
"product = functools.reduce(operator.mul, [1, 2, 3], 1)\n"
"\n"
"# You can write:\n"
"product = 1\n"
"for i in [1, 2, 3]:\n"
"    product *= i"

#: ../../howto/functional.rst:1075
msgid ""
"A related function is :func:`itertools.accumulate(iterable, func=operator."
"add) <itertools.accumulate>`.  It performs the same calculation, but instead "
"of returning only the final result, :func:`~itertools.accumulate` returns an "
"iterator that also yields each partial result::"
msgstr ""
"Связанная функция: :func:`itertools.accumulate(iterable, func=operator.add) "
"<itertools.accumulate>`. Он выполняет те же вычисления, но вместо возврата "
"только окончательного результата :func:`~itertools.accumulate` возвращает "
"итератор, который также возвращает каждый частичный результат:"

#: ../../howto/functional.rst:1080
msgid ""
"itertools.accumulate([1, 2, 3, 4, 5]) =>\n"
"  1, 3, 6, 10, 15\n"
"\n"
"itertools.accumulate([1, 2, 3, 4, 5], operator.mul) =>\n"
"  1, 2, 6, 24, 120"
msgstr ""
"itertools.accumulate([1, 2, 3, 4, 5]) =>\n"
"  1, 3, 6, 10, 15\n"
"\n"
"itertools.accumulate([1, 2, 3, 4, 5], operator.mul) =>\n"
"  1, 2, 6, 24, 120"

#: ../../howto/functional.rst:1088
msgid "The operator module"
msgstr "Модуль оператора"

#: ../../howto/functional.rst:1090
msgid ""
"The :mod:`operator` module was mentioned earlier.  It contains a set of "
"functions corresponding to Python's operators.  These functions are often "
"useful in functional-style code because they save you from writing trivial "
"functions that perform a single operation."
msgstr ""
"Модуль :mod:`operator` уже упоминался ранее. Он содержит набор функций, "
"соответствующих операторам Python. Эти функции часто полезны в коде "
"функционального стиля, поскольку они избавляют вас от написания тривиальных "
"функций, выполняющих одну операцию."

#: ../../howto/functional.rst:1095
msgid "Some of the functions in this module are:"
msgstr "Вот некоторые из функций этого модуля:"

#: ../../howto/functional.rst:1097
msgid ""
"Math operations: ``add()``, ``sub()``, ``mul()``, ``floordiv()``, "
"``abs()``, ..."
msgstr ""
"Математические операции: ``add()``, ``sub()``, ``mul()``, ``floordiv()``, "
"``abs()``, ..."

#: ../../howto/functional.rst:1098
msgid "Logical operations: ``not_()``, ``truth()``."
msgstr "Логические операции: ``not_()``, ``truth()``."

#: ../../howto/functional.rst:1099
msgid "Bitwise operations: ``and_()``, ``or_()``, ``invert()``."
msgstr "Побитовые операции: ``and_()``, ``or_()``, ``invert()``."

#: ../../howto/functional.rst:1100
msgid ""
"Comparisons: ``eq()``, ``ne()``, ``lt()``, ``le()``, ``gt()``, and ``ge()``."
msgstr ""
"Сравнения: ``eq()``, ``ne()``, ``lt()``, ``le()``, ``gt()`` и ``ge()``."

#: ../../howto/functional.rst:1101
msgid "Object identity: ``is_()``, ``is_not()``."
msgstr "Идентификация объекта: ``is_()``, ``is_not()``."

#: ../../howto/functional.rst:1103
msgid "Consult the operator module's documentation for a complete list."
msgstr "Полный список см. в документации модуля оператора."

#: ../../howto/functional.rst:1107
msgid "Small functions and the lambda expression"
msgstr "Маленькие функции и лямбда-выражение"

#: ../../howto/functional.rst:1109
msgid ""
"When writing functional-style programs, you'll often need little functions "
"that act as predicates or that combine elements in some way."
msgstr ""
"При написании программ в функциональном стиле вам часто понадобятся "
"небольшие функции, которые действуют как предикаты или каким-либо образом "
"объединяют элементы."

#: ../../howto/functional.rst:1112
msgid ""
"If there's a Python built-in or a module function that's suitable, you don't "
"need to define a new function at all::"
msgstr ""
"Если есть встроенная функция Python или подходящая функция модуля, вам "
"вообще не нужно определять новую функцию::"

#: ../../howto/functional.rst:1115
msgid ""
"stripped_lines = [line.strip() for line in lines]\n"
"existing_files = filter(os.path.exists, file_list)"
msgstr ""
"Stripped_lines = [line.strip() для строки в строках] существующие_файлы = "
"фильтр(os.path.exists, список_файлов)"

#: ../../howto/functional.rst:1118
msgid ""
"If the function you need doesn't exist, you need to write it.  One way to "
"write small functions is to use the :keyword:`lambda` expression.  "
"``lambda`` takes a number of parameters and an expression combining these "
"parameters, and creates an anonymous function that returns the value of the "
"expression::"
msgstr ""
"Если нужная вам функция не существует, вам нужно ее написать. Один из "
"способов написания небольших функций — использовать выражение :keyword:"
"`lambda`. ``лямбда`` принимает ряд параметров и выражение, объединяющее эти "
"параметры, и создает анонимную функцию, которая возвращает значение "
"выражения::"

#: ../../howto/functional.rst:1123
msgid ""
"adder = lambda x, y: x+y\n"
"\n"
"print_assign = lambda name, value: name + '=' + str(value)"
msgstr ""
"adder = lambda x, y: x+y\n"
"\n"
"print_assign = lambda name, value: name + '=' + str(value)"

#: ../../howto/functional.rst:1127
msgid ""
"An alternative is to just use the ``def`` statement and define a function in "
"the usual way::"
msgstr ""
"Альтернативой является использование оператора ``def`` и определение функции "
"обычным способом:"

#: ../../howto/functional.rst:1130
msgid ""
"def adder(x, y):\n"
"    return x + y\n"
"\n"
"def print_assign(name, value):\n"
"    return name + '=' + str(value)"
msgstr ""
"def adder(x, y):\n"
"    return x + y\n"
"\n"
"def print_assign(name, value):\n"
"    return name + '=' + str(value)"

#: ../../howto/functional.rst:1136
msgid ""
"Which alternative is preferable?  That's a style question; my usual course "
"is to avoid using ``lambda``."
msgstr ""
"Какая альтернатива предпочтительнее? Это вопрос стиля; мой обычный курс — "
"избегать использования «лямбда»."

#: ../../howto/functional.rst:1139
msgid ""
"One reason for my preference is that ``lambda`` is quite limited in the "
"functions it can define.  The result has to be computable as a single "
"expression, which means you can't have multiway ``if... elif... else`` "
"comparisons or ``try... except`` statements.  If you try to do too much in a "
"``lambda`` statement, you'll end up with an overly complicated expression "
"that's hard to read.  Quick, what's the following code doing? ::"
msgstr ""
"Одна из причин моего предпочтения заключается в том, что лямбда весьма "
"ограничена в функциях, которые она может определить. Результат должен быть "
"вычислен как одно выражение, а это означает, что вы не можете использовать "
"многосторонние сравнения ``if... elif... else`` или ``try... кроме`` "
"операторов. Если вы попытаетесь сделать слишком много в операторе "
"``лямбда``, вы получите слишком сложное выражение, которое будет трудно "
"читать. Быстро, что делает следующий код? ::"

#: ../../howto/functional.rst:1146
msgid ""
"import functools\n"
"total = functools.reduce(lambda a, b: (0, a[1] + b[1]), items)[1]"
msgstr ""
"import functools\n"
"total = functools.reduce(lambda a, b: (0, a[1] + b[1]), items)[1]"

#: ../../howto/functional.rst:1149
msgid ""
"You can figure it out, but it takes time to disentangle the expression to "
"figure out what's going on.  Using a short nested ``def`` statements makes "
"things a little bit better::"
msgstr ""
"Разобраться в этом можно, но нужно время, чтобы распутать выражение и "
"понять, что происходит. Использование коротких вложенных операторов ``def`` "
"делает ситуацию немного лучше:"

#: ../../howto/functional.rst:1153
msgid ""
"import functools\n"
"def combine(a, b):\n"
"    return 0, a[1] + b[1]\n"
"\n"
"total = functools.reduce(combine, items)[1]"
msgstr ""
"import functools\n"
"def combine(a, b):\n"
"    return 0, a[1] + b[1]\n"
"\n"
"total = functools.reduce(combine, items)[1]"

#: ../../howto/functional.rst:1159
msgid "But it would be best of all if I had simply used a ``for`` loop::"
msgstr "Но было бы лучше, если бы я просто использовал цикл for::"

#: ../../howto/functional.rst:1161
msgid ""
"total = 0\n"
"for a, b in items:\n"
"    total += b"
msgstr ""
"total = 0\n"
"for a, b in items:\n"
"    total += b"

#: ../../howto/functional.rst:1165
msgid "Or the :func:`sum` built-in and a generator expression::"
msgstr "Или встроенная функция :func:`sum` и выражение-генератор::"

#: ../../howto/functional.rst:1167
msgid "total = sum(b for a, b in items)"
msgstr "total = sum(b for a, b in items)"

#: ../../howto/functional.rst:1169
msgid ""
"Many uses of :func:`functools.reduce` are clearer when written as ``for`` "
"loops."
msgstr ""
"Многие варианты использования :func:`functools.reduce` становятся более "
"понятными, если они записаны как циклы ``for``."

#: ../../howto/functional.rst:1171
msgid ""
"Fredrik Lundh once suggested the following set of rules for refactoring uses "
"of ``lambda``:"
msgstr ""
"Фредрик Лунд однажды предложил следующий набор правил для рефакторинга "
"использования лямбды:"

#: ../../howto/functional.rst:1174
msgid "Write a lambda function."
msgstr "Напишите лямбда-функцию."

#: ../../howto/functional.rst:1175
msgid "Write a comment explaining what the heck that lambda does."
msgstr "Напишите комментарий, объясняющий, какого черта делает эта лямбда."

#: ../../howto/functional.rst:1176
msgid ""
"Study the comment for a while, and think of a name that captures the essence "
"of the comment."
msgstr ""
"Изучите комментарий некоторое время и придумайте название, которое бы "
"отражало суть комментария."

#: ../../howto/functional.rst:1178
msgid "Convert the lambda to a def statement, using that name."
msgstr "Преобразуйте лямбду в оператор def, используя это имя."

#: ../../howto/functional.rst:1179
msgid "Remove the comment."
msgstr "Удалить комментарий."

#: ../../howto/functional.rst:1181
msgid ""
"I really like these rules, but you're free to disagree about whether this "
"lambda-free style is better."
msgstr ""
"Мне очень нравятся эти правила, но вы можете не согласиться с тем, лучше ли "
"этот стиль без лямбда-выражений."

#: ../../howto/functional.rst:1186
msgid "Revision History and Acknowledgements"
msgstr "История изменений и благодарности"

#: ../../howto/functional.rst:1188
msgid ""
"The author would like to thank the following people for offering "
"suggestions, corrections and assistance with various drafts of this article: "
"Ian Bicking, Nick Coghlan, Nick Efford, Raymond Hettinger, Jim Jewett, Mike "
"Krell, Leandro Lameiro, Jussi Salmela, Collin Winter, Blake Winton."
msgstr ""
"Автор хотел бы поблагодарить следующих людей за предложения, исправления и "
"помощь в различных черновиках этой статьи: Иэна Бикинга, Ника Коглана, Ника "
"Эффорда, Рэймонда Хеттингера, Джима Джуэтта, Майка Крелла, Леандро Ламейро, "
"Юсси Салмела, Коллина Уинтера, Блейк Уинтон."

#: ../../howto/functional.rst:1193
msgid "Version 0.1: posted June 30 2006."
msgstr "Версия 0.1: опубликована 30 июня 2006 г."

#: ../../howto/functional.rst:1195
msgid "Version 0.11: posted July 1 2006.  Typo fixes."
msgstr "Версия 0.11: опубликована 1 июля 2006 г. Исправлены опечатки."

#: ../../howto/functional.rst:1197
msgid ""
"Version 0.2: posted July 10 2006.  Merged genexp and listcomp sections into "
"one. Typo fixes."
msgstr ""
"Версия 0.2: опубликовано 10 июля 2006 г. Разделы genexp и listcomp "
"объединены в один. Исправлены опечатки."

#: ../../howto/functional.rst:1200
msgid ""
"Version 0.21: Added more references suggested on the tutor mailing list."
msgstr "Версия 0.21: В список рассылки репетиторов добавлено больше ссылок."

#: ../../howto/functional.rst:1202
msgid ""
"Version 0.30: Adds a section on the ``functional`` module written by Collin "
"Winter; adds short section on the operator module; a few other edits."
msgstr ""
"Версия 0.30: Добавлен раздел о ``функциональном'' модуле, написанный "
"Коллином Уинтером; добавляет краткий раздел по операторскому модулю; еще "
"несколько правок."

#: ../../howto/functional.rst:1207
msgid "References"
msgstr "References"

#: ../../howto/functional.rst:1210
msgid "General"
msgstr "Главное"

#: ../../howto/functional.rst:1212
msgid ""
"**Structure and Interpretation of Computer Programs**, by Harold Abelson and "
"Gerald Jay Sussman with Julie Sussman.  The book can be found at https://"
"mitpress.mit.edu/sicp.  In this classic textbook of computer science, "
"chapters 2 and 3 discuss the use of sequences and streams to organize the "
"data flow inside a program.  The book uses Scheme for its examples, but many "
"of the design approaches described in these chapters are applicable to "
"functional-style Python code."
msgstr ""
"**Структура и интерпретация компьютерных программ**, Гарольд Абельсон и "
"Джеральд Джей Сассман с Джули Сассман. Книгу можно найти по адресу https://"
"mitpress.mit.edu/sicp. В главах 2 и 3 этого классического учебника "
"информатики обсуждается использование последовательностей и потоков для "
"организации потока данных внутри программы. В книге в качестве примеров "
"используется Scheme, но многие из подходов к проектированию, описанных в "
"этих главах, применимы к коду Python в функциональном стиле."

#: ../../howto/functional.rst:1220
msgid ""
"https://www.defmacro.org/ramblings/fp.html: A general introduction to "
"functional programming that uses Java examples and has a lengthy historical "
"introduction."
msgstr ""
"https://www.defmacro.org/ramblings/fp.html: Общее введение в функциональное "
"программирование, в котором используются примеры Java и имеется подробное "
"историческое введение."

#: ../../howto/functional.rst:1223
msgid ""
"https://en.wikipedia.org/wiki/Functional_programming: General Wikipedia "
"entry describing functional programming."
msgstr ""
"https://en.wikipedia.org/wiki/Functional_programming: общая запись в "
"Википедии, описывающая функциональное программирование."

#: ../../howto/functional.rst:1226
msgid "https://en.wikipedia.org/wiki/Coroutine: Entry for coroutines."
msgstr "https://en.wikipedia.org/wiki/Coroutine: запись для сопрограмм."

#: ../../howto/functional.rst:1228
msgid ""
"https://en.wikipedia.org/wiki/Partial_application: Entry for the concept of "
"partial function application."
msgstr ""
"https://en.wikipedia.org/wiki/Partial_application: запись о концепции "
"применения частичных функций."

#: ../../howto/functional.rst:1230
msgid ""
"https://en.wikipedia.org/wiki/Currying: Entry for the concept of currying."
msgstr ""
"https://en.wikipedia.org/wiki/Currying: запись о концепции каррирования."

#: ../../howto/functional.rst:1233
msgid "Python-specific"
msgstr "Специфичный для Python"

#: ../../howto/functional.rst:1235
msgid ""
"https://gnosis.cx/TPiP/: The first chapter of David Mertz's book :title-"
"reference:`Text Processing in Python` discusses functional programming for "
"text processing, in the section titled \"Utilizing Higher-Order Functions in "
"Text Processing\"."
msgstr ""
"https://gnosis.cx/TPiP/: В первой главе книги Дэвида Мерца :title-reference:"
"`Обработка текста в Python` обсуждается функциональное программирование для "
"обработки текста в разделе «Использование функций высшего порядка в "
"обработке текста». ."

#: ../../howto/functional.rst:1240
msgid ""
"Mertz also wrote a 3-part series of articles on functional programming for "
"IBM's DeveloperWorks site; see `part 1 <https://developer.ibm.com/articles/l-"
"prog/>`__, `part 2 <https://developer.ibm.com/tutorials/l-prog2/>`__, and "
"`part 3 <https://developer.ibm.com/tutorials/l-prog3/>`__,"
msgstr ""
"Мерц также написал серию статей из трех частей по функциональному "
"программированию для сайта IBM DeveloperWorks; см. `часть 1 <https://"
"developer.ibm.com/articles/l-prog/>`__, `часть 2 <https://developer.ibm.com/"
"tutorials/l-prog2/>`__ и `часть 3 <https://developer.ibm.com/tutorials/l-"
"prog3/>`__,"

#: ../../howto/functional.rst:1248
msgid "Python documentation"
msgstr "Документация Python"

#: ../../howto/functional.rst:1250
msgid "Documentation for the :mod:`itertools` module."
msgstr "Документация к модулю :mod:`itertools`."

#: ../../howto/functional.rst:1252
msgid "Documentation for the :mod:`functools` module."
msgstr "Документация к модулю :mod:`functools`"

#: ../../howto/functional.rst:1254
msgid "Documentation for the :mod:`operator` module."
msgstr "Документация к модулю :mod:`operator`"

#: ../../howto/functional.rst:1256
msgid ":pep:`289`: \"Generator Expressions\""
msgstr ":pep:`289`: \"Генераторные выражения\""

#: ../../howto/functional.rst:1258
msgid ""
":pep:`342`: \"Coroutines via Enhanced Generators\" describes the new "
"generator features in Python 2.5."
msgstr ""
":pep:`342`: «Сопрограммы через расширенные генераторы» описывают новые "
"функции генератора в Python 2.5."
