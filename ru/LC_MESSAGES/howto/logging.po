# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 15:28+0000\n"
"PO-Revision-Date: 2023-05-24 02:11+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../howto/logging.rst:3
msgid "Logging HOWTO"
msgstr "КАК СДЕЛАТЬ по логированию"

#: ../../howto/logging.rst:0
msgid "Author"
msgstr "Автор"

#: ../../howto/logging.rst:5
msgid "Vinay Sajip <vinay_sajip at red-dove dot com>"
msgstr "Винай Саджип <vinay_sajip на red-dove dot com>"

#: ../../howto/logging.rst:12
msgid "Basic Logging Tutorial"
msgstr "Базовое руководство по логированию"

#: ../../howto/logging.rst:14
msgid ""
"Logging is a means of tracking events that happen when some software runs. "
"The software's developer adds logging calls to their code to indicate that "
"certain events have occurred. An event is described by a descriptive message "
"which can optionally contain variable data (i.e. data that is potentially "
"different for each occurrence of the event). Events also have an importance "
"which the developer ascribes to the event; the importance can also be called "
"the *level* or *severity*."
msgstr ""
"Ведение журнала — это средство отслеживания событий, происходящих при "
"запуске некоторого программного обеспечения. Разработчик программного "
"обеспечения добавляет в свой код вызовы журналирования, чтобы указать, что "
"произошли определенные события. Событие описывается описательным сообщением, "
"которое может дополнительно содержать переменные данные (т. е. данные, "
"которые потенциально различны для каждого возникновения события). События "
"также имеют значение, которое разработчик приписывает событию; важность "
"также можно назвать *уровнем* или *серьезностью*."

#: ../../howto/logging.rst:23
msgid "When to use logging"
msgstr "Когда использовать ведение журнала"

#: ../../howto/logging.rst:25
msgid ""
"You can access logging functionality by creating a logger via ``logger = "
"getLogger(__name__)``, and then calling the logger's :meth:`~Logger.debug`, :"
"meth:`~Logger.info`, :meth:`~Logger.warning`, :meth:`~Logger.error` and :"
"meth:`~Logger.critical` methods. To determine when to use logging, and to "
"see which logger methods to use when, see the table below. It states, for "
"each of a set of common tasks, the best tool to use for that task."
msgstr ""
"Вы можете получить доступ к функциям ведения журнала, создав средство "
"ведения журнала через ``logger = getLogger(__name__)``, а затем вызвав его :"
"meth:`~Logger.debug`, :meth:`~Logger.info`, :meth:` Методы ~Logger."
"warning`, :meth:`~Logger.error` и :meth:`~Logger.critical`. Чтобы "
"определить, когда использовать ведение журнала, а также какие методы ведения "
"журнала использовать, см. таблицу ниже. Для каждой из набора общих задач в "
"нем указывается лучший инструмент, который можно использовать для этой "
"задачи."

#: ../../howto/logging.rst:33
msgid "Task you want to perform"
msgstr "Задача, которую вы хотите выполнить"

#: ../../howto/logging.rst:33
msgid "The best tool for the task"
msgstr "Лучший инструмент для решения задачи"

#: ../../howto/logging.rst:35
msgid ""
"Display console output for ordinary usage of a command line script or program"
msgstr ""
"Отображение вывода консоли для обычного использования сценария или программы "
"командной строки."

#: ../../howto/logging.rst:35
msgid ":func:`print`"
msgstr ":func:`print`"

#: ../../howto/logging.rst:39
msgid ""
"Report events that occur during normal operation of a program (e.g. for "
"status monitoring or fault investigation)"
msgstr ""
"Сообщайте о событиях, которые происходят во время нормальной работы "
"программы (например, для мониторинга состояния или расследования ошибок)."

#: ../../howto/logging.rst:39
msgid ""
"A logger's :meth:`~Logger.info` (or :meth:`~Logger.debug` method for very "
"detailed output for diagnostic purposes)"
msgstr ""
"Метод регистратора :meth:`~Logger.info` (или метод :meth:`~Logger.debug` для "
"очень подробного вывода в диагностических целях)"

#: ../../howto/logging.rst:44
msgid "Issue a warning regarding a particular runtime event"
msgstr ""
"Выдать предупреждение относительно определенного события во время выполнения"

#: ../../howto/logging.rst:44
msgid ""
":func:`warnings.warn` in library code if the issue is avoidable and the "
"client application should be modified to eliminate the warning"
msgstr ""
":func:`warnings.warn` в коде библиотеки, если проблему можно избежать и "
"клиентское приложение необходимо изменить, чтобы устранить предупреждение."

#: ../../howto/logging.rst:49
msgid ""
"A logger's :meth:`~Logger.warning` method if there is nothing the client "
"application can do about the situation, but the event should still be noted"
msgstr ""
"Метод регистратора :meth:`~Logger.warning`, если клиентское приложение "
"ничего не может сделать с ситуацией, но событие все равно должно быть "
"отмечено."

#: ../../howto/logging.rst:55
msgid "Report an error regarding a particular runtime event"
msgstr "Сообщить об ошибке, связанной с конкретным событием времени выполнения"

#: ../../howto/logging.rst:55
msgid "Raise an exception"
msgstr "Вызвать исключение"

#: ../../howto/logging.rst:58
msgid ""
"Report suppression of an error without raising an exception (e.g. error "
"handler in a long-running server process)"
msgstr ""
"Сообщать о подавлении ошибки без создания исключения (например, обработчик "
"ошибок в длительно выполняющемся серверном процессе)"

#: ../../howto/logging.rst:58
msgid ""
"A logger's :meth:`~Logger.error`, :meth:`~Logger.exception` or :meth:"
"`~Logger.critical` method as appropriate for the specific error and "
"application domain"
msgstr ""
"Метод регистратора :meth:`~Logger.error`, :meth:`~Logger.Exception` или :"
"meth:`~Logger.critical` в зависимости от конкретной ошибки и домена "
"приложения."

#: ../../howto/logging.rst:65
msgid ""
"The logger methods are named after the level or severity of the events they "
"are used to track. The standard levels and their applicability are described "
"below (in increasing order of severity):"
msgstr ""
"Методы ведения журнала названы в соответствии с уровнем или серьезностью "
"событий, которые они используют для отслеживания. Стандартные уровни и их "
"применимость описаны ниже (в порядке возрастания серьезности):"

#: ../../howto/logging.rst:72 ../../howto/logging.rst:827
msgid "Level"
msgstr "Уровень"

#: ../../howto/logging.rst:72
msgid "When it's used"
msgstr "Когда он используется"

#: ../../howto/logging.rst:74 ../../howto/logging.rst:837
msgid "``DEBUG``"
msgstr "``DEBUG``"

#: ../../howto/logging.rst:74
msgid ""
"Detailed information, typically of interest only when diagnosing problems."
msgstr ""
"Подробная информация, обычно представляющая интерес только при диагностике "
"проблем."

#: ../../howto/logging.rst:77 ../../howto/logging.rst:835
msgid "``INFO``"
msgstr "``INFO``"

#: ../../howto/logging.rst:77
msgid "Confirmation that things are working as expected."
msgstr "Подтверждение того, что все работает так, как ожидалось."

#: ../../howto/logging.rst:80 ../../howto/logging.rst:833
msgid "``WARNING``"
msgstr "``WARNING``"

#: ../../howto/logging.rst:80
msgid ""
"An indication that something unexpected happened, or indicative of some "
"problem in the near future (e.g. 'disk space low'). The software is still "
"working as expected."
msgstr ""
"Признак того, что произошло что-то неожиданное, или признак какой-либо "
"проблемы в ближайшем будущем (например, «недостаточно места на диске»). "
"Программное обеспечение все еще работает должным образом."

#: ../../howto/logging.rst:85 ../../howto/logging.rst:831
msgid "``ERROR``"
msgstr "``ERROR``"

#: ../../howto/logging.rst:85
msgid ""
"Due to a more serious problem, the software has not been able to perform "
"some function."
msgstr ""
"Из-за более серьезной проблемы программное обеспечение не смогло выполнить "
"некоторые функции."

#: ../../howto/logging.rst:88 ../../howto/logging.rst:829
msgid "``CRITICAL``"
msgstr "``CRITICAL``"

#: ../../howto/logging.rst:88
msgid ""
"A serious error, indicating that the program itself may be unable to "
"continue running."
msgstr ""
"Серьезная ошибка, указывающая на то, что сама программа, возможно, не сможет "
"продолжить работу."

#: ../../howto/logging.rst:92
msgid ""
"The default level is ``WARNING``, which means that only events of this level "
"and above will be tracked, unless the logging package is configured to do "
"otherwise."
msgstr ""
"Уровень по умолчанию — «ПРЕДУПРЕЖДЕНИЕ», что означает, что будут "
"отслеживаться только события этого уровня и выше, если пакет журналирования "
"не настроен на иное."

#: ../../howto/logging.rst:96
msgid ""
"Events that are tracked can be handled in different ways. The simplest way "
"of handling tracked events is to print them to the console. Another common "
"way is to write them to a disk file."
msgstr ""
"Отслеживаемые события можно обрабатывать разными способами. Самый простой "
"способ обработки отслеживаемых событий — вывести их на консоль. Другой "
"распространенный способ — записать их в файл на диске."

#: ../../howto/logging.rst:104
msgid "A simple example"
msgstr "Простой пример"

#: ../../howto/logging.rst:106
msgid "A very simple example is::"
msgstr "Очень простой пример:"

#: ../../howto/logging.rst:112
msgid "If you type these lines into a script and run it, you'll see:"
msgstr "Если вы введете эти строки в скрипт и запустите его, вы увидите:"

#: ../../howto/logging.rst:118
msgid ""
"printed out on the console. The ``INFO`` message doesn't appear because the "
"default level is ``WARNING``. The printed message includes the indication of "
"the level and the description of the event provided in the logging call, i."
"e. 'Watch out!'. The actual output can be formatted quite flexibly if you "
"need that; formatting options will also be explained later."
msgstr ""
"распечатано на консоли. Сообщение ``INFO`` не появляется, поскольку уровень "
"по умолчанию — ``WARNING``. Печатное сообщение включает в себя указание "
"уровня и описание события, указанного в вызове регистрации, например "
"«Осторожно!». Фактический вывод может быть отформатирован довольно гибко, "
"если вам это нужно; параметры форматирования также будут объяснены позже."

#: ../../howto/logging.rst:124
msgid ""
"Notice that in this example, we use functions directly on the ``logging`` "
"module, like ``logging.debug``, rather than creating a logger and calling "
"functions on it. These functions operation on the root logger, but can be "
"useful as they will call :func:`~logging.basicConfig` for you if it has not "
"been called yet, like in this example.  In larger programs you'll usually "
"want to control the logging configuration explicitly however - so for that "
"reason as well as others, it's better to create loggers and call their "
"methods."
msgstr ""
"Обратите внимание, что в этом примере мы используем функции непосредственно "
"в модуле logging, например logging.debug, вместо того, чтобы создавать "
"средство ведения журнала и вызывать на нем функции. Эти функции работают с "
"корневым регистратором, но могут быть полезны, поскольку они вызовут для "
"вас :func:`~logging.basicConfig`, если он еще не был вызван, как в этом "
"примере. Однако в более крупных программах вы обычно захотите явно "
"контролировать конфигурацию журналирования - поэтому по этой, как и по "
"другим причинам, лучше создавать средства журналирования и вызывать их "
"методы."

#: ../../howto/logging.rst:133
msgid "Logging to a file"
msgstr "Запись в файл"

#: ../../howto/logging.rst:135
msgid ""
"A very common situation is that of recording logging events in a file, so "
"let's look at that next. Be sure to try the following in a newly started "
"Python interpreter, and don't just continue from the session described "
"above::"
msgstr ""
"Очень распространенной ситуацией является запись событий журнала в файл, "
"поэтому давайте рассмотрим ее дальше. Обязательно попробуйте следующее в "
"только что запущенном интерпретаторе Python, а не просто продолжайте сеанс, "
"описанный выше:"

#: ../../howto/logging.rst:147
msgid ""
"The *encoding* argument was added. In earlier Python versions, or if not "
"specified, the encoding used is the default value used by :func:`open`. "
"While not shown in the above example, an *errors* argument can also now be "
"passed, which determines how encoding errors are handled. For available "
"values and the default, see the documentation for :func:`open`."
msgstr ""
"Был добавлен аргумент *кодирование*. В более ранних версиях Python (если не "
"указано иное) используемая кодировка — это значение по умолчанию, "
"используемое :func:`open`. Хотя это и не показано в приведенном выше "
"примере, теперь также можно передать аргумент *errors*, который определяет, "
"как обрабатываются ошибки кодирования. Доступные значения и значения по "
"умолчанию см. в документации по :func:`open`."

#: ../../howto/logging.rst:154
msgid ""
"And now if we open the file and look at what we have, we should find the log "
"messages:"
msgstr ""
"И теперь, если мы откроем файл и посмотрим, что у нас есть, мы должны найти "
"сообщения журнала:"

#: ../../howto/logging.rst:164
msgid ""
"This example also shows how you can set the logging level which acts as the "
"threshold for tracking. In this case, because we set the threshold to "
"``DEBUG``, all of the messages were printed."
msgstr ""
"В этом примере также показано, как можно установить уровень ведения журнала, "
"который действует как пороговое значение для отслеживания. В этом случае, "
"поскольку мы установили пороговое значение ``DEBUG``, все сообщения были "
"напечатаны."

#: ../../howto/logging.rst:168
msgid ""
"If you want to set the logging level from a command-line option such as:"
msgstr ""
"Если вы хотите установить уровень ведения журнала с помощью параметра "
"командной строки, например:"

#: ../../howto/logging.rst:174
msgid ""
"and you have the value of the parameter passed for ``--log`` in some "
"variable *loglevel*, you can use::"
msgstr ""
"и у вас есть значение параметра, переданного для ``--log`` в некоторой "
"переменной *loglevel*, вы можете использовать::"

#: ../../howto/logging.rst:179
msgid ""
"to get the value which you'll pass to :func:`basicConfig` via the *level* "
"argument. You may want to error check any user input value, perhaps as in "
"the following example::"
msgstr ""
"чтобы получить значение, которое вы передадите в :func:`basicConfig` через "
"аргумент *level*. Вы можете захотеть проверить на наличие ошибок любое "
"введенное пользователем значение, например, как в следующем примере:"

#: ../../howto/logging.rst:191
msgid ""
"The call to :func:`basicConfig` should come *before* any calls to a logger's "
"methods such as :meth:`~Logger.debug`, :meth:`~Logger.info`, etc. Otherwise, "
"that logging event may not be handled in the desired manner."
msgstr ""
"Вызов :func:`basicConfig` должен происходить *перед* любыми вызовами методов "
"регистратора, таких как :meth:`~Logger.debug`, :meth:`~Logger.info` и т. д. "
"В противном случае это событие регистрации может не обрабатываться желаемым "
"образом."

#: ../../howto/logging.rst:195
msgid ""
"If you run the above script several times, the messages from successive runs "
"are appended to the file *example.log*. If you want each run to start "
"afresh, not remembering the messages from earlier runs, you can specify the "
"*filemode* argument, by changing the call in the above example to::"
msgstr ""
"Если вы запускаете приведенный выше сценарий несколько раз, сообщения от "
"последовательных запусков добавляются в файл *example.log*. Если вы хотите, "
"чтобы каждый запуск начинался заново, не запоминая сообщения от предыдущих "
"запусков, вы можете указать аргумент *filemode*. , изменив вызов в "
"приведенном выше примере на::"

#: ../../howto/logging.rst:202
msgid ""
"The output will be the same as before, but the log file is no longer "
"appended to, so the messages from earlier runs are lost."
msgstr ""
"Вывод будет таким же, как и раньше, но файл журнала больше не будет "
"добавляться, поэтому сообщения предыдущих запусков будут потеряны."

#: ../../howto/logging.rst:207
msgid "Logging variable data"
msgstr "Логирование переменных данных"

#: ../../howto/logging.rst:209
msgid ""
"To log variable data, use a format string for the event description message "
"and append the variable data as arguments. For example::"
msgstr ""
"Чтобы зарегистрировать переменные данные, используйте строку формата для "
"сообщения с описанием события и добавьте переменные данные в качестве "
"аргументов. Например::"

#: ../../howto/logging.rst:215
msgid "will display:"
msgstr "будет отображаться:"

#: ../../howto/logging.rst:221
msgid ""
"As you can see, merging of variable data into the event description message "
"uses the old, %-style of string formatting. This is for backwards "
"compatibility: the logging package pre-dates newer formatting options such "
"as :meth:`str.format` and :class:`string.Template`. These newer formatting "
"options *are* supported, but exploring them is outside the scope of this "
"tutorial: see :ref:`formatting-styles` for more information."
msgstr ""
"Как видите, при объединении переменных данных в сообщение с описанием "
"события используется старый, %-s стиль форматирования строк. Это сделано для "
"обратной совместимости: пакет журналирования предшествует новым параметрам "
"форматирования, таким как :meth:`str.format` и :class:`string.Template`. Эти "
"новые параметры форматирования *поддерживаются*, но их изучение выходит за "
"рамки данного руководства: дополнительную информацию см. в разделе :ref:"
"`formatting-styles`."

#: ../../howto/logging.rst:230
msgid "Changing the format of displayed messages"
msgstr "Изменение формата отображаемых сообщений"

#: ../../howto/logging.rst:232
msgid ""
"To change the format which is used to display messages, you need to specify "
"the format you want to use::"
msgstr ""
"Чтобы изменить формат, используемый для отображения сообщений, вам "
"необходимо указать формат, который вы хотите использовать:"

#: ../../howto/logging.rst:241
msgid "which would print:"
msgstr "который будет печатать:"

#: ../../howto/logging.rst:249
msgid ""
"Notice that the 'root' which appeared in earlier examples has disappeared. "
"For a full set of things that can appear in format strings, you can refer to "
"the documentation for :ref:`logrecord-attributes`, but for simple usage, you "
"just need the *levelname* (severity), *message* (event description, "
"including variable data) and perhaps to display when the event occurred. "
"This is described in the next section."
msgstr ""
"Обратите внимание, что «корень», который появлялся в предыдущих примерах, "
"исчез. Полный набор вещей, которые могут отображаться в строках формата, вы "
"можете найти в документации по :ref:`logrecord-attributes`, но для простого "
"использования вам просто нужны *имя уровня* (серьезность), *сообщение* "
"(событие описание, включая переменные данные) и, возможно, для отображения "
"того, когда произошло событие. Это описано в следующем разделе."

#: ../../howto/logging.rst:258
msgid "Displaying the date/time in messages"
msgstr "Отображение даты/времени в сообщениях"

#: ../../howto/logging.rst:260
msgid ""
"To display the date and time of an event, you would place '%(asctime)s' in "
"your format string::"
msgstr ""
"Чтобы отобразить дату и время события, вы должны разместить ' %(время по "
"возрастанию) с ' в строке формата::"

#: ../../howto/logging.rst:267
msgid "which should print something like this:"
msgstr "который должен напечатать что-то вроде этого:"

#: ../../howto/logging.rst:273
msgid ""
"The default format for date/time display (shown above) is like ISO8601 or :"
"rfc:`3339`. If you need more control over the formatting of the date/time, "
"provide a *datefmt* argument to ``basicConfig``, as in this example::"
msgstr ""
"Формат отображения даты/времени по умолчанию (показанный выше) аналогичен "
"ISO8601 или :rfc:`3339`. Если вам нужен больший контроль над форматированием "
"даты/времени, укажите аргумент *datefmt* для ``basicConfig``, как в этом "
"примере:"

#: ../../howto/logging.rst:281
msgid "which would display something like this:"
msgstr "который будет отображать что-то вроде этого:"

#: ../../howto/logging.rst:287
msgid ""
"The format of the *datefmt* argument is the same as supported by :func:`time."
"strftime`."
msgstr ""
"Формат аргумента *datefmt* такой же, как и в формате :func:`time.strftime`."

#: ../../howto/logging.rst:292
msgid "Next Steps"
msgstr "Следующие шаги"

#: ../../howto/logging.rst:294
msgid ""
"That concludes the basic tutorial. It should be enough to get you up and "
"running with logging. There's a lot more that the logging package offers, "
"but to get the best out of it, you'll need to invest a little more of your "
"time in reading the following sections. If you're ready for that, grab some "
"of your favourite beverage and carry on."
msgstr ""
"На этом базовое руководство закончено. Этого должно быть достаточно, чтобы "
"начать работу с журналированием. Пакет ведения журналов предлагает гораздо "
"больше, но чтобы получить от него максимальную пользу, вам придется "
"потратить немного больше времени. читая следующие разделы. Если вы готовы к "
"этому, возьмите немного своего любимого напитка и продолжайте."

#: ../../howto/logging.rst:300
msgid ""
"If your logging needs are simple, then use the above examples to incorporate "
"logging into your own scripts, and if you run into problems or don't "
"understand something, please post a question on the comp.lang.python Usenet "
"group (available at https://groups.google.com/g/comp.lang.python) and you "
"should receive help before too long."
msgstr ""
"Если ваши потребности в ведении журналов просты, используйте приведенные "
"выше примеры, чтобы включить ведение журнала в свои собственные сценарии, а "
"если у вас возникнут проблемы или вы что-то не понимаете, задайте вопрос в "
"группе usenet comp.lang.python (доступно по адресу https). ://groups.google."
"com/g/comp.lang.python), и вскоре вы получите помощь."

#: ../../howto/logging.rst:306
msgid ""
"Still here? You can carry on reading the next few sections, which provide a "
"slightly more advanced/in-depth tutorial than the basic one above. After "
"that, you can take a look at the :ref:`logging-cookbook`."
msgstr ""
"Все еще здесь? Вы можете продолжить чтение следующих нескольких разделов, "
"которые представляют собой немного более продвинутое/углубленное "
"руководство, чем базовое, приведенное выше. После этого вы можете взглянуть "
"на :ref:`logging-cookbook`."

#: ../../howto/logging.rst:314
msgid "Advanced Logging Tutorial"
msgstr "Расширенное руководство по логированию"

#: ../../howto/logging.rst:316
msgid ""
"The logging library takes a modular approach and offers several categories "
"of components: loggers, handlers, filters, and formatters."
msgstr ""
"Библиотека журналирования использует модульный подход и предлагает несколько "
"категорий компонентов: регистраторы, обработчики, фильтры и средства "
"форматирования."

#: ../../howto/logging.rst:319
msgid "Loggers expose the interface that application code directly uses."
msgstr ""
"Регистраторы предоставляют интерфейс, который напрямую использует код "
"приложения."

#: ../../howto/logging.rst:320
msgid ""
"Handlers send the log records (created by loggers) to the appropriate "
"destination."
msgstr ""
"Обработчики отправляют записи журнала (созданные регистраторами) в "
"соответствующее место назначения."

#: ../../howto/logging.rst:322
msgid ""
"Filters provide a finer grained facility for determining which log records "
"to output."
msgstr ""
"Фильтры предоставляют более детальную возможность определения того, какие "
"записи журнала следует выводить."

#: ../../howto/logging.rst:324
msgid "Formatters specify the layout of log records in the final output."
msgstr "Форматтеры определяют расположение записей журнала в конечном выводе."

#: ../../howto/logging.rst:326
msgid ""
"Log event information is passed between loggers, handlers, filters and "
"formatters in a :class:`LogRecord` instance."
msgstr ""
"Информация о событиях журнала передается между регистраторами, "
"обработчиками, фильтрами и форматировщиками в экземпляре :class:`LogRecord`."

#: ../../howto/logging.rst:329
msgid ""
"Logging is performed by calling methods on instances of the :class:`Logger` "
"class (hereafter called :dfn:`loggers`). Each instance has a name, and they "
"are conceptually arranged in a namespace hierarchy using dots (periods) as "
"separators. For example, a logger named 'scan' is the parent of loggers "
"'scan.text', 'scan.html' and 'scan.pdf'. Logger names can be anything you "
"want, and indicate the area of an application in which a logged message "
"originates."
msgstr ""
"Ведение журнала осуществляется путем вызова методов экземпляров класса :"
"class:`Logger` (далее называемого :dfn:`loggers`). У каждого экземпляра есть "
"имя, и они концептуально организованы в иерархию пространств имен с "
"использованием точек (точек) в качестве разделителей. Например, средство "
"ведения журнала с именем «scan» является родительским для средств ведения "
"журнала «scan.text», «scan.html» и «scan.pdf». Имена регистраторов могут "
"быть любыми и указывают область приложения, в которой происходит "
"зарегистрированное сообщение."

#: ../../howto/logging.rst:336
msgid ""
"A good convention to use when naming loggers is to use a module-level "
"logger, in each module which uses logging, named as follows::"
msgstr ""
"Хорошим соглашением при именовании средств ведения журнала является "
"использование средства ведения журнала на уровне модуля, в каждом модуле, "
"использующем ведение журнала, с именем следующим образом:"

#: ../../howto/logging.rst:341
msgid ""
"This means that logger names track the package/module hierarchy, and it's "
"intuitively obvious where events are logged just from the logger name."
msgstr ""
"Это означает, что имена регистраторов отслеживают иерархию пакетов/модулей, "
"и интуитивно очевидно, где события регистрируются, просто по имени "
"регистратора."

#: ../../howto/logging.rst:344
msgid ""
"The root of the hierarchy of loggers is called the root logger. That's the "
"logger used by the functions :func:`debug`, :func:`info`, :func:`warning`, :"
"func:`error` and :func:`critical`, which just call the same-named method of "
"the root logger. The functions and the methods have the same signatures. The "
"root logger's name is printed as 'root' in the logged output."
msgstr ""
"Корень иерархии регистраторов называется корневым регистратором. Это "
"регистратор, используемый функциями :func:`debug`, :func:`info`, :func:"
"`warning`, :func:`error` и :func:`critical`, которые просто вызывают "
"одноимённый метод. корневого регистратора. Функции и методы имеют одинаковые "
"сигнатуры. Имя корневого регистратора печатается как «root» в "
"протоколируемых выходных данных."

#: ../../howto/logging.rst:350
msgid ""
"It is, of course, possible to log messages to different destinations. "
"Support is included in the package for writing log messages to files, HTTP "
"GET/POST locations, email via SMTP, generic sockets, queues, or OS-specific "
"logging mechanisms such as syslog or the Windows NT event log. Destinations "
"are served by :dfn:`handler` classes. You can create your own log "
"destination class if you have special requirements not met by any of the "
"built-in handler classes."
msgstr ""
"Конечно, в пакет включена поддержка записи сообщений журнала в файлы, "
"местоположения HTTP GET/POST, электронная почта через SMTP, общие сокеты, "
"очереди или механизмы регистрации, специфичные для ОС, такие как syslog или "
"журнал событий Windows NT. Назначения обслуживаются классами :dfn:`handler`. "
"Вы можете создать свой собственный класс назначения журнала, если у вас есть "
"особые требования, которым не соответствует ни один из встроенных классов-"
"обработчиков."

#: ../../howto/logging.rst:357
msgid ""
"By default, no destination is set for any logging messages. You can specify "
"a destination (such as console or file) by using :func:`basicConfig` as in "
"the tutorial examples. If you call the functions  :func:`debug`, :func:"
"`info`, :func:`warning`, :func:`error` and :func:`critical`, they will check "
"to see if no destination is set; and if one is not set, they will set a "
"destination of the console (``sys.stderr``) and a default format for the "
"displayed message before delegating to the root logger to do the actual "
"message output."
msgstr ""
"По умолчанию для сообщений журнала не установлено место назначения. Вы "
"можете указать место назначения (например, консоль или файл), используя :"
"func:`basicConfig`, как в примерах руководства. Если вы вызовете функции :"
"func:`debug`, :func:`info`, :func:`warning`, :func:`error` и :func:"
"`critical`, они проверят, не задан ли пункт назначения. ; и если он не "
"установлен, они установят место назначения консоли (``sys.stderr``) и формат "
"по умолчанию для отображаемого сообщения, прежде чем делегировать корневому "
"регистратору выполнение фактического вывода сообщения."

#: ../../howto/logging.rst:365
msgid "The default format set by :func:`basicConfig` for messages is:"
msgstr "Формат по умолчанию, установленный :func:`basicConfig` для сообщений:"

#: ../../howto/logging.rst:371
msgid ""
"You can change this by passing a format string to :func:`basicConfig` with "
"the *format* keyword argument. For all options regarding how a format string "
"is constructed, see :ref:`formatter-objects`."
msgstr ""
"Вы можете изменить это, передав строку формата в :func:`basicConfig` с "
"аргументом ключевого слова *format*. Обо всех вариантах построения строки "
"формата см. :ref:`formatter-objects`."

#: ../../howto/logging.rst:376
msgid "Logging Flow"
msgstr "Поток логирования"

#: ../../howto/logging.rst:378
msgid ""
"The flow of log event information in loggers and handlers is illustrated in "
"the following diagram."
msgstr ""
"Поток информации о событиях журнала в средствах ведения журнала и "
"обработчиках показан на следующей диаграмме."

#: ../../howto/logging.rst:385
msgid "Loggers"
msgstr "Логгеры"

#: ../../howto/logging.rst:387
msgid ""
":class:`Logger` objects have a threefold job.  First, they expose several "
"methods to application code so that applications can log messages at "
"runtime. Second, logger objects determine which log messages to act upon "
"based upon severity (the default filtering facility) or filter objects.  "
"Third, logger objects pass along relevant log messages to all interested log "
"handlers."
msgstr ""
"Объекты :class:`Logger` выполняют тройную задачу. Во-первых, они "
"предоставляют несколько методов коду приложения, чтобы приложения могли "
"регистрировать сообщения во время выполнения. Во-вторых, объекты журнала "
"определяют, какие сообщения журнала следует обрабатывать в зависимости от "
"серьезности (средство фильтрации по умолчанию) или фильтруют объекты. "
"Объекты журнала передают соответствующие сообщения журнала всем "
"заинтересованным обработчикам журнала."

#: ../../howto/logging.rst:393
msgid ""
"The most widely used methods on logger objects fall into two categories: "
"configuration and message sending."
msgstr ""
"Наиболее широко используемые методы объектов журнала делятся на две "
"категории: настройка и отправка сообщений."

#: ../../howto/logging.rst:396
msgid "These are the most common configuration methods:"
msgstr "Это наиболее распространенные методы настройки:"

#: ../../howto/logging.rst:398
msgid ""
":meth:`Logger.setLevel` specifies the lowest-severity log message a logger "
"will handle, where debug is the lowest built-in severity level and critical "
"is the highest built-in severity.  For example, if the severity level is "
"INFO, the logger will handle only INFO, WARNING, ERROR, and CRITICAL "
"messages and will ignore DEBUG messages."
msgstr ""
":meth:`Logger.setLevel` указывает сообщение журнала с наименьшим уровнем "
"серьезности, которое будет обрабатывать средство ведения журнала, где "
"отладка — это самый низкий встроенный уровень серьезности, а критический — "
"самый высокий встроенный уровень серьезности. Например, если уровень "
"серьезности — INFO, средство ведения журнала будет обрабатывать только INFO, "
"WARNING. , ERROR и CRITICAL и игнорирует сообщения DEBUG."

#: ../../howto/logging.rst:404
msgid ""
":meth:`Logger.addHandler` and :meth:`Logger.removeHandler` add and remove "
"handler objects from the logger object.  Handlers are covered in more detail "
"in :ref:`handler-basic`."
msgstr ""
":meth:`Logger.addHandler` и :meth:`Logger.removeHandler` добавляют и удаляют "
"объекты-обработчики из объекта регистратора. Обработчики более подробно "
"описаны в :ref:`handler-basic`."

#: ../../howto/logging.rst:408
msgid ""
":meth:`Logger.addFilter` and :meth:`Logger.removeFilter` add and remove "
"filter objects from the logger object.  Filters are covered in more detail "
"in :ref:`filter`."
msgstr ""
":meth:`Logger.addFilter` и :meth:`Logger.removeFilter` добавляют и удаляют "
"объекты фильтра из объекта журнала. Более подробно фильтры описаны в :ref:"
"`filter`."

#: ../../howto/logging.rst:412
msgid ""
"You don't need to always call these methods on every logger you create. See "
"the last two paragraphs in this section."
msgstr ""
"Вам не нужно всегда вызывать эти методы для каждого создаваемого вами "
"средства ведения журнала. См. последние два абзаца в этом разделе."

#: ../../howto/logging.rst:415
msgid ""
"With the logger object configured, the following methods create log messages:"
msgstr ""
"После настройки объекта журнала следующие методы создают сообщения журнала:"

#: ../../howto/logging.rst:417
msgid ""
":meth:`Logger.debug`, :meth:`Logger.info`, :meth:`Logger.warning`, :meth:"
"`Logger.error`, and :meth:`Logger.critical` all create log records with a "
"message and a level that corresponds to their respective method names. The "
"message is actually a format string, which may contain the standard string "
"substitution syntax of ``%s``, ``%d``, ``%f``, and so on.  The rest of their "
"arguments is a list of objects that correspond with the substitution fields "
"in the message.  With regard to ``**kwargs``, the logging methods care only "
"about a keyword of ``exc_info`` and use it to determine whether to log "
"exception information."
msgstr ""
":meth:`Logger.debug`, :meth:`Logger.info`, :meth:`Logger.warning`, :meth:"
"`Logger.error` и :meth:`Logger.critical` создают записи журнала с сообщение "
"и уровень, соответствующие соответствующим именам методов. Сообщение на "
"самом деле представляет собой строку формата, которая может содержать "
"стандартный синтаксис подстановки строк `` %s ``, `` %д ``, `` %f `` и так "
"далее. Остальная часть их аргументов представляет собой список объектов, "
"соответствующих полям подстановки в сообщении. Что касается ``**kwargs``, "
"методы журналирования заботятся только о ключевом слове ``exc_info`` и "
"используют его, чтобы определить, следует ли регистрировать информацию об "
"исключении."

#: ../../howto/logging.rst:427
msgid ""
":meth:`Logger.exception` creates a log message similar to :meth:`Logger."
"error`.  The difference is that :meth:`Logger.exception` dumps a stack trace "
"along with it.  Call this method only from an exception handler."
msgstr ""
":meth:`Logger.Exception` создает сообщение журнала, похожее на :meth:`Logger."
"error`. Разница в том, что :meth:`Logger.Exception` вместе с ним выгружает и "
"трассировку стека. Вызывайте этот метод только из обработчика исключений."

#: ../../howto/logging.rst:431
msgid ""
":meth:`Logger.log` takes a log level as an explicit argument.  This is a "
"little more verbose for logging messages than using the log level "
"convenience methods listed above, but this is how to log at custom log "
"levels."
msgstr ""
":meth:`Logger.log` принимает уровень журнала в качестве явного аргумента. "
"Это немного более подробно для регистрации сообщений, чем использование "
"удобных методов уровня журнала, перечисленных выше, но это способ "
"регистрации на пользовательских уровнях журнала."

#: ../../howto/logging.rst:435
msgid ""
":func:`getLogger` returns a reference to a logger instance with the "
"specified name if it is provided, or ``root`` if not.  The names are period-"
"separated hierarchical structures.  Multiple calls to :func:`getLogger` with "
"the same name will return a reference to the same logger object.  Loggers "
"that are further down in the hierarchical list are children of loggers "
"higher up in the list. For example, given a logger with a name of ``foo``, "
"loggers with names of ``foo.bar``, ``foo.bar.baz``, and ``foo.bam`` are all "
"descendants of ``foo``."
msgstr ""
":func:`getLogger` возвращает ссылку на экземпляр регистратора с указанным "
"именем, если оно указано, или ``root``, если нет. Имена представляют собой "
"иерархические структуры, разделенные периодами. Множественные вызовы :func:"
"`getLogger` с одним и тем же именем вернут ссылку на один и тот же объект "
"журнала. Регистраторы, находящиеся ниже в иерархическом списке, являются "
"дочерними элементами регистраторов, находящихся выше в списке. Например, для "
"данного регистратора с именем ``foo`` все регистраторы с именами ``foo."
"bar``, ``foo.bar.baz`` и ``foo.bam`` являются потомками ``фу``."

#: ../../howto/logging.rst:443
msgid ""
"Loggers have a concept of *effective level*. If a level is not explicitly "
"set on a logger, the level of its parent is used instead as its effective "
"level. If the parent has no explicit level set, *its* parent is examined, "
"and so on - all ancestors are searched until an explicitly set level is "
"found. The root logger always has an explicit level set (``WARNING`` by "
"default). When deciding whether to process an event, the effective level of "
"the logger is used to determine whether the event is passed to the logger's "
"handlers."
msgstr ""
"У лесорубов есть понятие *эффективного уровня*. Если уровень не установлен "
"явно для средства ведения журнала, вместо этого в качестве эффективного "
"уровня используется уровень его родительского элемента. Если у родительского "
"элемента не установлен явный уровень, проверяется *его* родительский элемент "
"и т. д. — поиск всех предков осуществляется до тех пор, пока не будет найден "
"явно установленный уровень. Корневой регистратор всегда имеет явный "
"установленный уровень (по умолчанию «ПРЕДУПРЕЖДЕНИЕ»). При принятии решения "
"о том, обрабатывать ли событие, эффективный уровень средства ведения журнала "
"используется для определения того, передается ли событие обработчикам "
"средства ведения журнала."

#: ../../howto/logging.rst:451
msgid ""
"Child loggers propagate messages up to the handlers associated with their "
"ancestor loggers. Because of this, it is unnecessary to define and configure "
"handlers for all the loggers an application uses. It is sufficient to "
"configure handlers for a top-level logger and create child loggers as "
"needed. (You can, however, turn off propagation by setting the *propagate* "
"attribute of a logger to ``False``.)"
msgstr ""
"Дочерние регистраторы передают сообщения обработчикам, связанным с их "
"родительскими регистраторами. По этой причине нет необходимости определять и "
"настраивать обработчики для всех средств ведения журнала, которые использует "
"приложение. Достаточно настроить обработчики для логгера верхнего уровня и "
"при необходимости создавать дочерние логгеры. (Однако вы можете отключить "
"распространение, установив для атрибута *propagate* средства ведения журнала "
"значение «False»)."

#: ../../howto/logging.rst:462
msgid "Handlers"
msgstr "Обработчики"

#: ../../howto/logging.rst:464
msgid ""
":class:`~logging.Handler` objects are responsible for dispatching the "
"appropriate log messages (based on the log messages' severity) to the "
"handler's specified destination.  :class:`Logger` objects can add zero or "
"more handler objects to themselves with an :meth:`~Logger.addHandler` "
"method.  As an example scenario, an application may want to send all log "
"messages to a log file, all log messages of error or higher to stdout, and "
"all messages of critical to an email address. This scenario requires three "
"individual handlers where each handler is responsible for sending messages "
"of a specific severity to a specific location."
msgstr ""
"Объекты :class:`~logging.Handler` отвечают за отправку соответствующих "
"сообщений журнала (в зависимости от серьезности сообщений журнала) в "
"указанный обработчиком пункт назначения. Объекты :class:`Logger` могут "
"добавлять к себе ноль или более объектов-обработчиков с помощью метода :meth:"
"`~Logger.addHandler`. В качестве примера сценария приложение может захотеть "
"отправить все сообщения журнала в файл журнала, все сообщения журнала об "
"ошибках или выше на стандартный вывод и все критические сообщения на адрес "
"электронной почты. Для этого сценария требуются три отдельных обработчика, "
"каждый из которых отвечает за отправку сообщений определенной серьезности в "
"определенное место."

#: ../../howto/logging.rst:474
msgid ""
"The standard library includes quite a few handler types (see :ref:`useful-"
"handlers`); the tutorials use mainly :class:`StreamHandler` and :class:"
"`FileHandler` in its examples."
msgstr ""
"Стандартная библиотека включает довольно много типов обработчиков (см. :ref:"
"`useful-handlers`); в руководствах в примерах в основном используются :class:"
"`StreamHandler` и :class:`FileHandler`."

#: ../../howto/logging.rst:478
msgid ""
"There are very few methods in a handler for application developers to "
"concern themselves with.  The only handler methods that seem relevant for "
"application developers who are using the built-in handler objects (that is, "
"not creating custom handlers) are the following configuration methods:"
msgstr ""
"В обработчике очень мало методов, которыми могут интересоваться разработчики "
"приложений. Единственные методы обработчика, которые кажутся значимыми для "
"разработчиков приложений, использующих встроенные объекты-обработчики (то "
"есть не создающих собственные обработчики), — это следующие методы "
"конфигурации:"

#: ../../howto/logging.rst:483
msgid ""
"The :meth:`~Handler.setLevel` method, just as in logger objects, specifies "
"the lowest severity that will be dispatched to the appropriate destination.  "
"Why are there two :meth:`~Handler.setLevel` methods?  The level set in the "
"logger determines which severity of messages it will pass to its handlers.  "
"The level set in each handler determines which messages that handler will "
"send on."
msgstr ""
"Метод :meth:`~Handler.setLevel`, как и в объектах регистратора, определяет "
"наименьшую серьезность, которая будет отправлена ​​в соответствующий пункт "
"назначения. Почему существует два метода :meth:`~Handler.setLevel`? Уровень, "
"установленный в средстве ведения журнала, определяет, какую серьезность "
"сообщений он будет передавать своим обработчикам. Уровень, установленный в "
"каждом обработчике, определяет, какие сообщения будет отправлять этот "
"обработчик."

#: ../../howto/logging.rst:489
msgid ""
":meth:`~Handler.setFormatter` selects a Formatter object for this handler to "
"use."
msgstr ""
":meth:`~Handler.setFormatter` выбирает объект Formatter для использования "
"этим обработчиком."

#: ../../howto/logging.rst:492
msgid ""
":meth:`~Handler.addFilter` and :meth:`~Handler.removeFilter` respectively "
"configure and deconfigure filter objects on handlers."
msgstr ""
":meth:`~Handler.addFilter` и :meth:`~Handler.removeFilter` соответственно "
"настраивают и деконфигурируют объекты фильтра в обработчиках."

#: ../../howto/logging.rst:495
msgid ""
"Application code should not directly instantiate and use instances of :class:"
"`Handler`.  Instead, the :class:`Handler` class is a base class that defines "
"the interface that all handlers should have and establishes some default "
"behavior that child classes can use (or override)."
msgstr ""
"Код приложения не должен напрямую создавать экземпляры и использовать "
"экземпляры :class:`Handler`. Вместо этого класс :class:`Handler` является "
"базовым классом, который определяет интерфейс, который должны иметь все "
"обработчики, и устанавливает некоторое поведение по умолчанию, которое могут "
"использовать (или переопределять) дочерние классы."

#: ../../howto/logging.rst:502
msgid "Formatters"
msgstr "Форматеры"

#: ../../howto/logging.rst:504
msgid ""
"Formatter objects configure the final order, structure, and contents of the "
"log message.  Unlike the base :class:`logging.Handler` class, application "
"code may instantiate formatter classes, although you could likely subclass "
"the formatter if your application needs special behavior.  The constructor "
"takes three optional arguments -- a message format string, a date format "
"string and a style indicator."
msgstr ""
"Объекты форматирования настраивают окончательный порядок, структуру и "
"содержимое сообщения журнала. В отличие от базового класса :class:`logging."
"Handler`, код приложения может создавать экземпляры классов форматирования, "
"хотя вы, вероятно, можете создать подкласс форматтера, если вашему "
"приложению требуется особое поведение. Конструктор принимает три "
"необязательных аргумента — строку формата сообщения, строку формата даты и "
"индикатор стиля."

#: ../../howto/logging.rst:513
msgid ""
"If there is no message format string, the default is to use the raw "
"message.  If there is no date format string, the default date format is:"
msgstr ""
"Если строка формата сообщения отсутствует, по умолчанию используется "
"необработанное сообщение. Если строка формата даты отсутствует, формат даты "
"по умолчанию:"

#: ../../howto/logging.rst:520
msgid ""
"with the milliseconds tacked on at the end. The ``style`` is one of ``'%'``, "
"``'{'``, or ``'$'``. If one of these is not specified, then ``'%'`` will be "
"used."
msgstr ""
"с добавлением миллисекунд в конце. ``стиль`` может быть одним из ``'%'``, "
"``'{'`` или ``'$'``. Если один из них не указан, будет использоваться "
"``'%'``."

#: ../../howto/logging.rst:523
msgid ""
"If the ``style`` is ``'%'``, the message format string uses ``%(<dictionary "
"key>)s`` styled string substitution; the possible keys are documented in :"
"ref:`logrecord-attributes`. If the style is ``'{'``, the message format "
"string is assumed to be compatible with :meth:`str.format` (using keyword "
"arguments), while if the style is ``'$'`` then the message format string "
"should conform to what is expected by :meth:`string.Template.substitute`."
msgstr ""
"Если ``стиль`` равен ``'%'``, строка формата сообщения использует "
"подстановку строки в стиле ``%(<ключ словаря>)s``; возможные ключи описаны "
"в :ref:`logrecord-attributes`. Если стиль ``'{'``, предполагается, что "
"строка формата сообщения совместима с :meth:`str.format` (с использованием "
"аргументов ключевого слова), а если стиль ``'$'``, то Строка формата "
"сообщения должна соответствовать ожидаемому :meth:`string.Template."
"substitute`."

#: ../../howto/logging.rst:530
msgid "Added the ``style`` parameter."
msgstr "Добавлен ``style`` параметр."

#: ../../howto/logging.rst:533
msgid ""
"The following message format string will log the time in a human-readable "
"format, the severity of the message, and the contents of the message, in "
"that order::"
msgstr ""
"Следующая строка формата сообщения будет регистрировать время в "
"удобочитаемом формате, серьезность сообщения и содержимое сообщения в "
"следующем порядке:"

#: ../../howto/logging.rst:539
msgid ""
"Formatters use a user-configurable function to convert the creation time of "
"a record to a tuple. By default, :func:`time.localtime` is used; to change "
"this for a particular formatter instance, set the ``converter`` attribute of "
"the instance to a function with the same signature as :func:`time.localtime` "
"or :func:`time.gmtime`. To change it for all formatters, for example if you "
"want all logging times to be shown in GMT, set the ``converter`` attribute "
"in the Formatter class (to ``time.gmtime`` for GMT display)."
msgstr ""
"Средства форматирования используют настраиваемую пользователем функцию для "
"преобразования времени создания записи в кортеж. По умолчанию используется :"
"func:`time.localtime`; чтобы изменить это для конкретного экземпляра "
"форматтера, установите атрибут ``converter`` экземпляра на функцию с той же "
"сигнатурой, что и :func:`time.localtime` или :func:`time.gmtime`. Чтобы "
"изменить его для всех форматтеров, например, если вы хотите, чтобы все время "
"регистрации отображалось в формате GMT, установите атрибут ``converter`` в "
"классе Formatter (на ``time.gmtime`` для отображения GMT)."

#: ../../howto/logging.rst:549
msgid "Configuring Logging"
msgstr "Настройка логирования"

#: ../../howto/logging.rst:553
msgid "Programmers can configure logging in three ways:"
msgstr "Программисты могут настроить ведение журнала тремя способами:"

#: ../../howto/logging.rst:555
msgid ""
"Creating loggers, handlers, and formatters explicitly using Python code that "
"calls the configuration methods listed above."
msgstr ""
"Создание средств ведения журнала, обработчиков и средств форматирования "
"явным образом с использованием кода Python, вызывающего перечисленные выше "
"методы конфигурации."

#: ../../howto/logging.rst:557
msgid ""
"Creating a logging config file and reading it using the :func:`fileConfig` "
"function."
msgstr ""
"Создание файла конфигурации журналирования и чтение его с помощью :func:"
"`fileConfig` функции."

#: ../../howto/logging.rst:559
msgid ""
"Creating a dictionary of configuration information and passing it to the :"
"func:`dictConfig` function."
msgstr ""
"Создание словаря конфигурационной информации и передача его в функцию:func:"
"`dictConfig`."

#: ../../howto/logging.rst:562
msgid ""
"For the reference documentation on the last two options, see :ref:`logging-"
"config-api`.  The following example configures a very simple logger, a "
"console handler, and a simple formatter using Python code::"
msgstr ""
"Справочную документацию по двум последним параметрам см. в разделе :ref:"
"`logging-config-api`. В следующем примере настраиваются очень простой "
"регистратор, обработчик консоли и простой форматировщик с использованием "
"кода Python:"

#: ../../howto/logging.rst:592
msgid ""
"Running this module from the command line produces the following output:"
msgstr "Запуск этого модуля из командной строки дает следующий результат:"

#: ../../howto/logging.rst:603
msgid ""
"The following Python module creates a logger, handler, and formatter nearly "
"identical to those in the example listed above, with the only difference "
"being the names of the objects::"
msgstr ""
"Следующий модуль Python создает средство ведения журнала, обработчик и "
"средство форматирования, почти идентичное тем, что приведены в приведенном "
"выше примере, с той лишь разницей, что имена объектов:"

#: ../../howto/logging.rst:622
msgid "Here is the logging.conf file:"
msgstr "Вот файл logging.conf:"

#: ../../howto/logging.rst:654
msgid ""
"The output is nearly identical to that of the non-config-file-based example:"
msgstr "Вывод почти идентичен примеру, не основанному на файле конфигурации:"

#: ../../howto/logging.rst:665
msgid ""
"You can see that the config file approach has a few advantages over the "
"Python code approach, mainly separation of configuration and code and the "
"ability of noncoders to easily modify the logging properties."
msgstr ""
"Вы можете видеть, что подход с использованием файла конфигурации имеет "
"несколько преимуществ по сравнению с подходом с кодом Python, в основном "
"разделение конфигурации и кода, а также возможность непрограммистам легко "
"изменять свойства журналирования."

#: ../../howto/logging.rst:669
msgid ""
"The :func:`fileConfig` function takes a default parameter, "
"``disable_existing_loggers``, which defaults to ``True`` for reasons of "
"backward compatibility. This may or may not be what you want, since it will "
"cause any non-root loggers existing before the :func:`fileConfig` call to be "
"disabled unless they (or an ancestor) are explicitly named in the "
"configuration. Please refer to the reference documentation for more "
"information, and specify ``False`` for this parameter if you wish."
msgstr ""
"Функция :func:`fileConfig` принимает параметр по умолчанию "
"``disable_existing_loggers``, который по умолчанию имеет значение ``True`` "
"по соображениям обратной совместимости. Это может быть, а может и не быть "
"тем, что вы хотите, так как это приведет к отключению любых некорневых "
"регистраторов, существовавших до вызова :func:`fileConfig`, если только они "
"(или их предки) не указаны явно в конфигурации. Пожалуйста, обратитесь к "
"справочной документации для получения дополнительной информации и при "
"желании укажите «False» для этого параметра."

#: ../../howto/logging.rst:677
msgid ""
"The dictionary passed to :func:`dictConfig` can also specify a Boolean value "
"with key ``disable_existing_loggers``, which if not specified explicitly in "
"the dictionary also defaults to being interpreted as ``True``. This leads to "
"the logger-disabling behaviour described above, which may not be what you "
"want - in which case, provide the key explicitly with a value of ``False``."
msgstr ""
"Словарь, передаваемый в :func:`dictConfig`, также может указывать логическое "
"значение с ключом ``disable_existing_loggers``, который, если он не указан "
"явно в словаре, также по умолчанию интерпретируется как ``True``. Это "
"приводит к описанному выше поведению с отключением журнала, что может быть "
"не тем, что вам нужно - в этом случае явно укажите для ключа значение "
"``False``."

#: ../../howto/logging.rst:687
msgid ""
"Note that the class names referenced in config files need to be either "
"relative to the logging module, or absolute values which can be resolved "
"using normal import mechanisms. Thus, you could use either :class:`~logging."
"handlers.WatchedFileHandler` (relative to the logging module) or ``mypackage."
"mymodule.MyHandler`` (for a class defined in package ``mypackage`` and "
"module ``mymodule``, where ``mypackage`` is available on the Python import "
"path)."
msgstr ""
"Обратите внимание, что имена классов, указанные в файлах конфигурации, "
"должны быть либо относительными к модулю журналирования, либо абсолютными "
"значениями, которые можно разрешить с помощью обычных механизмов импорта. "
"Таким образом, вы можете использовать либо :class:`~logging.handlers."
"WatchedFileHandler` (относительно модуля журналирования), либо ``mypackage."
"mymodule.MyHandler`` (для класса, определенного в пакете ``mypackage`` и "
"модуле `` mymodule``, где ``mypackage`` доступен в пути импорта Python)."

#: ../../howto/logging.rst:695
msgid ""
"In Python 3.2, a new means of configuring logging has been introduced, using "
"dictionaries to hold configuration information. This provides a superset of "
"the functionality of the config-file-based approach outlined above, and is "
"the recommended configuration method for new applications and deployments. "
"Because a Python dictionary is used to hold configuration information, and "
"since you can populate that dictionary using different means, you have more "
"options for configuration. For example, you can use a configuration file in "
"JSON format, or, if you have access to YAML processing functionality, a file "
"in YAML format, to populate the configuration dictionary. Or, of course, you "
"can construct the dictionary in Python code, receive it in pickled form over "
"a socket, or use whatever approach makes sense for your application."
msgstr ""
"В Python 3.2 были представлены новые средства настройки журналирования с "
"использованием словарей для хранения информации о конфигурации. Это "
"обеспечивает расширенный набор функций подхода на основе файлов "
"конфигурации, описанного выше, и является рекомендуемым методом настройки "
"для новых приложений и развертываний. . Поскольку словарь Python "
"используется для хранения информации о конфигурации, и поскольку вы можете "
"заполнять этот словарь различными способами, у вас есть больше возможностей "
"для настройки. Например, вы можете использовать файл конфигурации в формате "
"JSON или, если у вас есть доступ к нему. Функциональность обработки YAML, "
"файл в формате YAML для заполнения словаря конфигурации. Или, конечно, вы "
"можете создать словарь в коде Python, получить его в маринованном виде через "
"сокет или использовать любой подход, который имеет смысл для вашего "
"приложения."

#: ../../howto/logging.rst:707
msgid ""
"Here's an example of the same configuration as above, in YAML format for the "
"new dictionary-based approach:"
msgstr ""
"Вот пример той же конфигурации, что и выше, в формате YAML для нового "
"подхода на основе словаря:"

#: ../../howto/logging.rst:731
msgid ""
"For more information about logging using a dictionary, see :ref:`logging-"
"config-api`."
msgstr ""
"Дополнительную информацию о ведении журнала с использованием словаря см. в "
"разделе :ref:`logging-config-api`."

#: ../../howto/logging.rst:735
msgid "What happens if no configuration is provided"
msgstr "Что произойдет, если не будет предоставлена ​​конфигурация"

#: ../../howto/logging.rst:737
msgid ""
"If no logging configuration is provided, it is possible to have a situation "
"where a logging event needs to be output, but no handlers can be found to "
"output the event."
msgstr ""
"Если конфигурация ведения журнала не указана, возможна ситуация, когда "
"необходимо вывести событие журнала, но не удается найти обработчики для "
"вывода этого события."

#: ../../howto/logging.rst:741
msgid ""
"The event is output using a 'handler of last resort', stored in :data:"
"`lastResort`. This internal handler is not associated with any logger, and "
"acts like a :class:`~logging.StreamHandler` which writes the event "
"description message to the current value of ``sys.stderr`` (therefore "
"respecting any redirections which may be in effect). No formatting is done "
"on the message - just the bare event description message is printed. The "
"handler's level is set to ``WARNING``, so all events at this and greater "
"severities will be output."
msgstr ""
"Событие выводится с использованием «обработчика последней инстанции», "
"хранящегося в :data:`lastResort`. Этот внутренний обработчик не связан ни с "
"каким регистратором и действует как :class:`~logging.StreamHandler`, который "
"записывает сообщение с описанием события в текущее значение ``sys.stderr`` "
"(следовательно, с учетом любых перенаправлений, которые могут быть в "
"эффект). В сообщении не выполняется форматирование — печатается только "
"сообщение с описанием события. Уровень обработчика установлен на "
"«ПРЕДУПРЕЖДЕНИЕ», поэтому будут выводиться все события этой и более "
"серьезной важности."

#: ../../howto/logging.rst:752
msgid "For versions of Python prior to 3.2, the behaviour is as follows:"
msgstr "Для версий Python до 3.2 поведение выглядит следующим образом: "

#: ../../howto/logging.rst:754
msgid ""
"If :data:`raiseExceptions` is ``False`` (production mode), the event is "
"silently dropped."
msgstr ""
"Если :data:`raiseExceptions` имеет значение ``False`` (рабочий режим), "
"событие автоматически удаляется."

#: ../../howto/logging.rst:757
msgid ""
"If :data:`raiseExceptions` is ``True`` (development mode), a message 'No "
"handlers could be found for logger X.Y.Z' is printed once."
msgstr ""
"Если :data:`raiseExceptions` имеет значение ``True`` (режим разработки), "
"сообщение «Не удалось найти обработчики для регистратора XYZ» выводится один "
"раз."

#: ../../howto/logging.rst:760
msgid ""
"To obtain the pre-3.2 behaviour, :data:`lastResort` can be set to ``None``."
msgstr ""
"Чтобы получить поведение версии до версии 3.2, для :data:`lastResort` можно "
"установить значение ``None``."

#: ../../howto/logging.rst:766
msgid "Configuring Logging for a Library"
msgstr "Настройка ведения журнала для библиотеки "

#: ../../howto/logging.rst:768
msgid ""
"When developing a library which uses logging, you should take care to "
"document how the library uses logging - for example, the names of loggers "
"used. Some consideration also needs to be given to its logging "
"configuration. If the using application does not use logging, and library "
"code makes logging calls, then (as described in the previous section) events "
"of severity ``WARNING`` and greater will be printed to ``sys.stderr``. This "
"is regarded as the best default behaviour."
msgstr ""
"При разработке библиотеки, использующей журналирование, вам следует "
"позаботиться о том, чтобы документировать, как библиотека использует "
"журналирование, например, имена используемых средств журналирования. "
"Некоторое внимание также необходимо уделить конфигурации журналирования. "
"Если использующее приложение не использует журналирование, а код библиотеки "
"выполняет вызовы журналирования, то (как описано в предыдущем разделе) "
"события уровня серьезности ``WARNING`` и выше будут печататься в ``sys."
"stderr``. Это считается лучшим поведением по умолчанию."

#: ../../howto/logging.rst:776
msgid ""
"If for some reason you *don't* want these messages printed in the absence of "
"any logging configuration, you can attach a do-nothing handler to the top-"
"level logger for your library. This avoids the message being printed, since "
"a handler will always be found for the library's events: it just doesn't "
"produce any output. If the library user configures logging for application "
"use, presumably that configuration will add some handlers, and if levels are "
"suitably configured then logging calls made in library code will send output "
"to those handlers, as normal."
msgstr ""
"Если по какой-то причине вы *не* хотите, чтобы эти сообщения печатались при "
"отсутствии какой-либо конфигурации журналирования, вы можете присоединить "
"обработчик бездействия к регистратору верхнего уровня для вашей библиотеки. "
"Это позволяет избежать вывода сообщения, поскольку для событий библиотеки "
"всегда будет найден обработчик: он просто не выдает никакого вывода. Если "
"пользователь библиотеки настраивает ведение журнала для использования "
"приложения, предположительно, эта конфигурация добавит некоторые "
"обработчики, и если уровни настроены соответствующим образом, то вызовы "
"журналирования, выполненные в коде библиотеки, будут отправлять выходные "
"данные этим обработчикам, как обычно."

#: ../../howto/logging.rst:785
msgid ""
"A do-nothing handler is included in the logging package: :class:`~logging."
"NullHandler` (since Python 3.1). An instance of this handler could be added "
"to the top-level logger of the logging namespace used by the library (*if* "
"you want to prevent your library's logged events being output to ``sys."
"stderr`` in the absence of logging configuration). If all logging by a "
"library *foo* is done using loggers with names matching 'foo.x', 'foo.x.y', "
"etc. then the code::"
msgstr ""
"В пакет журналирования включен обработчик бездействия: :class:`~logging."
"NullHandler` (начиная с Python 3.1). Экземпляр этого обработчика можно "
"добавить в регистратор верхнего уровня пространства имен журналирования, "
"используемого библиотекой (*если* вы хотите предотвратить вывод "
"зарегистрированных событий вашей библиотеки в ``sys.stderr`` при отсутствии "
"конфигурации журналирования. ). Если все журналирование библиотеки *foo* "
"выполняется с использованием регистраторов с именами, соответствующими 'foo."
"x', 'foo.xy' и т. д., то код:"

#: ../../howto/logging.rst:796
msgid ""
"should have the desired effect. If an organisation produces a number of "
"libraries, then the logger name specified can be 'orgname.foo' rather than "
"just 'foo'."
msgstr ""
"должно дать желаемый эффект. Если организация производит несколько "
"библиотек, то указанным именем журнала может быть «orgname.foo», а не просто "
"«foo»."

#: ../../howto/logging.rst:800
msgid ""
"It is strongly advised that you *do not log to the root logger* in your "
"library. Instead, use a logger with a unique and easily identifiable name, "
"such as the ``__name__`` for your library's top-level package or module. "
"Logging to the root logger will make it difficult or impossible for the "
"application developer to configure the logging verbosity or handlers of your "
"library as they wish."
msgstr ""
"Настоятельно рекомендуется *не входить в корневой регистратор* вашей "
"библиотеки. Вместо этого используйте средство ведения журнала с уникальным и "
"легко идентифицируемым именем, например ``__name__`` для пакета или модуля "
"верхнего уровня вашей библиотеки. Ведение журнала в корневом регистраторе "
"затруднит или сделает невозможным для разработчика приложения настройку "
"подробностей журналирования или обработчиков вашей библиотеки по своему "
"усмотрению."

#: ../../howto/logging.rst:807
msgid ""
"It is strongly advised that you *do not add any handlers other than* :class:"
"`~logging.NullHandler` *to your library's loggers*. This is because the "
"configuration of handlers is the prerogative of the application developer "
"who uses your library. The application developer knows their target audience "
"and what handlers are most appropriate for their application: if you add "
"handlers 'under the hood', you might well interfere with their ability to "
"carry out unit tests and deliver logs which suit their requirements."
msgstr ""
"Настоятельно рекомендуется *не добавлять в журналы вашей библиотеки никаких "
"обработчиков, кроме* :class:`~logging.NullHandler` *. Это связано с тем, что "
"настройка обработчиков — прерогатива разработчика приложения, использующего "
"вашу библиотеку. Разработчик приложения знает свою целевую аудиторию и то, "
"какие обработчики наиболее подходят для его приложения: если вы добавите "
"обработчики «под капотом», вы вполне можете помешать им выполнять модульные "
"тесты и доставлять журналы, соответствующие их требованиям."

#: ../../howto/logging.rst:818
msgid "Logging Levels"
msgstr "Уровни логирования"

#: ../../howto/logging.rst:820
msgid ""
"The numeric values of logging levels are given in the following table. These "
"are primarily of interest if you want to define your own levels, and need "
"them to have specific values relative to the predefined levels. If you "
"define a level with the same numeric value, it overwrites the predefined "
"value; the predefined name is lost."
msgstr ""
"Числовые значения уровней ведения журнала приведены в следующей таблице. Они "
"в первую очередь представляют интерес, если вы хотите определить свои "
"собственные уровни и хотите, чтобы они имели определенные значения "
"относительно предопределенных уровней. Если вы определяете уровень с тем же "
"числовым значением, он перезаписывает предопределенное значение; "
"предопределенное имя потеряно."

#: ../../howto/logging.rst:827
msgid "Numeric value"
msgstr "Числовое значение"

#: ../../howto/logging.rst:829
msgid "50"
msgstr "50"

#: ../../howto/logging.rst:831
msgid "40"
msgstr "40"

#: ../../howto/logging.rst:833
msgid "30"
msgstr "30"

#: ../../howto/logging.rst:835
msgid "20"
msgstr "20"

#: ../../howto/logging.rst:837
msgid "10"
msgstr "10"

#: ../../howto/logging.rst:839
msgid "``NOTSET``"
msgstr "``NOTSET``"

#: ../../howto/logging.rst:839
msgid "0"
msgstr "0"

#: ../../howto/logging.rst:842
msgid ""
"Levels can also be associated with loggers, being set either by the "
"developer or through loading a saved logging configuration. When a logging "
"method is called on a logger, the logger compares its own level with the "
"level associated with the method call. If the logger's level is higher than "
"the method call's, no logging message is actually generated. This is the "
"basic mechanism controlling the verbosity of logging output."
msgstr ""
"Уровни также могут быть связаны с регистраторами: они устанавливаются либо "
"разработчиком, либо путем загрузки сохраненной конфигурации журналирования. "
"Когда метод регистрации вызывается в средстве ведения журнала, средство "
"ведения журнала сравнивает свой собственный уровень с уровнем, связанным с "
"вызовом метода. Если уровень регистратора выше, чем уровень вызова метода, "
"сообщение журнала фактически не генерируется. Это базовый механизм "
"управления подробностью вывода журнала."

#: ../../howto/logging.rst:849
msgid ""
"Logging messages are encoded as instances of the :class:`~logging.LogRecord` "
"class. When a logger decides to actually log an event, a :class:`~logging."
"LogRecord` instance is created from the logging message."
msgstr ""
"Сообщения журнала кодируются как экземпляры класса :class:`~logging."
"LogRecord`. Когда регистратор решает фактически зарегистрировать событие, из "
"сообщения журнала создается экземпляр :class:`~logging.LogRecord`."

#: ../../howto/logging.rst:853
msgid ""
"Logging messages are subjected to a dispatch mechanism through the use of :"
"dfn:`handlers`, which are instances of subclasses of the :class:`Handler` "
"class. Handlers are responsible for ensuring that a logged message (in the "
"form of a :class:`LogRecord`) ends up in a particular location (or set of "
"locations) which is useful for the target audience for that message (such as "
"end users, support desk staff, system administrators, developers). Handlers "
"are passed :class:`LogRecord` instances intended for particular "
"destinations. Each logger can have zero, one or more handlers associated "
"with it (via the :meth:`~Logger.addHandler` method of :class:`Logger`). In "
"addition to any handlers directly associated with a logger, *all handlers "
"associated with all ancestors of the logger* are called to dispatch the "
"message (unless the *propagate* flag for a logger is set to a false value, "
"at which point the passing to ancestor handlers stops)."
msgstr ""
"Сообщения журнала подвергаются механизму диспетчеризации посредством "
"использования :dfn:`handlers`, которые являются экземплярами подклассов "
"класса :class:`Handler`. Обработчики несут ответственность за то, чтобы "
"зарегистрированное сообщение (в форме :class:`LogRecord`) попадало в "
"определенное место (или набор мест), которое полезно для целевой аудитории "
"этого сообщения (например, конечные пользователи, сотрудники службы "
"поддержки, системные администраторы, разработчики). Обработчикам передаются "
"экземпляры LogRecord, предназначенные для определенных пунктов назначения. "
"Каждый регистратор может иметь ноль, один или несколько связанных с ним "
"обработчиков (с помощью метода :meth:`~Logger.addHandler` :class:`Logger`). "
"В дополнение к любым обработчикам, непосредственно связанным с "
"регистратором, для отправки сообщения вызываются *все обработчики, связанные "
"со всеми предками регистратора* (если только флаг *propagate* для "
"регистратора не установлен в ложное значение, и в этот момент передача для "
"обработчиков предков останавливается)."

#: ../../howto/logging.rst:867
msgid ""
"Just as for loggers, handlers can have levels associated with them. A "
"handler's level acts as a filter in the same way as a logger's level does. "
"If a handler decides to actually dispatch an event, the :meth:`~Handler."
"emit` method is used to send the message to its destination. Most user-"
"defined subclasses of :class:`Handler` will need to override this :meth:"
"`~Handler.emit`."
msgstr ""
"Как и в случае с регистраторами, обработчики могут иметь связанные с ними "
"уровни. Уровень обработчика действует как фильтр так же, как и уровень "
"регистратора. Если обработчик решает фактически отправить событие, метод :"
"meth:`~Handler.emit` используется для отправки сообщения по назначению. "
"Большинству определяемых пользователем подклассов :class:`Handler` "
"потребуется переопределить этот :meth:`~Handler.emit`."

#: ../../howto/logging.rst:876
msgid "Custom Levels"
msgstr "Пользовательские уровни"

#: ../../howto/logging.rst:878
msgid ""
"Defining your own levels is possible, but should not be necessary, as the "
"existing levels have been chosen on the basis of practical experience. "
"However, if you are convinced that you need custom levels, great care should "
"be exercised when doing this, and it is possibly *a very bad idea to define "
"custom levels if you are developing a library*. That's because if multiple "
"library authors all define their own custom levels, there is a chance that "
"the logging output from such multiple libraries used together will be "
"difficult for the using developer to control and/or interpret, because a "
"given numeric value might mean different things for different libraries."
msgstr ""
"Определение собственных уровней возможно, но не обязательно, поскольку "
"существующие уровни были выбраны на основе практического опыта. Однако, если "
"вы убеждены, что вам нужны пользовательские уровни, при этом следует "
"проявлять большую осторожность, и, возможно, *очень плохая идея определять "
"пользовательские уровни, если вы разрабатываете библиотеку*. Это связано с "
"тем, что если несколько авторов библиотек определяют свои собственные "
"пользовательские уровни, существует вероятность того, что вывод журнала из "
"таких нескольких библиотек, используемых вместе, будет сложно контролировать "
"и/или интерпретировать использующему разработчику, поскольку данное числовое "
"значение может означать разные вещи. для разных библиотек."

#: ../../howto/logging.rst:891
msgid "Useful Handlers"
msgstr "Полезные обработчики"

#: ../../howto/logging.rst:893
msgid ""
"In addition to the base :class:`Handler` class, many useful subclasses are "
"provided:"
msgstr ""
"В дополнение к базовому классу :class:`Handler` имеется множество полезных "
"подклассов:"

#: ../../howto/logging.rst:896
msgid ""
":class:`StreamHandler` instances send messages to streams (file-like "
"objects)."
msgstr ""
"Экземпляры :class:`StreamHandler` отправляют сообщения в потоки "
"(файлоподобные объекты)."

#: ../../howto/logging.rst:899
msgid ":class:`FileHandler` instances send messages to disk files."
msgstr "Экземпляры :class:`FileHandler` отправляют сообщения в файлы на диске."

#: ../../howto/logging.rst:901
msgid ""
":class:`~handlers.BaseRotatingHandler` is the base class for handlers that "
"rotate log files at a certain point. It is not meant to be  instantiated "
"directly. Instead, use :class:`~handlers.RotatingFileHandler` or :class:"
"`~handlers.TimedRotatingFileHandler`."
msgstr ""
":class:`~handlers.BaseRotatingHandler` — это базовый класс для обработчиков, "
"которые вращают файлы журналов в определенный момент. Он не предназначен для "
"непосредственного создания экземпляра. Вместо этого используйте :class:"
"`~handlers.RotatingFileHandler` или :class:`~handlers."
"TimedRotatingFileHandler`."

#: ../../howto/logging.rst:906
msgid ""
":class:`~handlers.RotatingFileHandler` instances send messages to disk "
"files, with support for maximum log file sizes and log file rotation."
msgstr ""
"Экземпляры :class:`~handlers.RotatingFileHandler` отправляют сообщения в "
"файлы на диске с поддержкой максимального размера файлов журналов и ротации "
"файлов журналов."

#: ../../howto/logging.rst:909
msgid ""
":class:`~handlers.TimedRotatingFileHandler` instances send messages to disk "
"files, rotating the log file at certain timed intervals."
msgstr ""
"Экземпляры :class:`~handlers.TimedRotatingFileHandler` отправляют сообщения "
"в файлы на диске, вращая файл журнала через определенные промежутки времени."

#: ../../howto/logging.rst:912
msgid ""
":class:`~handlers.SocketHandler` instances send messages to TCP/IP sockets. "
"Since 3.4, Unix domain sockets are also supported."
msgstr ""
"Экземпляры :class:`~handlers.SocketHandler` отправляют сообщения в сокеты "
"TCP/IP. Начиная с версии 3.4, также поддерживаются сокеты домена Unix."

#: ../../howto/logging.rst:915
msgid ""
":class:`~handlers.DatagramHandler` instances send messages to UDP sockets. "
"Since 3.4, Unix domain sockets are also supported."
msgstr ""
"Экземпляры :class:`~handlers.DatagramHandler` отправляют сообщения в сокеты "
"UDP. Начиная с версии 3.4, также поддерживаются сокеты домена Unix."

#: ../../howto/logging.rst:918
msgid ""
":class:`~handlers.SMTPHandler` instances send messages to a designated email "
"address."
msgstr ""
"Экземпляры :class:`~handlers.SMTPHandler` отправляют сообщения на указанный "
"адрес электронной почты."

#: ../../howto/logging.rst:921
msgid ""
":class:`~handlers.SysLogHandler` instances send messages to a Unix syslog "
"daemon, possibly on a remote machine."
msgstr ""
"Экземпляры :class:`~handlers.SysLogHandler` отправляют сообщения демону "
"системного журнала Unix, возможно, на удаленном компьютере."

#: ../../howto/logging.rst:924
msgid ""
":class:`~handlers.NTEventLogHandler` instances send messages to a Windows "
"NT/2000/XP event log."
msgstr ""
"Экземпляры :class:`~handlers.NTEventLogHandler` отправляют сообщения в "
"журнал событий Windows NT/2000/XP."

#: ../../howto/logging.rst:927
msgid ""
":class:`~handlers.MemoryHandler` instances send messages to a buffer in "
"memory, which is flushed whenever specific criteria are met."
msgstr ""
"Экземпляры :class:`~handlers.MemoryHandler` отправляют сообщения в буфер в "
"памяти, который сбрасывается при выполнении определенных критериев."

#: ../../howto/logging.rst:930
msgid ""
":class:`~handlers.HTTPHandler` instances send messages to an HTTP server "
"using either ``GET`` or ``POST`` semantics."
msgstr ""
"Экземпляры :class:`~handlers.HTTPHandler` отправляют сообщения на HTTP-"
"сервер, используя семантику ``GET`` или ``POST``."

#: ../../howto/logging.rst:933
msgid ""
":class:`~handlers.WatchedFileHandler` instances watch the file they are "
"logging to. If the file changes, it is closed and reopened using the file "
"name. This handler is only useful on Unix-like systems; Windows does not "
"support the underlying mechanism used."
msgstr ""
"Экземпляры :class:`~handlers.WatchedFileHandler` наблюдают за файлом, в "
"который они записывают данные. Если файл изменяется, он закрывается и снова "
"открывается с использованием имени файла. Этот обработчик полезен только в "
"Unix-подобных системах; Windows не поддерживает используемый базовый "
"механизм."

#: ../../howto/logging.rst:938
msgid ""
":class:`~handlers.QueueHandler` instances send messages to a queue, such as "
"those implemented in the :mod:`queue` or :mod:`multiprocessing` modules."
msgstr ""
"Экземпляры :class:`~handlers.QueueHandler` отправляют сообщения в очередь, "
"например, реализованную в модулях :mod:`queue` или :mod:`multiprocessing`."

#: ../../howto/logging.rst:941
msgid ""
":class:`NullHandler` instances do nothing with error messages. They are used "
"by library developers who want to use logging, but want to avoid the 'No "
"handlers could be found for logger *XXX*' message which can be displayed if "
"the library user has not configured logging. See :ref:`library-config` for "
"more information."
msgstr ""
"Экземпляры :class:`NullHandler` ничего не делают с сообщениями об ошибках. "
"Они используются разработчиками библиотек, которые хотят использовать "
"ведение журнала, но хотят избежать сообщения «Не удалось найти обработчики "
"для средства ведения журнала *XXX*», которое может отображаться, если "
"пользователь библиотеки не настроил ведение журнала. Дополнительную "
"информацию смотрите в :ref:`library-config`."

#: ../../howto/logging.rst:947
msgid "The :class:`NullHandler` class."
msgstr "Класс :class:`NullHandler`."

#: ../../howto/logging.rst:950
msgid "The :class:`~handlers.QueueHandler` class."
msgstr "Класс :class:`~handlers.QueueHandler`."

#: ../../howto/logging.rst:953
msgid ""
"The :class:`NullHandler`, :class:`StreamHandler` and :class:`FileHandler` "
"classes are defined in the core logging package. The other handlers are "
"defined in a sub-module, :mod:`logging.handlers`. (There is also another sub-"
"module, :mod:`logging.config`, for configuration functionality.)"
msgstr ""
"Классы :class:`NullHandler`, :class:`StreamHandler` и :class:`FileHandler` "
"определены в основном пакете ведения журналов. Остальные обработчики "
"определены в подмодуле :mod:`logging.handlers`. (Существует также еще один "
"подмодуль :mod:`logging.config` для функций настройки.)"

#: ../../howto/logging.rst:958
msgid ""
"Logged messages are formatted for presentation through instances of the :"
"class:`Formatter` class. They are initialized with a format string suitable "
"for use with the % operator and a dictionary."
msgstr ""
"Зарегистрированные сообщения форматируются для представления через "
"экземпляры класса :class:`Formatter`. Они инициализируются строкой формата, "
"подходящей для использования с оператором % и словарем."

#: ../../howto/logging.rst:962
msgid ""
"For formatting multiple messages in a batch, instances of :class:"
"`BufferingFormatter` can be used. In addition to the format string (which is "
"applied to each message in the batch), there is provision for header and "
"trailer format strings."
msgstr ""
"Для форматирования нескольких сообщений в пакете можно использовать "
"экземпляры :class:`BufferingFormatter`. В дополнение к строке формата "
"(которая применяется к каждому сообщению в пакете) предусмотрены строки "
"формата заголовка и концевика."

#: ../../howto/logging.rst:967
msgid ""
"When filtering based on logger level and/or handler level is not enough, "
"instances of :class:`Filter` can be added to both :class:`Logger` and :class:"
"`Handler` instances (through their :meth:`~Handler.addFilter` method). "
"Before deciding to process a message further, both loggers and handlers "
"consult all their filters for permission. If any filter returns a false "
"value, the message is not processed further."
msgstr ""
"Если фильтрации на основе уровня регистратора и/или уровня обработчика "
"недостаточно, экземпляры :class:`Filter` можно добавить как к экземплярам :"
"class:`Logger`, так и к :class:`Handler` (через их :meth:`~ Handler."
"addFilter`). Прежде чем принять решение о дальнейшей обработке сообщения, и "
"регистраторы, и обработчики обращаются ко всем своим фильтрам за "
"разрешением. Если какой-либо фильтр возвращает ложное значение, сообщение "
"дальше не обрабатывается."

#: ../../howto/logging.rst:974
msgid ""
"The basic :class:`Filter` functionality allows filtering by specific logger "
"name. If this feature is used, messages sent to the named logger and its "
"children are allowed through the filter, and all others dropped."
msgstr ""
"Базовая функциональность :class:`Filter` позволяет фильтровать данные по "
"определенному имени регистратора. Если эта функция используется, сообщения, "
"отправленные указанному регистратору и его дочерним элементам, разрешаются "
"через фильтр, а все остальные удаляются."

#: ../../howto/logging.rst:982
msgid "Exceptions raised during logging"
msgstr "Исключения, возникающие во время регистрации"

#: ../../howto/logging.rst:984
msgid ""
"The logging package is designed to swallow exceptions which occur while "
"logging in production. This is so that errors which occur while handling "
"logging events - such as logging misconfiguration, network or other similar "
"errors - do not cause the application using logging to terminate prematurely."
msgstr ""
"Пакет журналирования предназначен для обработки исключений, возникающих при "
"входе в рабочую среду. Это сделано для того, чтобы ошибки, возникающие при "
"обработке событий регистрации, такие как неправильная конфигурация "
"регистрации, сетевые или другие подобные ошибки, не приводили к "
"преждевременному завершению работы приложения, использующего журналирование."

#: ../../howto/logging.rst:989
msgid ""
":class:`SystemExit` and :class:`KeyboardInterrupt` exceptions are never "
"swallowed. Other exceptions which occur during the :meth:`~Handler.emit` "
"method of a :class:`Handler` subclass are passed to its :meth:`~Handler."
"handleError` method."
msgstr ""
"Исключения :class:`SystemExit` и :class:`KeyboardInterrupt` никогда не "
"поглощаются. Другие исключения, которые возникают во время метода :meth:"
"`~Handler.emit` подкласса :class:`Handler`, передаются в его метод :meth:"
"`~Handler.handleError`."

#: ../../howto/logging.rst:994
msgid ""
"The default implementation of :meth:`~Handler.handleError` in :class:"
"`Handler` checks to see if a module-level variable, :data:`raiseExceptions`, "
"is set. If set, a traceback is printed to :data:`sys.stderr`. If not set, "
"the exception is swallowed."
msgstr ""
"Реализация :meth:`~Handler.handleError` в :class:`Handler` по умолчанию "
"проверяет, установлена ​​ли переменная уровня модуля :data:`raiseExceptions`. "
"Если установлено, обратная трассировка печатается в :data:`sys.stderr`. Если "
"не установлено, исключение проглатывается."

#: ../../howto/logging.rst:1000
msgid ""
"The default value of :data:`raiseExceptions` is ``True``. This is because "
"during development, you typically want to be notified of any exceptions that "
"occur. It's advised that you set :data:`raiseExceptions` to ``False`` for "
"production usage."
msgstr ""
"Значением по умолчанию :data:`raiseExceptions` является ``True``. Это "
"связано с тем, что во время разработки вы обычно хотите получать уведомления "
"о любых возникающих исключениях. Рекомендуется установить для параметра :"
"data:`raiseExceptions` значение ``False`` для производственного "
"использования."

#: ../../howto/logging.rst:1010
msgid "Using arbitrary objects as messages"
msgstr "Использование произвольных объектов в качестве сообщений"

#: ../../howto/logging.rst:1012
msgid ""
"In the preceding sections and examples, it has been assumed that the message "
"passed when logging the event is a string. However, this is not the only "
"possibility. You can pass an arbitrary object as a message, and its :meth:"
"`~object.__str__` method will be called when the logging system needs to "
"convert it to a string representation. In fact, if you want to, you can "
"avoid computing a string representation altogether - for example, the :class:"
"`~handlers.SocketHandler` emits an event by pickling it and sending it over "
"the wire."
msgstr ""
"В предыдущих разделах и примерах предполагалось, что сообщение, передаваемое "
"при регистрации события, представляет собой строку. Однако это не "
"единственная возможность. Вы можете передать произвольный объект в качестве "
"сообщения, и его метод :meth:`~object.__str__` будет вызываться, когда "
"системе журналирования потребуется преобразовать его в строковое "
"представление. Фактически, если вы хотите, вы можете вообще избежать "
"вычисления строкового представления - например, :class:`~handlers."
"SocketHandler` генерирует событие, маринуя его и отправляя по сети."

#: ../../howto/logging.rst:1023
msgid "Optimization"
msgstr "Оптимизация"

#: ../../howto/logging.rst:1025
msgid ""
"Formatting of message arguments is deferred until it cannot be avoided. "
"However, computing the arguments passed to the logging method can also be "
"expensive, and you may want to avoid doing it if the logger will just throw "
"away your event. To decide what to do, you can call the :meth:`~Logger."
"isEnabledFor` method which takes a level argument and returns true if the "
"event would be created by the Logger for that level of call. You can write "
"code like this::"
msgstr ""
"Форматирование аргументов сообщения откладывается до тех пор, пока его "
"нельзя будет избежать. Однако вычисление аргументов, передаваемых методу "
"регистрации, также может быть дорогостоящим, и вы можете не делать этого, "
"если средство регистрации просто выбросит ваше событие. Чтобы решить, что "
"делать, вы можете вызвать метод :meth:`~Logger.isEnabledFor`, который "
"принимает аргумент уровня и возвращает true, если событие будет создано "
"Logger для этого уровня вызова. Вы можете написать такой код::"

#: ../../howto/logging.rst:1037
msgid ""
"so that if the logger's threshold is set above ``DEBUG``, the calls to "
"``expensive_func1`` and ``expensive_func2`` are never made."
msgstr ""
"так что если порог регистратора установлен выше DEBUG, вызовы "
"expensive_func1 иexpensive_func2 никогда не выполняются."

#: ../../howto/logging.rst:1040
msgid ""
"In some cases, :meth:`~Logger.isEnabledFor` can itself be more expensive "
"than you'd like (e.g. for deeply nested loggers where an explicit level is "
"only set high up in the logger hierarchy). In such cases (or if you want to "
"avoid calling a method in tight loops), you can cache the result of a call "
"to :meth:`~Logger.isEnabledFor` in a local or instance variable, and use "
"that instead of calling the method each time. Such a cached value would only "
"need to be recomputed when the logging configuration changes dynamically "
"while the application is running (which is not all that common)."
msgstr ""
"В некоторых случаях :meth:`~Logger.isEnabledFor` может сам по себе оказаться "
"более дорогим, чем хотелось бы (например, для глубоко вложенных "
"регистраторов, где явный уровень устанавливается только высоко в иерархии "
"регистраторов). В таких случаях (или если вы хотите избежать вызова метода в "
"тесных циклах) вы можете кэшировать результат вызова :meth:`~Logger."
"isEnabledFor` в локальной переменной или переменной экземпляра и "
"использовать ее вместо вызова метода метод каждый раз. Такое кэшированное "
"значение необходимо будет пересчитывать только в том случае, если "
"конфигурация ведения журнала изменяется динамически во время работы "
"приложения (что случается не так уж и часто)."

#: ../../howto/logging.rst:1049
msgid ""
"There are other optimizations which can be made for specific applications "
"which need more precise control over what logging information is collected. "
"Here's a list of things you can do to avoid processing during logging which "
"you don't need:"
msgstr ""
"Существуют и другие оптимизации, которые можно выполнить для конкретных "
"приложений, которым требуется более точный контроль над тем, какая "
"информация собирается. Вот список того, что вы можете сделать, чтобы "
"избежать ненужной обработки во время регистрации:"

#: ../../howto/logging.rst:1055
msgid "What you don't want to collect"
msgstr "Что вы не хотите собирать"

#: ../../howto/logging.rst:1055
msgid "How to avoid collecting it"
msgstr "Как избежать сбора"

#: ../../howto/logging.rst:1057
msgid "Information about where calls were made from."
msgstr "Информация о том, откуда были совершены звонки."

#: ../../howto/logging.rst:1057
msgid ""
"Set ``logging._srcfile`` to ``None``. This avoids calling :func:`sys."
"_getframe`, which may help to speed up your code in environments like PyPy "
"(which can't speed up code that uses :func:`sys._getframe`)."
msgstr ""
"Установите для ``logging._srcfile`` значение ``None``. Это позволяет "
"избежать вызова :func:`sys._getframe`, что может помочь ускорить ваш код в "
"таких средах, как PyPy (который не может ускорить код, использующий :func:"
"`sys._getframe`)."

#: ../../howto/logging.rst:1063
msgid "Threading information."
msgstr "Потоковая передача информации."

#: ../../howto/logging.rst:1063
msgid "Set ``logging.logThreads`` to ``False``."
msgstr "Установите для logging.logThreads значение False."

#: ../../howto/logging.rst:1065
msgid "Current process ID (:func:`os.getpid`)"
msgstr "Текущий идентификатор процесса (:func:`os.getpid`)"

#: ../../howto/logging.rst:1065
msgid "Set ``logging.logProcesses`` to ``False``."
msgstr "Установите для ``logging.logProcesses`` значение ``False``."

#: ../../howto/logging.rst:1067
msgid ""
"Current process name when using ``multiprocessing`` to manage multiple "
"processes."
msgstr ""
"Текущее имя процесса при использовании многопроцессорности для управления "
"несколькими процессами."

#: ../../howto/logging.rst:1067
msgid "Set ``logging.logMultiprocessing`` to ``False``."
msgstr "Установите для logging.logMultiprocessing значение False."

#: ../../howto/logging.rst:1071
msgid ""
"Also note that the core logging module only includes the basic handlers. If "
"you don't import :mod:`logging.handlers` and :mod:`logging.config`, they "
"won't take up any memory."
msgstr ""
"Также обратите внимание, что основной модуль журналирования включает только "
"базовые обработчики. Если вы не импортируете :mod:`logging.handlers` и :mod:"
"`logging.config`, они не будут занимать память."

#: ../../howto/logging.rst:1078
msgid "Module :mod:`logging`"
msgstr "Модуль :mod:`logging`"

#: ../../howto/logging.rst:1078
msgid "API reference for the logging module."
msgstr "Ссылка на API для модуля ведения журнала."

#: ../../howto/logging.rst:1081
msgid "Module :mod:`logging.config`"
msgstr "Модуль :mod:`logging.config`"

#: ../../howto/logging.rst:1081
msgid "Configuration API for the logging module."
msgstr "API конфигурации для модуля журналирования."

#: ../../howto/logging.rst:1084
msgid "Module :mod:`logging.handlers`"
msgstr "Модуль :mod:`logging.handlers`"

#: ../../howto/logging.rst:1084
msgid "Useful handlers included with the logging module."
msgstr "Полезные обработчики, включенные в модуль журналирования."

#: ../../howto/logging.rst:1086
msgid ":ref:`A logging cookbook <logging-cookbook>`"
msgstr ":ref:`Книга рецептов ведения журналов <logging-cookbook>`"
