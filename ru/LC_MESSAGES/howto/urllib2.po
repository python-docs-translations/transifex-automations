# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-21 22:20+0000\n"
"PO-Revision-Date: 2023-05-24 02:11+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../howto/urllib2.rst:5
msgid "HOWTO Fetch Internet Resources Using The urllib Package"
msgstr "КАК получить интернет-ресурсы с помощью пакета urllib"

#: ../../howto/urllib2.rst:0
msgid "Author"
msgstr "Автор"

#: ../../howto/urllib2.rst:7
msgid "`Michael Foord <https://agileabstractions.com/>`_"
msgstr "`Майкл Фурд <https://agileabstractions.com/>`_"

#: ../../howto/urllib2.rst:11
msgid "Introduction"
msgstr "Введение"

#: ../../howto/urllib2.rst:15
msgid ""
"You may also find useful the following article on fetching web resources "
"with Python:"
msgstr ""
"Вам также может оказаться полезной следующая статья о получении веб-ресурсов "
"с помощью Python:"

#: ../../howto/urllib2.rst:18
msgid ""
"`Basic Authentication <https://web.archive.org/web/20201215133350/http://www."
"voidspace.org.uk/python/articles/authentication.shtml>`_"
msgstr ""
"`Базовая аутентификация <https://web.archive.org/web/20201215133350/http://"
"www.voidspace.org.uk/python/articles/authentication.shtml>`_"

#: ../../howto/urllib2.rst:20
msgid "A tutorial on *Basic Authentication*, with examples in Python."
msgstr "Учебник по *Базовой аутентификации* с примерами на Python."

#: ../../howto/urllib2.rst:22
msgid ""
"**urllib.request** is a Python module for fetching URLs (Uniform Resource "
"Locators). It offers a very simple interface, in the form of the *urlopen* "
"function. This is capable of fetching URLs using a variety of different "
"protocols. It also offers a slightly more complex interface for handling "
"common situations - like basic authentication, cookies, proxies and so on. "
"These are provided by objects called handlers and openers."
msgstr ""
"**urllib.request** — это модуль Python для получения URL-адресов "
"(унифицированных локаторов ресурсов). Он предлагает очень простой интерфейс "
"в виде функции *urlopen*. Он способен получать URL-адреса с использованием "
"различных протоколов. Он также предлагает немного более сложный интерфейс "
"для обработки распространенных ситуаций, таких как базовая аутентификация, "
"файлы cookie, прокси и т. д. Они предоставляются объектами, называемыми "
"обработчиками и открывателями."

#: ../../howto/urllib2.rst:29
msgid ""
"urllib.request supports fetching URLs for many \"URL schemes\" (identified "
"by the string before the ``\":\"`` in URL - for example ``\"ftp\"`` is the "
"URL scheme of ``\"ftp://python.org/\"``) using their associated network "
"protocols (e.g. FTP, HTTP). This tutorial focuses on the most common case, "
"HTTP."
msgstr ""
"urllib.request поддерживает получение URL-адресов для многих \"схем URL-"
"адресов\" (определяемых строкой перед ``\":\"`` в URL-адресе - например, "
"``\"ftp\"`` — это URL-схема ``\"ftp:// python.org/\"``), используя связанные "
"с ними сетевые протоколы (например, FTP, HTTP). В этом руководстве "
"рассматривается наиболее распространенный случай — HTTP."

#: ../../howto/urllib2.rst:34
msgid ""
"For straightforward situations *urlopen* is very easy to use. But as soon as "
"you encounter errors or non-trivial cases when opening HTTP URLs, you will "
"need some understanding of the HyperText Transfer Protocol. The most "
"comprehensive and authoritative reference to HTTP is :rfc:`2616`. This is a "
"technical document and not intended to be easy to read. This HOWTO aims to "
"illustrate using *urllib*, with enough detail about HTTP to help you "
"through. It is not intended to replace the :mod:`urllib.request` docs, but "
"is supplementary to them."
msgstr ""
"В простых ситуациях *urlopen* очень легко использовать. Но как только вы "
"столкнетесь с ошибками или нетривиальными случаями при открытии HTTP-ссылок, "
"вам понадобится некоторое понимание протокола передачи гипертекста. Наиболее "
"полная и авторитетная ссылка на HTTP — :rfc:`2616`. Это технический "
"документ, который не предназначен для легкого чтения. Этот HOWTO призван "
"проиллюстрировать использование *urllib* с достаточным количеством "
"подробностей о HTTP, чтобы помочь вам в этом. Он не предназначен для замены "
"документации :mod:`urllib.request`, а является дополнением к ней."

#: ../../howto/urllib2.rst:44
msgid "Fetching URLs"
msgstr "Получение URL-адресов"

#: ../../howto/urllib2.rst:46
msgid "The simplest way to use urllib.request is as follows::"
msgstr ""
"Самый простой способ использования urllib.request выглядит следующим образом:"

#: ../../howto/urllib2.rst:52
msgid ""
"If you wish to retrieve a resource via URL and store it in a temporary "
"location, you can do so via the :func:`shutil.copyfileobj` and :func:"
"`tempfile.NamedTemporaryFile` functions::"
msgstr ""
"Если вы хотите получить ресурс по URL-адресу и сохранить его во временном "
"расположении, вы можете сделать это с помощью функций :func:`shutil."
"copyfileobj` и :func:`tempfile.NamedTemporaryFile`::"

#: ../../howto/urllib2.rst:67
msgid ""
"Many uses of urllib will be that simple (note that instead of an 'http:' URL "
"we could have used a URL starting with 'ftp:', 'file:', etc.).  However, "
"it's the purpose of this tutorial to explain the more complicated cases, "
"concentrating on HTTP."
msgstr ""
"Многие варианты использования urllib будут настолько простыми (обратите "
"внимание, что вместо URL-адреса «http:» мы могли бы использовать URL-адрес, "
"начинающийся с «ftp:», «file:» и т. д.). Однако цель этого руководства — "
"объяснить более сложные случаи, сосредоточив внимание на HTTP."

#: ../../howto/urllib2.rst:72
msgid ""
"HTTP is based on requests and responses - the client makes requests and "
"servers send responses. urllib.request mirrors this with a ``Request`` "
"object which represents the HTTP request you are making. In its simplest "
"form you create a Request object that specifies the URL you want to fetch. "
"Calling ``urlopen`` with this Request object returns a response object for "
"the URL requested. This response is a file-like object, which means you can "
"for example call ``.read()`` on the response::"
msgstr ""
"HTTP основан на запросах и ответах: клиент отправляет запросы, а серверы "
"отправляют ответы. urllib.request отражает это с помощью объекта Request, "
"который представляет HTTP-запрос, который вы делаете. В своей простейшей "
"форме вы создаете объект Request, который указывает URL-адрес, который вы "
"хотите получить. Вызов urlopen с этим объектом Request возвращает объект "
"ответа для запрошенного URL. Этот ответ представляет собой файлоподобный "
"объект, что означает, что вы можете, например, вызвать ``.read()`` для "
"ответа:"

#: ../../howto/urllib2.rst:86
msgid ""
"Note that urllib.request makes use of the same Request interface to handle "
"all URL schemes.  For example, you can make an FTP request like so::"
msgstr ""
"Обратите внимание, что urllib.request использует один и тот же интерфейс "
"запроса для обработки всех схем URL-адресов. Например, вы можете сделать FTP-"
"запрос следующим образом:"

#: ../../howto/urllib2.rst:91
msgid ""
"In the case of HTTP, there are two extra things that Request objects allow "
"you to do: First, you can pass data to be sent to the server.  Second, you "
"can pass extra information (\"metadata\") *about* the data or about the "
"request itself, to the server - this information is sent as HTTP "
"\"headers\".  Let's look at each of these in turn."
msgstr ""
"В случае HTTP есть две дополнительные вещи, которые объекты Request "
"позволяют вам делать: во-первых, вы можете передавать данные для отправки на "
"сервер. Во-вторых, вы можете передать дополнительную информацию "
"(«метаданные») *о* данных или о самом запросе на сервер — эта информация "
"отправляется в виде «заголовков» HTTP. Давайте рассмотрим каждый из них по "
"очереди."

#: ../../howto/urllib2.rst:98
msgid "Data"
msgstr "Данные"

#: ../../howto/urllib2.rst:100
msgid ""
"Sometimes you want to send data to a URL (often the URL will refer to a CGI "
"(Common Gateway Interface) script or other web application). With HTTP, this "
"is often done using what's known as a **POST** request. This is often what "
"your browser does when you submit a HTML form that you filled in on the web. "
"Not all POSTs have to come from forms: you can use a POST to transmit "
"arbitrary data to your own application. In the common case of HTML forms, "
"the data needs to be encoded in a standard way, and then passed to the "
"Request object as the ``data`` argument. The encoding is done using a "
"function from the :mod:`urllib.parse` library. ::"
msgstr ""
"Иногда вам нужно отправить данные на URL-адрес (часто URL-адрес будет "
"относиться к сценарию CGI (Common Gateway Interface) или другому веб-"
"приложению). В HTTP это часто делается с помощью так называемого запроса "
"**POST**. Часто именно это делает ваш браузер, когда вы отправляете HTML-"
"форму, которую заполнили в Интернете. Не все POST-запросы должны поступать "
"из форм: вы можете использовать POST для передачи произвольных данных в ваше "
"собственное приложение. В обычном случае HTML-форм данные необходимо "
"закодировать стандартным способом, а затем передать объекту Request в "
"качестве аргумента data. Кодирование осуществляется с помощью функции из "
"библиотеки :mod:`urllib.parse`. ::"

#: ../../howto/urllib2.rst:124
msgid ""
"Note that other encodings are sometimes required (e.g. for file upload from "
"HTML forms - see `HTML Specification, Form Submission <https://www.w3.org/TR/"
"REC-html40/interact/forms.html#h-17.13>`_ for more details)."
msgstr ""
"Обратите внимание, что иногда требуются другие кодировки (например, для "
"загрузки файлов из HTML-форм — см. `Спецификация HTML, Отправка формы "
"<https://www.w3.org/TR/REC-html40/interact/forms.html#h-17.13>). `_ для "
"более подробной информации)."

#: ../../howto/urllib2.rst:129
msgid ""
"If you do not pass the ``data`` argument, urllib uses a **GET** request. One "
"way in which GET and POST requests differ is that POST requests often have "
"\"side-effects\": they change the state of the system in some way (for "
"example by placing an order with the website for a hundredweight of tinned "
"spam to be delivered to your door).  Though the HTTP standard makes it clear "
"that POSTs are intended to *always* cause side-effects, and GET requests "
"*never* to cause side-effects, nothing prevents a GET request from having "
"side-effects, nor a POST requests from having no side-effects. Data can also "
"be passed in an HTTP GET request by encoding it in the URL itself."
msgstr ""
"Если вы не передадите аргумент ``data``, urllib использует запрос **GET**. "
"Одно из отличий запросов GET и POST заключается в том, что запросы POST "
"часто имеют «побочные эффекты»: они каким-то образом меняют состояние "
"системы (например, размещая на веб-сайте заказ на доставку центнера "
"консервированного спама). до вашей двери). Хотя стандарт HTTP ясно дает "
"понять, что запросы POST *всегда* вызывают побочные эффекты, а запросы GET "
"*никогда* не вызывают побочных эффектов, ничто не препятствует тому, чтобы "
"запрос GET имел побочные эффекты, а запросы POST не имели побочных эффектов. "
"побочные эффекты. Данные также можно передавать в запросе HTTP GET, "
"закодировав их в самом URL-адресе."

#: ../../howto/urllib2.rst:139
msgid "This is done as follows::"
msgstr "Это делается следующим образом:"

#: ../../howto/urllib2.rst:154
msgid ""
"Notice that the full URL is created by adding a ``?`` to the URL, followed "
"by the encoded values."
msgstr ""
"Обратите внимание, что полный URL-адрес создается путем добавления к URL-"
"адресу символа ``?``, за которым следуют закодированные значения."

#: ../../howto/urllib2.rst:158
msgid "Headers"
msgstr "Заголовки"

#: ../../howto/urllib2.rst:160
msgid ""
"We'll discuss here one particular HTTP header, to illustrate how to add "
"headers to your HTTP request."
msgstr ""
"Мы обсудим здесь один конкретный HTTP-заголовок, чтобы проиллюстрировать, "
"как добавлять заголовки в ваш HTTP-запрос."

#: ../../howto/urllib2.rst:163
msgid ""
"Some websites [#]_ dislike being browsed by programs, or send different "
"versions to different browsers [#]_. By default urllib identifies itself as "
"``Python-urllib/x.y`` (where ``x`` and ``y`` are the major and minor version "
"numbers of the Python release, e.g. ``Python-urllib/2.5``), which may "
"confuse the site, or just plain not work. The way a browser identifies "
"itself is through the ``User-Agent`` header [#]_. When you create a Request "
"object you can pass a dictionary of headers in. The following example makes "
"the same request as above, but identifies itself as a version of Internet "
"Explorer [#]_. ::"
msgstr ""
"Некоторые веб-сайты [#]_ не нравится, когда их просматривают программы, или "
"отправляют разные версии в разные браузеры [#]_ . По умолчанию urllib "
"идентифицирует себя как ``Python-urllib/xy`` (где ``x`` и ``y`` — это "
"старший и дополнительный номера версий версии Python, например ``Python-"
"urllib/2.5`` ), что может запутать сайт или просто не работать. Браузер "
"идентифицирует себя через заголовок User-Agent. [#]_ . При создании объекта "
"Request вы можете передать словарь заголовков. В следующем примере "
"выполняется тот же запрос, что и выше, но он идентифицируется как версия "
"Internet Explorer. [#]_ . ::"

#: ../../howto/urllib2.rst:190
msgid ""
"The response also has two useful methods. See the section on `info and "
"geturl`_ which comes after we have a look at what happens when things go "
"wrong."
msgstr ""
"Ответ также имеет два полезных метода. См. раздел `info и geturl`_, который "
"появится после того, как мы рассмотрим, что происходит, когда что-то идет не "
"так."

#: ../../howto/urllib2.rst:195
msgid "Handling Exceptions"
msgstr " Обработка исключений"

#: ../../howto/urllib2.rst:197
msgid ""
"*urlopen* raises :exc:`~urllib.error.URLError` when it cannot handle a "
"response (though as usual with Python APIs, built-in exceptions such as :exc:"
"`ValueError`, :exc:`TypeError` etc. may also be raised)."
msgstr ""
"*urlopen* вызывает :exc:`~urllib.error.URLError`, когда он не может "
"обработать ответ (хотя, как обычно в API Python, встроенные исключения, "
"такие как :exc:`ValueError`, :exc:`TypeError` и т. д. тоже может быть "
"повышено)."

#: ../../howto/urllib2.rst:201
msgid ""
":exc:`~urllib.error.HTTPError` is the subclass of :exc:`~urllib.error."
"URLError` raised in the specific case of HTTP URLs."
msgstr ""
":exc:`~urllib.error.HTTPError` является подклассом :exc:`~urllib.error."
"URLError`, возникающим в конкретном случае HTTP-URL."

#: ../../howto/urllib2.rst:204
msgid "The exception classes are exported from the :mod:`urllib.error` module."
msgstr "Классы исключений экспортируются из модуля :mod:`urllib.error`."

#: ../../howto/urllib2.rst:207
msgid "URLError"
msgstr "URLError"

#: ../../howto/urllib2.rst:209
msgid ""
"Often, URLError is raised because there is no network connection (no route "
"to the specified server), or the specified server doesn't exist.  In this "
"case, the exception raised will have a 'reason' attribute, which is a tuple "
"containing an error code and a text error message."
msgstr ""
"Часто ошибка URLError возникает из-за отсутствия сетевого подключения (нет "
"маршрута к указанному серверу) или указанного сервера не существует. В этом "
"случае возникшее исключение будет иметь атрибут «причина», который "
"представляет собой кортеж, содержащий код ошибки и текстовое сообщение об "
"ошибке."

#: ../../howto/urllib2.rst:214
msgid "e.g. ::"
msgstr "напр. ::"

#: ../../howto/urllib2.rst:225
msgid "HTTPError"
msgstr "HTTPError"

#: ../../howto/urllib2.rst:227
msgid ""
"Every HTTP response from the server contains a numeric \"status code\". "
"Sometimes the status code indicates that the server is unable to fulfil the "
"request. The default handlers will handle some of these responses for you "
"(for example, if the response is a \"redirection\" that requests the client "
"fetch the document from a different URL, urllib will handle that for you). "
"For those it can't handle, urlopen will raise an :exc:`~urllib.error."
"HTTPError`. Typical errors include '404' (page not found), '403' (request "
"forbidden), and '401' (authentication required)."
msgstr ""
"Каждый HTTP-ответ от сервера содержит числовой «код состояния». Иногда код "
"состояния указывает на то, что сервер не может выполнить запрос. Обработчики "
"по умолчанию будут обрабатывать некоторые из этих ответов за вас (например, "
"если ответ представляет собой «перенаправление», которое запрашивает у "
"клиента получение документа с другого URL-адреса, urllib обработает это за "
"вас). Для тех, с которыми он не может справиться, urlopen выдаст :exc:"
"`~urllib.error.HTTPError`. Типичные ошибки включают «404» (страница не "
"найдена), «403» (запрос запрещен) и «401» (требуется проверка подлинности)."

#: ../../howto/urllib2.rst:235
msgid ""
"See section 10 of :rfc:`2616` for a reference on all the HTTP error codes."
msgstr ""
"См. раздел 10 документа :rfc:`2616` для получения информации обо всех кодах "
"ошибок HTTP."

#: ../../howto/urllib2.rst:237
msgid ""
"The :exc:`~urllib.error.HTTPError` instance raised will have an integer "
"'code' attribute, which corresponds to the error sent by the server."
msgstr ""
"Созданный экземпляр :exc:`~urllib.error.HTTPError` будет иметь целочисленный "
"атрибут code, который соответствует ошибке, отправленной сервером."

#: ../../howto/urllib2.rst:241
msgid "Error Codes"
msgstr "Коды ошибок"

#: ../../howto/urllib2.rst:243
msgid ""
"Because the default handlers handle redirects (codes in the 300 range), and "
"codes in the 100--299 range indicate success, you will usually only see "
"error codes in the 400--599 range."
msgstr ""
"Поскольку обработчики по умолчанию обрабатывают перенаправления (коды в "
"диапазоне 300), а коды в диапазоне 100–299 указывают на успех, вы обычно "
"увидите только коды ошибок в диапазоне 400–599."

#: ../../howto/urllib2.rst:247
msgid ""
":attr:`http.server.BaseHTTPRequestHandler.responses` is a useful dictionary "
"of response codes in that shows all the response codes used by :rfc:`2616`. "
"The dictionary is reproduced here for convenience ::"
msgstr ""
":attr:`http.server.BaseHTTPRequestHandler.responses` — это полезный словарь "
"кодов ответов, в котором показаны все коды ответов, используемые :rfc:"
"`2616`. Словарь воспроизведен здесь для удобства::"

#: ../../howto/urllib2.rst:319
msgid ""
"When an error is raised the server responds by returning an HTTP error code "
"*and* an error page. You can use the :exc:`~urllib.error.HTTPError` instance "
"as a response on the page returned. This means that as well as the code "
"attribute, it also has read, geturl, and info, methods as returned by the "
"``urllib.response`` module::"
msgstr ""
"При возникновении ошибки сервер отвечает, возвращая код ошибки HTTP *и* "
"страницу с ошибкой. Вы можете использовать экземпляр :exc:`~urllib.error."
"HTTPError` в качестве ответа на возвращаемой странице. Это означает, что "
"помимо атрибута code он также имеет методы read, geturl и info, возвращаемые "
"модулем urllib.response:"

#: ../../howto/urllib2.rst:339
msgid "Wrapping it Up"
msgstr "Подведем итоги"

#: ../../howto/urllib2.rst:341
msgid ""
"So if you want to be prepared for :exc:`~urllib.error.HTTPError` *or* :exc:"
"`~urllib.error.URLError` there are two basic approaches. I prefer the second "
"approach."
msgstr ""
"Итак, если вы хотите быть готовыми к :exc:`~urllib.error.HTTPError` *или* :"
"exc:`~urllib.error.URLError`, есть два основных подхода. Я предпочитаю "
"второй подход."

#: ../../howto/urllib2.rst:345
msgid "Number 1"
msgstr "Номер 1"

#: ../../howto/urllib2.rst:367
msgid ""
"The ``except HTTPError`` *must* come first, otherwise ``except URLError`` "
"will *also* catch an :exc:`~urllib.error.HTTPError`."
msgstr ""
"``кроме HTTPError`` *должен* идти первым, иначе ``кроме URLError`` *также* "
"перехватит :exc:`~urllib.error.HTTPError`."

#: ../../howto/urllib2.rst:371
msgid "Number 2"
msgstr "Номер 2"

#: ../../howto/urllib2.rst:392
msgid "info and geturl"
msgstr "информация и geturl"

#: ../../howto/urllib2.rst:394
msgid ""
"The response returned by urlopen (or the :exc:`~urllib.error.HTTPError` "
"instance) has two useful methods :meth:`!info` and :meth:`!geturl` and is "
"defined in the module :mod:`urllib.response`."
msgstr ""
"Ответ, возвращаемый urlopen (или экземпляром :exc:`~urllib.error."
"HTTPError`), имеет два полезных метода :meth:`!info` и :meth:`!geturl` и "
"определен в модуле :mod:` urllib.response`."

#: ../../howto/urllib2.rst:398
msgid ""
"**geturl** - this returns the real URL of the page fetched. This is useful "
"because ``urlopen`` (or the opener object used) may have followed a "
"redirect. The URL of the page fetched may not be the same as the URL "
"requested."
msgstr ""
"**geturl** — возвращает реальный URL полученной страницы. Это полезно, "
"поскольку urlopen (или используемый объект открытия) мог следовать за "
"перенаправлением. URL-адрес полученной страницы может не совпадать с "
"запрошенным URL-адресом."

#: ../../howto/urllib2.rst:402
msgid ""
"**info** - this returns a dictionary-like object that describes the page "
"fetched, particularly the headers sent by the server. It is currently an :"
"class:`http.client.HTTPMessage` instance."
msgstr ""
"**info** — возвращает объект, похожий на словарь, который описывает "
"полученную страницу, в частности заголовки, отправленные сервером. В "
"настоящее время это экземпляр :class:`http.client.HTTPMessage`."

#: ../../howto/urllib2.rst:406
msgid ""
"Typical headers include 'Content-length', 'Content-type', and so on. See the "
"`Quick Reference to HTTP Headers <https://jkorpela.fi/http.html>`_ for a "
"useful listing of HTTP headers with brief explanations of their meaning and "
"use."
msgstr ""
"Типичные заголовки включают «Длина контента», «Тип контента» и т. д. См. "
"`Краткий справочник по заголовкам HTTP <https://jkorpela.fi/http.html>`_ для "
"получения полезного списка заголовков HTTP с краткими объяснениями их "
"значения и использования."

#: ../../howto/urllib2.rst:413
msgid "Openers and Handlers"
msgstr "Открыватели и манипуляторы"

#: ../../howto/urllib2.rst:415
msgid ""
"When you fetch a URL you use an opener (an instance of the perhaps "
"confusingly named :class:`urllib.request.OpenerDirector`). Normally we have "
"been using the default opener - via ``urlopen`` - but you can create custom "
"openers. Openers use handlers. All the \"heavy lifting\" is done by the "
"handlers. Each handler knows how to open URLs for a particular URL scheme "
"(http, ftp, etc.), or how to handle an aspect of URL opening, for example "
"HTTP redirections or HTTP cookies."
msgstr ""
"Когда вы получаете URL-адрес, вы используете открывающее устройство "
"(экземпляр, возможно, с запутанным названием :class:`urllib.request."
"OpenerDirector`). Обычно мы используем открыватель по умолчанию — через "
"urlopen — но вы можете создавать собственные открыватели. Открыватели "
"используют обработчики. Всю «тяжелую работу» выполняют проводники. Каждый "
"обработчик знает, как открывать URL-адреса для определенной схемы URL-"
"адресов (http, ftp и т. д.) или как обрабатывать какой-либо аспект открытия "
"URL-адреса, например перенаправление HTTP или файлы cookie HTTP."

#: ../../howto/urllib2.rst:423
msgid ""
"You will want to create openers if you want to fetch URLs with specific "
"handlers installed, for example to get an opener that handles cookies, or to "
"get an opener that does not handle redirections."
msgstr ""
"Вам понадобится создать средства открытия, если вы хотите получать URL-"
"адреса с установленными определенными обработчиками, например, чтобы "
"получить средство открытия, которое обрабатывает файлы cookie, или получить "
"средство открытия, которое не обрабатывает перенаправления."

#: ../../howto/urllib2.rst:427
msgid ""
"To create an opener, instantiate an ``OpenerDirector``, and then call ``."
"add_handler(some_handler_instance)`` repeatedly."
msgstr ""
"Чтобы создать открывающее средство, создайте экземпляр OpenerDirector, а "
"затем несколько раз вызовите .add_handler(some_handler_instance)."

#: ../../howto/urllib2.rst:430
msgid ""
"Alternatively, you can use ``build_opener``, which is a convenience function "
"for creating opener objects with a single function call.  ``build_opener`` "
"adds several handlers by default, but provides a quick way to add more and/"
"or override the default handlers."
msgstr ""
"В качестве альтернативы вы можете использовать build_opener, удобную функцию "
"для создания объектов открытия с помощью одного вызова функции. "
"``build_opener`` добавляет несколько обработчиков по умолчанию, но "
"обеспечивает быстрый способ добавить больше и/или переопределить обработчики "
"по умолчанию."

#: ../../howto/urllib2.rst:435
msgid ""
"Other sorts of handlers you might want to can handle proxies, "
"authentication, and other common but slightly specialised situations."
msgstr ""
"Другие типы обработчиков, которые вам могут понадобиться, могут обрабатывать "
"прокси, аутентификацию и другие распространенные, но немного "
"специализированные ситуации."

#: ../../howto/urllib2.rst:438
msgid ""
"``install_opener`` can be used to make an ``opener`` object the (global) "
"default opener. This means that calls to ``urlopen`` will use the opener you "
"have installed."
msgstr ""
"``install_opener`` можно использовать, чтобы сделать объект ``opener`` "
"(глобальным) открывателем по умолчанию. Это означает, что вызовы urlopen "
"будут использовать установленный вами открыватель."

#: ../../howto/urllib2.rst:442
msgid ""
"Opener objects have an ``open`` method, which can be called directly to "
"fetch urls in the same way as the ``urlopen`` function: there's no need to "
"call ``install_opener``, except as a convenience."
msgstr ""
"Объекты Opener имеют метод open, который можно вызывать напрямую для "
"получения URL-адресов так же, как и функцию urlopen: нет необходимости "
"вызывать install_opener, кроме как для удобства."

#: ../../howto/urllib2.rst:448
msgid "Basic Authentication"
msgstr "Базовая аутентификация"

#: ../../howto/urllib2.rst:450
msgid ""
"To illustrate creating and installing a handler we will use the "
"``HTTPBasicAuthHandler``. For a more detailed discussion of this subject -- "
"including an explanation of how Basic Authentication works - see the `Basic "
"Authentication Tutorial <https://web.archive.org/web/20201215133350/http://"
"www.voidspace.org.uk/python/articles/authentication.shtml>`__."
msgstr ""
"Чтобы проиллюстрировать создание и установку обработчика, мы будем "
"использовать HTTPBasicAuthHandler. Более подробное обсуждение этой темы, "
"включая объяснение того, как работает базовая аутентификация, см. в "
"«Руководстве по базовой аутентификации» <https://web.archive.org/"
"web/20201215133350/http://www.voidspace.org. uk/python/articles/"
"authentication.shtml>`__."

#: ../../howto/urllib2.rst:456
msgid ""
"When authentication is required, the server sends a header (as well as the "
"401 error code) requesting authentication.  This specifies the "
"authentication scheme and a 'realm'. The header looks like: ``WWW-"
"Authenticate: SCHEME realm=\"REALM\"``."
msgstr ""
"Когда требуется аутентификация, сервер отправляет заголовок (а также код "
"ошибки 401) с запросом аутентификации. Это определяет схему аутентификации и "
"«область». Заголовок выглядит так: ``WWW-Authenticate: "
"SCHEMErealm=\"REALM\"``."

#: ../../howto/urllib2.rst:461
msgid "e.g."
msgstr "напр."

#: ../../howto/urllib2.rst:468
msgid ""
"The client should then retry the request with the appropriate name and "
"password for the realm included as a header in the request. This is 'basic "
"authentication'. In order to simplify this process we can create an instance "
"of ``HTTPBasicAuthHandler`` and an opener to use this handler."
msgstr ""
"Затем клиент должен повторить запрос с соответствующим именем и паролем для "
"области, включенными в заголовок запроса. Это «базовая аутентификация». "
"Чтобы упростить этот процесс, мы можем создать экземпляр "
"HTTPBasicAuthHandler и средство открытия для использования этого обработчика."

#: ../../howto/urllib2.rst:473
msgid ""
"The ``HTTPBasicAuthHandler`` uses an object called a password manager to "
"handle the mapping of URLs and realms to passwords and usernames. If you "
"know what the realm is (from the authentication header sent by the server), "
"then you can use a ``HTTPPasswordMgr``. Frequently one doesn't care what the "
"realm is. In that case, it is convenient to use "
"``HTTPPasswordMgrWithDefaultRealm``. This allows you to specify a default "
"username and password for a URL. This will be supplied in the absence of you "
"providing an alternative combination for a specific realm. We indicate this "
"by providing ``None`` as the realm argument to the ``add_password`` method."
msgstr ""
"HTTPBasicAuthHandler использует объект, называемый менеджером паролей, для "
"обработки сопоставления URL-адресов и областей с паролями и именами "
"пользователей. Если вы знаете, что такое область (из заголовка "
"аутентификации, отправленного сервером), вы можете использовать "
"HTTPPasswordMgr. Часто человека не волнует, что это за царство. В этом "
"случае удобно использовать HTTPPasswordMgrWithDefaultRealm. Это позволяет "
"вам указать имя пользователя и пароль по умолчанию для URL-адреса. Это будет "
"предоставлено, если вы не предоставите альтернативную комбинацию для "
"конкретной области. Мы указываем это, предоставляя None в качестве аргумента "
"области для метода add_password."

#: ../../howto/urllib2.rst:483
msgid ""
"The top-level URL is the first URL that requires authentication. URLs "
"\"deeper\" than the URL you pass to .add_password() will also match. ::"
msgstr ""
"URL-адрес верхнего уровня — это первый URL-адрес, требующий аутентификации. "
"URL-адреса «глубже», чем URL-адрес, который вы передаете в .add_password(), "
"также будут совпадать. ::"

#: ../../howto/urllib2.rst:508
msgid ""
"In the above example we only supplied our ``HTTPBasicAuthHandler`` to "
"``build_opener``. By default openers have the handlers for normal situations "
"-- ``ProxyHandler`` (if a proxy setting such as an :envvar:`!http_proxy` "
"environment variable is set), ``UnknownHandler``, ``HTTPHandler``, "
"``HTTPDefaultErrorHandler``, ``HTTPRedirectHandler``, ``FTPHandler``, "
"``FileHandler``, ``DataHandler``, ``HTTPErrorProcessor``."
msgstr ""
"В приведенном выше примере мы предоставили только наш HTTPBasicAuthHandler "
"для build_opener. По умолчанию открывающие программы имеют обработчики для "
"нормальных ситуаций — ``ProxyHandler`` (если установлены такие настройки "
"прокси, как переменная среды :envvar:`!http_proxy`), ``UnknownHandler``, "
"``HTTPHandler``, `` `HTTPDefaultErrorHandler``, ``HTTPRedirectHandler``, "
"``FTPHandler``, ``FileHandler``, ``DataHandler``, ``HTTPErrorProcessor``."

#: ../../howto/urllib2.rst:515
msgid ""
"``top_level_url`` is in fact *either* a full URL (including the 'http:' "
"scheme component and the hostname and optionally the port number) e.g. "
"``\"http://example.com/\"`` *or* an \"authority\" (i.e. the hostname, "
"optionally including the port number) e.g. ``\"example.com\"`` or "
"``\"example.com:8080\"`` (the latter example includes a port number).  The "
"authority, if present, must NOT contain the \"userinfo\" component - for "
"example ``\"joe:password@example.com\"`` is not correct."
msgstr ""
"``top_level_url`` на самом деле *либо* полный URL-адрес (включая компонент "
"схемы 'http:', имя хоста и, возможно, номер порта), например ``\"http://"
"example.com/\"`` *или* «авторитет» (т. е. имя хоста, необязательно включая "
"номер порта), например «example.com» или «example.com:8080» (последний "
"пример включает номер порта). Полномочия, если они присутствуют, НЕ должны "
"содержать компонент «userinfo» — например, ``\"joe:password@example.com\"`` "
"неверен."

#: ../../howto/urllib2.rst:525
msgid "Proxies"
msgstr "Прокси-серверы"

#: ../../howto/urllib2.rst:527
msgid ""
"**urllib** will auto-detect your proxy settings and use those. This is "
"through the ``ProxyHandler``, which is part of the normal handler chain when "
"a proxy setting is detected.  Normally that's a good thing, but there are "
"occasions when it may not be helpful [#]_. One way to do this is to setup "
"our own ``ProxyHandler``, with no proxies defined. This is done using "
"similar steps to setting up a `Basic Authentication`_ handler: ::"
msgstr ""
"**urllib** автоматически определит настройки вашего прокси-сервера и будет "
"использовать их. Это осуществляется через ProxyHandler, который является "
"частью обычной цепочки обработчиков при обнаружении настройки прокси. Обычно "
"это хорошо, но бывают случаи, когда это может оказаться бесполезным. [#]_ . "
"Один из способов сделать это — настроить наш собственный ProxyHandler без "
"определения прокси. Это делается с помощью шагов, аналогичных настройке "
"обработчика `Basic Authentication`_:::"

#: ../../howto/urllib2.rst:540
msgid ""
"Currently ``urllib.request`` *does not* support fetching of ``https`` "
"locations through a proxy.  However, this can be enabled by extending urllib."
"request as shown in the recipe [#]_."
msgstr ""
"В настоящее время urllib.request *не* поддерживает получение местоположений "
"https через прокси. Однако это можно включить, расширив urllib.request, как "
"показано в рецепте. [#]_ ."

#: ../../howto/urllib2.rst:546
msgid ""
"``HTTP_PROXY`` will be ignored if a variable ``REQUEST_METHOD`` is set; see "
"the documentation on :func:`~urllib.request.getproxies`."
msgstr ""
"``HTTP_PROXY`` будет игнорироваться, если установлена ​​переменная "
"``REQUEST_METHOD``; см. документацию по :func:`~urllib.request.getproxies`."

#: ../../howto/urllib2.rst:551
msgid "Sockets and Layers"
msgstr "Сокеты и слои"

#: ../../howto/urllib2.rst:553
msgid ""
"The Python support for fetching resources from the web is layered.  urllib "
"uses the :mod:`http.client` library, which in turn uses the socket library."
msgstr ""
"Поддержка Python для получения ресурсов из Интернета является "
"многоуровневой. urllib использует библиотеку :mod:`http.client`, которая, в "
"свою очередь, использует библиотеку сокетов."

#: ../../howto/urllib2.rst:556
msgid ""
"As of Python 2.3 you can specify how long a socket should wait for a "
"response before timing out. This can be useful in applications which have to "
"fetch web pages. By default the socket module has *no timeout* and can hang. "
"Currently, the socket timeout is not exposed at the http.client or urllib."
"request levels. However, you can set the default timeout globally for all "
"sockets using ::"
msgstr ""
"Начиная с Python 2.3, вы можете указать, как долго сокет должен ждать "
"ответа, прежде чем истечет время ожидания. Это может быть полезно в "
"приложениях, которым необходимо получать веб-страницы. По умолчанию модуль "
"сокета не имеет тайм-аута и может зависать. В настоящее время тайм-аут "
"сокета не отображается на уровнях http.client или urllib.request. Однако вы "
"можете установить тайм-аут по умолчанию глобально для всех сокетов, "
"используя ::"

#: ../../howto/urllib2.rst:579
msgid "Footnotes"
msgstr "Сноски"

#: ../../howto/urllib2.rst:581
msgid "This document was reviewed and revised by John Lee."
msgstr "Этот документ был рассмотрен и исправлен Джоном Ли."

#: ../../howto/urllib2.rst:583
msgid "Google for example."
msgstr "Например, Google."

#: ../../howto/urllib2.rst:584
msgid ""
"Browser sniffing is a very bad practice for website design - building sites "
"using web standards is much more sensible. Unfortunately a lot of sites "
"still send different versions to different browsers."
msgstr ""
"Сниффинг браузера — очень плохая практика для дизайна веб-сайтов: создание "
"сайтов с использованием веб-стандартов гораздо разумнее. К сожалению, многие "
"сайты по-прежнему отправляют разные версии в разные браузеры."

#: ../../howto/urllib2.rst:587
msgid ""
"The user agent for MSIE 6 is *'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT "
"5.1; SV1; .NET CLR 1.1.4322)'*"
msgstr ""
"Пользовательским агентом для MSIE 6 является *'Mozilla/4.0 (совместимый; "
"MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 1.1.4322)'*"

#: ../../howto/urllib2.rst:589
msgid ""
"For details of more HTTP request headers, see `Quick Reference to HTTP "
"Headers`_."
msgstr ""
"Дополнительные сведения о заголовках HTTP-запросов см. в разделе «Краткий "
"справочник по заголовкам HTTP»."

#: ../../howto/urllib2.rst:591
msgid ""
"In my case I have to use a proxy to access the internet at work. If you "
"attempt to fetch *localhost* URLs through this proxy it blocks them. IE is "
"set to use the proxy, which urllib picks up on. In order to test scripts "
"with a localhost server, I have to prevent urllib from using the proxy."
msgstr ""
"В моем случае мне приходится использовать прокси для доступа в Интернет на "
"работе. Если вы попытаетесь получить URL-адреса *localhost* через этот "
"прокси, он их заблокирует. IE настроен на использование прокси, который "
"подхватывает urllib. Чтобы протестировать сценарии на локальном сервере, мне "
"нужно запретить urllib использовать прокси."

#: ../../howto/urllib2.rst:596
msgid ""
"urllib opener for SSL proxy (CONNECT method): `ASPN Cookbook Recipe <https://"
"code.activestate.com/recipes/456195/>`_."
msgstr ""
