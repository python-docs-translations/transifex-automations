# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-21 22:20+0000\n"
"PO-Revision-Date: 2023-05-24 02:11+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../howto/isolating-extensions.rst:5
msgid "Isolating Extension Modules"
msgstr "Изолирующие модули расширения"

#: ../../howto/isolating-extensions.rst-1
msgid "Abstract"
msgstr "Абстракция"

#: ../../howto/isolating-extensions.rst:9
msgid ""
"Traditionally, state belonging to Python extension modules was kept in C "
"``static`` variables, which have process-wide scope. This document describes "
"problems of such per-process state and shows a safer way: per-module state."
msgstr ""
"Традиционно состояние, принадлежащее модулям расширения Python, сохранялось "
"в статических переменных C, которые имеют область действия на уровне всего "
"процесса. В этом документе описываются проблемы такого состояния каждого "
"процесса и показан более безопасный способ: состояние каждого модуля."

#: ../../howto/isolating-extensions.rst:14
msgid ""
"The document also describes how to switch to per-module state where "
"possible. This transition involves allocating space for that state, "
"potentially switching from static types to heap types, and—perhaps most "
"importantly—accessing per-module state from code."
msgstr ""
"В документе также описывается, как переключиться в состояние каждого модуля, "
"где это возможно. Этот переход включает в себя выделение места для этого "
"состояния, потенциальное переключение со статических типов на типы кучи и — "
"возможно, самое главное — доступ к состоянию каждого модуля из кода."

#: ../../howto/isolating-extensions.rst:21
msgid "Who should read this"
msgstr "Кому следует это прочитать"

#: ../../howto/isolating-extensions.rst:23
msgid ""
"This guide is written for maintainers of :ref:`C-API <c-api-index>` "
"extensions who would like to make that extension safer to use in "
"applications where Python itself is used as a library."
msgstr ""
"Это руководство написано для сопровождающих расширений :ref:`C-API <c-api-"
"index>`, которые хотели бы сделать это расширение более безопасным для "
"использования в приложениях, где сам Python используется в качестве "
"библиотеки."

#: ../../howto/isolating-extensions.rst:29
msgid "Background"
msgstr "Фон"

#: ../../howto/isolating-extensions.rst:31
msgid ""
"An *interpreter* is the context in which Python code runs. It contains "
"configuration (e.g. the import path) and runtime state (e.g. the set of "
"imported modules)."
msgstr ""
"*Интерпретатор* — это контекст, в котором выполняется код Python. Он "
"содержит конфигурацию (например, путь импорта) и состояние времени "
"выполнения (например, набор импортированных модулей)."

#: ../../howto/isolating-extensions.rst:35
msgid ""
"Python supports running multiple interpreters in one process. There are two "
"cases to think about—users may run interpreters:"
msgstr ""
"Python поддерживает запуск нескольких интерпретаторов в одном процессе. Есть "
"два случая, о которых следует подумать: пользователи могут запускать "
"интерпретаторы:"

#: ../../howto/isolating-extensions.rst:38
msgid ""
"in sequence, with several :c:func:`Py_InitializeEx`/:c:func:`Py_FinalizeEx` "
"cycles, and"
msgstr ""
"последовательно, с несколькими циклами :c:func:`Py_InitializeEx`/:c:func:"
"`Py_FinalizeEx`, и"

#: ../../howto/isolating-extensions.rst:40
msgid ""
"in parallel, managing \"sub-interpreters\" using :c:func:"
"`Py_NewInterpreter`/:c:func:`Py_EndInterpreter`."
msgstr ""
"параллельно управление «субинтерпретаторами» с помощью :c:func:"
"`Py_NewInterpreter`/:c:func:`Py_EndInterpreter`."

#: ../../howto/isolating-extensions.rst:43
msgid ""
"Both cases (and combinations of them) would be most useful when embedding "
"Python within a library. Libraries generally shouldn't make assumptions "
"about the application that uses them, which include assuming a process-wide "
"\"main Python interpreter\"."
msgstr ""
"Оба случая (и их комбинации) будут наиболее полезны при встраивании Python в "
"библиотеку. Библиотеки, как правило, не должны делать предположений о "
"приложении, которое их использует, в том числе предполагать наличие "
"«основного интерпретатора Python» в масштабе всего процесса."

#: ../../howto/isolating-extensions.rst:48
msgid ""
"Historically, Python extension modules don't handle this use case well. Many "
"extension modules (and even some stdlib modules) use *per-process* global "
"state, because C ``static`` variables are extremely easy to use. Thus, data "
"that should be specific to an interpreter ends up being shared between "
"interpreters. Unless the extension developer is careful, it is very easy to "
"introduce edge cases that lead to crashes when a module is loaded in more "
"than one interpreter in the same process."
msgstr ""
"Исторически сложилось так, что модули расширения Python плохо справляются с "
"этим вариантом использования. Многие модули расширения (и даже некоторые "
"модули stdlib) используют глобальное состояние каждого процесса, поскольку "
"статические переменные C чрезвычайно просты в использовании. Таким образом, "
"данные, которые должны быть специфичны для интерпретатора, в конечном итоге "
"распределяются между интерпретаторами. Если разработчик расширения не будет "
"осторожен, очень легко ввести пограничные случаи, которые приведут к сбоям, "
"когда модуль загружается более чем в один интерпретатор в одном и том же "
"процессе."

#: ../../howto/isolating-extensions.rst:56
msgid ""
"Unfortunately, *per-interpreter* state is not easy to achieve. Extension "
"authors tend to not keep multiple interpreters in mind when developing, and "
"it is currently cumbersome to test the behavior."
msgstr ""
"К сожалению, достичь состояния *для каждого интерпретатора* непросто. Авторы "
"расширений, как правило, не учитывают наличие нескольких интерпретаторов при "
"разработке, и в настоящее время тестировать такое поведение затруднительно."

#: ../../howto/isolating-extensions.rst:61
msgid "Enter Per-Module State"
msgstr "Введите состояние каждого модуля"

#: ../../howto/isolating-extensions.rst:63
msgid ""
"Instead of focusing on per-interpreter state, Python's C API is evolving to "
"better support the more granular *per-module* state. This means that C-level "
"data is be attached to a *module object*. Each interpreter creates its own "
"module object, keeping the data separate. For testing the isolation, "
"multiple module objects corresponding to a single extension can even be "
"loaded in a single interpreter."
msgstr ""

#: ../../howto/isolating-extensions.rst:70
msgid ""
"Per-module state provides an easy way to think about lifetime and resource "
"ownership: the extension module will initialize when a module object is "
"created, and clean up when it's freed. In this regard, a module is just like "
"any other :c:expr:`PyObject *`; there are no \"on interpreter shutdown\" "
"hooks to think—or forget—about."
msgstr ""
"Состояние каждого модуля позволяет легко учитывать время жизни и владение "
"ресурсами: модуль расширения инициализируется при создании объекта модуля и "
"очищается при его освобождении. В этом отношении модуль ничем не отличается "
"от любого другого :c:expr:`PyObject *`; нет никаких ловушек «при выключении "
"интерпретатора», о которых нужно подумать или забыть."

#: ../../howto/isolating-extensions.rst:76
msgid ""
"Note that there are use cases for different kinds of \"globals\": per-"
"process, per-interpreter, per-thread or per-task state. With per-module "
"state as the default, these are still possible, but you should treat them as "
"exceptional cases: if you need them, you should give them additional care "
"and testing. (Note that this guide does not cover them.)"
msgstr ""
"Обратите внимание, что существуют варианты использования различных типов "
"«глобальных переменных»: состояние каждого процесса, каждого интерпретатора, "
"каждого потока или состояния каждой задачи. Если состояние каждого модуля "
"установлено по умолчанию, это все еще возможно, но к ним следует относиться "
"как к исключительным случаям: если они вам нужны, вам следует уделить им "
"дополнительный уход и тестирование. (Обратите внимание, что в этом "
"руководстве они не рассматриваются.)"

#: ../../howto/isolating-extensions.rst:85
msgid "Isolated Module Objects"
msgstr "Изолированные объекты модуля"

#: ../../howto/isolating-extensions.rst:87
msgid ""
"The key point to keep in mind when developing an extension module is that "
"several module objects can be created from a single shared library. For "
"example:"
msgstr ""
"Ключевым моментом, который следует учитывать при разработке модуля "
"расширения, является то, что несколько объектов модуля могут быть созданы из "
"одной общей библиотеки. Например:"

#: ../../howto/isolating-extensions.rst:101
msgid ""
"As a rule of thumb, the two modules should be completely independent. All "
"objects and state specific to the module should be encapsulated within the "
"module object, not shared with other module objects, and cleaned up when the "
"module object is deallocated. Since this just is a rule of thumb, exceptions "
"are possible (see `Managing Global State`_), but they will need more thought "
"and attention to edge cases."
msgstr ""
"Как правило, два модуля должны быть полностью независимыми. Все объекты и "
"состояние, специфичные для модуля, должны быть инкапсулированы внутри "
"объекта модуля, не использоваться совместно с другими объектами модуля и "
"очищаться при освобождении объекта модуля. Поскольку это всего лишь "
"эмпирическое правило, возможны исключения (см. «Управление глобальным "
"состоянием»), но для крайних случаев потребуется больше внимания и внимания."

#: ../../howto/isolating-extensions.rst:109
msgid ""
"While some modules could do with less stringent restrictions, isolated "
"modules make it easier to set clear expectations and guidelines that work "
"across a variety of use cases."
msgstr ""
"Хотя для некоторых модулей можно было бы использовать менее строгие "
"ограничения, изолированные модули упрощают установление четких ожиданий и "
"рекомендаций, которые подходят для различных вариантов использования."

#: ../../howto/isolating-extensions.rst:115
msgid "Surprising Edge Cases"
msgstr "Неожиданные крайние случаи"

#: ../../howto/isolating-extensions.rst:117
msgid ""
"Note that isolated modules do create some surprising edge cases. Most "
"notably, each module object will typically not share its classes and "
"exceptions with other similar modules. Continuing from the `example above "
"<Isolated Module Objects_>`__, note that ``old_binascii.Error`` and "
"``binascii.Error`` are separate objects. In the following code, the "
"exception is *not* caught:"
msgstr ""
"Обратите внимание, что изолированные модули создают некоторые неожиданные "
"крайние случаи. В частности, каждый объект модуля обычно не разделяет свои "
"классы и исключения с другими аналогичными модулями. Продолжая приведенный "
"выше пример <Изолированные объекты модуля_>`__, обратите внимание, что "
"``old_binascii.Error`` и ``binascii.Error`` являются отдельными объектами. В "
"следующем коде исключение *не* перехватывается:"

#: ../../howto/isolating-extensions.rst:137
msgid ""
"This is expected. Notice that pure-Python modules behave the same way: it is "
"a part of how Python works."
msgstr ""
"Это ожидаемо. Обратите внимание, что модули на чистом Python ведут себя "
"одинаково: это часть того, как работает Python."

#: ../../howto/isolating-extensions.rst:140
msgid ""
"The goal is to make extension modules safe at the C level, not to make hacks "
"behave intuitively. Mutating ``sys.modules`` \"manually\" counts as a hack."
msgstr ""
"Цель состоит в том, чтобы сделать модули расширения безопасными на уровне C, "
"а не заставлять хаки вести себя интуитивно. Изменение ``sys.modules`` "
"«вручную» считается взломом."

#: ../../howto/isolating-extensions.rst:146
msgid "Making Modules Safe with Multiple Interpreters"
msgstr "Обеспечение безопасности модулей с помощью нескольких интерпретаторов"

#: ../../howto/isolating-extensions.rst:150
msgid "Managing Global State"
msgstr "Управление глобальным состоянием"

#: ../../howto/isolating-extensions.rst:152
msgid ""
"Sometimes, the state associated with a Python module is not specific to that "
"module, but to the entire process (or something else \"more global\" than a "
"module). For example:"
msgstr ""
"Иногда состояние, связанное с модулем Python, относится не к этому модулю, а "
"ко всему процессу (или к чему-то еще, «более глобальному», чем модуль). "
"Например:"

#: ../../howto/isolating-extensions.rst:156
msgid "The ``readline`` module manages *the* terminal."
msgstr "Модуль ``readline`` управляет *терминалом*."

#: ../../howto/isolating-extensions.rst:157
msgid ""
"A module running on a circuit board wants to control *the* on-board LED."
msgstr "Модуль, работающий на плате, хочет управлять встроенным светодиодом."

#: ../../howto/isolating-extensions.rst:160
msgid ""
"In these cases, the Python module should provide *access* to the global "
"state, rather than *own* it. If possible, write the module so that multiple "
"copies of it can access the state independently (along with other libraries, "
"whether for Python or other languages). If that is not possible, consider "
"explicit locking."
msgstr ""
"В этих случаях модуль Python должен предоставлять *доступ* к глобальному "
"состоянию, а не *владеть* им. Если возможно, напишите модуль так, чтобы "
"несколько его копий могли независимо обращаться к состоянию (вместе с "
"другими библиотеками, будь то для Python или других языков). Если это "
"невозможно, рассмотрите возможность явной блокировки."

#: ../../howto/isolating-extensions.rst:166
msgid ""
"If it is necessary to use process-global state, the simplest way to avoid "
"issues with multiple interpreters is to explicitly prevent a module from "
"being loaded more than once per process—see `Opt-Out: Limiting to One Module "
"Object per Process`_."
msgstr ""
"Если необходимо использовать глобальное состояние процесса, самый простой "
"способ избежать проблем с несколькими интерпретаторами — это явно запретить "
"загрузку модуля более одного раза для каждого процесса — см. «Отказ от "
"участия: ограничение одним объектом модуля на процесс». ."

#: ../../howto/isolating-extensions.rst:173
msgid "Managing Per-Module State"
msgstr "Управление состоянием каждого модуля"

#: ../../howto/isolating-extensions.rst:175
msgid ""
"To use per-module state, use :ref:`multi-phase extension module "
"initialization <multi-phase-initialization>`. This signals that your module "
"supports multiple interpreters correctly."
msgstr ""
"Чтобы использовать состояние каждого модуля, используйте :ref:`многофазную "
"инициализацию модуля расширения <multi-phase-initialization>`. Это "
"сигнализирует о том, что ваш модуль правильно поддерживает несколько "
"интерпретаторов."

#: ../../howto/isolating-extensions.rst:179
msgid ""
"Set ``PyModuleDef.m_size`` to a positive number to request that many bytes "
"of storage local to the module. Usually, this will be set to the size of "
"some module-specific ``struct``, which can store all of the module's C-level "
"state. In particular, it is where you should put pointers to classes "
"(including exceptions, but excluding static types) and settings (e.g. "
"``csv``'s :py:data:`~csv.field_size_limit`) which the C code needs to "
"function."
msgstr ""
"Установите для ``PyModuleDef.m_size`` положительное число, чтобы запросить "
"такое количество байтов локального хранилища для модуля. Обычно для этого "
"параметра устанавливается размер некоторой специфичной для модуля "
"``структуры``, которая может хранить все состояние модуля C-уровня. В "
"частности, именно здесь вы должны поместить указатели на классы (включая "
"исключения, но исключая статические типы) и настройки (например, :py:data:"
"`~csv.field_size_limit````csv``), которые необходимы коду C. функция."

#: ../../howto/isolating-extensions.rst:188
msgid ""
"Another option is to store state in the module's ``__dict__``, but you must "
"avoid crashing when users modify ``__dict__`` from Python code. This usually "
"means error- and type-checking at the C level, which is easy to get wrong "
"and hard to test sufficiently."
msgstr ""
"Другой вариант — сохранить состояние в ``__dict__`` модуля, но вы должны "
"избегать сбоев, когда пользователи изменяют ``__dict__`` из кода Python. "
"Обычно это означает проверку ошибок и типов на уровне C, где легко ошибиться "
"и сложно достаточно протестировать."

#: ../../howto/isolating-extensions.rst:193
msgid ""
"However, if module state is not needed in C code, storing it in ``__dict__`` "
"only is a good idea."
msgstr ""
"Однако, если состояние модуля не требуется в коде C, хорошей идеей будет "
"хранить его только в ``__dict__``."

#: ../../howto/isolating-extensions.rst:196
msgid ""
"If the module state includes ``PyObject`` pointers, the module object must "
"hold references to those objects and implement the module-level hooks "
"``m_traverse``, ``m_clear`` and ``m_free``. These work like ``tp_traverse``, "
"``tp_clear`` and ``tp_free`` of a class. Adding them will require some work "
"and make the code longer; this is the price for modules which can be "
"unloaded cleanly."
msgstr ""
"Если состояние модуля включает указатели PyObject, объект модуля должен "
"содержать ссылки на эти объекты и реализовывать перехватчики уровня модуля "
"m_traverse, m_clear и m_free. Они работают как ``tp_traverse``, ``tp_clear`` "
"и ``tp_free`` класса. Их добавление потребует некоторой работы и сделает код "
"длиннее; это цена модулей, которые можно аккуратно выгрузить."

#: ../../howto/isolating-extensions.rst:203
msgid ""
"An example of a module with per-module state is currently available as "
"`xxlimited <https://github.com/python/cpython/blob/master/Modules/xxlimited."
"c>`__; example module initialization shown at the bottom of the file."
msgstr ""
"Пример модуля с состоянием для каждого модуля в настоящее время доступен как "
"`xxlimited <https://github.com/python/cpython/blob/master/Modules/xxlimited."
"c>`__; пример инициализации модуля показан внизу файла."

#: ../../howto/isolating-extensions.rst:209
msgid "Opt-Out: Limiting to One Module Object per Process"
msgstr "Отказ: ограничение одним объектом модуля на процесс"

#: ../../howto/isolating-extensions.rst:211
msgid ""
"A non-negative ``PyModuleDef.m_size`` signals that a module supports "
"multiple interpreters correctly. If this is not yet the case for your "
"module, you can explicitly make your module loadable only once per process. "
"For example::"
msgstr ""
"Неотрицательное значение PyModuleDef.m_size сигнализирует о том, что модуль "
"правильно поддерживает несколько интерпретаторов. Если для вашего модуля это "
"еще не так, вы можете явно сделать модуль загружаемым только один раз для "
"каждого процесса. Например::"

#: ../../howto/isolating-extensions.rst:232
msgid "Module State Access from Functions"
msgstr "Доступ к состоянию модуля из функций"

#: ../../howto/isolating-extensions.rst:234
msgid ""
"Accessing the state from module-level functions is straightforward. "
"Functions get the module object as their first argument; for extracting the "
"state, you can use ``PyModule_GetState``::"
msgstr ""
"Доступ к состоянию из функций уровня модуля прост. Функции получают объект "
"модуля в качестве первого аргумента; для извлечения состояния вы можете "
"использовать PyModule_GetState::"

#: ../../howto/isolating-extensions.rst:249
msgid ""
"``PyModule_GetState`` may return ``NULL`` without setting an exception if "
"there is no module state, i.e. ``PyModuleDef.m_size`` was zero. In your own "
"module, you're in control of ``m_size``, so this is easy to prevent."
msgstr ""
"``PyModule_GetState`` может возвращать ``NULL`` без установки исключения, "
"если состояние модуля отсутствует, т.е. ``PyModuleDef.m_size`` было нулевым. "
"В вашем собственном модуле вы управляете m_size, поэтому это легко "
"предотвратить."

#: ../../howto/isolating-extensions.rst:256
msgid "Heap Types"
msgstr "Типы кучи"

#: ../../howto/isolating-extensions.rst:258
msgid ""
"Traditionally, types defined in C code are *static*; that is, ``static "
"PyTypeObject`` structures defined directly in code and initialized using "
"``PyType_Ready()``."
msgstr ""
"Традиционно типы, определенные в коде C, являются *статическими*; то есть "
"статические структуры PyTypeObject, определенные непосредственно в коде и "
"инициализируемые с помощью PyType_Ready()."

#: ../../howto/isolating-extensions.rst:262
msgid ""
"Such types are necessarily shared across the process. Sharing them between "
"module objects requires paying attention to any state they own or access. To "
"limit the possible issues, static types are immutable at the Python level: "
"for example, you can't set ``str.myattribute = 123``."
msgstr ""
"Такие типы обязательно используются во всем процессе. Совместное "
"использование их между объектами модуля требует внимания к любому состоянию, "
"которым они владеют или к которому они имеют доступ. Чтобы ограничить "
"возможные проблемы, статические типы являются неизменяемыми на уровне "
"Python: например, вы не можете установить ``str.myattribute = 123``."

#: ../../howto/isolating-extensions.rst:268
msgid ""
"Sharing truly immutable objects between interpreters is fine, as long as "
"they don't provide access to mutable objects. However, in CPython, every "
"Python object has a mutable implementation detail: the reference count. "
"Changes to the refcount are guarded by the GIL. Thus, code that shares any "
"Python objects across interpreters implicitly depends on CPython's current, "
"process-wide GIL."
msgstr ""
"Совместное использование действительно неизменяемых объектов между "
"интерпретаторами — это нормально, если они не предоставляют доступ к "
"изменяемым объектам. Однако в CPython каждый объект Python имеет изменяемую "
"деталь реализации: счетчик ссылок. Изменения в счетчике ссылок защищены GIL. "
"Таким образом, код, который совместно использует любые объекты Python в "
"разных интерпретаторах, неявно зависит от текущего общепроцессного GIL "
"CPython."

#: ../../howto/isolating-extensions.rst:275
msgid ""
"Because they are immutable and process-global, static types cannot access "
"\"their\" module state. If any method of such a type requires access to "
"module state, the type must be converted to a *heap-allocated type*, or "
"*heap type* for short. These correspond more closely to classes created by "
"Python's ``class`` statement."
msgstr ""
"Поскольку статические типы являются неизменяемыми и глобальными для "
"процесса, они не могут получить доступ к «своему» состоянию модуля. Если "
"какой-либо метод такого типа требует доступа к состоянию модуля, этот тип "
"должен быть преобразован в *тип, выделяемый в куче*, или для краткости *тип "
"в куче*. Они более близко соответствуют классам, созданным оператором Python "
"``class``."

#: ../../howto/isolating-extensions.rst:282
msgid "For new modules, using heap types by default is a good rule of thumb."
msgstr ""
"Для новых модулей хорошим практическим правилом является использование типов "
"кучи по умолчанию."

#: ../../howto/isolating-extensions.rst:286
msgid "Changing Static Types to Heap Types"
msgstr "Изменение статических типов на типы кучи"

#: ../../howto/isolating-extensions.rst:288
msgid ""
"Static types can be converted to heap types, but note that the heap type API "
"was not designed for \"lossless\" conversion from static types—that is, "
"creating a type that works exactly like a given static type. So, when "
"rewriting the class definition in a new API, you are likely to "
"unintentionally change a few details (e.g. pickleability or inherited "
"slots). Always test the details that are important to you."
msgstr ""
"Статические типы можно преобразовать в типы кучи, но учтите, что API типов "
"кучи не был разработан для преобразования статических типов «без потерь», то "
"есть создания типа, который работает точно так же, как заданный статический "
"тип. Таким образом, при переписывании определения класса в новом API вы, "
"скорее всего, непреднамеренно измените некоторые детали (например, "
"возможность выбора или унаследованные слоты). Всегда проверяйте детали, "
"которые важны для вас."

#: ../../howto/isolating-extensions.rst:297
msgid ""
"Watch out for the following two points in particular (but note that this is "
"not a comprehensive list):"
msgstr ""
"Обратите особое внимание на следующие два пункта (но обратите внимание, что "
"это не полный список):"

#: ../../howto/isolating-extensions.rst:300
msgid ""
"Unlike static types, heap type objects are mutable by default. Use the :c:"
"macro:`Py_TPFLAGS_IMMUTABLETYPE` flag to prevent mutability."
msgstr ""
"В отличие от статических типов, объекты типа кучи по умолчанию изменяемы. "
"Используйте флаг :c:macro:`Py_TPFLAGS_IMMUTABLETYPE`, чтобы предотвратить "
"изменчивость."

#: ../../howto/isolating-extensions.rst:302
msgid ""
"Heap types inherit :c:member:`~PyTypeObject.tp_new` by default, so it may "
"become possible to instantiate them from Python code. You can prevent this "
"with the :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION` flag."
msgstr ""
"Типы кучи по умолчанию наследуют :c:member:`~PyTypeObject.tp_new`, поэтому "
"может стать возможным создать их экземпляры из кода Python. Вы можете "
"предотвратить это с помощью флага :c:macro:"
"`Py_TPFLAGS_DISALLOW_INSTANTIATION`."

#: ../../howto/isolating-extensions.rst:308
msgid "Defining Heap Types"
msgstr "Определение типов кучи"

#: ../../howto/isolating-extensions.rst:310
msgid ""
"Heap types can be created by filling a :c:struct:`PyType_Spec` structure, a "
"description or \"blueprint\" of a class, and calling :c:func:"
"`PyType_FromModuleAndSpec` to construct a new class object."
msgstr ""
"Типы кучи могут быть созданы путем заполнения структуры :c:struct:"
"`PyType_Spec`, описания или «чертежа» класса и вызова :c:func:"
"`PyType_FromModuleAndSpec` для создания нового объекта класса."

#: ../../howto/isolating-extensions.rst:315
msgid ""
"Other functions, like :c:func:`PyType_FromSpec`, can also create heap types, "
"but :c:func:`PyType_FromModuleAndSpec` associates the module with the class, "
"allowing access to the module state from methods."
msgstr ""
"Другие функции, такие как :c:func:`PyType_FromSpec`, также могут создавать "
"типы кучи, но :c:func:`PyType_FromModuleAndSpec` связывает модуль с классом, "
"позволяя получить доступ к состоянию модуля из методов."

#: ../../howto/isolating-extensions.rst:319
msgid ""
"The class should generally be stored in *both* the module state (for safe "
"access from C) and the module's ``__dict__`` (for access from Python code)."
msgstr ""
"Класс обычно должен храниться как в *состоянии* модуля (для безопасного "
"доступа из C), так и в ``__dict__`` модуля (для доступа из кода Python)."

#: ../../howto/isolating-extensions.rst:325
msgid "Garbage-Collection Protocol"
msgstr "Протокол сбора мусора"

#: ../../howto/isolating-extensions.rst:327
msgid ""
"Instances of heap types hold a reference to their type. This ensures that "
"the type isn't destroyed before all its instances are, but may result in "
"reference cycles that need to be broken by the garbage collector."
msgstr ""
"Экземпляры типов кучи содержат ссылку на свой тип. Это гарантирует, что тип "
"не будет уничтожен до того, как будут уничтожены все его экземпляры, но "
"может привести к ссылочным циклам, которые придется прерывать сборщику "
"мусора."

#: ../../howto/isolating-extensions.rst:332
msgid ""
"To avoid memory leaks, instances of heap types must implement the garbage "
"collection protocol. That is, heap types should:"
msgstr ""
"Чтобы избежать утечек памяти, экземпляры типов кучи должны реализовывать "
"протокол сборки мусора. То есть типы кучи должны:"

#: ../../howto/isolating-extensions.rst:336
msgid "Have the :c:macro:`Py_TPFLAGS_HAVE_GC` flag."
msgstr "Имейте флаг :c:macro:`Py_TPFLAGS_HAVE_GC`."

#: ../../howto/isolating-extensions.rst:337
msgid ""
"Define a traverse function using ``Py_tp_traverse``, which visits the type "
"(e.g. using ``Py_VISIT(Py_TYPE(self))``)."
msgstr ""
"Определите функцию обхода, используя Py_tp_traverse, которая посещает тип "
"(например, используя Py_VISIT(Py_TYPE(self)))."

#: ../../howto/isolating-extensions.rst:340
msgid ""
"Please refer to the the documentation of :c:macro:`Py_TPFLAGS_HAVE_GC` and :"
"c:member:`~PyTypeObject.tp_traverse` for additional considerations."
msgstr ""

#: ../../howto/isolating-extensions.rst:344
msgid ""
"The API for defining heap types grew organically, leaving it somewhat "
"awkward to use in its current state. The following sections will guide you "
"through common issues."
msgstr ""
"API для определения типов кучи развился органично, поэтому в его текущем "
"состоянии его использовать несколько неудобно. Следующие разделы помогут вам "
"разобраться с распространенными проблемами."

#: ../../howto/isolating-extensions.rst:350
msgid "``tp_traverse`` in Python 3.8 and lower"
msgstr "``tp_traverse`` в Python 3.8 и ниже"

#: ../../howto/isolating-extensions.rst:352
msgid ""
"The requirement to visit the type from ``tp_traverse`` was added in Python "
"3.9. If you support Python 3.8 and lower, the traverse function must *not* "
"visit the type, so it must be more complicated::"
msgstr ""
"Требование посещения типа из tp_traverse было добавлено в Python 3.9. Если "
"вы поддерживаете Python 3.8 и ниже, функция перемещения *не* должна "
"обращаться к типу, поэтому она должна быть более сложной:"

#: ../../howto/isolating-extensions.rst:364
msgid ""
"Unfortunately, :c:data:`Py_Version` was only added in Python 3.11. As a "
"replacement, use:"
msgstr ""
"К сожалению, :c:data:`Py_Version` был добавлен только в Python 3.11. В "
"качестве замены используйте:"

#: ../../howto/isolating-extensions.rst:367
msgid ":c:macro:`PY_VERSION_HEX`, if not using the stable ABI, or"
msgstr ":c:macro:`PY_VERSION_HEX`, если не используется стабильный ABI, или"

#: ../../howto/isolating-extensions.rst:368
msgid ""
":py:data:`sys.version_info` (via :c:func:`PySys_GetObject` and :c:func:"
"`PyArg_ParseTuple`)."
msgstr ""
":py:data:`sys.version_info` (via :c:func:`PySys_GetObject` and :c:func:"
"`PyArg_ParseTuple`)."

#: ../../howto/isolating-extensions.rst:373
msgid "Delegating ``tp_traverse``"
msgstr "Делегирование ``tp_traverse``"

#: ../../howto/isolating-extensions.rst:375
msgid ""
"If your traverse function delegates to the :c:member:`~PyTypeObject."
"tp_traverse` of its base class (or another type), ensure that "
"``Py_TYPE(self)`` is visited only once. Note that only heap type are "
"expected to visit the type in ``tp_traverse``."
msgstr ""
"Если ваша функция перемещения делегирует :c:member:`~PyTypeObject."
"tp_traverse` своего базового класса (или другого типа), убедитесь, что "
"``Py_TYPE(self)`` посещается только один раз. Обратите внимание, что только "
"тип кучи должен посещать тип в tp_traverse."

#: ../../howto/isolating-extensions.rst:380
msgid "For example, if your traverse function includes::"
msgstr "Например, если ваша функция перемещения включает в себя::"

#: ../../howto/isolating-extensions.rst:384
msgid "...and ``base`` may be a static type, then it should also include::"
msgstr ""
"...и ``base`` может быть статическим типом, тогда он также должен включать::"

#: ../../howto/isolating-extensions.rst:394
msgid ""
"It is not necessary to handle the type's reference count in :c:member:"
"`~PyTypeObject.tp_new` and :c:member:`~PyTypeObject.tp_clear`."
msgstr ""
"Нет необходимости обрабатывать счетчик ссылок типа в :c:member:"
"`~PyTypeObject.tp_new` и :c:member:`~PyTypeObject.tp_clear`."

#: ../../howto/isolating-extensions.rst:399
msgid "Defining ``tp_dealloc``"
msgstr "Определение ``tp_dealloc``"

#: ../../howto/isolating-extensions.rst:401
msgid ""
"If your type has a custom :c:member:`~PyTypeObject.tp_dealloc` function, it "
"needs to:"
msgstr ""
"Если у вашего типа есть пользовательская функция :c:member:`~PyTypeObject."
"tp_dealloc`, ему необходимо:"

#: ../../howto/isolating-extensions.rst:404
msgid ""
"call :c:func:`PyObject_GC_UnTrack` before any fields are invalidated, and"
msgstr ""
"вызовите :c:func:`PyObject_GC_UnTrack` перед тем, как какие-либо поля станут "
"недействительными, и"

#: ../../howto/isolating-extensions.rst:405
msgid "decrement the reference count of the type."
msgstr "уменьшить счетчик ссылок типа."

#: ../../howto/isolating-extensions.rst:407
msgid ""
"To keep the type valid while ``tp_free`` is called, the type's refcount "
"needs to be decremented *after* the instance is deallocated. For example::"
msgstr ""
"Чтобы тип оставался действительным во время вызова ``tp_free``, счетчик "
"ссылок типа должен быть уменьшен *после* освобождения экземпляра. Например::"

#: ../../howto/isolating-extensions.rst:419
msgid ""
"The default ``tp_dealloc`` function does this, so if your type does *not* "
"override ``tp_dealloc`` you don't need to add it."
msgstr ""
"Это делает функция по умолчанию ``tp_dealloc``, поэтому, если ваш тип *не* "
"переопределяет ``tp_dealloc``, вам не нужно ее добавлять."

#: ../../howto/isolating-extensions.rst:425
msgid "Not overriding ``tp_free``"
msgstr "Не переопределять ``tp_free``"

#: ../../howto/isolating-extensions.rst:427
msgid ""
"The :c:member:`~PyTypeObject.tp_free` slot of a heap type must be set to :c:"
"func:`PyObject_GC_Del`. This is the default; do not override it."
msgstr ""
"Слот :c:member:`~PyTypeObject.tp_free` типа кучи должен быть установлен в :c:"
"func:`PyObject_GC_Del`. Это значение по умолчанию; не переопределяйте его."

#: ../../howto/isolating-extensions.rst:433
msgid "Avoiding ``PyObject_New``"
msgstr "Избегание ``PyObject_New``"

#: ../../howto/isolating-extensions.rst:435
msgid "GC-tracked objects need to be allocated using GC-aware functions."
msgstr ""
"Объекты, отслеживаемые GC, необходимо выделять с помощью функций, "
"поддерживающих GC."

#: ../../howto/isolating-extensions.rst:437
msgid "If you use use :c:func:`PyObject_New` or :c:func:`PyObject_NewVar`:"
msgstr ""
"Если вы используете, используйте :c:func:`PyObject_New` или :c:func:"
"`PyObject_NewVar`:"

#: ../../howto/isolating-extensions.rst:439
msgid ""
"Get and call type's :c:member:`~PyTypeObject.tp_alloc` slot, if possible. "
"That is, replace ``TYPE *o = PyObject_New(TYPE, typeobj)`` with::"
msgstr ""
"Получите и вызовите слот типа :c:member:`~PyTypeObject.tp_alloc`, если это "
"возможно. То есть замените ``TYPE *o = PyObject_New(TYPE, typeobj)`` на::"

#: ../../howto/isolating-extensions.rst:444
msgid ""
"Replace ``o = PyObject_NewVar(TYPE, typeobj, size)`` with the same, but use "
"size instead of the 0."
msgstr ""
"Замените ``o = PyObject_NewVar(TYPE, typeobj, size)`` на то же самое, но "
"используйте размер вместо 0."

#: ../../howto/isolating-extensions.rst:447
msgid ""
"If the above is not possible (e.g. inside a custom ``tp_alloc``), call :c:"
"func:`PyObject_GC_New` or :c:func:`PyObject_GC_NewVar`::"
msgstr ""
"Если вышеуказанное невозможно (например, внутри пользовательского "
"``tp_alloc``), вызовите :c:func:`PyObject_GC_New` или :c:func:"
"`PyObject_GC_NewVar`::"

#: ../../howto/isolating-extensions.rst:456
msgid "Module State Access from Classes"
msgstr "Доступ к состоянию модуля из классов"

#: ../../howto/isolating-extensions.rst:458
msgid ""
"If you have a type object defined with :c:func:`PyType_FromModuleAndSpec`, "
"you can call :c:func:`PyType_GetModule` to get the associated module, and "
"then :c:func:`PyModule_GetState` to get the module's state."
msgstr ""
"Если у вас есть объект типа, определенный с помощью :c:func:"
"`PyType_FromModuleAndSpec`, вы можете вызвать :c:func:`PyType_GetModule`, "
"чтобы получить связанный модуль, а затем :c:func:`PyModule_GetState`, чтобы "
"получить состояние модуля."

#: ../../howto/isolating-extensions.rst:462
msgid ""
"To save a some tedious error-handling boilerplate code, you can combine "
"these two steps with :c:func:`PyType_GetModuleState`, resulting in::"
msgstr ""
"Чтобы сэкономить утомительный шаблонный код обработки ошибок, вы можете "
"объединить эти два шага с :c:func:`PyType_GetModuleState`, в результате чего:"

#: ../../howto/isolating-extensions.rst:472
msgid "Module State Access from Regular Methods"
msgstr "Доступ к состоянию модуля из обычных методов"

#: ../../howto/isolating-extensions.rst:474
msgid ""
"Accessing the module-level state from methods of a class is somewhat more "
"complicated, but is possible thanks to API introduced in Python 3.9. To get "
"the state, you need to first get the *defining class*, and then get the "
"module state from it."
msgstr ""
"Доступ к состоянию уровня модуля из методов класса несколько сложнее, но "
"возможен благодаря API, представленному в Python 3.9. Чтобы получить "
"состояние, вам нужно сначала получить *определяющий класс*, а затем получить "
"из него состояние модуля."

#: ../../howto/isolating-extensions.rst:479
msgid ""
"The largest roadblock is getting *the class a method was defined in*, or "
"that method's \"defining class\" for short. The defining class can have a "
"reference to the module it is part of."
msgstr ""
"Самым большим препятствием является получение *класса, в котором был "
"определен метод*, или, для краткости, «определяющего класса» этого метода. "
"Определяющий класс может иметь ссылку на модуль, частью которого он является."

#: ../../howto/isolating-extensions.rst:483
msgid ""
"Do not confuse the defining class with ``Py_TYPE(self)``. If the method is "
"called on a *subclass* of your type, ``Py_TYPE(self)`` will refer to that "
"subclass, which may be defined in different module than yours."
msgstr ""
"Не путайте определяющий класс с Py_TYPE(self)``. Если метод вызывается для "
"*подкласса* вашего типа, ``Py_TYPE(self)`` будет ссылаться на этот подкласс, "
"который может быть определен в другом модуле, отличном от вашего."

#: ../../howto/isolating-extensions.rst:488
msgid ""
"The following Python code can illustrate the concept. ``Base."
"get_defining_class`` returns ``Base`` even if ``type(self) == Sub``:"
msgstr ""
"Следующий код Python может проиллюстрировать эту концепцию. ``Base."
"get_defining_class`` возвращает ``Base``, даже если ``type(self) == Sub``:"

#: ../../howto/isolating-extensions.rst:504
msgid ""
"For a method to get its \"defining class\", it must use the :ref:"
"`METH_METHOD | METH_FASTCALL | METH_KEYWORDS <METH_METHOD-METH_FASTCALL-"
"METH_KEYWORDS>` :c:type:`calling convention <PyMethodDef>` and the "
"corresponding :c:type:`PyCMethod` signature::"
msgstr ""
"Чтобы метод получил свой «определяющий класс», он должен использовать :ref:"
"`METH_METHOD | METH_FASTCALL | METH_KEYWORDS <METH_METHOD-METH_FASTCALL-"
"METH_KEYWORDS>` :c:type:`соглашение о вызовах <PyMethodDef>` и "
"соответствующая сигнатура :c:type:`PyCMethod`::"

#: ../../howto/isolating-extensions.rst:516
msgid ""
"Once you have the defining class, call :c:func:`PyType_GetModuleState` to "
"get the state of its associated module."
msgstr ""
"Получив определяющий класс, вызовите :c:func:`PyType_GetModuleState`, чтобы "
"получить состояние связанного с ним модуля."

#: ../../howto/isolating-extensions.rst:519
msgid "For example::"
msgstr "Например::"

#: ../../howto/isolating-extensions.rst:547
msgid "Module State Access from Slot Methods, Getters and Setters"
msgstr "Доступ к состоянию модуля из методов слота, геттеров и сеттеров"

#: ../../howto/isolating-extensions.rst:551
msgid "This is new in Python 3.11."
msgstr "Это новое в Python 3.11."

#: ../../howto/isolating-extensions.rst:559
msgid ""
"Slot methods—the fast C equivalents for special methods, such as :c:member:"
"`~PyNumberMethods.nb_add` for :py:attr:`~object.__add__` or :c:member:"
"`~PyTypeObject.tp_new` for initialization—have a very simple API that "
"doesn't allow passing in the defining class, unlike with :c:type:"
"`PyCMethod`. The same goes for getters and setters defined with :c:type:"
"`PyGetSetDef`."
msgstr ""
"Методы слота — быстрые эквиваленты C для специальных методов, таких как :c:"
"member:`~PyNumberMethods.nb_add` для :py:attr:`~object.__add__` или :c:"
"member:`~PyTypeObject.tp_new` для инициализации. — иметь очень простой API, "
"который не позволяет передавать определяющий класс, в отличие от :c:type:"
"`PyCMethod`. То же самое касается геттеров и сеттеров, определенных с "
"помощью :c:type:`PyGetSetDef`."

#: ../../howto/isolating-extensions.rst:566
msgid ""
"To access the module state in these cases, use the :c:func:"
"`PyType_GetModuleByDef` function, and pass in the module definition. Once "
"you have the module, call :c:func:`PyModule_GetState` to get the state::"
msgstr ""
"Чтобы получить доступ к состоянию модуля в этих случаях, используйте "
"функцию :c:func:`PyType_GetModuleByDef` и передайте определение модуля. "
"Получив модуль, вызовите :c:func:`PyModule_GetState`, чтобы получить "
"состояние::"

#: ../../howto/isolating-extensions.rst:577
msgid ""
":c:func:`!PyType_GetModuleByDef` works by searching the :term:`method "
"resolution order` (i.e. all superclasses) for the first superclass that has "
"a corresponding module."
msgstr ""
":c:func:`!PyType_GetModuleByDef` работает путем поиска в :term:`порядке "
"разрешения методов` (т.е. во всех суперклассах) первого суперкласса, "
"имеющего соответствующий модуль."

#: ../../howto/isolating-extensions.rst:583
msgid ""
"In very exotic cases (inheritance chains spanning multiple modules created "
"from the same definition), :c:func:`!PyType_GetModuleByDef` might not return "
"the module of the true defining class. However, it will always return a "
"module with the same definition, ensuring a compatible C memory layout."
msgstr ""
"В очень экзотических случаях (цепочки наследования, охватывающие несколько "
"модулей, созданных на основе одного и того же определения), :c:func:`!"
"PyType_GetModuleByDef` может не вернуть модуль истинного определяющего "
"класса. Однако он всегда будет возвращать модуль с тем же определением, "
"обеспечивая совместимую структуру памяти C."

#: ../../howto/isolating-extensions.rst:591
msgid "Lifetime of the Module State"
msgstr "Время жизни состояния модуля"

#: ../../howto/isolating-extensions.rst:593
msgid ""
"When a module object is garbage-collected, its module state is freed. For "
"each pointer to (a part of) the module state, you must hold a reference to "
"the module object."
msgstr ""
"Когда объект модуля подвергается сборке мусора, его состояние модуля "
"освобождается. Для каждого указателя на состояние модуля (части) вы должны "
"содержать ссылку на объект модуля."

#: ../../howto/isolating-extensions.rst:597
msgid ""
"Usually this is not an issue, because types created with :c:func:"
"`PyType_FromModuleAndSpec`, and their instances, hold a reference to the "
"module. However, you must be careful in reference counting when you "
"reference module state from other places, such as callbacks for external "
"libraries."
msgstr ""
"Обычно это не проблема, поскольку типы, созданные с помощью :c:func:"
"`PyType_FromModuleAndSpec`, и их экземпляры содержат ссылку на модуль. "
"Однако вы должны быть осторожны при подсчете ссылок, когда вы ссылаетесь на "
"состояние модуля из других мест, например, из обратных вызовов для внешних "
"библиотек."

#: ../../howto/isolating-extensions.rst:606
msgid "Open Issues"
msgstr "Открытые вопросы"

#: ../../howto/isolating-extensions.rst:608
msgid "Several issues around per-module state and heap types are still open."
msgstr ""
"Несколько вопросов, касающихся состояния каждого модуля и типов кучи, все "
"еще остаются открытыми."

#: ../../howto/isolating-extensions.rst:610
msgid ""
"Discussions about improving the situation are best held on the `capi-sig "
"mailing list <https://mail.python.org/mailman3/lists/capi-sig.python.org/"
">`__."
msgstr ""
"Обсуждения улучшения ситуации лучше всего вести в списке рассылки capi-sig "
"<https://mail.python.org/mailman3/lists/capi-sig.python.org/>`__."

#: ../../howto/isolating-extensions.rst:615
msgid "Per-Class Scope"
msgstr "Область действия для каждого класса"

#: ../../howto/isolating-extensions.rst:617
msgid ""
"It is currently (as of Python 3.11) not possible to attach state to "
"individual *types* without relying on CPython implementation details (which "
"may change in the future—perhaps, ironically, to allow a proper solution for "
"per-class scope)."
msgstr ""
"В настоящее время (начиная с Python 3.11) невозможно прикрепить состояние к "
"отдельным *типам*, не полагаясь на детали реализации CPython (которые могут "
"измениться в будущем — возможно, по иронии судьбы, чтобы обеспечить "
"правильное решение для области видимости каждого класса)."

#: ../../howto/isolating-extensions.rst:624
msgid "Lossless Conversion to Heap Types"
msgstr "Преобразование без потерь в типы кучи"

#: ../../howto/isolating-extensions.rst:626
msgid ""
"The heap type API was not designed for \"lossless\" conversion from static "
"types; that is, creating a type that works exactly like a given static type."
msgstr ""
"API типов кучи не был разработан для преобразования статических типов «без "
"потерь»; то есть создание типа, который работает точно так же, как заданный "
"статический тип."
