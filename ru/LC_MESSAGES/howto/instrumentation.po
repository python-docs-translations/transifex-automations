# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-10 16:06+0000\n"
"PO-Revision-Date: 2022-11-05 17:21+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../howto/instrumentation.rst:7
msgid "Instrumenting CPython with DTrace and SystemTap"
msgstr "Инструментирование CPython с помощью DTrace и SystemTap"

#: ../../howto/instrumentation.rst:0
msgid "author"
msgstr "автор"

#: ../../howto/instrumentation.rst:9
msgid "David Malcolm"
msgstr "David Malcolm"

#: ../../howto/instrumentation.rst:10
msgid "Łukasz Langa"
msgstr "Łukasz Langa"

#: ../../howto/instrumentation.rst:12
msgid ""
"DTrace and SystemTap are monitoring tools, each providing a way to inspect "
"what the processes on a computer system are doing.  They both use domain-"
"specific languages allowing a user to write scripts which:"
msgstr ""
"DTrace и SystemTap — это инструменты мониторинга, каждый из которых "
"позволяет проверить, что делают процессы в компьютерной системе. Оба они "
"используют языки, специфичные для предметной области, что позволяет "
"пользователю писать сценарии, которые:"

#: ../../howto/instrumentation.rst:16
msgid "filter which processes are to be observed"
msgstr "фильтровать, какие процессы следует наблюдать"

#: ../../howto/instrumentation.rst:17
msgid "gather data from the processes of interest"
msgstr "собирать данные о интересующих процессах"

#: ../../howto/instrumentation.rst:18
msgid "generate reports on the data"
msgstr "генерировать отчеты по данным"

#: ../../howto/instrumentation.rst:20
msgid ""
"As of Python 3.6, CPython can be built with embedded \"markers\", also known "
"as \"probes\", that can be observed by a DTrace or SystemTap script, making "
"it easier to monitor what the CPython processes on a system are doing."
msgstr ""
"Начиная с Python 3.6, CPython может быть построен со встроенными "
"«маркерами», также известными как «зонды», которые можно наблюдать с помощью "
"сценария DTrace или SystemTap, что упрощает мониторинг того, что делают "
"процессы CPython в системе."

#: ../../howto/instrumentation.rst:27
msgid ""
"DTrace markers are implementation details of the CPython interpreter. No "
"guarantees are made about probe compatibility between versions of CPython. "
"DTrace scripts can stop working or work incorrectly without warning when "
"changing CPython versions."
msgstr ""
"Маркеры DTrace — это детали реализации интерпретатора CPython. Никаких "
"гарантий совместимости зондов между версиями CPython не предоставляется. "
"Скрипты DTrace могут перестать работать или работать некорректно без "
"предупреждения при смене версии CPython."

#: ../../howto/instrumentation.rst:34
msgid "Enabling the static markers"
msgstr "Включение статических маркеров"

#: ../../howto/instrumentation.rst:36
msgid ""
"macOS comes with built-in support for DTrace.  On Linux, in order to build "
"CPython with the embedded markers for SystemTap, the SystemTap development "
"tools must be installed."
msgstr ""
"macOS поставляется со встроенной поддержкой DTrace. В Linux для сборки "
"CPython со встроенными маркерами для SystemTap необходимо установить "
"инструменты разработки SystemTap."

#: ../../howto/instrumentation.rst:40
msgid "On a Linux machine, this can be done via::"
msgstr "На машине Linux это можно сделать через:"

#: ../../howto/instrumentation.rst:44
msgid "or::"
msgstr "или::"

#: ../../howto/instrumentation.rst:49
msgid ""
"CPython must then be :option:`configured with the --with-dtrace option <--"
"with-dtrace>`:"
msgstr ""
"Затем CPython должен быть :option:`настроен с помощью опции --with-dtrace <--"
"with-dtrace>`:"

#: ../../howto/instrumentation.rst:56
msgid ""
"On macOS, you can list available DTrace probes by running a Python process "
"in the background and listing all probes made available by the Python "
"provider::"
msgstr ""
"В macOS вы можете просмотреть список доступных зондов DTrace, запустив "
"процесс Python в фоновом режиме и выведя список всех зондов, доступных "
"провайдером Python:"

#: ../../howto/instrumentation.rst:73
msgid ""
"On Linux, you can verify if the SystemTap static markers are present in the "
"built binary by seeing if it contains a \".note.stapsdt\" section."
msgstr ""
"В Linux вы можете проверить, присутствуют ли статические маркеры SystemTap "
"во встроенном двоичном файле, проверив, содержит ли он раздел «.note."
"stapsdt»."

#: ../../howto/instrumentation.rst:81
msgid ""
"If you've built Python as a shared library (with the :option:`--enable-"
"shared` configure option), you need to look instead within the shared "
"library.  For example::"
msgstr ""
"Если вы создали Python как общую библиотеку (с опцией настройки :option:`--"
"enable-shared`), вам нужно вместо этого просмотреть общую библиотеку. "
"Например::"

#: ../../howto/instrumentation.rst:88
msgid "Sufficiently modern readelf can print the metadata::"
msgstr "Достаточно современный readelf может распечатать метаданные::"

#: ../../howto/instrumentation.rst:125
msgid ""
"The above metadata contains information for SystemTap describing how it can "
"patch strategically placed machine code instructions to enable the tracing "
"hooks used by a SystemTap script."
msgstr ""
"Приведенные выше метаданные содержат информацию для SystemTap, описывающую, "
"как он может исправить стратегически расположенные инструкции машинного "
"кода, чтобы включить перехватчики трассировки, используемые сценарием "
"SystemTap."

#: ../../howto/instrumentation.rst:131
msgid "Static DTrace probes"
msgstr "Статические зонды DTrace"

#: ../../howto/instrumentation.rst:133
msgid ""
"The following example DTrace script can be used to show the call/return "
"hierarchy of a Python script, only tracing within the invocation of a "
"function called \"start\". In other words, import-time function invocations "
"are not going to be listed:"
msgstr ""
"Следующий пример сценария DTrace можно использовать для отображения иерархии "
"вызовов/возвратов сценария Python, отслеживая только вызов функции с именем "
"«start». Другими словами, вызовы функций во время импорта не будут "
"перечислены:"

#: ../../howto/instrumentation.rst:172 ../../howto/instrumentation.rst:230
msgid "It can be invoked like this::"
msgstr "Его можно вызвать следующим образом::"

#: ../../howto/instrumentation.rst:176 ../../howto/instrumentation.rst:236
msgid "The output looks like this:"
msgstr "Вывод выглядит следующим образом:"

#: ../../howto/instrumentation.rst:201
msgid "Static SystemTap markers"
msgstr "Статические маркеры SystemTap"

#: ../../howto/instrumentation.rst:203
msgid ""
"The low-level way to use the SystemTap integration is to use the static "
"markers directly.  This requires you to explicitly state the binary file "
"containing them."
msgstr ""
"Низкоуровневый способ использования интеграции SystemTap — напрямую "
"использовать статические маркеры. Для этого вам необходимо явно указать "
"содержащий их двоичный файл."

#: ../../howto/instrumentation.rst:207
msgid ""
"For example, this SystemTap script can be used to show the call/return "
"hierarchy of a Python script:"
msgstr ""
"Например, этот сценарий SystemTap можно использовать для отображения "
"иерархии вызовов/возвратов сценария Python:"

#: ../../howto/instrumentation.rst:247
msgid "where the columns are:"
msgstr "где столбцы:"

#: ../../howto/instrumentation.rst:249
msgid "time in microseconds since start of script"
msgstr "время в микросекундах с момента запуска скрипта"

#: ../../howto/instrumentation.rst:251
msgid "name of executable"
msgstr "имя исполняемого файла"

#: ../../howto/instrumentation.rst:253
msgid "PID of process"
msgstr "PID процесса"

#: ../../howto/instrumentation.rst:255
msgid ""
"and the remainder indicates the call/return hierarchy as the script executes."
msgstr ""
"а остаток указывает иерархию вызовов/возвратов при выполнении сценария."

#: ../../howto/instrumentation.rst:257
msgid ""
"For a :option:`--enable-shared` build of CPython, the markers are contained "
"within the libpython shared library, and the probe's dotted path needs to "
"reflect this. For example, this line from the above example:"
msgstr ""
"Для сборки CPython :option:`--enable-shared` маркеры содержатся в общей "
"библиотеке libpython, и это должно отражаться в пунктирном пути зонда. "
"Например, эта строка из приведенного выше примера:"

#: ../../howto/instrumentation.rst:265
msgid "should instead read:"
msgstr "вместо этого следует читать:"

#: ../../howto/instrumentation.rst:271
msgid "(assuming a :ref:`debug build <debug-build>` of CPython 3.6)"
msgstr ""
"(при условии, что имеется :ref:`отладочная сборка <debug-build>` CPython 3.6)"

#: ../../howto/instrumentation.rst:275
msgid "Available static markers"
msgstr "Доступные статические маркеры"

#: ../../howto/instrumentation.rst:279
msgid ""
"This marker indicates that execution of a Python function has begun. It is "
"only triggered for pure-Python (bytecode) functions."
msgstr ""
"Этот маркер указывает, что началось выполнение функции Python. Он "
"срабатывает только для функций чистого Python (байт-код)."

#: ../../howto/instrumentation.rst:282
msgid ""
"The filename, function name, and line number are provided back to the "
"tracing script as positional arguments, which must be accessed using "
"``$arg1``, ``$arg2``, ``$arg3``:"
msgstr ""
"Имя файла, имя функции и номер строки передаются обратно в скрипт "
"трассировки в качестве позиционных аргументов, доступ к которым "
"осуществляется с помощью ``$arg1``, ``$arg2``, ``$arg3``:"

#: ../../howto/instrumentation.rst:286
msgid ""
"``$arg1`` : ``(const char *)`` filename, accessible using "
"``user_string($arg1)``"
msgstr ""
"``$arg1`` : ``(const char *)`` filename, accessible using "
"``user_string($arg1)``"

#: ../../howto/instrumentation.rst:288
msgid ""
"``$arg2`` : ``(const char *)`` function name, accessible using "
"``user_string($arg2)``"
msgstr ""
"``$arg2`` : ``(const char *)`` function name, accessible using "
"``user_string($arg2)``"

#: ../../howto/instrumentation.rst:291
msgid "``$arg3`` : ``int`` line number"
msgstr "``$arg3`` : ``int`` line number"

#: ../../howto/instrumentation.rst:295
msgid ""
"This marker is the converse of :c:func:`function__entry`, and indicates that "
"execution of a Python function has ended (either via ``return``, or via an "
"exception).  It is only triggered for pure-Python (bytecode) functions."
msgstr ""

#: ../../howto/instrumentation.rst:299
msgid "The arguments are the same as for :c:func:`function__entry`"
msgstr ""

#: ../../howto/instrumentation.rst:303
msgid ""
"This marker indicates a Python line is about to be executed.  It is the "
"equivalent of line-by-line tracing with a Python profiler.  It is not "
"triggered within C functions."
msgstr ""
"Этот маркер указывает на то, что строка Python скоро будет выполнена. Это "
"эквивалент построчной трассировки с помощью профилировщика Python. Он не "
"запускается в функциях C."

#: ../../howto/instrumentation.rst:307
msgid "The arguments are the same as for :c:func:`function__entry`."
msgstr ""

#: ../../howto/instrumentation.rst:311
msgid ""
"Fires when the Python interpreter starts a garbage collection cycle. "
"``arg0`` is the generation to scan, like :func:`gc.collect()`."
msgstr ""

#: ../../howto/instrumentation.rst:316
msgid ""
"Fires when the Python interpreter finishes a garbage collection cycle. "
"``arg0`` is the number of collected objects."
msgstr ""
"Срабатывает, когда интерпретатор Python завершает цикл сборки мусора. "
"``arg0`` — количество собранных объектов."

#: ../../howto/instrumentation.rst:321
msgid ""
"Fires before :mod:`importlib` attempts to find and load the module. ``arg0`` "
"is the module name."
msgstr ""
"Срабатывает до того, как :mod:`importlib` попытается найти и загрузить "
"модуль. ``arg0`` — это имя модуля."

#: ../../howto/instrumentation.rst:328
msgid ""
"Fires after :mod:`importlib`'s find_and_load function is called. ``arg0`` is "
"the module name, ``arg1`` indicates if module was successfully loaded."
msgstr ""
"Срабатывает после вызова функции find_and_load в :mod:`importlib`. ``arg0`` "
"— это имя модуля, ``arg1`` указывает, был ли модуль успешно загружен."

#: ../../howto/instrumentation.rst:337
msgid ""
"Fires when :func:`sys.audit` or :c:func:`PySys_Audit` is called. ``arg0`` is "
"the event name as C string, ``arg1`` is a :c:type:`PyObject` pointer to a "
"tuple object."
msgstr ""
"Срабатывает при вызове :func:`sys.audit` или :c:func:`PySys_Audit`. arg0 — "
"это имя события в виде строки C, arg1 — это указатель :c:type:`PyObject` на "
"объект-кортеж."

#: ../../howto/instrumentation.rst:345
msgid "SystemTap Tapsets"
msgstr "Смесители SystemTap"

#: ../../howto/instrumentation.rst:347
msgid ""
"The higher-level way to use the SystemTap integration is to use a "
"\"tapset\": SystemTap's equivalent of a library, which hides some of the "
"lower-level details of the static markers."
msgstr ""
"Более высокоуровневый способ использования интеграции SystemTap — "
"использовать «tapset»: эквивалент библиотеки SystemTap, который скрывает "
"некоторые низкоуровневые детали статических маркеров."

#: ../../howto/instrumentation.rst:351
msgid "Here is a tapset file, based on a non-shared build of CPython:"
msgstr "Вот файл набора касаний, основанный на частной сборке CPython:"

#: ../../howto/instrumentation.rst:374
msgid ""
"If this file is installed in SystemTap's tapset directory (e.g. ``/usr/share/"
"systemtap/tapset``), then these additional probepoints become available:"
msgstr ""
"Если этот файл установлен в каталоге Tapset SystemTap (например, ``/usr/"
"share/systemtap/tapset``), тогда становятся доступными следующие "
"дополнительные точки проверки:"

#: ../../howto/instrumentation.rst:380
msgid ""
"This probe point indicates that execution of a Python function has begun. It "
"is only triggered for pure-Python (bytecode) functions."
msgstr ""
"Эта точка проверки указывает на то, что началось выполнение функции Python. "
"Он срабатывает только для функций чистого Python (байт-код)."

#: ../../howto/instrumentation.rst:385
msgid ""
"This probe point is the converse of ``python.function.return``, and "
"indicates that execution of a Python function has ended (either via "
"``return``, or via an exception).  It is only triggered for pure-Python "
"(bytecode) functions."
msgstr ""
"Эта точка проверки является обратной точкой ``python.function.return`` и "
"указывает, что выполнение функции Python закончилось (либо через ``return``, "
"либо через исключение). Он срабатывает только для функций чистого Python "
"(байт-код)."

#: ../../howto/instrumentation.rst:392
msgid "Examples"
msgstr "Примеры"

#: ../../howto/instrumentation.rst:393
msgid ""
"This SystemTap script uses the tapset above to more cleanly implement the "
"example given above of tracing the Python function-call hierarchy, without "
"needing to directly name the static markers:"
msgstr ""
"Этот сценарий SystemTap использует приведенный выше набор тапов для более "
"четкой реализации приведенного выше примера отслеживания иерархии вызовов "
"функций Python без необходимости напрямую называть статические маркеры:"

#: ../../howto/instrumentation.rst:412
msgid ""
"The following script uses the tapset above to provide a top-like view of all "
"running CPython code, showing the top 20 most frequently entered bytecode "
"frames, each second, across the whole system:"
msgstr ""
"Следующий скрипт использует указанный выше набор тапов для обеспечения "
"верхнего вида всего работающего кода CPython, показывая 20 наиболее часто "
"вводимых кадров байт-кода каждую секунду во всей системе:"
