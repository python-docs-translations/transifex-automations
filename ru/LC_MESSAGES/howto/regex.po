# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-21 22:20+0000\n"
"PO-Revision-Date: 2023-05-24 02:11+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../howto/regex.rst:5
msgid "Regular Expression HOWTO"
msgstr "Руководство по использованию регулярных выражений"

#: ../../howto/regex.rst:0
msgid "Author"
msgstr "Автор"

#: ../../howto/regex.rst:7
msgid "A.M. Kuchling <amk@amk.ca>"
msgstr "A.M. Kuchling <amk@amk.ca>"

#: ../../howto/regex.rst-1
msgid "Abstract"
msgstr "Абстракция"

#: ../../howto/regex.rst:18
msgid ""
"This document is an introductory tutorial to using regular expressions in "
"Python with the :mod:`re` module.  It provides a gentler introduction than "
"the corresponding section in the Library Reference."
msgstr ""
"Этот документ представляет собой вводное руководство по использованию "
"регулярных выражений в Python с модулем :mod:`re`. Он представляет собой "
"более мягкое введение, чем соответствующий раздел в Библиотечном справочнике."

#: ../../howto/regex.rst:24
msgid "Introduction"
msgstr "Введение"

#: ../../howto/regex.rst:26
msgid ""
"Regular expressions (called REs, or regexes, or regex patterns) are "
"essentially a tiny, highly specialized programming language embedded inside "
"Python and made available through the :mod:`re` module. Using this little "
"language, you specify the rules for the set of possible strings that you "
"want to match; this set might contain English sentences, or e-mail "
"addresses, or TeX commands, or anything you like.  You can then ask "
"questions such as \"Does this string match the pattern?\", or \"Is there a "
"match for the pattern anywhere in this string?\".  You can also use REs to "
"modify a string or to split it apart in various ways."
msgstr ""
"Регулярные выражения (называемые RE, или регулярные выражения, или шаблоны "
"регулярных выражений) — это, по сути, крошечный узкоспециализированный язык "
"программирования, встроенный в Python и доступный через модуль :mod:`re`. "
"Используя этот небольшой язык, вы указываете правила для набора возможных "
"строк, которые вы хотите сопоставить; этот набор может содержать английские "
"предложения, адреса электронной почты, команды TeX или все, что вам "
"нравится. Затем вы можете задать такие вопросы, как «Соответствует ли эта "
"строка шаблону?» или «Есть ли совпадение с шаблоном где-нибудь в этой "
"строке?». Вы также можете использовать RE для изменения строки или ее "
"разделения различными способами."

#: ../../howto/regex.rst:35
msgid ""
"Regular expression patterns are compiled into a series of bytecodes which "
"are then executed by a matching engine written in C.  For advanced use, it "
"may be necessary to pay careful attention to how the engine will execute a "
"given RE, and write the RE in a certain way in order to produce bytecode "
"that runs faster. Optimization isn't covered in this document, because it "
"requires that you have a good understanding of the matching engine's "
"internals."
msgstr ""
"Шаблоны регулярных выражений компилируются в серию байт-кодов, которые затем "
"выполняются механизмом сопоставления, написанным на C. Для расширенного "
"использования может потребоваться обратить пристальное внимание на то, как "
"механизм будет выполнять данный RE, и записать RE в определенным образом, "
"чтобы создать байт-код, который работает быстрее. Оптимизация не "
"рассматривается в этом документе, поскольку она требует хорошего понимания "
"внутреннего устройства соответствующего механизма."

#: ../../howto/regex.rst:42
msgid ""
"The regular expression language is relatively small and restricted, so not "
"all possible string processing tasks can be done using regular expressions.  "
"There are also tasks that *can* be done with regular expressions, but the "
"expressions turn out to be very complicated.  In these cases, you may be "
"better off writing Python code to do the processing; while Python code will "
"be slower than an elaborate regular expression, it will also probably be "
"more understandable."
msgstr ""
"Язык регулярных выражений относительно небольшой и ограниченный, поэтому не "
"все возможные задачи обработки строк можно выполнить с помощью регулярных "
"выражений. Есть также задачи, которые *можно* решить с помощью регулярных "
"выражений, но выражения оказываются очень сложными. В этих случаях вам может "
"быть лучше написать код Python для выполнения обработки; хотя код Python "
"будет медленнее, чем сложное регулярное выражение, он также, вероятно, будет "
"более понятным."

#: ../../howto/regex.rst:51
msgid "Simple Patterns"
msgstr "Простые шаблоны"

#: ../../howto/regex.rst:53
msgid ""
"We'll start by learning about the simplest possible regular expressions.  "
"Since regular expressions are used to operate on strings, we'll begin with "
"the most common task: matching characters."
msgstr ""
"Мы начнем с изучения простейших регулярных выражений. Поскольку регулярные "
"выражения используются для работы со строками, мы начнем с самой "
"распространенной задачи: сопоставления символов."

#: ../../howto/regex.rst:57
msgid ""
"For a detailed explanation of the computer science underlying regular "
"expressions (deterministic and non-deterministic finite automata), you can "
"refer to almost any textbook on writing compilers."
msgstr ""
"Для подробного объяснения информатики, лежащей в основе регулярных выражений "
"(детерминированных и недетерминированных конечных автоматов), вы можете "
"обратиться практически к любому учебнику по написанию компиляторов."

#: ../../howto/regex.rst:63
msgid "Matching Characters"
msgstr "Совпадающие символы"

#: ../../howto/regex.rst:65
msgid ""
"Most letters and characters will simply match themselves.  For example, the "
"regular expression ``test`` will match the string ``test`` exactly.  (You "
"can enable a case-insensitive mode that would let this RE match ``Test`` or "
"``TEST`` as well; more about this later.)"
msgstr ""
"Большинство букв и символов просто совпадают. Например, регулярное выражение "
"``test`` будет точно соответствовать строке ``test``. (Вы можете включить "
"режим без учета регистра, который позволит этому RE также соответствовать "
"``Test`` или ``TEST``; подробнее об этом позже.)"

#: ../../howto/regex.rst:70
msgid ""
"There are exceptions to this rule; some characters are special :dfn:"
"`metacharacters`, and don't match themselves.  Instead, they signal that "
"some out-of-the-ordinary thing should be matched, or they affect other "
"portions of the RE by repeating them or changing their meaning.  Much of "
"this document is devoted to discussing various metacharacters and what they "
"do."
msgstr ""
"Из этого правила есть исключения; некоторые символы являются специальными :"
"dfn:`метасимволами` и не совпадают сами с собой. Вместо этого они "
"сигнализируют о том, что следует сопоставить какую-то необычную вещь, или "
"влияют на другие части RE, повторяя их или изменяя их значение. Большая "
"часть этого документа посвящена обсуждению различных метасимволов и того, "
"что они делают."

#: ../../howto/regex.rst:76
msgid ""
"Here's a complete list of the metacharacters; their meanings will be "
"discussed in the rest of this HOWTO."
msgstr ""
"Вот полный список метасимволов; их значения будут обсуждаться в оставшейся "
"части этого HOWTO."

#: ../../howto/regex.rst:83
msgid ""
"The first metacharacters we'll look at are ``[`` and ``]``. They're used for "
"specifying a character class, which is a set of characters that you wish to "
"match.  Characters can be listed individually, or a range of characters can "
"be indicated by giving two characters and separating them by a ``'-'``.  For "
"example, ``[abc]`` will match any of the characters ``a``, ``b``, or ``c``; "
"this is the same as ``[a-c]``, which uses a range to express the same set of "
"characters.  If you wanted to match only lowercase letters, your RE would be "
"``[a-z]``."
msgstr ""
"Первые метасимволы, которые мы рассмотрим, — это ``[`` и ``]``. Они "
"используются для указания класса символов, который представляет собой набор "
"символов, которые вы хотите сопоставить. Символы могут быть перечислены "
"индивидуально или можно указать диапазон символов, указав два символа и "
"разделив их знаком ``'-'``. Например, ``[abc]`` будет соответствовать любому "
"из символов ``a``, ``b`` или ``c``; это то же самое, что ``[ac]``, который "
"использует диапазон для выражения того же набора символов. Если вы хотите "
"сопоставить только строчные буквы, ваш RE будет ``[az]``."

#: ../../howto/regex.rst:92
msgid ""
"Metacharacters (except ``\\``) are not active inside classes.  For example, "
"``[akm$]`` will match any of the characters ``'a'``, ``'k'``, ``'m'``, or "
"``'$'``; ``'$'`` is usually a metacharacter, but inside a character class "
"it's stripped of its special nature."
msgstr ""
"Метасимволы (кроме ``\\``) неактивны внутри классов. Например, ``[akm$]`` "
"будет соответствовать любому из символов ``'a'``, ``'k'``, ``'m'`` или "
"``'$'``; ``'$'`` обычно является метасимволом, но внутри класса символов он "
"лишен своей особой природы."

#: ../../howto/regex.rst:97
msgid ""
"You can match the characters not listed within the class by :dfn:"
"`complementing` the set.  This is indicated by including a ``'^'`` as the "
"first character of the class. For example, ``[^5]`` will match any character "
"except ``'5'``.  If the caret appears elsewhere in a character class, it "
"does not have special meaning. For example: ``[5^]`` will match either a "
"``'5'`` or a ``'^'``."
msgstr ""
"Вы можете сопоставить символы, не перечисленные в классе, :dfn:`дополняя` "
"набор. На это указывает включение ``'^'`` в качестве первого символа класса. "
"Например, ``[^5]`` будет соответствовать любому символу, кроме ``'5'``. Если "
"курсор появляется в другом месте класса символов, он не имеет особого "
"значения. Например: ``[5^]`` будет соответствовать либо ``'5'``, либо "
"``'^'``."

#: ../../howto/regex.rst:103
msgid ""
"Perhaps the most important metacharacter is the backslash, ``\\``.   As in "
"Python string literals, the backslash can be followed by various characters "
"to signal various special sequences.  It's also used to escape all the "
"metacharacters so you can still match them in patterns; for example, if you "
"need to match a ``[`` or  ``\\``, you can precede them with a backslash to "
"remove their special meaning: ``\\[`` or ``\\\\``."
msgstr ""
"Возможно, самым важным метасимволом является обратная косая черта ``\\``. "
"Как и в строковых литералах Python, за обратной косой чертой могут следовать "
"различные символы, обозначающие различные специальные последовательности. Он "
"также используется для экранирования всех метасимволов, чтобы вы могли "
"сопоставлять их с шаблонами; например, если вам нужно сопоставить ``[`` или "
"``\\``, вы можете поставить перед ними обратную косую черту, чтобы удалить "
"их особое значение: ``\\[`` или ``\\\\``."

#: ../../howto/regex.rst:110
msgid ""
"Some of the special sequences beginning with ``'\\'`` represent predefined "
"sets of characters that are often useful, such as the set of digits, the set "
"of letters, or the set of anything that isn't whitespace."
msgstr ""
"Некоторые специальные последовательности, начинающиеся с ``'\\'``, "
"представляют собой заранее определенные наборы символов, которые часто "
"бывают полезны, например, набор цифр, набор букв или набор всего, что не "
"является пробелами."

#: ../../howto/regex.rst:115
msgid ""
"Let's take an example: ``\\w`` matches any alphanumeric character.  If the "
"regex pattern is expressed in bytes, this is equivalent to the class ``[a-zA-"
"Z0-9_]``.  If the regex pattern is a string, ``\\w`` will match all the "
"characters marked as letters in the Unicode database provided by the :mod:"
"`unicodedata` module.  You can use the more restricted definition of ``\\w`` "
"in a string pattern by supplying the :const:`re.ASCII` flag when compiling "
"the regular expression."
msgstr ""
"Давайте рассмотрим пример: ``\\w`` соответствует любому буквенно-цифровому "
"символу. Если шаблон регулярного выражения выражается в байтах, это "
"эквивалентно классу ``[a-zA-Z0-9_]``. Если шаблон регулярного выражения "
"представляет собой строку, ``\\w`` будет соответствовать всем символам, "
"помеченным как буквы в базе данных Unicode, предоставленной модулем :mod:"
"`unicodedata`. Вы можете использовать более ограниченное определение ``\\w`` "
"в строковом шаблоне, указав флаг :const:`re.ASCII` при компиляции "
"регулярного выражения."

#: ../../howto/regex.rst:123
msgid ""
"The following list of special sequences isn't complete. For a complete list "
"of sequences and expanded class definitions for Unicode string patterns, see "
"the last part of :ref:`Regular Expression Syntax <re-syntax>` in the "
"Standard Library reference.  In general, the Unicode versions match any "
"character that's in the appropriate category in the Unicode database."
msgstr ""
"Следующий список специальных последовательностей не является полным. Полный "
"список последовательностей и расширенные определения классов для строковых "
"шаблонов Юникода см. в последней части :ref:`Синтаксиса регулярных выражений "
"<re-syntax>` в справочнике по стандартной библиотеке. Как правило, версии "
"Юникода соответствуют любому символу, находящемуся в соответствующей "
"категории в базе данных Юникода."

#: ../../howto/regex.rst:131
msgid "``\\d``"
msgstr "``\\d``"

#: ../../howto/regex.rst:131
msgid "Matches any decimal digit; this is equivalent to the class ``[0-9]``."
msgstr ""
"Соответствует любой десятичной цифре; это эквивалентно классу ``[0-9]``."

#: ../../howto/regex.rst:134
msgid "``\\D``"
msgstr "``\\D``"

#: ../../howto/regex.rst:134
msgid ""
"Matches any non-digit character; this is equivalent to the class ``[^0-9]``."
msgstr ""
"Соответствует любому нецифровому символу; это эквивалентно классу ``[^0-9]``."

#: ../../howto/regex.rst:138
msgid "``\\s``"
msgstr "``\\s``"

#: ../../howto/regex.rst:137
msgid ""
"Matches any whitespace character; this is equivalent to the class "
"``[ \\t\\n\\r\\f\\v]``."
msgstr ""
"Соответствует любому символу пробела; это эквивалентно классу "
"``[ \\t\\n\\r\\f\\v]``."

#: ../../howto/regex.rst:142
msgid "``\\S``"
msgstr "``\\S``"

#: ../../howto/regex.rst:141
msgid ""
"Matches any non-whitespace character; this is equivalent to the class ``[^ "
"\\t\\n\\r\\f\\v]``."
msgstr ""
"Соответствует любому символу без пробелов; это эквивалентно классу ``[^ "
"\\t\\n\\r\\f\\v]``."

#: ../../howto/regex.rst:146
msgid "``\\w``"
msgstr "``\\w``"

#: ../../howto/regex.rst:145
msgid ""
"Matches any alphanumeric character; this is equivalent to the class ``[a-zA-"
"Z0-9_]``."
msgstr ""
"Соответствует любому буквенно-цифровому символу; это эквивалентно классу "
"``[a-zA-Z0-9_]``."

#: ../../howto/regex.rst:150
msgid "``\\W``"
msgstr "``\\W``"

#: ../../howto/regex.rst:149
msgid ""
"Matches any non-alphanumeric character; this is equivalent to the class "
"``[^a-zA-Z0-9_]``."
msgstr ""
"Соответствует любому небуквенно-цифровому символу; это эквивалентно классу "
"``[^a-zA-Z0-9_]``."

#: ../../howto/regex.rst:152
msgid ""
"These sequences can be included inside a character class.  For example, "
"``[\\s,.]`` is a character class that will match any whitespace character, "
"or ``','`` or ``'.'``."
msgstr ""
"Эти последовательности могут быть включены в класс символов. Например, "
"``[\\s,.]`` — это класс символов, который будет соответствовать любому "
"символу пробела или ``','`` или ``'.'``."

#: ../../howto/regex.rst:156
msgid ""
"The final metacharacter in this section is ``.``.  It matches anything "
"except a newline character, and there's an alternate mode (:const:`re."
"DOTALL`) where it will match even a newline.  ``.`` is often used where you "
"want to match \"any character\"."
msgstr ""
"Последний метасимвол в этом разделе — ``.``. Он соответствует всему, кроме "
"символа новой строки, и существует альтернативный режим (:const:`re."
"DOTALL`), в котором он будет соответствовать даже символу новой строки. ``."
"`` часто используется там, где вы хотите сопоставить «любой символ»."

#: ../../howto/regex.rst:163
msgid "Repeating Things"
msgstr "Повторяющиеся вещи"

#: ../../howto/regex.rst:165
msgid ""
"Being able to match varying sets of characters is the first thing regular "
"expressions can do that isn't already possible with the methods available on "
"strings.  However, if that was the only additional capability of regexes, "
"they wouldn't be much of an advance. Another capability is that you can "
"specify that portions of the RE must be repeated a certain number of times."
msgstr ""
"Возможность сопоставлять различные наборы символов — это первое, что могут "
"делать регулярные выражения, что пока невозможно с помощью методов, "
"доступных для строк. Однако, если бы это была единственная дополнительная "
"возможность регулярных выражений, они не были бы большим достижением. Другая "
"возможность заключается в том, что вы можете указать, что части RE должны "
"повторяться определенное количество раз."

#: ../../howto/regex.rst:171
msgid ""
"The first metacharacter for repeating things that we'll look at is ``*``.  "
"``*`` doesn't match the literal character ``'*'``; instead, it specifies "
"that the previous character can be matched zero or more times, instead of "
"exactly once."
msgstr ""
"Первый метасимвол для повторения вещей, который мы рассмотрим, — это ``*``. "
"``*`` не соответствует буквальному символу ``'*'``; вместо этого он "
"указывает, что предыдущий символ может быть сопоставлен ноль или более раз, "
"а не ровно один раз."

#: ../../howto/regex.rst:175
msgid ""
"For example, ``ca*t`` will match ``'ct'`` (0 ``'a'`` characters), ``'cat'`` "
"(1 ``'a'``), ``'caaat'`` (3 ``'a'`` characters), and so forth."
msgstr ""
"Например, ``ca*t`` будет соответствовать ``'ct'`` (0 символов ``'a'``), "
"``'cat'`` (1 ``'a'``), ``' `'caaat'`` (3 символа ``'a'``) и т.д."

#: ../../howto/regex.rst:178
msgid ""
"Repetitions such as ``*`` are :dfn:`greedy`; when repeating a RE, the "
"matching engine will try to repeat it as many times as possible. If later "
"portions of the pattern don't match, the matching engine will then back up "
"and try again with fewer repetitions."
msgstr ""
"Повторения типа ``*`` являются :dfn:`жадными`; при повторении RE механизм "
"сопоставления попытается повторить его столько раз, сколько возможно. Если "
"последующие части шаблона не совпадают, механизм сопоставления выполнит "
"резервное копирование и повторит попытку с меньшим количеством повторений."

#: ../../howto/regex.rst:183
msgid ""
"A step-by-step example will make this more obvious.  Let's consider the "
"expression ``a[bcd]*b``.  This matches the letter ``'a'``, zero or more "
"letters from the class ``[bcd]``, and finally ends with a ``'b'``.  Now "
"imagine matching this RE against the string ``'abcbd'``."
msgstr ""
"Пошаговый пример сделает это более очевидным. Давайте рассмотрим выражение "
"``a[bcd]*b``. Это соответствует букве ``'a'``, нулю или более букв из класса "
"``[bcd]`` и, наконец, заканчивается на ``'b'``. Теперь представьте, что это "
"значение соответствует строке ``'abcbd'``."

#: ../../howto/regex.rst:189
msgid "Step"
msgstr "Шаг"

#: ../../howto/regex.rst:189
msgid "Matched"
msgstr "Сопоставление"

#: ../../howto/regex.rst:189
msgid "Explanation"
msgstr "Пояснение"

#: ../../howto/regex.rst:191
msgid "1"
msgstr "1"

#: ../../howto/regex.rst:191
msgid "``a``"
msgstr "``a``"

#: ../../howto/regex.rst:191
msgid "The ``a`` in the RE matches."
msgstr "Буква ``а`` в ответе совпадает."

#: ../../howto/regex.rst:193
msgid "2"
msgstr "2"

#: ../../howto/regex.rst:193
msgid "``abcbd``"
msgstr "``abcbd``"

#: ../../howto/regex.rst:193
msgid ""
"The engine matches ``[bcd]*``, going as far as it can, which is to the end "
"of the string."
msgstr ""
"Движок сопоставляет `[bcd]*`, заходя так далеко, как только может, то есть "
"до конца строки."

#: ../../howto/regex.rst:197
msgid "3"
msgstr "3"

#: ../../howto/regex.rst:197 ../../howto/regex.rst:205
msgid "*Failure*"
msgstr "*Неудача*"

#: ../../howto/regex.rst:197
msgid ""
"The engine tries to match ``b``, but the current position is at the end of "
"the string, so it fails."
msgstr ""
"Движок пытается найти соответствие `b`, но текущая позиция находится в конце "
"строки, поэтому он терпит неудачу."

#: ../../howto/regex.rst:202
msgid "4"
msgstr "4"

#: ../../howto/regex.rst:202 ../../howto/regex.rst:213
msgid "``abcb``"
msgstr "``abcb``"

#: ../../howto/regex.rst:202
msgid "Back up, so that  ``[bcd]*`` matches one less character."
msgstr ""
"Сделайте резервную копию, чтобы ``[bcd]*`` соответствовало на один символ "
"меньше."

#: ../../howto/regex.rst:205
msgid "5"
msgstr "5"

#: ../../howto/regex.rst:205
msgid ""
"Try ``b`` again, but the current position is at the last character, which is "
"a ``'d'``."
msgstr ""
"Попробуйте ``b`` еще раз, но текущая позиция находится на последнем символе, "
"то есть ``'d'``."

#: ../../howto/regex.rst:209 ../../howto/regex.rst:213
msgid "6"
msgstr "6"

#: ../../howto/regex.rst:209
msgid "``abc``"
msgstr "``abc``"

#: ../../howto/regex.rst:209
msgid "Back up again, so that ``[bcd]*`` is only matching ``bc``."
msgstr ""
"Создайте резервную копию еще раз, чтобы ``[bcd]*`` соответствовал только "
"``bc``."

#: ../../howto/regex.rst:213
msgid ""
"Try ``b`` again.  This time the character at the current position is "
"``'b'``, so it succeeds."
msgstr ""
"Попробуйте ``b`` еще раз. На этот раз символом в текущей позиции является "
"``'b'``, так что это удалось."

#: ../../howto/regex.rst:219
msgid ""
"The end of the RE has now been reached, and it has matched ``'abcb'``.  This "
"demonstrates how the matching engine goes as far as it can at first, and if "
"no match is found it will then progressively back up and retry the rest of "
"the RE again and again.  It will back up until it has tried zero matches for "
"``[bcd]*``, and if that subsequently fails, the engine will conclude that "
"the string doesn't match the RE at all."
msgstr ""
"Достигнут конец RE, и он соответствует ``'abcb'``. Это демонстрирует, как "
"механизм сопоставления сначала работает настолько далеко, насколько это "
"возможно, и, если совпадение не найдено, он затем постепенно выполняет "
"резервное копирование и повторяет остальную часть RE снова и снова. Он будет "
"выполнять резервное копирование до тех пор, пока не будет проверено нулевое "
"совпадение для ``[bcd]*``, и если впоследствии это не удастся, механизм "
"придет к выводу, что строка вообще не соответствует RE."

#: ../../howto/regex.rst:226
msgid ""
"Another repeating metacharacter is ``+``, which matches one or more times.  "
"Pay careful attention to the difference between ``*`` and ``+``; ``*`` "
"matches *zero* or more times, so whatever's being repeated may not be "
"present at all, while ``+`` requires at least *one* occurrence.  To use a "
"similar example, ``ca+t`` will match ``'cat'`` (1 ``'a'``), ``'caaat'`` (3 "
"``'a'``\\ s), but won't match ``'ct'``."
msgstr ""
"Другой повторяющийся метасимвол — ``+``, который соответствует один или "
"несколько раз. Обратите особое внимание на разницу между ``*`` и ``+``; "
"``*`` соответствует *нолю* или более раз, поэтому все, что повторяется, "
"может отсутствовать вообще, тогда как ``+`` требует хотя бы *одного* "
"вхождения. Если использовать аналогичный пример, ``ca+t`` будет "
"соответствовать ``'cat'`` (1 ``'a'``), ``'caaat'`` (3 ``'a'``\\ s), но не "
"будет соответствовать ``'ct'``."

#: ../../howto/regex.rst:233
msgid ""
"There are two more repeating operators or quantifiers.  The question mark "
"character, ``?``, matches either once or zero times; you can think of it as "
"marking something as being optional.  For example, ``home-?brew`` matches "
"either ``'homebrew'`` or ``'home-brew'``."
msgstr ""
"Есть еще два повторяющихся оператора или квантора. Символ вопросительного "
"знака ``?`` соответствует либо один раз, либо ноль раз; вы можете думать об "
"этом как о пометке чего-то как необязательного. Например, ``home-?brew`` "
"соответствует либо ``homebrew'``, либо ``'home-brew'``."

#: ../../howto/regex.rst:238
msgid ""
"The most complicated quantifier is ``{m,n}``, where *m* and *n* are decimal "
"integers.  This quantifier means there must be at least *m* repetitions, and "
"at most *n*.  For example, ``a/{1,3}b`` will match ``'a/b'``, ``'a//b'``, "
"and ``'a///b'``.  It won't match ``'ab'``, which has no slashes, or ``'a////"
"b'``, which has four."
msgstr ""
"Самый сложный квантификатор — это ``{m,n}``, где *m* и *n* — десятичные "
"целые числа. Этот квантификатор означает, что должно быть не менее *m* "
"повторений и не более *n*. Например, ``a/{1,3}b`` будет соответствовать ``'a/"
"b'``, ``'a//b'`` и ``'a///b'`` . Он не будет соответствовать ``'ab'``, у "
"которого нет косых черт, или ``'a////b'``, у которого их четыре."

#: ../../howto/regex.rst:244
msgid ""
"You can omit either *m* or *n*; in that case, a reasonable value is assumed "
"for the missing value.  Omitting *m* is interpreted as a lower limit of 0, "
"while omitting *n* results in an upper bound of infinity."
msgstr ""
"Вы можете опустить либо *m*, либо *n*; в этом случае для отсутствующего "
"значения предполагается разумное значение. Пропуск *m* интерпретируется как "
"нижний предел, равный 0, а пропуск *n* приводит к верхней границе "
"бесконечности."

#: ../../howto/regex.rst:248
msgid ""
"The simplest case ``{m}`` matches the preceding item exactly *m* times. For "
"example, ``a/{2}b`` will only match ``'a//b'``."
msgstr ""
"Самый простой случай ``{m}`` соответствует предыдущему элементу ровно *m* "
"раз. Например, ``a/{2}b`` будет соответствовать только ``'a//b'``."

#: ../../howto/regex.rst:251
msgid ""
"Readers of a reductionist bent may notice that the three other quantifiers "
"can all be expressed using this notation.  ``{0,}`` is the same as ``*``, "
"``{1,}`` is equivalent to ``+``, and ``{0,1}`` is the same as ``?``.  It's "
"better to use ``*``, ``+``, or ``?`` when you can, simply because they're "
"shorter and easier to read."
msgstr ""
"Читатели, придерживающиеся редукционистских взглядов, могут заметить, что "
"все три других квантора могут быть выражены с использованием этой записи. "
"``{0,}`` совпадает с ``*``, ``{1,}`` эквивалентен ``+``, а ``{0,1}`` "
"аналогичен `` `?``. Лучше использовать ``*``, ``+`` или ``?``, когда это "
"возможно, просто потому, что они короче и их легче читать."

#: ../../howto/regex.rst:259
msgid "Using Regular Expressions"
msgstr "Использование регулярных выражений"

#: ../../howto/regex.rst:261
msgid ""
"Now that we've looked at some simple regular expressions, how do we actually "
"use them in Python?  The :mod:`re` module provides an interface to the "
"regular expression engine, allowing you to compile REs into objects and then "
"perform matches with them."
msgstr ""
"Теперь, когда мы рассмотрели некоторые простые регулярные выражения, как нам "
"на самом деле использовать их в Python? Модуль :mod:`re` предоставляет "
"интерфейс для механизма регулярных выражений, позволяя вам компилировать RE "
"в объекты и затем выполнять с ними сопоставления."

#: ../../howto/regex.rst:268
msgid "Compiling Regular Expressions"
msgstr "Компиляция регулярных выражений"

#: ../../howto/regex.rst:270
msgid ""
"Regular expressions are compiled into pattern objects, which have methods "
"for various operations such as searching for pattern matches or performing "
"string substitutions. ::"
msgstr ""
"Регулярные выражения компилируются в объекты шаблонов, которые имеют методы "
"для различных операций, таких как поиск совпадений с шаблоном или выполнение "
"подстановки строк. ::"

#: ../../howto/regex.rst:279
msgid ""
":func:`re.compile` also accepts an optional *flags* argument, used to enable "
"various special features and syntax variations.  We'll go over the available "
"settings later, but for now a single example will do::"
msgstr ""
":func:`re.compile` также принимает необязательный аргумент *flags*, "
"используемый для включения различных специальных функций и вариантов "
"синтаксиса. Доступные настройки мы рассмотрим позже, а пока достаточно "
"одного примера:"

#: ../../howto/regex.rst:285
msgid ""
"The RE is passed to :func:`re.compile` as a string.  REs are handled as "
"strings because regular expressions aren't part of the core Python language, "
"and no special syntax was created for expressing them.  (There are "
"applications that don't need REs at all, so there's no need to bloat the "
"language specification by including them.) Instead, the :mod:`re` module is "
"simply a C extension module included with Python, just like the :mod:"
"`socket` or :mod:`zlib` modules."
msgstr ""
"RE передается в :func:`re.compile` как строка. RE обрабатываются как строки, "
"поскольку регулярные выражения не являются частью основного языка Python, и "
"для их выражения не было создано специального синтаксиса. (Есть приложения, "
"которым вообще не нужны RE, поэтому нет необходимости раздувать спецификацию "
"языка, включая их.) Вместо этого модуль :mod:`re` — это просто модуль "
"расширения C, включенный в Python, точно так же, как модуль Модули :mod:"
"`socket` или :mod:`zlib`."

#: ../../howto/regex.rst:292
msgid ""
"Putting REs in strings keeps the Python language simpler, but has one "
"disadvantage which is the topic of the next section."
msgstr ""
"Размещение RE в строках упрощает язык Python, но имеет один недостаток, "
"который является темой следующего раздела."

#: ../../howto/regex.rst:299
msgid "The Backslash Plague"
msgstr "Эпидемия обратного слэша"

#: ../../howto/regex.rst:301
msgid ""
"As stated earlier, regular expressions use the backslash character "
"(``'\\'``) to indicate special forms or to allow special characters to be "
"used without invoking their special meaning. This conflicts with Python's "
"usage of the same character for the same purpose in string literals."
msgstr ""
"Как говорилось ранее, регулярные выражения используют символ обратной косой "
"черты (``'\\'``) для обозначения специальных форм или для разрешения "
"использования специальных символов без обращения к их особому значению. Это "
"противоречит использованию Python того же символа для той же цели в "
"строковых литералах."

#: ../../howto/regex.rst:306
msgid ""
"Let's say you want to write a RE that matches the string ``\\section``, "
"which might be found in a LaTeX file.  To figure out what to write in the "
"program code, start with the desired string to be matched.  Next, you must "
"escape any backslashes and other metacharacters by preceding them with a "
"backslash, resulting in the string ``\\\\section``.  The resulting string "
"that must be passed to :func:`re.compile` must be ``\\\\section``.  However, "
"to express this as a Python string literal, both backslashes must be escaped "
"*again*."
msgstr ""
"Допустим, вы хотите написать RE, соответствующий строке ``\\section``, "
"которую можно найти в файле LaTeX. Чтобы разобраться, что писать в коде "
"программы, начните с нужной строки, которую нужно сопоставить. Затем вы "
"должны избежать любых обратных косых черт и других метасимволов, поставив "
"перед ними обратную косую черту, в результате чего получится строка ``\\"
"\\section``. Результирующая строка, которая должна быть передана в :func:`re."
"compile`, должна быть ``\\\\section``. Однако, чтобы выразить это как "
"строковый литерал Python, обе обратные косые черты должны быть *снова* "
"экранированы."

#: ../../howto/regex.rst:315
msgid "Characters"
msgstr "Символы"

#: ../../howto/regex.rst:315
msgid "Stage"
msgstr "Этап"

#: ../../howto/regex.rst:317
msgid "``\\section``"
msgstr "``\\section``"

#: ../../howto/regex.rst:317
msgid "Text string to be matched"
msgstr "Текстовая строка для сопоставления"

#: ../../howto/regex.rst:319
msgid "``\\\\section``"
msgstr "``\\\\section``"

#: ../../howto/regex.rst:319
msgid "Escaped backslash for :func:`re.compile`"
msgstr "Экранированная обратная косая черта для :func:`re.compile`"

#: ../../howto/regex.rst:321 ../../howto/regex.rst:348
msgid "``\"\\\\\\\\section\"``"
msgstr "``\"\\\\\\\\section\"``"

#: ../../howto/regex.rst:321
msgid "Escaped backslashes for a string literal"
msgstr "Экранированные обратные косые черты для строкового литерала"

#: ../../howto/regex.rst:324
msgid ""
"In short, to match a literal backslash, one has to write ``'\\\\\\\\'`` as "
"the RE string, because the regular expression must be ``\\\\``, and each "
"backslash must be expressed as ``\\\\`` inside a regular Python string "
"literal.  In REs that feature backslashes repeatedly, this leads to lots of "
"repeated backslashes and makes the resulting strings difficult to understand."
msgstr ""
"Короче говоря, чтобы сопоставить буквальную обратную косую черту, нужно "
"написать ``'\\\\\\\\'`` в качестве строки RE, потому что регулярное "
"выражение должно быть ``\\\\``, а каждая обратная косая черта должна быть "
"выражена как `` \\\\`` внутри обычного строкового литерала Python. В RE, в "
"которых обратная косая черта используется неоднократно, это приводит к "
"множеству повторяющихся обратных косых черт и затрудняет понимание "
"полученных строк."

#: ../../howto/regex.rst:330
msgid ""
"The solution is to use Python's raw string notation for regular expressions; "
"backslashes are not handled in any special way in a string literal prefixed "
"with ``'r'``, so ``r\"\\n\"`` is a two-character string containing ``'\\'`` "
"and ``'n'``, while ``\"\\n\"`` is a one-character string containing a "
"newline. Regular expressions will often be written in Python code using this "
"raw string notation."
msgstr ""
"Решение состоит в том, чтобы использовать для регулярных выражений "
"необработанную строковую нотацию Python; обратная косая черта не "
"обрабатывается каким-либо особым образом в строковом литерале с префиксом "
"``'r'``, поэтому ``r\"\\n\"`` представляет собой двухсимвольную строку, "
"содержащую ``'\\'`` и ``' n'``, а ``\"\\n\"`` представляет собой "
"односимвольную строку, содержащую перевод строки. Регулярные выражения часто "
"пишутся в коде Python с использованием этой необработанной строковой нотации."

#: ../../howto/regex.rst:336
msgid ""
"In addition, special escape sequences that are valid in regular expressions, "
"but not valid as Python string literals, now result in a :exc:"
"`DeprecationWarning` and will eventually become a :exc:`SyntaxError`, which "
"means the sequences will be invalid if raw string notation or escaping the "
"backslashes isn't used."
msgstr ""
"Кроме того, специальные escape-последовательности, которые допустимы в "
"регулярных выражениях, но недопустимы в качестве строковых литералов Python, "
"теперь приводят к :exc:`DeprecationWarning` и в конечном итоге становятся :"
"exc:`SyntaxError`, что означает, что последовательности будут "
"недействительными. если не используется необработанная строковая запись или "
"экранирование обратной косой черты."

#: ../../howto/regex.rst:344
msgid "Regular String"
msgstr "Обычная строка"

#: ../../howto/regex.rst:344
msgid "Raw string"
msgstr "Необработанная строка"

#: ../../howto/regex.rst:346
msgid "``\"ab*\"``"
msgstr "``\"ab*\"``"

#: ../../howto/regex.rst:346
msgid "``r\"ab*\"``"
msgstr "``r\"ab*\"``"

#: ../../howto/regex.rst:348
msgid "``r\"\\\\section\"``"
msgstr "``r\"\\\\section\"``"

#: ../../howto/regex.rst:350
msgid "``\"\\\\w+\\\\s+\\\\1\"``"
msgstr "``\"\\\\w+\\\\s+\\\\1\"``"

#: ../../howto/regex.rst:350
msgid "``r\"\\w+\\s+\\1\"``"
msgstr "``r\"\\w+\\s+\\1\"``"

#: ../../howto/regex.rst:355
msgid "Performing Matches"
msgstr "Проведение матчей"

#: ../../howto/regex.rst:357
msgid ""
"Once you have an object representing a compiled regular expression, what do "
"you do with it?  Pattern objects have several methods and attributes. Only "
"the most significant ones will be covered here; consult the :mod:`re` docs "
"for a complete listing."
msgstr ""
"Если у вас есть объект, представляющий скомпилированное регулярное "
"выражение, что вы с ним делаете? Объекты шаблонов имеют несколько методов и "
"атрибутов. Здесь будут рассмотрены только наиболее важные из них; полный "
"список см. в документации :mod:`re`."

#: ../../howto/regex.rst:363 ../../howto/regex.rst:421
#: ../../howto/regex.rst:1069
msgid "Method/Attribute"
msgstr "Метод/Атрибут"

#: ../../howto/regex.rst:363 ../../howto/regex.rst:421
#: ../../howto/regex.rst:1069
msgid "Purpose"
msgstr "Предназначение"

#: ../../howto/regex.rst:365
msgid "``match()``"
msgstr "``match()``"

#: ../../howto/regex.rst:365
msgid "Determine if the RE matches at the beginning of the string."
msgstr "Определите, соответствует ли RE началу строки."

#: ../../howto/regex.rst:368
msgid "``search()``"
msgstr "``search()``"

#: ../../howto/regex.rst:368
msgid "Scan through a string, looking for any location where this RE matches."
msgstr ""
"Просканируйте строку в поисках любого места, которому соответствует этот RE."

#: ../../howto/regex.rst:371
msgid "``findall()``"
msgstr "``findall()``"

#: ../../howto/regex.rst:371
msgid "Find all substrings where the RE matches, and returns them as a list."
msgstr ""
"Найдите все подстроки, которым соответствует RE, и вернет их в виде списка."

#: ../../howto/regex.rst:374
msgid "``finditer()``"
msgstr "``finditer()``"

#: ../../howto/regex.rst:374
msgid ""
"Find all substrings where the RE matches, and returns them as an :term:"
"`iterator`."
msgstr ""
"Находит все подстроки, которым соответствует RE, и возвращает их в виде :"
"term:`итератора`."

#: ../../howto/regex.rst:378
msgid ""
":meth:`~re.Pattern.match` and :meth:`~re.Pattern.search` return ``None`` if "
"no match can be found.  If they're successful, a :ref:`match object <match-"
"objects>` instance is returned, containing information about the match: "
"where it starts and ends, the substring it matched, and more."
msgstr ""
":meth:`~re.Pattern.match` и :meth:`~re.Pattern.search` возвращают ``None``, "
"если совпадение не найдено. Если они успешны, возвращается экземпляр :ref:"
"`match object <match-objects>`, содержащий информацию о совпадении: где оно "
"начинается и заканчивается, совпадающую подстроку и многое другое."

#: ../../howto/regex.rst:383
msgid ""
"You can learn about this by interactively experimenting with the :mod:`re` "
"module.  If you have :mod:`tkinter` available, you may also want to look at :"
"source:`Tools/demo/redemo.py`, a demonstration program included with the "
"Python distribution.  It allows you to enter REs and strings, and displays "
"whether the RE matches or fails. :file:`redemo.py` can be quite useful when "
"trying to debug a complicated RE."
msgstr ""

#: ../../howto/regex.rst:390
msgid ""
"This HOWTO uses the standard Python interpreter for its examples. First, run "
"the Python interpreter, import the :mod:`re` module, and compile a RE::"
msgstr ""
"В этом HOWTO для примеров используется стандартный интерпретатор Python. "
"Сначала запустите интерпретатор Python, импортируйте модуль :mod:`re` и "
"скомпилируйте RE::"

#: ../../howto/regex.rst:398
msgid ""
"Now, you can try matching various strings against the RE ``[a-z]+``.  An "
"empty string shouldn't match at all, since ``+`` means 'one or more "
"repetitions'. :meth:`~re.Pattern.match` should return ``None`` in this case, "
"which will cause the interpreter to print no output.  You can explicitly "
"print the result of :meth:`!match` to make this clear. ::"
msgstr ""
"Теперь вы можете попробовать сопоставить различные строки с RE ``[az]+``. "
"Пустая строка вообще не должна совпадать, поскольку ``+`` означает \"одно "
"или несколько повторений\". :meth:`~re.Pattern.match` в этом случае должен "
"возвращать ``None``, что приведет к тому, что интерпретатор не выведет "
"никаких результатов. Вы можете явно вывести результат :meth:`!match`, чтобы "
"прояснить это. ::"

#: ../../howto/regex.rst:408
msgid ""
"Now, let's try it on a string that it should match, such as ``tempo``.  In "
"this case, :meth:`~re.Pattern.match` will return a :ref:`match object <match-"
"objects>`, so you should store the result in a variable for later use. ::"
msgstr ""
"Теперь давайте попробуем это сделать со строкой, которой она должна "
"соответствовать, например, «tempo». В этом случае :meth:`~re.Pattern.match` "
"вернет объект :ref:`match <match-objects>`, поэтому вам следует сохранить "
"результат в переменной для дальнейшего использования. ::"

#: ../../howto/regex.rst:416
msgid ""
"Now you can query the :ref:`match object <match-objects>` for information "
"about the matching string.  Match object instances also have several methods "
"and attributes; the most important ones are:"
msgstr ""
"Теперь вы можете запросить :ref:`match object <match-objects>` для получения "
"информации о соответствующей строке. Экземпляры объекта соответствия также "
"имеют несколько методов и атрибутов; наиболее важные из них:"

#: ../../howto/regex.rst:423
msgid "``group()``"
msgstr "``group()``"

#: ../../howto/regex.rst:423
msgid "Return the string matched by the RE"
msgstr "Вернуть строку, соответствующую RE"

#: ../../howto/regex.rst:425
msgid "``start()``"
msgstr "``start()``"

#: ../../howto/regex.rst:425
msgid "Return the starting position of the match"
msgstr "Вернуть исходную позицию матча"

#: ../../howto/regex.rst:427
msgid "``end()``"
msgstr "``end()``"

#: ../../howto/regex.rst:427
msgid "Return the ending position of the match"
msgstr "Вернуть конечную позицию матча"

#: ../../howto/regex.rst:429
msgid "``span()``"
msgstr "``span()``"

#: ../../howto/regex.rst:429
msgid "Return a tuple containing the (start, end) positions  of the match"
msgstr "Возвращает кортеж, содержащий позиции (начало и конец) совпадения."

#: ../../howto/regex.rst:433
msgid "Trying these methods will soon clarify their meaning::"
msgstr "Попробовав эти методы, вы вскоре проясните их значение:"

#: ../../howto/regex.rst:442
msgid ""
":meth:`~re.Match.group` returns the substring that was matched by the RE.  :"
"meth:`~re.Match.start` and :meth:`~re.Match.end` return the starting and "
"ending index of the match. :meth:`~re.Match.span` returns both start and end "
"indexes in a single tuple.  Since the :meth:`~re.Pattern.match` method only "
"checks if the RE matches at the start of a string, :meth:`!start` will "
"always be zero.  However, the :meth:`~re.Pattern.search` method of patterns "
"scans through the string, so  the match may not start at zero in that "
"case. ::"
msgstr ""
":meth:`~re.Match.group` возвращает подстроку, совпадающую с RE. :meth:`~re."
"Match.start` и :meth:`~re.Match.end` возвращают начальный и конечный индекс "
"совпадения. :meth:`~re.Match.span` возвращает начальный и конечный индексы в "
"одном кортеже. Поскольку метод :meth:`~re.Pattern.match` проверяет только "
"совпадение RE в начале строки, :meth:`!start` всегда будет нулевым. Однако "
"метод шаблонов :meth:`~re.Pattern.search` сканирует строку, поэтому в этом "
"случае совпадение может не начинаться с нуля. ::"

#: ../../howto/regex.rst:459
msgid ""
"In actual programs, the most common style is to store the :ref:`match object "
"<match-objects>` in a variable, and then check if it was ``None``.  This "
"usually looks like::"
msgstr ""
"В реальных программах наиболее распространенным стилем является сохранение :"
"ref:`match object <match-objects>` в переменной, а затем проверка, является "
"ли он ``None``. Обычно это выглядит так::"

#: ../../howto/regex.rst:470
msgid ""
"Two pattern methods return all of the matches for a pattern. :meth:`~re."
"Pattern.findall` returns a list of matching strings::"
msgstr ""
"Два метода шаблона возвращают все совпадения шаблона. :meth:`~re.Pattern."
"findall` возвращает список совпадающих строк::"

#: ../../howto/regex.rst:477
msgid ""
"The ``r`` prefix, making the literal a raw string literal, is needed in this "
"example because escape sequences in a normal \"cooked\" string literal that "
"are not recognized by Python, as opposed to regular expressions, now result "
"in a :exc:`DeprecationWarning` and will eventually become a :exc:"
"`SyntaxError`.  See :ref:`the-backslash-plague`."
msgstr ""
"Префикс ``r``, делающий литерал необработанным строковым литералом, "
"необходим в этом примере, поскольку escape-последовательности в обычном "
"«приготовленном» строковом литерале, которые не распознаются Python, в "
"отличие от регулярных выражений, теперь приводят к : exc:"
"`DeprecationWarning` и в конечном итоге станет :exc:`SyntaxError`. См. :ref:"
"`the-backslash-plague`."

#: ../../howto/regex.rst:483
msgid ""
":meth:`~re.Pattern.findall` has to create the entire list before it can be "
"returned as the result.  The :meth:`~re.Pattern.finditer` method returns a "
"sequence of :ref:`match object <match-objects>` instances as an :term:"
"`iterator`::"
msgstr ""
":meth:`~re.Pattern.findall` должен создать весь список, прежде чем его можно "
"будет вернуть в качестве результата. Метод :meth:`~re.Pattern.finditer` "
"возвращает последовательность экземпляров :ref:`match object <match-"
"objects>` в виде :term:`iterator`::"

#: ../../howto/regex.rst:499
msgid "Module-Level Functions"
msgstr "Функции на уровне модуля"

#: ../../howto/regex.rst:501
msgid ""
"You don't have to create a pattern object and call its methods; the :mod:"
"`re` module also provides top-level functions called :func:`~re.match`, :"
"func:`~re.search`, :func:`~re.findall`, :func:`~re.sub`, and so forth.  "
"These functions take the same arguments as the corresponding pattern method "
"with the RE string added as the first argument, and still return either "
"``None`` or a :ref:`match object <match-objects>` instance. ::"
msgstr ""
"Вам не нужно создавать объект шаблона и вызывать его методы; Модуль :mod:"
"`re` также предоставляет функции верхнего уровня, называемые :func:`~re."
"match`, :func:`~re.search`, :func:`~re.findall`, :func:`~ re.sub` и так "
"далее. Эти функции принимают те же аргументы, что и соответствующий метод "
"шаблона, со строкой RE, добавленной в качестве первого аргумента, и по-"
"прежнему возвращают либо ``None``, либо экземпляр :ref:`match object <match-"
"objects>`. ::"

#: ../../howto/regex.rst:513
msgid ""
"Under the hood, these functions simply create a pattern object for you and "
"call the appropriate method on it.  They also store the compiled object in a "
"cache, so future calls using the same RE won't need to parse the pattern "
"again and again."
msgstr ""
"По сути, эти функции просто создают для вас объект шаблона и вызывают для "
"него соответствующий метод. Они также сохраняют скомпилированный объект в "
"кеше, поэтому будущим вызовам, использующим тот же RE, не придется снова и "
"снова анализировать шаблон."

#: ../../howto/regex.rst:518
msgid ""
"Should you use these module-level functions, or should you get the pattern "
"and call its methods yourself?  If you're accessing a regex within a loop, "
"pre-compiling it will save a few function calls. Outside of loops, there's "
"not much difference thanks to the internal cache."
msgstr ""
"Стоит ли вам использовать эти функции уровня модуля или вам следует получить "
"шаблон и самостоятельно вызывать его методы? Если вы получаете доступ к "
"регулярному выражению внутри цикла, его предварительная компиляция позволит "
"сэкономить несколько вызовов функций. За пределами циклов особой разницы нет "
"благодаря внутреннему кешу."

#: ../../howto/regex.rst:526
msgid "Compilation Flags"
msgstr "Флаги компиляции"

#: ../../howto/regex.rst:530
msgid ""
"Compilation flags let you modify some aspects of how regular expressions "
"work. Flags are available in the :mod:`re` module under two names, a long "
"name such as :const:`IGNORECASE` and a short, one-letter form such as :const:"
"`I`.  (If you're familiar with Perl's pattern modifiers, the one-letter "
"forms use the same letters; the short form of :const:`re.VERBOSE` is :const:"
"`re.X`, for example.) Multiple flags can be specified by bitwise OR-ing "
"them; ``re.I | re.M`` sets both the :const:`I` and :const:`M` flags, for "
"example."
msgstr ""
"Флаги компиляции позволяют изменять некоторые аспекты работы регулярных "
"выражений. Флаги доступны в модуле :mod:`re` под двумя именами: длинным, "
"например :const:`IGNORECASE`, и коротким, состоящим из одной буквы, "
"например :const:`I`. (Если вы знакомы с модификаторами шаблонов Perl, то в "
"однобуквенных формах используются одни и те же буквы; например, краткая "
"форма :const:`re.VERBOSE` — :const:`re.X`.) Можно использовать несколько "
"флагов. быть заданы посредством побитового ИЛИ; ``ре.Я | Например, re.M`` "
"устанавливает оба флага :const:`I` и :const:`M`."

#: ../../howto/regex.rst:538
msgid ""
"Here's a table of the available flags, followed by a more detailed "
"explanation of each one."
msgstr ""
"Ниже представлена ​​таблица доступных флагов с более подробным объяснением "
"каждого из них."

#: ../../howto/regex.rst:542
msgid "Flag"
msgstr "Флаг"

#: ../../howto/regex.rst:542
msgid "Meaning"
msgstr "Значение"

#: ../../howto/regex.rst:544
msgid ":const:`ASCII`, :const:`A`"
msgstr ":const:`ASCII`, :const:`A`"

#: ../../howto/regex.rst:544
msgid ""
"Makes several escapes like ``\\w``, ``\\b``, ``\\s`` and ``\\d`` match only "
"on ASCII characters with the respective property."
msgstr ""
"Делает несколько управляющих символов, таких как ``\\w``, ``\\b``, ``\\s`` и "
"``\\d``, соответствующими только символам ASCII с соответствующим свойством."

#: ../../howto/regex.rst:548
msgid ":const:`DOTALL`, :const:`S`"
msgstr ":const:`DOTALL`, :const:`S`"

#: ../../howto/regex.rst:548
msgid "Make ``.`` match any character, including newlines."
msgstr ""
"Сделайте так, чтобы ``.`` соответствовал любому символу, включая символы "
"новой строки."

#: ../../howto/regex.rst:551
msgid ":const:`IGNORECASE`, :const:`I`"
msgstr ":const:`IGNORECASE`, :const:`I`"

#: ../../howto/regex.rst:551
msgid "Do case-insensitive matches."
msgstr "Делайте совпадения без учета регистра."

#: ../../howto/regex.rst:553
msgid ":const:`LOCALE`, :const:`L`"
msgstr ":const:`LOCALE`, :const:`L`"

#: ../../howto/regex.rst:553
msgid "Do a locale-aware match."
msgstr "Выполните сопоставление с учетом локали."

#: ../../howto/regex.rst:555
msgid ":const:`MULTILINE`, :const:`M`"
msgstr ":const:`MULTILINE`, :const:`M`"

#: ../../howto/regex.rst:555
msgid "Multi-line matching, affecting ``^`` and ``$``."
msgstr "многострочное сопоставление, затрагивающее ``^`` и ``$``."

#: ../../howto/regex.rst:558
msgid ":const:`VERBOSE`, :const:`X` (for 'extended')"
msgstr ":const:`VERBOSE`, :const:`X` (для 'extended')"

#: ../../howto/regex.rst:558
msgid ""
"Enable verbose REs, which can be organized more cleanly and understandably."
msgstr ""
"Включите подробные RE, которые можно организовать более четко и понятно."

#: ../../howto/regex.rst:567
msgid ""
"Perform case-insensitive matching; character class and literal strings will "
"match letters by ignoring case.  For example, ``[A-Z]`` will match lowercase "
"letters, too. Full Unicode matching also works unless the :const:`ASCII` "
"flag is used to disable non-ASCII matches.  When the Unicode patterns ``[a-"
"z]`` or ``[A-Z]`` are used in combination with the :const:`IGNORECASE` flag, "
"they will match the 52 ASCII letters and 4 additional non-ASCII letters: "
"'İ' (U+0130, Latin capital letter I with dot above), 'ı' (U+0131, Latin "
"small letter dotless i), 'ſ' (U+017F, Latin small letter long s) and "
"'K' (U+212A, Kelvin sign).  ``Spam`` will match ``'Spam'``, ``'spam'``, "
"``'spAM'``, or ``'ſpam'`` (the latter is matched only in Unicode mode). This "
"lowercasing doesn't take the current locale into account; it will if you "
"also set the :const:`LOCALE` flag."
msgstr ""
"Выполнить сопоставление без учета регистра; класс символов и литеральные "
"строки будут соответствовать буквам, игнорируя регистр. Например, ``[AZ]`` "
"также будет соответствовать строчным буквам. Полное соответствие Юникода "
"также работает, если не используется флаг :const:`ASCII` для отключения "
"совпадений, отличных от ASCII. Когда шаблоны Юникода ``[az]`` или ``[AZ]`` "
"используются в сочетании с флагом :const:`IGNORECASE`, они будут "
"соответствовать 52 буквам ASCII и 4 дополнительным буквам, отличным от "
"ASCII: 'İ ' (U+0130, латинская заглавная буква I с точкой вверху), "
"'ı' (U+0131, латинская строчная буква без точки i), 'ſ' (U+017F, длинная "
"латинская строчная буква s) и 'K' (U +212А, знак Кельвина). ``Spam`` будет "
"соответствовать ``'Spam'``, ``'spam'``, ``'spAM'`` или ``'Spam'`` (последний "
"сопоставляется только в режиме Unicode). При этом нижнем регистре не "
"учитывается текущая локаль; так и будет, если вы также установите флаг :"
"const:`LOCALE`."

#: ../../howto/regex.rst:585
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B`` and case-insensitive matching "
"dependent on the current locale instead of the Unicode database."
msgstr ""
"Сделайте ``\\w``, ``\\W``, ``\\b``, ``\\B`` и сопоставление без учета "
"регистра зависящим от текущей локали, а не от базы данных Unicode."

#: ../../howto/regex.rst:588
msgid ""
"Locales are a feature of the C library intended to help in writing programs "
"that take account of language differences.  For example, if you're "
"processing encoded French text, you'd want to be able to write ``\\w+`` to "
"match words, but ``\\w`` only matches the character class ``[A-Za-z]`` in "
"bytes patterns; it won't match bytes corresponding to ``é`` or ``ç``. If "
"your system is configured properly and a French locale is selected, certain "
"C functions will tell the program that the byte corresponding to ``é`` "
"should also be considered a letter. Setting the :const:`LOCALE` flag when "
"compiling a regular expression will cause the resulting compiled object to "
"use these C functions for ``\\w``; this is slower, but also enables ``\\w+`` "
"to match French words as you'd expect. The use of this flag is discouraged "
"in Python 3 as the locale mechanism is very unreliable, it only handles one "
"\"culture\" at a time, and it only works with 8-bit locales.  Unicode "
"matching is already enabled by default in Python 3 for Unicode (str) "
"patterns, and it is able to handle different locales/languages."
msgstr ""
"Локали — это функция библиотеки C, предназначенная для помощи в написании "
"программ, учитывающих языковые различия. Например, если вы обрабатываете "
"закодированный текст на французском языке, вы хотели бы иметь возможность "
"писать ``\\w+`` для сопоставления слов, но ``\\w`` соответствует только "
"классу символов ``[A-Za- z]`` в шаблонах байтов; он не будет соответствовать "
"байтам, соответствующим ``é`` или ``ç``. Если ваша система настроена "
"правильно и выбрана французская локаль, некоторые функции C сообщат "
"программе, что байт, соответствующий ``é``, также следует считать буквой. "
"Установка флага :const:`LOCALE` при компиляции регулярного выражения "
"приведет к тому, что результирующий скомпилированный объект будет "
"использовать эти функции C для ``\\w``; это медленнее, но также позволяет "
"``\\w+`` соответствовать французским словам, как и следовало ожидать. "
"Использование этого флага не рекомендуется в Python 3, поскольку механизм "
"локали очень ненадежен, он обрабатывает только одну «культуру» за раз и "
"работает только с 8-битными локалями. Сопоставление Юникода уже включено по "
"умолчанию в Python 3 для шаблонов Юникода (str) и может обрабатывать "
"различные локали/языки."

#: ../../howto/regex.rst:610
msgid ""
"(``^`` and ``$`` haven't been explained yet;  they'll be introduced in "
"section :ref:`more-metacharacters`.)"
msgstr ""
"(``^`` и ``$`` еще не объяснены; они будут представлены в разделе :ref:`more-"
"metacharacters`.)"

#: ../../howto/regex.rst:613
msgid ""
"Usually ``^`` matches only at the beginning of the string, and ``$`` matches "
"only at the end of the string and immediately before the newline (if any) at "
"the end of the string. When this flag is specified, ``^`` matches at the "
"beginning of the string and at the beginning of each line within the string, "
"immediately following each newline.  Similarly, the ``$`` metacharacter "
"matches either at the end of the string and at the end of each line "
"(immediately preceding each newline)."
msgstr ""
"Обычно ``^`` соответствует только началу строки, а ``$`` соответствует "
"только концу строки и непосредственно перед символом новой строки (если "
"таковой имеется) в конце строки. Если указан этот флаг, ``^`` соответствует "
"началу строки и началу каждой строки внутри строки, сразу после каждой новой "
"строки. Аналогично, метасимвол ``$`` соответствует либо в конце строки, либо "
"в конце каждой строки (непосредственно перед каждой новой строкой)."

#: ../../howto/regex.rst:626
msgid ""
"Makes the ``'.'`` special character match any character at all, including a "
"newline; without this flag, ``'.'`` will match anything *except* a newline."
msgstr ""
"Делает специальный символ ``'.'`` соответствующим любому символу, включая "
"новую строку; без этого флага ``'.'`` будет соответствовать всему, *кроме* "
"новой строки."

#: ../../howto/regex.rst:634
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\s`` and ``\\S`` perform ASCII-"
"only matching instead of full Unicode matching. This is only meaningful for "
"Unicode patterns, and is ignored for byte patterns."
msgstr ""
"Заставить ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\s`` и ``\\S`` выполнять "
"сопоставление только в формате ASCII вместо полного Соответствие Юникода. "
"Это имеет смысл только для шаблонов Юникода и игнорируется для байтовых "
"шаблонов."

#: ../../howto/regex.rst:643
msgid ""
"This flag allows you to write regular expressions that are more readable by "
"granting you more flexibility in how you can format them.  When this flag "
"has been specified, whitespace within the RE string is ignored, except when "
"the whitespace is in a character class or preceded by an unescaped "
"backslash; this lets you organize and indent the RE more clearly.  This flag "
"also lets you put comments within a RE that will be ignored by the engine; "
"comments are marked by a ``'#'`` that's neither in a character class or "
"preceded by an unescaped backslash."
msgstr ""
"Этот флаг позволяет вам писать регулярные выражения, которые более "
"читабельны, предоставляя вам большую гибкость в их форматировании. Если "
"указан этот флаг, пробелы в строке RE игнорируются, за исключением случаев, "
"когда пробелы находятся в классе символов или им предшествует "
"неэкранированная обратная косая черта; это позволяет более четко "
"организовать и отступить от RE. Этот флаг также позволяет вам помещать "
"комментарии в RE, которые будут игнорироваться движком; комментарии "
"помечаются символом ``'#'``, который не принадлежит классу символов и "
"которому не предшествует неэкранированная обратная косая черта."

#: ../../howto/regex.rst:652
msgid ""
"For example, here's a RE that uses :const:`re.VERBOSE`; see how much easier "
"it is to read? ::"
msgstr ""
"Например, вот RE, который использует :const:`re.VERBOSE`; видите, насколько "
"легче читать? ::"

#: ../../howto/regex.rst:665
msgid "Without the verbose setting, the RE would look like this::"
msgstr "Без подробной настройки RE выглядело бы так:"

#: ../../howto/regex.rst:671
msgid ""
"In the above example, Python's automatic concatenation of string literals "
"has been used to break up the RE into smaller pieces, but it's still more "
"difficult to understand than the version using :const:`re.VERBOSE`."
msgstr ""
"В приведенном выше примере для разбиения RE на более мелкие части "
"использовалась автоматическая конкатенация строковых литералов Python, но ее "
"все равно сложнее понять, чем версию, использующую :const:`re.VERBOSE`."

#: ../../howto/regex.rst:677
msgid "More Pattern Power"
msgstr "Больше силы паттерна"

#: ../../howto/regex.rst:679
msgid ""
"So far we've only covered a part of the features of regular expressions.  In "
"this section, we'll cover some new metacharacters, and how to use groups to "
"retrieve portions of the text that was matched."
msgstr ""
"До сих пор мы рассмотрели лишь часть возможностей регулярных выражений. В "
"этом разделе мы рассмотрим некоторые новые метасимволы и способы "
"использования групп для извлечения частей совпавшего текста."

#: ../../howto/regex.rst:687
msgid "More Metacharacters"
msgstr "Больше метасимволов"

#: ../../howto/regex.rst:689
msgid ""
"There are some metacharacters that we haven't covered yet.  Most of them "
"will be covered in this section."
msgstr ""
"Есть некоторые метасимволы, которые мы еще не рассмотрели. Большинство из "
"них будут рассмотрены в этом разделе."

#: ../../howto/regex.rst:692
msgid ""
"Some of the remaining metacharacters to be discussed are :dfn:`zero-width "
"assertions`.  They don't cause the engine to advance through the string; "
"instead, they consume no characters at all, and simply succeed or fail.  For "
"example, ``\\b`` is an assertion that the current position is located at a "
"word boundary; the position isn't changed by the ``\\b`` at all.  This means "
"that zero-width assertions should never be repeated, because if they match "
"once at a given location, they can obviously be matched an infinite number "
"of times."
msgstr ""
"Некоторые из оставшихся метасимволов, которые предстоит обсудить, — это :dfn:"
"`утверждения нулевой ширины`. Они не заставляют двигатель продвигаться по "
"струне; вместо этого они вообще не используют символы и просто добиваются "
"успеха или терпят неудачу. Например, ``\\b`` — это утверждение, что текущая "
"позиция находится на границе слова; позиция вообще не меняется с помощью "
"``\\b``. Это означает, что утверждения нулевой ширины никогда не должны "
"повторяться, потому что, если они совпадают один раз в заданном месте, "
"очевидно, что они могут быть сопоставлены бесконечное количество раз."

#: ../../howto/regex.rst:708
msgid "``|``"
msgstr "``|``"

#: ../../howto/regex.rst:701
msgid ""
"Alternation, or the \"or\" operator.   If *A* and *B* are regular "
"expressions, ``A|B`` will match any string that matches either *A* or *B*. "
"``|`` has very low precedence in order to make it work reasonably when "
"you're alternating multi-character strings. ``Crow|Servo`` will match either "
"``'Crow'`` or ``'Servo'``, not ``'Cro'``, a ``'w'`` or an ``'S'``, and "
"``'ervo'``."
msgstr ""
"Чередование, или оператор «или». Если *A* и *B* являются регулярными "
"выражениями, ``A|B`` будет соответствовать любой строке, соответствующей "
"либо *A*, либо *B*. ``|`` имеет очень низкий приоритет, чтобы обеспечить его "
"разумную работу при чередовании многосимвольных строк. ``Crow|Servo`` будет "
"соответствовать либо ``'Crow'``, либо ``'Servo'``, но не ``'Cro'``, ``'w'`` "
"или ``'S'. `` и ``'эрво'``."

#: ../../howto/regex.rst:707
msgid ""
"To match a literal ``'|'``, use ``\\|``, or enclose it inside a character "
"class, as in ``[|]``."
msgstr ""
"Чтобы сопоставить литерал ``'|'``, используйте ``\\|`` или заключите его в "
"класс символов, как в ``[|]``."

#: ../../howto/regex.rst:723
msgid "``^``"
msgstr "``^``"

#: ../../howto/regex.rst:711
msgid ""
"Matches at the beginning of lines.  Unless the :const:`MULTILINE` flag has "
"been set, this will only match at the beginning of the string.  In :const:"
"`MULTILINE` mode, this also matches immediately after each newline within "
"the string."
msgstr ""
"Совпадения в начале строк. Если не установлен флаг :const:`MULTILINE`, он "
"будет соответствовать только началу строки. В режиме :const:`MULTILINE` это "
"также соответствует сразу после каждой новой строки в строке."

#: ../../howto/regex.rst:715
msgid ""
"For example, if you wish to match the word ``From`` only at the beginning of "
"a line, the RE to use is ``^From``. ::"
msgstr ""
"Например, если вы хотите, чтобы слово «From» соответствовало только началу "
"строки, используйте RE — «^From». ::"

#: ../../howto/regex.rst:723
msgid "To match a literal ``'^'``, use ``\\^``."
msgstr "Чтобы сопоставить литерал ``'^'``, используйте ``\\^``."

#: ../../howto/regex.rst:737
msgid "``$``"
msgstr "``$``"

#: ../../howto/regex.rst:726
msgid ""
"Matches at the end of a line, which is defined as either the end of the "
"string, or any location followed by a newline character.     ::"
msgstr ""
"Соответствует концу строки, которая определяется как конец строки или любое "
"место, за которым следует символ новой строки. ::"

#: ../../howto/regex.rst:736
msgid ""
"To match a literal ``'$'``, use ``\\$`` or enclose it inside a character "
"class, as in  ``[$]``."
msgstr ""
"Чтобы сопоставить литерал ``'$'``, используйте ``\\$`` или заключите его в "
"класс символов, как в ``[$]``."

#: ../../howto/regex.rst:743
msgid "``\\A``"
msgstr "``\\A``"

#: ../../howto/regex.rst:740
msgid ""
"Matches only at the start of the string.  When not in :const:`MULTILINE` "
"mode, ``\\A`` and ``^`` are effectively the same.  In :const:`MULTILINE` "
"mode, they're different: ``\\A`` still matches only at the beginning of the "
"string, but ``^`` may match at any location inside the string that follows a "
"newline character."
msgstr ""
"Соответствует только началу строки. Если режим не :const:`MULTILINE`, "
"``\\A`` и ``^`` фактически одинаковы. В режиме :const:`MULTILINE` они "
"отличаются: ``\\A`` по-прежнему соответствует только началу строки, но ``^`` "
"может соответствовать любому месту внутри строки, следующему за символом "
"новой строки."

#: ../../howto/regex.rst:746
msgid "``\\Z``"
msgstr "``\\Z``"

#: ../../howto/regex.rst:746
msgid "Matches only at the end of the string."
msgstr "Соответствует только концу строки."

#: ../../howto/regex.rst:781
msgid "``\\b``"
msgstr "``\\b``"

#: ../../howto/regex.rst:749
msgid ""
"Word boundary.  This is a zero-width assertion that matches only at the "
"beginning or end of a word.  A word is defined as a sequence of alphanumeric "
"characters, so the end of a word is indicated by whitespace or a non-"
"alphanumeric character."
msgstr ""
"Граница слова. Это утверждение нулевой ширины, которое соответствует только "
"началу или концу слова. Слово определяется как последовательность буквенно-"
"цифровых символов, поэтому конец слова обозначается пробелом или небуквенно-"
"цифровым символом."

#: ../../howto/regex.rst:754
msgid ""
"The following example matches ``class`` only when it's a complete word; it "
"won't match when it's contained inside another word. ::"
msgstr ""
"Следующий пример соответствует ``class`` только тогда, когда это полное "
"слово; оно не будет совпадать, если оно содержится внутри другого слова. ::"

#: ../../howto/regex.rst:765
msgid ""
"There are two subtleties you should remember when using this special "
"sequence. First, this is the worst collision between Python's string "
"literals and regular expression sequences.  In Python's string literals, "
"``\\b`` is the backspace character, ASCII value 8.  If you're not using raw "
"strings, then Python will convert the ``\\b`` to a backspace, and your RE "
"won't match as you expect it to. The following example looks the same as our "
"previous RE, but omits the ``'r'`` in front of the RE string. ::"
msgstr ""
"При использовании этой специальной последовательности следует помнить две "
"тонкости. Во-первых, это худшее противоречие между строковыми литералами "
"Python и последовательностями регулярных выражений. В строковых литералах "
"Python ``\\b`` — это символ возврата, значение ASCII 8. Если вы не "
"используете необработанные строки, Python преобразует ``\\b`` в обратный "
"пробел, и ваш RE не будет соответствует вашим ожиданиям. Следующий пример "
"выглядит так же, как наш предыдущий RE, но в нем отсутствует ``'r'`` перед "
"строкой RE. ::"

#: ../../howto/regex.rst:779
msgid ""
"Second, inside a character class, where there's no use for this assertion, "
"``\\b`` represents the backspace character, for compatibility with Python's "
"string literals."
msgstr ""
"Во-вторых, внутри класса символов, где это утверждение бесполезно, ``\\b`` "
"представляет собой символ обратного пространства для совместимости со "
"строковыми литералами Python."

#: ../../howto/regex.rst:786
msgid "``\\B``"
msgstr "``\\B``"

#: ../../howto/regex.rst:784
msgid ""
"Another zero-width assertion, this is the opposite of ``\\b``, only matching "
"when the current position is not at a word boundary."
msgstr ""
"Другое утверждение нулевой ширины, противоположное ``\\b``, совпадает только "
"тогда, когда текущая позиция не находится на границе слова."

#: ../../howto/regex.rst:789
msgid "Grouping"
msgstr "Группировка"

#: ../../howto/regex.rst:791
msgid ""
"Frequently you need to obtain more information than just whether the RE "
"matched or not.  Regular expressions are often used to dissect strings by "
"writing a RE divided into several subgroups which match different components "
"of interest. For example, an RFC-822 header line is divided into a header "
"name and a value, separated by a ``':'``, like this:"
msgstr ""
"Часто вам нужно получить больше информации, чем просто о том, совпадают "
"данные или нет. Регулярные выражения часто используются для разделения строк "
"путем записи данных, разделенных на несколько подгрупп, которые "
"соответствуют различным интересующим компонентам. Например, строка заголовка "
"RFC-822 разделена на имя заголовка и значение, разделенные символом ``':'``, "
"вот так:"

#: ../../howto/regex.rst:804
msgid ""
"This can be handled by writing a regular expression which matches an entire "
"header line, and has one group which matches the header name, and another "
"group which matches the header's value."
msgstr ""
"Это можно решить, написав регулярное выражение, которое соответствует всей "
"строке заголовка и содержит одну группу, соответствующую имени заголовка, и "
"другую группу, соответствующую значению заголовка."

#: ../../howto/regex.rst:808
msgid ""
"Groups are marked by the ``'('``, ``')'`` metacharacters. ``'('`` and "
"``')'`` have much the same meaning as they do in mathematical expressions; "
"they group together the expressions contained inside them, and you can "
"repeat the contents of a group with a quantifier, such as ``*``, ``+``, ``?"
"``, or ``{m,n}``.  For example, ``(ab)*`` will match zero or more "
"repetitions of ``ab``. ::"
msgstr ""
"Группы отмечаются метасимволами ``'('``, ``')'``. ``'('`` и ``')'`` имеют "
"почти то же значение, что и в математических выражениях; они группируют "
"содержащиеся внутри них выражения, и вы можете повторять содержимое группы с "
"помощью квантора, например ``*``, ``+``, ``?`` или ``{m,n} ``. Например, "
"``(ab)*`` будет соответствовать нулю или более повторений ``ab``. ::"

#: ../../howto/regex.rst:819
msgid ""
"Groups indicated with ``'('``, ``')'`` also capture the starting and ending "
"index of the text that they match; this can be retrieved by passing an "
"argument to :meth:`~re.Match.group`, :meth:`~re.Match.start`, :meth:`~re."
"Match.end`, and :meth:`~re.Match.span`.  Groups are numbered starting with "
"0.  Group 0 is always present; it's the whole RE, so :ref:`match object "
"<match-objects>` methods all have group 0 as their default argument.  Later "
"we'll see how to express groups that don't capture the span of text that "
"they match. ::"
msgstr ""
"Группы, обозначенные ``'('``, ``')'``, также фиксируют начальный и конечный "
"индекс текста, которому они соответствуют; его можно получить, передав "
"аргумент :meth:`~re.Match.group`, :meth:`~re.Match.start`, :meth:`~re.Match."
"end` и :meth:` ~re.Match.span`. Группы нумеруются начиная с 0. Группа 0 "
"присутствует всегда; это весь RE, поэтому все методы match object <match-"
"objects> имеют группу 0 в качестве аргумента по умолчанию. Позже мы увидим, "
"как выражать группы, которые не охватывают тот фрагмент текста, которому они "
"соответствуют. ::"

#: ../../howto/regex.rst:835
msgid ""
"Subgroups are numbered from left to right, from 1 upward.  Groups can be "
"nested; to determine the number, just count the opening parenthesis "
"characters, going from left to right. ::"
msgstr ""
"Подгруппы нумеруются слева направо, от 1 вверх. Группы могут быть "
"вложенными; Чтобы определить число, просто посчитайте символы открывающих "
"круглых скобок слева направо. ::"

#: ../../howto/regex.rst:848
msgid ""
":meth:`~re.Match.group` can be passed multiple group numbers at a time, in "
"which case it will return a tuple containing the corresponding values for "
"those groups. ::"
msgstr ""
":meth:`~re.Match.group` может передавать несколько номеров групп "
"одновременно, и в этом случае он вернет кортеж, содержащий соответствующие "
"значения для этих групп. ::"

#: ../../howto/regex.rst:854
msgid ""
"The :meth:`~re.Match.groups` method returns a tuple containing the strings "
"for all the subgroups, from 1 up to however many there are. ::"
msgstr ""
"Метод :meth:`~re.Match.groups` возвращает кортеж, содержащий строки для всех "
"подгрупп, от 1 до любого их количества. ::"

#: ../../howto/regex.rst:860
msgid ""
"Backreferences in a pattern allow you to specify that the contents of an "
"earlier capturing group must also be found at the current location in the "
"string.  For example, ``\\1`` will succeed if the exact contents of group 1 "
"can be found at the current position, and fails otherwise.  Remember that "
"Python's string literals also use a backslash followed by numbers to allow "
"including arbitrary characters in a string, so be sure to use a raw string "
"when incorporating backreferences in a RE."
msgstr ""
"Обратные ссылки в шаблоне позволяют указать, что содержимое более ранней "
"группы захвата также должно быть найдено в текущем месте строки. Например, "
"``\\1`` завершится успешно, если точное содержимое группы 1 можно найти в "
"текущей позиции, и завершится неудачей в противном случае. Помните, что "
"строковые литералы Python также используют обратную косую черту, за которой "
"следуют цифры, чтобы разрешить включение произвольных символов в строку, "
"поэтому обязательно используйте необработанную строку при включении обратных "
"ссылок в RE."

#: ../../howto/regex.rst:868
msgid "For example, the following RE detects doubled words in a string. ::"
msgstr "Например, следующий RE обнаруживает удвоенные слова в строке. ::"

#: ../../howto/regex.rst:874
msgid ""
"Backreferences like this aren't often useful for just searching through a "
"string --- there are few text formats which repeat data in this way --- but "
"you'll soon find out that they're *very* useful when performing string "
"substitutions."
msgstr ""
"Обратные ссылки, подобные этой, не часто полезны для простого поиска по "
"строке --- существует несколько текстовых форматов, которые повторяют данные "
"таким образом --- но вы скоро обнаружите, что они *очень* полезны при "
"выполнении строковых замен. ."

#: ../../howto/regex.rst:880
msgid "Non-capturing and Named Groups"
msgstr "Незахватывающие и именованные группы"

#: ../../howto/regex.rst:882
msgid ""
"Elaborate REs may use many groups, both to capture substrings of interest, "
"and to group and structure the RE itself.  In complex REs, it becomes "
"difficult to keep track of the group numbers.  There are two features which "
"help with this problem.  Both of them use a common syntax for regular "
"expression extensions, so we'll look at that first."
msgstr ""
"Сложные RE могут использовать множество групп как для захвата интересующих "
"подстрок, так и для группировки и структурирования самого RE. В сложных RE "
"становится сложно отслеживать номера групп. Есть две функции, которые "
"помогают решить эту проблему. Оба они используют общий синтаксис для "
"расширений регулярных выражений, поэтому сначала мы рассмотрим его."

#: ../../howto/regex.rst:888
msgid ""
"Perl 5 is well known for its powerful additions to standard regular "
"expressions. For these new features the Perl developers couldn't choose new "
"single-keystroke metacharacters or new special sequences beginning with "
"``\\`` without making Perl's regular expressions confusingly different from "
"standard REs.  If they chose ``&`` as a new metacharacter, for example, old "
"expressions would be assuming that ``&`` was a regular character and "
"wouldn't have escaped it by writing ``\\&`` or ``[&]``."
msgstr ""
"Perl 5 хорошо известен своими мощными дополнениями к стандартным регулярным "
"выражениям. Для этих новых функций разработчики Perl не могли выбирать новые "
"метасимволы, нажимаемые одной клавишей, или новые специальные "
"последовательности, начинающиеся с ``\\``, не делая регулярные выражения "
"Perl неотличимыми от стандартных RE. Например, если бы они выбрали ``&`` в "
"качестве нового метасимвола, старые выражения предполагали бы, что ``&`` был "
"обычным символом и не экранировал бы его, написав ``\\&`` или ``[ &]``."

#: ../../howto/regex.rst:895
msgid ""
"The solution chosen by the Perl developers was to use ``(?...)`` as the "
"extension syntax.  ``?`` immediately after a parenthesis was a syntax error "
"because the ``?`` would have nothing to repeat, so this didn't introduce any "
"compatibility problems.  The characters immediately after the ``?``  "
"indicate what extension is being used, so ``(?=foo)`` is one thing (a "
"positive lookahead assertion) and ``(?:foo)`` is something else (a non-"
"capturing group containing the subexpression ``foo``)."
msgstr ""
"Решением, выбранным разработчиками Perl, было использование ``(?...)`` в "
"качестве синтаксиса расширения. ``?`` сразу после скобки было синтаксической "
"ошибкой, поскольку ``?`` нечего было бы повторять, поэтому это не создавало "
"никаких проблем совместимости. Символы сразу после ``?`` указывают, какое "
"расширение используется, поэтому ``(?=foo)`` — это одно (утверждение "
"положительного просмотра вперед), а ``(?:foo)`` — это что-то другое ( группа "
"без захвата, содержащая подвыражение ``foo``)."

#: ../../howto/regex.rst:903
msgid ""
"Python supports several of Perl's extensions and adds an extension syntax to "
"Perl's extension syntax.  If the first character after the question mark is "
"a ``P``, you know that it's an extension that's specific to Python."
msgstr ""
"Python поддерживает несколько расширений Perl и добавляет синтаксис "
"расширений к синтаксису расширений Perl. Если первым символом после "
"вопросительного знака является ``P``, вы знаете, что это расширение, "
"специфичное для Python."

#: ../../howto/regex.rst:908
msgid ""
"Now that we've looked at the general extension syntax, we can return to the "
"features that simplify working with groups in complex REs."
msgstr ""
"Теперь, когда мы рассмотрели общий синтаксис расширений, мы можем вернуться "
"к функциям, упрощающим работу с группами в сложных RE."

#: ../../howto/regex.rst:911
msgid ""
"Sometimes you'll want to use a group to denote a part of a regular "
"expression, but aren't interested in retrieving the group's contents. You "
"can make this fact explicit by using a non-capturing group: ``(?:...)``, "
"where you can replace the ``...`` with any other regular expression. ::"
msgstr ""
"Иногда вам нужно использовать группу для обозначения части регулярного "
"выражения, но вы не заинтересованы в получении содержимого группы. Вы можете "
"сделать этот факт явным, используя группу без захвата: ``(?:...)``, где вы "
"можете заменить ``...`` любым другим регулярным выражением. ::"

#: ../../howto/regex.rst:923
msgid ""
"Except for the fact that you can't retrieve the contents of what the group "
"matched, a non-capturing group behaves exactly the same as a capturing "
"group; you can put anything inside it, repeat it with a repetition "
"metacharacter such as ``*``, and nest it within other groups (capturing or "
"non-capturing). ``(?:...)`` is particularly useful when modifying an "
"existing pattern, since you can add new groups without changing how all the "
"other groups are numbered.  It should be mentioned that there's no "
"performance difference in searching between capturing and non-capturing "
"groups; neither form is any faster than the other."
msgstr ""
"За исключением того факта, что вы не можете получить содержимое того, что "
"соответствует группе, группа без захвата ведет себя точно так же, как группа "
"захвата; вы можете поместить внутрь него что угодно, повторить это с помощью "
"метасимвола повторения, такого как ``*``, и вложить это в другие группы (с "
"захватом или без захвата). ``(?:...)`` особенно полезен при изменении "
"существующего шаблона, поскольку вы можете добавлять новые группы, не меняя "
"нумерацию всех остальных групп. Следует отметить, что нет никакой разницы в "
"производительности при поиске между захватывающими и не захватывающими "
"группами; ни одна из форм не быстрее другой."

#: ../../howto/regex.rst:932
msgid ""
"A more significant feature is named groups: instead of referring to them by "
"numbers, groups can be referenced by a name."
msgstr ""
"Более важной особенностью являются именованные группы: вместо обращения к "
"ним по номерам на группы можно ссылаться по имени."

#: ../../howto/regex.rst:935
msgid ""
"The syntax for a named group is one of the Python-specific extensions: ``(?"
"P<name>...)``.  *name* is, obviously, the name of the group.  Named groups "
"behave exactly like capturing groups, and additionally associate a name with "
"a group.  The :ref:`match object <match-objects>` methods that deal with "
"capturing groups all accept either integers that refer to the group by "
"number or strings that contain the desired group's name.  Named groups are "
"still given numbers, so you can retrieve information about a group in two "
"ways::"
msgstr ""
"Синтаксис именованной группы — это одно из специфичных для Python "
"расширений: ``(?P<name>...)``. *name* — это, очевидно, название группы. "
"Именованные группы ведут себя точно так же, как группы записи, и "
"дополнительно связывают имя с группой. Все методы :ref:`match object <match-"
"objects>`, которые занимаются захватом групп, принимают либо целые числа, "
"ссылающиеся на группу по номеру, либо строки, содержащие имя нужной группы. "
"Именованным группам по-прежнему присваиваются номера, поэтому информацию о "
"группе можно получить двумя способами:"

#: ../../howto/regex.rst:950
msgid ""
"Additionally, you can retrieve named groups as a dictionary with :meth:`~re."
"Match.groupdict`::"
msgstr ""
"Кроме того, вы можете получить именованные группы в виде словаря с помощью :"
"meth:`~re.Match.groupdict`::"

#: ../../howto/regex.rst:957
msgid ""
"Named groups are handy because they let you use easily remembered names, "
"instead of having to remember numbers.  Here's an example RE from the :mod:"
"`imaplib` module::"
msgstr ""
"Именованные группы удобны, поскольку позволяют использовать легко "
"запоминающиеся имена вместо необходимости запоминать числа. Вот пример RE из "
"модуля :mod:`imaplib`::"

#: ../../howto/regex.rst:968
msgid ""
"It's obviously much easier to retrieve ``m.group('zonem')``, instead of "
"having to remember to retrieve group 9."
msgstr ""
"Очевидно, гораздо проще получить ``m.group('zonem')`` вместо того, чтобы "
"помнить о получении группы 9."

#: ../../howto/regex.rst:971
msgid ""
"The syntax for backreferences in an expression such as ``(...)\\1`` refers "
"to the number of the group.  There's naturally a variant that uses the group "
"name instead of the number. This is another Python extension: ``(?P=name)`` "
"indicates that the contents of the group called *name* should again be "
"matched at the current point.  The regular expression for finding doubled "
"words, ``\\b(\\w+)\\s+\\1\\b`` can also be written as ``\\b(?"
"P<word>\\w+)\\s+(?P=word)\\b``::"
msgstr ""
"Синтаксис обратных ссылок в таких выражениях, как ``(...)\\1``, относится к "
"номеру группы. Естественно, существует вариант, в котором вместо номера "
"используется имя группы. Это еще одно расширение Python: ``(?P=name)`` "
"указывает, что содержимое группы с именем *name* должно снова сопоставляться "
"в текущей точке. Регулярное выражение для поиска удвоенных слов "
"``\\b(\\w+)\\s+\\1\\b`` также можно записать как ``\\b(?P<word>\\w+)\\s+(?"
"P=word) \\b``::"

#: ../../howto/regex.rst:984
msgid "Lookahead Assertions"
msgstr "Предварительные утверждения"

#: ../../howto/regex.rst:986
msgid ""
"Another zero-width assertion is the lookahead assertion.  Lookahead "
"assertions are available in both positive and negative form, and  look like "
"this:"
msgstr ""
"Еще одно утверждение нулевой ширины — это утверждение просмотра вперед. "
"Утверждения опережающего просмотра доступны как в положительной, так и в "
"отрицательной форме и выглядят следующим образом:"

#: ../../howto/regex.rst:994
msgid "``(?=...)``"
msgstr "``(?=...)``"

#: ../../howto/regex.rst:990
msgid ""
"Positive lookahead assertion.  This succeeds if the contained regular "
"expression, represented here by ``...``, successfully matches at the current "
"location, and fails otherwise. But, once the contained expression has been "
"tried, the matching engine doesn't advance at all; the rest of the pattern "
"is tried right where the assertion started."
msgstr ""
"Позитивное прогнозное утверждение. Это завершается успешно, если "
"содержащееся в нем регулярное выражение, представленное здесь ``...``, "
"успешно соответствует текущему местоположению, а в противном случае терпит "
"неудачу. Но как только содержащееся выражение было опробовано, механизм "
"сопоставления вообще не продвигается вперед; остальная часть шаблона "
"проверяется прямо с того места, где началось утверждение."

#: ../../howto/regex.rst:999
msgid "``(?!...)``"
msgstr "``(?!...)``"

#: ../../howto/regex.rst:997
msgid ""
"Negative lookahead assertion.  This is the opposite of the positive "
"assertion; it succeeds if the contained expression *doesn't* match at the "
"current position in the string."
msgstr ""
"Утверждение отрицательного прогнозирования. Это противоположность "
"положительному утверждению; он успешен, если содержащееся выражение *не* "
"соответствует текущей позиции в строке."

#: ../../howto/regex.rst:1001
msgid ""
"To make this concrete, let's look at a case where a lookahead is useful. "
"Consider a simple pattern to match a filename and split it apart into a base "
"name and an extension, separated by a ``.``.  For example, in ``news.rc``, "
"``news`` is the base name, and ``rc`` is the filename's extension."
msgstr ""
"Чтобы прояснить это, давайте рассмотрим случай, когда просмотр вперед "
"полезен. Рассмотрим простой шаблон для сопоставления имени файла и "
"разделения его на базовое имя и расширение, разделенные символом ``.``. "
"Например, в файле news.rc, news — это базовое имя, а rc — расширение имени "
"файла."

#: ../../howto/regex.rst:1006
msgid "The pattern to match this is quite simple:"
msgstr "Шаблон, соответствующий этому, довольно прост:"

#: ../../howto/regex.rst:1008
msgid "``.*[.].*$``"
msgstr "``.*[.].*$``"

#: ../../howto/regex.rst:1010
msgid ""
"Notice that the ``.`` needs to be treated specially because it's a "
"metacharacter, so it's inside a character class to only match that specific "
"character.  Also notice the trailing ``$``; this is added to ensure that all "
"the rest of the string must be included in the extension.  This regular "
"expression matches ``foo.bar`` and ``autoexec.bat`` and ``sendmail.cf`` and "
"``printers.conf``."
msgstr ""
"Обратите внимание, что ``.`` требует особого обращения, поскольку это "
"метасимвол, поэтому он находится внутри класса символов и соответствует "
"только этому конкретному символу. Также обратите внимание на завершающий "
"``$``; это добавляется для того, чтобы гарантировать, что вся остальная "
"часть строки должна быть включена в расширение. Это регулярное выражение "
"соответствует ``foo.bar``, ``autoexec.bat``, ``sendmail.cf`` и ``printers."
"conf``."

#: ../../howto/regex.rst:1017
msgid ""
"Now, consider complicating the problem a bit; what if you want to match "
"filenames where the extension is not ``bat``? Some incorrect attempts:"
msgstr ""
"Теперь давайте немного усложним задачу; что, если вы хотите сопоставить "
"имена файлов с расширением, отличным от «bat»? Некоторые неправильные "
"попытки:"

#: ../../howto/regex.rst:1020
msgid ""
"``.*[.][^b].*$``  The first attempt above tries to exclude ``bat`` by "
"requiring that the first character of the extension is not a ``b``.  This is "
"wrong, because the pattern also doesn't match ``foo.bar``."
msgstr ""
"``.*[.][^b].*$`` Первая попытка выше пытается исключить ``bat``, требуя, "
"чтобы первый символ расширения не был ``b``. Это неправильно, потому что "
"шаблон также не соответствует ``foo.bar``."

#: ../../howto/regex.rst:1024
msgid "``.*[.]([^b]..|.[^a].|..[^t])$``"
msgstr "``.*[.]([^b]..|.[^a].|..[^t])$``"

#: ../../howto/regex.rst:1026
msgid ""
"The expression gets messier when you try to patch up the first solution by "
"requiring one of the following cases to match: the first character of the "
"extension isn't ``b``; the second character isn't ``a``; or the third "
"character isn't ``t``.  This accepts ``foo.bar`` and rejects ``autoexec."
"bat``, but it requires a three-letter extension and won't accept a filename "
"with a two-letter extension such as ``sendmail.cf``.  We'll complicate the "
"pattern again in an effort to fix it."
msgstr ""
"Выражение становится более запутанным, когда вы пытаетесь исправить первое "
"решение, требуя совпадения одного из следующих случаев: первый символ "
"расширения не ``b``; второй символ не ``а``; или третий символ не ``t``. Он "
"принимает ``foo.bar`` и отклоняет ``autoexec.bat``, но требует "
"трехбуквенного расширения и не принимает имя файла с двухбуквенным "
"расширением, например ``sendmail.cf``. Мы снова усложним узор, пытаясь его "
"исправить."

#: ../../howto/regex.rst:1034
msgid "``.*[.]([^b].?.?|.[^a]?.?|..?[^t]?)$``"
msgstr "``.*[.]([^b].?.?|.[^a]?.?|..?[^t]?)$``"

#: ../../howto/regex.rst:1036
msgid ""
"In the third attempt, the second and third letters are all made optional in "
"order to allow matching extensions shorter than three characters, such as "
"``sendmail.cf``."
msgstr ""
"В третьей попытке вторая и третья буквы становятся необязательными, чтобы "
"обеспечить соответствие расширениям короче трех символов, например sendmail."
"cf."

#: ../../howto/regex.rst:1040
msgid ""
"The pattern's getting really complicated now, which makes it hard to read "
"and understand.  Worse, if the problem changes and you want to exclude both "
"``bat`` and ``exe`` as extensions, the pattern would get even more "
"complicated and confusing."
msgstr ""
"Теперь узор становится очень сложным, что затрудняет его чтение и понимание. "
"Хуже того, если проблема изменится и вы захотите исключить как расширения "
"«bat», так и «exe», шаблон станет еще более сложным и запутанным."

#: ../../howto/regex.rst:1045
msgid "A negative lookahead cuts through all this confusion:"
msgstr "Отрицательный прогноз устраняет всю эту путаницу:"

#: ../../howto/regex.rst:1047
msgid ""
"``.*[.](?!bat$)[^.]*$``  The negative lookahead means: if the expression "
"``bat`` doesn't match at this point, try the rest of the pattern; if "
"``bat$`` does match, the whole pattern will fail.  The trailing ``$`` is "
"required to ensure that something like ``sample.batch``, where the extension "
"only starts with ``bat``, will be allowed.  The ``[^.]*`` makes sure that "
"the pattern works when there are multiple dots in the filename."
msgstr ""
"``.*[.](?!bat$)[^.]*$`` Отрицательный просмотр вперед означает: если "
"выражение ``bat`` не соответствует в этот момент, попробуйте остальную часть "
"шаблона; если ``bat$`` соответствует, весь шаблон потерпит неудачу. "
"Завершающий ``$`` необходим для того, чтобы гарантировать, что будет "
"разрешено что-то вроде ``sample.batch``, где расширение начинается только с "
"``bat``. ``[^.]*`` гарантирует, что шаблон работает, когда в имени файла "
"есть несколько точек."

#: ../../howto/regex.rst:1054
msgid ""
"Excluding another filename extension is now easy; simply add it as an "
"alternative inside the assertion.  The following pattern excludes filenames "
"that end in either ``bat`` or ``exe``:"
msgstr ""
"Исключить другое расширение имени файла теперь легко; просто добавьте его в "
"качестве альтернативы внутри утверждения. Следующий шаблон исключает имена "
"файлов, оканчивающиеся на ``bat`` или ``exe``:"

#: ../../howto/regex.rst:1058
msgid "``.*[.](?!bat$|exe$)[^.]*$``"
msgstr "``.*[.](?!bat$|exe$)[^.]*$``"

#: ../../howto/regex.rst:1062
msgid "Modifying Strings"
msgstr "Изменение строк"

#: ../../howto/regex.rst:1064
msgid ""
"Up to this point, we've simply performed searches against a static string. "
"Regular expressions are also commonly used to modify strings in various "
"ways, using the following pattern methods:"
msgstr ""
"До этого момента мы просто выполняли поиск по статической строке. Регулярные "
"выражения также часто используются для изменения строк различными способами "
"с использованием следующих методов шаблона:"

#: ../../howto/regex.rst:1071
msgid "``split()``"
msgstr "``split()``"

#: ../../howto/regex.rst:1071
msgid "Split the string into a list, splitting it wherever the RE matches"
msgstr "Разделите строку на список, разделив его там, где соответствует RE."

#: ../../howto/regex.rst:1074
msgid "``sub()``"
msgstr "``sub()``"

#: ../../howto/regex.rst:1074
msgid ""
"Find all substrings where the RE matches, and replace them with a different "
"string"
msgstr ""
"Найдите все подстроки, которым соответствует RE, и замените их другой "
"строкой."

#: ../../howto/regex.rst:1077
msgid "``subn()``"
msgstr "``subn()``"

#: ../../howto/regex.rst:1077
msgid ""
"Does the same thing as :meth:`!sub`,  but returns the new string and the "
"number of replacements"
msgstr ""
"Делает то же самое, что и :meth:`!sub`, но возвращает новую строку и "
"количество замен."

#: ../../howto/regex.rst:1084
msgid "Splitting Strings"
msgstr "Разделение строк"

#: ../../howto/regex.rst:1086
msgid ""
"The :meth:`~re.Pattern.split` method of a pattern splits a string apart "
"wherever the RE matches, returning a list of the pieces. It's similar to "
"the :meth:`~str.split` method of strings but provides much more generality "
"in the delimiters that you can split by; string :meth:`!split` only supports "
"splitting by whitespace or by a fixed string.  As you'd expect, there's a "
"module-level :func:`re.split` function, too."
msgstr ""
"Метод шаблона :meth:`~re.Pattern.split` разбивает строку на части там, где "
"RE соответствует, возвращая список частей. Он похож на метод строк :meth:"
"`~str.split`, но обеспечивает гораздо большую универсальность в "
"разделителях, по которым можно разделить; string :meth:`!split` поддерживает "
"разделение только по пробелам или по фиксированной строке. Как и следовало "
"ожидать, на уровне модуля также имеется функция :func:`re.split`."

#: ../../howto/regex.rst:1097
msgid ""
"Split *string* by the matches of the regular expression.  If capturing "
"parentheses are used in the RE, then their contents will also be returned as "
"part of the resulting list.  If *maxsplit* is nonzero, at most *maxsplit* "
"splits are performed."
msgstr ""
"Разделить *строку* по совпадениям с регулярным выражением. Если в RE "
"используются захватывающие круглые скобки, то их содержимое также будет "
"возвращено как часть результирующего списка. Если *maxsplit* не равно нулю, "
"выполняется не более *maxsplit* разделения."

#: ../../howto/regex.rst:1102
msgid ""
"You can limit the number of splits made, by passing a value for *maxsplit*. "
"When *maxsplit* is nonzero, at most *maxsplit* splits will be made, and the "
"remainder of the string is returned as the final element of the list.  In "
"the following example, the delimiter is any sequence of non-alphanumeric "
"characters. ::"
msgstr ""
"Вы можете ограничить количество разделений, передав значение *maxsplit*. "
"Если *maxsplit* не равно нулю, будет выполнено не более *maxsplit* "
"разбиений, а оставшаяся часть строки будет возвращена как последний элемент "
"списка. В следующем примере разделителем является любая последовательность "
"небуквенно-цифровых символов. ::"

#: ../../howto/regex.rst:1114
msgid ""
"Sometimes you're not only interested in what the text between delimiters is, "
"but also need to know what the delimiter was.  If capturing parentheses are "
"used in the RE, then their values are also returned as part of the list.  "
"Compare the following calls::"
msgstr ""
"Иногда вас не только интересует текст между разделителями, но и нужно знать, "
"что это был за разделитель. Если в RE используются захватывающие круглые "
"скобки, то их значения также возвращаются как часть списка. Сравните "
"следующие вызовы::"

#: ../../howto/regex.rst:1126
msgid ""
"The module-level function :func:`re.split` adds the RE to be used as the "
"first argument, but is otherwise the same.   ::"
msgstr ""
"Функция уровня модуля :func:`re.split` добавляет RE, который будет "
"использоваться в качестве первого аргумента, но в остальном остается тем "
"же. ::"

#: ../../howto/regex.rst:1138
msgid "Search and Replace"
msgstr "Поиск и замена"

#: ../../howto/regex.rst:1140
msgid ""
"Another common task is to find all the matches for a pattern, and replace "
"them with a different string.  The :meth:`~re.Pattern.sub` method takes a "
"replacement value, which can be either a string or a function, and the "
"string to be processed."
msgstr ""
"Другая распространенная задача — найти все совпадения с шаблоном и заменить "
"их другой строкой. Метод :meth:`~re.Pattern.sub` принимает замещающее "
"значение, которое может быть строкой или функцией, а также строку, "
"подлежащую обработке."

#: ../../howto/regex.rst:1147
msgid ""
"Returns the string obtained by replacing the leftmost non-overlapping "
"occurrences of the RE in *string* by the replacement *replacement*.  If the "
"pattern isn't found, *string* is returned unchanged."
msgstr ""
"Возвращает строку, полученную путем замены крайних левых непересекающихся "
"вхождений RE в *string* заменой *replacement*. Если шаблон не найден, "
"*строка* возвращается без изменений."

#: ../../howto/regex.rst:1151
msgid ""
"The optional argument *count* is the maximum number of pattern occurrences "
"to be replaced; *count* must be a non-negative integer.  The default value "
"of 0 means to replace all occurrences."
msgstr ""
"Необязательный аргумент *count* — это максимальное количество вхождений "
"шаблона, которые необходимо заменить; *count* должно быть неотрицательным "
"целым числом. Значение по умолчанию 0 означает замену всех вхождений."

#: ../../howto/regex.rst:1155
msgid ""
"Here's a simple example of using the :meth:`~re.Pattern.sub` method.  It "
"replaces colour names with the word ``colour``::"
msgstr ""
"Вот простой пример использования метода :meth:`~re.Pattern.sub`. Он заменяет "
"названия цветов словом ``color``::"

#: ../../howto/regex.rst:1164
msgid ""
"The :meth:`~re.Pattern.subn` method does the same work, but returns a 2-"
"tuple containing the new string value and the number of replacements  that "
"were performed::"
msgstr ""
"Метод :meth:`~re.Pattern.subn` выполняет ту же работу, но возвращает кортеж "
"из двух элементов, содержащий новое строковое значение и количество "
"выполненных замен:"

#: ../../howto/regex.rst:1173
msgid ""
"Empty matches are replaced only when they're not adjacent to a previous "
"empty match. ::"
msgstr ""
"Пустые совпадения заменяются только в том случае, если они не соседствуют с "
"предыдущим пустым совпадением. ::"

#: ../../howto/regex.rst:1180
msgid ""
"If *replacement* is a string, any backslash escapes in it are processed.  "
"That is, ``\\n`` is converted to a single newline character, ``\\r`` is "
"converted to a carriage return, and so forth. Unknown escapes such as "
"``\\&`` are left alone. Backreferences, such as ``\\6``, are replaced with "
"the substring matched by the corresponding group in the RE.  This lets you "
"incorporate portions of the original text in the resulting replacement "
"string."
msgstr ""
"Если *replacement* является строкой, любые символы обратной косой черты в "
"ней обрабатываются. То есть ``\\n`` преобразуется в один символ новой "
"строки, ``\\r`` преобразуется в возврат каретки и так далее. Неизвестные "
"escape-символы, такие как ``\\&``, остаются в покое. Обратные ссылки, такие "
"как ``\\6``, заменяются подстрокой, соответствующей соответствующей группе в "
"RE. Это позволяет включать части исходного текста в результирующую строку "
"замены."

#: ../../howto/regex.rst:1187
msgid ""
"This example matches the word ``section`` followed by a string enclosed in "
"``{``, ``}``, and changes ``section`` to ``subsection``::"
msgstr ""
"Этот пример соответствует слову ``section``, за которым следует строка, "
"заключенная в ``{``, ``}``, и заменяет ``section`` на ``subsection``::"

#: ../../howto/regex.rst:1194
msgid ""
"There's also a syntax for referring to named groups as defined by the ``(?"
"P<name>...)`` syntax.  ``\\g<name>`` will use the substring matched by the "
"group named ``name``, and  ``\\g<number>``  uses the corresponding group "
"number. ``\\g<2>`` is therefore equivalent to ``\\2``,  but isn't ambiguous "
"in a replacement string such as ``\\g<2>0``.  (``\\20`` would be interpreted "
"as a reference to group 20, not a reference to group 2 followed by the "
"literal character ``'0'``.)  The following substitutions are all equivalent, "
"but use all three variations of the replacement string. ::"
msgstr ""
"Существует также синтаксис для ссылки на именованные группы, определенный "
"синтаксисом ``(?P<name>...)``. ``\\g<name>`` будет использовать подстроку, "
"соответствующую группе с именем ``name``, а ``\\g<number>`` использует "
"соответствующий номер группы. Таким образом, ``\\g<2>`` эквивалентен "
"``\\2``, но не является двусмысленным в строке замены, такой как "
"``\\g<2>0``. (``\\20`` будет интерпретироваться как ссылка на группу 20, а "
"не как ссылка на группу 2, за которой следует буквальный символ ``'0'``.) "
"Все следующие замены эквивалентны, но используют все три варианта строка "
"замены. ::"

#: ../../howto/regex.rst:1211
msgid ""
"*replacement* can also be a function, which gives you even more control.  If "
"*replacement* is a function, the function is called for every non-"
"overlapping occurrence of *pattern*.  On each call, the function is passed "
"a :ref:`match object <match-objects>` argument for the match and can use "
"this information to compute the desired replacement string and return it."
msgstr ""
"*замена* также может быть функцией, которая дает вам еще больше контроля. "
"Если *replacement* является функцией, она вызывается для каждого "
"непересекающегося вхождения *pattern*. При каждом вызове функции передается "
"аргумент :ref:`match object <match-objects>` для соответствия, и она может "
"использовать эту информацию для вычисления желаемой строки замены и ее "
"возврата."

#: ../../howto/regex.rst:1217
msgid ""
"In the following example, the replacement function translates decimals into "
"hexadecimal::"
msgstr ""
"В следующем примере функция замены переводит десятичные числа в "
"шестнадцатеричные:"

#: ../../howto/regex.rst:1229
msgid ""
"When using the module-level :func:`re.sub` function, the pattern is passed "
"as the first argument.  The pattern may be provided as an object or as a "
"string; if you need to specify regular expression flags, you must either use "
"a pattern object as the first parameter, or use embedded modifiers in the "
"pattern string, e.g. ``sub(\"(?i)b+\", \"x\", \"bbbb BBBB\")`` returns ``'x "
"x'``."
msgstr ""
"При использовании функции :func:`re.sub` на уровне модуля шаблон передается "
"в качестве первого аргумента. Шаблон может быть предоставлен как объект или "
"как строка; если вам нужно указать флаги регулярного выражения, вы должны "
"либо использовать объект шаблона в качестве первого параметра, либо "
"использовать встроенные модификаторы в строку шаблона, например, ``sub(\"(?"
"i)b+\", \"x\", \"bbbb BBBB \")`` возвращает ``'x x'``."

#: ../../howto/regex.rst:1237
msgid "Common Problems"
msgstr "Общие проблемы"

#: ../../howto/regex.rst:1239
msgid ""
"Regular expressions are a powerful tool for some applications, but in some "
"ways their behaviour isn't intuitive and at times they don't behave the way "
"you may expect them to.  This section will point out some of the most common "
"pitfalls."
msgstr ""
"Регулярные выражения являются мощным инструментом для некоторых приложений, "
"но в некотором смысле их поведение не интуитивно понятно, а иногда они ведут "
"себя не так, как вы от них ожидаете. В этом разделе будут указаны некоторые "
"из наиболее распространенных ошибок."

#: ../../howto/regex.rst:1245
msgid "Use String Methods"
msgstr "Используйте строковые методы"

#: ../../howto/regex.rst:1247
msgid ""
"Sometimes using the :mod:`re` module is a mistake.  If you're matching a "
"fixed string, or a single character class, and you're not using any :mod:"
"`re` features such as the :const:`~re.IGNORECASE` flag, then the full power "
"of regular expressions may not be required. Strings have several methods for "
"performing operations with fixed strings and they're usually much faster, "
"because the implementation is a single small C loop that's been optimized "
"for the purpose, instead of the large, more generalized regular expression "
"engine."
msgstr ""
"Иногда использование модуля :mod:`re` является ошибкой. Если вы "
"сопоставляете фиксированную строку или один класс символов и не используете "
"какие-либо функции :mod:`re`, такие как флаг :const:`~re.IGNORECASE`, тогда "
"вся мощь регулярных выражений может не потребоваться. Строки имеют несколько "
"методов для выполнения операций с фиксированными строками, и обычно они "
"намного быстрее, поскольку реализация представляет собой один небольшой цикл "
"C, оптимизированный для этой цели, а не большой, более обобщенный механизм "
"регулярных выражений."

#: ../../howto/regex.rst:1255
msgid ""
"One example might be replacing a single fixed string with another one; for "
"example, you might replace ``word`` with ``deed``.  :func:`re.sub` seems "
"like the function to use for this, but consider the :meth:`~str.replace` "
"method.  Note that :meth:`!replace` will also replace ``word`` inside words, "
"turning ``swordfish`` into ``sdeedfish``, but the  naive RE ``word`` would "
"have done that, too.  (To avoid performing the substitution on parts of "
"words, the pattern would have to be ``\\bword\\b``, in order to require that "
"``word`` have a word boundary on either side.  This takes the job beyond  :"
"meth:`!replace`'s abilities.)"
msgstr ""
"Одним из примеров может быть замена одной фиксированной строки другой; "
"например, вы можете заменить слово на слово дело. :func:`re.sub` кажется "
"функцией, которую можно использовать для этого, но рассмотрим метод :meth:"
"`~str.replace`. Обратите внимание, что :meth:`!replace` также заменит "
"``word`` внутри слов, превратив ``swordfish`` в ``sdeedfish``, но наивный RE "
"``word`` тоже сделал бы это. (Чтобы избежать выполнения замены частей слов, "
"шаблон должен быть ``\\bword\\b``, чтобы требовать, чтобы ``word`` имел "
"границу слова с обеих сторон. Это выходит за рамки: meth:`!replace`.)"

#: ../../howto/regex.rst:1264
msgid ""
"Another common task is deleting every occurrence of a single character from "
"a string or replacing it with another single character.  You might do this "
"with something like ``re.sub('\\n', ' ', S)``, but :meth:`~str.translate` is "
"capable of doing both tasks and will be faster than any regular expression "
"operation can be."
msgstr ""
"Другая распространенная задача — удаление каждого вхождения одного символа "
"из строки или замена его другим одиночным символом. Вы можете сделать это с "
"помощью чего-то вроде ``re.sub('\\n', ' ', S)``, но :meth:`~str.translate` "
"способен выполнять обе задачи и будет быстрее, чем любое регулярное "
"выражение. операция может быть."

#: ../../howto/regex.rst:1270
msgid ""
"In short, before turning to the :mod:`re` module, consider whether your "
"problem can be solved with a faster and simpler string method."
msgstr ""
"Короче говоря, прежде чем обращаться к модулю :mod:`re`, подумайте, можно ли "
"решить вашу проблему более быстрым и простым строковым методом."

#: ../../howto/regex.rst:1275
msgid "match() versus search()"
msgstr "match() против search()"

#: ../../howto/regex.rst:1277
msgid ""
"The :func:`~re.match` function only checks if the RE matches at the "
"beginning of the string while :func:`~re.search` will scan forward through "
"the string for a match. It's important to keep this distinction in mind.  "
"Remember,  :func:`!match` will only report a successful match which will "
"start at 0; if the match wouldn't start at zero,  :func:`!match` will *not* "
"report it. ::"
msgstr ""
"Функция :func:`~re.match` проверяет только совпадение RE в начале строки, "
"тогда как :func:`~re.search` будет сканировать строку вперед в поисках "
"совпадений. Важно помнить об этом различии. Помните, :func:`!match` сообщит "
"только об успешном совпадении, которое начинается с 0; если совпадение не "
"начнется с нуля, :func:`!match` *не* сообщит об этом. ::"

#: ../../howto/regex.rst:1288
msgid ""
"On the other hand, :func:`~re.search` will scan forward through the string, "
"reporting the first match it finds. ::"
msgstr ""
"С другой стороны, :func:`~re.search` будет сканировать строку вперед, "
"сообщая о первом найденном совпадении. ::"

#: ../../howto/regex.rst:1296
msgid ""
"Sometimes you'll be tempted to keep using :func:`re.match`, and just add ``."
"*`` to the front of your RE.  Resist this temptation and use :func:`re."
"search` instead.  The regular expression compiler does some analysis of REs "
"in order to speed up the process of looking for a match.  One such analysis "
"figures out what the first character of a match must be; for example, a "
"pattern starting with ``Crow`` must match starting with a ``'C'``.  The "
"analysis lets the engine quickly scan through the string looking for the "
"starting character, only trying the full match if a ``'C'`` is found."
msgstr ""
"Иногда у вас может возникнуть соблазн продолжать использовать :func:`re."
"match` и просто добавлять ``.*`` в начало вашего RE. Не поддавайтесь этому "
"искушению и вместо этого используйте :func:`re.search`. Компилятор "
"регулярных выражений выполняет некоторый анализ RE, чтобы ускорить процесс "
"поиска соответствия. Один из таких анализов позволяет выяснить, каким должен "
"быть первый символ совпадения; например, шаблон, начинающийся с «Crow», "
"должен соответствовать букве, начинающейся с «C». Анализ позволяет движку "
"быстро сканировать строку в поисках начального символа, пробуя полное "
"совпадение только в том случае, если найден ``'C'``."

#: ../../howto/regex.rst:1305
msgid ""
"Adding ``.*`` defeats this optimization, requiring scanning to the end of "
"the string and then backtracking to find a match for the rest of the RE.  "
"Use :func:`re.search` instead."
msgstr ""
"Добавление ``.*`` отменяет эту оптимизацию, требуя сканирования до конца "
"строки, а затем возврата, чтобы найти совпадение для остальной части RE. "
"Вместо этого используйте :func:`re.search`."

#: ../../howto/regex.rst:1311
msgid "Greedy versus Non-Greedy"
msgstr "Жадный против нежадного"

#: ../../howto/regex.rst:1313
msgid ""
"When repeating a regular expression, as in ``a*``, the resulting action is "
"to consume as much of the pattern as possible.  This fact often bites you "
"when you're trying to match a pair of balanced delimiters, such as the angle "
"brackets surrounding an HTML tag.  The naive pattern for matching a single "
"HTML tag doesn't work because of the greedy nature of ``.*``. ::"
msgstr ""
"При повторении регулярного выражения, например ``a*``, результатом является "
"использование как можно большей части шаблона. Этот факт часто бросается в "
"глаза, когда вы пытаетесь сопоставить пару сбалансированных разделителей, "
"таких как угловые скобки, окружающие тег HTML. Наивный шаблон для "
"сопоставления одного тега HTML не работает из-за жадной природы ``.*``. ::"

#: ../../howto/regex.rst:1327
msgid ""
"The RE matches the ``'<'`` in ``'<html>'``, and the ``.*`` consumes the rest "
"of the string.  There's still more left in the RE, though, and the ``>`` "
"can't match at the end of the string, so the regular expression engine has "
"to backtrack character by character until it finds a match for the ``>``.   "
"The final match extends from the ``'<'`` in ``'<html>'`` to the ``'>'`` in "
"``'</title>'``, which isn't what you want."
msgstr ""
"RE соответствует ``'<'`` в ``'<html>'``, а ``.*`` поглощает остальную часть "
"строки. Однако в RE еще осталось еще больше, и ``>`` не может "
"соответствовать концу строки, поэтому механизму регулярных выражений "
"приходится возвращаться посимвольно, пока не найдет совпадение для ``>` `. "
"Окончательное совпадение простирается от ``'<'`` в ``'<html>'`` до ``'>'`` в "
"``'</title>'``, а это не то, что вы хотеть."

#: ../../howto/regex.rst:1334
msgid ""
"In this case, the solution is to use the non-greedy quantifiers ``*?``, ``+?"
"``, ``??``, or ``{m,n}?``, which match as *little* text as possible.  In the "
"above example, the ``'>'`` is tried immediately after the first ``'<'`` "
"matches, and when it fails, the engine advances a character at a time, "
"retrying the ``'>'`` at every step.  This produces just the right result::"
msgstr ""
"В этом случае решением является использование нежадных кванторов ``*?``, ``+?"
"``, ``??`` или ``{m,n}?``, которые соответствуют как *немного* текста, "
"насколько это возможно. В приведенном выше примере ``'>'`` пробуется сразу "
"после первого совпадения ``'<'``, и в случае неудачи движок продвигает "
"вперед символ за раз, повторяя ``'>'` ` на каждом шагу. Это дает правильный "
"результат::"

#: ../../howto/regex.rst:1343
msgid ""
"(Note that parsing HTML or XML with regular expressions is painful. Quick-"
"and-dirty patterns will handle common cases, but HTML and XML have special "
"cases that will break the obvious regular expression; by the time you've "
"written a regular expression that handles all of the possible cases, the "
"patterns will be *very* complicated.  Use an HTML or XML parser module for "
"such tasks.)"
msgstr ""
"(Обратите внимание, что анализ HTML или XML с помощью регулярных выражений "
"является болезненным занятием. Шаблоны на скорую руку справляются с обычными "
"случаями, но HTML и XML имеют особые случаи, которые нарушают очевидное "
"регулярное выражение; к тому времени, как вы напишете регулярное выражение, "
"обрабатывает все возможные случаи, шаблоны будут *очень* сложными. Для таких "
"задач используйте модуль анализатора HTML или XML.)"

#: ../../howto/regex.rst:1351
msgid "Using re.VERBOSE"
msgstr "Использование re.VERBOSE"

#: ../../howto/regex.rst:1353
msgid ""
"By now you've probably noticed that regular expressions are a very compact "
"notation, but they're not terribly readable.  REs of moderate complexity can "
"become lengthy collections of backslashes, parentheses, and metacharacters, "
"making them difficult to read and understand."
msgstr ""
"Вы, наверное, уже заметили, что регулярные выражения — это очень компактная "
"запись, но она не очень читабельна. RE средней сложности могут представлять "
"собой длинные наборы обратных косых черт, круглых скобок и метасимволов, что "
"затрудняет их чтение и понимание."

#: ../../howto/regex.rst:1358
msgid ""
"For such REs, specifying the :const:`re.VERBOSE` flag when compiling the "
"regular expression can be helpful, because it allows you to format the "
"regular expression more clearly."
msgstr ""
"Для таких RE указание флага :const:`re.VERBOSE` при компиляции регулярного "
"выражения может быть полезным, поскольку это позволяет более четко "
"форматировать регулярное выражение."

#: ../../howto/regex.rst:1362
msgid ""
"The ``re.VERBOSE`` flag has several effects.  Whitespace in the regular "
"expression that *isn't* inside a character class is ignored.  This means "
"that an expression such as ``dog | cat`` is equivalent to the less readable "
"``dog|cat``, but ``[a b]`` will still match the characters ``'a'``, ``'b'``, "
"or a space.  In addition, you can also put comments inside a RE; comments "
"extend from a ``#`` character to the next newline.  When used with triple-"
"quoted strings, this enables REs to be formatted more neatly::"
msgstr ""
"Флаг ``re.VERBOSE`` имеет несколько эффектов. Пробелы в регулярном "
"выражении, *не* находящиеся внутри класса символов, игнорируются. Это "
"означает, что такое выражение, как ``собака | cat`` эквивалентен менее "
"читаемому ``dog|cat``, но ``[ab]`` по-прежнему будет соответствовать "
"символам ``'a'``, ``'b'`` или пробелу. Кроме того, вы также можете размещать "
"комментарии внутри RE; комментарии простираются от символа ``#`` до "
"следующей новой строки. При использовании со строками в тройных кавычках это "
"позволяет более аккуратно форматировать RE:"

#: ../../howto/regex.rst:1379
msgid "This is far more readable than::"
msgstr "Это гораздо более читабельно, чем::"

#: ../../howto/regex.rst:1385
msgid "Feedback"
msgstr "Обратная связь"

#: ../../howto/regex.rst:1387
msgid ""
"Regular expressions are a complicated topic.  Did this document help you "
"understand them?  Were there parts that were unclear, or Problems you "
"encountered that weren't covered here?  If so, please send suggestions for "
"improvements to the author."
msgstr ""
"Регулярные выражения — сложная тема. Помог ли этот документ вам их понять? "
"Были ли какие-то моменты непонятны или возникли проблемы, которые здесь не "
"описаны? Если да, пожалуйста, пришлите предложения по улучшению автору."

#: ../../howto/regex.rst:1392
msgid ""
"The most complete book on regular expressions is almost certainly Jeffrey "
"Friedl's Mastering Regular Expressions, published by O'Reilly.  "
"Unfortunately, it exclusively concentrates on Perl and Java's flavours of "
"regular expressions, and doesn't contain any Python material at all, so it "
"won't be useful as a reference for programming in Python.  (The first "
"edition covered Python's now-removed :mod:`!regex` module, which won't help "
"you much.)  Consider checking it out from your library."
msgstr ""
"Наиболее полной книгой по регулярным выражениям почти наверняка является "
"книга Джеффри Фридла «Освоение регулярных выражений», опубликованная "
"О'Рейли. К сожалению, он сосредоточен исключительно на вариантах регулярных "
"выражений Perl и Java и вообще не содержит материалов по Python, поэтому он "
"не будет полезен в качестве справочника по программированию на Python. (В "
"первом издании речь шла об уже удаленном из Python модуле :mod:`!regex`, "
"который вам мало чем поможет.) Попробуйте проверить его в своей библиотеке."
