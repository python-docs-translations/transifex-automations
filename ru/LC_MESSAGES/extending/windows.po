# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Roustam Khamidoulline, 2024
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 14:53+0000\n"
"PO-Revision-Date: 2024-05-11 00:32+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../extending/windows.rst:8
msgid "Building C and C++ Extensions on Windows"
msgstr "Создание расширений C и C++ в Windows"

#: ../../extending/windows.rst:10
msgid ""
"This chapter briefly explains how to create a Windows extension module for "
"Python using Microsoft Visual C++, and follows with more detailed background "
"information on how it works.  The explanatory material is useful for both "
"the Windows programmer learning to build Python extensions and the Unix "
"programmer interested in producing software which can be successfully built "
"on both Unix and Windows."
msgstr ""
"В этой главе кратко объясняется, как создать модуль расширения Windows для "
"Python с использованием Microsoft Visual C++, а затем приводится более "
"подробная справочная информация о том, как он работает. Пояснительный "
"материал полезен как программистам Windows, обучающимся созданию расширений "
"Python, так и программистам Unix, заинтересованным в создании программного "
"обеспечения, которое можно успешно создавать как в Unix, так и в Windows."

#: ../../extending/windows.rst:17
msgid ""
"Module authors are encouraged to use the distutils approach for building "
"extension modules, instead of the one described in this section. You will "
"still need the C compiler that was used to build Python; typically Microsoft "
"Visual C++."
msgstr ""
"Авторам модулей рекомендуется использовать подход distutils для создания "
"модулей расширения вместо того, который описан в этом разделе. Вам по-"
"прежнему понадобится компилятор C, который использовался для сборки Python; "
"обычно Microsoft Visual C++."

#: ../../extending/windows.rst:24
msgid ""
"This chapter mentions a number of filenames that include an encoded Python "
"version number.  These filenames are represented with the version number "
"shown as ``XY``; in practice, ``'X'`` will be the major version number and "
"``'Y'`` will be the minor version number of the Python release you're "
"working with.  For example, if you are using Python 2.2.1, ``XY`` will "
"actually be ``22``."
msgstr ""
"В этой главе упоминается ряд имен файлов, которые включают закодированный "
"номер версии Python. Эти имена файлов представлены номером версии, "
"обозначенным как ``XY``; на практике X будет основным номером версии, а Y "
"будет младшим номером версии Python, с которой вы работаете. Например, если "
"вы используете Python 2.2.1, ``XY`` на самом деле будет ``22``."

#: ../../extending/windows.rst:34
msgid "A Cookbook Approach"
msgstr "Подход с кулинарной книгой"

#: ../../extending/windows.rst:36
msgid ""
"There are two approaches to building extension modules on Windows, just as "
"there are on Unix: use the ``setuptools`` package to control the build "
"process, or do things manually.  The setuptools approach works well for most "
"extensions; documentation on using ``setuptools`` to build and package "
"extension modules is available in :ref:`setuptools-index`.  If you find you "
"really need to do things manually, it may be instructive to study the "
"project file for the :source:`winsound <PCbuild/winsound.vcxproj>` standard "
"library module."
msgstr ""
"Существует два подхода к созданию модулей расширения в Windows, как и в "
"Unix: использовать пакет ``setuptools`` для управления процессом сборки или "
"делать все вручную. Подход setuptools хорошо работает для большинства "
"расширений; Документация по использованию ``setuptools`` для сборки и "
"упаковки модулей расширения доступна в :ref:`setuptools-index`. Если вы "
"обнаружите, что вам действительно нужно делать что-то вручную, возможно, "
"будет полезно изучить файл проекта стандартного библиотечного модуля :source:"
"`winsound <PCbuild/winsound.vcxproj>`."

#: ../../extending/windows.rst:48
msgid "Differences Between Unix and Windows"
msgstr "Различия между Unix и Windows"

#: ../../extending/windows.rst:53
msgid ""
"Unix and Windows use completely different paradigms for run-time loading of "
"code.  Before you try to build a module that can be dynamically loaded, be "
"aware of how your system works."
msgstr ""
"Unix и Windows используют совершенно разные парадигмы загрузки кода во время "
"выполнения. Прежде чем попытаться создать модуль, который можно будет "
"динамически загружать, узнайте, как работает ваша система."

#: ../../extending/windows.rst:57
msgid ""
"In Unix, a shared object (:file:`.so`) file contains code to be used by the "
"program, and also the names of functions and data that it expects to find in "
"the program.  When the file is joined to the program, all references to "
"those functions and data in the file's code are changed to point to the "
"actual locations in the program where the functions and data are placed in "
"memory. This is basically a link operation."
msgstr ""
"В Unix файл общего объекта (:file:`.so`) содержит код, который будет "
"использоваться программой, а также имена функций и данных, которые она "
"ожидает найти в программе. Когда файл присоединяется к программе, все ссылки "
"на эти функции и данные в коде файла изменяются, чтобы указывать на "
"фактические места в программе, где функции и данные размещаются в памяти. По "
"сути, это операция связи."

#: ../../extending/windows.rst:64
msgid ""
"In Windows, a dynamic-link library (:file:`.dll`) file has no dangling "
"references.  Instead, an access to functions or data goes through a lookup "
"table.  So the DLL code does not have to be fixed up at runtime to refer to "
"the program's memory; instead, the code already uses the DLL's lookup table, "
"and the lookup table is modified at runtime to point to the functions and "
"data."
msgstr ""
"В Windows файл библиотеки динамической компоновки (:file:`.dll`) не имеет "
"висячих ссылок. Вместо этого доступ к функциям или данным осуществляется "
"через справочную таблицу. Таким образом, код DLL не нужно исправлять во "
"время выполнения, чтобы он мог обращаться к памяти программы; вместо этого "
"код уже использует таблицу поиска DLL, а таблица поиска модифицируется во "
"время выполнения, чтобы указывать на функции и данные."

#: ../../extending/windows.rst:70
msgid ""
"In Unix, there is only one type of library file (:file:`.a`) which contains "
"code from several object files (:file:`.o`).  During the link step to create "
"a shared object file (:file:`.so`), the linker may find that it doesn't know "
"where an identifier is defined.  The linker will look for it in the object "
"files in the libraries; if it finds it, it will include all the code from "
"that object file."
msgstr ""
"В Unix существует только один тип библиотечного файла (:file:`.a`), который "
"содержит код из нескольких объектных файлов (:file:`.o`). На этапе "
"компоновки для создания общего объектного файла (:file:`.so`) компоновщик "
"может обнаружить, что он не знает, где определен идентификатор. Компоновщик "
"будет искать его в объектных файлах библиотек; если он его найдет, он "
"включит весь код из этого объектного файла."

#: ../../extending/windows.rst:76
msgid ""
"In Windows, there are two types of library, a static library and an import "
"library (both called :file:`.lib`).  A static library is like a Unix :file:`."
"a` file; it contains code to be included as necessary. An import library is "
"basically used only to reassure the linker that a certain identifier is "
"legal, and will be present in the program when the DLL is loaded.  So the "
"linker uses the information from the import library to build the lookup "
"table for using identifiers that are not included in the DLL.  When an "
"application or a DLL is linked, an import library may be generated, which "
"will need to be used for all future DLLs that depend on the symbols in the "
"application or DLL."
msgstr ""
"В Windows существует два типа библиотек: статическая библиотека и библиотека "
"импорта (обе называются :file:`.lib`). Статическая библиотека похожа на "
"файл :file:`.a` в Unix; он содержит код, который можно включать при "
"необходимости. Библиотека импорта в основном используется только для того, "
"чтобы убедить компоновщика в том, что определенный идентификатор является "
"допустимым и будет присутствовать в программе при загрузке DLL. Таким "
"образом, компоновщик использует информацию из библиотеки импорта для "
"построения таблицы поиска для использования идентификаторов, не включенных в "
"DLL. Когда приложение или DLL связывается, может быть создана библиотека "
"импорта, которую необходимо будет использовать для всех будущих DLL, которые "
"зависят от символов в приложении или DLL."

#: ../../extending/windows.rst:86
msgid ""
"Suppose you are building two dynamic-load modules, B and C, which should "
"share another block of code A.  On Unix, you would *not* pass :file:`A.a` to "
"the linker for :file:`B.so` and :file:`C.so`; that would cause it to be "
"included twice, so that B and C would each have their own copy.  In Windows, "
"building :file:`A.dll` will also build :file:`A.lib`.  You *do* pass :file:"
"`A.lib` to the linker for B and C.  :file:`A.lib` does not contain code; it "
"just contains information which will be used at runtime to access A's code."
msgstr ""
"Предположим, вы создаете два модуля динамической загрузки, B и C, которые "
"должны совместно использовать другой блок кода A. В Unix вы *не* передаете :"
"file:`Aa` компоновщику для :file:`B.so` и :file:`C.so`; это приведет к тому, "
"что он будет включен дважды, так что у B и C будет своя собственная копия. В "
"Windows сборка :file:`A.dll` также приведет к сборке :file:`A.lib`. Вы "
"*делаете* передачу :file:`A.lib` компоновщику для B и C. :file:`A.lib` не "
"содержит кода; он просто содержит информацию, которая будет использоваться "
"во время выполнения для доступа к коду A."

#: ../../extending/windows.rst:94
msgid ""
"In Windows, using an import library is sort of like using ``import spam``; "
"it gives you access to spam's names, but does not create a separate copy.  "
"On Unix, linking with a library is more like ``from spam import *``; it does "
"create a separate copy."
msgstr ""
"В Windows использование библиотеки импорта похоже на использование «импорта "
"спама»; он дает вам доступ к именам спамеров, но не создает отдельную копию. "
"В Unix связывание с библиотекой больше похоже на «импорт спама *»; он "
"создает отдельную копию."

#: ../../extending/windows.rst:103
msgid "Using DLLs in Practice"
msgstr "Использование DLL на практике"

#: ../../extending/windows.rst:108
msgid ""
"Windows Python is built in Microsoft Visual C++; using other compilers may "
"or may not work.  The rest of this section is MSVC++ specific."
msgstr ""
"Windows Python встроен в Microsoft Visual C++; использование других "
"компиляторов может работать, а может и не работать. Остальная часть этого "
"раздела относится только к MSVC++."

#: ../../extending/windows.rst:111
msgid ""
"When creating DLLs in Windows, you must pass :file:`pythonXY.lib` to the "
"linker. To build two DLLs, spam and ni (which uses C functions found in "
"spam), you could use these commands::"
msgstr ""
"При создании DLL в Windows вы должны передать :file:`pythonXY.lib` "
"компоновщику. Чтобы создать две библиотеки DLL, spam и ni (которые "
"используют функции C, найденные в спаме), вы можете использовать следующие "
"команды:"

#: ../../extending/windows.rst:115
msgid ""
"cl /LD /I/python/include spam.c ../libs/pythonXY.lib\n"
"cl /LD /I/python/include ni.c spam.lib ../libs/pythonXY.lib"
msgstr ""
"cl /LD /I/python/include spam.c ../libs/pythonXY.lib\n"
"cl /LD /I/python/include ni.c spam.lib ../libs/pythonXY.lib"

#: ../../extending/windows.rst:118
msgid ""
"The first command created three files: :file:`spam.obj`, :file:`spam.dll` "
"and :file:`spam.lib`.  :file:`Spam.dll` does not contain any Python "
"functions (such as :c:func:`PyArg_ParseTuple`), but it does know how to find "
"the Python code thanks to :file:`pythonXY.lib`."
msgstr ""
"Первая команда создала три файла: :file:`spam.obj`, :file:`spam.dll` и :file:"
"`spam.lib`. :file:`Spam.dll` не содержит никаких функций Python (таких как :"
"c:func:`PyArg_ParseTuple`), но знает, как найти код Python благодаря :file:"
"`pythonXY.lib`."

#: ../../extending/windows.rst:123
msgid ""
"The second command created :file:`ni.dll` (and :file:`.obj` and :file:`."
"lib`), which knows how to find the necessary functions from spam, and also "
"from the Python executable."
msgstr ""
"Вторая команда создала :file:`ni.dll` (а также :file:`.obj` и :file:`.lib`), "
"который умеет находить нужные функции в спаме, а также в исполняемом файле "
"Python."

#: ../../extending/windows.rst:127
msgid ""
"Not every identifier is exported to the lookup table.  If you want any other "
"modules (including Python) to be able to see your identifiers, you have to "
"say ``_declspec(dllexport)``, as in ``void _declspec(dllexport) "
"initspam(void)`` or ``PyObject _declspec(dllexport) *NiGetSpamData(void)``."
msgstr ""
"Не каждый идентификатор экспортируется в таблицу поиска. Если вы хотите, "
"чтобы другие модули (включая Python) могли видеть ваши идентификаторы, вам "
"нужно сказать ``_declspec(dllexport)``, например ``void _declspec(dllexport) "
"initspam(void)`` или ``PyObject _declspec(dllexport) *NiGetSpamData(void)``."

#: ../../extending/windows.rst:132
msgid ""
"Developer Studio will throw in a lot of import libraries that you do not "
"really need, adding about 100K to your executable.  To get rid of them, use "
"the Project Settings dialog, Link tab, to specify *ignore default "
"libraries*.  Add the correct :file:`msvcrt{xx}.lib` to the list of libraries."
msgstr ""
"Developer Studio добавит множество библиотек импорта, которые вам на самом "
"деле не нужны, добавив около 100 КБ к вашему исполняемому файлу. Чтобы "
"избавиться от них, используйте диалоговое окно «Настройки проекта» на "
"вкладке «Ссылка» и укажите *игнорировать библиотеки по умолчанию*. Добавьте "
"правильный :file:`msvcrt{xx}.lib` в список библиотек."
