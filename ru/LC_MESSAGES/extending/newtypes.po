# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Jon Britva, 2023
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 15:28+0000\n"
"PO-Revision-Date: 2023-05-24 02:10+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../extending/newtypes.rst:7
msgid "Defining Extension Types: Assorted Topics"
msgstr "Определение типов расширений: разные темы"

#: ../../extending/newtypes.rst:11
msgid ""
"This section aims to give a quick fly-by on the various type methods you can "
"implement and what they do."
msgstr ""
"Целью этого раздела является краткое описание различных методов типов, "
"которые вы можете реализовать, и того, что они делают."

#: ../../extending/newtypes.rst:14
msgid ""
"Here is the definition of :c:type:`PyTypeObject`, with some fields only used "
"in :ref:`debug builds <debug-build>` omitted:"
msgstr ""
"Вот определение :c:type:`PyTypeObject`, при этом некоторые поля, "
"используемые только в :ref:`debug builds <debug-build>`, опущены:"

#: ../../extending/newtypes.rst:20
msgid ""
"Now that's a *lot* of methods.  Don't worry too much though -- if you have a "
"type you want to define, the chances are very good that you will only "
"implement a handful of these."
msgstr ""
"Это *много* методов. Однако не беспокойтесь слишком сильно — если у вас есть "
"тип, который вы хотите определить, очень велика вероятность, что вы "
"реализуете только несколько из них."

#: ../../extending/newtypes.rst:24
msgid ""
"As you probably expect by now, we're going to go over this and give more "
"information about the various handlers.  We won't go in the order they are "
"defined in the structure, because there is a lot of historical baggage that "
"impacts the ordering of the fields.  It's often easiest to find an example "
"that includes the fields you need and then change the values to suit your "
"new type. ::"
msgstr ""
"Как вы, наверное, уже догадались, мы собираемся рассмотреть это и "
"предоставить больше информации о различных обработчиках. Мы не будем идти в "
"том порядке, в котором они определены в структуре, поскольку на порядок "
"полей влияет множество исторических данных. Зачастую проще всего найти "
"пример, включающий нужные вам поля, а затем изменить значения в соответствии "
"с новым типом. ::"

#: ../../extending/newtypes.rst:33
msgid ""
"The name of the type -- as mentioned in the previous chapter, this will "
"appear in various places, almost entirely for diagnostic purposes. Try to "
"choose something that will be helpful in such a situation! ::"
msgstr ""
"Название типа — как упоминалось в предыдущей главе, оно будет появляться в "
"разных местах, почти исключительно в диагностических целях. Постарайтесь "
"выбрать то, что будет полезно в такой ситуации! ::"

#: ../../extending/newtypes.rst:39
msgid ""
"These fields tell the runtime how much memory to allocate when new objects "
"of this type are created.  Python has some built-in support for variable "
"length structures (think: strings, tuples) which is where the :c:member:"
"`~PyTypeObject.tp_itemsize` field comes in.  This will be dealt with "
"later. ::"
msgstr ""
"Эти поля сообщают среде выполнения, сколько памяти следует выделить при "
"создании новых объектов этого типа. Python имеет некоторую встроенную "
"поддержку структур переменной длины (например, строк, кортежей), и именно "
"здесь появляется поле :c:member:`~PyTypeObject.tp_itemsize`. Об этом мы "
"поговорим позже. ::"

#: ../../extending/newtypes.rst:46
msgid ""
"Here you can put a string (or its address) that you want returned when the "
"Python script references ``obj.__doc__`` to retrieve the doc string."
msgstr ""
"Здесь вы можете поместить строку (или ее адрес), которую вы хотите вернуть, "
"когда сценарий Python ссылается на ``obj.__doc__`` для получения строки "
"документа."

#: ../../extending/newtypes.rst:49
msgid ""
"Now we come to the basic type methods -- the ones most extension types will "
"implement."
msgstr ""
"Теперь мы подошли к методам базового типа — тем, которые реализует "
"большинство типов расширений."

#: ../../extending/newtypes.rst:54
msgid "Finalization and De-allocation"
msgstr "Завершение и перераспределение"

#: ../../extending/newtypes.rst:66
msgid ""
"This function is called when the reference count of the instance of your "
"type is reduced to zero and the Python interpreter wants to reclaim it.  If "
"your type has memory to free or other clean-up to perform, you can put it "
"here.  The object itself needs to be freed here as well.  Here is an example "
"of this function::"
msgstr ""
"Эта функция вызывается, когда счетчик ссылок экземпляра вашего типа "
"уменьшается до нуля и интерпретатор Python хочет его вернуть. Если у вашего "
"типа есть память, которую нужно освободить или выполнить другую очистку, вы "
"можете поместить ее сюда. Здесь также необходимо освободить сам объект. Вот "
"пример этой функции:"

#: ../../extending/newtypes.rst:79
msgid ""
"If your type supports garbage collection, the destructor should call :c:func:"
"`PyObject_GC_UnTrack` before clearing any member fields::"
msgstr ""
"Если ваш тип поддерживает сборку мусора, деструктор должен вызвать :c:func:"
"`PyObject_GC_UnTrack` перед очисткой любых полей-членов::"

#: ../../extending/newtypes.rst:95
msgid ""
"One important requirement of the deallocator function is that it leaves any "
"pending exceptions alone.  This is important since deallocators are "
"frequently called as the interpreter unwinds the Python stack; when the "
"stack is unwound due to an exception (rather than normal returns), nothing "
"is done to protect the deallocators from seeing that an exception has "
"already been set.  Any actions which a deallocator performs which may cause "
"additional Python code to be executed may detect that an exception has been "
"set.  This can lead to misleading errors from the interpreter.  The proper "
"way to protect against this is to save a pending exception before performing "
"the unsafe action, and restoring it when done.  This can be done using the :"
"c:func:`PyErr_Fetch` and :c:func:`PyErr_Restore` functions::"
msgstr ""
"Одним из важных требований функции освобождения является то, что она "
"оставляет в покое любые ожидающие исключения. Это важно, поскольку "
"устройства освобождения памяти часто вызываются, когда интерпретатор "
"раскручивает стек Python; когда стек разматывается из-за исключения (а не "
"обычного возврата), ничего не делается, чтобы защитить устройства "
"освобождения от обнаружения того, что исключение уже установлено. Любые "
"действия, которые выполняет освободитель и которые могут вызвать выполнение "
"дополнительного кода Python, могут обнаружить, что было установлено "
"исключение. Это может привести к вводящим в заблуждение ошибкам переводчика. "
"Правильный способ защиты от этого — сохранить ожидающее исключение перед "
"выполнением небезопасного действия и восстановить его после выполнения. Это "
"можно сделать с помощью функций :c:func:`PyErr_Fetch` и :c:func:"
"`PyErr_Restore`::"

#: ../../extending/newtypes.rst:134
msgid ""
"There are limitations to what you can safely do in a deallocator function. "
"First, if your type supports garbage collection (using :c:member:"
"`~PyTypeObject.tp_traverse` and/or :c:member:`~PyTypeObject.tp_clear`), some "
"of the object's members can have been cleared or finalized by the time :c:"
"member:`~PyTypeObject.tp_dealloc` is called.  Second, in :c:member:"
"`~PyTypeObject.tp_dealloc`, your object is in an unstable state: its "
"reference count is equal to zero.  Any call to a non-trivial object or API "
"(as in the example above) might end up calling :c:member:`~PyTypeObject."
"tp_dealloc` again, causing a double free and a crash."
msgstr ""
"Существуют ограничения на то, что вы можете безопасно делать с помощью "
"функции освобождения. Во-первых, если ваш тип поддерживает сборку мусора (с "
"использованием :c:member:`~PyTypeObject.tp_traverse` и/или :c:member:"
"`~PyTypeObject.tp_clear`), некоторые члены объекта могут быть очищены или "
"финализированы с помощью time :c:member:`~PyTypeObject.tp_dealloc` "
"вызывается. Во-вторых, в :c:member:`~PyTypeObject.tp_dealloc` ваш объект "
"находится в нестабильном состоянии: его счетчик ссылок равен нулю. Любой "
"вызов нетривиального объекта или API (как в примере выше) может закончиться "
"повторным вызовом :c:member:`~PyTypeObject.tp_dealloc`, что приведет к "
"двойному освобождению и сбою."

#: ../../extending/newtypes.rst:143
msgid ""
"Starting with Python 3.4, it is recommended not to put any complex "
"finalization code in :c:member:`~PyTypeObject.tp_dealloc`, and instead use "
"the new :c:member:`~PyTypeObject.tp_finalize` type method."
msgstr ""
"Начиная с Python 3.4, рекомендуется не помещать какой-либо сложный код "
"завершения в :c:member:`~PyTypeObject.tp_dealloc`, а вместо этого "
"использовать новый метод типа :c:member:`~PyTypeObject.tp_finalize`."

#: ../../extending/newtypes.rst:148
msgid ":pep:`442` explains the new finalization scheme."
msgstr ":pep:`442` объясняет новую схему финализации."

#: ../../extending/newtypes.rst:155
msgid "Object Presentation"
msgstr "Представление объекта"

#: ../../extending/newtypes.rst:157
msgid ""
"In Python, there are two ways to generate a textual representation of an "
"object: the :func:`repr` function, and the :func:`str` function.  (The :func:"
"`print` function just calls :func:`str`.)  These handlers are both optional."
msgstr ""
"В Python существует два способа создания текстового представления объекта: "
"функция :func:`repr` и функция :func:`str`. (Функция :func:`print` просто "
"вызывает :func:`str`.) Оба этих обработчика являются необязательными."

#: ../../extending/newtypes.rst:166
msgid ""
"The :c:member:`~PyTypeObject.tp_repr` handler should return a string object "
"containing a representation of the instance for which it is called.  Here is "
"a simple example::"
msgstr ""
"Обработчик :c:member:`~PyTypeObject.tp_repr` должен возвращать строковый "
"объект, содержащий представление экземпляра, для которого он вызывается. Вот "
"простой пример:"

#: ../../extending/newtypes.rst:177
msgid ""
"If no :c:member:`~PyTypeObject.tp_repr` handler is specified, the "
"interpreter will supply a representation that uses the type's :c:member:"
"`~PyTypeObject.tp_name` and a uniquely identifying value for the object."
msgstr ""
"Если обработчик :c:member:`~PyTypeObject.tp_repr` не указан, интерпретатор "
"предоставит представление, которое использует тип :c:member:`~PyTypeObject."
"tp_name` и уникально идентифицирующее значение для объекта."

#: ../../extending/newtypes.rst:181
msgid ""
"The :c:member:`~PyTypeObject.tp_str` handler is to :func:`str` what the :c:"
"member:`~PyTypeObject.tp_repr` handler described above is to :func:`repr`; "
"that is, it is called when Python code calls :func:`str` on an instance of "
"your object.  Its implementation is very similar to the :c:member:"
"`~PyTypeObject.tp_repr` function, but the resulting string is intended for "
"human consumption.  If :c:member:`~PyTypeObject.tp_str` is not specified, "
"the :c:member:`~PyTypeObject.tp_repr` handler is used instead."
msgstr ""
"Обработчик :c:member:`~PyTypeObject.tp_str` выполняет то же самое, что и "
"обработчик :c:member:`~PyTypeObject.tp_repr`, описанный выше, для :func:"
"`repr`; то есть он вызывается, когда код Python вызывает :func:`str` для "
"экземпляра вашего объекта. Ее реализация очень похожа на функцию :c:member:"
"`~PyTypeObject.tp_repr`, но результирующая строка предназначена для "
"потребления человеком. Если :c:member:`~PyTypeObject.tp_str` не указан, "
"вместо него используется обработчик :c:member:`~PyTypeObject.tp_repr`."

#: ../../extending/newtypes.rst:188
msgid "Here is a simple example::"
msgstr "Вот простой пример:"

#: ../../extending/newtypes.rst:200
msgid "Attribute Management"
msgstr "Управление атрибутами"

#: ../../extending/newtypes.rst:202
msgid ""
"For every object which can support attributes, the corresponding type must "
"provide the functions that control how the attributes are resolved.  There "
"needs to be a function which can retrieve attributes (if any are defined), "
"and another to set attributes (if setting attributes is allowed).  Removing "
"an attribute is a special case, for which the new value passed to the "
"handler is ``NULL``."
msgstr ""
"Для каждого объекта, который может поддерживать атрибуты, соответствующий "
"тип должен предоставлять функции, управляющие разрешением атрибутов. Должна "
"быть функция, которая может получать атрибуты (если таковые определены), и "
"другая для установки атрибутов (если установка атрибутов разрешена). "
"Удаление атрибута — это особый случай, когда новое значение, передаваемое "
"обработчику, равно NULL."

#: ../../extending/newtypes.rst:208
msgid ""
"Python supports two pairs of attribute handlers; a type that supports "
"attributes only needs to implement the functions for one pair.  The "
"difference is that one pair takes the name of the attribute as a :c:expr:"
"`char\\*`, while the other accepts a :c:expr:`PyObject*`.  Each type can use "
"whichever pair makes more sense for the implementation's convenience. ::"
msgstr ""
"Python поддерживает две пары обработчиков атрибутов; тип, поддерживающий "
"атрибуты, должен реализовывать функции только для одной пары. Разница в том, "
"что одна пара принимает имя атрибута как :c:expr:`char\\*`, а другая "
"принимает :c:expr:`PyObject*`. Каждый тип может использовать любую пару, "
"которая имеет больше смысла для удобства реализации. ::"

#: ../../extending/newtypes.rst:220
msgid ""
"If accessing attributes of an object is always a simple operation (this will "
"be explained shortly), there are generic implementations which can be used "
"to provide the :c:expr:`PyObject*` version of the attribute management "
"functions. The actual need for type-specific attribute handlers almost "
"completely disappeared starting with Python 2.2, though there are many "
"examples which have not been updated to use some of the new generic "
"mechanism that is available."
msgstr ""
"Если доступ к атрибутам объекта всегда является простой операцией (это будет "
"объяснено ниже), существуют общие реализации, которые можно использовать для "
"предоставления версии :c:expr:`PyObject*` функций управления атрибутами. "
"Фактическая необходимость в обработчиках атрибутов, специфичных для "
"конкретного типа, почти полностью исчезла, начиная с Python 2.2, хотя "
"существует множество примеров, которые не были обновлены для использования "
"некоторых доступных новых универсальных механизмов."

#: ../../extending/newtypes.rst:231
msgid "Generic Attribute Management"
msgstr "Управление универсальными атрибутами"

#: ../../extending/newtypes.rst:233
msgid ""
"Most extension types only use *simple* attributes.  So, what makes the "
"attributes simple?  There are only a couple of conditions that must be met:"
msgstr ""
"Большинство типов расширений используют только *простые* атрибуты. Итак, что "
"же делает атрибуты простыми? Есть только пара условий, которые необходимо "
"соблюдать:"

#: ../../extending/newtypes.rst:236
msgid ""
"The name of the attributes must be known when :c:func:`PyType_Ready` is "
"called."
msgstr "Имя атрибутов должно быть известно при вызове :c:func:`PyType_Ready`."

#: ../../extending/newtypes.rst:239
msgid ""
"No special processing is needed to record that an attribute was looked up or "
"set, nor do actions need to be taken based on the value."
msgstr ""
"Для регистрации того, что атрибут был найден или установлен, не требуется "
"никакой специальной обработки, а также не требуется предпринимать действия "
"на основе значения."

#: ../../extending/newtypes.rst:242
msgid ""
"Note that this list does not place any restrictions on the values of the "
"attributes, when the values are computed, or how relevant data is stored."
msgstr ""
"Обратите внимание, что этот список не накладывает никаких ограничений на "
"значения атрибутов, время вычисления значений или способ хранения "
"соответствующих данных."

#: ../../extending/newtypes.rst:245
msgid ""
"When :c:func:`PyType_Ready` is called, it uses three tables referenced by "
"the type object to create :term:`descriptor`\\s which are placed in the "
"dictionary of the type object.  Each descriptor controls access to one "
"attribute of the instance object.  Each of the tables is optional; if all "
"three are ``NULL``, instances of the type will only have attributes that are "
"inherited from their base type, and should leave the :c:member:"
"`~PyTypeObject.tp_getattro` and :c:member:`~PyTypeObject.tp_setattro` fields "
"``NULL`` as well, allowing the base type to handle attributes."
msgstr ""
"Когда вызывается :c:func:`PyType_Ready`, она использует три таблицы, на "
"которые ссылается объект типа, для создания :term:`дескриптора`\\s, которые "
"помещаются в словарь объекта типа. Каждый дескриптор управляет доступом к "
"одному атрибуту объекта экземпляра. Каждая из таблиц является "
"необязательной; если все три имеют значение ``NULL``, экземпляры типа будут "
"иметь только атрибуты, унаследованные от их базового типа, и должны "
"оставить :c:member:`~PyTypeObject.tp_getattro` и :c:member:`~PyTypeObject ."
"tp_setattro` также содержит поля ``NULL``, что позволяет базовому типу "
"обрабатывать атрибуты."

#: ../../extending/newtypes.rst:253
msgid "The tables are declared as three fields of the type object::"
msgstr "Таблицы объявлены как три поля типа object::"

#: ../../extending/newtypes.rst:259
msgid ""
"If :c:member:`~PyTypeObject.tp_methods` is not ``NULL``, it must refer to an "
"array of :c:type:`PyMethodDef` structures.  Each entry in the table is an "
"instance of this structure::"
msgstr ""
"Если :c:member:`~PyTypeObject.tp_methods` не равен ``NULL``, он должен "
"ссылаться на массив структур :c:type:`PyMethodDef`. Каждая запись в таблице "
"является экземпляром этой структуры:"

#: ../../extending/newtypes.rst:270
msgid ""
"One entry should be defined for each method provided by the type; no entries "
"are needed for methods inherited from a base type.  One additional entry is "
"needed at the end; it is a sentinel that marks the end of the array.  The :c:"
"member:`~PyMethodDef.ml_name` field of the sentinel must be ``NULL``."
msgstr ""
"Для каждого метода, предоставляемого типом, должна быть определена одна "
"запись; для методов, унаследованных от базового типа, записи не требуются. В "
"конце необходима еще одна запись; это индикатор, отмечающий конец массива. "
"Поле :c:member:`~PyMethodDef.ml_name` дозорного должно быть ``NULL``."

#: ../../extending/newtypes.rst:275
msgid ""
"The second table is used to define attributes which map directly to data "
"stored in the instance.  A variety of primitive C types are supported, and "
"access may be read-only or read-write.  The structures in the table are "
"defined as::"
msgstr ""
"Вторая таблица используется для определения атрибутов, которые напрямую "
"сопоставляются с данными, хранящимися в экземпляре. Поддерживаются различные "
"примитивные типы C, и доступ может быть только для чтения или для чтения и "
"записи. Структуры в таблице определены как:"

#: ../../extending/newtypes.rst:287
msgid ""
"For each entry in the table, a :term:`descriptor` will be constructed and "
"added to the type which will be able to extract a value from the instance "
"structure.  The :c:member:`~PyMemberDef.type` field should contain one of "
"the type codes defined in the :file:`structmember.h` header; the value will "
"be used to determine how to convert Python values to and from C values.  "
"The :c:member:`~PyMemberDef.flags` field is used to store flags which "
"control how the attribute can be accessed."
msgstr ""

#: ../../extending/newtypes.rst:294
msgid ""
"The following flag constants are defined in :file:`structmember.h`; they may "
"be combined using bitwise-OR."
msgstr ""

#: ../../extending/newtypes.rst:298
msgid "Constant"
msgstr "Константа"

#: ../../extending/newtypes.rst:298
msgid "Meaning"
msgstr "Значение"

#: ../../extending/newtypes.rst:300
msgid ":const:`READONLY`"
msgstr ""

#: ../../extending/newtypes.rst:300
msgid "Never writable."
msgstr ""

#: ../../extending/newtypes.rst:302
msgid ":const:`PY_AUDIT_READ`"
msgstr ""

#: ../../extending/newtypes.rst:302
msgid ""
"Emit an ``object.__getattr__`` :ref:`audit events <audit-events>` before "
"reading."
msgstr ""

#: ../../extending/newtypes.rst:307
msgid ""
":c:macro:`RESTRICTED`, :c:macro:`READ_RESTRICTED` and :c:macro:"
"`WRITE_RESTRICTED` are deprecated. However, :c:macro:`READ_RESTRICTED` is an "
"alias for :c:macro:`PY_AUDIT_READ`, so fields that specify either :c:macro:"
"`RESTRICTED` or :c:macro:`READ_RESTRICTED` will also raise an audit event."
msgstr ""

#: ../../extending/newtypes.rst:320
msgid ""
"An interesting advantage of using the :c:member:`~PyTypeObject.tp_members` "
"table to build descriptors that are used at runtime is that any attribute "
"defined this way can have an associated doc string simply by providing the "
"text in the table.  An application can use the introspection API to retrieve "
"the descriptor from the class object, and get the doc string using its :attr:"
"`!__doc__` attribute."
msgstr ""

#: ../../extending/newtypes.rst:326
msgid ""
"As with the :c:member:`~PyTypeObject.tp_methods` table, a sentinel entry "
"with a :c:member:`~PyMethodDef.ml_name` value of ``NULL`` is required."
msgstr ""
"Как и в случае с таблицей :c:member:`~PyTypeObject.tp_methods`, требуется "
"контрольная запись со значением :c:member:`~PyMethodDef.ml_name`, равным "
"``NULL``."

#: ../../extending/newtypes.rst:340
msgid "Type-specific Attribute Management"
msgstr "Управление атрибутами, зависящими от типа"

#: ../../extending/newtypes.rst:342
msgid ""
"For simplicity, only the :c:expr:`char\\*` version will be demonstrated "
"here; the type of the name parameter is the only difference between the :c:"
"expr:`char\\*` and :c:expr:`PyObject*` flavors of the interface. This "
"example effectively does the same thing as the generic example above, but "
"does not use the generic support added in Python 2.2.  It explains how the "
"handler functions are called, so that if you do need to extend their "
"functionality, you'll understand what needs to be done."
msgstr ""
"Для простоты здесь будет продемонстрирована только версия :c:expr:`char\\*`; "
"тип параметра name — единственное различие между вариантами интерфейса :c:"
"expr:`char\\*` и :c:expr:`PyObject*`. Этот пример фактически делает то же "
"самое, что и общий пример выше, но не использует универсальную поддержку, "
"добавленную в Python 2.2. Там объясняется, как вызываются функции-"
"обработчики, так что если вам понадобится расширить их функциональность, вы "
"поймете, что нужно сделать."

#: ../../extending/newtypes.rst:350
msgid ""
"The :c:member:`~PyTypeObject.tp_getattr` handler is called when the object "
"requires an attribute look-up.  It is called in the same situations where "
"the :meth:`~object.__getattr__` method of a class would be called."
msgstr ""
"Обработчик :c:member:`~PyTypeObject.tp_getattr` вызывается, когда объекту "
"требуется поиск атрибута. Он вызывается в тех же ситуациях, когда вызывается "
"метод :meth:`~object.__getattr__` класса."

#: ../../extending/newtypes.rst:354
msgid "Here is an example::"
msgstr "Вот пример::"

#: ../../extending/newtypes.rst:370
msgid ""
"The :c:member:`~PyTypeObject.tp_setattr` handler is called when the :meth:"
"`~object.__setattr__` or :meth:`~object.__delattr__` method of a class "
"instance would be called.  When an attribute should be deleted, the third "
"parameter will be ``NULL``.  Here is an example that simply raises an "
"exception; if this were really all you wanted, the :c:member:`~PyTypeObject."
"tp_setattr` handler should be set to ``NULL``. ::"
msgstr ""
"Обработчик :c:member:`~PyTypeObject.tp_setattr` вызывается, когда будет "
"вызван метод :meth:`~object.__setattr__` или :meth:`~object.__delattr__` "
"экземпляра класса. Если атрибут необходимо удалить, третьим параметром будет "
"значение NULL. Вот пример, который просто вызывает исключение; если бы это "
"было действительно все, что вам нужно, обработчик :c:member:`~PyTypeObject."
"tp_setattr` должен быть установлен в значение ``NULL``. ::"

#: ../../extending/newtypes.rst:384
msgid "Object Comparison"
msgstr "Сравнение объектов"

#: ../../extending/newtypes.rst:390
msgid ""
"The :c:member:`~PyTypeObject.tp_richcompare` handler is called when "
"comparisons are needed.  It is analogous to the :ref:`rich comparison "
"methods <richcmpfuncs>`, like :meth:`!__lt__`, and also called by :c:func:"
"`PyObject_RichCompare` and :c:func:`PyObject_RichCompareBool`."
msgstr ""
"Обработчик :c:member:`~PyTypeObject.tp_richcompare` вызывается, когда "
"необходимо сравнение. Он аналогичен :ref:`методам расширенного сравнения "
"<richcmpfuncs>`, например :meth:`!__lt__`, и также вызывается :c:func:"
"`PyObject_RichCompare` и :c:func:`PyObject_RichCompareBool`."

#: ../../extending/newtypes.rst:395
msgid ""
"This function is called with two Python objects and the operator as "
"arguments, where the operator is one of ``Py_EQ``, ``Py_NE``, ``Py_LE``, "
"``Py_GE``, ``Py_LT`` or ``Py_GT``.  It should compare the two objects with "
"respect to the specified operator and return ``Py_True`` or ``Py_False`` if "
"the comparison is successful, ``Py_NotImplemented`` to indicate that "
"comparison is not implemented and the other object's comparison method "
"should be tried, or ``NULL`` if an exception was set."
msgstr ""
"Эта функция вызывается с двумя объектами Python и оператором в качестве "
"аргументов, где оператором является один из ``Py_EQ``, ``Py_NE``, ``Py_LE``, "
"``Py_GE``, ``Py_LT`` или ``Py_GT``. Он должен сравнить два объекта "
"относительно указанного оператора и вернуть Py_True или Py_False, если "
"сравнение прошло успешно, Py_NotImplemented, чтобы указать, что сравнение не "
"реализовано и метод сравнения другого объекта должен быть опробовано, или "
"``NULL``, если было установлено исключение."

#: ../../extending/newtypes.rst:403
msgid ""
"Here is a sample implementation, for a datatype that is considered equal if "
"the size of an internal pointer is equal::"
msgstr ""
"Вот пример реализации типа данных, который считается равным, если размер "
"внутреннего указателя равен:"

#: ../../extending/newtypes.rst:433
msgid "Abstract Protocol Support"
msgstr "Поддержка абстрактных протоколов"

#: ../../extending/newtypes.rst:435
msgid ""
"Python supports a variety of *abstract* 'protocols;' the specific interfaces "
"provided to use these interfaces are documented in :ref:`abstract`."
msgstr ""
"Python поддерживает множество *абстрактных* «протоколов»; конкретные "
"интерфейсы, предоставленные для использования этих интерфейсов, описаны в :"
"ref:`abstract`."

#: ../../extending/newtypes.rst:439
msgid ""
"A number of these abstract interfaces were defined early in the development "
"of the Python implementation.  In particular, the number, mapping, and "
"sequence protocols have been part of Python since the beginning.  Other "
"protocols have been added over time.  For protocols which depend on several "
"handler routines from the type implementation, the older protocols have been "
"defined as optional blocks of handlers referenced by the type object.  For "
"newer protocols there are additional slots in the main type object, with a "
"flag bit being set to indicate that the slots are present and should be "
"checked by the interpreter.  (The flag bit does not indicate that the slot "
"values are non-``NULL``. The flag may be set to indicate the presence of a "
"slot, but a slot may still be unfilled.) ::"
msgstr ""
"Некоторые из этих абстрактных интерфейсов были определены на ранних стадиях "
"разработки реализации Python. В частности, протоколы чисел, сопоставления и "
"последовательности были частью Python с самого начала. Со временем были "
"добавлены и другие протоколы. Для протоколов, которые зависят от нескольких "
"подпрограмм-обработчиков из реализации типа, более старые протоколы были "
"определены как необязательные блоки обработчиков, на которые ссылается "
"объект типа. Для более новых протоколов в объекте основного типа имеются "
"дополнительные слоты, при этом устанавливается бит флага, указывающий, что "
"слоты присутствуют и должны быть проверены интерпретатором. (Бит флага не "
"указывает на то, что значения слота не равны NULL. Флаг может быть "
"установлен для указания наличия слота, но слот все равно может быть "
"незаполненным.) ::"

#: ../../extending/newtypes.rst:454
msgid ""
"If you wish your object to be able to act like a number, a sequence, or a "
"mapping object, then you place the address of a structure that implements "
"the C type :c:type:`PyNumberMethods`, :c:type:`PySequenceMethods`, or :c:"
"type:`PyMappingMethods`, respectively. It is up to you to fill in this "
"structure with appropriate values. You can find examples of the use of each "
"of these in the :file:`Objects` directory of the Python source "
"distribution. ::"
msgstr ""
"Если вы хотите, чтобы ваш объект мог действовать как число, "
"последовательность или объект сопоставления, вы помещаете адрес структуры, "
"реализующей тип C :c:type:`PyNumberMethods`, :c:type:` PySequenceMethods` "
"или :c:type:`PyMappingMethods` соответственно. Вам предстоит заполнить эту "
"структуру соответствующими значениями. Вы можете найти примеры использования "
"каждого из них в каталоге :file:`Objects` дистрибутива исходного кода "
"Python. ::"

#: ../../extending/newtypes.rst:463
msgid ""
"This function, if you choose to provide it, should return a hash number for "
"an instance of your data type. Here is a simple example::"
msgstr ""
"Эта функция, если вы решите ее предоставить, должна возвращать хэш-число "
"экземпляра вашего типа данных. Вот простой пример:"

#: ../../extending/newtypes.rst:476
msgid ""
":c:type:`!Py_hash_t` is a signed integer type with a platform-varying width. "
"Returning ``-1`` from :c:member:`~PyTypeObject.tp_hash` indicates an error, "
"which is why you should be careful to avoid returning it when hash "
"computation is successful, as seen above."
msgstr ""
":c:type:`!Py_hash_t` — это целочисленный тип со знаком, ширина которого "
"зависит от платформы. Возврат ``-1`` из :c:member:`~PyTypeObject.tp_hash` "
"указывает на ошибку, поэтому вам следует быть осторожным, чтобы не "
"возвращать его при успешном вычислении хэша, как показано выше."

#: ../../extending/newtypes.rst:485
msgid ""
"This function is called when an instance of your data type is \"called\", "
"for example, if ``obj1`` is an instance of your data type and the Python "
"script contains ``obj1('hello')``, the :c:member:`~PyTypeObject.tp_call` "
"handler is invoked."
msgstr ""
"Эта функция вызывается, когда «вызывается» экземпляр вашего типа данных, "
"например, если ``obj1`` является экземпляром вашего типа данных и скрипт "
"Python содержит ``obj1('hello')``, то: Вызывается обработчик c:member:"
"`~PyTypeObject.tp_call`."

#: ../../extending/newtypes.rst:489
msgid "This function takes three arguments:"
msgstr "Эта функция принимает три аргумента:"

#: ../../extending/newtypes.rst:491
msgid ""
"*self* is the instance of the data type which is the subject of the call. If "
"the call is ``obj1('hello')``, then *self* is ``obj1``."
msgstr ""
"*self* — это экземпляр типа данных, который является предметом вызова. Если "
"вызов — ``obj1('hello')``, то *self* — это ``obj1``."

#: ../../extending/newtypes.rst:494
msgid ""
"*args* is a tuple containing the arguments to the call.  You can use :c:func:"
"`PyArg_ParseTuple` to extract the arguments."
msgstr ""
"*args* — это кортеж, содержащий аргументы вызова. Вы можете использовать :c:"
"func:`PyArg_ParseTuple` для извлечения аргументов."

#: ../../extending/newtypes.rst:497
msgid ""
"*kwds* is a dictionary of keyword arguments that were passed. If this is non-"
"``NULL`` and you support keyword arguments, use :c:func:"
"`PyArg_ParseTupleAndKeywords` to extract the arguments.  If you do not want "
"to support keyword arguments and this is non-``NULL``, raise a :exc:"
"`TypeError` with a message saying that keyword arguments are not supported."
msgstr ""
"*kwds* — это словарь переданных аргументов ключевого слова. Если это "
"значение не NULL и вы поддерживаете аргументы ключевых слов, используйте :c:"
"func:`PyArg_ParseTupleAndKeywords` для извлечения аргументов. Если вы не "
"хотите поддерживать аргументы ключевого слова и это не NULL, вызовите :exc:"
"`TypeError` с сообщением о том, что аргументы ключевого слова не "
"поддерживаются."

#: ../../extending/newtypes.rst:503
msgid "Here is a toy ``tp_call`` implementation::"
msgstr "Вот игрушечная реализация ``tp_call``::"

#: ../../extending/newtypes.rst:529
msgid ""
"These functions provide support for the iterator protocol.  Both handlers "
"take exactly one parameter, the instance for which they are being called, "
"and return a new reference.  In the case of an error, they should set an "
"exception and return ``NULL``.  :c:member:`~PyTypeObject.tp_iter` "
"corresponds to the Python :meth:`~object.__iter__` method, while :c:member:"
"`~PyTypeObject.tp_iternext` corresponds to the Python :meth:`~iterator."
"__next__` method."
msgstr ""
"Эти функции обеспечивают поддержку протокола итератора. Оба обработчика "
"принимают ровно один параметр — экземпляр, для которого они вызываются, — и "
"возвращают новую ссылку. В случае ошибки они должны установить исключение и "
"вернуть NULL. :c:member:`~PyTypeObject.tp_iter` соответствует методу Python :"
"meth:`~object.__iter__`, а :c:member:`~PyTypeObject.tp_iternext` "
"соответствует методу Python :meth:`~iterator.__next__ `метод."

#: ../../extending/newtypes.rst:536
msgid ""
"Any :term:`iterable` object must implement the :c:member:`~PyTypeObject."
"tp_iter` handler, which must return an :term:`iterator` object.  Here the "
"same guidelines apply as for Python classes:"
msgstr ""
"Любой объект :term:`iterable` должен реализовывать обработчик :c:member:"
"`~PyTypeObject.tp_iter`, который должен возвращать объект :term:`iterator`. "
"Здесь применяются те же правила, что и для классов Python:"

#: ../../extending/newtypes.rst:540
msgid ""
"For collections (such as lists and tuples) which can support multiple "
"independent iterators, a new iterator should be created and returned by each "
"call to :c:member:`~PyTypeObject.tp_iter`."
msgstr ""
"Для коллекций (таких как списки и кортежи), которые могут поддерживать "
"несколько независимых итераторов, новый итератор должен создаваться и "
"возвращаться при каждом вызове :c:member:`~PyTypeObject.tp_iter`."

#: ../../extending/newtypes.rst:543
msgid ""
"Objects which can only be iterated over once (usually due to side effects of "
"iteration, such as file objects) can implement :c:member:`~PyTypeObject."
"tp_iter` by returning a new reference to themselves -- and should also "
"therefore implement the :c:member:`~PyTypeObject.tp_iternext`  handler."
msgstr ""
"Объекты, которые можно итерировать только один раз (обычно из-за побочных "
"эффектов итерации, например файловых объектов), могут реализовать :c:member:"
"`~PyTypeObject.tp_iter`, возвращая новую ссылку на себя - и, следовательно, "
"также должны реализовывать :c:member:`~PyTypeObject.tp_iternext` обработчик."

#: ../../extending/newtypes.rst:548
msgid ""
"Any :term:`iterator` object should implement both :c:member:`~PyTypeObject."
"tp_iter` and :c:member:`~PyTypeObject.tp_iternext`.  An iterator's :c:member:"
"`~PyTypeObject.tp_iter` handler should return a new reference to the "
"iterator.  Its :c:member:`~PyTypeObject.tp_iternext` handler should return a "
"new reference to the next object in the iteration, if there is one. If the "
"iteration has reached the end, :c:member:`~PyTypeObject.tp_iternext` may "
"return ``NULL`` without setting an exception, or it may set :exc:"
"`StopIteration` *in addition* to returning ``NULL``; avoiding the exception "
"can yield slightly better performance.  If an actual error occurs, :c:member:"
"`~PyTypeObject.tp_iternext` should always set an exception and return "
"``NULL``."
msgstr ""
"Любой объект :term:`iterator` должен реализовывать как :c:member:"
"`~PyTypeObject.tp_iter`, так и :c:member:`~PyTypeObject.tp_iternext`. "
"Обработчик :c:member:`~PyTypeObject.tp_iter` итератора должен возвращать "
"новую ссылку на итератор. Его обработчик :c:member:`~PyTypeObject."
"tp_iternext` должен возвращать новую ссылку на следующий объект в итерации, "
"если таковой имеется. Если итерация достигла конца, :c:member:`~PyTypeObject."
"tp_iternext` может вернуть ``NULL`` без установки исключения или может "
"установить :exc:`StopIteration` *в дополнение* к возврату ``NULL` ``; "
"избегание исключения может привести к несколько более высокой "
"производительности. Если происходит фактическая ошибка, :c:member:"
"`~PyTypeObject.tp_iternext` всегда должен устанавливать исключение и "
"возвращать ``NULL``."

#: ../../extending/newtypes.rst:564
msgid "Weak Reference Support"
msgstr "Слабая справочная поддержка"

#: ../../extending/newtypes.rst:566
msgid ""
"One of the goals of Python's weak reference implementation is to allow any "
"type to participate in the weak reference mechanism without incurring the "
"overhead on performance-critical objects (such as numbers)."
msgstr ""
"Одна из целей реализации слабых ссылок в Python — позволить любому типу "
"участвовать в механизме слабых ссылок без дополнительных затрат на объекты, "
"критичные к производительности (такие как числа)."

#: ../../extending/newtypes.rst:571
msgid "Documentation for the :mod:`weakref` module."
msgstr "Документация для модуля :mod:`weakref`."

#: ../../extending/newtypes.rst:573
msgid ""
"For an object to be weakly referencable, the extension type must do two "
"things:"
msgstr ""

#: ../../extending/newtypes.rst:575
msgid ""
"Include a :c:expr:`PyObject*` field in the C object structure dedicated to "
"the weak reference mechanism.  The object's constructor should leave it "
"``NULL`` (which is automatic when using the default :c:member:`~PyTypeObject."
"tp_alloc`)."
msgstr ""

#: ../../extending/newtypes.rst:580
msgid ""
"Set the :c:member:`~PyTypeObject.tp_weaklistoffset` type member to the "
"offset of the aforementioned field in the C object structure, so that the "
"interpreter knows how to access and modify that field."
msgstr ""

#: ../../extending/newtypes.rst:584
msgid ""
"Concretely, here is how a trivial object structure would be augmented with "
"the required field::"
msgstr ""

#: ../../extending/newtypes.rst:592
msgid "And the corresponding member in the statically declared type object::"
msgstr ""

#: ../../extending/newtypes.rst:600
msgid ""
"The only further addition is that ``tp_dealloc`` needs to clear any weak "
"references (by calling :c:func:`PyObject_ClearWeakRefs`) if the field is non-"
"``NULL``::"
msgstr ""

#: ../../extending/newtypes.rst:616
msgid "More Suggestions"
msgstr "Еще предложения"

#: ../../extending/newtypes.rst:618
msgid ""
"In order to learn how to implement any specific method for your new data "
"type, get the :term:`CPython` source code.  Go to the :file:`Objects` "
"directory, then search the C source files for ``tp_`` plus the function you "
"want (for example, ``tp_richcompare``).  You will find examples of the "
"function you want to implement."
msgstr ""
"Чтобы узнать, как реализовать какой-либо конкретный метод для вашего нового "
"типа данных, получите исходный код :term:`CPython`. Перейдите в каталог :"
"file:`Objects`, затем выполните поиск в исходных файлах C по запросу ``tp_`` "
"и нужной функции (например, ``tp_richcompare``). Вы найдете примеры функций, "
"которые хотите реализовать."

#: ../../extending/newtypes.rst:624
msgid ""
"When you need to verify that an object is a concrete instance of the type "
"you are implementing, use the :c:func:`PyObject_TypeCheck` function.  A "
"sample of its use might be something like the following::"
msgstr ""
"Если вам нужно убедиться, что объект является конкретным экземпляром "
"реализуемого вами типа, используйте функцию :c:func:`PyObject_TypeCheck`. "
"Пример его использования может быть примерно следующим:"

#: ../../extending/newtypes.rst:635
msgid "Download CPython source releases."
msgstr "Загрузите исходные версии CPython."

#: ../../extending/newtypes.rst:635
msgid "https://www.python.org/downloads/source/"
msgstr "https://www.python.org/downloads/source/"

#: ../../extending/newtypes.rst:637
msgid ""
"The CPython project on GitHub, where the CPython source code is developed."
msgstr "Проект CPython на GitHub, где разрабатывается исходный код CPython."

#: ../../extending/newtypes.rst:638
msgid "https://github.com/python/cpython"
msgstr "https://github.com/python/cpython"

#: ../../extending/newtypes.rst:56
msgid "object"
msgstr "объект"

#: ../../extending/newtypes.rst:56
msgid "deallocation"
msgstr "освобождение"

#: ../../extending/newtypes.rst:56
msgid "deallocation, object"
msgstr "освобождение, объект"

#: ../../extending/newtypes.rst:56
msgid "finalization"
msgstr "завершение"

#: ../../extending/newtypes.rst:56
msgid "finalization, of objects"
msgstr "доработка объектов"

#: ../../extending/newtypes.rst:91
msgid "PyErr_Fetch (C function)"
msgstr "PyErr_Fetch (C функция)"

#: ../../extending/newtypes.rst:91
msgid "PyErr_Restore (C function)"
msgstr "PyErr_Restore (C функция)"

#: ../../extending/newtypes.rst:150
msgid "string"
msgstr "строка"

#: ../../extending/newtypes.rst:150
msgid "object representation"
msgstr "представление объекта"

#: ../../extending/newtypes.rst:150
msgid "built-in function"
msgstr "встроенная функция"

#: ../../extending/newtypes.rst:150
msgid "repr"
msgstr "repr"

#: ../../extending/newtypes.rst:313
msgid "READONLY"
msgstr ""

#: ../../extending/newtypes.rst:313
msgid "READ_RESTRICTED"
msgstr ""

#: ../../extending/newtypes.rst:313
msgid "WRITE_RESTRICTED"
msgstr ""

#: ../../extending/newtypes.rst:313
msgid "RESTRICTED"
msgstr ""

#: ../../extending/newtypes.rst:313
msgid "PY_AUDIT_READ"
msgstr ""
