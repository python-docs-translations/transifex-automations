# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmitriy Q, 2023
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-21 22:20+0000\n"
"PO-Revision-Date: 2023-05-24 02:17+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/logging.handlers.rst:2
msgid ":mod:`logging.handlers` --- Logging handlers"
msgstr ""

#: ../../library/logging.handlers.rst:10
msgid "**Source code:** :source:`Lib/logging/handlers.py`"
msgstr "**Исходный код:** :source:`Lib/logging/handlers.py`"

#: ../../library/logging.handlers.rst:14
msgid ""
"This page contains only reference information. For tutorials, please see"
msgstr ":mod:`!logging.config` --- Конфигурация журналирования"

#: ../../library/logging.handlers.rst:17
msgid ":ref:`Basic Tutorial <logging-basic-tutorial>`"
msgstr ":ref:`Basic Tutorial <logging-basic-tutorial>`"

#: ../../library/logging.handlers.rst:18
msgid ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"

#: ../../library/logging.handlers.rst:19
msgid ":ref:`Logging Cookbook <logging-cookbook>`"
msgstr ":ref:`Logging Cookbook <logging-cookbook>`"

#: ../../library/logging.handlers.rst:25
msgid ""
"The following useful handlers are provided in the package. Note that three "
"of the handlers (:class:`StreamHandler`, :class:`FileHandler` and :class:"
"`NullHandler`) are actually defined in the :mod:`logging` module itself, but "
"have been documented here along with the other handlers."
msgstr ""
"В пакете предусмотрены следующие полезные обработчики. Обратите внимание, "
"что три обработчика (:class:`StreamHandler`, :class:`FileHandler` и :class:"
"`NullHandler`) на самом деле определены в самом модуле :mod:`logging`, но "
"они документированы здесь вместе с другие обработчики."

#: ../../library/logging.handlers.rst:33
msgid "StreamHandler"
msgstr "StreamHandler"

#: ../../library/logging.handlers.rst:35
msgid ""
"The :class:`StreamHandler` class, located in the core :mod:`logging` "
"package, sends logging output to streams such as *sys.stdout*, *sys.stderr* "
"or any file-like object (or, more precisely, any object which supports :meth:"
"`write` and :meth:`flush` methods)."
msgstr ""
"Класс :class:`StreamHandler`, расположенный в базовом пакете :mod:`logging`, "
"отправляет выходные данные журналирования в такие потоки, как *sys.stdout*, "
"*sys.stderr* или любой файлоподобный объект (или, точнее, , любой объект, "
"который поддерживает методы :meth:`write` и :meth:`flush`)."

#: ../../library/logging.handlers.rst:43
msgid ""
"Returns a new instance of the :class:`StreamHandler` class. If *stream* is "
"specified, the instance will use it for logging output; otherwise, *sys."
"stderr* will be used."
msgstr ""
"Возвращает новый экземпляр класса :class:`StreamHandler`. Если указан "
"*stream*, экземпляр будет использовать его для протоколирования вывода; в "
"противном случае будет использоваться *sys.stderr*."

#: ../../library/logging.handlers.rst:50
msgid ""
"If a formatter is specified, it is used to format the record. The record is "
"then written to the stream followed by :attr:`terminator`. If exception "
"information is present, it is formatted using :func:`traceback."
"print_exception` and appended to the stream."
msgstr ""
"Если указан форматтер, он используется для форматирования записи. Затем "
"запись записывается в поток, за которым следует :attr:`terminator`. Если "
"информация об исключении присутствует, она форматируется с использованием :"
"func:`traceback.print_Exception` и добавляется в поток."

#: ../../library/logging.handlers.rst:58
msgid ""
"Flushes the stream by calling its :meth:`flush` method. Note that the :meth:"
"`close` method is inherited from :class:`~logging.Handler` and so does no "
"output, so an explicit :meth:`flush` call may be needed at times."
msgstr ""
"Сбрасывает поток, вызывая его метод :meth:`flush`. Обратите внимание, что "
"метод :meth:`close` унаследован от :class:`~logging.Handler` и поэтому не "
"производит вывода, поэтому иногда может потребоваться явный вызов :meth:"
"`flush`."

#: ../../library/logging.handlers.rst:64
msgid ""
"Sets the instance's stream to the specified value, if it is different. The "
"old stream is flushed before the new stream is set."
msgstr ""
"Устанавливает поток экземпляра в указанное значение, если оно отличается. "
"Старый поток сбрасывается перед установкой нового потока."

#: ../../library/logging.handlers.rst:0
msgid "Parameters"
msgstr "Параметры"

#: ../../library/logging.handlers.rst:67
msgid "The stream that the handler should use."
msgstr "Поток, который должен использовать обработчик."

#: ../../library/logging.handlers.rst:0
msgid "Returns"
msgstr "Возврат"

#: ../../library/logging.handlers.rst:69
msgid "the old stream, if the stream was changed, or *None* if it wasn't."
msgstr ""

#: ../../library/logging.handlers.rst:75
msgid ""
"String used as the terminator when writing a formatted record to a stream. "
"Default value is ``'\\n'``."
msgstr ""
"Строка, используемая в качестве терминатора при записи форматированной "
"записи в поток. Значение по умолчанию — ``'\\n'``."

#: ../../library/logging.handlers.rst:78
msgid ""
"If you don't want a newline termination, you can set the handler instance's "
"``terminator`` attribute to the empty string."
msgstr ""
"Если вам не нужно завершение новой строки, вы можете установить атрибут "
"терминатора экземпляра обработчика на пустую строку."

#: ../../library/logging.handlers.rst:81
msgid "In earlier versions, the terminator was hardcoded as ``'\\n'``."
msgstr ""
"В более ранних версиях терминатор был жестко запрограммирован как ``'\\n'``."

#: ../../library/logging.handlers.rst:89
msgid "FileHandler"
msgstr "FileHandler"

#: ../../library/logging.handlers.rst:91
msgid ""
"The :class:`FileHandler` class, located in the core :mod:`logging` package, "
"sends logging output to a disk file.  It inherits the output functionality "
"from :class:`StreamHandler`."
msgstr ""
"Класс :class:`FileHandler`, расположенный в базовом пакете :mod:`logging`, "
"отправляет выходные данные журнала в файл на диске. Он наследует "
"функциональность вывода от :class:`StreamHandler`."

#: ../../library/logging.handlers.rst:98
msgid ""
"Returns a new instance of the :class:`FileHandler` class. The specified file "
"is opened and used as the stream for logging. If *mode* is not specified, "
"``'a'`` is used.  If *encoding* is not ``None``, it is used to open the file "
"with that encoding.  If *delay* is true, then file opening is deferred until "
"the first call to :meth:`emit`. By default, the file grows indefinitely. If "
"*errors* is specified, it's used to determine how encoding errors are "
"handled."
msgstr ""
"Возвращает новый экземпляр класса :class:`FileHandler`. Указанный файл "
"открывается и используется в качестве потока для протоколирования. Если "
"*mode* не указан, используется ``'a'``. Если *кодировка* не равна «Нет», она "
"используется для открытия файла с этой кодировкой. Если *delay* имеет "
"значение true, то открытие файла откладывается до первого вызова :meth:"
"`emit`. По умолчанию файл растет бесконечно. Если указано *errors*, оно "
"используется для определения способа обработки ошибок кодирования."

#: ../../library/logging.handlers.rst:105
#: ../../library/logging.handlers.rst:190
#: ../../library/logging.handlers.rst:338
#: ../../library/logging.handlers.rst:444
msgid ""
"As well as string values, :class:`~pathlib.Path` objects are also accepted "
"for the *filename* argument."
msgstr ""
"Помимо строковых значений, в качестве аргумента *filename* также принимаются "
"объекты :class:`~pathlib.Path`."

#: ../../library/logging.handlers.rst:109
#: ../../library/logging.handlers.rst:194
#: ../../library/logging.handlers.rst:342
#: ../../library/logging.handlers.rst:448
msgid "The *errors* parameter was added."
msgstr "Добавлен параметр *errors*."

#: ../../library/logging.handlers.rst:114
msgid "Closes the file."
msgstr "Закрывает файл."

#: ../../library/logging.handlers.rst:118
msgid "Outputs the record to the file."
msgstr "Выводит запись в файл."

#: ../../library/logging.handlers.rst:120
msgid ""
"Note that if the file was closed due to logging shutdown at exit and the "
"file mode is 'w', the record will not be emitted (see :issue:`42378`)."
msgstr ""
"Обратите внимание: если файл был закрыт из-за прекращения регистрации при "
"выходе и режим файла равен «w», запись не будет создана (см. :issue:`42378`)."

#: ../../library/logging.handlers.rst:127
msgid "NullHandler"
msgstr "NullHandler"

#: ../../library/logging.handlers.rst:131
msgid ""
"The :class:`NullHandler` class, located in the core :mod:`logging` package, "
"does not do any formatting or output. It is essentially a 'no-op' handler "
"for use by library developers."
msgstr ""
"Класс :class:`NullHandler`, расположенный в базовом пакете :mod:`logging`, "
"не выполняет никакого форматирования или вывода. По сути, это "
"«бездействующий» обработчик, используемый разработчиками библиотек."

#: ../../library/logging.handlers.rst:137
msgid "Returns a new instance of the :class:`NullHandler` class."
msgstr "Возвращает новый экземпляр класса :class:`NullHandler`."

#: ../../library/logging.handlers.rst:141
#: ../../library/logging.handlers.rst:145
msgid "This method does nothing."
msgstr "Этот метод ничего не делает."

#: ../../library/logging.handlers.rst:149
msgid ""
"This method returns ``None`` for the lock, since there is no underlying I/O "
"to which access needs to be serialized."
msgstr ""
"Этот метод возвращает None для блокировки, поскольку нет базового ввода-"
"вывода, доступ к которому необходимо сериализовать."

#: ../../library/logging.handlers.rst:153
msgid ""
"See :ref:`library-config` for more information on how to use :class:"
"`NullHandler`."
msgstr ""
"См. :ref:`library-config` для получения дополнительной информации о том, как "
"использовать :class:`NullHandler`."

#: ../../library/logging.handlers.rst:159
msgid "WatchedFileHandler"
msgstr "WatchedFileHandler"

#: ../../library/logging.handlers.rst:163
msgid ""
"The :class:`WatchedFileHandler` class, located in the :mod:`logging."
"handlers` module, is a :class:`FileHandler` which watches the file it is "
"logging to. If the file changes, it is closed and reopened using the file "
"name."
msgstr ""
"Класс :class:`WatchedFileHandler`, расположенный в модуле :mod:`logging."
"handlers`, представляет собой :class:`FileHandler`, который отслеживает "
"файл, в который он записывает данные. Если файл изменяется, он закрывается и "
"снова открывается с использованием имени файла."

#: ../../library/logging.handlers.rst:167
msgid ""
"A file change can happen because of usage of programs such as *newsyslog* "
"and *logrotate* which perform log file rotation. This handler, intended for "
"use under Unix/Linux, watches the file to see if it has changed since the "
"last emit. (A file is deemed to have changed if its device or inode have "
"changed.) If the file has changed, the old file stream is closed, and the "
"file opened to get a new stream."
msgstr ""
"Изменение файла может произойти из-за использования таких программ, как "
"*newsyslog* и *logrotate*, которые выполняют ротацию файлов журналов. Этот "
"обработчик, предназначенный для использования в Unix/Linux, отслеживает "
"файл, чтобы увидеть, не изменился ли он с момента последней отправки. (Файл "
"считается изменившимся, если изменилось его устройство или индексный "
"дескриптор.) Если файл изменился, старый файловый поток закрывается, а файл "
"открывается для получения нового потока."

#: ../../library/logging.handlers.rst:174
msgid ""
"This handler is not appropriate for use under Windows, because under Windows "
"open log files cannot be moved or renamed - logging opens the files with "
"exclusive locks - and so there is no need for such a handler. Furthermore, "
"*ST_INO* is not supported under Windows; :func:`~os.stat` always returns "
"zero for this value."
msgstr ""
"Этот обработчик не подходит для использования в Windows, поскольку в Windows "
"открытые файлы журналов нельзя перемещать или переименовывать — при ведении "
"журнала файлы открываются с монопольной блокировкой, поэтому в таком "
"обработчике нет необходимости. Более того, *ST_INO* не поддерживается в "
"Windows; :func:`~os.stat` всегда возвращает ноль для этого значения."

#: ../../library/logging.handlers.rst:183
msgid ""
"Returns a new instance of the :class:`WatchedFileHandler` class. The "
"specified file is opened and used as the stream for logging. If *mode* is "
"not specified, ``'a'`` is used.  If *encoding* is not ``None``, it is used "
"to open the file with that encoding.  If *delay* is true, then file opening "
"is deferred until the first call to :meth:`emit`.  By default, the file "
"grows indefinitely. If *errors* is provided, it determines how encoding "
"errors are handled."
msgstr ""
"Возвращает новый экземпляр класса :class:`WatchedFileHandler`. Указанный "
"файл открывается и используется в качестве потока для протоколирования. Если "
"*mode* не указан, используется ``'a'``. Если *кодировка* не равна «Нет», она "
"используется для открытия файла с этой кодировкой. Если *delay* имеет "
"значение true, то открытие файла откладывается до первого вызова :meth:"
"`emit`. По умолчанию файл растет бесконечно. Если указано *errors*, оно "
"определяет, как обрабатываются ошибки кодирования."

#: ../../library/logging.handlers.rst:199
msgid ""
"Checks to see if the file has changed.  If it has, the existing stream is "
"flushed and closed and the file opened again, typically as a precursor to "
"outputting the record to the file."
msgstr ""
"Проверяет, изменился ли файл. Если это так, существующий поток очищается и "
"закрывается, а файл открывается снова, обычно перед выводом записи в файл."

#: ../../library/logging.handlers.rst:208
msgid ""
"Outputs the record to the file, but first calls :meth:`reopenIfNeeded` to "
"reopen the file if it has changed."
msgstr ""
"Выводит запись в файл, но сначала вызывает :meth:`reopenIfNeeded`, чтобы "
"повторно открыть файл, если он изменился."

#: ../../library/logging.handlers.rst:214
msgid "BaseRotatingHandler"
msgstr "BaseRotatingHandler"

#: ../../library/logging.handlers.rst:216
msgid ""
"The :class:`BaseRotatingHandler` class, located in the :mod:`logging."
"handlers` module, is the base class for the rotating file handlers, :class:"
"`RotatingFileHandler` and :class:`TimedRotatingFileHandler`. You should not "
"need to instantiate this class, but it has attributes and methods you may "
"need to override."
msgstr ""
"Класс :class:`BaseRotatingHandler`, расположенный в модуле :mod:`logging."
"handlers`, является базовым классом для обработчиков вращающихся файлов: :"
"class:`RotatingFileHandler` и :class:`TimedRotatingFileHandler`. Вам не "
"нужно создавать экземпляр этого класса, но у него есть атрибуты и методы, "
"которые вам, возможно, придется переопределить."

#: ../../library/logging.handlers.rst:224
msgid "The parameters are as for :class:`FileHandler`. The attributes are:"
msgstr "Параметры такие же, как для :class:`FileHandler`. Атрибуты:"

#: ../../library/logging.handlers.rst:228
msgid ""
"If this attribute is set to a callable, the :meth:`rotation_filename` method "
"delegates to this callable. The parameters passed to the callable are those "
"passed to :meth:`rotation_filename`."
msgstr ""
"Если этот атрибут установлен в вызываемый объект, метод :meth:"
"`rotation_filename` делегирует этот вызываемый объект. Параметры, "
"передаваемые вызываемому объекту, — это те, которые передаются в :meth:"
"`rotation_filename`."

#: ../../library/logging.handlers.rst:232
msgid ""
"The namer function is called quite a few times during rollover, so it should "
"be as simple and as fast as possible. It should also return the same output "
"every time for a given input, otherwise the rollover behaviour may not work "
"as expected."
msgstr ""
"Функция namer вызывается довольно много раз во время ролловера, поэтому она "
"должна быть максимально простой и быстрой. Он также должен каждый раз "
"возвращать один и тот же результат для данного ввода, иначе поведение "
"опрокидывания может работать не так, как ожидалось."

#: ../../library/logging.handlers.rst:237
msgid ""
"It's also worth noting that care should be taken when using a namer to "
"preserve certain attributes in the filename which are used during rotation. "
"For example, :class:`RotatingFileHandler` expects to have a set of log files "
"whose names contain successive integers, so that rotation works as expected, "
"and :class:`TimedRotatingFileHandler` deletes old log files (based on the "
"``backupCount`` parameter passed to the handler's initializer) by "
"determining the oldest files to delete. For this to happen, the filenames "
"should be sortable using the date/time portion of the filename, and a namer "
"needs to respect this. (If a namer is wanted that doesn't respect this "
"scheme, it will need to be used in a subclass of :class:"
"`TimedRotatingFileHandler` which overrides the :meth:"
"`~TimedRotatingFileHandler.getFilesToDelete` method to fit in with the "
"custom naming scheme.)"
msgstr ""
"Также стоит отметить, что при использовании именования следует соблюдать "
"осторожность, чтобы сохранить в имени файла определенные атрибуты, которые "
"используются во время ротации. Например, :class:`RotatingFileHandler` "
"ожидает набор файлов журналов, имена которых содержат последовательные целые "
"числа, так что ротация работает должным образом, а :class:"
"`TimedRotatingFileHandler` удаляет старые файлы журналов (на основе "
"``backupCount`` параметр, передаваемый инициализатору обработчика), путем "
"определения самых старых файлов, подлежащих удалению. Чтобы это произошло, "
"имена файлов должны быть сортируемыми по части имени файла, содержащей дату/"
"время, и разработчик имен должен учитывать это. (Если требуется имя, не "
"соблюдающее эту схему, его необходимо будет использовать в подклассе :class:"
"`TimedRotatingFileHandler`, который переопределяет метод :meth:"
"`~TimedRotatingFileHandler.getFilesToDelete`, чтобы он соответствовал "
"пользовательскому именованию. схема.)"

#: ../../library/logging.handlers.rst:255
msgid ""
"If this attribute is set to a callable, the :meth:`rotate` method delegates "
"to this callable.  The parameters passed to the callable are those passed "
"to :meth:`rotate`."
msgstr ""
"Если для этого атрибута установлено значение вызываемого объекта, метод :"
"meth:`rotate` делегирует это вызываемому объекту. Параметры, передаваемые "
"вызываемому объекту, — это те, которые передаются в :meth:`rotate`."

#: ../../library/logging.handlers.rst:263
msgid "Modify the filename of a log file when rotating."
msgstr "Измените имя файла журнала при ротации."

#: ../../library/logging.handlers.rst:265
msgid "This is provided so that a custom filename can be provided."
msgstr "Это сделано для того, чтобы можно было указать собственное имя файла."

#: ../../library/logging.handlers.rst:267
msgid ""
"The default implementation calls the 'namer' attribute of the handler, if "
"it's callable, passing the default name to it. If the attribute isn't "
"callable (the default is ``None``), the name is returned unchanged."
msgstr ""
"Реализация по умолчанию вызывает атрибут обработчика namer, если он доступен "
"для вызова, передавая ему имя по умолчанию. Если атрибут не может быть "
"вызван (по умолчанию установлено значение «Нет»), имя возвращается без "
"изменений."

#: ../../library/logging.handlers.rst:271
msgid "The default name for the log file."
msgstr "Имя по умолчанию для файла журнала."

#: ../../library/logging.handlers.rst:278
msgid "When rotating, rotate the current log."
msgstr "При вращении вращайте текущий журнал."

#: ../../library/logging.handlers.rst:280
msgid ""
"The default implementation calls the 'rotator' attribute of the handler, if "
"it's callable, passing the source and dest arguments to it. If the attribute "
"isn't callable (the default is ``None``), the source is simply renamed to "
"the destination."
msgstr ""
"Реализация по умолчанию вызывает атрибут обработчика «rotator», если он "
"доступен для вызова, передавая ему аргументы source и dest. Если атрибут не "
"может быть вызван (по умолчанию установлено значение «Нет»), источник просто "
"переименовывается в пункт назначения."

#: ../../library/logging.handlers.rst:285
msgid ""
"The source filename. This is normally the base filename, e.g. 'test.log'."
msgstr ""
"Имя исходного файла. Обычно это базовое имя файла, например «test.log»."

#: ../../library/logging.handlers.rst:287
msgid ""
"The destination filename. This is normally what the source is rotated to, e."
"g. 'test.log.1'."
msgstr ""
"Имя файла назначения. Обычно это то, к чему приводится смена источника, "
"например, «test.log.1»."

#: ../../library/logging.handlers.rst:292
msgid ""
"The reason the attributes exist is to save you having to subclass - you can "
"use the same callables for instances of :class:`RotatingFileHandler` and :"
"class:`TimedRotatingFileHandler`. If either the namer or rotator callable "
"raises an exception, this will be handled in the same way as any other "
"exception during an :meth:`emit` call, i.e. via the :meth:`handleError` "
"method of the handler."
msgstr ""
"Причина существования атрибутов заключается в том, чтобы избавить вас от "
"необходимости создавать подклассы: вы можете использовать одни и те же "
"вызываемые объекты для экземпляров :class:`RotatingFileHandler` и :class:"
"`TimedRotatingFileHandler`. Если вызываемый объект namer или ротатора "
"вызывает исключение, оно будет обработано так же, как и любое другое "
"исключение во время вызова :meth:`emit`, то есть через метод :meth:"
"`handleError` обработчика."

#: ../../library/logging.handlers.rst:299
msgid ""
"If you need to make more significant changes to rotation processing, you can "
"override the methods."
msgstr ""
"Если вам нужно внести более существенные изменения в обработку вращения, вы "
"можете переопределить методы."

#: ../../library/logging.handlers.rst:302
msgid "For an example, see :ref:`cookbook-rotator-namer`."
msgstr "Пример см. в :ref:`cookbook-rotator-namer`."

#: ../../library/logging.handlers.rst:308
msgid "RotatingFileHandler"
msgstr "RotatingFileHandler"

#: ../../library/logging.handlers.rst:310
msgid ""
"The :class:`RotatingFileHandler` class, located in the :mod:`logging."
"handlers` module, supports rotation of disk log files."
msgstr ""
"Класс :class:`RotatingFileHandler`, расположенный в модуле :mod:`logging."
"handlers`, поддерживает ротацию файлов журналов диска."

#: ../../library/logging.handlers.rst:316
msgid ""
"Returns a new instance of the :class:`RotatingFileHandler` class. The "
"specified file is opened and used as the stream for logging. If *mode* is "
"not specified, ``'a'`` is used.  If *encoding* is not ``None``, it is used "
"to open the file with that encoding.  If *delay* is true, then file opening "
"is deferred until the first call to :meth:`emit`.  By default, the file "
"grows indefinitely. If *errors* is provided, it determines how encoding "
"errors are handled."
msgstr ""
"Возвращает новый экземпляр класса :class:`RotatingFileHandler`. Указанный "
"файл открывается и используется в качестве потока для протоколирования. Если "
"*mode* не указан, используется ``'a'``. Если *кодировка* не равна «Нет», она "
"используется для открытия файла с этой кодировкой. Если *delay* имеет "
"значение true, то открытие файла откладывается до первого вызова :meth:"
"`emit`. По умолчанию файл растет бесконечно. Если указано *errors*, оно "
"определяет, как обрабатываются ошибки кодирования."

#: ../../library/logging.handlers.rst:323
msgid ""
"You can use the *maxBytes* and *backupCount* values to allow the file to :"
"dfn:`rollover` at a predetermined size. When the size is about to be "
"exceeded, the file is closed and a new file is silently opened for output. "
"Rollover occurs whenever the current log file is nearly *maxBytes* in "
"length; but if either of *maxBytes* or *backupCount* is zero, rollover never "
"occurs, so you generally want to set *backupCount* to at least 1, and have a "
"non-zero *maxBytes*. When *backupCount* is non-zero, the system will save "
"old log files by appending the extensions '.1', '.2' etc., to the filename. "
"For example, with a *backupCount* of 5 and a base file name of :file:`app."
"log`, you would get :file:`app.log`, :file:`app.log.1`, :file:`app.log.2`, "
"up to :file:`app.log.5`. The file being written to is always :file:`app."
"log`.  When this file is filled, it is closed and renamed to :file:`app."
"log.1`, and if files :file:`app.log.1`, :file:`app.log.2`, etc. exist, then "
"they are renamed to :file:`app.log.2`, :file:`app.log.3` etc. respectively."
msgstr ""
"Вы можете использовать значения *maxBytes* и *backupCount*, чтобы позволить "
"файлу :dfn:`rollover` иметь заранее определенный размер. Когда размер "
"приближается к превышению, файл закрывается, и для вывода автоматически "
"открывается новый файл. Смена происходит всякий раз, когда длина текущего "
"файла журнала приближается к *maxBytes*; но если любой из *maxBytes* или "
"*backupCount* равен нулю, пролонгация никогда не происходит, поэтому обычно "
"требуется установить для *backupCount* значение не менее 1 и иметь ненулевое "
"значение *maxBytes*. Если *backupCount* не равно нулю, система сохранит "
"старые файлы журналов, добавив к имени файла расширения «.1», «.2» и т. д. "
"Например, при *backupCount*, равном 5, и базовом имени файла :file:`app."
"log`, вы получите :file:`app.log`, :file:`app.log.1`, :file :`app.log.2`, "
"до :file:`app.log.5`. Файл, в который производится запись, всегда имеет вид :"
"file:`app.log`. Когда этот файл заполнен, он закрывается и переименовывается "
"в :file:`app.log.1`, а если файлы :file:`app.log.1`, :file:`app.log.2` и т."
"д. существуют, то они переименовываются в :file:`app.log.2`, :file:`app."
"log.3` и т. д. соответственно."

#: ../../library/logging.handlers.rst:347
#: ../../library/logging.handlers.rst:453
msgid "Does a rollover, as described above."
msgstr "Делает ролловер, как описано выше."

#: ../../library/logging.handlers.rst:352
msgid ""
"Outputs the record to the file, catering for rollover as described "
"previously."
msgstr "Выводит запись в файл с возможностью опрокидывания, как описано ранее."

#: ../../library/logging.handlers.rst:358
msgid "TimedRotatingFileHandler"
msgstr "TimedRotatingFileHandler"

#: ../../library/logging.handlers.rst:360
msgid ""
"The :class:`TimedRotatingFileHandler` class, located in the :mod:`logging."
"handlers` module, supports rotation of disk log files at certain timed "
"intervals."
msgstr ""
"Класс :class:`TimedRotatingFileHandler`, расположенный в модуле :mod:"
"`logging.handlers`, поддерживает ротацию файлов журналов диска через "
"определенные промежутки времени."

#: ../../library/logging.handlers.rst:367
msgid ""
"Returns a new instance of the :class:`TimedRotatingFileHandler` class. The "
"specified file is opened and used as the stream for logging. On rotating it "
"also sets the filename suffix. Rotating happens based on the product of "
"*when* and *interval*."
msgstr ""
"Возвращает новый экземпляр класса :class:`TimedRotatingFileHandler`. "
"Указанный файл открывается и используется в качестве потока для "
"протоколирования. При вращении также устанавливается суффикс имени файла. "
"Вращение происходит на основе произведения *когда* и *интервал*."

#: ../../library/logging.handlers.rst:372
msgid ""
"You can use the *when* to specify the type of *interval*. The list of "
"possible values is below.  Note that they are not case sensitive."
msgstr ""
"Вы можете использовать *when*, чтобы указать тип *интервала*. Список "
"возможных значений приведен ниже. Обратите внимание, что они не "
"чувствительны к регистру."

#: ../../library/logging.handlers.rst:376
msgid "Value"
msgstr "Значение"

#: ../../library/logging.handlers.rst:376
msgid "Type of interval"
msgstr "Тип интервала"

#: ../../library/logging.handlers.rst:376
msgid "If/how *atTime* is used"
msgstr "Если/как используется *atTime*"

#: ../../library/logging.handlers.rst:378
msgid "``'S'``"
msgstr "``'S'``"

#: ../../library/logging.handlers.rst:378
msgid "Seconds"
msgstr "Секунды"

#: ../../library/logging.handlers.rst:378
#: ../../library/logging.handlers.rst:380
#: ../../library/logging.handlers.rst:382
#: ../../library/logging.handlers.rst:384
msgid "Ignored"
msgstr "игнорируется"

#: ../../library/logging.handlers.rst:380
msgid "``'M'``"
msgstr "``'M'``"

#: ../../library/logging.handlers.rst:380
msgid "Minutes"
msgstr "Минуты"

#: ../../library/logging.handlers.rst:382
msgid "``'H'``"
msgstr "``'H'``"

#: ../../library/logging.handlers.rst:382
msgid "Hours"
msgstr "Часы"

#: ../../library/logging.handlers.rst:384
msgid "``'D'``"
msgstr "``'D'``"

#: ../../library/logging.handlers.rst:384
msgid "Days"
msgstr "Дни"

#: ../../library/logging.handlers.rst:386
msgid "``'W0'-'W6'``"
msgstr "``'W0'-'W6'``"

#: ../../library/logging.handlers.rst:386
msgid "Weekday (0=Monday)"
msgstr "День недели (0=понедельник)"

#: ../../library/logging.handlers.rst:386
#: ../../library/logging.handlers.rst:389
msgid "Used to compute initial rollover time"
msgstr "Используется для расчета начального времени ролловера."

#: ../../library/logging.handlers.rst:389
msgid "``'midnight'``"
msgstr "``'midnight'``"

#: ../../library/logging.handlers.rst:389
msgid "Roll over at midnight, if *atTime* not specified, else at time *atTime*"
msgstr "Перенос в полночь, если *atTime* не указано, иначе во время *atTime*"

#: ../../library/logging.handlers.rst:394
msgid ""
"When using weekday-based rotation, specify 'W0' for Monday, 'W1' for "
"Tuesday, and so on up to 'W6' for Sunday. In this case, the value passed for "
"*interval* isn't used."
msgstr ""
"При использовании ротации по дням недели укажите «W0» для понедельника, «W1» "
"для вторника и т. д. до «W6» для воскресенья. В этом случае значение, "
"переданное для *interval*, не используется."

#: ../../library/logging.handlers.rst:398
msgid ""
"The system will save old log files by appending extensions to the filename. "
"The extensions are date-and-time based, using the strftime format ``%Y-%m-"
"%d_%H-%M-%S`` or a leading portion thereof, depending on the rollover "
"interval."
msgstr ""
"Система сохранит старые файлы журналов, добавив расширения к имени файла. "
"Расширения основаны на дате и времени, используя формат strftime ``%Y-%m- %д "
"_%H-%M-%S`` или его начальная часть, в зависимости от интервала переноса."

#: ../../library/logging.handlers.rst:403
msgid ""
"When computing the next rollover time for the first time (when the handler "
"is created), the last modification time of an existing log file, or else the "
"current time, is used to compute when the next rotation will occur."
msgstr ""
"При первом вычислении времени следующего ролловера (при создании "
"обработчика) для вычисления момента, когда произойдет следующий ролловер, "
"используется время последнего изменения существующего файла журнала или, в "
"противном случае, текущее время."

#: ../../library/logging.handlers.rst:407
msgid ""
"If the *utc* argument is true, times in UTC will be used; otherwise local "
"time is used."
msgstr ""
"Если аргумент *utc* имеет значение true, будет использоваться время в "
"формате UTC; в противном случае используется местное время."

#: ../../library/logging.handlers.rst:410
msgid ""
"If *backupCount* is nonzero, at most *backupCount* files will be kept, and "
"if more would be created when rollover occurs, the oldest one is deleted. "
"The deletion logic uses the interval to determine which files to delete, so "
"changing the interval may leave old files lying around."
msgstr ""
"Если *backupCount* не равно нулю, будет сохранено не более файлов "
"*backupCount*, а если при смене файлов будет создано больше файлов, самый "
"старый из них будет удален. Логика удаления использует интервал, чтобы "
"определить, какие файлы следует удалить, поэтому изменение интервала может "
"привести к тому, что старые файлы останутся лежать."

#: ../../library/logging.handlers.rst:415
msgid ""
"If *delay* is true, then file opening is deferred until the first call to :"
"meth:`emit`."
msgstr ""
"Если *delay* имеет значение true, то открытие файла откладывается до первого "
"вызова :meth:`emit`."

#: ../../library/logging.handlers.rst:418
msgid ""
"If *atTime* is not ``None``, it must be a ``datetime.time`` instance which "
"specifies the time of day when rollover occurs, for the cases where rollover "
"is set to happen \"at midnight\" or \"on a particular weekday\". Note that "
"in these cases, the *atTime* value is effectively used to compute the "
"*initial* rollover, and subsequent rollovers would be calculated via the "
"normal interval calculation."
msgstr ""
"Если *atTime* не имеет значения None, это должен быть экземпляр datetime."
"time, который определяет время суток, когда происходит переключение, для "
"случаев, когда переключение происходит «в полночь» или «в определенный "
"будний день». Обратите внимание, что в этих случаях значение *atTime* "
"эффективно используется для вычисления *начального* ролловера, а последующие "
"ролловеры будут рассчитываться посредством обычного расчета интервала."

#: ../../library/logging.handlers.rst:425
msgid ""
"If *errors* is specified, it's used to determine how encoding errors are "
"handled."
msgstr ""
"Если указано *errors*, оно используется для определения способа обработки "
"ошибок кодирования."

#: ../../library/logging.handlers.rst:428
msgid ""
"Calculation of the initial rollover time is done when the handler is "
"initialised. Calculation of subsequent rollover times is done only when "
"rollover occurs, and rollover occurs only when emitting output. If this is "
"not kept in mind, it might lead to some confusion. For example, if an "
"interval of \"every minute\" is set, that does not mean you will always see "
"log files with times (in the filename) separated by a minute; if, during "
"application execution, logging output is generated more frequently than once "
"a minute, *then* you can expect to see log files with times separated by a "
"minute. If, on the other hand, logging messages are only output once every "
"five minutes (say), then there will be gaps in the file times corresponding "
"to the minutes where no output (and hence no rollover) occurred."
msgstr ""
"Расчет начального времени опрокидывания выполняется при инициализации "
"обработчика. Расчет последующего времени ролловера выполняется только тогда, "
"когда ролловер происходит, а ролловер происходит только при выдаче выходных "
"данных. Если этого не учитывать, это может привести к некоторой путанице. "
"Например, если установлен интервал «каждую минуту», это не означает, что вы "
"всегда будете видеть файлы журналов, в которых время (в имени файла) "
"отделено минутой; если во время выполнения приложения выходные данные "
"журнала создаются чаще, чем раз в минуту, *тогда* вы можете ожидать увидеть "
"файлы журналов со временем, разделенным минутой. Если, с другой стороны, "
"сообщения журнала выводятся только раз в пять минут (скажем), то во времени "
"файла будут пробелы, соответствующие минутам, в течение которых не "
"происходило вывода (и, следовательно, опрокидывания)."

#: ../../library/logging.handlers.rst:441
msgid "*atTime* parameter was added."
msgstr "Добавлен параметр *atTime*."

#: ../../library/logging.handlers.rst:457
msgid ""
"Outputs the record to the file, catering for rollover as described above."
msgstr "Выводит запись в файл с возможностью опрокидывания, как описано выше."

#: ../../library/logging.handlers.rst:461
msgid ""
"Returns a list of filenames which should be deleted as part of rollover. "
"These are the absolute paths of the oldest backup log files written by the "
"handler."
msgstr ""
"Возвращает список имен файлов, которые следует удалить в ходе ролловера. Это "
"абсолютные пути к самым старым файлам журнала резервного копирования, "
"записанным обработчиком."

#: ../../library/logging.handlers.rst:467
msgid "SocketHandler"
msgstr "SocketHandler"

#: ../../library/logging.handlers.rst:469
msgid ""
"The :class:`SocketHandler` class, located in the :mod:`logging.handlers` "
"module, sends logging output to a network socket. The base class uses a TCP "
"socket."
msgstr ""
"Класс :class:`SocketHandler`, расположенный в модуле :mod:`logging."
"handlers`, отправляет выходные данные журнала в сетевой сокет. Базовый класс "
"использует сокет TCP."

#: ../../library/logging.handlers.rst:475
msgid ""
"Returns a new instance of the :class:`SocketHandler` class intended to "
"communicate with a remote machine whose address is given by *host* and "
"*port*."
msgstr ""
"Возвращает новый экземпляр класса :class:`SocketHandler`, предназначенный "
"для связи с удаленным компьютером, адрес которого задан параметрами *host* и "
"*port*."

#: ../../library/logging.handlers.rst:478
msgid ""
"If ``port`` is specified as ``None``, a Unix domain socket is created using "
"the value in ``host`` - otherwise, a TCP socket is created."
msgstr ""
"Если для порта указано значение Нет, сокет домена Unix создается с "
"использованием значения в хосте, в противном случае создается сокет TCP."

#: ../../library/logging.handlers.rst:484
msgid "Closes the socket."
msgstr "Закрывает сокет."

#: ../../library/logging.handlers.rst:489
msgid ""
"Pickles the record's attribute dictionary and writes it to the socket in "
"binary format. If there is an error with the socket, silently drops the "
"packet. If the connection was previously lost, re-establishes the "
"connection. To unpickle the record at the receiving end into a :class:"
"`~logging.LogRecord`, use the :func:`~logging.makeLogRecord` function."
msgstr ""
"Выбирает словарь атрибутов записи и записывает его в сокет в двоичном "
"формате. Если в сокете возникла ошибка, пакет автоматически отбрасывается. "
"Если соединение ранее было потеряно, восстанавливает соединение. Чтобы "
"преобразовать запись на принимающей стороне в :class:`~logging.LogRecord`, "
"используйте функцию :func:`~logging.makeLogRecord`."

#: ../../library/logging.handlers.rst:499
msgid ""
"Handles an error which has occurred during :meth:`emit`. The most likely "
"cause is a lost connection. Closes the socket so that we can retry on the "
"next event."
msgstr ""
"Обрабатывает ошибку, возникшую во время :meth:`emit`. Наиболее вероятная "
"причина – потеря связи. Закрывает сокет, чтобы мы могли повторить попытку "
"при следующем событии."

#: ../../library/logging.handlers.rst:506
msgid ""
"This is a factory method which allows subclasses to define the precise type "
"of socket they want. The default implementation creates a TCP socket (:const:"
"`socket.SOCK_STREAM`)."
msgstr ""
"Это фабричный метод, который позволяет подклассам определять точный тип "
"сокета, который им нужен. Реализация по умолчанию создает TCP-сокет (:const:"
"`socket.SOCK_STREAM`)."

#: ../../library/logging.handlers.rst:513
msgid ""
"Pickles the record's attribute dictionary in binary format with a length "
"prefix, and returns it ready for transmission across the socket. The details "
"of this operation are equivalent to::"
msgstr ""
"Выбирает словарь атрибутов записи в двоичном формате с префиксом длины и "
"возвращает его готовым для передачи через сокет. Детали этой операции "
"эквивалентны:"

#: ../../library/logging.handlers.rst:521
msgid ""
"Note that pickles aren't completely secure. If you are concerned about "
"security, you may want to override this method to implement a more secure "
"mechanism. For example, you can sign pickles using HMAC and then verify them "
"on the receiving end, or alternatively you can disable unpickling of global "
"objects on the receiving end."
msgstr ""
"Обратите внимание, что соленые огурцы не полностью безопасны. Если вас "
"беспокоит безопасность, вы можете переопределить этот метод, чтобы "
"реализовать более безопасный механизм. Например, вы можете подписать Pickles "
"с помощью HMAC, а затем проверить их на принимающей стороне или, "
"альтернативно, вы можете отключить распаковку глобальных объектов на "
"принимающей стороне."

#: ../../library/logging.handlers.rst:530
msgid ""
"Send a pickled byte-string *packet* to the socket. The format of the sent "
"byte-string is as described in the documentation for :meth:`~SocketHandler."
"makePickle`."
msgstr ""
"Отправьте маринованный пакет байтовой строки в сокет. Формат отправляемой "
"байтовой строки описан в документации для :meth:`~SocketHandler.makePickle`."

#: ../../library/logging.handlers.rst:534
msgid ""
"This function allows for partial sends, which can happen when the network is "
"busy."
msgstr ""
"Эта функция позволяет осуществлять частичную отправку, что может произойти, "
"когда сеть занята."

#: ../../library/logging.handlers.rst:540
msgid ""
"Tries to create a socket; on failure, uses an exponential back-off "
"algorithm.  On initial failure, the handler will drop the message it was "
"trying to send.  When subsequent messages are handled by the same instance, "
"it will not try connecting until some time has passed.  The default "
"parameters are such that the initial delay is one second, and if after that "
"delay the connection still can't be made, the handler will double the delay "
"each time up to a maximum of 30 seconds."
msgstr ""
"Пытается создать сокет; в случае сбоя используется алгоритм "
"экспоненциального отката. В случае первоначальной неудачи обработчик "
"отбросит сообщение, которое пытался отправить. Когда последующие сообщения "
"обрабатываются одним и тем же экземпляром, он не будет пытаться "
"подключиться, пока не пройдет некоторое время. Параметры по умолчанию "
"таковы, что первоначальная задержка составляет одну секунду, и если после "
"этой задержки соединение все еще не может быть установлено, обработчик будет "
"удваивать задержку каждый раз, максимум до 30 секунд."

#: ../../library/logging.handlers.rst:548
msgid "This behaviour is controlled by the following handler attributes:"
msgstr "Это поведение контролируется следующими атрибутами обработчика:"

#: ../../library/logging.handlers.rst:550
msgid "``retryStart`` (initial delay, defaulting to 1.0 seconds)."
msgstr "``retryStart`` (начальная задержка, по умолчанию 1,0 секунды)."

#: ../../library/logging.handlers.rst:551
msgid "``retryFactor`` (multiplier, defaulting to 2.0)."
msgstr "``retryFactor`` (множитель, по умолчанию 2,0)."

#: ../../library/logging.handlers.rst:552
msgid "``retryMax`` (maximum delay, defaulting to 30.0 seconds)."
msgstr "``retryMax`` (максимальная задержка, по умолчанию 30,0 секунд)."

#: ../../library/logging.handlers.rst:554
msgid ""
"This means that if the remote listener starts up *after* the handler has "
"been used, you could lose messages (since the handler won't even attempt a "
"connection until the delay has elapsed, but just silently drop messages "
"during the delay period)."
msgstr ""
"Это означает, что если удаленный прослушиватель запускается *после* "
"использования обработчика, вы можете потерять сообщения (поскольку "
"обработчик даже не будет пытаться установить соединение, пока не истечет "
"задержка, а просто молча отбрасывает сообщения в течение периода задержки)."

#: ../../library/logging.handlers.rst:563
msgid "DatagramHandler"
msgstr "DatagramHandler"

#: ../../library/logging.handlers.rst:565
msgid ""
"The :class:`DatagramHandler` class, located in the :mod:`logging.handlers` "
"module, inherits from :class:`SocketHandler` to support sending logging "
"messages over UDP sockets."
msgstr ""
"Класс :class:`DatagramHandler`, расположенный в модуле :mod:`logging."
"handlers`, наследуется от :class:`SocketHandler` для поддержки отправки "
"сообщений журнала через UDP-сокеты."

#: ../../library/logging.handlers.rst:572
msgid ""
"Returns a new instance of the :class:`DatagramHandler` class intended to "
"communicate with a remote machine whose address is given by *host* and "
"*port*."
msgstr ""
"Возвращает новый экземпляр класса :class:`DatagramHandler`, предназначенный "
"для связи с удаленным компьютером, адрес которого задан параметрами *host* и "
"*port*."

#: ../../library/logging.handlers.rst:575
msgid ""
"As UDP is not a streaming protocol, there is no persistent connection "
"between an instance of this handler and *host*. For this reason, when using "
"a network socket, a DNS lookup might have to be made each time an event is "
"logged, which can introduce some latency into the system. If this affects "
"you, you can do a lookup yourself and initialize this handler using the "
"looked-up IP address rather than the hostname."
msgstr ""
"Поскольку UDP не является протоколом потоковой передачи, между экземпляром "
"этого обработчика и *хостом* не существует постоянного соединения. По этой "
"причине при использовании сетевого сокета может потребоваться выполнять "
"поиск DNS каждый раз при регистрации события, что может привести к некоторой "
"задержке в системе. Если это вас затрагивает, вы можете выполнить поиск "
"самостоятельно и инициализировать этот обработчик, используя найденный IP-"
"адрес, а не имя хоста."

#: ../../library/logging.handlers.rst:582
msgid ""
"If ``port`` is specified as ``None``, a Unix domain socket is created using "
"the value in ``host`` - otherwise, a UDP socket is created."
msgstr ""
"Если для порта указано значение Нет, сокет домена Unix создается с "
"использованием значения в хосте, в противном случае создается сокет UDP."

#: ../../library/logging.handlers.rst:588
msgid ""
"Pickles the record's attribute dictionary and writes it to the socket in "
"binary format. If there is an error with the socket, silently drops the "
"packet. To unpickle the record at the receiving end into a :class:`~logging."
"LogRecord`, use the :func:`~logging.makeLogRecord` function."
msgstr ""
"Выбирает словарь атрибутов записи и записывает его в сокет в двоичном "
"формате. Если в сокете возникла ошибка, пакет автоматически отбрасывается. "
"Чтобы преобразовать запись на принимающей стороне в :class:`~logging."
"LogRecord`, используйте функцию :func:`~logging.makeLogRecord`."

#: ../../library/logging.handlers.rst:597
msgid ""
"The factory method of :class:`SocketHandler` is here overridden to create a "
"UDP socket (:const:`socket.SOCK_DGRAM`)."
msgstr ""
"Фабричный метод :class:`SocketHandler` здесь переопределяется для создания "
"UDP-сокета (:const:`socket.SOCK_DGRAM`)."

#: ../../library/logging.handlers.rst:603
msgid ""
"Send a pickled byte-string to a socket. The format of the sent byte-string "
"is as described in the documentation for :meth:`SocketHandler.makePickle`."
msgstr ""
"Отправьте обработанную байтовую строку в сокет. Формат отправляемой байтовой "
"строки описан в документации для :meth:`SocketHandler.makePickle`."

#: ../../library/logging.handlers.rst:610
msgid "SysLogHandler"
msgstr "SysLogHandler"

#: ../../library/logging.handlers.rst:612
msgid ""
"The :class:`SysLogHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a remote or local Unix syslog."
msgstr ""
"Класс :class:`SysLogHandler`, расположенный в модуле :mod:`logging."
"handlers`, поддерживает отправку сообщений журнала в удаленный или локальный "
"системный журнал Unix."

#: ../../library/logging.handlers.rst:618
msgid ""
"Returns a new instance of the :class:`SysLogHandler` class intended to "
"communicate with a remote Unix machine whose address is given by *address* "
"in the form of a ``(host, port)`` tuple.  If *address* is not specified, "
"``('localhost', 514)`` is used.  The address is used to open a socket.  An "
"alternative to providing a ``(host, port)`` tuple is providing an address as "
"a string, for example '/dev/log'. In this case, a Unix domain socket is used "
"to send the message to the syslog. If *facility* is not specified, :const:"
"`LOG_USER` is used. The type of socket opened depends on the *socktype* "
"argument, which defaults to :const:`socket.SOCK_DGRAM` and thus opens a UDP "
"socket. To open a TCP socket (for use with the newer syslog daemons such as "
"rsyslog), specify a value of :const:`socket.SOCK_STREAM`."
msgstr ""
"Возвращает новый экземпляр класса :class:`SysLogHandler`, предназначенный "
"для связи с удаленной машиной Unix, адрес которой задан *адрес* в форме "
"кортежа ``(хост, порт)``. Если *адрес* не указан, используется "
"``('localhost', 514)``. Адрес используется для открытия сокета. "
"Альтернативой предоставлению кортежа ``(host, port)`` является "
"предоставление адреса в виде строки, например \"/dev/log\". В этом случае "
"для отправки сообщения в системный журнал используется сокет домена Unix. "
"Если *facility* не указано, используется :const:`LOG_USER`. Тип открываемого "
"сокета зависит от аргумента *socktype*, который по умолчанию имеет значение :"
"const:`socket.SOCK_DGRAM` и, таким образом, открывает UDP-сокет. Чтобы "
"открыть сокет TCP (для использования с новыми демонами системного журнала, "
"такими как rsyslog), укажите значение :const:`socket.SOCK_STREAM`."

#: ../../library/logging.handlers.rst:630
msgid ""
"Note that if your server is not listening on UDP port 514, :class:"
"`SysLogHandler` may appear not to work. In that case, check what address you "
"should be using for a domain socket - it's system dependent. For example, on "
"Linux it's usually '/dev/log' but on OS/X it's '/var/run/syslog'. You'll "
"need to check your platform and use the appropriate address (you may need to "
"do this check at runtime if your application needs to run on several "
"platforms). On Windows, you pretty much have to use the UDP option."
msgstr ""
"Обратите внимание: если ваш сервер не прослушивает UDP-порт 514, может "
"показаться, что :class:`SysLogHandler` не работает. В этом случае проверьте, "
"какой адрес вам следует использовать для сокета домена — это зависит от "
"системы. Например, в Linux это обычно «/dev/log», а в OS/X — «/var/run/"
"syslog». Вам нужно будет проверить свою платформу и использовать "
"соответствующий адрес (вам может потребоваться выполнить эту проверку во "
"время выполнения, если ваше приложение должно работать на нескольких "
"платформах). В Windows вам в значительной степени придется использовать "
"опцию UDP."

#: ../../library/logging.handlers.rst:639
msgid ""
"On macOS 12.x (Monterey), Apple has changed the behaviour of their syslog "
"daemon - it no longer listens on a domain socket. Therefore, you cannot "
"expect :class:`SysLogHandler` to work on this system."
msgstr ""
"В macOS 12.x (Монтерей) Apple изменила поведение своего демона системного "
"журнала — он больше не прослушивает сокет домена. Следовательно, вы не "
"можете ожидать, что :class:`SysLogHandler` будет работать в этой системе."

#: ../../library/logging.handlers.rst:643
msgid "See :gh:`91070` for more information."
msgstr "См. :gh:`91070` для получения дополнительной информации."

#: ../../library/logging.handlers.rst:645
msgid "*socktype* was added."
msgstr "Был добавлен *socktype*."

#: ../../library/logging.handlers.rst:651
msgid "Closes the socket to the remote host."
msgstr "Закрывает сокет на удаленном хосте."

#: ../../library/logging.handlers.rst:655
msgid ""
"Tries to create a socket and, if it's not a datagram socket, connect it to "
"the other end. This method is called during handler initialization, but it's "
"not regarded as an error if the other end isn't listening at this point - "
"the method will be called again when emitting an event, if there is no "
"socket at that point."
msgstr ""
"Пытается создать сокет и, если это не дейтаграммный сокет, подключить его к "
"другому концу. Этот метод вызывается во время инициализации обработчика, но "
"он не считается ошибкой, если другой конец в этот момент не прослушивает — "
"метод будет вызываться снова при отправке события, если в этот момент нет "
"сокета."

#: ../../library/logging.handlers.rst:665
msgid ""
"The record is formatted, and then sent to the syslog server. If exception "
"information is present, it is *not* sent to the server."
msgstr ""
"Запись форматируется, а затем отправляется на сервер системного журнала. "
"Если информация об исключении присутствует, она *не* отправляется на сервер."

#: ../../library/logging.handlers.rst:668
msgid ""
"(See: :issue:`12168`.) In earlier versions, the message sent to the syslog "
"daemons was always terminated with a NUL byte, because early versions of "
"these daemons expected a NUL terminated message - even though it's not in "
"the relevant specification (:rfc:`5424`). More recent versions of these "
"daemons don't expect the NUL byte but strip it off if it's there, and even "
"more recent daemons (which adhere more closely to RFC 5424) pass the NUL "
"byte on as part of the message."
msgstr ""
"(См.: :issue:`12168`.) В более ранних версиях сообщение, отправленное "
"демонам системного журнала, всегда завершалось нулевым байтом, поскольку "
"ранние версии этих демонов ожидали сообщение о завершении NUL - даже если "
"это не указано в соответствующей спецификации. (:rfc:`5424`). Более поздние "
"версии этих демонов не ожидают NUL-байт, а удаляют его, если он есть, и даже "
"более поздние демоны (которые более точно соответствуют RFC 5424) передают "
"NUL-байт как часть сообщения."

#: ../../library/logging.handlers.rst:677
msgid ""
"To enable easier handling of syslog messages in the face of all these "
"differing daemon behaviours, the appending of the NUL byte has been made "
"configurable, through the use of a class-level attribute, ``append_nul``. "
"This defaults to ``True`` (preserving the existing behaviour) but can be set "
"to ``False`` on a ``SysLogHandler`` instance in order for that instance to "
"*not* append the NUL terminator."
msgstr ""
"Чтобы упростить обработку сообщений системного журнала в условиях всех этих "
"различий в поведении демонов, добавление NUL-байта стало настраиваемым с "
"помощью атрибута уровня класса ``append_nul``. По умолчанию это значение "
"True (с сохранением существующего поведения), но его можно установить в "
"False для экземпляра SysLogHandler, чтобы этот экземпляр *не* добавлял "
"терминатор NUL."

#: ../../library/logging.handlers.rst:684
msgid ""
"(See: :issue:`12419`.) In earlier versions, there was no facility for an "
"\"ident\" or \"tag\" prefix to identify the source of the message. This can "
"now be specified using a class-level attribute, defaulting to ``\"\"`` to "
"preserve existing behaviour, but which can be overridden on a "
"``SysLogHandler`` instance in order for that instance to prepend the ident "
"to every message handled. Note that the provided ident must be text, not "
"bytes, and is prepended to the message exactly as is."
msgstr ""
"(См.: :issue:`12419`.) В более ранних версиях не было возможности "
"использовать префикс «ident» или «tag» для идентификации источника "
"сообщения. Теперь это можно указать с помощью атрибута уровня класса, по "
"умолчанию равного ``\"\"`` для сохранения существующего поведения, но "
"который можно переопределить в экземпляре ``SysLogHandler``, чтобы этот "
"экземпляр добавлял идентификатор перед каждым сообщением. обработано. "
"Обратите внимание, что предоставленный идентификатор должен быть текстом, а "
"не байтами, и добавляется к сообщению точно так же, как есть."

#: ../../library/logging.handlers.rst:695
msgid ""
"Encodes the facility and priority into an integer. You can pass in strings "
"or integers - if strings are passed, internal mapping dictionaries are used "
"to convert them to integers."
msgstr ""
"Кодирует возможность и приоритет в целое число. Вы можете передавать строки "
"или целые числа — если передаются строки, для преобразования их в целые "
"числа используются внутренние словари сопоставлений."

#: ../../library/logging.handlers.rst:699
msgid ""
"The symbolic ``LOG_`` values are defined in :class:`SysLogHandler` and "
"mirror the values defined in the ``sys/syslog.h`` header file."
msgstr ""
"Символические значения ``LOG_`` определены в :class:`SysLogHandler` и "
"отражают значения, определенные в заголовочном файле ``sys/syslog.h``."

#: ../../library/logging.handlers.rst:702
msgid "**Priorities**"
msgstr "**Приоритеты**"

#: ../../library/logging.handlers.rst:705
#: ../../library/logging.handlers.rst:727
msgid "Name (string)"
msgstr "Имя (строка)"

#: ../../library/logging.handlers.rst:705
#: ../../library/logging.handlers.rst:727
msgid "Symbolic value"
msgstr "Символическое значение"

#: ../../library/logging.handlers.rst:707
msgid "``alert``"
msgstr "``alert``"

#: ../../library/logging.handlers.rst:707
msgid "LOG_ALERT"
msgstr "LOG_ALERT"

#: ../../library/logging.handlers.rst:709
msgid "``crit`` or ``critical``"
msgstr "``crit`` или ``critical``"

#: ../../library/logging.handlers.rst:709
msgid "LOG_CRIT"
msgstr "LOG_CRIT"

#: ../../library/logging.handlers.rst:711
msgid "``debug``"
msgstr "``debug``"

#: ../../library/logging.handlers.rst:711
msgid "LOG_DEBUG"
msgstr "LOG_DEBUG"

#: ../../library/logging.handlers.rst:713
msgid "``emerg`` or ``panic``"
msgstr "``emerg`` или ``panic``"

#: ../../library/logging.handlers.rst:713
msgid "LOG_EMERG"
msgstr "LOG_EMERG"

#: ../../library/logging.handlers.rst:715
msgid "``err`` or ``error``"
msgstr "``err`` или ``error``"

#: ../../library/logging.handlers.rst:715
msgid "LOG_ERR"
msgstr "LOG_ERR"

#: ../../library/logging.handlers.rst:717
msgid "``info``"
msgstr "``info``"

#: ../../library/logging.handlers.rst:717
msgid "LOG_INFO"
msgstr "LOG_INFO"

#: ../../library/logging.handlers.rst:719
msgid "``notice``"
msgstr "``notice``"

#: ../../library/logging.handlers.rst:719
msgid "LOG_NOTICE"
msgstr "LOG_NOTICE"

#: ../../library/logging.handlers.rst:721
msgid "``warn`` or ``warning``"
msgstr "``warn`` или ``warning``"

#: ../../library/logging.handlers.rst:721
msgid "LOG_WARNING"
msgstr "LOG_WARNING"

#: ../../library/logging.handlers.rst:724
msgid "**Facilities**"
msgstr "**Удобства**"

#: ../../library/logging.handlers.rst:729
msgid "``auth``"
msgstr "``auth``"

#: ../../library/logging.handlers.rst:729
msgid "LOG_AUTH"
msgstr "LOG_AUTH"

#: ../../library/logging.handlers.rst:731
msgid "``authpriv``"
msgstr "``authpriv``"

#: ../../library/logging.handlers.rst:731
msgid "LOG_AUTHPRIV"
msgstr "LOG_AUTHPRIV"

#: ../../library/logging.handlers.rst:733
msgid "``cron``"
msgstr "``cron``"

#: ../../library/logging.handlers.rst:733
msgid "LOG_CRON"
msgstr "LOG_CRON"

#: ../../library/logging.handlers.rst:735
msgid "``daemon``"
msgstr "``daemon``"

#: ../../library/logging.handlers.rst:735
msgid "LOG_DAEMON"
msgstr "LOG_DAEMON"

#: ../../library/logging.handlers.rst:737
msgid "``ftp``"
msgstr "``ftp``"

#: ../../library/logging.handlers.rst:737
msgid "LOG_FTP"
msgstr "LOG_FTP"

#: ../../library/logging.handlers.rst:739
msgid "``kern``"
msgstr "``kern``"

#: ../../library/logging.handlers.rst:739
msgid "LOG_KERN"
msgstr "LOG_KERN"

#: ../../library/logging.handlers.rst:741
msgid "``lpr``"
msgstr "``lpr``"

#: ../../library/logging.handlers.rst:741
msgid "LOG_LPR"
msgstr "LOG_LPR"

#: ../../library/logging.handlers.rst:743
msgid "``mail``"
msgstr "``mail``"

#: ../../library/logging.handlers.rst:743
msgid "LOG_MAIL"
msgstr "LOG_MAIL"

#: ../../library/logging.handlers.rst:745
msgid "``news``"
msgstr "``news``"

#: ../../library/logging.handlers.rst:745
msgid "LOG_NEWS"
msgstr "LOG_NEWS"

#: ../../library/logging.handlers.rst:747
msgid "``syslog``"
msgstr "``syslog``"

#: ../../library/logging.handlers.rst:747
msgid "LOG_SYSLOG"
msgstr "LOG_SYSLOG"

#: ../../library/logging.handlers.rst:749
msgid "``user``"
msgstr "``user``"

#: ../../library/logging.handlers.rst:749
msgid "LOG_USER"
msgstr "LOG_USER"

#: ../../library/logging.handlers.rst:751
msgid "``uucp``"
msgstr "``uucp``"

#: ../../library/logging.handlers.rst:751
msgid "LOG_UUCP"
msgstr "LOG_UUCP"

#: ../../library/logging.handlers.rst:753
msgid "``local0``"
msgstr "``local0``"

#: ../../library/logging.handlers.rst:753
msgid "LOG_LOCAL0"
msgstr "LOG_LOCAL0"

#: ../../library/logging.handlers.rst:755
msgid "``local1``"
msgstr "``local1``"

#: ../../library/logging.handlers.rst:755
msgid "LOG_LOCAL1"
msgstr "LOG_LOCAL1"

#: ../../library/logging.handlers.rst:757
msgid "``local2``"
msgstr "``local2``"

#: ../../library/logging.handlers.rst:757
msgid "LOG_LOCAL2"
msgstr "LOG_LOCAL2"

#: ../../library/logging.handlers.rst:759
msgid "``local3``"
msgstr "``local3``"

#: ../../library/logging.handlers.rst:759
msgid "LOG_LOCAL3"
msgstr "LOG_LOCAL3"

#: ../../library/logging.handlers.rst:761
msgid "``local4``"
msgstr "``local4``"

#: ../../library/logging.handlers.rst:761
msgid "LOG_LOCAL4"
msgstr "LOG_LOCAL4"

#: ../../library/logging.handlers.rst:763
msgid "``local5``"
msgstr "``local5``"

#: ../../library/logging.handlers.rst:763
msgid "LOG_LOCAL5"
msgstr "LOG_LOCAL5"

#: ../../library/logging.handlers.rst:765
msgid "``local6``"
msgstr "``local6``"

#: ../../library/logging.handlers.rst:765
msgid "LOG_LOCAL6"
msgstr "LOG_LOCAL6"

#: ../../library/logging.handlers.rst:767
msgid "``local7``"
msgstr "``local7``"

#: ../../library/logging.handlers.rst:767
msgid "LOG_LOCAL7"
msgstr "LOG_LOCAL7"

#: ../../library/logging.handlers.rst:772
msgid ""
"Maps a logging level name to a syslog priority name. You may need to "
"override this if you are using custom levels, or if the default algorithm is "
"not suitable for your needs. The default algorithm maps ``DEBUG``, ``INFO``, "
"``WARNING``, ``ERROR`` and ``CRITICAL`` to the equivalent syslog names, and "
"all other level names to 'warning'."
msgstr ""
"Сопоставляет имя уровня ведения журнала с именем приоритета системного "
"журнала. Возможно, вам придется переопределить это, если вы используете "
"пользовательские уровни или если алгоритм по умолчанию не подходит для ваших "
"нужд. Алгоритм по умолчанию сопоставляет ``DEBUG``, ``INFO``, ``WARNING``, "
"``ERROR`` и ``CRITICAL`` эквивалентным именам системного журнала, а все "
"остальные имена уровней - \"предупреждению\"."

#: ../../library/logging.handlers.rst:782
msgid "NTEventLogHandler"
msgstr "NTEventLogHandler"

#: ../../library/logging.handlers.rst:784
msgid ""
"The :class:`NTEventLogHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a local Windows NT, Windows "
"2000 or Windows XP event log. Before you can use it, you need Mark Hammond's "
"Win32 extensions for Python installed."
msgstr ""
"Класс :class:`NTEventLogHandler`, расположенный в модуле :mod:`logging."
"handlers`, поддерживает отправку сообщений журнала в локальный журнал "
"событий Windows NT, Windows 2000 или Windows XP. Прежде чем вы сможете его "
"использовать, вам необходимо установить расширения Win32 Марка Хаммонда для "
"Python."

#: ../../library/logging.handlers.rst:792
msgid ""
"Returns a new instance of the :class:`NTEventLogHandler` class. The "
"*appname* is used to define the application name as it appears in the event "
"log. An appropriate registry entry is created using this name. The *dllname* "
"should give the fully qualified pathname of a .dll or .exe which contains "
"message definitions to hold in the log (if not specified, ``'win32service."
"pyd'`` is used - this is installed with the Win32 extensions and contains "
"some basic placeholder message definitions. Note that use of these "
"placeholders will make your event logs big, as the entire message source is "
"held in the log. If you want slimmer logs, you have to pass in the name of "
"your own .dll or .exe which contains the message definitions you want to use "
"in the event log). The *logtype* is one of ``'Application'``, ``'System'`` "
"or ``'Security'``, and defaults to ``'Application'``."
msgstr ""
"Возвращает новый экземпляр класса :class:`NTEventLogHandler`. *appname* "
"используется для определения имени приложения, которое отображается в "
"журнале событий. С этим именем создается соответствующая запись реестра. "
"*dllname* должно содержать полный путь к файлу .dll или .exe, который "
"содержит определения сообщений для хранения в журнале (если не указано, "
"используется ``'win32service.pyd'`` - он устанавливается вместе с "
"расширениями Win32. и содержит некоторые основные определения сообщений-"
"заполнителей. Обратите внимание, что использование этих заполнителей "
"приведет к увеличению размера журналов событий, поскольку весь источник "
"сообщений будет храниться в журнале. Если вам нужны более компактные "
"журналы, вам придется передать имя вашей собственной .dll. или .exe, который "
"содержит определения сообщений, которые вы хотите использовать в журнале "
"событий). *logtype* является одним из ``'Приложение'``, ``'Система'`` или "
"``'Безопасность'`` и по умолчанию имеет значение ``'Приложение'``."

#: ../../library/logging.handlers.rst:808
msgid ""
"At this point, you can remove the application name from the registry as a "
"source of event log entries. However, if you do this, you will not be able "
"to see the events as you intended in the Event Log Viewer - it needs to be "
"able to access the registry to get the .dll name. The current version does "
"not do this."
msgstr ""
"На этом этапе вы можете удалить имя приложения из реестра как источника "
"записей журнала событий. Однако если вы сделаете это, вы не сможете видеть "
"события так, как вы предполагали, в средстве просмотра журнала событий — ему "
"необходимо иметь доступ к реестру, чтобы получить имя .dll. Текущая версия "
"этого не делает."

#: ../../library/logging.handlers.rst:817
msgid ""
"Determines the message ID, event category and event type, and then logs the "
"message in the NT event log."
msgstr ""
"Определяет идентификатор сообщения, категорию и тип события, а затем "
"регистрирует сообщение в журнале событий NT."

#: ../../library/logging.handlers.rst:823
msgid ""
"Returns the event category for the record. Override this if you want to "
"specify your own categories. This version returns 0."
msgstr ""
"Возвращает категорию события для записи. Переопределите это значение, если "
"хотите указать свои собственные категории. Эта версия возвращает 0."

#: ../../library/logging.handlers.rst:829
msgid ""
"Returns the event type for the record. Override this if you want to specify "
"your own types. This version does a mapping using the handler's typemap "
"attribute, which is set up in :meth:`__init__` to a dictionary which "
"contains mappings for :const:`DEBUG`, :const:`INFO`, :const:`WARNING`, :"
"const:`ERROR` and :const:`CRITICAL`. If you are using your own levels, you "
"will either need to override this method or place a suitable dictionary in "
"the handler's *typemap* attribute."
msgstr ""
"Возвращает тип события для записи. Переопределите это значение, если хотите "
"указать свои собственные типы. Эта версия выполняет сопоставление с "
"использованием атрибута typemap обработчика, который установлен в :meth:"
"`__init__`, со словарем, который содержит сопоставления для :const:`DEBUG`, :"
"const:`INFO`, :const:`WARNING`, :const:`ОШИБКА` и :const:`КРИТИЧЕСКИЙ`. Если "
"вы используете свои собственные уровни, вам нужно будет либо переопределить "
"этот метод, либо поместить подходящий словарь в атрибут *typemap* "
"обработчика."

#: ../../library/logging.handlers.rst:840
msgid ""
"Returns the message ID for the record. If you are using your own messages, "
"you could do this by having the *msg* passed to the logger being an ID "
"rather than a format string. Then, in here, you could use a dictionary "
"lookup to get the message ID. This version returns 1, which is the base "
"message ID in :file:`win32service.pyd`."
msgstr ""
"Возвращает идентификатор сообщения для записи. Если вы используете свои "
"собственные сообщения, вы можете сделать это, передав *msg* в регистратор "
"как идентификатор, а не строку формата. Затем здесь вы можете использовать "
"поиск по словарю, чтобы получить идентификатор сообщения. Эта версия "
"возвращает 1, который является базовым идентификатором сообщения в файле:"
"`win32service.pyd`."

#: ../../library/logging.handlers.rst:849
msgid "SMTPHandler"
msgstr "SMTPHandler"

#: ../../library/logging.handlers.rst:851
msgid ""
"The :class:`SMTPHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to an email address via SMTP."
msgstr ""
"Класс :class:`SMTPHandler`, расположенный в модуле :mod:`logging.handlers`, "
"поддерживает отправку сообщений журнала на адрес электронной почты через "
"SMTP."

#: ../../library/logging.handlers.rst:857
msgid ""
"Returns a new instance of the :class:`SMTPHandler` class. The instance is "
"initialized with the from and to addresses and subject line of the email. "
"The *toaddrs* should be a list of strings. To specify a non-standard SMTP "
"port, use the (host, port) tuple format for the *mailhost* argument. If you "
"use a string, the standard SMTP port is used. If your SMTP server requires "
"authentication, you can specify a (username, password) tuple for the "
"*credentials* argument."
msgstr ""
"Возвращает новый экземпляр класса :class:`SMTPHandler`. Экземпляр "
"инициализируется с указанием адресов отправителя и получателя, а также "
"строки темы электронного письма. *toaddrs* должен представлять собой список "
"строк. Чтобы указать нестандартный порт SMTP, используйте формат кортежа "
"(хост, порт) для аргумента *mailhost*. Если вы используете строку, "
"используется стандартный порт SMTP. Если ваш SMTP-сервер требует "
"аутентификации, вы можете указать кортеж (имя пользователя, пароль) для "
"аргумента *credentials*."

#: ../../library/logging.handlers.rst:864
msgid ""
"To specify the use of a secure protocol (TLS), pass in a tuple to the "
"*secure* argument. This will only be used when authentication credentials "
"are supplied. The tuple should be either an empty tuple, or a single-value "
"tuple with the name of a keyfile, or a 2-value tuple with the names of the "
"keyfile and certificate file. (This tuple is passed to the :meth:`smtplib."
"SMTP.starttls` method.)"
msgstr ""
"Чтобы указать использование безопасного протокола (TLS), передайте кортеж в "
"аргумент *secure*. Это будет использоваться только в том случае, если "
"предоставлены учетные данные для аутентификации. Кортеж должен быть либо "
"пустым кортежем, либо кортежем с одним значением с именем файла ключа, либо "
"кортежем из 2 значений с именами файла ключа и файла сертификата. (Этот "
"кортеж передается методу :meth:`smtplib.SMTP.starttls`.)"

#: ../../library/logging.handlers.rst:871
msgid ""
"A timeout can be specified for communication with the SMTP server using the "
"*timeout* argument."
msgstr ""
"Таймаут можно указать для связи с SMTP-сервером, используя аргумент "
"*timeout*."

#: ../../library/logging.handlers.rst:874
msgid "Added the *timeout* parameter."
msgstr "Добавлен параметр *timeout*."

#: ../../library/logging.handlers.rst:879
msgid "Formats the record and sends it to the specified addressees."
msgstr "Форматирует запись и отправляет ее указанным адресатам."

#: ../../library/logging.handlers.rst:884
msgid ""
"If you want to specify a subject line which is record-dependent, override "
"this method."
msgstr ""
"Если вы хотите указать тему, зависящую от записи, переопределите этот метод."

#: ../../library/logging.handlers.rst:890
msgid "MemoryHandler"
msgstr "MemoryHandler"

#: ../../library/logging.handlers.rst:892
msgid ""
"The :class:`MemoryHandler` class, located in the :mod:`logging.handlers` "
"module, supports buffering of logging records in memory, periodically "
"flushing them to a :dfn:`target` handler. Flushing occurs whenever the "
"buffer is full, or when an event of a certain severity or greater is seen."
msgstr ""
"Класс :class:`MemoryHandler`, расположенный в модуле :mod:`logging."
"handlers`, поддерживает буферизацию записей журнала в памяти, периодически "
"сбрасывая их в обработчик :dfn:`target`. Сброс происходит всякий раз, когда "
"буфер заполнен или когда происходит событие определенной серьезности или "
"выше."

#: ../../library/logging.handlers.rst:897
msgid ""
":class:`MemoryHandler` is a subclass of the more general :class:"
"`BufferingHandler`, which is an abstract class. This buffers logging records "
"in memory. Whenever each record is added to the buffer, a check is made by "
"calling :meth:`shouldFlush` to see if the buffer should be flushed.  If it "
"should, then :meth:`flush` is expected to do the flushing."
msgstr ""
":class:`MemoryHandler` — это подкласс более общего :class:"
"`BufferingHandler`, который является абстрактным классом. Это буферизует "
"записи журнала в памяти. Всякий раз, когда каждая запись добавляется в "
"буфер, производится проверка путем вызова :meth:`shouldFlush`, чтобы "
"определить, следует ли очистить буфер. Если да, то ожидается, что :meth:"
"`flush` выполнит очистку."

#: ../../library/logging.handlers.rst:906
msgid ""
"Initializes the handler with a buffer of the specified capacity. Here, "
"*capacity* means the number of logging records buffered."
msgstr ""
"Инициализирует обработчик буфером указанной емкости. Здесь *емкость* "
"означает количество буферизованных записей журнала."

#: ../../library/logging.handlers.rst:912
msgid ""
"Append the record to the buffer. If :meth:`shouldFlush` returns true, call :"
"meth:`flush` to process the buffer."
msgstr ""
"Добавить запись в буфер. Если :meth:`shouldFlush` возвращает true, вызовите :"
"meth:`flush` для обработки буфера."

#: ../../library/logging.handlers.rst:918
msgid ""
"For a :class:`BufferingHandler` instance, flushing means that it sets the "
"buffer to an empty list. This method can be overwritten to implement more "
"useful flushing behavior."
msgstr ""
"Для экземпляра :class:`BufferingHandler` очистка означает, что буфер "
"устанавливается в пустой список. Этот метод можно перезаписать, чтобы "
"реализовать более полезное поведение очистки."

#: ../../library/logging.handlers.rst:925
msgid ""
"Return ``True`` if the buffer is up to capacity. This method can be "
"overridden to implement custom flushing strategies."
msgstr ""
"Верните True, если буфер заполнен. Этот метод можно переопределить для "
"реализации пользовательских стратегий очистки."

#: ../../library/logging.handlers.rst:931
msgid ""
"Returns a new instance of the :class:`MemoryHandler` class. The instance is "
"initialized with a buffer size of *capacity* (number of records buffered). "
"If *flushLevel* is not specified, :const:`ERROR` is used. If no *target* is "
"specified, the target will need to be set using :meth:`setTarget` before "
"this handler does anything useful. If *flushOnClose* is specified as "
"``False``, then the buffer is *not* flushed when the handler is closed. If "
"not specified or specified as ``True``, the previous behaviour of flushing "
"the buffer will occur when the handler is closed."
msgstr ""
"Возвращает новый экземпляр класса :class:`MemoryHandler`. Экземпляр "
"инициализируется с размером буфера *емкость* (количество записей в буфере). "
"Если *flushLevel* не указан, используется :const:`ERROR`. Если *target* не "
"указан, цель необходимо будет установить с помощью :meth:`setTarget`, прежде "
"чем этот обработчик сделает что-нибудь полезное. Если для *flushOnClose* "
"указано значение «False», то буфер *не* очищается при закрытии обработчика. "
"Если не указано или указано значение «True», предыдущее поведение очистки "
"буфера произойдет при закрытии обработчика."

#: ../../library/logging.handlers.rst:940
msgid "The *flushOnClose* parameter was added."
msgstr "Добавлен параметр *flushOnClose*."

#: ../../library/logging.handlers.rst:946
msgid "Calls :meth:`flush`, sets the target to ``None`` and clears the buffer."
msgstr ""
"Вызывает :meth:`flush`, устанавливает для цели значение ``None`` и очищает "
"буфер."

#: ../../library/logging.handlers.rst:952
msgid ""
"For a :class:`MemoryHandler` instance, flushing means just sending the "
"buffered records to the target, if there is one. The buffer is also cleared "
"when buffered records are sent to the target. Override if you want different "
"behavior."
msgstr ""
"Для экземпляра :class:`MemoryHandler` очистка означает просто отправку "
"буферизованных записей в цель, если таковая имеется. Буфер также очищается, "
"когда буферизованные записи отправляются в цель. Переопределите, если хотите "
"другое поведение."

#: ../../library/logging.handlers.rst:959
msgid "Sets the target handler for this handler."
msgstr "Устанавливает целевой обработчик для этого обработчика."

#: ../../library/logging.handlers.rst:964
msgid "Checks for buffer full or a record at the *flushLevel* or higher."
msgstr ""
"Проверяет заполненность буфера или запись на уровне *flushLevel* или выше."

#: ../../library/logging.handlers.rst:970
msgid "HTTPHandler"
msgstr "HTTPHandler"

#: ../../library/logging.handlers.rst:972
msgid ""
"The :class:`HTTPHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a web server, using either "
"``GET`` or ``POST`` semantics."
msgstr ""
"Класс :class:`HTTPHandler`, расположенный в модуле :mod:`logging.handlers`, "
"поддерживает отправку сообщений журнала на веб-сервер, используя семантику "
"``GET`` или ``POST``."

#: ../../library/logging.handlers.rst:979
msgid ""
"Returns a new instance of the :class:`HTTPHandler` class. The *host* can be "
"of the form ``host:port``, should you need to use a specific port number.  "
"If no *method* is specified, ``GET`` is used. If *secure* is true, a HTTPS "
"connection will be used. The *context* parameter may be set to a :class:`ssl."
"SSLContext` instance to configure the SSL settings used for the HTTPS "
"connection. If *credentials* is specified, it should be a 2-tuple consisting "
"of userid and password, which will be placed in a HTTP 'Authorization' "
"header using Basic authentication. If you specify credentials, you should "
"also specify secure=True so that your userid and password are not passed in "
"cleartext across the wire."
msgstr ""
"Возвращает новый экземпляр класса :class:`HTTPHandler`. *хост* может иметь "
"форму ``хост:порт``, если вам нужно использовать определенный номер порта. "
"Если *метод* не указан, используется GET. Если *secure* имеет значение true, "
"будет использоваться соединение HTTPS. Параметр *context* может быть "
"установлен для экземпляра :class:`ssl.SSLContext` для настройки параметров "
"SSL, используемых для HTTPS-соединения. Если указаны *credentials*, это "
"должен быть кортеж из двух элементов, состоящий из идентификатора "
"пользователя и пароля, который будет помещен в заголовок HTTP "
"«Authorization» с использованием базовой аутентификации. Если вы указываете "
"учетные данные, вам также следует указать secure=True, чтобы ваш "
"идентификатор пользователя и пароль не передавались по сети в открытом виде."

#: ../../library/logging.handlers.rst:990
msgid "The *context* parameter was added."
msgstr "Добавлен параметр *context*."

#: ../../library/logging.handlers.rst:995
msgid ""
"Provides a dictionary, based on ``record``, which is to be URL-encoded and "
"sent to the web server. The default implementation just returns ``record."
"__dict__``. This method can be overridden if e.g. only a subset of :class:"
"`~logging.LogRecord` is to be sent to the web server, or if more specific "
"customization of what's sent to the server is required."
msgstr ""
"Предоставляет словарь, основанный на ``записи``, который должен быть "
"закодирован в URL-адресе и отправлен на веб-сервер. Реализация по умолчанию "
"просто возвращает ``record.__dict__``. Этот метод можно переопределить, "
"если, например, на веб-сервер необходимо отправить только подмножество :"
"class:`~logging.LogRecord` или если требуется более специфическая настройка "
"того, что отправляется на сервер."

#: ../../library/logging.handlers.rst:1003
msgid ""
"Sends the record to the web server as a URL-encoded dictionary. The :meth:"
"`mapLogRecord` method is used to convert the record to the dictionary to be "
"sent."
msgstr ""
"Отправляет запись на веб-сервер в виде словаря в кодировке URL. Метод :meth:"
"`mapLogRecord` используется для преобразования записи в словарь для отправки."

#: ../../library/logging.handlers.rst:1007
msgid ""
"Since preparing a record for sending it to a web server is not the same as a "
"generic formatting operation, using :meth:`~logging.Handler.setFormatter` to "
"specify a :class:`~logging.Formatter` for a :class:`HTTPHandler` has no "
"effect. Instead of calling :meth:`~logging.Handler.format`, this handler "
"calls :meth:`mapLogRecord` and then :func:`urllib.parse.urlencode` to encode "
"the dictionary in a form suitable for sending to a web server."
msgstr ""
"Поскольку подготовка записи для отправки на веб-сервер — это не то же самое, "
"что стандартная операция форматирования, использование :meth:`~logging."
"Handler.setFormatter` для указания :class:`~logging.Formatter` для :class: "
"`HTTPHandler` не имеет никакого эффекта. Вместо вызова :meth:`~logging."
"Handler.format` этот обработчик вызывает :meth:`mapLogRecord`, а затем :func:"
"`urllib.parse.urlencode` для кодирования словаря в форме, подходящей для "
"отправки на веб-сервер. ."

#: ../../library/logging.handlers.rst:1020
msgid "QueueHandler"
msgstr "QueueHandler"

#: ../../library/logging.handlers.rst:1024
msgid ""
"The :class:`QueueHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a queue, such as those "
"implemented in the :mod:`queue` or :mod:`multiprocessing` modules."
msgstr ""
"Класс :class:`QueueHandler`, расположенный в модуле :mod:`logging.handlers`, "
"поддерживает отправку сообщений журнала в очередь, например, реализованных в "
"модулях :mod:`queue` или :mod:`multiprocessing`. ."

#: ../../library/logging.handlers.rst:1028
msgid ""
"Along with the :class:`QueueListener` class, :class:`QueueHandler` can be "
"used to let handlers do their work on a separate thread from the one which "
"does the logging. This is important in web applications and also other "
"service applications where threads servicing clients need to respond as "
"quickly as possible, while any potentially slow operations (such as sending "
"an email via :class:`SMTPHandler`) are done on a separate thread."
msgstr ""
"Наряду с классом :class:`QueueListener`, :class:`QueueHandler` может "
"использоваться, чтобы позволить обработчикам выполнять свою работу в "
"отдельном потоке от того, который ведет журналирование. Это важно в веб-"
"приложениях, а также в других сервисных приложениях, где потоки, "
"обслуживающие клиентов, должны реагировать как можно быстрее, в то время как "
"любые потенциально медленные операции (например, отправка электронной почты "
"через :class:`SMTPHandler`) выполняются в отдельном потоке."

#: ../../library/logging.handlers.rst:1037
msgid ""
"Returns a new instance of the :class:`QueueHandler` class. The instance is "
"initialized with the queue to send messages to. The *queue* can be any queue-"
"like object; it's used as-is by the :meth:`enqueue` method, which needs to "
"know how to send messages to it. The queue is not *required* to have the "
"task tracking API, which means that you can use :class:`~queue.SimpleQueue` "
"instances for *queue*."
msgstr ""
"Возвращает новый экземпляр класса :class:`QueueHandler`. Экземпляр "
"инициализируется очередью для отправки сообщений. *Очередь* может быть любым "
"объектом, похожим на очередь; он используется как есть методом :meth:"
"`enqueue`, которому необходимо знать, как отправлять ему сообщения. Очереди "
"не *обязаны* иметь API отслеживания задач, а это означает, что вы можете "
"использовать экземпляры :class:`~queue.SimpleQueue` для *queue*."

#: ../../library/logging.handlers.rst:1044
#: ../../library/logging.handlers.rst:1127
msgid ""
"If you are using :mod:`multiprocessing`, you should avoid using :class:"
"`~queue.SimpleQueue` and instead use :class:`multiprocessing.Queue`."
msgstr ""
"Если вы используете :mod:`multiprocessing`, вам следует избегать "
"использования :class:`~queue.SimpleQueue` и вместо этого использовать :class:"
"`multiprocessing.Queue`."

#: ../../library/logging.handlers.rst:1049
msgid ""
"Enqueues the result of preparing the LogRecord. Should an exception occur (e."
"g. because a bounded queue has filled up), the :meth:`~logging.Handler."
"handleError` method is called to handle the error. This can result in the "
"record silently being dropped (if :data:`logging.raiseExceptions` is "
"``False``) or a message printed to ``sys.stderr`` (if :data:`logging."
"raiseExceptions` is ``True``)."
msgstr ""
"Ставит в очередь результат подготовки LogRecord. В случае возникновения "
"исключения (например, из-за заполнения ограниченной очереди) для обработки "
"ошибки вызывается метод :meth:`~logging.Handler.handleError`. Это может "
"привести к молчаливому удалению записи (если :data:`logging.raiseExceptions` "
"имеет значение ``False``) или к выводу сообщения в ``sys.stderr`` (если :"
"data:`logging.raiseExceptions`` имеет значение `` «Правда»)."

#: ../../library/logging.handlers.rst:1058
msgid ""
"Prepares a record for queuing. The object returned by this method is "
"enqueued."
msgstr ""
"Подготавливает запись для постановки в очередь. Объект, возвращаемый этим "
"методом, ставится в очередь."

#: ../../library/logging.handlers.rst:1061
msgid ""
"The base implementation formats the record to merge the message, arguments, "
"exception and stack information, if present.  It also removes unpickleable "
"items from the record in-place. Specifically, it overwrites the record's :"
"attr:`msg` and :attr:`message` attributes with the merged message (obtained "
"by calling the handler's :meth:`format` method), and sets the :attr:`args`, :"
"attr:`exc_info` and :attr:`exc_text` attributes to ``None``."
msgstr ""
"Базовая реализация форматирует запись для объединения сообщения, аргументов, "
"исключений и информации стека, если они есть. Он также удаляет неподдающиеся "
"редактированию элементы из записи на месте. В частности, он перезаписывает "
"атрибуты записи :attr:`msg` и :attr:`message` объединенным сообщением "
"(полученным путем вызова метода :meth:`format` обработчика) и устанавливает :"
"attr:`args`, : Для атрибутов attr:`exc_info` и :attr:`exc_text` установлено "
"значение ``None``."

#: ../../library/logging.handlers.rst:1069
msgid ""
"You might want to override this method if you want to convert the record to "
"a dict or JSON string, or send a modified copy of the record while leaving "
"the original intact."
msgstr ""
"Возможно, вы захотите переопределить этот метод, если хотите преобразовать "
"запись в строку dict или JSON или отправить измененную копию записи, оставив "
"оригинал нетронутым."

#: ../../library/logging.handlers.rst:1073
msgid ""
"The base implementation formats the message with arguments, sets the "
"``message`` and ``msg`` attributes to the formatted message and sets the "
"``args`` and ``exc_text`` attributes to ``None`` to allow pickling and to "
"prevent further attempts at formatting. This means that a handler on the :"
"class:`QueueListener` side won't have the information to do custom "
"formatting, e.g. of exceptions. You may wish to subclass ``QueueHandler`` "
"and override this method to e.g. avoid setting ``exc_text`` to ``None``. "
"Note that the ``message`` / ``msg`` / ``args`` changes are related to "
"ensuring the record is pickleable, and you might or might not be able to "
"avoid doing that depending on whether your ``args`` are pickleable. (Note "
"that you may have to consider not only your own code but also code in any "
"libraries that you use.)"
msgstr ""
"Базовая реализация форматирует сообщение с аргументами, устанавливает "
"атрибуты ``message`` и ``msg`` для отформатированного сообщения и "
"устанавливает атрибуты ``args`` и ``exc_text`` в ``None``, чтобы разрешить "
"травление и предотвращение дальнейших попыток форматирования. Это означает, "
"что обработчик на стороне :class:`QueueListener` не будет иметь информации "
"для выполнения пользовательского форматирования, например, исключений. Вы "
"можете создать подкласс QueueHandler и переопределить этот метод, чтобы, "
"например, не устанавливать для exc_text значение None. Обратите внимание, "
"что изменения ``message``/``msg``/``args`` связаны с обеспечением "
"возможности выбора записи, и вы можете или не можете избежать этого в "
"зависимости от того, есть ли у вас ``args` ` можно мариновать. (Обратите "
"внимание, что вам, возможно, придется учитывать не только свой собственный "
"код, но и код любых библиотек, которые вы используете.)"

#: ../../library/logging.handlers.rst:1089
msgid ""
"Enqueues the record on the queue using ``put_nowait()``; you may want to "
"override this if you want to use blocking behaviour, or a timeout, or a "
"customized queue implementation."
msgstr ""
"Помещает запись в очередь с помощью put_nowait(); вы можете переопределить "
"это, если хотите использовать поведение блокировки, тайм-аут или "
"настраиваемую реализацию очереди."

#: ../../library/logging.handlers.rst:1098
msgid "QueueListener"
msgstr "QueueListener"

#: ../../library/logging.handlers.rst:1102
msgid ""
"The :class:`QueueListener` class, located in the :mod:`logging.handlers` "
"module, supports receiving logging messages from a queue, such as those "
"implemented in the :mod:`queue` or :mod:`multiprocessing` modules. The "
"messages are received from a queue in an internal thread and passed, on the "
"same thread, to one or more handlers for processing. While :class:"
"`QueueListener` is not itself a handler, it is documented here because it "
"works hand-in-hand with :class:`QueueHandler`."
msgstr ""
"Класс :class:`QueueListener`, расположенный в модуле :mod:`logging."
"handlers`, поддерживает получение сообщений журнала из очереди, например, "
"реализованных в модулях :mod:`queue` или :mod:`multiprocessing`. . Сообщения "
"принимаются из очереди во внутреннем потоке и передаются в том же потоке "
"одному или нескольким обработчикам для обработки. Хотя :class:"
"`QueueListener` сам по себе не является обработчиком, он описан здесь, "
"поскольку работает рука об руку с :class:`QueueHandler`."

#: ../../library/logging.handlers.rst:1110
msgid ""
"Along with the :class:`QueueHandler` class, :class:`QueueListener` can be "
"used to let handlers do their work on a separate thread from the one which "
"does the logging. This is important in web applications and also other "
"service applications where threads servicing clients need to respond as "
"quickly as possible, while any potentially slow operations (such as sending "
"an email via :class:`SMTPHandler`) are done on a separate thread."
msgstr ""
"Наряду с классом :class:`QueueHandler`, :class:`QueueListener` может "
"использоваться, чтобы позволить обработчикам выполнять свою работу в "
"отдельном потоке от того, который ведет журналирование. Это важно в веб-"
"приложениях, а также в других сервисных приложениях, где потоки, "
"обслуживающие клиентов, должны реагировать как можно быстрее, в то время как "
"любые потенциально медленные операции (например, отправка электронной почты "
"через :class:`SMTPHandler`) выполняются в отдельном потоке."

#: ../../library/logging.handlers.rst:1119
msgid ""
"Returns a new instance of the :class:`QueueListener` class. The instance is "
"initialized with the queue to send messages to and a list of handlers which "
"will handle entries placed on the queue. The queue can be any queue-like "
"object; it's passed as-is to the :meth:`dequeue` method, which needs to know "
"how to get messages from it. The queue is not *required* to have the task "
"tracking API (though it's used if available), which means that you can use :"
"class:`~queue.SimpleQueue` instances for *queue*."
msgstr ""
"Возвращает новый экземпляр класса :class:`QueueListener`. Экземпляр "
"инициализируется очередью для отправки сообщений и списком обработчиков, "
"которые будут обрабатывать записи, помещенные в очередь. Очередь может быть "
"любым объектом, похожим на очередь; он передается как есть методу :meth:"
"`dequeue`, который должен знать, как получать от него сообщения. Очереди "
"*необязательно* иметь API отслеживания задач (хотя он используется, если "
"доступен), что означает, что вы можете использовать экземпляры :class:"
"`~queue.SimpleQueue` для *queue*."

#: ../../library/logging.handlers.rst:1130
msgid ""
"If ``respect_handler_level`` is ``True``, a handler's level is respected "
"(compared with the level for the message) when deciding whether to pass "
"messages to that handler; otherwise, the behaviour is as in previous Python "
"versions - to always pass each message to each handler."
msgstr ""
"Если ``respect_handler_level`` имеет значение ``True``, уровень обработчика "
"учитывается (по сравнению с уровнем сообщения) при принятии решения о "
"передаче сообщений этому обработчику; в противном случае поведение такое же, "
"как и в предыдущих версиях Python — всегда передавать каждое сообщение "
"каждому обработчику."

#: ../../library/logging.handlers.rst:1135
msgid "The ``respect_handler_level`` argument was added."
msgstr "Был добавлен аргумент ``respect_handler_level``."

#: ../../library/logging.handlers.rst:1140
msgid "Dequeues a record and return it, optionally blocking."
msgstr ""
"Извлекает запись из очереди и возвращает ее, при необходимости блокируя."

#: ../../library/logging.handlers.rst:1142
msgid ""
"The base implementation uses ``get()``. You may want to override this method "
"if you want to use timeouts or work with custom queue implementations."
msgstr ""
"Базовая реализация использует get(). Возможно, вы захотите переопределить "
"этот метод, если хотите использовать таймауты или работать с настраиваемыми "
"реализациями очередей."

#: ../../library/logging.handlers.rst:1148
msgid "Prepare a record for handling."
msgstr "Подготовьте запись для обработки."

#: ../../library/logging.handlers.rst:1150
msgid ""
"This implementation just returns the passed-in record. You may want to "
"override this method if you need to do any custom marshalling or "
"manipulation of the record before passing it to the handlers."
msgstr ""
"Эта реализация просто возвращает переданную запись. Возможно, вы захотите "
"переопределить этот метод, если вам нужно выполнить какую-либо "
"пользовательскую сортировку или манипулирование записью перед ее передачей "
"обработчикам."

#: ../../library/logging.handlers.rst:1156
msgid "Handle a record."
msgstr "Обработать запись."

#: ../../library/logging.handlers.rst:1158
msgid ""
"This just loops through the handlers offering them the record to handle. The "
"actual object passed to the handlers is that which is returned from :meth:"
"`prepare`."
msgstr ""
"Это просто проходит через обработчики, предлагая им запись для обработки. "
"Фактический объект, передаваемый обработчикам, — это тот, который "
"возвращается из :meth:`prepare`."

#: ../../library/logging.handlers.rst:1164
msgid "Starts the listener."
msgstr "Запускает прослушиватель."

#: ../../library/logging.handlers.rst:1166
msgid ""
"This starts up a background thread to monitor the queue for LogRecords to "
"process."
msgstr ""
"При этом запускается фоновый поток для мониторинга очереди обработки "
"LogRecords."

#: ../../library/logging.handlers.rst:1171
msgid "Stops the listener."
msgstr "Останавливает слушателя."

#: ../../library/logging.handlers.rst:1173
msgid ""
"This asks the thread to terminate, and then waits for it to do so. Note that "
"if you don't call this before your application exits, there may be some "
"records still left on the queue, which won't be processed."
msgstr ""
"Это запрашивает завершение потока, а затем ждет, пока он это сделает. "
"Обратите внимание: если вы не вызовете это до завершения работы приложения, "
"в очереди могут остаться некоторые записи, которые не будут обработаны."

#: ../../library/logging.handlers.rst:1179
msgid ""
"Writes a sentinel to the queue to tell the listener to quit. This "
"implementation uses ``put_nowait()``.  You may want to override this method "
"if you want to use timeouts or work with custom queue implementations."
msgstr ""
"Записывает в очередь сигнал, сообщающий прослушивателю о выходе. Эта "
"реализация использует put_nowait(). Возможно, вы захотите переопределить "
"этот метод, если хотите использовать таймауты или работать с настраиваемыми "
"реализациями очередей."

#: ../../library/logging.handlers.rst:1190
msgid "Module :mod:`logging`"
msgstr "Модуль :mod:`logging`"

#: ../../library/logging.handlers.rst:1190
msgid "API reference for the logging module."
msgstr "Ссылка на API для модуля ведения журнала."

#: ../../library/logging.handlers.rst:1192
msgid "Module :mod:`logging.config`"
msgstr "Модуль :mod:`logging.config`"

#: ../../library/logging.handlers.rst:1193
msgid "Configuration API for the logging module."
msgstr "API конфигурации для модуля журналирования."
