# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Roustam Khamidoulline, 2024
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-25 14:54+0000\n"
"PO-Revision-Date: 2024-05-11 00:33+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/string.rst:2
msgid ":mod:`!string` --- Common string operations"
msgstr ":mod:`!string` --- Общие операции со строками"

#: ../../library/string.rst:7
msgid "**Source code:** :source:`Lib/string.py`"
msgstr "**Исходный код:** :source:`Lib/string.py`"

#: ../../library/string.rst:14
msgid ":ref:`textseq`"
msgstr ":ref:`textseq`"

#: ../../library/string.rst:16
msgid ":ref:`string-methods`"
msgstr ":ref:`string-methods`"

#: ../../library/string.rst:19
msgid "String constants"
msgstr "Строковые константы"

#: ../../library/string.rst:21
msgid "The constants defined in this module are:"
msgstr "В этом модуле определены следующие константы:"

#: ../../library/string.rst:26
msgid ""
"The concatenation of the :const:`ascii_lowercase` and :const:"
"`ascii_uppercase` constants described below.  This value is not locale-"
"dependent."
msgstr ""
"Объединение констант :const:`ascii_lowercase` и :const:`ascii_uppercase`, "
"описанное ниже. Это значение не зависит от локали."

#: ../../library/string.rst:32
msgid ""
"The lowercase letters ``'abcdefghijklmnopqrstuvwxyz'``.  This value is not "
"locale-dependent and will not change."
msgstr ""
"Строчные буквы ``'abcdefghijklmnopqrstuvwxyz'``. Это значение не зависит от "
"локали и не изменится."

#: ../../library/string.rst:38
msgid ""
"The uppercase letters ``'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``.  This value is not "
"locale-dependent and will not change."
msgstr ""
"Прописные буквы ``'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``. Это значение не зависит от "
"локали и не изменится."

#: ../../library/string.rst:44
msgid "The string ``'0123456789'``."
msgstr "Строка ``'0123456789'``."

#: ../../library/string.rst:49
msgid "The string ``'0123456789abcdefABCDEF'``."
msgstr "Строка ``'0123456789abcdefABCDEF'``."

#: ../../library/string.rst:54
msgid "The string ``'01234567'``."
msgstr "Строка ``'01234567'``."

#: ../../library/string.rst:59
msgid ""
"String of ASCII characters which are considered punctuation characters in "
"the ``C`` locale: ``!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~``."
msgstr ""
"Строка символов ASCII, которые считаются знаками пунктуации в локали ``C``: "
"``!\"#$%&'()*+,-./:;<=>?@[\\]^_`{| }~``."

#: ../../library/string.rst:65
msgid ""
"String of ASCII characters which are considered printable by Python. This is "
"a combination of :const:`digits`, :const:`ascii_letters`, :const:"
"`punctuation`, and :const:`whitespace`."
msgstr ""

#: ../../library/string.rst:71
msgid ""
"By design, :meth:`string.printable.isprintable() <str.isprintable>` returns :"
"const:`False`. In particular, ``string.printable`` is not printable in the "
"POSIX sense (see :manpage:`LC_CTYPE <locale(5)>`)."
msgstr ""

#: ../../library/string.rst:78
msgid ""
"A string containing all ASCII characters that are considered whitespace. "
"This includes the characters space, tab, linefeed, return, formfeed, and "
"vertical tab."
msgstr ""
"Строка, содержащая все символы ASCII, которые считаются пробелами. Сюда "
"входят пробелы, табуляция, перевод строки, возврат, перевод страницы и "
"вертикальная табуляция."

#: ../../library/string.rst:86
msgid "Custom String Formatting"
msgstr "Пользовательское форматирование строк"

#: ../../library/string.rst:88
msgid ""
"The built-in string class provides the ability to do complex variable "
"substitutions and value formatting via the :meth:`~str.format` method "
"described in :pep:`3101`.  The :class:`Formatter` class in the :mod:`string` "
"module allows you to create and customize your own string formatting "
"behaviors using the same implementation as the built-in :meth:`~str.format` "
"method."
msgstr ""
"Встроенный строковый класс предоставляет возможность выполнять сложные "
"замены переменных и форматирование значений с помощью метода :meth:`~str."
"format`, описанного в :pep:`3101`. Класс :class:`Formatter` в модуле :mod:"
"`string` позволяет вам создавать и настраивать собственные методы "
"форматирования строк, используя ту же реализацию, что и встроенный метод :"
"meth:`~str.format`."

#: ../../library/string.rst:97
msgid "The :class:`Formatter` class has the following public methods:"
msgstr "Класс :class:`Formatter` имеет следующие общедоступные методы:"

#: ../../library/string.rst:101
msgid ""
"The primary API method.  It takes a format string and an arbitrary set of "
"positional and keyword arguments. It is just a wrapper that calls :meth:"
"`vformat`."
msgstr ""
"Основной метод API. Он принимает строку формата и произвольный набор "
"позиционных и ключевых аргументов. Это просто оболочка, которая вызывает :"
"meth:`vformat`."

#: ../../library/string.rst:105
msgid ""
"A format string argument is now :ref:`positional-only <positional-"
"only_parameter>`."
msgstr ""
"Аргумент строки формата теперь имеет вид :ref:`positional-only <positional-"
"only_parameter>`."

#: ../../library/string.rst:111
msgid ""
"This function does the actual work of formatting.  It is exposed as a "
"separate function for cases where you want to pass in a predefined "
"dictionary of arguments, rather than unpacking and repacking the dictionary "
"as individual arguments using the ``*args`` and ``**kwargs`` syntax.  :meth:"
"`vformat` does the work of breaking up the format string into character data "
"and replacement fields.  It calls the various methods described below."
msgstr ""
"Эта функция выполняет фактическую работу по форматированию. Она "
"предоставляется как отдельная функция для случаев, когда вы хотите передать "
"предопределенный словарь аргументов, а не распаковывать и переупаковывать "
"словарь как отдельные аргументы, используя синтаксис ``*args`` и "
"``**kwargs``. :meth:`vformat` выполняет работу по разбиению строки формата "
"на символьные данные и поля замены. Он вызывает различные методы, описанные "
"ниже."

#: ../../library/string.rst:119
msgid ""
"In addition, the :class:`Formatter` defines a number of methods that are "
"intended to be replaced by subclasses:"
msgstr ""
"Кроме того, :class:`Formatter` определяет ряд методов, которые "
"предполагается заменить подклассами:"

#: ../../library/string.rst:124
msgid ""
"Loop over the format_string and return an iterable of tuples "
"(*literal_text*, *field_name*, *format_spec*, *conversion*).  This is used "
"by :meth:`vformat` to break the string into either literal text, or "
"replacement fields."
msgstr ""
"Переберите format_string и верните итерацию кортежей (*literal_text*, "
"*field_name*, *format_spec*, *conversion*). Это используется :meth:`vformat` "
"для разбиения строки на литеральный текст или поля замены."

#: ../../library/string.rst:129
msgid ""
"The values in the tuple conceptually represent a span of literal text "
"followed by a single replacement field.  If there is no literal text (which "
"can happen if two replacement fields occur consecutively), then "
"*literal_text* will be a zero-length string.  If there is no replacement "
"field, then the values of *field_name*, *format_spec* and *conversion* will "
"be ``None``."
msgstr ""
"Значения в кортеже концептуально представляют собой фрагмент буквального "
"текста, за которым следует одно поле замены. Если текст-литерал отсутствует "
"(что может произойти, если два поля замены встречаются последовательно), то "
"*literal_text* будет строкой нулевой длины. Если поля замены нет, то "
"значения *field_name*, *format_spec* и *conversion* будут равны ``None``."

#: ../../library/string.rst:138
msgid ""
"Given *field_name* as returned by :meth:`parse` (see above), convert it to "
"an object to be formatted.  Returns a tuple (obj, used_key).  The default "
"version takes strings of the form defined in :pep:`3101`, such as "
"\"0[name]\" or \"label.title\".  *args* and *kwargs* are as passed in to :"
"meth:`vformat`.  The return value *used_key* has the same meaning as the "
"*key* parameter to :meth:`get_value`."
msgstr ""
"Учитывая *field_name*, возвращенное :meth:`parse` (см. выше), преобразуйте "
"его в объект для форматирования. Возвращает кортеж (obj, Used_key). Версия "
"по умолчанию принимает строки формы, определенной в :pep:`3101`, например "
"\"0[имя]\" или \"label.title\". *args* и *kwargs* передаются в :meth:"
"`vformat`. Возвращаемое значение *used_key* имеет то же значение, что и "
"параметр *key* для :meth:`get_value`."

#: ../../library/string.rst:147
msgid ""
"Retrieve a given field value.  The *key* argument will be either an integer "
"or a string.  If it is an integer, it represents the index of the positional "
"argument in *args*; if it is a string, then it represents a named argument "
"in *kwargs*."
msgstr ""
"Получить заданное значение поля. Аргумент *key* может быть целым числом или "
"строкой. Если это целое число, оно представляет индекс позиционного "
"аргумента в *args*; если это строка, то она представляет именованный "
"аргумент в *kwargs*."

#: ../../library/string.rst:152
msgid ""
"The *args* parameter is set to the list of positional arguments to :meth:"
"`vformat`, and the *kwargs* parameter is set to the dictionary of keyword "
"arguments."
msgstr ""
"Для параметра *args* задан список позиционных аргументов :meth:`vformat`, а "
"для параметра *kwargs* задан словарь аргументов ключевых слов."

#: ../../library/string.rst:156
msgid ""
"For compound field names, these functions are only called for the first "
"component of the field name; subsequent components are handled through "
"normal attribute and indexing operations."
msgstr ""
"Для составных имен полей эти функции вызываются только для первого "
"компонента имени поля; последующие компоненты обрабатываются посредством "
"обычных операций атрибутов и индексации."

#: ../../library/string.rst:160
msgid ""
"So for example, the field expression '0.name' would cause :meth:`get_value` "
"to be called with a *key* argument of 0.  The ``name`` attribute will be "
"looked up after :meth:`get_value` returns by calling the built-in :func:"
"`getattr` function."
msgstr ""
"Так, например, выражение поля «0.name» приведет к вызову :meth:`get_value` с "
"аргументом *key*, равным 0. Атрибут ``name`` будет искаться после :meth:"
"`get_value` возвращается, вызывая встроенную функцию :func:`getattr`."

#: ../../library/string.rst:165
msgid ""
"If the index or keyword refers to an item that does not exist, then an :exc:"
"`IndexError` or :exc:`KeyError` should be raised."
msgstr ""
"Если индекс или ключевое слово ссылается на несуществующий элемент, то "
"должно быть выдано :exc:`IndexError` или :exc:`KeyError`."

#: ../../library/string.rst:170
msgid ""
"Implement checking for unused arguments if desired.  The arguments to this "
"function is the set of all argument keys that were actually referred to in "
"the format string (integers for positional arguments, and strings for named "
"arguments), and a reference to the *args* and *kwargs* that was passed to "
"vformat.  The set of unused args can be calculated from these parameters.  :"
"meth:`check_unused_args` is assumed to raise an exception if the check fails."
msgstr ""
"При необходимости реализуйте проверку неиспользуемых аргументов. Аргументами "
"этой функции является набор всех ключей аргументов, на которые фактически "
"ссылались в строке формата (целые числа для позиционных аргументов и строки "
"для именованных аргументов), а также ссылка на *args* и *kwargs*, которые "
"были переданы в функцию. vформат. Набор неиспользуемых аргументов можно "
"рассчитать на основе этих параметров. Предполагается, что :meth:"
"`check_unused_args` вызывает исключение, если проверка не удалась."

#: ../../library/string.rst:180
msgid ""
":meth:`format_field` simply calls the global :func:`format` built-in.  The "
"method is provided so that subclasses can override it."
msgstr ""
":meth:`format_field` просто вызывает глобальный встроенный :func:`format`. "
"Этот метод предоставляется для того, чтобы подклассы могли его "
"переопределить."

#: ../../library/string.rst:185
msgid ""
"Converts the value (returned by :meth:`get_field`) given a conversion type "
"(as in the tuple returned by the :meth:`parse` method).  The default version "
"understands 's' (str), 'r' (repr) and 'a' (ascii) conversion types."
msgstr ""
"Преобразует значение (возвращенное :meth:`get_field`) заданного типа "
"преобразования (как в кортеже, возвращаемом методом :meth:`parse`). Версия "
"по умолчанию поддерживает типы преобразования «s» (str), «r» (repr) и "
"«a» (ascii)."

#: ../../library/string.rst:194
msgid "Format String Syntax"
msgstr "Синтаксис форматной строки"

#: ../../library/string.rst:196
msgid ""
"The :meth:`str.format` method and the :class:`Formatter` class share the "
"same syntax for format strings (although in the case of :class:`Formatter`, "
"subclasses can define their own format string syntax).  The syntax is "
"related to that of :ref:`formatted string literals <f-strings>`, but it is "
"less sophisticated and, in particular, does not support arbitrary "
"expressions."
msgstr ""
"Метод :meth:`str.format` и класс :class:`Formatter` используют один и тот же "
"синтаксис для строк формата (хотя в случае :class:`Formatter` подклассы "
"могут определять свой собственный синтаксис строки формата). Синтаксис "
"аналогичен синтаксису :ref:`форматированных строковых литералов <f-"
"strings>`, но он менее сложен и, в частности, не поддерживает произвольные "
"выражения."

#: ../../library/string.rst:209
msgid ""
"Format strings contain \"replacement fields\" surrounded by curly braces ``{}"
"``. Anything that is not contained in braces is considered literal text, "
"which is copied unchanged to the output.  If you need to include a brace "
"character in the literal text, it can be escaped by doubling: ``{{`` and ``}}"
"``."
msgstr ""
"Строки формата содержат «поля замены», окруженные фигурными скобками ``{}``. "
"Все, что не заключено в фигурные скобки, считается обычным текстом и "
"копируется в выходные данные в неизмененном виде. Если вам нужно включить "
"фигурную скобку в обычный текст, ее можно экранировать удвоением: ``{{`` и "
"``}}``."

#: ../../library/string.rst:214
msgid "The grammar for a replacement field is as follows:"
msgstr "Грамматика поля замены следующая:"

#: ../../library/string.rst:226
msgid ""
"In less formal terms, the replacement field can start with a *field_name* "
"that specifies the object whose value is to be formatted and inserted into "
"the output instead of the replacement field. The *field_name* is optionally "
"followed by a  *conversion* field, which is preceded by an exclamation point "
"``'!'``, and a *format_spec*, which is preceded by a colon ``':'``.  These "
"specify a non-default format for the replacement value."
msgstr ""
"Говоря менее формально, поле замены может начинаться с *имя_поля*, "
"указывающего объект, значение которого должно быть отформатировано и "
"вставлено в выходные данные вместо поля замены. За *field_name* опционально "
"следует поле *conversion*, которому предшествует восклицательный знак "
"``'!'``, и *format_spec*, которому предшествует двоеточие ``':'``. Они "
"определяют формат замещающего значения, отличный от формата по умолчанию."

#: ../../library/string.rst:233
msgid "See also the :ref:`formatspec` section."
msgstr "См. также раздел :ref:`formatspec`."

#: ../../library/string.rst:235
msgid ""
"The *field_name* itself begins with an *arg_name* that is either a number or "
"a keyword.  If it's a number, it refers to a positional argument, and if "
"it's a keyword, it refers to a named keyword argument. An *arg_name* is "
"treated as a number if a call to :meth:`str.isdecimal` on the string would "
"return true. If the numerical arg_names in a format string are 0, 1, 2, ... "
"in sequence, they can all be omitted (not just some) and the numbers 0, 1, "
"2, ... will be automatically inserted in that order. Because *arg_name* is "
"not quote-delimited, it is not possible to specify arbitrary dictionary keys "
"(e.g., the strings ``'10'`` or ``':-]'``) within a format string. The "
"*arg_name* can be followed by any number of index or attribute expressions. "
"An expression of the form ``'.name'`` selects the named attribute using :"
"func:`getattr`, while an expression of the form ``'[index]'`` does an index "
"lookup using :meth:`~object.__getitem__`."
msgstr ""
"Само *field_name* начинается с *arg_name*, которое представляет собой число "
"или ключевое слово. Если это число, оно относится к позиционному аргументу, "
"а если это ключевое слово, оно относится к именованному ключевому аргументу. "
"*arg_name* рассматривается как число, если вызов :meth:`str.isdecimal` для "
"строки возвращает true. Если числовые имена arg_names в строке формата равны "
"0, 1, 2, ... последовательно, их все можно опустить (а не только некоторые), "
"и числа 0, 1, 2, ... будут автоматически вставлены в этом порядке. . "
"Поскольку *arg_name* не ограничивается кавычками, невозможно указать "
"произвольные ключи словаря (например, строки ``'10'`` или ``':-]'``) внутри "
"строки формата. За *arg_name* может следовать любое количество выражений "
"индекса или атрибута. Выражение формы ``'.name'`` выбирает именованный "
"атрибут, используя :func:`getattr`, а выражение формы ``'[index]'`` "
"выполняет поиск по индексу, используя :meth:`~ объект.__getitem__`."

#: ../../library/string.rst:249
msgid ""
"The positional argument specifiers can be omitted for :meth:`str.format`, so "
"``'{} {}'.format(a, b)`` is equivalent to ``'{0} {1}'.format(a, b)``."
msgstr ""
"Спецификаторы позиционных аргументов могут быть опущены для :meth:`str."
"format`, поэтому ``'{} {}'.format(a, b)`` эквивалентно ``'{0} {1}'.format "
"(а, б)``."

#: ../../library/string.rst:253
msgid ""
"The positional argument specifiers can be omitted for :class:`Formatter`."
msgstr ""
"Спецификаторы позиционных аргументов могут быть опущены для :class:"
"`Formatter`."

#: ../../library/string.rst:256
msgid "Some simple format string examples::"
msgstr "Несколько простых примеров строк форматирования:"

#: ../../library/string.rst:258
msgid ""
"\"First, thou shalt count to {0}\"  # References first positional argument\n"
"\"Bring me a {}\"                   # Implicitly references the first "
"positional argument\n"
"\"From {} to {}\"                   # Same as \"From {0} to {1}\"\n"
"\"My quest is {name}\"              # References keyword argument 'name'\n"
"\"Weight in tons {0.weight}\"       # 'weight' attribute of first positional "
"arg\n"
"\"Units destroyed: {players[0]}\"   # First element of keyword argument "
"'players'."
msgstr ""
"\"First, thou shalt count to {0}\"  # References first positional argument\n"
"\"Bring me a {}\"                   # Implicitly references the first "
"positional argument\n"
"\"From {} to {}\"                   # Same as \"From {0} to {1}\"\n"
"\"My quest is {name}\"              # References keyword argument 'name'\n"
"\"Weight in tons {0.weight}\"       # 'weight' attribute of first positional "
"arg\n"
"\"Units destroyed: {players[0]}\"   # First element of keyword argument "
"'players'."

#: ../../library/string.rst:265
msgid ""
"The *conversion* field causes a type coercion before formatting.  Normally, "
"the job of formatting a value is done by the :meth:`~object.__format__` "
"method of the value itself.  However, in some cases it is desirable to force "
"a type to be formatted as a string, overriding its own definition of "
"formatting.  By converting the value to a string before calling :meth:"
"`~object.__format__`, the normal formatting logic is bypassed."
msgstr ""
"Поле *conversion* вызывает приведение типа перед форматированием. Обычно "
"работа по форматированию значения выполняется методом :meth:`~object."
"__format__` самого значения. Однако в некоторых случаях желательно "
"принудительно отформатировать тип как строку, переопределив его собственное "
"определение форматирования. Преобразуя значение в строку перед вызовом :meth:"
"`~object.__format__`, нормальная логика форматирования обходит."

#: ../../library/string.rst:272
msgid ""
"Three conversion flags are currently supported: ``'!s'`` which calls :func:"
"`str` on the value, ``'!r'`` which calls :func:`repr` and ``'!a'`` which "
"calls :func:`ascii`."
msgstr ""
"В настоящее время поддерживаются три флага преобразования: ``'!s'``, который "
"вызывает :func:`str` для значения, ``'!r'``, который вызывает :func:`repr` и "
"``'!a' `` который вызывает :func:`ascii`."

#: ../../library/string.rst:276
msgid "Some examples::"
msgstr "Несколько примеров::"

#: ../../library/string.rst:278
msgid ""
"\"Harold's a clever {0!s}\"        # Calls str() on the argument first\n"
"\"Bring out the holy {name!r}\"    # Calls repr() on the argument first\n"
"\"More {!a}\"                      # Calls ascii() on the argument first"
msgstr ""
"\"Harold's a clever {0!s}\"        # Calls str() on the argument first\n"
"\"Bring out the holy {name!r}\"    # Calls repr() on the argument first\n"
"\"More {!a}\"                      # Calls ascii() on the argument first"

#: ../../library/string.rst:282
msgid ""
"The *format_spec* field contains a specification of how the value should be "
"presented, including such details as field width, alignment, padding, "
"decimal precision and so on.  Each value type can define its own "
"\"formatting mini-language\" or interpretation of the *format_spec*."
msgstr ""
"Поле *format_spec* содержит спецификацию того, как должно быть представлено "
"значение, включая такие детали, как ширина поля, выравнивание, заполнение, "
"десятичная точность и т. д. Каждый тип значения может определять свой "
"собственный «мини-язык форматирования» или интерпретацию *format_spec*."

#: ../../library/string.rst:287
msgid ""
"Most built-in types support a common formatting mini-language, which is "
"described in the next section."
msgstr ""
"Большинство встроенных типов поддерживают общий мини-язык форматирования, "
"который описан в следующем разделе."

#: ../../library/string.rst:290
msgid ""
"A *format_spec* field can also include nested replacement fields within it. "
"These nested replacement fields may contain a field name, conversion flag "
"and format specification, but deeper nesting is not allowed.  The "
"replacement fields within the format_spec are substituted before the "
"*format_spec* string is interpreted. This allows the formatting of a value "
"to be dynamically specified."
msgstr ""
"Поле *format_spec* также может включать в себя вложенные поля замены. Эти "
"вложенные поля замены могут содержать имя поля, флаг преобразования и "
"спецификацию формата, но более глубокая вложенность не допускается. Поля "
"замены в format_spec заменяются до интерпретации строки *format_spec*. Это "
"позволяет динамически задавать форматирование значения."

#: ../../library/string.rst:297
msgid "See the :ref:`formatexamples` section for some examples."
msgstr "Некоторые примеры см. в разделе :ref:`formatexamples`."

#: ../../library/string.rst:303
msgid "Format Specification Mini-Language"
msgstr "Спецификация формата"

#: ../../library/string.rst:305
msgid ""
"\"Format specifications\" are used within replacement fields contained "
"within a format string to define how individual values are presented (see :"
"ref:`formatstrings` and :ref:`f-strings`). They can also be passed directly "
"to the built-in :func:`format` function.  Each formattable type may define "
"how the format specification is to be interpreted."
msgstr ""
"«Спецификации формата» используются в полях замены, содержащихся в строке "
"формата, для определения способа представления отдельных значений (см. :ref:"
"`formatstrings` и :ref:`f-strings`). Их также можно передать непосредственно "
"встроенной функции :func:`format`. Каждый форматируемый тип может "
"определять, как следует интерпретировать спецификацию формата."

#: ../../library/string.rst:312
msgid ""
"Most built-in types implement the following options for format "
"specifications, although some of the formatting options are only supported "
"by the numeric types."
msgstr ""
"Большинство встроенных типов реализуют следующие параметры спецификаций "
"формата, хотя некоторые параметры форматирования поддерживаются только "
"числовыми типами."

#: ../../library/string.rst:315
msgid ""
"A general convention is that an empty format specification produces the same "
"result as if you had called :func:`str` on the value. A non-empty format "
"specification typically modifies the result."
msgstr ""
"Общее соглашение заключается в том, что пустая спецификация формата дает тот "
"же результат, как если бы вы вызвали :func:`str` для значения. Непустая "
"спецификация формата обычно изменяет результат."

#: ../../library/string.rst:319
msgid "The general form of a *standard format specifier* is:"
msgstr "Общая форма *спецификатора стандартного формата*:"

#: ../../library/string.rst:333
msgid ""
"If a valid *align* value is specified, it can be preceded by a *fill* "
"character that can be any character and defaults to a space if omitted. It "
"is not possible to use a literal curly brace (\"``{``\" or \"``}``\") as the "
"*fill* character in a :ref:`formatted string literal <f-strings>` or when "
"using the :meth:`str.format` method.  However, it is possible to insert a "
"curly brace with a nested replacement field.  This limitation doesn't affect "
"the :func:`format` function."
msgstr ""
"Если указано допустимое значение *align*, ему может предшествовать символ "
"*fill*, который может быть любым символом и по умолчанию равен пробелу, если "
"он опущен. Невозможно использовать буквальную фигурную скобку (\"``{``\" или "
"\"``}``\") в качестве символа *fill* в :ref:`форматированном строковом "
"литерале <f-strings>` или когда используя метод :meth:`str.format`. Однако "
"можно вставить фигурную скобку с вложенным полем замены. Это ограничение не "
"влияет на функцию :func:`format`."

#: ../../library/string.rst:342
msgid "The meaning of the various alignment options is as follows:"
msgstr "Смысл различных вариантов выравнивания следующий:"

#: ../../library/string.rst:351 ../../library/string.rst:383
#: ../../library/string.rst:442
msgid "Option"
msgstr "Опция"

#: ../../library/string.rst:351 ../../library/string.rst:383
#: ../../library/string.rst:442 ../../library/string.rst:481
#: ../../library/string.rst:492 ../../library/string.rst:527
msgid "Meaning"
msgstr "Значение"

#: ../../library/string.rst:353
msgid "``'<'``"
msgstr "``'<'``"

#: ../../library/string.rst:353
msgid ""
"Forces the field to be left-aligned within the available space (this is the "
"default for most objects)."
msgstr ""
"Принудительно выравнивает поле по левому краю в пределах доступного "
"пространства (это значение по умолчанию для большинства объектов)."

#: ../../library/string.rst:356
msgid "``'>'``"
msgstr "``'>'``"

#: ../../library/string.rst:356
msgid ""
"Forces the field to be right-aligned within the available space (this is the "
"default for numbers)."
msgstr ""
"Принудительно выравнивает поле по правому краю доступного пространства (это "
"значение по умолчанию для чисел)."

#: ../../library/string.rst:359
msgid "``'='``"
msgstr "``'='``"

#: ../../library/string.rst:359
msgid ""
"Forces the padding to be placed after the sign (if any) but before the "
"digits.  This is used for printing fields in the form '+000000120'. This "
"alignment option is only valid for numeric types, excluding :class:"
"`complex`. It becomes the default for numbers when '0' immediately precedes "
"the field width."
msgstr ""
"Принудительно размещает отступы после знака (если есть), но перед цифрами. "
"Это используется для печати полей в форме «+000000120». Этот параметр "
"выравнивания действителен только для числовых типов, за исключением :class:"
"`complex`. Оно становится значением по умолчанию для чисел, если перед "
"шириной поля стоит «0»."

#: ../../library/string.rst:366
msgid "``'^'``"
msgstr "``'^'``"

#: ../../library/string.rst:366
msgid "Forces the field to be centered within the available space."
msgstr "Заставляет поле центрироваться в пределах доступного пространства."

#: ../../library/string.rst:370
msgid ""
"Note that unless a minimum field width is defined, the field width will "
"always be the same size as the data to fill it, so that the alignment option "
"has no meaning in this case."
msgstr ""
"Обратите внимание: если не определена минимальная ширина поля, ширина поля "
"всегда будет того же размера, что и данные для его заполнения, поэтому опция "
"выравнивания в этом случае не имеет смысла."

#: ../../library/string.rst:374
msgid ""
"The *sign* option is only valid for number types, and can be one of the "
"following:"
msgstr ""
"Параметр *sign* действителен только для числовых типов и может быть одним из "
"следующих:"

#: ../../library/string.rst:385
msgid "``'+'``"
msgstr "``'+'``"

#: ../../library/string.rst:385
msgid ""
"Indicates that a sign should be used for both positive as well as negative "
"numbers."
msgstr ""

#: ../../library/string.rst:388
msgid "``'-'``"
msgstr "``'-'``"

#: ../../library/string.rst:388
msgid ""
"Indicates that a sign should be used only for negative numbers (this is the "
"default behavior)."
msgstr ""

#: ../../library/string.rst:377 ../../library/string.rst:391
msgid "space"
msgstr "space"

#: ../../library/string.rst:391
msgid ""
"Indicates that a leading space should be used on positive numbers, and a "
"minus sign on negative numbers."
msgstr ""

#: ../../library/string.rst:398
msgid ""
"The ``'z'`` option coerces negative zero floating-point values to positive "
"zero after rounding to the format precision.  This option is only valid for "
"floating-point presentation types."
msgstr ""
"Опция ``'z'`` приводит отрицательные нулевые значения с плавающей запятой к "
"положительному нулю после округления до точности формата. Этот параметр "
"действителен только для типов представления с плавающей запятой."

#: ../../library/string.rst:402
msgid "Added the ``'z'`` option (see also :pep:`682`)."
msgstr "Добавлена ​​опция ``'z'`` (см. также :pep:`682`)."

#: ../../library/string.rst:407
msgid ""
"The ``'#'`` option causes the \"alternate form\" to be used for the "
"conversion.  The alternate form is defined differently for different types.  "
"This option is only valid for integer, float and complex types. For "
"integers, when binary, octal, or hexadecimal output is used, this option "
"adds the respective prefix ``'0b'``, ``'0o'``, ``'0x'``, or ``'0X'`` to the "
"output value. For float and complex the alternate form causes the result of "
"the conversion to always contain a decimal-point character, even if no "
"digits follow it. Normally, a decimal-point character appears in the result "
"of these conversions only if a digit follows it. In addition, for ``'g'`` "
"and ``'G'`` conversions, trailing zeros are not removed from the result."
msgstr ""
"Опция ``'#'`` приводит к использованию \"альтернативной формы\" для "
"преобразования. Альтернативная форма определяется по-разному для разных "
"типов. Эта опция действительна только для целочисленных, плавающих и "
"комплексных типов. Для целых чисел, когда используется двоичный, "
"восьмеричный или шестнадцатеричный вывод, эта опция добавляет "
"соответствующий префикс ``'0b'``, ``'0o'``, ``'0x'`` или ``'0X' `` к "
"выходному значению. Для чисел с плавающей запятой и комплексных чисел "
"альтернативная форма приводит к тому, что результат преобразования всегда "
"содержит символ десятичной точки, даже если за ним не следуют никакие цифры. "
"Обычно символ десятичной точки появляется в результате этих преобразований "
"только в том случае, если за ним следует цифра. Кроме того, для "
"преобразований ``'g'`` и ``G'`` конечные нули из результата не удаляются."

#: ../../library/string.rst:419
msgid ""
"The *width* is a decimal integer defining the minimum total field width, "
"including any prefixes, separators, and other formatting characters. If not "
"specified, then the field width will be determined by the content."
msgstr ""
"*Ширина* — это десятичное целое число, определяющее минимальную общую ширину "
"поля, включая любые префиксы, разделители и другие символы форматирования. "
"Если не указано, то ширина поля будет определяться содержимым."

#: ../../library/string.rst:423
msgid ""
"When no explicit alignment is given, preceding the *width* field by a zero "
"(``'0'``) character enables sign-aware zero-padding for numeric types, "
"excluding :class:`complex`.  This is equivalent to a *fill* character of "
"``'0'`` with an *alignment* type of ``'='``."
msgstr ""
"Если явное выравнивание не задано, добавление к полю *width* нулевого "
"символа (``'0'``) включает заполнение нулями с учетом знаков для числовых "
"типов, за исключением :class:`complex`. Это эквивалентно *fill* символу "
"``'0'`` с типом *alignment* ``'='``."

#: ../../library/string.rst:428
msgid ""
"Preceding the *width* field by ``'0'`` no longer affects the default "
"alignment for strings."
msgstr ""
"Установка перед полем *width* значения ``'0'`` больше не влияет на "
"выравнивание строк по умолчанию."

#: ../../library/string.rst:433
msgid ""
"The *grouping* option after the *width* field specifies a digit group "
"separator for the integral part of a number. It can be one of the following:"
msgstr ""

#: ../../library/string.rst:444
msgid "``','``"
msgstr "``','``"

#: ../../library/string.rst:444
msgid ""
"Inserts a comma every 3 digits for integer presentation type ``'d'`` and "
"floating-point presentation types, excluding ``'n'``. For other presentation "
"types, this option is not supported."
msgstr ""

#: ../../library/string.rst:450
msgid "``'_'``"
msgstr "``'_'``"

#: ../../library/string.rst:450
msgid ""
"Inserts an underscore every 3 digits for integer presentation type ``'d'`` "
"and floating-point presentation types, excluding ``'n'``. For integer "
"presentation types ``'b'``, ``'o'``, ``'x'``, and ``'X'``, underscores are "
"inserted every 4 digits. For other presentation types, this option is not "
"supported."
msgstr ""
"Вставляет подчеркивание каждые 3 цифры для целочисленного типа представления "
"``'d'`` и типов представления с плавающей точкой, за исключением ``'n'``. "
"Для целочисленных типов представления ``'b'``, ``'o'``, ``'x'`` и ``'X'`` "
"подчеркивание вставляется каждые 4 цифры. Для других типов представления эта "
"опция не поддерживается."

#: ../../library/string.rst:460
msgid ""
"For a locale aware separator, use the ``'n'`` presentation type instead."
msgstr ""

#: ../../library/string.rst:462
msgid "Added the ``','`` option (see also :pep:`378`)."
msgstr "Добавлена ​​опция ``','`` (см. также :pep:`378`)."

#: ../../library/string.rst:465
msgid "Added the ``'_'`` option (see also :pep:`515`)."
msgstr "Добавлена ​​опция ``'_'`` (см. также :pep:`515`)."

#: ../../library/string.rst:468
msgid ""
"The *precision* is a decimal integer indicating how many digits should be "
"displayed after the decimal point for presentation types ``'f'`` and "
"``'F'``, or before and after the decimal point for presentation types "
"``'g'`` or ``'G'``.  For string presentation types the field indicates the "
"maximum field size - in other words, how many characters will be used from "
"the field content.  The *precision* is not allowed for integer presentation "
"types."
msgstr ""
"*Точность* — это десятичное целое число, указывающее, сколько цифр должно "
"отображаться после десятичной точки для типов представления ``'f'`` и "
"``'F'`` или до и после десятичной точки для типов представления `` 'g'`` или "
"``'G'``. Для строковых типов представления в поле указывается максимальный "
"размер поля — другими словами, сколько символов будет использовано из "
"содержимого поля. *Точность* не допускается для целочисленных типов "
"представления."

#: ../../library/string.rst:476
msgid "Finally, the *type* determines how the data should be presented."
msgstr "Наконец, *тип* определяет, как должны быть представлены данные."

#: ../../library/string.rst:478
msgid "The available string presentation types are:"
msgstr "Доступные типы строкового представления:"

#: ../../library/string.rst:481 ../../library/string.rst:492
#: ../../library/string.rst:527
msgid "Type"
msgstr "Тип"

#: ../../library/string.rst:483
msgid "``'s'``"
msgstr "``'s'``"

#: ../../library/string.rst:483
msgid "String format. This is the default type for strings and may be omitted."
msgstr ""
"Строковый формат. Это тип по умолчанию для строк, и его можно опустить."

#: ../../library/string.rst:486 ../../library/string.rst:515
#: ../../library/string.rst:601
msgid "None"
msgstr "None"

#: ../../library/string.rst:486
msgid "The same as ``'s'``."
msgstr "То же, что ``s'``."

#: ../../library/string.rst:489
msgid "The available integer presentation types are:"
msgstr "Доступные целочисленные типы представления:"

#: ../../library/string.rst:494
msgid "``'b'``"
msgstr "``'b'``"

#: ../../library/string.rst:494
msgid "Binary format. Outputs the number in base 2."
msgstr "Бинарный формат. Выводит число по основанию 2."

#: ../../library/string.rst:496
msgid "``'c'``"
msgstr "``'c'``"

#: ../../library/string.rst:496
msgid ""
"Character. Converts the integer to the corresponding unicode character "
"before printing."
msgstr ""
"Характер. Преобразует целое число в соответствующий символ Юникода перед "
"печатью."

#: ../../library/string.rst:499
msgid "``'d'``"
msgstr "``'d'``"

#: ../../library/string.rst:499
msgid "Decimal Integer. Outputs the number in base 10."
msgstr "Десятичное целое число. Выводит число в десятичной системе счисления."

#: ../../library/string.rst:501
msgid "``'o'``"
msgstr "``'o'``"

#: ../../library/string.rst:501
msgid "Octal format. Outputs the number in base 8."
msgstr "Восьмеричный формат. Выводит число по основанию 8."

#: ../../library/string.rst:503
msgid "``'x'``"
msgstr "``'x'``"

#: ../../library/string.rst:503
msgid ""
"Hex format. Outputs the number in base 16, using lower-case letters for the "
"digits above 9."
msgstr ""
"Шестнадцатеричный формат. Выводит число по основанию 16, используя строчные "
"буквы для цифр выше 9."

#: ../../library/string.rst:506
msgid "``'X'``"
msgstr "``'X'``"

#: ../../library/string.rst:506
msgid ""
"Hex format. Outputs the number in base 16, using upper-case letters for the "
"digits above 9. In case ``'#'`` is specified, the prefix ``'0x'`` will be "
"upper-cased to ``'0X'`` as well."
msgstr ""
"Шестнадцатеричный формат. Выводит число по основанию 16, используя заглавные "
"буквы для цифр выше 9. Если указан ``'#'``, префикс ``'0x'`` будет записан в "
"верхнем регистре до ``'0X' `` тоже."

#: ../../library/string.rst:511 ../../library/string.rst:593
msgid "``'n'``"
msgstr "``'n'``"

#: ../../library/string.rst:511
msgid ""
"Number. This is the same as ``'d'``, except that it uses the current locale "
"setting to insert the appropriate digit group separators."
msgstr ""

#: ../../library/string.rst:515
msgid "The same as ``'d'``."
msgstr "То же, что и ``'d'``."

#: ../../library/string.rst:518
msgid ""
"In addition to the above presentation types, integers can be formatted with "
"the floating-point presentation types listed below (except ``'n'`` and "
"``None``). When doing so, :func:`float` is used to convert the integer to a "
"floating-point number before formatting."
msgstr ""
"В дополнение к вышеуказанным типам представления, целые числа могут быть "
"отформатированы с использованием типов представления с плавающей запятой, "
"перечисленных ниже (кроме ``'n'`` и ``None``). При этом :func:`float` "
"используется для преобразования целого числа в число с плавающей запятой "
"перед форматированием."

#: ../../library/string.rst:523
msgid ""
"The available presentation types for :class:`float` and :class:`~decimal."
"Decimal` values are:"
msgstr ""
"Доступные типы представления для значений :class:`float` и :class:`~decimal."
"Decimal`:"

#: ../../library/string.rst:529
msgid "``'e'``"
msgstr "``'e'``"

#: ../../library/string.rst:529
msgid ""
"Scientific notation. For a given precision ``p``, formats the number in "
"scientific notation with the letter 'e' separating the coefficient from the "
"exponent. The coefficient has one digit before and ``p`` digits after the "
"decimal point, for a total of ``p + 1`` significant digits. With no "
"precision given, uses a precision of ``6`` digits after the decimal point "
"for :class:`float`, and shows all coefficient digits for :class:`~decimal."
"Decimal`.  If ``p=0``, the decimal point is omitted unless the ``#`` option "
"is used."
msgstr ""
"Научное обозначение. Для заданной точности ``p`` форматирует число в "
"экспоненциальной записи с буквой \"е\", отделяющей коэффициент от показателя "
"степени. Коэффициент имеет одну цифру до и цифры «p» после запятой, всего «p "
"+ 1» значащих цифр. Если точность не указана, используется точность в ``6`` "
"цифр после десятичной точки для :class:`float` и отображаются все цифры "
"коэффициентов для :class:`~decimal.Decimal`. Если ``p=0``, десятичная точка "
"опускается, если не используется опция ``#``."

#: ../../library/string.rst:540
msgid "``'E'``"
msgstr "``'E'``"

#: ../../library/string.rst:540
msgid ""
"Scientific notation. Same as ``'e'`` except it uses an upper case 'E' as the "
"separator character."
msgstr ""
"Научное обозначение. То же, что и ``'e'``, за исключением того, что в "
"качестве символа-разделителя используется заглавная буква \"E\"."

#: ../../library/string.rst:543
msgid "``'f'``"
msgstr "``'f'``"

#: ../../library/string.rst:543
msgid ""
"Fixed-point notation. For a given precision ``p``, formats the number as a "
"decimal number with exactly ``p`` digits following the decimal point. With "
"no precision given, uses a precision of ``6`` digits after the decimal point "
"for :class:`float`, and uses a precision large enough to show all "
"coefficient digits for :class:`~decimal.Decimal`.  If ``p=0``, the decimal "
"point is omitted unless the ``#`` option is used."
msgstr ""
"Обозначение фиксированной точки. Для заданной точности ``p`` форматирует "
"число как десятичное число с ровно ``p`` цифрами после десятичной точки. "
"Если точность не указана, используется точность в ``6`` цифр после "
"десятичной точки для :class:`float` и используется достаточно большая "
"точность, чтобы отобразить все цифры коэффициентов для :class:`~decimal."
"Decimal`. Если ``p=0``, десятичная точка опускается, если не используется "
"опция ``#``."

#: ../../library/string.rst:552
msgid "``'F'``"
msgstr "``'F'``"

#: ../../library/string.rst:552
msgid ""
"Fixed-point notation. Same as ``'f'``, but converts ``nan`` to  ``NAN`` and "
"``inf`` to ``INF``."
msgstr ""
"Обозначение фиксированной точки. То же, что и ``'f'``, но преобразует "
"``nan`` в ``NAN`` и ``inf`` в ``INF``."

#: ../../library/string.rst:555
msgid "``'g'``"
msgstr "``'g'``"

#: ../../library/string.rst:555
msgid ""
"General format.  For a given precision ``p >= 1``, this rounds the number to "
"``p`` significant digits and then formats the result in either fixed-point "
"format or in scientific notation, depending on its magnitude. A precision of "
"``0`` is treated as equivalent to a precision of ``1``."
msgstr ""
"Общий формат. Для заданной точности ``p >= 1`` число округляется до значащих "
"цифр ``p``, а затем форматируется результат либо в формате с фиксированной "
"запятой, либо в экспоненциальном представлении, в зависимости от его "
"величины. Точность ``0`` рассматривается как эквивалент точности ``1``."

#: ../../library/string.rst:562
msgid ""
"The precise rules are as follows: suppose that the result formatted with "
"presentation type ``'e'`` and precision ``p-1`` would have exponent "
"``exp``.  Then, if ``m <= exp < p``, where ``m`` is -4 for floats and -6 "
"for :class:`Decimals <decimal.Decimal>`, the number is formatted with "
"presentation type ``'f'`` and precision ``p-1-exp``.  Otherwise, the number "
"is formatted with presentation type ``'e'`` and precision ``p-1``. In both "
"cases insignificant trailing zeros are removed from the significand, and the "
"decimal point is also removed if there are no remaining digits following it, "
"unless the ``'#'`` option is used."
msgstr ""
"Точные правила таковы: предположим, что результат, отформатированный с типом "
"представления «e» и точностью «p-1», будет иметь показатель степени «exp». "
"Затем, если ``m <= exp < p``, где ``m`` равно -4 для чисел с плавающей "
"запятой и -6 для :class:`Decimals <decimal.Decimal>`, число форматируется с "
"использованием типа представления `` 'f'`` и точность ``p-1-exp``. В "
"противном случае число форматируется с использованием типа представления «e» "
"и точности «p-1». В обоих случаях незначащие конечные нули удаляются из "
"мантиссы, а также удаляется десятичная точка, если после нее не осталось "
"цифр, если только не используется опция ``'#'``."

#: ../../library/string.rst:575
msgid ""
"With no precision given, uses a precision of ``6`` significant digits for :"
"class:`float`. For :class:`~decimal.Decimal`, the coefficient of the result "
"is formed from the coefficient digits of the value; scientific notation is "
"used for values smaller than ``1e-6`` in absolute value and values where the "
"place value of the least significant digit is larger than 1, and fixed-point "
"notation is used otherwise."
msgstr ""
"Без указания точности используется точность в ``6`` значащих цифр для :class:"
"`float`. Для :class:`~decimal.Decimal` коэффициент результата формируется из "
"цифр коэффициента значения; Научное обозначение используется для значений, "
"меньших, чем ``1e-6`` по абсолютному значению, и значений, где разряд "
"младшей значащей цифры больше 1, в противном случае используется обозначение "
"с фиксированной точкой."

#: ../../library/string.rst:584
msgid ""
"Positive and negative infinity, positive and negative zero, and nans, are "
"formatted as ``inf``, ``-inf``, ``0``, ``-0`` and ``nan`` respectively, "
"regardless of the precision."
msgstr ""
"Положительная и отрицательная бесконечность, положительный и отрицательный "
"ноль, а также nans форматируются как ``inf``, ``-inf``, ``0``, ``-0`` и "
"``nan`` соответственно, независимо от точности."

#: ../../library/string.rst:589
msgid "``'G'``"
msgstr "``'G'``"

#: ../../library/string.rst:589
msgid ""
"General format. Same as ``'g'`` except switches to ``'E'`` if the number "
"gets too large. The representations of infinity and NaN are uppercased, too."
msgstr ""
"Общий формат. То же, что и ``'g'``, за исключением переключения на ``'E'``, "
"если число становится слишком большим. Представления бесконечности и NaN "
"также заглавны."

#: ../../library/string.rst:593
msgid ""
"Number. This is the same as ``'g'``, except that it uses the current locale "
"setting to insert the appropriate digit group separators for the integral "
"part of a number."
msgstr ""

#: ../../library/string.rst:598
msgid "``'%'``"
msgstr "``'%'``"

#: ../../library/string.rst:598
msgid ""
"Percentage. Multiplies the number by 100 and displays in fixed (``'f'``) "
"format, followed by a percent sign."
msgstr ""
"Процент. Умножает число на 100 и отображает его в фиксированном (``'f'``) "
"формате, за которым следует знак процента."

#: ../../library/string.rst:601
msgid ""
"For :class:`float` this is like the ``'g'`` type, except that when fixed-"
"point notation is used to format the result, it always includes at least one "
"digit past the decimal point, and switches to the scientific notation when "
"``exp >= p - 1``.  When the precision is not specified, the latter will be "
"as large as needed to represent the given value faithfully."
msgstr ""
"Для :class:`float` это похоже на тип ``'g'``, за исключением того, что когда "
"для форматирования результата используется запись с фиксированной запятой, "
"он всегда включает по крайней мере одну цифру после десятичной точки и "
"переключается на научное обозначение, когда ``exp >= p - 1``. Если точность "
"не указана, последняя будет настолько велика, насколько это необходимо для "
"точного представления заданного значения."

#: ../../library/string.rst:609
msgid ""
"For :class:`~decimal.Decimal`, this is the same as either ``'g'`` or ``'G'`` "
"depending on the value of ``context.capitals`` for the current decimal "
"context."
msgstr ""
"Для :class:`~decimal.Decimal` это то же самое, что ``'g'`` или ``'G'`` в "
"зависимости от значения ``context.capitals`` для текущего десятичного "
"контекста."

#: ../../library/string.rst:613
msgid ""
"The overall effect is to match the output of :func:`str` as altered by the "
"other format modifiers."
msgstr ""
"Общий эффект заключается в том, чтобы соответствовать выводу :func:`str`, "
"измененному другими модификаторами формата."

#: ../../library/string.rst:617
msgid ""
"The result should be correctly rounded to a given precision ``p`` of digits "
"after the decimal point.  The rounding mode for :class:`float` matches that "
"of the :func:`round` builtin.  For :class:`~decimal.Decimal`, the rounding "
"mode of the current :ref:`context <decimal-context>` will be used."
msgstr ""
"Результат должен быть правильно округлен до заданной точности p цифр после "
"десятичной точки. Режим округления для :class:`float` соответствует режиму "
"округления встроенной функции :func:`round`. Для :class:`~decimal.Decimal` "
"будет использоваться режим округления текущего :ref:`context <decimal-"
"context>`."

#: ../../library/string.rst:622
msgid ""
"The available presentation types for :class:`complex` are the same as those "
"for :class:`float` (``'%'`` is not allowed).  Both the real and imaginary "
"components of a complex number are formatted as floating-point numbers, "
"according to the specified presentation type.  They are separated by the "
"mandatory sign of the imaginary part, the latter being terminated by a ``j`` "
"suffix.  If the presentation type is missing, the result will match the "
"output of :func:`str` (complex numbers with a non-zero real part are also "
"surrounded by parentheses), possibly altered by other format modifiers."
msgstr ""
"Доступные типы представления для :class:`complex` такие же, как и для :class:"
"`float` (``'%'`` не допускается). И действительные, и мнимые компоненты "
"комплексного числа форматируются как числа с плавающей запятой в "
"соответствии с указанным типом представления. Они разделены обязательным "
"знаком мнимой части, последняя оканчивается суффиксом ``j``. Если тип "
"представления отсутствует, результат будет соответствовать выводу :func:"
"`str` (комплексные числа с ненулевой действительной частью также заключены в "
"круглые скобки), возможно, измененные другими модификаторами формата."

#: ../../library/string.rst:635
msgid "Format examples"
msgstr "Примеры форматов"

#: ../../library/string.rst:637
msgid ""
"This section contains examples of the :meth:`str.format` syntax and "
"comparison with the old ``%``-formatting."
msgstr ""
"Этот раздел содержит примеры синтаксиса :meth:`str.format` и сравнение со "
"старым форматированием ``%``."

#: ../../library/string.rst:640
msgid ""
"In most of the cases the syntax is similar to the old ``%``-formatting, with "
"the addition of the ``{}`` and with ``:`` used instead of ``%``. For "
"example, ``'%03.2f'`` can be translated to ``'{:03.2f}'``."
msgstr ""
"В большинстве случаев синтаксис аналогичен старому форматированию ``%``, с "
"добавлением ``{}`` и использованием ``:`` вместо ``%``. Например, ``' %03.2f "
"'`` можно перевести в ``'{:03.2f}'``."

#: ../../library/string.rst:644
msgid ""
"The new format syntax also supports new and different options, shown in the "
"following examples."
msgstr ""
"Новый синтаксис формата также поддерживает новые и различные параметры, "
"показанные в следующих примерах."

#: ../../library/string.rst:647
msgid "Accessing arguments by position::"
msgstr "Доступ к аргументам по позиции::"

#: ../../library/string.rst:649
msgid ""
">>> '{0}, {1}, {2}'.format('a', 'b', 'c')\n"
"'a, b, c'\n"
">>> '{}, {}, {}'.format('a', 'b', 'c')  # 3.1+ only\n"
"'a, b, c'\n"
">>> '{2}, {1}, {0}'.format('a', 'b', 'c')\n"
"'c, b, a'\n"
">>> '{2}, {1}, {0}'.format(*'abc')      # unpacking argument sequence\n"
"'c, b, a'\n"
">>> '{0}{1}{0}'.format('abra', 'cad')   # arguments' indices can be "
"repeated\n"
"'abracadabra'"
msgstr ""
">>> '{0}, {1}, {2}'.format('a', 'b', 'c')\n"
"'a, b, c'\n"
">>> '{}, {}, {}'.format('a', 'b', 'c')  # 3.1+ only\n"
"'a, b, c'\n"
">>> '{2}, {1}, {0}'.format('a', 'b', 'c')\n"
"'c, b, a'\n"
">>> '{2}, {1}, {0}'.format(*'abc')      # unpacking argument sequence\n"
"'c, b, a'\n"
">>> '{0}{1}{0}'.format('abra', 'cad')   # arguments' indices can be "
"repeated\n"
"'abracadabra'"

#: ../../library/string.rst:660
msgid "Accessing arguments by name::"
msgstr "Доступ к аргументам по имени::"

#: ../../library/string.rst:662
msgid ""
">>> 'Coordinates: {latitude}, {longitude}'.format(latitude='37.24N', "
"longitude='-115.81W')\n"
"'Coordinates: 37.24N, -115.81W'\n"
">>> coord = {'latitude': '37.24N', 'longitude': '-115.81W'}\n"
">>> 'Coordinates: {latitude}, {longitude}'.format(**coord)\n"
"'Coordinates: 37.24N, -115.81W'"
msgstr ""
">>> 'Coordinates: {latitude}, {longitude}'.format(latitude='37.24N', "
"longitude='-115.81W')\n"
"'Coordinates: 37.24N, -115.81W'\n"
">>> coord = {'latitude': '37.24N', 'longitude': '-115.81W'}\n"
">>> 'Coordinates: {latitude}, {longitude}'.format(**coord)\n"
"'Coordinates: 37.24N, -115.81W'"

#: ../../library/string.rst:668
msgid "Accessing arguments' attributes::"
msgstr "Доступ к атрибутам аргументов::"

#: ../../library/string.rst:670
msgid ""
">>> c = 3-5j\n"
">>> ('The complex number {0} is formed from the real part {0.real} '\n"
"...  'and the imaginary part {0.imag}.').format(c)\n"
"'The complex number (3-5j) is formed from the real part 3.0 and the "
"imaginary part -5.0.'\n"
">>> class Point:\n"
"...     def __init__(self, x, y):\n"
"...         self.x, self.y = x, y\n"
"...     def __str__(self):\n"
"...         return 'Point({self.x}, {self.y})'.format(self=self)\n"
"...\n"
">>> str(Point(4, 2))\n"
"'Point(4, 2)'"
msgstr ""
">>> c = 3-5j\n"
">>> ('The complex number {0} is formed from the real part {0.real} '\n"
"...  'and the imaginary part {0.imag}.').format(c)\n"
"'The complex number (3-5j) is formed from the real part 3.0 and the "
"imaginary part -5.0.'\n"
">>> class Point:\n"
"...     def __init__(self, x, y):\n"
"...         self.x, self.y = x, y\n"
"...     def __str__(self):\n"
"...         return 'Point({self.x}, {self.y})'.format(self=self)\n"
"...\n"
">>> str(Point(4, 2))\n"
"'Point(4, 2)'"

#: ../../library/string.rst:683
msgid "Accessing arguments' items::"
msgstr "Доступ к элементам аргументов::"

#: ../../library/string.rst:685
msgid ""
">>> coord = (3, 5)\n"
">>> 'X: {0[0]};  Y: {0[1]}'.format(coord)\n"
"'X: 3;  Y: 5'"
msgstr ""
">>> coord = (3, 5)\n"
">>> 'X: {0[0]};  Y: {0[1]}'.format(coord)\n"
"'X: 3;  Y: 5'"

#: ../../library/string.rst:689
msgid "Replacing ``%s`` and ``%r``::"
msgstr "Замена `` %s `` и ``%r``::"

#: ../../library/string.rst:691
msgid ""
">>> \"repr() shows quotes: {!r}; str() doesn't: {!s}\".format('test1', "
"'test2')\n"
"\"repr() shows quotes: 'test1'; str() doesn't: test2\""
msgstr ""
">>> \"repr() shows quotes: {!r}; str() doesn't: {!s}\".format('test1', "
"'test2')\n"
"\"repr() shows quotes: 'test1'; str() doesn't: test2\""

#: ../../library/string.rst:694
msgid "Aligning the text and specifying a width::"
msgstr "Выравнивание текста и указание ширины::"

#: ../../library/string.rst:696
msgid ""
">>> '{:<30}'.format('left aligned')\n"
"'left aligned                  '\n"
">>> '{:>30}'.format('right aligned')\n"
"'                 right aligned'\n"
">>> '{:^30}'.format('centered')\n"
"'           centered           '\n"
">>> '{:*^30}'.format('centered')  # use '*' as a fill char\n"
"'***********centered***********'"
msgstr ""
">>> '{:<30}'.format('left aligned')\n"
"'left aligned                  '\n"
">>> '{:>30}'.format('right aligned')\n"
"'                 right aligned'\n"
">>> '{:^30}'.format('centered')\n"
"'           centered           '\n"
">>> '{:*^30}'.format('centered')  # use '*' as a fill char\n"
"'***********centered***********'"

#: ../../library/string.rst:705
msgid "Replacing ``%+f``, ``%-f``, and ``% f`` and specifying a sign::"
msgstr "Замена `` %+f ``, `` %-f `` и ``%f`` и указав знак::"

#: ../../library/string.rst:707
msgid ""
">>> '{:+f}; {:+f}'.format(3.14, -3.14)  # show it always\n"
"'+3.140000; -3.140000'\n"
">>> '{: f}; {: f}'.format(3.14, -3.14)  # show a space for positive numbers\n"
"' 3.140000; -3.140000'\n"
">>> '{:-f}; {:-f}'.format(3.14, -3.14)  # show only the minus -- same as '{:"
"f}; {:f}'\n"
"'3.140000; -3.140000'"
msgstr ""
">>> '{:+f}; {:+f}'.format(3.14, -3.14)  # show it always\n"
"'+3.140000; -3.140000'\n"
">>> '{: f}; {: f}'.format(3.14, -3.14)  # show a space for positive numbers\n"
"' 3.140000; -3.140000'\n"
">>> '{:-f}; {:-f}'.format(3.14, -3.14)  # show only the minus -- same as '{:"
"f}; {:f}'\n"
"'3.140000; -3.140000'"

#: ../../library/string.rst:714
msgid ""
"Replacing ``%x`` and ``%o`` and converting the value to different bases::"
msgstr "Замена `` %х `` и `` %the `` и преобразование значения в разные базы::"

#: ../../library/string.rst:716
msgid ""
">>> # format also supports binary numbers\n"
">>> \"int: {0:d};  hex: {0:x};  oct: {0:o};  bin: {0:b}\".format(42)\n"
"'int: 42;  hex: 2a;  oct: 52;  bin: 101010'\n"
">>> # with 0x, 0o, or 0b as prefix:\n"
">>> \"int: {0:d};  hex: {0:#x};  oct: {0:#o};  bin: {0:#b}\".format(42)\n"
"'int: 42;  hex: 0x2a;  oct: 0o52;  bin: 0b101010'"
msgstr ""
">>> # format also supports binary numbers\n"
">>> \"int: {0:d};  hex: {0:x};  oct: {0:o};  bin: {0:b}\".format(42)\n"
"'int: 42;  hex: 2a;  oct: 52;  bin: 101010'\n"
">>> # with 0x, 0o, or 0b as prefix:\n"
">>> \"int: {0:d};  hex: {0:#x};  oct: {0:#o};  bin: {0:#b}\".format(42)\n"
"'int: 42;  hex: 0x2a;  oct: 0o52;  bin: 0b101010'"

#: ../../library/string.rst:723
msgid "Using the comma or the underscore as a digit group separator::"
msgstr ""

#: ../../library/string.rst:725
msgid ""
">>> '{:,}'.format(1234567890)\n"
"'1,234,567,890'\n"
">>> '{:_}'.format(1234567890)\n"
"'1_234_567_890'\n"
">>> '{:_b}'.format(1234567890)\n"
"'100_1001_1001_0110_0000_0010_1101_0010'\n"
">>> '{:_x}'.format(1234567890)\n"
"'4996_02d2'"
msgstr ""

#: ../../library/string.rst:734
msgid "Expressing a percentage::"
msgstr "Выражая проценты::"

#: ../../library/string.rst:736
msgid ""
">>> points = 19\n"
">>> total = 22\n"
">>> 'Correct answers: {:.2%}'.format(points/total)\n"
"'Correct answers: 86.36%'"
msgstr ""
">>> points = 19\n"
">>> total = 22\n"
">>> 'Correct answers: {:.2%}'.format(points/total)\n"
"'Correct answers: 86.36%'"

#: ../../library/string.rst:741
msgid "Using type-specific formatting::"
msgstr "Использование форматирования, специфичного для типа::"

#: ../../library/string.rst:743
msgid ""
">>> import datetime\n"
">>> d = datetime.datetime(2010, 7, 4, 12, 15, 58)\n"
">>> '{:%Y-%m-%d %H:%M:%S}'.format(d)\n"
"'2010-07-04 12:15:58'"
msgstr ""
">>> import datetime\n"
">>> d = datetime.datetime(2010, 7, 4, 12, 15, 58)\n"
">>> '{:%Y-%m-%d %H:%M:%S}'.format(d)\n"
"'2010-07-04 12:15:58'"

#: ../../library/string.rst:748
msgid "Nesting arguments and more complex examples::"
msgstr "Вложенные аргументы и более сложные примеры:"

#: ../../library/string.rst:750
msgid ""
">>> for align, text in zip('<^>', ['left', 'center', 'right']):\n"
"...     '{0:{fill}{align}16}'.format(text, fill=align, align=align)\n"
"...\n"
"'left<<<<<<<<<<<<'\n"
"'^^^^^center^^^^^'\n"
"'>>>>>>>>>>>right'\n"
">>>\n"
">>> octets = [192, 168, 0, 1]\n"
">>> '{:02X}{:02X}{:02X}{:02X}'.format(*octets)\n"
"'C0A80001'\n"
">>> int(_, 16)\n"
"3232235521\n"
">>>\n"
">>> width = 5\n"
">>> for num in range(5,12):\n"
"...     for base in 'dXob':\n"
"...         print('{0:{width}{base}}'.format(num, base=base, width=width), "
"end=' ')\n"
"...     print()\n"
"...\n"
"    5     5     5   101\n"
"    6     6     6   110\n"
"    7     7     7   111\n"
"    8     8    10  1000\n"
"    9     9    11  1001\n"
"   10     A    12  1010\n"
"   11     B    13  1011"
msgstr ""
">>> for align, text in zip('<^>', ['left', 'center', 'right']):\n"
"...     '{0:{fill}{align}16}'.format(text, fill=align, align=align)\n"
"...\n"
"'left<<<<<<<<<<<<'\n"
"'^^^^^center^^^^^'\n"
"'>>>>>>>>>>>right'\n"
">>>\n"
">>> octets = [192, 168, 0, 1]\n"
">>> '{:02X}{:02X}{:02X}{:02X}'.format(*octets)\n"
"'C0A80001'\n"
">>> int(_, 16)\n"
"3232235521\n"
">>>\n"
">>> width = 5\n"
">>> for num in range(5,12):\n"
"...     for base in 'dXob':\n"
"...         print('{0:{width}{base}}'.format(num, base=base, width=width), "
"end=' ')\n"
"...     print()\n"
"...\n"
"    5     5     5   101\n"
"    6     6     6   110\n"
"    7     7     7   111\n"
"    8     8    10  1000\n"
"    9     9    11  1001\n"
"   10     A    12  1010\n"
"   11     B    13  1011"

#: ../../library/string.rst:782
msgid "Template strings"
msgstr "Строки шаблона"

#: ../../library/string.rst:784
msgid ""
"Template strings provide simpler string substitutions as described in :pep:"
"`292`.  A primary use case for template strings is for internationalization "
"(i18n) since in that context, the simpler syntax and functionality makes it "
"easier to translate than other built-in string formatting facilities in "
"Python.  As an example of a library built on template strings for i18n, see "
"the `flufl.i18n <https://flufli18n.readthedocs.io/en/latest/>`_ package."
msgstr ""
"Строки шаблонов обеспечивают более простые замены строк, как описано в :pep:"
"`292`. Основным вариантом использования строк шаблона является "
"интернационализация (i18n), поскольку в этом контексте более простой "
"синтаксис и функциональность упрощают перевод, чем другие встроенные "
"средства форматирования строк в Python. В качестве примера библиотеки, "
"построенной на строках шаблона для i18n, см. пакет `flufl.i18n <https://"
"flufli18n.readthedocs.io/en/latest/>`_."

#: ../../library/string.rst:794
msgid ""
"Template strings support ``$``-based substitutions, using the following "
"rules:"
msgstr ""
"Строки шаблонов поддерживают замены на основе ``$``, используя следующие "
"правила:"

#: ../../library/string.rst:796
msgid "``$$`` is an escape; it is replaced with a single ``$``."
msgstr "``$$`` — это побег; он заменяется одним ``$``."

#: ../../library/string.rst:798
msgid ""
"``$identifier`` names a substitution placeholder matching a mapping key of "
"``\"identifier\"``.  By default, ``\"identifier\"`` is restricted to any "
"case-insensitive ASCII alphanumeric string (including underscores) that "
"starts with an underscore or ASCII letter.  The first non-identifier "
"character after the ``$`` character terminates this placeholder "
"specification."
msgstr ""
"``$identifier`` называет заполнитель подстановки, соответствующий ключу "
"сопоставления ``\"identifier\"``. По умолчанию ``\"идентификатор\"`` "
"ограничивается любой буквенно-цифровой строкой ASCII без учета регистра "
"(включая символы подчеркивания), которая начинается с символа подчеркивания "
"или буквы ASCII. Первый неидентифицирующий символ после символа ``$`` "
"завершает эту спецификацию заполнителя."

#: ../../library/string.rst:805
msgid ""
"``${identifier}`` is equivalent to ``$identifier``.  It is required when "
"valid identifier characters follow the placeholder but are not part of the "
"placeholder, such as ``\"${noun}ification\"``."
msgstr ""
"``${identifier}`` эквивалентен ``$identifier``. Это требуется, когда "
"действительные символы идентификатора следуют за заполнителем, но не "
"являются его частью, например ``\"${noun}ification\"``."

#: ../../library/string.rst:809
msgid ""
"Any other appearance of ``$`` in the string will result in a :exc:"
"`ValueError` being raised."
msgstr ""
"Любое другое появление ``$`` в строке приведет к возникновению :exc:"
"`ValueError`."

#: ../../library/string.rst:812
msgid ""
"The :mod:`string` module provides a :class:`Template` class that implements "
"these rules.  The methods of :class:`Template` are:"
msgstr ""
"Модуль :mod:`string` предоставляет класс :class:`Template`, который "
"реализует эти правила. Методы :class:`Template`:"

#: ../../library/string.rst:818
msgid "The constructor takes a single argument which is the template string."
msgstr ""
"Конструктор принимает единственный аргумент, который является строкой "
"шаблона."

#: ../../library/string.rst:823
msgid ""
"Performs the template substitution, returning a new string.  *mapping* is "
"any dictionary-like object with keys that match the placeholders in the "
"template.  Alternatively, you can provide keyword arguments, where the "
"keywords are the placeholders.  When both *mapping* and *kwds* are given and "
"there are duplicates, the placeholders from *kwds* take precedence."
msgstr ""
"Выполняет замену шаблона, возвращая новую строку. *отображение* — это любой "
"объект, подобный словарю, ключи которого соответствуют заполнителям в "
"шаблоне. Альтернативно вы можете предоставить аргументы ключевых слов, где "
"ключевые слова являются заполнителями. Если заданы и *mapping*, и *kwds* и "
"имеются дубликаты, заполнители из *kwds* имеют приоритет."

#: ../../library/string.rst:832
msgid ""
"Like :meth:`substitute`, except that if placeholders are missing from "
"*mapping* and *kwds*, instead of raising a :exc:`KeyError` exception, the "
"original placeholder will appear in the resulting string intact.  Also, "
"unlike with :meth:`substitute`, any other appearances of the ``$`` will "
"simply return ``$`` instead of raising :exc:`ValueError`."
msgstr ""
"Аналогично :meth:`substitute`, за исключением того, что если заполнители "
"отсутствуют в *mapping* и *kwds*, вместо того, чтобы вызывать исключение :"
"exc:`KeyError`, исходный заполнитель появится в результирующей строке "
"неповрежденным. Кроме того, в отличие от :meth:`substitute`, любое другое "
"появление ``$`` просто вернет ``$`` вместо вызова :exc:`ValueError`."

#: ../../library/string.rst:838
msgid ""
"While other exceptions may still occur, this method is called \"safe\" "
"because it always tries to return a usable string instead of raising an "
"exception.  In another sense, :meth:`safe_substitute` may be anything other "
"than safe, since it will silently ignore malformed templates containing "
"dangling delimiters, unmatched braces, or placeholders that are not valid "
"Python identifiers."
msgstr ""
"Хотя могут возникать и другие исключения, этот метод называется "
"«безопасным», поскольку он всегда пытается вернуть пригодную для "
"использования строку вместо того, чтобы вызывать исключение. В другом "
"смысле :meth:`safe_substitute` может быть чем угодно, только не безопасным, "
"поскольку он будет молча игнорировать некорректные шаблоны, содержащие "
"висячие разделители, несовпадающие фигурные скобки или заполнители, которые "
"не являются допустимыми идентификаторами Python."

#: ../../library/string.rst:848
msgid ""
"Returns false if the template has invalid placeholders that will cause :meth:"
"`substitute` to raise :exc:`ValueError`."
msgstr ""
"Возвращает false, если в шаблоне есть недопустимые заполнители, что приведет "
"к тому, что :meth:`substitute` вызовет :exc:`ValueError`."

#: ../../library/string.rst:856
msgid ""
"Returns a list of the valid identifiers in the template, in the order they "
"first appear, ignoring any invalid identifiers."
msgstr ""
"Возвращает список допустимых идентификаторов в шаблоне в порядке их первого "
"появления, игнорируя все недопустимые идентификаторы."

#: ../../library/string.rst:861
msgid ":class:`Template` instances also provide one public data attribute:"
msgstr ""
"Экземпляры :class:`Template` также предоставляют один общедоступный атрибут "
"данных:"

#: ../../library/string.rst:865
msgid ""
"This is the object passed to the constructor's *template* argument.  In "
"general, you shouldn't change it, but read-only access is not enforced."
msgstr ""
"Это объект, передаваемый в аргумент *template* конструктора. В общем, менять "
"его не следует, но доступ только для чтения не предусмотрен."

#: ../../library/string.rst:868
msgid "Here is an example of how to use a Template::"
msgstr "Вот пример использования шаблона:"

#: ../../library/string.rst:870
msgid ""
">>> from string import Template\n"
">>> s = Template('$who likes $what')\n"
">>> s.substitute(who='tim', what='kung pao')\n"
"'tim likes kung pao'\n"
">>> d = dict(who='tim')\n"
">>> Template('Give $who $100').substitute(d)\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: Invalid placeholder in string: line 1, col 11\n"
">>> Template('$who likes $what').substitute(d)\n"
"Traceback (most recent call last):\n"
"...\n"
"KeyError: 'what'\n"
">>> Template('$who likes $what').safe_substitute(d)\n"
"'tim likes $what'"
msgstr ""
">>> from string import Template\n"
">>> s = Template('$who likes $what')\n"
">>> s.substitute(who='tim', what='kung pao')\n"
"'tim likes kung pao'\n"
">>> d = dict(who='tim')\n"
">>> Template('Give $who $100').substitute(d)\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: Invalid placeholder in string: line 1, col 11\n"
">>> Template('$who likes $what').substitute(d)\n"
"Traceback (most recent call last):\n"
"...\n"
"KeyError: 'what'\n"
">>> Template('$who likes $what').safe_substitute(d)\n"
"'tim likes $what'"

#: ../../library/string.rst:886
msgid ""
"Advanced usage: you can derive subclasses of :class:`Template` to customize "
"the placeholder syntax, delimiter character, or the entire regular "
"expression used to parse template strings.  To do this, you can override "
"these class attributes:"
msgstr ""
"Расширенное использование: вы можете получить подклассы :class:`Template` "
"для настройки синтаксиса заполнителя, символа-разделителя или всего "
"регулярного выражения, используемого для анализа строк шаблона. Для этого вы "
"можете переопределить эти атрибуты класса:"

#: ../../library/string.rst:891
msgid ""
"*delimiter* -- This is the literal string describing a placeholder "
"introducing delimiter.  The default value is ``$``.  Note that this should "
"*not* be a regular expression, as the implementation will call :meth:`re."
"escape` on this string as needed.  Note further that you cannot change the "
"delimiter after class creation (i.e. a different delimiter must be set in "
"the subclass's class namespace)."
msgstr ""
"*разделитель* — это литеральная строка, описывающая заполнитель, вводящий "
"разделитель. Значение по умолчанию — ``$``. Обратите внимание, что это *не* "
"должно быть регулярным выражением, поскольку реализация будет вызывать :meth:"
"`re.escape` для этой строки по мере необходимости. Обратите внимание, что вы "
"не можете изменить разделитель после создания класса (т. е. в пространстве "
"имен классов подкласса должен быть установлен другой разделитель)."

#: ../../library/string.rst:898
msgid ""
"*idpattern* -- This is the regular expression describing the pattern for non-"
"braced placeholders.  The default value is the regular expression ``(?a:[_a-"
"z][_a-z0-9]*)``.  If this is given and *braceidpattern* is ``None`` this "
"pattern will also apply to braced placeholders."
msgstr ""
"*idpattern* — это регулярное выражение, описывающее шаблон для заполнителей "
"без фигурных скобок. Значением по умолчанию является регулярное выражение "
"``(?a:[_a-z][_a-z0-9]*)``. Если это задано, а *braceidpattern* имеет "
"значение None, этот шаблон также будет применяться к заполнителям в фигурных "
"скобках."

#: ../../library/string.rst:905
msgid ""
"Since default *flags* is ``re.IGNORECASE``, pattern ``[a-z]`` can match with "
"some non-ASCII characters. That's why we use the local ``a`` flag here."
msgstr ""
"Поскольку *flags* по умолчанию имеет значение ``re.IGNORECASE``, шаблон "
"``[az]`` может соответствовать некоторым символам, отличным от ASCII. Вот "
"почему мы используем здесь локальный флаг ``a``."

#: ../../library/string.rst:909
msgid ""
"*braceidpattern* can be used to define separate patterns used inside and "
"outside the braces."
msgstr ""
"*braceidpattern* можно использовать для определения отдельных шаблонов, "
"используемых внутри и снаружи фигурных скобок."

#: ../../library/string.rst:913
msgid ""
"*braceidpattern* -- This is like *idpattern* but describes the pattern for "
"braced placeholders.  Defaults to ``None`` which means to fall back to "
"*idpattern* (i.e. the same pattern is used both inside and outside braces). "
"If given, this allows you to define different patterns for braced and "
"unbraced placeholders."
msgstr ""
"*braceidpattern* — это похоже на *idpattern*, но описывает шаблон для "
"заполнителей в фигурных скобках. По умолчанию установлено значение None, что "
"означает возврат к *idpattern* (т.е. один и тот же шаблон используется как "
"внутри, так и снаружи фигурных скобок). Если задано, это позволяет вам "
"определять разные шаблоны для закреплённых и незакреплённых заполнителей."

#: ../../library/string.rst:921
msgid ""
"*flags* -- The regular expression flags that will be applied when compiling "
"the regular expression used for recognizing substitutions.  The default "
"value is ``re.IGNORECASE``.  Note that ``re.VERBOSE`` will always be added "
"to the flags, so custom *idpattern*\\ s must follow conventions for verbose "
"regular expressions."
msgstr ""
"*flags* — флаги регулярного выражения, которые будут применяться при "
"компиляции регулярного выражения, используемого для распознавания замен. "
"Значение по умолчанию — re.IGNORECASE. Обратите внимание, что ``re.VERBOSE`` "
"всегда будет добавляться к флагам, поэтому пользовательские *idpattern*\\ "
"должны соответствовать соглашениям для многословных регулярных выражений."

#: ../../library/string.rst:929
msgid ""
"Alternatively, you can provide the entire regular expression pattern by "
"overriding the class attribute *pattern*.  If you do this, the value must be "
"a regular expression object with four named capturing groups.  The capturing "
"groups correspond to the rules given above, along with the invalid "
"placeholder rule:"
msgstr ""
"Альтернативно вы можете предоставить весь шаблон регулярного выражения, "
"переопределив атрибут класса *pattern*. В этом случае значение должно быть "
"объектом регулярного выражения с четырьмя именованными группами захвата. "
"Группы захвата соответствуют правилам, приведенным выше, а также правилу "
"недопустимого заполнителя:"

#: ../../library/string.rst:935
msgid ""
"*escaped* -- This group matches the escape sequence, e.g. ``$$``, in the "
"default pattern."
msgstr ""
"*escaped* — эта группа соответствует escape-последовательности, например ``$"
"$``, в шаблоне по умолчанию."

#: ../../library/string.rst:938
msgid ""
"*named* -- This group matches the unbraced placeholder name; it should not "
"include the delimiter in capturing group."
msgstr ""
"*named* — эта группа соответствует имени-заполнителю без фигурных скобок; он "
"не должен включать разделитель в группу захвата."

#: ../../library/string.rst:941
msgid ""
"*braced* -- This group matches the brace enclosed placeholder name; it "
"should not include either the delimiter or braces in the capturing group."
msgstr ""
"*braced* -- Эта группа соответствует имени заполнителя, заключенному в "
"фигурные скобки; в группе захвата не должно быть ни разделителя, ни фигурных "
"скобок."

#: ../../library/string.rst:944
msgid ""
"*invalid* -- This group matches any other delimiter pattern (usually a "
"single delimiter), and it should appear last in the regular expression."
msgstr ""
"*invalid* — эта группа соответствует любому другому шаблону разделителя "
"(обычно одиночному разделителю) и должна появляться последней в регулярном "
"выражении."

#: ../../library/string.rst:947
msgid ""
"The methods on this class will raise :exc:`ValueError` if the pattern "
"matches the template without one of these named groups matching."
msgstr ""
"Методы этого класса вызовут :exc:`ValueError`, если шаблон соответствует "
"шаблону без совпадения ни одной из этих именованных групп."

#: ../../library/string.rst:952
msgid "Helper functions"
msgstr "Вспомогательные функции"

#: ../../library/string.rst:956
msgid ""
"Split the argument into words using :meth:`str.split`, capitalize each word "
"using :meth:`str.capitalize`, and join the capitalized words using :meth:"
"`str.join`.  If the optional second argument *sep* is absent or ``None``, "
"runs of whitespace characters are replaced by a single space and leading and "
"trailing whitespace are removed, otherwise *sep* is used to split and join "
"the words."
msgstr ""
"Разделите аргумент на слова, используя :meth:`str.split`, напишите каждое "
"слово с заглавной буквы, используя :meth:`str.capitalize`, и соедините слова "
"с заглавной буквы, используя :meth:`str.join`. Если необязательный второй "
"аргумент *sep* отсутствует или ``None``, серии пробелов заменяются одним "
"пробелом, а начальные и конечные пробелы удаляются, в противном случае *sep* "
"используется для разделения и соединения слов."

#: ../../library/string.rst:202
msgid "{} (curly brackets)"
msgstr "{} (фигурные скобки)"

#: ../../library/string.rst:202 ../../library/string.rst:344
#: ../../library/string.rst:377 ../../library/string.rst:396
#: ../../library/string.rst:405 ../../library/string.rst:437
msgid "in string formatting"
msgstr "в форматировании строк"

#: ../../library/string.rst:202
msgid ". (dot)"
msgstr ". (точка)"

#: ../../library/string.rst:202
msgid "[] (square brackets)"
msgstr "[] (квадратные скобки)"

#: ../../library/string.rst:202
msgid "! (exclamation)"
msgstr "! (восклицание)"

#: ../../library/string.rst:202
msgid ": (colon)"
msgstr ": (двоеточие)"

#: ../../library/string.rst:344
msgid "< (less)"
msgstr "< (меньше)"

#: ../../library/string.rst:344
msgid "> (greater)"
msgstr "> (больше)"

#: ../../library/string.rst:344
msgid "= (equals)"
msgstr "= (равно)"

#: ../../library/string.rst:344
msgid "^ (caret)"
msgstr "^ (caret)"

#: ../../library/string.rst:377
msgid "+ (plus)"
msgstr "+ (плюс)"

#: ../../library/string.rst:377
msgid "- (minus)"
msgstr "- (минус)"

#: ../../library/string.rst:396
msgid "z"
msgstr "z"

#: ../../library/string.rst:405
msgid "# (hash)"
msgstr "# (hash)"

#: ../../library/string.rst:437
msgid ", (comma)"
msgstr ", (запятая)"

#: ../../library/string.rst:437
msgid "_ (underscore)"
msgstr "_ (подчеркивание)"

#: ../../library/string.rst:792
msgid "$ (dollar)"
msgstr "$ (доллар)"

#: ../../library/string.rst:792
msgid "in template strings"
msgstr "в строках шаблона"
