# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# Roustam Khamidoulline, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-17 14:51+0000\n"
"PO-Revision-Date: 2024-05-11 00:33+0000\n"
"Last-Translator: Roustam Khamidoulline, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/faulthandler.rst:2
msgid ":mod:`!faulthandler` --- Dump the Python traceback"
msgstr ":mod:`!faulthandler` --- Дамп обратной трассировки Python"

#: ../../library/faulthandler.rst:11
msgid ""
"This module contains functions to dump Python tracebacks explicitly, on a "
"fault, after a timeout, or on a user signal. Call :func:`faulthandler."
"enable` to install fault handlers for the :const:`~signal.SIGSEGV`, :const:"
"`~signal.SIGFPE`, :const:`~signal.SIGABRT`, :const:`~signal.SIGBUS`, and :"
"const:`~signal.SIGILL` signals. You can also enable them at startup by "
"setting the :envvar:`PYTHONFAULTHANDLER` environment variable or by using "
"the :option:`-X` ``faulthandler`` command line option."
msgstr ""
"Этот модуль содержит функции для явного сброса обратных трассировок Python, "
"при ошибке, после тайм-аута или по сигналу пользователя. Вызовите :func:"
"`faulthandler.enable`, чтобы установить обработчики ошибок для :const:"
"`~signal.SIGSEGV`, :const:`~signal.SIGFPE`, :const:`~signal.SIGABRT`, :const:"
"`~ signal.SIGBUS` и сигналы :const:`~signal.SIGILL`. Вы также можете "
"включить их при запуске, установив переменную среды :envvar:"
"`PYTHONFAULTHANDLER` или используя параметр командной строки :option:`-X` "
"``faulthandler``."

#: ../../library/faulthandler.rst:19
msgid ""
"The fault handler is compatible with system fault handlers like Apport or "
"the Windows fault handler. The module uses an alternative stack for signal "
"handlers if the :c:func:`!sigaltstack` function is available. This allows it "
"to dump the traceback even on a stack overflow."
msgstr ""
"Обработчик ошибок совместим с обработчиками системных ошибок, такими как "
"Apport или обработчик ошибок Windows. Модуль использует альтернативный стек "
"для обработчиков сигналов, если доступна функция :c:func:`!sigaltstack`. Это "
"позволяет ему сбрасывать обратную трассировку даже при переполнении стека."

#: ../../library/faulthandler.rst:24
msgid ""
"The fault handler is called on catastrophic cases and therefore can only use "
"signal-safe functions (e.g. it cannot allocate memory on the heap). Because "
"of this limitation traceback dumping is minimal compared to normal Python "
"tracebacks:"
msgstr ""
"Обработчик ошибок вызывается в катастрофических случаях и поэтому может "
"использовать только функции, безопасные для сигналов (например, он не может "
"выделять память в куче). Из-за этого ограничения дамп обратной трассировки "
"минимален по сравнению с обычными обратными трассировками Python:"

#: ../../library/faulthandler.rst:29
msgid ""
"Only ASCII is supported. The ``backslashreplace`` error handler is used on "
"encoding."
msgstr ""
"Поддерживается только ASCII. При кодировании используется обработчик ошибок "
"backslashreplace."

#: ../../library/faulthandler.rst:31
msgid "Each string is limited to 500 characters."
msgstr "Каждая строка ограничена 500 символами."

#: ../../library/faulthandler.rst:32
msgid ""
"Only the filename, the function name and the line number are displayed. (no "
"source code)"
msgstr ""
"Отображаются только имя файла, имя функции и номер строки. (без исходного "
"кода)"

#: ../../library/faulthandler.rst:34
msgid "It is limited to 100 frames and 100 threads."
msgstr "Он ограничен 100 кадрами и 100 потоками."

#: ../../library/faulthandler.rst:35
msgid "The order is reversed: the most recent call is shown first."
msgstr "Порядок обратный: первым отображается самый последний вызов."

#: ../../library/faulthandler.rst:37
msgid ""
"By default, the Python traceback is written to :data:`sys.stderr`. To see "
"tracebacks, applications must be run in the terminal. A log file can "
"alternatively be passed to :func:`faulthandler.enable`."
msgstr ""
"По умолчанию обратная трассировка Python записывается в :data:`sys.stderr`. "
"Чтобы увидеть обратные трассировки, приложения должны быть запущены в "
"терминале. Альтернативно файл журнала можно передать в :func:`faulthandler."
"enable`."

#: ../../library/faulthandler.rst:41
msgid ""
"The module is implemented in C, so tracebacks can be dumped on a crash or "
"when Python is deadlocked."
msgstr ""
"Модуль реализован на C, поэтому обратные трассировки могут быть сброшены при "
"сбое или когда Python зашел в тупик."

#: ../../library/faulthandler.rst:44
msgid ""
"The :ref:`Python Development Mode <devmode>` calls :func:`faulthandler."
"enable` at Python startup."
msgstr ""
":ref:`Режим разработки Python <devmode>` вызывает :func:`faulthandler."
"enable` при запуске Python."

#: ../../library/faulthandler.rst:49
msgid "Module :mod:`pdb`"
msgstr "Модуль :mod:`pdb`"

#: ../../library/faulthandler.rst:50
msgid "Interactive source code debugger for Python programs."
msgstr "Интерактивный отладчик исходного кода программ Python."

#: ../../library/faulthandler.rst:52
msgid "Module :mod:`traceback`"
msgstr "Модуль :mod:`traceback`"

#: ../../library/faulthandler.rst:53
msgid ""
"Standard interface to extract, format and print stack traces of Python "
"programs."
msgstr ""
"Стандартный интерфейс для извлечения, форматирования и печати трассировок "
"стека программ Python."

#: ../../library/faulthandler.rst:56
msgid "Dumping the traceback"
msgstr "Сброс обратной связи"

#: ../../library/faulthandler.rst:60
msgid ""
"Dump the tracebacks of all threads into *file*. If *all_threads* is "
"``False``, dump only the current thread."
msgstr ""
"Сохраните обратные трассировки всех потоков в *файл*. Если *all_threads* "
"имеет значение «False», выгрузить только текущий поток."

#: ../../library/faulthandler.rst:63
msgid ""
":func:`traceback.print_tb`, which can be used to print a traceback object."
msgstr ""
":func:`traceback.print_tb`, который можно использовать для печати объекта "
"трассировки."

#: ../../library/faulthandler.rst:65 ../../library/faulthandler.rst:84
#: ../../library/faulthandler.rst:123 ../../library/faulthandler.rst:148
msgid "Added support for passing file descriptor to this function."
msgstr "Добавлена ​​поддержка передачи дескриптора файла в эту функцию."

#: ../../library/faulthandler.rst:70
msgid "Fault handler state"
msgstr "Состояние обработчика неисправностей"

#: ../../library/faulthandler.rst:74
msgid ""
"Enable the fault handler: install handlers for the :const:`~signal."
"SIGSEGV`, :const:`~signal.SIGFPE`, :const:`~signal.SIGABRT`, :const:`~signal."
"SIGBUS` and :const:`~signal.SIGILL` signals to dump the Python traceback. If "
"*all_threads* is ``True``, produce tracebacks for every running thread. "
"Otherwise, dump only the current thread."
msgstr ""
"Включите обработчик ошибок: установите обработчики для :const:`~signal."
"SIGSEGV`, :const:`~signal.SIGFPE`, :const:`~signal.SIGABRT`, :const:`~signal."
"SIGBUS` и : const:`~signal.SIGILL` сигнализирует о сбросе трассировки "
"Python. Если *all_threads* имеет значение True, создается обратная "
"трассировка для каждого работающего потока. В противном случае выгрузите "
"только текущий поток."

#: ../../library/faulthandler.rst:81
msgid ""
"The *file* must be kept open until the fault handler is disabled: see :ref:"
"`issue with file descriptors <faulthandler-fd>`."
msgstr ""
"*Файл* должен оставаться открытым до тех пор, пока обработчик ошибок не "
"будет отключен: см. :ref:`проблема с файловыми дескрипторами <faulthandler-"
"fd>`."

#: ../../library/faulthandler.rst:87
msgid "On Windows, a handler for Windows exception is also installed."
msgstr "В Windows также установлен обработчик исключений Windows."

#: ../../library/faulthandler.rst:90
msgid ""
"The dump now mentions if a garbage collector collection is running if "
"*all_threads* is true."
msgstr ""
"В дампе теперь указывается, запущен ли сборщик мусора, если *all_threads* "
"имеет значение true."

#: ../../library/faulthandler.rst:96
msgid ""
"Disable the fault handler: uninstall the signal handlers installed by :func:"
"`enable`."
msgstr ""
"Отключите обработчик ошибок: удалите обработчики сигналов, установленные :"
"func:`enable`."

#: ../../library/faulthandler.rst:101
msgid "Check if the fault handler is enabled."
msgstr "Проверьте, включен ли обработчик ошибок."

#: ../../library/faulthandler.rst:105
msgid "Dumping the tracebacks after a timeout"
msgstr "Сброс обратных трассировок после таймаута"

#: ../../library/faulthandler.rst:109
msgid ""
"Dump the tracebacks of all threads, after a timeout of *timeout* seconds, or "
"every *timeout* seconds if *repeat* is ``True``.  If *exit* is ``True``, "
"call :c:func:`!_exit` with status=1 after dumping the tracebacks.  (Note :c:"
"func:`!_exit` exits the process immediately, which means it doesn't do any "
"cleanup like flushing file buffers.) If the function is called twice, the "
"new call replaces previous parameters and resets the timeout. The timer has "
"a sub-second resolution."
msgstr ""
"Дамп обратных трассировок всех потоков после тайм-аута *timeout* секунд или "
"каждые *timeout* секунд, если *repeat* имеет значение ``True``. Если *exit* "
"имеет значение ``True``, вызовите :c:func:`!_exit` со статусом=1 после "
"сброса обратных трассировок. (Примечание: :c:func:`!_exit` немедленно "
"завершает процесс, что означает, что он не выполняет никакой очистки, такой "
"как очистка файловых буферов.) Если функция вызывается дважды, новый вызов "
"заменяет предыдущие параметры и сбрасывает время ожидания. Таймер имеет "
"разрешение менее секунды."

#: ../../library/faulthandler.rst:117
msgid ""
"The *file* must be kept open until the traceback is dumped or :func:"
"`cancel_dump_traceback_later` is called: see :ref:`issue with file "
"descriptors <faulthandler-fd>`."
msgstr ""
"*Файл* должен оставаться открытым до тех пор, пока не будет выполнен дамп "
"трассировки или не будет вызвана :func:`cancel_dump_traceback_later`: см. :"
"ref:`проблема с файловыми дескрипторами <faulthandler-fd>`."

#: ../../library/faulthandler.rst:121
msgid "This function is implemented using a watchdog thread."
msgstr "Эта функция реализована с использованием сторожевого потока."

#: ../../library/faulthandler.rst:126
msgid "This function is now always available."
msgstr "Эта функция теперь доступна всегда."

#: ../../library/faulthandler.rst:131
msgid "Cancel the last call to :func:`dump_traceback_later`."
msgstr "Отмените последний вызов :func:`dump_traceback_later`."

#: ../../library/faulthandler.rst:135
msgid "Dumping the traceback on a user signal"
msgstr "Сброс трассировки пользовательского сигнала"

#: ../../library/faulthandler.rst:139
msgid ""
"Register a user signal: install a handler for the *signum* signal to dump "
"the traceback of all threads, or of the current thread if *all_threads* is "
"``False``, into *file*. Call the previous handler if chain is ``True``."
msgstr ""
"Зарегистрируйте пользовательский сигнал: установите обработчик для сигнала "
"*signum*, чтобы сбрасывать обратную трассировку всех потоков или текущего "
"потока, если *all_threads* имеет значение ``False``, в *file*. Вызовите "
"предыдущий обработчик, если цепочка имеет значение «True»."

#: ../../library/faulthandler.rst:143
msgid ""
"The *file* must be kept open until the signal is unregistered by :func:"
"`unregister`: see :ref:`issue with file descriptors <faulthandler-fd>`."
msgstr ""
"*Файл* должен оставаться открытым до тех пор, пока сигнал не будет отменен с "
"помощью :func:`unregister`: см. :ref:`проблема с файловыми дескрипторами "
"<faulthandler-fd>`."

#: ../../library/faulthandler.rst:146 ../../library/faulthandler.rst:157
msgid "Not available on Windows."
msgstr "Недоступно в Windows."

#: ../../library/faulthandler.rst:153
msgid ""
"Unregister a user signal: uninstall the handler of the *signum* signal "
"installed by :func:`register`. Return ``True`` if the signal was registered, "
"``False`` otherwise."
msgstr ""
"Отмените регистрацию пользовательского сигнала: удалите обработчик сигнала "
"*signum*, установленный :func:`register`. Верните True, если сигнал был "
"зарегистрирован, и False в противном случае."

#: ../../library/faulthandler.rst:163
msgid "Issue with file descriptors"
msgstr "Проблема с файловыми дескрипторами"

#: ../../library/faulthandler.rst:165
msgid ""
":func:`enable`, :func:`dump_traceback_later` and :func:`register` keep the "
"file descriptor of their *file* argument. If the file is closed and its file "
"descriptor is reused by a new file, or if :func:`os.dup2` is used to replace "
"the file descriptor, the traceback will be written into a different file. "
"Call these functions again each time that the file is replaced."
msgstr ""
":func:`enable`, :func:`dump_traceback_later` и :func:`register` сохраняют "
"файловый дескриптор своего аргумента *file*. Если файл закрыт и его файловый "
"дескриптор повторно используется новым файлом или если для замены файлового "
"дескриптора используется :func:`os.dup2`, обратная трассировка будет "
"записана в другой файл. Вызовите эти функции снова каждый раз при замене "
"файла."

#: ../../library/faulthandler.rst:173
msgid "Example"
msgstr "Пример"

#: ../../library/faulthandler.rst:175
msgid ""
"Example of a segmentation fault on Linux with and without enabling the fault "
"handler:"
msgstr ""
"Пример ошибки сегментации в Linux с включением обработчика ошибок и без него:"

#: ../../library/faulthandler.rst:178
msgid ""
"$ python -c \"import ctypes; ctypes.string_at(0)\"\n"
"Segmentation fault\n"
"\n"
"$ python -q -X faulthandler\n"
">>> import ctypes\n"
">>> ctypes.string_at(0)\n"
"Fatal Python error: Segmentation fault\n"
"\n"
"Current thread 0x00007fb899f39700 (most recent call first):\n"
"  File \"/home/python/cpython/Lib/ctypes/__init__.py\", line 486 in "
"string_at\n"
"  File \"<stdin>\", line 1 in <module>\n"
"Segmentation fault"
msgstr ""
"$ python -c \"import ctypes; ctypes.string_at(0)\"\n"
"Segmentation fault\n"
"\n"
"$ python -q -X faulthandler\n"
">>> import ctypes\n"
">>> ctypes.string_at(0)\n"
"Fatal Python error: Segmentation fault\n"
"\n"
"Current thread 0x00007fb899f39700 (most recent call first):\n"
"  File \"/home/python/cpython/Lib/ctypes/__init__.py\", line 486 in "
"string_at\n"
"  File \"<stdin>\", line 1 in <module>\n"
"Segmentation fault"
