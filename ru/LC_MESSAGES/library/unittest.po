# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-02-28 14:56+0000\n"
"PO-Revision-Date: 2024-05-11 00:34+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/unittest.rst:2
msgid ":mod:`!unittest` --- Unit testing framework"
msgstr ":mod:`!unittest` --- Платформа модульного тестирования"

#: ../../library/unittest.rst:12
msgid "**Source code:** :source:`Lib/unittest/__init__.py`"
msgstr "**Исходный код:** :source:`Lib/unittest/__init__.py`"

#: ../../library/unittest.rst:16
msgid ""
"(If you are already familiar with the basic concepts of testing, you might "
"want to skip to :ref:`the list of assert methods <assert-methods>`.)"
msgstr ""
"(Если вы уже знакомы с основными концепциями тестирования, возможно, вам "
"захочется перейти к :ref:`списку методов утверждения <assert-methods>`.)"

#: ../../library/unittest.rst:19
msgid ""
"The :mod:`unittest` unit testing framework was originally inspired by JUnit "
"and has a similar flavor as major unit testing frameworks in other "
"languages.  It supports test automation, sharing of setup and shutdown code "
"for tests, aggregation of tests into collections, and independence of the "
"tests from the reporting framework."
msgstr ""
"Среда модульного тестирования :mod:`unittest` изначально была вдохновлена ​​"
"JUnit и имеет сходство с основными средами модульного тестирования на других "
"языках. Он поддерживает автоматизацию тестирования, совместное использование "
"кода настройки и завершения тестов, объединение тестов в коллекции и "
"независимость тестов от системы отчетности."

#: ../../library/unittest.rst:25
msgid ""
"To achieve this, :mod:`unittest` supports some important concepts in an "
"object-oriented way:"
msgstr ""
"Чтобы добиться этого, :mod:`unittest` поддерживает некоторые важные "
"концепции объектно-ориентированным способом:"

#: ../../library/unittest.rst:28
msgid "test fixture"
msgstr "испытательное приспособление"

#: ../../library/unittest.rst:29
msgid ""
"A :dfn:`test fixture` represents the preparation needed to perform one or "
"more tests, and any associated cleanup actions.  This may involve, for "
"example, creating temporary or proxy databases, directories, or starting a "
"server process."
msgstr ""
":dfn:`test приспособление` представляет собой подготовку, необходимую для "
"выполнения одного или нескольких тестов, а также любых связанных с ними "
"действий по очистке. Это может включать, например, создание временных или "
"прокси-баз данных, каталогов или запуск серверного процесса."

#: ../../library/unittest.rst:34
msgid "test case"
msgstr "тестовый пример"

#: ../../library/unittest.rst:35
msgid ""
"A :dfn:`test case` is the individual unit of testing.  It checks for a "
"specific response to a particular set of inputs.  :mod:`unittest` provides a "
"base class, :class:`TestCase`, which may be used to create new test cases."
msgstr ""
":dfn:`Тестовый пример` — это отдельная единица тестирования. Он проверяет "
"конкретный ответ на определенный набор входных данных. :mod:`unittest` "
"предоставляет базовый класс :class:`TestCase`, который можно использовать "
"для создания новых тестовых случаев."

#: ../../library/unittest.rst:39
msgid "test suite"
msgstr "тестовый набор"

#: ../../library/unittest.rst:40
msgid ""
"A :dfn:`test suite` is a collection of test cases, test suites, or both.  It "
"is used to aggregate tests that should be executed together."
msgstr ""
":dfn:`test suite` — это набор тестовых примеров, наборов тестов или того и "
"другого. Он используется для объединения тестов, которые должны выполняться "
"вместе."

#: ../../library/unittest.rst:43
msgid "test runner"
msgstr "test runner"

#: ../../library/unittest.rst:44
msgid ""
"A :dfn:`test runner` is a component which orchestrates the execution of "
"tests and provides the outcome to the user.  The runner may use a graphical "
"interface, a textual interface, or return a special value to indicate the "
"results of executing the tests."
msgstr ""
":dfn:`test runner` — это компонент, который организует выполнение тестов и "
"предоставляет результаты пользователю. Бегун может использовать графический "
"интерфейс, текстовый интерфейс или возвращать специальное значение для "
"обозначения результатов выполнения тестов."

#: ../../library/unittest.rst:52
msgid "Module :mod:`doctest`"
msgstr "Модуль :mod:`doctest`"

#: ../../library/unittest.rst:53
msgid "Another test-support module with a very different flavor."
msgstr "Еще один модуль поддержки тестирования с совершенно другим вкусом."

#: ../../library/unittest.rst:55
msgid ""
"`Simple Smalltalk Testing: With Patterns <https://web.archive.org/"
"web/20150315073817/http://www.xprogramming.com/testfram.htm>`_"
msgstr ""
"`Простое тестирование Smalltalk: с шаблонами <https://web.archive.org/"
"web/20150315073817/http://www.xprogramming.com/testfram.htm>`_"

#: ../../library/unittest.rst:56
msgid ""
"Kent Beck's original paper on testing frameworks using the pattern shared "
"by :mod:`unittest`."
msgstr ""
"Оригинальная статья Кента Бека о тестировании фреймворков с использованием "
"шаблона, предоставленного :mod:`unittest`."

#: ../../library/unittest.rst:59
msgid "`pytest <https://docs.pytest.org/>`_"
msgstr "`pytest <https://docs.pytest.org/>`_"

#: ../../library/unittest.rst:60
msgid ""
"Third-party unittest framework with a lighter-weight syntax for writing "
"tests.  For example, ``assert func(10) == 42``."
msgstr ""
"Сторонняя среда модульного тестирования с облегченным синтаксисом для "
"написания тестов. Например, ``assert func(10) == 42``."

#: ../../library/unittest.rst:63
msgid ""
"`The Python Testing Tools Taxonomy <https://wiki.python.org/moin/"
"PythonTestingToolsTaxonomy>`_"
msgstr ""
"`Таксономия инструментов тестирования Python <https://wiki.python.org/moin/"
"PythonTestingToolsTaxonomy>`_"

#: ../../library/unittest.rst:64
msgid ""
"An extensive list of Python testing tools including functional testing "
"frameworks and mock object libraries."
msgstr ""
"Обширный список инструментов тестирования Python, включая платформы "
"функционального тестирования и библиотеки макетов объектов."

#: ../../library/unittest.rst:67
msgid ""
"`Testing in Python Mailing List <http://lists.idyll.org/listinfo/testing-in-"
"python>`_"
msgstr ""
"`Тестирование в списке рассылки Python <http://lists.idyll.org/listinfo/"
"testing-in-python>`_"

#: ../../library/unittest.rst:68
msgid ""
"A special-interest-group for discussion of testing, and testing tools, in "
"Python."
msgstr ""
"Группа по особым интересам для обсуждения тестирования и инструментов "
"тестирования на Python."

#: ../../library/unittest.rst:71
msgid ""
"The script :file:`Tools/unittestgui/unittestgui.py` in the Python source "
"distribution is a GUI tool for test discovery and execution.  This is "
"intended largely for ease of use for those new to unit testing.  For "
"production environments it is recommended that tests be driven by a "
"continuous integration system such as `Buildbot <https://buildbot.net/>`_, "
"`Jenkins <https://www.jenkins.io/>`_, `GitHub Actions <https://github.com/"
"features/actions>`_, or `AppVeyor <https://www.appveyor.com/>`_."
msgstr ""
"Сценарий :file:`Tools/unittestgui/unittestgui.py` в дистрибутиве исходного "
"кода Python представляет собой инструмент с графическим интерфейсом для "
"обнаружения и выполнения тестов. Это предназначено в основном для простоты "
"использования для новичков в модульном тестировании. Для производственных "
"сред рекомендуется, чтобы тесты проводились с помощью системы непрерывной "
"интеграции, такой как `Buildbot <https://buildbot.net/>`_, `Jenkins <https://"
"www.jenkins.io/>`_, ` Действия GitHub <https://github.com/features/"
"actions>`_ или `AppVeyor <https://www.appveyor.com/>`_."

#: ../../library/unittest.rst:83
msgid "Basic example"
msgstr "Основной пример"

#: ../../library/unittest.rst:85
msgid ""
"The :mod:`unittest` module provides a rich set of tools for constructing and "
"running tests.  This section demonstrates that a small subset of the tools "
"suffice to meet the needs of most users."
msgstr ""
"Модуль :mod:`unittest` предоставляет богатый набор инструментов для создания "
"и запуска тестов. В этом разделе показано, что небольшого набора "
"инструментов достаточно для удовлетворения потребностей большинства "
"пользователей."

#: ../../library/unittest.rst:89
msgid "Here is a short script to test three string methods::"
msgstr "Вот короткий скрипт для проверки трех строковых методов:"

#: ../../library/unittest.rst:91
msgid ""
"import unittest\n"
"\n"
"class TestStringMethods(unittest.TestCase):\n"
"\n"
"    def test_upper(self):\n"
"        self.assertEqual('foo'.upper(), 'FOO')\n"
"\n"
"    def test_isupper(self):\n"
"        self.assertTrue('FOO'.isupper())\n"
"        self.assertFalse('Foo'.isupper())\n"
"\n"
"    def test_split(self):\n"
"        s = 'hello world'\n"
"        self.assertEqual(s.split(), ['hello', 'world'])\n"
"        # check that s.split fails when the separator is not a string\n"
"        with self.assertRaises(TypeError):\n"
"            s.split(2)\n"
"\n"
"if __name__ == '__main__':\n"
"    unittest.main()"
msgstr ""
"import unittest\n"
"\n"
"class TestStringMethods(unittest.TestCase):\n"
"\n"
"    def test_upper(self):\n"
"        self.assertEqual('foo'.upper(), 'FOO')\n"
"\n"
"    def test_isupper(self):\n"
"        self.assertTrue('FOO'.isupper())\n"
"        self.assertFalse('Foo'.isupper())\n"
"\n"
"    def test_split(self):\n"
"        s = 'hello world'\n"
"        self.assertEqual(s.split(), ['hello', 'world'])\n"
"        # check that s.split fails when the separator is not a string\n"
"        with self.assertRaises(TypeError):\n"
"            s.split(2)\n"
"\n"
"if __name__ == '__main__':\n"
"    unittest.main()"

#: ../../library/unittest.rst:113
msgid ""
"A testcase is created by subclassing :class:`unittest.TestCase`.  The three "
"individual tests are defined with methods whose names start with the letters "
"``test``.  This naming convention informs the test runner about which "
"methods represent tests."
msgstr ""
"Тестовый пример создается путем создания подкласса :class:`unittest."
"TestCase`. Три отдельных теста определяются методами, имена которых "
"начинаются с букв «test». Это соглашение об именах информирует исполнителя "
"тестов о том, какие методы представляют тесты."

#: ../../library/unittest.rst:118
msgid ""
"The crux of each test is a call to :meth:`~TestCase.assertEqual` to check "
"for an expected result; :meth:`~TestCase.assertTrue` or :meth:`~TestCase."
"assertFalse` to verify a condition; or :meth:`~TestCase.assertRaises` to "
"verify that a specific exception gets raised.  These methods are used "
"instead of the :keyword:`assert` statement so the test runner can accumulate "
"all test results and produce a report."
msgstr ""
"Суть каждого теста — это вызов :meth:`~TestCase.assertEqual` для проверки "
"ожидаемого результата; :meth:`~TestCase.assertTrue` или :meth:`~TestCase."
"assertFalse` для проверки условия; или :meth:`~TestCase.assertRaises`, чтобы "
"убедиться, что возникло конкретное исключение. Эти методы используются "
"вместо оператора :keyword:`assert`, поэтому программа, запускающая тесты, "
"может аккумулировать все результаты тестирования и создать отчет."

#: ../../library/unittest.rst:125
msgid ""
"The :meth:`~TestCase.setUp` and :meth:`~TestCase.tearDown` methods allow you "
"to define instructions that will be executed before and after each test "
"method. They are covered in more detail in the section :ref:`organizing-"
"tests`."
msgstr ""
"Методы :meth:`~TestCase.setUp` и :meth:`~TestCase.tearDown` позволяют вам "
"определять инструкции, которые будут выполняться до и после каждого метода "
"тестирования. Более подробно они описаны в разделе :ref:`organizing-tests`."

#: ../../library/unittest.rst:129
msgid ""
"The final block shows a simple way to run the tests. :func:`unittest.main` "
"provides a command-line interface to the test script.  When run from the "
"command line, the above script produces an output that looks like this::"
msgstr ""
"Последний блок показывает простой способ запуска тестов. :func:`unittest."
"main` предоставляет интерфейс командной строки для тестового сценария. При "
"запуске из командной строки приведенный выше сценарий выдает следующий "
"результат:"

#: ../../library/unittest.rst:133
msgid ""
"...\n"
"----------------------------------------------------------------------\n"
"Ran 3 tests in 0.000s\n"
"\n"
"OK"
msgstr ""
"...\n"
"----------------------------------------------------------------------\n"
"Ran 3 tests in 0.000s\n"
"\n"
"OK"

#: ../../library/unittest.rst:139
msgid ""
"Passing the ``-v`` option to your test script will instruct :func:`unittest."
"main` to enable a higher level of verbosity, and produce the following "
"output::"
msgstr ""
"Передача опции ``-v`` в ваш тестовый скрипт даст указание :func:`unittest."
"main` включить более высокий уровень детализации и выдать следующий "
"результат:"

#: ../../library/unittest.rst:142
msgid ""
"test_isupper (__main__.TestStringMethods.test_isupper) ... ok\n"
"test_split (__main__.TestStringMethods.test_split) ... ok\n"
"test_upper (__main__.TestStringMethods.test_upper) ... ok\n"
"\n"
"----------------------------------------------------------------------\n"
"Ran 3 tests in 0.001s\n"
"\n"
"OK"
msgstr ""
"test_isupper (__main__.TestStringMethods.test_isupper) ... ok\n"
"test_split (__main__.TestStringMethods.test_split) ... ok\n"
"test_upper (__main__.TestStringMethods.test_upper) ... ok\n"
"\n"
"----------------------------------------------------------------------\n"
"Ran 3 tests in 0.001s\n"
"\n"
"OK"

#: ../../library/unittest.rst:151
msgid ""
"The above examples show the most commonly used :mod:`unittest` features "
"which are sufficient to meet many everyday testing needs.  The remainder of "
"the documentation explores the full feature set from first principles."
msgstr ""
"В приведенных выше примерах показаны наиболее часто используемые функции :"
"mod:`unittest`, которых достаточно для удовлетворения многих повседневных "
"потребностей тестирования. Остальная часть документации исследует полный "
"набор функций с первых принципов."

#: ../../library/unittest.rst:155
msgid ""
"The behavior of returning a value from a test method (other than the default "
"``None`` value), is now deprecated."
msgstr ""
"Поведение возврата значения из тестового метода (кроме значения по умолчанию "
"None) теперь считается устаревшим."

#: ../../library/unittest.rst:163
msgid "Command-Line Interface"
msgstr "Интерфейс командной строки"

#: ../../library/unittest.rst:165
msgid ""
"The unittest module can be used from the command line to run tests from "
"modules, classes or even individual test methods::"
msgstr ""
"Модуль unittest можно использовать из командной строки для запуска тестов из "
"модулей, классов или даже отдельных методов тестирования:"

#: ../../library/unittest.rst:168
msgid ""
"python -m unittest test_module1 test_module2\n"
"python -m unittest test_module.TestClass\n"
"python -m unittest test_module.TestClass.test_method"
msgstr ""
"python -m unittest test_module1 test_module2\n"
"python -m unittest test_module.TestClass\n"
"python -m unittest test_module.TestClass.test_method"

#: ../../library/unittest.rst:172
msgid ""
"You can pass in a list with any combination of module names, and fully "
"qualified class or method names."
msgstr ""
"Вы можете передать список с любой комбинацией имен модулей и полными именами "
"классов или методов."

#: ../../library/unittest.rst:175
msgid "Test modules can be specified by file path as well::"
msgstr "Тестовые модули также могут быть указаны по пути к файлу::"

#: ../../library/unittest.rst:177
msgid "python -m unittest tests/test_something.py"
msgstr "python -m unittest tests/test_something.py"

#: ../../library/unittest.rst:179
msgid ""
"This allows you to use the shell filename completion to specify the test "
"module. The file specified must still be importable as a module. The path is "
"converted to a module name by removing the '.py' and converting path "
"separators into '.'. If you want to execute a test file that isn't "
"importable as a module you should execute the file directly instead."
msgstr ""
"Это позволяет вам использовать завершение имени файла оболочки для указания "
"тестового модуля. Указанный файл по-прежнему должен быть доступен для "
"импорта как модуль. Путь преобразуется в имя модуля путем удаления «.py» и "
"преобразования разделителей пути в «.». Если вы хотите выполнить тестовый "
"файл, который нельзя импортировать как модуль, вместо этого вам следует "
"выполнить файл напрямую."

#: ../../library/unittest.rst:185
msgid ""
"You can run tests with more detail (higher verbosity) by passing in the -v "
"flag::"
msgstr ""
"Вы можете запускать тесты с большей детализацией (более подробной "
"информацией), передав флаг -v::"

#: ../../library/unittest.rst:187
msgid "python -m unittest -v test_module"
msgstr "python -m unittest -v test_module"

#: ../../library/unittest.rst:189
msgid ""
"When executed without arguments :ref:`unittest-test-discovery` is started::"
msgstr ""
"При выполнении без аргументов запускается :ref:`unittest-test-discovery`::"

#: ../../library/unittest.rst:191
msgid "python -m unittest"
msgstr "python -m unittest"

#: ../../library/unittest.rst:193
msgid "For a list of all the command-line options::"
msgstr "Список всех параметров командной строки:"

#: ../../library/unittest.rst:195
msgid "python -m unittest -h"
msgstr "python -m unittest -h"

#: ../../library/unittest.rst:197
msgid ""
"In earlier versions it was only possible to run individual test methods and "
"not modules or classes."
msgstr ""
"В более ранних версиях можно было запускать только отдельные методы "
"тестирования, а не модули или классы."

#: ../../library/unittest.rst:203
msgid "Command-line options"
msgstr "Параметры командной строки"

#: ../../library/unittest.rst:205
msgid ":program:`unittest` supports these command-line options:"
msgstr ":program:`unittest` поддерживает следующие параметры командной строки:"

#: ../../library/unittest.rst:211
msgid ""
"The standard output and standard error streams are buffered during the test "
"run. Output during a passing test is discarded. Output is echoed normally on "
"test fail or error and is added to the failure messages."
msgstr ""
"Потоки стандартного вывода и стандартных ошибок буферизуются во время "
"выполнения теста. Вывод во время прохождения теста отбрасывается. Выходные "
"данные обычно отображаются в случае сбоя или ошибки теста и добавляются к "
"сообщениям об ошибках."

#: ../../library/unittest.rst:217
msgid ""
":kbd:`Control-C` during the test run waits for the current test to end and "
"then reports all the results so far. A second :kbd:`Control-C` raises the "
"normal :exc:`KeyboardInterrupt` exception."
msgstr ""
":kbd:`Control-C` во время выполнения теста ожидает завершения текущего "
"теста, а затем сообщает обо всех результатах на данный момент. Второе "
"нажатие :kbd:`Control-C` вызывает обычное исключение :exc:"
"`KeyboardInterrupt`."

#: ../../library/unittest.rst:221
msgid ""
"See `Signal Handling`_ for the functions that provide this functionality."
msgstr ""
"См. «Обработка сигналов» для функций, обеспечивающих эту функциональность."

#: ../../library/unittest.rst:225
msgid "Stop the test run on the first error or failure."
msgstr "Остановите тестовый прогон при первой ошибке или сбое."

#: ../../library/unittest.rst:229
msgid ""
"Only run test methods and classes that match the pattern or substring. This "
"option may be used multiple times, in which case all test cases that match "
"any of the given patterns are included."
msgstr ""
"Запускайте только тестовые методы и классы, соответствующие шаблону или "
"подстроке. Эту опцию можно использовать несколько раз, и в этом случае будут "
"включены все тестовые примеры, соответствующие любому из заданных шаблонов."

#: ../../library/unittest.rst:233
msgid ""
"Patterns that contain a wildcard character (``*``) are matched against the "
"test name using :meth:`fnmatch.fnmatchcase`; otherwise simple case-sensitive "
"substring matching is used."
msgstr ""
"Шаблоны, содержащие подстановочный знак (``*``), сопоставляются с именем "
"теста с помощью :meth:`fnmatch.fnmatchcase`; в противном случае используется "
"простое сопоставление подстрок с учетом регистра."

#: ../../library/unittest.rst:237
msgid ""
"Patterns are matched against the fully qualified test method name as "
"imported by the test loader."
msgstr ""
"Шаблоны сопоставляются с полным именем метода тестирования, импортированным "
"загрузчиком тестов."

#: ../../library/unittest.rst:240
msgid ""
"For example, ``-k foo`` matches ``foo_tests.SomeTest.test_something``, "
"``bar_tests.SomeTest.test_foo``, but not ``bar_tests.FooTest."
"test_something``."
msgstr ""
"Например, ``-k foo`` соответствует ``foo_tests.SomeTest.test_something``, "
"``bar_tests.SomeTest.test_foo``, но не ``bar_tests.FooTest.test_something``."

#: ../../library/unittest.rst:245
msgid "Show local variables in tracebacks."
msgstr "Показывать локальные переменные в обратных трассировках."

#: ../../library/unittest.rst:249
msgid "Show the N slowest test cases (N=0 for all)."
msgstr "Показать N самых медленных тестовых случаев (N=0 для всех)."

#: ../../library/unittest.rst:251
msgid "The command-line options ``-b``, ``-c`` and ``-f`` were added."
msgstr "Были добавлены параметры командной строки ``-b``, ``-c`` и ``-f``."

#: ../../library/unittest.rst:254
msgid "The command-line option ``--locals``."
msgstr "Опция командной строки ``--locals``."

#: ../../library/unittest.rst:257
msgid "The command-line option ``-k``."
msgstr "Опция командной строки ``-k``."

#: ../../library/unittest.rst:260
msgid "The command-line option ``--durations``."
msgstr "Опция командной строки ``--durations``."

#: ../../library/unittest.rst:263
msgid ""
"The command line can also be used for test discovery, for running all of the "
"tests in a project or just a subset."
msgstr ""
"Командную строку также можно использовать для обнаружения тестов, для "
"запуска всех тестов в проекте или только их подмножества."

#: ../../library/unittest.rst:269
msgid "Test Discovery"
msgstr "Открытие тестов"

#: ../../library/unittest.rst:273
msgid ""
"Unittest supports simple test discovery. In order to be compatible with test "
"discovery, all of the test files must be :ref:`modules <tut-modules>` or :"
"ref:`packages <tut-packages>` importable from the top-level directory of the "
"project (this means that their filenames must be valid :ref:`identifiers "
"<identifiers>`)."
msgstr ""
"Unittest поддерживает простое обнаружение тестов. Чтобы быть совместимыми с "
"обнаружением тестов, все тестовые файлы должны быть :ref:`modules <tut-"
"modules>` или :ref:`packages <tut-packages>`, которые можно импортировать из "
"каталога верхнего уровня проекта ( это означает, что имена их файлов должны "
"быть действительными :ref:`identifiers <identifiers>`)."

#: ../../library/unittest.rst:279
msgid ""
"Test discovery is implemented in :meth:`TestLoader.discover`, but can also "
"be used from the command line. The basic command-line usage is::"
msgstr ""
"Обнаружение тестов реализовано в :meth:`TestLoader.discover`, но его также "
"можно использовать из командной строки. Основное использование командной "
"строки:"

#: ../../library/unittest.rst:282
msgid ""
"cd project_directory\n"
"python -m unittest discover"
msgstr ""
"cd project_directory\n"
"python -m unittest discover"

#: ../../library/unittest.rst:287
msgid ""
"As a shortcut, ``python -m unittest`` is the equivalent of ``python -m "
"unittest discover``. If you want to pass arguments to test discovery the "
"``discover`` sub-command must be used explicitly."
msgstr ""
"В качестве сокращения ``python -m unittest`` эквивалентен ``python -m "
"unittest Discover``. Если вы хотите передать аргументы для проверки "
"обнаружения, подкоманду Discover необходимо использовать явно."

#: ../../library/unittest.rst:291
msgid "The ``discover`` sub-command has the following options:"
msgstr "Подкоманда ``discover`` имеет следующие параметры:"

#: ../../library/unittest.rst:297
msgid "Verbose output"
msgstr "Подробный вывод"

#: ../../library/unittest.rst:301
msgid "Directory to start discovery (``.`` default)"
msgstr "Каталог для начала обнаружения (``.`` по умолчанию)"

#: ../../library/unittest.rst:305
msgid "Pattern to match test files (``test*.py`` default)"
msgstr "Шаблон для соответствия тестовым файлам (по умолчанию ``test*.py``)"

#: ../../library/unittest.rst:309
msgid "Top level directory of project (defaults to start directory)"
msgstr "Каталог верхнего уровня проекта (по умолчанию — начальный каталог)"

#: ../../library/unittest.rst:311
msgid ""
"The :option:`-s`, :option:`-p`, and :option:`-t` options can be passed in as "
"positional arguments in that order. The following two command lines are "
"equivalent::"
msgstr ""
"Параметры :option:`-s`, :option:`-p` и :option:`-t` могут передаваться как "
"позиционные аргументы в указанном порядке. Следующие две командные строки "
"эквивалентны:"

#: ../../library/unittest.rst:315
msgid ""
"python -m unittest discover -s project_directory -p \"*_test.py\"\n"
"python -m unittest discover project_directory \"*_test.py\""
msgstr ""
"python -m unittest Discover -s каталог_проекта -p \"*_test.py\" python -m "
"unittest обнаружить каталог_проекта \"*_test.py\""

#: ../../library/unittest.rst:318
msgid ""
"As well as being a path it is possible to pass a package name, for example "
"``myproject.subpackage.test``, as the start directory. The package name you "
"supply will then be imported and its location on the filesystem will be used "
"as the start directory."
msgstr ""
"Помимо пути, в качестве начального каталога можно передать имя пакета, "
"например ``myproject.subpackage.test``. Указанное вами имя пакета будет "
"импортировано, а его местоположение в файловой системе будет использоваться "
"в качестве начального каталога."

#: ../../library/unittest.rst:325
msgid ""
"Test discovery loads tests by importing them. Once test discovery has found "
"all the test files from the start directory you specify it turns the paths "
"into package names to import. For example :file:`foo/bar/baz.py` will be "
"imported as ``foo.bar.baz``."
msgstr ""
"Обнаружение тестов загружает тесты путем их импорта. Как только обнаружение "
"тестов обнаружит все тестовые файлы из указанного вами начального каталога, "
"оно преобразует пути в имена пакетов для импорта. Например, :file:`foo/bar/"
"baz.py` будет импортирован как ``foo.bar.baz``."

#: ../../library/unittest.rst:330
msgid ""
"If you have a package installed globally and attempt test discovery on a "
"different copy of the package then the import *could* happen from the wrong "
"place. If this happens test discovery will warn you and exit."
msgstr ""
"Если у вас глобально установлен пакет и вы пытаетесь выполнить тестовое "
"обнаружение в другой копии пакета, импорт *может* произойти не из того "
"места. Если это произойдет, Test Discovery предупредит вас и завершит работу."

#: ../../library/unittest.rst:334
msgid ""
"If you supply the start directory as a package name rather than a path to a "
"directory then discover assumes that whichever location it imports from is "
"the location you intended, so you will not get the warning."
msgstr ""
"Если вы указываете начальный каталог в качестве имени пакета, а не пути к "
"каталогу, то Discover предполагает, что какое бы расположение он ни "
"импортировал, это именно то место, которое вы намеревались использовать, "
"поэтому вы не получите предупреждение."

#: ../../library/unittest.rst:339
msgid ""
"Test modules and packages can customize test loading and discovery by "
"through the `load_tests protocol`_."
msgstr ""
"Тестовые модули и пакеты могут настраивать загрузку и обнаружение тестов с "
"помощью протокола load_tests_."

#: ../../library/unittest.rst:342
msgid ""
"Test discovery supports :term:`namespace packages <namespace package>` for "
"the start directory. Note that you need to specify the top level directory "
"too (e.g. ``python -m unittest discover -s root/namespace -t root``)."
msgstr ""
"Обнаружение тестов поддерживает :term:`пакеты пространства имен <пакет "
"пространства имен>` для начального каталога. Обратите внимание, что вам "
"также необходимо указать каталог верхнего уровня (например, ``python -m "
"unittest Discover -s root/namespace -t root``)."

#: ../../library/unittest.rst:348
msgid ""
":mod:`unittest` dropped the :term:`namespace packages <namespace package>` "
"support in Python 3.11. It has been broken since Python 3.7. Start directory "
"and subdirectories containing tests must be regular package that have "
"``__init__.py`` file."
msgstr ""
":mod:`unittest` прекратил поддержку :term:`namespace packages <namespace "
"package>` в Python 3.11. Он был сломан начиная с Python 3.7. Начальный "
"каталог и подкаталоги, содержащие тесты, должны представлять собой обычный "
"пакет с файлом ``__init__.py``."

#: ../../library/unittest.rst:354
msgid ""
"Directories containing start directory still can be a namespace package. In "
"this case, you need to specify start directory as dotted package name, and "
"target directory explicitly. For example::"
msgstr ""
"Каталоги, содержащие стартовый каталог, по-прежнему могут быть пакетом "
"пространства имен. В этом случае вам необходимо указать начальный каталог в "
"виде имени пакета, разделенного точками, и явно указать целевой каталог. "
"Например::"

#: ../../library/unittest.rst:358
msgid ""
"# proj/  <-- current directory\n"
"#   namespace/\n"
"#     mypkg/\n"
"#       __init__.py\n"
"#       test_mypkg.py\n"
"\n"
"python -m unittest discover -s namespace.mypkg -t ."
msgstr ""
"# proj/  <-- current directory\n"
"#   namespace/\n"
"#     mypkg/\n"
"#       __init__.py\n"
"#       test_mypkg.py\n"
"\n"
"python -m unittest discover -s namespace.mypkg -t ."

#: ../../library/unittest.rst:370
msgid "Organizing test code"
msgstr "Организация тестового кода"

#: ../../library/unittest.rst:372
msgid ""
"The basic building blocks of unit testing are :dfn:`test cases` --- single "
"scenarios that must be set up and checked for correctness.  In :mod:"
"`unittest`, test cases are represented by :class:`unittest.TestCase` "
"instances. To make your own test cases you must write subclasses of :class:"
"`TestCase` or use :class:`FunctionTestCase`."
msgstr ""
"Основными строительными блоками модульного тестирования являются тестовые "
"примеры — отдельные сценарии, которые необходимо настроить и проверить на "
"корректность. В :mod:`unittest` тестовые случаи представлены экземплярами :"
"class:`unittest.TestCase`. Чтобы создать свои собственные тестовые примеры, "
"вы должны написать подклассы :class:`TestCase` или использовать :class:"
"`FunctionTestCase`."

#: ../../library/unittest.rst:378
msgid ""
"The testing code of a :class:`TestCase` instance should be entirely self "
"contained, such that it can be run either in isolation or in arbitrary "
"combination with any number of other test cases."
msgstr ""
"Код тестирования экземпляра :class:`TestCase` должен быть полностью "
"автономным, чтобы его можно было запускать либо изолированно, либо в "
"произвольной комбинации с любым количеством других тестовых случаев."

#: ../../library/unittest.rst:382
msgid ""
"The simplest :class:`TestCase` subclass will simply implement a test method "
"(i.e. a method whose name starts with ``test``) in order to perform specific "
"testing code::"
msgstr ""
"Самый простой подкласс :class:`TestCase` просто реализует тестовый метод (т."
"е. метод, имя которого начинается с ``test``) для выполнения конкретного "
"кода тестирования:"

#: ../../library/unittest.rst:386
msgid ""
"import unittest\n"
"\n"
"class DefaultWidgetSizeTestCase(unittest.TestCase):\n"
"    def test_default_widget_size(self):\n"
"        widget = Widget('The widget')\n"
"        self.assertEqual(widget.size(), (50, 50))"
msgstr ""
"import unittest\n"
"\n"
"class DefaultWidgetSizeTestCase(unittest.TestCase):\n"
"    def test_default_widget_size(self):\n"
"        widget = Widget('The widget')\n"
"        self.assertEqual(widget.size(), (50, 50))"

#: ../../library/unittest.rst:393
msgid ""
"Note that in order to test something, we use one of the :ref:`assert\\* "
"methods <assert-methods>` provided by the :class:`TestCase` base class.  If "
"the test fails, an exception will be raised with an explanatory message, "
"and :mod:`unittest` will identify the test case as a :dfn:`failure`.  Any "
"other exceptions will be treated as :dfn:`errors`."
msgstr ""
"Обратите внимание: чтобы что-то протестировать, мы используем один из "
"методов :ref:`assert\\* <assert-methods>`, предоставляемых базовым классом :"
"class:`TestCase`. Если тест не пройден, будет выдано исключение с поясняющим "
"сообщением, и :mod:`unittest` идентифицирует тестовый пример как :dfn:"
"`failure`. Любые другие исключения будут рассматриваться как :dfn:`errors`."

#: ../../library/unittest.rst:399
msgid ""
"Tests can be numerous, and their set-up can be repetitive.  Luckily, we can "
"factor out set-up code by implementing a method called :meth:`~TestCase."
"setUp`, which the testing framework will automatically call for every single "
"test we run::"
msgstr ""
"Тестов может быть множество, а их настройка может повторяться. К счастью, мы "
"можем выделить код настройки, реализовав метод :meth:`~TestCase.setUp`, "
"который среда тестирования будет автоматически вызывать для каждого "
"запускаемого нами теста:"

#: ../../library/unittest.rst:404
msgid ""
"import unittest\n"
"\n"
"class WidgetTestCase(unittest.TestCase):\n"
"    def setUp(self):\n"
"        self.widget = Widget('The widget')\n"
"\n"
"    def test_default_widget_size(self):\n"
"        self.assertEqual(self.widget.size(), (50,50),\n"
"                         'incorrect default size')\n"
"\n"
"    def test_widget_resize(self):\n"
"        self.widget.resize(100,150)\n"
"        self.assertEqual(self.widget.size(), (100,150),\n"
"                         'wrong size after resize')"
msgstr ""
"import unittest\n"
"\n"
"class WidgetTestCase(unittest.TestCase):\n"
"    def setUp(self):\n"
"        self.widget = Widget('The widget')\n"
"\n"
"    def test_default_widget_size(self):\n"
"        self.assertEqual(self.widget.size(), (50,50),\n"
"                         'incorrect default size')\n"
"\n"
"    def test_widget_resize(self):\n"
"        self.widget.resize(100,150)\n"
"        self.assertEqual(self.widget.size(), (100,150),\n"
"                         'wrong size after resize')"

#: ../../library/unittest.rst:420
msgid ""
"The order in which the various tests will be run is determined by sorting "
"the test method names with respect to the built-in ordering for strings."
msgstr ""
"Порядок, в котором будут выполняться различные тесты, определяется путем "
"сортировки имен тестовых методов относительно встроенного порядка строк."

#: ../../library/unittest.rst:424
msgid ""
"If the :meth:`~TestCase.setUp` method raises an exception while the test is "
"running, the framework will consider the test to have suffered an error, and "
"the test method will not be executed."
msgstr ""
"Если метод :meth:`~TestCase.setUp` вызывает исключение во время выполнения "
"теста, платформа посчитает, что в тесте произошла ошибка, и метод теста не "
"будет выполнен."

#: ../../library/unittest.rst:428
msgid ""
"Similarly, we can provide a :meth:`~TestCase.tearDown` method that tidies up "
"after the test method has been run::"
msgstr ""
"Аналогичным образом мы можем предоставить метод :meth:`~TestCase.tearDown`, "
"который наводит порядок после запуска тестового метода::"

#: ../../library/unittest.rst:431
msgid ""
"import unittest\n"
"\n"
"class WidgetTestCase(unittest.TestCase):\n"
"    def setUp(self):\n"
"        self.widget = Widget('The widget')\n"
"\n"
"    def tearDown(self):\n"
"        self.widget.dispose()"
msgstr ""
"импортировать модульный тест класс WidgetTestCase(unittest.TestCase): защита "
"setUp(self): self.widget = Виджет('Виджет') защита TearDown (сам): self."
"widget.dispose()"

#: ../../library/unittest.rst:440
msgid ""
"If :meth:`~TestCase.setUp` succeeded, :meth:`~TestCase.tearDown` will be run "
"whether the test method succeeded or not."
msgstr ""
"Если :meth:`~TestCase.setUp` завершился успешно, :meth:`~TestCase.tearDown` "
"будет запущен независимо от того, удался тестовый метод или нет."

#: ../../library/unittest.rst:443
msgid ""
"Such a working environment for the testing code is called a :dfn:`test "
"fixture`.  A new TestCase instance is created as a unique test fixture used "
"to execute each individual test method.  Thus :meth:`~TestCase.setUp`, :meth:"
"`~TestCase.tearDown`, and :meth:`~TestCase.__init__` will be called once per "
"test."
msgstr ""
"Такая рабочая среда для тестируемого кода называется тестовым "
"приспособлением. Новый экземпляр TestCase создается как уникальное тестовое "
"приспособление, используемое для выполнения каждого отдельного метода "
"тестирования. Таким образом, :meth:`~TestCase.setUp`, :meth:`~TestCase."
"tearDown` и :meth:`~TestCase.__init__` будут вызываться один раз для каждого "
"теста."

#: ../../library/unittest.rst:449
msgid ""
"It is recommended that you use TestCase implementations to group tests "
"together according to the features they test.  :mod:`unittest` provides a "
"mechanism for this: the :dfn:`test suite`, represented by :mod:`unittest`'s :"
"class:`TestSuite` class.  In most cases, calling :func:`unittest.main` will "
"do the right thing and collect all the module's test cases for you and "
"execute them."
msgstr ""
"Рекомендуется использовать реализации TestCase для группировки тестов в "
"соответствии с проверяемыми ими функциями. :mod:`unittest` предоставляет для "
"этого механизм: :dfn:`test suite`, представленный классом :class:"
"`TestSuite` :mod:`unittest`. В большинстве случаев вызов :func:`unittest."
"main` поступит правильно: соберет для вас все тестовые примеры модуля и "
"выполнит их."

#: ../../library/unittest.rst:456
msgid ""
"However, should you want to customize the building of your test suite, you "
"can do it yourself::"
msgstr ""
"Однако если вы захотите настроить построение своего набора тестов, вы можете "
"сделать это самостоятельно:"

#: ../../library/unittest.rst:459
msgid ""
"def suite():\n"
"    suite = unittest.TestSuite()\n"
"    suite.addTest(WidgetTestCase('test_default_widget_size'))\n"
"    suite.addTest(WidgetTestCase('test_widget_resize'))\n"
"    return suite\n"
"\n"
"if __name__ == '__main__':\n"
"    runner = unittest.TextTestRunner()\n"
"    runner.run(suite())"
msgstr ""
"def suite():\n"
"    suite = unittest.TestSuite()\n"
"    suite.addTest(WidgetTestCase('test_default_widget_size'))\n"
"    suite.addTest(WidgetTestCase('test_widget_resize'))\n"
"    return suite\n"
"\n"
"if __name__ == '__main__':\n"
"    runner = unittest.TextTestRunner()\n"
"    runner.run(suite())"

#: ../../library/unittest.rst:469
msgid ""
"You can place the definitions of test cases and test suites in the same "
"modules as the code they are to test (such as :file:`widget.py`), but there "
"are several advantages to placing the test code in a separate module, such "
"as :file:`test_widget.py`:"
msgstr ""
"Вы можете поместить определения тестовых примеров и наборов тестов в те же "
"модули, что и тестируемый код (например, :file:`widget.py`), но размещение "
"тестового кода в отдельном модуле имеет несколько преимуществ: например :"
"file:`test_widget.py`:"

#: ../../library/unittest.rst:474
msgid "The test module can be run standalone from the command line."
msgstr "Тестовый модуль можно запустить автономно из командной строки."

#: ../../library/unittest.rst:476
msgid "The test code can more easily be separated from shipped code."
msgstr "Тестовый код легче отделить от поставляемого кода."

#: ../../library/unittest.rst:478
msgid ""
"There is less temptation to change test code to fit the code it tests "
"without a good reason."
msgstr ""
"Меньше соблазна без уважительной причины изменить тестовый код, чтобы он "
"соответствовал тестируемому коду."

#: ../../library/unittest.rst:481
msgid ""
"Test code should be modified much less frequently than the code it tests."
msgstr ""
"Тестовый код следует изменять гораздо реже, чем код, который он тестирует."

#: ../../library/unittest.rst:483
msgid "Tested code can be refactored more easily."
msgstr "Протестированный код можно легче реорганизовать."

#: ../../library/unittest.rst:485
msgid ""
"Tests for modules written in C must be in separate modules anyway, so why "
"not be consistent?"
msgstr ""
"Тесты для модулей, написанных на C, в любом случае должны быть в отдельных "
"модулях, так почему бы не быть последовательными?"

#: ../../library/unittest.rst:488
msgid ""
"If the testing strategy changes, there is no need to change the source code."
msgstr ""
"Если стратегия тестирования изменится, нет необходимости менять исходный код."

#: ../../library/unittest.rst:494
msgid "Re-using old test code"
msgstr "Повторное использование старого тестового кода"

#: ../../library/unittest.rst:496
msgid ""
"Some users will find that they have existing test code that they would like "
"to run from :mod:`unittest`, without converting every old test function to "
"a :class:`TestCase` subclass."
msgstr ""
"Некоторые пользователи обнаружат, что у них уже есть тестовый код, который "
"они хотели бы запустить из :mod:`unittest`, без преобразования каждой старой "
"тестовой функции в подкласс :class:`TestCase`."

#: ../../library/unittest.rst:500
msgid ""
"For this reason, :mod:`unittest` provides a :class:`FunctionTestCase` class. "
"This subclass of :class:`TestCase` can be used to wrap an existing test "
"function.  Set-up and tear-down functions can also be provided."
msgstr ""
"По этой причине :mod:`unittest` предоставляет класс :class:"
"`FunctionTestCase`. Этот подкласс :class:`TestCase` можно использовать для "
"обертывания существующей тестовой функции. Также могут быть предусмотрены "
"функции установки и демонтажа."

#: ../../library/unittest.rst:504
msgid "Given the following test function::"
msgstr "Учитывая следующую тестовую функцию::"

#: ../../library/unittest.rst:506
msgid ""
"def testSomething():\n"
"    something = makeSomething()\n"
"    assert something.name is not None\n"
"    # ..."
msgstr ""
"def testSomething():\n"
"    something = makeSomething()\n"
"    assert something.name is not None\n"
"    # ..."

#: ../../library/unittest.rst:511
msgid ""
"one can create an equivalent test case instance as follows, with optional "
"set-up and tear-down methods::"
msgstr ""
"можно создать эквивалентный экземпляр тестового примера следующим образом, с "
"дополнительными методами настройки и удаления:"

#: ../../library/unittest.rst:514
msgid ""
"testcase = unittest.FunctionTestCase(testSomething,\n"
"                                     setUp=makeSomethingDB,\n"
"                                     tearDown=deleteSomethingDB)"
msgstr ""
"testcase = unittest.FunctionTestCase(testSomething,\n"
"                                     setUp=makeSomethingDB,\n"
"                                     tearDown=deleteSomethingDB)"

#: ../../library/unittest.rst:520
msgid ""
"Even though :class:`FunctionTestCase` can be used to quickly convert an "
"existing test base over to a :mod:`unittest`\\ -based system, this approach "
"is not recommended.  Taking the time to set up proper :class:`TestCase` "
"subclasses will make future test refactorings infinitely easier."
msgstr ""
"Несмотря на то, что :class:`FunctionTestCase` можно использовать для "
"быстрого преобразования существующей тестовой базы в систему на основе :mod:"
"`unittest`\\, этот подход не рекомендуется. Потратив время на настройку "
"правильных подклассов :class:`TestCase`, вы значительно упростите будущие "
"рефакторинги тестов."

#: ../../library/unittest.rst:525
msgid ""
"In some cases, the existing tests may have been written using the :mod:"
"`doctest` module.  If so, :mod:`doctest` provides a :class:`DocTestSuite` "
"class that can automatically build :class:`unittest.TestSuite` instances "
"from the existing :mod:`doctest`\\ -based tests."
msgstr ""
"В некоторых случаях существующие тесты могут быть написаны с использованием "
"модуля :mod:`doctest`. Если да, то :mod:`doctest` предоставляет класс :class:"
"`DocTestSuite`, который может автоматически создавать экземпляры :class:"
"`unittest.TestSuite` из существующих тестов на основе :mod:`doctest`\\."

#: ../../library/unittest.rst:534
msgid "Skipping tests and expected failures"
msgstr "Пропуск тестов и ожидаемые сбои"

#: ../../library/unittest.rst:538
msgid ""
"Unittest supports skipping individual test methods and even whole classes of "
"tests.  In addition, it supports marking a test as an \"expected failure,\" "
"a test that is broken and will fail, but shouldn't be counted as a failure "
"on a :class:`TestResult`."
msgstr ""
"Unittest поддерживает пропуск отдельных методов тестирования и даже целых "
"классов тестов. Кроме того, он поддерживает пометку теста как «ожидаемого "
"сбоя», теста, который не работает и завершится неудачно, но не должен "
"считаться сбоем в :class:`TestResult`."

#: ../../library/unittest.rst:543
msgid ""
"Skipping a test is simply a matter of using the :func:`skip` :term:"
"`decorator` or one of its conditional variants, calling :meth:`TestCase."
"skipTest` within a :meth:`~TestCase.setUp` or test method, or raising :exc:"
"`SkipTest` directly."
msgstr ""
"Пропустить тест можно просто с помощью :func:`skip` :term:`decorator` или "
"одного из его условных вариантов, вызывая :meth:`TestCase.skipTest` внутри :"
"meth:`~TestCase.setUp` или тестовый метод или вызов :exc:`SkipTest` напрямую."

#: ../../library/unittest.rst:547
msgid "Basic skipping looks like this::"
msgstr "Базовый пропуск выглядит так::"

#: ../../library/unittest.rst:549
msgid ""
"class MyTestCase(unittest.TestCase):\n"
"\n"
"    @unittest.skip(\"demonstrating skipping\")\n"
"    def test_nothing(self):\n"
"        self.fail(\"shouldn't happen\")\n"
"\n"
"    @unittest.skipIf(mylib.__version__ < (1, 3),\n"
"                     \"not supported in this library version\")\n"
"    def test_format(self):\n"
"        # Tests that work for only a certain version of the library.\n"
"        pass\n"
"\n"
"    @unittest.skipUnless(sys.platform.startswith(\"win\"), \"requires "
"Windows\")\n"
"    def test_windows_support(self):\n"
"        # windows specific testing code\n"
"        pass\n"
"\n"
"    def test_maybe_skipped(self):\n"
"        if not external_resource_available():\n"
"            self.skipTest(\"external resource not available\")\n"
"        # test code that depends on the external resource\n"
"        pass"
msgstr ""
"class MyTestCase(unittest.TestCase):\n"
"\n"
"    @unittest.skip(\"demonstrating skipping\")\n"
"    def test_nothing(self):\n"
"        self.fail(\"shouldn't happen\")\n"
"\n"
"    @unittest.skipIf(mylib.__version__ < (1, 3),\n"
"                     \"not supported in this library version\")\n"
"    def test_format(self):\n"
"        # Tests that work for only a certain version of the library.\n"
"        pass\n"
"\n"
"    @unittest.skipUnless(sys.platform.startswith(\"win\"), \"requires "
"Windows\")\n"
"    def test_windows_support(self):\n"
"        # windows specific testing code\n"
"        pass\n"
"\n"
"    def test_maybe_skipped(self):\n"
"        if not external_resource_available():\n"
"            self.skipTest(\"external resource not available\")\n"
"        # test code that depends on the external resource\n"
"        pass"

#: ../../library/unittest.rst:572
msgid "This is the output of running the example above in verbose mode::"
msgstr "Это результат выполнения приведенного выше примера в подробном режиме:"

#: ../../library/unittest.rst:574
msgid ""
"test_format (__main__.MyTestCase.test_format) ... skipped 'not supported in "
"this library version'\n"
"test_nothing (__main__.MyTestCase.test_nothing) ... skipped 'demonstrating "
"skipping'\n"
"test_maybe_skipped (__main__.MyTestCase.test_maybe_skipped) ... skipped "
"'external resource not available'\n"
"test_windows_support (__main__.MyTestCase.test_windows_support) ... skipped "
"'requires Windows'\n"
"\n"
"----------------------------------------------------------------------\n"
"Ran 4 tests in 0.005s\n"
"\n"
"OK (skipped=4)"
msgstr ""
"test_format (__main__.MyTestCase.test_format) ... skipped 'not supported in "
"this library version'\n"
"test_nothing (__main__.MyTestCase.test_nothing) ... skipped 'demonstrating "
"skipping'\n"
"test_maybe_skipped (__main__.MyTestCase.test_maybe_skipped) ... skipped "
"'external resource not available'\n"
"test_windows_support (__main__.MyTestCase.test_windows_support) ... skipped "
"'requires Windows'\n"
"\n"
"----------------------------------------------------------------------\n"
"Ran 4 tests in 0.005s\n"
"\n"
"OK (skipped=4)"

#: ../../library/unittest.rst:584
msgid "Classes can be skipped just like methods::"
msgstr "Классы можно пропускать так же, как и методы::"

#: ../../library/unittest.rst:586
msgid ""
"@unittest.skip(\"showing class skipping\")\n"
"class MySkippedTestCase(unittest.TestCase):\n"
"    def test_not_run(self):\n"
"        pass"
msgstr ""
"@unittest.skip(\"showing class skipping\")\n"
"class MySkippedTestCase(unittest.TestCase):\n"
"    def test_not_run(self):\n"
"        pass"

#: ../../library/unittest.rst:591
msgid ""
":meth:`TestCase.setUp` can also skip the test.  This is useful when a "
"resource that needs to be set up is not available."
msgstr ""
":meth:`TestCase.setUp` также может пропустить тест. Это полезно, когда "
"ресурс, который необходимо настроить, недоступен."

#: ../../library/unittest.rst:594
msgid "Expected failures use the :func:`expectedFailure` decorator. ::"
msgstr "Ожидаемые сбои используют декоратор :func:`expectedFailure`. ::"

#: ../../library/unittest.rst:596
msgid ""
"class ExpectedFailureTestCase(unittest.TestCase):\n"
"    @unittest.expectedFailure\n"
"    def test_fail(self):\n"
"        self.assertEqual(1, 0, \"broken\")"
msgstr ""
"класс ExpectedFailureTestCase(unittest.TestCase): @unittest.expectedFailure "
"защита test_fail(self): self.assertEqual(1, 0, «сломанный»)"

#: ../../library/unittest.rst:601
msgid ""
"It's easy to roll your own skipping decorators by making a decorator that "
"calls :func:`skip` on the test when it wants it to be skipped.  This "
"decorator skips the test unless the passed object has a certain attribute::"
msgstr ""
"Легко создавать собственные декораторы пропуска, создав декоратор, который "
"вызывает :func:`skip` в тесте, когда он хочет, чтобы его пропустили. Этот "
"декоратор пропускает проверку, если переданный объект не имеет определенного "
"атрибута::"

#: ../../library/unittest.rst:605
msgid ""
"def skipUnlessHasattr(obj, attr):\n"
"    if hasattr(obj, attr):\n"
"        return lambda func: func\n"
"    return unittest.skip(\"{!r} doesn't have {!r}\".format(obj, attr))"
msgstr ""
"def skipUnlessHasattr(obj, attr):\n"
"    if hasattr(obj, attr):\n"
"        return lambda func: func\n"
"    return unittest.skip(\"{!r} doesn't have {!r}\".format(obj, attr))"

#: ../../library/unittest.rst:610
msgid ""
"The following decorators and exception implement test skipping and expected "
"failures:"
msgstr ""
"Следующие декораторы и исключения реализуют пропуск тестов и ожидаемые сбои:"

#: ../../library/unittest.rst:614
msgid ""
"Unconditionally skip the decorated test.  *reason* should describe why the "
"test is being skipped."
msgstr ""
"Безоговорочно пропустите оформленный тест. *причина* должна описывать, "
"почему тест пропускается."

#: ../../library/unittest.rst:619
msgid "Skip the decorated test if *condition* is true."
msgstr "Пропустить декорированный тест, если *условие* истинно."

#: ../../library/unittest.rst:623
msgid "Skip the decorated test unless *condition* is true."
msgstr "Пропустить декорированный тест, если *условие* не истинно."

#: ../../library/unittest.rst:627
msgid ""
"Mark the test as an expected failure or error.  If the test fails or errors "
"in the test function itself (rather than in one of the :dfn:`test fixture` "
"methods) then it will be considered a success.  If the test passes, it will "
"be considered a failure."
msgstr ""
"Отметьте тест как ожидаемый сбой или ошибку. Если тест не пройден или "
"возникли ошибки в самой тестовой функции (а не в одном из методов :dfn:`test "
"приспособления`), то он будет считаться успешным. Если тест пройден успешно, "
"это будет считаться неудачным."

#: ../../library/unittest.rst:634
msgid "This exception is raised to skip a test."
msgstr "Это исключение вызывается для пропуска теста."

#: ../../library/unittest.rst:636
msgid ""
"Usually you can use :meth:`TestCase.skipTest` or one of the skipping "
"decorators instead of raising this directly."
msgstr ""
"Обычно вы можете использовать :meth:`TestCase.skipTest` или один из "
"пропущенных декораторов вместо того, чтобы вызывать это напрямую."

#: ../../library/unittest.rst:639
msgid ""
"Skipped tests will not have :meth:`~TestCase.setUp` or :meth:`~TestCase."
"tearDown` run around them. Skipped classes will not have :meth:`~TestCase."
"setUpClass` or :meth:`~TestCase.tearDownClass` run. Skipped modules will not "
"have :func:`setUpModule` or :func:`tearDownModule` run."
msgstr ""
"Пропущенные тесты не будут выполняться вокруг них :meth:`~TestCase.setUp` "
"или :meth:`~TestCase.tearDown`. Пропущенные классы не будут запускаться :"
"meth:`~TestCase.setUpClass` или :meth:`~TestCase.tearDownClass`. Пропущенные "
"модули не будут запускаться :func:`setUpModule` или :func:`tearDownModule`."

#: ../../library/unittest.rst:647
msgid "Distinguishing test iterations using subtests"
msgstr "Различение итераций теста с помощью подтестов"

#: ../../library/unittest.rst:651
msgid ""
"When there are very small differences among your tests, for instance some "
"parameters, unittest allows you to distinguish them inside the body of a "
"test method using the :meth:`~TestCase.subTest` context manager."
msgstr ""
"Если между вашими тестами есть очень небольшие различия, например некоторые "
"параметры, unittest позволяет вам различать их внутри тела метода "
"тестирования с помощью контекстного менеджера :meth:`~TestCase.subTest`."

#: ../../library/unittest.rst:655
msgid "For example, the following test::"
msgstr "Например, следующий тест:"

#: ../../library/unittest.rst:657
msgid ""
"class NumbersTest(unittest.TestCase):\n"
"\n"
"    def test_even(self):\n"
"        \"\"\"\n"
"        Test that numbers between 0 and 5 are all even.\n"
"        \"\"\"\n"
"        for i in range(0, 6):\n"
"            with self.subTest(i=i):\n"
"                self.assertEqual(i % 2, 0)"
msgstr ""
"class NumbersTest(unittest.TestCase):\n"
"\n"
"    def test_even(self):\n"
"        \"\"\"\n"
"        Test that numbers between 0 and 5 are all even.\n"
"        \"\"\"\n"
"        for i in range(0, 6):\n"
"            with self.subTest(i=i):\n"
"                self.assertEqual(i % 2, 0)"

#: ../../library/unittest.rst:667
msgid "will produce the following output::"
msgstr "выдаст следующий результат::"

#: ../../library/unittest.rst:669
msgid ""
"======================================================================\n"
"FAIL: test_even (__main__.NumbersTest.test_even) (i=1)\n"
"Test that numbers between 0 and 5 are all even.\n"
"----------------------------------------------------------------------\n"
"Traceback (most recent call last):\n"
"  File \"subtests.py\", line 11, in test_even\n"
"    self.assertEqual(i % 2, 0)\n"
"    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"AssertionError: 1 != 0\n"
"\n"
"======================================================================\n"
"FAIL: test_even (__main__.NumbersTest.test_even) (i=3)\n"
"Test that numbers between 0 and 5 are all even.\n"
"----------------------------------------------------------------------\n"
"Traceback (most recent call last):\n"
"  File \"subtests.py\", line 11, in test_even\n"
"    self.assertEqual(i % 2, 0)\n"
"    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"AssertionError: 1 != 0\n"
"\n"
"======================================================================\n"
"FAIL: test_even (__main__.NumbersTest.test_even) (i=5)\n"
"Test that numbers between 0 and 5 are all even.\n"
"----------------------------------------------------------------------\n"
"Traceback (most recent call last):\n"
"  File \"subtests.py\", line 11, in test_even\n"
"    self.assertEqual(i % 2, 0)\n"
"    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"AssertionError: 1 != 0"
msgstr ""
"======================================================================\n"
"FAIL: test_even (__main__.NumbersTest.test_even) (i=1)\n"
"Test that numbers between 0 and 5 are all even.\n"
"----------------------------------------------------------------------\n"
"Traceback (most recent call last):\n"
"  File \"subtests.py\", line 11, in test_even\n"
"    self.assertEqual(i % 2, 0)\n"
"    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"AssertionError: 1 != 0\n"
"\n"
"======================================================================\n"
"FAIL: test_even (__main__.NumbersTest.test_even) (i=3)\n"
"Test that numbers between 0 and 5 are all even.\n"
"----------------------------------------------------------------------\n"
"Traceback (most recent call last):\n"
"  File \"subtests.py\", line 11, in test_even\n"
"    self.assertEqual(i % 2, 0)\n"
"    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"AssertionError: 1 != 0\n"
"\n"
"======================================================================\n"
"FAIL: test_even (__main__.NumbersTest.test_even) (i=5)\n"
"Test that numbers between 0 and 5 are all even.\n"
"----------------------------------------------------------------------\n"
"Traceback (most recent call last):\n"
"  File \"subtests.py\", line 11, in test_even\n"
"    self.assertEqual(i % 2, 0)\n"
"    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"AssertionError: 1 != 0"

#: ../../library/unittest.rst:699
msgid ""
"Without using a subtest, execution would stop after the first failure, and "
"the error would be less easy to diagnose because the value of ``i`` wouldn't "
"be displayed::"
msgstr ""
"Без использования подтеста выполнение остановилось бы после первого сбоя, и "
"ошибку было бы труднее диагностировать, поскольку значение ``i`` не будет "
"отображаться:"

#: ../../library/unittest.rst:703
msgid ""
"======================================================================\n"
"FAIL: test_even (__main__.NumbersTest.test_even)\n"
"----------------------------------------------------------------------\n"
"Traceback (most recent call last):\n"
"  File \"subtests.py\", line 32, in test_even\n"
"    self.assertEqual(i % 2, 0)\n"
"AssertionError: 1 != 0"
msgstr ""
"======================================================================\n"
"FAIL: test_even (__main__.NumbersTest.test_even)\n"
"----------------------------------------------------------------------\n"
"Traceback (most recent call last):\n"
"  File \"subtests.py\", line 32, in test_even\n"
"    self.assertEqual(i % 2, 0)\n"
"AssertionError: 1 != 0"

#: ../../library/unittest.rst:715
msgid "Classes and functions"
msgstr "Классы и функции"

#: ../../library/unittest.rst:717
msgid "This section describes in depth the API of :mod:`unittest`."
msgstr "В этом разделе подробно описывается API :mod:`unittest`."

#: ../../library/unittest.rst:723
msgid "Test cases"
msgstr "Тестовые примеры"

#: ../../library/unittest.rst:727
msgid ""
"Instances of the :class:`TestCase` class represent the logical test units in "
"the :mod:`unittest` universe.  This class is intended to be used as a base "
"class, with specific tests being implemented by concrete subclasses.  This "
"class implements the interface needed by the test runner to allow it to "
"drive the tests, and methods that the test code can use to check for and "
"report various kinds of failure."
msgstr ""
"Экземпляры класса :class:`TestCase` представляют собой логические тестовые "
"модули во вселенной :mod:`unittest`. Этот класс предназначен для "
"использования в качестве базового класса, при этом конкретные тесты "
"реализуются конкретными подклассами. Этот класс реализует интерфейс, "
"необходимый средству запуска тестов, чтобы позволить ему управлять тестами, "
"а также методы, которые тестовый код может использовать для проверки и "
"сообщения о различных типах сбоев."

#: ../../library/unittest.rst:734
msgid ""
"Each instance of :class:`TestCase` will run a single base method: the method "
"named *methodName*. In most uses of :class:`TestCase`, you will neither "
"change the *methodName* nor reimplement the default ``runTest()`` method."
msgstr ""
"Каждый экземпляр :class:`TestCase` будет запускать один базовый метод: метод "
"с именем *methodName*. В большинстве случаев использования :class:`TestCase` "
"вы не будете ни менять *methodName*, ни переопределять метод по умолчанию "
"``runTest()``."

#: ../../library/unittest.rst:739
msgid ""
":class:`TestCase` can be instantiated successfully without providing a "
"*methodName*. This makes it easier to experiment with :class:`TestCase` from "
"the interactive interpreter."
msgstr ""
":class:`TestCase` может быть успешно создан без указания *methodName*. Это "
"упрощает эксперименты с :class:`TestCase` из интерактивного интерпретатора."

#: ../../library/unittest.rst:744
msgid ""
":class:`TestCase` instances provide three groups of methods: one group used "
"to run the test, another used by the test implementation to check conditions "
"and report failures, and some inquiry methods allowing information about the "
"test itself to be gathered."
msgstr ""
"Экземпляры :class:`TestCase` предоставляют три группы методов: одна группа "
"используется для запуска теста, другая используется реализацией теста для "
"проверки условий и сообщения об ошибках, а также некоторые методы запроса, "
"позволяющие собирать информацию о самом тесте."

#: ../../library/unittest.rst:749
msgid "Methods in the first group (running the test) are:"
msgstr "Методы первой группы (проведение теста):"

#: ../../library/unittest.rst:753
msgid ""
"Method called to prepare the test fixture.  This is called immediately "
"before calling the test method; other than :exc:`AssertionError` or :exc:"
"`SkipTest`, any exception raised by this method will be considered an error "
"rather than a test failure. The default implementation does nothing."
msgstr ""
"Метод, вызываемый для подготовки тестового приспособления. Он вызывается "
"непосредственно перед вызовом тестового метода; кроме :exc:`AssertionError` "
"или :exc:`SkipTest`, любое исключение, вызванное этим методом, будет "
"считаться ошибкой, а не провалом теста. Реализация по умолчанию ничего не "
"делает."

#: ../../library/unittest.rst:761
msgid ""
"Method called immediately after the test method has been called and the "
"result recorded.  This is called even if the test method raised an "
"exception, so the implementation in subclasses may need to be particularly "
"careful about checking internal state.  Any exception, other than :exc:"
"`AssertionError` or :exc:`SkipTest`, raised by this method will be "
"considered an additional error rather than a test failure (thus increasing "
"the total number of reported errors). This method will only be called if "
"the :meth:`setUp` succeeds, regardless of the outcome of the test method. "
"The default implementation does nothing."
msgstr ""
"Метод вызывается сразу после вызова тестового метода и записи результата. Он "
"вызывается, даже если тестовый метод вызвал исключение, поэтому при "
"реализации в подклассах может потребоваться особая осторожность при проверке "
"внутреннего состояния. Любое исключение, кроме :exc:`AssertionError` или :"
"exc:`SkipTest`, вызванное этим методом, будет считаться дополнительной "
"ошибкой, а не сбоем теста (таким образом увеличивая общее количество "
"зарегистрированных ошибок). Этот метод будет вызываться только в том случае, "
"если :meth:`setUp` завершится успешно, независимо от результата метода "
"тестирования. Реализация по умолчанию ничего не делает."

#: ../../library/unittest.rst:774
msgid ""
"A class method called before tests in an individual class are run. "
"``setUpClass`` is called with the class as the only argument and must be "
"decorated as a :func:`classmethod`::"
msgstr ""
"Метод класса, вызываемый перед запуском тестов в отдельном классе. "
"``setUpClass`` вызывается с классом в качестве единственного аргумента и "
"должен быть оформлен как :func:`classmethod`::"

#: ../../library/unittest.rst:778
msgid ""
"@classmethod\n"
"def setUpClass(cls):\n"
"    ..."
msgstr ""
"@classmethod\n"
"def setUpClass(cls):\n"
"    ..."

#: ../../library/unittest.rst:782 ../../library/unittest.rst:797
msgid "See `Class and Module Fixtures`_ for more details."
msgstr "См. «Фикстуры классов и модулей» для более подробной информации."

#: ../../library/unittest.rst:789
msgid ""
"A class method called after tests in an individual class have run. "
"``tearDownClass`` is called with the class as the only argument and must be "
"decorated as a :meth:`classmethod`::"
msgstr ""
"Метод класса, вызываемый после выполнения тестов в отдельном классе. "
"``tearDownClass`` вызывается с классом в качестве единственного аргумента и "
"должен быть оформлен как :meth:`classmethod`::"

#: ../../library/unittest.rst:793
msgid ""
"@classmethod\n"
"def tearDownClass(cls):\n"
"    ..."
msgstr ""
"@classmethod\n"
"def tearDownClass(cls):\n"
"    ..."

#: ../../library/unittest.rst:804
msgid ""
"Run the test, collecting the result into the :class:`TestResult` object "
"passed as *result*.  If *result* is omitted or ``None``, a temporary result "
"object is created (by calling the :meth:`defaultTestResult` method) and "
"used. The result object is returned to :meth:`run`'s caller."
msgstr ""
"Запустите тест, собрав результат в объект :class:`TestResult`, переданный "
"как *result*. Если *result* опущен или ``None``, создается временный объект "
"результата (путем вызова метода :meth:`defaultTestResult`) и используется. "
"Объект результата возвращается вызывающей стороне :meth:`run`."

#: ../../library/unittest.rst:810
msgid ""
"The same effect may be had by simply calling the :class:`TestCase` instance."
msgstr ""
"Тот же эффект можно получить, просто вызвав экземпляр :class:`TestCase`."

#: ../../library/unittest.rst:813
msgid ""
"Previous versions of ``run`` did not return the result. Neither did calling "
"an instance."
msgstr ""
"Предыдущие версии ``run`` не возвращали результат. Как и вызов экземпляра."

#: ../../library/unittest.rst:819
msgid ""
"Calling this during a test method or :meth:`setUp` skips the current test.  "
"See :ref:`unittest-skipping` for more information."
msgstr ""
"Вызов этого метода во время тестового метода или :meth:`setUp` пропускает "
"текущий тест. Дополнительную информацию см. в разделе :ref:`unittest-"
"skipping`."

#: ../../library/unittest.rst:827
msgid ""
"Return a context manager which executes the enclosed code block as a "
"subtest.  *msg* and *params* are optional, arbitrary values which are "
"displayed whenever a subtest fails, allowing you to identify them clearly."
msgstr ""
"Верните менеджер контекста, который выполняет вложенный блок кода в качестве "
"подтеста. *msg* и *params* — необязательные произвольные значения, которые "
"отображаются при сбое подтеста, что позволяет четко их идентифицировать."

#: ../../library/unittest.rst:832
msgid ""
"A test case can contain any number of subtest declarations, and they can be "
"arbitrarily nested."
msgstr ""
"Тестовый пример может содержать любое количество объявлений подтестов, и они "
"могут быть произвольно вложены."

#: ../../library/unittest.rst:835
msgid "See :ref:`subtests` for more information."
msgstr "Дополнительную информацию см. в разделе :ref:`subtests`."

#: ../../library/unittest.rst:842
msgid ""
"Run the test without collecting the result.  This allows exceptions raised "
"by the test to be propagated to the caller, and can be used to support "
"running tests under a debugger."
msgstr ""
"Запустите тест, не собирая результат. Это позволяет распространять "
"исключения, вызванные тестом, на вызывающую сторону и может использоваться "
"для поддержки запуска тестов в отладчике."

#: ../../library/unittest.rst:848
msgid ""
"The :class:`TestCase` class provides several assert methods to check for and "
"report failures.  The following table lists the most commonly used methods "
"(see the tables below for more assert methods):"
msgstr ""
"Класс :class:`TestCase` предоставляет несколько методов проверки для "
"проверки и сообщения об ошибках. В следующей таблице перечислены наиболее "
"часто используемые методы (дополнительные методы утверждения см. в таблицах "
"ниже):"

#: ../../library/unittest.rst:853 ../../library/unittest.rst:974
#: ../../library/unittest.rst:1188 ../../library/unittest.rst:1312
msgid "Method"
msgstr "Метод"

#: ../../library/unittest.rst:853 ../../library/unittest.rst:974
#: ../../library/unittest.rst:1188
msgid "Checks that"
msgstr "Проверяет, что"

#: ../../library/unittest.rst:853 ../../library/unittest.rst:974
#: ../../library/unittest.rst:1188 ../../library/unittest.rst:1312
msgid "New in"
msgstr "Новое в"

#: ../../library/unittest.rst:855
msgid ":meth:`assertEqual(a, b) <TestCase.assertEqual>`"
msgstr ":meth:`assertEqual(a, b) <TestCase.assertEqual>`"

#: ../../library/unittest.rst:855
msgid "``a == b``"
msgstr "``a == b``"

#: ../../library/unittest.rst:858
msgid ":meth:`assertNotEqual(a, b) <TestCase.assertNotEqual>`"
msgstr ":meth:`assertNotEqual(a, b) <TestCase.assertNotEqual>`"

#: ../../library/unittest.rst:858
msgid "``a != b``"
msgstr "``a != b``"

#: ../../library/unittest.rst:861
msgid ":meth:`assertTrue(x) <TestCase.assertTrue>`"
msgstr ":meth:`assertTrue(x) <TestCase.assertTrue>`"

#: ../../library/unittest.rst:861
msgid "``bool(x) is True``"
msgstr "``bool(x) is True``"

#: ../../library/unittest.rst:864
msgid ":meth:`assertFalse(x) <TestCase.assertFalse>`"
msgstr ":meth:`assertFalse(x) <TestCase.assertFalse>`"

#: ../../library/unittest.rst:864
msgid "``bool(x) is False``"
msgstr "``bool(x) is False``"

#: ../../library/unittest.rst:867
msgid ":meth:`assertIs(a, b) <TestCase.assertIs>`"
msgstr ":meth:`assertIs(a, b) <TestCase.assertIs>`"

#: ../../library/unittest.rst:867
msgid "``a is b``"
msgstr "``a is b``"

#: ../../library/unittest.rst:867 ../../library/unittest.rst:870
#: ../../library/unittest.rst:873 ../../library/unittest.rst:876
#: ../../library/unittest.rst:879 ../../library/unittest.rst:882
#: ../../library/unittest.rst:979 ../../library/unittest.rst:1196
#: ../../library/unittest.rst:1199 ../../library/unittest.rst:1202
#: ../../library/unittest.rst:1205 ../../library/unittest.rst:1208
#: ../../library/unittest.rst:1314 ../../library/unittest.rst:1317
#: ../../library/unittest.rst:1320 ../../library/unittest.rst:1323
#: ../../library/unittest.rst:1326 ../../library/unittest.rst:1329
msgid "3.1"
msgstr "3.1"

#: ../../library/unittest.rst:870
msgid ":meth:`assertIsNot(a, b) <TestCase.assertIsNot>`"
msgstr ":meth:`assertIsNot(a, b) <TestCase.assertIsNot>`"

#: ../../library/unittest.rst:870
msgid "``a is not b``"
msgstr "``a is not b``"

#: ../../library/unittest.rst:873
msgid ":meth:`assertIsNone(x) <TestCase.assertIsNone>`"
msgstr ":meth:`assertIsNone(x) <TestCase.assertIsNone>`"

#: ../../library/unittest.rst:873
msgid "``x is None``"
msgstr "``x is None``"

#: ../../library/unittest.rst:876
msgid ":meth:`assertIsNotNone(x) <TestCase.assertIsNotNone>`"
msgstr ":meth:`assertIsNotNone(x) <TestCase.assertIsNotNone>`"

#: ../../library/unittest.rst:876
msgid "``x is not None``"
msgstr "``x is not None``"

#: ../../library/unittest.rst:879
msgid ":meth:`assertIn(a, b) <TestCase.assertIn>`"
msgstr ":meth:`assertIn(a, b) <TestCase.assertIn>`"

#: ../../library/unittest.rst:879
msgid "``a in b``"
msgstr "``a in b``"

#: ../../library/unittest.rst:882
msgid ":meth:`assertNotIn(a, b) <TestCase.assertNotIn>`"
msgstr ":meth:`assertNotIn(a, b) <TestCase.assertNotIn>`"

#: ../../library/unittest.rst:882
msgid "``a not in b``"
msgstr "``a not in b``"

#: ../../library/unittest.rst:885
msgid ":meth:`assertIsInstance(a, b) <TestCase.assertIsInstance>`"
msgstr ":meth:`assertIsInstance(a, b) <TestCase.assertIsInstance>`"

#: ../../library/unittest.rst:885
msgid "``isinstance(a, b)``"
msgstr "``isinstance(a, b)``"

#: ../../library/unittest.rst:885 ../../library/unittest.rst:888
#: ../../library/unittest.rst:982 ../../library/unittest.rst:985
#: ../../library/unittest.rst:1211 ../../library/unittest.rst:1214
msgid "3.2"
msgstr "3.2"

#: ../../library/unittest.rst:888
msgid ":meth:`assertNotIsInstance(a, b) <TestCase.assertNotIsInstance>`"
msgstr ":meth:`assertNotIsInstance(a, b) <TestCase.assertNotIsInstance>`"

#: ../../library/unittest.rst:888
msgid "``not isinstance(a, b)``"
msgstr "``not isinstance(a, b)``"

#: ../../library/unittest.rst:892
msgid ""
"All the assert methods accept a *msg* argument that, if specified, is used "
"as the error message on failure (see also :data:`longMessage`). Note that "
"the *msg* keyword argument can be passed to :meth:`assertRaises`, :meth:"
"`assertRaisesRegex`, :meth:`assertWarns`, :meth:`assertWarnsRegex` only when "
"they are used as a context manager."
msgstr ""
"Все методы утверждения принимают аргумент *msg*, который, если он указан, "
"используется в качестве сообщения об ошибке в случае сбоя (см. также :data:"
"`longMessage`). Обратите внимание, что аргумент ключевого слова *msg* можно "
"передать в :meth:`assertRaises`, :meth:`assertRaisesRegex`, :meth:"
"`assertWarns`, :meth:`assertWarnsRegex` только тогда, когда они используются "
"в качестве контекстного менеджера."

#: ../../library/unittest.rst:900
msgid ""
"Test that *first* and *second* are equal.  If the values do not compare "
"equal, the test will fail."
msgstr ""
"Проверьте, что *первый* и *второй* равны. Если значения не сравниваются "
"равными, тест завершится неудачей."

#: ../../library/unittest.rst:903
msgid ""
"In addition, if *first* and *second* are the exact same type and one of "
"list, tuple, dict, set, frozenset or str or any type that a subclass "
"registers with :meth:`addTypeEqualityFunc` the type-specific equality "
"function will be called in order to generate a more useful default error "
"message (see also the :ref:`list of type-specific methods <type-specific-"
"methods>`)."
msgstr ""
"Кроме того, если *first* и * Second* имеют один и тот же тип и один из "
"списка, кортежа, dict, set, FrozesetSet или Str или любого типа, который "
"регистрируется подклассом с помощью :meth:`addTypeEqualityFunc`, функция "
"равенства для конкретного типа будет вызываться для генерации более "
"полезного сообщения об ошибке по умолчанию (см. также :ref:`список методов, "
"специфичных для типа <type-dependent-methods>`)."

#: ../../library/unittest.rst:910
msgid "Added the automatic calling of type-specific equality function."
msgstr "Добавлен автоматический вызов функции равенства для конкретного типа."

#: ../../library/unittest.rst:913
msgid ""
":meth:`assertMultiLineEqual` added as the default type equality function for "
"comparing strings."
msgstr ""
":meth:`assertMultiLineEqual` добавлен как функция равенства типов по "
"умолчанию для сравнения строк."

#: ../../library/unittest.rst:920
msgid ""
"Test that *first* and *second* are not equal.  If the values do compare "
"equal, the test will fail."
msgstr ""
"Проверьте, что *первый* и *второй* не равны. Если значения сравниваются "
"равными, тест не пройден."

#: ../../library/unittest.rst:926
msgid "Test that *expr* is true (or false)."
msgstr "Проверьте, что *выражение* истинно (или ложно)."

#: ../../library/unittest.rst:928
msgid ""
"Note that this is equivalent to ``bool(expr) is True`` and not to ``expr is "
"True`` (use ``assertIs(expr, True)`` for the latter).  This method should "
"also be avoided when more specific methods are available (e.g. "
"``assertEqual(a, b)`` instead of ``assertTrue(a == b)``), because they "
"provide a better error message in case of failure."
msgstr ""
"Обратите внимание, что это эквивалентно ``bool(expr) is True``, а не ``expr "
"is True`` (для последнего используйте ``assertIs(expr, True)``). Этого "
"метода также следует избегать, когда доступны более конкретные методы "
"(например, ``assertEqual(a, b)`` вместо ``assertTrue(a == b)``), поскольку "
"они обеспечивают лучшее сообщение об ошибке в случае сбоя. ."

#: ../../library/unittest.rst:938
msgid "Test that *first* and *second* are (or are not) the same object."
msgstr ""
"Проверьте, что *первый* и *второй* являются (или не являются) одним и тем же "
"объектом."

#: ../../library/unittest.rst:946
msgid "Test that *expr* is (or is not) ``None``."
msgstr "Проверьте, что *expr* равно (или нет) ``None``."

#: ../../library/unittest.rst:954
msgid "Test that *member* is (or is not) in *container*."
msgstr "Проверьте, что *member* находится (или нет) в *container*."

#: ../../library/unittest.rst:962
msgid ""
"Test that *obj* is (or is not) an instance of *cls* (which can be a class or "
"a tuple of classes, as supported by :func:`isinstance`). To check for the "
"exact type, use :func:`assertIs(type(obj), cls) <assertIs>`."
msgstr ""
"Проверьте, что *obj* является (или не является) экземпляром *cls* (который "
"может быть классом или кортежем классов, что поддерживается :func:"
"`isinstance`). Чтобы проверить точный тип, используйте :func:"
"`assertIs(type(obj), cls) <assertIs>`."

#: ../../library/unittest.rst:970
msgid ""
"It is also possible to check the production of exceptions, warnings, and log "
"messages using the following methods:"
msgstr ""
"Также можно проверить создание исключений, предупреждений и сообщений "
"журнала следующими методами:"

#: ../../library/unittest.rst:976
msgid ":meth:`assertRaises(exc, fun, *args, **kwds) <TestCase.assertRaises>`"
msgstr ":meth:`assertRaises(exc, fun, *args, **kwds) <TestCase.assertRaises>`"

#: ../../library/unittest.rst:976
msgid "``fun(*args, **kwds)`` raises *exc*"
msgstr "``fun(*args, **kwds)`` raises *exc*"

#: ../../library/unittest.rst:979
msgid ""
":meth:`assertRaisesRegex(exc, r, fun, *args, **kwds) <TestCase."
"assertRaisesRegex>`"
msgstr ""
":meth:`assertRaisesRegex(exc, r, fun, *args, **kwds) <TestCase."
"assertRaisesRegex>`"

#: ../../library/unittest.rst:979
msgid "``fun(*args, **kwds)`` raises *exc* and the message matches regex *r*"
msgstr ""
"``fun(*args, **kwds)`` вызывает *exc* и сообщение соответствует регулярному "
"выражению *r*"

#: ../../library/unittest.rst:982
msgid ":meth:`assertWarns(warn, fun, *args, **kwds) <TestCase.assertWarns>`"
msgstr ":meth:`assertWarns(warn, fun, *args, **kwds) <TestCase.assertWarns>`"

#: ../../library/unittest.rst:982
msgid "``fun(*args, **kwds)`` raises *warn*"
msgstr "``fun(*args, **kwds)`` вызывает *warn*"

#: ../../library/unittest.rst:985
msgid ""
":meth:`assertWarnsRegex(warn, r, fun, *args, **kwds) <TestCase."
"assertWarnsRegex>`"
msgstr ""
":meth:`assertWarnsRegex(warn, r, fun, *args, **kwds) <TestCase."
"assertWarnsRegex>`"

#: ../../library/unittest.rst:985
msgid "``fun(*args, **kwds)`` raises *warn* and the message matches regex *r*"
msgstr ""
"``fun(*args, **kwds)`` выдает *warn* и сообщение соответствует регулярному "
"выражению *r*"

#: ../../library/unittest.rst:988
msgid ":meth:`assertLogs(logger, level) <TestCase.assertLogs>`"
msgstr ":meth:`assertLogs(logger, level) <TestCase.assertLogs>`"

#: ../../library/unittest.rst:988
msgid "The ``with`` block logs on *logger* with minimum *level*"
msgstr "Блок ``with`` регистрируется в *logger* с минимальным *уровнем*."

#: ../../library/unittest.rst:988
msgid "3.4"
msgstr "3.4"

#: ../../library/unittest.rst:991
msgid ":meth:`assertNoLogs(logger, level) <TestCase.assertNoLogs>`"
msgstr ":meth:`assertNoLogs(logger, level) <TestCase.assertNoLogs>`"

#: ../../library/unittest.rst:991
msgid "The ``with`` block does not log on"
msgstr "Блок ``with`` не входит в систему"

#: ../../library/unittest.rst:992
msgid "*logger* with minimum *level*"
msgstr "*логгер* с минимальным *уровнем*"

#: ../../library/unittest.rst:991
msgid "3.10"
msgstr "3.10"

#: ../../library/unittest.rst:998
msgid ""
"Test that an exception is raised when *callable* is called with any "
"positional or keyword arguments that are also passed to :meth:"
"`assertRaises`.  The test passes if *exception* is raised, is an error if "
"another exception is raised, or fails if no exception is raised. To catch "
"any of a group of exceptions, a tuple containing the exception classes may "
"be passed as *exception*."
msgstr ""
"Проверьте, возникает ли исключение при вызове *callable* с любыми "
"позиционными или ключевыми аргументами, которые также передаются в :meth:"
"`assertRaises`. Тест проходит успешно, если возникло *исключение*, является "
"ошибкой, если возникло другое исключение, или завершается неудачно, если "
"исключение не возникло. Чтобы перехватить любое исключение из группы, "
"кортеж, содержащий классы исключений, может быть передан как *Exception*."

#: ../../library/unittest.rst:1005
msgid ""
"If only the *exception* and possibly the *msg* arguments are given, return a "
"context manager so that the code under test can be written inline rather "
"than as a function::"
msgstr ""
"Если заданы только аргументы *исключение* и, возможно, *msg*, верните "
"диспетчер контекста, чтобы тестируемый код можно было записать встроенным, а "
"не в виде функции::"

#: ../../library/unittest.rst:1009
msgid ""
"with self.assertRaises(SomeException):\n"
"    do_something()"
msgstr "с self.assertRaises(SomeException): сделать_что-то()"

#: ../../library/unittest.rst:1012
msgid ""
"When used as a context manager, :meth:`assertRaises` accepts the additional "
"keyword argument *msg*."
msgstr ""
"При использовании в качестве менеджера контекста :meth:`assertRaises` "
"принимает дополнительный аргумент ключевого слова *msg*."

#: ../../library/unittest.rst:1015
msgid ""
"The context manager will store the caught exception object in its :attr:"
"`exception` attribute.  This can be useful if the intention is to perform "
"additional checks on the exception raised::"
msgstr ""
"Менеджер контекста сохранит перехваченный объект исключения в своем "
"атрибуте :attr:`Exception`. Это может быть полезно, если предполагается "
"выполнить дополнительные проверки возникшего исключения:"

#: ../../library/unittest.rst:1019
msgid ""
"with self.assertRaises(SomeException) as cm:\n"
"    do_something()\n"
"\n"
"the_exception = cm.exception\n"
"self.assertEqual(the_exception.error_code, 3)"
msgstr ""
"with self.assertRaises(SomeException) as cm:\n"
"    do_something()\n"
"\n"
"the_exception = cm.exception\n"
"self.assertEqual(the_exception.error_code, 3)"

#: ../../library/unittest.rst:1025
msgid "Added the ability to use :meth:`assertRaises` as a context manager."
msgstr ""
"Добавлена ​​возможность использовать :meth:`assertRaises` в качестве "
"контекстного менеджера."

#: ../../library/unittest.rst:1028
msgid "Added the :attr:`exception` attribute."
msgstr "Добавлен атрибут :attr:`Exception`."

#: ../../library/unittest.rst:1031 ../../library/unittest.rst:1057
#: ../../library/unittest.rst:1098 ../../library/unittest.rst:1121
msgid "Added the *msg* keyword argument when used as a context manager."
msgstr ""
"Добавлен аргумент ключевого слова *msg* при использовании в качестве "
"менеджера контекста."

#: ../../library/unittest.rst:1038
msgid ""
"Like :meth:`assertRaises` but also tests that *regex* matches on the string "
"representation of the raised exception.  *regex* may be a regular expression "
"object or a string containing a regular expression suitable for use by :func:"
"`re.search`.  Examples::"
msgstr ""
"Подобно :meth:`assertRaises`, но также проверяет соответствие *regex* "
"строковому представлению возникшего исключения. *regex* может быть объектом "
"регулярного выражения или строкой, содержащей регулярное выражение, "
"подходящее для использования :func:`re.search`. Примеры::"

#: ../../library/unittest.rst:1043
msgid ""
"self.assertRaisesRegex(ValueError, \"invalid literal for.*XYZ'$\",\n"
"                       int, 'XYZ')"
msgstr ""
"self.assertRaisesRegex(ValueError, \"invalid literal for.*XYZ'$\",\n"
"                       int, 'XYZ')"

#: ../../library/unittest.rst:1046 ../../library/unittest.rst:1114
msgid "or::"
msgstr "или::"

#: ../../library/unittest.rst:1048
msgid ""
"with self.assertRaisesRegex(ValueError, 'literal'):\n"
"   int('XYZ')"
msgstr ""
"with self.assertRaisesRegex(ValueError, 'literal'):\n"
"   int('XYZ')"

#: ../../library/unittest.rst:1051
msgid "Added under the name ``assertRaisesRegexp``."
msgstr "Добавлен под названием «assertRaisesRegexp»."

#: ../../library/unittest.rst:1054
msgid "Renamed to :meth:`assertRaisesRegex`."
msgstr "Переименовано в :meth:`assertRaisesRegex`."

#: ../../library/unittest.rst:1064
msgid ""
"Test that a warning is triggered when *callable* is called with any "
"positional or keyword arguments that are also passed to :meth:"
"`assertWarns`.  The test passes if *warning* is triggered and fails if it "
"isn't.  Any exception is an error. To catch any of a group of warnings, a "
"tuple containing the warning classes may be passed as *warnings*."
msgstr ""
"Проверьте, что предупреждение выдается, когда *callable* вызывается с любыми "
"позиционными или ключевыми аргументами, которые также передаются в :meth:"
"`assertWarns`. Тест проходит успешно, если срабатывает *предупреждение*, и "
"завершается неудачей, если нет. Любое исключение является ошибкой. Чтобы "
"перехватить любое предупреждение из группы, кортеж, содержащий классы "
"предупреждений, можно передать как *предупреждения*."

#: ../../library/unittest.rst:1071
msgid ""
"If only the *warning* and possibly the *msg* arguments are given, return a "
"context manager so that the code under test can be written inline rather "
"than as a function::"
msgstr ""
"Если заданы только аргументы *warning* и, возможно, *msg*, верните диспетчер "
"контекста, чтобы тестируемый код можно было написать в строке, а не в виде "
"функции::"

#: ../../library/unittest.rst:1075
msgid ""
"with self.assertWarns(SomeWarning):\n"
"    do_something()"
msgstr ""
"with self.assertWarns(SomeWarning):\n"
"    do_something()"

#: ../../library/unittest.rst:1078
msgid ""
"When used as a context manager, :meth:`assertWarns` accepts the additional "
"keyword argument *msg*."
msgstr ""
"При использовании в качестве менеджера контекста :meth:`assertWarns` "
"принимает дополнительный аргумент ключевого слова *msg*."

#: ../../library/unittest.rst:1081
msgid ""
"The context manager will store the caught warning object in its :attr:"
"`warning` attribute, and the source line which triggered the warnings in "
"the :attr:`filename` and :attr:`lineno` attributes. This can be useful if "
"the intention is to perform additional checks on the warning caught::"
msgstr ""
"Менеджер контекста сохранит перехваченный объект предупреждения в своем "
"атрибуте :attr:`warning`, а исходную строку, вызвавшую предупреждение, в "
"атрибутах :attr:`filename` и :attr:`lineno`. Это может быть полезно, если "
"предполагается выполнить дополнительные проверки пойманного предупреждения:"

#: ../../library/unittest.rst:1087
msgid ""
"with self.assertWarns(SomeWarning) as cm:\n"
"    do_something()\n"
"\n"
"self.assertIn('myfile.py', cm.filename)\n"
"self.assertEqual(320, cm.lineno)"
msgstr ""
"with self.assertWarns(SomeWarning) as cm:\n"
"    do_something()\n"
"\n"
"self.assertIn('myfile.py', cm.filename)\n"
"self.assertEqual(320, cm.lineno)"

#: ../../library/unittest.rst:1093
msgid ""
"This method works regardless of the warning filters in place when it is "
"called."
msgstr ""
"Этот метод работает независимо от фильтров предупреждений, установленных при "
"его вызове."

#: ../../library/unittest.rst:1105
msgid ""
"Like :meth:`assertWarns` but also tests that *regex* matches on the message "
"of the triggered warning.  *regex* may be a regular expression object or a "
"string containing a regular expression suitable for use by :func:`re."
"search`.  Example::"
msgstr ""
"Подобно :meth:`assertWarns`, но также проверяет соответствие *regex* "
"сообщению сработавшего предупреждения. *regex* может быть объектом "
"регулярного выражения или строкой, содержащей регулярное выражение, "
"подходящее для использования :func:`re.search`. Пример::"

#: ../../library/unittest.rst:1110
msgid ""
"self.assertWarnsRegex(DeprecationWarning,\n"
"                      r'legacy_function\\(\\) is deprecated',\n"
"                      legacy_function, 'XYZ')"
msgstr ""
"self.assertWarnsRegex(DeprecationWarning, r'legacy_function\\(\\) устарела', "
"унаследованная_функция, 'XYZ')"

#: ../../library/unittest.rst:1116
msgid ""
"with self.assertWarnsRegex(RuntimeWarning, 'unsafe frobnicating'):\n"
"    frobnicate('/etc/passwd')"
msgstr ""
"с self.assertWarnsRegex(RuntimeWarning, «небезопасное запугивание»): "
"frobnicate('/etc/passwd')"

#: ../../library/unittest.rst:1126
msgid ""
"A context manager to test that at least one message is logged on the "
"*logger* or one of its children, with at least the given *level*."
msgstr ""
"Менеджер контекста для проверки того, что хотя бы одно сообщение "
"зарегистрировано в *регистраторе* или одном из его дочерних элементов, по "
"крайней мере, с заданным *уровнем*."

#: ../../library/unittest.rst:1130
msgid ""
"If given, *logger* should be a :class:`logging.Logger` object or a :class:"
"`str` giving the name of a logger.  The default is the root logger, which "
"will catch all messages that were not blocked by a non-propagating "
"descendent logger."
msgstr ""
"Если задано, *logger* должен быть объектом :class:`logging.Logger` или :"
"class:`str`, указывающим имя регистратора. По умолчанию используется "
"корневой регистратор, который будет перехватывать все сообщения, которые не "
"были заблокированы нераспространяющимся дочерним регистратором."

#: ../../library/unittest.rst:1135 ../../library/unittest.rst:1176
msgid ""
"If given, *level* should be either a numeric logging level or its string "
"equivalent (for example either ``\"ERROR\"`` or :const:`logging.ERROR`).  "
"The default is :const:`logging.INFO`."
msgstr ""
"Если задано, *logger* должен быть объектом :class:`logging.Logger` или :"
"class:`str`, указывающим имя регистратора. По умолчанию используется "
"корневой регистратор, который будет перехватывать все сообщения, которые не "
"были заблокированы нераспространяющимся дочерним регистратором."

#: ../../library/unittest.rst:1139
msgid ""
"The test passes if at least one message emitted inside the ``with`` block "
"matches the *logger* and *level* conditions, otherwise it fails."
msgstr ""
"Тест считается пройденным, если хотя бы одно сообщение, отправленное внутри "
"блока ``with``, соответствует условиям *logger* и *level*, в противном "
"случае он не пройден."

#: ../../library/unittest.rst:1142
msgid ""
"The object returned by the context manager is a recording helper which keeps "
"tracks of the matching log messages.  It has two attributes:"
msgstr ""
"Объект, возвращаемый диспетчером контекста, является помощником записи, "
"который отслеживает соответствующие сообщения журнала. Он имеет два атрибута:"

#: ../../library/unittest.rst:1148
msgid ""
"A list of :class:`logging.LogRecord` objects of the matching log messages."
msgstr ""
"Список объектов :class:`logging.LogRecord` соответствующих сообщений журнала."

#: ../../library/unittest.rst:1153
msgid ""
"A list of :class:`str` objects with the formatted output of matching "
"messages."
msgstr ""
"Список объектов :class:`str` с форматированным выводом соответствующих "
"сообщений."

#: ../../library/unittest.rst:1156
msgid "Example::"
msgstr "Пример::"

#: ../../library/unittest.rst:1158
msgid ""
"with self.assertLogs('foo', level='INFO') as cm:\n"
"    logging.getLogger('foo').info('first message')\n"
"    logging.getLogger('foo.bar').error('second message')\n"
"self.assertEqual(cm.output, ['INFO:foo:first message',\n"
"                             'ERROR:foo.bar:second message'])"
msgstr ""
"with self.assertLogs('foo', level='INFO') as cm:\n"
"    logging.getLogger('foo').info('first message')\n"
"    logging.getLogger('foo.bar').error('second message')\n"
"self.assertEqual(cm.output, ['INFO:foo:first message',\n"
"                             'ERROR:foo.bar:second message'])"

#: ../../library/unittest.rst:1168
msgid ""
"A context manager to test that no messages are logged on the *logger* or one "
"of its children, with at least the given *level*."
msgstr ""
"Менеджер контекста, проверяющий, что никакие сообщения не регистрируются в "
"*регистраторе* или одном из его дочерних элементов, по крайней мере, с "
"заданным *уровнем*."

#: ../../library/unittest.rst:1172
msgid ""
"If given, *logger* should be a :class:`logging.Logger` object or a :class:"
"`str` giving the name of a logger.  The default is the root logger, which "
"will catch all messages."
msgstr ""
"Если задано, *logger* должен быть объектом :class:`logging.Logger` или :"
"class:`str`, указывающим имя регистратора. По умолчанию используется "
"корневой регистратор, который будет перехватывать все сообщения."

#: ../../library/unittest.rst:1180
msgid ""
"Unlike :meth:`assertLogs`, nothing will be returned by the context manager."
msgstr ""
"В отличие от :meth:`assertLogs`, контекстный менеджер ничего не вернет."

#: ../../library/unittest.rst:1185
msgid ""
"There are also other methods used to perform more specific checks, such as:"
msgstr ""
"Существуют также другие методы, используемые для выполнения более конкретных "
"проверок, например:"

#: ../../library/unittest.rst:1190
msgid ":meth:`assertAlmostEqual(a, b) <TestCase.assertAlmostEqual>`"
msgstr ":meth:`assertAlmostEqual(a, b) <TestCase.assertAlmostEqual>`"

#: ../../library/unittest.rst:1190
msgid "``round(a-b, 7) == 0``"
msgstr "``round(a-b, 7) == 0``"

#: ../../library/unittest.rst:1193
msgid ":meth:`assertNotAlmostEqual(a, b) <TestCase.assertNotAlmostEqual>`"
msgstr ":meth:`assertNotAlmostEqual(a, b) <TestCase.assertNotAlmostEqual>`"

#: ../../library/unittest.rst:1193
msgid "``round(a-b, 7) != 0``"
msgstr "``round(a-b, 7) != 0``"

#: ../../library/unittest.rst:1196
msgid ":meth:`assertGreater(a, b) <TestCase.assertGreater>`"
msgstr ":meth:`assertGreater(a, b) <TestCase.assertGreater>`"

#: ../../library/unittest.rst:1196
msgid "``a > b``"
msgstr "``a > b``"

#: ../../library/unittest.rst:1199
msgid ":meth:`assertGreaterEqual(a, b) <TestCase.assertGreaterEqual>`"
msgstr ":meth:`assertGreaterEqual(a, b) <TestCase.assertGreaterEqual>`"

#: ../../library/unittest.rst:1199
msgid "``a >= b``"
msgstr "``a >= b``"

#: ../../library/unittest.rst:1202
msgid ":meth:`assertLess(a, b) <TestCase.assertLess>`"
msgstr ":meth:`assertLess(a, b) <TestCase.assertLess>`"

#: ../../library/unittest.rst:1202
msgid "``a < b``"
msgstr "``a < b``"

#: ../../library/unittest.rst:1205
msgid ":meth:`assertLessEqual(a, b) <TestCase.assertLessEqual>`"
msgstr ":meth:`assertLessEqual(a, b) <TestCase.assertLessEqual>`"

#: ../../library/unittest.rst:1205
msgid "``a <= b``"
msgstr "``a <= b``"

#: ../../library/unittest.rst:1208
msgid ":meth:`assertRegex(s, r) <TestCase.assertRegex>`"
msgstr ":meth:`assertRegex(s, r) <TestCase.assertRegex>`"

#: ../../library/unittest.rst:1208
msgid "``r.search(s)``"
msgstr "``r.search(s)``"

#: ../../library/unittest.rst:1211
msgid ":meth:`assertNotRegex(s, r) <TestCase.assertNotRegex>`"
msgstr ":meth:`assertNotRegex(s, r) <TestCase.assertNotRegex>`"

#: ../../library/unittest.rst:1211
msgid "``not r.search(s)``"
msgstr "``not r.search(s)``"

#: ../../library/unittest.rst:1214
msgid ":meth:`assertCountEqual(a, b) <TestCase.assertCountEqual>`"
msgstr ":meth:`assertCountEqual(a, b) <TestCase.assertCountEqual>`"

#: ../../library/unittest.rst:1214
msgid ""
"*a* and *b* have the same elements in the same number, regardless of their "
"order."
msgstr ""
"*a* и *b* содержат одинаковые элементы в одном и том же номере, независимо "
"от их порядка."

#: ../../library/unittest.rst:1223
msgid ""
"Test that *first* and *second* are approximately (or not approximately) "
"equal by computing the difference, rounding to the given number of decimal "
"*places* (default 7), and comparing to zero.  Note that these methods round "
"the values to the given number of *decimal places* (i.e. like the :func:"
"`round` function) and not *significant digits*."
msgstr ""
"Проверьте, что *первый* и *второй* приблизительно (или не приблизительно) "
"равны, вычислив разницу, округлив ее до заданного количества десятичных "
"*знаков* (по умолчанию 7) и сравнив ее с нулем. Обратите внимание, что эти "
"методы округляют значения до заданного количества *десятичных знаков* (т.е. "
"как функция :func:`round`), а не до *значащих цифр*."

#: ../../library/unittest.rst:1229
msgid ""
"If *delta* is supplied instead of *places* then the difference between "
"*first* and *second* must be less or equal to (or greater than) *delta*."
msgstr ""
"Если вместо *мест* указано *дельта*, то разница между *первым* и *вторым* "
"должна быть меньше или равна (или больше) *дельта*."

#: ../../library/unittest.rst:1232
msgid "Supplying both *delta* and *places* raises a :exc:`TypeError`."
msgstr "Указание *delta* и *places* вызывает ошибку :exc:`TypeError`."

#: ../../library/unittest.rst:1234
msgid ""
":meth:`assertAlmostEqual` automatically considers almost equal objects that "
"compare equal.  :meth:`assertNotAlmostEqual` automatically fails if the "
"objects compare equal.  Added the *delta* keyword argument."
msgstr ""
":meth:`assertAlmostEqual` автоматически считает почти равные объекты, "
"которые сравниваются равными. :meth:`assertNotAlmostEqual` автоматически "
"завершается с ошибкой, если объекты сравниваются равными. Добавлен аргумент "
"ключевого слова *delta*."

#: ../../library/unittest.rst:1245
msgid ""
"Test that *first* is respectively >, >=, < or <= than *second* depending on "
"the method name.  If not, the test will fail::"
msgstr ""
"Проверьте, что *first* равен соответственно >, >=, < или <=, чем * Second*, "
"в зависимости от имени метода. В противном случае тест завершится неудачно::"

#: ../../library/unittest.rst:1248
msgid ""
">>> self.assertGreaterEqual(3, 4)\n"
"AssertionError: \"3\" unexpectedly not greater than or equal to \"4\""
msgstr ""
">>> self.assertGreaterEqual(3, 4)\n"
"AssertionError: \"3\" unexpectedly not greater than or equal to \"4\""

#: ../../library/unittest.rst:1257
msgid ""
"Test that a *regex* search matches (or does not match) *text*.  In case of "
"failure, the error message will include the pattern and the *text* (or the "
"pattern and the part of *text* that unexpectedly matched).  *regex* may be a "
"regular expression object or a string containing a regular expression "
"suitable for use by :func:`re.search`."
msgstr ""
"Проверьте, что поиск по *регулярному* выражению* соответствует (или не "
"соответствует) *тексту*. В случае неудачи сообщение об ошибке будет "
"содержать шаблон и *текст* (или шаблон и часть *текста*, которые неожиданно "
"совпали). *regex* может быть объектом регулярного выражения или строкой, "
"содержащей регулярное выражение, подходящее для использования :func:`re."
"search`."

#: ../../library/unittest.rst:1263
msgid "Added under the name ``assertRegexpMatches``."
msgstr "Добавлен под названием «assertRegexpMatches»."

#: ../../library/unittest.rst:1265
msgid ""
"The method ``assertRegexpMatches()`` has been renamed to :meth:`."
"assertRegex`."
msgstr ""
"Метод ``assertRegexpMatches()`` был переименован в :meth:`.assertRegex`."

#: ../../library/unittest.rst:1268
msgid ":meth:`.assertNotRegex`."
msgstr ":meth:`.assertNotRegex`."

#: ../../library/unittest.rst:1274
msgid ""
"Test that sequence *first* contains the same elements as *second*, "
"regardless of their order. When they don't, an error message listing the "
"differences between the sequences will be generated."
msgstr ""
"Проверьте, что последовательность *first* содержит те же элементы, что и * "
"Second*, независимо от их порядка. Если этого не произойдет, будет "
"сгенерировано сообщение об ошибке со списком различий между "
"последовательностями."

#: ../../library/unittest.rst:1278
msgid ""
"Duplicate elements are *not* ignored when comparing *first* and *second*. It "
"verifies whether each element has the same count in both sequences. "
"Equivalent to: ``assertEqual(Counter(list(first)), Counter(list(second)))`` "
"but works with sequences of unhashable objects as well."
msgstr ""
"Повторяющиеся элементы *не* игнорируются при сравнении *первого* и "
"*второго*. Он проверяет, имеет ли каждый элемент одинаковое количество в "
"обеих последовательностях. Эквивалентно: ``assertEqual(Counter(list(first)), "
"Counter(list( Second)))``, но также работает с последовательностями "
"нехэшируемых объектов."

#: ../../library/unittest.rst:1289
msgid ""
"The :meth:`assertEqual` method dispatches the equality check for objects of "
"the same type to different type-specific methods.  These methods are already "
"implemented for most of the built-in types, but it's also possible to "
"register new methods using :meth:`addTypeEqualityFunc`:"
msgstr ""
"Метод :meth:`assertEqual` отправляет проверку равенства объектов одного и "
"того же типа различным методам, зависящим от типа. Эти методы уже "
"реализованы для большинства встроенных типов, но также можно "
"зарегистрировать новые методы с помощью :meth:`addTypeEqualityFunc`:"

#: ../../library/unittest.rst:1296
msgid ""
"Registers a type-specific method called by :meth:`assertEqual` to check if "
"two objects of exactly the same *typeobj* (not subclasses) compare equal.  "
"*function* must take two positional arguments and a third msg=None keyword "
"argument just as :meth:`assertEqual` does.  It must raise :data:`self."
"failureException(msg) <failureException>` when inequality between the first "
"two parameters is detected -- possibly providing useful information and "
"explaining the inequalities in details in the error message."
msgstr ""
"Регистрирует специфичный для типа метод, вызываемый :meth:`assertEqual`, "
"чтобы проверить, равны ли два объекта одного и того же *typeobj* (не "
"подклассов). *функция* должна принимать два позиционных аргумента и третий "
"аргумент ключевого слова msg=None, как и :meth:`assertEqual`. Он должен "
"вызвать :data:`self.failureException(msg) <failureException>` при "
"обнаружении неравенства между первыми двумя параметрами - возможно, "
"предоставляя полезную информацию и подробно объясняя неравенства в сообщении "
"об ошибке."

#: ../../library/unittest.rst:1307
msgid ""
"The list of type-specific methods automatically used by :meth:`~TestCase."
"assertEqual` are summarized in the following table.  Note that it's usually "
"not necessary to invoke these methods directly."
msgstr ""
"Список методов для конкретного типа, автоматически используемых :meth:"
"`~TestCase.assertEqual`, обобщен в следующей таблице. Обратите внимание, что "
"обычно нет необходимости вызывать эти методы напрямую."

#: ../../library/unittest.rst:1312
msgid "Used to compare"
msgstr "Используется для сравнения"

#: ../../library/unittest.rst:1314
msgid ":meth:`assertMultiLineEqual(a, b) <TestCase.assertMultiLineEqual>`"
msgstr ":meth:`assertMultiLineEqual(a, b) <TestCase.assertMultiLineEqual>`"

#: ../../library/unittest.rst:1314
msgid "strings"
msgstr "строки"

#: ../../library/unittest.rst:1317
msgid ":meth:`assertSequenceEqual(a, b) <TestCase.assertSequenceEqual>`"
msgstr ":meth:`assertSequenceEqual(a, b) <TestCase.assertSequenceEqual>`"

#: ../../library/unittest.rst:1317
msgid "sequences"
msgstr "последовательности"

#: ../../library/unittest.rst:1320
msgid ":meth:`assertListEqual(a, b) <TestCase.assertListEqual>`"
msgstr ":meth:`assertListEqual(a, b) <TestCase.assertListEqual>`"

#: ../../library/unittest.rst:1320
msgid "lists"
msgstr "списки"

#: ../../library/unittest.rst:1323
msgid ":meth:`assertTupleEqual(a, b) <TestCase.assertTupleEqual>`"
msgstr ":meth:`assertTupleEqual(a, b) <TestCase.assertTupleEqual>`"

#: ../../library/unittest.rst:1323
msgid "tuples"
msgstr "кортежи"

#: ../../library/unittest.rst:1326
msgid ":meth:`assertSetEqual(a, b) <TestCase.assertSetEqual>`"
msgstr ":meth:`assertSetEqual(a, b) <TestCase.assertSetEqual>`"

#: ../../library/unittest.rst:1326
msgid "sets or frozensets"
msgstr "наборы или замороженные наборы"

#: ../../library/unittest.rst:1329
msgid ":meth:`assertDictEqual(a, b) <TestCase.assertDictEqual>`"
msgstr ":meth:`assertDictEqual(a, b) <TestCase.assertDictEqual>`"

#: ../../library/unittest.rst:1329
msgid "dicts"
msgstr "словари"

#: ../../library/unittest.rst:1337
msgid ""
"Test that the multiline string *first* is equal to the string *second*. When "
"not equal a diff of the two strings highlighting the differences will be "
"included in the error message. This method is used by default when comparing "
"strings with :meth:`assertEqual`."
msgstr ""
"Проверьте, что многострочная строка *first* равна строке * Second*. Если они "
"не равны, в сообщение об ошибке будет включена разница между двумя строками, "
"подчеркивающими различия. Этот метод используется по умолчанию при сравнении "
"строк с помощью :meth:`assertEqual`."

#: ../../library/unittest.rst:1347
msgid ""
"Tests that two sequences are equal.  If a *seq_type* is supplied, both "
"*first* and *second* must be instances of *seq_type* or a failure will be "
"raised.  If the sequences are different an error message is constructed that "
"shows the difference between the two."
msgstr ""
"Проверяет, что две последовательности равны. Если указан *seq_type*, *first* "
"и * Second* должны быть экземплярами *seq_type*, иначе будет выдана ошибка. "
"Если последовательности различаются, создается сообщение об ошибке, "
"показывающее разницу между ними."

#: ../../library/unittest.rst:1352
msgid ""
"This method is not called directly by :meth:`assertEqual`, but it's used to "
"implement :meth:`assertListEqual` and :meth:`assertTupleEqual`."
msgstr ""
"Этот метод не вызывается напрямую из :meth:`assertEqual`, но он используется "
"для реализации :meth:`assertListEqual` и :meth:`assertTupleEqual`."

#: ../../library/unittest.rst:1362
msgid ""
"Tests that two lists or tuples are equal.  If not, an error message is "
"constructed that shows only the differences between the two.  An error is "
"also raised if either of the parameters are of the wrong type. These methods "
"are used by default when comparing lists or tuples with :meth:`assertEqual`."
msgstr ""
"Проверяет, что два списка или кортежа равны. В противном случае создается "
"сообщение об ошибке, показывающее только различия между ними. Ошибка также "
"возникает, если какой-либо из параметров имеет неверный тип. Эти методы "
"используются по умолчанию при сравнении списков или кортежей с помощью :meth:"
"`assertEqual`."

#: ../../library/unittest.rst:1373
msgid ""
"Tests that two sets are equal.  If not, an error message is constructed that "
"lists the differences between the sets.  This method is used by default when "
"comparing sets or frozensets with :meth:`assertEqual`."
msgstr ""
"Проверяет, что два набора равны. В противном случае создается сообщение об "
"ошибке, в котором перечислены различия между наборами. Этот метод "
"используется по умолчанию при сравнении наборов или замороженных наборов с "
"помощью :meth:`assertEqual`."

#: ../../library/unittest.rst:1377
msgid ""
"Fails if either of *first* or *second* does not have a :meth:`set."
"difference` method."
msgstr ""
"Ошибка, если ни один из *first* или * Second* не имеет метода :meth:`set."
"difference`."

#: ../../library/unittest.rst:1385
msgid ""
"Test that two dictionaries are equal.  If not, an error message is "
"constructed that shows the differences in the dictionaries. This method will "
"be used by default to compare dictionaries in calls to :meth:`assertEqual`."
msgstr ""
"Проверьте, что два словаря равны. Если нет, создается сообщение об ошибке, "
"показывающее различия в словарях. Этот метод будет использоваться по "
"умолчанию для сравнения словарей при вызовах :meth:`assertEqual`."

#: ../../library/unittest.rst:1396
msgid ""
"Finally the :class:`TestCase` provides the following methods and attributes:"
msgstr "Наконец, :class:`TestCase` предоставляет следующие методы и атрибуты:"

#: ../../library/unittest.rst:1401
msgid ""
"Signals a test failure unconditionally, with *msg* or ``None`` for the error "
"message."
msgstr ""
"Безоговорочно сигнализирует о сбое теста, используя *msg* или ``None`` для "
"сообщения об ошибке."

#: ../../library/unittest.rst:1407
msgid ""
"This class attribute gives the exception raised by the test method.  If a "
"test framework needs to use a specialized exception, possibly to carry "
"additional information, it must subclass this exception in order to \"play "
"fair\" with the framework.  The initial value of this attribute is :exc:"
"`AssertionError`."
msgstr ""
"Этот атрибут класса выдает исключение, вызванное тестовым методом. Если "
"среда тестирования должна использовать специализированное исключение, "
"возможно, для передачи дополнительной информации, она должна создать "
"подкласс этого исключения, чтобы «играть честно» с платформой. Начальное "
"значение этого атрибута — :exc:`AssertionError`."

#: ../../library/unittest.rst:1416
msgid ""
"This class attribute determines what happens when a custom failure message "
"is passed as the msg argument to an assertXYY call that fails. ``True`` is "
"the default value. In this case, the custom message is appended to the end "
"of the standard failure message. When set to ``False``, the custom message "
"replaces the standard message."
msgstr ""
"Этот атрибут класса определяет, что происходит, когда пользовательское "
"сообщение об ошибке передается в качестве аргумента msg в вызов AssertXYY, "
"который завершился неудачей. ``True`` — значение по умолчанию. В этом случае "
"специальное сообщение добавляется в конец стандартного сообщения об ошибке. "
"Если установлено значение «False», пользовательское сообщение заменяет "
"стандартное сообщение."

#: ../../library/unittest.rst:1422
msgid ""
"The class setting can be overridden in individual test methods by assigning "
"an instance attribute, self.longMessage, to ``True`` or ``False`` before "
"calling the assert methods."
msgstr ""
"Параметр класса можно переопределить в отдельных методах тестирования, "
"присвоив атрибуту экземпляра self.longMessage значение True или False перед "
"вызовом методов утверждения."

#: ../../library/unittest.rst:1426
msgid "The class setting gets reset before each test call."
msgstr "Настройка класса сбрасывается перед каждым тестовым вызовом."

#: ../../library/unittest.rst:1433
msgid ""
"This attribute controls the maximum length of diffs output by assert methods "
"that report diffs on failure. It defaults to 80*8 characters. Assert methods "
"affected by this attribute are :meth:`assertSequenceEqual` (including all "
"the sequence comparison methods that delegate to it), :meth:"
"`assertDictEqual` and :meth:`assertMultiLineEqual`."
msgstr ""
"Этот атрибут управляет максимальной длиной вывода различий с помощью методов "
"утверждения, которые сообщают о различиях в случае сбоя. По умолчанию он "
"равен 80*8 символов. Методы подтверждения, на которые влияет этот атрибут: :"
"meth:`assertSequenceEqual` (включая все методы сравнения "
"последовательностей, которые ему делегируют), :meth:`assertDictEqual` и :"
"meth:`assertMultiLineEqual`."

#: ../../library/unittest.rst:1440
msgid ""
"Setting ``maxDiff`` to ``None`` means that there is no maximum length of "
"diffs."
msgstr ""
"Установка ``maxDiff`` в ``None`` означает, что не существует максимальной "
"длины различий."

#: ../../library/unittest.rst:1446
msgid ""
"Testing frameworks can use the following methods to collect information on "
"the test:"
msgstr ""
"Платформы тестирования могут использовать следующие методы для сбора "
"информации о тесте:"

#: ../../library/unittest.rst:1452
msgid ""
"Return the number of tests represented by this test object.  For :class:"
"`TestCase` instances, this will always be ``1``."
msgstr ""
"Возвращает количество тестов, представленных этим тестовым объектом. Для "
"экземпляров :class:`TestCase` это всегда будет ``1``."

#: ../../library/unittest.rst:1458
msgid ""
"Return an instance of the test result class that should be used for this "
"test case class (if no other result instance is provided to the :meth:`run` "
"method)."
msgstr ""
"Возвращает экземпляр класса результата теста, который следует использовать "
"для этого класса тестового примера (если методу :meth:`run` не предоставлен "
"другой экземпляр результата)."

#: ../../library/unittest.rst:1462
msgid ""
"For :class:`TestCase` instances, this will always be an instance of :class:"
"`TestResult`; subclasses of :class:`TestCase` should override this as "
"necessary."
msgstr ""
"Для экземпляров :class:`TestCase` это всегда будет экземпляр :class:"
"`TestResult`; подклассы :class:`TestCase` должны переопределять это при "
"необходимости."

#: ../../library/unittest.rst:1469
msgid ""
"Return a string identifying the specific test case.  This is usually the "
"full name of the test method, including the module and class name."
msgstr ""
"Возвращает строку, идентифицирующую конкретный тестовый пример. Обычно это "
"полное имя метода тестирования, включая имя модуля и класса."

#: ../../library/unittest.rst:1475
msgid ""
"Returns a description of the test, or ``None`` if no description has been "
"provided.  The default implementation of this method returns the first line "
"of the test method's docstring, if available, or ``None``."
msgstr ""
"Возвращает описание теста или None, если описание не было предоставлено. "
"Реализация этого метода по умолчанию возвращает первую строку документации "
"тестового метода, если она доступна, или «Нет»."

#: ../../library/unittest.rst:1480
msgid ""
"In 3.1 this was changed to add the test name to the short description even "
"in the presence of a docstring.  This caused compatibility issues with "
"unittest extensions and adding the test name was moved to the :class:"
"`TextTestResult` in Python 3.2."
msgstr ""
"В версии 3.1 это было изменено: к краткому описанию добавлялось имя теста "
"даже при наличии строки документации. Это вызвало проблемы совместимости с "
"расширениями unittest, и добавление имени теста было перенесено в :class:"
"`TextTestResult` в Python 3.2."

#: ../../library/unittest.rst:1489
msgid ""
"Add a function to be called after :meth:`tearDown` to cleanup resources used "
"during the test. Functions will be called in reverse order to the order they "
"are added (:abbr:`LIFO (last-in, first-out)`).  They are called with any "
"arguments and keyword arguments passed into :meth:`addCleanup` when they are "
"added."
msgstr ""
"Добавьте функцию, которая будет вызываться после :meth:`tearDown` для "
"очистки ресурсов, использованных во время теста. Функции будут вызываться в "
"порядке, обратном порядку их добавления (:abbr:`LIFO (last-in, first-out)`). "
"Они вызываются с любыми аргументами и ключевыми словами, передаваемыми в :"
"meth:`addCleanup` при их добавлении."

#: ../../library/unittest.rst:1495
msgid ""
"If :meth:`setUp` fails, meaning that :meth:`tearDown` is not called, then "
"any cleanup functions added will still be called."
msgstr ""
"Если :meth:`setUp` завершается сбоем, то есть :meth:`tearDown` не "
"вызывается, то любые добавленные функции очистки все равно будут вызываться."

#: ../../library/unittest.rst:1503
msgid ""
"Enter the supplied :term:`context manager`.  If successful, also add its :"
"meth:`~object.__exit__` method as a cleanup function by :meth:`addCleanup` "
"and return the result of the :meth:`~object.__enter__` method."
msgstr ""
"Введите предоставленный :term:`контекстный менеджер`. В случае успеха также "
"добавьте его метод :meth:`~object.__exit__` в качестве функции очистки с "
"помощью :meth:`addCleanup` и верните результат метода :meth:`~object."
"__enter__`."

#: ../../library/unittest.rst:1513
msgid ""
"This method is called unconditionally after :meth:`tearDown`, or after :meth:"
"`setUp` if :meth:`setUp` raises an exception."
msgstr ""
"Этот метод вызывается безоговорочно после :meth:`tearDown` или после :meth:"
"`setUp`, если :meth:`setUp` вызывает исключение."

#: ../../library/unittest.rst:1516
msgid ""
"It is responsible for calling all the cleanup functions added by :meth:"
"`addCleanup`. If you need cleanup functions to be called *prior* to :meth:"
"`tearDown` then you can call :meth:`doCleanups` yourself."
msgstr ""
"Он отвечает за вызов всех функций очистки, добавленных :meth:`addCleanup`. "
"Если вам нужно, чтобы функции очистки вызывались *до* :meth:`tearDown`, вы "
"можете вызвать :meth:`doCleanups` самостоятельно."

#: ../../library/unittest.rst:1521
msgid ""
":meth:`doCleanups` pops methods off the stack of cleanup functions one at a "
"time, so it can be called at any time."
msgstr ""
":meth:`doCleanups` извлекает методы из стека функций очистки по одному, "
"поэтому его можно вызвать в любое время."

#: ../../library/unittest.rst:1529
msgid ""
"Add a function to be called after :meth:`tearDownClass` to cleanup resources "
"used during the test class. Functions will be called in reverse order to the "
"order they are added (:abbr:`LIFO (last-in, first-out)`). They are called "
"with any arguments and keyword arguments passed into :meth:`addClassCleanup` "
"when they are added."
msgstr ""
"Добавьте функцию, которая будет вызываться после :meth:`tearDownClass` для "
"очистки ресурсов, используемых во время тестового класса. Функции будут "
"вызываться в порядке, обратном порядку их добавления (:abbr:`LIFO (last-in, "
"first-out)`). Они вызываются с любыми аргументами и ключевыми словами, "
"передаваемыми в :meth:`addClassCleanup` при их добавлении."

#: ../../library/unittest.rst:1535
msgid ""
"If :meth:`setUpClass` fails, meaning that :meth:`tearDownClass` is not "
"called, then any cleanup functions added will still be called."
msgstr ""
"Если :meth:`setUpClass` завершается сбоем, то есть :meth:`tearDownClass` не "
"вызывается, то любые добавленные функции очистки все равно будут вызываться."

#: ../../library/unittest.rst:1543
msgid ""
"Enter the supplied :term:`context manager`.  If successful, also add its :"
"meth:`~object.__exit__` method as a cleanup function by :meth:"
"`addClassCleanup` and return the result of the :meth:`~object.__enter__` "
"method."
msgstr ""
"Введите предоставленный :term:`контекстный менеджер`. В случае успеха также "
"добавьте его метод :meth:`~object.__exit__` в качестве функции очистки с "
"помощью :meth:`addClassCleanup` и верните результат метода :meth:`~object."
"__enter__`."

#: ../../library/unittest.rst:1553
msgid ""
"This method is called unconditionally after :meth:`tearDownClass`, or after :"
"meth:`setUpClass` if :meth:`setUpClass` raises an exception."
msgstr ""
"Этот метод вызывается безоговорочно после :meth:`tearDownClass` или после :"
"meth:`setUpClass`, если :meth:`setUpClass` вызывает исключение."

#: ../../library/unittest.rst:1556
msgid ""
"It is responsible for calling all the cleanup functions added by :meth:"
"`addClassCleanup`. If you need cleanup functions to be called *prior* to :"
"meth:`tearDownClass` then you can call :meth:`doClassCleanups` yourself."
msgstr ""
"Он отвечает за вызов всех функций очистки, добавленных :meth:"
"`addClassCleanup`. Если вам нужно, чтобы функции очистки вызывались *до* :"
"meth:`tearDownClass`, вы можете вызвать :meth:`doClassCleanups` "
"самостоятельно."

#: ../../library/unittest.rst:1561
msgid ""
":meth:`doClassCleanups` pops methods off the stack of cleanup functions one "
"at a time, so it can be called at any time."
msgstr ""
":meth:`doClassCleanups` извлекает методы из стека функций очистки по одному, "
"поэтому его можно вызвать в любое время."

#: ../../library/unittest.rst:1569
msgid ""
"This class provides an API similar to :class:`TestCase` and also accepts "
"coroutines as test functions."
msgstr ""
"Этот класс предоставляет API, аналогичный :class:`TestCase`, а также "
"принимает сопрограммы в качестве тестовых функций."

#: ../../library/unittest.rst:1577
msgid ""
"Method called to prepare the test fixture. This is called after :meth:"
"`setUp`. This is called immediately before calling the test method; other "
"than :exc:`AssertionError` or :exc:`SkipTest`, any exception raised by this "
"method will be considered an error rather than a test failure. The default "
"implementation does nothing."
msgstr ""
"Метод, вызываемый для подготовки тестового приспособления. Это вызывается "
"после :meth:`setUp`. Он вызывается непосредственно перед вызовом тестового "
"метода; кроме :exc:`AssertionError` или :exc:`SkipTest`, любое исключение, "
"вызванное этим методом, будет считаться ошибкой, а не провалом теста. "
"Реализация по умолчанию ничего не делает."

#: ../../library/unittest.rst:1586
msgid ""
"Method called immediately after the test method has been called and the "
"result recorded.  This is called before :meth:`tearDown`. This is called "
"even if the test method raised an exception, so the implementation in "
"subclasses may need to be particularly careful about checking internal "
"state.  Any exception, other than :exc:`AssertionError` or :exc:`SkipTest`, "
"raised by this method will be considered an additional error rather than a "
"test failure (thus increasing the total number of reported errors). This "
"method will only be called if the :meth:`asyncSetUp` succeeds, regardless of "
"the outcome of the test method. The default implementation does nothing."
msgstr ""
"Метод вызывается сразу после вызова тестового метода и записи результата. "
"Это вызывается перед :meth:`tearDown`. Он вызывается, даже если тестовый "
"метод вызвал исключение, поэтому при реализации в подклассах может "
"потребоваться особая осторожность при проверке внутреннего состояния. Любое "
"исключение, кроме :exc:`AssertionError` или :exc:`SkipTest`, вызванное этим "
"методом, будет считаться дополнительной ошибкой, а не сбоем теста (таким "
"образом увеличивая общее количество зарегистрированных ошибок). Этот метод "
"будет вызываться только в том случае, если :meth:`asyncSetUp` завершится "
"успешно, независимо от результата метода тестирования. Реализация по "
"умолчанию ничего не делает."

#: ../../library/unittest.rst:1598
msgid "This method accepts a coroutine that can be used as a cleanup function."
msgstr ""
"Этот метод принимает сопрограмму, которую можно использовать в качестве "
"функции очистки."

#: ../../library/unittest.rst:1603
msgid ""
"Enter the supplied :term:`asynchronous context manager`.  If successful, "
"also add its :meth:`~object.__aexit__` method as a cleanup function by :meth:"
"`addAsyncCleanup` and return the result of the :meth:`~object.__aenter__` "
"method."
msgstr ""
"Введите предоставленный :term:`асинхронный контекстный менеджер`. В случае "
"успеха также добавьте его метод :meth:`~object.__aexit__` в качестве функции "
"очистки с помощью :meth:`addAsyncCleanup` и верните результат метода :meth:"
"`~object.__aenter__`."

#: ../../library/unittest.rst:1613
msgid ""
"Sets up a new event loop to run the test, collecting the result into the :"
"class:`TestResult` object passed as *result*.  If *result* is omitted or "
"``None``, a temporary result object is created (by calling the :meth:"
"`defaultTestResult` method) and used. The result object is returned to :meth:"
"`run`'s caller. At the end of the test all the tasks in the event loop are "
"cancelled."
msgstr ""
"Устанавливает новый цикл событий для запуска теста, собирая результат в "
"объект :class:`TestResult`, передаваемый как *result*. Если *result* опущен "
"или ``None``, создается временный объект результата (путем вызова метода :"
"meth:`defaultTestResult`) и используется. Объект результата возвращается "
"вызывающей стороне :meth:`run`. В конце теста все задачи в цикле событий "
"отменяются."

#: ../../library/unittest.rst:1621
msgid "An example illustrating the order::"
msgstr "Пример, иллюстрирующий порядок::"

#: ../../library/unittest.rst:1623
msgid ""
"from unittest import IsolatedAsyncioTestCase\n"
"\n"
"events = []\n"
"\n"
"\n"
"class Test(IsolatedAsyncioTestCase):\n"
"\n"
"\n"
"    def setUp(self):\n"
"        events.append(\"setUp\")\n"
"\n"
"    async def asyncSetUp(self):\n"
"        self._async_connection = await AsyncConnection()\n"
"        events.append(\"asyncSetUp\")\n"
"\n"
"    async def test_response(self):\n"
"        events.append(\"test_response\")\n"
"        response = await self._async_connection.get(\"https://example."
"com\")\n"
"        self.assertEqual(response.status_code, 200)\n"
"        self.addAsyncCleanup(self.on_cleanup)\n"
"\n"
"    def tearDown(self):\n"
"        events.append(\"tearDown\")\n"
"\n"
"    async def asyncTearDown(self):\n"
"        await self._async_connection.close()\n"
"        events.append(\"asyncTearDown\")\n"
"\n"
"    async def on_cleanup(self):\n"
"        events.append(\"cleanup\")\n"
"\n"
"if __name__ == \"__main__\":\n"
"    unittest.main()"
msgstr ""
"from unittest import IsolatedAsyncioTestCase\n"
"\n"
"events = []\n"
"\n"
"\n"
"class Test(IsolatedAsyncioTestCase):\n"
"\n"
"\n"
"    def setUp(self):\n"
"        events.append(\"setUp\")\n"
"\n"
"    async def asyncSetUp(self):\n"
"        self._async_connection = await AsyncConnection()\n"
"        events.append(\"asyncSetUp\")\n"
"\n"
"    async def test_response(self):\n"
"        events.append(\"test_response\")\n"
"        response = await self._async_connection.get(\"https://example."
"com\")\n"
"        self.assertEqual(response.status_code, 200)\n"
"        self.addAsyncCleanup(self.on_cleanup)\n"
"\n"
"    def tearDown(self):\n"
"        events.append(\"tearDown\")\n"
"\n"
"    async def asyncTearDown(self):\n"
"        await self._async_connection.close()\n"
"        events.append(\"asyncTearDown\")\n"
"\n"
"    async def on_cleanup(self):\n"
"        events.append(\"cleanup\")\n"
"\n"
"if __name__ == \"__main__\":\n"
"    unittest.main()"

#: ../../library/unittest.rst:1657
msgid ""
"After running the test, ``events`` would contain ``[\"setUp\", "
"\"asyncSetUp\", \"test_response\", \"asyncTearDown\", \"tearDown\", "
"\"cleanup\"]``."
msgstr ""
"После запуска теста ``events`` будет содержать ``[\"setUp\", \"asyncSetUp\", "
"\"test_response\", \"asyncTearDown\", \"tearDown\", \"cleanup\"]``."

#: ../../library/unittest.rst:1662
msgid ""
"This class implements the portion of the :class:`TestCase` interface which "
"allows the test runner to drive the test, but does not provide the methods "
"which test code can use to check and report errors.  This is used to create "
"test cases using legacy test code, allowing it to be integrated into a :mod:"
"`unittest`-based test framework."
msgstr ""
"Этот класс реализует часть интерфейса :class:`TestCase`, которая позволяет "
"исполнителю теста управлять тестом, но не предоставляет методы, которые "
"тестовый код может использовать для проверки и сообщения об ошибках. Это "
"используется для создания тестовых примеров с использованием устаревшего "
"тестового кода, что позволяет интегрировать его в тестовую среду на основе :"
"mod:`unittest`."

#: ../../library/unittest.rst:1672
msgid "Grouping tests"
msgstr "Группировка тестов"

#: ../../library/unittest.rst:1676
msgid ""
"This class represents an aggregation of individual test cases and test "
"suites. The class presents the interface needed by the test runner to allow "
"it to be run as any other test case.  Running a :class:`TestSuite` instance "
"is the same as iterating over the suite, running each test individually."
msgstr ""
"Этот класс представляет собой совокупность отдельных тестовых примеров и "
"наборов тестов. Класс представляет интерфейс, необходимый средству запуска "
"тестов, чтобы его можно было запускать как любой другой тестовый пример. "
"Запуск экземпляра :class:`TestSuite` аналогичен перебору пакета, при котором "
"каждый тест выполняется отдельно."

#: ../../library/unittest.rst:1681
msgid ""
"If *tests* is given, it must be an iterable of individual test cases or "
"other test suites that will be used to build the suite initially. Additional "
"methods are provided to add test cases and suites to the collection later on."
msgstr ""
"Если указано *tests*, это должна быть итерация отдельных тестовых случаев "
"или других наборов тестов, которые будут использоваться для первоначального "
"создания набора. Предоставляются дополнительные методы для последующего "
"добавления тестовых примеров и наборов в коллекцию."

#: ../../library/unittest.rst:1685
msgid ""
":class:`TestSuite` objects behave much like :class:`TestCase` objects, "
"except they do not actually implement a test.  Instead, they are used to "
"aggregate tests into groups of tests that should be run together. Some "
"additional methods are available to add tests to :class:`TestSuite` "
"instances:"
msgstr ""
"Объекты :class:`TestSuite` ведут себя так же, как объекты :class:`TestCase`, "
"за исключением того, что они фактически не реализуют тест. Вместо этого они "
"используются для объединения тестов в группы тестов, которые следует "
"запускать вместе. Доступны некоторые дополнительные методы для добавления "
"тестов в экземпляры :class:`TestSuite`:"

#: ../../library/unittest.rst:1693
msgid "Add a :class:`TestCase` or :class:`TestSuite` to the suite."
msgstr "Добавьте в комплект :class:`TestCase` или :class:`TestSuite`."

#: ../../library/unittest.rst:1698
msgid ""
"Add all the tests from an iterable of :class:`TestCase` and :class:"
"`TestSuite` instances to this test suite."
msgstr ""
"Добавьте в этот набор тестов все тесты из итерации экземпляров :class:"
"`TestCase` и :class:`TestSuite`."

#: ../../library/unittest.rst:1701
msgid ""
"This is equivalent to iterating over *tests*, calling :meth:`addTest` for "
"each element."
msgstr ""
"Это эквивалентно перебору *tests* с вызовом :meth:`addTest` для каждого "
"элемента."

#: ../../library/unittest.rst:1704
msgid ":class:`TestSuite` shares the following methods with :class:`TestCase`:"
msgstr ":class:`TestSuite` разделяет с :class:`TestCase` следующие методы:"

#: ../../library/unittest.rst:1709
msgid ""
"Run the tests associated with this suite, collecting the result into the "
"test result object passed as *result*.  Note that unlike :meth:`TestCase."
"run`, :meth:`TestSuite.run` requires the result object to be passed in."
msgstr ""
"Запустите тесты, связанные с этим набором, собрав результаты в объект "
"результата теста, передаваемый как *result*. Обратите внимание, что в "
"отличие от :meth:`TestCase.run`, :meth:`TestSuite.run` требует передачи "
"объекта результата."

#: ../../library/unittest.rst:1717
msgid ""
"Run the tests associated with this suite without collecting the result. This "
"allows exceptions raised by the test to be propagated to the caller and can "
"be used to support running tests under a debugger."
msgstr ""
"Запустите тесты, связанные с этим пакетом, без сбора результатов. Это "
"позволяет распространять исключения, вызванные тестом, на вызывающую сторону "
"и может использоваться для поддержки запуска тестов в отладчике."

#: ../../library/unittest.rst:1724
msgid ""
"Return the number of tests represented by this test object, including all "
"individual tests and sub-suites."
msgstr ""
"Возвращает количество тестов, представленных этим тестовым объектом, включая "
"все отдельные тесты и поднаборы."

#: ../../library/unittest.rst:1730
msgid ""
"Tests grouped by a :class:`TestSuite` are always accessed by iteration. "
"Subclasses can lazily provide tests by overriding :meth:`!__iter__`. Note "
"that this method may be called several times on a single suite (for example "
"when counting tests or comparing for equality) so the tests returned by "
"repeated iterations before :meth:`TestSuite.run` must be the same for each "
"call iteration. After :meth:`TestSuite.run`, callers should not rely on the "
"tests returned by this method unless the caller uses a subclass that "
"overrides :meth:`TestSuite._removeTestAtIndex` to preserve test references."
msgstr ""
"Доступ к тестам, сгруппированным по :class:`TestSuite`, всегда "
"осуществляется путем итерации. Подклассы могут лениво предоставлять тесты, "
"переопределяя :meth:`!__iter__`. Обратите внимание, что этот метод может "
"вызываться несколько раз для одного набора (например, при подсчете тестов "
"или сравнении на равенство), поэтому тесты, возвращаемые повторными "
"итерациями перед :meth:`TestSuite.run`, должны быть одинаковыми для каждой "
"итерации вызова. После :meth:`TestSuite.run` вызывающие программы не должны "
"полагаться на тесты, возвращаемые этим методом, если только вызывающая "
"сторона не использует подкласс, который переопределяет :meth:`TestSuite."
"_removeTestAtIndex` для сохранения ссылок на тесты."

#: ../../library/unittest.rst:1740
msgid ""
"In earlier versions the :class:`TestSuite` accessed tests directly rather "
"than through iteration, so overriding :meth:`!__iter__` wasn't sufficient "
"for providing tests."
msgstr ""
"В более ранних версиях :class:`TestSuite` обращался к тестам напрямую, а не "
"посредством итерации, поэтому переопределения :meth:`!__iter__` было "
"недостаточно для предоставления тестов."

#: ../../library/unittest.rst:1745
msgid ""
"In earlier versions the :class:`TestSuite` held references to each :class:"
"`TestCase` after :meth:`TestSuite.run`. Subclasses can restore that behavior "
"by overriding :meth:`TestSuite._removeTestAtIndex`."
msgstr ""
"В более ранних версиях :class:`TestSuite` содержал ссылки на каждый :class:"
"`TestCase` после :meth:`TestSuite.run`. Подклассы могут восстановить это "
"поведение, переопределив :meth:`TestSuite._removeTestAtIndex`."

#: ../../library/unittest.rst:1750
msgid ""
"In the typical usage of a :class:`TestSuite` object, the :meth:`run` method "
"is invoked by a :class:`TestRunner` rather than by the end-user test harness."
msgstr ""
"При типичном использовании объекта :class:`TestSuite` метод :meth:`run` "
"вызывается :class:`TestRunner`, а не тестовой программой конечного "
"пользователя."

#: ../../library/unittest.rst:1755
msgid "Loading and running tests"
msgstr "Загрузка и запуск тестов"

#: ../../library/unittest.rst:1759
msgid ""
"The :class:`TestLoader` class is used to create test suites from classes and "
"modules.  Normally, there is no need to create an instance of this class; "
"the :mod:`unittest` module provides an instance that can be shared as :data:"
"`unittest.defaultTestLoader`.  Using a subclass or instance, however, allows "
"customization of some configurable properties."
msgstr ""
"Класс :class:`TestLoader` используется для создания наборов тестов из "
"классов и модулей. Обычно нет необходимости создавать экземпляр этого "
"класса; Модуль :mod:`unittest` предоставляет экземпляр, который можно "
"использовать как :data:`unittest.defaultTestLoader`. Однако использование "
"подкласса или экземпляра позволяет настраивать некоторые настраиваемые "
"свойства."

#: ../../library/unittest.rst:1765
msgid ":class:`TestLoader` objects have the following attributes:"
msgstr "Объекты :class:`TestLoader` имеют следующие атрибуты:"

#: ../../library/unittest.rst:1770
msgid ""
"A list of the non-fatal errors encountered while loading tests. Not reset by "
"the loader at any point. Fatal errors are signalled by the relevant method "
"raising an exception to the caller. Non-fatal errors are also indicated by a "
"synthetic test that will raise the original error when run."
msgstr ""
"Список нефатальных ошибок, возникших при загрузке тестов. Не сбрасывается "
"загрузчиком в любой момент. Фатальные ошибки сигнализируются соответствующим "
"методом, вызывающим исключение. Нефатальные ошибки также определяются "
"синтетическим тестом, который при запуске выявляет исходную ошибку."

#: ../../library/unittest.rst:1779
msgid ":class:`TestLoader` objects have the following methods:"
msgstr "Объекты :class:`TestLoader` имеют следующие методы:"

#: ../../library/unittest.rst:1784
msgid ""
"Return a suite of all test cases contained in the :class:`TestCase`\\ -"
"derived :class:`testCaseClass`."
msgstr ""
"Возвращает набор всех тестовых случаев, содержащихся в :class:`TestCase`\\ -"
"производном :class:`testCaseClass`."

#: ../../library/unittest.rst:1787
msgid ""
"A test case instance is created for each method named by :meth:"
"`getTestCaseNames`. By default these are the method names beginning with "
"``test``. If :meth:`getTestCaseNames` returns no methods, but the :meth:"
"`runTest` method is implemented, a single test case is created for that "
"method instead."
msgstr ""
"Экземпляр тестового примера создается для каждого метода, названного :meth:"
"`getTestCaseNames`. По умолчанию это имена методов, начинающиеся с ``test``. "
"Если :meth:`getTestCaseNames` не возвращает никаких методов, но метод :meth:"
"`runTest` реализован, вместо этого для этого метода создается один тестовый "
"пример."

#: ../../library/unittest.rst:1796
msgid ""
"Return a suite of all test cases contained in the given module. This method "
"searches *module* for classes derived from :class:`TestCase` and creates an "
"instance of the class for each test method defined for the class."
msgstr ""
"Возвращает набор всех тестовых примеров, содержащихся в данном модуле. Этот "
"метод ищет в *модуле* классы, производные от :class:`TestCase`, и создает "
"экземпляр класса для каждого тестового метода, определенного для этого "
"класса."

#: ../../library/unittest.rst:1803
msgid ""
"While using a hierarchy of :class:`TestCase`\\ -derived classes can be "
"convenient in sharing fixtures and helper functions, defining test methods "
"on base classes that are not intended to be instantiated directly does not "
"play well with this method.  Doing so, however, can be useful when the "
"fixtures are different and defined in subclasses."
msgstr ""
"Хотя использование иерархии классов, производных от :class:`TestCase`\\, "
"может быть удобно для совместного использования фикстур и вспомогательных "
"функций, определение тестовых методов в базовых классах, которые не "
"предназначены для непосредственного создания экземпляров, не очень хорошо "
"работает с этим методом. Однако это может быть полезно, когда фикстуры "
"различны и определены в подклассах."

#: ../../library/unittest.rst:1809
msgid ""
"If a module provides a ``load_tests`` function it will be called to load the "
"tests. This allows modules to customize test loading. This is the "
"`load_tests protocol`_.  The *pattern* argument is passed as the third "
"argument to ``load_tests``."
msgstr ""
"Если модуль предоставляет функцию load_tests, он будет вызван для загрузки "
"тестов. Это позволяет модулям настраивать тестовую загрузку. Это протокол "
"load_tests_. Аргумент *pattern* передается в качестве третьего аргумента в "
"``load_tests``."

#: ../../library/unittest.rst:1814
msgid "Support for ``load_tests`` added."
msgstr "Добавлена ​​поддержка load_tests."

#: ../../library/unittest.rst:1817
msgid "Support for a keyword-only argument *pattern* has been added."
msgstr ""
"Добавлена ​​поддержка аргумента *pattern*, состоящего только из ключевых слов."

#: ../../library/unittest.rst:1820
msgid ""
"The undocumented and unofficial *use_load_tests* parameter has been removed."
msgstr ""
"Недокументированный и неофициальный параметр *use_load_tests* был удален."

#: ../../library/unittest.rst:1827
msgid "Return a suite of all test cases given a string specifier."
msgstr ""
"Возвращает набор всех тестовых примеров с заданным строковым спецификатором."

#: ../../library/unittest.rst:1829
msgid ""
"The specifier *name* is a \"dotted name\" that may resolve either to a "
"module, a test case class, a test method within a test case class, a :class:"
"`TestSuite` instance, or a callable object which returns a :class:`TestCase` "
"or :class:`TestSuite` instance.  These checks are applied in the order "
"listed here; that is, a method on a possible test case class will be picked "
"up as \"a test method within a test case class\", rather than \"a callable "
"object\"."
msgstr ""
"Спецификатор *name* — это «имя, разделенное точками», которое может "
"разрешаться либо в модуль, либо в класс тестового примера, либо в тестовый "
"метод внутри класса тестового примера, либо в экземпляр :class:`TestSuite`, "
"либо в вызываемый объект, который возвращает: экземпляр class:`TestCase` "
"или :class:`TestSuite`. Эти проверки применяются в порядке, указанном здесь; "
"то есть метод возможного класса тестового примера будет выбран как «тестовый "
"метод в классе тестового сценария», а не как «вызываемый объект»."

#: ../../library/unittest.rst:1837
msgid ""
"For example, if you have a module :mod:`SampleTests` containing a :class:"
"`TestCase`\\ -derived class :class:`SampleTestCase` with three test methods "
"(:meth:`test_one`, :meth:`test_two`, and :meth:`test_three`), the specifier "
"``'SampleTests.SampleTestCase'`` would cause this method to return a suite "
"which will run all three test methods. Using the specifier ``'SampleTests."
"SampleTestCase.test_two'`` would cause it to return a test suite which will "
"run only the :meth:`test_two` test method. The specifier can refer to "
"modules and packages which have not been imported; they will be imported as "
"a side-effect."
msgstr ""
"Например, если у вас есть модуль :mod:`SampleTests`, содержащий :class:"
"`TestCase`\\ - производный класс :class:`SampleTestCase` с тремя методами "
"тестирования (:meth:`test_one`, :meth:`test_two` и :meth:`test_three`), "
"спецификатор ``'SampleTests.SampleTestCase'`` приведет к тому, что этот "
"метод вернет набор, который будет запускать все три метода тестирования. "
"Использование спецификатора SampleTests.SampleTestCase.test_two приведет к "
"возврату набора тестов, который будет запускать только тестовый метод :meth:"
"`test_two`. Спецификатор может ссылаться на модули и пакеты, которые не были "
"импортированы; они будут импортированы как побочный эффект."

#: ../../library/unittest.rst:1847
msgid "The method optionally resolves *name* relative to the given *module*."
msgstr "Метод опционально разрешает *name* относительно данного *модуля*."

#: ../../library/unittest.rst:1849
msgid ""
"If an :exc:`ImportError` or :exc:`AttributeError` occurs while traversing "
"*name* then a synthetic test that raises that error when run will be "
"returned. These errors are included in the errors accumulated by self.errors."
msgstr ""
"Если при обходе *name* возникает ошибка :exc:`ImportError` или :exc:"
"`AttributeError`, то будет возвращен синтетический тест, который выдает эту "
"ошибку при запуске. Эти ошибки включены в список ошибок, накопленных self."
"errors."

#: ../../library/unittest.rst:1858
msgid ""
"Similar to :meth:`loadTestsFromName`, but takes a sequence of names rather "
"than a single name.  The return value is a test suite which supports all the "
"tests defined for each name."
msgstr ""
"Похож на :meth:`loadTestsFromName`, но принимает последовательность имен, а "
"не одно имя. Возвращаемое значение — это набор тестов, который поддерживает "
"все тесты, определенные для каждого имени."

#: ../../library/unittest.rst:1865
msgid ""
"Return a sorted sequence of method names found within *testCaseClass*; this "
"should be a subclass of :class:`TestCase`."
msgstr ""
"Возвращает отсортированную последовательность имен методов, найденных в "
"*testCaseClass*; это должен быть подкласс :class:`TestCase`."

#: ../../library/unittest.rst:1871
msgid ""
"Find all the test modules by recursing into subdirectories from the "
"specified start directory, and return a TestSuite object containing them. "
"Only test files that match *pattern* will be loaded. (Using shell style "
"pattern matching.) Only module names that are importable (i.e. are valid "
"Python identifiers) will be loaded."
msgstr ""
"Найдите все тестовые модули, рекурсивно пройдя по подкаталогам указанного "
"начального каталога, и верните содержащий их объект TestSuite. Будут "
"загружены только тестовые файлы, соответствующие *шаблону*. (Используя "
"сопоставление шаблонов в стиле оболочки.) Будут загружены только имена "
"модулей, которые можно импортировать (т. е. являются действительными "
"идентификаторами Python)."

#: ../../library/unittest.rst:1877
msgid ""
"All test modules must be importable from the top level of the project. If "
"the start directory is not the top level directory then *top_level_dir* must "
"be specified separately."
msgstr ""
"Все тестовые модули должны быть импортированы с верхнего уровня проекта. "
"Если начальный каталог не является каталогом верхнего уровня, то "
"*top_level_dir* необходимо указать отдельно."

#: ../../library/unittest.rst:1881
msgid ""
"If importing a module fails, for example due to a syntax error, then this "
"will be recorded as a single error and discovery will continue.  If the "
"import failure is due to :exc:`SkipTest` being raised, it will be recorded "
"as a skip instead of an error."
msgstr ""
"Если импортировать модуль не удалось, например, из-за синтаксической ошибки, "
"это будет записано как одна ошибка, и обнаружение продолжится. Если ошибка "
"импорта вызвана вызовом :exc:`SkipTest`, это будет записано как пропуск, а "
"не как ошибка."

#: ../../library/unittest.rst:1886
msgid ""
"If a package (a directory containing a file named :file:`__init__.py`) is "
"found, the package will be checked for a ``load_tests`` function. If this "
"exists then it will be called ``package.load_tests(loader, tests, "
"pattern)``. Test discovery takes care to ensure that a package is only "
"checked for tests once during an invocation, even if the load_tests function "
"itself calls ``loader.discover``."
msgstr ""
"Если пакет (каталог, содержащий файл с именем :file:`__init__.py`) найден, "
"пакет будет проверен на наличие функции ``load_tests``. Если он существует, "
"то он будет называться ``package.load_tests(loader,tests,pattern)``. "
"Обнаружение тестов заботится о том, чтобы пакет проверялся на наличие тестов "
"только один раз во время вызова, даже если сама функция load_tests вызывает "
"``loader.discover``."

#: ../../library/unittest.rst:1894
msgid ""
"If ``load_tests`` exists then discovery does *not* recurse into the package, "
"``load_tests`` is responsible for loading all tests in the package."
msgstr ""
"Если ``load_tests`` существует, то обнаружение *не* повторяется в пакете, "
"``load_tests`` отвечает за загрузку всех тестов в пакете."

#: ../../library/unittest.rst:1898
msgid ""
"The pattern is deliberately not stored as a loader attribute so that "
"packages can continue discovery themselves."
msgstr ""
"Шаблон намеренно не сохраняется как атрибут загрузчика, чтобы пакеты могли "
"продолжить обнаружение самостоятельно."

#: ../../library/unittest.rst:1901
msgid ""
"*top_level_dir* is stored internally, and used as a default to any nested "
"calls to ``discover()``. That is, if a package's ``load_tests`` calls "
"``loader.discover()``, it does not need to pass this argument."
msgstr ""
"*top_level_dir* хранится внутри и используется по умолчанию для любых "
"вложенных вызовов ``discover()``. То есть, если ``load_tests`` пакета "
"вызывает ``loader.discover()``, ему не нужно передавать этот аргумент."

#: ../../library/unittest.rst:1905
msgid "*start_dir* can be a dotted module name as well as a directory."
msgstr ""
"*start_dir* может быть именем модуля, разделенным точками, а также каталогом."

#: ../../library/unittest.rst:1909
msgid ""
"Modules that raise :exc:`SkipTest` on import are recorded as skips, not "
"errors."
msgstr ""
"Модули, которые вызывают :exc:`SkipTest` при импорте, записываются как "
"пропуски, а не как ошибки."

#: ../../library/unittest.rst:1913
msgid "*start_dir* can be a :term:`namespace packages <namespace package>`."
msgstr "*start_dir* может быть :term:`namespace packages <namespace package>`."

#: ../../library/unittest.rst:1916
msgid ""
"Paths are sorted before being imported so that execution order is the same "
"even if the underlying file system's ordering is not dependent on file name."
msgstr ""
"Пути сортируются перед импортом, поэтому порядок выполнения одинаков, даже "
"если порядок базовой файловой системы не зависит от имени файла."

#: ../../library/unittest.rst:1921
msgid ""
"Found packages are now checked for ``load_tests`` regardless of whether "
"their path matches *pattern*, because it is impossible for a package name to "
"match the default pattern."
msgstr ""
"Найденные пакеты теперь проверяются на наличие ``load_tests`` независимо от "
"того, соответствует ли их путь *шаблону*, поскольку невозможно, чтобы имя "
"пакета соответствовало шаблону по умолчанию."

#: ../../library/unittest.rst:1926
msgid ""
"*start_dir* can not be a :term:`namespace packages <namespace package>`. It "
"has been broken since Python 3.7 and Python 3.11 officially remove it."
msgstr ""
"*start_dir* не может быть :term:`namespace packages <namespace package>`. Он "
"был сломан с тех пор, как Python 3.7 и Python 3.11 официально удалили его."

#: ../../library/unittest.rst:1930
msgid "*top_level_dir* is only stored for the duration of *discover* call."
msgstr "*top_level_dir* сохраняется только на время вызова *discover*."

#: ../../library/unittest.rst:1934
msgid ""
"The following attributes of a :class:`TestLoader` can be configured either "
"by subclassing or assignment on an instance:"
msgstr ""
"Следующие атрибуты :class:`TestLoader` могут быть настроены либо путем "
"создания подкласса, либо путем присвоения экземпляру:"

#: ../../library/unittest.rst:1940
msgid ""
"String giving the prefix of method names which will be interpreted as test "
"methods.  The default value is ``'test'``."
msgstr ""
"Строка, дающая префикс имен методов, которые будут интерпретироваться как "
"методы тестирования. Значение по умолчанию — ``'test'``."

#: ../../library/unittest.rst:1943
msgid ""
"This affects :meth:`getTestCaseNames` and all the ``loadTestsFrom*`` methods."
msgstr ""
"Это влияет на :meth:`getTestCaseNames` и все методы ``loadTestsFrom*``."

#: ../../library/unittest.rst:1949
msgid ""
"Function to be used to compare method names when sorting them in :meth:"
"`getTestCaseNames` and all the ``loadTestsFrom*`` methods."
msgstr ""
"Функция, которая будет использоваться для сравнения имен методов при их "
"сортировке в :meth:`getTestCaseNames` и всех методах ``loadTestsFrom*``."

#: ../../library/unittest.rst:1955
msgid ""
"Callable object that constructs a test suite from a list of tests. No "
"methods on the resulting object are needed.  The default value is the :class:"
"`TestSuite` class."
msgstr ""
"Вызываемый объект, который создает набор тестов из списка тестов. Никакие "
"методы результирующего объекта не требуются. Значением по умолчанию является "
"класс :class:`TestSuite`."

#: ../../library/unittest.rst:1959 ../../library/unittest.rst:1972
msgid "This affects all the ``loadTestsFrom*`` methods."
msgstr "Это влияет на все методы loadTestsFrom*."

#: ../../library/unittest.rst:1963
msgid ""
"List of Unix shell-style wildcard test name patterns that test methods have "
"to match to be included in test suites (see ``-k`` option)."
msgstr ""
"Список шаблонов имен тестов с подстановочными знаками в стиле оболочки Unix, "
"которым должны соответствовать методы тестирования, чтобы их можно было "
"включить в наборы тестов (см. параметр ``-k``)."

#: ../../library/unittest.rst:1966
msgid ""
"If this attribute is not ``None`` (the default), all test methods to be "
"included in test suites must match one of the patterns in this list. Note "
"that matches are always performed using :meth:`fnmatch.fnmatchcase`, so "
"unlike patterns passed to the ``-k`` option, simple substring patterns will "
"have to be converted using ``*`` wildcards."
msgstr ""
"Если этот атрибут отличается от «Нет» (по умолчанию), все методы "
"тестирования, включаемые в наборы тестов, должны соответствовать одному из "
"шаблонов в этом списке. Обратите внимание, что совпадения всегда выполняются "
"с использованием :meth:`fnmatch.fnmatchcase`, поэтому в отличие от шаблонов, "
"передаваемых с опцией ``-k``, простые шаблоны подстрок придется "
"конвертировать с использованием подстановочных знаков ``*``."

#: ../../library/unittest.rst:1979
msgid ""
"This class is used to compile information about which tests have succeeded "
"and which have failed."
msgstr ""
"Этот класс используется для сбора информации о том, какие тесты прошли "
"успешно, а какие — нет."

#: ../../library/unittest.rst:1982
msgid ""
"A :class:`TestResult` object stores the results of a set of tests.  The :"
"class:`TestCase` and :class:`TestSuite` classes ensure that results are "
"properly recorded; test authors do not need to worry about recording the "
"outcome of tests."
msgstr ""
"Объект :class:`TestResult` хранит результаты набора тестов. Классы :class:"
"`TestCase` и :class:`TestSuite` обеспечивают правильную запись результатов; "
"авторам тестов не нужно беспокоиться о записи результатов тестов."

#: ../../library/unittest.rst:1987
msgid ""
"Testing frameworks built on top of :mod:`unittest` may want access to the :"
"class:`TestResult` object generated by running a set of tests for reporting "
"purposes; a :class:`TestResult` instance is returned by the :meth:"
"`TestRunner.run` method for this purpose."
msgstr ""
"Средам тестирования, построенным на основе :mod:`unittest`, может "
"потребоваться доступ к объекту :class:`TestResult`, сгенерированному путем "
"запуска набора тестов для целей отчетности; Для этой цели метод :meth:"
"`TestRunner.run` возвращает экземпляр :class:`TestResult`."

#: ../../library/unittest.rst:1992
msgid ""
":class:`TestResult` instances have the following attributes that will be of "
"interest when inspecting the results of running a set of tests:"
msgstr ""
"Экземпляры :class:`TestResult` имеют следующие атрибуты, которые будут "
"представлять интерес при проверке результатов запуска набора тестов:"

#: ../../library/unittest.rst:1998
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks. Each tuple represents a test which raised an "
"unexpected exception."
msgstr ""
"Список, содержащий два кортежа экземпляров :class:`TestCase` и строк, "
"содержащих форматированные обратные трассировки. Каждый кортеж представляет "
"собой тест, вызвавший неожиданное исключение."

#: ../../library/unittest.rst:2004
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks. Each tuple represents a test where a failure "
"was explicitly signalled using the :ref:`assert\\* methods <assert-methods>`."
msgstr ""
"Список, содержащий два кортежа экземпляров :class:`TestCase` и строк, "
"содержащих форматированные обратные трассировки. Каждый кортеж представляет "
"собой тест, в котором сбой был явно сигнализирован с использованием методов :"
"ref:`assert\\* <assert-methods>`."

#: ../../library/unittest.rst:2010
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding the reason for skipping the test."
msgstr ""
"Список, содержащий 2 кортежа экземпляров :class:`TestCase` и строк, "
"содержащих причину пропуска теста."

#: ../../library/unittest.rst:2017
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks.  Each tuple represents an expected failure or "
"error of the test case."
msgstr ""
"Список, содержащий два кортежа экземпляров :class:`TestCase` и строк, "
"содержащих форматированные обратные трассировки. Каждый кортеж представляет "
"собой ожидаемый сбой или ошибку тестового примера."

#: ../../library/unittest.rst:2023
msgid ""
"A list containing :class:`TestCase` instances that were marked as expected "
"failures, but succeeded."
msgstr ""
"Список, содержащий экземпляры :class:`TestCase`, которые были помечены как "
"ожидаемые неудачные, но завершились успешно."

#: ../../library/unittest.rst:2028
msgid ""
"A list containing 2-tuples of test case names and floats representing the "
"elapsed time of each test which was run."
msgstr ""
"Список, содержащий два кортежа имен тестовых наборов и числа с плавающей "
"запятой, представляющие прошедшее время каждого запущенного теста."

#: ../../library/unittest.rst:2035
msgid ""
"Set to ``True`` when the execution of tests should stop by :meth:`stop`."
msgstr ""
"Установите значение True, когда выполнение тестов должно остановиться на :"
"meth:`stop`."

#: ../../library/unittest.rst:2039
msgid "The total number of tests run so far."
msgstr "Общее количество тестов, проведенных на данный момент."

#: ../../library/unittest.rst:2043
msgid ""
"If set to true, ``sys.stdout`` and ``sys.stderr`` will be buffered in "
"between :meth:`startTest` and :meth:`stopTest` being called. Collected "
"output will only be echoed onto the real ``sys.stdout`` and ``sys.stderr`` "
"if the test fails or errors. Any output is also attached to the failure / "
"error message."
msgstr ""
"Если установлено значение true, ``sys.stdout`` и ``sys.stderr`` будут "
"буферизованы между вызовами :meth:`startTest` и :meth:`stopTest`. Собранные "
"выходные данные будут отражены в реальных файлах ``sys.stdout`` и ``sys."
"stderr`` только в случае сбоя или ошибки теста. Любой вывод также "
"прилагается к сообщению о сбое/ошибке."

#: ../../library/unittest.rst:2052
msgid ""
"If set to true :meth:`stop` will be called on the first failure or error, "
"halting the test run."
msgstr ""
"Если установлено значение true, :meth:`stop` будет вызываться при первом "
"сбое или ошибке, останавливая выполнение теста."

#: ../../library/unittest.rst:2059
msgid "If set to true then local variables will be shown in tracebacks."
msgstr ""
"Если установлено значение true, локальные переменные будут отображаться в "
"обратных трассировках."

#: ../../library/unittest.rst:2065
msgid ""
"Return ``True`` if all tests run so far have passed, otherwise returns "
"``False``."
msgstr ""
"Возвращает ``True``, если все выполненные на данный момент тесты прошли "
"успешно, в противном случае возвращает ``False``."

#: ../../library/unittest.rst:2068
msgid ""
"Returns ``False`` if there were any :attr:`unexpectedSuccesses` from tests "
"marked with the :func:`expectedFailure` decorator."
msgstr ""
"Возвращает ``False``, если были какие-либо :attr:`unexpectedSuccesses` из "
"тестов, отмеченных декоратором :func:`expectedFailure`."

#: ../../library/unittest.rst:2074
msgid ""
"This method can be called to signal that the set of tests being run should "
"be aborted by setting the :attr:`shouldStop` attribute to ``True``. :class:"
"`TestRunner` objects should respect this flag and return without running any "
"additional tests."
msgstr ""
"Этот метод можно вызвать, чтобы сигнализировать о том, что выполняемый набор "
"тестов должен быть прерван, установив для атрибута :attr:`shouldStop` "
"значение ``True``. Объекты :class:`TestRunner` должны учитывать этот флаг и "
"возвращаться без выполнения каких-либо дополнительных тестов."

#: ../../library/unittest.rst:2079
msgid ""
"For example, this feature is used by the :class:`TextTestRunner` class to "
"stop the test framework when the user signals an interrupt from the "
"keyboard.  Interactive tools which provide :class:`TestRunner` "
"implementations can use this in a similar manner."
msgstr ""
"Например, эта функция используется классом :class:`TextTestRunner` для "
"остановки тестовой среды, когда пользователь сигнализирует о прерывании с "
"клавиатуры. Интерактивные инструменты, предоставляющие реализации :class:"
"`TestRunner`, могут использовать это аналогичным образом."

#: ../../library/unittest.rst:2084
msgid ""
"The following methods of the :class:`TestResult` class are used to maintain "
"the internal data structures, and may be extended in subclasses to support "
"additional reporting requirements.  This is particularly useful in building "
"tools which support interactive reporting while tests are being run."
msgstr ""
"Следующие методы класса :class:`TestResult` используются для поддержки "
"внутренних структур данных и могут быть расширены в подклассах для поддержки "
"дополнительных требований к отчетности. Это особенно полезно при создании "
"инструментов, поддерживающих интерактивную отчетность во время выполнения "
"тестов."

#: ../../library/unittest.rst:2092
msgid "Called when the test case *test* is about to be run."
msgstr "Вызывается, когда скоро будет запущен тестовый пример *test*."

#: ../../library/unittest.rst:2096
msgid ""
"Called after the test case *test* has been executed, regardless of the "
"outcome."
msgstr ""
"Вызывается после выполнения тестового примера *test*, независимо от "
"результата."

#: ../../library/unittest.rst:2101
msgid "Called once before any tests are executed."
msgstr "Вызывается один раз перед выполнением каких-либо тестов."

#: ../../library/unittest.rst:2108
msgid "Called once after all tests are executed."
msgstr "Вызывается один раз после выполнения всех тестов."

#: ../../library/unittest.rst:2115
msgid ""
"Called when the test case *test* raises an unexpected exception. *err* is a "
"tuple of the form returned by :func:`sys.exc_info`: ``(type, value, "
"traceback)``."
msgstr ""
"Вызывается, когда тестовый пример *test* вызывает неожиданное исключение. "
"*err* — это кортеж формы, возвращаемый :func:`sys.exc_info`: ``(type, value,"
"traceback)``."

#: ../../library/unittest.rst:2119
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`errors` attribute, where *formatted_err* is a formatted "
"traceback derived from *err*."
msgstr ""
"Реализация по умолчанию добавляет кортеж (test, formatted_err) к атрибуту :"
"attr:`errors` экземпляра, где *formatted_err* — это форматированная обратная "
"трассировка, полученная из *err*."

#: ../../library/unittest.rst:2126
msgid ""
"Called when the test case *test* signals a failure. *err* is a tuple of the "
"form returned by :func:`sys.exc_info`: ``(type, value, traceback)``."
msgstr ""
"Вызывается, когда тестовый пример *test* сигнализирует об ошибке. *err* — "
"это кортеж формы, возвращаемый :func:`sys.exc_info`: ``(type, value,"
"traceback)``."

#: ../../library/unittest.rst:2129
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`failures` attribute, where *formatted_err* is a formatted "
"traceback derived from *err*."
msgstr ""
"Реализация по умолчанию добавляет кортеж ``(test, formatted_err)`` к "
"атрибуту :attr:`failures` экземпляра, где *formatted_err* — это "
"форматированная обратная трассировка, полученная из *err*."

#: ../../library/unittest.rst:2136
msgid "Called when the test case *test* succeeds."
msgstr "Вызывается, когда тестовый пример *test* завершается успешно."

#: ../../library/unittest.rst:2138
msgid "The default implementation does nothing."
msgstr "Реализация по умолчанию ничего не делает."

#: ../../library/unittest.rst:2143
msgid ""
"Called when the test case *test* is skipped.  *reason* is the reason the "
"test gave for skipping."
msgstr ""
"Вызывается, когда тестовый пример *test* пропускается. *причина* — причина "
"пропуска теста."

#: ../../library/unittest.rst:2146
msgid ""
"The default implementation appends a tuple ``(test, reason)`` to the "
"instance's :attr:`skipped` attribute."
msgstr ""
"Реализация по умолчанию добавляет кортеж ``(test, Reason)`` к атрибуту :attr:"
"`skiped` экземпляра."

#: ../../library/unittest.rst:2152
msgid ""
"Called when the test case *test* fails or errors, but was marked with the :"
"func:`expectedFailure` decorator."
msgstr ""
"Вызывается, когда тестовый пример *test* завершается неудачно или с ошибкой, "
"но помечен декоратором :func:`expectedFailure`."

#: ../../library/unittest.rst:2155
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`expectedFailures` attribute, where *formatted_err* is a "
"formatted traceback derived from *err*."
msgstr ""
"Реализация по умолчанию добавляет кортеж (test, formatted_err) к атрибуту :"
"attr:`expectedFailures` экземпляра, где *formatted_err* — это "
"форматированная обратная трассировка, полученная из *err*."

#: ../../library/unittest.rst:2162
msgid ""
"Called when the test case *test* was marked with the :func:`expectedFailure` "
"decorator, but succeeded."
msgstr ""
"Вызывается, когда тестовый пример *test* был помечен декоратором :func:"
"`expectedFailure`, но завершился успешно."

#: ../../library/unittest.rst:2165
msgid ""
"The default implementation appends the test to the instance's :attr:"
"`unexpectedSuccesses` attribute."
msgstr ""
"Реализация по умолчанию добавляет тест к атрибуту :attr:"
"`unexpectedSuccesses` экземпляра."

#: ../../library/unittest.rst:2171
msgid ""
"Called when a subtest finishes.  *test* is the test case corresponding to "
"the test method.  *subtest* is a custom :class:`TestCase` instance "
"describing the subtest."
msgstr ""
"Вызывается по завершении подтеста. *test* — тестовый пример, соответствующий "
"методу тестирования. *subtest* — это пользовательский экземпляр :class:"
"`TestCase`, описывающий подтест."

#: ../../library/unittest.rst:2175
msgid ""
"If *outcome* is :const:`None`, the subtest succeeded.  Otherwise, it failed "
"with an exception where *outcome* is a tuple of the form returned by :func:"
"`sys.exc_info`: ``(type, value, traceback)``."
msgstr ""
"Если *outcome* равен :const:`None`, подтест пройден успешно. В противном "
"случае он завершился ошибкой с исключением, где *outcome* представляет собой "
"кортеж формы, возвращаемой :func:`sys.exc_info`: ``(type, value, "
"Traceback)``."

#: ../../library/unittest.rst:2179
msgid ""
"The default implementation does nothing when the outcome is a success, and "
"records subtest failures as normal failures."
msgstr ""
"Реализация по умолчанию ничего не делает, если результат успешен, и "
"записывает неудачи подтестов как обычные неудачи."

#: ../../library/unittest.rst:2186
msgid ""
"Called when the test case finishes.  *elapsed* is the time represented in "
"seconds, and it includes the execution of cleanup functions."
msgstr ""
"Вызывается после завершения тестового примера. *прошедшее* — это время, "
"представленное в секундах, включая выполнение функций очистки."

#: ../../library/unittest.rst:2193
msgid ""
"A concrete implementation of :class:`TestResult` used by the :class:"
"`TextTestRunner`. Subclasses should accept ``**kwargs`` to ensure "
"compatibility as the interface changes."
msgstr ""
"Конкретная реализация :class:`TestResult`, используемая :class:"
"`TextTestRunner`. Подклассы должны принимать ``**kwargs``, чтобы обеспечить "
"совместимость при изменении интерфейса."

#: ../../library/unittest.rst:2199
msgid "Added the *durations* keyword parameter."
msgstr "Добавлен параметр ключевого слова *durations*."

#: ../../library/unittest.rst:2204
msgid ""
"Instance of the :class:`TestLoader` class intended to be shared.  If no "
"customization of the :class:`TestLoader` is needed, this instance can be "
"used instead of repeatedly creating new instances."
msgstr ""
"Экземпляр класса :class:`TestLoader`, предназначенный для совместного "
"использования. Если никакая настройка :class:`TestLoader` не требуется, этот "
"экземпляр можно использовать вместо многократного создания новых экземпляров."

#: ../../library/unittest.rst:2213
msgid ""
"A basic test runner implementation that outputs results to a stream. If "
"*stream* is ``None``, the default, :data:`sys.stderr` is used as the output "
"stream. This class has a few configurable parameters, but is essentially "
"very simple.  Graphical applications which run test suites should provide "
"alternate implementations. Such implementations should accept ``**kwargs`` "
"as the interface to construct runners changes when features are added to "
"unittest."
msgstr ""
"Базовая реализация средства запуска тестов, которая выводит результаты в "
"поток. Если *stream* имеет значение None, в качестве выходного потока по "
"умолчанию используется :data:`sys.stderr`. Этот класс имеет несколько "
"настраиваемых параметров, но по сути он очень прост. Графические приложения, "
"в которых выполняются наборы тестов, должны предоставлять альтернативные "
"реализации. Такие реализации должны принимать ``**kwargs`` в качестве "
"интерфейса для создания изменений бегунов при добавлении функций в unittest."

#: ../../library/unittest.rst:2220
msgid ""
"By default this runner shows :exc:`DeprecationWarning`, :exc:"
"`PendingDeprecationWarning`, :exc:`ResourceWarning` and :exc:`ImportWarning` "
"even if they are :ref:`ignored by default <warning-ignored>`.  This behavior "
"can be overridden using Python's :option:`!-Wd` or :option:`!-Wa` options "
"(see :ref:`Warning control <using-on-warnings>`) and leaving *warnings* to "
"``None``."
msgstr ""
"По умолчанию этот бегун отображает :exc:`DeprecationWarning`, :exc:"
"`PendingDeprecationWarning`, :exc:`ResourceWarning` и :exc:`ImportWarning`, "
"даже если они :ref:`игнорируются по умолчанию <warning-ignored>`. Это "
"поведение можно переопределить с помощью параметров Python :option:`!-Wd` "
"или :option:`!-Wa` (см. :ref:`Управление предупреждением <using-on-"
"warnings>`), оставив *warnings* в `` Нет``."

#: ../../library/unittest.rst:2228
msgid "Added the *warnings* parameter."
msgstr "Добавлен параметр *предупреждения*."

#: ../../library/unittest.rst:2231
msgid ""
"The default stream is set to :data:`sys.stderr` at instantiation time rather "
"than import time."
msgstr ""
"Поток по умолчанию устанавливается на :data:`sys.stderr` во время создания "
"экземпляра, а не во время импорта."

#: ../../library/unittest.rst:2235
msgid "Added the *tb_locals* parameter."
msgstr "Добавлен параметр *tb_locals*."

#: ../../library/unittest.rst:2238
msgid "Added the *durations* parameter."
msgstr "Добавлен параметр *durations*."

#: ../../library/unittest.rst:2243
msgid ""
"This method returns the instance of ``TestResult`` used by :meth:`run`. It "
"is not intended to be called directly, but can be overridden in subclasses "
"to provide a custom ``TestResult``."
msgstr ""
"Этот метод возвращает экземпляр TestResult, используемый :meth:`run`. Он не "
"предназначен для прямого вызова, но может быть переопределен в подклассах "
"для предоставления собственного TestResult."

#: ../../library/unittest.rst:2247
msgid ""
"``_makeResult()`` instantiates the class or callable passed in the "
"``TextTestRunner`` constructor as the ``resultclass`` argument. It defaults "
"to :class:`TextTestResult` if no ``resultclass`` is provided. The result "
"class is instantiated with the following arguments::"
msgstr ""
"``_makeResult()`` создает экземпляр класса или вызываемого объекта, "
"переданного в конструкторе ``TextTestRunner`` в качестве аргумента "
"``resultclass``. По умолчанию используется :class:`TextTestResult`, если "
"``resultclass`` не указан. Класс результата создается со следующими "
"аргументами:"

#: ../../library/unittest.rst:2252
msgid "stream, descriptions, verbosity"
msgstr "поток, описания, многословие"

#: ../../library/unittest.rst:2256
msgid ""
"This method is the main public interface to the ``TextTestRunner``. This "
"method takes a :class:`TestSuite` or :class:`TestCase` instance. A :class:"
"`TestResult` is created by calling :func:`_makeResult` and the test(s) are "
"run and the results printed to stdout."
msgstr ""
"Этот метод является основным общедоступным интерфейсом TextTestRunner. Этот "
"метод принимает экземпляр :class:`TestSuite` или :class:`TestCase`. :class:"
"`TestResult` создается путем вызова :func:`_makeResult`, запускаются тесты и "
"выводятся результаты на стандартный вывод."

#: ../../library/unittest.rst:2267
msgid ""
"A command-line program that loads a set of tests from *module* and runs "
"them; this is primarily for making test modules conveniently executable. The "
"simplest use for this function is to include the following line at the end "
"of a test script::"
msgstr ""
"Программа командной строки, которая загружает набор тестов из *модуля* и "
"запускает их; это прежде всего сделано для того, чтобы сделать тестовые "
"модули удобными для выполнения. Простейшее использование этой функции — "
"включение следующей строки в конец тестового сценария:"

#: ../../library/unittest.rst:2272
msgid ""
"if __name__ == '__main__':\n"
"    unittest.main()"
msgstr ""
"if __name__ == '__main__':\n"
"    unittest.main()"

#: ../../library/unittest.rst:2275
msgid ""
"You can run tests with more detailed information by passing in the verbosity "
"argument::"
msgstr ""
"Вы можете запустить тесты с более подробной информацией, передав аргумент "
"verbosity::"

#: ../../library/unittest.rst:2278
msgid ""
"if __name__ == '__main__':\n"
"    unittest.main(verbosity=2)"
msgstr ""
"if __name__ == '__main__':\n"
"    unittest.main(verbosity=2)"

#: ../../library/unittest.rst:2281
msgid ""
"The *defaultTest* argument is either the name of a single test or an "
"iterable of test names to run if no test names are specified via *argv*.  If "
"not specified or ``None`` and no test names are provided via *argv*, all "
"tests found in *module* are run."
msgstr ""
"Аргумент *defaultTest* — это либо имя одного теста, либо итерация имен "
"тестов, которые будут выполняться, если имена тестов не указаны через "
"*argv*. Если не указано или ``Нет`` и имена тестов не указаны через *argv*, "
"запускаются все тесты, найденные в *module*."

#: ../../library/unittest.rst:2286
msgid ""
"The *argv* argument can be a list of options passed to the program, with the "
"first element being the program name.  If not specified or ``None``, the "
"values of :data:`sys.argv` are used."
msgstr ""
"Аргумент *argv* может представлять собой список параметров, передаваемых "
"программе, где первым элементом является имя программы. Если не указано или "
"«Нет», используются значения :data:`sys.argv`."

#: ../../library/unittest.rst:2290
msgid ""
"The *testRunner* argument can either be a test runner class or an already "
"created instance of it. By default ``main`` calls :func:`sys.exit` with an "
"exit code indicating success (0) or failure (1) of the tests run. An exit "
"code of 5 indicates that no tests were run or skipped."
msgstr ""
"Аргумент *testRunner* может быть либо классом запуска тестов, либо уже "
"созданным его экземпляром. По умолчанию main вызывает :func:`sys.exit` с "
"кодом завершения, указывающим на успех (0) или неудачу (1) выполненных "
"тестов. Код выхода 5 указывает, что никакие тесты не выполнялись и не были "
"пропущены."

#: ../../library/unittest.rst:2295
msgid ""
"The *testLoader* argument has to be a :class:`TestLoader` instance, and "
"defaults to :data:`defaultTestLoader`."
msgstr ""
"Аргумент *testLoader* должен быть экземпляром :class:`TestLoader` и по "
"умолчанию имеет значение :data:`defaultTestLoader`."

#: ../../library/unittest.rst:2298
msgid ""
"``main`` supports being used from the interactive interpreter by passing in "
"the argument ``exit=False``. This displays the result on standard output "
"without calling :func:`sys.exit`::"
msgstr ""
"``main`` поддерживает использование из интерактивного интерпретатора, "
"передавая аргумент ``exit=False``. Это отображает результат в стандартном "
"выводе без вызова :func:`sys.exit`::"

#: ../../library/unittest.rst:2302
msgid ""
">>> from unittest import main\n"
">>> main(module='test_module', exit=False)"
msgstr ""
">>> from unittest import main\n"
">>> main(module='test_module', exit=False)"

#: ../../library/unittest.rst:2305
msgid ""
"The *failfast*, *catchbreak* and *buffer* parameters have the same effect as "
"the same-name `command-line options`_."
msgstr ""
"Параметры *failfast*, *catchbreak* и *buffer* имеют тот же эффект, что и "
"одноименные `параметры командной строки`_."

#: ../../library/unittest.rst:2308
msgid ""
"The *warnings* argument specifies the :ref:`warning filter <warning-filter>` "
"that should be used while running the tests.  If it's not specified, it will "
"remain ``None`` if a :option:`!-W` option is passed to :program:`python` "
"(see :ref:`Warning control <using-on-warnings>`), otherwise it will be set "
"to ``'default'``."
msgstr ""
"Аргумент *warnings* указывает :ref:`фильтр предупреждений <warning-filter>`, "
"который следует использовать при запуске тестов. Если он не указан, он "
"останется ``None``, если параметр :option:`!-W` будет передан в :program:"
"`python` (см. :ref:`Управление предупреждениями <using-on-warnings>`) , в "
"противном случае будет установлено значение ``'default'``."

#: ../../library/unittest.rst:2314
msgid ""
"Calling ``main`` returns an object with the ``result`` attribute that "
"contains the result of the tests run as a :class:`unittest.TestResult`."
msgstr ""
"Вызов main возвращает объект с атрибутом result, который содержит результат "
"тестов, выполненных в виде :class:`unittest.TestResult`."

#: ../../library/unittest.rst:2317
msgid "The *exit* parameter was added."
msgstr "Добавлен параметр *exit*."

#: ../../library/unittest.rst:2320
msgid ""
"The *verbosity*, *failfast*, *catchbreak*, *buffer* and *warnings* "
"parameters were added."
msgstr ""
"Были добавлены параметры *verbosity*, *failfast*, *catchbreak*, *buffer* и "
"*warnings*."

#: ../../library/unittest.rst:2324
msgid ""
"The *defaultTest* parameter was changed to also accept an iterable of test "
"names."
msgstr ""
"Параметр *defaultTest* был изменен, чтобы также принимать итерацию имен "
"тестов."

#: ../../library/unittest.rst:2332
msgid "load_tests Protocol"
msgstr "Протокол load_tests"

#: ../../library/unittest.rst:2336
msgid ""
"Modules or packages can customize how tests are loaded from them during "
"normal test runs or test discovery by implementing a function called "
"``load_tests``."
msgstr ""
"Модули и пакеты могут настраивать способ загрузки тестов из них во время "
"обычных запусков тестов или обнаружения тестов, реализуя функцию под "
"названием load_tests."

#: ../../library/unittest.rst:2339
msgid ""
"If a test module defines ``load_tests`` it will be called by :meth:"
"`TestLoader.loadTestsFromModule` with the following arguments::"
msgstr ""
"Если тестовый модуль определяет ``load_tests``, он будет вызван :meth:"
"`TestLoader.loadTestsFromModule` со следующими аргументами:"

#: ../../library/unittest.rst:2342 ../../library/unittest.rst:2374
msgid "load_tests(loader, standard_tests, pattern)"
msgstr "load_tests(loader, standard_tests, pattern)"

#: ../../library/unittest.rst:2344
msgid ""
"where *pattern* is passed straight through from ``loadTestsFromModule``.  It "
"defaults to ``None``."
msgstr ""
"где *pattern* передается напрямую из loadTestsFromModule. По умолчанию "
"установлено значение «Нет»."

#: ../../library/unittest.rst:2347
msgid "It should return a :class:`TestSuite`."
msgstr "Он должен вернуть :class:`TestSuite`."

#: ../../library/unittest.rst:2349
msgid ""
"*loader* is the instance of :class:`TestLoader` doing the loading. "
"*standard_tests* are the tests that would be loaded by default from the "
"module. It is common for test modules to only want to add or remove tests "
"from the standard set of tests. The third argument is used when loading "
"packages as part of test discovery."
msgstr ""
"*loader* — это экземпляр :class:`TestLoader`, выполняющий загрузку. "
"*standard_tests* — это тесты, которые по умолчанию загружаются из модуля. "
"Обычно тестовые модули хотят только добавлять или удалять тесты из "
"стандартного набора тестов. Третий аргумент используется при загрузке "
"пакетов в рамках обнаружения тестов."

#: ../../library/unittest.rst:2355
msgid ""
"A typical ``load_tests`` function that loads tests from a specific set of :"
"class:`TestCase` classes may look like::"
msgstr ""
"Типичная функция load_tests, которая загружает тесты из определенного набора "
"классов :class:`TestCase`, может выглядеть так:"

#: ../../library/unittest.rst:2358
msgid ""
"test_cases = (TestCase1, TestCase2, TestCase3)\n"
"\n"
"def load_tests(loader, tests, pattern):\n"
"    suite = TestSuite()\n"
"    for test_class in test_cases:\n"
"        tests = loader.loadTestsFromTestCase(test_class)\n"
"        suite.addTests(tests)\n"
"    return suite"
msgstr ""
"test_cases = (TestCase1, TestCase2, TestCase3)\n"
"\n"
"def load_tests(loader, tests, pattern):\n"
"    suite = TestSuite()\n"
"    for test_class in test_cases:\n"
"        tests = loader.loadTestsFromTestCase(test_class)\n"
"        suite.addTests(tests)\n"
"    return suite"

#: ../../library/unittest.rst:2367
msgid ""
"If discovery is started in a directory containing a package, either from the "
"command line or by calling :meth:`TestLoader.discover`, then the package :"
"file:`__init__.py` will be checked for ``load_tests``.  If that function "
"does not exist, discovery will recurse into the package as though it were "
"just another directory.  Otherwise, discovery of the package's tests will be "
"left up to ``load_tests`` which is called with the following arguments::"
msgstr ""
"Если обнаружение запускается в каталоге, содержащем пакет, либо из командной "
"строки, либо путем вызова :meth:`TestLoader.discover`, то пакет :file:"
"`__init__.py` будет проверен на наличие ``load_tests``. Если эта функция не "
"существует, обнаружение будет повторяться в пакете, как если бы это был "
"просто другой каталог. В противном случае обнаружение тестов пакета будет "
"оставлено на усмотрение ``load_tests``, которое вызывается со следующими "
"аргументами:"

#: ../../library/unittest.rst:2376
msgid ""
"This should return a :class:`TestSuite` representing all the tests from the "
"package. (``standard_tests`` will only contain tests collected from :file:"
"`__init__.py`.)"
msgstr ""
"Это должно вернуть :class:`TestSuite`, представляющий все тесты из пакета. "
"(``standard_tests`` будет содержать только тесты, собранные из :file:"
"`__init__.py`.)"

#: ../../library/unittest.rst:2380
msgid ""
"Because the pattern is passed into ``load_tests`` the package is free to "
"continue (and potentially modify) test discovery. A 'do nothing' "
"``load_tests`` function for a test package would look like::"
msgstr ""
"Поскольку шаблон передается в load_tests, пакет может продолжать (и "
"потенциально изменять) обнаружение тестов. Функция ``load_tests``, ничего не "
"делающая для тестового пакета, будет выглядеть так:"

#: ../../library/unittest.rst:2384
msgid ""
"def load_tests(loader, standard_tests, pattern):\n"
"    # top level directory cached on loader instance\n"
"    this_dir = os.path.dirname(__file__)\n"
"    package_tests = loader.discover(start_dir=this_dir, pattern=pattern)\n"
"    standard_tests.addTests(package_tests)\n"
"    return standard_tests"
msgstr ""
"def load_tests(loader, standard_tests, pattern):\n"
"    # top level directory cached on loader instance\n"
"    this_dir = os.path.dirname(__file__)\n"
"    package_tests = loader.discover(start_dir=this_dir, pattern=pattern)\n"
"    standard_tests.addTests(package_tests)\n"
"    return standard_tests"

#: ../../library/unittest.rst:2391
msgid ""
"Discovery no longer checks package names for matching *pattern* due to the "
"impossibility of package names matching the default pattern."
msgstr ""
"Discovery больше не проверяет имена пакетов на соответствие *шаблону* из-за "
"невозможности соответствия имен пакетов шаблону по умолчанию."

#: ../../library/unittest.rst:2398
msgid "Class and Module Fixtures"
msgstr "Фикстуры классов и модулей"

#: ../../library/unittest.rst:2400
msgid ""
"Class and module level fixtures are implemented in :class:`TestSuite`. When "
"the test suite encounters a test from a new class then :meth:`tearDownClass` "
"from the previous class (if there is one) is called, followed by :meth:"
"`setUpClass` from the new class."
msgstr ""
"Фикстуры уровня класса и модуля реализованы в :class:`TestSuite`. Когда "
"набор тестов встречает тест из нового класса, вызывается :meth:"
"`tearDownClass` из предыдущего класса (если он есть), а затем :meth:"
"`setUpClass` из нового класса."

#: ../../library/unittest.rst:2405
msgid ""
"Similarly if a test is from a different module from the previous test then "
"``tearDownModule`` from the previous module is run, followed by "
"``setUpModule`` from the new module."
msgstr ""
"Аналогично, если тест происходит из модуля, отличного от предыдущего теста, "
"то запускается ``tearDownModule`` из предыдущего модуля, а затем "
"``setUpModule`` из нового модуля."

#: ../../library/unittest.rst:2409
msgid ""
"After all the tests have run the final ``tearDownClass`` and "
"``tearDownModule`` are run."
msgstr ""
"После запуска всех тестов запускаются последние ``tearDownClass`` и "
"``tearDownModule``."

#: ../../library/unittest.rst:2412
msgid ""
"Note that shared fixtures do not play well with [potential] features like "
"test parallelization and they break test isolation. They should be used with "
"care."
msgstr ""
"Обратите внимание, что общие фикстуры плохо сочетаются с [потенциальными] "
"функциями, такими как распараллеливание тестов, и они нарушают изоляцию "
"тестов. Их следует использовать с осторожностью."

#: ../../library/unittest.rst:2415
msgid ""
"The default ordering of tests created by the unittest test loaders is to "
"group all tests from the same modules and classes together. This will lead "
"to ``setUpClass`` / ``setUpModule`` (etc) being called exactly once per "
"class and module. If you randomize the order, so that tests from different "
"modules and classes are adjacent to each other, then these shared fixture "
"functions may be called multiple times in a single test run."
msgstr ""
"По умолчанию порядок тестов, созданных загрузчиками тестов unittest, "
"заключается в группировке всех тестов из одних и тех же модулей и классов. "
"Это приведет к тому, что ``setUpClass``/``setUpModule`` (и т. д.) будет "
"вызываться ровно один раз для каждого класса и модуля. Если вы "
"рандомизируете порядок, чтобы тесты из разных модулей и классов находились "
"рядом друг с другом, то эти общие функции фиксации могут вызываться "
"несколько раз за один запуск теста."

#: ../../library/unittest.rst:2422
msgid ""
"Shared fixtures are not intended to work with suites with non-standard "
"ordering. A ``BaseTestSuite`` still exists for frameworks that don't want to "
"support shared fixtures."
msgstr ""
"Общие светильники не предназначены для работы с люксами с нестандартным "
"порядком. BaseTestSuite все еще существует для фреймворков, которые не хотят "
"поддерживать общие приспособления."

#: ../../library/unittest.rst:2426
msgid ""
"If there are any exceptions raised during one of the shared fixture "
"functions the test is reported as an error. Because there is no "
"corresponding test instance an ``_ErrorHolder`` object (that has the same "
"interface as a :class:`TestCase`) is created to represent the error. If you "
"are just using the standard unittest test runner then this detail doesn't "
"matter, but if you are a framework author it may be relevant."
msgstr ""
"Если во время одной из функций общего устройства возникают какие-либо "
"исключения, о тесте сообщается как об ошибке. Поскольку соответствующего "
"тестового экземпляра нет, для представления ошибки создается объект "
"``_ErrorHolder`` (который имеет тот же интерфейс, что и :class:`TestCase`). "
"Если вы просто используете стандартный модуль запуска тестов unittest, эта "
"деталь не имеет значения, но если вы являетесь автором фреймворка, это может "
"быть актуально."

#: ../../library/unittest.rst:2435
msgid "setUpClass and tearDownClass"
msgstr "setUpClass и tearDownClass"

#: ../../library/unittest.rst:2437
msgid "These must be implemented as class methods::"
msgstr "Они должны быть реализованы как методы класса::"

#: ../../library/unittest.rst:2439
msgid ""
"import unittest\n"
"\n"
"class Test(unittest.TestCase):\n"
"    @classmethod\n"
"    def setUpClass(cls):\n"
"        cls._connection = createExpensiveConnectionObject()\n"
"\n"
"    @classmethod\n"
"    def tearDownClass(cls):\n"
"        cls._connection.destroy()"
msgstr ""
"import unittest\n"
"\n"
"class Test(unittest.TestCase):\n"
"    @classmethod\n"
"    def setUpClass(cls):\n"
"        cls._connection = createExpensiveConnectionObject()\n"
"\n"
"    @classmethod\n"
"    def tearDownClass(cls):\n"
"        cls._connection.destroy()"

#: ../../library/unittest.rst:2450
msgid ""
"If you want the ``setUpClass`` and ``tearDownClass`` on base classes called "
"then you must call up to them yourself. The implementations in :class:"
"`TestCase` are empty."
msgstr ""
"Если вы хотите, чтобы ``setUpClass`` и ``tearDownClass`` вызывались в "
"базовых классах, вы должны вызвать их самостоятельно. Реализации в :class:"
"`TestCase` пусты."

#: ../../library/unittest.rst:2454
msgid ""
"If an exception is raised during a ``setUpClass`` then the tests in the "
"class are not run and the ``tearDownClass`` is not run. Skipped classes will "
"not have ``setUpClass`` or ``tearDownClass`` run. If the exception is a :exc:"
"`SkipTest` exception then the class will be reported as having been skipped "
"instead of as an error."
msgstr ""
"Если во время ``setUpClass`` возникает исключение, то тесты в классе не "
"запускаются и ``tearDownClass`` не запускается. Пропущенные классы не будут "
"запускаться ``setUpClass`` или ``tearDownClass``. Если исключение "
"представляет собой исключение :exc:`SkipTest`, то о классе будет сообщено "
"как о пропущенном, а не как об ошибке."

#: ../../library/unittest.rst:2462
msgid "setUpModule and tearDownModule"
msgstr "setUpModule и tearDownModule"

#: ../../library/unittest.rst:2464
msgid "These should be implemented as functions::"
msgstr "Они должны быть реализованы как функции::"

#: ../../library/unittest.rst:2466
msgid ""
"def setUpModule():\n"
"    createConnection()\n"
"\n"
"def tearDownModule():\n"
"    closeConnection()"
msgstr ""
"def setUpModule():\n"
"    createConnection()\n"
"\n"
"def tearDownModule():\n"
"    closeConnection()"

#: ../../library/unittest.rst:2472
msgid ""
"If an exception is raised in a ``setUpModule`` then none of the tests in the "
"module will be run and the ``tearDownModule`` will not be run. If the "
"exception is a :exc:`SkipTest` exception then the module will be reported as "
"having been skipped instead of as an error."
msgstr ""
"Если в ``setUpModule`` возникает исключение, ни один из тестов в модуле не "
"будет запущен, и ``tearDownModule`` не будет запущен. Если исключением "
"является исключение :exc:`SkipTest`, то о модуле будет сообщено как о "
"пропущенном, а не как об ошибке."

#: ../../library/unittest.rst:2477
msgid ""
"To add cleanup code that must be run even in the case of an exception, use "
"``addModuleCleanup``:"
msgstr ""
"Чтобы добавить код очистки, который должен быть запущен даже в случае "
"исключения, используйте addModuleCleanup:"

#: ../../library/unittest.rst:2483
msgid ""
"Add a function to be called after :func:`tearDownModule` to cleanup "
"resources used during the test class. Functions will be called in reverse "
"order to the order they are added (:abbr:`LIFO (last-in, first-out)`). They "
"are called with any arguments and keyword arguments passed into :meth:"
"`addModuleCleanup` when they are added."
msgstr ""
"Добавьте функцию, которая будет вызываться после :func:`tearDownModule` для "
"очистки ресурсов, используемых во время тестового класса. Функции будут "
"вызываться в порядке, обратном порядку их добавления (:abbr:`LIFO (last-in, "
"first-out)`). Они вызываются с любыми аргументами и ключевыми словами, "
"передаваемыми в :meth:`addModuleCleanup` при их добавлении."

#: ../../library/unittest.rst:2489
msgid ""
"If :meth:`setUpModule` fails, meaning that :func:`tearDownModule` is not "
"called, then any cleanup functions added will still be called."
msgstr ""
"Если :meth:`setUpModule` завершается сбоем, то есть :func:`tearDownModule` "
"не вызывается, то любые добавленные функции очистки все равно будут "
"вызываться."

#: ../../library/unittest.rst:2497
msgid ""
"Enter the supplied :term:`context manager`.  If successful, also add its :"
"meth:`~object.__exit__` method as a cleanup function by :func:"
"`addModuleCleanup` and return the result of the :meth:`~object.__enter__` "
"method."
msgstr ""
"Введите предоставленный :term:`контекстный менеджер`. В случае успеха также "
"добавьте его метод :meth:`~object.__exit__` в качестве функции очистки с "
"помощью :func:`addModuleCleanup` и верните результат метода :meth:`~object."
"__enter__`."

#: ../../library/unittest.rst:2507
msgid ""
"This function is called unconditionally after :func:`tearDownModule`, or "
"after :func:`setUpModule` if :func:`setUpModule` raises an exception."
msgstr ""
"Эта функция вызывается безоговорочно после :func:`tearDownModule` или после :"
"func:`setUpModule`, если :func:`setUpModule` вызывает исключение."

#: ../../library/unittest.rst:2510
msgid ""
"It is responsible for calling all the cleanup functions added by :func:"
"`addModuleCleanup`. If you need cleanup functions to be called *prior* to :"
"func:`tearDownModule` then you can call :func:`doModuleCleanups` yourself."
msgstr ""
"Он отвечает за вызов всех функций очистки, добавленных :func:"
"`addModuleCleanup`. Если вам нужно, чтобы функции очистки вызывались *до* :"
"func:`tearDownModule`, вы можете вызвать :func:`doModuleCleanups` "
"самостоятельно."

#: ../../library/unittest.rst:2515
msgid ""
":func:`doModuleCleanups` pops methods off the stack of cleanup functions one "
"at a time, so it can be called at any time."
msgstr ""
":func:`doModuleCleanups` извлекает методы из стека функций очистки по "
"одному, поэтому их можно вызвать в любое время."

#: ../../library/unittest.rst:2522
msgid "Signal Handling"
msgstr "Обработка сигналов"

#: ../../library/unittest.rst:2526
msgid ""
"The :option:`-c/--catch <unittest -c>` command-line option to unittest, "
"along with the ``catchbreak`` parameter to :func:`unittest.main`, provide "
"more friendly handling of control-C during a test run. With catch break "
"behavior enabled control-C will allow the currently running test to "
"complete, and the test run will then end and report all the results so far. "
"A second control-c will raise a :exc:`KeyboardInterrupt` in the usual way."
msgstr ""
"Параметр командной строки :option:`-c/--catch <unittest -c>` для unittest "
"вместе с параметром ``catchbreak`` для :func:`unittest.main` обеспечивают "
"более дружелюбную обработку управляющих данных. C во время тестового "
"запуска. Если включено поведение Catch Break, Control-C позволит завершить "
"текущий тест, а затем тестовый запуск завершится и сообщит обо всех "
"результатах на данный момент. Второй control-c вызовет :exc:"
"`KeyboardInterrupt` обычным способом."

#: ../../library/unittest.rst:2533
msgid ""
"The control-c handling signal handler attempts to remain compatible with "
"code or tests that install their own :const:`signal.SIGINT` handler. If the "
"``unittest`` handler is called but *isn't* the installed :const:`signal."
"SIGINT` handler, i.e. it has been replaced by the system under test and "
"delegated to, then it calls the default handler. This will normally be the "
"expected behavior by code that replaces an installed handler and delegates "
"to it. For individual tests that need ``unittest`` control-c handling "
"disabled the :func:`removeHandler` decorator can be used."
msgstr ""
"Обработчик сигнала control-c пытается оставаться совместимым с кодом или "
"тестами, которые устанавливают собственный обработчик :const:`signal."
"SIGINT`. Если обработчик ``unittest`` вызывается, но *не* является "
"установленным обработчиком :const:`signal.SIGINT`, т.е. он был заменен "
"тестируемой системой и делегирован ей, то он вызывает обработчик по "
"умолчанию. Обычно это ожидаемое поведение кода, который заменяет "
"установленный обработчик и делегирует ему полномочия. Для отдельных тестов, "
"которым требуется отключить обработку control-c unittest, можно использовать "
"декоратор :func:`removeHandler`."

#: ../../library/unittest.rst:2542
msgid ""
"There are a few utility functions for framework authors to enable control-c "
"handling functionality within test frameworks."
msgstr ""
"Для авторов фреймворков существует несколько служебных функций, позволяющих "
"включить функциональность обработки control-c в тестовых средах."

#: ../../library/unittest.rst:2547
msgid ""
"Install the control-c handler. When a :const:`signal.SIGINT` is received "
"(usually in response to the user pressing control-c) all registered results "
"have :meth:`~TestResult.stop` called."
msgstr ""
"Установите обработчик control-c. Когда получен :const:`signal.SIGINT` "
"(обычно в ответ на нажатие пользователем control-c), для всех "
"зарегистрированных результатов вызывается :meth:`~TestResult.stop`."

#: ../../library/unittest.rst:2554
msgid ""
"Register a :class:`TestResult` object for control-c handling. Registering a "
"result stores a weak reference to it, so it doesn't prevent the result from "
"being garbage collected."
msgstr ""
"Зарегистрируйте объект :class:`TestResult` для обработки control-c. При "
"регистрации результата сохраняется слабая ссылка на него, поэтому это не "
"предотвращает сбор мусора."

#: ../../library/unittest.rst:2558
msgid ""
"Registering a :class:`TestResult` object has no side-effects if control-c "
"handling is not enabled, so test frameworks can unconditionally register all "
"results they create independently of whether or not handling is enabled."
msgstr ""
"Регистрация объекта :class:`TestResult` не имеет побочных эффектов, если "
"обработка control-c не включена, поэтому среды тестирования могут "
"безоговорочно регистрировать все результаты, которые они создают, независимо "
"от того, включена ли обработка."

#: ../../library/unittest.rst:2565
msgid ""
"Remove a registered result. Once a result has been removed then :meth:"
"`~TestResult.stop` will no longer be called on that result object in "
"response to a control-c."
msgstr ""
"Удалить зарегистрированный результат. Как только результат будет удален, :"
"meth:`~TestResult.stop` больше не будет вызываться для этого объекта "
"результата в ответ на control-c."

#: ../../library/unittest.rst:2572
msgid ""
"When called without arguments this function removes the control-c handler if "
"it has been installed. This function can also be used as a test decorator to "
"temporarily remove the handler while the test is being executed::"
msgstr ""
"При вызове без аргументов эта функция удаляет обработчик control-c, если он "
"был установлен. Эту функцию также можно использовать в качестве декоратора "
"теста для временного удаления обработчика во время выполнения теста:"

#: ../../library/unittest.rst:2576
msgid ""
"@unittest.removeHandler\n"
"def test_signal_handling(self):\n"
"    ..."
msgstr ""
"@unittest.removeHandler\n"
"def test_signal_handling(self):\n"
"    ..."
