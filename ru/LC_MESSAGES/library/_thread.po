# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 15:28+0000\n"
"PO-Revision-Date: 2023-05-24 02:20+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/_thread.rst:2
msgid ":mod:`_thread` --- Low-level threading API"
msgstr ":mod:`_thread` --- Низкоуровневый потоковый API"

#: ../../library/_thread.rst:15
msgid ""
"This module provides low-level primitives for working with multiple threads "
"(also called :dfn:`light-weight processes` or :dfn:`tasks`) --- multiple "
"threads of control sharing their global data space.  For synchronization, "
"simple locks (also called :dfn:`mutexes` or :dfn:`binary semaphores`) are "
"provided. The :mod:`threading` module provides an easier to use and higher-"
"level threading API built on top of this module."
msgstr ""
"Этот модуль предоставляет низкоуровневые примитивы для работы с несколькими "
"потоками (также называемыми :dfn:`легкими процессами` или :dfn:`tasks`) --- "
"несколькими потоками управления, совместно использующими свое глобальное "
"пространство данных. Для синхронизации предусмотрены простые блокировки "
"(также называемые :dfn:`мьютексы` или :dfn:`бинарные семафоры`). Модуль :mod:"
"`threading` предоставляет более простой в использовании API-интерфейс "
"многопоточности более высокого уровня, построенный на основе этого модуля."

#: ../../library/_thread.rst:26
msgid "This module used to be optional, it is now always available."
msgstr "Раньше этот модуль был необязательным, теперь он всегда доступен."

#: ../../library/_thread.rst:29
msgid "This module defines the following constants and functions:"
msgstr "Этот модуль определяет следующие константы и функции:"

#: ../../library/_thread.rst:33
msgid "Raised on thread-specific errors."
msgstr "Возникает из-за ошибок, специфичных для потока."

#: ../../library/_thread.rst:35
msgid "This is now a synonym of the built-in :exc:`RuntimeError`."
msgstr "Теперь это синоним встроенной ошибки :exc:`RuntimeError`."

#: ../../library/_thread.rst:41
msgid "This is the type of lock objects."
msgstr "Это тип блокировки объектов."

#: ../../library/_thread.rst:46
msgid ""
"Start a new thread and return its identifier.  The thread executes the "
"function *function* with the argument list *args* (which must be a tuple). "
"The optional *kwargs* argument specifies a dictionary of keyword arguments."
msgstr ""
"Запустите новый поток и верните его идентификатор. Поток выполняет функцию "
"*function* со списком аргументов *args* (который должен быть кортежем). "
"Необязательный аргумент *kwargs* указывает словарь аргументов ключевых слов."

#: ../../library/_thread.rst:50
msgid "When the function returns, the thread silently exits."
msgstr "Когда функция завершает работу, поток автоматически завершает работу."

#: ../../library/_thread.rst:52
msgid ""
"When the function terminates with an unhandled exception, :func:`sys."
"unraisablehook` is called to handle the exception. The *object* attribute of "
"the hook argument is *function*. By default, a stack trace is printed and "
"then the thread exits (but other threads continue to run)."
msgstr ""
"Когда функция завершается с необработанным исключением, вызывается :func:"
"`sys.unraisablehook` для обработки исключения. Атрибут *object* аргумента "
"ловушки — *function*. По умолчанию выводится трассировка стека, а затем "
"поток завершается (но другие потоки продолжают выполняться)."

#: ../../library/_thread.rst:57
msgid ""
"When the function raises a :exc:`SystemExit` exception, it is silently "
"ignored."
msgstr "Когда функция вызывает исключение :exc:`SystemExit`, оно игнорируется."

#: ../../library/_thread.rst:60
msgid ":func:`sys.unraisablehook` is now used to handle unhandled exceptions."
msgstr ""
":func:`sys.unraisablehook` теперь используется для обработки необработанных "
"исключений."

#: ../../library/_thread.rst:66
msgid ""
"Simulate the effect of a signal arriving in the main thread. A thread can "
"use this function to interrupt the main thread, though there is no guarantee "
"that the interruption will happen immediately."
msgstr ""
"Имитируйте эффект сигнала, поступающего в основной поток. Поток может "
"использовать эту функцию для прерывания основного потока, хотя нет никакой "
"гарантии, что прерывание произойдет немедленно."

#: ../../library/_thread.rst:70
msgid ""
"If given, *signum* is the number of the signal to simulate. If *signum* is "
"not given, :const:`signal.SIGINT` is simulated."
msgstr ""
"Если задано, *signum* — это номер сигнала для моделирования. Если *signum* "
"не задан, моделируется :const:`signal.SIGINT`."

#: ../../library/_thread.rst:73
msgid ""
"If the given signal isn't handled by Python (it was set to :const:`signal."
"SIG_DFL` or :const:`signal.SIG_IGN`), this function does nothing."
msgstr ""
"Если данный сигнал не обрабатывается Python (он был установлен в :const:"
"`signal.SIG_DFL` или :const:`signal.SIG_IGN`), эта функция ничего не делает."

#: ../../library/_thread.rst:77
msgid "The *signum* argument is added to customize the signal number."
msgstr "Аргумент *signum* добавляется для настройки номера сигнала."

#: ../../library/_thread.rst:81
msgid ""
"This does not emit the corresponding signal but schedules a call to the "
"associated handler (if it exists). If you want to truly emit the signal, "
"use :func:`signal.raise_signal`."
msgstr ""
"Это не выдает соответствующий сигнал, но планирует вызов связанного "
"обработчика (если он существует). Если вы хотите по-настоящему излучать "
"сигнал, используйте :func:`signal.raise_signal`."

#: ../../library/_thread.rst:88
msgid ""
"Raise the :exc:`SystemExit` exception.  When not caught, this will cause the "
"thread to exit silently."
msgstr ""
"Вызовите исключение :exc:`SystemExit`. Если его не поймать, это приведет к "
"тихому завершению потока."

#: ../../library/_thread.rst:102
msgid ""
"Return a new lock object.  Methods of locks are described below.  The lock "
"is initially unlocked."
msgstr ""
"Верните новый объект блокировки. Способы блокировок описаны ниже. Замок "
"изначально разблокирован."

#: ../../library/_thread.rst:108
msgid ""
"Return the 'thread identifier' of the current thread.  This is a nonzero "
"integer.  Its value has no direct meaning; it is intended as a magic cookie "
"to be used e.g. to index a dictionary of thread-specific data.  Thread "
"identifiers may be recycled when a thread exits and another thread is "
"created."
msgstr ""
"Возвращает «идентификатор потока» текущего потока. Это ненулевое целое "
"число. Его значение не имеет прямого значения; он задуман как волшебный файл "
"cookie, который можно использовать, например, для индексации словаря данных, "
"специфичных для потока. Идентификаторы потоков могут быть переработаны при "
"выходе из потока и создании другого потока."

#: ../../library/_thread.rst:116
msgid ""
"Return the native integral Thread ID of the current thread assigned by the "
"kernel. This is a non-negative integer. Its value may be used to uniquely "
"identify this particular thread system-wide (until the thread terminates, "
"after which the value may be recycled by the OS)."
msgstr ""
"Возвращает собственный целочисленный идентификатор потока текущего потока, "
"назначенный ядром. Это неотрицательное целое число. Его значение может "
"использоваться для уникальной идентификации этого конкретного потока в "
"масштабе всей системы (до тех пор, пока поток не завершится, после чего "
"значение может быть повторно использовано ОС)."

#: ../../library/_thread.rst:121
msgid ""
":ref:`Availability <availability>`: Windows, FreeBSD, Linux, macOS, OpenBSD, "
"NetBSD, AIX."
msgstr ""

#: ../../library/_thread.rst:128
msgid ""
"Return the thread stack size used when creating new threads.  The optional "
"*size* argument specifies the stack size to be used for subsequently created "
"threads, and must be 0 (use platform or configured default) or a positive "
"integer value of at least 32,768 (32 KiB). If *size* is not specified, 0 is "
"used.  If changing the thread stack size is unsupported, a :exc:"
"`RuntimeError` is raised.  If the specified stack size is invalid, a :exc:"
"`ValueError` is raised and the stack size is unmodified.  32 KiB is "
"currently the minimum supported stack size value to guarantee sufficient "
"stack space for the interpreter itself.  Note that some platforms may have "
"particular restrictions on values for the stack size, such as requiring a "
"minimum stack size > 32 KiB or requiring allocation in multiples of the "
"system memory page size - platform documentation should be referred to for "
"more information (4 KiB pages are common; using multiples of 4096 for the "
"stack size is the suggested approach in the absence of more specific "
"information)."
msgstr ""
"Возвращает размер стека потоков, используемый при создании новых потоков. "
"Необязательный аргумент *size* указывает размер стека, который будет "
"использоваться для последующих создаваемых потоков, и должен быть равен 0 "
"(используйте платформу или настроенное по умолчанию) или положительному "
"целому значению не менее 32 768 (32 КиБ). Если *размер* не указан, "
"используется 0. Если изменение размера стека потока не поддерживается, "
"выдается ошибка :exc:`RuntimeError`. Если указанный размер стека "
"недействителен, возникает ошибка :exc:`ValueError` и размер стека не "
"изменяется. 32 КиБ в настоящее время является минимальным поддерживаемым "
"значением размера стека, гарантирующим достаточно места в стеке для самого "
"интерпретатора. Обратите внимание, что на некоторых платформах могут быть "
"особые ограничения на значения размера стека, например, требование "
"минимального размера стека> 32 КБ или требование выделения, кратного размеру "
"страницы системной памяти. Для получения дополнительной информации следует "
"обратиться к документации платформы (страницы 4 КБ). распространены; при "
"отсутствии более конкретной информации рекомендуется использовать размер "
"стека, кратный 4096)."

#: ../../library/_thread.rst:143
msgid ":ref:`Availability <availability>`: Windows, pthreads."
msgstr ":ref:`Availability <availability>`: Windows, pthreads."

#: ../../library/_thread.rst:145
msgid "Unix platforms with POSIX threads support."
msgstr "Платформы Unix с поддержкой потоков POSIX."

#: ../../library/_thread.rst:150
msgid ""
"The maximum value allowed for the *timeout* parameter of :meth:`Lock.acquire "
"<threading.Lock.acquire>`. Specifying a timeout greater than this value will "
"raise an :exc:`OverflowError`."
msgstr ""
"Максимальное значение, допустимое для параметра *timeout* функции :meth:"
"`Lock.acquire <threading.Lock.acquire>`. Указание таймаута, превышающего это "
"значение, вызовет ошибку :exc:`OverflowError`."

#: ../../library/_thread.rst:157
msgid "Lock objects have the following methods:"
msgstr "Объекты блокировки имеют следующие методы:"

#: ../../library/_thread.rst:162
msgid ""
"Without any optional argument, this method acquires the lock "
"unconditionally, if necessary waiting until it is released by another thread "
"(only one thread at a time can acquire a lock --- that's their reason for "
"existence)."
msgstr ""
"Без какого-либо дополнительного аргумента этот метод получает блокировку "
"безоговорочно, при необходимости ожидая, пока она не будет освобождена "
"другим потоком (только один поток за раз может получить блокировку - это "
"причина их существования)."

#: ../../library/_thread.rst:166
msgid ""
"If the *blocking* argument is present, the action depends on its value: if "
"it is False, the lock is only acquired if it can be acquired immediately "
"without waiting, while if it is True, the lock is acquired unconditionally "
"as above."
msgstr ""

#: ../../library/_thread.rst:171
msgid ""
"If the floating-point *timeout* argument is present and positive, it "
"specifies the maximum wait time in seconds before returning.  A negative "
"*timeout* argument specifies an unbounded wait.  You cannot specify a "
"*timeout* if *blocking* is False."
msgstr ""

#: ../../library/_thread.rst:176
msgid ""
"The return value is ``True`` if the lock is acquired successfully, ``False`` "
"if not."
msgstr ""
"Возвращаемое значение — «True», если блокировка получена успешно, и «False», "
"если нет."

#: ../../library/_thread.rst:179
msgid "The *timeout* parameter is new."
msgstr "Параметр *timeout* является новым."

#: ../../library/_thread.rst:182
msgid "Lock acquires can now be interrupted by signals on POSIX."
msgstr "Получение блокировки теперь может быть прервано сигналами POSIX."

#: ../../library/_thread.rst:188
msgid ""
"Releases the lock.  The lock must have been acquired earlier, but not "
"necessarily by the same thread."
msgstr ""
"Освобождает замок. Блокировка должна быть получена ранее, но не обязательно "
"тем же потоком."

#: ../../library/_thread.rst:194
msgid ""
"Return the status of the lock: ``True`` if it has been acquired by some "
"thread, ``False`` if not."
msgstr ""
"Возвращает статус блокировки: ``True``, если она была получена каким-либо "
"потоком, ``False``, если нет."

#: ../../library/_thread.rst:197
msgid ""
"In addition to these methods, lock objects can also be used via the :keyword:"
"`with` statement, e.g.::"
msgstr ""
"В дополнение к этим методам, объекты блокировки также могут быть "
"использованы с помощью инструкции :keyword:`with`, например::"

#: ../../library/_thread.rst:207
msgid "**Caveats:**"
msgstr "** Пещеры:**"

#: ../../library/_thread.rst:211
msgid ""
"Threads interact strangely with interrupts: the :exc:`KeyboardInterrupt` "
"exception will be received by an arbitrary thread.  (When the :mod:`signal` "
"module is available, interrupts always go to the main thread.)"
msgstr ""
"Потоки странно взаимодействуют с прерываниями: исключение :exc:"
"`KeyboardInterrupt` будет получено произвольным потоком. (Когда доступен "
"модуль :mod:`signal`, прерывания всегда передаются в основной поток.)"

#: ../../library/_thread.rst:215
msgid ""
"Calling :func:`sys.exit` or raising the :exc:`SystemExit` exception is "
"equivalent to calling :func:`_thread.exit`."
msgstr ""
"Вызов :func:`sys.exit` или создание исключения :exc:`SystemExit` "
"эквивалентен вызову :func:`_thread.exit`."

#: ../../library/_thread.rst:218
msgid ""
"It is not possible to interrupt the :meth:`~threading.Lock.acquire` method "
"on a lock --- the :exc:`KeyboardInterrupt` exception will happen after the "
"lock has been acquired."
msgstr ""
"Невозможно прервать метод :meth:`~threading.Lock.acquire` при блокировке --- "
"исключение :exc:`KeyboardInterrupt` произойдет после получения блокировки."

#: ../../library/_thread.rst:222
msgid ""
"When the main thread exits, it is system defined whether the other threads "
"survive.  On most systems, they are killed without executing :keyword:"
"`try` ... :keyword:`finally` clauses or executing object destructors."
msgstr ""
"Когда основной поток завершает работу, система определяет, выживут ли другие "
"потоки. В большинстве систем они уничтожаются без выполнения предложений :"
"keyword:`try` ... :keyword:`finally` или выполнения деструкторов объектов."

#: ../../library/_thread.rst:227
msgid ""
"When the main thread exits, it does not do any of its usual cleanup (except "
"that :keyword:`try` ... :keyword:`finally` clauses are honored), and the "
"standard I/O files are not flushed."
msgstr ""
"Когда основной поток завершает работу, он не выполняет никакой обычной "
"очистки (за исключением того, что выполняются условия :keyword:`try` ... :"
"keyword:`finally`), и стандартные файлы ввода-вывода не сбрасываются."

#: ../../library/_thread.rst:7
msgid "light-weight processes"
msgstr "легкие процессы"

#: ../../library/_thread.rst:7
msgid "processes, light-weight"
msgstr "процессы, легкий вес"

#: ../../library/_thread.rst:7
msgid "binary semaphores"
msgstr "двоичные семафоры"

#: ../../library/_thread.rst:7
msgid "semaphores, binary"
msgstr "семафоры, двоичные"

#: ../../library/_thread.rst:22
msgid "pthreads"
msgstr "pthreads"

#: ../../library/_thread.rst:22
msgid "threads"
msgstr "поток"

#: ../../library/_thread.rst:22
msgid "POSIX"
msgstr "POSIX"

#: ../../library/_thread.rst:209
msgid "module"
msgstr "модуль"

#: ../../library/_thread.rst:209
msgid "signal"
msgstr "сигнал"
