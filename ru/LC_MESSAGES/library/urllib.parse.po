# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 16:02+0000\n"
"PO-Revision-Date: 2022-11-05 17:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/urllib.parse.rst:2
msgid ":mod:`urllib.parse` --- Parse URLs into components"
msgstr ""

#: ../../library/urllib.parse.rst:7
msgid "**Source code:** :source:`Lib/urllib/parse.py`"
msgstr "**Исходный код:** :source:`Lib/urllib/parse.py`"

#: ../../library/urllib.parse.rst:18
msgid ""
"This module defines a standard interface to break Uniform Resource Locator "
"(URL) strings up in components (addressing scheme, network location, path "
"etc.), to combine the components back into a URL string, and to convert a "
"\"relative URL\" to an absolute URL given a \"base URL.\""
msgstr ""
"Этот модуль определяет стандартный интерфейс для разбиения строк Uniform "
"Resource Locator (URL) на компоненты (схема адресации, сетевое расположение, "
"путь и т. д.), объединения компонентов обратно в строку URL-адреса и "
"преобразования «относительного URL-адреса» в абсолютный URL-адрес с учетом "
"«базового URL-адреса»."

#: ../../library/urllib.parse.rst:23
msgid ""
"The module has been designed to match the internet RFC on Relative Uniform "
"Resource Locators. It supports the following URL schemes: ``file``, ``ftp``, "
"``gopher``, ``hdl``, ``http``, ``https``, ``imap``, ``mailto``, ``mms``, "
"``news``, ``nntp``, ``prospero``, ``rsync``, ``rtsp``, ``rtspu``, ``sftp``, "
"``shttp``, ``sip``, ``sips``, ``snews``, ``svn``, ``svn+ssh``, ``telnet``, "
"``wais``, ``ws``, ``wss``."
msgstr ""

#: ../../library/urllib.parse.rst:30
msgid ""
"The :mod:`urllib.parse` module defines functions that fall into two broad "
"categories: URL parsing and URL quoting. These are covered in detail in the "
"following sections."
msgstr ""
"Модуль :mod:`urllib.parse` определяет функции, которые делятся на две "
"большие категории: анализ URL-адресов и цитирование URL-адресов. Они "
"подробно описаны в следующих разделах."

#: ../../library/urllib.parse.rst:35
msgid "URL Parsing"
msgstr "Анализ URL-адресов"

#: ../../library/urllib.parse.rst:37
msgid ""
"The URL parsing functions focus on splitting a URL string into its "
"components, or on combining URL components into a URL string."
msgstr ""
"Функции анализа URL-адресов сосредоточены на разделении строки URL-адреса на "
"ее компоненты или на объединении компонентов URL-адреса в строку URL-адреса."

#: ../../library/urllib.parse.rst:42
msgid ""
"Parse a URL into six components, returning a 6-item :term:`named tuple`.  "
"This corresponds to the general structure of a URL: ``scheme://netloc/path;"
"parameters?query#fragment``. Each tuple item is a string, possibly empty. "
"The components are not broken up into smaller parts (for example, the "
"network location is a single string), and % escapes are not expanded. The "
"delimiters as shown above are not part of the result, except for a leading "
"slash in the *path* component, which is retained if present.  For example:"
msgstr ""
"Разобрать URL-адрес на шесть компонентов, вернув :term:`named tuple` из 6 "
"элементов. Это соответствует общей структуре URL: ``scheme://netloc/path;"
"parameters?query#fragment``. Каждый элемент кортежа представляет собой "
"строку, возможно, пустую. Компоненты не разбиваются на более мелкие части "
"(например, сетевое расположение представляет собой одну строку), а escape-"
"символы % не расширяются. Разделители, показанные выше, не являются частью "
"результата, за исключением косой черты в компоненте *path*, которая "
"сохраняется, если присутствует. Например:"

#: ../../library/urllib.parse.rst:75
msgid ""
"Following the syntax specifications in :rfc:`1808`, urlparse recognizes a "
"netloc only if it is properly introduced by '//'.  Otherwise the input is "
"presumed to be a relative URL and thus to start with a path component."
msgstr ""
"Следуя спецификациям синтаксиса в :rfc:`1808`, urlparse распознает netloc "
"только в том случае, если он правильно введен с помощью '//'. В противном "
"случае предполагается, что входные данные представляют собой относительный "
"URL-адрес и, следовательно, начинаются с компонента пути."

#: ../../library/urllib.parse.rst:94
msgid ""
"The *scheme* argument gives the default addressing scheme, to be used only "
"if the URL does not specify one.  It should be the same type (text or bytes) "
"as *urlstring*, except that the default value ``''`` is always allowed, and "
"is automatically converted to ``b''`` if appropriate."
msgstr ""
"Аргумент *scheme* задает схему адресации по умолчанию, которая будет "
"использоваться только в том случае, если в URL-адресе она не указана. Он "
"должен быть того же типа (текст или байты), что и *urlstring*, за "
"исключением того, что значение по умолчанию ``''`` всегда разрешено и "
"автоматически преобразуется в ``b''``, если это необходимо."

#: ../../library/urllib.parse.rst:99
msgid ""
"If the *allow_fragments* argument is false, fragment identifiers are not "
"recognized.  Instead, they are parsed as part of the path, parameters or "
"query component, and :attr:`fragment` is set to the empty string in the "
"return value."
msgstr ""
"Если аргумент *allow_fragments* имеет значение false, идентификаторы "
"фрагментов не распознаются. Вместо этого они анализируются как часть пути, "
"параметров или компонента запроса, а :attr:`fragment` устанавливается в "
"пустую строку в возвращаемом значении."

#: ../../library/urllib.parse.rst:104
msgid ""
"The return value is a :term:`named tuple`, which means that its items can be "
"accessed by index or as named attributes, which are:"
msgstr ""
"Возвращаемое значение представляет собой именованный кортеж, что означает, "
"что доступ к его элементам можно получить по индексу или через именованные "
"атрибуты, а именно:"

#: ../../library/urllib.parse.rst:108 ../../library/urllib.parse.rst:297
#: ../../library/urllib.parse.rst:410
msgid "Attribute"
msgstr "Атрибут"

#: ../../library/urllib.parse.rst:108 ../../library/urllib.parse.rst:297
#: ../../library/urllib.parse.rst:410
msgid "Index"
msgstr "Индекс"

#: ../../library/urllib.parse.rst:108 ../../library/urllib.parse.rst:297
#: ../../library/urllib.parse.rst:410
msgid "Value"
msgstr "Значение"

#: ../../library/urllib.parse.rst:108 ../../library/urllib.parse.rst:297
#: ../../library/urllib.parse.rst:410
msgid "Value if not present"
msgstr "Значение, если отсутствует"

#: ../../library/urllib.parse.rst:110 ../../library/urllib.parse.rst:299
msgid ":attr:`scheme`"
msgstr ":attr:`scheme`"

#: ../../library/urllib.parse.rst:110 ../../library/urllib.parse.rst:299
#: ../../library/urllib.parse.rst:412
msgid "0"
msgstr "0"

#: ../../library/urllib.parse.rst:110 ../../library/urllib.parse.rst:299
msgid "URL scheme specifier"
msgstr "Спецификатор схемы URL-адресов"

#: ../../library/urllib.parse.rst:110 ../../library/urllib.parse.rst:299
msgid "*scheme* parameter"
msgstr "параметр *схема*"

#: ../../library/urllib.parse.rst:112 ../../library/urllib.parse.rst:301
msgid ":attr:`netloc`"
msgstr ":attr:`netloc`"

#: ../../library/urllib.parse.rst:112 ../../library/urllib.parse.rst:301
#: ../../library/urllib.parse.rst:414
msgid "1"
msgstr "1"

#: ../../library/urllib.parse.rst:112 ../../library/urllib.parse.rst:301
msgid "Network location part"
msgstr "Часть сетевого местоположения"

#: ../../library/urllib.parse.rst:112 ../../library/urllib.parse.rst:114
#: ../../library/urllib.parse.rst:116 ../../library/urllib.parse.rst:119
#: ../../library/urllib.parse.rst:121 ../../library/urllib.parse.rst:301
#: ../../library/urllib.parse.rst:303 ../../library/urllib.parse.rst:305
#: ../../library/urllib.parse.rst:307 ../../library/urllib.parse.rst:412
#: ../../library/urllib.parse.rst:414
msgid "empty string"
msgstr "пустая строка"

#: ../../library/urllib.parse.rst:114 ../../library/urllib.parse.rst:303
msgid ":attr:`path`"
msgstr ":attr:`path`"

#: ../../library/urllib.parse.rst:114 ../../library/urllib.parse.rst:303
msgid "2"
msgstr "2"

#: ../../library/urllib.parse.rst:114 ../../library/urllib.parse.rst:303
msgid "Hierarchical path"
msgstr "Иерархический путь"

#: ../../library/urllib.parse.rst:116
msgid ":attr:`params`"
msgstr ":attr:`params`"

#: ../../library/urllib.parse.rst:116 ../../library/urllib.parse.rst:305
msgid "3"
msgstr "3"

#: ../../library/urllib.parse.rst:116
msgid "Parameters for last path element"
msgstr "Параметры для последнего элемента пути"

#: ../../library/urllib.parse.rst:119 ../../library/urllib.parse.rst:305
msgid ":attr:`query`"
msgstr ":attr:`query`"

#: ../../library/urllib.parse.rst:119 ../../library/urllib.parse.rst:307
msgid "4"
msgstr "4"

#: ../../library/urllib.parse.rst:119 ../../library/urllib.parse.rst:305
msgid "Query component"
msgstr "Компонент запроса"

#: ../../library/urllib.parse.rst:121 ../../library/urllib.parse.rst:307
#: ../../library/urllib.parse.rst:414
msgid ":attr:`fragment`"
msgstr ":attr:`fragment`"

#: ../../library/urllib.parse.rst:121
msgid "5"
msgstr "5"

#: ../../library/urllib.parse.rst:121 ../../library/urllib.parse.rst:307
#: ../../library/urllib.parse.rst:414
msgid "Fragment identifier"
msgstr "Идентификатор фрагмента"

#: ../../library/urllib.parse.rst:123 ../../library/urllib.parse.rst:309
msgid ":attr:`username`"
msgstr ":attr:`username`"

#: ../../library/urllib.parse.rst:123 ../../library/urllib.parse.rst:309
msgid "User name"
msgstr "Имя пользователя"

#: ../../library/urllib.parse.rst:123 ../../library/urllib.parse.rst:125
#: ../../library/urllib.parse.rst:127 ../../library/urllib.parse.rst:129
#: ../../library/urllib.parse.rst:309 ../../library/urllib.parse.rst:311
#: ../../library/urllib.parse.rst:313 ../../library/urllib.parse.rst:315
msgid ":const:`None`"
msgstr ":const:`None`"

#: ../../library/urllib.parse.rst:125 ../../library/urllib.parse.rst:311
msgid ":attr:`password`"
msgstr ":attr:`password`"

#: ../../library/urllib.parse.rst:125 ../../library/urllib.parse.rst:311
msgid "Password"
msgstr "Пароль"

#: ../../library/urllib.parse.rst:127 ../../library/urllib.parse.rst:313
msgid ":attr:`hostname`"
msgstr ":attr:`hostname`"

#: ../../library/urllib.parse.rst:127 ../../library/urllib.parse.rst:313
msgid "Host name (lower case)"
msgstr "Имя хоста (нижний регистр)"

#: ../../library/urllib.parse.rst:129 ../../library/urllib.parse.rst:315
msgid ":attr:`port`"
msgstr ":attr:`port`"

#: ../../library/urllib.parse.rst:129 ../../library/urllib.parse.rst:315
msgid "Port number as integer, if present"
msgstr "Номер порта в виде целого числа, если он присутствует."

#: ../../library/urllib.parse.rst:133 ../../library/urllib.parse.rst:319
msgid ""
"Reading the :attr:`port` attribute will raise a :exc:`ValueError` if an "
"invalid port is specified in the URL.  See section :ref:`urlparse-result-"
"object` for more information on the result object."
msgstr ""
"Чтение атрибута :attr:`port` вызовет ошибку :exc:`ValueError`, если в URL-"
"адресе указан недопустимый порт. См. раздел :ref:`urlparse-result-object` "
"для получения дополнительной информации об объекте результата."

#: ../../library/urllib.parse.rst:137 ../../library/urllib.parse.rst:323
msgid ""
"Unmatched square brackets in the :attr:`netloc` attribute will raise a :exc:"
"`ValueError`."
msgstr ""
"Несовпадающие квадратные скобки в атрибуте :attr:`netloc` вызовут ошибку :"
"exc:`ValueError`."

#: ../../library/urllib.parse.rst:140 ../../library/urllib.parse.rst:326
msgid ""
"Characters in the :attr:`netloc` attribute that decompose under NFKC "
"normalization (as used by the IDNA encoding) into any of ``/``, ``?``, "
"``#``, ``@``, or ``:`` will raise a :exc:`ValueError`. If the URL is "
"decomposed before parsing, no error will be raised."
msgstr ""
"Символы в атрибуте :attr:`netloc`, которые при нормализации NFKC "
"(используемые кодировкой IDNA) разлагаются на любые из ``/``, ``?``, ``#``, "
"``@``, или ``:`` вызовет :exc:`ValueError`. Если URL-адрес разложен перед "
"анализом, ошибка не возникнет."

#: ../../library/urllib.parse.rst:145
msgid ""
"As is the case with all named tuples, the subclass has a few additional "
"methods and attributes that are particularly useful. One such method is :"
"meth:`_replace`. The :meth:`_replace` method will return a new ParseResult "
"object replacing specified fields with new values."
msgstr ""
"Как и в случае со всеми именованными кортежами, у подкласса есть несколько "
"дополнительных методов и атрибутов, которые особенно полезны. Одним из таких "
"методов является :meth:`_replace`. Метод :meth:`_replace` вернет новый "
"объект ParseResult, заменив указанные поля новыми значениями."

#: ../../library/urllib.parse.rst:164
msgid ""
":func:`urlparse` does not perform validation.  See :ref:`URL parsing "
"security <url-parsing-security>` for details."
msgstr ""
":func:`urlparse` не выполняет проверку. Дополнительную информацию см. в "
"разделе :ref:`Безопасность анализа URL-адресов <url-parsing-security>`."

#: ../../library/urllib.parse.rst:167
msgid "Added IPv6 URL parsing capabilities."
msgstr "Добавлены возможности анализа URL-адресов IPv6."

#: ../../library/urllib.parse.rst:170
msgid ""
"The fragment is now parsed for all URL schemes (unless *allow_fragment* is "
"false), in accordance with :rfc:`3986`.  Previously, an allowlist of schemes "
"that support fragments existed."
msgstr ""

#: ../../library/urllib.parse.rst:175 ../../library/urllib.parse.rst:340
msgid ""
"Out-of-range port numbers now raise :exc:`ValueError`, instead of returning :"
"const:`None`."
msgstr ""
"Номера портов, выходящих за пределы диапазона, теперь вызывают :exc:"
"`ValueError` вместо возврата :const:`None`."

#: ../../library/urllib.parse.rst:179 ../../library/urllib.parse.rst:344
msgid ""
"Characters that affect netloc parsing under NFKC normalization will now "
"raise :exc:`ValueError`."
msgstr ""
"Символы, влияющие на синтаксический анализ netloc при нормализации NFKC, "
"теперь будут вызывать :exc:`ValueError`."

#: ../../library/urllib.parse.rst:186
msgid ""
"Parse a query string given as a string argument (data of type :mimetype:"
"`application/x-www-form-urlencoded`).  Data are returned as a dictionary.  "
"The dictionary keys are the unique query variable names and the values are "
"lists of values for each name."
msgstr ""
"Разобрать строку запроса, заданную как строковый аргумент (данные типа :"
"mimetype:`application/x-www-form-urlencoded`). Данные возвращаются в виде "
"словаря. Ключи словаря — это уникальные имена переменных запроса, а значения "
"— это списки значений для каждого имени."

#: ../../library/urllib.parse.rst:191 ../../library/urllib.parse.rst:236
msgid ""
"The optional argument *keep_blank_values* is a flag indicating whether blank "
"values in percent-encoded queries should be treated as blank strings. A true "
"value indicates that blanks should be retained as  blank strings.  The "
"default false value indicates that blank values are to be ignored and "
"treated as if they were not included."
msgstr ""
"Необязательный аргумент *keep_blank_values* — это флаг, указывающий, следует "
"ли рассматривать пустые значения в запросах с процентным кодированием как "
"пустые строки. Значение true указывает, что пробелы следует сохранять как "
"пустые строки. Значение false по умолчанию указывает, что пустые значения "
"следует игнорировать и обрабатывать так, как если бы они не были включены."

#: ../../library/urllib.parse.rst:197 ../../library/urllib.parse.rst:242
msgid ""
"The optional argument *strict_parsing* is a flag indicating what to do with "
"parsing errors.  If false (the default), errors are silently ignored.  If "
"true, errors raise a :exc:`ValueError` exception."
msgstr ""
"Необязательный аргумент *strict_parsing* — это флаг, указывающий, что делать "
"с ошибками синтаксического анализа. Если значение false (по умолчанию), "
"ошибки игнорируются. Если это правда, ошибки вызывают исключение :exc:"
"`ValueError`."

#: ../../library/urllib.parse.rst:201 ../../library/urllib.parse.rst:246
msgid ""
"The optional *encoding* and *errors* parameters specify how to decode "
"percent-encoded sequences into Unicode characters, as accepted by the :meth:"
"`bytes.decode` method."
msgstr ""
"Необязательные параметры *encoding* и *errors* определяют, как декодировать "
"последовательности, закодированные в процентах, в символы Юникода, принятые "
"методом :meth:`bytes.decode`."

#: ../../library/urllib.parse.rst:205 ../../library/urllib.parse.rst:250
msgid ""
"The optional argument *max_num_fields* is the maximum number of fields to "
"read. If set, then throws a :exc:`ValueError` if there are more than "
"*max_num_fields* fields read."
msgstr ""
"Необязательный аргумент *max_num_fields* — это максимальное количество полей "
"для чтения. Если установлено, то выдается :exc:`ValueError`, если прочитано "
"более *max_num_fields* полей."

#: ../../library/urllib.parse.rst:209 ../../library/urllib.parse.rst:254
msgid ""
"The optional argument *separator* is the symbol to use for separating the "
"query arguments. It defaults to ``&``."
msgstr ""
"Необязательный аргумент *separator* — это символ, используемый для "
"разделения аргументов запроса. По умолчанию это ``&``."

#: ../../library/urllib.parse.rst:212
msgid ""
"Use the :func:`urllib.parse.urlencode` function (with the ``doseq`` "
"parameter set to ``True``) to convert such dictionaries into query strings."
msgstr ""
"Используйте функцию :func:`urllib.parse.urlencode` (с параметром ``doseq``, "
"установленным в ``True``), чтобы преобразовать такие словари в строки "
"запроса."

#: ../../library/urllib.parse.rst:217 ../../library/urllib.parse.rst:260
msgid "Add *encoding* and *errors* parameters."
msgstr "Добавьте параметры *encoding* и *errors*."

#: ../../library/urllib.parse.rst:220 ../../library/urllib.parse.rst:263
msgid "Added *max_num_fields* parameter."
msgstr "Добавлен параметр *max_num_fields*."

#: ../../library/urllib.parse.rst:223 ../../library/urllib.parse.rst:266
msgid ""
"Added *separator* parameter with the default value of ``&``. Python versions "
"earlier than Python 3.10 allowed using both ``;`` and ``&`` as query "
"parameter separator. This has been changed to allow only a single separator "
"key, with ``&`` as the default separator."
msgstr ""
"Добавлен параметр *separator* со значением по умолчанию ``&``. Версии "
"Python, предшествующие Python 3.10, позволяли использовать как ``;``, так и "
"``&`` в качестве разделителя параметров запроса. Это было изменено, чтобы "
"разрешить использование только одного ключа-разделителя с ``&`` в качестве "
"разделителя по умолчанию."

#: ../../library/urllib.parse.rst:232
msgid ""
"Parse a query string given as a string argument (data of type :mimetype:"
"`application/x-www-form-urlencoded`).  Data are returned as a list of name, "
"value pairs."
msgstr ""
"Разобрать строку запроса, заданную как строковый аргумент (данные типа :"
"mimetype:`application/x-www-form-urlencoded`). Данные возвращаются в виде "
"списка пар имя-значение."

#: ../../library/urllib.parse.rst:257
msgid ""
"Use the :func:`urllib.parse.urlencode` function to convert such lists of "
"pairs into query strings."
msgstr ""
"Используйте функцию :func:`urllib.parse.urlencode` для преобразования таких "
"списков пар в строки запроса."

#: ../../library/urllib.parse.rst:275
msgid ""
"Construct a URL from a tuple as returned by ``urlparse()``. The *parts* "
"argument can be any six-item iterable. This may result in a slightly "
"different, but equivalent URL, if the URL that was parsed originally had "
"unnecessary delimiters (for example, a ``?`` with an empty query; the RFC "
"states that these are equivalent)."
msgstr ""
"Создайте URL-адрес из кортежа, возвращаемого функцией urlparse(). Аргументом "
"*parts* может быть любая итерация из шести элементов. Это может привести к "
"получению немного другого, но эквивалентного URL-адреса, если URL-адрес, "
"который был проанализирован, изначально имел ненужные разделители (например, "
"``?`` с пустым запросом; RFC утверждает, что они эквивалентны)."

#: ../../library/urllib.parse.rst:284
msgid ""
"This is similar to :func:`urlparse`, but does not split the params from the "
"URL. This should generally be used instead of :func:`urlparse` if the more "
"recent URL syntax allowing parameters to be applied to each segment of the "
"*path* portion of the URL (see :rfc:`2396`) is wanted.  A separate function "
"is needed to separate the path segments and parameters.  This function "
"returns a 5-item :term:`named tuple`::"
msgstr ""
"Это похоже на :func:`urlparse`, но не отделяет параметры от URL-адреса. "
"Обычно его следует использовать вместо :func:`urlparse`, если требуется "
"более новый синтаксис URL-адреса, позволяющий применять параметры к каждому "
"сегменту части *path* URL-адреса (см. :rfc:`2396`). Для разделения сегментов "
"пути и параметров необходима отдельная функция. Эта функция возвращает :term:"
"`named tuple`:: из 5 элементов."

#: ../../library/urllib.parse.rst:293 ../../library/urllib.parse.rst:406
msgid ""
"The return value is a :term:`named tuple`, its items can be accessed by "
"index or as named attributes:"
msgstr ""
"Возвращаемое значение представляет собой именованный кортеж, доступ к его "
"элементам можно получить по индексу или как именованные атрибуты:"

#: ../../library/urllib.parse.rst:331
msgid ""
"Following some of the `WHATWG spec`_ that updates RFC 3986, leading C0 "
"control and space characters are stripped from the URL. ``\\n``, ``\\r`` and "
"tab ``\\t`` characters are removed from the URL at any position."
msgstr ""
"В соответствии с некоторыми спецификациями WHATWG, обновляющими RFC 3986, из "
"URL-адреса удаляются ведущие управляющие символы C0 и пробелы. Символы "
"``\\n``, ``\\r`` и табуляции ``\\t`` удаляются из URL-адреса в любой позиции."

#: ../../library/urllib.parse.rst:337
msgid ""
":func:`urlsplit` does not perform validation.  See :ref:`URL parsing "
"security <url-parsing-security>` for details."
msgstr ""
":func:`urlsplit` не выполняет проверку. Дополнительную информацию см. в "
"разделе :ref:`Безопасность анализа URL-адресов <url-parsing-security>`."

#: ../../library/urllib.parse.rst:348
msgid "ASCII newline and tab characters are stripped from the URL."
msgstr "Символы новой строки и табуляции ASCII удаляются из URL-адреса."

#: ../../library/urllib.parse.rst:351
msgid ""
"Leading WHATWG C0 control and space characters are stripped from the URL."
msgstr ""
"Из URL-адреса удаляются ведущие управляющие символы WHATWG C0 и пробелы."

#: ../../library/urllib.parse.rst:358
msgid ""
"Combine the elements of a tuple as returned by :func:`urlsplit` into a "
"complete URL as a string. The *parts* argument can be any five-item "
"iterable. This may result in a slightly different, but equivalent URL, if "
"the URL that was parsed originally had unnecessary delimiters (for example, "
"a ? with an empty query; the RFC states that these are equivalent)."
msgstr ""
"Объедините элементы кортежа, возвращаемые :func:`urlsplit`, в полный URL-"
"адрес в виде строки. Аргументом *parts* может быть любая итерация из пяти "
"элементов. Это может привести к получению немного другого, но эквивалентного "
"URL-адреса, если изначально анализируемый URL-адрес имел ненужные "
"разделители (например, знак ? с пустым запросом; в RFC указано, что они "
"эквивалентны)."

#: ../../library/urllib.parse.rst:367
msgid ""
"Construct a full (\"absolute\") URL by combining a \"base URL\" (*base*) "
"with another URL (*url*).  Informally, this uses components of the base URL, "
"in particular the addressing scheme, the network location and (part of) the "
"path, to provide missing components in the relative URL.  For example:"
msgstr ""
"Создайте полный («абсолютный») URL-адрес, объединив «базовый URL-"
"адрес» (*base*) с другим URL-адресом (*url*). Неофициально при этом "
"используются компоненты базового URL-адреса, в частности схема адресации, "
"сетевое расположение и (часть) пути, чтобы обеспечить недостающие компоненты "
"в относительном URL-адресе. Например:"

#: ../../library/urllib.parse.rst:376
msgid ""
"The *allow_fragments* argument has the same meaning and default as for :func:"
"`urlparse`."
msgstr ""
"Аргумент *allow_fragments* имеет то же значение и значение по умолчанию, что "
"и :func:`urlparse`."

#: ../../library/urllib.parse.rst:381
msgid ""
"If *url* is an absolute URL (that is, it starts with ``//`` or ``scheme://"
"``), the *url*'s hostname and/or scheme will be present in the result.  For "
"example:"
msgstr ""
"Если *url* является абсолютным URL-адресом (то есть он начинается с ``//`` "
"или ``scheme://``), в результате будет присутствовать имя хоста и/или схема "
"*url*. Например:"

#: ../../library/urllib.parse.rst:390
msgid ""
"If you do not want that behavior, preprocess the *url* with :func:`urlsplit` "
"and :func:`urlunsplit`, removing possible *scheme* and *netloc* parts."
msgstr ""
"Если вы не хотите такого поведения, предварительно обработайте *url* с "
"помощью :func:`urlsplit` и :func:`urlunsplit`, удалив возможные части "
"*scheme* и *netloc*."

#: ../../library/urllib.parse.rst:396
msgid "Behavior updated to match the semantics defined in :rfc:`3986`."
msgstr ""
"Поведение обновлено в соответствии с семантикой, определенной в :rfc:`3986`."

#: ../../library/urllib.parse.rst:401
msgid ""
"If *url* contains a fragment identifier, return a modified version of *url* "
"with no fragment identifier, and the fragment identifier as a separate "
"string.  If there is no fragment identifier in *url*, return *url* "
"unmodified and an empty string."
msgstr ""
"Если *url* содержит идентификатор фрагмента, верните измененную версию *url* "
"без идентификатора фрагмента и идентификатор фрагмента в виде отдельной "
"строки. Если в *url* нет идентификатора фрагмента, верните *url* без "
"изменений и пустую строку."

#: ../../library/urllib.parse.rst:412
msgid ":attr:`url`"
msgstr ":attr:`url`"

#: ../../library/urllib.parse.rst:412
msgid "URL with no fragment"
msgstr "URL без фрагмента"

#: ../../library/urllib.parse.rst:417
msgid ""
"See section :ref:`urlparse-result-object` for more information on the result "
"object."
msgstr ""
"См. раздел :ref:`urlparse-result-object` для получения дополнительной "
"информации об объекте результата."

#: ../../library/urllib.parse.rst:420
msgid "Result is a structured object rather than a simple 2-tuple."
msgstr ""
"Результатом является структурированный объект, а не простой кортеж из двух "
"элементов."

#: ../../library/urllib.parse.rst:425
msgid ""
"Extract the url from a wrapped URL (that is, a string formatted as ``<URL:"
"scheme://host/path>``, ``<scheme://host/path>``, ``URL:scheme://host/path`` "
"or ``scheme://host/path``). If *url* is not a wrapped URL, it is returned "
"without changes."
msgstr ""
"Извлеките URL-адрес из завернутого URL-адреса (то есть строки в формате "
"``<URL:scheme://host/path>``, ``<scheme://host/path>``, ``URL:scheme ://хост/"
"путь`` или ``схема://хост/путь``). Если *url* не является завернутым URL-"
"адресом, он возвращается без изменений."

#: ../../library/urllib.parse.rst:433
msgid "URL parsing security"
msgstr "Безопасность анализа URL-адресов"

#: ../../library/urllib.parse.rst:435
msgid ""
"The :func:`urlsplit` and :func:`urlparse` APIs do not perform **validation** "
"of inputs.  They may not raise errors on inputs that other applications "
"consider invalid.  They may also succeed on some inputs that might not be "
"considered URLs elsewhere.  Their purpose is for practical functionality "
"rather than purity."
msgstr ""
"API :func:`urlsplit` и :func:`urlparse` не выполняют **проверку** входных "
"данных. Они не могут вызывать ошибки при вводе, которые другие приложения "
"считают недействительными. Они также могут добиться успеха в некоторых "
"входных данных, которые в других местах не могут считаться URL-адресами. Их "
"цель – практическая функциональность, а не чистота."

#: ../../library/urllib.parse.rst:441
msgid ""
"Instead of raising an exception on unusual input, they may instead return "
"some component parts as empty strings. Or components may contain more than "
"perhaps they should."
msgstr ""
"Вместо того, чтобы вызывать исключение при необычном вводе, они могут "
"возвращать некоторые компоненты в виде пустых строк. Или компоненты могут "
"содержать больше, чем следовало бы."

#: ../../library/urllib.parse.rst:445
msgid ""
"We recommend that users of these APIs where the values may be used anywhere "
"with security implications code defensively. Do some verification within "
"your code before trusting a returned component part.  Does that ``scheme`` "
"make sense?  Is that a sensible ``path``?  Is there anything strange about "
"that ``hostname``?  etc."
msgstr ""
"Мы рекомендуем пользователям этих API, значения которых могут использоваться "
"где угодно, что может иметь последствия для безопасности, использовать "
"защитный код. Прежде чем доверять возвращенной части компонента, выполните "
"некоторую проверку кода. Имеет ли эта «схема» смысл? Это разумный «путь»? "
"Есть ли что-нибудь странное в этом «имени хоста»? и т. д."

#: ../../library/urllib.parse.rst:454
msgid "Parsing ASCII Encoded Bytes"
msgstr "Анализ байтов в кодировке ASCII"

#: ../../library/urllib.parse.rst:456
msgid ""
"The URL parsing functions were originally designed to operate on character "
"strings only. In practice, it is useful to be able to manipulate properly "
"quoted and encoded URLs as sequences of ASCII bytes. Accordingly, the URL "
"parsing functions in this module all operate on :class:`bytes` and :class:"
"`bytearray` objects in addition to :class:`str` objects."
msgstr ""
"Функции анализа URL-адресов изначально были разработаны для работы только со "
"строками символов. На практике полезно иметь возможность манипулировать "
"правильно заключенными и закодированными URL-адресами как "
"последовательностями байтов ASCII. Соответственно, все функции анализа URL-"
"адресов в этом модуле работают с объектами :class:`bytes` и :class:"
"`bytearray` в дополнение к объектам :class:`str`."

#: ../../library/urllib.parse.rst:462
msgid ""
"If :class:`str` data is passed in, the result will also contain only :class:"
"`str` data. If :class:`bytes` or :class:`bytearray` data is passed in, the "
"result will contain only :class:`bytes` data."
msgstr ""
"Если переданы данные :class:`str`, результат также будет содержать только "
"данные :class:`str`. Если переданы данные :class:`bytes` или :class:"
"`bytearray`, результат будет содержать только данные :class:`bytes`."

#: ../../library/urllib.parse.rst:466
msgid ""
"Attempting to mix :class:`str` data with :class:`bytes` or :class:"
"`bytearray` in a single function call will result in a :exc:`TypeError` "
"being raised, while attempting to pass in non-ASCII byte values will "
"trigger :exc:`UnicodeDecodeError`."
msgstr ""
"Попытка смешать данные :class:`str` с :class:`bytes` или :class:`bytearray` "
"в одном вызове функции приведет к возникновению :exc:`TypeError` при попытке "
"передать данные, отличные от ASCII. байтовые значения вызовут :exc:"
"`UnicodeDecodeError`."

#: ../../library/urllib.parse.rst:471
msgid ""
"To support easier conversion of result objects between :class:`str` and :"
"class:`bytes`, all return values from URL parsing functions provide either "
"an :meth:`encode` method (when the result contains :class:`str` data) or a :"
"meth:`decode` method (when the result contains :class:`bytes` data). The "
"signatures of these methods match those of the corresponding :class:`str` "
"and :class:`bytes` methods (except that the default encoding is ``'ascii'`` "
"rather than ``'utf-8'``). Each produces a value of a corresponding type that "
"contains either :class:`bytes` data (for :meth:`encode` methods) or :class:"
"`str` data (for :meth:`decode` methods)."
msgstr ""
"Чтобы упростить преобразование объектов результатов между :class:`str` и :"
"class:`bytes`, все возвращаемые значения функций анализа URL-адресов "
"предоставляют либо метод :meth:`encode` (когда результат содержит :class:"
"`str` data) или метод :meth:`decode` (когда результат содержит данные :class:"
"`bytes`). Сигнатуры этих методов совпадают с подписями соответствующих "
"методов :class:`str` и :class:`bytes` (за исключением того, что по умолчанию "
"используется кодировка ``'ascii'``, а не ``'utf-8'``). . Каждый создает "
"значение соответствующего типа, которое содержит либо данные :class:`bytes` "
"(для методов :meth:`encode`), либо данные :class:`str` (для методов :meth:"
"`decode`)."

#: ../../library/urllib.parse.rst:482
msgid ""
"Applications that need to operate on potentially improperly quoted URLs that "
"may contain non-ASCII data will need to do their own decoding from bytes to "
"characters before invoking the URL parsing methods."
msgstr ""
"Приложениям, которым необходимо работать с потенциально неправильно "
"заключенными в кавычки URL-адресами, которые могут содержать данные, "
"отличные от ASCII, потребуется выполнить собственное декодирование из байтов "
"в символы перед вызовом методов анализа URL-адресов."

#: ../../library/urllib.parse.rst:486
msgid ""
"The behaviour described in this section applies only to the URL parsing "
"functions. The URL quoting functions use their own rules when producing or "
"consuming byte sequences as detailed in the documentation of the individual "
"URL quoting functions."
msgstr ""
"Поведение, описанное в этом разделе, применимо только к функциям анализа URL-"
"адресов. Функции цитирования URL-адресов используют свои собственные правила "
"при создании или использовании последовательностей байтов, как подробно "
"описано в документации отдельных функций цитирования URL-адресов."

#: ../../library/urllib.parse.rst:491
msgid "URL parsing functions now accept ASCII encoded byte sequences"
msgstr ""
"Функции анализа URL-адресов теперь принимают последовательности байтов в "
"кодировке ASCII."

#: ../../library/urllib.parse.rst:498
msgid "Structured Parse Results"
msgstr "Структурированные результаты анализа"

#: ../../library/urllib.parse.rst:500
msgid ""
"The result objects from the :func:`urlparse`, :func:`urlsplit`  and :func:"
"`urldefrag` functions are subclasses of the :class:`tuple` type. These "
"subclasses add the attributes listed in the documentation for those "
"functions, the encoding and decoding support described in the previous "
"section, as well as an additional method:"
msgstr ""
"Объекты результатов функций :func:`urlparse`, :func:`urlsplit` и :func:"
"`urldefrag` являются подклассами типа :class:`tuple`. Эти подклассы "
"добавляют атрибуты, перечисленные в документации для этих функций, поддержку "
"кодирования и декодирования, описанную в предыдущем разделе, а также "
"дополнительный метод:"

#: ../../library/urllib.parse.rst:508
msgid ""
"Return the re-combined version of the original URL as a string. This may "
"differ from the original URL in that the scheme may be normalized to lower "
"case and empty components may be dropped. Specifically, empty parameters, "
"queries, and fragment identifiers will be removed."
msgstr ""
"Верните повторно объединенную версию исходного URL-адреса в виде строки. Он "
"может отличаться от исходного URL-адреса тем, что схема может быть приведена "
"к нижнему регистру, а пустые компоненты могут быть удалены. В частности, "
"будут удалены пустые параметры, запросы и идентификаторы фрагментов."

#: ../../library/urllib.parse.rst:513
msgid ""
"For :func:`urldefrag` results, only empty fragment identifiers will be "
"removed. For :func:`urlsplit` and :func:`urlparse` results, all noted "
"changes will be made to the URL returned by this method."
msgstr ""
"Для результатов :func:`urldefrag` будут удалены только пустые идентификаторы "
"фрагментов. Для результатов :func:`urlsplit` и :func:`urlparse` все "
"отмеченные изменения будут внесены в URL-адрес, возвращаемый этим методом."

#: ../../library/urllib.parse.rst:517
msgid ""
"The result of this method remains unchanged if passed back through the "
"original parsing function:"
msgstr ""
"Результат этого метода остается неизменным, если он передается обратно через "
"исходную функцию синтаксического анализа:"

#: ../../library/urllib.parse.rst:530
msgid ""
"The following classes provide the implementations of the structured parse "
"results when operating on :class:`str` objects:"
msgstr ""
"Следующие классы предоставляют реализации результатов структурированного "
"анализа при работе с объектами :class:`str`:"

#: ../../library/urllib.parse.rst:535
msgid ""
"Concrete class for :func:`urldefrag` results containing :class:`str` data. "
"The :meth:`encode` method returns a :class:`DefragResultBytes` instance."
msgstr ""
"Конкретный класс для результатов :func:`urldefrag`, содержащих данные :class:"
"`str`. Метод :meth:`encode` возвращает экземпляр :class:`DefragResultBytes`."

#: ../../library/urllib.parse.rst:543
msgid ""
"Concrete class for :func:`urlparse` results containing :class:`str` data. "
"The :meth:`encode` method returns a :class:`ParseResultBytes` instance."
msgstr ""
"Конкретный класс для результатов :func:`urlparse`, содержащих данные :class:"
"`str`. Метод :meth:`encode` возвращает экземпляр :class:`ParseResultBytes`."

#: ../../library/urllib.parse.rst:549
msgid ""
"Concrete class for :func:`urlsplit` results containing :class:`str` data. "
"The :meth:`encode` method returns a :class:`SplitResultBytes` instance."
msgstr ""
"Конкретный класс для результатов :func:`urlsplit`, содержащих данные :class:"
"`str`. Метод :meth:`encode` возвращает экземпляр :class:`SplitResultBytes`."

#: ../../library/urllib.parse.rst:554
msgid ""
"The following classes provide the implementations of the parse results when "
"operating on :class:`bytes` or :class:`bytearray` objects:"
msgstr ""
"Следующие классы предоставляют реализации результатов анализа при работе с "
"объектами :class:`bytes` или :class:`bytearray`:"

#: ../../library/urllib.parse.rst:559
msgid ""
"Concrete class for :func:`urldefrag` results containing :class:`bytes` data. "
"The :meth:`decode` method returns a :class:`DefragResult` instance."
msgstr ""
"Конкретный класс для результатов :func:`urldefrag`, содержащих данные :class:"
"`bytes`. Метод :meth:`decode` возвращает экземпляр :class:`DefragResult`."

#: ../../library/urllib.parse.rst:567
msgid ""
"Concrete class for :func:`urlparse` results containing :class:`bytes` data. "
"The :meth:`decode` method returns a :class:`ParseResult` instance."
msgstr ""
"Конкретный класс для результатов :func:`urlparse`, содержащих данные :class:"
"`bytes`. Метод :meth:`decode` возвращает экземпляр :class:`ParseResult`."

#: ../../library/urllib.parse.rst:575
msgid ""
"Concrete class for :func:`urlsplit` results containing :class:`bytes` data. "
"The :meth:`decode` method returns a :class:`SplitResult` instance."
msgstr ""
"Конкретный класс для результатов :func:`urlsplit`, содержащих данные :class:"
"`bytes`. Метод :meth:`decode` возвращает экземпляр :class:`SplitResult`."

#: ../../library/urllib.parse.rst:583
msgid "URL Quoting"
msgstr "URL-цитирование"

#: ../../library/urllib.parse.rst:585
msgid ""
"The URL quoting functions focus on taking program data and making it safe "
"for use as URL components by quoting special characters and appropriately "
"encoding non-ASCII text. They also support reversing these operations to "
"recreate the original data from the contents of a URL component if that task "
"isn't already covered by the URL parsing functions above."
msgstr ""
"Функции цитирования URL-адресов направлены на получение данных программы и "
"обеспечение их безопасности для использования в качестве компонентов URL-"
"адресов путем цитирования специальных символов и соответствующего "
"кодирования текста, отличного от ASCII. Они также поддерживают обращение "
"этих операций для воссоздания исходных данных из содержимого компонента URL-"
"адреса, если эта задача еще не решена вышеописанными функциями анализа URL-"
"адресов."

#: ../../library/urllib.parse.rst:593
msgid ""
"Replace special characters in *string* using the ``%xx`` escape. Letters, "
"digits, and the characters ``'_.-~'`` are never quoted. By default, this "
"function is intended for quoting the path section of a URL. The optional "
"*safe* parameter specifies additional ASCII characters that should not be "
"quoted --- its default value is ``'/'``."
msgstr ""

#: ../../library/urllib.parse.rst:599 ../../library/urllib.parse.rst:645
#: ../../library/urllib.parse.rst:674
msgid "*string* may be either a :class:`str` or a :class:`bytes` object."
msgstr "*string* может быть объектом :class:`str` или :class:`bytes`."

#: ../../library/urllib.parse.rst:601
msgid ""
"Moved from :rfc:`2396` to :rfc:`3986` for quoting URL strings. \"~\" is now "
"included in the set of unreserved characters."
msgstr ""
"Перемещено с :rfc:`2396` на :rfc:`3986` для цитирования строк URL. «~» "
"теперь включен в набор незарезервированных символов."

#: ../../library/urllib.parse.rst:605
msgid ""
"The optional *encoding* and *errors* parameters specify how to deal with non-"
"ASCII characters, as accepted by the :meth:`str.encode` method. *encoding* "
"defaults to ``'utf-8'``. *errors* defaults to ``'strict'``, meaning "
"unsupported characters raise a :class:`UnicodeEncodeError`. *encoding* and "
"*errors* must not be supplied if *string* is a :class:`bytes`, or a :class:"
"`TypeError` is raised."
msgstr ""
"Необязательные параметры *encoding* и *errors* определяют, как обращаться с "
"символами, отличными от ASCII, как это принято методом :meth:`str.encode`. "
"*кодировка* по умолчанию — ``'utf-8'``. *errors* по умолчанию имеет значение "
"``'strict'``, что означает, что неподдерживаемые символы вызывают ошибку :"
"class:`UnicodeEncodeError`. *encoding* и *errors* не должны указываться, "
"если *string* представляет собой :class:`bytes` или возникает :class:"
"`TypeError`."

#: ../../library/urllib.parse.rst:613
msgid ""
"Note that ``quote(string, safe, encoding, errors)`` is equivalent to "
"``quote_from_bytes(string.encode(encoding, errors), safe)``."
msgstr ""
"Обратите внимание, что ``quote(string,safe,coding,errors)`` эквивалентно "
"``quote_from_bytes(string.encode(encoding,errors),safe)``."

#: ../../library/urllib.parse.rst:616
msgid "Example: ``quote('/El Niño/')`` yields ``'/El%20Ni%C3%B1o/'``."
msgstr "Пример: ``quote('/El Niño/')`` дает ``'/El%20Ni%C3%B1o/'``."

#: ../../library/urllib.parse.rst:621
msgid ""
"Like :func:`quote`, but also replace spaces with plus signs, as required for "
"quoting HTML form values when building up a query string to go into a URL. "
"Plus signs in the original string are escaped unless they are included in "
"*safe*.  It also does not have *safe* default to ``'/'``."
msgstr ""
"Подобно :func:`quote`, но также замените пробелы знаками плюс, как это "
"требуется для цитирования значений HTML-формы при создании строки запроса "
"для перехода в URL-адрес. Знаки плюс в исходной строке экранируются, если "
"они не включены в *safe*. Он также не имеет *безопасного* значения по "
"умолчанию ``'/'``."

#: ../../library/urllib.parse.rst:626
msgid "Example: ``quote_plus('/El Niño/')`` yields ``'%2FEl+Ni%C3%B1o%2F'``."
msgstr "Example: ``quote_plus('/El Niño/')`` yields ``'%2FEl+Ni%C3%B1o%2F'``."

#: ../../library/urllib.parse.rst:631
msgid ""
"Like :func:`quote`, but accepts a :class:`bytes` object rather than a :class:"
"`str`, and does not perform string-to-bytes encoding."
msgstr ""
"Подобен :func:`quote`, но принимает объект :class:`bytes`, а не :class:"
"`str`, и не выполняет побайтовое кодирование."

#: ../../library/urllib.parse.rst:634
msgid "Example: ``quote_from_bytes(b'a&\\xef')`` yields ``'a%26%EF'``."
msgstr "Example: ``quote_from_bytes(b'a&\\xef')`` yields ``'a%26%EF'``."

#: ../../library/urllib.parse.rst:640
msgid ""
"Replace ``%xx`` escapes with their single-character equivalent. The optional "
"*encoding* and *errors* parameters specify how to decode percent-encoded "
"sequences into Unicode characters, as accepted by the :meth:`bytes.decode` "
"method."
msgstr ""

#: ../../library/urllib.parse.rst:647
msgid ""
"*encoding* defaults to ``'utf-8'``. *errors* defaults to ``'replace'``, "
"meaning invalid sequences are replaced by a placeholder character."
msgstr ""
"*кодировка* по умолчанию — ``'utf-8'``. *errors* по умолчанию имеет значение "
"``'replace'``, что означает, что недопустимые последовательности заменяются "
"символом-заполнителем."

#: ../../library/urllib.parse.rst:651
msgid "Example: ``unquote('/El%20Ni%C3%B1o/')`` yields ``'/El Niño/'``."
msgstr "Example: ``unquote('/El%20Ni%C3%B1o/')`` yields ``'/El Niño/'``."

#: ../../library/urllib.parse.rst:653
msgid ""
"*string* parameter supports bytes and str objects (previously only str)."
msgstr "Параметр *string* поддерживает байты и объекты str (ранее только str)."

#: ../../library/urllib.parse.rst:661
msgid ""
"Like :func:`unquote`, but also replace plus signs with spaces, as required "
"for unquoting HTML form values."
msgstr ""
"Аналогично :func:`unquote`, но также замените знаки плюса пробелами, как это "
"требуется для вывода из кавычек значений HTML-формы."

#: ../../library/urllib.parse.rst:664
msgid "*string* must be a :class:`str`."
msgstr "*строка* должна быть :class:`str`."

#: ../../library/urllib.parse.rst:666
msgid "Example: ``unquote_plus('/El+Ni%C3%B1o/')`` yields ``'/El Niño/'``."
msgstr "Example: ``unquote_plus('/El+Ni%C3%B1o/')`` yields ``'/El Niño/'``."

#: ../../library/urllib.parse.rst:671
msgid ""
"Replace ``%xx`` escapes with their single-octet equivalent, and return a :"
"class:`bytes` object."
msgstr ""

#: ../../library/urllib.parse.rst:676
msgid ""
"If it is a :class:`str`, unescaped non-ASCII characters in *string* are "
"encoded into UTF-8 bytes."
msgstr ""
"Если это :class:`str`, неэкранированные символы, отличные от ASCII, в "
"*строке* кодируются в байты UTF-8."

#: ../../library/urllib.parse.rst:679
msgid "Example: ``unquote_to_bytes('a%26%EF')`` yields ``b'a&\\xef'``."
msgstr "Пример: ``unquote_to_bytes('a%26 %И F')`` дает ``b'a&\\xef'``."

#: ../../library/urllib.parse.rst:685
msgid ""
"Convert a mapping object or a sequence of two-element tuples, which may "
"contain :class:`str` or :class:`bytes` objects, to a percent-encoded ASCII "
"text string.  If the resultant string is to be used as a *data* for POST "
"operation with the :func:`~urllib.request.urlopen` function, then it should "
"be encoded to bytes, otherwise it would result in a :exc:`TypeError`."
msgstr ""
"Преобразуйте объект сопоставления или последовательность двухэлементных "
"кортежей, которые могут содержать объекты :class:`str` или :class:`bytes`, в "
"текстовую строку ASCII с процентной кодировкой. Если результирующая строка "
"будет использоваться в качестве *данных* для операции POST с функцией :func:"
"`~urllib.request.urlopen`, то ее следует закодировать в байтах, иначе это "
"приведет к ошибке :exc:`TypeError. `."

#: ../../library/urllib.parse.rst:692
msgid ""
"The resulting string is a series of ``key=value`` pairs separated by ``'&'`` "
"characters, where both *key* and *value* are quoted using the *quote_via* "
"function.  By default, :func:`quote_plus` is used to quote the values, which "
"means spaces are quoted as a ``'+'`` character and '/' characters are "
"encoded as ``%2F``, which follows the standard for GET requests "
"(``application/x-www-form-urlencoded``).  An alternate function that can be "
"passed as *quote_via* is :func:`quote`, which will encode spaces as ``%20`` "
"and not encode '/' characters.  For maximum control of what is quoted, use "
"``quote`` and specify a value for *safe*."
msgstr ""
"Результирующая строка представляет собой серию пар ``ключ=значение``, "
"разделенных символами ``'&'``, где *ключ* и *значение* заключаются в кавычки "
"с помощью функции *quote_via*. По умолчанию :func:`quote_plus` используется "
"для кавычек значений, что означает, что пробелы заключаются в кавычки как "
"символ ``'+'``, а символы '/' кодируются как `` %2F ``, который "
"соответствует стандарту для запросов GET (``application/x-www-form-"
"urlencoded``). Альтернативной функцией, которую можно передать как "
"*quote_via*, является :func:`quote`, которая будет кодировать пробелы как "
"``%20`` и не кодировать символы '/'. Для максимального контроля над тем, что "
"цитируется, используйте ``quote`` и укажите значение *safe*."

#: ../../library/urllib.parse.rst:702
msgid ""
"When a sequence of two-element tuples is used as the *query* argument, the "
"first element of each tuple is a key and the second is a value. The value "
"element in itself can be a sequence and in that case, if the optional "
"parameter *doseq* evaluates to ``True``, individual ``key=value`` pairs "
"separated by ``'&'`` are generated for each element of the value sequence "
"for the key.  The order of parameters in the encoded string will match the "
"order of parameter tuples in the sequence."
msgstr ""
"Когда в качестве аргумента *query* используется последовательность "
"двухэлементных кортежей, первый элемент каждого кортежа является ключом, а "
"второй — значением. Элемент value сам по себе может быть "
"последовательностью, и в этом случае, если необязательный параметр *doseq* "
"оценивается как True, для каждый элемент последовательности значений ключа. "
"Порядок параметров в закодированной строке будет соответствовать порядку "
"кортежей параметров в последовательности."

#: ../../library/urllib.parse.rst:710
msgid ""
"The *safe*, *encoding*, and *errors* parameters are passed down to "
"*quote_via* (the *encoding* and *errors* parameters are only passed when a "
"query element is a :class:`str`)."
msgstr ""
"Параметры *safe*, *encoding* и *errors* передаются в *quote_via* (параметры "
"*encoding* и *errors* передаются только в том случае, если элементом запроса "
"является :class:`str`)."

#: ../../library/urllib.parse.rst:714
msgid ""
"To reverse this encoding process, :func:`parse_qs` and :func:`parse_qsl` are "
"provided in this module to parse query strings into Python data structures."
msgstr ""
"Чтобы обратить этот процесс кодирования вспять, в этом модуле предусмотрены :"
"func:`parse_qs` и :func:`parse_qsl` для анализа строк запроса в структуры "
"данных Python."

#: ../../library/urllib.parse.rst:717
msgid ""
"Refer to :ref:`urllib examples <urllib-examples>` to find out how the :func:"
"`urllib.parse.urlencode` method can be used for generating the query string "
"of a URL or data for a POST request."
msgstr ""
"Обратитесь к примерам :ref:`urllib <urllib-examples>`, чтобы узнать, как "
"метод :func:`urllib.parse.urlencode` можно использовать для генерации строки "
"запроса URL-адреса или данных для запроса POST."

#: ../../library/urllib.parse.rst:721
msgid "*query* supports bytes and string objects."
msgstr "*query* поддерживает байтовые и строковые объекты."

#: ../../library/urllib.parse.rst:724
msgid "*quote_via* parameter."
msgstr ""

#: ../../library/urllib.parse.rst:732
msgid "`WHATWG`_ -  URL Living standard"
msgstr "`WHATWG`_ -  URL Living standard"

#: ../../library/urllib.parse.rst:731
msgid ""
"Working Group for the URL Standard that defines URLs, domains, IP addresses, "
"the application/x-www-form-urlencoded format, and their API."
msgstr ""
"Рабочая группа по стандарту URL-адресов, определяющему URL-адреса, домены, "
"IP-адреса, формат application/x-www-form-urlencoded и их API."

#: ../../library/urllib.parse.rst:738
msgid ":rfc:`3986` - Uniform Resource Identifiers"
msgstr ":rfc:`3986` — унифицированные идентификаторы ресурсов"

#: ../../library/urllib.parse.rst:735
msgid ""
"This is the current standard (STD66). Any changes to urllib.parse module "
"should conform to this. Certain deviations could be observed, which are "
"mostly for backward compatibility purposes and for certain de-facto parsing "
"requirements as commonly observed in major browsers."
msgstr ""
"Это текущий стандарт (STD66). Любые изменения в модуле urllib.parse должны "
"соответствовать этому. Могут наблюдаться определенные отклонения, которые в "
"основном связаны с целями обратной совместимости и некоторыми фактическими "
"требованиями синтаксического анализа, которые обычно наблюдаются в основных "
"браузерах."

#: ../../library/urllib.parse.rst:741
msgid ":rfc:`2732` - Format for Literal IPv6 Addresses in URL's."
msgstr ":rfc:`2732` — формат буквальных адресов IPv6 в URL-адресах."

#: ../../library/urllib.parse.rst:741
msgid "This specifies the parsing requirements of IPv6 URLs."
msgstr "Это определяет требования к синтаксическому анализу URL-адресов IPv6."

#: ../../library/urllib.parse.rst:745
msgid ":rfc:`2396` - Uniform Resource Identifiers (URI): Generic Syntax"
msgstr ""
":rfc:`2396` — унифицированные идентификаторы ресурсов (URI): общий синтаксис"

#: ../../library/urllib.parse.rst:744
msgid ""
"Document describing the generic syntactic requirements for both Uniform "
"Resource Names (URNs) and Uniform Resource Locators (URLs)."
msgstr ""
"Документ, описывающий общие синтаксические требования как для "
"унифицированных имен ресурсов (URN), так и для унифицированных локаторов "
"ресурсов (URL)."

#: ../../library/urllib.parse.rst:748
msgid ":rfc:`2368` - The mailto URL scheme."
msgstr ":rfc:`2368` — Схема URL-адреса mailto."

#: ../../library/urllib.parse.rst:748
msgid "Parsing requirements for mailto URL schemes."
msgstr "Требования к анализу схем URL-адресов mailto."

#: ../../library/urllib.parse.rst:753
msgid ":rfc:`1808` - Relative Uniform Resource Locators"
msgstr ":rfc:`1808` - Относительные унифицированные локаторы ресурсов"

#: ../../library/urllib.parse.rst:751
msgid ""
"This Request For Comments includes the rules for joining an absolute and a "
"relative URL, including a fair number of \"Abnormal Examples\" which govern "
"the treatment of border cases."
msgstr ""
"Этот запрос комментариев включает правила объединения абсолютных и "
"относительных URL-адресов, включая значительное количество «аномальных "
"примеров», которые регулируют обработку пограничных случаев."

#: ../../library/urllib.parse.rst:755
msgid ":rfc:`1738` - Uniform Resource Locators (URL)"
msgstr ":rfc:`1738` — унифицированные указатели ресурсов (URL)"

#: ../../library/urllib.parse.rst:756
msgid "This specifies the formal syntax and semantics of absolute URLs."
msgstr ""
"Это определяет формальный синтаксис и семантику абсолютных URL-адресов."
