# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 15:28+0000\n"
"PO-Revision-Date: 2023-05-24 02:13+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/binascii.rst:2
msgid ":mod:`binascii` --- Convert between binary and ASCII"
msgstr ""

#: ../../library/binascii.rst:14
msgid ""
"The :mod:`binascii` module contains a number of methods to convert between "
"binary and various ASCII-encoded binary representations. Normally, you will "
"not use these functions directly but use wrapper modules like :mod:`uu` or :"
"mod:`base64` instead. The :mod:`binascii` module contains low-level "
"functions written in C for greater speed that are used by the higher-level "
"modules."
msgstr ""
"Модуль :mod:`binascii` содержит ряд методов для преобразования между "
"двоичными и различными двоичными представлениями в кодировке ASCII. Обычно "
"вы не будете использовать эти функции напрямую, а вместо этого будете "
"использовать модули-оболочки, такие как :mod:`uu` или :mod:`base64`. Модуль :"
"mod:`binascii` содержит функции низкого уровня, написанные на C для большей "
"скорости, которые используются модулями более высокого уровня."

#: ../../library/binascii.rst:23
msgid ""
"``a2b_*`` functions accept Unicode strings containing only ASCII characters. "
"Other functions only accept :term:`bytes-like objects <bytes-like object>` "
"(such as :class:`bytes`, :class:`bytearray` and other objects that support "
"the buffer protocol)."
msgstr ""
"Функции ``a2b_*`` принимают строки Unicode, содержащие только символы ASCII. "
"Другие функции принимают только :term:`bytes-подобные объекты <bytes-like "
"object>` (такие как :class:`bytes`, :class:`bytearray` и другие объекты, "
"поддерживающие протокол буфера)."

#: ../../library/binascii.rst:28
msgid "ASCII-only unicode strings are now accepted by the ``a2b_*`` functions."
msgstr ""
"Строки Юникода, содержащие только ASCII, теперь принимаются функциями "
"``a2b_*``."

#: ../../library/binascii.rst:32
msgid "The :mod:`binascii` module defines the following functions:"
msgstr "Модуль :mod:`binascii` определяет следующие функции:"

#: ../../library/binascii.rst:37
msgid ""
"Convert a single line of uuencoded data back to binary and return the binary "
"data. Lines normally contain 45 (binary) bytes, except for the last line. "
"Line data may be followed by whitespace."
msgstr ""
"Преобразуйте одну строку данных, закодированных uu, обратно в двоичные "
"данные и верните двоичные данные. Строки обычно содержат 45 (двоичных) байт, "
"за исключением последней строки. За строковыми данными может следовать "
"пробел."

#: ../../library/binascii.rst:44
msgid ""
"Convert binary data to a line of ASCII characters, the return value is the "
"converted line, including a newline char. The length of *data* should be at "
"most 45. If *backtick* is true, zeros are represented by ``'`'`` instead of "
"spaces."
msgstr ""
"Преобразуйте двоичные данные в строку символов ASCII. Возвращаемым значением "
"является преобразованная строка, включая символ новой строки. Длина *data* "
"должна быть не более 45. Если *backtick* истинно, нули представляются "
"``'`'`` вместо пробелов."

#: ../../library/binascii.rst:48
msgid "Added the *backtick* parameter."
msgstr "Добавлен параметр *backtick*."

#: ../../library/binascii.rst:54
msgid ""
"Convert a block of base64 data back to binary and return the binary data. "
"More than one line may be passed at a time."
msgstr ""
"Преобразуйте блок данных base64 обратно в двоичный формат и верните двоичные "
"данные. Одновременно можно передавать более одной строки."

#: ../../library/binascii.rst:57
msgid ""
"If *strict_mode* is true, only valid base64 data will be converted. Invalid "
"base64 data will raise :exc:`binascii.Error`."
msgstr ""
"Если *strict_mode* имеет значение true, будут преобразованы только "
"допустимые данные base64. Неверные данные base64 вызовут ошибку :exc:"
"`binascii.Error`."

#: ../../library/binascii.rst:60
msgid "Valid base64:"
msgstr "Действительная base64:"

#: ../../library/binascii.rst:62
msgid "Conforms to :rfc:`3548`."
msgstr "Соответствует :rfc:`3548`."

#: ../../library/binascii.rst:63
msgid "Contains only characters from the base64 alphabet."
msgstr "Содержит только символы алфавита base64."

#: ../../library/binascii.rst:64
msgid ""
"Contains no excess data after padding (including excess padding, newlines, "
"etc.)."
msgstr ""
"Не содержит лишних данных после заполнения (включая лишние поля, символы "
"новой строки и т. д.)."

#: ../../library/binascii.rst:65
msgid "Does not start with a padding."
msgstr "Не начинается с отступа."

#: ../../library/binascii.rst:67
msgid "Added the *strict_mode* parameter."
msgstr "Добавлен параметр *strict_mode*."

#: ../../library/binascii.rst:73
msgid ""
"Convert binary data to a line of ASCII characters in base64 coding. The "
"return value is the converted line, including a newline char if *newline* is "
"true.  The output of this function conforms to :rfc:`3548`."
msgstr ""
"Преобразуйте двоичные данные в строку символов ASCII в кодировке Base64. "
"Возвращаемое значение — это преобразованная строка, включая символ новой "
"строки, если *newline* имеет значение true. Вывод этой функции "
"соответствует :rfc:`3548`."

#: ../../library/binascii.rst:77
msgid "Added the *newline* parameter."
msgstr "Добавлен параметр *newline*."

#: ../../library/binascii.rst:83
msgid ""
"Convert a block of quoted-printable data back to binary and return the "
"binary data. More than one line may be passed at a time. If the optional "
"argument *header* is present and true, underscores will be decoded as spaces."
msgstr ""
"Преобразуйте блок данных, доступных для печати, обратно в двоичный формат и "
"верните двоичные данные. Одновременно можно передавать более одной строки. "
"Если необязательный аргумент *header* присутствует и имеет значение true, "
"символы подчеркивания будут декодированы как пробелы."

#: ../../library/binascii.rst:90
msgid ""
"Convert binary data to a line(s) of ASCII characters in quoted-printable "
"encoding.  The return value is the converted line(s). If the optional "
"argument *quotetabs* is present and true, all tabs and spaces will be "
"encoded.   If the optional argument *istext* is present and true, newlines "
"are not encoded but trailing whitespace will be encoded. If the optional "
"argument *header* is present and true, spaces will be encoded as underscores "
"per :rfc:`1522`. If the optional argument *header* is present and false, "
"newline characters will be encoded as well; otherwise linefeed conversion "
"might corrupt the binary data stream."
msgstr ""
"Преобразуйте двоичные данные в строку(и) символов ASCII в кодировке для "
"печати в кавычках. Возвращаемое значение — это преобразованные строки. Если "
"необязательный аргумент *quotetabs* присутствует и имеет значение true, все "
"табуляции и пробелы будут закодированы. Если необязательный аргумент "
"*istext* присутствует и имеет значение true, символы новой строки не "
"кодируются, но будут кодироваться конечные пробелы. Если необязательный "
"аргумент *header* присутствует и имеет значение true, пробелы будут "
"закодированы как символы подчеркивания согласно :rfc:`1522`. Если "
"необязательный аргумент *header* присутствует и имеет значение false, "
"символы новой строки также будут закодированы; в противном случае "
"преобразование перевода строки может повредить поток двоичных данных."

#: ../../library/binascii.rst:103
msgid ""
"Compute a 16-bit CRC value of *data*, starting with *value* as the initial "
"CRC, and return the result.  This uses the CRC-CCITT polynomial *x*:sup:`16` "
"+ *x*:sup:`12` + *x*:sup:`5` + 1, often represented as 0x1021.  This CRC is "
"used in the binhex4 format."
msgstr ""
"Вычислите 16-битное значение CRC для *data*, начиная с *value* в качестве "
"начального CRC, и верните результат. При этом используется полином CRC-CCITT "
"*x*:sup:`16` + *x*:sup:`12` + *x*:sup:`5` + 1, часто представленный как "
"0x1021. Этот CRC используется в формате binhex4."

#: ../../library/binascii.rst:111
msgid ""
"Compute CRC-32, the unsigned 32-bit checksum of *data*, starting with an "
"initial CRC of *value*.  The default initial CRC is zero.  The algorithm is "
"consistent with the ZIP file checksum.  Since the algorithm is designed for "
"use as a checksum algorithm, it is not suitable for use as a general hash "
"algorithm.  Use as follows::"
msgstr ""
"Вычислите CRC-32, беззнаковую 32-битную контрольную сумму *данных*, начиная "
"с начальной CRC *значения*. Начальный CRC по умолчанию равен нулю. Алгоритм "
"соответствует контрольной сумме ZIP-файла. Поскольку алгоритм предназначен "
"для использования в качестве алгоритма контрольной суммы, он не подходит для "
"использования в качестве общего алгоритма хеширования. Используйте следующим "
"образом::"

#: ../../library/binascii.rst:123
msgid "The result is always unsigned."
msgstr "Результат всегда беззнаковый."

#: ../../library/binascii.rst:129
msgid ""
"Return the hexadecimal representation of the binary *data*.  Every byte of "
"*data* is converted into the corresponding 2-digit hex representation.  The "
"returned bytes object is therefore twice as long as the length of *data*."
msgstr ""
"Возвращает шестнадцатеричное представление двоичных *данных*. Каждый байт "
"*данных* преобразуется в соответствующее двухзначное шестнадцатеричное "
"представление. Таким образом, длина возвращаемого объекта байтов в два раза "
"превышает длину *data*."

#: ../../library/binascii.rst:133
msgid ""
"Similar functionality (but returning a text string) is also conveniently "
"accessible using the :meth:`bytes.hex` method."
msgstr ""
"Аналогичная функциональность (но с возвратом текстовой строки) также удобно "
"доступна с помощью метода :meth:`bytes.hex`."

#: ../../library/binascii.rst:136
msgid ""
"If *sep* is specified, it must be a single character str or bytes object. It "
"will be inserted in the output after every *bytes_per_sep* input bytes. "
"Separator placement is counted from the right end of the output by default, "
"if you wish to count from the left, supply a negative *bytes_per_sep* value."
msgstr ""
"Если указано *sep*, это должен быть односимвольный объект str или bytes. Он "
"будет вставлен в выходные данные после каждого входного байта "
"*bytes_per_sep*. По умолчанию размещение разделителя отсчитывается от "
"правого конца вывода. Если вы хотите считать от левого, укажите "
"отрицательное значение *bytes_per_sep*."

#: ../../library/binascii.rst:151
msgid "The *sep* and *bytes_per_sep* parameters were added."
msgstr "Были добавлены параметры *sep* и *bytes_per_sep*."

#: ../../library/binascii.rst:157
msgid ""
"Return the binary data represented by the hexadecimal string *hexstr*.  This "
"function is the inverse of :func:`b2a_hex`. *hexstr* must contain an even "
"number of hexadecimal digits (which can be upper or lower case), otherwise "
"an :exc:`Error` exception is raised."
msgstr ""
"Возвращает двоичные данные, представленные шестнадцатеричной строкой "
"*hexstr*. Эта функция является обратной :func:`b2a_hex`. *hexstr* должен "
"содержать четное количество шестнадцатеричных цифр (которые могут быть в "
"верхнем или нижнем регистре), в противном случае выдается исключение :exc:"
"`Error`."

#: ../../library/binascii.rst:162
msgid ""
"Similar functionality (accepting only text string arguments, but more "
"liberal towards whitespace) is also accessible using the :meth:`bytes."
"fromhex` class method."
msgstr ""
"Аналогичная функциональность (принимающая только аргументы текстовой строки, "
"но более свободная в отношении пробелов) также доступна с использованием "
"метода класса :meth:`bytes.fromhex`."

#: ../../library/binascii.rst:168
msgid "Exception raised on errors. These are usually programming errors."
msgstr "Исключение возникает при ошибках. Обычно это ошибки программирования."

#: ../../library/binascii.rst:173
msgid ""
"Exception raised on incomplete data. These are usually not programming "
"errors, but may be handled by reading a little more data and trying again."
msgstr ""
"Исключение возникает при неполных данных. Обычно это не ошибки "
"программирования, но их можно устранить, прочитав немного больше данных и "
"повторив попытку."

#: ../../library/binascii.rst:181
msgid "Module :mod:`base64`"
msgstr "Модуль :mod:`base64`"

#: ../../library/binascii.rst:180
msgid ""
"Support for RFC compliant base64-style encoding in base 16, 32, 64, and 85."
msgstr ""
"Поддержка кодировки в стиле base64, совместимой с RFC, в базовых кодировках "
"16, 32, 64 и 85."

#: ../../library/binascii.rst:184
msgid "Module :mod:`uu`"
msgstr "Module :mod:`uu`"

#: ../../library/binascii.rst:184
msgid "Support for UU encoding used on Unix."
msgstr "Поддержка кодировки UU, используемой в Unix."

#: ../../library/binascii.rst:186
msgid "Module :mod:`quopri`"
msgstr "Модуль :mod:`quopri`"

#: ../../library/binascii.rst:187
msgid "Support for quoted-printable encoding used in MIME email messages."
msgstr ""
"Поддержка кодировки Quote-printable, используемой в сообщениях электронной "
"почты MIME."

#: ../../library/binascii.rst:8
msgid "module"
msgstr "модуль"

#: ../../library/binascii.rst:8
msgid "uu"
msgstr "uu"

#: ../../library/binascii.rst:8
msgid "base64"
msgstr "base64"
