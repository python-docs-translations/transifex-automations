# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# Roustam Khamidoulline, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-17 14:51+0000\n"
"PO-Revision-Date: 2024-05-11 00:33+0000\n"
"Last-Translator: Roustam Khamidoulline, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/types.rst:2
msgid ":mod:`!types` --- Dynamic type creation and names for built-in types"
msgstr ""
":mod:`!types` --- Динамическое создание типов и имена для встроенных типов"

#: ../../library/types.rst:7
msgid "**Source code:** :source:`Lib/types.py`"
msgstr "**Исходный код:** :source:`Lib/types.py`"

#: ../../library/types.rst:11
msgid ""
"This module defines utility functions to assist in dynamic creation of new "
"types."
msgstr ""
"Этот модуль определяет служебные функции, помогающие в динамическом создании "
"новых типов."

#: ../../library/types.rst:14
msgid ""
"It also defines names for some object types that are used by the standard "
"Python interpreter, but not exposed as builtins like :class:`int` or :class:"
"`str` are."
msgstr ""
"Он также определяет имена для некоторых типов объектов, которые используются "
"стандартным интерпретатором Python, но не отображаются как встроенные "
"функции, такие как :class:`int` или :class:`str`."

#: ../../library/types.rst:18
msgid ""
"Finally, it provides some additional type-related utility classes and "
"functions that are not fundamental enough to be builtins."
msgstr ""
"Наконец, он предоставляет некоторые дополнительные служебные классы и "
"функции, связанные с типами, которые недостаточно фундаментальны, чтобы быть "
"встроенными."

#: ../../library/types.rst:23
msgid "Dynamic Type Creation"
msgstr "Создание динамических типов"

#: ../../library/types.rst:27
msgid "Creates a class object dynamically using the appropriate metaclass."
msgstr ""
"Создает объект класса динамически, используя соответствующий метакласс."

#: ../../library/types.rst:29
msgid ""
"The first three arguments are the components that make up a class definition "
"header: the class name, the base classes (in order), the keyword arguments "
"(such as ``metaclass``)."
msgstr ""
"Первые три аргумента — это компоненты, составляющие заголовок определения "
"класса: имя класса, базовые классы (по порядку), аргументы ключевого слова "
"(например, «метакласс»)."

#: ../../library/types.rst:33
msgid ""
"The *exec_body* argument is a callback that is used to populate the freshly "
"created class namespace. It should accept the class namespace as its sole "
"argument and update the namespace directly with the class contents. If no "
"callback is provided, it has the same effect as passing in ``lambda ns: "
"None``."
msgstr ""
"Аргумент *exec_body* — это обратный вызов, который используется для "
"заполнения пространства имен только что созданного класса. Он должен принять "
"пространство имен класса в качестве единственного аргумента и обновить "
"пространство имен непосредственно содержимым класса. Если обратный вызов не "
"указан, это имеет тот же эффект, что и передача ``lambda ns: None``."

#: ../../library/types.rst:43
msgid "Calculates the appropriate metaclass and creates the class namespace."
msgstr ""
"Вычисляет соответствующий метакласс и создает пространство имен класса."

#: ../../library/types.rst:45
msgid ""
"The arguments are the components that make up a class definition header: the "
"class name, the base classes (in order) and the keyword arguments (such as "
"``metaclass``)."
msgstr ""
"Аргументы — это компоненты, составляющие заголовок определения класса: имя "
"класса, базовые классы (по порядку) и аргументы ключевого слова (например, "
"«метакласс»)."

#: ../../library/types.rst:49
msgid "The return value is a 3-tuple: ``metaclass, namespace, kwds``"
msgstr ""
"Возвращаемое значение представляет собой тройной кортеж: ``метакласс, "
"пространство имен, kwds``"

#: ../../library/types.rst:51
msgid ""
"*metaclass* is the appropriate metaclass, *namespace* is the prepared class "
"namespace and *kwds* is an updated copy of the passed in *kwds* argument "
"with any ``'metaclass'`` entry removed. If no *kwds* argument is passed in, "
"this will be an empty dict."
msgstr ""
"*metaclass* — это соответствующий метакласс, *namespace* — это "
"подготовленное пространство имен класса, а *kwds* — это обновленная копия "
"переданного аргумента *kwds* с удаленной записью ``'metaclass'``. Если "
"аргумент *kwds* не передан, это будет пустой словарь."

#: ../../library/types.rst:60
msgid ""
"The default value for the ``namespace`` element of the returned tuple has "
"changed.  Now an insertion-order-preserving mapping is used when the "
"metaclass does not have a ``__prepare__`` method."
msgstr ""
"Значение по умолчанию для элемента namespace возвращаемого кортежа "
"изменилось. Теперь отображение, сохраняющее порядок вставки, используется, "
"когда метакласс не имеет метода ``__prepare__``."

#: ../../library/types.rst:66
msgid ":ref:`metaclasses`"
msgstr ":ref:`metaclasses`"

#: ../../library/types.rst:67
msgid "Full details of the class creation process supported by these functions"
msgstr ""
"Полная информация о процессе создания классов, поддерживаемом этими "
"функциями."

#: ../../library/types.rst:69
msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ":pep:`3115` - Метаклассы в Python 3000"

#: ../../library/types.rst:70
msgid "Introduced the ``__prepare__`` namespace hook"
msgstr "Представлен хук пространства имен ``__prepare__``."

#: ../../library/types.rst:74
msgid "Resolve MRO entries dynamically as specified by :pep:`560`."
msgstr "Разрешайте записи MRO динамически, как указано в :pep:`560`."

#: ../../library/types.rst:76
msgid ""
"This function looks for items in *bases* that are not instances of :class:"
"`type`, and returns a tuple where each such object that has an :meth:"
"`~object.__mro_entries__` method is replaced with an unpacked result of "
"calling this method.  If a *bases* item is an instance of :class:`type`, or "
"it doesn't have an :meth:`!__mro_entries__` method, then it is included in "
"the return tuple unchanged."
msgstr ""
"Эта функция ищет в *базах* элементы, которые не являются экземплярами :class:"
"`type`, и возвращает кортеж, в котором каждый такой объект, имеющий метод :"
"meth:`~object.__mro_entries__`, заменяется распакованным результатом вызова. "
"этот метод. Если элемент *bases* является экземпляром :class:`type` или у "
"него нет метода :meth:`!__mro_entries__`, то он включается в возвращаемый "
"кортеж без изменений."

#: ../../library/types.rst:87
msgid ""
"Return the tuple of objects originally given as the bases of *cls* before "
"the :meth:`~object.__mro_entries__` method has been called on any bases "
"(following the mechanisms laid out in :pep:`560`). This is useful for "
"introspecting :ref:`Generics <user-defined-generics>`."
msgstr ""
"Возвращает кортеж объектов, изначально заданных в качестве баз *cls* до "
"того, как метод :meth:`~object.__mro_entries__` будет вызван на любых базах "
"(следуя механизмам, изложенным в :pep:`560`). Это полезно для анализа :ref:"
"`Generics <user-defined-generics>`."

#: ../../library/types.rst:92
msgid ""
"For classes that have an ``__orig_bases__`` attribute, this function returns "
"the value of ``cls.__orig_bases__``. For classes without the "
"``__orig_bases__`` attribute, :attr:`cls.__bases__ <type.__bases__>` is "
"returned."
msgstr ""
"Для классов, имеющих атрибут ``__orig_bases__``, эта функция возвращает "
"значение ``cls.__orig_bases__``. Для классов без атрибута ``__orig_bases__`` "
"возвращается :attr:`cls.__bases__ <type.__bases__>`."

#: ../../library/types.rst:97
msgid "Examples::"
msgstr "Примеры::"

#: ../../library/types.rst:99
msgid ""
"from typing import TypeVar, Generic, NamedTuple, TypedDict\n"
"\n"
"T = TypeVar(\"T\")\n"
"class Foo(Generic[T]): ...\n"
"class Bar(Foo[int], float): ...\n"
"class Baz(list[str]): ...\n"
"Eggs = NamedTuple(\"Eggs\", [(\"a\", int), (\"b\", str)])\n"
"Spam = TypedDict(\"Spam\", {\"a\": int, \"b\": str})\n"
"\n"
"assert Bar.__bases__ == (Foo, float)\n"
"assert get_original_bases(Bar) == (Foo[int], float)\n"
"\n"
"assert Baz.__bases__ == (list,)\n"
"assert get_original_bases(Baz) == (list[str],)\n"
"\n"
"assert Eggs.__bases__ == (tuple,)\n"
"assert get_original_bases(Eggs) == (NamedTuple,)\n"
"\n"
"assert Spam.__bases__ == (dict,)\n"
"assert get_original_bases(Spam) == (TypedDict,)\n"
"\n"
"assert int.__bases__ == (object,)\n"
"assert get_original_bases(int) == (object,)"
msgstr ""
"from typing import TypeVar, Generic, NamedTuple, TypedDict\n"
"\n"
"T = TypeVar(\"T\")\n"
"class Foo(Generic[T]): ...\n"
"class Bar(Foo[int], float): ...\n"
"class Baz(list[str]): ...\n"
"Eggs = NamedTuple(\"Eggs\", [(\"a\", int), (\"b\", str)])\n"
"Spam = TypedDict(\"Spam\", {\"a\": int, \"b\": str})\n"
"\n"
"assert Bar.__bases__ == (Foo, float)\n"
"assert get_original_bases(Bar) == (Foo[int], float)\n"
"\n"
"assert Baz.__bases__ == (list,)\n"
"assert get_original_bases(Baz) == (list[str],)\n"
"\n"
"assert Eggs.__bases__ == (tuple,)\n"
"assert get_original_bases(Eggs) == (NamedTuple,)\n"
"\n"
"assert Spam.__bases__ == (dict,)\n"
"assert get_original_bases(Spam) == (TypedDict,)\n"
"\n"
"assert int.__bases__ == (object,)\n"
"assert get_original_bases(int) == (object,)"

#: ../../library/types.rst:127
msgid ":pep:`560` - Core support for typing module and generic types"
msgstr ""
":pep:`560` - Основная поддержка модуля типизации и универсальных типов."

#: ../../library/types.rst:131
msgid "Standard Interpreter Types"
msgstr "Стандартные типы интерпретаторов"

#: ../../library/types.rst:133
msgid ""
"This module provides names for many of the types that are required to "
"implement a Python interpreter. It deliberately avoids including some of the "
"types that arise only incidentally during processing such as the "
"``listiterator`` type."
msgstr ""
"Этот модуль предоставляет имена для многих типов, которые необходимы для "
"реализации интерпретатора Python. Он намеренно избегает включения некоторых "
"типов, которые возникают случайно во время обработки, таких как тип "
"listiterator."

#: ../../library/types.rst:138
msgid ""
"Typical use of these names is for :func:`isinstance` or :func:`issubclass` "
"checks."
msgstr ""
"Обычно эти имена используются для проверок :func:`isinstance` или :func:"
"`issubclass`."

#: ../../library/types.rst:142
msgid ""
"If you instantiate any of these types, note that signatures may vary between "
"Python versions."
msgstr ""
"Если вы создаете экземпляр любого из этих типов, обратите внимание, что "
"сигнатуры могут различаться в зависимости от версии Python."

#: ../../library/types.rst:144
msgid "Standard names are defined for the following types:"
msgstr "Стандартные имена определены для следующих типов:"

#: ../../library/types.rst:148
msgid "The type of :data:`None`."
msgstr "Тип :data:`Нет`."

#: ../../library/types.rst:156
msgid ""
"The type of user-defined functions and functions created by :keyword:"
"`lambda`  expressions."
msgstr ""
"Тип пользовательских функций и функций, созданных с помощью :keyword:"
"`lambda`-выражений."

#: ../../library/types.rst:159
msgid ""
"Raises an :ref:`auditing event <auditing>` ``function.__new__`` with "
"argument ``code``."
msgstr ""
"Вызывает :ref:`событие аудита <auditing>` ``function.__new__`` с аргументом "
"``code``."

#: ../../library/types.rst:161
msgid ""
"The audit event only occurs for direct instantiation of function objects, "
"and is not raised for normal compilation."
msgstr ""
"Событие аудита возникает только при прямом создании экземпляров "
"функциональных объектов и не возникает при обычной компиляции."

#: ../../library/types.rst:167
msgid ""
"The type of :term:`generator`-iterator objects, created by generator "
"functions."
msgstr ""
"Тип объектов :term:`generator`-итератора, созданных функциями-генераторами."

#: ../../library/types.rst:173
msgid ""
"The type of :term:`coroutine` objects, created by :keyword:`async def` "
"functions."
msgstr ""
"Тип объектов :term:`coroutine`, создаваемых функциями :keyword:`async def`."

#: ../../library/types.rst:181
msgid ""
"The type of :term:`asynchronous generator`-iterator objects, created by "
"asynchronous generator functions."
msgstr ""
"Тип объектов-итераторов асинхронного генератора, созданных функциями "
"асинхронного генератора."

#: ../../library/types.rst:191
msgid ""
"The type of :ref:`code objects <code-objects>` such as returned by :func:"
"`compile`."
msgstr ""
"Тип :ref:`объектов кода <code-objects>`, например, возвращаемый :func:"
"`compile`."

#: ../../library/types.rst:193
msgid ""
"Raises an :ref:`auditing event <auditing>` ``code.__new__`` with arguments "
"``code``, ``filename``, ``name``, ``argcount``, ``posonlyargcount``, "
"``kwonlyargcount``, ``nlocals``, ``stacksize``, ``flags``."
msgstr ""
"Вызывает :ref:`событие аудита <auditing>` ``code.__new__`` с аргументами "
"``code``, ``filename``, ``name``, ``argcount``, ``posonlyargcount`` , "
"``kwonlyargcount``, ``nlocals``, ``stacksize``, ``flags``."

#: ../../library/types.rst:195
msgid ""
"Note that the audited arguments may not match the names or positions "
"required by the initializer.  The audit event only occurs for direct "
"instantiation of code objects, and is not raised for normal compilation."
msgstr ""
"Обратите внимание, что проверяемые аргументы могут не соответствовать именам "
"или позициям, требуемым инициализатором. Событие аудита возникает только при "
"прямом создании экземпляров объектов кода и не возникает при обычной "
"компиляции."

#: ../../library/types.rst:201
msgid ""
"The type for cell objects: such objects are used as containers for a "
"function's free variables."
msgstr ""
"Тип объектов ячеек: такие объекты используются в качестве контейнеров для "
"свободных переменных функции."

#: ../../library/types.rst:209
msgid "The type of methods of user-defined class instances."
msgstr "Тип методов экземпляров определяемого пользователем класса."

#: ../../library/types.rst:215
msgid ""
"The type of built-in functions like :func:`len` or :func:`sys.exit`, and "
"methods of built-in classes.  (Here, the term \"built-in\" means \"written "
"in C\".)"
msgstr ""
"Тип встроенных функций, таких как :func:`len` или :func:`sys.exit`, а также "
"методы встроенных классов. (Здесь термин «встроенный» означает «написанный "
"на C».)"

#: ../../library/types.rst:222
msgid ""
"The type of methods of some built-in data types and base classes such as :"
"meth:`object.__init__` or :meth:`object.__lt__`."
msgstr ""
"Тип методов некоторых встроенных типов данных и базовых классов, таких как :"
"meth:`object.__init__` или :meth:`object.__lt__`."

#: ../../library/types.rst:230
msgid ""
"The type of *bound* methods of some built-in data types and base classes. "
"For example it is the type of :code:`object().__str__`."
msgstr ""
"Тип *связанных* методов некоторых встроенных типов данных и базовых классов. "
"Например, это тип :code:`object().__str__`."

#: ../../library/types.rst:238
msgid "The type of :data:`NotImplemented`."
msgstr "Тип :data:`NotImplemented`."

#: ../../library/types.rst:245
msgid ""
"The type of methods of some built-in data types such as :meth:`str.join`."
msgstr ""
"Тип методов некоторых встроенных типов данных, таких как :meth:`str.join`."

#: ../../library/types.rst:252
msgid ""
"The type of *unbound* class methods of some built-in data types such as "
"``dict.__dict__['fromkeys']``."
msgstr ""
"Тип *несвязанных* методов класса некоторых встроенных типов данных, таких "
"как ``dict.__dict__['fromkeys']``."

#: ../../library/types.rst:260
msgid ""
"The type of :term:`modules <module>`. The constructor takes the name of the "
"module to be created and optionally its :term:`docstring`."
msgstr ""
"Тип :term:`модулей <модуль>`. Конструктор принимает имя создаваемого модуля "
"и, при необходимости, его :term:`docstring`."

#: ../../library/types.rst:265
msgid ":ref:`Documentation on module objects <module-objects>`"
msgstr ":ref:`Документация по объектам модуля <module-objects>`"

#: ../../library/types.rst:266
msgid ""
"Provides details on the special attributes that can be found on instances "
"of :class:`!ModuleType`."
msgstr ""
"Содержит подробную информацию о специальных атрибутах, которые можно найти в "
"экземплярах :class:`!ModuleType`."

#: ../../library/types.rst:269
msgid ":func:`importlib.util.module_from_spec`"
msgstr ":func:`importlib.util.module_from_spec`"

#: ../../library/types.rst:270
msgid ""
"Modules created using the :class:`!ModuleType` constructor are created with "
"many of their special attributes unset or set to default values. :func:`!"
"module_from_spec` provides a more robust way of creating :class:`!"
"ModuleType` instances which ensures the various attributes are set "
"appropriately."
msgstr ""
"Модули, созданные с помощью конструктора :class:`!ModuleType`, создаются со "
"многими из своих специальных атрибутов, которые не установлены или "
"установлены в значения по умолчанию. :func:`!module_from_spec` обеспечивает "
"более надежный способ создания экземпляров :class:`!ModuleType`, который "
"гарантирует правильную установку различных атрибутов."

#: ../../library/types.rst:278
msgid "The type of :data:`Ellipsis`."
msgstr "Тип :data:`Ellipsis`."

#: ../../library/types.rst:284
msgid ""
"The type of :ref:`parameterized generics <types-genericalias>` such as "
"``list[int]``."
msgstr ""
"Тип параметризованных дженериков <types-genericalias>, например list[int]``."

#: ../../library/types.rst:287
msgid ""
"``t_origin`` should be a non-parameterized generic class, such as ``list``, "
"``tuple`` or ``dict``.  ``t_args`` should be a :class:`tuple` (possibly of "
"length 1) of types which parameterize ``t_origin``::"
msgstr ""
"``t_origin`` должен быть непараметризованным универсальным классом, таким "
"как ``list``, ``tuple`` или ``dict``. ``t_args`` должен быть :class:`tuple` "
"(возможно, длиной 1) типов, которые параметризуют ``t_origin``::"

#: ../../library/types.rst:291
msgid ""
">>> from types import GenericAlias\n"
"\n"
">>> list[int] == GenericAlias(list, (int,))\n"
"True\n"
">>> dict[str, int] == GenericAlias(dict, (str, int))\n"
"True"
msgstr ""
">>> from types import GenericAlias\n"
"\n"
">>> list[int] == GenericAlias(list, (int,))\n"
"True\n"
">>> dict[str, int] == GenericAlias(dict, (str, int))\n"
"True"

#: ../../library/types.rst:300
msgid "This type can now be subclassed."
msgstr "Теперь этот тип можно разделить на подклассы."

#: ../../library/types.rst:305
msgid ":ref:`Generic Alias Types<types-genericalias>`"
msgstr ":ref:`Generic Alias Types<types-genericalias>`"

#: ../../library/types.rst:306
msgid "In-depth documentation on instances of :class:`!types.GenericAlias`"
msgstr "Подробная документация по экземплярам :class:`!types.GenericAlias`"

#: ../../library/types.rst:308
msgid ":pep:`585` - Type Hinting Generics In Standard Collections"
msgstr ":pep:`585` - Обобщенные типы хинтинга в стандартных коллекциях"

#: ../../library/types.rst:309
msgid "Introducing the :class:`!types.GenericAlias` class"
msgstr "Представляем класс :class:`!types.GenericAlias`"

#: ../../library/types.rst:313
msgid "The type of :ref:`union type expressions<types-union>`."
msgstr "Тип :ref:`выражений типа объединения<types-union>`."

#: ../../library/types.rst:319
msgid ""
"The type of traceback objects such as found in ``sys.exception()."
"__traceback__``."
msgstr ""
"Тип объектов трассировки, например, найденный в ``sys.Exception()."
"__traceback__``."

#: ../../library/types.rst:321
msgid ""
"See :ref:`the language reference <traceback-objects>` for details of the "
"available attributes and operations, and guidance on creating tracebacks "
"dynamically."
msgstr ""
"См. :ref:`Справочник по языку <traceback-objects>` для получения подробной "
"информации о доступных атрибутах и ​​операциях, а также рекомендаций по "
"динамическому созданию обратных трассировок."

#: ../../library/types.rst:328
msgid ""
"The type of :ref:`frame objects <frame-objects>` such as found in :attr:`tb."
"tb_frame <traceback.tb_frame>` if ``tb`` is a traceback object."
msgstr ""
"Тип :ref:`frame-объектов <frame-objects>`, например, найденный в :attr:`tb."
"tb_frame <traceback.tb_frame>`, если ``tb`` является объектом трассировки."

#: ../../library/types.rst:334
msgid ""
"The type of objects defined in extension modules with ``PyGetSetDef``, such "
"as :attr:`FrameType.f_locals <frame.f_locals>` or ``array.array.typecode``. "
"This type is used as descriptor for object attributes; it has the same "
"purpose as the :class:`property` type, but for classes defined in extension "
"modules."
msgstr ""
"Тип объектов, определенных в модулях расширения с помощью PyGetSetDef, "
"например :attr:`FrameType.f_locals <frame.f_locals>` или ``array.array."
"typecode``. Этот тип используется как дескриптор атрибутов объекта; он имеет "
"ту же цель, что и тип :class:`property`, но для классов, определенных в "
"модулях расширения."

#: ../../library/types.rst:343
msgid ""
"The type of objects defined in extension modules with ``PyMemberDef``, such "
"as ``datetime.timedelta.days``.  This type is used as descriptor for simple "
"C data members which use standard conversion functions; it has the same "
"purpose as the :class:`property` type, but for classes defined in extension "
"modules."
msgstr ""
"Тип объектов, определенных в модулях расширения с помощью PyMemberDef, "
"например datetime.timedelta.days. Этот тип используется в качестве "
"дескриптора для простых членов данных C, которые используют стандартные "
"функции преобразования; он имеет ту же цель, что и тип :class:`property`, но "
"для классов, определенных в модулях расширения."

#: ../../library/types.rst:348
msgid ""
"In addition, when a class is defined with a :attr:`~object.__slots__` "
"attribute, then for each slot, an instance of :class:`!MemberDescriptorType` "
"will be added as an attribute on the class. This allows the slot to appear "
"in the class's :attr:`~type.__dict__`."
msgstr ""
"Кроме того, если класс определен с атрибутом :attr:`~object.__slots__`, то "
"для каждого слота в качестве атрибута класса будет добавлен экземпляр :class:"
"`!MemberDescriptorType`. Это позволит слоту появиться в :attr:`~type."
"__dict__` класса."

#: ../../library/types.rst:354
msgid ""
"In other implementations of Python, this type may be identical to "
"``GetSetDescriptorType``."
msgstr ""
"В других реализациях Python этот тип может быть идентичен "
"GetSetDescriptorType."

#: ../../library/types.rst:359
msgid ""
"Read-only proxy of a mapping. It provides a dynamic view on the mapping's "
"entries, which means that when the mapping changes, the view reflects these "
"changes."
msgstr ""
"Прокси-сервер сопоставления, доступный только для чтения. Он обеспечивает "
"динамическое представление записей сопоставления, что означает, что при "
"изменении сопоставления представление отражает эти изменения."

#: ../../library/types.rst:367
msgid ""
"Updated to support the new union (``|``) operator from :pep:`584`, which "
"simply delegates to the underlying mapping."
msgstr ""
"Обновлено для поддержки нового оператора объединения (``|``) из :pep:`584`, "
"который просто делегирует базовое сопоставление."

#: ../../library/types.rst:372
msgid ""
"Return ``True`` if the underlying mapping has a key *key*, else ``False``."
msgstr ""
"Возвращайте ``True``, если базовое сопоставление имеет ключ *key*, иначе "
"``False``."

#: ../../library/types.rst:377
msgid ""
"Return the item of the underlying mapping with key *key*.  Raises a :exc:"
"`KeyError` if *key* is not in the underlying mapping."
msgstr ""
"Верните элемент базового сопоставления с ключом *key*. Вызывает :exc:"
"`KeyError`, если *key* отсутствует в базовом сопоставлении."

#: ../../library/types.rst:382
msgid ""
"Return an iterator over the keys of the underlying mapping.  This is a "
"shortcut for ``iter(proxy.keys())``."
msgstr ""
"Возвращает итератор по ключам базового сопоставления. Это ярлык для "
"``iter(proxy.keys())``."

#: ../../library/types.rst:387
msgid "Return the number of items in the underlying mapping."
msgstr "Возвращает количество элементов в базовом сопоставлении."

#: ../../library/types.rst:391
msgid "Return a shallow copy of the underlying mapping."
msgstr "Верните неглубокую копию базового сопоставления."

#: ../../library/types.rst:395
msgid ""
"Return the value for *key* if *key* is in the underlying mapping, else "
"*default*.  If *default* is not given, it defaults to ``None``, so that this "
"method never raises a :exc:`KeyError`."
msgstr ""
"Возвращает значение *key*, если *key* находится в базовом сопоставлении, "
"иначе *default*. Если *default* не задано, по умолчанию используется "
"значение None, так что этот метод никогда не вызывает :exc:`KeyError`."

#: ../../library/types.rst:401
msgid ""
"Return a new view of the underlying mapping's items (``(key, value)`` pairs)."
msgstr ""
"Возвращает новое представление элементов базового сопоставления (пары "
"``(ключ, значение)``).(``(key, value)`` pairs)."

#: ../../library/types.rst:406
msgid "Return a new view of the underlying mapping's keys."
msgstr "Верните новое представление ключей базового сопоставления."

#: ../../library/types.rst:410
msgid "Return a new view of the underlying mapping's values."
msgstr "Верните новое представление значений базового сопоставления."

#: ../../library/types.rst:414
msgid "Return a reverse iterator over the keys of the underlying mapping."
msgstr "Верните обратный итератор по ключам базового сопоставления."

#: ../../library/types.rst:420
msgid "Return a hash of the underlying mapping."
msgstr "Возвращает хеш базового сопоставления."

#: ../../library/types.rst:426
msgid "Additional Utility Classes and Functions"
msgstr "Дополнительные служебные классы и функции"

#: ../../library/types.rst:430
msgid ""
"A simple :class:`object` subclass that provides attribute access to its "
"namespace, as well as a meaningful repr."
msgstr ""
"Простой подкласс :class:`object`, который обеспечивает доступ к атрибутам "
"своего пространства имен, а также значимое представление."

#: ../../library/types.rst:433
msgid ""
"Unlike :class:`object`, with ``SimpleNamespace`` you can add and remove "
"attributes.  If a ``SimpleNamespace`` object is initialized with keyword "
"arguments, those are directly added to the underlying namespace."
msgstr ""
"В отличие от :class:`object`, с помощью ``SimpleNamespace`` вы можете "
"добавлять и удалять атрибуты. Если объект SimpleNamespace инициализируется "
"аргументами ключевого слова, они напрямую добавляются в базовое пространство "
"имен."

#: ../../library/types.rst:437
msgid "The type is roughly equivalent to the following code::"
msgstr "Тип примерно эквивалентен следующему коду:"

#: ../../library/types.rst:439
msgid ""
"class SimpleNamespace:\n"
"    def __init__(self, /, **kwargs):\n"
"        self.__dict__.update(kwargs)\n"
"\n"
"    def __repr__(self):\n"
"        items = (f\"{k}={v!r}\" for k, v in self.__dict__.items())\n"
"        return \"{}({})\".format(type(self).__name__, \", \".join(items))\n"
"\n"
"    def __eq__(self, other):\n"
"        if isinstance(self, SimpleNamespace) and isinstance(other, "
"SimpleNamespace):\n"
"           return self.__dict__ == other.__dict__\n"
"        return NotImplemented"
msgstr ""
"class SimpleNamespace:\n"
"    def __init__(self, /, **kwargs):\n"
"        self.__dict__.update(kwargs)\n"
"\n"
"    def __repr__(self):\n"
"        items = (f\"{k}={v!r}\" for k, v in self.__dict__.items())\n"
"        return \"{}({})\".format(type(self).__name__, \", \".join(items))\n"
"\n"
"    def __eq__(self, other):\n"
"        if isinstance(self, SimpleNamespace) and isinstance(other, "
"SimpleNamespace):\n"
"           return self.__dict__ == other.__dict__\n"
"        return NotImplemented"

#: ../../library/types.rst:452
msgid ""
"``SimpleNamespace`` may be useful as a replacement for ``class NS: pass``. "
"However, for a structured record type use :func:`~collections.namedtuple` "
"instead."
msgstr ""
"``SimpleNamespace`` может быть полезен в качестве замены ``class NS: pass``. "
"Однако для типа структурированной записи вместо этого используйте :func:"
"`~collections.namedtuple`."

#: ../../library/types.rst:458
msgid ""
"Attribute order in the repr changed from alphabetical to insertion (like "
"``dict``)."
msgstr ""
"Порядок атрибутов в представлении изменен с алфавитного на порядок вставки "
"(как в ``dict``)."

#: ../../library/types.rst:464
msgid "Route attribute access on a class to __getattr__."
msgstr "Направьте доступ к атрибутам класса к __getattr__."

#: ../../library/types.rst:466
msgid ""
"This is a descriptor, used to define attributes that act differently when "
"accessed through an instance and through a class.  Instance access remains "
"normal, but access to an attribute through a class will be routed to the "
"class's __getattr__ method; this is done by raising AttributeError."
msgstr ""
"Это дескриптор, используемый для определения атрибутов, которые действуют по-"
"разному при доступе через экземпляр и через класс. Доступ к экземпляру "
"остается обычным, но доступ к атрибуту через класс будет перенаправлен на "
"метод __getattr__ класса; это делается путем поднятия AttributeError."

#: ../../library/types.rst:471
msgid ""
"This allows one to have properties active on an instance, and have virtual "
"attributes on the class with the same name (see :class:`enum.Enum` for an "
"example)."
msgstr ""
"Это позволяет иметь активные свойства экземпляра и виртуальные атрибуты "
"класса с тем же именем (пример см. в :class:`enum.Enum`)."

#: ../../library/types.rst:478
msgid "Coroutine Utility Functions"
msgstr "Служебные функции сопрограммы"

#: ../../library/types.rst:482
msgid ""
"This function transforms a :term:`generator` function into a :term:"
"`coroutine function` which returns a generator-based coroutine. The "
"generator-based coroutine is still a :term:`generator iterator`, but is also "
"considered to be a :term:`coroutine` object and is :term:`awaitable`.  "
"However, it may not necessarily implement the :meth:`~object.__await__` "
"method."
msgstr ""
"Эта функция преобразует функцию :term:`generator` в :term:`coroutine "
"function`, которая возвращает сопрограмму на основе генератора. Сопрограмма "
"на основе генератора по-прежнему является :term:`итератором-генератором`, но "
"также считается объектом :term:`сопрограммы` и является :term:`awaitable`. "
"Однако он не обязательно реализует метод :meth:`~object.__await__`."

#: ../../library/types.rst:489
msgid "If *gen_func* is a generator function, it will be modified in-place."
msgstr ""
"Если *gen_func* является функцией-генератором, она будет изменена на месте."

#: ../../library/types.rst:491
msgid ""
"If *gen_func* is not a generator function, it will be wrapped. If it returns "
"an instance of :class:`collections.abc.Generator`, the instance will be "
"wrapped in an *awaitable* proxy object.  All other types of objects will be "
"returned as is."
msgstr ""
"Если *gen_func* не является функцией-генератором, она будет обернута. Если "
"он возвращает экземпляр :class:`collections.abc.Generator`, этот экземпляр "
"будет заключен в *ожидаемый* прокси-объект. Все остальные типы объектов "
"будут возвращены как есть."

#: ../../library/types.rst:189
msgid "built-in function"
msgstr "встроенная функция"

#: ../../library/types.rst:189
msgid "compile"
msgstr "скомпилировать"
