# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 15:28+0000\n"
"PO-Revision-Date: 2023-05-24 02:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/xml.etree.elementtree.rst:2
msgid ":mod:`xml.etree.ElementTree` --- The ElementTree XML API"
msgstr ""

#: ../../library/xml.etree.elementtree.rst:9
msgid "**Source code:** :source:`Lib/xml/etree/ElementTree.py`"
msgstr "**Исходный код:** :source:`Lib/xml/etree/ElementTree.py`"

#: ../../library/xml.etree.elementtree.rst:13
msgid ""
"The :mod:`xml.etree.ElementTree` module implements a simple and efficient "
"API for parsing and creating XML data."
msgstr ""
"Модуль :mod:`xml.etree.ElementTree` реализует простой и эффективный API для "
"анализа и создания XML-данных."

#: ../../library/xml.etree.elementtree.rst:16
msgid "This module will use a fast implementation whenever available."
msgstr "Этот модуль будет использовать быструю реализацию, когда она доступна."

#: ../../library/xml.etree.elementtree.rst:19
msgid "The :mod:`!xml.etree.cElementTree` module is deprecated."
msgstr "Модуль :mod:`!xml.etree.cElementTree` устарел."

#: ../../library/xml.etree.elementtree.rst:25
msgid ""
"The :mod:`xml.etree.ElementTree` module is not secure against maliciously "
"constructed data.  If you need to parse untrusted or unauthenticated data "
"see :ref:`xml-vulnerabilities`."
msgstr ""
"Модуль :mod:`xml.etree.ElementTree` не защищен от вредоносно созданных "
"данных. Если вам нужно проанализировать ненадежные или неаутентифицированные "
"данные, см. :ref:`xml-vulnerabilities`."

#: ../../library/xml.etree.elementtree.rst:30
msgid "Tutorial"
msgstr "Руководство"

#: ../../library/xml.etree.elementtree.rst:32
msgid ""
"This is a short tutorial for using :mod:`xml.etree.ElementTree` (``ET`` in "
"short).  The goal is to demonstrate some of the building blocks and basic "
"concepts of the module."
msgstr ""
"Это краткое руководство по использованию :mod:`xml.etree.ElementTree` "
"(сокращенно ``ET``). Цель состоит в том, чтобы продемонстрировать некоторые "
"строительные блоки и основные концепции модуля."

#: ../../library/xml.etree.elementtree.rst:37
msgid "XML tree and elements"
msgstr "XML-дерево и элементы"

#: ../../library/xml.etree.elementtree.rst:39
msgid ""
"XML is an inherently hierarchical data format, and the most natural way to "
"represent it is with a tree.  ``ET`` has two classes for this purpose - :"
"class:`ElementTree` represents the whole XML document as a tree, and :class:"
"`Element` represents a single node in this tree.  Interactions with the "
"whole document (reading and writing to/from files) are usually done on the :"
"class:`ElementTree` level.  Interactions with a single XML element and its "
"sub-elements are done on the :class:`Element` level."
msgstr ""
"XML — это по своей сути иерархический формат данных, и наиболее естественным "
"способом его представления является дерево. Для этой цели в ``ET`` есть два "
"класса: :class:`ElementTree` представляет весь XML-документ в виде дерева, "
"а :class:`Element` представляет один узел в этом дереве. Взаимодействия со "
"всем документом (чтение и запись в/из файлов) обычно выполняются на уровне :"
"class:`ElementTree`. Взаимодействие с одним элементом XML и его "
"подэлементами осуществляется на уровне :class:`Element`."

#: ../../library/xml.etree.elementtree.rst:50
msgid "Parsing XML"
msgstr "Анализ XML"

#: ../../library/xml.etree.elementtree.rst:52
msgid ""
"We'll be using the fictive :file:`country_data.xml` XML document as the "
"sample data for this section:"
msgstr ""
"Мы будем использовать вымышленный XML-документ :file:`country_data.xml` в "
"качестве образца данных для этого раздела:"

#: ../../library/xml.etree.elementtree.rst:80
msgid "We can import this data by reading from a file::"
msgstr "Мы можем импортировать эти данные, прочитав из файла::"

#: ../../library/xml.etree.elementtree.rst:86
msgid "Or directly from a string::"
msgstr "Или напрямую из строки::"

#: ../../library/xml.etree.elementtree.rst:90
msgid ""
":func:`fromstring` parses XML from a string directly into an :class:"
"`Element`, which is the root element of the parsed tree.  Other parsing "
"functions may create an :class:`ElementTree`.  Check the documentation to be "
"sure."
msgstr ""
":func:`fromstring` анализирует XML из строки непосредственно в :class:"
"`Element`, который является корневым элементом анализируемого дерева. Другие "
"функции синтаксического анализа могут создавать :class:`ElementTree`. Чтобы "
"быть уверенным, проверьте документацию."

#: ../../library/xml.etree.elementtree.rst:94
msgid ""
"As an :class:`Element`, ``root`` has a tag and a dictionary of attributes::"
msgstr "Как :class:`Element`, ``root`` имеет тег и словарь атрибутов:"

#: ../../library/xml.etree.elementtree.rst:101
msgid "It also has children nodes over which we can iterate::"
msgstr "У него также есть дочерние узлы, по которым мы можем перебирать::"

#: ../../library/xml.etree.elementtree.rst:110
msgid "Children are nested, and we can access specific child nodes by index::"
msgstr ""
"Дочерние узлы вложены, и мы можем получить доступ к определенным дочерним "
"узлам по индексу::"

#: ../../library/xml.etree.elementtree.rst:118
msgid ""
"Not all elements of the XML input will end up as elements of the parsed "
"tree. Currently, this module skips over any XML comments, processing "
"instructions, and document type declarations in the input. Nevertheless, "
"trees built using this module's API rather than parsing from XML text can "
"have comments and processing instructions in them; they will be included "
"when generating XML output. A document type declaration may be accessed by "
"passing a custom :class:`TreeBuilder` instance to the :class:`XMLParser` "
"constructor."
msgstr ""
"Не все элементы входных данных XML станут элементами анализируемого дерева. "
"В настоящее время этот модуль пропускает любые комментарии XML, инструкции "
"по обработке и объявления типов документов во входных данных. Тем не менее, "
"деревья, построенные с использованием API этого модуля, а не путем анализа "
"текста XML, могут содержать комментарии и инструкции по обработке; они будут "
"включены при генерации вывода XML. Доступ к объявлению типа документа можно "
"получить, передав пользовательский экземпляр :class:`TreeBuilder` в "
"конструктор :class:`XMLParser`."

#: ../../library/xml.etree.elementtree.rst:132
msgid "Pull API for non-blocking parsing"
msgstr "Pull API для неблокирующего анализа"

#: ../../library/xml.etree.elementtree.rst:134
msgid ""
"Most parsing functions provided by this module require the whole document to "
"be read at once before returning any result.  It is possible to use an :"
"class:`XMLParser` and feed data into it incrementally, but it is a push API "
"that calls methods on a callback target, which is too low-level and "
"inconvenient for most needs.  Sometimes what the user really wants is to be "
"able to parse XML incrementally, without blocking operations, while enjoying "
"the convenience of fully constructed :class:`Element` objects."
msgstr ""
"Большинство функций синтаксического анализа, предоставляемых этим модулем, "
"требуют, чтобы весь документ был прочитан сразу, прежде чем возвращать какой-"
"либо результат. Можно использовать :class:`XMLParser` и постепенно вводить в "
"него данные, но это push-API, который вызывает методы для цели обратного "
"вызова, что является слишком низкоуровневым и неудобным для большинства "
"нужд. Иногда пользователю действительно хочется иметь возможность "
"анализировать XML постепенно, без блокировки операций, наслаждаясь при этом "
"удобством полностью сконструированных объектов :class:`Element`."

#: ../../library/xml.etree.elementtree.rst:142
msgid ""
"The most powerful tool for doing this is :class:`XMLPullParser`.  It does "
"not require a blocking read to obtain the XML data, and is instead fed with "
"data incrementally with :meth:`XMLPullParser.feed` calls.  To get the parsed "
"XML elements, call :meth:`XMLPullParser.read_events`.  Here is an example::"
msgstr ""
"Самый мощный инструмент для этого — :class:`XMLPullParser`. Для получения "
"данных XML не требуется блокирующее чтение, вместо этого данные передаются "
"постепенно с помощью вызовов :meth:`XMLPullParser.feed`. Чтобы получить "
"проанализированные элементы XML, вызовите :meth:`XMLPullParser.read_events`. "
"Вот пример::"

#: ../../library/xml.etree.elementtree.rst:159
msgid ""
"The obvious use case is applications that operate in a non-blocking fashion "
"where the XML data is being received from a socket or read incrementally "
"from some storage device.  In such cases, blocking reads are unacceptable."
msgstr ""
"Очевидный вариант использования — это приложения, которые работают "
"неблокирующим образом, когда данные XML принимаются из сокета или поэтапно "
"считываются с какого-либо устройства хранения. В таких случаях блокировка "
"чтения недопустима."

#: ../../library/xml.etree.elementtree.rst:163
msgid ""
"Because it's so flexible, :class:`XMLPullParser` can be inconvenient to use "
"for simpler use-cases.  If you don't mind your application blocking on "
"reading XML data but would still like to have incremental parsing "
"capabilities, take a look at :func:`iterparse`.  It can be useful when "
"you're reading a large XML document and don't want to hold it wholly in "
"memory."
msgstr ""
"Из-за своей гибкости :class:`XMLPullParser` может быть неудобно использовать "
"в более простых случаях. Если вы не возражаете против блокировки вашего "
"приложения при чтении XML-данных, но все же хотели бы иметь возможности "
"поэтапного анализа, взгляните на :func:`iterparse`. Это может быть полезно, "
"когда вы читаете большой XML-документ и не хотите хранить его целиком в "
"памяти."

#: ../../library/xml.etree.elementtree.rst:169
msgid ""
"Where *immediate* feedback through events is wanted, calling method :meth:"
"`XMLPullParser.flush` can help reduce delay; please make sure to study the "
"related security notes."
msgstr ""
"Там, где требуется *немедленная* обратная связь через события, вызов метода :"
"meth:`XMLPullParser.flush` может помочь уменьшить задержку; обязательно "
"ознакомьтесь с соответствующими примечаниями по безопасности."

#: ../../library/xml.etree.elementtree.rst:175
msgid "Finding interesting elements"
msgstr "Поиск интересных элементов"

#: ../../library/xml.etree.elementtree.rst:177
msgid ""
":class:`Element` has some useful methods that help iterate recursively over "
"all the sub-tree below it (its children, their children, and so on).  For "
"example, :meth:`Element.iter`::"
msgstr ""
":class:`Element` имеет несколько полезных методов, которые помогают "
"рекурсивно перебирать все поддерево ниже него (его дочерние элементы, их "
"дочерние элементы и т. д.). Например, :meth:`Element.iter`::"

#: ../../library/xml.etree.elementtree.rst:190
msgid ""
":meth:`Element.findall` finds only elements with a tag which are direct "
"children of the current element.  :meth:`Element.find` finds the *first* "
"child with a particular tag, and :attr:`Element.text` accesses the element's "
"text content.  :meth:`Element.get` accesses the element's attributes::"
msgstr ""
":meth:`Element.findall` находит только элементы с тегом, которые являются "
"прямыми дочерними элементами текущего элемента. :meth:`Element.find` находит "
"*первый* дочерний элемент с определенным тегом, а :attr:`Element.text` "
"получает доступ к текстовому содержимому элемента. :meth:`Element.get` "
"получает доступ к атрибутам элемента::"

#: ../../library/xml.etree.elementtree.rst:204
msgid ""
"More sophisticated specification of which elements to look for is possible "
"by using :ref:`XPath <elementtree-xpath>`."
msgstr ""
"Более сложная спецификация того, какие элементы искать, возможна с помощью :"
"ref:`XPath <elementtree-xpath>`."

#: ../../library/xml.etree.elementtree.rst:208
msgid "Modifying an XML File"
msgstr "Изменение XML-файла"

#: ../../library/xml.etree.elementtree.rst:210
msgid ""
":class:`ElementTree` provides a simple way to build XML documents and write "
"them to files. The :meth:`ElementTree.write` method serves this purpose."
msgstr ""
":class:`ElementTree` предоставляет простой способ создания XML-документов и "
"записи их в файлы. Этой цели служит метод :meth:`ElementTree.write`."

#: ../../library/xml.etree.elementtree.rst:213
msgid ""
"Once created, an :class:`Element` object may be manipulated by directly "
"changing its fields (such as :attr:`Element.text`), adding and modifying "
"attributes (:meth:`Element.set` method), as well as adding new children (for "
"example with :meth:`Element.append`)."
msgstr ""
"После создания объектом :class:`Element` можно манипулировать, напрямую "
"изменяя его поля (например, :attr:`Element.text`), добавляя и изменяя "
"атрибуты (метод :meth:`Element.set`), а также как добавление новых дочерних "
"элементов (например, с помощью :meth:`Element.append`)."

#: ../../library/xml.etree.elementtree.rst:218
msgid ""
"Let's say we want to add one to each country's rank, and add an ``updated`` "
"attribute to the rank element::"
msgstr ""
"Допустим, мы хотим добавить по одному к рейтингу каждой страны и добавить "
"атрибут «обновлено» к элементу ранга:"

#: ../../library/xml.etree.elementtree.rst:228
#: ../../library/xml.etree.elementtree.rst:272
msgid "Our XML now looks like this:"
msgstr "Наш XML теперь выглядит так:"

#: ../../library/xml.etree.elementtree.rst:256
msgid ""
"We can remove elements using :meth:`Element.remove`.  Let's say we want to "
"remove all countries with a rank higher than 50::"
msgstr ""
"Мы можем удалять элементы, используя :meth:`Element.remove`. Допустим, мы "
"хотим удалить все страны с рейтингом выше 50::"

#: ../../library/xml.etree.elementtree.rst:267
msgid ""
"Note that concurrent modification while iterating can lead to problems, just "
"like when iterating and modifying Python lists or dicts. Therefore, the "
"example first collects all matching elements with ``root.findall()``, and "
"only then iterates over the list of matches."
msgstr ""
"Обратите внимание, что одновременная модификация во время итерации может "
"привести к проблемам, как и при итерации и изменении списков или диктов "
"Python. Поэтому пример сначала собирает все совпадающие элементы с помощью "
"root.findall() и только затем перебирает список совпадений."

#: ../../library/xml.etree.elementtree.rst:294
msgid "Building XML documents"
msgstr "Создание XML-документов"

#: ../../library/xml.etree.elementtree.rst:296
msgid ""
"The :func:`SubElement` function also provides a convenient way to create new "
"sub-elements for a given element::"
msgstr ""
"Функция :func:`SubElement` также предоставляет удобный способ создания новых "
"подэлементов для данного элемента:"

#: ../../library/xml.etree.elementtree.rst:307
msgid "Parsing XML with Namespaces"
msgstr "Анализ XML с помощью пространств имен"

#: ../../library/xml.etree.elementtree.rst:309
msgid ""
"If the XML input has `namespaces <https://en.wikipedia.org/wiki/"
"XML_namespace>`__, tags and attributes with prefixes in the form ``prefix:"
"sometag`` get expanded to ``{uri}sometag`` where the *prefix* is replaced by "
"the full *URI*. Also, if there is a `default namespace <https://www.w3.org/"
"TR/xml-names/#defaulting>`__, that full URI gets prepended to all of the non-"
"prefixed tags."
msgstr ""
"Если ввод XML имеет ``пространства имен <https://en.wikipedia.org/wiki/"
"XML_namespace>`__, теги и атрибуты с префиксами в форме ``prefix:sometag`` "
"расширяются до ``{uri}sometag` ` где *префикс* заменяется полным *URI*. "
"Кроме того, если существует `пространство имен по умолчанию <https://www.w3."
"org/TR/xml-names/#defaulting>`__, этот полный URI добавляется ко всем тегам "
"без префиксов."

#: ../../library/xml.etree.elementtree.rst:317
msgid ""
"Here is an XML example that incorporates two namespaces, one with the prefix "
"\"fictional\" and the other serving as the default namespace:"
msgstr ""
"Вот пример XML, который включает в себя два пространства имен: одно с "
"префиксом «вымышленный», а другое служит пространством имен по умолчанию:"

#: ../../library/xml.etree.elementtree.rst:338
msgid ""
"One way to search and explore this XML example is to manually add the URI to "
"every tag or attribute in the xpath of a :meth:`~Element.find` or :meth:"
"`~Element.findall`::"
msgstr ""
"Один из способов поиска и изучения этого примера XML — вручную добавить URI "
"к каждому тегу или атрибуту в xpath :meth:`~Element.find` или :meth:"
"`~Element.findall`::"

#: ../../library/xml.etree.elementtree.rst:349
msgid ""
"A better way to search the namespaced XML example is to create a dictionary "
"with your own prefixes and use those in the search functions::"
msgstr ""
"Лучший способ поиска в примере XML с пространством имен — создать словарь с "
"собственными префиксами и использовать их в функциях поиска:"

#: ../../library/xml.etree.elementtree.rst:361
msgid "These two approaches both output::"
msgstr "Эти два подхода оба выводят::"

#: ../../library/xml.etree.elementtree.rst:375
msgid "XPath support"
msgstr "Поддержка XPath"

#: ../../library/xml.etree.elementtree.rst:377
msgid ""
"This module provides limited support for `XPath expressions <https://www.w3."
"org/TR/xpath>`_ for locating elements in a tree.  The goal is to support a "
"small subset of the abbreviated syntax; a full XPath engine is outside the "
"scope of the module."
msgstr ""
"Этот модуль обеспечивает ограниченную поддержку `выражений XPath <https://"
"www.w3.org/TR/xpath>`_ для поиска элементов в дереве. Целью является "
"поддержка небольшого подмножества сокращенного синтаксиса; полный механизм "
"XPath выходит за рамки модуля."

#: ../../library/xml.etree.elementtree.rst:383
#: ../../library/xml.etree.elementtree.rst:777
msgid "Example"
msgstr "Пример"

#: ../../library/xml.etree.elementtree.rst:385
msgid ""
"Here's an example that demonstrates some of the XPath capabilities of the "
"module.  We'll be using the ``countrydata`` XML document from the :ref:"
"`Parsing XML <elementtree-parsing-xml>` section::"
msgstr ""
"Вот пример, демонстрирующий некоторые возможности XPath модуля. Мы будем "
"использовать XML-документ ``countrydata`` из раздела :ref:`Разбор XML "
"<elementtree-parsing-xml>`::"

#: ../../library/xml.etree.elementtree.rst:409
msgid ""
"For XML with namespaces, use the usual qualified ``{namespace}tag`` "
"notation::"
msgstr ""
"Для XML с пространствами имен используйте обычную квалифицированную нотацию "
"``{namespace}tag``::"

#: ../../library/xml.etree.elementtree.rst:416
msgid "Supported XPath syntax"
msgstr "Поддерживаемый синтаксис XPath"

#: ../../library/xml.etree.elementtree.rst:421
msgid "Syntax"
msgstr "Синтаксис"

#: ../../library/xml.etree.elementtree.rst:421
msgid "Meaning"
msgstr "Значение"

#: ../../library/xml.etree.elementtree.rst:423
msgid "``tag``"
msgstr "``tag``"

#: ../../library/xml.etree.elementtree.rst:423
msgid ""
"Selects all child elements with the given tag. For example, ``spam`` selects "
"all child elements named ``spam``, and ``spam/egg`` selects all "
"grandchildren named ``egg`` in all children named ``spam``.  ``{namespace}"
"*`` selects all tags in the given namespace, ``{*}spam`` selects tags named "
"``spam`` in any (or no) namespace, and ``{}*`` only selects tags that are "
"not in a namespace."
msgstr ""
"Выбирает все дочерние элементы с данным тегом. Например, ``spam`` выбирает "
"все дочерние элементы с именем ``spam``, а ``spam/egg`` выбирает всех "
"дочерних элементов с именем ``egg`` во всех дочерних элементах с именем "
"``spam``. ``{namespace}*`` выбирает все теги в заданном пространстве имен, "
"``{*}spam`` выбирает теги с именем ``spam`` в любом пространстве имен (или "
"без него), а ``{}*`` выбирает только теги, которые не находятся в "
"пространстве имен."

#: ../../library/xml.etree.elementtree.rst:432
msgid "Support for star-wildcards was added."
msgstr "Была добавлена ​​поддержка звездочек."

#: ../../library/xml.etree.elementtree.rst:435
msgid "``*``"
msgstr "``*``"

#: ../../library/xml.etree.elementtree.rst:435
msgid ""
"Selects all child elements, including comments and processing instructions.  "
"For example, ``*/egg`` selects all grandchildren named ``egg``."
msgstr ""
"Выбирает все дочерние элементы, включая комментарии и инструкции по "
"обработке. Например, ``*/egg`` выбирает всех внуков с именем ``egg``."

#: ../../library/xml.etree.elementtree.rst:439
msgid "``.``"
msgstr "``.``"

#: ../../library/xml.etree.elementtree.rst:439
msgid ""
"Selects the current node.  This is mostly useful at the beginning of the "
"path, to indicate that it's a relative path."
msgstr ""
"Выбирает текущий узел. Чаще всего это полезно в начале пути, чтобы указать, "
"что это относительный путь."

#: ../../library/xml.etree.elementtree.rst:443
msgid "``//``"
msgstr "``//``"

#: ../../library/xml.etree.elementtree.rst:443
msgid ""
"Selects all subelements, on all levels beneath the current  element.  For "
"example, ``.//egg`` selects all ``egg`` elements in the entire tree."
msgstr ""
"Выбирает все подэлементы на всех уровнях ниже текущего элемента. Например, "
"``.//egg`` выбирает все элементы ``egg`` во всем дереве."

#: ../../library/xml.etree.elementtree.rst:447
msgid "``..``"
msgstr "``..``"

#: ../../library/xml.etree.elementtree.rst:447
msgid ""
"Selects the parent element.  Returns ``None`` if the path attempts to reach "
"the ancestors of the start element (the element ``find`` was called on)."
msgstr ""
"Выбирает родительский элемент. Возвращает None, если путь пытается достичь "
"предков начального элемента (был вызван элемент find)."

#: ../../library/xml.etree.elementtree.rst:451
msgid "``[@attrib]``"
msgstr "``[@attrib]``"

#: ../../library/xml.etree.elementtree.rst:451
msgid "Selects all elements that have the given attribute."
msgstr "Выбирает все элементы, имеющие данный атрибут."

#: ../../library/xml.etree.elementtree.rst:453
msgid "``[@attrib='value']``"
msgstr "``[@attrib='value']``"

#: ../../library/xml.etree.elementtree.rst:453
msgid ""
"Selects all elements for which the given attribute has the given value.  The "
"value cannot contain quotes."
msgstr ""
"Выбирает все элементы, для которых данный атрибут имеет заданное значение. "
"Значение не может содержать кавычки."

#: ../../library/xml.etree.elementtree.rst:457
msgid "``[@attrib!='value']``"
msgstr "``[@attrib!='value']``"

#: ../../library/xml.etree.elementtree.rst:457
msgid ""
"Selects all elements for which the given attribute does not have the given "
"value. The value cannot contain quotes."
msgstr ""
"Выбирает все элементы, для которых данный атрибут не имеет заданного "
"значения. Значение не может содержать кавычки."

#: ../../library/xml.etree.elementtree.rst:463
msgid "``[tag]``"
msgstr "``[tag]``"

#: ../../library/xml.etree.elementtree.rst:463
msgid ""
"Selects all elements that have a child named ``tag``.  Only immediate "
"children are supported."
msgstr ""
"Выбирает все элементы, у которых есть дочерний элемент с именем «tag». "
"Поддерживаются только непосредственные дети."

#: ../../library/xml.etree.elementtree.rst:466
msgid "``[.='text']``"
msgstr "``[.='text']``"

#: ../../library/xml.etree.elementtree.rst:466
msgid ""
"Selects all elements whose complete text content, including descendants, "
"equals the given ``text``."
msgstr ""
"Выбирает все элементы, полное текстовое содержимое которых, включая "
"потомков, равно заданному ``тексту``."

#: ../../library/xml.etree.elementtree.rst:471
msgid "``[.!='text']``"
msgstr "``[.!='text']``"

#: ../../library/xml.etree.elementtree.rst:471
msgid ""
"Selects all elements whose complete text content, including descendants, "
"does not equal the given ``text``."
msgstr ""
"Выбирает все элементы, полное текстовое содержимое которых, включая "
"потомков, не соответствует заданному ``тексту``."

#: ../../library/xml.etree.elementtree.rst:477
msgid "``[tag='text']``"
msgstr "``[tag='text']``"

#: ../../library/xml.etree.elementtree.rst:477
msgid ""
"Selects all elements that have a child named ``tag`` whose complete text "
"content, including descendants, equals the given ``text``."
msgstr ""
"Выбирает все элементы, у которых есть дочерний элемент с именем «tag», "
"полное текстовое содержимое которого, включая потомков, равно заданному "
"«тексту»."

#: ../../library/xml.etree.elementtree.rst:481
msgid "``[tag!='text']``"
msgstr "``[tag!='text']``"

#: ../../library/xml.etree.elementtree.rst:481
msgid ""
"Selects all elements that have a child named ``tag`` whose complete text "
"content, including descendants, does not equal the given ``text``."
msgstr ""
"Выбирает все элементы, у которых есть дочерний элемент с именем «tag», "
"полное текстовое содержимое которого, включая потомков, не соответствует "
"заданному «тексту»."

#: ../../library/xml.etree.elementtree.rst:487
msgid "``[position]``"
msgstr "``[position]``"

#: ../../library/xml.etree.elementtree.rst:487
msgid ""
"Selects all elements that are located at the given position.  The position "
"can be either an integer (1 is the first position), the expression "
"``last()`` (for the last position), or a position relative to the last "
"position (e.g. ``last()-1``)."
msgstr ""
"Выбирает все элементы, расположенные в заданной позиции. Позиция может быть "
"либо целым числом (1 – первая позиция), выражением ``last()`` (для последней "
"позиции) или позицией относительно последней позиции (например, "
"``last()-1``. )."

#: ../../library/xml.etree.elementtree.rst:494
msgid ""
"Predicates (expressions within square brackets) must be preceded by a tag "
"name, an asterisk, or another predicate.  ``position`` predicates must be "
"preceded by a tag name."
msgstr ""
"Предикатам (выражениям в квадратных скобках) должно предшествовать имя тега, "
"звездочка или другой предикат. Предикату ``position`` должно предшествовать "
"имя тега."

#: ../../library/xml.etree.elementtree.rst:499
#: ../../library/xml.etree.elementtree.rst:829
msgid "Reference"
msgstr "Ссылка"

#: ../../library/xml.etree.elementtree.rst:504
#: ../../library/xml.etree.elementtree.rst:834
msgid "Functions"
msgstr "Функции"

#: ../../library/xml.etree.elementtree.rst:508
msgid "`C14N 2.0 <https://www.w3.org/TR/xml-c14n2/>`_ transformation function."
msgstr "`C14N 2.0 <https://www.w3.org/TR/xml-c14n2/>`_ функция преобразования."

#: ../../library/xml.etree.elementtree.rst:510
msgid ""
"Canonicalization is a way to normalise XML output in a way that allows byte-"
"by-byte comparisons and digital signatures.  It reduced the freedom that XML "
"serializers have and instead generates a more constrained XML "
"representation.  The main restrictions regard the placement of namespace "
"declarations, the ordering of attributes, and ignorable whitespace."
msgstr ""

#: ../../library/xml.etree.elementtree.rst:516
msgid ""
"This function takes an XML data string (*xml_data*) or a file path or file-"
"like object (*from_file*) as input, converts it to the canonical form, and "
"writes it out using the *out* file(-like) object, if provided, or returns it "
"as a text string if not.  The output file receives text, not bytes.  It "
"should therefore be opened in text mode with ``utf-8`` encoding."
msgstr ""
"Эта функция принимает строку данных XML (*xml_data*) или путь к файлу или "
"файлоподобный объект (*from_file*) в качестве входных данных, преобразует ее "
"в каноническую форму и записывает ее с использованием *out* file(-like) "
"объект, если он предоставлен, или возвращает его в виде текстовой строки, "
"если нет. Выходной файл получает текст, а не байты. Поэтому его следует "
"открывать в текстовом режиме с кодировкой «utf-8»."

#: ../../library/xml.etree.elementtree.rst:523
msgid "Typical uses::"
msgstr "Типичное применение::"

#: ../../library/xml.etree.elementtree.rst:534
msgid "The configuration *options* are as follows:"
msgstr "*options* конфигурации следующие:"

#: ../../library/xml.etree.elementtree.rst:536
msgid "*with_comments*: set to true to include comments (default: false)"
msgstr ""
"*with_comments*: установите значение true, чтобы включать комментарии (по "
"умолчанию: false)"

#: ../../library/xml.etree.elementtree.rst:537
msgid ""
"*strip_text*: set to true to strip whitespace before and after text content"
msgstr ""
"*strip_text*: установите значение true, чтобы удалить пробелы до и после "
"текстового содержимого."

#: ../../library/xml.etree.elementtree.rst:538
#: ../../library/xml.etree.elementtree.rst:540
msgid "(default: false)"
msgstr "(по умолчанию: ложь)"

#: ../../library/xml.etree.elementtree.rst:539
msgid ""
"*rewrite_prefixes*: set to true to replace namespace prefixes by "
"\"n{number}\""
msgstr ""
"*rewrite_prefixes*: установите значение true, чтобы заменить префиксы "
"пространства имен на «n{number}»."

#: ../../library/xml.etree.elementtree.rst:541
msgid "*qname_aware_tags*: a set of qname aware tag names in which prefixes"
msgstr ""
"*qname_aware_tags*: набор имен тегов, поддерживающих qname, в которых "
"префиксы"

#: ../../library/xml.etree.elementtree.rst:542
#: ../../library/xml.etree.elementtree.rst:544
msgid "should be replaced in text content (default: empty)"
msgstr "следует заменить в текстовом содержимом (по умолчанию: пусто)"

#: ../../library/xml.etree.elementtree.rst:543
msgid ""
"*qname_aware_attrs*: a set of qname aware attribute names in which prefixes"
msgstr ""
"*qname_aware_attrs*: набор имен атрибутов, учитывающих qname, в которых "
"префиксы"

#: ../../library/xml.etree.elementtree.rst:545
msgid "*exclude_attrs*: a set of attribute names that should not be serialised"
msgstr ""
"*exclude_attrs*: набор имен атрибутов, которые не следует сериализовать."

#: ../../library/xml.etree.elementtree.rst:546
msgid "*exclude_tags*: a set of tag names that should not be serialised"
msgstr "*exclude_tags*: набор имен тегов, которые не следует сериализовать."

#: ../../library/xml.etree.elementtree.rst:548
msgid ""
"In the option list above, \"a set\" refers to any collection or iterable of "
"strings, no ordering is expected."
msgstr ""
"В приведенном выше списке параметров «набор» относится к любой коллекции или "
"итерации строк, упорядочение не предполагается."

#: ../../library/xml.etree.elementtree.rst:556
msgid ""
"Comment element factory.  This factory function creates a special element "
"that will be serialized as an XML comment by the standard serializer.  The "
"comment string can be either a bytestring or a Unicode string.  *text* is a "
"string containing the comment string.  Returns an element instance "
"representing a comment."
msgstr ""
"Фабрика элементов комментариев. Эта фабричная функция создает специальный "
"элемент, который будет сериализован в виде комментария XML стандартным "
"сериализатором. Строка комментария может быть либо байтовой строкой, либо "
"строкой Юникода. *текст* — это строка, содержащая строку комментария. "
"Возвращает экземпляр элемента, представляющий комментарий."

#: ../../library/xml.etree.elementtree.rst:562
msgid ""
"Note that :class:`XMLParser` skips over comments in the input instead of "
"creating comment objects for them. An :class:`ElementTree` will only contain "
"comment nodes if they have been inserted into to the tree using one of the :"
"class:`Element` methods."
msgstr ""
"Обратите внимание, что :class:`XMLParser` пропускает комментарии во входных "
"данных вместо того, чтобы создавать для них объекты комментариев. :class:"
"`ElementTree` будет содержать узлы комментариев только в том случае, если "
"они были вставлены в дерево с помощью одного из методов :class:`Element`."

#: ../../library/xml.etree.elementtree.rst:569
msgid ""
"Writes an element tree or element structure to sys.stdout.  This function "
"should be used for debugging only."
msgstr ""
"Записывает дерево элементов или структуру элементов в sys.stdout. Эту "
"функцию следует использовать только для отладки."

#: ../../library/xml.etree.elementtree.rst:572
msgid ""
"The exact output format is implementation dependent.  In this version, it's "
"written as an ordinary XML file."
msgstr ""
"Точный формат вывода зависит от реализации. В этой версии он записан как "
"обычный XML-файл."

#: ../../library/xml.etree.elementtree.rst:575
msgid "*elem* is an element tree or an individual element."
msgstr "*elem* — дерево элементов или отдельный элемент."

#: ../../library/xml.etree.elementtree.rst:577
msgid ""
"The :func:`dump` function now preserves the attribute order specified by the "
"user."
msgstr ""
"Функция :func:`dump` теперь сохраняет порядок атрибутов, указанный "
"пользователем."

#: ../../library/xml.etree.elementtree.rst:584
msgid ""
"Parses an XML section from a string constant.  Same as :func:`XML`.  *text* "
"is a string containing XML data.  *parser* is an optional parser instance. "
"If not given, the standard :class:`XMLParser` parser is used. Returns an :"
"class:`Element` instance."
msgstr ""
"Анализирует раздел XML из строковой константы. То же, что :func:`XML`. "
"*текст* — это строка, содержащая данные XML. *parser* — необязательный "
"экземпляр синтаксического анализатора. Если не указано, используется "
"стандартный парсер :class:`XMLParser`. Возвращает экземпляр :class:`Element`."

#: ../../library/xml.etree.elementtree.rst:592
msgid ""
"Parses an XML document from a sequence of string fragments.  *sequence* is a "
"list or other sequence containing XML data fragments.  *parser* is an "
"optional parser instance.  If not given, the standard :class:`XMLParser` "
"parser is used.  Returns an :class:`Element` instance."
msgstr ""
"Анализирует XML-документ из последовательности фрагментов строк. "
"*последовательность* — список или другая последовательность, содержащая "
"фрагменты данных XML. *parser* — необязательный экземпляр синтаксического "
"анализатора. Если не указано, используется стандартный парсер :class:"
"`XMLParser`. Возвращает экземпляр :class:`Element`."

#: ../../library/xml.etree.elementtree.rst:602
msgid ""
"Appends whitespace to the subtree to indent the tree visually. This can be "
"used to generate pretty-printed XML output. *tree* can be an Element or "
"ElementTree.  *space* is the whitespace string that will be inserted for "
"each indentation level, two space characters by default.  For indenting "
"partial subtrees inside of an already indented tree, pass the initial "
"indentation level as *level*."
msgstr ""
"Добавляет пробелы к поддереву для визуального отступа дерева. Это можно "
"использовать для создания красивого вывода XML. *tree* может быть элементом "
"или ElementTree. *пробел* — это строка пробелов, которая будет вставлена ​​для "
"каждого уровня отступа, по умолчанию два символа пробела. Для отступа "
"частичных поддеревьев внутри уже имеющегося дерева передайте начальный "
"уровень отступа как *level*."

#: ../../library/xml.etree.elementtree.rst:614
msgid ""
"Check if an object appears to be a valid element object.  *element* is an "
"element instance.  Return ``True`` if this is an element object."
msgstr ""
"Проверьте, является ли объект допустимым объектом-элементом. *element* — "
"экземпляр элемента. Верните ``True``, если это объект-элемент."

#: ../../library/xml.etree.elementtree.rst:620
msgid ""
"Parses an XML section into an element tree incrementally, and reports what's "
"going on to the user.  *source* is a filename or :term:`file object` "
"containing XML data.  *events* is a sequence of events to report back.  The "
"supported events are the strings ``\"start\"``, ``\"end\"``, "
"``\"comment\"``, ``\"pi\"``, ``\"start-ns\"`` and ``\"end-ns\"`` (the \"ns\" "
"events are used to get detailed namespace information).  If *events* is "
"omitted, only ``\"end\"`` events are reported. *parser* is an optional "
"parser instance.  If not given, the standard :class:`XMLParser` parser is "
"used.  *parser* must be a subclass of :class:`XMLParser` and can only use "
"the default :class:`TreeBuilder` as a target. Returns an :term:`iterator` "
"providing ``(event, elem)`` pairs; it has a ``root`` attribute that "
"references the root element of the resulting XML tree once *source* is fully "
"read."
msgstr ""
"Постепенно анализирует раздел XML в дереве элементов и сообщает "
"пользователю, что происходит. *source* — это имя файла или :term:`файловый "
"объект`, содержащий данные XML. *events* — это последовательность событий, о "
"которых необходимо сообщить. Поддерживаемые события — это строки "
"``\"start\", ``\"end\"``, ``\"comment\"``, ``\"pi\"``, ``\"start-ns\"`` и `` "
"\"end-ns\"`` (события \"ns\" используются для получения подробной информации "
"о пространстве имен). Если *events* опущено, сообщается только о "
"``конечных'` событиях. *parser* — необязательный экземпляр синтаксического "
"анализатора. Если не указано, используется стандартный парсер :class:"
"`XMLParser`. *parser* должен быть подклассом :class:`XMLParser` и может "
"использовать в качестве цели только :class:`TreeBuilder` по умолчанию. "
"Возвращает :term:`итератор`, предоставляющий пары ``(event, elem)``; у него "
"есть атрибут root, который ссылается на корневой элемент результирующего XML-"
"дерева после полного чтения *source*."

#: ../../library/xml.etree.elementtree.rst:634
msgid ""
"Note that while :func:`iterparse` builds the tree incrementally, it issues "
"blocking reads on *source* (or the file it names).  As such, it's unsuitable "
"for applications where blocking reads can't be made.  For fully non-blocking "
"parsing, see :class:`XMLPullParser`."
msgstr ""
"Обратите внимание, что хотя :func:`iterparse` строит дерево постепенно, он "
"блокирует чтение *source* (или файла, который он называет). Таким образом, "
"он не подходит для приложений, в которых невозможно выполнить блокирующее "
"чтение. Для полного неблокирующего анализа см. :class:`XMLPullParser`."

#: ../../library/xml.etree.elementtree.rst:641
msgid ""
":func:`iterparse` only guarantees that it has seen the \">\" character of a "
"starting tag when it emits a \"start\" event, so the attributes are defined, "
"but the contents of the text and tail attributes are undefined at that "
"point.  The same applies to the element children; they may or may not be "
"present."
msgstr ""
":func:`iterparse` гарантирует, что он увидел символ \">\" начального тега "
"только тогда, когда генерирует событие \"start\", поэтому атрибуты "
"определены, но содержимое атрибутов text и Tail в этот момент не "
"определено. . То же самое относится и к дочерним элементам; они могут "
"присутствовать, а могут и не присутствовать."

#: ../../library/xml.etree.elementtree.rst:647
#: ../../library/xml.etree.elementtree.rst:1516
msgid "If you need a fully populated element, look for \"end\" events instead."
msgstr ""
"Если вам нужен полностью заполненный элемент, вместо этого ищите «конечные» "
"события."

#: ../../library/xml.etree.elementtree.rst:649
msgid "The *parser* argument."
msgstr "Аргумент *parser*."

#: ../../library/xml.etree.elementtree.rst:652
#: ../../library/xml.etree.elementtree.rst:1520
msgid "The ``comment`` and ``pi`` events were added."
msgstr "Были добавлены события ``comment`` и ``pi``."

#: ../../library/xml.etree.elementtree.rst:658
msgid ""
"Parses an XML section into an element tree.  *source* is a filename or file "
"object containing XML data.  *parser* is an optional parser instance.  If "
"not given, the standard :class:`XMLParser` parser is used.  Returns an :"
"class:`ElementTree` instance."
msgstr ""
"Анализирует раздел XML в дереве элементов. *source* — это имя файла или "
"файловый объект, содержащий данные XML. *parser* — необязательный экземпляр "
"синтаксического анализатора. Если не указано, используется стандартный "
"парсер :class:`XMLParser`. Возвращает экземпляр :class:`ElementTree`."

#: ../../library/xml.etree.elementtree.rst:666
msgid ""
"PI element factory.  This factory function creates a special element that "
"will be serialized as an XML processing instruction.  *target* is a string "
"containing the PI target.  *text* is a string containing the PI contents, if "
"given.  Returns an element instance, representing a processing instruction."
msgstr ""
"Фабрика элементов ПИ. Эта фабричная функция создает специальный элемент, "
"который будет сериализован как инструкция обработки XML. *target* — строка, "
"содержащая цель PI. *текст* — это строка, содержащая содержимое PI, если оно "
"указано. Возвращает экземпляр элемента, представляющий инструкцию обработки."

#: ../../library/xml.etree.elementtree.rst:671
msgid ""
"Note that :class:`XMLParser` skips over processing instructions in the input "
"instead of creating PI objects for them. An :class:`ElementTree` will only "
"contain processing instruction nodes if they have been inserted into to the "
"tree using one of the :class:`Element` methods."
msgstr ""
"Обратите внимание, что :class:`XMLParser` пропускает инструкции обработки во "
"входных данных вместо создания для них объектов PI. :class:`ElementTree` "
"будет содержать узлы инструкций обработки только в том случае, если они были "
"вставлены в дерево с помощью одного из :class:`Element` методов."

#: ../../library/xml.etree.elementtree.rst:679
msgid ""
"Registers a namespace prefix.  The registry is global, and any existing "
"mapping for either the given prefix or the namespace URI will be removed. "
"*prefix* is a namespace prefix.  *uri* is a namespace uri.  Tags and "
"attributes in this namespace will be serialized with the given prefix, if at "
"all possible."
msgstr ""
"Регистрирует префикс пространства имен. Реестр является глобальным, и все "
"существующие сопоставления для данного префикса или URI пространства имен "
"будут удалены. *prefix* — префикс пространства имен. *uri* — это "
"пространство имен uri. Теги и атрибуты в этом пространстве имен будут "
"сериализованы с заданным префиксом, если это вообще возможно."

#: ../../library/xml.etree.elementtree.rst:690
msgid ""
"Subelement factory.  This function creates an element instance, and appends "
"it to an existing element."
msgstr ""
"Завод субэлементов. Эта функция создает экземпляр элемента и добавляет его к "
"существующему элементу."

#: ../../library/xml.etree.elementtree.rst:693
msgid ""
"The element name, attribute names, and attribute values can be either "
"bytestrings or Unicode strings.  *parent* is the parent element.  *tag* is "
"the subelement name.  *attrib* is an optional dictionary, containing element "
"attributes.  *extra* contains additional attributes, given as keyword "
"arguments.  Returns an element instance."
msgstr ""
"Имя элемента, имена атрибутов и значения атрибутов могут быть либо байтовыми "
"строками, либо строками Юникода. *parent* — родительский элемент. *tag* — "
"имя подэлемента. *attrib* — необязательный словарь, содержащий атрибуты "
"элементов. *extra* содержит дополнительные атрибуты, заданные в качестве "
"аргументов ключевого слова. Возвращает экземпляр элемента."

#: ../../library/xml.etree.elementtree.rst:704
msgid ""
"Generates a string representation of an XML element, including all "
"subelements.  *element* is an :class:`Element` instance.  *encoding* [1]_ is "
"the output encoding (default is US-ASCII).  Use ``encoding=\"unicode\"`` to "
"generate a Unicode string (otherwise, a bytestring is generated).  *method* "
"is either ``\"xml\"``, ``\"html\"`` or ``\"text\"`` (default is "
"``\"xml\"``). *xml_declaration*, *default_namespace* and "
"*short_empty_elements* has the same meaning as in :meth:`ElementTree.write`. "
"Returns an (optionally) encoded string containing the XML data."
msgstr ""
"Создает строковое представление элемента XML, включая все подэлементы. "
"*element* — это экземпляр :class:`Element`. *кодировка* [1]_ — выходная "
"кодировка (по умолчанию — US-ASCII). Используйте ``encoding=\"unicode\"`` "
"для генерации строки Unicode (в противном случае генерируется байтовая "
"строка). *метод* — это ``\"xml\"``, ``\"html\"`` или ``\"text\"`` (по "
"умолчанию ``\"xml\"``). *xml_declaration*, *default_namespace* и "
"*short_empty_elements* имеют то же значение, что и в :meth:`ElementTree."
"write`. Возвращает (необязательно) закодированную строку, содержащую данные "
"XML."

#: ../../library/xml.etree.elementtree.rst:713
#: ../../library/xml.etree.elementtree.rst:740
#: ../../library/xml.etree.elementtree.rst:1194
msgid "Added the *short_empty_elements* parameter."
msgstr "Добавлен параметр *short_empty_elements*."

#: ../../library/xml.etree.elementtree.rst:716
#: ../../library/xml.etree.elementtree.rst:743
msgid "Added the *xml_declaration* and *default_namespace* parameters."
msgstr "Добавлены параметры *xml_declaration* и *default_namespace*."

#: ../../library/xml.etree.elementtree.rst:719
msgid ""
"The :func:`tostring` function now preserves the attribute order specified by "
"the user."
msgstr ""
"Функция :func:`tostring` теперь сохраняет порядок атрибутов, указанный "
"пользователем."

#: ../../library/xml.etree.elementtree.rst:728
msgid ""
"Generates a string representation of an XML element, including all "
"subelements.  *element* is an :class:`Element` instance.  *encoding* [1]_ is "
"the output encoding (default is US-ASCII).  Use ``encoding=\"unicode\"`` to "
"generate a Unicode string (otherwise, a bytestring is generated).  *method* "
"is either ``\"xml\"``, ``\"html\"`` or ``\"text\"`` (default is "
"``\"xml\"``). *xml_declaration*, *default_namespace* and "
"*short_empty_elements* has the same meaning as in :meth:`ElementTree.write`. "
"Returns a list of (optionally) encoded strings containing the XML data. It "
"does not guarantee any specific sequence, except that ``b\"\"."
"join(tostringlist(element)) == tostring(element)``."
msgstr ""
"Создает строковое представление элемента XML, включая все подэлементы. "
"*element* — это экземпляр :class:`Element`. *кодировка* [1]_ — выходная "
"кодировка (по умолчанию — US-ASCII). Используйте ``encoding=\"unicode\"`` "
"для генерации строки Unicode (в противном случае генерируется байтовая "
"строка). *метод* — это ``\"xml\"``, ``\"html\"`` или ``\"text\"`` (по "
"умолчанию ``\"xml\"``). *xml_declaration*, *default_namespace* и "
"*short_empty_elements* имеют то же значение, что и в :meth:`ElementTree."
"write`. Возвращает список (необязательно) закодированных строк, содержащих "
"данные XML. Он не гарантирует какой-либо конкретной последовательности, за "
"исключением того, что ``b\"\".join(tostringlist(element)) == "
"tostring(element)``."

#: ../../library/xml.etree.elementtree.rst:746
msgid ""
"The :func:`tostringlist` function now preserves the attribute order "
"specified by the user."
msgstr ""
"Функция :func:`tostringlist` теперь сохраняет порядок атрибутов, указанный "
"пользователем."

#: ../../library/xml.etree.elementtree.rst:753
msgid ""
"Parses an XML section from a string constant.  This function can be used to "
"embed \"XML literals\" in Python code.  *text* is a string containing XML "
"data.  *parser* is an optional parser instance.  If not given, the standard :"
"class:`XMLParser` parser is used.  Returns an :class:`Element` instance."
msgstr ""
"Анализирует раздел XML из строковой константы. Эту функцию можно "
"использовать для встраивания «литералов XML» в код Python. *текст* — это "
"строка, содержащая данные XML. *parser* — необязательный экземпляр "
"синтаксического анализатора. Если не указано, используется стандартный "
"парсер :class:`XMLParser`. Возвращает экземпляр :class:`Element`."

#: ../../library/xml.etree.elementtree.rst:761
msgid ""
"Parses an XML section from a string constant, and also returns a dictionary "
"which maps from element id:s to elements.  *text* is a string containing XML "
"data.  *parser* is an optional parser instance.  If not given, the standard :"
"class:`XMLParser` parser is used.  Returns a tuple containing an :class:"
"`Element` instance and a dictionary."
msgstr ""
"Анализирует раздел XML из строковой константы, а также возвращает словарь, "
"который сопоставляет идентификаторы элементов с элементами. *текст* — это "
"строка, содержащая данные XML. *parser* — необязательный экземпляр "
"синтаксического анализатора. Если не указано, используется стандартный "
"парсер :class:`XMLParser`. Возвращает кортеж, содержащий экземпляр :class:"
"`Element` и словарь."

#: ../../library/xml.etree.elementtree.rst:771
msgid "XInclude support"
msgstr "Поддержка XInclude"

#: ../../library/xml.etree.elementtree.rst:773
msgid ""
"This module provides limited support for `XInclude directives <https://www."
"w3.org/TR/xinclude/>`_, via the :mod:`xml.etree.ElementInclude` helper "
"module.  This module can be used to insert subtrees and text strings into "
"element trees, based on information in the tree."
msgstr ""
"Этот модуль обеспечивает ограниченную поддержку директив XInclude <https://"
"www.w3.org/TR/xinclude/>`_ через вспомогательный модуль :mod:`xml.etree."
"ElementInclude`. Этот модуль можно использовать для вставки поддеревьев и "
"текстовых строк в деревья элементов на основе информации в дереве."

#: ../../library/xml.etree.elementtree.rst:779
msgid ""
"Here's an example that demonstrates use of the XInclude module. To include "
"an XML document in the current document, use the ``{http://www.w3.org/2001/"
"XInclude}include`` element and set the **parse** attribute to ``\"xml\"``, "
"and use the **href** attribute to specify the document to include."
msgstr ""
"Вот пример, демонстрирующий использование модуля XInclude. Чтобы включить "
"XML-документ в текущий документ, используйте элемент ``{http://www.w3."
"org/2001/XInclude}include`` и установите для атрибута **parse** значение "
"``\"xml\"``. и используйте атрибут **href**, чтобы указать включаемый "
"документ."

#: ../../library/xml.etree.elementtree.rst:788
msgid ""
"By default, the **href** attribute is treated as a file name. You can use "
"custom loaders to override this behaviour. Also note that the standard "
"helper does not support XPointer syntax."
msgstr ""
"По умолчанию атрибут **href** рассматривается как имя файла. Вы можете "
"использовать специальные загрузчики, чтобы переопределить это поведение. "
"Также обратите внимание, что стандартный помощник не поддерживает синтаксис "
"XPointer."

#: ../../library/xml.etree.elementtree.rst:790
msgid ""
"To process this file, load it as usual, and pass the root element to the :"
"mod:`xml.etree.ElementTree` module:"
msgstr ""
"Чтобы обработать этот файл, загрузите его как обычно и передайте корневой "
"элемент модулю :mod:`xml.etree.ElementTree`:"

#: ../../library/xml.etree.elementtree.rst:801
msgid ""
"The ElementInclude module replaces the ``{http://www.w3.org/2001/XInclude}"
"include`` element with the root element from the **source.xml** document. "
"The result might look something like this:"
msgstr ""
"Модуль ElementInclude заменяет элемент ``{http://www.w3.org/2001/XInclude}"
"include`` корневым элементом из документа **source.xml**. Результат может "
"выглядеть примерно так:"

#: ../../library/xml.etree.elementtree.rst:809
msgid ""
"If the **parse** attribute is omitted, it defaults to \"xml\". The href "
"attribute is required."
msgstr ""
"Если атрибут **parse** опущен, по умолчанию используется значение «xml». "
"Атрибут href является обязательным."

#: ../../library/xml.etree.elementtree.rst:811
msgid ""
"To include a text document, use the ``{http://www.w3.org/2001/XInclude}"
"include`` element, and set the **parse** attribute to \"text\":"
msgstr ""
"Чтобы включить текстовый документ, используйте элемент ``{http://www.w3."
"org/2001/XInclude}include`` и установите для атрибута **parse** значение "
"\"text\":"

#: ../../library/xml.etree.elementtree.rst:820
msgid "The result might look something like:"
msgstr "Результат может выглядеть примерно так:"

#: ../../library/xml.etree.elementtree.rst:841
msgid ""
"Default loader. This default loader reads an included resource from disk.  "
"*href* is a URL. *parse* is for parse mode either \"xml\" or \"text\".  "
"*encoding* is an optional text encoding.  If not given, encoding is "
"``utf-8``.  Returns the expanded resource.  If the parse mode is "
"``\"xml\"``, this is an ElementTree instance.  If the parse mode is "
"\"text\", this is a Unicode string.  If the loader fails, it can return None "
"or raise an exception."
msgstr ""

#: ../../library/xml.etree.elementtree.rst:853
msgid ""
"This function expands XInclude directives.  *elem* is the root element.  "
"*loader* is an optional resource loader.  If omitted, it defaults to :func:"
"`default_loader`. If given, it should be a callable that implements the same "
"interface as :func:`default_loader`.  *base_url* is base URL of the original "
"file, to resolve relative include file references.  *max_depth* is the "
"maximum number of recursive inclusions.  Limited to reduce the risk of "
"malicious content explosion. Pass a negative value to disable the limitation."
msgstr ""

#: ../../library/xml.etree.elementtree.rst:861
msgid ""
"Returns the expanded resource.  If the parse mode is ``\"xml\"``, this is an "
"ElementTree instance.  If the parse mode is \"text\", this is a Unicode "
"string.  If the loader fails, it can return None or raise an exception."
msgstr ""

#: ../../library/xml.etree.elementtree.rst:866
msgid "Added the *base_url* and *max_depth* parameters."
msgstr "Добавлены параметры *base_url* и ​​*max_length*."

#: ../../library/xml.etree.elementtree.rst:873
msgid "Element Objects"
msgstr "Объекты элементов"

#: ../../library/xml.etree.elementtree.rst:880
msgid ""
"Element class.  This class defines the Element interface, and provides a "
"reference implementation of this interface."
msgstr ""
"Класс элемента. Этот класс определяет интерфейс Element и предоставляет "
"эталонную реализацию этого интерфейса."

#: ../../library/xml.etree.elementtree.rst:883
msgid ""
"The element name, attribute names, and attribute values can be either "
"bytestrings or Unicode strings.  *tag* is the element name.  *attrib* is an "
"optional dictionary, containing element attributes.  *extra* contains "
"additional attributes, given as keyword arguments."
msgstr ""
"Имя элемента, имена атрибутов и значения атрибутов могут быть либо байтовыми "
"строками, либо строками Юникода. *tag* — имя элемента. *attrib* — "
"необязательный словарь, содержащий атрибуты элементов. *extra* содержит "
"дополнительные атрибуты, заданные в качестве аргументов ключевого слова."

#: ../../library/xml.etree.elementtree.rst:891
msgid ""
"A string identifying what kind of data this element represents (the element "
"type, in other words)."
msgstr ""
"Строка, определяющая, какие данные представляет этот элемент (другими "
"словами, тип элемента)."

#: ../../library/xml.etree.elementtree.rst:898
msgid ""
"These attributes can be used to hold additional data associated with the "
"element.  Their values are usually strings but may be any application-"
"specific object.  If the element is created from an XML file, the *text* "
"attribute holds either the text between the element's start tag and its "
"first child or end tag, or ``None``, and the *tail* attribute holds either "
"the text between the element's end tag and the next tag, or ``None``.  For "
"the XML data"
msgstr ""
"Эти атрибуты можно использовать для хранения дополнительных данных, "
"связанных с элементом. Их значения обычно представляют собой строки, но "
"могут быть любым объектом, специфичным для приложения. Если элемент создан "
"из XML-файла, атрибут *text* содержит либо текст между начальным тегом "
"элемента и его первым дочерним или конечным тегом, либо «Нет», а атрибут "
"*tail* содержит либо текст между конечный тег элемента и следующий тег или "
"``None``. Для XML-данных"

#: ../../library/xml.etree.elementtree.rst:910
msgid ""
"the *a* element has ``None`` for both *text* and *tail* attributes, the *b* "
"element has *text* ``\"1\"`` and *tail* ``\"4\"``, the *c* element has "
"*text* ``\"2\"`` and *tail* ``None``, and the *d* element has *text* "
"``None`` and *tail* ``\"3\"``."
msgstr ""
"элемент *a* имеет атрибут None для атрибутов *text* и *tail*, элемент *b* "
"имеет *text* ``\"1\"`` и *tail* ``\"4\"``, элемент *c* имеет *text* "
"``\"2\"`` и *tail* ``None``, а элемент *d* имеет *text* ``None`` и *tail* "
"``\"3\" ``."

#: ../../library/xml.etree.elementtree.rst:915
msgid ""
"To collect the inner text of an element, see :meth:`itertext`, for example "
"``\"\".join(element.itertext())``."
msgstr ""
"Чтобы собрать внутренний текст элемента, см. :meth:`itertext`, например "
"``\"\".join(element.itertext())``."

#: ../../library/xml.etree.elementtree.rst:918
msgid "Applications may store arbitrary objects in these attributes."
msgstr "Приложения могут хранить в этих атрибутах произвольные объекты."

#: ../../library/xml.etree.elementtree.rst:923
msgid ""
"A dictionary containing the element's attributes.  Note that while the "
"*attrib* value is always a real mutable Python dictionary, an ElementTree "
"implementation may choose to use another internal representation, and create "
"the dictionary only if someone asks for it.  To take advantage of such "
"implementations, use the dictionary methods below whenever possible."
msgstr ""
"Словарь, содержащий атрибуты элемента. Обратите внимание: хотя значение "
"*attrib* всегда является реальным изменяемым словарем Python, реализация "
"ElementTree может использовать другое внутреннее представление и создавать "
"словарь только в том случае, если кто-то об этом попросит. Чтобы "
"воспользоваться преимуществами таких реализаций, по возможности используйте "
"приведенные ниже методы словаря."

#: ../../library/xml.etree.elementtree.rst:929
msgid "The following dictionary-like methods work on the element attributes."
msgstr "Следующие словарные методы работают с атрибутами элементов."

#: ../../library/xml.etree.elementtree.rst:934
msgid ""
"Resets an element.  This function removes all subelements, clears all "
"attributes, and sets the text and tail attributes to ``None``."
msgstr ""
"Сбрасывает элемент. Эта функция удаляет все подэлементы, очищает все "
"атрибуты и устанавливает для атрибутов текста и хвоста значение «Нет»."

#: ../../library/xml.etree.elementtree.rst:940
msgid "Gets the element attribute named *key*."
msgstr "Получает атрибут элемента с именем *key*."

#: ../../library/xml.etree.elementtree.rst:942
msgid ""
"Returns the attribute value, or *default* if the attribute was not found."
msgstr ""
"Возвращает значение атрибута или *по умолчанию*, если атрибут не найден."

#: ../../library/xml.etree.elementtree.rst:947
msgid ""
"Returns the element attributes as a sequence of (name, value) pairs.  The "
"attributes are returned in an arbitrary order."
msgstr ""
"Возвращает атрибуты элемента в виде последовательности пар (имя, значение). "
"Атрибуты возвращаются в произвольном порядке."

#: ../../library/xml.etree.elementtree.rst:953
msgid ""
"Returns the elements attribute names as a list.  The names are returned in "
"an arbitrary order."
msgstr ""
"Возвращает имена атрибутов элементов в виде списка. Имена возвращаются в "
"произвольном порядке."

#: ../../library/xml.etree.elementtree.rst:959
msgid "Set the attribute *key* on the element to *value*."
msgstr "Установите для атрибута *key* элемента значение *value*."

#: ../../library/xml.etree.elementtree.rst:961
msgid "The following methods work on the element's children (subelements)."
msgstr "Следующие методы работают с дочерними элементами (подэлементами)."

#: ../../library/xml.etree.elementtree.rst:966
msgid ""
"Adds the element *subelement* to the end of this element's internal list of "
"subelements.  Raises :exc:`TypeError` if *subelement* is not an :class:"
"`Element`."
msgstr ""
"Добавляет элемент *подэлемент* в конец внутреннего списка подэлементов этого "
"элемента. Вызывает :exc:`TypeError`, если *подэлемент* не является :class:"
"`Element`."

#: ../../library/xml.etree.elementtree.rst:973
msgid ""
"Appends *subelements* from a sequence object with zero or more elements. "
"Raises :exc:`TypeError` if a subelement is not an :class:`Element`."
msgstr ""

#: ../../library/xml.etree.elementtree.rst:981
msgid ""
"Finds the first subelement matching *match*.  *match* may be a tag name or "
"a :ref:`path <elementtree-xpath>`.  Returns an element instance or "
"``None``.  *namespaces* is an optional mapping from namespace prefix to full "
"name.  Pass ``''`` as prefix to move all unprefixed tag names in the "
"expression into the given namespace."
msgstr ""
"Находит первый подэлемент, соответствующий *match*. *match* может быть "
"именем тега или :ref:`path <elementtree-xpath>`. Возвращает экземпляр "
"элемента или ``None``. *namespaces* — это необязательное сопоставление "
"префикса пространства имен с полным именем. Передайте ``''`` в качестве "
"префикса, чтобы переместить все имена тегов без префикса в выражении в "
"заданное пространство имен."

#: ../../library/xml.etree.elementtree.rst:990
msgid ""
"Finds all matching subelements, by tag name or :ref:`path <elementtree-"
"xpath>`.  Returns a list containing all matching elements in document "
"order.  *namespaces* is an optional mapping from namespace prefix to full "
"name.  Pass ``''`` as prefix to move all unprefixed tag names in the "
"expression into the given namespace."
msgstr ""
"Находит все соответствующие подэлементы по имени тега или :ref:`path "
"<elementtree-xpath>`. Возвращает список, содержащий все соответствующие "
"элементы в порядке документа. *namespaces* — это необязательное "
"сопоставление префикса пространства имен с полным именем. Передайте ``''`` в "
"качестве префикса, чтобы переместить все имена тегов без префикса в "
"выражении в заданное пространство имен."

#: ../../library/xml.etree.elementtree.rst:999
msgid ""
"Finds text for the first subelement matching *match*.  *match* may be a tag "
"name or a :ref:`path <elementtree-xpath>`.  Returns the text content of the "
"first matching element, or *default* if no element was found. Note that if "
"the matching element has no text content an empty string is returned. "
"*namespaces* is an optional mapping from namespace prefix to full name.  "
"Pass ``''`` as prefix to move all unprefixed tag names in the expression "
"into the given namespace."
msgstr ""
"Находит текст для первого подэлемента, соответствующего *match*. *match* "
"может быть именем тега или :ref:`path <elementtree-xpath>`. Возвращает "
"текстовое содержимое первого совпадающего элемента или *по умолчанию*, если "
"элемент не найден. Обратите внимание: если соответствующий элемент не имеет "
"текстового содержимого, возвращается пустая строка. *namespaces* — это "
"необязательное сопоставление префикса пространства имен с полным именем. "
"Передайте ``''`` в качестве префикса, чтобы переместить все имена тегов без "
"префикса в выражении в заданное пространство имен."

#: ../../library/xml.etree.elementtree.rst:1010
msgid ""
"Inserts *subelement* at the given position in this element.  Raises :exc:"
"`TypeError` if *subelement* is not an :class:`Element`."
msgstr ""
"Вставляет *подэлемент* в заданную позицию в этом элементе. Вызывает :exc:"
"`TypeError`, если *подэлемент* не является :class:`Element`."

#: ../../library/xml.etree.elementtree.rst:1016
msgid ""
"Creates a tree :term:`iterator` with the current element as the root. The "
"iterator iterates over this element and all elements below it, in document "
"(depth first) order.  If *tag* is not ``None`` or ``'*'``, only elements "
"whose tag equals *tag* are returned from the iterator.  If the tree "
"structure is modified during iteration, the result is undefined."
msgstr ""
"Создает дерево :term:`iterator` с текущим элементом в качестве корня. "
"Итератор перебирает этот элемент и все элементы ниже него в порядке "
"документа (сначала в глубину). Если *tag* не равен ``None`` или ``'*'``, из "
"итератора возвращаются только элементы, тег которых равен *tag*. Если "
"древовидная структура изменяется во время итерации, результат не определен."

#: ../../library/xml.etree.elementtree.rst:1027
msgid ""
"Finds all matching subelements, by tag name or :ref:`path <elementtree-"
"xpath>`.  Returns an iterable yielding all matching elements in document "
"order. *namespaces* is an optional mapping from namespace prefix to full "
"name."
msgstr ""
"Находит все соответствующие подэлементы по имени тега или :ref:`path "
"<elementtree-xpath>`. Возвращает итерацию, возвращающую все соответствующие "
"элементы в порядке документа. *namespaces* — это необязательное "
"сопоставление префикса пространства имен с полным именем."

#: ../../library/xml.etree.elementtree.rst:1038
msgid ""
"Creates a text iterator.  The iterator loops over this element and all "
"subelements, in document order, and returns all inner text."
msgstr ""
"Создает текстовый итератор. Итератор проходит по этому элементу и всем "
"подэлементам в порядке документа и возвращает весь внутренний текст."

#: ../../library/xml.etree.elementtree.rst:1046
msgid ""
"Creates a new element object of the same type as this element.  Do not call "
"this method, use the :func:`SubElement` factory function instead."
msgstr ""
"Создает новый объект элемента того же типа, что и этот элемент. Не вызывайте "
"этот метод, используйте вместо него фабричную функцию :func:`SubElement`."

#: ../../library/xml.etree.elementtree.rst:1052
msgid ""
"Removes *subelement* from the element.  Unlike the find\\* methods this "
"method compares elements based on the instance identity, not on tag value or "
"contents."
msgstr ""
"Удаляет *подэлемент* из элемента. В отличие от методов find\\* этот метод "
"сравнивает элементы на основе идентификатора экземпляра, а не значения тега "
"или содержимого."

#: ../../library/xml.etree.elementtree.rst:1056
msgid ""
":class:`Element` objects also support the following sequence type methods "
"for working with subelements: :meth:`~object.__delitem__`, :meth:`~object."
"__getitem__`, :meth:`~object.__setitem__`, :meth:`~object.__len__`."
msgstr ""
"Объекты :class:`Element` также поддерживают следующие методы типа "
"последовательности для работы с подэлементами: :meth:`~object.__delitem__`, :"
"meth:`~object.__getitem__`, :meth:`~object.__setitem__`, : meth:`~object."
"__len__`."

#: ../../library/xml.etree.elementtree.rst:1061
msgid ""
"Caution: Elements with no subelements will test as ``False``.  This behavior "
"will change in future versions.  Use specific ``len(elem)`` or ``elem is "
"None`` test instead. ::"
msgstr ""

#: ../../library/xml.etree.elementtree.rst:1073
msgid ""
"Prior to Python 3.8, the serialisation order of the XML attributes of "
"elements was artificially made predictable by sorting the attributes by "
"their name. Based on the now guaranteed ordering of dicts, this arbitrary "
"reordering was removed in Python 3.8 to preserve the order in which "
"attributes were originally parsed or created by user code."
msgstr ""
"До Python 3.8 порядок сериализации атрибутов XML элементов искусственно "
"делался предсказуемым путем сортировки атрибутов по их именам. Основываясь "
"на теперь гарантированном порядке диктовок, это произвольное "
"переупорядочение было удалено в Python 3.8, чтобы сохранить порядок, в "
"котором атрибуты изначально анализировались или создавались пользовательским "
"кодом."

#: ../../library/xml.etree.elementtree.rst:1079
msgid ""
"In general, user code should try not to depend on a specific ordering of "
"attributes, given that the `XML Information Set <https://www.w3.org/TR/xml-"
"infoset/>`_ explicitly excludes the attribute order from conveying "
"information. Code should be prepared to deal with any ordering on input. In "
"cases where deterministic XML output is required, e.g. for cryptographic "
"signing or test data sets, canonical serialisation is available with the :"
"func:`canonicalize` function."
msgstr ""
"В общем, пользовательский код должен стараться не зависеть от определенного "
"порядка атрибутов, учитывая, что `Набор информации XML <https://www.w3.org/"
"TR/xml-infoset/>`_ явно исключает порядок атрибутов из передающая "
"информацию. Код должен быть готов справиться с любым упорядочиванием входных "
"данных. В случаях, когда требуется детерминированный вывод XML, например, "
"для криптографической подписи или наборов тестовых данных, каноническая "
"сериализация доступна с помощью функции :func:`canonicalize`."

#: ../../library/xml.etree.elementtree.rst:1087
msgid ""
"In cases where canonical output is not applicable but a specific attribute "
"order is still desirable on output, code should aim for creating the "
"attributes directly in the desired order, to avoid perceptual mismatches for "
"readers of the code. In cases where this is difficult to achieve, a recipe "
"like the following can be applied prior to serialisation to enforce an order "
"independently from the Element creation::"
msgstr ""
"В случаях, когда канонический вывод неприменим, но определенный порядок "
"атрибутов по-прежнему желателен, код должен стремиться создавать атрибуты "
"непосредственно в желаемом порядке, чтобы избежать несоответствий восприятия "
"для читателей кода. В случаях, когда этого трудно достичь, перед "
"сериализацией можно применить рецепт, подобный следующему, чтобы обеспечить "
"соблюдение порядка независимо от создания Элемента:"

#: ../../library/xml.etree.elementtree.rst:1107
msgid "ElementTree Objects"
msgstr "Объекты ElementTree"

#: ../../library/xml.etree.elementtree.rst:1112
msgid ""
"ElementTree wrapper class.  This class represents an entire element "
"hierarchy, and adds some extra support for serialization to and from "
"standard XML."
msgstr ""
"Класс-оболочка ElementTree. Этот класс представляет всю иерархию элементов и "
"добавляет дополнительную поддержку сериализации в стандартный XML и из него."

#: ../../library/xml.etree.elementtree.rst:1116
msgid ""
"*element* is the root element.  The tree is initialized with the contents of "
"the XML *file* if given."
msgstr ""
"*element* — корневой элемент. Дерево инициализируется содержимым *файла* "
"XML, если он указан."

#: ../../library/xml.etree.elementtree.rst:1122
msgid ""
"Replaces the root element for this tree.  This discards the current contents "
"of the tree, and replaces it with the given element.  Use with care.  "
"*element* is an element instance."
msgstr ""
"Заменяет корневой элемент этого дерева. При этом текущее содержимое дерева "
"отбрасывается и заменяется данным элементом. Используйте с осторожностью. "
"*element* — экземпляр элемента."

#: ../../library/xml.etree.elementtree.rst:1129
msgid "Same as :meth:`Element.find`, starting at the root of the tree."
msgstr "То же, что и :meth:`Element.find`, начиная с корня дерева."

#: ../../library/xml.etree.elementtree.rst:1134
msgid "Same as :meth:`Element.findall`, starting at the root of the tree."
msgstr "То же, что и :meth:`Element.findall`, начиная с корня дерева."

#: ../../library/xml.etree.elementtree.rst:1139
msgid "Same as :meth:`Element.findtext`, starting at the root of the tree."
msgstr "То же, что и :meth:`Element.findtext`, начиная с корня дерева."

#: ../../library/xml.etree.elementtree.rst:1144
msgid "Returns the root element for this tree."
msgstr "Возвращает корневой элемент этого дерева."

#: ../../library/xml.etree.elementtree.rst:1149
msgid ""
"Creates and returns a tree iterator for the root element.  The iterator "
"loops over all elements in this tree, in section order.  *tag* is the tag to "
"look for (default is to return all elements)."
msgstr ""
"Создает и возвращает итератор дерева для корневого элемента. Итератор "
"перебирает все элементы в этом дереве в порядке разделов. *tag* — это тег, "
"который нужно искать (по умолчанию возвращаются все элементы)."

#: ../../library/xml.etree.elementtree.rst:1156
msgid "Same as :meth:`Element.iterfind`, starting at the root of the tree."
msgstr "То же, что и :meth:`Element.iterfind`, начиная с корня дерева."

#: ../../library/xml.etree.elementtree.rst:1163
msgid ""
"Loads an external XML section into this element tree.  *source* is a file "
"name or :term:`file object`.  *parser* is an optional parser instance. If "
"not given, the standard :class:`XMLParser` parser is used.  Returns the "
"section root element."
msgstr ""
"Загружает внешний раздел XML в это дерево элементов. *source* — это имя "
"файла или :term:`файловый объект`. *parser* — необязательный экземпляр "
"синтаксического анализатора. Если не указано, используется стандартный "
"парсер :class:`XMLParser`. Возвращает корневой элемент раздела."

#: ../../library/xml.etree.elementtree.rst:1173
msgid ""
"Writes the element tree to a file, as XML.  *file* is a file name, or a :"
"term:`file object` opened for writing.  *encoding* [1]_ is the output "
"encoding (default is US-ASCII). *xml_declaration* controls if an XML "
"declaration should be added to the file.  Use ``False`` for never, ``True`` "
"for always, ``None`` for only if not US-ASCII or UTF-8 or Unicode (default "
"is ``None``). *default_namespace* sets the default XML namespace (for "
"\"xmlns\"). *method* is either ``\"xml\"``, ``\"html\"`` or ``\"text\"`` "
"(default is ``\"xml\"``). The keyword-only *short_empty_elements* parameter "
"controls the formatting of elements that contain no content.  If ``True`` "
"(the default), they are emitted as a single self-closed tag, otherwise they "
"are emitted as a pair of start/end tags."
msgstr ""
"Записывает дерево элементов в файл в формате XML. *file* — имя файла или "
"файловый объект, открытый для записи. *кодировка* [1]_ — выходная кодировка "
"(по умолчанию — US-ASCII). *xml_declaration* определяет, следует ли "
"добавлять в файл XML-объявление. Используйте ``False`` для никогда, ``True`` "
"для всегда, ``None``, только если не используется US-ASCII, UTF-8 или "
"Unicode (по умолчанию — ``None``). *default_namespace* устанавливает "
"пространство имен XML по умолчанию (для «xmlns»). *метод* — это ``\"xml\"``, "
"``\"html\"`` или ``\"text\"`` (по умолчанию ``\"xml\"``). Параметр "
"*short_empty_elements*, содержащий только ключевые слова*, управляет "
"форматированием элементов, не содержащих содержимого. Если «True» (по "
"умолчанию), они создаются как один самозакрывающийся тег, в противном случае "
"они создаются как пара начальных/конечных тегов."

#: ../../library/xml.etree.elementtree.rst:1187
msgid ""
"The output is either a string (:class:`str`) or binary (:class:`bytes`). "
"This is controlled by the *encoding* argument.  If *encoding* is "
"``\"unicode\"``, the output is a string; otherwise, it's binary.  Note that "
"this may conflict with the type of *file* if it's an open :term:`file "
"object`; make sure you do not try to write a string to a binary stream and "
"vice versa."
msgstr ""
"Выходные данные представляют собой либо строку (:class:`str`), либо двоичный "
"файл (:class:`bytes`). Это контролируется аргументом *encoding*. Если "
"*кодировка* равна ``\"unicode\"``, вывод представляет собой строку; в "
"противном случае это двоичный код. Обратите внимание, что это может "
"конфликтовать с типом *файла*, если это открытый :term:`файловый объект`; "
"убедитесь, что вы не пытаетесь записать строку в двоичный поток и наоборот."

#: ../../library/xml.etree.elementtree.rst:1197
msgid ""
"The :meth:`write` method now preserves the attribute order specified by the "
"user."
msgstr ""
"Метод :meth:`write` теперь сохраняет порядок атрибутов, указанный "
"пользователем."

#: ../../library/xml.etree.elementtree.rst:1202
msgid "This is the XML file that is going to be manipulated::"
msgstr "Это XML-файл, которым будут манипулировать:"

#: ../../library/xml.etree.elementtree.rst:1214
msgid ""
"Example of changing the attribute \"target\" of every link in first "
"paragraph::"
msgstr "Пример изменения атрибута «цель» каждой ссылки в первом абзаце:"

#: ../../library/xml.etree.elementtree.rst:1233
msgid "QName Objects"
msgstr "Объекты QName"

#: ../../library/xml.etree.elementtree.rst:1238
msgid ""
"QName wrapper.  This can be used to wrap a QName attribute value, in order "
"to get proper namespace handling on output.  *text_or_uri* is a string "
"containing the QName value, in the form {uri}local, or, if the tag argument "
"is given, the URI part of a QName.  If *tag* is given, the first argument is "
"interpreted as a URI, and this argument is interpreted as a local name. :"
"class:`QName` instances are opaque."
msgstr ""
"Обертка QName. Это можно использовать для переноса значения атрибута QName, "
"чтобы обеспечить правильную обработку пространства имен на выходе. "
"*text_or_uri* — это строка, содержащая значение QName в форме {uri}local "
"или, если указан аргумент тега, часть URI QName. Если указан *tag*, первый "
"аргумент интерпретируется как URI, а этот аргумент интерпретируется как "
"локальное имя. Экземпляры :class:`QName` непрозрачны."

#: ../../library/xml.etree.elementtree.rst:1250
msgid "TreeBuilder Objects"
msgstr "Объекты TreeBuilder"

#: ../../library/xml.etree.elementtree.rst:1256
msgid ""
"Generic element structure builder.  This builder converts a sequence of "
"start, data, end, comment and pi method calls to a well-formed element "
"structure.  You can use this class to build an element structure using a "
"custom XML parser, or a parser for some other XML-like format."
msgstr ""
"Универсальный конструктор структур элементов. Этот конструктор преобразует "
"последовательность вызовов методов start, data, end, comment и pi в "
"правильно сформированную структуру элементов. Вы можете использовать этот "
"класс для построения структуры элементов с помощью специального анализатора "
"XML или анализатора какого-либо другого XML-подобного формата."

#: ../../library/xml.etree.elementtree.rst:1261
msgid ""
"*element_factory*, when given, must be a callable accepting two positional "
"arguments: a tag and a dict of attributes.  It is expected to return a new "
"element instance."
msgstr ""
"*element_factory*, если он задан, должен быть вызываемым объектом, "
"принимающим два позиционных аргумента: тег и набор атрибутов. Ожидается, что "
"он вернет новый экземпляр элемента."

#: ../../library/xml.etree.elementtree.rst:1265
msgid ""
"The *comment_factory* and *pi_factory* functions, when given, should behave "
"like the :func:`Comment` and :func:`ProcessingInstruction` functions to "
"create comments and processing instructions.  When not given, the default "
"factories will be used.  When *insert_comments* and/or *insert_pis* is true, "
"comments/pis will be inserted into the tree if they appear within the root "
"element (but not outside of it)."
msgstr ""
"Функции *comment_factory* и *pi_factory*, если они заданы, должны вести себя "
"как функции :func:`Comment` и :func:`ProcessingInstruction` для создания "
"комментариев и инструкций обработки. Если этот параметр не указан, будут "
"использоваться фабрики по умолчанию. Когда *insert_comments* и/или "
"*insert_pis* имеет значение true, комментарии/pis будут вставлены в дерево, "
"если они появляются внутри корневого элемента (но не за его пределами)."

#: ../../library/xml.etree.elementtree.rst:1274
msgid ""
"Flushes the builder buffers, and returns the toplevel document element.  "
"Returns an :class:`Element` instance."
msgstr ""
"Очищает буферы компоновщика и возвращает элемент документа верхнего уровня. "
"Возвращает экземпляр :class:`Element`."

#: ../../library/xml.etree.elementtree.rst:1280
msgid ""
"Adds text to the current element.  *data* is a string.  This should be "
"either a bytestring, or a Unicode string."
msgstr ""
"Добавляет текст к текущему элементу. *данные* — это строка. Это должна быть "
"либо байтовая строка, либо строка Юникода."

#: ../../library/xml.etree.elementtree.rst:1286
msgid ""
"Closes the current element.  *tag* is the element name.  Returns the closed "
"element."
msgstr ""
"Закрывает текущий элемент. *tag* — имя элемента. Возвращает закрытый элемент."

#: ../../library/xml.etree.elementtree.rst:1292
msgid ""
"Opens a new element.  *tag* is the element name.  *attrs* is a dictionary "
"containing element attributes.  Returns the opened element."
msgstr ""
"Открывает новый элемент. *tag* — имя элемента. *attrs* — словарь, содержащий "
"атрибуты элементов. Возвращает открытый элемент."

#: ../../library/xml.etree.elementtree.rst:1298
msgid ""
"Creates a comment with the given *text*.  If ``insert_comments`` is true, "
"this will also add it to the tree."
msgstr ""
"Создает комментарий с заданным *текстом*. Если ``insert_comments`` имеет "
"значение true, это также добавит его в дерево."

#: ../../library/xml.etree.elementtree.rst:1306
msgid ""
"Creates a process instruction with the given *target* name and *text*. If "
"``insert_pis`` is true, this will also add it to the tree."
msgstr ""
"Создает инструкцию процесса с заданным *целевым* именем и *текстом*. Если "
"``insert_pis`` имеет значение true, это также добавит его в дерево."

#: ../../library/xml.etree.elementtree.rst:1312
msgid ""
"In addition, a custom :class:`TreeBuilder` object can provide the following "
"methods:"
msgstr ""
"Кроме того, пользовательский объект :class:`TreeBuilder` может предоставлять "
"следующие методы:"

#: ../../library/xml.etree.elementtree.rst:1317
msgid ""
"Handles a doctype declaration.  *name* is the doctype name.  *pubid* is the "
"public identifier.  *system* is the system identifier.  This method does not "
"exist on the default :class:`TreeBuilder` class."
msgstr ""
"Обрабатывает объявление типа документа. *name* — имя типа документа. *pubid* "
"— общедоступный идентификатор. *system* — идентификатор системы. Этот метод "
"не существует в классе по умолчанию :class:`TreeBuilder`."

#: ../../library/xml.etree.elementtree.rst:1325
msgid ""
"Is called whenever the parser encounters a new namespace declaration, before "
"the ``start()`` callback for the opening element that defines it. *prefix* "
"is ``''`` for the default namespace and the declared namespace prefix name "
"otherwise.  *uri* is the namespace URI."
msgstr ""
"Вызывается всякий раз, когда анализатор встречает новое объявление "
"пространства имен, перед обратным вызовом start() для открывающего элемента, "
"который его определяет. *prefix* — это ``''`` для пространства имен по "
"умолчанию и объявленное имя префикса пространства имен в противном случае. "
"*uri* — это URI пространства имен."

#: ../../library/xml.etree.elementtree.rst:1334
msgid ""
"Is called after the ``end()`` callback of an element that declared a "
"namespace prefix mapping, with the name of the *prefix* that went out of "
"scope."
msgstr ""
"Вызывается после обратного вызова ``end()`` элемента, который объявил "
"сопоставление префикса пространства имен, с именем *префикса*, выходящим за "
"пределы области видимости."

#: ../../library/xml.etree.elementtree.rst:1346
msgid ""
"A `C14N 2.0 <https://www.w3.org/TR/xml-c14n2/>`_ writer.  Arguments are the "
"same as for the :func:`canonicalize` function.  This class does not build a "
"tree but translates the callback events directly into a serialised form "
"using the *write* function."
msgstr ""
"Автор `C14N 2.0 <https://www.w3.org/TR/xml-c14n2/>`_. Аргументы те же, что и "
"для функции :func:`canonicalize`. Этот класс не строит дерево, а переводит "
"события обратного вызова непосредственно в сериализованную форму с помощью "
"функции *write*."

#: ../../library/xml.etree.elementtree.rst:1357
msgid "XMLParser Objects"
msgstr "Объекты XMLParser"

#: ../../library/xml.etree.elementtree.rst:1362
msgid ""
"This class is the low-level building block of the module.  It uses :mod:`xml."
"parsers.expat` for efficient, event-based parsing of XML.  It can be fed XML "
"data incrementally with the :meth:`feed` method, and parsing events are "
"translated to a push API - by invoking callbacks on the *target* object.  If "
"*target* is omitted, the standard :class:`TreeBuilder` is used. If "
"*encoding* [1]_ is given, the value overrides the encoding specified in the "
"XML file."
msgstr ""
"Этот класс является низкоуровневым строительным блоком модуля. Он "
"использует :mod:`xml.parsers.expat` для эффективного анализа XML на основе "
"событий. XML-данные могут передаваться постепенно с помощью метода :meth:"
"`feed`, а события синтаксического анализа преобразуются в push-API, вызывая "
"обратные вызовы для *целевого* объекта. Если *target* опущен, используется "
"стандартный :class:`TreeBuilder`. Если *кодировка* [1]_ задано, значение "
"переопределяет кодировку, указанную в файле XML."

#: ../../library/xml.etree.elementtree.rst:1370
msgid ""
"Parameters are now :ref:`keyword-only <keyword-only_parameter>`. The *html* "
"argument no longer supported."
msgstr ""

#: ../../library/xml.etree.elementtree.rst:1377
msgid ""
"Finishes feeding data to the parser.  Returns the result of calling the "
"``close()`` method of the *target* passed during construction; by default, "
"this is the toplevel document element."
msgstr ""
"Завершает подачу данных в анализатор. Возвращает результат вызова метода "
"close() объекта *target*, переданного во время построения; по умолчанию это "
"элемент документа верхнего уровня."

#: ../../library/xml.etree.elementtree.rst:1384
msgid "Feeds data to the parser.  *data* is encoded data."
msgstr "Передает данные в парсер. *данные* — это закодированные данные."

#: ../../library/xml.etree.elementtree.rst:1389
#: ../../library/xml.etree.elementtree.rst:1467
msgid ""
"Triggers parsing of any previously fed unparsed data, which can be used to "
"ensure more immediate feedback, in particular with Expat >=2.6.0. The "
"implementation of :meth:`flush` temporarily disables reparse deferral with "
"Expat (if currently enabled) and triggers a reparse. Disabling reparse "
"deferral has security consequences; please see :meth:`xml.parsers.expat."
"xmlparser.SetReparseDeferralEnabled` for details."
msgstr ""
"Запускает анализ любых ранее переданных неразобранных данных, которые можно "
"использовать для обеспечения более немедленной обратной связи, в частности, "
"с Expat >=2.6.0. Реализация :meth:`flush` временно отключает отсрочку "
"повторной обработки с помощью Expat (если она включена в данный момент) и "
"запускает повторную обработку. Отключение отсрочки повторной обработки имеет "
"последствия для безопасности; подробности см. в :meth:`xml.parsers.expat."
"xmlparser.SetReparseDeferralEnabled`."

#: ../../library/xml.etree.elementtree.rst:1396
#: ../../library/xml.etree.elementtree.rst:1474
msgid ""
"Note that :meth:`flush` has been backported to some prior releases of "
"CPython as a security fix.  Check for availability of :meth:`flush` using :"
"func:`hasattr` if used in code running across a variety of Python versions."
msgstr ""
"Обратите внимание, что :meth:`flush` был перенесен в некоторые предыдущие "
"выпуски CPython в качестве исправления безопасности. Проверьте доступность :"
"meth:`flush` с помощью :func:`hasattr`, если он используется в коде, "
"работающем в различных версиях Python."

#: ../../library/xml.etree.elementtree.rst:1404
msgid ""
":meth:`XMLParser.feed` calls *target*\\'s ``start(tag, attrs_dict)`` method "
"for each opening tag, its ``end(tag)`` method for each closing tag, and data "
"is processed by method ``data(data)``.  For further supported callback "
"methods, see the :class:`TreeBuilder` class.  :meth:`XMLParser.close` calls "
"*target*\\'s method ``close()``. :class:`XMLParser` can be used not only for "
"building a tree structure. This is an example of counting the maximum depth "
"of an XML file::"
msgstr ""
":meth:`XMLParser.feed` вызывает метод ``start(tag, attrs_dict)`` *target* "
"для каждого открывающего тега, его метод ``end(tag)`` для каждого "
"закрывающего тега, и данные обрабатываются методом ``данные(данные)``. "
"Дополнительные поддерживаемые методы обратного вызова см. в классе :class:"
"`TreeBuilder`. :meth:`XMLParser.close` вызывает метод "
"*target*\\``close()``. :class:`XMLParser` можно использовать не только для "
"построения древовидной структуры. Это пример подсчета максимальной глубины "
"XML-файла:"

#: ../../library/xml.etree.elementtree.rst:1448
msgid "XMLPullParser Objects"
msgstr "Объекты XMLPullParser"

#: ../../library/xml.etree.elementtree.rst:1452
msgid ""
"A pull parser suitable for non-blocking applications.  Its input-side API is "
"similar to that of :class:`XMLParser`, but instead of pushing calls to a "
"callback target, :class:`XMLPullParser` collects an internal list of parsing "
"events and lets the user read from it. *events* is a sequence of events to "
"report back.  The supported events are the strings ``\"start\"``, "
"``\"end\"``, ``\"comment\"``, ``\"pi\"``, ``\"start-ns\"`` and ``\"end-"
"ns\"`` (the \"ns\" events are used to get detailed namespace information).  "
"If *events* is omitted, only ``\"end\"`` events are reported."
msgstr ""
"Анализатор pull, подходящий для неблокирующих приложений. Его API на стороне "
"ввода аналогичен API :class:`XMLParser`, но вместо отправки вызовов к цели "
"обратного вызова :class:`XMLPullParser` собирает внутренний список событий "
"синтаксического анализа и позволяет пользователю читать его. *events* — это "
"последовательность событий, о которых необходимо сообщить. Поддерживаемые "
"события — это строки ``\"start\", ``\"end\"``, ``\"comment\"``, ``\"pi\"``, "
"``\"start-ns\"`` и `` \"end-ns\"`` (события \"ns\" используются для "
"получения подробной информации о пространстве имен). Если *events* опущено, "
"сообщается только о ``конечных'` событиях."

#: ../../library/xml.etree.elementtree.rst:1463
msgid "Feed the given bytes data to the parser."
msgstr "Передайте данные в байтах синтаксическому анализатору."

#: ../../library/xml.etree.elementtree.rst:1483
msgid ""
"Signal the parser that the data stream is terminated. Unlike :meth:"
"`XMLParser.close`, this method always returns :const:`None`. Any events not "
"yet retrieved when the parser is closed can still be read with :meth:"
"`read_events`."
msgstr ""
"Сообщите синтаксическому анализатору, что поток данных прекращен. В отличие "
"от :meth:`XMLParser.close`, этот метод всегда возвращает :const:`None`. "
"Любые события, которые еще не получены при закрытии парсера, все равно можно "
"прочитать с помощью :meth:`read_events`."

#: ../../library/xml.etree.elementtree.rst:1490
msgid ""
"Return an iterator over the events which have been encountered in the data "
"fed to the parser.  The iterator yields ``(event, elem)`` pairs, where "
"*event* is a string representing the type of event (e.g. ``\"end\"``) and "
"*elem* is the encountered :class:`Element` object, or other context value as "
"follows."
msgstr ""
"Возвращает итератор для событий, которые были обнаружены в данных, "
"переданных в анализатор. Итератор выдает пары ``(event, elem)``, где "
"*event* — это строка, представляющая тип события (например, ``\"end\"``), а "
"*elem* — обнаруженный объект :class:`Element`. или другое значение контекста "
"следующим образом."

#: ../../library/xml.etree.elementtree.rst:1496
msgid "``start``, ``end``: the current Element."
msgstr "``start``, ``end``: текущий элемент."

#: ../../library/xml.etree.elementtree.rst:1497
msgid "``comment``, ``pi``: the current comment / processing instruction"
msgstr "``комментарий``, ``pi``: текущий комментарий/инструкция обработки."

#: ../../library/xml.etree.elementtree.rst:1498
msgid ""
"``start-ns``: a tuple ``(prefix, uri)`` naming the declared namespace "
"mapping."
msgstr ""
"``start-ns``: кортеж ``(prefix, uri)``, называющий объявленное отображение "
"пространства имен."

#: ../../library/xml.etree.elementtree.rst:1500
msgid "``end-ns``: :const:`None` (this may change in a future version)"
msgstr "``end-ns``: :const:`None` (это может измениться в будущей версии)"

#: ../../library/xml.etree.elementtree.rst:1502
msgid ""
"Events provided in a previous call to :meth:`read_events` will not be "
"yielded again.  Events are consumed from the internal queue only when they "
"are retrieved from the iterator, so multiple readers iterating in parallel "
"over iterators obtained from :meth:`read_events` will have unpredictable "
"results."
msgstr ""
"События, предоставленные при предыдущем вызове :meth:`read_events`, больше "
"не будут выдаваться. События потребляются из внутренней очереди только "
"тогда, когда они извлекаются из итератора, поэтому несколько читателей, "
"параллельно перебирающих итераторы, полученные из :meth:`read_events`, будут "
"иметь непредсказуемые результаты."

#: ../../library/xml.etree.elementtree.rst:1510
msgid ""
":class:`XMLPullParser` only guarantees that it has seen the \">\" character "
"of a starting tag when it emits a \"start\" event, so the attributes are "
"defined, but the contents of the text and tail attributes are undefined at "
"that point.  The same applies to the element children; they may or may not "
"be present."
msgstr ""
":class:`XMLPullParser` гарантирует, что он увидел символ \">\" начального "
"тега только тогда, когда генерирует событие \"start\", поэтому атрибуты "
"определены, но содержимое атрибутов text и Tail в этот момент не "
"определено. . То же самое относится и к дочерним элементам; они могут "
"присутствовать, а могут и не присутствовать."

#: ../../library/xml.etree.elementtree.rst:1525
msgid "Exceptions"
msgstr "Исключения"

#: ../../library/xml.etree.elementtree.rst:1529
msgid ""
"XML parse error, raised by the various parsing methods in this module when "
"parsing fails.  The string representation of an instance of this exception "
"will contain a user-friendly error message.  In addition, it will have the "
"following attributes available:"
msgstr ""
"Ошибка синтаксического анализа XML, вызываемая различными методами "
"синтаксического анализа в этом модуле при сбое синтаксического анализа. "
"Строковое представление экземпляра этого исключения будет содержать понятное "
"пользователю сообщение об ошибке. Кроме того, ему будут доступны следующие "
"атрибуты:"

#: ../../library/xml.etree.elementtree.rst:1536
msgid ""
"A numeric error code from the expat parser. See the documentation of :mod:"
"`xml.parsers.expat` for the list of error codes and their meanings."
msgstr ""
"Числовой код ошибки из парсера экспатов. См. документацию :mod:`xml.parsers."
"expat` для получения списка кодов ошибок и их значений."

#: ../../library/xml.etree.elementtree.rst:1541
msgid ""
"A tuple of *line*, *column* numbers, specifying where the error occurred."
msgstr ""
"Кортеж номеров *строки* и *столбца*, указывающий, где произошла ошибка."

#: ../../library/xml.etree.elementtree.rst:1544
msgid "Footnotes"
msgstr "Сноски"

#: ../../library/xml.etree.elementtree.rst:1545
msgid ""
"The encoding string included in XML output should conform to the appropriate "
"standards.  For example, \"UTF-8\" is valid, but \"UTF8\" is not.  See "
"https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl and https://"
"www.iana.org/assignments/character-sets/character-sets.xhtml."
msgstr ""
"Строка кодирования, включенная в выходные данные XML, должна соответствовать "
"соответствующим стандартам. Например, «UTF-8» допустим, а «UTF8» — нет. См. "
"https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl и https://www."
"iana.org/assignments/character-sets/character-sets.xhtml."
