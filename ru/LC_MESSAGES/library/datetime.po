# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Roustam Khamidoulline, 2024
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-25 14:54+0000\n"
"PO-Revision-Date: 2024-05-11 00:33+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/datetime.rst:2
msgid ":mod:`!datetime` --- Basic date and time types"
msgstr ":mod:`!datetime` --- Основные типы даты и времени"

#: ../../library/datetime.rst:11
msgid "**Source code:** :source:`Lib/datetime.py`"
msgstr "**Исходный код:** :source:`Lib/datetime.py`"

#: ../../library/datetime.rst:17
msgid ""
"The :mod:`!datetime` module supplies classes for manipulating dates and "
"times."
msgstr ""
"Модуль :mod:`!datetime` предоставляет классы для управления датами и "
"временем."

#: ../../library/datetime.rst:19
msgid ""
"While date and time arithmetic is supported, the focus of the implementation "
"is on efficient attribute extraction for output formatting and manipulation."
msgstr ""
"Хотя арифметика даты и времени поддерживается, основное внимание в "
"реализации уделяется эффективному извлечению атрибутов для форматирования и "
"манипулирования выходными данными."

#: ../../library/datetime.rst:24
msgid "Skip to :ref:`the format codes <format-codes>`."
msgstr "Перейдите к :ref:`кодам формата <format-codes>`."

#: ../../library/datetime.rst:28
msgid "Module :mod:`calendar`"
msgstr "Модуль :mod:`calendar`"

#: ../../library/datetime.rst:29
msgid "General calendar related functions."
msgstr "Общие функции, связанные с календарем."

#: ../../library/datetime.rst:31
msgid "Module :mod:`time`"
msgstr "Модуль :mod:`time`"

#: ../../library/datetime.rst:32
msgid "Time access and conversions."
msgstr "Доступ ко времени и преобразования."

#: ../../library/datetime.rst:34
msgid "Module :mod:`zoneinfo`"
msgstr "Модуль :mod:`zoneinfo`"

#: ../../library/datetime.rst:35
msgid "Concrete time zones representing the IANA time zone database."
msgstr ""
"Конкретные часовые пояса, представляющие базу данных часовых поясов IANA."

#: ../../library/datetime.rst:37
msgid "Package `dateutil <https://dateutil.readthedocs.io/en/stable/>`_"
msgstr "Пакет `dateutil <https://dateutil.readthedocs.io/en/stable/>`_"

#: ../../library/datetime.rst:38
msgid "Third-party library with expanded time zone and parsing support."
msgstr ""
"Сторонняя библиотека с расширенным часовым поясом и поддержкой парсинга."

#: ../../library/datetime.rst:40
msgid "Package :pypi:`DateType`"
msgstr "Пакет :pypi:`DateType`"

#: ../../library/datetime.rst:41
msgid ""
"Third-party library that introduces distinct static types to e.g. allow :"
"term:`static type checkers <static type checker>` to differentiate between "
"naive and aware datetimes."
msgstr ""
"Сторонняя библиотека, которая вводит отдельные статические типы, например, "
"позволяет :term:`проверкам статического типа <статическая проверка типа>` "
"различать наивные и осведомленные даты и времени."

#: ../../library/datetime.rst:48
msgid "Aware and Naive Objects"
msgstr "Осознанные и наивные объекты"

#: ../../library/datetime.rst:50
msgid ""
"Date and time objects may be categorized as \"aware\" or \"naive\" depending "
"on whether or not they include time zone information."
msgstr ""
"Объекты даты и времени могут быть отнесены к категории «осведомленных» или "
"«наивных» в зависимости от того, включают ли они информацию о часовом поясе."

#: ../../library/datetime.rst:53
msgid ""
"With sufficient knowledge of applicable algorithmic and political time "
"adjustments, such as time zone and daylight saving time information, an "
"**aware** object can locate itself relative to other aware objects. An aware "
"object represents a specific moment in time that is not open to "
"interpretation. [#]_"
msgstr ""
"При наличии достаточных знаний о применимых алгоритмических и политических "
"корректировках времени, таких как информация о часовом поясе и летнем "
"времени, **осведомленный** объект может определять свое местоположение "
"относительно других осведомленных объектов. Осознанный объект представляет "
"собой конкретный момент времени, который не подлежит интерпретации. [#]_"

#: ../../library/datetime.rst:59
msgid ""
"A **naive** object does not contain enough information to unambiguously "
"locate itself relative to other date/time objects. Whether a naive object "
"represents Coordinated Universal Time (UTC), local time, or time in some "
"other time zone is purely up to the program, just like it is up to the "
"program whether a particular number represents metres, miles, or mass. Naive "
"objects are easy to understand and to work with, at the cost of ignoring "
"some aspects of reality."
msgstr ""
"**Наивный** объект не содержит достаточно информации, чтобы однозначно "
"определить свое местоположение относительно других объектов даты и времени. "
"Представляет ли наивный объект всемирное координированное время (UTC), "
"местное время или время в каком-то другом часовом поясе, зависит "
"исключительно от программы, точно так же, как от программы зависит, "
"представляет ли конкретное число метры, мили или массу. Наивные объекты "
"легко понять и с ними легко работать, ценой игнорирования некоторых аспектов "
"реальности."

#: ../../library/datetime.rst:66
msgid ""
"For applications requiring aware objects, :class:`.datetime` and :class:`."
"time` objects have an optional time zone information attribute, :attr:`!"
"tzinfo`, that can be set to an instance of a subclass of the abstract :class:"
"`tzinfo` class. These :class:`tzinfo` objects capture information about the "
"offset from UTC time, the time zone name, and whether daylight saving time "
"is in effect."
msgstr ""
"Для приложений, требующих наличия объектов, объекты :class:`.datetime` и :"
"class:`.time` имеют дополнительный атрибут информации о часовом поясе, :attr:"
"`!tzinfo`, который может быть установлен для экземпляра подкласса "
"абстрактный :class:`tzinfo` класс. Эти объекты :class:`tzinfo` собирают "
"информацию об отклонении от времени UTC, имени часового пояса и о том, "
"действует ли летнее время."

#: ../../library/datetime.rst:72
msgid ""
"Only one concrete :class:`tzinfo` class, the :class:`timezone` class, is "
"supplied by the :mod:`!datetime` module. The :class:`!timezone` class can "
"represent simple time zones with fixed offsets from UTC, such as UTC itself "
"or North American EST and EDT time zones. Supporting time zones at deeper "
"levels of detail is up to the application. The rules for time adjustment "
"across the world are more political than rational, change frequently, and "
"there is no standard suitable for every application aside from UTC."
msgstr ""
"Только один конкретный класс :class:`tzinfo`, класс :class:`timezone`, "
"предоставляется модулем :mod:`!datetime`. Класс :class:`!timezone` может "
"представлять простые часовые пояса с фиксированными смещениями от UTC, "
"например, само UTC или часовые пояса Северной Америки EST и EDT. Поддержка "
"часовых поясов на более глубоких уровнях детализации зависит от приложения. "
"Правила корректировки времени во всем мире носят скорее политический, чем "
"рациональный характер, часто меняются, и не существует стандарта, "
"подходящего для каждого применения, кроме UTC."

#: ../../library/datetime.rst:81
msgid "Constants"
msgstr "Константы"

#: ../../library/datetime.rst:83
msgid "The :mod:`!datetime` module exports the following constants:"
msgstr "Модуль :mod:`!datetime` экспортирует следующие константы:"

#: ../../library/datetime.rst:87
msgid ""
"The smallest year number allowed in a :class:`date` or :class:`.datetime` "
"object. :const:`MINYEAR` is 1."
msgstr ""
"Наименьшее число года, разрешенное в объекте :class:`date` или :class:`."
"datetime`. :const:`MINYEAR` равен 1."

#: ../../library/datetime.rst:93
msgid ""
"The largest year number allowed in a :class:`date` or :class:`.datetime` "
"object. :const:`MAXYEAR` is 9999."
msgstr ""
"Максимальный номер года, разрешенный в объекте :class:`date` или :class:`."
"datetime`. :const:`MAXYEAR` — 9999."

#: ../../library/datetime.rst:98
msgid "Alias for the UTC time zone singleton :attr:`datetime.timezone.utc`."
msgstr ""
"Псевдоним для одиночного часового пояса UTC :attr:`datetime.timezone.utc`."

#: ../../library/datetime.rst:103
msgid "Available Types"
msgstr "Доступные типы"

#: ../../library/datetime.rst:108
msgid ""
"An idealized naive date, assuming the current Gregorian calendar always was, "
"and always will be, in effect. Attributes: :attr:`year`, :attr:`month`, and :"
"attr:`day`."
msgstr ""
"Идеализированная наивная дата, предполагающая, что текущий григорианский "
"календарь всегда действовал и всегда будет действовать. Атрибуты: :attr:"
"`year`, :attr:`month` и :attr:`day`."

#: ../../library/datetime.rst:116
msgid ""
"An idealized time, independent of any particular day, assuming that every "
"day has exactly 24\\*60\\*60 seconds.  (There is no notion of \"leap "
"seconds\" here.) Attributes: :attr:`hour`, :attr:`minute`, :attr:`second`, :"
"attr:`microsecond`, and :attr:`.tzinfo`."
msgstr ""
"Идеализированное время, независимое от какого-либо конкретного дня, при "
"условии, что в каждом дне ровно 24\\*60\\*60 секунд. (Здесь нет понятия "
"«високосные секунды».) Атрибуты: :attr:`hour`, :attr:`минута`, :attr:"
"`секунда`, :attr:`микросекунда` и :attr:`.tzinfo `."

#: ../../library/datetime.rst:125
msgid ""
"A combination of a date and a time. Attributes: :attr:`year`, :attr:"
"`month`, :attr:`day`, :attr:`hour`, :attr:`minute`, :attr:`second`, :attr:"
"`microsecond`, and :attr:`.tzinfo`."
msgstr ""
"Сочетание даты и времени. Атрибуты: :attr:`год`, :attr:`месяц`, :attr:"
"`день`, :attr:`час`, :attr:`минута`, :attr:`секунда`, :attr:`микросекунда` "
"и :attr:`.tzinfo`."

#: ../../library/datetime.rst:133
msgid ""
"A duration expressing the difference between two :class:`.datetime` or :"
"class:`date` instances to microsecond resolution."
msgstr ""
"Длительность, выражающая разницу между двумя экземплярами :class:`.datetime` "
"или :class:`date` с разрешением в микросекундах."

#: ../../library/datetime.rst:140
msgid ""
"An abstract base class for time zone information objects. These are used by "
"the :class:`.datetime` and :class:`.time` classes to provide a customizable "
"notion of time adjustment (for example, to account for time zone and/or "
"daylight saving time)."
msgstr ""
"Абстрактный базовый класс для объектов информации о часовом поясе. Они "
"используются классами :class:`.datetime` и :class:`.time` для предоставления "
"настраиваемого понятия корректировки времени (например, для учета часового "
"пояса и/или летнего времени)."

#: ../../library/datetime.rst:148
msgid ""
"A class that implements the :class:`tzinfo` abstract base class as a fixed "
"offset from the UTC."
msgstr ""
"Класс, реализующий абстрактный базовый класс :class:`tzinfo` как "
"фиксированное смещение от UTC."

#: ../../library/datetime.rst:153 ../../library/datetime.rst:171
msgid "Objects of these types are immutable."
msgstr "Объекты этих типов неизменяемы."

#: ../../library/datetime.rst:155
msgid "Subclass relationships::"
msgstr "Отношения между подклассами::"

#: ../../library/datetime.rst:157
msgid ""
"object\n"
"    timedelta\n"
"    tzinfo\n"
"        timezone\n"
"    time\n"
"    date\n"
"        datetime"
msgstr ""
"object\n"
"    timedelta\n"
"    tzinfo\n"
"        timezone\n"
"    time\n"
"    date\n"
"        datetime"

#: ../../library/datetime.rst:166
msgid "Common Properties"
msgstr "Общие свойства"

#: ../../library/datetime.rst:168
msgid ""
"The :class:`date`, :class:`.datetime`, :class:`.time`, and :class:`timezone` "
"types share these common features:"
msgstr ""
"Типы :class:`date`, :class:`.datetime`, :class:`.time` и :class:`timezone` "
"имеют следующие общие особенности:"

#: ../../library/datetime.rst:172
msgid ""
"Objects of these types are :term:`hashable`, meaning that they can be used "
"as dictionary keys."
msgstr ""
"Объекты этих типов являются :term:`hashable`, что означает, что их можно "
"использовать в качестве ключей словаря."

#: ../../library/datetime.rst:174
msgid ""
"Objects of these types support efficient pickling via the :mod:`pickle` "
"module."
msgstr ""
"Объекты этих типов поддерживают эффективное травление с помощью модуля :mod:"
"`pickle`."

#: ../../library/datetime.rst:177
msgid "Determining if an Object is Aware or Naive"
msgstr "Определение того, является ли объект осознанным или наивным"

#: ../../library/datetime.rst:179
msgid "Objects of the :class:`date` type are always naive."
msgstr "Объекты типа :class:`date` всегда наивны."

#: ../../library/datetime.rst:181
msgid ""
"An object of type :class:`.time` or :class:`.datetime` may be aware or naive."
msgstr ""
"Объект типа :class:`.time` или :class:`.datetime` может быть осознанным или "
"неактивным."

#: ../../library/datetime.rst:183
msgid ""
"A :class:`.datetime` object ``d`` is aware if both of the following hold:"
msgstr ""
"Объект :class:`.datetime` ``d`` распознает, если выполняются оба следующих "
"условия:"

#: ../../library/datetime.rst:185
msgid "``d.tzinfo`` is not ``None``"
msgstr "``d.tzinfo`` is not ``None``"

#: ../../library/datetime.rst:186
msgid "``d.tzinfo.utcoffset(d)`` does not return ``None``"
msgstr "``d.tzinfo.utcoffset(d)`` не возвращает ``None``"

#: ../../library/datetime.rst:188
msgid "Otherwise, ``d`` is naive."
msgstr "В противном случае ``d`` будет наивным."

#: ../../library/datetime.rst:190
msgid "A :class:`.time` object ``t`` is aware if both of the following hold:"
msgstr ""
"Объект :class:`.time` ``t`` распознает, если выполняются оба следующих "
"условия:"

#: ../../library/datetime.rst:192
msgid "``t.tzinfo`` is not ``None``"
msgstr "``t.tzinfo`` не ``None``"

#: ../../library/datetime.rst:193
msgid "``t.tzinfo.utcoffset(None)`` does not return ``None``."
msgstr "``t.tzinfo.utcoffset(None)`` не возвращает ``None`` ."

#: ../../library/datetime.rst:195
msgid "Otherwise, ``t`` is naive."
msgstr "В противном случае ``t`` будет наивным."

#: ../../library/datetime.rst:197
msgid ""
"The distinction between aware and naive doesn't apply to :class:`timedelta` "
"objects."
msgstr ""
"Различие между осведомленным и наивным не применимо к объектам :class:"
"`timedelta`."

#: ../../library/datetime.rst:203
msgid ":class:`timedelta` Objects"
msgstr "Объекты :class:`timedelta`"

#: ../../library/datetime.rst:205
msgid ""
"A :class:`timedelta` object represents a duration, the difference between "
"two :class:`.datetime` or :class:`date` instances."
msgstr ""
"Объект :class:`timedelta` представляет продолжительность, разницу между "
"двумя экземплярами :class:`.datetime` или :class:`date`."

#: ../../library/datetime.rst:210
msgid ""
"All arguments are optional and default to 0. Arguments may be integers or "
"floats, and may be positive or negative."
msgstr ""
"Все аргументы являются необязательными и по умолчанию имеют значение 0. "
"Аргументы могут быть целыми числами или числами с плавающей запятой, а также "
"могут быть положительными или отрицательными."

#: ../../library/datetime.rst:213
msgid ""
"Only *days*, *seconds* and *microseconds* are stored internally. Arguments "
"are converted to those units:"
msgstr ""
"Внутри хранятся только *дни*, *секунды* и *микросекунды*. Аргументы "
"преобразуются в следующие единицы:"

#: ../../library/datetime.rst:216
msgid "A millisecond is converted to 1000 microseconds."
msgstr "Миллисекунда преобразуется в 1000 микросекунд."

#: ../../library/datetime.rst:217
msgid "A minute is converted to 60 seconds."
msgstr "Минута конвертируется в 60 секунд."

#: ../../library/datetime.rst:218
msgid "An hour is converted to 3600 seconds."
msgstr "Час преобразуется в 3600 секунд."

#: ../../library/datetime.rst:219
msgid "A week is converted to 7 days."
msgstr "Неделя преобразуется в 7 дней."

#: ../../library/datetime.rst:221
msgid ""
"and days, seconds and microseconds are then normalized so that the "
"representation is unique, with"
msgstr ""
"а затем дни, секунды и микросекунды нормализуются так, чтобы представление "
"было уникальным, с"

#: ../../library/datetime.rst:224
msgid "``0 <= microseconds < 1000000``"
msgstr "``0 <= microseconds < 1000000``"

#: ../../library/datetime.rst:225
msgid "``0 <= seconds < 3600*24`` (the number of seconds in one day)"
msgstr "``0 <= секунд < 3600*24`` (количество секунд в одном дне)"

#: ../../library/datetime.rst:226
msgid "``-999999999 <= days <= 999999999``"
msgstr "``-999999999 <= days <= 999999999``"

#: ../../library/datetime.rst:228
msgid ""
"The following example illustrates how any arguments besides *days*, "
"*seconds* and *microseconds* are \"merged\" and normalized into those three "
"resulting attributes::"
msgstr ""
"Следующий пример иллюстрирует, как любые аргументы, кроме *дней*, *секунд* и "
"*микросекунд*, «объединяются» и нормализуются в эти три результирующих "
"атрибута:"

#: ../../library/datetime.rst:232
msgid ""
">>> from datetime import timedelta\n"
">>> delta = timedelta(\n"
"...     days=50,\n"
"...     seconds=27,\n"
"...     microseconds=10,\n"
"...     milliseconds=29000,\n"
"...     minutes=5,\n"
"...     hours=8,\n"
"...     weeks=2\n"
"... )\n"
">>> # Only days, seconds, and microseconds remain\n"
">>> delta\n"
"datetime.timedelta(days=64, seconds=29156, microseconds=10)"
msgstr ""
">>> from datetime import timedelta\n"
">>> delta = timedelta(\n"
"...     days=50,\n"
"...     seconds=27,\n"
"...     microseconds=10,\n"
"...     milliseconds=29000,\n"
"...     minutes=5,\n"
"...     hours=8,\n"
"...     weeks=2\n"
"... )\n"
">>> # Only days, seconds, and microseconds remain\n"
">>> delta\n"
"datetime.timedelta(days=64, seconds=29156, microseconds=10)"

#: ../../library/datetime.rst:246
msgid ""
"If any argument is a float and there are fractional microseconds, the "
"fractional microseconds left over from all arguments are combined and their "
"sum is rounded to the nearest microsecond using round-half-to-even "
"tiebreaker. If no argument is a float, the conversion and normalization "
"processes are exact (no information is lost)."
msgstr ""
"Если какой-либо аргумент является числом с плавающей запятой и есть дробные "
"микросекунды, дробные микросекунды, оставшиеся от всех аргументов, "
"объединяются, и их сумма округляется до ближайшей микросекунды с "
"использованием тай-брейкера от половины до четного. Если ни один аргумент не "
"является числом с плавающей запятой, процессы преобразования и нормализации "
"являются точными (информация не теряется)."

#: ../../library/datetime.rst:253
msgid ""
"If the normalized value of days lies outside the indicated range, :exc:"
"`OverflowError` is raised."
msgstr ""
"Если нормализованное значение дней находится за пределами указанного "
"диапазона, возникает ошибка :exc:`OverflowError`."

#: ../../library/datetime.rst:256
msgid ""
"Note that normalization of negative values may be surprising at first. For "
"example::"
msgstr ""
"Обратите внимание, что нормализация отрицательных значений поначалу может "
"показаться неожиданной. Например::"

#: ../../library/datetime.rst:259
msgid ""
">>> from datetime import timedelta\n"
">>> d = timedelta(microseconds=-1)\n"
">>> (d.days, d.seconds, d.microseconds)\n"
"(-1, 86399, 999999)"
msgstr ""
">>> from datetime import timedelta\n"
">>> d = timedelta(microseconds=-1)\n"
">>> (d.days, d.seconds, d.microseconds)\n"
"(-1, 86399, 999999)"

#: ../../library/datetime.rst:265 ../../library/datetime.rst:566
#: ../../library/datetime.rst:1089 ../../library/datetime.rst:1720
#: ../../library/datetime.rst:2322
msgid "Class attributes:"
msgstr "Атрибуты класса:"

#: ../../library/datetime.rst:269
msgid "The most negative :class:`timedelta` object, ``timedelta(-999999999)``."
msgstr "Самый негативный объект :class:`timedelta`, ``timedelta(-999999999)``."

#: ../../library/datetime.rst:274
msgid ""
"The most positive :class:`timedelta` object, ``timedelta(days=999999999, "
"hours=23, minutes=59, seconds=59, microseconds=999999)``."
msgstr ""
"Самый позитивный объект :class:`timedelta`, ``timedelta(days=999999999, "
"часы=23, минуты=59, секунды=59, микросекунды=999999)``."

#: ../../library/datetime.rst:280
msgid ""
"The smallest possible difference between non-equal :class:`timedelta` "
"objects, ``timedelta(microseconds=1)``."
msgstr ""
"Наименьшая возможная разница между неравными объектами :class:`timedelta`, "
"``timedelta(microсекунды=1)``."

#: ../../library/datetime.rst:283
msgid ""
"Note that, because of normalization, ``timedelta.max`` is greater than ``-"
"timedelta.min``. ``-timedelta.max`` is not representable as a :class:"
"`timedelta` object."
msgstr ""
"Обратите внимание, что из-за нормализации timedelta.max больше, чем -"
"timedelta.min. ``-timedelta.max`` не может быть представлен как объект :"
"class:`timedelta`."

#: ../../library/datetime.rst:287 ../../library/datetime.rst:584
#: ../../library/datetime.rst:1109 ../../library/datetime.rst:1740
msgid "Instance attributes (read-only):"
msgstr "Атрибуты экземпляра (доступны только для чтения):"

#: ../../library/datetime.rst:291
msgid "Between -999,999,999 and 999,999,999 inclusive."
msgstr "От -999 999 999 до 999 999 999 включительно."

#: ../../library/datetime.rst:296
msgid "Between 0 and 86,399 inclusive."
msgstr "От 0 до 86 399 включительно."

#: ../../library/datetime.rst:300
msgid ""
"It is a somewhat common bug for code to unintentionally use this attribute "
"when it is actually intended to get a :meth:`~timedelta.total_seconds` value "
"instead:"
msgstr ""
"Это довольно распространенная ошибка, когда код непреднамеренно использует "
"этот атрибут, хотя на самом деле он предназначен для получения вместо этого "
"значения :meth:`~timedelta.total_секунды`:"

#: ../../library/datetime.rst:304
msgid ""
">>> from datetime import timedelta\n"
">>> duration = timedelta(seconds=11235813)\n"
">>> duration.days, duration.seconds\n"
"(130, 3813)\n"
">>> duration.total_seconds()\n"
"11235813.0"
msgstr ""
">>> from datetime import timedelta\n"
">>> duration = timedelta(seconds=11235813)\n"
">>> duration.days, duration.seconds\n"
"(130, 3813)\n"
">>> duration.total_seconds()\n"
"11235813.0"

#: ../../library/datetime.rst:315
msgid "Between 0 and 999,999 inclusive."
msgstr "От 0 до 999 999 включительно."

#: ../../library/datetime.rst:318 ../../library/datetime.rst:601
#: ../../library/datetime.rst:1162
msgid "Supported operations:"
msgstr "Поддерживаемые операции:"

#: ../../library/datetime.rst:323 ../../library/datetime.rst:604
#: ../../library/datetime.rst:1165
msgid "Operation"
msgstr "Операция"

#: ../../library/datetime.rst:323 ../../library/datetime.rst:604
#: ../../library/datetime.rst:1165
msgid "Result"
msgstr "Результат"

#: ../../library/datetime.rst:325
msgid "``t1 = t2 + t3``"
msgstr "``t1 = t2 + t3``"

#: ../../library/datetime.rst:325
msgid ""
"Sum of ``t2`` and ``t3``. Afterwards ``t1 - t2 == t3`` and ``t1 - t3 == t2`` "
"are true. (1)"
msgstr ""
"Сумма ``t2`` и ``t3``. После этого ``t1 - t2 == t3`` и ``t1 - t3 == t2`` "
"являются истинными. (1)"

#: ../../library/datetime.rst:329
msgid "``t1 = t2 - t3``"
msgstr "``t1 = t2 - t3``"

#: ../../library/datetime.rst:329
msgid ""
"Difference of ``t2``  and ``t3``. Afterwards ``t1 == t2 - t3`` and ``t2 == "
"t1 + t3`` are true. (1)(6)"
msgstr ""
"Разница «t2» и «t3». После этого ``t1 == t2 - t3`` и ``t2 == t1 + t3`` "
"являются истинными. (1)(6)"

#: ../../library/datetime.rst:333
msgid "``t1 = t2 * i or t1 = i * t2``"
msgstr "``t1 = t2 * i or t1 = i * t2``"

#: ../../library/datetime.rst:333
msgid ""
"Delta multiplied by an integer. Afterwards ``t1 // i == t2`` is true, "
"provided ``i != 0``."
msgstr ""
"Дельта, умноженная на целое число. После этого ``t1 // i == t2`` будет "
"истинным, если ``i != 0``."

#: ../../library/datetime.rst:337
msgid "In general, ``t1  * i == t1 * (i-1) + t1`` is true. (1)"
msgstr "В общем, ``t1 * i == t1 * (i-1) + t1`` верно. (1)"

#: ../../library/datetime.rst:340
msgid "``t1 = t2 * f or t1 = f * t2``"
msgstr "``t1 = t2 * f or t1 = f * t2``"

#: ../../library/datetime.rst:340
msgid ""
"Delta multiplied by a float. The result is rounded to the nearest multiple "
"of timedelta.resolution using round-half-to-even."
msgstr ""
"Дельта умножается на число с плавающей точкой. Результат округляется до "
"ближайшего значения, кратного timedelta.resolution, с использованием метода "
"округления от половины до четного."

#: ../../library/datetime.rst:344
msgid "``f = t2 / t3``"
msgstr "``f = t2 / t3``"

#: ../../library/datetime.rst:344
msgid ""
"Division (3) of overall duration ``t2`` by interval unit ``t3``. Returns a :"
"class:`float` object."
msgstr ""
"Деление (3) общей продолжительности ``t2`` на единицу интервала ``t3``. "
"Возвращает объект :class:`float`."

#: ../../library/datetime.rst:348
msgid "``t1 = t2 / f or t1 = t2 / i``"
msgstr "``t1 = t2 / f or t1 = t2 / i``"

#: ../../library/datetime.rst:348
msgid ""
"Delta divided by a float or an int. The result is rounded to the nearest "
"multiple of timedelta.resolution using round-half-to-even."
msgstr ""
"Дельта делится на число с плавающей точкой или целое число. Результат "
"округляется до ближайшего значения, кратного значению timedelta.resolution, "
"с использованием метода округления от половины до четного."

#: ../../library/datetime.rst:352
msgid "``t1 = t2 // i`` or ``t1 = t2 // t3``"
msgstr "``t1 = t2 // i`` or ``t1 = t2 // t3``"

#: ../../library/datetime.rst:352
msgid ""
"The floor is computed and the remainder (if any) is thrown away. In the "
"second case, an integer is returned. (3)"
msgstr ""
"Вычисляется минимальное значение, а остаток (если таковой имеется) "
"отбрасывается. Во втором случае возвращается целое число. (3)"

#: ../../library/datetime.rst:356
msgid "``t1 = t2 % t3``"
msgstr "``t1 = t2 % t3``"

#: ../../library/datetime.rst:356
msgid "The remainder is computed as a :class:`timedelta` object. (3)"
msgstr "Оставшаяся часть вычисляется как объект :class:`timedelta`. (3)"

#: ../../library/datetime.rst:359
msgid "``q, r = divmod(t1, t2)``"
msgstr "``q, r = divmod(t1, t2)``"

#: ../../library/datetime.rst:359
msgid ""
"Computes the quotient and the remainder: ``q = t1 // t2`` (3) and ``r = t1 % "
"t2``. ``q`` is an integer and ``r`` is a :class:`timedelta` object."
msgstr ""
"Вычисляет частное и остаток: ``q = t1 // t2`` (3) и ``r = t1 % t2``. ``q`` "
"является целым числом, а ``r`` представляет собой объект :class:`timedelta`."

#: ../../library/datetime.rst:364
msgid "``+t1``"
msgstr "``+t1``"

#: ../../library/datetime.rst:364
msgid "Returns a :class:`timedelta` object with the same value. (2)"
msgstr "Возвращает объект :class:`timedelta` с тем же значением. (2)"

#: ../../library/datetime.rst:367
msgid "``-t1``"
msgstr "``-t1``"

#: ../../library/datetime.rst:367
msgid ""
"Equivalent to ``timedelta(-t1.days, -t1.seconds, -t1.microseconds)``, and to "
"``t1 * -1``. (1)(4)"
msgstr ""
"Эквивалентно ``timedelta(-t1.days, -t1.секунды, -t1.микросекунды)`` и ``t1 * "
"-1``. (1)(4)"

#: ../../library/datetime.rst:371
msgid "``abs(t)``"
msgstr "``abs(t)``"

#: ../../library/datetime.rst:371
msgid ""
"Equivalent to ``+t`` when ``t.days >= 0``, and to ``-t`` when ``t.days < "
"0``. (2)"
msgstr ""
"Эквивалентно ``+t``, когда ``t.days >= 0``, и ``-t``, когда ``t.days < 0``. "
"(2)"

#: ../../library/datetime.rst:374
msgid "``str(t)``"
msgstr "``str(t)``"

#: ../../library/datetime.rst:374
msgid ""
"Returns a string in the form ``[D day[s], ][H]H:MM:SS[.UUUUUU]``, where D is "
"negative for negative ``t``. (5)"
msgstr ""
"Возвращает строку в виде ``[D day[s], ][H]H:MM:SS[.UUUUUU]``, где D - "
"отрицательное значение для отрицательного ``t``. (5)"

#: ../../library/datetime.rst:378
msgid "``repr(t)``"
msgstr "``repr(t)``"

#: ../../library/datetime.rst:378
msgid ""
"Returns a string representation of the :class:`timedelta` object as a "
"constructor call with canonical attribute values."
msgstr ""
"Возвращает строковое представление объекта :class:`timedelta` в виде вызова "
"конструктора с каноническими значениями атрибутов."

#: ../../library/datetime.rst:384 ../../library/datetime.rst:623
#: ../../library/datetime.rst:2570
msgid "Notes:"
msgstr "Примечания:"

#: ../../library/datetime.rst:387
msgid "This is exact but may overflow."
msgstr "Это точно, но может привести к переполнению."

#: ../../library/datetime.rst:390
msgid "This is exact and cannot overflow."
msgstr "Это точно и не может привести к переполнению."

#: ../../library/datetime.rst:393
msgid "Division by zero raises :exc:`ZeroDivisionError`."
msgstr "Деление на ноль вызывает :exc:`ZeroDivisionError`."

#: ../../library/datetime.rst:396
msgid "``-timedelta.max`` is not representable as a :class:`timedelta` object."
msgstr ""
"``-timedelta.max`` не может быть представлен как объект :class:`timedelta`."

#: ../../library/datetime.rst:399
msgid ""
"String representations of :class:`timedelta` objects are normalized "
"similarly to their internal representation. This leads to somewhat unusual "
"results for negative timedeltas. For example::"
msgstr ""
"Строковые представления объектов :class:`timedelta` нормализуются аналогично "
"их внутреннему представлению. Это приводит к несколько необычным результатам "
"для отрицательных временных дельт. Например::"

#: ../../library/datetime.rst:403
msgid ""
">>> timedelta(hours=-5)\n"
"datetime.timedelta(days=-1, seconds=68400)\n"
">>> print(_)\n"
"-1 day, 19:00:00"
msgstr ""
">>> timedelta(hours=-5)\n"
"datetime.timedelta(days=-1, seconds=68400)\n"
">>> print(_)\n"
"-1 day, 19:00:00"

#: ../../library/datetime.rst:409
msgid ""
"The expression ``t2 - t3`` will always be equal to the expression ``t2 + (-"
"t3)`` except when t3 is equal to ``timedelta.max``; in that case the former "
"will produce a result while the latter will overflow."
msgstr ""
"Выражение ``t2 - t3`` всегда будет равно выражению ``t2 + (-t3)``, за "
"исключением случаев, когда t3 равно ``timedelta.max``; в этом случае первый "
"даст результат, а второй переполнится."

#: ../../library/datetime.rst:413
msgid ""
"In addition to the operations listed above, :class:`timedelta` objects "
"support certain additions and subtractions with :class:`date` and :class:`."
"datetime` objects (see below)."
msgstr ""
"В дополнение к операциям, перечисленным выше, объекты :class:`timedelta` "
"поддерживают определенные сложения и вычитания с объектами :class:`date` и :"
"class:`.datetime` (см. ниже)."

#: ../../library/datetime.rst:417
msgid ""
"Floor division and true division of a :class:`timedelta` object by another :"
"class:`timedelta` object are now supported, as are remainder operations and "
"the :func:`divmod` function. True division and multiplication of a :class:"
"`timedelta` object by a :class:`float` object are now supported."
msgstr ""
"Теперь поддерживаются деление этажа и истинное деление объекта :class:"
"`timedelta` на другой объект :class:`timedelta`, а также операции с "
"остатками и функция :func:`divmod`. Теперь поддерживается истинное деление и "
"умножение объекта :class:`timedelta` на объект :class:`float`."

#: ../../library/datetime.rst:423
msgid ":class:`timedelta` objects support equality and order comparisons."
msgstr ""
"Объекты :class:`timedelta` поддерживают сравнение на равенство и порядок."

#: ../../library/datetime.rst:425
msgid ""
"In Boolean contexts, a :class:`timedelta` object is considered to be true if "
"and only if it isn't equal to ``timedelta(0)``."
msgstr ""
"В логическом контексте объект :class:`timedelta` считается истинным тогда и "
"только тогда, когда он не равен ``timedelta(0)``."

#: ../../library/datetime.rst:428 ../../library/datetime.rst:649
#: ../../library/datetime.rst:1248 ../../library/datetime.rst:1847
msgid "Instance methods:"
msgstr "Методы экземпляра:"

#: ../../library/datetime.rst:432
msgid ""
"Return the total number of seconds contained in the duration. Equivalent to "
"``td / timedelta(seconds=1)``. For interval units other than seconds, use "
"the division form directly (e.g. ``td / timedelta(microseconds=1)``)."
msgstr ""
"Возвращает общее количество секунд, содержащихся в продолжительности. "
"Эквивалентно ``td / timedelta(секунды=1)``. Для единиц измерения интервала, "
"отличных от секунд, используйте непосредственно форму деления (например, "
"``td / timedelta(микросекунды=1)``)."

#: ../../library/datetime.rst:436
msgid ""
"Note that for very large time intervals (greater than 270 years on most "
"platforms) this method will lose microsecond accuracy."
msgstr ""
"Обратите внимание, что для очень больших интервалов времени (более 270 лет "
"на большинстве платформ) этот метод теряет микросекундную точность."

#: ../../library/datetime.rst:442
msgid "Examples of usage: :class:`timedelta`"
msgstr "Примеры использования: :class:`timedelta`"

#: ../../library/datetime.rst:444
msgid "An additional example of normalization::"
msgstr "Дополнительный пример нормализации::"

#: ../../library/datetime.rst:446
msgid ""
">>> # Components of another_year add up to exactly 365 days\n"
">>> from datetime import timedelta\n"
">>> year = timedelta(days=365)\n"
">>> another_year = timedelta(weeks=40, days=84, hours=23,\n"
"...                          minutes=50, seconds=600)\n"
">>> year == another_year\n"
"True\n"
">>> year.total_seconds()\n"
"31536000.0"
msgstr ""
">>> # Components of another_year add up to exactly 365 days\n"
">>> from datetime import timedelta\n"
">>> year = timedelta(days=365)\n"
">>> another_year = timedelta(weeks=40, days=84, hours=23,\n"
"...                          minutes=50, seconds=600)\n"
">>> year == another_year\n"
"True\n"
">>> year.total_seconds()\n"
"31536000.0"

#: ../../library/datetime.rst:456
msgid "Examples of :class:`timedelta` arithmetic::"
msgstr "Примеры арифметики :class:`timedelta`::"

#: ../../library/datetime.rst:458
msgid ""
">>> from datetime import timedelta\n"
">>> year = timedelta(days=365)\n"
">>> ten_years = 10 * year\n"
">>> ten_years\n"
"datetime.timedelta(days=3650)\n"
">>> ten_years.days // 365\n"
"10\n"
">>> nine_years = ten_years - year\n"
">>> nine_years\n"
"datetime.timedelta(days=3285)\n"
">>> three_years = nine_years // 3\n"
">>> three_years, three_years.days // 365\n"
"(datetime.timedelta(days=1095), 3)"
msgstr ""
">>> from datetime import timedelta\n"
">>> year = timedelta(days=365)\n"
">>> ten_years = 10 * year\n"
">>> ten_years\n"
"datetime.timedelta(days=3650)\n"
">>> ten_years.days // 365\n"
"10\n"
">>> nine_years = ten_years - year\n"
">>> nine_years\n"
"datetime.timedelta(days=3285)\n"
">>> three_years = nine_years // 3\n"
">>> three_years, three_years.days // 365\n"
"(datetime.timedelta(days=1095), 3)"

#: ../../library/datetime.rst:475
msgid ":class:`date` Objects"
msgstr "Объекты :class:`date`"

#: ../../library/datetime.rst:477
msgid ""
"A :class:`date` object represents a date (year, month and day) in an "
"idealized calendar, the current Gregorian calendar indefinitely extended in "
"both directions."
msgstr ""
"Объект :class:`date` представляет дату (год, месяц и день) в "
"идеализированном календаре, текущем григорианском календаре, неограниченно "
"расширенном в обоих направлениях."

#: ../../library/datetime.rst:481
msgid ""
"January 1 of year 1 is called day number 1, January 2 of year 1 is called "
"day number 2, and so on. [#]_"
msgstr ""
"1 января года 1 называется днем ​​номер 1, 2 января года 1 называется днем ​​"
"номер 2 и так далее. [#]_"

#: ../../library/datetime.rst:486
msgid ""
"All arguments are required. Arguments must be integers, in the following "
"ranges:"
msgstr ""
"Все аргументы обязательны. Аргументы должны быть целыми числами в следующих "
"диапазонах:"

#: ../../library/datetime.rst:489
msgid "``MINYEAR <= year <= MAXYEAR``"
msgstr "``MINYEAR <= year <= MAXYEAR``"

#: ../../library/datetime.rst:490
msgid "``1 <= month <= 12``"
msgstr "``1 <= month <= 12``"

#: ../../library/datetime.rst:491
msgid "``1 <= day <= number of days in the given month and year``"
msgstr "``1 <= day <= number of days in the given month and year``"

#: ../../library/datetime.rst:493 ../../library/datetime.rst:864
msgid ""
"If an argument outside those ranges is given, :exc:`ValueError` is raised."
msgstr ""
"Если указан аргумент за пределами этих диапазонов, возникает :exc:"
"`ValueError`."

#: ../../library/datetime.rst:496 ../../library/datetime.rst:869
msgid "Other constructors, all class methods:"
msgstr "Другие конструкторы, все методы класса:"

#: ../../library/datetime.rst:500
msgid "Return the current local date."
msgstr "Вернуть текущую местную дату."

#: ../../library/datetime.rst:502
msgid "This is equivalent to ``date.fromtimestamp(time.time())``."
msgstr "Это эквивалентно ``date.fromtimestamp(time.time())``."

#: ../../library/datetime.rst:506
msgid ""
"Return the local date corresponding to the POSIX timestamp, such as is "
"returned by :func:`time.time`."
msgstr ""
"Возвращает локальную дату, соответствующую временной метке POSIX, например, "
"возвращаемую :func:`time.time`."

#: ../../library/datetime.rst:509
msgid ""
"This may raise :exc:`OverflowError`, if the timestamp is out of the range of "
"values supported by the platform C :c:func:`localtime` function, and :exc:"
"`OSError` on :c:func:`localtime` failure. It's common for this to be "
"restricted to years from 1970 through 2038. Note that on non-POSIX systems "
"that include leap seconds in their notion of a timestamp, leap seconds are "
"ignored by :meth:`fromtimestamp`."
msgstr ""
"Это может вызвать :exc:`OverflowError`, если временная метка выходит за "
"пределы диапазона значений, поддерживаемых функцией платформы C :c:func:"
"`localtime`, и :exc:`OSError` в :c:func:`localtime`. ` провал. Обычно это "
"ограничивается годами с 1970 по 2038 год. Обратите внимание, что в системах, "
"отличных от POSIX, которые включают високосные секунды в понятие метки "
"времени, високосные секунды игнорируются :meth:`fromtimestamp`."

#: ../../library/datetime.rst:516
msgid ""
"Raise :exc:`OverflowError` instead of :exc:`ValueError` if the timestamp is "
"out of the range of values supported by the platform C :c:func:`localtime` "
"function. Raise :exc:`OSError` instead of :exc:`ValueError` on :c:func:"
"`localtime` failure."
msgstr ""
"Поднимите :exc:`OverflowError` вместо :exc:`ValueError`, если временная "
"метка выходит за пределы диапазона значений, поддерживаемых функцией "
"платформы C :c:func:`localtime`. Вызовите :exc:`OSError` вместо :exc:"
"`ValueError` при сбое :c:func:`localtime`."

#: ../../library/datetime.rst:525
msgid ""
"Return the date corresponding to the proleptic Gregorian ordinal, where "
"January 1 of year 1 has ordinal 1."
msgstr ""
"Возвращает дату, соответствующую пролептическому григорианскому порядковому "
"номеру, где 1 января года 1 имеет порядковый номер 1."

#: ../../library/datetime.rst:528
msgid ""
":exc:`ValueError` is raised unless ``1 <= ordinal <= date.max.toordinal()``. "
"For any date ``d``, ``date.fromordinal(d.toordinal()) == d``."
msgstr ""
":exc:`ValueError` возникает, если ``1 <= ordinal <= date.max.toordinal()``. "
"Для любой даты ``d`` ``date.fromordinal(d.toordinal()) == d``."

#: ../../library/datetime.rst:535
msgid ""
"Return a :class:`date` corresponding to a *date_string* given in any valid "
"ISO 8601 format, with the following exceptions:"
msgstr ""
"Возвращает :class:`date`, соответствующий *date_string*, заданному в любом "
"допустимом формате ISO 8601, за следующими исключениями:"

#: ../../library/datetime.rst:538 ../../library/datetime.rst:1029
msgid ""
"Reduced precision dates are not currently supported (``YYYY-MM``, ``YYYY``)."
msgstr ""
"Даты пониженной точности в настоящее время не поддерживаются (``ГГГГ-ММ``, "
"``ГГГГ``)."

#: ../../library/datetime.rst:540 ../../library/datetime.rst:1031
msgid ""
"Extended date representations are not currently supported (``±YYYYYY-MM-"
"DD``)."
msgstr ""
"Расширенное представление даты в настоящее время не поддерживается "
"(``±ГГГГГГ-ММ-ДД``)."

#: ../../library/datetime.rst:542 ../../library/datetime.rst:1033
msgid "Ordinal dates are not currently supported (``YYYY-OOO``)."
msgstr "Порядковые даты в настоящее время не поддерживаются (``ГГГГ-ООО``)."

#: ../../library/datetime.rst:544 ../../library/datetime.rst:1035
#: ../../library/datetime.rst:1476
msgid "Examples::"
msgstr "Примеры::"

#: ../../library/datetime.rst:546
msgid ""
">>> from datetime import date\n"
">>> date.fromisoformat('2019-12-04')\n"
"datetime.date(2019, 12, 4)\n"
">>> date.fromisoformat('20191204')\n"
"datetime.date(2019, 12, 4)\n"
">>> date.fromisoformat('2021-W01-1')\n"
"datetime.date(2021, 1, 4)"
msgstr ""
">>> from datetime import date\n"
">>> date.fromisoformat('2019-12-04')\n"
"datetime.date(2019, 12, 4)\n"
">>> date.fromisoformat('20191204')\n"
"datetime.date(2019, 12, 4)\n"
">>> date.fromisoformat('2021-W01-1')\n"
"datetime.date(2021, 1, 4)"

#: ../../library/datetime.rst:555
msgid "Previously, this method only supported the format ``YYYY-MM-DD``."
msgstr "Ранее этот метод поддерживал только формат «ГГГГ-ММ-ДД»."

#: ../../library/datetime.rst:560
msgid ""
"Return a :class:`date` corresponding to the ISO calendar date specified by "
"year, week and day. This is the inverse of the function :meth:`date."
"isocalendar`."
msgstr ""
"Возвращает :class:`date`, соответствующий дате календаря ISO, указанной "
"годом, неделей и днем. Это обратная функция :meth:`date.isocalendar`."

#: ../../library/datetime.rst:570
msgid "The earliest representable date, ``date(MINYEAR, 1, 1)``."
msgstr "Самая ранняя представимая дата, ``date(MINYEAR, 1, 1)``."

#: ../../library/datetime.rst:575
msgid "The latest representable date, ``date(MAXYEAR, 12, 31)``."
msgstr "Самая последняя представимая дата, ``date(MAXYEAR, 12, 31)``."

#: ../../library/datetime.rst:580
msgid ""
"The smallest possible difference between non-equal date objects, "
"``timedelta(days=1)``."
msgstr ""
"Наименьшая возможная разница между неравными объектами даты, "
"``timedelta(days=1)``."

#: ../../library/datetime.rst:588 ../../library/datetime.rst:1113
msgid "Between :const:`MINYEAR` and :const:`MAXYEAR` inclusive."
msgstr "Между :const:`MINYEAR` и :const:`MAXYEAR` включительно."

#: ../../library/datetime.rst:593 ../../library/datetime.rst:1118
msgid "Between 1 and 12 inclusive."
msgstr "От 1 до 12 включительно."

#: ../../library/datetime.rst:598 ../../library/datetime.rst:1123
msgid "Between 1 and the number of days in the given month of the given year."
msgstr "Между 1 и количеством дней в данном месяце данного года."

#: ../../library/datetime.rst:606
msgid "``date2 = date1 + timedelta``"
msgstr "``date2 = date1 + timedelta``"

#: ../../library/datetime.rst:606
msgid "``date2`` will be ``timedelta.days`` days after ``date1``. (1)"
msgstr "``date2`` будет через ``timedelta.days`` дней после ``date1``. (1)"

#: ../../library/datetime.rst:609
msgid "``date2 = date1 - timedelta``"
msgstr "``date2 = date1 - timedelta``"

#: ../../library/datetime.rst:609
msgid "Computes ``date2`` such that ``date2 + timedelta == date1``. (2)"
msgstr "Вычисляет ``date2`` так, что ``date2 + timedelta == date1``. (2)"

#: ../../library/datetime.rst:612
msgid "``timedelta = date1 - date2``"
msgstr "``timedelta = date1 - date2``"

#: ../../library/datetime.rst:612 ../../library/datetime.rst:1171
msgid "\\(3)"
msgstr "\\(3)"

#: ../../library/datetime.rst:0
msgid "``date1 == date2``"
msgstr "``date1 == date2``"

#: ../../library/datetime.rst:0
msgid "``date1 != date2``"
msgstr "``date1 != date2``"

#: ../../library/datetime.rst:614 ../../library/datetime.rst:1173
msgid "Equality comparison. (4)"
msgstr "Сравнение равенства. (4)"

#: ../../library/datetime.rst:0
msgid "``date1 < date2``"
msgstr "``date1 < date2``"

#: ../../library/datetime.rst:0
msgid "``date1 > date2``"
msgstr "``date1 > date2``"

#: ../../library/datetime.rst:0
msgid "``date1 <= date2``"
msgstr "``date1 <= date2``"

#: ../../library/datetime.rst:0
msgid "``date1 >= date2``"
msgstr "``date1 >= date2``"

#: ../../library/datetime.rst:617 ../../library/datetime.rst:1176
msgid "Order comparison. (5)"
msgstr "Сравнение заказов. (5)"

#: ../../library/datetime.rst:626
msgid ""
"*date2* is moved forward in time if ``timedelta.days > 0``, or backward if "
"``timedelta.days < 0``. Afterward ``date2 - date1 == timedelta.days``. "
"``timedelta.seconds`` and ``timedelta.microseconds`` are ignored. :exc:"
"`OverflowError` is raised if ``date2.year`` would be smaller than :const:"
"`MINYEAR` or larger than :const:`MAXYEAR`."
msgstr ""
"*date2* перемещается вперед во времени, если ``timedelta.days > 0``, или "
"назад, если ``timedelta.days < 0``. Далее ``date2 - date1 == timedelta."
"days``. ``timedelta.секунды`` и ``timedelta.microсекунды`` игнорируются. :"
"exc:`OverflowError` возникает, если ``date2.year`` меньше :const:`MINYEAR` "
"или больше :const:`MAXYEAR`."

#: ../../library/datetime.rst:633
msgid "``timedelta.seconds`` and ``timedelta.microseconds`` are ignored."
msgstr "``timedelta.seconds`` и ``timedelta.microseconds`` игнорируются."

#: ../../library/datetime.rst:636
msgid ""
"This is exact, and cannot overflow. ``timedelta.seconds`` and ``timedelta."
"microseconds`` are 0, and ``date2 + timedelta == date1`` after."
msgstr ""
"Это точно и не может переполниться. ``timedelta.seconds`` и ``timedelta."
"microseconds`` равны 0, а ``date2 + timedelta == date1`` после."

#: ../../library/datetime.rst:640
msgid ":class:`date` objects are equal if they represent the same date."
msgstr "Объекты :class:`date` равны, если они представляют одну и ту же дату."

#: ../../library/datetime.rst:643
msgid ""
"*date1* is considered less than *date2* when *date1* precedes *date2* in "
"time. In other words, ``date1 < date2`` if and only if ``date1.toordinal() < "
"date2.toordinal()``."
msgstr ""
"*date1* считается меньше, чем *date2*, если *date1* предшествует *date2* по "
"времени. Другими словами, ``date1 < date2`` тогда и только тогда, когда "
"``date1.toordinal() < date2.toordinal()``."

#: ../../library/datetime.rst:647
msgid ""
"In Boolean contexts, all :class:`date` objects are considered to be true."
msgstr "В логическом контексте все объекты :class:`date` считаются истинными."

#: ../../library/datetime.rst:653
msgid ""
"Return a new :class:`date` object with the same values, but with specified "
"parameters updated."
msgstr ""

#: ../../library/datetime.rst:656 ../../library/datetime.rst:1890
msgid "Example::"
msgstr "Пример::"

#: ../../library/datetime.rst:658
msgid ""
">>> from datetime import date\n"
">>> d = date(2002, 12, 31)\n"
">>> d.replace(day=26)\n"
"datetime.date(2002, 12, 26)"
msgstr ""
">>> from datetime import date\n"
">>> d = date(2002, 12, 31)\n"
">>> d.replace(day=26)\n"
"datetime.date(2002, 12, 26)"

#: ../../library/datetime.rst:666 ../../library/datetime.rst:1361
msgid ""
"Return a :class:`time.struct_time` such as returned by :func:`time."
"localtime`."
msgstr ""
"Возвращает :class:`time.struct_time`, например, возвращаемый :func:`time."
"localtime`."

#: ../../library/datetime.rst:668
msgid "The hours, minutes and seconds are 0, and the DST flag is -1."
msgstr "Часы, минуты и секунды равны 0, а флаг летнего времени равен -1."

#: ../../library/datetime.rst:670 ../../library/datetime.rst:1363
msgid "``d.timetuple()`` is equivalent to::"
msgstr "``d.timetuple()`` эквивалентен::"

#: ../../library/datetime.rst:672
msgid ""
"time.struct_time((d.year, d.month, d.day, 0, 0, 0, d.weekday(), yday, -1))"
msgstr ""
"time.struct_time((d.year, d.month, d.day, 0, 0, 0, d.weekday(), yday, -1))"

#: ../../library/datetime.rst:674
msgid ""
"where ``yday = d.toordinal() - date(d.year, 1, 1).toordinal() + 1`` is the "
"day number within the current year starting with 1 for January 1st."
msgstr ""
"where ``yday = d.toordinal() - date(d.year, 1, 1).toordinal() + 1`` is the "
"day number within the current year starting with 1 for January 1st."

#: ../../library/datetime.rst:680
msgid ""
"Return the proleptic Gregorian ordinal of the date, where January 1 of year "
"1 has ordinal 1. For any :class:`date` object ``d``, ``date.fromordinal(d."
"toordinal()) == d``."
msgstr ""
"Возвращает пролептический григорианский порядковый номер даты, где 1 января "
"года 1 имеет порядковый номер 1. Для любого :class:`date` объекта ``d``, "
"``date.fromordinal(d.toordinal()) == d` `."

#: ../../library/datetime.rst:687
msgid ""
"Return the day of the week as an integer, where Monday is 0 and Sunday is 6. "
"For example, ``date(2002, 12, 4).weekday() == 2``, a Wednesday. See also :"
"meth:`isoweekday`."
msgstr ""
"Возвращает день недели как целое число, где понедельник — 0, а воскресенье — "
"6. Например, ``date(2002, 12, 4).weekday() == 2``, среда. См. также :meth:"
"`isoweekday`."

#: ../../library/datetime.rst:694
msgid ""
"Return the day of the week as an integer, where Monday is 1 and Sunday is 7. "
"For example, ``date(2002, 12, 4).isoweekday() == 3``, a Wednesday. See also :"
"meth:`weekday`, :meth:`isocalendar`."
msgstr ""
"Возвращает день недели как целое число, где понедельник — 1, а воскресенье — "
"7. Например, ``date(2002, 12, 4).isoweekday() == 3``, среда. См. также :meth:"
"`weekday`, :meth:`isocalendar`."

#: ../../library/datetime.rst:701
msgid ""
"Return a :term:`named tuple` object with three components: ``year``, "
"``week`` and ``weekday``."
msgstr ""
"Возвращает объект :term:`named tuple` с тремя компонентами: ``год``, "
"``неделя`` и ``день недели``."

#: ../../library/datetime.rst:704
msgid ""
"The ISO calendar is a widely used variant of the Gregorian calendar. [#]_"
msgstr ""
"Календарь ISO является широко используемым вариантом григорианского "
"календаря. [#]_"

#: ../../library/datetime.rst:706
msgid ""
"The ISO year consists of 52 or 53 full weeks, and where a week starts on a "
"Monday and ends on a Sunday. The first week of an ISO year is the first "
"(Gregorian) calendar week of a year containing a Thursday. This is called "
"week number 1, and the ISO year of that Thursday is the same as its "
"Gregorian year."
msgstr ""
"Год ISO состоит из 52 или 53 полных недель, причем неделя начинается в "
"понедельник и заканчивается в воскресенье. Первая неделя года по ISO — это "
"первая (григорианская) календарная неделя года, содержащая четверг. Это "
"называется неделя номер 1, и год ISO этого четверга совпадает с годом по "
"григорианскому календарю."

#: ../../library/datetime.rst:711
msgid ""
"For example, 2004 begins on a Thursday, so the first week of ISO year 2004 "
"begins on Monday, 29 Dec 2003 and ends on Sunday, 4 Jan 2004::"
msgstr ""
"Например, 2004 год начинается в четверг, поэтому первая неделя 2004 года ISO "
"начинается в понедельник, 29 декабря 2003 года, и заканчивается в "
"воскресенье, 4 января 2004 года:"

#: ../../library/datetime.rst:714
msgid ""
">>> from datetime import date\n"
">>> date(2003, 12, 29).isocalendar()\n"
"datetime.IsoCalendarDate(year=2004, week=1, weekday=1)\n"
">>> date(2004, 1, 4).isocalendar()\n"
"datetime.IsoCalendarDate(year=2004, week=1, weekday=7)"
msgstr ""
">>> from datetime import date\n"
">>> date(2003, 12, 29).isocalendar()\n"
"datetime.IsoCalendarDate(year=2004, week=1, weekday=1)\n"
">>> date(2004, 1, 4).isocalendar()\n"
"datetime.IsoCalendarDate(year=2004, week=1, weekday=7)"

#: ../../library/datetime.rst:720
msgid "Result changed from a tuple to a :term:`named tuple`."
msgstr "Результат изменился с кортежа на кортеж с именем :term:`named`."

#: ../../library/datetime.rst:725
msgid ""
"Return a string representing the date in ISO 8601 format, ``YYYY-MM-DD``::"
msgstr ""
"Возвращает строку, представляющую дату в формате ISO 8601, ``ГГГГ-ММ-ДД``::"

#: ../../library/datetime.rst:727
msgid ""
">>> from datetime import date\n"
">>> date(2002, 12, 4).isoformat()\n"
"'2002-12-04'"
msgstr ""
">>> from datetime import date\n"
">>> date(2002, 12, 4).isoformat()\n"
"'2002-12-04'"

#: ../../library/datetime.rst:733
msgid "For a date ``d``, ``str(d)`` is equivalent to ``d.isoformat()``."
msgstr "Для даты ``d`` ``str(d)`` эквивалентен ``d.isoformat()``."

#: ../../library/datetime.rst:738
msgid "Return a string representing the date::"
msgstr "Возвращает строку, представляющую дату::"

#: ../../library/datetime.rst:740
msgid ""
">>> from datetime import date\n"
">>> date(2002, 12, 4).ctime()\n"
"'Wed Dec  4 00:00:00 2002'"
msgstr ""
">>> from datetime import date\n"
">>> date(2002, 12, 4).ctime()\n"
"'Wed Dec  4 00:00:00 2002'"

#: ../../library/datetime.rst:744 ../../library/datetime.rst:1547
msgid "``d.ctime()`` is equivalent to::"
msgstr "``d.ctime()`` эквивалентно::"

#: ../../library/datetime.rst:746 ../../library/datetime.rst:1549
msgid "time.ctime(time.mktime(d.timetuple()))"
msgstr "time.ctime(time.mktime(d.timetuple()))"

#: ../../library/datetime.rst:748
msgid ""
"on platforms where the native C :c:func:`ctime` function (which :func:`time."
"ctime` invokes, but which :meth:`date.ctime` does not invoke) conforms to "
"the C standard."
msgstr ""
"на платформах, где встроенная функция C :c:func:`ctime` (которая вызывается :"
"func:`time.ctime`, но не вызывается :meth:`date.ctime`) соответствует "
"стандарту C."

#: ../../library/datetime.rst:755
msgid ""
"Return a string representing the date, controlled by an explicit format "
"string. Format codes referring to hours, minutes or seconds will see 0 "
"values. See also :ref:`strftime-strptime-behavior` and :meth:`date."
"isoformat`."
msgstr ""
"Возвращает строку, представляющую дату, управляемую строкой явного формата. "
"Коды формата, относящиеся к часам, минутам или секундам, будут иметь 0 "
"значений. См. также :ref:`strftime-strptime-behavior` и :meth:`date."
"isoformat`."

#: ../../library/datetime.rst:762
msgid ""
"Same as :meth:`.date.strftime`. This makes it possible to specify a format "
"string for a :class:`.date` object in :ref:`formatted string literals <f-"
"strings>` and when using :meth:`str.format`. See also :ref:`strftime-"
"strptime-behavior` and :meth:`date.isoformat`."
msgstr ""
"То же, что и :meth:`.date.strftime`. Это позволяет указать строку формата "
"для объекта :class:`.date` в :ref:`форматированных строковых литералах <f-"
"strings>` и при использовании :meth:`str.format`. См. также :ref:`strftime-"
"strptime-behavior` и :meth:`date.isoformat`."

#: ../../library/datetime.rst:768
msgid "Examples of Usage: :class:`date`"
msgstr "Примеры использования: :class:`date`"

#: ../../library/datetime.rst:770
msgid "Example of counting days to an event::"
msgstr "Пример подсчета дней до события:"

#: ../../library/datetime.rst:772
msgid ""
">>> import time\n"
">>> from datetime import date\n"
">>> today = date.today()\n"
">>> today\n"
"datetime.date(2007, 12, 5)\n"
">>> today == date.fromtimestamp(time.time())\n"
"True\n"
">>> my_birthday = date(today.year, 6, 24)\n"
">>> if my_birthday < today:\n"
"...     my_birthday = my_birthday.replace(year=today.year + 1)\n"
"...\n"
">>> my_birthday\n"
"datetime.date(2008, 6, 24)\n"
">>> time_to_birthday = abs(my_birthday - today)\n"
">>> time_to_birthday.days\n"
"202"
msgstr ""
">>> import time\n"
">>> from datetime import date\n"
">>> today = date.today()\n"
">>> today\n"
"datetime.date(2007, 12, 5)\n"
">>> today == date.fromtimestamp(time.time())\n"
"True\n"
">>> my_birthday = date(today.year, 6, 24)\n"
">>> if my_birthday < today:\n"
"...     my_birthday = my_birthday.replace(year=today.year + 1)\n"
"...\n"
">>> my_birthday\n"
"datetime.date(2008, 6, 24)\n"
">>> time_to_birthday = abs(my_birthday - today)\n"
">>> time_to_birthday.days\n"
"202"

#: ../../library/datetime.rst:789
msgid "More examples of working with :class:`date`:"
msgstr "Еще примеры работы с :class:`date`:"

#: ../../library/datetime.rst:791
msgid ""
">>> from datetime import date\n"
">>> d = date.fromordinal(730920) # 730920th day after 1. 1. 0001\n"
">>> d\n"
"datetime.date(2002, 3, 11)\n"
"\n"
">>> # Methods related to formatting string output\n"
">>> d.isoformat()\n"
"'2002-03-11'\n"
">>> d.strftime(\"%d/%m/%y\")\n"
"'11/03/02'\n"
">>> d.strftime(\"%A %d. %B %Y\")\n"
"'Monday 11. March 2002'\n"
">>> d.ctime()\n"
"'Mon Mar 11 00:00:00 2002'\n"
">>> 'The {1} is {0:%d}, the {2} is {0:%B}.'.format(d, \"day\", \"month\")\n"
"'The day is 11, the month is March.'\n"
"\n"
">>> # Methods for to extracting 'components' under different calendars\n"
">>> t = d.timetuple()\n"
">>> for i in t:\n"
"...     print(i)\n"
"2002                # year\n"
"3                   # month\n"
"11                  # day\n"
"0\n"
"0\n"
"0\n"
"0                   # weekday (0 = Monday)\n"
"70                  # 70th day in the year\n"
"-1\n"
">>> ic = d.isocalendar()\n"
">>> for i in ic:\n"
"...     print(i)\n"
"2002                # ISO year\n"
"11                  # ISO week number\n"
"1                   # ISO day number ( 1 = Monday )\n"
"\n"
">>> # A date object is immutable; all operations produce a new object\n"
">>> d.replace(year=2005)\n"
"datetime.date(2005, 3, 11)"
msgstr ""
">>> from datetime import date\n"
">>> d = date.fromordinal(730920) # 730920th day after 1. 1. 0001\n"
">>> d\n"
"datetime.date(2002, 3, 11)\n"
"\n"
">>> # Methods related to formatting string output\n"
">>> d.isoformat()\n"
"'2002-03-11'\n"
">>> d.strftime(\"%d/%m/%y\")\n"
"'11/03/02'\n"
">>> d.strftime(\"%A %d. %B %Y\")\n"
"'Monday 11. March 2002'\n"
">>> d.ctime()\n"
"'Mon Mar 11 00:00:00 2002'\n"
">>> 'The {1} is {0:%d}, the {2} is {0:%B}.'.format(d, \"day\", \"month\")\n"
"'The day is 11, the month is March.'\n"
"\n"
">>> # Methods for to extracting 'components' under different calendars\n"
">>> t = d.timetuple()\n"
">>> for i in t:\n"
"...     print(i)\n"
"2002                # year\n"
"3                   # month\n"
"11                  # day\n"
"0\n"
"0\n"
"0\n"
"0                   # weekday (0 = Monday)\n"
"70                  # 70th day in the year\n"
"-1\n"
">>> ic = d.isocalendar()\n"
">>> for i in ic:\n"
"...     print(i)\n"
"2002                # ISO year\n"
"11                  # ISO week number\n"
"1                   # ISO day number ( 1 = Monday )\n"
"\n"
">>> # A date object is immutable; all operations produce a new object\n"
">>> d.replace(year=2005)\n"
"datetime.date(2005, 3, 11)"

#: ../../library/datetime.rst:838
msgid ":class:`.datetime` Objects"
msgstr "Объекты :class:`.datetime`"

#: ../../library/datetime.rst:840
msgid ""
"A :class:`.datetime` object is a single object containing all the "
"information from a :class:`date` object and a :class:`.time` object."
msgstr ""
"Объект :class:`.datetime` — это отдельный объект, содержащий всю информацию "
"из объекта :class:`date` и объекта :class:`.time`."

#: ../../library/datetime.rst:843
msgid ""
"Like a :class:`date` object, :class:`.datetime` assumes the current "
"Gregorian calendar extended in both directions; like a :class:`.time` "
"object, :class:`.datetime` assumes there are exactly 3600\\*24 seconds in "
"every day."
msgstr ""
"Подобно объекту :class:`date`, :class:`.datetime` предполагает, что текущий "
"григорианский календарь расширен в обоих направлениях; как и объект :class:`."
"time`, :class:`.datetime` предполагает, что в каждом дне ровно 3600\\*24 "
"секунды."

#: ../../library/datetime.rst:847
msgid "Constructor:"
msgstr "Конструктор:"

#: ../../library/datetime.rst:851
msgid ""
"The *year*, *month* and *day* arguments are required. *tzinfo* may be "
"``None``, or an instance of a :class:`tzinfo` subclass. The remaining "
"arguments must be integers in the following ranges:"
msgstr ""
"Аргументы *год*, *месяц* и *день* являются обязательными. *tzinfo* может "
"иметь значение None или быть экземпляром подкласса :class:`tzinfo`. "
"Остальные аргументы должны быть целыми числами в следующих диапазонах:"

#: ../../library/datetime.rst:855
msgid "``MINYEAR <= year <= MAXYEAR``,"
msgstr "``MINYEAR <= year <= MAXYEAR``,"

#: ../../library/datetime.rst:856
msgid "``1 <= month <= 12``,"
msgstr "``1 <= month <= 12``,"

#: ../../library/datetime.rst:857
msgid "``1 <= day <= number of days in the given month and year``,"
msgstr "``1 <= day <= number of days in the given month and year``,"

#: ../../library/datetime.rst:858 ../../library/datetime.rst:1711
msgid "``0 <= hour < 24``,"
msgstr "``0 <= hour < 24``,"

#: ../../library/datetime.rst:859 ../../library/datetime.rst:1712
msgid "``0 <= minute < 60``,"
msgstr "``0 <= minute < 60``,"

#: ../../library/datetime.rst:860 ../../library/datetime.rst:1713
msgid "``0 <= second < 60``,"
msgstr "``0 <= second < 60``,"

#: ../../library/datetime.rst:861 ../../library/datetime.rst:1714
msgid "``0 <= microsecond < 1000000``,"
msgstr "``0 <= microsecond < 1000000``,"

#: ../../library/datetime.rst:862 ../../library/datetime.rst:1715
msgid "``fold in [0, 1]``."
msgstr "``fold in [0, 1]``."

#: ../../library/datetime.rst:866 ../../library/datetime.rst:1282
#: ../../library/datetime.rst:1857
msgid "Added the *fold* parameter."
msgstr "Добавлен параметр *fold*."

#: ../../library/datetime.rst:873
msgid "Return the current local date and time, with :attr:`.tzinfo` ``None``."
msgstr ""
"Возвращает текущую местную дату и время с помощью :attr:`.tzinfo` ``None``."

#: ../../library/datetime.rst:875
msgid "Equivalent to::"
msgstr "Эквивалентно::"

#: ../../library/datetime.rst:877
msgid "datetime.fromtimestamp(time.time())"
msgstr "datetime.fromtimestamp(time.time())"

#: ../../library/datetime.rst:879
msgid "See also :meth:`now`, :meth:`fromtimestamp`."
msgstr "См. также :meth:`now`, :meth:`fromtimestamp`."

#: ../../library/datetime.rst:881
msgid ""
"This method is functionally equivalent to :meth:`now`, but without a ``tz`` "
"parameter."
msgstr ""
"Этот метод функционально эквивалентен :meth:`now`, но без параметра tz``."

#: ../../library/datetime.rst:886
msgid "Return the current local date and time."
msgstr "Возвращает текущую местную дату и время."

#: ../../library/datetime.rst:888
msgid ""
"If optional argument *tz* is ``None`` or not specified, this is like :meth:"
"`today`, but, if possible, supplies more precision than can be gotten from "
"going through a :func:`time.time` timestamp (for example, this may be "
"possible on platforms supplying the C :c:func:`gettimeofday` function)."
msgstr ""
"Если необязательный аргумент *tz* имеет значение ``None`` или не указан, это "
"похоже на :meth:`today`, но, если возможно, обеспечивает большую точность, "
"чем можно получить при использовании :func:`time.time` временная метка "
"(например, это может быть возможно на платформах, поддерживающих функцию C :"
"c:func:`gettimeofday`)."

#: ../../library/datetime.rst:894
msgid ""
"If *tz* is not ``None``, it must be an instance of a :class:`tzinfo` "
"subclass, and the current date and time are converted to *tz*’s time zone."
msgstr ""
"Если *tz* не ``None``, он должен быть экземпляром подкласса :class:`tzinfo`, "
"а текущая дата и время преобразуются в часовой пояс *tz*."

#: ../../library/datetime.rst:897
msgid "This function is preferred over :meth:`today` and :meth:`utcnow`."
msgstr "Эта функция предпочтительнее :meth:`today` и :meth:`utcnow`."

#: ../../library/datetime.rst:901
msgid ""
"Subsequent calls to :meth:`!datetime.now` may return the same instant "
"depending on the precision of the underlying clock."
msgstr ""
"Последующие вызовы :meth:`!datetime.now` могут возвращать тот же момент "
"времени в зависимости от точности базовых часов."

#: ../../library/datetime.rst:906
msgid "Return the current UTC date and time, with :attr:`.tzinfo` ``None``."
msgstr ""
"Возвращает текущую дату и время в формате UTC с помощью :attr:`.tzinfo` "
"``None``."

#: ../../library/datetime.rst:908
msgid ""
"This is like :meth:`now`, but returns the current UTC date and time, as a "
"naive :class:`.datetime` object. An aware current UTC datetime can be "
"obtained by calling ``datetime.now(timezone.utc)``. See also :meth:`now`."
msgstr ""
"Это похоже на :meth:`now`, но возвращает текущую дату и время в формате UTC "
"как простой объект :class:`.datetime`. Текущую дату и время в формате UTC "
"можно получить, вызвав ``datetime.now(timezone.utc)``. См. также :meth:"
"`сейчас`."

#: ../../library/datetime.rst:914
msgid ""
"Because naive ``datetime`` objects are treated by many ``datetime`` methods "
"as local times, it is preferred to use aware datetimes to represent times in "
"UTC. As such, the recommended way to create an object representing the "
"current time in UTC is by calling ``datetime.now(timezone.utc)``."
msgstr ""
"Поскольку наивные объекты datetime обрабатываются многими методами datetime "
"как локальное время, для представления времени в формате UTC "
"предпочтительнее использовать осведомленные объекты datetime. Таким образом, "
"рекомендуемый способ создания объекта, представляющего текущее время в "
"формате UTC, — это вызов ``datetime.now(timezone.utc)``."

#: ../../library/datetime.rst:921
msgid "Use :meth:`datetime.now` with :const:`UTC` instead."
msgstr ""

#: ../../library/datetime.rst:926
msgid ""
"Return the local date and time corresponding to the POSIX timestamp, such as "
"is returned by :func:`time.time`. If optional argument *tz* is ``None`` or "
"not specified, the timestamp is converted to the platform's local date and "
"time, and the returned :class:`.datetime` object is naive."
msgstr ""
"Возвращает локальную дату и время, соответствующие временной метке POSIX, "
"например, возвращаемые :func:`time.time`. Если необязательный аргумент *tz* "
"имеет значение ``None`` или не указан, временная метка преобразуется в "
"локальную дату и время платформы, а возвращаемый объект :class:`.datetime` "
"является наивным."

#: ../../library/datetime.rst:931
msgid ""
"If *tz* is not ``None``, it must be an instance of a :class:`tzinfo` "
"subclass, and the timestamp is converted to *tz*’s time zone."
msgstr ""
"Если *tz* не ``None``, он должен быть экземпляром подкласса :class:`tzinfo`, "
"а временная метка преобразуется в часовой пояс *tz*."

#: ../../library/datetime.rst:934
msgid ""
":meth:`fromtimestamp` may raise :exc:`OverflowError`, if the timestamp is "
"out of the range of values supported by the platform C :c:func:`localtime` "
"or :c:func:`gmtime` functions, and :exc:`OSError` on :c:func:`localtime` or :"
"c:func:`gmtime` failure. It's common for this to be restricted to years in "
"1970 through 2038. Note that on non-POSIX systems that include leap seconds "
"in their notion of a timestamp, leap seconds are ignored by :meth:"
"`fromtimestamp`, and then it's possible to have two timestamps differing by "
"a second that yield identical :class:`.datetime` objects. This method is "
"preferred over :meth:`utcfromtimestamp`."
msgstr ""
":meth:`fromtimestamp` может вызвать :exc:`OverflowError`, если метка времени "
"выходит за пределы диапазона значений, поддерживаемых функциями платформы C :"
"c:func:`localtime` или :c:func:`gmtime`, и :exc:`OSError` при сбое :c:func:"
"`localtime` или :c:func:`gmtime`. Обычно это ограничивается годами с 1970 по "
"2038 год. Обратите внимание, что в системах, отличных от POSIX, которые "
"включают дополнительные секунды в понятие метки времени, дополнительные "
"секунды игнорируются :meth:`fromtimestamp`, и тогда можно иметь две "
"временные метки, отличающиеся на секунду, которые дают идентичные объекты :"
"class:`.datetime`. Этот метод предпочтительнее :meth:`utcfromtimestamp`."

#: ../../library/datetime.rst:945
msgid ""
"Raise :exc:`OverflowError` instead of :exc:`ValueError` if the timestamp is "
"out of the range of values supported by the platform C :c:func:`localtime` "
"or :c:func:`gmtime` functions. Raise :exc:`OSError` instead of :exc:"
"`ValueError` on :c:func:`localtime` or :c:func:`gmtime` failure."
msgstr ""
"Вызовите :exc:`OverflowError` вместо :exc:`ValueError`, если временная метка "
"выходит за пределы диапазона значений, поддерживаемых функциями платформы C :"
"c:func:`localtime` или :c:func:`gmtime`. Вызовите :exc:`OSError` вместо :exc:"
"`ValueError` при сбое :c:func:`localtime` или :c:func:`gmtime`."

#: ../../library/datetime.rst:952
msgid ":meth:`fromtimestamp` may return instances with :attr:`.fold` set to 1."
msgstr ""
":meth:`fromtimestamp` может возвращать экземпляры с :attr:`.fold`, "
"установленным в 1."

#: ../../library/datetime.rst:957
msgid ""
"Return the UTC :class:`.datetime` corresponding to the POSIX timestamp, "
"with :attr:`.tzinfo` ``None``.  (The resulting object is naive.)"
msgstr ""
"Возвращает UTC :class:`.datetime`, соответствующий временной метке POSIX, с :"
"attr:`.tzinfo` ``None``. (Полученный объект является наивным.)"

#: ../../library/datetime.rst:960
msgid ""
"This may raise :exc:`OverflowError`, if the timestamp is out of the range of "
"values supported by the platform C :c:func:`gmtime` function, and :exc:"
"`OSError` on :c:func:`gmtime` failure. It's common for this to be restricted "
"to years in 1970 through 2038."
msgstr ""
"Это может вызвать :exc:`OverflowError`, если временная метка выходит за "
"пределы диапазона значений, поддерживаемых функцией платформы C :c:func:"
"`gmtime`, и :exc:`OSError` в :c:func:`gmtime`. ` провал. Обычно это "
"ограничивается годами с 1970 по 2038 год."

#: ../../library/datetime.rst:965
msgid "To get an aware :class:`.datetime` object, call :meth:`fromtimestamp`::"
msgstr ""
"Чтобы получить осведомленный объект :class:`.datetime`, вызовите :meth:"
"`fromtimestamp`::"

#: ../../library/datetime.rst:967
msgid "datetime.fromtimestamp(timestamp, timezone.utc)"
msgstr "datetime.fromtimestamp(timestamp, timezone.utc)"

#: ../../library/datetime.rst:969
msgid ""
"On the POSIX compliant platforms, it is equivalent to the following "
"expression::"
msgstr ""
"На платформах, совместимых с POSIX, это эквивалентно следующему выражению:"

#: ../../library/datetime.rst:972
msgid ""
"datetime(1970, 1, 1, tzinfo=timezone.utc) + timedelta(seconds=timestamp)"
msgstr ""
"datetime(1970, 1, 1, tzinfo=timezone.utc) + timedelta(seconds=timestamp)"

#: ../../library/datetime.rst:974
msgid ""
"except the latter formula always supports the full years range: between :"
"const:`MINYEAR` and :const:`MAXYEAR` inclusive."
msgstr ""
"за исключением того, что последняя формула всегда поддерживает полный "
"диапазон лет: от :const:`MINYEAR` до :const:`MAXYEAR` включительно."

#: ../../library/datetime.rst:979
msgid ""
"Because naive ``datetime`` objects are treated by many ``datetime`` methods "
"as local times, it is preferred to use aware datetimes to represent times in "
"UTC. As such, the recommended way to create an object representing a "
"specific timestamp in UTC is by calling ``datetime.fromtimestamp(timestamp, "
"tz=timezone.utc)``."
msgstr ""
"Поскольку наивные объекты datetime обрабатываются многими методами datetime "
"как локальное время, для представления времени в формате UTC "
"предпочтительнее использовать осведомленные объекты datetime. Таким образом, "
"рекомендуемый способ создания объекта, представляющего определенную "
"временную метку в формате UTC, — это вызов ``datetime."
"fromtimestamp(timestamp, tz=timezone.utc)``."

#: ../../library/datetime.rst:985
msgid ""
"Raise :exc:`OverflowError` instead of :exc:`ValueError` if the timestamp is "
"out of the range of values supported by the platform C :c:func:`gmtime` "
"function. Raise :exc:`OSError` instead of :exc:`ValueError` on :c:func:"
"`gmtime` failure."
msgstr ""
"Поднимите :exc:`OverflowError` вместо :exc:`ValueError`, если временная "
"метка выходит за пределы диапазона значений, поддерживаемых функцией "
"платформы C :c:func:`gmtime`. Вызовите :exc:`OSError` вместо :exc:"
"`ValueError` при сбое :c:func:`gmtime`."

#: ../../library/datetime.rst:993
msgid "Use :meth:`datetime.fromtimestamp` with :const:`UTC` instead."
msgstr ""

#: ../../library/datetime.rst:998
msgid ""
"Return the :class:`.datetime` corresponding to the proleptic Gregorian "
"ordinal, where January 1 of year 1 has ordinal 1. :exc:`ValueError` is "
"raised unless ``1 <= ordinal <= datetime.max.toordinal()``. The hour, "
"minute, second and microsecond of the result are all 0, and :attr:`.tzinfo` "
"is ``None``."
msgstr ""
"Возвращает :class:`.datetime`, соответствующий пролептическому "
"григорианскому порядковому номеру, где 1 января года 1 имеет порядковый "
"номер 1. :exc:`ValueError` возникает, если ``1 <= ordinal <= datetime.max."
"toordinal() ``. Час, минута, секунда и микросекунда результата равны 0, а :"
"attr:`.tzinfo` имеет значение ``None``."

#: ../../library/datetime.rst:1006
msgid ""
"Return a new :class:`.datetime` object whose date components are equal to "
"the given :class:`date` object's, and whose time components are equal to the "
"given :class:`.time` object's. If the *tzinfo* argument is provided, its "
"value is used to set the :attr:`.tzinfo` attribute of the result, otherwise "
"the :attr:`~.time.tzinfo` attribute of the *time* argument is used.  If the "
"*date* argument is a :class:`.datetime` object, its time components and :"
"attr:`.tzinfo` attributes are ignored."
msgstr ""
"Возвращает новый объект :class:`.datetime`, компоненты даты которого равны "
"заданному объекту :class:`date`, а компоненты времени равны заданному "
"объекту :class:`.time`. Если указан аргумент *tzinfo*, его значение "
"используется для установки атрибута :attr:`.tzinfo` результата, в противном "
"случае используется атрибут :attr:`~.time.tzinfo` аргумента *time*. Если "
"аргумент *date* является объектом :class:`.datetime`, его компоненты времени "
"и атрибуты :attr:`.tzinfo` игнорируются."

#: ../../library/datetime.rst:1014
msgid ""
"For any :class:`.datetime` object ``d``, ``d == datetime.combine(d.date(), d."
"time(), d.tzinfo)``."
msgstr ""
"Для любого объекта :class:`.datetime` ``d``, ``d == datetime.combine(d."
"date(), d.time(), d.tzinfo)``."

#: ../../library/datetime.rst:1017
msgid "Added the *tzinfo* argument."
msgstr "Добавлен аргумент *tzinfo*."

#: ../../library/datetime.rst:1023
msgid ""
"Return a :class:`.datetime` corresponding to a *date_string* in any valid "
"ISO 8601 format, with the following exceptions:"
msgstr ""
"Возвращает :class:`.datetime`, соответствующий *date_string* в любом "
"допустимом формате ISO 8601, за следующими исключениями:"

#: ../../library/datetime.rst:1026 ../../library/datetime.rst:1811
msgid "Time zone offsets may have fractional seconds."
msgstr "Смещение часового пояса может составлять доли секунды."

#: ../../library/datetime.rst:1027
msgid "The ``T`` separator may be replaced by any single unicode character."
msgstr "Разделитель ``T`` может быть заменен любым символом Юникода."

#: ../../library/datetime.rst:1028 ../../library/datetime.rst:1816
msgid "Fractional hours and minutes are not supported."
msgstr "Дробные часы и минуты не поддерживаются."

#: ../../library/datetime.rst:1037
msgid ""
">>> from datetime import datetime\n"
">>> datetime.fromisoformat('2011-11-04')\n"
"datetime.datetime(2011, 11, 4, 0, 0)\n"
">>> datetime.fromisoformat('20111104')\n"
"datetime.datetime(2011, 11, 4, 0, 0)\n"
">>> datetime.fromisoformat('2011-11-04T00:05:23')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23)\n"
">>> datetime.fromisoformat('2011-11-04T00:05:23Z')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23, tzinfo=datetime.timezone.utc)\n"
">>> datetime.fromisoformat('20111104T000523')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23)\n"
">>> datetime.fromisoformat('2011-W01-2T00:05:23.283')\n"
"datetime.datetime(2011, 1, 4, 0, 5, 23, 283000)\n"
">>> datetime.fromisoformat('2011-11-04 00:05:23.283')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23, 283000)\n"
">>> datetime.fromisoformat('2011-11-04 00:05:23.283+00:00')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23, 283000, tzinfo=datetime.timezone."
"utc)\n"
">>> datetime.fromisoformat('2011-11-04T00:05:23+04:00')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23,\n"
"    tzinfo=datetime.timezone(datetime.timedelta(seconds=14400)))"
msgstr ""
">>> from datetime import datetime\n"
">>> datetime.fromisoformat('2011-11-04')\n"
"datetime.datetime(2011, 11, 4, 0, 0)\n"
">>> datetime.fromisoformat('20111104')\n"
"datetime.datetime(2011, 11, 4, 0, 0)\n"
">>> datetime.fromisoformat('2011-11-04T00:05:23')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23)\n"
">>> datetime.fromisoformat('2011-11-04T00:05:23Z')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23, tzinfo=datetime.timezone.utc)\n"
">>> datetime.fromisoformat('20111104T000523')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23)\n"
">>> datetime.fromisoformat('2011-W01-2T00:05:23.283')\n"
"datetime.datetime(2011, 1, 4, 0, 5, 23, 283000)\n"
">>> datetime.fromisoformat('2011-11-04 00:05:23.283')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23, 283000)\n"
">>> datetime.fromisoformat('2011-11-04 00:05:23.283+00:00')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23, 283000, tzinfo=datetime.timezone."
"utc)\n"
">>> datetime.fromisoformat('2011-11-04T00:05:23+04:00')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23,\n"
"    tzinfo=datetime.timezone(datetime.timedelta(seconds=14400)))"

#: ../../library/datetime.rst:1059
msgid ""
"Previously, this method only supported formats that could be emitted by :"
"meth:`date.isoformat` or :meth:`datetime.isoformat`."
msgstr ""
"Ранее этот метод поддерживал только форматы, которые могли быть созданы с "
"помощью :meth:`date.isoformat` или :meth:`datetime.isoformat`."

#: ../../library/datetime.rst:1066
msgid ""
"Return a :class:`.datetime` corresponding to the ISO calendar date specified "
"by year, week and day. The non-date components of the datetime are populated "
"with their normal default values. This is the inverse of the function :meth:"
"`datetime.isocalendar`."
msgstr ""
"Возвращает :class:`.datetime`, соответствующий дате календаря ISO, указанной "
"годом, неделей и днем. Компоненты даты и времени, не относящиеся к дате, "
"заполняются обычными значениями по умолчанию. Это обратная функция :meth:"
"`datetime.isocalendar`."

#: ../../library/datetime.rst:1075
msgid ""
"Return a :class:`.datetime` corresponding to *date_string*, parsed according "
"to *format*."
msgstr ""
"Возвращает :class:`.datetime`, соответствующий *date_string*, анализируемый "
"в соответствии с *format*."

#: ../../library/datetime.rst:1078
msgid ""
"If *format* does not contain microseconds or time zone information, this is "
"equivalent to::"
msgstr ""
"Если *format* не содержит микросекунд или информации о часовом поясе, это "
"эквивалентно::"

#: ../../library/datetime.rst:1080 ../../library/datetime.rst:2550
msgid "datetime(*(time.strptime(date_string, format)[0:6]))"
msgstr "datetime(*(time.strptime(date_string, format)[0:6]))"

#: ../../library/datetime.rst:1082
msgid ""
":exc:`ValueError` is raised if the date_string and format can't be parsed "
"by :func:`time.strptime` or if it returns a value which isn't a time tuple.  "
"See also :ref:`strftime-strptime-behavior` and :meth:`datetime."
"fromisoformat`."
msgstr ""
":exc:`ValueError` возникает, если строка_даты и формат не могут быть "
"проанализированы с помощью :func:`time.strptime` или если она возвращает "
"значение, которое не является кортежем времени. См. также :ref:`strftime-"
"strptime-behavior` и :meth:`datetime.fromisoformat`."

#: ../../library/datetime.rst:1093
msgid ""
"The earliest representable :class:`.datetime`, ``datetime(MINYEAR, 1, 1, "
"tzinfo=None)``."
msgstr ""
"Самый ранний представимый :class:`.datetime`, ``datetime(MINYEAR, 1, 1, "
"tzinfo=None)``."

#: ../../library/datetime.rst:1099
msgid ""
"The latest representable :class:`.datetime`, ``datetime(MAXYEAR, 12, 31, 23, "
"59, 59, 999999, tzinfo=None)``."
msgstr ""
"Самый последний представимый :class:`.datetime`, ``datetime(MAXYEAR, 12, 31, "
"23, 59, 59, 999999, tzinfo=None)``."

#: ../../library/datetime.rst:1105
msgid ""
"The smallest possible difference between non-equal :class:`.datetime` "
"objects, ``timedelta(microseconds=1)``."
msgstr ""
"Наименьшая возможная разница между неравными объектами :class:`.datetime`, "
"``timedelta(microсекунды=1)``."

#: ../../library/datetime.rst:1128 ../../library/datetime.rst:1744
msgid "In ``range(24)``."
msgstr "На сайте ``range(24)``."

#: ../../library/datetime.rst:1133 ../../library/datetime.rst:1138
#: ../../library/datetime.rst:1749 ../../library/datetime.rst:1754
msgid "In ``range(60)``."
msgstr "На сайте ``range(60)``."

#: ../../library/datetime.rst:1143 ../../library/datetime.rst:1759
msgid "In ``range(1000000)``."
msgstr "На сайте ``range(1000000)``."

#: ../../library/datetime.rst:1148
msgid ""
"The object passed as the *tzinfo* argument to the :class:`.datetime` "
"constructor, or ``None`` if none was passed."
msgstr ""
"Объект передается как аргумент *tzinfo* конструктору :class:`.datetime` или "
"``None``, если ничего не было передано."

#: ../../library/datetime.rst:1154 ../../library/datetime.rst:1770
msgid ""
"In ``[0, 1]``. Used to disambiguate wall times during a repeated interval. "
"(A repeated interval occurs when clocks are rolled back at the end of "
"daylight saving time or when the UTC offset for the current zone is "
"decreased for political reasons.) The values 0 and 1 represent, "
"respectively, the earlier and later of the two moments with the same wall "
"time representation."
msgstr ""
"В ``[0, 1]``. Используется для устранения неоднозначности времени стены в "
"течение повторяющегося интервала. (Повторяющийся интервал возникает, когда "
"часы откатываются назад в конце летнего времени или когда смещение UTC для "
"текущей зоны уменьшается по политическим причинам.) Значения 0 и 1 "
"представляют соответственно более ранний и поздний из двух моментов. с тем "
"же представлением времени на стене."

#: ../../library/datetime.rst:1167
msgid "``datetime2 = datetime1 + timedelta``"
msgstr "``datetime2 = datetime1 + timedelta``"

#: ../../library/datetime.rst:1167 ../../library/datetime.rst:2380
#: ../../library/datetime.rst:2385 ../../library/datetime.rst:2397
#: ../../library/datetime.rst:2402 ../../library/datetime.rst:2462
#: ../../library/datetime.rst:2467 ../../library/datetime.rst:2471
msgid "\\(1)"
msgstr "\\(1)"

#: ../../library/datetime.rst:1169
msgid "``datetime2 = datetime1 - timedelta``"
msgstr "``datetime2 = datetime1 - timedelta``"

#: ../../library/datetime.rst:1169 ../../library/datetime.rst:2413
msgid "\\(2)"
msgstr "\\(2)"

#: ../../library/datetime.rst:1171
msgid "``timedelta = datetime1 - datetime2``"
msgstr "``timedelta = datetime1 - datetime2``"

#: ../../library/datetime.rst:0
msgid "``datetime1 == datetime2``"
msgstr "``datetime1 == datetime2``"

#: ../../library/datetime.rst:0
msgid "``datetime1 != datetime2``"
msgstr "``datetime1 != datetime2``"

#: ../../library/datetime.rst:0
msgid "``datetime1 < datetime2``"
msgstr "``datetime1 < datetime2``"

#: ../../library/datetime.rst:0
msgid "``datetime1 > datetime2``"
msgstr "``datetime1 > datetime2``"

#: ../../library/datetime.rst:0
msgid "``datetime1 <= datetime2``"
msgstr "``datetime1 <= datetime2``"

#: ../../library/datetime.rst:0
msgid "``datetime1 >= datetime2``"
msgstr "``datetime1 >= datetime2``"

#: ../../library/datetime.rst:1183
msgid ""
"``datetime2`` is a duration of ``timedelta`` removed from ``datetime1``, "
"moving forward in time if ``timedelta.days > 0``, or backward if ``timedelta."
"days < 0``. The result has the same :attr:`~.datetime.tzinfo` attribute as "
"the input datetime, and ``datetime2 - datetime1 == timedelta`` after. :exc:"
"`OverflowError` is raised if ``datetime2.year`` would be smaller than :const:"
"`MINYEAR` or larger than :const:`MAXYEAR`. Note that no time zone "
"adjustments are done even if the input is an aware object."
msgstr ""
"datetime2 — это длительность timedelta, удаленная из datetime1, "
"перемещающаяся вперед во времени, если timedelta.days > 0, или назад, если "
"timedelta.days < 0. Результат имеет тот же атрибут :attr:`~.datetime."
"tzinfo`, что и входное datetime, и ``datetime2 - datetime1 == timedelta`` "
"после. :exc:`OverflowError` возникает, если ``datetime2.year`` меньше :const:"
"`MINYEAR` или больше :const:`MAXYEAR`. Обратите внимание, что корректировка "
"часового пояса не выполняется, даже если входные данные являются "
"осведомленным объектом."

#: ../../library/datetime.rst:1192
msgid ""
"Computes the ``datetime2`` such that ``datetime2 + timedelta == datetime1``. "
"As for addition, the result has the same :attr:`~.datetime.tzinfo` attribute "
"as the input datetime, and no time zone adjustments are done even if the "
"input is aware."
msgstr ""
"Вычисляет ``datetime2`` так, что ``datetime2 + timedelta == datetime1``. Что "
"касается сложения, результат имеет тот же атрибут :attr:`~.datetime.tzinfo`, "
"что и входная дата-время, и никакие корректировки часового пояса не "
"выполняются, даже если входные данные известны."

#: ../../library/datetime.rst:1197
msgid ""
"Subtraction of a :class:`.datetime` from a :class:`.datetime` is defined "
"only if both operands are naive, or if both are aware. If one is aware and "
"the other is naive, :exc:`TypeError` is raised."
msgstr ""
"Вычитание :class:`.datetime` из :class:`.datetime` определяется только в том "
"случае, если оба операнда являются наивными или если оба операнда известны. "
"Если один знает, а другой наивен, возникает :exc:`TypeError`."

#: ../../library/datetime.rst:1201
msgid ""
"If both are naive, or both are aware and have the same :attr:`~.datetime."
"tzinfo` attribute, the :attr:`~.datetime.tzinfo` attributes are ignored, and "
"the result is a :class:`timedelta` object ``t`` such that ``datetime2 + t == "
"datetime1``. No time zone adjustments are done in this case."
msgstr ""
"Если оба неактивны или оба осведомлены и имеют один и тот же атрибут :attr:"
"`~.datetime.tzinfo`, атрибуты :attr:`~.datetime.tzinfo` игнорируются, и "
"результатом является :class:`timedelta `объект ``t`` такой, что ``datetime2 "
"+ t == datetime1``. В этом случае корректировка часового пояса не "
"производится."

#: ../../library/datetime.rst:1206
msgid ""
"If both are aware and have different :attr:`~.datetime.tzinfo` attributes, "
"``a-b`` acts as if ``a`` and ``b`` were first converted to naive UTC "
"datetimes. The result is ``(a.replace(tzinfo=None) - a.utcoffset()) - (b."
"replace(tzinfo=None) - b.utcoffset())`` except that the implementation never "
"overflows."
msgstr ""
"Если оба знают и имеют разные атрибуты :attr:`~.datetime.tzinfo`, ``ab`` "
"действует так, как если бы ``a`` и ``b`` были сначала преобразованы в "
"наивное время в формате UTC. Результатом будет ``(a.replace(tzinfo=None) - a."
"utcoffset()) - (b.replace(tzinfo=None) - b.utcoffset())``, за исключением "
"того, что реализация никогда не переполняется."

#: ../../library/datetime.rst:1212
msgid ""
":class:`.datetime` objects are equal if they represent the same date and "
"time, taking into account the time zone."
msgstr ""
"Объекты :class:`.datetime` равны, если они представляют одну и ту же дату и "
"время с учетом часового пояса."

#: ../../library/datetime.rst:1215
msgid ""
"Naive and aware :class:`!datetime` objects are never equal. :class:`!"
"datetime` objects are never equal to :class:`date` objects that are not "
"also :class:`!datetime` instances, even if they represent the same date."
msgstr ""
"Наивные и осознанные объекты :class:`!datetime` никогда не бывают равными. "
"Объекты :class:`!datetime` никогда не равны объектам :class:`date`, которые "
"не являются также экземплярами :class:`!datetime`, даже если они "
"представляют одну и ту же дату."

#: ../../library/datetime.rst:1220
msgid ""
"If both comparands are aware, and have the same :attr:`!tzinfo` attribute, "
"the :attr:`!tzinfo` and :attr:`~.datetime.fold` attributes are ignored and "
"the base datetimes are compared. If both comparands are aware and have "
"different :attr:`~.datetime.tzinfo` attributes, the comparison acts as "
"comparands were first converted to UTC datetimes except that the "
"implementation never overflows. :class:`!datetime` instances in a repeated "
"interval are never equal to :class:`!datetime` instances in other time zone."
msgstr ""
"Если оба объекта сравнения известны и имеют один и тот же атрибут :attr:`!"
"tzinfo`, атрибуты :attr:`!tzinfo` и :attr:`~.datetime.fold` игнорируются и "
"сравниваются базовые даты и время. Если оба объекта сравнения известны и "
"имеют разные атрибуты :attr:`~.datetime.tzinfo`, сравнение действует так, "
"как если бы сравниваемые значения сначала были преобразованы в дату и время "
"в формате UTC, за исключением того, что реализация никогда не переполняется. "
"Экземпляры :class:`!datetime` в повторяющемся интервале никогда не равны "
"экземплярам :class:`!datetime` в другом часовом поясе."

#: ../../library/datetime.rst:1230
msgid ""
"*datetime1* is considered less than *datetime2* when *datetime1* precedes "
"*datetime2* in time, taking into account the time zone."
msgstr ""
"*datetime1* считается меньшим, чем *datetime2*, если *datetime1* "
"предшествует *datetime2* по времени с учетом часового пояса."

#: ../../library/datetime.rst:1233
msgid ""
"Order comparison between naive and aware :class:`.datetime` objects, as well "
"as a :class:`!datetime` object and a :class:`!date` object that is not also "
"a :class:`!datetime` instance, raises :exc:`TypeError`."
msgstr ""
"Сравнение порядка между наивными и осведомленными объектами :class:`."
"datetime`, а также объектом :class:`!datetime` и объектом :class:`!date`, "
"который не является также экземпляром :class:`!datetime` , вызывает :exc:"
"`TypeError`."

#: ../../library/datetime.rst:1237
msgid ""
"If both comparands are aware, and have the same :attr:`!tzinfo` attribute, "
"the :attr:`!tzinfo` and :attr:`~.datetime.fold` attributes are ignored and "
"the base datetimes are compared. If both comparands are aware and have "
"different :attr:`~.datetime.tzinfo` attributes, the comparison acts as "
"comparands were first converted to UTC datetimes except that the "
"implementation never overflows."
msgstr ""
"Если оба объекта сравнения известны и имеют один и тот же атрибут :attr:`!"
"tzinfo`, атрибуты :attr:`!tzinfo` и :attr:`~.datetime.fold` игнорируются и "
"сравниваются базовые даты и время. Если оба объекта сравнения известны и "
"имеют разные атрибуты :attr:`~.datetime.tzinfo`, сравнение действует так, "
"как если бы сравниваемые значения сначала были преобразованы в дату и время "
"в формате UTC, за исключением того, что реализация никогда не переполняется."

#: ../../library/datetime.rst:1244
msgid ""
"Equality comparisons between aware and naive :class:`.datetime` instances "
"don't raise :exc:`TypeError`."
msgstr ""
"Сравнения на равенство между осведомленными и наивными экземплярами :class:`."
"datetime` не вызывают :exc:`TypeError`."

#: ../../library/datetime.rst:1252
msgid "Return :class:`date` object with same year, month and day."
msgstr "Верните объект :class:`date` с тем же годом, месяцем и днем."

#: ../../library/datetime.rst:1257
msgid ""
"Return :class:`.time` object with same hour, minute, second, microsecond and "
"fold. :attr:`.tzinfo` is ``None``. See also method :meth:`timetz`."
msgstr ""
"Возвращает объект :class:`.time` с тем же часом, минутой, секундой, "
"микросекундой и кратностью. :attr:`.tzinfo` имеет значение ``Нет``. См. "
"также метод :meth:`timetz`."

#: ../../library/datetime.rst:1260 ../../library/datetime.rst:1269
msgid "The fold value is copied to the returned :class:`.time` object."
msgstr "Значение сгиба копируется в возвращаемый объект :class:`.time`."

#: ../../library/datetime.rst:1266
msgid ""
"Return :class:`.time` object with same hour, minute, second, microsecond, "
"fold, and tzinfo attributes. See also method :meth:`time`."
msgstr ""
"Возвращает объект :class:`.time` с теми же атрибутами часов, минут, секунд, "
"микросекунд, сгибов и tzinfo. См. также метод :meth:`time`."

#: ../../library/datetime.rst:1277
msgid ""
"Return a new :class:`datetime` object with the same attributes, but with "
"specified parameters updated. Note that ``tzinfo=None`` can be specified to "
"create a naive datetime from an aware datetime with no conversion of date "
"and time data."
msgstr ""
"Верните новый объект :class:`datetime` с теми же атрибутами, но с указанными "
"обновленными параметрами. Обратите внимание, что ``tzinfo=None`` можно "
"указать для создания наивного datetime из осведомленного datetime без "
"преобразования данных даты и времени."

#: ../../library/datetime.rst:1288
msgid ""
"Return a :class:`.datetime` object with new :attr:`.tzinfo` attribute *tz*, "
"adjusting the date and time data so the result is the same UTC time as "
"*self*, but in *tz*'s local time."
msgstr ""
"Возвращает объект :class:`.datetime` с новым атрибутом :attr:`.tzinfo` *tz*, "
"корректируя данные даты и времени так, чтобы результатом было то же время "
"UTC, что и *self*, но в *tz* местное время."

#: ../../library/datetime.rst:1292
msgid ""
"If provided, *tz* must be an instance of a :class:`tzinfo` subclass, and "
"its :meth:`utcoffset` and :meth:`dst` methods must not return ``None``. If "
"*self* is naive, it is presumed to represent time in the system time zone."
msgstr ""
"Если указано, *tz* должен быть экземпляром подкласса :class:`tzinfo`, а его "
"методы :meth:`utcoffset` и :meth:`dst` не должны возвращать ``None``. Если "
"*self* является наивным, предполагается, что оно представляет время в "
"часовом поясе системы."

#: ../../library/datetime.rst:1296
msgid ""
"If called without arguments (or with ``tz=None``) the system local time zone "
"is assumed for the target time zone. The ``.tzinfo`` attribute of the "
"converted datetime instance will be set to an instance of :class:`timezone` "
"with the zone name and offset obtained from the OS."
msgstr ""
"При вызове без аргументов (или с ``tz=None``) в качестве целевого часового "
"пояса предполагается локальный часовой пояс системы. Атрибуту .tzinfo "
"преобразованного экземпляра datetime будет присвоен экземпляр :class:"
"`timezone` с именем зоны и смещением, полученным из ОС."

#: ../../library/datetime.rst:1301
msgid ""
"If ``self.tzinfo`` is *tz*, ``self.astimezone(tz)`` is equal to *self*:  no "
"adjustment of date or time data is performed. Else the result is local time "
"in the time zone *tz*, representing the same UTC time as *self*:  after "
"``astz = dt.astimezone(tz)``, ``astz - astz.utcoffset()`` will have the same "
"date and time data as ``dt - dt.utcoffset()``."
msgstr ""
"Если ``self.tzinfo`` имеет значение *tz*, ``self.astimezone(tz)`` равен "
"*self*: корректировка данных даты и времени не выполняется. В противном "
"случае результатом будет местное время в часовом поясе *tz*, представляющее "
"то же время UTC, что и *self*: после ``astz = dt.astimezone(tz)``, ``astz - "
"astz.utcoffset()`` будет имеют те же данные даты и времени, что и ``dt - dt."
"utcoffset()``."

#: ../../library/datetime.rst:1307
msgid ""
"If you merely want to attach a :class:`timezone` object *tz* to a datetime "
"*dt* without adjustment of date and time data, use ``dt."
"replace(tzinfo=tz)``. If you merely want to remove the :class:`!timezone` "
"object from an aware datetime *dt* without conversion of date and time data, "
"use ``dt.replace(tzinfo=None)``."
msgstr ""
"Если вы просто хотите прикрепить объект :class:`timezone` *tz* к дате и "
"времени *dt* без корректировки данных даты и времени, используйте ``dt."
"replace(tzinfo=tz)``. Если вы просто хотите удалить объект :class:`!"
"timezone` из поддерживаемого объекта datetime *dt* без преобразования данных "
"даты и времени, используйте ``dt.replace(tzinfo=None)``."

#: ../../library/datetime.rst:1312
msgid ""
"Note that the default :meth:`tzinfo.fromutc` method can be overridden in a :"
"class:`tzinfo` subclass to affect the result returned by :meth:`astimezone`. "
"Ignoring error cases, :meth:`astimezone` acts like::"
msgstr ""
"Обратите внимание, что метод по умолчанию :meth:`tzinfo.fromutc` может быть "
"переопределен в подклассе :class:`tzinfo`, чтобы повлиять на результат, "
"возвращаемый :meth:`astimezone`. Игнорируя случаи ошибок, :meth:`astimezone` "
"действует как::"

#: ../../library/datetime.rst:1316
msgid ""
"def astimezone(self, tz):\n"
"    if self.tzinfo is tz:\n"
"        return self\n"
"    # Convert self to UTC, and attach the new timezone object.\n"
"    utc = (self - self.utcoffset()).replace(tzinfo=tz)\n"
"    # Convert from UTC to tz's local time.\n"
"    return tz.fromutc(utc)"
msgstr ""
"def astimezone(self, tz):\n"
"    if self.tzinfo is tz:\n"
"        return self\n"
"    # Convert self to UTC, and attach the new timezone object.\n"
"    utc = (self - self.utcoffset()).replace(tzinfo=tz)\n"
"    # Convert from UTC to tz's local time.\n"
"    return tz.fromutc(utc)"

#: ../../library/datetime.rst:1324
msgid "*tz* now can be omitted."
msgstr "*tz* теперь можно опустить."

#: ../../library/datetime.rst:1327
msgid ""
"The :meth:`astimezone` method can now be called on naive instances that are "
"presumed to represent system local time."
msgstr ""
"Метод :meth:`astimezone` теперь можно вызывать в простых экземплярах, "
"которые предположительно представляют местное время системы."

#: ../../library/datetime.rst:1334
msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns ``self.tzinfo."
"utcoffset(self)``, and raises an exception if the latter doesn't return "
"``None`` or a :class:`timedelta` object with magnitude less than one day."
msgstr ""
"Если :attr:`.tzinfo` имеет значение None, возвращает None, else возвращает "
"self.tzinfo.utcoffset(self) и вызывает исключение, если последний не "
"возвращает `` None или объект :class:`timedelta` с магнитудой менее одного "
"дня."

#: ../../library/datetime.rst:1338 ../../library/datetime.rst:1930
#: ../../library/datetime.rst:2037 ../../library/datetime.rst:2282
#: ../../library/datetime.rst:2294 ../../library/datetime.rst:2623
msgid "The UTC offset is not restricted to a whole number of minutes."
msgstr "Смещение UTC не ограничивается целым числом минут."

#: ../../library/datetime.rst:1344
msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns ``self.tzinfo."
"dst(self)``, and raises an exception if the latter doesn't return ``None`` "
"or a :class:`timedelta` object with magnitude less than one day."
msgstr ""
"Если :attr:`.tzinfo` имеет значение None, возвращает None, else возвращает "
"self.tzinfo.dst(self) и вызывает исключение, если последний не возвращает `` "
"None или объект :class:`timedelta` с магнитудой менее одного дня."

#: ../../library/datetime.rst:1348 ../../library/datetime.rst:1940
#: ../../library/datetime.rst:2091
msgid "The DST offset is not restricted to a whole number of minutes."
msgstr "Смещение летнего времени не ограничивается целым числом минут."

#: ../../library/datetime.rst:1354
msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns ``self.tzinfo."
"tzname(self)``, raises an exception if the latter doesn't return ``None`` or "
"a string object,"
msgstr ""
"Если :attr:`.tzinfo` имеет значение ``None``, возвращает ``None``, else "
"возвращает ``self.tzinfo.tzname(self)``, вызывает исключение, если последний "
"не возвращает ``None `` или строковый объект,"

#: ../../library/datetime.rst:1365
msgid ""
"time.struct_time((d.year, d.month, d.day,\n"
"                  d.hour, d.minute, d.second,\n"
"                  d.weekday(), yday, dst))"
msgstr ""
"time.struct_time((d.year, d.month, d.day,\n"
"                  d.hour, d.minute, d.second,\n"
"                  d.weekday(), yday, dst))"

#: ../../library/datetime.rst:1369
msgid ""
"where ``yday = d.toordinal() - date(d.year, 1, 1).toordinal() + 1`` is the "
"day number within the current year starting with 1 for January 1st. The :"
"attr:`~time.struct_time.tm_isdst` flag of the result is set according to "
"the :meth:`dst` method: :attr:`.tzinfo` is ``None`` or :meth:`dst` returns "
"``None``, :attr:`!tm_isdst` is set to ``-1``; else if :meth:`dst` returns a "
"non-zero value, :attr:`!tm_isdst` is set to 1; else :attr:`!tm_isdst` is set "
"to 0."
msgstr ""
"где ``yday = d.toordinal() - date(d.year, 1, 1).toordinal() + 1`` — это "
"номер дня в текущем году, начиная с 1 для 1 января. Флаг :attr:`~time."
"struct_time.tm_isdst` результата устанавливается в соответствии с методом :"
"meth:`dst`: :attr:`.tzinfo` имеет значение ``None`` или :meth:`dst` "
"возвращает ``None``, :attr:`!tm_isdst` установлен в ``-1``; иначе, если :"
"meth:`dst` возвращает ненулевое значение, :attr:`!tm_isdst` устанавливается "
"в 1; else :attr:`!tm_isdst` имеет значение 0."

#: ../../library/datetime.rst:1380
msgid ""
"If :class:`.datetime` instance ``d`` is naive, this is the same as ``d."
"timetuple()`` except that :attr:`~.time.struct_time.tm_isdst` is forced to 0 "
"regardless of what ``d.dst()`` returns. DST is never in effect for a UTC "
"time."
msgstr ""
"Если экземпляр :class:`.datetime` ``d`` является наивным, это то же самое, "
"что ``d.timetuple()``, за исключением того, что :attr:`~.time.struct_time."
"tm_isdst` независимо от этого принудительно устанавливается в 0. того, что "
"возвращает ``d.dst()``. Летнее время никогда не действует для времени UTC."

#: ../../library/datetime.rst:1384
msgid ""
"If ``d`` is aware, ``d`` is normalized to UTC time, by subtracting ``d."
"utcoffset()``, and a :class:`time.struct_time` for the normalized time is "
"returned. :attr:`!tm_isdst` is forced to 0. Note that an :exc:"
"`OverflowError` may be raised if ``d.year`` was ``MINYEAR`` or ``MAXYEAR`` "
"and UTC adjustment spills over a year boundary."
msgstr ""
"Если ``d`` знает, ``d`` нормализуется ко времени UTC путем вычитания ``d."
"utcoffset()`` и возвращается :class:`time.struct_time` для нормализованного "
"времени. :attr:`!tm_isdst` принудительно устанавливается равным 0. Обратите "
"внимание, что :exc:`OverflowError` может возникнуть, если ``d.year`` был "
"``MINYEAR`` или ``MAXYEAR`` и корректировка UTC распространяется на граница "
"года."

#: ../../library/datetime.rst:1393
msgid ""
"Because naive ``datetime`` objects are treated by many ``datetime`` methods "
"as local times, it is preferred to use aware datetimes to represent times in "
"UTC; as a result, using :meth:`datetime.utctimetuple` may give misleading "
"results. If you have a naive ``datetime`` representing UTC, use ``datetime."
"replace(tzinfo=timezone.utc)`` to make it aware, at which point you can use :"
"meth:`.datetime.timetuple`."
msgstr ""
"Поскольку наивные объекты datetime обрабатываются многими методами datetime "
"как локальное время, для представления времени в формате UTC "
"предпочтительнее использовать осведомленные объекты datetime; в результате "
"использование :meth:`datetime.utctimetuple` может дать неверные результаты. "
"Если у вас есть наивное ``datetime``, представляющее UTC, используйте "
"``datetime.replace(tzinfo=timezone.utc)``, чтобы сообщить об этом, и в этот "
"момент вы можете использовать :meth:`.datetime.timetuple`."

#: ../../library/datetime.rst:1402
msgid ""
"Return the proleptic Gregorian ordinal of the date. The same as ``self."
"date().toordinal()``."
msgstr ""
"Возвращает упреждающий григорианский порядковый номер даты. То же, что и "
"``self.date().toordinal()``."

#: ../../library/datetime.rst:1407
msgid ""
"Return POSIX timestamp corresponding to the :class:`.datetime` instance. The "
"return value is a :class:`float` similar to that returned by :func:`time."
"time`."
msgstr ""
"Возвращает временную метку POSIX, соответствующую экземпляру :class:`."
"datetime`. Возвращаемое значение — это :class:`float`, аналогичное "
"возвращаемому :func:`time.time`."

#: ../../library/datetime.rst:1411
msgid ""
"Naive :class:`.datetime` instances are assumed to represent local time and "
"this method relies on the platform C :c:func:`mktime` function to perform "
"the conversion. Since :class:`.datetime` supports wider range of values "
"than :c:func:`mktime` on many platforms, this method may raise :exc:"
"`OverflowError` or :exc:`OSError` for times far in the past or far in the "
"future."
msgstr ""
"Предполагается, что наивные экземпляры :class:`.datetime` представляют "
"местное время, и этот метод использует функцию платформы C :c:func:`mktime` "
"для выполнения преобразования. Поскольку :class:`.datetime` поддерживает "
"более широкий диапазон значений, чем :c:func:`mktime` на многих платформах, "
"этот метод может вызывать :exc:`OverflowError` или :exc:`OSError` для "
"моментов далекого прошлого или далеко в будущем."

#: ../../library/datetime.rst:1418
msgid ""
"For aware :class:`.datetime` instances, the return value is computed as::"
msgstr ""
"Для осведомленных экземпляров :class:`.datetime` возвращаемое значение "
"вычисляется как::"

#: ../../library/datetime.rst:1421
msgid "(dt - datetime(1970, 1, 1, tzinfo=timezone.utc)).total_seconds()"
msgstr "(dt - datetime(1970, 1, 1, tzinfo=timezone.utc)).total_seconds()"

#: ../../library/datetime.rst:1425
msgid ""
"The :meth:`timestamp` method uses the :attr:`.fold` attribute to "
"disambiguate the times during a repeated interval."
msgstr ""
"Метод :meth:`timestamp` использует атрибут :attr:`.fold` для устранения "
"неоднозначности времени в течение повторяющегося интервала."

#: ../../library/datetime.rst:1431
msgid ""
"There is no method to obtain the POSIX timestamp directly from a naive :"
"class:`.datetime` instance representing UTC time. If your application uses "
"this convention and your system time zone is not set to UTC, you can obtain "
"the POSIX timestamp by supplying ``tzinfo=timezone.utc``::"
msgstr ""
"Не существует способа получить временную метку POSIX непосредственно из "
"простого экземпляра :class:`.datetime`, представляющего время UTC. Если ваше "
"приложение использует это соглашение и часовой пояс вашей системы не "
"установлен в формате UTC, вы можете получить временную метку POSIX, указав "
"``tzinfo=timezone.utc``::"

#: ../../library/datetime.rst:1437
msgid "timestamp = dt.replace(tzinfo=timezone.utc).timestamp()"
msgstr "timestamp = dt.replace(tzinfo=timezone.utc).timestamp()"

#: ../../library/datetime.rst:1439
msgid "or by calculating the timestamp directly::"
msgstr "или путем непосредственного вычисления временной метки::"

#: ../../library/datetime.rst:1441
msgid "timestamp = (dt - datetime(1970, 1, 1)) / timedelta(seconds=1)"
msgstr "timestamp = (dt - datetime(1970, 1, 1)) / timedelta(seconds=1)"

#: ../../library/datetime.rst:1445
msgid ""
"Return the day of the week as an integer, where Monday is 0 and Sunday is 6. "
"The same as ``self.date().weekday()``. See also :meth:`isoweekday`."
msgstr ""
"Возвращает день недели как целое число, где понедельник — 0, а воскресенье — "
"6. То же самое, что ``self.date().weekday()``. См. также :meth:`isoweekday`."

#: ../../library/datetime.rst:1451
msgid ""
"Return the day of the week as an integer, where Monday is 1 and Sunday is 7. "
"The same as ``self.date().isoweekday()``. See also :meth:`weekday`, :meth:"
"`isocalendar`."
msgstr ""
"Возвращает день недели как целое число, где понедельник — 1, а воскресенье — "
"7. То же, что и ``self.date().isoweekday()``. См. также :meth:`weekday`, :"
"meth:`isocalendar`."

#: ../../library/datetime.rst:1458
msgid ""
"Return a :term:`named tuple` with three components: ``year``, ``week`` and "
"``weekday``. The same as ``self.date().isocalendar()``."
msgstr ""
"Возвращает именованный кортеж с тремя компонентами: «год», «неделя» и «день "
"недели». То же, что ``self.date().isocalendar()``."

#: ../../library/datetime.rst:1464
msgid "Return a string representing the date and time in ISO 8601 format:"
msgstr "Верните строку, представляющую дату и время в формате ISO 8601:"

#: ../../library/datetime.rst:1466
msgid "``YYYY-MM-DDTHH:MM:SS.ffffff``, if :attr:`microsecond` is not 0"
msgstr "``ГГГГ-ММ-ДДТЧЧ:ММ:СС.ffffff``, если :attr:`микросекунда` не равно 0"

#: ../../library/datetime.rst:1467
msgid "``YYYY-MM-DDTHH:MM:SS``, if :attr:`microsecond` is 0"
msgstr "``ГГГГ-ММ-ДДТЧЧ:ММ:СС``, если :attr:`микросекунда` равна 0"

#: ../../library/datetime.rst:1469
msgid ""
"If :meth:`utcoffset` does not return ``None``, a string is appended, giving "
"the UTC offset:"
msgstr ""
"Если :meth:`utcoffset` не возвращает ``None``, добавляется строка, дающая "
"смещение UTC:"

#: ../../library/datetime.rst:1472
msgid ""
"``YYYY-MM-DDTHH:MM:SS.ffffff+HH:MM[:SS[.ffffff]]``, if :attr:`microsecond` "
"is not 0"
msgstr ""
"``ГГГГ-ММ-ДДТЧЧ:ММ:СС.ffffff+ЧЧ:ММ[:СС[.ffffff]]``, если :attr:"
"`микросекунда` не равно 0"

#: ../../library/datetime.rst:1474
msgid ""
"``YYYY-MM-DDTHH:MM:SS+HH:MM[:SS[.ffffff]]``,  if :attr:`microsecond` is 0"
msgstr ""
"``ГГГГ-ММ-ДДТЧЧ:ММ:СС+ЧЧ:ММ[:СС[.ffffff]]``, если :attr:`микросекунда` равна "
"0"

#: ../../library/datetime.rst:1478
msgid ""
">>> from datetime import datetime, timezone\n"
">>> datetime(2019, 5, 18, 15, 17, 8, 132263).isoformat()\n"
"'2019-05-18T15:17:08.132263'\n"
">>> datetime(2019, 5, 18, 15, 17, tzinfo=timezone.utc).isoformat()\n"
"'2019-05-18T15:17:00+00:00'"
msgstr ""
">>> from datetime import datetime, timezone\n"
">>> datetime(2019, 5, 18, 15, 17, 8, 132263).isoformat()\n"
"'2019-05-18T15:17:08.132263'\n"
">>> datetime(2019, 5, 18, 15, 17, tzinfo=timezone.utc).isoformat()\n"
"'2019-05-18T15:17:00+00:00'"

#: ../../library/datetime.rst:1484
msgid ""
"The optional argument *sep* (default ``'T'``) is a one-character separator, "
"placed between the date and time portions of the result. For example::"
msgstr ""
"Необязательный аргумент *sep* (по умолчанию ``'T'``) представляет собой "
"односимвольный разделитель, помещаемый между частями даты и времени "
"результата. Например::"

#: ../../library/datetime.rst:1487
msgid ""
">>> from datetime import tzinfo, timedelta, datetime\n"
">>> class TZ(tzinfo):\n"
"...     \"\"\"A time zone with an arbitrary, constant -06:39 offset.\"\"\"\n"
"...     def utcoffset(self, dt):\n"
"...         return timedelta(hours=-6, minutes=-39)\n"
"...\n"
">>> datetime(2002, 12, 25, tzinfo=TZ()).isoformat(' ')\n"
"'2002-12-25 00:00:00-06:39'\n"
">>> datetime(2009, 11, 27, microsecond=100, tzinfo=TZ()).isoformat()\n"
"'2009-11-27T00:00:00.000100-06:39'"
msgstr ""
">>> from datetime import tzinfo, timedelta, datetime\n"
">>> class TZ(tzinfo):\n"
"...     \"\"\"A time zone with an arbitrary, constant -06:39 offset.\"\"\"\n"
"...     def utcoffset(self, dt):\n"
"...         return timedelta(hours=-6, minutes=-39)\n"
"...\n"
">>> datetime(2002, 12, 25, tzinfo=TZ()).isoformat(' ')\n"
"'2002-12-25 00:00:00-06:39'\n"
">>> datetime(2009, 11, 27, microsecond=100, tzinfo=TZ()).isoformat()\n"
"'2009-11-27T00:00:00.000100-06:39'"

#: ../../library/datetime.rst:1498 ../../library/datetime.rst:1870
msgid ""
"The optional argument *timespec* specifies the number of additional "
"components of the time to include (the default is ``'auto'``). It can be one "
"of the following:"
msgstr ""
"Необязательный аргумент *timespec* указывает количество дополнительных "
"компонентов времени, которые необходимо включить (по умолчанию — "
"``'auto'``). Это может быть одно из следующих:"

#: ../../library/datetime.rst:1502 ../../library/datetime.rst:1874
msgid ""
"``'auto'``: Same as ``'seconds'`` if :attr:`microsecond` is 0, same as "
"``'microseconds'`` otherwise."
msgstr ""
"``'auto'``: То же, что ``'секунды'``, если :attr:`microсекунды` равно 0, то "
"же самое, что и ``'микросекунды'`` в противном случае."

#: ../../library/datetime.rst:1504 ../../library/datetime.rst:1876
msgid "``'hours'``: Include the :attr:`hour` in the two-digit ``HH`` format."
msgstr "``'hours'``: включите :attr:`hour` в двузначном формате ``ЧЧ``."

#: ../../library/datetime.rst:1505 ../../library/datetime.rst:1877
msgid ""
"``'minutes'``: Include :attr:`hour` and :attr:`minute` in ``HH:MM`` format."
msgstr ""
"``'minutes'``: включите :attr:`hour` и :attr:`hour` в формате ``ЧЧ:ММ``."

#: ../../library/datetime.rst:1506 ../../library/datetime.rst:1878
msgid ""
"``'seconds'``: Include :attr:`hour`, :attr:`minute`, and :attr:`second` in "
"``HH:MM:SS`` format."
msgstr ""
"``'seconds'``: включите :attr:`hour`, :attr:`minute` и :attr:`second` в "
"формате ``ЧЧ:ММ:СС``."

#: ../../library/datetime.rst:1508 ../../library/datetime.rst:1880
msgid ""
"``'milliseconds'``: Include full time, but truncate fractional second part "
"to milliseconds. ``HH:MM:SS.sss`` format."
msgstr ""
"``'milliseconds'``: Включить полное время, но усечь дробную часть секунды до "
"миллисекунд. ``HH:MM:SS.sss`` ."

#: ../../library/datetime.rst:1510 ../../library/datetime.rst:1882
msgid "``'microseconds'``: Include full time in ``HH:MM:SS.ffffff`` format."
msgstr ""
"``'microseconds'``: Включите полный рабочий день в ``HH:MM:SS.ffffff`` "
"форматировать ."

#: ../../library/datetime.rst:1514 ../../library/datetime.rst:1886
msgid "Excluded time components are truncated, not rounded."
msgstr "Исключенные компоненты времени усекаются, а не округляются."

#: ../../library/datetime.rst:1516
msgid ":exc:`ValueError` will be raised on an invalid *timespec* argument::"
msgstr ":exc:`ValueError` будет вызван недопустимым аргументом *timespec*::"

#: ../../library/datetime.rst:1519
msgid ""
">>> from datetime import datetime\n"
">>> datetime.now().isoformat(timespec='minutes')\n"
"'2002-12-25T00:00'\n"
">>> dt = datetime(2015, 1, 1, 12, 30, 59, 0)\n"
">>> dt.isoformat(timespec='microseconds')\n"
"'2015-01-01T12:30:59.000000'"
msgstr ""
">>> from datetime import datetime\n"
">>> datetime.now().isoformat(timespec='minutes')\n"
"'2002-12-25T00:00'\n"
">>> dt = datetime(2015, 1, 1, 12, 30, 59, 0)\n"
">>> dt.isoformat(timespec='microseconds')\n"
"'2015-01-01T12:30:59.000000'"

#: ../../library/datetime.rst:1526 ../../library/datetime.rst:1901
msgid "Added the *timespec* parameter."
msgstr "Добавлен параметр *timespec*."

#: ../../library/datetime.rst:1532
msgid ""
"For a :class:`.datetime` instance ``d``, ``str(d)`` is equivalent to ``d."
"isoformat(' ')``."
msgstr ""
"Для экземпляра :class:`.datetime` ``d`` ``str(d)`` эквивалентен ``d."
"isoformat(' ')``."

#: ../../library/datetime.rst:1538
msgid "Return a string representing the date and time::"
msgstr "Возвращает строку, представляющую дату и время::"

#: ../../library/datetime.rst:1540
msgid ""
">>> from datetime import datetime\n"
">>> datetime(2002, 12, 4, 20, 30, 40).ctime()\n"
"'Wed Dec  4 20:30:40 2002'"
msgstr ""
">>> from datetime import datetime\n"
">>> datetime(2002, 12, 4, 20, 30, 40).ctime()\n"
"'Wed Dec  4 20:30:40 2002'"

#: ../../library/datetime.rst:1544
msgid ""
"The output string will *not* include time zone information, regardless of "
"whether the input is aware or naive."
msgstr ""
"Выходная строка *не* будет включать информацию о часовом поясе, независимо "
"от того, являются ли входные данные осознанными или наивными."

#: ../../library/datetime.rst:1551
msgid ""
"on platforms where the native C :c:func:`ctime` function (which :func:`time."
"ctime` invokes, but which :meth:`datetime.ctime` does not invoke) conforms "
"to the C standard."
msgstr ""
"на платформах, где встроенная функция C :c:func:`ctime` (которая вызывается :"
"func:`time.ctime`, но не вызывается :meth:`datetime.ctime`) соответствует "
"стандарту C."

#: ../../library/datetime.rst:1558
msgid ""
"Return a string representing the date and time, controlled by an explicit "
"format string. See also :ref:`strftime-strptime-behavior` and :meth:"
"`datetime.isoformat`."
msgstr ""
"Возвращает строку, представляющую дату и время, управляемую строкой явного "
"формата. См. также :ref:`strftime-strptime-behavior` и :meth:`datetime."
"isoformat`."

#: ../../library/datetime.rst:1565
msgid ""
"Same as :meth:`.datetime.strftime`. This makes it possible to specify a "
"format string for a :class:`.datetime` object in :ref:`formatted string "
"literals <f-strings>` and when using :meth:`str.format`. See also :ref:"
"`strftime-strptime-behavior` and :meth:`datetime.isoformat`."
msgstr ""
"То же, что и :meth:`.datetime.strftime`. Это позволяет указать строку "
"формата для объекта :class:`.datetime` в :ref:`форматированных строковых "
"литералах <f-strings>` и при использовании :meth:`str.format`. См. также :"
"ref:`strftime-strptime-behavior` и :meth:`datetime.isoformat`."

#: ../../library/datetime.rst:1572
msgid "Examples of Usage: :class:`.datetime`"
msgstr "Примеры использования: :class:`.datetime`"

#: ../../library/datetime.rst:1574
msgid "Examples of working with :class:`.datetime` objects:"
msgstr "Примеры работы с объектами :class:`.datetime`:"

#: ../../library/datetime.rst:1576
msgid ""
">>> from datetime import datetime, date, time, timezone\n"
"\n"
">>> # Using datetime.combine()\n"
">>> d = date(2005, 7, 14)\n"
">>> t = time(12, 30)\n"
">>> datetime.combine(d, t)\n"
"datetime.datetime(2005, 7, 14, 12, 30)\n"
"\n"
">>> # Using datetime.now()\n"
">>> datetime.now()\n"
"datetime.datetime(2007, 12, 6, 16, 29, 43, 79043)   # GMT +1\n"
">>> datetime.now(timezone.utc)\n"
"datetime.datetime(2007, 12, 6, 15, 29, 43, 79060, tzinfo=datetime.timezone."
"utc)\n"
"\n"
">>> # Using datetime.strptime()\n"
">>> dt = datetime.strptime(\"21/11/06 16:30\", \"%d/%m/%y %H:%M\")\n"
">>> dt\n"
"datetime.datetime(2006, 11, 21, 16, 30)\n"
"\n"
">>> # Using datetime.timetuple() to get tuple of all attributes\n"
">>> tt = dt.timetuple()\n"
">>> for it in tt:\n"
"...     print(it)\n"
"...\n"
"2006    # year\n"
"11      # month\n"
"21      # day\n"
"16      # hour\n"
"30      # minute\n"
"0       # second\n"
"1       # weekday (0 = Monday)\n"
"325     # number of days since 1st January\n"
"-1      # dst - method tzinfo.dst() returned None\n"
"\n"
">>> # Date in ISO format\n"
">>> ic = dt.isocalendar()\n"
">>> for it in ic:\n"
"...     print(it)\n"
"...\n"
"2006    # ISO year\n"
"47      # ISO week\n"
"2       # ISO weekday\n"
"\n"
">>> # Formatting a datetime\n"
">>> dt.strftime(\"%A, %d. %B %Y %I:%M%p\")\n"
"'Tuesday, 21. November 2006 04:30PM'\n"
">>> 'The {1} is {0:%d}, the {2} is {0:%B}, the {3} is {0:%I:%M%p}.'."
"format(dt, \"day\", \"month\", \"time\")\n"
"'The day is 21, the month is November, the time is 04:30PM.'"
msgstr ""
">>> from datetime import datetime, date, time, timezone\n"
"\n"
">>> # Using datetime.combine()\n"
">>> d = date(2005, 7, 14)\n"
">>> t = time(12, 30)\n"
">>> datetime.combine(d, t)\n"
"datetime.datetime(2005, 7, 14, 12, 30)\n"
"\n"
">>> # Using datetime.now()\n"
">>> datetime.now()\n"
"datetime.datetime(2007, 12, 6, 16, 29, 43, 79043)   # GMT +1\n"
">>> datetime.now(timezone.utc)\n"
"datetime.datetime(2007, 12, 6, 15, 29, 43, 79060, tzinfo=datetime.timezone."
"utc)\n"
"\n"
">>> # Using datetime.strptime()\n"
">>> dt = datetime.strptime(\"21/11/06 16:30\", \"%d/%m/%y %H:%M\")\n"
">>> dt\n"
"datetime.datetime(2006, 11, 21, 16, 30)\n"
"\n"
">>> # Using datetime.timetuple() to get tuple of all attributes\n"
">>> tt = dt.timetuple()\n"
">>> for it in tt:\n"
"...     print(it)\n"
"...\n"
"2006    # year\n"
"11      # month\n"
"21      # day\n"
"16      # hour\n"
"30      # minute\n"
"0       # second\n"
"1       # weekday (0 = Monday)\n"
"325     # number of days since 1st January\n"
"-1      # dst - method tzinfo.dst() returned None\n"
"\n"
">>> # Date in ISO format\n"
">>> ic = dt.isocalendar()\n"
">>> for it in ic:\n"
"...     print(it)\n"
"...\n"
"2006    # ISO year\n"
"47      # ISO week\n"
"2       # ISO weekday\n"
"\n"
">>> # Formatting a datetime\n"
">>> dt.strftime(\"%A, %d. %B %Y %I:%M%p\")\n"
"'Tuesday, 21. November 2006 04:30PM'\n"
">>> 'The {1} is {0:%d}, the {2} is {0:%B}, the {3} is {0:%I:%M%p}.'."
"format(dt, \"day\", \"month\", \"time\")\n"
"'The day is 21, the month is November, the time is 04:30PM.'"

#: ../../library/datetime.rst:1627
msgid ""
"The example below defines a :class:`tzinfo` subclass capturing time zone "
"information for Kabul, Afghanistan, which used +4 UTC until 1945 and then "
"+4:30 UTC thereafter::"
msgstr ""
"В приведенном ниже примере определяется подкласс :class:`tzinfo`, собирающий "
"информацию о часовом поясе для Кабула, Афганистан, который использовал +4 "
"UTC до 1945 года, а затем +4:30 UTC после этого::"

#: ../../library/datetime.rst:1631
msgid ""
"from datetime import timedelta, datetime, tzinfo, timezone\n"
"\n"
"class KabulTz(tzinfo):\n"
"    # Kabul used +4 until 1945, when they moved to +4:30\n"
"    UTC_MOVE_DATE = datetime(1944, 12, 31, 20, tzinfo=timezone.utc)\n"
"\n"
"    def utcoffset(self, dt):\n"
"        if dt.year < 1945:\n"
"            return timedelta(hours=4)\n"
"        elif (1945, 1, 1, 0, 0) <= dt.timetuple()[:5] < (1945, 1, 1, 0, "
"30):\n"
"            # An ambiguous (\"imaginary\") half-hour range representing\n"
"            # a 'fold' in time due to the shift from +4 to +4:30.\n"
"            # If dt falls in the imaginary range, use fold to decide how\n"
"            # to resolve. See PEP495.\n"
"            return timedelta(hours=4, minutes=(30 if dt.fold else 0))\n"
"        else:\n"
"            return timedelta(hours=4, minutes=30)\n"
"\n"
"    def fromutc(self, dt):\n"
"        # Follow same validations as in datetime.tzinfo\n"
"        if not isinstance(dt, datetime):\n"
"            raise TypeError(\"fromutc() requires a datetime argument\")\n"
"        if dt.tzinfo is not self:\n"
"            raise ValueError(\"dt.tzinfo is not self\")\n"
"\n"
"        # A custom implementation is required for fromutc as\n"
"        # the input to this function is a datetime with utc values\n"
"        # but with a tzinfo set to self.\n"
"        # See datetime.astimezone or fromtimestamp.\n"
"        if dt.replace(tzinfo=timezone.utc) >= self.UTC_MOVE_DATE:\n"
"            return dt + timedelta(hours=4, minutes=30)\n"
"        else:\n"
"            return dt + timedelta(hours=4)\n"
"\n"
"    def dst(self, dt):\n"
"        # Kabul does not observe daylight saving time.\n"
"        return timedelta(0)\n"
"\n"
"    def tzname(self, dt):\n"
"        if dt >= self.UTC_MOVE_DATE:\n"
"            return \"+04:30\"\n"
"        return \"+04\""
msgstr ""
"from datetime import timedelta, datetime, tzinfo, timezone\n"
"\n"
"class KabulTz(tzinfo):\n"
"    # Kabul used +4 until 1945, when they moved to +4:30\n"
"    UTC_MOVE_DATE = datetime(1944, 12, 31, 20, tzinfo=timezone.utc)\n"
"\n"
"    def utcoffset(self, dt):\n"
"        if dt.year < 1945:\n"
"            return timedelta(hours=4)\n"
"        elif (1945, 1, 1, 0, 0) <= dt.timetuple()[:5] < (1945, 1, 1, 0, "
"30):\n"
"            # An ambiguous (\"imaginary\") half-hour range representing\n"
"            # a 'fold' in time due to the shift from +4 to +4:30.\n"
"            # If dt falls in the imaginary range, use fold to decide how\n"
"            # to resolve. See PEP495.\n"
"            return timedelta(hours=4, minutes=(30 if dt.fold else 0))\n"
"        else:\n"
"            return timedelta(hours=4, minutes=30)\n"
"\n"
"    def fromutc(self, dt):\n"
"        # Follow same validations as in datetime.tzinfo\n"
"        if not isinstance(dt, datetime):\n"
"            raise TypeError(\"fromutc() requires a datetime argument\")\n"
"        if dt.tzinfo is not self:\n"
"            raise ValueError(\"dt.tzinfo is not self\")\n"
"\n"
"        # A custom implementation is required for fromutc as\n"
"        # the input to this function is a datetime with utc values\n"
"        # but with a tzinfo set to self.\n"
"        # See datetime.astimezone or fromtimestamp.\n"
"        if dt.replace(tzinfo=timezone.utc) >= self.UTC_MOVE_DATE:\n"
"            return dt + timedelta(hours=4, minutes=30)\n"
"        else:\n"
"            return dt + timedelta(hours=4)\n"
"\n"
"    def dst(self, dt):\n"
"        # Kabul does not observe daylight saving time.\n"
"        return timedelta(0)\n"
"\n"
"    def tzname(self, dt):\n"
"        if dt >= self.UTC_MOVE_DATE:\n"
"            return \"+04:30\"\n"
"        return \"+04\""

#: ../../library/datetime.rst:1674
msgid "Usage of ``KabulTz`` from above::"
msgstr "Использование ``KabulTz`` сверху::"

#: ../../library/datetime.rst:1676
msgid ""
">>> tz1 = KabulTz()\n"
"\n"
">>> # Datetime before the change\n"
">>> dt1 = datetime(1900, 11, 21, 16, 30, tzinfo=tz1)\n"
">>> print(dt1.utcoffset())\n"
"4:00:00\n"
"\n"
">>> # Datetime after the change\n"
">>> dt2 = datetime(2006, 6, 14, 13, 0, tzinfo=tz1)\n"
">>> print(dt2.utcoffset())\n"
"4:30:00\n"
"\n"
">>> # Convert datetime to another time zone\n"
">>> dt3 = dt2.astimezone(timezone.utc)\n"
">>> dt3\n"
"datetime.datetime(2006, 6, 14, 8, 30, tzinfo=datetime.timezone.utc)\n"
">>> dt2\n"
"datetime.datetime(2006, 6, 14, 13, 0, tzinfo=KabulTz())\n"
">>> dt2 == dt3\n"
"True"
msgstr ""
">>> tz1 = KabulTz()\n"
"\n"
">>> # Datetime before the change\n"
">>> dt1 = datetime(1900, 11, 21, 16, 30, tzinfo=tz1)\n"
">>> print(dt1.utcoffset())\n"
"4:00:00\n"
"\n"
">>> # Datetime after the change\n"
">>> dt2 = datetime(2006, 6, 14, 13, 0, tzinfo=tz1)\n"
">>> print(dt2.utcoffset())\n"
"4:30:00\n"
"\n"
">>> # Convert datetime to another time zone\n"
">>> dt3 = dt2.astimezone(timezone.utc)\n"
">>> dt3\n"
"datetime.datetime(2006, 6, 14, 8, 30, tzinfo=datetime.timezone.utc)\n"
">>> dt2\n"
"datetime.datetime(2006, 6, 14, 13, 0, tzinfo=KabulTz())\n"
">>> dt2 == dt3\n"
"True"

#: ../../library/datetime.rst:1700
msgid ":class:`.time` Objects"
msgstr "Объекты :class:`.time`"

#: ../../library/datetime.rst:1702
msgid ""
"A :class:`.time` object represents a (local) time of day, independent of any "
"particular day, and subject to adjustment via a :class:`tzinfo` object."
msgstr ""
"Объект :class:`.time` представляет (локальное) время суток, независимое от "
"какого-либо конкретного дня и подлежащее настройке с помощью объекта :class:"
"`tzinfo`."

#: ../../library/datetime.rst:1707
msgid ""
"All arguments are optional. *tzinfo* may be ``None``, or an instance of a :"
"class:`tzinfo` subclass. The remaining arguments must be integers in the "
"following ranges:"
msgstr ""
"Все аргументы являются необязательными. *tzinfo* может иметь значение None "
"или быть экземпляром подкласса :class:`tzinfo`. Остальные аргументы должны "
"быть целыми числами в следующих диапазонах:"

#: ../../library/datetime.rst:1717
msgid ""
"If an argument outside those ranges is given, :exc:`ValueError` is raised. "
"All default to 0 except *tzinfo*, which defaults to ``None``."
msgstr ""
"Если указан аргумент за пределами этих диапазонов, возникает :exc:"
"`ValueError`. Все значения по умолчанию равны 0, кроме *tzinfo*, для "
"которого по умолчанию установлено значение «Нет»."

#: ../../library/datetime.rst:1725
msgid "The earliest representable :class:`.time`, ``time(0, 0, 0, 0)``."
msgstr "Самый ранний представимый :class:`.time`, ``time(0, 0, 0, 0)``."

#: ../../library/datetime.rst:1730
msgid "The latest representable :class:`.time`, ``time(23, 59, 59, 999999)``."
msgstr "Последний представимый :class:`.time`, ``time(23, 59, 59, 999999)``."

#: ../../library/datetime.rst:1735
msgid ""
"The smallest possible difference between non-equal :class:`.time` objects, "
"``timedelta(microseconds=1)``, although note that arithmetic on :class:`."
"time` objects is not supported."
msgstr ""
"Наименьшая возможная разница между неравными объектами :class:`.time`, "
"``timedelta(microсекунды=1)``, хотя обратите внимание, что арифметика на "
"объектах :class:`.time` не поддерживается."

#: ../../library/datetime.rst:1764
msgid ""
"The object passed as the tzinfo argument to the :class:`.time` constructor, "
"or ``None`` if none was passed."
msgstr ""
"Объект передается в качестве аргумента tzinfo конструктору :class:`.time` "
"или ``None``, если ничего не было передано."

#: ../../library/datetime.rst:1778
msgid ""
":class:`.time` objects support equality and order comparisons, where ``a`` "
"is considered less than ``b`` when ``a`` precedes ``b`` in time."
msgstr ""
"Объекты :class:`.time` поддерживают сравнение на равенство и порядок, где "
"``a`` считается меньшим, чем ``b``, когда ``a`` предшествует ``b`` по "
"времени."

#: ../../library/datetime.rst:1781
msgid ""
"Naive and aware :class:`!time` objects are never equal. Order comparison "
"between naive and aware :class:`!time` objects raises :exc:`TypeError`."
msgstr ""
"Объекты :class:`.time` поддерживают сравнение на равенство и порядок, где "
"*a* считается меньшим, чем *b*, когда *a* предшествует *b* по времени."

#: ../../library/datetime.rst:1785
msgid ""
"If both comparands are aware, and have the same :attr:`~.time.tzinfo` "
"attribute, the :attr:`!tzinfo` and :attr:`!fold` attributes are ignored and "
"the base times are compared. If both comparands are aware and have "
"different :attr:`!tzinfo` attributes, the comparands are first adjusted by "
"subtracting their UTC offsets (obtained from ``self.utcoffset()``)."
msgstr ""
"Если оба объекта сравнения известны и имеют одинаковый атрибут :attr:`~.time."
"tzinfo`, атрибуты :attr:`!tzinfo` и :attr:`!fold` игнорируются и "
"сравниваются базовые времена. Если оба объекта сравнения известны и имеют "
"разные атрибуты :attr:`!tzinfo`, сравниваемые значения сначала "
"корректируются путем вычитания их смещений UTC (полученных из ``self."
"utcoffset()``)."

#: ../../library/datetime.rst:1791
msgid ""
"Equality comparisons between aware and naive :class:`.time` instances don't "
"raise :exc:`TypeError`."
msgstr ""
"Сравнения на равенство между осведомленными и наивными экземплярами :class:`."
"time` не вызывают :exc:`TypeError`."

#: ../../library/datetime.rst:1795
msgid ""
"In Boolean contexts, a :class:`.time` object is always considered to be true."
msgstr ""
"В логическом контексте объект :class:`.time` всегда считается истинным."

#: ../../library/datetime.rst:1797
msgid ""
"Before Python 3.5, a :class:`.time` object was considered to be false if it "
"represented midnight in UTC. This behavior was considered obscure and error-"
"prone and has been removed in Python 3.5. See :issue:`13936` for full "
"details."
msgstr ""
"До Python 3.5 объект :class:`.time` считался ложным, если он представлял "
"полночь в формате UTC. Такое поведение считалось непонятным и подверженным "
"ошибкам, и оно было удалено в Python 3.5. Подробности смотрите в :issue:"
"`13936`."

#: ../../library/datetime.rst:1804
msgid "Other constructor:"
msgstr "Другой конструктор:"

#: ../../library/datetime.rst:1808
msgid ""
"Return a :class:`.time` corresponding to a *time_string* in any valid ISO "
"8601 format, with the following exceptions:"
msgstr ""
"Возвращает :class:`.time`, соответствующий *time_string* в любом допустимом "
"формате ISO 8601, за следующими исключениями:"

#: ../../library/datetime.rst:1812
msgid ""
"The leading ``T``, normally required in cases where there may be ambiguity "
"between a date and a time, is not required."
msgstr ""
"Ведущий ``T``, обычно требуемый в случаях, когда между датой и временем "
"может возникнуть неоднозначность, не требуется."

#: ../../library/datetime.rst:1814
msgid ""
"Fractional seconds may have any number of digits (anything beyond 6 will be "
"truncated)."
msgstr ""
"Дробные секунды могут иметь любое количество цифр (все, что больше 6, будет "
"усечено)."

#: ../../library/datetime.rst:1818
msgid "Examples:"
msgstr "Примеры:"

#: ../../library/datetime.rst:1820
msgid ""
">>> from datetime import time\n"
">>> time.fromisoformat('04:23:01')\n"
"datetime.time(4, 23, 1)\n"
">>> time.fromisoformat('T04:23:01')\n"
"datetime.time(4, 23, 1)\n"
">>> time.fromisoformat('T042301')\n"
"datetime.time(4, 23, 1)\n"
">>> time.fromisoformat('04:23:01.000384')\n"
"datetime.time(4, 23, 1, 384)\n"
">>> time.fromisoformat('04:23:01,000384')\n"
"datetime.time(4, 23, 1, 384)\n"
">>> time.fromisoformat('04:23:01+04:00')\n"
"datetime.time(4, 23, 1, tzinfo=datetime.timezone(datetime."
"timedelta(seconds=14400)))\n"
">>> time.fromisoformat('04:23:01Z')\n"
"datetime.time(4, 23, 1, tzinfo=datetime.timezone.utc)\n"
">>> time.fromisoformat('04:23:01+00:00')\n"
"datetime.time(4, 23, 1, tzinfo=datetime.timezone.utc)"
msgstr ""
">>> from datetime import time\n"
">>> time.fromisoformat('04:23:01')\n"
"datetime.time(4, 23, 1)\n"
">>> time.fromisoformat('T04:23:01')\n"
"datetime.time(4, 23, 1)\n"
">>> time.fromisoformat('T042301')\n"
"datetime.time(4, 23, 1)\n"
">>> time.fromisoformat('04:23:01.000384')\n"
"datetime.time(4, 23, 1, 384)\n"
">>> time.fromisoformat('04:23:01,000384')\n"
"datetime.time(4, 23, 1, 384)\n"
">>> time.fromisoformat('04:23:01+04:00')\n"
"datetime.time(4, 23, 1, tzinfo=datetime.timezone(datetime."
"timedelta(seconds=14400)))\n"
">>> time.fromisoformat('04:23:01Z')\n"
"datetime.time(4, 23, 1, tzinfo=datetime.timezone.utc)\n"
">>> time.fromisoformat('04:23:01+00:00')\n"
"datetime.time(4, 23, 1, tzinfo=datetime.timezone.utc)"

#: ../../library/datetime.rst:1842
msgid ""
"Previously, this method only supported formats that could be emitted by :"
"meth:`time.isoformat`."
msgstr ""
"Раньше этот метод поддерживал только форматы, которые могли быть созданы с "
"помощью :meth:`time.isoformat`."

#: ../../library/datetime.rst:1852
msgid ""
"Return a new :class:`.time` with the same values, but with specified "
"parameters updated. Note that ``tzinfo=None`` can be specified to create a "
"naive :class:`.time` from an aware :class:`.time`, without conversion of the "
"time data."
msgstr ""
"Верните новый :class:`.time` с теми же значениями, но с указанными "
"обновленными параметрами. Обратите внимание, что ``tzinfo=None`` можно "
"указать для создания наивного :class:`.time` из осведомленного :class:`."
"time`, без преобразования данных времени."

#: ../../library/datetime.rst:1863
msgid "Return a string representing the time in ISO 8601 format, one of:"
msgstr "Возвращает строку, представляющую время в формате ISO 8601, один из:"

#: ../../library/datetime.rst:1865
msgid "``HH:MM:SS.ffffff``, if :attr:`microsecond` is not 0"
msgstr "``HH:MM:SS.ffffff``, если :attr:`microsecond` не равен 0"

#: ../../library/datetime.rst:1866
msgid "``HH:MM:SS``, if :attr:`microsecond` is 0"
msgstr "``HH:MM:SS``, если :attr:`microsecond` равен 0"

#: ../../library/datetime.rst:1867
msgid ""
"``HH:MM:SS.ffffff+HH:MM[:SS[.ffffff]]``, if :meth:`utcoffset` does not "
"return ``None``"
msgstr ""
"``HH:MM:SS.ffffff+HH:MM[:SS[.ffffff]]``, если :meth:`utcoffset` не "
"возвращает ``None``"

#: ../../library/datetime.rst:1868
msgid ""
"``HH:MM:SS+HH:MM[:SS[.ffffff]]``, if :attr:`microsecond` is 0 and :meth:"
"`utcoffset` does not return ``None``"
msgstr ""
"``HH:MM:SS+HH:MM[:SS[.ffffff]]``, если :attr:`microsecond` равно 0, а :meth:"
"`utcoffset` не возвращает ``None``"

#: ../../library/datetime.rst:1888
msgid ":exc:`ValueError` will be raised on an invalid *timespec* argument."
msgstr ":exc:`ValueError` будет вызван недопустимым аргументом *timespec*."

#: ../../library/datetime.rst:1892
msgid ""
">>> from datetime import time\n"
">>> time(hour=12, minute=34, second=56, microsecond=123456)."
"isoformat(timespec='minutes')\n"
"'12:34'\n"
">>> dt = time(hour=12, minute=34, second=56, microsecond=0)\n"
">>> dt.isoformat(timespec='microseconds')\n"
"'12:34:56.000000'\n"
">>> dt.isoformat(timespec='auto')\n"
"'12:34:56'"
msgstr ""
">>> from datetime import time\n"
">>> time(hour=12, minute=34, second=56, microsecond=123456)."
"isoformat(timespec='minutes')\n"
"'12:34'\n"
">>> dt = time(hour=12, minute=34, second=56, microsecond=0)\n"
">>> dt.isoformat(timespec='microseconds')\n"
"'12:34:56.000000'\n"
">>> dt.isoformat(timespec='auto')\n"
"'12:34:56'"

#: ../../library/datetime.rst:1907
msgid "For a time ``t``, ``str(t)`` is equivalent to ``t.isoformat()``."
msgstr ""
"В течение некоторого времени ``t`` ``str(t)`` эквивалентен ``t.isoformat()``."

#: ../../library/datetime.rst:1912
msgid ""
"Return a string representing the time, controlled by an explicit format "
"string.  See also :ref:`strftime-strptime-behavior` and :meth:`time."
"isoformat`."
msgstr ""
"Возвращает строку, представляющую время, управляемую строкой явного формата. "
"См. также :ref:`strftime-strptime-behavior` и :meth:`time.isoformat`."

#: ../../library/datetime.rst:1918
msgid ""
"Same as :meth:`.time.strftime`. This makes it possible to specify a format "
"string for a :class:`.time` object in :ref:`formatted string literals <f-"
"strings>` and when using :meth:`str.format`. See also :ref:`strftime-"
"strptime-behavior` and :meth:`time.isoformat`."
msgstr ""
"То же, что и :meth:`.time.strftime`. Это позволяет указать строку формата "
"для объекта :class:`.time` в :ref:`форматированных строковых литералах <f-"
"strings>` и при использовании :meth:`str.format`. См. также :ref:`strftime-"
"strptime-behavior` и :meth:`time.isoformat`."

#: ../../library/datetime.rst:1926
msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns ``self.tzinfo."
"utcoffset(None)``, and raises an exception if the latter doesn't return "
"``None`` or a :class:`timedelta` object with magnitude less than one day."
msgstr ""
"Если :attr:`.tzinfo` имеет значение None, возвращает None, else возвращает "
"self.tzinfo.utcoffset(None) и вызывает исключение, если последний не "
"возвращает `` None или объект :class:`timedelta` с магнитудой менее одного "
"дня."

#: ../../library/datetime.rst:1936
msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns ``self.tzinfo."
"dst(None)``, and raises an exception if the latter doesn't return ``None``, "
"or a :class:`timedelta` object with magnitude less than one day."
msgstr ""
"Если :attr:`.tzinfo` имеет значение None, возвращает None, else возвращает "
"self.tzinfo.dst(None) и вызывает исключение, если последний не возвращает `` "
"None`` или объект :class:`timedelta` с магнитудой менее одного дня."

#: ../../library/datetime.rst:1945
msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns ``self.tzinfo."
"tzname(None)``, or raises an exception if the latter doesn't return ``None`` "
"or a string object."
msgstr ""
"Если :attr:`.tzinfo` имеет значение None, возвращает None, else возвращает "
"self.tzinfo.tzname(None) или вызывает исключение, если последний не "
"возвращает `` None`` или строковый объект."

#: ../../library/datetime.rst:1950
msgid "Examples of Usage: :class:`.time`"
msgstr "Примеры использования: :class:`.time`"

#: ../../library/datetime.rst:1952
msgid "Examples of working with a :class:`.time` object::"
msgstr "Примеры работы с объектом :class:`.time`::"

#: ../../library/datetime.rst:1954
msgid ""
">>> from datetime import time, tzinfo, timedelta\n"
">>> class TZ1(tzinfo):\n"
"...     def utcoffset(self, dt):\n"
"...         return timedelta(hours=1)\n"
"...     def dst(self, dt):\n"
"...         return timedelta(0)\n"
"...     def tzname(self,dt):\n"
"...         return \"+01:00\"\n"
"...     def  __repr__(self):\n"
"...         return f\"{self.__class__.__name__}()\"\n"
"...\n"
">>> t = time(12, 10, 30, tzinfo=TZ1())\n"
">>> t\n"
"datetime.time(12, 10, 30, tzinfo=TZ1())\n"
">>> t.isoformat()\n"
"'12:10:30+01:00'\n"
">>> t.dst()\n"
"datetime.timedelta(0)\n"
">>> t.tzname()\n"
"'+01:00'\n"
">>> t.strftime(\"%H:%M:%S %Z\")\n"
"'12:10:30 +01:00'\n"
">>> 'The {} is {:%H:%M}.'.format(\"time\", t)\n"
"'The time is 12:10.'"
msgstr ""
">>> from datetime import time, tzinfo, timedelta\n"
">>> class TZ1(tzinfo):\n"
"...     def utcoffset(self, dt):\n"
"...         return timedelta(hours=1)\n"
"...     def dst(self, dt):\n"
"...         return timedelta(0)\n"
"...     def tzname(self,dt):\n"
"...         return \"+01:00\"\n"
"...     def  __repr__(self):\n"
"...         return f\"{self.__class__.__name__}()\"\n"
"...\n"
">>> t = time(12, 10, 30, tzinfo=TZ1())\n"
">>> t\n"
"datetime.time(12, 10, 30, tzinfo=TZ1())\n"
">>> t.isoformat()\n"
"'12:10:30+01:00'\n"
">>> t.dst()\n"
"datetime.timedelta(0)\n"
">>> t.tzname()\n"
"'+01:00'\n"
">>> t.strftime(\"%H:%M:%S %Z\")\n"
"'12:10:30 +01:00'\n"
">>> 'The {} is {:%H:%M}.'.format(\"time\", t)\n"
"'The time is 12:10.'"

#: ../../library/datetime.rst:1983
msgid ":class:`tzinfo` Objects"
msgstr "Объекты :class:`tzinfo`"

#: ../../library/datetime.rst:1987
msgid ""
"This is an abstract base class, meaning that this class should not be "
"instantiated directly.  Define a subclass of :class:`tzinfo` to capture "
"information about a particular time zone."
msgstr ""
"Это абстрактный базовый класс, а это означает, что экземпляр этого класса не "
"должен создаваться напрямую. Определите подкласс :class:`tzinfo` для сбора "
"информации об определенном часовом поясе."

#: ../../library/datetime.rst:1991
msgid ""
"An instance of (a concrete subclass of) :class:`tzinfo` can be passed to the "
"constructors for :class:`.datetime` and :class:`.time` objects. The latter "
"objects view their attributes as being in local time, and the :class:"
"`tzinfo` object supports methods revealing offset of local time from UTC, "
"the name of the time zone, and DST offset, all relative to a date or time "
"object passed to them."
msgstr ""
"Экземпляр (конкретного подкласса) :class:`tzinfo` может быть передан "
"конструкторам для объектов :class:`.datetime` и :class:`.time`. Последние "
"объекты рассматривают свои атрибуты как относящиеся к местному времени, а "
"объект :class:`tzinfo` поддерживает методы, показывающие смещение местного "
"времени от UTC, названия часового пояса и смещения летнего времени, все "
"относительно объекта даты или времени. перешел к ним."

#: ../../library/datetime.rst:1997
msgid ""
"You need to derive a concrete subclass, and (at least) supply "
"implementations of the standard :class:`tzinfo` methods needed by the :class:"
"`.datetime` methods you use. The :mod:`!datetime` module provides :class:"
"`timezone`, a simple concrete subclass of :class:`tzinfo` which can "
"represent time zones with fixed offset from UTC such as UTC itself or North "
"American EST and EDT."
msgstr ""
"Вам необходимо создать конкретный подкласс и (по крайней мере) предоставить "
"реализации стандартных методов :class:`tzinfo`, необходимых для используемых "
"вами методов :class:`.datetime`. Модуль :mod:`!datetime` предоставляет :"
"class:`timezone`, простой конкретный подкласс :class:`tzinfo`, который может "
"представлять часовые пояса с фиксированным смещением от UTC, такие как само "
"UTC или североамериканское EST и EDT."

#: ../../library/datetime.rst:2004
msgid ""
"Special requirement for pickling:  A :class:`tzinfo` subclass must have an :"
"meth:`~object.__init__` method that can be called with no arguments, "
"otherwise it can be pickled but possibly not unpickled again. This is a "
"technical requirement that may be relaxed in the future."
msgstr ""
"Особое требование для травления: подкласс :class:`tzinfo` должен иметь "
"метод :meth:`~object.__init__`, который можно вызывать без аргументов, в "
"противном случае его можно будет марилировать, но, возможно, не "
"расконсервировать снова. Это техническое требование, которое в будущем может "
"быть смягчено."

#: ../../library/datetime.rst:2010
msgid ""
"A concrete subclass of :class:`tzinfo` may need to implement the following "
"methods. Exactly which methods are needed depends on the uses made of aware :"
"mod:`!datetime` objects. If in doubt, simply implement all of them."
msgstr ""
"Конкретному подклассу :class:`tzinfo` может потребоваться реализация "
"следующих методов. Какие именно методы необходимы, зависит от использования "
"известных объектов :mod:`!datetime`. Если сомневаетесь, просто реализуйте их "
"все."

#: ../../library/datetime.rst:2017
msgid ""
"Return offset of local time from UTC, as a :class:`timedelta` object that is "
"positive east of UTC. If local time is west of UTC, this should be negative."
msgstr ""
"Возвращает смещение местного времени от UTC в виде объекта :class:"
"`timedelta`, положительного к востоку от UTC. Если местное время находится к "
"западу от UTC, оно должно быть отрицательным."

#: ../../library/datetime.rst:2020
msgid ""
"This represents the *total* offset from UTC; for example, if a :class:"
"`tzinfo` object represents both time zone and DST adjustments, :meth:"
"`utcoffset` should return their sum. If the UTC offset isn't known, return "
"``None``. Else the value returned must be a :class:`timedelta` object "
"strictly between ``-timedelta(hours=24)`` and ``timedelta(hours=24)`` (the "
"magnitude of the offset must be less than one day). Most implementations of :"
"meth:`utcoffset` will probably look like one of these two::"
msgstr ""
"Это представляет собой *общее* смещение от UTC; например, если объект :class:"
"`tzinfo` представляет как часовой пояс, так и настройки летнего времени, :"
"meth:`utcoffset` должен вернуть их сумму. Если смещение UTC неизвестно, "
"верните None. В противном случае возвращаемое значение должно быть объектом :"
"class:`timedelta` строго между ``-timedelta(hours=24)`` и "
"``timedelta(hours=24)`` (величина смещения должна быть меньше одного "
"дня). ). Большинство реализаций :meth:`utcoffset`, вероятно, будут выглядеть "
"как одна из этих двух::"

#: ../../library/datetime.rst:2028
msgid ""
"return CONSTANT                 # fixed-offset class\n"
"return CONSTANT + self.dst(dt)  # daylight-aware class"
msgstr ""
"вернуть CONSTANT # класс с фиксированным смещением return CONSTANT + self."
"dst(dt) # класс, учитывающий дневной свет"

#: ../../library/datetime.rst:2031
msgid ""
"If :meth:`utcoffset` does not return ``None``, :meth:`dst` should not return "
"``None`` either."
msgstr ""
"Если :meth:`utcoffset` не возвращает ``None``, :meth:`dst` также не должен "
"возвращать ``None``."

#: ../../library/datetime.rst:2034
msgid ""
"The default implementation of :meth:`utcoffset` raises :exc:"
"`NotImplementedError`."
msgstr ""
"Реализация :meth:`utcoffset` по умолчанию вызывает :exc:"
"`NotImplementedError`."

#: ../../library/datetime.rst:2043
msgid ""
"Return the daylight saving time (DST) adjustment, as a :class:`timedelta` "
"object or ``None`` if DST information isn't known."
msgstr ""
"Возвращает настройку летнего времени (DST) в виде объекта timedelta или "
"None, если информация о летнем времени неизвестна."

#: ../../library/datetime.rst:2047
msgid ""
"Return ``timedelta(0)`` if DST is not in effect. If DST is in effect, return "
"the offset as a :class:`timedelta` object (see :meth:`utcoffset` for "
"details). Note that DST offset, if applicable, has already been added to the "
"UTC offset returned by :meth:`utcoffset`, so there's no need to consult :"
"meth:`dst` unless you're interested in obtaining DST info separately. For "
"example, :meth:`datetime.timetuple` calls its :attr:`~.datetime.tzinfo` "
"attribute's :meth:`dst` method to determine how the :attr:`~time.struct_time."
"tm_isdst` flag should be set, and :meth:`tzinfo.fromutc` calls :meth:`dst` "
"to account for DST changes when crossing time zones."
msgstr ""
"Верните ``timedelta(0)``, если летнее время не действует. Если действует "
"летнее время, верните смещение как объект :class:`timedelta` (подробности "
"см. в :meth:`utcoffset`). Обратите внимание, что смещение летнего времени, "
"если оно применимо, уже добавлено к смещению UTC, возвращаемому :meth:"
"`utcoffset`, поэтому нет необходимости обращаться к :meth:`dst`, если вы не "
"заинтересованы в получении информации о летнем времени отдельно. Например, :"
"meth:`datetime.timetuple` вызывает метод :meth:`dst` своего атрибута :attr:"
"`~.datetime.tzinfo`, чтобы определить, как должен быть установлен флаг :attr:"
"`~time.struct_time.tm_isdst`. и :meth:`tzinfo.fromutc` вызывает :meth:`dst` "
"для учета изменений летнего времени при пересечении часовых поясов."

#: ../../library/datetime.rst:2057
msgid ""
"An instance *tz* of a :class:`tzinfo` subclass that models both standard and "
"daylight times must be consistent in this sense:"
msgstr ""
"Экземпляр *tz* подкласса :class:`tzinfo`, который моделирует как "
"стандартное, так и летнее время, должен быть согласованным в этом смысле:"

#: ../../library/datetime.rst:2060
msgid "``tz.utcoffset(dt) - tz.dst(dt)``"
msgstr "``tz.utcoffset(dt) - tz.dst(dt)``"

#: ../../library/datetime.rst:2062
msgid ""
"must return the same result for every :class:`.datetime` *dt* with ``dt."
"tzinfo == tz``. For sane :class:`tzinfo` subclasses, this expression yields "
"the time zone's \"standard offset\", which should not depend on the date or "
"the time, but only on geographic location. The implementation of :meth:"
"`datetime.astimezone` relies on this, but cannot detect violations; it's the "
"programmer's responsibility to ensure it. If a :class:`tzinfo` subclass "
"cannot guarantee this, it may be able to override the default implementation "
"of :meth:`tzinfo.fromutc` to work correctly with :meth:`~.datetime."
"astimezone` regardless."
msgstr ""
"должен возвращать один и тот же результат для каждого :class:`.datetime` "
"*dt* с ``dt.tzinfo == tz``. Для нормальных подклассов :class:`tzinfo` это "
"выражение дает «стандартное смещение» часового пояса, которое не должно "
"зависеть от даты или времени, а только от географического местоположения. "
"Реализация :meth:`datetime.astimezone` полагается на это, но не может "
"обнаружить нарушения; ответственность за это лежит на программисте. Если "
"подкласс :class:`tzinfo` не может этого гарантировать, он может "
"переопределить реализацию :meth:`tzinfo.fromutc` по умолчанию для корректной "
"работы с :meth:`~.datetime.astimezone` независимо от этого."

#: ../../library/datetime.rst:2071
msgid ""
"Most implementations of :meth:`dst` will probably look like one of these "
"two::"
msgstr ""
"Большинство реализаций :meth:`dst`, вероятно, будут выглядеть как одна из "
"этих двух::"

#: ../../library/datetime.rst:2073
msgid ""
"def dst(self, dt):\n"
"    # a fixed-offset class:  doesn't account for DST\n"
"    return timedelta(0)"
msgstr ""
"def dst(self, dt):\n"
"    # a fixed-offset class:  doesn't account for DST\n"
"    return timedelta(0)"

#: ../../library/datetime.rst:2077
msgid "or::"
msgstr "или::"

#: ../../library/datetime.rst:2079
msgid ""
"def dst(self, dt):\n"
"    # Code to set dston and dstoff to the time zone's DST\n"
"    # transition times based on the input dt.year, and expressed\n"
"    # in standard local time.\n"
"\n"
"    if dston <= dt.replace(tzinfo=None) < dstoff:\n"
"        return timedelta(hours=1)\n"
"    else:\n"
"        return timedelta(0)"
msgstr ""
"def dst(self, dt):\n"
"    # Code to set dston and dstoff to the time zone's DST\n"
"    # transition times based on the input dt.year, and expressed\n"
"    # in standard local time.\n"
"\n"
"    if dston <= dt.replace(tzinfo=None) < dstoff:\n"
"        return timedelta(hours=1)\n"
"    else:\n"
"        return timedelta(0)"

#: ../../library/datetime.rst:2089
msgid ""
"The default implementation of :meth:`dst` raises :exc:`NotImplementedError`."
msgstr ""
"Реализация :meth:`dst` по умолчанию вызывает :exc:`NotImplementedError`."

#: ../../library/datetime.rst:2097
msgid ""
"Return the time zone name corresponding to the :class:`.datetime` object "
"*dt*, as a string. Nothing about string names is defined by the :mod:`!"
"datetime` module, and there's no requirement that it mean anything in "
"particular. For example, ``\"GMT\"``, ``\"UTC\"``, ``\"-500\"``, "
"``\"-5:00\"``, ``\"EDT\"``, ``\"US/Eastern\"``, ``\"America/New York\"`` are "
"all valid replies. Return ``None`` if a string name isn't known. Note that "
"this is a method rather than a fixed string primarily because some :class:"
"`tzinfo` subclasses will wish to return different names depending on the "
"specific value of *dt* passed, especially if the :class:`tzinfo` class is "
"accounting for daylight time."
msgstr ""
"Возвращает имя часового пояса, соответствующее объекту :class:`.datetime` "
"*dt*, в виде строки. Модуль :mod:`!datetime` ничего не определяет в именах "
"строк, и нет никаких требований, чтобы они значили что-то конкретное. "
"Например, ``\"GMT\"``, ``\"UTC\"``, ``\"-500\"``, ``\"-5:00\"``, "
"``\"EDT\"``, ``\" «США/Восточная Европа», «Америка/Нью-Йорк» — все это "
"действительные ответы. Верните None, если имя строки неизвестно. Обратите "
"внимание, что это метод, а не фиксированная строка, главным образом потому, "
"что некоторые подклассы :class:`tzinfo` захотят возвращать разные имена в "
"зависимости от конкретного переданного значения *dt*, особенно если класс :"
"class:`tzinfo` является бухгалтерским. для дневного времени."

#: ../../library/datetime.rst:2107
msgid ""
"The default implementation of :meth:`tzname` raises :exc:"
"`NotImplementedError`."
msgstr ""
"Реализация :meth:`tzname` по умолчанию вызывает :exc:`NotImplementedError`."

#: ../../library/datetime.rst:2110
msgid ""
"These methods are called by a :class:`.datetime` or :class:`.time` object, "
"in response to their methods of the same names. A :class:`.datetime` object "
"passes itself as the argument, and a :class:`.time` object passes ``None`` "
"as the argument. A :class:`tzinfo` subclass's methods should therefore be "
"prepared to accept a *dt* argument of ``None``, or of class :class:`."
"datetime`."
msgstr ""
"Эти методы вызываются объектом :class:`.datetime` или :class:`.time` в ответ "
"на их одноименные методы. Объект :class:`.datetime` передает себя в качестве "
"аргумента, а объект :class:`.time` передает в качестве аргумента ``None``. "
"Поэтому методы подкласса :class:`tzinfo` должны быть готовы принять аргумент "
"*dt* со значением ``None`` или класса :class:`.datetime`."

#: ../../library/datetime.rst:2116
msgid ""
"When ``None`` is passed, it's up to the class designer to decide the best "
"response. For example, returning ``None`` is appropriate if the class wishes "
"to say that time objects don't participate in the :class:`tzinfo` protocols. "
"It may be more useful for ``utcoffset(None)`` to return the standard UTC "
"offset, as there is no other convention for discovering the standard offset."
msgstr ""
"Когда передается None, разработчик класса должен выбрать лучший ответ. "
"Например, возврат None подходит, если класс желает сообщить, что объекты "
"времени не участвуют в протоколах :class:`tzinfo`. Может быть более полезно, "
"чтобы utcoffset(None) возвращал стандартное смещение UTC, поскольку не "
"существует другого соглашения для обнаружения стандартного смещения."

#: ../../library/datetime.rst:2122
msgid ""
"When a :class:`.datetime` object is passed in response to a :class:`."
"datetime` method, ``dt.tzinfo`` is the same object as *self*. :class:"
"`tzinfo` methods can rely on this, unless user code calls :class:`tzinfo` "
"methods directly. The intent is that the :class:`tzinfo` methods interpret "
"*dt* as being in local time, and not need worry about objects in other time "
"zones."
msgstr ""
"Когда объект :class:`.datetime` передается в ответ на метод :class:`."
"datetime`, ``dt.tzinfo`` является тем же объектом, что и *self*. На это "
"могут полагаться методы :class:`tzinfo`, если пользовательский код не "
"вызывает методы :class:`tzinfo` напрямую. Цель состоит в том, чтобы методы :"
"class:`tzinfo` интерпретировали *dt* как местное время и не беспокоились об "
"объектах в других часовых поясах."

#: ../../library/datetime.rst:2128
msgid ""
"There is one more :class:`tzinfo` method that a subclass may wish to "
"override:"
msgstr ""
"Существует еще один метод :class:`tzinfo`, который подкласс может "
"переопределить:"

#: ../../library/datetime.rst:2133
msgid ""
"This is called from the default :meth:`datetime.astimezone` implementation. "
"When called from that, ``dt.tzinfo`` is *self*, and *dt*'s date and time "
"data are to be viewed as expressing a UTC time. The purpose of :meth:"
"`fromutc` is to adjust the date and time data, returning an equivalent "
"datetime in *self*'s local time."
msgstr ""
"Это вызывается из реализации :meth:`datetime.astimezone` по умолчанию. При "
"вызове из него ``dt.tzinfo`` является *self*, а данные даты и времени *dt* "
"следует рассматривать как выражение времени UTC. Целью :meth:`fromutc` "
"является корректировка данных даты и времени, возвращая эквивалентное "
"значение даты и времени в локальном времени *self*."

#: ../../library/datetime.rst:2139
msgid ""
"Most :class:`tzinfo` subclasses should be able to inherit the default :meth:"
"`fromutc` implementation without problems. It's strong enough to handle "
"fixed-offset time zones, and time zones accounting for both standard and "
"daylight time, and the latter even if the DST transition times differ in "
"different years. An example of a time zone the default :meth:`fromutc` "
"implementation may not handle correctly in all cases is one where the "
"standard offset (from UTC) depends on the specific date and time passed, "
"which can happen for political reasons. The default implementations of :meth:"
"`~.datetime.astimezone` and :meth:`fromutc` may not produce the result you "
"want if the result is one of the hours straddling the moment the standard "
"offset changes."
msgstr ""
"Большинство подклассов :class:`tzinfo` должны иметь возможность без проблем "
"наследовать реализацию :meth:`fromutc` по умолчанию. Он достаточно силен, "
"чтобы обрабатывать часовые пояса с фиксированным смещением, а также часовые "
"пояса, учитывающие как стандартное, так и летнее время, причем последнее, "
"даже если время перехода на летнее время различается в разные годы. Примером "
"часового пояса, который реализация :meth:`fromutc` по умолчанию может "
"обрабатывать неправильно во всех случаях, является тот, где стандартное "
"смещение (от UTC) зависит от конкретной переданной даты и времени, что может "
"произойти по политическим причинам. Реализации по умолчанию :meth:`~."
"datetime.astimezone` и :meth:`fromutc` могут не дать желаемого результата, "
"если результат является одним из часов, находящихся между моментом изменения "
"стандартного смещения."

#: ../../library/datetime.rst:2150
msgid ""
"Skipping code for error cases, the default :meth:`fromutc` implementation "
"acts like::"
msgstr ""
"Пропуская код в случае ошибок, реализация :meth:`fromutc` по умолчанию "
"действует следующим образом::"

#: ../../library/datetime.rst:2153
msgid ""
"def fromutc(self, dt):\n"
"    # raise ValueError error if dt.tzinfo is not self\n"
"    dtoff = dt.utcoffset()\n"
"    dtdst = dt.dst()\n"
"    # raise ValueError if dtoff is None or dtdst is None\n"
"    delta = dtoff - dtdst  # this is self's standard offset\n"
"    if delta:\n"
"        dt += delta   # convert to standard local time\n"
"        dtdst = dt.dst()\n"
"        # raise ValueError if dtdst is None\n"
"    if dtdst:\n"
"        return dt + dtdst\n"
"    else:\n"
"        return dt"
msgstr ""
"def fromutc(self, dt):\n"
"    # raise ValueError error if dt.tzinfo is not self\n"
"    dtoff = dt.utcoffset()\n"
"    dtdst = dt.dst()\n"
"    # raise ValueError if dtoff is None or dtdst is None\n"
"    delta = dtoff - dtdst  # this is self's standard offset\n"
"    if delta:\n"
"        dt += delta   # convert to standard local time\n"
"        dtdst = dt.dst()\n"
"        # raise ValueError if dtdst is None\n"
"    if dtdst:\n"
"        return dt + dtdst\n"
"    else:\n"
"        return dt"

#: ../../library/datetime.rst:2168
msgid ""
"In the following :download:`tzinfo_examples.py <../includes/tzinfo_examples."
"py>` file there are some examples of :class:`tzinfo` classes:"
msgstr ""
"В следующем файле :download:`tzinfo_examples.py <../includes/tzinfo_examples."
"py>` приведены несколько примеров классов :class:`tzinfo`:"

#: ../../library/datetime.rst:2172
msgid ""
"from datetime import tzinfo, timedelta, datetime\n"
"\n"
"ZERO = timedelta(0)\n"
"HOUR = timedelta(hours=1)\n"
"SECOND = timedelta(seconds=1)\n"
"\n"
"# A class capturing the platform's idea of local time.\n"
"# (May result in wrong values on historical times in\n"
"#  timezones where UTC offset and/or the DST rules had\n"
"#  changed in the past.)\n"
"import time as _time\n"
"\n"
"STDOFFSET = timedelta(seconds = -_time.timezone)\n"
"if _time.daylight:\n"
"    DSTOFFSET = timedelta(seconds = -_time.altzone)\n"
"else:\n"
"    DSTOFFSET = STDOFFSET\n"
"\n"
"DSTDIFF = DSTOFFSET - STDOFFSET\n"
"\n"
"class LocalTimezone(tzinfo):\n"
"\n"
"    def fromutc(self, dt):\n"
"        assert dt.tzinfo is self\n"
"        stamp = (dt - datetime(1970, 1, 1, tzinfo=self)) // SECOND\n"
"        args = _time.localtime(stamp)[:6]\n"
"        dst_diff = DSTDIFF // SECOND\n"
"        # Detect fold\n"
"        fold = (args == _time.localtime(stamp - dst_diff))\n"
"        return datetime(*args, microsecond=dt.microsecond,\n"
"                        tzinfo=self, fold=fold)\n"
"\n"
"    def utcoffset(self, dt):\n"
"        if self._isdst(dt):\n"
"            return DSTOFFSET\n"
"        else:\n"
"            return STDOFFSET\n"
"\n"
"    def dst(self, dt):\n"
"        if self._isdst(dt):\n"
"            return DSTDIFF\n"
"        else:\n"
"            return ZERO\n"
"\n"
"    def tzname(self, dt):\n"
"        return _time.tzname[self._isdst(dt)]\n"
"\n"
"    def _isdst(self, dt):\n"
"        tt = (dt.year, dt.month, dt.day,\n"
"              dt.hour, dt.minute, dt.second,\n"
"              dt.weekday(), 0, 0)\n"
"        stamp = _time.mktime(tt)\n"
"        tt = _time.localtime(stamp)\n"
"        return tt.tm_isdst > 0\n"
"\n"
"Local = LocalTimezone()\n"
"\n"
"\n"
"# A complete implementation of current DST rules for major US time zones.\n"
"\n"
"def first_sunday_on_or_after(dt):\n"
"    days_to_go = 6 - dt.weekday()\n"
"    if days_to_go:\n"
"        dt += timedelta(days_to_go)\n"
"    return dt\n"
"\n"
"\n"
"# US DST Rules\n"
"#\n"
"# This is a simplified (i.e., wrong for a few cases) set of rules for US\n"
"# DST start and end times. For a complete and up-to-date set of DST rules\n"
"# and timezone definitions, visit the Olson Database (or try pytz):\n"
"# http://www.twinsun.com/tz/tz-link.htm\n"
"# https://sourceforge.net/projects/pytz/ (might not be up-to-date)\n"
"#\n"
"# In the US, since 2007, DST starts at 2am (standard time) on the second\n"
"# Sunday in March, which is the first Sunday on or after Mar 8.\n"
"DSTSTART_2007 = datetime(1, 3, 8, 2)\n"
"# and ends at 2am (DST time) on the first Sunday of Nov.\n"
"DSTEND_2007 = datetime(1, 11, 1, 2)\n"
"# From 1987 to 2006, DST used to start at 2am (standard time) on the first\n"
"# Sunday in April and to end at 2am (DST time) on the last\n"
"# Sunday of October, which is the first Sunday on or after Oct 25.\n"
"DSTSTART_1987_2006 = datetime(1, 4, 1, 2)\n"
"DSTEND_1987_2006 = datetime(1, 10, 25, 2)\n"
"# From 1967 to 1986, DST used to start at 2am (standard time) on the last\n"
"# Sunday in April (the one on or after April 24) and to end at 2am (DST "
"time)\n"
"# on the last Sunday of October, which is the first Sunday\n"
"# on or after Oct 25.\n"
"DSTSTART_1967_1986 = datetime(1, 4, 24, 2)\n"
"DSTEND_1967_1986 = DSTEND_1987_2006\n"
"\n"
"def us_dst_range(year):\n"
"    # Find start and end times for US DST. For years before 1967, return\n"
"    # start = end for no DST.\n"
"    if 2006 < year:\n"
"        dststart, dstend = DSTSTART_2007, DSTEND_2007\n"
"    elif 1986 < year < 2007:\n"
"        dststart, dstend = DSTSTART_1987_2006, DSTEND_1987_2006\n"
"    elif 1966 < year < 1987:\n"
"        dststart, dstend = DSTSTART_1967_1986, DSTEND_1967_1986\n"
"    else:\n"
"        return (datetime(year, 1, 1), ) * 2\n"
"\n"
"    start = first_sunday_on_or_after(dststart.replace(year=year))\n"
"    end = first_sunday_on_or_after(dstend.replace(year=year))\n"
"    return start, end\n"
"\n"
"\n"
"class USTimeZone(tzinfo):\n"
"\n"
"    def __init__(self, hours, reprname, stdname, dstname):\n"
"        self.stdoffset = timedelta(hours=hours)\n"
"        self.reprname = reprname\n"
"        self.stdname = stdname\n"
"        self.dstname = dstname\n"
"\n"
"    def __repr__(self):\n"
"        return self.reprname\n"
"\n"
"    def tzname(self, dt):\n"
"        if self.dst(dt):\n"
"            return self.dstname\n"
"        else:\n"
"            return self.stdname\n"
"\n"
"    def utcoffset(self, dt):\n"
"        return self.stdoffset + self.dst(dt)\n"
"\n"
"    def dst(self, dt):\n"
"        if dt is None or dt.tzinfo is None:\n"
"            # An exception may be sensible here, in one or both cases.\n"
"            # It depends on how you want to treat them.  The default\n"
"            # fromutc() implementation (called by the default astimezone()\n"
"            # implementation) passes a datetime with dt.tzinfo is self.\n"
"            return ZERO\n"
"        assert dt.tzinfo is self\n"
"        start, end = us_dst_range(dt.year)\n"
"        # Can't compare naive to aware objects, so strip the timezone from\n"
"        # dt first.\n"
"        dt = dt.replace(tzinfo=None)\n"
"        if start + HOUR <= dt < end - HOUR:\n"
"            # DST is in effect.\n"
"            return HOUR\n"
"        if end - HOUR <= dt < end:\n"
"            # Fold (an ambiguous hour): use dt.fold to disambiguate.\n"
"            return ZERO if dt.fold else HOUR\n"
"        if start <= dt < start + HOUR:\n"
"            # Gap (a non-existent hour): reverse the fold rule.\n"
"            return HOUR if dt.fold else ZERO\n"
"        # DST is off.\n"
"        return ZERO\n"
"\n"
"    def fromutc(self, dt):\n"
"        assert dt.tzinfo is self\n"
"        start, end = us_dst_range(dt.year)\n"
"        start = start.replace(tzinfo=self)\n"
"        end = end.replace(tzinfo=self)\n"
"        std_time = dt + self.stdoffset\n"
"        dst_time = std_time + HOUR\n"
"        if end <= dst_time < end + HOUR:\n"
"            # Repeated hour\n"
"            return std_time.replace(fold=1)\n"
"        if std_time < start or dst_time >= end:\n"
"            # Standard time\n"
"            return std_time\n"
"        if start <= std_time < end - HOUR:\n"
"            # Daylight saving time\n"
"            return dst_time\n"
"\n"
"\n"
"Eastern  = USTimeZone(-5, \"Eastern\",  \"EST\", \"EDT\")\n"
"Central  = USTimeZone(-6, \"Central\",  \"CST\", \"CDT\")\n"
"Mountain = USTimeZone(-7, \"Mountain\", \"MST\", \"MDT\")\n"
"Pacific  = USTimeZone(-8, \"Pacific\",  \"PST\", \"PDT\")\n"
msgstr ""
"from datetime import tzinfo, timedelta, datetime\n"
"\n"
"ZERO = timedelta(0)\n"
"HOUR = timedelta(hours=1)\n"
"SECOND = timedelta(seconds=1)\n"
"\n"
"# A class capturing the platform's idea of local time.\n"
"# (May result in wrong values on historical times in\n"
"#  timezones where UTC offset and/or the DST rules had\n"
"#  changed in the past.)\n"
"import time as _time\n"
"\n"
"STDOFFSET = timedelta(seconds = -_time.timezone)\n"
"if _time.daylight:\n"
"    DSTOFFSET = timedelta(seconds = -_time.altzone)\n"
"else:\n"
"    DSTOFFSET = STDOFFSET\n"
"\n"
"DSTDIFF = DSTOFFSET - STDOFFSET\n"
"\n"
"class LocalTimezone(tzinfo):\n"
"\n"
"    def fromutc(self, dt):\n"
"        assert dt.tzinfo is self\n"
"        stamp = (dt - datetime(1970, 1, 1, tzinfo=self)) // SECOND\n"
"        args = _time.localtime(stamp)[:6]\n"
"        dst_diff = DSTDIFF // SECOND\n"
"        # Detect fold\n"
"        fold = (args == _time.localtime(stamp - dst_diff))\n"
"        return datetime(*args, microsecond=dt.microsecond,\n"
"                        tzinfo=self, fold=fold)\n"
"\n"
"    def utcoffset(self, dt):\n"
"        if self._isdst(dt):\n"
"            return DSTOFFSET\n"
"        else:\n"
"            return STDOFFSET\n"
"\n"
"    def dst(self, dt):\n"
"        if self._isdst(dt):\n"
"            return DSTDIFF\n"
"        else:\n"
"            return ZERO\n"
"\n"
"    def tzname(self, dt):\n"
"        return _time.tzname[self._isdst(dt)]\n"
"\n"
"    def _isdst(self, dt):\n"
"        tt = (dt.year, dt.month, dt.day,\n"
"              dt.hour, dt.minute, dt.second,\n"
"              dt.weekday(), 0, 0)\n"
"        stamp = _time.mktime(tt)\n"
"        tt = _time.localtime(stamp)\n"
"        return tt.tm_isdst > 0\n"
"\n"
"Local = LocalTimezone()\n"
"\n"
"\n"
"# A complete implementation of current DST rules for major US time zones.\n"
"\n"
"def first_sunday_on_or_after(dt):\n"
"    days_to_go = 6 - dt.weekday()\n"
"    if days_to_go:\n"
"        dt += timedelta(days_to_go)\n"
"    return dt\n"
"\n"
"\n"
"# US DST Rules\n"
"#\n"
"# This is a simplified (i.e., wrong for a few cases) set of rules for US\n"
"# DST start and end times. For a complete and up-to-date set of DST rules\n"
"# and timezone definitions, visit the Olson Database (or try pytz):\n"
"# http://www.twinsun.com/tz/tz-link.htm\n"
"# https://sourceforge.net/projects/pytz/ (might not be up-to-date)\n"
"#\n"
"# In the US, since 2007, DST starts at 2am (standard time) on the second\n"
"# Sunday in March, which is the first Sunday on or after Mar 8.\n"
"DSTSTART_2007 = datetime(1, 3, 8, 2)\n"
"# and ends at 2am (DST time) on the first Sunday of Nov.\n"
"DSTEND_2007 = datetime(1, 11, 1, 2)\n"
"# From 1987 to 2006, DST used to start at 2am (standard time) on the first\n"
"# Sunday in April and to end at 2am (DST time) on the last\n"
"# Sunday of October, which is the first Sunday on or after Oct 25.\n"
"DSTSTART_1987_2006 = datetime(1, 4, 1, 2)\n"
"DSTEND_1987_2006 = datetime(1, 10, 25, 2)\n"
"# From 1967 to 1986, DST used to start at 2am (standard time) on the last\n"
"# Sunday in April (the one on or after April 24) and to end at 2am (DST "
"time)\n"
"# on the last Sunday of October, which is the first Sunday\n"
"# on or after Oct 25.\n"
"DSTSTART_1967_1986 = datetime(1, 4, 24, 2)\n"
"DSTEND_1967_1986 = DSTEND_1987_2006\n"
"\n"
"def us_dst_range(year):\n"
"    # Find start and end times for US DST. For years before 1967, return\n"
"    # start = end for no DST.\n"
"    if 2006 < year:\n"
"        dststart, dstend = DSTSTART_2007, DSTEND_2007\n"
"    elif 1986 < year < 2007:\n"
"        dststart, dstend = DSTSTART_1987_2006, DSTEND_1987_2006\n"
"    elif 1966 < year < 1987:\n"
"        dststart, dstend = DSTSTART_1967_1986, DSTEND_1967_1986\n"
"    else:\n"
"        return (datetime(year, 1, 1), ) * 2\n"
"\n"
"    start = first_sunday_on_or_after(dststart.replace(year=year))\n"
"    end = first_sunday_on_or_after(dstend.replace(year=year))\n"
"    return start, end\n"
"\n"
"\n"
"class USTimeZone(tzinfo):\n"
"\n"
"    def __init__(self, hours, reprname, stdname, dstname):\n"
"        self.stdoffset = timedelta(hours=hours)\n"
"        self.reprname = reprname\n"
"        self.stdname = stdname\n"
"        self.dstname = dstname\n"
"\n"
"    def __repr__(self):\n"
"        return self.reprname\n"
"\n"
"    def tzname(self, dt):\n"
"        if self.dst(dt):\n"
"            return self.dstname\n"
"        else:\n"
"            return self.stdname\n"
"\n"
"    def utcoffset(self, dt):\n"
"        return self.stdoffset + self.dst(dt)\n"
"\n"
"    def dst(self, dt):\n"
"        if dt is None or dt.tzinfo is None:\n"
"            # An exception may be sensible here, in one or both cases.\n"
"            # It depends on how you want to treat them.  The default\n"
"            # fromutc() implementation (called by the default astimezone()\n"
"            # implementation) passes a datetime with dt.tzinfo is self.\n"
"            return ZERO\n"
"        assert dt.tzinfo is self\n"
"        start, end = us_dst_range(dt.year)\n"
"        # Can't compare naive to aware objects, so strip the timezone from\n"
"        # dt first.\n"
"        dt = dt.replace(tzinfo=None)\n"
"        if start + HOUR <= dt < end - HOUR:\n"
"            # DST is in effect.\n"
"            return HOUR\n"
"        if end - HOUR <= dt < end:\n"
"            # Fold (an ambiguous hour): use dt.fold to disambiguate.\n"
"            return ZERO if dt.fold else HOUR\n"
"        if start <= dt < start + HOUR:\n"
"            # Gap (a non-existent hour): reverse the fold rule.\n"
"            return HOUR if dt.fold else ZERO\n"
"        # DST is off.\n"
"        return ZERO\n"
"\n"
"    def fromutc(self, dt):\n"
"        assert dt.tzinfo is self\n"
"        start, end = us_dst_range(dt.year)\n"
"        start = start.replace(tzinfo=self)\n"
"        end = end.replace(tzinfo=self)\n"
"        std_time = dt + self.stdoffset\n"
"        dst_time = std_time + HOUR\n"
"        if end <= dst_time < end + HOUR:\n"
"            # Repeated hour\n"
"            return std_time.replace(fold=1)\n"
"        if std_time < start or dst_time >= end:\n"
"            # Standard time\n"
"            return std_time\n"
"        if start <= std_time < end - HOUR:\n"
"            # Daylight saving time\n"
"            return dst_time\n"
"\n"
"\n"
"Eastern  = USTimeZone(-5, \"Eastern\",  \"EST\", \"EDT\")\n"
"Central  = USTimeZone(-6, \"Central\",  \"CST\", \"CDT\")\n"
"Mountain = USTimeZone(-7, \"Mountain\", \"MST\", \"MDT\")\n"
"Pacific  = USTimeZone(-8, \"Pacific\",  \"PST\", \"PDT\")\n"

#: ../../library/datetime.rst:2174
msgid ""
"Note that there are unavoidable subtleties twice per year in a :class:"
"`tzinfo` subclass accounting for both standard and daylight time, at the DST "
"transition points. For concreteness, consider US Eastern (UTC -0500), where "
"EDT begins the minute after 1:59 (EST) on the second Sunday in March, and "
"ends the minute after 1:59 (EDT) on the first Sunday in November::"
msgstr ""
"Обратите внимание, что дважды в год в подклассе :class:`tzinfo` возникают "
"неизбежные тонкости, учитывающие как стандартное, так и летнее время, в "
"точках перехода на летнее время. Для конкретики рассмотрим восточную часть "
"США (UTC -0500), где EDT начинается на минуте после 1:59 (EST) во второе "
"воскресенье марта и заканчивается на минуте после 1:59 (EDT) в первое "
"воскресенье ноября:"

#: ../../library/datetime.rst:2180
msgid ""
"  UTC   3:MM  4:MM  5:MM  6:MM  7:MM  8:MM\n"
"  EST  22:MM 23:MM  0:MM  1:MM  2:MM  3:MM\n"
"  EDT  23:MM  0:MM  1:MM  2:MM  3:MM  4:MM\n"
"\n"
"start  22:MM 23:MM  0:MM  1:MM  3:MM  4:MM\n"
"\n"
"  end  23:MM  0:MM  1:MM  1:MM  2:MM  3:MM"
msgstr ""
"  UTC   3:MM  4:MM  5:MM  6:MM  7:MM  8:MM\n"
"  EST  22:MM 23:MM  0:MM  1:MM  2:MM  3:MM\n"
"  EDT  23:MM  0:MM  1:MM  2:MM  3:MM  4:MM\n"
"\n"
"start  22:MM 23:MM  0:MM  1:MM  3:MM  4:MM\n"
"\n"
"  end  23:MM  0:MM  1:MM  1:MM  2:MM  3:MM"

#: ../../library/datetime.rst:2188
msgid ""
"When DST starts (the \"start\" line), the local wall clock leaps from 1:59 "
"to 3:00. A wall time of the form 2:MM doesn't really make sense on that day, "
"so ``astimezone(Eastern)`` won't deliver a result with ``hour == 2`` on the "
"day DST begins. For example, at the Spring forward transition of 2016, we "
"get::"
msgstr ""
"Когда начинается летнее время (линия «старт»), местные настенные часы "
"переходят с 1:59 на 3:00. Настенное время в форме 2:MM на самом деле не "
"имеет смысла в этот день, поэтому astimezone(eastern)`` не выдаст результат "
"с ``hour == 2`` в день начала летнего времени. Например, при переходе Spring "
"вперед 2016 года мы получаем:"

#: ../../library/datetime.rst:2193
msgid ""
">>> from datetime import datetime, timezone\n"
">>> from tzinfo_examples import HOUR, Eastern\n"
">>> u0 = datetime(2016, 3, 13, 5, tzinfo=timezone.utc)\n"
">>> for i in range(4):\n"
"...     u = u0 + i*HOUR\n"
"...     t = u.astimezone(Eastern)\n"
"...     print(u.time(), 'UTC =', t.time(), t.tzname())\n"
"...\n"
"05:00:00 UTC = 00:00:00 EST\n"
"06:00:00 UTC = 01:00:00 EST\n"
"07:00:00 UTC = 03:00:00 EDT\n"
"08:00:00 UTC = 04:00:00 EDT"
msgstr ""
">>> from datetime import datetime, timezone\n"
">>> from tzinfo_examples import HOUR, Eastern\n"
">>> u0 = datetime(2016, 3, 13, 5, tzinfo=timezone.utc)\n"
">>> for i in range(4):\n"
"...     u = u0 + i*HOUR\n"
"...     t = u.astimezone(Eastern)\n"
"...     print(u.time(), 'UTC =', t.time(), t.tzname())\n"
"...\n"
"05:00:00 UTC = 00:00:00 EST\n"
"06:00:00 UTC = 01:00:00 EST\n"
"07:00:00 UTC = 03:00:00 EDT\n"
"08:00:00 UTC = 04:00:00 EDT"

#: ../../library/datetime.rst:2207
msgid ""
"When DST ends (the \"end\" line), there's a potentially worse problem: "
"there's an hour that can't be spelled unambiguously in local wall time: the "
"last hour of daylight time. In Eastern, that's times of the form 5:MM UTC on "
"the day daylight time ends. The local wall clock leaps from 1:59 (daylight "
"time) back to 1:00 (standard time) again. Local times of the form 1:MM are "
"ambiguous. :meth:`~.datetime.astimezone` mimics the local clock's behavior "
"by mapping two adjacent UTC hours into the same local hour then. In the "
"Eastern example, UTC times of the form 5:MM and 6:MM both map to 1:MM when "
"converted to Eastern, but earlier times have the :attr:`~.datetime.fold` "
"attribute set to 0 and the later times have it set to 1. For example, at the "
"Fall back transition of 2016, we get::"
msgstr ""
"Когда заканчивается летнее время («конечная» строка), возникает потенциально "
"более серьезная проблема: есть час, который нельзя однозначно записать в "
"местном настенном времени: последний час дневного времени. На восточном "
"языке это время в формате 5:MM UTC в день окончания летнего времени. Местные "
"настенные часы снова переходят с 1:59 (дневное время) на 1:00 (стандартное "
"время). Местное время в форме 1:MM неоднозначно. :meth:`~.datetime."
"astimezone` имитирует поведение локальных часов, сопоставляя два соседних "
"часа UTC с одним и тем же местным часом. В восточном примере время UTC в "
"форме 5:MM и 6:MM отображается в 1:MM при преобразовании в восточное время, "
"но более раннее время имеет атрибут :attr:`~.datetime.fold`, установленный в "
"0, а более позднее время. раз оно установлено равным 1. Например, при "
"переходе на возврат в 2016 году мы получаем:"

#: ../../library/datetime.rst:2218
msgid ""
">>> u0 = datetime(2016, 11, 6, 4, tzinfo=timezone.utc)\n"
">>> for i in range(4):\n"
"...     u = u0 + i*HOUR\n"
"...     t = u.astimezone(Eastern)\n"
"...     print(u.time(), 'UTC =', t.time(), t.tzname(), t.fold)\n"
"...\n"
"04:00:00 UTC = 00:00:00 EDT 0\n"
"05:00:00 UTC = 01:00:00 EDT 0\n"
"06:00:00 UTC = 01:00:00 EST 1\n"
"07:00:00 UTC = 02:00:00 EST 0"
msgstr ""
">>> u0 = datetime(2016, 11, 6, 4, tzinfo=timezone.utc)\n"
">>> for i in range(4):\n"
"...     u = u0 + i*HOUR\n"
"...     t = u.astimezone(Eastern)\n"
"...     print(u.time(), 'UTC =', t.time(), t.tzname(), t.fold)\n"
"...\n"
"04:00:00 UTC = 00:00:00 EDT 0\n"
"05:00:00 UTC = 01:00:00 EDT 0\n"
"06:00:00 UTC = 01:00:00 EST 1\n"
"07:00:00 UTC = 02:00:00 EST 0"

#: ../../library/datetime.rst:2229
msgid ""
"Note that the :class:`.datetime` instances that differ only by the value of "
"the :attr:`~.datetime.fold` attribute are considered equal in comparisons."
msgstr ""
"Обратите внимание, что экземпляры :class:`.datetime`, которые отличаются "
"только значением атрибута :attr:`~.datetime.fold`, считаются равными при "
"сравнении."

#: ../../library/datetime.rst:2232
msgid ""
"Applications that can't bear wall-time ambiguities should explicitly check "
"the value of the :attr:`~.datetime.fold` attribute or avoid using hybrid :"
"class:`tzinfo` subclasses; there are no ambiguities when using :class:"
"`timezone`, or any other fixed-offset :class:`tzinfo` subclass (such as a "
"class representing only EST (fixed offset -5 hours), or only EDT (fixed "
"offset -4 hours))."
msgstr ""
"Приложения, которые не допускают неоднозначности времени стены, должны явно "
"проверять значение атрибута :attr:`~.datetime.fold` или избегать "
"использования гибридных подклассов :class:`tzinfo`; нет никакой "
"двусмысленности при использовании :class:`timezone` или любого другого "
"подкласса :class:`tzinfo` с фиксированным смещением (например, класса, "
"представляющего только EST (фиксированное смещение -5 часов) или только EDT "
"(фиксированное смещение -4) часы))."

#: ../../library/datetime.rst:2240
msgid ":mod:`zoneinfo`"
msgstr ":mod:`zoneinfo`"

#: ../../library/datetime.rst:2241
msgid ""
"The :mod:`!datetime` module has a basic :class:`timezone` class (for "
"handling arbitrary fixed offsets from UTC) and its :attr:`timezone.utc` "
"attribute (a UTC :class:`!timezone` instance)."
msgstr ""
"Модуль :mod:`!datetime` имеет базовый класс :class:`timezone` (для обработки "
"произвольных фиксированных смещений от UTC) и его атрибут :attr:`timezone."
"utc` (экземпляр UTC :class:`!timezone` )."

#: ../../library/datetime.rst:2245
msgid ""
"``zoneinfo`` brings the *IANA time zone database* (also known as the Olson "
"database) to Python, and its usage is recommended."
msgstr ""
"``zoneinfo`` переносит *базу данных часовых поясов IANA* (также известную "
"как база данных Олсона) на Python, и ее использование рекомендуется."

#: ../../library/datetime.rst:2248
msgid "`IANA time zone database <https://www.iana.org/time-zones>`_"
msgstr "`База данных часовых поясов IANA <https://www.iana.org/time-zones>`_"

#: ../../library/datetime.rst:2249
msgid ""
"The Time Zone Database (often called tz, tzdata or zoneinfo) contains code "
"and data that represent the history of local time for many representative "
"locations around the globe. It is updated periodically to reflect changes "
"made by political bodies to time zone boundaries, UTC offsets, and daylight-"
"saving rules."
msgstr ""
"База данных часовых поясов (часто называемая tz, tzdata илиzoneinfo) "
"содержит код и данные, которые представляют историю местного времени для "
"многих репрезентативных мест по всему миру. Он периодически обновляется, "
"чтобы отражать изменения, внесенные политическими органами в границы часовых "
"поясов, смещения UTC и правила перехода на летнее время."

#: ../../library/datetime.rst:2259
msgid ":class:`timezone` Objects"
msgstr "Объекты :class:`timezone`"

#: ../../library/datetime.rst:2261
msgid ""
"The :class:`timezone` class is a subclass of :class:`tzinfo`, each instance "
"of which represents a time zone defined by a fixed offset from UTC."
msgstr ""
"Класс :class:`timezone` является подклассом :class:`tzinfo`, каждый "
"экземпляр которого представляет часовой пояс, определенный фиксированным "
"смещением от UTC."

#: ../../library/datetime.rst:2265
msgid ""
"Objects of this class cannot be used to represent time zone information in "
"the locations where different offsets are used in different days of the year "
"or where historical changes have been made to civil time."
msgstr ""
"Объекты этого класса нельзя использовать для представления информации о "
"часовом поясе в местах, где в разные дни года используются разные смещения "
"или где в гражданское время были внесены исторические изменения."

#: ../../library/datetime.rst:2272
msgid ""
"The *offset* argument must be specified as a :class:`timedelta` object "
"representing the difference between the local time and UTC. It must be "
"strictly between ``-timedelta(hours=24)`` and ``timedelta(hours=24)``, "
"otherwise :exc:`ValueError` is raised."
msgstr ""
"Аргумент *offset* должен быть указан как объект :class:`timedelta`, "
"представляющий разницу между местным временем и временем UTC. Оно должно "
"находиться строго между ``-timedelta(hours=24)`` и ``timedelta(hours=24)``, "
"в противном случае выдается :exc:`ValueError`."

#: ../../library/datetime.rst:2277
msgid ""
"The *name* argument is optional. If specified it must be a string that will "
"be used as the value returned by the :meth:`datetime.tzname` method."
msgstr ""
"Аргумент *имя* является необязательным. Если указано, это должна быть "
"строка, которая будет использоваться в качестве значения, возвращаемого "
"методом :meth:`datetime.tzname`."

#: ../../library/datetime.rst:2288 ../../library/datetime.rst:2299
msgid ""
"Return the fixed value specified when the :class:`timezone` instance is "
"constructed."
msgstr ""
"Возвращает фиксированное значение, указанное при создании экземпляра :class:"
"`timezone`."

#: ../../library/datetime.rst:2291
msgid ""
"The *dt* argument is ignored. The return value is a :class:`timedelta` "
"instance equal to the difference between the local time and UTC."
msgstr ""
"Аргумент *dt* игнорируется. Возвращаемое значение — это экземпляр :class:"
"`timedelta`, равный разнице между местным временем и временем UTC."

#: ../../library/datetime.rst:2302
msgid ""
"If *name* is not provided in the constructor, the name returned by "
"``tzname(dt)`` is generated from the value of the ``offset`` as follows. If "
"*offset* is ``timedelta(0)``, the name is \"UTC\", otherwise it is a string "
"in the format ``UTC±HH:MM``, where ± is the sign of ``offset``, HH and MM "
"are two digits of ``offset.hours`` and ``offset.minutes`` respectively."
msgstr ""
"Если *name* не указано в конструкторе, имя, возвращаемое ``tzname(dt)``, "
"генерируется из значения ``offset`` следующим образом. Если *offset* равно "
"``timedelta(0)``, то имя — \"UTC\", в противном случае это строка в формате "
"``UTC±HH:MM``, где ± — знак ``offset`` , ЧЧ и ММ — это две цифры «смещение."
"часы» и «смещение.минуты» соответственно."

#: ../../library/datetime.rst:2308
msgid ""
"Name generated from ``offset=timedelta(0)`` is now plain ``'UTC'``, not "
"``'UTC+00:00'``."
msgstr ""
"Имя, сгенерированное из ``offset=timedelta(0)``, теперь имеет вид ``'UTC'``, "
"а не ``'UTC+00:00'``."

#: ../../library/datetime.rst:2315
msgid "Always returns ``None``."
msgstr "Всегда возвращает ``None``."

#: ../../library/datetime.rst:2319
msgid ""
"Return ``dt + offset``. The *dt* argument must be an aware :class:`."
"datetime` instance, with ``tzinfo`` set to ``self``."
msgstr ""
"Верните ``dt + смещение``. Аргумент *dt* должен быть осведомленным "
"экземпляром :class:`.datetime` с параметром ``tzinfo``, установленным в "
"``self``."

#: ../../library/datetime.rst:2326
msgid "The UTC time zone, ``timezone(timedelta(0))``."
msgstr "Часовой пояс UTC, ``timezone(timedelta(0))``."

#: ../../library/datetime.rst:2335
msgid ":meth:`~.datetime.strftime` and :meth:`~.datetime.strptime` Behavior"
msgstr "Поведение :meth:`~.datetime.strftime` и :meth:`~.datetime.strptime`"

#: ../../library/datetime.rst:2337
msgid ""
":class:`date`, :class:`.datetime`, and :class:`.time` objects all support a "
"``strftime(format)`` method, to create a string representing the time under "
"the control of an explicit format string."
msgstr ""
"Объекты :class:`date`, :class:`.datetime` и :class:`.time` поддерживают "
"метод ``strftime(format)`` для создания строки, представляющей время под "
"контролем явного строка формата."

#: ../../library/datetime.rst:2341
msgid ""
"Conversely, the :meth:`datetime.strptime` class method creates a :class:`."
"datetime` object from a string representing a date and time and a "
"corresponding format string."
msgstr ""
"И наоборот, метод класса :meth:`datetime.strptime` создает объект :class:`."
"datetime` из строки, представляющей дату и время, и соответствующей строки "
"формата."

#: ../../library/datetime.rst:2345
msgid ""
"The table below provides a high-level comparison of :meth:`~.datetime."
"strftime` versus :meth:`~.datetime.strptime`:"
msgstr ""
"В таблице ниже представлено общее сравнение :meth:`~.datetime.strftime` и :"
"meth:`~.datetime.strptime`:"

#: ../../library/datetime.rst:2349
msgid "``strftime``"
msgstr "``strftime``"

#: ../../library/datetime.rst:2349
msgid "``strptime``"
msgstr "``strptime``"

#: ../../library/datetime.rst:2351
msgid "Usage"
msgstr "Использование"

#: ../../library/datetime.rst:2351
msgid "Convert object to a string according to a given format"
msgstr ""
"Преобразовать объект в строку в соответствии с заданным форматированием"

#: ../../library/datetime.rst:2351
msgid ""
"Parse a string into a :class:`.datetime` object given a corresponding format"
msgstr ""
"Разобрать строку в объект :class:`.datetime` с учетом соответствующего "
"формата."

#: ../../library/datetime.rst:2353
msgid "Type of method"
msgstr "Тип метода"

#: ../../library/datetime.rst:2353
msgid "Instance method"
msgstr "Метод экземпляра"

#: ../../library/datetime.rst:2353
msgid "Class method"
msgstr "Метод класса"

#: ../../library/datetime.rst:2355
msgid "Method of"
msgstr "Метод"

#: ../../library/datetime.rst:2355
msgid ":class:`date`; :class:`.datetime`; :class:`.time`"
msgstr ":class:`date`; :class:`.datetime`; :class:`.time`"

#: ../../library/datetime.rst:2355
msgid ":class:`.datetime`"
msgstr ":class:`.datetime`"

#: ../../library/datetime.rst:2357
msgid "Signature"
msgstr "Подпись"

#: ../../library/datetime.rst:2357
msgid "``strftime(format)``"
msgstr "``strftime(format)``"

#: ../../library/datetime.rst:2357
msgid "``strptime(date_string, format)``"
msgstr "``strptime(date_string, format)``"

#: ../../library/datetime.rst:2364
msgid ""
":meth:`~.datetime.strftime` and :meth:`~.datetime.strptime` Format Codes"
msgstr ""
"Коды форматов :meth:`~.datetime.strftime` и :meth:`~.datetime.strptime`"

#: ../../library/datetime.rst:2366
msgid ""
"These methods accept format codes that can be used to parse and format "
"dates::"
msgstr ""
"Эти методы принимают коды формата, которые можно использовать для анализа и "
"форматирования дат:"

#: ../../library/datetime.rst:2368
msgid ""
">>> datetime.strptime('31/01/22 23:59:59.999999',\n"
"...                   '%d/%m/%y %H:%M:%S.%f')\n"
"datetime.datetime(2022, 1, 31, 23, 59, 59, 999999)\n"
">>> _.strftime('%a %d %b %Y, %I:%M%p')\n"
"'Mon 31 Jan 2022, 11:59PM'"
msgstr ""
">>> datetime.strptime('31/01/22 23:59:59.999999',\n"
"...                   '%d/%m/%y %H:%M:%S.%f')\n"
"datetime.datetime(2022, 1, 31, 23, 59, 59, 999999)\n"
">>> _.strftime('%a %d %b %Y, %I:%M%p')\n"
"'Mon 31 Jan 2022, 11:59PM'"

#: ../../library/datetime.rst:2374
msgid ""
"The following is a list of all the format codes that the 1989 C standard "
"requires, and these work on all platforms with a standard C implementation."
msgstr ""
"Ниже приведен список всех кодов формата, которые требуются в стандарте C "
"1989 года, и они работают на всех платформах со стандартной реализацией C."

#: ../../library/datetime.rst:2378 ../../library/datetime.rst:2481
msgid "Directive"
msgstr "Директива"

#: ../../library/datetime.rst:2378 ../../library/datetime.rst:2481
msgid "Meaning"
msgstr "Значение"

#: ../../library/datetime.rst:2378 ../../library/datetime.rst:2481
msgid "Example"
msgstr "Пример"

#: ../../library/datetime.rst:2378 ../../library/datetime.rst:2481
msgid "Notes"
msgstr "Примечания"

#: ../../library/datetime.rst:2380
msgid "``%a``"
msgstr "``%a``"

#: ../../library/datetime.rst:2380
msgid "Weekday as locale's abbreviated name."
msgstr "День недели - сокращенное название региона."

#: ../../library/datetime.rst:0
msgid "Sun, Mon, ..., Sat (en_US);"
msgstr "Sun, Mon, ..., Sat (en_US);"

#: ../../library/datetime.rst:0
msgid "So, Mo, ..., Sa (de_DE)"
msgstr "So, Mo, ..., Sa (de_DE)"

#: ../../library/datetime.rst:2385
msgid "``%A``"
msgstr "``%A``"

#: ../../library/datetime.rst:2385
msgid "Weekday as locale's full name."
msgstr "День недели в виде полного названия в регионе."

#: ../../library/datetime.rst:0
msgid "Sunday, Monday, ..., Saturday (en_US);"
msgstr "Sunday, Monday, ..., Saturday (en_US);"

#: ../../library/datetime.rst:0
msgid "Sonntag, Montag, ..., Samstag (de_DE)"
msgstr "Sonntag, Montag, ..., Samstag (de_DE)"

#: ../../library/datetime.rst:2390
msgid "``%w``"
msgstr "``%w``"

#: ../../library/datetime.rst:2390
msgid "Weekday as a decimal number, where 0 is Sunday and 6 is Saturday."
msgstr "День недели как десятичное число, где 0 - воскресенье, а 6 - суббота."

#: ../../library/datetime.rst:2390
msgid "0, 1, ..., 6"
msgstr "0, 1, ..., 6"

#: ../../library/datetime.rst:2394
msgid "``%d``"
msgstr "``%d``"

#: ../../library/datetime.rst:2394
msgid "Day of the month as a zero-padded decimal number."
msgstr "День месяца в виде десятичного числа, дополненного нулем."

#: ../../library/datetime.rst:2394
msgid "01, 02, ..., 31"
msgstr "01, 02, ..., 31"

#: ../../library/datetime.rst:2394 ../../library/datetime.rst:2407
#: ../../library/datetime.rst:2410 ../../library/datetime.rst:2416
#: ../../library/datetime.rst:2419 ../../library/datetime.rst:2425
#: ../../library/datetime.rst:2443
msgid "\\(9)"
msgstr "\\(9)"

#: ../../library/datetime.rst:2397
msgid "``%b``"
msgstr "``%b``"

#: ../../library/datetime.rst:2397
msgid "Month as locale's abbreviated name."
msgstr "Месяц в виде сокращенного названия в регионе."

#: ../../library/datetime.rst:0
msgid "Jan, Feb, ..., Dec (en_US);"
msgstr "Jan, Feb, ..., Dec (en_US);"

#: ../../library/datetime.rst:0
msgid "Jan, Feb, ..., Dez (de_DE)"
msgstr "Jan, Feb, ..., Dez (de_DE)"

#: ../../library/datetime.rst:2402
msgid "``%B``"
msgstr "``%B``"

#: ../../library/datetime.rst:2402
msgid "Month as locale's full name."
msgstr "Месяц в виде полного названия в регионе."

#: ../../library/datetime.rst:0
msgid "January, February, ..., December (en_US);"
msgstr "January, February, ..., December (en_US);"

#: ../../library/datetime.rst:0
msgid "Januar, Februar, ..., Dezember (de_DE)"
msgstr "Januar, Februar, ..., Dezember (de_DE)"

#: ../../library/datetime.rst:2407
msgid "``%m``"
msgstr "``%m``"

#: ../../library/datetime.rst:2407
msgid "Month as a zero-padded decimal number."
msgstr "Месяц в виде десятичного числа, дополненного нулем."

#: ../../library/datetime.rst:2407 ../../library/datetime.rst:2419
msgid "01, 02, ..., 12"
msgstr "01, 02, ..., 12"

#: ../../library/datetime.rst:2410
msgid "``%y``"
msgstr "``%y``"

#: ../../library/datetime.rst:2410
msgid "Year without century as a zero-padded decimal number."
msgstr "Год без столетия в виде десятичного числа, дополненного нулем."

#: ../../library/datetime.rst:2410
msgid "00, 01, ..., 99"
msgstr "00, 01, ..., 99"

#: ../../library/datetime.rst:2413
msgid "``%Y``"
msgstr "``%Y``"

#: ../../library/datetime.rst:2413
msgid "Year with century as a decimal number."
msgstr "Год с добавленным веком в качестве десятичного числа."

#: ../../library/datetime.rst:2413 ../../library/datetime.rst:2483
msgid "0001, 0002, ..., 2013, 2014, ..., 9998, 9999"
msgstr "0001, 0002, ..., 2013, 2014, ..., 9998, 9999"

#: ../../library/datetime.rst:2416
msgid "``%H``"
msgstr "``%H``"

#: ../../library/datetime.rst:2416
msgid "Hour (24-hour clock) as a zero-padded decimal number."
msgstr "Час (24 часа) в виде десятичного числа, дополненного нулем."

#: ../../library/datetime.rst:2416
msgid "00, 01, ..., 23"
msgstr "00, 01, ..., 23"

#: ../../library/datetime.rst:2419
msgid "``%I``"
msgstr "``%I``"

#: ../../library/datetime.rst:2419
msgid "Hour (12-hour clock) as a zero-padded decimal number."
msgstr "Час (12-часовой вид) в виде десятичного числа, дополненного нулем."

#: ../../library/datetime.rst:2422
msgid "``%p``"
msgstr "``%p``"

#: ../../library/datetime.rst:2422
msgid "Locale's equivalent of either AM or PM."
msgstr "Региональный эквивалент AM или PM."

#: ../../library/datetime.rst:0
msgid "AM, PM (en_US);"
msgstr "AM, PM (en_US);"

#: ../../library/datetime.rst:0
msgid "am, pm (de_DE)"
msgstr "am, pm (de_DE)"

#: ../../library/datetime.rst:2422
msgid "\\(1), \\(3)"
msgstr "\\(1), \\(3)"

#: ../../library/datetime.rst:2425
msgid "``%M``"
msgstr "``%M``"

#: ../../library/datetime.rst:2425
msgid "Minute as a zero-padded decimal number."
msgstr "Минута в виде десятичного числа, дополненного нулем."

#: ../../library/datetime.rst:2425 ../../library/datetime.rst:2428
msgid "00, 01, ..., 59"
msgstr "00, 01, ..., 59"

#: ../../library/datetime.rst:2428
msgid "``%S``"
msgstr "``%S``"

#: ../../library/datetime.rst:2428
msgid "Second as a zero-padded decimal number."
msgstr "Секунда в виде десятичного числа, дополненного нулем."

#: ../../library/datetime.rst:2428
msgid "\\(4), \\(9)"
msgstr "\\(4), \\(9)"

#: ../../library/datetime.rst:2431
msgid "``%f``"
msgstr "``%f``"

#: ../../library/datetime.rst:2431
msgid "Microsecond as a decimal number, zero-padded to 6 digits."
msgstr "Микросекунда в виде десятичного числа, дополненного нулем."

#: ../../library/datetime.rst:2431
msgid "000000, 000001, ..., 999999"
msgstr "000000, 000001, ..., 999999"

#: ../../library/datetime.rst:2431
msgid "\\(5)"
msgstr "\\(5)"

#: ../../library/datetime.rst:2435 ../../library/datetime.rst:2611
msgid "``%z``"
msgstr "``%z``"

#: ../../library/datetime.rst:2435
msgid ""
"UTC offset in the form ``±HHMM[SS[.ffffff]]`` (empty string if the object is "
"naive)."
msgstr ""
"Смещение по UTC в виде `±HHMM[SS[.ffffff]]` (пустая строка, если объект без "
"часового пояса)."

#: ../../library/datetime.rst:2435
msgid "(empty), +0000, -0400, +1030, +063415, -030712.345216"
msgstr "(empty), +0000, -0400, +1030, +063415, -030712.345216"

#: ../../library/datetime.rst:2435 ../../library/datetime.rst:2440
#: ../../library/datetime.rst:2497
msgid "\\(6)"
msgstr "\\(6)"

#: ../../library/datetime.rst:2440 ../../library/datetime.rst:2637
msgid "``%Z``"
msgstr "``%Z``"

#: ../../library/datetime.rst:2440
msgid "Time zone name (empty string if the object is naive)."
msgstr ""
"Название часового пояса (пустая строка, если объект без часового пояса)."

#: ../../library/datetime.rst:2440
msgid "(empty), UTC, GMT"
msgstr "(empty), UTC, GMT"

#: ../../library/datetime.rst:2443
msgid "``%j``"
msgstr "``%j``"

#: ../../library/datetime.rst:2443
msgid "Day of the year as a zero-padded decimal number."
msgstr "День года в виде десятичного числа, дополненного нулем."

#: ../../library/datetime.rst:2443
msgid "001, 002, ..., 366"
msgstr "001, 002, ..., 366"

#: ../../library/datetime.rst:2446
msgid "``%U``"
msgstr "``%U``"

#: ../../library/datetime.rst:2446
msgid ""
"Week number of the year (Sunday as the first day of the week) as a zero-"
"padded decimal number. All days in a new year preceding the first Sunday are "
"considered to be in week 0."
msgstr ""
"Номер недели в году (воскресенье - первый день недели) в виде десятичного "
"числа, дополненного нулем. Все дни в новом году, предшествующие первому "
"воскресенью, считаются днями недели 0."

#: ../../library/datetime.rst:2446 ../../library/datetime.rst:2454
msgid "00, 01, ..., 53"
msgstr "00, 01, ..., 53"

#: ../../library/datetime.rst:2446 ../../library/datetime.rst:2454
msgid "\\(7), \\(9)"
msgstr "\\(7), \\(9)"

#: ../../library/datetime.rst:2454
msgid "``%W``"
msgstr "``%W``"

#: ../../library/datetime.rst:2454
msgid ""
"Week number of the year (Monday as the first day of the week) as a zero-"
"padded decimal number. All days in a new year preceding the first Monday are "
"considered to be in week 0."
msgstr ""
"Номер недели в году (понедельник - первый день недели) в виде десятичного "
"числа, дополненного нулем. Все дни в новом году, предшествующие первому "
"понедельнику, считаются днями недели 0."

#: ../../library/datetime.rst:2462
msgid "``%c``"
msgstr "``%c``"

#: ../../library/datetime.rst:2462
msgid "Locale's appropriate date and time representation."
msgstr "Соответствующее региональному стандарту представление даты и времени."

#: ../../library/datetime.rst:0
msgid "Tue Aug 16 21:30:00 1988 (en_US);"
msgstr "Tue Aug 16 21:30:00 1988 (en_US);"

#: ../../library/datetime.rst:0
msgid "Di 16 Aug 21:30:00 1988 (de_DE)"
msgstr "Di 16 Aug 21:30:00 1988 (de_DE)"

#: ../../library/datetime.rst:2467
msgid "``%x``"
msgstr "``%x``"

#: ../../library/datetime.rst:2467
msgid "Locale's appropriate date representation."
msgstr "Соответствующее региональному стандарту представление даты."

#: ../../library/datetime.rst:0
msgid "08/16/88 (None);"
msgstr "08/16/88 (None);"

#: ../../library/datetime.rst:0
msgid "08/16/1988 (en_US);"
msgstr "08/16/1988 (en_US);"

#: ../../library/datetime.rst:0
msgid "16.08.1988 (de_DE)"
msgstr "16.08.1988 (de_DE)"

#: ../../library/datetime.rst:2471
msgid "``%X``"
msgstr "``%X``"

#: ../../library/datetime.rst:2471
msgid "Locale's appropriate time representation."
msgstr "Представление времени, соответствующее региону."

#: ../../library/datetime.rst:0
msgid "21:30:00 (en_US);"
msgstr "21:30:00 (en_US);"

#: ../../library/datetime.rst:0
msgid "21:30:00 (de_DE)"
msgstr "21:30:00 (de_DE)"

#: ../../library/datetime.rst:2474
msgid "``%%``"
msgstr "``%%``"

#: ../../library/datetime.rst:2474
msgid "A literal ``'%'`` character."
msgstr "Буквальный символ ``%``."

#: ../../library/datetime.rst:2474
msgid "%"
msgstr "%"

#: ../../library/datetime.rst:2477
msgid ""
"Several additional directives not required by the C89 standard are included "
"for convenience. These parameters all correspond to ISO 8601 date values."
msgstr ""
"Для удобства включены несколько дополнительных указаний, не требуемых "
"стандартом C89. Все эти параметры соответствуют значениям даты по стандарту "
"ISO 8601."

#: ../../library/datetime.rst:2483
msgid "``%G``"
msgstr "``%G``"

#: ../../library/datetime.rst:2483
msgid ""
"ISO 8601 year with century representing the year that contains the greater "
"part of the ISO week (``%V``)."
msgstr ""
"Год по стандарту ISO 8601, где столетие соответствует году, который содержит "
"большую часть недели ISO (``%V``)."

#: ../../library/datetime.rst:2483
msgid "\\(8)"
msgstr "\\(8)"

#: ../../library/datetime.rst:2488
msgid "``%u``"
msgstr "``%u``"

#: ../../library/datetime.rst:2488
msgid "ISO 8601 weekday as a decimal number where 1 is Monday."
msgstr ""
"День недели в формате ISO 8601 в виде десятичного числа, где 1 — понедельник."

#: ../../library/datetime.rst:2488
msgid "1, 2, ..., 7"
msgstr "1, 2, ..., 7"

#: ../../library/datetime.rst:2491
msgid "``%V``"
msgstr "``%V``"

#: ../../library/datetime.rst:2491
msgid ""
"ISO 8601 week as a decimal number with Monday as the first day of the week. "
"Week 01 is the week containing Jan 4."
msgstr ""
"В таблице ниже представлено общее сравнение :meth:`~.datetime.strftime` и :"
"meth:`~.datetime.strptime`:"

#: ../../library/datetime.rst:2491
msgid "01, 02, ..., 53"
msgstr "01, 02, ..., 53"

#: ../../library/datetime.rst:2491
msgid "\\(8), \\(9)"
msgstr "\\(8), \\(9)"

#: ../../library/datetime.rst:2497 ../../library/datetime.rst:2633
msgid "``%:z``"
msgstr "``%:z``"

#: ../../library/datetime.rst:2497
msgid ""
"UTC offset in the form ``±HH:MM[:SS[.ffffff]]`` (empty string if the object "
"is naive)."
msgstr ""
"Смещение UTC в форме ``±HH:MM[:SS[.ffffff]]`` (пустая строка, если объект "
"является наивным)."

#: ../../library/datetime.rst:2497
msgid "(empty), +00:00, -04:00, +10:30, +06:34:15, -03:07:12.345216"
msgstr "(empty), +00:00, -04:00, +10:30, +06:34:15, -03:07:12.345216"

#: ../../library/datetime.rst:2503
msgid ""
"These may not be available on all platforms when used with the :meth:`~."
"datetime.strftime` method. The ISO 8601 year and ISO 8601 week directives "
"are not interchangeable with the year and week number directives above. "
"Calling :meth:`~.datetime.strptime` with incomplete or ambiguous ISO 8601 "
"directives will raise a :exc:`ValueError`."
msgstr ""
"Они могут быть доступны не на всех платформах при использовании с методом :"
"meth:`~.datetime.strftime`. Директивы ISO 8601 года и ISO 8601 недели не "
"являются взаимозаменяемыми с приведенными выше директивами года и номера "
"недели. Вызов :meth:`~.datetime.strptime` с неполными или неоднозначными "
"директивами ISO 8601 вызовет ошибку :exc:`ValueError`."

#: ../../library/datetime.rst:2508
msgid ""
"The full set of format codes supported varies across platforms, because "
"Python calls the platform C library's :c:func:`strftime` function, and "
"platform variations are common. To see the full set of format codes "
"supported on your platform, consult the :manpage:`strftime(3)` "
"documentation. There are also differences between platforms in handling of "
"unsupported format specifiers."
msgstr ""
"Полный набор поддерживаемых кодов форматов варьируется в зависимости от "
"платформы, поскольку Python вызывает функцию :c:func:`strftime` библиотеки C "
"платформы, и вариации платформ являются общими. Чтобы просмотреть полный "
"набор кодов форматов, поддерживаемых вашей платформой, обратитесь к "
"документации :manpage:`strftime(3)`. Между платформами также существуют "
"различия в обработке спецификаторов неподдерживаемого формата."

#: ../../library/datetime.rst:2514
msgid "``%G``, ``%u`` and ``%V`` were added."
msgstr "`` %G ``, `` %в `` и ``%V`` были добавлены."

#: ../../library/datetime.rst:2517
msgid "``%:z`` was added."
msgstr "``%:z`` был добавлен."

#: ../../library/datetime.rst:2521
msgid "Technical Detail"
msgstr "Техническая деталь"

#: ../../library/datetime.rst:2523
msgid ""
"Broadly speaking, ``d.strftime(fmt)`` acts like the :mod:`time` module's "
"``time.strftime(fmt, d.timetuple())`` although not all objects support a :"
"meth:`~date.timetuple` method."
msgstr ""
"В общих чертах, ``d.strftime(fmt)`` действует как ``time.strftime(fmt, d."
"timetuple())`` модуля :mod:`time`, хотя не все объекты поддерживают :meth:`~ "
"метод date.timetuple`."

#: ../../library/datetime.rst:2527
msgid ""
"For the :meth:`.datetime.strptime` class method, the default value is "
"``1900-01-01T00:00:00.000``: any components not specified in the format "
"string will be pulled from the default value."
msgstr ""

#: ../../library/datetime.rst:2532
msgid ""
"When used to parse partial dates lacking a year, :meth:`~.datetime.strptime` "
"will raise when encountering February 29 because its default year of 1900 is "
"*not* a leap year.  Always add a default leap year to partial date strings "
"before parsing."
msgstr ""

#: ../../library/datetime.rst:2537
msgid ""
">>> from datetime import datetime\n"
">>> value = \"2/29\"\n"
">>> datetime.strptime(value, \"%m/%d\")\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: day is out of range for month\n"
">>> datetime.strptime(f\"1904 {value}\", \"%Y %m/%d\")\n"
"datetime.datetime(1904, 2, 29, 0, 0)"
msgstr ""

#: ../../library/datetime.rst:2548
msgid "Using ``datetime.strptime(date_string, format)`` is equivalent to::"
msgstr ""
"Использование ``datetime.strptime(date_string, format)`` эквивалентно::"

#: ../../library/datetime.rst:2552
msgid ""
"except when the format includes sub-second components or time zone offset "
"information, which are supported in ``datetime.strptime`` but are discarded "
"by ``time.strptime``."
msgstr ""
"за исключением случаев, когда формат включает компоненты с точностью до "
"секунды или информацию о смещении часового пояса, которые поддерживаются в "
"datetime.strptime, но отбрасываются в time.strptime."

#: ../../library/datetime.rst:2556
msgid ""
"For :class:`.time` objects, the format codes for year, month, and day should "
"not be used, as :class:`!time` objects have no such values. If they're used "
"anyway, 1900 is substituted for the year, and 1 for the month and day."
msgstr ""
"Для объектов :class:`.time` не следует использовать коды формата года, "
"месяца и дня, поскольку объекты :class:`!time` не имеют таких значений. Если "
"они все равно используются, 1900 заменяется на год, а 1 на месяц и день."

#: ../../library/datetime.rst:2560
msgid ""
"For :class:`date` objects, the format codes for hours, minutes, seconds, and "
"microseconds should not be used, as :class:`date` objects have no such "
"values. If they're used anyway, 0 is substituted for them."
msgstr ""
"Для объектов :class:`date` не следует использовать коды формата часов, "
"минут, секунд и микросекунд, поскольку объекты :class:`date` не имеют таких "
"значений. Если они все равно используются, вместо них заменяется 0."

#: ../../library/datetime.rst:2564
msgid ""
"For the same reason, handling of format strings containing Unicode code "
"points that can't be represented in the charset of the current locale is "
"also platform-dependent. On some platforms such code points are preserved "
"intact in the output, while on others ``strftime`` may raise :exc:"
"`UnicodeError` or return an empty string instead."
msgstr ""
"По той же причине обработка строк формата, содержащих кодовые точки Unicode, "
"которые не могут быть представлены в кодировке текущей локали, также зависит "
"от платформы. На некоторых платформах такие точки кода сохраняются в "
"выходных данных без изменений, в то время как на других ``strftime`` может "
"вызывать :exc:`UnicodeError` или вместо этого возвращать пустую строку."

#: ../../library/datetime.rst:2573
msgid ""
"Because the format depends on the current locale, care should be taken when "
"making assumptions about the output value. Field orderings will vary (for "
"example, \"month/day/year\" versus \"day/month/year\"), and the output may "
"contain non-ASCII characters."
msgstr ""
"Поскольку формат зависит от текущей локали, следует проявлять осторожность "
"при предположениях относительно выходного значения. Порядок полей может "
"различаться (например, «месяц/день/год» и «день/месяц/год»), а выходные "
"данные могут содержать символы, отличные от ASCII."

#: ../../library/datetime.rst:2579
msgid ""
"The :meth:`~.datetime.strptime` method can parse years in the full [1, 9999] "
"range, but years < 1000 must be zero-filled to 4-digit width."
msgstr ""
"Метод :meth:`~.datetime.strptime` может анализировать годы в полном "
"диапазоне [1, 9999], но годы < 1000 должны быть заполнены нулями до 4-"
"значной ширины."

#: ../../library/datetime.rst:2582
msgid ""
"In previous versions, :meth:`~.datetime.strftime` method was restricted to "
"years >= 1900."
msgstr ""
"В предыдущих версиях метод :meth:`~.datetime.strftime` был ограничен годами "
">= 1900."

#: ../../library/datetime.rst:2586
msgid ""
"In version 3.2, :meth:`~.datetime.strftime` method was restricted to years "
">= 1000."
msgstr ""
"В версии 3.2 метод :meth:`~.datetime.strftime` был ограничен годами >= 1000."

#: ../../library/datetime.rst:2591
msgid ""
"When used with the :meth:`~.datetime.strptime` method, the ``%p`` directive "
"only affects the output hour field if the ``%I`` directive is used to parse "
"the hour."
msgstr ""
"При использовании с методом :meth:`~.datetime.strptime`, `` %p Директива `` "
"влияет на поле выходного часа только в том случае, если директива ``%I`` "
"используется для анализа часа."

#: ../../library/datetime.rst:2595
msgid ""
"Unlike the :mod:`time` module, the :mod:`!datetime` module does not support "
"leap seconds."
msgstr ""
"В отличие от модуля :mod:`time`, модуль :mod:`!datetime` не поддерживает "
"дополнительные секунды."

#: ../../library/datetime.rst:2599
msgid ""
"When used with the :meth:`~.datetime.strptime` method, the ``%f`` directive "
"accepts from one to six digits and zero pads on the right. ``%f`` is an "
"extension to the set of format characters in the C standard (but implemented "
"separately in datetime objects, and therefore always available)."
msgstr ""
"При использовании с методом :meth:`~.datetime.strptime`, `` %f `` Директива "
"принимает от одной до шести цифр и нули справа. `` %f `` является "
"расширением набора символов формата в стандарте C (но реализовано отдельно в "
"объектах datetime и, следовательно, всегда доступно)."

#: ../../library/datetime.rst:2606
msgid ""
"For a naive object, the ``%z``, ``%:z`` and ``%Z`` format codes are replaced "
"by empty strings."
msgstr ""
"Для наивного объекта коды формата ``%z``, ``%:z`` и ``%Z`` заменяются "
"пустыми строками."

#: ../../library/datetime.rst:2609
msgid "For an aware object:"
msgstr "Для осведомленного объекта:"

#: ../../library/datetime.rst:2612
msgid ""
":meth:`~.datetime.utcoffset` is transformed into a string of the form "
"``±HHMM[SS[.ffffff]]``, where ``HH`` is a 2-digit string giving the number "
"of UTC offset hours, ``MM`` is a 2-digit string giving the number of UTC "
"offset minutes, ``SS`` is a 2-digit string giving the number of UTC offset "
"seconds and ``ffffff`` is a 6-digit string giving the number of UTC offset "
"microseconds. The ``ffffff`` part is omitted when the offset is a whole "
"number of seconds and both the ``ffffff`` and the ``SS`` part is omitted "
"when the offset is a whole number of minutes. For example, if :meth:`~."
"datetime.utcoffset` returns ``timedelta(hours=-3, minutes=-30)``, ``%z`` is "
"replaced with the string ``'-0330'``."
msgstr ""
":meth:`~.datetime.utcoffset` преобразуется в строку вида ``±HHMM[SS[."
"ffffff]]``, где ``HH`` — это двухзначная строка, указывающая номер смещения "
"UTC. часы, ``MM`` — это двухзначная строка, указывающая количество минут "
"смещения UTC, ``SS`` — это двухзначная строка, указывающая количество секунд "
"смещения UTC, а ``ffffff`` представляет собой шестизначное число. строка, "
"указывающая количество микросекунд смещения UTC. Часть ``ffffff`` "
"опускается, если смещение составляет целое число секунд, а часть ``ffffff`` "
"и ``SS`` опускается, когда смещение составляет целое число минут. Например, "
"если :meth:`~.datetime.utcoffset` возвращает ``timedelta(часы=-3, "
"минуты=-30)``, ``%z`` заменяется строкой ``'-0330'` `."

#: ../../library/datetime.rst:2626
msgid ""
"When the ``%z`` directive is provided to the  :meth:`~.datetime.strptime` "
"method, the UTC offsets can have a colon as a separator between hours, "
"minutes and seconds. For example, ``'+01:00:00'`` will be parsed as an "
"offset of one hour. In addition, providing ``'Z'`` is identical to "
"``'+00:00'``."
msgstr ""
"Когда директива %z предоставляется методу :meth:`~.datetime.strptime`, "
"смещения UTC могут иметь двоеточие в качестве разделителя между часами, "
"минутами и секундами. Например, ``'+01:00:00'`` будет анализироваться как "
"смещение в один час. Кроме того, предоставление ``'Z'`` идентично "
"``'+00:00'``."

#: ../../library/datetime.rst:2634
msgid ""
"Behaves exactly as ``%z``, but has a colon separator added between hours, "
"minutes and seconds."
msgstr ""
"Ведёт себя точно так же, как %z, но между часами, минутами и секундами "
"добавляется двоеточие."

#: ../../library/datetime.rst:2638
msgid ""
"In :meth:`~.datetime.strftime`, ``%Z`` is replaced by an empty string if :"
"meth:`~.datetime.tzname` returns ``None``; otherwise ``%Z`` is replaced by "
"the returned value, which must be a string."
msgstr ""
"В :meth:`~.datetime.strftime` ``%Z`` заменяется пустой строкой, если :meth:"
"`~.datetime.tzname` возвращает ``None``; в противном случае ``%Z`` "
"заменяется возвращаемым значением, которое должно быть строкой."

#: ../../library/datetime.rst:2642
msgid ":meth:`~.datetime.strptime` only accepts certain values for ``%Z``:"
msgstr ""
":meth:`~.datetime.strptime` принимает только определенные значения для "
"``%Z``:"

#: ../../library/datetime.rst:2644
msgid "any value in ``time.tzname`` for your machine's locale"
msgstr "любое значение в ``time.tzname`` для локали вашего компьютера"

#: ../../library/datetime.rst:2645
msgid "the hard-coded values ``UTC`` and ``GMT``"
msgstr "жестко закодированные значения ``UTC`` и ``GMT``"

#: ../../library/datetime.rst:2647
msgid ""
"So someone living in Japan may have ``JST``, ``UTC``, and ``GMT`` as valid "
"values, but probably not ``EST``. It will raise ``ValueError`` for invalid "
"values."
msgstr ""
"Таким образом, кто-то, живущий в Японии, может иметь действительные значения "
"``JST``, ``UTC`` и ``GMT``, но, вероятно, не ``EST``. Это вызовет "
"``ValueError`` для недопустимых значений."

#: ../../library/datetime.rst:2651
msgid ""
"When the ``%z`` directive is provided to the :meth:`~.datetime.strptime` "
"method, an aware :class:`.datetime` object will be produced. The ``tzinfo`` "
"of the result will be set to a :class:`timezone` instance."
msgstr ""
"Когда директива %z предоставляется методу :meth:`~.datetime.strptime`, будет "
"создан соответствующий объект :class:`.datetime`. ``tzinfo`` результата "
"будет установлен в экземпляр :class:`timezone`."

#: ../../library/datetime.rst:2657
msgid ""
"When used with the :meth:`~.datetime.strptime` method, ``%U`` and ``%W`` are "
"only used in calculations when the day of the week and the calendar year "
"(``%Y``) are specified."
msgstr ""
"При использовании с методом :meth:`~.datetime.strptime`, ``%U`` и ``%W`` "
"используются в вычислениях только тогда, когда день недели и календарный год "
"(``%Y` `) указаны."

#: ../../library/datetime.rst:2662
msgid ""
"Similar to ``%U`` and ``%W``, ``%V`` is only used in calculations when the "
"day of the week and the ISO year (``%G``) are specified in a :meth:`~."
"datetime.strptime` format string. Also note that ``%G`` and ``%Y`` are not "
"interchangeable."
msgstr ""
"Подобно ``%U`` и ``%W``, ``%V`` используется в вычислениях только тогда, "
"когда день недели и год ISO (`` %G ``) указаны в строке формата :meth:`~."
"datetime.strptime`. Также обратите внимание, что `` %G `` и ``%Y`` не "
"являются взаимозаменяемыми."

#: ../../library/datetime.rst:2668
msgid ""
"When used with the :meth:`~.datetime.strptime` method, the leading zero is "
"optional for  formats ``%d``, ``%m``, ``%H``, ``%I``, ``%M``, ``%S``, "
"``%j``, ``%U``, ``%W``, and ``%V``. Format ``%y`` does require a leading "
"zero."
msgstr ""
"При использовании с методом :meth:`~.datetime.strptime` ведущий ноль "
"необязателен для форматов `` %д ``, ``%m``, ``%H``, ``%I``, ``%M``, ``%S``, "
"``%j``, ``%U` `, ``%W`` и ``%V``. Формат ``%y`` требует ведущего нуля."

#: ../../library/datetime.rst:2673
msgid ""
"Parsing dates without a year using :meth:`~.datetime.strptime` will fail on "
"representations of February 29 as that date does not exist in the default "
"year of 1900."
msgstr ""

#: ../../library/datetime.rst:2678
msgid "Footnotes"
msgstr "Сноски"

#: ../../library/datetime.rst:2679
msgid "If, that is, we ignore the effects of Relativity"
msgstr "Если, то есть, мы игнорируем эффекты теории относительности"

#: ../../library/datetime.rst:2681
msgid ""
"This matches the definition of the \"proleptic Gregorian\" calendar in "
"Dershowitz and Reingold's book *Calendrical Calculations*, where it's the "
"base calendar for all computations. See the book for algorithms for "
"converting between proleptic Gregorian ordinals and many other calendar "
"systems."
msgstr ""
"Это соответствует определению «превентивного григорианского» календаря в "
"книге Дершовица и Рейнгольда *Календарные вычисления*, где он является "
"базовым календарем для всех вычислений. См. книгу об алгоритмах "
"преобразования пролептических григорианских порядковых номеров во многие "
"другие календарные системы."

#: ../../library/datetime.rst:2687
msgid ""
"See R. H. van Gent's `guide to the mathematics of the ISO 8601 calendar "
"<https://web.archive.org/web/20220531051136/https://webspace.science.uu.nl/"
"~gent0113/calendar/isocalendar.htm>`_ for a good explanation."
msgstr ""
"См. «Руководство по математике календаря ISO 8601» Р.Х. ван Гента <https://"
"web.archive.org/web/20220531051136/https://webspace.science.uu.nl/~gent0113/"
"calendar/isocalendar.htm> `_ за хорошее объяснение."

#: ../../library/datetime.rst:2329
msgid "% (percent)"
msgstr "% (процент)"

#: ../../library/datetime.rst:2329
msgid "datetime format"
msgstr "формат даты и времени"
