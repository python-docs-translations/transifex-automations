# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-10 16:06+0000\n"
"PO-Revision-Date: 2022-11-05 17:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/fcntl.rst:2
msgid ":mod:`fcntl` --- The ``fcntl`` and ``ioctl`` system calls"
msgstr ""

#: ../../library/fcntl.rst:16
msgid ""
"This module performs file control and I/O control on file descriptors. It is "
"an interface to the :c:func:`fcntl` and :c:func:`ioctl` Unix routines.  For "
"a complete description of these calls, see :manpage:`fcntl(2)` and :manpage:"
"`ioctl(2)` Unix manual pages."
msgstr ""

#: ../../library/fcntl.rst:21
msgid ""
"All functions in this module take a file descriptor *fd* as their first "
"argument.  This can be an integer file descriptor, such as returned by ``sys."
"stdin.fileno()``, or an :class:`io.IOBase` object, such as ``sys.stdin`` "
"itself, which provides a :meth:`~io.IOBase.fileno` that returns a genuine "
"file descriptor."
msgstr ""
"Все функции в этом модуле принимают файловый дескриптор *fd* в качестве "
"первого аргумента. Это может быть целочисленный файловый дескриптор, "
"например, возвращаемый ``sys.stdin.fileno()``, или объект :class:`io."
"IOBase`, например, сам ``sys.stdin``, который предоставляет :meth:`~io."
"IOBase.fileno`, который возвращает подлинный дескриптор файла."

#: ../../library/fcntl.rst:27
msgid ""
"Operations in this module used to raise an :exc:`IOError` where they now "
"raise an :exc:`OSError`."
msgstr ""
"Операции в этом модуле раньше вызывали :exc:`IOError`, а теперь они "
"вызывают :exc:`OSError`."

#: ../../library/fcntl.rst:31
msgid ""
"The fcntl module now contains ``F_ADD_SEALS``, ``F_GET_SEALS``, and "
"``F_SEAL_*`` constants for sealing of :func:`os.memfd_create` file "
"descriptors."
msgstr ""
"Модуль fcntl теперь содержит константы F_ADD_SEALS, F_GET_SEALS и F_SEAL_* "
"для запечатывания файловых дескрипторов :func:`os.memfd_create`."

#: ../../library/fcntl.rst:36
msgid ""
"On macOS, the fcntl module exposes the ``F_GETPATH`` constant, which obtains "
"the path of a file from a file descriptor. On Linux(>=3.15), the fcntl "
"module exposes the ``F_OFD_GETLK``, ``F_OFD_SETLK`` and ``F_OFD_SETLKW`` "
"constants, which are used when working with open file description locks."
msgstr ""
"В macOS модуль fcntl предоставляет константу F_GETPATH, которая получает "
"путь к файлу из файлового дескриптора. В Linux (>=3.15) модуль fcntl "
"предоставляет константы F_OFD_GETLK, F_OFD_SETLK и F_OFD_SETLKW, которые "
"используются при работе с блокировками описаний открытых файлов."

#: ../../library/fcntl.rst:43
msgid ""
"On Linux >= 2.6.11, the fcntl module exposes the ``F_GETPIPE_SZ`` and "
"``F_SETPIPE_SZ`` constants, which allow to check and modify a pipe's size "
"respectively."
msgstr ""
"В Linux >= 2.6.11 модуль fcntl предоставляет константы F_GETPIPE_SZ и "
"F_SETPIPE_SZ, которые позволяют проверять и изменять размер канала "
"соответственно."

#: ../../library/fcntl.rst:48
msgid "The module defines the following functions:"
msgstr "Модуль определяет следующие функции:"

#: ../../library/fcntl.rst:53
msgid ""
"Perform the operation *cmd* on file descriptor *fd* (file objects providing "
"a :meth:`~io.IOBase.fileno` method are accepted as well).  The values used "
"for *cmd* are operating system dependent, and are available as constants in "
"the :mod:`fcntl` module, using the same names as used in the relevant C "
"header files. The argument *arg* can either be an integer value, or a :class:"
"`bytes` object. With an integer value, the return value of this function is "
"the integer return value of the C :c:func:`fcntl` call.  When the argument "
"is bytes it represents a binary structure, e.g. created by :func:`struct."
"pack`. The binary data is copied to a buffer whose address is passed to the "
"C :c:func:`fcntl` call.  The return value after a successful call is the "
"contents of the buffer, converted to a :class:`bytes` object. The length of "
"the returned object will be the same as the length of the *arg* argument. "
"This is limited to 1024 bytes. If the information returned in the buffer by "
"the operating system is larger than 1024 bytes, this is most likely to "
"result in a segmentation violation or a more subtle data corruption."
msgstr ""
"Выполните операцию *cmd* над файловым дескриптором *fd* (также принимаются "
"файловые объекты, предоставляющие метод :meth:`~io.IOBase.fileno`). "
"Значения, используемые для *cmd*, зависят от операционной системы и доступны "
"как константы в модуле :mod:`fcntl`, используя те же имена, что и в "
"соответствующих заголовочных файлах C. Аргумент *arg* может быть либо "
"целочисленным значением, либо объектом :class:`bytes`. При целочисленном "
"значении возвращаемое значение этой функции является целочисленным "
"возвращаемым значением вызова C :c:func:`fcntl`. Когда аргументом являются "
"байты, он представляет двоичную структуру, например, созданную :func:`struct."
"pack`. Двоичные данные копируются в буфер, адрес которого передается вызову "
"C :c:func:`fcntl`. Возвращаемое значение после успешного вызова — это "
"содержимое буфера, преобразованное в объект :class:`bytes`. Длина "
"возвращаемого объекта будет такой же, как длина аргумента *arg*. Это "
"ограничено 1024 байтами. Если информация, возвращаемая операционной системой "
"в буфер, превышает 1024 байта, это, скорее всего, приведет к нарушению "
"сегментации или более незаметному повреждению данных."

#: ../../library/fcntl.rst:70
msgid "If the :c:func:`fcntl` fails, an :exc:`OSError` is raised."
msgstr ""

#: ../../library/fcntl.rst:72
msgid ""
"Raises an :ref:`auditing event <auditing>` ``fcntl.fcntl`` with arguments "
"``fd``, ``cmd``, ``arg``."
msgstr ""
"Вызывает :ref:`событие аудита <auditing>` ``fcntl.fcntl`` с аргументами "
"``fd``, ``cmd``, ``arg``."

#: ../../library/fcntl.rst:77
msgid ""
"This function is identical to the :func:`~fcntl.fcntl` function, except that "
"the argument handling is even more complicated."
msgstr ""
"Эта функция идентична функции :func:`~fcntl.fcntl`, за исключением того, что "
"обработка аргументов еще сложнее."

#: ../../library/fcntl.rst:80
msgid ""
"The *request* parameter is limited to values that can fit in 32-bits. "
"Additional constants of interest for use as the *request* argument can be "
"found in the :mod:`termios` module, under the same names as used in the "
"relevant C header files."
msgstr ""
"Параметр *request* ограничен значениями, которые могут уместиться в 32 бита. "
"Дополнительные константы, представляющие интерес для использования в "
"качестве аргумента *request*, можно найти в модуле :mod:`termios` под теми "
"же именами, что и в соответствующих заголовочных файлах C."

#: ../../library/fcntl.rst:85
msgid ""
"The parameter *arg* can be one of an integer, an object supporting the read-"
"only buffer interface (like :class:`bytes`) or an object supporting the read-"
"write buffer interface (like :class:`bytearray`)."
msgstr ""
"Параметр *arg* может быть целым числом, объектом, поддерживающим интерфейс "
"буфера только для чтения (например, :class:`bytes`), или объектом, "
"поддерживающим интерфейс буфера чтения-записи (например, :class:`bytearray`)."

#: ../../library/fcntl.rst:89
msgid ""
"In all but the last case, behaviour is as for the :func:`~fcntl.fcntl` "
"function."
msgstr ""
"Во всех случаях, кроме последнего, поведение аналогично функции :func:"
"`~fcntl.fcntl`."

#: ../../library/fcntl.rst:92
msgid ""
"If a mutable buffer is passed, then the behaviour is determined by the value "
"of the *mutate_flag* parameter."
msgstr ""
"Если передается изменяемый буфер, то поведение определяется значением "
"параметра *mutate_flag*."

#: ../../library/fcntl.rst:95
msgid ""
"If it is false, the buffer's mutability is ignored and behaviour is as for a "
"read-only buffer, except that the 1024 byte limit mentioned above is avoided "
"-- so long as the buffer you pass is at least as long as what the operating "
"system wants to put there, things should work."
msgstr ""
"Если это значение ложно, изменчивость буфера игнорируется, и поведение "
"аналогично буферу, доступному только для чтения, за исключением того, что "
"упомянутое выше ограничение в 1024 байта избегается - при условии, что длина "
"передаваемого буфера не меньше длины, указанной в операционной системе. "
"хочет туда поставить, все должно работать."

#: ../../library/fcntl.rst:100
msgid ""
"If *mutate_flag* is true (the default), then the buffer is (in effect) "
"passed to the underlying :func:`ioctl` system call, the latter's return code "
"is passed back to the calling Python, and the buffer's new contents reflect "
"the action of the :func:`ioctl`.  This is a slight simplification, because "
"if the supplied buffer is less than 1024 bytes long it is first copied into "
"a static buffer 1024 bytes long which is then passed to :func:`ioctl` and "
"copied back into the supplied buffer."
msgstr ""
"Если *mutate_flag* имеет значение true (по умолчанию), то буфер (фактически) "
"передается базовому системному вызову :func:`ioctl`, код возврата последнего "
"передается обратно вызывающему Python, и новое содержимое буфера отражает "
"действие :func:`ioctl`. Это небольшое упрощение, поскольку если длина "
"предоставленного буфера меньше 1024 байт, он сначала копируется в "
"статический буфер длиной 1024 байта, который затем передается в :func:"
"`ioctl` и копируется обратно в предоставленный буфер."

#: ../../library/fcntl.rst:108
msgid "If the :c:func:`ioctl` fails, an :exc:`OSError` exception is raised."
msgstr ""

#: ../../library/fcntl.rst:110
msgid "An example::"
msgstr "Вот пример::"

#: ../../library/fcntl.rst:123
msgid ""
"Raises an :ref:`auditing event <auditing>` ``fcntl.ioctl`` with arguments "
"``fd``, ``request``, ``arg``."
msgstr ""
"Вызывает :ref:`событие аудита <auditing>` ``fcntl.ioctl`` с аргументами "
"``fd``, ``request``, ``arg``."

#: ../../library/fcntl.rst:128
msgid ""
"Perform the lock operation *operation* on file descriptor *fd* (file objects "
"providing a :meth:`~io.IOBase.fileno` method are accepted as well). See the "
"Unix manual :manpage:`flock(2)` for details.  (On some systems, this "
"function is emulated using :c:func:`fcntl`.)"
msgstr ""
"Выполните операцию блокировки *operation* для файлового дескриптора *fd* "
"(также принимаются файловые объекты, предоставляющие метод :meth:`~io.IOBase."
"fileno`). Подробности смотрите в руководстве по Unix :manpage:`flock(2)`. (В "
"некоторых системах эта функция эмулируется с помощью :c:func:`fcntl`.)"

#: ../../library/fcntl.rst:133
msgid "If the :c:func:`flock` fails, an :exc:`OSError` exception is raised."
msgstr ""

#: ../../library/fcntl.rst:135
msgid ""
"Raises an :ref:`auditing event <auditing>` ``fcntl.flock`` with arguments "
"``fd``, ``operation``."
msgstr ""
"Вызывает :ref:`событие аудита <auditing>` ``fcntl.flock`` с аргументами "
"``fd``, ``operation``."

#: ../../library/fcntl.rst:140
msgid ""
"This is essentially a wrapper around the :func:`~fcntl.fcntl` locking calls. "
"*fd* is the file descriptor (file objects providing a :meth:`~io.IOBase."
"fileno` method are accepted as well) of the file to lock or unlock, and "
"*cmd* is one of the following values:"
msgstr ""
"По сути, это оболочка вокруг вызовов блокировки :func:`~fcntl.fcntl`. *fd* — "
"это файловый дескриптор (также принимаются файловые объекты, предоставляющие "
"метод :meth:`~io.IOBase.fileno`) файла, который необходимо заблокировать или "
"разблокировать, а *cmd* — одно из следующих значений:"

#: ../../library/fcntl.rst:145
msgid ":const:`LOCK_UN` -- unlock"
msgstr ""

#: ../../library/fcntl.rst:146
msgid ":const:`LOCK_SH` -- acquire a shared lock"
msgstr ""

#: ../../library/fcntl.rst:147
msgid ":const:`LOCK_EX` -- acquire an exclusive lock"
msgstr ""

#: ../../library/fcntl.rst:149
msgid ""
"When *cmd* is :const:`LOCK_SH` or :const:`LOCK_EX`, it can also be bitwise "
"ORed with :const:`LOCK_NB` to avoid blocking on lock acquisition. If :const:"
"`LOCK_NB` is used and the lock cannot be acquired, an :exc:`OSError` will be "
"raised and the exception will have an *errno* attribute set to :const:"
"`EACCES` or :const:`EAGAIN` (depending on the operating system; for "
"portability, check for both values).  On at least some systems, :const:"
"`LOCK_EX` can only be used if the file descriptor refers to a file opened "
"for writing."
msgstr ""

#: ../../library/fcntl.rst:158
msgid ""
"*len* is the number of bytes to lock, *start* is the byte offset at which "
"the lock starts, relative to *whence*, and *whence* is as with :func:`io."
"IOBase.seek`, specifically:"
msgstr ""
"*len* — это количество байтов для блокировки, *start* — это смещение в "
"байтах, с которого начинается блокировка, относительно *whence*, а *whence* "
"аналогично :func:`io.IOBase.seek`, а именно:"

#: ../../library/fcntl.rst:162
msgid ":const:`0` -- relative to the start of the file (:data:`os.SEEK_SET`)"
msgstr ""

#: ../../library/fcntl.rst:163
msgid ""
":const:`1` -- relative to the current buffer position (:data:`os.SEEK_CUR`)"
msgstr ""

#: ../../library/fcntl.rst:164
msgid ":const:`2` -- relative to the end of the file (:data:`os.SEEK_END`)"
msgstr ""

#: ../../library/fcntl.rst:166
msgid ""
"The default for *start* is 0, which means to start at the beginning of the "
"file. The default for *len* is 0 which means to lock to the end of the "
"file.  The default for *whence* is also 0."
msgstr ""
"По умолчанию для *start* установлено значение 0, что означает начало с "
"начала файла. По умолчанию для *len* установлено значение 0, что означает "
"блокировку до конца файла. Значение по умолчанию для *wherece* также равно 0."

#: ../../library/fcntl.rst:170
msgid ""
"Raises an :ref:`auditing event <auditing>` ``fcntl.lockf`` with arguments "
"``fd``, ``cmd``, ``len``, ``start``, ``whence``."
msgstr ""
"Вызывает :ref:`событие аудита <auditing>` ``fcntl.lockf`` с аргументами "
"``fd``, ``cmd``, ``len``, ``start``, ``where`` ."

#: ../../library/fcntl.rst:172
msgid "Examples (all on a SVR4 compliant system)::"
msgstr "Примеры (все в системе, совместимой с SVR4)::"

#: ../../library/fcntl.rst:182
msgid ""
"Note that in the first example the return value variable *rv* will hold an "
"integer value; in the second example it will hold a :class:`bytes` object.  "
"The structure lay-out for the *lockdata* variable is system dependent --- "
"therefore using the :func:`flock` call may be better."
msgstr ""
"Обратите внимание, что в первом примере переменная возвращаемого значения "
"*rv* будет содержать целочисленное значение; во втором примере он будет "
"содержать объект :class:`bytes`. Структура переменной *lockdata* зависит от "
"системы, поэтому лучше использовать вызов :func:`flock`."

#: ../../library/fcntl.rst:193
msgid "Module :mod:`os`"
msgstr "Модуль :mod:`os`"

#: ../../library/fcntl.rst:191
msgid ""
"If the locking flags :data:`~os.O_SHLOCK` and :data:`~os.O_EXLOCK` are "
"present in the :mod:`os` module (on BSD only), the :func:`os.open` function "
"provides an alternative to the :func:`lockf` and :func:`flock` functions."
msgstr ""
