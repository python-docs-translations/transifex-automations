# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 15:28+0000\n"
"PO-Revision-Date: 2023-05-24 02:14+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/decimal.rst:2
msgid ":mod:`decimal` --- Decimal fixed point and floating point arithmetic"
msgstr ""

#: ../../library/decimal.rst:15
msgid "**Source code:** :source:`Lib/decimal.py`"
msgstr "**Исходный код:** :source:`Lib/decimal.py`"

#: ../../library/decimal.rst:33
msgid ""
"The :mod:`decimal` module provides support for fast correctly rounded "
"decimal floating point arithmetic. It offers several advantages over the :"
"class:`float` datatype:"
msgstr ""

#: ../../library/decimal.rst:37
msgid ""
"Decimal \"is based on a floating-point model which was designed with people "
"in mind, and necessarily has a paramount guiding principle -- computers must "
"provide an arithmetic that works in the same way as the arithmetic that "
"people learn at school.\" -- excerpt from the decimal arithmetic "
"specification."
msgstr ""
"Десятичная система «основана на модели с плавающей запятой, которая была "
"разработана с учетом потребностей людей и обязательно имеет главный "
"руководящий принцип: компьютеры должны обеспечивать арифметику, которая "
"работает так же, как арифметика, которую люди изучают в школе». -- отрывок "
"из спецификации десятичной арифметики."

#: ../../library/decimal.rst:42
msgid ""
"Decimal numbers can be represented exactly.  In contrast, numbers like "
"``1.1`` and ``2.2`` do not have exact representations in binary floating "
"point. End users typically would not expect ``1.1 + 2.2`` to display as "
"``3.3000000000000003`` as it does with binary floating point."
msgstr ""
"Десятичные числа могут быть представлены точно. Напротив, числа типа «1.1» и "
"«2.2» не имеют точного представления в двоичном формате с плавающей запятой. "
"Конечные пользователи обычно не ожидают, что ``1.1 + 2.2`` будет "
"отображаться как ``3.3000000000000003``, как это происходит с двоичной "
"плавающей запятой."

#: ../../library/decimal.rst:47
msgid ""
"The exactness carries over into arithmetic.  In decimal floating point, "
"``0.1 + 0.1 + 0.1 - 0.3`` is exactly equal to zero.  In binary floating "
"point, the result is ``5.5511151231257827e-017``.  While near to zero, the "
"differences prevent reliable equality testing and differences can "
"accumulate. For this reason, decimal is preferred in accounting applications "
"which have strict equality invariants."
msgstr ""
"Точность переносится и на арифметику. В десятичном формате с плавающей "
"запятой ``0,1 + 0,1 + 0,1 - 0,3`` точно равно нулю. В двоичном формате с "
"плавающей запятой результат будет ``5.5511151231257827e-017``. Несмотря на "
"то, что различия близки к нулю, они препятствуют надежному тестированию на "
"равенство, и различия могут накапливаться. По этой причине десятичное число "
"предпочтительнее в бухгалтерских приложениях, которые имеют строгие "
"инварианты равенства."

#: ../../library/decimal.rst:54
msgid ""
"The decimal module incorporates a notion of significant places so that "
"``1.30 + 1.20`` is ``2.50``.  The trailing zero is kept to indicate "
"significance. This is the customary presentation for monetary applications. "
"For multiplication, the \"schoolbook\" approach uses all the figures in the "
"multiplicands.  For instance, ``1.3 * 1.2`` gives ``1.56`` while ``1.30 * "
"1.20`` gives ``1.5600``."
msgstr ""
"Десятичный модуль включает в себя понятие значащих знаков, так что «1,30 + "
"1,20» равно «2,50». Конечный ноль сохраняется для обозначения значимости. "
"Это обычное представление денежных приложений. Для умножения в «учебном» "
"подходе используются все числа множимого. Например, «1,3 * 1,2» дает «1,56», "
"а «1,30 * 1,20» дает «1,5600»."

#: ../../library/decimal.rst:61
msgid ""
"Unlike hardware based binary floating point, the decimal module has a user "
"alterable precision (defaulting to 28 places) which can be as large as "
"needed for a given problem:"
msgstr ""
"В отличие от аппаратного двоичного числа с плавающей запятой, десятичный "
"модуль имеет изменяемую пользователем точность (по умолчанию 28 знаков), "
"которая может быть настолько большой, насколько это необходимо для "
"конкретной задачи:"

#: ../../library/decimal.rst:73
msgid ""
"Both binary and decimal floating point are implemented in terms of published "
"standards.  While the built-in float type exposes only a modest portion of "
"its capabilities, the decimal module exposes all required parts of the "
"standard. When needed, the programmer has full control over rounding and "
"signal handling. This includes an option to enforce exact arithmetic by "
"using exceptions to block any inexact operations."
msgstr ""
"Как двоичные, так и десятичные числа с плавающей запятой реализованы в "
"соответствии с опубликованными стандартами. В то время как встроенный тип "
"float предоставляет лишь скромную часть своих возможностей, модуль decimal "
"предоставляет все необходимые части стандарта. При необходимости программист "
"имеет полный контроль над округлением и обработкой сигналов. Сюда входит "
"возможность обеспечить точную арифметику с помощью исключений для блокировки "
"любых неточных операций."

#: ../../library/decimal.rst:80
msgid ""
"The decimal module was designed to support \"without prejudice, both exact "
"unrounded decimal arithmetic (sometimes called fixed-point arithmetic) and "
"rounded floating-point arithmetic.\"  -- excerpt from the decimal arithmetic "
"specification."
msgstr ""
"Модуль decimal был разработан для поддержки «без ущерба как точной "
"неокругленной десятичной арифметики (иногда называемой арифметикой с "
"фиксированной запятой), так и округленной арифметики с плавающей запятой». "
"-- отрывок из спецификации десятичной арифметики."

#: ../../library/decimal.rst:85
msgid ""
"The module design is centered around three concepts:  the decimal number, "
"the context for arithmetic, and signals."
msgstr ""
"Дизайн модуля основан на трех концепциях: десятичном числе, контексте "
"арифметики и сигналах."

#: ../../library/decimal.rst:88
msgid ""
"A decimal number is immutable.  It has a sign, coefficient digits, and an "
"exponent.  To preserve significance, the coefficient digits do not truncate "
"trailing zeros.  Decimals also include special values such as ``Infinity``, "
"``-Infinity``, and ``NaN``.  The standard also differentiates ``-0`` from "
"``+0``."
msgstr ""
"Десятичное число неизменно. Он имеет знак, цифры коэффициента и показатель "
"степени. Чтобы сохранить значимость, цифры коэффициента не обрезают конечные "
"нули. Десятичные числа также включают специальные значения, такие как "
"«Бесконечность», «-Бесконечность» и «NaN». Стандарт также отличает ``-0`` от "
"``+0``."

#: ../../library/decimal.rst:94
msgid ""
"The context for arithmetic is an environment specifying precision, rounding "
"rules, limits on exponents, flags indicating the results of operations, and "
"trap enablers which determine whether signals are treated as exceptions.  "
"Rounding options include :const:`ROUND_CEILING`, :const:`ROUND_DOWN`, :const:"
"`ROUND_FLOOR`, :const:`ROUND_HALF_DOWN`, :const:`ROUND_HALF_EVEN`, :const:"
"`ROUND_HALF_UP`, :const:`ROUND_UP`, and :const:`ROUND_05UP`."
msgstr ""
"Контекстом для арифметических операций является среда, определяющая "
"точность, правила округления, ограничения на показатели степени, флаги, "
"указывающие результаты операций, и активаторы ловушек, которые определяют, "
"рассматриваются ли сигналы как исключения. Параметры округления включают :"
"const:`ROUND_CEILING`, :const:`ROUND_DOWN`, :const:`ROUND_FLOOR`, :const:"
"`ROUND_HALF_DOWN`, :const:`ROUND_HALF_EVEN`, :const:`ROUND_HALF_UP`, :const:"
"`ROUND_UP` ` и :const:`ROUND_05UP`."

#: ../../library/decimal.rst:101
msgid ""
"Signals are groups of exceptional conditions arising during the course of "
"computation.  Depending on the needs of the application, signals may be "
"ignored, considered as informational, or treated as exceptions. The signals "
"in the decimal module are: :const:`Clamped`, :const:`InvalidOperation`, :"
"const:`DivisionByZero`, :const:`Inexact`, :const:`Rounded`, :const:"
"`Subnormal`, :const:`Overflow`, :const:`Underflow` and :const:"
"`FloatOperation`."
msgstr ""
"Сигналы — это группы исключительных условий, возникающих в ходе вычислений. "
"В зависимости от потребностей приложения сигналы могут игнорироваться, "
"рассматриваться как информационные или рассматриваться как исключения. "
"Сигналы в десятичном модуле: :const:`Clamped`, :const:`InvalidOperation`, :"
"const:`DivisionByZero`, :const:`Inexact`, :const:`Rounded`, :const:"
"`Subnormal`, :const:`Overflow`, :const:`Underflow` и :const:`FloatOperation`."

#: ../../library/decimal.rst:108
msgid ""
"For each signal there is a flag and a trap enabler.  When a signal is "
"encountered, its flag is set to one, then, if the trap enabler is set to "
"one, an exception is raised.  Flags are sticky, so the user needs to reset "
"them before monitoring a calculation."
msgstr ""
"Для каждого сигнала есть флаг и активатор ловушки. При обнаружении сигнала "
"его флаг устанавливается в единицу, затем, если для активатора ловушки "
"установлено значение 1, возникает исключение. Флаги закреплены, поэтому "
"пользователю необходимо сбросить их перед наблюдением за расчетом."

#: ../../library/decimal.rst:116
msgid ""
"IBM's General Decimal Arithmetic Specification, `The General Decimal "
"Arithmetic Specification <https://speleotrove.com/decimal/decarith.html>`_."
msgstr ""
"Общая спецификация десятичной арифметики IBM, `Общая спецификация десятичной "
"арифметики <https://speleotrove.com/decimal/decarith.html>`_."

#: ../../library/decimal.rst:125
msgid "Quick-start Tutorial"
msgstr "Краткое руководство"

#: ../../library/decimal.rst:127
msgid ""
"The usual start to using decimals is importing the module, viewing the "
"current context with :func:`getcontext` and, if necessary, setting new "
"values for precision, rounding, or enabled traps::"
msgstr ""
"Обычное начало использования десятичных дробей — это импорт модуля, просмотр "
"текущего контекста с помощью :func:`getcontext` и, при необходимости, "
"установка новых значений точности, округления или включенных ловушек::"

#: ../../library/decimal.rst:139
msgid ""
"Decimal instances can be constructed from integers, strings, floats, or "
"tuples. Construction from an integer or a float performs an exact conversion "
"of the value of that integer or float.  Decimal numbers include special "
"values such as ``NaN`` which stands for \"Not a number\", positive and "
"negative ``Infinity``, and ``-0``::"
msgstr ""
"Десятичные экземпляры могут быть созданы из целых чисел, строк, чисел с "
"плавающей запятой или кортежей. Конструкция из целого числа или числа с "
"плавающей запятой выполняет точное преобразование значения этого целого "
"числа или числа с плавающей запятой. Десятичные числа включают специальные "
"значения, такие как ``NaN``, что означает «Не число», положительные и "
"отрицательные ``Бесконечность`` и ``-0``::"

#: ../../library/decimal.rst:163
msgid ""
"If the :exc:`FloatOperation` signal is trapped, accidental mixing of "
"decimals and floats in constructors or ordering comparisons raises an "
"exception::"
msgstr ""
"Если сигнал :exc:`FloatOperation` перехвачен, случайное смешивание "
"десятичных чисел и чисел с плавающей запятой в конструкторах или сравнениях "
"порядка вызывает исключение::"

#: ../../library/decimal.rst:182
msgid ""
"The significance of a new Decimal is determined solely by the number of "
"digits input.  Context precision and rounding only come into play during "
"arithmetic operations."
msgstr ""
"Значение новой десятичной дроби определяется исключительно количеством "
"введенных цифр. Контекстная точность и округление играют роль только во "
"время арифметических операций."

#: ../../library/decimal.rst:199
msgid ""
"If the internal limits of the C version are exceeded, constructing a decimal "
"raises :class:`InvalidOperation`::"
msgstr ""
"Если внутренние ограничения версии C превышены, при построении десятичной "
"дроби возникает :class:`InvalidOperation`::"

#: ../../library/decimal.rst:209
msgid ""
"Decimals interact well with much of the rest of Python.  Here is a small "
"decimal floating point flying circus:"
msgstr ""

#: ../../library/decimal.rst:241
msgid "And some mathematical functions are also available to Decimal:"
msgstr "И некоторые математические функции также доступны для Decimal:"

#: ../../library/decimal.rst:253
msgid ""
"The :meth:`~Decimal.quantize` method rounds a number to a fixed exponent.  "
"This method is useful for monetary applications that often round results to "
"a fixed number of places:"
msgstr ""
"Метод :meth:`~Decimal.quantize` округляет число до фиксированной степени. "
"Этот метод полезен для денежных приложений, которые часто округляют "
"результаты до фиксированного количества знаков:"

#: ../../library/decimal.rst:262
msgid ""
"As shown above, the :func:`getcontext` function accesses the current context "
"and allows the settings to be changed.  This approach meets the needs of "
"most applications."
msgstr ""
"Как показано выше, функция :func:`getcontext` получает доступ к текущему "
"контексту и позволяет изменять настройки. Этот подход удовлетворяет "
"потребностям большинства приложений."

#: ../../library/decimal.rst:266
msgid ""
"For more advanced work, it may be useful to create alternate contexts using "
"the Context() constructor.  To make an alternate active, use the :func:"
"`setcontext` function."
msgstr ""
"Для более сложной работы может быть полезно создать альтернативные контексты "
"с помощью конструктора Context(). Чтобы сделать альтернативу активной, "
"используйте функцию :func:`setcontext`."

#: ../../library/decimal.rst:270
msgid ""
"In accordance with the standard, the :mod:`decimal` module provides two "
"ready to use standard contexts, :const:`BasicContext` and :const:"
"`ExtendedContext`. The former is especially useful for debugging because "
"many of the traps are enabled:"
msgstr ""
"В соответствии со стандартом модуль :mod:`decimal` предоставляет два готовых "
"к использованию стандартных контекста: :const:`BasicContext` и :const:"
"`ExtendedContext`. Первое особенно полезно для отладки, поскольку включены "
"многие ловушки:"

#: ../../library/decimal.rst:299
msgid ""
"Contexts also have signal flags for monitoring exceptional conditions "
"encountered during computations.  The flags remain set until explicitly "
"cleared, so it is best to clear the flags before each set of monitored "
"computations by using the :meth:`~Context.clear_flags` method. ::"
msgstr ""
"Контексты также имеют сигнальные флаги для мониторинга исключительных "
"условий, возникающих во время вычислений. Флаги остаются установленными до "
"тех пор, пока они не будут явно очищены, поэтому лучше всего очищать флаги "
"перед каждым набором отслеживаемых вычислений, используя метод :meth:"
"`~Context.clear_flags`. ::"

#: ../../library/decimal.rst:312
msgid ""
"The *flags* entry shows that the rational approximation to pi was rounded "
"(digits beyond the context precision were thrown away) and that the result "
"is inexact (some of the discarded digits were non-zero)."
msgstr ""
"Запись *flags* показывает, что рациональное приближение числа «пи» было "
"округлено (цифры, выходящие за рамки контекстной точности, были отброшены) и "
"что результат неточен (некоторые из отброшенных цифр были ненулевыми)."

#: ../../library/decimal.rst:316
msgid ""
"Individual traps are set using the dictionary in the :attr:`~Context.traps` "
"attribute of a context:"
msgstr ""
"Отдельные ловушки устанавливаются с использованием словаря в атрибуте :attr:"
"`~Context.traps` контекста:"

#: ../../library/decimal.rst:331
msgid ""
"Most programs adjust the current context only once, at the beginning of the "
"program.  And, in many applications, data is converted to :class:`Decimal` "
"with a single cast inside a loop.  With context set and decimals created, "
"the bulk of the program manipulates the data no differently than with other "
"Python numeric types."
msgstr ""
"Большинство программ корректируют текущий контекст только один раз, в начале "
"программы. И во многих приложениях данные преобразуются в :class:`Decimal` с "
"помощью одного приведения внутри цикла. С установленным контекстом и "
"созданными десятичными дробями основная часть программы манипулирует данными "
"так же, как и с другими числовыми типами Python."

#: ../../library/decimal.rst:343
msgid "Decimal objects"
msgstr "Десятичные объекты"

#: ../../library/decimal.rst:348
msgid "Construct a new :class:`Decimal` object based from *value*."
msgstr "Создайте новый объект :class:`Decimal` на основе *value*."

#: ../../library/decimal.rst:350
msgid ""
"*value* can be an integer, string, tuple, :class:`float`, or another :class:"
"`Decimal` object. If no *value* is given, returns ``Decimal('0')``.  If "
"*value* is a string, it should conform to the decimal numeric string syntax "
"after leading and trailing whitespace characters, as well as underscores "
"throughout, are removed::"
msgstr ""
"*значение* может быть целым числом, строкой, кортежем, :class:`float` или "
"другим :class:`Decimal` объектом. Если *значение* не указано, возвращается "
"``Decimal('0')``. Если *value* является строкой, она должна соответствовать "
"синтаксису десятичной числовой строки после удаления начальных и конечных "
"пробельных символов, а также символов подчеркивания::"

#: ../../library/decimal.rst:366
msgid ""
"Other Unicode decimal digits are also permitted where ``digit`` appears "
"above.  These include decimal digits from various other alphabets (for "
"example, Arabic-Indic and Devanāgarī digits) along with the fullwidth digits "
"``'\\uff10'`` through ``'\\uff19'``."
msgstr ""
"Другие десятичные цифры Юникода также разрешены там, где выше встречается "
"слово «цифра». К ним относятся десятичные цифры из различных других "
"алфавитов (например, арабско-индийские цифры и цифры деванагари), а также "
"цифры полной ширины от ``'\\uff10'`` до ``'\\uff19'``."

#: ../../library/decimal.rst:371
msgid ""
"If *value* is a :class:`tuple`, it should have three components, a sign "
"(``0`` for positive or ``1`` for negative), a :class:`tuple` of digits, and "
"an integer exponent. For example, ``Decimal((0, (1, 4, 1, 4), -3))`` returns "
"``Decimal('1.414')``."
msgstr ""
"Если *value* представляет собой :class:`tuple`, оно должно состоять из трёх "
"компонентов: знак (``0`` для положительного значения или ``1`` для "
"отрицательного), :class:`tuple` цифр и целочисленный показатель. Например, "
"``Decimal((0, (1, 4, 1, 4), -3))`` возвращает ``Decimal('1.414')``."

#: ../../library/decimal.rst:376
msgid ""
"If *value* is a :class:`float`, the binary floating point value is "
"losslessly converted to its exact decimal equivalent.  This conversion can "
"often require 53 or more digits of precision.  For example, "
"``Decimal(float('1.1'))`` converts to "
"``Decimal('1.100000000000000088817841970012523233890533447265625')``."
msgstr ""

#: ../../library/decimal.rst:382
msgid ""
"The *context* precision does not affect how many digits are stored. That is "
"determined exclusively by the number of digits in *value*. For example, "
"``Decimal('3.00000')`` records all five zeros even if the context precision "
"is only three."
msgstr ""
"Точность *контекста* не влияет на количество сохраняемых цифр. Это "
"определяется исключительно количеством цифр в *значении*. Например, "
"``Decimal('3.00000')`` записывает все пять нулей, даже если точность "
"контекста равна всего трем."

#: ../../library/decimal.rst:387
msgid ""
"The purpose of the *context* argument is determining what to do if *value* "
"is a malformed string.  If the context traps :const:`InvalidOperation`, an "
"exception is raised; otherwise, the constructor returns a new Decimal with "
"the value of ``NaN``."
msgstr ""
"Назначение аргумента *context* — определить, что делать, если *value* "
"представляет собой неверную строку. Если контекст перехватывает :const:"
"`InvalidOperation`, возникает исключение; в противном случае конструктор "
"возвращает новое десятичное число со значением NaN."

#: ../../library/decimal.rst:392
msgid "Once constructed, :class:`Decimal` objects are immutable."
msgstr "После создания объекты :class:`Decimal` становятся неизменяемыми."

#: ../../library/decimal.rst:394
msgid ""
"The argument to the constructor is now permitted to be a :class:`float` "
"instance."
msgstr "Аргументом конструктора теперь может быть экземпляр :class:`float`."

#: ../../library/decimal.rst:398
msgid ""
":class:`float` arguments raise an exception if the :exc:`FloatOperation` "
"trap is set. By default the trap is off."
msgstr ""
"Аргументы :class:`float` вызывают исключение, если установлена ​​ловушка :exc:"
"`FloatOperation`. По умолчанию ловушка отключена."

#: ../../library/decimal.rst:402
msgid ""
"Underscores are allowed for grouping, as with integral and floating-point "
"literals in code."
msgstr ""
"Для группировки разрешены подчеркивания, как и в случае целочисленных "
"литералов и литералов с плавающей запятой в коде."

#: ../../library/decimal.rst:406
msgid ""
"Decimal floating point objects share many properties with the other built-in "
"numeric types such as :class:`float` and :class:`int`.  All of the usual "
"math operations and special methods apply.  Likewise, decimal objects can be "
"copied, pickled, printed, used as dictionary keys, used as set elements, "
"compared, sorted, and coerced to another type (such as :class:`float` or :"
"class:`int`)."
msgstr ""

#: ../../library/decimal.rst:413
msgid ""
"There are some small differences between arithmetic on Decimal objects and "
"arithmetic on integers and floats.  When the remainder operator ``%`` is "
"applied to Decimal objects, the sign of the result is the sign of the "
"*dividend* rather than the sign of the divisor::"
msgstr ""
"Есть некоторые небольшие различия между арифметикой объектов Decimal и "
"арифметикой целых чисел и чисел с плавающей запятой. Когда оператор остатка "
"``%`` применяется к десятичным объектам, знаком результата является знак "
"*делимого*, а не знак делителя::"

#: ../../library/decimal.rst:423
msgid ""
"The integer division operator ``//`` behaves analogously, returning the "
"integer part of the true quotient (truncating towards zero) rather than its "
"floor, so as to preserve the usual identity ``x == (x // y) * y + x % y``::"
msgstr ""
"Оператор целочисленного деления ``//`` ведет себя аналогично, возвращая "
"целую часть истинного частного (усекаясь в сторону нуля), а не его нижнюю "
"часть, чтобы сохранить обычную идентичность ``x == (x // y) * y + x % y``::"

#: ../../library/decimal.rst:432
msgid ""
"The ``%`` and ``//`` operators implement the ``remainder`` and ``divide-"
"integer`` operations (respectively) as described in the specification."
msgstr ""
"Операторы ``%`` и ``//`` реализуют операции ``остаток`` и ``деление целого "
"числа`` (соответственно), как описано в спецификации."

#: ../../library/decimal.rst:436
msgid ""
"Decimal objects cannot generally be combined with floats or instances of :"
"class:`fractions.Fraction` in arithmetic operations: an attempt to add a :"
"class:`Decimal` to a :class:`float`, for example, will raise a :exc:"
"`TypeError`.  However, it is possible to use Python's comparison operators "
"to compare a :class:`Decimal` instance ``x`` with another number ``y``.  "
"This avoids confusing results when doing equality comparisons between "
"numbers of different types."
msgstr ""
"Десятичные объекты обычно не могут комбинироваться с числами с плавающей "
"запятой или экземплярами :class:`fractions.Fraction` в арифметических "
"операциях: например, попытка добавить :class:`Decimal` к :class:`float` "
"вызовет : exc:`TypeError`. Однако можно использовать операторы сравнения "
"Python для сравнения экземпляра :class:`Decimal``x`` с другим числом ``y``. "
"Это позволяет избежать путаницы при сравнении чисел разных типов на "
"равенство."

#: ../../library/decimal.rst:444
msgid ""
"Mixed-type comparisons between :class:`Decimal` instances and other numeric "
"types are now fully supported."
msgstr ""
"Сравнения смешанного типа между экземплярами :class:`Decimal` и другими "
"числовыми типами теперь полностью поддерживаются."

#: ../../library/decimal.rst:448
msgid ""
"In addition to the standard numeric properties, decimal floating point "
"objects also have a number of specialized methods:"
msgstr ""

#: ../../library/decimal.rst:454
msgid ""
"Return the adjusted exponent after shifting out the coefficient's rightmost "
"digits until only the lead digit remains: ``Decimal('321e+5').adjusted()`` "
"returns seven.  Used for determining the position of the most significant "
"digit with respect to the decimal point."
msgstr ""
"Возвращает скорректированную экспоненту после смещения крайних правых цифр "
"коэффициента до тех пор, пока не останется только первая цифра: "
"``Decimal('321e+5').adjusted()`` возвращает семь. Используется для "
"определения положения старшей цифры относительно десятичной точки."

#: ../../library/decimal.rst:461
msgid ""
"Return a pair ``(n, d)`` of integers that represent the given :class:"
"`Decimal` instance as a fraction, in lowest terms and with a positive "
"denominator::"
msgstr ""
"Возвращает пару целых чисел ``(n, d)``, которые представляют данный "
"экземпляр :class:`Decimal` как дробь, в наименьших выражениях и с "
"положительным знаменателем::"

#: ../../library/decimal.rst:468
msgid ""
"The conversion is exact.  Raise OverflowError on infinities and ValueError "
"on NaNs."
msgstr ""
"Преобразование точное. Поднимите OverflowError для бесконечностей и "
"ValueError для NaN."

#: ../../library/decimal.rst:475
msgid ""
"Return a :term:`named tuple` representation of the number: "
"``DecimalTuple(sign, digits, exponent)``."
msgstr ""
"Возвращает :term:`именованный кортеж`, представляющий число: "
"``DecimalTuple(знак, цифры, показатель степени)``."

#: ../../library/decimal.rst:481
msgid ""
"Return the canonical encoding of the argument.  Currently, the encoding of "
"a :class:`Decimal` instance is always canonical, so this operation returns "
"its argument unchanged."
msgstr ""
"Верните каноническую кодировку аргумента. В настоящее время кодировка "
"экземпляра :class:`Decimal` всегда каноническая, поэтому эта операция "
"возвращает аргумент без изменений."

#: ../../library/decimal.rst:487
msgid ""
"Compare the values of two Decimal instances.  :meth:`compare` returns a "
"Decimal instance, and if either operand is a NaN then the result is a NaN::"
msgstr ""
"Сравните значения двух экземпляров Decimal. :meth:`compare` возвращает "
"экземпляр Decimal, и если любой операнд имеет значение NaN, то результатом "
"будет NaN::"

#: ../../library/decimal.rst:498
msgid ""
"This operation is identical to the :meth:`compare` method, except that all "
"NaNs signal.  That is, if neither operand is a signaling NaN then any quiet "
"NaN operand is treated as though it were a signaling NaN."
msgstr ""
"Эта операция идентична методу :meth:`compare`, за исключением того, что все "
"NaN сигнализируют. То есть, если ни один из операндов не является сигнальным "
"NaN, то любой тихий операнд NaN обрабатывается так, как если бы он был "
"сигнальным NaN."

#: ../../library/decimal.rst:504
msgid ""
"Compare two operands using their abstract representation rather than their "
"numerical value.  Similar to the :meth:`compare` method, but the result "
"gives a total ordering on :class:`Decimal` instances.  Two :class:`Decimal` "
"instances with the same numeric value but different representations compare "
"unequal in this ordering:"
msgstr ""
"Сравните два операнда, используя их абстрактное представление, а не числовое "
"значение. Похож на метод :meth:`compare`, но результат дает общий порядок "
"экземпляров :class:`Decimal`. Два экземпляра :class:`Decimal` с одинаковым "
"числовым значением, но разными представлениями сравниваются в неравномерном "
"порядке:"

#: ../../library/decimal.rst:513
msgid ""
"Quiet and signaling NaNs are also included in the total ordering.  The "
"result of this function is ``Decimal('0')`` if both operands have the same "
"representation, ``Decimal('-1')`` if the first operand is lower in the total "
"order than the second, and ``Decimal('1')`` if the first operand is higher "
"in the total order than the second operand.  See the specification for "
"details of the total order."
msgstr ""
"Тихие и сигнальные NaN также включены в общий порядок. Результатом этой "
"функции является ``Decimal('0')``, если оба операнда имеют одинаковое "
"представление, ``Decimal('-1')``, если первый операнд в общем порядке ниже "
"второго, и ``Decimal('1')``, если первый операнд в общем порядке выше "
"второго операнда. Подробную информацию об общей сумме заказа см. в "
"спецификации."

#: ../../library/decimal.rst:520 ../../library/decimal.rst:531
#: ../../library/decimal.rst:559 ../../library/decimal.rst:846
msgid ""
"This operation is unaffected by context and is quiet: no flags are changed "
"and no rounding is performed.  As an exception, the C version may raise "
"InvalidOperation if the second operand cannot be converted exactly."
msgstr ""
"На эту операцию не влияет контекст, и она выполняется тихо: флаги не "
"изменяются и округление не выполняется. В виде исключения версия C может "
"вызвать InvalidOperation, если второй операнд не может быть точно "
"преобразован."

#: ../../library/decimal.rst:526
msgid ""
"Compare two operands using their abstract representation rather than their "
"value as in :meth:`compare_total`, but ignoring the sign of each operand. "
"``x.compare_total_mag(y)`` is equivalent to ``x.copy_abs().compare_total(y."
"copy_abs())``."
msgstr ""
"Сравните два операнда, используя их абстрактное представление, а не их "
"значение, как в :meth:`compare_total`, но игнорируя знак каждого операнда. "
"``x.compare_total_mag(y)`` эквивалентен ``x.copy_abs().compare_total(y."
"copy_abs())``."

#: ../../library/decimal.rst:537
msgid ""
"Just returns self, this method is only to comply with the Decimal "
"Specification."
msgstr ""
"Просто возвращает себя, этот метод должен соответствовать только десятичной "
"спецификации."

#: ../../library/decimal.rst:542
msgid ""
"Return the absolute value of the argument.  This operation is unaffected by "
"the context and is quiet: no flags are changed and no rounding is performed."
msgstr ""
"Возвращает абсолютное значение аргумента. На эту операцию не влияет "
"контекст, и она выполняется тихо: флаги не изменяются и округление не "
"выполняется."

#: ../../library/decimal.rst:548
msgid ""
"Return the negation of the argument.  This operation is unaffected by the "
"context and is quiet: no flags are changed and no rounding is performed."
msgstr ""
"Вернуть отрицание аргумента. На эту операцию не влияет контекст, и она "
"выполняется тихо: флаги не изменяются и округление не выполняется."

#: ../../library/decimal.rst:553
msgid ""
"Return a copy of the first operand with the sign set to be the same as the "
"sign of the second operand.  For example:"
msgstr ""
"Верните копию первого операнда со знаком, совпадающим со знаком второго "
"операнда. Например:"

#: ../../library/decimal.rst:565
msgid ""
"Return the value of the (natural) exponential function ``e**x`` at the given "
"number.  The result is correctly rounded using the :const:`ROUND_HALF_EVEN` "
"rounding mode."
msgstr ""
"Возвращает значение (натуральной) экспоненциальной функции ``e**x`` по "
"заданному номеру. Результат правильно округляется с использованием режима "
"округления :const:`ROUND_HALF_EVEN`."

#: ../../library/decimal.rst:576
msgid ""
"Alternative constructor that only accepts instances of :class:`float` or :"
"class:`int`."
msgstr ""
"Альтернативный конструктор, который принимает только экземпляры :class:"
"`float` или :class:`int`."

#: ../../library/decimal.rst:579
msgid ""
"Note ``Decimal.from_float(0.1)`` is not the same as ``Decimal('0.1')``. "
"Since 0.1 is not exactly representable in binary floating point, the value "
"is stored as the nearest representable value which is "
"``0x1.999999999999ap-4``.  That equivalent value in decimal is "
"``0.1000000000000000055511151231257827021181583404541015625``."
msgstr ""
"Обратите внимание: ``Decimal.from_float(0.1)`` — это не то же самое, что "
"``Decimal('0.1')``. Поскольку 0,1 не совсем представимо в двоичном виде с "
"плавающей запятой, значение сохраняется как ближайшее представимое значение, "
"которое равно ``0x1.999999999999ap-4``. Это эквивалентное десятичное "
"значение равно ``0,1000000000000000055511151231257827021181583404541015625``."

#: ../../library/decimal.rst:585
msgid ""
"From Python 3.2 onwards, a :class:`Decimal` instance can also be constructed "
"directly from a :class:`float`."
msgstr ""
"Начиная с Python 3.2, экземпляр :class:`Decimal` также может быть создан "
"непосредственно из :class:`float`."

#: ../../library/decimal.rst:603
msgid ""
"Fused multiply-add.  Return self*other+third with no rounding of the "
"intermediate product self*other."
msgstr ""
"Слитое умножение-сложение. Вернуть self*other+ Third без округления "
"промежуточного продукта self*other."

#: ../../library/decimal.rst:611
msgid ""
"Return :const:`True` if the argument is canonical and :const:`False` "
"otherwise.  Currently, a :class:`Decimal` instance is always canonical, so "
"this operation always returns :const:`True`."
msgstr ""
"Верните :const:`True`, если аргумент канонический, и :const:`False` в "
"противном случае. В настоящее время экземпляр :class:`Decimal` всегда "
"является каноническим, поэтому эта операция всегда возвращает :const:`True`."

#: ../../library/decimal.rst:617
msgid ""
"Return :const:`True` if the argument is a finite number, and :const:`False` "
"if the argument is an infinity or a NaN."
msgstr ""
"Верните :const:`True`, если аргумент является конечным числом, и :const:"
"`False`, если аргумент является бесконечностью или NaN."

#: ../../library/decimal.rst:622
msgid ""
"Return :const:`True` if the argument is either positive or negative infinity "
"and :const:`False` otherwise."
msgstr ""
"Верните :const:`True`, если аргумент имеет положительную или отрицательную "
"бесконечность, и :const:`False` в противном случае."

#: ../../library/decimal.rst:627
msgid ""
"Return :const:`True` if the argument is a (quiet or signaling) NaN and :"
"const:`False` otherwise."
msgstr ""
"Верните :const:`True`, если аргумент имеет значение NaN (тихое или "
"сигнальное), и :const:`False` в противном случае."

#: ../../library/decimal.rst:632
msgid ""
"Return :const:`True` if the argument is a *normal* finite number.  Return :"
"const:`False` if the argument is zero, subnormal, infinite or a NaN."
msgstr ""
"Верните :const:`True`, если аргумент является *нормальным* конечным числом. "
"Верните :const:`False`, если аргумент равен нулю, субнормальному, "
"бесконечному или NaN."

#: ../../library/decimal.rst:637
msgid ""
"Return :const:`True` if the argument is a quiet NaN, and :const:`False` "
"otherwise."
msgstr ""
"Верните :const:`True`, если аргументом является тихое значение NaN, и :const:"
"`False` в противном случае."

#: ../../library/decimal.rst:642
msgid ""
"Return :const:`True` if the argument has a negative sign and :const:`False` "
"otherwise.  Note that zeros and NaNs can both carry signs."
msgstr ""
"Верните :const:`True`, если аргумент имеет отрицательный знак, и :const:"
"`False` в противном случае. Обратите внимание, что нули и NaN могут иметь "
"знаки."

#: ../../library/decimal.rst:647
msgid ""
"Return :const:`True` if the argument is a signaling NaN and :const:`False` "
"otherwise."
msgstr ""
"Верните :const:`True`, если аргумент является сигнальным NaN, и :const:"
"`False` в противном случае."

#: ../../library/decimal.rst:652
msgid ""
"Return :const:`True` if the argument is subnormal, and :const:`False` "
"otherwise."
msgstr ""
"Верните :const:`True`, если аргумент ненормальный, и :const:`False` в "
"противном случае."

#: ../../library/decimal.rst:657
msgid ""
"Return :const:`True` if the argument is a (positive or negative) zero and :"
"const:`False` otherwise."
msgstr ""
"Верните :const:`True`, если аргумент представляет собой ноль (положительный "
"или отрицательный), и :const:`False` в противном случае."

#: ../../library/decimal.rst:662
msgid ""
"Return the natural (base e) logarithm of the operand.  The result is "
"correctly rounded using the :const:`ROUND_HALF_EVEN` rounding mode."
msgstr ""
"Возвращает натуральный логарифм (по основанию e) операнда. Результат "
"правильно округляется с использованием режима округления :const:"
"`ROUND_HALF_EVEN`."

#: ../../library/decimal.rst:667
msgid ""
"Return the base ten logarithm of the operand.  The result is correctly "
"rounded using the :const:`ROUND_HALF_EVEN` rounding mode."
msgstr ""
"Возвращает десятичный логарифм операнда. Результат правильно округляется с "
"использованием режима округления :const:`ROUND_HALF_EVEN`."

#: ../../library/decimal.rst:672
msgid ""
"For a nonzero number, return the adjusted exponent of its operand as a :"
"class:`Decimal` instance.  If the operand is a zero then ``Decimal('-"
"Infinity')`` is returned and the :const:`DivisionByZero` flag is raised.  If "
"the operand is an infinity then ``Decimal('Infinity')`` is returned."
msgstr ""
"Для ненулевого числа верните скорректированную степень его операнда в виде "
"экземпляра :class:`Decimal`. Если операнд равен нулю, то возвращается "
"``Decimal('-Infinity')`` и поднимается флаг :const:`DivisionByZero`. Если "
"операнд является бесконечностью, возвращается ``Decimal('Infinity')``."

#: ../../library/decimal.rst:680
msgid ""
":meth:`logical_and` is a logical operation which takes two *logical "
"operands* (see :ref:`logical_operands_label`).  The result is the digit-wise "
"``and`` of the two operands."
msgstr ""
":meth:`ological_and` — это логическая операция, которая принимает два "
"*логических операнда* (см. :ref:`ological_operands_label`). Результатом "
"является поразрядное «и» двух операндов."

#: ../../library/decimal.rst:686
msgid ""
":meth:`logical_invert` is a logical operation.  The result is the digit-wise "
"inversion of the operand."
msgstr ""
":meth:`ologic_invert` — это логическая операция. Результатом является "
"поразрядная инверсия операнда."

#: ../../library/decimal.rst:691
msgid ""
":meth:`logical_or` is a logical operation which takes two *logical operands* "
"(see :ref:`logical_operands_label`).  The result is the digit-wise ``or`` of "
"the two operands."
msgstr ""
":meth:`логическое_или` — это логическая операция, которая принимает два "
"*логических операнда* (см. :ref:`ological_operands_label`). Результатом "
"является поразрядное «или» двух операндов."

#: ../../library/decimal.rst:697
msgid ""
":meth:`logical_xor` is a logical operation which takes two *logical "
"operands* (see :ref:`logical_operands_label`).  The result is the digit-wise "
"exclusive or of the two operands."
msgstr ""
":meth:`ological_xor` — это логическая операция, которая принимает два "
"*логических операнда* (см. :ref:`ological_operands_label`). Результатом "
"является исключающее число или из двух операндов."

#: ../../library/decimal.rst:703
msgid ""
"Like ``max(self, other)`` except that the context rounding rule is applied "
"before returning and that ``NaN`` values are either signaled or ignored "
"(depending on the context and whether they are signaling or quiet)."
msgstr ""
"Подобно ``max(self,other)``, за исключением того, что правило округления "
"контекста применяется перед возвратом и что значения ``NaN`` либо "
"сигнализируются, либо игнорируются (в зависимости от контекста и от того, "
"сигнализируют они или молчат)."

#: ../../library/decimal.rst:710
msgid ""
"Similar to the :meth:`.max` method, but the comparison is done using the "
"absolute values of the operands."
msgstr ""
"Аналогичен методу :meth:`.max`, но сравнение выполняется с использованием "
"абсолютных значений операндов."

#: ../../library/decimal.rst:715
msgid ""
"Like ``min(self, other)`` except that the context rounding rule is applied "
"before returning and that ``NaN`` values are either signaled or ignored "
"(depending on the context and whether they are signaling or quiet)."
msgstr ""
"Подобно ``min(self,other)``, за исключением того, что правило округления "
"контекста применяется перед возвратом и что значения ``NaN`` либо "
"сигнализируются, либо игнорируются (в зависимости от контекста и от того, "
"сигнализируют они или молчат)."

#: ../../library/decimal.rst:722
msgid ""
"Similar to the :meth:`.min` method, but the comparison is done using the "
"absolute values of the operands."
msgstr ""
"Аналогичен методу :meth:`.min`, но сравнение выполняется с использованием "
"абсолютных значений операндов."

#: ../../library/decimal.rst:727
msgid ""
"Return the largest number representable in the given context (or in the "
"current thread's context if no context is given) that is smaller than the "
"given operand."
msgstr ""
"Возвращает наибольшее число, представимое в данном контексте (или в "
"контексте текущего потока, если контекст не указан), которое меньше "
"заданного операнда."

#: ../../library/decimal.rst:733
msgid ""
"Return the smallest number representable in the given context (or in the "
"current thread's context if no context is given) that is larger than the "
"given operand."
msgstr ""
"Возвращает наименьшее число, которое можно представить в данном контексте "
"(или в контексте текущего потока, если контекст не указан), которое больше "
"заданного операнда."

#: ../../library/decimal.rst:739
msgid ""
"If the two operands are unequal, return the number closest to the first "
"operand in the direction of the second operand.  If both operands are "
"numerically equal, return a copy of the first operand with the sign set to "
"be the same as the sign of the second operand."
msgstr ""
"Если два операнда не равны, верните число, ближайшее к первому операнду, в "
"направлении второго операнда. Если оба операнда численно равны, верните "
"копию первого операнда со знаком, совпадающим со знаком второго операнда."

#: ../../library/decimal.rst:746
msgid ""
"Used for producing canonical values of an equivalence class within either "
"the current context or the specified context."
msgstr ""
"Используется для создания канонических значений класса эквивалентности либо "
"в текущем контексте, либо в указанном контексте."

#: ../../library/decimal.rst:749
msgid ""
"This has the same semantics as the unary plus operation, except that if the "
"final result is finite it is reduced to its simplest form, with all trailing "
"zeros removed and its sign preserved. That is, while the coefficient is non-"
"zero and a multiple of ten the coefficient is divided by ten and the "
"exponent is incremented by 1. Otherwise (the coefficient is zero) the "
"exponent is set to 0. In all cases the sign is unchanged."
msgstr ""
"Она имеет ту же семантику, что и операция унарного плюса, за исключением "
"того, что, если конечный результат конечен, она сводится к простейшей форме, "
"при этом удаляются все конечные нули и сохраняется ее знак. То есть, пока "
"коэффициент ненулевой и кратен десяти, коэффициент делится на десять и "
"показатель степени увеличивается на 1. В противном случае (коэффициент равен "
"нулю) показатель степени устанавливается равным 0. Во всех случаях знак не "
"меняется. ."

#: ../../library/decimal.rst:756
msgid ""
"For example, ``Decimal('32.100')`` and ``Decimal('0.321000e+2')`` both "
"normalize to the equivalent value ``Decimal('32.1')``."
msgstr ""
"Например, ``Decimal('32.100')`` и ``Decimal('0.321000e+2')`` оба "
"нормализуются до эквивалентного значения ``Decimal('32.1')``."

#: ../../library/decimal.rst:759
msgid "Note that rounding is applied *before* reducing to simplest form."
msgstr ""
"Обратите внимание, что округление применяется *до* приведения к простейшей "
"форме."

#: ../../library/decimal.rst:761
msgid ""
"In the latest versions of the specification, this operation is also known as "
"``reduce``."
msgstr ""
"В последних версиях спецификации эта операция также известна как "
"«сокращение»."

#: ../../library/decimal.rst:766
msgid ""
"Return a string describing the *class* of the operand.  The returned value "
"is one of the following ten strings."
msgstr ""
"Возвращает строку, описывающую *класс* операнда. Возвращаемое значение — "
"одна из следующих десяти строк."

#: ../../library/decimal.rst:769
msgid "``\"-Infinity\"``, indicating that the operand is negative infinity."
msgstr ""
"``\"-Infinity\"``, указывающий, что операнд имеет отрицательную "
"бесконечность."

#: ../../library/decimal.rst:770
msgid ""
"``\"-Normal\"``, indicating that the operand is a negative normal number."
msgstr ""
"``\"-Normal\"``, указывающий, что операнд является отрицательным нормальным "
"числом."

#: ../../library/decimal.rst:771
msgid ""
"``\"-Subnormal\"``, indicating that the operand is negative and subnormal."
msgstr ""
"``\"-Subnormal\"``, указывающий, что операнд отрицательный и ненормальный."

#: ../../library/decimal.rst:772
msgid "``\"-Zero\"``, indicating that the operand is a negative zero."
msgstr "``\"-Zero\"``, указывающий, что операнд является отрицательным нулем."

#: ../../library/decimal.rst:773
msgid "``\"+Zero\"``, indicating that the operand is a positive zero."
msgstr "``\"+Zero\"``, указывающий, что операнд является положительным нулем."

#: ../../library/decimal.rst:774
msgid ""
"``\"+Subnormal\"``, indicating that the operand is positive and subnormal."
msgstr ""
"``\"+Субнормальный\"``, указывающий, что операнд положительный и "
"субнормальный."

#: ../../library/decimal.rst:775
msgid ""
"``\"+Normal\"``, indicating that the operand is a positive normal number."
msgstr ""
"``\"+Normal\"``, указывающий, что операнд является положительным нормальным "
"числом."

#: ../../library/decimal.rst:776
msgid "``\"+Infinity\"``, indicating that the operand is positive infinity."
msgstr ""
"``\"+Infinity\"``, указывающий, что операнд имеет положительную "
"бесконечность."

#: ../../library/decimal.rst:777
msgid "``\"NaN\"``, indicating that the operand is a quiet NaN (Not a Number)."
msgstr ""
"``\"NaN\"``, указывающий, что операнд является молчаливым NaN (не числом)."

#: ../../library/decimal.rst:778
msgid "``\"sNaN\"``, indicating that the operand is a signaling NaN."
msgstr "``\"sNaN\"``, указывающий, что операнд является сигнальным NaN."

#: ../../library/decimal.rst:782
msgid ""
"Return a value equal to the first operand after rounding and having the "
"exponent of the second operand."
msgstr ""
"Возвращает значение, равное первому операнду после округления и имеющее "
"показатель степени второго операнда."

#: ../../library/decimal.rst:788
msgid ""
"Unlike other operations, if the length of the coefficient after the quantize "
"operation would be greater than precision, then an :const:`InvalidOperation` "
"is signaled. This guarantees that, unless there is an error condition, the "
"quantized exponent is always equal to that of the right-hand operand."
msgstr ""
"В отличие от других операций, если длина коэффициента после операции "
"квантования превышает точность, то сигнализируется :const:"
"`InvalidOperation`. Это гарантирует, что, если не возникнет ошибка, "
"квантованная экспонента всегда равна экспоненте правого операнда."

#: ../../library/decimal.rst:794
msgid ""
"Also unlike other operations, quantize never signals Underflow, even if the "
"result is subnormal and inexact."
msgstr ""
"Кроме того, в отличие от других операций, квантование никогда не "
"сигнализирует о недостаточном переполнении, даже если результат ненормальный "
"и неточный."

#: ../../library/decimal.rst:797
msgid ""
"If the exponent of the second operand is larger than that of the first then "
"rounding may be necessary.  In this case, the rounding mode is determined by "
"the ``rounding`` argument if given, else by the given ``context`` argument; "
"if neither argument is given the rounding mode of the current thread's "
"context is used."
msgstr ""
"Если показатель степени второго операнда больше показателя степени первого, "
"то может потребоваться округление. В этом случае режим округления "
"определяется аргументом округления, если он задан, в противном случае — "
"заданным аргументом контекста; если ни один аргумент не указан, используется "
"режим округления контекста текущего потока."

#: ../../library/decimal.rst:803
msgid ""
"An error is returned whenever the resulting exponent is greater than :attr:"
"`~Context.Emax` or less than :meth:`~Context.Etiny`."
msgstr ""
"Ошибка возвращается всякий раз, когда результирующий показатель степени "
"больше :attr:`~Context.Emax` или меньше :meth:`~Context.Etiny`."

#: ../../library/decimal.rst:808
msgid ""
"Return ``Decimal(10)``, the radix (base) in which the :class:`Decimal` class "
"does all its arithmetic.  Included for compatibility with the specification."
msgstr ""
"Возвращает ``Decimal(10)``, систему счисления (основание), в которой класс :"
"class:`Decimal` выполняет всю свою арифметику. Включено для совместимости со "
"спецификацией."

#: ../../library/decimal.rst:814
msgid ""
"Return the remainder from dividing *self* by *other*.  This differs from "
"``self % other`` in that the sign of the remainder is chosen so as to "
"minimize its absolute value.  More precisely, the return value is ``self - n "
"* other`` where ``n`` is the integer nearest to the exact value of ``self / "
"other``, and if two integers are equally near then the even one is chosen."
msgstr ""
"Вернуть остаток от деления *self* на *other*. Это отличается от «self "
"%other» тем, что знак остатка выбирается так, чтобы минимизировать его "
"абсолютное значение. Точнее, возвращаемое значение — ``self - n *other``, "
"где ``n`` — целое число, ближайшее к точному значению ``self/other``, и если "
"два целых числа одинаково близки, то четное выбран."

#: ../../library/decimal.rst:821
msgid "If the result is zero then its sign will be the sign of *self*."
msgstr "Если результат равен нулю, то его знаком будет знак *self*."

#: ../../library/decimal.rst:832
msgid ""
"Return the result of rotating the digits of the first operand by an amount "
"specified by the second operand.  The second operand must be an integer in "
"the range -precision through precision.  The absolute value of the second "
"operand gives the number of places to rotate.  If the second operand is "
"positive then rotation is to the left; otherwise rotation is to the right. "
"The coefficient of the first operand is padded on the left with zeros to "
"length precision if necessary.  The sign and exponent of the first operand "
"are unchanged."
msgstr ""
"Возвращает результат вращения цифр первого операнда на величину, указанную "
"вторым операндом. Второй операнд должен быть целым числом в диапазоне от "
"точности до точности. Абсолютное значение второго операнда дает количество "
"мест для вращения. Если второй операнд положительный, то вращение происходит "
"влево; в противном случае вращение происходит вправо. Коэффициент первого "
"операнда при необходимости дополняется слева нулями для точности длины. Знак "
"и показатель степени первого операнда не изменяются."

#: ../../library/decimal.rst:843
msgid ""
"Test whether self and other have the same exponent or whether both are "
"``NaN``."
msgstr ""
"Проверьте, имеют ли я и другие одинаковый показатель степени или оба "
"являются ``NaN``."

#: ../../library/decimal.rst:852
msgid ""
"Return the first operand with exponent adjusted by the second. Equivalently, "
"return the first operand multiplied by ``10**other``.  The second operand "
"must be an integer."
msgstr ""
"Верните первый операнд с показателем степени, скорректированным вторым. "
"Аналогично, верните первый операнд, умноженный на ``10**other``. Второй "
"операнд должен быть целым числом."

#: ../../library/decimal.rst:858
msgid ""
"Return the result of shifting the digits of the first operand by an amount "
"specified by the second operand.  The second operand must be an integer in "
"the range -precision through precision.  The absolute value of the second "
"operand gives the number of places to shift.  If the second operand is "
"positive then the shift is to the left; otherwise the shift is to the "
"right.  Digits shifted into the coefficient are zeros.  The sign and "
"exponent of the first operand are unchanged."
msgstr ""
"Возвращает результат сдвига цифр первого операнда на величину, указанную "
"вторым операндом. Второй операнд должен быть целым числом в диапазоне от "
"точности до точности. Абсолютное значение второго операнда дает количество "
"мест для сдвига. Если второй операнд положительный, то сдвиг происходит "
"влево; в противном случае сдвиг происходит вправо. Цифры, вставленные в "
"коэффициент, являются нулями. Знак и показатель степени первого операнда не "
"изменяются."

#: ../../library/decimal.rst:868
msgid "Return the square root of the argument to full precision."
msgstr "Верните квадратный корень аргумента с полной точностью."

#: ../../library/decimal.rst:873 ../../library/decimal.rst:1468
msgid ""
"Convert to a string, using engineering notation if an exponent is needed."
msgstr ""
"Преобразуйте в строку, используя инженерную нотацию, если требуется "
"показатель степени."

#: ../../library/decimal.rst:875 ../../library/decimal.rst:1470
msgid ""
"Engineering notation has an exponent which is a multiple of 3.  This can "
"leave up to 3 digits to the left of the decimal place and may require the "
"addition of either one or two trailing zeros."
msgstr ""
"В инженерных обозначениях показатель степени кратен 3. При этом слева от "
"десятичного знака может оставаться до 3 цифр, и может потребоваться "
"добавление одного или двух конечных нулей."

#: ../../library/decimal.rst:879
msgid ""
"For example, this converts ``Decimal('123E+1')`` to ``Decimal('1.23E+3')``."
msgstr ""
"Например, это преобразует ``Decimal('123E+1')`` в ``Decimal('1.23E+3')``."

#: ../../library/decimal.rst:883
msgid ""
"Identical to the :meth:`to_integral_value` method.  The ``to_integral`` name "
"has been kept for compatibility with older versions."
msgstr ""
"Идентичен методу :meth:`to_integral_value`. Имя to_integral сохранено для "
"совместимости со старыми версиями."

#: ../../library/decimal.rst:888
msgid ""
"Round to the nearest integer, signaling :const:`Inexact` or :const:`Rounded` "
"as appropriate if rounding occurs.  The rounding mode is determined by the "
"``rounding`` parameter if given, else by the given ``context``.  If neither "
"parameter is given then the rounding mode of the current context is used."
msgstr ""
"Округлите до ближайшего целого числа, сигнализируя :const:`Inexact` или :"
"const:`Rounded` в зависимости от ситуации, если происходит округление. Режим "
"округления определяется параметром округления, если он задан, в противном "
"случае — заданным контекстом. Если ни один из параметров не указан, "
"используется режим округления текущего контекста."

#: ../../library/decimal.rst:896
msgid ""
"Round to the nearest integer without signaling :const:`Inexact` or :const:"
"`Rounded`.  If given, applies *rounding*; otherwise, uses the rounding "
"method in either the supplied *context* or the current context."
msgstr ""
"Округлите до ближайшего целого числа, не сигнализируя :const:`Inexact` или :"
"const:`Rounded`. Если задано, применяется *округление*; в противном случае "
"используется метод округления либо в предоставленном *контексте*, либо в "
"текущем контексте."

#: ../../library/decimal.rst:904
msgid "Logical operands"
msgstr "Логические операнды"

#: ../../library/decimal.rst:906
msgid ""
"The :meth:`~Decimal.logical_and`, :meth:`~Decimal.logical_invert`, :meth:"
"`~Decimal.logical_or`, and :meth:`~Decimal.logical_xor` methods expect their "
"arguments to be *logical operands*.  A *logical operand* is a :class:"
"`Decimal` instance whose exponent and sign are both zero, and whose digits "
"are all either ``0`` or ``1``."
msgstr ""
"Методы :meth:`~Decimal.ological_and`, :meth:`~Decimal.ological_invert`, :"
"meth:`~Decimal.ological_or` и :meth:`~Decimal.ological_xor` ожидают, что их "
"аргументы будут *логическими операндами. *. *Логический операнд* — это "
"экземпляр :class:`Decimal`, показатель степени и знак которого равны нулю, а "
"все цифры равны либо ``0``, либо ``1``."

#: ../../library/decimal.rst:918
msgid "Context objects"
msgstr "контекст объекты"

#: ../../library/decimal.rst:920
msgid ""
"Contexts are environments for arithmetic operations.  They govern precision, "
"set rules for rounding, determine which signals are treated as exceptions, "
"and limit the range for exponents."
msgstr ""
"Контексты — это среды для арифметических операций. Они управляют точностью, "
"устанавливают правила округления, определяют, какие сигналы считаются "
"исключениями, и ограничивают диапазон показателей степени."

#: ../../library/decimal.rst:924
msgid ""
"Each thread has its own current context which is accessed or changed using "
"the :func:`getcontext` and :func:`setcontext` functions:"
msgstr ""
"Каждый поток имеет свой собственный текущий контекст, доступ к которому или "
"его изменение осуществляется с помощью функций :func:`getcontext` и :func:"
"`setcontext`:"

#: ../../library/decimal.rst:930
msgid "Return the current context for the active thread."
msgstr "Верните текущий контекст для активного потока."

#: ../../library/decimal.rst:935
msgid "Set the current context for the active thread to *c*."
msgstr "Установите текущий контекст для активного потока на *c*."

#: ../../library/decimal.rst:937
msgid ""
"You can also use the :keyword:`with` statement and the :func:`localcontext` "
"function to temporarily change the active context."
msgstr ""
"Вы также можете использовать оператор :keyword:`with` и функцию :func:"
"`localcontext` для временного изменения активного контекста."

#: ../../library/decimal.rst:942
msgid ""
"Return a context manager that will set the current context for the active "
"thread to a copy of *ctx* on entry to the with-statement and restore the "
"previous context when exiting the with-statement. If no context is "
"specified, a copy of the current context is used.  The *kwargs* argument is "
"used to set the attributes of the new context."
msgstr ""
"Возвращает менеджер контекста, который установит текущий контекст для "
"активного потока в копию *ctx* при входе в оператор with и восстановит "
"предыдущий контекст при выходе из оператора with. Если контекст не указан, "
"используется копия текущего контекста. Аргумент *kwargs* используется для "
"установки атрибутов нового контекста."

#: ../../library/decimal.rst:948
msgid ""
"For example, the following code sets the current decimal precision to 42 "
"places, performs a calculation, and then automatically restores the previous "
"context::"
msgstr ""
"Например, следующий код устанавливает текущую десятичную точность до 42 "
"знаков, выполняет расчет, а затем автоматически восстанавливает предыдущий "
"контекст:"

#: ../../library/decimal.rst:958
msgid "Using keyword arguments, the code would be the following::"
msgstr "Используя аргументы ключевого слова, код будет следующим:"

#: ../../library/decimal.rst:966
msgid ""
"Raises :exc:`TypeError` if *kwargs* supplies an attribute that :class:"
"`Context` doesn't support.  Raises either :exc:`TypeError` or :exc:"
"`ValueError` if *kwargs* supplies an invalid value for an attribute."
msgstr ""
"Вызывает :exc:`TypeError`, если *kwargs* предоставляет атрибут, который :"
"class:`Context` не поддерживает. Вызывает либо :exc:`TypeError`, либо :exc:"
"`ValueError`, если *kwargs* предоставляет недопустимое значение для атрибута."

#: ../../library/decimal.rst:970
msgid ""
":meth:`localcontext` now supports setting context attributes through the use "
"of keyword arguments."
msgstr ""
":meth:`localcontext` теперь поддерживает настройку атрибутов контекста с "
"помощью аргументов ключевого слова."

#: ../../library/decimal.rst:973
msgid ""
"New contexts can also be created using the :class:`Context` constructor "
"described below. In addition, the module provides three pre-made contexts:"
msgstr ""
"Новые контексты также можно создавать с помощью конструктора :class:"
"`Context`, описанного ниже. Кроме того, модуль предоставляет три готовых "
"контекста:"

#: ../../library/decimal.rst:979
msgid ""
"This is a standard context defined by the General Decimal Arithmetic "
"Specification.  Precision is set to nine.  Rounding is set to :const:"
"`ROUND_HALF_UP`.  All flags are cleared.  All traps are enabled (treated as "
"exceptions) except :const:`Inexact`, :const:`Rounded`, and :const:"
"`Subnormal`."
msgstr ""
"Это стандартный контекст, определенный Спецификацией общей десятичной "
"арифметики. Точность установлена ​​на девять. Для округления установлено "
"значение :const:`ROUND_HALF_UP`. Все флаги сброшены. Все ловушки включены "
"(расцениваются как исключения), кроме :const:`Inexact`, :const:`Rounded` и :"
"const:`Subnormal`."

#: ../../library/decimal.rst:985
msgid ""
"Because many of the traps are enabled, this context is useful for debugging."
msgstr "Поскольку многие ловушки включены, этот контекст полезен для отладки."

#: ../../library/decimal.rst:990
msgid ""
"This is a standard context defined by the General Decimal Arithmetic "
"Specification.  Precision is set to nine.  Rounding is set to :const:"
"`ROUND_HALF_EVEN`.  All flags are cleared.  No traps are enabled (so that "
"exceptions are not raised during computations)."
msgstr ""
"Это стандартный контекст, определенный Спецификацией общей десятичной "
"арифметики. Точность установлена ​​на девять. Для округления установлено "
"значение :const:`ROUND_HALF_EVEN`. Все флаги сброшены. Никаких ловушек не "
"включено (чтобы во время вычислений не возникало исключений)."

#: ../../library/decimal.rst:995
msgid ""
"Because the traps are disabled, this context is useful for applications that "
"prefer to have result value of ``NaN`` or ``Infinity`` instead of raising "
"exceptions.  This allows an application to complete a run in the presence of "
"conditions that would otherwise halt the program."
msgstr ""
"Поскольку ловушки отключены, этот контекст полезен для приложений, которые "
"предпочитают иметь значение результата «NaN» или «Бесконечность» вместо "
"создания исключений. Это позволяет приложению завершить работу при наличии "
"условий, которые в противном случае остановили бы программу."

#: ../../library/decimal.rst:1003
msgid ""
"This context is used by the :class:`Context` constructor as a prototype for "
"new contexts.  Changing a field (such a precision) has the effect of "
"changing the default for new contexts created by the :class:`Context` "
"constructor."
msgstr ""
"Этот контекст используется конструктором :class:`Context` в качестве "
"прототипа для новых контекстов. Изменение поля (такая точность) приводит к "
"изменению значения по умолчанию для новых контекстов, созданных "
"конструктором :class:`Context`."

#: ../../library/decimal.rst:1007
msgid ""
"This context is most useful in multi-threaded environments.  Changing one of "
"the fields before threads are started has the effect of setting system-wide "
"defaults.  Changing the fields after threads have started is not recommended "
"as it would require thread synchronization to prevent race conditions."
msgstr ""
"Этот контекст наиболее полезен в многопоточных средах. Изменение одного из "
"полей до запуска потоков приводит к установке общесистемных значений по "
"умолчанию. Изменение полей после запуска потоков не рекомендуется, так как "
"для предотвращения состояний гонки потребуется синхронизация потоков."

#: ../../library/decimal.rst:1012
msgid ""
"In single threaded environments, it is preferable to not use this context at "
"all.  Instead, simply create contexts explicitly as described below."
msgstr ""
"В однопоточных средах предпочтительно вообще не использовать этот контекст. "
"Вместо этого просто создайте контексты явно, как описано ниже."

#: ../../library/decimal.rst:1015
msgid ""
"The default values are :attr:`Context.prec`\\ =\\ ``28``, :attr:`Context."
"rounding`\\ =\\ :const:`ROUND_HALF_EVEN`, and enabled traps for :class:"
"`Overflow`, :class:`InvalidOperation`, and :class:`DivisionByZero`."
msgstr ""
"Значения по умолчанию: :attr:`Context.prec`\\ =\\ ``28``, :attr:`Context."
"rounding`\\ =\\ :const:`ROUND_HALF_EVEN` и включенные ловушки для :class:"
"`Overflow`, :class:`InvalidOperation` и :class:`DivisionByZero`."

#: ../../library/decimal.rst:1020
msgid ""
"In addition to the three supplied contexts, new contexts can be created with "
"the :class:`Context` constructor."
msgstr ""
"В дополнение к трем предоставленным контекстам, новые контексты могут быть "
"созданы с помощью конструктора :class:`Context`."

#: ../../library/decimal.rst:1026
msgid ""
"Creates a new context.  If a field is not specified or is :const:`None`, the "
"default values are copied from the :const:`DefaultContext`.  If the *flags* "
"field is not specified or is :const:`None`, all flags are cleared."
msgstr ""
"Создает новый контекст. Если поле не указано или имеет значение :const:"
"`None`, значения по умолчанию копируются из :const:`DefaultContext`. Если "
"поле *flags* не указано или имеет значение :const:`None`, все флаги "
"очищаются."

#: ../../library/decimal.rst:1030
msgid ""
"*prec* is an integer in the range [``1``, :const:`MAX_PREC`] that sets the "
"precision for arithmetic operations in the context."
msgstr ""
"*prec* — целое число в диапазоне [``1``, :const:`MAX_PREC`], которое "
"устанавливает точность для арифметических операций в контексте."

#: ../../library/decimal.rst:1033
msgid ""
"The *rounding* option is one of the constants listed in the section "
"`Rounding Modes`_."
msgstr ""
"Параметр *rounding* — это одна из констант, перечисленных в разделе «Режимы "
"округления»."

#: ../../library/decimal.rst:1036
msgid ""
"The *traps* and *flags* fields list any signals to be set. Generally, new "
"contexts should only set traps and leave the flags clear."
msgstr ""
"В полях *trap* и *flags* перечислены все сигналы, которые необходимо "
"установить. Как правило, в новых контекстах следует только устанавливать "
"ловушки и оставлять флаги незамеченными."

#: ../../library/decimal.rst:1039
msgid ""
"The *Emin* and *Emax* fields are integers specifying the outer limits "
"allowable for exponents. *Emin* must be in the range [:const:`MIN_EMIN`, "
"``0``], *Emax* in the range [``0``, :const:`MAX_EMAX`]."
msgstr ""
"Поля *Emin* и *Emax* представляют собой целые числа, определяющие внешние "
"пределы, допустимые для экспонент. *Emin* должен находиться в диапазоне [:"
"const:`MIN_EMIN`, ``0``], *Emax* в диапазоне [``0``, :const:`MAX_EMAX`]."

#: ../../library/decimal.rst:1043
msgid ""
"The *capitals* field is either ``0`` or ``1`` (the default). If set to "
"``1``, exponents are printed with a capital ``E``; otherwise, a lowercase "
"``e`` is used: ``Decimal('6.02e+23')``."
msgstr ""
"Поле *capitals* имеет значение «0» или «1» (по умолчанию). Если установлено "
"значение «1», показатели степени печатаются с заглавной буквы «E»; в "
"противном случае используется строчная буква ``e``: ``Decimal('6.02e+23')``."

#: ../../library/decimal.rst:1047
msgid ""
"The *clamp* field is either ``0`` (the default) or ``1``. If set to ``1``, "
"the exponent ``e`` of a :class:`Decimal` instance representable in this "
"context is strictly limited to the range ``Emin - prec + 1 <= e <= Emax - "
"prec + 1``.  If *clamp* is ``0`` then a weaker condition holds: the adjusted "
"exponent of the :class:`Decimal` instance is at most :attr:`~Context.Emax`.  "
"When *clamp* is ``1``, a large normal number will, where possible, have its "
"exponent reduced and a corresponding number of zeros added to its "
"coefficient, in order to fit the exponent constraints; this preserves the "
"value of the number but loses information about significant trailing zeros.  "
"For example::"
msgstr ""
"Поле *clamp* имеет значение либо ``0`` (по умолчанию), либо ``1``. Если "
"установлено значение ``1``, показатель степени ``e`` экземпляра :class:"
"`Decimal`, представленного в этом контексте, строго ограничен диапазоном "
"``Emin - prec + 1 <= e <= Emax - prec + 1``. Если *clamp* равен ``0``, тогда "
"выполняется более слабое условие: скорректированная экспонента экземпляра :"
"class:`Decimal` не превышает :attr:`~Context.Emax`. Когда *clamp* равен "
"``1``, для большого нормального числа, где это возможно, показатель степени "
"будет уменьшен, а к его коэффициенту добавлено соответствующее количество "
"нулей, чтобы соответствовать ограничениям показателя степени; при этом "
"сохраняется значение числа, но теряется информация о значимых конечных "
"нулях. Например::"

#: ../../library/decimal.rst:1062
msgid ""
"A *clamp* value of ``1`` allows compatibility with the fixed-width decimal "
"interchange formats specified in IEEE 754."
msgstr ""
"Значение *clamp*, равное ``1``, обеспечивает совместимость с десятичными "
"форматами обмена фиксированной шириной, указанными в IEEE 754."

#: ../../library/decimal.rst:1065
msgid ""
"The :class:`Context` class defines several general purpose methods as well "
"as a large number of methods for doing arithmetic directly in a given "
"context. In addition, for each of the :class:`Decimal` methods described "
"above (with the exception of the :meth:`~Decimal.adjusted` and :meth:"
"`~Decimal.as_tuple` methods) there is a corresponding :class:`Context` "
"method.  For example, for a :class:`Context` instance ``C`` and :class:"
"`Decimal` instance ``x``, ``C.exp(x)`` is equivalent to ``x."
"exp(context=C)``.  Each :class:`Context` method accepts a Python integer (an "
"instance of :class:`int`) anywhere that a Decimal instance is accepted."
msgstr ""
"Класс :class:`Context` определяет несколько методов общего назначения, а "
"также большое количество методов для выполнения арифметических действий "
"непосредственно в заданном контексте. Кроме того, для каждого из описанных "
"выше методов :class:`Decimal` (за исключением методов :meth:`~Decimal."
"adjusted` и :meth:`~Decimal.as_tuple`) существует соответствующий :class: "
"Метод «Контекст». Например, для экземпляра :class:`Context` ``C`` и :class:"
"`Decimal` экземпляра ``x``, ``C.exp(x)`` эквивалентен ``x."
"exp( контекст=C)``. Каждый метод :class:`Context` принимает целое число "
"Python (экземпляр :class:`int`) везде, где принимается экземпляр Decimal."

#: ../../library/decimal.rst:1078
msgid "Resets all of the flags to ``0``."
msgstr "Сбрасывает все флаги в «0»."

#: ../../library/decimal.rst:1082
msgid "Resets all of the traps to ``0``."
msgstr "Сбрасывает все ловушки в «0»."

#: ../../library/decimal.rst:1088
msgid "Return a duplicate of the context."
msgstr "Вернуть дубликат контекста."

#: ../../library/decimal.rst:1092
msgid "Return a copy of the Decimal instance num."
msgstr "Вернуть копию номера экземпляра Decimal."

#: ../../library/decimal.rst:1096
msgid ""
"Creates a new Decimal instance from *num* but using *self* as context. "
"Unlike the :class:`Decimal` constructor, the context precision, rounding "
"method, flags, and traps are applied to the conversion."
msgstr ""
"Создает новый экземпляр Decimal из *num*, но используя *self* в качестве "
"контекста. В отличие от конструктора :class:`Decimal`, при преобразовании "
"применяются точность контекста, метод округления, флаги и ловушки."

#: ../../library/decimal.rst:1100
msgid ""
"This is useful because constants are often given to a greater precision than "
"is needed by the application.  Another benefit is that rounding immediately "
"eliminates unintended effects from digits beyond the current precision. In "
"the following example, using unrounded inputs means that adding zero to a "
"sum can change the result:"
msgstr ""
"Это полезно, поскольку константам часто присваивается более высокая "
"точность, чем требуется приложению. Еще одним преимуществом является то, что "
"округление немедленно устраняет непреднамеренные эффекты цифр, выходящих за "
"рамки текущей точности. В следующем примере использование неокругленных "
"входных данных означает, что добавление нуля к сумме может изменить "
"результат:"

#: ../../library/decimal.rst:1114
msgid ""
"This method implements the to-number operation of the IBM specification. If "
"the argument is a string, no leading or trailing whitespace or underscores "
"are permitted."
msgstr ""
"Этот метод реализует операцию to-number спецификации IBM. Если аргумент "
"является строкой, никакие начальные или конечные пробелы или символы "
"подчеркивания не допускаются."

#: ../../library/decimal.rst:1120
msgid ""
"Creates a new Decimal instance from a float *f* but rounding using *self* as "
"the context.  Unlike the :meth:`Decimal.from_float` class method, the "
"context precision, rounding method, flags, and traps are applied to the "
"conversion."
msgstr ""
"Создает новый экземпляр Decimal из числа с плавающей запятой *f*, но "
"округляет его, используя *self* в качестве контекста. В отличие от метода "
"класса :meth:`Decimal.from_float`, при преобразовании применяются точность "
"контекста, метод округления, флаги и ловушки."

#: ../../library/decimal.rst:1140
msgid ""
"Returns a value equal to ``Emin - prec + 1`` which is the minimum exponent "
"value for subnormal results.  When underflow occurs, the exponent is set to :"
"const:`Etiny`."
msgstr ""
"Возвращает значение, равное ``Emin - prec + 1``, ​​которое является "
"минимальным значением показателя степени для ненормальных результатов. Когда "
"происходит опустошение, экспонента устанавливается на :const:`Etiny`."

#: ../../library/decimal.rst:1146
msgid "Returns a value equal to ``Emax - prec + 1``."
msgstr "Возвращает значение, равное ``Emax - prec + 1``."

#: ../../library/decimal.rst:1148
msgid ""
"The usual approach to working with decimals is to create :class:`Decimal` "
"instances and then apply arithmetic operations which take place within the "
"current context for the active thread.  An alternative approach is to use "
"context methods for calculating within a specific context.  The methods are "
"similar to those for the :class:`Decimal` class and are only briefly "
"recounted here."
msgstr ""
"Обычный подход к работе с десятичными числами заключается в создании "
"экземпляров :class:`Decimal` и последующем применении арифметических "
"операций, которые происходят в текущем контексте активного потока. "
"Альтернативный подход — использовать контекстные методы для вычислений в "
"конкретном контексте. Методы аналогичны методам класса :class:`Decimal` и "
"здесь описаны лишь вкратце."

#: ../../library/decimal.rst:1158
msgid "Returns the absolute value of *x*."
msgstr "Возвращает абсолютное значение *x*."

#: ../../library/decimal.rst:1163
msgid "Return the sum of *x* and *y*."
msgstr "Вернуть сумму *x* и *y*."

#: ../../library/decimal.rst:1168
msgid "Returns the same Decimal object *x*."
msgstr "Возвращает тот же объект Decimal *x*."

#: ../../library/decimal.rst:1173
msgid "Compares *x* and *y* numerically."
msgstr "Сравнивает *x* и *y* численно."

#: ../../library/decimal.rst:1178
msgid "Compares the values of the two operands numerically."
msgstr "Сравнивает значения двух операндов численно."

#: ../../library/decimal.rst:1183
msgid "Compares two operands using their abstract representation."
msgstr "Сравнивает два операнда, используя их абстрактное представление."

#: ../../library/decimal.rst:1188
msgid ""
"Compares two operands using their abstract representation, ignoring sign."
msgstr ""
"Сравнивает два операнда, используя их абстрактное представление, игнорируя "
"знак."

#: ../../library/decimal.rst:1193
msgid "Returns a copy of *x* with the sign set to 0."
msgstr "Возвращает копию *x* со знаком, равным 0."

#: ../../library/decimal.rst:1198
msgid "Returns a copy of *x* with the sign inverted."
msgstr "Возвращает копию *x* с инвертированным знаком."

#: ../../library/decimal.rst:1203
msgid "Copies the sign from *y* to *x*."
msgstr "Копирует знак из *y* в *x*."

#: ../../library/decimal.rst:1208
msgid "Return *x* divided by *y*."
msgstr "Верните *x*, разделенное на *y*."

#: ../../library/decimal.rst:1213
msgid "Return *x* divided by *y*, truncated to an integer."
msgstr "Возвращает *x*, разделенное на *y*, усеченное до целого числа."

#: ../../library/decimal.rst:1218
msgid "Divides two numbers and returns the integer part of the result."
msgstr "Делит два числа и возвращает целую часть результата."

#: ../../library/decimal.rst:1223
msgid "Returns ``e ** x``."
msgstr "Возвращает ``e ** x``."

#: ../../library/decimal.rst:1228
msgid "Returns *x* multiplied by *y*, plus *z*."
msgstr "Возвращает *x*, умноженное на *y* плюс *z*."

#: ../../library/decimal.rst:1233
msgid "Returns ``True`` if *x* is canonical; otherwise returns ``False``."
msgstr ""
"Возвращает ``True``, если *x* является каноническим; в противном случае "
"возвращается ``False``."

#: ../../library/decimal.rst:1238
msgid "Returns ``True`` if *x* is finite; otherwise returns ``False``."
msgstr ""
"Возвращает ``True``, если *x* конечно; в противном случае возвращается "
"``False``."

#: ../../library/decimal.rst:1243
msgid "Returns ``True`` if *x* is infinite; otherwise returns ``False``."
msgstr ""
"Возвращает ``True``, если *x* бесконечно; в противном случае возвращается "
"``False``."

#: ../../library/decimal.rst:1248
msgid "Returns ``True`` if *x* is a qNaN or sNaN; otherwise returns ``False``."
msgstr ""
"Возвращает ``True``, если *x* является qNaN или sNaN; в противном случае "
"возвращается ``False``."

#: ../../library/decimal.rst:1253
msgid ""
"Returns ``True`` if *x* is a normal number; otherwise returns ``False``."
msgstr ""
"Возвращает ``True``, если *x* — обычное число; в противном случае "
"возвращается ``False``."

#: ../../library/decimal.rst:1258
msgid "Returns ``True`` if *x* is a quiet NaN; otherwise returns ``False``."
msgstr ""
"Возвращает ``True``, если *x* является молчаливым NaN; в противном случае "
"возвращается ``False``."

#: ../../library/decimal.rst:1263
msgid "Returns ``True`` if *x* is negative; otherwise returns ``False``."
msgstr ""
"Возвращает ``True``, если *x* отрицательное значение; в противном случае "
"возвращается ``False``."

#: ../../library/decimal.rst:1268
msgid ""
"Returns ``True`` if *x* is a signaling NaN; otherwise returns ``False``."
msgstr ""
"Возвращает ``True``, если *x* является сигнальным NaN; в противном случае "
"возвращается ``False``."

#: ../../library/decimal.rst:1273
msgid "Returns ``True`` if *x* is subnormal; otherwise returns ``False``."
msgstr ""
"Возвращает ``True``, если *x* ненормально; в противном случае возвращается "
"``False``."

#: ../../library/decimal.rst:1278
msgid "Returns ``True`` if *x* is a zero; otherwise returns ``False``."
msgstr ""
"Возвращает ``True``, если *x* — ноль; в противном случае возвращается "
"``False``."

#: ../../library/decimal.rst:1283
msgid "Returns the natural (base e) logarithm of *x*."
msgstr "Возвращает натуральный логарифм (по основанию e) числа *x*."

#: ../../library/decimal.rst:1288
msgid "Returns the base 10 logarithm of *x*."
msgstr "Возвращает десятичный логарифм числа *x*."

#: ../../library/decimal.rst:1293
msgid "Returns the exponent of the magnitude of the operand's MSD."
msgstr "Возвращает показатель степени MSD операнда."

#: ../../library/decimal.rst:1298
msgid "Applies the logical operation *and* between each operand's digits."
msgstr "Применяет логическую операцию *и* между цифрами каждого операнда."

#: ../../library/decimal.rst:1303
msgid "Invert all the digits in *x*."
msgstr "Инвертируйте все цифры в *x*."

#: ../../library/decimal.rst:1308
msgid "Applies the logical operation *or* between each operand's digits."
msgstr "Применяет логическую операцию *или* между цифрами каждого операнда."

#: ../../library/decimal.rst:1313
msgid "Applies the logical operation *xor* between each operand's digits."
msgstr "Применяет логическую операцию *xor* между цифрами каждого операнда."

#: ../../library/decimal.rst:1318
msgid "Compares two values numerically and returns the maximum."
msgstr "Сравнивает два значения численно и возвращает максимальное значение."

#: ../../library/decimal.rst:1323 ../../library/decimal.rst:1333
msgid "Compares the values numerically with their sign ignored."
msgstr "Сравнивает значения численно, их знак игнорируется."

#: ../../library/decimal.rst:1328
msgid "Compares two values numerically and returns the minimum."
msgstr "Сравнивает два значения численно и возвращает минимум."

#: ../../library/decimal.rst:1338
msgid "Minus corresponds to the unary prefix minus operator in Python."
msgstr "Минус соответствует унарному префиксному оператору минус в Python."

#: ../../library/decimal.rst:1343
msgid "Return the product of *x* and *y*."
msgstr "Вернуть произведение *x* и *y*."

#: ../../library/decimal.rst:1348
msgid "Returns the largest representable number smaller than *x*."
msgstr "Возвращает наибольшее представимое число, меньшее *x*."

#: ../../library/decimal.rst:1353
msgid "Returns the smallest representable number larger than *x*."
msgstr "Возвращает наименьшее представимое число, большее *x*."

#: ../../library/decimal.rst:1358
msgid "Returns the number closest to *x*, in direction towards *y*."
msgstr "Возвращает число, ближайшее к *x*, в направлении *y*."

#: ../../library/decimal.rst:1363
msgid "Reduces *x* to its simplest form."
msgstr "Приводит *x* к простейшей форме."

#: ../../library/decimal.rst:1368
msgid "Returns an indication of the class of *x*."
msgstr "Возвращает указание класса *x*."

#: ../../library/decimal.rst:1373
msgid ""
"Plus corresponds to the unary prefix plus operator in Python.  This "
"operation applies the context precision and rounding, so it is *not* an "
"identity operation."
msgstr ""
"Плюс соответствует унарному префиксу оператора плюс в Python. Эта операция "
"применяет точность и округление контекста, поэтому она *не* является "
"операцией идентификации."

#: ../../library/decimal.rst:1380
msgid "Return ``x`` to the power of ``y``, reduced modulo ``modulo`` if given."
msgstr ""
"Возвратите ``x`` в степень ``y``, уменьшенную по модулю ``modulo``, если "
"задано."

#: ../../library/decimal.rst:1382
msgid ""
"With two arguments, compute ``x**y``.  If ``x`` is negative then ``y`` must "
"be integral.  The result will be inexact unless ``y`` is integral and the "
"result is finite and can be expressed exactly in 'precision' digits. The "
"rounding mode of the context is used. Results are always correctly rounded "
"in the Python version."
msgstr ""
"С двумя аргументами вычислите ``x**y``. Если «x» отрицательно, то «y» должно "
"быть целым. Результат будет неточным, если только ``y`` не является целым, а "
"результат конечен и не может быть точно выражен в «точных» цифрах. "
"Используется режим округления контекста. Результаты всегда правильно "
"округляются в версии Python."

#: ../../library/decimal.rst:1388
msgid ""
"``Decimal(0) ** Decimal(0)`` results in ``InvalidOperation``, and if "
"``InvalidOperation`` is not trapped, then results in ``Decimal('NaN')``."
msgstr ""
"``Decimal(0) ** Decimal(0)`` приводит к ``InvalidOperation``, и если "
"``InvalidOperation`` не перехватывается, тогда получается ``Decimal('NaN')``."

#: ../../library/decimal.rst:1391
msgid ""
"The C module computes :meth:`power` in terms of the correctly rounded :meth:"
"`exp` and :meth:`ln` functions. The result is well-defined but only \"almost "
"always correctly rounded\"."
msgstr ""
"Модуль C вычисляет :meth:`power` с помощью правильно округленных функций :"
"meth:`exp` и :meth:`ln`. Результат четко определен, но только «почти всегда "
"правильно округлен»."

#: ../../library/decimal.rst:1396
msgid ""
"With three arguments, compute ``(x**y) % modulo``.  For the three argument "
"form, the following restrictions on the arguments hold:"
msgstr ""
"С тремя аргументами вычислите ``(x**y) % по модулю``. Для формы с тремя "
"аргументами действуют следующие ограничения на аргументы:"

#: ../../library/decimal.rst:1399
msgid "all three arguments must be integral"
msgstr "Все три аргумента должны быть целочисленными"

#: ../../library/decimal.rst:1400
msgid "``y`` must be nonnegative"
msgstr "``y`` должно быть неотрицательным"

#: ../../library/decimal.rst:1401
msgid "at least one of ``x`` or ``y`` must be nonzero"
msgstr "хотя бы один из ``x`` или ``y`` должен быть ненулевым"

#: ../../library/decimal.rst:1402
msgid "``modulo`` must be nonzero and have at most 'precision' digits"
msgstr "``modulo`` должен быть ненулевым и содержать не более \"точных\" цифр."

#: ../../library/decimal.rst:1404
msgid ""
"The value resulting from ``Context.power(x, y, modulo)`` is equal to the "
"value that would be obtained by computing ``(x**y) % modulo`` with unbounded "
"precision, but is computed more efficiently.  The exponent of the result is "
"zero, regardless of the exponents of ``x``, ``y`` and ``modulo``.  The "
"result is always exact."
msgstr ""
"Значение, полученное из ``Context.power(x, y, modulo)``, равно значению, "
"которое было бы получено путем вычисления ``(x**y) % по модулю`` с "
"неограниченной точностью, но вычисляется более эффективно. . Показатель "
"степени результата равен нулю, независимо от показателей ``x``, ``y`` и ``по "
"модулю``. Результат всегда точен."

#: ../../library/decimal.rst:1414
msgid "Returns a value equal to *x* (rounded), having the exponent of *y*."
msgstr ""
"Возвращает значение, равное *x* (округленное), с показателем степени *y*."

#: ../../library/decimal.rst:1419
msgid "Just returns 10, as this is Decimal, :)"
msgstr "Просто возвращает 10, так как это десятичное число :)"

#: ../../library/decimal.rst:1424
msgid "Returns the remainder from integer division."
msgstr "Возвращает остаток от целочисленного деления."

#: ../../library/decimal.rst:1426
msgid ""
"The sign of the result, if non-zero, is the same as that of the original "
"dividend."
msgstr ""
"Знак результата, если он ненулевой, тот же, что и у исходного делимого."

#: ../../library/decimal.rst:1432
msgid ""
"Returns ``x - y * n``, where *n* is the integer nearest the exact value of "
"``x / y`` (if the result is 0 then its sign will be the sign of *x*)."
msgstr ""
"Возвращает ``x - y * n``, где *n* — целое число, ближайшее к точному "
"значению ``x ​​/ y`` (если результат равен 0, то его знак будет знаком *x*)."

#: ../../library/decimal.rst:1438
msgid "Returns a rotated copy of *x*, *y* times."
msgstr "Возвращает повернутую копию *x*, *y* раз."

#: ../../library/decimal.rst:1443
msgid "Returns ``True`` if the two operands have the same exponent."
msgstr "Возвращает ``True``, если два операнда имеют одинаковую степень."

#: ../../library/decimal.rst:1448
msgid "Returns the first operand after adding the second value its exp."
msgstr ""
"Возвращает первый операнд после добавления второго значения к его значению "
"exp."

#: ../../library/decimal.rst:1453
msgid "Returns a shifted copy of *x*, *y* times."
msgstr "Возвращает сдвинутую копию *x*, *y* раз."

#: ../../library/decimal.rst:1458
msgid "Square root of a non-negative number to context precision."
msgstr "Квадратный корень из неотрицательного числа для точности контекста."

#: ../../library/decimal.rst:1463
msgid "Return the difference between *x* and *y*."
msgstr "Возвращает разницу между *x* и *y*."

#: ../../library/decimal.rst:1477
msgid "Rounds to an integer."
msgstr "Округляет до целого числа."

#: ../../library/decimal.rst:1482
msgid "Converts a number to a string using scientific notation."
msgstr "Преобразует число в строку, используя экспоненциальную запись."

#: ../../library/decimal.rst:1489
msgid "Constants"
msgstr "Константы"

#: ../../library/decimal.rst:1491
msgid ""
"The constants in this section are only relevant for the C module. They are "
"also included in the pure Python version for compatibility."
msgstr ""
"Константы в этом разделе относятся только к модулю C. Они также включены в "
"чистую версию Python для совместимости."

#: ../../library/decimal.rst:1495
msgid "32-bit"
msgstr "32-бит"

#: ../../library/decimal.rst:1495
msgid "64-bit"
msgstr "64-бит"

#: ../../library/decimal.rst:1497 ../../library/decimal.rst:1499
msgid "``425000000``"
msgstr "``425000000``"

#: ../../library/decimal.rst:1497 ../../library/decimal.rst:1499
msgid "``999999999999999999``"
msgstr "``999999999999999999``"

#: ../../library/decimal.rst:1501
msgid "``-425000000``"
msgstr "``-425000000``"

#: ../../library/decimal.rst:1501
msgid "``-999999999999999999``"
msgstr "``-999999999999999999``"

#: ../../library/decimal.rst:1503
msgid "``-849999999``"
msgstr "``-849999999``"

#: ../../library/decimal.rst:1503
msgid "``-1999999999999999997``"
msgstr "``-1999999999999999997``"

#: ../../library/decimal.rst:1509
msgid ""
"The value is ``True``.  Deprecated, because Python now always has threads."
msgstr ""
"Значение ``True``. Устарело, поскольку в Python теперь всегда есть потоки."

#: ../../library/decimal.rst:1515
msgid ""
"The default value is ``True``. If Python is :option:`configured using the --"
"without-decimal-contextvar option <--without-decimal-contextvar>`, the C "
"version uses a thread-local rather than a coroutine-local context and the "
"value is ``False``.  This is slightly faster in some nested context "
"scenarios."
msgstr ""
"Значение по умолчанию — ``True``. Если Python :option:`настроен с "
"использованием опции --without-decimal-contextvar <--without-decimal-"
"contextvar>`, версия C использует локальный контекст потока, а не локальный "
"контекст сопрограммы, и значение равно `` Ложь``. В некоторых сценариях с "
"вложенным контекстом это происходит немного быстрее."

#: ../../library/decimal.rst:1524
msgid "Rounding modes"
msgstr "Режимы округления"

#: ../../library/decimal.rst:1528
msgid "Round towards ``Infinity``."
msgstr "Округление в сторону «Бесконечности»."

#: ../../library/decimal.rst:1532
msgid "Round towards zero."
msgstr "Округляем в сторону нуля."

#: ../../library/decimal.rst:1536
msgid "Round towards ``-Infinity``."
msgstr "Округление в сторону ``-Бесконечности``."

#: ../../library/decimal.rst:1540
msgid "Round to nearest with ties going towards zero."
msgstr "Округляем до ближайшего значения, при этом связи стремятся к нулю."

#: ../../library/decimal.rst:1544
msgid "Round to nearest with ties going to nearest even integer."
msgstr ""
"Округляем до ближайшего, при этом связи идут к ближайшему четному целому "
"числу."

#: ../../library/decimal.rst:1548
msgid "Round to nearest with ties going away from zero."
msgstr "Округляем до ближайшего значения, отсчитывая от нуля."

#: ../../library/decimal.rst:1552
msgid "Round away from zero."
msgstr "Округляем от нуля."

#: ../../library/decimal.rst:1556
msgid ""
"Round away from zero if last digit after rounding towards zero would have "
"been 0 or 5; otherwise round towards zero."
msgstr ""
"Округлите в сторону от нуля, если последняя цифра после округления в сторону "
"нуля была бы 0 или 5; в противном случае округлите до нуля."

#: ../../library/decimal.rst:1563
msgid "Signals"
msgstr "Сигналы"

#: ../../library/decimal.rst:1565
msgid ""
"Signals represent conditions that arise during computation. Each corresponds "
"to one context flag and one context trap enabler."
msgstr ""
"Сигналы представляют собой условия, возникающие во время вычислений. Каждый "
"соответствует одному флагу контекста и одному активатору контекстной ловушки."

#: ../../library/decimal.rst:1568
msgid ""
"The context flag is set whenever the condition is encountered. After the "
"computation, flags may be checked for informational purposes (for instance, "
"to determine whether a computation was exact). After checking the flags, be "
"sure to clear all flags before starting the next computation."
msgstr ""
"Флаг контекста устанавливается всякий раз, когда встречается условие. После "
"вычисления флаги могут быть проверены в информационных целях (например, "
"чтобы определить, было ли вычисление точным). После проверки флагов "
"обязательно очистите все флаги перед началом следующего вычисления."

#: ../../library/decimal.rst:1573
msgid ""
"If the context's trap enabler is set for the signal, then the condition "
"causes a Python exception to be raised.  For example, if the :class:"
"`DivisionByZero` trap is set, then a :exc:`DivisionByZero` exception is "
"raised upon encountering the condition."
msgstr ""
"Если для сигнала установлен активатор ловушки контекста, то условие вызывает "
"возникновение исключения Python. Например, если установлена ​​ловушка :class:"
"`DivisionByZero`, то при обнаружении условия возникает исключение :exc:"
"`DivisionByZero`."

#: ../../library/decimal.rst:1581
msgid "Altered an exponent to fit representation constraints."
msgstr ""
"Изменен показатель степени, чтобы он соответствовал ограничениям "
"представления."

#: ../../library/decimal.rst:1583
msgid ""
"Typically, clamping occurs when an exponent falls outside the context's :"
"attr:`~Context.Emin` and :attr:`~Context.Emax` limits.  If possible, the "
"exponent is reduced to fit by adding zeros to the coefficient."
msgstr ""
"Обычно ограничение происходит, когда экспонента выходит за пределы "
"контекста :attr:`~Context.Emin` и :attr:`~Context.Emax`. Если возможно, "
"показатель степени уменьшается до соответствия путем добавления нулей к "
"коэффициенту."

#: ../../library/decimal.rst:1590
msgid "Base class for other signals and a subclass of :exc:`ArithmeticError`."
msgstr "Базовый класс для других сигналов и подкласс :exc:`ArithmeticError`."

#: ../../library/decimal.rst:1595
msgid "Signals the division of a non-infinite number by zero."
msgstr "Сигнализирует о делении небесконечного числа на ноль."

#: ../../library/decimal.rst:1597
msgid ""
"Can occur with division, modulo division, or when raising a number to a "
"negative power.  If this signal is not trapped, returns ``Infinity`` or ``-"
"Infinity`` with the sign determined by the inputs to the calculation."
msgstr ""
"Может произойти при делении, делении по модулю или при возведении числа в "
"отрицательную степень. Если этот сигнал не перехвачен, возвращается "
"``Бесконечность`` или ``-Бесконечность`` со знаком, определяемым входными "
"данными для расчета."

#: ../../library/decimal.rst:1604
msgid "Indicates that rounding occurred and the result is not exact."
msgstr "Указывает, что произошло округление и результат неточный."

#: ../../library/decimal.rst:1606
msgid ""
"Signals when non-zero digits were discarded during rounding. The rounded "
"result is returned.  The signal flag or trap is used to detect when results "
"are inexact."
msgstr ""
"Сигналы, когда ненулевые цифры были отброшены во время округления. "
"Возвращается округленный результат. Сигнальный флаг или ловушка используются "
"для обнаружения неточных результатов."

#: ../../library/decimal.rst:1613
msgid "An invalid operation was performed."
msgstr "Была выполнена недопустимая операция."

#: ../../library/decimal.rst:1615
msgid ""
"Indicates that an operation was requested that does not make sense. If not "
"trapped, returns ``NaN``.  Possible causes include::"
msgstr ""
"Указывает, что была запрошена операция, которая не имеет смысла. Если не "
"перехвачен, возвращает ``NaN``. Возможные причины включают в себя:"

#: ../../library/decimal.rst:1631
msgid "Numerical overflow."
msgstr "Числовое переполнение."

#: ../../library/decimal.rst:1633
msgid ""
"Indicates the exponent is larger than :attr:`Context.Emax` after rounding "
"has occurred.  If not trapped, the result depends on the rounding mode, "
"either pulling inward to the largest representable finite number or rounding "
"outward to ``Infinity``.  In either case, :class:`Inexact` and :class:"
"`Rounded` are also signaled."
msgstr ""
"Указывает, что показатель степени больше :attr:`Context.Emax` после того, "
"как произошло округление. Если не захвачено, результат зависит от режима "
"округления: либо вытягивание внутрь до наибольшего представимого конечного "
"числа, либо округление наружу до «Бесконечности». В любом случае также "
"сигнализируются :class:`Inexact` и :class:`Rounded`."

#: ../../library/decimal.rst:1642
msgid "Rounding occurred though possibly no information was lost."
msgstr ""
"Произошло округление, хотя, возможно, никакая информация не была потеряна."

#: ../../library/decimal.rst:1644
msgid ""
"Signaled whenever rounding discards digits; even if those digits are zero "
"(such as rounding ``5.00`` to ``5.0``).  If not trapped, returns the result "
"unchanged.  This signal is used to detect loss of significant digits."
msgstr ""
"Сигнализируется всякий раз, когда при округлении отбрасываются цифры; даже "
"если эти цифры равны нулю (например, округление ``5,00`` до ``5,0``). Если "
"не перехвачен, возвращает результат без изменений. Этот сигнал используется "
"для обнаружения потери значащих цифр."

#: ../../library/decimal.rst:1652
msgid "Exponent was lower than :attr:`~Context.Emin` prior to rounding."
msgstr ""
"До округления показатель степени был меньше, чем :attr:`~Context.Emin`."

#: ../../library/decimal.rst:1654
msgid ""
"Occurs when an operation result is subnormal (the exponent is too small). If "
"not trapped, returns the result unchanged."
msgstr ""
"Происходит, когда результат операции не соответствует норме (показатель "
"степени слишком мал). Если не перехвачен, возвращает результат без изменений."

#: ../../library/decimal.rst:1660
msgid "Numerical underflow with result rounded to zero."
msgstr "Числовое переполнение, результат округляется до нуля."

#: ../../library/decimal.rst:1662
msgid ""
"Occurs when a subnormal result is pushed to zero by rounding. :class:"
"`Inexact` and :class:`Subnormal` are also signaled."
msgstr ""
"Происходит, когда ненормальный результат округляется до нуля. Также "
"сигнализируются :class:`Inexact` и :class:`Subnormal`."

#: ../../library/decimal.rst:1668
msgid "Enable stricter semantics for mixing floats and Decimals."
msgstr ""
"Включите более строгую семантику для смешивания чисел с плавающей запятой и "
"десятичных дробей."

#: ../../library/decimal.rst:1670
msgid ""
"If the signal is not trapped (default), mixing floats and Decimals is "
"permitted in the :class:`~decimal.Decimal` constructor, :meth:`~decimal."
"Context.create_decimal` and all comparison operators. Both conversion and "
"comparisons are exact. Any occurrence of a mixed operation is silently "
"recorded by setting :exc:`FloatOperation` in the context flags. Explicit "
"conversions with :meth:`~decimal.Decimal.from_float` or :meth:`~decimal."
"Context.create_decimal_from_float` do not set the flag."
msgstr ""
"Если сигнал не перехвачен (по умолчанию), смешивание чисел с плавающей "
"запятой и десятичных дробей разрешено в конструкторе :class:`~decimal."
"Decimal`, :meth:`~decimal.Context.create_decimal` и во всех операторах "
"сравнения. И преобразование, и сравнение точны. Любое возникновение "
"смешанной операции автоматически записывается путем установки :exc:"
"`FloatOperation` в контекстных флагах. Явные преобразования с помощью :meth:"
"`~decimal.Decimal.from_float` или :meth:`~decimal.Context."
"create_decimal_from_float` не устанавливают флаг."

#: ../../library/decimal.rst:1678
msgid ""
"Otherwise (the signal is trapped), only equality comparisons and explicit "
"conversions are silent. All other mixed operations raise :exc:"
"`FloatOperation`."
msgstr ""
"В противном случае (сигнал перехватывается) молчат только сравнения на "
"равенство и явные преобразования. Все остальные смешанные операции вызывают :"
"exc:`FloatOperation`."

#: ../../library/decimal.rst:1682
msgid "The following table summarizes the hierarchy of signals::"
msgstr "В следующей таблице представлена ​​иерархия сигналов:"

#: ../../library/decimal.rst:1703
msgid "Floating Point Notes"
msgstr "Заметки о плавающей точке"

#: ../../library/decimal.rst:1707
msgid "Mitigating round-off error with increased precision"
msgstr "Уменьшение ошибки округления за счет повышения точности"

#: ../../library/decimal.rst:1709
msgid ""
"The use of decimal floating point eliminates decimal representation error "
"(making it possible to represent ``0.1`` exactly); however, some operations "
"can still incur round-off error when non-zero digits exceed the fixed "
"precision."
msgstr ""
"Использование десятичной плавающей точки устраняет ошибку десятичного "
"представления (давая возможность точно представить ``0,1``); однако "
"некоторые операции все равно могут вызывать ошибку округления, когда "
"ненулевые цифры превышают фиксированную точность."

#: ../../library/decimal.rst:1713
msgid ""
"The effects of round-off error can be amplified by the addition or "
"subtraction of nearly offsetting quantities resulting in loss of "
"significance.  Knuth provides two instructive examples where rounded "
"floating point arithmetic with insufficient precision causes the breakdown "
"of the associative and distributive properties of addition:"
msgstr ""

#: ../../library/decimal.rst:1737
msgid ""
"The :mod:`decimal` module makes it possible to restore the identities by "
"expanding the precision sufficiently to avoid loss of significance:"
msgstr ""
"Модуль :mod:`decimal` позволяет восстановить идентичность, достаточно "
"расширив точность, чтобы избежать потери значимости:"

#: ../../library/decimal.rst:1757
msgid "Special values"
msgstr "Специальные значения"

#: ../../library/decimal.rst:1759
msgid ""
"The number system for the :mod:`decimal` module provides special values "
"including ``NaN``, ``sNaN``, ``-Infinity``, ``Infinity``, and two zeros, "
"``+0`` and ``-0``."
msgstr ""
"Система счисления для модуля :mod:`decimal` предоставляет специальные "
"значения, включая ``NaN``, ``sNaN``, ``-Infinity``, ``Infinity`` и два нуля, "
"``+0` ` и ``-0``."

#: ../../library/decimal.rst:1763
msgid ""
"Infinities can be constructed directly with:  ``Decimal('Infinity')``. Also, "
"they can arise from dividing by zero when the :exc:`DivisionByZero` signal "
"is not trapped.  Likewise, when the :exc:`Overflow` signal is not trapped, "
"infinity can result from rounding beyond the limits of the largest "
"representable number."
msgstr ""
"Бесконечности можно построить напрямую с помощью: ``Decimal('Infinity')``. "
"Кроме того, они могут возникнуть в результате деления на ноль, если сигнал :"
"exc:`DivisionByZero` не перехвачен. Аналогично, если сигнал :exc:`Overflow` "
"не перехвачен, бесконечность может возникнуть в результате округления за "
"пределами наибольшего представимого числа."

#: ../../library/decimal.rst:1768
msgid ""
"The infinities are signed (affine) and can be used in arithmetic operations "
"where they get treated as very large, indeterminate numbers.  For instance, "
"adding a constant to infinity gives another infinite result."
msgstr ""
"Бесконечности имеют знак (аффинные) и могут использоваться в арифметических "
"операциях, где они рассматриваются как очень большие неопределенные числа. "
"Например, добавление константы к бесконечности дает еще один бесконечный "
"результат."

#: ../../library/decimal.rst:1772
msgid ""
"Some operations are indeterminate and return ``NaN``, or if the :exc:"
"`InvalidOperation` signal is trapped, raise an exception.  For example, "
"``0/0`` returns ``NaN`` which means \"not a number\".  This variety of "
"``NaN`` is quiet and, once created, will flow through other computations "
"always resulting in another ``NaN``.  This behavior can be useful for a "
"series of computations that occasionally have missing inputs --- it allows "
"the calculation to proceed while flagging specific results as invalid."
msgstr ""
"Некоторые операции являются неопределенными и возвращают ``NaN``, или, если "
"сигнал :exc:`InvalidOperation` перехвачен, вызывают исключение. Например, "
"``0/0`` возвращает ``NaN``, что означает «не число». Эта разновидность "
"``NaN`` тиха и после создания будет проходить через другие вычисления, "
"всегда приводящие к другому ``NaN``. Такое поведение может быть полезно для "
"серии вычислений, в которых иногда отсутствуют входные данные — оно "
"позволяет продолжить вычисление, помечая определенные результаты как "
"недействительные."

#: ../../library/decimal.rst:1780
msgid ""
"A variant is ``sNaN`` which signals rather than remaining quiet after every "
"operation.  This is a useful return value when an invalid result needs to "
"interrupt a calculation for special handling."
msgstr ""
"Вариантом является sNaN, который сигнализирует, а не молчит после каждой "
"операции. Это полезное возвращаемое значение, когда недопустимый результат "
"требует прерывания вычислений для специальной обработки."

#: ../../library/decimal.rst:1784
msgid ""
"The behavior of Python's comparison operators can be a little surprising "
"where a ``NaN`` is involved.  A test for equality where one of the operands "
"is a quiet or signaling ``NaN`` always returns :const:`False` (even when "
"doing ``Decimal('NaN')==Decimal('NaN')``), while a test for inequality "
"always returns :const:`True`.  An attempt to compare two Decimals using any "
"of the ``<``, ``<=``, ``>`` or ``>=`` operators will raise the :exc:"
"`InvalidOperation` signal if either operand is a ``NaN``, and return :const:"
"`False` if this signal is not trapped.  Note that the General Decimal "
"Arithmetic specification does not specify the behavior of direct "
"comparisons; these rules for comparisons involving a ``NaN`` were taken from "
"the IEEE 854 standard (see Table 3 in section 5.7).  To ensure strict "
"standards-compliance, use the :meth:`~Decimal.compare` and :meth:`~Decimal."
"compare_signal` methods instead."
msgstr ""
"Поведение операторов сравнения Python может быть немного неожиданным, когда "
"речь идет о NaN. Проверка на равенство, когда один из операндов является "
"тихим или сигнальным ``NaN``, всегда возвращает :const:`False` (даже при "
"выполнении ``Decimal('NaN')==Decimal('NaN')``) , тогда как проверка на "
"неравенство всегда возвращает :const:`True`. Попытка сравнить два десятичных "
"числа с помощью любого из операторов ``<``, ``<=``, ``>`` или ``>=`` вызовет "
"сигнал :exc:`InvalidOperation`, если любой из операндов равен ``NaN`` и "
"верните :const:`False`, если этот сигнал не перехвачен. Обратите внимание, "
"что спецификация общей десятичной арифметики не определяет поведение прямых "
"сравнений; эти правила сравнений с использованием NaN были взяты из "
"стандарта IEEE 854 (см. Таблицу 3 в разделе 5.7). Чтобы обеспечить строгое "
"соответствие стандартам, вместо этого используйте методы :meth:`~Decimal."
"compare` и :meth:`~Decimal.compare_signal`."

#: ../../library/decimal.rst:1797
msgid ""
"The signed zeros can result from calculations that underflow. They keep the "
"sign that would have resulted if the calculation had been carried out to "
"greater precision.  Since their magnitude is zero, both positive and "
"negative zeros are treated as equal and their sign is informational."
msgstr ""
"Знаковые нули могут быть результатом вычислений, которые заканчиваются. Они "
"сохраняют тот знак, который получился бы, если бы расчет проводился с "
"большей точностью. Поскольку их величина равна нулю, как положительные, так "
"и отрицательные нули считаются равными, а их знак является информационным."

#: ../../library/decimal.rst:1802
msgid ""
"In addition to the two signed zeros which are distinct yet equal, there are "
"various representations of zero with differing precisions yet equivalent in "
"value.  This takes a bit of getting used to.  For an eye accustomed to "
"normalized floating point representations, it is not immediately obvious "
"that the following calculation returns a value equal to zero:"
msgstr ""

#: ../../library/decimal.rst:1817
msgid "Working with threads"
msgstr "Работа с потоками"

#: ../../library/decimal.rst:1819
msgid ""
"The :func:`getcontext` function accesses a different :class:`Context` object "
"for each thread.  Having separate thread contexts means that threads may "
"make changes (such as ``getcontext().prec=10``) without interfering with "
"other threads."
msgstr ""
"Функция :func:`getcontext` обращается к разным объектам :class:`Context` для "
"каждого потока. Наличие отдельных контекстов потоков означает, что потоки "
"могут вносить изменения (например, getcontext().prec=10), не мешая другим "
"потокам."

#: ../../library/decimal.rst:1823
msgid ""
"Likewise, the :func:`setcontext` function automatically assigns its target "
"to the current thread."
msgstr ""
"Аналогично, функция :func:`setcontext` автоматически назначает свою цель "
"текущему потоку."

#: ../../library/decimal.rst:1826
msgid ""
"If :func:`setcontext` has not been called before :func:`getcontext`, then :"
"func:`getcontext` will automatically create a new context for use in the "
"current thread."
msgstr ""
"Если :func:`setcontext` не вызывался до :func:`getcontext`, то :func:"
"`getcontext` автоматически создаст новый контекст для использования в "
"текущем потоке."

#: ../../library/decimal.rst:1830
msgid ""
"The new context is copied from a prototype context called *DefaultContext*. "
"To control the defaults so that each thread will use the same values "
"throughout the application, directly modify the *DefaultContext* object. "
"This should be done *before* any threads are started so that there won't be "
"a race condition between threads calling :func:`getcontext`. For example::"
msgstr ""
"Новый контекст копируется из контекста прототипа с именем *DefaultContext*. "
"Чтобы контролировать значения по умолчанию, чтобы каждый поток использовал "
"одни и те же значения во всем приложении, напрямую измените объект "
"*DefaultContext*. Это должно быть сделано *до* запуска любых потоков, чтобы "
"не возникло состояние гонки между потоками, вызывающими :func:`getcontext`. "
"Например::"

#: ../../library/decimal.rst:1855
msgid "Recipes"
msgstr "Рецепты"

#: ../../library/decimal.rst:1857
msgid ""
"Here are a few recipes that serve as utility functions and that demonstrate "
"ways to work with the :class:`Decimal` class::"
msgstr ""
"Вот несколько рецептов, которые служат служебными функциями и демонстрируют "
"способы работы с классом :class:`Decimal`::"

#: ../../library/decimal.rst:2012
msgid "Decimal FAQ"
msgstr "ЧаВо по десятичным дробям"

#: ../../library/decimal.rst:2014
msgid ""
"Q. It is cumbersome to type ``decimal.Decimal('1234.5')``.  Is there a way "
"to minimize typing when using the interactive interpreter?"
msgstr ""
"Вопрос. Вводить ``decimal.Decimal('1234.5')`` неудобно. Есть ли способ "
"свести к минимуму набор текста при использовании интерактивного переводчика?"

#: ../../library/decimal.rst:2017
msgid "A. Some users abbreviate the constructor to just a single letter:"
msgstr "О. Некоторые пользователи сокращают конструктор до одной буквы:"

#: ../../library/decimal.rst:2023
msgid ""
"Q. In a fixed-point application with two decimal places, some inputs have "
"many places and need to be rounded.  Others are not supposed to have excess "
"digits and need to be validated.  What methods should be used?"
msgstr ""
"Вопрос. В приложении с фиксированной запятой и двумя десятичными знаками "
"некоторые входные данные имеют много знаков и их необходимо округлять. "
"Другие не должны иметь лишних цифр и должны быть проверены. Какие методы "
"следует использовать?"

#: ../../library/decimal.rst:2027
msgid ""
"A. The :meth:`~Decimal.quantize` method rounds to a fixed number of decimal "
"places. If the :const:`Inexact` trap is set, it is also useful for "
"validation:"
msgstr ""
"О. Метод :meth:`~Decimal.quantize` округляет до фиксированного количества "
"десятичных знаков. Если установлена ​​ловушка :const:`Inexact`, она также "
"полезна для проверки:"

#: ../../library/decimal.rst:2045
msgid ""
"Q. Once I have valid two place inputs, how do I maintain that invariant "
"throughout an application?"
msgstr ""
"Вопрос. Если у меня есть действительные входные данные из двух мест, как мне "
"сохранить этот инвариант во всем приложении?"

#: ../../library/decimal.rst:2048
msgid ""
"A. Some operations like addition, subtraction, and multiplication by an "
"integer will automatically preserve fixed point.  Others operations, like "
"division and non-integer multiplication, will change the number of decimal "
"places and need to be followed-up with a :meth:`~Decimal.quantize` step:"
msgstr ""
"Ответ. Некоторые операции, такие как сложение, вычитание и умножение на "
"целое число, автоматически сохраняют фиксированную точку. Другие операции, "
"такие как деление и нецелое умножение, изменят количество десятичных знаков "
"и должны сопровождаться шагом :meth:`~Decimal.quantize`:"

#: ../../library/decimal.rst:2066
msgid ""
"In developing fixed-point applications, it is convenient to define functions "
"to handle the :meth:`~Decimal.quantize` step:"
msgstr ""
"При разработке приложений с фиксированной точкой удобно определять функции "
"для обработки шага :meth:`~Decimal.quantize`:"

#: ../../library/decimal.rst:2079
msgid ""
"Q. There are many ways to express the same value.  The numbers ``200``, "
"``200.000``, ``2E2``, and ``.02E+4`` all have the same value at various "
"precisions. Is there a way to transform them to a single recognizable "
"canonical value?"
msgstr ""
"Вопрос. Есть много способов выразить одну и ту же ценность. Числа ``200``, "
"``200.000``, ``2E2`` и ``.02E+4`` имеют одно и то же значение с различной "
"точностью. Есть ли способ преобразовать их в одно узнаваемое каноническое "
"значение?"

#: ../../library/decimal.rst:2084
msgid ""
"A. The :meth:`~Decimal.normalize` method maps all equivalent values to a "
"single representative:"
msgstr ""
"А. Метод :meth:`~Decimal.normalize` сопоставляет все эквивалентные значения "
"одному представителю:"

#: ../../library/decimal.rst:2091
msgid "Q. When does rounding occur in a computation?"
msgstr "Вопрос. Когда в вычислениях происходит округление?"

#: ../../library/decimal.rst:2093
msgid ""
"A. It occurs *after* the computation.  The philosophy of the decimal "
"specification is that numbers are considered exact and are created "
"independent of the current context.  They can even have greater precision "
"than current context.  Computations process with those exact inputs and then "
"rounding (or other context operations) is applied to the *result* of the "
"computation::"
msgstr ""
"Ответ. Это происходит *после* вычислений. Философия десятичной спецификации "
"заключается в том, что числа считаются точными и создаются независимо от "
"текущего контекста. Они могут даже иметь большую точность, чем текущий "
"контекст. Процесс вычислений с использованием этих точных входных данных, а "
"затем к *результату* вычислений применяется округление (или другие "
"контекстные операции):"

#: ../../library/decimal.rst:2111
msgid ""
"Q. Some decimal values always print with exponential notation.  Is there a "
"way to get a non-exponential representation?"
msgstr ""
"Вопрос. Некоторые десятичные значения всегда печатаются в экспоненциальном "
"представлении. Есть ли способ получить неэкспоненциальное представление?"

#: ../../library/decimal.rst:2114
msgid ""
"A. For some values, exponential notation is the only way to express the "
"number of significant places in the coefficient.  For example, expressing "
"``5.0E+3`` as ``5000`` keeps the value constant but cannot show the "
"original's two-place significance."
msgstr ""
"А. Для некоторых значений экспоненциальная запись является единственным "
"способом выразить количество значимых мест в коэффициенте. Например, "
"выражение ``5.0E+3`` как ``5000`` сохраняет значение постоянным, но не может "
"показать двухзначное значение оригинала."

#: ../../library/decimal.rst:2119
msgid ""
"If an application does not care about tracking significance, it is easy to "
"remove the exponent and trailing zeroes, losing significance, but keeping "
"the value unchanged:"
msgstr ""
"Если приложение не заботится об отслеживании значимости, можно легко удалить "
"показатель степени и конечные нули, потеряв значимость, но сохранив значение "
"неизменным:"

#: ../../library/decimal.rst:2129
msgid "Q. Is there a way to convert a regular float to a :class:`Decimal`?"
msgstr ""
"Вопрос. Есть ли способ преобразовать обычное число с плавающей запятой в :"
"class:`Decimal`?"

#: ../../library/decimal.rst:2131
msgid ""
"A. Yes, any binary floating point number can be exactly expressed as a "
"Decimal though an exact conversion may take more precision than intuition "
"would suggest:"
msgstr ""

#: ../../library/decimal.rst:2140
msgid ""
"Q. Within a complex calculation, how can I make sure that I haven't gotten a "
"spurious result because of insufficient precision or rounding anomalies."
msgstr ""
"Вопрос. Как я могу убедиться в том, что при сложном расчете я не получил "
"ложный результат из-за недостаточной точности или аномалий округления?"

#: ../../library/decimal.rst:2143
msgid ""
"A. The decimal module makes it easy to test results.  A best practice is to "
"re-run calculations using greater precision and with various rounding modes. "
"Widely differing results indicate insufficient precision, rounding mode "
"issues, ill-conditioned inputs, or a numerically unstable algorithm."
msgstr ""
"Ответ. Десятичный модуль упрощает проверку результатов. Лучше всего "
"повторить расчеты с большей точностью и с различными режимами округления. "
"Сильно различающиеся результаты указывают на недостаточную точность, "
"проблемы с режимом округления, плохие входные данные или численно "
"нестабильный алгоритм."

#: ../../library/decimal.rst:2148
msgid ""
"Q. I noticed that context precision is applied to the results of operations "
"but not to the inputs.  Is there anything to watch out for when mixing "
"values of different precisions?"
msgstr ""
"Вопрос. Я заметил, что точность контекста применяется к результатам "
"операций, а не к входным данным. На что следует обратить внимание при "
"смешивании значений разной точности?"

#: ../../library/decimal.rst:2152
msgid ""
"A. Yes.  The principle is that all values are considered to be exact and so "
"is the arithmetic on those values.  Only the results are rounded.  The "
"advantage for inputs is that \"what you type is what you get\".  A "
"disadvantage is that the results can look odd if you forget that the inputs "
"haven't been rounded:"
msgstr ""
"А. Да. Принцип заключается в том, что все значения считаются точными, как и "
"арифметика этих значений. Только результаты округляются. Преимущество ввода "
"заключается в том, что «что вы вводите, то и получаете». Недостатком "
"является то, что результаты могут выглядеть странно, если вы забудете, что "
"входные данные не были округлены:"

#: ../../library/decimal.rst:2165
msgid ""
"The solution is either to increase precision or to force rounding of inputs "
"using the unary plus operation:"
msgstr ""
"Решение состоит в том, чтобы либо повысить точность, либо принудительно "
"округлить входные данные с помощью операции унарного плюса:"

#: ../../library/decimal.rst:2174
msgid ""
"Alternatively, inputs can be rounded upon creation using the :meth:`Context."
"create_decimal` method:"
msgstr ""
"Альтернативно, входные данные можно округлить при создании с помощью метода :"
"meth:`Context.create_decimal`:"

#: ../../library/decimal.rst:2180
msgid "Q. Is the CPython implementation fast for large numbers?"
msgstr "Вопрос. Быстра ли реализация CPython для больших чисел?"

#: ../../library/decimal.rst:2182
msgid ""
"A. Yes.  In the CPython and PyPy3 implementations, the C/CFFI versions of "
"the decimal module integrate the high speed `libmpdec <https://www.bytereef."
"org/mpdecimal/doc/libmpdec/index.html>`_ library for arbitrary precision "
"correctly rounded decimal floating point arithmetic [#]_. ``libmpdec`` uses "
"`Karatsuba multiplication <https://en.wikipedia.org/wiki/"
"Karatsuba_algorithm>`_ for medium-sized numbers and the `Number Theoretic "
"Transform <https://en.wikipedia.org/wiki/"
"Discrete_Fourier_transform_(general)#Number-theoretic_transform>`_ for very "
"large numbers."
msgstr ""

#: ../../library/decimal.rst:2192
msgid ""
"The context must be adapted for exact arbitrary precision arithmetic. :attr:"
"`~Context.Emin` and :attr:`~Context.Emax` should always be set to the "
"maximum values, :attr:`~Context.clamp` should always be 0 (the default).  "
"Setting :attr:`~Context.prec` requires some care."
msgstr ""
"Контекст должен быть адаптирован для точной арифметики произвольной "
"точности. :attr:`~Context.Emin` и :attr:`~Context.Emax` всегда должны быть "
"установлены на максимальные значения, :attr:`~Context.clamp` всегда должен "
"быть равен 0 (по умолчанию). Настройка :attr:`~Context.prec` требует "
"некоторой осторожности."

#: ../../library/decimal.rst:2196
msgid ""
"The easiest approach for trying out bignum arithmetic is to use the maximum "
"value for :attr:`~Context.prec` as well [#]_::"
msgstr ""
"Самый простой способ опробовать арифметику bignum — использовать также "
"максимальное значение для :attr:`~Context.prec`. [#]_ ::"

#: ../../library/decimal.rst:2205
msgid ""
"For inexact results, :attr:`MAX_PREC` is far too large on 64-bit platforms "
"and the available memory will be insufficient::"
msgstr ""
"Из-за неточных результатов :attr:`MAX_PREC` слишком велик на 64-битных "
"платформах, и доступной памяти будет недостаточно::"

#: ../../library/decimal.rst:2213
msgid ""
"On systems with overallocation (e.g. Linux), a more sophisticated approach "
"is to adjust :attr:`~Context.prec` to the amount of available RAM.  Suppose "
"that you have 8GB of RAM and expect 10 simultaneous operands using a maximum "
"of 500MB each::"
msgstr ""
"В системах с избыточным распределением ресурсов (например, Linux) более "
"сложный подход заключается в настройке :attr:`~Context.prec` в соответствии "
"с объемом доступной оперативной памяти. Предположим, что у вас 8 ГБ ОЗУ и вы "
"ожидаете одновременного выполнения 10 операндов, каждый из которых будет "
"занимать максимум 500 МБ:"

#: ../../library/decimal.rst:2237
msgid ""
"In general (and especially on systems without overallocation), it is "
"recommended to estimate even tighter bounds and set the :attr:`Inexact` trap "
"if all calculations are expected to be exact."
msgstr ""
"В целом (и особенно в системах без избыточного распределения) рекомендуется "
"оценивать еще более жесткие границы и устанавливать ловушку :attr:`Inexact`, "
"если ожидается, что все вычисления будут точными."

#: ../../library/decimal.rst:2246
msgid ""
"This approach now works for all exact results except for non-integer powers."
msgstr ""
"Этот подход теперь работает для всех точных результатов, за исключением "
"нецелых степеней."
