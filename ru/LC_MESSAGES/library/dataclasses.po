# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Roustam Khamidoulline, 2024
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-25 14:54+0000\n"
"PO-Revision-Date: 2024-05-11 00:33+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/dataclasses.rst:2
msgid ":mod:`!dataclasses` --- Data Classes"
msgstr ":mod:`!dataclasses` --- Классы данных"

#: ../../library/dataclasses.rst:10
msgid "**Source code:** :source:`Lib/dataclasses.py`"
msgstr "**Исходный код:** :source:`Lib/dataclasses.py`"

#: ../../library/dataclasses.rst:14
msgid ""
"This module provides a decorator and functions for automatically adding "
"generated :term:`special methods <special method>` such as :meth:`~object."
"__init__` and :meth:`~object.__repr__` to user-defined classes.  It was "
"originally described in :pep:`557`."
msgstr ""
"Этот модуль предоставляет декоратор и функции для автоматического добавления "
"сгенерированных :term:`специальных методов <специальный метод>`, таких как :"
"meth:`~object.__init__` и :meth:`~object.__repr__` к пользовательским "
"классам. Первоначально он был описан в :pep:`557`."

#: ../../library/dataclasses.rst:19
msgid ""
"The member variables to use in these generated methods are defined using :"
"pep:`526` type annotations.  For example, this code::"
msgstr ""
"Переменные-члены, используемые в этих сгенерированных методах, определяются "
"с использованием аннотаций типа :pep:`526`. Например, этот код::"

#: ../../library/dataclasses.rst:22
msgid ""
"from dataclasses import dataclass\n"
"\n"
"@dataclass\n"
"class InventoryItem:\n"
"    \"\"\"Class for keeping track of an item in inventory.\"\"\"\n"
"    name: str\n"
"    unit_price: float\n"
"    quantity_on_hand: int = 0\n"
"\n"
"    def total_cost(self) -> float:\n"
"        return self.unit_price * self.quantity_on_hand"
msgstr ""
"from dataclasses import dataclass\n"
"\n"
"@dataclass\n"
"class InventoryItem:\n"
"    \"\"\"Class for keeping track of an item in inventory.\"\"\"\n"
"    name: str\n"
"    unit_price: float\n"
"    quantity_on_hand: int = 0\n"
"\n"
"    def total_cost(self) -> float:\n"
"        return self.unit_price * self.quantity_on_hand"

#: ../../library/dataclasses.rst:34
msgid "will add, among other things, a :meth:`!__init__` that looks like::"
msgstr "добавит, среди прочего, :meth:`!__init__`, который выглядит так::"

#: ../../library/dataclasses.rst:36
msgid ""
"def __init__(self, name: str, unit_price: float, quantity_on_hand: int = "
"0):\n"
"    self.name = name\n"
"    self.unit_price = unit_price\n"
"    self.quantity_on_hand = quantity_on_hand"
msgstr ""
"def __init__(self, name: str, unit_price: float, quantity_on_hand: int = "
"0):\n"
"    self.name = name\n"
"    self.unit_price = unit_price\n"
"    self.quantity_on_hand = quantity_on_hand"

#: ../../library/dataclasses.rst:41
msgid ""
"Note that this method is automatically added to the class: it is not "
"directly specified in the :class:`!InventoryItem` definition shown above."
msgstr ""
"Обратите внимание, что этот метод автоматически добавляется в класс: он не "
"указан напрямую в определении :class:`!InventoryItem`, показанном выше."

#: ../../library/dataclasses.rst:47
msgid "Module contents"
msgstr "Содержимое модуля"

#: ../../library/dataclasses.rst:51
msgid ""
"This function is a :term:`decorator` that is used to add generated :term:"
"`special methods <special method>` to classes, as described below."
msgstr ""
"Эта функция представляет собой декоратор, который используется для "
"добавления сгенерированных :term:`специальных методов <специальный метод>` к "
"классам, как описано ниже."

#: ../../library/dataclasses.rst:54
msgid ""
"The ``@dataclass`` decorator examines the class to find ``field``\\s.  A "
"``field`` is defined as a class variable that has a :term:`type annotation "
"<variable annotation>`.  With two exceptions described below, nothing in "
"``@dataclass`` examines the type specified in the variable annotation."
msgstr ""
"Декоратор @dataclass проверяет класс на наличие полей. ``Поле`` определяется "
"как переменная класса, имеющая аннотацию типа :term:`type <variable "
"annotation>`. За двумя исключениями, описанными ниже, ничто в ``@dataclass`` "
"не проверяет тип, указанный в аннотации переменной."

#: ../../library/dataclasses.rst:60
msgid ""
"The order of the fields in all of the generated methods is the order in "
"which they appear in the class definition."
msgstr ""
"Порядок полей во всех сгенерированных методах соответствует порядку, в "
"котором они появляются в определении класса."

#: ../../library/dataclasses.rst:63
msgid ""
"The ``@dataclass`` decorator will add various \"dunder\" methods to the "
"class, described below.  If any of the added methods already exist in the "
"class, the behavior depends on the parameter, as documented below. The "
"decorator returns the same class that it is called on; no new class is "
"created."
msgstr ""
"Декоратор ``@dataclass`` добавит к классу различные методы \"dunder\", "
"описанные ниже. Если какой-либо из добавленных методов уже существует в "
"классе, поведение зависит от параметра, как описано ниже. Декоратор "
"возвращает тот же класс, к которому он был вызван; новый класс не создается."

#: ../../library/dataclasses.rst:69
msgid ""
"If ``@dataclass`` is used just as a simple decorator with no parameters, it "
"acts as if it has the default values documented in this signature.  That is, "
"these three uses of ``@dataclass`` are equivalent::"
msgstr ""
"Если ``@dataclass`` используется как простой декоратор без параметров, он "
"действует так, как будто у него есть значения по умолчанию, "
"задокументированные в этой сигнатуре. То есть эти три варианта использования "
"``@dataclass`` эквивалентны:"

#: ../../library/dataclasses.rst:74
msgid ""
"@dataclass\n"
"class C:\n"
"    ...\n"
"\n"
"@dataclass()\n"
"class C:\n"
"    ...\n"
"\n"
"@dataclass(init=True, repr=True, eq=True, order=False, unsafe_hash=False, "
"frozen=False,\n"
"           match_args=True, kw_only=False, slots=False, weakref_slot=False)\n"
"class C:\n"
"    ..."
msgstr ""
"@dataclass\n"
"class C:\n"
"    ...\n"
"\n"
"@dataclass()\n"
"class C:\n"
"    ...\n"
"\n"
"@dataclass(init=True, repr=True, eq=True, order=False, unsafe_hash=False, "
"frozen=False,\n"
"           match_args=True, kw_only=False, slots=False, weakref_slot=False)\n"
"class C:\n"
"    ..."

#: ../../library/dataclasses.rst:87
msgid "The parameters to ``@dataclass`` are:"
msgstr "Параметры ``@dataclass``:"

#: ../../library/dataclasses.rst:89
msgid ""
"*init*: If true (the default), a :meth:`~object.__init__` method will be "
"generated."
msgstr ""
"*init*: если true (по умолчанию), будет сгенерирован метод :meth:`~object."
"__init__`."

#: ../../library/dataclasses.rst:92
msgid ""
"If the class already defines :meth:`!__init__`, this parameter is ignored."
msgstr ""
"Если класс уже определяет :meth:`!__init__`, этот параметр игнорируется."

#: ../../library/dataclasses.rst:95
msgid ""
"*repr*: If true (the default), a :meth:`~object.__repr__` method will be "
"generated.  The generated repr string will have the class name and the name "
"and repr of each field, in the order they are defined in the class.  Fields "
"that are marked as being excluded from the repr are not included.  For "
"example: ``InventoryItem(name='widget', unit_price=3.0, "
"quantity_on_hand=10)``."
msgstr ""
"*repr*: если true (по умолчанию), будет сгенерирован метод :meth:`~object."
"__repr__`. Сгенерированная строка представления будет содержать имя класса, "
"а также имя и представление каждого поля в том порядке, в котором они "
"определены в классе. Поля, помеченные как исключенные из представления, не "
"включаются. Например: ``InventoryItem(name='widget', unit_price=3.0, "
"Quantity_on_hand=10)``."

#: ../../library/dataclasses.rst:102
msgid ""
"If the class already defines :meth:`!__repr__`, this parameter is ignored."
msgstr ""
"Если класс уже определяет :meth:`!__repr__`, этот параметр игнорируется."

#: ../../library/dataclasses.rst:105
msgid ""
"*eq*: If true (the default), an :meth:`~object.__eq__` method will be "
"generated.  This method compares the class as if it were a tuple of its "
"fields, in order.  Both instances in the comparison must be of the identical "
"type."
msgstr ""
"*eq*: если true (по умолчанию), будет сгенерирован метод :meth:`~object."
"__eq__`. Этот метод сравнивает класс, как если бы он был кортежем его полей "
"по порядку. Оба экземпляра в сравнении должны быть одного и того же типа."

#: ../../library/dataclasses.rst:110
msgid ""
"If the class already defines :meth:`!__eq__`, this parameter is ignored."
msgstr "Если класс уже определяет :meth:`!__eq__`, этот параметр игнорируется."

#: ../../library/dataclasses.rst:113
msgid ""
"*order*: If true (the default is ``False``), :meth:`~object.__lt__`, :meth:"
"`~object.__le__`, :meth:`~object.__gt__`, and :meth:`~object.__ge__` methods "
"will be generated.  These compare the class as if it were a tuple of its "
"fields, in order.  Both instances in the comparison must be of the identical "
"type.  If *order* is true and *eq* is false, a :exc:`ValueError` is raised."
msgstr ""
"*order*: Если true (по умолчанию — «False»), :meth:`~object.__lt__`, :meth:"
"`~object.__le__`, :meth:`~object.__gt__` и :meth Будут сгенерированы методы :"
"`~object.__ge__`. Они сравнивают класс, как если бы он был кортежем его "
"полей по порядку. Оба экземпляра в сравнении должны быть одного и того же "
"типа. Если *order* имеет значение true, а *eq* имеет значение false, "
"возникает ошибка :exc:`ValueError`."

#: ../../library/dataclasses.rst:120
msgid ""
"If the class already defines any of :meth:`!__lt__`, :meth:`!__le__`, :meth:"
"`!__gt__`, or :meth:`!__ge__`, then :exc:`TypeError` is raised."
msgstr ""
"Если класс уже определяет любой из :meth:`!__lt__`, :meth:`!__le__`, :meth:`!"
"__gt__` или :meth:`!__ge__`, то возникает :exc:`TypeError`."

#: ../../library/dataclasses.rst:124
msgid ""
"*unsafe_hash*: If ``False`` (the default), a :meth:`~object.__hash__` method "
"is generated according to how *eq* and *frozen* are set."
msgstr ""
"*unsafe_hash*: если ``False`` (по умолчанию), метод :meth:`~object.__hash__` "
"генерируется в соответствии с тем, как установлены *eq* и *frozen*."

#: ../../library/dataclasses.rst:127
msgid ""
":meth:`!__hash__` is used by built-in :meth:`hash`, and when objects are "
"added to hashed collections such as dictionaries and sets.  Having a :meth:`!"
"__hash__` implies that instances of the class are immutable. Mutability is a "
"complicated property that depends on the programmer's intent, the existence "
"and behavior of :meth:`!__eq__`, and the values of the *eq* and *frozen* "
"flags in the ``@dataclass`` decorator."
msgstr ""
":meth:`!__hash__` используется встроенным :meth:`hash`, а также когда "
"объекты добавляются в хешированные коллекции, такие как словари и наборы. "
"Наличие :meth:`!__hash__` подразумевает, что экземпляры класса неизменяемы. "
"Изменяемость — это сложное свойство, которое зависит от намерений "
"программиста, существования и поведения :meth:`!__eq__` и значений флагов "
"*eq* и *frozen* в декораторе ``@dataclass``."

#: ../../library/dataclasses.rst:134
msgid ""
"By default, ``@dataclass`` will not implicitly add a :meth:`~object."
"__hash__` method unless it is safe to do so.  Neither will it add or change "
"an existing explicitly defined :meth:`!__hash__` method.  Setting the class "
"attribute ``__hash__ = None`` has a specific meaning to Python, as described "
"in the :meth:`!__hash__` documentation."
msgstr ""
"По умолчанию ``@dataclass`` не будет неявно добавлять метод :meth:`~object."
"__hash__`, если это не безопасно. Он также не будет добавлять или изменять "
"существующий явно определенный метод :meth:`!__hash__`. Установка атрибута "
"класса ``__hash__ = None`` имеет особое значение для Python, как описано в "
"документации :meth:`!__hash__`."

#: ../../library/dataclasses.rst:140
msgid ""
"If :meth:`!__hash__` is not explicitly defined, or if it is set to ``None``, "
"then ``@dataclass`` *may* add an implicit :meth:`!__hash__` method. Although "
"not recommended, you can force ``@dataclass`` to create a :meth:`!__hash__` "
"method with ``unsafe_hash=True``. This might be the case if your class is "
"logically immutable but can still be mutated. This is a specialized use case "
"and should be considered carefully."
msgstr ""
"Если :meth:`!__hash__` не определен явно или для него установлено значение "
"``None``, то ``@dataclass`` *может* добавить неявный метод :meth:`!"
"__hash__`. Хотя это и не рекомендуется, вы можете заставить ``@dataclass`` "
"создать метод :meth:`!__hash__` с ``unsafe_hash=True``. Это может быть тот "
"случай, если ваш класс логически неизменяем, но все равно может быть "
"изменен. Это специализированный вариант использования, и его следует "
"тщательно рассмотреть."

#: ../../library/dataclasses.rst:147
msgid ""
"Here are the rules governing implicit creation of a :meth:`!__hash__` "
"method.  Note that you cannot both have an explicit :meth:`!__hash__` method "
"in your dataclass and set ``unsafe_hash=True``; this will result in a :exc:"
"`TypeError`."
msgstr ""
"Вот правила, управляющие неявным созданием метода :meth:`!__hash__`. "
"Обратите внимание, что вы не можете одновременно иметь явный метод :meth:`!"
"__hash__` в своем классе данных и установить ``unsafe_hash=True``; это "
"приведет к ошибке :exc:`TypeError`."

#: ../../library/dataclasses.rst:152
msgid ""
"If *eq* and *frozen* are both true, by default ``@dataclass`` will generate "
"a :meth:`!__hash__` method for you.  If *eq* is true and *frozen* is false, :"
"meth:`!__hash__` will be set to ``None``, marking it unhashable (which it "
"is, since it is mutable).  If *eq* is false, :meth:`!__hash__` will be left "
"untouched meaning the :meth:`!__hash__` method of the superclass will be "
"used (if the superclass is :class:`object`, this means it will fall back to "
"id-based hashing)."
msgstr ""
"Если *eq* и *frozen* оба верны, по умолчанию @dataclass`` сгенерирует для "
"вас метод :meth:`!__hash__`. Если *eq* имеет значение true, а *frozen* имеет "
"значение false, :meth:`!__hash__` будет установлен в значение ``None``, "
"отмечая его как нехешируемый (что и является таковым, поскольку он "
"изменяем). Если *eq* имеет значение false, :meth:`!__hash__` останется "
"нетронутым, что означает, что будет использоваться метод :meth:`!__hash__` "
"суперкласса (если суперклассом является :class:`object`, это означает, что "
"он будет вернуться к хешированию на основе идентификатора)."

#: ../../library/dataclasses.rst:160
msgid ""
"*frozen*: If true (the default is ``False``), assigning to fields will "
"generate an exception.  This emulates read-only frozen instances.  If :meth:"
"`~object.__setattr__` or :meth:`~object.__delattr__` is defined in the "
"class, then :exc:`TypeError` is raised.  See the discussion below."
msgstr ""
"*frozen*: Если true (по умолчанию — False), присвоение полям приведет к "
"возникновению исключения. Это эмулирует замороженные экземпляры, доступные "
"только для чтения. Если в классе определено :meth:`~object.__setattr__` или :"
"meth:`~object.__delattr__`, то возникает :exc:`TypeError`. Смотрите "
"обсуждение ниже."

#: ../../library/dataclasses.rst:165
msgid ""
"*match_args*: If true (the default is ``True``), the :attr:`~object."
"__match_args__` tuple will be created from the list of non keyword-only "
"parameters to the generated :meth:`~object.__init__` method (even if :meth:`!"
"__init__` is not generated, see above).  If false, or if :attr:`!"
"__match_args__` is already defined in the class, then :attr:`!"
"__match_args__` will not be generated."
msgstr ""
"*match_args*: Если true (по умолчанию ``True``), кортеж :attr:`~object."
"__match_args__` будет создан из списка параметров, не являющихся только "
"ключевыми словами, для сгенерированного метода :meth:`~object.__init__` "
"(даже если :meth:`!__init__` не сгенерирован, см. выше). Если false или "
"если :attr:`!__match_args__` уже определен в классе, то :attr:`!"
"__match_args__` не будет сгенерирован."

#: ../../library/dataclasses.rst:174
msgid ""
"*kw_only*: If true (the default value is ``False``), then all fields will be "
"marked as keyword-only.  If a field is marked as keyword-only, then the only "
"effect is that the :meth:`~object.__init__` parameter generated from a "
"keyword-only field must be specified with a keyword when :meth:`!__init__` "
"is called. See the :term:`parameter` glossary entry for details.  Also see "
"the :const:`KW_ONLY` section."
msgstr ""
"*kw_only*: Если true (значение по умолчанию ``False``), то все поля будут "
"помечены как содержащие только ключевые слова. Если поле помечено как "
"содержащее только ключевые слова, то единственным эффектом будет то, что "
"параметр :meth:`~object.__init__`, сгенерированный из поля, содержащего "
"только ключевые слова, должен быть указан с ключевым словом при вызове :meth:"
"`!__init__`. Подробности см. в записи глоссария :term:`parameter`. Также см. "
"раздел :const:`KW_ONLY`."

#: ../../library/dataclasses.rst:182
msgid "Keyword-only fields are not included in :attr:`!__match_args__`."
msgstr ""

#: ../../library/dataclasses.rst:186
msgid ""
"*slots*: If true (the default is ``False``), :attr:`~object.__slots__` "
"attribute will be generated and new class will be returned instead of the "
"original one. If :attr:`!__slots__` is already defined in the class, then :"
"exc:`TypeError` is raised."
msgstr ""
"*slots*: если true (по умолчанию установлено ``False``), будет создан "
"атрибут :attr:`~object.__slots__` и вместо исходного будет возвращен новый "
"класс. Если :attr:`!__slots__` уже определен в классе, то возникает :exc:"
"`TypeError`."

#: ../../library/dataclasses.rst:192
msgid ""
"Calling no-arg :func:`super` in dataclasses using ``slots=True`` will result "
"in the following exception being raised: ``TypeError: super(type, obj): obj "
"must be an instance or subtype of type``. The two-arg :func:`super` is a "
"valid workaround. See :gh:`90562` for full details."
msgstr ""
"Вызов no-arg :func:`super` в классах данных с использованием ``slots=True`` "
"приведет к возникновению следующего исключения: ``TypeError: super(type, "
"obj): obj должен быть экземпляром или подтипом типа` `. Использование :func:"
"`super` с двумя аргументами является допустимым обходным решением. Подробную "
"информацию см. в :gh:`90562`."

#: ../../library/dataclasses.rst:199
msgid ""
"Passing parameters to a base class :meth:`~object.__init_subclass__` when "
"using ``slots=True`` will result in a :exc:`TypeError`. Either use "
"``__init_subclass__`` with no parameters or use default values as a "
"workaround. See :gh:`91126` for full details."
msgstr ""
"Передача параметров базовому классу :meth:`~object.__init_subclass__` при "
"использовании ``slots=True`` приведет к ошибке :exc:`TypeError`. Либо "
"используйте ``__init_subclass__`` без параметров, либо используйте значения "
"по умолчанию в качестве обходного пути. Подробную информацию см. в :gh:"
"`91126`."

#: ../../library/dataclasses.rst:207
msgid ""
"If a field name is already included in the :attr:`!__slots__` of a base "
"class, it will not be included in the generated :attr:`!__slots__` to "
"prevent :ref:`overriding them <datamodel-note-slots>`. Therefore, do not "
"use :attr:`!__slots__` to retrieve the field names of a dataclass. Use :func:"
"`fields` instead. To be able to determine inherited slots, base class :attr:"
"`!__slots__` may be any iterable, but *not* an iterator."
msgstr ""
"Если имя поля уже включено в :attr:`!__slots__` базового класса, оно не "
"будет включено в сгенерированный :attr:`!__slots__`, чтобы предотвратить :"
"ref:`переопределение их <datamodel-note-slots >`. Поэтому не используйте :"
"attr:`!__slots__` для получения имен полей класса данных. Вместо этого "
"используйте :func:`fields`. Чтобы иметь возможность определять "
"унаследованные слоты, базовый класс :attr:`!__slots__` может быть любым "
"итерируемым, но *не* итератором."

#: ../../library/dataclasses.rst:217
msgid ""
"*weakref_slot*: If true (the default is ``False``), add a slot named "
"\"__weakref__\", which is required to make an instance :func:`weakref-able "
"<weakref.ref>`. It is an error to specify ``weakref_slot=True`` without also "
"specifying ``slots=True``."
msgstr ""
"*weakref_slot*: если это правда (по умолчанию — «False»), добавьте слот с "
"именем «__weakref__», который необходим для создания экземпляра :func:"
"`weakref-able <weakref.ref>`. Указание ``weakref_slot=True`` без указания "
"``slots=True`` является ошибкой."

#: ../../library/dataclasses.rst:225
msgid ""
"``field``\\s may optionally specify a default value, using normal Python "
"syntax::"
msgstr ""
"``field``\\s может опционально указывать значение по умолчанию, используя "
"обычный синтаксис Python::"

#: ../../library/dataclasses.rst:228
msgid ""
"@dataclass\n"
"class C:\n"
"    a: int       # 'a' has no default value\n"
"    b: int = 0   # assign a default value for 'b'"
msgstr ""
"@dataclass\n"
"class C:\n"
"    a: int       # 'a' has no default value\n"
"    b: int = 0   # assign a default value for 'b'"

#: ../../library/dataclasses.rst:233
msgid ""
"In this example, both :attr:`!a` and :attr:`!b` will be included in the "
"added :meth:`~object.__init__` method, which will be defined as::"
msgstr ""
"В этом примере оба :attr:`!a` и :attr:`!b` будут включены в добавленный "
"метод :meth:`~object.__init__`, который будет определен как::"

#: ../../library/dataclasses.rst:236
msgid "def __init__(self, a: int, b: int = 0):"
msgstr "def __init__(self, a: int, b: int = 0):"

#: ../../library/dataclasses.rst:238
msgid ""
":exc:`TypeError` will be raised if a field without a default value follows a "
"field with a default value.  This is true whether this occurs in a single "
"class, or as a result of class inheritance."
msgstr ""
":exc:`TypeError` будет вызван, если поле без значения по умолчанию следует "
"за полем со значением по умолчанию. Это справедливо независимо от того, "
"происходит ли это в одном классе или в результате наследования классов."

#: ../../library/dataclasses.rst:244
msgid ""
"For common and simple use cases, no other functionality is required.  There "
"are, however, some dataclass features that require additional per-field "
"information.  To satisfy this need for additional information, you can "
"replace the default field value with a call to the provided :func:`!field` "
"function.  For example::"
msgstr ""
"Для распространенных и простых случаев использования никаких других функций "
"не требуется. Однако существуют некоторые функции классов данных, которые "
"требуют дополнительной информации для каждого поля. Чтобы удовлетворить "
"потребность в дополнительной информации, вы можете заменить значение поля по "
"умолчанию вызовом предоставленной функции :func:`!field`. Например::"

#: ../../library/dataclasses.rst:250
msgid ""
"@dataclass\n"
"class C:\n"
"    mylist: list[int] = field(default_factory=list)\n"
"\n"
"c = C()\n"
"c.mylist += [1, 2, 3]"
msgstr ""
"@dataclass\n"
"class C:\n"
"    mylist: list[int] = field(default_factory=list)\n"
"\n"
"c = C()\n"
"c.mylist += [1, 2, 3]"

#: ../../library/dataclasses.rst:257
msgid ""
"As shown above, the :const:`MISSING` value is a sentinel object used to "
"detect if some parameters are provided by the user. This sentinel is used "
"because ``None`` is a valid value for some parameters with a distinct "
"meaning.  No code should directly use the :const:`MISSING` value."
msgstr ""
"Как показано выше, значение :const:`MISSING` — это контрольный объект, "
"используемый для определения того, предоставлены ли пользователем некоторые "
"параметры. Этот контрольный показатель используется, поскольку «Нет» "
"является допустимым значением для некоторых параметров с особым значением. "
"Ни один код не должен напрямую использовать значение :const:`MISSING`."

#: ../../library/dataclasses.rst:262
msgid "The parameters to :func:`!field` are:"
msgstr "Параметры :func:`!field`:"

#: ../../library/dataclasses.rst:264
msgid ""
"*default*: If provided, this will be the default value for this field.  This "
"is needed because the :func:`!field` call itself replaces the normal "
"position of the default value."
msgstr ""
"*default*: если указано, это будет значение по умолчанию для этого поля. Это "
"необходимо, поскольку вызов :func:`!field` сам по себе заменяет нормальную "
"позицию значения по умолчанию."

#: ../../library/dataclasses.rst:268
msgid ""
"*default_factory*: If provided, it must be a zero-argument callable that "
"will be called when a default value is needed for this field.  Among other "
"purposes, this can be used to specify fields with mutable default values, as "
"discussed below.  It is an error to specify both *default* and "
"*default_factory*."
msgstr ""
"*default_factory*: Если указано, это должен быть вызываемый объект без "
"аргументов, который будет вызываться, когда для этого поля потребуется "
"значение по умолчанию. Помимо прочего, это можно использовать для указания "
"полей с изменяемыми значениями по умолчанию, как описано ниже. Указание "
"*default* и *default_factory* является ошибкой."

#: ../../library/dataclasses.rst:274
msgid ""
"*init*: If true (the default), this field is included as a parameter to the "
"generated :meth:`~object.__init__` method."
msgstr ""
"*init*: если true (по умолчанию), это поле включается в качестве параметра в "
"сгенерированный метод :meth:`~object.__init__`."

#: ../../library/dataclasses.rst:277
msgid ""
"*repr*: If true (the default), this field is included in the string returned "
"by the generated :meth:`~object.__repr__` method."
msgstr ""
"*repr*: если true (по умолчанию), это поле включается в строку, возвращаемую "
"сгенерированным методом :meth:`~object.__repr__`."

#: ../../library/dataclasses.rst:280
msgid ""
"*hash*: This can be a bool or ``None``.  If true, this field is included in "
"the generated :meth:`~object.__hash__` method.  If false, this field is "
"excluded from the generated :meth:`~object.__hash__`. If ``None`` (the "
"default), use the value of *compare*: this would normally be the expected "
"behavior, since a field should be included in the hash if it's used for "
"comparisons.  Setting this value to anything other than ``None`` is "
"discouraged."
msgstr ""
"*хэш*: это может быть Bool или `` none``. Если это правда, это поле включено "
"в метод сгенерированного: мета: `~ объект .__ hash__`. Если ложь, это поле "
"исключено из сгенерированного: мета: `~ объект .__ Hash__`. Если `` none`` "
"(по умолчанию), используйте значение *compare *: это обычно было бы "
"ожидаемым поведением, поскольку поле следует включать в хэш, если оно "
"используется для сравнения. Установка этого значения для чего -либо, кроме "
"`` none``, не рекомендуется."

#: ../../library/dataclasses.rst:288
msgid ""
"One possible reason to set ``hash=False`` but ``compare=True`` would be if a "
"field is expensive to compute a hash value for, that field is needed for "
"equality testing, and there are other fields that contribute to the type's "
"hash value.  Even if a field is excluded from the hash, it will still be "
"used for comparisons."
msgstr ""
"Одной из возможных причин установки ``hash=False``, но ``compare=True`` "
"может быть то, что вычисление хеш-значения для поля требует больших затрат, "
"это поле необходимо для проверки на равенство, и есть другие поля, которые "
"способствуют хеш-значение типа. Даже если поле исключено из хэша, оно все "
"равно будет использоваться для сравнения."

#: ../../library/dataclasses.rst:294
msgid ""
"*compare*: If true (the default), this field is included in the generated "
"equality and comparison methods (:meth:`~object.__eq__`, :meth:`~object."
"__gt__`, et al.)."
msgstr ""
"*compare*: если true (по умолчанию), это поле включается в генерируемые "
"методы равенства и сравнения (:meth:`~object.__eq__`, :meth:`~object.__gt__` "
"и др.)."

#: ../../library/dataclasses.rst:298
msgid ""
"*metadata*: This can be a mapping or ``None``. ``None`` is treated as an "
"empty dict.  This value is wrapped in :func:`~types.MappingProxyType` to "
"make it read-only, and exposed on the :class:`Field` object. It is not used "
"at all by Data Classes, and is provided as a third-party extension "
"mechanism. Multiple third-parties can each have their own key, to use as a "
"namespace in the metadata."
msgstr ""
"*метаданные*: это может быть сопоставление или «Нет». ``None`` "
"рассматривается как пустой словарь. Это значение заключено в :func:`~types."
"MappingProxyType`, чтобы сделать его доступным только для чтения, и "
"отображается в объекте :class:`Field`. Он вообще не используется классами "
"данных и предоставляется как сторонний механизм расширения. Каждая из "
"нескольких третьих сторон может иметь свой собственный ключ, который можно "
"использовать в качестве пространства имен в метаданных."

#: ../../library/dataclasses.rst:306
msgid ""
"*kw_only*: If true, this field will be marked as keyword-only. This is used "
"when the generated :meth:`~object.__init__` method's parameters are computed."
msgstr ""
"*kw_only*: если true, это поле будет помечено как предназначенное только для "
"ключевых слов. Это используется при вычислении параметров сгенерированного "
"метода :meth:`~object.__init__`."

#: ../../library/dataclasses.rst:310
msgid "Keyword-only fields are also not included in :attr:`!__match_args__`."
msgstr ""

#: ../../library/dataclasses.rst:314
msgid ""
"If the default value of a field is specified by a call to :func:`!field`, "
"then the class attribute for this field will be replaced by the specified "
"*default* value.  If *default* is not provided, then the class attribute "
"will be deleted.  The intent is that after the :func:`@dataclass "
"<dataclass>` decorator runs, the class attributes will all contain the "
"default values for the fields, just as if the default value itself were "
"specified.  For example, after::"
msgstr ""
"Если значение поля по умолчанию указано вызовом :func:`!field`, то атрибут "
"класса для этого поля будет заменен указанным значением *default*. Если "
"*default* не указано, атрибут класса будет удален. Цель состоит в том, чтобы "
"после запуска декоратора :func:`@dataclass <dataclass>` все атрибуты класса "
"будут содержать значения по умолчанию для полей, как если бы было указано "
"само значение по умолчанию. Например, после::"

#: ../../library/dataclasses.rst:323
msgid ""
"@dataclass\n"
"class C:\n"
"    x: int\n"
"    y: int = field(repr=False)\n"
"    z: int = field(repr=False, default=10)\n"
"    t: int = 20"
msgstr ""
"@dataclass\n"
"class C:\n"
"    x: int\n"
"    y: int = field(repr=False)\n"
"    z: int = field(repr=False, default=10)\n"
"    t: int = 20"

#: ../../library/dataclasses.rst:330
msgid ""
"The class attribute :attr:`!C.z` will be ``10``, the class attribute :attr:`!"
"C.t` will be ``20``, and the class attributes :attr:`!C.x` and :attr:`!C.y` "
"will not be set."
msgstr ""
"Атрибут класса :attr:`!Cz` будет равен ``10``, атрибут класса :attr:`!Ct` "
"будет ``20``, а атрибуты класса :attr:`!Cx` и :attr :`!Cy` не будет "
"установлен."

#: ../../library/dataclasses.rst:336
msgid ""
":class:`!Field` objects describe each defined field. These objects are "
"created internally, and are returned by the :func:`fields` module-level "
"method (see below).  Users should never instantiate a :class:`!Field` object "
"directly.  Its documented attributes are:"
msgstr ""
"Объекты :class:`!Field` описывают каждое определенное поле. Эти объекты "
"создаются внутри и возвращаются методом уровня модуля :func:`fields` (см. "
"ниже). Пользователи никогда не должны создавать экземпляр объекта :class:`!"
"Field` напрямую. Его документированные атрибуты:"

#: ../../library/dataclasses.rst:341
msgid ":attr:`!name`: The name of the field."
msgstr ":attr:`!name`: Имя поля."

#: ../../library/dataclasses.rst:342
msgid ":attr:`!type`: The type of the field."
msgstr ":attr:`!type`: Тип поля."

#: ../../library/dataclasses.rst:343
msgid ""
":attr:`!default`, :attr:`!default_factory`, :attr:`!init`, :attr:`!repr`, :"
"attr:`!hash`, :attr:`!compare`, :attr:`!metadata`, and :attr:`!kw_only` have "
"the identical meaning and values as they do in the :func:`field` function."
msgstr ""
":attr:`!default`, :attr:`!default_factory`, :attr:`!init`, :attr:`!repr`, :"
"attr:`!hash`, :attr:`!compare`, :attr :`!metadata` и :attr:`!kw_only` имеют "
"то же значение и значения, что и в функции :func:`field`."

#: ../../library/dataclasses.rst:347
msgid ""
"Other attributes may exist, but they are private and must not be inspected "
"or relied on."
msgstr ""
"Могут существовать и другие атрибуты, но они являются частными и не должны "
"проверяться или на них нельзя полагаться."

#: ../../library/dataclasses.rst:352
msgid ""
"Returns a tuple of :class:`Field` objects that define the fields for this "
"dataclass.  Accepts either a dataclass, or an instance of a dataclass. "
"Raises :exc:`TypeError` if not passed a dataclass or instance of one. Does "
"not return pseudo-fields which are ``ClassVar`` or ``InitVar``."
msgstr ""
"Возвращает кортеж объектов :class:`Field`, которые определяют поля для этого "
"класса данных. Принимает либо класс данных, либо экземпляр класса данных. "
"Вызывает :exc:`TypeError`, если не передан класс данных или его экземпляр. "
"Не возвращает псевдополя ClassVar или InitVar."

#: ../../library/dataclasses.rst:359
msgid ""
"Converts the dataclass *obj* to a dict (by using the factory function "
"*dict_factory*).  Each dataclass is converted to a dict of its fields, as "
"``name: value`` pairs.  dataclasses, dicts, lists, and tuples are recursed "
"into.  Other objects are copied with :func:`copy.deepcopy`."
msgstr ""
"Преобразует класс данных *obj* в dict (с помощью фабричной функции "
"*dict_factory*). Каждый класс данных преобразуется в набор своих полей в "
"виде пар «имя: значение». классы данных, словари, списки и кортежи "
"рекурсивно выполняются. Другие объекты копируются с помощью :func:`copy."
"deepcopy`."

#: ../../library/dataclasses.rst:365
msgid "Example of using :func:`!asdict` on nested dataclasses::"
msgstr "Пример использования :func:`!asdict` для вложенных классов данных::"

#: ../../library/dataclasses.rst:367
msgid ""
"@dataclass\n"
"class Point:\n"
"     x: int\n"
"     y: int\n"
"\n"
"@dataclass\n"
"class C:\n"
"     mylist: list[Point]\n"
"\n"
"p = Point(10, 20)\n"
"assert asdict(p) == {'x': 10, 'y': 20}\n"
"\n"
"c = C([Point(0, 0), Point(10, 4)])\n"
"assert asdict(c) == {'mylist': [{'x': 0, 'y': 0}, {'x': 10, 'y': 4}]}"
msgstr ""
"@dataclass\n"
"class Point:\n"
"     x: int\n"
"     y: int\n"
"\n"
"@dataclass\n"
"class C:\n"
"     mylist: list[Point]\n"
"\n"
"p = Point(10, 20)\n"
"assert asdict(p) == {'x': 10, 'y': 20}\n"
"\n"
"c = C([Point(0, 0), Point(10, 4)])\n"
"assert asdict(c) == {'mylist': [{'x': 0, 'y': 0}, {'x': 10, 'y': 4}]}"

#: ../../library/dataclasses.rst:382 ../../library/dataclasses.rst:402
msgid "To create a shallow copy, the following workaround may be used::"
msgstr ""
"Чтобы создать неглубокую копию, можно использовать следующий обходной путь:"

#: ../../library/dataclasses.rst:384
msgid "{field.name: getattr(obj, field.name) for field in fields(obj)}"
msgstr "{field.name: getattr(obj, field.name) для поля в полях(obj)}"

#: ../../library/dataclasses.rst:386
msgid ""
":func:`!asdict` raises :exc:`TypeError` if *obj* is not a dataclass instance."
msgstr ""
":func:`!asdict` вызывает :exc:`TypeError`, если *obj* не является "
"экземпляром класса данных."

#: ../../library/dataclasses.rst:391
msgid ""
"Converts the dataclass *obj* to a tuple (by using the factory function "
"*tuple_factory*).  Each dataclass is converted to a tuple of its field "
"values.  dataclasses, dicts, lists, and tuples are recursed into. Other "
"objects are copied with :func:`copy.deepcopy`."
msgstr ""
"Преобразует класс данных *obj* в кортеж (с помощью фабричной функции "
"*tuple_factory*). Каждый класс данных преобразуется в кортеж значений его "
"полей. классы данных, словари, списки и кортежи рекурсивно выполняются. "
"Другие объекты копируются с помощью :func:`copy.deepcopy`."

#: ../../library/dataclasses.rst:397
msgid "Continuing from the previous example::"
msgstr "Продолжая предыдущий пример:"

#: ../../library/dataclasses.rst:399
msgid ""
"assert astuple(p) == (10, 20)\n"
"assert astuple(c) == ([(0, 0), (10, 4)],)"
msgstr ""
"assert astuple(p) == (10, 20)\n"
"assert astuple(c) == ([(0, 0), (10, 4)],)"

#: ../../library/dataclasses.rst:404
msgid "tuple(getattr(obj, field.name) for field in dataclasses.fields(obj))"
msgstr "tuple(getattr(obj, field.name) for field in dataclasses.fields(obj))"

#: ../../library/dataclasses.rst:406
msgid ""
":func:`!astuple` raises :exc:`TypeError` if *obj* is not a dataclass "
"instance."
msgstr ""
":func:`!astuple` вызывает :exc:`TypeError`, если *obj* не является "
"экземпляром класса данных."

#: ../../library/dataclasses.rst:411
msgid ""
"Creates a new dataclass with name *cls_name*, fields as defined in *fields*, "
"base classes as given in *bases*, and initialized with a namespace as given "
"in *namespace*.  *fields* is an iterable whose elements are each either "
"``name``, ``(name, type)``, or ``(name, type, Field)``.  If just ``name`` is "
"supplied, :data:`typing.Any` is used for ``type``.  The values of *init*, "
"*repr*, *eq*, *order*, *unsafe_hash*, *frozen*, *match_args*, *kw_only*, "
"*slots*, and *weakref_slot* have the same meaning as they do in :func:"
"`@dataclass <dataclass>`."
msgstr ""
"Создает новый класс данных с именем *cls_name*, полями, как определено в "
"*fields*, базовыми классами, как указано в *bases*, и инициализируется "
"пространством имен, указанным в *namespace*. *fields* — это итерация, каждый "
"из элементов которой представляет собой ``name``, ``(name, type)`` или "
"``(name, type, Field)``. Если указано только ``name``, для ``type`` "
"используется :data:`typing.Any`. Значения *init*, *repr*, *eq*, *order*, "
"*unsafe_hash*, *frozen*, *match_args*, *kw_only*, *slots* и *weakref_slot* "
"имеют то же значение, что и они. в :func:`@dataclass <dataclass>`."

#: ../../library/dataclasses.rst:421
msgid ""
"If *module* is defined, the :attr:`!__module__` attribute of the dataclass "
"is set to that value. By default, it is set to the module name of the caller."
msgstr ""
"Если *module* определен, атрибуту :attr:`!__module__` класса данных "
"присваивается это значение. По умолчанию установлено имя модуля вызывающего "
"объекта."

#: ../../library/dataclasses.rst:425
msgid ""
"This function is not strictly required, because any Python mechanism for "
"creating a new class with :attr:`!__annotations__` can then apply the :func:"
"`@dataclass <dataclass>` function to convert that class to a dataclass.  "
"This function is provided as a convenience.  For example::"
msgstr ""
"Эта функция не является строго обязательной, поскольку любой механизм Python "
"для создания нового класса с помощью :attr:`!__annotations__` может затем "
"применить функцию :func:`@dataclass <dataclass>` для преобразования этого "
"класса в класс данных. Эта функция предусмотрена для удобства. Например::"

#: ../../library/dataclasses.rst:431
msgid ""
"C = make_dataclass('C',\n"
"                   [('x', int),\n"
"                     'y',\n"
"                    ('z', int, field(default=5))],\n"
"                   namespace={'add_one': lambda self: self.x + 1})"
msgstr ""
"C = make_dataclass('C',\n"
"                   [('x', int),\n"
"                     'y',\n"
"                    ('z', int, field(default=5))],\n"
"                   namespace={'add_one': lambda self: self.x + 1})"

#: ../../library/dataclasses.rst:437
msgid "Is equivalent to::"
msgstr "Это эквивалентно::"

#: ../../library/dataclasses.rst:439
msgid ""
"@dataclass\n"
"class C:\n"
"    x: int\n"
"    y: 'typing.Any'\n"
"    z: int = 5\n"
"\n"
"    def add_one(self):\n"
"        return self.x + 1"
msgstr ""
"@dataclass\n"
"class C:\n"
"    x: int\n"
"    y: 'typing.Any'\n"
"    z: int = 5\n"
"\n"
"    def add_one(self):\n"
"        return self.x + 1"

#: ../../library/dataclasses.rst:450
msgid ""
"Creates a new object of the same type as *obj*, replacing fields with values "
"from *changes*.  If *obj* is not a Data Class, raises :exc:`TypeError`.  If "
"keys in *changes* are not field names of the given dataclass, raises :exc:"
"`TypeError`."
msgstr ""
"Создает новый объект того же типа, что и *obj*, заменяя поля значениями из "
"*changes*. Если *obj* не является классом данных, выдается :exc:`TypeError`. "
"Если ключи в *changes* не являются именами полей данного класса данных, "
"выдается :exc:`TypeError`."

#: ../../library/dataclasses.rst:455
msgid ""
"The newly returned object is created by calling the :meth:`~object.__init__` "
"method of the dataclass.  This ensures that :meth:`__post_init__`, if "
"present, is also called."
msgstr ""
"Вновь возвращенный объект создается путем вызова метода :meth:`~object."
"__init__` класса данных. Это гарантирует, что :meth:`__post_init__`, если он "
"присутствует, также будет вызван."

#: ../../library/dataclasses.rst:459
msgid ""
"Init-only variables without default values, if any exist, must be specified "
"on the call to :func:`!replace` so that they can be passed to :meth:`!"
"__init__` and :meth:`__post_init__`."
msgstr ""
"Переменные только для инициализации без значений по умолчанию, если таковые "
"существуют, должны быть указаны при вызове :func:`!replace`, чтобы их можно "
"было передать в :meth:`!__init__` и :meth:`__post_init__`."

#: ../../library/dataclasses.rst:463
msgid ""
"It is an error for *changes* to contain any fields that are defined as "
"having ``init=False``.  A :exc:`ValueError` will be raised in this case."
msgstr ""
"Если *changes* содержит какие-либо поля, которые определены как имеющие "
"``init=False``, это ошибка. В этом случае будет выдано :exc:`ValueError`."

#: ../../library/dataclasses.rst:467
msgid ""
"Be forewarned about how ``init=False`` fields work during a call to :func:`!"
"replace`.  They are not copied from the source object, but rather are "
"initialized in :meth:`__post_init__`, if they're initialized at all.  It is "
"expected that ``init=False`` fields will be rarely and judiciously used.  If "
"they are used, it might be wise to have alternate class constructors, or "
"perhaps a custom :func:`!replace` (or similarly named) method which handles "
"instance copying."
msgstr ""
"Будьте предупреждены о том, как работают поля ``init=False`` во время "
"вызова :func:`!replace`. Они не копируются из исходного объекта, а "
"инициализируются в :meth:`__post_init__`, если они вообще инициализируются. "
"Ожидается, что поля init=False будут использоваться редко и разумно. Если "
"они используются, возможно, было бы разумно иметь альтернативные "
"конструкторы классов или, возможно, специальный метод :func:`!replace` (или "
"с аналогичным названием), который обрабатывает копирование экземпляров."

#: ../../library/dataclasses.rst:478
msgid ""
"Return ``True`` if its parameter is a dataclass (including subclasses of a "
"dataclass) or an instance of one, otherwise return ``False``."
msgstr ""
"Возвращайте ``True``, если его параметром является класс данных (включая "
"подклассы класса данных) или его экземпляр, в противном случае возвращайте "
"``False``."

#: ../../library/dataclasses.rst:481
msgid ""
"If you need to know if a class is an instance of a dataclass (and not a "
"dataclass itself), then add a further check for ``not isinstance(obj, "
"type)``::"
msgstr ""
"Если вам нужно узнать, является ли класс экземпляром класса данных (а не "
"самим классом данных), добавьте дополнительную проверку ``not "
"isinstance(obj, type)``::"

#: ../../library/dataclasses.rst:485
msgid ""
"def is_dataclass_instance(obj):\n"
"    return is_dataclass(obj) and not isinstance(obj, type)"
msgstr ""
"защита is_dataclass_instance (объект): вернуть is_dataclass(obj), а не "
"isinstance(obj, type)"

#: ../../library/dataclasses.rst:490
msgid "A sentinel value signifying a missing default or default_factory."
msgstr ""
"Контрольное значение, обозначающее отсутствие значения default или "
"default_factory."

#: ../../library/dataclasses.rst:494
msgid ""
"A sentinel value used as a type annotation.  Any fields after a pseudo-field "
"with the type of :const:`!KW_ONLY` are marked as keyword-only fields.  Note "
"that a pseudo-field of type :const:`!KW_ONLY` is otherwise completely "
"ignored.  This includes the name of such a field.  By convention, a name of "
"``_`` is used for a :const:`!KW_ONLY` field.  Keyword-only fields signify :"
"meth:`~object.__init__` parameters that must be specified as keywords when "
"the class is instantiated."
msgstr ""
"Контрольное значение, используемое в качестве аннотации типа. Любые поля "
"после псевдополя типа :const:`!KW_ONLY` помечаются как поля только для "
"ключевых слов. Обратите внимание, что псевдополе типа :const:`!KW_ONLY` в "
"противном случае полностью игнорируется. Сюда входит имя такого поля. По "
"соглашению, имя ``_`` используется для поля :const:`!KW_ONLY`. Поля, "
"содержащие только ключевые слова, обозначают параметры :meth:`~object."
"__init__`, которые должны быть указаны как ключевые слова при создании "
"экземпляра класса."

#: ../../library/dataclasses.rst:503
msgid ""
"In this example, the fields ``y`` and ``z`` will be marked as keyword-only "
"fields::"
msgstr ""
"В этом примере поля ``y`` и ``z`` будут помечены как поля только для "
"ключевых слов:"

#: ../../library/dataclasses.rst:505
msgid ""
"@dataclass\n"
"class Point:\n"
"    x: float\n"
"    _: KW_ONLY\n"
"    y: float\n"
"    z: float\n"
"\n"
"p = Point(0, y=1.5, z=2.0)"
msgstr ""
"@dataclass\n"
"class Point:\n"
"    x: float\n"
"    _: KW_ONLY\n"
"    y: float\n"
"    z: float\n"
"\n"
"p = Point(0, y=1.5, z=2.0)"

#: ../../library/dataclasses.rst:514
msgid ""
"In a single dataclass, it is an error to specify more than one field whose "
"type is :const:`!KW_ONLY`."
msgstr ""
"В одном классе данных указывать более одного поля типа :const:`!KW_ONLY` "
"является ошибкой."

#: ../../library/dataclasses.rst:521
msgid ""
"Raised when an implicitly defined :meth:`~object.__setattr__` or :meth:"
"`~object.__delattr__` is called on a dataclass which was defined with "
"``frozen=True``. It is a subclass of :exc:`AttributeError`."
msgstr ""
"Возникает, когда неявно определенный :meth:`~object.__setattr__` или :meth:"
"`~object.__delattr__` вызывается для класса данных, который был определен с "
"``frozen=True``. Это подкласс :exc:`AttributeError`."

#: ../../library/dataclasses.rst:528
msgid "Post-init processing"
msgstr "Обработка после инициализации"

#: ../../library/dataclasses.rst:532
msgid ""
"When defined on the class, it will be called by the generated :meth:`~object."
"__init__`, normally as :meth:`!self.__post_init__`. However, if any "
"``InitVar`` fields are defined, they will also be passed to :meth:`!"
"__post_init__` in the order they were defined in the class.  If no :meth:`!"
"__init__` method is generated, then :meth:`!__post_init__` will not "
"automatically be called."
msgstr ""
"Если он определен в классе, он будет вызываться сгенерированным :meth:"
"`~object.__init__`, обычно как :meth:`!self.__post_init__`. Однако, если "
"определены какие-либо поля ``InitVar``, они также будут переданы в :meth:`!"
"__post_init__` в том порядке, в котором они были определены в классе. Если "
"метод :meth:`!__init__` не создан, то :meth:`!__post_init__` не будет "
"вызываться автоматически."

#: ../../library/dataclasses.rst:539
msgid ""
"Among other uses, this allows for initializing field values that depend on "
"one or more other fields.  For example::"
msgstr ""
"Помимо прочего, это позволяет инициализировать значения полей, которые "
"зависят от одного или нескольких других полей. Например::"

#: ../../library/dataclasses.rst:542
msgid ""
"@dataclass\n"
"class C:\n"
"    a: float\n"
"    b: float\n"
"    c: float = field(init=False)\n"
"\n"
"    def __post_init__(self):\n"
"        self.c = self.a + self.b"
msgstr ""
"@dataclass\n"
"class C:\n"
"    a: float\n"
"    b: float\n"
"    c: float = field(init=False)\n"
"\n"
"    def __post_init__(self):\n"
"        self.c = self.a + self.b"

#: ../../library/dataclasses.rst:551
msgid ""
"The :meth:`~object.__init__` method generated by :func:`@dataclass "
"<dataclass>` does not call base class :meth:`!__init__` methods. If the base "
"class has an :meth:`!__init__` method that has to be called, it is common to "
"call this method in a :meth:`__post_init__` method::"
msgstr ""
"Метод :meth:`~object.__init__`, сгенерированный :func:`@dataclass "
"<dataclass>`, не вызывает методы базового класса :meth:`!__init__`. Если "
"базовый класс имеет метод :meth:`!__init__`, который необходимо вызвать, "
"обычно этот метод вызывается в методе :meth:`__post_init__`::"

#: ../../library/dataclasses.rst:556
msgid ""
"class Rectangle:\n"
"    def __init__(self, height, width):\n"
"      self.height = height\n"
"      self.width = width\n"
"\n"
"@dataclass\n"
"class Square(Rectangle):\n"
"    side: float\n"
"\n"
"    def __post_init__(self):\n"
"        super().__init__(self.side, self.side)"
msgstr ""
"class Rectangle:\n"
"    def __init__(self, height, width):\n"
"      self.height = height\n"
"      self.width = width\n"
"\n"
"@dataclass\n"
"class Square(Rectangle):\n"
"    side: float\n"
"\n"
"    def __post_init__(self):\n"
"        super().__init__(self.side, self.side)"

#: ../../library/dataclasses.rst:568
msgid ""
"Note, however, that in general the dataclass-generated :meth:`!__init__` "
"methods don't need to be called, since the derived dataclass will take care "
"of initializing all fields of any base class that is a dataclass itself."
msgstr ""
"Однако обратите внимание, что в целом методы :meth:`!__init__`, "
"сгенерированные классом данных, вызывать не нужно, поскольку производный "
"класс данных позаботится об инициализации всех полей любого базового класса, "
"который сам является классом данных."

#: ../../library/dataclasses.rst:572
msgid ""
"See the section below on init-only variables for ways to pass parameters to :"
"meth:`!__post_init__`.  Also see the warning about how :func:`replace` "
"handles ``init=False`` fields."
msgstr ""
"См. раздел ниже, посвященный переменным, предназначенным только для "
"инициализации, чтобы узнать о способах передачи параметров в :meth:`!"
"__post_init__`. Также см. предупреждение о том, как :func:`replace` "
"обрабатывает поля ``init=False``."

#: ../../library/dataclasses.rst:579
msgid "Class variables"
msgstr "Переменные класса"

#: ../../library/dataclasses.rst:581
msgid ""
"One of the few places where :func:`@dataclass <dataclass>` actually inspects "
"the type of a field is to determine if a field is a class variable as "
"defined in :pep:`526`.  It does this by checking if the type of the field "
"is :data:`typing.ClassVar`.  If a field is a ``ClassVar``, it is excluded "
"from consideration as a field and is ignored by the dataclass mechanisms.  "
"Such ``ClassVar`` pseudo-fields are not returned by the module-level :func:"
"`fields` function."
msgstr ""
"Одно из немногих мест, где :func:`@dataclass <dataclass>` действительно "
"проверяет тип поля, — это определить, является ли поле переменной класса, "
"как определено в :pep:`526`. Это делается путем проверки того, является ли "
"тип поля :data:`typing.ClassVar`. Если поле является ClassVar, оно "
"исключается из рассмотрения как поле и игнорируется механизмами классов "
"данных. Такие псевдополя ``ClassVar`` не возвращаются функцией :func:"
"`fields` уровня модуля."

#: ../../library/dataclasses.rst:592
msgid "Init-only variables"
msgstr "Переменные, доступные только для инициализации"

#: ../../library/dataclasses.rst:594
msgid ""
"Another place where :func:`@dataclass <dataclass>` inspects a type "
"annotation is to determine if a field is an init-only variable.  It does "
"this by seeing if the type of a field is of type ``dataclasses.InitVar``.  "
"If a field is an ``InitVar``, it is considered a pseudo-field called an init-"
"only field.  As it is not a true field, it is not returned by the module-"
"level :func:`fields` function.  Init-only fields are added as parameters to "
"the generated :meth:`~object.__init__` method, and are passed to the "
"optional :meth:`__post_init__` method.  They are not otherwise used by "
"dataclasses."
msgstr ""
"Еще одно место, где :func:`@dataclass <dataclass>` проверяет аннотацию типа, "
"— это определить, является ли поле переменной, предназначенной только для "
"инициализации. Он делает это, проверяя, имеет ли тип поля тип dataclasses."
"InitVar. Если поле является InitVar, оно считается псевдополем, называемым "
"полем только для инициализации. Поскольку это не настоящее поле, оно не "
"возвращается функцией :func:`fields` уровня модуля. Поля, предназначенные "
"только для инициализации, добавляются в качестве параметров в "
"сгенерированный метод :meth:`~object.__init__` и передаются в необязательный "
"метод :meth:`__post_init__`. В противном случае они не используются классами "
"данных."

#: ../../library/dataclasses.rst:604
msgid ""
"For example, suppose a field will be initialized from a database, if a value "
"is not provided when creating the class::"
msgstr ""
"Например, предположим, что поле будет инициализировано из базы данных, если "
"при создании класса не указано значение:"

#: ../../library/dataclasses.rst:607
msgid ""
"@dataclass\n"
"class C:\n"
"    i: int\n"
"    j: int | None = None\n"
"    database: InitVar[DatabaseType | None] = None\n"
"\n"
"    def __post_init__(self, database):\n"
"        if self.j is None and database is not None:\n"
"            self.j = database.lookup('j')\n"
"\n"
"c = C(10, database=my_database)"
msgstr ""
"@dataclass\n"
"class C:\n"
"    i: int\n"
"    j: int | None = None\n"
"    database: InitVar[DatabaseType | None] = None\n"
"\n"
"    def __post_init__(self, database):\n"
"        if self.j is None and database is not None:\n"
"            self.j = database.lookup('j')\n"
"\n"
"c = C(10, database=my_database)"

#: ../../library/dataclasses.rst:619
msgid ""
"In this case, :func:`fields` will return :class:`Field` objects for :attr:`!"
"i` and :attr:`!j`, but not for :attr:`!database`."
msgstr ""
"В этом случае :func:`fields` вернет объекты :class:`Field` для :attr:`!i` и :"
"attr:`!j`, но не для :attr:`!database`."

#: ../../library/dataclasses.rst:625
msgid "Frozen instances"
msgstr "Замороженные экземпляры"

#: ../../library/dataclasses.rst:627
msgid ""
"It is not possible to create truly immutable Python objects.  However, by "
"passing ``frozen=True`` to the :func:`@dataclass <dataclass>` decorator you "
"can emulate immutability.  In that case, dataclasses will add :meth:`~object."
"__setattr__` and :meth:`~object.__delattr__` methods to the class.  These "
"methods will raise a :exc:`FrozenInstanceError` when invoked."
msgstr ""
"Невозможно создать действительно неизменяемые объекты Python. Однако, "
"передав ``frozen=True`` декоратору :func:`@dataclass <dataclass>`, вы можете "
"эмулировать неизменность. В этом случае классы данных добавят в класс "
"методы :meth:`~object.__setattr__` и :meth:`~object.__delattr__`. Эти методы "
"вызовут ошибку :exc:`FrozenInstanceError` при вызове."

#: ../../library/dataclasses.rst:633
msgid ""
"There is a tiny performance penalty when using ``frozen=True``: :meth:"
"`~object.__init__` cannot use simple assignment to initialize fields, and "
"must use :meth:`!object.__setattr__`."
msgstr ""
"При использовании ``frozen=True`` существует небольшое снижение "
"производительности: :meth:`~object.__init__` не может использовать простое "
"присваивание для инициализации полей и должен использовать :meth:`!object."
"__setattr__`."

#: ../../library/dataclasses.rst:642
msgid "Inheritance"
msgstr "Наследование"

#: ../../library/dataclasses.rst:644
msgid ""
"When the dataclass is being created by the :func:`@dataclass <dataclass>` "
"decorator, it looks through all of the class's base classes in reverse MRO "
"(that is, starting at :class:`object`) and, for each dataclass that it "
"finds, adds the fields from that base class to an ordered mapping of fields. "
"After all of the base class fields are added, it adds its own fields to the "
"ordered mapping.  All of the generated methods will use this combined, "
"calculated ordered mapping of fields.  Because the fields are in insertion "
"order, derived classes override base classes.  An example::"
msgstr ""
"Когда класс данных создается декоратором :func:`@dataclass <dataclass>`, он "
"просматривает все базовые классы класса в обратном MRO (то есть начиная с :"
"class:`object`) и для каждого класса данных что он находит, добавляет поля "
"из этого базового класса в упорядоченное отображение полей. После добавления "
"всех полей базового класса он добавляет свои собственные поля к "
"упорядоченному сопоставлению. Все сгенерированные методы будут использовать "
"это комбинированное, рассчитанное упорядоченное сопоставление полей. "
"Поскольку поля расположены в порядке вставки, производные классы "
"переопределяют базовые классы. Пример::"

#: ../../library/dataclasses.rst:654
msgid ""
"@dataclass\n"
"class Base:\n"
"    x: Any = 15.0\n"
"    y: int = 0\n"
"\n"
"@dataclass\n"
"class C(Base):\n"
"    z: int = 10\n"
"    x: int = 15"
msgstr ""
"@dataclass\n"
"class Base:\n"
"    x: Any = 15.0\n"
"    y: int = 0\n"
"\n"
"@dataclass\n"
"class C(Base):\n"
"    z: int = 10\n"
"    x: int = 15"

#: ../../library/dataclasses.rst:664
msgid ""
"The final list of fields is, in order, :attr:`!x`, :attr:`!y`, :attr:`!z`.  "
"The final type of :attr:`!x` is :class:`int`, as specified in class :class:`!"
"C`."
msgstr ""
"Окончательный список полей по порядку: :attr:`!x`, :attr:`!y`, :attr:`!z`. "
"Последний тип :attr:`!x` — это :class:`int`, как указано в классе :class:`!"
"C`."

#: ../../library/dataclasses.rst:667
msgid ""
"The generated :meth:`~object.__init__` method for :class:`!C` will look "
"like::"
msgstr ""
"Сгенерированный метод :meth:`~object.__init__` для :class:`!C` будет "
"выглядеть так::"

#: ../../library/dataclasses.rst:669
msgid "def __init__(self, x: int = 15, y: int = 0, z: int = 10):"
msgstr "def __init__(self, x: int = 15, y: int = 0, z: int = 10):"

#: ../../library/dataclasses.rst:672
msgid "Re-ordering of keyword-only parameters in :meth:`!__init__`"
msgstr ""
"Изменение порядка параметров, содержащих только ключевые слова, в :meth:`!"
"__init__`"

#: ../../library/dataclasses.rst:674
msgid ""
"After the parameters needed for :meth:`~object.__init__` are computed, any "
"keyword-only parameters are moved to come after all regular (non-keyword-"
"only) parameters.  This is a requirement of how keyword-only parameters are "
"implemented in Python: they must come after non-keyword-only parameters."
msgstr ""
"После вычисления параметров, необходимых для :meth:`~object.__init__`, любые "
"параметры, содержащие только ключевые слова, перемещаются после всех обычных "
"параметров (не только ключевых слов). Это требование реализации параметров, "
"содержащих только ключевые слова, в Python: они должны идти после "
"параметров, не содержащих только ключевые слова."

#: ../../library/dataclasses.rst:680
msgid ""
"In this example, :attr:`!Base.y`, :attr:`!Base.w`, and :attr:`!D.t` are "
"keyword-only fields, and :attr:`!Base.x` and :attr:`!D.z` are regular "
"fields::"
msgstr ""
"В этом примере :attr:`!Base.y`, :attr:`!Base.w` и :attr:`!Dt` являются "
"полями только для ключевых слов, а :attr:`!Base.x` и : attr:`!Dz` — обычные "
"поля::"

#: ../../library/dataclasses.rst:683
msgid ""
"@dataclass\n"
"class Base:\n"
"    x: Any = 15.0\n"
"    _: KW_ONLY\n"
"    y: int = 0\n"
"    w: int = 1\n"
"\n"
"@dataclass\n"
"class D(Base):\n"
"    z: int = 10\n"
"    t: int = field(kw_only=True, default=0)"
msgstr ""
"@dataclass\n"
"class Base:\n"
"    x: Any = 15.0\n"
"    _: KW_ONLY\n"
"    y: int = 0\n"
"    w: int = 1\n"
"\n"
"@dataclass\n"
"class D(Base):\n"
"    z: int = 10\n"
"    t: int = field(kw_only=True, default=0)"

#: ../../library/dataclasses.rst:695
msgid "The generated :meth:`!__init__` method for :class:`!D` will look like::"
msgstr ""
"Сгенерированный метод :meth:`!__init__` для :class:`!D` будет выглядеть так::"

#: ../../library/dataclasses.rst:697
msgid ""
"def __init__(self, x: Any = 15.0, z: int = 10, *, y: int = 0, w: int = 1, t: "
"int = 0):"
msgstr ""
"def __init__(self, x: Any = 15.0, z: int = 10, *, y: int = 0, w: int = 1, t: "
"int = 0):"

#: ../../library/dataclasses.rst:699
msgid ""
"Note that the parameters have been re-ordered from how they appear in the "
"list of fields: parameters derived from regular fields are followed by "
"parameters derived from keyword-only fields."
msgstr ""
"Обратите внимание, что порядок параметров изменен по сравнению с тем, как "
"они появляются в списке полей: за параметрами, полученными из обычных полей, "
"следуют параметры, полученные из полей, содержащих только ключевые слова."

#: ../../library/dataclasses.rst:703
msgid ""
"The relative ordering of keyword-only parameters is maintained in the re-"
"ordered :meth:`!__init__` parameter list."
msgstr ""
"Относительный порядок параметров, содержащих только ключевые слова, "
"сохраняется в переупорядоченном списке параметров :meth:`!__init__`."

#: ../../library/dataclasses.rst:708
msgid "Default factory functions"
msgstr "Заводские функции по умолчанию"

#: ../../library/dataclasses.rst:710
msgid ""
"If a :func:`field` specifies a *default_factory*, it is called with zero "
"arguments when a default value for the field is needed.  For example, to "
"create a new instance of a list, use::"
msgstr ""
"Если в :func:`field` указана *default_factory*, она вызывается с нулевыми "
"аргументами, когда для поля требуется значение по умолчанию. Например, чтобы "
"создать новый экземпляр списка, используйте::"

#: ../../library/dataclasses.rst:714
msgid "mylist: list = field(default_factory=list)"
msgstr "mylist: list = field(default_factory=list)"

#: ../../library/dataclasses.rst:716
msgid ""
"If a field is excluded from :meth:`~object.__init__` (using ``init=False``) "
"and the field also specifies *default_factory*, then the default factory "
"function will always be called from the generated :meth:`!__init__` "
"function.  This happens because there is no other way to give the field an "
"initial value."
msgstr ""
"Если поле исключено из :meth:`~object.__init__` (с использованием "
"``init=False``) и в поле также указана *default_factory*, то фабричная "
"функция по умолчанию всегда будет вызываться из сгенерированного :meth:` !"
"__init__` функция. Это происходит потому, что нет другого способа присвоить "
"полю начальное значение."

#: ../../library/dataclasses.rst:723
msgid "Mutable default values"
msgstr "Изменяемые значения по умолчанию"

#: ../../library/dataclasses.rst:725
msgid ""
"Python stores default member variable values in class attributes. Consider "
"this example, not using dataclasses::"
msgstr ""
"Python хранит значения переменных-членов по умолчанию в атрибутах класса. "
"Рассмотрим этот пример, не используя классы данных::"

#: ../../library/dataclasses.rst:728
msgid ""
"class C:\n"
"    x = []\n"
"    def add(self, element):\n"
"        self.x.append(element)\n"
"\n"
"o1 = C()\n"
"o2 = C()\n"
"o1.add(1)\n"
"o2.add(2)\n"
"assert o1.x == [1, 2]\n"
"assert o1.x is o2.x"
msgstr ""
"class C:\n"
"    x = []\n"
"    def add(self, element):\n"
"        self.x.append(element)\n"
"\n"
"o1 = C()\n"
"o2 = C()\n"
"o1.add(1)\n"
"o2.add(2)\n"
"assert o1.x == [1, 2]\n"
"assert o1.x is o2.x"

#: ../../library/dataclasses.rst:740
msgid ""
"Note that the two instances of class :class:`!C` share the same class "
"variable :attr:`!x`, as expected."
msgstr ""
"Обратите внимание, что два экземпляра класса :class:`!C` используют одну и "
"ту же переменную класса :attr:`!x`, как и ожидалось."

#: ../../library/dataclasses.rst:743
msgid "Using dataclasses, *if* this code was valid::"
msgstr "Используя классы данных, *если* этот код действителен::"

#: ../../library/dataclasses.rst:745
msgid ""
"@dataclass\n"
"class D:\n"
"    x: list = []      # This code raises ValueError\n"
"    def add(self, element):\n"
"        self.x.append(element)"
msgstr ""
"@dataclass\n"
"class D:\n"
"    x: list = []      # This code raises ValueError\n"
"    def add(self, element):\n"
"        self.x.append(element)"

#: ../../library/dataclasses.rst:751
msgid "it would generate code similar to::"
msgstr "он будет генерировать код, похожий на::"

#: ../../library/dataclasses.rst:753
msgid ""
"class D:\n"
"    x = []\n"
"    def __init__(self, x=x):\n"
"        self.x = x\n"
"    def add(self, element):\n"
"        self.x.append(element)\n"
"\n"
"assert D().x is D().x"
msgstr ""
"class D:\n"
"    x = []\n"
"    def __init__(self, x=x):\n"
"        self.x = x\n"
"    def add(self, element):\n"
"        self.x.append(element)\n"
"\n"
"assert D().x is D().x"

#: ../../library/dataclasses.rst:762
msgid ""
"This has the same issue as the original example using class :class:`!C`. "
"That is, two instances of class :class:`!D` that do not specify a value for :"
"attr:`!x` when creating a class instance will share the same copy of :attr:`!"
"x`.  Because dataclasses just use normal Python class creation they also "
"share this behavior.  There is no general way for Data Classes to detect "
"this condition.  Instead, the :func:`@dataclass <dataclass>` decorator will "
"raise a :exc:`ValueError` if it detects an unhashable default parameter.  "
"The assumption is that if a value is unhashable, it is mutable.  This is a "
"partial solution, but it does protect against many common errors."
msgstr ""
"Здесь та же проблема, что и в исходном примере с использованием класса :"
"class:`!C`. То есть два экземпляра класса :class:`!D`, в которых не указано "
"значение :attr:`!x` при создании экземпляра класса, будут совместно "
"использовать одну и ту же копию :attr:`!x`. Поскольку классы данных просто "
"используют обычное создание классов Python, они также имеют такое же "
"поведение. Для классов данных не существует общего способа обнаружить это "
"состояние. Вместо этого декоратор :func:`@dataclass <dataclass>` вызовет "
"ошибку :exc:`ValueError`, если обнаружит нехэшируемый параметр по умолчанию. "
"Предполагается, что если значение не хешируется, оно изменяемо. Это "
"частичное решение, но оно защищает от многих распространенных ошибок."

#: ../../library/dataclasses.rst:773
msgid ""
"Using default factory functions is a way to create new instances of mutable "
"types as default values for fields::"
msgstr ""
"Использование фабричных функций по умолчанию — это способ создания новых "
"экземпляров изменяемых типов в качестве значений по умолчанию для полей::"

#: ../../library/dataclasses.rst:776
msgid ""
"@dataclass\n"
"class D:\n"
"    x: list = field(default_factory=list)\n"
"\n"
"assert D().x is not D().x"
msgstr ""
"@dataclass\n"
"class D:\n"
"    x: list = field(default_factory=list)\n"
"\n"
"assert D().x is not D().x"

#: ../../library/dataclasses.rst:782
msgid ""
"Instead of looking for and disallowing objects of type :class:`list`, :class:"
"`dict`, or :class:`set`, unhashable objects are now not allowed as default "
"values.  Unhashability is used to approximate mutability."
msgstr ""
"Вместо поиска и запрета объектов типа :class:`list`, :class:`dict` или :"
"class:`set`, нехэшируемые объекты теперь не допускаются в качестве значений "
"по умолчанию. Нехешируемость используется для аппроксимации изменчивости."

#: ../../library/dataclasses.rst:789
msgid "Descriptor-typed fields"
msgstr "Поля с типом дескриптора"

#: ../../library/dataclasses.rst:791
msgid ""
"Fields that are assigned :ref:`descriptor objects <descriptors>` as their "
"default value have the following special behaviors:"
msgstr ""
"Поля, которым назначены :ref:`объекты дескриптора <дескрипторы>` в качестве "
"значения по умолчанию, имеют следующее особое поведение:"

#: ../../library/dataclasses.rst:794
msgid ""
"The value for the field passed to the dataclass's :meth:`~object.__init__` "
"method is passed to the descriptor's :meth:`~object.__set__` method rather "
"than overwriting the descriptor object."
msgstr ""
"Значение поля, передаваемого в метод :meth:`~object.__init__` класса данных, "
"передается в метод :meth:`~object.__set__` дескриптора, а не перезаписывает "
"объект дескриптора."

#: ../../library/dataclasses.rst:798
msgid ""
"Similarly, when getting or setting the field, the descriptor's :meth:"
"`~object.__get__` or :meth:`!__set__` method is called rather than returning "
"or overwriting the descriptor object."
msgstr ""
"Аналогично, при получении или установке поля вызывается метод дескриптора :"
"meth:`~object.__get__` или :meth:`!__set__`, а не возвращает или "
"перезаписывает объект дескриптора."

#: ../../library/dataclasses.rst:802
msgid ""
"To determine whether a field contains a default value, :func:`@dataclass "
"<dataclass>` will call the descriptor's :meth:`!__get__` method using its "
"class access form: ``descriptor.__get__(obj=None, type=cls)``.  If the "
"descriptor returns a value in this case, it will be used as the field's "
"default. On the other hand, if the descriptor raises :exc:`AttributeError` "
"in this situation, no default value will be provided for the field."
msgstr ""
"Чтобы определить, содержит ли поле значение по умолчанию, :func:`@dataclass "
"<dataclass>` вызовет метод дескриптора :meth:`!__get__`, используя форму "
"доступа к его классу: ``descriptor.__get__(obj=None, type= cls)``. Если в "
"этом случае дескриптор возвращает значение, оно будет использоваться в "
"качестве значения поля по умолчанию. С другой стороны, если в этой ситуации "
"дескриптор вызывает :exc:`AttributeError`, для поля не будет предоставлено "
"значение по умолчанию."

#: ../../library/dataclasses.rst:812
msgid ""
"class IntConversionDescriptor:\n"
"    def __init__(self, *, default):\n"
"        self._default = default\n"
"\n"
"    def __set_name__(self, owner, name):\n"
"        self._name = \"_\" + name\n"
"\n"
"    def __get__(self, obj, type):\n"
"        if obj is None:\n"
"            return self._default\n"
"\n"
"        return getattr(obj, self._name, self._default)\n"
"\n"
"    def __set__(self, obj, value):\n"
"        setattr(obj, self._name, int(value))\n"
"\n"
"@dataclass\n"
"class InventoryItem:\n"
"    quantity_on_hand: IntConversionDescriptor = "
"IntConversionDescriptor(default=100)\n"
"\n"
"i = InventoryItem()\n"
"print(i.quantity_on_hand)   # 100\n"
"i.quantity_on_hand = 2.5    # calls __set__ with 2.5\n"
"print(i.quantity_on_hand)   # 2"
msgstr ""
"class IntConversionDescriptor:\n"
"    def __init__(self, *, default):\n"
"        self._default = default\n"
"\n"
"    def __set_name__(self, owner, name):\n"
"        self._name = \"_\" + name\n"
"\n"
"    def __get__(self, obj, type):\n"
"        if obj is None:\n"
"            return self._default\n"
"\n"
"        return getattr(obj, self._name, self._default)\n"
"\n"
"    def __set__(self, obj, value):\n"
"        setattr(obj, self._name, int(value))\n"
"\n"
"@dataclass\n"
"class InventoryItem:\n"
"    quantity_on_hand: IntConversionDescriptor = "
"IntConversionDescriptor(default=100)\n"
"\n"
"i = InventoryItem()\n"
"print(i.quantity_on_hand)   # 100\n"
"i.quantity_on_hand = 2.5    # calls __set__ with 2.5\n"
"print(i.quantity_on_hand)   # 2"

#: ../../library/dataclasses.rst:837
msgid ""
"Note that if a field is annotated with a descriptor type, but is not "
"assigned a descriptor object as its default value, the field will act like a "
"normal field."
msgstr ""
"Обратите внимание: если поле аннотировано типом дескриптора, но ему не "
"назначен объект дескриптора в качестве значения по умолчанию, поле будет "
"действовать как обычное поле."
