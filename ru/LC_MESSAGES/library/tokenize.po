# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-10 16:06+0000\n"
"PO-Revision-Date: 2022-11-05 17:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/tokenize.rst:2
msgid ":mod:`tokenize` --- Tokenizer for Python source"
msgstr ""

#: ../../library/tokenize.rst:10
msgid "**Source code:** :source:`Lib/tokenize.py`"
msgstr "**Исходный код:** :source:`Lib/tokenize.py`"

#: ../../library/tokenize.rst:14
msgid ""
"The :mod:`tokenize` module provides a lexical scanner for Python source "
"code, implemented in Python.  The scanner in this module returns comments as "
"tokens as well, making it useful for implementing \"pretty-printers\", "
"including colorizers for on-screen displays."
msgstr ""
"Модуль :mod:`tokenize` предоставляет лексический сканер исходного кода "
"Python, реализованный на Python. Сканер в этом модуле также возвращает "
"комментарии в виде токенов, что делает его полезным для реализации «красивых "
"принтеров», включая раскраски для экранных дисплеев."

#: ../../library/tokenize.rst:19
msgid ""
"To simplify token stream handling, all :ref:`operator <operators>` and :ref:"
"`delimiter <delimiters>` tokens and :data:`Ellipsis` are returned using the "
"generic :data:`~token.OP` token type.  The exact type can be determined by "
"checking the ``exact_type`` property on the :term:`named tuple` returned "
"from :func:`tokenize.tokenize`."
msgstr ""
"Чтобы упростить обработку потока токенов, все токены :ref:`operator "
"<operators>` и :ref:`delimiter <delimiters>` и :data:`Ellipsis` возвращаются "
"с использованием общего типа токена :data:`~token.OP`. . Точный тип можно "
"определить, проверив свойство exact_type в :term:`named tuple`, возвращаемом "
"из :func:`tokenize.tokenize`."

#: ../../library/tokenize.rst:28
msgid ""
"Note that the functions in this module are only designed to parse "
"syntactically valid Python code (code that does not raise when parsed using :"
"func:`ast.parse`).  The behavior of the functions in this module is "
"**undefined** when providing invalid Python code and it can change at any "
"point."
msgstr ""
"Обратите внимание, что функции в этом модуле предназначены только для "
"анализа синтаксически допустимого кода Python (кода, который не вызывается "
"при анализе с использованием :func:`ast.parse`). Поведение функций в этом "
"модуле **не определено** при предоставлении недопустимого кода Python и "
"может измениться в любой момент."

#: ../../library/tokenize.rst:35
msgid "Tokenizing Input"
msgstr "Токенизация ввода"

#: ../../library/tokenize.rst:37
msgid "The primary entry point is a :term:`generator`:"
msgstr "Первичной точкой входа является :term:`генератор`:"

#: ../../library/tokenize.rst:41
msgid ""
"The :func:`.tokenize` generator requires one argument, *readline*, which "
"must be a callable object which provides the same interface as the :meth:`io."
"IOBase.readline` method of file objects.  Each call to the function should "
"return one line of input as bytes."
msgstr ""
"Генератору :func:`.tokenize` требуется один аргумент, *readline*, который "
"должен быть вызываемым объектом, предоставляющим тот же интерфейс, что и "
"метод :meth:`io.IOBase.readline` для файловых объектов. Каждый вызов функции "
"должен возвращать одну строку ввода в виде байтов."

#: ../../library/tokenize.rst:46
msgid ""
"The generator produces 5-tuples with these members: the token type; the "
"token string; a 2-tuple ``(srow, scol)`` of ints specifying the row and "
"column where the token begins in the source; a 2-tuple ``(erow, ecol)`` of "
"ints specifying the row and column where the token ends in the source; and "
"the line on which the token was found. The line passed (the last tuple item) "
"is the *physical* line.  The 5 tuple is returned as a :term:`named tuple` "
"with the field names: ``type string start end line``."
msgstr ""
"Генератор создает 5 кортежей со следующими элементами: тип токена; строка "
"токена; кортеж из двух целых чисел (srow, scol), определяющий строку и "
"столбец, где начинается токен в источнике; 2-кортеж ``(erow, ecol)`` целых "
"чисел, определяющий строку и столбец, где токен заканчивается в источнике; и "
"строка, на которой был найден токен. Пройденная строка (последний элемент "
"кортежа) является *физической* строкой. Кортеж 5 возвращается как "
"именованный кортеж с именами полей: ``type string start end line``."

#: ../../library/tokenize.rst:55
msgid ""
"The returned :term:`named tuple` has an additional property named "
"``exact_type`` that contains the exact operator type for :data:`~token.OP` "
"tokens.  For all other token types ``exact_type`` equals the named tuple "
"``type`` field."
msgstr ""
"Возвращенный :term:`named tuple` имеет дополнительное свойство с именем "
"``exact_type``, которое содержит точный тип оператора для токенов :data:"
"`~token.OP`. Для всех других типов токенов ``exact_type`` соответствует "
"именованному полю кортежа ``type``."

#: ../../library/tokenize.rst:60
msgid "Added support for named tuples."
msgstr "Добавлена ​​поддержка именованных кортежей."

#: ../../library/tokenize.rst:63
msgid "Added support for ``exact_type``."
msgstr "Добавлена ​​поддержка ``exact_type``."

#: ../../library/tokenize.rst:66
msgid ""
":func:`.tokenize` determines the source encoding of the file by looking for "
"a UTF-8 BOM or encoding cookie, according to :pep:`263`."
msgstr ""
":func:`.tokenize` определяет исходную кодировку файла путем поиска "
"спецификации UTF-8 или файла cookie кодирования в соответствии с :pep:`263`."

#: ../../library/tokenize.rst:71
msgid "Tokenize a source reading unicode strings instead of bytes."
msgstr "Токенизировать источник, читающий строки Юникода вместо байтов."

#: ../../library/tokenize.rst:73
msgid ""
"Like :func:`.tokenize`, the *readline* argument is a callable returning a "
"single line of input. However, :func:`generate_tokens` expects *readline* to "
"return a str object rather than bytes."
msgstr ""
"Как и :func:`.tokenize`, аргумент *readline* является вызываемым объектом, "
"возвращающим одну строку входных данных. Однако :func:`generate_tokens` "
"ожидает, что *readline* вернет объект str, а не байты."

#: ../../library/tokenize.rst:77
msgid ""
"The result is an iterator yielding named tuples, exactly like :func:`."
"tokenize`. It does not yield an :data:`~token.ENCODING` token."
msgstr ""
"Результатом является итератор, возвращающий именованные кортежи, точно так "
"же, как :func:`.tokenize`. Он не дает токена :data:`~token.ENCODING`."

#: ../../library/tokenize.rst:80
msgid ""
"All constants from the :mod:`token` module are also exported from :mod:"
"`tokenize`."
msgstr ""
"Все константы из модуля :mod:`token` также экспортируются из :mod:`tokenize`."

#: ../../library/tokenize.rst:83
msgid ""
"Another function is provided to reverse the tokenization process. This is "
"useful for creating tools that tokenize a script, modify the token stream, "
"and write back the modified script."
msgstr ""
"Предусмотрена еще одна функция для обратного процесса токенизации. Это "
"полезно для создания инструментов, которые маркируют сценарий, изменяют "
"поток токенов и записывают измененный сценарий обратно."

#: ../../library/tokenize.rst:90
msgid ""
"Converts tokens back into Python source code.  The *iterable* must return "
"sequences with at least two elements, the token type and the token string. "
"Any additional sequence elements are ignored."
msgstr ""
"Преобразует токены обратно в исходный код Python. *iterable* должен "
"возвращать последовательности, содержащие как минимум два элемента: тип "
"токена и строку токена. Любые дополнительные элементы последовательности "
"игнорируются."

#: ../../library/tokenize.rst:94
msgid ""
"The reconstructed script is returned as a single string.  The result is "
"guaranteed to tokenize back to match the input so that the conversion is "
"lossless and round-trips are assured.  The guarantee applies only to the "
"token type and token string as the spacing between tokens (column positions) "
"may change."
msgstr ""
"Восстановленный сценарий возвращается в виде одной строки. Результат "
"гарантированно токенизируется обратно в соответствии с входными данными, так "
"что преобразование происходит без потерь и гарантируется двусторонний обмен "
"данными. Гарантия распространяется только на тип токена и строку токена, "
"поскольку расстояние между токенами (позиции столбцов) может измениться."

#: ../../library/tokenize.rst:100
msgid ""
"It returns bytes, encoded using the :data:`~token.ENCODING` token, which is "
"the first token sequence output by :func:`.tokenize`. If there is no "
"encoding token in the input, it returns a str instead."
msgstr ""
"Он возвращает байты, закодированные с использованием токена :data:`~token."
"ENCODING`, который является первой последовательностью токенов, выводимой :"
"func:`.tokenize`. Если во входных данных нет токена кодирования, вместо "
"этого возвращается строка."

#: ../../library/tokenize.rst:105
msgid ""
":func:`.tokenize` needs to detect the encoding of source files it tokenizes. "
"The function it uses to do this is available:"
msgstr ""
":func:`.tokenize` должен определять кодировку исходных файлов, которые он "
"токенизирует. Функция, которую он использует для этого, доступна:"

#: ../../library/tokenize.rst:110
msgid ""
"The :func:`detect_encoding` function is used to detect the encoding that "
"should be used to decode a Python source file. It requires one argument, "
"readline, in the same way as the :func:`.tokenize` generator."
msgstr ""
"Функция :func:`detect_encoding` используется для определения кодировки, "
"которая должна использоваться для декодирования исходного файла Python. Ему "
"требуется один аргумент, readline, так же, как и генератору :func:`."
"tokenize`."

#: ../../library/tokenize.rst:114
msgid ""
"It will call readline a maximum of twice, and return the encoding used (as a "
"string) and a list of any lines (not decoded from bytes) it has read in."
msgstr ""
"Он вызовет readline максимум два раза и вернет использованную кодировку (в "
"виде строки) и список всех строк (не декодированных из байтов), которые он "
"прочитал."

#: ../../library/tokenize.rst:118
msgid ""
"It detects the encoding from the presence of a UTF-8 BOM or an encoding "
"cookie as specified in :pep:`263`. If both a BOM and a cookie are present, "
"but disagree, a :exc:`SyntaxError` will be raised. Note that if the BOM is "
"found, ``'utf-8-sig'`` will be returned as an encoding."
msgstr ""
"Он определяет кодировку по наличию спецификации UTF-8 или файла cookie "
"кодирования, как указано в :pep:`263`. Если присутствуют и спецификация, и "
"файл cookie, но они не совпадают, будет выдано исключение :exc:"
"`SyntaxError`. Обратите внимание, что если спецификация найдена, в качестве "
"кодировки будет возвращена ``'utf-8-sig'`."

#: ../../library/tokenize.rst:123
msgid ""
"If no encoding is specified, then the default of ``'utf-8'`` will be "
"returned."
msgstr ""
"Если кодировка не указана, то будет возвращено значение по умолчанию «utf-8»."

#: ../../library/tokenize.rst:126
msgid ""
"Use :func:`.open` to open Python source files: it uses :func:"
"`detect_encoding` to detect the file encoding."
msgstr ""
"Используйте :func:`.open` для открытия исходных файлов Python: он "
"использует :func:`detect_encoding` для определения кодировки файла."

#: ../../library/tokenize.rst:132
msgid ""
"Open a file in read only mode using the encoding detected by :func:"
"`detect_encoding`."
msgstr ""
"Откройте файл в режиме только для чтения, используя кодировку, обнаруженную :"
"func:`detect_encoding`."

#: ../../library/tokenize.rst:139
msgid ""
"Raised when either a docstring or expression that may be split over several "
"lines is not completed anywhere in the file, for example::"
msgstr ""
"Возникает, когда строка документации или выражение, которое может быть "
"разбито на несколько строк, не завершено где-либо в файле, например::"

#: ../../library/tokenize.rst:145
msgid "or::"
msgstr "или::"

#: ../../library/tokenize.rst:151
msgid ""
"Note that unclosed single-quoted strings do not cause an error to be raised. "
"They are tokenized as :data:`~token.ERRORTOKEN`, followed by the "
"tokenization of their contents."
msgstr ""

#: ../../library/tokenize.rst:159
msgid "Command-Line Usage"
msgstr "Использование командной строки"

#: ../../library/tokenize.rst:163
msgid ""
"The :mod:`tokenize` module can be executed as a script from the command "
"line. It is as simple as:"
msgstr ""
"Модуль :mod:`tokenize` можно запустить как скрипт из командной строки. Это "
"так же просто, как:"

#: ../../library/tokenize.rst:170
msgid "The following options are accepted:"
msgstr "Принимаются следующие варианты:"

#: ../../library/tokenize.rst:176
msgid "show this help message and exit"
msgstr "показать это справочное сообщение и выйти"

#: ../../library/tokenize.rst:180
msgid "display token names using the exact type"
msgstr "отображать имена токенов, используя точный тип"

#: ../../library/tokenize.rst:182
msgid ""
"If :file:`filename.py` is specified its contents are tokenized to stdout. "
"Otherwise, tokenization is performed on stdin."
msgstr ""
"Если указан :file:`filename.py`, его содержимое токенизируется в стандартный "
"вывод. В противном случае токенизация выполняется на стандартном вводе."

#: ../../library/tokenize.rst:186
msgid "Examples"
msgstr "Примеры"

#: ../../library/tokenize.rst:188
msgid ""
"Example of a script rewriter that transforms float literals into Decimal "
"objects::"
msgstr ""
"Пример переписчика скриптов, который преобразует литералы с плавающей "
"запятой в объекты Decimal:"

#: ../../library/tokenize.rst:230
msgid "Example of tokenizing from the command line.  The script::"
msgstr "Пример токенизации из командной строки. Скрипт::"

#: ../../library/tokenize.rst:237
msgid ""
"will be tokenized to the following output where the first column is the "
"range of the line/column coordinates where the token is found, the second "
"column is the name of the token, and the final column is the value of the "
"token (if any)"
msgstr ""
"будет преобразован в следующий вывод, где первый столбец — это диапазон "
"координат строки/столбца, в котором найден токен, второй столбец — это имя "
"токена, а последний столбец — это значение токена (если есть)"

#: ../../library/tokenize.rst:265
msgid ""
"The exact token type names can be displayed using the :option:`-e` option:"
msgstr ""
"Точные имена типов токенов можно отобразить с помощью опции :option:`-e`:"

#: ../../library/tokenize.rst:291
msgid ""
"Example of tokenizing a file programmatically, reading unicode strings "
"instead of bytes with :func:`generate_tokens`::"
msgstr ""
"Пример программного токенизации файла, чтения строк Юникода вместо байтов с "
"помощью :func:`generate_tokens`::"

#: ../../library/tokenize.rst:301
msgid "Or reading bytes directly with :func:`.tokenize`::"
msgstr "Или чтение байтов напрямую с помощью :func:`.tokenize`::"
