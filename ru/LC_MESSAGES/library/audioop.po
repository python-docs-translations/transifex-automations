# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 15:28+0000\n"
"PO-Revision-Date: 2023-05-24 02:13+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/audioop.rst:2
msgid ":mod:`audioop` --- Manipulate raw audio data"
msgstr ":mod:`audioop` --- Манипулирование необработанными аудиоданными"

#: ../../library/audioop.rst:11
msgid ""
"The :mod:`audioop` module is deprecated (see :pep:`PEP 594 <594#audioop>` "
"for details)."
msgstr ""
"Модуль :mod:`audioop` устарел (подробности см. в :pep:`PEP 594 "
"<594#audioop>`)."

#: ../../library/audioop.rst:14
msgid ""
"The :mod:`audioop` module contains some useful operations on sound "
"fragments. It operates on sound fragments consisting of signed integer "
"samples 8, 16, 24 or 32 bits wide, stored in :term:`bytes-like objects "
"<bytes-like object>`.  All scalar items are integers, unless specified "
"otherwise."
msgstr ""
"Модуль :mod:`audioop` содержит несколько полезных операций над звуковыми "
"фрагментами. Он оперирует звуковыми фрагментами, состоящими из целочисленных "
"сэмплов со знаком шириной 8, 16, 24 или 32 бита, хранящихся в :term:`bytes-"
"like объектах <bytes-like object>`. Все скалярные элементы являются целыми "
"числами, если не указано иное."

#: ../../library/audioop.rst:19
msgid ""
"Support for 24-bit samples was added. All functions now accept any :term:"
"`bytes-like object`. String input now results in an immediate error."
msgstr ""
"Добавлена ​​поддержка 24-битных сэмплов. Все функции теперь принимают любой :"
"term:`байтовый объект`. Строковый ввод теперь приводит к немедленной ошибке."

#: ../../library/audioop.rst:30
msgid ""
"This module provides support for a-LAW, u-LAW and Intel/DVI ADPCM encodings."
msgstr ""
"Этот модуль обеспечивает поддержку кодировок a-LAW, u-LAW и Intel/DVI ADPCM."

#: ../../library/audioop.rst:34
msgid ""
"A few of the more complicated operations only take 16-bit samples, otherwise "
"the sample size (in bytes) is always a parameter of the operation."
msgstr ""
"Некоторые из более сложных операций берут только 16-битные выборки, в "
"противном случае размер выборки (в байтах) всегда является параметром "
"операции."

#: ../../library/audioop.rst:37
msgid "The module defines the following variables and functions:"
msgstr "Модуль определяет следующие переменные и функции:"

#: ../../library/audioop.rst:42
msgid ""
"This exception is raised on all errors, such as unknown number of bytes per "
"sample, etc."
msgstr ""
"Это исключение возникает при всех ошибках, таких как неизвестное количество "
"байтов в выборке и т. д."

#: ../../library/audioop.rst:48
msgid ""
"Return a fragment which is the addition of the two samples passed as "
"parameters. *width* is the sample width in bytes, either ``1``, ``2``, ``3`` "
"or ``4``.  Both fragments should have the same length.  Samples are "
"truncated in case of overflow."
msgstr ""
"Возвращает фрагмент, который представляет собой сложение двух выборок, "
"переданных в качестве параметров. *width* — это ширина выборки в байтах: "
"``1``, ``2``, ``3`` или ``4``. Оба фрагмента должны иметь одинаковую длину. "
"Выборки обрезаются в случае переполнения."

#: ../../library/audioop.rst:55
msgid ""
"Decode an Intel/DVI ADPCM coded fragment to a linear fragment.  See the "
"description of :func:`lin2adpcm` for details on ADPCM coding. Return a tuple "
"``(sample, newstate)`` where the sample has the width specified in *width*."
msgstr ""
"Декодируйте фрагмент кода Intel/DVI ADPCM в линейный фрагмент. Подробную "
"информацию о кодировании ADPCM смотрите в описании :func:`lin2adpcm`. "
"Возвращает кортеж ``(sample, newstate)``, где образец имеет ширину, "
"указанную в *width*."

#: ../../library/audioop.rst:62
msgid ""
"Convert sound fragments in a-LAW encoding to linearly encoded sound "
"fragments. a-LAW encoding always uses 8 bits samples, so *width* refers only "
"to the sample width of the output fragment here."
msgstr ""
"Преобразуйте звуковые фрагменты в кодировке a-LAW в линейно закодированные "
"звуковые фрагменты. Кодирование a-LAW всегда использует 8-битные выборки, "
"поэтому *ширина* здесь относится только к ширине выборки выходного фрагмента."

#: ../../library/audioop.rst:69
msgid "Return the average over all samples in the fragment."
msgstr "Возвращает среднее значение по всем выборкам во фрагменте."

#: ../../library/audioop.rst:74
msgid ""
"Return the average peak-peak value over all samples in the fragment. No "
"filtering is done, so the usefulness of this routine is questionable."
msgstr ""
"Возвращает среднее пиковое значение по всем выборкам во фрагменте. "
"Фильтрация не производится, поэтому полезность этой процедуры сомнительна."

#: ../../library/audioop.rst:80
msgid ""
"Return a fragment that is the original fragment with a bias added to each "
"sample.  Samples wrap around in case of overflow."
msgstr ""
"Верните фрагмент, который является исходным фрагментом с добавлением "
"смещения к каждому образцу. Образцы переворачиваются в случае переполнения."

#: ../../library/audioop.rst:86
msgid ""
"\"Byteswap\" all samples in a fragment and returns the modified fragment. "
"Converts big-endian samples to little-endian and vice versa."
msgstr ""
"«Поменять местами» все выборки во фрагменте и вернуть измененный фрагмент. "
"Преобразует образцы с прямым порядком байтов в образцы с прямым порядком "
"байтов и наоборот."

#: ../../library/audioop.rst:94
msgid ""
"Return the number of zero crossings in the fragment passed as an argument."
msgstr ""
"Возвращает количество пересечений нуля во фрагменте, переданном в качестве "
"аргумента."

#: ../../library/audioop.rst:99
msgid ""
"Return a factor *F* such that ``rms(add(fragment, mul(reference, -F)))`` is "
"minimal, i.e., return the factor with which you should multiply *reference* "
"to make it match as well as possible to *fragment*.  The fragments should "
"both contain 2-byte samples."
msgstr ""
"Верните коэффициент *F* такой, что ``rms(add(fragment, mul(reference, -"
"F)))`` является минимальным, т.е. верните коэффициент, на который вы должны "
"умножить *reference*, чтобы он совпадал, а также возможно *фрагментировать*. "
"Оба фрагмента должны содержать 2-байтовые выборки."

#: ../../library/audioop.rst:104
msgid "The time taken by this routine is proportional to ``len(fragment)``."
msgstr "Время, затрачиваемое этой процедурой, пропорционально len(fragment)."

#: ../../library/audioop.rst:109
msgid ""
"Try to match *reference* as well as possible to a portion of *fragment* "
"(which should be the longer fragment).  This is (conceptually) done by "
"taking slices out of *fragment*, using :func:`findfactor` to compute the "
"best match, and minimizing the result.  The fragments should both contain 2-"
"byte samples. Return a tuple ``(offset, factor)`` where *offset* is the "
"(integer) offset into *fragment* where the optimal match started and "
"*factor* is the (floating-point) factor as per :func:`findfactor`."
msgstr ""
"Постарайтесь сопоставить *ссылку* как можно точнее с частью *фрагмента* "
"(который должен быть более длинным фрагментом). Это (концептуально) делается "
"путем извлечения фрагментов из *фрагмента*, использования :func:`findfactor` "
"для вычисления наилучшего соответствия и минимизации результата. Оба "
"фрагмента должны содержать 2-байтовые выборки. Возвращает кортеж ``(offset, "
"Factor)``, где *offset* — это (целое) смещение в *fragment*, где началось "
"оптимальное совпадение, а *factor* — это коэффициент (с плавающей запятой) "
"согласно :func:`findfactor `."

#: ../../library/audioop.rst:120
msgid ""
"Search *fragment* for a slice of length *length* samples (not bytes!) with "
"maximum energy, i.e., return *i* for which ``rms(fragment[i*2:"
"(i+length)*2])`` is maximal.  The fragments should both contain 2-byte "
"samples."
msgstr ""
"Найдите *fragment* срез выборки длиной *length* (не байты!) с максимальной "
"энергией, т. е. верните *i*, для которого ``rms(fragment[i*2:(i+length)*2])` "
"` является максимальным. Оба фрагмента должны содержать 2-байтовые выборки."

#: ../../library/audioop.rst:124
msgid "The routine takes time proportional to ``len(fragment)``."
msgstr "Процедура занимает время, пропорциональное ``len(fragment)``."

#: ../../library/audioop.rst:129
msgid "Return the value of sample *index* from the fragment."
msgstr "Вернуть значение образца *index* из фрагмента."

#: ../../library/audioop.rst:134
msgid ""
"Convert samples to 4 bit Intel/DVI ADPCM encoding.  ADPCM coding is an "
"adaptive coding scheme, whereby each 4 bit number is the difference between "
"one sample and the next, divided by a (varying) step.  The Intel/DVI ADPCM "
"algorithm has been selected for use by the IMA, so it may well become a "
"standard."
msgstr ""
"Преобразуйте образцы в 4-битную кодировку Intel/DVI ADPCM. Кодирование ADPCM "
"представляет собой схему адаптивного кодирования, в которой каждое 4-битное "
"число представляет собой разницу между одной выборкой и следующей, "
"разделенную на (меняющийся) шаг. Алгоритм Intel/DVI ADPCM был выбран для "
"использования IMA, поэтому он вполне может стать стандартом."

#: ../../library/audioop.rst:139
msgid ""
"*state* is a tuple containing the state of the coder.  The coder returns a "
"tuple ``(adpcmfrag, newstate)``, and the *newstate* should be passed to the "
"next call of :func:`lin2adpcm`.  In the initial call, ``None`` can be passed "
"as the state. *adpcmfrag* is the ADPCM coded fragment packed 2 4-bit values "
"per byte."
msgstr ""
"*state* — это кортеж, содержащий состояние кодера. Кодер возвращает кортеж "
"``(adpcmfrag, newstate)``, и *newstate* должен быть передан при следующем "
"вызове :func:`lin2adpcm`. При первом вызове в качестве состояния может быть "
"передано None. *adpcmfrag* — это закодированный фрагмент ADPCM, упакованный "
"по 2 4-битных значения на байт."

#: ../../library/audioop.rst:147
msgid ""
"Convert samples in the audio fragment to a-LAW encoding and return this as a "
"bytes object.  a-LAW is an audio encoding format whereby you get a dynamic "
"range of about 13 bits using only 8 bit samples.  It is used by the Sun "
"audio hardware, among others."
msgstr ""
"Преобразуйте образцы аудиофрагмента в кодировку a-LAW и верните это как "
"байтовый объект. a-LAW — это формат кодирования звука, при котором вы "
"получаете динамический диапазон около 13 бит, используя только 8-битные "
"сэмплы. Он используется, среди прочего, аудиооборудованием Sun."

#: ../../library/audioop.rst:155
msgid "Convert samples between 1-, 2-, 3- and 4-byte formats."
msgstr "Преобразование выборок между 1-, 2-, 3- и 4-байтовыми форматами."

#: ../../library/audioop.rst:159
msgid ""
"In some audio formats, such as .WAV files, 16, 24 and 32 bit samples are "
"signed, but 8 bit samples are unsigned.  So when converting to 8 bit wide "
"samples for these formats, you need to also add 128 to the result::"
msgstr ""
"В некоторых аудиоформатах, таких как файлы .WAV, 16-, 24- и 32-битные семплы "
"имеют знак, а 8-битные семплы — беззнаковые. Поэтому при конвертации в 8-"
"битные семплы для этих форматов к результату нужно еще прибавить 128::"

#: ../../library/audioop.rst:166
msgid ""
"The same, in reverse, has to be applied when converting from 8 to 16, 24 or "
"32 bit width samples."
msgstr ""
"То же самое, наоборот, необходимо применить при преобразовании выборок с "
"шириной 8 в 16, 24 или 32 бита."

#: ../../library/audioop.rst:172
msgid ""
"Convert samples in the audio fragment to u-LAW encoding and return this as a "
"bytes object.  u-LAW is an audio encoding format whereby you get a dynamic "
"range of about 14 bits using only 8 bit samples.  It is used by the Sun "
"audio hardware, among others."
msgstr ""
"Преобразуйте образцы аудиофрагмента в кодировку u-LAW и верните это как "
"байтовый объект. u-LAW — это формат кодирования звука, при котором вы "
"получаете динамический диапазон около 14 бит, используя только 8-битные "
"семплы. Он используется, среди прочего, аудиооборудованием Sun."

#: ../../library/audioop.rst:180
msgid ""
"Return the maximum of the *absolute value* of all samples in a fragment."
msgstr ""
"Возвращает максимальное *абсолютное значение* всех выборок во фрагменте."

#: ../../library/audioop.rst:185
msgid "Return the maximum peak-peak value in the sound fragment."
msgstr "Возвращает максимальное пиковое значение в звуковом фрагменте."

#: ../../library/audioop.rst:190
msgid ""
"Return a tuple consisting of the minimum and maximum values of all samples "
"in the sound fragment."
msgstr ""
"Возвращает кортеж, состоящий из минимальных и максимальных значений всех "
"сэмплов в звуковом фрагменте."

#: ../../library/audioop.rst:196
msgid ""
"Return a fragment that has all samples in the original fragment multiplied "
"by the floating-point value *factor*.  Samples are truncated in case of "
"overflow."
msgstr ""
"Возвращает фрагмент, в котором все выборки исходного фрагмента умножены на "
"значение с плавающей запятой *фактор*. Выборки обрезаются в случае "
"переполнения."

#: ../../library/audioop.rst:202
msgid "Convert the frame rate of the input fragment."
msgstr "Преобразуйте частоту кадров входного фрагмента."

#: ../../library/audioop.rst:204
msgid ""
"*state* is a tuple containing the state of the converter.  The converter "
"returns a tuple ``(newfragment, newstate)``, and *newstate* should be passed "
"to the next call of :func:`ratecv`.  The initial call should pass ``None`` "
"as the state."
msgstr ""
"*state* — это кортеж, содержащий состояние преобразователя. Конвертер "
"возвращает кортеж ``(newfragment, newstate)``, и *newstate* должно быть "
"передано при следующем вызове :func:`ratecv`. Первоначальный вызов должен "
"передавать None в качестве состояния."

#: ../../library/audioop.rst:208
msgid ""
"The *weightA* and *weightB* arguments are parameters for a simple digital "
"filter and default to ``1`` and ``0`` respectively."
msgstr ""
"Аргументы *weightA* и *weightB* являются параметрами простого цифрового "
"фильтра и по умолчанию равны «1» и «0» соответственно."

#: ../../library/audioop.rst:214
msgid "Reverse the samples in a fragment and returns the modified fragment."
msgstr "Переверните выборки во фрагменте и верните измененный фрагмент."

#: ../../library/audioop.rst:219
msgid ""
"Return the root-mean-square of the fragment, i.e. ``sqrt(sum(S_i^2)/n)``."
msgstr ""
"Возвращает среднеквадратическое значение фрагмента, т.е. ``sqrt(sum(S_i^2)/"
"n)``."

#: ../../library/audioop.rst:221
msgid "This is a measure of the power in an audio signal."
msgstr "Это мера мощности аудиосигнала."

#: ../../library/audioop.rst:226
msgid ""
"Convert a stereo fragment to a mono fragment.  The left channel is "
"multiplied by *lfactor* and the right channel by *rfactor* before adding the "
"two channels to give a mono signal."
msgstr ""
"Преобразуйте стереофрагмент в монофрагмент. Левый канал умножается на "
"*lfactor*, а правый канал на *rfactor* перед сложением двух каналов для "
"получения моносигнала."

#: ../../library/audioop.rst:233
msgid ""
"Generate a stereo fragment from a mono fragment.  Each pair of samples in "
"the stereo fragment are computed from the mono sample, whereby left channel "
"samples are multiplied by *lfactor* and right channel samples by *rfactor*."
msgstr ""
"Сгенерируйте стереофрагмент из монофрагмента. Каждая пара сэмплов в "
"стереофрагменте вычисляется из моносэмпла, при этом сэмплы левого канала "
"умножаются на *lfactor*, а сэмплы правого канала на *rfactor*."

#: ../../library/audioop.rst:240
msgid ""
"Convert sound fragments in u-LAW encoding to linearly encoded sound "
"fragments. u-LAW encoding always uses 8 bits samples, so *width* refers only "
"to the sample width of the output fragment here."
msgstr ""
"Преобразуйте звуковые фрагменты в кодировке u-LAW в линейно закодированные "
"звуковые фрагменты. Кодирование u-LAW всегда использует 8-битные выборки, "
"поэтому *ширина* здесь относится только к ширине выборки выходного фрагмента."

#: ../../library/audioop.rst:244
msgid ""
"Note that operations such as :func:`.mul` or :func:`.max` make no "
"distinction between mono and stereo fragments, i.e. all samples are treated "
"equal.  If this is a problem the stereo fragment should be split into two "
"mono fragments first and recombined later.  Here is an example of how to do "
"that::"
msgstr ""
"Обратите внимание, что такие операции, как :func:`.mul` или :func:`.max`, не "
"делают различий между моно- и стереофрагментами, т.е. все семплы "
"обрабатываются одинаково. Если это проблема, стереофрагмент следует сначала "
"разделить на два монофрагмента, а затем повторно объединить. Вот пример "
"того, как это сделать:"

#: ../../library/audioop.rst:258
msgid ""
"If you use the ADPCM coder to build network packets and you want your "
"protocol to be stateless (i.e. to be able to tolerate packet loss) you "
"should not only transmit the data but also the state.  Note that you should "
"send the *initial* state (the one you passed to :func:`lin2adpcm`) along to "
"the decoder, not the final state (as returned by the coder).  If you want to "
"use :class:`struct.Struct` to store the state in binary you can code the "
"first element (the predicted value) in 16 bits and the second (the delta "
"index) in 8."
msgstr ""
"Если вы используете кодер ADPCM для создания сетевых пакетов и хотите, чтобы "
"ваш протокол не сохранял состояния (т. е. допускал потерю пакетов), вам "
"следует передавать не только данные, но и состояние. Обратите внимание, что "
"вам следует отправлять *начальное* состояние (то, которое вы передали в :"
"func:`lin2adpcm`) вместе с декодером, а не конечное состояние (то, которое "
"возвращается кодером). Если вы хотите использовать :class:`struct.Struct` "
"для хранения состояния в двоичном формате, вы можете закодировать первый "
"элемент (прогнозируемое значение) в 16 битах, а второй (дельта-индекс) в 8."

#: ../../library/audioop.rst:266
msgid ""
"The ADPCM coders have never been tried against other ADPCM coders, only "
"against themselves.  It could well be that I misinterpreted the standards in "
"which case they will not be interoperable with the respective standards."
msgstr ""
"Кодировщики ADPCM никогда не использовались против других кодировщиков "
"ADPCM, только против самих себя. Вполне возможно, что я неправильно "
"истолковал стандарты, и в этом случае они не будут совместимы с "
"соответствующими стандартами."

#: ../../library/audioop.rst:270
msgid ""
"The :func:`find\\*` routines might look a bit funny at first sight. They are "
"primarily meant to do echo cancellation.  A reasonably fast way to do this "
"is to pick the most energetic piece of the output sample, locate that in the "
"input sample and subtract the whole output sample from the input sample::"
msgstr ""
"На первый взгляд процедуры :func:`find\\*` могут показаться немного "
"забавными. Они в первую очередь предназначены для эхоподавления. Достаточно "
"быстрый способ сделать это — выбрать наиболее энергичную часть выходной "
"выборки, найти ее во входной выборке и вычесть всю выходную выборку из "
"входной выборки:"

#: ../../library/audioop.rst:24
msgid "Intel/DVI ADPCM"
msgstr "Intel/DVI ADPCM"

#: ../../library/audioop.rst:24
msgid "ADPCM, Intel/DVI"
msgstr "ADPCM, Intel/DVI"

#: ../../library/audioop.rst:24
msgid "a-LAW"
msgstr "a-LAW"

#: ../../library/audioop.rst:24
msgid "u-LAW"
msgstr "u-LAW"
