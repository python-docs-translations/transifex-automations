# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Roustam Khamidoulline, 2024
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-02 14:54+0000\n"
"PO-Revision-Date: 2024-05-11 00:33+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/readline.rst:2
msgid ":mod:`!readline` --- GNU readline interface"
msgstr ":mod:`!readline` --- Интерфейс строки чтения GNU"

#: ../../library/readline.rst:12
msgid ""
"The :mod:`readline` module defines a number of functions to facilitate "
"completion and reading/writing of history files from the Python interpreter. "
"This module can be used directly, or via the :mod:`rlcompleter` module, "
"which supports completion of Python identifiers at the interactive prompt.  "
"Settings made using  this module affect the behaviour of both the "
"interpreter's interactive prompt  and the prompts offered by the built-in :"
"func:`input` function."
msgstr ""
"Модуль :mod:`readline` определяет ряд функций, облегчающих завершение и "
"чтение/запись файлов истории из интерпретатора Python. Этот модуль можно "
"использовать напрямую или через модуль :mod:`rlcompleter`, который "
"поддерживает завершение идентификаторов Python в интерактивной подсказке. "
"Настройки, выполненные с помощью этого модуля, влияют на поведение как "
"интерактивной подсказки переводчика, так и подсказок, предлагаемых "
"встроенной функцией :func:`input`."

#: ../../library/readline.rst:20
msgid ""
"Readline keybindings may be configured via an initialization file, typically "
"``.inputrc`` in your home directory.  See `Readline Init File <https://"
"tiswww.cwru.edu/php/chet/readline/rluserman.html#Readline-Init-File>`_ in "
"the GNU Readline manual for information about the format and allowable "
"constructs of that file, and the capabilities of the Readline library in "
"general."
msgstr ""
"Сочетания клавиш Readline можно настроить с помощью файла инициализации, "
"обычно ``.inputrc`` в вашем домашнем каталоге. См. `Readline Init File "
"<https://tiswww.cwru.edu/php/chet/readline/rluserman.html#Readline-Init-"
"File>`_ в руководстве GNU Readline для получения информации о формате и "
"допустимых конструкциях этого файла. , и возможности библиотеки Readline в "
"целом."

#: ../../library/readline.rst:29
msgid ""
"The underlying Readline library API may be implemented by the ``libedit`` "
"library instead of GNU readline. On macOS the :mod:`readline` module detects "
"which library is being used at run time."
msgstr ""
"Базовый API библиотеки Readline может быть реализован с помощью библиотеки "
"libedit вместо GNU readline. В macOS модуль :mod:`readline` определяет, "
"какая библиотека используется во время выполнения."

#: ../../library/readline.rst:34
msgid ""
"The configuration file for ``libedit`` is different from that of GNU "
"readline. If you programmatically load configuration strings you can check "
"for the text \"libedit\" in :const:`readline.__doc__` to differentiate "
"between GNU readline and libedit."
msgstr ""
"Файл конфигурации libedit отличается от файла конфигурации GNU readline. "
"Если вы программно загружаете строки конфигурации, вы можете проверить "
"наличие текста «libedit» в :const:`readline.__doc__`, чтобы различать GNU "
"readline и libedit."

#: ../../library/readline.rst:39
msgid ""
"If you use *editline*/``libedit`` readline emulation on macOS, the "
"initialization file located in your home directory is named ``.editrc``. For "
"example, the following content in ``~/.editrc`` will turn ON *vi* "
"keybindings and TAB completion::"
msgstr ""
"Если вы используете эмуляцию линии чтения *editline*/``libedit`` в macOS, "
"файл инициализации, расположенный в вашем домашнем каталоге, называется ``."
"editrc``. Например, следующее содержимое в ``~/.editrc`` включит привязки "
"клавиш *vi* и завершение TAB:"

#: ../../library/readline.rst:44
msgid ""
"python:bind -v\n"
"python:bind ^I rl_complete"
msgstr ""
"python:bind -v\n"
"python:bind ^I rl_complete"

#: ../../library/readline.rst:47
msgid ""
"Also note that different libraries may use different history file formats. "
"When switching the underlying library, existing history files may become "
"unusable."
msgstr ""
"Также обратите внимание, что разные библиотеки могут использовать разные "
"форматы файлов истории. При переключении базовой библиотеки существующие "
"файлы истории могут стать непригодными для использования."

#: ../../library/readline.rst:53
msgid "Init file"
msgstr "Инициализирующий файл"

#: ../../library/readline.rst:55
msgid "The following functions relate to the init file and user configuration:"
msgstr ""
"Следующие функции относятся к файлу инициализации и пользовательской "
"конфигурации:"

#: ../../library/readline.rst:60
msgid ""
"Execute the init line provided in the *string* argument. This calls :c:func:"
"`!rl_parse_and_bind` in the underlying library."
msgstr ""

#: ../../library/readline.rst:66
msgid ""
"Execute a readline initialization file. The default filename is the last "
"filename used. This calls :c:func:`!rl_read_init_file` in the underlying "
"library."
msgstr ""

#: ../../library/readline.rst:71
msgid "Line buffer"
msgstr "Линейный буфер"

#: ../../library/readline.rst:73
msgid "The following functions operate on the line buffer:"
msgstr "Следующие функции работают с строковым буфером:"

#: ../../library/readline.rst:78
msgid ""
"Return the current contents of the line buffer (:c:data:`!rl_line_buffer` in "
"the underlying library)."
msgstr ""

#: ../../library/readline.rst:84
msgid ""
"Insert text into the line buffer at the cursor position.  This calls :c:func:"
"`!rl_insert_text` in the underlying library, but ignores the return value."
msgstr ""

#: ../../library/readline.rst:91
msgid ""
"Change what's displayed on the screen to reflect the current contents of the "
"line buffer.  This calls :c:func:`!rl_redisplay` in the underlying library."
msgstr ""

#: ../../library/readline.rst:96
msgid "History file"
msgstr "Исторический файл"

#: ../../library/readline.rst:98
msgid "The following functions operate on a history file:"
msgstr "Следующие функции работают с файлом истории:"

#: ../../library/readline.rst:103
msgid ""
"Load a readline history file, and append it to the history list. The default "
"filename is :file:`~/.history`.  This calls :c:func:`!read_history` in the "
"underlying library."
msgstr ""

#: ../../library/readline.rst:110
msgid ""
"Save the history list to a readline history file, overwriting any existing "
"file.  The default filename is :file:`~/.history`.  This calls :c:func:`!"
"write_history` in the underlying library."
msgstr ""

#: ../../library/readline.rst:117
msgid ""
"Append the last *nelements* items of history to a file.  The default "
"filename is :file:`~/.history`.  The file must already exist.  This calls :c:"
"func:`!append_history` in the underlying library.  This function only exists "
"if Python was compiled for a version of the library that supports it."
msgstr ""
"Добавьте последний * nelements * элементы истории в файл. Имя файла по "
"умолчанию: файл: `~/.history`. Файл должен уже существовать. Это вызывает: "
"C: Func: `! Append_history` в базовой библиотеке. Эта функция существует "
"только в том случае, если Python был составлен для версии библиотеки, "
"которая поддерживает ее."

#: ../../library/readline.rst:129
msgid ""
"Set or return the desired number of lines to save in the history file. The :"
"func:`write_history_file` function uses this value to truncate the history "
"file, by calling :c:func:`!history_truncate_file` in the underlying "
"library.  Negative values imply unlimited history file size."
msgstr ""
"Установите или верните желаемое количество строк для сохранения в файле "
"истории. Функция: func: `write_history_file` использует это значение, чтобы "
"усечь файл истории, позвонив: C: Func:`! Отрицательные значения "
"подразумевают неограниченный размер файла истории."

#: ../../library/readline.rst:137
msgid "History list"
msgstr "Исторический список"

#: ../../library/readline.rst:139
msgid "The following functions operate on a global history list:"
msgstr "Следующие функции работают со списком глобальной истории:"

#: ../../library/readline.rst:144
msgid ""
"Clear the current history.  This calls :c:func:`!clear_history` in the "
"underlying library.  The Python function only exists if Python was compiled "
"for a version of the library that supports it."
msgstr ""
"Очистить текущую историю. Это вызывает :c:func:`!clear_history` в базовой "
"библиотеке. Функция Python существует только в том случае, если Python был "
"скомпилирован для версии библиотеки, которая ее поддерживает."

#: ../../library/readline.rst:151
msgid ""
"Return the number of items currently in the history.  (This is different "
"from :func:`get_history_length`, which returns the maximum number of lines "
"that will be written to a history file.)"
msgstr ""
"Возвращает количество элементов, находящихся в настоящее время в истории. "
"(Это отличается от :func:`get_history_length`, которая возвращает "
"максимальное количество строк, которые будут записаны в файл истории.)"

#: ../../library/readline.rst:158
msgid ""
"Return the current contents of history item at *index*.  The item index is "
"one-based.  This calls :c:func:`!history_get` in the underlying library."
msgstr ""

#: ../../library/readline.rst:164
msgid ""
"Remove history item specified by its position from the history. The position "
"is zero-based.  This calls :c:func:`!remove_history` in the underlying "
"library."
msgstr ""

#: ../../library/readline.rst:171
msgid ""
"Replace history item specified by its position with *line*. The position is "
"zero-based.  This calls :c:func:`!replace_history_entry` in the underlying "
"library."
msgstr ""

#: ../../library/readline.rst:178
msgid ""
"Append *line* to the history buffer, as if it was the last line typed. This "
"calls :c:func:`!add_history` in the underlying library."
msgstr ""

#: ../../library/readline.rst:184
msgid ""
"Enable or disable automatic calls to :c:func:`!add_history` when reading "
"input via readline.  The *enabled* argument should be a Boolean value that "
"when true, enables auto history, and that when false, disables auto history."
msgstr ""
"Включить или отключить автоматические вызовы :c:func:`!add_history` при "
"чтении ввода через readline. Аргумент *enabled* должен быть логическим "
"значением, которое при значении true включает автоматическую историю, а при "
"значении false отключает автоматическую историю."

#: ../../library/readline.rst:192
msgid ""
"Auto history is enabled by default, and changes to this do not persist "
"across multiple sessions."
msgstr ""
"Автоматическая история включена по умолчанию, и ее изменения не сохраняются "
"в течение нескольких сеансов."

#: ../../library/readline.rst:197
msgid "Startup hooks"
msgstr "Захваты запуска"

#: ../../library/readline.rst:202
msgid ""
"Set or remove the function invoked by the :c:data:`!rl_startup_hook` "
"callback of the underlying library.  If *function* is specified, it will be "
"used as the new hook function; if omitted or ``None``, any function already "
"installed is removed.  The hook is called with no arguments just before "
"readline prints the first prompt."
msgstr ""
"Установите или удалите функцию, вызванную: C: DATA: `! RL_STARTUP_HOOK Если "
"* функция * указана, она будет использоваться в качестве новой функции "
"крючка; Если опущены или `` none``, любая уже установленная функция "
"удаляется. Крюк вызывается без аргументов непосредственно перед тем, как "
"чтения печатают первое подсказку."

#: ../../library/readline.rst:211
msgid ""
"Set or remove the function invoked by the :c:data:`!rl_pre_input_hook` "
"callback of the underlying library.  If *function* is specified, it will be "
"used as the new hook function; if omitted or ``None``, any function already "
"installed is removed.  The hook is called with no arguments after the first "
"prompt has been printed and just before readline starts reading input "
"characters.  This function only exists if Python was compiled for a version "
"of the library that supports it."
msgstr ""
"Установите или удалите функцию, вызванную: C: Data: `! RL_PRE_INPUT_HOOK` "
"Обратный вызов базовой библиотеки. Если * функция * указана, она будет "
"использоваться в качестве новой функции крючка; Если опущены или `` none``, "
"любая уже установленная функция удаляется. Крюк вызывается без аргументов "
"после того, как первая подсказка была напечатана, и непосредственно перед "
"чтением начинает читать входные символы. Эта функция существует только в том "
"случае, если Python был составлен для версии библиотеки, которая "
"поддерживает ее."

#: ../../library/readline.rst:223
msgid "Completion"
msgstr "Завершение"

#: ../../library/readline.rst:225
msgid ""
"The following functions relate to implementing a custom word completion "
"function.  This is typically operated by the Tab key, and can suggest and "
"automatically complete a word being typed.  By default, Readline is set up "
"to be used by :mod:`rlcompleter` to complete Python identifiers for the "
"interactive interpreter.  If the :mod:`readline` module is to be used with a "
"custom completer, a different set of word delimiters should be set."
msgstr ""
"Следующие функции относятся к реализации пользовательской функции завершения "
"слов. Обычно это управляется клавишей Tab и может предлагать и автоматически "
"дополнять набираемое слово. По умолчанию Readline настроен на использование :"
"mod:`rlcompleter` для завершения идентификаторов Python для интерактивного "
"интерпретатора. Если модуль :mod:`readline` будет использоваться с "
"пользовательским заполнителем, необходимо установить другой набор "
"разделителей слов."

#: ../../library/readline.rst:235
msgid ""
"Set or remove the completer function.  If *function* is specified, it will "
"be used as the new completer function; if omitted or ``None``, any completer "
"function already installed is removed.  The completer function is called as "
"``function(text, state)``, for *state* in ``0``, ``1``, ``2``, ..., until it "
"returns a non-string value.  It should return the next possible completion "
"starting with *text*."
msgstr ""
"Установите или удалите функцию завершения. Если указана *функция*, она будет "
"использоваться как новая функция завершения; если он опущен или ``Нет``, "
"любая уже установленная функция завершения будет удалена. Функция завершения "
"вызывается как ``function(text,state)`` для *state* в ``0``, ``1``, "
"``2``, ..., пока она не вернет не- строковое значение. Он должен вернуть "
"следующее возможное завершение, начинающееся с *text*."

#: ../../library/readline.rst:242
msgid ""
"The installed completer function is invoked by the *entry_func* callback "
"passed to :c:func:`!rl_completion_matches` in the underlying library. The "
"*text* string comes from the first parameter to the :c:data:`!"
"rl_attempted_completion_function` callback of the underlying library."
msgstr ""
"Установленная функция завершения вызывается обратным вызовом *entry_func*, "
"переданным в :c:func:`!rl_completion_matches` в базовой библиотеке. Строка "
"*text* поступает из первого параметра обратного вызова :c:data:`!"
"rl_attempted_completion_function` базовой библиотеки."

#: ../../library/readline.rst:251
msgid ""
"Get the completer function, or ``None`` if no completer function has been "
"set."
msgstr ""
"Получите функцию завершения или ``None``, если функция завершения не была "
"установлена."

#: ../../library/readline.rst:256
msgid ""
"Get the type of completion being attempted.  This returns the :c:data:`!"
"rl_completion_type` variable in the underlying library as an integer."
msgstr ""

#: ../../library/readline.rst:264
msgid ""
"Get the beginning or ending index of the completion scope. These indexes are "
"the *start* and *end* arguments passed to the :c:data:`!"
"rl_attempted_completion_function` callback of the underlying library.  The "
"values may be different in the same input editing scenario based on the "
"underlying C readline implementation. Ex: libedit is known to behave "
"differently than libreadline."
msgstr ""
"Получите начало или окончание индекса прицела завершения. Эти индексы - это "
"* start * и * end * аргументы, передаваемые: c: data: `! "
"Rl_attempted_completion_function` обратный вызов базовой библиотеки. "
"Значения могут отличаться в одном и том же сценарии редактирования ввода, "
"основанном на базовой реализации C Readline. Пример: Libedit, как известно, "
"ведет себя иначе, чем Libreadline."

#: ../../library/readline.rst:275
msgid ""
"Set or get the word delimiters for completion.  These determine the start of "
"the word to be considered for completion (the completion scope). These "
"functions access the :c:data:`!rl_completer_word_break_characters` variable "
"in the underlying library."
msgstr ""
"Устанавливают или получают разделители слов для завершения. Они определяют "
"начало слова, которое будет рассматриваться для завершения (область "
"завершения). Эти функции обращаются к переменной :c:data:`!"
"rl_completer_word_break_characters` в базовой библиотеке."

#: ../../library/readline.rst:283
msgid ""
"Set or remove the completion display function.  If *function* is specified, "
"it will be used as the new completion display function; if omitted or "
"``None``, any completion display function already installed is removed.  "
"This sets or clears the :c:data:`!rl_completion_display_matches_hook` "
"callback in the underlying library.  The completion display function is "
"called as ``function(substitution, [matches], longest_match_length)`` once "
"each time matches need to be displayed."
msgstr ""
"Установите или удалите функцию отображения завершения. Если * функция * "
"указана, она будет использоваться в качестве новой функции отображения "
"завершения; Если опущены или `` none``, любая уже установленная функция "
"дисплея завершения удаляется. Это устанавливает или очищает: C: Data: `! "
"RL_COMPLETION_DISPLAY_MATCHES_HOOK Функция отображения завершения называется "
"как `` function (замена, [совпадает], longest_match_length) `` один раз, "
"когда необходимо отображать совпадения каждый раз."

#: ../../library/readline.rst:296
msgid "Example"
msgstr "Пример"

#: ../../library/readline.rst:298
msgid ""
"The following example demonstrates how to use the :mod:`readline` module's "
"history reading and writing functions to automatically load and save a "
"history file named :file:`.python_history` from the user's home directory.  "
"The code below would normally be executed automatically during interactive "
"sessions from the user's :envvar:`PYTHONSTARTUP` file. ::"
msgstr ""
"В следующем примере показано, как использовать функции чтения и записи "
"истории модуля :mod:`readline` для автоматической загрузки и сохранения "
"файла истории с именем :file:`.python_history` из домашнего каталога "
"пользователя. Приведенный ниже код обычно выполняется автоматически во время "
"интерактивных сеансов из файла :envvar:`PYTHONSTARTUP` пользователя. ::"

#: ../../library/readline.rst:304
msgid ""
"import atexit\n"
"import os\n"
"import readline\n"
"\n"
"histfile = os.path.join(os.path.expanduser(\"~\"), \".python_history\")\n"
"try:\n"
"    readline.read_history_file(histfile)\n"
"    # default history len is -1 (infinite), which may grow unruly\n"
"    readline.set_history_length(1000)\n"
"except FileNotFoundError:\n"
"    pass\n"
"\n"
"atexit.register(readline.write_history_file, histfile)"
msgstr ""
"import atexit\n"
"import os\n"
"import readline\n"
"\n"
"histfile = os.path.join(os.path.expanduser(\"~\"), \".python_history\")\n"
"try:\n"
"    readline.read_history_file(histfile)\n"
"    # default history len is -1 (infinite), which may grow unruly\n"
"    readline.set_history_length(1000)\n"
"except FileNotFoundError:\n"
"    pass\n"
"\n"
"atexit.register(readline.write_history_file, histfile)"

#: ../../library/readline.rst:318
msgid ""
"This code is actually automatically run when Python is run in :ref:"
"`interactive mode <tut-interactive>` (see :ref:`rlcompleter-config`)."
msgstr ""
"Этот код на самом деле автоматически запускается, когда Python запускается "
"в :ref:`интерактивном режиме <tut-interactive>` (см. :ref:`rlcompleter-"
"config`)."

#: ../../library/readline.rst:321
msgid ""
"The following example achieves the same goal but supports concurrent "
"interactive sessions, by only appending the new history. ::"
msgstr ""
"Следующий пример достигает той же цели, но поддерживает одновременные "
"интерактивные сеансы, добавляя только новую историю. ::"

#: ../../library/readline.rst:324
msgid ""
"import atexit\n"
"import os\n"
"import readline\n"
"histfile = os.path.join(os.path.expanduser(\"~\"), \".python_history\")\n"
"\n"
"try:\n"
"    readline.read_history_file(histfile)\n"
"    h_len = readline.get_current_history_length()\n"
"except FileNotFoundError:\n"
"    open(histfile, 'wb').close()\n"
"    h_len = 0\n"
"\n"
"def save(prev_h_len, histfile):\n"
"    new_h_len = readline.get_current_history_length()\n"
"    readline.set_history_length(1000)\n"
"    readline.append_history_file(new_h_len - prev_h_len, histfile)\n"
"atexit.register(save, h_len, histfile)"
msgstr ""
"import atexit\n"
"import os\n"
"import readline\n"
"histfile = os.path.join(os.path.expanduser(\"~\"), \".python_history\")\n"
"\n"
"try:\n"
"    readline.read_history_file(histfile)\n"
"    h_len = readline.get_current_history_length()\n"
"except FileNotFoundError:\n"
"    open(histfile, 'wb').close()\n"
"    h_len = 0\n"
"\n"
"def save(prev_h_len, histfile):\n"
"    new_h_len = readline.get_current_history_length()\n"
"    readline.set_history_length(1000)\n"
"    readline.append_history_file(new_h_len - prev_h_len, histfile)\n"
"atexit.register(save, h_len, histfile)"

#: ../../library/readline.rst:342
msgid ""
"The following example extends the :class:`code.InteractiveConsole` class to "
"support history save/restore. ::"
msgstr ""
"Следующий пример расширяет класс :class:`code.InteractiveConsole` для "
"поддержки сохранения/восстановления истории. ::"

#: ../../library/readline.rst:345
msgid ""
"import atexit\n"
"import code\n"
"import os\n"
"import readline\n"
"\n"
"class HistoryConsole(code.InteractiveConsole):\n"
"    def __init__(self, locals=None, filename=\"<console>\",\n"
"                 histfile=os.path.expanduser(\"~/.console-history\")):\n"
"        code.InteractiveConsole.__init__(self, locals, filename)\n"
"        self.init_history(histfile)\n"
"\n"
"    def init_history(self, histfile):\n"
"        readline.parse_and_bind(\"tab: complete\")\n"
"        if hasattr(readline, \"read_history_file\"):\n"
"            try:\n"
"                readline.read_history_file(histfile)\n"
"            except FileNotFoundError:\n"
"                pass\n"
"            atexit.register(self.save_history, histfile)\n"
"\n"
"    def save_history(self, histfile):\n"
"        readline.set_history_length(1000)\n"
"        readline.write_history_file(histfile)"
msgstr ""
"import atexit\n"
"import code\n"
"import os\n"
"import readline\n"
"\n"
"class HistoryConsole(code.InteractiveConsole):\n"
"    def __init__(self, locals=None, filename=\"<console>\",\n"
"                 histfile=os.path.expanduser(\"~/.console-history\")):\n"
"        code.InteractiveConsole.__init__(self, locals, filename)\n"
"        self.init_history(histfile)\n"
"\n"
"    def init_history(self, histfile):\n"
"        readline.parse_and_bind(\"tab: complete\")\n"
"        if hasattr(readline, \"read_history_file\"):\n"
"            try:\n"
"                readline.read_history_file(histfile)\n"
"            except FileNotFoundError:\n"
"                pass\n"
"            atexit.register(self.save_history, histfile)\n"
"\n"
"    def save_history(self, histfile):\n"
"        readline.set_history_length(1000)\n"
"        readline.write_history_file(histfile)"
