# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-11 15:02+0000\n"
"PO-Revision-Date: 2025-05-08 05:09+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/os.path.rst:2
msgid ":mod:`!os.path` --- Common pathname manipulations"
msgstr ":mod:`!os.path` --- Общие манипуляции с путями"

#: ../../library/os.path.rst:7
msgid ""
"**Source code:** :source:`Lib/genericpath.py`, :source:`Lib/posixpath.py` "
"(for POSIX) and :source:`Lib/ntpath.py` (for Windows)."
msgstr ""
"**Исходный код:** :source:`Lib/genericpath.py`, :source:`Lib/posixpath.py` "
"(для POSIX) и :source:`Lib/ntpath.py` (для Windows)."

#: ../../library/os.path.rst:14
msgid ""
"This module implements some useful functions on pathnames. To read or write "
"files see :func:`open`, and for accessing the filesystem see the :mod:`os` "
"module. The path parameters can be passed as strings, or bytes, or any "
"object implementing the :class:`os.PathLike` protocol."
msgstr ""
"Этот модуль реализует некоторые полезные функции для имен путей. Для чтения "
"или записи файлов используйте :func:`open`, а для доступа к файловой системе "
"используйте модуль :mod:`os`. Параметры пути могут передаваться в виде "
"строк, байтов или любого объекта, реализующего протокол :class:`os.PathLike`."

#: ../../library/os.path.rst:19
msgid ""
"Unlike a Unix shell, Python does not do any *automatic* path expansions. "
"Functions such as :func:`expanduser` and :func:`expandvars` can be invoked "
"explicitly when an application desires shell-like path expansion.  (See also "
"the :mod:`glob` module.)"
msgstr ""
"В отличие от оболочки Unix, Python не выполняет никаких *автоматических* "
"расширений путей. Такие функции, как :func:`expanduser` и :func:"
"`expandvars`, можно вызывать явно, когда приложению требуется расширение "
"пути в стиле оболочки. (См. также модуль :mod:`glob`.)"

#: ../../library/os.path.rst:26
msgid "The :mod:`pathlib` module offers high-level path objects."
msgstr "Модуль :mod:`pathlib` предлагает объекты путей высокого уровня."

#: ../../library/os.path.rst:31
msgid ""
"All of these functions accept either only bytes or only string objects as "
"their parameters.  The result is an object of the same type, if a path or "
"file name is returned."
msgstr ""
"Все эти функции принимают в качестве параметров либо только байты, либо "
"только строковые объекты. Результатом является объект того же типа, если "
"возвращается путь или имя файла."

#: ../../library/os.path.rst:37
msgid ""
"Since different operating systems have different path name conventions, "
"there are several versions of this module in the standard library.  The :mod:"
"`os.path` module is always the path module suitable for the operating system "
"Python is running on, and therefore usable for local paths.  However, you "
"can also import and use the individual modules if you want to manipulate a "
"path that is *always* in one of the different formats.  They all have the "
"same interface:"
msgstr ""
"Поскольку в разных операционных системах действуют разные соглашения об "
"именах путей, в стандартной библиотеке имеется несколько версий этого "
"модуля. Модуль :mod:`os.path` всегда является модулем пути, подходящим для "
"операционной системы, в которой работает Python, и, следовательно, может "
"использоваться для локальных путей. Однако вы также можете импортировать и "
"использовать отдельные модули, если хотите манипулировать путем, который "
"*всегда* находится в одном из различных форматов. Все они имеют одинаковый "
"интерфейс:"

#: ../../library/os.path.rst:45
msgid ":mod:`posixpath` for UNIX-style paths"
msgstr ":mod:`posixpath` для путей в стиле UNIX"

#: ../../library/os.path.rst:46
msgid ":mod:`ntpath` for Windows paths"
msgstr ":mod:`ntpath` для путей Windows"

#: ../../library/os.path.rst:51
msgid ""
":func:`exists`, :func:`lexists`, :func:`isdir`, :func:`isfile`, :func:"
"`islink`, and :func:`ismount` now return ``False`` instead of raising an "
"exception for paths that contain characters or bytes unrepresentable at the "
"OS level."
msgstr ""
":func:`exists`, :func:`lexists`, :func:`isdir`, :func:`isfile`, :func:"
"`islink` и :func:`ismount` теперь вместо этого возвращают ``False`` создания "
"исключения для путей, содержащих символы или байты, непредставимые на уровне "
"ОС."

#: ../../library/os.path.rst:59
msgid ""
"Return a normalized absolutized version of the pathname *path*. On most "
"platforms, this is equivalent to calling the function :func:`normpath` as "
"follows: ``normpath(join(os.getcwd(), path))``."
msgstr ""
"Возвращает нормализованную абсолютную версию пути *path*. На большинстве "
"платформ это эквивалентно вызову функции :func:`normpath` следующим образом: "
"``normpath(join(os.getcwd(), path))``."

#: ../../library/os.path.rst:63 ../../library/os.path.rst:76
#: ../../library/os.path.rst:117 ../../library/os.path.rst:126
#: ../../library/os.path.rst:142 ../../library/os.path.rst:152
#: ../../library/os.path.rst:178 ../../library/os.path.rst:198
#: ../../library/os.path.rst:215 ../../library/os.path.rst:227
#: ../../library/os.path.rst:236 ../../library/os.path.rst:246
#: ../../library/os.path.rst:260 ../../library/os.path.rst:270
#: ../../library/os.path.rst:289 ../../library/os.path.rst:309
#: ../../library/os.path.rst:381 ../../library/os.path.rst:401
#: ../../library/os.path.rst:441 ../../library/os.path.rst:470
#: ../../library/os.path.rst:486 ../../library/os.path.rst:497
#: ../../library/os.path.rst:511 ../../library/os.path.rst:527
#: ../../library/os.path.rst:552 ../../library/os.path.rst:616
msgid "Accepts a :term:`path-like object`."
msgstr "Принимает :term:`объект, похожий на путь`."

#: ../../library/os.path.rst:69
msgid ""
"Return the base name of pathname *path*.  This is the second element of the "
"pair returned by passing *path* to the function :func:`split`.  Note that "
"the result of this function is different from the Unix :program:`basename` "
"program; where :program:`basename` for ``'/foo/bar/'`` returns ``'bar'``, "
"the :func:`basename` function returns an empty string (``''``)."
msgstr ""
"Возвращает базовое имя пути *path*. Это второй элемент пары, возвращаемой "
"путем передачи *path* функции :func:`split`. Обратите внимание, что "
"результат этой функции отличается от результата программы Unix :program:"
"`basename`; где :program:`basename` для ``'/foo/bar/'`` возвращает "
"``'bar'``, функция :func:`basename` возвращает пустую строку (``''``)."

#: ../../library/os.path.rst:82
msgid ""
"Return the longest common sub-path of each pathname in the iterable "
"*paths*.  Raise :exc:`ValueError` if *paths* contain both absolute and "
"relative pathnames, if *paths* are on different drives, or if *paths* is "
"empty.  Unlike :func:`commonprefix`, this returns a valid path."
msgstr ""
"Возвращает самый длинный общий подпуть каждого пути в итерируемых *paths*. "
"Поднимите :exc:`ValueError`, если *paths* содержит как абсолютные, так и "
"относительные имена путей, если *paths* находятся на разных дисках или если "
"*paths* пусто. В отличие от :func:`commonprefix`, он возвращает "
"действительный путь."

#: ../../library/os.path.rst:90
msgid "Accepts a sequence of :term:`path-like objects <path-like object>`."
msgstr ""
"Принимает последовательность :term:`path-like object <path-like object>`."

#: ../../library/os.path.rst:93
msgid "Any iterable can now be passed, rather than just sequences."
msgstr ""
"Теперь можно передавать любые итерации, а не только последовательности."

#: ../../library/os.path.rst:99
msgid ""
"Return the longest path prefix (taken character-by-character) that is a "
"prefix of all paths in  *list*.  If *list* is empty, return the empty string "
"(``''``)."
msgstr ""
"Возвращает префикс самого длинного пути (посимвольный), который является "
"префиксом всех путей в *списке*. Если *list* пуст, верните пустую строку "
"(``''``)."

#: ../../library/os.path.rst:105
msgid ""
"This function may return invalid paths because it works a character at a "
"time.  To obtain a valid path, see :func:`commonpath`."
msgstr ""
"Эта функция может возвращать недопустимые пути, поскольку она обрабатывает "
"посимвольно. Чтобы получить действительный путь, см. :func:`commonpath`."

#: ../../library/os.path.rst:111
msgid ""
">>> os.path.commonprefix(['/usr/lib', '/usr/local/lib'])\n"
"'/usr/l'\n"
"\n"
">>> os.path.commonpath(['/usr/lib', '/usr/local/lib'])\n"
"'/usr'"
msgstr ""
">>> os.path.commonprefix(['/usr/lib', '/usr/local/lib']) '/usr/л' >>> os."
"path.commonpath(['/usr/lib', '/usr/local/lib']) '/usr'"

#: ../../library/os.path.rst:123
msgid ""
"Return the directory name of pathname *path*.  This is the first element of "
"the pair returned by passing *path* to the function :func:`split`."
msgstr ""
"Возвращает имя каталога с именем пути *path*. Это первый элемент пары, "
"возвращаемой путем передачи *path* функции :func:`split`."

#: ../../library/os.path.rst:132
msgid ""
"Return ``True`` if *path* refers to an existing path or an open file "
"descriptor.  Returns ``False`` for broken symbolic links.  On some "
"platforms, this function may return ``False`` if permission is not granted "
"to execute :func:`os.stat` on the requested file, even if the *path* "
"physically exists."
msgstr ""
"Возвращайте ``True``, если *path* относится к существующему пути или "
"дескриптору открытого файла. Возвращает False для неработающих символических "
"ссылок. На некоторых платформах эта функция может возвращать «False», если "
"не предоставлено разрешение на выполнение :func:`os.stat` для запрошенного "
"файла, даже если *path* физически существует."

#: ../../library/os.path.rst:138
msgid ""
"*path* can now be an integer: ``True`` is returned if it is an  open file "
"descriptor, ``False`` otherwise."
msgstr ""
"*path* теперь может быть целым числом: ``True`` возвращается, если это "
"дескриптор открытого файла, ``False`` в противном случае."

#: ../../library/os.path.rst:148
msgid ""
"Return ``True`` if *path* refers to an existing path, including broken "
"symbolic links.   Equivalent to :func:`exists` on platforms lacking :func:"
"`os.lstat`."
msgstr ""
"Возвращайте ``True``, если *path* относится к существующему пути, включая "
"неработающие символические ссылки. Эквивалент :func:`exists` на платформах, "
"где отсутствует :func:`os.lstat`."

#: ../../library/os.path.rst:160
msgid ""
"On Unix and Windows, return the argument with an initial component of ``~`` "
"or ``~user`` replaced by that *user*'s home directory."
msgstr ""
"В Unix и Windows верните аргумент, заменяя начальный компонент ``~`` или "
"``~user`` домашним каталогом этого *user*."

#: ../../library/os.path.rst:165
msgid ""
"On Unix, an initial ``~`` is replaced by the environment variable :envvar:"
"`HOME` if it is set; otherwise the current user's home directory is looked "
"up in the password directory through the built-in module :mod:`pwd`. An "
"initial ``~user`` is looked up directly in the password directory."
msgstr ""
"В Unix начальная переменная ``~`` заменяется переменной среды :envvar:"
"`HOME`, если она установлена; в противном случае домашний каталог текущего "
"пользователя ищется в каталоге паролей с помощью встроенного модуля :mod:"
"`pwd`. Исходный ``~user`` ищется непосредственно в каталоге паролей."

#: ../../library/os.path.rst:170
msgid ""
"On Windows, :envvar:`USERPROFILE` will be used if set, otherwise a "
"combination of :envvar:`HOMEPATH` and :envvar:`HOMEDRIVE` will be used.  An "
"initial ``~user`` is handled by checking that the last directory component "
"of the current user's home directory matches :envvar:`USERNAME`, and "
"replacing it if so."
msgstr ""
"В Windows будет использоваться :envvar:`USERPROFILE`, если он установлен, в "
"противном случае будет использоваться комбинация :envvar:`HOMEPATH` и :"
"envvar:`HOMEDRIVE`. Начальный ``~user`` обрабатывается путем проверки "
"соответствия последнего компонента домашнего каталога текущего пользователя :"
"envvar:`USERNAME` и его замены, если это так."

#: ../../library/os.path.rst:175
msgid ""
"If the expansion fails or if the path does not begin with a tilde, the path "
"is returned unchanged."
msgstr ""
"Если раскрытие завершается неудачей или путь не начинается с тильды, путь "
"возвращается без изменений."

#: ../../library/os.path.rst:181
msgid "No longer uses :envvar:`HOME` on Windows."
msgstr "Больше не использует :envvar:`HOME` в Windows."

#: ../../library/os.path.rst:190
msgid ""
"Return the argument with environment variables expanded.  Substrings of the "
"form ``$name`` or ``${name}`` are replaced by the value of environment "
"variable *name*.  Malformed variable names and references to non-existing "
"variables are left unchanged."
msgstr ""
"Верните аргумент с расширенными переменными среды. Подстроки вида ``$name`` "
"или ``${name}`` заменяются значением переменной среды *name*. Неверные имена "
"переменных и ссылки на несуществующие переменные остаются неизменными."

#: ../../library/os.path.rst:195
msgid ""
"On Windows, ``%name%`` expansions are supported in addition to ``$name`` and "
"``${name}``."
msgstr ""
"В Windows `` %n Расширения ame%`` поддерживаются в дополнение к ``$name`` и "
"``${name}``."

#: ../../library/os.path.rst:204
msgid ""
"Return the time of last access of *path*.  The return value is a floating-"
"point number giving the number of seconds since the epoch (see the  :mod:"
"`time` module).  Raise :exc:`OSError` if the file does not exist or is "
"inaccessible."
msgstr ""
"Возвращает время последнего доступа к *path*. Возвращаемое значение "
"представляет собой число с плавающей запятой, указывающее количество секунд, "
"прошедших с начала эпохи (см. модуль :mod:`time`). Поднимите :exc:`OSError`, "
"если файл не существует или недоступен."

#: ../../library/os.path.rst:211
msgid ""
"Return the time of last modification of *path*.  The return value is a "
"floating-point number giving the number of seconds since the epoch (see "
"the  :mod:`time` module). Raise :exc:`OSError` if the file does not exist or "
"is inaccessible."
msgstr ""
"Возвращает время последней модификации *path*. Возвращаемое значение "
"представляет собой число с плавающей запятой, указывающее количество секунд, "
"прошедших с начала эпохи (см. модуль :mod:`time`). Поднимите :exc:`OSError`, "
"если файл не существует или недоступен."

#: ../../library/os.path.rst:221
msgid ""
"Return the system's ctime which, on some systems (like Unix) is the time of "
"the last metadata change, and, on others (like Windows), is the creation "
"time for *path*. The return value is a number giving the number of seconds "
"since the epoch (see the  :mod:`time` module).  Raise :exc:`OSError` if the "
"file does not exist or is inaccessible."
msgstr ""
"Возвращает системное время, которое в некоторых системах (например, Unix) "
"является временем последнего изменения метаданных, а в других (например, "
"Windows) — временем создания *path*. Возвращаемое значение — это число, "
"обозначающее количество секунд, прошедших с эпохи (см. модуль :mod:`time`). "
"Поднимите :exc:`OSError`, если файл не существует или недоступен."

#: ../../library/os.path.rst:233
msgid ""
"Return the size, in bytes, of *path*.  Raise :exc:`OSError` if the file does "
"not exist or is inaccessible."
msgstr ""
"Возвращает размер *path* в байтах. Поднимите :exc:`OSError`, если файл не "
"существует или недоступен."

#: ../../library/os.path.rst:242
msgid ""
"Return ``True`` if *path* is an absolute pathname.  On Unix, that means it "
"begins with a slash, on Windows that it begins with two (back)slashes, or a "
"drive letter, colon, and (back)slash together."
msgstr ""
"Верните ``True``, если *path* является абсолютным путем. В Unix это "
"означает, что он начинается с косой черты, в Windows — с двух (обратных) "
"косых черт или буквы диска, двоеточия и (обратной) косой черты вместе."

#: ../../library/os.path.rst:249
msgid ""
"On Windows, returns ``False`` if the given path starts with exactly one "
"(back)slash."
msgstr ""
"В Windows возвращает «False», если заданный путь начинается ровно с одной "
"(обратной) косой черты."

#: ../../library/os.path.rst:256
msgid ""
"Return ``True`` if *path* is an :func:`existing <exists>` regular file. This "
"follows symbolic links, so both :func:`islink` and :func:`isfile` can be "
"true for the same path."
msgstr ""
"Возвращает ``True``, если *path* является :func:`existing <exists>` обычным "
"файлом. Это следует за символическими ссылками, поэтому оба :func:`islink` "
"и :func:`isfile` могут быть истинными для одного и того же пути."

#: ../../library/os.path.rst:266
msgid ""
"Return ``True`` if *path* is an :func:`existing <exists>` directory.  This "
"follows symbolic links, so both :func:`islink` and :func:`isdir` can be true "
"for the same path."
msgstr ""
"Возвращает ``True``, если *path* является существующим каталогом <exists>`. "
"Это следует за символическими ссылками, поэтому оба :func:`islink` и :func:"
"`isdir` могут быть истинными для одного и того же пути."

#: ../../library/os.path.rst:276
msgid ""
"Return ``True`` if *path* refers to an :func:`existing <lexists>` directory "
"entry that is a junction.  Always return ``False`` if junctions are not "
"supported on the current platform."
msgstr ""
"Возвращайте ``True``, если *path* относится к существующей записи каталога "
"<lexists>`, которая является соединением. Всегда возвращайте False, если "
"соединения не поддерживаются на текущей платформе."

#: ../../library/os.path.rst:285
msgid ""
"Return ``True`` if *path* refers to an :func:`existing <exists>` directory "
"entry that is a symbolic link.  Always ``False`` if symbolic links are not "
"supported by the Python runtime."
msgstr ""
"Возвращает ``True``, если *path* относится к существующей записи каталога "
"<exists>`, которая является символической ссылкой. Всегда ``False``, если "
"символические ссылки не поддерживаются средой выполнения Python."

#: ../../library/os.path.rst:295
msgid ""
"Return ``True`` if pathname *path* is a :dfn:`mount point`: a point in a "
"file system where a different file system has been mounted.  On POSIX, the "
"function checks whether *path*'s parent, :file:`{path}/..`, is on a "
"different device than *path*, or whether :file:`{path}/..` and *path* point "
"to the same i-node on the same device --- this should detect mount points "
"for all Unix and POSIX variants.  It is not able to reliably detect bind "
"mounts on the same filesystem. On Linux systems, it will always return "
"``True`` for btrfs subvolumes, even if they aren't mount points. On Windows, "
"a drive letter root and a share UNC are always mount points, and for any "
"other path ``GetVolumePathName`` is called to see if it is different from "
"the input path."
msgstr ""

#: ../../library/os.path.rst:306
msgid "Added support for detecting non-root mount points on Windows."
msgstr ""
"Добавлена ​​поддержка обнаружения точек монтирования без полномочий root в "
"Windows."

#: ../../library/os.path.rst:315
msgid ""
"Return ``True`` if pathname *path* is located on a Windows Dev Drive. A Dev "
"Drive is optimized for developer scenarios, and offers faster performance "
"for reading and writing files. It is recommended for use for source code, "
"temporary build directories, package caches, and other IO-intensive "
"operations."
msgstr ""
"Верните ``True``, если путь *path* находится на диске разработчика Windows. "
"Dev Drive оптимизирован для сценариев разработки и обеспечивает более "
"высокую производительность при чтении и записи файлов. Рекомендуется "
"использовать для исходного кода, временных каталогов сборки, кэшей пакетов и "
"других операций с интенсивным вводом-выводом."

#: ../../library/os.path.rst:321
msgid ""
"May raise an error for an invalid path, for example, one without a "
"recognizable drive, but returns ``False`` on platforms that do not support "
"Dev Drives. See `the Windows documentation <https://learn.microsoft.com/"
"windows/dev-drive/>`_ for information on enabling and creating Dev Drives."
msgstr ""
"Может вызвать ошибку из-за недопустимого пути, например, без распознаваемого "
"диска, но возвращает «False» на платформах, которые не поддерживают Dev "
"Drives. См. `документацию Windows <https://learn.microsoft.com/windows/dev-"
"drive/>`_ для получения информации о включении и создании Dev Drives."

#: ../../library/os.path.rst:328
msgid ""
"The function is now available on all platforms, and will always return "
"``False`` on those that have no support for Dev Drives"
msgstr ""
"Функция теперь доступна на всех платформах и всегда будет возвращать "
"значение «False» на тех, которые не поддерживают Dev Drives."

#: ../../library/os.path.rst:334
msgid "Return ``True`` if *path* is a reserved pathname on the current system."
msgstr ""
"Верните ``True``, если *path* — зарезервированный путь в текущей системе."

#: ../../library/os.path.rst:336
msgid ""
"On Windows, reserved filenames include those that end with a space or dot; "
"those that contain colons (i.e. file streams such as \"name:stream\"), "
"wildcard characters (i.e. ``'*?\"<>'``), pipe, or ASCII control characters; "
"as well as DOS device names such as \"NUL\", \"CON\", \"CONIN$\", \"CONOUT$"
"\", \"AUX\", \"PRN\", \"COM1\", and \"LPT1\"."
msgstr ""
"В Windows зарезервированные имена файлов включают те, которые заканчиваются "
"пробелом или точкой; те, которые содержат двоеточия (т. е. файловые потоки, "
"такие как «имя:поток»), подстановочные знаки (т. е. ``'*?\"<>'``), "
"вертикальные или управляющие символы ASCII; а также имена устройств DOS, "
"такие как \" NUL\", \"CON\", \"CONIN$\", \"CONOUT$\", \"AUX\", \"PRN\", "
"\"COM1\" и \"LPT1\"."

#: ../../library/os.path.rst:344
msgid ""
"This function approximates rules for reserved paths on most Windows systems. "
"These rules change over time in various Windows releases. This function may "
"be updated in future Python releases as changes to the rules become broadly "
"available."
msgstr ""
"Эта функция аппроксимирует правила для зарезервированных путей в большинстве "
"систем Windows. Эти правила со временем меняются в различных выпусках "
"Windows. Эта функция может быть обновлена ​​в будущих выпусках Python, когда "
"изменения в правилах станут широко доступны."

#: ../../library/os.path.rst:349
msgid "Availability"
msgstr "Доступность"

#: ../../library/os.path.rst:356
msgid ""
"Join one or more path segments intelligently.  The return value is the "
"concatenation of *path* and all members of *\\*paths*, with exactly one "
"directory separator following each non-empty part, except the last. That is, "
"the result will only end in a separator if the last part is either empty or "
"ends in a separator. If a segment is an absolute path (which on Windows "
"requires both a drive and a root), then all previous segments are ignored "
"and joining continues from the absolute path segment."
msgstr ""
"Разумно присоединяйтесь к одному или нескольким сегментам пути. Возвращаемое "
"значение представляет собой объединение *path* и всех членов *\\*paths*, с "
"ровно одним разделителем каталогов после каждой непустой части, кроме "
"последней. То есть результат будет заканчиваться разделителем только в том "
"случае, если последняя часть либо пуста, либо заканчивается разделителем. "
"Если сегмент представляет собой абсолютный путь (для которого в Windows "
"требуется как диск, так и корень), то все предыдущие сегменты игнорируются, "
"и присоединение продолжается с сегмента абсолютного пути."

#: ../../library/os.path.rst:364
msgid ""
"On Windows, the drive is not reset when a rooted path segment (e.g., "
"``r'\\foo'``) is encountered. If a segment is on a different drive or is an "
"absolute path, all previous segments are ignored and the drive is reset. "
"Note that since there is a current directory for each drive, ``os.path."
"join(\"c:\", \"foo\")`` represents a path relative to the current directory "
"on drive :file:`C:` (:file:`c:foo`), not :file:`c:\\\\foo`."
msgstr ""
"В Windows диск не сбрасывается при обнаружении корневого сегмента пути "
"(например, ``r'\\foo'``). Если сегмент находится на другом диске или имеет "
"абсолютный путь, все предыдущие сегменты игнорируются и диск сбрасывается. "
"Обратите внимание: поскольку для каждого диска существует текущий каталог, "
"``os.path.join(\"c:\", \"foo\")`` представляет путь относительно текущего "
"каталога на диске :file:`C:` (: file:`c:foo`), а не :file:`c:\\\\foo`."

#: ../../library/os.path.rst:371
msgid "Accepts a :term:`path-like object` for *path* and *paths*."
msgstr "Принимает объект, похожий на путь, для *path* и *paths*."

#: ../../library/os.path.rst:377
msgid ""
"Normalize the case of a pathname.  On Windows, convert all characters in the "
"pathname to lowercase, and also convert forward slashes to backward slashes. "
"On other operating systems, return the path unchanged."
msgstr ""
"Нормализуйте регистр пути. В Windows преобразуйте все символы в имени пути в "
"нижний регистр, а также преобразуйте прямые косые черты в обратные. В других "
"операционных системах верните путь без изменений."

#: ../../library/os.path.rst:387
msgid ""
"Normalize a pathname by collapsing redundant separators and up-level "
"references so that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all "
"become ``A/B``.  This string manipulation may change the meaning of a path "
"that contains symbolic links.  On Windows, it converts forward slashes to "
"backward slashes. To normalize case, use :func:`normcase`."
msgstr ""
"Нормализуйте путь, свернув избыточные разделители и ссылки верхнего уровня, "
"чтобы ``A//B``, ``A/B/``, ``A/./B`` и ``A/foo/.. /B`` все становятся ``A/"
"B``. Эта манипуляция со строками может изменить значение пути, содержащего "
"символические ссылки. В Windows он преобразует косую черту в обратную. Чтобы "
"нормализовать регистр, используйте :func:`normcase`."

#: ../../library/os.path.rst:394
msgid ""
"On POSIX systems, in accordance with `IEEE Std 1003.1 2013 Edition; 4.13 "
"Pathname Resolution <https://pubs.opengroup.org/onlinepubs/9699919799/"
"basedefs/V1_chap04.html#tag_04_13>`_, if a pathname begins with exactly two "
"slashes, the first component following the leading characters may be "
"interpreted in an implementation-defined manner, although more than two "
"leading characters shall be treated as a single character."
msgstr ""
"В системах POSIX в соответствии со стандартом IEEE Std 1003.1, издание 2013 "
"г.; 4.13 Разрешение пути <https://pubs.opengroup.org/onlinepubs/9699919799/"
"basedefs/V1_chap04.html#tag_04_13>`_, если имя пути начинается ровно с двух "
"косых черт, первый компонент, следующий за ведущими символами, может "
"интерпретироваться как способом, определяемым реализацией, хотя более двух "
"начальных символов должны рассматриваться как один символ."

#: ../../library/os.path.rst:407
msgid ""
"Return the canonical path of the specified filename, eliminating any "
"symbolic links encountered in the path (if they are supported by the "
"operating system). On Windows, this function will also resolve MS-DOS (also "
"called 8.3) style names such as ``C:\\\\PROGRA~1`` to ``C:\\\\Program "
"Files``."
msgstr ""
"Возвращает канонический путь к указанному имени файла, удаляя все "
"символические ссылки, встречающиеся в пути (если они поддерживаются "
"операционной системой). В Windows эта функция также преобразует имена стилей "
"MS-DOS (также называемые 8.3), такие как ``C:\\\\PROGRA~1``, в ``C:\\"
"\\Program Files``."

#: ../../library/os.path.rst:412
msgid ""
"By default, the path is evaluated up to the first component that does not "
"exist, is a symlink loop, or whose evaluation raises :exc:`OSError`. All "
"such components are appended unchanged to the existing part of the path."
msgstr ""

#: ../../library/os.path.rst:416
msgid ""
"Some errors that are handled this way include \"access denied\", \"not a "
"directory\", or \"bad argument to internal function\". Thus, the resulting "
"path may be missing or inaccessible, may still contain links or loops, and "
"may traverse non-directories."
msgstr ""

#: ../../library/os.path.rst:421
msgid "This behavior can be modified by keyword arguments:"
msgstr ""

#: ../../library/os.path.rst:423
msgid ""
"If *strict* is ``True``, the first error encountered when evaluating the "
"path is re-raised. In particular, :exc:`FileNotFoundError` is raised if "
"*path* does not exist, or another :exc:`OSError` if it is otherwise "
"inaccessible."
msgstr ""

#: ../../library/os.path.rst:428
msgid ""
"If *strict* is :py:data:`os.path.ALLOW_MISSING`, errors other than :exc:"
"`FileNotFoundError` are re-raised (as with ``strict=True``). Thus, the "
"returned path will not contain any symbolic links, but the named file and "
"some of its parent directories may be missing."
msgstr ""

#: ../../library/os.path.rst:434
msgid ""
"This function emulates the operating system's procedure for making a path "
"canonical, which differs slightly between Windows and UNIX with respect to "
"how links and subsequent path components interact."
msgstr ""
"Эта функция эмулирует процедуру операционной системы для создания "
"канонического пути, которая немного отличается в Windows и UNIX в отношении "
"взаимодействия ссылок и последующих компонентов пути."

#: ../../library/os.path.rst:438
msgid ""
"Operating system APIs make paths canonical as needed, so it's not normally "
"necessary to call this function."
msgstr ""
"API-интерфейсы операционной системы при необходимости делают пути "
"каноническими, поэтому обычно нет необходимости вызывать эту функцию."

#: ../../library/os.path.rst:444
msgid "Symbolic links and junctions are now resolved on Windows."
msgstr "Символические ссылки и соединения теперь разрешаются в Windows."

#: ../../library/os.path.rst:447
msgid "The *strict* parameter was added."
msgstr "Добавлен параметр *strict*."

#: ../../library/os.path.rst:450
msgid ""
"The :py:data:`~os.path.ALLOW_MISSING` value for the *strict* parameter was "
"added."
msgstr ""

#: ../../library/os.path.rst:456
msgid "Special value used for the *strict* argument in :func:`realpath`."
msgstr ""

#: ../../library/os.path.rst:462
msgid ""
"Return a relative filepath to *path* either from the current directory or "
"from an optional *start* directory.  This is a path computation:  the "
"filesystem is not accessed to confirm the existence or nature of *path* or "
"*start*.  On Windows, :exc:`ValueError` is raised when *path* and *start* "
"are on different drives."
msgstr ""
"Возвращает относительный путь к файлу *path* либо из текущего каталога, либо "
"из дополнительного *начального* каталога. Это вычисление пути: к файловой "
"системе не осуществляется доступ для подтверждения существования или природы "
"*path* или *start*. В Windows :exc:`ValueError` возникает, когда *path* и "
"*start* находятся на разных дисках."

#: ../../library/os.path.rst:468
msgid "*start* defaults to :data:`os.curdir`."
msgstr "*start* по умолчанию имеет значение :data:`os.curdir`."

#: ../../library/os.path.rst:476
msgid ""
"Return ``True`` if both pathname arguments refer to the same file or "
"directory. This is determined by the device number and i-node number and "
"raises an exception if an :func:`os.stat` call on either pathname fails."
msgstr ""
"Верните True, если оба аргумента пути относятся к одному и тому же файлу или "
"каталогу. Это определяется номером устройства и номером i-узла и вызывает "
"исключение, если вызов :func:`os.stat` по любому пути завершается неудачно."

#: ../../library/os.path.rst:480 ../../library/os.path.rst:494
#: ../../library/os.path.rst:508
msgid "Added Windows support."
msgstr "Добавлена поддержка Windows."

#: ../../library/os.path.rst:483
msgid "Windows now uses the same implementation as all other platforms."
msgstr ""
"Windows теперь использует ту же реализацию, что и все другие платформы."

#: ../../library/os.path.rst:492
msgid ""
"Return ``True`` if the file descriptors *fp1* and *fp2* refer to the same "
"file."
msgstr ""
"Возвращайте ``True``, если файловые дескрипторы *fp1* и *fp2* относятся к "
"одному и тому же файлу."

#: ../../library/os.path.rst:503
msgid ""
"Return ``True`` if the stat tuples *stat1* and *stat2* refer to the same "
"file. These structures may have been returned by :func:`os.fstat`, :func:`os."
"lstat`, or :func:`os.stat`.  This function implements the underlying "
"comparison used by :func:`samefile` and :func:`sameopenfile`."
msgstr ""
"Верните True, если кортежи статистики *stat1* и *stat2* относятся к одному и "
"тому же файлу. Эти структуры могли быть возвращены функциями :func:`os."
"fstat`, :func:`os.lstat` или :func:`os.stat`. Эта функция реализует базовое "
"сравнение, используемое :func:`samefile` и :func:`sameopenfile`."

#: ../../library/os.path.rst:517
msgid ""
"Split the pathname *path* into a pair, ``(head, tail)`` where *tail* is the "
"last pathname component and *head* is everything leading up to that.  The "
"*tail* part will never contain a slash; if *path* ends in a slash, *tail* "
"will be empty.  If there is no slash in *path*, *head* will be empty.  If "
"*path* is empty, both *head* and *tail* are empty.  Trailing slashes are "
"stripped from *head* unless it is the root (one or more slashes only).  In "
"all cases, ``join(head, tail)`` returns a path to the same location as "
"*path* (but the strings may differ).  Also see the functions :func:`dirname` "
"and :func:`basename`."
msgstr ""
"Разделите путь *path* на пару ``(head, Tail)``, где *tail* — это последний "
"компонент пути, а *head* — все, что к нему ведет. Часть *хвост* никогда не "
"будет содержать косую черту; если *path* заканчивается косой чертой, *tail* "
"будет пустым. Если в *path* нет косой черты, *head* будет пустым. Если "
"*path* пуст, *head* и *tail* пусты. Конечные косые черты удаляются из "
"*head*, если только это не корень (только одна или несколько косых черт). Во "
"всех случаях ``join(head, Tail)`` возвращает путь к тому же местоположению, "
"что и *path* (но строки могут отличаться). Также см. функции :func:`dirname` "
"и :func:`basename`."

#: ../../library/os.path.rst:533
msgid ""
"Split the pathname *path* into a pair ``(drive, tail)`` where *drive* is "
"either a mount point or the empty string.  On systems which do not use drive "
"specifications, *drive* will always be the empty string.  In all cases, "
"``drive + tail`` will be the same as *path*."
msgstr ""
"Разделите путь *path* на пару ``(диск, хвост)``, где *диск* — это либо точка "
"монтирования, либо пустая строка. В системах, которые не используют "
"спецификации дисков, *диск* всегда будет пустой строкой. Во всех случаях "
"``drive + Tail`` будет таким же, как *path*."

#: ../../library/os.path.rst:538
msgid ""
"On Windows, splits a pathname into drive/UNC sharepoint and relative path."
msgstr ""
"В Windows разделяет путь на диск/точку доступа UNC и относительный путь."

#: ../../library/os.path.rst:540
msgid ""
"If the path contains a drive letter, drive will contain everything up to and "
"including the colon::"
msgstr ""
"Если путь содержит букву диска, диск будет содержать все, включая двоеточие::"

#: ../../library/os.path.rst:543
msgid ""
">>> splitdrive(\"c:/dir\")\n"
"(\"c:\", \"/dir\")"
msgstr ""
">>> splitdrive(\"c:/dir\")\n"
"(\"c:\", \"/dir\")"

#: ../../library/os.path.rst:546
msgid ""
"If the path contains a UNC path, drive will contain the host name and share::"
msgstr ""
"Если путь содержит путь UNC, диск будет содержать имя хоста и общий ресурс::"

#: ../../library/os.path.rst:549
msgid ""
">>> splitdrive(\"//host/computer/dir\")\n"
"(\"//host/computer\", \"/dir\")"
msgstr ""
">>> splitdrive(\"//host/computer/dir\")\n"
"(\"//host/computer\", \"/dir\")"

#: ../../library/os.path.rst:558
msgid ""
"Split the pathname *path* into a 3-item tuple ``(drive, root, tail)`` where "
"*drive* is a device name or mount point, *root* is a string of separators "
"after the drive, and *tail* is everything after the root. Any of these items "
"may be the empty string. In all cases, ``drive + root + tail`` will be the "
"same as *path*."
msgstr ""
"Разделите имя пути *path* на кортеж из трех элементов ``(диск, корень, "
"хвост)``, где *диск* — это имя устройства или точка монтирования, *root* — "
"это строка разделителей после диска, а *tail * это все после рута. Любой из "
"этих элементов может быть пустой строкой. Во всех случаях ``диск + корень + "
"хвост`` будет таким же, как *path*."

#: ../../library/os.path.rst:564
msgid ""
"On POSIX systems, *drive* is always empty. The *root* may be empty (if "
"*path* is relative), a single forward slash (if *path* is absolute), or two "
"forward slashes (implementation-defined per `IEEE Std 1003.1-2017; 4.13 "
"Pathname Resolution <https://pubs.opengroup.org/onlinepubs/9699919799/"
"basedefs/V1_chap04.html#tag_04_13>`_.) For example::"
msgstr ""
"В системах POSIX *диск* всегда пуст. *Корень* может быть пустым (если *путь* "
"является относительным), одной косой чертой (если *путь* является "
"абсолютным) или двумя косыми чертами (определяется реализацией согласно "
"`IEEE Std 1003.1-2017; 4.13 Разрешение пути <https) ://pubs.opengroup.org/"
"onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_13>`_.) Например::"

#: ../../library/os.path.rst:570
msgid ""
">>> splitroot('/home/sam')\n"
"('', '/', 'home/sam')\n"
">>> splitroot('//home/sam')\n"
"('', '//', 'home/sam')\n"
">>> splitroot('///home/sam')\n"
"('', '/', '//home/sam')"
msgstr ""
">>> splitroot('/home/sam')\n"
"('', '/', 'home/sam')\n"
">>> splitroot('//home/sam')\n"
"('', '//', 'home/sam')\n"
">>> splitroot('///home/sam')\n"
"('', '/', '//home/sam')"

#: ../../library/os.path.rst:577
msgid ""
"On Windows, *drive* may be empty, a drive-letter name, a UNC share, or a "
"device name. The *root* may be empty, a forward slash, or a backward slash. "
"For example::"
msgstr ""
"В Windows *диск* может быть пустым, это может быть имя диска, общий ресурс "
"UNC или имя устройства. *Корень* может быть пустым, может быть прямой или "
"обратной косой чертой. Например::"

#: ../../library/os.path.rst:581
msgid ""
">>> splitroot('C:/Users/Sam')\n"
"('C:', '/', 'Users/Sam')\n"
">>> splitroot('//Server/Share/Users/Sam')\n"
"('//Server/Share', '/', 'Users/Sam')"
msgstr ""
">>> splitroot('C:/Users/Sam')\n"
"('C:', '/', 'Users/Sam')\n"
">>> splitroot('//Server/Share/Users/Sam')\n"
"('//Server/Share', '/', 'Users/Sam')"

#: ../../library/os.path.rst:591
msgid ""
"Split the pathname *path* into a pair ``(root, ext)``  such that ``root + "
"ext == path``, and the extension, *ext*, is empty or begins with a period "
"and contains at most one period."
msgstr ""
"Разделите имя пути *path* на пару ``(root, ext)`` так, чтобы ``root + ext == "
"path``, а расширение *ext* было пустым или начиналось с точки и содержало не "
"более один период."

#: ../../library/os.path.rst:595
msgid "If the path contains no extension, *ext* will be ``''``::"
msgstr "Если путь не содержит расширения, *ext* будет ``''``::"

#: ../../library/os.path.rst:597
msgid ""
">>> splitext('bar')\n"
"('bar', '')"
msgstr ""
">>> splitext('bar')\n"
"('bar', '')"

#: ../../library/os.path.rst:600
msgid ""
"If the path contains an extension, then *ext* will be set to this extension, "
"including the leading period. Note that previous periods will be ignored::"
msgstr ""
"Если путь содержит расширение, то *ext* будет установлено для этого "
"расширения, включая начальную точку. Обратите внимание, что предыдущие "
"периоды будут игнорироваться::"

#: ../../library/os.path.rst:603
msgid ""
">>> splitext('foo.bar.exe')\n"
"('foo.bar', '.exe')\n"
">>> splitext('/foo/bar.exe')\n"
"('/foo/bar', '.exe')"
msgstr ""
">>> splitext('foo.bar.exe')\n"
"('foo.bar', '.exe')\n"
">>> splitext('/foo/bar.exe')\n"
"('/foo/bar', '.exe')"

#: ../../library/os.path.rst:608
msgid ""
"Leading periods of the last component of the path are considered to be part "
"of the root::"
msgstr "Ведущие периоды последней компоненты пути считаются частью корня:"

#: ../../library/os.path.rst:611
msgid ""
">>> splitext('.cshrc')\n"
"('.cshrc', '')\n"
">>> splitext('/foo/....jpg')\n"
"('/foo/....jpg', '')"
msgstr ""
">>> splitext('.cshrc')\n"
"('.cshrc', '')\n"
">>> splitext('/foo/....jpg')\n"
"('/foo/....jpg', '')"

#: ../../library/os.path.rst:622
msgid ""
"``True`` if arbitrary Unicode strings can be used as file names (within "
"limitations imposed by the file system)."
msgstr ""
"``True``, если в качестве имен файлов можно использовать произвольные строки "
"Unicode (в пределах ограничений, налагаемых файловой системой)."

#: ../../library/os.path.rst:10
msgid "path"
msgstr "путь"

#: ../../library/os.path.rst:10
msgid "operations"
msgstr "операции"

#: ../../library/os.path.rst:156
msgid "~ (tilde)"
msgstr "~ (тильда)"

#: ../../library/os.path.rst:156
msgid "home directory expansion"
msgstr "расширение домашнего каталога"

#: ../../library/os.path.rst:163
msgid "module"
msgstr "модуль"

#: ../../library/os.path.rst:163
msgid "pwd"
msgstr "pwd"

#: ../../library/os.path.rst:184
msgid "$ (dollar)"
msgstr "$ (доллар)"

#: ../../library/os.path.rst:184
msgid "environment variables expansion"
msgstr "расширение переменных среды"

#: ../../library/os.path.rst:184
msgid "% (percent)"
msgstr "% (процент)"

#: ../../library/os.path.rst:184
msgid "environment variables expansion (Windows)"
msgstr "расширение переменных среды (Windows)"
